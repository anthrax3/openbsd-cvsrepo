head	1.52;
access;
symbols
	OPENBSD_6_2_BASE:1.52
	OPENBSD_6_1:1.51.0.4
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.50.0.12
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.8
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.50.0.10
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.50.0.6
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.50.0.4
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.48.0.2
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.44.0.2
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.8
	OPENBSD_5_0:1.43.0.6
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.4
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.40.0.6
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.40.0.2
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.39.0.4
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.30.0.6
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.4
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.28.0.4
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.26.0.4
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.52
date	2017.06.21.00.11.36;	author espie;	state Exp;
branches;
next	1.51;
commitid	Z2SsnRh4j4NVjat6;

1.51
date	2016.10.21.16.12.38;	author espie;	state Exp;
branches;
next	1.50;
commitid	aLVdeKrJ0t5upS3l;

1.50
date	2013.11.22.15.47.35;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2013.04.23.14.32.53;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2012.11.24.11.04.55;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2012.10.18.17.54.43;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2012.10.11.14.56.17;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2012.10.09.19.51.50;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2012.03.22.13.47.12;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.19.19.46.43;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2010.04.25.13.59.53;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.11.00.12.10;	author fgsch;	state Exp;
branches;
next	1.40;

1.40
date	2008.11.24.16.23.04;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.18.09.44.35;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.17.08.36.57;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.16.12.30.35;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2007.07.17.10.54.46;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2007.07.08.17.44.20;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2007.03.20.03.50.39;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2007.01.04.18.01.32;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.20.23.10.19;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.07.13.11.35;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.11.21.12.11;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.17.16.45.02;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.29.12.53.39;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.23.12.34.41;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.03.13.41.02;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.17.14.39.07;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.14.13.46.44;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.14.13.32.06;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.17.23.54.26;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.23.16.21.43;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.17.14.38.14;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.10.01.41.05;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.17.23.50.45;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.26.16.21.32;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.08.09.45.15;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	99.12.19.00.04.25;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	99.12.18.21.53.32;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.12.16.17.02.45;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.12.16.16.58.15;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	99.12.16.16.52.11;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	99.12.16.16.41.41;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	99.12.09.18.18.24;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	99.12.06.22.28.44;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	99.12.06.22.24.31;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	98.12.05.00.06.27;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.30.21.08.52;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.36.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.52
log
@error out if an exists condition tests an empty path, because that makes
zero sense.

this would have caught DEPENDSFILE in gnu/cc/cc_tools

okay guenther@@,  also tested by krw@@
@
text
@/*	$OpenBSD: cond.c,v 1.51 2016/10/21 16:12:38 espie Exp $	*/
/*	$NetBSD: cond.c,v 1.7 1996/11/06 17:59:02 christos Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ohash.h>
#include "config.h"
#include "defines.h"
#include "dir.h"
#include "buf.h"
#include "cond.h"
#include "cond_int.h"
#include "condhashconsts.h"
#include "error.h"
#include "var.h"
#include "varname.h"
#include "targ.h"
#include "lowparse.h"
#include "str.h"
#include "main.h"
#include "gnode.h"
#include "lst.h"


/* The parsing of conditional expressions is based on this grammar:
 *	E -> F || E
 *	E -> F
 *	F -> T && F
 *	F -> T
 *	T -> defined(variable)
 *	T -> make(target)
 *	T -> exists(file)
 *	T -> empty(varspec)
 *	T -> target(name)
 *	T -> commands(name)
 *	T -> symbol
 *	T -> $(varspec) op value
 *	T -> $(varspec) == "string"
 *	T -> $(varspec) != "string"
 *	T -> "string" == "string"
 *	T -> "string" != "string"
 *	T -> number op number
 *	T -> ( E )
 *	T -> ! T
 *	op -> == | != | > | < | >= | <=
 *
 * 'symbol' is some other symbol to which the default function (condDefProc)
 * is applied.
 *
 * Tokens are scanned from the 'condExpr' string. The scanner (CondToken)
 * will return And for '&' and '&&', Or for '|' and '||', Not for '!',
 * LParen for '(', RParen for ')' and will evaluate the other terminal
 * symbols, using either the default function or the function given in the
 * terminal, and return the result as either true or False.
 *
 * All Non-Terminal functions (CondE, CondF and CondT) return Err on error.  */
typedef enum {
	False = 0, True = 1, And, Or, Not, LParen, RParen, EndOfFile, None, Err
} Token;

/*-
 * Structures to handle elegantly the different forms of #if's. The
 * last two fields are stored in condInvert and condDefProc, respectively.
 */
static bool CondGetArg(const char **, struct Name *,
    const char *, bool);
static bool CondDoDefined(struct Name *);
static bool CondDoMake(struct Name *);
static bool CondDoExists(struct Name *);
static bool CondDoTarget(struct Name *);
static bool CondDoTargetWithCommands(struct Name *);
static bool CondCvtArg(const char *, double *);
static Token CondToken(bool);
static Token CondT(bool);
static Token CondF(bool);
static Token CondE(bool);
static Token CondHandleVarSpec(bool);
static Token CondHandleDefault(bool);
static Token CondHandleComparison(char *, bool, bool);
static Token CondHandleString(bool);
static Token CondHandleNumber(bool);
static const char *find_cond(const char *);


struct If {
	bool isElse;			/* true for else forms */
	bool doNot;			/* true for embedded negation */
	bool (*defProc)(struct Name *); /* function to apply */
};

static struct If ifs[] = {
	{ false,false,	CondDoDefined },	/* if, ifdef */
	{ false,true,	CondDoDefined },	/* ifndef */
	{ false,false,	CondDoMake },		/* ifmake */
	{ false,true,	CondDoMake },		/* ifnmake */
	{ true,	false,	CondDoDefined },	/* elif, elifdef */
	{ true,	true,	CondDoDefined },	/* elifndef */
	{ true,	false,	CondDoMake },		/* elifmake */
	{ true,	true,	CondDoMake },		/* elifnmake */
	{ true,	false,	NULL }
};

#define COND_IF_INDEX		0
#define COND_IFDEF_INDEX	0
#define COND_IFNDEF_INDEX	1
#define COND_IFMAKE_INDEX	2
#define COND_IFNMAKE_INDEX	3
#define COND_ELIF_INDEX		4
#define COND_ELIFDEF_INDEX	4
#define COND_ELIFNDEF_INDEX	5
#define COND_ELIFMAKE_INDEX	6
#define COND_ELIFNMAKE_INDEX	7
#define COND_ELSE_INDEX		8

static bool condInvert;		/* Invert the default function */
static bool (*condDefProc)(struct Name *);
				/* Default function to apply */
static const char *condExpr;	/* The expression to parse */
static Token condPushBack=None;	/* Single push-back token used in parsing */

#define MAXIF 30		/* greatest depth of #if'ing */

static struct {
	bool 	value;
	Location origin;
} condStack[MAXIF];		/* Stack of conditionals */

static int condTop = MAXIF;	/* Top-most conditional */
static int skipIfLevel=0;	/* Depth of skipped conditionals */
static bool skipLine = false;	/* Whether the parse module is skipping lines */

static const char *
find_cond(const char *p)
{
	for (;;p++) {
		/* XXX: when *p == '\0', strchr() returns !NULL */
		if (strchr(" \t)&|$", *p) != NULL)
			return p;
	}
}


/*-
 *-----------------------------------------------------------------------
 * CondGetArg --
 *	Find the argument of a built-in function.
 *
 * Results:
 *	true if evaluation went okay
 *
 * Side Effects:
 *	The line pointer is set to point to the closing parenthesis of the
 *	function call. The argument is filled.
 *-----------------------------------------------------------------------
 */
static bool
CondGetArg(const char **linePtr, struct Name *arg, const char *func,
    bool parens) /* true if arg should be bounded by parens */
{
	const char *cp;

	cp = *linePtr;
	/* Set things up to return faster in case of problem */
	arg->s = cp;
	arg->e = cp;
	arg->tofree = false;

	/* make and defined are not really keywords, so if CondGetArg doesn't
	 * work...
	 */
	if (parens) {
		while (ISSPACE(*cp))
			cp++;
		if (*cp == '(')
			cp++;
		else
			return false;
	}

	if (*cp == '\0')
		return false;

	while (ISSPACE(*cp))
		cp++;

	cp = VarName_Get(cp, arg, NULL, true, find_cond);

	while (ISSPACE(*cp))
		cp++;
	if (parens) {
		if (*cp == ')')
			cp++;
		else {
			Parse_Error(PARSE_WARNING,
			    "Missing closing parenthesis for %s()", func);
			return false;
	    	}
	}

	*linePtr = cp;
	return true;
}

/*-
 *-----------------------------------------------------------------------
 * CondDoDefined --
 *	Handle the 'defined' function for conditionals.
 *
 * Results:
 *	true if the given variable is defined.
 *-----------------------------------------------------------------------
 */
static bool
CondDoDefined(struct Name *arg)
{
	return Var_Definedi(arg->s, arg->e);
}

/*-
 *-----------------------------------------------------------------------
 * CondDoMake --
 *	Handle the 'make' function for conditionals.
 *
 * Results:
 *	true if the given target is being made.
 *-----------------------------------------------------------------------
 */
static bool
CondDoMake(struct Name *arg)
{
	LstNode ln;

	for (ln = Lst_First(create); ln != NULL; ln = Lst_Adv(ln)) {
		char *s = Lst_Datum(ln);
		if (Str_Matchi(s, strchr(s, '\0'), arg->s, arg->e))
			return true;
	}

	return false;
}

/*-
 *-----------------------------------------------------------------------
 * CondDoExists --
 *	See if the given file exists.
 *
 * Results:
 *	true if the file exists and false if it does not.
 *-----------------------------------------------------------------------
 */
static bool
CondDoExists(struct Name *arg)
{
	bool result;
	char *path;

	if (arg->s == arg->e)
		Parse_Error(PARSE_FATAL, "Empty file name in .if exists()");

	path = Dir_FindFilei(arg->s, arg->e, defaultPath);
	if (path != NULL) {
		result = true;
		free(path);
	} else {
		result = false;
	}
	return result;
}

/*-
 *-----------------------------------------------------------------------
 * CondDoTarget --
 *	See if the given node exists and is an actual target.
 *
 * Results:
 *	true if the node exists as a target and false if it does not.
 *-----------------------------------------------------------------------
 */
static bool
CondDoTarget(struct Name *arg)
{
	GNode *gn;

	gn = Targ_FindNodei(arg->s, arg->e, TARG_NOCREATE);
	if (gn != NULL && !OP_NOP(gn->type))
		return true;
	else
		return false;
}

/*-
 *-----------------------------------------------------------------------
 * CondDoTargetWithCommands --
 *	See if the given node exists and has commands.
 *
 * Results:
 *	true if the node is complete and false if it does not.
 *-----------------------------------------------------------------------
 */
static bool
CondDoTargetWithCommands(struct Name *arg)
{
	GNode *gn;

	gn = Targ_FindNodei(arg->s, arg->e, TARG_NOCREATE);
	if (gn != NULL && !OP_NOP(gn->type) && (gn->type & OP_HAS_COMMANDS))
		return true;
	else
		return false;
}


/*-
 *-----------------------------------------------------------------------
 * CondCvtArg --
 *	Convert the given number into a double. If the number begins
 *	with 0x, it is interpreted as a hexadecimal integer
 *	and converted to a double from there. All other strings just have
 *	strtod called on them.
 *
 * Results:
 *	Sets 'value' to double value of string.
 *	Returns true if the string was a valid number, false o.w.
 *
 * Side Effects:
 *	Can change 'value' even if string is not a valid number.
 *-----------------------------------------------------------------------
 */
static bool
CondCvtArg(const char *str, double *value)
{
	if (*str == '0' && str[1] == 'x') {
		long i;

		for (str += 2, i = 0; *str; str++) {
			int x;
			if (ISDIGIT(*str))
				x  = *str - '0';
			else if (ISXDIGIT(*str))
				x = 10 + *str - (ISUPPER(*str) ? 'A' : 'a');
			else
				return false;
			i = (i << 4) + x;
		}
		*value = (double) i;
		return true;
	}
	else {
		char *eptr;
		*value = strtod(str, &eptr);
		return *eptr == '\0';
	}
}


static Token
CondHandleNumber(bool doEval)
{
	const char *end;
	char *lhs;

	end = condExpr;
	while (!ISSPACE(*end) && strchr("!=><", *end) == NULL)
		end++;
	lhs = Str_dupi(condExpr, end);
	condExpr = end;
	return CondHandleComparison(lhs, true, doEval);
}

static Token
CondHandleVarSpec(bool doEval)
{
	char *lhs;
	size_t varSpecLen;
	bool doFree;

	/* Parse the variable spec and skip over it, saving its
	 * value in lhs.  */
	lhs = Var_Parse(condExpr, NULL, doEval,&varSpecLen,&doFree);
	if (lhs == var_Error)
		/* Even if !doEval, we still report syntax errors, which
		 * is what getting var_Error back with !doEval means.  */
		return Err;
	condExpr += varSpecLen;

	if (!ISSPACE(*condExpr) &&
		strchr("!=><", *condExpr) == NULL) {
		BUFFER buf;

		Buf_Init(&buf, 0);

		Buf_AddString(&buf, lhs);

		if (doFree)
			free(lhs);

		for (;*condExpr && !ISSPACE(*condExpr); condExpr++)
			Buf_AddChar(&buf, *condExpr);

		lhs = Var_Subst(Buf_Retrieve(&buf), NULL, doEval);
		Buf_Destroy(&buf);
		doFree = true;
	}

	return CondHandleComparison(lhs, doFree, doEval);
}

static Token
CondHandleString(bool doEval)
{
	char *lhs;
	const char *begin;
	BUFFER buf;

	/* find the extent of the string */
	begin = ++condExpr;
	while (*condExpr && *condExpr != '"') {
		condExpr++;
	}

	Buf_Init(&buf, 0);
	Buf_Addi(&buf, begin, condExpr);
	if (*condExpr == '"')
		condExpr++;
	lhs = Var_Subst(Buf_Retrieve(&buf), NULL, doEval);
	Buf_Destroy(&buf);
	return CondHandleComparison(lhs, true, doEval);
}

static Token
CondHandleComparison(char *lhs, bool doFree, bool doEval)
{
	Token t;
	const char *rhs;
	const char *op;

	t = Err;
	/* Skip whitespace to get to the operator.	*/
	while (ISSPACE(*condExpr))
		condExpr++;

	/* Make sure the operator is a valid one. If it isn't a
	 * known relational operator, pretend we got a
	 * != 0 comparison.  */
	op = condExpr;
	switch (*condExpr) {
	case '!':
	case '=':
	case '<':
	case '>':
		if (condExpr[1] == '=')
			condExpr += 2;
		else
			condExpr += 1;
		break;
	default:
		op = "!=";
		rhs = "0";

		goto do_compare;
	}
	while (ISSPACE(*condExpr))
		condExpr++;
	if (*condExpr == '\0') {
		Parse_Error(PARSE_WARNING,
		    "Missing right-hand-side of operator");
		goto error;
	}
	rhs = condExpr;
do_compare:
	if (*rhs == '"') {
		/* Doing a string comparison. Only allow == and != for
		 * operators.  */
		char *string;
		const char *cp;
		int qt;
		BUFFER buf;

do_string_compare:
		if ((*op != '!' && *op != '=') || op[1] != '=') {
			Parse_Error(PARSE_WARNING,
			    "String comparison operator should be either == or !=");
			goto error;
		}

		Buf_Init(&buf, 0);
		qt = *rhs == '"' ? 1 : 0;

		for (cp = &rhs[qt]; ((qt && *cp != '"') ||
		    (!qt && strchr(" \t)", *cp) == NULL)) && *cp != '\0';) {
			if (*cp == '$') {
				size_t len;

				if (Var_ParseBuffer(&buf, cp, NULL, doEval,
				    &len)) {
					cp += len;
					continue;
				}
			} else if (*cp == '\\' && cp[1] != '\0')
				/* Backslash escapes things -- skip over next
				 * character, if it exists.  */
				cp++;
			Buf_AddChar(&buf, *cp++);
		}

		string = Buf_Retrieve(&buf);

		if (DEBUG(COND))
			printf("lhs = \"%s\", rhs = \"%s\", op = %.2s\n",
			    lhs, string, op);
		/* Null-terminate rhs and perform the comparison.
		 * t is set to the result.  */
		if (*op == '=')
			t = strcmp(lhs, string) ? False : True;
		else
			t = strcmp(lhs, string) ? True : False;
		free(string);
		if (rhs == condExpr) {
			if (!qt && *cp == ')')
				condExpr = cp;
			else if (*cp == '\0')
				condExpr = cp;
			else
				condExpr = cp + 1;
		}
	} else {
		/* rhs is either a float or an integer. Convert both the
		 * lhs and the rhs to a double and compare the two.  */
		double left, right;
		char *string;

		if (!CondCvtArg(lhs, &left))
			goto do_string_compare;
		if (*rhs == '$') {
			size_t len;
			bool freeIt;

			string = Var_Parse(rhs, NULL, doEval,&len,&freeIt);
			if (string == var_Error)
				right = 0.0;
			else {
				if (!CondCvtArg(string, &right)) {
					if (freeIt)
						free(string);
					goto do_string_compare;
				}
				if (freeIt)
					free(string);
				if (rhs == condExpr)
					condExpr += len;
			}
		} else {
			if (!CondCvtArg(rhs, &right))
				goto do_string_compare;
			if (rhs == condExpr) {
				/* Skip over the right-hand side.  */
				while (!ISSPACE(*condExpr) && *condExpr != '\0')
					condExpr++;
			}
		}

		if (DEBUG(COND))
			printf("left = %f, right = %f, op = %.2s\n", left,
			    right, op);
		switch (op[0]) {
		case '!':
			if (op[1] != '=') {
				Parse_Error(PARSE_WARNING, "Unknown operator");
				goto error;
			}
			t = left != right ? True : False;
			break;
		case '=':
			if (op[1] != '=') {
				Parse_Error(PARSE_WARNING, "Unknown operator");
				goto error;
			}
			t = left == right ? True : False;
			break;
		case '<':
			if (op[1] == '=')
				t = left <= right ? True : False;
			else
				t = left < right ? True : False;
			break;
		case '>':
			if (op[1] == '=')
				t = left >= right ? True : False;
			else
				t = left > right ? True : False;
			break;
		}
	}
error:
	if (doFree)
		free(lhs);
	return t;
}

#define S(s)	s, sizeof(s)-1
static struct operator {
	const char *s;
	size_t len;
	bool (*proc)(struct Name *);
} ops[] = {
	{S("defined"), CondDoDefined},
	{S("make"), CondDoMake},
	{S("exists"), CondDoExists},
	{S("target"), CondDoTarget},
	{S("commands"), CondDoTargetWithCommands},
	{NULL, 0, NULL}
};

static Token
CondHandleDefault(bool doEval)
{
	bool t;
	bool (*evalProc)(struct Name *);
	bool invert = false;
	struct Name arg;
	size_t arglen;

	evalProc = NULL;
	if (strncmp(condExpr, "empty", 5) == 0) {
		/* Use Var_Parse to parse the spec in parens and return
		 * True if the resulting string is empty.  */
		size_t length;
		bool doFree;
		char *val;

		condExpr += 5;

		for (arglen = 0; condExpr[arglen] != '(' &&
		    condExpr[arglen] != '\0';)
			arglen++;

		if (condExpr[arglen] != '\0') {
			val = Var_Parse(&condExpr[arglen - 1], NULL,
			    doEval, &length, &doFree);
			if (val == var_Error)
				t = Err;
			else {
				/* A variable is empty when it just contains
				 * spaces... 4/15/92, christos */
				char *p;
				for (p = val; ISSPACE(*p); p++)
					continue;
				t = *p == '\0' ? True : False;
			}
			if (doFree)
				free(val);
			/* Advance condExpr to beyond the closing ). Note that
			 * we subtract one from arglen + length b/c length
			 * is calculated from condExpr[arglen - 1].  */
			condExpr += arglen + length - 1;
			return t;
		} else
			condExpr -= 5;
	} else {
		struct operator *op;

		for (op = ops; op != NULL; op++)
			if (strncmp(condExpr, op->s, op->len) == 0) {
				condExpr += op->len;
				if (CondGetArg(&condExpr, &arg, op->s, true))
					evalProc = op->proc;
				else
					condExpr -= op->len;
				break;
			}
	}
	if (evalProc == NULL) {
		/* The symbol is itself the argument to the default
		 * function. We advance condExpr to the end of the symbol
		 * by hand (the next whitespace, closing paren or
		 * binary operator) and set to invert the evaluation
		 * function if condInvert is true.  */
		invert = condInvert;
		evalProc = condDefProc;
		/* XXX should we ignore problems now ? */
		CondGetArg(&condExpr, &arg, "", false);
	}

	/* Evaluate the argument using the set function. If invert
	 * is true, we invert the sense of the function.  */
	t = (!doEval || (*evalProc)(&arg) ?
	     (invert ? False : True) :
	     (invert ? True : False));
	VarName_Free(&arg);
	return t;
}

/*-
 *-----------------------------------------------------------------------
 * CondToken --
 *	Return the next token from the input.
 *
 * Results:
 *	A Token for the next lexical token in the stream.
 *
 * Side Effects:
 *	condPushback will be set back to None if it is used.
 *-----------------------------------------------------------------------
 */
static Token
CondToken(bool doEval)
{

	if (condPushBack != None) {
		Token t;

		t = condPushBack;
		condPushBack = None;
		return t;
	}

	while (ISSPACE(*condExpr))
		condExpr++;
	switch (*condExpr) {
	case '(':
		condExpr++;
		return LParen;
	case ')':
		condExpr++;
		return RParen;
	case '|':
		if (condExpr[1] == '|')
			condExpr++;
		condExpr++;
		return Or;
	case '&':
		if (condExpr[1] == '&')
			condExpr++;
		condExpr++;
		return And;
	case '!':
		condExpr++;
		return Not;
	case '\n':
	case '\0':
		return EndOfFile;
	case '"':
		return CondHandleString(doEval);
	case '$':
		return CondHandleVarSpec(doEval);
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		return CondHandleNumber(doEval);
	default:
		return CondHandleDefault(doEval);
	}
}

/*-
 *-----------------------------------------------------------------------
 * CondT --
 *	Parse a single term in the expression. This consists of a terminal
 *	symbol or Not and a terminal symbol (not including the binary
 *	operators):
 *	    T -> defined(variable) | make(target) | exists(file) | symbol
 *	    T -> ! T | ( E )
 *
 * Results:
 *	True, False or Err.
 *
 * Side Effects:
 *	Tokens are consumed.
 *-----------------------------------------------------------------------
 */
static Token
CondT(bool doEval)
{
	Token t;

	t = CondToken(doEval);

	if (t == EndOfFile)
		/* If we reached the end of the expression, the expression
		 * is malformed...  */
		t = Err;
	else if (t == LParen) {
		/* T -> ( E ).	*/
		t = CondE(doEval);
		if (t != Err)
			if (CondToken(doEval) != RParen)
				t = Err;
	} else if (t == Not) {
		t = CondT(doEval);
		if (t == True)
			t = False;
		else if (t == False)
			t = True;
	}
	return t;
}

/*-
 *-----------------------------------------------------------------------
 * CondF --
 *	Parse a conjunctive factor (nice name, wot?)
 *	    F -> T && F | T
 *
 * Results:
 *	True, False or Err
 *
 * Side Effects:
 *	Tokens are consumed.
 *-----------------------------------------------------------------------
 */
static Token
CondF(bool doEval)
{
	Token l, o;

	l = CondT(doEval);
	if (l != Err) {
		o = CondToken(doEval);

		if (o == And) {
		    /* F -> T && F
		     *
		     * If T is False, the whole thing will be False, but we
		     * have to parse the r.h.s. anyway (to throw it away).  If
		     * T is True, the result is the r.h.s., be it an Err or no.
		     * */
		    if (l == True)
			    l = CondF(doEval);
		    else
			    (void)CondF(false);
		} else
			/* F -> T.	*/
			condPushBack = o;
	}
	return l;
}

/*-
 *-----------------------------------------------------------------------
 * CondE --
 *	Main expression production.
 *	    E -> F || E | F
 *
 * Results:
 *	True, False or Err.
 *
 * Side Effects:
 *	Tokens are, of course, consumed.
 *-----------------------------------------------------------------------
 */
static Token
CondE(bool doEval)
{
	Token l, o;

	l = CondF(doEval);
	if (l != Err) {
		o = CondToken(doEval);

		if (o == Or) {
			/* E -> F || E
			 *
			 * A similar thing occurs for ||, except that here we
			 * make sure the l.h.s. is False before we bother to
			 * evaluate the r.h.s.  Once again, if l is False, the
			 * result is the r.h.s. and once again if l is True, we
			 * parse the r.h.s. to throw it away.  */
			if (l == False)
				l = CondE(doEval);
			else
				(void)CondE(false);
		} else
			/* E -> F.	*/
			condPushBack = o;
	}
	return l;
}

/* Evaluate conditional in line.
 * returns COND_SKIP, COND_PARSE, COND_INVALID, COND_ISFOR, COND_ISINCLUDE,
 * COND_ISUNDEF.
 * A conditional line looks like this:
 *	<cond-type> <expr>
 *	where <cond-type> is any of if, ifmake, ifnmake, ifdef,
 *	ifndef, elif, elifmake, elifnmake, elifdef, elifndef
 *	and <expr> consists of &&, ||, !, make(target), defined(variable)
 *	and parenthetical groupings thereof.
 */
int
Cond_Eval(const char *line)
{
	/* find end of keyword */
	const char *end;
	uint32_t k;
	size_t len;
	struct If *ifp;
	bool value = false;
	int level;	/* Level at which to report errors. */

	level = PARSE_FATAL;

	for (end = line; ISLOWER(*end); end++)
		;
	/* quick path: recognize special targets early on */
	if (*end == '.' || *end == ':')
		return COND_INVALID;
	len = end - line;
	k = ohash_interval(line, &end);
	switch(k % MAGICSLOTS2) {
	case K_COND_IF % MAGICSLOTS2:
		if (k == K_COND_IF && len == strlen(COND_IF) &&
		    strncmp(line, COND_IF, len) == 0) {
			ifp = ifs + COND_IF_INDEX;
		} else
			return COND_INVALID;
		break;
	case K_COND_IFDEF % MAGICSLOTS2:
		if (k == K_COND_IFDEF && len == strlen(COND_IFDEF) &&
		    strncmp(line, COND_IFDEF, len) == 0) {
			ifp = ifs + COND_IFDEF_INDEX;
		} else
			return COND_INVALID;
		break;
	case K_COND_IFNDEF % MAGICSLOTS2:
		if (k == K_COND_IFNDEF && len == strlen(COND_IFNDEF) &&
		    strncmp(line, COND_IFNDEF, len) == 0) {
			ifp = ifs + COND_IFNDEF_INDEX;
		} else
			return COND_INVALID;
		break;
	case K_COND_IFMAKE % MAGICSLOTS2:
		if (k == K_COND_IFMAKE && len == strlen(COND_IFMAKE) &&
		    strncmp(line, COND_IFMAKE, len) == 0) {
			ifp = ifs + COND_IFMAKE_INDEX;
		} else
			return COND_INVALID;
		break;
	case K_COND_IFNMAKE % MAGICSLOTS2:
		if (k == K_COND_IFNMAKE && len == strlen(COND_IFNMAKE) &&
		    strncmp(line, COND_IFNMAKE, len) == 0) {
			ifp = ifs + COND_IFNMAKE_INDEX;
		} else
			return COND_INVALID;
		break;
	case K_COND_ELIF % MAGICSLOTS2:
		if (k == K_COND_ELIF && len == strlen(COND_ELIF) &&
		    strncmp(line, COND_ELIF, len) == 0) {
			ifp = ifs + COND_ELIF_INDEX;
		} else
			return COND_INVALID;
		break;
	case K_COND_ELIFDEF % MAGICSLOTS2:
		if (k == K_COND_ELIFDEF && len == strlen(COND_ELIFDEF) &&
		    strncmp(line, COND_ELIFDEF, len) == 0) {
			ifp = ifs + COND_ELIFDEF_INDEX;
		} else
			return COND_INVALID;
		break;
	case K_COND_ELIFNDEF % MAGICSLOTS2:
		if (k == K_COND_ELIFNDEF && len == strlen(COND_ELIFNDEF) &&
		    strncmp(line, COND_ELIFNDEF, len) == 0) {
			ifp = ifs + COND_ELIFNDEF_INDEX;
		} else
			return COND_INVALID;
		break;
	case K_COND_ELIFMAKE % MAGICSLOTS2:
		if (k == K_COND_ELIFMAKE && len == strlen(COND_ELIFMAKE) &&
		    strncmp(line, COND_ELIFMAKE, len) == 0) {
			ifp = ifs + COND_ELIFMAKE_INDEX;
		} else
			return COND_INVALID;
		break;
	case K_COND_ELIFNMAKE % MAGICSLOTS2:
		if (k == K_COND_ELIFNMAKE && len == strlen(COND_ELIFNMAKE) &&
		    strncmp(line, COND_ELIFNMAKE, len) == 0) {
			ifp = ifs + COND_ELIFNMAKE_INDEX;
		} else
			return COND_INVALID;
		break;
	case K_COND_ELSE % MAGICSLOTS2:
		/* valid conditional whose value is the inverse
		 * of the previous if we parsed.  */
		if (k == K_COND_ELSE && len == strlen(COND_ELSE) &&
		    strncmp(line, COND_ELSE, len) == 0) {
			if (condTop == MAXIF) {
				Parse_Error(level, "if-less else");
				return COND_INVALID;
			} else if (skipIfLevel == 0) {
				value = !condStack[condTop].value;
				ifp = ifs + COND_ELSE_INDEX;
			} else
				return COND_SKIP;
		} else
			return COND_INVALID;
		break;
	case K_COND_ENDIF % MAGICSLOTS2:
		if (k == K_COND_ENDIF && len == strlen(COND_ENDIF) &&
		    strncmp(line, COND_ENDIF, len) == 0) {
			/* End of a conditional section. If skipIfLevel is
			 * non-zero, that conditional was skipped, so lines
			 * following it should also be skipped. Hence, we
			 * return COND_SKIP. Otherwise, the conditional was
			 * read so succeeding lines should be parsed (think
			 * about it...) so we return COND_PARSE, unless this
			 * endif isn't paired with a decent if.  */
			if (skipIfLevel != 0) {
				skipIfLevel--;
				return COND_SKIP;
			} else {
				if (condTop == MAXIF) {
					Parse_Error(level, "if-less endif");
					return COND_INVALID;
				} else {
					skipLine = false;
					condTop++;
					return COND_PARSE;
				}
			}
		} else
			return COND_INVALID;
		break;

	/* Recognize other keywords there, to simplify parser's task */
	case K_COND_FOR % MAGICSLOTS2:
		if (k == K_COND_FOR && len == strlen(COND_FOR) &&
		    strncmp(line, COND_FOR, len) == 0)
			return COND_ISFOR;
		else
			return COND_INVALID;
	case K_COND_UNDEF % MAGICSLOTS2:
		if (k == K_COND_UNDEF && len == strlen(COND_UNDEF) &&
		    strncmp(line, COND_UNDEF, len) == 0)
			return COND_ISUNDEF;
		else
			return COND_INVALID;
	case K_COND_POISON % MAGICSLOTS2:
		if (k == K_COND_POISON && len == strlen(COND_POISON) &&
		    strncmp(line, COND_POISON, len) == 0)
			return COND_ISPOISON;
		else
			return COND_INVALID;
	case K_COND_INCLUDE % MAGICSLOTS2:
		if (k == K_COND_INCLUDE && len == strlen(COND_INCLUDE) &&
		    strncmp(line, COND_INCLUDE, len) == 0)
			return COND_ISINCLUDE;
		else
			return COND_INVALID;
	default:
		/* Not a valid conditional type. No error...  */
		return COND_INVALID;
	}

	if (ifp->isElse) {
		if (condTop == MAXIF) {
			Parse_Error(level, "if-less elif");
			return COND_INVALID;
		} else if (skipIfLevel != 0 || condStack[condTop].value) {
			/*
			 * Skip if we're meant to or is an else-type
			 * conditional and previous corresponding one was
			 * evaluated to true.
			 */
			skipLine = true;
			return COND_SKIP;
		}
	} else if (skipLine) {
		/* Don't even try to evaluate a conditional that's not an else
		 * if we're skipping things...  */
		skipIfLevel++;
		return COND_SKIP;
	} else
		condTop--;

	if (condTop < 0) {
		/* This is the one case where we can definitely proclaim a fatal
		 * error. If we don't, we're hosed.  */
		Parse_Error(PARSE_FATAL, "Too many nested if's. %d max.",
		    MAXIF);
		condTop = 0;
		return COND_INVALID;
	}

	if (ifp->defProc) {
		/* Initialize file-global variables for parsing.  */
		condDefProc = ifp->defProc;
		condInvert = ifp->doNot;

		line += len;

		while (*line == ' ' || *line == '\t')
			line++;

		condExpr = line;
		condPushBack = None;

		switch (CondE(true)) {
		case True:
			if (CondToken(true) == EndOfFile) {
				value = true;
				break;
			}
			goto err;
			/* FALLTHROUGH */
		case False:
			if (CondToken(true) == EndOfFile) {
				value = false;
				break;
			}
			/* FALLTHROUGH */
		case Err:
err:
			Parse_Error(level, "Malformed conditional (%s)", line);
			return COND_INVALID;
		default:
			break;
		}
	}

	condStack[condTop].value = value;
	Parse_FillLocation(&condStack[condTop].origin);
	skipLine = !value;
	return value ? COND_PARSE : COND_SKIP;
}

void
Cond_End(void)
{
	int i;

	if (condTop != MAXIF) {
		Parse_Error(PARSE_FATAL, "%s%d open conditional%s",
		    condTop == 0 ? "at least ": "", MAXIF-condTop,
		    MAXIF-condTop == 1 ? "" : "s");
		for (i = MAXIF-1; i >= condTop; i--) {
			fprintf(stderr, "\t(%s:%lu)\n", 
			    condStack[i].origin.fname, 
			    condStack[i].origin.lineno);
		}
	}
	condTop = MAXIF;
}
@


1.51
log
@small obvious cleanups:
- remove a lot of unnecessary casts
- zap extra param that's no longer needed
- add proper prototype and make function static

okay natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.50 2013/11/22 15:47:35 espie Exp $	*/
d294 3
@


1.50
log
@wrappers for is*/to* that make damn sure their arguments are
cast to unsigned chars.

okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.49 2013/04/23 14:32:53 espie Exp $	*/
d272 1
a272 1
		char *s = (char *)Lst_Datum(ln);
@


1.49
log
@remove TIMESTAMP abstraction layer, prodded by theo.
while there, clean up includes.
use strtoll for ar timestamps (pretty much unused in reality, more
standard conforming than anything)

use idea from Todd to adapt to time_t being 32 bits OR 64 bits
(pedantically correct: INT_MIN would work just fine up to 1910 or so...)

okay millert@@, gone thru a make build.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.48 2012/11/24 11:04:55 espie Exp $	*/
d210 1
a210 1
		while (isspace(*cp))
d221 1
a221 1
	while (isspace(*cp))
d226 1
a226 1
	while (isspace(*cp))
d372 1
a372 1
			if (isdigit(*str))
d374 2
a375 2
			else if (isxdigit(*str))
				x = 10 + *str - (isupper(*str) ? 'A' : 'a');
d398 1
a398 1
	while (!isspace(*end) && strchr("!=><", *end) == NULL)
d421 1
a421 1
	if (!isspace(*condExpr) &&
d432 1
a432 1
		for (;*condExpr && !isspace(*condExpr); condExpr++)
d474 1
a474 1
	while (isspace(*condExpr))
d497 1
a497 1
	while (isspace(*condExpr))
d592 1
a592 1
				while (!isspace(*condExpr) && *condExpr != '\0')
d681 1
a681 1
				for (p = val; isspace(*p); p++)
d752 1
a752 1
	while (isspace(*condExpr))
d936 1
a936 1
	for (end = line; islower(*end); end++)
@


1.48
log
@be more strict in recognizing .if keyword() constructs, don't ignore
unknown keywords.
uniform white space handling.

okay beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.47 2012/10/18 17:54:43 espie Exp $	*/
d40 1
a41 1
#include <stdint.h>
d44 1
a60 1
#include "ohash.h"
@


1.47
log
@numerous error message fixes:
- do ^C checking differently: don't record sent signals, but when jobs
die, recheck whether we received/have pending a INT/QUIT/TERM/HUP signal.
Then don't display our process group "normally", instead group together
everything dying by signal/shell dying by signal (just give the target
names).

- make certain we always handle signals before dying from "other conditions"
- have the parser messages look more like normal messages
- remove double error messages from some parser errors
- make sure unclosed variables ARE errors when some modifiers are present

- keep track of the base directory we're run from, so that submakes can
get shortened directories...
- make sure the whole error message including silent command fits into a
reasonable length.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.46 2012/10/11 14:56:17 espie Exp $	*/
d201 8
d210 1
a210 1
		while (*cp != '(' && *cp != '\0')
d214 2
d218 1
a218 9
	if (*cp == '\0') {
		/* No arguments whatsoever. Because 'make' and 'defined' aren't
		 * really "reserved words", we don't print a message. I think
		 * this is better than hitting the user with a warning message
		 * every time s/he uses the word 'make' or 'defined' at the
		 * beginning of a symbol...  */
		arg->s = cp;
		arg->e = cp;
		arg->tofree = false;
a219 1
	}
d221 1
a221 1
	while (*cp == ' ' || *cp == '\t')
a223 1

d226 1
a226 8
	while (*cp == ' ' || *cp == '\t')
		cp++;
	if (parens && *cp != ')') {
		Parse_Error(PARSE_WARNING,
		    "Missing closing parenthesis for %s()", func);
	    return false;
	} else if (parens)
		/* Advance pointer past close parenthesis.  */
d228 9
d752 1
a752 1
	while (*condExpr == ' ' || *condExpr == '\t')
@


1.46
log
@fix make's cond parser to be able to handle .if 5 < 7 directly.
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.45 2012/10/09 19:51:50 espie Exp $	*/
d1167 3
a1169 2
			fprintf(stderr, "\t at line %lu of %s\n",
			    condStack[i].origin.lineno, condStack[i].origin.fname);
@


1.45
log
@steal .if commands() concept from NetBSD.
Actually less ambiguous than .if target().
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.44 2012/03/22 13:47:12 espie Exp $	*/
d80 1
d119 1
d390 14
d779 3
@


1.44
log
@minor cleanup: error messages include lineno and fileno together, so
recognize that and create a struct Location_ for it.

mostly from Jonathan Calmels, a few nits from me.

okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.43 2010/07/19 19:46:43 espie Exp $	*/
d73 1
d108 1
d313 1
a313 1
    GNode *gn;
d322 21
d627 1
@


1.43
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.42 2010/04/25 13:59:53 espie Exp $	*/
d159 1
a159 2
	unsigned long	lineno;
	const char	*filename;
d1109 1
a1109 2
	condStack[condTop].lineno = Parse_Getlineno();
	condStack[condTop].filename = Parse_Getfilename();
d1125 1
a1125 1
			    condStack[i].lineno, condStack[i].filename);
@


1.42
log
@pure whitespace cleanup
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$	*/
@


1.41
log
@If this is an else-type conditional and previous corresponding one
evaluated to true, skip. tested by simon@@ and myself. espie@@ ok.
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.40 2008/11/24 16:23:04 espie Exp $	*/
d227 1
a227 1
		Parse_Error(PARSE_WARNING, 
d490 1
a490 1
				if (Var_ParseBuffer(&buf, cp, NULL, doEval, 
d628 1
a628 1
		for (arglen = 0; condExpr[arglen] != '(' && 
d1068 1
a1068 1
		Parse_Error(PARSE_FATAL, "Too many nested if's. %d max.", 
d1127 1
a1127 1
			fprintf(stderr, "\t at line %lu of %s\n", 
@


1.40
log
@fix a very old bug. Fix discovered in NetBSD by miod@@
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d1048 7
a1054 5
		} else if (skipIfLevel != 0) {
			/* If skipping this conditional, just ignore the whole
			 * thing.  If we don't, the user might be employing a
			 * variable that's undefined, for which there's an
			 * enclosing ifdef that we're skipping...  */
d1062 10
d1110 5
a1114 26
	if (!ifp->isElse)
		condTop--;
	else if (skipIfLevel != 0 || condStack[condTop].value) {
		/* If this is an else-type conditional, it should only take
		 * effect if its corresponding if was evaluated and false. If
		 * its if was true or skipped, we return COND_SKIP (and start
		 * skipping in case we weren't already), leaving the stack
		 * unmolested so later elif's don't screw up...  */
		skipLine = true;
		return COND_SKIP;
	}

	if (condTop < 0) {
		/* This is the one case where we can definitely proclaim a fatal
		 * error. If we don't, we're hosed.  */
		Parse_Error(PARSE_FATAL, "Too many nested if's. %d max.", 
		    MAXIF);
		condTop = 0;
		return COND_INVALID;
	} else {
		condStack[condTop].value = value;
		condStack[condTop].lineno = Parse_Getlineno();
		condStack[condTop].filename = Parse_Getfilename();
		skipLine = !value;
		return value ? COND_PARSE : COND_SKIP;
	}
@


1.39
log
@reindent cond.c
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.38 2007/09/17 09:28:36 espie Exp $	*/
d350 1
a350 1
				x = 10 + *str - isupper(*str) ? 'A' : 'a';
@


1.38
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.37 2007/09/17 08:36:57 espie Exp $	*/
d95 1
a95 1
    False = 0, True = 1, And, Or, Not, LParen, RParen, EndOfFile, None, Err
d121 3
a123 4
    bool	isElse;		/* true for else forms */
    bool	doNot;		/* true for embedded negation */
    bool	(*defProc)(struct Name *);
    				/* function to apply */
d127 9
a135 9
    { false,	false,	CondDoDefined },	/* if, ifdef */
    { false,	true,	CondDoDefined },	/* ifndef */
    { false,	false,	CondDoMake },		/* ifmake */
    { false,	true,	CondDoMake },		/* ifnmake */
    { true,	false,	CondDoDefined },	/* elif, elifdef */
    { true,	true,	CondDoDefined },	/* elifndef */
    { true,	false,	CondDoMake },		/* elifmake */
    { true,	true,	CondDoMake },		/* elifnmake */
    { true,	false,	NULL }
d150 5
a154 6
static bool	  condInvert;		/* Invert the default function */
static bool	  (*condDefProc)	/* Default function to apply */
		   (struct Name *);
static const char *condExpr;		/* The expression to parse */
static Token	  condPushBack=None;	/* Single push-back token used in
					 * parsing */
d156 1
a156 1
#define MAXIF		30	  /* greatest depth of #if'ing */
d162 5
a166 5
} condStack[MAXIF];			/* Stack of conditionals */
static int	  condTop = MAXIF;	/* Top-most conditional */
static int	  skipIfLevel=0;	/* Depth of skipped conditionals */
static bool	  skipLine = false;	/* Whether the parse module is skipping
					 * lines */
d171 5
a175 5
    for (;;p++) {
    	/* XXX: when *p == '\0', strchr() returns !NULL */
	if (strchr(" \t)&|$", *p) != NULL)
	    return p;
    }
d196 9
a204 1
    const char	  	*cp;
d206 11
a216 18
    cp = *linePtr;
    if (parens) {
	while (*cp != '(' && *cp != '\0')
	    cp++;
	if (*cp == '(')
	    cp++;
    }

    if (*cp == '\0') {
	/* No arguments whatsoever. Because 'make' and 'defined' aren't really
	 * "reserved words", we don't print a message. I think this is better
	 * than hitting the user with a warning message every time s/he uses
	 * the word 'make' or 'defined' at the beginning of a symbol...  */
	arg->s = cp;
	arg->e = cp;
	arg->tofree = false;
	return false;
    }
d218 2
a219 2
    while (*cp == ' ' || *cp == '\t')
	cp++;
d222 1
a222 1
    cp = VarName_Get(cp, arg, NULL, true, find_cond);
d224 9
a232 9
    while (*cp == ' ' || *cp == '\t')
	cp++;
    if (parens && *cp != ')') {
	Parse_Error(PARSE_WARNING, "Missing closing parenthesis for %s()",
		     func);
	return false;
    } else if (parens)
	/* Advance pointer past close parenthesis.  */
	cp++;
d234 2
a235 2
    *linePtr = cp;
    return true;
d250 1
a250 1
    return Var_Definedi(arg->s, arg->e);
d265 1
a265 1
    LstNode ln;
d267 5
a271 5
    for (ln = Lst_First(create); ln != NULL; ln = Lst_Adv(ln)) {
    	char *s = (char *)Lst_Datum(ln);
	if (Str_Matchi(s, strchr(s, '\0'), arg->s, arg->e))
	    return true;
    }
d273 1
a273 1
    return false;
d288 2
a289 2
    bool result;
    char    *path;
d291 8
a298 8
    path = Dir_FindFilei(arg->s, arg->e, defaultPath);
    if (path != NULL) {
	result = true;
	free(path);
    } else {
	result = false;
    }
    return result;
d313 1
a313 1
    GNode   *gn;
d315 5
a319 5
    gn = Targ_FindNodei(arg->s, arg->e, TARG_NOCREATE);
    if (gn != NULL && !OP_NOP(gn->type))
	return true;
    else
	return false;
d342 2
a343 2
    if (*str == '0' && str[1] == 'x') {
	long i;
d345 17
a361 9
	for (str += 2, i = 0; *str; str++) {
	    int x;
	    if (isdigit(*str))
		x  = *str - '0';
	    else if (isxdigit(*str))
		x = 10 + *str - isupper(*str) ? 'A' : 'a';
	    else
		return false;
	    i = (i << 4) + x;
a362 8
	*value = (double) i;
	return true;
    }
    else {
	char *eptr;
	*value = strtod(str, &eptr);
	return *eptr == '\0';
    }
d369 3
a371 12
    char	*lhs;
    size_t	varSpecLen;
    bool	doFree;

    /* Parse the variable spec and skip over it, saving its
     * value in lhs.  */
    lhs = Var_Parse(condExpr, NULL, doEval,&varSpecLen,&doFree);
    if (lhs == var_Error)
	/* Even if !doEval, we still report syntax errors, which
	 * is what getting var_Error back with !doEval means.  */
	return Err;
    condExpr += varSpecLen;
d373 27
a399 13
    if (!isspace(*condExpr) &&
	strchr("!=><", *condExpr) == NULL) {
	BUFFER buf;

	Buf_Init(&buf, 0);

	Buf_AddString(&buf, lhs);

	if (doFree)
	    free(lhs);

	for (;*condExpr && !isspace(*condExpr); condExpr++)
	    Buf_AddChar(&buf, *condExpr);
d401 1
a401 6
	lhs = Var_Subst(Buf_Retrieve(&buf), NULL, doEval);
	Buf_Destroy(&buf);
	doFree = true;
    }

    return CondHandleComparison(lhs, doFree, doEval);
d429 14
a442 14
    Token	t;
    const char	*rhs;
    const char	*op;

    t = Err;
    /* Skip whitespace to get to the operator.	*/
    while (isspace(*condExpr))
	condExpr++;

    /* Make sure the operator is a valid one. If it isn't a
     * known relational operator, pretend we got a
     * != 0 comparison.  */
    op = condExpr;
    switch (*condExpr) {
d447 5
a451 5
	    if (condExpr[1] == '=')
		condExpr += 2;
	    else
		condExpr += 1;
	    break;
d453 2
a454 2
	    op = "!=";
	    rhs = "0";
d456 6
a461 6
	    goto do_compare;
    }
    while (isspace(*condExpr))
	condExpr++;
    if (*condExpr == '\0') {
	Parse_Error(PARSE_WARNING,
d463 3
a465 3
	goto error;
    }
    rhs = condExpr;
d467 7
a473 7
    if (*rhs == '"') {
	/* Doing a string comparison. Only allow == and != for
	 * operators.  */
	char	*string;
	const char *cp;
	int	    qt;
	BUFFER	buf;
d476 5
a480 5
	if ((*op != '!' && *op != '=') || op[1] != '=') {
	    Parse_Error(PARSE_WARNING,
    "String comparison operator should be either == or !=");
	    goto error;
	}
d482 2
a483 2
	Buf_Init(&buf, 0);
	qt = *rhs == '"' ? 1 : 0;
d485 15
a499 10
	for (cp = &rhs[qt];
	     ((qt && *cp != '"') ||
	      (!qt && strchr(" \t)", *cp) == NULL)) &&
	     *cp != '\0';) {
	    if (*cp == '$') {
		size_t	len;

		if (Var_ParseBuffer(&buf, cp, NULL, doEval, &len)) {
		    cp += len;
		    continue;
a500 6
	    } else if (*cp == '\\' && cp[1] != '\0')
		/* Backslash escapes things -- skip over next
		 * character, if it exists.  */
		cp++;
	    Buf_AddChar(&buf, *cp++);
	}
d502 1
a502 1
	string = Buf_Retrieve(&buf);
d504 17
a520 38
	if (DEBUG(COND))
	    printf("lhs = \"%s\", rhs = \"%s\", op = %.2s\n",
		   lhs, string, op);
	/* Null-terminate rhs and perform the comparison.
	 * t is set to the result.  */
	if (*op == '=')
	    t = strcmp(lhs, string) ? False : True;
	else
	    t = strcmp(lhs, string) ? True : False;
	free(string);
	if (rhs == condExpr) {
	    if (!qt && *cp == ')')
		condExpr = cp;
	    else if (*cp == '\0')
		condExpr = cp;
	    else
		condExpr = cp + 1;
	}
    } else {
	/* rhs is either a float or an integer. Convert both the
	 * lhs and the rhs to a double and compare the two.  */
	double		left, right;
	char		*string;

	if (!CondCvtArg(lhs, &left))
	    goto do_string_compare;
	if (*rhs == '$') {
	    size_t	len;
	    bool	freeIt;

	    string = Var_Parse(rhs, NULL, doEval,&len,&freeIt);
	    if (string == var_Error)
		right = 0.0;
	    else {
		if (!CondCvtArg(string, &right)) {
		    if (freeIt)
			free(string);
		    goto do_string_compare;
a521 5
		if (freeIt)
		    free(string);
		if (rhs == condExpr)
		    condExpr += len;
	    }
d523 34
a556 10
	    if (!CondCvtArg(rhs, &right))
		goto do_string_compare;
	    if (rhs == condExpr) {
		/* Skip over the right-hand side.  */
		while (!isspace(*condExpr) &&
		      *condExpr != '\0')
		    condExpr++;

	    }
	}
d558 31
a588 32
	if (DEBUG(COND))
	    printf("left = %f, right = %f, op = %.2s\n", left,
		   right, op);
	switch (op[0]) {
	case '!':
	    if (op[1] != '=') {
		Parse_Error(PARSE_WARNING,
			    "Unknown operator");
		goto error;
	    }
	    t = left != right ? True : False;
	    break;
	case '=':
	    if (op[1] != '=') {
		Parse_Error(PARSE_WARNING,
			    "Unknown operator");
		goto error;
	    }
	    t = left == right ? True : False;
	    break;
	case '<':
	    if (op[1] == '=')
		t = left <= right ? True : False;
	    else
		t = left < right ? True : False;
	    break;
	case '>':
	    if (op[1] == '=')
		t = left >= right ? True : False;
	    else
		t = left > right ? True : False;
	    break;
a589 1
    }
d591 3
a593 3
    if (doFree)
	free(lhs);
    return t;
d598 3
a600 3
    const char *s;
    size_t len;
    bool (*proc)(struct Name *);
d602 5
a606 5
    {S("defined"), CondDoDefined},
    {S("make"), CondDoMake},
    {S("exists"), CondDoExists},
    {S("target"), CondDoTarget},
    {NULL, 0, NULL}
d608 1
d612 19
a630 13
    bool	t;
    bool	(*evalProc)(struct Name *);
    bool	invert = false;
    struct Name	arg;
    size_t arglen;

    evalProc = NULL;
    if (strncmp(condExpr, "empty", 5) == 0) {
	/* Use Var_Parse to parse the spec in parens and return
	 * True if the resulting string is empty.  */
	size_t	 length;
	bool doFree;
	char	*val;
d632 24
a655 1
	condExpr += 5;
d657 21
a677 2
	for (arglen = 0; condExpr[arglen] != '(' && condExpr[arglen] != '\0';)
	     arglen++;
d679 7
a685 54
	if (condExpr[arglen] != '\0') {
	    val = Var_Parse(&condExpr[arglen - 1], NULL,
			    doEval, &length, &doFree);
	    if (val == var_Error)
		t = Err;
	    else {
		/* A variable is empty when it just contains
		 * spaces... 4/15/92, christos */
		char *p;
		for (p = val; isspace(*p); p++)
		    continue;
		t = *p == '\0' ? True : False;
	    }
	    if (doFree)
		free(val);
	    /* Advance condExpr to beyond the closing ). Note that
	     * we subtract one from arglen + length b/c length
	     * is calculated from condExpr[arglen - 1].  */
	    condExpr += arglen + length - 1;
	    return t;
	} else
	    condExpr -= 5;
    } else {
	struct operator *op;

	for (op = ops; op != NULL; op++)
	    if (strncmp(condExpr, op->s, op->len) == 0) {
		condExpr += op->len;
		if (CondGetArg(&condExpr, &arg, op->s, true))
		    evalProc = op->proc;
		else
		    condExpr -= op->len;
		break;
	    }
    }
    if (evalProc == NULL) {
	/* The symbol is itself the argument to the default
	 * function. We advance condExpr to the end of the symbol
	 * by hand (the next whitespace, closing paren or
	 * binary operator) and set to invert the evaluation
	 * function if condInvert is true.  */
	invert = condInvert;
	evalProc = condDefProc;
	/* XXX should we ignore problems now ? */
	CondGetArg(&condExpr, &arg, "", false);
    }

    /* Evaluate the argument using the set function. If invert
     * is true, we invert the sense of the function.  */
    t = (!doEval || (*evalProc)(&arg) ?
	 (invert ? False : True) :
	 (invert ? True : False));
    VarName_Free(&arg);
    return t;
d704 2
a705 2
    if (condPushBack != None) {
	Token	  t;
d707 4
a710 4
	t = condPushBack;
	condPushBack = None;
	return t;
    }
d712 3
a714 3
    while (*condExpr == ' ' || *condExpr == '\t')
	condExpr++;
    switch (*condExpr) {
d716 2
a717 2
	    condExpr++;
	    return LParen;
d719 2
a720 2
	    condExpr++;
	    return RParen;
d722 2
a723 1
	    if (condExpr[1] == '|')
d725 1
a725 2
	    condExpr++;
	    return Or;
d727 2
a728 1
	    if (condExpr[1] == '&')
d730 1
a730 2
	    condExpr++;
	    return And;
d732 2
a733 2
	    condExpr++;
	    return Not;
d736 1
a736 1
	    return EndOfFile;
d738 1
a738 1
	    return CondHandleString(doEval);
d740 1
a740 1
	    return CondHandleVarSpec(doEval);
d742 2
a743 2
	    return CondHandleDefault(doEval);
    }
d765 1
a765 1
    Token   t;
d767 1
a767 1
    t = CondToken(doEval);
d769 3
a771 9
    if (t == EndOfFile)
	/* If we reached the end of the expression, the expression
	 * is malformed...  */
	t = Err;
    else if (t == LParen) {
	/* T -> ( E ).	*/
	t = CondE(doEval);
	if (t != Err)
	    if (CondToken(doEval) != RParen)
d773 14
a786 8
    } else if (t == Not) {
	t = CondT(doEval);
	if (t == True)
	    t = False;
	else if (t == False)
	    t = True;
    }
    return t;
d805 1
a805 1
    Token   l, o;
d807 20
a826 19
    l = CondT(doEval);
    if (l != Err) {
	o = CondToken(doEval);

	if (o == And) {
	    /* F -> T && F
	     *
	     * If T is False, the whole thing will be False, but we have to
	     * parse the r.h.s. anyway (to throw it away).
	     * If T is True, the result is the r.h.s., be it an Err or no.  */
	    if (l == True)
		l = CondF(doEval);
	    else
		(void)CondF(false);
	} else
	    /* F -> T.	*/
	    condPushBack = o;
    }
    return l;
d845 1
a845 1
    Token   l, o;
d847 21
a867 20
    l = CondF(doEval);
    if (l != Err) {
	o = CondToken(doEval);

	if (o == Or) {
	    /* E -> F || E
	     *
	     * A similar thing occurs for ||, except that here we make sure
	     * the l.h.s. is False before we bother to evaluate the r.h.s.
	     * Once again, if l is False, the result is the r.h.s. and once
	     * again if l is True, we parse the r.h.s. to throw it away.  */
	    if (l == False)
		l = CondE(doEval);
	    else
		(void)CondE(false);
	} else
	    /* E -> F.	*/
	    condPushBack = o;
    }
    return l;
d883 158
a1040 95
    /* find end of keyword */
    const char	*end;
    uint32_t 	k;
    size_t 	len;
    struct If	*ifp;
    bool	value = false;
    int		level;	/* Level at which to report errors. */

    level = PARSE_FATAL;

    for (end = line; islower(*end); end++)
	;
    /* quick path: recognize special targets early on */
    if (*end == '.' || *end == ':')
    	return COND_INVALID;
    len = end - line;
    k = ohash_interval(line, &end);
    switch(k % MAGICSLOTS2) {
    case K_COND_IF % MAGICSLOTS2:
	if (k == K_COND_IF && len == strlen(COND_IF) &&
	    strncmp(line, COND_IF, len) == 0) {
	    ifp = ifs + COND_IF_INDEX;
	} else
	    return COND_INVALID;
	break;
    case K_COND_IFDEF % MAGICSLOTS2:
	if (k == K_COND_IFDEF && len == strlen(COND_IFDEF) &&
	    strncmp(line, COND_IFDEF, len) == 0) {
	    ifp = ifs + COND_IFDEF_INDEX;
	} else
	    return COND_INVALID;
	break;
    case K_COND_IFNDEF % MAGICSLOTS2:
	if (k == K_COND_IFNDEF && len == strlen(COND_IFNDEF) &&
	    strncmp(line, COND_IFNDEF, len) == 0) {
	    ifp = ifs + COND_IFNDEF_INDEX;
	} else
	    return COND_INVALID;
	break;
    case K_COND_IFMAKE % MAGICSLOTS2:
	if (k == K_COND_IFMAKE && len == strlen(COND_IFMAKE) &&
	    strncmp(line, COND_IFMAKE, len) == 0) {
	    ifp = ifs + COND_IFMAKE_INDEX;
	} else
	    return COND_INVALID;
	break;
    case K_COND_IFNMAKE % MAGICSLOTS2:
	if (k == K_COND_IFNMAKE && len == strlen(COND_IFNMAKE) &&
	    strncmp(line, COND_IFNMAKE, len) == 0) {
	    ifp = ifs + COND_IFNMAKE_INDEX;
	} else
	    return COND_INVALID;
	break;
    case K_COND_ELIF % MAGICSLOTS2:
	if (k == K_COND_ELIF && len == strlen(COND_ELIF) &&
	    strncmp(line, COND_ELIF, len) == 0) {
	    ifp = ifs + COND_ELIF_INDEX;
	} else
	    return COND_INVALID;
	break;
    case K_COND_ELIFDEF % MAGICSLOTS2:
	if (k == K_COND_ELIFDEF && len == strlen(COND_ELIFDEF) &&
	    strncmp(line, COND_ELIFDEF, len) == 0) {
	    ifp = ifs + COND_ELIFDEF_INDEX;
	} else
	    return COND_INVALID;
	break;
    case K_COND_ELIFNDEF % MAGICSLOTS2:
	if (k == K_COND_ELIFNDEF && len == strlen(COND_ELIFNDEF) &&
	    strncmp(line, COND_ELIFNDEF, len) == 0) {
	    ifp = ifs + COND_ELIFNDEF_INDEX;
	} else
	    return COND_INVALID;
	break;
    case K_COND_ELIFMAKE % MAGICSLOTS2:
	if (k == K_COND_ELIFMAKE && len == strlen(COND_ELIFMAKE) &&
	    strncmp(line, COND_ELIFMAKE, len) == 0) {
	    ifp = ifs + COND_ELIFMAKE_INDEX;
	} else
	    return COND_INVALID;
	break;
    case K_COND_ELIFNMAKE % MAGICSLOTS2:
	if (k == K_COND_ELIFNMAKE && len == strlen(COND_ELIFNMAKE) &&
	    strncmp(line, COND_ELIFNMAKE, len) == 0) {
	    ifp = ifs + COND_ELIFNMAKE_INDEX;
	} else
	    return COND_INVALID;
	break;
    case K_COND_ELSE % MAGICSLOTS2:
	/* valid conditional whose value is the inverse
	 * of the previous if we parsed.  */
	if (k == K_COND_ELSE && len == strlen(COND_ELSE) &&
	    strncmp(line, COND_ELSE, len) == 0) {
	    if (condTop == MAXIF) {
		Parse_Error(level, "if-less else");
d1042 3
a1044 21
	    } else if (skipIfLevel == 0) {
		value = !condStack[condTop].value;
		ifp = ifs + COND_ELSE_INDEX;
	    } else
		return COND_SKIP;
	} else
	    return COND_INVALID;
	break;
    case K_COND_ENDIF % MAGICSLOTS2:
	if (k == K_COND_ENDIF && len == strlen(COND_ENDIF) &&
	    strncmp(line, COND_ENDIF, len) == 0) {
	/* End of a conditional section. If skipIfLevel is non-zero, that
	 * conditional was skipped, so lines following it should also be
	 * skipped. Hence, we return COND_SKIP. Otherwise, the conditional
	 * was read so succeeding lines should be parsed (think about it...)
	 * so we return COND_PARSE, unless this endif isn't paired with
	 * a decent if.  */
	    if (skipIfLevel != 0) {
		skipIfLevel--;
		return COND_SKIP;
	    } else {
d1046 8
a1053 6
		    Parse_Error(level, "if-less endif");
		    return COND_INVALID;
		} else {
		    skipLine = false;
		    condTop++;
		    return COND_PARSE;
d1055 40
a1094 70
	    }
	} else
	    return COND_INVALID;
	break;
	/* Recognize other keywords there, to simplify parser's task */
    case K_COND_FOR % MAGICSLOTS2:
    	if (k == K_COND_FOR && len == strlen(COND_FOR) &&
	    strncmp(line, COND_FOR, len) == 0)
	    return COND_ISFOR;
	else
	    return COND_INVALID;
    case K_COND_UNDEF % MAGICSLOTS2:
    	if (k == K_COND_UNDEF && len == strlen(COND_UNDEF) &&
	    strncmp(line, COND_UNDEF, len) == 0)
	    return COND_ISUNDEF;
	else
	    return COND_INVALID;
    case K_COND_POISON % MAGICSLOTS2:
    	if (k == K_COND_POISON && len == strlen(COND_POISON) &&
	    strncmp(line, COND_POISON, len) == 0)
	    return COND_ISPOISON;
	else
	    return COND_INVALID;
    case K_COND_INCLUDE % MAGICSLOTS2:
    	if (k == K_COND_INCLUDE && len == strlen(COND_INCLUDE) &&
	    strncmp(line, COND_INCLUDE, len) == 0)
	    return COND_ISINCLUDE;
	else
	    return COND_INVALID;
    default:
	/* Not a valid conditional type. No error...  */
	return COND_INVALID;
    }

    if (ifp->isElse) {
	if (condTop == MAXIF) {
	    Parse_Error(level, "if-less elif");
	    return COND_INVALID;
	} else if (skipIfLevel != 0) {
	    /* If skipping this conditional, just ignore the whole thing.
	     * If we don't, the user might be employing a variable that's
	     * undefined, for which there's an enclosing ifdef that
	     * we're skipping...  */
	    return COND_SKIP;
	}
    } else if (skipLine) {
	/* Don't even try to evaluate a conditional that's not an else if
	 * we're skipping things...  */
	skipIfLevel++;
	return COND_SKIP;
    }

    if (ifp->defProc) {
	/* Initialize file-global variables for parsing.  */
	condDefProc = ifp->defProc;
	condInvert = ifp->doNot;

	line += len;

	while (*line == ' ' || *line == '\t')
	    line++;

	condExpr = line;
	condPushBack = None;

	switch (CondE(true)) {
	    case True:
		if (CondToken(true) == EndOfFile) {
		    value = true;
		    break;
d1096 20
a1115 11
		goto err;
		/* FALLTHROUGH */
	    case False:
		if (CondToken(true) == EndOfFile) {
		    value = false;
		    break;
		}
		/* FALLTHROUGH */
	    case Err:
	    err:
		Parse_Error(level, "Malformed conditional (%s)", line);
d1117 6
a1122 2
	    default:
		break;
a1123 27
    }

    if (!ifp->isElse)
	condTop--;
    else if (skipIfLevel != 0 || condStack[condTop].value) {
	/* If this is an else-type conditional, it should only take effect
	 * if its corresponding if was evaluated and false. If its if was
	 * true or skipped, we return COND_SKIP (and start skipping in case
	 * we weren't already), leaving the stack unmolested so later elif's
	 * don't screw up...  */
	skipLine = true;
	return COND_SKIP;
    }

    if (condTop < 0) {
	/* This is the one case where we can definitely proclaim a fatal
	 * error. If we don't, we're hosed.  */
	Parse_Error(PARSE_FATAL, "Too many nested if's. %d max.", MAXIF);
	condTop = 0;
	return COND_INVALID;
    } else {
	condStack[condTop].value = value;
	condStack[condTop].lineno = Parse_Getlineno();
	condStack[condTop].filename = Parse_Getfilename();
	skipLine = !value;
	return value ? COND_PARSE : COND_SKIP;
    }
d1129 1
a1129 1
    int i;
d1131 8
a1138 7
    if (condTop != MAXIF) {
	Parse_Error(PARSE_FATAL, "%s%d open conditional%s",
	    condTop == 0 ? "at least ": "", MAXIF-condTop,
	    MAXIF-condTop == 1 ? "" : "s");
	for (i = MAXIF-1; i >= condTop; i--) {
	    fprintf(stderr, "\t at line %lu of %s\n", condStack[i].lineno,
		condStack[i].filename);
d1140 1
a1140 2
    }
    condTop = MAXIF;
@


1.37
log
@kill += 1, -= 1     -> ++, --
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.36 2007/09/16 12:30:35 espie Exp $	*/
d195 1
a195 1
CondGetArg(const char **linePtr, struct Name *arg, const char *func, 
d872 1
a872 1
/* Evaluate conditional in line.  
d904 1
a904 1
	if (k == K_COND_IF && len == strlen(COND_IF) && 
d911 1
a911 1
	if (k == K_COND_IFDEF && len == strlen(COND_IFDEF) && 
d918 1
a918 1
	if (k == K_COND_IFNDEF && len == strlen(COND_IFNDEF) && 
d925 1
a925 1
	if (k == K_COND_IFMAKE && len == strlen(COND_IFMAKE) && 
d932 1
a932 1
	if (k == K_COND_IFNMAKE && len == strlen(COND_IFNMAKE) && 
d939 1
a939 1
	if (k == K_COND_ELIF && len == strlen(COND_ELIF) && 
d946 1
a946 1
	if (k == K_COND_ELIFDEF && len == strlen(COND_ELIFDEF) && 
d953 1
a953 1
	if (k == K_COND_ELIFNDEF && len == strlen(COND_ELIFNDEF) && 
d960 1
a960 1
	if (k == K_COND_ELIFMAKE && len == strlen(COND_ELIFMAKE) && 
d967 1
a967 1
	if (k == K_COND_ELIFNMAKE && len == strlen(COND_ELIFNMAKE) && 
d976 1
a976 1
	if (k == K_COND_ELSE && len == strlen(COND_ELSE) && 
d990 1
a990 1
	if (k == K_COND_ENDIF && len == strlen(COND_ENDIF) && 
d1097 1
a1097 1
    
d1131 1
a1131 1
	Parse_Error(PARSE_FATAL, "%s%d open conditional%s", 
@


1.36
log
@rename dirSearchPath -> defaultPath, and openDirectories -> knownDirectories
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.35 2007/07/17 10:54:46 espie Exp $	*/
d999 1
a999 1
		skipIfLevel -= 1;
d1007 1
a1007 1
		    condTop += 1;
d1058 1
a1058 1
	skipIfLevel += 1;
d1099 1
a1099 1
	condTop -= 1;
@


1.35
log
@comment snicky usage of strchr
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.34 2007/07/08 17:44:20 espie Exp $	*/
d292 1
a292 1
    path = Dir_FindFilei(arg->s, arg->e, dirSearchPath);
@


1.34
log
@A set of big related changes. okay millert@@, tested further by kettenis@@
and matthieu@@

This all revolves around putting ALL global variables into one single big
hash, and using flags. This removes some impossible to understand stuff,
like old varfind, and allows for some nice stuff.
- each time we reference a global variable, we create it, possibly as a dummy
variable.
- each time we go to the environment, we remember it, thus we no longer go
back to it.

Lists of dependant changes:
- isolate changes to oldVars and checkEnvFirst.
- remove VAR_CMD and VAR_GLOBAL contexts. The only distinction is in parsevar.
Split Parse_DoVar into Parse_DoVar and Parse_CmdlineVar
- rework var modules around obtain_global_var, observe flags in various
functions like Var_Value and Var_Seti.
- Var_Seti/Var_Appendi are almost the same code, use that internally.
- add magic to handle the very special SHELL variable.
- introduce Var_Definedi for the cases where we don't want the actual
value, to simplify tests.
- add keyword .poison, parse it and set global flags accordingly.
- do poison_checks where needed.
- document poison.
- in for loops, set variable temporarily, so that Var_SubstVar will also
substitute it in varmodifiers expressions.
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.33 2007/03/20 03:50:39 tedu Exp $	*/
d174 1
@


1.33
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.32 2007/01/04 18:01:32 espie Exp $	*/
d250 1
a250 4
    if (Var_Valuei(arg->s, arg->e) != NULL)
	return true;
    else
	return false;
d1024 6
@


1.32
log
@extend make grammar slightly:
- make it possible to have constructs like
.if $A$B == "value"
instead of simpler
.if $A == "value"

- make it possible to have explicit strings comparisons like:
.if "string" == "string2"

this comes in handy in .for loops, where the variable is expanded, and
thus there is no longer any variable for make to look at.

So in the end, the "" can sometimes be removed, but not always... small
price to pay to get `better' expressions.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.31 2006/01/20 23:10:19 espie Exp $	*/
d647 1
a647 1
		for (p = val; *p && isspace(*p); p++)
@


1.31
log
@use stdint.h where appropriate. okay millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.30 2004/04/07 13:11:35 espie Exp $	*/
d78 2
d115 2
a371 1
    Token	t;
a372 2
    const char	*rhs;
    const char	*op;
a377 1
    t = Err;
d399 2
a400 2
	lhs = Buf_Retrieve(&buf);

d404 33
d743 2
@


1.30
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.29 2003/06/03 02:56:11 millert Exp $	*/
d42 1
d854 1
a854 1
    u_int32_t 	k;
@


1.29
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.28 2002/06/11 21:12:11 espie Exp $	*/
d166 1
a166 2
find_cond(p)
    const char *p;
d189 2
a190 5
CondGetArg(linePtr, arg, func, parens)
    const char 		**linePtr;
    struct Name	  	*arg;
    const char	  	*func;
    bool	  	parens;	/* true if arg should be bounded by parens */
d243 1
a243 2
CondDoDefined(arg)
    struct Name	*arg;
d261 1
a261 2
CondDoMake(arg)
    struct Name	*arg;
d284 1
a284 2
CondDoExists(arg)
    struct Name *arg;
d309 1
a309 2
CondDoTarget(arg)
    struct Name	*arg;
d338 1
a338 3
CondCvtArg(str, value)
    const char		*str;
    double		*value;
d365 1
a365 2
CondHandleVarSpec(doEval)
    bool doEval;
d583 1
a583 2
CondHandleDefault(doEval)
    bool	doEval;
d673 1
a673 2
CondToken(doEval)
    bool doEval;
d733 1
a733 2
CondT(doEval)
    bool doEval;
d773 1
a773 2
CondF(doEval)
    bool doEval;
d812 1
a812 2
CondE(doEval)
    bool doEval;
d1086 1
a1086 1
Cond_End()
@


1.28
log
@This is the first step in sanitizing the conditional parser.

Change the conditional recognition algorithm:
scan for a sequence of alphabetic characters, hash it, and compare it against
a small table (using ohash functions).
This makes Cond_Eval entry more logical, and allows for some shortcuts in
recognizing .include, .for, .undef.

This also means that conditionals must have an intervening blank between
the keyword and the actual test, e.g.,
.ifA
will no longer work.

(but no-one actually uses this, and it's highly obfuscated)

Okay miod@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.27 2002/04/17 16:45:02 espie Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.27
log
@Disallow condTop from ever becoming <0. Fixes regress/mk17 mk18.
ok millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.26 2001/05/29 12:53:39 espie Exp $	*/
d53 2
d64 1
d119 3
a121 4
static struct If {
    char	*form;		/* Form of if */
    int 	formlen;	/* Length of form */
    bool	doNot;		/* true if default function should be negated */
d123 1
a123 8
				/* Default function to apply */
} ifs[] = {
    { "ifdef",	  5,	  false,  CondDoDefined },
    { "ifndef",   6,	  true,   CondDoDefined },
    { "ifmake",   6,	  false,  CondDoMake },
    { "ifnmake",  7,	  true,   CondDoMake },
    { "if",	  2,	  false,  CondDoDefined },
    { NULL,	  0,	  false,  NULL }
d126 24
d858 5
a862 2
/* A conditional line looks like this:
 *	    <cond-type> <expr>
d869 1
a869 2
Cond_Eval(line)
    const char	    *line;    /* Line to parse */
d871 7
a877 4
    struct If	    *ifp;
    bool	    isElse;
    bool	    value = false;
    int 	    level;	/* Level at which to report errors. */
d881 97
a977 9
    /* Stuff we are looking for can be if*, elif*, else, or endif.
     * otherwise, this is not our turf.  */

    /* Find what type of if we're dealing with. The result is left
     * in ifp and isElse is set true if it's an elif line.  */
    if (line[0] == 'e' && line[1] == 'l') {
	line += 2;
	isElse = true;
    } else if (strncmp(line, "endif", 5) == 0) {
d984 3
a986 7
	if (skipIfLevel != 0) {
	    skipIfLevel -= 1;
	    return COND_SKIP;
	} else {
	    if (condTop == MAXIF) {
		Parse_Error(level, "if-less endif");
		return COND_INVALID;
d988 8
a995 3
		skipLine = false;
		condTop += 1;
		return COND_PARSE;
d997 25
a1021 9
	}
    } else
	isElse = false;

    /* Figure out what sort of conditional it is -- what its default
     * function is, etc. -- by looking in the table of valid "ifs" */
    for (ifp = ifs; ifp->form != NULL; ifp++) {
	if (strncmp(ifp->form, line, ifp->formlen) == 0)
	    break;
d1024 3
a1026 14
    if (ifp->form == NULL) {
	/* Nothing fits. If the first word on the line is actually
	 * "else", it's a valid conditional whose value is the inverse
	 * of the previous if we parsed.  */
	if (isElse && line[0] == 's' && line[1] == 'e') {
	    if (condTop == MAXIF) {
		Parse_Error(level, "if-less else");
		return COND_INVALID;
	    } else if (skipIfLevel == 0)
		value = !condStack[condTop].value;
	    else
		return COND_SKIP;
	} else
	    /* Not a valid conditional type. No error...  */
d1028 5
a1032 16
    } else {
	if (isElse) {
	    if (condTop == MAXIF) {
		Parse_Error(level, "if-less elif");
		return COND_INVALID;
	    } else if (skipIfLevel != 0) {
		/* If skipping this conditional, just ignore the whole thing.
		 * If we don't, the user might be employing a variable that's
		 * undefined, for which there's an enclosing ifdef that
		 * we're skipping...  */
		return COND_SKIP;
	    }
	} else if (skipLine) {
	    /* Don't even try to evaluate a conditional that's not an else if
	     * we're skipping things...  */
	    skipIfLevel += 1;
d1035 6
d1042 1
d1047 1
a1047 1
	line += ifp->formlen;
d1077 2
a1078 1
    if (!isElse)
@


1.26
log
@Take includes out of lst.h, re-add what's needed to separate files.
Removes remaining lint stuff from lst.lib.
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.25 2001/05/23 12:34:41 espie Exp $	*/
d979 1
d996 3
a998 2
	Parse_Error(PARSE_FATAL, "%d open conditional%s", MAXIF-condTop,
		    MAXIF-condTop == 1 ? "" : "s");
@


1.25
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: cond.c,v 1.4 1998/12/05 00:06:27 espie Exp $	*/
d46 1
@


1.24
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d43 18
a60 25
/*-
 * cond.c --
 *	Functions to handle conditionals in a makefile.
 *
 * Interface:
 *	Cond_Eval	Evaluate the conditional in the passed line.
 *
 */

#include    <ctype.h>
#include    <math.h>
#include    <stddef.h>
#include    "make.h"
#include    "ohash.h"
#include    "dir.h"
#include    "buf.h"

#ifndef lint
#if 0
static char sccsid[] = "@@(#)cond.c	8.2 (Berkeley) 1/2/94";
#else
UNUSED
static char rcsid[] = "$OpenBSD: cond.c,v 1.4 1998/12/05 00:06:27 espie Exp $";
#endif
#endif /* not lint */
d88 1
a88 1
 * terminal, and return the result as either True or False.
d99 13
a111 13
static Boolean CondGetArg(const char **, struct Name *,
    const char *, Boolean);
static Boolean CondDoDefined(struct Name *);
static Boolean CondDoMake(struct Name *);
static Boolean CondDoExists(struct Name *);
static Boolean CondDoTarget(struct Name *);
static Boolean CondCvtArg(const char *, double *);
static Token CondToken(Boolean);
static Token CondT(Boolean);
static Token CondF(Boolean);
static Token CondE(Boolean);
static Token CondHandleVarSpec(Boolean);
static Token CondHandleDefault(Boolean);
d118 2
a119 2
    Boolean	doNot;		/* TRUE if default function should be negated */
    Boolean	(*defProc)(struct Name *);
d122 6
a127 6
    { "ifdef",	  5,	  FALSE,  CondDoDefined },
    { "ifndef",   6,	  TRUE,   CondDoDefined },
    { "ifmake",   6,	  FALSE,  CondDoMake },
    { "ifnmake",  7,	  TRUE,   CondDoMake },
    { "if",	  2,	  FALSE,  CondDoDefined },
    { NULL,	  0,	  FALSE,  NULL }
d130 2
a131 2
static Boolean	  condInvert;		/* Invert the default function */
static Boolean	  (*condDefProc)	/* Default function to apply */
d140 1
a140 1
	Boolean 	value;
d146 1
a146 1
static Boolean	  skipLine = FALSE;	/* Whether the parse module is skipping
d166 1
a166 1
 *	TRUE if evaluation went okay
d173 1
a173 1
static Boolean
d178 1
a178 1
    Boolean	  	parens;	/* TRUE if arg should be bounded by parens */
d197 2
a198 2
	arg->tofree = FALSE;
	return FALSE;
d205 1
a205 1
    cp = Var_Name_Get(cp, arg, NULL, TRUE, find_cond);
d212 1
a212 1
	return FALSE;
d218 1
a218 1
    return TRUE;
d227 1
a227 1
 *	TRUE if the given variable is defined.
d230 1
a230 1
static Boolean
d234 2
a235 2
    if (Var_Value_interval(arg->s, arg->e) != NULL)
	return TRUE;
d237 1
a237 1
	return FALSE;
d246 1
a246 1
 *	TRUE if the given target is being made.
d249 1
a249 1
static Boolean
d255 4
a258 3
    for (ln = Lst_First(&create); ln != NULL; ln = Lst_Adv(ln)) {
	if (Str_Matchi((char *)Lst_Datum(ln), arg->s, arg->e))
	    return TRUE;
d261 1
a261 1
    return FALSE;
d270 1
a270 1
 *	TRUE if the file exists and FALSE if it does not.
d273 1
a273 1
static Boolean
d277 1
a277 1
    Boolean result;
d280 1
a280 1
    path = Dir_FindFilei(arg->s, arg->e, &dirSearchPath);
d282 1
a282 1
	result = TRUE;
d285 1
a285 1
	result = FALSE;
d296 1
a296 1
 *	TRUE if the node exists as a target and FALSE if it does not.
d299 1
a299 1
static Boolean
d305 1
a305 1
    gn = Targ_FindNode(arg->s, arg->e, TARG_NOCREATE);
d307 1
a307 1
	return TRUE;
d309 1
a309 1
	return FALSE;
d329 1
a329 1
static Boolean
d344 1
a344 1
		return FALSE;
d348 1
a348 1
	return TRUE;
d360 1
a360 1
    Boolean doEval;
d367 1
a367 1
    Boolean	doFree;
d395 1
a395 1
	doFree = TRUE;
d456 1
a456 2
		if (Var_ParseBuffer(&buf, cp, NULL, doEval, &len)
		    == SUCCESS) {
d497 1
a497 1
	    Boolean	freeIt;
d569 1
a569 1
    Boolean (*proc)(struct Name *);
d579 1
a579 1
    Boolean	doEval;
d581 3
a583 3
    Boolean	t;
    Boolean	(*evalProc)(struct Name *);
    Boolean	invert = FALSE;
d592 1
a592 1
	Boolean doFree;
d628 1
a628 1
		if (CondGetArg(&condExpr, &arg, op->s, TRUE))
d640 1
a640 1
	 * function if condInvert is TRUE.  */
d644 1
a644 1
	CondGetArg(&condExpr, &arg, "", FALSE);
d648 1
a648 1
     * is TRUE, we invert the sense of the function.  */
d652 1
a652 1
    Var_Name_Free(&arg);
d670 1
a670 1
    Boolean doEval;
d731 1
a731 1
    Boolean doEval;
d772 1
a772 1
    Boolean doEval;
d789 1
a789 1
		(void)CondF(FALSE);
d812 1
a812 1
    Boolean doEval;
d830 1
a830 1
		(void)CondE(FALSE);
d838 1
a838 5
/*-
 *-----------------------------------------------------------------------
 * Cond_Eval --
 *	Evaluate the conditional in the passed fragment. The fragment
 *	looks like this:
a843 6
 *
 * Results:
 *	COND_PARSE	if should parse lines after the conditional
 *	COND_SKIP	if should skip lines after the conditional
 *	COND_INVALID	if not a valid conditional.
 *-----------------------------------------------------------------------
d847 1
a847 1
    char	    *line;    /* Line to parse */
d850 2
a851 2
    Boolean	    isElse;
    Boolean	    value = FALSE;
d860 1
a860 1
     * in ifp and isElse is set TRUE if it's an elif line.  */
d863 1
a863 1
	isElse = TRUE;
d879 1
a879 1
		skipLine = FALSE;
d885 1
a885 1
	isElse = FALSE;
d940 1
a940 1
	switch (CondE(TRUE)) {
d942 2
a943 2
		if (CondToken(TRUE) == EndOfFile) {
		    value = TRUE;
d949 2
a950 2
		if (CondToken(TRUE) == EndOfFile) {
		    value = FALSE;
d966 2
a967 2
	 * if its corresponding if was evaluated and FALSE. If its if was
	 * TRUE or skipped, we return COND_SKIP (and start skipping in case
d970 1
a970 1
	skipLine = TRUE;
a987 9
/*-
 *-----------------------------------------------------------------------
 * Cond_End --
 *	Make sure everything's clean at the end of a makefile.
 *
 * Side Effects:
 *	Parse_Error will be called if open conditionals are around.
 *-----------------------------------------------------------------------
 */
@


1.23
log
@Guard against Var_Value() being applied to an empty string, which it
doesn't do [for efficiency reason, hash_interval does not deal with
empty strings not declared as intervals. More recent incarnations of
this code will use Var_Value_interval extensively instead]

Problem found by Peter Stromberg.
@
text
@d1 2
a2 1
/*	$OpenBSD: cond.c,v 1.22 2000/09/14 13:46:44 espie Exp $	*/
d48 1
a48 1
 *	Cond_Eval 	Evaluate the conditional in the passed line.
a51 1
#include    <stddef.h>
d54 1
d65 1
a65 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.22 2000/09/14 13:46:44 espie Exp $";
d69 2
a70 2
/*
 * The parsing of conditional expressions is based on this grammar:
d97 1
a97 2
 * All Non-Terminal functions (CondE, CondF and CondT) return Err on error.
 */
d99 1
a99 1
    And, Or, Not, True, False, LParen, RParen, EndOfFile, None, Err
d106 15
a120 12
static void CondPushBack __P((Token));
static Boolean CondGetArg __P((char **, char **, size_t *, char *, Boolean));
static Boolean CondDoDefined __P((size_t, char *));
static int CondStrMatch __P((void *, void *));
static Boolean CondDoMake __P((size_t, char *));
static Boolean CondDoExists __P((size_t, char *));
static Boolean CondDoTarget __P((size_t, char *));
static Boolean CondCvtArg __P((char *, double *));
static Token CondToken __P((Boolean));
static Token CondT __P((Boolean));
static Token CondF __P((Boolean));
static Token CondE __P((Boolean));
d123 5
a127 4
    char	*form;	      /* Form of if */
    int		formlen;      /* Length of form */
    Boolean	doNot;	      /* TRUE if default function should be negated */
    Boolean	(*defProc) __P((size_t, char *)); /* Default function to apply */
d130 3
a132 3
    { "ifndef",	  6,	  TRUE,	  CondDoDefined },
    { "ifmake",	  6,	  FALSE,  CondDoMake },
    { "ifnmake",  7,	  TRUE,	  CondDoMake },
d137 1
a137 1
static Boolean	  condInvert;	    	/* Invert the default function */
d139 2
a140 2
		    __P((size_t, char *));
static char 	  *condExpr;	    	/* The expression to parse */
d144 1
a144 1
#define	MAXIF		30	  /* greatest depth of #if'ing */
d148 6
a153 6
	unsigned long 	lineno;
	const char 	*filename;
} condStack[MAXIF]; 			/* Stack of conditionals */
static int  	  condTop = MAXIF;  	/* Top-most conditional */
static int  	  skipIfLevel=0;    	/* Depth of skipped conditionals */
static Boolean	  skipLine = FALSE; 	/* Whether the parse module is skipping
d156 8
a163 19
/*-
 *-----------------------------------------------------------------------
 * CondPushBack --
 *	Push back the most recent token read. We only need one level of
 *	this, so the thing is just stored in 'condPushback'.
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	condPushback is overwritten.
 *
 *-----------------------------------------------------------------------
 */
static void
CondPushBack (t)
    Token   	  t;	/* Token to push back into the "stream" */
{
    condPushBack = t;
d165 2
a166 1

d177 1
a177 1
 *	function call. The argument and argument length are filled.
d181 5
a185 6
CondGetArg(linePtr, argPtr, argLen, func, parens)
    char    	  **linePtr;
    char    	  **argPtr;
    size_t    	  *argLen;
    char    	  *func;
    Boolean 	  parens;   	/* TRUE if arg should be bounded by parens */
d187 1
a187 2
    register char *cp;
    BUFFER buf;
d191 1
a191 1
	while (*cp != '(' && *cp != '\0') {
d193 1
a193 2
	}
	if (*cp == '(') {
a194 1
	}
d198 1
a198 2
	/*
	 * No arguments whatsoever. Because 'make' and 'defined' aren't really
d201 4
a204 3
	 * the word 'make' or 'defined' at the beginning of a symbol...
	 */
	*argPtr = cp;
d208 1
a208 1
    while (*cp == ' ' || *cp == '\t') {
a209 21
    }

    /*
     * Create a buffer for the argument and start it out at 16 characters
     * long. Why 16? Why not?
     */
    Buf_Init(&buf, 16);

    while ((strchr(" \t)&|", *cp) == (char *)NULL) && (*cp != '\0')) {
	if (*cp == '$') {
	    /*
	     * Parse the variable spec and install it as part of the argument
	     * if it's valid. We tell Var_Parse to complain on an undefined
	     * variable, so we don't do it too. Nor do we return an error,
	     * though perhaps we should...
	     */
	    char  	*cp2;
	    size_t	len;
	    Boolean	doFree;

	    cp2 = Var_Parse(cp, NULL, TRUE, &len, &doFree);
a210 10
	    Buf_AddString(&buf, cp2);
	    if (doFree) {
		free(cp2);
	    }
	    cp += len;
	} else {
	    Buf_AddChar(&buf, *cp);
	    cp++;
	}
    }
d212 1
a212 2
    *argPtr = Buf_Retrieve(&buf);
    *argLen = Buf_Size(&buf);
d214 1
a214 1
    while (*cp == ' ' || *cp == '\t') {
a215 1
    }
d217 1
a217 1
	Parse_Error (PARSE_WARNING, "Missing closing parenthesis for %s()",
d220 2
a221 4
    } else if (parens) {
	/*
	 * Advance pointer past close parenthesis.
	 */
a222 1
    }
d227 1
a227 1

a234 4
 *
 * Side Effects:
 *	None.
 *
d238 2
a239 3
CondDoDefined(argLen, arg)
    size_t  argLen;
    char    *arg;
d241 2
a242 9
    char    savec = arg[argLen];
    Boolean result;

    if (argLen == 0)
    	return FALSE;

    arg[argLen] = '\0';
    if (Var_Value(arg, NULL) != NULL)
	result = TRUE;
d244 1
a244 3
	result = FALSE;
    arg[argLen] = savec;
    return (result);
d246 1
a246 19

/*-
 *-----------------------------------------------------------------------
 * CondStrMatch --
 *	Front-end for Str_Match so it returns 0 on match and non-zero
 *	on mismatch. Callback function for CondDoMake via Lst_Find
 *
 * Results:
 *	0 if string matches pattern
 *-----------------------------------------------------------------------
 */
static int
CondStrMatch(string, pattern)
    void *string;
    void *pattern;
{
    return !Str_Match((char *)string,(char *)pattern);
}

a253 4
 *
 * Side Effects:
 *	None.
 *
d257 2
a258 3
CondDoMake (argLen, arg)
    size_t  argLen;
    char    *arg;
d260 1
a260 2
    char    savec = arg[argLen];
    Boolean result;
d262 3
a264 5
    arg[argLen] = '\0';
    if (Lst_Find(&create, CondStrMatch, arg) == NULL) {
	result = FALSE;
    } else {
	result = TRUE;
d266 2
a267 2
    arg[argLen] = savec;
    return (result);
d269 1
a269 1

a276 4
 *
 * Side Effects:
 *	None.
 *
d280 2
a281 3
CondDoExists (argLen, arg)
    size_t  argLen;
    char    *arg;
a282 1
    char    savec = arg[argLen];
d286 2
a287 3
    arg[argLen] = '\0';
    path = Dir_FindFile(arg, &dirSearchPath);
    if (path != (char *)NULL) {
d293 1
a293 2
    arg[argLen] = savec;
    return (result);
d295 1
a295 1

a302 4
 *
 * Side Effects:
 *	None.
 *
d306 2
a307 3
CondDoTarget(argLen, arg)
    size_t  argLen;
    char    *arg;
a308 2
    char    savec = arg[argLen];
    Boolean result;
d311 5
a315 9
    arg[argLen] = '\0';
    gn = Targ_FindNode(arg, TARG_NOCREATE);
    if ((gn != NULL) && !OP_NOP(gn->type)) {
	result = TRUE;
    } else {
	result = FALSE;
    }
    arg[argLen] = savec;
    return (result);
d318 1
a318 1

a332 2
 *
 *
d337 1
a337 1
    register char    	*str;
d340 2
a341 2
    if ((*str == '0') && (str[1] == 'x')) {
	register long i;
d345 1
a345 1
	    if (isdigit((unsigned char) *str))
d347 2
a348 2
	    else if (isxdigit((unsigned char) *str))
		x = 10 + *str - isupper((unsigned char) *str) ? 'A' : 'a';
d362 301
a662 1

a672 1
 *
a678 1
    Token	  t;
d680 12
a691 2
    if (condPushBack == None) {
	while (*condExpr == ' ' || *condExpr == '\t') {
d693 6
a698 4
	}
	switch (*condExpr) {
	    case '(':
		t = LParen;
d700 4
a703 3
		break;
	    case ')':
		t = RParen;
d705 12
a716 394
		break;
	    case '|':
		if (condExpr[1] == '|') {
		    condExpr++;
		}
		condExpr++;
		t = Or;
		break;
	    case '&':
		if (condExpr[1] == '&') {
		    condExpr++;
		}
		condExpr++;
		t = And;
		break;
	    case '!':
		t = Not;
		condExpr++;
		break;
	    case '\n':
	    case '\0':
		t = EndOfFile;
		break;
	    case '$': {
		char	*lhs;
		char	*rhs;
		char	*op;
		size_t	varSpecLen;
		Boolean	doFree;

		/*
		 * Parse the variable spec and skip over it, saving its
		 * value in lhs.
		 */
		t = Err;
		lhs = Var_Parse(condExpr, NULL, doEval,&varSpecLen,&doFree);
		if (lhs == var_Error) {
		    /*
		     * Even if !doEval, we still report syntax errors, which
		     * is what getting var_Error back with !doEval means.
		     */
		    return(Err);
		}
		condExpr += varSpecLen;

		if (!isspace((unsigned char) *condExpr) &&
		    strchr("!=><", *condExpr) == NULL) {
		    BUFFER buf;

		    Buf_Init(&buf, 0);

		    Buf_AddString(&buf, lhs);

		    if (doFree)
			free(lhs);

		    for (;*condExpr && !isspace((unsigned char) *condExpr);
			 condExpr++)
			Buf_AddChar(&buf, *condExpr);

		    lhs = Buf_Retrieve(&buf);

		    doFree = TRUE;
		}

		/*
		 * Skip whitespace to get to the operator
		 */
		while (isspace((unsigned char) *condExpr))
		    condExpr++;

		/*
		 * Make sure the operator is a valid one. If it isn't a
		 * known relational operator, pretend we got a
		 * != 0 comparison.
		 */
		op = condExpr;
		switch (*condExpr) {
		    case '!':
		    case '=':
		    case '<':
		    case '>':
			if (condExpr[1] == '=') {
			    condExpr += 2;
			} else {
			    condExpr += 1;
			}
			break;
		    default:
			op = "!=";
			rhs = "0";

			goto do_compare;
		}
		while (isspace((unsigned char) *condExpr)) {
		    condExpr++;
		}
		if (*condExpr == '\0') {
		    Parse_Error(PARSE_WARNING,
				"Missing right-hand-side of operator");
		    goto error;
		}
		rhs = condExpr;
do_compare:
		if (*rhs == '"') {
		    /*
		     * Doing a string comparison. Only allow == and != for
		     * operators.
		     */
		    char    *string;
		    char    *cp, *cp2;
		    int	    qt;
		    BUFFER  buf;

do_string_compare:
		    if (((*op != '!') && (*op != '=')) || (op[1] != '=')) {
			Parse_Error(PARSE_WARNING,
		"String comparison operator should be either == or !=");
			goto error;
		    }

		    Buf_Init(&buf, 0);
		    qt = *rhs == '"' ? 1 : 0;

		    for (cp = &rhs[qt];
			 ((qt && (*cp != '"')) ||
			  (!qt && strchr(" \t)", *cp) == NULL)) &&
			 (*cp != '\0'); cp++) {
			if ((*cp == '\\') && (cp[1] != '\0')) {
			    /*
			     * Backslash escapes things -- skip over next
			     * character, if it exists.
			     */
			    cp++;
			    Buf_AddChar(&buf, *cp);
			} else if (*cp == '$') {
			    size_t  len;
			    Boolean freeIt;

			    cp2 = Var_Parse(cp, NULL, doEval,&len, &freeIt);
			    if (cp2 != var_Error) {
				Buf_AddString(&buf, cp2);
				if (freeIt) {
				    free(cp2);
				}
				cp += len - 1;
			    } else {
				Buf_AddChar(&buf, *cp);
			    }
			} else {
			    Buf_AddChar(&buf, *cp);
			}
		    }

		    string = Buf_Retrieve(&buf);

		    if (DEBUG(COND)) {
			printf("lhs = \"%s\", rhs = \"%s\", op = %.2s\n",
			       lhs, string, op);
		    }
		    /*
		     * Null-terminate rhs and perform the comparison.
		     * t is set to the result.
		     */
		    if (*op == '=') {
			t = strcmp(lhs, string) ? False : True;
		    } else {
			t = strcmp(lhs, string) ? True : False;
		    }
		    free(string);
		    if (rhs == condExpr) {
		    	if (!qt && *cp == ')')
			    condExpr = cp;
			else if (*cp == '\0')
			    condExpr = cp;
			else
			    condExpr = cp + 1;
		    }
		} else {
		    /*
		     * rhs is either a float or an integer. Convert both the
		     * lhs and the rhs to a double and compare the two.
		     */
		    double  	left, right;
		    char    	*string;

		    if (!CondCvtArg(lhs, &left))
			goto do_string_compare;
		    if (*rhs == '$') {
			size_t 	len;
			Boolean	freeIt;

			string = Var_Parse(rhs, NULL, doEval,&len,&freeIt);
			if (string == var_Error) {
			    right = 0.0;
			} else {
			    if (!CondCvtArg(string, &right)) {
				if (freeIt)
				    free(string);
				goto do_string_compare;
			    }
			    if (freeIt)
				free(string);
			    if (rhs == condExpr)
				condExpr += len;
			}
		    } else {
			if (!CondCvtArg(rhs, &right))
			    goto do_string_compare;
			if (rhs == condExpr) {
			    /*
			     * Skip over the right-hand side
			     */
			    while(!isspace((unsigned char) *condExpr) &&
				  (*condExpr != '\0')) {
				condExpr++;
			    }
			}
		    }

		    if (DEBUG(COND)) {
			printf("left = %f, right = %f, op = %.2s\n", left,
			       right, op);
		    }
		    switch(op[0]) {
		    case '!':
			if (op[1] != '=') {
			    Parse_Error(PARSE_WARNING,
					"Unknown operator");
			    goto error;
			}
			t = (left != right ? True : False);
			break;
		    case '=':
			if (op[1] != '=') {
			    Parse_Error(PARSE_WARNING,
					"Unknown operator");
			    goto error;
			}
			t = (left == right ? True : False);
			break;
		    case '<':
			if (op[1] == '=') {
			    t = (left <= right ? True : False);
			} else {
			    t = (left < right ? True : False);
			}
			break;
		    case '>':
			if (op[1] == '=') {
			    t = (left >= right ? True : False);
			} else {
			    t = (left > right ? True : False);
			}
			break;
		    }
		}
error:
		if (doFree)
		    free(lhs);
		break;
	    }
	    default: {
		Boolean (*evalProc) __P((size_t, char *));
		Boolean invert = FALSE;
		char	*arg;
		size_t	arglen;

		if (strncmp (condExpr, "defined", 7) == 0) {
		    /*
		     * Use CondDoDefined to evaluate the argument and
		     * CondGetArg to extract the argument from the 'function
		     * call'.
		     */
		    evalProc = CondDoDefined;
		    condExpr += 7;
		    if (!CondGetArg(&condExpr, &arg, &arglen, 
		    	"defined", TRUE)) {
			    condExpr -= 7;
			    goto use_default;
 		    }
		} else if (strncmp (condExpr, "make", 4) == 0) {
		    /*
		     * Use CondDoMake to evaluate the argument and
		     * CondGetArg to extract the argument from the 'function
		     * call'.
		     */
		    evalProc = CondDoMake;
		    condExpr += 4;
		    if (!CondGetArg(&condExpr, &arg, &arglen, 
		    	"make", TRUE)) {
			    condExpr -= 4;
			    goto use_default;
 		    }
		} else if (strncmp (condExpr, "exists", 6) == 0) {
		    /*
		     * Use CondDoExists to evaluate the argument and
		     * CondGetArg to extract the argument from the
		     * 'function call'.
		     */
		    evalProc = CondDoExists;
		    condExpr += 6;
		    if (!CondGetArg(&condExpr, &arg, &arglen,
		    	"exists", TRUE)) {
			    condExpr -= 6;
			    goto use_default;
		    }
		} else if (strncmp(condExpr, "empty", 5) == 0) {
		    /*
		     * Use Var_Parse to parse the spec in parens and return
		     * True if the resulting string is empty.
		     */
		    size_t  length;
		    Boolean doFree;
		    char    *val;

		    condExpr += 5;

		    for (arglen = 0;
			 condExpr[arglen] != '(' && condExpr[arglen] != '\0';
			 arglen += 1)
			continue;

		    if (condExpr[arglen] != '\0') {
			val = Var_Parse(&condExpr[arglen - 1], NULL,
					doEval, &length, &doFree);
			if (val == var_Error) {
			    t = Err;
			} else {
			    /*
			     * A variable is empty when it just contains
			     * spaces... 4/15/92, christos
			     */
			    char *p;
			    for (p = val; *p && isspace((unsigned char)*p); p++)
				continue;
			    t = (*p == '\0') ? True : False;
			}
			if (doFree) {
			    free(val);
			}
			/*
			 * Advance condExpr to beyond the closing ). Note that
			 * we subtract one from arglen + length b/c length
			 * is calculated from condExpr[arglen - 1].
			 */
			condExpr += arglen + length - 1;
		    } else {
			condExpr -= 5;
			goto use_default;
		    }
		    break;
		} else if (strncmp (condExpr, "target", 6) == 0) {
		    /*
		     * Use CondDoTarget to evaluate the argument and
		     * CondGetArg to extract the argument from the
		     * 'function call'.
		     */
		    evalProc = CondDoTarget;
		    condExpr += 6;
		    if (!CondGetArg(&condExpr, &arg, &arglen, 
		    	"target", TRUE)) {
			    condExpr -= 6;
			    goto use_default;
		    }
		} else {
		    /*
		     * The symbol is itself the argument to the default
		     * function. We advance condExpr to the end of the symbol
		     * by hand (the next whitespace, closing paren or
		     * binary operator) and set to invert the evaluation
		     * function if condInvert is TRUE.
		     */
		use_default:
		    invert = condInvert;
		    evalProc = condDefProc;
		    /* XXX should we ignore problems now ? */
		    CondGetArg(&condExpr, &arg, &arglen, "", FALSE);
		}

		/*
		 * Evaluate the argument using the set function. If invert
		 * is TRUE, we invert the sense of the function.
		 */
		t = (!doEval || (* evalProc) (arglen, arg) ?
		     (invert ? False : True) :
		     (invert ? True : False));
		free(arg);
		break;
	    }
	}
    } else {
	t = condPushBack;
	condPushBack = None;
a717 1
    return (t);
d719 1
a719 1

a733 1
 *
d744 3
a746 5
    if (t == EndOfFile) {
	/*
	 * If we reached the end of the expression, the expression
	 * is malformed...
	 */
d748 2
a749 4
    } else if (t == LParen) {
	/*
	 * T -> ( E )
	 */
d751 2
a752 2
	if (t != Err) {
	    if (CondToken(doEval) != RParen) {
a753 2
	    }
	}
d756 1
a756 1
	if (t == True) {
d758 1
a758 1
	} else if (t == False) {
a759 1
	}
d761 1
a761 1
    return (t);
d763 1
a763 1

a774 1
 *
d788 1
a788 2
	    /*
	     * F -> T && F
d792 2
a793 3
	     * If T is True, the result is the r.h.s., be it an Err or no.
	     */
	    if (l == True) {
d795 5
a799 9
	    } else {
		(void) CondF(FALSE);
	    }
	} else {
	    /*
	     * F -> T
	     */
	    CondPushBack (o);
	}
d801 1
a801 1
    return (l);
d803 1
a803 1

a814 1
 *
d828 1
a828 2
	    /*
	     * E -> F || E
d833 2
a834 3
	     * again if l is True, we parse the r.h.s. to throw it away.
	     */
	    if (l == False) {
d836 5
a840 9
	    } else {
		(void) CondE(FALSE);
	    }
	} else {
	    /*
	     * E -> F
	     */
	    CondPushBack (o);
	}
d842 1
a842 1
    return (l);
d844 1
a844 1

d848 1
a848 1
 *	Evaluate the conditional in the passed line. The line
d850 1
a850 1
 *	    #<cond-type> <expr>
d859 1
a859 5
 *	COND_INVALID  	if not a valid conditional.
 *
 * Side Effects:
 *	None.
 *
d863 2
a864 2
Cond_Eval (line)
    char    	    *line;    /* Line to parse */
d867 3
a869 3
    Boolean 	    isElse;
    Boolean 	    value = FALSE;
    int	    	    level;  	/* Level at which to report errors. */
d873 2
a874 3
    for (line++; *line == ' ' || *line == '\t'; line++) {
	continue;
    }
d876 2
a877 4
    /*
     * Find what type of if we're dealing with. The result is left
     * in ifp and isElse is set TRUE if it's an elif line.
     */
d881 2
a882 3
    } else if (strncmp (line, "endif", 5) == 0) {
	/*
	 * End of a conditional section. If skipIfLevel is non-zero, that
d887 1
a887 2
	 * a decent if.
	 */
d890 1
a890 1
	    return (COND_SKIP);
d893 2
a894 2
		Parse_Error (level, "if-less endif");
		return (COND_INVALID);
d898 1
a898 1
		return (COND_PARSE);
d901 1
a901 1
    } else {
a902 1
    }
d904 4
a907 6
    /*
     * Figure out what sort of conditional it is -- what its default
     * function is, etc. -- by looking in the table of valid "ifs"
     */
    for (ifp = ifs; ifp->form != (char *)0; ifp++) {
	if (strncmp (ifp->form, line, ifp->formlen) == 0) {
a908 1
	}
d911 2
a912 3
    if (ifp->form == (char *) 0) {
	/*
	 * Nothing fit. If the first word on the line is actually
d914 2
a915 3
	 * of the previous if we parsed.
	 */
	if (isElse && (line[0] == 's') && (line[1] == 'e')) {
d917 3
a919 3
		Parse_Error (level, "if-less else");
		return (COND_INVALID);
	    } else if (skipIfLevel == 0) {
d921 5
a925 9
	    } else {
		return (COND_SKIP);
	    }
	} else {
	    /*
	     * Not a valid conditional type. No error...
	     */
	    return (COND_INVALID);
	}
d929 2
a930 2
		Parse_Error (level, "if-less elif");
		return (COND_INVALID);
d932 1
a932 2
		/*
		 * If skipping this conditional, just ignore the whole thing.
d935 2
a936 3
		 * we're skipping...
		 */
		return(COND_SKIP);
d939 2
a940 4
	    /*
	     * Don't even try to evaluate a conditional that's not an else if
	     * we're skipping things...
	     */
d942 1
a942 1
	    return(COND_SKIP);
d945 1
a945 3
	/*
	 * Initialize file-global variables for parsing
	 */
d951 1
a951 1
	while (*line == ' ' || *line == '\t') {
a952 1
	}
d973 2
a974 3
		Parse_Error (level, "Malformed conditional (%s)",
			     line);
		return (COND_INVALID);
d979 1
a979 1
    if (!isElse) {
d981 2
a982 3
    } else if ((skipIfLevel != 0) || condStack[condTop].value) {
	/*
	 * If this is an else-type conditional, it should only take effect
d986 1
a986 2
	 * don't screw up...
	 */
d988 1
a988 1
	return (COND_SKIP);
d992 4
a995 6
	/*
	 * This is the one case where we can definitely proclaim a fatal
	 * error. If we don't, we're hosed.
	 */
	Parse_Error (PARSE_FATAL, "Too many nested if's. %d max.", MAXIF);
	return (COND_INVALID);
d1001 1
a1001 1
	return (value ? COND_PARSE : COND_SKIP);
d1004 1
a1004 1

a1009 3
 * Results:
 *	None.
 *
a1011 1
 *
@


1.22
log
@Replace the old hash used to hold file names within a directory with
open hashing.

An interesting optimization is that the open hashing interface is more
fine-grained, hence we can compute the correct hash value at the start
of Dir_FindFile, and reuse it for each hash structure into which we look
(the effect is measurable on large directories along with objdir/VPATH).

Remove a few unnecessary Lst_Open/Lst_Close that serve no purpose except
obfuscating the code.

The interface to dir.h changes slightly, hence tedious includes changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.21 2000/09/14 13:32:06 espie Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.21 2000/09/14 13:32:06 espie Exp $";
d294 3
@


1.21
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.20 2000/07/17 23:54:26 espie Exp $	*/
d51 1
d55 1
a55 1
#include    "hash.h"
d64 1
a64 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.20 2000/07/17 23:54:26 espie Exp $";
@


1.20
log
@FALLTHRU -> FALLTHROUGH, requested by miod@@ and style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.19 2000/06/23 16:21:43 espie Exp $	*/
a41 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)cond.c	8.2 (Berkeley) 1/2/94";
#else
static char rcsid[] = "$OpenBSD: cond.c,v 1.19 2000/06/23 16:21:43 espie Exp $";
#endif
#endif /* not lint */

d57 9
@


1.19
log
@In various places, VAR_CMD is used to actually mean `no real context',
since lookup will start with VAR_CMD in any case.
This fixes VarFind and Var_Parse to handle ctxt == NULL correctly, and
replace those confusing VAR_CMD with proper NULL pointers.

This patch also handles three small details:
- .CURDIR is necessarily set in VAR_GLOBAL,
- suffix handling for archives copies two hard-coded variables, for
which it can use a quick path,
- typos in TargFreeGN.

Reviewed millert@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.18 2000/06/17 14:38:14 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.18 2000/06/17 14:38:14 espie Exp $";
d1186 1
a1186 1
		/*FALLTHRU*/
d1192 1
a1192 1
		/*FALLTHRU*/
@


1.18
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.17 2000/06/10 01:41:05 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.17 2000/06/10 01:41:05 espie Exp $";
d238 1
a238 1
	    cp2 = Var_Parse(cp, VAR_CMD, TRUE, &len, &doFree);
d294 1
a294 1
    if (Var_Value(arg, VAR_CMD) != NULL)
d531 1
a531 1
		lhs = Var_Parse(condExpr, VAR_CMD, doEval,&varSpecLen,&doFree);
d635 1
a635 1
			    cp2 = Var_Parse(cp, VAR_CMD, doEval,&len, &freeIt);
d688 1
a688 1
			string = Var_Parse(rhs, VAR_CMD, doEval,&len,&freeIt);
d820 1
a820 1
			val = Var_Parse(&condExpr[arglen - 1], VAR_CMD,
@


1.17
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.16 2000/04/17 23:50:45 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.16 2000/04/17 23:50:45 espie Exp $";
d342 1
a342 1
    if (Lst_Find(create, CondStrMatch, arg) == NULL) {
d374 1
a374 1
    path = Dir_FindFile(arg, dirSearchPath);
@


1.16
log
@Annotate CondStack with filenames/line numbers.
Give a trace of dangling .if in case of errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.15 2000/03/26 16:21:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.15 2000/03/26 16:21:32 espie Exp $";
d107 1
a107 1
static int CondStrMatch __P((ClientData, ClientData));
a309 4
 *
 * Side Effects:
 *	None
 *
d314 2
a315 2
    ClientData    string;
    ClientData    pattern;
d317 1
a317 1
    return(!Str_Match((char *) string,(char *) pattern));
@


1.15
log
@Remove idiotic, braindead casts T* -> void*
They serve no purpose, except hiding potential bugs.

In particular, remove (ClientData) cast from macro, showing potentially
troublesome use of Hashes to store time_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.14 2000/01/08 09:45:15 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.14 2000/01/08 09:45:15 espie Exp $";
d140 5
a144 1
static Boolean	  condStack[MAXIF]; 	/* Stack of conditionals's values */
d1135 1
a1135 1
		value = !condStack[condTop];
d1208 1
a1208 1
    } else if ((skipIfLevel != 0) || condStack[condTop]) {
d1228 3
a1230 1
	condStack[condTop] = value;
d1252 2
d1257 4
@


1.14
log
@Finish changing all Var_Parse arguments to size_t. Thanks to millert@@
for reminding me.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.13 1999/12/19 00:04:25 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.13 1999/12/19 00:04:25 espie Exp $";
d342 1
a342 1
    if (Lst_Find(create, CondStrMatch, (ClientData)arg) == NULL) {
@


1.13
log
@Rearrange Lst_Find interface to conform better with other functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.12 1999/12/18 21:53:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.12 1999/12/18 21:53:32 espie Exp $";
d231 1
a231 1
	    int		len;
d523 1
a523 1
		int	varSpecLen;
d632 1
a632 1
			    int	len;
d685 1
a685 1
			int 	len;
d808 1
a808 1
		    int	    length;
@


1.12
log
@NIL, NILGNODE, etc, are only glorified NULL.
Get rid of them.

Get rid of list.h, nothing uses it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.11 1999/12/16 17:02:45 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.11 1999/12/16 17:02:45 espie Exp $";
d342 1
a342 1
    if (Lst_Find (create, (ClientData)arg, CondStrMatch) == NULL) {
@


1.11
log
@Allocate buffers as static data structures.
This cuts down quite a lot of malloc, since in actual use,
buffer usage is mostly static.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.10 1999/12/16 16:58:15 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.10 1999/12/16 16:58:15 espie Exp $";
d342 1
a342 1
    if (Lst_Find (create, (ClientData)arg, CondStrMatch) == NILLNODE) {
d409 1
a409 1
    if ((gn != NILGNODE) && !OP_NOP(gn->type)) {
@


1.10
log
@Fix those two bugs in cond.c.
- CondGetArg needs to differentiate between empty strings and problems.
Returning problems as a separate boolean is cleaner anyway.
- Fix error in conditional parser which would overstep the ending 0, so
that a second zero would be needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.9 1999/12/16 16:52:11 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.9 1999/12/16 16:52:11 espie Exp $";
d189 1
a189 1
    register Buffer buf;
d220 1
a220 1
    buf = Buf_Init(16);
d236 1
a236 1
	    Buf_AddString(buf, cp2);
d242 1
a242 1
	    Buf_AddChar(buf, *cp);
d247 2
a248 3
    *argPtr = Buf_Retrieve(buf);
    *argLen = Buf_Size(buf);
    Buf_Destroy(buf, FALSE);
d543 1
a543 1
		    Buffer buf;
d545 1
a545 1
		    buf = Buf_Init(0);
d547 1
a547 1
		    Buf_AddString(buf, lhs);
d554 1
a554 1
			Buf_AddChar(buf, *condExpr);
d556 1
a556 2
		    lhs = Buf_Retrieve(buf);
		    Buf_Destroy(buf, FALSE);
d608 1
a608 1
		    Buffer  buf;
d617 1
a617 1
		    buf = Buf_Init(0);
d630 1
a630 1
			    Buf_AddChar(buf, *cp);
d637 1
a637 1
				Buf_AddString(buf, cp2);
d643 1
a643 1
				Buf_AddChar(buf, *cp);
d646 1
a646 1
			    Buf_AddChar(buf, *cp);
d650 1
a650 2
		    string = Buf_Retrieve(buf);
		    Buf_Destroy(buf, FALSE);
@


1.9
log
@Remove unneeded extraneous zeros at the end of buffers.

Actually, one of these needs to be there, because of two bugs in cond.c
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.8 1999/12/16 16:41:41 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.8 1999/12/16 16:41:41 espie Exp $";
d105 1
a105 1
static size_t CondGetArg __P((char **, char **, char *, Boolean));
d173 1
a173 1
 *	The length of the argument and the address of the argument.
d176 2
a177 3
 *	The pointer is set to point to the closing parenthesis of the
 *	function call.
 *
d180 2
a181 2
static size_t
CondGetArg(linePtr, argPtr, func, parens)
d184 1
a188 1
    size_t    	  argLen;
d209 1
a209 1
	return (0);
a246 2
    /* XXX */
    Buf_AddChar(buf, '\0');
d248 1
a248 1
    argLen = Buf_Size(buf);
d257 1
a257 1
	return (0);
d266 1
a266 1
    return (argLen);
d672 2
d775 5
a779 5
		    arglen = CondGetArg (&condExpr, &arg, "defined", TRUE);
		    if (arglen == 0) {
			condExpr -= 7;
			goto use_default;
		    }
d788 5
a792 5
		    arglen = CondGetArg (&condExpr, &arg, "make", TRUE);
		    if (arglen == 0) {
			condExpr -= 4;
			goto use_default;
		    }
d801 4
a804 4
		    arglen = CondGetArg(&condExpr, &arg, "exists", TRUE);
		    if (arglen == 0) {
			condExpr -= 6;
			goto use_default;
d859 4
a862 4
		    arglen = CondGetArg(&condExpr, &arg, "target", TRUE);
		    if (arglen == 0) {
			condExpr -= 6;
			goto use_default;
d875 2
a876 1
		    arglen = CondGetArg(&condExpr, &arg, "", FALSE);
@


1.8
log
@Split Buf_GetAll into Buf_Retrieve/Buf_Size.
(idiotic to retrieve size every time when it's used half the time)
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.7 1999/12/09 18:18:24 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.7 1999/12/09 18:18:24 espie Exp $";
d248 1
a559 1
		    Buf_AddChar(buf, '\0');
a560 1
		    varSpecLen = Buf_Size(buf);
a653 2

		    Buf_AddChar(buf, '\0');
@


1.7
log
@Introduce `common usage' buf patterns and use them.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.6 1999/12/06 22:28:44 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.6 1999/12/06 22:28:44 espie Exp $";
d249 2
a250 1
    *argPtr = Buf_GetAll(buf, &argLen);
d560 2
a561 1
		    lhs = Buf_GetAll(buf, &varSpecLen);
d658 1
a658 1
		    string = Buf_GetAll(buf, NULL);
@


1.6
log
@Extra parameter no longer needed, ditch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.5 1999/12/06 22:24:31 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.5 1999/12/06 22:24:31 espie Exp $";
d237 1
a237 1
	    Buf_AddChars(buf, strlen(cp2), cp2);
a545 1
		    char *cp;
d549 1
a549 2
		    for (cp = lhs; *cp; cp++)
			Buf_AddChar(buf, *cp);
d641 1
a641 1
				Buf_AddChars(buf, strlen(cp2), cp2);
@


1.5
log
@Clean up buffers interface somewhat:

- buf.c deals exclusively with chars. Be explicit about it, and remove
extraneous dumb casts to char (can hide real type errors).
- buffer sizes are size_t. Note that bp->left can never become NULL.
- Buf_GetAll is happy with a NULL pointer for the size, remove unneeded
extra pointers.
- Propagate size_t to all places where buffer functions are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.4 1998/12/05 00:06:27 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.4 1998/12/05 00:06:27 espie Exp $";
a288 1
    char    *p1;
d292 1
a292 1
    if (Var_Value (arg, VAR_CMD, &p1) != (char *)NULL) {
d294 1
a294 1
    } else {
a295 2
    }
    efree(p1);
@


1.4
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: cond.c,v 1.2 1996/06/26 05:36:28 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.2 1996/06/26 05:36:28 deraadt Exp $";
d105 2
a106 2
static int CondGetArg __P((char **, char **, char *, Boolean));
static Boolean CondDoDefined __P((int, char *));
d108 3
a110 3
static Boolean CondDoMake __P((int, char *));
static Boolean CondDoExists __P((int, char *));
static Boolean CondDoTarget __P((int, char *));
d121 1
a121 1
    Boolean	(*defProc) __P((int, char *)); /* Default function to apply */
d133 1
a133 1
		    __P((int, char *));
d181 2
a182 2
static int
CondGetArg (linePtr, argPtr, func, parens)
d189 1
a189 1
    int	    	  argLen;
d237 1
a237 1
	    Buf_AddBytes(buf, strlen(cp2), (Byte *)cp2);
d243 1
a243 1
	    Buf_AddByte(buf, (Byte)*cp);
d248 2
a249 2
    Buf_AddByte(buf, (Byte)'\0');
    *argPtr = (char *)Buf_GetAll(buf, &argLen);
d284 2
a285 2
CondDoDefined (argLen, arg)
    int	    argLen;
d340 1
a340 1
    int	    argLen;
d371 1
a371 1
    int	    argLen;
d404 2
a405 2
CondDoTarget (argLen, arg)
    int	    argLen;
d554 1
a554 1
			Buf_AddByte(buf, (Byte)*cp);
d561 1
a561 1
			Buf_AddByte(buf, (Byte)*condExpr);
d563 2
a564 2
		    Buf_AddByte(buf, (Byte)'\0');
		    lhs = (char *)Buf_GetAll(buf, &varSpecLen);
d639 1
a639 1
			    Buf_AddByte(buf, (Byte)*cp);
d646 1
a646 1
				Buf_AddBytes(buf, strlen(cp2), (Byte *)cp2);
d652 1
a652 1
				Buf_AddByte(buf, (Byte)*cp);
d655 1
a655 1
			    Buf_AddByte(buf, (Byte)*cp);
d659 1
a659 1
		    Buf_AddByte(buf, (Byte)0);
d661 1
a661 1
		    string = (char *)Buf_GetAll(buf, (int *)0);
d769 1
a769 1
		Boolean (*evalProc) __P((int, char *));
d772 1
a772 1
		int	arglen;
@


1.3
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d298 1
a298 2
    if (p1)
	free(p1);
@


1.2
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: cond.c,v 1.6 1995/06/14 15:18:58 christos Exp $	*/
/*	$NetBSD: cond.c,v 1.6 1995/06/14 15:18:58 christos Exp $	*/
d44 1
a44 1
static char sccsid[] = "@@(#)cond.c	5.6 (Berkeley) 6/1/90";
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cond.c,v 1.6 1995/06/14 15:18:58 christos Exp $";
d104 1
d121 1
a121 1
    Boolean	(*defProc)(); /* Default function to apply */
d128 1
a128 1
    { (char *)0,  0,	  FALSE,  (Boolean (*)())0 }
d132 2
a133 1
static Boolean	  (*condDefProc)(); 	/* Default function to apply */
d222 1
a222 1
    
d265 1
a265 1
    
d439 1
a439 1
 *	
d629 4
a632 4
		    
		    for (cp = &rhs[qt]; 
			 ((qt && (*cp != '"')) || 
			  (!qt && strchr(" \t)", *cp) == NULL)) && 
d644 1
a644 1
			    
d698 1
a698 1
			
d726 1
a726 1
		    
d770 1
a770 1
		Boolean (*evalProc)();
d774 1
a774 1
		
d836 2
a837 2
			    /* 
			     * A variable is empty when it just contains 
d1119 1
a1119 1
    
d1179 1
a1179 1
	
d1181 1
a1181 1
	
d1185 1
a1185 1
	
d1188 1
a1188 1
	
@


1.1
log
@Initial revision
@
text
@d1 1
d46 1
a46 1
static char rcsid[] = "$NetBSD: cond.c,v 1.6 1995/06/14 15:18:58 christos Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
