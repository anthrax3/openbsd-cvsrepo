head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.2
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.6
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.8
	OPENBSD_5_0:1.12.0.6
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.10.0.8
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.10
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.6
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.6
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.14
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.12
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.10
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.10.14.09.27.21;	author natano;	state Exp;
branches;
next	1.17;
commitid	xK9iXmhQ2bSDSVMb;

1.17
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	6b2lLILbgCR1fvia;

1.16
date	2014.05.18.08.08.50;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2013.04.23.14.32.53;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2012.10.09.19.45.34;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2012.04.11.18.27.30;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.16.10.20.17;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.03.13.56.56;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.08.17.44.20;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.20.23.10.19;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.11.21.12.11;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.23.12.34.43;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.03.13.41.05;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.02.16.57.26;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.23.16.27.29;	author espie;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Implement the ${<D} and ${<F} variables, as documented in the manual.
They are equivalent to ${<:H} and ${<:T} repectively, however the former
variants are more portable, as they are understood by GNU, FreeBSD and
NetBSD make too.

absence of those variables reported by Dario Niedermann <dnied at tiscali.it>
ok millert espie
@
text
@/*	$OpenBSD: generate.c,v 1.17 2015/04/18 18:28:37 deraadt Exp $ */

/*
 * Copyright (c) 2001 Marc Espie.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <ohash.h>

#include "stats.h"
#include "cond_int.h"
#include "var_int.h"
#include "node_int.h"

#define M(x)	x, #x
char *table_var[] = {
	M(TARGET),
	M(OODATE),
	M(ALLSRC),
	M(IMPSRC),
	M(PREFIX),
	M(ARCHIVE),
	M(MEMBER),
	M(LONGTARGET),
	M(LONGOODATE),
	M(LONGALLSRC),
	M(LONGIMPSRC),
	M(LONGPREFIX),
	M(LONGARCHIVE),
	M(LONGMEMBER),
	M(FTARGET),
	M(DTARGET),
	M(FPREFIX),
	M(DPREFIX),
	M(FARCHIVE),
	M(DARCHIVE),
	M(FMEMBER),
	M(DMEMBER),
	M(FIMPSRC),
	M(DIMPSRC),
	NULL
};

char *table_cond[] = {
	M(COND_IF),
	M(COND_IFDEF),
	M(COND_IFNDEF),
	M(COND_IFMAKE),
	M(COND_IFNMAKE),
	M(COND_ELSE),
	M(COND_ELIF),
	M(COND_ELIFDEF),
	M(COND_ELIFNDEF),
	M(COND_ELIFMAKE),
	M(COND_ELIFNMAKE),
	M(COND_ENDIF),
	M(COND_FOR),
	M(COND_ENDFOR),
	M(COND_INCLUDE),
	M(COND_UNDEF),
	M(COND_POISON),
	NULL
};

char *table_nodes[] = {
	M(NODE_DEFAULT),
	M(NODE_EXEC),
	M(NODE_IGNORE),
	M(NODE_INCLUDES),
	M(NODE_INVISIBLE),
	M(NODE_JOIN),
	M(NODE_LIBS),
	M(NODE_MADE),
	M(NODE_MAIN),
	M(NODE_MAKE),
	M(NODE_MAKEFLAGS),
	M(NODE_MFLAGS),
	M(NODE_NOTMAIN),
	M(NODE_NOTPARALLEL),
	M(NODE_NO_PARALLEL),
	M(NODE_NULL),
	M(NODE_OPTIONAL),
	M(NODE_ORDER),
	M(NODE_PARALLEL),
	M(NODE_PATH),
	M(NODE_PHONY),
	M(NODE_PRECIOUS),
	M(NODE_RECURSIVE),
	M(NODE_SILENT),
	M(NODE_SINGLESHELL),
	M(NODE_SUFFIXES),
	M(NODE_USE),
	M(NODE_WAIT),
	M(NODE_BEGIN),
	M(NODE_END),
	M(NODE_INTERRUPT),
	M(NODE_CHEAP),
	M(NODE_EXPENSIVE),
	M(NODE_POSIX),
	M(NODE_SCCS_GET),
	NULL
};


char **table[] = {
	table_var,
	table_cond,
	table_nodes
};

int
main(int argc, char *argv[])
{
	uint32_t i;
	uint32_t v;
	uint32_t h;
	uint32_t slots;
	const char *errstr;
	const char *e;
	char **occupied;
	char **t;
	int tn;

	Init_Stats();
	if (argc != 3)
		exit(1);

	tn = strtonum(argv[1], 1, INT_MAX, &errstr);
	if (errstr)
		exit(1);
	t = table[tn-1];
	slots = strtonum(argv[2], 0, INT_MAX, &errstr);
	if (errstr)
		exit(1);
	if (slots) {
		occupied = calloc(slots, sizeof(char *));
		if (!occupied)
			exit(1);
	} else
		occupied = NULL;

	printf("/* File created by generate %d %d, do not edit */\n",
	    tn, slots);
	for (i = 0; t[i] != NULL; i++) {
		e = NULL;
		v = ohash_interval(t[i], &e);
		if (slots) {
			h = v % slots;
			if (occupied[h]) {
				fprintf(stderr,
				    "Collision: %s / %s (%d)\n", occupied[h],
				    t[i], h);
				exit(1);
			}
			occupied[h] = t[i];
		}
		i++;
		printf("#define K_%s %u\n", t[i], v);
	}
	if (slots)
		printf("#define MAGICSLOTS%d %u\n", tn, slots);
	exit(0);
}
@


1.17
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: generate.c,v 1.16 2014/05/18 08:08:50 espie Exp $ */
d64 2
@


1.16
log
@a bit more reallocarray (and kill ecalloc, which isn't used)
okay chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: generate.c,v 1.15 2013/04/23 14:32:53 espie Exp $ */
d32 1
d141 1
d151 2
a152 2
	tn = atoi(argv[1]);
	if (!tn)
d155 3
a157 1
	slots = atoi(argv[2]);
@


1.15
log
@remove TIMESTAMP abstraction layer, prodded by theo.
while there, clean up includes.
use strtoll for ar timestamps (pretty much unused in reality, more
standard conforming than anything)

use idea from Todd to adapt to time_t being 32 bits OR 64 bits
(pedantically correct: INT_MIN would work just fine up to 1910 or so...)

okay millert@@, gone thru a make build.
@
text
@d1 1
a1 1
/*	$OpenBSD: generate.c,v 1.14 2012/10/09 19:45:34 espie Exp $ */
d155 1
a155 1
		occupied = calloc(sizeof(char *), slots);
a157 2
		for (i = 0; i < slots; i++)
			occupied[i] = NULL;
@


1.14
log
@- SPECIAL_DEPRECATED -> SPECIAL_NOTHING
- nodes for .POSIX and .SCCS_GET (which don't do anything)
- zap remaining suffix crud.

new scaffolding:
- groupling list and HELDBACK state to avoid races in engine.
- parser recognizes lists of targets that shoul be grouped together
- OP_DOUBLE to mark nodes that have multiple lists of commands
@
text
@d1 1
a1 1
/*	$OpenBSD: generate.c,v 1.13 2012/04/11 18:27:30 espie Exp $ */
d29 1
a30 1
#include <stdint.h>
d32 1
a34 1
#include "ohash.h"
@


1.13
log
@make has had heuristics to avoid parallel make recursion.
Sometimes they mess up, so add .CHEAP/.EXPENSIVE to explicitly tell make
'hey this is not THAT bad' or 'worse than you think'.
agreed by guenther@@, millert@@ (and some tweaks)
@
text
@d1 1
a1 1
/*	$OpenBSD: generate.c,v 1.12 2010/07/19 19:46:44 espie Exp $ */
d121 2
@


1.12
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: generate.c,v 1.11 2010/07/19 19:30:37 espie Exp $ */
d119 2
@


1.11
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$ */
@


1.10
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: generate.c,v 1.9 2007/09/16 10:20:17 espie Exp $ */
@


1.9
log
@scaffolding to recognize special targets/sources using ohash functions.
@
text
@d2 1
a2 1
/*	$OpenBSD: generate.c,v 1.8 2007/09/03 13:56:56 espie Exp $ */
d160 1
a160 1
	printf("/* File created by generate %d %d, do not edit */\n", 
d168 1
a168 1
				fprintf(stderr, 
@


1.8
log
@use calloc() for the sake of regularity, prompted by deraadt@@

Note that I *still* fill every pointer with explicit NULL, for portability.
filling with 0 bytes is not necessarily the same as NULL pointers.
@
text
@d2 1
a2 1
/*	$OpenBSD: generate.c,v 1.7 2007/07/08 17:44:20 espie Exp $ */
d38 1
d88 35
d126 2
a127 1
	table_cond
@


1.7
log
@A set of big related changes. okay millert@@, tested further by kettenis@@
and matthieu@@

This all revolves around putting ALL global variables into one single big
hash, and using flags. This removes some impossible to understand stuff,
like old varfind, and allows for some nice stuff.
- each time we reference a global variable, we create it, possibly as a dummy
variable.
- each time we go to the environment, we remember it, thus we no longer go
back to it.

Lists of dependant changes:
- isolate changes to oldVars and checkEnvFirst.
- remove VAR_CMD and VAR_GLOBAL contexts. The only distinction is in parsevar.
Split Parse_DoVar into Parse_DoVar and Parse_CmdlineVar
- rework var modules around obtain_global_var, observe flags in various
functions like Var_Value and Var_Seti.
- Var_Seti/Var_Appendi are almost the same code, use that internally.
- add magic to handle the very special SHELL variable.
- introduce Var_Definedi for the cases where we don't want the actual
value, to simplify tests.
- add keyword .poison, parse it and set global flags accordingly.
- do poison_checks where needed.
- document poison.
- in for loops, set variable temporarily, so that Var_SubstVar will also
substitute it in varmodifiers expressions.
@
text
@d2 1
a2 1
/*	$OpenBSD: generate.c,v 1.6 2006/01/20 23:10:19 espie Exp $ */
d115 1
a115 1
		occupied = malloc(sizeof(char *) * slots);
@


1.6
log
@use stdint.h where appropriate. okay millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: generate.c,v 1.5 2002/06/11 21:12:11 espie Exp $ */
d83 1
@


1.5
log
@This is the first step in sanitizing the conditional parser.

Change the conditional recognition algorithm:
scan for a sequence of alphabetic characters, hash it, and compare it against
a small table (using ohash functions).
This makes Cond_Eval entry more logical, and allows for some shortcuts in
recognizing .include, .for, .undef.

This also means that conditionals must have an intervening blank between
the keyword and the actual test, e.g.,
.ifA
will no longer work.

(but no-one actually uses this, and it's highly obfuscated)

Okay miod@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: generate.c,v 1.4 2001/05/23 12:34:43 espie Exp $ */
d31 1
d95 4
a98 4
	u_int32_t i;
	u_int32_t v;
	u_int32_t h;
	u_int32_t slots;
@


1.4
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d72 1
d79 1
@


1.3
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d1 2
d4 26
a31 1
#include <stddef.h>
a32 1
#include "make.h"
d36 1
a100 1
#ifdef HAS_STATS
a101 1
#endif
@


1.2
log
@Use the ohash_* that's now in libc.
@
text
@a0 4
/* $OpenBSD: generate.c,v 1.1 2000/06/23 16:27:29 espie Exp $ */
/* Written by Marc Espie 1999.  
 * Public domain.
 */
d7 1
d9 1
a9 1
#include "error.h"
d12 1
a12 1
char *table[] = {
d26 10
a35 1
	M(LONGMEMBER)
d38 23
d71 2
d77 1
a77 1
	if (argc < 2)
d80 2
a81 2
	slots = atoi(argv[1]);
	if (!slots)
d83 14
a96 6
	occupied = emalloc(sizeof(char *) * slots);
	for (i = 0; i < slots; i++)
		occupied[i] = NULL;
	
	printf("/* Generated file, do not edit */\n");
	for (i = 0; i < sizeof(table)/sizeof(char *); i++) {
d98 10
a107 6
		v = ohash_interval(table[i], &e);
		h = v % slots;
		if (occupied[h]) {
			fprintf(stderr, "Collision: %s / %s (%d)\n", occupied[h],
				table[i], h);
			exit(1);
d109 2
a110 2
		occupied[h] = table[i++];
		printf("#define K_%s %u\n", table[i], v);
d112 2
a113 1
	printf("#define MAGICSLOTS %u\n", slots);
a115 1

@


1.1
log
@This is the speed-up patch, which doubles make speed (almost).

Use the open hashing functions for global contexts instead of List in
var.c.

All the preliminary work to trim down local contexts means that we don't
suffer from the heavy initialization work that a hash table entails.

There is some make kludgery to:
- build the hashing functions as a library,
- recreate hashconsts.h, even if make depend was not invoked.

One point of the hashing scheme written was to separate the computation
of the hash function, and the hash lookup itself. This is very convenient
for make, because of those pesky special variables. hashconsts.h is there
to pre-hash the correct values, which replaces a few expensive string
comparisons with quick hash value comparisons, followed by one expensive
string comparison. The modulus MAGICSLOTS chosen in the Makefile is
ad-hoc: it is small enough to write a small switch without collision,
and will need changing if the hash function changes...

The function quick_lookup is the most important:
it either returns an index, for a local variable, or it does compute a
hashing value, and returns -1.

Another somewhat controversial decision is the use of string intervals.
This avoids either copying a string, or twiddling with a byte for cases
such as ${VAR}.

Finally, the variable name is stored within the variable itself. Since
a given variable name never changes, this makes sense. All that was needed
was a hash library with support for this.  Note that the hashing table
holds only a variable pointer AND the corresponding hashing value, WITHOUT
a modulo hashtablesize. Two reasons:
- hash resizes can be done faster, without having to recompute hashing values.
- locality of access. The hash table fits into memory without problem. Once
a candidate slot is found, we check the complete hashing value. Probability
of a collision is very small (32 bits...). So bringing up the whole
variable in memory at once is good: the name will almost always match, in
which case we want the variable value as well, so it makes sense to put
them together.

The ohash functions implement open hashing, as described in Knuth, but with
a variable table size.  Choosing powers of 2 sizes does not yield more
collisions, but it makes the hashing scheme much simpler. The thresholds at
which to expand/shrink the tables seem to work well in practice. The
default sizes were chosen such that the tables hardly ever shrink or expand
anyways (though I've tried with smaller/larger sizes to verify that the
shrinking/expanding worked correctly): larger Makefiles hold roughly
500/600 variables, which fits without trouble into a 1024-sized variable.

Disregard #ifdef STATS_HASH, this is some internal scaffolding I'm using
to measure make performance.

The only known issue with open-hashing is that deletions cannot create
empty slots, but do leave slots marked as `occupied once' so that lookup
works.  We use a well-known optimization which records those pseudo-empty
slots while looking up values. If the value is not found, the pseudo-empty
slot is returned to be filled. If the value is found, it is swapped with
the pseudo-empty slot. This is an improvement in both cases, since this
shortens the length of lookup chains, eventually pushing the pseudo-empty
slots to the end.

Reviewed by millert@@ and miod@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d59 1
a59 1
		v = hash_interval(table[i], &e);
@

