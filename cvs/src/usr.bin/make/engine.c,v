head	1.53;
access;
symbols
	OPENBSD_6_1:1.52.0.4
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.50.0.8
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.4
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.50.0.6
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.48.0.4
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.45.0.2
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.40.0.2
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.29.0.2
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.8
	OPENBSD_5_0:1.28.0.6
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.4
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19;
locks; strict;
comment	@ * @;


1.53
date	2017.07.09.15.28.00;	author espie;	state Exp;
branches;
next	1.52;
commitid	3SdYCHzXI01gaKeB;

1.52
date	2017.01.29.10.04.13;	author espie;	state Exp;
branches;
next	1.51;
commitid	gEdDXJ9FSY8aN6yu;

1.51
date	2016.10.21.16.12.38;	author espie;	state Exp;
branches;
next	1.50;
commitid	aLVdeKrJ0t5upS3l;

1.50
date	2015.01.23.13.18.40;	author espie;	state Exp;
branches;
next	1.49;
commitid	iXa5WmoY9RgeqDsn;

1.49
date	2014.10.31.13.29.42;	author gsoares;	state Exp;
branches;
next	1.48;
commitid	nBvAUxZbceUE3IUh;

1.48
date	2014.05.30.21.19.57;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2013.11.22.15.47.35;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2013.08.26.14.15.07;	author naddy;	state Exp;
branches;
next	1.45;

1.45
date	2013.05.30.08.58.38;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2013.05.25.11.54.14;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2013.05.22.12.14.08;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2013.05.14.18.47.40;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2013.04.23.14.32.53;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2012.12.07.15.08.03;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2012.11.21.23.21.54;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2012.10.18.17.54.43;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2012.10.09.19.50.44;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2012.10.06.09.32.40;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2012.10.04.13.20.46;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2012.10.02.10.29.30;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2012.09.14.14.18.50;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2012.09.14.08.46.39;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2012.08.25.08.12.56;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2012.03.22.13.47.12;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.25.13.59.53;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.16.09.49.22;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.16.09.47.06;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2009.05.12.09.46.39;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.10.11.07.37;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.26.09.25.49;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.10.10.48.43;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.10.09.22.18;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2008.11.04.07.22.35;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2008.01.29.22.23.10;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2008.01.02.15.37.22;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.31.15.49.23;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.17.16.39.45;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.17.16.32.04;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.10.12.51.40;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.06.21.12.23;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.03.14.05.39;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.03.11.42.41;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.02.17.27.24;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.17.12.42.09;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.17.12.19.11;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.17.12.10.35;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.17.12.07.22;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.17.08.36.57;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.16.14.36.57;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.16.12.09.36;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.16.10.39.07;	author espie;	state Exp;
branches;
next	;


desc
@@


1.53
log
@there's no need to fork/exec to execute comments
okay millert@@
@
text
@/*	$OpenBSD: engine.c,v 1.52 2017/01/29 10:04:13 espie Exp $ */
/*
 * Copyright (c) 2012 Marc Espie.
 *
 * Extensive code modifications for the OpenBSD project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "config.h"
#include "defines.h"
#include "dir.h"
#include "engine.h"
#include "arch.h"
#include "gnode.h"
#include "targ.h"
#include "var.h"
#include "extern.h"
#include "lst.h"
#include "timestamp.h"
#include "make.h"
#include "pathnames.h"
#include "error.h"
#include "str.h"
#include "memory.h"
#include "buf.h"
#include "job.h"
#include "lowparse.h"

static void MakeTimeStamp(void *, void *);
static int rewrite_time(const char *);
static void setup_meta(void);
static void setup_engine(void);
static char **recheck_command_for_shell(char **);
static void list_parents(GNode *, FILE *);

/* XXX due to a bug in make's logic, targets looking like *.a or -l*
 * have been silently dropped when make couldn't figure them out.
 * Now, we warn about them until all Makefile bugs have been fixed.
 */
static bool
drop_silently(const char *s)
{
	size_t len;

	if (s[0] == '-' && s[1] == 'l')
		return true;

	len = strlen(s);
	if (len >=2 && s[len-2] == '.' && s[len-1] == 'a')
		return true;
	return false;
}

bool
node_find_valid_commands(GNode *gn)
{
	/* Alter our type to tell if errors should be ignored or things
	 * should not be printed so setup_and_run_command knows what to do.
	 */
	if (Targ_Ignore(gn))
		gn->type |= OP_IGNORE;
	if (Targ_Silent(gn))
		gn->type |= OP_SILENT;

	if (DEBUG(DOUBLE) && (gn->type & OP_DOUBLE))
		fprintf(stderr, "Warning: target %s had >1 lists of "
		    "shell commands (ignoring later ones)\n", gn->name);
	if (OP_NOP(gn->type) && Lst_IsEmpty(&gn->commands)) {
		if (drop_silently(gn->name)) {
			printf("Warning: target %s", gn->name);
			list_parents(gn, stdout);
			printf(" does not have any command (BUG)\n");
			return true;
		}
		/*
		 * No commands. Look for .DEFAULT rule from which we might infer
		 * commands
		 */
		if ((gn->type & OP_NODEFAULT) == 0 &&
		    (DEFAULT->type & OP_DUMMY) == 0 &&
		    !Lst_IsEmpty(&DEFAULT->commands)) {
			/*
			 * Make only looks for a .DEFAULT if the node was never
			 * the target of an operator, so that's what we do too.
			 * If a .DEFAULT was given, we substitute its commands
			 * for gn's commands and set the IMPSRC variable to be
			 * the target's name The DEFAULT node acts like a
			 * transformation rule, in that gn also inherits any
			 * attributes or sources attached to .DEFAULT itself.
			 */
			Make_HandleUse(DEFAULT, gn);
			Var(IMPSRC_INDEX, gn) = Var(TARGET_INDEX, gn);
		} else if (is_out_of_date(Dir_MTime(gn))) {
			/*
			 * The node wasn't the target of an operator we have no
			 * .DEFAULT rule to go on and the target doesn't
			 * already exist. There's nothing more we can do for
			 * this branch.
			 */
			 return false;
	    	}
	}
	return true;
}

static void
list_parents(GNode *gn, FILE *out)
{
	LstNode ln;
	bool first = true;

	for (ln = Lst_First(&gn->parents); ln != NULL; ln = Lst_Adv(ln)) {
		GNode *p = Lst_Datum(ln);
		if (!p->must_make)
			continue;
		if (first) {
			fprintf(out, " (prerequisite of:");
			first = false;
		}
		fprintf(out, " %s", p->name);
	}
	if (!first)
		fprintf(out, ")");
}

void
node_failure(GNode *gn)
{
	/*
	 If the -k flag wasn't given, we stop in
	 * our tracks, otherwise we just don't update this
	 * node's parents so they never get examined.
	 */
	const char *diag;
	FILE *out;

	if (gn->type & OP_OPTIONAL) {
		out = stdout;
		diag = "(ignored)";
	} else if (keepgoing) {
		out = stdout;
		diag = "(continuing)";
	} else {
		out = stderr;
		diag = "";
	}
	fprintf(out, "make: don't know how to make %s", gn->name);
	list_parents(gn, out);
	fprintf(out, "%s\n", diag);
	if (out == stdout)
		fflush(stdout);
	else {
		print_errors();
		Punt(NULL);
	}
}

/* touch files the hard way, by writing stuff to them */
static int
rewrite_time(const char *name)
{
	int fd;
	char c;

	fd = open(name, O_RDWR | O_CREAT, 0666);
	if (fd < 0)
		return -1;
	/*
	 * Read and write a byte to the file to change
	 * the modification time.
	 */
	if (read(fd, &c, 1) == 1) {
		(void)lseek(fd, 0, SEEK_SET);
		(void)write(fd, &c, 1);
	}

	(void)close(fd);
	return 0;
}

void
Job_Touch(GNode *gn)
{
	handle_all_signals();
	if (gn->type & (OP_JOIN|OP_USE|OP_EXEC|OP_OPTIONAL|OP_PHONY)) {
		/*
		 * .JOIN, .USE, and .OPTIONAL targets are "virtual" targets
		 * and, as such, shouldn't really be created.
		 * Likewise, .PHONY targets are not really files
		 */
		return;
	}

	if (!(gn->type & OP_SILENT)) {
		(void)fprintf(stdout, "touch %s\n", gn->name);
		(void)fflush(stdout);
	}

	if (noExecute) {
		return;
	}

	if (gn->type & OP_ARCHV) {
		Arch_Touch(gn);
	} else {
		const char *file = gn->path != NULL ? gn->path : gn->name;

		if (set_times(file) == -1){
			if (rewrite_time(file) == -1) {
				(void)fprintf(stderr,
				    "*** couldn't touch %s: %s", file,
				    strerror(errno));
		    	}
		}
	}
}

void
Make_TimeStamp(GNode *parent, GNode *child)
{
	if (is_strictly_before(parent->youngest->mtime, child->mtime)) {
 		parent->youngest = child;
	}
}

void
Make_HandleUse(GNode	*cgn,	/* The .USE node */
    GNode	*pgn)	/* The target of the .USE node */
{
	GNode	*gn;	/* A child of the .USE node */
	LstNode	ln;	/* An element in the children list */


	assert(cgn->type & (OP_USE|OP_TRANSFORM));

	if (pgn == NULL)
		Fatal("Trying to apply .USE to '%s' without a parent",
		    cgn->name);

	if ((cgn->type & OP_USE) || Lst_IsEmpty(&pgn->commands)) {
		/* .USE or transformation and target has no commands
		 * -- append the child's commands to the parent.  */
		Lst_Concat(&pgn->commands, &cgn->commands);
	}

	for (ln = Lst_First(&cgn->children); ln != NULL;
	    ln = Lst_Adv(ln)) {
		gn = Lst_Datum(ln);

		if (Lst_AddNew(&pgn->children, gn)) {
			Lst_AtEnd(&gn->parents, pgn);
			pgn->unmade++;
		}
	}

	if (DEBUG(DOUBLE) && (cgn->type & OP_DOUBLE))
		fprintf(stderr, 
		    "Warning: .USE %s expanded in %s had >1 lists of "
		    "shell commands (ignoring later ones)\n", 
		    cgn->name, pgn->name);
	pgn->type |= cgn->type & ~(OP_OPMASK|OP_USE|OP_TRANSFORM|OP_DOUBLE);

	/*
	 * This child node is now "made", so we decrement the count of
	 * unmade children in the parent... We also remove the child
	 * from the parent's list to accurately reflect the number of
	 * decent children the parent has. This is used by Make_Run to
	 * decide whether to queue the parent or examine its children...
	 */
	if (cgn->type & OP_USE)
		pgn->unmade--;
}

void
Make_DoAllVar(GNode *gn)
{
	GNode *child;
	LstNode ln;
	BUFFER allsrc, oodate;
	char *target;
	bool do_oodate;
	int oodate_count, allsrc_count = 0;

	oodate_count = 0;
	allsrc_count = 0;

	Var(OODATE_INDEX, gn) = "";
	Var(ALLSRC_INDEX, gn) = "";

	for (ln = Lst_First(&gn->children); ln != NULL; ln = Lst_Adv(ln)) {
		child = Lst_Datum(ln);
		if ((child->type & (OP_EXEC|OP_USE|OP_INVISIBLE)) != 0)
			continue;
		if (OP_NOP(child->type) ||
		    (target = Var(TARGET_INDEX, child)) == NULL) {
			/*
			 * this node is only source; use the specific pathname
			 * for it
			 */
			target = child->path != NULL ? child->path :
			    child->name;
		}

		/*
		 * It goes in the OODATE variable if the parent is younger than
		 * the child or if the child has been modified more recently
		 * than the start of the make.  This is to keep make from
		 * getting confused if something else updates the parent after
		 * the make starts (shouldn't happen, I know, but sometimes it
		 * does). In such a case, if we've updated the kid, the parent
		 * is likely to have a modification time later than that of the
		 * kid and anything that relies on the OODATE variable will be
		 * hosed.
		 */
		do_oodate = false;
		if (gn->type & OP_JOIN) {
			if (child->built_status == MADE)
				do_oodate = true;
		} else if (is_strictly_before(gn->mtime, child->mtime) ||
		   (!is_strictly_before(child->mtime, starttime) &&
		   child->built_status == MADE))
		   	do_oodate = true;
		if (do_oodate) {
			oodate_count++;
			if (oodate_count == 1)
				Var(OODATE_INDEX, gn) = target;
			else {
				if (oodate_count == 2) {
					Buf_Init(&oodate, 0);
					Buf_AddString(&oodate,
					    Var(OODATE_INDEX, gn));
				}
				Buf_AddSpace(&oodate);
				Buf_AddString(&oodate, target);
			}
		}
		allsrc_count++;
		if (allsrc_count == 1)
			Var(ALLSRC_INDEX, gn) = target;
		else {
			if (allsrc_count == 2) {
				Buf_Init(&allsrc, 0);
				Buf_AddString(&allsrc,
				    Var(ALLSRC_INDEX, gn));
			}
			Buf_AddSpace(&allsrc);
			Buf_AddString(&allsrc, target);
		}
	}

	if (allsrc_count > 1)
		Var(ALLSRC_INDEX, gn) = Buf_Retrieve(&allsrc);
	if (oodate_count > 1)
		Var(OODATE_INDEX, gn) = Buf_Retrieve(&oodate);

	if (gn->impliedsrc)
		Var(IMPSRC_INDEX, gn) = Var(TARGET_INDEX, gn->impliedsrc);

	if (gn->type & OP_JOIN)
		Var(TARGET_INDEX, gn) = Var(ALLSRC_INDEX, gn);
}

/* Wrapper to call Make_TimeStamp from a forEach loop.	*/
static void
MakeTimeStamp(void *parent, void *child)
{
    Make_TimeStamp(parent, child);
}

bool
Make_OODate(GNode *gn)
{
	bool	    oodate;

	/*
	 * Certain types of targets needn't even be sought as their datedness
	 * doesn't depend on their modification time...
	 */
	if ((gn->type & (OP_JOIN|OP_USE|OP_EXEC|OP_PHONY)) == 0) {
		(void)Dir_MTime(gn);
		if (DEBUG(MAKE)) {
			if (!is_out_of_date(gn->mtime))
				printf("modified %s...",
				    time_to_string(&gn->mtime));
			else
				printf("non-existent...");
		}
	}

	/*
	 * A target is remade in one of the following circumstances:
	 * - its modification time is smaller than that of its youngest child
	 *   and it would actually be run (has commands or type OP_NOP)
	 * - it's the object of a force operator
	 * - it has no children, was on the lhs of an operator and doesn't
	 *   exist already.
	 *
	 */
	if (gn->type & OP_USE) {
		/*
		 * If the node is a USE node it is *never* out of date
		 * no matter *what*.
		 */
		if (DEBUG(MAKE))
			printf(".USE node...");
		oodate = false;
	} else if (gn->type & OP_JOIN) {
		/*
		 * A target with the .JOIN attribute is only considered
		 * out-of-date if any of its children was out-of-date.
		 */
		if (DEBUG(MAKE))
			printf(".JOIN node...");
		oodate = gn->childMade;
	} else if (gn->type & (OP_FORCE|OP_EXEC|OP_PHONY)) {
		/*
		 * A node which is the object of the force (!) operator or which
		 * has the .EXEC attribute is always considered out-of-date.
		 */
		if (DEBUG(MAKE)) {
			if (gn->type & OP_FORCE)
				printf("! operator...");
			else if (gn->type & OP_PHONY)
				printf(".PHONY node...");
			else
				printf(".EXEC node...");
		}
		oodate = true;
	} else if (is_strictly_before(gn->mtime, gn->youngest->mtime) ||
	   (gn == gn->youngest &&
	    (is_out_of_date(gn->mtime) || (gn->type & OP_DOUBLEDEP)))) {
		/*
		 * A node whose modification time is less than that of its
		 * youngest child or that has no children (gn->youngest == gn)
		 * and either doesn't exist (mtime == OUT_OF_DATE)
		 * or was the object of a :: operator is out-of-date.
		 */
		if (DEBUG(MAKE)) {
			if (is_strictly_before(gn->mtime, gn->youngest->mtime))
				printf("modified before source(%s)...",
				    gn->youngest->name);
			else if (is_out_of_date(gn->mtime))
				printf("non-existent and no sources...");
			else
				printf(":: operator and no sources...");
		}
		oodate = true;
	} else {
		oodate = false;
	}

	/*
	 * If the target isn't out-of-date, the parents need to know its
	 * modification time. Note that targets that appear to be out-of-date
	 * but aren't, because they have no commands and aren't of type OP_NOP,
	 * have their mtime stay below their children's mtime to keep parents
	 * from thinking they're out-of-date.
	 */
	if (!oodate)
		Lst_ForEach(&gn->parents, MakeTimeStamp, gn);

	return oodate;
}

/* The following array is used to make a fast determination of which
 * characters are interpreted specially by the shell.  If a command
 * contains any of these characters, it is executed by the shell, not
 * directly by us.  */
static char	    meta[256];

void
setup_meta(void)
{
	char *p;

	for (p = "#=|^(){};&<>*?[]:$`\\\n~"; *p != '\0'; p++)
		meta[(unsigned char) *p] = 1;
	/* The null character serves as a sentinel in the string.  */
	meta[0] = 1;
}

static char **
recheck_command_for_shell(char **av)
{
	char *runsh[] = {
		"!", "alias", "cd", "eval", "exit", "read", "set", "ulimit",
		"unalias", "unset", "wait", "umask", NULL
	};

	char **p;

	/* optimization: if exec cmd, we avoid the intermediate shell */
	if (strcmp(av[0], "exec") == 0)
		av++;

	for (p = runsh; *p; p++)
		if (strcmp(av[0], *p) == 0)
			return NULL;

	return av;
}

static void
run_command(const char *cmd, bool errCheck)
{
	const char *p;
	char *shargv[4];
	char **todo;

	shargv[0] = _PATH_BSHELL;

	shargv[1] = errCheck ? "-ec" : "-c";
	shargv[2] = (char *)cmd;
	shargv[3] = NULL;

	todo = shargv;


	/* Search for meta characters in the command. If there are no meta
	 * characters, there's no need to execute a shell to execute the
	 * command.  */
	for (p = cmd; !meta[(unsigned char)*p]; p++)
		continue;
	if (*p == '\0') {
		char *bp;
		char **av;
		int argc;
		/* No meta-characters, so probably no need to exec a shell.
		 * Break the command into words to form an argument vector
		 * we can execute.  */
		av = brk_string(cmd, &argc, &bp);
		av = recheck_command_for_shell(av);
		if (av != NULL)
			todo = av;
	}
	execvp(todo[0], todo);

	if (errno == ENOENT)
		fprintf(stderr, "%s: not found\n", todo[0]);
	else
		perror(todo[0]);
	_exit(1);
}

static Job myjob;

void
job_attach_node(Job *job, GNode *node)
{
	job->node = node;
	job->node->built_status = BUILDING;
	job->next_cmd = Lst_First(&node->commands);
	job->exit_type = JOB_EXIT_OKAY;
	job->location = NULL;
	job->flags = 0;
}

void
job_handle_status(Job *job, int status)
{
	bool silent;
	int dying;

	/* if there's one job running and we don't keep going, no need 
	 * to report right now.
	 */
	if ((job->flags & JOB_ERRCHECK) && !keepgoing && runningJobs == NULL) 
		silent = !DEBUG(JOB);
	else
		silent = false;

	debug_job_printf("Process %ld (%s) exited with status %d.\n",
	    (long)job->pid, job->node->name, status);

	/* classify status */
	if (WIFEXITED(status)) {
		job->code = WEXITSTATUS(status);/* exited */
		if (job->code != 0) {
			/* if we're already dying from that signal, be silent */
			if (!silent && job->code > 128 
			    && job->code <= 128 + _NSIG) {
				dying = check_dying_signal();
				silent = dying && job->code == dying + 128;
			}
			if (!silent)
				printf("*** Error %d", job->code);
			job->exit_type = JOB_EXIT_BAD;
		} else 
			job->exit_type = JOB_EXIT_OKAY;
	} else {
		job->exit_type = JOB_SIGNALED;
		job->code = WTERMSIG(status);	/* signaled */
		/* if we're already dying from that signal, be silent */
		if (!silent) {
			dying = check_dying_signal();
			silent = dying && job->code == dying;
		}
		if (!silent)
			printf("*** Signal %d", job->code);
	}

	/* if there is a problem, what's going on ? */
	if (job->exit_type != JOB_EXIT_OKAY) {
		if (!silent)
			printf(" in target '%s'", job->node->name);
		if (job->flags & JOB_ERRCHECK) {
			job->node->built_status = ERROR;
			/* compute expensive status if we really want it */
			if ((job->flags & JOB_SILENT) && job == &myjob)
				determine_expensive_job(job);
			if (!keepgoing) {
				if (!silent)
					printf("\n");
				job->next = errorJobs;
				errorJobs = job;
				/* XXX don't free the command */
				return;
			}
			printf(", line %lu of %s", job->location->lineno, 
			    job->location->fname);
			if ((job->flags & (JOB_SILENT | JOB_IS_EXPENSIVE)) 
			    == JOB_SILENT)
				printf(": %s", job->cmd);
			/* Abort the current target,
			 * but let others continue.  */
			printf(" (continuing)\n");
		} else {
			/* Continue executing commands for
			 * this target.  If we return 0,
			 * this will happen...  */
			printf(" (ignored)\n");
			job->exit_type = JOB_EXIT_OKAY;
		}
	}
	free(job->cmd);
}

int
run_gnode(GNode *gn)
{
	if (!gn || (gn->type & OP_DUMMY))
		return NOSUCHNODE;

	gn->built_status = MADE;

	job_attach_node(&myjob, gn);
	while (myjob.exit_type == JOB_EXIT_OKAY) {
		bool finished = job_run_next(&myjob);
		if (finished)
			break;
		handle_one_job(&myjob);
	}

	return gn->built_status;
}


static void
setup_engine(void)
{
	static int already_setup = 0;

	if (!already_setup) {
		setup_meta();
		already_setup = 1;
	}
}

static bool
do_run_command(Job *job)
{
	bool silent;	/* Don't print command */
	bool doExecute;	/* Execute the command */
	bool errCheck;	/* Check errors */
	pid_t cpid; 	/* Child pid */

	const char *cmd = job->cmd;
	silent = job->node->type & OP_SILENT;
	errCheck = !(job->node->type & OP_IGNORE);
	if (job->node->type & OP_MAKE)
		doExecute = true;
	else
		doExecute = !noExecute;

	/* How can we execute a null command ? we warn the user that the
	 * command expanded to nothing (is this the right thing to do?).  */
	if (*cmd == '\0') {
		Error("%s expands to empty string", cmd);
		return false;
	}

	for (;; cmd++) {
		if (*cmd == '@@')
			silent = DEBUG(LOUD) ? false : true;
		else if (*cmd == '-')
			errCheck = false;
		else if (*cmd == '+')
			doExecute = true;
		else
			break;
	}
	while (ISSPACE(*cmd))
		cmd++;
	/* Print the command before fork if make -n or !silent*/
	if ( noExecute || !silent)
		printf("%s\n", cmd);
	
	if (silent)
		job->flags |= JOB_SILENT;
	else
		job->flags &= ~JOB_SILENT;

	/* If we're not supposed to execute any commands, this is as far as
	 * we go...  */
	if (!doExecute)
		return false;
	/* always flush for other stuff */
	fflush(stdout);

	/* Optimization: bypass comments entirely */
	if (*cmd == '#')
		return false;

	/* Fork and execute the single command. If the fork fails, we abort.  */
	switch (cpid = fork()) {
	case -1:
		Punt("Could not fork");
		/*NOTREACHED*/
	case 0:
		/* put a random delay unless we're the only job running
		 * and there's nothing left to do.
		 */
		if (random_delay)
			if (!(runningJobs == NULL && no_jobs_left()))
				usleep(arc4random_uniform(random_delay));
		run_command(cmd, errCheck);
		/*NOTREACHED*/
	default:
		job->pid = cpid;
		job->next = runningJobs;
		runningJobs = job;
		if (errCheck)
			job->flags |= JOB_ERRCHECK;
		else
			job->flags &= ~JOB_ERRCHECK;
		debug_job_printf("Running %ld (%s) %s\n", (long)job->pid, 
		    job->node->name, (noExecute || !silent) ? "" : cmd);
		return true;
	}
}

bool
job_run_next(Job *job)
{
	bool started;
	GNode *gn = job->node;

	setup_engine();
	while (job->next_cmd != NULL) {
		struct command *command = Lst_Datum(job->next_cmd);

		handle_all_signals();
		job->location = &command->location;
		Parse_SetLocation(job->location);
		job->cmd = Var_Subst(command->string, &gn->context, false);
		job->next_cmd = Lst_Adv(job->next_cmd);
		if (fatal_errors)
			Punt(NULL);
		started = do_run_command(job);
		if (started)
			return false;
		else
			free(job->cmd);
	}
	job->exit_type = JOB_EXIT_OKAY;
	return true;
}

@


1.52
log
@obvious protection against null pointer, because it's quite possible for cgn
to not have a parent...
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.51 2016/10/21 16:12:38 espie Exp $ */
d786 4
@


1.51
log
@small obvious cleanups:
- remove a lot of unnecessary casts
- zap extra param that's no longer needed
- add proper prototype and make function static

okay natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.50 2015/01/23 13:18:40 espie Exp $ */
d302 4
@


1.50
log
@remove a bunch of dangerous casts (useless casts from void * to something
else, in some cases by adding extra temporary variables.
IMO, it's much better practice to do

void *a;
int *p = a;
*p = 42;

rather than
void *a;
*(int *)a = 42;

okay miod@@... to be revisited for some possible const additions later.
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.49 2014/10/31 13:29:42 gsoares Exp $ */
d311 1
a311 1
		gn = (GNode *)Lst_Datum(ln);
d354 1
a354 1
		child = (GNode *)Lst_Datum(ln);
@


1.49
log
@redirect error output to stderr instead of stdout

stderr is always unbuffered by default, so zap fflush(3) its no longer makes any sense here
reminded by espie@@

OK espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.48 2014/05/30 21:19:57 espie Exp $ */
d430 1
a430 1
    Make_TimeStamp((GNode *)parent, (GNode *)child);
@


1.48
log
@modern bourne shells  handle ~. Unlikely in makefiles, but still, better
fork a shell then (as seen in a commit message in netbsd's make, apparently
taken from debian. didn't look at the actual code, but it was a "duh" moment)

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.47 2013/11/22 15:47:35 espie Exp $ */
d277 1
a277 1
				(void)fprintf(stdout,
a279 1
				(void)fflush(stdout);
@


1.47
log
@wrappers for is*/to* that make damn sure their arguments are
cast to unsigned chars.

okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.46 2013/08/26 14:15:07 naddy Exp $ */
d540 1
a540 1
	for (p = "#=|^(){};&<>*?[]:$`\\\n"; *p != '\0'; p++)
@


1.46
log
@replace rand(3)/random(3) calls with secure arc4random*()
npppd ok yasuoka@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.45 2013/05/30 08:58:38 espie Exp $ */
d766 1
a766 1
	while (isspace(*cmd))
@


1.45
log
@remove cmtime again, but with a proper test for nodes without children.

problem seen by aja,
make pointed by matthieu,
sleuthing by me,
okay by millert

(and you say OpenBSD developers don't work together)
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.44 2013/05/25 11:54:14 espie Exp $ */
d795 1
a795 1
				usleep(random() % random_delay);
@


1.44
log
@obviously missed something, so revert.
(noticed by sthen@@/matthieu@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.43 2013/05/22 12:14:08 espie Exp $ */
d289 1
a289 1
	if (is_strictly_before(parent->cmtime, child->mtime)) {
a290 1
		parent->cmtime = child->mtime;
d493 2
a494 2
	} else if (is_strictly_before(gn->mtime, gn->cmtime) ||
	   (is_out_of_date(gn->cmtime) &&
d498 2
a499 2
		 * youngest child or that has no children (cmtime ==
		 * OUT_OF_DATE) and either doesn't exist (mtime == OUT_OF_DATE)
d503 1
a503 1
			if (is_strictly_before(gn->mtime, gn->cmtime))
@


1.43
log
@as checked through thorough tests, youngest->mtime == ctime, so ditch
the extra field.

remove some extra abstraction layer: use clock_gettime directly
instead of ts_set_from_now (what is "now" anyways)

time_to_string takes param by pointer

rename "now" into starttime (more accurate term)

randomize queue uses arc4random_uniform (prompted by deraadt@@)

display debug timestamp with ns too (it's debug, so it doesn't really
matter whichever way it's done, as long as it's done)

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.42 2013/05/14 18:47:40 espie Exp $ */
d289 3
a291 2
	if (is_strictly_before(parent->youngest->mtime, child->mtime)) {
		parent->youngest = child;
d494 2
a495 2
	} else if (is_strictly_before(gn->mtime, gn->youngest->mtime) ||
	   (is_out_of_date(gn->youngest->mtime) &&
d504 1
a504 1
			if (is_strictly_before(gn->mtime, gn->youngest->mtime))
@


1.42
log
@keep track of the youngest child, helps a lot with out-of-date messages
in -dm mode.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.41 2013/04/23 14:32:53 espie Exp $ */
d289 1
a289 2
	if (is_strictly_before(parent->cmtime, child->mtime)) {
		parent->cmtime = child->mtime;
d384 1
a384 1
		   (!is_strictly_before(child->mtime, now) &&
d448 1
a448 1
				    time_to_string(gn->mtime));
d493 2
a494 2
	} else if (is_strictly_before(gn->mtime, gn->cmtime) ||
	   (is_out_of_date(gn->cmtime) &&
d503 1
a503 1
			if (is_strictly_before(gn->mtime, gn->cmtime))
@


1.41
log
@remove TIMESTAMP abstraction layer, prodded by theo.
while there, clean up includes.
use strtoll for ar timestamps (pretty much unused in reality, more
standard conforming than anything)

use idea from Todd to adapt to time_t being 32 bits OR 64 bits
(pedantically correct: INT_MIN would work just fine up to 1910 or so...)

okay millert@@, gone thru a make build.
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.40 2012/12/07 15:08:03 espie Exp $ */
d289 1
a289 1
	if (is_strictly_before(parent->cmtime, child->mtime))
d291 2
d505 2
a506 1
				printf("modified before source...");
@


1.40
log
@document engine interface, remove internal function from visible interface
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.39 2012/11/21 23:21:54 espie Exp $ */
d66 3
d70 2
d74 1
a74 3
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
a75 2
#include <string.h>
#include <signal.h>
@


1.39
log
@${.ALLSRC} and ${.OODATE} should always be defined, even for empty lists
of prerequisites. This prevents complaints from the var module and from
other developers.

That's a bug I introduced 5 years ago... found out by miod@@

okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.38 2012/10/18 17:54:43 espie Exp $ */
d564 1
a564 1
void
@


1.38
log
@numerous error message fixes:
- do ^C checking differently: don't record sent signals, but when jobs
die, recheck whether we received/have pending a INT/QUIT/TERM/HUP signal.
Then don't display our process group "normally", instead group together
everything dying by signal/shell dying by signal (just give the target
names).

- make certain we always handle signals before dying from "other conditions"
- have the parser messages look more like normal messages
- remove double error messages from some parser errors
- make sure unclosed variables ARE errors when some modifiers are present

- keep track of the base directory we're run from, so that submakes can
get shortened directories...
- make sure the whole error message including silent command fits into a
reasonable length.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.37 2012/10/09 19:50:44 espie Exp $ */
d348 3
@


1.37
log
@warn about targets with multiple command lists (debug option), as it's
definitely non portable behavior.

discussed with millert@@, who rightfully insisted on the optional debug part
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.36 2012/10/06 09:32:40 espie Exp $ */
a613 1
	job->sent_signal = 0;
d620 1
d636 7
a642 1
		if (status != 0) {
d651 5
@


1.36
log
@- extra juice for debugging signal passing.  Note when we can't pass the
signal because the process already bought it (pgroups will do that to you)
(lots of discussion with Todd on that one)
- tweak error handling some more to make it less verbose when just one job
is running...
- show signal name in case of signal interrupts.
- zap OP_LIB, move that stuff to the location where we warn when we meet
that bug.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.35 2012/10/04 13:20:46 espie Exp $ */
d131 3
d318 6
a323 1
	pgn->type |= cgn->type & ~(OP_OPMASK|OP_USE|OP_TRANSFORM);
@


1.35
log
@backout pgroup/job control from make, there is something deeply bogus
in stdin interaction.

Fixes update-patches as reported by aja...
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.34 2012/10/02 10:29:30 espie Exp $ */
d102 18
d132 1
a132 2
		/* XXX */
		if ((gn->type & OP_LIB)) {
d135 1
a135 1
			printf(" does not have any command\n");
d606 1
d612 10
d629 2
a630 1
			printf("*** Error code %d", job->code);
d637 2
a638 1
		printf("*** Signal %d", job->code);
d643 2
a644 1
		printf(" in target %s", job->node->name);
d651 2
a652 1
				printf("\n");
@


1.34
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.33 2012/09/21 07:55:20 espie Exp $ */
a732 2
		/* place ourselves in a different process group */
		setpgid(0, 0);
@


1.33
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.32 2012/09/14 14:18:50 espie Exp $ */
d100 1
d113 8
a120 2
	if (OP_NOP(gn->type) && Lst_IsEmpty(&gn->commands) &&
	    (gn->type & OP_LIB) == 0) {
d152 20
d180 2
a181 2
	static const char msg[] =
	    "make: don't know how to make";
d184 2
a185 1
		printf("%s %s(ignored)\n", msg, gn->name);
d187 2
a188 1
		(void)printf("%s %s(continuing)\n", msg, gn->name);
d190 9
a198 1
		fprintf(stderr, "%s %s\n", msg, gn->name);
a201 1
	fflush(stdout);
a250 2
	} else if (gn->type & OP_LIB) {
		Arch_TouchLib(gn);
a308 6

	/* if the parent node doesn't have any location, then inherit the
	 * use stuff, since that gives us better error messages.
	 */
	if (!pgn->origin.lineno)
		pgn->origin = cgn->origin;
a431 2
	 * Libraries are only considered out-of-date if the archive module says
	 * they are.
a440 7
	} else if ((gn->type & OP_LIB) && Arch_IsLib(gn)) {
		if (DEBUG(MAKE))
		    printf("library...");

		/* always out of date if no children and :: target */
		oodate = Arch_LibOODate(gn) ||
		    (is_out_of_date(gn->cmtime) && (gn->type & OP_DOUBLEDEP));
d584 1
d733 8
@


1.32
log
@more accurate fix: don't mark '!' as a meta character, recognize "!" as
a shell reserved word.

okay millert@@
@
text
@d1 27
a27 1
/*	$OpenBSD: engine.c,v 1.31 2012/09/14 08:46:39 espie Exp $ */
d63 1
d93 1
a96 1
static void setup_signal(int, psighandler);
d98 1
a100 5
static int setup_and_run_command(char *, GNode *, int);
static void run_command(const char *, bool);
static int run_prepared_gnode(GNode *);
static void handle_compat_interrupts(GNode *);

d102 1
a102 1
Job_CheckCommands(GNode *gn)
d146 1
a146 1
job_failure(GNode *gn, void (*abortProc)(char *, ...))
d157 1
a157 3
		(void)fprintf(stdout, "%s %s(ignored)\n", msg,
		    gn->name);
		(void)fflush(stdout);
d159 1
a159 3
		(void)fprintf(stdout, "%s %s(continuing)\n",
		    msg, gn->name);
		(void)fflush(stdout);
d161 3
a163 2
		(*abortProc)("%s %s. Stop in %s.", msg,
		    gn->name, Var_Value(".CURDIR"));
d165 1
d167 1
d194 1
a478 53
volatile sig_atomic_t got_signal;

volatile sig_atomic_t got_SIGINT, got_SIGHUP, got_SIGQUIT, got_SIGTERM;

static void
setup_signal(int sig, psighandler h)
{
	if (signal(sig, SIG_IGN) != SIG_IGN)
		(void)signal(sig, h);
}

void
setup_all_signals(psighandler interrupt, psighandler jc)
{
	/*
	 * Catch the four signals that POSIX specifies if they aren't ignored.
	 * handle_signal will take care of calling JobInterrupt if appropriate.
	 */
	setup_signal(SIGINT, interrupt);
	setup_signal(SIGHUP, interrupt);
	setup_signal(SIGQUIT, interrupt);
	setup_signal(SIGTERM, interrupt);
	setup_signal(SIGTSTP, jc);
	setup_signal(SIGTTOU, jc);
	setup_signal(SIGTTIN, jc);
	setup_signal(SIGWINCH, jc);
	setup_signal(SIGCONT, jc);
	got_signal = 0;
}

void
SigHandler(int sig)
{
	switch(sig) {
	case SIGINT:
		got_SIGINT++;
		got_signal = 1;
		break;
	case SIGHUP:
		got_SIGHUP++;
		got_signal = 1;
		break;
	case SIGQUIT:
		got_SIGQUIT++;
		got_signal = 1;
		break;
	case SIGTERM:
		got_SIGTERM++;
		got_signal = 1;
		break;
	}
}

d517 1
a517 1
static void
d559 99
a657 15
/*-
 *-----------------------------------------------------------------------
 * setup_and_run_command --
 *	Execute the next command for a target. If the command returns an
 *	error, the node's built_status field is set to ERROR and creation stops.
 *
 * Results:
 *	0 in case of error, 1 if ok.
 *
 * Side Effects:
 *	The node's 'built_status' field may be set to ERROR.
 *-----------------------------------------------------------------------
 */
static int
setup_and_run_command(char *cmd, GNode *gn, int dont_fork)
d662 9
a670 8
	int reason;	/* Reason for child's death */
	int status;	/* Description of child's death */
	pid_t cpid; 	/* Child actually found */
	pid_t stat;	/* Status of fork */

	silent = gn->type & OP_SILENT;
	errCheck = !(gn->type & OP_IGNORE);
	doExecute = !noExecute;
d676 1
a676 1
		return 1;
d691 2
a692 3
	/* Print the command before echoing if we're not supposed to be quiet
	 * for this one. We also print the command if -n given.  */
	if (!silent || noExecute) {
d694 6
a699 2
		fflush(stdout);
	}
d703 3
a705 10
		return 1;

	/* if we're running in parallel mode, we try not to fork the last
	 * command, since it's exit status will be just fine... unless
	 * errCheck is not set, in which case we must deal with the
	 * status ourselves.
	 */
	if (dont_fork && errCheck)
		run_command(cmd, errCheck);
		/*NOTREACHED*/
d710 1
a710 1
		Fatal("Could not fork");
d716 10
a725 44
		break;
	}

	/* The child is off and running. Now all we can do is wait...  */
	while (1) {

		while ((stat = waitpid(cpid, &reason, 0)) != cpid) {
			if (stat == -1 && errno != EINTR)
				break;
		}

		if (got_signal)
			break;

		if (stat != -1) {
			if (WIFEXITED(reason)) {
				status = WEXITSTATUS(reason);	/* exited */
				if (status != 0)
					printf("*** Error code %d", status);
			} else {
				status = WTERMSIG(reason);	/* signaled */
				printf("*** Signal %d", status);
			}


			if (!WIFEXITED(reason) || status != 0) {
				if (errCheck) {
					gn->built_status = ERROR;
					if (keepgoing)
						/* Abort the current target,
						 * but let others continue.  */
						printf(" (continuing)\n");
				} else {
					/* Continue executing commands for
					 * this target.  If we return 0,
					 * this will happen...  */
					printf(" (ignored)\n");
					status = 0;
				}
			}
			return !status;
		} else
			Fatal("error in wait: %s", strerror(errno));
			/*NOTREACHED*/
a726 1
	return 0;
d729 2
a730 2
static void
handle_compat_interrupts(GNode *gn)
d732 2
a733 31
	if (!Targ_Precious(gn)) {
		char *file = Var(TARGET_INDEX, gn);

		if (!noExecute && eunlink(file) != -1)
			Error("*** %s removed\n", file);
	}
	if (got_SIGINT) {
		signal(SIGINT, SIG_IGN);
		signal(SIGTERM, SIG_IGN);
		signal(SIGHUP, SIG_IGN);
		signal(SIGQUIT, SIG_IGN);
		got_signal = 0;
		got_SIGINT = 0;
		run_gnode(interrupt_node);
		exit(255);
	}
	exit(255);
}

void
expand_commands(GNode *gn)
{
	LstNode ln;
	char *cmd;

	Parse_SetLocation(&gn->origin);
	for (ln = Lst_First(&gn->commands); ln != NULL; ln = Lst_Adv(ln)) {
		cmd = Var_Subst(Lst_Datum(ln), &gn->context, false);
		Lst_AtEnd(&gn->expanded, cmd);
	}
}
d735 9
a743 5
int
run_gnode(GNode *gn)
{
	if (gn != NULL && (gn->type & OP_DUMMY) == 0) {
		expand_commands(gn);
d745 6
a750 4
			exit(1);
		return run_prepared_gnode(gn);
	} else {
		return NOSUCHNODE;
d752 2
a755 58
static int
run_prepared_gnode(GNode *gn)
{
	char *cmd;

	gn->built_status = MADE;
	while ((cmd = Lst_DeQueue(&gn->expanded)) != NULL) {
		if (setup_and_run_command(cmd, gn, 0) == 0)
			break;
		free(cmd);
	}
	free(cmd);
	if (got_signal)
		handle_compat_interrupts(gn);
	return gn->built_status;
}

void
run_gnode_parallel(GNode *gn)
{
	char *cmd;

	gn->built_status = MADE;
	/* XXX don't bother freeing cmd, we're dead anyways ! */
	while ((cmd = Lst_DeQueue(&gn->expanded)) != NULL) {
		if (setup_and_run_command(cmd, gn,
		    Lst_IsEmpty(&gn->expanded)) == 0)
			break;
	}
	/* Normally, we don't reach this point, unless the last command
	 * ignores error, in which case we interpret the status ourselves.
	 */
	switch(gn->built_status) {
	case MADE:
		exit(0);
	case ERROR:
		exit(1);
	default:
		fprintf(stderr, "Could not run gnode, returned %d\n",
		    gn->built_status);
		exit(1);
	}
}

void
setup_engine(int parallel)
{
	static int already_setup = 0;

	if (!already_setup) {
		setup_meta();
		if (parallel)
			setup_all_signals(parallel_handler, parallel_handler);
		else
			setup_all_signals(SigHandler, SIG_DFL);
		already_setup = 1;
	}
}
@


1.31
log
@! is a meta character, this lets

test:
	! pgrep process

work, without trying to look for a '!' command

(remember that not running a shell for each command is an optimization ?)

bug fix prompted by eric@@'s remark, okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.30 2012/08/25 08:12:56 espie Exp $ */
d520 1
a520 1
	for (p = "#!=|^(){};&<>*?[]:$`\\\n"; *p != '\0'; p++)
d530 1
a530 1
		"alias", "cd", "eval", "exit", "read", "set", "ulimit",
@


1.30
log
@- make wrong variable specs (unterminated) parse errors.
- add info to be able to pinpoint parse errors at runtime.
- let job runners abort when a parse error happens while expanding a variable
during execution
- fix an infinite loop when compiling without FEATURE_RECVARS.

okay millert@@, krw@@
the very few errors found out by this (less than 10 over src/X/ports)
fixed trivially beforehand, as requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.29 2012/03/22 13:47:12 espie Exp $ */
d520 1
a520 1
	for (p = "#=|^(){};&<>*?[]:$`\\\n"; *p != '\0'; p++)
@


1.29
log
@minor cleanup: error messages include lineno and fileno together, so
recognize that and create a struct Location_ for it.

mostly from Jonathan Calmels, a few nits from me.

okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.28 2010/04/25 13:59:53 espie Exp $ */
d741 1
d753 2
@


1.28
log
@pure whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d256 2
a257 4
	if (!pgn->lineno) {
		pgn->lineno = cgn->lineno;
		pgn->fname = cgn->fname;
	}
@


1.27
log
@write sensible error message
@
text
@d95 1
a95 1
		if ((gn->type & OP_NODEFAULT) == 0 && 
d114 1
a114 1
			 * this branch. 
d315 1
a315 1
					Buf_AddString(&oodate, 
d328 1
a328 1
				Buf_AddString(&allsrc, 
d343 1
a343 1
			
d624 1
a624 1
	} 
d715 1
a715 1
static void 
d785 1
a785 1
		if (setup_and_run_command(cmd, gn, 
d798 1
a798 1
		fprintf(stderr, "Could not run gnode, returned %d\n", 
@


1.26
log
@avoid touching .PHONY targets, they don't exist.
@
text
@d709 1
a709 1
			Fatal("error in wait: %d", stat);
d798 2
a799 3
		fprintf(stderr, 
		    "Could not run gnode, returned %d\n", 
			gn->built_status);
@


1.25
log
@zap double prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.24 2009/05/10 11:07:37 espie Exp $ */
d172 1
a172 1
	if (gn->type & (OP_JOIN|OP_USE|OP_EXEC|OP_OPTIONAL)) {
d176 1
@


1.24
log
@simplify job handling a great deal: we don't care when jobs get
stopped/continued, as we won't try to start new jobs when other stuff
is stopped.

Redo signal handling so that most stuff can be done directly in the handler.
This requires blocking/unblocking signals while creating new jobs, and creating
a small list that only contains job's pids.

Switch to pgrps for jobs, since that works.

Add a clamping heuristic that avoids starting new jobs while an expensive job
is running (expensive meaning "very likely to be a recursive make run"). This
idea is mostly from Theo, through the implementation is mine.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a66 1
void setup_all_signals(psighandler, psighandler);
@


1.23
log
@move code around a bit, extract code from run_prepared_gnode
into a run_gnode_parallel. That simplifies the control flow of that routine
a bit, to allow for more tweaks in the parallel case.

okay kettenis@@, otto@@
@
text
@d65 1
d67 1
d70 1
a70 2
static void setup_signal(int);
static void setup_all_signals(void);
d460 1
a460 2
volatile sig_atomic_t got_SIGINT, got_SIGHUP, got_SIGQUIT,
    got_SIGTERM, got_SIGTSTP, got_SIGTTOU, got_SIGTTIN, got_SIGWINCH;
d463 1
a463 1
setup_signal(int sig)
d465 2
a466 3
	if (signal(sig, SIG_IGN) != SIG_IGN) {
		(void)signal(sig, SigHandler);
	}
d469 2
a470 2
static void
setup_all_signals()
d476 10
a485 16
	setup_signal(SIGINT);
	setup_signal(SIGHUP);
	setup_signal(SIGQUIT);
	setup_signal(SIGTERM);
	/*
	 * There are additional signals that need to be caught and passed if
	 * either the export system wants to be told directly of signals or if
	 * we're giving each job its own process group (since then it won't get
	 * signals from the terminal driver as we own the terminal)
	 */
#if defined(USE_PGRP)
	setup_signal(SIGTSTP);
	setup_signal(SIGTTOU);
	setup_signal(SIGTTIN);
	setup_signal(SIGWINCH);
#endif
a507 18
#ifdef USE_PGRP
	case SIGTSTP:
		got_SIGTSTP++;
		got_signal = 1;
		break;
	case SIGTTOU:
		got_SIGTTOU++;
		got_signal = 1;
		break;
	case SIGTTIN:
		got_SIGTTIN++;
		got_signal = 1;
		break;
	case SIGWINCH:
		got_SIGWINCH++;
		got_signal = 1;
		break;
#endif
d673 1
a673 1
		while ((stat = wait(&reason)) != cpid) {
d682 1
a682 3
			if (WIFSTOPPED(reason))
				status = WSTOPSIG(reason);	/* stopped */
			else if (WIFEXITED(reason)) {
d685 1
a685 1
				    printf("*** Error code %d", status);
d806 1
a806 1
setup_engine()
d812 4
a815 1
		setup_all_signals();
@


1.22
log
@missing static
@
text
@d75 1
d781 3
a784 1
	return run_prepared_gnode(gn, 0);
d787 2
a788 2
int
run_prepared_gnode(GNode *gn, int parallel)
d792 4
a795 8
	if (gn != NULL && (gn->type & OP_DUMMY) == 0) {
		gn->built_status = MADE;
		while ((cmd = Lst_DeQueue(&gn->expanded)) != NULL) {
			if (setup_and_run_command(cmd, gn, 
			    parallel && Lst_IsEmpty(&gn->expanded)) == 0)
				break;
			free(cmd);
		}
d797 33
a829 5
		if (got_signal && !parallel)
			handle_compat_interrupts(gn);
		return gn->built_status;
	} else
		return NOSUCHNODE;
@


1.21
log
@adjust comment to reflect reality (CompatRunCommand is gone)
@
text
@d469 1
a469 1
void
@


1.20
log
@changes to get target equivalence to work better.
- add new file to create lists of equivalent targets (siblings)
- use that for sequential mode to have much better VPATH support
- separate checking commands from reporting error, for later.
- zap DieHorribly accordingly
- renumber existing flags
- signal_running_jobs() is simpler than pass_signal_to_jobs()
- new debug option -dn for name matching.

Similar code to handle parallel make is still missing.

thanks to Mark, Miod, Theo, Otto, Todd for tests and/or comments.
@
text
@d81 1
a81 1
	 * should not be printed so CompatRunCommand knows what to do.
@


1.19
log
@A few changes:
- expand commands earlier, so that we can eventually scan them to take
smarter decisions.
- clean up the select() mask code and rename variables to sensible things.
- quite a few minor renames for readability
- erecalloc
- clean up wait status handling, do not try to rebuild wait status, but
instead parse it early and deal with the parsed code.

tested by lots of people, thanks guys!
@
text
@d38 1
d78 1
a78 1
Job_CheckCommands(GNode *gn, void (*abortProc)(char *, ...))
d113 1
a113 3
			 * this branch. If the -k flag wasn't given, we stop in
			 * our tracks, otherwise we just don't update this
			 * node's parents so they never get examined.
d115 2
a116 18
			static const char msg[] =
			    "make: don't know how to make";

			if (gn->type & OP_OPTIONAL) {
				(void)fprintf(stdout, "%s %s(ignored)\n", msg,
				    gn->name);
				(void)fflush(stdout);
			} else if (keepgoing) {
				(void)fprintf(stdout, "%s %s(continuing)\n",
				    msg, gn->name);
				(void)fflush(stdout);
				return false;
			} else {
				(*abortProc)("%s %s. Stop in %s.", msg,
				    gn->name, Var_Value(".CURDIR"));
				return false;
			}
		}
d121 24
d220 16
a235 5
	if (cgn->type & (OP_USE|OP_TRANSFORM)) {
		if ((cgn->type & OP_USE) || Lst_IsEmpty(&pgn->commands)) {
			/* .USE or transformation and target has no commands
			 * -- append the child's commands to the parent.  */
			Lst_Concat(&pgn->commands, &cgn->commands);
d237 1
d239 1
a239 9
		for (ln = Lst_First(&cgn->children); ln != NULL;
		    ln = Lst_Adv(ln)) {
			gn = (GNode *)Lst_Datum(ln);

			if (Lst_AddNew(&pgn->children, gn)) {
				Lst_AtEnd(&gn->parents, pgn);
				pgn->unmade++;
			}
		}
d241 9
a249 1
		pgn->type |= cgn->type & ~(OP_OPMASK|OP_USE|OP_TRANSFORM);
a250 10
		/*
		 * This child node is now "made", so we decrement the count of
		 * unmade children in the parent... We also remove the child
		 * from the parent's list to accurately reflect the number of
		 * decent children the parent has. This is used by Make_Run to
		 * decide whether to queue the parent or examine its children...
		 */
		if (cgn->type & OP_USE)
			pgn->unmade--;
	}
@


1.18
log
@fix obvious bug in .NODEFAULT handling
@
text
@a621 1
	char *cmdStart;	/* Start of expanded command */
a633 2
	cmdStart = Var_Subst(cmd, &gn->context, false);

d636 1
a636 2
	if (*cmdStart == '\0') {
		free(cmdStart);
d639 1
a639 2
	} else
		cmd = cmdStart;
a683 1
	free(cmdStart);
d748 1
a748 1
		run_gnode(interrupt_node, 0);
d754 21
d776 1
a776 1
run_gnode(GNode *gn, int parallel)
d778 1
a778 1
	LstNode ln, nln;
d782 3
a784 4
		for (ln = Lst_First(&gn->commands); ln != NULL; ln = nln) {
			nln = Lst_Adv(ln);
			if (setup_and_run_command(Lst_Datum(ln), gn, 
			    parallel && nln == NULL) == 0)
d786 1
d788 1
@


1.17
log
@if our node doesn't have a lineno/fname, inherit from `used' node.
This lets suffix rules finally print out where they come from...
@
text
@d88 1
a88 1
	    (gn->type & (OP_NODEFAULT | OP_LIB)) == 0) {
d93 2
a94 1
		if ((DEFAULT->type & OP_DUMMY) == 0 &&
@


1.16
log
@simplify dynamic variable handling a great deal:
first remove all usage of Varq_Append by building the string directly.
then replace `common' handling with specialized handling for dynamic
strings (since they no longer need a buffer). Finally, identify the place
where the variable value needs to be copied because it's going to be free'd
or erased soon, and finally, use simple char* pointers.

Shaves about 80 bytes off every gnode structure, and kills quite a few
unnecessary malloc()s as well.
@
text
@d241 7
@


1.15
log
@.PHONY targets should not look at files.
@
text
@d63 1
a65 1
static void MakeAddAllSrc(void *, void *);
d105 1
a105 1
			Varq_Set(IMPSRC_INDEX, Varq_Value(TARGET_INDEX, gn), gn);
d243 2
a244 2
static void
MakeAddAllSrc(void *cgnp, void *pgnp)
d246 14
a259 5
	GNode	*child = (GNode *)cgnp;
	GNode	*parent = (GNode *)pgnp;
	if ((child->type & (OP_EXEC|OP_USE|OP_INVISIBLE)) == 0) {
		const char *target;

d261 1
a261 1
		    (target = Varq_Value(TARGET_INDEX, child)) == NULL) {
d270 13
a282 2
		Varq_Append(ALLSRC_INDEX, target, parent);
		if (parent->type & OP_JOIN) {
d284 2
a285 2
				Varq_Append(OODATE_INDEX, target, parent);
		} else if (is_strictly_before(parent->mtime, child->mtime) ||
d287 27
a313 14
		   child->built_status == MADE)) {
			/*
			 * It goes in the OODATE variable if the parent is
			 * younger than the child or if the child has been
			 * modified more recently than the start of the make.
			 * This is to keep make from getting confused if
			 * something else updates the parent after the
			 * make starts (shouldn't happen, I know, but sometimes
			 * it does). In such a case, if we've updated the kid,
			 * the parent is likely to have a modification time
			 * later than that of the kid and anything that relies
			 * on the OODATE variable will be hosed.
			 */
			Varq_Append(OODATE_INDEX, target, parent);
a315 1
}
d317 4
a320 4
void
Make_DoAllVar(GNode *gn)
{
	Lst_ForEach(&gn->children, MakeAddAllSrc, gn);
d323 1
a323 2
		Varq_Set(IMPSRC_INDEX, 
		    Varq_Value(TARGET_INDEX, gn->impliedsrc), gn);
a324 5
	if (Varq_Value(OODATE_INDEX, gn) == NULL)
		Varq_Set(OODATE_INDEX, "", gn);
	if (Varq_Value(ALLSRC_INDEX, gn) == NULL)
		Varq_Set(ALLSRC_INDEX, "", gn);

d326 1
a326 1
		Varq_Set(TARGET_INDEX, Varq_Value(ALLSRC_INDEX, gn), gn);
d734 1
a734 1
		char	  *file = Varq_Value(TARGET_INDEX, gn);
@


1.14
log
@rename make -> must_make, made -> built_status
to make them easier to find in source files.
@
text
@d319 1
a319 1
	if ((gn->type & (OP_JOIN|OP_USE|OP_EXEC)) == 0) {
@


1.13
log
@simplify the way we deal with implicit rules and handle $<.

Having an `iParents' field is actually backwards, it's ways simpler to
store the pointer in the child, as an impliedsrc, and to set the variable
just in time along with all the rest in DoAllVar.

This is simpler, and it should allow us to call SuffFindDeps much later.
@
text
@d263 1
a263 1
			if (child->made == MADE)
d267 1
a267 1
		   child->made == MADE)) {
d576 1
a576 1
 *	error, the node's made field is set to ERROR and creation stops.
d582 1
a582 1
 *	The node's 'made' field may be set to ERROR.
d683 1
a683 1
					gn->made = ERROR;
d732 1
a732 1
		gn->made = MADE;
d741 1
a741 1
		return gn->made;
@


1.12
log
@simplify: Job_CheckCommands deals with silent and ignerr now, so there's
no need to duplicate that info at the job level since we can just use
the gn->type.
@
text
@d290 4
@


1.11
log
@do the silent/ignore check in Job_CheckCommands, so that make -j4 -s works
@
text
@d161 1
a161 1
Job_Touch(GNode *gn, bool silent)
d171 1
a171 1
	if (!silent) {
@


1.10
log
@Work done at p2k7.


This is a really big step towards getting parallel make to work.


Note that this is not yet complete. There are still a few `details' to
fix before this works 100%.  Specifically: sequential make (compat) and
parallel make don't use the same engine, and the parallel engine still
has a few limitations. For instance, some known issues:
- parallel make does not deal with .phony targets correctly all the time.
- some errors are deadly in parallel make mode.
- parallel make NEEDS way more sturdy correspondance of file system paths
and target names, since it often needs to match dependencies to targets
before the corresponding files exist.
- some local variables like $* get set in a bogus way in some cases.
- suffix handling has issues, especially related to the NULL suffix.
So, if you find stuff that does NOT yet work with parallel make, don't go
blindly try to fix the Makefile. It's very likely you might have stumbled
into a make bug. (unless you really, really, understand Makefiles, DON'T
GO CHANGING THEM YET).



Tested by lots of people, thanks go to miod@@, and robert@@ among other people.

Quick summary of what this does:

- remove `saving commands' extension (it's not really usable, nor used)
- move compat job runner and parallel interrupt handling into engine.c
- tweak the code so that both compat and parallel mode use the same job runner
and the same interrupt handling. Remove the other one.
- optimize job runner so that, in parallel mode, the last command does not
fork if we can avoid it (as it's already running in a sub shell).
- scrape all the code that dealt with creating shell scripts from commands.
- scrape all the code that dealt with recognizing special sequences in
command output to print/not print output.
- fix the parallel job pipe to not keep around file descriptors that are not
needed.
- replace the parallel job buffering with a nicer one, that deals with
non-blocking descriptors to try to agregate as much output from one job in
one go (greed) to unconfuse the users.
- create two pipes per job, so that stdout and stderr stay separate.
- make job token printing a debug option.
- always use the parallel job-runner to `execute' commands, even if we just
print them out.
- store list of errors encountered during parallel make running, and print them
on exit, so that we know what went wrong.
- add a dirty hack to targ.c to deal with paths produced by gccmakedep.
@
text
@d79 8
@


1.9
log
@rewrite of the basic suffix/target parsing: use hash for suffixes.

Store special targets in target hash, and use them for the parsing.

Use OP_DUMMY flag to mark targets that don't really exist yet, such
as interrupt and default nodes.

Also, .PATHxxx is special in suffixes.

Small tweaks to compat.c, so that run_commands does more stuff after
the fork() (and thus no need to free things).

Remove distinction between local and global jobs.
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.5 2007/09/17 09:28:36 espie Exp $ */
d36 2
d40 2
d46 1
d59 4
d67 8
d401 344
@


1.8
log
@fix indent
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.7 2007/09/17 12:10:35 espie Exp $ */
a53 1
#include "main.h"
a58 13
/*-
 *-----------------------------------------------------------------------
 * Job_CheckCommands --
 *	Make sure the given node has all the commands it needs.
 *
 * Results:
 *	true if the commands list is/was ok.
 *
 * Side Effects:
 *	The node will have commands from the .DEFAULT rule added to it
 *	if it needs them.
 *-----------------------------------------------------------------------
 */
d63 1
a63 1
	    (gn->type & OP_LIB) == 0) {
d68 2
a69 1
		if (DEFAULT != NULL && !Lst_IsEmpty(&DEFAULT->commands)) {
a134 11
/*-
 *-----------------------------------------------------------------------
 * Job_Touch --
 *	Touch the given target. Called by JobStart when the -t flag was
 *	given
 *
 * Side Effects:
 *	The data modification of the file is changed. In addition, if the
 *	file did not exist, it is created.
 *-----------------------------------------------------------------------
 */
d140 2
a141 2
		 * .JOIN, .USE and .OPTIONAL targets are "virtual"
		 * targets and, as such, shouldn't really be created.
d168 1
a168 1
			}
a172 11
/*-
 *-----------------------------------------------------------------------
 * Make_TimeStamp --
 *	Set the cmtime field of a parent node based on the mtime stamp in its
 *	child.
 *
 * Side Effects:
 *	The cmtime of the parent node will be changed if the mtime
 *	field of the child is greater than it.
 *-----------------------------------------------------------------------
 */
a179 20
/*-
 *-----------------------------------------------------------------------
 * Make_HandleUse --
 *	Function called by Make_Run and SuffApplyTransform on the downward
 *	pass to handle .USE and transformation nodes. A callback function
 *	for Lst_ForEach, it implements the .USE and transformation
 *	functionality by copying the node's commands, type flags
 *	and children to the parent node. Should be called before the
 *	children are enqueued to be looked at by MakeAddChild.
 *
 *	A .USE node is much like an explicit transformation rule, except
 *	its commands are always added to the target node, even if the
 *	target already has commands.
 *
 * Side Effects:
 *	Children and commands may be added to the parent and the parent's
 *	type may be changed.
 *
 *-----------------------------------------------------------------------
 */
d181 1
a181 2
Make_HandleUse(
    GNode	*cgn,	/* The .USE node */
d189 2
a190 2
			/* .USE or transformation and target has no commands --
			 * append the child's commands to the parent.  */
d211 1
a211 2
		 * decide whether to queue the parent or examine its
		 * children...
d213 1
a213 1
		if (cgn->type & OP_USE) {
a214 1
		}
a217 17
/*-
 *-----------------------------------------------------------------------
 * MakeAddAllSrc --
 *	Add a child's name to the ALLSRC and OODATE variables of the given
 *	node. Called from Make_DoAllVar via Lst_ForEach. A child is added only
 *	if it has not been given the .EXEC, .USE or .INVISIBLE attributes.
 *	.EXEC and .USE children are very rarely going to be files, so...
 *	A child is added to the OODATE variable if its modification time is
 *	later than that of its parent, as defined by Make, except if the
 *	parent is a .JOIN node. In that case, it is only added to the OODATE
 *	variable if it was actually made (since .JOIN nodes don't have
 *	modification times, the comparison is rather unfair...)..
 *
 * Side Effects:
 *	The ALLSRC variable for the given node is extended.
 *-----------------------------------------------------------------------
 */
d219 1
a219 4
MakeAddAllSrc(
    void *cgnp, /* The child to add */
    void *pgnp) /* The parent to whose ALLSRC variable it should be */
			/* added */
d221 4
a224 4
	GNode *cgn = (GNode *)cgnp;
	GNode *pgn = (GNode *)pgnp;
	if ((cgn->type & (OP_EXEC|OP_USE|OP_INVISIBLE)) == 0) {
		const char *child;
d226 2
a227 2
		if (OP_NOP(cgn->type) ||
		    (child = Varq_Value(TARGET_INDEX, cgn)) == NULL) {
d232 2
a233 1
			child = cgn->path != NULL ? cgn->path : cgn->name;
d236 7
a242 8
		Varq_Append(ALLSRC_INDEX, child, pgn);
		if (pgn->type & OP_JOIN) {
			if (cgn->made == MADE) {
				Varq_Append(OODATE_INDEX, child, pgn);
			}
		} else if (is_strictly_before(pgn->mtime, cgn->mtime) ||
		    (!is_strictly_before(cgn->mtime, now) &&
		    cgn->made == MADE)) {
d247 7
a253 8
			 * This is to keep pmake from getting confused if
			 * something else updates the parent after the make
			 * starts (shouldn't happen, I know, but sometimes it
			 * does). In such a case, if we've updated the kid, the
			 * parent is likely to have a modification time later
			 * than that of the kid and anything that relies on the
			 * OODATE variable will be hosed.
			 *
d255 1
a255 1
			Varq_Append(OODATE_INDEX, child, pgn);
a259 19
/*-
 *-----------------------------------------------------------------------
 * Make_DoAllVar --
 *	Set up the ALLSRC and OODATE variables. Sad to say, it must be
 *	done separately, rather than while traversing the graph. This is
 *	because Make defined OODATE to contain all sources whose modification
 *	times were later than that of the target, *not* those sources that
 *	were out-of-date. Since in both compatibility and native modes,
 *	the modification time of the parent isn't found until the child
 *	has been dealt with, we have to wait until now to fill in the
 *	variable. As for ALLSRC, the ordering is important and not
 *	guaranteed when in native mode, so it must be set here, too.
 *
 * Side Effects:
 *	The ALLSRC and OODATE variables of the given node is filled in.
 *	If the node is a .JOIN node, its TARGET variable will be set to
 *	match its ALLSRC variable.
 *-----------------------------------------------------------------------
 */
d276 1
a276 3
MakeTimeStamp(
    void *pgn,	/* the current parent */
    void *cgn)	/* the child we've just examined */
d278 1
a278 1
	Make_TimeStamp((GNode *)pgn, (GNode *)cgn);
a280 18
/*-
 *-----------------------------------------------------------------------
 * Make_OODate --
 *	See if a given node is out of date with respect to its sources.
 *	Used by Make_Run when deciding which nodes to place on the
 *	toBeMade queue initially and by Make_Update to screen out USE and
 *	EXEC nodes. In the latter case, however, any other sort of node
 *	must be considered out-of-date since at least one of its children
 *	will have been recreated.
 *
 * Results:
 *	true if the node is out of date. false otherwise.
 *
 * Side Effects:
 *	The mtime field of the node and the cmtime field of its parents
 *	will/may be changed.
 *-----------------------------------------------------------------------
 */
d282 1
a282 1
Make_OODate(GNode *gn)	/* the node to check */
d284 1
a284 1
	bool oodate;
d293 1
a293 1
			if (!is_out_of_date(gn->mtime)) {
d296 1
a296 1
			} else {
a297 1
			}
d303 5
a307 5
	 *	its modification time is smaller than that of its youngest child
	 *	    and it would actually be run (has commands or type OP_NOP)
	 *	it's the object of a force operator
	 *	it has no children, was on the lhs of an operator and doesn't
	 *	exist already.
a310 3
	 *
	 * These weird rules are brought to you by Backward-Compatibility and
	 * the strange people who wrote 'Make'.
d317 1
a317 1
		if (DEBUG(MAKE)) {
a318 1
		}
d321 2
a322 7
		if (DEBUG(MAKE)) {
			printf("library...");
		}

		/*
		 * always out of date if no children and :: target
		 */
d324 1
d332 1
a332 1
		if (DEBUG(MAKE)) {
a333 1
		}
d337 2
a338 3
		 * A node which is the object of the force (!) operator or
		 * which has the .EXEC attribute is always considered
		 * out-of-date.
d341 1
a341 1
			if (gn->type & OP_FORCE) {
d343 1
a343 1
			} else if (gn->type & OP_PHONY) {
d345 1
a345 1
			} else {
a346 1
			}
d350 1
a350 1
	    (is_out_of_date(gn->cmtime) &&
d356 1
a356 2
		 * or was the object of a :: operator is out-of-date. Why?
		 * Because that's the way Make does it.
d359 1
a359 1
			if (is_strictly_before(gn->mtime, gn->cmtime)) {
d361 1
a361 1
			} else if (is_out_of_date(gn->mtime)) {
d363 1
a363 1
			} else {
a364 1
			}
a367 7
#if 0
		/* WHY? */
		if (DEBUG(MAKE)) {
			printf("source %smade...", gn->childMade ? "" : "not ");
		}
		oodate = gn->childMade;
#else
a368 1
#endif /* 0 */
@


1.7
log
@minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.6 2007/09/17 12:07:22 espie Exp $ */
d211 2
a212 2
    if (is_strictly_before(parent->cmtime, child->mtime))
	    parent->cmtime = child->mtime;
@


1.6
log
@separate rewrite_times function
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.5 2007/09/17 09:28:36 espie Exp $ */
d164 1
a164 1
		 * .JOIN, .USE, .ZEROTIME and .OPTIONAL targets are "virtual"
d209 1
a209 3
Make_TimeStamp(
    GNode *pgn, /* the current parent */
    GNode *cgn) /* the child we've just examined */
d211 2
a212 2
	if (is_strictly_before(pgn->cmtime, cgn->mtime))
		pgn->cmtime = cgn->mtime;
@


1.5
log
@kill extra spaces at end of line
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.4 2007/09/17 08:36:57 espie Exp $ */
d58 1
d125 23
a161 2
	int streamID;	/* ID of stream opened to do the touch */

d187 1
a187 16
			streamID = open(file, O_RDWR | O_CREAT, 0666);

			if (streamID >= 0) {
				char	c;

				/*
				 * Read and write a byte to the file to change
				 * the modification time, then close the file.
				 */
				if (read(streamID, &c, 1) == 1) {
					(void)lseek(streamID, 0, SEEK_SET);
					(void)write(streamID, &c, 1);
				}

				(void)close(streamID);
			} else {
@


1.4
log
@kill += 1, -= 1     -> ++, --
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.3 2007/09/16 14:36:57 espie Exp $ */
d102 1
a102 1
			static const char msg[] = 
d106 1
a106 1
				(void)fprintf(stdout, "%s %s(ignored)\n", msg, 
d110 1
a110 1
				(void)fprintf(stdout, "%s %s(continuing)\n", 
d115 1
a115 1
				(*abortProc)("%s %s. Stop in %s.", msg, 
d181 2
a182 2
				(void)fprintf(stdout, 
				    "*** couldn't touch %s: %s", file, 
d245 1
a245 1
		for (ln = Lst_First(&cgn->children); ln != NULL; 
d314 1
a314 1
		    (!is_strictly_before(cgn->mtime, now) && 
d407 1
a407 1
				printf("modified %s...", 
@


1.3
log
@reindent
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.2 2007/09/16 12:09:36 espie Exp $ */
d251 1
a251 1
				pgn->unmade += 1;
@


1.2
log
@rename Targ_FmtTime into time_to_string and move it, as it's not related
to target nodes at all (reduces modules inter-dependencies)
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.1 2007/09/16 10:39:07 espie Exp $ */
d73 1
a73 3
Job_CheckCommands(GNode *gn, 		/* The target whose commands need
				     	 * verifying */
    void (*abortProc)(char *, ...)) 	/* Function to abort with message */
d75 45
a119 40
    if (OP_NOP(gn->type) && Lst_IsEmpty(&gn->commands) &&
	(gn->type & OP_LIB) == 0) {
	/*
	 * No commands. Look for .DEFAULT rule from which we might infer
	 * commands
	 */
	if (DEFAULT != NULL && !Lst_IsEmpty(&DEFAULT->commands)) {
	    /*
	     * Make only looks for a .DEFAULT if the node was never the
	     * target of an operator, so that's what we do too. If
	     * a .DEFAULT was given, we substitute its commands for gn's
	     * commands and set the IMPSRC variable to be the target's name
	     * The DEFAULT node acts like a transformation rule, in that
	     * gn also inherits any attributes or sources attached to
	     * .DEFAULT itself.
	     */
	    Make_HandleUse(DEFAULT, gn);
	    Varq_Set(IMPSRC_INDEX, Varq_Value(TARGET_INDEX, gn), gn);
	} else if (is_out_of_date(Dir_MTime(gn))) {
	    /*
	     * The node wasn't the target of an operator we have no .DEFAULT
	     * rule to go on and the target doesn't already exist. There's
	     * nothing more we can do for this branch. If the -k flag wasn't
	     * given, we stop in our tracks, otherwise we just don't update
	     * this node's parents so they never get examined.
	     */
	    static const char msg[] = "make: don't know how to make";

	    if (gn->type & OP_OPTIONAL) {
		(void)fprintf(stdout, "%s %s(ignored)\n", msg, gn->name);
		(void)fflush(stdout);
	    } else if (keepgoing) {
		(void)fprintf(stdout, "%s %s(continuing)\n", msg, gn->name);
		(void)fflush(stdout);
		return false;
	    } else {
		(*abortProc)("%s %s. Stop in %s.", msg, gn->name,
			Var_Value(".CURDIR"));
		return false;
	    }
d121 1
a121 2
    }
    return true;
d136 1
a136 2
Job_Touch(GNode *gn,		/* the node of the file to touch */
    bool silent)		/* true if should not print messages */
d138 1
a138 1
    int 	  streamID;	/* ID of stream opened to do the touch */
d140 7
a146 7
    if (gn->type & (OP_JOIN|OP_USE|OP_EXEC|OP_OPTIONAL)) {
	/*
	 * .JOIN, .USE, .ZEROTIME and .OPTIONAL targets are "virtual" targets
	 * and, as such, shouldn't really be created.
	 */
	return;
    }
d148 4
a151 15
    if (!silent) {
	(void)fprintf(stdout, "touch %s\n", gn->name);
	(void)fflush(stdout);
    }

    if (noExecute) {
	return;
    }

    if (gn->type & OP_ARCHV) {
	Arch_Touch(gn);
    } else if (gn->type & OP_LIB) {
	Arch_TouchLib(gn);
    } else {
	const char *file = gn->path != NULL ? gn->path : gn->name;
d153 3
a155 5
	if (set_times(file) == -1){
	    streamID = open(file, O_RDWR | O_CREAT, 0666);

	    if (streamID >= 0) {
		char	c;
d157 29
a185 7
		/*
		 * Read and write a byte to the file to change the
		 * modification time, then close the file.
		 */
		if (read(streamID, &c, 1) == 1) {
		    (void)lseek(streamID, 0, SEEK_SET);
		    (void)write(streamID, &c, 1);
a186 7

		(void)close(streamID);
	    } else {
		(void)fprintf(stdout, "*** couldn't touch %s: %s",
			       file, strerror(errno));
		(void)fflush(stdout);
	    }
a187 1
    }
d206 2
a207 2
    if (is_strictly_before(pgn->cmtime, cgn->mtime))
	pgn->cmtime = cgn->mtime;
d235 2
a236 2
    GNode	*gn;	/* A child of the .USE node */
    LstNode	ln;	/* An element in the children list */
d238 6
a243 6
    if (cgn->type & (OP_USE|OP_TRANSFORM)) {
	if ((cgn->type & OP_USE) || Lst_IsEmpty(&pgn->commands)) {
	    /* .USE or transformation and target has no commands -- append
	     * the child's commands to the parent.  */
	    Lst_Concat(&pgn->commands, &cgn->commands);
	}
d245 9
a253 2
	for (ln = Lst_First(&cgn->children); ln != NULL; ln = Lst_Adv(ln)) {
	    gn = (GNode *)Lst_Datum(ln);
d255 1
a255 5
	    if (Lst_AddNew(&pgn->children, gn)) {
		Lst_AtEnd(&gn->parents, pgn);
		pgn->unmade += 1;
	    }
	}
d257 11
a267 11
	pgn->type |= cgn->type & ~(OP_OPMASK|OP_USE|OP_TRANSFORM);

	/*
	 * This child node is now "made", so we decrement the count of
	 * unmade children in the parent... We also remove the child
	 * from the parent's list to accurately reflect the number of decent
	 * children the parent has. This is used by Make_Run to decide
	 * whether to queue the parent or examine its children...
	 */
	if (cgn->type & OP_USE) {
	    pgn->unmade--;
a268 1
    }
d294 13
a306 12
    GNode	*cgn = (GNode *)cgnp;
    GNode	*pgn = (GNode *)pgnp;
    if ((cgn->type & (OP_EXEC|OP_USE|OP_INVISIBLE)) == 0) {
	const char *child;

	if (OP_NOP(cgn->type) ||
	    (child = Varq_Value(TARGET_INDEX, cgn)) == NULL) {
	    /*
	     * this node is only source; use the specific pathname for it
	     */
	    child = cgn->path != NULL ? cgn->path : cgn->name;
	}
d308 23
a330 21
	Varq_Append(ALLSRC_INDEX, child, pgn);
	if (pgn->type & OP_JOIN) {
	    if (cgn->made == MADE) {
		Varq_Append(OODATE_INDEX, child, pgn);
	    }
	} else if (is_strictly_before(pgn->mtime, cgn->mtime) ||
		   (!is_strictly_before(cgn->mtime, now) && cgn->made == MADE))
	{
	    /*
	     * It goes in the OODATE variable if the parent is younger than the
	     * child or if the child has been modified more recently than
	     * the start of the make. This is to keep pmake from getting
	     * confused if something else updates the parent after the
	     * make starts (shouldn't happen, I know, but sometimes it
	     * does). In such a case, if we've updated the kid, the parent
	     * is likely to have a modification time later than that of
	     * the kid and anything that relies on the OODATE variable will
	     * be hosed.
	     *
	     */
	    Varq_Append(OODATE_INDEX, child, pgn);
a331 1
    }
d356 1
a356 1
    Lst_ForEach(&gn->children, MakeAddAllSrc, gn);
d358 4
a361 4
    if (Varq_Value(OODATE_INDEX, gn) == NULL)
	Varq_Set(OODATE_INDEX, "", gn);
    if (Varq_Value(ALLSRC_INDEX, gn) == NULL)
	Varq_Set(ALLSRC_INDEX, "", gn);
d363 2
a364 2
    if (gn->type & OP_JOIN)
	Varq_Set(TARGET_INDEX, Varq_Value(ALLSRC_INDEX, gn), gn);
d373 1
a373 1
    Make_TimeStamp((GNode *)pgn, (GNode *)cgn);
d397 1
a397 1
    bool	    oodate;
a398 30
    /*
     * Certain types of targets needn't even be sought as their datedness
     * doesn't depend on their modification time...
     */
    if ((gn->type & (OP_JOIN|OP_USE|OP_EXEC)) == 0) {
	(void)Dir_MTime(gn);
	if (DEBUG(MAKE)) {
	    if (!is_out_of_date(gn->mtime)) {
		printf("modified %s...", time_to_string(gn->mtime));
	    } else {
		printf("non-existent...");
	    }
	}
    }

    /*
     * A target is remade in one of the following circumstances:
     *	its modification time is smaller than that of its youngest child
     *	    and it would actually be run (has commands or type OP_NOP)
     *	it's the object of a force operator
     *	it has no children, was on the lhs of an operator and doesn't exist
     *	    already.
     *
     * Libraries are only considered out-of-date if the archive module says
     * they are.
     *
     * These weird rules are brought to you by Backward-Compatibility and
     * the strange people who wrote 'Make'.
     */
    if (gn->type & OP_USE) {
d400 2
a401 2
	 * If the node is a USE node it is *never* out of date
	 * no matter *what*.
d403 10
a412 7
	if (DEBUG(MAKE)) {
	    printf(".USE node...");
	}
	oodate = false;
    } else if ((gn->type & OP_LIB) && Arch_IsLib(gn)) {
	if (DEBUG(MAKE)) {
	    printf("library...");
d416 12
a427 1
	 * always out of date if no children and :: target
d429 13
d443 52
a494 48
	oodate = Arch_LibOODate(gn) ||
	    (is_out_of_date(gn->cmtime) && (gn->type & OP_DOUBLEDEP));
    } else if (gn->type & OP_JOIN) {
	/*
	 * A target with the .JOIN attribute is only considered
	 * out-of-date if any of its children was out-of-date.
	 */
	if (DEBUG(MAKE)) {
	    printf(".JOIN node...");
	}
	oodate = gn->childMade;
    } else if (gn->type & (OP_FORCE|OP_EXEC|OP_PHONY)) {
	/*
	 * A node which is the object of the force (!) operator or which has
	 * the .EXEC attribute is always considered out-of-date.
	 */
	if (DEBUG(MAKE)) {
	    if (gn->type & OP_FORCE) {
		printf("! operator...");
	    } else if (gn->type & OP_PHONY) {
		printf(".PHONY node...");
	    } else {
		printf(".EXEC node...");
	    }
	}
	oodate = true;
    } else if (is_strictly_before(gn->mtime, gn->cmtime) ||
	       (is_out_of_date(gn->cmtime) &&
		(is_out_of_date(gn->mtime) || (gn->type & OP_DOUBLEDEP))))
    {
	/*
	 * A node whose modification time is less than that of its
	 * youngest child or that has no children (cmtime == OUT_OF_DATE) and
	 * either doesn't exist (mtime == OUT_OF_DATE) or was the object of a
	 * :: operator is out-of-date. Why? Because that's the way Make does
	 * it.
	 */
	if (DEBUG(MAKE)) {
	    if (is_strictly_before(gn->mtime, gn->cmtime)) {
		printf("modified before source...");
	    } else if (is_out_of_date(gn->mtime)) {
		printf("non-existent and no sources...");
	    } else {
		printf(":: operator and no sources...");
	    }
	}
	oodate = true;
    } else {
d496 5
a500 5
	/* WHY? */
	if (DEBUG(MAKE)) {
	    printf("source %smade...", gn->childMade ? "" : "not ");
	}
	oodate = gn->childMade;
d502 1
a502 1
	oodate = false;
d504 1
a504 1
    }
d506 9
a514 9
    /*
     * If the target isn't out-of-date, the parents need to know its
     * modification time. Note that targets that appear to be out-of-date
     * but aren't, because they have no commands and aren't of type OP_NOP,
     * have their mtime stay below their children's mtime to keep parents from
     * thinking they're out-of-date.
     */
    if (!oodate)
	Lst_ForEach(&gn->parents, MakeTimeStamp, gn);
d516 1
a516 1
    return oodate;
@


1.1
log
@first step towards sanity: take the functions common to parallel/not parallel
make outside of make.c and job.c, and create an engine.c file to hold them.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d401 1
a401 1
		printf("modified %s...", Targ_FmtTime(gn->mtime));
@

