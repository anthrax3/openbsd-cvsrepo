head	1.118;
access;
symbols
	OPENBSD_6_1:1.118.0.4
	OPENBSD_6_1_BASE:1.118
	OPENBSD_6_0:1.116.0.2
	OPENBSD_6_0_BASE:1.116
	OPENBSD_5_9:1.115.0.2
	OPENBSD_5_9_BASE:1.115
	OPENBSD_5_8:1.112.0.6
	OPENBSD_5_8_BASE:1.112
	OPENBSD_5_7:1.112.0.2
	OPENBSD_5_7_BASE:1.112
	OPENBSD_5_6:1.110.0.6
	OPENBSD_5_6_BASE:1.110
	OPENBSD_5_5:1.110.0.4
	OPENBSD_5_5_BASE:1.110
	OPENBSD_5_4:1.109.0.4
	OPENBSD_5_4_BASE:1.109
	OPENBSD_5_3:1.109.0.2
	OPENBSD_5_3_BASE:1.109
	OPENBSD_5_2:1.104.0.2
	OPENBSD_5_2_BASE:1.104
	OPENBSD_5_1_BASE:1.100
	OPENBSD_5_1:1.100.0.6
	OPENBSD_5_0:1.100.0.4
	OPENBSD_5_0_BASE:1.100
	OPENBSD_4_9:1.100.0.2
	OPENBSD_4_9_BASE:1.100
	OPENBSD_4_8:1.99.0.2
	OPENBSD_4_8_BASE:1.99
	OPENBSD_4_7:1.97.0.2
	OPENBSD_4_7_BASE:1.97
	OPENBSD_4_6:1.96.0.4
	OPENBSD_4_6_BASE:1.96
	OPENBSD_4_5:1.95.0.6
	OPENBSD_4_5_BASE:1.95
	OPENBSD_4_4:1.95.0.4
	OPENBSD_4_4_BASE:1.95
	OPENBSD_4_3:1.95.0.2
	OPENBSD_4_3_BASE:1.95
	OPENBSD_4_2:1.80.0.2
	OPENBSD_4_2_BASE:1.80
	OPENBSD_4_1:1.70.0.2
	OPENBSD_4_1_BASE:1.70
	OPENBSD_4_0:1.69.0.10
	OPENBSD_4_0_BASE:1.69
	OPENBSD_3_9:1.69.0.8
	OPENBSD_3_9_BASE:1.69
	OPENBSD_3_8:1.69.0.6
	OPENBSD_3_8_BASE:1.69
	OPENBSD_3_7:1.69.0.4
	OPENBSD_3_7_BASE:1.69
	OPENBSD_3_6:1.69.0.2
	OPENBSD_3_6_BASE:1.69
	OPENBSD_3_5:1.68.0.4
	OPENBSD_3_5_BASE:1.68
	OPENBSD_3_4:1.68.0.2
	OPENBSD_3_4_BASE:1.68
	OPENBSD_3_3:1.67.0.4
	OPENBSD_3_3_BASE:1.67
	OPENBSD_3_2:1.67.0.2
	OPENBSD_3_2_BASE:1.67
	OPENBSD_3_1:1.66.0.2
	OPENBSD_3_1_BASE:1.66
	OPENBSD_3_0:1.63.0.2
	OPENBSD_3_0_BASE:1.63
	OPENBSD_2_9_BASE:1.58
	OPENBSD_2_9:1.58.0.2
	OPENBSD_2_8:1.57.0.2
	OPENBSD_2_8_BASE:1.57
	OPENBSD_2_7:1.39.0.2
	OPENBSD_2_7_BASE:1.39
	OPENBSD_2_6:1.21.0.2
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.15.0.4
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.118
date	2016.10.23.14.54.14;	author espie;	state Exp;
branches;
next	1.117;
commitid	wPoE1FuixzUwl6nK;

1.117
date	2016.10.21.16.12.38;	author espie;	state Exp;
branches;
next	1.116;
commitid	aLVdeKrJ0t5upS3l;

1.116
date	2016.05.13.12.18.11;	author espie;	state Exp;
branches;
next	1.115;
commitid	v5Th46OWjgqJgguh;

1.115
date	2015.12.22.21.50.54;	author espie;	state Exp;
branches;
next	1.114;
commitid	GigfcRQoohfc1el3;

1.114
date	2015.11.29.09.17.12;	author espie;	state Exp;
branches;
next	1.113;
commitid	ksdjFFnlF9CNScbW;

1.113
date	2015.11.06.18.41.02;	author espie;	state Exp;
branches;
next	1.112;
commitid	1JptavfL2sf83nqK;

1.112
date	2015.01.23.22.35.57;	author espie;	state Exp;
branches;
next	1.111;
commitid	WtGGWUPWONvkhNGN;

1.111
date	2015.01.23.13.18.40;	author espie;	state Exp;
branches;
next	1.110;
commitid	iXa5WmoY9RgeqDsn;

1.110
date	2013.11.22.15.47.35;	author espie;	state Exp;
branches;
next	1.109;

1.109
date	2012.11.24.11.06.08;	author espie;	state Exp;
branches;
next	1.108;

1.108
date	2012.11.07.14.18.41;	author espie;	state Exp;
branches;
next	1.107;

1.107
date	2012.10.09.19.45.34;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2012.10.02.10.29.31;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2012.04.20.13.28.11;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2012.04.17.09.34.15;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2012.04.11.18.27.30;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2012.03.22.13.47.12;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2010.12.26.13.09.22;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2010.07.15.10.41.11;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2009.08.16.09.51.12;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2009.05.10.11.52.09;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2007.09.23.09.47.56;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2007.09.18.08.46.10;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2007.09.18.08.24.56;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2007.09.17.12.42.09;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2007.09.17.11.32.25;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2007.09.17.11.14.37;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2007.09.17.11.11.30;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2007.09.17.09.45.37;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2007.09.17.09.44.20;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2007.09.17.09.38.49;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2007.09.17.08.36.57;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2007.09.16.12.30.35;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2007.09.16.10.57.02;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2007.09.16.10.14.26;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2007.08.05.11.00.58;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2007.07.30.10.03.11;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2007.07.30.09.51.53;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2007.07.30.09.32.02;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2007.07.24.18.58.48;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2007.07.24.18.56.15;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2007.07.24.18.52.47;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2007.07.20.12.32.45;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2007.07.08.17.44.20;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2007.03.20.03.50.39;	author tedu;	state Exp;
branches;
next	1.70;

1.70
date	2007.01.18.17.49.51;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2004.04.07.13.11.36;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2003.06.03.02.56.12;	author millert;	state Exp;
branches;
next	1.67;

1.67
date	2002.06.11.21.12.11;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2001.11.11.12.35.02;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2001.11.11.06.02.06;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2001.11.11.01.19.23;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2001.06.12.22.44.21;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2001.05.29.12.53.42;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2001.05.23.12.34.47;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2001.05.15.12.52.15;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2001.05.03.13.41.08;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2000.11.24.14.27.20;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2000.09.14.13.46.45;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2000.09.14.13.43.31;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2000.09.14.13.40.03;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2000.09.14.13.36.46;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2000.09.14.13.32.07;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2000.06.23.16.41.53;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2000.06.23.16.40.50;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2000.06.23.16.39.45;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2000.06.23.16.23.26;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2000.06.23.16.21.43;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2000.06.23.16.20.01;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2000.06.23.16.15.50;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2000.06.17.14.43.36;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2000.06.17.14.40.29;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2000.06.17.14.38.18;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2000.06.10.01.41.06;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2000.06.10.01.32.23;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2000.06.10.01.26.37;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2000.04.17.23.54.47;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2000.04.17.23.45.24;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2000.03.26.16.21.32;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2000.01.08.09.45.15;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	99.12.18.21.58.07;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	99.12.18.21.56.07;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	99.12.18.21.53.32;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	99.12.18.02.11.27;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	99.12.16.17.27.18;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	99.12.16.17.07.21;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	99.12.16.17.02.45;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	99.12.16.16.52.11;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	99.12.16.16.41.42;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	99.12.16.16.27.12;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	99.12.06.22.24.31;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	99.11.11.11.42.19;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	99.11.11.11.40.09;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	99.11.10.14.00.54;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	99.10.05.22.08.07;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	99.10.05.22.06.24;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	99.05.04.16.44.45;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	99.05.04.16.09.25;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	98.12.05.00.06.29;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	98.07.02.20.47.26;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.07.25.21.05.35;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.04.28.01.52.40;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.04.01.07.28.21;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.03.26.17.46.44;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.11.30.21.09.02;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	96.09.21.05.03.37;	author briggs;	state Exp;
branches;
next	1.9;

1.9
date	96.09.02.16.04.17;	author briggs;	state Exp;
branches;
next	1.8;

1.8
date	96.07.23.18.37.12;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.03.27.19.32.41;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.03.02.19.50.48;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.02.23.18.32.58;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.22.22.24.51;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	95.12.17.13.42.02;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.23.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.118
log
@add !!=
feedback and okay millert@@
@
text
@/*	$OpenBSD: parse.c,v 1.117 2016/10/21 16:12:38 espie Exp $	*/
/*	$NetBSD: parse.c,v 1.29 1997/03/10 21:20:04 christos Exp $	*/

/*
 * Copyright (c) 1999 Marc Espie.
 *
 * Extensive code changes for the OpenBSD project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1988, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <assert.h>
#include <ctype.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ohash.h>
#include "config.h"
#include "defines.h"
#include "dir.h"
#include "direxpand.h"
#include "job.h"
#include "buf.h"
#include "for.h"
#include "lowparse.h"
#include "arch.h"
#include "cond.h"
#include "suff.h"
#include "parse.h"
#include "var.h"
#include "targ.h"
#include "error.h"
#include "str.h"
#include "main.h"
#include "gnode.h"
#include "memory.h"
#include "extern.h"
#include "lst.h"
#include "parsevar.h"
#include "stats.h"
#include "garray.h"
#include "node_int.h"
#include "nodehashconsts.h"


/* gsources and gtargets should be local to some functions, but they're
 * set as persistent arrays for performance reasons.
 */
static struct growableArray gsources, gtargets;
static struct ohash htargets;
static bool htargets_setup = false;
#define SOURCES_SIZE	128
#define TARGETS_SIZE	32

static LIST	theUserIncPath;/* list of directories for "..." includes */
static LIST	theSysIncPath;	/* list of directories for <...> includes */
Lst systemIncludePath = &theSysIncPath;
Lst userIncludePath = &theUserIncPath;

static GNode	    *mainNode;	/* The main target to create. This is the
				 * first target on the first dependency
				 * line in the first makefile */
/*-
 * specType contains the special TYPE of the current target. It is
 * SPECIAL_NONE if the target is unspecial. If it *is* special, however,
 * the children are linked as children of the parent but not vice versa.
 * This variable is set in ParseDoDependency
 */

static unsigned int specType;
static int waiting;

/*
 * Predecessor node for handling .ORDER. Initialized to NULL when .ORDER
 * seen, then set to each successive source on the line.
 */
static GNode	*predecessor;

static void ParseLinkSrc(GNode *, GNode *);
static int ParseDoOp(GNode **, unsigned int);
static int ParseAddDep(GNode *, GNode *);
static void ParseDoSrc(struct growableArray *, struct growableArray *, int,
    const char *, const char *);
static int ParseFindMain(void *, void *);
static void ParseClearPath(void *);

static void add_target_node(const char *, const char *);
static void add_target_nodes(const char *, const char *);
static void apply_op(struct growableArray *, unsigned int, GNode *);
static void ParseDoDependency(const char *);
static void ParseAddCmd(void *, void *);
static void ParseHasCommands(void *);
static bool handle_poison(const char *);
static bool handle_for_loop(Buffer, const char *);
static bool handle_undef(const char *);
#define ParseReadLoopLine(linebuf) Parse_ReadUnparsedLine(linebuf, "for loop")
static bool handle_bsd_command(Buffer, Buffer, const char *);
static bool register_target(GNode *, struct ohash *);
static char *strip_comments(Buffer, const char *);
static char *resolve_include_filename(const char *, const char *, bool);
static void handle_include_file(const char *, const char *, bool, bool);
static bool lookup_bsd_include(const char *);
static void lookup_sysv_style_include(const char *, const char *, bool);
static void lookup_sysv_include(const char *, const char *);
static void lookup_conditional_include(const char *, const char *);
static bool parse_as_special_line(Buffer, Buffer, const char *);
static unsigned int parse_operator(const char **);

static const char *parse_do_targets(Lst, unsigned int *, const char *);
static void parse_target_line(struct growableArray *, const char *,
    const char *, bool *);

static void finish_commands(struct growableArray *);
static void parse_commands(struct growableArray *, const char *);
static void create_special_nodes(void);
static bool found_delimiter(const char *);
static unsigned int handle_special_targets(Lst);
static void dump_targets(void);
static void dedup_targets(struct growableArray *);
static void build_target_group(struct growableArray *, struct ohash *t);
static void reset_target_hash(void);


#define P(k) k, sizeof(k), K_##k

static struct {
	const char *keyword;
	size_t sz;
	uint32_t hv;
	unsigned int type;
	unsigned int special_op;
} specials[] = {
    { P(NODE_EXEC),	SPECIAL_EXEC | SPECIAL_TARGETSOURCE,	OP_EXEC, },
    { P(NODE_IGNORE),	SPECIAL_IGNORE | SPECIAL_TARGETSOURCE, 	OP_IGNORE, },
    { P(NODE_INCLUDES),	SPECIAL_NOTHING | SPECIAL_TARGET,	0, },
    { P(NODE_INVISIBLE),SPECIAL_INVISIBLE | SPECIAL_TARGETSOURCE,OP_INVISIBLE, },
    { P(NODE_JOIN),	SPECIAL_JOIN | SPECIAL_TARGETSOURCE,	OP_JOIN, },
    { P(NODE_LIBS),	SPECIAL_NOTHING | SPECIAL_TARGET,	0, },
    { P(NODE_MADE),	SPECIAL_MADE | SPECIAL_TARGETSOURCE,	OP_MADE, },
    { P(NODE_MAIN),	SPECIAL_MAIN | SPECIAL_TARGET,		0, },
    { P(NODE_MAKE),	SPECIAL_MAKE | SPECIAL_TARGETSOURCE,	OP_MAKE, },
    { P(NODE_MAKEFLAGS),	SPECIAL_MFLAGS | SPECIAL_TARGET,	0, },
    { P(NODE_MFLAGS),	SPECIAL_MFLAGS | SPECIAL_TARGET,	0, },
    { P(NODE_NOTMAIN),	SPECIAL_NOTMAIN | SPECIAL_TARGETSOURCE,	OP_NOTMAIN, },
    { P(NODE_NOTPARALLEL),SPECIAL_NOTPARALLEL | SPECIAL_TARGET,	0, },
    { P(NODE_NO_PARALLEL),SPECIAL_NOTPARALLEL | SPECIAL_TARGET,	0, },
    { P(NODE_NULL),	SPECIAL_NOTHING | SPECIAL_TARGET,	0, },
    { P(NODE_OPTIONAL),	SPECIAL_OPTIONAL | SPECIAL_TARGETSOURCE,OP_OPTIONAL, },
    { P(NODE_ORDER),	SPECIAL_ORDER | SPECIAL_TARGET,		0, },
    { P(NODE_PARALLEL),	SPECIAL_PARALLEL | SPECIAL_TARGET,	0, },
    { P(NODE_PATH),	SPECIAL_PATH | SPECIAL_TARGET,		0, },
    { P(NODE_PHONY),	SPECIAL_PHONY | SPECIAL_TARGETSOURCE,	OP_PHONY, },
    { P(NODE_PRECIOUS),	SPECIAL_PRECIOUS | SPECIAL_TARGETSOURCE,OP_PRECIOUS, },
    { P(NODE_RECURSIVE),SPECIAL_MAKE | SPECIAL_TARGETSOURCE,	OP_MAKE, },
    { P(NODE_SILENT),	SPECIAL_SILENT | SPECIAL_TARGETSOURCE,	OP_SILENT, },
    { P(NODE_SINGLESHELL),SPECIAL_NOTHING | SPECIAL_TARGET,	0, },
    { P(NODE_SUFFIXES),	SPECIAL_SUFFIXES | SPECIAL_TARGET,	0, },
    { P(NODE_USE),	SPECIAL_USE | SPECIAL_TARGETSOURCE,	OP_USE, },
    { P(NODE_WAIT),	SPECIAL_WAIT | SPECIAL_TARGETSOURCE,	0 },
    { P(NODE_CHEAP),	SPECIAL_CHEAP | SPECIAL_TARGETSOURCE,	OP_CHEAP, },
    { P(NODE_EXPENSIVE),SPECIAL_EXPENSIVE | SPECIAL_TARGETSOURCE,OP_EXPENSIVE, },
    { P(NODE_POSIX), SPECIAL_NOTHING | SPECIAL_TARGET, 0 },
    { P(NODE_SCCS_GET), SPECIAL_NOTHING | SPECIAL_TARGET, 0 },
};

#undef P

static void
create_special_nodes()
{
	unsigned int i;

	for (i = 0; i < sizeof(specials)/sizeof(specials[0]); i++) {
		GNode *gn = Targ_FindNodeh(specials[i].keyword,
		    specials[i].sz, specials[i].hv, TARG_CREATE);
		gn->special = specials[i].type;
		gn->special_op = specials[i].special_op;
	}
}

/*-
 *---------------------------------------------------------------------
 * ParseLinkSrc  --
 *	Link the parent node to its new child. Used by
 *	ParseDoDependency. If the specType isn't 'Not', the parent
 *	isn't linked as a parent of the child.
 *
 * Side Effects:
 *	New elements are added to the parents list of cgn and the
 *	children list of cgn. the unmade field of pgn is updated
 *	to reflect the additional child.
 *---------------------------------------------------------------------
 */
static void
ParseLinkSrc(GNode *pgn, GNode *cgn)
{
	if (Lst_AddNew(&pgn->children, cgn)) {
		if (specType == SPECIAL_NONE)
			Lst_AtEnd(&cgn->parents, pgn);
		pgn->unmade++;
	}
}

static char *
operator_string(int op)
{
	/* XXX we don't bother freeing this, it's used for a fatal error
	 * anyways
	 */
	char *result = emalloc(5);
	char *t = result;
	if (op & OP_DEPENDS) {
		*t++ = ':';
	}
	if (op & OP_FORCE) {
		*t++ = '!';
	}
	if (op & OP_DOUBLEDEP) {
		*t++ = ':';
		*t++ = ':';
	}
	*t = 0;
	return result;
}

/*-
 *---------------------------------------------------------------------
 * ParseDoOp  --
 *	Apply the parsed operator to the given target node. Used in a
 *	Array_Find call by ParseDoDependency once all targets have
 *	been found and their operator parsed. If the previous and new
 *	operators are incompatible, a major error is taken.
 *
 * Side Effects:
 *	The type field of the node is altered to reflect any new bits in
 *	the op.
 *---------------------------------------------------------------------
 */
static int
ParseDoOp(GNode **gnp, unsigned int op)
{
	GNode *gn = *gnp;
	/*
	 * If the dependency mask of the operator and the node don't match and
	 * the node has actually had an operator applied to it before, and the
	 * operator actually has some dependency information in it, complain.
	 */
	if (((op & OP_OPMASK) != (gn->type & OP_OPMASK)) &&
	    !OP_NOP(gn->type) && !OP_NOP(op)) {
		Parse_Error(PARSE_FATAL, 
		    "Inconsistent dependency operator for target %s\n"
		    "\t(was %s%s, now %s%s)",
		    gn->name, gn->name, operator_string(gn->type), 
		    gn->name, operator_string(op));
		return 0;
	}

	if (op == OP_DOUBLEDEP && ((gn->type & OP_OPMASK) == OP_DOUBLEDEP)) {
		/* If the node was the object of a :: operator, we need to
		 * create a new instance of it for the children and commands on
		 * this dependency line. The new instance is placed on the
		 * 'cohorts' list of the initial one (note the initial one is
		 * not on its own cohorts list) and the new instance is linked
		 * to all parents of the initial instance.  */
		GNode *cohort;
		LstNode ln;

		cohort = Targ_NewGN(gn->name);
		/* Duplicate links to parents so graph traversal is simple.
		 * Perhaps some type bits should be duplicated?
		 *
		 * Make the cohort invisible as well to avoid duplicating it
		 * into other variables. True, parents of this target won't
		 * tend to do anything with their local variables, but better
		 * safe than sorry.  */
		for (ln = Lst_First(&gn->parents); ln != NULL; ln = Lst_Adv(ln))
			ParseLinkSrc(Lst_Datum(ln), cohort);
		cohort->type = OP_DOUBLEDEP|OP_INVISIBLE;
		Lst_AtEnd(&gn->cohorts, cohort);

		/* Replace the node in the targets list with the new copy */
		*gnp = cohort;
		gn = cohort;
	}
	/* We don't want to nuke any previous flags (whatever they were) so we
	 * just OR the new operator into the old.  */
	gn->type |= op;
	return 1;
}

/*-
 *---------------------------------------------------------------------
 * ParseAddDep	--
 *	Check if the pair of GNodes given needs to be synchronized.
 *	This has to be when two nodes are on different sides of a
 *	.WAIT directive.
 *
 * Results:
 *	Returns 0 if the two targets need to be ordered, 1 otherwise.
 *	If it returns 0, the search can stop.
 *
 * Side Effects:
 *	A dependency can be added between the two nodes.
 *
 *---------------------------------------------------------------------
 */
static int
ParseAddDep(GNode *p, GNode *s)
{
	if (p->order < s->order) {
		/* XXX: This can cause loops, and loops can cause unmade
		 * targets, but checking is tedious, and the debugging output
		 * can show the problem.  */
		Lst_AtEnd(&p->successors, s);
		Lst_AtEnd(&s->preds, p);
		return 1;
	} else
		return 0;
}

static void
apply_op(struct growableArray *targets, unsigned int op, GNode *gn)
{
	if (op)
		gn->type |= op;
	else
		Array_ForEach(targets, ParseLinkSrc, gn);
}

/*-
 *---------------------------------------------------------------------
 * ParseDoSrc  --
 *	Given the name of a source, figure out if it is an attribute
 *	and apply it to the targets if it is. Else decide if there is
 *	some attribute which should be applied *to* the source because
 *	of some special target and apply it if so. Otherwise, make the
 *	source be a child of the targets in the list 'targets'
 *
 * Side Effects:
 *	Operator bits may be added to the list of targets or to the source.
 *	The targets may have a new source added to their lists of children.
 *---------------------------------------------------------------------
 */
static void
ParseDoSrc(
    struct growableArray *targets,
    struct growableArray *sources,
    int 	tOp,	/* operator (if any) from special targets */
    const char	*src,	/* name of the source to handle */
    const char *esrc)
{
	GNode *gn = Targ_FindNodei(src, esrc, TARG_CREATE);
	if ((gn->special & SPECIAL_SOURCE) != 0) {
		if (gn->special_op) {
			Array_FindP(targets, ParseDoOp, gn->special_op);
			return;
		} else {
			assert((gn->special & SPECIAL_MASK) == SPECIAL_WAIT);
			waiting++;
			return;
		}
	}

	switch (specType) {
	case SPECIAL_MAIN:
		/*
		 * If we have noted the existence of a .MAIN, it means we need
		 * to add the sources of said target to the list of things
		 * to create.  Note that this will only be invoked if the user
		 * didn't specify a target on the command line. This is to
		 * allow #ifmake's to succeed, or something...
		 */
		Lst_AtEnd(create, gn->name);
		/*
		 * Add the name to the .TARGETS variable as well, so the user
		 * can employ that, if desired.
		 */
		Var_Append(".TARGETS", gn->name);
		return;

	case SPECIAL_ORDER:
		/*
		 * Create proper predecessor/successor links between the
		 * previous source and the current one.
		 */
		if (predecessor != NULL) {
			Lst_AtEnd(&predecessor->successors, gn);
			Lst_AtEnd(&gn->preds, predecessor);
		}
		predecessor = gn;
		break;

	default:
		/*
		 * In the case of a source that was the object of a :: operator,
		 * the attribute is applied to all of its instances (as kept in
		 * the 'cohorts' list of the node) or all the cohorts are linked
		 * to all the targets.
		 */
		apply_op(targets, tOp, gn);
		if ((gn->type & OP_OPMASK) == OP_DOUBLEDEP) {
			LstNode	ln;

			for (ln=Lst_First(&gn->cohorts); ln != NULL;
			    ln = Lst_Adv(ln)){
			    	apply_op(targets, tOp, Lst_Datum(ln));
			}
		}
		break;
	}

	gn->order = waiting;
	Array_AtEnd(sources, gn);
	if (waiting)
		Array_Find(sources, ParseAddDep, gn);
}

/*-
 *-----------------------------------------------------------------------
 * ParseFindMain --
 *	Find a real target in the list and set it to be the main one.
 *	Called by ParseDoDependency when a main target hasn't been found
 *	yet.
 *
 * Results:
 *	1 if main not found yet, 0 if it is.
 *
 * Side Effects:
 *	mainNode is changed and.
 *-----------------------------------------------------------------------
 */
static int
ParseFindMain(void *gnp, void *dummy UNUSED)
{
	GNode *gn = gnp;

	if ((gn->type & OP_NOTARGET) == 0 && gn->special == SPECIAL_NONE) {
		mainNode = gn;
		return 0;
	} else {
		return 1;
	}
}

/*-
 *-----------------------------------------------------------------------
 * ParseClearPath --
 *	Reinit path to an empty path
 *-----------------------------------------------------------------------
 */
static void
ParseClearPath(void *p)
{
	Lst path = p;

	Lst_Destroy(path, Dir_Destroy);
	Lst_Init(path);
}

static void
add_target_node(const char *line, const char *end)
{
	GNode *gn;

	gn = Suff_ParseAsTransform(line, end);

	if (gn == NULL) {
		gn = Targ_FindNodei(line, end, TARG_CREATE);
		gn->type &= ~OP_DUMMY;
	}

	Array_AtEnd(&gtargets, gn);
}

static void
add_target_nodes(const char *line, const char *end)
{

	if (Dir_HasWildcardsi(line, end)) {
		/*
		 * Targets are to be sought only in the current directory,
		 * so create an empty path for the thing. Note we need to
		 * use Dir_Destroy in the destruction of the path as the
		 * Dir module could have added a directory to the path...
		 */
		char *targName;
		LIST emptyPath;
		LIST curTargs;

		Lst_Init(&emptyPath);
		Lst_Init(&curTargs);
		Dir_Expandi(line, end, &emptyPath, &curTargs);
		Lst_Destroy(&emptyPath, Dir_Destroy);
		while ((targName = Lst_DeQueue(&curTargs)) != NULL) {
			add_target_node(targName, targName + strlen(targName));
		}
		Lst_Destroy(&curTargs, NOFREE);
	} else {
		add_target_node(line, end);
	}
}

/* special target line check: a proper delimiter is a ':' or '!', but
 * we don't want to end a target on such a character if there is a better
 * match later on.
 * By "better" I mean one that is followed by whitespace. This allows the
 * user to have targets like:
 *    fie::fi:fo: fum
 * where "fie::fi:fo" is the target.  In real life this is used for perl5
 * library man pages where "::" separates an object from its class.  Ie:
 * "File::Spec::Unix".
 * This behaviour is also consistent with other versions of make.
 */
static bool
found_delimiter(const char *s)
{
	if (*s == '!' || *s == ':') {
		const char *p = s + 1;

		if (*s == ':' && *p == ':')
			p++;

		/* Found the best match already. */
		if (ISSPACE(*p) || *p == '\0')
			return true;

		do {
			p += strcspn(p, "!:");
			if (*p == '\0')
			    break;
			p++;
		} while (!ISSPACE(*p));

		/* No better match later on... */
		if (*p == '\0')
			return true;
	}
	return false;
}

static const char *
parse_do_targets(Lst paths, unsigned int *op, const char *line)
{
	const char *cp;

	do {
		for (cp = line; *cp && !ISSPACE(*cp) && *cp != '(';) {
			if (*cp == '$')
				/* Must be a dynamic source (would have been
				 * expanded otherwise), so call the Var module
				 * to parse the puppy so we can safely advance
				 * beyond it...There should be no errors in
				 * this, as they would have been discovered in
				 * the initial Var_Subst and we wouldn't be
				 * here.  */
				Var_ParseSkip(&cp, NULL);
			else {
				if (found_delimiter(cp))
					break;
				cp++;
			}
		}

		if (*cp == '(') {
			LIST temp;
			Lst_Init(&temp);
			/* Archives must be handled specially to make sure the
			 * OP_ARCHV flag is set in their 'type' field, for one
			 * thing, and because things like "archive(file1.o
			 * file2.o file3.o)" are permissible.
			 * Arch_ParseArchive will set 'line' to be the first
			 * non-blank after the archive-spec. It creates/finds
			 * nodes for the members and places them on the given
			 * list, returning true if all went well and false if
			 * there was an error in the specification. On error,
			 * line should remain untouched.  */
			if (!Arch_ParseArchive(&line, &temp, NULL)) {
				Parse_Error(PARSE_FATAL,
				     "Error in archive specification: \"%s\"",
				     line);
				return NULL;
			} else {
				AppendList2Array(&temp, &gtargets);
				Lst_Destroy(&temp, NOFREE);
				cp = line;
				continue;
			}
		}
		if (*cp == '\0') {
			/* Ending a dependency line without an operator is a
			 * Bozo no-no */
			/* Deeper check for cvs conflicts */
			if (gtargets.n > 0 &&
			    (strcmp(gtargets.a[0]->name, "<<<<<<<") == 0 ||
			    strcmp(gtargets.a[0]->name, ">>>>>>>") == 0)) {
			    	Parse_Error(PARSE_FATAL,
    "Need an operator (likely from a cvs update conflict)");
			} else {
				Parse_Error(PARSE_FATAL, 
				    "Need an operator in '%s'", line);
			}
			return NULL;
		}
		/*
		 * Have word in line. Get or create its nodes and stick it at
		 * the end of the targets list
		 */
	    	if (*line != '\0')
			add_target_nodes(line, cp);

		while (ISSPACE(*cp))
			cp++;
		line = cp;
	} while (*line != '!' && *line != ':' && *line);
	*op = handle_special_targets(paths);
	return cp;
}

static void
dump_targets()
{
	size_t i;
	for (i = 0; i < gtargets.n; i++)
		fprintf(stderr, "%s", gtargets.a[i]->name);
	fprintf(stderr, "\n");
}

static unsigned int
handle_special_targets(Lst paths)
{
	size_t i;
	int seen_path = 0;
	int seen_special = 0;
	int seen_normal = 0;
	int type;

	for (i = 0; i < gtargets.n; i++) {
		type = gtargets.a[i]->special;
		if ((type & SPECIAL_MASK) == SPECIAL_PATH) {
			seen_path++;
			Lst_AtEnd(paths, find_suffix_path(gtargets.a[i]));
		} else if ((type & SPECIAL_TARGET) != 0)
			seen_special++;
		else
			seen_normal++;
	}
	if ((seen_path != 0) + (seen_special != 0) + (seen_normal != 0) > 1) {
		Parse_Error(PARSE_FATAL, "Wrong mix of special targets");
		dump_targets();
		specType = SPECIAL_ERROR;
		return 0;
	}
	if (seen_normal != 0) {
		specType = SPECIAL_NONE;
		return 0;
	} else if (seen_path != 0) {
		specType = SPECIAL_PATH;
		return 0;
	} else if (seen_special == 0) {
		specType = SPECIAL_NONE;
		return 0;
	} else if (seen_special != 1) {
		Parse_Error(PARSE_FATAL,
		    "Mixing special targets is not allowed");
		dump_targets();
		return 0;
	} else if (seen_special == 1) {
		specType = gtargets.a[0]->special & SPECIAL_MASK;
		switch (specType) {
		case SPECIAL_MAIN:
			if (!Lst_IsEmpty(create)) {
				specType = SPECIAL_NONE;
			}
			break;
		case SPECIAL_NOTPARALLEL:
		{
			extern int  maxJobs;

			maxJobs = 1;
			compatMake = 1;
			break;
		}
		case SPECIAL_ORDER:
			predecessor = NULL;
			break;
		default:
			break;
		}
		return gtargets.a[0]->special_op;
	} else {
		/* we're allowed to have 0 target */
		specType = SPECIAL_NONE;
		return 0;
	}
}

static unsigned int
parse_operator(const char **pos)
{
	const char *cp = *pos;
	unsigned int op = OP_ERROR;

	if (*cp == '!') {
		op = OP_FORCE;
	} else if (*cp == ':') {
		if (cp[1] == ':') {
			op = OP_DOUBLEDEP;
			cp++;
		} else {
			op = OP_DEPENDS;
		}
	} else {
		Parse_Error(PARSE_FATAL, "Missing dependency operator");
		return OP_ERROR;
	}

	cp++;			/* Advance beyond operator */

	/* Get to the first source */
	while (ISSPACE(*cp))
		cp++;
	*pos = cp;
	return op;
}

/*-
 *---------------------------------------------------------------------
 * ParseDoDependency  --
 *	Parse the dependency line in line.
 *
 * Side Effects:
 *	The nodes of the sources are linked as children to the nodes of the
 *	targets. Some nodes may be created.
 *
 *	We parse a dependency line by first extracting words from the line and
 * finding nodes in the list of all targets with that name. This is done
 * until a character is encountered which is an operator character. Currently
 * these are only ! and :. At this point the operator is parsed and the
 * pointer into the line advanced until the first source is encountered.
 *	The parsed operator is applied to each node in the 'targets' list,
 * which is where the nodes found for the targets are kept, by means of
 * the ParseDoOp function.
 *	The sources are read in much the same way as the targets were except
 * that now they are expanded using the wildcarding scheme of the C-Shell
 * and all instances of the resulting words in the list of all targets
 * are found. Each of the resulting nodes is then linked to each of the
 * targets as one of its children.
 *	Certain targets are handled specially. These are the ones detailed
 * by the specType variable.
 *	The storing of transformation rules is also taken care of here.
 * A target is recognized as a transformation rule by calling
 * Suff_IsTransform. If it is a transformation rule, its node is gotten
 * from the suffix module via Suff_AddTransform rather than the standard
 * Targ_FindNode in the target module.
 *---------------------------------------------------------------------
 */
static void
ParseDoDependency(const char *line)	/* the line to parse */
{
	const char *cp; 	/* our current position */
	unsigned int op; 	/* the operator on the line */
	LIST paths;		/* List of search paths to alter when parsing
			 	* a list of .PATH targets */
	unsigned int tOp;		/* operator from special target */

	waiting = 0;
	Lst_Init(&paths);

	Array_Reset(&gsources);

	cp = parse_do_targets(&paths, &tOp, line);
	if (cp == NULL || specType == SPECIAL_ERROR) {
		/* invalidate targets for further processing */
		Array_Reset(&gtargets); 
		return;
	}

	op = parse_operator(&cp);
	if (op == OP_ERROR) {
		/* invalidate targets for further processing */
		Array_Reset(&gtargets); 
		return;
	}

	Array_FindP(&gtargets, ParseDoOp, op);
	dedup_targets(&gtargets);

	line = cp;

	/*
	 * Several special targets take different actions if present with no
	 * sources:
	 *	a .SUFFIXES line with no sources clears out all old suffixes
	 *	a .PRECIOUS line makes all targets precious
	 *	a .IGNORE line ignores errors for all targets
	 *	a .SILENT line creates silence when making all targets
	 *	a .PATH removes all directories from the search path(s).
	 */
	if (!*line) {
		switch (specType) {
		case SPECIAL_SUFFIXES:
			Suff_ClearSuffixes();
			break;
		case SPECIAL_PRECIOUS:
			allPrecious = true;
			break;
		case SPECIAL_IGNORE:
			ignoreErrors = true;
			break;
		case SPECIAL_SILENT:
			beSilent = true;
			break;
		case SPECIAL_PATH:
			Lst_Every(&paths, ParseClearPath);
			break;
		default:
			break;
		}
	} else if (specType == SPECIAL_MFLAGS) {
		/* Call on functions in main.c to deal with these arguments */
		Main_ParseArgLine(line);
		return;
	} else if (specType == SPECIAL_NOTPARALLEL) {
		return;
	}

	/*
	 * NOW GO FOR THE SOURCES
	 */
	if (specType == SPECIAL_SUFFIXES || specType == SPECIAL_PATH ||
	    specType == SPECIAL_NOTHING) {
		while (*line) {
		    /*
		     * If the target was one that doesn't take files as its
		     * sources but takes something like suffixes, we take each
		     * space-separated word on the line as a something and deal
		     * with it accordingly.
		     *
		     * If the target was .SUFFIXES, we take each source as a
		     * suffix and add it to the list of suffixes maintained by
		     * the Suff module.
		     *
		     * If the target was a .PATH, we add the source as a
		     * directory to search on the search path.
		     *
		     * If it was .INCLUDES, the source is taken to be the
		     * suffix of files which will be #included and whose search
		     * path should be present in the .INCLUDES variable.
		     *
		     * If it was .LIBS, the source is taken to be the suffix of
		     * files which are considered libraries and whose search
		     * path should be present in the .LIBS variable.
		     *
		     * If it was .NULL, the source is the suffix to use when a
		     * file has no valid suffix.
		     */
		    while (*cp && !ISSPACE(*cp))
			    cp++;
		    switch (specType) {
		    case SPECIAL_SUFFIXES:
			    Suff_AddSuffixi(line, cp);
			    break;
		    case SPECIAL_PATH:
			    {
			    LstNode ln;

			    for (ln = Lst_First(&paths); ln != NULL;
			    	ln = Lst_Adv(ln))
				    Dir_AddDiri(Lst_Datum(ln), line, cp);
			    break;
			    }
		    default:
			    break;
		    }
		    if (*cp != '\0')
			cp++;
		    while (ISSPACE(*cp))
			cp++;
		    line = cp;
		}
		Lst_Destroy(&paths, NOFREE);
	} else {
		while (*line) {
			/*
			 * The targets take real sources, so we must beware of
			 * archive specifications (i.e. things with left
			 * parentheses in them) and handle them accordingly.
			 */
			while (*cp && !ISSPACE(*cp)) {
				if (*cp == '(' && cp > line && cp[-1] != '$') {
					/*
					 * Only stop for a left parenthesis if
					 * it isn't at the start of a word
					 * (that'll be for variable changes
					 * later) and isn't preceded by a
					 * dollar sign (a dynamic source).
					 */
					break;
				} else {
					cp++;
				}
			}

			if (*cp == '(') {
				GNode *gn;
				LIST sources;	/* list of archive source
						 * names after expansion */

				Lst_Init(&sources);
				if (!Arch_ParseArchive(&line, &sources, NULL)) {
					Parse_Error(PARSE_FATAL,
					    "Error in source archive spec \"%s\"",
					    line);
					return;
				}

				while ((gn = Lst_DeQueue(&sources)) != NULL)
					ParseDoSrc(&gtargets, &gsources, tOp,
					    gn->name, NULL);
				cp = line;
			} else {
				const char *endSrc = cp;

				ParseDoSrc(&gtargets, &gsources, tOp, line,
				    endSrc);
				if (*cp)
					cp++;
			}
			while (ISSPACE(*cp))
				cp++;
			line = cp;
		}
	}

	if (mainNode == NULL) {
		/* If we have yet to decide on a main target to make, in the
		 * absence of any user input, we want the first target on
		 * the first dependency line that is actually a real target
		 * (i.e. isn't a .USE or .EXEC rule) to be made.  */
		Array_Find(&gtargets, ParseFindMain, NULL);
	}
}

/*-
 * ParseAddCmd	--
 *	Lst_ForEach function to add a command line to all targets
 *
 *	The new command may be added to the commands list of the node.
 *
 * 	If the target already had commands, we ignore the new ones, but 
 *	we note that we got double commands (in case we actually get to run 
 *	that ambiguous target).
 *
 *	Note this does not apply to :: dependency lines, since those 
 *	will generate fresh cloned nodes and add them to the cohorts
 *	field of the main node.
 */
static void
ParseAddCmd(void *gnp, void *cmd)
{
	GNode *gn = gnp;

	if (!(gn->type & OP_HAS_COMMANDS))
		Lst_AtEnd(&gn->commands, cmd);
	else
		gn->type |= OP_DOUBLE;
}

/*-
 *-----------------------------------------------------------------------
 * ParseHasCommands --
 *	Record that the target gained commands through OP_HAS_COMMANDS,
 *	so that double command lists may be ignored.
 *-----------------------------------------------------------------------
 */
static void
ParseHasCommands(void *gnp)
{
	GNode *gn = gnp;
	gn->type |= OP_HAS_COMMANDS;

}


/* Strip comments from line. Build a copy in buffer if necessary, */
static char *
strip_comments(Buffer copy, const char *line)
{
	const char *comment;
	const char *p;

	comment = strchr(line, '#');
	assert(comment != line);
	if (comment == NULL)
		return (char *)line;
	else {
		Buf_Reset(copy);

		for (p = line; *p != '\0'; p++) {
			if (*p == '\\') {
				if (p[1] == '#') {
					Buf_Addi(copy, line, p);
					Buf_AddChar(copy, '#');
					line = p+2;
				}
				if (p[1] != '\0')
					p++;
			} else if (*p == '#')
				break;
		}
		Buf_Addi(copy, line, p);
		return Buf_Retrieve(copy);
	}
}



/***
 *** Support for various include constructs
 ***/


void
Parse_AddIncludeDir(const char	*dir)
{
	Dir_AddDir(userIncludePath, dir);
}

static char *
resolve_include_filename(const char *file, const char *efile, bool isSystem)
{
	char *fullname;

	/* Look up system files on the system path first */
	if (isSystem) {
		fullname = Dir_FindFileNoDoti(file, efile, systemIncludePath);
		if (fullname)
			return fullname;
	}

	/* Handle non-system non-absolute files... */
	if (!isSystem && file[0] != '/') {
		/* ... by looking first under the same directory as the
		 * current file */
		char *slash = NULL;
		const char *fname;

		fname = Parse_Getfilename();

		if (fname != NULL)
			slash = strrchr(fname, '/');

		if (slash != NULL) {
			char *newName;

			newName = Str_concati(fname, slash, file, efile, '/');
			fullname = Dir_FindFile(newName, userIncludePath);
			if (fullname == NULL)
				fullname = Dir_FindFile(newName, defaultPath);
			free(newName);
			if (fullname)
				return fullname;
		}
	}

	/* Now look first on the -I search path, then on the .PATH
	 * search path, if not found in a -I directory.
	 * XXX: Suffix specific?  */
	fullname = Dir_FindFilei(file, efile, userIncludePath);
	if (fullname)
		return fullname;
	fullname = Dir_FindFilei(file, efile, defaultPath);
	if (fullname)
		return fullname;

	/* Still haven't found the makefile. Look for it on the system
	 * path as a last resort (if we haven't already). */
	if (isSystem)
		return NULL;
	else
		return Dir_FindFilei(file, efile, systemIncludePath);
}

static void
handle_include_file(const char *file, const char *efile, bool isSystem,
    bool errIfNotFound)
{
	char *fullname;

	fullname = resolve_include_filename(file, efile, isSystem);
	if (fullname == NULL && errIfNotFound)
		Parse_Error(PARSE_FATAL, "Could not find %.*s", 
		    (int)(efile - file), file);

	if (fullname != NULL) {
		FILE *f;

		f = fopen(fullname, "r");
		if (f == NULL && errIfNotFound)
			Parse_Error(PARSE_FATAL, "Cannot open %s", fullname);
		else
			Parse_FromFile(fullname, f);
	}
}

/* .include <file> (system) or .include "file" (normal) */
static bool
lookup_bsd_include(const char *file)
{
	char endc;
	const char *efile;
	char *file2;
	bool isSystem;

	/* find starting delimiter */
	while (ISSPACE(*file))
		file++;

	/* determine type of file */
	if (*file == '<') {
		isSystem = true;
		endc = '>';
	} else if (*file == '"') {
		isSystem = false;
		endc = '"';
	} else {
		Parse_Error(PARSE_WARNING,
		    ".include filename must be delimited by '\"' or '<'");
		return false;
	}

	/* delimit file name between file and efile */
	for (efile = ++file; *efile != endc; efile++) {
		if (*efile == '\0') {
			Parse_Error(PARSE_WARNING,
			     "Unclosed .include filename. '%c' expected", endc);
			return false;
		}
	}
	/* Substitute for any variables in the file name before trying to
	 * find the thing. */
	file2 = Var_Substi(file, efile, NULL, false);
	handle_include_file(file2, strchr(file2, '\0'), isSystem, true);
	free(file2);
	return true;
}


static void
lookup_sysv_style_include(const char *line, const char *directive,
    bool errIfMissing)
{
	char *file;
	char *name;
	char *ename;
	bool okay = false;

	/* Substitute for any variables in the file name before trying to
	 * find the thing. */
	file = Var_Subst(line, NULL, false);

	/* sys5 allows for list of files separated by spaces */
	name = file;
	while (1) {
		/* find beginning of name */
		while (ISSPACE(*name))
			name++;
		if (*name == '\0')
			break;
		for (ename = name; *ename != '\0' && !ISSPACE(*ename);)
			ename++;
		handle_include_file(name, ename, true, errIfMissing);
		okay = true;
		name = ename;
	}

	free(file);
	if (!okay) {
		Parse_Error(PARSE_FATAL, "Filename missing from \"%s\"",
		directive);
	}
}


/* system V construct:  include file */
static void
lookup_sysv_include(const char *file, const char *directive)
{
	lookup_sysv_style_include(file, directive, true);
}


/* sinclude file and -include file */
static void
lookup_conditional_include(const char *file, const char *directive)
{
	lookup_sysv_style_include(file, directive, false);
}


/***
 ***   BSD-specific . constructs
 ***   They all follow the same pattern:
 ***    if the syntax matches BSD stuff, then we're committed to handle
 ***   them and report fatal errors (like, include file not existing)
 ***    otherwise, we return false, and hope somebody else will handle it.
 ***/

static bool
handle_poison(const char *line)
{
	const char *p = line;
	int type = POISON_NORMAL;
	bool not = false;
	bool paren_to_match = false;
	const char *name, *ename;

	while (ISSPACE(*p))
		p++;
	if (*p == '!') {
		not = true;
		p++;
	}
	while (ISSPACE(*p))
		p++;
	if (strncmp(p, "defined", 7) == 0) {
		type = POISON_DEFINED;
		p += 7;
	} else if (strncmp(p, "empty", 5) == 0) {
		type = POISON_EMPTY;
		p += 5;
	}
	while (ISSPACE(*p))
		p++;
	if (*p == '(') {
		paren_to_match = true;
		p++;
	}
	while (ISSPACE(*p))
		p++;
	name = ename = p;
	while (*p != '\0' && !ISSPACE(*p)) {
		if (*p == ')' && paren_to_match) {
			paren_to_match = false;
			p++;
			break;
		}
		p++;
		ename = p;
	}
	while (ISSPACE(*p))
		p++;
	switch(type) {
	case POISON_NORMAL:
	case POISON_EMPTY:
		if (not)
			type = POISON_INVALID;
		break;
	case POISON_DEFINED:
		if (not)
			type = POISON_NOT_DEFINED;
		else
			type = POISON_INVALID;
		break;
	}
	if ((*p != '\0' && *p != '#') || type == POISON_INVALID) {
		Parse_Error(PARSE_WARNING, "Invalid syntax for .poison: %s",
		    line);
		return false;
	} else {
		Var_Mark(name, ename, type);
		return true;
	}
}


static bool
handle_for_loop(Buffer linebuf, const char *line)
{
	For *loop;

	loop = For_Eval(line);
	if (loop != NULL) {
		bool ok;
		do {
			/* Find the matching endfor.  */
			line = ParseReadLoopLine(linebuf);
			if (line == NULL) {
			    Parse_Error(PARSE_FATAL,
				 "Unexpected end of file in for loop.\n");
			    return false;
			}
			ok = For_Accumulate(loop, line);
		} while (ok);
		For_Run(loop);
		return true;
	} else
		return false;
}

static bool
handle_undef(const char *line)
{
	const char *eline;

	while (ISSPACE(*line))
		line++;
	for (eline = line; !ISSPACE(*eline) && *eline != '\0';)
		eline++;
	Var_Deletei(line, eline);
	return true;
}

/* global hub for the construct */
static bool
handle_bsd_command(Buffer linebuf, Buffer copy, const char *line)
{
	char *stripped;

	while (ISSPACE(*line))
		line++;

	/* delegate basic classification to the conditional module */
	switch (Cond_Eval(line)) {
	case COND_SKIP:
		/* Skip to next conditional that evaluates to COND_PARSE.  */
		do {
			line = Parse_ReadNextConditionalLine(linebuf);
			if (line != NULL) {
				while (ISSPACE(*line))
					line++;
					stripped = strip_comments(copy, line);
			}
		} while (line != NULL && Cond_Eval(stripped) != COND_PARSE);
		/* FALLTHROUGH */
	case COND_PARSE:
		return true;
	case COND_ISFOR:
		return handle_for_loop(linebuf, line + 3);
	case COND_ISINCLUDE:
		return lookup_bsd_include(line + 7);
	case COND_ISPOISON:
		return handle_poison(line + 6);
	case COND_ISUNDEF:
		return handle_undef(line + 5);
	default:
		break;
	}

	return false;
}

/* postprocess group of targets prior to linking stuff with them */
static bool 
register_target(GNode *gn, struct ohash *t)
{
	unsigned int slot;
	uint32_t hv;
	const char *ename = NULL;
	GNode *gn2;

	hv = ohash_interval(gn->name, &ename);

	slot = ohash_lookup_interval(t, gn->name, ename, hv);
	gn2 = ohash_find(t, slot);

	if (gn2 == NULL) {
		ohash_insert(t, slot, gn);
		return true;
	} else
		return false;
}

static void
build_target_group(struct growableArray *targets, struct ohash *t)
{
	LstNode ln;
	bool seen_target = false;
	unsigned int i;

	/* may be 0 if wildcard expansion resulted in zero match */
	if (targets->n <= 1)
		return;

	/* Perform checks to see if we must tie targets together */
	/* XXX */
	if (targets->a[0]->type & OP_TRANSFORM)
		return;

	for (ln = Lst_First(&targets->a[0]->commands); ln != NULL; 
	    ln = Lst_Adv(ln)) {
	    	struct command *cmd = Lst_Datum(ln);
		if (Var_Check_for_target(cmd->string)) {
			seen_target = true;
			break;
		}
	}
	if (DEBUG(TARGGROUP)) {
		fprintf(stderr, 
		    seen_target ? "No target group at %lu: ": 
		    "Target group at %lu:", Parse_Getlineno());
		for (i = 0; i < targets->n; i++)
			fprintf(stderr, " %s", targets->a[i]->name);
		fprintf(stderr, "\n");
	}
	if (seen_target)
		return;

	GNode *gn, *gn2;
	/* targets may already participate in groupling lists, 
	 * so rebuild the circular list "from scratch"
	 */

	for (i = 0; i < targets->n; i++) {
		gn = targets->a[i];
		for (gn2 = gn->groupling; gn2 != gn; gn2 = gn2->groupling) {	
			if (!gn2)
				break;
		    	register_target(gn2, t);
		}
	}

	for (gn = ohash_first(t, &i); gn != NULL; gn = ohash_next(t, &i)) {
		gn->groupling = gn2;
		gn2 = gn;
	}
	gn = ohash_first(t, &i);
	gn->groupling = gn2;
}

static void
reset_target_hash()
{
	if (htargets_setup)
		ohash_delete(&htargets);
	ohash_init(&htargets, 5, &gnode_info);
	htargets_setup = true;
}

void
Parse_End()
{
	if (htargets_setup)
		ohash_delete(&htargets);
}

static void
dedup_targets(struct growableArray *targets)
{
	unsigned int i, j;

	if (targets->n <= 1)
		return;

	reset_target_hash();
	/* first let's de-dup the list */
	for (i = 0, j = 0; i < targets->n; i++) {
		GNode *gn = targets->a[i];
		if (register_target(gn, &htargets))
			targets->a[j++] = targets->a[i];
	}
	targets->n = j;
}


/***
 *** handle a group of commands
 ***/

static void
finish_commands(struct growableArray *targets)
{
	build_target_group(targets, &htargets);
	Array_Every(targets, ParseHasCommands);
}

static void
parse_commands(struct growableArray *targets, const char *line)
{
	/* add the command to the list of
	 * commands of all targets in the dependency spec */

	struct command *cmd;
	size_t len = strlen(line);

	cmd = emalloc(sizeof(struct command) + len);
	memcpy(&cmd->string, line, len+1);
	Parse_FillLocation(&cmd->location);

	Array_ForEach(targets, ParseAddCmd, cmd);
}

static bool
parse_as_special_line(Buffer buf, Buffer copy, const char *line)
{
	if (*line == '.' && handle_bsd_command(buf, copy, line+1))
		return true;
	if (FEATURES(FEATURE_SYSVINCLUDE) &&
	    strncmp(line, "include", 7) == 0 &&
	    ISSPACE(line[7]) &&
	    strchr(line, ':') == NULL) {
	    /* It's an S3/S5-style "include".  */
		lookup_sysv_include(line + 7, "include");
		return true;
	}
	if (FEATURES(FEATURE_CONDINCLUDE) &&
	    strncmp(line, "sinclude", 8) == 0 &&
	    ISSPACE(line[8]) &&
	    strchr(line, ':') == NULL) {
		lookup_conditional_include(line+8, "sinclude");
		return true;
	}
	if (FEATURES(FEATURE_CONDINCLUDE) &&
	    strncmp(line, "-include", 8) == 0 &&
	    ISSPACE(line[8]) &&
	    strchr(line, ':') == NULL) {
		lookup_conditional_include(line+8, "-include");
		return true;
	}
	return false;
}

static void
parse_target_line(struct growableArray *targets, const char *line,
    const char *stripped, bool *pcommands_seen)
{
	size_t pos;
	char *end;
	char *cp;
	char *cmd;

	/* let's start a new set of commands */
	Array_Reset(targets);

	/* XXX this is a dirty heuristic to handle target: dep ; commands */
	cmd = NULL;
	/* First we need to find eventual dependencies */
	pos = strcspn(stripped, ":!");
	/* go over :!, and find ;  */
	if (stripped[pos] != '\0' &&
	    (end = strchr(stripped+pos+1, ';')) != NULL) {
		if (line != stripped)
			/* find matching ; in original... The
			 * original might be slightly longer.  */
			cmd = strchr(line+(end-stripped), ';');
		else
			cmd = end;
		/* kill end of line. */
		*end = '\0';
	}
	/* We now know it's a dependency line so it needs to
	 * have all variables expanded before being parsed.
	 */
	cp = Var_Subst(stripped, NULL, false);
	ParseDoDependency(cp);
	free(cp);

	/* Parse command if it's not empty. */
	if (cmd != NULL) {
		do {
			cmd++;
		} while (ISSPACE(*cmd));
		if (*cmd != '\0') {
			parse_commands(targets, cmd);
			*pcommands_seen = true;
		}
	}
}

void
Parse_File(const char *filename, FILE *stream)
{
	char *line;
	bool expectingCommands = false;
	bool commands_seen = false;

	/* somewhat permanent spaces to shave time */
	BUFFER buf;
	BUFFER copy;

	Buf_Init(&buf, MAKE_BSIZE);
	Buf_Init(&copy, MAKE_BSIZE);

	Parse_FromFile(filename, stream);
	do {
		while ((line = Parse_ReadNormalLine(&buf)) != NULL) {
			if (*line == '\t') {
				if (expectingCommands) {
					commands_seen = true;
					parse_commands(&gtargets, line+1);
				} else
					Parse_Error(PARSE_FATAL,
					    "Unassociated shell command \"%s\"",
					     line);
			} else {
				const char *stripped = strip_comments(&copy,
				    line);
				if (!parse_as_special_line(&buf, &copy,
				    stripped)) {
				    	if (commands_seen)
						finish_commands(&gtargets);
					commands_seen = false;
					if (Parse_As_Var_Assignment(stripped))
						expectingCommands = false;
					else {
						parse_target_line(&gtargets,
						    line, stripped, 
						    &commands_seen);
						expectingCommands = true;
					}
				}
			}
		}
	} while (Parse_NextFile());

	if (commands_seen)
		finish_commands(&gtargets);
	/* Make sure conditionals are clean.  */
	Cond_End();

	Parse_ReportErrors();
	Buf_Destroy(&buf);
	Buf_Destroy(&copy);
}

void
Parse_Init(void)
{
	mainNode = NULL;
	Static_Lst_Init(userIncludePath);
	Static_Lst_Init(systemIncludePath);
	Array_Init(&gtargets, TARGETS_SIZE);
    	Array_Init(&gsources, SOURCES_SIZE);
	create_special_nodes();
}

void
Parse_MainName(Lst listmain)	/* result list */
{
	if (mainNode == NULL) {
		Punt("no target to make.");
		/*NOTREACHED*/
	} else if (mainNode->type & OP_DOUBLEDEP) {
		Lst_AtEnd(listmain, mainNode);
		Lst_Concat(listmain, &mainNode->cohorts);
	}
	else
		Lst_AtEnd(listmain, mainNode);
}
@


1.117
log
@small obvious cleanups:
- remove a lot of unnecessary casts
- zap extra param that's no longer needed
- add proper prototype and make function static

okay natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.116 2016/05/13 12:18:11 espie Exp $	*/
d1324 1
a1324 1
		Var_MarkPoisoned(name, ename, type);
@


1.116
log
@have sinclude/include be more compatible with sysv, handle list of files

small improvement and okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.115 2015/12/22 21:50:54 espie Exp $	*/
d151 1
d330 1
a330 1
			ParseLinkSrc((GNode *)Lst_Datum(ln), cohort);
d459 1
a459 2
			    	apply_op(targets, tOp,
				    (GNode *)Lst_Datum(ln));
d547 1
a547 1
		while ((targName = (char *)Lst_DeQueue(&curTargs)) != NULL) {
d922 1
a922 1
				    Dir_AddDiri((Lst)Lst_Datum(ln), line, cp);
d970 1
a970 2
				while ((gn = (GNode *)Lst_DeQueue(&sources)) !=
				    NULL)
d1407 1
a1407 1
bool 
@


1.115
log
@in case we have a parse error, dispell the target list early to avoid
various problems.

Problem noticed by jsg@@, deeper patch than he suggested

okay jsg@@ and tb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.114 2015/11/29 09:17:12 espie Exp $	*/
d152 1
a152 1
static char *resolve_include_filename(const char *, bool);
d1084 1
a1084 1
resolve_include_filename(const char *file, bool isSystem)
d1090 1
a1090 1
		fullname = Dir_FindFileNoDot(file, systemIncludePath);
d1110 1
a1110 2
			newName = Str_concati(fname, slash, file,
			    strchr(file, '\0'), '/');
d1123 1
a1123 1
	fullname = Dir_FindFile(file, userIncludePath);
d1126 1
a1126 1
	fullname = Dir_FindFile(file, defaultPath);
d1135 1
a1135 1
		return Dir_FindFile(file, systemIncludePath);
d1139 1
a1139 1
handle_include_file(const char *name, const char *ename, bool isSystem,
a1141 1
	char *file;
d1144 1
a1144 5
	/* Substitute for any variables in the file name before trying to
	 * find the thing. */
	file = Var_Substi(name, ename, NULL, false);

	fullname = resolve_include_filename(file, isSystem);
d1146 2
a1147 3
		Parse_Error(PARSE_FATAL, "Could not find %s", file);
	free(file);

d1166 1
d1194 5
a1198 1
	handle_include_file(file, efile, isSystem, true);
d1204 1
a1204 1
lookup_sysv_style_include(const char *file, const char *directive,
d1207 23
a1229 1
	const char *efile;
d1231 2
a1232 4
	/* find beginning of name */
	while (ISSPACE(*file))
		file++;
	if (*file == '\0') {
d1234 1
a1234 2
		    directive);
		return;
a1235 5
	/* sys5 delimits file up to next blank character or end of line */
	for (efile = file; *efile != '\0' && !ISSPACE(*efile);)
		efile++;

	handle_include_file(file, efile, true, errIfMissing);
@


1.114
log
@fix duplicate targets in target list for good: split previous groupling fix
in two. Catch 22: we have to dedup targets very early so that commands get
attached correctly, but we can't figure out the grouplings heuristics until
we have all commands...

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.113 2015/11/06 18:41:02 espie Exp $	*/
d825 3
a827 1
	if (cp == NULL || specType == SPECIAL_ERROR)
d829 1
d832 3
a834 1
	if (op == OP_ERROR)
d836 1
@


1.113
log
@I was very optimistic in groupling creation. Turns out lists of targets
can have duplicates, or overlap, or even be empty thanks to fnmatch.

So use the big guns to build the circular list correctly, namely
actual lists of targets that are made together will be registered in a
hash first, then we recreate the full list from there.

(merging lists is not an issue, since groupling links are only used to
temporarily lock targets in parallel mode).

Issue noticed by guenther@@, okay guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.112 2015/01/23 22:35:57 espie Exp $	*/
d103 2
d171 3
a818 1

d833 1
d1389 3
a1391 6
/***
 *** handle a group of commands
 ***/

static void
register_for_groupling(GNode *gn, struct ohash *temp)
d1400 2
a1401 2
	slot = ohash_lookup_interval(temp, gn->name, ename, hv);
	gn2 = ohash_find(temp, slot);
d1403 5
a1407 2
	if (gn2 == NULL)
		ohash_insert(temp, slot, gn);
d1411 1
a1411 1
build_target_group(struct growableArray *targets)
d1420 2
d1425 1
d1445 3
a1447 2
	/* target list MAY hold duplicates AND targets may already participate
	 * in groupling lists, so rebuild the circular list "from scratch"
a1449 5
	struct ohash t;
	GNode *gn, *gn2;

	ohash_init(&t, 5, &gnode_info);

a1451 1
		register_for_groupling(gn, &t);
d1455 1
a1455 1
		    	register_for_groupling(gn2, &t);
d1459 1
a1459 1
	for (gn = ohash_first(&t, &i); gn != NULL; gn = ohash_next(&t, &i)) {
d1463 1
a1463 1
	gn = ohash_first(&t, &i);
d1465 22
d1488 11
a1498 1
	ohash_delete(&t);
d1501 5
d1509 1
a1509 1
	build_target_group(targets);
a1638 1
					Array_Reset(&gtargets);
@


1.112
log
@a wee little bit more cleanup (more const and remove noise from CDIAGFLAGS...
-pedantic kind of requires -std=c99 here to avoid LL warnings)
okay miod@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.111 2015/01/23 13:18:40 espie Exp $	*/
d66 1
d70 1
d1389 17
a1407 1
	unsigned int i;
d1410 1
d1412 2
a1413 3
	if (targets->n == 1)
		return;
	if (targets->a[0]->groupling != NULL)
d1437 9
d1447 7
a1453 1
		targets->a[i]->groupling = targets->a[(i+1)%targets->n];
d1455 9
@


1.111
log
@remove a bunch of dangerous casts (useless casts from void * to something
else, in some cases by adding extra temporary variables.
IMO, it's much better practice to do

void *a;
int *p = a;
*p = 42;

rather than
void *a;
*(int *)a = 42;

okay miod@@... to be revisited for some possible const additions later.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.110 2013/11/22 15:47:35 espie Exp $	*/
d482 1
@


1.110
log
@wrappers for is*/to* that make damn sure their arguments are
cast to unsigned chars.

okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.109 2012/11/24 11:06:08 espie Exp $	*/
d481 1
a481 1
	GNode *gn = (GNode *)gnp;
d499 1
a499 1
	Lst path = (Lst)p;
d1001 1
a1001 1
	GNode *gn = (GNode *)gnp;
d1019 1
a1019 1
	GNode *gn = (GNode *)gnp;
@


1.109
log
@complement "need an operator" fatal error message with the actual line content.
okay beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.108 2012/11/07 14:18:41 espie Exp $	*/
d569 1
a569 1
		if (isspace(*p) || *p == '\0')
d577 1
a577 1
		} while (!isspace(*p));
d592 1
a592 1
		for (cp = line; *cp && !isspace(*cp) && *cp != '(';) {
d656 1
a656 1
		while (isspace(*cp))
d765 1
a765 1
	while (isspace(*cp))
d896 1
a896 1
		    while (*cp && !isspace(*cp))
d916 1
a916 1
		    while (isspace(*cp))
d928 1
a928 1
			while (*cp && !isspace(*cp)) {
d969 1
a969 1
			while (isspace(*cp))
d1162 1
a1162 1
	while (isspace(*file))
d1198 1
a1198 1
	while (isspace(*file))
d1206 1
a1206 1
	for (efile = file; *efile != '\0' && !isspace(*efile);)
d1246 1
a1246 1
	while (isspace(*p))
d1252 1
a1252 1
	while (isspace(*p))
d1261 1
a1261 1
	while (isspace(*p))
d1267 1
a1267 1
	while (isspace(*p))
d1270 1
a1270 1
	while (*p != '\0' && !isspace(*p)) {
d1279 1
a1279 1
	while (isspace(*p))
d1334 1
a1334 1
	while (isspace(*line))
d1336 1
a1336 1
	for (eline = line; !isspace(*eline) && *eline != '\0';)
d1348 1
a1348 1
	while (isspace(*line))
d1358 1
a1358 1
				while (isspace(*line))
d1453 1
a1453 1
	    isspace(line[7]) &&
d1461 1
a1461 1
	    isspace(line[8]) &&
d1468 1
a1468 1
	    isspace(line[8]) &&
d1515 1
a1515 1
		} while (isspace(*cmd));
@


1.108
log
@say goodbye to killing trailing spaces.
this was yet another weirdness in our make that isn't shared by
other makes, and that isn't part of any standard.
This means end-of-line spaces in variables ARE significant (spaces
around the equal sign still aren't).

okay sthen@@, "sounds fine" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.107 2012/10/09 19:45:34 espie Exp $	*/
d644 2
a645 1
				Parse_Error(PARSE_FATAL, "Need an operator");
@


1.107
log
@- SPECIAL_DEPRECATED -> SPECIAL_NOTHING
- nodes for .POSIX and .SCCS_GET (which don't do anything)
- zap remaining suffix crud.

new scaffolding:
- groupling list and HELDBACK state to avoid races in engine.
- parser recognizes lists of targets that shoul be grouped together
- OP_DOUBLE to mark nodes that have multiple lists of commands
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.106 2012/10/02 10:29:31 espie Exp $	*/
a1050 1
		Buf_KillTrailingSpaces(copy);
@


1.106
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.105 2012/09/21 07:55:20 espie Exp $	*/
d159 1
a159 1
    const char *);
d180 1
a180 1
    { P(NODE_INCLUDES),	SPECIAL_DEPRECATED | SPECIAL_TARGET,	0, },
d183 1
a183 1
    { P(NODE_LIBS),	SPECIAL_DEPRECATED | SPECIAL_TARGET,	0, },
d192 1
a192 1
    { P(NODE_NULL),	SPECIAL_DEPRECATED | SPECIAL_TARGET,	0, },
d201 1
a201 1
    { P(NODE_SINGLESHELL),SPECIAL_SINGLESHELL | SPECIAL_TARGET,	0, },
d207 2
a208 3
#if 0
	{ P(NODE_NOPATH),	SPECIAL_NOPATH, },
#endif
d724 1
a726 3
		case SPECIAL_SINGLESHELL:
			compatMake = 1;
			break;
d858 1
a858 1
		/*Call on functions in main.c to deal with these arguments */
d861 1
a861 2
	} else if (specType == SPECIAL_NOTPARALLEL ||
	    specType == SPECIAL_SINGLESHELL) {
d869 1
a869 1
	    specType == SPECIAL_DEPRECATED) {
d987 9
a995 2
 * Side Effects:
 *	A new element is added to the commands list of the node.
d1001 1
a1001 1
	/* if target already supplied, ignore commands */
d1004 2
d1011 2
a1012 7
 *	Callback procedure for Parse_File when destroying the list of
 *	targets on the last dependency line. Marks a target as already
 *	having commands if it does, to keep from having shell commands
 *	on multiple dependency lines.
 *
 * Side Effects:
 *	OP_HAS_COMMANDS may be set for the target.
d1016 1
a1016 1
ParseHasCommands(void *gnp)	    /* Node to examine */
d1019 2
a1020 2
	if (!Lst_IsEmpty(&gn->commands))
		gn->type |= OP_HAS_COMMANDS;
d1386 38
d1426 1
a1427 1
	Array_Reset(targets);
a1442 1

d1478 1
a1478 1
    const char *stripped)
d1516 1
a1516 1
		if (*cmd != '\0')
d1518 2
d1528 1
d1541 2
a1542 1
				if (expectingCommands)
d1544 1
a1544 1
				else
d1553 1
a1553 1
					if (expectingCommands)
d1555 2
d1561 2
a1562 1
						    line, stripped);
d1570 1
a1570 1
	if (expectingCommands)
@


1.105
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.104 2012/04/20 13:28:11 espie Exp $	*/
a108 4
#ifdef CLEANUP
static LIST	    targCmds;	/* command lines for targets */
#endif

a167 28
#define	SPECIAL_EXEC		4U
#define SPECIAL_IGNORE		5U
#define SPECIAL_INCLUDES	6U
#define	SPECIAL_INVISIBLE	8U
#define SPECIAL_JOIN		9U
#define SPECIAL_LIBS		10U
#define SPECIAL_MADE		11U
#define SPECIAL_MAIN		12U
#define SPECIAL_MAKE		13U
#define SPECIAL_MFLAGS		14U
#define	SPECIAL_NOTMAIN		15U
#define	SPECIAL_NOTPARALLEL	16U
#define	SPECIAL_NULL		17U
#define	SPECIAL_OPTIONAL	18U
#define SPECIAL_ORDER		19U
#define SPECIAL_PARALLEL	20U
#define SPECIAL_PHONY		22U
#define SPECIAL_PRECIOUS	23U
#define SPECIAL_SILENT		25U
#define SPECIAL_SINGLESHELL	26U
#define SPECIAL_SUFFIXES	27U
#define	SPECIAL_USE		28U
#define SPECIAL_WAIT		29U
#define SPECIAL_NOPATH		30U
#define SPECIAL_ERROR		31U
#define SPECIAL_CHEAP		32U
#define SPECIAL_EXPENSIVE	33U

d180 1
a180 1
    { P(NODE_INCLUDES),	SPECIAL_INCLUDES | SPECIAL_TARGET,	0, },
d183 1
a183 1
    { P(NODE_LIBS),	SPECIAL_LIBS | SPECIAL_TARGET,		0, },
d192 1
a192 1
    { P(NODE_NULL),	SPECIAL_NULL | SPECIAL_TARGET,		0, },
a517 7
	/* try to find a proper location for a target in a file, by
	 * filling it repeatedly until the target has commands..
	 * This is not perfect for .USE targets...
	 */
	if ((gn->type & OP_HAS_COMMANDS) == 0)
		Parse_FillLocation(&gn->origin);

d701 1
a701 2
	}
	else if (seen_path != 0) {
d873 1
a873 2
	    specType == SPECIAL_INCLUDES || specType == SPECIAL_LIBS ||
	    specType == SPECIAL_NULL) {
a913 9
		    case SPECIAL_INCLUDES:
			    Suff_AddIncludei(line, cp);
			    break;
		    case SPECIAL_LIBS:
			    Suff_AddLibi(line, cp);
			    break;
		    case SPECIAL_NULL:
			    Suff_SetNulli(line, cp);
			    break;
a1406 3
#ifdef CLEANUP
	Lst_AtEnd(&targCmds, cmd);
#endif
a1544 5

	LowParse_Init();
#ifdef CLEANUP
	Static_Lst_Init(&targCmds);
#endif
a1545 12

#ifdef CLEANUP
void
Parse_End(void)
{
	Lst_Destroy(&targCmds, (SimpleProc)free);
	Lst_Destroy(systemIncludePath, Dir_Destroy);
	Lst_Destroy(userIncludePath, Dir_Destroy);
	LowParse_End();
}
#endif

@


1.104
log
@dyslexy strikes again
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.103 2012/04/17 09:34:15 espie Exp $	*/
d550 8
a557 2
	if (gn != NULL)
		Array_AtEnd(&gtargets, gn);
d1049 1
a1049 1
	if (!(gn->type & OP_HAS_COMMANDS)) {
a1050 3
		if (!gn->origin.lineno)
			Parse_FillLocation(&gn->origin);
	}
d1447 8
a1454 1
	char *cmd = estrdup(line);
d1499 1
a1499 1
	char *dep;
d1505 1
a1505 1
	dep = NULL;
d1514 1
a1514 1
			dep = strchr(line+(end-stripped), ';');
d1516 1
a1516 1
			dep = end;
d1527 2
a1528 2
	/* Parse dependency if it's not empty. */
	if (dep != NULL) {
d1530 4
a1533 4
			dep++;
		} while (isspace(*dep));
		if (*dep != '\0')
			parse_commands(targets, dep);
@


1.103
log
@this error message was impossible to understand without the source code.
be slightly more verbose and really explain what's going on.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.102 2012/04/11 18:27:30 espie Exp $	*/
d331 2
a332 2
		    gn->name, gn->name, operator_string(op), 
		    gn->name, operator_string(gn->type));
@


1.102
log
@make has had heuristics to avoid parallel make recursion.
Sometimes they mess up, so add .CHEAP/.EXPENSIVE to explicitly tell make
'hey this is not THAT bad' or 'worse than you think'.
agreed by guenther@@, millert@@ (and some tweaks)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.101 2012/03/22 13:47:12 espie Exp $	*/
d282 22
d328 5
a332 2
		Parse_Error(PARSE_FATAL, "Inconsistent operator for %s",
		    gn->name);
@


1.101
log
@minor cleanup: error messages include lineno and fileno together, so
recognize that and create a struct Location_ for it.

mostly from Jonathan Calmels, a few nits from me.

okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.100 2010/12/26 13:09:22 espie Exp $	*/
d197 2
d237 2
@


1.100
log
@nits with current being NULL or not.
okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.99 2010/07/19 19:46:44 espie Exp $	*/
d1016 2
a1017 4
		if (!gn->lineno) {
			gn->lineno = Parse_Getlineno();
			gn->fname = Parse_Getfilename();
		}
@


1.99
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.98 2010/07/15 10:41:11 espie Exp $	*/
d1105 1
a1105 1
		char *slash;
d1110 3
a1112 1
		slash = strrchr(fname, '/');
@


1.98
log
@whitespace
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$	*/
@


1.97
log
@use unsigned values where applicable
@
text
@d303 1
a303 1
		Parse_Error(PARSE_FATAL, "Inconsistent operator for %s", 
d647 1
a647 1
			    	Parse_Error(PARSE_FATAL, 
d714 1
a714 1
		Parse_Error(PARSE_FATAL, 
@


1.96
log
@simple check for cvs conflicts, avoids some "duh" moments (some people like
it, other don't care, it's cheap enough). Slightly tweaked patch that also
guards against empty arrays (though it's unlikely to happen, I don't feel
like proving the array is not empty).
@
text
@d124 1
a124 1
static int specType;
d134 1
a134 1
static int ParseDoOp(GNode **, int);
d143 1
a143 1
static void apply_op(struct growableArray *, int, GNode *);
d160 1
a160 1
static int parse_operator(const char **);
d162 1
a162 1
static const char *parse_do_targets(Lst, int *, const char *);
d170 1
a170 1
static int handle_special_targets(Lst);
d173 25
a197 25
#define	SPECIAL_EXEC		4
#define SPECIAL_IGNORE		5
#define SPECIAL_INCLUDES	6
#define	SPECIAL_INVISIBLE	8
#define SPECIAL_JOIN		9
#define SPECIAL_LIBS		10
#define SPECIAL_MADE		11
#define SPECIAL_MAIN		12
#define SPECIAL_MAKE		13
#define SPECIAL_MFLAGS		14
#define	SPECIAL_NOTMAIN		15
#define	SPECIAL_NOTPARALLEL	16
#define	SPECIAL_NULL		17
#define	SPECIAL_OPTIONAL	18
#define SPECIAL_ORDER		19
#define SPECIAL_PARALLEL	20
#define SPECIAL_PHONY		22
#define SPECIAL_PRECIOUS	23
#define SPECIAL_SILENT		25
#define SPECIAL_SINGLESHELL	26
#define SPECIAL_SUFFIXES	27
#define	SPECIAL_USE		28
#define SPECIAL_WAIT		29
#define SPECIAL_NOPATH		30
#define SPECIAL_ERROR		31
d206 2
a207 2
	int type;
	int special_op;
d293 1
a293 1
ParseDoOp(GNode **gnp, int op)
d372 1
a372 1
apply_op(struct growableArray *targets, int op, GNode *gn)
d593 1
a593 1
parse_do_targets(Lst paths, int *op, const char *line)
d678 1
a678 1
static int
d750 1
a750 1
static int
d754 1
a754 1
	int op = OP_ERROR;
d814 1
a814 1
	int op; 		/* the operator on the line */
d817 1
a817 1
	int tOp;		/* operator from special target */
@


1.95
log
@put parsing of operator (:, ::, !) into its own function
@
text
@d643 9
a651 1
			Parse_Error(PARSE_FATAL, "Need an operator");
@


1.94
log
@reindent a few lines in parse.c which are missing it.
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.93 2007/09/18 08:24:56 espie Exp $	*/
d160 1
d742 29
d821 2
a822 13
	/* Have now parsed all the target names. Must parse the operator next.
	 * The result is left in op .  */
	if (*cp == '!') {
		op = OP_FORCE;
	} else if (*cp == ':') {
		if (cp[1] == ':') {
			op = OP_DOUBLEDEP;
			cp++;
		} else {
			op = OP_DEPENDS;
		}
	} else {
		Parse_Error(PARSE_FATAL, "Missing dependency operator");
a823 3
	}

	cp++;			/* Advance beyond operator */
a826 5
	/*
	 * Get to the first source
	 */
	while (isspace(*cp))
		cp++;
@


1.93
log
@missing prototype for static function
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.92 2007/09/17 12:42:09 espie Exp $	*/
d269 7
a275 9
ParseLinkSrc(
    GNode		*pgn,	/* The parent node */
    GNode		*cgn)	/* The child node */
{
    if (Lst_AddNew(&pgn->children, cgn)) {
	if (specType == SPECIAL_NONE)
	    Lst_AtEnd(&cgn->parents, pgn);
	pgn->unmade++;
    }
d292 46
a337 47
ParseDoOp(
    GNode	   **gnp,
    int	   	   op)	/* The operator to apply */
{
    GNode *gn = *gnp;
    /*
     * If the dependency mask of the operator and the node don't match and
     * the node has actually had an operator applied to it before, and
     * the operator actually has some dependency information in it, complain.
     */
    if (((op & OP_OPMASK) != (gn->type & OP_OPMASK)) &&
	!OP_NOP(gn->type) && !OP_NOP(op)) {
	Parse_Error(PARSE_FATAL, "Inconsistent operator for %s", gn->name);
	return 0;
    }

    if (op == OP_DOUBLEDEP && ((gn->type & OP_OPMASK) == OP_DOUBLEDEP)) {
	/* If the node was the object of a :: operator, we need to create a
	 * new instance of it for the children and commands on this dependency
	 * line. The new instance is placed on the 'cohorts' list of the
	 * initial one (note the initial one is not on its own cohorts list)
	 * and the new instance is linked to all parents of the initial
	 * instance.  */
	GNode		*cohort;
	LstNode 	ln;

	cohort = Targ_NewGN(gn->name);
	/* Duplicate links to parents so graph traversal is simple. Perhaps
	 * some type bits should be duplicated?
	 *
	 * Make the cohort invisible as well to avoid duplicating it into
	 * other variables. True, parents of this target won't tend to do
	 * anything with their local variables, but better safe than
	 * sorry.  */
	for (ln = Lst_First(&gn->parents); ln != NULL; ln = Lst_Adv(ln))
	    ParseLinkSrc((GNode *)Lst_Datum(ln), cohort);
	cohort->type = OP_DOUBLEDEP|OP_INVISIBLE;
	Lst_AtEnd(&gn->cohorts, cohort);

	/* Replace the node in the targets list with the new copy */
	*gnp = cohort;
	gn = cohort;
    }
    /* We don't want to nuke any previous flags (whatever they were) so we
     * just OR the new operator into the old.  */
    gn->type |= op;
    return 1;
d359 9
a367 10
    if (p->order < s->order) {
	/* XXX: This can cause loops, and loops can cause unmade targets,
	 * but checking is tedious, and the debugging output can show the
	 * problem.  */
	Lst_AtEnd(&p->successors, s);
	Lst_AtEnd(&s->preds, p);
	return 1;
    }
    else
	return 0;
d483 9
a491 11
ParseFindMain(
    void *gnp,	    /* Node to examine */
    void *dummy 	UNUSED)
{
    GNode	  *gn = (GNode *)gnp;
    if ((gn->type & OP_NOTARGET) == 0 && gn->special == SPECIAL_NONE) {
	mainNode = gn;
	return 0;
    } else {
	return 1;
    }
d503 1
a503 1
    Lst 	path = (Lst)p;
d505 2
a506 2
    Lst_Destroy(path, Dir_Destroy);
    Lst_Init(path);
d705 2
a706 1
		Parse_Error(PARSE_FATAL, "Mixing special targets is not allowed");
d992 1
a992 3
ParseAddCmd(
    void *gnp,	/* the node to which the command is to be added */
    void *cmd)	/* the command to add */
d1563 9
a1571 10

    if (mainNode == NULL) {
	Punt("no target to make.");
	/*NOTREACHED*/
    } else if (mainNode->type & OP_DOUBLEDEP) {
	Lst_AtEnd(listmain, mainNode);
	Lst_Concat(listmain, &mainNode->cohorts);
    }
    else
	Lst_AtEnd(listmain, mainNode);
a1572 1

@


1.92
log
@rewrite of the basic suffix/target parsing: use hash for suffixes.

Store special targets in target hash, and use them for the parsing.

Use OP_DUMMY flag to mark targets that don't really exist yet, such
as interrupt and default nodes.

Also, .PATHxxx is special in suffixes.

Small tweaks to compat.c, so that run_commands does more stuff after
the fork() (and thus no need to free things).

Remove distinction between local and global jobs.
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.91 2007/09/17 11:32:25 espie Exp $	*/
d170 1
@


1.91
log
@clean-up Parse_File toplevel: add functions to make it clearer what's going
on.

Start getting rid of globals by passing explicit parameters
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.90 2007/09/17 11:14:37 espie Exp $	*/
d94 2
d98 3
d118 4
a121 4
 * specType contains the SPECial TYPE of the current target. It is
 * Not if the target is unspecial. If it *is* special, however, the children
 * are linked as children of the parent but not vice versa. This variable is
 * set in ParseDoDependency
a122 27
typedef enum {
    Begin,	    /* .BEGIN */
    Default,	    /* .DEFAULT */
    End,	    /* .END */
    Ignore,	    /* .IGNORE */
    Includes,	    /* .INCLUDES */
    Interrupt,	    /* .INTERRUPT */
    Libs,	    /* .LIBS */
    MFlags,	    /* .MFLAGS or .MAKEFLAGS */
    Main,	    /* .MAIN and we don't have anything user-specified to
		     * make */
    NoExport,	    /* .NOEXPORT */
    NoPath,	    /* .NOPATH */
    Not,	    /* Not special */
    NotParallel,    /* .NOTPARALELL */
    Null,	    /* .NULL */
    Order,	    /* .ORDER */
    Parallel,	    /* .PARALLEL */
    ExPath,	    /* .PATH */
    Phony,	    /* .PHONY */
    Precious,	    /* .PRECIOUS */
    Silent,	    /* .SILENT */
    SingleShell,    /* .SINGLESHELL */
    Suffixes,	    /* .SUFFIXES */
    Wait,	    /* .WAIT */
    Attribute	    /* Generic attribute */
} ParseSpecial;
d124 1
a124 1
static ParseSpecial specType;
a132 49
/*
 * The parseKeywords table is searched using binary search when deciding
 * if a target or source is special. The 'spec' field is the ParseSpecial
 * type of the keyword ("Not" if the keyword isn't special as a target) while
 * the 'op' field is the operator to apply to the list of targets if the
 * keyword is used as a source ("0" if the keyword isn't special as a source)
 */
static struct {
    char	  *name;	/* Name of keyword */
    ParseSpecial  spec; 	/* Type when used as a target */
    int 	  op;		/* Operator when used as a source */
} parseKeywords[] = {
{ ".BEGIN",	  Begin,	0 },
{ ".DEFAULT",	  Default,	0 },
{ ".END",	  End,		0 },
{ ".EXEC",	  Attribute,	OP_EXEC },
{ ".IGNORE",	  Ignore,	OP_IGNORE },
{ ".INCLUDES",	  Includes,	0 },
{ ".INTERRUPT",   Interrupt,	0 },
{ ".INVISIBLE",   Attribute,	OP_INVISIBLE },
{ ".JOIN",	  Attribute,	OP_JOIN },
{ ".LIBS",	  Libs, 	0 },
{ ".MADE",	  Attribute,	OP_MADE },
{ ".MAIN",	  Main, 	0 },
{ ".MAKE",	  Attribute,	OP_MAKE },
{ ".MAKEFLAGS",   MFlags,	0 },
{ ".MFLAGS",	  MFlags,	0 },
#if 0	/* basic scaffolding for NOPATH, not working yet */
{ ".NOPATH",	  NoPath,	OP_NOPATH },
#endif
{ ".NOTMAIN",	  Attribute,	OP_NOTMAIN },
{ ".NOTPARALLEL", NotParallel,	0 },
{ ".NO_PARALLEL", NotParallel,	0 },
{ ".NULL",	  Null, 	0 },
{ ".OPTIONAL",	  Attribute,	OP_OPTIONAL },
{ ".ORDER",	  Order,	0 },
{ ".PARALLEL",	  Parallel,	0 },
{ ".PATH",	  ExPath,	0 },
{ ".PHONY",	  Phony,	OP_PHONY },
{ ".PRECIOUS",	  Precious,	OP_PRECIOUS },
{ ".RECURSIVE",   Attribute,	OP_MAKE },
{ ".SILENT",	  Silent,	OP_SILENT },
{ ".SINGLESHELL", SingleShell,	0 },
{ ".SUFFIXES",	  Suffixes,	0 },
{ ".USE",	  Attribute,	OP_USE },
{ ".WAIT",	  Wait, 	0 },
};

static int ParseFindKeyword(const char *);
d134 1
a134 1
static int ParseDoOp(GNode *, int);
d136 2
a137 1
static void ParseDoSrc(int, const char *);
a138 1
static void ParseAddDir(void *, void *);
d141 4
a144 3
static void add_target_node(const char *);
static void add_target_nodes(const char *);
static void ParseDoDependency(char *);
d160 2
d165 78
a242 11
/*-
 *----------------------------------------------------------------------
 * ParseFindKeyword --
 *	Look in the table of keywords for one matching the given string.
 *
 * Results:
 *	The index of the keyword, or -1 if it isn't there.
 *----------------------------------------------------------------------
 */
static int
ParseFindKeyword(const char *str)	/* keyword to look up */
d244 7
a250 18
    int 	    start,
		    end,
		    cur;
    int 	    diff;

    start = 0;
    end = (sizeof(parseKeywords)/sizeof(parseKeywords[0])) - 1;

    do {
	cur = start + (end - start) / 2;
	diff = strcmp(str, parseKeywords[cur].name);

	if (diff == 0) {
	    return cur;
	} else if (diff < 0) {
	    end = cur - 1;
	} else {
	    start = cur + 1;
a251 2
    } while (start <= end);
    return -1;
d253 1
d272 5
a276 5
	if (Lst_AddNew(&pgn->children, cgn)) {
		if (specType == Not)
			Lst_AtEnd(&cgn->parents, pgn);
		pgn->unmade++;
	}
d283 1
a283 1
 *	Lst_Find call by ParseDoDependency once all targets have
d294 1
a294 1
    GNode	   *gn,	/* The node to which the operator is to be applied */
d297 11
a307 11
	/*
	 * If the dependency mask of the operator and the node don't match and
	 * the node has actually had an operator applied to it before, and
	 * the operator actually has some dependency information in it, complain.
	 */
	if (((op & OP_OPMASK) != (gn->type & OP_OPMASK)) &&
		!OP_NOP(gn->type) && !OP_NOP(op)) {
		Parse_Error(PARSE_FATAL, 
		    "Inconsistent operator for %s", gn->name);
		return 0;
	}
d309 31
a339 35
	if (op == OP_DOUBLEDEP && ((gn->type & OP_OPMASK) == OP_DOUBLEDEP)) {
		/* If the node was the object of a :: operator, we need to
		 * create a new instance of it for the children and commands on
		 * this dependency line. The new instance is placed on the
		 * 'cohorts' list of the initial one (note the initial one is
		 * not on its own cohorts list) and the new instance is linked
		 * to all parents of the initial instance.  */
		GNode		*cohort;
		LstNode 	ln;
		unsigned int i;

		cohort = Targ_NewGN(gn->name);
		/* Duplicate links to parents so graph traversal is simple.
		 * Perhaps some type bits should be duplicated?
		 *
		 * Make the cohort invisible as well to avoid duplicating it
		 * into other variables. True, parents of this target won't
		 * tend to do anything with their local variables, but better
		 * safe than sorry.  */
		for (ln = Lst_First(&gn->parents); ln != NULL; ln = Lst_Adv(ln))
			ParseLinkSrc((GNode *)Lst_Datum(ln), cohort);
		cohort->type = OP_DOUBLEDEP|OP_INVISIBLE;
		Lst_AtEnd(&gn->cohorts, cohort);

		/* Replace the node in the targets list with the new copy */
		for (i = 0; i < gtargets.n; i++)
			if (gtargets.a[i] == gn)
				break;
		gtargets.a[i] = cohort;
		gn = cohort;
	}
	/* We don't want to nuke any previous flags (whatever they were) so we
	 * just OR the new operator into the old.  */
	gn->type |= op;
	return 1;
d361 17
a377 8
	if (p->order < s->order) {
		/* XXX: This can cause loops, and loops can cause unmade
		 * targets, but checking is tedious, and the debugging output
		 * can show the problem.  */
		Lst_AtEnd(&p->successors, s);
		Lst_AtEnd(&s->preds, p);
		return 1;
	}
d379 1
a379 1
		return 0;
a381 1

d398 2
d401 2
a402 1
    const char	*src)	/* name of the source to handle */
d404 9
a412 14
	GNode	*gn = NULL;

	if (*src == '.' && isupper(src[1])) {
		int keywd = ParseFindKeyword(src);
		if (keywd != -1) {
			int op = parseKeywords[keywd].op;
			if (op != 0) {
				Array_Find(&gtargets, ParseDoOp, op);
				return;
			}
			if (parseKeywords[keywd].spec == Wait) {
				waiting++;
				return;
			}
d417 1
a417 1
	case Main:
d421 3
a423 4
		 * to create. The string 'src' is likely to be freed, so we
		 * must make a new copy of it. Note that this will only be
		 * invoked if the user didn't specify a target on the command
		 * line. This is to allow #ifmake's to succeed, or something...
d425 1
a425 1
		Lst_AtEnd(create, estrdup(src));
d430 1
a430 1
		Var_Append(".TARGETS", src);
d433 1
a433 1
	case Order:
a437 1
		gn = Targ_FindNode(src, TARG_CREATE);
a441 4
		/*
		 * The current source now becomes the predecessor for the next
		 * one.
		 */
a446 5
		 * If the source is not an attribute, we need to find/create
		 * a node for it. After that we can apply any operator to it
		 * from a special target or link it to its parents, as
		 * appropriate.
		 *
d452 1
a452 6
		gn = Targ_FindNode(src, TARG_CREATE);
		if (tOp) {
			gn->type |= tOp;
		} else {
			Array_ForEach(&gtargets, ParseLinkSrc, gn);
		}
a453 1
			GNode	*cohort;
d456 1
a456 1
			for (ln=Lst_First(&gn->cohorts); ln != NULL; 
d458 2
a459 7
				cohort = (GNode *)Lst_Datum(ln);
				if (tOp) {
					cohort->type |= tOp;
				} else {
					Array_ForEach(&gtargets, ParseLinkSrc, 
					    cohort);
				}
d466 3
a468 4
	Array_AtEnd(&gsources, gn);
	if (waiting) {
		Array_Find(&gsources, ParseAddDep, gn);
	}
d482 1
a482 1
 *	mainNode is changed and Targ_SetMain is called.
d490 7
a496 23
	GNode	  *gn = (GNode *)gnp;
	if ((gn->type & OP_NOTARGET) == 0) {
		mainNode = gn;
		Targ_SetMain(gn);
		return 0;
	} else {
		return 1;
	}
}

/*-
 *-----------------------------------------------------------------------
 * ParseAddDir --
 *	Front-end for Dir_AddDir to make sure Lst_ForEach keeps going
 *
 * Side Effects:
 *	See Dir_AddDir.
 *-----------------------------------------------------------------------
 */
static void
ParseAddDir(void *path, void *name)
{
	Dir_AddDir((Lst)path, (char *)name);
d508 1
a508 1
	Lst 	path = (Lst)p;
d510 2
a511 2
	Lst_Destroy(path, Dir_Destroy);
	Lst_Init(path);
d515 1
a515 1
add_target_node(const char *line)
d519 6
a524 4
	if (!Suff_IsTransform(line))
		gn = Targ_FindNode(line, TARG_CREATE);
	else
		gn = Suff_AddTransform(line);
d531 1
a531 1
add_target_nodes(const char *line)
d534 1
a534 1
	if (Dir_HasWildcards(line)) {
d547 1
a547 1
		Dir_Expand(line, &emptyPath, &curTargs);
d550 1
a550 1
			add_target_node(targName);
d554 188
a741 1
		add_target_node(line);
d777 1
a777 1
ParseDoDependency(char *line)	/* the line to parse */
d779 5
a783 36
    char	   *cp; 	/* our current position */
    GNode	   *gn; 	/* a general purpose temporary node */
    int 	    op; 	/* the operator on the line */
    char	    savec;	/* a place to save a character */
    LIST	    paths;	/* List of search paths to alter when parsing
				 * a list of .PATH targets */
    int 	    tOp;	/* operator from special target */
    tOp = 0;

    specType = Not;
    waiting = 0;
    Lst_Init(&paths);

    Array_Reset(&gsources);

    do {
	for (cp = line; *cp && !isspace(*cp) && *cp != '(';)
	    if (*cp == '$')
		/* Must be a dynamic source (would have been expanded
		 * otherwise), so call the Var module to parse the puppy
		 * so we can safely advance beyond it...There should be
		 * no errors in this, as they would have been discovered
		 * in the initial Var_Subst and we wouldn't be here.  */
		Var_ParseSkip(&cp, NULL);
	    else {
		/* We don't want to end a word on ':' or '!' if there is a
		 * better match later on in the string.  By "better" I mean
		 * one that is followed by whitespace.	This allows the user
		 * to have targets like:
		 *    fie::fi:fo: fum
		 * where "fie::fi:fo" is the target.  In real life this is used
		 * for perl5 library man pages where "::" separates an object
		 * from its class.  Ie: "File::Spec::Unix".  This behaviour
		 * is also consistent with other versions of make.  */
		if (*cp == '!' || *cp == ':') {
		    char *p = cp + 1;
a784 2
		    if (*cp == ':' && *p == ':')
			p++;
d786 2
a787 3
		    /* Found the best match already. */
		    if (isspace(*p) || *p == '\0')
			break;
d789 1
a789 6
		    do {
			p += strcspn(p, "!:");
			if (*p == '\0')
			    break;
			p++;
		    } while (!isspace(*p));
d791 3
a793 3
		    /* No better match later on... */
		    if (*p == '\0')
			break;
d795 10
d806 2
a807 16
		cp++;
	    }
	if (*cp == '(') {
	    LIST temp;
	    Lst_Init(&temp);
	    /* Archives must be handled specially to make sure the OP_ARCHV
	     * flag is set in their 'type' field, for one thing, and because
	     * things like "archive(file1.o file2.o file3.o)" are permissible.
	     * Arch_ParseArchive will set 'line' to be the first non-blank
	     * after the archive-spec. It creates/finds nodes for the members
	     * and places them on the given list, returning true if all
	     * went well and false if there was an error in the
	     * specification. On error, line should remain untouched.  */
	    if (!Arch_ParseArchive(&line, &temp, NULL)) {
		Parse_Error(PARSE_FATAL,
			     "Error in archive specification: \"%s\"", line);
d809 3
a811 25
	    } else {
	    	AppendList2Array(&temp, &gtargets);
		Lst_Destroy(&temp, NOFREE);
		continue;
	    }
	}
	savec = *cp;

	if (*cp == '\0') {
	    /* Ending a dependency line without an operator is a Bozo no-no */
	    Parse_Error(PARSE_FATAL, "Need an operator");
	    return;
	}
	*cp = '\0';
	/* Have a word in line. See if it's a special target and set
	 * specType to match it.  */
	if (*line == '.' && isupper(line[1])) {
	    /* See if the target is a special target that must have it
	     * or its sources handled specially.  */
	    int keywd = ParseFindKeyword(line);
	    if (keywd != -1) {
		if (specType == ExPath && parseKeywords[keywd].spec != ExPath) {
		    Parse_Error(PARSE_FATAL, "Mismatched special targets");
		    return;
		}
d813 1
a813 2
		specType = parseKeywords[keywd].spec;
		tOp = parseKeywords[keywd].op;
d815 17
a831 29
		/*
		 * Certain special targets have special semantics:
		 *	.PATH		Have to set the defaultPath
		 *			variable too
		 *	.MAIN		Its sources are only used if
		 *			nothing has been specified to
		 *			create.
		 *	.DEFAULT	Need to create a node to hang
		 *			commands on, but we don't want
		 *			it in the graph, nor do we want
		 *			it to be the Main Target, so we
		 *			create it, set OP_NOTMAIN and
		 *			add it to the list, setting
		 *			DEFAULT to the new node for
		 *			later use. We claim the node is
		 *			A transformation rule to make
		 *			life easier later, when we'll
		 *			use Make_HandleUse to actually
		 *			apply the .DEFAULT commands.
		 *	.PHONY		The list of targets
		 *	.NOPATH 	Don't search for file in the path
		 *	.BEGIN
		 *	.END
		 *	.INTERRUPT	Are not to be considered the
		 *			main target.
		 *	.NOTPARALLEL	Make only one target at a time.
		 *	.SINGLESHELL	Create a shell for each command.
		 *	.ORDER		Must set initial predecessor to NULL
		 */
d833 2
a834 7
		    case ExPath:
			Lst_AtEnd(&paths, defaultPath);
			break;
		    case Main:
			if (!Lst_IsEmpty(create)) {
			    specType = Not;
			}
d836 2
a837 6
		    case Begin:
		    case End:
		    case Interrupt:
			gn = Targ_FindNode(line, TARG_CREATE);
			gn->type |= OP_NOTMAIN;
			Array_AtEnd(&gtargets, gn);
d839 2
a840 5
		    case Default:
			gn = Targ_NewGN(".DEFAULT");
			gn->type |= OP_NOTMAIN|OP_TRANSFORM;
			Array_AtEnd(&gtargets, gn);
			DEFAULT = gn;
d842 2
a843 5
		    case NotParallel:
		    {
			extern int  maxJobs;

			maxJobs = 1;
d845 2
a846 3
		    }
		    case SingleShell:
			compatMake = 1;
d848 1
a848 4
		    case Order:
			predecessor = NULL;
			break;
		    default:
d851 7
a857 19
	    } else if (strncmp(line, ".PATH", 5) == 0) {
		/*
		 * .PATH<suffix> has to be handled specially.
		 * Call on the suffix module to give us a path to
		 * modify.
		 */
		Lst	path;

		specType = ExPath;
		path = Suff_GetPath(&line[5]);
		if (path == NULL) {
		    Parse_Error(PARSE_FATAL,
				 "Suffix '%s' not defined (yet)",
				 &line[5]);
		    return;
		} else {
		    Lst_AtEnd(&paths, path);
		}
	    }
d861 1
a861 2
	 * Have word in line. Get or create its node and stick it at
	 * the end of the targets list
d863 60
a922 16
	if (specType == Not && *line != '\0') {
	    add_target_nodes(line);
	} else if (specType == ExPath && *line != '.' && *line != '\0')
	    Parse_Error(PARSE_WARNING, "Extra target (%s) ignored", line);

	*cp = savec;
	/*
	 * If it is a special type and not .PATH, it's the only target we
	 * allow on this line...
	 */
	if (specType != Not && specType != ExPath) {
	    bool warn = false;

	    while (*cp != '!' && *cp != ':' && *cp) {
		if (*cp != ' ' && *cp != '\t') {
		    warn = true;
d924 1
a924 5
		cp++;
	    }
	    if (warn) {
		Parse_Error(PARSE_WARNING, "Extra target ignored");
	    }
d926 20
a945 6
	    while (isspace(*cp)) {
		cp++;
	    }
	}
	line = cp;
    } while (*line != '!' && *line != ':' && *line);
d947 4
a950 16
    if (!Array_IsEmpty(&gtargets)) {
	switch (specType) {
	    default:
		Parse_Error(PARSE_WARNING, "Special and mundane targets don't mix. Mundane ones ignored");
		break;
	    case Default:
	    case Begin:
	    case End:
	    case Interrupt:
		/* These four create nodes on which to hang commands, so
		 * targets shouldn't be empty...  */
	    case Not:
		/* Nothing special here -- targets can be empty if it wants.  */
		break;
	}
    }
d952 7
a958 15
    /* Have now parsed all the target names. Must parse the operator next. The
     * result is left in op .  */
    if (*cp == '!') {
	op = OP_FORCE;
    } else if (*cp == ':') {
	if (cp[1] == ':') {
	    op = OP_DOUBLEDEP;
	    cp++;
	} else {
	    op = OP_DEPENDS;
	}
    } else {
	Parse_Error(PARSE_FATAL, "Missing dependency operator");
	return;
    }
d960 7
a966 1
    cp++;			/* Advance beyond operator */
d968 9
a976 38
    Array_Find(&gtargets, ParseDoOp, op);

    /*
     * Get to the first source
     */
    while (isspace(*cp)) {
	cp++;
    }
    line = cp;

    /*
     * Several special targets take different actions if present with no
     * sources:
     *	a .SUFFIXES line with no sources clears out all old suffixes
     *	a .PRECIOUS line makes all targets precious
     *	a .IGNORE line ignores errors for all targets
     *	a .SILENT line creates silence when making all targets
     *	a .PATH removes all directories from the search path(s).
     */
    if (!*line) {
	switch (specType) {
	    case Suffixes:
		Suff_ClearSuffixes();
		break;
	    case Precious:
		allPrecious = true;
		break;
	    case Ignore:
		ignoreErrors = true;
		break;
	    case Silent:
		beSilent = true;
		break;
	    case ExPath:
		Lst_Every(&paths, ParseClearPath);
		break;
	    default:
		break;
a977 11
    } else if (specType == MFlags) {
	/*
	 * Call on functions in main.c to deal with these arguments and
	 * set the initial character to a null-character so the loop to
	 * get sources won't get anything
	 */
	Main_ParseArgLine(line);
	*line = '\0';
    } else if (specType == NotParallel || specType == SingleShell) {
	*line = '\0';
    }
d979 6
a984 64
    /*
     * NOW GO FOR THE SOURCES
     */
    if (specType == Suffixes || specType == ExPath ||
	specType == Includes || specType == Libs ||
	specType == Null) {
	while (*line) {
	    /*
	     * If the target was one that doesn't take files as its sources
	     * but takes something like suffixes, we take each
	     * space-separated word on the line as a something and deal
	     * with it accordingly.
	     *
	     * If the target was .SUFFIXES, we take each source as a
	     * suffix and add it to the list of suffixes maintained by the
	     * Suff module.
	     *
	     * If the target was a .PATH, we add the source as a directory
	     * to search on the search path.
	     *
	     * If it was .INCLUDES, the source is taken to be the suffix of
	     * files which will be #included and whose search path should
	     * be present in the .INCLUDES variable.
	     *
	     * If it was .LIBS, the source is taken to be the suffix of
	     * files which are considered libraries and whose search path
	     * should be present in the .LIBS variable.
	     *
	     * If it was .NULL, the source is the suffix to use when a file
	     * has no valid suffix.
	     */
	    char  savec;
	    while (*cp && !isspace(*cp)) {
		cp++;
	    }
	    savec = *cp;
	    *cp = '\0';
	    switch (specType) {
		case Suffixes:
		    Suff_AddSuffix(line);
		    break;
		case ExPath:
		    Lst_ForEach(&paths, ParseAddDir, line);
		    break;
		case Includes:
		    Suff_AddInclude(line);
		    break;
		case Libs:
		    Suff_AddLib(line);
		    break;
		case Null:
		    Suff_SetNull(line);
		    break;
		default:
		    break;
	    }
	    *cp = savec;
	    if (savec != '\0') {
		cp++;
	    }
	    while (isspace(*cp)) {
		cp++;
	    }
	    line = cp;
a985 61
	Lst_Destroy(&paths, NOFREE);
    } else {
	while (*line) {
	    /*
	     * The targets take real sources, so we must beware of archive
	     * specifications (i.e. things with left parentheses in them)
	     * and handle them accordingly.
	     */
	    while (*cp && !isspace(*cp)) {
		if (*cp == '(' && cp > line && cp[-1] != '$') {
		    /*
		     * Only stop for a left parenthesis if it isn't at the
		     * start of a word (that'll be for variable changes
		     * later) and isn't preceded by a dollar sign (a dynamic
		     * source).
		     */
		    break;
		} else {
		    cp++;
		}
	    }

	    if (*cp == '(') {
		GNode	  *gn;
		LIST	  sources; /* list of archive source names after
				    * expansion */

		Lst_Init(&sources);
		if (!Arch_ParseArchive(&line, &sources, NULL)) {
		    Parse_Error(PARSE_FATAL,
				 "Error in source archive spec \"%s\"", line);
		    return;
		}

		while ((gn = (GNode *)Lst_DeQueue(&sources)) != NULL)
		    ParseDoSrc(tOp, gn->name);
		cp = line;
	    } else {
		if (*cp) {
		    *cp = '\0';
		    cp++;
		}

		ParseDoSrc(tOp, line);
	    }
	    while (isspace(*cp)) {
		cp++;
	    }
	    line = cp;
	}
    }

    if (mainNode == NULL) {
	/* If we have yet to decide on a main target to make, in the
	 * absence of any user input, we want the first target on
	 * the first dependency line that is actually a real target
	 * (i.e. isn't a .USE or .EXEC rule) to be made.  */
	Array_Find(&gtargets, ParseFindMain, NULL);
    }

    /* Finally, destroy the list of sources.  */
d1027 1
a1027 1
	if (!Lst_IsEmpty(&gn->commands)) {
a1028 1
	}
a1031 1

d1310 1
d1348 1
a1393 1
	Array_Every(targets, Suff_EndTransform);
a1543 1
	Array_Init(&gsources, SOURCES_SIZE);
d1545 2
d1570 9
a1578 9
	if (mainNode == NULL) {
		Punt("no target to make.");
		/*NOTREACHED*/
	} else if (mainNode->type & OP_DOUBLEDEP) {
		Lst_AtEnd(listmain, mainNode);
		Lst_Concat(listmain, &mainNode->cohorts);
	}
	else
		Lst_AtEnd(listmain, mainNode);
@


1.90
log
@Parse_DoVar -> Parse_As_Var_Assignment
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.89 2007/09/17 11:11:30 espie Exp $	*/
a220 1
static void ParseFinishDependency(void);
d229 3
a231 2

static void ParseDoCommands(const char *);
d1124 34
d1327 8
a1401 33

/* Strip comments from the line. Build a copy in buffer if necessary, */
static char *
strip_comments(Buffer copy, const char *line)
{
	const char *comment;
	const char *p;

	comment = strchr(line, '#');
	assert(comment != line);
	if (comment == NULL)
		return (char *)line;
	else {
		Buf_Reset(copy);

		for (p = line; *p != '\0'; p++) {
			if (*p == '\\') {
				if (p[1] == '#') {
					Buf_Addi(copy, line, p);
					Buf_AddChar(copy, '#');
					line = p+2;
				}
				if (p[1] != '\0')
					p++;
			} else if (*p == '#')
				break;
		}
		Buf_Addi(copy, line, p);
		Buf_KillTrailingSpaces(copy);
		return Buf_Retrieve(copy);
	}
}

d1407 1
a1407 1
	loop = For_Eval(line+3);
d1447 1
a1447 2
	/* The line might be a conditional. Ask the conditional module
	 * about it and act accordingly.  */
d1463 1
a1463 1
		return handle_for_loop(linebuf, line);
d1467 1
a1467 1
		return handle_poison(line+6);
d1477 4
a1480 10
/*-
 *-----------------------------------------------------------------------
 * ParseFinishDependency --
 *	Handle the end of a dependency group.
 *
 * Side Effects:
 *	'targets' list destroyed.
 *
 *-----------------------------------------------------------------------
 */
d1482 1
a1482 1
ParseFinishDependency(void)
d1484 3
a1486 3
	Array_Every(&gtargets, Suff_EndTransform);
	Array_Every(&gtargets, ParseHasCommands);
	Array_Reset(&gtargets);
d1490 1
a1490 1
ParseDoCommands(const char *line)
d1496 1
a1496 1
	Array_ForEach(&gtargets, ParseAddCmd, cmd);
d1502 29
a1530 17
void
Parse_File(
    const char	  *name,	/* the name of the file being read */
    FILE	  *stream)	/* Stream open to makefile to parse */
{
    char	  *cp,		/* pointer into the line */
		  *line;	/* the line we're working on */
    bool	  inDependency; /* true if currently in a dependency
				 * line or its commands */

    BUFFER	  buf;
    BUFFER	  copy;

    Buf_Init(&buf, MAKE_BSIZE);
    Buf_Init(&copy, MAKE_BSIZE);
    inDependency = false;
    Parse_FromFile(name, stream);
d1532 23
a1554 5
    do {
	while ((line = Parse_ReadNormalLine(&buf)) != NULL) {
	    if (*line == '\t') {
		if (inDependency)
		    ParseDoCommands(line+1);
d1556 26
a1581 27
		    Parse_Error(PARSE_FATAL,
			"Unassociated shell command \"%s\"",
			 line);
	    } else {
		char *stripped;
		stripped = strip_comments(&copy, line);
		if (*stripped == '.' && handle_bsd_command(&buf, &copy,
		    stripped+1))
			;
		else if (FEATURES(FEATURE_SYSVINCLUDE) &&
		    strncmp(stripped, "include", 7) == 0 &&
		    isspace(stripped[7]) &&
		    strchr(stripped, ':') == NULL) {
		    /* It's an S3/S5-style "include".  */
			lookup_sysv_include(stripped + 7, "include");
		} else if (FEATURES(FEATURE_CONDINCLUDE) &&
		    strncmp(stripped, "sinclude", 8) == 0 &&
		    isspace(stripped[8]) &&
		    strchr(stripped, ':') == NULL) {
		    	lookup_conditional_include(stripped+8, "sinclude");
		} else if (FEATURES(FEATURE_CONDINCLUDE) &&
		    strncmp(stripped, "-include", 8) == 0 &&
		    isspace(stripped[8]) &&
		    strchr(stripped, ':') == NULL) {
		    	lookup_conditional_include(stripped+8, "-include");
		} else {
		    char *dep;
d1583 13
a1595 22
		    if (inDependency)
			ParseFinishDependency();
		    if (Parse_As_Var_Assignment(stripped))
			inDependency = false;
		    else {
			size_t pos;
			char *end;

			/* Need a new list for the target nodes.  */
			Array_Reset(&gtargets);
			inDependency = true;

			dep = NULL;
			/* First we need to find eventual dependencies */
			pos = strcspn(stripped, ":!");
			/* go over :!, and find ;  */
			if (stripped[pos] != '\0' &&
			    (end = strchr(stripped+pos+1, ';')) != NULL) {
				if (line != stripped)
				    /* find matching ; in original... The
				     * original might be slightly longer.  */
				    dep = strchr(line+(end-stripped), ';');
d1597 18
a1614 19
				    dep = end;
				/* kill end of line. */
				*end = '\0';
			}
			/* We now know it's a dependency line so it needs to
			 * have all variables expanded before being parsed.
			 * Tell the variable module to complain if some
			 * variable is undefined... */
			cp = Var_Subst(stripped, NULL, true);
			ParseDoDependency(cp);
			free(cp);

			/* Parse dependency if it's not empty. */
			if (dep != NULL) {
			    do {
				dep++;
			    } while (isspace(*dep));
			    if (*dep != '\0')
				ParseDoCommands(dep);
a1615 1
		    }
d1617 1
a1617 3
	    }
	}
    } while (Parse_NextFile());
d1619 8
a1626 8
    if (inDependency)
	ParseFinishDependency();
    /* Make sure conditionals are clean.  */
    Cond_End();

    Parse_ReportErrors();
    Buf_Destroy(&buf);
    Buf_Destroy(&copy);
@


1.89
log
@parseIncPath -> userIncludePath and assorted renames
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.88 2007/09/17 09:45:37 espie Exp $	*/
d1554 1
a1554 1
		    if (Parse_DoVar(stripped))
@


1.88
log
@more zap spaces
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.87 2007/09/17 09:44:20 espie Exp $	*/
d100 1
a100 1
static LIST	theParseIncPath;/* list of directories for "..." includes */
d102 2
a103 2
Lst sysIncPath = &theSysIncPath;
Lst parseIncPath = &theParseIncPath;
d1132 1
a1132 1
	Dir_AddDir(parseIncPath, dir);
d1142 1
a1142 1
		fullname = Dir_FindFileNoDot(file, sysIncPath);
d1162 1
a1162 1
			fullname = Dir_FindFile(newName, parseIncPath);
d1174 1
a1174 1
	fullname = Dir_FindFile(file, parseIncPath);
d1186 1
a1186 1
		return Dir_FindFile(file, sysIncPath);
d1615 2
a1616 2
	Static_Lst_Init(parseIncPath);
	Static_Lst_Init(sysIncPath);
d1631 2
a1632 2
	Lst_Destroy(sysIncPath, Dir_Destroy);
	Lst_Destroy(parseIncPath, Dir_Destroy);
@


1.87
log
@zap more spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.86 2007/09/17 09:38:49 espie Exp $	*/
d1619 1
a1619 1
	
@


1.86
log
@partial reindent
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.85 2007/09/17 09:28:36 espie Exp $	*/
d1139 1
a1139 1
	
@


1.85
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.84 2007/09/17 08:36:57 espie Exp $	*/
d285 5
a289 5
    if (Lst_AddNew(&pgn->children, cgn)) {
	if (specType == Not)
	    Lst_AtEnd(&cgn->parents, pgn);
	pgn->unmade++;
    }
d310 47
a356 46
    /*
     * If the dependency mask of the operator and the node don't match and
     * the node has actually had an operator applied to it before, and
     * the operator actually has some dependency information in it, complain.
     */
    if (((op & OP_OPMASK) != (gn->type & OP_OPMASK)) &&
	!OP_NOP(gn->type) && !OP_NOP(op)) {
	Parse_Error(PARSE_FATAL, "Inconsistent operator for %s", gn->name);
	return 0;
    }

    if (op == OP_DOUBLEDEP && ((gn->type & OP_OPMASK) == OP_DOUBLEDEP)) {
	/* If the node was the object of a :: operator, we need to create a
	 * new instance of it for the children and commands on this dependency
	 * line. The new instance is placed on the 'cohorts' list of the
	 * initial one (note the initial one is not on its own cohorts list)
	 * and the new instance is linked to all parents of the initial
	 * instance.  */
	GNode		*cohort;
	LstNode 	ln;
	unsigned int i;

	cohort = Targ_NewGN(gn->name);
	/* Duplicate links to parents so graph traversal is simple. Perhaps
	 * some type bits should be duplicated?
	 *
	 * Make the cohort invisible as well to avoid duplicating it into
	 * other variables. True, parents of this target won't tend to do
	 * anything with their local variables, but better safe than
	 * sorry.  */
	for (ln = Lst_First(&gn->parents); ln != NULL; ln = Lst_Adv(ln))
	    ParseLinkSrc((GNode *)Lst_Datum(ln), cohort);
	cohort->type = OP_DOUBLEDEP|OP_INVISIBLE;
	Lst_AtEnd(&gn->cohorts, cohort);

	/* Replace the node in the targets list with the new copy */
	for (i = 0; i < gtargets.n; i++)
	    if (gtargets.a[i] == gn)
		break;
	gtargets.a[i] = cohort;
	gn = cohort;
    }
    /* We don't want to nuke any previous flags (whatever they were) so we
     * just OR the new operator into the old.  */
    gn->type |= op;
    return 1;
d378 10
a387 10
    if (p->order < s->order) {
	/* XXX: This can cause loops, and loops can cause unmade targets,
	 * but checking is tedious, and the debugging output can show the
	 * problem.  */
	Lst_AtEnd(&p->successors, s);
	Lst_AtEnd(&s->preds, p);
	return 1;
    }
    else
	return 0;
d410 1
a410 1
    GNode	*gn = NULL;
d412 13
a424 12
    if (*src == '.' && isupper(src[1])) {
	int keywd = ParseFindKeyword(src);
	if (keywd != -1) {
	    int op = parseKeywords[keywd].op;
	    if (op != 0) {
	    	Array_Find(&gtargets, ParseDoOp, op);
		return;
	    }
	    if (parseKeywords[keywd].spec == Wait) {
		waiting++;
		return;
	    }
a425 1
    }
d427 17
a443 17
    switch (specType) {
    case Main:
	/*
	 * If we have noted the existence of a .MAIN, it means we need
	 * to add the sources of said target to the list of things
	 * to create. The string 'src' is likely to be freed, so we
	 * must make a new copy of it. Note that this will only be
	 * invoked if the user didn't specify a target on the command
	 * line. This is to allow #ifmake's to succeed, or something...
	 */
	Lst_AtEnd(create, estrdup(src));
	/*
	 * Add the name to the .TARGETS variable as well, so the user can
	 * employ that, if desired.
	 */
	Var_Append(".TARGETS", src);
	return;
d445 16
a460 15
    case Order:
	/*
	 * Create proper predecessor/successor links between the previous
	 * source and the current one.
	 */
	gn = Targ_FindNode(src, TARG_CREATE);
	if (predecessor != NULL) {
	    Lst_AtEnd(&predecessor->successors, gn);
	    Lst_AtEnd(&gn->preds, predecessor);
	}
	/*
	 * The current source now becomes the predecessor for the next one.
	 */
	predecessor = gn;
	break;
d462 13
a474 24
    default:
	/*
	 * If the source is not an attribute, we need to find/create
	 * a node for it. After that we can apply any operator to it
	 * from a special target or link it to its parents, as
	 * appropriate.
	 *
	 * In the case of a source that was the object of a :: operator,
	 * the attribute is applied to all of its instances (as kept in
	 * the 'cohorts' list of the node) or all the cohorts are linked
	 * to all the targets.
	 */
	gn = Targ_FindNode(src, TARG_CREATE);
	if (tOp) {
	    gn->type |= tOp;
	} else {
	    Array_ForEach(&gtargets, ParseLinkSrc, gn);
	}
	if ((gn->type & OP_OPMASK) == OP_DOUBLEDEP) {
	    GNode	*cohort;
	    LstNode	ln;

	    for (ln=Lst_First(&gn->cohorts); ln != NULL; ln = Lst_Adv(ln)){
		cohort = (GNode *)Lst_Datum(ln);
d476 1
a476 1
		    cohort->type |= tOp;
d478 16
a493 1
		    Array_ForEach(&gtargets, ParseLinkSrc, cohort);
d495 1
a495 1
	    }
a496 2
	break;
    }
d498 5
a502 5
    gn->order = waiting;
    Array_AtEnd(&gsources, gn);
    if (waiting) {
    	Array_Find(&gsources, ParseAddDep, gn);
    }
d524 8
a531 8
    GNode	  *gn = (GNode *)gnp;
    if ((gn->type & OP_NOTARGET) == 0) {
	mainNode = gn;
	Targ_SetMain(gn);
	return 0;
    } else {
	return 1;
    }
d546 1
a546 1
    Dir_AddDir((Lst)path, (char *)name);
d558 1
a558 1
    Lst 	path = (Lst)p;
d560 2
a561 2
    Lst_Destroy(path, Dir_Destroy);
    Lst_Init(path);
d1090 8
a1097 7
    GNode *gn = (GNode *)gnp;
    /* if target already supplied, ignore commands */
    if (!(gn->type & OP_HAS_COMMANDS)) {
	Lst_AtEnd(&gn->commands, cmd);
	if (!gn->lineno) {
	    gn->lineno = Parse_Getlineno();
	    gn->fname = Parse_Getfilename();
a1098 1
    }
d1116 4
a1119 4
    GNode *gn = (GNode *)gnp;
    if (!Lst_IsEmpty(&gn->commands)) {
	gn->type |= OP_HAS_COMMANDS;
    }
d1482 3
a1484 3
    Array_Every(&gtargets, Suff_EndTransform);
    Array_Every(&gtargets, ParseHasCommands);
    Array_Reset(&gtargets);
d1490 3
a1492 3
    /* add the command to the list of
     * commands of all targets in the dependency spec */
    char *cmd = estrdup(line);
d1494 1
a1494 1
    Array_ForEach(&gtargets, ParseAddCmd, cmd);
d1496 1
a1496 1
    Lst_AtEnd(&targCmds, cmd);
d1642 9
a1650 9
    if (mainNode == NULL) {
	Punt("no target to make.");
	/*NOTREACHED*/
    } else if (mainNode->type & OP_DOUBLEDEP) {
	Lst_AtEnd(listmain, mainNode);
	Lst_Concat(listmain, &mainNode->cohorts);
    }
    else
	Lst_AtEnd(listmain, mainNode);
@


1.84
log
@kill += 1, -= 1     -> ++, --
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.83 2007/09/16 12:30:35 espie Exp $	*/
d1145 1
a1145 1
		/* ... by looking first under the same directory as the 
d1156 1
a1156 1
			newName = Str_concati(fname, slash, file, 
d1186 1
a1186 1
handle_include_file(const char *name, const char *ename, bool isSystem, 
d1217 1
a1217 1
	char endc; 
d1252 1
a1252 1
lookup_sysv_style_include(const char *file, const char *directive, 
d1347 1
a1347 1
		Parse_Error(PARSE_WARNING, "Invalid syntax for .poison: %s", 
d1450 1
a1450 1
	case COND_ISFOR: 
d1456 1
a1456 1
	case COND_ISUNDEF: 
d1526 1
a1526 1
		if (*stripped == '.' && handle_bsd_command(&buf, &copy, 
d1529 1
a1529 1
		else if (FEATURES(FEATURE_SYSVINCLUDE) && 
d1536 1
a1536 1
		    strncmp(stripped, "sinclude", 8) == 0 && 
d1541 1
a1541 1
		    strncmp(stripped, "-include", 8) == 0 && 
@


1.83
log
@rename dirSearchPath -> defaultPath, and openDirectories -> knownDirectories
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.82 2007/09/16 10:57:02 espie Exp $	*/
d1051 1
a1051 1
		    cp += 1;
@


1.82
log
@kill .SHELL, make doesn't even support it in non-parallel mode.
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.81 2007/09/16 10:14:26 espie Exp $	*/
d740 1
a740 1
		 *	.PATH		Have to set the dirSearchPath
d769 1
a769 1
			Lst_AtEnd(&paths, dirSearchPath);
d1160 1
a1160 1
				fullname = Dir_FindFile(newName, dirSearchPath);
d1173 1
a1173 1
	fullname = Dir_FindFile(file, dirSearchPath);
@


1.81
log
@cut up dir.c into dir.c/direxpand.c as there is very little interface between
two modules that do different things.
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.80 2007/08/05 11:00:58 espie Exp $	*/
a138 1
    ExShell,	    /* .SHELL */
a195 1
{ ".SHELL",	  ExShell,	0 },
a940 6
	*line = '\0';
    } else if (specType == ExShell) {
	if (!Job_ParseShell(line)) {
	    Parse_Error(PARSE_FATAL, "improper shell specification");
	    return;
	}
@


1.80
log
@fix curly in targets... broke it and no-one saw the difference, so it's
probably not used that often.
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.72 2007/07/08 17:44:20 espie Exp $	*/
d73 1
@


1.79
log
@introduce a Var_Substi to substitute on intervals.
Since we don't really know how to change Var_Subst and dependent functions,
we cheat, and copy the string to a buffer instead.

Clean-up the parser a bit: reorganize the include files lookup function:
introduce a resolve_include_filename function that figures out the full name
of the file, introduce a handle_include_file that does all the include file
handling, and rename the functions into handle_xxx_include, so that we
can remove most comments.

Rename ParseIsCond into handle_bsd_command, cut most of its code into
constituent functions.

Semantic changes:
- follow the rules that, if an optional construct does not parse correctly,
then it's not a real extension, and give the normal parser a chance to figure
it out. If the syntax checks out, semantic errors ARE real errors.
- allow variables to not be defined in include file names, no reason not to.

okay miod@@
@
text
@d595 1
a595 1
			add_target_node(line);
@


1.78
log
@everywhere except in Var_Parse, we always add/append variables to the
VAR_GLOBAL context, so make it the common case: rename the basic functions
to Var_Set_with_ctxt/Var_Append_with_ctxt, define Var_Set and Var_Append
as macros that specify VAR_GLOBAL, and use these.

okay miod@@
@
text
@d218 3
a220 5
static void ParseDoInclude(char *);
static void ParseDoPoison(char *);
static void ParseTraditionalInclude(char *);
static void ParseConditionalInclude(char *);
static void ParseLookupIncludeFile(char *, char *, bool, bool);
d223 1
a223 1
static bool ParseIsCond(Buffer, Buffer, char *);
d225 6
a230 1
static char *find_include(const char *, bool);
d1125 7
a1131 7
/*-
 *-----------------------------------------------------------------------
 * Parse_AddIncludeDir --
 *	Add a directory to the path searched for included makefiles
 *	bracketed by double-quotes. Used by functions in main.c
 *-----------------------------------------------------------------------
 */
d1133 1
a1133 1
Parse_AddIncludeDir(const char	*dir)	/* The name of the directory to add */
d1135 1
a1135 1
    Dir_AddDir(parseIncPath, dir);
d1138 2
a1139 17
/*-
 *---------------------------------------------------------------------
 * ParseDoInclude  --
 *	Push to another file.
 *
 *	The input is the line minus the #include. A file spec is a string
 *	enclosed in <> or "". The former is looked for only in sysIncPath.
 *	The latter in . and the directories specified by -I command line
 *	options
 *
 * Side Effects:
 *	old parse context is pushed on the stack, new file becomes
 *	current context.
 *---------------------------------------------------------------------
 */
static void
ParseDoInclude(char	  *file)/* file specification */
d1141 32
a1172 13
    char	  endc; 	/* the character which ends the file spec */
    char	  *cp;		/* current position in file spec */
    bool	  isSystem;	/* true if makefile is a system makefile */

    /* Skip to delimiter character so we know where to look.  */
    while (*file == ' ' || *file == '\t')
	file++;

    if (*file != '"' && *file != '<') {
	Parse_Error(PARSE_FATAL,
	    ".include filename must be delimited by '\"' or '<'");
	return;
    }
d1174 9
a1182 10
    /* Set the search path on which to find the include file based on the
     * characters which bracket its name. Angle-brackets imply it's
     * a system Makefile while double-quotes imply it's a user makefile */
    if (*file == '<') {
	isSystem = true;
	endc = '>';
    } else {
	isSystem = false;
	endc = '"';
    }
d1184 6
a1189 10
    /* Skip to matching delimiter.  */
    for (cp = ++file; *cp != endc; cp++) {
	if (*cp == '\0') {
	    Parse_Error(PARSE_FATAL,
		     "Unclosed %cinclude filename. '%c' expected",
		     '.', endc);
	    return;
	}
    }
    ParseLookupIncludeFile(file, cp, isSystem, true);
a1191 15
/*-
 *---------------------------------------------------------------------
 * ParseTraditionalInclude  --
 *	Push to another file.
 *
 *	The input is the line minus the "include".  The file name is
 *	the string following the "include".
 *
 * Side Effects:
 *	old parse context is pushed on the stack, new file becomes
 *	current context.
 *
 *	XXX May wish to support multiple files and wildcards ?
 *---------------------------------------------------------------------
 */
d1193 2
a1194 1
ParseTraditionalInclude(char *file) 	/* file specification */
d1196 12
a1207 1
    char	  *cp;		/* current position in file spec */
d1209 2
a1210 11
    /* Skip over whitespace.  */
    while (isspace(*file))
	file++;
    if (*file == '\0') {
	Parse_Error(PARSE_FATAL,
		     "Filename missing from \"include\"");
	return;
    }
    /* Skip to end of line or next whitespace.	*/
    for (cp = file; *cp != '\0' && !isspace(*cp);)
	cp++;
d1212 6
a1217 1
    ParseLookupIncludeFile(file, cp, true, true);
d1220 3
a1222 11
/*-
 *---------------------------------------------------------------------
 * ParseConditionalInclude  --
 *	May push to another file.
 *
 *	No error if the file does not exist.
 *	See ParseTraditionalInclude otherwise.
 *---------------------------------------------------------------------
 */
static void
ParseConditionalInclude(char *file)/* file specification */
d1224 20
a1243 1
    char	  *cp;		/* current position in file spec */
d1245 11
a1255 11
    /* Skip over whitespace.  */
    while (isspace(*file))
	file++;
    if (*file == '\0') {
	Parse_Error(PARSE_FATAL,
		     "Filename missing from \"include\"");
	return;
    }
    /* Skip to end of line or next whitespace.	*/
    for (cp = file; *cp != '\0' && !isspace(*cp);)
	cp++;
a1256 2
    ParseLookupIncludeFile(file, cp, true, false);
}
d1258 3
a1260 3
/* helper function for ParseLookupIncludeFile */
static char *
find_include(const char *file, bool isSystem)
d1262 1
a1262 8
    char *fullname;
    
    /* Look up system files on the system path first */
    if (isSystem) {
	fullname = Dir_FindFileNoDot(file, sysIncPath);
	if (fullname)
	    return fullname;
    }
d1264 7
a1270 22
    /* Handle non-system non-absolute files... */
    if (!isSystem && file[0] != '/') {
	/* ... by first searching relative to the including file's
	 * location. We don't want to cd there, of course, so we
	 * just tack on the old file's leading path components
	 * and call Dir_FindFile to see if we can locate the beast.  */
	char		*slash;
	const char	*fname;

	fname = Parse_Getfilename();

	slash = strrchr(fname, '/');
	if (slash != NULL) {
	    char *newName;

	    newName = Str_concati(fname, slash, file, strchr(file, '\0'), '/');
	    fullname = Dir_FindFile(newName, parseIncPath);
	    if (fullname == NULL)
		fullname = Dir_FindFile(newName, dirSearchPath);
	    free(newName);
	    if (fullname)
	    	return fullname;
d1272 3
a1274 1
    }
d1276 1
a1276 16
    /* Now look first on the -I search path, then on the .PATH
     * search path, if not found in a -I directory.
     * XXX: Suffix specific?  */
    fullname = Dir_FindFile(file, parseIncPath);
    if (fullname)
    	return fullname;
    fullname = Dir_FindFile(file, dirSearchPath);
    if (fullname)
    	return fullname;

    /* Still haven't found the makefile. Look for it on the system
     * path as a last resort.  */
    if (isSystem)
    	return NULL;
    else
	return Dir_FindFile(file, sysIncPath);
d1279 2
a1280 1
/* Common part to lookup and read an include file.  */
d1282 1
a1282 2
ParseLookupIncludeFile(char *spec, char *endSpec, bool isSystem, 
    bool errIfNotFound)
d1284 2
a1285 15
    char *file;
    char *fullname;
    char endc;

    /* Substitute for any variables in the file name before trying to
     * find the thing.	*/
    endc = *endSpec;
    *endSpec = '\0';
    file = Var_Subst(spec, NULL, false);
    *endSpec = endc;

    fullname = find_include(file, isSystem);
    if (fullname == NULL && errIfNotFound)
	Parse_Error(PARSE_FATAL, "Could not find %s", file);
	
a1286 1
    free(file);
d1288 5
a1292 14
    if (fullname != NULL) {
	FILE *f;

	f = fopen(fullname, "r");
	if (f == NULL && errIfNotFound) {
	    Parse_Error(PARSE_FATAL, "Cannot open %s", fullname);
	} else {
	    /* Once we find the absolute path to the file, we push the current
	     * stream to the includes stack, and start reading from the new
	     * file.  We set up the file name to be its absolute name so that
	     * error messages are informative.	*/
	    Parse_FromFile(fullname, f);
	}
    }
d1296 2
a1297 2
static void
ParseDoPoison(char *line)
d1299 1
a1299 1
	char *p = line;
d1303 1
a1303 1
	char *name, *ename;
d1353 2
a1354 2
	if ((*p != '\0' && *p != '#') || type == POISON_INVALID)
		Parse_Error(PARSE_FATAL, "Invalid syntax for .poison: %s", 
d1356 5
a1360 1
	Var_MarkPoisoned(name, ename, type);
d1364 1
a1364 2
/* Strip comments from the line. May return either a copy of the line, or
 * the line itself.  */
d1368 2
a1369 2
    const char *comment;
    const char *p;
d1371 18
a1388 13
    comment = strchr(line, '#');
    assert(comment != line);
    if (comment == NULL)
	return (char *)line;
    else {
	Buf_Reset(copy);

	for (p = line; *p != '\0'; p++) {
	    if (*p == '\\') {
		if (p[1] == '#') {
		    Buf_Addi(copy, line, p);
		    Buf_AddChar(copy, '#');
		    line = p+2;
d1390 3
a1392 4
		if (p[1] != '\0')
		    p++;
	    } else if (*p == '#')
		break;
a1393 4
	Buf_Addi(copy, line, p);
	Buf_KillTrailingSpaces(copy);
	return Buf_Retrieve(copy);
    }
d1397 1
a1397 1
ParseIsCond(Buffer linebuf, Buffer copy, char *line)
d1399 1
d1401 18
a1418 1
    char	*stripped;
d1420 4
a1423 2
    while (isspace(*line))
	line++;
d1425 5
a1429 15
    /* The line might be a conditional. Ask the conditional module
     * about it and act accordingly.  */
    switch (Cond_Eval(line)) {
    case COND_SKIP:
	/* Skip to next conditional that evaluates to COND_PARSE.  */
	do {
	    line = Parse_ReadNextConditionalLine(linebuf);
	    if (line != NULL) {
		while (isspace(*line))
		    line++;
		    stripped = strip_comments(copy, line);
	    }
	} while (line != NULL && Cond_Eval(stripped) != COND_PARSE);
	/* FALLTHROUGH */
    case COND_PARSE:
d1431 1
a1431 2
    case COND_ISFOR: {
	For *loop;
d1433 4
a1436 26
	loop = For_Eval(line+3);
	if (loop != NULL) {
	    bool ok;
	    do {
		/* Find the matching endfor.  */
		line = ParseReadLoopLine(linebuf);
		if (line == NULL) {
		    Parse_Error(PARSE_FATAL,
			     "Unexpected end of file in for loop.\n");
		    return false;
		}
		ok = For_Accumulate(loop, line);
	    } while (ok);
	    For_Run(loop);
	    return true;
	}
	break;
    }
    case COND_ISINCLUDE:
	ParseDoInclude(line + 7);
	return true;
    case COND_ISPOISON:
    	ParseDoPoison(line + 6);
	return true;
    case COND_ISUNDEF: {
	char *cp;
a1437 1
	line+=5;
d1439 29
a1467 9
	    line++;
	for (cp = line; !isspace(*cp) && *cp != '\0';)
	    cp++;
	Var_Deletei(line, cp);
	return true;
    }
    default:
	break;
    }
d1469 1
a1469 1
    return false;
d1533 3
a1535 2
		if (*stripped == '.' && ParseIsCond(&buf, &copy, stripped+1))
		    ;
d1541 1
a1541 1
			ParseTraditionalInclude(stripped + 7);
d1543 1
a1543 2
		    (*stripped == '-' || *stripped == 's') &&
		    strncmp(stripped+1, "include", 7) == 0 && 
d1546 6
a1551 1
		    	ParseConditionalInclude(stripped+8);
d1617 7
a1623 7
    mainNode = NULL;
    Static_Lst_Init(parseIncPath);
    Static_Lst_Init(sysIncPath);
    Array_Init(&gsources, SOURCES_SIZE);
    Array_Init(&gtargets, TARGETS_SIZE);
    
    LowParse_Init();
d1625 1
a1625 1
    Static_Lst_Init(&targCmds);
d1633 4
a1636 4
    Lst_Destroy(&targCmds, (SimpleProc)free);
    Lst_Destroy(sysIncPath, Dir_Destroy);
    Lst_Destroy(parseIncPath, Dir_Destroy);
    LowParse_End();
@


1.77
log
@separate and name functions to add target nodes to the graph.

okay miod@@
@
text
@d439 1
a439 1
	Var_Append(".TARGETS", src, VAR_GLOBAL);
@


1.76
log
@simplify computations in the var module: instead of advancing a char *
and keeping track of a length, we just advance the char *, and ditch
the length. We can still get the length at the end of the top-level
functions to satisfy existing interfaces.

Much simpler code, less error-prone.

Okay millert@@
@
text
@d212 3
d558 42
d829 1
a829 37
	    char *targName;

	    if (Dir_HasWildcards(line)) {
		/*
		 * Targets are to be sought only in the current directory,
		 * so create an empty path for the thing. Note we need to
		 * use Dir_Destroy in the destruction of the path as the
		 * Dir module could have added a directory to the path...
		 */
		LIST	    emptyPath;
		LIST	    curTargs;	/* list of target names to be found 
					 * and added to the targets list */

		Lst_Init(&emptyPath);
		Lst_Init(&curTargs);
		Dir_Expand(line, &emptyPath, &curTargs);
		Lst_Destroy(&emptyPath, Dir_Destroy);
	    while ((targName = (char *)Lst_DeQueue(&curTargs)) != NULL) {
		    if (!Suff_IsTransform(targName))
		    gn = Targ_FindNode(targName, TARG_CREATE);
		    else
		    gn = Suff_AddTransform(targName);

		    if (gn != NULL)
			Array_AtEnd(&gtargets, gn);
		}
		Lst_Destroy(&curTargs, NOFREE);
	    } else {
		if (!Suff_IsTransform(line))
		    gn = Targ_FindNode(line, TARG_CREATE);
		else
		    gn = Suff_AddTransform(line);

		if (gn != NULL)
		    Array_AtEnd(&gtargets, gn);
		/* Don't need the list of target names anymore...  */
	    }
@


1.75
log
@move the code that grabs a value in Var_Parse in its own function,
get_expanded_value.

Extend the code a bit to be much more thorough in case of a recursive
expansion: shows exactly the cycle of variable names involved.

okay millert@@
@
text
@@


1.74
log
@change Var_ParseSkip API to increment the position instead of returning a
length, simplifies code.

(warns a bit, symptom of some further issues to fix).

okay millert@@
@
text
@@


1.73
log
@big clean-up patch:
- rename a few functions in var.c to names that make more sense.
- introduce Var_Deletei because it makes more sense.
- rewrite .for loops to use a local LoopVar construct to avoid looking up more
stuff.
- reformat var.c to near K&R
- rewrite most comments in var.c

shown to a few people. millert@@ gave me his okay since it passes through
ports correctly.
@
text
@d612 1
a612 1
		cp += Var_ParseSkip(cp, NULL, NULL);
@


1.72
log
@A set of big related changes. okay millert@@, tested further by kettenis@@
and matthieu@@

This all revolves around putting ALL global variables into one single big
hash, and using flags. This removes some impossible to understand stuff,
like old varfind, and allows for some nice stuff.
- each time we reference a global variable, we create it, possibly as a dummy
variable.
- each time we go to the environment, we remember it, thus we no longer go
back to it.

Lists of dependant changes:
- isolate changes to oldVars and checkEnvFirst.
- remove VAR_CMD and VAR_GLOBAL contexts. The only distinction is in parsevar.
Split Parse_DoVar into Parse_DoVar and Parse_CmdlineVar
- rework var modules around obtain_global_var, observe flags in various
functions like Var_Value and Var_Seti.
- Var_Seti/Var_Appendi are almost the same code, use that internally.
- add magic to handle the very special SHELL variable.
- introduce Var_Definedi for the cases where we don't want the actual
value, to simplify tests.
- add keyword .poison, parse it and set global flags accordingly.
- do poison_checks where needed.
- document poison.
- in for loops, set variable temporarily, so that Var_SubstVar will also
substitute it in varmodifiers expressions.
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.71 2007/03/20 03:50:39 tedu Exp $	*/
d1498 1
a1498 2
	*cp = '\0';
	Var_Delete(line);
@


1.71
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.70 2007/01/18 17:49:51 espie Exp $	*/
d216 1
d1341 62
d1487 3
d1589 1
a1589 1
		    if (Parse_DoVar(stripped, VAR_GLOBAL))
@


1.70
log
@* add an extra argument to the dir lookup functions to say whether we
should look in the current directory.
* refactor include files treatment to have a separate function to look
for an include.
* use both pieces to make sure system includes do not get looked up
in the current directory unless everything else fails.

This is != from the netbsd solution to the same problem, which stuffs
`magic' entries into filepaths to say whether dot should be looked at
first or last.

feature requested by matthieu@@.
okay matthieu@@
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.69 2004/04/07 13:11:36 espie Exp $	*/
d841 1
a841 1
	    while (*cp && isspace(*cp)) {
d888 1
a888 1
    while (*cp && isspace(*cp)) {
d1000 1
a1000 1
	    while (*cp && isspace(*cp)) {
d1050 1
a1050 1
	    while (*cp && isspace(*cp)) {
d1381 1
a1381 1
    while (*line != '\0' && isspace(*line))
d1392 1
a1392 1
		while (*line != '\0' && isspace(*line))
d1428 1
a1428 1
	while (*line != '\0' && isspace(*line))
@


1.69
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.68 2003/06/03 02:56:12 millert Exp $	*/
d223 1
d1244 3
a1246 4
/* Common part to lookup and read an include file.  */
static void
ParseLookupIncludeFile(char *spec, char *endSpec, bool isSystem, 
    bool errIfNotFound)
a1247 1
    char *file;
d1249 7
a1255 13
    char endc;

    /* Substitute for any variables in the file name before trying to
     * find the thing.	*/
    endc = *endSpec;
    *endSpec = '\0';
    file = Var_Subst(spec, NULL, false);
    *endSpec = endc;

    /* Now that we know the file name and its search path, we attempt to
     * find the durn thing. NULL indicates the file still hasn't been
     * found.  */
    fullname = NULL;
d1277 2
d1285 6
a1290 4
    if (fullname == NULL)
	fullname = Dir_FindFile(file, parseIncPath);
    if (fullname == NULL)
	fullname = Dir_FindFile(file, dirSearchPath);
d1294 21
a1314 2
    if (fullname == NULL)
	fullname = Dir_FindFile(file, sysIncPath);
d1316 1
d1318 1
a1318 1
	    Parse_Error(PARSE_FATAL, "Could not find %s", file);
@


1.68
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.67 2002/06/11 21:12:11 espie Exp $	*/
d236 1
a236 2
ParseFindKeyword(str)
    const char	    *str;		/* String to find */
d274 3
a276 3
ParseLinkSrc(pgn, cgn)
    GNode		*pgn;	/* The parent node */
    GNode		*cgn;	/* The child node */
d299 3
a301 4
ParseDoOp(gn, op)
    GNode	   *gn;	/* The node to which the operator is to be
				 * applied */
    int	   	   op;	/* The operator to apply */
d368 1
a368 3
ParseAddDep(p, s)
    GNode *p;
    GNode *s;
d398 3
a400 4
ParseDoSrc(tOp, src)
    int 	tOp;	/* operator (if any) from special targets */
    const char	*src;	/* name of the source to handle */

d509 3
a511 3
ParseFindMain(gnp, dummy)
    void *gnp;	    /* Node to examine */
    void *dummy 	UNUSED;
d533 1
a533 3
ParseAddDir(path, name)
    void *path;
    void *name;
d545 1
a545 2
ParseClearPath(p)
    void	*p;
d585 1
a585 2
ParseDoDependency(line)
    char	   *line;	/* the line to parse */
d1075 3
a1077 3
ParseAddCmd(gnp, cmd)
    void *gnp;	/* the node to which the command is to be added */
    void *cmd;	/* the command to add */
d1103 1
a1103 2
ParseHasCommands(gnp)
    void *gnp;	    /* Node to examine */
d1119 1
a1119 2
Parse_AddIncludeDir(dir)
    const char	*dir;	/* The name of the directory to add */
d1140 1
a1140 2
ParseDoInclude(file)
    char	  *file;	/* file specification */
d1195 1
a1195 2
ParseTraditionalInclude(file)
    char	  *file;	/* file specification */
d1224 1
a1224 2
ParseConditionalInclude(file)
    char	  *file;	/* file specification */
d1245 2
a1246 5
ParseLookupIncludeFile(spec, endSpec, isSystem, errIfNotFound)
    char *spec;
    char *endSpec;
    bool isSystem;
    bool errIfNotFound;
d1328 1
a1328 3
strip_comments(copy, line)
    Buffer copy;
    const char *line;
d1359 1
a1359 4
ParseIsCond(linebuf, copy, line)
    Buffer	linebuf;
    Buffer	copy;
    char	*line;
d1437 1
a1437 1
ParseFinishDependency()
d1445 1
a1445 2
ParseDoCommands(line)
    const char *line;
d1458 3
a1460 3
Parse_File(name, stream)
    const char	  *name;	/* the name of the file being read */
    FILE	  *stream;	/* Stream open to makefile to parse */
d1564 1
a1564 1
Parse_Init()
d1580 1
a1580 1
Parse_End()
d1591 1
a1591 2
Parse_MainName(listmain)
    Lst 	  listmain;	/* result list */
@


1.67
log
@This is the first step in sanitizing the conditional parser.

Change the conditional recognition algorithm:
scan for a sequence of alphabetic characters, hash it, and compare it against
a small table (using ohash functions).
This makes Cond_Eval entry more logical, and allows for some shortcuts in
recognizing .include, .for, .undef.

This also means that conditionals must have an intervening blank between
the keyword and the actual test, e.g.,
.ifA
will no longer work.

(but no-one actually uses this, and it's highly obfuscated)

Okay miod@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.66 2001/11/11 12:35:02 espie Exp $	*/
d48 1
a48 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.66
log
@Fixed version... don't see how this could work on i386, since it didn't
initialize create in main.c.
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.65 2001/11/11 06:02:06 deraadt Exp $	*/
d1409 19
a1427 1
    default:
d1430 1
a1430 23

    {
    For *loop;

    loop = For_Eval(line);
    if (loop != NULL) {
	bool ok;
	do {
	    /* Find the matching endfor.  */
	    line = ParseReadLoopLine(linebuf);
	    if (line == NULL) {
		Parse_Error(PARSE_FATAL,
			 "Unexpected end of file in for loop.\n");
		return false;
	    }
	    ok = For_Accumulate(loop, line);
	} while (ok);
	For_Run(loop);
	return true;
    }
    }

    if (strncmp(line, "include", 7) == 0) {
d1433 1
a1433 1
    } else if (strncmp(line, "undef", 5) == 0) {
d1445 4
@


1.65
log
@undo changes that crash on (at least) the alpha
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.63 2001/06/12 22:44:21 espie Exp $	*/
d1594 2
a1595 2
    Lst_Init(parseIncPath);
    Lst_Init(sysIncPath);
d1601 1
a1601 1
    Lst_Init(&targCmds);
@


1.64
log
@Redo LstInit as a macro: smaller and faster code in all cases, zeroing two
pointers is simpler than calling a function.
Recognize purely static lst headers, which don't really need any
initialization.
ok miod@@
@
text
@d1594 2
a1595 2
    Static_Lst_Init(parseIncPath);
    Static_Lst_Init(sysIncPath);
d1601 1
a1601 1
    Static_Lst_Init(&targCmds);
@


1.63
log
@Replace the most used static lists in make by persistent growable arrays.
5% speed increase on a make build.
ok miod@@
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.62 2001/05/29 12:53:42 espie Exp $	*/
d1594 2
a1595 2
    Lst_Init(parseIncPath);
    Lst_Init(sysIncPath);
d1601 1
a1601 1
    Lst_Init(&targCmds);
@


1.62
log
@Take includes out of lst.h, re-add what's needed to separate files.
Removes remaining lint stuff from lst.lib.
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.61 2001/05/23 12:34:47 espie Exp $	*/
d95 7
a107 1
static LIST	    targets;	/* targets we're working on */
d210 3
a212 3
static int ParseDoOp(void *, void *);
static int ParseAddDep(void *, void *);
static void ParseDoSrc(int, const char *, Lst);
d304 2
a305 2
ParseDoOp(gnp, opp)
    void	   *gnp;	/* The node to which the operator is to be
d307 1
a307 1
    void	   *opp;	/* The operator to apply */
a308 2
    GNode	   *gn = (GNode *)gnp;
    int 	    op = *(int *)opp;
d329 1
d345 4
a348 2
	ln = Lst_Member(&targets, gn);
	Lst_Replace(ln, cohort);
d374 3
a376 3
ParseAddDep(pp, sp)
    void *pp;
    void *sp;
a377 3
    GNode *p = (GNode *)pp;
    GNode *s = (GNode *)sp;

d406 1
a406 1
ParseDoSrc(tOp, src, allsrc)
a408 1
    Lst 	allsrc; /* List of all sources to wait for */
d418 1
a418 1
		Lst_Find(&targets, ParseDoOp, &op);
d478 1
a478 4
	    LstNode	ln;

	    for (ln = Lst_First(&targets); ln != NULL; ln = Lst_Adv(ln))
		ParseLinkSrc((GNode *)Lst_Datum(ln), gn);
d489 1
a489 4
		    LstNode	ln;

		    for (ln = Lst_First(&targets); ln != NULL; ln = Lst_Adv(ln))
			ParseLinkSrc((GNode *)Lst_Datum(ln), cohort);
d497 1
a497 1
    Lst_AtEnd(allsrc, gn);
d499 1
a499 1
	Lst_Find(allsrc, ParseAddDep, gn);
a606 4
    LIST	    curTargs;	/* list of target names to be found and added
				 * to the targets list */
    LIST	    curSrcs;	/* list of sources in order */

d613 1
a613 2
    Lst_Init(&curTargs);
    Lst_Init(&curSrcs);
d659 2
d669 1
a669 1
	    if (!Arch_ParseArchive(&line, &targets, NULL)) {
d674 2
d745 1
a745 1
			Lst_AtEnd(&targets, gn);
d750 1
a750 1
			Lst_AtEnd(&targets, gn);
d805 2
d809 1
a811 8
	    } else {
		/*
		 * No wildcards, but we want to avoid code duplication,
		 * so create a list with the word on it.
		 */
		Lst_AtEnd(&curTargs, line);
	    }

d813 1
a813 1
		if (!Suff_IsTransform(targName)) {
d815 1
a815 1
		} else {
d817 3
d821 6
d829 2
a830 1
		    Lst_AtEnd(&targets, gn);
d832 1
a832 1
	} else if (specType == ExPath && *line != '.' && *line != '\0') {
a833 1
	}
d860 1
a860 6
    /*
     * Don't need the list of target names anymore...
     */
    Lst_Destroy(&curTargs, NOFREE);

    if (!Lst_IsEmpty(&targets)) {
d895 1
a895 1
    Lst_Find(&targets, ParseDoOp, &op);
d1052 1
a1052 1
		    ParseDoSrc(tOp, gn->name, &curSrcs);
d1060 1
a1060 1
		ParseDoSrc(tOp, line, &curSrcs);
d1074 1
a1074 1
	Lst_Find(&targets, ParseFindMain, NULL);
a1077 1
    Lst_Destroy(&curSrcs, NOFREE);
d1465 3
a1467 2
    Lst_Every(&targets, Suff_EndTransform);
    Lst_Destroy(&targets, ParseHasCommands);
d1478 1
a1478 1
    Lst_ForEach(&targets, ParseAddCmd, cmd);
d1540 1
a1540 1
			Lst_Init(&targets);
d1596 3
a1598 1
    Lst_Init(&targets);
a1609 1
    Lst_Destroy(&targets, NOFREE);
@


1.61
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.21 1999/10/05 22:08:07 espie Exp $	*/
d72 1
@


1.60
log
@thinko in my rewrite. Repair var:sh = something

Looks like nobody is using this anyways.
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.59 2001/05/03 13:41:08 espie Exp $	*/
a68 47
/*-
 * parse.c --
 *	Functions to parse a makefile.
 *
 *	One function, Parse_Init, must be called before any functions
 *	in this module are used. After that, the function Parse_File is the
 *	main entry point and controls most of the other functions in this
 *	module.
 *
 *	Most important structures are kept in Lsts. Directories for
 *	the #include "..." function are kept in the 'parseIncPath' Lst, while
 *	those for the #include <...> are kept in the 'sysIncPath' Lst. The
 *	targets currently being defined are kept in the 'targets' Lst.
 *
 *	The variables 'fname' and 'lineno' are used to track the name
 *	of the current file and the line number in that file so that error
 *	messages can be more meaningful.
 *
 * Interface:
 *	Parse_Init		    Initialization function which must be
 *				    called before anything else in this module
 *				    is used.
 *
 *	Parse_End		    Cleanup the module
 *
 *	Parse_File		    Function used to parse a makefile. It must
 *				    be given the name of the file, which should
 *				    already have been opened, and a function
 *				    to call to read a character from the file.
 *
 *	Parse_IsVar		    Returns TRUE if the given line is a
 *				    variable assignment. Used by MainParseArgs
 *				    to determine if an argument is a target
 *				    or a variable assignment. Used internally
 *				    for pretty much the same thing...
 *
 *	Parse_Error		    Function called when an error occurs in
 *				    parsing. Used by the variable and
 *				    conditional modules.
 *	Parse_MainName		    Returns a Lst of the main target to create.
 */

#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif
d70 1
a70 1
#include <stddef.h>
d72 3
a74 4
#include <ctype.h>
#include <errno.h>
#include "make.h"
#include "ohash.h"
d78 1
a78 1
#include "pathnames.h"
d80 19
a98 12

#ifndef lint
#if 0
static char sccsid[] = "@@(#)parse.c	8.3 (Berkeley) 3/19/94";
#else
UNUSED
static char rcsid[] = "$OpenBSD: parse.c,v 1.59 2001/05/03 13:41:08 espie Exp $";
#endif
#endif /* not lint */

LIST		parseIncPath;	/* list of directories for "..." includes */
LIST		sysIncPath;	/* list of directories for <...> includes */
a102 1
static LIST	    fileNames;
d215 2
a216 2
static void ParseLookupIncludeFile(char *, char *, Boolean, Boolean);
#define ParseGetLoopLine(linebuf)	ParseGetLine(linebuf, "for loop")
d218 1
a218 1
static Boolean ParseIsCond(Buffer, Buffer, char *);
a221 2
static const char *find_op1(const char *);
static const char *find_op2(const char *);
d276 1
a276 1
    if (Lst_AddNew(&pgn->children, cgn) == SUCCESS) {
d325 1
a325 1
	cohort = Targ_NewGN(gn->name, NULL);
d429 1
a429 1
	 * to create. The string 'src' is likely to be free, so we
d434 1
a434 1
	Lst_AtEnd(&create, estrdup(src));
d436 1
a436 1
	 * Add the name to the .TARGETS variable as well, so the user cna
d447 1
a447 1
	gn = Targ_FindNode(src, NULL, TARG_CREATE);
d470 1
a470 1
	gn = Targ_FindNode(src, NULL, TARG_CREATE);
d548 1
a548 1
    Dir_AddDir((Lst)path, (char *)name, NULL);
d671 2
a672 2
	     * and places them on the given list, returning SUCCESS if all
	     * went well and FAILURE if there was an error in the
d674 1
a674 1
	    if (Arch_ParseArchive(&line, &targets, NULL) != SUCCESS) {
d736 1
a736 1
			Lst_AtEnd(&paths, &dirSearchPath);
d739 1
a739 1
			if (!Lst_IsEmpty(&create)) {
d746 1
a746 1
			gn = Targ_FindNode(line, NULL, TARG_CREATE);
d751 1
a751 1
			gn = Targ_NewGN(".DEFAULT", NULL);
d822 1
a822 1
		    gn = Targ_FindNode(targName, NULL, TARG_CREATE);
d840 1
a840 1
	    Boolean warn = FALSE;
d844 1
a844 1
		    warn = TRUE;
d924 1
a924 1
		allPrecious = TRUE;
d927 1
a927 1
		ignoreErrors = TRUE;
d930 1
a930 1
		beSilent = TRUE;
d947 1
a947 1
	if (Job_ParseShell(line) != SUCCESS) {
d1049 1
a1049 1
		if (Arch_ParseArchive(&line, &sources, NULL) != SUCCESS) {
a1085 235
 *---------------------------------------------------------------------
 * Parse_IsVar	--
 *	Return TRUE if the passed line is a variable assignment. A variable
 *	assignment consists of a single word followed by optional whitespace
 *	followed by either a += or an = operator.
 *	This function is used both by the Parse_File function and main when
 *	parsing the command-line arguments.
 *
 * Results:
 *	TRUE if it is. FALSE if it ain't
 *---------------------------------------------------------------------
 */
Boolean
Parse_IsVar(line)
    char  *line;	/* the line to check */
{
    Boolean wasSpace = FALSE;	/* set TRUE if found a space */
    Boolean haveName = FALSE;	/* Set TRUE if have a variable name */
    int level = 0;
#define ISEQOPERATOR(c) \
	((c) == '+' || (c) == ':' || (c) == '?' || (c) == '!')

    for (; *line != '=' || level != 0; line++)
	switch (*line) {
	case '\0':
	    /* end-of-line -- can't be a variable assignment.  */
	    return FALSE;

	case ' ':
	case '\t':
	    /*
	     * there can be as much white space as desired so long as there is
	     * only one word before the operator
	     */
	    wasSpace = TRUE;
	    break;

	case '(':
	case '{':
	    level++;
	    break;

	case '}':
	case ')':
	    level--;
	    break;

	default:
	    if (wasSpace && haveName) {
		    if (ISEQOPERATOR(*line)) {
			/* We must have a finished word.  */
			if (level != 0)
			    return FALSE;

			/* When an = operator [+?!:] is found, the next
			 * character must be an = or it ain't a valid
			 * assignment.	*/
			if (line[1] == '=')
			    return haveName;
			/* This is a shell command.  */
			if (FEATURES(FEATURE_SUNSHCMD) && 
			    strncmp(line, ":sh", 3) == 0)
			    return haveName;
		    }
		    /* This is the start of another word, so not assignment.  */
		    return FALSE;
	    }
	    else {
		haveName = TRUE;
		wasSpace = FALSE;
	    }
	    break;
	}

    return haveName;
}

static const char *
find_op1(p)
    const char *p;
{
    for(;; p++) {
    	if (*p == '=' || isspace(*p) || *p == '$')
	    break;
	if (p[1] == '=' && (*p == '?' || *p == ':' || *p == '!' || *p == '+'))
	    break;
	if (p[0] == ':' && p[1] == 's' && p[2] == 'h')
	    break;
    }
    return p;
}

static const char *
find_op2(p)
    const char *p;
{
    for(;; p++) {
    	if (*p == '=' || isspace(*p) || *p == '$')
	    break;
	if (p[1] == '=' && (*p == '?' || *p == ':' || *p == '!' || *p == '+'))
	    break;
    }
    return p;
}

/*-
 *---------------------------------------------------------------------
 * Parse_DoVar	--
 *	Take the variable assignment in the passed line and do it in the
 *	global context.
 *
 *	Note: There is a lexical ambiguity with assignment modifier characters
 *	in variable names. This routine interprets the character before the =
 *	as a modifier. Therefore, an assignment like
 *	    C++=/usr/bin/CC
 *	is interpreted as "C+ +=" instead of "C++ =".
 *
 * Side Effects:
 *	the variable structure of the given variable name is altered in the
 *	global context.
 *---------------------------------------------------------------------
 */
void
Parse_DoVar(line, ctxt)
    const char	    *line;	/* a line guaranteed to be a variable
				 * assignment. This reduces error checks */
    GSymT	    *ctxt;    /* Context in which to do the assignment */
{
    const char	    *end;
    const char	    *arg;
    enum {
	VAR_SUBST, VAR_APPEND, VAR_SHELL, VAR_NORMAL
    }		    type;	/* Type of assignment */
    struct Name	    name;

    end = Var_Name_Get(line, &name, (SymTable *)ctxt, TRUE,
	FEATURES(FEATURE_SUNSHCMD) ? find_op1 : find_op2);

    while (isspace(*end))
    	end++;

    /* Check operator type.  */
    switch (*end) {
	case '+':
	    type = VAR_APPEND;
	    break;

	case '?':
	    /* If the variable already has a value, we don't do anything.  */
	    if (Var_Value_interval(name.s, name.e) != NULL) {
	    	Var_Name_Free(&name);
		return;
	    }
	    type = VAR_NORMAL;
	    break;

	case ':':
	    if (FEATURES(FEATURE_SUNSHCMD) && strncmp(end, ":sh", 3) == 0)
		type = VAR_SHELL;
	    else 
		type = VAR_SUBST;
	    break;

	case '!':
	    type = VAR_SHELL;
	    break;

	default:
	    type = VAR_NORMAL;
	    break;
    }

    /* Find operator itself and go over it.  */
    arg = end;
    while (*arg != '=')
    	arg++;
    arg++;
    while (isspace(*arg))
	arg++;

    if (type == VAR_APPEND)
	Var_Append_interval(name.s, name.e, arg, ctxt);
    else if (type == VAR_SUBST) {
	char *sub;
	/*
	 * Allow variables in the old value to be undefined, but leave their
	 * invocation alone -- this is done by forcing oldVars to be false.
	 * XXX: This can cause recursive variables, but that's not hard to do,
	 * and this allows someone to do something like
	 *
	 *  CFLAGS = $(.INCLUDES)
	 *  CFLAGS := -I.. $(CFLAGS)
	 *
	 * And not get an error.
	 */
	Boolean   oldOldVars = oldVars;

	oldVars = FALSE;
	/* ensure the variable is set to something to avoid `variable
	 * is recursive' errors.  */
	if (Var_Value_interval(name.s, name.e) == NULL)
	    Var_Set_interval(name.s, name.e, "", ctxt);

	sub = Var_Subst(arg, (SymTable *)ctxt, FALSE);
	oldVars = oldOldVars;

	Var_Set_interval(name.s, name.e, sub, ctxt);
	free(sub);
    } else if (type == VAR_SHELL) {
	char *res, *err;

	if (strchr(arg, '$') != NULL) {
	    char *sub;
	    /* There's a dollar sign in the command, so perform variable
	     * expansion on the whole thing. */
	    sub = Var_Subst(arg, NULL, TRUE);
	    res = Cmd_Exec(sub, &err);
	    free(sub);
	} else
	    res = Cmd_Exec(arg, &err);

	Var_Set_interval(name.s, name.e, res, ctxt);
	free(res);

	if (err)
	    Parse_Error(PARSE_WARNING, err, arg);

    } else
	/* Normal assignment -- just do it.  */
	Var_Set_interval(name.s, name.e, arg, ctxt);
    Var_Name_Free(&name);
}


/*-
d1141 1
a1141 1
    Dir_AddDir(&parseIncPath, dir, NULL);
d1165 1
a1165 1
    Boolean	  isSystem;	/* TRUE if makefile is a system makefile */
d1181 1
a1181 1
	isSystem = TRUE;
d1184 1
a1184 1
	isSystem = FALSE;
d1197 1
a1197 1
    ParseLookupIncludeFile(file, cp, isSystem, TRUE);
d1233 1
a1233 1
    ParseLookupIncludeFile(file, cp, TRUE, TRUE);
d1263 1
a1263 1
    ParseLookupIncludeFile(file, cp, TRUE, FALSE);
d1271 2
a1272 2
    Boolean isSystem;
    Boolean errIfNotFound;
d1282 1
a1282 1
    file = Var_Subst(spec, NULL, FALSE);
d1296 2
a1297 1
	char	  *slash;
d1299 3
a1301 1
	slash = strrchr(Parse_Getfilename(), '/');
d1303 1
a1303 1
	    char *base, *newName;
d1305 2
a1306 4
	    base = interval_dup(Parse_Getfilename(), slash);
	    newName = str_concat(base, file, '/');
	    free(base);
	    fullname = Dir_FindFile(newName, &parseIncPath);
d1308 1
a1308 1
		fullname = Dir_FindFile(newName, &dirSearchPath);
d1317 1
a1317 1
	fullname = Dir_FindFile(file, &parseIncPath);
d1319 1
a1319 1
	fullname = Dir_FindFile(file, &dirSearchPath);
d1324 1
a1324 1
	fullname = Dir_FindFile(file, &sysIncPath);
d1371 1
a1371 1
		    Buf_AddInterval(copy, line, p);
d1380 1
a1380 1
	Buf_AddInterval(copy, line, p);
d1386 1
a1386 1
static Boolean
d1404 1
a1404 1
	    line = ParseSkipGetLine(linebuf);
d1413 1
a1413 1
	return TRUE;
d1423 1
a1423 1
	Boolean ok;
d1426 1
a1426 1
	    line = ParseGetLoopLine(linebuf);
d1430 1
a1430 1
		return FALSE;
d1435 1
a1435 1
	return TRUE;
d1441 1
a1441 1
	return TRUE;
d1452 1
a1452 1
	return TRUE;
d1454 1
a1454 1
    return FALSE;
a1487 12
/*-
 *---------------------------------------------------------------------
 * Parse_File --
 *	Parse a file into its component parts, incorporating it into the
 *	current dependency graph. This is the main function and controls
 *	almost every other function in this module
 *
 * Side Effects:
 *	Loads. Nodes are added to the list of all targets, nodes and links
 *	are added to the dependency graph. etc. etc. etc.
 *---------------------------------------------------------------------
 */
d1490 1
a1490 1
    char	  *name;	/* the name of the file being read */
d1495 1
a1495 1
    Boolean	  inDependency; /* true if currently in a dependency
d1503 1
a1503 1
    inDependency = FALSE;
d1507 1
a1507 1
	while ((line = ParseReadLine(&buf)) != NULL) {
d1537 3
a1539 4
		    if (Parse_IsVar(stripped)) {
			inDependency = FALSE;
			Parse_DoVar(stripped, VAR_GLOBAL);
		    } else {
d1545 1
a1545 1
			inDependency = TRUE;
d1566 1
a1566 1
			cp = Var_Subst(stripped, NULL, TRUE);
d1589 1
a1589 1
    Finish_Errors();
a1593 9
/*-
 *---------------------------------------------------------------------
 * Parse_Init --
 *	initialize the parsing module
 *
 * Side Effects:
 *	the parseIncPath list is initialized...
 *---------------------------------------------------------------------
 */
d1598 2
a1599 2
    Lst_Init(&parseIncPath);
    Lst_Init(&sysIncPath);
d1601 1
a1602 1
    LowParse_Init();
a1603 1
    Lst_Init(&fileNames);
d1607 1
a1610 1
#ifdef CLEANUP
a1611 1
    Lst_Destroy(&fileNames, (SimpleProc)free);
d1613 2
a1614 2
    Lst_Destroy(&sysIncPath, Dir_Destroy);
    Lst_Destroy(&parseIncPath, Dir_Destroy);
d1616 1
a1617 1
}
a1619 10
/*-
 *-----------------------------------------------------------------------
 * Parse_MainName --
 *	Return a Lst of the main target to create for main()'s sake. If
 *	no such target exists, we Punt with an obnoxious error message.
 *
 * Side effect:
 *	Add the node to create to the list.
 *-----------------------------------------------------------------------
 */
@


1.59
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d2 1
a2 1
/*	$OpenBSD: parse.c,v 1.21 1999/10/05 22:08:07 espie Exp $	*/
d134 1
a134 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.21 1999/10/05 22:08:07 espie Exp $";
d1287 4
a1290 1
	    type = VAR_SUBST;
d1298 1
a1298 4
	    if (FEATURES(FEATURE_SUNSHCMD) && strncmp(end, ":sh", 3) == 0)
		type = VAR_SHELL;
	    else
		type = VAR_NORMAL;
@


1.58
log
@Clean-ups:
* Buf_Destroy can be a macro
* X_ instead of _X for struct names, to avoid infringing on the system's
namespace.
* better wildcard detection heuristics
* fix #ifdef CLEANUP code
* a few comments
@
text
@d1 2
a2 1
/*	$OpenBSD: parse.c,v 1.57 2000/09/14 13:46:45 espie Exp $	*/
d6 26
d88 3
a90 3
 *	Parse_Init	    	    Initialization function which must be
 *	    	  	    	    called before anything else in this module
 *	    	  	    	    is used.
d94 15
a108 15
 *	Parse_File	    	    Function used to parse a makefile. It must
 *	    	  	    	    be given the name of the file, which should
 *	    	  	    	    already have been opened, and a function
 *	    	  	    	    to call to read a character from the file.
 *
 *	Parse_IsVar	    	    Returns TRUE if the given line is a
 *	    	  	    	    variable assignment. Used by MainParseArgs
 *	    	  	    	    to determine if an argument is a target
 *	    	  	    	    or a variable assignment. Used internally
 *	    	  	    	    for pretty much the same thing...
 *
 *	Parse_Error	    	    Function called when an error occurs in
 *	    	  	    	    parsing. Used by the variable and
 *	    	  	    	    conditional modules.
 *	Parse_MainName	    	    Returns a Lst of the main target to create.
d116 1
d134 1
a134 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.57 2000/09/14 13:46:45 espie Exp $";
d138 4
a141 1
static LIST    		targets;	/* targets we're working on */
d143 2
a144 1
static LIST    	    	targCmds;	/* command lines for targets */
d146 1
a146 2
static Boolean	    	inLine;		/* true if currently in a dependency
				 	 * line or its commands */
a149 3
LIST         	parseIncPath;	/* list of directories for "..." includes */
LIST         	sysIncPath;	/* list of directories for <...> includes */

d157 1
a157 1
    Begin,  	    /* .BEGIN */
d159 1
a159 1
    End,    	    /* .END */
d171 2
a172 2
    Null,   	    /* .NULL */
    Order,  	    /* .ORDER */
d202 3
a204 3
    char    	  *name;    	/* Name of keyword */
    ParseSpecial  spec;	    	/* Type when used as a target */
    int	    	  op;	    	/* Operator when used as a source */
d206 10
a215 10
{ ".BEGIN", 	  Begin,    	0 },
{ ".DEFAULT",	  Default,  	0 },
{ ".END",   	  End,	    	0 },
{ ".EXEC",	  Attribute,   	OP_EXEC },
{ ".IGNORE",	  Ignore,   	OP_IGNORE },
{ ".INCLUDES",	  Includes, 	0 },
{ ".INTERRUPT",	  Interrupt,	0 },
{ ".INVISIBLE",	  Attribute,   	OP_INVISIBLE },
{ ".JOIN",  	  Attribute,   	OP_JOIN },
{ ".LIBS",  	  Libs,	    	0 },
d217 4
a220 4
{ ".MAIN",	  Main,		0 },
{ ".MAKE",  	  Attribute,   	OP_MAKE },
{ ".MAKEFLAGS",	  MFlags,   	0 },
{ ".MFLAGS",	  MFlags,   	0 },
d224 1
a224 1
{ ".NOTMAIN",	  Attribute,   	OP_NOTMAIN },
d227 3
a229 3
{ ".NULL",  	  Null,	    	0 },
{ ".OPTIONAL",	  Attribute,   	OP_OPTIONAL },
{ ".ORDER", 	  Order,    	0 },
d233 4
a236 4
{ ".PRECIOUS",	  Precious, 	OP_PRECIOUS },
{ ".RECURSIVE",	  Attribute,	OP_MAKE },
{ ".SHELL", 	  ExShell,    	0 },
{ ".SILENT",	  Silent,   	OP_SILENT },
d238 2
a239 2
{ ".SUFFIXES",	  Suffixes, 	0 },
{ ".USE",   	  Attribute,   	OP_USE },
d243 23
a265 17
static int ParseFindKeyword __P((char *));
static void ParseLinkSrc __P((void *, void *));
static int ParseDoOp __P((void *, void *));
static int ParseAddDep __P((void *, void *));
static void ParseDoSrc __P((int, char *, Lst));
static int ParseFindMain __P((void *, void *));
static void ParseAddDir __P((void *, void *));
static void ParseClearPath __P((void *));
static void ParseDoDependency __P((char *));
static void ParseAddCmd __P((void *, void *));
static void ParseHasCommands __P((void *));
static void ParseDoInclude __P((char *));
#ifdef SYSVINCLUDE
static void ParseTraditionalInclude __P((char *));
#endif
static void ParseLookupIncludeFile __P((char *, char *, Boolean));
static void ParseFinishLine __P((void));
a273 3
 *
 * Side Effects:
 *	None
d277 2
a278 2
ParseFindKeyword (str)
    char	    *str;		/* String to find */
d280 1
a280 1
    register int    start,
d283 1
a283 1
    register int    diff;
d289 2
a290 2
	cur = start + ((end - start) / 2);
	diff = strcmp (str, parseKeywords[cur].name);
d293 1
a293 1
	    return (cur);
d300 1
a300 1
    return (-1);
a301 1

d305 1
a305 1
 *	Link the parent node to its new child. Used in a Lst_ForEach by
d316 5
a320 8
ParseLinkSrc(pgnp, cgnp)
    void *pgnp;	/* The parent node */
    void *cgnp;	/* The child node */
{
    GNode          *pgn = (GNode *)pgnp;
    GNode          *cgn = (GNode *)cgnp;
    if (Lst_Member(&pgn->children, cgn) == NULL) {
	Lst_AtEnd(&pgn->children, cgn);
d323 1
a323 1
	pgn->unmade += 1;
a334 3
 * Results:
 *	0 if a problem, 1 if ok.
 *
d341 4
a344 4
ParseDoOp (gnp, opp)
    void *gnp;		/* The node to which the operator is to be
			 * applied */
    void *opp;		/* The operator to apply */
d346 2
a347 2
    GNode          *gn = (GNode *) gnp;
    int             op = *(int *) opp;
d359 2
a360 3
    if ((op == OP_DOUBLEDEP) && ((gn->type & OP_OPMASK) == OP_DOUBLEDEP)) {
	/*
	 * If the node was the object of a :: operator, we need to create a
d365 3
a367 4
	 * instance.
	 */
	register GNode	*cohort;
	LstNode	    	ln;
d370 1
a370 2
	/*
	 * Duplicate links to parents so graph traversal is simple. Perhaps
d376 3
a378 3
	 * sorry.
	 */
	Lst_ForEach(&gn->parents, ParseLinkSrc, cohort);
d382 1
a382 3
	/*
	 * Replace the node in the targets list with the new copy
	 */
d387 2
a388 4
    /*
     * We don't want to nuke any previous flags (whatever they were) so we
     * just OR the new operator into the old
     */
a389 1

d395 1
a395 1
 * ParseAddDep  --
d402 1
a402 1
 *	If it returns 0, the search can stop
d414 2
a415 2
    GNode *p = (GNode *) pp;
    GNode *s = (GNode *) sp;
d418 1
a418 2
	/*
	 * XXX: This can cause loops, and loops can cause unmade targets,
d420 1
a420 2
	 * problem
	 */
a438 3
 * Results:
 *	None
 *
d445 4
a448 4
ParseDoSrc (tOp, src, allsrc)
    int		tOp;	/* operator (if any) from special targets */
    char	*src;	/* name of the source to handle */
    Lst		allsrc;	/* List of all sources to wait for */
d453 1
a453 1
    if (*src == '.' && isupper (src[1])) {
d491 1
a491 1
	gn = Targ_FindNode(src, TARG_CREATE);
d514 1
a514 1
	gn = Targ_FindNode (src, TARG_CREATE);
d518 4
a521 1
	    Lst_ForEach(&targets, ParseLinkSrc, gn);
d524 2
a525 2
	    register GNode  	*cohort;
	    register LstNode	ln;
d532 4
a535 1
		    Lst_ForEach(&targets, ParseLinkSrc, cohort);
d544 1
a544 1
    if (waiting)
d546 1
a560 1
 *
d565 2
a566 2
    void 	*gnp;	/* Node to examine */
    void 	*dummy	UNUSED;		
d568 1
a568 1
    GNode   	  *gn = (GNode *) gnp;
d573 1
a573 1
    } else
d575 1
a584 1
 *
d598 1
a598 5
 *	Front-end for Dir_ClearPath to make sure Lst_ForEach keeps going
 *
 * Side Effects:
 *	See Dir_ClearPath
 *
d602 2
a603 2
ParseClearPath(path)
    void *path;
d605 4
a608 1
    Dir_ClearPath((Lst)path);
a615 3
 * Results:
 *	None
 *
d625 1
a625 1
 * 	The parsed operator is applied to each node in the 'targets' list,
d643 2
a644 2
ParseDoDependency (line)
    char           *line;	/* the line to parse */
d646 5
a650 5
    char  	   *cp;		/* our current position */
    GNode 	   *gn;		/* a general purpose temporary node */
    int             op;		/* the operator on the line */
    char            savec;	/* a place to save a character */
    LIST    	    paths;   	/* List of search paths to alter when parsing
d652 2
a653 2
    int	    	    tOp;    	/* operator from special target */
    LIST 	    curTargs;	/* list of target names to be found and added
d667 3
a669 31
	for (cp = line;
	     *cp && !isspace (*cp) && (*cp != '(');
	     cp++)
	{
	    /*
	     * We don't want to end a word on ':' or '!' if there is a
	     * better match later on in the string.  By "better" I mean
	     * one that is followed by whitespace.  This allows the user
	     * to have targets like:
	     *    fie::fi:fo: fum
	     * where "fie::fi:fo" is the target.  In real life this is used
	     * for perl5 library man pages where "::" separates an object
	     * from its class.  Ie: "File::Spec::Unix".  This behaviour
	     * is also consistent with other versions of make.
	     */
	    if (*cp == '!' || *cp == ':') {
		char *p = cp + 1;

		if (*p == '\0')
		    break;			/* no chance, not enough room */
		/*
		 * Only end the word on ':' or '!' if there is not
		 * a match later on followed by whitespace.
		 */
		while ((p = strchr(p + 1, *cp)) && !isspace(*(p + 1)))
		    ;
		if (!p || !isspace(*(p + 1)))
		    break;
	    } else if (*cp == '$') {
		/*
		 * Must be a dynamic source (would have been expanded
d673 28
a700 5
		 * in the initial Var_Subst and we wouldn't be here.
		 */
		size_t 	length;
		Boolean	freeIt;
		char	*result;
d702 3
a704 1
		result=Var_Parse(cp, NULL, TRUE, &length, &freeIt);
a705 2
		if (freeIt) {
		    free(result);
d707 1
a707 1
		cp += length-1;
a708 2
	    continue;
	}
d710 1
a710 2
	    /*
	     * Archives must be handled specially to make sure the OP_ARCHV
d717 1
a717 2
	     * specification. On error, line should remain untouched.
	     */
d719 1
a719 1
		Parse_Error (PARSE_FATAL,
d728 3
a730 6
	if (!*cp) {
	    /*
	     * Ending a dependency line without an operator is a Bozo
	     * no-no
	     */
	    Parse_Error (PARSE_FATAL, "Need an operator");
d734 5
a738 9
	/*
	 * Have a word in line. See if it's a special target and set
	 * specType to match it.
	 */
	if (*line == '.' && isupper (line[1])) {
	    /*
	     * See if the target is a special target that must have it
	     * or its sources handled specially.
	     */
d756 1
a756 1
		 *	.DEFAULT    	Need to create a node to hang
d764 4
a767 4
		 *	    	    	A transformation rule to make
		 *	    	    	life easier later, when we'll
		 *	    	    	use Make_HandleUse to actually
		 *	    	    	apply the .DEFAULT commands.
d769 1
a769 1
		 *	.NOPATH		Don't search for file in the path
d772 1
a772 1
		 *	.INTERRUPT  	Are not to be considered the
d774 3
a776 3
		 *  	.NOTPARALLEL	Make only one target at a time.
		 *  	.SINGLESHELL	Create a shell for each command.
		 *  	.ORDER	    	Must set initial predecessor to NULL
d790 1
a790 1
			gn = Targ_FindNode(line, TARG_CREATE);
d796 1
a796 1
			gn->type |= (OP_NOTMAIN|OP_TRANSFORM);
d816 1
a816 1
	    } else if (strncmp (line, ".PATH", 5) == 0) {
d822 1
a822 1
		Lst 	path;
d831 1
a831 1
		} else
d833 1
d841 1
a841 1
	if ((specType == Not) && (*line != '\0')) {
d852 1
a852 1
		
a853 1

a854 1

d864 3
a866 3
	    while((targName = (char *)Lst_DeQueue(&curTargs)) != NULL) {
		if (!Suff_IsTransform (targName)) {
		    gn = Targ_FindNode (targName, TARG_CREATE);
d868 1
a868 1
		    gn = Suff_AddTransform (targName);
d886 1
a886 1
	    while ((*cp != '!') && (*cp != ':') && *cp) {
d896 1
a896 1
	    while (*cp && isspace (*cp)) {
d901 1
a901 1
    } while ((*line != '!') && (*line != ':') && *line);
d903 3
a905 1
    /* Don't need the list of target names any more */
d909 1
a909 1
	switch(specType) {
d917 2
a918 4
		/*
		 * These four create nodes on which to hang commands, so
		 * targets shouldn't be empty...
		 */
d920 1
a920 3
		/*
		 * Nothing special here -- targets can be empty if it wants.
		 */
d925 2
a926 4
    /*
     * Have now parsed all the target names. Must parse the operator next. The
     * result is left in  op .
     */
d937 1
a937 1
	Parse_Error (PARSE_FATAL, "Missing dependency operator");
d948 1
a948 1
    while (*cp && isspace (*cp)) {
d965 1
a965 1
		Suff_ClearSuffixes ();
d988 1
a988 1
	Main_ParseArgLine (line);
d991 2
a992 2
	if (Job_ParseShell (line) != SUCCESS) {
	    Parse_Error (PARSE_FATAL, "improper shell specification");
d996 1
a996 1
    } else if ((specType == NotParallel) || (specType == SingleShell)) {
d1003 3
a1005 4
    if ((specType == Suffixes) || (specType == ExPath) ||
	(specType == Includes) || (specType == Libs) ||
	(specType == Null))
    {
d1032 1
a1032 1
	    while (*cp && !isspace (*cp)) {
d1039 1
a1039 1
		    Suff_AddSuffix (line);
d1045 1
a1045 1
		    Suff_AddInclude (line);
d1048 1
a1048 1
		    Suff_AddLib (line);
d1051 1
a1051 1
		    Suff_SetNull (line);
d1060 1
a1060 1
	    while (*cp && isspace (*cp)) {
d1073 2
a1074 2
	    while (*cp && !isspace (*cp)) {
		if ((*cp == '(') && (cp > line) && (cp[-1] != '$')) {
d1089 2
a1090 2
		LIST 	  sources; 	/* list of archive source names after
				 	 * expansion */
d1094 1
a1094 1
		    Parse_Error (PARSE_FATAL,
a1100 1
		Lst_Destroy(&sources, NOFREE);
d1110 1
a1110 1
	    while (*cp && isspace (*cp)) {
d1118 1
a1118 2
	/*
	 * If we have yet to decide on a main target to make, in the
d1121 1
a1121 2
	 * (i.e. isn't a .USE or .EXEC rule) to be made.
	 */
d1131 1
a1131 1
 * Parse_IsVar  --
a1139 3
 *
 * Side Effects:
 *	none
d1143 2
a1144 2
Parse_IsVar (line)
    register char  *line;	/* the line to check */
d1146 2
a1147 2
    register Boolean wasSpace = FALSE;	/* set TRUE if found a space */
    register Boolean haveName = FALSE;	/* Set TRUE if have a variable name */
d1150 1
a1150 7
	(((c) == '+') || ((c) == ':') || ((c) == '?') || ((c) == '!'))

    /*
     * Skip to variable name
     */
    for (;(*line == ' ') || (*line == '\t'); line++)
	continue;
d1155 1
a1155 3
	    /*
	     * end-of-line -- can't be a variable assignment.
	     */
d1180 1
a1180 3
			/*
			 * We must have a finished word
			 */
d1184 1
a1184 2
			/*
			 * When an = operator [+?!:] is found, the next
d1186 1
a1186 2
			 * assignment.
			 */
d1189 3
a1191 5
#ifdef SUNSHCMD
			/*
			 * This is a shell command
			 */
			if (strncmp(line, ":sh", 3) == 0)
a1192 1
#endif
d1194 1
a1194 3
		    /*
		     * This is the start of another word, so not assignment.
		     */
d1207 28
d1237 1
a1237 1
 * Parse_DoVar  --
a1246 3
 * Results:
 *	none
 *
d1253 2
a1254 2
Parse_DoVar (line, ctxt)
    char            *line;	/* a line guaranteed to be a variable
d1256 1
a1256 1
    GSymT   	    *ctxt;    	/* Context in which to do the assignment */
d1258 2
a1259 1
    char	   *cp;	/* pointer into line */
d1262 2
a1263 11
    }	    	    type;   	/* Type of assignment */
    char            *opc;	/* ptr to operator character to
				 * null-terminate the variable name */
    /*
     * Avoid clobbered variable warnings by forcing the compiler
     * to ``unregister'' variables
     */
#if __GNUC__
    (void) &cp;
    (void) &line;
#endif
d1265 2
a1266 6
    /*
     * Skip to variable name
     */
    while ((*line == ' ') || (*line == '\t')) {
	line++;
    }
d1268 2
a1269 10
    /*
     * Skip to operator character, nulling out whitespace as we go
     */
    for (cp = line + 1; *cp != '='; cp++) {
	if (isspace (*cp)) {
	    *cp = '\0';
	}
    }
    opc = cp-1;		/* operator is the previous character */
    *cp++ = '\0';	/* nuke the = */
d1271 2
a1272 4
    /*
     * Check operator type
     */
    switch (*opc) {
a1274 1
	    *opc = '\0';
d1278 3
a1280 5
	    /*
	     * If the variable already has a value, we don't do anything.
	     */
	    *opc = '\0';
	    if (Var_Exists(line, ctxt)) {
a1281 2
	    } else {
		type = VAR_NORMAL;
d1283 1
a1287 1
	    *opc = '\0';
a1291 1
	    *opc = '\0';
d1295 1
a1295 6
#ifdef SUNSHCMD
	    while (*opc != ':')
		if (--opc < line)
		    break;

	    if (strncmp(opc, ":sh", 3) == 0) {
d1297 2
a1298 5
		*opc = '\0';
		break;
	    }
#endif
	    type = VAR_NORMAL;
d1302 12
a1313 7
    while (isspace (*cp)) {
	cp++;
    }

    if (type == VAR_APPEND) {
	Var_Append (line, cp, ctxt);
    } else if (type == VAR_SUBST) {
d1325 1
a1325 1
	Boolean	  oldOldVars = oldVars;
d1328 6
a1333 1
	cp = Var_Subst(cp, (SymTable *)ctxt, FALSE);
d1336 2
a1337 2
	Var_Set(line, cp, ctxt);
	free(cp);
a1338 2
	Boolean	freeCmd = FALSE; /* TRUE if the command needs to be freed, i.e.
				  * if any variable expansion was performed */
d1341 9
a1349 9
	if (strchr(cp, '$') != NULL) {
	    /*
	     * There's a dollar sign in the command, so perform variable
	     * expansion on the whole thing. The resulting string will need
	     * freeing when we're done, so set freeCmd to TRUE.
	     */
	    cp = Var_Subst(cp, NULL, TRUE);
	    freeCmd = TRUE;
	}
d1351 1
a1351 2
	res = Cmd_Exec(cp, &err);
	Var_Set(line, res, ctxt);
d1355 1
a1355 1
	    Parse_Error(PARSE_WARNING, err, cp);
d1357 4
a1360 8
	if (freeCmd)
	    free(cp);
    } else {
	/*
	 * Normal assignment -- just do it.
	 */
	Var_Set(line, cp, ctxt);
    }
d1365 1
a1365 1
 * ParseAddCmd  --
a1394 3
 * Results:
 *	None
 *
a1396 1
 *
d1403 1
a1403 1
    GNode *gn = (GNode *) gnp;
a1413 7
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	The directory is appended to the list.
 *
d1418 1
a1418 1
    char    	  *dir;	    /* The name of the directory to add */
d1434 1
a1434 1
 *	old parse context is pushed on the stack, new file becomes 
d1440 1
a1440 1
    char          *file;	/* file specification */
d1442 3
a1444 3
    char          endc;	    	/* the character which ends the file spec */
    char          *cp;		/* current position in file spec */
    Boolean 	  isSystem; 	/* TRUE if makefile is a system makefile */
d1446 1
a1446 1
    /* Skip to delimiter character so we know where to look */
d1451 1
a1451 1
	Parse_Error (PARSE_FATAL,
d1467 3
a1469 3
    /* Skip to matching delimiter */
    for (cp = ++file; *cp && *cp != endc; cp++) {
    	if (*cp == '\0') {
d1476 1
a1476 1
    ParseLookupIncludeFile(file, cp, isSystem);
a1478 1
#ifdef SYSVINCLUDE
d1488 1
a1488 1
 *	old parse context is pushed on the stack, new file becomes 
d1490 2
d1496 1
a1496 1
    char          *file;	/* file specification */
d1498 1
a1498 1
    char          *cp;		/* current position in file spec */
d1500 2
a1501 2
    /* Skip over whitespace */
    while (*file == ' ' || *file == '\t')
d1503 26
d1530 3
d1534 1
a1534 1
	Parse_Error (PARSE_FATAL,
d1538 1
a1538 2

    /* Skip to end of line or next whitespace */
d1540 1
a1540 1
    	cp++;
d1542 1
a1542 1
    ParseLookupIncludeFile(file, cp, TRUE);
a1543 1
#endif
d1547 1
a1547 1
ParseLookupIncludeFile(spec, endSpec, isSystem)
d1551 1
d1558 1
a1558 1
     * find the thing.  */
d1571 3
a1573 3
	/* ... by first searching relative to the including file's 
	 * location. We don't want to cd there, of course, so we 
	 * just tack on the old file's leading path components 
d1575 1
a1575 1
	char 	  *slash;
d1591 1
a1591 1
    /* Now look first on the -I search path, then on the .PATH 
d1594 1
a1594 1
    if (fullname == NULL) 
d1604 3
a1606 2
    if (fullname == NULL)
	Parse_Error(PARSE_FATAL, "Could not find %s", file);
d1611 1
a1611 1
    	FILE *f;
d1614 1
a1614 1
	if (f == NULL) {
d1620 1
a1620 1
	     * error messages are informative.  */
d1626 109
d1737 1
a1737 1
 * ParseFinishLine --
d1741 1
a1741 1
 *	inLine set FALSE. 'targets' list destroyed.
d1746 1
a1746 1
ParseFinishLine()
d1748 2
a1749 6
    if (inLine) {
	Lst_Every(&targets, Suff_EndTransform);
	Lst_Destroy(&targets, ParseHasCommands);
	Lst_Init(&targets);
	inLine = FALSE;
    }
d1752 13
a1772 3
 * Results:
 *	None
 *
d1780 2
a1781 2
    char          *name;	/* the name of the file being read */
    FILE *	  stream;   	/* Stream open to makefile to parse */
d1783 12
a1794 2
    register char *cp,		/* pointer into the line */
                  *line;	/* the line we're working on */
a1795 2
    inLine = FALSE;
    Parse_FromFile(name, stream);
d1797 1
a1797 34
	while ((line = ParseReadLine ()) != NULL) {
	    if (*line == '.') {
		/*
		 * Lines that begin with the special character are either
		 * include or undef directives.
		 */
		for (cp = line + 1; isspace (*cp); cp++) {
		    continue;
		}
		if (strncmp (cp, "include", 7) == 0) {
		    ParseDoInclude (cp + 7);
		    goto nextLine;
		} else if (strncmp(cp, "undef", 5) == 0) {
		    char *cp2;
		    for (cp += 5; isspace((unsigned char) *cp); cp++) {
			continue;
		    }

		    for (cp2 = cp; !isspace((unsigned char) *cp2) &&
				   (*cp2 != '\0'); cp2++) {
			continue;
		    }

		    *cp2 = '\0';

		    Var_Delete(cp, VAR_GLOBAL);
		    goto nextLine;
		}
	    }
	    if (*line == '#') {
		/* If we're this far, the line must be a comment. */
		goto nextLine;
	    }

d1799 6
a1804 41
		/*
		 * If a line starts with a tab, it can only hope to be
		 * a creation command.
		 */
#ifndef POSIX
	    shellCommand:
#endif
		for (cp = line + 1; isspace (*cp); cp++) {
		    continue;
		}
		if (*cp) {
		    if (inLine) {
			/*
			 * So long as it's not a blank line and we're actually
			 * in a dependency spec, add the command to the list of
			 * commands of all targets in the dependency spec
			 */
			Lst_ForEach(&targets, ParseAddCmd, cp);
#ifdef CLEANUP
			Lst_AtEnd(&targCmds, line);
#endif
			continue;
		    } else {
			Parse_Error (PARSE_FATAL,
				     "Unassociated shell command \"%s\"",
				     cp);
		    }
		}
#ifdef SYSVINCLUDE
	    } else if (strncmp (line, "include", 7) == 0 &&
		       isspace((unsigned char) line[7]) &&
		       strchr(line, ':') == NULL) {
		/*
		 * It's an S3/S5-style "include".
		 */
		ParseTraditionalInclude (line + 7);
		goto nextLine;
#endif
	    } else if (Parse_IsVar (line)) {
		ParseFinishLine();
		Parse_DoVar (line, VAR_GLOBAL);
d1806 18
a1823 13
		/*
		 * We now know it's a dependency line so it needs to have all
		 * variables expanded before being parsed. Tell the variable
		 * module to complain if some variable is undefined...
		 * To make life easier on novices, if the line is indented we
		 * first make sure the line has a dependency operator in it.
		 * If it doesn't have an operator and we're in a dependency
		 * line's script, we assume it's actually a shell command
		 * and add it to the current list of targets.
		 */
#ifndef POSIX
		Boolean	nonSpace = FALSE;
#endif
d1825 8
a1832 15
		cp = line;
		if (isspace((unsigned char) line[0])) {
		    while ((*cp != '\0') && isspace((unsigned char) *cp)) {
			cp++;
		    }
		    if (*cp == '\0') {
			goto nextLine;
		    }
#ifndef POSIX
		    while ((*cp != ':') && (*cp != '!') && (*cp != '\0')) {
			nonSpace = TRUE;
			cp++;
		    }
#endif
		}
d1834 35
a1868 8
#ifndef POSIX
		if (*cp == '\0') {
		    if (inLine) {
			Parse_Error (PARSE_WARNING,
				     "Shell command needs a leading tab");
			goto shellCommand;
		    } else if (nonSpace) {
			Parse_Error (PARSE_FATAL, "Missing operator");
a1869 15
		} else {
#endif
		    ParseFinishLine();

		    cp = Var_Subst(line, NULL, TRUE);
		    free (line);
		    line = cp;

		    /* Need a new list for the target nodes */
		    Lst_Destroy(&targets, NOFREE);
		    Lst_Init(&targets);
		    inLine = TRUE;

		    ParseDoDependency (line);
#ifndef POSIX
a1870 1
#endif
a1871 4

	    nextLine:

	    free (line);
d1875 3
a1877 1
    /* Make sure conditionals are clean */
d1881 2
d1914 1
a1914 1
    Lst_Delete(&targets, NOFREE);
d1928 1
a1928 1
 * Side Effects:
a1929 1
 *
d1934 1
a1934 1
    Lst           listmain;	/* result list */
d1937 4
a1940 4
    if (mainNode == NULL)
	Punt ("no target to make.");
    	/*NOTREACHED*/
    else if (mainNode->type & OP_DOUBLEDEP) {
d1947 1
@


1.57
log
@Replace the old hash used to hold file names within a directory with
open hashing.

An interesting optimization is that the open hashing interface is more
fine-grained, hence we can compute the correct hash value at the start
of Dir_FindFile, and reuse it for each hash structure into which we look
(the effect is measurable on large directories along with objdir/VPATH).

Remove a few unnecessary Lst_Open/Lst_Close that serve no purpose except
obfuscating the code.

The interface to dir.h changes slightly, hence tedious includes changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.56 2000/09/14 13:43:31 espie Exp $	*/
d106 1
a106 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.56 2000/09/14 13:43:31 espie Exp $";
d1870 1
a1870 1
    Lst_Destroy(&fileNames, (void (*) __P((ClientData))) free);
@


1.56
log
@- new DirReadDir internal function, that just reads a directory from
the disk or from a cache.
- use it in Dir_AddDir, and directly to set up dot.
- change Dir_AddDir to use string intervals, as this simplifies
dependend functions.
- set up an open-hashing cache for opened directory names.
- add_dirpath() function in main, to simplify code.
- simplify cleaning-up directories, as Dir_ClearPath is overkill.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.55 2000/09/14 13:40:03 espie Exp $	*/
d89 1
d94 1
a94 1
#include "hash.h"
d106 1
a106 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.55 2000/09/14 13:40:03 espie Exp $";
@


1.55
log
@Use the new hash scheme to store the target nodes.
Scrap the list of all targets: it only slows make down.
The only visible difference is that the list of all targets is not
shown in order when debugging.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.54 2000/09/14 13:36:46 espie Exp $	*/
d105 1
a105 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.54 2000/09/14 13:36:46 espie Exp $";
d574 1
a574 1
    Dir_AddDir((Lst)path, (char *)name);
d1470 1
a1470 1
    Dir_AddDir(&parseIncPath, dir);
@


1.54
log
@Clean-up, systematic use of UNUSED, white space...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.53 2000/09/14 13:32:07 espie Exp $	*/
d105 1
a105 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.53 2000/09/14 13:32:07 espie Exp $";
d346 1
a346 1
	cohort = Targ_NewGN(gn->name);
d797 1
a797 1
			gn = Targ_NewGN(".DEFAULT");
@


1.53
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.52 2000/06/23 16:41:53 espie Exp $	*/
d105 1
a105 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.52 2000/06/23 16:41:53 espie Exp $";
d547 2
a548 2
    void *gnp;	    /* Node to examine */
    void *dummy;
d554 3
a556 4
	return (dummy ? 0 : 0);
    } else {
	return (dummy ? 1 : 1);
    }
@


1.52
log
@This patch replaces str_concat with a slightly unobfuscated version.

In particular, Dir_MakeFlags is abusing str_concat, and works much better
with buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.51 2000/06/23 16:40:50 espie Exp $	*/
a41 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)parse.c	8.3 (Berkeley) 3/19/94";
#else
static char rcsid[] = "$OpenBSD: parse.c,v 1.51 2000/06/23 16:40:50 espie Exp $";
#endif
#endif /* not lint */

d100 9
a223 1
static int __inline ParseReadc __P((void));
@


1.51
log
@This is complementary to the previous patch.

There is no code change in this patch, we just move the remaining
`lowparse' functions to the right file, and adjust the interface file
accordingly.

Reviewed by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.50 2000/06/23 16:39:45 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.50 2000/06/23 16:39:45 espie Exp $";
d1604 1
a1604 1
	    newName = str_concat(base, file, STR_ADDSLASH);
@


1.50
log
@This patch is worth a lot, speed-wise.

This does introduce a proper stack of IFiles to handle included files:
instead of having the current file be a special case, it's also an IFile.

The corresponding code is slightly unobfuscated, removing the error-prone
ParseEOF function, freeing the filename systematically (thus, main.c needs
to strdup stdin), and merging both include functions lookup into one.

The speed gain comes from changing the IFile structure to merge with
fgetln seamlessly.

The low-level parse code is mostly moved to a new file, lowparse.c, to
make things easier to read (see next patch as well).

Accordingly, util.c gains a fgetln.

Note the interaction between Parse_File, Dir_FindFile, and ReadMakefile in
main.c. This patch closes a subtle memory hole (only the Makefile names,
so rather small).

Reviewed by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.49 2000/06/23 16:23:26 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.49 2000/06/23 16:23:26 espie Exp $";
a229 2
static char *ParseReadLine __P((void));
static char *ParseSkipLine __P((int));
a1643 314
    }
}

/* ParseSkipLine():
 *	Grab the next line
 */
static char *
ParseSkipLine(skip)
    int skip; 		/* Skip lines that don't start with . */
{
    char *line;
    int c, lastc;
    BUFFER buf;

    Buf_Init(&buf, MAKE_BSIZE);

    for (;;) {
        Buf_Reset(&buf);
        lastc = '\0';

        while (((c = ParseReadc()) != '\n' || lastc == '\\')
               && c != EOF) {
            if (c == '\n') {
                Buf_ReplaceLastChar(&buf, ' ');
                current->lineno++;

                while ((c = ParseReadc()) == ' ' || c == '\t');

                if (c == EOF)
                    break;
            }

            Buf_AddChar(&buf, c);
            lastc = c;
        }

        line = Buf_Retrieve(&buf);
        current->lineno++;
	    /* allow for non-newline terminated lines while skipping */
	if (line[0] == '.')
	    break;

        if (c == EOF) {
            Parse_Error(PARSE_FATAL, "Unclosed conditional/for loop");
            Buf_Destroy(&buf);
            return NULL;
        }
	if (skip == 0)
	    break;

    }

    return line;
}


/*-
 *---------------------------------------------------------------------
 * ParseReadLine --
 *	Read an entire line from the input file. Called only by Parse_File.
 *	To facilitate escaped newlines and what have you, a character is
 *	buffered in 'lastc', which is '\0' when no characters have been
 *	read. When we break out of the loop, c holds the terminating
 *	character and lastc holds a character that should be added to
 *	the line (unless we don't read anything but a terminator).
 *
 * Results:
 *	A line w/o its newline
 *
 * Side Effects:
 *	Only those associated with reading a character
 *---------------------------------------------------------------------
 */
static char *
ParseReadLine ()
{
    BUFFER  	  buf;	    	/* Buffer for current line */
    register int  c;	      	/* the current character */
    register int  lastc;    	/* The most-recent character */
    Boolean	  semiNL;     	/* treat semi-colons as newlines */
    Boolean	  ignDepOp;   	/* TRUE if should ignore dependency operators
				 * for the purposes of setting semiNL */
    Boolean 	  ignComment;	/* TRUE if should ignore comments (in a
				 * shell command */
    char 	  *line;    	/* Result */
    char          *ep;		/* to strip trailing blanks */

    semiNL = FALSE;
    ignDepOp = FALSE;
    ignComment = FALSE;

    /*
     * Handle special-characters at the beginning of the line. Either a
     * leading tab (shell command) or pound-sign (possible conditional)
     * forces us to ignore comments and dependency operators and treat
     * semi-colons as semi-colons (by leaving semiNL FALSE). This also
     * discards completely blank lines.
     */
    for (;;) {
	c = ParseReadc();

	if (c == '\t') {
	    ignComment = ignDepOp = TRUE;
	    break;
	} else if (c == '\n') {
	    current->lineno++;
	} else if (c == '#') {
	    ParseUnreadc(c);
	    break;
	} else {
	    /*
	     * Anything else breaks out without doing anything
	     */
	    break;
	}
    }

    if (c != EOF) {
	lastc = c;
	Buf_Init(&buf, MAKE_BSIZE);

	while (((c = ParseReadc ()) != '\n' || (lastc == '\\')) &&
	       (c != EOF))
	{
test_char:
	    switch(c) {
	    case '\n':
		/*
		 * Escaped newline: read characters until a non-space or an
		 * unescaped newline and replace them all by a single space.
		 * This is done by storing the space over the backslash and
		 * dropping through with the next nonspace. If it is a
		 * semi-colon and semiNL is TRUE, it will be recognized as a
		 * newline in the code below this...
		 */
		current->lineno++;
		lastc = ' ';
		while ((c = ParseReadc ()) == ' ' || c == '\t') {
		    continue;
		}
		if (c == EOF || c == '\n') {
		    goto line_read;
		} else {
		    /*
		     * Check for comments, semiNL's, etc. -- easier than
		     * ParseUnreadc(c); continue;
		     */
		    goto test_char;
		}
		/*NOTREACHED*/
		break;

	    case ';':
		/*
		 * Semi-colon: Need to see if it should be interpreted as a
		 * newline
		 */
		if (semiNL) {
		    /*
		     * To make sure the command that may be following this
		     * semi-colon begins with a tab, we push one back into the
		     * input stream. This will overwrite the semi-colon in the
		     * buffer. If there is no command following, this does no
		     * harm, since the newline remains in the buffer and the
		     * whole line is ignored.
		     */
		    ParseUnreadc('\t');
		    goto line_read;
		}
		break;
	    case '=':
		if (!semiNL) {
		    /*
		     * Haven't seen a dependency operator before this, so this
		     * must be a variable assignment -- don't pay attention to
		     * dependency operators after this.
		     */
		    ignDepOp = TRUE;
		} else if (lastc == ':' || lastc == '!') {
		    /*
		     * Well, we've seen a dependency operator already, but it
		     * was the previous character, so this is really just an
		     * expanded variable assignment. Revert semi-colons to
		     * being just semi-colons again and ignore any more
		     * dependency operators.
		     *
		     * XXX: Note that a line like "foo : a:=b" will blow up,
		     * but who'd write a line like that anyway?
		     */
		    ignDepOp = TRUE; semiNL = FALSE;
		}
		break;
	    case '#':
		if (!ignComment) {
		    if (
#if 0
		    compatMake &&
#endif
		    (lastc != '\\')) {
			/*
			 * If the character is a hash mark and it isn't escaped
			 * (or we're being compatible), the thing is a comment.
			 * Skip to the end of the line.
			 */
			do {
			    c = ParseReadc();
			} while ((c != '\n') && (c != EOF));
			goto line_read;
		    } else {
			/*
			 * Don't add the backslash. Just let the # get copied
			 * over.
			 */
			lastc = c;
			continue;
		    }
		}
		break;
	    case ':':
	    case '!':
		if (!ignDepOp && (c == ':' || c == '!')) {
		    /*
		     * A semi-colon is recognized as a newline only on
		     * dependency lines. Dependency lines are lines with a
		     * colon or an exclamation point. Ergo...
		     */
		    semiNL = TRUE;
		}
		break;
	    }
	    /*
	     * Copy in the previous character and save this one in lastc.
	     */
	    Buf_AddChar(&buf, lastc);
	    lastc = c;

	}
    line_read:
	current->lineno++;

	if (lastc != '\0') 
	    Buf_AddChar(&buf, lastc);
	line = Buf_Retrieve(&buf);

	/*
	 * Strip trailing blanks and tabs from the line.
	 * Do not strip a blank or tab that is preceeded by
	 * a '\'
	 */
	ep = line;
	while (*ep)
	    ++ep;
	while (ep > line + 1 && (ep[-1] == ' ' || ep[-1] == '\t')) {
	    if (ep > line + 1 && ep[-2] == '\\')
		break;
	    --ep;
	}
	*ep = 0;

	if (line[0] == '.') {
	    /*
	     * The line might be a conditional. Ask the conditional module
	     * about it and act accordingly
	     */
	    switch (Cond_Eval (line)) {
	    case COND_SKIP:
		/*
		 * Skip to next conditional that evaluates to COND_PARSE.
		 */
		do {
		    free (line);
		    line = ParseSkipLine(1);
		} while (line && Cond_Eval(line) != COND_PARSE);
		if (line == NULL)
		    break;
		/*FALLTHRU*/
	    case COND_PARSE:
		free(line);
		line = ParseReadLine();
		break;
	    case COND_INVALID:
	    	{
		For *loop;

		loop = For_Eval(line);
		if (loop != NULL) {
		    Boolean ok;

		    free(line);
		    do {
			/* Find the matching endfor.  */
			line = ParseSkipLine(0);
			if (line == NULL) {
			    Parse_Error(PARSE_FATAL,
				     "Unexpected end of file in for loop.\n");
			    return line;
			}
			ok = For_Accumulate(loop, line);
			free(line);
		    } while (ok);
		    For_Run(loop);
		    line = ParseReadLine();
		}
		break;
		}
	    }
	}
	return (line);

    } else {
	/*
	 * Hit end-of-file, so return a NULL line to indicate this.
	 */
	return((char *)NULL);
@


1.49
log
@This patch separates local contexts from global contexts for good.
Apart from a few casts, VAR_GLOBAL and friends are separate
data structures, so we use a small array for local variables.

We also junk allVars, since TargFreeGN can release local nodes,
and var.c has explicit lists for its variables already.

Reviewed millert@@ and miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.48 2000/06/23 16:21:43 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.48 2000/06/23 16:21:43 espie Exp $";
d106 1
a107 11
#ifdef CLEANUP
static LIST	    fileNames;	/* file names to free at end */
#endif

/*
 * These values are returned by ParseEOF to tell Parse_File whether to
 * CONTINUE parsing, i.e. it had only reached the end of an include file,
 * or if it's DONE.
 */
#define	CONTINUE	1
#define	DONE		0
a113 13
typedef struct {
    char *str;
    char *ptr;
} PTR;

static char    	    *fname;	/* name of current file (for errors) */
static unsigned long lineno;	/* line number in current file */
static FILE   	    *curFILE = NULL; 	/* current makefile */

static PTR 	    *curPTR = NULL; 	/* current makefile */

static int	    fatals = 0;

a116 12
/*
 * Definitions for handling #include specifications
 */
typedef struct IFile {
    char            *fname;	    /* name of previous file */
    unsigned long   lineno;	    /* saved line number */
    FILE            *F;		    /* the open stream */
    PTR             *p;	    	    /* the char pointer */
} IFile;

static LIST      includes;  	/* stack of IFiles generated by
				 * #includes */
a212 2
static void ParseErrorInternal __P((char *, unsigned long, int, char *, ...));
static void ParseVErrorInternal __P((char *, unsigned long, int, char *, va_list));
a223 1
static void ParseUnreadc __P((int));
d229 1
a229 1
static int ParseEOF __P((int));
a273 107
 * ParseVErrorInternal  --
 *	Error message abort function for parsing. Prints out the context
 *	of the error (line number and file) as well as the message with
 *	two optional arguments.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	"fatals" is incremented if the level is PARSE_FATAL.
 */
/* VARARGS */
static void
#ifdef __STDC__
ParseVErrorInternal(char *cfname, unsigned long clineno, int type, char *fmt,
    va_list ap)
#else
ParseVErrorInternal(va_alist)
	va_dcl
#endif
{
	(void)fprintf(stderr, "\"%s\", line %lu: ", cfname, clineno);
	if (type == PARSE_WARNING)
		(void)fprintf(stderr, "warning: ");
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
	(void)fflush(stderr);
	if (type == PARSE_FATAL)
		fatals += 1;
}

/*-
 * ParseErrorInternal  --
 *	Error function
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	None
 */
/* VARARGS */
static void
#ifdef __STDC__
ParseErrorInternal(char *cfname, unsigned long clineno, int type, char *fmt, ...)
#else
ParseErrorInternal(va_alist)
	va_dcl
#endif
{
	va_list ap;
#ifdef __STDC__
	va_start(ap, fmt);
#else
	int type;		/* Error type (PARSE_WARNING, PARSE_FATAL) */
	char *fmt;
	char *cfname;
	unsigned long clineno;

	va_start(ap);
	cfname = va_arg(ap, char *);
	clineno = va_arg(ap, unsigned long);
	type = va_arg(ap, int);
	fmt = va_arg(ap, char *);
#endif

	ParseVErrorInternal(cfname, clineno, type, fmt, ap);
	va_end(ap);
}

/*-
 * Parse_Error  --
 *	External interface to ParseErrorInternal; uses the default filename
 *	Line number.
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	None
 */
/* VARARGS */
void
#ifdef __STDC__
Parse_Error(int type, char *fmt, ...)
#else
Parse_Error(va_alist)
	va_dcl
#endif
{
	va_list ap;
#ifdef __STDC__
	va_start(ap, fmt);
#else
	int type;		/* Error type (PARSE_WARNING, PARSE_FATAL) */
	char *fmt;

	va_start(ap);
	type = va_arg(ap, int);
	fmt = va_arg(ap, char *);
#endif

	ParseVErrorInternal(fname, lineno, type, fmt, ap);
}

/*-
a1485 3
 * Results:
 *	None
 *
d1487 2
a1488 2
 *	A structure is added to the includes Lst and readProc, lineno,
 *	fname and curFILE are altered for the new file
d1492 1
a1492 1
ParseDoInclude (file)
a1494 2
    char          *fullname;	/* full pathname of file */
    IFile         *oldFile;	/* state associated with current file */
d1499 2
a1500 4
    /*
     * Skip to delimiter character so we know where to look
     */
    while ((*file == ' ') || (*file == '\t')) {
a1501 1
    }
d1503 1
a1503 1
    if ((*file != '"') && (*file != '<')) {
d1509 1
a1509 2
    /*
     * Set the search path on which to find the include file based on the
d1511 1
a1511 2
     * a system Makefile while double-quotes imply it's a user makefile
     */
d1520 1
a1520 3
    /*
     * Skip to matching delimiter
     */
d1522 2
a1523 5
	continue;
    }

    if (*cp != endc) {
	Parse_Error (PARSE_FATAL,
d1526 1
a1526 45
	return;
    }
    *cp = '\0';

    /*
     * Substitute for any variables in the file name before trying to
     * find the thing.
     */
    file = Var_Subst(file, NULL, FALSE);

    /*
     * Now we know the file's name and its search path, we attempt to
     * find the durn thing. A return of NULL indicates the file don't
     * exist.
     */
    if (!isSystem) {
	/*
	 * Include files contained in double-quotes are first searched for
	 * relative to the including file's location. We don't want to
	 * cd there, of course, so we just tack on the old file's
	 * leading path components and call Dir_FindFile to see if
	 * we can locate the beast.
	 */
	char	  *prefEnd, *Fname;

	/* Make a temporary copy of this, to be safe. */
	Fname = estrdup(fname);

	prefEnd = strrchr (Fname, '/');
	if (prefEnd != (char *)NULL) {
	    char  	*newName;

	    *prefEnd = '\0';
	    if (file[0] == '/')
		newName = estrdup(file);
	    else
		newName = str_concat (Fname, file, STR_ADDSLASH);
	    fullname = Dir_FindFile(newName, &parseIncPath);
	    if (fullname == (char *)NULL) {
		fullname = Dir_FindFile(newName, &dirSearchPath);
	    }
	    free (newName);
	    *prefEnd = '/';
	} else {
	    fullname = (char *)NULL;
a1527 30
	free (Fname);
    } else {
	fullname = (char *)NULL;
    }

    if (fullname == (char *)NULL) {
	/*
	 * System makefile or makefile wasn't found in same directory as
	 * included makefile. Search for it first on the -I search path,
	 * then on the .PATH search path, if not found in a -I directory.
	 * XXX: Suffix specific?
	 */
	fullname = Dir_FindFile(file, &parseIncPath);
	if (fullname == (char *)NULL) {
	    fullname = Dir_FindFile(file, &dirSearchPath);
	}
    }

    if (fullname == (char *)NULL) {
	/*
	 * Still haven't found the makefile. Look for it on the system
	 * path as a last resort.
	 */
	fullname = Dir_FindFile(file, &sysIncPath);
    }

    if (fullname == (char *) NULL) {
	*cp = endc;
	Parse_Error (PARSE_FATAL, "Could not find %s", file);
	return;
d1529 1
a1529 78

    free(file);

    /*
     * Once we find the absolute path to the file, we get to save all the
     * state from the current file before we can start reading this
     * include file. The state is stored in an IFile structure which
     * is placed on a list with other IFile structures. The list makes
     * a very nice stack to track how we got here...
     */
    oldFile = (IFile *) emalloc (sizeof (IFile));
    oldFile->fname = fname;

    oldFile->F = curFILE;
    oldFile->p = curPTR;
    oldFile->lineno = lineno;

    Lst_AtFront(&includes, oldFile);

    /*
     * Once the previous state has been saved, we can get down to reading
     * the new file. We set up the name of the file to be the absolute
     * name of the include file so error messages refer to the right
     * place. Naturally enough, we start reading at line number 0.
     */
    fname = fullname;
#ifdef CLEANUP
    Lst_AtEnd(&fileNames, fname);
#endif
    lineno = 0;

    curFILE = fopen (fullname, "r");
    curPTR = NULL;
    if (curFILE == (FILE * ) NULL) {
	Parse_Error (PARSE_FATAL, "Cannot open %s", fullname);
	/*
	 * Pop to previous file
	 */
	(void) ParseEOF(0);
    }
}


/*-
 *---------------------------------------------------------------------
 * Parse_FromString  --
 *	Start Parsing from the given string
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	A structure is added to the includes Lst and readProc, lineno,
 *	fname and curFILE are altered for the new file
 *---------------------------------------------------------------------
 */
void
Parse_FromString(str, newlineno)
    char 	  *str;
    unsigned long newlineno;
{
    IFile         *oldFile;	/* state associated with this file */

    if (DEBUG(FOR))
	(void) fprintf(stderr, "%s\n----\n", str);

    oldFile = (IFile *) emalloc (sizeof (IFile));
    oldFile->lineno = lineno;
    oldFile->fname = fname;
    oldFile->F = curFILE;
    oldFile->p = curPTR;

    Lst_AtFront(&includes, oldFile);

    curFILE = NULL;
    curPTR = (PTR *) emalloc (sizeof (PTR));
    curPTR->str = curPTR->ptr = str;
    lineno = newlineno;
a1531 1

a1540 3
 * Results:
 *	None
 *
d1542 2
a1543 2
 *	A structure is added to the includes Lst and readProc, lineno,
 *	fname and curFILE are altered for the new file
d1547 1
a1547 1
ParseTraditionalInclude (file)
a1549 2
    char          *fullname;	/* full pathname of file */
    IFile         *oldFile;	/* state associated with current file */
a1550 1
    char	  *prefEnd;
d1552 2
a1553 4
    /*
     * Skip over whitespace
     */
    while ((*file == ' ') || (*file == '\t')) {
a1554 1
    }
d1562 3
a1564 6
    /*
     * Skip to end of line or next whitespace
     */
    for (cp = file; *cp && *cp != '\n' && *cp != '\t' && *cp != ' '; cp++) {
	continue;
    }
d1566 3
a1568 1
    *cp = '\0';
d1570 43
a1612 30
    /*
     * Substitute for any variables in the file name before trying to
     * find the thing.
     */
    file = Var_Subst(file, NULL, FALSE);

    /*
     * Now we know the file's name, we attempt to find the durn thing.
     * A return of NULL indicates the file don't exist.
     *
     * Include files are first searched for relative to the including
     * file's location. We don't want to cd there, of course, so we
     * just tack on the old file's leading path components and call
     * Dir_FindFile to see if we can locate the beast.
     * XXX - this *does* search in the current directory, right?
     */

    prefEnd = strrchr (fname, '/');
    if (prefEnd != (char *)NULL) {
	char  	*newName;

	*prefEnd = '\0';
	newName = str_concat (fname, file, STR_ADDSLASH);
	fullname = Dir_FindFile(newName, &parseIncPath);
	if (fullname == NULL)
	    fullname = Dir_FindFile(newName, &dirSearchPath);
	free (newName);
	*prefEnd = '/';
    } else {
	fullname = (char *)NULL;
d1615 4
a1618 7
    if (fullname == (char *)NULL) {
	/*
	 * System makefile or makefile wasn't found in same directory as
	 * included makefile. Search for it first on the -I search path,
	 * then on the .PATH search path, if not found in a -I directory.
	 * XXX: Suffix specific?
	 */
d1620 2
a1621 3
	if (fullname == NULL)
	    fullname = Dir_FindFile(file, &dirSearchPath);
    }
d1623 3
a1625 5
    if (fullname == (char *)NULL) {
	/*
	 * Still haven't found the makefile. Look for it on the system
	 * path as a last resort.
	 */
a1626 1
    }
d1628 2
a1629 4
    if (fullname == (char *) NULL) {
	Parse_Error (PARSE_FATAL, "Could not find %s", file);
	return;
    }
d1631 1
a1631 9
    /*
     * Once we find the absolute path to the file, we get to save all the
     * state from the current file before we can start reading this
     * include file. The state is stored in an IFile structure which
     * is placed on a list with other IFile structures. The list makes
     * a very nice stack to track how we got here...
     */
    oldFile = (IFile *) emalloc (sizeof (IFile));
    oldFile->fname = fname;
d1633 2
a1634 3
    oldFile->F = curFILE;
    oldFile->p = curPTR;
    oldFile->lineno = lineno;
d1636 10
a1645 22
    Lst_AtFront(&includes, oldFile);

    /*
     * Once the previous state has been saved, we can get down to reading
     * the new file. We set up the name of the file to be the absolute
     * name of the include file so error messages refer to the right
     * place. Naturally enough, we start reading at line number 0.
     */
    fname = fullname;
#ifdef CLEANUP
    Lst_AtEnd(&fileNames, fname);
#endif
    lineno = 0;

    curFILE = fopen (fullname, "r");
    curPTR = NULL;
    if (curFILE == (FILE * ) NULL) {
	Parse_Error (PARSE_FATAL, "Cannot open %s", fullname);
	/*
	 * Pop to previous file
	 */
	(void) ParseEOF(1);
a1647 87
#endif

/*-
 *---------------------------------------------------------------------
 * ParseEOF  --
 *	Called when EOF is reached in the current file. If we were reading
 *	an include file, the includes stack is popped and things set up
 *	to go back to reading the previous file at the previous location.
 *
 * Results:
 *	CONTINUE if there's more to do. DONE if not.
 *
 * Side Effects:
 *	The old curFILE, is closed. The includes list is shortened.
 *	lineno, curFILE, and fname are changed if CONTINUE is returned.
 *---------------------------------------------------------------------
 */
static int
ParseEOF (opened)
    int opened;
{
    IFile     *ifile;	/* the state on the top of the includes stack */

    if ((ifile = (IFile *)Lst_DeQueue(&includes)) == NULL)
    	return DONE;
    fname = ifile->fname;
    lineno = ifile->lineno;
    if (opened && curFILE)
	(void) fclose (curFILE);
    if (curPTR) {
	free(curPTR->str);
	free(curPTR);
    }
    curFILE = ifile->F;
    curPTR = ifile->p;
    free(ifile);
    return (CONTINUE);
}

/*-
 *---------------------------------------------------------------------
 * ParseReadc  --
 *	Read a character from the current file
 *
 * Results:
 *	The character that was read
 *
 * Side Effects:
 *---------------------------------------------------------------------
 */
static int __inline
ParseReadc()
{
    if (curFILE)
	return fgetc(curFILE);

    if (curPTR && *curPTR->ptr)
	return *curPTR->ptr++;
    return EOF;
}


/*-
 *---------------------------------------------------------------------
 * ParseUnreadc  --
 *	Put back a character to the current file
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *---------------------------------------------------------------------
 */
static void
ParseUnreadc(c)
    int c;
{
    if (curFILE) {
	ungetc(c, curFILE);
	return;
    }
    if (curPTR) {
	*--(curPTR->ptr) = c;
	return;
    }
}

d1670 1
a1670 1
                lineno++;
d1683 1
a1683 1
        lineno++;
d1751 1
a1751 1
	    lineno++;
d1781 1
a1781 1
		lineno++;
d1884 1
a1884 1
	lineno++;
d2009 1
a2009 8
    fname = estrdup(name);
#ifdef CLEANUP
    Lst_AtEnd(&fileNames, fname);
#endif
    curFILE = stream;
    lineno = 0;
    fatals = 0;

d2150 1
a2150 4
	/*
	 * Reached EOF, but it may be just EOF of an include file...
	 */
    } while (ParseEOF(1) == CONTINUE);
d2152 1
a2152 3
    /*
     * Make sure conditionals are clean
     */
d2155 1
a2155 4
    if (fatals) {
	fprintf (stderr, "Fatal errors encountered -- cannot continue\n");
	exit (1);
    }
a2172 1
    Lst_Init(&includes);
d2175 1
d2190 1
a2190 1
    Lst_Destroy(&includes, NOFREE);	/* Should be empty now */
a2220 13

unsigned long
Parse_Getlineno()
{
    return lineno;
}

const char *
Parse_Getfilename()
{
    return fname;
}

@


1.48
log
@In various places, VAR_CMD is used to actually mean `no real context',
since lookup will start with VAR_CMD in any case.
This fixes VarFind and Var_Parse to handle ctxt == NULL correctly, and
replace those confusing VAR_CMD with proper NULL pointers.

This patch also handles three small details:
- .CURDIR is necessarily set in VAR_GLOBAL,
- suffix handling for archives copies two hard-coded variables, for
which it can use a quick path,
- typos in TargFreeGN.

Reviewed millert@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.47 2000/06/23 16:20:01 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.47 2000/06/23 16:20:01 espie Exp $";
d1410 1
a1410 1
    SymTable   	    *ctxt;    	/* Context in which to do the assignment */
d1513 1
a1513 1
	cp = Var_Subst(cp, ctxt, FALSE);
@


1.47
log
@Once those special variable are taken care of, other Var functions can take
the GNode's context directly.  We rename that special Lst to `SymTable *'
in prevision of things to come.

Along the line, we lose the special GNodes affected to VAR_CMD, VAR_GLOBAL,
VAR_ENV, which become simple Lsts... This is not a problem, except when
getting to a context's name for debugging (handled very nicely by
offsetof).

Again, this is a preparatory patch, which does not gain anything except
for cleaning up issues...

Reviewed by millert@@ and miod@@, like the previous patch
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.46 2000/06/23 16:15:50 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.46 2000/06/23 16:15:50 espie Exp $";
d841 1
a841 1
		result=Var_Parse(cp, VAR_CMD, TRUE, &length, &freeIt);
d861 1
a861 1
	    if (Arch_ParseArchive(&line, &targets, VAR_CMD) != SUCCESS) {
d1249 1
a1249 1
		if (Arch_ParseArchive(&line, &sources, VAR_CMD) != SUCCESS) {
d1529 1
a1529 1
	    cp = Var_Subst(cp, VAR_CMD, TRUE);
d1694 1
a1694 1
    file = Var_Subst(file, VAR_CMD, FALSE);
d1896 1
a1896 1
    file = Var_Subst(file, VAR_CMD, FALSE);
d2564 1
a2564 1
		    cp = Var_Subst(line, VAR_CMD, TRUE);
@


1.46
log
@Trivial consequences of the previous list changes:

- audit code for Lst_Datum, it's never applied to an empty pointer,
so check can be removed -> turn into a macro,
- Lst_First, Lst_Last can become macro as well
- specialized version of Lst_Succ (Lst_Adv) to use in loops where it cannot
fail,
- Lst_Open can no longer fail. Trim down corresponding code.

Reviewed millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.45 2000/06/17 14:43:36 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.45 2000/06/17 14:43:36 espie Exp $";
d1410 1
a1410 1
    GNode   	    *ctxt;    	/* Context in which to do the assignment */
@


1.45
log
@This removes the few instances of Lst_New left.
- replaces Lst_Duplicate with Lst_Clone, which does not allocate storage
- split Lst_Concat into Lst_Concat/Lst_ConcatDestroy
Thus, all the LstValid checks are gone, since we always invoke list
functions with valid pointers.

Note that dynamic list allocation accounted for roughly 20% of all calls
to malloc.  The extraneous calls to malloc left are now mostly in parse.c,
which makes some wasteful usage of temporary buffers.

With those few patches, the code is sturdier, and easier to maintain.

Reviewed by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.44 2000/06/17 14:40:29 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.44 2000/06/17 14:40:29 espie Exp $";
d659 1
a659 1
	    for (ln=Lst_First(&gn->cohorts); ln != NULL; ln = Lst_Succ(ln)){
@


1.44
log
@A few assorted changes, to remove more dynamic lists.
- in Dir_Expand, path is a misnomer. Use a temp variable instead...
Reformat code for readability.
- Change Parse_MainName/Targ_FindList so that they fill arguments instead
of allocating new lists.
- nuke Targ_FindList(TG_NOCREATE), as this is never used.

- close a small memory hole (forgot to free sysMkPath if CLEANUP).

Reviewed by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.43 2000/06/17 14:38:18 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.43 2000/06/17 14:38:18 espie Exp $";
d118 1
a118 1
static Lst     	    targets;	/* targets we're working on */
d120 1
a120 1
static LIST    	    targCmds;	/* command lines for targets */
d122 2
a123 2
static Boolean	    inLine;	/* true if currently in a dependency
				 * line or its commands */
d510 1
a510 1
	ln = Lst_Member(targets, gn);
d593 1
a593 1
		Lst_Find(targets, ParseDoOp, &op);
d653 1
a653 1
	    Lst_ForEach(targets, ParseLinkSrc, gn);
d664 1
a664 1
		    Lst_ForEach(targets, ParseLinkSrc, cohort);
d784 1
a784 1
    Lst    	    paths;   	/* List of search paths to alter when parsing
d795 1
a795 1
    paths = (Lst)NULL;
d861 1
a861 1
	    if (Arch_ParseArchive (&line, targets, VAR_CMD) != SUCCESS) {
d930 1
a930 3
			if (paths == NULL)
			    paths = Lst_New();
			Lst_AtEnd(paths, &dirSearchPath);
d942 1
a942 1
			Lst_AtEnd(targets, gn);
d947 1
a947 1
			Lst_AtEnd(targets, gn);
d975 1
a975 1
		path = Suff_GetPath (&line[5]);
d977 1
a977 1
		    Parse_Error (PARSE_FATAL,
d981 2
a982 5
		} else {
		    if (paths == NULL)
			paths = Lst_New();
		    Lst_AtEnd(paths, path);
		}
d1023 1
a1023 1
		    Lst_AtEnd(targets, gn);
d1057 1
a1057 1
    if (!Lst_IsEmpty(targets)) {
d1098 1
a1098 1
    Lst_Find(targets, ParseDoOp, &op);
d1132 1
a1132 1
		Lst_Every(paths, ParseClearPath);
d1198 1
a1198 1
		    Lst_ForEach(paths, ParseAddDir, line);
d1221 1
a1221 2
	if (paths)
	    Lst_Delete(paths, NOFREE);
d1281 1
a1281 1
	Lst_Find(targets, ParseFindMain, NULL);
d2403 3
a2405 3
	Lst_Every(targets, Suff_EndTransform);
	Lst_Delete(targets, ParseHasCommands);
	targets = NULL;
d2496 1
a2496 1
			Lst_ForEach(targets, ParseAddCmd, cp);
d2568 3
a2570 7
		    /*
		     * Need a non-circular list for the target nodes
		     */
		    if (targets)
			Lst_Delete(targets, NOFREE);

		    targets = Lst_New();
d2615 1
d2628 1
a2628 2
    if (targets)
	Lst_Delete(targets, NOFREE);
d2657 1
a2657 1
	Lst_Concat(listmain, &mainNode->cohorts, LST_CONCNEW);
@


1.43
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.42 2000/06/10 01:41:06 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.42 2000/06/10 01:41:06 espie Exp $";
a2651 3
 * Results:
 *	A Lst of the single node to create.
 *
d2653 1
a2653 1
 *	None.
d2657 3
a2659 2
Lst
Parse_MainName()
a2660 1
    Lst           listmain;	/* result list */
d2662 1
a2662 3
    listmain = Lst_New();

    if (mainNode == NULL) {
d2665 1
a2665 1
    } else if (mainNode->type & OP_DOUBLEDEP) {
a2670 1
    return (listmain);
@


1.42
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.41 2000/06/10 01:32:23 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.41 2000/06/10 01:32:23 espie Exp $";
d108 1
a108 1
static Lst	    fileNames;	/* file names to free at end */
d120 1
a120 1
static Lst     	    targCmds;	/* command lines for targets */
d150 1
a150 1
static Lst      includes;  	/* stack of IFiles generated by
d152 2
a153 2
Lst         	parseIncPath;	/* list of directories for "..." includes */
Lst         	sysIncPath;	/* list of directories for <...> includes */
d438 2
a439 2
    if (Lst_Member(pgn->children, cgn) == NULL) {
	Lst_AtEnd(pgn->children, cgn);
d441 1
a441 1
	    Lst_AtEnd(cgn->parents, pgn);
d503 1
a503 1
	Lst_ForEach(gn->parents, ParseLinkSrc, cohort);
d505 1
a505 1
	Lst_AtEnd(gn->cohorts, cohort);
d553 2
a554 2
	Lst_AtEnd(p->successors, s);
	Lst_AtEnd(s->preds, p);
d613 1
a613 1
	Lst_AtEnd(create, estrdup(src));
d628 2
a629 2
	    Lst_AtEnd(predecessor->successors, gn);
	    Lst_AtEnd(gn->preds, predecessor);
d659 1
a659 1
	    for (ln=Lst_First(gn->cohorts); ln != NULL; ln = Lst_Succ(ln)){
d787 1
a787 3
    Lst	    	    sources;	/* list of archive source names after
				 * expansion */
    Lst 	    curTargs;	/* list of target names to be found and added
d789 1
a789 1
    Lst		    curSrcs;	/* list of sources in order */
d797 2
a798 2
    curTargs = Lst_Init();
    curSrcs = Lst_Init();
d930 3
a932 4
			if (paths == NULL) {
			    paths = Lst_Init();
			}
			Lst_AtEnd(paths, dirSearchPath);
d935 1
a935 1
			if (!Lst_IsEmpty(create)) {
d984 2
a985 3
		    if (paths == NULL) {
			paths = Lst_Init();
		    }
d1005 3
a1007 1
		Lst	    emptyPath = Lst_Init();
d1009 1
a1009 1
		Dir_Expand(line, emptyPath, curTargs);
d1011 1
a1011 1
		Lst_Destroy(emptyPath, Dir_Destroy);
d1017 1
a1017 1
		Lst_AtEnd(curTargs, line);
d1020 1
a1020 1
	    while((targName = (char *)Lst_DeQueue(curTargs)) != NULL) {
d1059 2
a1060 4
    /*
     * Don't need the list of target names anymore...
     */
    Lst_Destroy(curTargs, NOFREE);
d1226 2
a1227 3
	if (paths) {
	    Lst_Destroy(paths, NOFREE);
	}
d1251 2
d1254 2
a1255 2
		sources = Lst_Init();
		if (Arch_ParseArchive (&line, sources, VAR_CMD) != SUCCESS) {
d1261 3
a1263 3
		while ((gn = (GNode *)Lst_DeQueue(sources)) != NULL)
		    ParseDoSrc(tOp, gn->name, curSrcs);
		Lst_Destroy(sources, NOFREE);
d1271 1
a1271 1
		ParseDoSrc (tOp, line, curSrcs);
d1290 2
a1291 4
    /*
     * Finally, destroy the list of sources
     */
    Lst_Destroy(curSrcs, NOFREE);
d1572 1
a1572 1
	Lst_AtEnd(gn->commands, cmd);
d1601 1
a1601 1
    if (!Lst_IsEmpty(gn->commands)) {
d1621 1
a1621 1
Parse_AddIncludeDir (dir)
d1624 1
a1624 1
    Dir_AddDir (parseIncPath, dir);
d1729 1
a1729 1
	    fullname = Dir_FindFile (newName, parseIncPath);
d1731 1
a1731 1
		fullname = Dir_FindFile(newName, dirSearchPath);
d1750 1
a1750 1
	fullname = Dir_FindFile (file, parseIncPath);
d1752 1
a1752 1
	    fullname = Dir_FindFile(file, dirSearchPath);
d1761 1
a1761 1
	fullname = Dir_FindFile(file, sysIncPath);
d1786 1
a1786 1
    Lst_AtFront(includes, oldFile);
d1796 1
a1796 1
    Lst_AtEnd(fileNames, fname);
d1841 1
a1841 1
    Lst_AtFront(includes, oldFile);
d1921 3
a1923 4
	fullname = Dir_FindFile (newName, parseIncPath);
	if (fullname == (char *)NULL) {
	    fullname = Dir_FindFile(newName, dirSearchPath);
	}
d1937 3
a1939 4
	fullname = Dir_FindFile (file, parseIncPath);
	if (fullname == (char *)NULL) {
	    fullname = Dir_FindFile(file, dirSearchPath);
	}
d1947 1
a1947 1
	fullname = Dir_FindFile(file, sysIncPath);
d1969 1
a1969 1
    Lst_AtFront(includes, oldFile);
d1979 1
a1979 1
    lst_AtEnd(fileNames, fname);
d2016 1
a2016 1
    if ((ifile = (IFile *)Lst_DeQueue(includes)) == NULL)
d2410 1
a2410 1
	Lst_Destroy(targets, ParseHasCommands);
d2443 1
a2443 1
    Lst_AtEnd(fileNames, fname);
d2504 1
a2504 1
			Lst_AtEnd(targCmds, line);
d2578 1
a2578 1
			Lst_Destroy(targets, NOFREE);
d2580 1
a2580 1
		    targets = Lst_Init();
a2613 3
 * Results:
 *	none
 *
d2619 1
a2619 1
Parse_Init ()
d2622 3
a2624 3
    parseIncPath = Lst_Init();
    sysIncPath = Lst_Init();
    includes = Lst_Init();
d2626 2
a2627 2
    targCmds = Lst_Init();
    fileNames = Lst_Init();
d2635 2
a2636 2
    Lst_Destroy(targCmds, (SimpleProc)free);
    Lst_Destroy(fileNames, (void (*) __P((ClientData))) free);
d2638 4
a2641 4
	Lst_Destroy(targets, NOFREE);
    Lst_Destroy(sysIncPath, Dir_Destroy);
    Lst_Destroy(parseIncPath, Dir_Destroy);
    Lst_Destroy(includes, NOFREE);	/* Should be empty now */
d2665 1
a2665 1
    listmain = Lst_Init();
d2672 1
a2672 1
	Lst_Concat(listmain, mainNode->cohorts, LST_CONCNEW);
@


1.41
log
@Thus, Lst_ForEach no longer needs returning a status.
In fact, it can become a macro based on Lst_ForEachFrom.
This also introduces Lst_Every, as a shortcut for the very common case where
Lst_ForEach does not need any user data.

Finally,  make consistent use of a few function typedefs, instead of having
explicit void (*)(Lst)  arguments all over the place.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.40 2000/06/10 01:26:37 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.40 2000/06/10 01:26:37 espie Exp $";
d251 3
a253 3
static void ParseLinkSrc __P((ClientData, ClientData));
static int ParseDoOp __P((ClientData, ClientData));
static int ParseAddDep __P((ClientData, ClientData));
d255 3
a257 3
static int ParseFindMain __P((ClientData, ClientData));
static void ParseAddDir __P((ClientData, ClientData));
static void ParseClearPath __P((ClientData));
d259 1
a259 1
static void ParseAddCmd __P((ClientData, ClientData));
d262 1
a262 1
static void ParseHasCommands __P((ClientData));
d433 2
a434 2
    ClientData     pgnp;	/* The parent node */
    ClientData     cgnp;	/* The child node */
d464 3
a466 3
    ClientData     gnp;		/* The node to which the operator is to be
				 * applied */
    ClientData     opp;		/* The operator to apply */
d541 2
a542 2
    ClientData pp;
    ClientData sp;
d694 2
a695 2
    ClientData	  gnp;	    /* Node to examine */
    ClientData    dummy;
d719 2
a720 2
    ClientData	  path;
    ClientData    name;
d737 1
a737 1
    ClientData path;
d1571 2
a1572 2
    ClientData gnp;	/* the node to which the command is to be added */
    ClientData cmd;	/* the command to add */
d1603 1
a1603 1
    ClientData 	  gnp;	    /* Node to examine */
d2030 2
a2031 2
	free((Address) curPTR->str);
	free((Address) curPTR);
d2035 1
a2035 1
    free ((Address)ifile);
d2362 1
a2362 1
		free ((Address) line);
@


1.40
log
@Lst_Find and Lst_ForEach do the same thing, except that the comparison
sense is reversed (Lst_Find  returns when proc says 0, whereas Lst_ForEach
goes on while proc says 0).

This patch turns a number of Lst_ForEach into Lst_Find.
Specifically, all Lst_ForEach that actually may return quickly as proc
does not always returns zero.

Of course, the corresponding proc need to be tweaked to swap 0 and 1...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.39 2000/04/17 23:54:47 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.39 2000/04/17 23:54:47 espie Exp $";
d251 1
a251 1
static int ParseLinkSrc __P((ClientData, ClientData));
d256 2
a257 2
static int ParseAddDir __P((ClientData, ClientData));
static int ParseClearPath __P((ClientData, ClientData));
d259 1
a259 1
static int ParseAddCmd __P((ClientData, ClientData));
a424 3
 * Results:
 *	Always = 0
 *
d431 2
a432 2
static int
ParseLinkSrc (pgnp, cgnp)
d436 2
a437 2
    GNode          *pgn = (GNode *) pgnp;
    GNode          *cgn = (GNode *) cgnp;
d440 1
a440 1
	if (specType == Not) {
a441 1
	}
a443 1
    return (0);
d450 1
a450 1
 *	Lst_ForEach call by ParseDoDependency once all targets have
a711 3
 * Results:
 *	=== 0
 *
d717 1
a717 1
static int
d722 1
a722 2
    Dir_AddDir((Lst) path, (char *) name);
    return(0);
a729 3
 * Results:
 *	=== 0
 *
d735 2
a736 2
static int
ParseClearPath(path, dummy)
a737 1
    ClientData dummy;
d739 1
a739 2
    Dir_ClearPath((Lst) path);
    return(dummy ? 0 : 0);
d1141 1
a1141 1
		Lst_ForEach(paths, ParseClearPath, NULL);
d1266 1
a1266 1
		Lst_Destroy (sources, NOFREE);
a1565 3
 * Results:
 *	Always 0
 *
d1569 1
a1569 1
static int
d1574 1
a1574 1
    GNode *gn = (GNode *) gnp;
a1582 1
    return(0);
a2406 3
 * Results:
 *	Nothing.
 *
d2416 2
a2417 2
	Lst_ForEach(targets, Suff_EndTransform, NULL);
	Lst_Destroy (targets, ParseHasCommands);
d2509 1
a2509 1
			Lst_ForEach (targets, ParseAddCmd, cp);
d2645 1
a2645 1
    Lst_Destroy(targCmds, (void (*) __P((ClientData))) free);
@


1.39
log
@Record location in target node as well.
Indicate what went wrong for commands like
	@@exit 1
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.37 2000/03/26 16:21:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.37 2000/03/26 16:21:32 espie Exp $";
d460 1
a460 1
 *	Always 0
d481 3
a483 4
	!OP_NOP(gn->type) && !OP_NOP(op))
    {
	Parse_Error (PARSE_FATAL, "Inconsistent operator for %s", gn->name);
	return (1);
d525 1
a525 1
    return (0);
d536 2
a537 2
 *	Returns 1 if the two targets need to be ordered, 0 otherwise.
 *	If it returns 1, the search can stop
d560 1
a560 1
	return 0;
d563 1
a563 1
	return 1;
d598 1
a598 1
		Lst_ForEach (targets, ParseDoOp, &op);
d678 2
a679 3
    if (waiting) {
	Lst_ForEach(allsrc, ParseAddDep, gn);
    }
d690 1
a690 1
 *	0 if main not found yet, 1 if it is.
d706 2
a708 2
    } else {
	return (dummy ? 0 : 0);
d1121 1
a1121 1
    Lst_ForEach (targets, ParseDoOp, &op);
d1304 1
a1304 1
	Lst_ForEach(targets, ParseFindMain, NULL);
@


1.38
log
@Don't free Makefile filenames when the file is finished reading, but
keep them for error reporting.
@
text
@d1595 1
a1595 1
    if (!(gn->type & OP_HAS_COMMANDS))
d1597 5
@


1.37
log
@Remove idiotic, braindead casts T* -> void*
They serve no purpose, except hiding potential bugs.

In particular, remove (ClientData) cast from macro, showing potentially
troublesome use of Hashes to store time_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.36 2000/01/08 09:45:15 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.36 2000/01/08 09:45:15 espie Exp $";
d107 4
d1815 3
a1866 1
    fname = estrdup(fname);
d2000 3
a2039 1
    free ((Address) fname);
d2466 4
a2469 1
    fname = name;
d2655 1
d2664 1
d2711 6
@


1.36
log
@Finish changing all Var_Parse arguments to size_t. Thanks to millert@@
for reminding me.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.35 1999/12/18 21:58:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.35 1999/12/18 21:58:07 espie Exp $";
d437 2
a438 2
    if (Lst_Member (pgn->children, (ClientData)cgn) == NULL) {
	Lst_AtEnd(pgn->children, (ClientData)cgn);
d440 1
a440 1
	    Lst_AtEnd(cgn->parents, (ClientData)pgn);
d505 1
a505 1
	Lst_ForEach(gn->parents, ParseLinkSrc, (ClientData)cohort);
d507 1
a507 1
	Lst_AtEnd(gn->cohorts, (ClientData)cohort);
d512 2
a513 2
	ln = Lst_Member(targets, (ClientData)gn);
	Lst_Replace(ln, (ClientData)cohort);
d555 2
a556 2
	Lst_AtEnd(p->successors, (ClientData)s);
	Lst_AtEnd(s->preds, (ClientData)p);
d595 1
a595 1
		Lst_ForEach (targets, ParseDoOp, (ClientData)&op);
d615 1
a615 1
	Lst_AtEnd(create, (ClientData)estrdup(src));
d630 2
a631 2
	    Lst_AtEnd(predecessor->successors, (ClientData)gn);
	    Lst_AtEnd(gn->preds, (ClientData)predecessor);
d655 1
a655 1
	    Lst_ForEach (targets, ParseLinkSrc, (ClientData)gn);
d666 1
a666 1
		    Lst_ForEach(targets, ParseLinkSrc, (ClientData)cohort);
d674 1
a674 1
    Lst_AtEnd(allsrc, (ClientData)gn);
d676 1
a676 1
	Lst_ForEach(allsrc, ParseAddDep, (ClientData)gn);
d947 1
a947 1
			Lst_AtEnd(paths, (ClientData)dirSearchPath);
d959 1
a959 1
			Lst_AtEnd(targets, (ClientData)gn);
d964 1
a964 1
			Lst_AtEnd(targets, (ClientData)gn);
d1002 1
a1002 1
		    Lst_AtEnd(paths, (ClientData)path);
d1031 1
a1031 1
		Lst_AtEnd(curTargs, (ClientData)line);
d1042 1
a1042 1
		    Lst_AtEnd(targets, (ClientData)gn);
d1119 1
a1119 1
    Lst_ForEach (targets, ParseDoOp, (ClientData)&op);
d1153 1
a1153 1
		Lst_ForEach(paths, ParseClearPath, (ClientData)NULL);
d1219 1
a1219 1
		    Lst_ForEach(paths, ParseAddDir, (ClientData)line);
d1302 1
a1302 1
	Lst_ForEach (targets, ParseFindMain, (ClientData)0);
d1802 1
a1802 1
    Lst_AtFront(includes, (ClientData)oldFile);
d1854 1
a1854 1
    Lst_AtFront(includes, (ClientData)oldFile);
d1985 1
a1985 1
    Lst_AtFront(includes, (ClientData)oldFile);
d2426 1
a2426 1
	Lst_ForEach(targets, Suff_EndTransform, (ClientData)NULL);
d2518 1
a2518 1
			Lst_AtEnd(targCmds, (ClientData) line);
d2686 1
a2686 1
	Lst_AtEnd(listmain, (ClientData)mainNode);
d2690 1
a2690 1
	Lst_AtEnd(listmain, (ClientData)mainNode);
@


1.35
log
@Nothing ever checks ReturnStatus on Lst_Insert, Lst_Append, Lst_AtFront,
Lst_AtEnd, Lst_Concat, Lst_Remove, Lst_Replace.

Don't bother returning one.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.34 1999/12/18 21:56:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.34 1999/12/18 21:56:07 espie Exp $";
d851 1
a851 1
		int 	length;
@


1.34
log
@Lst_DeQueue already checks for empty lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.33 1999/12/18 21:53:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.33 1999/12/18 21:53:32 espie Exp $";
d438 1
a438 1
	(void)Lst_AtEnd (pgn->children, (ClientData)cgn);
d440 1
a440 1
	    (void)Lst_AtEnd (cgn->parents, (ClientData)pgn);
d507 1
a507 1
	(void)Lst_AtEnd(gn->cohorts, (ClientData)cohort);
d555 2
a556 2
	(void)Lst_AtEnd(p->successors, (ClientData)s);
	(void)Lst_AtEnd(s->preds, (ClientData)p);
d615 1
a615 1
	(void) Lst_AtEnd (create, (ClientData)estrdup(src));
d630 2
a631 2
	    (void)Lst_AtEnd(predecessor->successors, (ClientData)gn);
	    (void)Lst_AtEnd(gn->preds, (ClientData)predecessor);
d674 1
a674 1
    (void)Lst_AtEnd(allsrc, (ClientData)gn);
d947 1
a947 1
			(void)Lst_AtEnd(paths, (ClientData)dirSearchPath);
d959 1
a959 1
			(void)Lst_AtEnd(targets, (ClientData)gn);
d964 1
a964 1
			(void)Lst_AtEnd(targets, (ClientData)gn);
d1002 1
a1002 1
		    (void)Lst_AtEnd(paths, (ClientData)path);
d1031 1
a1031 1
		(void)Lst_AtEnd(curTargs, (ClientData)line);
d1042 1
a1042 1
		    (void)Lst_AtEnd (targets, (ClientData)gn);
d1592 1
a1592 1
	(void)Lst_AtEnd(gn->commands, cmd);
d1802 1
a1802 1
    (void) Lst_AtFront (includes, (ClientData)oldFile);
d1854 1
a1854 1
    (void) Lst_AtFront (includes, (ClientData)oldFile);
d1985 1
a1985 1
    (void) Lst_AtFront (includes, (ClientData)oldFile);
d2686 1
a2686 1
	(void) Lst_AtEnd (listmain, (ClientData)mainNode);
d2690 1
a2690 1
	(void) Lst_AtEnd (listmain, (ClientData)mainNode);
@


1.33
log
@NIL, NILGNODE, etc, are only glorified NULL.
Get rid of them.

Get rid of list.h, nothing uses it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.32 1999/12/18 02:11:27 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.32 1999/12/18 02:11:27 espie Exp $";
d1012 2
d1034 1
a1034 3
	    while(!Lst_IsEmpty(curTargs)) {
		char	*targName = (char *)Lst_DeQueue(curTargs);

d1276 2
a1277 4
		while (!Lst_IsEmpty (sources)) {
		    gn = (GNode *) Lst_DeQueue (sources);
		    ParseDoSrc (tOp, gn->name, curSrcs);
		}
d2029 2
a2030 5
    if (Lst_IsEmpty (includes)) {
	return (DONE);
    }

    ifile = (IFile *) Lst_DeQueue (includes);
@


1.32
log
@make does not use circular lists, get rid of the extra weight.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.31 1999/12/16 17:27:18 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.31 1999/12/16 17:27:18 espie Exp $";
d190 1
a190 1
 * Predecessor node for handling .ORDER. Initialized to NILGNODE when .ORDER
d437 1
a437 1
    if (Lst_Member (pgn->children, (ClientData)cgn) == NILLNODE) {
d629 1
a629 1
	if (predecessor != NILGNODE) {
d661 1
a661 1
	    for (ln=Lst_First(gn->cohorts); ln != NILLNODE; ln = Lst_Succ(ln)){
d940 1
a940 1
		 *  	.ORDER	    	Must set initial predecessor to NIL
d978 1
a978 1
			predecessor = NILGNODE;
d993 1
a993 1
		if (path == NILLST) {
d999 1
a999 1
		    if (paths == (Lst)NULL) {
d1297 1
a1297 1
    if (mainNode == NILGNODE) {
d2643 1
a2643 1
    mainNode = NILGNODE;
d2687 1
a2687 1
    if (mainNode == NILGNODE) {
@


1.31
log
@Var_Subst is actually two distinct functions folded into one:
split the function specific to for.c out, and give them more sensible
arguments at the same time.

This makes .for loop handling more efficient, as we have some heuristic
to evaluate the size of the buffer needed...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.30 1999/12/16 17:07:21 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.30 1999/12/16 17:07:21 espie Exp $";
d811 2
a812 2
    curTargs = Lst_Init(FALSE);
    curSrcs = Lst_Init(FALSE);
d945 1
a945 1
			    paths = Lst_Init(FALSE);
d1000 1
a1000 1
			paths = Lst_Init(FALSE);
d1019 1
a1019 1
		Lst	    emptyPath = Lst_Init(FALSE);
d1269 1
a1269 1
		sources = Lst_Init (FALSE);
d2599 1
a2599 1
		    targets = Lst_Init (FALSE);
d2644 3
a2646 3
    parseIncPath = Lst_Init (FALSE);
    sysIncPath = Lst_Init (FALSE);
    includes = Lst_Init (FALSE);
d2648 1
a2648 1
    targCmds = Lst_Init (FALSE);
d2685 1
a2685 1
    listmain = Lst_Init (FALSE);
@


1.30
log
@for.c becomes sane.
- split For_Eval into For_Eval (first line of loop) / For_Accumulate
(remaining lines).
- encapsulate state into a For structure, instead of brain damaged static
variables that need copy.

Very minor performance hit, specifically, For structure is allocated with
malloc/free, instead of playing tricks with static/auto variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.29 1999/12/16 17:02:45 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.29 1999/12/16 17:02:45 espie Exp $";
d1538 1
a1538 1
	cp = Var_Subst(NULL, cp, ctxt, FALSE);
d1554 1
a1554 1
	    cp = Var_Subst(NULL, cp, VAR_CMD, TRUE);
d1718 1
a1718 1
    file = Var_Subst (NULL, file, VAR_CMD, FALSE);
d1918 1
a1918 1
    file = Var_Subst (NULL, file, VAR_CMD, FALSE);
d2589 1
a2589 1
		    cp = Var_Subst (NULL, line, VAR_CMD, TRUE);
@


1.29
log
@Allocate buffers as static data structures.
This cuts down quite a lot of malloc, since in actual use,
buffer usage is mostly static.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.28 1999/12/16 16:52:11 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.28 1999/12/16 16:52:11 espie Exp $";
d2378 7
a2384 2
		if (For_Eval(line)) {
		    int ok;
d2387 1
a2387 3
			/*
			 * Skip after the matching end
			 */
d2390 1
a2390 1
			    Parse_Error (PARSE_FATAL,
d2392 1
a2392 1
			    break;
d2394 1
a2394 1
			ok = For_Eval(line);
d2396 2
a2397 4
		    }
		    while (ok);
		    if (line != NULL)
			For_Run();
d2401 1
@


1.28
log
@Remove unneeded extraneous zeros at the end of buffers.

Actually, one of these needs to be there, because of two bugs in cond.c
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.27 1999/12/16 16:41:42 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.27 1999/12/16 16:41:42 espie Exp $";
d2109 1
a2109 1
    Buffer buf;
d2111 1
a2111 1
    buf = Buf_Init(MAKE_BSIZE);
d2114 1
a2114 1
        Buf_Reset(buf);
d2120 1
a2120 1
                Buf_ReplaceLastChar(buf, ' ');
d2129 1
a2129 1
            Buf_AddChar(buf, c);
d2133 1
a2133 1
        line = Buf_Retrieve(buf);
d2141 2
a2142 2
            Buf_Destroy(buf, TRUE);
            return((char *)NULL);
a2148 1
    Buf_Destroy(buf, FALSE);
d2173 1
a2173 1
    Buffer  	  buf;	    	/* Buffer for current line */
d2216 1
a2216 1
	buf = Buf_Init(MAKE_BSIZE);
d2330 1
a2330 1
	    Buf_AddChar(buf, lastc);
d2338 2
a2339 3
	    Buf_AddChar(buf, lastc);
	line = Buf_Retrieve(buf);
	Buf_Destroy(buf, FALSE);
@


1.27
log
@Split Buf_GetAll into Buf_Retrieve/Buf_Size.
(idiotic to retrieve size every time when it's used half the time)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.26 1999/12/16 16:27:12 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.26 1999/12/16 16:27:12 espie Exp $";
a2132 1
        Buf_AddChar(buf, '\0');
d2338 1
a2338 1
	if (lastc != '\0') {
a2339 2
	}
	Buf_AddChar(buf, '\0');
@


1.26
log
@Start cleaning up buf.c in earnest.

- Buf_Discard is only used to remove all the bytes in a buffer,
replace with Buf_Reset,
- buffer values are not read unless accessed first through Buf_GetAll,
no need to null-terminate it at every point.
- Buf_Expand need not check if the expansion is needed. That's Buf_AddChar
and Buf_AddChars responsability (otherwise, Buf_AddChar checks twice)
- Buf_Overflow only handles overflow. Adding the character is done in
every case anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.25 1999/12/06 22:24:31 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.25 1999/12/06 22:24:31 espie Exp $";
d2134 1
a2134 1
        line = Buf_GetAll(buf, NULL);
d2343 1
a2343 1
	line = Buf_GetAll(buf, NULL);
@


1.25
log
@Clean up buffers interface somewhat:

- buf.c deals exclusively with chars. Be explicit about it, and remove
extraneous dumb casts to char (can hide real type errors).
- buffer sizes are size_t. Note that bp->left can never become NULL.
- Buf_GetAll is happy with a NULL pointer for the size, remove unneeded
extra pointers.
- Propagate size_t to all places where buffer functions are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.24 1999/11/11 11:42:19 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.24 1999/11/11 11:42:19 espie Exp $";
a2108 1
    size_t lineLength = 0;
d2114 1
a2114 1
        Buf_Discard(buf, lineLength);
d2134 1
a2134 1
        line = Buf_GetAll(buf, &lineLength);
@


1.24
log
@Communicate line numbers between parse.c and for.c.
Parse_String starts in the current line, but at a given line number.

.for loops yield correct line numbers, much easier to debug !
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.22 1999/11/10 14:00:54 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.22 1999/11/10 14:00:54 espie Exp $";
d2108 2
a2109 1
    int c, lastc, lineLength = 0;
d2121 1
a2121 1
                Buf_ReplaceLastByte(buf, (Byte)' ');
d2130 1
a2130 1
            Buf_AddByte(buf, (Byte)c);
d2134 2
a2135 2
        Buf_AddByte(buf, (Byte)'\0');
        line = (char *)Buf_GetAll(buf, &lineLength);
a2185 1
    int	    	  lineLength;	/* Length of result */
d2333 1
a2333 1
	    Buf_AddByte (buf, (Byte)lastc);
d2341 1
a2341 1
	    Buf_AddByte (buf, (Byte)lastc);
d2343 3
a2345 3
	Buf_AddByte (buf, (Byte)'\0');
	line = (char *)Buf_GetAll (buf, &lineLength);
	Buf_Destroy (buf, FALSE);
@


1.23
log
@Lineno as unsigned long. Slightly easier for printf, and more sensible.
@
text
@d140 4
a143 4
    char           *fname;	    /* name of previous file */
    unsigned long  lineno;	    /* saved line number */
    FILE 	   *F;		    /* the open stream */
    PTR            *p;	    	    /* the char pointer */
d1841 3
a1843 2
Parse_FromString(str)
    char *str;
d1861 1
a1861 1
    lineno = 0;
d2702 7
@


1.22
log
@Make ParseSkipLine more regular:
perform the exit tests before checking for EOF.

This makes behavior while scanning tests more regular.
e.g,

.if defined(UVM) && ${UVM} == "yes"
...
.endif

without a final newline at the endif should always work,
instead of being an error half the time...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.21 1999/10/05 22:08:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.21 1999/10/05 22:08:07 espie Exp $";
d126 1
a126 1
static int          lineno;	/* line number in current file */
d141 3
a143 3
    int             lineno;	    /* saved line number */
    FILE *          F;		    /* the open stream */
    PTR *	    p;	    	    /* the char pointer */
d244 2
a245 2
static void ParseErrorInternal __P((char *, size_t, int, char *, ...));
static void ParseVErrorInternal __P((char *, size_t, int, char *, va_list));
d322 1
a322 1
ParseVErrorInternal(char *cfname, size_t clineno, int type, char *fmt,
d329 1
a329 1
	(void)fprintf(stderr, "\"%s\", line %d: ", cfname, (int) clineno);
d353 1
a353 1
ParseErrorInternal(char *cfname, size_t clineno, int type, char *fmt, ...)
d366 1
a366 1
	size_t clineno;
d370 1
a370 1
	clineno = va_arg(ap, size_t);
@


1.21
log
@Mark ParseReadC as inline (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.20 1999/10/05 22:06:24 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.20 1999/10/05 22:06:24 espie Exp $";
d2112 1
a2112 1
    do {
d2132 7
d2144 2
d2147 1
a2147 4
        lineno++;
        Buf_AddByte(buf, (Byte)'\0');
        line = (char *)Buf_GetAll(buf, &lineLength);
    } while (skip == 1 && line[0] != '.');
@


1.20
log
@Efficiency patch from NetBSD:
make spends time freeing data structures right before exiting.
So don't bother.
Keep the code inside #ifdef, so that it's still there if someone
ever wants to use make code inside a library.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.19 1999/05/04 16:44:45 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.19 1999/05/04 16:44:45 millert Exp $";
d256 1
a256 1
static int ParseReadc __P((void));
d2061 1
a2061 1
static int
@


1.19
log
@Better comment explaining last change:
We don't want to end a word on ':' or '!' if there is a better match
later on in the string.  By "better" I mean one that is followed
by whitespace.  This allows the user to have targets like: fie::fi:fo: fum
where "fie::fi:fo" is the target.  In real life this is used
for perl5 library man pages where "::" separates an object from its
class.  Ie: "File::Spec::Unix".  This behaviour is also consistent
with other versions of make.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.18 1999/05/04 16:09:25 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.18 1999/05/04 16:09:25 millert Exp $";
d115 1
d117 1
d2519 1
d2521 1
d2644 1
d2646 1
d2652 1
d2659 1
@


1.18
log
@Allow embedded ":" or "!" in target names
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.17 1998/12/05 00:06:29 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.17 1998/12/05 00:06:29 espie Exp $";
d817 11
d835 1
a835 3
		 * a match later on followed by whitespace.  This
		 * allows us to have targets with embedded ':' and '!'
		 * characters.
@


1.17
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.15 1997/07/25 21:05:35 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.15 1997/07/25 21:05:35 mickey Exp $";
d814 1
a814 2
	     *cp && !isspace (*cp) &&
	     (*cp != '!') && (*cp != ':') && (*cp != '(');
d817 16
a832 1
	    if (*cp == '$') {
@


1.16
log
@Fix a bug where make gets confused by targets beginning with a period (``.'')
and tried to do a suffix conversion, following a NULL pointer in the
proccess.  Also add some sanity checks so we don't blindly assume
strchr returns non-NULL.
@
text
@d167 1
d220 3
d242 2
d306 1
a306 1
 * Parse_Error  --
d318 71
d409 1
a409 9
	(void)fprintf(stderr, "\"%s\", line %d: ", fname, lineno);
	if (type == PARSE_WARNING)
		(void)fprintf(stderr, "warning: ");
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
	(void)fflush(stderr);
	if (type == PARSE_FATAL)
		fatals += 1;
d699 1
a699 1
    if ((gn->type & (OP_NOTMAIN|OP_USE|OP_EXEC|OP_TRANSFORM)) == 0) {
d908 1
@


1.15
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.14 1997/04/28 01:52:40 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.14 1997/04/28 01:52:40 millert Exp $";
d946 2
a947 1
		(void)Lst_AtEnd (targets, (ClientData)gn);
@


1.14
log
@Back out newer .USE code as it caused problems.  I've done a "make build"
without problems and the problem Theo saw before is gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.13 1997/04/01 07:28:21 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.13 1997/04/01 07:28:21 millert Exp $";
d92 1
a92 1
#if __STDC__
d313 1
a313 1
#if __STDC__
d321 1
a321 1
#if __STDC__
@


1.13
log
@Sync with NetBSD (mostly by christos initial substitution/regexp from Der Mouse)

- fix the variable substitution code in make [PR/2748]
      1. change s/a/b/ so that it substitutes the first occurance of the
         pattern on each word, not only the first word.
      2. add flag '1' to the variable substitution so that the substitutions
         get performed only once.

  ***THIS IS AN INCOMPATIBLE CHANGE!***

  Unfortunately there was no way to make things consistent without
  modifying the current behavior. Fortunately none of our Makefiles
  depended on this.

            OLD:

                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4

            NEW:
                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 ba2 ba3 ba4
                S/a/b/1  = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4
                S/a/b/1g = bb1 aa2 aa3 aa4
- add regexp variable substitution via 'C/foo/bar/' [PR/2752]
- add variable quoting via the ${VAR:Q} modifier. This is useful when running
  recursive invocations of make(1):

        make VAR=${VAR:Q}

  will always work... (This may prove useful in the kernel builds...) [PR/2981]
- BSD did not traditionally have <sys/cdefs.h>; use BSD4_4 instead and include
  <sys/param.h> to grab it.
- Don't compile the regex code if MAKE_BOOTSTRAP (from gwr)
- Use explicit .c.o rule in Makefile.boot so that the bootstrap process works.
- Use only integral types in procedure arguments. [buf.c buf.h]
- Include <stdlib.h> to get getenv() prototype on SVR4
- if __STDC__ -> ifdef __STDC__ to appease SVR4
- Define const and volatile for non __STDC__
- Implement snprintf() and vsnprintf() for non BSD4_4 systems.
- Make $MACHINE_ARCH settable from the environment.
- Fix .USE directive problems: (reported by cgd)
    1. ${.*} variables did not get expanded in dependencies.
    2. expanded ${.*} variables in .USE dependencies can cause tree
       restructuring; handle it.
    3. in compat mode, expand .USE before evaluating the list of targets,
       instead of doing .USE expansions on demand, because they can cause
       tree restructuring.
- Add a .MADE directive to indicated that the children of a target are
  up-to-date, even when they are not. This is to simulate our current
  make install behavior with proper dependencies.
- Fix problems in the RE substitution error handling.
- Locate all the children of a node marked as MADE.
- Do not compile-in ${MACHINE} (as per NetBSD PR#3386)
- Disable globbing for targets/dependencies when POSIX is defined.
- Fix globbing so that patterns that don't have a matching number of [] or {}
  don't get expanded. (before the [ case got expanded to nothing!) This is
  disabled.
- Make sure that the children of nodes that are marked .MADE, are marked
  UPTODATE and their timestamps are consistent.
- Don't disable wildcards completely; they are used by other Makefiles.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.12 1997/03/26 17:46:44 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.12 1997/03/26 17:46:44 deraadt Exp $";
d2578 1
a2578 1
    Lst           main;	/* result list */
d2580 1
a2580 1
    main = Lst_Init (FALSE);
d2586 2
a2587 2
	(void) Lst_AtEnd (main, (ClientData)mainNode);
	Lst_Concat(main, mainNode->cohorts, LST_CONCNEW);
d2590 2
a2591 2
	(void) Lst_AtEnd (main, (ClientData)mainNode);
    return (main);
@


1.12
log
@s/main/listmain/; seebs@@solon.com
@
text
@d1 2
a2 2
/*	$OpenBSD: parse.c,v 1.11 1996/11/30 21:09:02 millert Exp $	*/
/*	$NetBSD: parse.c,v 1.27 1996/11/06 17:59:20 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.11 1996/11/30 21:09:02 millert Exp $";
d214 1
d470 1
a470 1
int
d2578 1
a2578 1
    Lst           listmain;	/* result list */
d2580 1
a2580 1
    listmain = Lst_Init (FALSE);
d2586 2
a2587 2
	(void) Lst_AtEnd (listmain, (ClientData)mainNode);
	Lst_Concat(listmain, mainNode->cohorts, LST_CONCNEW);
d2590 2
a2591 2
	(void) Lst_AtEnd (listmain, (ClientData)mainNode);
    return (listmain);
@


1.11
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.10 1996/09/21 05:03:37 briggs Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: parse.c,v 1.25 1996/09/13 04:22:09 christos Exp $";
d2577 1
a2577 1
    Lst           main;	/* result list */
d2579 1
a2579 1
    main = Lst_Init (FALSE);
d2585 2
a2586 2
	(void) Lst_AtEnd (main, (ClientData)mainNode);
	Lst_Concat(main, mainNode->cohorts, LST_CONCNEW);
d2589 2
a2590 2
	(void) Lst_AtEnd (main, (ClientData)mainNode);
    return (main);
@


1.10
log
@From NetBSD (christos):
- Fix bug where the first line after a conditionally skipped was not ready
  in its entirety if it contained a continuation.
- Print the whole error line, not just the first 20 characters of it.
@
text
@d1 2
a2 2
/*	$OpenBSD: parse.c,v 1.9 1996/09/02 16:04:17 briggs Exp $	*/
/*	$NetBSD: parse.c,v 1.25 1996/09/13 04:22:09 christos Exp $	*/
d5 2
a6 2
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
d44 1
a44 1
static char sccsid[] = "@@(#)parse.c	5.18 (Berkeley) 2/19/91";
d46 1
a46 1
static char rcsid[] = "$NetBSD: parse.c,v 1.25 1996/09/13 04:22:09 christos Exp $";
d279 1
a279 1
    
d402 1
a402 1
     * the operator actually has some dependency information in it, complain. 
d422 1
a422 1
			
d446 1
a446 1
     * just OR the new operator into the old 
d453 1
a453 1
/*- 
d466 1
a466 1
 *	
d741 1
a741 1
    
d789 1
a789 1
	
d793 1
a793 1
	     * no-no 
d806 1
a806 1
	     * or its sources handled specially. 
d814 1
a814 1
		
d874 1
a874 1
			
d894 1
a894 1
		
d910 1
a910 1
	
d913 1
a913 1
	 * the end of the targets list 
d924 1
a924 1
		
d926 1
a926 1
		
d935 1
a935 1
	    
d938 1
a938 1
		
d944 1
a944 1
		
d950 1
a950 1
	
d958 1
a958 1
	    
d1025 1
a1025 1
     * Get to the first source 
d1078 1
a1078 1
    
d1080 1
a1080 1
     * NOW GO FOR THE SOURCES 
d1199 1
a1199 1
    
d1245 1
a1245 1
    for (;(*line == ' ') || (*line == '\t'); line++) 
d1260 1
a1260 1
	     * only one word before the operator 
d1274 1
a1274 1
		
d1305 1
a1305 1
		haveName = TRUE; 
d1344 1
a1344 1
    char            *opc;	/* ptr to operator character to 
d1346 1
a1346 1
    /* 
d1552 1
a1552 1
 *	
d1644 1
a1644 1
	    
d1734 1
a1734 1
 *	
d1757 1
a1757 1
    
d1773 1
a1773 1
 *	
d1836 1
a1836 1
	    
d1956 1
a1956 1
 *	Read a character from the current file 
d1969 1
a1969 1
	  
d1979 1
a1979 1
 *	Put back a character to the current file 
d2010 1
a2010 1
    int c, lastc = '\0', lineLength;
d2013 32
a2044 1
    c = ParseReadc();
d2046 1
a2046 50
    if (skip) {
	/*
	 * Skip lines until get to one that begins with a
	 * special char.
	 */
	while ((c != '.') && (c != EOF)) {
	    while (((c != '\n') || (lastc == '\\')) && (c != EOF)) {
		/*
		 * Advance to next unescaped newline
		 */
		if ((lastc = c) == '\n') {
		    lineno++;
		}
		c = ParseReadc();
	    }
	    lineno++;
	    
	    lastc = c;
	    c = ParseReadc ();
	}
    }
    
    if (c == EOF) {
	Parse_Error (PARSE_FATAL, "Unclosed conditional/for loop");
	return ((char *)NULL);
    }
    
    /*
     * Read the entire line into buf
     */
    buf = Buf_Init (MAKE_BSIZE);
    if (c != '\n') {
	lastc = '\0';
	do {
	    if (lastc != '\0' && lastc != '\n')
		Buf_AddByte (buf, (Byte) lastc);
	    if ((lastc = c) == '\n')
		lineno++;
	    c = ParseReadc();
	    if (c == '\n' && lastc == '\\')
		lastc = '\0';
	} while (((c != '\n') || (lastc == '\0')) && (c != EOF));
	if (lastc != '\0' && lastc != '\n')
	    Buf_AddByte (buf, (Byte) lastc);
    }
    lineno++;
    
    Buf_AddByte (buf, (Byte)'\0');
    line = (char *)Buf_GetAll (buf, &lineLength);
    Buf_Destroy (buf, FALSE);
d2112 1
a2112 1
	
d2116 1
a2116 1
	
d2164 1
a2164 1
		} 
d2231 1
a2231 1
	    
d2235 1
a2235 1
	
d2251 1
a2251 1
	while (ep > line && (ep[-1] == ' ' || ep[-1] == '\t')) {
d2257 1
a2257 1
	
d2289 1
a2289 1
			    Parse_Error (PARSE_FATAL, 
d2337 1
a2337 1
		    
d2398 2
a2399 3
	    if (*line == '#' || *line == '\0') {
		/* If we're this far, the line must be a comment.
		   (Empty lines are ignored as well) */
d2402 1
a2402 1
	    
d2419 1
a2419 1
			 * commands of all targets in the dependency spec 
d2431 1
a2431 1
	    } else if (strncmp (line, "include", 7) == 0 && 
d2457 1
a2457 1
		
d2473 1
a2473 1
		    
d2490 1
a2490 1
		    
d2492 1
a2492 1
		     * Need a non-circular list for the target nodes 
d2499 1
a2499 1
		    
d2511 1
a2511 1
	 * Reached EOF, but it may be just EOF of an include file... 
d2558 1
a2558 1
    
@


1.9
log
@Sync up with NetBSD:
(christos)
	Fix bug reported by Greg Hudson where leaf (source only) nodes were
	referenced only by their basename and not by their full pathname. This
	breaks when .PATH or MAKEOBJDIR are used. There might be Makefiles
	around that try to work around this bug by prepending ${.CURDIR} to
	the sources, and they should be found and fixed. Also a lot of the gunk
	in suff.c that was attempting to work around the same problem could be
	removed.
(christos)
	- Move -D flags from Makefile to config.h and explain what they do. Add
	  -Wall -Wno-unused to CFLAGS. Add new define SYSVVARSUB to enable SysV
	  style variable substitutions and enable them.
	- Add SunOS style command substitutions via SUNSHCMD
	- Fix core dump with '{variable = value'
(christos)
	Fix bug where make will always exit with 0, even when one or more
	parallel jobs failed. (Only affects parallel make code)
(christos)
	Protect __P from being multiply defined (for systems that already
	define it)
(christos) Add strdup() since ultrix is missing it.
	From Larry Schwimmer <rosebud@@cyclone.Stanford.EDU>
(christos) Add estrdup(), a checked version of strdup and use it.
(christos) Recognize SVR4 style long filename entries in archives.
(thorpej) Tidy up some RCS ids a bit.
@
text
@d1 2
a2 2
/*	$OpenBSD: parse.c,v 1.8 1996/07/23 18:37:12 deraadt Exp $	*/
/*	$NetBSD: parse.c,v 1.24 1996/08/13 16:42:13 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: parse.c,v 1.24 1996/08/13 16:42:13 christos Exp $";
d2021 1
a2021 2
	    while (((c != '\n') || (lastc == '\\')) && (c != EOF))
	    {
d2047 1
d2049 4
a2052 1
	    Buf_AddByte (buf, (Byte)c);
d2054 5
a2058 1
	} while ((c != '\n') && (c != EOF));
d2445 1
a2445 1
				     "Unassociated shell command \"%.20s\"",
@


1.8
log
@nicer error message; netbsd pr#2651; enami@@ba2.so-net.or.jp
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: parse.c,v 1.22 1996/03/15 21:52:41 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: parse.c,v 1.22 1996/03/15 21:52:41 christos Exp $";
a99 1
#include <sys/wait.h>
d543 1
a543 1
	(void) Lst_AtEnd (create, (ClientData)strdup(src));
d1279 6
d1286 1
a1286 1
			 * character * must be an = or it ain't a valid
d1289 1
a1289 3
			if (line[1] != '=' && level == 0)
			    return FALSE;
			else
d1291 1
a1291 2
		    }
		    else {
d1293 1
a1293 1
			 * This is the start of another word, so not assignment.
d1295 3
a1297 1
			return FALSE;
d1299 4
d1405 11
d1447 3
a1449 14
	char	*args[4];   	/* Args for invoking the shell */
	int 	fds[2];	    	/* Pipe streams */
	int 	cpid;	    	/* Child PID */
	int 	pid;	    	/* PID from wait() */
	Boolean	freeCmd;    	/* TRUE if the command needs to be freed, i.e.
				 * if any variable expansion was performed */

	/* 
	 * Avoid clobbered variable warnings by forcing the compiler
	 * to ``unregister'' variables
	 */
#if __GNUC__
	(void) &freeCmd;
#endif
d1451 1
a1451 6
	/*
	 * Set up arguments for shell
	 */
	args[0] = "sh";
	args[1] = "-c";
	if (strchr(cp, '$') != (char *)NULL) {
d1457 1
a1457 1
	    args[2] = Var_Subst(NULL, cp, VAR_CMD, TRUE);
a1458 3
	} else {
	    args[2] = cp;
	    freeCmd = FALSE;
a1459 1
	args[3] = (char *)NULL;
d1461 3
a1463 4
	/*
	 * Open a pipe for fetching its output
	 */
	pipe(fds);
d1465 2
a1466 9
	/*
	 * Fork
	 */
	cpid = vfork();
	if (cpid == 0) {
	    /*
	     * Close input side of pipe
	     */
	    close(fds[0]);
d1468 2
a1469 93
	    /*
	     * Duplicate the output stream to the shell's output, then
	     * shut the extra thing down. Note we don't fetch the error
	     * stream...why not? Why?
	     */
	    dup2(fds[1], 1);
	    close(fds[1]);
	    
	    execv("/bin/sh", args);
	    _exit(1);
	} else if (cpid < 0) {
	    /*
	     * Couldn't fork -- tell the user and make the variable null
	     */
	    Parse_Error(PARSE_WARNING, "Couldn't exec \"%s\"", cp);
	    Var_Set(line, "", ctxt);
	} else {
	    int	status;
	    int cc;
	    Buffer buf;
	    char *res;

	    /*
	     * No need for the writing half
	     */
	    close(fds[1]);
	    
	    buf = Buf_Init (MAKE_BSIZE);

	    do {
		char   result[BUFSIZ];
		cc = read(fds[0], result, sizeof(result));
		if (cc > 0) 
		    Buf_AddBytes(buf, cc, (Byte *) result);
	    }
	    while (cc > 0 || (cc == -1 && errno == EINTR));

	    /*
	     * Close the input side of the pipe.
	     */
	    close(fds[0]);

	    /*
	     * Wait for the process to exit.
	     */
	    while(((pid = wait(&status)) != cpid) && (pid >= 0))
		continue;

	    res = (char *)Buf_GetAll (buf, &cc);
	    Buf_Destroy (buf, FALSE);

	    if (cc == 0) {
		/*
		 * Couldn't read the child's output -- tell the user and
		 * set the variable to null
		 */
		Parse_Error(PARSE_WARNING, "Couldn't read shell's output");
	    }

	    if (status) {
		/*
		 * Child returned an error -- tell the user but still use
		 * the result.
		 */
		Parse_Error(PARSE_WARNING, "\"%s\" returned non-zero", cp);
	    }

	    /*
	     * Null-terminate the result, convert newlines to spaces and
	     * install it in the variable.
	     */
	    res[cc] = '\0';
	    cp = &res[cc] - 1;

	    if (*cp == '\n') {
		/*
		 * A final newline is just stripped
		 */
		*cp-- = '\0';
	    }
	    while (cp >= res) {
		if (*cp == '\n') {
		    *cp = ' ';
		}
		cp--;
	    }
	    Var_Set(line, res, ctxt);
	    free(res);

	}
	if (freeCmd) {
	    free(args[2]);
	}
d1474 1
a1474 1
	Var_Set (line, cp, ctxt);
d1478 1
d1639 1
a1639 1
	Fname = strdup(fname);
d1647 1
a1647 1
		newName = strdup(file);
d1764 1
a1764 1
    fname = strdup(fname);
@


1.7
log
@From NetBSD: merge of 960317
@
text
@d2693 1
a2693 1
	Punt ("make: no target to make.\n");
@


1.6
log
@Make sure SYSV-style include directives are only matched when there is a
whitespace character after the word "include"
@
text
@d1 2
a2 1
/*	$NetBSD: parse.c,v 1.19 1996/02/07 23:04:04 thorpej Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: parse.c,v 1.19 1996/02/07 23:04:04 thorpej Exp $";
d174 1
d227 1
d838 1
@


1.5
log
@Implement an -m option used for replacing /usr/share/mk with a
custom search path, like $DESTDIR/usr/share/mk
@
text
@d2539 1
@


1.4
log
@From NetBSD:
Support SVR4 style archives.
Fix pr/1421 (from Matthew Green) and pr/1997 (from Jeff Thieleke).
In ParseDoInclude(), make a temporary copy of the current file name
while searching for ""-type include files, since the current file name
might not be a writeable string.
@
text
@a2646 4
	char *cp = NULL, *start;
					/* avoid faults on read-only strings */
	static char syspath[] = _PATH_DEFSYSPATH;
    
a2651 15

    /*
     * Add the directories from the DEFSYSPATH (more than one may be given
     * as dir1:...:dirn) to the system include path.
     */
    for (start = syspath; *start != '\0'; start = cp) {
	for (cp = start; *cp != '\0' && *cp != ':'; cp++) 
	    continue;
	if (*cp == '\0') {
	    Dir_AddDir(sysIncPath, start);
	} else {
	    *cp++ = '\0';
	    Dir_AddDir(sysIncPath, start);
	}
    }
@


1.3
log
@from christos:
- Added .WAIT to synchronize between sources like other pmake variants.
- Updated documentation to include .ORDER .PARALLEL .NO_PARALLEL .NONPARALLEL
@
text
@d1 1
a1 1
/*	$NetBSD: parse.c,v 1.18 1995/12/16 05:03:13 christos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: parse.c,v 1.18 1995/12/16 05:03:13 christos Exp $";
d1731 1
a1731 1
	char	  *prefEnd;
d1733 4
a1736 1
	prefEnd = strrchr (fname, '/');
d1744 1
a1744 1
		newName = str_concat (fname, file, STR_ADDSLASH);
d1754 1
@


1.2
log
@from christos@@netbsd:
Minor:
    - ${.PREFIX} should never contain a full pathname
    - Fixed gcc -Wall warnings
Major:
    - compatMake is now FALSE. This means that we are now running in
      full pmake mode:
          * rules on dependency lines can be executed in parallel and or
            out of sequence:

            foo: bar baz

            can fire the rule for baz before the rule for bar is fired.
            To enforce bar to be fired before baz, another rule needs to be
            added. [bar: baz]
          * adjacent shell commands in a target are now executed by a single
            invocation of the shell, not one invocation of the shell per line
      (compatMake can be turned off using the -B flag)
    - The -j flag now works... I.e. make -j 4 will fork up to four jobs in
      parallel when it can. The target name is printed before each burst
      of output caused by the target execution as '--- target ---', when j > 1
    - I have changed all the Makefiles so that they work with make -j N, and
      I have tested the whole netbsd by:
          'make -j 4 cleandir; make -j 4 depend; make -j 4; make -j 4 install'
    - I have not compiled or tested this version of make with -DREMOTE.
- Turn compat mode on by default. It gets turned off when the -j without
  the -B flag is specified. [Thus you can use -j 1 to turn it off].
- Fix malloc -> emalloc as Gordon noted.
Updates for POSIX/SVR4 compiling:
arch.c:          Don't require ranlib stuff. Not everybody has it.
dir.c:           SunOS-4 != Solaris; change #ifdef sun to #if sun && !__svr4__
job.c, compat.c: Don't use 'union wait', use int and the W*() macros.
main.c:          Check for uname() == -1; some unames return > 0...
util.c, job.c:   Add signal() with BSD semantics for svr4, don't use bsd
                 sigmask and friends.

from cgd@@netbsd:
pull in make.h.  (PAlloc() now uses emalloc(), which is prototyped in
make.h.  If the prototype is not in scope on the Alpha, I see lots
of "cast to pointer from integer of different size" warnings.)
@
text
@d1 1
a1 1
/*	$NetBSD: parse.c,v 1.17 1995/11/02 23:55:03 christos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: parse.c,v 1.17 1995/11/02 23:55:03 christos Exp $";
d171 1
d178 1
d183 1
d219 1
d223 1
d232 1
d238 2
a239 1
static void ParseDoSrc __P((int, char *));
d451 39
d508 1
a508 1
ParseDoSrc (tOp, src)
d511 2
d514 1
a514 2
    int		op;	/* operator (if any) from special source */
    GNode	*gn;
a515 1
    op = 0;
d519 9
a527 1
	    op = parseKeywords[keywd].op;
d530 3
a532 3
    if (op != 0) {
	Lst_ForEach (targets, ParseDoOp, (ClientData)&op);
    } else if (specType == Main) {
d547 3
a549 1
    } else if (specType == Order) {
d563 3
a565 1
    } else {
d596 7
d725 2
a726 1
    Lst	    	    sources;	/* list of source names after expansion */
d729 1
d734 1
d738 1
d1178 1
a1178 1
		    ParseDoSrc (tOp, gn->name);
d1188 1
a1188 1
		ParseDoSrc (tOp, line);
d1207 4
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: parse.c,v 1.16 1995/09/10 03:58:16 christos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: parse.c,v 1.16 1995/09/10 03:58:16 christos Exp $";
d2219 5
a2223 1
		    if (compatMake && (lastc != '\\')) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
