head	1.47;
access;
symbols
	OPENBSD_6_2_BASE:1.47
	OPENBSD_6_1:1.46.0.4
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.41.0.6
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.33.0.4
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.30.0.4
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.2
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.25.0.8
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.10
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.6
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.8
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.6
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6;
locks; strict;
comment	@ * @;


1.47
date	2017.07.10.07.10.29;	author bluhm;	state Exp;
branches;
next	1.46;
commitid	pS7ZddbDzedvKvwe;

1.46
date	2017.02.24.23.38.47;	author espie;	state Exp;
branches;
next	1.45;
commitid	Di7APe9pPPoGjzSq;

1.45
date	2017.01.25.14.17.45;	author espie;	state Exp;
branches;
next	1.44;
commitid	0OAXX2W4NsR3UI9u;

1.44
date	2016.10.02.17.42.31;	author tb;	state Exp;
branches;
next	1.43;
commitid	R5IOpZHDIgjj5qk9;

1.43
date	2015.11.15.06.19.22;	author daniel;	state Exp;
branches;
next	1.42;
commitid	NHRgVVfv00xsvnmo;

1.42
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	0Dp7Dy9FuNZesYo2;

1.41
date	2015.01.23.22.35.58;	author espie;	state Exp;
branches;
next	1.40;
commitid	WtGGWUPWONvkhNGN;

1.40
date	2015.01.23.13.18.40;	author espie;	state Exp;
branches;
next	1.39;
commitid	iXa5WmoY9RgeqDsn;

1.39
date	2014.09.21.13.43.25;	author espie;	state Exp;
branches;
next	1.38;
commitid	zw3F9TYAm6Oyxx78;

1.38
date	2014.05.18.08.08.50;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2014.05.12.19.11.19;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.22.08.26.31;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2013.11.22.15.47.35;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2013.11.12.17.44.03;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2012.10.18.17.54.43;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2012.10.12.13.20.11;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2011.08.16.14.18.25;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.30.21.02.13;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.29.13.39.00;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.19.19.30.38;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.03.15.42.11;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.17.09.44.20;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.16.12.02.38;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.16.12.01.11;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.16.09.46.14;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.30.09.51.53;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.24.18.58.48;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2007.07.24.18.56.15;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.24.18.52.47;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.20.12.32.45;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.15.20.43.23;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.07.13.11.36;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.07.18.33.08;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.03.02.56.12;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.07.12.19.46;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.23.12.34.52;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.07.22.59.33;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.03.13.41.13;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.14.13.36.46;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.14.13.35.38;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.24.21.57.28;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.17.23.54.26;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.17.23.26.51;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.17.23.09.06;	author espie;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Also check for NUL termination at the first character of tstr in
the error path of VarModifiers_Apply().  This prevents a sporadic
crash in make's regress target t41.
OK espie@@
@
text
@/*	$OpenBSD: varmodifiers.c,v 1.46 2017/02/24 23:38:47 espie Exp $	*/
/*	$NetBSD: var.c,v 1.18 1997/03/18 19:24:46 christos Exp $	*/

/*
 * Copyright (c) 1999-2010 Marc Espie.
 *
 * Extensive code changes for the OpenBSD project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1988, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* VarModifiers_Apply is mostly a constituent function of Var_Parse, it
 * is also called directly by Var_SubstVar.  */


#include <ctype.h>
#include <sys/types.h>
#include <regex.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "config.h"
#include "defines.h"
#include "buf.h"
#include "var.h"
#include "varmodifiers.h"
#include "varname.h"
#include "targ.h"
#include "error.h"
#include "str.h"
#include "cmd_exec.h"
#include "memory.h"
#include "gnode.h"


/* Var*Pattern flags */
#define VAR_SUB_GLOBAL	0x01	/* Apply substitution globally */
#define VAR_SUB_ONE	0x02	/* Apply substitution to one word */
#define VAR_SUB_MATCHED 0x04	/* There was a match */
#define VAR_MATCH_START 0x08	/* Match at start of word */
#define VAR_MATCH_END	0x10	/* Match at end of word */

/* Modifiers flags */
#define VAR_EQUAL	0x20
#define VAR_MAY_EQUAL	0x40
#define VAR_ADD_EQUAL	0x80
#define VAR_BANG_EQUAL	0x100

typedef struct {
	char	  *lbuffer; /* left string to free */
	char	  *lhs;     /* String to match */
	size_t	  leftLen;  /* Length of string */
	char	  *rhs;     /* Replacement string (w/ &'s removed) */
	size_t	  rightLen; /* Length of replacement */
	int 	  flags;
} VarPattern;

struct LoopStuff {
	struct LoopVar	*var;
	char	*expand;
	bool	err;
};

static bool VarHead(struct Name *, bool, Buffer, void *);
static bool VarTail(struct Name *, bool, Buffer, void *);
static bool VarSuffix(struct Name *, bool, Buffer, void *);
static bool VarRoot(struct Name *, bool, Buffer, void *);
static bool VarMatch(struct Name *, bool, Buffer, void *);
static bool VarSYSVMatch(struct Name *, bool, Buffer, void *);
static bool VarNoMatch(struct Name *, bool, Buffer, void *);
static bool VarUniq(struct Name *, bool, Buffer, void *);
static bool VarLoop(struct Name *, bool, Buffer, void *);


static void VarREError(int, regex_t *, const char *);
static bool VarRESubstitute(struct Name *, bool, Buffer, void *);
static char *do_regex(const char *, const struct Name *, void *);

typedef struct {
	regex_t	  re;
	int 	  nsub;
	regmatch_t	 *matches;
	char	 *replace;
	int 	  flags;
} VarREPattern;

static bool VarSubstitute(struct Name *, bool, Buffer, void *);
static char *VarGetPattern(SymTable *, int, const char **, int, int,
    size_t *, VarPattern *);
static char *VarQuote(const char *, const struct Name *, void *);
static char *VarModify(char *, bool (*)(struct Name *, bool, Buffer, void *), void *);

static void *check_empty(const char **, SymTable *, bool, int);
static void *check_quote(const char **, SymTable *, bool, int);
static char *do_upper(const char *, const struct Name *, void *);
static char *do_lower(const char *, const struct Name *, void *);
static void *check_shcmd(const char **, SymTable *, bool, int);
static char *do_shcmd(const char *, const struct Name *, void *);
static char *do_sort(const char *, const struct Name *, void *);
static char *finish_loop(const char *, const struct Name *, void *);
static int NameCompare(const void *, const void *);
static char *do_label(const char *, const struct Name *, void *);
static char *do_path(const char *, const struct Name *, void *);
static char *do_def(const char *, const struct Name *, void *);
static char *do_undef(const char *, const struct Name *, void *);
static char *do_assign(const char *, const struct Name *, void *);
static char *do_exec(const char *, const struct Name *, void *);

static void *assign_get_value(const char **, SymTable *, bool, int);
static void *get_cmd(const char **, SymTable *, bool, int);
static void *get_value(const char **, SymTable *, bool, int);
static void *get_stringarg(const char **, SymTable *, bool, int);
static void free_stringarg(void *);
static void *get_patternarg(const char **, SymTable *, bool, int);
static void *get_spatternarg(const char **, SymTable *, bool, int);
static void *common_get_patternarg(const char **, SymTable *, bool, int, bool);
static void free_patternarg(void *);
static void free_looparg(void *);
static void *get_sysvpattern(const char **, SymTable *, bool, int);
static void *get_loop(const char **, SymTable *, bool, int);
static char *LoopGrab(const char **);

static struct Name dummy;
static struct Name *dummy_arg = &dummy;

static struct modifier {
	    bool atstart;
	    void * (*getarg)(const char **, SymTable *, bool, int);
	    char * (*apply)(const char *, const struct Name *, void *);
	    bool (*word_apply)(struct Name *, bool, Buffer, void *);
	    void   (*freearg)(void *);
} *choose_mod[256],
	match_mod = {false, get_stringarg, NULL, VarMatch, free_stringarg},
	nomatch_mod = {false, get_stringarg, NULL, VarNoMatch, free_stringarg},
	subst_mod = {false, get_spatternarg, NULL, VarSubstitute, free_patternarg},
	resubst_mod = {false, get_patternarg, do_regex, NULL, free_patternarg},
	quote_mod = {false, check_quote, VarQuote, NULL , free},
	tail_mod = {false, check_empty, NULL, VarTail, NULL},
	head_mod = {false, check_empty, NULL, VarHead, NULL},
	suffix_mod = {false, check_empty, NULL, VarSuffix, NULL},
	root_mod = {false, check_empty, NULL, VarRoot, NULL},
	upper_mod = {false, check_empty, do_upper, NULL, NULL},
	lower_mod = {false, check_empty, do_lower, NULL, NULL},
	shcmd_mod = {false, check_shcmd, do_shcmd, NULL, NULL},
	sysv_mod = {false, get_sysvpattern, NULL, VarSYSVMatch, free_patternarg},
	uniq_mod = {false, check_empty, NULL, VarUniq, NULL},
	sort_mod = {false, check_empty, do_sort, NULL, NULL},
	loop_mod = {false, get_loop, finish_loop, VarLoop, free_looparg},
	undef_mod = {true, get_value, do_undef, NULL, NULL},
	def_mod = {true, get_value, do_def, NULL, NULL},
	label_mod = {true, check_empty, do_label, NULL, NULL},
	path_mod = {true, check_empty, do_path, NULL, NULL},
	assign_mod = {true, assign_get_value, do_assign, NULL, free_patternarg},
	exec_mod = {true, get_cmd, do_exec, NULL, free_patternarg}
;

void
VarModifiers_Init()
{
	choose_mod['M'] = &match_mod;
	choose_mod['N'] = &nomatch_mod;
	choose_mod['S'] = &subst_mod;
	choose_mod['C'] = &resubst_mod;
	choose_mod['Q'] = &quote_mod;
	choose_mod['T'] = &tail_mod;
	choose_mod['H'] = &head_mod;
	choose_mod['E'] = &suffix_mod;
	choose_mod['R'] = &root_mod;
	if (FEATURES(FEATURE_UPPERLOWER)) {
		choose_mod['U'] = &upper_mod;
		choose_mod['L'] = &lower_mod;
	}
	if (FEATURES(FEATURE_SUNSHCMD))
		choose_mod['s'] = &shcmd_mod;
	if (FEATURES(FEATURE_UNIQ))
		choose_mod['u'] = &uniq_mod;
	if (FEATURES(FEATURE_SORT))
		choose_mod['O'] = &sort_mod;
	if (FEATURES(FEATURE_ODE)) {
		choose_mod['@@'] = &loop_mod;
		choose_mod['D'] = &def_mod;
		choose_mod['U'] = &undef_mod;
		choose_mod['L'] = &label_mod;
		choose_mod['P'] = &path_mod;
	}
	if (FEATURES(FEATURE_ASSIGN))
		choose_mod[':'] = &assign_mod;
	if (FEATURES(FEATURE_EXECMOD))
		choose_mod['!'] = &exec_mod;
}

/* All modifiers handle addSpace (need to add a space before placing the
 * next word into the buffer) and propagate it when necessary.
 */

/*-
 *-----------------------------------------------------------------------
 * VarHead --
 *	Remove the tail of the given word and add the result to the given
 *	buffer.
 *-----------------------------------------------------------------------
 */
static bool
VarHead(struct Name *word, bool addSpace, Buffer buf, void *dummy UNUSED)
{
	const char	*slash;

	slash = Str_rchri(word->s, word->e, '/');
	if (slash != NULL) {
		if (addSpace)
			Buf_AddSpace(buf);
		Buf_Addi(buf, word->s, slash);
	} else {
		/* If no directory part, give . (q.v. the POSIX standard).  */
		if (addSpace)
			Buf_AddString(buf, " .");
		else
			Buf_AddChar(buf, '.');
	}
	return true;
}

/*-
 *-----------------------------------------------------------------------
 * VarTail --
 *	Remove the head of the given word add the result to the given
 *	buffer.
 *-----------------------------------------------------------------------
 */
static bool
VarTail(struct Name *word, bool addSpace, Buffer buf, void *dummy UNUSED)
{
	const char	*slash;

	if (addSpace)
		Buf_AddSpace(buf);
	slash = Str_rchri(word->s, word->e, '/');
	if (slash != NULL)
		Buf_Addi(buf, slash+1, word->e);
	else
		Buf_Addi(buf, word->s, word->e);
	return true;
}

/*-
 *-----------------------------------------------------------------------
 * VarSuffix --
 *	Add the suffix of the given word to the given buffer.
 *-----------------------------------------------------------------------
 */
static bool
VarSuffix(struct Name *word, bool addSpace, Buffer buf, void *dummy UNUSED)
{
	const char	*dot;

	dot = Str_rchri(word->s, word->e, '.');
	if (dot != NULL) {
		if (addSpace)
			Buf_AddSpace(buf);
		Buf_Addi(buf, dot+1, word->e);
		addSpace = true;
	}
	return addSpace;
}

/*-
 *-----------------------------------------------------------------------
 * VarRoot --
 *	Remove the suffix of the given word and add the result to the
 *	buffer.
 *-----------------------------------------------------------------------
 */
static bool
VarRoot(struct Name *word, bool addSpace, Buffer buf, void *dummy UNUSED)
{
	const char	*dot;

	if (addSpace)
		Buf_AddSpace(buf);
	dot = Str_rchri(word->s, word->e, '.');
	if (dot != NULL)
		Buf_Addi(buf, word->s, dot);
	else
		Buf_Addi(buf, word->s, word->e);
	return true;
}

/*-
 *-----------------------------------------------------------------------
 * VarMatch --
 *	Add the word to the buffer if it matches the given pattern.
 *-----------------------------------------------------------------------
 */
static bool
VarMatch(struct Name *word, bool addSpace, Buffer buf,
    void *pattern) /* Pattern the word must match */
{
	const char *pat = pattern;

	if (Str_Matchi(word->s, word->e, pat, strchr(pat, '\0'))) {
		if (addSpace)
			Buf_AddSpace(buf);
		Buf_Addi(buf, word->s, word->e);
		return true;
	} else
		return addSpace;
}

/*-
 *-----------------------------------------------------------------------
 * VarNoMatch --
 *	Add the word to the buffer if it doesn't match the given pattern.
 *-----------------------------------------------------------------------
 */
static bool
VarNoMatch(struct Name *word, bool addSpace, Buffer buf,
    void *pattern) /* Pattern the word must not match */
{
	const char *pat = pattern;

	if (!Str_Matchi(word->s, word->e, pat, strchr(pat, '\0'))) {
		if (addSpace)
			Buf_AddSpace(buf);
		Buf_Addi(buf, word->s, word->e);
		return true;
	} else
		return addSpace;
}

static bool
VarUniq(struct Name *word, bool addSpace, Buffer buf, void *lastp)
{
	struct Name *last = lastp;

	/* does not match */
	if (last->s == NULL || last->e - last->s != word->e - word->s ||
	    strncmp(word->s, last->s, word->e - word->s) != 0) {
		if (addSpace)
			Buf_AddSpace(buf);
		Buf_Addi(buf, word->s, word->e);
		addSpace = true;
	}
	last->s = word->s;
	last->e = word->e;
	return addSpace;
}

static bool
VarLoop(struct Name *word, bool addSpace, Buffer buf, void *vp)
{
	struct LoopStuff *v = vp;

	if (addSpace)
		Buf_AddSpace(buf);
	Var_SubstVar(buf, v->expand, v->var, word->s);
	return true;
}

static char *
finish_loop(const char *s, const struct Name *n UNUSED , void *p)
{
	struct LoopStuff *l = p;

	return Var_Subst(s, NULL,  l->err);
}

static int
NameCompare(const void *ap, const void *bp)
{
	const struct Name *a, *b;
	size_t n, m;
	int c;

	a = ap;
	b = bp;
	n = a->e - a->s;
	m = b->e - b->s;
	if (n < m) {
		c = strncmp(a->s, b->s, n);
		if (c != 0)
			return c;
		else
			return -1;
    	} else if (m < n) {
		c = strncmp(a->s, b->s, m);
		if (c != 0)
			return c;
		else
			return 1;
    	} else
		return strncmp(a->s, b->s, n);
}

static char *
do_sort(const char *s, const struct Name *dummy UNUSED, void *arg UNUSED)
{
	struct Name *t;
	unsigned long n, i, j;
	const char *start, *end;

	n = 1024;	/* start at 1024 words */
	t = ereallocarray(NULL, n, sizeof(struct Name));
	start = s;
	end = start;

	for (i = 0;; i++) {
		if (i == n) {
			n *= 2;
			t = ereallocarray(t, n, sizeof(struct Name));
		}
		start = iterate_words(&end);
		if (start == NULL)
			break;
		t[i].s = start;
		t[i].e = end;
	}
	if (i > 0) {
		BUFFER buf;

		Buf_Init(&buf, end - s);
		qsort(t, i, sizeof(struct Name), NameCompare);
		Buf_Addi(&buf, t[0].s, t[0].e);
		for (j = 1; j < i; j++) {
			Buf_AddSpace(&buf);
			Buf_Addi(&buf, t[j].s, t[j].e);
		}
		free(t);
		return Buf_Retrieve(&buf);
	} else {
		free(t);
		return "";
	}
}

static char *
do_label(const char *s UNUSED, const struct Name *n, void *arg UNUSED)
{
	return Str_dupi(n->s, n->e);
}

static char *
do_path(const char *s UNUSED, const struct Name *n, void *arg UNUSED)
{
	GNode *gn;

	gn = Targ_FindNodei(n->s, n->e, TARG_NOCREATE);
	if (gn == NULL)
		return Str_dupi(n->s, n->e);
	else
		return strdup(gn->path);
}

static char *
do_def(const char *s, const struct Name *n UNUSED, void *arg)
{
	VarPattern *v = arg;
	if (s == NULL) {
		free_patternarg(v);
		return NULL;
	} else
		return v->lbuffer;
}

static char *
do_undef(const char *s, const struct Name *n UNUSED, void *arg)
{
	VarPattern *v = arg;
	if (s != NULL) {
		free_patternarg(v);
		return NULL;
	} else
		return v->lbuffer;
}

static char *
do_assign(const char *s, const struct Name *n, void *arg)
{
	VarPattern *v = arg;
	char *msg;
	char *result;

	switch (v->flags) {
	case VAR_EQUAL:
		Var_Seti(n->s, n->e, v->lbuffer);
		break;
	case VAR_MAY_EQUAL:
		if (s == NULL)
			Var_Seti(n->s, n->e, v->lbuffer);
		break;
	case VAR_ADD_EQUAL:
		if (s == NULL)
			Var_Seti(n->s, n->e, v->lbuffer);
		else
			Var_Appendi(n->s, n->e, v->lbuffer);
		break;
	case VAR_BANG_EQUAL:
		result = Cmd_Exec(v->lbuffer, &msg);
		if (result != NULL) {
			Var_Seti(n->s, n->e, result);
			free(result);
		} else
			Error(msg, v->lbuffer);
		break;

	}
	return NULL;
}

static char *
do_exec(const char *s UNUSED, const struct Name *n UNUSED, void *arg)
{
	VarPattern *v = arg;
	char *msg;
	char *result;

	result = Cmd_Exec(v->lbuffer, &msg);
	if (result == NULL)
		Error(msg, v->lbuffer);
	return result;
}

/*-
 *-----------------------------------------------------------------------
 * VarSYSVMatch --
 *	Add the word to the buffer if it matches the given pattern.
 *	Used to implement the System V % modifiers.
 *-----------------------------------------------------------------------
 */
static bool
VarSYSVMatch(struct Name *word, bool addSpace, Buffer buf, void *patp)
{
	size_t	len;
	const char	*ptr;
	VarPattern	*pat = patp;

	if (*word->s != '\0') {
		if (addSpace)
			Buf_AddSpace(buf);
		if ((ptr = Str_SYSVMatch(word->s, pat->lhs, &len)) != NULL)
			Str_SYSVSubst(buf, pat->rhs, ptr, len);
		else
			Buf_Addi(buf, word->s, word->e);
		return true;
	} else
		return addSpace;
}

void *
get_sysvpattern(const char **p, SymTable *ctxt UNUSED, bool err, int endc)
{
	VarPattern		*pattern;
	const char		*cp, *cp2;
	BUFFER buf, buf2;
	int cnt = 0;
	char startc = endc == ')' ? '(' : '{';

	Buf_Init(&buf, 0);
	for (cp = *p;; cp++) {
		if (*cp == '=' && cnt == 0)
			break;
		if (*cp == '\0') {
			Buf_Destroy(&buf);
			return NULL;
		}
		if (*cp == startc)
			cnt++;
		else if (*cp == endc) {
			cnt--;
			if (cnt < 0) {
				Buf_Destroy(&buf);
				return NULL;
			}
		} else if (*cp == '$') {
			if (cp[1] == '$')
				cp++;
			else {
				size_t len;
				(void)Var_ParseBuffer(&buf, cp, ctxt, err, 
				    &len);
				cp += len - 1;
				continue;
			}
		}
		Buf_AddChar(&buf, *cp);
	}

	Buf_Init(&buf2, 0);
	for (cp2 = cp+1;; cp2++) {
		if (((*cp2 == ':' && cp2[1] != endc) || *cp2 == endc) && 
		    cnt == 0)
			break;
		if (*cp2 == '\0') {
			Buf_Destroy(&buf);
			Buf_Destroy(&buf2);
			return NULL;
		}
		if (*cp2 == startc)
			cnt++;
		else if (*cp2 == endc) {
			cnt--;
			if (cnt < 0) {
				Buf_Destroy(&buf);
				Buf_Destroy(&buf2);
				return NULL;
			}
		} else if (*cp2 == '$') {
			if (cp2[1] == '$')
				cp2++;
			else {
				size_t len;
				(void)Var_ParseBuffer(&buf2, cp2, ctxt, err, 
				    &len);
				cp2 += len - 1;
				continue;
			}
		}
		Buf_AddChar(&buf2, *cp2);
	}

	pattern = emalloc(sizeof(VarPattern));
	pattern->lbuffer = pattern->lhs = Buf_Retrieve(&buf);
	pattern->leftLen = Buf_Size(&buf);
	pattern->rhs = Buf_Retrieve(&buf2);
	pattern->rightLen = Buf_Size(&buf2);
	pattern->flags = 0;
	*p = cp2;
	return pattern;
}


/*-
 *-----------------------------------------------------------------------
 * VarSubstitute --
 *	Perform a string-substitution on the given word, Adding the
 *	result to the given buffer.
 *-----------------------------------------------------------------------
 */
static bool
VarSubstitute(struct Name *word, bool addSpace, Buffer buf,
    void *patternp) /* Pattern for substitution */
{
    size_t	wordLen;    /* Length of word */
    const char	*cp;	    /* General pointer */
    VarPattern	*pattern = patternp;

    wordLen = word->e - word->s;
    if ((pattern->flags & (VAR_SUB_ONE|VAR_SUB_MATCHED)) !=
	(VAR_SUB_ONE|VAR_SUB_MATCHED)) {
	/* Still substituting -- break it down into simple anchored cases
	 * and if none of them fits, perform the general substitution case.  */
	if ((pattern->flags & VAR_MATCH_START) &&
	    (strncmp(word->s, pattern->lhs, pattern->leftLen) == 0)) {
		/* Anchored at start and beginning of word matches pattern.  */
		if ((pattern->flags & VAR_MATCH_END) &&
		    (wordLen == pattern->leftLen)) {
			/* Also anchored at end and matches to the end (word
			 * is same length as pattern) add space and rhs only
			 * if rhs is non-null.	*/
			if (pattern->rightLen != 0) {
			    if (addSpace)
				Buf_AddSpace(buf);
			    addSpace = true;
			    Buf_AddChars(buf, pattern->rightLen,
					 pattern->rhs);
			}
			pattern->flags |= VAR_SUB_MATCHED;
		} else if (pattern->flags & VAR_MATCH_END) {
		    /* Doesn't match to end -- copy word wholesale.  */
		    goto nosub;
		} else {
		    /* Matches at start but need to copy in
		     * trailing characters.  */
		    if ((pattern->rightLen + wordLen - pattern->leftLen) != 0){
			if (addSpace)
			    Buf_AddSpace(buf);
			addSpace = true;
		    }
		    Buf_AddChars(buf, pattern->rightLen, pattern->rhs);
		    Buf_AddChars(buf, wordLen - pattern->leftLen,
				 word->s + pattern->leftLen);
		    pattern->flags |= VAR_SUB_MATCHED;
		}
	} else if (pattern->flags & VAR_MATCH_START) {
	    /* Had to match at start of word and didn't -- copy whole word.  */
	    goto nosub;
	} else if (pattern->flags & VAR_MATCH_END) {
	    /* Anchored at end, Find only place match could occur (leftLen
	     * characters from the end of the word) and see if it does. Note
	     * that because the $ will be left at the end of the lhs, we have
	     * to use strncmp.	*/
	    cp = word->s + (wordLen - pattern->leftLen);
	    if (cp >= word->s &&
		strncmp(cp, pattern->lhs, pattern->leftLen) == 0) {
		/* Match found. If we will place characters in the buffer,
		 * add a space before hand as indicated by addSpace, then
		 * stuff in the initial, unmatched part of the word followed
		 * by the right-hand-side.  */
		if (((cp - word->s) + pattern->rightLen) != 0) {
		    if (addSpace)
			Buf_AddSpace(buf);
		    addSpace = true;
		}
		Buf_Addi(buf, word->s, cp);
		Buf_AddChars(buf, pattern->rightLen, pattern->rhs);
		pattern->flags |= VAR_SUB_MATCHED;
	    } else {
		/* Had to match at end and didn't. Copy entire word.  */
		goto nosub;
	    }
	} else {
	    /* Pattern is unanchored: search for the pattern in the word using
	     * strstr, copying unmatched portions and the
	     * right-hand-side for each match found, handling non-global
	     * substitutions correctly, etc. When the loop is done, any
	     * remaining part of the word (word and wordLen are adjusted
	     * accordingly through the loop) is copied straight into the
	     * buffer.
	     * addSpace is set to false as soon as a space is added to the
	     * buffer.	*/
	    bool done;
	    size_t origSize;

	    done = false;
	    origSize = Buf_Size(buf);
	    while (!done) {
		cp = strstr(word->s, pattern->lhs);
		if (cp != NULL) {
		    if (addSpace && (cp - word->s) + pattern->rightLen != 0){
			Buf_AddSpace(buf);
			addSpace = false;
		    }
		    Buf_Addi(buf, word->s, cp);
		    Buf_AddChars(buf, pattern->rightLen, pattern->rhs);
		    wordLen -= (cp - word->s) + pattern->leftLen;
		    word->s = cp + pattern->leftLen;
		    if (wordLen == 0 || (pattern->flags & VAR_SUB_GLOBAL) == 0)
			done = true;
		    pattern->flags |= VAR_SUB_MATCHED;
		} else
		    done = true;
	    }
	    if (wordLen != 0) {
		if (addSpace)
		    Buf_AddSpace(buf);
		Buf_AddChars(buf, wordLen, word->s);
	    }
	    /* If added characters to the buffer, need to add a space
	     * before we add any more. If we didn't add any, just return
	     * the previous value of addSpace.	*/
	    return Buf_Size(buf) != origSize || addSpace;
	}
	return addSpace;
    }
 nosub:
    if (addSpace)
	Buf_AddSpace(buf);
    Buf_AddChars(buf, wordLen, word->s);
    return true;
}

/*-
 *-----------------------------------------------------------------------
 * VarREError --
 *	Print the error caused by a regcomp or regexec call.
 *-----------------------------------------------------------------------
 */
static void
VarREError(int err, regex_t *pat, const char *str)
{
	char	*errbuf;
	int 	errlen;

	errlen = regerror(err, pat, 0, 0);
	errbuf = emalloc(errlen);
	regerror(err, pat, errbuf, errlen);
	Error("%s: %s", str, errbuf);
	free(errbuf);
}

/*-
 *-----------------------------------------------------------------------
 * VarRESubstitute --
 *	Perform a regex substitution on the given word, placing the
 *	result in the passed buffer.
 *-----------------------------------------------------------------------
 */
static bool
VarRESubstitute(struct Name *word, bool addSpace, Buffer buf, void *patternp)
{
	VarREPattern	*pat;
	int 		xrv;
	const char		*wp;
	char		*rp;
	int 		added;

#define MAYBE_ADD_SPACE()		\
	if (addSpace && !added) 	\
		Buf_AddSpace(buf);	\
	added = 1

	added = 0;
	wp = word->s;
	pat = patternp;

	if ((pat->flags & (VAR_SUB_ONE|VAR_SUB_MATCHED)) ==
	    (VAR_SUB_ONE|VAR_SUB_MATCHED))
		xrv = REG_NOMATCH;
	else {
	tryagain:
		xrv = regexec(&pat->re, wp, pat->nsub, pat->matches, 0);
	}

	switch (xrv) {
	case 0:
		pat->flags |= VAR_SUB_MATCHED;
		if (pat->matches[0].rm_so > 0) {
			MAYBE_ADD_SPACE();
			Buf_AddChars(buf, pat->matches[0].rm_so, wp);
		}

		for (rp = pat->replace; *rp; rp++) {
			if (*rp == '\\' && (rp[1] == '&' || rp[1] == '\\')) {
				MAYBE_ADD_SPACE();
				Buf_AddChar(buf,rp[1]);
				rp++;
			}
			else if (*rp == '&' ||
			    (*rp == '\\' && ISDIGIT(rp[1]))) {
				int n;
				const char *subbuf;
				int sublen;
				char errstr[3];

				if (*rp == '&') {
					n = 0;
					errstr[0] = '&';
					errstr[1] = '\0';
				} else {
					n = rp[1] - '0';
					errstr[0] = '\\';
					errstr[1] = rp[1];
					errstr[2] = '\0';
					rp++;
				}

				if (n >= pat->nsub) {
					Error("No subexpression %s",
					    &errstr[0]);
					subbuf = "";
					sublen = 0;
				} else if (pat->matches[n].rm_so == -1 &&
				    pat->matches[n].rm_eo == -1) {
					Error("No match for subexpression %s",
					    &errstr[0]);
					subbuf = "";
					sublen = 0;
				} else {
					subbuf = wp + pat->matches[n].rm_so;
					sublen = pat->matches[n].rm_eo -
					    pat->matches[n].rm_so;
				}

				if (sublen > 0) {
					MAYBE_ADD_SPACE();
					Buf_AddChars(buf, sublen, subbuf);
				}
			} else {
				MAYBE_ADD_SPACE();
				Buf_AddChar(buf, *rp);
			}
		}
		wp += pat->matches[0].rm_eo;
		if (pat->flags & VAR_SUB_GLOBAL) {
			/* like most modern tools, empty string matches
			 * should advance one char at a time...
			 */
			if (pat->matches[0].rm_eo == 0)  {
				if (*wp) {
					MAYBE_ADD_SPACE();
					Buf_AddChar(buf, *wp++);
				} else
					break;
			}
			goto tryagain;
		}
		if (*wp) {
			MAYBE_ADD_SPACE();
			Buf_AddString(buf, wp);
		}
		break;
	default:
		VarREError(xrv, &pat->re, "Unexpected regex error");
	       /* FALLTHROUGH */
	case REG_NOMATCH:
		if (*wp) {
			MAYBE_ADD_SPACE();
			Buf_AddString(buf, wp);
		}
		break;
	}
	return addSpace||added;
}

/*-
 *-----------------------------------------------------------------------
 * VarModify --
 *	Modify each of the words of the passed string using the given
 *	function. Used to implement all modifiers.
 *
 * Results:
 *	A string of all the words modified appropriately.
 *-----------------------------------------------------------------------
 */
static char *
VarModify(char *str, 		/* String whose words should be trimmed */
				/* Function to use to modify them */
    bool (*modProc)(struct Name *, bool, Buffer, void *),
    void *datum)		/* Datum to pass it */
{
	BUFFER	  buf;		/* Buffer for the new string */
	bool	  addSpace;	/* true if need to add a space to the
				     * buffer before adding the trimmed
				     * word */
	struct Name	  word;

	Buf_Init(&buf, 0);
	addSpace = false;

	word.e = str;

	while ((word.s = iterate_words(&word.e)) != NULL) {
		char termc;

		termc = *word.e;
		*((char *)(word.e)) = '\0';
		addSpace = (*modProc)(&word, addSpace, &buf, datum);
		*((char *)(word.e)) = termc;
	}
	return Buf_Retrieve(&buf);
}

/*-
 *-----------------------------------------------------------------------
 * VarGetPattern --
 *	Pass through the tstr looking for 1) escaped delimiters,
 *	'$'s and backslashes (place the escaped character in
 *	uninterpreted) and 2) unescaped $'s that aren't before
 *	the delimiter (expand the variable substitution).
 *	Return the expanded string or NULL if the delimiter was missing
 *	If pattern is specified, handle escaped ampersands, and replace
 *	unescaped ampersands with the lhs of the pattern.
 *
 * Results:
 *	A string of all the words modified appropriately.
 *	If length is specified, return the string length of the buffer
 *-----------------------------------------------------------------------
 */
static char *
VarGetPattern(SymTable *ctxt, int err, const char **tstr, int delim1,
    int delim2, size_t *length, VarPattern *pattern)
{
	const char	*cp;
	char	*result;
	BUFFER	buf;
	size_t	junk;

	Buf_Init(&buf, 0);
	if (length == NULL)
		length = &junk;

#define IS_A_MATCH(cp, delim1, delim2) \
	(cp[0] == '\\' && (cp[1] == delim1 || cp[1] == delim2 || \
	 cp[1] == '\\' || cp[1] == '$' || (pattern && cp[1] == '&')))

	/*
	 * Skim through until the matching delimiter is found;
	 * pick up variable substitutions on the way. Also allow
	 * backslashes to quote the delimiter, $, and \, but don't
	 * touch other backslashes.
	 */
	for (cp = *tstr; *cp != '\0' && *cp != delim1 && *cp != delim2; cp++) {
		if (IS_A_MATCH(cp, delim1, delim2)) {
			Buf_AddChar(&buf, cp[1]);
			cp++;
		} else if (*cp == '$') {
			/* Allowed at end of pattern */
			if (cp[1] == delim1 || cp[1] == delim2)
				Buf_AddChar(&buf, *cp);
			else {
				size_t len;

				/* If unescaped dollar sign not before the
				 * delimiter, assume it's a variable
				 * substitution and recurse.  */
				(void)Var_ParseBuffer(&buf, cp, ctxt, err,
				    &len);
				cp += len - 1;
			}
		} else if (pattern && *cp == '&')
			Buf_AddChars(&buf, pattern->leftLen, pattern->lhs);
		else
			Buf_AddChar(&buf, *cp);
	}

	*length = Buf_Size(&buf);
	result = Buf_Retrieve(&buf);

	if (*cp != delim1 && *cp != delim2) {
		*tstr = cp;
		*length = 0;
		free(result);
		return NULL;
	}
	else {
		*tstr = ++cp;
		return result;
	}
}

/*-
 *-----------------------------------------------------------------------
 * VarQuote --
 *	Quote shell meta-characters in the string
 *
 * Results:
 *	The quoted string
 *-----------------------------------------------------------------------
 */
static char *
VarQuote(const char *str, const struct Name *n UNUSED, void *islistp)
{
	int *p = islistp;
	int islist = *p;

	BUFFER	  buf;
	/* This should cover most shells :-( */
	static char meta[] = "\n \t'`\";&<>()|*?{}[]\\$!#^~";
	char *rep = meta;
	if (islist)
		rep += 3;

	Buf_Init(&buf, MAKE_BSIZE);
	for (; *str; str++) {
		if (strchr(rep, *str) != NULL)
			Buf_AddChar(&buf, '\\');
		Buf_AddChar(&buf, *str);
	}
	return Buf_Retrieve(&buf);
}

static void *
check_empty(const char **p, SymTable *ctxt UNUSED, bool b UNUSED, int endc)
{
	dummy_arg->s = NULL;
	if ((*p)[1] == endc || (*p)[1] == ':') {
		(*p)++;
		return dummy_arg;
	} else
		return NULL;
}

static void *
check_quote(const char **p, SymTable *ctxt UNUSED, bool b UNUSED, int endc)
{
	int *qargs = emalloc(sizeof(int));
	*qargs = 0;
	if ((*p)[1] == 'L') {
		*qargs = 1;
		(*p)++;
	}
	if ((*p)[1] == endc || (*p)[1] == ':') {
		(*p)++;
		return qargs;
	} else  {
		free(qargs);
		return NULL;
	}
}

static void *
check_shcmd(const char **p, SymTable *ctxt UNUSED, bool b UNUSED, int endc)
{
	if ((*p)[1] == 'h' && ((*p)[2] == endc || (*p)[2] == ':')) {
		(*p)+=2;
		return dummy_arg;
	} else
		return NULL;
}


static char *
do_shcmd(const char *s, const struct Name *n UNUSED, void *arg UNUSED)
{
	char *err;
	char *t;

	t = Cmd_Exec(s, &err);
	if (err)
		Error(err, s);
	return t;
}

static void *
get_stringarg(const char **p, SymTable *ctxt UNUSED, bool b UNUSED, int endc)
{
	const char *cp;
	char *s;

	for (cp = *p + 1; *cp != ':' && *cp != endc; cp++) {
		if (*cp == '\\') {
			if (cp[1] == ':' || cp[1] == endc || cp[1] == '\\')
				cp++;
		} else if (*cp == '\0')
			return NULL;
	}
	s = escape_dupi(*p+1, cp, ":)}");
	*p = cp;
	return s;
}

static void
free_stringarg(void *arg)
{
	free(arg);
}

static char *
do_upper(const char *s, const struct Name *n UNUSED, void *arg UNUSED)
{
	size_t len, i;
	char *t;

	len = strlen(s);
	t = emalloc(len+1);
	for (i = 0; i < len; i++)
		t[i] = TOUPPER(s[i]);
	t[len] = '\0';
	return t;
}

static char *
do_lower(const char *s, const struct Name *n UNUSED, void *arg UNUSED)
{
	size_t	len, i;
	char	*t;

	len = strlen(s);
	t = emalloc(len+1);
	for (i = 0; i < len; i++)
		t[i] = TOLOWER(s[i]);
	t[len] = '\0';
	return t;
}

static void *
get_patternarg(const char **p, SymTable *ctxt, bool err, int endc)
{
	return common_get_patternarg(p, ctxt, err, endc, false);
}

/* Extract anchors */
static void *
get_spatternarg(const char **p, SymTable *ctxt, bool err, int endc)
{
	VarPattern *pattern;

	pattern = common_get_patternarg(p, ctxt, err, endc, true);
	if (pattern != NULL && pattern->leftLen > 0) {
		if (pattern->lhs[pattern->leftLen-1] == '$') {
			    pattern->leftLen--;
			    pattern->flags |= VAR_MATCH_END;
		}
		if (pattern->lhs[0] == '^') {
			    pattern->lhs++;
			    pattern->leftLen--;
			    pattern->flags |= VAR_MATCH_START;
		}
	}
	return pattern;
}

static void
free_looparg(void *arg)
{
	struct LoopStuff *l = arg;

	Var_DeleteLoopVar(l->var);
	free(l->expand);
}

static char *
LoopGrab(const char **s)
{
	const char *p, *start;

	start = *s;
	for (p = start; *p != '@@'; p++) {
		if (*p == '\\')
			p++;
		if (*p == 0)
			return NULL;
	}
	*s = p+1;
	return escape_dupi(start, p, "@@\\");
}

static void *
get_loop(const char **p, SymTable *ctxt UNUSED, bool err, int endc)
{
	static struct LoopStuff loop;
	const char *s;
	const char *var;

	s = *p +1;

	loop.var = NULL;
	loop.expand = NULL;
	loop.err = err;
	var = LoopGrab(&s);
	if (var != NULL) {
		loop.expand = LoopGrab(&s);
		if (*s == endc || *s == ':') {
			*p = s;
			loop.var = Var_NewLoopVar(var, NULL);
			return &loop;
		}
	}
	free_looparg(&loop);
	return NULL;
}

static void *
common_get_patternarg(const char **p, SymTable *ctxt, bool err, int endc,
    bool dosubst)
{
	VarPattern *pattern;
	char delim;
	const char *s;

	pattern = emalloc(sizeof(VarPattern));
	pattern->flags = 0;
	s = *p;

	delim = s[1];
	if (delim == '\0')
		return NULL;
	s += 2;

	pattern->rhs = NULL;
	pattern->lhs = VarGetPattern(ctxt, err, &s, delim, delim,
	    &pattern->leftLen, NULL);
	pattern->lbuffer = pattern->lhs;
	if (pattern->lhs != NULL) {
		pattern->rhs = VarGetPattern(ctxt, err, &s, delim, delim,
		    &pattern->rightLen, dosubst ? pattern: NULL);
		if (pattern->rhs != NULL) {
			/* Check for global substitution. If 'g' after the
			 * final delimiter, substitution is global and is
			 * marked that way.  */
			for (;; s++) {
				switch (*s) {
				case 'g':
					pattern->flags |= VAR_SUB_GLOBAL;
					continue;
				case '1':
					pattern->flags |= VAR_SUB_ONE;
					continue;
				}
				break;
			}
			if (*s == endc || *s == ':') {
				*p = s;
				return pattern;
			}
		}
	}
	free_patternarg(pattern);
	return NULL;
}

static void *
assign_get_value(const char **p, SymTable *ctxt, bool err, int endc)
{
	const char *s;
	int flags;
	VarPattern *arg;

	s = *p + 1;
	if (s[0] == '=')
		flags = VAR_EQUAL;
	else if (s[0] == '?' && s[1] == '=')
		flags = VAR_MAY_EQUAL;
	else if (s[0] == '+' && s[1] == '=')
		flags = VAR_ADD_EQUAL;
	else if (s[0] == '!' && s[1] == '=')
		flags = VAR_BANG_EQUAL;
	else
		return NULL;

	arg = get_value(&s, ctxt, err, endc);
	if (arg != NULL) {
		*p = s;
		arg->flags = flags;
	}
	return arg;
}

static void *
get_value(const char **p, SymTable *ctxt, bool err, int endc)
{
	VarPattern *pattern;
	const char *s;

	pattern = emalloc(sizeof(VarPattern));
	s = *p + 1;
	pattern->rhs = NULL;
	pattern->lbuffer = VarGetPattern(ctxt, err, &s, ':', endc,
	    &pattern->leftLen, NULL);
	if (s[-1] == endc || s[-1] == ':') {
		*p = s-1;
		return pattern;
	}
	free_patternarg(pattern);
	return NULL;
}

static void *
get_cmd(const char **p, SymTable *ctxt, bool err, int endc UNUSED)
{
	VarPattern *pattern;
	const char *s;

	pattern = emalloc(sizeof(VarPattern));
	s = *p + 1;
	pattern->rhs = NULL;
	pattern->lbuffer = VarGetPattern(ctxt, err, &s, '!', '!',
	    &pattern->leftLen, NULL);
	if (s[-1] == '!') {
		*p = s-1;
		return pattern;
	}
	free_patternarg(pattern);
	return NULL;
}

static void
free_patternarg(void *p)
{
	VarPattern *vp = p;

	free(vp->lbuffer);
	free(vp->rhs);
	free(vp);
}

static char *
do_regex(const char *s, const struct Name *n UNUSED, void *arg)
{
	VarREPattern p2;
	VarPattern *p = arg;
	int error;
	char *result;

	error = regcomp(&p2.re, p->lhs, REG_EXTENDED);
	if (error) {
		VarREError(error, &p2.re, "RE substitution error");
		return var_Error;
	}
	p2.nsub = p2.re.re_nsub + 1;
	p2.replace = p->rhs;
	p2.flags = p->flags;
	if (p2.nsub < 1)
		p2.nsub = 1;
	if (p2.nsub > 10)
		p2.nsub = 10;
	p2.matches = ereallocarray(NULL, p2.nsub, sizeof(regmatch_t));
	result = VarModify((char *)s, VarRESubstitute, &p2);
	regfree(&p2.re);
	free(p2.matches);
	return result;
}

char *
VarModifiers_Apply(char *str, const struct Name *name, SymTable *ctxt,
    bool err, bool *freePtr, const char **pscan, int paren)
{
	const char *tstr;
	bool atstart;    /* Some ODE modifiers only make sense at start */
	char endc = paren == '(' ? ')' : '}';
	const char *start = *pscan;

	tstr = start;
	/*
	 * Now we need to apply any modifiers the user wants applied.
	 * These are:
	 *		  :M<pattern>	words which match the given <pattern>.
	 *				<pattern> is of the standard file
	 *				wildcarding form.
	 *		  :S<d><pat1><d><pat2><d>[g]
	 *				Substitute <pat2> for <pat1> in the
	 *				value
	 *		  :C<d><pat1><d><pat2><d>[g]
	 *				Substitute <pat2> for regex <pat1> in
	 *				the value
	 *		  :H		Substitute the head of each word
	 *		  :T		Substitute the tail of each word
	 *		  :E		Substitute the extension (minus '.') of
	 *				each word
	 *		  :R		Substitute the root of each word
	 *				(pathname minus the suffix).
	 *		  :lhs=rhs	Like :S, but the rhs goes to the end of
	 *				the invocation.
	 */

	atstart = true;
	while (*tstr != endc && *tstr != '\0') {
		struct modifier *mod;
		void *arg;
		char *newStr;

		tstr++;
		if (DEBUG(VAR)) {
			if (str != NULL)
				printf("Applying :%c to \"%s\"\n", *tstr, str);
			else
				printf("Applying :%c\n", *tstr);
		}

		mod = choose_mod[(unsigned char)*tstr];
		arg = NULL;

		if (mod != NULL && (!mod->atstart || atstart))
			arg = mod->getarg(&tstr, ctxt, err, endc);
		if (FEATURES(FEATURE_SYSVVARSUB) && arg == NULL) {
			mod = &sysv_mod;
			arg = mod->getarg(&tstr, ctxt, err, endc);
		}
		atstart = false;
		if (arg != NULL) {
			if (str != NULL || (mod->atstart && name != NULL)) {
				if (mod->word_apply != NULL) {
					newStr = VarModify(str,
					    mod->word_apply, arg);
					if (mod->apply != NULL) {
						char *newStr2;

						newStr2 = mod->apply(newStr,
						    name, arg);
						free(newStr);
						newStr = newStr2;
					}
				} else
					newStr = mod->apply(str, name, arg);
				if (*freePtr)
					free(str);
				str = newStr;
				if (str != var_Error)
					*freePtr = true;
				else
					*freePtr = false;
			}
			if (mod->freearg != NULL)
				mod->freearg(arg);
		} else {
			Error("Bad modifier: %s", tstr);
			/* Try skipping to end of var... */
			while (*tstr != endc && *tstr != '\0')
				tstr++;
			if (str != NULL && *freePtr)
				free(str);
			str = var_Error;
			*freePtr = false;
			break;
		}
		if (DEBUG(VAR) && str != NULL)
			printf("Result is \"%s\"\n", str);
	}
	if (*tstr == '\0')
		Parse_Error(PARSE_FATAL, "Unclosed variable specification");
	else
		tstr++;

	*pscan = tstr;
	return str;
}

char *
Var_GetHead(char *s)
{
	return VarModify(s, VarHead, NULL);
}

char *
Var_GetTail(char *s)
{
	return VarModify(s, VarTail, NULL);
}
@


1.46
log
@add support for variables in the lhs of SYSV modifiers.
lack of support noted by naddy@@
source, xenocara, and ports still build without a hitch.

okay naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.45 2017/01/25 14:17:45 espie Exp $	*/
d1520 1
a1520 1
			for (tstr++; *tstr != endc && *tstr != '\0';)
@


1.45
log
@off-by-one, leading to segfaults.  Trivial fix.

reported by jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.44 2016/10/02 17:42:31 tb Exp $	*/
d606 1
a606 1
	BUFFER buf;
d609 2
d614 2
a615 1
		if (*cp == '\0')
d617 1
d622 2
a623 1
			if (cnt < 0)
d625 11
d637 1
d639 2
a640 1
	Buf_Init(&buf, 0);
d647 1
d656 1
d664 1
a664 1
				(void)Var_ParseBuffer(&buf, cp2, ctxt, err, 
d670 1
a670 1
		Buf_AddChar(&buf, *cp2);
d674 4
a677 4
	pattern->lbuffer = pattern->lhs = Str_dupi(*p, cp);
	pattern->leftLen = cp - *p;
	pattern->rhs = Buf_Retrieve(&buf);
	pattern->rightLen = Buf_Size(&buf);
@


1.44
log
@Avoid two printf("%s", NULL) with 'make -d v'.

improvements & ok espie, earlier version ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.43 2015/11/15 06:19:22 daniel Exp $	*/
d879 1
a879 1
				if (n > pat->nsub) {
@


1.43
log
@unifdef MAKE_BOOTSTRAP now that Makefile.boot is gone.

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.42 2015/08/20 22:32:41 deraadt Exp $	*/
d1455 6
a1460 2
		if (DEBUG(VAR))
			printf("Applying :%c to \"%s\"\n", *tstr, str);
d1508 1
a1508 1
		if (DEBUG(VAR))
@


1.42
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.41 2015/01/23 22:35:58 espie Exp $	*/
a69 1
#ifndef MAKE_BOOTSTRAP
a70 1
#endif
a127 1
#ifndef MAKE_BOOTSTRAP
a138 1
#endif
a188 1
#ifndef MAKE_BOOTSTRAP
a189 1
#endif
a215 1
#ifndef MAKE_BOOTSTRAP
a216 1
#endif
a793 1
#ifndef MAKE_BOOTSTRAP
a935 1
#endif
a1388 1
#ifndef MAKE_BOOTSTRAP
a1414 1
#endif
@


1.41
log
@a wee little bit more cleanup (more const and remove noise from CDIAGFLAGS...
-pedantic kind of requires -std=c99 here to avoid LL warnings)
okay miod@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.40 2015/01/23 13:18:40 espie Exp $	*/
d661 1
a661 1
	pattern = (VarPattern *)emalloc(sizeof(VarPattern));
d1283 1
a1283 1
	pattern = (VarPattern *)emalloc(sizeof(VarPattern));
d1357 1
a1357 1
	pattern = (VarPattern *)emalloc(sizeof(VarPattern));
d1376 1
a1376 1
	pattern = (VarPattern *)emalloc(sizeof(VarPattern));
@


1.40
log
@remove a bunch of dangerous casts (useless casts from void * to something
else, in some cases by adding extra temporary variables.
IMO, it's much better practice to do

void *a;
int *p = a;
*p = 42;

rather than
void *a;
*(int *)a = 42;

okay miod@@... to be revisited for some possible const additions later.
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.39 2014/09/21 13:43:25 espie Exp $	*/
d359 1
a359 1
	const char *pat = (const char *)pattern;
d380 1
a380 1
	const char *pat = (const char *)pattern;
d431 1
a431 1
	struct Name *a, *b;
d435 2
a436 2
	a = (struct Name *)ap;
	b = (struct Name *)bp;
d442 1
a442 1
		    return c;
d444 1
a444 1
		    return -1;
d448 1
a448 1
		    return c;
d450 1
a450 1
		    return 1;
d452 1
a452 1
	    return strncmp(a->s, b->s, n);
@


1.39
log
@plug a small memory leak, fairly infrequent.
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.38 2014/05/18 08:08:50 espie Exp $	*/
d394 1
a394 1
	struct Name *last = (struct Name *)lastp;
d412 1
a412 1
	struct LoopStuff *v = (struct LoopStuff *)vp;
d423 1
a423 1
	struct LoopStuff *l = (struct LoopStuff *)p;
d517 1
a517 1
	VarPattern *v = (VarPattern *)arg;
d528 1
a528 1
	VarPattern *v = (VarPattern *)arg;
d539 1
a539 1
	VarPattern *v = (VarPattern *)arg;
d573 1
a573 1
	VarPattern *v = (VarPattern *)arg;
d595 1
a595 1
	VarPattern	*pat = (VarPattern *)patp;
d685 1
a685 1
    VarPattern	*pattern = (VarPattern *)patternp;
d1075 2
a1076 1
	int islist = *((int *)islistp);
d1228 1
a1228 1
	struct LoopStuff *l = (struct LoopStuff *)arg;
d1392 1
a1392 1
	VarPattern *vp = (VarPattern *)p;
d1404 1
a1404 1
	VarPattern *p = (VarPattern *)arg;
@


1.38
log
@a bit more reallocarray (and kill ecalloc, which isn't used)
okay chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.37 2014/05/12 19:11:19 espie Exp $	*/
d1116 2
a1117 1
	} else
d1119 1
@


1.37
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.36 2014/04/22 08:26:31 espie Exp $	*/
d1417 1
a1417 1
	p2.matches = emalloc(p2.nsub * sizeof(regmatch_t));
@


1.36
log
@effectively use emult_realloc, okay guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.35 2013/11/22 15:47:35 espie Exp $	*/
d463 1
a463 1
	t = ecalloc(n, sizeof(struct Name));
d470 1
a470 1
			t = emult_realloc(t, n, sizeof(struct Name));
@


1.35
log
@wrappers for is*/to* that make damn sure their arguments are
cast to unsigned chars.

okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.34 2013/11/12 17:44:03 deraadt Exp $	*/
d463 1
a463 1
	t = (struct Name *)emalloc(sizeof(struct Name) * n);
d470 1
a470 1
			t = (struct Name *)erealloc(t, sizeof(struct Name) * n);
@


1.34
log
@Do not use a char as index, unless first making it unsigned.
(signed char, ya know)
ok espie
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.33 2012/10/18 17:54:43 espie Exp $	*/
d870 1
a870 1
			    (*rp == '\\' && isdigit(rp[1]))) {
d1176 1
a1176 1
		t[i] = toupper(s[i]);
d1190 1
a1190 1
		t[i] = tolower(s[i]);
@


1.33
log
@numerous error message fixes:
- do ^C checking differently: don't record sent signals, but when jobs
die, recheck whether we received/have pending a INT/QUIT/TERM/HUP signal.
Then don't display our process group "normally", instead group together
everything dying by signal/shell dying by signal (just give the target
names).

- make certain we always handle signals before dying from "other conditions"
- have the parser messages look more like normal messages
- remove double error messages from some parser errors
- make sure unclosed variables ARE errors when some modifiers are present

- keep track of the base directory we're run from, so that submakes can
get shortened directories...
- make sure the whole error message including silent command fits into a
reasonable length.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.32 2012/10/12 13:20:11 espie Exp $	*/
d1467 1
a1467 1
		mod = choose_mod[*tstr];
@


1.32
log
@fix infinite loops on regexps that match the empty word, which is
especially bad during runtime as we trap ^C.

For instance ${A:C/-*//g}. Problem found by rpe@@

Do the same as other modern tools: advance by one char and repeat, so
that there's at most one empty word match at each position.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.31 2012/09/21 07:55:20 espie Exp $	*/
d1517 1
a1517 1
		Error("Unclosed variable specification");
@


1.31
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.30 2011/08/16 14:18:25 espie Exp $	*/
d915 11
a925 1
		if (pat->flags & VAR_SUB_GLOBAL)
d927 1
@


1.30
log
@recommit, now that release is done (handle sysv if bsd is incorrect, may
make more extensive plans later)
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.29 2011/07/30 21:02:13 espie Exp $	*/
d1492 1
a1492 1
			Error("Bad modifier: %s\n", tstr);
@


1.29
log
@deemed unsafe by theo, will wait after 5.0
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.27 2010/07/19 19:46:44 espie Exp $	*/
d632 2
a633 1
		if ((*cp2 == ':' || *cp2 == endc) && cnt == 0)
@


1.28
log
@systemV trumps our modifiers.
fixes a case encountered by jeremy@@
full fix not prudent at this time.
okay millert@@, otto@@
@
text
@d632 1
a632 2
		if (((*cp2 == ':' && cp2[1] != endc) || *cp2 == endc) && 
		    cnt == 0)
@


1.27
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.26 2010/07/19 19:30:38 espie Exp $	*/
d632 2
a633 1
		if ((*cp2 == ':' || *cp2 == endc) && cnt == 0)
@


1.26
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD: varmodifiers.c,v 1.25 2007/11/03 15:42:11 deraadt Exp $	*/
d5 1
a5 1
 * Copyright (c) 1999 Marc Espie.
@


1.25
log
@fix some lint FALLTHROUGH
@
text
@d2 1
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.24 2007/09/17 09:44:20 espie Exp $	*/
d152 1
d197 1
a197 1
	quote_mod = {false, check_empty, VarQuote, NULL , NULL},
d611 1
a611 2
get_sysvpattern(const char **p, SymTable *ctxt UNUSED, bool err UNUSED,
    int endc)
d615 1
a617 1

d631 1
d635 2
a636 1
		if (*cp2 == '\0')
d638 1
d643 2
a644 1
			if (cnt < 0)
d646 11
d658 1
d664 2
a665 2
	pattern->rhs = Str_dupi(cp+1, cp2);
	pattern->rightLen = cp2 - (cp+1);
d1062 1
a1062 1
VarQuote(const char *str, const struct Name *n UNUSED, void *dummy UNUSED)
d1064 1
d1069 3
d1075 1
a1075 1
		if (strchr(meta, *str) != NULL)
d1089 16
@


1.24
log
@zap more spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.23 2007/09/17 09:28:36 espie Exp $	*/
d908 1
a908 1
	       /* fall through */
@


1.23
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.22 2007/09/16 12:02:38 espie Exp $	*/
d245 1
a245 1
		choose_mod['P'] = &path_mod;	
d434 1
a434 1
	
d1199 1
a1199 1
	
d1409 1
a1409 1
	
@


1.22
log
@reindent varmodifiers.c, no binary change
@
text
@d2 1
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.14 2005/07/15 20:43:23 espie Exp $	*/
d356 1
a356 1
VarMatch(struct Name *word, bool addSpace, Buffer buf, 
d377 1
a377 1
VarNoMatch(struct Name *word, bool addSpace, Buffer buf, 
d397 1
a397 1
	if (last->s == NULL || last->e - last->s != word->e - word->s || 
d610 1
a610 1
get_sysvpattern(const char **p, SymTable *ctxt UNUSED, bool err UNUSED, 
d644 1
a644 1
	    
d664 1
a664 1
VarSubstitute(struct Name *word, bool addSpace, Buffer buf, 
d853 1
a853 1
			else if (*rp == '&' || 
d873 1
a873 1
					Error("No subexpression %s", 
d879 1
a879 1
					Error("No match for subexpression %s", 
d885 1
a885 1
					sublen = pat->matches[n].rm_eo - 
d933 1
a933 1
    bool (*modProc)(struct Name *, bool, Buffer, void *), 
d975 1
a975 1
VarGetPattern(SymTable *ctxt, int err, const char **tstr, int delim1, 
d1011 1
a1011 1
				(void)Var_ParseBuffer(&buf, cp, ctxt, err, 
d1226 1
a1226 1
common_get_patternarg(const char **p, SymTable *ctxt, bool err, int endc, 
d1243 1
a1243 1
	pattern->lhs = VarGetPattern(ctxt, err, &s, delim, delim, 
d1297 1
a1297 1
	} 
d1379 1
a1379 1
VarModifiers_Apply(char *str, const struct Name *name, SymTable *ctxt, 
d1433 1
a1433 1
					newStr = VarModify(str, 
d1438 1
a1438 1
						newStr2 = mod->apply(newStr, 
@


1.21
log
@remove warnings
@
text
@d2 1
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.20 2007/09/16 09:46:14 espie Exp $	*/
d106 6
a111 6
    char	  *lbuffer; /* left string to free */
    char	  *lhs;     /* String to match */
    size_t	  leftLen;  /* Length of string */
    char	  *rhs;     /* Replacement string (w/ &'s removed) */
    size_t	  rightLen; /* Length of replacement */
    int 	  flags;
d115 3
a117 3
    struct LoopVar	*var;
    char	*expand;
    bool	err;
d137 5
a141 5
    regex_t	  re;
    int 	  nsub;
    regmatch_t	 *matches;
    char	 *replace;
    int 	  flags;
d184 5
a188 5
	bool atstart;
	void * (*getarg)(const char **, SymTable *, bool, int);
	char * (*apply)(const char *, const struct Name *, void *);
	bool (*word_apply)(struct Name *, bool, Buffer, void *);
	void   (*freearg)(void *);
d190 3
a192 3
    match_mod = {false, get_stringarg, NULL, VarMatch, free_stringarg},
    nomatch_mod = {false, get_stringarg, NULL, VarNoMatch, free_stringarg},
    subst_mod = {false, get_spatternarg, NULL, VarSubstitute, free_patternarg},
d194 1
a194 1
    resubst_mod = {false, get_patternarg, do_regex, NULL, free_patternarg},
d196 18
a213 18
    quote_mod = {false, check_empty, VarQuote, NULL , NULL},
    tail_mod = {false, check_empty, NULL, VarTail, NULL},
    head_mod = {false, check_empty, NULL, VarHead, NULL},
    suffix_mod = {false, check_empty, NULL, VarSuffix, NULL},
    root_mod = {false, check_empty, NULL, VarRoot, NULL},
    upper_mod = {false, check_empty, do_upper, NULL, NULL},
    lower_mod = {false, check_empty, do_lower, NULL, NULL},
    shcmd_mod = {false, check_shcmd, do_shcmd, NULL, NULL},
    sysv_mod = {false, get_sysvpattern, NULL, VarSYSVMatch, free_patternarg},
    uniq_mod = {false, check_empty, NULL, VarUniq, NULL},
    sort_mod = {false, check_empty, do_sort, NULL, NULL},
    loop_mod = {false, get_loop, finish_loop, VarLoop, free_looparg},
    undef_mod = {true, get_value, do_undef, NULL, NULL},
    def_mod = {true, get_value, do_def, NULL, NULL},
    label_mod = {true, check_empty, do_label, NULL, NULL},
    path_mod = {true, check_empty, do_path, NULL, NULL},
    assign_mod = {true, assign_get_value, do_assign, NULL, free_patternarg},
    exec_mod = {true, get_cmd, do_exec, NULL, free_patternarg}
d219 3
a221 3
    choose_mod['M'] = &match_mod;
    choose_mod['N'] = &nomatch_mod;
    choose_mod['S'] = &subst_mod;
d223 1
a223 1
    choose_mod['C'] = &resubst_mod;
d225 26
a250 26
    choose_mod['Q'] = &quote_mod;
    choose_mod['T'] = &tail_mod;
    choose_mod['H'] = &head_mod;
    choose_mod['E'] = &suffix_mod;
    choose_mod['R'] = &root_mod;
    if (FEATURES(FEATURE_UPPERLOWER)) {
	choose_mod['U'] = &upper_mod;
	choose_mod['L'] = &lower_mod;
    }
    if (FEATURES(FEATURE_SUNSHCMD))
	choose_mod['s'] = &shcmd_mod;
    if (FEATURES(FEATURE_UNIQ))
    	choose_mod['u'] = &uniq_mod;
    if (FEATURES(FEATURE_SORT))
    	choose_mod['O'] = &sort_mod;
    if (FEATURES(FEATURE_ODE)) {
    	choose_mod['@@'] = &loop_mod;
	choose_mod['D'] = &def_mod;
	choose_mod['U'] = &undef_mod;
	choose_mod['L'] = &label_mod;
	choose_mod['P'] = &path_mod;	
    }
    if (FEATURES(FEATURE_ASSIGN))
    	choose_mod[':'] = &assign_mod;
    if (FEATURES(FEATURE_EXECMOD))
    	choose_mod['!'] = &exec_mod;
d267 1
a267 1
    const char	*slash;
d269 13
a281 13
    slash = Str_rchri(word->s, word->e, '/');
    if (slash != NULL) {
	if (addSpace)
	    Buf_AddSpace(buf);
	Buf_Addi(buf, word->s, slash);
    } else {
	/* If no directory part, give . (q.v. the POSIX standard).  */
	if (addSpace)
	    Buf_AddString(buf, " .");
	else
	    Buf_AddChar(buf, '.');
    }
    return true;
d294 1
a294 1
    const char	*slash;
d296 8
a303 8
    if (addSpace)
	Buf_AddSpace(buf);
    slash = Str_rchri(word->s, word->e, '/');
    if (slash != NULL)
	Buf_Addi(buf, slash+1, word->e);
    else
	Buf_Addi(buf, word->s, word->e);
    return true;
d315 1
a315 1
    const char	*dot;
d317 8
a324 8
    dot = Str_rchri(word->s, word->e, '.');
    if (dot != NULL) {
	if (addSpace)
	    Buf_AddSpace(buf);
	Buf_Addi(buf, dot+1, word->e);
	addSpace = true;
    }
    return addSpace;
d337 1
a337 1
    const char	*dot;
d339 8
a346 8
    if (addSpace)
	Buf_AddSpace(buf);
    dot = Str_rchri(word->s, word->e, '.');
    if (dot != NULL)
	Buf_Addi(buf, word->s, dot);
    else
	Buf_Addi(buf, word->s, word->e);
    return true;
d359 1
a359 1
    const char *pat = (const char *)pattern;
d361 7
a367 7
    if (Str_Matchi(word->s, word->e, pat, strchr(pat, '\0'))) {
	if (addSpace)
	    Buf_AddSpace(buf);
	Buf_Addi(buf, word->s, word->e);
	return true;
    } else
	return addSpace;
d380 1
a380 1
    const char *pat = (const char *)pattern;
d382 7
a388 7
    if (!Str_Matchi(word->s, word->e, pat, strchr(pat, '\0'))) {
	if (addSpace)
	    Buf_AddSpace(buf);
	Buf_Addi(buf, word->s, word->e);
	return true;
    } else
	return addSpace;
d394 1
a394 1
    struct Name *last = (struct Name *)lastp;
d396 11
a406 11
    	/* does not match */
    if (last->s == NULL || last->e - last->s != word->e - word->s || 
    	strncmp(word->s, last->s, word->e - word->s) != 0) {
	if (addSpace)
	    Buf_AddSpace(buf);
	Buf_Addi(buf, word->s, word->e);
	addSpace = true;
    }
    last->s = word->s;
    last->e = word->e;
    return addSpace;
d412 1
a412 1
    struct LoopStuff *v = (struct LoopStuff *)vp;
d414 4
a417 4
    if (addSpace)
    	Buf_AddSpace(buf);
    Var_SubstVar(buf, v->expand, v->var, word->s);
    return true;
d458 22
a479 22
    struct Name *t;
    unsigned long n, i, j;
    const char *start, *end;

    n = 1024;	/* start at 1024 words */
    t = (struct Name *)emalloc(sizeof(struct Name) * n);
    start = s;
    end = start;

    for (i = 0;; i++) {
    	if (i == n) {
		n *= 2;
		t = (struct Name *)erealloc(t, sizeof(struct Name) * n);
	}
	start = iterate_words(&end);
	if (start == NULL)
	    break;
	t[i].s = start;
	t[i].e = end;
    }
    if (i > 0) {
    	BUFFER buf;
d481 12
a492 6
    	Buf_Init(&buf, end - s);
	qsort(t, i, sizeof(struct Name), NameCompare);
	Buf_Addi(&buf, t[0].s, t[0].e);
	for (j = 1; j < i; j++) {
		Buf_AddSpace(&buf);
		Buf_Addi(&buf, t[j].s, t[j].e);
a493 6
	free(t);
	return Buf_Retrieve(&buf);
    } else {
    	free(t);
    	return "";
    }
d499 1
a499 1
    return Str_dupi(n->s, n->e);
d505 1
a505 1
    GNode *gn;
d507 5
a511 5
    gn = Targ_FindNodei(n->s, n->e, TARG_NOCREATE);
    if (gn == NULL)
    	return Str_dupi(n->s, n->e);
    else
	return strdup(gn->path);
d517 6
a522 6
    VarPattern *v = (VarPattern *)arg;
    if (s == NULL) {
    	free_patternarg(v);
	return NULL;
    } else
    	return v->lbuffer;
d528 6
a533 6
    VarPattern *v = (VarPattern *)arg;
    if (s != NULL) {
    	free_patternarg(v);
	return NULL;
    } else
    	return v->lbuffer;
d539 26
a564 26
    VarPattern *v = (VarPattern *)arg;
    char *msg;
    char *result;

    switch (v->flags) {
    case VAR_EQUAL:
    	Var_Seti(n->s, n->e, v->lbuffer);
	break;
    case VAR_MAY_EQUAL:
    	if (s == NULL)
	    Var_Seti(n->s, n->e, v->lbuffer);
	break;
    case VAR_ADD_EQUAL:
    	if (s == NULL)
	    Var_Seti(n->s, n->e, v->lbuffer);
	else
	    Var_Appendi(n->s, n->e, v->lbuffer);
	break;
    case VAR_BANG_EQUAL:
    	result = Cmd_Exec(v->lbuffer, &msg);
	if (result != NULL) {
		Var_Seti(n->s, n->e, result);
		free(result);
	} else
		Error(msg, v->lbuffer);
	break;
d566 2
a567 2
    }
    return NULL;
d573 8
a580 8
    VarPattern *v = (VarPattern *)arg;
    char *msg;
    char *result;

    result = Cmd_Exec(v->lbuffer, &msg);
    if (result == NULL)
	Error(msg, v->lbuffer);
    return result;
d591 1
a591 2
VarSYSVMatch(struct Name *word, bool addSpace, Buffer buf, 
    void *patp) /* Pattern the word must match */
d593 3
a595 3
    size_t	len;
    const char	*ptr;
    VarPattern	*pat = (VarPattern *)patp;
d597 10
a606 10
    if (*word->s != '\0') {
	    if (addSpace)
		Buf_AddSpace(buf);
	    if ((ptr = Str_SYSVMatch(word->s, pat->lhs, &len)) != NULL)
		Str_SYSVSubst(buf, pat->rhs, ptr, len);
	    else
		Buf_Addi(buf, word->s, word->e);
	    return true;
    } else
	return addSpace;
d613 17
a629 16
    VarPattern		*pattern;
    const char		*cp, *cp2;
    int cnt = 0;
    char startc = endc == ')' ? '(' : '{';

    for (cp = *p;; cp++) {
    	if (*cp == '=' && cnt == 0)
	    break;
	if (*cp == '\0')
	    return NULL;
	if (*cp == startc)
	    cnt++;
	else if (*cp == endc) {
	    cnt--;
	    if (cnt < 0)
	    	return NULL;
d631 12
a642 12
    }
    for (cp2 = cp+1;; cp2++) {
    	if ((*cp2 == ':' || *cp2 == endc) && cnt == 0)
	    break;
	if (*cp2 == '\0')
	    return NULL;
	if (*cp2 == startc)
	    cnt++;
	else if (*cp2 == endc) {
	    cnt--;
	    if (cnt < 0)
	    	return NULL;
d644 9
a652 10
    }
	
    pattern = (VarPattern *)emalloc(sizeof(VarPattern));
    pattern->lbuffer = pattern->lhs = Str_dupi(*p, cp);
    pattern->leftLen = cp - *p;
    pattern->rhs = Str_dupi(cp+1, cp2);
    pattern->rightLen = cp2 - (cp+1);
    pattern->flags = 0;
    *p = cp2;
    return pattern;
d796 2
a797 2
    char	*errbuf;
    int 	errlen;
d799 5
a803 5
    errlen = regerror(err, pat, 0, 0);
    errbuf = emalloc(errlen);
    regerror(err, pat, errbuf, errlen);
    Error("%s: %s", str, errbuf);
    free(errbuf);
d816 5
a820 5
    VarREPattern	*pat;
    int 		xrv;
    const char		*wp;
    char		*rp;
    int 		added;
d824 1
a824 1
	    Buf_AddSpace(buf);		\
d827 10
a836 18
    added = 0;
    wp = word->s;
    pat = patternp;

    if ((pat->flags & (VAR_SUB_ONE|VAR_SUB_MATCHED)) ==
	(VAR_SUB_ONE|VAR_SUB_MATCHED))
	xrv = REG_NOMATCH;
    else {
    tryagain:
	xrv = regexec(&pat->re, wp, pat->nsub, pat->matches, 0);
    }

    switch (xrv) {
    case 0:
	pat->flags |= VAR_SUB_MATCHED;
	if (pat->matches[0].rm_so > 0) {
	    MAYBE_ADD_SPACE();
	    Buf_AddChars(buf, pat->matches[0].rm_so, wp);
d839 6
a844 22
	for (rp = pat->replace; *rp; rp++) {
	    if (*rp == '\\' && (rp[1] == '&' || rp[1] == '\\')) {
		MAYBE_ADD_SPACE();
		Buf_AddChar(buf,rp[1]);
		rp++;
	    }
	    else if (*rp == '&' || (*rp == '\\' && isdigit(rp[1]))) {
		int n;
		const char *subbuf;
		int sublen;
		char errstr[3];

		if (*rp == '&') {
		    n = 0;
		    errstr[0] = '&';
		    errstr[1] = '\0';
		} else {
		    n = rp[1] - '0';
		    errstr[0] = '\\';
		    errstr[1] = rp[1];
		    errstr[2] = '\0';
		    rp++;
d847 57
a903 12
		if (n > pat->nsub) {
		    Error("No subexpression %s", &errstr[0]);
		    subbuf = "";
		    sublen = 0;
		} else if (pat->matches[n].rm_so == -1 &&
			   pat->matches[n].rm_eo == -1) {
		    Error("No match for subexpression %s", &errstr[0]);
		    subbuf = "";
		    sublen = 0;
		} else {
		    subbuf = wp + pat->matches[n].rm_so;
		    sublen = pat->matches[n].rm_eo - pat->matches[n].rm_so;
d905 8
a912 4

		if (sublen > 0) {
		    MAYBE_ADD_SPACE();
		    Buf_AddChars(buf, sublen, subbuf);
d914 1
a914 20
	    } else {
		MAYBE_ADD_SPACE();
		Buf_AddChar(buf, *rp);
	    }
	}
	wp += pat->matches[0].rm_eo;
	if (pat->flags & VAR_SUB_GLOBAL)
	    goto tryagain;
	if (*wp) {
	    MAYBE_ADD_SPACE();
	    Buf_AddString(buf, wp);
	}
	break;
    default:
	VarREError(xrv, &pat->re, "Unexpected regex error");
       /* fall through */
    case REG_NOMATCH:
	if (*wp) {
	    MAYBE_ADD_SPACE();
	    Buf_AddString(buf, wp);
d916 1
a916 3
	break;
    }
    return addSpace||added;
d936 20
a955 20
    BUFFER	  buf;		/* Buffer for the new string */
    bool	  addSpace;	/* true if need to add a space to the
				 * buffer before adding the trimmed
				 * word */
    struct Name	  word;

    Buf_Init(&buf, 0);
    addSpace = false;

    word.e = str;

    while ((word.s = iterate_words(&word.e)) != NULL) {
    	char termc;

	termc = *word.e;
	*((char *)(word.e)) = '\0';
	addSpace = (*modProc)(&word, addSpace, &buf, datum);
	*((char *)(word.e)) = termc;
    }
    return Buf_Retrieve(&buf);
d978 8
a985 8
    const char	*cp;
    char	*result;
    BUFFER	buf;
    size_t	junk;

    Buf_Init(&buf, 0);
    if (length == NULL)
	length = &junk;
d988 2
a989 2
    (cp[0] == '\\' && (cp[1] == delim1 || cp[1] == delim2 || \
     cp[1] == '\\' || cp[1] == '$' || (pattern && cp[1] == '&')))
d991 29
a1019 27
    /*
     * Skim through until the matching delimiter is found;
     * pick up variable substitutions on the way. Also allow
     * backslashes to quote the delimiter, $, and \, but don't
     * touch other backslashes.
     */
    for (cp = *tstr; *cp != '\0' && *cp != delim1 && *cp != delim2; cp++) {
	if (IS_A_MATCH(cp, delim1, delim2)) {
	    Buf_AddChar(&buf, cp[1]);
	    cp++;
	} else if (*cp == '$') {
		/* Allowed at end of pattern */
	    if (cp[1] == delim1 || cp[1] == delim2)
		Buf_AddChar(&buf, *cp);
	    else {
		size_t len;

		/* If unescaped dollar sign not before the delimiter,
		 * assume it's a variable substitution and recurse.  */
		(void)Var_ParseBuffer(&buf, cp, ctxt, err, &len);
		cp += len - 1;
	    }
	} else if (pattern && *cp == '&')
	    Buf_AddChars(&buf, pattern->leftLen, pattern->lhs);
	else
	    Buf_AddChar(&buf, *cp);
    }
d1021 2
a1022 2
    *length = Buf_Size(&buf);
    result = Buf_Retrieve(&buf);
d1024 10
a1033 10
    if (*cp != delim1 && *cp != delim2) {
	*tstr = cp;
	*length = 0;
	free(result);
	return NULL;
    }
    else {
	*tstr = ++cp;
	return result;
    }
d1049 11
a1059 11
    BUFFER	  buf;
    /* This should cover most shells :-( */
    static char meta[] = "\n \t'`\";&<>()|*?{}[]\\$!#^~";

    Buf_Init(&buf, MAKE_BSIZE);
    for (; *str; str++) {
	if (strchr(meta, *str) != NULL)
	    Buf_AddChar(&buf, '\\');
	Buf_AddChar(&buf, *str);
    }
    return Buf_Retrieve(&buf);
d1065 6
a1070 6
    dummy_arg->s = NULL;
    if ((*p)[1] == endc || (*p)[1] == ':') {
	(*p)++;
	return dummy_arg;
    } else
	return NULL;
d1076 5
a1080 5
    if ((*p)[1] == 'h' && ((*p)[2] == endc || (*p)[2] == ':')) {
	(*p)+=2;
	return dummy_arg;
    } else
	return NULL;
d1087 2
a1088 2
    char	*err;
    char	*t;
d1090 4
a1093 4
    t = Cmd_Exec(s, &err);
    if (err)
	Error(err, s);
    return t;
d1099 2
a1100 2
    const char	*cp;
    char	*s;
d1102 10
a1111 10
    for (cp = *p + 1; *cp != ':' && *cp != endc; cp++) {
	if (*cp == '\\') {
	    if (cp[1] == ':' || cp[1] == endc || cp[1] == '\\')
		cp++;
	} else if (*cp == '\0')
	    return NULL;
    }
    s = escape_dupi(*p+1, cp, ":)}");
    *p = cp;
    return s;
d1117 1
a1117 1
    free(arg);
d1123 2
a1124 2
    size_t	len, i;
    char	*t;
d1126 6
a1131 6
    len = strlen(s);
    t = emalloc(len+1);
    for (i = 0; i < len; i++)
	t[i] = toupper(s[i]);
    t[len] = '\0';
    return t;
d1137 2
a1138 2
    size_t	len, i;
    char	*t;
d1140 6
a1145 6
    len = strlen(s);
    t = emalloc(len+1);
    for (i = 0; i < len; i++)
	t[i] = tolower(s[i]);
    t[len] = '\0';
    return t;
d1151 1
a1151 1
    return common_get_patternarg(p, ctxt, err, endc, false);
d1158 1
a1158 1
    VarPattern *pattern;
d1160 5
a1164 10
    pattern = common_get_patternarg(p, ctxt, err, endc, true);
    if (pattern != NULL && pattern->leftLen > 0) {
	if (pattern->lhs[pattern->leftLen-1] == '$') {
		pattern->leftLen--;
		pattern->flags |= VAR_MATCH_END;
	}
    	if (pattern->lhs[0] == '^') {
		pattern->lhs++;
		pattern->leftLen--;
		pattern->flags |= VAR_MATCH_START;
d1166 7
a1172 2
    }
    return pattern;
d1178 1
a1178 1
    struct LoopStuff *l = (struct LoopStuff *)arg;
d1180 2
a1181 2
    Var_DeleteLoopVar(l->var);
    free(l->expand);
d1187 1
a1187 1
    const char *p, *start;
d1189 9
a1197 9
    start = *s;
    for (p = start; *p != '@@'; p++) {
    	if (*p == '\\')
	    p++;
    	if (*p == 0)
		return NULL;
    }
    *s = p+1;
    return escape_dupi(start, p, "@@\\");
d1203 17
a1219 16
    static struct LoopStuff	loop;
    const char *s;
    const char *var;

    s = *p +1;

    loop.var = NULL;
    loop.expand = NULL;
    loop.err = err;
    var = LoopGrab(&s);
    if (var != NULL) {
    	loop.expand = LoopGrab(&s);
	if (*s == endc || *s == ':') {
	    *p = s;
	    loop.var = Var_NewLoopVar(var, NULL);
	    return &loop;
d1221 2
a1222 3
    }
    free_looparg(&loop);
    return NULL;
d1229 7
a1235 7
    VarPattern *pattern;
    char	delim;
    const char	*s;

    pattern = (VarPattern *)emalloc(sizeof(VarPattern));
    pattern->flags = 0;
    s = *p;
d1237 4
a1240 4
    delim = s[1];
    if (delim == '\0')
	return NULL;
    s += 2;
d1242 26
a1267 19
    pattern->rhs = NULL;
    pattern->lhs = VarGetPattern(ctxt, err, &s, delim, delim,
	&pattern->leftLen, NULL);
    pattern->lbuffer = pattern->lhs;
    if (pattern->lhs != NULL) {
	pattern->rhs = VarGetPattern(ctxt, err, &s, delim, delim,
	    &pattern->rightLen, dosubst ? pattern: NULL);
	if (pattern->rhs != NULL) {
	    /* Check for global substitution. If 'g' after the final
	     * delimiter, substitution is global and is marked that
	     * way.  */
	    for (;; s++) {
		switch (*s) {
		case 'g':
		    pattern->flags |= VAR_SUB_GLOBAL;
		    continue;
		case '1':
		    pattern->flags |= VAR_SUB_ONE;
		    continue;
a1268 6
		break;
	    }
	    if (*s == endc || *s == ':') {
		*p = s;
		return pattern;
	    }
d1270 2
a1271 3
    }
    free_patternarg(pattern);
    return NULL;
d1277 22
a1298 22
    const char *s;
    int flags;
    VarPattern *arg;

    s = *p + 1;
    if (s[0] == '=')
    	flags = VAR_EQUAL;
    else if (s[0] == '?' && s[1] == '=')
    	flags = VAR_MAY_EQUAL;
    else if (s[0] == '+' && s[1] == '=')
    	flags = VAR_ADD_EQUAL;
    else if (s[0] == '!' && s[1] == '=')
    	flags = VAR_BANG_EQUAL;
    else
    	return NULL;

    arg = get_value(&s, ctxt, err, endc);
    if (arg != NULL) {
    	*p = s;
	arg->flags = flags;
    } 
    return arg;
d1304 2
a1305 2
    VarPattern *pattern;
    const char *s;
d1307 11
a1317 11
    pattern = (VarPattern *)emalloc(sizeof(VarPattern));
    s = *p + 1;
    pattern->rhs = NULL;
    pattern->lbuffer = VarGetPattern(ctxt, err, &s, ':', endc,
    	&pattern->leftLen, NULL);
    if (s[-1] == endc || s[-1] == ':') {
    	*p = s-1;
	return pattern;
    }
    free_patternarg(pattern);
    return NULL;
d1323 2
a1324 2
    VarPattern *pattern;
    const char *s;
d1326 11
a1336 11
    pattern = (VarPattern *)emalloc(sizeof(VarPattern));
    s = *p + 1;
    pattern->rhs = NULL;
    pattern->lbuffer = VarGetPattern(ctxt, err, &s, '!', '!',
    	&pattern->leftLen, NULL);
    if (s[-1] == '!') {
    	*p = s-1;
	return pattern;
    }
    free_patternarg(pattern);
    return NULL;
d1342 1
a1342 1
    VarPattern *vp = (VarPattern *)p;
d1344 3
a1346 3
    free(vp->lbuffer);
    free(vp->rhs);
    free(vp);
d1353 22
a1374 22
    VarREPattern p2;
    VarPattern	*p = (VarPattern *)arg;
    int 	error;
    char	*result;

    error = regcomp(&p2.re, p->lhs, REG_EXTENDED);
    if (error) {
	VarREError(error, &p2.re, "RE substitution error");
	return var_Error;
    }
    p2.nsub = p2.re.re_nsub + 1;
    p2.replace = p->rhs;
    p2.flags = p->flags;
    if (p2.nsub < 1)
	p2.nsub = 1;
    if (p2.nsub > 10)
	p2.nsub = 10;
    p2.matches = emalloc(p2.nsub * sizeof(regmatch_t));
    result = VarModify((char *)s, VarRESubstitute, &p2);
    regfree(&p2.re);
    free(p2.matches);
    return result;
d1382 86
a1467 44
    const char	*tstr;
    bool	atstart;    /* Some ODE modifiers only make sense at start */
    char endc = paren == '(' ? ')' : '}';
    const char *start = *pscan;

    tstr = start;
    /*
     * Now we need to apply any modifiers the user wants applied.
     * These are:
     *		  :M<pattern>	words which match the given <pattern>.
     *				<pattern> is of the standard file
     *				wildcarding form.
     *		  :S<d><pat1><d><pat2><d>[g]
     *				Substitute <pat2> for <pat1> in the value
     *		  :C<d><pat1><d><pat2><d>[g]
     *				Substitute <pat2> for regex <pat1> in the value
     *		  :H		Substitute the head of each word
     *		  :T		Substitute the tail of each word
     *		  :E		Substitute the extension (minus '.') of
     *				each word
     *		  :R		Substitute the root of each word
     *				(pathname minus the suffix).
     *		  :lhs=rhs	Like :S, but the rhs goes to the end of
     *				the invocation.
     */
    
    atstart = true;
    while (*tstr != endc && *tstr != '\0') {
	struct modifier *mod;
	void		*arg;
	char		*newStr;

	tstr++;
	if (DEBUG(VAR))
	    printf("Applying :%c to \"%s\"\n", *tstr, str);

	mod = choose_mod[*tstr];
	arg = NULL;

	if (mod != NULL && (!mod->atstart || atstart))
	    arg = mod->getarg(&tstr, ctxt, err, endc);
	if (FEATURES(FEATURE_SYSVVARSUB) && arg == NULL) {
	    mod = &sysv_mod;
	    arg = mod->getarg(&tstr, ctxt, err, endc);
d1469 3
a1471 28
	atstart = false;
	if (arg != NULL) {
	    if (str != NULL || (mod->atstart && name != NULL)) {
		if (mod->word_apply != NULL) {
		    newStr = VarModify(str, mod->word_apply, arg);
		    if (mod->apply != NULL) {
		    	char *newStr2;

		    	newStr2 = mod->apply(newStr, name, arg);
			free(newStr);
			newStr = newStr2;
		    }
		} else
		    newStr = mod->apply(str, name, arg);
		if (*freePtr)
		    free(str);
		str = newStr;
		if (str != var_Error)
		    *freePtr = true;
		else
		    *freePtr = false;
	    }
	    if (mod->freearg != NULL)
		mod->freearg(arg);
	} else {
	    Error("Bad modifier: %s\n", tstr);
	    /* Try skipping to end of var... */
	    for (tstr++; *tstr != endc && *tstr != '\0';)
a1472 13
	    if (str != NULL && *freePtr)
		free(str);
	    str = var_Error;
	    *freePtr = false;
	    break;
	}
	if (DEBUG(VAR))
	    printf("Result is \"%s\"\n", str);
    }
    if (*tstr == '\0')
	Error("Unclosed variable specification");
    else
    	tstr++;
d1474 2
a1475 2
    *pscan = tstr;
    return str;
d1481 1
a1481 1
    return VarModify(s, VarHead, NULL);
d1487 1
a1487 1
    return VarModify(s, VarTail, NULL);
@


1.20
log
@remove dead code: #define RECHECK is always on
@
text
@d2 1
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.14 2005/07/15 20:43:23 espie Exp $	*/
d1196 1
a1196 1
get_loop(const char **p, SymTable *ctxt, bool err, int endc)
@


1.19
log
@everywhere except in Var_Parse, we always add/append variables to the
VAR_GLOBAL context, so make it the common case: rename the basic functions
to Var_Set_with_ctxt/Var_Append_with_ctxt, define Var_Set and Var_Append
as macros that specify VAR_GLOBAL, and use these.

okay miod@@
@
text
@@


1.18
log
@simplify computations in the var module: instead of advancing a char *
and keeping track of a length, we just advance the char *, and ditch
the length. We can still get the length at the end of the top-level
functions to satisfy existing interfaces.

Much simpler code, less error-prone.

Okay millert@@
@
text
@d545 1
a545 1
    	Var_Seti(n->s, n->e, v->lbuffer, VAR_GLOBAL);
d549 1
a549 1
	    Var_Seti(n->s, n->e, v->lbuffer, VAR_GLOBAL);
d553 1
a553 1
	    Var_Seti(n->s, n->e, v->lbuffer, VAR_GLOBAL);
d555 1
a555 1
	    Var_Appendi(n->s, n->e, v->lbuffer, VAR_GLOBAL);
d560 1
a560 1
		Var_Seti(n->s, n->e, result, VAR_GLOBAL);
@


1.17
log
@move the code that grabs a value in Var_Parse in its own function,
get_expanded_value.

Extend the code a bit to be much more thorough in case of a recursive
expansion: shows exactly the cycle of variable names involved.

okay millert@@
@
text
@d1375 1
a1375 1
    bool err, bool *freePtr, const char *start, int paren, size_t *lengthPtr)
d1380 1
d1460 1
a1460 1
    if (*tstr == '\0') {
d1462 2
a1463 3
	/* make tstr point at the last char of the variable specification */
	tstr--;
    }
d1465 1
a1465 1
    *lengthPtr += tstr - start;
@


1.16
log
@change Var_ParseSkip API to increment the position instead of returning a
length, simplifies code.

(warns a bit, symptom of some further issues to fix).

okay millert@@
@
text
@@


1.15
log
@big clean-up patch:
- rename a few functions in var.c to names that make more sense.
- introduce Var_Deletei because it makes more sense.
- rewrite .for loops to use a local LoopVar construct to avoid looking up more
stuff.
- reformat var.c to near K&R
- rewrite most comments in var.c

shown to a few people. millert@@ gave me his okay since it passes through
ports correctly.
@
text
@@


1.14
log
@fixes 4286.
back & forth between fgs and me.
@
text
@d2 1
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.13 2004/04/07 13:11:36 espie Exp $	*/
d115 1
a115 1
    char	*var;
a116 1
    SymTable	*ctxt;
d425 1
a425 1
	return Var_Subst(s, l->ctxt, l->err);
d1175 1
a1175 1
    free(l->var);
d1200 1
a1205 1
    loop.ctxt =ctxt;
d1207 2
a1208 2
    loop.var = LoopGrab(&s);
    if (loop.var != NULL) {
d1212 1
d1375 1
a1375 1
    bool err, bool *freePtr, const char *start, int endc, size_t *lengthPtr)
d1379 1
@


1.13
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.12 2003/10/07 18:33:08 fgsch Exp $	*/
d618 1
a618 1
    char startc = endc == ')' ? '(' : '}';
d636 2
d1458 1
a1458 1
    if (*tstr == '\0')
d1460 3
@


1.12
log
@- check if result is valid before using it.
- correctly set *freePtr, not freePtr.
input and ok espie@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.11 2003/06/03 02:56:12 millert Exp $	*/
d266 1
a266 5
VarHead(word, addSpace, buf, dummy)
    struct Name *word;
    bool	addSpace;
    Buffer	buf;
    void	*dummy		UNUSED;
d293 1
a293 5
VarTail(word, addSpace, buf, dummy)
    struct Name *word;
    bool	addSpace;
    Buffer	buf;
    void	*dummy		UNUSED;
d314 1
a314 5
VarSuffix(word, addSpace, buf, dummy)
    struct Name *word;
    bool	addSpace;
    Buffer	buf;
    void	*dummy		UNUSED;
d336 1
a336 5
VarRoot(word, addSpace, buf, dummy)
    struct Name *word;
    bool	addSpace;
    Buffer	buf;
    void	*dummy		UNUSED;
d357 2
a358 5
VarMatch(word, addSpace, buf, pattern)
    struct Name *word;
    bool	addSpace;
    Buffer	buf;
    void	*pattern;	/* Pattern the word must match */
d378 2
a379 5
VarNoMatch(word, addSpace, buf, pattern)
    struct Name *word;
    bool	addSpace;
    Buffer	buf;
    void	*pattern;	/* Pattern the word must not match */
d393 1
a393 5
VarUniq(word, addSpace, buf, lastp)
    struct Name	*word;
    bool	addSpace;
    Buffer	buf;
    void	*lastp;
d411 1
a411 5
VarLoop(word, addSpace, buf, vp)
    struct Name	*word;
    bool	addSpace;
    Buffer	buf;
    void	*vp;
d422 1
a422 4
finish_loop(s, n, p)
	const char *s;
	const struct Name *n	UNUSED;
	void *p;
d430 1
a430 3
NameCompare(ap, bp)
	const void *ap;
	const void *bp;
d457 1
a457 4
do_sort(s, dummy, arg)
    const char	*s;
    const struct Name *dummy UNUSED;
    void	*arg	UNUSED;
d498 1
a498 4
do_label(s, n, arg)
    const char *s 	UNUSED;
    const struct Name *n;
    void *arg 		UNUSED;
d504 1
a504 4
do_path(s, n, arg)
    const char *s 	UNUSED;
    const struct Name *n;
    void *arg 		UNUSED;
d516 1
a516 4
do_def(s, n, arg)
    const char *s;
    const struct Name *n	UNUSED;
    void *arg;
d527 1
a527 4
do_undef(s, n, arg)
    const char *s;
    const struct Name *n	UNUSED;
    void *arg;
d538 1
a538 4
do_assign(s, n, arg)
    const char *s;
    const struct Name *n;
    void *arg;
d572 1
a572 4
do_exec(s, n, arg)
    const char *s		UNUSED;
    const struct Name *n	UNUSED;
    void *arg;
d592 2
a593 5
VarSYSVMatch(word, addSpace, buf, patp)
    struct Name *word;
    bool	addSpace;
    Buffer	buf;
    void	*patp;	/* Pattern the word must match */
d612 2
a613 5
get_sysvpattern(p, ctxt, err, endc)
    const char		**p;
    SymTable		*ctxt	UNUSED;
    bool		err	UNUSED;
    int			endc;
d664 2
a665 5
VarSubstitute(word, addSpace, buf, patternp)
    struct Name *word;
    bool	addSpace;
    Buffer	buf;
    void	*patternp;	/* Pattern for substitution */
d794 1
a794 4
VarREError(err, pat, str)
    int 	err;
    regex_t	*pat;
    const char	*str;
d814 1
a814 5
VarRESubstitute(word, addSpace, buf, patternp)
    struct Name		*word;
    bool		addSpace;
    Buffer		buf;
    void		*patternp;
d927 1
a927 2
VarModify(str, modProc, datum)
    char	  *str; 	/* String whose words should be trimmed */
d929 2
a930 2
    bool	  (*modProc)(struct Name *, bool, Buffer, void *);
    void	  *datum;	/* Datum to pass it */
d971 2
a972 8
VarGetPattern(ctxt, err, tstr, delim1, delim2, length, pattern)
    SymTable	*ctxt;
    int 	err;
    const char	**tstr;
    int 	delim1;
    int 	delim2;
    size_t	*length;
    VarPattern	*pattern;
d1040 1
a1040 4
VarQuote(str, n, dummy)
    const char	*str;
    const struct Name *n	UNUSED;
    void	*dummy		UNUSED;
d1057 1
a1057 5
check_empty(p, ctxt, b, endc)
    const char	**p;
    SymTable	*ctxt		UNUSED;
    bool	b		UNUSED;
    int		endc;
d1068 1
a1068 5
check_shcmd(p, ctxt, b, endc)
    const char	**p;
    SymTable	*ctxt		UNUSED;
    bool	b		UNUSED;
    int		endc;
d1079 1
a1079 4
do_shcmd(s, n, arg)
    const char	*s;
    const struct Name *n	UNUSED;
    void	*arg		UNUSED;
d1091 1
a1091 5
get_stringarg(p, ctxt, b, endc)
    const char	**p;
    SymTable	*ctxt		UNUSED;
    bool	b		UNUSED;
    int		endc;
d1109 1
a1109 2
free_stringarg(arg)
    void *arg;
d1115 1
a1115 4
do_upper(s, n, arg)
    const char	*s;
    const struct Name *n	UNUSED;
    void	*arg		UNUSED;
d1129 1
a1129 4
do_lower(s, n, arg)
    const char	*s;
    const struct Name *n	UNUSED;
    void	*arg		UNUSED;
d1143 1
a1143 5
get_patternarg(p, ctxt, err, endc)
    const char	**p;
    SymTable	*ctxt;
    bool	err;
    int		endc;
d1150 1
a1150 5
get_spatternarg(p, ctxt, err, endc)
    const char	**p;
    SymTable	*ctxt;
    bool	err;
    int		endc;
d1170 1
a1170 2
free_looparg(arg)
    void *arg;
d1179 1
a1179 2
LoopGrab(s)
    const char **s;
d1195 1
a1195 5
get_loop(p, ctxt, err, endc)
    const char 	**p;
    SymTable	*ctxt;
    bool	err;
    int		endc;
d1219 2
a1220 6
common_get_patternarg(p, ctxt, err, endc, dosubst)
    const char	**p;
    SymTable	*ctxt;
    bool	err;
    int		endc;
    bool 	dosubst;
d1268 1
a1268 5
assign_get_value(p, ctxt, err, endc)
    const char 	**p;
    SymTable 	*ctxt;
    bool	err;
    int		endc;
d1295 1
a1295 5
get_value(p, ctxt, err, endc)
    const char 	**p;
    SymTable 	*ctxt;
    bool	err;
    int		endc;
d1314 1
a1314 5
get_cmd(p, ctxt, err, endc)
    const char 	**p;
    SymTable 	*ctxt;
    bool	err;
    int		endc	UNUSED;
d1333 1
a1333 2
free_patternarg(p)
    void *p;
d1344 1
a1344 4
do_regex(s, n, arg)
    const char	*s;
    const struct Name *n	UNUSED;
    void	*arg;
d1372 2
a1373 9
VarModifiers_Apply(str, name, ctxt, err, freePtr, start, endc, lengthPtr)
    char	*str;
    const struct Name *name;
    SymTable	*ctxt;
    bool	err;
    bool	*freePtr;
    const char	*start;
    int		endc;
    size_t	*lengthPtr;
d1464 1
a1464 2
Var_GetHead(s)
    char *s;
d1470 1
a1470 2
Var_GetTail(s)
    char *s;
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.10 2001/09/07 12:19:46 espie Exp $	*/
d1595 1
a1595 1
	    freePtr = false;
@


1.10
log
@Repair regular expression substitution.
Even though the code can share some common parts, there is an important
difference I had missed.
@
text
@d2 1
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.9 2001/05/23 12:34:52 espie Exp $	*/
d48 1
a48 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.8 2001/05/07 22:59:33 espie Exp $	*/
d178 1
d1250 10
d1270 1
a1270 1
    pattern = get_patternarg(p, ctxt, err, endc);
d1341 1
a1341 1
get_patternarg(p, ctxt, err, endc)
d1346 1
d1367 1
a1367 1
	    &pattern->rightLen, pattern);
@


1.8
log
@some complex situations need those functions to be reentrant, hence no
static VarPatterns...

Old make could use dynamic variables because everything was jumbled
into one single function.
@
text
@d2 1
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.7 2001/05/03 13:41:13 espie Exp $	*/
d73 2
a74 1
#include    <ctype.h>
d76 1
a76 2
#include    <sys/types.h>
#include    <regex.h>
d78 6
a83 1
#include "make.h"
d85 1
d87 8
d122 1
a122 1
    Boolean	err;
d125 9
a133 9
static Boolean VarHead(struct Name *, Boolean, Buffer, void *);
static Boolean VarTail(struct Name *, Boolean, Buffer, void *);
static Boolean VarSuffix(struct Name *, Boolean, Buffer, void *);
static Boolean VarRoot(struct Name *, Boolean, Buffer, void *);
static Boolean VarMatch(struct Name *, Boolean, Buffer, void *);
static Boolean VarSYSVMatch(struct Name *, Boolean, Buffer, void *);
static Boolean VarNoMatch(struct Name *, Boolean, Buffer, void *);
static Boolean VarUniq(struct Name *, Boolean, Buffer, void *);
static Boolean VarLoop(struct Name *, Boolean, Buffer, void *);
d138 1
a138 1
static Boolean VarRESubstitute(struct Name *, Boolean, Buffer, void *);
d150 1
a150 1
static Boolean VarSubstitute(struct Name *, Boolean, Buffer, void *);
d154 1
a154 1
static char *VarModify(char *, Boolean (*)(struct Name *, Boolean, Buffer, void *), void *);
d156 1
a156 1
static void *check_empty(const char **, SymTable *, Boolean, int);
d159 1
a159 1
static void *check_shcmd(const char **, SymTable *, Boolean, int);
d171 4
a174 4
static void *assign_get_value(const char **, SymTable *, Boolean, int);
static void *get_cmd(const char **, SymTable *, Boolean, int);
static void *get_value(const char **, SymTable *, Boolean, int);
static void *get_stringarg(const char **, SymTable *, Boolean, int);
d176 2
a177 2
static void *get_patternarg(const char **, SymTable *, Boolean, int);
static void *get_spatternarg(const char **, SymTable *, Boolean, int);
d180 2
a181 2
static void *get_sysvpattern(const char **, SymTable *, Boolean, int);
static void *get_loop(const char **, SymTable *, Boolean, int);
d188 2
a189 2
	Boolean atstart;
	void * (*getarg)(const char **, SymTable *, Boolean, int);
d191 1
a191 1
	Boolean (*word_apply)(struct Name *, Boolean, Buffer, void *);
d194 3
a196 3
    match_mod = {FALSE, get_stringarg, NULL, VarMatch, free_stringarg},
    nomatch_mod = {FALSE, get_stringarg, NULL, VarNoMatch, free_stringarg},
    subst_mod = {FALSE, get_spatternarg, NULL, VarSubstitute, free_patternarg},
d198 1
a198 1
    resubst_mod = {FALSE, get_patternarg, do_regex, NULL, free_patternarg},
d200 18
a217 18
    quote_mod = {FALSE, check_empty, VarQuote, NULL , NULL},
    tail_mod = {FALSE, check_empty, NULL, VarTail, NULL},
    head_mod = {FALSE, check_empty, NULL, VarHead, NULL},
    suffix_mod = {FALSE, check_empty, NULL, VarSuffix, NULL},
    root_mod = {FALSE, check_empty, NULL, VarRoot, NULL},
    upper_mod = {FALSE, check_empty, do_upper, NULL, NULL},
    lower_mod = {FALSE, check_empty, do_lower, NULL, NULL},
    shcmd_mod = {FALSE, check_shcmd, do_shcmd, NULL, NULL},
    sysv_mod = {FALSE, get_sysvpattern, NULL, VarSYSVMatch, free_patternarg},
    uniq_mod = {FALSE, check_empty, NULL, VarUniq, NULL},
    sort_mod = {FALSE, check_empty, do_sort, NULL, NULL},
    loop_mod = {FALSE, get_loop, finish_loop, VarLoop, free_looparg},
    undef_mod = {TRUE, get_value, do_undef, NULL, NULL},
    def_mod = {TRUE, get_value, do_def, NULL, NULL},
    label_mod = {TRUE, check_empty, do_label, NULL, NULL},
    path_mod = {TRUE, check_empty, do_path, NULL, NULL},
    assign_mod = {TRUE, assign_get_value, do_assign, NULL, free_patternarg},
    exec_mod = {TRUE, get_cmd, do_exec, NULL, free_patternarg}
d268 1
a268 1
static Boolean
d271 1
a271 1
    Boolean	addSpace;
d277 1
a277 1
    slash = lastchar(word->s, word->e, '/');
d281 1
a281 1
	Buf_AddInterval(buf, word->s, slash);
d289 1
a289 1
    return TRUE;
d299 1
a299 1
static Boolean
d302 1
a302 1
    Boolean	addSpace;
d310 1
a310 1
    slash = lastchar(word->s, word->e, '/');
d312 1
a312 1
	Buf_AddInterval(buf, slash+1, word->e);
d314 2
a315 2
	Buf_AddInterval(buf, word->s, word->e);
    return TRUE;
d324 1
a324 1
static Boolean
d327 1
a327 1
    Boolean	addSpace;
d333 1
a333 1
    dot = lastchar(word->s, word->e, '.');
d337 2
a338 2
	Buf_AddInterval(buf, dot+1, word->e);
	addSpace = TRUE;
d350 1
a350 1
static Boolean
d353 1
a353 1
    Boolean	addSpace;
d361 1
a361 1
    dot = lastchar(word->s, word->e, '.');
d363 1
a363 1
	Buf_AddInterval(buf, word->s, dot);
d365 2
a366 2
	Buf_AddInterval(buf, word->s, word->e);
    return TRUE;
d375 1
a375 1
static Boolean
d378 1
a378 1
    Boolean	addSpace;
d382 3
a384 1
    if (Str_Match(word->s, (const char *)pattern)) {
d387 2
a388 2
	Buf_AddInterval(buf, word->s, word->e);
	return TRUE;
d399 1
a399 1
static Boolean
d402 1
a402 1
    Boolean	addSpace;
d406 3
a408 1
    if (!Str_Match(word->s, (const char *)pattern)) {
d411 2
a412 2
	Buf_AddInterval(buf, word->s, word->e);
	return TRUE;
d417 1
a417 1
static Boolean
d420 1
a420 1
    Boolean	addSpace;
d431 2
a432 2
	Buf_AddInterval(buf, word->s, word->e);
	addSpace = TRUE;
d439 1
a439 1
static Boolean
d442 1
a442 1
    Boolean	addSpace;
d451 1
a451 1
    return TRUE;
d525 1
a525 1
	Buf_AddInterval(&buf, t[0].s, t[0].e);
d528 1
a528 1
		Buf_AddInterval(&buf, t[j].s, t[j].e);
d544 1
a544 1
    return interval_dup(n->s, n->e);
d555 1
a555 1
    gn = Targ_FindNode(n->s, n->e, TARG_NOCREATE);
d557 1
a557 1
    	return interval_dup(n->s, n->e);
d602 1
a602 1
    	Var_Set_interval(n->s, n->e, v->lbuffer, VAR_GLOBAL);
d606 1
a606 1
	    Var_Set_interval(n->s, n->e, v->lbuffer, VAR_GLOBAL);
d610 1
a610 1
	    Var_Set_interval(n->s, n->e, v->lbuffer, VAR_GLOBAL);
d612 1
a612 1
	    Var_Append_interval(n->s, n->e, v->lbuffer, VAR_GLOBAL);
d617 1
a617 1
		Var_Set_interval(n->s, n->e, result, VAR_GLOBAL);
d650 1
a650 1
static Boolean
d653 1
a653 1
    Boolean	addSpace;
d667 2
a668 2
		Buf_AddInterval(buf, word->s, word->e);
	    return TRUE;
d677 1
a677 1
    Boolean		err	UNUSED;
d711 1
a711 1
    pattern->lbuffer = pattern->lhs = interval_dup(*p, cp);
d713 1
a713 1
    pattern->rhs = interval_dup(cp+1, cp2);
d728 1
a728 1
static Boolean
d731 1
a731 1
    Boolean	addSpace;
d755 1
a755 1
			    addSpace = TRUE;
d769 1
a769 1
			addSpace = TRUE;
d794 1
a794 1
		    addSpace = TRUE;
d796 1
a796 1
		Buf_AddInterval(buf, word->s, cp);
d811 1
a811 1
	     * addSpace is set to FALSE as soon as a space is added to the
d813 1
a813 1
	    Boolean done;
d816 1
a816 1
	    done = FALSE;
d823 1
a823 1
			addSpace = FALSE;
d825 1
a825 1
		    Buf_AddInterval(buf, word->s, cp);
d830 1
a830 1
			done = TRUE;
d833 1
a833 1
		    done = TRUE;
d851 1
a851 1
    return TRUE;
d884 1
a884 1
static Boolean
d887 1
a887 1
    Boolean		addSpace;
d1005 1
a1005 1
    Boolean	  (*modProc)(struct Name *, Boolean, Buffer, void *);
d1009 1
a1009 1
    Boolean	  addSpace;	/* TRUE if need to add a space to the
d1015 1
a1015 1
    addSpace = FALSE;
d1145 1
a1145 1
    Boolean	b		UNUSED;
d1160 1
a1160 1
    Boolean	b		UNUSED;
d1190 1
a1190 1
    Boolean	b		UNUSED;
d1203 1
a1203 1
    s = escape_dup(*p+1, cp, ":)}");
d1254 1
a1254 1
    Boolean	err;
d1298 1
a1298 1
    return escape_dup(start, p, "@@\\");
d1305 1
a1305 1
    Boolean	err;
d1333 1
a1333 1
    Boolean	err;
d1385 1
a1385 1
    Boolean	err;
d1416 1
a1416 1
    Boolean	err;
d1439 1
a1439 1
    Boolean	err;
d1506 2
a1507 2
    Boolean	err;
    Boolean	*freePtr;
d1513 1
a1513 1
    Boolean	atstart;    /* Some ODE modifiers only make sense at start */
d1536 1
a1536 1
    atstart = TRUE;
d1555 1
a1555 1
	atstart = FALSE;
d1573 1
a1573 1
		    *freePtr = TRUE;
d1575 1
a1575 1
		    *freePtr = FALSE;
d1587 1
a1587 1
	    freePtr = FALSE;
a1599 8
/*-
 *-----------------------------------------------------------------------
 * Var_GetHead --
 *	Find the leading components of a (list of) filename(s).
 *	XXX: VarHead does not replace foo by ., as (sun) System V make
 *	does.
 *-----------------------------------------------------------------------
 */
a1606 7
/*-
 *-----------------------------------------------------------------------
 * Var_GetTail --
 *	Return the tail from each of a list of words. Used to set the
 *	System V local variables.
 *-----------------------------------------------------------------------
 */
@


1.7
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d2 1
a2 1
/*	$OpenBSD: var.c,v 1.12 1999/09/28 21:57:04 espie Exp $	*/
d662 1
a662 1
    static VarPattern	pattern;
d692 6
a697 5
    pattern.lhs = interval_dup(*p, cp);
    pattern.leftLen = cp - *p;
    pattern.rhs = interval_dup(cp+1, cp2);
    pattern.rightLen = cp2 - (cp+1);
    pattern.flags = 0;
d699 1
a699 1
    return &pattern;
d1318 1
a1318 1
    static VarPattern	pattern;	/* just one for the whole system */
d1322 2
a1325 1
    pattern.flags = 0;
d1331 8
a1338 8
    pattern.rhs = NULL;
    pattern.lhs = VarGetPattern(ctxt, err, &s, delim, delim,
	&pattern.leftLen, NULL);
    pattern.lbuffer = pattern.lhs;
    if (pattern.lhs != NULL) {
	pattern.rhs = VarGetPattern(ctxt, err, &s, delim, delim,
	    &pattern.rightLen, &pattern);
	if (pattern.rhs != NULL) {
d1345 1
a1345 1
		    pattern.flags |= VAR_SUB_GLOBAL;
d1348 1
a1348 1
		    pattern.flags |= VAR_SUB_ONE;
d1355 1
a1355 1
		return &pattern;
d1359 1
a1359 1
    free_patternarg(&pattern);
d1401 1
a1401 1
    static VarPattern pattern;
d1404 1
d1406 3
a1408 3
    pattern.rhs = NULL;
    pattern.lbuffer = VarGetPattern(ctxt, err, &s, ':', endc,
    	&pattern.leftLen, NULL);
d1411 1
a1411 1
	return &pattern;
d1413 1
a1413 1
    free_patternarg(&pattern);
d1424 1
a1424 1
    static VarPattern pattern;
d1427 1
d1429 3
a1431 3
    pattern.rhs = NULL;
    pattern.lbuffer = VarGetPattern(ctxt, err, &s, '!', '!',
    	&pattern.leftLen, NULL);
d1434 1
a1434 1
	return &pattern;
d1436 1
a1436 1
    free_patternarg(&pattern);
d1445 1
d1448 1
@


1.6
log
@Clean-up, systematic use of UNUSED, white space...
@
text
@d1 2
a2 1
/*	$OpenBSD: varmodifiers.c,v 1.5 2000/09/14 13:35:38 espie Exp $	*/
d69 4
a72 2
/* VarModifiers_Apply is mostly a constituent function of Var_Parse.  */
 
d85 2
a86 2
#define VAR_SUB_MATCHED	0x04	/* There was a match */
#define VAR_MATCH_START	0x08	/* Match at start of word */
d89 6
d96 6
a101 5
    char    	  *lhs;	    /* String to match */
    size_t    	  leftLen;  /* Length of string */
    char    	  *rhs;	    /* Replacement string (w/ &'s removed) */
    size_t    	  rightLen; /* Length of replacement */
    int	    	  flags;
d104 18
d123 4
d129 1
a129 1
    int		  nsub;
d132 1
a132 1
    int		  flags;
d136 47
a182 9
static Boolean VarHead __P((const char *, Boolean, Buffer, void *));
static Boolean VarTail __P((const char *, Boolean, Buffer, void *));
static Boolean VarSuffix __P((const char *, Boolean, Buffer, void *));
static Boolean VarRoot __P((const char *, Boolean, Buffer, void *));
static Boolean VarMatch __P((const char *, Boolean, Buffer, void *));
#ifdef SYSVVARSUB
static Boolean VarSYSVMatch __P((const char *, Boolean, Buffer, void *));
#endif
static Boolean VarNoMatch __P((const char *, Boolean, Buffer, void *));
d184 1
a184 2
static void VarREError __P((int, regex_t *, const char *));
static Boolean VarRESubstitute __P((const char *, Boolean, Buffer, void *));
d186 19
a204 7
static Boolean VarSubstitute __P((const char *, Boolean, Buffer, void *));
static char *VarGetPattern __P((SymTable *, int, char **, int, int *, size_t *,
				VarPattern *));
static char *VarQuote __P((const char *));
static char *VarModify __P((char *, Boolean (*)(const char *, Boolean, Buffer, void *), void *));
static Boolean VarUppercase __P((const char *, Boolean, Buffer, void *));
static Boolean VarLowercase __P((const char *, Boolean, Buffer, void *));
d206 2
a207 21
/*-
 *-----------------------------------------------------------------------
 * VarUppercase --
 *	Place the Upper cased word in the given buffer.
 *
 * Results:
 *	TRUE if characters were added to the buffer (a space needs to be
 *	added to the buffer before the next word).
 *
 * Side Effects:
 *	The word is added to the buffer.
 *
 *-----------------------------------------------------------------------
 */
static Boolean
VarUppercase(word, addSpace, buf, dummy)
    const char	*word;    	/* Word to Upper Case */
    Boolean	addSpace; 	/* True if need to add a space to the buffer
				 * before sticking in the head */
    Buffer	buf;	    	/* Buffer in which to store it */
    void 	*dummy		UNUSED;
d209 32
a240 7
    size_t len = strlen(word);

    if (addSpace)
	Buf_AddSpace(buf);
    while (len--)
    	Buf_AddChar(buf, toupper(*word++));
    return TRUE;
d243 2
a244 13
/*-
 *-----------------------------------------------------------------------
 * VarLowercase --
 *	Place the Lower cased word in the given buffer.
 *
 * Results:
 *	TRUE if characters were added to the buffer (a space needs to be
 *	added to the buffer before the next word).
 *
 * Side Effects:
 *	The word is added to the buffer.
 *
 *-----------------------------------------------------------------------
a245 16
static Boolean
VarLowercase(word, addSpace, buf, dummy)
    const char	*word;    	/* Word to Lower Case */
    Boolean	addSpace; 	/* True if need to add a space to the buffer
				 * before sticking in the head */
    Buffer	buf;	    	/* Buffer in which to store it */
    void 	*dummy		UNUSED;
{
    size_t len = strlen(word);

    if (addSpace)
	Buf_AddSpace(buf);
    while (len--)
    	Buf_AddChar(buf, tolower(*word++));
    return TRUE;
}
d250 1
a250 1
 *	Remove the tail of the given word and place the result in the given
a251 8
 *
 * Results:
 *	TRUE if characters were added to the buffer (a space needs to be
 *	added to the buffer before the next word).
 *
 * Side Effects:
 *	The trimmed word is added to the buffer.
 *
d256 3
a258 4
    const char	*word;    	/* Word to trim */
    Boolean	addSpace; 	/* True if need to add a space to the buffer
				 * before sticking in the head */
    Buffer	buf;	    	/* Buffer in which to store it */
d263 1
a263 1
    slash = strrchr(word, '/');
d267 1
a267 2
	Buf_AddInterval(buf, word, slash);
	return TRUE;
d269 1
a269 1
	/* If no directory part, give . (q.v. the POSIX standard) */
d281 1
a281 1
 *	Remove the head of the given word and place the result in the given
a282 8
 *
 * Results:
 *	TRUE if characters were added to the buffer (a space needs to be
 *	added to the buffer before the next word).
 *
 * Side Effects:
 *	The trimmed word is added to the buffer.
 *
d287 3
a289 4
    const char	*word;    	/* Word to trim */
    Boolean	addSpace; 	/* TRUE if need to stick a space in the
				 * buffer before adding the tail */
    Buffer	buf;	    	/* Buffer in which to store it */
d294 1
a294 1
    if (addSpace) 
d296 1
a296 1
    slash = strrchr(word, '/');
d298 1
a298 1
	Buf_AddString(buf, slash+1);
d300 1
a300 1
	Buf_AddString(buf, word);
d307 1
a307 9
 *	Place the suffix of the given word in the given buffer.
 *
 * Results:
 *	TRUE if characters were added to the buffer (a space needs to be
 *	added to the buffer before the next word).
 *
 * Side Effects:
 *	The suffix from the word is placed in the buffer.
 *
d312 3
a314 4
    const char	*word;    	/* Word to trim */
    Boolean	addSpace; 	/* TRUE if need to add a space before placing
				 * the suffix in the buffer */
    Buffer	buf;	    	/* Buffer in which to store it */
d319 1
a319 1
    dot = strrchr(word, '.');
d323 1
a323 1
	Buf_AddString(buf, dot+1);
d332 1
a332 1
 *	Remove the suffix of the given word and place the result in the
a333 8
 *
 * Results:
 *	TRUE if characters were added to the buffer (a space needs to be
 *	added to the buffer before the next word).
 *
 * Side Effects:
 *	The trimmed word is added to the buffer.
 *
d338 3
a340 4
    const char	*word;    	/* Word to trim */
    Boolean	addSpace; 	/* TRUE if need to add a space to the buffer
				 * before placing the root in it */
    Buffer	buf;	    	/* Buffer in which to store it */
d347 1
a347 2

    dot = strrchr(word, '.');
d349 1
a349 1
	Buf_AddInterval(buf, word, dot);
d351 1
a351 1
	Buf_AddString(buf, word);
d358 1
a358 10
 *	Place the word in the buffer if it matches the given pattern.
 *	Callback function for VarModify to implement the :M modifier.
 *
 * Results:
 *	TRUE if a space should be placed in the buffer before the next
 *	word.
 *
 * Side Effects:
 *	The word may be copied to the buffer.
 *
d363 42
a404 6
    const char    *word;    	/* Word to examine */
    Boolean 	  addSpace; 	/* TRUE if need to add a space to the
				 * buffer before adding the word, if it
				 * matches */
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *pattern; 	/* Pattern the word must match */
d406 5
a410 1
    if (Str_Match(word, (char *) pattern)) {
d413 1
a414 1
	Buf_AddString(buf, word);
d416 2
d421 204
a624 1
#ifdef SYSVVARSUB
d628 2
a629 11
 *	Place the word in the buffer if it matches the given pattern.
 *	Callback function for VarModify to implement the System V %
 *	modifiers.
 *
 * Results:
 *	TRUE if a space should be placed in the buffer before the next
 *	word.
 *
 * Side Effects:
 *	The word may be copied to the buffer.
 *
d634 8
a641 10
    const char    *word;    	/* Word to examine */
    Boolean 	  addSpace; 	/* TRUE if need to add a space to the
				 * buffer before adding the word, if it
				 * matches */
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *patp; 	/* Pattern the word must match */
{
    size_t 	  len;
    const char    *ptr;
    VarPattern 	  *pat = (VarPattern *) patp;
d643 1
a643 1
    if (*word) {
d646 1
a646 4

	    addSpace = TRUE;

	    if ((ptr = Str_SYSVMatch(word, pat->lhs, &len)) != NULL)
d649 4
a652 3
		Buf_AddString(buf, word);
    }
    return addSpace;
a653 1
#endif
d655 6
a660 23
/*-
 *-----------------------------------------------------------------------
 * VarNoMatch --
 *	Place the word in the buffer if it doesn't match the given pattern.
 *	Callback function for VarModify to implement the :N modifier.
 *
 * Results:
 *	TRUE if a space should be placed in the buffer before the next
 *	word.
 *
 * Side Effects:
 *	The word may be copied to the buffer.
 *
 *-----------------------------------------------------------------------
 */
static Boolean
VarNoMatch(word, addSpace, buf, pattern)
    const char    *word;    	/* Word to examine */
    Boolean 	  addSpace; 	/* TRUE if need to add a space to the
				 * buffer before adding the word, if it
				 * matches */
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *pattern; 	/* Pattern the word must match */
d662 28
a689 5
    if (!Str_Match(word, (char *) pattern)) {
	if (addSpace)
	    Buf_AddSpace(buf);
	addSpace = TRUE;
	Buf_AddString(buf, word);
d691 8
a698 1
    return(addSpace);
d705 2
a706 9
 *	Perform a string-substitution on the given word, placing the
 *	result in the passed buffer.
 *
 * Results:
 *	TRUE if a space is needed before more characters are added.
 *
 * Side Effects:
 *	None.
 *
d711 8
a718 9
    const char 	  	*word;	    /* Word to modify */
    Boolean 	  	addSpace;   /* True if space should be added before
				     * other characters */
    Buffer  	  	buf;	    /* Buffer for result */
    void 		*patternp;  /* Pattern for substitution */
{
    size_t  		wordLen;    /* Length of word */
    const char 	*cp;	    	    /* General pointer */
    VarPattern	*pattern = (VarPattern *) patternp;
d720 1
a720 1
    wordLen = strlen(word);
d723 2
a724 4
	/*
	 * Still substituting -- break it down into simple anchored cases
	 * and if none of them fits, perform the general substitution case.
	 */
d726 2
a727 4
	    (strncmp(word, pattern->lhs, pattern->leftLen) == 0)) {
		/*
		 * Anchored at start and beginning of word matches pattern
		 */
d730 1
a730 2
			/*
			 * Also anchored at end and matches to the end (word
d732 1
a732 2
			 * if rhs is non-null.
			 */
d737 2
a738 1
			    Buf_AddChars(buf, pattern->rightLen, pattern->rhs);
d742 1
a742 3
		    /*
		     * Doesn't match to end -- copy word wholesale
		     */
d745 2
a746 3
		    /*
		     * Matches at start but need to copy in trailing characters
		     */
d754 1
a754 1
				 word + pattern->leftLen);
d758 1
a758 3
	    /*
	     * Had to match at start of word and didn't -- copy whole word.
	     */
d761 1
a761 2
	    /*
	     * Anchored at end, Find only place match could occur (leftLen
d764 5
a768 7
	     * to use strncmp.
	     */
	    cp = word + (wordLen - pattern->leftLen);
	    if ((cp >= word) &&
		(strncmp(cp, pattern->lhs, pattern->leftLen) == 0)) {
		/*
		 * Match found. If we will place characters in the buffer,
d771 2
a772 3
		 * by the right-hand-side.
		 */
		if (((cp - word) + pattern->rightLen) != 0) {
d777 1
a777 1
		Buf_AddInterval(buf, word, cp);
d781 1
a781 3
		/*
		 * Had to match at end and didn't. Copy entire word.
		 */
d785 2
a786 3
	    /*
	     * Pattern is unanchored: search for the pattern in the word using
	     * String_FindSubstring, copying unmatched portions and the
d792 3
a794 4
	     * addSpace is set FALSE as soon as a space is added to the
	     * buffer.
	     */
	    register Boolean done;
d800 3
a802 3
		cp = strstr(word, pattern->lhs);
		if (cp != (char *)NULL) {
		    if (addSpace && (((cp - word) + pattern->rightLen) != 0)){
d806 1
a806 1
		    Buf_AddInterval(buf, word, cp);
d808 3
a810 3
		    wordLen -= (cp - word) + pattern->leftLen;
		    word = cp + pattern->leftLen;
		    if (wordLen == 0 || (pattern->flags & VAR_SUB_GLOBAL) == 0){
a811 1
		    }
d813 1
a813 1
		} else {
a814 1
		}
d819 1
a819 1
		Buf_AddChars(buf, wordLen, word);
d821 1
a821 2
	    /*
	     * If added characters to the buffer, need to add a space
d823 2
a824 3
	     * the previous value of addSpace.
	     */
	    return (Buf_Size(buf) != origSize || addSpace);
d826 1
a826 1
	return (addSpace);
d831 2
a832 2
    Buf_AddChars(buf, wordLen, word);
    return(TRUE);
a834 1

a839 7
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	An error gets printed.
 *
d844 3
a846 3
    int err;
    regex_t *pat;
    const char *str;
d848 2
a849 2
    char *errbuf;
    int errlen;
a862 7
 *
 * Results:
 *	TRUE if a space is needed before more characters are added.
 *
 * Side Effects:
 *	None.
 *
d867 10
a876 10
    const char *word;
    Boolean addSpace;
    Buffer buf;
    void *patternp;
{
    VarREPattern *pat;
    int xrv;
    const char *wp;
    char *rp;
    int added;
d879 1
a879 1
	if (addSpace && !added)		\
d884 1
a884 1
    wp = word;
d904 1
a904 1
	    if ((*rp == '\\') && ((rp[1] == '&') || (rp[1] == '\\'))) {
d906 1
a906 1
		Buf_AddChar(buf, rp[1]);
d909 1
a909 1
	    else if ((*rp == '&') || ((*rp == '\\') && isdigit(rp[1]))) {
d931 2
a932 2
		} else if ((pat->matches[n].rm_so == -1) &&
			   (pat->matches[n].rm_eo == -1)) {
d936 1
a936 1
	        } else {
d955 1
a955 1
	    Buf_AddChars(buf, strlen(wp), wp);
d964 1
a964 1
	    Buf_AddChars(buf, strlen(wp), wp);
d968 1
a968 1
    return(addSpace||added);
a979 1
 *
d984 4
a987 4
    char    	  *str;	    	/* String whose words should be trimmed */
			    	/* Function to use to modify them */
    Boolean    	  (*modProc) __P((const char *, Boolean, Buffer, void *));
    void          *datum;	/* Datum to pass it */
d989 2
a990 2
    BUFFER  	  buf;		/* Buffer for the new string */
    Boolean 	  addSpace;	/* TRUE if need to add a space to the
d993 1
a993 5
    char 	  *end;
    char	  *word;

    if (str == NULL)
    	return NULL;
d998 1
a998 1
    end = str;
d1000 2
a1001 2
    while ((word = iterate_words(&end)) != NULL) {
	char	  termc;
d1003 4
a1006 4
	termc = *end;
	*end = '\0';
	addSpace = (*modProc)(word, addSpace, &buf, datum);
	*end = termc;
a1024 5
 *	If flags is specified and the last character of the pattern is a
 *	$ set the VAR_MATCH_END bit of flags.
 *
 * Side Effects:
 *	None.
d1028 8
a1035 8
VarGetPattern(ctxt, err, tstr, delim, flags, length, pattern)
    SymTable *ctxt;
    int err;
    char **tstr;
    int delim;
    int *flags;
    size_t *length;
    VarPattern *pattern;
d1037 4
a1040 3
    char *cp;
    BUFFER buf;
    size_t junk;
d1046 3
a1048 3
#define IS_A_MATCH(cp, delim) \
    ((cp[0] == '\\') && ((cp[1] == delim) ||  \
     (cp[1] == '\\') || (cp[1] == '$') || (pattern && (cp[1] == '&'))))
d1056 2
a1057 2
    for (cp = *tstr; *cp && (*cp != delim); cp++) {
	if (IS_A_MATCH(cp, delim)) {
d1061 3
a1063 10
	    if (cp[1] == delim) {
		if (flags == NULL)
		    Buf_AddChar(&buf, *cp);
		else
		    /*
		     * Unescaped $ at end of pattern => anchor
		     * pattern at end.
		     */
		    *flags |= VAR_MATCH_END;
	    }
d1065 5
a1069 13
		char   *cp2;
		size_t     len;
		Boolean freeIt;

		/*
		 * If unescaped dollar sign not before the
		 * delimiter, assume it's a variable
		 * substitution and recurse.
		 */
		cp2 = Var_Parse(cp, ctxt, err, &len, &freeIt);
		Buf_AddString(&buf, cp2);
		if (freeIt)
		    free(cp2);
d1072 1
a1072 2
	}
	else if (pattern && *cp == '&')
d1078 4
a1081 1
    if (*cp != delim) {
d1084 1
d1089 94
a1182 2
	*length = Buf_Size(&buf);
	return Buf_Retrieve(&buf);
d1184 44
d1230 4
a1233 3
char *
VarModifiers_Apply(str, ctxt, err, freePtr, start, endc, lengthPtr)
    char 	*str;
d1236 22
a1257 4
    Boolean	*freePtr;
    char	*start;
    char 	endc;
    size_t	*lengthPtr;
d1259 1
a1259 3
    char 	*tstr; 
    char	delim;
    char	*cp;
d1261 3
a1263 1
    tstr = start;
d1265 5
a1269 22
    /*
     * Now we need to apply any modifiers the user wants applied.
     * These are:
     *  	  :M<pattern>	words which match the given <pattern>.
     *  	  	    	<pattern> is of the standard file
     *  	  	    	wildcarding form.
     *  	  :S<d><pat1><d><pat2><d>[g]
     *  	  	    	Substitute <pat2> for <pat1> in the value
     *  	  :C<d><pat1><d><pat2><d>[g]
     *  	  	    	Substitute <pat2> for regex <pat1> in the value
     *  	  :H	    	Substitute the head of each word
     *  	  :T	    	Substitute the tail of each word
     *  	  :E	    	Substitute the extension (minus '.') of
     *  	  	    	each word
     *  	  :R	    	Substitute the root of each word
     *  	  	    	(pathname minus the suffix).
     *	    	  :lhs=rhs  	Like :S, but the rhs goes to the end of
     *	    	    	    	the invocation.
     */
    while (*tstr != endc) {
	char	*newStr;    /* New value to return */
	char	termc;	    /* Character which terminated scan */
d1271 20
a1290 35
	if (DEBUG(VAR))
	    printf("Applying :%c to \"%s\"\n", *tstr, str ? str : "");
	switch (*tstr) {
	    case 'N':
	    case 'M':
	    {
		for (cp = tstr + 1;
		     *cp != '\0' && *cp != ':' && *cp != endc;
		     cp++) {
		    if (*cp == '\\' && (cp[1] == ':' || cp[1] == endc)){
			cp++;
		    }
		}
		termc = *cp;
		*cp = '\0';
		if (*tstr == 'M')
		    newStr = VarModify(str, VarMatch, tstr+1);
		else
		    newStr = VarModify(str, VarNoMatch, tstr+1);
		break;
	    }
	    case 'S':
	    {
		VarPattern 	    pattern;

		pattern.flags = 0;
		delim = tstr[1];
		tstr += 2;

		/* If pattern begins with '^', it is anchored to the
		 * start of the word -- skip over it and flag pattern.  */
		if (*tstr == '^') {
		    pattern.flags |= VAR_MATCH_START;
		    tstr++;
		}
d1292 1
a1292 23
		cp = tstr;
		if ((pattern.lhs = VarGetPattern(ctxt, err, &cp, delim,
		    &pattern.flags, &pattern.leftLen, NULL)) == NULL)
		    goto cleanup;

		if ((pattern.rhs = VarGetPattern(ctxt, err, &cp, delim,
		    NULL, &pattern.rightLen, &pattern)) == NULL)
		    goto cleanup;

		/* Check for global substitution. If 'g' after the final
		 * delimiter, substitution is global and is marked that
		 * way.  */
		for (;; cp++) {
		    switch (*cp) {
		    case 'g':
			pattern.flags |= VAR_SUB_GLOBAL;
			continue;
		    case '1':
			pattern.flags |= VAR_SUB_ONE;
			continue;
		    }
		    break;
		}
d1294 15
a1308 2
		termc = *cp;
		newStr = VarModify(str, VarSubstitute, &pattern);
d1310 10
a1319 27
		/* Free the two strings.  */
		free(pattern.lhs);
		free(pattern.rhs);
		break;
	    }
#ifndef MAKE_BOOTSTRAP
	    case 'C':
	    {
		VarREPattern    pattern;
		char           *re;
		int             error;

		pattern.flags = 0;
		delim = tstr[1];
		tstr += 2;

		cp = tstr;

		if ((re = VarGetPattern(ctxt, err, &cp, delim, NULL,
		    NULL, NULL)) == NULL)
		    goto cleanup;

		if ((pattern.replace = VarGetPattern(ctxt, err, &cp,
		    delim, NULL, NULL, NULL)) == NULL) {
		    free(re);
		    goto cleanup;
		}
d1321 1
a1321 11
		for (;; cp++) {
		    switch (*cp) {
		    case 'g':
			pattern.flags |= VAR_SUB_GLOBAL;
			continue;
		    case '1':
			pattern.flags |= VAR_SUB_ONE;
			continue;
		    }
		    break;
		}
d1323 5
a1327 1
		termc = *cp;
d1329 19
a1347 7
		error = regcomp(&pattern.re, re, REG_EXTENDED);
		free(re);
		if (error) {
		    *lengthPtr = cp - start + 1;
		    VarREError(error, &pattern.re, "RE substitution error");
		    free(pattern.replace);
		    return var_Error;
a1348 12

		pattern.nsub = pattern.re.re_nsub + 1;
		if (pattern.nsub < 1)
		    pattern.nsub = 1;
		if (pattern.nsub > 10)
		    pattern.nsub = 10;
		pattern.matches = emalloc(pattern.nsub *
					  sizeof(regmatch_t));
		newStr = VarModify(str, VarRESubstitute, &pattern);
		regfree(&pattern.re);
		free(pattern.replace);
		free(pattern.matches);
d1351 32
a1382 80
#endif
	    case 'Q':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarQuote(str);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/* FALLTHROUGH */
	    case 'T':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarModify(str, VarTail, NULL);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/* FALLTHROUGH */
	    case 'H':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarModify(str, VarHead, NULL);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/* FALLTHROUGH */
	    case 'E':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarModify(str, VarSuffix, NULL);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/* FALLTHROUGH */
	    case 'R':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarModify(str, VarRoot, NULL);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/* FALLTHROUGH */
	    case 'U':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarModify(str, VarUppercase, NULL);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/* FALLTHROUGH */
	    case 'L':
		if (tstr[1] == endc || tstr[1] == ':') {
		    newStr = VarModify(str, VarLowercase, NULL);
		    cp = tstr + 1;
		    termc = *cp;
		    break;
		}
		/* FALLTHROUGH */
#ifdef SUNSHCMD
	    case 's':
		if (tstr[1] == 'h' && (tstr[2] == endc || tstr[2] == ':')) {
		    char *err = 0;
		    newStr = str ? Cmd_Exec(str, &err) : NULL;
		    if (err)
			Error(err, str);
		    cp = tstr + 2;
		    termc = *cp;
		    break;
		}
		/* FALLTHROUGH */
#endif
	    default:
	    {
#ifdef SYSVVARSUB
		/* This can either be a bogus modifier or a System-V
		 * substitution command.  */
		VarPattern      pattern;
		Boolean         eqFound;
		int           	cnt;	/* Used to count brace pairs when 
					 * variable in in parens or braces */
		char		startc;
d1384 7
a1390 4
		if (endc == ')') 
		    startc = '(';
		else
		    startc = '{';
d1392 9
a1400 20
		pattern.flags = 0;
		eqFound = FALSE;
		/* First we make a pass through the string trying
		 * to verify it is a SYSV-make-style translation:
		 * it must be: <string1>=<string2>) */
		cp = tstr;
		cnt = 1;
		while (*cp != '\0' && cnt) {
		    if (*cp == '=') {
			eqFound = TRUE;
			/* continue looking for endc */
		    }
		    else if (*cp == endc)
			cnt--;
		    else if (*cp == startc)
			cnt++;
		    if (cnt)
			cp++;
		}
		if (*cp == endc && eqFound) {
d1402 11
a1412 20
		    /* Now we break this sucker into the lhs and
		     * rhs. We must null terminate them of course.  */
		    for (cp = tstr; *cp != '='; cp++)
			continue;
		    pattern.lhs = tstr;
		    pattern.leftLen = cp - tstr;
		    *cp++ = '\0';

		    pattern.rhs = cp;
		    cnt = 1;
		    while (cnt) {
			if (*cp == endc)
			    cnt--;
			else if (*cp == startc)
			    cnt++;
			if (cnt)
			    cp++;
		    }
		    pattern.rightLen = cp - pattern.rhs;
		    *cp = '\0';
d1414 9
a1422 22
		    /* SYSV modifications happen through the whole
		     * string. Note the pattern is anchored at the end.  */
		    newStr = VarModify(str, VarSYSVMatch, &pattern);

		    /* Restore the nulled characters */
		    pattern.lhs[pattern.leftLen] = '=';
		    pattern.rhs[pattern.rightLen] = endc;
		    termc = endc;
		} else
#endif
		{
		    Error ("Unknown modifier '%c'\n", *tstr);
		    for (cp = tstr+1;
			 *cp != ':' && *cp != endc && *cp != '\0';)
			 cp++;
		    termc = *cp;
		    newStr = var_Error;
		}
	    }
	}
	if (DEBUG(VAR))
	    printf("Result is \"%s\"\n", newStr != NULL ? newStr : "");
d1424 7
a1430 14
	if (*freePtr)
	    free(str);
	str = newStr;
	if (str != var_Error && str != NULL)
	    *freePtr = TRUE;
	else
	    *freePtr = FALSE;
	if (termc == '\0')
	    Error("Unclosed variable specification");
	else if (termc == ':')
	    *cp++ = termc;
	else
	    *cp = termc;
	tstr = cp;
d1432 3
a1434 2
    *lengthPtr += tstr - start+1;
    return str;
d1436 7
a1442 6
cleanup:
    *lengthPtr += cp - start +1;
    if (*freePtr)
	free(str);
    Error("Unclosed substitution for (%c missing)", delim);
    return var_Error;
d1445 1
a1445 10
/*-
 *-----------------------------------------------------------------------
 * VarQuote --
 *	Quote shell meta-characters in the string
 *
 * Results:
 *	The quoted string
 *
 *-----------------------------------------------------------------------
 */
d1447 40
a1486 2
VarQuote(str)
	const char *str;
d1488 2
d1491 30
a1520 3
    BUFFER  	  buf;
    /* This should cover most shells :-( */
    static char meta[] = "\n \t'`\";&<>()|*?{}[]\\$!#^~";
d1522 2
a1523 2
    if (str == NULL)
    	return NULL;
d1525 43
a1567 5
    Buf_Init(&buf, MAKE_BSIZE);
    for (; *str; str++) {
	if (strchr(meta, *str) != NULL)
	    Buf_AddChar(&buf, '\\');
	Buf_AddChar(&buf, *str);
d1569 5
a1573 1
    return Buf_Retrieve(&buf);
d1575 1
a1581 7
 *
 * Results:
 *	The leading components.
 *
 * Side Effects:
 *	None.
 *
d1585 2
a1586 2
Var_GetHead(file)
    char    	*file;	    /* Filename to manipulate */
d1588 1
a1588 1
    return VarModify(file, VarHead, NULL);
a1595 7
 *
 * Results:
 *	The resulting string.
 *
 * Side Effects:
 *	None.
 *
d1599 2
a1600 2
Var_GetTail(file)
    char    	*file;	    /* Filename to modify */
d1602 1
a1602 1
    return VarModify(file, VarTail, NULL);
a1603 1

@


1.5
log
@Two new functions:

iterate_words: light-weight equivalent to brk_string,
which does not need to copy the string, and does not do \ interpretation
which are only needed for the string.

escape_dup: handles escape sequence in a systematic way.

This speeds up variable modifiers.

This also makes .for loops more consistent, as they use the same definition
of `a word' as the rest of make.
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.4 2000/07/24 21:57:28 espie Exp $	*/
d141 2
a142 2
    const char    *word;    	/* Word to Upper Case */
    Boolean 	  addSpace; 	/* True if need to add a space to the buffer
d144 2
a145 2
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void *dummy;
d172 2
a173 2
    const char    *word;    	/* Word to Lower Case */
    Boolean 	  addSpace; 	/* True if need to add a space to the buffer
d175 2
a176 2
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void *dummy;
d204 2
a205 2
    const char    *word;    	/* Word to trim */
    Boolean 	  addSpace; 	/* True if need to add a space to the buffer
d207 2
a208 2
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *dummy;
d210 1
a210 1
    const char 	  *slash;
d225 1
a225 1
    return(dummy ? TRUE : TRUE);
d245 2
a246 2
    const char    *word;    	/* Word to trim */
    Boolean 	  addSpace; 	/* TRUE if need to stick a space in the
d248 2
a249 2
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *dummy;
d251 1
a251 1
    const char *slash;
d260 1
a260 1
    return (dummy ? TRUE : TRUE);
d279 2
a280 2
    const char    *word;    	/* Word to trim */
    Boolean 	  addSpace; 	/* TRUE if need to add a space before placing
d282 2
a283 2
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *dummy;
d285 1
a285 1
    const char *dot;
d294 1
a294 1
    return (dummy ? addSpace : addSpace);
d314 2
a315 2
    const char 	  *word;    	/* Word to trim */
    Boolean 	  addSpace; 	/* TRUE if need to add a space to the buffer
d317 2
a318 2
    Buffer  	  buf;	    	/* Buffer in which to store it */
    void 	  *dummy;
d320 1
a320 1
    const char *dot;
d330 1
a330 1
    return (dummy ? TRUE : TRUE);
@


1.4
log
@Oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.3 2000/07/17 23:54:26 espie Exp $	*/
d121 1
a121 1
static char *VarModify __P((const char *, Boolean (*)(const char *, Boolean, Buffer, void *), void *));
d772 3
a774 3
VarModify (str, modProc, datum)
    const char    	  *str;	    /* String whose words should be trimmed */
				    /* Function to use to modify them */
d776 1
a776 1
    void          *datum;    	    /* Datum to pass it */
d778 6
a783 7
    BUFFER  	  buf;	    	    /* Buffer for the new string */
    Boolean 	  addSpace; 	    /* TRUE if need to add a space to the
				     * buffer before adding the trimmed
				     * word */
    char 	  **av;		    /* word list */
    char 	  *as;		    /* word list memory */
    int ac, i;
d791 1
a791 1
    av = brk_string(str, &ac, FALSE, &as);
d793 2
a794 2
    for (i = 0; i < ac; i++)
	addSpace = (*modProc)(av[i], addSpace, &buf, datum);
d796 5
a800 2
    free(as);
    free(av);
@


1.3
log
@FALLTHRU -> FALLTHROUGH, requested by miod@@ and style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.2 2000/07/17 23:26:51 espie Exp $	*/
d1127 1
a1127 1
		    char *err;
@


1.2
log
@- let VarModifiers_Apply accept NULL string gracefully,
- simplify Var_Parse: use varfind, then leverage on the result
to recognize `special case' dynamic parsing.

VarModifiers_Apply need to be called on NULL strings, to be able to parse
modifiers applied to non-existent variables.

(Alternately, we could call VarModifiers_Apply on a dummy string, but
this is less efficient).
@
text
@d1 1
a1 1
/*	$OpenBSD: varmodifiers.c,v 1.1 2000/07/17 23:09:06 espie Exp $	*/
d1075 1
a1075 1
		/*FALLTHRU*/
d1083 1
a1083 1
		/*FALLTHRU*/
d1091 1
a1091 1
		/*FALLTHRU*/
d1099 1
a1099 1
		/*FALLTHRU*/
d1107 1
a1107 1
		/*FALLTHRU*/
d1115 1
a1115 1
		/*FALLTHRU*/
d1123 1
a1123 1
		/*FALLTHRU*/
d1135 1
a1135 1
		/*FALLTHRU*/
@


1.1
log
@Major unobfuscation: split var modifiers handling to a separate file.
This does finally make var handling somewhat readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: var.c,v 1.12 1999/09/28 21:57:04 espie Exp $	*/
d786 3
d941 1
a941 1
	    printf("Applying :%c to \"%s\"\n", *tstr, str);
d1128 1
a1128 1
		    newStr = Cmd_Exec(str, &err);
d1216 1
a1216 1
	    printf("Result is \"%s\"\n", newStr);
d1221 1
a1221 1
	if (str != var_Error)
d1262 3
@

