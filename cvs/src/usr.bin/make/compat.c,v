head	1.86;
access;
symbols
	OPENBSD_6_1:1.86.0.2
	OPENBSD_6_1_BASE:1.86
	OPENBSD_6_0:1.85.0.8
	OPENBSD_6_0_BASE:1.85
	OPENBSD_5_9:1.85.0.4
	OPENBSD_5_9_BASE:1.85
	OPENBSD_5_8:1.85.0.6
	OPENBSD_5_8_BASE:1.85
	OPENBSD_5_7:1.85.0.2
	OPENBSD_5_7_BASE:1.85
	OPENBSD_5_6:1.83.0.8
	OPENBSD_5_6_BASE:1.83
	OPENBSD_5_5:1.83.0.6
	OPENBSD_5_5_BASE:1.83
	OPENBSD_5_4:1.83.0.2
	OPENBSD_5_4_BASE:1.83
	OPENBSD_5_3:1.78.0.2
	OPENBSD_5_3_BASE:1.78
	OPENBSD_5_2:1.76.0.2
	OPENBSD_5_2_BASE:1.76
	OPENBSD_5_1_BASE:1.75
	OPENBSD_5_1:1.75.0.6
	OPENBSD_5_0:1.75.0.4
	OPENBSD_5_0_BASE:1.75
	OPENBSD_4_9:1.75.0.2
	OPENBSD_4_9_BASE:1.75
	OPENBSD_4_8:1.74.0.2
	OPENBSD_4_8_BASE:1.74
	OPENBSD_4_7:1.72.0.2
	OPENBSD_4_7_BASE:1.72
	OPENBSD_4_6:1.71.0.4
	OPENBSD_4_6_BASE:1.71
	OPENBSD_4_5:1.70.0.2
	OPENBSD_4_5_BASE:1.70
	OPENBSD_4_4:1.69.0.4
	OPENBSD_4_4_BASE:1.69
	OPENBSD_4_3:1.69.0.2
	OPENBSD_4_3_BASE:1.69
	OPENBSD_4_2:1.53.0.2
	OPENBSD_4_2_BASE:1.53
	OPENBSD_4_1:1.51.0.2
	OPENBSD_4_1_BASE:1.51
	OPENBSD_4_0:1.50.0.10
	OPENBSD_4_0_BASE:1.50
	OPENBSD_3_9:1.50.0.8
	OPENBSD_3_9_BASE:1.50
	OPENBSD_3_8:1.50.0.6
	OPENBSD_3_8_BASE:1.50
	OPENBSD_3_7:1.50.0.4
	OPENBSD_3_7_BASE:1.50
	OPENBSD_3_6:1.50.0.2
	OPENBSD_3_6_BASE:1.50
	OPENBSD_3_5:1.49.0.4
	OPENBSD_3_5_BASE:1.49
	OPENBSD_3_4:1.49.0.2
	OPENBSD_3_4_BASE:1.49
	OPENBSD_3_3:1.48.0.4
	OPENBSD_3_3_BASE:1.48
	OPENBSD_3_2:1.48.0.2
	OPENBSD_3_2_BASE:1.48
	OPENBSD_3_1:1.46.0.2
	OPENBSD_3_1_BASE:1.46
	OPENBSD_3_0:1.40.0.2
	OPENBSD_3_0_BASE:1.40
	OPENBSD_2_9_BASE:1.35
	OPENBSD_2_9:1.35.0.4
	OPENBSD_2_8:1.35.0.2
	OPENBSD_2_8_BASE:1.35
	OPENBSD_2_7:1.24.0.2
	OPENBSD_2_7_BASE:1.24
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.86
date	2016.10.21.16.12.38;	author espie;	state Exp;
branches;
next	1.85;
commitid	aLVdeKrJ0t5upS3l;

1.85
date	2015.01.23.13.38.16;	author espie;	state Exp;
branches;
next	1.84;
commitid	ppprYXC9RNGuUXGK;

1.84
date	2015.01.23.13.18.40;	author espie;	state Exp;
branches;
next	1.83;
commitid	iXa5WmoY9RgeqDsn;

1.83
date	2013.06.20.19.48.32;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2013.05.30.08.58.38;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2013.05.25.11.54.14;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2013.05.22.12.14.08;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2013.04.23.14.32.53;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2012.11.24.11.03.45;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2012.03.22.13.47.12;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2010.11.02.19.47.22;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2010.07.19.19.46.43;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2010.04.25.13.59.53;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2009.08.16.09.53.43;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2009.05.10.11.07.37;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2008.11.04.07.22.35;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2008.01.29.22.23.10;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2007.11.10.13.59.48;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2007.11.10.12.51.40;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.06.21.12.23;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2007.11.03.14.05.39;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2007.11.03.11.42.41;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2007.11.02.17.27.24;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2007.10.27.08.44.12;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2007.10.14.09.02.10;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2007.09.17.12.42.09;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2007.09.17.08.36.57;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2007.09.16.14.18.40;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2007.09.16.12.09.36;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.16.10.39.07;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.16.09.46.14;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2007.07.30.09.51.53;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2007.07.30.09.49.00;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2007.01.04.17.55.35;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2004.04.07.13.11.35;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2002.07.31.19.29.20;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.12.06.07.15;	author mpech;	state Exp;
branches;
next	1.46;

1.46
date	2002.01.16.01.28.54;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2001.12.02.00.13.16;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.23.23.42.45;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.22.23.56.43;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2001.11.22.21.18.10;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2001.11.17.19.37.53;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.15.18.43.41;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.29.12.53.39;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.29.12.17.05;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.23.12.34.40;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.03.13.41.02;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.14.13.52.41;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.14.13.46.44;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.14.13.32.06;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.30.23.26.25;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.23.16.21.43;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.23.16.20.01;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.23.16.18.08;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.17.14.38.14;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.10.01.41.05;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.10.01.32.22;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.10.01.26.36;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.17.23.54.47;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.26.16.21.32;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.02.13.47.47;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.01.03.23.32;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.12.18.21.58.07;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	99.12.18.21.56.07;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	99.12.18.21.53.32;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	99.12.16.17.31.51;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	99.12.16.17.27.18;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	99.12.06.22.28.44;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	99.11.14.18.16.22;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	99.11.10.14.11.49;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	98.12.05.00.06.27;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	98.05.13.06.54.58;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.05.12.07.10.01;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.01.02.05.56.33;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.04.28.01.52.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.04.21.08.37.49;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.04.20.22.28.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.04.01.07.28.09;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.11.30.21.08.51;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.36.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.23.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.86
log
@small obvious cleanups:
- remove a lot of unnecessary casts
- zap extra param that's no longer needed
- add proper prototype and make function static

okay natano@@
@
text
@/*	$OpenBSD: compat.c,v 1.85 2015/01/23 13:38:16 espie Exp $	*/
/*	$NetBSD: compat.c,v 1.14 1996/11/06 17:59:01 christos Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <limits.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include "config.h"
#include "defines.h"
#include "dir.h"
#include "engine.h"
#include "job.h"
#include "compat.h"
#include "suff.h"
#include "var.h"
#include "targ.h"
#include "targequiv.h"
#include "error.h"
#include "extern.h"
#include "gnode.h"
#include "timestamp.h"
#include "lst.h"

static void CompatMake(void *, void *);

/*-
 *-----------------------------------------------------------------------
 * CompatMake --
 *	Make a target.
 *
 * Side Effects:
 *	If an error is detected and not being ignored, the process exits.
 *-----------------------------------------------------------------------
 */
static void
CompatMake(void *gnp,	/* The node to make */
    void *pgnp)		/* Parent to abort if necessary */
{
	GNode *gn = gnp;
	GNode *pgn = pgnp;

	GNode *sib;
	bool cmdsOk;

	if (DEBUG(MAKE))
		printf("CompatMake(%s, %s)\n", pgn ? pgn->name : "NULL",
		    gn->name);

	/* XXX some loops are not loops, people write dependencies
	 * between siblings to make sure they get built.
	 * Also, we don't recognize direct loops.
	 */
	if (gn == pgn)
		return;
	/* handle .USE right away */
	if (gn->type & OP_USE) {
		Make_HandleUse(gn, pgn);
		return;
	}

	look_harder_for_target(gn);

	if (pgn != NULL && is_sibling(gn, pgn))
		return;

	if (pgn == NULL)
		pgn = gn;

	if (pgn->type & OP_MADE) {
		sib = gn;
		do {
			sib->mtime = gn->mtime;
			sib->built_status = UPTODATE;
			sib = sib->sibling;
		} while (sib != gn);
	}

	switch(gn->built_status) {
	case UNKNOWN: 
		/* First mark ourselves to be made, then apply whatever
		 * transformations the suffix module thinks are necessary.
		 * Once that's done, we can descend and make all our children.
		 * If any of them has an error but the -k flag was given,
		 * our 'must_make' field will be set false again.  This is our
		 * signal to not attempt to do anything but abort our
		 * parent as well.  */
		gn->must_make = true;
		gn->built_status = BEINGMADE;
		/* note that, in case we have siblings, we only check all
		 * children for all siblings, but we don't try to apply
		 * any other rule.
		 */
		sib = gn;
		do {
			Suff_FindDeps(sib);
			Lst_ForEach(&sib->children, CompatMake, gn);
			sib = sib->sibling;
		} while (sib != gn);

		if (!gn->must_make) {
			Error("Build for %s aborted", gn->name);
			gn->built_status = ABORTED;
			pgn->must_make = false;
			return;
		}

		/* All the children were made ok. Now youngest points to
		 * the newest child, we need to find out
		 * if we exist and when we were modified last. The criteria
		 * for datedness are defined by the Make_OODate function.  */
		if (DEBUG(MAKE))
			printf("Examining %s...", gn->name);
		if (!Make_OODate(gn)) {
			gn->built_status = UPTODATE;
			if (DEBUG(MAKE))
				printf("up-to-date.\n");
			return;
		} else if (DEBUG(MAKE))
			printf("out-of-date.\n");

		/* If the user is just seeing if something is out-of-date,
		 * exit now to tell him/her "yes".  */
		if (queryFlag)
			exit(1);

		/* normally, we run the job, but if we can't find any
		 * commands, we defer to siblings instead.
		 */
		sib = gn;
		do {
			/* We need to be re-made. We also have to make sure
			 * we've got a $?  variable. To be nice, we also define
			 * the $> variable using Make_DoAllVar().
			 */
			Make_DoAllVar(sib);
			cmdsOk = node_find_valid_commands(sib);
			if (cmdsOk || (gn->type & OP_OPTIONAL))
				break;

			sib = sib->sibling;
		} while (sib != gn);

		if (cmdsOk) {
			/* Our commands are ok, but we still have to worry
			 * about the -t flag...	*/
			if (!touchFlag)
				run_gnode(sib);
			else {
				Job_Touch(sib);
				if (gn != sib)
					Job_Touch(gn);
			}
		} else {
			node_failure(gn);
			sib->built_status = ERROR;
		}

		/* copy over what we just did */
		gn->built_status = sib->built_status;

		if (gn->built_status != ERROR) {
			/* If the node was made successfully, mark it so,
			 * update its modification time and timestamp all
			 * its parents.
			 * This is to keep its state from affecting that of
			 * its parent.  */
			gn->built_status = MADE;
			sib->built_status = MADE;
			/* This is what Make does and it's actually a good
			 * thing, as it allows rules like
			 *
			 *	cmp -s y.tab.h parse.h || cp y.tab.h parse.h
			 *
			 * to function as intended. Unfortunately, thanks to
			 * the stateless nature of NFS (and the speed of
			 * this program), there are times when the
			 * modification time of a file created on a remote
			 * machine will not be modified before the stat()
			 * implied by the Dir_MTime occurs, thus leading us
			 * to believe that the file is unchanged, wreaking
			 * havoc with files that depend on this one.
			 */
			if (noExecute || is_out_of_date(Dir_MTime(gn)))
				clock_gettime(CLOCK_REALTIME, &gn->mtime);
			if (is_strictly_before(gn->mtime, gn->youngest->mtime))
				gn->mtime = gn->youngest->mtime;
			if (sib != gn) {
				if (noExecute || is_out_of_date(Dir_MTime(sib)))
					clock_gettime(CLOCK_REALTIME, 
					    &sib->mtime);
				if (is_strictly_before(sib->mtime, 
				    sib->youngest->mtime))
					sib->mtime = sib->youngest->mtime;
			}
			if (DEBUG(MAKE))
				printf("update time: %s\n",
				    time_to_string(&gn->mtime));
			if (!(gn->type & OP_EXEC)) {
				pgn->childMade = true;
				Make_TimeStamp(pgn, gn);
			}
		} else if (keepgoing)
			pgn->must_make = false;
		else {
			print_errors();
			exit(1);
		}
		break;
	case ERROR:
		/* Already had an error when making this beastie. Tell the
		 * parent to abort.  */
		pgn->must_make = false;
		break;
	case BEINGMADE:
		Error("Graph cycles through %s", gn->name);
		gn->built_status = ERROR;
		pgn->must_make = false;
		break;
	case MADE:
		if ((gn->type & OP_EXEC) == 0) {
			pgn->childMade = true;
			Make_TimeStamp(pgn, gn);
		}
		break;
	case UPTODATE:
		if ((gn->type & OP_EXEC) == 0)
			Make_TimeStamp(pgn, gn);
		break;
	default:
		break;
	}
}

void
Compat_Run(Lst targs)		/* List of target nodes to re-create */
{
	GNode	  *gn = NULL;	/* Current root target */
	int 	  errors;   	/* Number of targets not remade due to errors */

	/* For each entry in the list of targets to create, call CompatMake on
	 * it to create the thing. CompatMake will leave the 'built_status'
	 * field of gn in one of several states:
	 *	    UPTODATE	    gn was already up-to-date
	 *	    MADE	    gn was recreated successfully
	 *	    ERROR	    An error occurred while gn was being
	 *                          created
	 *	    ABORTED	    gn was not remade because one of its
	 *                          inferiors could not be made due to errors.
	 */
	errors = 0;
	while ((gn = Lst_DeQueue(targs)) != NULL) {
		CompatMake(gn, NULL);

		if (gn->built_status == UPTODATE)
			printf("`%s' is up to date.\n", gn->name);
		else if (gn->built_status == ABORTED) {
			printf("`%s' not remade because of errors.\n",
			    gn->name);
			errors++;
		}
	}

	/* If the user has defined a .END target, run its commands.  */
	if (errors == 0)
		run_gnode(end_node);
}
@


1.85
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.84 2015/01/23 13:18:40 espie Exp $	*/
d286 1
a286 1
	while ((gn = (GNode *)Lst_DeQueue(targs)) != NULL) {
@


1.84
log
@remove a bunch of dangerous casts (useless casts from void * to something
else, in some cases by adding extra temporary variables.
IMO, it's much better practice to do

void *a;
int *p = a;
*p = 42;

rather than
void *a;
*(int *)a = 42;

okay miod@@... to be revisited for some possible const additions later.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.83 2013/06/20 19:48:32 espie Exp $	*/
d75 1
a75 1
	GNode *pgn = gnp;
@


1.83
log
@fix typo
thx Caspar Schutijser
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.82 2013/05/30 08:58:38 espie Exp $	*/
d74 2
a75 2
	GNode *gn = (GNode *)gnp;
	GNode *pgn = (GNode *)pgnp;
@


1.82
log
@remove cmtime again, but with a proper test for nodes without children.

problem seen by aja,
make pointed by matthieu,
sleuthing by me,
okay by millert

(and you say OpenBSD developers don't work together)
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.81 2013/05/25 11:54:14 espie Exp $	*/
d142 1
a142 1
		/* All the children were made ok. Now youngest poinst to
@


1.81
log
@obviously missed something, so revert.
(noticed by sthen@@/matthieu@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.80 2013/05/22 12:14:08 espie Exp $	*/
d220 2
a221 2
			if (is_strictly_before(gn->mtime, gn->cmtime))
				gn->mtime = gn->cmtime;
d227 2
a228 2
				    sib->cmtime))
					sib->mtime = sib->cmtime;
@


1.80
log
@as checked through thorough tests, youngest->mtime == ctime, so ditch
the extra field.

remove some extra abstraction layer: use clock_gettime directly
instead of ts_set_from_now (what is "now" anyways)

time_to_string takes param by pointer

rename "now" into starttime (more accurate term)

randomize queue uses arc4random_uniform (prompted by deraadt@@)

display debug timestamp with ns too (it's debug, so it doesn't really
matter whichever way it's done, as long as it's done)

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.79 2013/04/23 14:32:53 espie Exp $	*/
d220 2
a221 2
			if (is_strictly_before(gn->mtime, gn->youngest->mtime))
				gn->mtime = gn->youngest->mtime;
d227 2
a228 2
				    sib->youngest->mtime))
					sib->mtime = sib->youngest->mtime;
@


1.79
log
@remove TIMESTAMP abstraction layer, prodded by theo.
while there, clean up includes.
use strtoll for ar timestamps (pretty much unused in reality, more
standard conforming than anything)

use idea from Todd to adapt to time_t being 32 bits OR 64 bits
(pedantically correct: INT_MIN would work just fine up to 1910 or so...)

okay millert@@, gone thru a make build.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.78 2012/11/24 11:03:45 espie Exp $	*/
d142 2
a143 2
		/* All the children were made ok. Now cmtime contains the
		 * modification time of the newest child, we need to find out
d219 3
a221 3
				ts_set_from_now(gn->mtime);
			if (is_strictly_before(gn->mtime, gn->cmtime))
				gn->mtime = gn->cmtime;
d224 5
a228 3
					ts_set_from_now(sib->mtime);
				if (is_strictly_before(sib->mtime, sib->cmtime))
					sib->mtime = sib->cmtime;
d232 1
a232 1
				    time_to_string(gn->mtime));
@


1.78
log
@clean-up: move up .USE handling, so that the rest becomes a simple switch()

okay beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.77 2012/09/21 07:55:20 espie Exp $	*/
d40 1
@


1.77
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.76 2012/03/22 13:47:12 espie Exp $	*/
d89 6
d112 2
a113 3
	if (gn->type & OP_USE) {
		Make_HandleUse(gn, pgn);
	} else if (gn->built_status == UNKNOWN) {
d240 2
a241 1
	} else if (gn->built_status == ERROR)
d245 10
a254 19
	else {
		switch (gn->built_status) {
		case BEINGMADE:
			Error("Graph cycles through %s", gn->name);
			gn->built_status = ERROR;
			pgn->must_make = false;
			break;
		case MADE:
			if ((gn->type & OP_EXEC) == 0) {
				pgn->childMade = true;
				Make_TimeStamp(pgn, gn);
			}
			break;
		case UPTODATE:
			if ((gn->type & OP_EXEC) == 0)
				Make_TimeStamp(pgn, gn);
			break;
		default:
			break;
d256 7
@


1.76
log
@minor cleanup: error messages include lineno and fileno together, so
recognize that and create a struct Location_ for it.

mostly from Jonathan Calmels, a few nits from me.

okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.75 2010/11/02 19:47:22 deraadt Exp $	*/
d46 1
d165 1
a165 1
			cmdsOk = Job_CheckCommands(sib);
d183 1
a183 1
			job_failure(gn, Fatal);
d232 1
a232 9

			if (gn->origin.lineno)
				printf("\n\nStop in %s (line %lu of %s).\n",
				    Var_Value(".CURDIR"),
				    (unsigned long)gn->origin.lineno,
				    gn->origin.fname);
			else
				printf("\n\nStop in %s.\n",
				    Var_Value(".CURDIR"));
a266 10

	setup_engine(0);
	/* If the user has defined a .BEGIN target, execute the commands
	 * attached to it.  */
	if (!queryFlag) {
		if (run_gnode(begin_node) == ERROR) {
			printf("\n\nStop.\n");
			exit(1);
		}
	}
@


1.75
log
@exit 1 (not -1) for -q; PR 6494
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.74 2010/07/19 19:46:43 espie Exp $	*/
d232 1
a232 1
			if (gn->lineno)
d235 2
a236 2
				    (unsigned long)gn->lineno,
				    gn->fname);
@


1.74
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.73 2010/04/25 13:59:53 espie Exp $	*/
d152 1
a152 1
			exit(-1);
@


1.73
log
@pure whitespace cleanup
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$	*/
@


1.72
log
@modify timestamp handling to grab current time instead of relying on a
stale timestamp.

all those diffs sent to people ages ago, who didn't answer, except for
Theo, who said he ran it with no issues, so let's get this in...
@
text
@d80 1
a80 1
		printf("CompatMake(%s, %s)\n", pgn ? pgn->name : "NULL", 
d162 1
a162 1
			 * the $> variable using Make_DoAllVar().  
d287 1
a287 1
	 * it to create the thing. CompatMake will leave the 'built_status' 
@


1.71
log
@simplify job handling a great deal: we don't care when jobs get
stopped/continued, as we won't try to start new jobs when other stuff
is stopped.

Redo signal handling so that most stuff can be done directly in the handler.
This requires blocking/unblocking signals while creating new jobs, and creating
a small list that only contains job's pids.

Switch to pgrps for jobs, since that works.

Add a clamping heuristic that avoids starting new jobs while an expensive job
is running (expensive meaning "very likely to be a recursive make run"). This
idea is mostly from Theo, through the implementation is mine.
@
text
@d100 1
a100 1
			(void)Dir_MTime(sib);
d213 1
a213 1
				gn->mtime = now;
d218 1
a218 1
					sib->mtime = now;
@


1.70
log
@changes to get target equivalence to work better.
- add new file to create lists of equivalent targets (siblings)
- use that for sequential mode to have much better VPATH support
- separate checking commands from reporting error, for later.
- zap DieHorribly accordingly
- renumber existing flags
- signal_running_jobs() is simpler than pass_signal_to_jobs()
- new debug option -dn for name matching.

Similar code to handle parallel make is still missing.

thanks to Mark, Miod, Theo, Otto, Todd for tests and/or comments.
@
text
@d276 1
a276 1
	setup_engine();
@


1.69
log
@A few changes:
- expand commands earlier, so that we can eventually scan them to take
smarter decisions.
- clean up the select() mask code and rename variables to sensible things.
- quite a few minor renames for readability
- erecalloc
- clean up wait status handling, do not try to rebuild wait status, but
instead parse it early and deal with the parsed code.

tested by lots of people, thanks guys!
@
text
@d51 1
d76 13
d91 6
d98 6
a103 2
		(void)Dir_MTime(gn);
		gn->built_status = UPTODATE;
d118 11
a128 2
		Suff_FindDeps(gn);
		Lst_ForEach(&gn->children, CompatMake, gn);
d130 1
d155 16
a170 4
		/* We need to be re-made. We also have to make sure we've
		 * got a $?  variable. To be nice, we also define the $>
		 * variable using Make_DoAllVar().  */
		Make_DoAllVar(gn);
d172 1
a172 1
		if (Job_CheckCommands(gn, Fatal)) {
d176 13
a188 5
				run_gnode(gn);
			else
				Job_Touch(gn);
		} else
			gn->built_status = ERROR;
d197 1
d216 6
d250 1
a250 1
			Error("Graph cycles through %s\n", gn->name);
d298 1
a298 1
		CompatMake(gn, gn);
@


1.68
log
@UNMADE -> UNKNOWN
@
text
@d130 1
a130 1
				run_gnode(gn, 0);
d219 1
a219 1
		if (run_gnode(begin_node, 0) == ERROR) {
d250 1
a250 1
		run_gnode(end_node, 0);
@


1.67
log
@rename make -> must_make, made -> built_status
to make them easier to find in source files.
@
text
@d84 1
a84 1
	} else if (gn->built_status == UNMADE) {
@


1.66
log
@simplify the way we deal with implicit rules and handle $<.

Having an `iParents' field is actually backwards, it's ways simpler to
store the pointer in the child, as an impliedsrc, and to set the variable
just in time along with all the rest in DoAllVar.

This is simpler, and it should allow us to call SuffFindDeps much later.
@
text
@d79 1
a79 1
		gn->made = UPTODATE;
d84 1
a84 1
	} else if (gn->made == UNMADE) {
d89 1
a89 1
		 * our 'make' field will be set false again.  This is our
d92 2
a93 2
		gn->make = true;
		gn->made = BEINGMADE;
d96 3
a98 3
		if (!gn->make) {
			gn->made = ABORTED;
			pgn->make = false;
d109 1
a109 1
			gn->made = UPTODATE;
d134 1
a134 1
			gn->made = ERROR;
d136 1
a136 1
		if (gn->made != ERROR) {
d142 1
a142 1
			gn->made = MADE;
d169 1
a169 1
			pgn->make = false;
d182 4
a185 4
	} else if (gn->made == ERROR)
		/* Already had an error when making this beastie. Tell the parent
		 * to abort.  */
		pgn->make = false;
d187 1
a187 1
		switch (gn->made) {
d190 2
a191 2
			gn->made = ERROR;
			pgn->make = false;
d226 2
a227 2
	 * it to create the thing. CompatMake will leave the 'made' field of gn
	 * in one of several states:
d239 1
a239 1
		if (gn->made == UPTODATE)
d241 1
a241 1
		else if (gn->made == ABORTED) {
@


1.65
log
@simplify: Job_CheckCommands deals with silent and ignerr now, so there's
no need to duplicate that info at the job level since we can just use
the gn->type.
@
text
@a101 5
		if (Lst_Member(&gn->iParents, pgn) != NULL) {
			Varq_Set(IMPSRC_INDEX, Varq_Value(TARGET_INDEX, gn),
			    pgn);
		}

a186 4
		if (Lst_Member(&gn->iParents, pgn) != NULL) {
			Varq_Set(IMPSRC_INDEX, Varq_Value(TARGET_INDEX, gn),
			    pgn);
		}
@


1.64
log
@do the silent/ignore check in Job_CheckCommands, so that make -j4 -s works
@
text
@d137 1
a137 1
				Job_Touch(gn, gn->type & OP_SILENT);
@


1.63
log
@Work done at p2k7.


This is a really big step towards getting parallel make to work.


Note that this is not yet complete. There are still a few `details' to
fix before this works 100%.  Specifically: sequential make (compat) and
parallel make don't use the same engine, and the parallel engine still
has a few limitations. For instance, some known issues:
- parallel make does not deal with .phony targets correctly all the time.
- some errors are deadly in parallel make mode.
- parallel make NEEDS way more sturdy correspondance of file system paths
and target names, since it often needs to match dependencies to targets
before the corresponding files exist.
- some local variables like $* get set in a bogus way in some cases.
- suffix handling has issues, especially related to the NULL suffix.
So, if you find stuff that does NOT yet work with parallel make, don't go
blindly try to fix the Makefile. It's very likely you might have stumbled
into a make bug. (unless you really, really, understand Makefiles, DON'T
GO CHANGING THEM YET).



Tested by lots of people, thanks go to miod@@, and robert@@ among other people.

Quick summary of what this does:

- remove `saving commands' extension (it's not really usable, nor used)
- move compat job runner and parallel interrupt handling into engine.c
- tweak the code so that both compat and parallel mode use the same job runner
and the same interrupt handling. Remove the other one.
- optimize job runner so that, in parallel mode, the last command does not
fork if we can avoid it (as it's already running in a sub shell).
- scrape all the code that dealt with creating shell scripts from commands.
- scrape all the code that dealt with recognizing special sequences in
command output to print/not print output.
- fix the parallel job pipe to not keep around file descriptors that are not
needed.
- replace the parallel job buffering with a nicer one, that deals with
non-blocking descriptors to try to agregate as much output from one job in
one go (greed) to unconfuse the users.
- create two pipes per job, so that stdout and stderr stay separate.
- make job token printing a debug option.
- always use the parallel job-runner to `execute' commands, even if we just
print them out.
- store list of errors encountered during parallel make running, and print them
on exit, so that we know what went wrong.
- add a dirty hack to targ.c to deal with paths produced by gccmakedep.
@
text
@a130 8
		/* Alter our type to tell if errors should be ignored or things
		 * should not be printed so CompatRunCommand knows what to do.
		 */
		if (Targ_Ignore(gn))
			gn->type |= OP_IGNORE;
		if (Targ_Silent(gn))
			gn->type |= OP_SILENT;

@


1.62
log
@fix indentation
@
text
@a38 5
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <ctype.h>
#include <errno.h>
a40 1
#include <stddef.h>
a42 2
#include <string.h>
#include <unistd.h>
a51 1
#include "str.h"
a52 1
#include "memory.h"
a53 1
#include "make.h"
a55 1
#include "pathnames.h"
a56 2
static void CompatInterrupt(int);
static int CompatRunCommand(LstNode, void *);
a57 254
static int run_gnode(GNode *);
static void setup_meta(void);
static char **recheck_command_for_shell(char **);
static void run_command(const char *, bool);

static volatile sig_atomic_t interrupted;

static void
CompatInterrupt(int signo)
{
	if (interrupted != SIGINT)
		interrupted = signo;
}

/* The following array is used to make a fast determination of which
 * characters are interpreted specially by the shell.  If a command
 * contains any of these characters, it is executed by the shell, not
 * directly by us.  */
static char	    meta[256];

static void
setup_meta(void)
{
	char *p;

	for (p = "#=|^(){};&<>*?[]:$`\\\n"; *p != '\0'; p++)
		meta[(unsigned char) *p] = 1;
	/* The null character serves as a sentinel in the string.  */
	meta[0] = 1;
}

static char **
recheck_command_for_shell(char **av)
{
	char *runsh[] = {
		"alias", "cd", "eval", "exit", "read", "set", "ulimit",
		"unalias", "unset", "wait", "umask", NULL
	};

	char **p;

	/* optimization: if exec cmd, we avoid the intermediate shell */
	if (strcmp(av[0], "exec") == 0)
		av++;

	for (p = runsh; *p; p++)
		if (strcmp(av[0], *p) == 0)
			return NULL;

	return av;
}

static void
run_command(const char *cmd, bool errCheck)
{
	const char *p;
	char *shargv[4];
	char **todo;

	shargv[0] = _PATH_BSHELL;

	shargv[1] = errCheck ? "-ec" : "-c";
	shargv[2] = (char *)cmd;
	shargv[3] = NULL;

	todo = shargv;


	/* Search for meta characters in the command. If there are no meta
	 * characters, there's no need to execute a shell to execute the
	 * command.  */
	for (p = cmd; !meta[(unsigned char)*p]; p++)
		continue;
	if (*p == '\0') {
		char *bp;
		char **av;
		int argc;
		/* No meta-characters, so probably no need to exec a shell.
		 * Break the command into words to form an argument vector
		 * we can execute.  */
		av = brk_string(cmd, &argc, &bp);
		av = recheck_command_for_shell(av);
		if (av != NULL)
			todo = av;
	}
	execvp(todo[0], todo);

	if (errno == ENOENT)
		fprintf(stderr, "%s: not found\n", todo[0]);
	else
		perror(todo[0]);
	_exit(1);
}

/*-
 *-----------------------------------------------------------------------
 * CompatRunCommand --
 *	Execute the next command for a target. If the command returns an
 *	error, the node's made field is set to ERROR and creation stops.
 *
 * Results:
 *	0 in case of error, 1 if ok.
 *
 * Side Effects:
 *	The node's 'made' field may be set to ERROR.
 *-----------------------------------------------------------------------
 */
static int
CompatRunCommand(LstNode cmdNode,	/* Command to execute */
    void *gnp)				/* Node from which the command came */
{
	char *cmdStart;	/* Start of expanded command */
	bool silent;	/* Don't print command */
	bool doExecute;	/* Execute the command */
	bool errCheck;	/* Check errors */
	int reason;	/* Reason for child's death */
	int status;	/* Description of child's death */
	pid_t cpid; 	/* Child actually found */
	pid_t stat;	/* Status of fork */
	char *cmd = (char *)Lst_Datum(cmdNode);
	GNode *gn = (GNode *)gnp;

	silent = gn->type & OP_SILENT;
	errCheck = !(gn->type & OP_IGNORE);
	doExecute = !noExecute;

	cmdStart = Var_Subst(cmd, &gn->context, false);

	/* How can we execute a null command ? we warn the user that the
	 * command expanded to nothing (is this the right thing to do?).  */
	if (*cmdStart == '\0') {
		free(cmdStart);
		Error("%s expands to empty string", cmd);
		return 1;
	} else
		cmd = cmdStart;

	if ((gn->type & OP_SAVE_CMDS) && (gn != end_node)) {
		Lst_AtEnd(&end_node->commands, cmdStart);
		end_node->type &= ~OP_DUMMY;
		return 1;
	} else if (strcmp(cmdStart, "...") == 0) {
		gn->type |= OP_SAVE_CMDS;
		return 1;
	}
	for (;; cmd++) {
		if (*cmd == '@@')
			silent = DEBUG(LOUD) ? false : true;
		else if (*cmd == '-')
			errCheck = false;
		else if (*cmd == '+')
			doExecute = true;
		else
			break;
	}
	while (isspace(*cmd))
		cmd++;
	/* Print the command before echoing if we're not supposed to be quiet
	 * for this one. We also print the command if -n given.  */
	if (!silent || noExecute) {
		printf("%s\n", cmd);
		fflush(stdout);
	}
	/* If we're not supposed to execute any commands, this is as far as
	 * we go...  */
	if (!doExecute)
		return 1;

	/* Fork and execute the single command. If the fork fails, we abort.  */
	switch (cpid = fork()) {
	case -1:
		Fatal("Could not fork");
		/*NOTREACHED*/
	case 0:
		run_command(cmd, errCheck);
		/*NOTREACHED*/
	default:
		break;
	}
	free(cmdStart);

	/* The child is off and running. Now all we can do is wait...  */
	while (1) {

		while ((stat = wait(&reason)) != cpid) {
			if (stat == -1 && errno != EINTR)
				break;
		}

		if (interrupted)
			break;

		if (stat != -1) {
			if (WIFSTOPPED(reason))
				status = WSTOPSIG(reason);	/* stopped */
			else if (WIFEXITED(reason)) {
				status = WEXITSTATUS(reason);	/* exited */
				if (status != 0)
				    printf("*** Error code %d", status);
			} else {
				status = WTERMSIG(reason);	/* signaled */
				printf("*** Signal %d", status);
			}


			if (!WIFEXITED(reason) || status != 0) {
				if (errCheck) {
					gn->made = ERROR;
					if (keepgoing)
						/* Abort the current target,
						 * but let others continue.  */
						printf(" (continuing)\n");
				} else {
					/* Continue executing commands for
					 * this target.  If we return 0,
					 * this will happen...  */
					printf(" (ignored)\n");
					status = 0;
				}
			}
			return !status;
		} else
			Fatal("error in wait: %d", stat);
			/*NOTREACHED*/
	}

	/* This is reached only if interrupted */
	if (!Targ_Precious(gn)) {
		char	  *file = Varq_Value(TARGET_INDEX, gn);

		if (!noExecute && eunlink(file) != -1)
			Error("*** %s removed\n", file);
	}
	if (interrupted == SIGINT) {
		signal(SIGINT, SIG_IGN);
		signal(SIGTERM, SIG_IGN);
		signal(SIGHUP, SIG_IGN);
		signal(SIGQUIT, SIG_IGN);
		interrupted = 0;
		run_gnode(interrupt_node);
		exit(SIGINT);
	}
	exit(interrupted);
}

static int
run_gnode(GNode *gn)
{
	if (gn != NULL && (gn->type & OP_DUMMY) == 0) {
		Lst_ForEachNodeWhile(&gn->commands, CompatRunCommand, gn);
		return gn->made;
	} else
		return NOSUCHNODE;
}
d75 2
d143 1
a143 1
				run_gnode(gn);
d232 1
a232 6
	signal(SIGINT, CompatInterrupt);
	signal(SIGTERM, CompatInterrupt);
	signal(SIGHUP, CompatInterrupt);
	signal(SIGQUIT, CompatInterrupt);

	setup_meta();
d236 1
a236 1
		if (run_gnode(begin_node) == ERROR) {
d267 1
a267 1
		run_gnode(end_node);
@


1.61
log
@allows node to be run twice, by not destroying the cmdnode contents.
This way, you can run `make .BEGIN'. Okay, this will run .BEGIN twice.
@
text
@d406 6
a411 6
		    /* Our commands are ok, but we still have to worry
		     * about the -t flag...	*/
		    if (!touchFlag)
			    run_gnode(gn);
		    else
			    Job_Touch(gn, gn->type & OP_SILENT);
@


1.60
log
@rewrite of the basic suffix/target parsing: use hash for suffixes.

Store special targets in target hash, and use them for the parsing.

Use OP_DUMMY flag to mark targets that don't really exist yet, such
as interrupt and default nodes.

Also, .PATHxxx is special in suffixes.

Small tweaks to compat.c, so that run_commands does more stuff after
the fork() (and thus no need to free things).

Remove distinction between local and global jobs.
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.59 2007/09/17 09:28:36 espie Exp $	*/
a207 1
	Lst_Replace(cmdNode, cmdStart);
a251 1
	Lst_Replace(cmdNode, NULL);
@


1.59
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.58 2007/09/17 08:36:57 espie Exp $	*/
a68 8
/* The following array is used to make a fast determination of which
 * characters are interpreted specially by the shell.  If a command
 * contains any of these characters, it is executed by the shell, not
 * directly by us.  */

static char meta[256];

static GNode *ENDNode;
d72 4
a75 1
static int shellneed(char **);
d86 19
a104 16
/*-
 *-----------------------------------------------------------------------
 * shellneed --
 *
 * Results:
 *	Returns 1 if a specified set of arguments
 *	must be executed by the shell,
 *	0 if it can be run via execve, and -1 if the command can be
 *	handled internally
 *
 * Side Effects:
 *	May modify the process umask
 *-----------------------------------------------------------------------
 */
static int
shellneed(char **av)
d107 2
a108 3
		"alias", "cd", "eval", "exec", "exit", "read", "set", "ulimit",
		"unalias", "unset", "wait",
		NULL
d113 4
a116 1
	/* FIXME most of these ARE actual no-ops */
d119 19
a137 1
			return 1;
a138 18
	if (strcmp(av[0], "umask") == 0) {
		long umi;
		char *ep = NULL;
		mode_t um;

		if (av[1] != NULL) {
			umi = strtol(av[1], &ep, 8);
			if (ep == NULL)
				return 1;
			um = umi;
		}
		else {
			um = umask(0);
			printf("%o\n", um);
		}
		(void)umask(um);
		return -1;
	}
d140 24
a163 1
	return 0;
d180 2
a181 2
CompatRunCommand(LstNode cmdNode,/* Command to execute */
    void *gnp)			/* Node from which the command came */
d183 8
a190 12
	char *cmdStart;		/* Start of expanded command */
	char *cp, *bp = NULL;
	bool silent;		/* Don't print command */
	bool doExecute;		/* Execute the command */
	volatile bool errCheck;	/* Check errors */
	int reason;		/* Reason for child's death */
	int status;		/* Description of child's death */
	pid_t cpid; 		/* Child actually found */
	pid_t stat; 		/* Status of fork */
	char **volatile av; 	/* Argument vector for thing to exec */
	int argc; 		/* Number of arguments in av or 0 if not
				 * dynamically allocated */
a192 1
	static char *shargv[4] = { _PATH_BSHELL };
d200 2
a201 5
	/* brk_string will return an argv with a NULL in av[0], thus causing
	 * execvp to choke and die horribly. Besides, how can we execute a null
	 * command? In any case, we warn the user that the command expanded to
	 * nothing (is this the right thing to do?).  */

d210 3
a212 2
	if ((gn->type & OP_SAVE_CMDS) && (gn != ENDNode)) {
		Lst_AtEnd(&ENDNode->commands, cmdStart);
a217 1

a227 1

a229 8

	/* Search for meta characters in the command. If there are no meta
	 * characters, there's no need to execute a shell to execute the
	 * command.  */
	for (cp = cmd; !meta[(unsigned char)*cp]; cp++) {
		continue;
	}

a235 1

a240 36
	if (*cp != '\0') {
		/* If *cp isn't the null character, we hit a "meta" character
		 * and need to pass the command off to the shell. We give the
		 * shell the -e flag as well as -c if it's supposed to exit
		 * when it hits an error.  */

		shargv[1] = errCheck ? "-ec" : "-c";
		shargv[2] = cmd;
		shargv[3] = NULL;
		av = shargv;
		argc = 0;
	} else {
		/* No meta-characters, so probably no need to exec a shell.
		 * Break the command into words to form an argument vector
		 * we can execute.  */
		av = brk_string(cmd, &argc, &bp);
		switch (shellneed(av)) {
		case -1: /* handled internally */
			free(bp);
			free(av);
			return 1;
		case 1:
			shargv[1] = errCheck ? "-ec" : "-c";
			shargv[2] = cmd;
			shargv[3] = NULL;
			free(av);
			free(bp);
			bp = NULL;
			av = shargv;
			argc = 0;
			break;
		default: /* nothing needed */
			break;
		}
	}

d242 2
a243 2
	cpid = fork();
	if (cpid == -1)
d245 6
a250 11
	if (cpid == 0) {
		execvp(av[0], av);
		if (errno == ENOENT)
			fprintf(stderr, "%s: not found\n", av[0]);
		else
			perror(av[0]);
		_exit(1);
	}
	if (bp) {
		free(av);
		free(bp);
d272 1
a272 1
					printf("*** Error code %d", status);
d287 3
a289 3
					/* Continue executing commands for this
					 * target.  If we return 0, this will
					 * happen...  */
d302 1
a302 1
		char *file = Varq_Value(TARGET_INDEX, gn);
a307 1
		GNode *i = Targ_FindNode(".INTERRUPT", TARG_NOCREATE);
d313 1
a313 2
		if (i != NULL)
			Lst_ForEachNodeWhile(&i->commands, CompatRunCommand, i);
d319 10
d354 6
a359 5
		 * transformations the suffix module thinks are necessary. Once
		 * that's done, we can descend and make all our children. If
		 * any of them has an error but the -k flag was given, our
		 * 'make' field will be set false again.  This is our signal to
		 * not attempt to do anything but abort our parent as well.  */
d377 2
a378 2
		 * if we exist and when we were modified last. The criteria for
		 * datedness are defined by the Make_OODate function.  */
d381 1
a381 1
		if (! Make_OODate(gn)) {
d389 2
a390 2
		/* If the user is just seeing if something is out-of-date, exit
		 * now to tell him/her "yes".  */
d394 3
a396 3
		/* We need to be re-made. We also have to make sure we've got a
		 * $?  variable. To be nice, we also define the $> variable
		 * using Make_DoAllVar().  */
d401 1
a401 1
		 * */
d408 6
a413 7
			/* Our commands are ok, but we still have to worry
			 * about the -t flag...	*/
			if (!touchFlag)
				Lst_ForEachNodeWhile(&gn->commands,
				    CompatRunCommand, gn);
			else
				Job_Touch(gn, gn->type & OP_SILENT);
d419 4
a422 4
			 * update its modification time and timestamp all its
			 * parents. Note that for .ZEROTIME targets, the
			 * timestamping isn't done.  This is to keep its state
			 * from affecting that of its parent.  */
d430 7
a436 11
			 * the stateless nature of NFS (and the speed of this
			 * program), there are times when the modification time
			 * of a file created on a remote machine will not be
			 * modified before the stat() implied by the Dir_MTime
			 * occurs, thus leading us to believe that the file is
			 * unchanged, wreaking havoc with files that depend on
			 * this one.
			 *
			 * I have decided it is better to make too much than to
			 * make too little, so this stuff is commented out
			 * unless you're sure it's ok.  -- ardeb 1/12/88
d464 2
a465 2
		/* Already had an error when making this beastie. Tell the
		 * parent to abort.  */
d497 2
a498 3
	char *cp;		/* Pointer to string of shell meta-characters */
	GNode *gn = NULL;	/* Current root target */
	int errors;   		/* Number of targets not remade due to errors */
d505 1
a505 6
	for (cp = "#=|^(){};&<>*?[]:$`\\\n"; *cp != '\0'; cp++)
		meta[(unsigned char) *cp] = 1;
	/* The null character serves as a sentinel in the string.  */
	meta[0] = 1;

	ENDNode = Targ_FindNode(".END", TARG_CREATE);
d509 3
a511 8
		gn = Targ_FindNode(".BEGIN", TARG_NOCREATE);
		if (gn != NULL) {
			Lst_ForEachNodeWhile(&gn->commands, CompatRunCommand,
			    gn);
			if (gn->made == ERROR) {
				printf("\n\nStop.\n");
				exit(1);
			}
d520 2
a521 1
	 *	    ERROR	    An error occurred while gn was being created
d523 1
a523 1
	 *			    inferiors could not be made due to errors.
d540 1
a540 2
		Lst_ForEachNodeWhile(&ENDNode->commands, CompatRunCommand,
		    ENDNode);
@


1.58
log
@kill += 1, -= 1     -> ++, --
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.57 2007/09/16 14:18:40 espie Exp $	*/
d84 1
a84 1
static void 
d398 1
a398 1
			Varq_Set(IMPSRC_INDEX, Varq_Value(TARGET_INDEX, gn), 
d438 1
a438 1
				Lst_ForEachNodeWhile(&gn->commands, 
d475 1
a475 1
				printf("update time: %s\n", 
d491 1
a491 1
				printf("\n\nStop in %s.\n", 
d501 1
a501 1
			Varq_Set(IMPSRC_INDEX, Varq_Value(TARGET_INDEX, gn), 
d549 1
a549 1
			Lst_ForEachNodeWhile(&gn->commands, CompatRunCommand, 
d564 1
a564 1
	 *	    ABORTED	    gn was not remade because one of its 
d574 1
a574 1
			printf("`%s' not remade because of errors.\n", 
d582 1
a582 1
		Lst_ForEachNodeWhile(&ENDNode->commands, CompatRunCommand, 
@


1.57
log
@reindent compat.c
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.56 2007/09/16 12:09:36 espie Exp $	*/
d576 1
a576 1
			errors += 1;
@


1.56
log
@rename Targ_FmtTime into time_to_string and move it, as it's not related
to target nodes at all (reduces modules inter-dependencies)
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.55 2007/09/16 10:39:07 espie Exp $	*/
d74 1
a74 1
static char	    meta[256];
d76 1
a76 1
static GNode	    *ENDNode;
d87 2
a88 2
    if (interrupted != SIGINT)
	interrupted = signo;
d160 11
a170 11
    char	  *cmdStart;	/* Start of expanded command */
    char *cp, *bp = NULL;
    bool	  silent,	/* Don't print command */
		  doExecute;	/* Execute the command */
    volatile bool errCheck;	/* Check errors */
    int 	  reason;	/* Reason for child's death */
    int 	  status;	/* Description of child's death */
    pid_t 	  cpid; 	/* Child actually found */
    pid_t	  stat; 	/* Status of fork */
    char	  ** volatile av; /* Argument vector for thing to exec */
    int 	  argc; 	/* Number of arguments in av or 0 if not
d172 41
a212 14
    char	  *cmd = (char *)Lst_Datum(cmdNode);
    GNode	  *gn = (GNode *)gnp;
    static char *shargv[4] = { _PATH_BSHELL };

    silent = gn->type & OP_SILENT;
    errCheck = !(gn->type & OP_IGNORE);
    doExecute = !noExecute;

    cmdStart = Var_Subst(cmd, &gn->context, false);

    /* brk_string will return an argv with a NULL in av[0], thus causing
     * execvp to choke and die horribly. Besides, how can we execute a null
     * command? In any case, we warn the user that the command expanded to
     * nothing (is this the right thing to do?).  */
d214 20
a233 69
    if (*cmdStart == '\0') {
	free(cmdStart);
	Error("%s expands to empty string", cmd);
	return 1;
    } else
	cmd = cmdStart;
    Lst_Replace(cmdNode, cmdStart);

    if ((gn->type & OP_SAVE_CMDS) && (gn != ENDNode)) {
	Lst_AtEnd(&ENDNode->commands, cmdStart);
	return 1;
    } else if (strcmp(cmdStart, "...") == 0) {
	gn->type |= OP_SAVE_CMDS;
	return 1;
    }

    for (;; cmd++) {
	if (*cmd == '@@')
	    silent = DEBUG(LOUD) ? false : true;
	else if (*cmd == '-')
	    errCheck = false;
	else if (*cmd == '+')
	    doExecute = true;
	else
	    break;
    }

    while (isspace(*cmd))
	cmd++;

    /* Search for meta characters in the command. If there are no meta
     * characters, there's no need to execute a shell to execute the
     * command.  */
    for (cp = cmd; !meta[(unsigned char)*cp]; cp++) {
	continue;
    }

    /* Print the command before echoing if we're not supposed to be quiet for
     * this one. We also print the command if -n given.  */
    if (!silent || noExecute) {
	printf("%s\n", cmd);
	fflush(stdout);
    }

    /* If we're not supposed to execute any commands, this is as far as
     * we go...  */
    if (!doExecute)
	return 1;

    if (*cp != '\0') {
	/* If *cp isn't the null character, we hit a "meta" character and
	 * need to pass the command off to the shell. We give the shell the
	 * -e flag as well as -c if it's supposed to exit when it hits an
	 * error.  */

	shargv[1] = errCheck ? "-ec" : "-c";
	shargv[2] = cmd;
	shargv[3] = NULL;
	av = shargv;
	argc = 0;
    } else {
	/* No meta-characters, so probably no need to exec a shell.
	 * Break the command into words to form an argument vector
	 * we can execute.  */
	av = brk_string(cmd, &argc, &bp);
	switch (shellneed(av)) {
	case -1: /* handled internally */
		free(bp);
		free(av);
d235 7
a241 1
	case 1:
d245 40
d287 10
a296 64
		bp = NULL;
		av = shargv;
		argc = 0;
		break;
	default: /* nothing needed */
		break;
	}
    }

    /* Fork and execute the single command. If the fork fails, we abort.  */
    cpid = fork();
    if (cpid == -1)
	Fatal("Could not fork");
    if (cpid == 0) {
	    execvp(av[0], av);
	    if (errno == ENOENT)
		fprintf(stderr, "%s: not found\n", av[0]);
	    else
		perror(av[0]);
	    _exit(1);
    }
    if (bp) {
	free(av);
	free(bp);
    }
    free(cmdStart);
    Lst_Replace(cmdNode, NULL);

    /* The child is off and running. Now all we can do is wait...  */
    while (1) {

	while ((stat = wait(&reason)) != cpid) {
	    if (stat == -1 && errno != EINTR)
		break;
	}

	if (interrupted)
	    break;

	if (stat != -1) {
	    if (WIFSTOPPED(reason))
		status = WSTOPSIG(reason);		/* stopped */
	    else if (WIFEXITED(reason)) {
		status = WEXITSTATUS(reason);		/* exited */
		if (status != 0)
		    printf("*** Error code %d", status);
	    } else {
		status = WTERMSIG(reason);		/* signaled */
		printf("*** Signal %d", status);
	    }


	    if (!WIFEXITED(reason) || status != 0) {
		if (errCheck) {
		    gn->made = ERROR;
		    if (keepgoing)
			/* Abort the current target, but let others
			 * continue.  */
			printf(" (continuing)\n");
		} else {
		    /* Continue executing commands for this target.
		     * If we return 0, this will happen...  */
		    printf(" (ignored)\n");
		    status = 0;
d298 57
a354 26
	    }
	    return !status;
	} else
	    Fatal("error in wait: %d", stat);
	    /*NOTREACHED*/
    }

    /* This is reached only if interrupted */
    if (!Targ_Precious(gn)) {
	char	  *file = Varq_Value(TARGET_INDEX, gn);

	if (!noExecute && eunlink(file) != -1)
	    Error("*** %s removed\n", file);
    }
    if (interrupted == SIGINT) {
    	GNode *i = Targ_FindNode(".INTERRUPT", TARG_NOCREATE);
	signal(SIGINT, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
	signal(SIGHUP, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	interrupted = 0;
	if (i != NULL)
	    Lst_ForEachNodeWhile(&i->commands, CompatRunCommand, i);
	exit(SIGINT);
    }
    exit(interrupted);
d370 26
a395 2
    GNode *gn = (GNode *)gnp;
    GNode *pgn = (GNode *)pgnp;
d397 4
a400 68
    if (pgn->type & OP_MADE) {
	(void)Dir_MTime(gn);
	gn->made = UPTODATE;
    }

    if (gn->type & OP_USE) {
	Make_HandleUse(gn, pgn);
    } else if (gn->made == UNMADE) {
	/* First mark ourselves to be made, then apply whatever transformations
	 * the suffix module thinks are necessary. Once that's done, we can
	 * descend and make all our children. If any of them has an error
	 * but the -k flag was given, our 'make' field will be set false again.
	 * This is our signal to not attempt to do anything but abort our
	 * parent as well.  */
	gn->make = true;
	gn->made = BEINGMADE;
	Suff_FindDeps(gn);
	Lst_ForEach(&gn->children, CompatMake, gn);
	if (!gn->make) {
	    gn->made = ABORTED;
	    pgn->make = false;
	    return;
	}

	if (Lst_Member(&gn->iParents, pgn) != NULL) {
	    Varq_Set(IMPSRC_INDEX, Varq_Value(TARGET_INDEX, gn), pgn);
	}

	/* All the children were made ok. Now cmtime contains the modification
	 * time of the newest child, we need to find out if we exist and when
	 * we were modified last. The criteria for datedness are defined by the
	 * Make_OODate function.  */
	if (DEBUG(MAKE))
	    printf("Examining %s...", gn->name);
	if (! Make_OODate(gn)) {
	    gn->made = UPTODATE;
	    if (DEBUG(MAKE))
		printf("up-to-date.\n");
	    return;
	} else if (DEBUG(MAKE))
	    printf("out-of-date.\n");

	/* If the user is just seeing if something is out-of-date, exit now
	 * to tell him/her "yes".  */
	if (queryFlag)
	    exit(-1);

	/* We need to be re-made. We also have to make sure we've got a $?
	 * variable. To be nice, we also define the $> variable using
	 * Make_DoAllVar().  */
	Make_DoAllVar(gn);

	/* Alter our type to tell if errors should be ignored or things
	 * should not be printed so CompatRunCommand knows what to do.	*/
	if (Targ_Ignore(gn))
	    gn->type |= OP_IGNORE;
	if (Targ_Silent(gn))
	    gn->type |= OP_SILENT;

	if (Job_CheckCommands(gn, Fatal)) {
	    /* Our commands are ok, but we still have to worry about the -t
	     * flag...	*/
	    if (!touchFlag)
		Lst_ForEachNodeWhile(&gn->commands, CompatRunCommand, gn);
	    else
		Job_Touch(gn, gn->type & OP_SILENT);
	} else
	    gn->made = ERROR;
d402 82
a483 36
	if (gn->made != ERROR) {
	    /* If the node was made successfully, mark it so, update
	     * its modification time and timestamp all its parents. Note
	     * that for .ZEROTIME targets, the timestamping isn't done.
	     * This is to keep its state from affecting that of its parent.  */
	    gn->made = MADE;
	    /* This is what Make does and it's actually a good thing, as it
	     * allows rules like
	     *
	     *	cmp -s y.tab.h parse.h || cp y.tab.h parse.h
	     *
	     * to function as intended. Unfortunately, thanks to the stateless
	     * nature of NFS (and the speed of this program), there are times
	     * when the modification time of a file created on a remote
	     * machine will not be modified before the stat() implied by
	     * the Dir_MTime occurs, thus leading us to believe that the file
	     * is unchanged, wreaking havoc with files that depend on this one.
	     *
	     * I have decided it is better to make too much than to make too
	     * little, so this stuff is commented out unless you're sure it's
	     * ok.
	     * -- ardeb 1/12/88
	     */
	    if (noExecute || is_out_of_date(Dir_MTime(gn)))
		gn->mtime = now;
	    if (is_strictly_before(gn->mtime, gn->cmtime))
		gn->mtime = gn->cmtime;
	    if (DEBUG(MAKE))
		printf("update time: %s\n", time_to_string(gn->mtime));
	    if (!(gn->type & OP_EXEC)) {
		pgn->childMade = true;
		Make_TimeStamp(pgn, gn);
	    }
	} else if (keepgoing)
	    pgn->make = false;
	else {
d485 13
a497 21
	    if (gn->lineno)
		printf("\n\nStop in %s (line %lu of %s).\n",
			Var_Value(".CURDIR"),
			(unsigned long)gn->lineno,
			gn->fname);
	    else
		printf("\n\nStop in %s.\n", Var_Value(".CURDIR"));
	    exit(1);
	}
    } else if (gn->made == ERROR)
	/* Already had an error when making this beastie. Tell the parent
	 * to abort.  */
	pgn->make = false;
    else {
	if (Lst_Member(&gn->iParents, pgn) != NULL) {
	    Varq_Set(IMPSRC_INDEX, Varq_Value(TARGET_INDEX, gn), pgn);
	}
	switch (gn->made) {
	    case BEINGMADE:
		Error("Graph cycles through %s\n", gn->name);
		gn->made = ERROR;
d499 24
a522 13
		break;
	    case MADE:
		if ((gn->type & OP_EXEC) == 0) {
		    pgn->childMade = true;
		    Make_TimeStamp(pgn, gn);
		}
		break;
	    case UPTODATE:
		if ((gn->type & OP_EXEC) == 0)
		    Make_TimeStamp(pgn, gn);
		break;
	    default:
		break;
a523 1
    }
d529 55
a583 51
    char	  *cp;		/* Pointer to string of shell meta-characters */
    GNode	  *gn = NULL;	/* Current root target */
    int 	  errors;   	/* Number of targets not remade due to errors */

    signal(SIGINT, CompatInterrupt);
    signal(SIGTERM, CompatInterrupt);
    signal(SIGHUP, CompatInterrupt);
    signal(SIGQUIT, CompatInterrupt);

    for (cp = "#=|^(){};&<>*?[]:$`\\\n"; *cp != '\0'; cp++)
	meta[(unsigned char) *cp] = 1;
    /* The null character serves as a sentinel in the string.  */
    meta[0] = 1;

    ENDNode = Targ_FindNode(".END", TARG_CREATE);
    /* If the user has defined a .BEGIN target, execute the commands attached
     * to it.  */
    if (!queryFlag) {
	gn = Targ_FindNode(".BEGIN", TARG_NOCREATE);
	if (gn != NULL) {
	    Lst_ForEachNodeWhile(&gn->commands, CompatRunCommand, gn);
	    if (gn->made == ERROR) {
		printf("\n\nStop.\n");
		exit(1);
	    }
	}
    }

    /* For each entry in the list of targets to create, call CompatMake on
     * it to create the thing. CompatMake will leave the 'made' field of gn
     * in one of several states:
     *	    UPTODATE	    gn was already up-to-date
     *	    MADE	    gn was recreated successfully
     *	    ERROR	    An error occurred while gn was being created
     *	    ABORTED	    gn was not remade because one of its inferiors
     *			    could not be made due to errors.  */
    errors = 0;
    while ((gn = (GNode *)Lst_DeQueue(targs)) != NULL) {
	CompatMake(gn, gn);

	if (gn->made == UPTODATE)
	    printf("`%s' is up to date.\n", gn->name);
	else if (gn->made == ABORTED) {
	    printf("`%s' not remade because of errors.\n", gn->name);
	    errors += 1;
	}
    }

    /* If the user has defined a .END target, run its commands.  */
    if (errors == 0)
	Lst_ForEachNodeWhile(&ENDNode->commands, CompatRunCommand, ENDNode);
@


1.55
log
@first step towards sanity: take the functions common to parallel/not parallel
make outside of make.c and job.c, and create an engine.c file to hold them.
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.54 2007/09/16 09:46:14 espie Exp $	*/
d469 1
a469 1
		printf("update time: %s\n", Targ_FmtTime(gn->mtime));
@


1.54
log
@remove dead code: #define RECHECK is always on
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.51 2007/01/04 17:55:35 espie Exp $	*/
d54 1
a54 1
#include "job.h"
@


1.53
log
@everywhere except in Var_Parse, we always add/append variables to the
VAR_GLOBAL context, so make it the common case: rename the basic functions
to Var_Set_with_ctxt/Var_Append_with_ctxt, define Var_Set and Var_Append
as macros that specify VAR_GLOBAL, and use these.

okay miod@@
@
text
@a446 28
#ifndef RECHECK
	    /* We can't re-stat the thing, but we can at least take care of
	     * rules where a target depends on a source that actually creates
	     * the target, but only if it has changed, e.g.
	     *
	     * parse.h : parse.o
	     *
	     * parse.o : parse.y
	     *		yacc -d parse.y
	     *		cc -c y.tab.c
	     *		mv y.tab.o parse.o
	     *		cmp -s y.tab.h parse.h || mv y.tab.h parse.h
	     *
	     * In this case, if the definitions produced by yacc haven't
	     * changed from before, parse.h won't have been updated and
	     * gn->mtime will reflect the current modification time for
	     * parse.h. This is something of a kludge, I admit, but it's a
	     * useful one..
	     *
	     * XXX: People like to use a rule like
	     *
	     * FRC:
	     *
	     * To force things that depend on FRC to be made, so we have to
	     * check for gn->children being empty as well...  */
	    if (!Lst_IsEmpty(&gn->commands) || Lst_IsEmpty(&gn->children))
		gn->mtime = now;
#else
a469 1
#endif
@


1.52
log
@local is always true, so zap it.
okay miod@@
@
text
@@


1.51
log
@having a function that iterates through node's datum so that we retrieve
the list item with lst_member is non-sensical, create a new function
(Lst_ForEachNodeWhile) that iterates through lstnodes directly and use
it.

Less obfuscated, slightly more efficient...

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.50 2004/04/07 13:11:35 espie Exp $	*/
a171 2
    bool	  local;	/* true if command should be executed
				 * locally */
a271 2
    local = true;

a276 1
	if (local) {
d282 1
a282 3
	} else
	    (void)execv(av[0], av);
	_exit(1);
@


1.50
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.49 2003/06/03 02:56:11 millert Exp $	*/
d78 1
a78 1
static int CompatRunCommand(void *, void *);
d157 1
a157 1
CompatRunCommand(void *cmdp,	/* Command to execute */
a168 1
    LstNode	  cmdNode;	/* Node where current command is located */
d174 1
a174 1
    char	  *cmd = (char *)cmdp;
a181 1
    cmdNode = Lst_Member(&gn->commands, cmd);
d357 1
a357 1
	    Lst_Find(&i->commands, CompatRunCommand, i);
d442 1
a442 1
		Lst_Find(&gn->commands, CompatRunCommand, gn);
d576 1
a576 1
	    Lst_Find(&gn->commands, CompatRunCommand, gn);
d606 1
a606 1
	Lst_Find(&ENDNode->commands, CompatRunCommand, ENDNode);
@


1.49
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.48 2002/07/31 19:29:20 mickey Exp $	*/
d85 1
a85 2
CompatInterrupt(signo)
    int signo;
d106 1
a106 2
shellneed(av)
	char **av;
d157 2
a158 3
CompatRunCommand(cmdp, gnp)
    void *	  cmdp; 	/* Command to execute */
    void *	  gnp;		/* Node from which the command came */
d375 2
a376 3
CompatMake(gnp, pgnp)
    void *	gnp;	    /* The node to make */
    void *	pgnp;	    /* Parent to abort if necessary */
d556 1
a556 2
Compat_Run(targs)
    Lst 	  targs;    /* List of target nodes to re-create */
d558 3
a560 3
    char	  *cp;	    /* Pointer to string of shell meta-characters */
    GNode	  *gn = NULL;/* Current root target */
    int 	  errors;   /* Number of targets not remade due to errors */
@


1.48
log
@use fork, not vfork. seems to fix misterious trapframe trashing on hppa; deraadt@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.47 2002/06/12 06:07:15 mpech Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.47
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.46 2002/01/16 01:28:54 millert Exp $	*/
d286 1
a286 1
    cpid = vfork();
@


1.46
log
@Use the volatile specifier to fix warnings about variables being
clobbered by longjmp / vfork instead of the gcc "(void)&foo;" hack.
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.45 2001/12/02 00:13:16 espie Exp $	*/
d174 2
a175 2
    int 	  cpid; 	/* Child actually found */
    int		  stat; 	/* Status of fork */
@


1.45
log
@Put back the interrupt fixed code, since it's not the issue.
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.44 2001/11/23 23:42:45 deraadt Exp $	*/
a169 1
		  errCheck,	/* Check errors */
d171 1
d177 1
a177 1
    char	  **av; 	/* Argument vector for thing to exec */
a185 6
    /* Avoid clobbered variable warnings by forcing the compiler
     * to ``unregister'' variables.  */
#if __GNUC__
    (void)&av;
    (void)&errCheck;
#endif
@


1.44
log
@back out changes that break kernel compiles.  good testing jobmk install!
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.41 2001/11/17 19:37:53 deraadt Exp $	*/
a79 1
static GNode	    *curTarg = NULL;
d86 3
a88 12
/*-
 *-----------------------------------------------------------------------
 * CompatInterrupt --
 *	Interrupt the creation of the current target and remove it if
 *	it ain't precious.
 *
 * Side Effects:
 *	The target is removed and the process exits. If .INTERRUPT exists,
 *	its commands are run first WITH INTERRUPTS IGNORED..
 *-----------------------------------------------------------------------
 */
static void
d90 1
a90 1
    int     signo;
d92 2
a93 17
    GNode   *gn;

    if (curTarg != NULL && !Targ_Precious(curTarg)) {
	char	  *file = Varq_Value(TARGET_INDEX, curTarg);

	if (!noExecute && eunlink(file) != -1)
	    Error("*** %s removed\n", file);

	/* Run .INTERRUPT only if hit with interrupt signal.  */
	if (signo == SIGINT) {
	    gn = Targ_FindNode(".INTERRUPT", TARG_NOCREATE);
	    if (gn != NULL)
		Lst_Find(&gn->commands, CompatRunCommand, gn);
	}

    }
    _exit(signo);
d321 3
d351 1
a351 1
	    break;
d357 19
a375 1
    return !status;
d457 1
a457 2
	    if (!touchFlag) {
		curTarg = gn;
d459 1
a459 2
		curTarg = NULL;
	    } else
d577 4
a580 8
    if (signal(SIGINT, SIG_IGN) != SIG_IGN)
	signal(SIGINT, CompatInterrupt);
    if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
	signal(SIGTERM, CompatInterrupt);
    if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
	signal(SIGHUP, CompatInterrupt);
    if (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
	signal(SIGQUIT, CompatInterrupt);
@


1.43
log
@Remove broken interrupt handler.
Nothing of what it did is allowed in an interrupt handler.
Rather, just mark that an interrupt occurred, and check for interrupts
in the wait of RunCommand (that's the correct point to check for interrupts
anyways).

Okay miod@@, millert@@ approves (as he's too tired to look at the code)
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.42 2001/11/22 21:18:10 espie Exp $	*/
d80 1
d87 12
a98 3
static volatile sig_atomic_t interrupted;

static void 
d100 1
a100 1
    int signo;
d102 17
a118 2
    if (interrupted != SIGINT)
	interrupted = signo;
a345 3
	if (interrupted)
	    break;

d373 1
a373 1
	    return !status;
d379 1
a379 19
    /* This is reached only if interrupted */
    if (!Targ_Precious(gn)) {
	char	  *file = Varq_Value(TARGET_INDEX, gn);

	if (!noExecute && eunlink(file) != -1)
	    Error("*** %s removed\n", file);
    }
    if (interrupted == SIGINT) {
    	GNode *i = Targ_FindNode(".INTERRUPT", TARG_NOCREATE);
	signal(SIGINT, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
	signal(SIGHUP, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	interrupted = 0;
	if (i != NULL)
	    Lst_Find(&i->commands, CompatRunCommand, i);
	exit(SIGINT);
    }
    exit(interrupted);
d423 3
a425 3
	if (Lst_Member(&gn->iParents, pgn) != NULL && 
	    (pgn->type & OP_IS_SUFFIX))
		Varq_Set(IMPSRC_INDEX, Varq_Value(TARGET_INDEX, gn), pgn);
d461 2
a462 1
	    if (!touchFlag)
d464 2
a465 1
	    else
d550 3
a552 3
	if (Lst_Member(&gn->iParents, pgn) != NULL && 
	    (pgn->type & OP_IS_SUFFIX))
		Varq_Set(IMPSRC_INDEX, Varq_Value(TARGET_INDEX, gn), pgn);
d583 8
a590 4
    signal(SIGINT, CompatInterrupt);
    signal(SIGTERM, CompatInterrupt);
    signal(SIGHUP, CompatInterrupt);
    signal(SIGQUIT, CompatInterrupt);
@


1.42
log
@Explicitly mark nodes whose commands have been filled with
implicit (suffix) rules.  Then, only expand the IMPSRC/< variable
if the node has been marked.

This matches what Single Unix 2 and common sense say: implicit rules
shouldn't count when an explicit rule has been found (an explicit rule
being a full-scale dependency, with some associated commands)

Note that Single Unix leaves the `PREFIX' question open, so we leave
the PREFIX code as it is.

This fixes regression case mk14, which now fails as it should.

This is just a bug-fix. Some more correct (and faster) code should
probably be substituted. Namely, right now, the suffix code is too
greedy, whereas it should test for explicit rules earlier, and not
even bother instantiating implicit rules from templates when they
duplicate actual existing rules.

ok millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.41 2001/11/17 19:37:53 deraadt Exp $	*/
a79 1
static GNode	    *curTarg = NULL;
d86 3
a88 12
/*-
 *-----------------------------------------------------------------------
 * CompatInterrupt --
 *	Interrupt the creation of the current target and remove it if
 *	it ain't precious.
 *
 * Side Effects:
 *	The target is removed and the process exits. If .INTERRUPT exists,
 *	its commands are run first WITH INTERRUPTS IGNORED..
 *-----------------------------------------------------------------------
 */
static void
d90 1
a90 1
    int     signo;
d92 2
a93 17
    GNode   *gn;

    if (curTarg != NULL && !Targ_Precious(curTarg)) {
	char	  *file = Varq_Value(TARGET_INDEX, curTarg);

	if (!noExecute && eunlink(file) != -1)
	    Error("*** %s removed\n", file);

	/* Run .INTERRUPT only if hit with interrupt signal.  */
	if (signo == SIGINT) {
	    gn = Targ_FindNode(".INTERRUPT", TARG_NOCREATE);
	    if (gn != NULL)
		Lst_Find(&gn->commands, CompatRunCommand, gn);
	}

    }
    _exit(signo);
d321 3
d351 1
a351 1
	    break;
d357 19
a375 1
    return !status;
d457 1
a457 2
	    if (!touchFlag) {
		curTarg = gn;
d459 1
a459 2
		curTarg = NULL;
	    } else
d577 4
a580 8
    if (signal(SIGINT, SIG_IGN) != SIG_IGN)
	signal(SIGINT, CompatInterrupt);
    if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
	signal(SIGTERM, CompatInterrupt);
    if (signal(SIGHUP, SIG_IGN) != SIG_IGN)
	signal(SIGHUP, CompatInterrupt);
    if (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
	signal(SIGQUIT, CompatInterrupt);
@


1.41
log
@do not exit() from signal handler
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.40 2001/09/15 18:43:41 mickey Exp $	*/
d423 3
a425 3
	if (Lst_Member(&gn->iParents, pgn) != NULL) {
	    Varq_Set(IMPSRC_INDEX, Varq_Value(TARGET_INDEX, gn), pgn);
	}
d550 3
a552 3
	if (Lst_Member(&gn->iParents, pgn) != NULL) {
	    Varq_Set(IMPSRC_INDEX, Varq_Value(TARGET_INDEX, gn), pgn);
	}
@


1.40
log
@fix a pasto, fix pr 1969
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.39 2001/05/29 12:53:39 espie Exp $	*/
d118 1
a118 1
    exit(signo);
@


1.39
log
@Take includes out of lst.h, re-add what's needed to separate files.
Removes remaining lint stuff from lst.lib.
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.38 2001/05/29 12:17:05 espie Exp $	*/
d633 1
a633 1
	Lst_Find(&ENDNode->commands, CompatRunCommand, gn);
@


1.38
log
@Blech! gcc is a stupid program. Compiling with -fno-builtin shows lots
of missing function declarations.
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.37 2001/05/23 12:34:40 espie Exp $	*/
d48 1
d52 1
@


1.37
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: compat.c,v 1.12 1998/12/05 00:06:27 espie Exp $	*/
d51 1
@


1.36
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d43 26
a68 34
/*-
 * compat.c --
 *	The routines in this file implement the full-compatibility
 *	mode of PMake. Most of the special functionality of PMake
 *	is available in this mode. Things not supported:
 *	    - different shells.
 *	    - friendly variable substitution.
 *
 * Interface:
 *	Compat_Run	    Initialize things for this module and recreate
 *			    thems as need creatin'
 */

#include    <sys/types.h>
#include    <sys/stat.h>
#include    <sys/wait.h>
#include    <ctype.h>
#include    <errno.h>
#include    <signal.h>
#include    <stddef.h>
#include    <stdio.h>
#include    "make.h"
#include    "ohash.h"
#include    "dir.h"
#include    "job.h"

#ifndef lint
#if 0
static char sccsid[] = "@@(#)compat.c	8.2 (Berkeley) 3/19/94";
#else
UNUSED
static char rcsid[] = "$OpenBSD: compat.c,v 1.12 1998/12/05 00:06:27 espie Exp $";
#endif
#endif /* not lint */
d109 1
a109 1
	    gn = Targ_FindNode(".INTERRUPT", NULL, TARG_NOCREATE);
d191 1
a191 1
    Boolean	  silent,	/* Don't print command */
d197 1
a197 1
    ReturnStatus  stat; 	/* Status of fork */
d202 1
a202 1
    Boolean	  local;	/* TRUE if command should be executed
d206 1
a206 1
    static char *shargv[4] = { "/bin/sh" };
d219 1
a219 1
    cmdStart = Var_Subst(cmd, &gn->context, FALSE);
d244 1
a244 1
	    silent = DEBUG(LOUD) ? FALSE : TRUE;
d246 1
a246 1
	    errCheck = FALSE;
d248 1
a248 1
	    doExecute = TRUE;
d311 1
a311 1
    local = TRUE;
d407 1
a407 1
	 * but the -k flag was given, our 'make' field will be set FALSE again.
d410 1
a410 1
	gn->make = TRUE;
d416 1
a416 1
	    pgn->make = FALSE;
d520 1
a520 1
	    if (is_before(gn->mtime, gn->cmtime))
d526 1
a526 1
		pgn->childMade = TRUE;
d530 1
a530 1
	    pgn->make = FALSE;
d545 1
a545 1
	pgn->make = FALSE;
d554 1
a554 1
		pgn->make = FALSE;
d558 1
a558 1
		    pgn->childMade = TRUE;
a571 9
/*-
 *-----------------------------------------------------------------------
 * Compat_Run --
 *	Initialize this mode and start making.
 *
 * Side Effects:
 *	Guess what?
 *-----------------------------------------------------------------------
 */
d594 1
a594 1
    ENDNode = Targ_FindNode(".END", NULL, TARG_CREATE);
d598 1
a598 1
	gn = Targ_FindNode(".BEGIN", NULL, TARG_NOCREATE);
@


1.35
log
@Introduce a few macros to handle timestamps in an abstract way.

Replace the time stamp hash in dir.c with an open hashing structure.

In doing so, remove some nasty casts, simplify code a bit:
Dir_MTime can return a modification time, since make does not make
a distinction between out-of-date and non-existent files.
@
text
@d1 2
a2 1
/*	$OpenBSD: compat.c,v 1.34 2000/09/14 13:46:44 espie Exp $	*/
d53 1
a53 1
 *	    	  	    thems as need creatin'
a55 2
#include    <stddef.h>
#include    <stdio.h>
d62 2
d74 1
a74 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.34 2000/09/14 13:46:44 espie Exp $";
d78 1
a78 2
/*
 * The following array is used to make a fast determination of which
d81 1
a81 2
 * directly by us.
 */
d83 1
a83 1
static char 	    meta[256];
d87 4
a90 4
static void CompatInterrupt __P((int));
static int CompatRunCommand __P((void *, void *));
static void CompatMake __P((void *, void *));
static int shellneed __P((char **av));
a97 3
 * Results:
 *	None.
 *
a100 1
 *
d104 2
a105 2
CompatInterrupt (signo)
    int	    signo;
d109 2
a110 2
    if ((curTarg != NULL) && !Targ_Precious (curTarg)) {
	char 	  *file = Varq_Value(TARGET_INDEX, curTarg);
d112 1
a112 1
	if (!noExecute && eunlink(file) != -1) {
a113 1
	}
d115 1
a115 3
	/*
	 * Run .INTERRUPT only if hit with interrupt signal
	 */
d117 2
a118 2
	    gn = Targ_FindNode(".INTERRUPT", TARG_NOCREATE);
	    if (gn != NULL) {
a119 1
	    }
d123 1
a123 1
    exit (signo);
d125 1
a125 1

d129 1
a129 1
 *	
d131 2
a132 2
 *	Returns 1 if a specified set of arguments 
 *      must be executed by the shell,
d134 1
a134 1
 *      handled internally
a137 1
 *	
d141 1
a141 1
shellneed (av)
d144 1
a144 1
	char *runsh[] = { 
d146 1
a146 1
		"unalias", "unset", "wait", 
d155 1
a155 1
			return (1);
d165 1
a165 1
				return (1);
d172 2
a173 2
		(void) umask(um);
		return (-1);
d176 1
a176 1
	return (0);
d178 1
a178 1

d186 1
a186 1
 *	1 if the command succeeded, 0 if an error occurred.
a189 1
 *
d193 3
a195 3
CompatRunCommand (cmdp, gnp)
    void 	  *cmdp;	/* Command to execute */
    void 	  *gnp;    	/* Node from which the command came */
d197 1
a197 1
    char    	  *cmdStart;	/* Start of expanded command */
d199 2
a200 2
    Boolean 	  silent,   	/* Don't print command */
		  errCheck, 	/* Check errors */
d202 7
a208 7
    int 	  reason;   	/* Reason for child's death */
    int	    	  status;   	/* Description of child's death */
    int	    	  cpid;	    	/* Child actually found */
    ReturnStatus  stat;	    	/* Status of fork */
    LstNode 	  cmdNode;  	/* Node where current command is located */
    char    	  **av;	    	/* Argument vector for thing to exec */
    int	    	  argc;	    	/* Number of arguments in av or 0 if not
d210 1
a210 1
    Boolean 	  local;    	/* TRUE if command should be executed
d212 6
a217 8
    char	  *cmd = (char *) cmdp;
    GNode	  *gn = (GNode *) gnp;
    static char	*shargv[4] = { "/bin/sh" };

    /*
     * Avoid clobbered variable warnings by forcing the compiler
     * to ``unregister'' variables
     */
d219 2
a220 2
    (void) &av;
    (void) &errCheck;
d229 1
a229 2
    /*
     * brk_string will return an argv with a NULL in av[0], thus causing
d232 1
a232 2
     * nothing (is this the right thing to do?).
     */
d238 1
a238 1
    } else {
a239 1
    }
d251 2
a252 2
    	if (*cmd == '@@')
	    silent = TRUE;
d261 1
a261 1
    while (isspace((unsigned char)*cmd))
d264 1
a264 2
    /*
     * Search for meta characters in the command. If there are no meta
d266 1
a266 2
     * command.
     */
d271 2
a272 4
    /*
     * Print the command before echoing if we're not supposed to be quiet for
     * this one. We also print the command if -n given.
     */
d274 1
a274 1
	printf ("%s\n", cmd);
d278 2
a279 4
    /*
     * If we're not supposed to execute any commands, this is as far as
     * we go...
     */
d284 1
a284 2
	/*
	 * If *cp isn't the null character, we hit a "meta" character and
d287 1
a287 2
	 * error.
	 */
d289 1
a289 1
	shargv[1] = (errCheck ? "-ec" : "-c");
d291 1
a291 1
	shargv[3] = (char *)NULL;
d295 5
a299 7
	/*
	 * No meta-characters, so probably no need to exec a shell. 
	 * Break the command into words to form an argument vector 
	 * we can execute.
	 */
	av = brk_string(cmd, &argc, TRUE, &bp);
	switch(shellneed(av)) {
d305 1
a305 1
		shargv[1] = (errCheck ? "-ec" : "-c");
d307 2
a308 1
		shargv[3] = (char *)NULL;
a309 1
		free(av);
d321 1
a321 3
    /*
     * Fork and execute the single command. If the fork fails, we abort.
     */
d323 1
a323 1
    if (cpid < 0) {
a324 1
    }
d329 1
a329 1
	    	fprintf(stderr, "%s: not found\n", av[0]);
d332 1
a332 1
	} else {
a333 1
	}
d337 1
a337 1
    	free(av);
d343 1
a343 3
    /*
     * The child is off and running. Now all we can do is wait...
     */
d347 1
a347 1
	    if (stat == -1 && errno != EINTR) {
a348 1
	    }
d351 2
a352 2
	if (stat > -1) {
	    if (WIFSTOPPED(reason)) {
d354 1
a354 1
	    } else if (WIFEXITED(reason)) {
d356 2
a357 3
		if (status != 0) {
		    printf ("*** Error code %d", status);
		}
d360 1
a360 1
		printf ("*** Signal %d", status);
d364 1
a364 1
	    if (!WIFEXITED(reason) || (status != 0)) {
d367 4
a370 7
		    if (keepgoing) {
			/*
			 * Abort the current target, but let others
			 * continue.
			 */
			printf (" (continuing)\n");
		    }
d372 3
a374 5
		    /*
		     * Continue executing commands for this target.
		     * If we return 0, this will happen...
		     */
		    printf (" (ignored)\n");
d379 2
a380 2
	} else {
	    Fatal ("error in wait: %d", stat);
a381 1
	}
d386 1
a386 1

a393 1
 *
d398 2
a399 2
    void *gnp;	    /* The node to make */
    void *pgnp;	    /* Parent to abort if necessary */
d401 2
a402 2
    GNode *gn = (GNode *) gnp;
    GNode *pgn = (GNode *) pgnp;
d412 1
a412 2
	/*
	 * First mark ourselves to be made, then apply whatever transformations
d417 1
a417 2
	 * parent as well.
	 */
d420 1
a420 1
	Suff_FindDeps (gn);
d428 1
a428 1
	if (Lst_Member(&gn->iParents, pgn) != NULL)
d430 1
d432 1
a432 2
	/*
	 * All the children were made ok. Now cmtime contains the modification
d435 2
a436 3
	 * Make_OODate function.
	 */
	if (DEBUG(MAKE)) {
a437 1
	}
d440 1
a440 1
	    if (DEBUG(MAKE)) {
a441 1
	    }
d443 1
a443 1
	} else if (DEBUG(MAKE)) {
a444 1
	}
d446 4
a449 7
	/*
	 * If the user is just seeing if something is out-of-date, exit now
	 * to tell him/her "yes".
	 */
	if (queryFlag) {
	    exit (-1);
	}
d451 1
a451 2
	/*
	 * We need to be re-made. We also have to make sure we've got a $?
d453 1
a453 2
	 * Make_DoAllVar().
	 */
d456 3
a458 5
	/*
	 * Alter our type to tell if errors should be ignored or things
	 * should not be printed so CompatRunCommand knows what to do.
	 */
	if (Targ_Ignore (gn)) {
d460 1
a460 2
	}
	if (Targ_Silent (gn)) {
a461 1
	}
d463 3
a465 5
	if (Job_CheckCommands (gn, Fatal)) {
	    /*
	     * Our commands are ok, but we still have to worry about the -t
	     * flag...
	     */
d470 3
a472 4
	    } else {
		Job_Touch (gn, gn->type & OP_SILENT);
	    }
	} else {
a473 1
	}
d476 1
a476 2
	    /*
	     * If the node was made successfully, mark it so, update
d479 1
a479 2
	     * This is to keep its state from affecting that of its parent.
	     */
d482 1
a482 2
	    /*
	     * We can't re-stat the thing, but we can at least take care of
d489 4
a492 4
	     *  	yacc -d parse.y
	     *  	cc -c y.tab.c
	     *  	mv y.tab.o parse.o
	     *  	cmp -s y.tab.h parse.h || mv y.tab.h parse.h
d505 2
a506 3
	     * check for gn->children being empty as well...
	     */
	    if (!Lst_IsEmpty(&gn->commands) || Lst_IsEmpty(&gn->children)) {
a507 1
	    }
d509 1
a509 2
	    /*
	     * This is what Make does and it's actually a good thing, as it
d530 1
a530 1
	    if (DEBUG(MAKE)) {
a531 1
	    }
d537 1
a537 1
	} else if (keepgoing) {
d539 2
a540 1
	} else {
d542 2
a543 2
		printf("\n\nStop in %s (line %lu of %s).\n", 
			Var_Value(".CURDIR", VAR_GLOBAL), 
d547 2
a548 2
		printf("\n\nStop in %s.\n", Var_Value(".CURDIR", VAR_GLOBAL));
	    exit (1);
d550 3
a552 5
    } else if (gn->made == ERROR) {
	/*
	 * Already had an error when making this beastie. Tell the parent
	 * to abort.
	 */
d554 2
a555 2
    } else {
	if (Lst_Member(&gn->iParents, pgn) != NULL)
d557 2
a558 1
	switch(gn->made) {
d571 1
a571 1
		if ((gn->type & OP_EXEC) == 0) {
a572 1
		}
d579 1
a579 1

a584 3
 * Results:
 *	None.
 *
a586 1
 *
d591 1
a591 1
    Lst	    	  targs;    /* List of target nodes to re-create */
d593 3
a595 3
    char    	  *cp;	    /* Pointer to string of shell meta-characters */
    GNode   	  *gn = NULL;/* Current root target */
    int	    	  errors;   /* Number of targets not remade due to errors */
d597 1
a597 1
    if (signal(SIGINT, SIG_IGN) != SIG_IGN) {
d599 1
a599 2
    }
    if (signal(SIGTERM, SIG_IGN) != SIG_IGN) {
d601 1
a601 2
    }
    if (signal(SIGHUP, SIG_IGN) != SIG_IGN) {
d603 1
a603 2
    }
    if (signal(SIGQUIT, SIG_IGN) != SIG_IGN) {
a604 1
    }
d606 1
a606 1
    for (cp = "#=|^(){};&<>*?[]:$`\\\n"; *cp != '\0'; cp++) {
d608 1
a608 4
    }
    /*
     * The null character serves as a sentinel in the string.
     */
d611 3
a613 5
    ENDNode = Targ_FindNode(".END", TARG_CREATE);
    /*
     * If the user has defined a .BEGIN target, execute the commands attached
     * to it.
     */
d615 1
a615 1
	gn = Targ_FindNode(".BEGIN", TARG_NOCREATE);
d618 4
a621 4
            if (gn->made == ERROR) {
                printf("\n\nStop.\n");
                exit(1);
            }
d625 1
a625 2
    /*
     * For each entry in the list of targets to create, call CompatMake on
d629 2
a630 2
     *	    MADE  	    gn was recreated successfully
     *	    ERROR 	    An error occurred while gn was being created
d632 1
a632 2
     *	    	  	    could not be made due to errors.
     */
d637 4
a640 4
	if (gn->made == UPTODATE) {
	    printf ("`%s' is up to date.\n", gn->name);
	} else if (gn->made == ABORTED) {
	    printf ("`%s' not remade because of errors.\n", gn->name);
d645 2
a646 4
    /*
     * If the user has defined a .END target, run its commands.
     */
    if (errors == 0) {
a647 1
    }
@


1.34
log
@Replace the old hash used to hold file names within a directory with
open hashing.

An interesting optimization is that the open hashing interface is more
fine-grained, hence we can compute the correct hash value at the start
of Dir_FindFile, and reuse it for each hash structure into which we look
(the effect is measurable on large directories along with objdir/VPATH).

Remove a few unnecessary Lst_Open/Lst_Close that serve no purpose except
obfuscating the code.

The interface to dir.h changes slightly, hence tedious includes changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.33 2000/09/14 13:32:06 espie Exp $	*/
d73 1
a73 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.33 2000/09/14 13:32:06 espie Exp $";
d446 1
a446 1
	(void) Dir_MTime(gn);
d592 1
a592 1
	    if (noExecute || Dir_MTime(gn) == FALSE) {
d594 1
a594 2
	    }
	    if (gn->cmtime > gn->mtime)
@


1.33
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.32 2000/06/30 23:26:25 espie Exp $	*/
d55 1
d64 1
a64 1
#include    "hash.h"
d73 1
a73 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.32 2000/06/30 23:26:25 espie Exp $";
@


1.32
log
@Recognize `+cmd' as a command that should always be executed, even in
make -n mode.

Currently works only in sequential make mode. In parallel make mode,
it's just a no-op.

Useful to debug recursive Makefiles, and part of POSIX.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.31 2000/06/23 16:21:43 espie Exp $	*/
a41 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)compat.c	8.2 (Berkeley) 3/19/94";
#else
static char rcsid[] = "$OpenBSD: compat.c,v 1.31 2000/06/23 16:21:43 espie Exp $";
#endif
#endif /* not lint */

d66 9
@


1.31
log
@In various places, VAR_CMD is used to actually mean `no real context',
since lookup will start with VAR_CMD in any case.
This fixes VarFind and Var_Parse to handle ctxt == NULL correctly, and
replace those confusing VAR_CMD with proper NULL pointers.

This patch also handles three small details:
- .CURDIR is necessarily set in VAR_GLOBAL,
- suffix handling for archives copies two hard-coded variables, for
which it can use a quick path,
- typos in TargFreeGN.

Reviewed millert@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.30 2000/06/23 16:20:01 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.30 2000/06/23 16:20:01 espie Exp $";
d209 2
a210 1
		  errCheck; 	/* Check errors */
d235 1
d264 2
a265 2
    while ((*cmd == '@@') || (*cmd == '-')) {
	if (*cmd == '@@') {
d267 1
a267 1
	} else {
d269 4
a272 2
	}
	cmd++;
d300 1
a300 1
    if (noExecute)
@


1.30
log
@Once those special variable are taken care of, other Var functions can take
the GNode's context directly.  We rename that special Lst to `SymTable *'
in prevision of things to come.

Along the line, we lose the special GNodes affected to VAR_CMD, VAR_GLOBAL,
VAR_ENV, which become simple Lsts... This is not a problem, except when
getting to a context's name for debugging (handled very nicely by
offsetof).

Again, this is a preparatory patch, which does not gain anything except
for cleaning up issues...

Reviewed by millert@@ and miod@@, like the previous patch
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.29 2000/06/23 16:18:08 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.29 2000/06/23 16:18:08 espie Exp $";
d604 1
a604 1
			Var_Value(".CURDIR", &gn->context), 
d608 1
a608 1
		printf("\n\nStop in %s.\n", Var_Value(".CURDIR", &gn->context));
@


1.29
log
@Start of variable fixes and speed-ups.

This patch may seem a bit non-sensical at first. It simply introduces some
new interface. Specifically, recognizes that some variable names
(.TARGET/$@@, .OODATE/$?, .ALLSRC/$>, .IMPSRC/$<, .PREFIX/$*, .ARCHIVE/$!,
.MEMBER/$%) are `special' (the actual variables which are local to a
target, e.g. GNode).

Currently, The Varq functions (for Varquick access) are only stubs to the
normal functions.

This fixes a very important detail before proceeding to turn variable lists
into hash tables: if every GNode holds a hash table, initialization times
for those will be very costly. But generic GNodes only hold those seven
special variables... which can be stored directly into a small array;
the only general cases are the environment, the command line and
global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.28 2000/06/17 14:38:14 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.28 2000/06/17 14:38:14 espie Exp $";
d236 1
a236 1
    cmdStart = Var_Subst(cmd, gn, FALSE);
d604 1
a604 1
			Var_Value(".CURDIR", gn), 
d608 1
a608 1
		printf("\n\nStop in %s.\n", Var_Value(".CURDIR", gn));
@


1.28
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.27 2000/06/10 01:41:05 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.27 2000/06/10 01:41:05 espie Exp $";
d113 1
a113 1
	char 	  *file = Var_Value(TARGET, curTarg);
d465 2
a466 3
	if (Lst_Member(&gn->iParents, pgn) != NULL) {
	    Var_Set(IMPSRC, Var_Value(TARGET, gn), pgn);
	}
d619 1
a619 1
	    Var_Set (IMPSRC, Var_Value(TARGET, gn), pgn);
@


1.27
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.26 2000/06/10 01:32:22 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.26 2000/06/10 01:32:22 espie Exp $";
d125 1
a125 1
		Lst_Find(gn->commands, CompatRunCommand, gn);
d235 1
a235 1
    cmdNode = Lst_Member(gn->commands, cmd);
d255 1
a255 1
	Lst_AtEnd(ENDNode->commands, cmdStart);
d458 1
a458 1
	Lst_ForEach(gn->children, CompatMake, gn);
d465 1
a465 1
	if (Lst_Member (gn->iParents, pgn) != NULL) {
d521 1
a521 1
		Lst_Find(gn->commands, CompatRunCommand, gn);
d565 1
a565 1
	    if (!Lst_IsEmpty(gn->commands) || Lst_IsEmpty(gn->children)) {
d619 1
a619 1
	if (Lst_Member (gn->iParents, pgn) != NULL)
d694 1
a694 1
	    Lst_Find(gn->commands, CompatRunCommand, gn);
d728 1
a728 1
	Lst_Find(ENDNode->commands, CompatRunCommand, gn);
@


1.26
log
@Thus, Lst_ForEach no longer needs returning a status.
In fact, it can become a macro based on Lst_ForEachFrom.
This also introduces Lst_Every, as a shortcut for the very common case where
Lst_ForEach does not need any user data.

Finally,  make consistent use of a few function typedefs, instead of having
explicit void (*)(Lst)  arguments all over the place.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.25 2000/06/10 01:26:36 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.25 2000/06/10 01:26:36 espie Exp $";
d87 2
a88 2
static int CompatRunCommand __P((ClientData, ClientData));
static void CompatMake __P((ClientData, ClientData));
d203 2
a204 2
    ClientData    cmdp;	    	/* Command to execute */
    ClientData    gnp;    	/* Node from which the command came */
d433 2
a434 2
    ClientData	gnp;	    /* The node to make */
    ClientData  pgnp;	    /* Parent to abort if necessary */
@


1.25
log
@Lst_Find and Lst_ForEach do the same thing, except that the comparison
sense is reversed (Lst_Find  returns when proc says 0, whereas Lst_ForEach
goes on while proc says 0).

This patch turns a number of Lst_ForEach into Lst_Find.
Specifically, all Lst_ForEach that actually may return quickly as proc
does not always returns zero.

Of course, the corresponding proc need to be tweaked to swap 0 and 1...
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.24 2000/04/17 23:54:47 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.24 2000/04/17 23:54:47 espie Exp $";
d88 1
a88 1
static int CompatMake __P((ClientData, ClientData));
a425 3
 * Results:
 *	0
 *
d431 2
a432 2
static int
CompatMake (gnp, pgnp)
d462 1
a462 1
	    return (0);
d483 1
a483 1
	    return (0);
a641 2

    return (0);
d714 1
a714 1
	CompatMake (gn, gn);
@


1.24
log
@Record location in target node as well.
Indicate what went wrong for commands like
	@@exit 1
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.23 2000/03/26 16:21:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.23 2000/03/26 16:21:32 espie Exp $";
d125 1
a125 1
		Lst_ForEach(gn->commands, CompatRunCommand, gn);
d194 1
a194 1
 *	0 if the command succeeded, 1 if an error occurred.
d248 1
a248 1
	return(0);
d256 1
a256 1
	return(0);
d259 1
a259 1
	return(0);
d296 2
a297 3
    if (noExecute) {
	return (0);
    }
d323 1
a323 1
		return 0;
d418 1
a418 1
    return (status);
d524 1
a524 1
		Lst_ForEach(gn->commands, CompatRunCommand, gn);
d699 1
a699 1
	    Lst_ForEach(gn->commands, CompatRunCommand, gn);
d733 1
a733 1
	Lst_ForEach(ENDNode->commands, CompatRunCommand, gn);
@


1.23
log
@Remove idiotic, braindead casts T* -> void*
They serve no purpose, except hiding potential bugs.

In particular, remove (ClientData) cast from macro, showing potentially
troublesome use of Hashes to store time_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.22 2000/02/02 13:47:47 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.22 2000/02/02 13:47:47 espie Exp $";
d607 7
a613 1
	    printf ("\n\nStop in %s.\n", Var_Value(".CURDIR", gn));
@


1.22
log
@Bug-fix: make should behave sensibly when presented with negative times...

- let *_MTime return booleans, as that's what they're used for, the time_t
is set as a side effect.

- use OUT_OF_DATE for a date starting point, set it at the origin of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.21 2000/02/01 03:23:32 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.21 2000/02/01 03:23:32 deraadt Exp $";
d125 1
a125 1
		Lst_ForEach(gn->commands, CompatRunCommand, (ClientData)gn);
d235 1
a235 1
    cmdNode = Lst_Member (gn->commands, (ClientData)cmd);
d252 1
a252 1
    Lst_Replace (cmdNode, (ClientData)cmdStart);
d255 1
a255 1
	Lst_AtEnd(ENDNode->commands, (ClientData)cmdStart);
d366 1
a366 1
    Lst_Replace(cmdNode, (ClientData)NULL);
d462 1
a462 1
	Lst_ForEach (gn->children, CompatMake, (ClientData)gn);
d525 1
a525 1
		Lst_ForEach (gn->commands, CompatRunCommand, (ClientData)gn);
d694 1
a694 1
	    Lst_ForEach(gn->commands, CompatRunCommand, (ClientData)gn);
d728 1
a728 1
	Lst_ForEach(ENDNode->commands, CompatRunCommand, (ClientData)gn);
@


1.21
log
@no need to extern int errno if errno.h is included
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.20 1999/12/18 21:58:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.20 1999/12/18 21:58:07 espie Exp $";
d591 1
a591 1
	    if (noExecute || Dir_MTime(gn) == 0) {
@


1.20
log
@Nothing ever checks ReturnStatus on Lst_Insert, Lst_Append, Lst_AtFront,
Lst_AtEnd, Lst_Concat, Lst_Remove, Lst_Replace.

Don't bother returning one.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.19 1999/12/18 21:56:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.19 1999/12/18 21:56:07 espie Exp $";
a73 1
extern int errno;
@


1.19
log
@Lst_DeQueue already checks for empty lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.18 1999/12/18 21:53:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.18 1999/12/18 21:53:32 espie Exp $";
d256 1
a256 1
	(void)Lst_AtEnd(ENDNode->commands, (ClientData)cmdStart);
d367 1
a367 1
    Lst_Replace (cmdNode, (ClientData) NULL);
@


1.18
log
@NIL, NILGNODE, etc, are only glorified NULL.
Get rid of them.

Get rid of list.h, nothing uses it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.17 1999/12/16 17:31:51 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.17 1999/12/16 17:31:51 espie Exp $";
d714 1
a714 2
    while (!Lst_IsEmpty (targs)) {
	gn = (GNode *) Lst_DeQueue (targs);
@


1.17
log
@Bugfix: execvp might fail for many reasons.
Perform an explicit ENOENT check to keep the same error message
for known cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.16 1999/12/16 17:27:18 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.16 1999/12/16 17:27:18 espie Exp $";
d85 1
a85 1
static GNode	    *curTarg = NILGNODE;
d113 1
a113 1
    if ((curTarg != NILGNODE) && !Targ_Precious (curTarg)) {
d125 1
a125 1
	    if (gn != NILGNODE) {
d470 1
a470 1
	if (Lst_Member (gn->iParents, pgn) != NILLNODE) {
d527 1
a527 1
		curTarg = NILGNODE;
d618 1
a618 1
	if (Lst_Member (gn->iParents, pgn) != NILLNODE)
d694 1
a694 1
	if (gn != NILGNODE) {
@


1.16
log
@Var_Subst is actually two distinct functions folded into one:
split the function specific to for.c out, and give them more sensible
arguments at the same time.

This makes .for loop handling more efficient, as we have some heuristic
to evaluate the size of the buffer needed...
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.15 1999/12/06 22:28:44 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.15 1999/12/06 22:28:44 espie Exp $";
d353 4
a356 2
	    (void) write (2, av[0], strlen (av[0]));
	    (void) write (2, ": not found\n", sizeof(": not found"));
@


1.15
log
@Extra parameter no longer needed, ditch.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.14 1999/11/14 18:16:22 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.14 1999/11/14 18:16:22 espie Exp $";
d237 1
a237 1
    cmdStart = Var_Subst (NULL, cmd, gn, FALSE);
@


1.14
log
@Fix erroneous free of static storage.
Problem reported by fgsch@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.13 1999/11/10 14:11:49 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.13 1999/11/10 14:11:49 espie Exp $";
d114 1
a114 2
	char	  *p1;
	char 	  *file = Var_Value (TARGET, curTarg, &p1);
a118 1
	efree(p1);
d469 1
a469 3
	    char *p1;
	    Var_Set (IMPSRC, Var_Value(TARGET, gn, &p1), pgn);
	    efree(p1);
d606 1
a606 4
	    char *p1;

	    printf ("\n\nStop in %s.\n", Var_Value(".CURDIR", gn, &p1));
	    efree(p1);
d616 2
a617 5
	if (Lst_Member (gn->iParents, pgn) != NILLNODE) {
	    char *p1;
	    Var_Set (IMPSRC, Var_Value(TARGET, gn, &p1), pgn);
	    efree(p1);
	}
@


1.13
log
@Turn on strict-prototypes, add missing prototypes.
Move main prototype to main.c, as this is not used
from any other file.

Close open bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.12 1998/12/05 00:06:27 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.12 1998/12/05 00:06:27 espie Exp $";
d332 3
@


1.12
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.10 1998/05/12 07:10:01 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.10 1998/05/12 07:10:01 deraadt Exp $";
d90 1
@


1.11
log
@catch more commands that require a shell
@
text
@d117 1
a117 1
	    printf ("*** %s removed\n", file);
d119 1
a119 2
	if (p1)
	    free(p1);
d140 4
a143 2
 *	Returns 1 if a specified line must be executed by the shell,
 *	0 if it can be run via execve, and -1 if the command is a no-op.
d146 1
a146 1
 *	None.
d151 2
a152 2
shellneed (cmd)
	char *cmd;
d156 1
a156 1
		"unalias", "unset", "wait", ":",
d160 1
a160 4
	char **av, **p;
	int ac;

	av = brk_string(cmd, &ac, TRUE);
d162 1
d164 1
a164 1
		if (strcmp(av[1], *p) == 0)
d167 1
a167 1
	if (strcmp(av[1], "umask") == 0) {
d172 2
a173 2
		if (av[2] != NULL) {
			umi = strtol(av[2], &ep, 8);
a176 2
			(void) umask(um);
			return (-1);
d178 4
a181 1
		um = umask(0);
a182 1
		printf("%o\n", um);
d209 1
a209 1
    register char *cp;
a221 1
    int		  internal;	/* Various values.. */
d224 1
d241 1
a241 1
     * brk_string will return an argv with a NULL in av[1], thus causing
a308 1
	static char	*shargv[4] = { "/bin/sh" };
d315 1
a315 1
    } else if ((internal = shellneed(cmd))) {
d317 3
a319 2
	 * This command must be passed by the shell for other reasons..
	 * or.. possibly not at all.
d321 15
a335 5
	static char	*shargv[4] = { "/bin/sh" };

	if (internal == -1) {
		/* Command does not need to be executed */
		return (0);
a336 15

	shargv[1] = (errCheck ? "-ec" : "-c");
	shargv[2] = cmd;
	shargv[3] = (char *)NULL;
	av = shargv;
	argc = 0;
    } else {
	/*
	 * No meta-characters, so no need to exec a shell. Break the command
	 * into words to form an argument vector we can execute.
	 * brk_string sticks our name in av[0], so we have to
	 * skip over it...
	 */
	av = brk_string(cmd, &argc, TRUE);
	av += 1;
d358 4
d469 1
a469 2
	    if (p1)
		free(p1);
d606 4
a609 1
	    printf ("\n\nStop.\n");
d622 1
a622 2
	    if (p1)
		free(p1);
@


1.10
log
@emulate umask inside make, so that the value gets propogated; also ensure
that "exit" gets passed to the shell and make does not attempt to execve()
it.  Other commands will probably come later..
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.9 1998/01/02 05:56:33 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.9 1998/01/02 05:56:33 deraadt Exp $";
d153 7
a159 1
	char **av;
d163 5
a167 2
	if (strcmp(av[1], "exit") == 0)
		return (1);
@


1.9
log
@use _exit()
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.8 1997/04/28 01:52:36 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.8 1997/04/28 01:52:36 millert Exp $";
d138 45
d214 1
d302 17
@


1.8
log
@Back out newer .USE code as it caused problems.  I've done a "make build"
without problems and the problem Theo saw before is gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.7 1997/04/21 08:37:49 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.7 1997/04/21 08:37:49 deraadt Exp $";
d290 1
a290 1
	exit(1);
@


1.7
log
@nope, breaks other things
@
text
@d1 2
a2 2
/*	$OpenBSD: compat.c,v 1.5 1997/04/01 07:28:09 millert Exp $	*/
/*	$NetBSD: compat.c,v 1.18 1997/03/28 22:31:22 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.5 1997/04/01 07:28:09 millert Exp $";
d375 3
a377 1
    if (gn->made == UNMADE) {
a634 6

    /*
     * Expand .USE nodes right now, because they can modify the structure
     * of the tree.
     */
    Lst_Destroy(Make_ExpandUse(targs), NOFREE);
@


1.6
log
@Back out the following change since it introduces an ordering problem:
    in compat mode, expand .USE before evaluating the list of targets,
    instead of doing .USE expansions on demand, because they can cause
    tree restructuring.
@
text
@d370 6
a375 3
    if (gn->type & OP_USE) {
	Make_HandleUse(gn, pgn);
    } else if (gn->made == UNMADE) {
d633 6
@


1.5
log
@Sync with NetBSD (mostly by christos initial substitution/regexp from Der Mouse)

- fix the variable substitution code in make [PR/2748]
      1. change s/a/b/ so that it substitutes the first occurance of the
         pattern on each word, not only the first word.
      2. add flag '1' to the variable substitution so that the substitutions
         get performed only once.

  ***THIS IS AN INCOMPATIBLE CHANGE!***

  Unfortunately there was no way to make things consistent without
  modifying the current behavior. Fortunately none of our Makefiles
  depended on this.

            OLD:

                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4

            NEW:
                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 ba2 ba3 ba4
                S/a/b/1  = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4
                S/a/b/1g = bb1 aa2 aa3 aa4
- add regexp variable substitution via 'C/foo/bar/' [PR/2752]
- add variable quoting via the ${VAR:Q} modifier. This is useful when running
  recursive invocations of make(1):

        make VAR=${VAR:Q}

  will always work... (This may prove useful in the kernel builds...) [PR/2981]
- BSD did not traditionally have <sys/cdefs.h>; use BSD4_4 instead and include
  <sys/param.h> to grab it.
- Don't compile the regex code if MAKE_BOOTSTRAP (from gwr)
- Use explicit .c.o rule in Makefile.boot so that the bootstrap process works.
- Use only integral types in procedure arguments. [buf.c buf.h]
- Include <stdlib.h> to get getenv() prototype on SVR4
- if __STDC__ -> ifdef __STDC__ to appease SVR4
- Define const and volatile for non __STDC__
- Implement snprintf() and vsnprintf() for non BSD4_4 systems.
- Make $MACHINE_ARCH settable from the environment.
- Fix .USE directive problems: (reported by cgd)
    1. ${.*} variables did not get expanded in dependencies.
    2. expanded ${.*} variables in .USE dependencies can cause tree
       restructuring; handle it.
    3. in compat mode, expand .USE before evaluating the list of targets,
       instead of doing .USE expansions on demand, because they can cause
       tree restructuring.
- Add a .MADE directive to indicated that the children of a target are
  up-to-date, even when they are not. This is to simulate our current
  make install behavior with proper dependencies.
- Fix problems in the RE substitution error handling.
- Locate all the children of a node marked as MADE.
- Do not compile-in ${MACHINE} (as per NetBSD PR#3386)
- Disable globbing for targets/dependencies when POSIX is defined.
- Fix globbing so that patterns that don't have a matching number of [] or {}
  don't get expanded. (before the [ case got expanded to nothing!) This is
  disabled.
- Make sure that the children of nodes that are marked .MADE, are marked
  UPTODATE and their timestamps are consistent.
- Don't disable wildcards completely; they are used by other Makefiles.
@
text
@d1 1
a1 1
/*	$OpenBSD: compat.c,v 1.4 1996/11/30 21:08:51 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.4 1996/11/30 21:08:51 millert Exp $";
d370 3
a372 6
    if (pgn->type & OP_MADE) {
	(void) Dir_MTime(gn);
	gn->made = UPTODATE;
    }

    if (gn->made == UNMADE) {
a629 6

    /*
     * Expand .USE nodes right now, because they can modify the structure
     * of the tree.
     */
    Lst_Destroy(Make_ExpandUse(targs), NOFREE);
@


1.4
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 2
a2 2
/*	$OpenBSD: compat.c,v 1.3 1996/06/26 05:36:27 deraadt Exp $	*/
/*	$NetBSD: compat.c,v 1.14 1996/11/06 17:59:01 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.3 1996/06/26 05:36:27 deraadt Exp $";
d369 7
a375 3
    if (gn->type & OP_USE) {
	Make_HandleUse(gn, pgn);
    } else if (gn->made == UNMADE) {
d633 6
@


1.3
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: compat.c,v 1.13 1995/11/22 17:40:00 christos Exp $	*/
/*	$NetBSD: compat.c,v 1.13 1995/11/22 17:40:00 christos Exp $	*/
d44 1
a44 1
static char sccsid[] = "@@(#)compat.c	5.7 (Berkeley) 3/1/91";
d46 1
a46 1
static char rcsid[] = "$OpenBSD: compat.c,v 1.13 1995/11/22 17:40:00 christos Exp $";
d111 1
a111 1
    
d172 1
a172 1
    /* 
d192 1
a192 1
     
d221 1
a221 1
    
d247 1
a247 1
    
d272 1
a272 1
    
d294 1
a294 1
    
d305 1
a305 1
	
d317 2
a318 1
	    } 
a319 1
	    
d396 1
a396 1
	
d430 1
a430 1
		    
d571 1
a571 1
	
d623 4
@


1.2
log
@from christos@@netbsd:
Minor:
    - ${.PREFIX} should never contain a full pathname
    - Fixed gcc -Wall warnings
Major:
    - compatMake is now FALSE. This means that we are now running in
      full pmake mode:
          * rules on dependency lines can be executed in parallel and or
            out of sequence:

            foo: bar baz

            can fire the rule for baz before the rule for bar is fired.
            To enforce bar to be fired before baz, another rule needs to be
            added. [bar: baz]
          * adjacent shell commands in a target are now executed by a single
            invocation of the shell, not one invocation of the shell per line
      (compatMake can be turned off using the -B flag)
    - The -j flag now works... I.e. make -j 4 will fork up to four jobs in
      parallel when it can. The target name is printed before each burst
      of output caused by the target execution as '--- target ---', when j > 1
    - I have changed all the Makefiles so that they work with make -j N, and
      I have tested the whole netbsd by:
          'make -j 4 cleandir; make -j 4 depend; make -j 4; make -j 4 install'
    - I have not compiled or tested this version of make with -DREMOTE.
- Turn compat mode on by default. It gets turned off when the -j without
  the -B flag is specified. [Thus you can use -j 1 to turn it off].
- Fix malloc -> emalloc as Gordon noted.
Updates for POSIX/SVR4 compiling:
arch.c:          Don't require ranlib stuff. Not everybody has it.
dir.c:           SunOS-4 != Solaris; change #ifdef sun to #if sun && !__svr4__
job.c, compat.c: Don't use 'union wait', use int and the W*() macros.
main.c:          Check for uname() == -1; some unames return > 0...
util.c, job.c:   Add signal() with BSD semantics for svr4, don't use bsd
                 sigmask and friends.

from cgd@@netbsd:
pull in make.h.  (PAlloc() now uses emalloc(), which is prototyped in
make.h.  If the prototype is not in scope on the Alpha, I see lots
of "cast to pointer from integer of different size" warnings.)
@
text
@d1 1
d46 1
a46 1
static char rcsid[] = "$NetBSD: compat.c,v 1.13 1995/11/22 17:40:00 christos Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: compat.c,v 1.11 1995/09/27 18:44:38 jtc Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: compat.c,v 1.11 1995/09/27 18:44:38 jtc Exp $";
a113 1
	struct stat st;
d115 1
a115 2
	if (!noExecute && lstat(file, &st) != -1 && !S_ISDIR(st.st_mode) && 
	    unlink(file) != -1) {
d158 1
a158 1
    union wait 	  reason;   	/* Reason for child's death */
d299 1
a299 1
	while ((stat = wait((int *)&reason)) != cpid) {
d307 1
a307 1
		status = reason.w_stopval;		/* stopped */
d309 1
a309 1
		status = reason.w_retcode;		/* exited */
d314 1
a314 1
		status = reason.w_termsig;		/* signaled */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
