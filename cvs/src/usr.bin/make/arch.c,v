head	1.89;
access;
symbols
	OPENBSD_6_2_BASE:1.89
	OPENBSD_6_1:1.87.0.4
	OPENBSD_6_1_BASE:1.87
	OPENBSD_6_0:1.86.0.4
	OPENBSD_6_0_BASE:1.86
	OPENBSD_5_9:1.86.0.2
	OPENBSD_5_9_BASE:1.86
	OPENBSD_5_8:1.85.0.6
	OPENBSD_5_8_BASE:1.85
	OPENBSD_5_7:1.85.0.2
	OPENBSD_5_7_BASE:1.85
	OPENBSD_5_6:1.83.0.4
	OPENBSD_5_6_BASE:1.83
	OPENBSD_5_5:1.82.0.4
	OPENBSD_5_5_BASE:1.82
	OPENBSD_5_4:1.81.0.2
	OPENBSD_5_4_BASE:1.81
	OPENBSD_5_3:1.80.0.2
	OPENBSD_5_3_BASE:1.80
	OPENBSD_5_2:1.79.0.10
	OPENBSD_5_2_BASE:1.79
	OPENBSD_5_1_BASE:1.79
	OPENBSD_5_1:1.79.0.8
	OPENBSD_5_0:1.79.0.6
	OPENBSD_5_0_BASE:1.79
	OPENBSD_4_9:1.79.0.4
	OPENBSD_4_9_BASE:1.79
	OPENBSD_4_8:1.79.0.2
	OPENBSD_4_8_BASE:1.79
	OPENBSD_4_7:1.77.0.2
	OPENBSD_4_7_BASE:1.77
	OPENBSD_4_6:1.75.0.10
	OPENBSD_4_6_BASE:1.75
	OPENBSD_4_5:1.75.0.6
	OPENBSD_4_5_BASE:1.75
	OPENBSD_4_4:1.75.0.4
	OPENBSD_4_4_BASE:1.75
	OPENBSD_4_3:1.75.0.2
	OPENBSD_4_3_BASE:1.75
	OPENBSD_4_2:1.60.0.2
	OPENBSD_4_2_BASE:1.60
	OPENBSD_4_1:1.55.0.6
	OPENBSD_4_1_BASE:1.55
	OPENBSD_4_0:1.55.0.4
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.55.0.2
	OPENBSD_3_9_BASE:1.55
	OPENBSD_3_8:1.54.0.6
	OPENBSD_3_8_BASE:1.54
	OPENBSD_3_7:1.54.0.4
	OPENBSD_3_7_BASE:1.54
	OPENBSD_3_6:1.54.0.2
	OPENBSD_3_6_BASE:1.54
	OPENBSD_3_5:1.53.0.4
	OPENBSD_3_5_BASE:1.53
	OPENBSD_3_4:1.53.0.2
	OPENBSD_3_4_BASE:1.53
	OPENBSD_3_3:1.51.0.6
	OPENBSD_3_3_BASE:1.51
	OPENBSD_3_2:1.51.0.4
	OPENBSD_3_2_BASE:1.51
	OPENBSD_3_1:1.51.0.2
	OPENBSD_3_1_BASE:1.51
	OPENBSD_3_0:1.50.0.2
	OPENBSD_3_0_BASE:1.50
	OPENBSD_2_9_BASE:1.43
	OPENBSD_2_9:1.43.0.2
	OPENBSD_2_8:1.36.0.2
	OPENBSD_2_8_BASE:1.36
	OPENBSD_2_7:1.26.0.2
	OPENBSD_2_7_BASE:1.26
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.89
date	2017.07.24.12.07.46;	author espie;	state Exp;
branches;
next	1.88;
commitid	bLpJT6CSwoqQCjlx;

1.88
date	2017.07.21.09.29.42;	author espie;	state Exp;
branches;
next	1.87;
commitid	3U0haOfJavv5YO4a;

1.87
date	2016.10.21.16.12.38;	author espie;	state Exp;
branches;
next	1.86;
commitid	aLVdeKrJ0t5upS3l;

1.86
date	2015.12.11.21.37.03;	author mmcc;	state Exp;
branches;
next	1.85;
commitid	lBOwsw15IgQPi82D;

1.85
date	2015.01.16.15.36.29;	author deraadt;	state Exp;
branches;
next	1.84;
commitid	UtvDri2GsrO6f1f5;

1.84
date	2015.01.15.22.08.41;	author deraadt;	state Exp;
branches;
next	1.83;
commitid	3Zfox0cl9f9WmmaL;

1.83
date	2014.05.12.19.11.19;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2013.11.22.15.47.35;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2013.04.23.14.32.53;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2012.10.02.10.29.30;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2010.07.19.19.46.43;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2010.02.03.20.45.44;	author miod;	state Exp;
branches;
next	1.76;

1.76
date	2009.08.16.09.53.43;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2007.11.17.16.39.45;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2007.11.10.12.51.40;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2007.11.03.15.30.04;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2007.11.02.17.27.24;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2007.09.17.12.50.59;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2007.09.17.10.06.44;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2007.09.16.12.30.35;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2007.09.16.12.25.12;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2007.09.16.12.09.36;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2007.09.16.11.29.34;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2007.09.16.11.27.05;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2007.09.16.10.14.26;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2007.09.16.09.49.24;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2007.09.16.09.46.14;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2007.07.30.09.51.53;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2007.07.24.18.58.48;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2007.07.24.18.56.15;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2007.07.24.18.52.47;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2007.03.20.03.50.39;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2006.01.20.23.10.19;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2004.04.07.13.11.35;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2003.04.06.22.47.14;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2002.01.30.18.40.26;	author matthieu;	state Exp;
branches;
next	1.50;

1.50
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.07.13.53.22;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.05.11.59.10;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.30.00.43.00;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2001.05.29.12.53.38;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.23.12.34.39;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2001.05.03.13.41.00;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2001.03.02.16.57.26;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2000.11.27.20.37.16;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2000.11.27.20.35.27;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2000.11.27.18.58.10;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2000.11.27.18.43.52;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2000.11.24.14.38.57;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2000.11.24.14.36.33;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2000.10.13.08.30.49;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.14.13.56.14;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.14.13.52.41;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.14.13.46.44;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.14.13.32.05;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.23.16.20.01;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.23.16.18.08;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.23.16.15.49;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.17.14.38.13;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.10.01.41.05;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.26.16.21.32;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2000.02.02.13.47.46;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2000.01.08.09.45.15;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	99.12.19.00.04.24;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	99.12.18.21.58.07;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	99.12.18.21.56.07;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	99.12.18.21.53.32;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	99.12.18.02.11.26;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	99.12.16.17.27.18;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	99.12.06.22.28.43;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	99.10.05.22.06.23;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	99.06.01.17.54.31;	author pefo;	state Exp;
branches;
next	1.14;

1.14
date	98.12.05.00.06.26;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	98.07.13.00.41.34;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.07.02.20.47.25;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.10.13.14.47.14;	author pefo;	state Exp;
branches;
next	1.10;

1.10
date	97.06.17.20.34.43;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	96.11.30.21.08.49;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.10.17.19.08.44;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.09.21.19.36.27;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.09.02.16.04.07;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.07.31.00.01.04;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.03.27.19.32.35;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.22.22.24.43;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.23.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.89
log
@GC old cruft.
noticed and patch Michael W. Bombardieri
@
text
@/*	$OpenBSD: arch.c,v 1.88 2017/07/21 09:29:42 espie Exp $ */
/*	$NetBSD: arch.c,v 1.17 1996/11/06 17:58:59 christos Exp $	*/

/*
 * Copyright (c) 1999,2000 Marc Espie.
 *
 * Extensive code changes for the OpenBSD project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1988, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 *	Once again, cacheing/hashing comes into play in the manipulation
 * of archives. The first time an archive is referenced, all of its members'
 * headers are read and hashed and the archive closed again. All hashed
 * archives are kept in a hash (archives) which is searched each time
 * an archive member is referenced.
 *
 */

#include <ar.h>
#include <assert.h>
#include <ctype.h>
#include <fcntl.h>
#include <limits.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <ohash.h>
#include "config.h"
#include "defines.h"
#include "buf.h"
#include "dir.h"
#include "direxpand.h"
#include "arch.h"
#include "var.h"
#include "targ.h"
#include "memory.h"
#include "gnode.h"
#include "timestamp.h"
#include "lst.h"

#ifdef TARGET_MACHINE
#undef MACHINE
#define MACHINE TARGET_MACHINE
#endif
#ifdef TARGET_MACHINE_ARCH
#undef MACHINE_ARCH
#define MACHINE_ARCH TARGET_MACHINE_ARCH
#endif
#ifdef TARGET_MACHINE_CPU
#undef MACHINE_CPU
#define MACHINE_CPU TARGET_MACHINE_CPU
#endif

static struct ohash archives;	/* Archives we've already examined.  */

typedef struct Arch_ {
	struct ohash members;	/* All the members of this archive, as
				 * struct arch_member entries.  */
	char name[1];		/* Archive name. */
} Arch;

/* Used to get to ar's field sizes.  */
static struct ar_hdr *dummy;
#define AR_NAME_SIZE		(sizeof(dummy->ar_name))
#define AR_DATE_SIZE		(sizeof(dummy->ar_date))

/* Each archive member is tied to an arch_member structure,
 * suitable for hashing.  */
struct arch_member {
	struct timespec mtime;		/* Member modification date.  */
	char date[AR_DATE_SIZE+1];	/* Same, before conversion to numeric
					 * value.  */
	char name[1];			/* Member name.  */
};

static struct ohash_info members_info = {
	offsetof(struct arch_member, name), NULL,
	hash_calloc, hash_free, element_alloc
};

static struct ohash_info arch_info = {
	offsetof(Arch, name), NULL, hash_calloc, hash_free, element_alloc
};



static struct arch_member *new_arch_member(struct ar_hdr *, const char *);
static struct timespec mtime_of_member(struct arch_member *);
static long field2long(const char *, size_t);
static Arch *read_archive(const char *, const char *);

static struct timespec ArchMTimeMember(const char *, const char *, bool);
static FILE *ArchFindMember(const char *, const char *, struct ar_hdr *, const char *);
static void ArchTouch(const char *, const char *);
#if defined(__svr4__) || defined(__SVR4) || \
    (defined(__OpenBSD__) && defined(__ELF__))
#define SVR4ARCHIVES
#endif
static bool parse_archive(Buffer, const char **, Lst, SymTable *);
static void add_archive_node(Lst, const char *);

struct SVR4namelist {
	char *fnametab;		/* Extended name table strings */
	size_t fnamesize;	/* Size of the string table */
};

#ifdef SVR4ARCHIVES
static const char *svr4list = "Archive list";

static char *ArchSVR4Entry(struct SVR4namelist *, const char *, size_t, FILE *);
#endif

static struct arch_member *
new_arch_member(struct ar_hdr *hdr, const char *name)
{
	const char *end = NULL;
	struct arch_member *n;

	n = ohash_create_entry(&members_info, name, &end);
	/* XXX ar entries are NOT null terminated.	*/
	memcpy(n->date, &(hdr->ar_date), AR_DATE_SIZE);
	n->date[AR_DATE_SIZE] = '\0';
	/* Don't compute mtime before it is needed. */
	ts_set_out_of_date(n->mtime);
	return n;
}

static struct timespec
mtime_of_member(struct arch_member *m)
{
	if (is_out_of_date(m->mtime))
		ts_set_from_time_t((time_t) strtoll(m->date, NULL, 10),
		    m->mtime);
	return m->mtime;
}

bool
Arch_ParseArchive(const char **line, Lst nodes, SymTable *ctxt)
{
	bool result;
	BUFFER expand;

	Buf_Init(&expand, MAKE_BSIZE);
	result = parse_archive(&expand, line, nodes, ctxt);
	Buf_Destroy(&expand);
	return result;
}

static void
add_archive_node(Lst nodes, const char *name)
{
	GNode *gn;

	gn = Targ_FindNode(name, TARG_CREATE);
	gn->type |= OP_ARCHV;
	Lst_AtEnd(nodes, gn);
}

static bool
parse_archive(Buffer expand, const char **linePtr, Lst nodeLst, SymTable *ctxt)
{
	const char *cp;    	/* Pointer into line */
	const char *lib;	/* Library-part of specification */
	const char *elib;
	const char *member;    	/* Member-part of specification */
	const char *emember;
	bool subst_lib;

	/* figure out the library name part */
	lib = *linePtr;
	subst_lib = false;

	for (cp = lib; *cp != '(' && *cp != '\0';) {
		if (*cp == '$') {
			if (!Var_ParseSkip(&cp, ctxt))
				return false;
			subst_lib = true;
		} else
			cp++;
	}

	elib = cp;
	if (subst_lib) {
		lib = Var_Substi(lib, elib, ctxt, true);
		elib = lib + strlen(lib);
	}

	if (*cp == '\0') {
		printf("Unclosed parenthesis in archive specification\n");
		return false;
	}
	cp++;
	/* iterate on members, that may be separated by spaces */
	for (;;) {
		/* First skip to the start of the member's name, mark that
		 * place and skip to the end of it (either white-space or
		 * a close paren).  */
		bool subst_member = false;

		while (ISSPACE(*cp))
			cp++;
		member = cp;
		while (*cp != '\0' && *cp != ')' && !ISSPACE(*cp)) {
			if (*cp == '$') {
				if (!Var_ParseSkip(&cp, ctxt))
					return false;
				subst_member = true;
			} else
				cp++;
		}

		/* If the specification ends without a closing parenthesis,
		 * chances are there's something wrong (like a missing
		 * backslash), so it's better to return failure than allow such
		 * things to happen.  */
		if (*cp == '\0' || ISSPACE(*cp)) {
			printf("No closing parenthesis in archive specification\n");
			return false;
		}

		/* If we didn't move anywhere, we must be done.  */
		if (cp == member)
			break;

		emember = cp;

		/* XXX: This should be taken care of intelligently by
		 * SuffExpandChildren, both for the archive and the member
		 * portions.  */

		/* If member contains variables, try and substitute for them.
		 * This will slow down archive specs with dynamic sources, of
		 * course, since we'll be (non-)substituting them three times,
		 * but them's the breaks -- we need to do this since
		 * SuffExpandChildren calls us, otherwise we could assume the
		 * thing would be taken care of later.  */
		if (subst_member) {
			const char *oldMemberName = member;
			const char *result;

			member = Var_Substi(member, emember, ctxt, true);

			/* Now form an archive spec and recurse to deal with
			 * nested variables and multi-word variable values....
			 * The results are just placed at the end of the
			 * nodeLst we're returning.  */
			Buf_Addi(expand, lib, elib);
			Buf_AddChar(expand, '(');
			Buf_AddString(expand, member);
			Buf_AddChar(expand, ')');
			result = Buf_Retrieve(expand);

			if (strchr(member, '$') &&
			    memcmp(member, oldMemberName,
				emember - oldMemberName) == 0) {
				/* Must contain dynamic sources, so we can't
				 * deal with it now.  let SuffExpandChildren
				 * handle it later  */
				add_archive_node(nodeLst, result);
			} else if (!Arch_ParseArchive(&result, nodeLst, ctxt))
				return false;
			Buf_Reset(expand);
		} else if (Dir_HasWildcardsi(member, emember)) {
			LIST  members;
			char  *m;

			Lst_Init(&members);

			Dir_Expandi(member, emember, defaultPath, &members);
			while ((m = Lst_DeQueue(&members)) != NULL) {
				Buf_Addi(expand, lib, elib);
				Buf_AddChar(expand, '(');
				Buf_AddString(expand, m);
				Buf_AddChar(expand, ')');
				free(m);
				add_archive_node(nodeLst, Buf_Retrieve(expand));
				Buf_Reset(expand);
			}
		} else {
			Buf_Addi(expand, lib, elib);
			Buf_AddChar(expand, '(');
			Buf_Addi(expand, member, emember);
			Buf_AddChar(expand, ')');
			add_archive_node(nodeLst, Buf_Retrieve(expand));
			Buf_Reset(expand);
		}
		if (subst_member)
			free((char *)member);

	}

	if (subst_lib)
		free((char *)lib);

	/* We promised the pointer would be set up at the next non-space, so
	 * we must advance cp there before setting *linePtr... (note that on
	 * entrance to the loop, cp is guaranteed to point at a ')') */
	do {
		cp++;
	} while (ISSPACE(*cp));

	*linePtr = cp;
	return true;
}

/* Helper function: ar fields are not null terminated.	*/
static long
field2long(const char *field, size_t length)
{
	static char enough[32];

	assert(length < sizeof(enough));
	memcpy(enough, field, length);
	enough[length] = '\0';
	return strtol(enough, NULL, 10);
}

static Arch *
read_archive(const char *archive, const char *earchive)
{
	FILE *arch;       /* Stream to archive */
	char magic[SARMAG];
	Arch *ar;
	struct SVR4namelist list;

	list.fnametab = NULL;

	/* When we encounter an archive for the first time, we read its
	 * whole contents, to place it in the cache.  */
	arch = fopen(archive, "r");
	if (arch == NULL)
		return NULL;

	/* Make sure this is an archive we can handle.  */
	if ((fread(magic, SARMAG, 1, arch) != 1) ||
	    (strncmp(magic, ARMAG, SARMAG) != 0)) {
		fclose(arch);
		return NULL;
	}

	ar = ohash_create_entry(&arch_info, archive, &earchive);
	ohash_init(&ar->members, 8, &members_info);

	for (;;) {
		size_t n;
		struct ar_hdr arHeader;	/* Archive-member header */
		off_t size;		/* Size of archive member */
		char buffer[PATH_MAX];
		char *memberName; 	/* Current member name while hashing. */
		char *cp;

		memberName = buffer;
		n = fread(&arHeader, 1, sizeof(struct ar_hdr), arch);

		/*  Whole archive read ok.  */
		if (n == 0 && feof(arch)) {
			free(list.fnametab);
			fclose(arch);
			return ar;
		}
		if (n < sizeof(struct ar_hdr))
			break;

		if (memcmp(arHeader.ar_fmag, ARFMAG, sizeof(arHeader.ar_fmag))
		    != 0) {
			/* header is bogus.  */
			break;
		} else {
			/* We need to advance the stream's pointer to the start
			 * of the next header.  Records are padded with
			 * newlines to an even-byte boundary, so we need to
			 * extract the size of the record and round it up
			 * during the seek.  */
			size = (off_t) field2long(arHeader.ar_size,
			    sizeof(arHeader.ar_size));

			(void)memcpy(memberName, arHeader.ar_name,
			    AR_NAME_SIZE);
			/* Find real end of name (strip extranous ' ')  */
			for (cp = memberName + AR_NAME_SIZE - 1; *cp == ' ';)
				cp--;
			cp[1] = '\0';

#ifdef SVR4ARCHIVES
			/* SVR4 names are slash terminated.  Also svr4 extended
			 * AR format.
			 */
			if (memberName[0] == '/') {
				/* SVR4 magic mode.  */
				memberName = ArchSVR4Entry(&list, memberName,
				    size, arch);
				if (memberName == NULL)
					/* Invalid data */
					break;
				else if (memberName == svr4list)
					/* List of files entry */
					continue;
				/* Got the entry.  */
				/* XXX this assumes further processing, such as
				 * AR_EFMT1, also applies to SVR4ARCHIVES.  */
			}
			else {
				if (cp[0] == '/')
					cp[0] = '\0';
			}
#endif

#ifdef AR_EFMT1
			/* BSD 4.4 extended AR format: #1/<namelen>, with name
			 * as the first <namelen> bytes of the file.  */
			if (memcmp(memberName, AR_EFMT1, sizeof(AR_EFMT1) - 1)
			    == 0 && ISDIGIT(memberName[sizeof(AR_EFMT1) - 1])) {

				int elen = atoi(memberName +
				    sizeof(AR_EFMT1)-1);

				if (elen <= 0 || elen >= PATH_MAX)
					break;
				memberName = buffer;
				if (fread(memberName, elen, 1, arch) != 1)
					break;
				memberName[elen] = '\0';
				if (fseek(arch, -elen, SEEK_CUR) != 0)
					break;
				if (DEBUG(ARCH) || DEBUG(MAKE))
					printf("ArchStat: Extended format entry for %s\n",
					    memberName);
			}
#endif

			ohash_insert(&ar->members,
			    ohash_qlookup(&ar->members, memberName),
				new_arch_member(&arHeader, memberName));
		}
		if (fseek(arch, (size + 1) & ~1, SEEK_CUR) != 0)
			break;
	}

	fclose(arch);
	ohash_delete(&ar->members);
	free(list.fnametab);
	free(ar);
	return NULL;
}

/*-
 *-----------------------------------------------------------------------
 * ArchMTimeMember --
 *	Find the modification time of an archive's member, given the
 *	path to the archive and the path to the desired member.
 *
 * Results:
 *	The archive member's modification time, or OUT_OF_DATE if member
 *	was not found (convenient, so that missing members are always
 *	out of date).
 *
 * Side Effects:
 *	Cache the whole archive contents if hash is true.
 *-----------------------------------------------------------------------
 */
static struct timespec
ArchMTimeMember(
    const char *archive,	/* Path to the archive */
    const char *member, 	/* Name of member. If it is a path, only the
				 * last component is used. */
    bool hash)       		/* true if archive should be hashed if not
				 * already so. */
{
	FILE *arch;     	/* Stream to archive */
	Arch *ar;		/* Archive descriptor */
	unsigned int slot;	/* Place of archive in the archives hash */
	const char *end = NULL;
	const char *cp;
	struct timespec result;

	ts_set_out_of_date(result);
	/* Because of space constraints and similar things, files are archived
	 * using their final path components, not the entire thing, so we need
	 * to point 'member' to the final component, if there is one, to make
	 * the comparisons easier...  */
	cp = strrchr(member, '/');
	if (cp != NULL)
		member = cp + 1;

	/* Try to find archive in cache.  */
	slot = ohash_qlookupi(&archives, archive, &end);
	ar = ohash_find(&archives, slot);

	/* If not found, get it now.  */
	if (ar == NULL) {
		if (!hash) {
			/* Quick path:  no need to hash the whole archive, just
			 * use ArchFindMember to get the member's header and
			 * close the stream again.  */
			struct ar_hdr arHeader;

			arch = ArchFindMember(archive, member, &arHeader, "r");

			if (arch != NULL) {
				fclose(arch);
				ts_set_from_time_t(
				    (time_t)strtol(arHeader.ar_date, NULL, 10),
				    result);
			}
			return result;
		}
		ar = read_archive(archive, end);
		if (ar != NULL)
			ohash_insert(&archives, slot, ar);
	}

	/* If archive was found, get entry we seek.  */
	if (ar != NULL) {
		struct arch_member *he;
		end = NULL;

		he = ohash_find(&ar->members, ohash_qlookupi(&ar->members,
		    member, &end));
		if (he != NULL)
			return mtime_of_member(he);
		else {
			if ((size_t)(end - member) > AR_NAME_SIZE) {
				/* Try truncated name.	*/
				end = member + AR_NAME_SIZE;
				he = ohash_find(&ar->members,
				    ohash_qlookupi(&ar->members, member, &end));
				if (he != NULL)
					return mtime_of_member(he);
			}
		}
	}
	return result;
}

#ifdef SVR4ARCHIVES
/*-
 *-----------------------------------------------------------------------
 * ArchSVR4Entry --
 *	Parse an SVR4 style entry that begins with a slash.
 *	If it is "//", then load the table of filenames
 *	If it is "/<offset>", then try to substitute the long file name
 *	from offset of a table previously read.
 *
 * Results:
 *	svr4list: just read a list of names
 *	NULL:	  error occurred
 *	extended name
 *
 * Side-effect:
 *	For a list of names, store the list in l.
 *-----------------------------------------------------------------------
 */

static char *
ArchSVR4Entry(struct SVR4namelist *l, const char *name, size_t size, FILE *arch)
{
#define ARLONGNAMES1 "/"
#define ARLONGNAMES2 "ARFILENAMES"
	size_t entry;
	char *ptr, *eptr;

	assert(name[0] == '/');
	name++;
	/* First comes a table of archive names, to be used by subsequent
	 * calls.  */
	if (memcmp(name, ARLONGNAMES1, sizeof(ARLONGNAMES1) - 1) == 0 ||
	    memcmp(name, ARLONGNAMES2, sizeof(ARLONGNAMES2) - 1) == 0) {

		if (l->fnametab != NULL) {
			if (DEBUG(ARCH))
				printf("Attempted to redefine an SVR4 name table\n");
			return NULL;
		}

		l->fnametab = emalloc(size);
		l->fnamesize = size;

		if (fread(l->fnametab, size, 1, arch) != 1) {
			if (DEBUG(ARCH))
				printf("Reading an SVR4 name table failed\n");
			return NULL;
		}

		eptr = l->fnametab + size;
		for (entry = 0, ptr = l->fnametab; ptr < eptr; ptr++)
			switch (*ptr) {
			case '/':
				entry++;
				*ptr = '\0';
				break;

			case '\n':
				break;

			default:
				break;
			}
		if (DEBUG(ARCH))
			printf("Found svr4 archive name table with %zu entries\n",
			    entry);
		return (char *)svr4list;
	}
	/* Then the names themselves are given as offsets in this table.  */
	if (*name == ' ' || *name == '\0')
		return NULL;

	entry = (size_t) strtol(name, &eptr, 0);
	if ((*eptr != ' ' && *eptr != '\0') || eptr == name) {
		if (DEBUG(ARCH))
			printf("Could not parse SVR4 name /%s\n", name);
		return NULL;
	}
	if (entry >= l->fnamesize) {
		if (DEBUG(ARCH))
			printf("SVR4 entry offset /%s is greater than %zu\n",
			    name, l->fnamesize);
		return NULL;
	}

	if (DEBUG(ARCH))
		printf("Replaced /%s with %s\n", name, l->fnametab + entry);

	return l->fnametab + entry;
}
#endif


/*-
 *-----------------------------------------------------------------------
 * ArchFindMember --
 *	Locate a member of an archive, given the path of the archive and
 *	the path of the desired member. If the archive is to be modified,
 *	the mode should be "r+", if not, it should be "r".
 *
 * Results:
 *	A FILE *, opened for reading and writing, positioned right after
 *	the member's header, or NULL if the member was nonexistent.
 *
 * Side Effects:
 *	Fill the struct ar_hdr pointed by arHeaderPtr.
 *-----------------------------------------------------------------------
 */
static FILE *
ArchFindMember(
    const char	  *archive,   /* Path to the archive */
    const char	  *member,    /* Name of member. If it is a path, only the
			       * last component is used. */
    struct ar_hdr *arHeaderPtr,/* Pointer to header structure to be filled in */
    const char	  *mode)      /* mode for opening the stream */
{
	FILE *	  arch;       /* Stream to archive */
	char	  *cp;
	char	  magic[SARMAG];
	size_t	  length;
	struct SVR4namelist list;

	list.fnametab = NULL;

	arch = fopen(archive, mode);
	if (arch == NULL)
		return NULL;

	/* Make sure this is an archive we can handle.  */
	if (fread(magic, SARMAG, 1, arch) != 1 ||
	    strncmp(magic, ARMAG, SARMAG) != 0) {
		fclose(arch);
		return NULL;
	}

	/* Because of space constraints and similar things, files are archived
	 * using their final path components, not the entire thing, so we need
	 * to point 'member' to the final component, if there is one, to make
	 * the comparisons easier...  */
	cp = strrchr(member, '/');
	if (cp != NULL)
		member = cp + 1;

	length = strlen(member);
	if (length >= AR_NAME_SIZE)
		length = AR_NAME_SIZE;

	/* Error handling is simpler than for read_archive, since we just
	 * look for a given member.  */
	while (fread(arHeaderPtr, sizeof(struct ar_hdr), 1, arch) == 1) {
		off_t size;       /* Size of archive member */
		char *memberName;

		if (memcmp(arHeaderPtr->ar_fmag, ARFMAG,
		    sizeof(arHeaderPtr->ar_fmag) ) != 0)
			 /* The header is bogus, so the archive is bad.  */
			 break;

		memberName = arHeaderPtr->ar_name;
		if (memcmp(member, memberName, length) == 0) {
			/* If the member's name doesn't take up the entire
			 * 'name' field, we have to be careful of matching
			 * prefixes. Names are space- padded to the right, so
			 * if the character in 'name' at the end of the matched
			 * string is anything but a space, this isn't the
			 * member we sought.  */
#ifdef SVR4ARCHIVES
			if (length < sizeof(arHeaderPtr->ar_name) &&
			    memberName[length] == '/')
				length++;
#endif
			if (length == sizeof(arHeaderPtr->ar_name) ||
			    memberName[length] == ' ') {
				free(list.fnametab);
				return arch;
			}
		}

		size = (off_t) field2long(arHeaderPtr->ar_size,
		    sizeof(arHeaderPtr->ar_size));

#ifdef SVR4ARCHIVES
		/* svr4 names are slash terminated. Also svr4 extended AR
		 * format.
		 */
		if (memberName[0] == '/') {
			/* svr4 magic mode.  */
			memberName = ArchSVR4Entry(&list, arHeaderPtr->ar_name,
			    size, arch);
			if (memberName == NULL)
				/* Invalid data */
				break;
			else if (memberName == svr4list)
				/* List of files entry */
				continue;
			/* Got the entry.  */
			if (strcmp(memberName, member) == 0) {
				free(list.fnametab);
				return arch;
			}
		}
#endif

#ifdef AR_EFMT1
		/* BSD 4.4 extended AR format: #1/<namelen>, with name as the
		 * first <namelen> bytes of the file.  */
		if (memcmp(memberName, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0 &&
		    ISDIGIT(memberName[sizeof(AR_EFMT1) - 1])) {
			char ename[PATH_MAX];

			int elength = atoi(memberName + sizeof(AR_EFMT1)-1);

			if (elength <= 0 || elength >= PATH_MAX)
				break;
			if (fread(ename, elength, 1, arch) != 1)
				break;
			if (fseek(arch, -elength, SEEK_CUR) != 0)
				break;
			ename[elength] = '\0';
			if (DEBUG(ARCH) || DEBUG(MAKE))
				printf("ArchFind: Extended format entry for %s\n", ename);
			/* Found as extended name.	*/
			if (strcmp(ename, member) == 0) {
				free(list.fnametab);
				return arch;
			}
		}
#endif
		/* This isn't the member we're after, so we need to advance the
		 * stream's pointer to the start of the next header.  */
		if (fseek(arch, (size + 1) & ~1, SEEK_CUR) != 0)
			break;
	}

	/* We did not find the member, or we ran into an error while reading
	 * the archive.  */
#ifdef SVRARCHIVES
	free(list.fnametab);
#endif
	fclose(arch);
	return NULL;
}

static void
ArchTouch(const char *archive, const char *member)
{
	FILE *arch;
	struct ar_hdr arHeader;

	arch = ArchFindMember(archive, member, &arHeader, "r+");
	if (arch != NULL) {
		snprintf(arHeader.ar_date, sizeof(arHeader.ar_date),
		    "%-12ld", (long) time(NULL));
		if (fseek(arch, -sizeof(struct ar_hdr), SEEK_CUR) == 0)
			(void)fwrite(&arHeader, sizeof(struct ar_hdr), 1, arch);
		fclose(arch);
	}
}

/*
 * Side Effects:
 *	The modification time of the entire archive is also changed.
 *	For a library, this could necessitate the re-ranlib'ing of the
 *	whole thing.
 */
void
Arch_Touch(GNode *gn)
{
	ArchTouch(Var(ARCHIVE_INDEX, gn), Var(MEMBER_INDEX, gn));
}

struct timespec
Arch_MTime(GNode *gn)
{
	gn->mtime = ArchMTimeMember(Var(ARCHIVE_INDEX, gn),
	     Var(MEMBER_INDEX, gn), true);

	return gn->mtime;
}

struct timespec
Arch_MemMTime(GNode *gn)
{
	LstNode ln;

	for (ln = Lst_First(&gn->parents); ln != NULL; ln = Lst_Adv(ln)) {
		GNode *pgn;
		char *nameStart;
		char *nameEnd;

		pgn = Lst_Datum(ln);

		if (pgn->type & OP_ARCHV) {
			/* If the parent is an archive specification and is
			 * being made and its member's name matches the name of
			 * the node we were given, record the modification time
			 * of the parent in the child. We keep searching its
			 * parents in case some other parent requires this
			 * child to exist...  */
			if ((nameStart = strchr(pgn->name, '(') ) != NULL) {
				nameStart++;
				nameEnd = strchr(nameStart, ')');
			} else
				nameEnd = NULL;

			if (pgn->must_make && nameEnd != NULL &&
			    strncmp(nameStart, gn->name, nameEnd - nameStart)
			    == 0 && gn->name[nameEnd-nameStart] == '\0')
				gn->mtime = Arch_MTime(pgn);
		} else if (pgn->must_make) {
			/* Something which isn't a library depends on the
			 * existence of this target, so it needs to exist.  */
			ts_set_out_of_date(gn->mtime);
			break;
		}
	}
	return gn->mtime;
}

void
Arch_Init(void)
{
	ohash_init(&archives, 4, &arch_info);
}
@


1.88
log
@fix two nasty out-of-bound accesses that killed (sporadically mk38 and mk38bis.
prodded by bluhm@@, okay bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.87 2016/10/21 16:12:38 espie Exp $ */
d414 1
a414 1
			efree(list.fnametab);
d498 1
a498 1
	efree(list.fnametab);
d765 1
a765 1
				efree(list.fnametab);
d789 1
a789 1
				efree(list.fnametab);
d815 1
a815 1
				efree(list.fnametab);
d829 1
a829 1
	efree(list.fnametab);
@


1.87
log
@small obvious cleanups:
- remove a lot of unnecessary casts
- zap extra param that's no longer needed
- add proper prototype and make function static

okay natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.86 2015/12/11 21:37:03 mmcc Exp $ */
d245 4
d273 1
a273 1
		if (*cp == '\0') {
@


1.86
log
@Use %zu to print size_t's rather than casting to u_long.

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.85 2015/01/16 15:36:29 deraadt Exp $ */
d323 1
a323 1
			while ((m = (char *)Lst_DeQueue(&members)) != NULL) {
d878 1
a878 1
		pgn = (GNode *)Lst_Datum(ln);
@


1.85
log
@switch to <limits.h>; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.84 2015/01/15 22:08:41 deraadt Exp $ */
d652 2
a653 2
			printf("Found svr4 archive name table with %lu entries\n",
			    (u_long)entry);
d668 2
a669 2
			printf("SVR4 entry offset /%s is greater than %lu\n",
			    name, (u_long)l->fnamesize);
@


1.84
log
@If some mythical system lacks PATH_MAX, do not set it to MAXPATHLEN+1
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.83 2014/05/12 19:11:19 espie Exp $ */
a72 1
#include <sys/param.h>
@


1.83
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.82 2013/11/22 15:47:35 espie Exp $ */
a97 8

#ifndef PATH_MAX
# ifdef MAXPATHLEN
#  define PATH_MAX (MAXPATHLEN+1)
# else
#  define PATH_MAX	1024
# endif
#endif
@


1.82
log
@wrappers for is*/to* that make damn sure their arguments are
cast to unsigned chars.

okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.81 2013/04/23 14:32:53 espie Exp $ */
d144 1
a144 1
	hash_alloc, hash_free, element_alloc
d148 1
a148 1
	offsetof(Arch, name), NULL, hash_alloc, hash_free, element_alloc
@


1.81
log
@remove TIMESTAMP abstraction layer, prodded by theo.
while there, clean up includes.
use strtoll for ar timestamps (pretty much unused in reality, more
standard conforming than anything)

use idea from Todd to adapt to time_t being 32 bits OR 64 bits
(pedantically correct: INT_MIN would work just fine up to 1910 or so...)

okay millert@@, gone thru a make build.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.80 2012/10/02 10:29:30 espie Exp $ */
d262 1
a262 1
		while (isspace(*cp))
d265 1
a265 1
		while (*cp != '\0' && *cp != ')' && !isspace(*cp)) {
d362 1
a362 1
	} while (isspace(*cp));
d474 1
a474 1
			    == 0 && isdigit(memberName[sizeof(AR_EFMT1) - 1])) {
d804 1
a804 1
		    isdigit(memberName[sizeof(AR_EFMT1) - 1])) {
@


1.80
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.79 2010/07/19 19:46:43 espie Exp $ */
d80 1
a81 1
#include <stdint.h>
d85 1
a85 1
#include "ohash.h"
d136 1
a136 1
	TIMESTAMP mtime;		/* Member modification date.  */
d154 1
a154 1
static TIMESTAMP mtime_of_member(struct arch_member *);
d158 1
a158 1
static TIMESTAMP ArchMTimeMember(const char *, const char *, bool);
d194 1
a194 1
static TIMESTAMP
d198 1
a198 1
		ts_set_from_time_t((time_t) strtol(m->date, NULL, 10),
d523 1
a523 1
static TIMESTAMP
d536 1
a536 1
	TIMESTAMP result;
d868 1
a868 1
TIMESTAMP
d877 1
a877 1
TIMESTAMP
@


1.79
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.78 2010/07/19 19:30:37 espie Exp $ */
a157 3
#ifdef CLEANUP
static void ArchFree(Arch *);
#endif
a202 10
#ifdef CLEANUP
static void
ArchFree(Arch *a)
{
	/* Free memory from hash entries */
	free_hash(&a->members);
	free(a);
}
#endif

a867 13
/*ARGSUSED*/
void
Arch_TouchLib(GNode *gn UNUSED)
                     /* ^          Non RANLIBMAG does nothing with it */
{
#ifdef RANLIBMAG
	if (gn->path != NULL) {
		ArchTouch(gn->path, RANLIBMAG);
		set_times(gn->path);
	}
#endif
}

a915 76
/* we assume the system knows how to find libraries */
void
Arch_FindLib(GNode *gn, Lst path UNUSED)
{
	Var(TARGET_INDEX, gn) = gn->name;
}

/*-
 *-----------------------------------------------------------------------
 * Arch_LibOODate --
 *	Decide if a node with the OP_LIB attribute is out-of-date. Called
 *	from Make_OODate to make its life easier.
 *
 *	There are several ways for a library to be out-of-date that are
 *	not available to ordinary files. In addition, there are ways
 *	that are open to regular files that are not available to
 *	libraries. A library that is only used as a source is never
 *	considered out-of-date by itself. This does not preclude the
 *	library's modification time from making its parent be out-of-date.
 *	A library will be considered out-of-date for any of these reasons,
 *	given that it is a target on a dependency line somewhere:
 *	    Its modification time is less than that of one of its
 *		  sources (gn->mtime < gn->cmtime).
 *	    Its modification time is greater than the time at which the
 *		  make began (i.e. it's been modified in the course
 *		  of the make, probably by archiving).
 *	    The modification time of one of its sources is greater than
 *		  the one of its RANLIBMAG member (i.e. its table of contents
 *		  is out-of-date). We don't compare of the archive time
 *		  vs. TOC time because they can be too close. In my
 *		  opinion we should not bother with the TOC at all since
 *		  this is used by 'ar' rules that affect the data contents
 *		  of the archive, not by ranlib rules, which affect the
 *		  TOC.
 *
 * Results:
 *	true if the library is out-of-date. false otherwise.
 *
 * Side Effects:
 *	The library will be hashed if it hasn't been already.
 *-----------------------------------------------------------------------
 */
bool
Arch_LibOODate(GNode *gn)
{
#ifdef RANLIBMAG
	TIMESTAMP modTimeTOC;	/* mod time of __.SYMDEF */
#endif

	if (OP_NOP(gn->type) && Lst_IsEmpty(&gn->children))
		return false;
	if (is_strictly_before(now, gn->mtime) ||
	    is_strictly_before(gn->mtime, gn->cmtime) ||
	    is_out_of_date(gn->mtime))
		return true;
#ifdef RANLIBMAG
	/* non existent libraries are always out-of-date.  */
	if (gn->path == NULL)
		return true;
	modTimeTOC = ArchMTimeMember(gn->path, RANLIBMAG, false);

	if (!is_out_of_date(modTimeTOC)) {
		if (DEBUG(ARCH) || DEBUG(MAKE))
			printf("%s modified %s...", RANLIBMAG,
			    time_to_string(modTimeTOC));
		return is_strictly_before(modTimeTOC, gn->cmtime);
	}
	/* A library w/o a table of contents is out-of-date.  */
	if (DEBUG(ARCH) || DEBUG(MAKE))
		printf("No t.o.c....");
	return true;
#else
	return false;
#endif
}

a919 33
}

#ifdef CLEANUP
void
Arch_End(void)
{
	Arch *e;
	unsigned int i;

	for (e = ohash_first(&archives, &i); e != NULL;
	    e = ohash_next(&archives, &i))
		ArchFree(e);
	ohash_delete(&archives);
}
#endif

bool
Arch_IsLib(GNode *gn)
{
	char buf[SARMAG];
	int fd;

	if (gn->path == NULL || (fd = open(gn->path, O_RDONLY)) == -1)
		return false;

	if (read(fd, buf, SARMAG) != SARMAG) {
		(void)close(fd);
		return false;
	}

	(void)close(fd);

	return memcmp(buf, ARMAG, SARMAG) == 0;
@


1.78
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$ */
@


1.77
log
@Add a new default variable in Makefile context, MACHINE_CPU. Its value is
decided at compile-time and is either MACHINE_CPU from <machine/param.h> if
it is defined, or the same value as MACHINE_ARCH otherwise.
This will be used to allow ports with suffixes to their canonical MACHINE_ARCH
to provide this canonical name as MACHINE_CPU, and in turn to let Makefiles
do TRT.
ok kettenis@@
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.76 2009/08/16 09:53:43 espie Exp $ */
@


1.76
log
@modify timestamp handling to grab current time instead of relying on a
stale timestamp.

all those diffs sent to people ages ago, who didn't answer, except for
Theo, who said he ran it with no issues, so let's get this in...
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d115 4
@


1.75
log
@simplify dynamic variable handling a great deal:
first remove all usage of Varq_Append by building the string directly.
then replace `common' handling with specialized handling for dynamic
strings (since they no longer need a buffer). Finally, identify the place
where the variable value needs to be copied because it's going to be free'd
or erased soon, and finally, use simple char* pointers.

Shaves about 80 bytes off every gnode structure, and kills quite a few
unnecessary malloc()s as well.
@
text
@d859 1
a859 1
		    "%-12ld", (long) timestamp2time_t(now));
@


1.74
log
@rename make -> must_make, made -> built_status
to make them easier to find in source files.
@
text
@d875 1
a875 1
	ArchTouch(Varq_Value(ARCHIVE_INDEX, gn), Varq_Value(MEMBER_INDEX, gn));
d894 2
a895 2
	gn->mtime = ArchMTimeMember(Varq_Value(ARCHIVE_INDEX, gn),
	     Varq_Value(MEMBER_INDEX, gn), true);
d943 1
a943 1
	Varq_Set(TARGET_INDEX, gn->name, gn);
@


1.73
log
@#ifdef stuff that is only used under #ifdef; ok espie
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.72 2007/11/02 17:27:24 espie Exp $ */
d925 1
a925 1
			if (pgn->make && nameEnd != NULL &&
d929 1
a929 1
		} else if (pgn->make) {
@


1.72
log
@Work done at p2k7.


This is a really big step towards getting parallel make to work.


Note that this is not yet complete. There are still a few `details' to
fix before this works 100%.  Specifically: sequential make (compat) and
parallel make don't use the same engine, and the parallel engine still
has a few limitations. For instance, some known issues:
- parallel make does not deal with .phony targets correctly all the time.
- some errors are deadly in parallel make mode.
- parallel make NEEDS way more sturdy correspondance of file system paths
and target names, since it often needs to match dependencies to targets
before the corresponding files exist.
- some local variables like $* get set in a bogus way in some cases.
- suffix handling has issues, especially related to the NULL suffix.
So, if you find stuff that does NOT yet work with parallel make, don't go
blindly try to fix the Makefile. It's very likely you might have stumbled
into a make bug. (unless you really, really, understand Makefiles, DON'T
GO CHANGING THEM YET).



Tested by lots of people, thanks go to miod@@, and robert@@ among other people.

Quick summary of what this does:

- remove `saving commands' extension (it's not really usable, nor used)
- move compat job runner and parallel interrupt handling into engine.c
- tweak the code so that both compat and parallel mode use the same job runner
and the same interrupt handling. Remove the other one.
- optimize job runner so that, in parallel mode, the last command does not
fork if we can avoid it (as it's already running in a sub shell).
- scrape all the code that dealt with creating shell scripts from commands.
- scrape all the code that dealt with recognizing special sequences in
command output to print/not print output.
- fix the parallel job pipe to not keep around file descriptors that are not
needed.
- replace the parallel job buffering with a nicer one, that deals with
non-blocking descriptors to try to agregate as much output from one job in
one go (greed) to unconfuse the users.
- create two pipes per job, so that stdout and stderr stay separate.
- make job token printing a debug option.
- always use the parallel job-runner to `execute' commands, even if we just
print them out.
- store list of errors encountered during parallel make running, and print them
on exit, so that we know what went wrong.
- add a dirty hack to targ.c to deal with paths produced by gccmakedep.
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d173 1
d177 1
@


1.71
log
@always define the svr4namelist. Doesn't hurt, even if we don't use it.
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.70 2007/09/17 10:06:44 espie Exp $ */
d937 1
a937 7
/* If the system can handle the -L flag when linking (or we cannot find
 * the library), we assume that the user has placed the .LIBRARIES variable
 * in the final linking command (or the linker will know where to find it)
 * and set the TARGET variable for this node to be the node's name. Otherwise,
 * we set the TARGET variable to be the full path of the library,
 * as returned by Dir_FindFile.
 */
d939 1
a939 1
Arch_FindLib(GNode *gn, Lst path)
a940 10
	char *libName;	/* file name for archive */
	size_t length = strlen(gn->name) + 6 - 2;

	libName = emalloc(length);
	snprintf(libName, length, "lib%s.a", &gn->name[2]);

	gn->path = Dir_FindFile(libName, path);

	free(libName);

@


1.70
log
@fix the arch code mostly.
- stop using sprintf for code that can use our buffers.
- stop modifying parsed line, rely on Var_Substi instead.

to do that, we need to go through an intermediate routine that uses
one single buffer to build archive names.
also introduce an add_archive_node function that makes things way simpler.
also rename a few variables.
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.69 2007/09/17 09:28:36 espie Exp $ */
a167 1
#ifdef SVR4ARCHIVES
a175 1
#endif
a393 1
#ifdef SVR4ARCHIVES
a396 1
#endif
a426 1
#ifdef SVR4ARCHIVES
a427 1
#endif
a510 1
#ifdef SVR4ARCHIVES
a511 1
#endif
a724 1
#ifdef SVR4ARCHIVES
a727 1
#endif
a777 1
#ifdef SVR4ARCHIVES
a778 1
#endif
a827 1
#ifdef SVR4ARCHIVES
a828 1
#endif
@


1.69
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.68 2007/09/16 12:30:35 espie Exp $ */
d89 1
d117 1
a117 1
static struct ohash archives;   /* Archives we've already examined.  */
d121 1
a121 1
			       	 * struct arch_member entries.  */
d133 4
a136 4
	TIMESTAMP mtime;	/* Member modification date.  */
	char date[AR_DATE_SIZE+1];
				/* Same, before conversion to numeric value.  */
	char name[1];		/* Member name.  */
d165 2
d170 2
a171 2
	char *fnametab;  	/* Extended name table strings */
	size_t fnamesize;  	/* Size of the string table */
d213 5
d219 10
d230 4
a233 14
/* Side-effects: Some nodes may be created.  */
bool
Arch_ParseArchive(char **linePtr,   /* Pointer to start of specification */
    Lst nodeLst, 		    /* Lst on which to place the nodes */
    SymTable *ctxt)		    /* Context in which to expand variables */
{
	char *cp;		/* Pointer into line */
	GNode *gn;	    	/* New node */
	char *libName;	    	/* Library-part of specification */
	char *memberName;    	/* Member-part of specification */
	char nameBuf[MAKE_BSIZE]; /* temporary place for node name */
	char saveChar;	    	/* Ending delimiter of member-name */
	bool subLibName;     	/* true if libName should have/had
				 * variable substitution performed on it */
d235 9
a243 1
	libName = *linePtr;
d245 3
a247 1
	subLibName = false;
d249 1
a249 1
	for (cp = libName; *cp != '(' && *cp != '\0';) {
d253 1
a253 1
			subLibName = true;
d258 5
a262 3
	*cp++ = '\0';
	if (subLibName)
		libName = Var_Subst(libName, ctxt, true);
d264 2
d270 1
a270 2
		bool doSubst = false; 	/* true if need to substitute in
					 * memberName */
d274 1
a274 1
		memberName = cp;
d279 1
a279 1
				doSubst = true;
d294 1
a294 1
		if (cp == memberName)
d297 1
a297 2
		saveChar = *cp;
		*cp = '\0';
d309 3
a311 5
		if (doSubst) {
			char *buf;
			char *sacrifice;
			char *oldMemberName = memberName;
			size_t length;
d313 1
a313 1
			memberName = Var_Subst(memberName, ctxt, true);
d319 9
a327 7
			length = strlen(memberName)+strlen(libName)+3;
			buf = sacrifice = emalloc(length);

			snprintf(buf, length, "%s(%s)", libName, memberName);

			if (strchr(memberName, '$') &&
				strcmp(memberName, oldMemberName) == 0) {
d329 4
a332 17
				 * deal with it now.  Just create an ARCHV node
				 * for the thing and let SuffExpandChildren
				 * handle it...  */
				gn = Targ_FindNode(buf, TARG_CREATE);

				if (gn == NULL) {
					free(buf);
					return false;
				} else {
					gn->type |= OP_ARCHV;
					Lst_AtEnd(nodeLst, gn);
				}
			} else if (!Arch_ParseArchive(&sacrifice, nodeLst,
			    ctxt)) {
				/* Error in nested call -- free buffer and
				 * return false ourselves.  */
				free(buf);
d334 4
a337 6
			}
			/* Free buffer and continue with our work.	*/
			free(buf);
		} else if (Dir_HasWildcards(memberName)) {
			LIST members;
			char *member;
d341 9
a349 15
			Dir_Expand(memberName, defaultPath, &members);
			while ((member = (char *)Lst_DeQueue(&members))
			    != NULL) {
				snprintf(nameBuf, MAKE_BSIZE, "%s(%s)",
				    libName, member);
				free(member);
				gn = Targ_FindNode(nameBuf, TARG_CREATE);
				/* We've found the node, but have to make sure
				 * the rest of the world knows it's an archive
				 * member, without having to constantly check
				 * for parentheses, so we type the thing with
				 * the OP_ARCHV bit before we place it on the
				 * end of the provided list.  */
				gn->type |= OP_ARCHV;
				Lst_AtEnd(nodeLst, gn);
d352 14
a365 20
			snprintf(nameBuf, MAKE_BSIZE, "%s(%s)", libName,
			    memberName);
			gn = Targ_FindNode(nameBuf, TARG_CREATE);
			/* We've found the node, but have to make sure the rest
			 * of the world knows it's an archive member, without
			 * having to constantly check for parentheses, so we
			 * type the thing with the OP_ARCHV bit before we place
			 * it on the end of the provided list.  */
			gn->type |= OP_ARCHV;
			Lst_AtEnd(nodeLst, gn);
		}
		if (doSubst)
			free(memberName);

		*cp = saveChar;
	}

	/* If substituted libName, free it now, since we need it no longer.  */
	if (subLibName)
		free(libName);
d393 1
a393 1
	FILE *arch;       	/* Stream to archive */
d420 2
a421 3
		struct ar_hdr arHeader;
				/* Archive-member header for reading archive */
		off_t size;	/* Size of archive member */
d423 1
a423 2
		char *memberName;
				/* Current member name while hashing. */
d442 1
a442 1
			/* The header is bogus.  */
d468 2
a469 1
				if (memberName == NULL)	/* Invalid data */
d472 1
a472 1
				    /* List of files entry */
d541 5
a545 5
    const char	  *archive,   /* Path to the archive */
    const char	  *member,    /* Name of member. If it is a path, only the
			       * last component is used. */
    bool	  hash)       /* true if archive should be hashed if not
			       * already so. */
d547 2
a548 2
	FILE *arch;       	/* Stream to archive */
	Arch *ar;	      	/* Archive descriptor */
d595 2
a596 2
		he = ohash_find(&ar->members,
		    ohash_qlookupi(&ar->members, member, &end));
d694 1
a694 1
			   name, (u_long)l->fnamesize);
d729 4
a732 4
	FILE *arch;       /* Stream to archive */
	char *cp;
	char magic[SARMAG];
	size_t length;
d765 1
a765 1
		off_t size;	/* Size of archive member */
d804 4
a807 3
			memberName = ArchSVR4Entry(&list,
			    arHeaderPtr->ar_name, size, arch);
			if (memberName == NULL)	/* Invalid data */
d810 1
a810 1
			    /* List of files entry */
d870 2
a871 2
		snprintf(arHeader.ar_date, sizeof(arHeader.ar_date), "%-12ld",
		    (long) timestamp2time_t(now));
d899 1
a899 1
    }
@


1.68
log
@rename dirSearchPath -> defaultPath, and openDirectories -> knownDirectories
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.67 2007/09/16 12:25:12 espie Exp $ */
d69 1
a69 1
 * archives are kept in a hash (archives) which is searched each time 
d195 1
a195 1
		ts_set_from_time_t((time_t) strtol(m->date, NULL, 10), 
d306 1
a306 1
			if (strchr(memberName, '$') && 
d321 1
a321 1
			} else if (!Arch_ParseArchive(&sacrifice, nodeLst, 
d337 1
a337 1
			while ((member = (char *)Lst_DeQueue(&members)) 
d339 1
a339 1
				snprintf(nameBuf, MAKE_BSIZE, "%s(%s)", 
d353 1
a353 1
			snprintf(nameBuf, MAKE_BSIZE, "%s(%s)", libName, 
d449 1
a449 1
		if (memcmp(arHeader.ar_fmag, ARFMAG, sizeof(arHeader.ar_fmag)) 
d459 1
a459 1
			size = (off_t) field2long(arHeader.ar_size, 
d462 1
a462 1
			(void)memcpy(memberName, arHeader.ar_name, 
d475 1
a475 1
				memberName = ArchSVR4Entry(&list, memberName, 
d495 1
a495 1
			if (memcmp(memberName, AR_EFMT1, sizeof(AR_EFMT1) - 1) 
d498 1
a498 1
				int elen = atoi(memberName + 
d510 1
a510 1
					printf("ArchStat: Extended format entry for %s\n", 
d587 2
a588 2
				ts_set_from_time_t( 
				    (time_t)strtol(arHeader.ar_date, NULL, 10), 
d603 1
a603 1
		he = ohash_find(&ar->members, 
d776 1
a776 1
		if (memcmp(arHeaderPtr->ar_fmag, ARFMAG, 
d790 1
a790 1
			if (length < sizeof(arHeaderPtr->ar_name) && 
d803 1
a803 1
		size = (off_t) field2long(arHeaderPtr->ar_size, 
d812 1
a812 1
			memberName = ArchSVR4Entry(&list, 
d877 1
a877 1
		snprintf(arHeader.ar_date, sizeof(arHeader.ar_date), "%-12ld", 
d945 1
a945 1
			    strncmp(nameStart, gn->name, nameEnd - nameStart) 
d958 3
a960 3
/* If the system can handle the -L flag when linking (or we cannot find 
 * the library), we assume that the user has placed the .LIBRARIES variable 
 * in the final linking command (or the linker will know where to find it) 
d1025 1
a1025 1
	if (is_strictly_before(now, gn->mtime) || 
d1037 1
a1037 1
			printf("%s modified %s...", RANLIBMAG, 
@


1.67
log
@minor reindent issues
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.66 2007/09/16 12:09:36 espie Exp $ */
d336 1
a336 1
			Dir_Expand(memberName, dirSearchPath, &members);
@


1.66
log
@rename Targ_FmtTime into time_to_string and move it, as it's not related
to target nodes at all (reduces modules inter-dependencies)
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.65 2007/09/16 11:29:34 espie Exp $ */
d578 14
a591 14
		    /* Quick path:  no need to hash the whole archive, just use
		     * ArchFindMember to get the member's header and close the
		     * stream again.  */
		    struct ar_hdr arHeader;

		    arch = ArchFindMember(archive, member, &arHeader, "r");

		    if (arch != NULL) {
			    fclose(arch);
			    ts_set_from_time_t( 
			    	(time_t)strtol(arHeader.ar_date, NULL, 10), 
				result);
		    }
		    return result;
d807 18
a824 18
		    /* svr4 names are slash terminated. Also svr4 extended AR
		     * format.
		     */
		    if (memberName[0] == '/') {
			    /* svr4 magic mode.  */
			    memberName = ArchSVR4Entry(&list, 
			    	arHeaderPtr->ar_name, size, arch);
			    if (memberName == NULL)	/* Invalid data */
				    break;
			    else if (memberName == svr4list)
			    	/* List of files entry */
				    continue;
			    /* Got the entry.  */
			    if (strcmp(memberName, member) == 0) {
				    efree(list.fnametab);
				    return arch;
			    }
		    }
d872 2
a873 2
    FILE *arch;
    struct ar_hdr arHeader;
@


1.65
log
@reuse free_hash
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.64 2007/09/16 11:27:05 espie Exp $ */
d1038 1
a1038 1
			    Targ_FmtTime(modTimeTOC));
@


1.64
log
@reindent arch.c
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.63 2007/09/16 10:14:26 espie Exp $ */
a200 6
/*-
 *-----------------------------------------------------------------------
 * ArchFree --
 *	Free memory used by an archive
 *-----------------------------------------------------------------------
 */
a203 3
	struct arch_member *mem;
	unsigned int i;

d205 1
a205 5
	for (mem = ohash_first(&a->members, &i); mem != NULL;
		mem = ohash_next(&a->members, &i))
		free(mem);

	ohash_delete(&a->members);
@


1.63
log
@cut up dir.c into dir.c/direxpand.c as there is very little interface between
two modules that do different things.
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.62 2007/09/16 09:49:24 espie Exp $ */
d116 1
a116 1
static struct ohash	  archives;   /* Archives we've already examined.  */
d119 3
a121 3
    struct ohash   members;    /* All the members of this archive, as
			       * struct arch_member entries.  */
    char	  name[1];    /* Archive name.	*/
d132 2
a133 2
    TIMESTAMP	  mtime;	/* Member modification date.  */
    char	  date[AR_DATE_SIZE+1];
d135 1
a135 1
    char	  name[1];	/* Member name.  */
d139 2
a140 2
    offsetof(struct arch_member, name), NULL,
    hash_alloc, hash_free, element_alloc
d144 1
a144 1
    offsetof(Arch, name), NULL, hash_alloc, hash_free, element_alloc
d167 2
a168 2
    char	  *fnametab;  /* Extended name table strings */
    size_t	  fnamesize;  /* Size of the string table */
d179 2
a180 2
    const char *end = NULL;
    struct arch_member *n;
d182 7
a188 7
    n = ohash_create_entry(&members_info, name, &end);
    /* XXX ar entries are NOT null terminated.	*/
    memcpy(n->date, &(hdr->ar_date), AR_DATE_SIZE);
    n->date[AR_DATE_SIZE] = '\0';
    /* Don't compute mtime before it is needed. */
    ts_set_out_of_date(n->mtime);
    return n;
d194 4
a197 3
    if (is_out_of_date(m->mtime))
	ts_set_from_time_t((time_t) strtol(m->date, NULL, 10), m->mtime);
    return m->mtime;
d210 2
a211 2
    struct arch_member *mem;
    unsigned int i;
d213 4
a216 4
    /* Free memory from hash entries */
    for (mem = ohash_first(&a->members, &i); mem != NULL;
	mem = ohash_next(&a->members, &i))
	free(mem);
d218 2
a219 2
    ohash_delete(&a->members);
    free(a);
d231 53
a283 21
    char	    *cp;	    /* Pointer into line */
    GNode	    *gn;	    /* New node */
    char	    *libName;	    /* Library-part of specification */
    char	    *memberName;    /* Member-part of specification */
    char	    nameBuf[MAKE_BSIZE]; /* temporary place for node name */
    char	    saveChar;	    /* Ending delimiter of member-name */
    bool	    subLibName;     /* true if libName should have/had
				     * variable substitution performed on it */

    libName = *linePtr;

    subLibName = false;

    for (cp = libName; *cp != '(' && *cp != '\0';) {
	if (*cp == '$') {
	    if (!Var_ParseSkip(&cp, ctxt))
		return false;
	    subLibName = true;
	} else
	    cp++;
    }
d285 3
a287 21
    *cp++ = '\0';
    if (subLibName)
	libName = Var_Subst(libName, ctxt, true);

    for (;;) {
	/* First skip to the start of the member's name, mark that
	 * place and skip to the end of it (either white-space or
	 * a close paren).  */
	bool doSubst = false; /* true if need to substitute in memberName */

	while (isspace(*cp))
	    cp++;
	memberName = cp;
	while (*cp != '\0' && *cp != ')' && !isspace(*cp)) {
	    if (*cp == '$') {
		if (!Var_ParseSkip(&cp, ctxt))
		    return false;
		doSubst = true;
	    } else
		cp++;
	}
d289 2
a290 8
	/* If the specification ends without a closing parenthesis,
	 * chances are there's something wrong (like a missing backslash),
	 * so it's better to return failure than allow such things to
	 * happen.  */
	if (*cp == '\0') {
	    printf("No closing parenthesis in archive specification\n");
	    return false;
	}
d292 73
a364 42
	/* If we didn't move anywhere, we must be done.  */
	if (cp == memberName)
	    break;

	saveChar = *cp;
	*cp = '\0';

	/* XXX: This should be taken care of intelligently by
	 * SuffExpandChildren, both for the archive and the member portions.  */

	/* If member contains variables, try and substitute for them.
	 * This will slow down archive specs with dynamic sources, of course,
	 * since we'll be (non-)substituting them three times, but them's
	 * the breaks -- we need to do this since SuffExpandChildren calls
	 * us, otherwise we could assume the thing would be taken care of
	 * later.  */
	if (doSubst) {
	    char    *buf;
	    char    *sacrifice;
	    char    *oldMemberName = memberName;
	    size_t  length;

	    memberName = Var_Subst(memberName, ctxt, true);

	    /* Now form an archive spec and recurse to deal with nested
	     * variables and multi-word variable values.... The results
	     * are just placed at the end of the nodeLst we're returning.  */
	    length = strlen(memberName)+strlen(libName)+3;
	    buf = sacrifice = emalloc(length);

	    snprintf(buf, length, "%s(%s)", libName, memberName);

	    if (strchr(memberName, '$') && 
	    	strcmp(memberName, oldMemberName) == 0) {
		/* Must contain dynamic sources, so we can't deal with it now.
		 * Just create an ARCHV node for the thing and let
		 * SuffExpandChildren handle it...  */
		gn = Targ_FindNode(buf, TARG_CREATE);

		if (gn == NULL) {
		    free(buf);
		    return false;
d366 10
a375 2
		    gn->type |= OP_ARCHV;
		    Lst_AtEnd(nodeLst, gn);
d377 4
a380 37
	    } else if (!Arch_ParseArchive(&sacrifice, nodeLst, ctxt)) {
		/* Error in nested call -- free buffer and return false
		 * ourselves.  */
		free(buf);
		return false;
	    }
	    /* Free buffer and continue with our work.	*/
	    free(buf);
	} else if (Dir_HasWildcards(memberName)) {
	    LIST  members;
	    char  *member;

	    Lst_Init(&members);

	    Dir_Expand(memberName, dirSearchPath, &members);
	    while ((member = (char *)Lst_DeQueue(&members)) != NULL) {
		snprintf(nameBuf, MAKE_BSIZE, "%s(%s)", libName, member);
		free(member);
		gn = Targ_FindNode(nameBuf, TARG_CREATE);
		/* We've found the node, but have to make sure the rest of
		 * the world knows it's an archive member, without having
		 * to constantly check for parentheses, so we type the
		 * thing with the OP_ARCHV bit before we place it on the
		 * end of the provided list.  */
		gn->type |= OP_ARCHV;
		Lst_AtEnd(nodeLst, gn);
	    }
	} else {
	    snprintf(nameBuf, MAKE_BSIZE, "%s(%s)", libName, memberName);
	    gn = Targ_FindNode(nameBuf, TARG_CREATE);
	    /* We've found the node, but have to make sure the rest of the
	     * world knows it's an archive member, without having to
	     * constantly check for parentheses, so we type the thing with
	     * the OP_ARCHV bit before we place it on the end of the
	     * provided list.  */
	    gn->type |= OP_ARCHV;
	    Lst_AtEnd(nodeLst, gn);
a381 2
	if (doSubst)
	    free(memberName);
d383 10
a392 2
	*cp = saveChar;
    }
d394 2
a395 13
    /* If substituted libName, free it now, since we need it no longer.  */
    if (subLibName)
	free(libName);

    /* We promised the pointer would be set up at the next non-space, so
     * we must advance cp there before setting *linePtr... (note that on
     * entrance to the loop, cp is guaranteed to point at a ')') */
    do {
	cp++;
    } while (isspace(*cp));

    *linePtr = cp;
    return true;
d402 1
a402 1
    static char enough[32];
d404 4
a407 4
    assert(length < sizeof(enough));
    memcpy(enough, field, length);
    enough[length] = '\0';
    return strtol(enough, NULL, 10);
d413 3
a415 3
    FILE *	  arch;       /* Stream to archive */
    char	  magic[SARMAG];
    Arch	  *ar;
d417 1
a417 1
    struct SVR4namelist list;
d419 1
a419 1
    list.fnametab = NULL;
d422 5
a426 5
    /* When we encounter an archive for the first time, we read its
     * whole contents, to place it in the cache.  */
    arch = fopen(archive, "r");
    if (arch == NULL)
	return NULL;
d428 6
a433 6
    /* Make sure this is an archive we can handle.  */
    if ((fread(magic, SARMAG, 1, arch) != 1) ||
	(strncmp(magic, ARMAG, SARMAG) != 0)) {
	    fclose(arch);
	    return NULL;
    }
d435 2
a436 2
    ar = ohash_create_entry(&arch_info, archive, &earchive);
    ohash_init(&ar->members, 8, &members_info);
d438 7
a444 6
    for (;;) {
	size_t		n;
	struct ar_hdr	arHeader;/* Archive-member header for reading archive */
	off_t		size;	/* Size of archive member */
	char		buffer[PATH_MAX];
	char		*memberName;
d446 1
a446 1
	char		*cp;	/* Useful character pointer */
d448 2
a449 2
	memberName = buffer;
	n = fread(&arHeader, 1, sizeof(struct ar_hdr), arch);
d451 2
a452 2
	/*  Whole archive read ok.  */
	if (n == 0 && feof(arch)) {
d454 1
a454 1
	    efree(list.fnametab);
d456 5
a460 5
	    fclose(arch);
	    return ar;
	}
	if (n < sizeof(struct ar_hdr))
	    break;
d462 19
a480 16
	if (memcmp(arHeader.ar_fmag, ARFMAG, sizeof(arHeader.ar_fmag)) != 0) {
	    /* The header is bogus.  */
	    break;
	} else {
	    /* We need to advance the stream's pointer to the start of the
	     * next header.  Records are padded with newlines to an even-byte
	     * boundary, so we need to extract the size of the record and
	     * round it up during the seek.  */
	    size = (off_t) field2long(arHeader.ar_size, 
	    	sizeof(arHeader.ar_size));

	    (void)memcpy(memberName, arHeader.ar_name, AR_NAME_SIZE);
	    /* Find real end of name (strip extranous ' ')  */
	    for (cp = memberName + AR_NAME_SIZE - 1; *cp == ' ';)
		cp--;
	    cp[1] = '\0';
d483 20
a502 17
	    /* SVR4 names are slash terminated.  Also svr4 extended AR format.
	     */
	    if (memberName[0] == '/') {
		/* SVR4 magic mode.  */
		memberName = ArchSVR4Entry(&list, memberName, size, arch);
		if (memberName == NULL)		/* Invalid data */
		    break;
		else if (memberName == svr4list)/* List of files entry */
		    continue;
		/* Got the entry.  */
		/* XXX this assumes further processing, such as AR_EFMT1,
		 * also applies to SVR4ARCHIVES.  */
	    }
	    else {
		if (cp[0] == '/')
		    cp[0] = '\0';
	    }
d506 27
a532 8
	    /* BSD 4.4 extended AR format: #1/<namelen>, with name as the
	     * first <namelen> bytes of the file.  */
	    if (memcmp(memberName, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0 &&
		isdigit(memberName[sizeof(AR_EFMT1) - 1])) {

		int elen = atoi(memberName + sizeof(AR_EFMT1)-1);

		if (elen <= 0 || elen >= PATH_MAX)
a533 15
		memberName = buffer;
		if (fread(memberName, elen, 1, arch) != 1)
			break;
		memberName[elen] = '\0';
		if (fseek(arch, -elen, SEEK_CUR) != 0)
			break;
		if (DEBUG(ARCH) || DEBUG(MAKE))
		    printf("ArchStat: Extended format entry for %s\n", 
		    	memberName);
	    }
#endif

	    ohash_insert(&ar->members,
		ohash_qlookup(&ar->members, memberName),
		    new_arch_member(&arHeader, memberName));
a534 3
	if (fseek(arch, (size + 1) & ~1, SEEK_CUR) != 0)
	    break;
    }
d536 2
a537 2
    fclose(arch);
    ohash_delete(&ar->members);
d539 1
a539 1
    efree(list.fnametab);
d541 2
a542 2
    free(ar);
    return NULL;
d568 42
a609 27
    FILE *	  arch;       /* Stream to archive */
    Arch	  *ar;	      /* Archive descriptor */
    unsigned int  slot;       /* Place of archive in the archives hash */
    const char	  *end = NULL;
    const char	  *cp;
    TIMESTAMP	  result;

    ts_set_out_of_date(result);
    /* Because of space constraints and similar things, files are archived
     * using their final path components, not the entire thing, so we need
     * to point 'member' to the final component, if there is one, to make
     * the comparisons easier...  */
    cp = strrchr(member, '/');
    if (cp != NULL)
	member = cp + 1;

    /* Try to find archive in cache.  */
    slot = ohash_qlookupi(&archives, archive, &end);
    ar = ohash_find(&archives, slot);

    /* If not found, get it now.  */
    if (ar == NULL) {
	if (!hash) {
	    /* Quick path:  no need to hash the whole archive, just use
	     * ArchFindMember to get the member's header and close the stream
	     * again.  */
	    struct ar_hdr	arHeader;
d611 4
a614 1
	    arch = ArchFindMember(archive, member, &arHeader, "r");
d616 1
a616 25
	    if (arch != NULL) {
		fclose(arch);
		ts_set_from_time_t( (time_t)strtol(arHeader.ar_date, NULL, 10), 
		    result);
	    }
	    return result;
	}
	ar = read_archive(archive, end);
	if (ar != NULL)
	    ohash_insert(&archives, slot, ar);
    }

    /* If archive was found, get entry we seek.  */
    if (ar != NULL) {
	struct arch_member *he;
	end = NULL;

	he = ohash_find(&ar->members, ohash_qlookupi(&ar->members, member, &end));
	if (he != NULL)
	    return mtime_of_member(he);
	else {
	    if ((size_t)(end - member) > AR_NAME_SIZE) {
		/* Try truncated name.	*/
		end = member + AR_NAME_SIZE;
		he = ohash_find(&ar->members,
d619 11
a629 2
		    return mtime_of_member(he);
	    }
d631 1
a631 2
    }
    return result;
d658 2
a659 2
    size_t entry;
    char *ptr, *eptr;
d661 12
a672 11
    assert(name[0] == '/');
    name++;
    /* First comes a table of archive names, to be used by subsequent calls.  */
    if (memcmp(name, ARLONGNAMES1, sizeof(ARLONGNAMES1) - 1) == 0 ||
	memcmp(name, ARLONGNAMES2, sizeof(ARLONGNAMES2) - 1) == 0) {

	if (l->fnametab != NULL) {
	    if (DEBUG(ARCH))
		printf("Attempted to redefine an SVR4 name table\n");
	    return NULL;
	}
d674 2
a675 2
	l->fnametab = emalloc(size);
	l->fnamesize = size;
d677 40
a716 4
	if (fread(l->fnametab, size, 1, arch) != 1) {
	    if (DEBUG(ARCH))
		printf("Reading an SVR4 name table failed\n");
	    return NULL;
a718 25
	eptr = l->fnametab + size;
	for (entry = 0, ptr = l->fnametab; ptr < eptr; ptr++)
	    switch (*ptr) {
	    case '/':
		entry++;
		*ptr = '\0';
		break;

	    case '\n':
		break;

	    default:
		break;
	    }
	if (DEBUG(ARCH))
	    printf("Found svr4 archive name table with %lu entries\n",
			(u_long)entry);
	return (char *)svr4list;
    }
    /* Then the names themselves are given as offsets in this table.  */
    if (*name == ' ' || *name == '\0')
	return NULL;

    entry = (size_t) strtol(name, &eptr, 0);
    if ((*eptr != ' ' && *eptr != '\0') || eptr == name) {
d720 1
a720 12
	    printf("Could not parse SVR4 name /%s\n", name);
	return NULL;
    }
    if (entry >= l->fnamesize) {
	if (DEBUG(ARCH))
	    printf("SVR4 entry offset /%s is greater than %lu\n",
		   name, (u_long)l->fnamesize);
	return NULL;
    }

    if (DEBUG(ARCH))
	printf("Replaced /%s with %s\n", name, l->fnametab + entry);
d722 1
a722 1
    return l->fnametab + entry;
d750 4
a753 4
    FILE *	  arch;       /* Stream to archive */
    char	  *cp;
    char	  magic[SARMAG];
    size_t	  length;
d755 1
a755 1
    struct SVR4namelist list;
d757 1
a757 1
    list.fnametab = NULL;
d760 3
a762 3
    arch = fopen(archive, mode);
    if (arch == NULL)
	return NULL;
d764 6
a769 6
    /* Make sure this is an archive we can handle.  */
    if (fread(magic, SARMAG, 1, arch) != 1 ||
	strncmp(magic, ARMAG, SARMAG) != 0) {
	    fclose(arch);
	    return NULL;
    }
d771 31
a801 30
    /* Because of space constraints and similar things, files are archived
     * using their final path components, not the entire thing, so we need
     * to point 'member' to the final component, if there is one, to make
     * the comparisons easier...  */
    cp = strrchr(member, '/');
    if (cp != NULL)
	member = cp + 1;

    length = strlen(member);
    if (length >= AR_NAME_SIZE)
	length = AR_NAME_SIZE;

    /* Error handling is simpler than for read_archive, since we just
     * look for a given member.  */
    while (fread(arHeaderPtr, sizeof(struct ar_hdr), 1, arch) == 1) {
	off_t		  size;       /* Size of archive member */
	char		  *memberName;

	if (memcmp(arHeaderPtr->ar_fmag, ARFMAG, sizeof(arHeaderPtr->ar_fmag) ) 
	    != 0)
	     /* The header is bogus, so the archive is bad.  */
	     break;

	memberName = arHeaderPtr->ar_name;
	if (memcmp(member, memberName, length) == 0) {
	    /* If the member's name doesn't take up the entire 'name' field,
	     * we have to be careful of matching prefixes. Names are space-
	     * padded to the right, so if the character in 'name' at the end
	     * of the matched string is anything but a space, this isn't the
	     * member we sought.  */
d803 3
a805 3
	    if (length < sizeof(arHeaderPtr->ar_name) && 
	    	memberName[length] == '/')
		length++;
d807 2
a808 2
	    if (length == sizeof(arHeaderPtr->ar_name) ||
		memberName[length] == ' ') {
d810 1
a810 1
		efree(list.fnametab);
d812 3
a814 3
		return arch;
	    }
	}
d816 2
a817 2
	size = (off_t) field2long(arHeaderPtr->ar_size, 
	    sizeof(arHeaderPtr->ar_size));
d820 18
a837 16
	    /* svr4 names are slash terminated. Also svr4 extended AR format.
	     */
	    if (memberName[0] == '/') {
		/* svr4 magic mode.  */
		memberName = ArchSVR4Entry(&list, arHeaderPtr->ar_name, size, 
		    arch);
		if (memberName == NULL)		/* Invalid data */
		    break;
		else if (memberName == svr4list)/* List of files entry */
		    continue;
		/* Got the entry.  */
		if (strcmp(memberName, member) == 0) {
		    efree(list.fnametab);
		    return arch;
		}
	    }
d841 19
a859 19
	/* BSD 4.4 extended AR format: #1/<namelen>, with name as the
	 * first <namelen> bytes of the file.  */
	if (memcmp(memberName, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0 &&
	    isdigit(memberName[sizeof(AR_EFMT1) - 1])) {
	    char	  ename[PATH_MAX];

	    int elength = atoi(memberName + sizeof(AR_EFMT1)-1);

	    if (elength <= 0 || elength >= PATH_MAX)
		break;
	    if (fread(ename, elength, 1, arch) != 1)
		break;
	    if (fseek(arch, -elength, SEEK_CUR) != 0)
		break;
	    ename[elength] = '\0';
	    if (DEBUG(ARCH) || DEBUG(MAKE))
		printf("ArchFind: Extended format entry for %s\n", ename);
	    /* Found as extended name.	*/
	    if (strcmp(ename, member) == 0) {
d861 1
a861 1
		efree(list.fnametab);
d863 2
a864 1
		return arch;
d866 5
a871 6
#endif
	/* This isn't the member we're after, so we need to advance the
	 * stream's pointer to the start of the next header.  */
	if (fseek(arch, (size + 1) & ~1, SEEK_CUR) != 0)
	    break;
    }
d873 2
a874 2
    /* We did not find the member, or we ran into an error while reading
     * the archive.  */
d876 1
a876 1
    efree(list.fnametab);
d878 2
a879 2
    fclose(arch);
    return NULL;
d888 8
a895 8
    arch = ArchFindMember(archive, member, &arHeader, "r+");
    if (arch != NULL) {
	snprintf(arHeader.ar_date, sizeof(arHeader.ar_date), "%-12ld", (long)
	    timestamp2time_t(now));
	if (fseek(arch, -sizeof(struct ar_hdr), SEEK_CUR) == 0)
	    (void)fwrite(&arHeader, sizeof(struct ar_hdr), 1, arch);
	fclose(arch);
    }
d907 1
a907 1
    ArchTouch(Varq_Value(ARCHIVE_INDEX, gn), Varq_Value(MEMBER_INDEX, gn));
d916 3
a918 3
    if (gn->path != NULL) {
	ArchTouch(gn->path, RANLIBMAG);
	set_times(gn->path);
d926 2
a927 3
    gn->mtime = ArchMTimeMember(Varq_Value(ARCHIVE_INDEX, gn),
	     Varq_Value(MEMBER_INDEX, gn),
	     true);
d929 1
a929 1
    return gn->mtime;
d935 1
a935 1
    LstNode	  ln;
d937 30
a966 28
    for (ln = Lst_First(&gn->parents); ln != NULL; ln = Lst_Adv(ln)) {
	GNode	*pgn;
	char	*nameStart,
		*nameEnd;

	pgn = (GNode *)Lst_Datum(ln);

	if (pgn->type & OP_ARCHV) {
	    /* If the parent is an archive specification and is being made
	     * and its member's name matches the name of the node we were
	     * given, record the modification time of the parent in the
	     * child. We keep searching its parents in case some other
	     * parent requires this child to exist...  */
	    if ((nameStart = strchr(pgn->name, '(') ) != NULL) {
		nameStart++;
		nameEnd = strchr(nameStart, ')');
	    } else
		nameEnd = NULL;

	    if (pgn->make && nameEnd != NULL &&
		strncmp(nameStart, gn->name, nameEnd - nameStart) == 0 &&
		gn->name[nameEnd-nameStart] == '\0')
		    gn->mtime = Arch_MTime(pgn);
	} else if (pgn->make) {
	    /* Something which isn't a library depends on the existence of
	     * this target, so it needs to exist.  */
	    ts_set_out_of_date(gn->mtime);
	    break;
d968 1
a968 2
    }
    return gn->mtime;
d981 2
a982 2
    char	    *libName;	/* file name for archive */
    size_t	    length = strlen(gn->name) + 6 - 2;
d984 2
a985 2
    libName = emalloc(length);
    snprintf(libName, length, "lib%s.a", &gn->name[2]);
d987 1
a987 1
    gn->path = Dir_FindFile(libName, path);
d989 1
a989 1
    free(libName);
d991 1
a991 1
    Varq_Set(TARGET_INDEX, gn->name, gn);
d1033 1
a1033 1
    TIMESTAMP	  modTimeTOC;	/* mod time of __.SYMDEF */
d1036 6
a1041 5
    if (OP_NOP(gn->type) && Lst_IsEmpty(&gn->children))
	return false;
    if (is_strictly_before(now, gn->mtime) || is_strictly_before(gn->mtime, gn->cmtime) ||
	is_out_of_date(gn->mtime))
	return true;
d1043 4
a1046 4
    /* non existent libraries are always out-of-date.  */
    if (gn->path == NULL)
	return true;
    modTimeTOC = ArchMTimeMember(gn->path, RANLIBMAG, false);
d1048 7
a1054 1
    if (!is_out_of_date(modTimeTOC)) {
d1056 2
a1057 7
	    printf("%s modified %s...", RANLIBMAG, Targ_FmtTime(modTimeTOC));
	return is_strictly_before(modTimeTOC, gn->cmtime);
    }
    /* A library w/o a table of contents is out-of-date.  */
    if (DEBUG(ARCH) || DEBUG(MAKE))
	printf("No t.o.c....");
    return true;
d1059 1
a1059 1
    return false;
d1066 1
a1066 1
    ohash_init(&archives, 4, &arch_info);
d1073 2
a1074 2
    Arch *e;
    unsigned int i;
d1076 4
a1079 4
    for (e = ohash_first(&archives, &i); e != NULL;
	e = ohash_next(&archives, &i))
	    ArchFree(e);
    ohash_delete(&archives);
d1086 5
a1090 2
    char buf[SARMAG];
    int fd;
d1092 4
a1095 2
    if (gn->path == NULL || (fd = open(gn->path, O_RDONLY)) == -1)
	return false;
a1096 1
    if (read(fd, buf, SARMAG) != SARMAG) {
a1097 4
	return false;
    }

    (void)close(fd);
d1099 1
a1099 1
    return memcmp(buf, ARMAG, SARMAG) == 0;
@


1.62
log
@more dead code: we always define LIBRARIES and INCLUDES
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.61 2007/09/16 09:46:14 espie Exp $ */
d90 1
@


1.61
log
@remove dead code: #define RECHECK is always on
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.56 2007/03/20 03:50:39 tedu Exp $ */
a965 1
#ifdef LIBRARIES
a966 3
#else
    Varq_Set(TARGET_INDEX, gn->path == NULL ? gn->name : gn->path, gn);
#endif /* LIBRARIES */
@


1.60
log
@everywhere except in Var_Parse, we always add/append variables to the
VAR_GLOBAL context, so make it the common case: rename the basic functions
to Var_Set_with_ctxt/Var_Append_with_ctxt, define Var_Set and Var_Append
as macros that specify VAR_GLOBAL, and use these.

okay miod@@
@
text
@@


1.59
log
@simplify computations in the var module: instead of advancing a char *
and keeping track of a length, we just advance the char *, and ditch
the length. We can still get the length at the end of the top-level
functions to satisfy existing interfaces.

Much simpler code, less error-prone.

Okay millert@@
@
text
@@


1.58
log
@move the code that grabs a value in Var_Parse in its own function,
get_expanded_value.

Extend the code a bit to be much more thorough in case of a recursive
expansion: shows exactly the cycle of variable names involved.

okay millert@@
@
text
@@


1.57
log
@change Var_ParseSkip API to increment the position instead of returning a
length, simplifies code.

(warns a bit, symptom of some further issues to fix).

okay millert@@
@
text
@@


1.56
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.55 2006/01/20 23:10:19 espie Exp $ */
d244 1
a244 4
	    bool ok;

	    cp += Var_ParseSkip(cp, ctxt, &ok);
	    if (ok == false)
d266 1
a266 3
		bool ok;
		cp += Var_ParseSkip(cp, ctxt, &ok);
		if (ok == false)
@


1.55
log
@use stdint.h where appropriate. okay millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.54 2004/04/07 13:11:35 espie Exp $ */
d264 1
a264 1
	while (*cp != '\0' && *cp != ')' && isspace(*cp))
d386 1
a386 1
    } while (*cp != '\0' && isspace(*cp));
@


1.54
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.53 2003/06/03 02:56:11 millert Exp $ */
a74 1
#include <sys/types.h>
d82 1
@


1.53
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.52 2003/04/06 22:47:14 espie Exp $ */
d172 1
a172 1
static char *ArchSVR4Entry(struct SVR4namelist *, char *, size_t, FILE *);
d176 1
a176 3
new_arch_member(hdr, name)
    struct ar_hdr *hdr;
    const char *name;
d191 1
a191 2
mtime_of_member(m)
    struct arch_member *m;
d206 1
a206 2
ArchFree(a)
    Arch	  *a;
d225 3
a227 4
Arch_ParseArchive(linePtr, nodeLst, ctxt)
    char	    **linePtr;	    /* Pointer to start of specification */
    Lst 	    nodeLst;	    /* Lst on which to place the nodes */
    SymTable	    *ctxt;	    /* Context in which to expand variables */
d232 1
a232 1
    char	    *memName;	    /* Member-part of specification */
d262 1
a262 1
	bool doSubst = false; /* true if need to substitute in memName */
d266 1
a266 1
	memName = cp;
d288 1
a288 1
	if (cp == memName)
d306 2
a307 2
	    char    *oldMemName = memName;
	    size_t  len;
d309 1
a309 1
	    memName = Var_Subst(memName, ctxt, true);
d314 2
a315 2
	    len = strlen(memName)+strlen(libName)+3;
	    buf = sacrifice = emalloc(len);
d317 1
a317 1
	    snprintf(buf, len, "%s(%s)", libName, memName);
d319 2
a320 1
	    if (strchr(memName, '$') && strcmp(memName, oldMemName) == 0) {
d341 1
a341 1
	} else if (Dir_HasWildcards(memName)) {
d347 1
a347 1
	    Dir_Expand(memName, dirSearchPath, &members);
d361 1
a361 1
	    snprintf(nameBuf, MAKE_BSIZE, "%s(%s)", libName, memName);
d372 1
a372 1
	    free(memName);
d394 1
a394 3
field2long(field, len)
    const char *field;
    size_t len;
d398 3
a400 3
    assert(len < sizeof(enough));
    memcpy(enough, field, len);
    enough[len] = '\0';
d405 1
a405 3
read_archive(archive, end)
    const char *archive;
    const char *end;
d429 1
a429 1
    ar = ohash_create_entry(&arch_info, archive, &end);
d434 1
a434 1
	struct ar_hdr	arh;	/* Archive-member header for reading archive */
d437 1
a437 1
	char		*memName;
d441 2
a442 2
	memName = buffer;
	n = fread(&arh, 1, sizeof(struct ar_hdr), arch);
d455 1
a455 1
	if (memcmp(arh.ar_fmag, ARFMAG, sizeof(arh.ar_fmag)) != 0) {
d463 2
a464 1
	    size = (off_t) field2long(arh.ar_size, sizeof(arh.ar_size));
d466 1
a466 1
	    (void)memcpy(memName, arh.ar_name, AR_NAME_SIZE);
d468 1
a468 1
	    for (cp = memName + AR_NAME_SIZE - 1; *cp == ' ';)
d475 1
a475 1
	    if (memName[0] == '/') {
d477 2
a478 2
		memName = ArchSVR4Entry(&list, memName, size, arch);
		if (memName == NULL)		/* Invalid data */
d480 1
a480 1
		else if (memName == svr4list)	/* List of files entry */
d495 2
a496 2
	    if (memcmp(memName, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0 &&
		isdigit(memName[sizeof(AR_EFMT1) - 1])) {
d498 1
a498 1
		int elen = atoi(memName + sizeof(AR_EFMT1)-1);
d502 2
a503 2
		memName = buffer;
		if (fread(memName, elen, 1, arch) != 1)
d505 1
a505 1
		memName[elen] = '\0';
d509 2
a510 1
		    printf("ArchStat: Extended format entry for %s\n", memName);
d515 2
a516 2
		ohash_qlookup(&ar->members, memName),
		    new_arch_member(&arh, memName));
d547 3
a549 3
ArchMTimeMember(archive, member, hash)
    const char	  *archive;   /* Path to the archive */
    const char	  *member;    /* Name of member. If it is a path, only the
d551 1
a551 1
    bool	  hash;       /* true if archive should be hashed if not
d580 1
a580 1
	    struct ar_hdr	sarh;
d582 1
a582 1
	    arch = ArchFindMember(archive, member, &sarh, "r");
d586 2
a587 1
		ts_set_from_time_t( (time_t)strtol(sarh.ar_date, NULL, 10), result);
d638 1
a638 5
ArchSVR4Entry(l, name, size, arch)
	struct SVR4namelist *l;
	char *name;
	size_t size;
	FILE *arch;
d722 1
a722 1
 *	Fill the struct ar_hdr pointed by arhPtr.
d726 3
a728 3
ArchFindMember(archive, member, arhPtr, mode)
    const char	  *archive;   /* Path to the archive */
    const char	  *member;    /* Name of member. If it is a path, only the
d730 2
a731 2
    struct ar_hdr *arhPtr;    /* Pointer to header structure to be filled in */
    const char	  *mode;      /* The mode for opening the stream */
d734 1
a734 1
    char	  *cp;	      /* Useful character pointer */
d736 1
a736 1
    size_t	  len;
d762 3
a764 3
    len = strlen(member);
    if (len >= AR_NAME_SIZE)
	len = AR_NAME_SIZE;
d768 1
a768 1
    while (fread(arhPtr, sizeof(struct ar_hdr), 1, arch) == 1) {
d770 1
a770 1
	char		  *memName;
d772 2
a773 1
	if (memcmp(arhPtr->ar_fmag, ARFMAG, sizeof(arhPtr->ar_fmag) ) != 0)
d777 2
a778 2
	memName = arhPtr->ar_name;
	if (memcmp(member, memName, len) == 0) {
d785 3
a787 2
	    if (len < sizeof(arhPtr->ar_name) && memName[len] == '/')
		len++;
d789 2
a790 2
	    if (len == sizeof(arhPtr->ar_name) ||
		memName[len] == ' ') {
d798 2
a799 1
	size = (off_t) field2long(arhPtr->ar_size, sizeof(arhPtr->ar_size));
d804 1
a804 1
	    if (memName[0] == '/') {
d806 3
a808 2
		memName = ArchSVR4Entry(&list, arhPtr->ar_name, size, arch);
		if (memName == NULL)		/* Invalid data */
d810 1
a810 1
		else if (memName == svr4list)	/* List of files entry */
d813 1
a813 1
		if (strcmp(memName, member) == 0) {
d823 2
a824 2
	if (memcmp(memName, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0 &&
	    isdigit(memName[sizeof(AR_EFMT1) - 1])) {
d827 1
a827 1
	    int elen = atoi(memName + sizeof(AR_EFMT1)-1);
d829 1
a829 1
	    if (elen <= 0 || elen >= PATH_MAX)
d831 1
a831 1
	    if (fread(ename, elen, 1, arch) != 1)
d833 1
a833 1
	    if (fseek(arch, -elen, SEEK_CUR) != 0)
d835 1
a835 1
	    ename[elen] = '\0';
d863 1
a863 3
ArchTouch(archive, member)
    const char	  *archive;   /* Path to the archive */
    const char	  *member;    /* Name of member. */
d866 1
a866 1
    struct ar_hdr arh;
d868 1
a868 1
    arch = ArchFindMember(archive, member, &arh, "r+");
d870 1
a870 1
	snprintf(arh.ar_date, sizeof(arh.ar_date), "%-12ld", (long)
d873 1
a873 1
	    (void)fwrite(&arh, sizeof(struct ar_hdr), 1, arch);
d885 1
a885 2
Arch_Touch(gn)
    GNode	  *gn;	  /* Node of member to touch */
d892 1
a892 2
Arch_TouchLib(gn)
    GNode	    *gn UNUSED;	/* The node of the library to touch */
d904 1
a904 2
Arch_MTime(gn)
    GNode	  *gn;	      /* Node describing archive member */
d914 1
a914 2
Arch_MemMTime(gn)
    GNode	  *gn;
d959 1
a959 3
Arch_FindLib(gn, path)
    GNode	    *gn;	/* Node of library to find */
    Lst 	    path;	/* Search path */
d962 1
a962 1
    size_t	    len = strlen(gn->name) + 6 - 2;
d964 2
a965 2
    libName = emalloc(len);
    snprintf(libName, len, "lib%s.a", &gn->name[2]);
d1014 1
a1014 2
Arch_LibOODate(gn)
    GNode	  *gn;		/* The library's graph node */
d1046 1
a1046 1
Arch_Init()
d1053 1
a1053 1
Arch_End()
d1066 1
a1066 2
Arch_IsLib(gn)
    GNode *gn;
@


1.52
log
@get rid of some strcpy/sprintf.
ok krw@@, matthieu@@, deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.51 2002/01/30 18:40:26 matthieu Exp $ */
d48 1
a48 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.51
log
@use defined(__ELF__) instead of a list of ELF architectures from which
sparc64 was missing.
This fixes a bug with ELF static libraries on sparc64
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.50 2001/09/19 10:58:07 mpech Exp $ */
d316 1
d323 2
a324 1
	    buf = sacrifice = emalloc(strlen(memName)+strlen(libName)+3);
d326 1
a326 1
	    sprintf(buf, "%s(%s)", libName, memName);
d979 1
d981 2
a982 2
    libName = emalloc(strlen(gn->name) + 6 - 2);
    sprintf(libName, "lib%s.a", &gn->name[2]);
@


1.50
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.49 2001/06/07 13:53:22 espie Exp $ */
d164 1
a164 2
    (defined(__OpenBSD__) && defined(__mips__)) || \
    (defined(__OpenBSD__) && defined(__powerpc))
@


1.49
log
@Better warning fix, in line with the rest of the code
(__attribute((__unused__)) denotes parameters that MAY be unused in the
code, e.g., it's mostly a `shut up warnings' device).
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.48 2001/06/05 11:59:10 espie Exp $ */
d637 1
a637 1
 *	NULL:	  error occured
@


1.48
log
@Use Str_concat instead of fixed buffers and snprintf in building paths.
Replace MAXPATHLEN with PATH_MAX (synch with op-make).
ok naddy@@
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.47 2001/05/30 00:43:00 deraadt Exp $ */
d904 2
a905 1
    GNode	    *gn;	/* The node of the library to touch */
a911 2
#else
    gn = gn;
@


1.47
log
@-Wall cleanup, mostly useless otherwise
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.46 2001/05/29 12:53:38 espie Exp $ */
d102 8
d447 1
a447 1
	char		buffer[MAXPATHLEN+1];
d510 1
a510 1
		if (elen <= 0 || elen > MAXPATHLEN)
d833 1
a833 1
	    char	  ename[MAXPATHLEN+1];
d837 1
a837 1
	    if (elen <= 0 || elen > MAXPATHLEN)
@


1.46
log
@Take includes out of lst.h, re-add what's needed to separate files.
Removes remaining lint stuff from lst.lib.
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.45 2001/05/23 12:34:39 espie Exp $ */
d605 1
a605 1
	    if (end - member > AR_NAME_SIZE) {
d893 1
d903 2
d1025 1
d1027 1
@


1.45
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: arch.c,v 1.16 1999/10/05 22:06:23 espie Exp $ */
d78 1
@


1.44
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d69 1
a69 4
/*-
 * arch.c --
 *	Functions to manipulate libraries, archives and their members.
 *
d73 2
a74 37
 * archives are kept on a list which is searched each time an archive member
 * is referenced.
 *
 * The interface to this module is:
 *	Arch_ParseArchive	Given an archive specification, return a list
 *				of GNode's, one for each member in the spec.
 *				FAILURE is returned if the specification is
 *				invalid for some reason.
 *
 *	Arch_Touch		Alter the modification time of the archive
 *				member described by the given node to be
 *				the current time.
 *
 *	Arch_TouchLib		Update the modification time of the library
 *				described by the given node. This is special
 *				because it also updates the modification time
 *				of the library's table of contents.
 *
 *	Arch_MTime		Find the modification time of a member of
 *				an archive *in the archive*. The time is also
 *				placed in the member's GNode. Returns the
 *				modification time.
 *
 *	Arch_MemMTime		Find the modification time of a member of
 *				an archive. Called when the member doesn't
 *				already exist. Looks in the archive for the
 *				modification time. Returns the modification
 *				time.
 *
 *	Arch_FindLib		Search for a library along a path. The
 *				library name in the GNode should be in
 *				-l<name> format.
 *
 *	Arch_LibOODate		Special function to decide if a library node
 *				is out-of-date.
 *
 *	Arch_Init		Initialize this module.
a75 1
 *	Arch_End		Cleanup this module.
d78 22
a99 26
#include    <sys/types.h>
#include    <sys/stat.h>
#include    <sys/time.h>
#include    <sys/param.h>
#include    <assert.h>
#include    <ctype.h>
#include    <ar.h>
#include    <utime.h>
#include    <stdio.h>
#include    <stddef.h>
#include    <stdlib.h>
#include    <fcntl.h>
#include    "make.h"
#include    "ohash.h"
#include    "dir.h"
#include    "config.h"

#ifndef lint
#if 0
static char sccsid[] = "@@(#)arch.c	8.2 (Berkeley) 1/2/94";
#else
UNUSED
static char rcsid[] = "$OpenBSD: arch.c,v 1.16 1999/10/05 22:06:23 espie Exp $";
#endif
#endif /* not lint */

d151 1
a151 1
static TIMESTAMP ArchMTimeMember(const char *, const char *, Boolean);
d184 1
a184 1
    set_out_of_date(n->mtime);
d193 1
a193 1
	grab_date((time_t) strtol(m->date, NULL, 10), m->mtime);
d223 2
a224 17
/*-
 *-----------------------------------------------------------------------
 * Arch_ParseArchive --
 *	Parse the archive specification in the given line and find/create
 *	the nodes for the specified archive members, placing their nodes
 *	on the given list.
 *
 * Results:
 *	SUCCESS if it was a valid specification. The linePtr is updated
 *	to point to the first non-space after the archive spec. The
 *	nodes for the members are placed on the given list.
 *
 * Side Effects:
 *	Some nodes may be created. The given list is extended.
 *-----------------------------------------------------------------------
 */
ReturnStatus
d236 1
a236 1
    Boolean	    subLibName;     /* TRUE if libName should have/had
d241 1
a241 1
    subLibName = FALSE;
d245 1
a245 1
	    ReturnStatus result;
d247 4
a250 4
	    cp += Var_ParseSkip(cp, ctxt, &result);
	    if (result == FAILURE)
		return FAILURE;
	    subLibName = TRUE;
d257 1
a257 1
	libName = Var_Subst(libName, ctxt, TRUE);
d263 1
a263 1
	Boolean doSubst = FALSE; /* TRUE if need to substitute in memName */
d270 5
a274 5
		ReturnStatus result;
		cp += Var_ParseSkip(cp, ctxt, &result);
		if (result == FAILURE)
		    return FAILURE;
		doSubst = TRUE;
d285 1
a285 1
	    return FAILURE;
d309 1
a309 1
	    memName = Var_Subst(memName, ctxt, TRUE);
d322 1
a322 1
		gn = Targ_FindNode(buf, NULL, TARG_CREATE);
d326 1
a326 1
		    return FAILURE;
d331 2
a332 2
	    } else if (Arch_ParseArchive(&sacrifice, nodeLst, ctxt)!=SUCCESS) {
		/* Error in nested call -- free buffer and return FAILURE
d335 1
a335 1
		return FAILURE;
d345 1
a345 1
	    Dir_Expand(memName, &dirSearchPath, &members);
d349 1
a349 1
		gn = Targ_FindNode(nameBuf, NULL, TARG_CREATE);
d360 1
a360 1
	    gn = Targ_FindNode(nameBuf, NULL, TARG_CREATE);
d387 1
a387 1
    return SUCCESS;
d543 1
a543 1
 *	Cache the whole archive contents if hash is TRUE.
d551 1
a551 1
    Boolean	  hash;       /* TRUE if archive should be hashed if not
d561 1
a561 1
    set_out_of_date(result);
d586 1
a586 1
		grab_date( (time_t)strtol(sarh.ar_date, NULL, 10), result);
d879 1
a879 5
/*-
 *-----------------------------------------------------------------------
 * Arch_Touch --
 *	Touch a member of an archive.
 *
a880 1
 *	The 'time' field of the member's header is updated.
a883 1
 *-----------------------------------------------------------------------
a891 11
/*-
 *-----------------------------------------------------------------------
 * Arch_TouchLib --
 *	Given a node which represents a library, touch the thing, making
 *	sure that the table of contents also is touched.
 *
 * Side Effects:
 *	The modification time of the library and of the RANLIBMAG
 *	member are set to 'now'.
 *-----------------------------------------------------------------------
 */
a903 13
/*-
 *-----------------------------------------------------------------------
 * Arch_MTime --
 *	Return the modification time of a member of an archive.
 *
 * Results:
 *	The modification time.
 *
 * Side Effects:
 *	The mtime field of the given node is filled in with the value
 *	returned by the function.
 *-----------------------------------------------------------------------
 */
d910 1
a910 1
	     TRUE);
a914 13
/*-
 *-----------------------------------------------------------------------
 * Arch_MemMTime --
 *	Given a non-existent archive member's node, get its modification
 *	time from its archived form, if it exists.
 *
 * Results:
 *	The modification time.
 *
 * Side Effects:
 *	The mtime field is filled in.
 *-----------------------------------------------------------------------
 */
d947 1
a947 1
	    set_out_of_date(gn->mtime);
d954 6
a959 15
/*-
 *-----------------------------------------------------------------------
 * Arch_FindLib --
 *	Search for a library along the given search path.
 *
 * Side Effects:
 *	The node's 'path' field is set to the found path (including the
 *	actual file name, not -l...). If the system can handle the -L
 *	flag when linking (or we cannot find the library), we assume that
 *	the user has placed the .LIBRARIES variable in the final linking
 *	command (or the linker will know where to find it) and set the
 *	TARGET variable for this node to be the node's name. Otherwise,
 *	we set the TARGET variable to be the full path of the library,
 *	as returned by Dir_FindFile.
 *-----------------------------------------------------------------------
d1011 1
a1011 1
 *	TRUE if the library is out-of-date. FALSE otherwise.
d1017 1
a1017 1
Boolean
d1024 2
a1025 2
	return FALSE;
    if (is_before(now, gn->mtime) || is_before(gn->mtime, gn->cmtime) ||
d1027 1
a1027 1
	return TRUE;
d1031 2
a1032 2
	return TRUE;
    modTimeTOC = ArchMTimeMember(gn->path, RANLIBMAG, FALSE);
d1037 1
a1037 1
	return is_before(modTimeTOC, gn->cmtime);
d1042 1
a1042 1
    return TRUE;
d1044 1
a1044 1
    return FALSE;
a1047 9
/*-
 *-----------------------------------------------------------------------
 * Arch_Init --
 *	Initialize things for this module.
 *
 * Side Effects:
 *	The 'archives' hash is initialized.
 *-----------------------------------------------------------------------
 */
d1054 1
a1054 11


/*-
 *-----------------------------------------------------------------------
 * Arch_End --
 *	Cleanup things for this module.
 *
 * Side Effects:
 *	The 'archives' hash is freed
 *-----------------------------------------------------------------------
 */
a1057 1
#ifdef CLEANUP
d1065 1
a1066 1
}
d1068 1
a1068 10
/*-
 *-----------------------------------------------------------------------
 * Arch_IsLib --
 *	Check if the node is a library
 *
 * Results:
 *	True or False.
 *-----------------------------------------------------------------------
 */
Boolean
d1076 1
a1076 1
	return FALSE;
d1080 1
a1080 1
	return FALSE;
@


1.43
log
@Use the ohash_* that's now in libc.
@
text
@d1 2
a2 1
/*	$OpenBSD: arch.c,v 1.42 2000/11/27 20:37:16 espie Exp $	*/
d6 1
a6 1
 * Copyright (c) 2000 Marc Espie.
d80 28
a107 28
 *	Arch_ParseArchive   	Given an archive specification, return a list
 *	    	  	    	of GNode's, one for each member in the spec.
 *	    	  	    	FAILURE is returned if the specification is
 *	    	  	    	invalid for some reason.
 *
 *	Arch_Touch	    	Alter the modification time of the archive
 *	    	  	    	member described by the given node to be
 *	    	  	    	the current time.
 *
 *	Arch_TouchLib	    	Update the modification time of the library
 *	    	  	    	described by the given node. This is special
 *	    	  	    	because it also updates the modification time
 *	    	  	    	of the library's table of contents.
 *
 *	Arch_MTime	    	Find the modification time of a member of
 *	    	  	    	an archive *in the archive*, return TRUE if
 *				exists. The time is placed in the member's 
 *				GNode. Returns the modification time.
 *
 *	Arch_MemMTime	    	Find the modification time of a member of
 *	    	  	    	an archive. Called when the member doesn't
 *	    	  	    	already exist. Looks in the archive for the
 *	    	  	    	modification time. Returns the modification
 *	    	  	    	time.
 *
 *	Arch_FindLib	    	Search for a library along a path. The
 *	    	  	    	library name in the GNode should be in
 *	    	  	    	-l<name> format.
d109 2
a110 2
 *	Arch_LibOODate	    	Special function to decide if a library node
 *	    	  	    	is out-of-date.
d112 1
a112 1
 *	Arch_Init 	    	Initialize this module.
d114 1
a114 1
 *	Arch_End 	    	Cleanup this module.
d121 1
a121 1
#include    <stddef.h>
a123 1
#include    <assert.h>
d126 1
d139 1
a139 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.42 2000/11/27 20:37:16 espie Exp $";
d143 1
d153 1
a153 1
static struct ohash 	archives;   /* Archives we've already examined */
d156 3
a158 3
    struct ohash  members;    /* All the members of this archive, as
     			       * struct arch_member entries.  */
    char	  name[1];    /* Archive name */
d163 1
a163 1
#define AR_NAME_SIZE	    	(sizeof(dummy->ar_name))
d166 1
a166 1
/* Each archive member is tied to an arch_member structure, 
d170 2
a171 2
    char   	  date[AR_DATE_SIZE+1];
    				/* Same, before conversion to numeric value.  */
d176 2
a177 2
    offsetof(struct arch_member, name), NULL, 
    hash_alloc, hash_free, element_alloc 
d181 1
a181 1
    offsetof(Arch, name), NULL, hash_alloc, hash_free, element_alloc 
d184 6
a189 4
static struct arch_member *new_arch_member __P((struct ar_hdr *, const char *));
static TIMESTAMP mtime_of_member __P((struct arch_member *));
static long field2long __P((const char *, size_t));
static Arch *read_archive __P((const char *, const char *));
d192 1
a192 1
static void ArchFree __P((Arch *));
d194 3
a196 3
static TIMESTAMP ArchMTimeMember __P((const char *, const char *, Boolean));
static FILE *ArchFindMember __P((const char *, const char *, struct ar_hdr *, const char *));
static void ArchTouch __P((const char *, const char *));
d211 1
a211 1
static char *ArchSVR4Entry __P((struct SVR4namelist *, char *, size_t, FILE *));
d223 1
a223 1
    /* XXX ar entries are NOT null terminated.  */
d236 1
a236 1
    	grab_date((time_t) strtol(m->date, NULL, 10), m->mtime);
d248 2
a249 2
ArchFree(ap)
    Arch	*a;
d256 1
a256 1
    	mem = ohash_next(&a->members, &i))
a279 1
 *
d284 3
a286 3
    char	    **linePtr;      /* Pointer to start of specification */
    Lst	    	    nodeLst;   	    /* Lst on which to place the nodes */
    SymTable   	    *ctxt;  	    /* Context in which to expand variables */
d288 4
a291 4
    register char   *cp;	    /* Pointer into line */
    GNode	    *gn;     	    /* New node */
    char	    *libName;  	    /* Library-part of specification */
    char	    *memName;  	    /* Member-part of specification */
d293 2
a294 2
    char	    saveChar;  	    /* Ending delimiter of member-name */
    Boolean 	    subLibName;	    /* TRUE if libName should have/had
d301 1
a301 1
    for (cp = libName; *cp != '(' && *cp != '\0'; cp++) {
d303 1
a303 14
	    /*
	     * Variable spec, so call the Var module to parse the puppy
	     * so we can safely advance beyond it...
	     */
	    size_t 	length;
	    Boolean	freeIt;
	    char	*result;

	    result=Var_Parse(cp, ctxt, TRUE, &length, &freeIt);
	    if (result == var_Error) {
		return(FAILURE);
	    } else {
		subLibName = TRUE;
	    }
d305 6
a310 5
	    if (freeIt) {
		free(result);
	    }
	    cp += length-1;
	}
d314 1
a314 1
    if (subLibName) {
a315 2
    }

d318 1
a318 2
	/*
	 * First skip to the start of the member's name, mark that
d320 2
a321 3
	 * a close paren).
	 */
	Boolean	doSubst = FALSE; /* TRUE if need to substitute in memName */
d323 1
a323 1
	while (*cp != '\0' && *cp != ')' && isspace (*cp)) {
a324 1
	}
d326 1
a326 1
	while (*cp != '\0' && *cp != ')' && !isspace (*cp)) {
d328 6
a333 20
		/*
		 * Variable spec, so call the Var module to parse the puppy
		 * so we can safely advance beyond it...
		 */
		size_t 	length;
		Boolean	freeIt;
		char	*result;

		result=Var_Parse(cp, ctxt, TRUE, &length, &freeIt);
		if (result == var_Error) {
		    return(FAILURE);
		} else {
		    doSubst = TRUE;
		}

		if (freeIt) {
		    free(result);
		}
		cp += length;
	    } else {
a334 1
	    }
d337 1
a337 2
	/*
	 * If the specification ends without a closing parenthesis,
d339 2
a340 2
	 * so it's better to return failure than allow such things to happen
	 */
d343 1
a343 1
	    return (FAILURE);
d346 2
a347 4
	/*
	 * If we didn't move anywhere, we must be done
	 */
	if (cp == memName) {
a348 1
	}
d353 4
a356 6
	/*
	 * XXX: This should be taken care of intelligently by
	 * SuffExpandChildren, both for the archive and the member portions.
	 */
	/*
	 * If member contains variables, try and substitute for them.
d361 1
a361 2
	 * later.
	 */
d369 1
a369 2
	    /*
	     * Now form an archive spec and recurse to deal with nested
d371 1
a371 2
	     * are just placed at the end of the nodeLst we're returning.
	     */
d377 1
a377 2
		/*
		 * Must contain dynamic sources, so we can't deal with it now.
d379 2
a380 3
		 * SuffExpandChildren handle it...
		 */
		gn = Targ_FindNode(buf, TARG_CREATE);
d384 1
a384 1
		    return(FAILURE);
d390 2
a391 4
		/*
		 * Error in nested call -- free buffer and return FAILURE
		 * ourselves.
		 */
d393 1
a393 1
		return(FAILURE);
d395 1
a395 3
	    /*
	     * Free buffer and continue with our work.
	     */
d398 1
a398 1
	    LIST members;
d402 1
d405 1
a405 2

		sprintf(nameBuf, "%s(%s)", libName, member);
d407 6
a412 29
		gn = Targ_FindNode(nameBuf, TARG_CREATE);
		if (gn == NULL)
		    return (FAILURE);
		else {
		    /*
		     * We've found the node, but have to make sure the rest of
		     * the world knows it's an archive member, without having
		     * to constantly check for parentheses, so we type the
		     * thing with the OP_ARCHV bit before we place it on the
		     * end of the provided list.
		     */
		    gn->type |= OP_ARCHV;
		    Lst_AtEnd(nodeLst, gn);
		}
	    }
	    Lst_Destroy(&members, NOFREE);
	} else {
	    sprintf(nameBuf, "%s(%s)", libName, memName);
	    gn = Targ_FindNode (nameBuf, TARG_CREATE);
	    if (gn == NULL) {
		return (FAILURE);
	    } else {
		/*
		 * We've found the node, but have to make sure the rest of the
		 * world knows it's an archive member, without having to
		 * constantly check for parentheses, so we type the thing with
		 * the OP_ARCHV bit before we place it on the end of the
		 * provided list.
		 */
d416 10
d427 1
a427 1
	if (doSubst) {
a428 1
	}
d433 2
a434 4
    /*
     * If substituted libName, free it now, since we need it no longer.
     */
    if (subLibName) {
a435 1
    }
d437 1
a437 2
    /*
     * We promised the pointer would be set up at the next non-space, so
d439 1
a439 2
     * entrance to the loop, cp is guaranteed to point at a ')')
     */
d442 1
a442 1
    } while (*cp != '\0' && isspace (*cp));
d445 1
a445 1
    return (SUCCESS);
d448 1
a448 1
/* Helper function: ar fields are not null terminated.  */
d467 3
a469 4
    FILE 	*arch;	/* Stream to archive */
    char	magic[SARMAG];
    Arch	*ar;

d493 2
a494 2
    	size_t 		n;
	struct ar_hdr 	arh;  	/* Archive-member header for reading archive */
d497 1
a497 1
	char 		*memName;
d499 1
a499 1
	char	  	*cp;	/* Useful character pointer */
d502 1
a502 1
    	n = fread(&arh, 1, sizeof(struct ar_hdr), arch);
d521 1
a521 1
	     * boundary, so we need to extract the size of the record and 
d527 1
a527 1
	    for (cp = memName + AR_NAME_SIZE - 1; *cp == ' ';) 
d537 1
a537 1
		if (memName == NULL) 		/* Invalid data */
d539 1
a539 1
		else if (memName == svr4list) 	/* List of files entry */
d558 1
a558 1
 
d596 2
a597 2
 *	The archive member's modification time, or OUT_OF_DATE if member 
 *	was not found (convenient, so that missing members are always 
a601 2
 *	Locate a member of an archive, given the path of the archive and
 *	the path of the desired member.
d609 2
a610 2
    Boolean	  hash;	      /* TRUE if archive should be hashed if not
    			       * already so. */
d612 1
a612 2
#define AR_MAX_NAME_LEN	    (sizeof(arh.ar_name)-1)
    FILE *	  arch;	      /* Stream to archive */
d614 2
a615 2
    unsigned int  slot;	      /* Place of archive in the archives hash */	
    const char 	  *end = NULL;
d652 1
d655 1
a655 1
	struct arch_member *he;	      
d663 2
a664 2
		/* Try truncated name */
	    	end = member + AR_NAME_SIZE;
a674 1

d686 1
a686 1
 *	NULL: 	  error occured
d693 1
a707 1

d726 1
d742 2
a743 2
	    printf("Found svr4 archive name table with %lu entries\n", 
		 	(u_long)entry);
a745 1

d753 1
a753 1
	    printf("Could not parse SVR4 name %s\n", name);
d758 1
a758 1
	    printf("SVR4 entry offset %s is greater than %lu\n",
d764 1
a764 1
	printf("Replaced %s with %s\n", name, l->fnametab + entry);
d780 1
a780 1
 *	the member's header, or NULL if the member was nonexistent. 
a783 1
 *
d794 1
a794 1
    FILE *	  arch;	      /* Stream to archive */
a797 1

d813 1
a813 1
     }
d822 1
d827 1
a827 1
    /* Error handling is simpler than for read_archive, since we just 
d830 2
a831 2
    	off_t	  	  size;       /* Size of archive member */
	char 		  *memName;
d833 1
a833 1
	if (memcmp(arhPtr->ar_fmag, ARFMAG, sizeof(arhPtr->ar_fmag) ) != 0) 
d836 1
d840 3
a842 3
 	     * we have to be careful of matching prefixes. Names are space-
 	     * padded to the right, so if the character in 'name' at the end
 	     * of the matched string is anything but a space, this isn't the
d846 1
a846 1
	    	len++;
d848 2
a849 2
	    if (len == sizeof(arhPtr->ar_name) || 
	    	memName[len] == ' ') {
d861 1
a861 1
 	     */
d865 1
a865 1
		if (memName == NULL) 		/* Invalid data */
d886 4
a889 4
	    if (elen <= 0 || elen > MAXPATHLEN) 
	    	break;
	    if (fread(ename, elen, 1, arch) != 1) 
	    	break;
d891 1
a891 1
	    	break;
d893 1
a893 1
	    if (DEBUG(ARCH) || DEBUG(MAKE)) 
d895 1
a895 1
	    /* Found as extended name.  */
a946 1
 *
a964 1
 *
d969 1
a969 1
    GNode	    *gn;      	/* The node of the library to touch */
d973 1
a973 1
    	ArchTouch(gn->path, RANLIBMAG);
d997 2
a998 2
	Varq_Value(MEMBER_INDEX, gn),
	TRUE);
d1009 5
d1017 2
a1018 2
Arch_MemMTime (gn)
    GNode   	  *gn;
d1020 1
a1020 1
    LstNode 	  ln;
d1036 2
a1037 2
	    	nameStart++;
	        nameEnd = strchr(nameStart, ')');
d1039 1
a1039 1
	    	nameEnd = NULL;
d1048 1
a1048 1
 	    set_out_of_date(gn->mtime);
a1059 3
 * Results:
 *	None.
 *
a1068 1
 *
d1072 3
a1074 3
Arch_FindLib (gn, path)
    GNode	    *gn;	      /* Node of library to find */
    Lst	    	    path;	      /* Search path */
d1076 1
a1076 1
    char	    *libName;   /* file name for archive */
d1078 1
a1078 1
    libName = (char *)emalloc (strlen (gn->name) + 6 - 2);
d1081 1
a1081 1
    gn->path = Dir_FindFile (libName, path);
d1083 1
a1083 1
    free (libName);
d1107 1
a1107 1
 *	    	  sources (gn->mtime < gn->cmtime).
d1109 2
a1110 2
 *	    	  make began (i.e. it's been modified in the course
 *	    	  of the make, probably by archiving).
d1113 1
a1113 1
 *	    	  is out-of-date). We don't compare of the archive time
a1124 1
 *
d1128 2
a1129 2
Arch_LibOODate (gn)
    GNode   	  *gn;  	/* The library's graph node */
d1131 1
a1131 1
    TIMESTAMP	modTimeTOC;	/* mod time of __.SYMDEF */
d1133 1
a1133 1
    if (OP_NOP(gn->type) && Lst_IsEmpty(&gn->children)) 
d1136 1
a1136 1
    	is_out_of_date(gn->mtime))
d1141 1
a1141 2
    	return TRUE;

d1149 1
a1149 1
    /* A library w/o a table of contents is out-of-date */
d1185 1
a1185 1
Arch_End ()
d1191 2
a1192 2
    for (e = ohash_first(&archives, &i); e != NULL; 
    	e = ohash_next(&archives, &i)) 
a1204 4
 *
 * Side Effects:
 *	None.
 *
d1207 1
a1207 1
int
d1211 1
a1211 2
    static const char armag[] = "!<arch>\n";
    char buf[sizeof(armag)-1];
d1214 1
a1214 1
    if ((fd = open(gn->path, O_RDONLY)) == -1)
d1217 2
a1218 2
    if (read(fd, buf, sizeof(buf)) != sizeof(buf)) {
	(void) close(fd);
d1222 1
a1222 1
    (void) close(fd);
d1224 1
a1224 1
    return memcmp(buf, armag, sizeof(buf)) == 0;
@


1.42
log
@This patch fixes ArchFindMember so that it handles SVR4 members
similarly to read_archive.

Note we no longer bother seeking back to the start of the header, as only
ArchTouch accesses that header, and can do the seek itself.

With this, arch handling should be working, more or less.
thanks to Todd, Miod, Naddy for reviewing those patches.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.41 2000/11/27 20:35:27 espie Exp $	*/
d138 1
a138 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.41 2000/11/27 20:35:27 espie Exp $";
d151 1
a151 1
static struct hash 	archives;   /* Archives we've already examined */
d154 1
a154 1
    struct hash	  members;    /* All the members of this archive, as
d173 1
a173 1
static struct hash_info members_info = {
d178 1
a178 1
static struct hash_info arch_info = {
d218 1
a218 1
    n = hash_create_entry(&members_info, name, &end);
d251 2
a252 2
    for (mem = hash_first(&a->members, &i); mem != NULL;
    	mem = hash_next(&a->members, &i))
d255 1
a255 1
    hash_delete(&a->members);
d553 2
a554 2
    ar = hash_create_entry(&arch_info, archive, &end);
    hash_init(&ar->members, 8, &members_info);
d636 2
a637 2
	    hash_insert(&ar->members,
		hash_qlookup(&ar->members, memName),
d645 1
a645 1
    hash_delete(&ar->members);
d696 2
a697 2
    slot = hash_qlookupi(&archives, archive, &end);
    ar = hash_find(&archives, slot);
d717 1
a717 1
	    hash_insert(&archives, slot, ar);
d724 1
a724 1
	he = hash_find(&ar->members, hash_qlookupi(&ar->members, member, &end));
d731 2
a732 2
		he = hash_find(&ar->members,
		    hash_qlookupi(&ar->members, member, &end));
d1240 1
a1240 1
    hash_init(&archives, 4, &arch_info);
d1261 2
a1262 2
    for (e = hash_first(&archives, &i); e != NULL; 
    	e = hash_next(&archives, &i)) 
d1264 1
a1264 1
    hash_delete(&archives);
@


1.41
log
@This does fix some nasty issues: ar field members are NOT null-terminated.

Hence, read_archive must be very careful to parse stuff correctly: don't
use str* when mem* are appropriate, copy numeric fields and ensure they're
terminated...
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.40 2000/11/27 18:58:10 espie Exp $	*/
d138 1
a138 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.40 2000/11/27 18:58:10 espie Exp $";
d846 2
a847 3
 *	An FILE *, opened for reading and writing, positioned at the
 *	start of the member's struct ar_hdr, or NULL if the member was
 *	nonexistent. The current struct ar_hdr for member.
d850 1
a850 1
 *	The passed struct ar_hdr structure is filled in.
d855 1
a855 1
ArchFindMember (archive, member, arhPtr, mode)
a862 1
    int		  size;       /* Size of archive member */
d865 1
a865 1
    int		  len, tlen;
d867 9
a875 4
    arch = fopen (archive, mode);
    if (arch == NULL) {
	return (NULL);
    }
d877 6
a882 9
    /*
     * We use the ARMAG string to make sure this is an archive we
     * can handle...
     */
    if ((fread (magic, SARMAG, 1, arch) != 1) ||
    	(strncmp (magic, ARMAG, SARMAG) != 0)) {
	    fclose (arch);
	    return (NULL);
    }
d884 1
a884 2
    /*
     * Because of space constraints and similar things, files are archived
d887 3
a889 4
     * the comparisons easier...
     */
    cp = strrchr (member, '/');
    if (cp != (char *) NULL) {
d891 34
a924 5
    }
    len = tlen = strlen (member);
    if (len > sizeof (arhPtr->ar_name)) {
	tlen = sizeof (arhPtr->ar_name);
    }
d926 15
a940 28
    while (fread ((char *)arhPtr, sizeof (struct ar_hdr), 1, arch) == 1) {
	if (strncmp(arhPtr->ar_fmag, ARFMAG, sizeof (arhPtr->ar_fmag) ) != 0) {
	     /*
	      * The header is bogus, so the archive is bad
	      * and there's no way we can recover...
	      */
	     fclose (arch);
	     return (NULL);
	} else if (strncmp (member, arhPtr->ar_name, tlen) == 0) {
	    /*
	     * If the member's name doesn't take up the entire 'name' field,
	     * we have to be careful of matching prefixes. Names are space-
	     * padded to the right, so if the character in 'name' at the end
	     * of the matched string is anything but a space, this isn't the
	     * member we sought.
	     */
	    if (tlen != sizeof(arhPtr->ar_name) && arhPtr->ar_name[tlen] != ' '){
		goto skip;
	    } else {
		/*
		 * To make life easier, we reposition the file at the start
		 * of the header we just read before we return the stream.
		 * In a more general situation, it might be better to leave
		 * the file at the actual member, rather than its header, but
		 * not here...
		 */
		fseek (arch, -sizeof(struct ar_hdr), SEEK_CUR);
		return (arch);
d942 2
a943 1
	} else
d945 23
a967 14
		/*
		 * BSD 4.4 extended AR format: #1/<namelen>, with name as the
		 * first <namelen> bytes of the file
		 */
	    if (strncmp(arhPtr->ar_name, AR_EFMT1,
					sizeof(AR_EFMT1) - 1) == 0 &&
		isdigit(arhPtr->ar_name[sizeof(AR_EFMT1) - 1])) {

		unsigned int elen = atoi(&arhPtr->ar_name[sizeof(AR_EFMT1)-1]);
		char ename[MAXPATHLEN];

		if (elen > MAXPATHLEN) {
			fclose (arch);
			return NULL;
d969 1
a969 16
		if (fread (ename, elen, 1, arch) != 1) {
			fclose (arch);
			return NULL;
		}
		ename[elen] = '\0';
		if (DEBUG(ARCH) || DEBUG(MAKE)) {
		    printf("ArchFind: Extended format entry for %s\n", ename);
		}
		if (strncmp(ename, member, len) == 0) {
			/* Found as extended name */
			fseek (arch, -sizeof(struct ar_hdr) - elen, SEEK_CUR);
			return (arch);
		}
		fseek (arch, -elen, SEEK_CUR);
		goto skip;
	} else
d971 4
a974 13
	{
skip:
	    /*
	     * This isn't the member we're after, so we need to advance the
	     * stream's pointer to the start of the next header. Files are
	     * padded with newlines to an even-byte boundary, so we need to
	     * extract the size of the file from the 'size' field of the
	     * header and round it up during the seek.
	     */
	    arhPtr->ar_size[sizeof(arhPtr->ar_size)-1] = '\0';
	    size = (int) strtol(arhPtr->ar_size, NULL, 10);
	    fseek (arch, (size + 1) & ~1, SEEK_CUR);
	}
d977 7
a983 6
    /*
     * We've looked everywhere, but the member is not to be found. Close the
     * archive and return NULL -- an error.
     */
    fclose (arch);
    return (NULL);
d998 2
a999 1
	(void)fwrite(&arh, sizeof(struct ar_hdr), 1, arch);
d1031 1
a1031 1
 *	Both the modification time of the library and of the RANLIBMAG
d1054 1
a1054 1
 *	The modification time (seconds).
@


1.40
log
@We take of the SVR4 archive handling data structure from our archive,
and put it into a specific structure (it is wasteful to keep lugging
SVR4 structures once an archive is parsed).

By tweaking read_archive slightly, we can achieve a nicer interface
to ArchSVR4Entry.

Note a bug in make: ArchFindMember does (currently) not use the SVR4 code,
hence some archive members won't be found in non-caching mode...
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.39 2000/11/27 18:43:52 espie Exp $	*/
d138 1
a138 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.39 2000/11/27 18:43:52 espie Exp $";
d184 1
d511 14
d530 3
a532 5
    FILE 		*arch;	/* Stream to archive */
    char		magic[SARMAG];
    Arch		*ar;
    struct ar_hdr 	arh;	/* archive-member header for reading archive */
    char		*cp;
a539 2
#define AR_MAX_NAME_LEN	    (sizeof(arh.ar_name)-1)

d548 1
a548 1
    	(strncmp(magic, ARMAG, SARMAG) != 0)) {
d556 4
a559 3

    while (fread((char *)&arh, sizeof (struct ar_hdr), 1, arch) == 1) {
	int		size;	/* Size of archive member */
d563 2
d566 12
a577 1
	memName[AR_MAX_NAME_LEN] = '\0';
d579 3
a581 6
	if (strncmp( arh.ar_fmag, ARFMAG, sizeof (arh.ar_fmag)) != 0) {
	    /*
	     * The header is bogus, so the archive is bad
	     * and there's no way we can recover...
	     */
	    goto badarch;
d583 10
a592 13
	    /*
	     * We need to advance the stream's pointer to the start of the
	     * next header. Files are padded with newlines to an even-byte
	     * boundary, so we need to extract the size of the file from the
	     * 'size' field of the header and round it up during the seek.
	     */
	    arh.ar_size[sizeof(arh.ar_size)-1] = '\0';
	    size = (int) strtol(arh.ar_size, NULL, 10);

	    (void) strncpy(memName, arh.ar_name, sizeof(arh.ar_name));
	    for (cp = &memName[AR_MAX_NAME_LEN]; *cp == ' '; cp--) {
		continue;
	    }
d596 1
a596 1
	    /* SVR4 names are slash terminated. Also svr4 extended AR format.
d616 3
a618 5
	    /*
	     * BSD 4.4 extended AR format: #1/<namelen>, with name as the
	     * first <namelen> bytes of the file
	     */
	    if (strncmp(memName, AR_EFMT1, sizeof(AR_EFMT1) - 1) == 0 &&
d621 7
a627 6
		unsigned int elen = atoi(&memName[sizeof(AR_EFMT1)-1]);

		if (elen > MAXPATHLEN)
			goto badarch;
		if (fread (memName, elen, 1, arch) != 1)
			goto badarch;
d629 3
a631 2
		fseek(arch, -elen, SEEK_CUR);
		if (DEBUG(ARCH) || DEBUG(MAKE)) {
a632 1
		}
d640 2
a641 1
	fseek(arch, (size + 1) & ~1, SEEK_CUR);
a643 5
    fclose(arch);

    return ar;

badarch:
@


1.39
log
@Factorise duplicated code involved in touching archives.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.38 2000/11/24 14:38:57 espie Exp $	*/
d123 1
d138 1
a138 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.38 2000/11/24 14:38:57 espie Exp $";
a155 2
    char	  *fnametab;  /* Extended name table strings */
    size_t	  fnamesize;  /* Size of the string table */
d196 11
a206 1
static int ArchSVR4Entry __P((Arch *, char *, size_t, FILE *));
a253 1
    efree(a->fnametab);
d515 11
a525 8
    FILE *	  arch;	      /* Stream to archive */
    char	  magic[SARMAG];
    Arch	  *ar;
    struct ar_hdr arh;        /* archive-member header for reading archive */
    int		  size;       /* Size of archive member */
    char	  memName[MAXPATHLEN+1];
    	    	    	    /* Current member name while hashing. */
    char 	  *cp;
a542 2
    ar->fnametab = NULL;
    ar->fnamesize = 0;
a544 1
    memName[AR_MAX_NAME_LEN] = '\0';
d547 7
d577 1
a577 2
	    /*
	     * svr4 names are slash terminated. Also svr4 extended AR format.
d580 5
a584 7
		/*
		 * svr4 magic mode; handle it
		 */
		switch (ArchSVR4Entry(ar, memName, size, arch)) {
		case -1:  /* Invalid data */
		    goto badarch;
		case 0:	  /* List of files entry */
d586 3
a588 3
		default:  /* Got the entry */
		    break;
		}
d632 3
a634 1
    efree(ar->fnametab);
d738 3
a740 8
 *	-1: Bad data in archive
 *	 0: A table was loaded from the file
 *	 1: Name was successfully substituted from table
 *	 2: Name was not successfully substituted from table
 *
 * Side Effects:
 *	If a table is read, the file pointer is moved to the next archive
 *	member
d742 2
d746 3
a748 3
static int
ArchSVR4Entry(ar, name, size, arch)
	Arch *ar;
d753 2
a754 2
#define ARLONGNAMES1 "//"
#define ARLONGNAMES2 "/ARFILENAMES"
d758 6
a763 2
    if (strncmp(name, ARLONGNAMES1, sizeof(ARLONGNAMES1) - 1) == 0 ||
	strncmp(name, ARLONGNAMES2, sizeof(ARLONGNAMES2) - 1) == 0) {
d765 2
a766 2
	if (ar->fnametab != NULL) {
	    if (DEBUG(ARCH)) {
d768 1
a768 2
	    }
	    return -1;
d771 2
a772 6
	/*
	 * This is a table of archive names, so we build one for
	 * ourselves
	 */
	ar->fnametab = emalloc(size);
	ar->fnamesize = size;
d774 2
a775 2
	if (fread(ar->fnametab, size, 1, arch) != 1) {
	    if (DEBUG(ARCH)) {
d777 1
a777 2
	    }
	    return -1;
d779 2
a780 2
	eptr = ar->fnametab + size;
	for (entry = 0, ptr = ar->fnametab; ptr < eptr; ptr++)
d793 1
a793 1
	if (DEBUG(ARCH)) {
d796 1
a796 2
	}
	return 0;
d799 3
a801 2
    if (name[1] == ' ' || name[1] == '\0')
	return 2;
d803 3
a805 3
    entry = (size_t) strtol(&name[1], &eptr, 0);
    if ((*eptr != ' ' && *eptr != '\0') || eptr == &name[1]) {
	if (DEBUG(ARCH)) {
d807 1
a807 2
	}
	return 2;
d809 2
a810 2
    if (entry >= ar->fnamesize) {
	if (DEBUG(ARCH)) {
d812 2
a813 3
		   name, (u_long)ar->fnamesize);
	}
	return 2;
d816 2
a817 3
    if (DEBUG(ARCH)) {
	printf("Replaced %s with %s\n", name, &ar->fnametab[entry]);
    }
d819 1
a819 3
    (void) strncpy(name, &ar->fnametab[entry], MAXPATHLEN);
    name[MAXPATHLEN] = '\0';
    return 1;
@


1.38
log
@As it stands now, arch.c does not work.
Its main failing is that ar headers are NOT null terminated.
This code is atrocious. This change starts cleaning that up.

Replace the list of cached archives with a hash,
streamline the logic of ArchMTimeMember,
by taking out the actual function that does the reading (read_archive).

More fixes to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.37 2000/11/24 14:36:33 espie Exp $	*/
d137 1
a137 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.37 2000/11/24 14:36:33 espie Exp $";
d192 1
d967 17
d989 1
a989 1
 * Results:
a990 2
 *
 * Side Effects:
d998 1
a998 1
Arch_Touch (gn)
d1001 1
a1001 12
    FILE *	  arch;	  /* Stream open to archive, positioned properly */
    struct ar_hdr arh;	  /* Current header describing member */

    arch = ArchFindMember(Varq_Value(ARCHIVE_INDEX, gn),
			  Varq_Value(MEMBER_INDEX, gn),
			  &arh, "r+");
    sprintf(arh.ar_date, "%-12ld", (long) timestamp2time_t(now));

    if (arch != NULL) {
	(void)fwrite ((char *)&arh, sizeof (struct ar_hdr), 1, arch);
	fclose (arch);
    }
a1009 3
 * Results:
 *	None.
 *
d1017 1
a1017 1
Arch_TouchLib (gn)
d1021 2
a1022 10
    FILE *	    arch;	/* Stream open to archive */
    struct ar_hdr   arh;      	/* Header describing table of contents */

    arch = ArchFindMember (gn->path, RANLIBMAG, &arh, "r+");
    sprintf(arh.ar_date, "%-12ld", (long) timestamp2time_t(now));

    if (arch != NULL) {
	(void)fwrite ((char *)&arh, sizeof (struct ar_hdr), 1, arch);
	fclose (arch);

@


1.37
log
@Change the time stamp interface to use an abstract datatype.
Define two possible interfaces: the classic one,
and the new one (used where available) that depends on timespec.

Better granularity, make is now able to distinguish between files that
were built during the same second.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.36 2000/10/13 08:30:49 espie Exp $	*/
d5 26
d137 1
a137 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.36 2000/10/13 08:30:49 espie Exp $";
d150 1
a150 1
static LIST	  archives;   /* Lst of archives we've already examined */
a152 1
    char	  *name;      /* Name of archive */
d157 1
d179 4
d185 1
a186 1
static int ArchFindArchive __P((void *, void *));
d188 1
a188 1
static void ArchFree __P((void *));
d190 2
a191 2
static TIMESTAMP ArchMTimeMember __P((char *, char *, Boolean));
static FILE *ArchFindMember __P((char *, char *, struct ar_hdr *, char *));
a229 7
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	None.
 *
d234 1
a234 1
    void *ap;
a235 1
    Arch *a = (Arch *) ap;
d237 1
a237 1
    unsigned i;
a243 1
    free(a->name);
d501 4
a504 42
/*-
 *-----------------------------------------------------------------------
 * ArchFindArchive --
 *	See if the given archive is the one we are looking for. Called
 *	From ArchMTimeMember and ArchFindMember via Lst_Find.
 *
 * Results:
 *	0 if it is, non-zero if it isn't.
 *-----------------------------------------------------------------------
 */
static int
ArchFindArchive(ar, archName)
    void *ar;	      	  /* Current list element */
    void *archName;  	  /* Name we want */
{
    return strcmp ((char *)archName, ((Arch *)ar)->name);
}

/*-
 *-----------------------------------------------------------------------
 * ArchMTimeMember --
 *	Locate a member of an archive, given the path of the archive and
 *	the path of the desired member.
 *
 * Results:
 *	A pointer to the current struct ar_hdr structure for the member. Note
 *	That no position is returned, so this is not useful for touching
 *	archive members. This is mostly because we have no assurances that
 *	The archive will remain constant after we read all the headers, so
 *	there's not much point in remembering the position...
 *
 * Side Effects:
 *
 *-----------------------------------------------------------------------
 */
static TIMESTAMP
ArchMTimeMember(archive, member, hash)
    char	  *archive;   /* Path to the archive */
    char	  *member;    /* Name of member. If it is a path, only the
			       * last component is used. */
    Boolean	  hash;	      /* TRUE if archive should be hashed if not
    			       * already so. */
a505 1
#define AR_MAX_NAME_LEN	    (sizeof(arh.ar_name)-1)
a506 2
    int		  size;       /* Size of archive member */
    char	  *cp;	      /* Useful character pointer */
d508 1
a508 3
    LstNode	  ln;	      /* Lst member containing archive descriptor */
    Arch	  *ar;	      /* Archive descriptor */
    struct arch_member *he;   /* Entry containing member's description */
d510 1
d513 1
a513 2
    const char 	  *end = NULL;
    TIMESTAMP	  result;
d515 1
a515 11
    set_out_of_date(result);

    /*
     * Because of space constraints and similar things, files are archived
     * using their final path components, not the entire thing, so we need
     * to point 'member' to the final component, if there is one, to make
     * the comparisons easier...
     */
    cp = strrchr(member, '/');
    if (cp != NULL)
	member = cp + 1;
d517 2
a518 46
    ln = Lst_Find(&archives, ArchFindArchive, archive);
    if (ln != NULL) {
	ar = (Arch *)Lst_Datum(ln);
	end = NULL;
	he = hash_find(&ar->members, hash_qlookupi(&ar->members, member, &end));
	if (he != NULL)
	    return mtime_of_member(he);
	else {
	    if (end - member > AR_NAME_SIZE) {
		/* Try truncated name */
	    	end = member + AR_NAME_SIZE;

		he = hash_find(&ar->members,
		    hash_qlookupi(&ar->members, member, &end));
		if (he != NULL)
		    return mtime_of_member(he);
	    }
	    return result;
	}
    }

    if (!hash) {
	/*
	 * Caller doesn't want the thing hashed, just use ArchFindMember
	 * to read the header for the member out and close down the stream
	 * again. Since the archive is not to be hashed, we assume there's
	 * no need to allocate extra room for the header we're returning,
	 * so just declare it static.
	 */
	 static struct ar_hdr	sarh;

	 arch = ArchFindMember(archive, member, &sarh, "r");

	if (arch == NULL)
	    return result;
	else {
	    fclose(arch);
	    grab_date( (time_t)strtol(sarh.ar_date, NULL, 10), result);
	    return result;
	}
    }

    /*
     * We don't have this archive on the list yet, so we want to find out
     * everything that's in it and cache it so we can get at it quickly.
     */
d521 1
a521 1
	return result;
d523 1
a523 4
    /*
     * We use the ARMAG string to make sure this is an archive we
     * can handle...
     */
d527 1
a527 1
	    return result;
d530 1
a530 2
    ar = (Arch *)emalloc(sizeof (Arch));
    ar->name = estrdup(archive);
d534 1
d614 1
a614 13
    Lst_AtEnd(&archives, ar);

    /*
     * Now that the archive has been read and cached, we can look into
     * the hash table to find the desired member's header.
     */
    he = hash_find(&ar->members,
	hash_qlookupi(&ar->members, member, &end));

    if (he != NULL)
	return mtime_of_member(he);
    else
	return result;
d621 88
d712 1
d838 2
a839 2
    char	  *archive;   /* Path to the archive */
    char	  *member;    /* Name of member. If it is a path, only the
d842 1
a842 1
    char	  *mode;      /* The mode for opening the stream */
d1220 1
a1220 2
 *	The 'archives' list is initialized.
 *
d1226 1
a1226 1
    Lst_Init(&archives);
a1235 3
 * Results:
 *	None.
 *
d1237 1
a1237 2
 *	The 'archives' list is freed
 *
d1244 7
a1250 1
    Lst_Destroy(&archives, ArchFree);
@


1.36
log
@Fix Arch_MemMTime (previous change I did was bogus)
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.35 2000/09/14 13:56:14 espie Exp $	*/
d111 1
a111 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.35 2000/09/14 13:56:14 espie Exp $";
d583 1
a583 1
	    return NULL;
d597 1
a597 1
	return (NULL);
d606 1
a606 1
	    return NULL;
d993 1
a993 1
    sprintf(arh.ar_date, "%-12ld", (long) now);
a1022 1
    struct utimbuf  times;	/* Times for utime() call */
d1025 1
a1025 1
    sprintf(arh.ar_date, "%-12ld", (long) now);
d1031 1
a1031 2
	times.actime = times.modtime = now;
	utime(gn->path, &times);
a1072 3
    GNode   	  *pgn;
    char    	  *nameStart,
		  *nameEnd;
d1074 5
a1078 2
    Lst_Open(&gn->parents);
    while ((ln = Lst_Next(&gn->parents)) != NULL) {
d1082 1
a1082 2
	    /*
	     * If the parent is an archive specification and is being made
d1086 2
a1087 4
	     * parent requires this child to exist...
	     */
		 /* OpenBSD: less ugly check for nameStart == NULL */
	    if ((nameStart = strchr (pgn->name, '(') ) != NULL) {
d1089 1
a1089 1
	        nameEnd = strchr (nameStart, ')');
d1094 3
a1096 6
		strncmp(nameStart, gn->name, nameEnd - nameStart) == 0) {
		    if (Arch_MTime(pgn))
			gn->mtime = pgn->mtime;
		    else
		    	gn->mtime = OUT_OF_DATE;
	    }
d1098 3
a1100 5
	    /*
	     * Something which isn't a library depends on the existence of
	     * this target, so it needs to exist.
	     */
	    gn->mtime = OUT_OF_DATE;
a1103 3

    Lst_Close(&gn->parents);

d1188 1
a1188 1
    Boolean 	  oodate;
d1190 5
a1194 6
    if (OP_NOP(gn->type) && Lst_IsEmpty(&gn->children)) {
	oodate = FALSE;
    } else if (gn->mtime > now || gn->mtime < gn->cmtime || 
    	gn->mtime == OUT_OF_DATE) {
	    oodate = TRUE;
    } else {
d1196 15
a1210 16
	time_t 	  	modTimeTOC; /* The table-of-contents's mod time */

	modTimeTOC = ArchMTimeMember(gn->path, RANLIBMAG, FALSE);

	if (!is_out_of_date(modTimeTOC)) {
	    if (DEBUG(ARCH) || DEBUG(MAKE))
		printf("%s modified %s...", RANLIBMAG, Targ_FmtTime(modTimeTOC));
	    oodate = is_before(modTimeTOC, gn->cmtime);
	} else {
	    /*
	     * A library w/o a table of contents is out-of-date
	     */
	    if (DEBUG(ARCH) || DEBUG(MAKE))
		printf("No t.o.c....");
	    oodate = TRUE;
	}
d1212 1
a1212 1
	oodate = FALSE;
a1213 2
    }
    return (oodate);
@


1.35
log
@This kills the last old hashing table, in arch.c

Slight optimizations: instead of storing archive members, just keep
the modification time, as we don't care for the rest of the archive
information. Lazily compute mtime, stash ascii date instead, and convert
to mtime when needed (storing an out_of_date value to mark the unconverted
values).

Archive handling is atrocious and need some clean-up.

Thanks to miod@@ who took the time to review those patches.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.34 2000/09/14 13:52:41 espie Exp $	*/
d72 1
a72 1
 *	Arch_MemTime	    	Find the modification time of a member of
d111 1
a111 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.34 2000/09/14 13:52:41 espie Exp $";
a1067 6
 * Results:
 *	TRUE if found.
 *
 * Side Effects:
 *	The mtime field is filled in.
 *
d1070 1
a1070 1
Boolean
d1117 1
a1117 1
    return gn->mtime == OUT_OF_DATE;
@


1.34
log
@Introduce a few macros to handle timestamps in an abstract way.

Replace the time stamp hash in dir.c with an open hashing structure.

In doing so, remove some nasty casts, simplify code a bit:
Dir_MTime can return a modification time, since make does not make
a distinction between out-of-date and non-existent files.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.33 2000/09/14 13:46:44 espie Exp $	*/
a102 1
#include    "hash.h"
d111 1
a111 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.33 2000/09/14 13:46:44 espie Exp $";
d126 1
a126 1
typedef struct Arch {
d128 2
a129 2
    Hash_Table	  members;    /* All the members of the archive described
			       * by <name, struct ar_hdr *> key/value pairs */
d134 22
d160 1
a160 1
static struct ar_hdr *ArchStatMember __P((char *, char *, Boolean));
d169 26
d214 2
a215 2
    Hash_Search	  search;
    Hash_Entry	  *entry;
d218 3
a220 4
    for (entry = Hash_EnumFirst(&a->members, &search);
	 entry != NULL;
	 entry = Hash_EnumNext(&search))
	free(Hash_GetValue(entry));
d224 1
a224 1
    Hash_DeleteTable(&a->members);
d484 1
a484 1
 *	From ArchStatMember and ArchFindMember via Lst_Find.
a487 4
 *
 * Side Effects:
 *	None.
 *
d491 1
a491 1
ArchFindArchive (ar, archName)
d500 1
a500 1
 * ArchStatMember --
d515 2
a516 2
static struct ar_hdr *
ArchStatMember (archive, member, hash)
d530 1
a530 1
    Hash_Entry	  *he;	      /* Entry containing member's description */
d534 4
d545 1
a545 1
    cp = strrchr (member, '/');
d552 13
a564 14

	he = Hash_FindEntry (&ar->members, member);

	if (he != NULL) {
	    return ((struct ar_hdr *) Hash_GetValue (he));
	} else {
	    /* Try truncated name */
	    char copy[AR_MAX_NAME_LEN+1];
	    int len = strlen (member);

	    if (len > AR_MAX_NAME_LEN) {
		len = AR_MAX_NAME_LEN;
		strncpy(copy, member, AR_MAX_NAME_LEN);
		copy[AR_MAX_NAME_LEN] = '\0';
d566 1
a566 3
	    if ((he = Hash_FindEntry (&ar->members, copy)) != NULL)
		return ((struct ar_hdr *) Hash_GetValue (he));
	    return (NULL);
d582 3
a584 3
	if (arch == NULL) {
	    return (NULL);
	} else {
d586 2
a587 1
	    return (&sarh);
d595 2
a596 2
    arch = fopen (archive, "r");
    if (arch == NULL) {
a597 1
    }
d603 4
a606 4
    if ((fread (magic, SARMAG, 1, arch) != 1) ||
    	(strncmp (magic, ARMAG, SARMAG) != 0)) {
	    fclose (arch);
	    return (NULL);
d609 2
a610 2
    ar = (Arch *)emalloc (sizeof (Arch));
    ar->name = estrdup (archive);
d613 1
a613 1
    Hash_InitTable (&ar->members, -1);
d616 2
a617 2
    while (fread ((char *)&arh, sizeof (struct ar_hdr), 1, arch) == 1) {
	if (strncmp ( arh.ar_fmag, ARFMAG, sizeof (arh.ar_fmag)) != 0) {
d633 1
a633 1
	    (void) strncpy (memName, arh.ar_name, sizeof(arh.ar_name));
d677 1
a677 1
		fseek (arch, -elen, SEEK_CUR);
d684 3
a686 3
	    he = Hash_CreateEntry(&ar->members, memName, NULL);
	    Hash_SetValue(he, emalloc(sizeof(struct ar_hdr)));
	    memcpy(Hash_GetValue(he), &arh, sizeof(struct ar_hdr));
d688 1
a688 1
	fseek (arch, (size + 1) & ~1, SEEK_CUR);
d691 1
a691 1
    fclose (arch);
d699 2
a700 1
    he = Hash_FindEntry (&ar->members, member);
d702 4
a705 5
    if (he != NULL) {
	return ((struct ar_hdr *) Hash_GetValue (he));
    } else {
	return (NULL);
    }
d709 1
a709 1
    Hash_DeleteTable(&ar->members);
d712 1
a712 1
    return NULL;
d1052 1
a1052 1
Arch_MTime (gn)
d1055 3
a1057 1
    struct ar_hdr *arhPtr;    /* Header of desired member */
a1058 7
    arhPtr = ArchStatMember(Varq_Value(ARCHIVE_INDEX, gn),
			     Varq_Value(MEMBER_INDEX, gn),
			     TRUE);
    if (arhPtr != NULL)
	gn->mtime = (time_t) strtol(arhPtr->ar_date, NULL, 10);
    else
    	gn->mtime = OUT_OF_DATE;
a1215 1
	struct ar_hdr  	*arhPtr;    /* Header for __.SYMDEF */
d1218 1
a1218 4
	arhPtr = ArchStatMember (gn->path, RANLIBMAG, FALSE);

	if (arhPtr != NULL) {
	    modTimeTOC = (time_t) strtol(arhPtr->ar_date, NULL, 10);
d1220 2
a1221 1
	    if (DEBUG(ARCH) || DEBUG(MAKE)) {
d1223 1
a1223 2
	    }
	    oodate = (gn->cmtime > modTimeTOC);
d1228 1
a1228 1
	    if (DEBUG(ARCH) || DEBUG(MAKE)) {
a1229 1
	    }
a1242 3
 *
 * Results:
 *	None.
@


1.33
log
@Replace the old hash used to hold file names within a directory with
open hashing.

An interesting optimization is that the open hashing interface is more
fine-grained, hence we can compute the correct hash value at the start
of Dir_FindFile, and reuse it for each hash structure into which we look
(the effect is measurable on large directories along with objdir/VPATH).

Remove a few unnecessary Lst_Open/Lst_Close that serve no purpose except
obfuscating the code.

The interface to dir.h changes slightly, hence tedious includes changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.32 2000/09/14 13:32:05 espie Exp $	*/
d112 1
a112 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.32 2000/09/14 13:32:05 espie Exp $";
d1001 1
a1001 1
 *	TRUE if found.
a1005 1
 *
d1008 1
a1008 1
Boolean
d1017 1
a1017 1
    if (arhPtr != NULL) {
d1019 1
a1019 2
	return TRUE;
    } else {
d1021 1
a1021 2
	return FALSE;
    }
@


1.32
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.31 2000/06/23 16:20:01 espie Exp $	*/
d94 1
d102 1
d112 1
a112 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.31 2000/06/23 16:20:01 espie Exp $";
@


1.31
log
@Once those special variable are taken care of, other Var functions can take
the GNode's context directly.  We rename that special Lst to `SymTable *'
in prevision of things to come.

Along the line, we lose the special GNodes affected to VAR_CMD, VAR_GLOBAL,
VAR_ENV, which become simple Lsts... This is not a problem, except when
getting to a context's name for debugging (handled very nicely by
offsetof).

Again, this is a preparatory patch, which does not gain anything except
for cleaning up issues...

Reviewed by millert@@ and miod@@, like the previous patch
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.30 2000/06/23 16:18:08 espie Exp $	*/
a41 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)arch.c	8.2 (Berkeley) 1/2/94";
#else
static char rcsid[] = "$OpenBSD: arch.c,v 1.30 2000/06/23 16:18:08 espie Exp $";
#endif
#endif /* not lint */

d105 9
a1011 1
    time_t	  modTime;    /* Modification time as an integer */
d1013 1
a1013 1
    arhPtr = ArchStatMember (Varq_Value(ARCHIVE_INDEX, gn),
@


1.30
log
@Start of variable fixes and speed-ups.

This patch may seem a bit non-sensical at first. It simply introduces some
new interface. Specifically, recognizes that some variable names
(.TARGET/$@@, .OODATE/$?, .ALLSRC/$>, .IMPSRC/$<, .PREFIX/$*, .ARCHIVE/$!,
.MEMBER/$%) are `special' (the actual variables which are local to a
target, e.g. GNode).

Currently, The Varq functions (for Varquick access) are only stubs to the
normal functions.

This fixes a very important detail before proceeding to turn variable lists
into hash tables: if every GNode holds a hash table, initialization times
for those will be very costly. But generic GNodes only hold those seven
special variables... which can be stored directly into a small array;
the only general cases are the environment, the command line and
global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.29 2000/06/23 16:15:49 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.29 2000/06/23 16:15:49 espie Exp $";
d200 1
a200 1
Arch_ParseArchive (linePtr, nodeLst, ctxt)
d203 1
a203 1
    GNode   	    *ctxt;  	    /* Context in which to expand variables */
@


1.29
log
@Trivial consequences of the previous list changes:

- audit code for Lst_Datum, it's never applied to an empty pointer,
so check can be removed -> turn into a macro,
- Lst_First, Lst_Last can become macro as well
- specialized version of Lst_Succ (Lst_Adv) to use in loops where it cannot
fail,
- Lst_Open can no longer fail. Trim down corresponding code.

Reviewed millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.28 2000/06/17 14:38:13 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.28 2000/06/17 14:38:13 espie Exp $";
d944 2
a945 2
    arch = ArchFindMember(Var_Value(ARCHIVE, gn),
			  Var_Value(MEMBER, gn),
d1013 2
a1014 2
    arhPtr = ArchStatMember (Var_Value(ARCHIVE, gn),
			     Var_Value(MEMBER, gn),
d1124 1
a1124 1
    Var_Set (TARGET, gn->name, gn);
d1126 1
a1126 1
    Var_Set (TARGET, gn->path == NULL ? gn->name : gn->path, gn);
@


1.28
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.27 2000/06/10 01:41:05 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.27 2000/06/10 01:41:05 espie Exp $";
d502 1
a502 1
	ar = (Arch *) Lst_Datum (ln);
d1048 1
a1048 4
    if (Lst_Open(&gn->parents) != SUCCESS) {
	gn->mtime = OUT_OF_DATE;
	return FALSE;
    }
d1050 1
a1050 1
	pgn = (GNode *) Lst_Datum (ln);
@


1.27
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.26 2000/03/26 16:21:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.26 2000/03/26 16:21:32 espie Exp $";
d122 1
a122 1
static Lst	  archives;   /* Lst of archives we've already examined */
d362 1
a362 1
	    Lst	  members = Lst_Init();
d365 3
a367 2
	    Dir_Expand(memName, dirSearchPath, members);
	    while ((member = (char *)Lst_DeQueue(members)) != NULL) {
d371 2
a372 2
		gn = Targ_FindNode (nameBuf, TARG_CREATE);
		if (gn == NULL) {
d374 1
a374 1
		} else {
d386 1
a386 1
	    Lst_Destroy(members, NOFREE);
d500 1
a500 1
    ln = Lst_Find(archives, ArchFindArchive, archive);
d647 1
a647 1
    Lst_AtEnd(archives, ar);
d1048 1
a1048 1
    if (Lst_Open (gn->parents) != SUCCESS) {
d1052 1
a1052 1
    while ((ln = Lst_Next (gn->parents)) != NULL) {
d1087 1
a1087 1
    Lst_Close (gn->parents);
d1175 1
a1175 1
    if (OP_NOP(gn->type) && Lst_IsEmpty(gn->children)) {
d1224 1
a1224 1
Arch_Init ()
d1226 1
a1226 1
    archives = Lst_Init();
d1248 1
a1248 1
    Lst_Destroy(archives, ArchFree);
@


1.26
log
@Remove idiotic, braindead casts T* -> void*
They serve no purpose, except hiding potential bugs.

In particular, remove (ClientData) cast from macro, showing potentially
troublesome use of Hashes to store time_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.25 2000/02/02 13:47:46 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.25 2000/02/02 13:47:46 espie Exp $";
d132 1
a132 1
static int ArchFindArchive __P((ClientData, ClientData));
d134 1
a134 1
static void ArchFree __P((ClientData));
d161 1
a161 1
    ClientData ap;
d171 1
a171 1
	free((Address) Hash_GetValue (entry));
d176 1
a176 1
    free((Address) a);
d446 2
a447 2
    ClientData	  ar;	      	  /* Current list element */
    ClientData	  archName;  	  /* Name we want */
d449 1
a449 1
    return (strcmp ((char *) archName, ((Arch *) ar)->name));
d637 3
a639 4
	    he = Hash_CreateEntry (&ar->members, memName, NULL);
	    Hash_SetValue (he, emalloc (sizeof (struct ar_hdr)));
	    memcpy ((Address)Hash_GetValue (he), (Address)&arh,
		sizeof (struct ar_hdr));
d661 2
a662 2
    fclose (arch);
    Hash_DeleteTable (&ar->members);
d664 2
a665 2
    free ((Address)ar);
    return (NULL);
@


1.25
log
@Bug-fix: make should behave sensibly when presented with negative times...

- let *_MTime return booleans, as that's what they're used for, the time_t
is set as a side effect.

- use OUT_OF_DATE for a date starting point, set it at the origin of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.24 2000/01/08 09:45:15 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.24 2000/01/08 09:45:15 espie Exp $";
d347 1
a347 1
		    Lst_AtEnd(nodeLst, (ClientData)gn);
d382 1
a382 1
		    Lst_AtEnd(nodeLst, (ClientData)gn);
d400 1
a400 1
		Lst_AtEnd(nodeLst, (ClientData)gn);
d499 1
a499 1
    ln = Lst_Find(archives, ArchFindArchive, (ClientData)archive);
d638 1
a638 1
	    Hash_SetValue (he, (ClientData)emalloc (sizeof (struct ar_hdr)));
d647 1
a647 1
    Lst_AtEnd(archives, (ClientData)ar);
@


1.24
log
@Finish changing all Var_Parse arguments to size_t. Thanks to millert@@
for reminding me.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.23 1999/12/19 00:04:24 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.23 1999/12/19 00:04:24 espie Exp $";
d76 3
a78 3
 *	    	  	    	an archive *in the archive*. The time is also
 *	    	  	    	placed in the member's GNode. Returns the
 *	    	  	    	modification time.
d998 1
a998 1
 *	The modification time (seconds).
d1006 1
a1006 1
time_t
d1017 2
a1018 1
	modTime = (time_t) strtol(arhPtr->ar_date, NULL, 10);
d1020 2
a1021 1
	modTime = 0;
a1022 3

    gn->mtime = modTime;
    return (modTime);
d1032 1
a1032 1
 *	The modification time.
d1039 1
a1039 1
time_t
d1049 2
a1050 2
	gn->mtime = 0;
	return (0);
d1072 4
a1075 1
				     gn->mtime = Arch_MTime(pgn);
d1082 1
a1082 1
	    gn->mtime = 0;
d1089 1
a1089 1
    return (gn->mtime);
d1177 3
a1179 2
    } else if ((gn->mtime > now) || (gn->mtime < gn->cmtime) || !gn->mtime) {
	oodate = TRUE;
d1183 1
a1183 1
	int 	  	modTimeTOC; /* The table-of-contents's mod time */
d1188 1
a1188 1
	    modTimeTOC = (int) strtol(arhPtr->ar_date, NULL, 10);
@


1.23
log
@Rearrange Lst_Find interface to conform better with other functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.22 1999/12/18 21:58:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.22 1999/12/18 21:58:07 espie Exp $";
d224 1
a224 1
	    int 	length;
d266 1
a266 1
		int 	length;
@


1.22
log
@Nothing ever checks ReturnStatus on Lst_Insert, Lst_Append, Lst_AtFront,
Lst_AtEnd, Lst_Concat, Lst_Remove, Lst_Replace.

Don't bother returning one.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.21 1999/12/18 21:56:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.21 1999/12/18 21:56:07 espie Exp $";
d499 1
a499 1
    ln = Lst_Find (archives, (ClientData) archive, ArchFindArchive);
@


1.21
log
@Lst_DeQueue already checks for empty lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.20 1999/12/18 21:53:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.20 1999/12/18 21:53:32 espie Exp $";
d347 1
a347 1
		    (void)Lst_AtEnd(nodeLst, (ClientData)gn);
d382 1
a382 1
		    (void) Lst_AtEnd (nodeLst, (ClientData)gn);
d400 1
a400 1
		(void) Lst_AtEnd (nodeLst, (ClientData)gn);
d647 1
a647 1
    (void) Lst_AtEnd (archives, (ClientData) ar);
@


1.20
log
@NIL, NILGNODE, etc, are only glorified NULL.
Get rid of them.

Get rid of list.h, nothing uses it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.19 1999/12/18 02:11:26 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.19 1999/12/18 02:11:26 espie Exp $";
d366 1
a366 2
	    while (!Lst_IsEmpty(members)) {
		member = (char *)Lst_DeQueue(members);
@


1.19
log
@make does not use circular lists, get rid of the extra weight.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.18 1999/12/16 17:27:18 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.18 1999/12/16 17:27:18 espie Exp $";
d342 1
a342 1
		if (gn == NILGNODE) {
d372 1
a372 1
		if (gn == NILGNODE) {
d390 1
a390 1
	    if (gn == NILGNODE) {
d501 1
a501 1
    if (ln != NILLNODE) {
d1054 1
a1054 1
    while ((ln = Lst_Next (gn->parents)) != NILLNODE) {
@


1.18
log
@Var_Subst is actually two distinct functions folded into one:
split the function specific to for.c out, and give them more sensible
arguments at the same time.

This makes .for loop handling more efficient, as we have some heuristic
to evaluate the size of the buffer needed...
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.17 1999/12/06 22:28:43 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.17 1999/12/06 22:28:43 espie Exp $";
d362 1
a362 1
	    Lst	  members = Lst_Init(FALSE);
d1224 1
a1224 1
    archives = Lst_Init (FALSE);
@


1.17
log
@Extra parameter no longer needed, ditch.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.16 1999/10/05 22:06:23 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.16 1999/10/05 22:06:23 espie Exp $";
d244 1
a244 1
	libName = Var_Subst(NULL, libName, ctxt, TRUE);
d323 1
a323 1
	    memName = Var_Subst(NULL, memName, ctxt, TRUE);
@


1.16
log
@Efficiency patch from NetBSD:
make spends time freeing data structures right before exiting.
So don't bother.
Keep the code inside #ifdef, so that it's still there if someone
ever wants to use make code inside a library.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.15 1999/06/01 17:54:31 pefo Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.15 1999/06/01 17:54:31 pefo Exp $";
a943 1
    char *p1, *p2;
d945 2
a946 2
    arch = ArchFindMember(Var_Value (ARCHIVE, gn, &p1),
			  Var_Value (MEMBER, gn, &p2),
a947 2
    efree(p1);
    efree(p2);
a1012 1
    char *p1, *p2;
d1014 2
a1015 2
    arhPtr = ArchStatMember (Var_Value (ARCHIVE, gn, &p1),
			     Var_Value (MEMBER, gn, &p2),
a1016 3
    efree(p1);
    efree(p2);

@


1.15
log
@Fix some mips -> __mips__ stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.14 1998/12/05 00:06:26 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.14 1998/12/05 00:06:26 espie Exp $";
d133 1
d135 1
d145 1
d178 1
d1252 1
d1254 1
@


1.14
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.12 1998/07/02 20:47:25 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.12 1998/07/02 20:47:25 millert Exp $";
d137 1
a137 1
    (defined(__OpenBSD__) && defined(__mips)) || \
@


1.13
log
@Use SEEK_CUR as "whence" in fseek, not 1.
@
text
@d113 9
d171 1
a171 2
    if (a->fnametab)
	free(a->fnametab);
d661 1
a661 2
    if (ar->fnametab)
	free(ar->fnametab);
d737 2
a738 1
	    printf("Found svr4 archive name table with %d entries\n", entry);
d755 2
a756 2
	    printf("SVR4 entry offset %s is greater than %d\n",
		   name, ar->fnamesize);
d943 1
a943 1
			  Var_Value (TARGET, gn, &p2),
d945 2
a946 4
    if (p1)
	free(p1);
    if (p2)
	free(p2);
d1006 1
a1006 1
int
d1011 1
a1011 1
    int		  modTime;    /* Modification time as an integer */
d1015 1
a1015 1
			     Var_Value (TARGET, gn, &p2),
d1017 2
a1018 4
    if (p1)
	free(p1);
    if (p2)
	free(p2);
d1021 1
a1021 1
	modTime = (int) strtol(arhPtr->ar_date, NULL, 10);
d1044 1
a1044 1
int
d1068 6
a1073 2
	    nameStart = strchr (pgn->name, '(') + 1;
	    nameEnd = strchr (nameStart, ')');
d1075 1
a1075 1
	    if (pgn->make && nameStart != (char *)1 && nameEnd != NULL &&
@


1.12
log
@Fix a bug where make gets confused by targets beginning with a period (``.'')
and tried to do a suffix conversion, following a NULL pointer in the
proccess.  Also add some sanity checks so we don't blindly assume
strchr returns non-NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.11 1997/10/13 14:47:14 pefo Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.11 1997/10/13 14:47:14 pefo Exp $";
d619 1
a619 1
		fseek (arch, -elen, 1);
d631 1
a631 1
	fseek (arch, (size + 1) & ~1, 1);
d851 1
a851 1
		fseek (arch, -sizeof(struct ar_hdr), 1);
d881 1
a881 1
			fseek (arch, -sizeof(struct ar_hdr) - elen, 1);
d884 1
a884 1
		fseek (arch, -elen, 1);
d899 1
a899 1
	    fseek (arch, (size + 1) & ~1, 1);
@


1.11
log
@powerpc ELF
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.10 1997/06/17 20:34:43 kstailey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.10 1997/06/17 20:34:43 kstailey Exp $";
d1067 1
a1067 1
	    if (pgn->make &&
@


1.10
log
@(foo *)NULL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.9 1996/11/30 21:08:49 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.9 1996/11/30 21:08:49 millert Exp $";
d128 2
a129 1
    (defined(__OpenBSD__) && defined(__mips))
@


1.9
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.8 1996/10/17 19:08:44 niklas Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.8 1996/10/17 19:08:44 niklas Exp $";
d156 1
a156 1
	 entry != (Hash_Entry *)NULL;
d484 1
a484 1
    if (cp != (char *) NULL) {
a485 1
    }
d493 1
a493 1
	if (he != (Hash_Entry *) NULL) {
d507 1
a507 1
	    return ((struct ar_hdr *) NULL);
d523 2
a524 2
	 if (arch == (FILE *)NULL) {
	    return ((struct ar_hdr *)NULL);
d536 2
a537 2
    if (arch == (FILE *) NULL) {
	return ((struct ar_hdr *) NULL);
d547 1
a547 1
	    return ((struct ar_hdr *) NULL);
d625 1
a625 1
	    he = Hash_CreateEntry (&ar->members, memName, (Boolean *)NULL);
d643 1
a643 1
    if (he != (Hash_Entry *) NULL) {
d646 1
a646 1
	return ((struct ar_hdr *) NULL);
d655 1
a655 1
    return ((struct ar_hdr *) NULL);
d795 2
a796 2
    if (arch == (FILE *) NULL) {
	return ((FILE *) NULL);
d806 1
a806 1
	    return ((FILE *) NULL);
d831 1
a831 1
	     return ((FILE *) NULL);
d907 1
a907 1
    return ((FILE *) NULL);
d942 1
a942 1
    if (arch != (FILE *) NULL) {
d975 1
a975 1
    if (arch != (FILE *) NULL) {
d1015 1
a1015 1
    if (arhPtr != (struct ar_hdr *) NULL) {
d1122 1
a1122 1
    Var_Set (TARGET, gn->path == (char *) NULL ? gn->name : gn->path, gn);
d1179 1
a1179 1
	if (arhPtr != (struct ar_hdr *)NULL) {
@


1.8
log
@Do not consider non-existent archives as up-to-date on non-a.out systems
@
text
@d1 2
a2 2
/*	$OpenBSD: arch.c,v 1.7 1996/09/21 19:36:27 niklas Exp $	*/
/*	$NetBSD: arch.c,v 1.16 1996/08/13 16:42:00 christos Exp $	*/
d5 2
a6 2
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
d44 1
a44 2
static char sccsid[] = "@@(#)arch.c	5.7 (Berkeley) 12/28/90";
static char rcsid[] = "$NetBSD: arch.c,v 1.14 1996/03/12 18:04:27 christos Exp $";
d46 1
a46 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.7 1996/09/21 19:36:27 niklas Exp $";
d107 1
d153 2
a154 2
    
    /* Free memory from hash entries */ 
d166 1
a166 1
	
d202 1
a202 1
    
d214 1
a214 1
	    
d221 1
a221 1
	    
d233 1
a233 1
    
d309 1
a309 1
	    
d355 1
a355 1
		
d394 1
a394 1
	
d540 1
a540 1
    
d557 1
a557 1
    
d799 1
a799 1
    
d824 1
a824 1
    
d1089 1
a1089 1
 *	Search for a library along the given search path. 
d1153 1
a1153 1
 *		  TOC. 
d1168 1
a1168 1
    
d1241 34
@


1.7
log
@Do not look for a.out t.o.c sections in the mips-based ports
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.6 1996/09/02 16:04:07 briggs Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.6 1996/09/02 16:04:07 briggs Exp $";
d1171 1
a1171 1
    } else if ((gn->mtime > now) || (gn->mtime < gn->cmtime)) {
@


1.6
log
@Sync up with NetBSD:
(christos)
	Fix bug reported by Greg Hudson where leaf (source only) nodes were
	referenced only by their basename and not by their full pathname. This
	breaks when .PATH or MAKEOBJDIR are used. There might be Makefiles
	around that try to work around this bug by prepending ${.CURDIR} to
	the sources, and they should be found and fixed. Also a lot of the gunk
	in suff.c that was attempting to work around the same problem could be
	removed.
(christos)
	- Move -D flags from Makefile to config.h and explain what they do. Add
	  -Wall -Wno-unused to CFLAGS. Add new define SYSVVARSUB to enable SysV
	  style variable substitutions and enable them.
	- Add SunOS style command substitutions via SUNSHCMD
	- Fix core dump with '{variable = value'
(christos)
	Fix bug where make will always exit with 0, even when one or more
	parallel jobs failed. (Only affects parallel make code)
(christos)
	Protect __P from being multiply defined (for systems that already
	define it)
(christos) Add strdup() since ultrix is missing it.
	From Larry Schwimmer <rosebud@@cyclone.Stanford.EDU>
(christos) Add estrdup(), a checked version of strdup and use it.
(christos) Recognize SVR4 style long filename entries in archives.
(thorpej) Tidy up some RCS ids a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: arch.c,v 1.5 1996/07/31 00:01:04 niklas Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.5 1996/07/31 00:01:04 niklas Exp $";
d127 2
a128 1
#if defined(__svr4__) || defined(__SVR4)
@


1.5
log
@RANLIBMAG should not be set on alphas, as make doesn't know ECOFF archives
@
text
@d1 2
a2 2
/*	$OpenBSD: arch.c,v 1.4 1996/03/27 19:32:35 niklas Exp $	*/
/*	$NetBSD: arch.c,v 1.14 1996/03/12 18:04:27 christos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: arch.c,v 1.4 1996/03/27 19:32:35 niklas Exp $";
a104 3
#if !defined(__svr4__) && !defined(__SVR4) && !defined(__alpha__)
#include    <ranlib.h>
#endif
d119 2
d127 4
d160 2
d551 3
a553 1
    ar->name = strdup (archive);
d559 5
a563 8
				 /*
				  * The header is bogus, so the archive is bad
				  * and there's no way we can recover...
				  */
				 fclose (arch);
				 Hash_DeleteTable (&ar->members);
				 free ((Address)ar);
				 return ((struct ar_hdr *) NULL);
d565 9
d580 21
a600 4
#if defined(__svr4__) || defined(__SVR4)
	    /* svr4 names are slash terminated */
	    if (cp[0] == '/')
		cp[0] = '\0';
d613 4
a616 12
		if (elen > MAXPATHLEN) {
			fclose (arch);
			Hash_DeleteTable (&ar->members);
			free ((Address)ar);
			return ((struct ar_hdr *) NULL);
		}
		if (fread (memName, elen, 1, arch) != 1) {
			fclose (arch);
			Hash_DeleteTable (&ar->members);
			free ((Address)ar);
			return ((struct ar_hdr *) NULL);
		}
a629 8
	/*
	 * We need to advance the stream's pointer to the start of the
	 * next header. Files are padded with newlines to an even-byte
	 * boundary, so we need to extract the size of the file from the
	 * 'size' field of the header and round it up during the seek.
	 */
	arh.ar_size[sizeof(arh.ar_size)-1] = '\0';
	size = (int) strtol(arh.ar_size, NULL, 10);
d648 8
d657 105
@


1.4
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD$";
d105 1
a105 1
#if !defined(__svr4__) && !defined(__SVR4) 
@


1.3
log
@From NetBSD:
Support SVR4 style archives.
Fix pr/1421 (from Matthew Green) and pr/1997 (from Jeff Thieleke).
In ParseDoInclude(), make a temporary copy of the current file name
while searching for ""-type include files, since the current file name
might not be a writeable string.
@
text
@d1 2
a2 1
/*	$NetBSD: arch.c,v 1.13 1996/02/04 22:20:34 christos Exp $	*/
d45 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: arch.c,v 1.13 1996/02/04 22:20:34 christos Exp $";
d1069 1
a1069 1
	oodata = FALSE;
@


1.2
log
@from christos@@netbsd:
Minor:
    - ${.PREFIX} should never contain a full pathname
    - Fixed gcc -Wall warnings
Major:
    - compatMake is now FALSE. This means that we are now running in
      full pmake mode:
          * rules on dependency lines can be executed in parallel and or
            out of sequence:

            foo: bar baz

            can fire the rule for baz before the rule for bar is fired.
            To enforce bar to be fired before baz, another rule needs to be
            added. [bar: baz]
          * adjacent shell commands in a target are now executed by a single
            invocation of the shell, not one invocation of the shell per line
      (compatMake can be turned off using the -B flag)
    - The -j flag now works... I.e. make -j 4 will fork up to four jobs in
      parallel when it can. The target name is printed before each burst
      of output caused by the target execution as '--- target ---', when j > 1
    - I have changed all the Makefiles so that they work with make -j N, and
      I have tested the whole netbsd by:
          'make -j 4 cleandir; make -j 4 depend; make -j 4; make -j 4 install'
    - I have not compiled or tested this version of make with -DREMOTE.
- Turn compat mode on by default. It gets turned off when the -j without
  the -B flag is specified. [Thus you can use -j 1 to turn it off].
- Fix malloc -> emalloc as Gordon noted.
Updates for POSIX/SVR4 compiling:
arch.c:          Don't require ranlib stuff. Not everybody has it.
dir.c:           SunOS-4 != Solaris; change #ifdef sun to #if sun && !__svr4__
job.c, compat.c: Don't use 'union wait', use int and the W*() macros.
main.c:          Check for uname() == -1; some unames return > 0...
util.c, job.c:   Add signal() with BSD semantics for svr4, don't use bsd
                 sigmask and friends.

from cgd@@netbsd:
pull in make.h.  (PAlloc() now uses emalloc(), which is prototyped in
make.h.  If the prototype is not in scope on the Alpha, I see lots
of "cast to pointer from integer of different size" warnings.)
@
text
@d1 1
a1 1
/*	$NetBSD: arch.c,v 1.11 1995/11/22 17:39:53 christos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: arch.c,v 1.11 1995/11/22 17:39:53 christos Exp $";
d103 1
a103 1
#ifndef __svr4__
d106 1
d565 6
d838 1
d841 1
a841 1
    struct timeval  times[2];	/* Times for utimes() call */
d850 2
a851 3
	times[0].tv_sec = times[1].tv_sec = now;
	times[0].tv_usec = times[1].tv_usec = 0;
	utimes(gn->path, times);
d853 1
d994 1
a994 1
#endif LIBRARIES
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: arch.c,v 1.9 1995/06/14 15:18:46 christos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: arch.c,v 1.9 1995/06/14 15:18:46 christos Exp $";
d103 1
d105 1
d497 1
a497 1
	    if (he = Hash_FindEntry (&ar->members, copy))
d1036 1
d1058 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
