head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.6
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.17.0.12
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.8
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.10
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.14.0.10
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.8
	OPENBSD_5_0:1.14.0.6
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.12.0.6
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.1.0.24
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.22
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.20
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.18
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.16
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.14
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_5:1.1.0.12
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.10
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.8
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.6
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.4
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.19
date	2016.10.23.14.54.14;	author espie;	state Exp;
branches;
next	1.18;
commitid	wPoE1FuixzUwl6nK;

1.18
date	2016.10.14.09.27.21;	author natano;	state Exp;
branches;
next	1.17;
commitid	xK9iXmhQ2bSDSVMb;

1.17
date	2014.01.06.12.08.18;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.09.19.39.59;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2012.10.02.10.29.31;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2009.05.13.10.47.54;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.17.16.39.45;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.17.09.46.20;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.17.09.45.37;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.17.09.44.20;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.30.10.03.11;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2007.07.30.09.51.53;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2007.07.24.18.52.47;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2007.07.20.12.32.45;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2007.07.08.17.53.15;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2007.07.08.17.44.20;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.23.12.34.52;	author espie;	state Exp;
branches;
next	;


desc
@@


1.19
log
@add !!=
feedback and okay millert@@
@
text
@#ifndef VAR_H
#define VAR_H
/* $OpenBSD: var.h,v 1.18 2016/10/14 09:27:21 natano Exp $ */
/*
 * Copyright (c) 2001 Marc Espie.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

extern GNode *current_node;
extern void Var_Init(void);
extern void Var_setCheckEnvFirst(bool);

/* Global variable handling. */
/* value = Var_Valuei(name, end);
 *	Returns value of global variable name/end, or NULL if inexistent. */
extern char *Var_Valuei(const char *, const char *);
#define Var_Value(n)	Var_Valuei(n, NULL)

/* isDefined = Var_Definedi(name, end);
 *	Checks whether global variable name/end is defined. */
extern bool Var_Definedi(const char *, const char *);

/* Var_Seti_with_ctxt(name, end, val, ctxt);
 *	Sets value val of variable name/end.  Copies val.
 *	ctxt can be VAR_CMD (command line) or VAR_GLOBAL (normal variable). */
extern void Var_Seti_with_ctxt(const char *, const char *, const char *,
	int);
#define Var_Set(n, v)	Var_Seti_with_ctxt(n, NULL, v, VAR_GLOBAL)
#define Var_Seti(n, e, v) Var_Seti_with_ctxt(n, e, v, VAR_GLOBAL)
/* Var_Appendi_with_ctxt(name, end, val, cxt);
 *	Appends value val to variable name/end in context ctxt, defining it
 *	if it does not already exist, and inserting one space otherwise. */
extern void Var_Appendi_with_ctxt(const char *, const char *,
	const char *, int);
#define Var_Append(n, v)	Var_Appendi_with_ctxt(n, NULL, v, VAR_GLOBAL)
#define Var_Appendi(n, e, v) 	Var_Appendi_with_ctxt(n, e, v, VAR_GLOBAL)

/* Var_Deletei(name, end);
 *	Deletes a global variable. */
extern void Var_Deletei(const char *, const char *);

/* Dynamic variable indices */
#define TARGET_INDEX	0
#define PREFIX_INDEX	1
#define ARCHIVE_INDEX	2
#define MEMBER_INDEX	3
#define IMPSRC_INDEX	4
#define OODATE_INDEX	5
#define ALLSRC_INDEX	6

#define Var(idx, gn)	((gn)->context.locals[idx])


/* SymTable_Init(t);
 *	Inits the local symtable in a GNode. */
extern void SymTable_Init(SymTable *);
/* SymTable_destroy(t);
 *	Destroys the local symtable in a GNode. */
extern void SymTable_Destroy(SymTable *);

/* Several ways to parse a variable specification. */
/* value = Var_Parse(varspec, ctxt, undef_is_bad, &length, &freeit);
 *	Parses a variable specification varspec and evaluates it in context
 *	ctxt.  Returns the resulting value, freeit indicates whether it's
 *	a copy that should be freed when no longer needed.  If it's not a
 *	copy, it's only valid until the next time variables are set.
 *	The length of the spec is returned in length, e.g., varspec begins
 *	at the $ and ends at the closing } or ).  Returns special value
 *	var_Error if a problem occurred. */
extern char *Var_Parse(const char *, SymTable *, bool, size_t *,
	bool *);
/* Note that var_Error is an instance of the empty string "", so that
 * callers who don't care don't need to. */
extern char	var_Error[];

/* ok = Var_ParseSkip(&varspec, ctxt, &ok);
 *	Parses a variable specification and returns true if the varspec
 *	is correct. Advances pointer past specification.  */
extern bool Var_ParseSkip(const char **, SymTable *);

/* ok = Var_ParseBuffer(buf, varspec, ctxt, undef_is_bad, &length);
 *	Similar to Var_Parse, except the value is directly appended to
 *	buffer buf. */
extern bool Var_ParseBuffer(Buffer, const char *, SymTable *,
	bool, size_t *);


/* The substitution itself */
/* subst = Var_Subst(str, ctxt, undef_is_bad);
 *	Substitutes all variable values in string str under context ctxt.
 *	Emit a PARSE_FATAL error if undef_is_bad and an undef variable is
 *	encountered. The result is always a copy that should be free. */
extern char *Var_Subst(const char *, SymTable *, bool);
/* subst = Var_Substi(str, estr, ctxt, undef_if_bad);
 */
extern char *Var_Substi(const char *, const char *, SymTable *, bool);

/* has_target = Var_Check_for_target(s):
 *	specialized tweak on Var_Subst that reads through a command line
 *	and looks for stuff like $@@.
 *	Use to desambiguate a list of targets into a target group.
 */
extern bool Var_Check_for_target(const char *);

/* For loop handling.
 *	// Create handle for variable name.
 *	handle = Var_NewLoopVar(name, end);
 *	// set up buffer
 *	for (...)
 *		// Substitute val for variable in str, and accumulate in buffer
 *		Var_SubstVar(buffer, str, handle, val);
 *	// Free handle
 *	Var_DeleteLoopVar(handle);
 */
struct LoopVar;	/* opaque handle */
struct LoopVar *Var_NewLoopVar(const char *, const char *);
void Var_DeleteLoopVar(struct LoopVar *);
extern void Var_SubstVar(Buffer, const char *, struct LoopVar *, const char *);
char *Var_LoopVarName(struct LoopVar *);


/* Var_Dump();
 *	Print out all global variables. */
extern void Var_Dump(void);

/* Var_AddCmdline(name);
 *	Add all variable values from VAR_CMD to variable name.
 *	Used to propagate variable values to submakes through MAKEFLAGS.  */
extern void Var_AddCmdline(const char *);

/* stuff common to var.c and varparse.c */
extern bool	errorIsOkay;

#define		VAR_GLOBAL	0
	/* Variables defined in a global context, e.g in the Makefile itself */
#define		VAR_CMD		1
	/* Variables defined on the command line */

#define POISON_INVALID		0
#define POISON_DEFINED		1
#define POISON_NORMAL		64
#define POISON_EMPTY		128
#define POISON_NOT_DEFINED	256
#define VAR_EXEC_LATER		512

extern void Var_Mark(const char *, const char *, unsigned int);
#endif
@


1.18
log
@Implement the ${<D} and ${<F} variables, as documented in the manual.
They are equivalent to ${<:H} and ${<:T} repectively, however the former
variants are more portable, as they are understood by GNU, FreeBSD and
NetBSD make too.

absence of those variables reported by Dario Niedermann <dnied at tiscali.it>
ok millert espie
@
text
@d3 1
a3 1
/* $OpenBSD: var.h,v 1.17 2014/01/06 12:08:18 espie Exp $ */
d164 1
d166 1
a166 1
extern void Var_MarkPoisoned(const char *, const char *, unsigned int);
@


1.17
log
@fix error messages, avoid dereferencing null pointers.
- the code becomes too indented, pull it into a separate function
- add an extra hint, the current_gnode.
- specifically, variables may be expanded during
target: prereq  solving in Suff_FindDeps, this is after parsing,
not during command execution, and the only actual indication with have is
that we're resolving a prereq of.

(this ought to fix mk35, and partially solve mk34)
@
text
@d3 1
a3 1
/* $OpenBSD: var.h,v 1.16 2012/10/09 19:39:59 espie Exp $ */
d67 3
a69 3
#define OODATE_INDEX	4
#define ALLSRC_INDEX	5
#define IMPSRC_INDEX	6
@


1.16
log
@new interface: look in command lines for variables that indicate a list of
targets is actually separate targets.
@
text
@d3 1
a3 1
/* $OpenBSD: var.h,v 1.15 2012/10/02 10:29:31 espie Exp $ */
d29 1
@


1.15
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d3 1
a3 1
/* $OpenBSD: var.h,v 1.14 2010/07/19 19:46:44 espie Exp $ */
d117 6
a164 1

@


1.14
log
@Correct $OpenBSD$ stuff
@
text
@d3 1
a3 1
/* $OpenBSD$ */
a29 6
#ifdef CLEANUP
extern void Var_End(void);
#else
#define Var_End()
#endif

@


1.13
log
@fix loopvar debug prints. Issue reported by naddy@@
@
text
@d3 1
@


1.12
log
@simplify dynamic variable handling a great deal:
first remove all usage of Varq_Append by building the string directly.
then replace `common' handling with specialized handling for dynamic
strings (since they no longer need a buffer). Finally, identify the place
where the variable value needs to be copied because it's going to be free'd
or erased soon, and finally, use simple char* pointers.

Shaves about 80 bytes off every gnode structure, and kills quite a few
unnecessary malloc()s as well.
@
text
@d137 1
@


1.11
log
@forgot one space
@
text
@d74 3
a76 9
/* value = Varq_Value(index, node);
 *	Returns value of dynamic variable for a given node. */
extern char *Varq_Value(int,  GNode *);
/* Varq_Set(index, val, node);
 *	Sets value of dynamic variable for a given node. Copies val. */
extern void Varq_Set(int, const char *, GNode *);
/* Varq_Append(index, val, node);
 *	Appends to value of dynamic variable for a given node. */
extern void Varq_Append(int, const char *, GNode *);
@


1.10
log
@more zap spaces
@
text
@d155 1
a155 1
extern bool	errorIsOkay;	
@


1.9
log
@zap more spaces at end of line
@
text
@d104 1
a104 1
extern char	var_Error[];	
@


1.8
log
@kill extra spaces at end of line
@
text
@d61 1
a61 1
	
@


1.7
log
@introduce a Var_Substi to substitute on intervals.
Since we don't really know how to change Var_Subst and dependent functions,
we cheat, and copy the string to a buffer instead.

Clean-up the parser a bit: reorganize the include files lookup function:
introduce a resolve_include_filename function that figures out the full name
of the file, introduce a handle_include_file that does all the include file
handling, and rename the functions into handle_xxx_include, so that we
can remove most comments.

Rename ParseIsCond into handle_bsd_command, cut most of its code into
constituent functions.

Semantic changes:
- follow the rules that, if an optional construct does not parse correctly,
then it's not a real extension, and give the normal parser a chance to figure
it out. If the syntax checks out, semantic errors ARE real errors.
- allow variables to not be defined in include file names, no reason not to.

okay miod@@
@
text
@d107 1
a107 1
 *	Parses a variable specification and returns true if the varspec 
@


1.6
log
@everywhere except in Var_Parse, we always add/append variables to the
VAR_GLOBAL context, so make it the common case: rename the basic functions
to Var_Set_with_ctxt/Var_Append_with_ctxt, define Var_Set and Var_Append
as macros that specify VAR_GLOBAL, and use these.

okay miod@@
@
text
@d124 3
@


1.5
log
@change Var_ParseSkip API to increment the position instead of returning a
length, simplifies code.

(warns a bit, symptom of some further issues to fix).

okay millert@@
@
text
@d47 1
a47 1
/* Var_Seti(name, end, val, ctxt);
d50 1
a50 1
extern void Var_Seti(const char *, const char *, const char *,
d52 3
a54 2
#define Var_Set(n, v, ctxt)	Var_Seti(n, NULL, v, ctxt)
/* Var_Appendi(name, end, val, cxt);
d57 1
a57 1
extern void Var_Appendi(const char *, const char *,
d59 2
a60 1
#define Var_Append(n, v, ctxt)	Var_Appendi(n, NULL, v, ctxt)
@


1.4
log
@big clean-up patch:
- rename a few functions in var.c to names that make more sense.
- introduce Var_Deletei because it makes more sense.
- rewrite .for loops to use a local LoopVar construct to avoid looking up more
stuff.
- reformat var.c to near K&R
- rewrite most comments in var.c

shown to a few people. millert@@ gave me his okay since it passes through
ports correctly.
@
text
@d104 4
a107 5
/* length = Var_ParseSkip(varspec, ctxt, &ok);
 *	Parses a variable specification and returns the specification
 *	length. Fills ok if the varspec is correct, that pointer can be
 *	NULL if this information is not needed.  */
extern size_t Var_ParseSkip(const char *, SymTable *, bool *);
@


1.3
log
@rename variable to errorIsOkay. What does oldVars mean anyway ?
@
text
@d37 1
a37 1
/* Global contexts handling. */
d42 3
a44 1
/* Only check if variable is defined */
d48 2
a49 1
 *	Sets value val of variable name/end in context ctxt.  Copies val. */
d60 3
a62 3
/* Var_Delete(name);
 *	Deletes a variable from the global context.  */
extern void Var_Delete(const char *);
d64 1
a64 1
/* Local context handling */
d72 2
d75 2
d78 2
d124 16
a139 8
/* Var_SubstVar(buf, str, varname, val);
 *	Substitutes variable varname with value val in string str, adding
 *	the result to buffer buf.  undefs are never error. */
extern void Var_SubstVar(Buffer, const char *, const char *, const char *);

/* Note that substituting to a buffer in Var_Subst is not useful. On the
 * other hand, handling intervals in Var_Subst and Var_Parse would be
 * useful, but this is hard. */
d153 1
a153 1
#define		VAR_GLOBAL	0 
d158 2
a159 2
#define POISON_INVALID 		0
#define POISON_DEFINED 		1
@


1.2
log
@A set of big related changes. okay millert@@, tested further by kettenis@@
and matthieu@@

This all revolves around putting ALL global variables into one single big
hash, and using flags. This removes some impossible to understand stuff,
like old varfind, and allows for some nice stuff.
- each time we reference a global variable, we create it, possibly as a dummy
variable.
- each time we go to the environment, we remember it, thus we no longer go
back to it.

Lists of dependant changes:
- isolate changes to oldVars and checkEnvFirst.
- remove VAR_CMD and VAR_GLOBAL contexts. The only distinction is in parsevar.
Split Parse_DoVar into Parse_DoVar and Parse_CmdlineVar
- rework var modules around obtain_global_var, observe flags in various
functions like Var_Value and Var_Seti.
- Var_Seti/Var_Appendi are almost the same code, use that internally.
- add magic to handle the very special SHELL variable.
- introduce Var_Definedi for the cases where we don't want the actual
value, to simplify tests.
- add keyword .poison, parse it and set global flags accordingly.
- do poison_checks where needed.
- document poison.
- in for loops, set variable temporarily, so that Var_SubstVar will also
substitute it in varmodifiers expressions.
@
text
@d134 1
a134 1
extern bool	oldVars;	/* Do old-style variable substitution */
@


1.1
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d35 1
a35 3
extern GSymT	*VAR_GLOBAL;	/* Variables defined in a global context, e.g
				 * in the Makefile itself */
extern GSymT	*VAR_CMD;	/* Variables defined on the command line */
d42 2
d48 1
a48 1
	GSymT *);
d54 1
a54 1
	const char *, GSymT  *);
d133 2
d136 10
a145 1
extern bool	oldVars;	/* Do old-style variable substitution */
d147 1
a147 2
extern bool	checkEnvFirst;	/* true if environment should be searched for
				 * variables before the global context */
@

