head	1.78;
access;
symbols
	OPENBSD_6_1:1.77.0.4
	OPENBSD_6_1_BASE:1.77
	OPENBSD_6_0:1.76.0.8
	OPENBSD_6_0_BASE:1.76
	OPENBSD_5_9:1.76.0.4
	OPENBSD_5_9_BASE:1.76
	OPENBSD_5_8:1.76.0.6
	OPENBSD_5_8_BASE:1.76
	OPENBSD_5_7:1.76.0.2
	OPENBSD_5_7_BASE:1.76
	OPENBSD_5_6:1.75.0.4
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.74.0.6
	OPENBSD_5_5_BASE:1.74
	OPENBSD_5_4:1.74.0.2
	OPENBSD_5_4_BASE:1.74
	OPENBSD_5_3:1.69.0.2
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.63.0.2
	OPENBSD_5_2_BASE:1.63
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.8
	OPENBSD_5_0:1.62.0.6
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.62.0.4
	OPENBSD_4_9_BASE:1.62
	OPENBSD_4_8:1.62.0.2
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.59.0.2
	OPENBSD_4_7_BASE:1.59
	OPENBSD_4_6:1.58.0.4
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.57.0.2
	OPENBSD_4_5_BASE:1.57
	OPENBSD_4_4:1.56.0.4
	OPENBSD_4_4_BASE:1.56
	OPENBSD_4_3:1.56.0.2
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.40.0.8
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.40.0.6
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.40.0.4
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.39.0.6
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.39.0.4
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	OPENBSD_3_5:1.38.0.4
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.38.0.2
	OPENBSD_3_4_BASE:1.38
	OPENBSD_3_3:1.37.0.2
	OPENBSD_3_3_BASE:1.37
	OPENBSD_3_2:1.35.0.4
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.35.0.2
	OPENBSD_3_1_BASE:1.35
	OPENBSD_3_0:1.34.0.2
	OPENBSD_3_0_BASE:1.34
	OPENBSD_2_9_BASE:1.30
	OPENBSD_2_9:1.30.0.2
	OPENBSD_2_8:1.28.0.2
	OPENBSD_2_8_BASE:1.28
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.78
date	2017.06.22.17.08.20;	author espie;	state Exp;
branches;
next	1.77;
commitid	m7jGakx58gVJKqZP;

1.77
date	2016.10.21.16.12.38;	author espie;	state Exp;
branches;
next	1.76;
commitid	aLVdeKrJ0t5upS3l;

1.76
date	2015.01.23.22.35.58;	author espie;	state Exp;
branches;
next	1.75;
commitid	WtGGWUPWONvkhNGN;

1.75
date	2014.05.12.19.11.19;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2013.05.30.08.58.38;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2013.05.25.11.54.14;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2013.05.22.12.14.08;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2013.05.14.18.47.40;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2013.04.23.14.32.53;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2012.10.09.19.45.34;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2012.10.06.09.32.40;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2012.10.02.10.29.31;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2012.09.01.16.44.25;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2012.08.20.09.51.05;	author jsg;	state Exp;
branches;
next	1.63;

1.63
date	2012.03.22.13.47.12;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2010.04.25.13.59.53;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2009.08.16.09.49.22;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2009.05.12.09.24.16;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2008.11.04.07.22.36;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2008.01.29.22.23.10;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.28.09.39.01;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.24.15.41.01;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2007.11.10.13.59.48;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.10.12.56.50;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2007.11.10.12.51.40;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.06.21.12.23;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.02.17.27.24;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2007.09.18.08.51.23;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.17.14.05.34;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.17.12.42.09;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.16.15.20.48;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.16.14.29.33;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.16.14.09.18;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.16.12.09.36;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2006.01.20.23.10.19;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.07.13.11.36;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2003.06.03.02.56.12;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2003.01.03.17.44.48;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2002.12.29.17.20.17;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.29.12.53.43;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.29.12.17.06;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.23.12.34.50;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.03.13.41.12;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.02.16.57.26;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.24.14.36.35;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2000.09.14.13.52.42;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2000.09.14.13.40.03;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.14.13.32.08;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.23.16.23.26;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.23.16.21.43;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.23.16.20.01;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.23.16.15.50;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.17.14.43.37;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.17.14.40.30;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.17.14.38.20;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.10.01.41.06;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.10.01.32.23;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.17.23.57.46;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.26.16.21.33;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.02.13.47.48;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	99.12.18.21.58.08;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	99.12.18.21.53.33;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.12.18.02.11.27;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.10.05.22.06.24;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	98.12.05.00.06.29;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	98.03.30.06.59.38;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.04.28.01.52.42;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.04.01.07.28.24;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.11.30.21.09.05;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.02.16.04.20;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.43.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.17.13.42.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.78
log
@better display of cycles in -j mode.
lots of tests by krw@@
review and comments by pirofti@@, more tweaks to come
@
text
@/*	$OpenBSD: targ.c,v 1.77 2016/10/21 16:12:38 espie Exp $ */
/*	$NetBSD: targ.c,v 1.11 1997/02/20 16:51:50 christos Exp $	*/

/*
 * Copyright (c) 1999 Marc Espie.
 *
 * Extensive code changes for the OpenBSD project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1988, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*-
 * targ.c --
 *		Target nodes are kept into a hash table.
 *
 * Interface:
 *	Targ_Init		Initialization procedure.
 *
 *	Targ_NewGN		Create a new GNode for the passed target
 *				(string). The node is *not* placed in the
 *				hash table, though all its fields are
 *				initialized.
 *
 *	Targ_FindNode		Find the node for a given target, creating
 *				and storing it if it doesn't exist and the
 *				flags are right (TARG_CREATE)
 *
 *	Targ_FindList		Given a list of names, find nodes for all
 *				of them, creating nodes if needed.
 *
 *	Targ_Ignore		Return true if errors should be ignored when
 *				creating the given target.
 *
 *	Targ_Silent		Return true if we should be silent when
 *				creating the given target.
 *
 *	Targ_Precious		Return true if the target is precious and
 *				should not be removed if we are interrupted.
 *
 * Debugging:
 *	Targ_PrintGraph 	Print out the entire graphm all variables
 *				and statistics for the directory cache. Should
 *				print something for suffixes, too, but...
 */

#include <limits.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ohash.h>
#include "config.h"
#include "defines.h"
#include "stats.h"
#include "suff.h"
#include "var.h"
#include "targ.h"
#include "memory.h"
#include "gnode.h"
#include "extern.h"
#include "timestamp.h"
#include "lst.h"
#include "node_int.h"
#include "nodehashconsts.h"
#include "dump.h"

static struct ohash targets;	/* hash table of targets */
struct ohash_info gnode_info = {
	offsetof(GNode, name), NULL, hash_calloc, hash_free, element_alloc
};

#define Targ_FindConstantNode(n, f) Targ_FindNodeh(n, sizeof(n), K_##n, f)


GNode *begin_node, *end_node, *interrupt_node, *DEFAULT;

void
Targ_Init(void)
{
	/* A small make file already creates 200 targets.  */
	ohash_init(&targets, 10, &gnode_info);
	begin_node = Targ_FindConstantNode(NODE_BEGIN, TARG_CREATE);
	begin_node->type |= OP_DUMMY | OP_NOTMAIN | OP_NODEFAULT;
	end_node = Targ_FindConstantNode(NODE_END, TARG_CREATE);
	end_node->type |= OP_DUMMY | OP_NOTMAIN | OP_NODEFAULT;
	interrupt_node = Targ_FindConstantNode(NODE_INTERRUPT, TARG_CREATE);
	interrupt_node->type |= OP_DUMMY | OP_NOTMAIN | OP_NODEFAULT;
	DEFAULT = Targ_FindConstantNode(NODE_DEFAULT, TARG_CREATE);
	DEFAULT->type |= OP_DUMMY | OP_NOTMAIN| OP_TRANSFORM | OP_NODEFAULT;

}

GNode *
Targ_NewGNi(const char *name, const char *ename)
{
	GNode *gn;

	gn = ohash_create_entry(&gnode_info, name, &ename);
	gn->path = NULL;
	gn->type = 0;
	gn->special = SPECIAL_NONE;
	gn->unmade = 0;
	gn->must_make = false;
	gn->built_status = UNKNOWN;
	gn->in_cycle = false;
	gn->childMade =	false;
	gn->order = 0;
	ts_set_out_of_date(gn->mtime);
	gn->youngest = gn;
	Lst_Init(&gn->cohorts);
	Lst_Init(&gn->parents);
	Lst_Init(&gn->children);
	Lst_Init(&gn->successors);
	Lst_Init(&gn->preds);
	SymTable_Init(&gn->context);
	gn->impliedsrc = NULL;
	Lst_Init(&gn->commands);
	gn->suffix = NULL;
	gn->next = NULL;
	gn->basename = NULL;
	gn->sibling = gn;
	gn->groupling = NULL;

#ifdef STATS_GN_CREATION
	STAT_GN_COUNT++;
#endif

	return gn;
}

GNode *
Targ_FindNodei(const char *name, const char *ename, int flags)
{
	uint32_t hv;

	hv = ohash_interval(name, &ename);
	return Targ_FindNodeih(name, ename, hv, flags);
}

GNode *
Targ_FindNodeih(const char *name, const char *ename, uint32_t hv, int flags)
{
	GNode *gn;
	unsigned int slot;

	slot = ohash_lookup_interval(&targets, name, ename, hv);

	gn = ohash_find(&targets, slot);

	if (gn == NULL && (flags & TARG_CREATE)) {
		gn = Targ_NewGNi(name, ename);
		ohash_insert(&targets, slot, gn);
	}

	return gn;
}

void
Targ_FindList(Lst nodes, Lst names)
{
	LstNode ln;
	GNode *gn;
	char *name;

	for (ln = Lst_First(names); ln != NULL; ln = Lst_Adv(ln)) {
		name = Lst_Datum(ln);
		gn = Targ_FindNode(name, TARG_CREATE);
		/* Note: Lst_AtEnd must come before the Lst_Concat so the nodes
		 * are added to the list in the order in which they were
		 * encountered in the makefile.  */
		Lst_AtEnd(nodes, gn);
		if (gn->type & OP_DOUBLEDEP)
			Lst_Concat(nodes, &gn->cohorts);
	}
}

bool
Targ_Ignore(GNode *gn)
{
	if (ignoreErrors || gn->type & OP_IGNORE)
		return true;
	else
		return false;
}

bool
Targ_Silent(GNode *gn)
{
	if (beSilent || gn->type & OP_SILENT)
		return true;
	else
		return false;
}

bool
Targ_Precious(GNode *gn)
{
	if (allPrecious || (gn->type & (OP_PRECIOUS|OP_DOUBLEDEP|OP_PHONY)))
		return true;
	else
		return false;
}

void
Targ_PrintCmd(void *p)
{
	const struct command *cmd = p;
	printf("\t%s\n", cmd->string);
}

void
Targ_PrintType(int type)
{
	int    tbit;

#define PRINTBIT(attr)	case CONCAT(OP_,attr): printf("." #attr " "); break
#define PRINTDBIT(attr) case CONCAT(OP_,attr): if (DEBUG(TARG)) printf("." #attr " "); break

	type &= ~OP_OPMASK;

	while (type) {
		tbit = 1 << (ffs(type) - 1);
		type &= ~tbit;

		switch (tbit) {
		PRINTBIT(OPTIONAL);
		PRINTBIT(USE);
		PRINTBIT(EXEC);
		PRINTBIT(IGNORE);
		PRINTBIT(PRECIOUS);
		PRINTBIT(SILENT);
		PRINTBIT(MAKE);
		PRINTBIT(JOIN);
		PRINTBIT(INVISIBLE);
		PRINTBIT(NOTMAIN);
		/*XXX: MEMBER is defined, so CONCAT(OP_,MEMBER) gives OP_"%" */
		case OP_MEMBER:
			if (DEBUG(TARG))
				printf(".MEMBER ");
			break;
		PRINTDBIT(ARCHV);
		}
    }
}

const char *
status_to_string(GNode *gn)
{
	switch (gn->built_status) {
	case UNKNOWN:
		return "unknown";
	case MADE:
		return "made";
	case UPTODATE:
		return "up-to-date";
	case ERROR:
		return "error when made";
	case ABORTED:
		return "aborted";
	default:
		return "other status";
	}
}

struct ohash *
targets_hash()
{
	return &targets;
}

GNode *
Targ_FindNodeh(const char *name, size_t n, uint32_t hv, int flags)
{
	return Targ_FindNodeih(name, name + n - 1, hv, flags);
}
@


1.77
log
@small obvious cleanups:
- remove a lot of unnecessary casts
- zap extra param that's no longer needed
- add proper prototype and make function static

okay natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.76 2015/01/23 22:35:58 espie Exp $ */
d158 1
@


1.76
log
@a wee little bit more cleanup (more const and remove noise from CDIAGFLAGS...
-pedantic kind of requires -std=c99 here to avoid LL warnings)
okay miod@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.75 2014/05/12 19:11:19 espie Exp $ */
d218 1
a218 1
		name = (char *)Lst_Datum(ln);
@


1.75
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.74 2013/05/30 08:58:38 espie Exp $ */
d259 1
a259 1
	struct command *cmd = p;
@


1.74
log
@remove cmtime again, but with a proper test for nodes without children.

problem seen by aja,
make pointed by matthieu,
sleuthing by me,
okay by millert

(and you say OpenBSD developers don't work together)
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.73 2013/05/25 11:54:14 espie Exp $ */
d122 1
a122 1
	offsetof(GNode, name), NULL, hash_alloc, hash_free, element_alloc
@


1.73
log
@obviously missed something, so revert.
(noticed by sthen@@/matthieu@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.72 2013/05/22 12:14:08 espie Exp $ */
a160 1
	ts_set_out_of_date(gn->cmtime);
@


1.72
log
@as checked through thorough tests, youngest->mtime == ctime, so ditch
the extra field.

remove some extra abstraction layer: use clock_gettime directly
instead of ts_set_from_now (what is "now" anyways)

time_to_string takes param by pointer

rename "now" into starttime (more accurate term)

randomize queue uses arc4random_uniform (prompted by deraadt@@)

display debug timestamp with ns too (it's debug, so it doesn't really
matter whichever way it's done, as long as it's done)

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.71 2013/05/14 18:47:40 espie Exp $ */
d161 1
@


1.71
log
@keep track of the youngest child, helps a lot with out-of-date messages
in -dm mode.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.70 2013/04/23 14:32:53 espie Exp $ */
a160 1
	ts_set_out_of_date(gn->cmtime);
@


1.70
log
@remove TIMESTAMP abstraction layer, prodded by theo.
while there, clean up includes.
use strtoll for ar timestamps (pretty much unused in reality, more
standard conforming than anything)

use idea from Todd to adapt to time_t being 32 bits OR 64 bits
(pedantically correct: INT_MIN would work just fine up to 1910 or so...)

okay millert@@, gone thru a make build.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.69 2012/10/09 19:45:34 espie Exp $ */
d162 1
@


1.69
log
@- SPECIAL_DEPRECATED -> SPECIAL_NOTHING
- nodes for .POSIX and .SCCS_GET (which don't do anything)
- zap remaining suffix crud.

new scaffolding:
- groupling list and HELDBACK state to avoid races in engine.
- parser recognizes lists of targets that shoul be grouped together
- OP_DOUBLE to mark nodes that have multiple lists of commands
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.68 2012/10/06 09:32:40 espie Exp $ */
d100 1
a101 1
#include <stdint.h>
d104 1
a106 1
#include "ohash.h"
@


1.68
log
@- extra juice for debugging signal passing.  Note when we can't pass the
signal because the process already bought it (pgroups will do that to you)
(lots of discussion with Todd on that one)
- tweak error handling some more to make it less verbose when just one job
is running...
- show signal name in case of signal interrupts.
- zap OP_LIB, move that stuff to the location where we warn when we meet
that bug.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.67 2012/10/02 10:29:31 espie Exp $ */
d174 1
a174 1
	gn->build_lock = false;
@


1.67
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.66 2012/09/21 07:55:20 espie Exp $ */
d153 1
a153 6
	if ((name[0] == '-' && name[1] == 'l') ||
	    (ename - name >=2 && ename[-1] == 'a' && ename[-2] == '.'))
		gn->type = OP_LIB;
	else
		gn->type = 0;

a287 1
		PRINTDBIT(LIB);
@


1.66
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.65 2012/09/01 16:44:25 espie Exp $ */
a70 2
 *	Targ_End		Cleanup the module
 *
d102 1
d118 1
a118 3
#ifdef CLEANUP
#include <stdlib.h>
#endif
a124 7
static void TargPrintOnlySrc(GNode *);
static void TargPrintName(void *);
static void TargPrintNode(GNode *, int);
#ifdef CLEANUP
static LIST allTargets;
static void TargFreeGN(void *);
#endif
a134 3
#ifdef CLEANUP
	Lst_Init(&allTargets);
#endif
a145 9
#ifdef CLEANUP
void
Targ_End(void)
{
	Lst_Every(&allTargets, TargFreeGN);
	ohash_delete(&targets);
}
#endif

d153 2
a154 1
	if (name[0] == '-' && name[1] == 'l')
a172 2
	gn->origin.lineno = 0;
	gn->origin.fname = NULL;
a184 3
#ifdef CLEANUP
	Lst_AtEnd(&allTargets, gn);
#endif
a187 18
#ifdef CLEANUP
static void
TargFreeGN(void *gnp)
{
	GNode *gn = (GNode *)gnp;

	efree(gn->path);
	Lst_Destroy(&gn->cohorts, NOFREE);
	Lst_Destroy(&gn->parents, NOFREE);
	Lst_Destroy(&gn->children, NOFREE);
	Lst_Destroy(&gn->successors, NOFREE);
	Lst_Destroy(&gn->preds, NOFREE);
	Lst_Destroy(&gn->commands, NOFREE);
	SymTable_Destroy(&gn->context);
	free(gn);
}
#endif

a260 8
static void
TargPrintName(void *gnp)
{
	GNode *gn = (GNode *)gnp;
	printf("%s ", gn->name);
}


d303 1
a320 85
}

static void
TargPrintNode(GNode *gn, int pass)
{
	if (OP_NOP(gn->type))
		return;
	printf("#\n");
	if (pass == 2) {
		printf("# %d unmade children\n", gn->unmade);
		if (! (gn->type & (OP_JOIN|OP_USE|OP_EXEC))) {
			if (!is_out_of_date(gn->mtime)) {
				printf("# last modified %s: %s\n",
				      time_to_string(gn->mtime),
				      status_to_string(gn));
			} else if (gn->built_status != UNKNOWN) {
				printf("# non-existent (maybe): %s\n",
				    status_to_string(gn));
			} else {
				printf("# unmade\n");
			}
		}
	}
	if (!Lst_IsEmpty(&gn->parents)) {
		printf("# parents: ");
		Lst_Every(&gn->parents, TargPrintName);
		fputc('\n', stdout);
	}
	if (gn->impliedsrc)
		printf("# implied source: %s\n", gn->impliedsrc->name);

	printf("%-16s", gn->name);
	switch (gn->type & OP_OPMASK) {
	case OP_DEPENDS:
		printf(": "); break;
	case OP_FORCE:
		printf("! "); break;
	case OP_DOUBLEDEP:
		printf(":: "); break;
	}
	Targ_PrintType(gn->type);
	Lst_Every(&gn->children, TargPrintName);
	fputc('\n', stdout);
	Lst_Every(&gn->commands, Targ_PrintCmd);
	printf("\n\n");
	if (gn->type & OP_DOUBLEDEP) {
		LstNode ln;

		for (ln = Lst_First(&gn->cohorts); ln != NULL; ln = Lst_Adv(ln))
			TargPrintNode((GNode *)Lst_Datum(ln), pass);
	}
}

static void
TargPrintOnlySrc(GNode *gn)
{
	if (OP_NOP(gn->type) && gn->special == SPECIAL_NONE &&
	    !(gn->type & OP_DUMMY))
		printf("#\t%s [%s]\n", gn->name,
		    gn->path != NULL ? gn->path : gn->name);
}

void
Targ_PrintGraph(int pass)	/* Which pass this is. 1 => no processing
				 * 2 => processing done */
{
	GNode		*gn;
	unsigned int	i;

	printf("#*** Input graph:\n");
	for (gn = ohash_first(&targets, &i); gn != NULL;
	    gn = ohash_next(&targets, &i))
		TargPrintNode(gn, pass);
	printf("\n\n");
	printf("#\n#   Files that are only sources:\n");
	for (gn = ohash_first(&targets, &i); gn != NULL;
	    gn = ohash_next(&targets, &i))
		TargPrintOnlySrc(gn);
	Var_Dump();
	printf("\n");
#ifdef DEBUG_DIRECTORY_CACHE
	Dir_PrintDirectories();
	printf("\n");
#endif
	Suff_PrintAll();
@


1.65
log
@put back out-of-line version of function.
even with only-inline, won't compile with -O0, so debugging is very
difficult...

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.63 2012/03/22 13:47:12 espie Exp $ */
a197 1
	Lst_Init(&gn->expanded);
d314 1
a314 1
Targ_PrintCmd(void *cmd)
d316 2
a317 1
	printf("\t%s\n", (char *)cmd);
@


1.64
log
@make use of __only_inline to ask for gnu inline semantics
ok espie@@
@
text
@d464 6
@


1.63
log
@minor cleanup: error messages include lineno and fileno together, so
recognize that and create a struct Location_ for it.

mostly from Jonathan Calmels, a few nits from me.

okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.62 2010/07/19 19:46:44 espie Exp $ */
a462 6
}

GNode *
Targ_FindNodeh(const char *name, size_t n, uint32_t hv, int flags)
{
	return Targ_FindNodeih(name, name + n - 1, hv, flags);
@


1.62
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.61 2010/07/19 19:30:37 espie Exp $ */
d194 2
a195 2
	gn->lineno = 0;
	gn->fname = NULL;
@


1.61
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD: targ.c,v 1.60 2010/04/25 13:59:53 espie Exp $ */
@


1.60
log
@pure whitespace cleanup
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d464 6
@


1.59
log
@write sensible error message
@
text
@d429 1
a429 1
	if (OP_NOP(gn->type) && gn->special == SPECIAL_NONE && 
@


1.58
log
@fix obvious bug: .PHONY targets don't match files, so they're precious (we
don't even want to check for a matching file on the file system)
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.57 2008/11/04 07:22:36 espie Exp $ */
@


1.57
log
@changes to get target equivalence to work better.
- add new file to create lists of equivalent targets (siblings)
- use that for sequential mode to have much better VPATH support
- separate checking commands from reporting error, for later.
- zap DieHorribly accordingly
- renumber existing flags
- signal_running_jobs() is simpler than pass_signal_to_jobs()
- new debug option -dn for name matching.

Similar code to handle parallel make is still missing.

thanks to Mark, Miod, Theo, Otto, Todd for tests and/or comments.
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d301 1
a301 1
	if (allPrecious || (gn->type & (OP_PRECIOUS|OP_DOUBLEDEP)))
@


1.56
log
@A few changes:
- expand commands earlier, so that we can eventually scan them to take
smarter decisions.
- clean up the select() mask code and rename variables to sensible things.
- quite a few minor renames for readability
- erecalloc
- clean up wait status handling, do not try to rebuild wait status, but
instead parse it early and deal with the parsed code.

tested by lots of people, thanks guys!
@
text
@d124 1
a124 1
static struct ohash targets;	/* a hash table of same */
d201 4
d460 2
a461 21
static char *curdir, *objdir;
static size_t curdir_len, objdir_len;

void
Targ_setdirs(const char *c, const char *o)
{
	curdir_len = strlen(c);
	curdir = emalloc(curdir_len+2);
	memcpy(curdir, c, curdir_len);
	curdir[curdir_len++] = '/';
	curdir[curdir_len] = 0;

	objdir_len = strlen(o);
	objdir = emalloc(objdir_len+2);
	memcpy(objdir, o, objdir_len);
	objdir[objdir_len++] = '/';
	objdir[objdir_len] = 0;
}

void
look_harder_for_target(GNode *gn)
d463 1
a463 22
	GNode *extra, *cgn;
	LstNode ln;

	if (gn->type & (OP_RESOLVED|OP_PHONY))
		return;
	gn->type |= OP_RESOLVED;
	if (strncmp(gn->name, objdir, objdir_len) == 0) {
		extra = Targ_FindNode(gn->name + objdir_len, TARG_NOCREATE);
		if (extra != NULL) {
			if (Lst_IsEmpty(&gn->commands))
				Lst_Concat(&gn->commands, &extra->commands);
			for (ln = Lst_First(&extra->children); ln != NULL;
			    ln = Lst_Adv(ln)) {
				cgn = (GNode *)Lst_Datum(ln);

				if (Lst_AddNew(&gn->children, cgn)) {
					Lst_AtEnd(&cgn->parents, gn);
					gn->unmade++;
				}
			}
		}
	}
@


1.55
log
@PHONY targets never correspond to real files.
@
text
@d199 2
a200 1
	gn->suffix =	NULL;
@


1.54
log
@more parallel make fixes.

Preparations to fix the engine:
- new function has_been_built(gn), that tells you what's the status of
a given node. Allows us to run Suff_FindDeps later, by updating the number
of unmade children correctly.
- take out the code that handles shell expansions in an expand_children*
set of functions, called by Suff_FindDeps, among others. These must be
called early in the engine to avoid creating bogus nodes.

Engine fixes:
- take the predecessor/successor special handling out, deal with it in
separate functions.
- don't count nodes. Explicitly track them all in a hash table (better
way to deal with non-built issues).
- don't run Suff_FindDeps at start, but just before building an actual node.
This allows make to find all dependencies correctly, as in groff.

Pfiou! now it works.
@
text
@d480 1
a480 1
	if (gn->type & OP_RESOLVED)
@


1.53
log
@UNMADE -> UNKNOWN
@
text
@a136 1
static const char *status_to_string(GNode *);
d351 1
a351 1
static const char *
@


1.52
log
@clearer debug code
@
text
@d185 1
a185 1
	gn->built_status = UNMADE;
d356 2
a357 2
	case UNMADE:
		return "unmade";
d384 1
a384 1
			} else if (gn->built_status != UNMADE) {
@


1.51
log
@rename make -> must_make, made -> built_status
to make them easier to find in source files.
@
text
@d137 1
d352 18
d383 1
a383 5
				      (gn->built_status == UNMADE ? "unmade" :
				       (gn->built_status == MADE ? "made" :
					(gn->built_status == UPTODATE ? 
					    "up-to-date" :
					     "error when made"))));
d386 1
a386 6
				      (gn->built_status == MADE ? "made" :
				       (gn->built_status == UPTODATE ? 
					    "up-to-date" :
					(gn->built_status == ERROR ? 
					    "error when made" :
					    "aborted"))));
@


1.50
log
@simplify the way we deal with implicit rules and handle $<.

Having an `iParents' field is actually backwards, it's ways simpler to
store the pointer in the child, as an impliedsrc, and to set the variable
just in time along with all the rest in DoAllVar.

This is simpler, and it should allow us to call SuffFindDeps much later.
@
text
@d183 2
a184 2
	gn->make = false;
	gn->made = UNMADE;
d364 4
a367 3
				      (gn->made == UNMADE ? "unmade" :
				       (gn->made == MADE ? "made" :
					(gn->made == UPTODATE ? "up-to-date" :
d369 1
a369 1
			} else if (gn->made != UNMADE) {
d371 6
a376 4
				      (gn->made == MADE ? "made" :
				       (gn->made == UPTODATE ? "up-to-date" :
					(gn->made == ERROR ? "error when made" :
					 "aborted"))));
@


1.49
log
@Work done at p2k7.


This is a really big step towards getting parallel make to work.


Note that this is not yet complete. There are still a few `details' to
fix before this works 100%.  Specifically: sequential make (compat) and
parallel make don't use the same engine, and the parallel engine still
has a few limitations. For instance, some known issues:
- parallel make does not deal with .phony targets correctly all the time.
- some errors are deadly in parallel make mode.
- parallel make NEEDS way more sturdy correspondance of file system paths
and target names, since it often needs to match dependencies to targets
before the corresponding files exist.
- some local variables like $* get set in a bogus way in some cases.
- suffix handling has issues, especially related to the NULL suffix.
So, if you find stuff that does NOT yet work with parallel make, don't go
blindly try to fix the Makefile. It's very likely you might have stumbled
into a make bug. (unless you really, really, understand Makefiles, DON'T
GO CHANGING THEM YET).



Tested by lots of people, thanks go to miod@@, and robert@@ among other people.

Quick summary of what this does:

- remove `saving commands' extension (it's not really usable, nor used)
- move compat job runner and parallel interrupt handling into engine.c
- tweak the code so that both compat and parallel mode use the same job runner
and the same interrupt handling. Remove the other one.
- optimize job runner so that, in parallel mode, the last command does not
fork if we can avoid it (as it's already running in a sub shell).
- scrape all the code that dealt with creating shell scripts from commands.
- scrape all the code that dealt with recognizing special sequences in
command output to print/not print output.
- fix the parallel job pipe to not keep around file descriptors that are not
needed.
- replace the parallel job buffering with a nicer one, that deals with
non-blocking descriptors to try to agregate as much output from one job in
one go (greed) to unconfuse the users.
- create two pipes per job, so that stdout and stderr stay separate.
- make job token printing a debug option.
- always use the parallel job-runner to `execute' commands, even if we just
print them out.
- store list of errors encountered during parallel make running, and print them
on exit, so that we know what went wrong.
- add a dirty hack to targ.c to deal with paths produced by gccmakedep.
@
text
@a188 1
	Lst_Init(&gn->iParents);
d197 1
a217 1
	Lst_Destroy(&gn->iParents, NOFREE);
a377 5
		if (!Lst_IsEmpty(&gn->iParents)) {
			printf("# implicit parents: ");
			Lst_Every(&gn->iParents, TargPrintName);
			fputc('\n', stdout);
		}
d384 2
@


1.48
log
@internal macro should be invisible from outside
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.47 2007/09/17 14:05:34 espie Exp $ */
d445 46
@


1.47
log
@avoid printing out special targets in debug mode
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.46 2007/09/17 12:42:09 espie Exp $ */
d136 2
@


1.46
log
@rewrite of the basic suffix/target parsing: use hash for suffixes.

Store special targets in target hash, and use them for the parsing.

Use OP_DUMMY flag to mark targets that don't really exist yet, such
as interrupt and default nodes.

Also, .PATHxxx is special in suffixes.

Small tweaks to compat.c, so that run_commands does more stuff after
the fork() (and thus no need to free things).

Remove distinction between local and global jobs.
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.45 2007/09/17 09:28:36 espie Exp $ */
d414 2
a415 1
	if (OP_NOP(gn->type))
@


1.45
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.44 2007/09/16 15:20:48 espie Exp $ */
d118 2
d125 2
a126 3
static struct ohash_info gnode_info = {
	offsetof(GNode, name),
	NULL, hash_alloc, hash_free, element_alloc
d137 2
a138 9
/*-
 *-----------------------------------------------------------------------
 * Targ_Init --
 *	Initialize this module
 *
 * Side Effects:
 *	The targets hash table is initialized
 *-----------------------------------------------------------------------
 */
d147 9
a157 9
/*-
 *-----------------------------------------------------------------------
 * Targ_End --
 *	Finalize this module
 *
 * Side Effects:
 *	All lists and gnodes are cleared
 *-----------------------------------------------------------------------
 */
a166 13
/*-
 *-----------------------------------------------------------------------
 * Targ_NewGNi  --
 *	Create and initialize a new graph node
 *
 * Results:
 *	An initialized graph node with the name field filled with a copy
 *	of the passed name
 *
 * Side effect:
 *	add targets to list of all targets if CLEANUP
 *-----------------------------------------------------------------------
 */
d168 1
a168 2
Targ_NewGNi(const char *name, /* the name to stick in the new node */
    const char *ename)
d174 1
a174 1
	if (name[0] == '-' && name[1] == 'l') {
d176 1
a176 1
	} else {
d178 5
a182 4
	}
	gn->unmade =	0;
	gn->make =		false;
	gn->made =		UNMADE;
d184 1
a184 1
	gn->order = 	0;
a209 6
/*-
 *-----------------------------------------------------------------------
 * TargFreeGN  --
 *	Destroy a GNode
 *-----------------------------------------------------------------------
 */
d228 8
a236 14
/*-
 *-----------------------------------------------------------------------
 * Targ_FindNodei  --
 *	Find a node in the list using the given name for matching
 *
 * Results:
 *	The node in the list if it was. If it wasn't, return NULL if
 *	flags was TARG_NOCREATE or the newly created and initialized node
 *	if flags was TARG_CREATE
 *
 * Side Effects:
 *	Sometimes a node is created and added to the list
 *-----------------------------------------------------------------------
 */
d238 1
a238 3
Targ_FindNodei(const char *name, const char *ename,
    int flags)			/* flags governing events when target not
				 * found */
d240 1
a240 1
	GNode *gn;		/* node in that element */
d243 1
a243 1
	slot = ohash_qlookupi(&targets, name, &ename);
a254 13
/*-
 *-----------------------------------------------------------------------
 * Targ_FindList --
 *	Make a complete list of GNodes from the given list of names
 *
 * Side Effects:
 *	Nodes will be created for all names in names which do not yet have graph
 *	nodes.
 *
 *	A complete list of graph nodes corresponding to all instances of all
 *	the names in names is added to nodes.
 * -----------------------------------------------------------------------
 */
d256 1
a256 2
Targ_FindList(Lst nodes, 	/* result list */
    Lst names) 			/* list of names to find */
d258 2
a259 2
	LstNode ln;		/* name list element */
	GNode *gn;		/* node in tLn */
a300 19
/******************* DEBUG INFO PRINTING ****************/

static GNode *mainTarg;	/* the main target, as set by Targ_SetMain */
/*-
 *-----------------------------------------------------------------------
 * Targ_SetMain --
 *	Set our idea of the main target we'll be creating. Used for
 *	debugging output.
 *
 * Side Effects:
 *	"mainTarg" is set to the main target's node.
 *-----------------------------------------------------------------------
 */
void
Targ_SetMain(GNode *gn)
{
	mainTarg = gn;
}

a314 7
/*-
 *-----------------------------------------------------------------------
 * Targ_PrintType --
 *	Print out a type field giving only those attributes the user can
 *	set.
 *-----------------------------------------------------------------------
 */
d320 2
a321 7
#define PRINTBIT(attr)	case CONCAT(OP_,attr): \
				printf("." #attr " "); \
				break
#define PRINTDBIT(attr) case CONCAT(OP_,attr): \
				if (DEBUG(TARG)) \
					printf("." #attr " "); \
				break
d348 1
a348 1
	}
a356 3
	if (gn == mainTarg) {
		printf("# *** MAIN TARGET ***\n");
	}
d358 1
a358 5
		if (gn->unmade) {
			printf("# %d unmade children\n", gn->unmade);
		} else {
			printf("# No unmade children\n");
		}
d362 5
a366 5
				    time_to_string(gn->mtime),
				    (gn->made == UNMADE ? "unmade" :
				    (gn->made == MADE ? "made" :
				    (gn->made == UPTODATE ? "up-to-date" :
				    "error when made"))));
d369 4
a372 4
				    (gn->made == MADE ? "made" :
				    (gn->made == UPTODATE ? "up-to-date" :
				    (gn->made == ERROR ? "error when made" :
				     "aborted"))));
d434 1
a434 1
		    TargPrintOnlySrc(gn);
d437 4
@


1.44
log
@remove some totally useless comments
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.43 2007/09/16 14:29:33 espie Exp $ */
d269 1
a269 1
Targ_FindNodei(const char *name, const char *ename, 
d420 3
a422 3
		case OP_MEMBER: 
			if (DEBUG(TARG)) 
				printf(".MEMBER "); 
@


1.43
log
@remove old debug code nothing uses
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.42 2007/09/16 14:09:18 espie Exp $ */
a320 6
/*-
 *-----------------------------------------------------------------------
 * Targ_Ignore	--
 *	Return true if should ignore errors when creating gn
 *-----------------------------------------------------------------------
 */
a329 6
/*-
 *-----------------------------------------------------------------------
 * Targ_Silent	--
 *	Return true if be silent when creating gn
 *-----------------------------------------------------------------------
 */
a338 6
/*-
 *-----------------------------------------------------------------------
 * Targ_Precious --
 *	See if the given target is precious
 *-----------------------------------------------------------------------
 */
a428 6
/*-
 *-----------------------------------------------------------------------
 * TargPrintNode --
 *	print the contents of a node
 *-----------------------------------------------------------------------
 */
a495 6
/*-
 *-----------------------------------------------------------------------
 * TargPrintOnlySrc --
 *	Print targets that are just a source.
 *-----------------------------------------------------------------------
 */
a503 6
/*-
 *-----------------------------------------------------------------------
 * Targ_PrintGraph --
 *	print the entire graph.
 *-----------------------------------------------------------------------
 */
@


1.42
log
@reindent targ.c
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.41 2007/09/16 12:09:36 espie Exp $ */
a557 4
#ifdef DEBUG_DIRECTORY_CACHE
	Dir_PrintDirectories();
	printf("\n");
#endif
@


1.41
log
@rename Targ_FmtTime into time_to_string and move it, as it's not related
to target nodes at all (reduces modules inter-dependencies)
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.40 2006/01/20 23:10:19 espie Exp $ */
d125 2
a126 1
    NULL, hash_alloc, hash_free, element_alloc };
d148 2
a149 2
    /* A small make file already creates 200 targets.  */
    ohash_init(&targets, 10, &gnode_info);
d151 1
a151 1
    Lst_Init(&allTargets);
d168 2
a169 2
    Lst_Every(&allTargets, TargFreeGN);
    ohash_delete(&targets);
d190 1
a190 1
    GNode *gn;
d192 25
a216 25
    gn = ohash_create_entry(&gnode_info, name, &ename);
    gn->path = NULL;
    if (name[0] == '-' && name[1] == 'l') {
	gn->type = OP_LIB;
    } else {
	gn->type = 0;
    }
    gn->unmade =	0;
    gn->make =		false;
    gn->made =		UNMADE;
    gn->childMade =	false;
    gn->order = 	0;
    ts_set_out_of_date(gn->mtime);
    ts_set_out_of_date(gn->cmtime);
    Lst_Init(&gn->iParents);
    Lst_Init(&gn->cohorts);
    Lst_Init(&gn->parents);
    Lst_Init(&gn->children);
    Lst_Init(&gn->successors);
    Lst_Init(&gn->preds);
    SymTable_Init(&gn->context);
    gn->lineno = 0;
    gn->fname = NULL;
    Lst_Init(&gn->commands);
    gn->suffix =	NULL;
d219 1
a219 1
    STAT_GN_COUNT++;
d223 1
a223 1
    Lst_AtEnd(&allTargets, gn);
d225 1
a225 1
    return gn;
d238 1
a238 1
    GNode *gn = (GNode *)gnp;
d240 10
a249 10
    efree(gn->path);
    Lst_Destroy(&gn->iParents, NOFREE);
    Lst_Destroy(&gn->cohorts, NOFREE);
    Lst_Destroy(&gn->parents, NOFREE);
    Lst_Destroy(&gn->children, NOFREE);
    Lst_Destroy(&gn->successors, NOFREE);
    Lst_Destroy(&gn->preds, NOFREE);
    Lst_Destroy(&gn->commands, NOFREE);
    SymTable_Destroy(&gn->context);
    free(gn);
d273 2
a274 2
    GNode		*gn;	/* node in that element */
    unsigned int	slot;
d276 1
a276 1
    slot = ohash_qlookupi(&targets, name, &ename);
d278 1
a278 1
    gn = ohash_find(&targets, slot);
d280 4
a283 4
    if (gn == NULL && (flags & TARG_CREATE)) {
	gn = Targ_NewGNi(name, ename);
	ohash_insert(&targets, slot, gn);
    }
d285 1
a285 1
    return gn;
d305 14
a318 14
    LstNode	   ln;		/* name list element */
    GNode	  *gn;		/* node in tLn */
    char	  *name;

    for (ln = Lst_First(names); ln != NULL; ln = Lst_Adv(ln)) {
	name = (char *)Lst_Datum(ln);
	gn = Targ_FindNode(name, TARG_CREATE);
	    /* Note: Lst_AtEnd must come before the Lst_Concat so the nodes
	     * are added to the list in the order in which they were
	     * encountered in the makefile.  */
	Lst_AtEnd(nodes, gn);
	if (gn->type & OP_DOUBLEDEP)
	    Lst_Concat(nodes, &gn->cohorts);
    }
d330 4
a333 4
    if (ignoreErrors || gn->type & OP_IGNORE)
	return true;
    else
	return false;
d345 4
a348 4
    if (beSilent || gn->type & OP_SILENT)
	return true;
    else
	return false;
d360 4
a363 4
    if (allPrecious || (gn->type & (OP_PRECIOUS|OP_DOUBLEDEP)))
	return true;
    else
	return false;
d368 1
a368 1
static GNode	  *mainTarg;	/* the main target, as set by Targ_SetMain */
d382 1
a382 1
    mainTarg = gn;
d388 2
a389 2
    GNode *gn = (GNode *)gnp;
    printf("%s ", gn->name);
d396 1
a396 1
    printf("\t%s\n", (char *)cmd);
d409 1
a409 1
    int    tbit;
d411 33
a443 24
#define PRINTBIT(attr)	case CONCAT(OP_,attr): printf("." #attr " "); break
#define PRINTDBIT(attr) case CONCAT(OP_,attr): if (DEBUG(TARG)) printf("." #attr " "); break

    type &= ~OP_OPMASK;

    while (type) {
	tbit = 1 << (ffs(type) - 1);
	type &= ~tbit;

	switch (tbit) {
	    PRINTBIT(OPTIONAL);
	    PRINTBIT(USE);
	    PRINTBIT(EXEC);
	    PRINTBIT(IGNORE);
	    PRINTBIT(PRECIOUS);
	    PRINTBIT(SILENT);
	    PRINTBIT(MAKE);
	    PRINTBIT(JOIN);
	    PRINTBIT(INVISIBLE);
	    PRINTBIT(NOTMAIN);
	    PRINTDBIT(LIB);
	    /*XXX: MEMBER is defined, so CONCAT(OP_,MEMBER) gives OP_"%" */
	    case OP_MEMBER: if (DEBUG(TARG)) printf(".MEMBER "); break;
	    PRINTDBIT(ARCHV);
a444 1
    }
d456 2
a457 1
    if (!OP_NOP(gn->type)) {
d460 1
a460 1
	    printf("# *** MAIN TARGET ***\n");
d463 2
a464 19
	    if (gn->unmade) {
		printf("# %d unmade children\n", gn->unmade);
	    } else {
		printf("# No unmade children\n");
	    }
	    if (! (gn->type & (OP_JOIN|OP_USE|OP_EXEC))) {
		if (!is_out_of_date(gn->mtime)) {
		    printf("# last modified %s: %s\n",
			      time_to_string(gn->mtime),
			      (gn->made == UNMADE ? "unmade" :
			       (gn->made == MADE ? "made" :
				(gn->made == UPTODATE ? "up-to-date" :
				 "error when made"))));
		} else if (gn->made != UNMADE) {
		    printf("# non-existent (maybe): %s\n",
			      (gn->made == MADE ? "made" :
			       (gn->made == UPTODATE ? "up-to-date" :
				(gn->made == ERROR ? "error when made" :
				 "aborted"))));
d466 24
a489 1
		    printf("# unmade\n");
a490 6
	    }
	    if (!Lst_IsEmpty(&gn->iParents)) {
		printf("# implicit parents: ");
		Lst_Every(&gn->iParents, TargPrintName);
		fputc('\n', stdout);
	    }
d493 3
a495 3
	    printf("# parents: ");
	    Lst_Every(&gn->parents, TargPrintName);
	    fputc('\n', stdout);
d500 1
a500 1
	    case OP_DEPENDS:
d502 1
a502 1
	    case OP_FORCE:
d504 1
a504 1
	    case OP_DOUBLEDEP:
d513 1
a513 1
	    LstNode ln;
d515 2
a516 2
	    for (ln = Lst_First(&gn->cohorts); ln != NULL; ln = Lst_Adv(ln))
		    TargPrintNode((GNode *)Lst_Datum(ln), pass);
a517 1
    }
d529 3
a531 3
    if (OP_NOP(gn->type))
	printf("#\t%s [%s]\n", gn->name,
	    gn->path != NULL ? gn->path : gn->name);
d544 2
a545 2
    GNode		*gn;
    unsigned int	i;
d547 11
a557 11
    printf("#*** Input graph:\n");
    for (gn = ohash_first(&targets, &i); gn != NULL;
	gn = ohash_next(&targets, &i))
	    TargPrintNode(gn, pass);
    printf("\n\n");
    printf("#\n#   Files that are only sources:\n");
    for (gn = ohash_first(&targets, &i); gn != NULL;
	gn = ohash_next(&targets, &i))
		TargPrintOnlySrc(gn);
    Var_Dump();
    printf("\n");
d559 2
a560 2
    Dir_PrintDirectories();
    printf("\n");
d562 1
a562 1
    Suff_PrintAll();
@


1.40
log
@use stdint.h where appropriate. okay millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.39 2004/04/07 13:11:36 espie Exp $ */
a399 28
 * Targ_FmtTime --
 *	Format a modification time in some reasonable way and return it.
 *
 * Results:
 *	The time reformatted.
 *
 * Side Effects:
 *	The time is placed in a static area, so it is overwritten
 *	with each call.
 *-----------------------------------------------------------------------
 */
char *
Targ_FmtTime(TIMESTAMP time)
{
    struct tm		*parts;
    static char 	buf[128];
    time_t t;

    t = timestamp2time_t(time);

    parts = localtime(&t);
    strftime(buf, sizeof buf, "%H:%M:%S %b %d, %Y", parts);
    buf[sizeof(buf) - 1] = '\0';
    return buf;
}

/*-
 *-----------------------------------------------------------------------
d461 1
a461 1
			      Targ_FmtTime(gn->mtime),
@


1.39
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.38 2003/06/03 02:56:12 millert Exp $ */
a100 1
#include <sys/types.h>
d104 1
@


1.38
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.37 2003/01/03 17:44:48 espie Exp $ */
d145 1
a145 1
Targ_Init()
d165 1
a165 1
Targ_End()
d186 2
a187 3
Targ_NewGNi(name, end)
    const char	*name;	/* the name to stick in the new node */
    const char	*end;
d191 1
a191 1
    gn = ohash_create_entry(&gnode_info, name, &end);
d235 1
a235 2
TargFreeGN(gnp)
    void *gnp;
d268 2
a269 4
Targ_FindNodei(name, end, flags)
    const char		*name;	/* the name to find */
    const char		*end;
    int 		flags;	/* flags governing events when target not
d275 1
a275 1
    slot = ohash_qlookupi(&targets, name, &end);
d280 1
a280 1
	gn = Targ_NewGNi(name, end);
d301 2
a302 3
Targ_FindList(nodes, names)
    Lst 	   nodes;	/* result list */
    Lst 	   names;	/* list of names to find */
d327 1
a327 2
Targ_Ignore(gn)
    GNode	   *gn; 	/* node to check for */
d342 1
a342 2
Targ_Silent(gn)
    GNode	   *gn; 	/* node to check for */
d357 1
a357 2
Targ_Precious(gn)
    GNode	   *gn; 	/* the node to check */
d379 1
a379 2
Targ_SetMain(gn)
    GNode   *gn;	/* The main target we'll create */
d385 1
a385 2
TargPrintName(gnp)
    void *gnp;
d393 1
a393 2
Targ_PrintCmd(cmd)
    void *cmd;
d412 1
a412 2
Targ_FmtTime(time)
    TIMESTAMP	 time;
d434 1
a434 2
Targ_PrintType(type)
    int    type;
d473 1
a473 3
TargPrintNode(gn, pass)
    GNode	  *gn;
    int 	  pass;
d546 1
a546 2
TargPrintOnlySrc(gn)
    GNode *gn;
d560 1
a560 2
Targ_PrintGraph(pass)
    int 		pass;	/* Which pass this is. 1 => no processing
@


1.37
log
@revert: reintroduce allTargets list #if CLEANUP, as all nodes are not added
to the hash.
ok miod@@
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.36 2002/12/29 17:20:17 espie Exp $ */
d48 1
a48 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.36
log
@Synch comment with code
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.35 2002/02/19 19:39:38 millert Exp $ */
d122 3
d135 1
d153 3
d171 1
a171 6
    unsigned int i;
    GNode *n;

     for (n = ohash_first(&targets, &i); n != NULL; n = ohash_next(&targets, &i))
     	TargFreeGN(n);

d185 2
d226 3
@


1.35
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.34 2001/05/29 12:53:43 espie Exp $ */
a182 2
 * Side Effects:
 *	The gnode is added to the list of all gnodes.
@


1.34
log
@Take includes out of lst.h, re-add what's needed to separate files.
Removes remaining lint stuff from lst.lib.
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.33 2001/05/29 12:17:06 espie Exp $ */
a449 1
#ifdef __STDC__
a451 4
#else
#define PRINTBIT(attr)	case CONCAT(OP_,attr): printf(".attr "); break
#define PRINTDBIT(attr) case CONCAT(OP_,attr): if (DEBUG(TARG)) printf(".attr "); break
#endif /* __STDC__ */
@


1.33
log
@Blech! gcc is a stupid program. Compiling with -fno-builtin shows lots
of missing function declarations.
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.32 2001/05/23 12:34:50 espie Exp $ */
d106 1
@


1.32
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: targ.c,v 1.10 1999/10/05 22:06:24 espie Exp $ */
d108 1
@


1.31
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d90 1
a90 1
 *	Targ_Ignore		Return TRUE if errors should be ignored when
d93 1
a93 1
 *	Targ_Silent		Return TRUE if we should be silent when
d96 1
a96 1
 *	Targ_Precious		Return TRUE if the target is precious and
d105 15
a119 17
#include	  <stddef.h>
#include	  <stdio.h>
#include	  <time.h>
#include	  "make.h"
#include	  "ohash.h"
#include	  "dir.h"
#include	  "stats.h"

#ifndef lint
#if 0
static char sccsid[] = "@@(#)targ.c	8.2 (Berkeley) 3/19/94";
#else
UNUSED
static char *rcsid = "$OpenBSD: targ.c,v 1.10 1999/10/05 22:06:24 espie Exp $";
#endif
#endif /* not lint */

d158 1
a161 1
#ifdef CLEANUP
d169 1
a170 1
}
d174 1
a174 1
 * Targ_NewGN  --
d186 1
a186 1
Targ_NewGN(name, end)
d200 1
a200 1
    gn->make =		FALSE;
d202 1
a202 1
    gn->childMade =	FALSE;
d204 2
a205 2
    set_out_of_date(gn->mtime);
    set_out_of_date(gn->cmtime);
d254 1
a254 1
 * Targ_FindNode  --
d267 1
a267 1
Targ_FindNode(name, end, flags)
d281 1
a281 1
	gn = Targ_NewGN(name, end);
d312 1
a312 1
	gn = Targ_FindNode(name, NULL, TARG_CREATE);
d328 1
a328 1
Boolean
d333 1
a333 1
	return TRUE;
d335 1
a335 1
	return FALSE;
d344 1
a344 1
Boolean
d349 1
a349 1
	return TRUE;
d351 1
a351 1
	return FALSE;
d360 1
a360 1
Boolean
d365 1
a365 1
	return TRUE;
d367 1
a367 1
	return FALSE;
d596 1
d599 1
@


1.30
log
@Use the ohash_* that's now in libc.
@
text
@d1 2
a2 1
/*	$OpenBSD: targ.c,v 1.29 2000/11/24 14:36:35 espie Exp $	*/
d6 26
d74 1
a74 1
 *	Targ_Init 	    	Initialization procedure.
d76 1
a76 1
 *	Targ_End 	    	Cleanup the module
d78 4
a81 4
 *	Targ_NewGN	    	Create a new GNode for the passed target
 *	    	  	    	(string). The node is *not* placed in the
 *	    	  	    	hash table, though all its fields are
 *	    	  	    	initialized.
d83 3
a85 3
 *	Targ_FindNode	    	Find the node for a given target, creating
 *	    	  	    	and storing it if it doesn't exist and the
 *	    	  	    	flags are right (TARG_CREATE)
d87 2
a88 2
 *	Targ_FindList	    	Given a list of names, find nodes for all
 *	    	  	    	of them, creating nodes if needed.
d90 2
a91 2
 *	Targ_Ignore	    	Return TRUE if errors should be ignored when
 *	    	  	    	creating the given target.
d93 2
a94 2
 *	Targ_Silent	    	Return TRUE if we should be silent when
 *	    	  	    	creating the given target.
d96 2
a97 2
 *	Targ_Precious	    	Return TRUE if the target is precious and
 *	    	  	    	should not be removed if we are interrupted.
d100 3
a102 3
 *	Targ_PrintGraph	    	Print out the entire graphm all variables
 *	    	  	    	and statistics for the directory cache. Should
 *	    	  	    	print something for suffixes, too, but...
d111 1
d118 1
a118 1
static char *rcsid = "$OpenBSD: targ.c,v 1.29 2000/11/24 14:36:35 espie Exp $";
d122 4
a125 6
#ifdef CLEANUP
static LIST	  allGNs;	/* List of all the GNodes */
#endif
static struct ohash targets; 	/* a hash table of same */
static struct ohash_info gnode_info = { 
	offsetof(GNode, name), 
d128 3
a130 3
static void TargPrintOnlySrc __P((GNode *));
static void TargPrintName __P((void *));
static void TargPrintNode __P((GNode *, int));
d132 1
a132 1
static void TargFreeGN __P((void *));
d140 1
a140 1
* Side Effects:
a146 3
#ifdef CLEANUP
    Lst_Init(&allGNs);
#endif
d161 1
a161 1
Targ_End ()
d164 6
a169 1
    Lst_Destroy(&allGNs, TargFreeGN);
d184 1
a184 1
 *	The gnode is added to the set of all gnodes.
d189 2
a190 2
    const char		*name;	/* the name to stick in the new node */
    const char 		*end;
d192 1
a192 1
    GNode 		*gn;
d201 5
a205 5
    gn->unmade =    	0;
    gn->make = 	    	FALSE;
    gn->made = 	    	UNMADE;
    gn->childMade = 	FALSE;
    gn->order =		0;
d220 2
a221 2
#ifdef CLEANUP
    Lst_AtEnd(&allGNs, gn);
a231 6
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	None.
d238 1
a238 1
    GNode *gn = (GNode *) gnp;
d247 1
a248 1
    Lst_Destroy(&gn->commands, NOFREE);
d260 1
a260 1
 *	The node in the list if it was. If it wasn't, return NULL of
d262 1
a262 1
 *	if it was TARG_CREATE
d269 1
a269 1
Targ_FindNode(name, flags)
d271 2
a272 1
    int			flags;	/* flags governing events when target not
d275 1
a275 2
    const char		*end = NULL;
    GNode         	*gn;	/* node in that element */
d281 1
a281 1
    
d283 1
a283 1
    	gn = Targ_NewGN(name, end);
d296 1
a296 1
 *	Nodes will be created for all names which do not yet have graph
d299 2
a300 2
 *	A complete list of graph nodes corresponding to all instances of
 *	all names is added to nodes.
d305 2
a306 2
    Lst		nodes;		/* result list */
    Lst		names;		/* list of names to find */
d308 3
a310 3
    LstNode  	ln;		/* name list element */
    GNode	*gn;		/* node in tLn */
    char	*name;
d314 4
a317 6
	gn = Targ_FindNode(name, TARG_CREATE);
	/*
	 * Note: Lst_AtEnd must come before the Lst_Concat so the nodes
	 * are added to the list in the order in which they were
	 * encountered in the makefile.
	 */
d326 1
a326 1
 * Targ_Ignore  --
d332 1
a332 1
    GNode          *gn;		/* node to check for */
d342 1
a342 1
 * Targ_Silent  --
d348 1
a348 1
    GNode          *gn;		/* node to check for */
d363 2
a364 2
Targ_Precious (gn)
    GNode          *gn;		/* the node to check */
d387 1
a387 1
    GNode   *gn;  	/* The main target we'll create */
a396 1

a418 1
 *
d423 1
a423 1
    TIMESTAMP		time;
d425 2
a426 2
    struct tm	  	*parts;
    static char		buf[128];
d432 1
a432 1
    strftime(buf, sizeof buf, "%k:%M:%S %b %d, %Y", parts);
d434 1
a434 1
    return(buf);
d454 2
a455 2
#define PRINTBIT(attr) 	case CONCAT(OP_,attr): printf(".attr "); break
#define PRINTDBIT(attr)	case CONCAT(OP_,attr): if (DEBUG(TARG)) printf(".attr "); break
d464 1
a464 1
	switch(tbit) {
d491 2
a492 2
    GNode 	*gn;
    int  	pass;
d496 1
a496 1
	if (gn == mainTarg)
d498 1
d500 1
a500 1
	    if (gn->unmade)
d502 1
a502 1
	    else
d504 1
d506 1
a506 1
		if (!is_out_of_date(gn->mtime))
d513 1
a513 1
		else if (gn->made != UNMADE)
d519 1
a519 1
		else
d521 1
d532 1
a532 1
	    fputc ('\n', stdout);
d551 2
a552 2
	    
	    for (ln = Lst_First(&gn->cohorts); ln != NULL; ln = Lst_Adv(ln)) 
d561 1
a561 1
 *	Print only those targets that are just a source.
d566 1
a566 1
    GNode 	*gn;
d569 2
a570 1
	printf("#\t%s [%s]\n", gn->name, gn->path ? gn->path : gn->name);
d581 2
a582 2
    int	    		pass; 	/* Which pass this is. 1 => no processing
			 	 * 2 => processing done */
d588 1
a588 1
    for (gn = ohash_first(&targets, &i); gn != NULL; 
d593 1
a593 1
    for (gn = ohash_first(&targets, &i); gn != NULL; 
d596 1
a596 4
    printf("#*** Global Variables:\n");
    Var_Dump(VAR_GLOBAL);
    printf("#*** Command-line Variables:\n");
    Var_Dump(VAR_CMD);
@


1.29
log
@Change the time stamp interface to use an abstract datatype.
Define two possible interfaces: the classic one,
and the new one (used where available) that depends on timespec.

Better granularity, make is now able to distinguish between files that
were built during the same second.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.28 2000/09/14 13:52:42 espie Exp $	*/
d90 1
a90 1
static char *rcsid = "$OpenBSD: targ.c,v 1.28 2000/09/14 13:52:42 espie Exp $";
d97 2
a98 2
static struct hash targets; 	/* a hash table of same */
static struct hash_info gnode_info = { 
d125 1
a125 1
    hash_init(&targets, 10, &gnode_info);
d142 1
a142 1
    hash_delete(&targets);
d166 1
a166 1
    gn = hash_create_entry(&gnode_info, name, &end);
d256 1
a256 1
    slot = hash_qlookupi(&targets, name, &end);
d258 1
a258 1
    gn = hash_find(&targets, slot);
d262 1
a262 1
	hash_insert(&targets, slot, gn);
d566 2
a567 2
    for (gn = hash_first(&targets, &i); gn != NULL; 
	gn = hash_next(&targets, &i))
d571 2
a572 2
    for (gn = hash_first(&targets, &i); gn != NULL; 
	gn = hash_next(&targets, &i))
@


1.28
log
@Introduce a few macros to handle timestamps in an abstract way.

Replace the time stamp hash in dir.c with an open hashing structure.

In doing so, remove some nasty casts, simplify code a bit:
Dir_MTime can return a modification time, since make does not make
a distinction between out-of-date and non-existent files.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.27 2000/09/14 13:40:03 espie Exp $	*/
d90 1
a90 1
static char *rcsid = "$OpenBSD: targ.c,v 1.27 2000/09/14 13:40:03 espie Exp $";
d178 2
a179 1
    gn->mtime = gn->cmtime = OUT_OF_DATE;
d405 1
a405 1
    time_t    time;
d409 1
d411 3
a413 1
    parts = localtime(&time);
d486 1
a486 1
		if (gn->mtime != OUT_OF_DATE)
@


1.27
log
@Use the new hash scheme to store the target nodes.
Scrap the list of all targets: it only slows make down.
The only visible difference is that the list of all targets is not
shown in order when debugging.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.26 2000/09/14 13:32:08 espie Exp $	*/
a82 1
#include 	  "hash.h"
d90 1
a90 1
static char *rcsid = "$OpenBSD: targ.c,v 1.26 2000/09/14 13:32:08 espie Exp $";
@


1.26
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.25 2000/06/23 16:23:26 espie Exp $	*/
d44 1
a44 3
 *	Functions for maintaining the Lst allTargets. Target nodes are
 * kept in two structures: a Lst, maintained by the list library, and a
 * hash table, maintained by the hash library.
d78 1
d82 2
a83 1
#include	  "hash.h"
d91 1
a91 1
static char *rcsid = "$OpenBSD: targ.c,v 1.25 2000/06/23 16:23:26 espie Exp $";
a94 1
static LIST       allTargets;	/* the list of all targets found so far */
d98 4
a101 1
static Hash_Table targets;	/* a hash table of same */
d103 1
a103 3
#define HTSIZE	191		/* initial size of hash table */

static void TargPrintOnlySrc __P((void *));
d105 1
a105 1
static void TargPrintNode __P((void *, void *));
d116 1
a116 1
 *	The allTargets list and the targets hash table are initialized
d125 2
a126 2
    Lst_Init(&allTargets);
    Hash_InitTable(&targets, HTSIZE);
a133 3
 * Results:
 *	None
 *
a141 1
    Lst_Destroy(&allTargets, NOFREE);
d143 1
a143 1
    Hash_DeleteTable(&targets);
d157 1
a157 1
 *	The gnode is added to the list of all gnodes.
d161 3
a163 2
Targ_NewGN (name)
    char           *name;	/* the name to stick in the new node */
d165 1
a165 1
    register GNode *gn;
d167 2
a168 3
    gn = (GNode *) emalloc (sizeof (GNode));
    gn->name = estrdup (name);
    gn->path = (char *) 0;
d196 1
a196 1
    return (gn);
a217 2

    free(gn->name);
d247 3
a249 3
Targ_FindNode (name, flags)
    char           *name;	/* the name to find */
    int             flags;	/* flags governing events when target not
d252 11
a262 15
    GNode         *gn;	      /* node in that element */
    Hash_Entry	  *he;	      /* New or used hash entry for node */
    Boolean	  isNew;      /* Set TRUE if Hash_CreateEntry had to create */
			      /* an entry for the node */


    if (flags & TARG_CREATE) {
	he = Hash_CreateEntry (&targets, name, &isNew);
	if (isNew) {
	    gn = Targ_NewGN (name);
	    Hash_SetValue (he, gn);
	    Lst_AtEnd(&allTargets, gn);
	}
    } else {
	he = Hash_FindEntry (&targets, name);
d265 1
a265 5
    if (he == NULL) {
	return (NULL);
    } else {
	return ((GNode *) Hash_GetValue (he));
    }
a307 6
 *
 * Results:
 *	TRUE if should ignore errors
 *
 * Side Effects:
 *	None
d311 1
a311 1
Targ_Ignore (gn)
d314 4
a317 5
    if (ignoreErrors || gn->type & OP_IGNORE) {
	return (TRUE);
    } else {
	return (FALSE);
    }
a323 6
 *
 * Results:
 *	TRUE if should be silent
 *
 * Side Effects:
 *	None
d327 1
a327 1
Targ_Silent (gn)
d330 4
a333 5
    if (beSilent || gn->type & OP_SILENT) {
	return (TRUE);
    } else {
	return (FALSE);
    }
a339 6
 *
 * Results:
 *	TRUE if it is precious. FALSE otherwise
 *
 * Side Effects:
 *	None
d346 4
a349 5
    if (allPrecious || (gn->type & (OP_PRECIOUS|OP_DOUBLEDEP))) {
	return (TRUE);
    } else {
	return (FALSE);
    }
a360 3
 * Results:
 *	None.
 *
d366 1
a366 1
Targ_SetMain (gn)
d404 1
a404 1
Targ_FmtTime (time)
d408 1
a408 1
    static char			buf[128];
a420 5
 *
 * Results:
 *
 * Side Effects:
 *
d424 2
a425 2
Targ_PrintType (type)
    register int    type;
d427 1
a427 1
    register int    tbit;
d469 3
a471 3
TargPrintNode(gnp, passp)
    void *gnp;
    void *passp;
a472 2
    GNode         *gn = (GNode *)gnp;
    int	    	  pass = *(int *)passp;
d525 6
a530 2
	if (gn->type & OP_DOUBLEDEP)
	    Lst_ForEach(&gn->cohorts, TargPrintNode, &pass);
a537 4
 *
 * Side Effects:
 *	The name of each file is printed preceeded by #\t
 *
d541 2
a542 2
TargPrintOnlySrc(gnp)
    void *gnp;
a543 2
    GNode   	  *gn = (GNode *)gnp;

d551 1
a551 7
 *	print the entire graph. heh heh
 *
 * Results:
 *	none
 *
 * Side Effects:
 *	lots o' output
d555 3
a557 3
Targ_PrintGraph (pass)
    int	    pass; 	/* Which pass this is. 1 => no processing
			 * 2 => processing done */
d559 3
d563 3
a565 1
    Lst_ForEach(&allTargets, TargPrintNode, &pass);
d568 3
a570 1
    Lst_Every(&allTargets, TargPrintOnlySrc);
@


1.25
log
@This patch separates local contexts from global contexts for good.
Apart from a few casts, VAR_GLOBAL and friends are separate
data structures, so we use a small array for local variables.

We also junk allVars, since TargFreeGN can release local nodes,
and var.c has explicit lists for its variables already.

Reviewed millert@@ and miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.24 2000/06/23 16:21:43 espie Exp $	*/
a41 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)targ.c	8.2 (Berkeley) 3/19/94";
#else
static char *rcsid = "$OpenBSD: targ.c,v 1.24 2000/06/23 16:21:43 espie Exp $";
#endif
#endif /* not lint */

d86 9
d115 1
a115 4
 * Results:
 *	None
 *
 * Side Effects:
@


1.24
log
@In various places, VAR_CMD is used to actually mean `no real context',
since lookup will start with VAR_CMD in any case.
This fixes VarFind and Var_Parse to handle ctxt == NULL correctly, and
replace those confusing VAR_CMD with proper NULL pointers.

This patch also handles three small details:
- .CURDIR is necessarily set in VAR_GLOBAL,
- suffix handling for archives copies two hard-coded variables, for
which it can use a quick path,
- typos in TargFreeGN.

Reviewed millert@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.23 2000/06/23 16:20:01 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.23 2000/06/23 16:20:01 espie Exp $";
d192 1
a192 1
    Lst_Init(&gn->context);
d233 1
a233 1
    Lst_Destroy(&gn->context, NOFREE);
@


1.23
log
@Once those special variable are taken care of, other Var functions can take
the GNode's context directly.  We rename that special Lst to `SymTable *'
in prevision of things to come.

Along the line, we lose the special GNodes affected to VAR_CMD, VAR_GLOBAL,
VAR_ENV, which become simple Lsts... This is not a problem, except when
getting to a context's name for debugging (handled very nicely by
offsetof).

Again, this is a preparatory patch, which does not gain anything except
for cleaning up issues...

Reviewed by millert@@ and miod@@, like the previous patch
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.22 2000/06/23 16:15:50 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.22 2000/06/23 16:15:50 espie Exp $";
d227 8
a234 8
    Lst_Destroy(&gn->iParents, NOFRE);
    Lst_Destroy(&gn->cohorts, NOFRE);
    Lst_Destroy(&gn->parents, NOFRE);
    Lst_Destroy(&gn->children, NOFRE);
    Lst_Destroy(&gn->successors, NOFRE);
    Lst_Destroy(&gn->preds, NOFRE);
    Lst_Destroy(&gn->context, NOFRE);
    Lst_Destroy(&gn->commands, NOFRE);
@


1.22
log
@Trivial consequences of the previous list changes:

- audit code for Lst_Datum, it's never applied to an empty pointer,
so check can be removed -> turn into a macro,
- Lst_First, Lst_Last can become macro as well
- specialized version of Lst_Succ (Lst_Adv) to use in loops where it cannot
fail,
- Lst_Open can no longer fail. Trim down corresponding code.

Reviewed millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.21 2000/06/17 14:43:37 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.21 2000/06/17 14:43:37 espie Exp $";
d620 1
a620 1
    Var_Dump (VAR_GLOBAL);
d622 1
a622 1
    Var_Dump (VAR_CMD);
@


1.21
log
@This removes the few instances of Lst_New left.
- replaces Lst_Duplicate with Lst_Clone, which does not allocate storage
- split Lst_Concat into Lst_Concat/Lst_ConcatDestroy
Thus, all the LstValid checks are gone, since we always invoke list
functions with valid pointers.

Note that dynamic list allocation accounted for roughly 20% of all calls
to malloc.  The extraneous calls to malloc left are now mostly in parse.c,
which makes some wasteful usage of temporary buffers.

With those few patches, the code is sturdier, and easier to maintain.

Reviewed by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.20 2000/06/17 14:40:30 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.20 2000/06/17 14:40:30 espie Exp $";
d306 1
a306 1
    for (ln = Lst_First(names); ln != NULL; ln = Lst_Succ(ln)) {
@


1.20
log
@A few assorted changes, to remove more dynamic lists.
- in Dir_Expand, path is a misnomer. Use a temp variable instead...
Reformat code for readability.
- Change Parse_MainName/Targ_FindList so that they fill arguments instead
of allocating new lists.
- nuke Targ_FindList(TG_NOCREATE), as this is never used.

- close a small memory hole (forgot to free sysMkPath if CLEANUP).

Reviewed by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.19 2000/06/17 14:38:20 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.19 2000/06/17 14:38:20 espie Exp $";
d316 1
a316 1
	    Lst_Concat(nodes, &gn->cohorts, LST_CONCNEW);
@


1.19
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.18 2000/06/10 01:41:06 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.18 2000/06/10 01:41:06 espie Exp $";
d71 1
a71 4
 *	    	  	    	of them. If a name doesn't exist and the
 *	    	  	    	TARG_NOCREATE flag was given, an error message
 *	    	  	    	is printed. Else, if a name doesn't exist,
 *	    	  	    	its node is created.
d289 3
a291 3
 * Results:
 *	A complete list of graph nodes corresponding to all instances of all
 *	the names in names.
d293 2
a294 4
 * Side Effects:
 *	If flags is TARG_CREATE, nodes will be created for all names in
 *	names which do not yet have graph nodes. If flags is TARG_NOCREATE,
 *	an error message will be printed for each name which can't be found.
d297 4
a300 5
Lst
Targ_FindList(names, flags)
    Lst        	   names;	/* list of names to find */
    int            flags;	/* flags used if no node is found for a given
				 * name */
d302 3
a304 4
    Lst            nodes;	/* result list */
    register LstNode  ln;		/* name list element */
    register GNode *gn;		/* node in tLn */
    char    	  *name;
d306 1
a306 6
    nodes = Lst_New();

    if (Lst_Open (names) == FAILURE) {
	return (nodes);
    }
    while ((ln = Lst_Next (names)) != NULL) {
d308 9
a316 14
	gn = Targ_FindNode (name, flags);
	if (gn != NULL) {
	    /*
	     * Note: Lst_AtEnd must come before the Lst_Concat so the nodes
	     * are added to the list in the order in which they were
	     * encountered in the makefile.
	     */
	    Lst_AtEnd(nodes, gn);
	    if (gn->type & OP_DOUBLEDEP) {
		Lst_Concat(nodes, &gn->cohorts, LST_CONCNEW);
	    }
	} else if (flags == TARG_NOCREATE) {
	    Error ("\"%s\" -- target unknown.", name);
	}
a317 2
    Lst_Close (names);
    return (nodes);
@


1.18
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.17 2000/06/10 01:32:23 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.17 2000/06/10 01:32:23 espie Exp $";
d97 1
a97 1
static Lst        allTargets;	/* the list of all targets found so far */
d99 1
a99 1
static Lst	  allGNs;	/* List of all the GNodes */
d125 1
a125 1
Targ_Init ()
d127 5
a131 2
    allTargets = Lst_Init();
    Hash_InitTable (&targets, HTSIZE);
d150 2
a151 3
    Lst_Destroy(allTargets, NOFREE);
    if (allGNs)
	Lst_Destroy(allGNs, TargFreeGN);
d189 7
a195 7
    gn->iParents =  	Lst_Init();
    gn->cohorts =   	Lst_Init();
    gn->parents =   	Lst_Init();
    gn->children =  	Lst_Init();
    gn->successors = 	Lst_Init();
    gn->preds =     	Lst_Init();
    gn->context =   	Lst_Init();
d198 1
a198 1
    gn->commands =  	Lst_Init();
d202 1
a202 3
    if (allGNs == NULL)
	allGNs = Lst_Init();
    Lst_AtEnd(allGNs, gn);
d230 8
a237 9

    Lst_Destroy(gn->iParents, NOFREE);
    Lst_Destroy(gn->cohorts, NOFREE);
    Lst_Destroy(gn->parents, NOFREE);
    Lst_Destroy(gn->children, NOFREE);
    Lst_Destroy(gn->successors, NOFREE);
    Lst_Destroy(gn->preds, NOFREE);
    Lst_Destroy(gn->context, NOFREE);
    Lst_Destroy(gn->commands, NOFREE);
d274 1
a274 1
	    Lst_AtEnd(allTargets, gn);
d303 1
a303 1
Targ_FindList (names, flags)
d313 1
a313 1
    nodes = Lst_Init();
d329 1
a329 1
		Lst_Concat(nodes, gn->cohorts, LST_CONCNEW);
d565 1
a565 1
	    if (!Lst_IsEmpty (gn->iParents)) {
d567 1
a567 1
		Lst_Every(gn->iParents, TargPrintName);
d571 1
a571 1
	if (!Lst_IsEmpty (gn->parents)) {
d573 1
a573 1
	    Lst_Every(gn->parents, TargPrintName);
d587 1
a587 1
	Lst_Every(gn->children, TargPrintName);
d589 1
a589 1
	Lst_Every(gn->commands, Targ_PrintCmd);
d592 1
a592 1
	    Lst_ForEach(gn->cohorts, TargPrintNode, &pass);
d634 1
a634 1
    Lst_ForEach(allTargets, TargPrintNode, &pass);
d637 1
a637 1
    Lst_Every(allTargets, TargPrintOnlySrc);
@


1.17
log
@Thus, Lst_ForEach no longer needs returning a status.
In fact, it can become a macro based on Lst_ForEachFrom.
This also introduces Lst_Every, as a shortcut for the very common case where
Lst_ForEach does not need any user data.

Finally,  make consistent use of a few function typedefs, instead of having
explicit void (*)(Lst)  arguments all over the place.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.16 2000/04/17 23:57:46 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.16 2000/04/17 23:57:46 espie Exp $";
d105 3
a107 3
static void TargPrintOnlySrc __P((ClientData));
static void TargPrintName __P((ClientData));
static void TargPrintNode __P((ClientData, ClientData));
d109 1
a109 1
static void TargFreeGN __P((ClientData));
d222 2
a223 2
TargFreeGN (gnp)
    ClientData gnp;
d239 1
a239 1
    free((Address)gn);
d434 1
a434 1
    ClientData     gnp;
d444 1
a444 1
    ClientData cmd;
d535 2
a536 2
    ClientData   gnp;
    ClientData	 passp;
d609 1
a609 1
    ClientData 	  gnp;
@


1.16
log
@Initialize lineno and fname, see parse.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.15 2000/03/26 16:21:33 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.15 2000/03/26 16:21:33 espie Exp $";
d105 3
a107 3
static int TargPrintOnlySrc __P((ClientData, ClientData));
static int TargPrintName __P((ClientData, ClientData));
static int TargPrintNode __P((ClientData, ClientData));
d432 2
a433 2
static int
TargPrintName (gnp, ppath)
a434 1
    ClientData	    ppath;
d436 3
a438 13
    GNode *gn = (GNode *) gnp;
    printf ("%s ", gn->name);
#ifdef notdef
    if (ppath) {
	if (gn->path) {
	    printf ("[%s]  ", gn->path);
	}
	if (gn == mainTarg) {
	    printf ("(MAIN NAME)  ");
	}
    }
#endif /* notdef */
    return (ppath ? 0 : 0);
d442 2
a443 2
int
Targ_PrintCmd (cmd, dummy)
a444 1
    ClientData dummy;
d446 1
a446 2
    printf ("\t%s\n", (char *) cmd);
    return (dummy ? 0 : 0);
d533 2
a534 2
static int
TargPrintNode (gnp, passp)
d538 2
a539 2
    GNode         *gn = (GNode *) gnp;
    int	    	  pass = *(int *) passp;
d542 1
a542 1
	if (gn == mainTarg) {
a543 1
	}
d545 1
a545 1
	    if (gn->unmade) {
d547 1
a547 1
	    } else {
a548 1
	    }
d550 1
a550 1
		if (gn->mtime != OUT_OF_DATE) {
d557 1
a557 1
		} else if (gn->made != UNMADE) {
d563 1
a563 1
		} else {
a564 1
		}
d568 2
a569 2
		Lst_ForEach(gn->iParents, TargPrintName, NULL);
		fputc ('\n', stdout);
d574 1
a574 1
	    Lst_ForEach(gn->parents, TargPrintName, NULL);
d587 4
a590 4
	Targ_PrintType (gn->type);
	Lst_ForEach(gn->children, TargPrintName, NULL);
	fputc ('\n', stdout);
	Lst_ForEach(gn->commands, Targ_PrintCmd, NULL);
d592 1
a592 1
	if (gn->type & OP_DOUBLEDEP) {
a593 1
	}
a594 1
    return (0);
a601 3
 * Results:
 *	0.
 *
d607 2
a608 2
static int
TargPrintOnlySrc(gnp, dummy)
a609 1
    ClientData 	  dummy;
d611 2
a612 1
    GNode   	  *gn = (GNode *) gnp;
a614 2

    return (dummy ? 0 : 0);
d638 1
a638 1
    Lst_ForEach(allTargets, TargPrintOnlySrc, NULL);
@


1.15
log
@Remove idiotic, braindead casts T* -> void*
They serve no purpose, except hiding potential bugs.

In particular, remove (ClientData) cast from macro, showing potentially
troublesome use of Hashes to store time_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.14 2000/02/02 13:47:48 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.14 2000/02/02 13:47:48 espie Exp $";
d194 2
@


1.14
log
@Bug-fix: make should behave sensibly when presented with negative times...

- let *_MTime return booleans, as that's what they're used for, the time_t
is set as a side effect.

- use OUT_OF_DATE for a date starting point, set it at the origin of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.13 1999/12/18 21:58:08 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.13 1999/12/18 21:58:08 espie Exp $";
d200 1
a200 1
    Lst_AtEnd(allGNs, (ClientData)gn);
d273 1
a273 1
	    Lst_AtEnd(allTargets, (ClientData)gn);
d326 1
a326 1
	    Lst_AtEnd(nodes, (ClientData)gn);
d582 1
a582 1
		Lst_ForEach (gn->iParents, TargPrintName, (ClientData)0);
d588 1
a588 1
	    Lst_ForEach (gn->parents, TargPrintName, (ClientData)0);
d602 1
a602 1
	Lst_ForEach (gn->children, TargPrintName, (ClientData)0);
d604 1
a604 1
	Lst_ForEach (gn->commands, Targ_PrintCmd, (ClientData)0);
d607 1
a607 1
	    Lst_ForEach (gn->cohorts, TargPrintNode, (ClientData)&pass);
d656 1
a656 1
    Lst_ForEach (allTargets, TargPrintNode, (ClientData)&pass);
d659 1
a659 1
    Lst_ForEach (allTargets, TargPrintOnlySrc, (ClientData) 0);
@


1.13
log
@Nothing ever checks ReturnStatus on Lst_Insert, Lst_Append, Lst_AtFront,
Lst_AtEnd, Lst_Concat, Lst_Remove, Lst_Replace.

Don't bother returning one.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.12 1999/12/18 21:53:33 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.12 1999/12/18 21:53:33 espie Exp $";
d186 1
a186 1
    gn->mtime = gn->cmtime = 0;
d563 1
a563 1
		if (gn->mtime != 0) {
@


1.12
log
@NIL, NILGNODE, etc, are only glorified NULL.
Get rid of them.

Get rid of list.h, nothing uses it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.11 1999/12/18 02:11:27 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.11 1999/12/18 02:11:27 espie Exp $";
d200 1
a200 1
    Lst_AtEnd(allGNs, (ClientData) gn);
d273 1
a273 1
	    (void) Lst_AtEnd (allTargets, (ClientData)gn);
d326 1
a326 1
	    (void) Lst_AtEnd (nodes, (ClientData)gn);
d328 1
a328 1
		(void)Lst_Concat (nodes, gn->cohorts, LST_CONCNEW);
@


1.11
log
@make does not use circular lists, get rid of the extra weight.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.10 1999/10/05 22:06:24 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.10 1999/10/05 22:06:24 espie Exp $";
d248 1
a248 1
 *	The node in the list if it was. If it wasn't, return NILGNODE of
d279 2
a280 2
    if (he == (Hash_Entry *) NULL) {
	return (NILGNODE);
d317 1
a317 1
    while ((ln = Lst_Next (names)) != NILLNODE) {
d320 1
a320 1
	if (gn != NILGNODE) {
@


1.10
log
@Efficiency patch from NetBSD:
make spends time freeing data structures right before exiting.
So don't bother.
Keep the code inside #ifdef, so that it's still there if someone
ever wants to use make code inside a library.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.9 1998/12/05 00:06:29 espie Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.9 1998/12/05 00:06:29 espie Exp $";
d127 1
a127 1
    allTargets = Lst_Init (FALSE);
d187 8
a194 8
    gn->iParents =  	Lst_Init (FALSE);
    gn->cohorts =   	Lst_Init (FALSE);
    gn->parents =   	Lst_Init (FALSE);
    gn->children =  	Lst_Init (FALSE);
    gn->successors = 	Lst_Init (FALSE);
    gn->preds =     	Lst_Init (FALSE);
    gn->context =   	Lst_Init (FALSE);
    gn->commands =  	Lst_Init (FALSE);
d199 1
a199 1
	allGNs = Lst_Init(FALSE);
d312 1
a312 1
    nodes = Lst_Init (FALSE);
@


1.9
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.7 1997/04/28 01:52:42 millert Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.7 1997/04/28 01:52:42 millert Exp $";
d98 1
d100 1
d108 1
d110 1
d146 1
d151 1
d197 1
d201 1
d206 1
d239 1
@


1.8
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d218 1
a218 2
    if (gn->path)
	free(gn->path);
@


1.7
log
@Back out newer .USE code as it caused problems.  I've done a "make build"
without problems and the problem Theo saw before is gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.6 1997/04/01 07:28:24 millert Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.6 1997/04/01 07:28:24 millert Exp $";
d470 1
a470 5
    static char	  	buf[40];
    static char	  	*months[] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    };
d473 2
a474 4

    sprintf (buf, "%d:%02d:%02d %s %d, %d",
	     parts->tm_hour, parts->tm_min, parts->tm_sec,
	     months[parts->tm_mon], parts->tm_mday, 1900 + parts->tm_year);
@


1.6
log
@Sync with NetBSD (mostly by christos initial substitution/regexp from Der Mouse)

- fix the variable substitution code in make [PR/2748]
      1. change s/a/b/ so that it substitutes the first occurance of the
         pattern on each word, not only the first word.
      2. add flag '1' to the variable substitution so that the substitutions
         get performed only once.

  ***THIS IS AN INCOMPATIBLE CHANGE!***

  Unfortunately there was no way to make things consistent without
  modifying the current behavior. Fortunately none of our Makefiles
  depended on this.

            OLD:

                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4

            NEW:
                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 ba2 ba3 ba4
                S/a/b/1  = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4
                S/a/b/1g = bb1 aa2 aa3 aa4
- add regexp variable substitution via 'C/foo/bar/' [PR/2752]
- add variable quoting via the ${VAR:Q} modifier. This is useful when running
  recursive invocations of make(1):

        make VAR=${VAR:Q}

  will always work... (This may prove useful in the kernel builds...) [PR/2981]
- BSD did not traditionally have <sys/cdefs.h>; use BSD4_4 instead and include
  <sys/param.h> to grab it.
- Don't compile the regex code if MAKE_BOOTSTRAP (from gwr)
- Use explicit .c.o rule in Makefile.boot so that the bootstrap process works.
- Use only integral types in procedure arguments. [buf.c buf.h]
- Include <stdlib.h> to get getenv() prototype on SVR4
- if __STDC__ -> ifdef __STDC__ to appease SVR4
- Define const and volatile for non __STDC__
- Implement snprintf() and vsnprintf() for non BSD4_4 systems.
- Make $MACHINE_ARCH settable from the environment.
- Fix .USE directive problems: (reported by cgd)
    1. ${.*} variables did not get expanded in dependencies.
    2. expanded ${.*} variables in .USE dependencies can cause tree
       restructuring; handle it.
    3. in compat mode, expand .USE before evaluating the list of targets,
       instead of doing .USE expansions on demand, because they can cause
       tree restructuring.
- Add a .MADE directive to indicated that the children of a target are
  up-to-date, even when they are not. This is to simulate our current
  make install behavior with proper dependencies.
- Fix problems in the RE substitution error handling.
- Locate all the children of a node marked as MADE.
- Do not compile-in ${MACHINE} (as per NetBSD PR#3386)
- Disable globbing for targets/dependencies when POSIX is defined.
- Fix globbing so that patterns that don't have a matching number of [] or {}
  don't get expanded. (before the [ case got expanded to nothing!) This is
  disabled.
- Make sure that the children of nodes that are marked .MADE, are marked
  UPTODATE and their timestamps are consistent.
- Don't disable wildcards completely; they are used by other Makefiles.
@
text
@d1 1
a1 1
/*	$OpenBSD: targ.c,v 1.5 1996/11/30 21:09:05 millert Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.5 1996/11/30 21:09:05 millert Exp $";
a168 1
    gn->uname = NULL;
a217 2
    if (gn->uname)
	free(gn->uname);
@


1.5
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 2
a2 2
/*	$OpenBSD: targ.c,v 1.4 1996/09/02 16:04:20 briggs Exp $	*/
/*	$NetBSD: targ.c,v 1.10 1996/11/06 17:59:27 christos Exp $	*/
d46 1
a46 1
static char *rcsid = "$OpenBSD: targ.c,v 1.4 1996/09/02 16:04:20 briggs Exp $";
d169 1
d219 2
@


1.4
log
@Sync up with NetBSD:
(christos)
	Fix bug reported by Greg Hudson where leaf (source only) nodes were
	referenced only by their basename and not by their full pathname. This
	breaks when .PATH or MAKEOBJDIR are used. There might be Makefiles
	around that try to work around this bug by prepending ${.CURDIR} to
	the sources, and they should be found and fixed. Also a lot of the gunk
	in suff.c that was attempting to work around the same problem could be
	removed.
(christos)
	- Move -D flags from Makefile to config.h and explain what they do. Add
	  -Wall -Wno-unused to CFLAGS. Add new define SYSVVARSUB to enable SysV
	  style variable substitutions and enable them.
	- Add SunOS style command substitutions via SUNSHCMD
	- Fix core dump with '{variable = value'
(christos)
	Fix bug where make will always exit with 0, even when one or more
	parallel jobs failed. (Only affects parallel make code)
(christos)
	Protect __P from being multiply defined (for systems that already
	define it)
(christos) Add strdup() since ultrix is missing it.
	From Larry Schwimmer <rosebud@@cyclone.Stanford.EDU>
(christos) Add estrdup(), a checked version of strdup and use it.
(christos) Recognize SVR4 style long filename entries in archives.
(thorpej) Tidy up some RCS ids a bit.
@
text
@d1 2
a2 2
/*	$OpenBSD: targ.c,v 1.3 1996/04/21 23:43:28 deraadt Exp $	*/
/*	$NetBSD: targ.c,v 1.9 1996/08/30 17:59:43 thorpej Exp $	*/
d5 2
a6 2
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
d43 5
a47 2
/* from: static char sccsid[] = "@@(#)targ.c	5.9 (Berkeley) 3/1/91"; */
static char *rcsid = "$Id: targ.c,v 1.3 1996/04/21 23:43:28 deraadt Exp $";
d280 1
a280 1
 *	Make a complete list of GNodes from the given list of names 
d284 1
a284 1
 *	the names in names. 
d401 1
a401 1
/*- 
d483 1
a483 1
    
d501 1
a501 1
    
d588 1
a588 1
	
@


1.3
log
@sync to netbsd 960418
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: targ.c,v 1.7 1996/04/08 18:57:49 jtc Exp $	*/
d44 1
a44 1
static char *rcsid = "$Id: targ.c,v 1.2 1995/12/17 13:42:03 deraadt Exp $";
d165 1
a165 1
    gn->name = strdup (name);
@


1.2
log
@from christos:
- Added .WAIT to synchronize between sources like other pmake variants.
- Updated documentation to include .ORDER .PARALLEL .NO_PARALLEL .NONPARALLEL
@
text
@d1 2
a2 1
/*	$NetBSD: targ.c,v 1.6 1995/12/16 05:03:15 christos Exp $	*/
d44 1
a44 1
static char *rcsid = "$Id: targ.c,v 1.6 1995/12/16 05:03:15 christos Exp $";
d475 1
a475 1
    sprintf (buf, "%d:%02d:%02d %s %d, 19%d",
d477 1
a477 1
	     months[parts->tm_mon], parts->tm_mday, parts->tm_year);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: targ.c,v 1.5 1995/06/14 15:20:08 christos Exp $	*/
d43 1
a43 1
static char *rcsid = "$Id: targ.c,v 1.5 1995/06/14 15:20:08 christos Exp $";
d175 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
