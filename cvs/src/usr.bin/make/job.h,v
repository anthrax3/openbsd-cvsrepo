head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.18
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.16
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.12
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.14
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.6
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.10
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.8
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.4
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.2
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.25.0.10
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.8
	OPENBSD_5_0:1.25.0.6
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.4
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.22.0.6
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.15.0.14
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.12
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.10
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2012.12.14.11.10.03;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2012.12.08.12.54.17;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2012.12.07.15.08.58;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2012.10.18.17.54.43;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2012.10.02.10.29.31;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2009.05.10.11.07.37;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2008.01.12.13.08.59;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.02.17.27.24;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.23.09.44.39;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.18.07.45.25;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.17.12.42.09;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.17.12.01.16;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.17.11.43.12;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.07.13.11.36;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.19.00.08.31;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.02.13.42.51;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.02.00.23.14;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.23.12.34.45;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.03.13.41.06;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.14.13.32.07;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.17.14.38.17;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	99.12.18.21.53.32;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	98.12.05.00.06.28;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	97.06.15.21.29.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.11.30.21.08.57;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.36.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.42;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.31
log
@a few more comments
@
text
@#ifndef _JOB_H_
#define _JOB_H_

/*	$OpenBSD: job.h,v 1.30 2012/12/08 12:54:17 espie Exp $	*/
/*	$NetBSD: job.h,v 1.5 1996/11/06 17:59:10 christos Exp $ */

/*
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)job.h 8.1 (Berkeley) 6/6/93
 */

/*-
 * job.h --
 *	Definitions pertaining to the running of jobs.
 */

/* Job_Make(gn);
 *	register a new job running commands associated with building gn.
 */
extern void Job_Make(GNode *);
/* Job_Init(maxproc);
 *	setup job handling framework
 */
extern void Job_Init(int);

/* interface with the normal build in make.c */
/* okay = can_start_job();
 *	can we run new jobs right now ?
 */
extern bool can_start_job(void);

/* finished = Job_Empty();
 *	wait until all jobs are finished after we build everything.
 */
extern bool Job_Empty(void);

/* errors = Job_Finish();
 *	final processing including running .END target if no errors.
 */
extern bool Job_Finish(void);

/* Job_Begin();
 *	similarly, run .BEGIN job at start of job.
 */
extern void Job_Begin(void);

extern void Job_Wait(void);
extern void Job_AbortAll(void);
extern void print_errors(void);

/* handle_running_jobs();
 *	wait until something happens, like a job finishing running a command
 *	or a signal coming in.
 */
extern void handle_running_jobs(void);

/* handle_all_signals();
 *	if a signal was received, react accordingly.
 *	By displaying STATUS info, or by aborting running jobs for a fatal
 *	signals. Relies on Job_Init() for setting up handlers.
 */
extern void handle_all_signals(void);

extern void determine_expensive_job(Job *);
extern Job *runningJobs, *errorJobs;
extern void debug_job_printf(const char *, ...);
extern void handle_one_job(Job *);
extern int check_dying_signal(void);

extern const char *basedirectory;

#endif /* _JOB_H_ */
@


1.30
log
@document a bit of job.c
notice that Job_Finish() really returns a boolean, so unconfuse
that accordingly (it's likely the extra Fatal() message is not
needed and we could just call finish)
@
text
@d4 1
a4 1
/*	$OpenBSD: job.h,v 1.29 2012/12/07 15:08:58 espie Exp $	*/
d81 5
d87 6
@


1.29
log
@job.h is also used for compat sequential mode.
@
text
@d4 1
a4 1
/*	$OpenBSD: job.h,v 1.28 2012/10/18 17:54:43 espie Exp $	*/
d48 3
d52 3
d56 5
d62 4
d67 9
a75 1
extern int Job_Finish(void);
@


1.28
log
@numerous error message fixes:
- do ^C checking differently: don't record sent signals, but when jobs
die, recheck whether we received/have pending a INT/QUIT/TERM/HUP signal.
Then don't display our process group "normally", instead group together
everything dying by signal/shell dying by signal (just give the target
names).

- make certain we always handle signals before dying from "other conditions"
- have the parser messages look more like normal messages
- remove double error messages from some parser errors
- make sure unclosed variables ARE errors when some modifiers are present

- keep track of the base directory we're run from, so that submakes can
get shortened directories...
- make sure the whole error message including silent command fits into a
reasonable length.

okay millert@@
@
text
@d4 1
a4 1
/*	$OpenBSD: job.h,v 1.27 2012/10/02 10:29:31 espie Exp $	*/
d45 1
a45 1
 *	Definitions pertaining to the running of jobs in parallel mode.
@


1.27
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d4 1
a4 1
/*	$OpenBSD: job.h,v 1.26 2012/09/21 07:55:20 espie Exp $	*/
d65 4
@


1.26
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d4 1
a4 1
/*	$OpenBSD: job.h,v 1.25 2010/07/19 19:46:44 espie Exp $	*/
a53 5
#ifdef CLEANUP
extern void Job_End(void);
#else
#define Job_End()
#endif
@


1.25
log
@Correct $OpenBSD$ stuff
@
text
@d4 1
a4 1
/*	$OpenBSD: job.h,v 1.24 2010/07/19 19:30:37 espie Exp $	*/
d53 1
d59 1
d64 1
a64 1
extern void parallel_handler(int);
d66 4
@


1.24
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d4 1
a4 2
/*	$OpenPackages$ */
/*	$OpenBSD$	*/
@


1.23
log
@simplify job handling a great deal: we don't care when jobs get
stopped/continued, as we won't try to start new jobs when other stuff
is stopped.

Redo signal handling so that most stuff can be done directly in the handler.
This requires blocking/unblocking signals while creating new jobs, and creating
a small list that only contains job's pids.

Switch to pgrps for jobs, since that works.

Add a clamping heuristic that avoids starting new jobs while an expensive job
is running (expensive meaning "very likely to be a recursive make run"). This
idea is mostly from Theo, through the implementation is mine.
@
text
@@


1.22
log
@better error reporting/job handling error:
- systematically reorder jobs based on who did output last, so that the
last job to output is *first* to output again.
- better reaction to errors: any job that outputs is checked for termination
directly, and the Error message is printed right afterwards.
- better error messages, giving more useful information in -j mode.
@
text
@d51 1
a51 1
extern bool Job_Full(void);
d63 1
@


1.21
log
@Work done at p2k7.


This is a really big step towards getting parallel make to work.


Note that this is not yet complete. There are still a few `details' to
fix before this works 100%.  Specifically: sequential make (compat) and
parallel make don't use the same engine, and the parallel engine still
has a few limitations. For instance, some known issues:
- parallel make does not deal with .phony targets correctly all the time.
- some errors are deadly in parallel make mode.
- parallel make NEEDS way more sturdy correspondance of file system paths
and target names, since it often needs to match dependencies to targets
before the corresponding files exist.
- some local variables like $* get set in a bogus way in some cases.
- suffix handling has issues, especially related to the NULL suffix.
So, if you find stuff that does NOT yet work with parallel make, don't go
blindly try to fix the Makefile. It's very likely you might have stumbled
into a make bug. (unless you really, really, understand Makefiles, DON'T
GO CHANGING THEM YET).



Tested by lots of people, thanks go to miod@@, and robert@@ among other people.

Quick summary of what this does:

- remove `saving commands' extension (it's not really usable, nor used)
- move compat job runner and parallel interrupt handling into engine.c
- tweak the code so that both compat and parallel mode use the same job runner
and the same interrupt handling. Remove the other one.
- optimize job runner so that, in parallel mode, the last command does not
fork if we can avoid it (as it's already running in a sub shell).
- scrape all the code that dealt with creating shell scripts from commands.
- scrape all the code that dealt with recognizing special sequences in
command output to print/not print output.
- fix the parallel job pipe to not keep around file descriptors that are not
needed.
- replace the parallel job buffering with a nicer one, that deals with
non-blocking descriptors to try to agregate as much output from one job in
one go (greed) to unconfuse the users.
- create two pipes per job, so that stdout and stderr stay separate.
- make job token printing a debug option.
- always use the parallel job-runner to `execute' commands, even if we just
print them out.
- store list of errors encountered during parallel make running, and print them
on exit, so that we know what went wrong.
- add a dirty hack to targ.c to deal with paths produced by gccmakedep.
@
text
@a48 2
extern void Job_CatchChildren(void);
extern void Job_CatchOutput(void);
d62 1
@


1.20
log
@kill local/jobs distinction. Correctly this time...
@
text
@d63 1
@


1.19
log
@revert maxLocal removal, there's something fishy going on.
@
text
@d5 1
a5 1
/*	$OpenBSD: job.h,v 1.18 2007/09/17 12:42:09 espie Exp $	*/
d52 1
a52 1
extern void Job_Init(int, int);
@


1.18
log
@rewrite of the basic suffix/target parsing: use hash for suffixes.

Store special targets in target hash, and use them for the parsing.

Use OP_DUMMY flag to mark targets that don't really exist yet, such
as interrupt and default nodes.

Also, .PATHxxx is special in suffixes.

Small tweaks to compat.c, so that run_commands does more stuff after
the fork() (and thus no need to free things).

Remove distinction between local and global jobs.
@
text
@d5 1
a5 1
/*	$OpenBSD: job.h,v 1.15 2004/04/07 13:11:36 espie Exp $	*/
d52 1
a52 1
extern void Job_Init(int);
@


1.17
log
@make usePipes the default, zap undocumented -P.
@
text
@d5 1
a5 1
/*	$OpenBSD: job.h,v 1.16 2007/09/17 11:43:12 espie Exp $	*/
d52 1
a52 1
extern void Job_Init(int, int);
@


1.16
log
@remove prototypes that now live in engine.h, adjust suff.c accordingly
@
text
@d5 1
a5 1
/*	$OpenBSD: job.h,v 1.15 2004/04/07 13:11:36 espie Exp $	*/
d49 1
a49 1
extern void Job_CatchChildren(bool);
@


1.15
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d5 1
a5 1
/*	$OpenBSD: job.h,v 1.14 2003/06/03 02:56:11 millert Exp $	*/
a48 3
extern void Job_Touch(GNode *, bool);
extern bool Job_CheckCommands(GNode *,
	void (*abortProc )(char *, ...));
a54 1
extern bool Job_ParseShell(const char *);
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d5 1
a5 1
/*	$OpenBSD: job.h,v 1.13 2002/03/19 00:08:31 espie Exp $	*/
d58 1
a58 1
extern bool Job_ParseShell(char *);
@


1.13
log
@Kill remote comments, un-expose private code.
ok millert@@
@
text
@d5 1
a5 1
/*	$OpenBSD: job.h,v 1.12 2002/03/02 13:42:51 espie Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@Kill JOB_REMIGRATE.
@
text
@d5 1
a5 1
/*	$OpenBSD: job.h,v 1.11 2002/03/02 00:23:14 espie Exp $	*/
a50 1
 *	Exported from job.c for the use of remote-execution modules.
a51 151
#define TMPPAT	"/tmp/makeXXXXXXXXXX"

/*
 * The SEL_ constants determine the maximum amount of time spent in select
 * before coming out to see if a child has finished. SEL_SEC is the number of
 * seconds and SEL_USEC is the number of micro-seconds
 */
#define SEL_SEC 	0
#define SEL_USEC	500000


/*-
 * Job Table definitions.
 *
 * Each job has several things associated with it:
 *	1) The process id of the child shell
 *	2) The graph node describing the target being made by this job
 *	3) A LstNode for the first command to be saved after the job
 *	   completes. This is NULL if there was no "..." in the job's
 *	   commands.
 *	4) An FILE* for writing out the commands. This is only
 *	   used before the job is actually started.
 *	5) A union of things used for handling the shell's output. Different
 *	   parts of the union are used based on the value of the usePipes
 *	   flag. If it is true, the output is being caught via a pipe and
 *	   the descriptors of our pipe, an array in which output is line
 *	   buffered and the current position in that buffer are all
 *	   maintained for each job. If, on the other hand, usePipes is false,
 *	   the output is routed to a temporary file and all that is kept
 *	   is the name of the file and the descriptor open to the file.
 *	6) An identifier provided by and for the exclusive use of the
 *	   Rmt module.
 *	7) A word of flags which determine how the module handles errors,
 *	   echoing, etc. for the job
 *
 * The job "table" is kept as a linked Lst in 'jobs', with the number of
 * active jobs maintained in the 'nJobs' variable. At no time will this
 * exceed the value of 'maxJobs', initialized by the Job_Init function.
 *
 * When a job is finished, the Make_Update function is called on each of the
 * parents of the node which was just remade. This takes care of the upward
 * traversal of the dependency graph.
 */
#define JOB_BUFSIZE	1024
typedef struct Job_ {
    int 	pid;	    /* The child's process ID */
    GNode	*node;	    /* The target the child is making */
    LstNode	tailCmds;   /* The node of the first command to be
			     * saved when the job has been run */
    FILE	*cmdFILE;   /* When creating the shell script, this is
			     * where the commands go */
    int 	rmtID;	   /* ID returned from Rmt module */
    short	flags;	    /* Flags to control treatment of job */
#define JOB_IGNERR	0x001	/* Ignore non-zero exits */
#define JOB_SILENT	0x002	/* no output */
#define JOB_SPECIAL	0x004	/* Target is a special one. i.e. run it locally
				 * if we can't export it and maxLocal is 0 */
#define JOB_IGNDOTS	0x008	/* Ignore "..." lines when processing
				 * commands */
#define JOB_FIRST	0x020	/* Job is first job for the node */
#define JOB_RESTART	0x080	/* Job needs to be completely restarted */
#define JOB_RESUME	0x100	/* Job needs to be resumed b/c it stopped,
				 * for some reason */
#define JOB_CONTINUING	0x200	/* We are in the process of resuming this job.
				 * Used to avoid infinite recursion between
				 * JobFinish and JobRestart */
    union {
	struct {
	    int 	op_inPipe;	/* Input side of pipe associated
					 * with job's output channel */
	    int 	op_outPipe;	/* Output side of pipe associated with
					 * job's output channel */
	    char	op_outBuf[JOB_BUFSIZE + 1];
					/* Buffer for storing the output of the
					 * job, line by line */
	    int 	op_curPos;	/* Current position in op_outBuf */
	}	    o_pipe;	    /* data used when catching the output via
				     * a pipe */
	struct {
	    char	of_outFile[sizeof(TMPPAT)];
					/* Name of file to which shell output
					 * was rerouted */
	    int 	of_outFd;	/* Stream open to the output
					 * file. Used to funnel all
					 * from a single job to one file
					 * while still allowing
					 * multiple shell invocations */
	}	    o_file;	    /* Data used when catching the output in
				     * a temporary file */
    }		output;     /* Data for tracking a shell's output */
} Job;

#define outPipe 	output.o_pipe.op_outPipe
#define inPipe		output.o_pipe.op_inPipe
#define outBuf		output.o_pipe.op_outBuf
#define curPos		output.o_pipe.op_curPos
#define outFile 	output.o_file.of_outFile
#define outFd		output.o_file.of_outFd


/*-
 * Shell Specifications:
 * Each shell type has associated with it the following information:
 *	1) The string which must match the last character of the shell name
 *	   for the shell to be considered of this type. The longest match
 *	   wins.
 *	2) A command to issue to turn off echoing of command lines
 *	3) A command to issue to turn echoing back on again
 *	4) What the shell prints, and its length, when given the echo-off
 *	   command. This line will not be printed when received from the shell
 *	5) A boolean to tell if the shell has the ability to control
 *	   error checking for individual commands.
 *	6) The string to turn this checking on.
 *	7) The string to turn it off.
 *	8) The command-flag to give to cause the shell to start echoing
 *	   commands right away.
 *	9) The command-flag to cause the shell to Lib_Exit when an error is
 *	   detected in one of the commands.
 *
 * Some special stuff goes on if a shell doesn't have error control. In such
 * a case, errCheck becomes a printf template for echoing the command,
 * should echoing be on and ignErr becomes another printf template for
 * executing the command while ignoring the return status. If either of these
 * strings is empty when hasErrCtl is false, the command will be executed
 * anyway as is and if it causes an error, so be it.
 */
typedef struct Shell_ {
    char	  *name;	/* the name of the shell. For Bourne and C
				 * shells, this is used only to find the
				 * shell description when used as the single
				 * source of a .SHELL target. For user-defined
				 * shells, this is the full path of the shell.
				 */
    bool	  hasEchoCtl;	/* True if both echoOff and echoOn defined */
    char	  *echoOff;	/* command to turn off echo */
    char	  *echoOn;	/* command to turn it back on again */
    char	  *noPrint;	/* command to skip when printing output from
				 * shell. This is usually the command which
				 * was executed to turn off echoing */
    int 	  noPLen;	/* length of noPrint command */
    bool	  hasErrCtl;	/* set if can control error checking for
				 * individual commands */
    char	  *errCheck;	/* string to turn error checking on */
    char	  *ignErr;	/* string to turn off error checking */
    /*
     * command-line flags
     */
    char	  *echo;	/* echo commands */
    char	  *exit;	/* exit on error */
}		Shell;

a70 1
extern void JobFlagForMigration(int);
@


1.11
log
@kill #ifdef REMOTE stuff that only obfuscates issues.
ok millert@@, miod@@
@
text
@d5 1
a5 1
/*	$OpenBSD: job.h,v 1.10 2001/05/23 12:34:45 espie Exp $	*/
a112 1
#define JOB_REMIGRATE	0x040	/* Job needs to be remigrated */
@


1.10
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d5 1
a5 1
/*	$OpenBSD: job.h,v 1.5 1998/12/05 00:06:28 espie Exp $	*/
a111 1
#define JOB_REMOTE	0x010	/* Job is running remotely */
a203 18


#ifdef REMOTE
extern char	*targFmt;	/* Format string for banner that separates
				 * output from multiple jobs. Contains a
				 * single %s where the name of the node being
				 * made should be put. */
extern GNode	*lastNode;	/* Last node for which a banner was printed.
				 * If Rmt module finds it necessary to print
				 * a banner, it should set this to the node
				 * for which the banner was printed */
extern int	nJobs;		/* Number of jobs running (local and remote) */
extern int	nLocal; 	/* Number of jobs running locally */
extern LIST	jobs;		/* List of active job descriptors */
extern bool	jobFull;	/* Non-zero if no more jobs should/will start*/
extern LIST	stoppedJobs;	/* List of jobs that are stopped or didn't
				 * quite get started */
#endif
@


1.9
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d1 3
a52 3
#ifndef _JOB_H_
#define _JOB_H_

d178 1
a178 1
 * strings is empty when hasErrCtl is FALSE, the command will be executed
d188 1
a188 1
    Boolean	  hasEchoCtl;	/* True if both echoOff and echoOn defined */
d195 1
a195 1
    Boolean	  hasErrCtl;	/* set if can control error checking for
d219 1
a219 1
extern Boolean	jobFull;	/* Non-zero if no more jobs should/will start*/
d225 2
a226 2
extern void Job_Touch(GNode *, Boolean);
extern Boolean Job_CheckCommands(GNode *,
d228 1
a228 1
extern void Job_CatchChildren(Boolean);
d232 3
a234 3
extern Boolean Job_Full(void);
extern Boolean Job_Empty(void);
extern ReturnStatus Job_ParseShell(char *);
d236 1
d238 3
@


1.8
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 3
a3 2
/*	$OpenBSD: job.h,v 1.7 2000/06/17 14:38:17 espie Exp $	*/
/*	$NetBSD: job.h,v 1.5 1996/11/06 17:59:10 christos Exp $	*/
d42 1
a42 1
 *	from: @@(#)job.h	8.1 (Berkeley) 6/6/93
d60 1
a60 1
#define SEL_SEC		0
d63 1
a63 1

d97 4
a100 4
typedef struct Job {
    int       	pid;	    /* The child's process ID */
    GNode    	*node;      /* The target the child is making */
    LstNode 	tailCmds;   /* The node of the first command to be
d102 1
a102 1
    FILE 	*cmdFILE;   /* When creating the shell script, this is
d104 4
a107 4
    int    	rmtID;     /* ID returned from Rmt module */
    short      	flags;	    /* Flags to control treatment of job */
#define	JOB_IGNERR	0x001	/* Ignore non-zero exits */
#define	JOB_SILENT	0x002	/* no output */
d110 1
a110 1
#define JOB_IGNDOTS	0x008  	/* Ignore "..." lines when processing
d123 1
a123 1
	    int	  	op_inPipe;	/* Input side of pipe associated
d125 1
a125 1
	    int   	op_outPipe;	/* Output side of pipe associated with
d127 2
a128 2
	    char  	op_outBuf[JOB_BUFSIZE + 1];
	    	  	    	    	/* Buffer for storing the output of the
d130 2
a131 2
	    int   	op_curPos;	/* Current position in op_outBuf */
	}   	    o_pipe;	    /* data used when catching the output via
d134 2
a135 2
	    char  	of_outFile[sizeof(TMPPAT)];
	    	  	    	    	/* Name of file to which shell output
d137 1
a137 1
	    int	    	of_outFd;	/* Stream open to the output
d142 1
a142 1
	}   	    o_file;	    /* Data used when catching the output in
d144 1
a144 1
    }       	output;	    /* Data for tracking a shell's output */
d147 2
a148 2
#define outPipe	  	output.o_pipe.op_outPipe
#define inPipe	  	output.o_pipe.op_inPipe
d151 3
a153 2
#define outFile		output.o_file.of_outFile
#define outFd	  	output.o_file.of_outFd
a154 1

d181 1
a181 1
typedef struct Shell {
d188 4
a191 4
    Boolean 	  hasEchoCtl;	/* True if both echoOff and echoOn defined */
    char          *echoOff;	/* command to turn off echo */
    char          *echoOn;	/* command to turn it back on again */
    char          *noPrint;	/* command to skip when printing output from
d194 1
a194 1
    int           noPLen;	/* length of noPrint command */
d202 3
a204 3
    char          *echo;	/* echo commands */
    char          *exit;	/* exit on error */
}               Shell;
d207 2
a208 1
extern char 	*targFmt;   	/* Format string for banner that separates
d212 1
a212 1
extern GNode	*lastNode;  	/* Last node for which a banner was printed.
d216 5
a220 4
extern int  	nJobs;	    	/* Number of jobs running (local and remote) */
extern int  	nLocal;	    	/* Number of jobs running locally */
extern LIST  	jobs;	    	/* List of active job descriptors */
extern LIST  	stoppedJobs;	/* List of jobs that are stopped or didn't
d222 1
a222 1
extern Boolean	jobFull;    	/* Non-zero if no more jobs should/will start*/
d225 15
a239 14
extern void Job_Touch __P((GNode *, Boolean));
extern Boolean Job_CheckCommands __P((GNode *, void (*abortProc )(char *, ...)));
extern void Job_CatchChildren __P((Boolean));
extern void Job_CatchOutput __P((void));
extern void Job_Make __P((GNode *));
extern void Job_Init __P((int, int));
extern Boolean Job_Full __P((void));
extern Boolean Job_Empty __P((void));
extern ReturnStatus Job_ParseShell __P((char *));
extern int Job_Finish __P((void));
extern void Job_End __P((void));
extern void Job_Wait __P((void));
extern void Job_AbortAll __P((void));
extern void JobFlagForMigration __P((int));
@


1.7
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.h,v 1.6 1999/12/18 21:53:32 espie Exp $	*/
d222 14
a235 14
void Job_Touch __P((GNode *, Boolean));
Boolean Job_CheckCommands __P((GNode *, void (*abortProc )(char *, ...)));
void Job_CatchChildren __P((Boolean));
void Job_CatchOutput __P((void));
void Job_Make __P((GNode *));
void Job_Init __P((int, int));
Boolean Job_Full __P((void));
Boolean Job_Empty __P((void));
ReturnStatus Job_ParseShell __P((char *));
int Job_Finish __P((void));
void Job_End __P((void));
void Job_Wait __P((void));
void Job_AbortAll __P((void));
void JobFlagForMigration __P((int));
@


1.6
log
@NIL, NILGNODE, etc, are only glorified NULL.
Get rid of them.

Get rid of list.h, nothing uses it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.h,v 1.5 1998/12/05 00:06:28 espie Exp $	*/
d216 2
a217 2
extern Lst  	jobs;	    	/* List of active job descriptors */
extern Lst  	stoppedJobs;	/* List of jobs that are stopped or didn't
@


1.5
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.h,v 1.3 1996/11/30 21:08:57 millert Exp $	*/
d70 1
a70 1
 *	   completes. This is NILLNODE if there was no "..." in the job's
@


1.4
log
@Avoid possible /tmp races by using mkstemp(3).
@
text
@d231 2
a232 1
int Job_End __P((void));
@


1.3
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.h,v 1.2 1996/06/26 05:36:34 deraadt Exp $	*/
d52 1
a52 1
#define TMPPAT	"/tmp/makeXXXXX"
d133 1
a133 1
	    char  	of_outFile[sizeof(TMPPAT)+2];
@


1.2
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: job.h,v 1.4 1995/06/14 15:19:26 christos Exp $	*/
/*	$NetBSD: job.h,v 1.4 1995/06/14 15:19:26 christos Exp $	*/
d41 1
a41 1
 *	from: @@(#)job.h	5.3 (Berkeley) 6/1/90
d57 1
a57 1
 * seconds and SEL_USEC is the number of micro-seconds 
d64 1
a64 1
 * Job Table definitions. 
d85 1
a85 1
 *	   echoing, etc. for the job 
d89 1
a89 1
 * exceed the value of 'maxJobs', initialized by the Job_Init function. 
d111 1
a111 1
#define JOB_REMOTE	0x010	/* Job is running remotely */  
d199 1
a199 1
     * command-line flags 
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
