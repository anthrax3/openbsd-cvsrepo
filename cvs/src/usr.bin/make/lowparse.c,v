head	1.35;
access;
symbols
	OPENBSD_6_1:1.35.0.4
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.33.0.6
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.32.0.10
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.8
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.4
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.2
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.27.0.2
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.6
	OPENBSD_5_0:1.25.0.4
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.22.0.8
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.10
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.6
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.12
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.10
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.8
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.6
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.17.0.6
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.4
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4;
locks; strict;
comment	@ * @;


1.35
date	2016.10.21.16.12.38;	author espie;	state Exp;
branches;
next	1.34;
commitid	aLVdeKrJ0t5upS3l;

1.34
date	2015.12.05.18.31.17;	author espie;	state Exp;
branches;
next	1.33;
commitid	koV6jfRwmzsb06lm;

1.33
date	2014.11.03.12.48.37;	author espie;	state Exp;
branches;
next	1.32;
commitid	A3I26haTUGj4123Y;

1.32
date	2012.11.07.14.18.41;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2012.10.18.17.54.43;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2012.10.02.10.29.31;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2012.08.25.08.12.56;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2012.03.22.13.50.30;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2012.03.22.13.47.12;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.26.13.09.22;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.15.10.41.11;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.22.10.43.38;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.22.10.23.02;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.17.03.37.31;	author ray;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.07.13.11.36;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.29.17.29.35;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.11.12.35.02;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.11.06.02.06;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.11.01.19.23;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.18.14.49.13;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.11.12.59.43;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.29.12.53.41;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.29.12.17.05;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.23.12.34.45;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.14.12.55.48;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.07.22.57.19;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.03.13.41.07;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.24.14.27.19;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.14.13.32.07;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.17.23.54.26;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.23.16.40.50;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.23.16.39.45;	author espie;	state Exp;
branches;
next	;


desc
@@


1.35
log
@small obvious cleanups:
- remove a lot of unnecessary casts
- zap extra param that's no longer needed
- add proper prototype and make function static

okay natano@@
@
text
@/*	$OpenBSD: lowparse.c,v 1.34 2015/12/05 18:31:17 espie Exp $ */

/* low-level parsing functions. */

/*
 * Copyright (c) 1999,2000 Marc Espie.
 *
 * Extensive code changes for the OpenBSD project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <assert.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "config.h"
#include "defines.h"
#include "buf.h"
#include "lowparse.h"
#include "error.h"
#include "lst.h"
#include "memory.h"
#include "pathnames.h"
#ifndef LOCATION_TYPE
#include "location.h"
#endif
#include "var.h"


#define READ_MAKEFILES "MAKEFILE_LIST"

/* Input stream structure: file or string.
 * Files have str == NULL, F != NULL.
 * Strings have F == NULL, str != NULL.
 */
struct input_stream {
	Location origin;	/* Name of file and line number */
	FILE *F;		/* Open stream, or NULL if pure string. */
	char *str;		/* Input string, if F == NULL. */

	/* Line buffer. */
	char *ptr;		/* Where we are. */
	char *end;		/* Don't overdo it. */
};

static struct input_stream *current;	/* the input_stream being parsed. */

static LIST input_stack;	/* Stack of input_stream waiting to be parsed
				 * (includes and loop reparses) */

/* record gnode location for proper reporting at runtime */
static Location *post_parse = NULL;

/* input_stream ctors.
 *
 * obj = new_input_file(filename, filehandle);
 *	Create input stream from filename, filehandle. */
static struct input_stream *new_input_file(const char *, FILE *);
/* obj = new_input_string(str, origin);
 *	Create input stream from str, origin. */
static struct input_stream *new_input_string(char *, const Location *);
/* free_input_stream(obj);
 *	Discard consumed input stream, closing files, freeing memory.  */
static void free_input_stream(struct input_stream *);


/* Handling basic character reading.
 * c = read_char();
 *	New character c from current input stream, or EOF at end of stream. */
#define read_char()	\
    current->ptr < current->end ? *current->ptr++ : grab_new_line_and_readchar()
/* char = grab_new_line_and_readchar();
 *	Guts for read_char. Grabs a new line off fgetln when we have
 *	consumed the current line and returns the first char, or EOF at end of
 *	stream.  */
static int grab_new_line_and_readchar(void);
/* c = skip_to_end_of_line();
 *	Skips to the end of the current line, returns either '\n' or EOF.  */
static int skip_to_end_of_line(void);


/* Helper functions to handle basic parsing. */
/* read_logical_line(buffer, firstchar);
 *	Grabs logical line into buffer, the first character has already been
 *	read into firstchar.  */
static void read_logical_line(Buffer, int);

/* firstchar = ParseSkipEmptyLines(buffer);
 *	Scans lines, skipping empty lines. May put some characters into
 *	buffer, returns the first character useful to continue parsing
 *	(e.g., not a backslash or a space. */
static int skip_empty_lines_and_read_char(Buffer);

const char *curdir;
size_t curdir_len;

void
Parse_setcurdir(const char *dir)
{
	curdir = dir;
	curdir_len = strlen(dir);
}

static bool
startswith(const char *f, const char *s, size_t len)
{
	return strncmp(f, s, len) == 0 && f[len] == '/';
}

static const char *
simplify(const char *filename)
{
	if (startswith(filename, curdir, curdir_len))
		return filename + curdir_len + 1;
	else if (startswith(filename, _PATH_DEFSYSPATH,
	    sizeof(_PATH_DEFSYSPATH)-1)) {
	    	size_t sz;
		char *buf;
		sz = strlen(filename) - sizeof(_PATH_DEFSYSPATH)+3;
		buf = emalloc(sz);
		snprintf(buf, sz, "<%s>", filename+sizeof(_PATH_DEFSYSPATH));
		return buf;
	} else
		return filename;
}

static struct input_stream *
new_input_file(const char *name, FILE *stream)
{
	struct input_stream *istream;

	istream = emalloc(sizeof(*istream));
	istream->origin.fname = simplify(name);
	Var_Append(READ_MAKEFILES, name);
	istream->str = NULL;
	/* Naturally enough, we start reading at line 0. */
	istream->origin.lineno = 0;
	istream->F = stream;
	istream->ptr = istream->end = NULL;
	return istream;
}

static void
free_input_stream(struct input_stream *istream)
{
	if (istream->F) {
		if (ferror(istream->F))
			Parse_Error(PARSE_FATAL, "Read error");
		if (fileno(istream->F) != STDIN_FILENO)
			(void)fclose(istream->F);
	}
	free(istream->str);
	/* Note we can't free the file names, as they are embedded in GN
	 * for error reports. */
	free(istream);
}

static struct input_stream *
new_input_string(char *str, const Location *origin)
{
	struct input_stream *istream;

	istream = emalloc(sizeof(*istream));
	/* No malloc, name is always taken from an already existing istream
	 * and strings are used in for loops, so we need to reset the line
	 * counter to an appropriate value. */
	istream->origin = *origin;
	istream->F = NULL;
	istream->ptr = istream->str = str;
	istream->end = str + strlen(str);
	return istream;
}


void
Parse_FromString(char *str, unsigned long lineno)
{
	Location origin;
	
	origin.fname = current->origin.fname;
	origin.lineno = lineno;
	if (DEBUG(FOR))
		(void)fprintf(stderr, "%s\n----\n", str);

	Lst_Push(&input_stack, current);
	assert(current != NULL);
	current = new_input_string(str, &origin);
}


void
Parse_FromFile(const char *name, FILE *stream)
{
	if (current != NULL)
		Lst_Push(&input_stack, current);
	current = new_input_file(name, stream);
}

bool
Parse_NextFile(void)
{
	if (current != NULL)
		free_input_stream(current);
	current = Lst_Pop(&input_stack);
	return current != NULL;
}

static int
grab_new_line_and_readchar(void)
{
	size_t len;

	if (current->F) {
		current->ptr = fgetln(current->F, &len);
		if (current->ptr) {
			current->end = current->ptr + len;
			return *current->ptr++;
		} else {
			current->end = NULL;
		}
	}
	return EOF;
}

static int
skip_to_end_of_line(void)
{
	if (current->F) {
		if (current->end - current->ptr > 1)
			current->ptr = current->end - 1;
		if (*current->ptr == '\n')
			return *current->ptr++;
		return EOF;
	} else {
		int c;

		do {
			c = read_char();
		} while (c != '\n' && c != EOF);
		return c;
	}
}


char *
Parse_ReadNextConditionalLine(Buffer linebuf)
{
	int c;

	/* If first char isn't dot, skip to end of line, handling \ */
	while ((c = read_char()) != '.') {
		for (;c != '\n'; c = read_char()) {
			if (c == '\\') {
				c = read_char();
				if (c == '\n')
					current->origin.lineno++;
			}
			if (c == EOF)
				/* Unclosed conditional, reported by cond.c */
				return NULL;
		}
		current->origin.lineno++;
	}

	/* This is the line we need to copy */
	return Parse_ReadUnparsedLine(linebuf, "conditional");
}

static void
read_logical_line(Buffer linebuf, int c)
{
	for (;;) {
		if (c == '\n') {
			current->origin.lineno++;
			break;
		}
		if (c == EOF)
			break;
		Buf_AddChar(linebuf, c);
		c = read_char();
		while (c == '\\') {
			c = read_char();
			if (c == '\n') {
				Buf_AddSpace(linebuf);
				current->origin.lineno++;
				do {
					c = read_char();
				} while (c == ' ' || c == '\t');
			} else {
				Buf_AddChar(linebuf, '\\');
				if (c == '\\') {
					Buf_AddChar(linebuf, '\\');
					c = read_char();
				}
				break;
			}
		}
	}
}

char *
Parse_ReadUnparsedLine(Buffer linebuf, const char *type)
{
	int c;

	Buf_Reset(linebuf);
	c = read_char();
	if (c == EOF) {
		Parse_Error(PARSE_FATAL, "Unclosed %s", type);
		return NULL;
	}

	/* Handle '\' at beginning of line, since \\n needs special treatment */
	while (c == '\\') {
		c = read_char();
		if (c == '\n') {
			current->origin.lineno++;
			do {
				c = read_char();
			} while (c == ' ' || c == '\t');
		} else {
			Buf_AddChar(linebuf, '\\');
			if (c == '\\') {
				Buf_AddChar(linebuf, '\\');
				c = read_char();
			}
			break;
		}
	}
	read_logical_line(linebuf, c);

	return Buf_Retrieve(linebuf);
}

/* This is a fairly complex function, but without it, we could not skip
 * blocks of comments without reading them. */
static int
skip_empty_lines_and_read_char(Buffer linebuf)
{
	int c;		/* the current character */

	for (;;) {
		Buf_Reset(linebuf);
		c = read_char();
		/* Strip leading spaces, fold on '\n' */
		if (c == ' ') {
			do {
				c = read_char();
			} while (c == ' ' || c == '\t');
			while (c == '\\') {
				c = read_char();
				if (c == '\n') {
					current->origin.lineno++;
					do {
						c = read_char();
					} while (c == ' ' || c == '\t');
				} else {
					Buf_AddChar(linebuf, '\\');
					if (c == '\\') {
						Buf_AddChar(linebuf, '\\');
						c = read_char();
					}
					if (c == EOF)
						return '\n';
					else
						return c;
				}
			}
			assert(c != '\t');
		}
		if (c == '#')
			c = skip_to_end_of_line();
		/* Almost identical to spaces, except this occurs after
		 * comments have been taken care of, and we keep the tab
		 * itself.  */
		if (c == '\t') {
			Buf_AddChar(linebuf, '\t');
			do {
				c = read_char();
			} while (c == ' ' || c == '\t');
			while (c == '\\') {
				c = read_char();
				if (c == '\n') {
					current->origin.lineno++;
					do {
						c = read_char();
					} while (c == ' ' || c == '\t');
				} else {
					Buf_AddChar(linebuf, '\\');
					if (c == '\\') {
						Buf_AddChar(linebuf, '\\');
						c = read_char();
					}
					if (c == EOF)
						return '\n';
					else
						return c;
				}
			}
		}
		if (c == '\n')
			current->origin.lineno++;
		else
			return c;
	}
}

/* Parse_ReadNormalLine removes beginning and trailing blanks (but keeps
 * the first tab), handles escaped newlines, and skips over uninteresting
 * lines.
 *
 * The line number is incremented, which implies that continuation
 * lines are numbered with the last line number (we could do better, at a
 * price).
 *
 * Trivial comments are also removed, but we can't do more, as
 * we don't know which lines are shell commands or not.  */
char *
Parse_ReadNormalLine(Buffer linebuf)
{
	int c;		/* the current character */

	c = skip_empty_lines_and_read_char(linebuf);

	if (c == EOF)
		return NULL;
	else {
		read_logical_line(linebuf, c);
		return Buf_Retrieve(linebuf);
	}
}

unsigned long
Parse_Getlineno(void)
{
	return current ? current->origin.lineno : 0;
}

const char *
Parse_Getfilename(void)
{
	return current ? current->origin.fname : NULL;
}

void
Parse_SetLocation(Location *origin)
{
	post_parse = origin;
}

void
Parse_FillLocation(Location *origin)
{
	if (post_parse) {
		*origin = *post_parse;
	} else {
		origin->lineno = Parse_Getlineno();
		origin->fname = Parse_Getfilename();
	}
}

void
Parse_ReportErrors(void)
{
	if (fatal_errors)
		exit(1);
	else
		assert(current == NULL);
}
@


1.34
log
@yet another feof check, just to be sure.
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.33 2014/11/03 12:48:37 espie Exp $ */
d226 1
a226 1
	current = (struct input_stream *)Lst_Pop(&input_stack);
@


1.33
log
@introspection feature: ${MAKEFILE_LIST} contains the list of makefiles
parsed.

name stolen from gmake, from a suggestion from guenther@@, to avoid
gratuitous confusin.

okay guenther@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.32 2012/11/07 14:18:41 espie Exp $ */
d168 6
a173 2
	if (istream->F && fileno(istream->F) != STDIN_FILENO)
		(void)fclose(istream->F);
@


1.32
log
@say goodbye to killing trailing spaces.
this was yet another weirdness in our make that isn't shared by
other makes, and that isn't part of any standard.
This means end-of-line spaces in variables ARE significant (spaces
around the equal sign still aren't).

okay sthen@@, "sounds fine" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.31 2012/10/18 17:54:43 espie Exp $ */
d49 1
d52 1
a52 6
/* XXX check whether we can free filenames at the end, for a proper
 * definition of `end'. */

#if 0
static LIST	    fileNames;	/* file names to free at end */
#endif
d137 1
a137 1
	else if (startswith(filename, _PATH_DEFSYSPATH, 
a152 3
#if 0
	Lst_AtEnd(&fileNames, name);
#endif
d156 1
d171 1
a171 1
	/* Note we can't free the file names yet, as they are embedded in GN
d183 2
a184 2
	 * and strings are used in for loops, so we need to reset the line counter
         * to an appropriate value. */
@


1.31
log
@numerous error message fixes:
- do ^C checking differently: don't record sent signals, but when jobs
die, recheck whether we received/have pending a INT/QUIT/TERM/HUP signal.
Then don't display our process group "normally", instead group together
everything dying by signal/shell dying by signal (just give the target
names).

- make certain we always handle signals before dying from "other conditions"
- have the parser messages look more like normal messages
- remove double error messages from some parser errors
- make sure unclosed variables ARE errors when some modifiers are present

- keep track of the base directory we're run from, so that submakes can
get shortened directories...
- make sure the whole error message including silent command fits into a
reasonable length.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.30 2012/10/02 10:29:31 espie Exp $ */
a452 1
		Buf_KillTrailingSpaces(linebuf);
@


1.30
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.29 2012/09/21 07:55:20 espie Exp $ */
d282 2
a283 3
			if (c == EOF) {
				Parse_Error(PARSE_FATAL,
				    "Unclosed conditional");
a284 1
			}
d490 1
a490 3
	if (fatal_errors) {
		fprintf(stderr,
		    "Fatal errors encountered -- cannot continue\n");
d492 1
a492 1
	} else
@


1.29
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.28 2012/08/25 08:12:56 espie Exp $ */
d45 1
d130 6
d139 1
a139 2
	if (strncmp(curdir, filename, curdir_len) == 0 && 
	    filename[curdir_len] == '/')
d141 9
a149 1
	else
a488 19
#ifdef CLEANUP
void
LowParse_Init(void)
{
	Static_Lst_Init(&input_stack);
	current = NULL;
}

void
LowParse_End(void)
{
	Lst_Destroy(&input_stack, NOFREE);	/* Should be empty now */
#if 0
	Lst_Destroy(&fileNames, (SimpleProc)free);
#endif
}
#endif


a492 4
#ifdef CLEANUP
		while (Parse_NextFile())
			;
#endif
@


1.28
log
@- make wrong variable specs (unterminated) parse errors.
- add info to be able to pinpoint parse errors at runtime.
- let job runners abort when a parse error happens while expanding a variable
during execution
- fix an infinite loop when compiling without FEATURE_RECVARS.

okay millert@@, krw@@
the very few errors found out by this (less than 10 over src/X/ports)
fixed trivially beforehand, as requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.27 2012/03/22 13:50:30 espie Exp $ */
d119 20
d148 1
a148 1
	istream->origin.fname = name;
@


1.27
log
@tweak: consistent include guards, no change in generated code.
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.26 2012/03/22 13:47:12 espie Exp $ */
d76 3
d439 6
d447 6
a452 2
	origin->lineno = Parse_Getlineno();
	origin->fname = Parse_Getfilename();
@


1.26
log
@minor cleanup: error messages include lineno and fileno together, so
recognize that and create a struct Location_ for it.

mostly from Jonathan Calmels, a few nits from me.

okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.25 2010/12/26 13:09:22 espie Exp $ */
d45 1
d47 1
@


1.25
log
@nits with current being NULL or not.
okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.24 2010/07/19 19:46:44 espie Exp $ */
d45 2
d60 1
a60 2
	const char *fname; 	/* Name of file */
	unsigned long lineno; 	/* Line number */
d79 3
a81 3
/* obj = new_input_string(str, filename, lineno);
 *	Create input stream from str, filename, lineno. */
static struct input_stream *new_input_string(char *, const char *, unsigned long);
d123 1
a123 1
	istream->fname = name;
d126 1
a126 1
	istream->lineno = 0;
d144 1
a144 1
new_input_string(char *str, const char *name, unsigned long lineno)
d149 4
a152 2
	/* No malloc, name is always taken from an already existing istream */
	istream->fname = name;
a153 3
	/* Strings are used in for loops, so we need to reset the line counter
	 * to an appropriate value. */
	istream->lineno = lineno;
d163 4
d172 1
a172 1
	current = new_input_string(str, current->fname, lineno);
d241 1
a241 1
					current->lineno++;
d249 1
a249 1
		current->lineno++;
d261 1
a261 1
			current->lineno++;
d272 1
a272 1
				current->lineno++;
d304 1
a304 1
			current->lineno++;
d340 1
a340 1
					current->lineno++;
d371 1
a371 1
					current->lineno++;
d389 1
a389 1
			current->lineno++;
d424 1
a424 1
	return current ? current->lineno : 0;
d430 8
a437 1
	return current ? current->fname : NULL;
@


1.24
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.23 2010/07/15 10:41:11 espie Exp $ */
d166 2
a167 2
	if (current != NULL)
		Lst_Push(&input_stack, current);
@


1.23
log
@whitespace
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$ */
@


1.22
log
@rename functions and data structures for clarity
@
text
@d241 1
a241 1
				Parse_Error(PARSE_FATAL, 
d457 1
a457 1
		fprintf(stderr, 
@


1.21
log
@reindent
@
text
@d54 5
a58 2
/* Input stream structure, file or string. */
typedef struct {
d67 1
a67 1
} IFile;
d69 1
a69 1
static IFile *current;		/* IFile being parsed. */
d71 1
a71 1
static LIST input_stack;	/* Stack of IFiles waiting to be parsed
d74 1
a74 1
/* IFile ctors.
d76 9
a84 9
 * obj = new_ifile(filename, filehandle);
 *	Create input object from filename, filehandle. */
static IFile *new_ifile(const char *, FILE *);
/* obj = new_istring(str, filename, lineno);
 *	Create input object from str, filename, lineno. */
static IFile *new_istring(char *, const char *, unsigned long);
/* free_ifile(obj);
 *	Discard consumed input object, closing streams, freeing memory.  */
static void free_ifile(IFile *);
d88 1
a88 1
 * c = ParseReadc();
d90 5
a94 5
#define ParseReadc()	\
    current->ptr < current->end ? *current->ptr++ : newline()
/* len = newline();
 *	Guts for ParseReadc. Grabs a new line off fgetln when we have
 *	consumed the current line and returns its length. Or EOF at end of
d96 2
a97 2
static int newline(void);
/* c = skiptoendofline();
d99 1
a99 1
static int skiptoendofline(void);
d103 1
a103 1
/* ParseFoldLF(buffer, firstchar);
d106 1
a106 1
static void ParseFoldLF(Buffer, int);
d112 1
a112 1
static int ParseSkipEmptyLines(Buffer);
d114 2
a115 2
static IFile *
new_ifile(const char *name, FILE *stream)
d117 1
a117 1
	IFile *ifile;
d122 3
a124 3
	ifile = emalloc(sizeof(*ifile));
	ifile->fname = name;
	ifile->str = NULL;
d126 4
a129 4
	ifile->lineno = 0;
	ifile->F = stream;
	ifile->ptr = ifile->end = NULL;
	return ifile;
d133 1
a133 1
free_ifile(IFile *ifile)
d135 3
a137 3
	if (ifile->F && fileno(ifile->F) != STDIN_FILENO)
		(void)fclose(ifile->F);
	free(ifile->str);
d140 1
a140 1
	free(ifile);
d143 2
a144 2
static IFile *
new_istring(char *str, const char *name, unsigned long lineno)
d146 1
a146 1
	IFile *ifile;
d148 4
a151 4
	ifile = emalloc(sizeof(*ifile));
	/* No malloc, name is always taken from an already existing ifile */
	ifile->fname = name;
	ifile->F = NULL;
d154 4
a157 4
	ifile->lineno = lineno;
	ifile->ptr = ifile->str = str;
	ifile->end = str + strlen(str);
	return ifile;
d169 1
a169 1
	current = new_istring(str, current->fname, lineno);
d178 1
a178 1
	current = new_ifile(name, stream);
d185 2
a186 2
		free_ifile(current);
	current = (IFile *)Lst_Pop(&input_stack);
d191 1
a191 1
newline(void)
d208 1
a208 1
skiptoendofline(void)
d220 1
a220 1
			c = ParseReadc();
d233 2
a234 2
	while ((c = ParseReadc()) != '.') {
		for (;c != '\n'; c = ParseReadc()) {
d236 1
a236 1
				c = ParseReadc();
d254 1
a254 1
ParseFoldLF(Buffer linebuf, int c)
d264 1
a264 1
		c = ParseReadc();
d266 1
a266 1
			c = ParseReadc();
d271 1
a271 1
					c = ParseReadc();
d277 1
a277 1
					c = ParseReadc();
d291 1
a291 1
	c = ParseReadc();
d299 1
a299 1
		c = ParseReadc();
d303 1
a303 1
				c = ParseReadc();
d309 1
a309 1
				c = ParseReadc();
d314 1
a314 1
	ParseFoldLF(linebuf, c);
d322 1
a322 1
ParseSkipEmptyLines(Buffer linebuf)
d328 1
a328 1
		c = ParseReadc();
d332 1
a332 1
				c = ParseReadc();
d335 1
a335 1
				c = ParseReadc();
d339 1
a339 1
						c = ParseReadc();
d345 1
a345 1
						c = ParseReadc();
d356 1
a356 1
			c = skiptoendofline();
d363 1
a363 1
				c = ParseReadc();
d366 1
a366 1
				c = ParseReadc();
d370 1
a370 1
						c = ParseReadc();
d376 1
a376 1
						c = ParseReadc();
d407 1
a407 1
	c = ParseSkipEmptyLines(linebuf);
d412 1
a412 1
		ParseFoldLF(linebuf, c);
@


1.20
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: lowparse.c,v 1.19 2007/05/17 03:37:31 ray Exp $ */
d56 8
a63 8
    const char		*fname; /* Name of file */
    unsigned long	lineno; /* Line number */
    FILE		*F;	/* Open stream, or NULL if pure string. */
    char		*str;	/* Input string, if F == NULL. */

    /* Line buffer. */
    char		*ptr;	/* Where we are. */
    char		*end;	/* Don't overdo it. */
d66 1
a66 1
static IFile	*current;	/* IFile being parsed. */
d68 1
a68 1
static LIST	input_stack;	/* Stack of IFiles waiting to be parsed
d87 2
a88 1
#define ParseReadc()	current->ptr < current->end ? *current->ptr++ : newline()
d114 1
a114 1
    IFile *ifile;
d116 1
a116 1
    Lst_AtEnd(&fileNames, name);
d119 8
a126 8
    ifile = emalloc(sizeof(*ifile));
    ifile->fname = name;
    ifile->str = NULL;
    /* Naturally enough, we start reading at line 0. */
    ifile->lineno = 0;
    ifile->F = stream;
    ifile->ptr = ifile->end = NULL;
    return ifile;
d132 6
a137 6
    if (ifile->F && fileno(ifile->F) != STDIN_FILENO)
	(void)fclose(ifile->F);
    free(ifile->str);
    /* Note we can't free the file names yet, as they are embedded in GN for
     * error reports. */
    free(ifile);
d143 1
a143 1
    IFile *ifile;
d145 10
a154 10
    ifile = emalloc(sizeof(*ifile));
    /* No malloc, name is always taken from an already existing ifile */
    ifile->fname = name;
    ifile->F = NULL;
    /* Strings are used in for loops, so we need to reset the line counter
     * to an appropriate value. */
    ifile->lineno = lineno;
    ifile->ptr = ifile->str = str;
    ifile->end = str + strlen(str);
    return ifile;
d161 2
a162 2
    if (DEBUG(FOR))
	(void)fprintf(stderr, "%s\n----\n", str);
d164 3
a166 3
    if (current != NULL)
	Lst_Push(&input_stack, current);
    current = new_istring(str, current->fname, lineno);
d173 3
a175 3
    if (current != NULL)
	Lst_Push(&input_stack, current);
    current = new_ifile(name, stream);
d181 4
a184 4
    if (current != NULL)
	free_ifile(current);
    current = (IFile *)Lst_Pop(&input_stack);
    return current != NULL;
d190 1
a190 1
    size_t len;
d192 8
a199 7
    if (current->F) {
	current->ptr = fgetln(current->F, &len);
	if (current->ptr) {
	    current->end = current->ptr + len;
	    return *current->ptr++;
	} else {
	    current->end = NULL;
d201 1
a201 2
    }
    return EOF;
d207 8
a214 8
    if (current->F) {
	if (current->end - current->ptr > 1)
	    current->ptr = current->end - 1;
	if (*current->ptr == '\n')
	    return *current->ptr++;
	return EOF;
    } else {
	int c;
d216 5
a220 5
	do {
	    c = ParseReadc();
	} while (c != '\n' && c != EOF);
	return c;
    }
d227 1
a227 1
    int c;
d230 14
a243 11
    while ((c = ParseReadc()) != '.') {
	for (;c != '\n'; c = ParseReadc()) {
	    if (c == '\\') {
		c = ParseReadc();
		if (c == '\n')
		    current->lineno++;
	    }
	    if (c == EOF) {
		Parse_Error(PARSE_FATAL, "Unclosed conditional");
		return NULL;
	    }
a244 2
	current->lineno++;
    }
d247 1
a247 1
    return Parse_ReadUnparsedLine(linebuf, "conditional");
d253 25
a277 22
    for (;;) {
	if (c == '\n') {
	    current->lineno++;
	    break;
	}
	if (c == EOF)
	    break;
	Buf_AddChar(linebuf, c);
	c = ParseReadc();
	while (c == '\\') {
	    c = ParseReadc();
	    if (c == '\n') {
		Buf_AddSpace(linebuf);
		current->lineno++;
		do {
		    c = ParseReadc();
		} while (c == ' ' || c == '\t');
	    } else {
		Buf_AddChar(linebuf, '\\');
		if (c == '\\') {
		    Buf_AddChar(linebuf, '\\');
		    c = ParseReadc();
a278 2
		break;
	    }
a279 1
    }
d285 1
a285 1
    int c;
d287 6
a292 6
    Buf_Reset(linebuf);
    c = ParseReadc();
    if (c == EOF) {
	Parse_Error(PARSE_FATAL, "Unclosed %s", type);
	return NULL;
    }
d294 2
a295 6
    /* Handle '\' at beginning of line, since \\n needs special treatment */
    while (c == '\\') {
	c = ParseReadc();
	if (c == '\n') {
	    current->lineno++;
	    do {
d297 13
a309 8
	    } while (c == ' ' || c == '\t');
	} else {
	    Buf_AddChar(linebuf, '\\');
	    if (c == '\\') {
		Buf_AddChar(linebuf, '\\');
		c = ParseReadc();
	    }
	    break;
d311 1
a311 2
    }
    ParseFoldLF(linebuf, c);
d313 1
a313 1
    return Buf_Retrieve(linebuf);
d321 1
a321 1
    int 	c;		/* the current character */
d323 2
a324 6
    for (;;) {
	Buf_Reset(linebuf);
	c = ParseReadc();
	/* Strip leading spaces, fold on '\n' */
	if (c == ' ') {
	    do {
d326 55
a380 18
	    } while (c == ' ' || c == '\t');
	    while (c == '\\') {
		c = ParseReadc();
		if (c == '\n') {
		    current->lineno++;
		    do {
			c = ParseReadc();
		    } while (c == ' ' || c == '\t');
		} else {
		    Buf_AddChar(linebuf, '\\');
		    if (c == '\\') {
			Buf_AddChar(linebuf, '\\');
			c = ParseReadc();
		    }
		    if (c == EOF)
			return '\n';
		    else
			return c;
d382 3
a384 28
	    }
	    assert(c != '\t');
	}
	if (c == '#')
	    c = skiptoendofline();
	/* Almost identical to spaces, except this occurs after comments
	 * have been taken care of, and we keep the tab itself.  */
	if (c == '\t') {
	    Buf_AddChar(linebuf, '\t');
	    do {
		c = ParseReadc();
	    } while (c == ' ' || c == '\t');
	    while (c == '\\') {
		c = ParseReadc();
		if (c == '\n') {
		    current->lineno++;
		    do {
			c = ParseReadc();
		    } while (c == ' ' || c == '\t');
		} else {
		    Buf_AddChar(linebuf, '\\');
		    if (c == '\\') {
			Buf_AddChar(linebuf, '\\');
			c = ParseReadc();
		    }
		    if (c == EOF)
			return '\n';
		    else
a385 2
		}
	    }
a386 5
	if (c == '\n')
	    current->lineno++;
	else
	    return c;
    }
d402 1
a402 1
    int 	c;		/* the current character */
d404 1
a404 1
    c = ParseSkipEmptyLines(linebuf);
d406 7
a412 7
    if (c == EOF)
	return NULL;
    else {
	ParseFoldLF(linebuf, c);
	Buf_KillTrailingSpaces(linebuf);
	return Buf_Retrieve(linebuf);
    }
d418 1
a418 1
    return current ? current->lineno : 0;
d424 1
a424 1
    return current ? current->fname : NULL;
d431 2
a432 2
    Static_Lst_Init(&input_stack);
    current = NULL;
d438 1
a438 1
    Lst_Destroy(&input_stack, NOFREE);	/* Should be empty now */
d440 1
a440 1
    Lst_Destroy(&fileNames, (SimpleProc)free);
d449 1
a449 1
    if (fatal_errors) {
d451 2
a452 2
	while (Parse_NextFile())
		;
d454 5
a458 4
	fprintf(stderr, "Fatal errors encountered -- cannot continue\n");
	exit(1);
    } else
    	assert(current == NULL);
@


1.19
log
@Remove extra return statement, from tbert from lint.

OK jaredy@@ and moritz@@
@
text
@d2 1
a2 1
/*	$OpenBSD: lowparse.c,v 1.18 2004/04/07 13:11:36 espie Exp $ */
d68 1
a68 1
static LIST	input_stack;	/* Stack of IFiles waiting to be parsed 
d71 1
a71 1
/* IFile ctors. 
d84 1
a84 1
/* Handling basic character reading. 
d388 1
a388 1
 * lines.  
@


1.18
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: lowparse.c,v 1.17 2002/12/29 17:29:35 espie Exp $ */
a375 1
		    return c;
@


1.17
log
@check -DCLEANUP compilation
@
text
@d2 1
a2 1
/*	$OpenBSD: lowparse.c,v 1.16 2001/11/11 12:35:02 espie Exp $ */
d111 1
a111 3
new_ifile(name, stream)
    const char *name;
    FILE *stream;
d129 1
a129 2
free_ifile(ifile)
    IFile *ifile;
d140 1
a140 4
new_istring(str, name, lineno)
    char *str;
    const char *name;
    unsigned long lineno;
d158 1
a158 3
Parse_FromString(str, lineno)
    char		*str;
    unsigned long	lineno;
d170 1
a170 3
Parse_FromFile(name, stream)
    const char		*name;
    FILE		*stream;
d178 1
a178 1
Parse_NextFile()
d187 1
a187 1
newline()
d204 1
a204 1
skiptoendofline()
d224 1
a224 2
Parse_ReadNextConditionalLine(linebuf)
    Buffer linebuf;
d249 1
a249 3
ParseFoldLF(linebuf, c)
    Buffer linebuf;
    int c;
d281 1
a281 3
Parse_ReadUnparsedLine(linebuf, type)
    Buffer	linebuf;
    const char	*type;
d317 1
a317 2
ParseSkipEmptyLines(linebuf)
    Buffer	linebuf;
d388 1
a388 1
 * the first tab), handles escaped newlines, and skip over uninteresting
d391 2
a392 2
 * The line number is advanced, which implies that continuation
 * lines are numbered with the last line no (we could do better, at a
d398 1
a398 2
Parse_ReadNormalLine(linebuf)
    Buffer	linebuf;
d414 1
a414 1
Parse_Getlineno()
d420 1
a420 1
Parse_Getfilename()
d427 1
a427 1
LowParse_Init()
d434 1
a434 1
LowParse_End()
d445 1
a445 1
Parse_ReportErrors()
@


1.16
log
@Fixed version... don't see how this could work on i386, since it didn't
initialize create in main.c.
@
text
@d2 1
a2 1
/*	$OpenBSD: lowparse.c,v 1.15 2001/11/11 06:02:06 deraadt Exp $ */
d454 1
a454 1
#ifdef 0
@


1.15
log
@undo changes that crash on (at least) the alpha
@
text
@d2 1
a2 1
/*	$OpenBSD: lowparse.c,v 1.13 2001/07/18 14:49:13 espie Exp $ */
d446 1
a446 1
    Lst_Init(&input_stack);
@


1.14
log
@Redo LstInit as a macro: smaller and faster code in all cases, zeroing two
pointers is simpler than calling a function.
Recognize purely static lst headers, which don't really need any
initialization.
ok miod@@
@
text
@d446 1
a446 1
    Static_Lst_Init(&input_stack);
@


1.13
log
@Avoid dumping core when reporting open conditionals.
Turns out that current is NULL when Parse_Fatal is called in this case,
so just do something sensible in error reporting functions when current is
NULL...
@
text
@d2 1
a2 1
/*	$OpenBSD: lowparse.c,v 1.12 2001/07/11 12:59:43 espie Exp $ */
d446 1
a446 1
    Lst_Init(&input_stack);
@


1.12
log
@Typo in comment
@
text
@d2 1
a2 1
/*	$OpenBSD: lowparse.c,v 1.11 2001/05/29 12:53:41 espie Exp $ */
d433 1
a433 1
    return current->lineno;
d439 1
a439 1
    return current->fname;
@


1.11
log
@Take includes out of lst.h, re-add what's needed to separate files.
Removes remaining lint stuff from lst.lib.
@
text
@d2 1
a2 1
/*	$OpenBSD: lowparse.c,v 1.10 2001/05/29 12:17:05 espie Exp $ */
d404 1
a404 1
 * the first tab), handles escaped newlinews, and skip over uninteresting
@


1.10
log
@Blech! gcc is a stupid program. Compiling with -fno-builtin shows lots
of missing function declarations.
@
text
@d2 1
a2 1
/*	$OpenBSD: lowparse.c,v 1.9 2001/05/23 12:34:45 espie Exp $ */
d36 1
@


1.9
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d36 1
@


1.8
log
@Ensure IFile str is always intialized, so that we can free it without
problems.

Bug found by wilfried@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: lowparse.c,v 1.7 2001/05/07 22:57:19 espie Exp $ */
d33 2
a34 1
#include <stdarg.h>
d36 3
a38 2
#include <assert.h>
#include "make.h"
d41 6
d48 1
a48 1
#ifdef CLEANUP
d52 10
a61 8
/* Definitions for handling #include specifications */
typedef struct IFile_ {
    char		*fname; /* name of file */
    unsigned long	lineno; /* line number */
    FILE		*F;	/* open stream */
    char		*str;	/* read from char area */
    char		*ptr;	/* where we are */
    char		*end;	/* don't overdo it */
d64 1
a64 1
static IFile	*current;
d66 2
a67 2
static LIST	includes;	/* stack of IFiles generated by
				 * #includes */
d69 10
a78 2
static IFile *new_ifile(char *, FILE *);
static IFile *new_istring(char *, char *, unsigned long);
d80 10
a89 1
static void ParseVErrorInternal(char *, unsigned long, int, char *, va_list);
d91 2
a93 3
static void ParseFoldLF(Buffer, int);
static int ParseSkipEmptyLines(Buffer);
static int	    fatals = 0;
a94 28
/*-
 * ParseVErrorInternal	--
 *	Error message abort function for parsing. Prints out the context
 *	of the error (line number and file) as well as the message with
 *	two optional arguments.
 *
 * Side Effects:
 *	"fatals" is incremented if the level is PARSE_FATAL.
 */
/* VARARGS */
static void
#ifdef __STDC__
ParseVErrorInternal(char *cfname, unsigned long clineno, int type, char *fmt,
    va_list ap)
#else
ParseVErrorInternal(va_alist)
	va_dcl
#endif
{
	(void)fprintf(stderr, "\"%s\", line %lu: ", cfname, clineno);
	if (type == PARSE_WARNING)
		(void)fprintf(stderr, "warning: ");
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
	if (type == PARSE_FATAL)
		fatals ++;
}
d96 5
a100 25
/*-
 * Parse_Error	--
 *	External interface to ParseVErrorInternal; uses the default filename
 *	Line number.
 */
/* VARARGS */
void
#ifdef __STDC__
Parse_Error(int type, char *fmt, ...)
#else
Parse_Error(va_alist)
	va_dcl
#endif
{
	va_list ap;
#ifdef __STDC__
	va_start(ap, fmt);
#else
	int type;		/* Error type (PARSE_WARNING, PARSE_FATAL) */
	char *fmt;

	va_start(ap);
	type = va_arg(ap, int);
	fmt = va_arg(ap, char *);
#endif
d102 5
a106 2
	ParseVErrorInternal(current->fname, current->lineno, type, fmt, ap);
}
d110 1
a110 1
    char *name;
d114 1
a114 1
#ifdef CLEANUP
d121 1
a121 1
    /* Naturally enough, we start reading at line 0 */
d143 1
a143 1
    char *name;
d152 2
a153 1
    /* Strings are used from for loops... */
a160 10
/*-
 *---------------------------------------------------------------------
 * Parse_FromString  --
 *	Start Parsing from the given string
 *
 * Side Effects:
 *	A structure is added to the includes Lst and readProc, lineno,
 *	fname and curFILE are altered for the new file
 *---------------------------------------------------------------------
 */
d170 1
a170 1
	Lst_AtFront(&includes, current);
d177 1
a177 1
    char		*name;
d181 1
a181 1
	Lst_AtFront(&includes, current);
d185 1
a185 16
/*-
 *---------------------------------------------------------------------
 * Parse_NextFile --
 *	Called when EOF is reached in the current file. If we were reading
 *	an include file, the includes stack is popped and things set up
 *	to go back to reading the previous file at the previous location.
 *
 * Results:
 *	CONTINUE if there's more to do. DONE if not.
 *
 * Side Effects:
 *	The old curFILE, is closed. The includes list is shortened.
 *	lineno, curFILE, and fname are changed if CONTINUE is returned.
 *---------------------------------------------------------------------
 */
Boolean
d188 4
a191 10
    IFile *next;

    next = (IFile *)Lst_DeQueue(&includes);
    if (next != NULL) {
	if (current != NULL)
	    free_ifile(current);
	current = next;
	return TRUE;
    } else
	return FALSE;
a193 1
/* guts for ParseReadc. Grab a new line off fgetln when we hit "\n" */
a210 4
#define ParseReadc()	current->ptr < current->end ? *current->ptr++ : newline()

/* Take advantage of fgetln: we don't have to scan a whole line to skip it.
 */
a230 3
/* ParseSkipGetLine():
 *	Return the first logical line that starts with '.'
 */
d232 1
a232 1
ParseSkipGetLine(linebuf)
d254 1
a254 1
    return ParseGetLine(linebuf, "conditional");
a256 2
/* Grab logical line into linebuf.
 * The first character is already in c. */
a290 3
/* ParseGetLine:
 *	Simply get line, no parsing beyond \
 */
d292 1
a292 1
ParseGetLine(linebuf, type)
d327 2
a328 4
/* Skip all empty lines, and return the first `useful' character.
 * (This does skip blocks of comments at high speed, which justifies
 * the complexity of the function.)
 */
d401 3
a403 4
/*-
 *---------------------------------------------------------------------
 * ParseReadLine --
 *	Read an entire line from the input file.
d405 3
a407 2
 * Results:
 *	A line without a new line, or NULL at EOF.
d409 2
a410 8
 * Notes:
 *	Removes beginning and trailing blanks (but keeps first tab).
 *	Updates line numbers, handles escaped newlines, and skip over
 *	uninteresting lines.
 *	All but trivial comments can't be handled at this point, because we
 *	don't know yet which lines are shell commands or not.
 *---------------------------------------------------------------------
 */
d412 1
a412 1
ParseReadLine(linebuf)
d444 1
a444 1
    Lst_Init(&includes);
d451 4
a454 1
    Lst_Destroy(&includes, NOFREE);	/* Should be empty now */
d460 1
a460 1
Finish_Errors()
d462 5
a466 5
    if (current != NULL) {
	free_ifile(current);
	current = NULL;
    }
    if (fatals) {
d469 2
a470 1
    }
@


1.7
log
@avoid closing the same file twice. parse module assumes ownership of
file handles it's passed to.

(this is apparently harmless on BSDs, but is still a bug).
@
text
@d2 1
a2 1
/*	$OpenBSD: lowparse.c,v 1.6 2001/05/03 13:41:07 espie Exp $ */
d139 1
d153 1
a153 2
    else
	free(ifile->str);
@


1.6
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d150 1
a150 1
    if (ifile->F)
@


1.5
log
@Clean-ups:
* Buf_Destroy can be a macro
* X_ instead of _X for struct names, to avoid infringing on the system's
namespace.
* better wildcard detection heuristics
* fix #ifdef CLEANUP code
* a few comments
@
text
@d1 2
a2 1
/*	$OpenBSD: lowparse.c,v 1.4 2000/09/14 13:32:07 espie Exp $ */
d46 6
a51 6
    char           	*fname;	/* name of file */
    unsigned long      	lineno;	/* line number */
    FILE 		*F;	/* open stream */
    char 		*str;	/* read from char area */	
    char 		*ptr;	/* where we are */
    char 		*end;	/* don't overdo it */
d56 1
a56 3


static LIST     includes;  	/* stack of IFiles generated by
d59 8
a66 7
static IFile *new_ifile __P((char *, FILE *));
static IFile *new_istring __P((char *, char *, unsigned long));
static void free_ifile __P((IFile *));
static void ParseVErrorInternal __P((char *, unsigned long, int, char *, va_list));
static int newline __P((void));
#define ParseReadc()	current->ptr < current->end ? *current->ptr++ : newline()
static void ParseUnreadc __P((char));
d70 1
a70 1
 * ParseVErrorInternal  --
d99 1
a99 1
 * Parse_Error  --
d151 1
a151 1
    	(void)fclose(ifile->F);
d153 1
a153 1
    	free(ifile->str);
d168 1
a168 1
    /* No malloc, name is always taken from an existing ifile */
d191 2
a192 2
    char 		*str;
    unsigned long 	lineno;
d203 1
a203 1
void 
d209 1
a209 1
    	Lst_AtFront(&includes, current);
d215 1
a215 1
 * Parse_NextFile -- 
d238 1
a238 1
    	return TRUE;
d240 1
a240 1
    	return FALSE;
a242 1

d261 6
a266 3
void 
ParseUnreadc(c)
	char c;
d268 14
a281 2
	current->ptr--;
	*current->ptr = c;
d284 3
a286 2
/* ParseSkipLine():
 *	Grab the next line
d289 2
a290 2
ParseSkipLine(skip)
    int skip; 		/* Skip lines that don't start with . */
d292 17
a308 3
    char *line;
    int c, lastc;
    BUFFER buf;
d310 3
a312 1
    Buf_Init(&buf, MAKE_BSIZE);
d314 7
d322 2
a323 23
        Buf_Reset(&buf);
        lastc = '\0';

        while (((c = ParseReadc()) != '\n' || lastc == '\\')
               && c != EOF) {
            if (c == '\n') {
                Buf_ReplaceLastChar(&buf, ' ');
                current->lineno++;

                while ((c = ParseReadc()) == ' ' || c == '\t');

                if (c == EOF)
                    break;
            }

            Buf_AddChar(&buf, c);
            lastc = c;
        }

        line = Buf_Retrieve(&buf);
        current->lineno++;
	    /* allow for non-newline terminated lines while skipping */
	if (line[0] == '.')
d325 2
a326 7

        if (c == EOF) {
            Parse_Error(PARSE_FATAL, "Unclosed conditional/for loop");
            Buf_Destroy(&buf);
            return NULL;
        }
	if (skip == 0)
d328 19
a346 1

a347 2

    return line;
d350 2
a351 17

/*-
 *---------------------------------------------------------------------
 * ParseReadLine --
 *	Read an entire line from the input file. Called only by Parse_File.
 *	To facilitate escaped newlines and what have you, a character is
 *	buffered in 'lastc', which is '\0' when no characters have been
 *	read. When we break out of the loop, c holds the terminating
 *	character and lastc holds a character that should be added to
 *	the line (unless we don't read anything but a terminator).
 *
 * Results:
 *	A line w/o its newline
 *
 * Side Effects:
 *	Only those associated with reading a character
 *---------------------------------------------------------------------
d354 15
a368 25
ParseReadLine ()
{
    BUFFER  	  buf;	    	/* Buffer for current line */
    register int  c;	      	/* the current character */
    register int  lastc;    	/* The most-recent character */
    Boolean	  semiNL;     	/* treat semi-colons as newlines */
    Boolean	  ignDepOp;   	/* TRUE if should ignore dependency operators
				 * for the purposes of setting semiNL */
    Boolean 	  ignComment;	/* TRUE if should ignore comments (in a
				 * shell command */
    char 	  *line;    	/* Result */
    char          *ep;		/* to strip trailing blanks */

    semiNL = FALSE;
    ignDepOp = FALSE;
    ignComment = FALSE;

    /*
     * Handle special-characters at the beginning of the line. Either a
     * leading tab (shell command) or pound-sign (possible conditional)
     * forces us to ignore comments and dependency operators and treat
     * semi-colons as semi-colons (by leaving semiNL FALSE). This also
     * discards completely blank lines.
     */
    for (;;) {
d370 1
a370 5

	if (c == '\t') {
	    ignComment = ignDepOp = TRUE;
	    break;
	} else if (c == '\n') {
d372 3
a374 3
	} else if (c == '#') {
	    ParseUnreadc(c);
	    break;
d376 5
a380 3
	    /*
	     * Anything else breaks out without doing anything
	     */
d384 14
d399 15
a413 25
    if (c != EOF) {
	lastc = c;
	Buf_Init(&buf, MAKE_BSIZE);

	while (((c = ParseReadc ()) != '\n' || (lastc == '\\')) &&
	       (c != EOF))
	{
test_char:
	    switch(c) {
	    case '\n':
		/*
		 * Escaped newline: read characters until a non-space or an
		 * unescaped newline and replace them all by a single space.
		 * This is done by storing the space over the backslash and
		 * dropping through with the next nonspace. If it is a
		 * semi-colon and semiNL is TRUE, it will be recognized as a
		 * newline in the code below this...
		 */
		current->lineno++;
		lastc = ' ';
		while ((c = ParseReadc ()) == ' ' || c == '\t') {
		    continue;
		}
		if (c == EOF || c == '\n') {
		    goto line_read;
d415 4
a418 72
		    /*
		     * Check for comments, semiNL's, etc. -- easier than
		     * ParseUnreadc(c); continue;
		     */
		    goto test_char;
		}
		/*NOTREACHED*/
		break;

	    case ';':
		/*
		 * Semi-colon: Need to see if it should be interpreted as a
		 * newline
		 */
		if (semiNL) {
		    /*
		     * To make sure the command that may be following this
		     * semi-colon begins with a tab, we push one back into the
		     * input stream. This will overwrite the semi-colon in the
		     * buffer. If there is no command following, this does no
		     * harm, since the newline remains in the buffer and the
		     * whole line is ignored.
		     */
		    ParseUnreadc('\t');
		    goto line_read;
		}
		break;
	    case '=':
		if (!semiNL) {
		    /*
		     * Haven't seen a dependency operator before this, so this
		     * must be a variable assignment -- don't pay attention to
		     * dependency operators after this.
		     */
		    ignDepOp = TRUE;
		} else if (lastc == ':' || lastc == '!') {
		    /*
		     * Well, we've seen a dependency operator already, but it
		     * was the previous character, so this is really just an
		     * expanded variable assignment. Revert semi-colons to
		     * being just semi-colons again and ignore any more
		     * dependency operators.
		     *
		     * XXX: Note that a line like "foo : a:=b" will blow up,
		     * but who'd write a line like that anyway?
		     */
		    ignDepOp = TRUE; semiNL = FALSE;
		}
		break;
	    case '#':
		if (!ignComment) {
		    if (
#if 0
		    compatMake &&
#endif
		    (lastc != '\\')) {
			/*
			 * If the character is a hash mark and it isn't escaped
			 * (or we're being compatible), the thing is a comment.
			 * Skip to the end of the line.
			 */
			do {
			    c = ParseReadc();
			} while ((c != '\n') && (c != EOF));
			goto line_read;
		    } else {
			/*
			 * Don't add the backslash. Just let the # get copied
			 * over.
			 */
			lastc = c;
			continue;
d420 4
a424 12
		break;
	    case ':':
	    case '!':
		if (!ignDepOp && (c == ':' || c == '!')) {
		    /*
		     * A semi-colon is recognized as a newline only on
		     * dependency lines. Dependency lines are lines with a
		     * colon or an exclamation point. Ergo...
		     */
		    semiNL = TRUE;
		}
		break;
d426 1
a426 6
	    /*
	     * Copy in the previous character and save this one in lastc.
	     */
	    Buf_AddChar(&buf, lastc);
	    lastc = c;

d428 13
a440 52
    line_read:
	current->lineno++;

	if (lastc != '\0') 
	    Buf_AddChar(&buf, lastc);
	line = Buf_Retrieve(&buf);

	/*
	 * Strip trailing blanks and tabs from the line.
	 * Do not strip a blank or tab that is preceeded by
	 * a '\'
	 */
	ep = line;
	while (*ep)
	    ++ep;
	while (ep > line + 1 && (ep[-1] == ' ' || ep[-1] == '\t')) {
	    if (ep > line + 1 && ep[-2] == '\\')
		break;
	    --ep;
	}
	*ep = 0;

	if (line[0] == '.') {
	    /*
	     * The line might be a conditional. Ask the conditional module
	     * about it and act accordingly
	     */
	    switch (Cond_Eval (line)) {
	    case COND_SKIP:
		/*
		 * Skip to next conditional that evaluates to COND_PARSE.
		 */
		do {
		    free (line);
		    line = ParseSkipLine(1);
		} while (line && Cond_Eval(line) != COND_PARSE);
		if (line == NULL)
		    break;
		/* FALLTHROUGH */
	    case COND_PARSE:
		free(line);
		line = ParseReadLine();
		break;
	    case COND_INVALID:
	    	{
		For *loop;

		loop = For_Eval(line);
		if (loop != NULL) {
		    Boolean ok;

		    free(line);
d442 13
a454 14
			/* Find the matching endfor.  */
			line = ParseSkipLine(0);
			if (line == NULL) {
			    Parse_Error(PARSE_FATAL,
				     "Unexpected end of file in for loop.\n");
			    return line;
			}
			ok = For_Accumulate(loop, line);
			free(line);
		    } while (ok);
		    For_Run(loop);
		    line = ParseReadLine();
		}
		break;
d458 6
a463 1
	return (line);
d465 30
a494 5
    } else {
	/*
	 * Hit end-of-file, so return a NULL line to indicate this.
	 */
	return((char *)NULL);
d524 1
a524 1
	
d530 1
a530 1
    	free_ifile(current);
@


1.4
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.3 2000/07/17 23:54:26 espie Exp $ */
d168 1
d244 2
a245 1
int
@


1.3
log
@FALLTHRU -> FALLTHROUGH, requested by miod@@ and style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.2 2000/06/23 16:40:50 espie Exp $ */
a63 1
static int skiptoendofline __P((void));
a66 1
static int ParseSkipEmptyLines __P((Buffer));
@


1.2
log
@This is complementary to the previous patch.

There is no code change in this patch, we just move the remaining
`lowparse' functions to the right file, and adjust the interface file
accordingly.

Reviewed by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lowparse.c,v 1.1 2000/06/23 16:39:45 espie Exp $ */
d542 1
a542 1
		/*FALLTHRU*/
@


1.1
log
@This patch is worth a lot, speed-wise.

This does introduce a proper stack of IFiles to handle included files:
instead of having the current file be a special case, it's also an IFile.

The corresponding code is slightly unobfuscated, removing the error-prone
ParseEOF function, freeing the filename systematically (thus, main.c needs
to strdup stdin), and merging both include functions lookup into one.

The speed gain comes from changing the IFile structure to merge with
fgetln seamlessly.

The low-level parse code is mostly moved to a new file, lowparse.c, to
make things easier to read (see next patch as well).

Accordingly, util.c gains a fgetln.

Note the interaction between Parse_File, Dir_FindFile, and ReadMakefile in
main.c. This patch closes a subtle memory hole (only the Makefile names,
so rather small).

Reviewed by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d43 14
d65 3
d268 314
@

