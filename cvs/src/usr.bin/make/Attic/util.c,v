head	1.27;
access;
symbols
	OPENBSD_5_4:1.26.0.8
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.6
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.4
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.25.0.6
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.4
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.23.0.8
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.10
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.21.0.18
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.16
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.14
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.12
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.10
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.8
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.6
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2013.10.01.15.37.33;	author deraadt;	state dead;
branches;
next	1.26;

1.26
date	2011.12.10.04.12.36;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.19.19.30.38;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.17.08.36.57;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.25.15.11.06;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.25.13.40.27;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.06.22.47.14;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.29.09.23.25;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.23.12.34.51;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.03.14.06.20;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.03.13.41.12;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.14.13.32.08;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.23.16.39.45;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.11.11.11.35.17;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	98.12.20.23.38.11;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.12.05.00.06.29;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	98.06.03.17.00.04;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.25.21.05.36;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.04.01.07.28.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.11.30.21.09.06;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.02.16.04.21;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.36.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.23.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@in truth, noone uses these backwards compat stubs to compile make on other
systems.  the replacements in here are the least of their worries, and they
shouldn't rely on these things from the 80's.  time for make to grow up,
and use whatever is common today.
@
text
@/*	$OpenBSD: util.c,v 1.26 2011/12/10 04:12:36 guenther Exp $	*/
/*	$NetBSD: util.c,v 1.10 1996/12/31 17:56:04 christos Exp $	*/

/*
 * Copyright (c) 2001 Marc Espie.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Missing stuff from OS's
 */

#include <sys/param.h>
#include <stdio.h>
#include "config.h"
#include "defines.h"

#ifdef sun

extern int errno, sys_nerr;
extern char *sys_errlist[];

char *
strerror(e)
    int e;
{
    static char buf[100];
    if (e < 0 || e >= sys_nerr) {
	snprintf(buf, sizeof buf, "Unknown error %d", e);
	return buf;
    }
    else
	return sys_errlist[e];
}
#endif

#ifdef ultrix
#include <string.h>

/* strdup
 *
 * Make a duplicate of a string.
 * For systems which lack this function.
 */
char *
strdup(str)
    const char *str;
{
    size_t len;
    char *p;

    if (str == NULL)
	return NULL;
    len = strlen(str) + 1;
    if ((p = malloc(len)) == NULL)
	return NULL;

    return memcpy(p, str, len);
}

#endif

#if defined(sun) || defined(__hpux) || defined(__sgi)

int
setenv(name, value, dum)
    const char *name;
    const char *value;
    int dum;
{
    char *p;
    int len = strlen(name) + strlen(value) + 2; /* = \0 */
    char *ptr = (char*)malloc(len);

    if (ptr == NULL)
	return -1;

    p = ptr;

    while (*name)
	*p++ = *name++;

    *p++ = '=';

    while (*value)
	*p++ = *value++;

    *p = '\0';

    len = putenv(ptr);
/*    free(ptr); */
    return len;
}
#endif

#ifdef __hpux
#include <sys/types.h>
#include <sys/param.h>
#include <sys/syscall.h>
#include <sys/signal.h>
#include <sys/stat.h>
#include <stdio.h>
#include <dirent.h>
#include <sys/time.h>
#include <time.h>
#include <unistd.h>


int
killpg(pid, sig)
    int pid, sig;
{
    return kill(-pid, sig);
}

void
srandom(seed)
    long seed;
{
    srand48(seed);
}

long
random()
{
    return lrand48();
}

/* turn into bsd signals */
void (*
signal(s, a))()
    int     s;
    void (*a)();
{
    struct sigvec osv, sv;

    (void)sigvector(s, (struct sigvec *)0, &osv);
    sv = osv;
    sv.sv_handler = a;
#ifdef SV_BSDSIG
    sv.sv_flags = SV_BSDSIG;
#endif

    if (sigvector(s, &sv, (struct sigvec *)0) == -1)
	return SIG_ERR;
    return osv.sv_handler;
}

#if !defined(BSD) && !defined(d_fileno)
# define d_fileno d_ino
#endif

#ifndef DEV_DEV_COMPARE
# define DEV_DEV_COMPARE(a, b) ((a) == (b))
#endif
#define ISDOT(c) ((c)[0] == '.' && ((c)[1] == '\0' || (c)[1] == '/'))
#define ISDOTDOT(c) ((c)[0] == '.' && ISDOT(&((c)[1])))


/* strrcpy():
 *	Like strcpy, going backwards and returning the new pointer
 */
static char *
strrcpy(ptr, str)
    char *ptr, *str;
{
    size_t len = strlen(str);

    while (len)
	*--ptr = str[--len];

    return ptr;
} /* end strrcpy */


char   *
getwd(pathname)
    char   *pathname;
{
    DIR    *dp;
    struct dirent *d;
    extern int errno;

    struct stat st_root, st_cur, st_next, st_dotdot;
    char    pathbuf[MAXPATHLEN], nextpathbuf[MAXPATHLEN * 2];
    char   *pathptr, *nextpathptr, *cur_name_add;

    /* find the inode of root */
    if (stat("/", &st_root) == -1) {
	(void)snprintf(pathname, MAXPATHLEN,
	    "getwd: Cannot stat \"/\" (%s)", strerror(errno));
	return NULL;
    }
    pathbuf[MAXPATHLEN - 1] = '\0';
    pathptr = &pathbuf[MAXPATHLEN - 1];
    nextpathbuf[MAXPATHLEN - 1] = '\0';
    cur_name_add = nextpathptr = &nextpathbuf[MAXPATHLEN - 1];

    /* find the inode of the current directory */
    if (lstat(".", &st_cur) == -1) {
	(void)snprintf(pathname, MAXPATHLEN,
	    "getwd: Cannot stat \".\" (%s)", strerror(errno));
	return NULL;
    }
    nextpathptr = strrcpy(nextpathptr, "../");

    /* Descend to root */
    for (;;) {

	/* look if we found root yet */
	if (st_cur.st_ino == st_root.st_ino &&
	    DEV_DEV_COMPARE(st_cur.st_dev, st_root.st_dev)) {
	    (void)strlcpy(pathname, *pathptr != '/' ? "/" : pathptr, MAXPATHLEN);
	    return pathname;
	}

	/* open the parent directory */
	if (stat(nextpathptr, &st_dotdot) == -1) {
	    (void)snprintf(pathname, MAXPATHLEN,
		"getwd: Cannot stat directory \"%s\" (%s)",
		nextpathptr, strerror(errno));
	    return NULL;
	}
	if ((dp = opendir(nextpathptr)) == NULL) {
	    (void)snprintf(pathname, MAXPATHLEN,
		"getwd: Cannot open directory \"%s\" (%s)",
		nextpathptr, strerror(errno));
	    return NULL;
	}

	/* look in the parent for the entry with the same inode */
	if (DEV_DEV_COMPARE(st_dotdot.st_dev, st_cur.st_dev)) {
	    /* Parent has same device. No need to stat every member */
	    for (d = readdir(dp); d != NULL; d = readdir(dp))
		if (d->d_fileno == st_cur.st_ino)
		    break;
	}
	else {
	    /*
	     * Parent has a different device. This is a mount point so we
	     * need to stat every member
	     */
	    for (d = readdir(dp); d != NULL; d = readdir(dp)) {
		if (ISDOT(d->d_name) || ISDOTDOT(d->d_name))
		    continue;
		(void)strlcpy(cur_name_add, d->d_name,
		    sizeof(nextpathbuf) MAXPATHLEN - (MAXPATHLEN - 1));
		if (lstat(nextpathptr, &st_next) == -1) {
		    (void)snprintf(pathname, MAXPATHLEN,
			"getwd: Cannot stat \"%s\" (%s)",
			d->d_name, strerror(errno));
		    (void)closedir(dp);
		    return NULL;
		}
		/* check if we found it yet */
		if (st_next.st_ino == st_cur.st_ino &&
		    DEV_DEV_COMPARE(st_next.st_dev, st_cur.st_dev))
		    break;
	    }
	}
	if (d == NULL) {
	    (void)snprintf(pathname, MAXPATHLEN,
		"getwd: Cannot find \".\" in \"..\"");
	    (void)closedir(dp);
	    return NULL;
	}
	st_cur = st_dotdot;
	pathptr = strrcpy(pathptr, d->d_name);
	pathptr = strrcpy(pathptr, "/");
	nextpathptr = strrcpy(nextpathptr, "../");
	(void)closedir(dp);
	*cur_name_add = '\0';
    }
} /* end getwd */


char	*sys_siglist[] = {
	"Signal 0",
	"Hangup",			/* SIGHUP    */
	"Interrupt",			/* SIGINT    */
	"Quit", 			/* SIGQUIT   */
	"Illegal instruction",		/* SIGILL    */
	"Trace/BPT trap",		/* SIGTRAP   */
	"IOT trap",			/* SIGIOT    */
	"EMT trap",			/* SIGEMT    */
	"Floating point exception",	/* SIGFPE    */
	"Killed",			/* SIGKILL   */
	"Bus error",			/* SIGBUS    */
	"Segmentation fault",		/* SIGSEGV   */
	"Bad system call",		/* SIGSYS    */
	"Broken pipe",			/* SIGPIPE   */
	"Alarm clock",			/* SIGALRM   */
	"Terminated",			/* SIGTERM   */
	"User defined signal 1",	/* SIGUSR1   */
	"User defined signal 2",	/* SIGUSR2   */
	"Child exited", 		/* SIGCLD    */
	"Power-fail restart",		/* SIGPWR    */
	"Virtual timer expired",	/* SIGVTALRM */
	"Profiling timer expired",	/* SIGPROF   */
	"I/O possible", 		/* SIGIO     */
	"Window size changes",		/* SIGWINDOW */
	"Stopped (signal)",		/* SIGSTOP   */
	"Stopped",			/* SIGTSTP   */
	"Continued",			/* SIGCONT   */
	"Stopped (tty input)",		/* SIGTTIN   */
	"Stopped (tty output)", 	/* SIGTTOU   */
	"Urgent I/O condition", 	/* SIGURG    */
	"Remote lock lost (NFS)",	/* SIGLOST   */
	"Signal 31",			/* reserved  */
	"DIL signal"			/* SIGDIL    */
};

int
utimes(file, tvp)
    char *file;
    struct timeval *tvp;
{
    struct utimbuf t;

    if (tvp == NULL)
	return utime(file, NULL);
    t.actime  = tvp[0].tv_sec;
    t.modtime = tvp[1].tv_sec;
    return utime(file, &t);
}


#endif /* __hpux */

#if defined(sun) && defined(__svr4__)
#include <signal.h>

/* turn into bsd signals */
void (*
signal(s, a))()
    int     s;
    void (*a)();
{
    struct sigaction sa, osa;

    memset(&sa, 0, sizeof sa);
    sa.sa_handler = a;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(s, &sa, &osa) == -1)
	return SIG_ERR;
    else
	return osa.sa_handler;
}

#endif

#ifndef BSD4_4
#include <stdarg.h>

#ifdef _IOSTRG
#define STRFLAG (_IOSTRG|_IOWRT)	/* no _IOWRT: avoid stdio bug */
#else
#define STRFLAG (_IOREAD)		/* XXX: Assume svr4 stdio */
#endif

int
vsnprintf(s, n, fmt, args)
	char *s;
	size_t n;
	const char *fmt;
	va_list args;
{
	FILE fakebuf;

	fakebuf._flag = STRFLAG;
	/*
	 * Some os's are char * _ptr, others are unsigned char *_ptr...
	 * We cast to void * to make everyone happy.
	 */
	fakebuf._ptr = (void *)s;
	fakebuf._cnt = n-1;
	fakebuf._file = -1;
	_doprnt(fmt, args, &fakebuf);
	fakebuf._cnt++;
	putc('\0', &fakebuf);
	if (fakebuf._cnt<0)
	    fakebuf._cnt = 0;
	return n-fakebuf._cnt-1;
}

int
snprintf(char *s, size_t n, const char *fmt, ...)
{
	va_list ap;
	int rv;

	va_start(ap, fmt);
	rv = vsnprintf(s, n, fmt, ap);
	va_end(ap);
	return rv;
}
#endif
#ifdef NEED_STRSTR
char *
strstr(string, substring)
	const char *string;		/* String to search. */
	const char *substring;		/* Substring to find in string */
{
	const char *a, *b;

	/*
	 * First scan quickly through the two strings looking for a single-
	 * character match.  When it's found, then compare the rest of the
	 * substring.
	 */

	for (b = substring; *string != 0; string++) {
		if (*string != *b)
			continue;
		a = string;
		for (;;) {
			if (*b == 0)
				return (char *)string;
			if (*a++ != *b++)
				break;
		}
		b = substring;
	}
	return NULL;
}
#endif

#ifdef NEED_FGETLN
char *
fgetln(stream, len)
    FILE *stream;
    size_t *len;
{
    static char *buffer = NULL;
    static size_t buflen = 0;

    if (buflen == 0) {
	buflen = 512;
	buffer = emalloc(buflen+1);
    }
    if (fgets(buffer, buflen+1, stream) == NULL)
	return NULL;
    *len = strlen(buffer);
    while (*len == buflen && buffer[*len-1] != '\n') {
	buffer = erealloc(buffer, 2*buflen + 1);
	if (fgets(buffer + buflen, buflen + 1, stream) == NULL)
	    return NULL;
	*len += strlen(buffer + buflen);
	buflen *= 2;
    }
    return buffer;
}
#endif
@


1.26
log
@Use clock_gettime() to get a high precision timestamp, instead of
converting gettimeofday()'s output, and pass utimes() NULL to get
the time from inside the kernel instead

ok espie@@, stress testing on NFS by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.25 2010/07/19 19:46:44 espie Exp $	*/
@


1.25
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.24 2010/07/19 19:30:38 espie Exp $	*/
d335 1
a335 1
    struct timeval tvp[2];
d339 2
@


1.24
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$	*/
@


1.23
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: util.c,v 1.22 2007/09/17 08:36:57 espie Exp $	*/
@


1.22
log
@kill += 1, -= 1     -> ++, --
@
text
@d2 1
a2 1
/*	$OpenBSD: util.c,v 1.21 2003/06/25 15:11:06 millert Exp $	*/
d210 1
a210 1
	(void)snprintf(pathname, MAXPATHLEN, 
d266 1
a266 1
		(void)strlcpy(cur_name_add, d->d_name, 
@


1.21
log
@Use sizeof(nextpathbuf) instead of 2 * MAXPATHLEN; espie@@ OK
@
text
@d2 1
a2 1
/*	$OpenBSD: util.c,v 1.20 2003/06/25 13:40:27 espie Exp $	*/
d432 1
a432 1
	for (b = substring; *string != 0; string += 1) {
@


1.20
log
@kill unused strcpy. Let the preprocessor compute the right size, as suggested
by miod and ok miod@@
@
text
@d2 1
a2 1
/*	$OpenBSD: util.c,v 1.19 2003/04/06 22:47:14 espie Exp $	*/
d267 1
a267 1
		    2 * MAXPATHLEN - (MAXPATHLEN - 1));
@


1.19
log
@get rid of some strcpy/sprintf.
ok krw@@, matthieu@@, deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: util.c,v 1.18 2002/05/29 09:23:25 deraadt Exp $	*/
d266 2
a267 1
		(void)strcpy(cur_name_add, d->d_name);
@


1.18
log
@more snprintf
@
text
@d2 1
a2 1
/*	$OpenBSD: util.c,v 1.17 2002/02/19 19:39:38 millert Exp $	*/
d210 1
a210 1
	(void)sprintf(pathname,
d221 1
a221 1
	(void)sprintf(pathname,
d233 1
a233 1
	    (void)strcpy(pathname, *pathptr != '/' ? "/" : pathptr);
d239 1
a239 1
	    (void)sprintf(pathname,
d245 1
a245 1
	    (void)sprintf(pathname,
d268 1
a268 1
		    (void)sprintf(pathname,
d281 1
a281 1
	    (void)sprintf(pathname,
@


1.17
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d2 1
a2 1
/*	$OpenBSD: util.c,v 1.16 2001/05/23 12:34:51 espie Exp $	*/
d49 1
a49 1
	sprintf(buf, "Unknown error %d", e);
d211 1
a211 1
			"getwd: Cannot stat \"/\" (%s)", strerror(errno));
d222 1
a222 1
			"getwd: Cannot stat \".\" (%s)", strerror(errno));
d240 2
a241 2
			    "getwd: Cannot stat directory \"%s\" (%s)",
			    nextpathptr, strerror(errno));
d246 2
a247 2
			    "getwd: Cannot open directory \"%s\" (%s)",
			    nextpathptr, strerror(errno));
d268 3
a270 2
		    (void)sprintf(pathname, "getwd: Cannot stat \"%s\" (%s)",
				    d->d_name, strerror(errno));
d281 2
a282 1
	    (void)sprintf(pathname, "getwd: Cannot find \".\" in \"..\"");
@


1.16
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: util.c,v 1.10 1998/12/20 23:38:11 deraadt Exp $	*/
a37 6
#ifndef __STDC__
# ifndef const
#  define const
# endif
#endif

a39 2


a369 1
#ifdef __STDC__
a370 3
#else
#include <varargs.h>
#endif
a403 1
#ifdef __STDC__
a404 4
#else
snprintf(va_alist)
	va_dcl
#endif
d408 1
a408 1
#ifdef __STDC__
a409 11
#else
	char *s;
	size_t n;
	const char *fmt;

	va_start(ap);

	s = va_arg(ap, char *);
	n = va_arg(ap, size_t);
	fmt = va_arg(ap, const char *);
#endif
@


1.15
log
@Bump bootstrap stuff from op-make. Mostly from fries@@
@
text
@d2 1
a2 1
/*	$OpenBSD: util.c,v 1.14 2001/05/03 13:41:12 espie Exp $	*/
d6 24
d33 1
a33 4
#ifndef lint
static char rcsid[] = "$OpenBSD: util.c,v 1.14 2001/05/03 13:41:12 espie Exp $";
#endif

d35 2
a36 2
#include "make.h"
#include <sys/param.h>
d377 1
a377 1
#if !defined(BSD4_4) && !defined(linux)
@


1.14
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d2 1
a2 1
/*	$OpenBSD: util.c,v 1.10 1998/12/20 23:38:11 deraadt Exp $	*/
d10 1
a10 1
static char rcsid[] = "$OpenBSD: util.c,v 1.10 1998/12/20 23:38:11 deraadt Exp $";
d356 1
a356 1
#ifndef BSD4_4
@


1.13
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 2
a2 1
/*	$OpenBSD: util.c,v 1.12 2000/06/23 16:39:45 espie Exp $	*/
d9 4
a16 5
#ifndef lint
UNUSED
static char rcsid[] = "$OpenBSD: util.c,v 1.12 2000/06/23 16:39:45 espie Exp $";
#endif

d78 1
a78 1
    register char *p;
d80 1
a80 3
    char *ptr = (char*) malloc(len);

    (void) dum;
d138 1
a138 1
signal(s, a)) ()
d144 1
a144 1
    (void) sigvector(s, (struct sigvec *) 0, &osv);
d151 3
a153 3
    if (sigvector(s, &sv, (struct sigvec *) 0) == -1)
        return (SIG_ERR);
    return (osv.sv_handler);
d163 1
a163 1
#define ISDOT(c) ((c)[0] == '.' && (((c)[1] == '\0') || ((c)[1] == '/')))
d172 1
a172 1
    register char *ptr, *str;
d174 1
a174 1
    register int len = strlen(str);
d179 1
a179 1
    return (ptr);
d197 1
a197 1
	(void) sprintf(pathname,
d199 1
a199 1
	return (NULL);
d208 1
a208 1
	(void) sprintf(pathname,
d210 1
a210 1
	return (NULL);
d220 2
a221 2
	    (void) strcpy(pathname, *pathptr != '/' ? "/" : pathptr);
	    return (pathname);
d226 1
a226 1
	    (void) sprintf(pathname,
d229 1
a229 1
	    return (NULL);
d232 1
a232 1
	    (void) sprintf(pathname,
d235 1
a235 1
	    return (NULL);
d253 1
a253 1
		(void) strcpy(cur_name_add, d->d_name);
d255 1
a255 1
		    (void) sprintf(pathname, "getwd: Cannot stat \"%s\" (%s)",
d257 2
a258 2
		    (void) closedir(dp);
		    return (NULL);
d267 3
a269 3
	    (void) sprintf(pathname, "getwd: Cannot find \".\" in \"..\"");
	    (void) closedir(dp);
	    return (NULL);
d275 1
a275 1
	(void) closedir(dp);
d281 34
a314 34
char    *sys_siglist[] = {
        "Signal 0",
        "Hangup",                       /* SIGHUP    */
        "Interrupt",                    /* SIGINT    */
        "Quit",                         /* SIGQUIT   */
        "Illegal instruction",          /* SIGILL    */
        "Trace/BPT trap",               /* SIGTRAP   */
        "IOT trap",                     /* SIGIOT    */
        "EMT trap",                     /* SIGEMT    */
        "Floating point exception",     /* SIGFPE    */
        "Killed",                       /* SIGKILL   */
        "Bus error",                    /* SIGBUS    */
        "Segmentation fault",           /* SIGSEGV   */
        "Bad system call",              /* SIGSYS    */
        "Broken pipe",                  /* SIGPIPE   */
        "Alarm clock",                  /* SIGALRM   */
        "Terminated",                   /* SIGTERM   */
        "User defined signal 1",        /* SIGUSR1   */
        "User defined signal 2",        /* SIGUSR2   */
        "Child exited",                 /* SIGCLD    */
        "Power-fail restart",           /* SIGPWR    */
        "Virtual timer expired",        /* SIGVTALRM */
        "Profiling timer expired",      /* SIGPROF   */
        "I/O possible",                 /* SIGIO     */
        "Window size changes",          /* SIGWINDOW */
        "Stopped (signal)",             /* SIGSTOP   */
        "Stopped",                      /* SIGTSTP   */
        "Continued",                    /* SIGCONT   */
        "Stopped (tty input)",          /* SIGTTIN   */
        "Stopped (tty output)",         /* SIGTTOU   */
        "Urgent I/O condition",         /* SIGURG    */
        "Remote lock lost (NFS)",       /* SIGLOST   */
        "Signal 31",                    /* reserved  */
        "DIL signal"                    /* SIGDIL    */
d326 1
a326 1
    return(utime(file, &t));
d337 1
a337 1
signal(s, a)) ()
d364 1
a364 1
#define STRFLAG	(_IOSTRG|_IOWRT)	/* no _IOWRT: avoid stdio bug */
d366 1
a366 1
#define STRFLAG	(_IOREAD)		/* XXX: Assume svr4 stdio */
d383 1
a383 1
	fakebuf._ptr = (void *) s;
d391 1
a391 1
	return (n-fakebuf._cnt-1);
a421 1

d462 1
a462 1
    	buflen = 512;
@


1.12
log
@This patch is worth a lot, speed-wise.

This does introduce a proper stack of IFiles to handle included files:
instead of having the current file be a special case, it's also an IFile.

The corresponding code is slightly unobfuscated, removing the error-prone
ParseEOF function, freeing the filename systematically (thus, main.c needs
to strdup stdin), and merging both include functions lookup into one.

The speed gain comes from changing the IFile structure to merge with
fgetln seamlessly.

The low-level parse code is mostly moved to a new file, lowparse.c, to
make things easier to read (see next patch as well).

Accordingly, util.c gains a fgetln.

Note the interaction between Parse_File, Dir_FindFile, and ReadMakefile in
main.c. This patch closes a subtle memory hole (only the Makefile names,
so rather small).

Reviewed by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.11 1999/11/11 11:35:17 espie Exp $	*/
a7 4
#ifndef lint
static char rcsid[] = "$OpenBSD: util.c,v 1.11 1999/11/11 11:35:17 espie Exp $";
#endif

d11 5
@


1.11
log
@Kill Str_FindSubString, it's strstr.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.10 1998/12/20 23:38:11 deraadt Exp $	*/
d9 1
a9 1
static char rcsid[] = "$OpenBSD: util.c,v 1.10 1998/12/20 23:38:11 deraadt Exp $";
d451 27
@


1.10
log
@bye bye BADSIG
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.9 1998/12/05 00:06:29 espie Exp $	*/
d9 1
a9 1
static char rcsid[] = "$OpenBSD: util.c,v 1.9 1998/12/05 00:06:29 espie Exp $";
d421 30
@


1.9
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.7 1997/07/25 21:05:36 mickey Exp $	*/
d9 1
a9 1
static char rcsid[] = "$OpenBSD: util.c,v 1.7 1997/07/25 21:05:36 mickey Exp $";
d153 1
a153 1
        return (BADSIG);
@


1.8
log
@zero sigaction before use
@
text
@@


1.7
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.6 1997/04/01 07:28:26 millert Exp $	*/
d9 1
a9 1
static char rcsid[] = "$OpenBSD: util.c,v 1.6 1997/04/01 07:28:26 millert Exp $";
d344 1
@


1.6
log
@Sync with NetBSD (mostly by christos initial substitution/regexp from Der Mouse)

- fix the variable substitution code in make [PR/2748]
      1. change s/a/b/ so that it substitutes the first occurance of the
         pattern on each word, not only the first word.
      2. add flag '1' to the variable substitution so that the substitutions
         get performed only once.

  ***THIS IS AN INCOMPATIBLE CHANGE!***

  Unfortunately there was no way to make things consistent without
  modifying the current behavior. Fortunately none of our Makefiles
  depended on this.

            OLD:

                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4

            NEW:
                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 ba2 ba3 ba4
                S/a/b/1  = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4
                S/a/b/1g = bb1 aa2 aa3 aa4
- add regexp variable substitution via 'C/foo/bar/' [PR/2752]
- add variable quoting via the ${VAR:Q} modifier. This is useful when running
  recursive invocations of make(1):

        make VAR=${VAR:Q}

  will always work... (This may prove useful in the kernel builds...) [PR/2981]
- BSD did not traditionally have <sys/cdefs.h>; use BSD4_4 instead and include
  <sys/param.h> to grab it.
- Don't compile the regex code if MAKE_BOOTSTRAP (from gwr)
- Use explicit .c.o rule in Makefile.boot so that the bootstrap process works.
- Use only integral types in procedure arguments. [buf.c buf.h]
- Include <stdlib.h> to get getenv() prototype on SVR4
- if __STDC__ -> ifdef __STDC__ to appease SVR4
- Define const and volatile for non __STDC__
- Implement snprintf() and vsnprintf() for non BSD4_4 systems.
- Make $MACHINE_ARCH settable from the environment.
- Fix .USE directive problems: (reported by cgd)
    1. ${.*} variables did not get expanded in dependencies.
    2. expanded ${.*} variables in .USE dependencies can cause tree
       restructuring; handle it.
    3. in compat mode, expand .USE before evaluating the list of targets,
       instead of doing .USE expansions on demand, because they can cause
       tree restructuring.
- Add a .MADE directive to indicated that the children of a target are
  up-to-date, even when they are not. This is to simulate our current
  make install behavior with proper dependencies.
- Fix problems in the RE substitution error handling.
- Locate all the children of a node marked as MADE.
- Do not compile-in ${MACHINE} (as per NetBSD PR#3386)
- Disable globbing for targets/dependencies when POSIX is defined.
- Fix globbing so that patterns that don't have a matching number of [] or {}
  don't get expanded. (before the [ case got expanded to nothing!) This is
  disabled.
- Make sure that the children of nodes that are marked .MADE, are marked
  UPTODATE and their timestamps are consistent.
- Don't disable wildcards completely; they are used by other Makefiles.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.5 1996/11/30 21:09:06 millert Exp $	*/
d9 1
a9 1
static char rcsid[] = "$OpenBSD: util.c,v 1.5 1996/11/30 21:09:06 millert Exp $";
d16 1
a16 1
#if !__STDC__
@


1.5
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.4 1996/09/02 16:04:21 briggs Exp $	*/
/*	$NetBSD: util.c,v 1.9 1996/11/11 15:16:10 christos Exp $	*/
d9 1
a9 1
static char rcsid[] = "$OpenBSD: util.c,v 1.4 1996/09/02 16:04:21 briggs Exp $";
d14 1
d354 67
@


1.4
log
@Sync up with NetBSD:
(christos)
	Fix bug reported by Greg Hudson where leaf (source only) nodes were
	referenced only by their basename and not by their full pathname. This
	breaks when .PATH or MAKEOBJDIR are used. There might be Makefiles
	around that try to work around this bug by prepending ${.CURDIR} to
	the sources, and they should be found and fixed. Also a lot of the gunk
	in suff.c that was attempting to work around the same problem could be
	removed.
(christos)
	- Move -D flags from Makefile to config.h and explain what they do. Add
	  -Wall -Wno-unused to CFLAGS. Add new define SYSVVARSUB to enable SysV
	  style variable substitutions and enable them.
	- Add SunOS style command substitutions via SUNSHCMD
	- Fix core dump with '{variable = value'
(christos)
	Fix bug where make will always exit with 0, even when one or more
	parallel jobs failed. (Only affects parallel make code)
(christos)
	Protect __P from being multiply defined (for systems that already
	define it)
(christos) Add strdup() since ultrix is missing it.
	From Larry Schwimmer <rosebud@@cyclone.Stanford.EDU>
(christos) Add estrdup(), a checked version of strdup and use it.
(christos) Recognize SVR4 style long filename entries in archives.
(thorpej) Tidy up some RCS ids a bit.
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.3 1996/06/26 05:36:38 deraadt Exp $	*/
/*	$NetBSD: util.c,v 1.5 1995/11/22 17:40:17 christos Exp $	*/
a5 1
 *
d9 1
a9 1
static char rcsid[] = "$OpenBSD: util.c,v 1.3 1996/06/26 05:36:38 deraadt Exp $";
d29 2
a30 2
strerror(e) 
    int e; 
d55 1
d72 1
a72 1
    const char *name; 
d84 1
a84 1
    
d87 1
a87 1
    while (*name) 
d92 1
a92 1
    while (*value) 
d241 1
a241 1
	    for (d = readdir(dp); d != NULL; d = readdir(dp)) 
d246 3
a248 3
	    /* 
	     * Parent has a different device. This is a mount point so we 
	     * need to stat every member 
d262 1
a262 1
		    DEV_DEV_COMPARE(st_next.st_dev, st_cur.st_dev)) 
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.5 1995/11/22 17:40:17 christos Exp $	*/
d10 1
a10 1
static char rcsid[] = "$OpenBSD: util.c,v 1.2 1995/12/14 03:23:39 deraadt Exp $";
d43 26
a68 1
#if defined(sun) || defined(__hpux)
@


1.2
log
@from christos@@netbsd:
Minor:
    - ${.PREFIX} should never contain a full pathname
    - Fixed gcc -Wall warnings
Major:
    - compatMake is now FALSE. This means that we are now running in
      full pmake mode:
          * rules on dependency lines can be executed in parallel and or
            out of sequence:

            foo: bar baz

            can fire the rule for baz before the rule for bar is fired.
            To enforce bar to be fired before baz, another rule needs to be
            added. [bar: baz]
          * adjacent shell commands in a target are now executed by a single
            invocation of the shell, not one invocation of the shell per line
      (compatMake can be turned off using the -B flag)
    - The -j flag now works... I.e. make -j 4 will fork up to four jobs in
      parallel when it can. The target name is printed before each burst
      of output caused by the target execution as '--- target ---', when j > 1
    - I have changed all the Makefiles so that they work with make -j N, and
      I have tested the whole netbsd by:
          'make -j 4 cleandir; make -j 4 depend; make -j 4; make -j 4 install'
    - I have not compiled or tested this version of make with -DREMOTE.
- Turn compat mode on by default. It gets turned off when the -j without
  the -B flag is specified. [Thus you can use -j 1 to turn it off].
- Fix malloc -> emalloc as Gordon noted.
Updates for POSIX/SVR4 compiling:
arch.c:          Don't require ranlib stuff. Not everybody has it.
dir.c:           SunOS-4 != Solaris; change #ifdef sun to #if sun && !__svr4__
job.c, compat.c: Don't use 'union wait', use int and the W*() macros.
main.c:          Check for uname() == -1; some unames return > 0...
util.c, job.c:   Add signal() with BSD semantics for svr4, don't use bsd
                 sigmask and friends.

from cgd@@netbsd:
pull in make.h.  (PAlloc() now uses emalloc(), which is prototyped in
make.h.  If the prototype is not in scope on the Alpha, I see lots
of "cast to pointer from integer of different size" warnings.)
@
text
@d1 1
d10 1
a10 1
static char rcsid[] = "$Id: util.c,v 1.5 1995/11/22 17:40:17 christos Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: util.c,v 1.4 1995/06/14 15:20:11 christos Exp $	*/
d9 1
a9 1
static char rcsid[] = "$Id: util.c,v 1.4 1995/06/14 15:20:11 christos Exp $";
d305 23
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
