head	1.28;
access;
symbols
	OPENBSD_6_1:1.28.0.16
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.14
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.10
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.12
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.4
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.8
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.19.0.2
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.8
	OPENBSD_5_0:1.17.0.6
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.4.0.24
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.22
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.20
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.18
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.16
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.14
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.12
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.10
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.28
date	2013.05.30.08.58.38;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2013.05.25.11.54.14;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2013.05.22.12.14.08;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2013.05.14.18.47.40;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2013.04.23.14.32.53;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2012.10.09.19.45.34;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2012.10.06.09.32.40;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2012.10.02.10.29.30;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2012.04.11.18.27.30;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2012.03.22.13.47.12;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.16.09.51.12;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.04.07.22.35;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.29.22.23.10;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.10.17.44.06;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.24.15.41.01;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.10.13.59.48;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.10.12.51.40;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.06.21.12.23;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.02.17.27.24;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.23.09.47.56;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.17.12.42.09;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.23.23.42.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.22.21.18.10;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.23.12.34.43;	author espie;	state Exp;
branches;
next	;


desc
@@


1.28
log
@remove cmtime again, but with a proper test for nodes without children.

problem seen by aja,
make pointed by matthieu,
sleuthing by me,
okay by millert

(and you say OpenBSD developers don't work together)
@
text
@#ifndef GNODE_H
#define GNODE_H
/*	$OpenBSD: gnode.h,v 1.27 2013/05/25 11:54:14 espie Exp $ */

/*
 * Copyright (c) 2001 Marc Espie.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/time.h>
#ifndef LIST_TYPE
#include "lst_t.h"
#endif
#ifndef LOCATION_TYPE
#include "location.h"
#endif
#ifndef SYMTABLE_H
#include "symtable.h"
#endif
#include <assert.h>

/*-
 * The structure for an individual graph node. Each node has several
 * pieces of data associated with it.
 *	1) the name of the target it describes
 *	2) the location of the target file in the file system.
 *	3) the type of operator used to define its sources (qv. parse.c)
 *	4) whether it is involved in this invocation of make
 *	5) whether the target has been remade
 *	6) whether any of its children has been remade
 *	7) the number of its children that are, as yet, unmade
 *	8) its modification time
 *	9) the modification time of its youngest child (qv. make.c)
 *	10) a list of nodes for which this is a source
 *	11) a list of nodes on which this depends
 *	12) a list of nodes that depend on this, as gleaned from the
 *	    transformation rules.
 *	13) a list of nodes of the same name created by the :: operator
 *	14) a list of nodes that must be made (if they're made) before
 *	    this node can be, but that do no enter into the datedness of
 *	    this node.
 *	15) a list of nodes that must be made (if they're made) after
 *	    this node is, but that do not depend on this node, in the
 *	    normal sense.
 *	16) a Lst of ``local'' variables that are specific to this target
 *	   and this target only (qv. var.c [$@@ $< $?, etc.])
 *	17) a Lst of strings that are commands to be given to a shell
 *	   to create this target.
 */

#define UNKNOWN		0
#define BEINGMADE	1
#define MADE		2
#define UPTODATE	3
#define ERROR		4
#define ABORTED		5
#define CYCLE		6
#define ENDCYCLE	7
#define NOSUCHNODE	8
#define BUILDING	9
#define HELDBACK	10

#define SPECIAL_NONE	0U
#define SPECIAL_PATH		21U
#define SPECIAL_MASK		63U
#define SPECIAL_TARGET		64U
#define SPECIAL_SOURCE		128U
#define SPECIAL_TARGETSOURCE	(SPECIAL_TARGET|SPECIAL_SOURCE)

#define	SPECIAL_EXEC		4U
#define SPECIAL_IGNORE		5U
#define SPECIAL_NOTHING 	6U
#define	SPECIAL_INVISIBLE	8U
#define SPECIAL_JOIN		9U
#define SPECIAL_MADE		11U
#define SPECIAL_MAIN		12U
#define SPECIAL_MAKE		13U
#define SPECIAL_MFLAGS		14U
#define	SPECIAL_NOTMAIN		15U
#define	SPECIAL_NOTPARALLEL	16U
#define	SPECIAL_OPTIONAL	18U
#define SPECIAL_ORDER		19U
#define SPECIAL_PARALLEL	20U
#define SPECIAL_PHONY		22U
#define SPECIAL_PRECIOUS	23U
#define SPECIAL_SILENT		25U
#define SPECIAL_SUFFIXES	27U
#define	SPECIAL_USE		28U
#define SPECIAL_WAIT		29U
#define SPECIAL_NOPATH		30U
#define SPECIAL_ERROR		31U
#define SPECIAL_CHEAP		32U
#define SPECIAL_EXPENSIVE	33U

struct GNode_ {
    unsigned int special_op;	/* special op to apply */
    unsigned char special;/* type of special node */
    char must_make;	/* true if this target needs to be remade */
    char childMade;	/* true if one of this target's children was
			 * made */
    char built_status;	/* Set to reflect the state of processing
			 * on this node:
			 *  UNKNOWN - Not examined yet
			 *  BEINGMADE - Target is currently being made.
			 *  BUILDING - There is a job running
			 *  MADE - Was out-of-date and has been made
			 *  UPTODATE - Was already up-to-date
			 *  ERROR - An error occurred while it was being
			 *	made (used only in compat mode)
			 *  ABORTED - The target was aborted due to
			 *	an error making an inferior.
			 *  CYCLE - Marked as potentially being part of
			 *	a graph cycle. If we come back to a
			 *	node marked this way, it is printed
			 *	and 'built_status' is changed to ENDCYCLE.
			 *  ENDCYCLE - the cycle has been completely
			 *	printed. Go back and unmark all its
			 *	members.
			 */
    char *path;		/* The full pathname of the file */
    unsigned int type;	/* Its type (see the OP flags, below) */
    int order;		/* Its wait weight */

    int unmade;		/* The number of unmade children */

    struct timespec mtime;	/* Its modification time */
    GNode *youngest;		/* Its youngest child */

    GNode *impliedsrc;
    LIST cohorts;	/* Other nodes for the :: operator */
    LIST parents;	/* Nodes that depend on this one */
    LIST children;	/* Nodes on which this one depends */
    LIST successors; 	/* Nodes that must be made after this one */
    LIST preds;		/* Nodes that must be made before this one */

    SymTable context;	/* The local variables */
    LIST commands;	/* Creation commands */
    Suff *suffix;	/* Suffix for the node (determined by
			 * Suff_FindDeps and opaque to everyone
			 * but the Suff module) */
    GNode *sibling;	/* equivalent targets */
    GNode *groupling;	/* target lists */
    GNode *watched;	/* the node currently building */
    /* stuff for target name equivalence */
    char *basename;	/* pointer to name stripped of path */
    GNode *next;
    char name[1];	/* The target's name */
};

struct command
{
	Location location;
	char string[1];
};

#define has_been_built(gn) \
	((gn)->built_status == MADE || (gn)->built_status == UPTODATE)
#define should_have_file(gn) \
	((gn)->special == SPECIAL_NONE && \
	((gn)->type & (OP_PHONY | OP_DUMMY)) == 0)
/*
 * The OP_ constants are used when parsing a dependency line as a way of
 * communicating to other parts of the program the way in which a target
 * should be made. These constants are bitwise-OR'ed together and
 * placed in the 'type' field of each node. Any node that has
 * a 'type' field which satisfies the OP_NOP function was never never on
 * the lefthand side of an operator, though it may have been on the
 * righthand side...
 */
#define OP_DEPENDS	0x00000001  /* Execution of commands depends on
				     * kids (:) */
#define OP_FORCE	0x00000002  /* Always execute commands (!) */
#define OP_DOUBLEDEP	0x00000004  /* Execution of commands depends on kids
				     * per line (::) */
#define OP_ERROR	0x00000000
#define OP_OPMASK	(OP_DEPENDS|OP_FORCE|OP_DOUBLEDEP)

#define OP_OPTIONAL	0x00000008  /* Don't care if the target doesn't
				     * exist and can't be created */
#define OP_USE		0x00000010  /* Use associated commands for parents */
#define OP_EXEC 	0x00000020  /* Target is never out of date, but always
				     * execute commands anyway. Its time
				     * doesn't matter, so it has none...sort
				     * of */
#define OP_IGNORE	0x00000040  /* Ignore errors when creating the node */
#define OP_PRECIOUS	0x00000080  /* Don't remove the target when
				     * interrupted */
#define OP_SILENT	0x00000100  /* Don't echo commands when executed */
#define OP_MAKE 	0x00000200  /* Target is a recursive make so its
				     * commands should always be executed when
				     * it is out of date, regardless of the
				     * state of the -n or -t flags */
#define OP_JOIN 	0x00000400  /* Target is out-of-date only if any of its
				     * children was out-of-date */
#define OP_MADE 	0x00000800  /* Assume the node is already made; even if
				     * it really is out of date */
#define OP_INVISIBLE	0x00001000  /* The node is invisible to its parents.
				     * I.e. it doesn't show up in the parents's
				     * local variables. */
#define OP_NOTMAIN	0x00002000  /* The node is exempt from normal 'main
				     * target' processing in parse.c */
#define OP_PHONY	0x00004000  /* Not a file target; run always */
#define OP_NOPATH	0x00008000  /* Don't search for file in the path */
#define OP_NODEFAULT	0x00010000  /* Special node that never needs */
				    /* DEFAULT commands applied */
#define OP_DUMMY	0x00020000  /* node was created by default, but it */
				    /* does not really exist. */
/* Attributes applied by PMake */
#define OP_TRANSFORM	0x00040000  /* The node is a transformation rule */
#define OP_MEMBER	0x00080000  /* Target is a member of an archive */
#define OP_DOUBLE	0x00100000  /* normal op with double commands */
#define OP_ARCHV	0x00200000  /* Target is an archive construct */
#define OP_HAS_COMMANDS 0x00400000  /* Target has all the commands it should.
				     * Used when parsing to catch multiple
				     * commands for a target */
#define OP_DEPS_FOUND	0x00800000  /* Already processed by Suff_FindDeps */
#define OP_RESOLVED	0x01000000  /* We looked harder already */
#define OP_CHEAP	0x02000000  /* Assume job is not recursive */
#define OP_EXPENSIVE	0x04000000  /* Recursive job, don't run in parallel */

/*
 * OP_NOP will return true if the node with the given type was not the
 * object of a dependency operator
 */
#define OP_NOP(t)	(((t) & OP_OPMASK) == 0x00000000)

#define OP_NOTARGET (OP_NOTMAIN|OP_USE|OP_EXEC|OP_TRANSFORM)


#endif
@


1.27
log
@obviously missed something, so revert.
(noticed by sthen@@/matthieu@@)
@
text
@d3 1
a3 1
/*	$OpenBSD: gnode.h,v 1.26 2013/05/22 12:14:08 espie Exp $ */
a146 2
    struct timespec cmtime;	/* The modification time of its youngest
			 	 * child */
@


1.26
log
@as checked through thorough tests, youngest->mtime == ctime, so ditch
the extra field.

remove some extra abstraction layer: use clock_gettime directly
instead of ts_set_from_now (what is "now" anyways)

time_to_string takes param by pointer

rename "now" into starttime (more accurate term)

randomize queue uses arc4random_uniform (prompted by deraadt@@)

display debug timestamp with ns too (it's debug, so it doesn't really
matter whichever way it's done, as long as it's done)

okay millert@@
@
text
@d3 1
a3 1
/*	$OpenBSD: gnode.h,v 1.25 2013/05/14 18:47:40 espie Exp $ */
d147 2
@


1.25
log
@keep track of the youngest child, helps a lot with out-of-date messages
in -dm mode.

okay millert@@
@
text
@d3 1
a3 1
/*	$OpenBSD: gnode.h,v 1.24 2013/04/23 14:32:53 espie Exp $ */
d40 1
d147 1
a147 2
    struct timespec cmtime;	/* The modification time of its youngest
			 	 * child */
a148 1
    GNode *youngest;
@


1.24
log
@remove TIMESTAMP abstraction layer, prodded by theo.
while there, clean up includes.
use strtoll for ar timestamps (pretty much unused in reality, more
standard conforming than anything)

use idea from Todd to adapt to time_t being 32 bits OR 64 bits
(pedantically correct: INT_MIN would work just fine up to 1910 or so...)

okay millert@@, gone thru a make build.
@
text
@d3 1
a3 1
/*	$OpenBSD: gnode.h,v 1.23 2012/10/09 19:45:34 espie Exp $ */
d149 1
@


1.23
log
@- SPECIAL_DEPRECATED -> SPECIAL_NOTHING
- nodes for .POSIX and .SCCS_GET (which don't do anything)
- zap remaining suffix crud.

new scaffolding:
- groupling list and HELDBACK state to avoid races in engine.
- parser recognizes lists of targets that shoul be grouped together
- OP_DOUBLE to mark nodes that have multiple lists of commands
@
text
@d3 1
a3 1
/*	$OpenBSD: gnode.h,v 1.22 2012/10/06 09:32:40 espie Exp $ */
d30 1
a30 3
#ifndef TIMESTAMP_TYPE
#include "timestamp_t.h"
#endif
d145 3
a147 3
    TIMESTAMP mtime;	/* Its modification time */
    TIMESTAMP cmtime;	/* The modification time of its youngest
			 * child */
@


1.22
log
@- extra juice for debugging signal passing.  Note when we can't pass the
signal because the process already bought it (pgroups will do that to you)
(lots of discussion with Todd on that one)
- tweak error handling some more to make it less verbose when just one job
is running...
- show signal name in case of signal interrupts.
- zap OP_LIB, move that stuff to the location where we warn when we meet
that bug.

okay millert@@
@
text
@d3 1
a3 1
/*	$OpenBSD: gnode.h,v 1.21 2012/10/02 10:29:30 espie Exp $ */
a42 1
struct Suff_;
d82 1
d93 1
a107 1
#define SPECIAL_SINGLESHELL	26U
a114 1
#define SPECIAL_DEPRECATED 	6U
a140 1
    char build_lock;	/* for parallel build in siblings */
d160 1
a160 1
    struct Suff_ *suffix;/* Suffix for the node (determined by
d163 3
a165 1
    struct GNode_ *sibling;	/* equivalent targets */
d168 1
a168 1
    struct GNode_ *next;
d233 1
@


1.21
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d3 1
a3 1
/*	$OpenBSD: gnode.h,v 1.20 2012/09/21 07:55:20 espie Exp $ */
a232 1
#define OP_LIB		0x00100000  /* Target is a library */
@


1.20
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d3 1
a3 1
/*	$OpenBSD: gnode.h,v 1.19 2012/04/11 18:27:30 espie Exp $ */
d82 1
d91 26
d127 1
a160 1
    Location origin;	/* First line number and file name of commands. */
@


1.19
log
@make has had heuristics to avoid parallel make recursion.
Sometimes they mess up, so add .CHEAP/.EXPENSIVE to explicitly tell make
'hey this is not THAT bad' or 'worse than you think'.
agreed by guenther@@, millert@@ (and some tweaks)
@
text
@d3 1
a3 1
/*	$OpenBSD: gnode.h,v 1.18 2012/03/22 13:47:12 espie Exp $ */
a134 1
    LIST expanded;	/* Expanded commands */
d143 6
@


1.18
log
@minor cleanup: error messages include lineno and fileno together, so
recognize that and create a struct Location_ for it.

mostly from Jonathan Calmels, a few nits from me.

okay otto@@
@
text
@d3 1
a3 1
/*	$OpenBSD: gnode.h,v 1.17 2010/07/19 19:46:44 espie Exp $ */
d208 2
@


1.17
log
@Correct $OpenBSD$ stuff
@
text
@d3 1
a3 1
/*	$OpenBSD: gnode.h,v 1.16 2010/07/19 19:30:37 espie Exp $ */
d36 3
d133 1
a133 2
    unsigned long lineno;/* First line number of commands.  */
    const char *fname;	/* File name of commands.  */
@


1.16
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d3 1
a3 2
/*	$OpenPackages$ */
/*	$OpenBSD$ */
@


1.15
log
@use unsigned values where applicable
@
text
@@


1.14
log
@changes to get target equivalence to work better.
- add new file to create lists of equivalent targets (siblings)
- use that for sequential mode to have much better VPATH support
- separate checking commands from reporting error, for later.
- zap DieHorribly accordingly
- renumber existing flags
- signal_running_jobs() is simpler than pass_signal_to_jobs()
- new debug option -dn for name matching.

Similar code to handle parallel make is still missing.

thanks to Mark, Miod, Theo, Otto, Todd for tests and/or comments.
@
text
@d74 1
a74 1
#define	UPTODATE	3
d81 5
a85 5
#define SPECIAL_NONE	0
#define	SPECIAL_PATH		21
#define SPECIAL_MASK		63
#define SPECIAL_TARGET		64
#define SPECIAL_SOURCE		128
d89 1
a89 1
    int special_op;	/* special op to apply */
d114 1
a114 1
    unsigned int type;		/* Its type (see the OP flags, below) */
@


1.13
log
@A few changes:
- expand commands earlier, so that we can eventually scan them to take
smarter decisions.
- clean up the select() mask code and rename variables to sensible things.
- quite a few minor renames for readability
- erecalloc
- clean up wait status handling, do not try to rebuild wait status, but
instead parse it early and deal with the parsed code.

tested by lots of people, thanks guys!
@
text
@d91 1
a91 1
    char must_make;		/* true if this target needs to be remade */
d112 1
d114 1
a114 1
    int type;		/* Its type (see the OP flags, below) */
d138 4
d145 5
a149 1
#define has_been_built(gn)	((gn)->built_status == MADE || (gn)->built_status == UPTODATE)
d186 1
a186 1
#define OP_INVISIBLE	0x00004000  /* The node is invisible to its parents.
d189 1
a189 1
#define OP_NOTMAIN	0x00008000  /* The node is exempt from normal 'main
d191 3
a193 3
#define OP_PHONY	0x00010000  /* Not a file target; run always */
#define OP_NOPATH	0x00020000  /* Don't search for file in the path */
#define OP_NODEFAULT	0x00040000  /* Special node that never needs */
d195 1
a195 1
#define OP_DUMMY	0x00080000  /* node was created by default, but it */
d198 5
a202 5
#define OP_TRANSFORM	0x80000000  /* The node is a transformation rule */
#define OP_MEMBER	0x40000000  /* Target is a member of an archive */
#define OP_LIB		0x20000000  /* Target is a library */
#define OP_ARCHV	0x10000000  /* Target is an archive construct */
#define OP_HAS_COMMANDS 0x08000000  /* Target has all the commands it should.
d205 1
a205 1
#define OP_DEPS_FOUND	0x02000000  /* Already processed by Suff_FindDeps */
@


1.12
log
@zap field nothing uses.
@
text
@d133 1
@


1.11
log
@more parallel make fixes.

Preparations to fix the engine:
- new function has_been_built(gn), that tells you what's the status of
a given node. Allows us to run Suff_FindDeps later, by updating the number
of unmade children correctly.
- take out the code that handles shell expansions in an expand_children*
set of functions, called by Suff_FindDeps, among others. These must be
called early in the engine to avoid creating bogus nodes.

Engine fixes:
- take the predecessor/successor special handling out, deal with it in
separate functions.
- don't count nodes. Explicitly track them all in a hash table (better
way to deal with non-built issues).
- don't run Suff_FindDeps at start, but just before building an actual node.
This allows make to find all dependencies correctly, as in groff.

Pfiou! now it works.
@
text
@a132 2
    LstNode current;	/* Current command, for job */

@


1.10
log
@UNMADE -> UNKNOWN
@
text
@d141 1
@


1.9
log
@rename make -> must_make, made -> built_status
to make them easier to find in source files.
@
text
@d71 1
a71 1
#define UNMADE		0
d96 2
a97 4
			 *  UNMADE - Not examined yet
			 *  BEINGMADE - Target is already being made.
			 *	Indicates a cycle in the graph. (compat
			 *	mode only)
d103 1
a103 1
			 *	an error making an inferior (compat).
@


1.8
log
@simplify the way we deal with implicit rules and handle $<.

Having an `iParents' field is actually backwards, it's ways simpler to
store the pointer in the child, as an impliedsrc, and to set the variable
just in time along with all the rest in DoAllVar.

This is simpler, and it should allow us to call SuffFindDeps much later.
@
text
@d91 1
a91 1
    char make;		/* true if this target needs to be remade */
d94 1
a94 1
    char made;		/* Set to reflect the state of processing
d109 1
a109 1
			 *	and 'made' is changed to ENDCYCLE.
@


1.7
log
@Work done at p2k7.


This is a really big step towards getting parallel make to work.


Note that this is not yet complete. There are still a few `details' to
fix before this works 100%.  Specifically: sequential make (compat) and
parallel make don't use the same engine, and the parallel engine still
has a few limitations. For instance, some known issues:
- parallel make does not deal with .phony targets correctly all the time.
- some errors are deadly in parallel make mode.
- parallel make NEEDS way more sturdy correspondance of file system paths
and target names, since it often needs to match dependencies to targets
before the corresponding files exist.
- some local variables like $* get set in a bogus way in some cases.
- suffix handling has issues, especially related to the NULL suffix.
So, if you find stuff that does NOT yet work with parallel make, don't go
blindly try to fix the Makefile. It's very likely you might have stumbled
into a make bug. (unless you really, really, understand Makefiles, DON'T
GO CHANGING THEM YET).



Tested by lots of people, thanks go to miod@@, and robert@@ among other people.

Quick summary of what this does:

- remove `saving commands' extension (it's not really usable, nor used)
- move compat job runner and parallel interrupt handling into engine.c
- tweak the code so that both compat and parallel mode use the same job runner
and the same interrupt handling. Remove the other one.
- optimize job runner so that, in parallel mode, the last command does not
fork if we can avoid it (as it's already running in a sub shell).
- scrape all the code that dealt with creating shell scripts from commands.
- scrape all the code that dealt with recognizing special sequences in
command output to print/not print output.
- fix the parallel job pipe to not keep around file descriptors that are not
needed.
- replace the parallel job buffering with a nicer one, that deals with
non-blocking descriptors to try to agregate as much output from one job in
one go (greed) to unconfuse the users.
- create two pipes per job, so that stdout and stderr stay separate.
- make job token printing a debug option.
- always use the parallel job-runner to `execute' commands, even if we just
print them out.
- store list of errors encountered during parallel make running, and print them
on exit, so that we know what went wrong.
- add a dirty hack to targ.c to deal with paths produced by gccmakedep.
@
text
@d124 1
a124 2
    LIST iParents;	/* Links to parents for which this is an
			 * implied source, if any */
@


1.6
log
@put parsing of operator (:, ::, !) into its own function
@
text
@a198 1
#define OP_SAVE_CMDS	0x04000000  /* Saving commands on .END (Compat) */
d200 1
@


1.5
log
@rewrite of the basic suffix/target parsing: use hash for suffixes.

Store special targets in target hash, and use them for the parsing.

Use OP_DUMMY flag to mark targets that don't really exist yet, such
as interrupt and default nodes.

Also, .PATHxxx is special in suffixes.

Small tweaks to compat.c, so that run_commands does more stuff after
the fork() (and thus no need to free things).

Remove distinction between local and global jobs.
@
text
@d4 1
a4 1
/*	$OpenBSD: gnode.h,v 1.4 2001/11/23 23:42:45 deraadt Exp $ */
d158 1
@


1.4
log
@back out changes that break kernel compiles.  good testing jobmk install!
@
text
@d4 1
a4 1
/*	$OpenBSD: gnode.h,v 1.2 2001/09/19 10:58:07 mpech Exp $ */
d70 18
d89 53
a141 54
    char	    *path;	/* The full pathname of the file */
    int 	    type;	/* Its type (see the OP flags, below) */
    int 	    order;	/* Its wait weight */

    bool	    make;	/* true if this target needs to be remade */
    enum {
	UNMADE, BEINGMADE, MADE, UPTODATE, ERROR, ABORTED,
	CYCLE, ENDCYCLE
    }		    made;	/* Set to reflect the state of processing
				 * on this node:
				 *  UNMADE - Not examined yet
				 *  BEINGMADE - Target is already being made.
				 *	Indicates a cycle in the graph. (compat
				 *	mode only)
				 *  MADE - Was out-of-date and has been made
				 *  UPTODATE - Was already up-to-date
				 *  ERROR - An error occurred while it was being
				 *	made (used only in compat mode)
				 *  ABORTED - The target was aborted due to
				 *	an error making an inferior (compat).
				 *  CYCLE - Marked as potentially being part of
				 *	a graph cycle. If we come back to a
				 *	node marked this way, it is printed
				 *	and 'made' is changed to ENDCYCLE.
				 *  ENDCYCLE - the cycle has been completely
				 *	printed. Go back and unmark all its
				 *	members.
				 */
    bool	    childMade;	/* true if one of this target's children was
				 * made */
    int 	    unmade;	/* The number of unmade children */

    TIMESTAMP	    mtime;	/* Its modification time */
    TIMESTAMP	    cmtime;	/* The modification time of its youngest
				 * child */

    LIST	    iParents;	/* Links to parents for which this is an
				 * implied source, if any */
    LIST	    cohorts;	/* Other nodes for the :: operator */
    LIST	    parents;	/* Nodes that depend on this one */
    LIST	    children;	/* Nodes on which this one depends */
    LIST	    successors; /* Nodes that must be made after this one */
    LIST	    preds;	/* Nodes that must be made before this one */

    SymTable	    context;	/* The local variables */
    unsigned long   lineno;	/* First line number of commands.  */
    const char *    fname;	/* File name of commands.  */
    LIST	    commands;	/* Creation commands */
    LstNode	    current;	/* Current command, for job */

    struct Suff_    *suffix;	/* Suffix for the node (determined by
				 * Suff_FindDeps and opaque to everyone
				 * but the Suff module) */
    char      name[1];		/* The target's name */
d171 1
a171 1
#define OP_MAKE 	0x00000200  /* Target is a recurrsive make so its
d186 4
@


1.3
log
@Explicitly mark nodes whose commands have been filled with
implicit (suffix) rules.  Then, only expand the IMPSRC/< variable
if the node has been marked.

This matches what Single Unix 2 and common sense say: implicit rules
shouldn't count when an explicit rule has been found (an explicit rule
being a full-scale dependency, with some associated commands)

Note that Single Unix leaves the `PREFIX' question open, so we leave
the PREFIX code as it is.

This fixes regression case mk14, which now fails as it should.

This is just a bug-fix. Some more correct (and faster) code should
probably be substituted. Namely, right now, the suffix code is too
greedy, whereas it should test for explicit rules earlier, and not
even bother instantiating implicit rules from templates when they
duplicate actual existing rules.

ok millert@@
@
text
@a178 1
#define OP_IS_SUFFIX	0x01000000  /* Cmds filled by suffix rule */
@


1.2
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d4 1
a4 1
/*	$OpenBSD: gnode.h,v 1.1 2001/05/23 12:34:43 espie Exp $ */
d179 1
@


1.1
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d4 1
a4 1
/*	$OpenBSD$ */
d87 1
a87 1
				 *  ERROR - An error occured while it was being
@

