head	1.25;
access;
symbols
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.14
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.6
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.10
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.8
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.8
	OPENBSD_5_0:1.19.0.6
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.17.0.4
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.12.0.14
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.12
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.10
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.8
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.8
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.25
date	2015.09.27.16.58.16;	author guenther;	state Exp;
branches;
next	1.24;
commitid	aJ83imcowNDDIDkP;

1.24
date	2012.10.18.17.54.43;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2012.10.02.10.29.30;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2012.03.22.13.50.30;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2012.03.22.13.47.12;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.04.07.22.35;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2008.01.12.13.08.59;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.03.10.41.48;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.02.17.27.24;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.07.13.11.35;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.17.11.58.56;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.05.22.32.41;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.18.14.49.13;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.29.12.17.05;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.23.12.34.42;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.03.13.41.04;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.13.08.29.20;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.23.16.27.29;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.08.19.07.13;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.12.09.18.20.06;	author espie;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Mark all the error printing functions as printf-like; fix two format
mismatches this revealed

ok espie@@
@
text
@/*	$OpenBSD: error.c,v 1.24 2012/10/18 17:54:43 espie Exp $ */

/*
 * Copyright (c) 2001 Marc Espie.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <sys/types.h>
#include <unistd.h>

#include "config.h"
#include "defines.h"
#include "error.h"
#include "job.h"
#include "targ.h"
#include "var.h"
#ifndef LOCATION_TYPE
#include "location.h"
#endif

#include "lowparse.h"
#include "dump.h"

int fatal_errors = 0;

static void ParseVErrorInternal(const Location *, int, const char *, va_list)
			__attribute__((__format__ (printf, 3, 0)));
/*-
 * Error --
 *	Print an error message given its format.
 */
void
Error(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
}

/*-
 * Fatal --
 *	Produce a Fatal error message. If jobs are running, waits for them
 *	to finish.
 *
 * Side Effects:
 *	The program exits
 */
void
Fatal(const char *fmt, ...)
{
	va_list ap;

	Job_Wait();

	va_start(ap, fmt);
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");

	if (DEBUG(GRAPH2))
		post_mortem();
	exit(2);		/* Not 1 so -q can distinguish error */
}

/*
 * Punt --
 *	Major exception once jobs are being created. Kills all jobs, prints
 *	a message and exits.
 *
 * Side Effects:
 *	All children are killed indiscriminately and the program Lib_Exits
 */
void
Punt(const char *fmt, ...)
{
	if (fmt) {
		va_list ap;

		va_start(ap, fmt);
		(void)fprintf(stderr, "make: ");
		(void)vfprintf(stderr, fmt, ap);
		va_end(ap);
		(void)fprintf(stderr, "\n");
	}

	Job_AbortAll();
	if (DEBUG(GRAPH2))
		post_mortem();
	exit(2);		/* Not 1, so -q can distinguish error */
}

/*
 * Finish --
 *	Called when aborting due to errors in command or fatal signal
 *
 * Side Effects:
 *	The program exits
 */
void
Finish()
{
	Job_Wait();
	print_errors();
	if (DEBUG(GRAPH2))
		post_mortem();
	exit(2);		/* Not 1 so -q can distinguish error */
}


/*-
 * ParseVErrorInternal	--
 *	Error message abort function for parsing. Prints out the context
 *	of the error (line number and file) as well as the message with
 *	two optional arguments.
 *
 * Side Effects:
 *	"fatals" is incremented if the level is PARSE_FATAL.
 */
static void
ParseVErrorInternal(const Location *origin, int type, const char *fmt, 
    va_list ap)
{
	static bool first = true;
	fprintf(stderr, "*** %s",
	    type == PARSE_WARNING ? "Warning" : "Parse error");
	if (first) {
		fprintf(stderr, " in %s: ", Var_Value(".CURDIR"));
		first = false;
	} else
		fprintf(stderr, ": ");
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	if (origin->fname)
	    	fprintf(stderr, " (%s:%lu)", origin->fname, origin->lineno);
	fprintf(stderr, "\n");
	if (type == PARSE_FATAL)
		fatal_errors ++;
}

/*-
 * Parse_Error	--
 *	External interface to ParseVErrorInternal; uses the default filename
 *	Line number.
 */
void
Parse_Error(int type, const char *fmt, ...)
{
	va_list ap;
	Location l;

	va_start(ap, fmt);
	Parse_FillLocation(&l);
	ParseVErrorInternal(&l, type, fmt, ap);
	va_end(ap);
}
@


1.24
log
@numerous error message fixes:
- do ^C checking differently: don't record sent signals, but when jobs
die, recheck whether we received/have pending a INT/QUIT/TERM/HUP signal.
Then don't display our process group "normally", instead group together
everything dying by signal/shell dying by signal (just give the target
names).

- make certain we always handle signals before dying from "other conditions"
- have the parser messages look more like normal messages
- remove double error messages from some parser errors
- make sure unclosed variables ARE errors when some modifiers are present

- keep track of the base directory we're run from, so that submakes can
get shortened directories...
- make sure the whole error message including silent command fits into a
reasonable length.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: error.c,v 1.23 2012/10/02 10:29:30 espie Exp $ */
d49 2
a50 1
static void ParseVErrorInternal(const Location *, int, const char *, va_list);
a54 1
/* VARARGS */
d56 1
a56 1
Error(char *fmt, ...)
a73 1
/* VARARGS */
d75 1
a75 1
Fatal(char *fmt, ...)
a98 1
/* VARARGS */
d100 1
a100 1
Punt(char *fmt, ...)
a144 1
/* VARARGS */
a170 1
/* VARARGS */
@


1.23
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: error.c,v 1.22 2012/09/21 07:55:20 espie Exp $ */
d152 10
d163 2
a164 6
	    (void)fprintf(stderr, "\"%s\", line %lu: ", origin->fname, origin->lineno);
	if (type == PARSE_WARNING)
		(void)fprintf(stderr, "warning: ");
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
a185 1

@


1.22
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d1 1
a1 1
/*	$OpenBSD: error.c,v 1.21 2012/03/22 13:50:30 espie Exp $ */
d45 1
d88 1
a88 1
		Targ_PrintGraph(2);
d116 1
a116 1
		Targ_PrintGraph(2);
d133 1
a133 1
		Targ_PrintGraph(2);
@


1.21
log
@tweak: consistent include guards, no change in generated code.
@
text
@d1 1
a1 1
/*	$OpenBSD: error.c,v 1.20 2012/03/22 13:47:12 espie Exp $ */
a46 1
bool supervise_jobs = false;
d79 1
a79 2
	if (supervise_jobs)
		Job_Wait();
d103 2
a104 1
	va_list ap;
d106 6
a111 5
	va_start(ap, fmt);
	(void)fprintf(stderr, "make: ");
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
d121 1
a121 2
 *	Called when aborting due to errors in child shell to signal
 *	abnormal exit.
d127 1
a127 1
Finish(int errors) /* number of errors encountered in Make_Make */
a129 3
	if (errors != 0) {
		Error("Stop in %s:", Var_Value(".CURDIR"));
	}
@


1.20
log
@minor cleanup: error messages include lineno and fileno together, so
recognize that and create a struct Location_ for it.

mostly from Jonathan Calmels, a few nits from me.

okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: error.c,v 1.19 2010/07/19 19:46:44 espie Exp $ */
d40 1
d42 1
@


1.19
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: error.c,v 1.18 2010/07/19 19:30:37 espie Exp $ */
d40 1
d47 1
a47 1
static void ParseVErrorInternal(const char *, unsigned long, int, const char *, va_list);
d150 2
a151 2
ParseVErrorInternal(const char *cfname, unsigned long clineno, int type,
	const char *fmt, va_list ap)
d153 2
a154 2
	if (cfname)
	    (void)fprintf(stderr, "\"%s\", line %lu: ", cfname, clineno);
d174 1
d177 2
a178 2
	ParseVErrorInternal(Parse_Getfilename(), Parse_Getlineno(), type,
	    fmt, ap);
@


1.18
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$ */
@


1.17
log
@changes to get target equivalence to work better.
- add new file to create lists of equivalent targets (siblings)
- use that for sequential mode to have much better VPATH support
- separate checking commands from reporting error, for later.
- zap DieHorribly accordingly
- renumber existing flags
- signal_running_jobs() is simpler than pass_signal_to_jobs()
- new debug option -dn for name matching.

Similar code to handle parallel make is still missing.

thanks to Mark, Miod, Theo, Otto, Todd for tests and/or comments.
@
text
@@


1.16
log
@better error reporting/job handling error:
- systematically reorder jobs based on who did output last, so that the
last job to output is *first* to output again.
- better reaction to errors: any job that outputs is checked for termination
directly, and the Error message is printed right afterwards.
- better error messages, giving more useful information in -j mode.
@
text
@a110 13
	DieHorribly();
}

/*-
 * DieHorribly --
 *	Exit without giving a message.
 *
 * Side Effects:
 *	A big one...
 */
void
DieHorribly(void)
{
@


1.15
log
@fix an obnoxious bug: in parallel mode, dieing in the job controller is not
the same as dieing in a sub job, since waiting on sub-jobs won't work.
So keep track of who we are via a state variable.
@
text
@d143 1
a143 3
		Error("make pid #%ld: %d error%s in directory %s:", (long)getpid(), 
		    errors, errors == 1 ? "" : "s", 
		    Var_Value(".CURDIR"));
@


1.14
log
@Work done at p2k7.


This is a really big step towards getting parallel make to work.


Note that this is not yet complete. There are still a few `details' to
fix before this works 100%.  Specifically: sequential make (compat) and
parallel make don't use the same engine, and the parallel engine still
has a few limitations. For instance, some known issues:
- parallel make does not deal with .phony targets correctly all the time.
- some errors are deadly in parallel make mode.
- parallel make NEEDS way more sturdy correspondance of file system paths
and target names, since it often needs to match dependencies to targets
before the corresponding files exist.
- some local variables like $* get set in a bogus way in some cases.
- suffix handling has issues, especially related to the NULL suffix.
So, if you find stuff that does NOT yet work with parallel make, don't go
blindly try to fix the Makefile. It's very likely you might have stumbled
into a make bug. (unless you really, really, understand Makefiles, DON'T
GO CHANGING THEM YET).



Tested by lots of people, thanks go to miod@@, and robert@@ among other people.

Quick summary of what this does:

- remove `saving commands' extension (it's not really usable, nor used)
- move compat job runner and parallel interrupt handling into engine.c
- tweak the code so that both compat and parallel mode use the same job runner
and the same interrupt handling. Remove the other one.
- optimize job runner so that, in parallel mode, the last command does not
fork if we can avoid it (as it's already running in a sub shell).
- scrape all the code that dealt with creating shell scripts from commands.
- scrape all the code that dealt with recognizing special sequences in
command output to print/not print output.
- fix the parallel job pipe to not keep around file descriptors that are not
needed.
- replace the parallel job buffering with a nicer one, that deals with
non-blocking descriptors to try to agregate as much output from one job in
one go (greed) to unconfuse the users.
- create two pipes per job, so that stdout and stderr stay separate.
- make job token printing a debug option.
- always use the parallel job-runner to `execute' commands, even if we just
print them out.
- store list of errors encountered during parallel make running, and print them
on exit, so that we know what went wrong.
- add a dirty hack to targ.c to deal with paths produced by gccmakedep.
@
text
@d44 3
a46 1
int	    fatal_errors = 0;
d78 3
a81 2
	Job_Wait();

@


1.13
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: error.c,v 1.12 2004/04/07 13:11:35 espie Exp $ */
d32 2
d40 1
d138 10
a147 1
	Fatal("%d error%s", errors, errors == 1 ? "" : "s");
@


1.12
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: error.c,v 1.11 2002/05/17 11:58:56 espie Exp $ */
d150 1
a150 1
ParseVErrorInternal(const char *cfname, unsigned long clineno, int type, 
d176 1
a176 1
	ParseVErrorInternal(Parse_Getfilename(), Parse_Getlineno(), type, 
@


1.11
log
@oops, worked only because va_end is a noop on most of our arches.
@
text
@d2 1
a2 1
/*	$OpenBSD: error.c,v 1.10 2002/02/19 19:39:38 millert Exp $ */
d116 1
a116 1
DieHorribly()
d133 1
a133 2
Finish(errors)
	int errors;	/* number of errors encountered in Make_Make */
d176 2
a177 1
	ParseVErrorInternal(Parse_Getfilename(), Parse_Getlineno(), type, fmt, ap);
@


1.10
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d2 1
a2 1
/*	$OpenBSD: error.c,v 1.9 2001/09/05 22:32:41 deraadt Exp $ */
d178 1
a178 1
	va_end(va);
@


1.9
log
@make sure that va_start() has matching va_end()
@
text
@d2 1
a2 1
/*	$OpenBSD: error.c,v 1.8 2001/07/18 14:49:13 espie Exp $ */
a27 5
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif
d31 1
a48 1
#ifdef __STDC__
a49 4
#else
Error(va_alist)
	va_dcl
#endif
d52 1
a52 1
#ifdef __STDC__
a53 6
#else
	char *fmt;

	va_start(ap);
	fmt = va_arg(ap, char *);
#endif
a68 1
#ifdef __STDC__
a69 4
#else
Fatal(va_alist)
	va_dcl
#endif
d72 1
a72 1
#ifdef __STDC__
a73 6
#else
	char *fmt;

	va_start(ap);
	fmt = va_arg(ap, char *);
#endif
a94 1
#ifdef __STDC__
a95 4
#else
Punt(va_alist)
	va_dcl
#endif
d98 1
a98 1
#ifdef __STDC__
a99 7
#else
	char *fmt;

	va_start(ap);
	fmt = va_arg(ap, char *);
#endif

a150 1
#ifdef __STDC__
a152 4
#else
ParseVErrorInternal(va_alist)
	va_dcl
#endif
a171 1
#ifdef __STDC__
a172 4
#else
Parse_Error(va_alist)
	va_dcl
#endif
d175 1
a175 1
#ifdef __STDC__
a176 9
#else
	int type;		/* Error type (PARSE_WARNING, PARSE_FATAL) */
	char *fmt;

	va_start(ap);
	type = va_arg(ap, int);
	fmt = va_arg(ap, char *);
#endif

@


1.8
log
@Avoid dumping core when reporting open conditionals.
Turns out that current is NULL when Parse_Fatal is called in this case,
so just do something sensible in error reporting functions when current is
NULL...
@
text
@d2 1
a2 1
/*	$OpenBSD: error.c,v 1.7 2001/05/29 12:17:05 espie Exp $ */
d235 1
@


1.7
log
@Blech! gcc is a stupid program. Compiling with -fno-builtin shows lots
of missing function declarations.
@
text
@d2 1
a2 1
/*	$OpenBSD: error.c,v 1.6 2001/05/23 12:34:42 espie Exp $ */
d197 2
a198 1
	(void)fprintf(stderr, "\"%s\", line %lu: ", cfname, clineno);
@


1.6
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD$ */
d35 1
@


1.5
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d1 2
a2 2
/* $OpenPackages$ */
/* $OpenBSD$ */
d5 1
a5 7
 * Copyright (c) 1988, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
d15 19
a33 24
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
d35 3
a37 3
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
d39 4
d44 10
a53 2
#ifdef __GNUC__
#define UNUSED	__attribute__((unused))
d55 2
a56 1
#define UNUSED
d58 6
d65 6
a70 15
static void enomem(size_t);

/*
 * emalloc --
 *	malloc, but die on error.
 */
void *
emalloc(len)
	size_t len;
{
	void *p;

	if ((p = malloc(len)) == NULL)
		enomem(len);
	return p;
d73 7
a79 3
/*
 * estrdup --
 *	strdup, but die on error.
d81 8
a88 3
char *
estrdup(str)
	const char *str;
d90 5
a94 2
	char *p;
	size_t size;
d96 8
a103 1
	size = strlen(str) + 1;
d105 3
a107 3
	p = emalloc(size);
	memcpy(p, str, size);
	return p;
d111 6
a116 2
 * erealloc --
 *	realloc, but die on error.
d118 8
a125 4
void *
erealloc(ptr, size)
	void *ptr;
	size_t size;
d127 5
a131 4
	if ((ptr = realloc(ptr, size)) == NULL)
		enomem(size);
	return ptr;
}
d133 3
a135 6
void *
ecalloc(s1, s2)
	size_t s1;
	size_t s2;
{
	void *p;
d137 4
a140 4
	if ((p = calloc(s1, s2)) == NULL)
		enomem(s1 * s2);
	return p;
}
d142 1
a142 7
/* Support routines for hash tables.  */
void *
hash_alloc(s, u)
	size_t s;
	void *u 	UNUSED;
{
	return ecalloc(s, 1);
d145 7
d153 1
a153 4
hash_free(p, s, u)
	void *p;
	size_t s	UNUSED;
	void *u 	UNUSED;
d155 4
a158 1
	free(p);
d161 11
a171 4
void *
element_alloc(s, u)
	size_t s;
	void *u 	UNUSED;
d173 1
a173 1
	return emalloc(s);
d177 8
a184 4

/*
 * enomem --
 *	die when out of memory.
d186 9
a194 3
void
enomem(size)
	size_t size;
d196 14
a209 7
	fprintf(stderr, "make: %s (%lu)\n", strerror(errno), (u_long)size);
	exit(2);
}

/*
 * esetenv --
 *	change environment, die on error.
d211 1
d213 6
a218 3
esetenv(name, value)
	const char *name;
	const char *value;
d220 6
a225 2
	if (setenv(name, value, 1) == 0)
	    return;
d227 4
a230 3
	fprintf(stderr, "make: setenv failed (%s)\n", strerror(errno));
	exit(2);
}
d232 1
a232 19

/*
 * enunlink --
 *	Remove a file carefully, avoiding directories.
 */
int
eunlink(file)
	const char *file;
{
	struct stat st;

	if (lstat(file, &st) == -1)
		return -1;

	if (S_ISDIR(st.st_mode)) {
		errno = EISDIR;
		return -1;
	}
	return unlink(file);
@


1.4
log
@esetenv: does a setenv and bails out if error.
@
text
@d1 2
a2 1
/* $OpenBSD: error.c,v 1.3 2000/06/23 16:27:29 espie Exp $ */
d51 7
a57 1
static void enomem __P((size_t));
d122 1
a122 1
	void *u;
d130 2
a131 2
	size_t s;
	void *u;
d139 1
a139 1
	void *u;
d143 3
a145 1
	
d174 1
d194 1
@


1.3
log
@This is the speed-up patch, which doubles make speed (almost).

Use the open hashing functions for global contexts instead of List in
var.c.

All the preliminary work to trim down local contexts means that we don't
suffer from the heavy initialization work that a hash table entails.

There is some make kludgery to:
- build the hashing functions as a library,
- recreate hashconsts.h, even if make depend was not invoked.

One point of the hashing scheme written was to separate the computation
of the hash function, and the hash lookup itself. This is very convenient
for make, because of those pesky special variables. hashconsts.h is there
to pre-hash the correct values, which replaces a few expensive string
comparisons with quick hash value comparisons, followed by one expensive
string comparison. The modulus MAGICSLOTS chosen in the Makefile is
ad-hoc: it is small enough to write a small switch without collision,
and will need changing if the hash function changes...

The function quick_lookup is the most important:
it either returns an index, for a local variable, or it does compute a
hashing value, and returns -1.

Another somewhat controversial decision is the use of string intervals.
This avoids either copying a string, or twiddling with a byte for cases
such as ${VAR}.

Finally, the variable name is stored within the variable itself. Since
a given variable name never changes, this makes sense. All that was needed
was a hash library with support for this.  Note that the hashing table
holds only a variable pointer AND the corresponding hashing value, WITHOUT
a modulo hashtablesize. Two reasons:
- hash resizes can be done faster, without having to recompute hashing values.
- locality of access. The hash table fits into memory without problem. Once
a candidate slot is found, we check the complete hashing value. Probability
of a collision is very small (32 bits...). So bringing up the whole
variable in memory at once is good: the name will almost always match, in
which case we want the variable value as well, so it makes sense to put
them together.

The ohash functions implement open hashing, as described in Knuth, but with
a variable table size.  Choosing powers of 2 sizes does not yield more
collisions, but it makes the hashing scheme much simpler. The thresholds at
which to expand/shrink the tables seem to work well in practice. The
default sizes were chosen such that the tables hardly ever shrink or expand
anyways (though I've tried with smaller/larger sizes to verify that the
shrinking/expanding worked correctly): larger Makefiles hold roughly
500/600 variables, which fits without trouble into a 1024-sized variable.

Disregard #ifdef STATS_HASH, this is some internal scaffolding I'm using
to measure make performance.

The only known issue with open-hashing is that deletions cannot create
empty slots, but do leave slots marked as `occupied once' so that lookup
works.  We use a well-known optimization which records those pseudo-empty
slots while looking up values. If the value is not found, the pseudo-empty
slot is returned to be filled. If the value is found, it is swapped with
the pseudo-empty slot. This is an improvement in both cases, since this
shortens the length of lookup chains, eventually pushing the pseudo-empty
slots to the end.

Reviewed by millert@@ and miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: error.c,v 1.2 2000/01/08 19:07:13 millert Exp $ */
d145 15
a159 1
	int myerr = errno;
d161 1
a161 1
	fprintf(stderr, "make: %s (%lu)\n", strerror(myerr), (u_long)size);
@


1.2
log
@Silence gcc -Wall on alpha in enomem() printf via cast to u_long.
@
text
@d1 1
a1 1
/* $OpenBSD: error.c,v 1.1 1999/12/09 18:20:06 espie Exp $ */
d111 26
@


1.1
log
@Split some allocation/error handling functions out of main.c
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d121 1
a121 1
	fprintf(stderr, "make: %s (%d)\n", strerror(myerr), size);
a143 1

@

