head	1.91;
access;
symbols
	OPENBSD_6_0:1.90.0.8
	OPENBSD_6_0_BASE:1.90
	OPENBSD_5_9:1.90.0.4
	OPENBSD_5_9_BASE:1.90
	OPENBSD_5_8:1.90.0.6
	OPENBSD_5_8_BASE:1.90
	OPENBSD_5_7:1.90.0.2
	OPENBSD_5_7_BASE:1.90
	OPENBSD_5_6:1.88.0.4
	OPENBSD_5_6_BASE:1.88
	OPENBSD_5_5:1.87.0.4
	OPENBSD_5_5_BASE:1.87
	OPENBSD_5_4:1.85.0.2
	OPENBSD_5_4_BASE:1.85
	OPENBSD_5_3:1.84.0.2
	OPENBSD_5_3_BASE:1.84
	OPENBSD_5_2:1.80.0.2
	OPENBSD_5_2_BASE:1.80
	OPENBSD_5_1_BASE:1.79
	OPENBSD_5_1:1.79.0.8
	OPENBSD_5_0:1.79.0.6
	OPENBSD_5_0_BASE:1.79
	OPENBSD_4_9:1.79.0.4
	OPENBSD_4_9_BASE:1.79
	OPENBSD_4_8:1.79.0.2
	OPENBSD_4_8_BASE:1.79
	OPENBSD_4_7:1.77.0.8
	OPENBSD_4_7_BASE:1.77
	OPENBSD_4_6:1.77.0.10
	OPENBSD_4_6_BASE:1.77
	OPENBSD_4_5:1.77.0.6
	OPENBSD_4_5_BASE:1.77
	OPENBSD_4_4:1.77.0.4
	OPENBSD_4_4_BASE:1.77
	OPENBSD_4_3:1.77.0.2
	OPENBSD_4_3_BASE:1.77
	OPENBSD_4_2:1.60.0.2
	OPENBSD_4_2_BASE:1.60
	OPENBSD_4_1:1.56.0.2
	OPENBSD_4_1_BASE:1.56
	OPENBSD_4_0:1.54.0.8
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.54.0.6
	OPENBSD_3_9_BASE:1.54
	OPENBSD_3_8:1.54.0.4
	OPENBSD_3_8_BASE:1.54
	OPENBSD_3_7:1.54.0.2
	OPENBSD_3_7_BASE:1.54
	OPENBSD_3_6:1.53.0.2
	OPENBSD_3_6_BASE:1.53
	OPENBSD_3_5:1.50.0.4
	OPENBSD_3_5_BASE:1.50
	OPENBSD_3_4:1.50.0.2
	OPENBSD_3_4_BASE:1.50
	OPENBSD_3_3:1.49.0.6
	OPENBSD_3_3_BASE:1.49
	OPENBSD_3_2:1.49.0.4
	OPENBSD_3_2_BASE:1.49
	OPENBSD_3_1:1.49.0.2
	OPENBSD_3_1_BASE:1.49
	OPENBSD_3_0:1.43.0.2
	OPENBSD_3_0_BASE:1.43
	OPENBSD_2_9_BASE:1.40
	OPENBSD_2_9:1.40.0.2
	OPENBSD_2_8:1.38.0.2
	OPENBSD_2_8_BASE:1.38
	OPENBSD_2_7:1.25.0.2
	OPENBSD_2_7_BASE:1.25
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.91
date	2016.10.21.16.12.38;	author espie;	state Exp;
branches;
next	1.90;
commitid	aLVdeKrJ0t5upS3l;

1.90
date	2015.01.23.22.35.58;	author espie;	state Exp;
branches;
next	1.89;
commitid	WtGGWUPWONvkhNGN;

1.89
date	2015.01.23.13.18.40;	author espie;	state Exp;
branches;
next	1.88;
commitid	iXa5WmoY9RgeqDsn;

1.88
date	2014.05.12.19.11.19;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2014.01.06.12.08.18;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2013.11.22.15.47.35;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2013.04.23.14.32.53;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2012.12.22.19.02.05;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2012.12.06.10.33.16;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2012.10.09.19.45.34;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2012.10.02.10.29.31;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2012.04.21.04.35.32;	author guenther;	state Exp;
branches;
next	1.79;

1.79
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2010.04.25.13.59.53;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2007.11.24.15.41.01;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2007.11.17.16.39.45;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2007.11.06.21.15.19;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2007.11.06.21.12.23;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2007.11.02.17.27.24;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2007.09.18.09.15.04;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2007.09.18.08.31.15;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2007.09.17.12.42.09;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2007.09.17.11.43.12;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2007.09.17.10.12.35;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2007.09.17.09.16.58;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2007.09.17.08.36.57;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2007.09.16.12.30.35;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2007.09.16.10.14.26;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2007.09.16.09.49.24;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2007.09.16.09.46.14;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2007.07.30.09.51.53;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2007.07.24.18.58.48;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2007.07.24.18.56.15;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2007.07.24.18.52.47;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2006.09.24.09.04.05;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2006.09.17.19.03.15;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2004.11.29.06.20.03;	author jsg;	state Exp;
branches;
next	1.53;

1.53
date	2004.06.19.13.34.30;	author robert;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.05.09.10.47;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2004.04.07.13.11.36;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.03.02.56.12;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.26.14.33.45;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2001.11.23.23.42.45;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2001.11.22.21.18.10;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2001.11.11.12.35.03;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.11.06.02.06;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.11.01.19.23;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2001.05.29.12.53.43;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.23.12.34.49;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2001.05.03.13.41.11;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2000.11.24.14.27.20;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2000.11.22.17.22.28;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2000.09.14.13.46.45;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2000.09.14.13.40.03;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.14.13.32.07;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2000.06.23.16.41.53;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.23.16.21.43;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.23.16.20.01;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.23.16.18.09;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.23.16.15.50;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.17.14.43.36;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.17.14.38.19;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.10.01.41.06;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.10.01.32.23;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.10.01.26.37;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.26.16.21.33;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2000.03.26.15.51.31;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.14.19.00.32;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2000.01.08.09.45.15;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	99.12.19.00.04.25;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	99.12.18.21.58.07;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	99.12.18.21.56.07;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	99.12.18.21.53.33;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	99.12.18.02.11.27;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	99.12.16.17.27.18;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	99.12.06.22.28.44;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	99.10.05.22.06.24;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	99.03.06.20.27.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.03.06.20.19.20;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.12.05.00.06.29;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	98.07.03.18.51.14;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.07.02.21.32.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.07.02.21.25.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.07.02.21.00.05;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.07.02.20.47.28;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.11.30.21.09.04;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.02.16.04.19;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.36.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.23.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.91
log
@small obvious cleanups:
- remove a lot of unnecessary casts
- zap extra param that's no longer needed
- add proper prototype and make function static

okay natano@@
@
text
@/*	$OpenBSD: suff.c,v 1.90 2015/01/23 22:35:58 espie Exp $ */
/*	$NetBSD: suff.c,v 1.13 1996/11/06 17:59:25 christos Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*-
 * suff.c --
 *	Functions to maintain suffix lists and find implicit dependents
 *	using suffix transformation rules
 *
 * Interface:
 *	Suff_Init		Initialize all things to do with suffixes.
 *
 *	Suff_ClearSuffixes	Clear out all the suffixes.
 *
 *	Suff_AddSuffix		Add the passed string as another known suffix.
 *
 *	Suff_ParseAsTransform	Line might be a suffix line, check it.
 *				If it's not, return NULL. Otherwise, add
 *				another transformation to the suffix graph.
 *				Returns	GNode suitable for framing, I mean,
 *				tacking commands, attributes, etc. on.
 *
 *	Suff_FindDeps		Find implicit sources for and the location of
 *				a target based on its suffix. Returns the
 *				bottom-most node added to the graph or NULL
 *				if the target had no implicit sources.
 */

#include <ctype.h>
#include <signal.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ohash.h>
#include "config.h"
#include "defines.h"
#include "dir.h"
#include "direxpand.h"
#include "engine.h"
#include "arch.h"
#include "suff.h"
#include "var.h"
#include "targ.h"
#include "error.h"
#include "str.h"
#include "lst.h"
#include "memory.h"
#include "gnode.h"
#include "make.h"
#include "stats.h"
#include "dump.h"

/* XXX the suffixes hash is stored using a specific hash function, suitable
 * for looking up suffixes in reverse.
 */
static struct ohash suffixes;

/* We remember the longest suffix, so we don't need to look beyond that.  */
size_t maxLen;
static LIST srclist;

/* Transforms (.c.o) are stored in another hash, independently from suffixes.
 * When make sees a target, it checks whether it's currently parsable as a
 * transform (according to the active suffixes). If yes, it's stored as a
 * new transform.
 *
 * XXX
 * But transforms DO NOT have a canonical decomposition as a set of suffixes,
 * and will be used as necessary later, when looking up implicit rules for
 * actual targets.
 *
 * For instance, a transform .a.b.c  can be parsed as .a -> .b.c if suffixes
 * .a and .b.c are active, and then LATER, reused as .a.b -> .c if suffixes
 * .a.b and .c are active.
 */
static struct ohash transforms;

/* conflicts between suffixes are solved by suffix declaration order. */
static int order = 0;

/*
 * Structure describing an individual suffix.
 */
struct Suff_ {
	size_t nameLen;		/* optimisation: strlen(name) */
	short flags;
#define SUFF_ACTIVE	  0x08	/* We never destroy suffixes and rules, */
				/* we just deactivate them. */
#define SUFF_PATH	  0x10	/* False suffix: actually, the path keyword */
	LIST searchPath;	/* The path along which files of this suffix
			     	 * may be found */
	int order;		/* order of declaration for conflict
				 * resolution. */
	LIST parents;		/* List of Suff we have a transformation to */
	LIST children;		/* List of Suff we have a transformation from */
	char name[1];
};

static struct ohash_info suff_info = {
	offsetof(struct Suff_, name), NULL,
	hash_calloc, hash_free, element_alloc
};

/*
 * Structure used in the search for implied sources.
 */
typedef struct Src_ {
	char *file;		/* The file to look for */
	char *prefix;		/* Prefix from which file was formed */
	Suff *suff;		/* The suffix on the file */
	struct Src_ *parent;	/* The Src for which this is a source */
	GNode *node;		/* The node describing the file */
	int children;		/* Count of existing children (so we don't free
				 * this thing too early or never nuke it) */
#ifdef DEBUG_SRC
	LIST	    cp; 	/* Debug; children list */
#endif
} Src;

/*
 * A structure for passing more than one argument to the Lst-library-invoked
 * function...
 */
typedef struct {
	Lst l;
	Src *s;
} LstSrc;

static Suff *emptySuff; /* The empty suffix required for POSIX
			 * single-suffix transformation rules */


#define parse_transform(s, p, q) parse_transformi(s, s + strlen(s), p, q)
static bool parse_transformi(const char *, const char *, Suff **, Suff **);
#define new_suffix(s)	new_suffixi(s, NULL)
static Suff *new_suffixi(const char *, const char *);
static void reverse_hash_add_char(uint32_t *, const char *);
static uint32_t reverse_hashi(const char *, const char **);
static unsigned int reverse_slot(struct ohash *, const char *, const char **);
static void clear_suffixes(void);
static void record_possible_suffix(Suff *, GNode *, char *, Lst, Lst);
static void record_possible_suffixes(GNode *, Lst, Lst);
static Suff *find_suffix_as_suffix(Lst, const char *, const char *);
static Suff *add_suffixi(const char *, const char *);

static void SuffInsert(Lst, Suff *);
static void SuffAddSrc(void *, void *);
static int SuffRemoveSrc(Lst);
static void SuffAddLevel(Lst, Src *);
static Src *SuffFindThem(Lst, Lst);
static Src *SuffFindCmds(Src *, Lst);
static void SuffExpandChildren(LstNode, GNode *);
static void SuffExpandVarChildren(LstNode, GNode *, GNode *);
static void SuffExpandWildChildren(LstNode, GNode *, GNode *);
static bool SuffApplyTransform(GNode *, GNode *, Suff *, Suff *);
static void SuffFindDeps(GNode *, Lst);
static void SuffFindArchiveDeps(GNode *, Lst);
static void SuffFindNormalDeps(GNode *, Lst);
static void SuffPrintName(void *);
static void SuffPrintSuff(void *);
static void SuffPrintTrans(GNode *);

#define find_suff(name)	find_suffi(name, NULL)
static Suff *find_suffi(const char *, const char *);
static Suff *find_best_suffix(const char *, const char *);
static GNode *find_transform(const char *);
static GNode *find_or_create_transformi(const char *, const char *);
static void setup_paths(void);
static void build_suffixes_graph(void);
static void special_path_hack(void);

#ifdef DEBUG_SRC
static void PrintAddr(void *);
#endif

/* hash functions for the suffixes hash */
/* add one char to the hash */
static void
reverse_hash_add_char(uint32_t *pk, const char *s)
{
	*pk =  ((*pk << 2) | (*pk >> 30)) ^ *s;
}

/* build a full hash from end to start */
static uint32_t
reverse_hashi(const char *s, const char **e)
{
	const char *p;
	uint32_t k;

	if (*e == NULL)
		*e = s + strlen(s);
	p = *e;
	if (p == s)
		k = 0;
	else
		k = *--p;
	while (p != s) {
		reverse_hash_add_char(&k, --p);
	}
	return k;
}

static unsigned int
reverse_slot(struct ohash *h, const char *s, const char **e)
{
	uint32_t hv;

	hv = reverse_hashi(s, e);
	return ohash_lookup_interval(h, s, *e, hv);
}


static char *
suffix_is_suffix(Suff *s, const char *str, const char *estr)
{
	const char *p1; 	/* Pointer into suffix name */
	const char *p2; 	/* Pointer into string being examined */

	if (estr - str < (ptrdiff_t) s->nameLen)
		return NULL;
	p1 = s->name + s->nameLen;
	p2 = estr;

	while (p1 != s->name) {
		p1--;
		p2--;
		if (*p1 != *p2)
			return NULL;
	}

	return (char *)p2;
}

static Suff *
find_suffi(const char *name, const char *ename)
{
	unsigned int slot;
#ifdef STATS_SUFF
	STAT_SUFF_LOOKUP_NAME++;
#endif
	slot = reverse_slot(&suffixes, name, &ename);
	return ohash_find(&suffixes, slot);
}

static GNode *
find_transform(const char *name)
{
	unsigned int slot;

#ifdef STATS_SUFF
	STAT_TRANSFORM_LOOKUP_NAME++;
#endif
	slot = ohash_qlookup(&transforms, name);

	return ohash_find(&transforms, slot);
}

static GNode *
find_or_create_transformi(const char *name, const char *end)
{
	GNode *r;
	unsigned int slot;

#ifdef STATS_SUFF
	STAT_TRANSFORM_LOOKUP_NAME++;
#endif
	slot = ohash_qlookupi(&transforms, name, &end);

	r = ohash_find(&transforms, slot);

	if (r == NULL) {
		r = Targ_NewGNi(name, end);
		ohash_insert(&transforms, slot, r);
	}
	return r;
}

/*-
 *-----------------------------------------------------------------------
 * SuffInsert  --
 *	Insert the suffix into the list keeping the list ordered by suffix
 *	numbers.
 *
 * Side Effects:
 *	The reference count of the suffix is incremented
 *-----------------------------------------------------------------------
 */
static void
SuffInsert(Lst l, Suff *s)
{
	LstNode ln;		/* current element in l we're examining */
	Suff *s2 = NULL;	/* the suffix descriptor in this element */

	for (ln = Lst_First(l); ln != NULL; ln = Lst_Adv(ln)) {
		s2 = Lst_Datum(ln);
		if (s2->order >= s->order)
			break;
	}

	if (DEBUG(SUFF))
		printf("inserting %s(%d)...", s->name, s->order);
	if (ln == NULL) {
		if (DEBUG(SUFF))
			printf("at end of list\n");
		Lst_AtEnd(l, s);
	} else if (s2->order != s->order) {
		if (DEBUG(SUFF))
			printf("before %s(%d)\n", s2->name, s2->order);
		Lst_Insert(l, ln, s);
	} else if (DEBUG(SUFF)) {
		printf("already there\n");
	}
}

/*-
 *-----------------------------------------------------------------------
 * Suff_ClearSuffixes --
 *	Nuke the list of suffixes but keep all transformation
 *	rules around.
 *
 * Side Effects:
 *	Current suffixes are reset
 *-----------------------------------------------------------------------
 */
static void
clear_suffixes(void)
{
	unsigned int i;
	Suff *s;

	for (s = ohash_first(&suffixes, &i); s != NULL;
	    s = ohash_next(&suffixes, &i))
		s->flags &= ~SUFF_ACTIVE;

	order = 0;
	maxLen = 0;
}

void
Suff_ClearSuffixes(void)
{
	clear_suffixes();
}


/* okay = parse_transform(str, &src, &targ);
 * 	try parsing a string as a transformation rule, returns true if
 *	successful. Fills &src, &targ with the constituent suffixes.
 * Special hack: source suffixes must exist OR be the special SUFF_PATH
 * pseudo suffix (.PATH)
 */
static bool
parse_transformi(const char *str, const char *e, Suff **srcPtr, Suff **targPtr)
{
	Suff *src, *target, *best_src, *best_target;
	const char *p;

	size_t len;
	uint32_t hv;
	unsigned int slot;

	/* empty string -> no suffix */
	if (e == str)
		return false;

	len = e - str;

	if (len > 2 * maxLen)
		return false;

	p = e;
	best_src = best_target = NULL;

	hv = *--p;
	while (p != str) {
		slot = ohash_lookup_interval(&suffixes, p, e, hv);
		/* no double suffix in there */
		if (p - str <= (ptrdiff_t)maxLen) {
			target = ohash_find(&suffixes, slot);
			if (target != NULL && (target->flags & SUFF_ACTIVE)) {
				src = find_suffi(str, p);
				if (src != NULL &&
				    (src->flags & (SUFF_ACTIVE | SUFF_PATH))) {
				/* XXX even if we find a set of suffixes, we
				 * have to keep going to find the best one,
				 * namely, the one whose src appears first in
				 * .SUFFIXES
				 */
					if (best_src == NULL ||
					    src->order < best_src->order) {
						best_src = src;
						best_target = target;
					}
				}
			}
		}
		/* can't be a suffix anyways */
		if (e - p >= (ptrdiff_t)maxLen)
			break;
		reverse_hash_add_char(&hv, --p);
	}

	if (p == str && best_src == NULL) {
		/* no double suffix transformation, resort to single suffix if
		 * we find one.  */
		slot = ohash_lookup_interval(&suffixes, p, e, hv);
		src = ohash_find(&suffixes, slot);
		if (src != NULL && (src->flags & (SUFF_ACTIVE | SUFF_PATH))) {
			best_src = src;
			best_target = emptySuff;
		}
	}
	if (best_src != NULL) {
		*srcPtr = best_src;
		*targPtr = best_target;
		return true;
	} else {
		return false;
	}
}

static void
special_path_hack(void)
{
	Suff *path = add_suffixi(".PATH", NULL);
	path->flags |= SUFF_PATH;
}

static Suff *
find_best_suffix(const char *s, const char *e)
{
	const char *p;
	uint32_t hv;
	unsigned int slot;
	Suff *best = NULL;
	Suff *suff;

	if (e == s)
		return NULL;
	p = e;
	hv = *--p;
	while (p != s) {
		slot = ohash_lookup_interval(&suffixes, p, e, hv);
		suff = ohash_find(&suffixes, slot);
		if (suff != NULL)
			if (best == NULL || suff->order < best->order)
				best = suff;
		if (e - p >= (ptrdiff_t)maxLen)
			break;
		reverse_hash_add_char(&hv, --p);
	}
	return best;
}

/*-
 *-----------------------------------------------------------------------
 * Suff_ParseAsTransform --
 *	Try parsing a target line as a transformation rule, depending on
 *	existing suffixes.
 *
 *	Possibly create a new transform, or reset an existing one.
 *-----------------------------------------------------------------------
 */
GNode *
Suff_ParseAsTransform(const char *line, const char *end)
{
	GNode *gn;	/* GNode of transformation rule */
	Suff *s;	/* source suffix */
	Suff *t;	/* target suffix */

	if (!parse_transformi(line, end, &s, &t))
		return NULL;

	gn = find_or_create_transformi(line, end);
	/* In case the transform already exists, nuke old commands and children.
	 * Note we can't free them, since there might be stuff that references
	 * them elsewhere
	 */
	if (!Lst_IsEmpty(&gn->commands)) {
		Lst_Destroy(&gn->commands, NOFREE);
		Lst_Init(&gn->commands);
	}
	if (!Lst_IsEmpty(&gn->children)) {
		Lst_Destroy(&gn->children, NOFREE);
		Lst_Init(&gn->children);
	}

	gn->type = OP_TRANSFORM;
	if (s->flags & SUFF_PATH) {
		gn->special = SPECIAL_PATH | SPECIAL_TARGET;
		gn->suffix = t;
	}

	if (DEBUG(SUFF))
		printf("defining transformation from `%s' to `%s'\n",
		    s->name, t->name);
	return gn;
}

static void
make_suffix_known(Suff *s)
{
	if ((s->flags & SUFF_ACTIVE) == 0) {
		s->order = order++;
		s->flags |= SUFF_ACTIVE;
		if (s->nameLen > maxLen)
			maxLen = s->nameLen;
	}
}

static Suff *
new_suffixi(const char *str, const char *eptr)
{
	Suff *s;

	s = ohash_create_entry(&suff_info, str, &eptr);
	s->nameLen = eptr - str;
	Lst_Init(&s->searchPath);
	Lst_Init(&s->children);
	Lst_Init(&s->parents);
	s->flags = 0;
	return s;
}

/*-
 *-----------------------------------------------------------------------
 * Suff_AddSuffix --
 *	Add the suffix in string to the end of the list of known suffixes.
 *	Should we restructure the suffix graph? Make doesn't...
 *
 * Side Effects:
 *	A GNode is created for the suffix and a Suff structure is created and
 *	added to the known suffixes, unless it was already known.
 *-----------------------------------------------------------------------
 */
void
Suff_AddSuffixi(const char *str, const char *end)
{
	(void)add_suffixi(str, end);
}

static Suff *
add_suffixi(const char *str, const char *end)
{
	Suff *s;	    /* new suffix descriptor */

	unsigned int slot;

	slot = reverse_slot(&suffixes, str, &end);
	s = ohash_find(&suffixes, slot);
	if (s == NULL) {
		s = new_suffixi(str, end);
		ohash_insert(&suffixes, slot, s);
	}
	make_suffix_known(s);
	return s;
}

Lst
find_suffix_path(GNode *gn)
{
	if (gn->suffix != NULL && gn->suffix != emptySuff)
		return &(gn->suffix->searchPath);
	else
		return defaultPath;
}

static void
build_suffixes_graph(void)
{
	Suff *s, *s2;
	GNode *gn;
	unsigned int i;

	for (gn = ohash_first(&transforms, &i); gn != NULL;
	    gn = ohash_next(&transforms, &i)) {
	    	if (Lst_IsEmpty(&gn->commands) && Lst_IsEmpty(&gn->children))
			continue;
		if ((gn->special & SPECIAL_MASK) == SPECIAL_PATH)
			continue;
	    	if (parse_transform(gn->name, &s, &s2)) {
			SuffInsert(&s2->children, s);
			SuffInsert(&s->parents, s2);
		}
	}
}

/*-
 *-----------------------------------------------------------------------
 * setup_paths
 *	Extend the search paths for all suffixes to include the default
 *	search path.
 *
 * Side Effects:
 *	The searchPath field of all the suffixes is extended by the
 *	directories in defaultPath. If paths were specified for the
 *	".h" suffix, the directories are stuffed into a global variable
 *	called ".INCLUDES" with each directory preceded by a -I. The same
 *	is done for the ".a" suffix, except the variable is called
 *	".LIBS" and the flag is -L.
 *-----------------------------------------------------------------------
 */
static void
setup_paths(void)
{
	unsigned int i;
	Suff *s;

	for (s = ohash_first(&suffixes, &i); s != NULL;
	    s = ohash_next(&suffixes, &i)) {
		if (!Lst_IsEmpty(&s->searchPath))
			Dir_Concat(&s->searchPath, defaultPath);
		else
			Lst_Clone(&s->searchPath, defaultPath, Dir_CopyDir);
	}
}

void
process_suffixes_after_makefile_is_read(void)
{
	/* once the Makefile is finish reading, we can set up the default PATH
	 * stuff, and build the final suffixes graph
	 */
	setup_paths();
	/* and we link all transforms to active suffixes at this point. */
	build_suffixes_graph();
}
	  /********** Implicit Source Search Functions *********/

/*-
 *-----------------------------------------------------------------------
 * SuffAddSrc  --
 *	Add a suffix as a Src structure to the given list with its parent
 *	being the given Src structure. If the suffix is the null suffix,
 *	the prefix is used unaltered as the file name in the Src structure.
 *
 * Side Effects:
 *	A Src structure is created and tacked onto the end of the list
 *-----------------------------------------------------------------------
 */
static void
SuffAddSrc(
    void *sp,		/* suffix for which to create a Src structure */
    void *lsp)		/* list and parent for the new Src */
{
	Suff *s = sp;
	LstSrc *ls = lsp;
	Src *s2;	/* new Src structure */
	Src *targ;	/* Target structure */

	targ = ls->s;

	s2 = emalloc(sizeof(Src));
	s2->file = Str_concat(targ->prefix, s->name, 0);
	s2->prefix = targ->prefix;
	s2->parent = targ;
	s2->node = NULL;
	s2->suff = s;
	s2->children = 0;
	targ->children++;
	Lst_AtEnd(ls->l, s2);
#ifdef DEBUG_SRC
	Lst_Init(&s2->cp);
	Lst_AtEnd(&targ->cp, s2);
	printf("2 add %x %x to %x:", targ, s2, ls->l);
	Lst_Every(ls->l, PrintAddr);
	printf("\n");
#endif

}

/*-
 *-----------------------------------------------------------------------
 * SuffAddLevel  --
 *	Add all the children of targ as Src structures to the given list
 *
 * Side Effects:
 *	Lots of structures are created and added to the list
 *-----------------------------------------------------------------------
 */
static void
SuffAddLevel(
    Lst l,	/* list to which to add the new level */
    Src *targ)	/* Src structure to use as the parent */
{
	LstSrc	   ls;

	ls.s = targ;
	ls.l = l;

	Lst_ForEach(&targ->suff->children, SuffAddSrc, &ls);
}

/*-
 *----------------------------------------------------------------------
 * SuffRemoveSrc --
 *	Free all src structures in list that don't have a reference count
 *
 * Results:
 *	Ture if an src was removed
 *
 * Side Effects:
 *	The memory is free'd.
 *----------------------------------------------------------------------
 */
static int
SuffRemoveSrc(Lst l)
{
	LstNode ln;
	Src *s;
	int t = 0;

#ifdef DEBUG_SRC
	printf("cleaning %lx: ", (unsigned long)l);
	Lst_Every(l, PrintAddr);
	printf("\n");
#endif


	for (ln = Lst_First(l); ln != NULL; ln = Lst_Adv(ln)) {
		s = Lst_Datum(ln);
		if (s->children == 0) {
			free(s->file);
			if (!s->parent)
				free(s->prefix);
			else {
#ifdef DEBUG_SRC
				LstNode ln2 = Lst_Member(&s->parent->cp, s);
				if (ln2 != NULL)
				    Lst_Remove(&s->parent->cp, ln2);
#endif
				--s->parent->children;
			}
#ifdef DEBUG_SRC
			printf("free: [l=%x] p=%x %d\n", l, s, s->children);
			Lst_Destroy(&s->cp, NOFREE);
#endif
			Lst_Remove(l, ln);
			free(s);
			t |= 1;
			return true;
		}
#ifdef DEBUG_SRC
		else {
			printf("keep: [l=%x] p=%x %d: ", l, s, s->children);
			Lst_Every(&s->cp, PrintAddr);
			printf("\n");
		}
#endif
	}

	return t;
}

/*-
 *-----------------------------------------------------------------------
 * SuffFindThem --
 *	Find the first existing file/target in the list srcs
 *
 * Results:
 *	The lowest structure in the chain of transformations
 *-----------------------------------------------------------------------
 */
static Src *
SuffFindThem(
    Lst srcs,	/* list of Src structures to search through */
    Lst slst)
{
	Src *s;		/* current Src */
	Src *rs; 	/* returned Src */
	char *ptr;

	rs = NULL;

	while ((s = Lst_DeQueue(srcs)) != NULL) {
		if (DEBUG(SUFF))
			printf("\ttrying %s...", s->file);

		/*
		 * A file is considered to exist if either a node exists in the
		 * graph for it or the file actually exists.
		 */
		if (Targ_FindNode(s->file, TARG_NOCREATE) != NULL) {
#ifdef DEBUG_SRC
			printf("remove %x from %x\n", s, srcs);
#endif
			rs = s;
			break;
		}

		if ((ptr = Dir_FindFile(s->file, &s->suff->searchPath))
		    != NULL) {
			rs = s;
#ifdef DEBUG_SRC
			printf("remove %x from %x\n", s, srcs);
#endif
			free(ptr);
			break;
		}

		if (DEBUG(SUFF))
		    printf("not there\n");

		SuffAddLevel(srcs, s);
		Lst_AtEnd(slst, s);
	}

	if (DEBUG(SUFF) && rs)
	    printf("got it\n");
	return rs;
}

/*-
 *-----------------------------------------------------------------------
 * SuffFindCmds --
 *	See if any of the children of the target in the Src structure is
 *	one from which the target can be transformed. If there is one,
 *	a Src structure is put together for it and returned.
 *-----------------------------------------------------------------------
 */
static Src *
SuffFindCmds(Src *targ, Lst slst)
{
	LstNode ln;	/* General-purpose list node */
	GNode *t;	/* Target GNode */
	GNode *s;	/* Source GNode */
	int prefixLen;	/* The length of the defined prefix */
	Suff *suff;	/* Suffix on matching beastie */
	Src *ret;	/* Return value */
	const char *cp;

	t = targ->node;
	prefixLen = strlen(targ->prefix);

	for (ln = Lst_First(&t->children); ln != NULL; ln = Lst_Adv(ln)) {
		s = Lst_Datum(ln);

		cp = strrchr(s->name, '/');
		if (cp == NULL)
			cp = s->name;
		else
			cp++;
		if (strncmp(cp, targ->prefix, prefixLen) != 0)
			continue;
		/* The node matches the prefix ok, see if it has a known
		 * suffix.	*/
		suff = find_suff(&cp[prefixLen]);
		if (suff == NULL)
			continue;
		/*
		 * It even has a known suffix, see if there's a transformation
		 * defined between the node's suffix and the target's suffix.
		 *
		 * XXX: Handle multi-stage transformations here, too.
		 */
		if (Lst_Member(&suff->parents, targ->suff) == NULL)
			continue;
		/*
		 * Create a new Src structure to describe this transformation
		 * (making sure to duplicate the source node's name so
		 * Suff_FindDeps can free it again (ick)), and return the new
		 * structure.
		 */
		ret = emalloc(sizeof(Src));
		ret->file = estrdup(s->name);
		ret->prefix = targ->prefix;
		ret->suff = suff;
		ret->parent = targ;
		ret->node = s;
		ret->children = 0;
		targ->children++;
#ifdef DEBUG_SRC
		Lst_Init(&ret->cp);
		printf("3 add %x %x\n", targ, ret);
		Lst_AtEnd(&targ->cp, ret);
#endif
		Lst_AtEnd(slst, ret);
		if (DEBUG(SUFF))
			printf("\tusing existing source %s\n", s->name);
		return ret;
	}
	return NULL;
}

static void
SuffLinkParent(GNode *cgn, GNode *pgn)
{
	Lst_AtEnd(&cgn->parents, pgn);
	if (!has_been_built(cgn))
		pgn->unmade++;
	else if ( ! (cgn->type & (OP_EXEC|OP_USE))) {
		if (cgn->built_status == MADE)
			pgn->childMade = true;
		(void)Make_TimeStamp(pgn, cgn);
	}
}

static void
SuffExpandVarChildren(LstNode after, GNode *cgn, GNode *pgn)
{
	GNode *gn;		/* New source 8) */
	char *cp;		/* Expanded value */
	LIST members;


	if (DEBUG(SUFF))
		printf("Expanding \"%s\"...", cgn->name);

	cp = Var_Subst(cgn->name, &pgn->context, true);
	if (cp == NULL) {
		printf("Problem substituting in %s", cgn->name);
		printf("\n");
		return;
	}

	Lst_Init(&members);

	if (cgn->type & OP_ARCHV) {
		/*
		 * Node was an archive(member) target, so we want to call
		 * on the Arch module to find the nodes for us, expanding
		 * variables in the parent's context.
		 */
		const char *sacrifice = (const char *)cp;

		(void)Arch_ParseArchive(&sacrifice, &members, &pgn->context);
	} else {
		/* Break the result into a vector of strings whose nodes
		 * we can find, then add those nodes to the members list.
		 * Unfortunately, we can't use brk_string because it
		 * doesn't understand about variable specifications with
		 * spaces in them...  */
		const char *start, *cp2;

		for (start = cp; *start == ' ' || *start == '\t'; start++)
			continue;
		for (cp2 = start; *cp2 != '\0';) {
			if (ISSPACE(*cp2)) {
				/* White-space -- terminate element, find the
				 * node, add it, skip any further spaces.  */
				gn = Targ_FindNodei(start, cp2, TARG_CREATE);
				cp2++;
				Lst_AtEnd(&members, gn);
				while (ISSPACE(*cp2))
					cp2++;
				/* Adjust cp2 for increment at start of loop,
				 * but set start to first non-space.  */
				start = cp2;
			} else if (*cp2 == '$')
				/* Start of a variable spec -- contact variable
				 * module to find the end so we can skip over
				 * it.  */
				Var_ParseSkip(&cp2, &pgn->context);
			else if (*cp2 == '\\' && cp2[1] != '\0')
				/* Escaped something -- skip over it.  */
				cp2+=2;
			else
				cp2++;
	    }

	    if (cp2 != start) {
		    /* Stuff left over -- add it to the list too.  */
		    gn = Targ_FindNodei(start, cp2, TARG_CREATE);
		    Lst_AtEnd(&members, gn);
	    }
	}
	/* Add all elements of the members list to the parent node.  */
	while ((gn = Lst_DeQueue(&members)) != NULL) {
		if (DEBUG(SUFF))
			printf("%s...", gn->name);
		if (Lst_Member(&pgn->children, gn) == NULL) {
			Lst_Append(&pgn->children, after, gn);
			after = Lst_Adv(after);
			SuffLinkParent(gn, pgn);
		}
	}
	/* Free the result.  */
	free(cp);
	if (DEBUG(SUFF))
		printf("\n");
}

static void
SuffExpandWildChildren(LstNode after, GNode *cgn, GNode *pgn)
{
	Suff *s;
	char *cp;	/* Expanded value */

	LIST exp;	/* List of expansions */
	Lst path;	/* Search path along which to expand */

	if (DEBUG(SUFF))
		printf("Wildcard expanding \"%s\"...", cgn->name);

	/* Find a path along which to expand the word.
	 *
	 * If the word has a known suffix, use that path.
	 * If it has no known suffix and we're allowed to use the null
	 *	 suffix, use its path.
	 * Else use the default system search path.  */
	s = find_best_suffix(cgn->name, cgn->name + strlen(cgn->name));

	if (s != NULL) {
		if (DEBUG(SUFF))
			printf("suffix is \"%s\"...", s->name);
		path = &s->searchPath;
	} else
		/* Use default search path.  */
		path = defaultPath;

	/* Expand the word along the chosen path. */
	Lst_Init(&exp);
	Dir_Expand(cgn->name, path, &exp);

	/* Fetch next expansion off the list and find its GNode.  */
	while ((cp = Lst_DeQueue(&exp)) != NULL) {
		GNode *gn;		/* New source 8) */
		if (DEBUG(SUFF))
			printf("%s...", cp);
		gn = Targ_FindNode(cp, TARG_CREATE);

		/* If gn isn't already a child of the parent, make it so and
		 * up the parent's count of unmade children.  */
		if (Lst_Member(&pgn->children, gn) == NULL) {
			Lst_Append(&pgn->children, after, gn);
			after = Lst_Adv(after);
			SuffLinkParent(gn, pgn);
		}
	}

	if (DEBUG(SUFF))
		printf("\n");
}

/*-
 *-----------------------------------------------------------------------
 * SuffExpandChildren --
 *	Expand the names of any children of a given node that contain
 *	variable invocations or file wildcards into actual targets.
 *
 * Side Effects:
 *	The expanded node is removed from the parent's list of children,
 *	and the parent's unmade counter is decremented, but other nodes
 *	may be added.
 *-----------------------------------------------------------------------
 */
static void
SuffExpandChildren(LstNode ln, /* LstNode of child, so we can replace it */
    GNode *pgn)
{
	GNode	*cgn = Lst_Datum(ln);

	/* First do variable expansion -- this takes precedence over wildcard
	 * expansion. If the result contains wildcards, they'll be gotten to
	 * later since the resulting words are tacked on to the end of the
	 * children list.  */
	if (strchr(cgn->name, '$') != NULL)
		SuffExpandVarChildren(ln, cgn, pgn);
	else if (Dir_HasWildcards(cgn->name))
		SuffExpandWildChildren(ln, cgn, pgn);
	else
	    /* Third case: nothing to expand.  */
		return;

	/* Since the source was expanded, remove it from the list of children to
	 * keep it from being processed.  */
	pgn->unmade--;
	Lst_Remove(&pgn->children, ln);
}

void
expand_children_from(GNode *parent, LstNode from)
{
	LstNode np, ln;

	for (ln = from; ln != NULL; ln = np) {
		np = Lst_Adv(ln);
		SuffExpandChildren(ln, parent);
	}
}

/*-
 *-----------------------------------------------------------------------
 * SuffApplyTransform --
 *	Apply a transformation rule, given the source and target nodes
 *	and suffixes.
 *
 * Results:
 *	true if successful, false if not.
 *
 * Side Effects:
 *	The source and target are linked and the commands from the
 *	transformation are added to the target node's commands list.
 *	All attributes but OP_DEPMASK and OP_TRANSFORM are applied
 *	to the target. The target also inherits all the sources for
 *	the transformation rule.
 *-----------------------------------------------------------------------
 */
static bool
SuffApplyTransform(
    GNode	*tGn,	/* Target node */
    GNode	*sGn,	/* Source node */
    Suff	*t,	/* Target suffix */
    Suff	*s)	/* Source suffix */
{
	LstNode	ln;	/* General node */
	char	*tname; /* Name of transformation rule */
	GNode	*gn;	/* Node for same */

	if (Lst_AddNew(&tGn->children, sGn)) {
		/* Not already linked, so form the proper links between the
		 * target and source.  */
		SuffLinkParent(sGn, tGn);
	}

	if ((sGn->type & OP_OPMASK) == OP_DOUBLEDEP) {
		/* When a :: node is used as the implied source of a node, we
		 * have to link all its cohorts in as sources as well. There's
		 * only one implied src, as that will be sufficient to get
		 * the .IMPSRC variable set for tGn.	*/
		for (ln=Lst_First(&sGn->cohorts); ln != NULL; ln=Lst_Adv(ln)) {
			gn = Lst_Datum(ln);

			if (Lst_AddNew(&tGn->children, gn)) {
				/* Not already linked, so form the proper links
				 * between the target and source.  */
				SuffLinkParent(gn, tGn);
			}
		}
	}
	/* Locate the transformation rule itself.  */
	tname = Str_concat(s->name, t->name, 0);
	gn = find_transform(tname);
	free(tname);

	if (gn == NULL)
		/*
		 * Not really such a transformation rule (can happen when we're
		 * called to link an OP_MEMBER and OP_ARCHV node), so return
		 * false.
		 */
		return false;

	if (DEBUG(SUFF))
		printf("\tapplying %s -> %s to \"%s\"\n", s->name, t->name,
		    tGn->name);

	/* Record last child for expansion purposes.  */
	ln = Lst_Last(&tGn->children);

	/* Pass the buck to Make_HandleUse to apply the rule.  */
	Make_HandleUse(gn, tGn);

	/* Deal with wildcards and variables in any acquired sources.  */
	expand_children_from(tGn, Lst_Succ(ln));

	/* Keep track of another parent to which this beast is transformed so
	 * the .IMPSRC variable can be set correctly for the parent.  */
	tGn->impliedsrc = sGn;

	return true;
}

static Suff *
find_suffix_as_suffix(Lst l, const char *b, const char *e)
{
	LstNode ln;
	Suff *s;

	for (ln = Lst_First(l); ln != NULL; ln = Lst_Adv(ln)) {
		s = Lst_Datum(ln);
		if (suffix_is_suffix(s, b, e))
			return s;
	}
	return NULL;
}

/*-
 *-----------------------------------------------------------------------
 * SuffFindArchiveDeps --
 *	Locate dependencies for an OP_ARCHV node.
 *
 * Side Effects:
 *	Same as Suff_FindDeps
 *-----------------------------------------------------------------------
 */
static void
SuffFindArchiveDeps(
    GNode	*gn,    /* Node for which to locate dependencies */
    Lst 	slst)
{
	char *eoarch;	/* End of archive portion */
	char *eoname;	/* End of member portion */
	GNode *mem;	/* Node for member */
	Suff *ms;	/* Suffix descriptor for member */
	char *name;	/* Start of member's name */

	/* The node is an archive(member) pair. so we must find a suffix
	 * for both of them.  */
	eoarch = strchr(gn->name, '(');
	if (eoarch == NULL)
		return;

	name = eoarch + 1;

	eoname = strchr(name, ')');
	if (eoname == NULL)
		return;

	/* To simplify things, call Suff_FindDeps recursively on the member now,
	 * so we can simply compare the member's .PREFIX and .TARGET variables
	 * to locate its suffix. This allows us to figure out the suffix to
	 * use for the archive without having to do a quadratic search over the
	 * suffix list, backtracking for each one...  */
	mem = Targ_FindNodei(name, eoname, TARG_CREATE);
	SuffFindDeps(mem, slst);

	/* Create the link between the two nodes right off. */
	if (Lst_AddNew(&gn->children, mem))
		SuffLinkParent(mem, gn);

	/* Copy variables from member node to this one.  */
	Var(TARGET_INDEX, gn) = Var(TARGET_INDEX, mem);
	Var(PREFIX_INDEX, gn) = Var(PREFIX_INDEX, mem);

	ms = mem->suffix;
	if (ms == NULL) {
		/* Didn't know what it was -- use .NULL suffix if not in make
		 * mode.  */
		if (DEBUG(SUFF))
			printf("using empty suffix\n");
		ms = emptySuff;
	}


	/* Set the other two local variables required for this target.  */
	Var(MEMBER_INDEX, gn) = mem->name;
	Var(ARCHIVE_INDEX, gn) = gn->name;

	if (ms != NULL) {
		/*
		 * Member has a known suffix, so look for a transformation rule
		 * from it to a possible suffix of the archive. Rather than
		 * searching through the entire list, we just look at suffixes
		 * to which the member's suffix may be transformed...
		 */

		Suff *suff;

		suff = find_suffix_as_suffix(&ms->parents, gn->name, eoarch);

		if (suff != NULL) {
			/* Got one -- apply it.  */
			if (!SuffApplyTransform(gn, mem, suff, ms) &&
			    DEBUG(SUFF))
				printf("\tNo transformation from %s -> %s\n",
				   ms->name, suff->name);
		}
	}

	/* Pretend gn appeared to the left of a dependency operator so
	 * the user needn't provide a transformation from the member to the
	 * archive.  */
	if (OP_NOP(gn->type))
		gn->type |= OP_DEPENDS;

	/* Flag the member as such so we remember to look in the archive for
	 * its modification time.  */
	mem->type |= OP_MEMBER;
}

static void
record_possible_suffix(Suff *s, GNode *gn, char *eoname, Lst srcs, Lst targs)
{
	int prefixLen;
	Src *targ;

	targ = emalloc(sizeof(Src));
	targ->file = estrdup(gn->name);
	targ->suff = s;
	targ->node = gn;
	targ->parent = NULL;
	targ->children = 0;
#ifdef DEBUG_SRC
	Lst_Init(&targ->cp);
#endif

	/* Allocate room for the prefix, whose end is found by
	 * subtracting the length of the suffix from the end of
	 * the name.  */
	prefixLen = (eoname - targ->suff->nameLen) - gn->name;
	targ->prefix = emalloc(prefixLen + 1);
	memcpy(targ->prefix, gn->name, prefixLen);
	targ->prefix[prefixLen] = '\0';

	/* Add nodes from which the target can be made.  */
	SuffAddLevel(srcs, targ);

	/* Record the target so we can nuke it.  */
	Lst_AtEnd(targs, targ);
}

static void
record_possible_suffixes(GNode *gn, Lst srcs, Lst targs)
{
	char *s = gn->name;
	char *e =  s + strlen(s);
	const char *p;
	uint32_t hv;
	unsigned int slot;
	Suff *suff;

	if (e == s)
		return;

	p = e;
	hv = *--p;

	while (p != s) {
		slot = ohash_lookup_interval(&suffixes, p, e, hv);
		suff = ohash_find(&suffixes, slot);
		if (suff != NULL && (suff->flags & SUFF_ACTIVE))
			record_possible_suffix(suff, gn, e, srcs, targs);
		if (e - p >= (ptrdiff_t)maxLen)
			break;
		reverse_hash_add_char(&hv, --p);
	}
}

/*-
 *-----------------------------------------------------------------------
 * SuffFindNormalDeps --
 *	Locate implicit dependencies for regular targets.
 *
 * Side Effects:
 *	Same as Suff_FindDeps...
 *-----------------------------------------------------------------------
 */
static void
SuffFindNormalDeps(
    GNode	*gn,	    /* Node for which to find sources */
    Lst 	slst)
{
	LIST srcs;	/* List of sources at which to look */
	LIST targs;	/* List of targets to which things can be
			 * transformed. They all have the same file,
			 * but different suff and prefix fields */
	Src *bottom;    /* Start of found transformation path */
	Src *src;	/* General Src pointer */
	char *prefix;	/* Prefix to use */
	Src *targ;	/* General Src target pointer */


	Lst_Init(&srcs);
	Lst_Init(&targs);

	/* We're caught in a catch-22 here. On the one hand, we want to use any
	 * transformation implied by the target's sources, but we can't examine
	 * the sources until we've expanded any variables/wildcards they may
	 * hold, and we can't do that until we've set up the target's local
	 * variables and we can't do that until we know what the proper suffix
	 * for the target is (in case there are two suffixes one of which is a
	 * suffix of the other) and we can't know that until we've found its
	 * implied source, which we may not want to use if there's an existing
	 * source that implies a different transformation.
	 *
	 * In an attempt to get around this, which may not work all the time,
	 * but should work most of the time, we look for implied sources first,
	 * checking transformations to all possible suffixes of the target, use
	 * what we find to set the target's local variables, expand the
	 * children, then look for any overriding transformations they imply.
	 * Should we find one, we discard the one we found before.	*/


	record_possible_suffixes(gn, &srcs, &targs);
	/* Handle target of unknown suffix...  */
	if (Lst_IsEmpty(&srcs)) {
		if (DEBUG(SUFF))
			printf("\tNo known suffix on %s. Using empty suffix\n",
			    gn->name);

		targ = emalloc(sizeof(Src));
		targ->file = estrdup(gn->name);
		targ->suff = emptySuff;
		targ->node = gn;
		targ->parent = NULL;
		targ->children = 0;
		targ->prefix = estrdup(gn->name);
#ifdef DEBUG_SRC
		Lst_Init(&targ->cp);
#endif

		/* Only use the default suffix rules if we don't have commands
		 * or dependencies defined for this gnode.  */
		if (Lst_IsEmpty(&gn->commands) && Lst_IsEmpty(&gn->children))
			SuffAddLevel(&srcs, targ);
		else {
			if (DEBUG(SUFF))
				printf("not ");
		}

		if (DEBUG(SUFF))
			printf("adding suffix rules\n");

		Lst_AtEnd(&targs, targ);
	}

	/* Using the list of possible sources built up from the target
	 * suffix(es), try and find an existing file/target that matches.  */
	bottom = SuffFindThem(&srcs, slst);

	if (bottom == NULL) {
		/* No known transformations -- use the first suffix found for
		 * setting the local variables.  */
		if (!Lst_IsEmpty(&targs))
			targ = Lst_Datum(Lst_First(&targs));
		else
			targ = NULL;
	} else {
		/* Work up the transformation path to find the suffix of the
		 * target to which the transformation was made.  */
		for (targ = bottom; targ->parent != NULL; targ = targ->parent)
			continue;
	}

	/* The .TARGET variable we always set to be the name at this point,
	 * since it's only set to the path if the thing is only a source and
	 * if it's only a source, it doesn't matter what we put here as far
	 * as expanding sources is concerned, since it has none...	*/
	Var(TARGET_INDEX, gn) = gn->name;

	prefix = targ != NULL ? estrdup(targ->prefix) : gn->name;
	Var(PREFIX_INDEX, gn) = prefix;

	/* Now we've got the important local variables set, expand any sources
	 * that still contain variables or wildcards in their names.  */
	expand_all_children(gn);

	if (targ == NULL) {
		if (DEBUG(SUFF))
			printf("\tNo valid suffix on %s\n", gn->name);

sfnd_abort:
		/* Deal with finding the thing on the default search path if the
		 * node is only a source (not on the lhs of a dependency operator
		 * or [XXX] it has neither children or commands).  */
		if (OP_NOP(gn->type) ||
		    (Lst_IsEmpty(&gn->children) &&
		    Lst_IsEmpty(&gn->commands))) {
			gn->path = Dir_FindFile(gn->name,
			    (targ == NULL ? defaultPath :
			    &targ->suff->searchPath));
			if (gn->path != NULL) {
				char *ptr;
				Var(TARGET_INDEX, gn) = estrdup(gn->path);

				if (targ != NULL) {
					/* Suffix known for the thing -- trim
					 * the suffix off the path to form the
					 * proper .PREFIX variable.  */
					int savep = strlen(gn->path) -
					    targ->suff->nameLen;
					char savec;

					gn->suffix = targ->suff;

					savec = gn->path[savep];
					gn->path[savep] = '\0';

					if ((ptr = strrchr(gn->path, '/')) !=
					    NULL)
						ptr++;
					else
						ptr = gn->path;

					Var(PREFIX_INDEX, gn) = estrdup(ptr);

					gn->path[savep] = savec;
				} else {
					/* The .PREFIX gets the full path if the
					 * target has no known suffix.  */
					gn->suffix = NULL;

					if ((ptr = strrchr(gn->path, '/')) !=
					    NULL)
						ptr++;
					else
						ptr = gn->path;

					Var(PREFIX_INDEX, gn) = estrdup(ptr);
				}
			}
		} else {
			/* Not appropriate to search for the thing -- set the
			 * path to be the name so Dir_MTime won't go grovelling
			 * for it.  */
			gn->suffix = targ == NULL ? NULL : targ->suff;
			efree(gn->path);
			gn->path = estrdup(gn->name);
		}

		goto sfnd_return;
	}

	/* Check for overriding transformation rule implied by sources.  */
	if (!Lst_IsEmpty(&gn->children)) {
		src = SuffFindCmds(targ, slst);

		if (src != NULL) {
			/* Free up all the Src structures in the transformation
			 * path up to, but not including, the parent node.  */
			while (bottom && bottom->parent != NULL) {
				(void)Lst_AddNew(slst, bottom);
				bottom = bottom->parent;
			}
			bottom = src;
		}
	}

	if (bottom == NULL) {
		/* No idea from where it can come -- return now.  */
		goto sfnd_abort;
	}

	/* We now have a list of Src structures headed by 'bottom' and linked
	 * via their 'parent' pointers. What we do next is create links between
	 * source and target nodes (which may or may not have been created) and
	 * set the necessary local variables in each target. The commands for
	 * each target are set from the commands of the transformation rule
	 * used to get from the src suffix to the targ suffix. Note that this
	 * causes the commands list of the original node, gn, to be replaced by
	 * the commands of the final transformation rule. Also, the unmade
	 * field of gn is incremented.  Etc.  */
	if (bottom->node == NULL) {
		bottom->node = Targ_FindNode(bottom->file, TARG_CREATE);
	}

	for (src = bottom; src->parent != NULL; src = src->parent) {
		targ = src->parent;

		src->node->suffix = src->suff;

		if (targ->node == NULL) {
			targ->node = Targ_FindNode(targ->file, TARG_CREATE);
		}

		SuffApplyTransform(targ->node, src->node,
				   targ->suff, src->suff);

		if (targ->node != gn) {
			/* Finish off the dependency-search process for any
			 * nodes between bottom and gn (no point in questing
			 * around the filesystem for their implicit source when
			 * it's already known). Note that the node can't have
			 * any sources that need expanding, since SuffFindThem
			 * will stop on an existing node, so all we need to do
			 * is set the standard and System V variables.  */
			targ->node->type |= OP_DEPS_FOUND;

			Var(PREFIX_INDEX, targ->node) = estrdup(targ->prefix);

			Var(TARGET_INDEX, targ->node) = targ->node->name;
		}
	}

	gn->suffix = src->suff;

	/* So Dir_MTime doesn't go questing for it...  */
	efree(gn->path);
	gn->path = estrdup(gn->name);

	/* Nuke the transformation path and the Src structures left over in the
	 * two lists.  */
sfnd_return:
	if (bottom)
		(void)Lst_AddNew(slst, bottom);

	while (SuffRemoveSrc(&srcs) || SuffRemoveSrc(&targs))
		continue;

	Lst_ConcatDestroy(slst, &srcs);
	Lst_ConcatDestroy(slst, &targs);
}


/*-
 *-----------------------------------------------------------------------
 * Suff_FindDeps  --
 *	Find implicit sources for the target described by the graph node
 *	gn
 *
 * Side Effects:
 *	Nodes are added to the graph below the passed-in node. The nodes
 *	are marked to have their IMPSRC variable filled in. The
 *	PREFIX variable is set for the given node and all its
 *	implied children.
 *
 * Notes:
 *	The path found by this target is the shortest path in the
 *	transformation graph, which may pass through non-existent targets,
 *	to an existing target. The search continues on all paths from the
 *	root suffix until a file is found. I.e. if there's a path
 *	.o -> .c -> .l -> .l,v from the root and the .l,v file exists but
 *	the .c and .l files don't, the search will branch out in
 *	all directions from .o and again from all the nodes on the
 *	next level until the .l,v node is encountered.
 *-----------------------------------------------------------------------
 */

void
Suff_FindDeps(GNode *gn)
{

	SuffFindDeps(gn, &srclist);
	while (SuffRemoveSrc(&srclist))
		continue;
}


static void
SuffFindDeps(GNode *gn, Lst slst)
{
	if (gn->type & OP_DEPS_FOUND) {
		/*
		 * If dependencies already found, no need to do it again...
		 */
		return;
	} else {
		gn->type |= OP_DEPS_FOUND;
	}

	if (DEBUG(SUFF))
		printf("SuffFindDeps (%s)\n", gn->name);

	current_node = gn;
	if (gn->type & OP_ARCHV)
		SuffFindArchiveDeps(gn, slst);
	else
		SuffFindNormalDeps(gn, slst);
	current_node = NULL;
}

/*-
 *-----------------------------------------------------------------------
 * Suff_Init --
 *	Initialize suffixes module
 *
 * Side Effects:
 *	Many
 *-----------------------------------------------------------------------
 */
void
Suff_Init(void)
{
	Static_Lst_Init(&srclist);
	ohash_init(&transforms, 4, &gnode_info);

	/*
	 * Create null suffix for single-suffix rules (POSIX). The thing doesn't
	 * actually go on the suffix list or everyone will think that's its
	 * suffix.
	 */
	emptySuff = new_suffix("");
	make_suffix_known(emptySuff);
	Dir_Concat(&emptySuff->searchPath, defaultPath);
	ohash_init(&suffixes, 4, &suff_info);
	order = 0;
	clear_suffixes();
	special_path_hack();

}


/********************* DEBUGGING FUNCTIONS **********************/

static void
SuffPrintName(void *p)
{
	const Suff *s = p;
	printf("%s ", s == emptySuff ? "<empty>" : s->name);
}

static void
SuffPrintSuff(void *sp)
{
	Suff    *s = sp;

	printf("# %-5s ", s->name);

	if (!Lst_IsEmpty(&s->parents)) {
		printf(" ->");
		Lst_Every(&s->parents, SuffPrintName);
	}
	if (!Lst_IsEmpty(&s->children)) {
		printf(" <-");
		Lst_Every(&s->children, SuffPrintName);
	}
	fputc('\n', stdout);
}

static void
SuffPrintTrans(GNode *t)
{
	printf("%-16s: ", t->name);
	Targ_PrintType(t->type);
	fputc('\n', stdout);
	Lst_Every(&t->commands, Targ_PrintCmd);
	fputc('\n', stdout);
}

static int 
compare_order(const void *a, const void *b)
{
	const Suff **pa = (const Suff **)a;
	const Suff **pb = (const Suff **)b;
	return (*pb)->order - (*pa)->order;
}

static void
print_path(Suff *s)
{
	/* do we need to print it ? compare against defaultPath */
	LstNode ln1, ln2;
	bool first = true;

	for (ln1 = Lst_First(&s->searchPath), ln2 = Lst_First(defaultPath);
	    ln1 != NULL && ln2 != NULL; 
	    ln1 = Lst_Adv(ln1)) {
		if (Lst_Datum(ln1) == Lst_Datum(ln2)) {
			ln2 = Lst_Adv(ln2);
			continue;
		}
		if (first) {
			printf(".PATH%s:", s->name);
			first = false;
		}
		printf(" %s", PathEntry_name(Lst_Datum(ln1)));
	}
	if (!first)
		printf("\n\n");
}

void
Suff_PrintAll(void)
{
	Suff **t;
	GNode **u;
	unsigned int i;
	bool reprint;


	printf("# Suffixes graph\n");
	t = sort_ohash_by_name(&suffixes);
	for (i = 0; t[i] != NULL; i++)
		if (!(t[i]->flags & SUFF_PATH))
			SuffPrintSuff(t[i]);

	printf("\n.PATH: ");
	Dir_PrintPath(defaultPath);
	printf("\n\n");
	for (i = 0; t[i] != NULL; i++)
		if (!(t[i]->flags & SUFF_PATH))
			print_path(t[i]);
	free(t);

	reprint = false;
	t = sort_ohash(&suffixes, compare_order);
	printf(".SUFFIXES:");
	for (i = 0; t[i] != NULL; i++) {
		if (t[i]->flags & SUFF_PATH)
			continue;
		printf(" %s", t[i]->name);
		if (!(t[i]->flags & SUFF_ACTIVE))
			reprint = true;
	}
	printf("\n\n");
	u = sort_ohash_by_name(&transforms);
	for (i = 0; u[i] != NULL; i++)
	    	SuffPrintTrans(u[i]);
	free(u);

	if (reprint) {
		printf(".SUFFIXES:");
		for (i = 0; t[i] != NULL; i++)
			if (t[i]->flags & SUFF_ACTIVE)
				printf(" %s", t[i]->name);
		printf("\n");
	}
	free(t);
}

#ifdef DEBUG_SRC
static void
PrintAddr(void *a)
{
	printf("%lx ", (unsigned long)a);
}
#endif
@


1.90
log
@a wee little bit more cleanup (more const and remove noise from CDIAGFLAGS...
-pedantic kind of requires -std=c99 here to avoid LL warnings)
okay miod@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.89 2015/01/23 13:18:40 espie Exp $ */
d331 1
a331 1
		s2 = (Suff *)Lst_Datum(ln);
d757 1
a757 1
		s = (Src *)Lst_Datum(ln);
d811 1
a811 1
	while ((s = (Src *)Lst_DeQueue(srcs)) != NULL) {
d872 1
a872 1
		s = (GNode *)Lst_Datum(ln);
d1004 1
a1004 1
	while ((gn = (GNode *)Lst_DeQueue(&members)) != NULL) {
d1052 1
a1052 1
	while ((cp = (char *)Lst_DeQueue(&exp)) != NULL) {
d1087 1
a1087 1
	GNode	*cgn = (GNode *)Lst_Datum(ln);
d1158 1
a1158 1
			gn = (GNode *)Lst_Datum(ln);
d1207 1
a1207 1
		s = (Suff *)Lst_Datum(ln);
d1452 1
a1452 1
			targ = (Src *)Lst_Datum(Lst_First(&targs));
@


1.89
log
@remove a bunch of dangerous casts (useless casts from void * to something
else, in some cases by adding extra temporary variables.
IMO, it's much better practice to do

void *a;
int *p = a;
*p = 42;

rather than
void *a;
*(int *)a = 42;

okay miod@@... to be revisited for some possible const additions later.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.88 2014/05/12 19:11:19 espie Exp $ */
d1715 1
a1715 1
	Suff *s = p;
@


1.88
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.87 2014/01/06 12:08:18 espie Exp $ */
d682 2
a683 2
	Suff *s = (Suff *)sp;
	LstSrc *ls = (LstSrc *)lsp;
d1715 1
a1715 1
	Suff *s = (Suff *)p;
d1722 1
a1722 1
	Suff    *s = (Suff *)sp;
@


1.87
log
@fix error messages, avoid dereferencing null pointers.
- the code becomes too indented, pull it into a separate function
- add an extra hint, the current_gnode.
- specifically, variables may be expanded during
target: prereq  solving in Suff_FindDeps, this is after parsing,
not during command execution, and the only actual indication with have is
that we're resolving a prereq of.

(this ought to fix mk35, and partially solve mk34)
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.86 2013/11/22 15:47:35 espie Exp $ */
d136 1
a136 1
	hash_alloc, hash_free, element_alloc
@


1.86
log
@wrappers for is*/to* that make damn sure their arguments are
cast to unsigned chars.

okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.85 2013/04/23 14:32:53 espie Exp $ */
d1671 1
d1676 1
@


1.85
log
@remove TIMESTAMP abstraction layer, prodded by theo.
while there, clean up includes.
use strtoll for ar timestamps (pretty much unused in reality, more
standard conforming than anything)

use idea from Todd to adapt to time_t being 32 bits OR 64 bits
(pedantically correct: INT_MIN would work just fine up to 1910 or so...)

okay millert@@, gone thru a make build.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.84 2012/12/22 19:02:05 espie Exp $ */
d974 1
a974 1
			if (isspace(*cp2)) {
d980 1
a980 1
				while (isspace(*cp2))
@


1.84
log
@cosmetic changes:
- pref -> prefix   as pref is somewhat ambiguous
- rework tests so loop doesn't intend off the screen
- zap unneeded variable
okay krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.83 2012/12/06 10:33:16 espie Exp $ */
d63 3
a67 2
#include <stdint.h>
#include <stddef.h>
a68 1
#include <signal.h>
@


1.83
log
@old code is gone, remove comments and prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.82 2012/10/09 19:45:34 espie Exp $ */
d144 1
a144 1
	char *pref;		/* Prefix from which file was formed */
d690 2
a691 2
	s2->file = Str_concat(targ->pref, s->name, 0);
	s2->pref = targ->pref;
d761 1
a761 1
				free(s->pref);
a854 6
 *
 * Results:
 *	The Src structure of the "winning" child, or NULL if no such beast.
 *
 * Side Effects:
 *	A Src structure may be allocated.
d858 1
a858 3
SuffFindCmds(
    Src 	*targ,	/* Src structure to play with */
    Lst 	slst)
d863 1
a863 1
	int prefLen;	/* The length of the defined prefix */
d869 1
a869 1
	prefLen = strlen(targ->pref);
d875 1
a875 1
		if (cp == NULL) {
d877 1
a877 1
		} else {
d879 29
a907 32
		}
		if (strncmp(cp, targ->pref, prefLen) == 0) {
			/* The node matches the prefix ok, see if it has a known
			 * suffix.	*/
			suff = find_suff(&cp[prefLen]);
			if (suff != NULL) {
				/*
				 * It even has a known suffix, see if there's a
				 * transformation defined between the node's
				 * suffix and the target's suffix.
				 *
				 * XXX: Handle multi-stage transformations
				 * here, too.
				 */
				if (Lst_Member(&suff->parents, targ->suff)
				    != NULL) {
					/*
					 * Hot Damn! Create a new Src structure
					 * to describe this transformation
					 * (making sure to duplicate the source
					 * node's name so Suff_FindDeps can
					 * free it again (ick)), and return the
					 * new structure.
					 */
					ret = emalloc(sizeof(Src));
					ret->file = estrdup(s->name);
					ret->pref = targ->pref;
					ret->suff = suff;
					ret->parent = targ;
					ret->node = s;
					ret->children = 0;
					targ->children++;
d909 3
a911 3
					Lst_Init(&ret->cp);
					printf("3 add %x %x\n", targ, ret);
					Lst_AtEnd(&targ->cp, ret);
d913 4
a916 9
					Lst_AtEnd(slst, ret);
					if (DEBUG(SUFF))
					    printf(
						"\tusing existing source %s\n",
						    s->name);
					return ret;
				}
			}
		}
d1311 1
a1311 1
	int prefLen;
a1312 1
	char *sopref = gn->name;
d1327 4
a1330 4
	prefLen = (eoname - targ->suff->nameLen) - sopref;
	targ->pref = emalloc(prefLen + 1);
	memcpy(targ->pref, sopref, prefLen);
	targ->pref[prefLen] = '\0';
d1383 1
a1383 1
			 * but different suff and pref fields */
d1386 1
a1386 1
	char *pref;	/* Prefix to use */
d1424 1
a1424 1
		targ->pref = estrdup(gn->name);
d1468 2
a1469 2
	pref = targ != NULL ? estrdup(targ->pref) : gn->name;
	Var(PREFIX_INDEX, gn) = pref;
d1596 1
a1596 1
			Var(PREFIX_INDEX, targ->node) = estrdup(targ->pref);
@


1.82
log
@- SPECIAL_DEPRECATED -> SPECIAL_NOTHING
- nodes for .POSIX and .SCCS_GET (which don't do anything)
- zap remaining suffix crud.

new scaffolding:
- groupling list and HELDBACK state to avoid races in engine.
- parser recognizes lists of targets that shoul be grouped together
- OP_DOUBLE to mark nodes that have multiple lists of commands
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.81 2012/10/02 10:29:31 espie Exp $ */
a48 2
 *
 *	Suff_GetPath		Return the search path for the given suffix.
@


1.81
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.80 2012/04/21 04:35:32 guenther Exp $ */
a51 5
 *	Suff_AddInclude 	Mark the given suffix as denoting an include
 *				file.
 *
 *	Suff_AddLib		Mark the given suffix as denoting a library.
 *
d121 1
a121 1
typedef struct Suff_ {
d134 1
a134 1
} Suff;
d499 1
a499 1
 *	Possibly create anew transform, or reset an existing one.
@


1.80
log
@When a new parent is attached to an already examined child (prerequisite),
use the same logic to update the parent (factored out as SuffLinkParent())
as is used for updating the original parent.  Fixes the "make -j2" problem
reported by tedu@@ at c2k11

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.79 2010/07/19 19:46:44 espie Exp $ */
d46 1
a46 4
 *	Suff_End		Cleanup the module
 *
 *	Suff_ClearSuffixes	Clear out all the suffixes and defined
 *				transformations.
a62 3
 *	Suff_SetNull		Define the suffix to consider the suffix of
 *				any file that doesn't have a known one.
 *
d93 1
a128 4
#define SUFF_INCLUDE	  0x01	/* suffix marked with .INCLUDES keyword */
#define SUFF_LIBRARY	  0x02	/* suffix marked with .LIBS keyword */
#define SUFF_NULL	  0x04	/* The empty suffix (normally '', */
				/* but see .EMPTY keyword) */
a170 1
static Suff *suffNull;	/* The NULL suffix for this run */
a174 2
static void build_path_variable(struct ohash *, int, const char *, const char *);
static void add_property(const char *, const char *, int);
a187 3
#ifdef CLEANUP
static void SuffFree(void *);
#endif
a320 28
#ifdef CLEANUP
/*-
 *-----------------------------------------------------------------------
 * SuffFree  --
 *	Free up all memory associated with the given suffix structure.
 *
 * Side Effects:
 *	the suffix entry is detroyed
 *-----------------------------------------------------------------------
 */
static void
SuffFree(void *sp)
{
	Suff *s = (Suff *)sp;

	if (s == emptySuff)
		emptySuff = NULL;

	Lst_Destroy(&s->children, NOFREE);
	Lst_Destroy(&s->parents, NOFREE);
	Lst_Destroy(&s->searchPath, Dir_Destroy);

	free(s->name);
	free(s);
}
#endif


a379 1
	suffNull = emptySuff;
d453 1
a453 1
			best_target = suffNull;
a610 49
/* find out the tagged suffixes, build a temporary path, and construct
 * a variable based on that.
 */
static void
build_path_variable(struct ohash *h, int opt, const char *name,
    const char *flag)
{
	char *value;
	LIST path;
	Suff *s;
	unsigned int i;

	Lst_Init(&path);
	for (s = ohash_first(h, &i); s != NULL; s = ohash_next(h, &i)) {
		if (Lst_IsEmpty(&s->searchPath))
			continue;
		if (s->flags & opt)
			Dir_Concat(&path, &s->searchPath);
	}

	value = Dir_MakeFlags(flag, &path);
	Var_Set(name, value);
	free(value);
	Lst_Destroy(&path, Dir_Destroy);
}

static void
add_property(const char *sname, const char *end, int opt)
{
	Suff *s;

	s = find_suffi(sname, end);
	if (s != NULL) {
		s->flags |= opt;
	}
}

void
Suff_AddIncludei(const char *sname, const char *end)
{
	add_property(sname, end, SUFF_INCLUDE);
}

void
Suff_AddLibi(const char *sname, const char *end)
{
	add_property(sname, end, SUFF_LIBRARY);
}

a658 3

	build_path_variable(&suffixes, SUFF_INCLUDE, ".INCLUDES", "-I");
	build_path_variable(&suffixes, SUFF_LIBRARY, ".LIBS", "-L");
a695 23
	if ((s->flags & SUFF_NULL) && *s->name != '\0') {
		/*
		 * If the suffix has been marked as the NULL suffix, also
		 * create a Src structure for a file with no suffix attached.
		 * Two birds, and all that...
		 */
		s2 = emalloc(sizeof(Src));
		s2->file = estrdup(targ->pref);
		s2->pref = targ->pref;
		s2->parent = targ;
		s2->node = NULL;
		s2->suff = s;
		s2->children = 0;
		targ->children++;
		Lst_AtEnd(ls->l, s2);
#ifdef DEBUG_SRC
		Lst_Init(&s2->cp);
		Lst_AtEnd(&targ->cp, s2);
		printf("1 add %x %x to %x:", targ, s2, ls->l);
		Lst_Every(ls->l, PrintAddr);
		printf("\n");
#endif
	}
d1290 2
a1291 2
			printf("using null suffix\n");
		ms = suffNull;
d1439 1
a1439 1
			printf("\tNo known suffix on %s. Using .NULL suffix\n",
d1444 1
a1444 1
		targ->suff = suffNull;
a1564 6
	/* If the suffix indicates that the target is a library, mark that in
	 * the node's type field.  */
	if (targ->suff->flags & SUFF_LIBRARY) {
		gn->type |= OP_LIB;
	}

d1695 1
a1695 1
	if (gn->type & OP_ARCHV) {
d1697 1
a1697 26
	} else if (gn->type & OP_LIB) {
		/*
		 * If the node is a library, it is the arch module's job to
		 * find it and set the TARGET variable accordingly. We merely
		 * provide the search path, assuming all libraries end in ".a"
		 * (if the suffix hasn't been defined, there's nothing we can
		 * do for it, so we just set the TARGET variable to the node's
		 * name in order to give it a value).
		 */
		Suff	*s;

		s = find_suff(LIBSUFF);
		if (s != NULL) {
			gn->suffix = s;
			Arch_FindLib(gn, &s->searchPath);
		} else {
			gn->suffix = NULL;
			Var(TARGET_INDEX, gn) = gn->name;
		}
		/*
		 * Because a library (-lfoo) target doesn't follow the standard
		 * filesystem conventions, we don't set the regular variables
		 * for the thing. .PREFIX is simply made empty...
		 */
		Var(PREFIX_INDEX, gn) = "";
	} else
a1701 27
 * Notes:
 */
void
Suff_SetNulli(const char *name, const char *end)
{
	Suff    *s;

	s= find_suffi(name, end);
	if (s != NULL) {
		/* pass the pumpkin */
		suffNull->flags &= ~SUFF_NULL;
		s->flags |= SUFF_NULL;
		/*
		 * XXX: Here's where the transformation mangling would take
		 * place
		 * we would need to handle the changing of the null suffix
		 * gracefully so the old transformation rules don't just go
		 * away.
		 */
		suffNull = s;
	} else {
		Parse_Error(PARSE_WARNING,
		    "Desired null suffix %s not defined.", name);
	}
}

/*-
a1721 1
	emptySuff->flags |= SUFF_NULL;
a1731 23
/*-
 *----------------------------------------------------------------------
 * Suff_End --
 *	Cleanup the this module
 *
 * Side Effects:
 *	The memory is free'd.
 *----------------------------------------------------------------------
 */

#ifdef CLEANUP
void
Suff_End(void)
{
	free_hash(&suffixes);
	if (emptySuff)
		SuffFree(emptySuff);
	Lst_Destroy(&srclist, NOFREE);
	ohash_delete(&transforms);
}
#endif


d1735 1
a1735 1
SuffPrintName(void *s)
d1737 2
a1738 1
	printf("%s ", ((Suff *)s)->name);
a1744 2
	int     flags;
	int     flag;
d1746 1
a1746 1
	printf("# `%s' ", s->name);
d1748 7
a1754 19
	flags = s->flags;
	if (flags) {
		fputs(" (", stdout);
		while (flags) {
			flag = 1 << (ffs(flags) - 1);
			flags &= ~flag;
			switch (flag) {
			case SUFF_NULL:
				printf("NULL");
				break;
			case SUFF_INCLUDE:
				printf("INCLUDE");
				break;
			case SUFF_LIBRARY:
				printf("LIBRARY");
				break;
			}
			fputc(flags ? '|' : ')', stdout);
		}
a1756 9
	printf("#\tTo: ");
	Lst_Every(&s->parents, SuffPrintName);
	fputc('\n', stdout);
	printf("#\tFrom: ");
	Lst_Every(&s->children, SuffPrintName);
	fputc('\n', stdout);
	printf("#\tSearch Path: ");
	Dir_PrintPath(&s->searchPath);
	fputc('\n', stdout);
d1769 32
d1804 2
a1805 2
	Suff *s;
	GNode *gn;
d1807 1
a1808 1
	printf("#*** Suffixes:\n");
d1810 38
a1847 8
	for (s = ohash_first(&suffixes, &i); s != NULL;
	    s = ohash_next(&suffixes, &i))
		SuffPrintSuff(s);

	printf("#*** Transformations:\n");
	for (gn = ohash_first(&transforms, &i); gn != NULL;
	    gn = ohash_next(&transforms, &i))
	    	SuffPrintTrans(gn);
@


1.79
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.78 2010/04/25 13:59:53 espie Exp $ */
d1064 13
d1152 1
a1152 3
			Lst_AtEnd(&gn->parents, pgn);
			if (!has_been_built(gn))
				pgn->unmade++;
d1205 1
a1205 3
			Lst_AtEnd(&gn->parents, pgn);
			if (!has_been_built(gn))
				pgn->unmade++;
d1291 1
a1291 3
		Lst_AtEnd(&sGn->parents, tGn);
		if (!has_been_built(sGn))
			tGn->unmade++;
d1305 1
a1305 3
				Lst_AtEnd(&gn->parents, tGn);
				if (!has_been_built(gn))
					tGn->unmade++;
d1397 2
a1398 5
	if (Lst_AddNew(&gn->children, mem)) {
		Lst_AtEnd(&mem->parents, gn);
		if (!has_been_built(mem))
			gn->unmade++;
	}
@


1.78
log
@pure whitespace cleanup
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$ */
@


1.77
log
@more parallel make fixes.

Preparations to fix the engine:
- new function has_been_built(gn), that tells you what's the status of
a given node. Allows us to run Suff_FindDeps later, by updating the number
of unmade children correctly.
- take out the code that handles shell expansions in an expand_children*
set of functions, called by Suff_FindDeps, among others. These must be
called early in the engine to avoid creating bogus nodes.

Engine fixes:
- take the predecessor/successor special handling out, deal with it in
separate functions.
- don't count nodes. Explicitly track them all in a hash table (better
way to deal with non-built issues).
- don't run Suff_FindDeps at start, but just before building an actual node.
This allows make to find all dependencies correctly, as in groff.

Pfiou! now it works.
@
text
@d107 1
a107 1
size_t maxLen;	
d144 1
a144 1
	int order;		/* order of declaration for conflict 
d152 1
a152 1
	offsetof(struct Suff_, name), NULL, 
d1291 1
a1291 1
		 * only one implied src, as that will be sufficient to get 
@


1.76
log
@simplify dynamic variable handling a great deal:
first remove all usage of Varq_Append by building the string directly.
then replace `common' handling with specialized handling for dynamic
strings (since they no longer need a buffer). Finally, identify the place
where the variable value needs to be copied because it's going to be free'd
or erased soon, and finally, use simple char* pointers.

Shaves about 80 bytes off every gnode structure, and kills quite a few
unnecessary malloc()s as well.
@
text
@d210 1
a210 1
static void SuffExpandChildren(void *, void *);
d1141 2
a1142 1
			pgn->unmade++;
d1196 2
a1197 1
			pgn->unmade++;
d1218 4
a1221 10
SuffExpandChildren(
    void	*cgnp,		/* Child to examine */
    void	*pgnp)		/* Parent node being processed */
{
	GNode	*cgn = (GNode *)cgnp;
	GNode	*pgn = (GNode *)pgnp;
	LstNode	ln;
	/* New nodes effectively take the place of the child, so we place them
	 * after the child.  */
	ln = Lst_Member(&pgn->children, cgn);
d1241 11
a1276 1
	LstNode	np;	    /* Next node for loop */
d1284 2
a1285 1
		tGn->unmade++;
d1300 2
a1301 1
				tGn->unmade++;
d1329 1
a1329 4
	for (ln = Lst_Succ(ln); ln != NULL; ln = np) {
		np = Lst_Adv(ln);
		SuffExpandChildren(Lst_Datum(ln), tGn);
	}
d1395 2
a1396 1
		gn->unmade++;
a1521 2
	LstNode	np;
	LstNode ln;
d1615 1
a1615 4
	for (ln = Lst_First(&gn->children); ln != NULL; ln = np) {
		np = Lst_Adv(ln);
		SuffExpandChildren(Lst_Datum(ln), gn);
	}
@


1.75
log
@bug-fix: try the empty suffix when we cannot find any transformation, not
when we cannot find any suffix.

This allows Makefiles like:

.SUFFIXES: .in .sh

all: truc.sh

truc.sh.in:
	echo "bonjour" >$@@

.in:
	sed -e 's/a/b/' <$< >$@@


to work (before that, the empty suffix would not be tried, since truc.sh
matches the .sh suffix, even though there is NO transformation).
@
text
@d1394 2
a1395 2
	Varq_Set(TARGET_INDEX, Varq_Value(TARGET_INDEX, mem), gn);
	Varq_Set(PREFIX_INDEX, Varq_Value(PREFIX_INDEX, mem), gn);
d1408 2
a1409 2
	Varq_Set(MEMBER_INDEX, mem->name, gn);
	Varq_Set(ARCHIVE_INDEX, gn->name, gn);
d1604 1
a1604 1
	Varq_Set(TARGET_INDEX, gn->name, gn);
d1606 2
a1607 2
	pref = targ != NULL ? targ->pref : gn->name;
	Varq_Set(PREFIX_INDEX, pref, gn);
d1632 1
a1632 1
				Varq_Set(TARGET_INDEX, gn->path, gn);
d1653 1
a1653 1
					Varq_Set(PREFIX_INDEX, ptr, gn);
d1667 1
a1667 1
					Varq_Set(PREFIX_INDEX, ptr, gn);
d1743 1
a1743 1
			Varq_Set(PREFIX_INDEX, targ->pref, targ->node);
d1745 1
a1745 1
			Varq_Set(TARGET_INDEX, targ->node->name, targ->node);
d1837 1
a1837 1
			Varq_Set(TARGET_INDEX, gn->name, gn);
d1844 1
a1844 1
		Varq_Set(PREFIX_INDEX, "", gn);
@


1.74
log
@simplify the way we deal with implicit rules and handle $<.

Having an `iParents' field is actually backwards, it's ways simpler to
store the pointer in the child, as an impliedsrc, and to set the variable
just in time along with all the rest in DoAllVar.

This is simpler, and it should allow us to call SuffFindDeps much later.
@
text
@d1551 1
a1551 1
	if (Lst_IsEmpty(&targs)) {
@


1.73
log
@Work done at p2k7.


This is a really big step towards getting parallel make to work.


Note that this is not yet complete. There are still a few `details' to
fix before this works 100%.  Specifically: sequential make (compat) and
parallel make don't use the same engine, and the parallel engine still
has a few limitations. For instance, some known issues:
- parallel make does not deal with .phony targets correctly all the time.
- some errors are deadly in parallel make mode.
- parallel make NEEDS way more sturdy correspondance of file system paths
and target names, since it often needs to match dependencies to targets
before the corresponding files exist.
- some local variables like $* get set in a bogus way in some cases.
- suffix handling has issues, especially related to the NULL suffix.
So, if you find stuff that does NOT yet work with parallel make, don't go
blindly try to fix the Makefile. It's very likely you might have stumbled
into a make bug. (unless you really, really, understand Makefiles, DON'T
GO CHANGING THEM YET).



Tested by lots of people, thanks go to miod@@, and robert@@ among other people.

Quick summary of what this does:

- remove `saving commands' extension (it's not really usable, nor used)
- move compat job runner and parallel interrupt handling into engine.c
- tweak the code so that both compat and parallel mode use the same job runner
and the same interrupt handling. Remove the other one.
- optimize job runner so that, in parallel mode, the last command does not
fork if we can avoid it (as it's already running in a sub shell).
- scrape all the code that dealt with creating shell scripts from commands.
- scrape all the code that dealt with recognizing special sequences in
command output to print/not print output.
- fix the parallel job pipe to not keep around file descriptors that are not
needed.
- replace the parallel job buffering with a nicer one, that deals with
non-blocking descriptors to try to agregate as much output from one job in
one go (greed) to unconfuse the users.
- create two pipes per job, so that stdout and stderr stay separate.
- make job token printing a debug option.
- always use the parallel job-runner to `execute' commands, even if we just
print them out.
- store list of errors encountered during parallel make running, and print them
on exit, so that we know what went wrong.
- add a dirty hack to targ.c to deal with paths produced by gccmakedep.
@
text
@d1283 3
a1285 4
		 * have to link all its cohorts in as sources as well. Only the
		 * initial sGn gets the target in its iParents list, however,
		 * as that will be sufficient to get the .IMPSRC variable set
		 * for tGn.	*/
d1328 1
a1328 1
	Lst_AtEnd(&sGn->iParents, tGn);
@


1.72
log
@better comments, sNum -> order. SUFF_EXISTS -> SUFF_ACTIVE
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.71 2007/09/18 08:31:15 espie Exp $ */
d82 1
@


1.71
log
@make -DCLEANUP compile again
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.70 2007/09/17 12:42:09 espie Exp $ */
a75 22
/* The suffix specifications are *really weird*
 * Here is how it works:
 * - each time you encounter a .SUFFIX: .s1 .s2 .s3
 * you add the suffixes to the list of known suffixes, keeping it ordered.
 * - when you see a
 * .s1.s2:
 * line, you match it against the known suffixes at this point, and it
 * is tagged as a transform rule.
 * - when you encounter a .SUFFIX:
 * you reset the list of suffixes to empty, but you keep all the transforms
 * around.
 * - at the end of all Makefiles, you match recognized transforms against
 * suffixes existing at this point.
 *
 * The description of SusV3 is really sketchy, but this is how make works,
 * gmake works that way as well.
 *
 * The only difference is that gmake keeps its transform rules on the main
 * target list, so if you define two suffixes and a transform, then resets
 * the suffix and define a normal rule with the same name, you'll override
 * the transform.
 */
d100 23
a122 3
static struct ohash suffixes;	/* hash of suffixes */
size_t    maxLen;		/* optimization: remember longest suffix */
static LIST	 srclist;	/* Lst of sources */
d125 2
a126 1
static int	  sNum = 0;	/* Counter for assigning suffix numbers */
d132 8
a139 6
	size_t nameLen;		/* Length of the suffix */
	short flags; 		/* Type of suffix */
#define SUFF_INCLUDE	  0x01	/* One which is #include'd */
#define SUFF_LIBRARY	  0x02	/* One which contains a library */
#define SUFF_NULL	  0x04	/* The empty suffix */
#define SUFF_EXISTS	  0x08	/* So that we don't have to destroy them */
d143 5
a147 4
	int sNum;		/* The suffix number */
	LIST parents;		/* Suffixes we have a transformation to */
	LIST children;		/* Suffixes we have a transformation from */
	char name[1]; 		/* The suffix itself */
d151 2
a152 1
	offsetof(struct Suff_, name), NULL, hash_alloc, hash_free, element_alloc
d233 2
a234 5
/* we usually look at suffixes `backwards', which makes it necessary for
 * us to have a specific hash function that proceeds backwards.
 */


d241 1
d382 1
a382 1
		if (s2->sNum >= s->sNum)
d387 1
a387 1
		printf("inserting %s(%d)...", s->name, s->sNum);
d392 1
a392 1
	} else if (s2->sNum != s->sNum) {
d394 1
a394 1
			printf("before %s(%d)\n", s2->name, s2->sNum);
d419 1
a419 1
		s->flags &= ~SUFF_EXISTS;
d421 1
a421 1
	sNum = 0;
d467 1
a467 1
			if (target != NULL && (target->flags & SUFF_EXISTS)) {
d470 1
a470 1
				    (src->flags & (SUFF_EXISTS | SUFF_PATH))) {
d477 1
a477 1
					    src->sNum < best_src->sNum) {
d495 1
a495 1
		if (src != NULL && (src->flags & (SUFF_EXISTS | SUFF_PATH))) {
d533 1
a533 1
			if (best == NULL || suff->sNum < best->sNum)
d590 3
a592 3
	if ((s->flags & SUFF_EXISTS) == 0) {
		s->sNum = sNum++;
		s->flags |= SUFF_EXISTS;
d1494 1
a1494 1
		if (suff != NULL && (suff->flags & SUFF_EXISTS))
d1901 1
a1901 1
	sNum = 0;
@


1.70
log
@rewrite of the basic suffix/target parsing: use hash for suffixes.

Store special targets in target hash, and use them for the parsing.

Use OP_DUMMY flag to mark targets that don't really exist yet, such
as interrupt and default nodes.

Also, .PATHxxx is special in suffixes.

Small tweaks to compat.c, so that run_commands does more stuff after
the fork() (and thus no need to free things).

Remove distinction between local and global jobs.
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.68 2007/09/17 10:12:35 espie Exp $ */
d1925 1
a1925 1
	ohash_delete(&transforms):
@


1.69
log
@remove prototypes that now live in engine.h, adjust suff.c accordingly
@
text
@a48 13
 *	Suff_DoPaths		This function is used to make life easier
 *				when searching for a file according to its
 *				suffix. It takes the global search path,
 *				as defined using the .PATH: target, and appends
 *				its directories to the path of each of the
 *				defined suffixes, as specified using
 *				.PATH<suffix>: targets. In addition, all
 *				directories given for suffixes labeled as
 *				include files or libraries, using the .INCLUDES
 *				or .LIBS targets, are played with using
 *				Dir_MakeFlags to create the .INCLUDES and
 *				.LIBS global variables.
 *
a51 3
 *	Suff_IsTransform	Return true if the passed string is the lhs
 *				of a transformation rule.
 *
d61 5
a65 3
 *	Suff_AddTransform	Add another transformation to the suffix
 *				graph. Returns	GNode suitable for framing, I
 *				mean, tacking commands, attributes, etc. on.
d76 22
d101 2
d104 1
d109 1
d119 1
a120 1
#include "engine.h"
d122 2
a123 4
static LIST	 sufflist;	/* Lst of suffixes */
#ifdef CLEANUP
static LIST	 suffClean;	/* Lst of suffixes to be cleaned */
#endif
d125 1
a125 1
static LIST	 transforms;	/* Lst of transformation rules */
d133 13
a145 12
    char	 *name; 	/* The suffix itself */
    int 	 nameLen;	/* Length of the suffix */
    short	 flags; 	/* Type of suffix */
#define SUFF_INCLUDE	  0x01	    /* One which is #include'd */
#define SUFF_LIBRARY	  0x02	    /* One which contains a library */
#define SUFF_NULL	  0x04	    /* The empty suffix */
    LIST	 searchPath;	/* The path along which files of this suffix
				 * may be found */
    int 	 sNum;		/* The suffix number */
    LIST	 parents;	/* Suffixes we have a transformation to */
    LIST	 children;	/* Suffixes we have a transformation from */
    LIST	 ref;		/* List of lists this suffix is referenced */
d148 4
d156 6
a161 6
    char	    *file;	/* The file to look for */
    char	    *pref;	/* Prefix from which file was formed */
    Suff	    *suff;	/* The suffix on the file */
    struct Src_     *parent;	/* The Src for which this is a source */
    GNode	    *node;	/* The node describing the file */
    int 	    children;	/* Count of existing children (so we don't free
d164 1
a164 1
    LIST	    cp; 	/* Debug; children list */
d173 2
a174 2
    Lst 	   l;
    Src 	   *s;
d177 19
a195 3
static Suff	    *suffNull;	/* The NULL suffix for this run */
static Suff	    *emptySuff; /* The empty suffix required for POSIX
				 * single-suffix transformation rules */
a196 8

static char *SuffStrIsPrefix(const char *, const char *);
static char *SuffSuffIsSuffix(Suff *, const char *);
static int SuffSuffIsSuffixP(void *, const void *);
static int SuffSuffIsPrefix(void *, const void *);
static int SuffHasNameP(void *, const void *);
static int GNodeHasNameP(void *, const void *);
static void SuffUnRef(Lst, Suff *);
a200 2
static bool SuffParseTransform(const char *, Suff **, Suff **);
static void SuffRebuildGraph(void *, void *);
d215 1
a215 1
static void SuffPrintTrans(void *);
d217 8
a224 2
static LstNode suff_find_by_name(const char *);
static LstNode transform_find_by_name(const char *);
d229 3
a231 9
	/*************** Lst Predicates ****************/
/*-
 *-----------------------------------------------------------------------
 * SuffStrIsPrefix  --
 *	See if prefix is a prefix of str.
 *
 * Results:
 *	NULL if it ain't, pointer to character in str after prefix if so
 *-----------------------------------------------------------------------
d233 10
a242 2
static char    *
SuffStrIsPrefix(const char *prefix, const char *str)
d244 12
a255 3
	while (*str && *prefix == *str) {
		prefix++;
		str++;
d257 7
d265 2
a266 1
	return *prefix ? NULL : (char *)str;
d269 1
a269 11
/*-
 *-----------------------------------------------------------------------
 * SuffSuffIsSuffix  --
 *	See if suff is a suffix of str. str should point to the end of the
 *	string to check.
 *
 * Results:
 *	NULL if it ain't, pointer to first character of suffix in str if
 *	it is.
 *-----------------------------------------------------------------------
 */
d271 1
a271 1
SuffSuffIsSuffix(Suff *s, const char *str)
d273 2
a274 2
	const char	   *p1; 	/* Pointer into suffix name */
	const char	   *p2; 	/* Pointer into string being examined */
d276 2
d279 1
a279 1
	p2 = str;
d291 2
a292 12
/*-
 *-----------------------------------------------------------------------
 * SuffSuffIsSuffixP --
 *	Predicate form of SuffSuffIsSuffix. Passed as the callback function
 *	to Lst_Find.
 *
 * Results:
 *	0 if the suffix is the one desired, non-zero if not.
 *-----------------------------------------------------------------------
 */
static int
SuffSuffIsSuffixP(void *s, const void *str)
d294 6
a299 1
	return !SuffSuffIsSuffix((Suff *)s, (const char *)str);
d302 2
a303 2
static int
SuffHasNameP(void *s, const void *sname)
d305 1
a305 2
	return strcmp((const char *)sname, ((Suff *)s)->name);
}
a306 3
static LstNode
suff_find_by_name(const char *name)
{
d308 1
a308 1
	STAT_SUFF_LOOKUP_NAME++;
d310 3
a312 1
	return Lst_FindConst(&sufflist, SuffHasNameP, name);
d315 2
a316 2
static int
GNodeHasNameP(void *gn, const void *name)
d318 2
a319 2
	return strcmp((const char *)name, ((GNode *)gn)->name);
}
a320 3
static LstNode
transform_find_by_name(const char *name)
{
d324 1
a324 20
	return Lst_FindConst(&transforms, GNodeHasNameP, name);
}
/*-
 *-----------------------------------------------------------------------
 * SuffSuffIsPrefix  --
 *	See if the suffix described by s is a prefix of the string. Care
 *	must be taken when using this to search for transformations and
 *	what-not, since there could well be two suffixes, one of which
 *	is a prefix of the other...
 *
 * Results:
 *	0 if s is a prefix of str. non-zero otherwise
 *-----------------------------------------------------------------------
 */
static int
SuffSuffIsPrefix(void *s, const void *str)
{
	return SuffStrIsPrefix(((Suff *)s)->name,
	    (const char *)str) == NULL ? 1 : 0;
}
d326 1
a326 1
	    /*********** Maintenance Functions ************/
d328 6
a333 7
static void
SuffUnRef(Lst l, Suff *sp)
{
	LstNode ln = Lst_Member(l, sp);
	if (ln != NULL)
		Lst_Remove(l, ln);
    }
d348 1
a348 4
	Suff	*s = (Suff *)sp;

	if (s == suffNull)
		suffNull = NULL;
a352 1
	Lst_Destroy(&s->ref, NOFREE);
d376 2
a377 2
	LstNode	  ln;		/* current element in l we're examining */
	Suff	  *s2 = NULL;	/* the suffix descriptor in this element */
d385 1
a385 1
	if (DEBUG(SUFF)) {
a386 1
	}
d388 1
a388 1
		if (DEBUG(SUFF)) {
a389 1
		}
a390 1
		Lst_AtEnd(&s->ref, l);
d392 1
a392 1
		if (DEBUG(SUFF)) {
a393 1
		}
a394 1
		Lst_AtEnd(&s->ref, l);
d403 2
a404 6
 *	This is gross. Nuke the list of suffixes but keep all transformation
 *	rules around. The transformation graph is destroyed in this process,
 *	but we leave the list of rules so when a new graph is formed the rules
 *	will remain.
 *	This function is called from the parse module when a
 *	.SUFFIXES:\n line is encountered.
d407 1
a407 1
 *	the sufflist and its graph nodes are destroyed
d410 15
d428 1
a428 6
#ifdef CLEANUP
	Lst_ConcatDestroy(&suffClean, &sufflist);
#endif
	Lst_Init(&sufflist);
	sNum = 0;
	suffNull = emptySuff;
d431 6
a436 11
/*-
 *-----------------------------------------------------------------------
 * SuffParseTransform --
 *	Parse a transformation string to find its two component suffixes.
 *
 * Results:
 *	true if the string is a valid transformation and false otherwise.
 *
 * Side Effects:
 *	The passed pointers are overwritten.
 *-----------------------------------------------------------------------
d439 14
a452 13
SuffParseTransform(
    const char		*str,		/* String being parsed */
    Suff		**srcPtr,	/* Place to store source of trans. */
    Suff		**targPtr)	/* Place to store target of trans. */
{
	LstNode		srcLn;	    /* element in suffix list of trans source*/
	Suff		*src;	    /* Source of transformation */
	LstNode		targLn;     /* element in suffix list of trans target*/
	const char		*str2;	    /* Extra pointer (maybe target suffix) */
	LstNode		singleLn;   /* element in suffix list of any suffix
					 * that exactly matches str */
	Suff		*single = NULL;/* Source of possible transformation to
					 * null suffix */
d454 5
a458 2
	srcLn = NULL;
	singleLn = NULL;
d460 14
a473 26
	/*
	 * Loop looking first for a suffix that matches the start of the
	 * string and then for one that exactly matches the rest of it. If
	 * we can find two that meet these criteria, we've successfully
	 * parsed the string.
	 */
	for (;;) {
		if (srcLn == NULL)
			srcLn = Lst_FindConst(&sufflist, SuffSuffIsPrefix, str);
		else
			srcLn = Lst_FindFromConst(Lst_Succ(srcLn),
			    SuffSuffIsPrefix, str);
		if (srcLn == NULL) {
			/*
			 * Ran out of source suffixes -- no such rule
			 */
			if (singleLn != NULL) {
				/*
				 * Not so fast Mr. Smith! There was a suffix
				 * that encompassed the entire string, so we
				 * assume it was a transformation to the null
				 * suffix (thank you POSIX). We still prefer to
				 * find a double rule over a singleton, hence
				 * we leave this check until the end.
				 *
				 * XXX: Use emptySuff over suffNull?
d475 6
a480 17
				*srcPtr = single;
				*targPtr = suffNull;
				return true;
			}
			return false;
		}
		src = (Suff *)Lst_Datum(srcLn);
		str2 = str + src->nameLen;
		if (*str2 == '\0') {
			single = src;
			singleLn = srcLn;
		} else {
			targLn = suff_find_by_name(str2);
			if (targLn != NULL) {
				*srcPtr = src;
				*targPtr = (Suff *)Lst_Datum(targLn);
				return true;
d483 22
d508 9
a516 12
/*-
 *-----------------------------------------------------------------------
 * Suff_IsTransform  --
 *	Return true if the given string is a transformation rule
 *
 * Results:
 *	true if the string is a concatenation of two known suffixes.
 *	false otherwise
 *-----------------------------------------------------------------------
 */
bool
Suff_IsTransform(const char *str)
d518 5
a522 1
	Suff	  *src, *targ;
d524 15
a538 1
	return SuffParseTransform(str, &src, &targ);
d543 3
a545 6
 * Suff_AddTransform --
 *	Add the transformation rule described by the line to the
 *	list of rules and place the transformation itself in the graph
 *
 * Results:
 *	The node created for the transformation in the transforms list
d547 1
a547 3
 * Side Effects:
 *	The node is placed on the end of the transforms Lst and links are
 *	made between the two suffixes mentioned in the target name
d551 1
a551 1
Suff_AddTransform(const char *line)
d553 6
a558 4
	GNode	  *gn;		/* GNode of transformation rule */
	Suff	  *s,		/* source suffix */
		      *t;		/* target suffix */
	LstNode	  ln;		/* Node for existing transformation */
d560 6
a565 17
	ln = transform_find_by_name(line);
	if (ln == NULL) {
		/*
		 * Make a new graph node for the transformation. It will be
		 * filled in by the Parse module.
		 */
		gn = Targ_NewGN(line);
		Lst_AtEnd(&transforms, gn);
	} else {
		/*
		 * New specification for transformation rule. Just nuke the old
		 * list of commands so they can be filled in again... We don't
		 * actually free the commands themselves, because a given
		 * command can be attached to several different
		 * transformations.
		 */
		gn = (GNode *)Lst_Datum(ln);
d568 2
d575 4
d580 1
a580 6
	(void)SuffParseTransform(line, &s, &t);

	/*
	 * link the two together in the proper relationship and order
	 */
	if (DEBUG(SUFF)) {
d583 11
d595 1
a595 2
	SuffInsert(&t->children, s);
	SuffInsert(&s->parents, t);
d597 12
a608 1
	return gn;
d613 3
a615 5
 * Suff_EndTransform --
 *	Handle the finish of a transformation definition, removing the
 *	transformation from the graph if it has neither commands nor
 *	sources. This is a callback procedure for the Parse module via
 *	Lst_ForEach
d618 2
a619 2
 *	If the node has no commands or children, the children and parents
 *	lists of the affected suffices are altered.
d623 1
a623 1
Suff_EndTransform(void *gnp)
d625 2
a626 1
	GNode *gn = (GNode *)gnp;
d628 4
a631 3
	if ((gn->type & OP_TRANSFORM) && Lst_IsEmpty(&gn->commands) &&
	    Lst_IsEmpty(&gn->children)) {
		Suff	*s, *t;
d633 1
a633 2
		if (!SuffParseTransform(gn->name, &s, &t))
			return;
d635 9
a643 4
		if (DEBUG(SUFF)) {
			printf("deleting transformation from `%s' to `%s'\n",
			    s->name, t->name);
		}
d645 8
a652 7
		/*
		 * Remove the source from the target's children list.
		 *
		 * We'll be called twice when the next target is seen, but .c
		 * and .o are only linked once...
		 */
		SuffUnRef(&t->children, s);
d654 18
a671 7
		/*
		 * Remove the target from the source's parents list
		 */
		if (s != NULL)
			SuffUnRef(&s->parents, t);
	} else if ((gn->type & OP_TRANSFORM) && DEBUG(SUFF)) {
		printf("transformation %s complete\n", gn->name);
d673 5
a679 15
/*-
 *-----------------------------------------------------------------------
 * SuffRebuildGraph --
 *	Called from Suff_AddSuffix via Lst_ForEach to search through the
 *	list of existing transformation rules and rebuild the transformation
 *	graph when it has been destroyed by Suff_ClearSuffixes. If the
 *	given rule is a transformation involving this suffix and another,
 *	existing suffix, the proper relationship is established between
 *	the two.
 *
 * Side Effects:
 *	The appropriate links will be made between this suffix and
 *	others if transformation rules exist for it.
 *-----------------------------------------------------------------------
 */
d681 1
a681 3
SuffRebuildGraph(
    void	*transformp,	/* Transformation to test */
    void	*sp)		/* Suffix to rebuild */
d683 1
a683 19
	GNode	*transform = (GNode *)transformp;
	Suff	*s = (Suff *)sp;
	char	*cp;
	LstNode	ln;
	Suff	*s2;

	/* First see if it is a transformation from this suffix.  */
	cp = SuffStrIsPrefix(s->name, transform->name);
	if (cp != NULL) {
		ln = suff_find_by_name(cp);
		if (ln != NULL) {
			/* Found target. Link in and return, since it can't be
			 * anything else.  */
			s2 = (Suff *)Lst_Datum(ln);
			SuffInsert(&s2->children, s);
			SuffInsert(&s->parents, s2);
			return;
		}
	}
d685 3
a687 14
	/* Not from, maybe to?  */
	cp = SuffSuffIsSuffix(s, transform->name + strlen(transform->name));
	if (cp != NULL) {
		/* Null-terminate the source suffix in order to find it.  */
		*cp = '\0';
		ln = suff_find_by_name(transform->name);
		/* Replace the start of the target suffix.  */
		*cp = s->name[0];
		if (ln != NULL) {
			/* Found it -- establish the proper relationship.  */
			s2 = (Suff *)Lst_Datum(ln);
			SuffInsert(&s->children, s2);
			SuffInsert(&s2->parents, s);
		}
a690 11
/*-
 *-----------------------------------------------------------------------
 * Suff_AddSuffix --
 *	Add the suffix in string to the end of the list of known suffixes.
 *	Should we restructure the suffix graph? Make doesn't...
 *
 * Side Effects:
 *	A GNode is created for the suffix and a Suff structure is created and
 *	added to the suffixes list unless the suffix was already known.
 *-----------------------------------------------------------------------
 */
d692 1
a692 1
Suff_AddSuffix(const char *str)
d694 2
a695 2
	Suff	  *s;	    /* new suffix descriptor */
	LstNode	  ln;
d697 4
a700 20
	ln = suff_find_by_name(str);
	if (ln == NULL) {
		s = emalloc(sizeof(Suff));

		s->name =	estrdup(str);
		s->nameLen =	strlen(s->name);
		Lst_Init(&s->searchPath);
		Lst_Init(&s->children);
		Lst_Init(&s->parents);
		Lst_Init(&s->ref);
		s->sNum =	sNum++;
		s->flags =	0;

		Lst_AtEnd(&sufflist, s);
		/*
		 * Look for any existing transformations from or to this suffix.
		 * XXX: Only do this after a Suff_ClearSuffixes?
		 */
		Lst_ForEach(&transforms, SuffRebuildGraph, s);
	}
d703 2
a704 12
/*-
 *-----------------------------------------------------------------------
 * Suff_GetPath --
 *	Return the search path for the given suffix, if it's defined.
 *
 * Results:
 *	The searchPath for the desired suffix or NULL if the suffix isn't
 *	defined.
 *-----------------------------------------------------------------------
 */
Lst
Suff_GetPath(const char *sname)
d706 14
a719 9
	LstNode	  ln;
	Suff	  *s;

	ln = suff_find_by_name(sname);
	if (ln == NULL) {
		return NULL;
	} else {
		s = (Suff *)Lst_Datum(ln);
		return &s->searchPath;
d725 1
a725 1
 * Suff_DoPaths --
d738 2
a739 2
void
Suff_DoPaths(void)
d741 2
a742 8
	Suff		*s;
	LstNode		ln;
	char		*ptr;
	LIST		inIncludes; /* Cumulative .INCLUDES path */
	LIST		inLibs;     /* Cumulative .LIBS path */

	Lst_Init(&inIncludes);
	Lst_Init(&inLibs);
d744 3
a746 9
	for (ln = Lst_First(&sufflist); ln != NULL; ln = Lst_Adv(ln)) {
		s = (Suff *)Lst_Datum(ln);
		if (!Lst_IsEmpty(&s->searchPath)) {
			if (s->flags & SUFF_INCLUDE) {
				Dir_Concat(&inIncludes, &s->searchPath);
			}
			if (s->flags & SUFF_LIBRARY) {
				Dir_Concat(&inLibs, &s->searchPath);
			}
d748 1
a748 1
		} else
d752 2
a753 7
	Var_Set(".INCLUDES", ptr = Dir_MakeFlags("-I", &inIncludes));
	free(ptr);
	Var_Set(".LIBS", ptr = Dir_MakeFlags("-L", &inLibs));
	free(ptr);

	Lst_Destroy(&inIncludes, Dir_Destroy);
	Lst_Destroy(&inLibs, Dir_Destroy);
a755 11
/*-
 *-----------------------------------------------------------------------
 * Suff_AddInclude --
 *	Add the given suffix as a type of file which gets included.
 *	Called from the parse module when a .INCLUDES line is parsed.
 *	The suffix must have already been defined.
 *
 * Side Effects:
 *	The SUFF_INCLUDE bit is set in the suffix's flags field
 *-----------------------------------------------------------------------
 */
d757 1
a757 1
Suff_AddInclude(const char *sname)	/* Name of suffix to mark */
d759 6
a764 8
	LstNode	  ln;
	Suff	  *s;

	ln = suff_find_by_name(sname);
	if (ln != NULL) {
		s = (Suff *)Lst_Datum(ln);
		s->flags |= SUFF_INCLUDE;
	}
a765 26

/*-
 *-----------------------------------------------------------------------
 * Suff_AddLib --
 *	Add the given suffix as a type of file which is a library.
 *	Called from the parse module when parsing a .LIBS line. The
 *	suffix must have been defined via .SUFFIXES before this is
 *	called.
 *
 * Side Effects:
 *	The SUFF_LIBRARY bit is set in the suffix's flags field
 *-----------------------------------------------------------------------
 */
void
Suff_AddLib(const char *sname)	/* Name of suffix to mark */
{
	LstNode	  ln;
	Suff	  *s;

	ln = suff_find_by_name(sname);
	if (ln != NULL) {
		s = (Suff *)Lst_Datum(ln);
		s->flags |= SUFF_LIBRARY;
	}
}

d781 2
a782 2
    void *sp,	    /* suffix for which to create a Src structure */
    void *lsp)	    /* list and parent for the new Src */
d784 4
a787 4
	Suff	*s = (Suff *)sp;
	LstSrc	*ls = (LstSrc *)lsp;
	Src 	*s2;	    /* new Src structure */
	Src 	*targ;	    /* Target structure */
d798 6
a803 6
		s2->file =	estrdup(targ->pref);
		s2->pref =	targ->pref;
		s2->parent =	targ;
		s2->node =	NULL;
		s2->suff =	s;
		s2->children =	0;
d815 6
a820 6
	s2->file =	    Str_concat(targ->pref, s->name, 0);
	s2->pref =	    targ->pref;
	s2->parent =    targ;
	s2->node =	    NULL;
	s2->suff =	    s;
	s2->children =  0;
d824 1
a824 1
    Lst_Init(&s2->cp);
d844 2
a845 2
    Lst 	   l,		/* list to which to add the new level */
    Src 	   *targ)	/* Src structure to use as the parent */
d927 2
a928 2
    Lst 	   srcs,	/* list of Src structures to search through */
    Lst 	   slst)
d930 3
a932 3
	Src 	   *s;		/* current Src */
	Src 	   *rs; 	/* returned Src */
	char	   *ptr;
d937 1
a937 1
		if (DEBUG(SUFF)) {
a938 1
		}
d962 2
a963 3
		if (DEBUG(SUFF)) {
			printf("not there\n");
		}
d969 2
a970 3
	if (DEBUG(SUFF) && rs) {
		printf("got it\n");
	}
d993 7
a999 7
	LstNode		ln;	/* General-purpose list node */
	GNode		*t,	/* Target GNode */
			    *s;	/* Source GNode */
	int 		prefLen;/* The length of the defined prefix */
	Suff		*suff;	/* Suffix on matching beastie */
	Src 		*ret;	/* Return value */
	const char		*cp;
d1016 2
a1017 3
			LstNode ln2;
			ln2 = suff_find_by_name(&cp[prefLen]);
			if (ln2 != NULL) {
a1025 2
				suff = (Suff *)Lst_Datum(ln2);

d1050 4
a1053 3
					if (DEBUG(SUFF)) {
						printf ("\tusing existing source %s\n", s->name);
					}
d1055 1
a1055 1
			    }
d1065 3
a1067 3
	GNode	*gn;		/* New source 8) */
	char	*cp;		/* Expanded value */
	LIST	members;
d1088 1
a1088 1
		const char	*sacrifice = cp;
d1097 1
a1097 1
		char	    *start, *cp2;
d1123 1
a1123 1
		}
d1125 5
a1129 5
		if (cp2 != start) {
			/* Stuff left over -- add it to the list too.  */
			gn = Targ_FindNodei(start, cp2, TARG_CREATE);
			Lst_AtEnd(&members, gn);
		}
d1151 2
a1152 2
	LstNode	ln;		/* List element for old source */
	char	*cp;		/* Expanded value */
d1154 2
a1155 2
	LIST	exp;	    /* List of expansions */
	Lst 	path;	    /* Search path along which to expand */
d1166 1
a1166 5
	cp = cgn->name + strlen(cgn->name);
	ln = Lst_FindConst(&sufflist, SuffSuffIsSuffixP, cp);

	if (ln != NULL) {
		Suff	*s = (Suff *)Lst_Datum(ln);
d1168 1
d1182 1
a1182 1
		GNode		*gn;		/* New source 8) */
d1234 1
a1234 1
		/* Third case: nothing to expand.  */
d1298 1
a1298 1
	ln = transform_find_by_name(tname);
d1301 1
a1301 1
	if (ln == NULL)
a1308 2
	gn = (GNode *)Lst_Datum(ln);

d1332 13
d1357 1
a1357 1
    GNode	*gn,	    /* Node for which to locate dependencies */
d1360 5
a1364 5
	char	*eoarch;    /* End of archive portion */
	char	*eoname;    /* End of member portion */
	GNode	*mem;	    /* Node for member */
	Suff	*ms;	    /* Suffix descriptor for member */
	char	*name;	    /* Start of member's name */
a1416 1
		LstNode     ln;
d1418 1
a1418 2
		/* Use first matching suffix...  */
		ln = Lst_FindConst(&ms->parents, SuffSuffIsSuffixP, eoarch);
d1420 3
a1422 1
		if (ln != NULL) {
d1424 2
a1425 2
			if (!SuffApplyTransform(gn, mem, (Suff *)Lst_Datum(ln),
			    ms) && DEBUG(SUFF))
d1427 1
a1427 1
				    ms->name, ((Suff *)Lst_Datum(ln))->name);
d1442 59
a1514 3
	char	*eoname;    /* End of name */
	char	*sopref;    /* Start of prefix */
	LstNode	ln;	    /* Next suffix node to check */
d1516 9
a1524 11
	LIST	srcs;	    /* List of sources at which to look */
	LIST	targs;	    /* List of targets to which things can be
				 * transformed. They all have the same file,
				 * but different suff and pref fields */
	Src 	*bottom;    /* Start of found transformation path */
	Src 	*src;	    /* General Src pointer */
	char	*pref;	    /* Prefix to use */
	Src 	*targ;	    /* General Src target pointer */


	eoname = gn->name + strlen(gn->name);
a1525 1
	sopref = gn->name;
a1526 2
	/* Begin at the beginning...  */
	ln = Lst_First(&sufflist);
a1546 38
	while (ln != NULL) {
		/* Look for next possible suffix...  */
		ln = Lst_FindFromConst(ln, SuffSuffIsSuffixP, eoname);

		if (ln != NULL) {
			int     prefLen;	    /* Length of the prefix */
			Src     *targ;

			/* Allocate a Src structure to which things can be
			 * transformed.  */
			targ = emalloc(sizeof(Src));
			targ->file = estrdup(gn->name);
			targ->suff = (Suff *)Lst_Datum(ln);
			targ->node = gn;
			targ->parent = NULL;
			targ->children = 0;
#ifdef DEBUG_SRC
			Lst_Init(&targ->cp);
#endif

			/* Allocate room for the prefix, whose end is found by
			 * subtracting the length of the suffix from the end of
			 * the name.  */
			prefLen = (eoname - targ->suff->nameLen) - sopref;
			targ->pref = emalloc(prefLen + 1);
			memcpy(targ->pref, sopref, prefLen);
			targ->pref[prefLen] = '\0';

			/* Add nodes from which the target can be made.  */
			SuffAddLevel(&srcs, targ);

			/* Record the target so we can nuke it.  */
			Lst_AtEnd(&targs, targ);

			/* Search from this suffix's successor...  */
			ln = Lst_Succ(ln);
		}
	}
d1548 1
d1550 2
a1551 2
	if (Lst_IsEmpty(&targs) && suffNull != NULL) {
		if (DEBUG(SUFF)) {
a1553 1
		}
d1561 1
a1561 1
		targ->pref = estrdup(sopref);
d1620 3
a1622 3
		/* Deal with finding the thing on the default search path if
		 * the node is only a source (not on the lhs of a dependency
		 * operator or [XXX] it has neither children or commands).  */
d1646 2
a1647 2
					if ((ptr = strrchr(gn->path, '/'))
					    != NULL)
d1656 2
a1657 2
					/* The .PREFIX gets the full path if
					 * the target has no known suffix.  */
d1660 2
a1661 2
					if ((ptr = strrchr(gn->path, '/'))
					    != NULL)
d1729 2
a1730 2
		SuffApplyTransform(targ->node, src->node, targ->suff,
		    src->suff);
d1814 1
a1814 1
	if (DEBUG(SUFF)) {
a1815 1
	}
a1827 1
		LstNode ln;
d1830 3
a1832 3
		ln = suff_find_by_name(LIBSUFF);
		if (ln != NULL) {
			gn->suffix = s = (Suff *)Lst_Datum(ln);
a1848 7
 *-----------------------------------------------------------------------
 * Suff_SetNull --
 *	Define which suffix is the null suffix.
 *
 * Side Effects:
 *	'suffNull' is altered.
 *
a1849 3
 *	Need to handle the changing of the null suffix gracefully so the
 *	old transformation rules don't just go away.
 *-----------------------------------------------------------------------
d1852 1
a1852 1
Suff_SetNull(const char *name)
a1854 1
	LstNode ln;
d1856 4
a1859 6
	ln = suff_find_by_name(name);
	if (ln != NULL) {
		s = (Suff *)Lst_Datum(ln);
		if (suffNull != NULL) {
			suffNull->flags &= ~SUFF_NULL;
		}
d1864 3
a1886 4
	Static_Lst_Init(&sufflist);
#ifdef CLEANUP
	Static_Lst_Init(&suffClean);
#endif
d1888 1
a1888 1
	Static_Lst_Init(&transforms);
a1889 1
	sNum = 0;
d1895 8
a1902 11
	emptySuff = suffNull = emalloc(sizeof(Suff));

	suffNull->name =	    estrdup("");
	suffNull->nameLen =     0;
	Lst_Init(&suffNull->searchPath);
	Dir_Concat(&suffNull->searchPath, defaultPath);
	Lst_Init(&suffNull->children);
	Lst_Init(&suffNull->parents);
	Lst_Init(&suffNull->ref);
	suffNull->sNum =	    sNum++;
	suffNull->flags =	    SUFF_NULL;
d1921 3
a1923 4
	Lst_Destroy(&sufflist, SuffFree);
	Lst_Destroy(&suffClean, SuffFree);
	if (suffNull)
		SuffFree(suffNull);
d1925 1
a1925 1
	Lst_Destroy(&transforms, NOFREE);
d1932 2
a1933 1
static void SuffPrintName(void *s)
d1980 1
a1980 1
SuffPrintTrans(void *tp)
a1981 2
	GNode   *t = (GNode *)tp;

d1992 4
d1997 4
a2000 1
	Lst_Every(&sufflist, SuffPrintSuff);
d2003 3
a2005 1
	Lst_Every(&transforms, SuffPrintTrans);
@


1.68
log
@reindent garray.h, add new function, to be used later
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.67 2007/09/17 09:28:36 espie Exp $ */
a106 1
#include "make.h"
d108 1
@


1.67
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.66 2007/09/17 09:16:58 espie Exp $ */
d1180 1
a1180 1
		char	*sacrifice = cp;
@


1.66
log
@reindent
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.65 2007/09/17 08:36:57 espie Exp $ */
d313 1
a313 1
	return SuffStrIsPrefix(((Suff *)s)->name, 
d466 1
a466 1
			srcLn = Lst_FindFromConst(Lst_Succ(srcLn), 
d1040 1
a1040 1
		if ((ptr = Dir_FindFile(s->file, &s->suff->searchPath)) 
d1119 1
a1119 1
				if (Lst_Member(&suff->parents, targ->suff) 
d1407 1
a1407 1
		printf("\tapplying %s -> %s to \"%s\"\n", s->name, t->name, 
d1695 1
a1695 1
		    (Lst_IsEmpty(&gn->children) && 
d1708 1
a1708 1
					int savep = strlen(gn->path) - 
d1717 1
a1717 1
					if ((ptr = strrchr(gn->path, '/')) 
d1731 1
a1731 1
					if ((ptr = strrchr(gn->path, '/')) 
d1800 1
a1800 1
		SuffApplyTransform(targ->node, src->node, targ->suff, 
d1953 1
a1953 1
		Parse_Error(PARSE_WARNING, 
@


1.65
log
@kill += 1, -= 1     -> ++, --
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.64 2007/09/16 12:30:35 espie Exp $ */
d215 4
a218 4
    while (*str && *prefix == *str) {
	prefix++;
	str++;
    }
d220 1
a220 1
    return *prefix ? NULL : (char *)str;
d237 2
a238 2
    const char	   *p1; 	/* Pointer into suffix name */
    const char	   *p2; 	/* Pointer into string being examined */
d240 2
a241 2
    p1 = s->name + s->nameLen;
    p2 = str;
d243 6
a248 6
    while (p1 != s->name) {
	p1--;
	p2--;
	if (*p1 != *p2)
		return NULL;
    }
d250 1
a250 1
    return (char *)p2;
d266 1
a266 1
    return !SuffSuffIsSuffix((Suff *)s, (const char *)str);
d272 1
a272 1
    return strcmp((const char *)sname, ((Suff *)s)->name);
d279 1
a279 1
    STAT_SUFF_LOOKUP_NAME++;
d281 1
a281 1
    return Lst_FindConst(&sufflist, SuffHasNameP, name);
d287 1
a287 1
    return strcmp((const char *)name, ((GNode *)gn)->name);
d294 1
a294 1
    STAT_TRANSFORM_LOOKUP_NAME++;
d296 1
a296 1
    return Lst_FindConst(&transforms, GNodeHasNameP, name);
d313 2
a314 1
    return SuffStrIsPrefix(((Suff *)s)->name, (const char *)str) == NULL ? 1 : 0;
d322 4
a325 4
    LstNode ln = Lst_Member(l, sp);
    if (ln != NULL)
	Lst_Remove(l, ln);
}
d340 1
a340 1
    Suff	*s = (Suff *)sp;
d342 2
a343 2
    if (s == suffNull)
	suffNull = NULL;
d345 2
a346 2
    if (s == emptySuff)
	emptySuff = NULL;
d348 4
a351 4
    Lst_Destroy(&s->ref, NOFREE);
    Lst_Destroy(&s->children, NOFREE);
    Lst_Destroy(&s->parents, NOFREE);
    Lst_Destroy(&s->searchPath, Dir_Destroy);
d353 2
a354 2
    free(s->name);
    free(s);
d372 2
a373 2
    LstNode	  ln;		/* current element in l we're examining */
    Suff	  *s2 = NULL;	/* the suffix descriptor in this element */
d375 5
a379 5
    for (ln = Lst_First(l); ln != NULL; ln = Lst_Adv(ln)) {
	s2 = (Suff *)Lst_Datum(ln);
	if (s2->sNum >= s->sNum)
	    break;
    }
a380 4
    if (DEBUG(SUFF)) {
	printf("inserting %s(%d)...", s->name, s->sNum);
    }
    if (ln == NULL) {
d382 1
a382 1
	    printf("at end of list\n");
d384 14
a397 5
	Lst_AtEnd(l, s);
	Lst_AtEnd(&s->ref, l);
    } else if (s2->sNum != s->sNum) {
	if (DEBUG(SUFF)) {
	    printf("before %s(%d)\n", s2->name, s2->sNum);
a398 5
	Lst_Insert(l, ln, s);
	Lst_AtEnd(&s->ref, l);
    } else if (DEBUG(SUFF)) {
	printf("already there\n");
    }
d419 1
a419 1
    Lst_ConcatDestroy(&suffClean, &sufflist);
d421 3
a423 3
    Lst_Init(&sufflist);
    sNum = 0;
    suffNull = emptySuff;
d444 58
a501 55
    LstNode		srcLn;	    /* element in suffix list of trans source*/
    Suff		*src;	    /* Source of transformation */
    LstNode		targLn;     /* element in suffix list of trans target*/
    const char		*str2;	    /* Extra pointer (maybe target suffix) */
    LstNode		singleLn;   /* element in suffix list of any suffix
				     * that exactly matches str */
    Suff		*single = NULL;/* Source of possible transformation to
				     * null suffix */

    srcLn = NULL;
    singleLn = NULL;

    /*
     * Loop looking first for a suffix that matches the start of the
     * string and then for one that exactly matches the rest of it. If
     * we can find two that meet these criteria, we've successfully
     * parsed the string.
     */
    for (;;) {
	if (srcLn == NULL)
	    srcLn = Lst_FindConst(&sufflist, SuffSuffIsPrefix, str);
	else
	    srcLn = Lst_FindFromConst(Lst_Succ(srcLn), SuffSuffIsPrefix, str);
	if (srcLn == NULL) {
	    /*
	     * Ran out of source suffixes -- no such rule
	     */
	    if (singleLn != NULL) {
		/*
		 * Not so fast Mr. Smith! There was a suffix that encompassed
		 * the entire string, so we assume it was a transformation
		 * to the null suffix (thank you POSIX). We still prefer to
		 * find a double rule over a singleton, hence we leave this
		 * check until the end.
		 *
		 * XXX: Use emptySuff over suffNull?
		 */
		*srcPtr = single;
		*targPtr = suffNull;
		return true;
	    }
	    return false;
	}
	src = (Suff *)Lst_Datum(srcLn);
	str2 = str + src->nameLen;
	if (*str2 == '\0') {
	    single = src;
	    singleLn = srcLn;
	} else {
	    targLn = suff_find_by_name(str2);
	    if (targLn != NULL) {
		*srcPtr = src;
		*targPtr = (Suff *)Lst_Datum(targLn);
		return true;
	    }
a502 1
    }
d518 1
a518 1
    Suff	  *src, *targ;
d520 1
a520 1
    return SuffParseTransform(str, &src, &targ);
d540 4
a543 4
    GNode	  *gn;		/* GNode of transformation rule */
    Suff	  *s,		/* source suffix */
		  *t;		/* target suffix */
    LstNode	  ln;		/* Node for existing transformation */
d545 22
a566 21
    ln = transform_find_by_name(line);
    if (ln == NULL) {
	/*
	 * Make a new graph node for the transformation. It will be filled in
	 * by the Parse module.
	 */
	gn = Targ_NewGN(line);
	Lst_AtEnd(&transforms, gn);
    } else {
	/*
	 * New specification for transformation rule. Just nuke the old list
	 * of commands so they can be filled in again... We don't actually
	 * free the commands themselves, because a given command can be
	 * attached to several different transformations.
	 */
	gn = (GNode *)Lst_Datum(ln);
	Lst_Destroy(&gn->commands, NOFREE);
	Lst_Init(&gn->commands);
	Lst_Destroy(&gn->children, NOFREE);
	Lst_Init(&gn->children);
    }
d568 1
a568 1
    gn->type = OP_TRANSFORM;
d570 1
a570 1
    (void)SuffParseTransform(line, &s, &t);
d572 9
a580 9
    /*
     * link the two together in the proper relationship and order
     */
    if (DEBUG(SUFF)) {
	printf("defining transformation from `%s' to `%s'\n",
		s->name, t->name);
    }
    SuffInsert(&t->children, s);
    SuffInsert(&s->parents, t);
d582 1
a582 1
    return gn;
d601 1
a601 1
    GNode *gn = (GNode *)gnp;
d603 11
a613 4
    if ((gn->type & OP_TRANSFORM) && Lst_IsEmpty(&gn->commands) &&
	Lst_IsEmpty(&gn->children))
    {
	Suff	*s, *t;
d615 7
a621 2
	if (!SuffParseTransform(gn->name, &s, &t))
	    return;
d623 7
a629 3
	if (DEBUG(SUFF)) {
	    printf("deleting transformation from `%s' to `%s'\n",
		    s->name, t->name);
a630 17

	/*
	 * Remove the source from the target's children list.
	 *
	 * We'll be called twice when the next target is seen, but .c and .o
	 * are only linked once...
	 */
	SuffUnRef(&t->children, s);

	/*
	 * Remove the target from the source's parents list
	 */
	if (s != NULL)
	    SuffUnRef(&s->parents, t);
    } else if ((gn->type & OP_TRANSFORM) && DEBUG(SUFF)) {
	printf("transformation %s complete\n", gn->name);
    }
d653 18
a670 17
    GNode	*transform = (GNode *)transformp;
    Suff	*s = (Suff *)sp;
    char	*cp;
    LstNode	ln;
    Suff	*s2;

    /* First see if it is a transformation from this suffix.  */
    cp = SuffStrIsPrefix(s->name, transform->name);
    if (cp != NULL) {
	ln = suff_find_by_name(cp);
	if (ln != NULL) {
	    /* Found target. Link in and return, since it can't be anything
	     * else.  */
	    s2 = (Suff *)Lst_Datum(ln);
	    SuffInsert(&s2->children, s);
	    SuffInsert(&s->parents, s2);
	    return;
a671 1
    }
d673 14
a686 13
    /* Not from, maybe to?  */
    cp = SuffSuffIsSuffix(s, transform->name + strlen(transform->name));
    if (cp != NULL) {
	/* Null-terminate the source suffix in order to find it.  */
	*cp = '\0';
	ln = suff_find_by_name(transform->name);
	/* Replace the start of the target suffix.  */
	*cp = s->name[0];
	if (ln != NULL) {
	    /* Found it -- establish the proper relationship.  */
	    s2 = (Suff *)Lst_Datum(ln);
	    SuffInsert(&s->children, s2);
	    SuffInsert(&s2->parents, s);
a687 1
    }
d704 2
a705 2
    Suff	  *s;	    /* new suffix descriptor */
    LstNode	  ln;
d707 12
a718 12
    ln = suff_find_by_name(str);
    if (ln == NULL) {
	s = emalloc(sizeof(Suff));

	s->name =	estrdup(str);
	s->nameLen =	strlen(s->name);
	Lst_Init(&s->searchPath);
	Lst_Init(&s->children);
	Lst_Init(&s->parents);
	Lst_Init(&s->ref);
	s->sNum =	sNum++;
	s->flags =	0;
d720 7
a726 7
	Lst_AtEnd(&sufflist, s);
	/*
	 * Look for any existing transformations from or to this suffix.
	 * XXX: Only do this after a Suff_ClearSuffixes?
	 */
	Lst_ForEach(&transforms, SuffRebuildGraph, s);
    }
d742 2
a743 2
    LstNode	  ln;
    Suff	  *s;
d745 7
a751 7
    ln = suff_find_by_name(sname);
    if (ln == NULL) {
	return NULL;
    } else {
	s = (Suff *)Lst_Datum(ln);
	return &s->searchPath;
    }
d772 27
a798 27
    Suff		*s;
    LstNode		ln;
    char		*ptr;
    LIST		inIncludes; /* Cumulative .INCLUDES path */
    LIST		inLibs;     /* Cumulative .LIBS path */

    Lst_Init(&inIncludes);
    Lst_Init(&inLibs);

    for (ln = Lst_First(&sufflist); ln != NULL; ln = Lst_Adv(ln)) {
	s = (Suff *)Lst_Datum(ln);
	if (!Lst_IsEmpty(&s->searchPath)) {
	    if (s->flags & SUFF_INCLUDE) {
		Dir_Concat(&inIncludes, &s->searchPath);
	    }
	    if (s->flags & SUFF_LIBRARY) {
		Dir_Concat(&inLibs, &s->searchPath);
	    }
	    Dir_Concat(&s->searchPath, defaultPath);
	} else
	    Lst_Clone(&s->searchPath, defaultPath, Dir_CopyDir);
    }

    Var_Set(".INCLUDES", ptr = Dir_MakeFlags("-I", &inIncludes));
    free(ptr);
    Var_Set(".LIBS", ptr = Dir_MakeFlags("-L", &inLibs));
    free(ptr);
d800 2
a801 2
    Lst_Destroy(&inIncludes, Dir_Destroy);
    Lst_Destroy(&inLibs, Dir_Destroy);
d818 2
a819 2
    LstNode	  ln;
    Suff	  *s;
d821 5
a825 5
    ln = suff_find_by_name(sname);
    if (ln != NULL) {
	s = (Suff *)Lst_Datum(ln);
	s->flags |= SUFF_INCLUDE;
    }
d843 2
a844 2
    LstNode	  ln;
    Suff	  *s;
d846 5
a850 5
    ln = suff_find_by_name(sname);
    if (ln != NULL) {
	s = (Suff *)Lst_Datum(ln);
	s->flags |= SUFF_LIBRARY;
    }
d871 4
a874 4
    Suff	*s = (Suff *)sp;
    LstSrc	*ls = (LstSrc *)lsp;
    Src 	*s2;	    /* new Src structure */
    Src 	*targ;	    /* Target structure */
d876 1
a876 1
    targ = ls->s;
d878 23
a900 6
    if ((s->flags & SUFF_NULL) && *s->name != '\0') {
	/*
	 * If the suffix has been marked as the NULL suffix, also create a Src
	 * structure for a file with no suffix attached. Two birds, and all
	 * that...
	 */
d902 6
a907 6
	s2->file =	estrdup(targ->pref);
	s2->pref =	targ->pref;
	s2->parent =	targ;
	s2->node =	NULL;
	s2->suff =	s;
	s2->children =	0;
d911 1
a911 1
	Lst_Init(&s2->cp);
d913 1
a913 1
	printf("1 add %x %x to %x:", targ, s2, ls->l);
a916 17
    }
    s2 = emalloc(sizeof(Src));
    s2->file =	    Str_concat(targ->pref, s->name, 0);
    s2->pref =	    targ->pref;
    s2->parent =    targ;
    s2->node =	    NULL;
    s2->suff =	    s;
    s2->children =  0;
    targ->children++;
    Lst_AtEnd(ls->l, s2);
#ifdef DEBUG_SRC
    Lst_Init(&s2->cp);
    Lst_AtEnd(&targ->cp, s2);
    printf("2 add %x %x to %x:", targ, s2, ls->l);
    Lst_Every(ls->l, PrintAddr);
    printf("\n");
#endif
d934 1
a934 1
    LstSrc	   ls;
d936 2
a937 2
    ls.s = targ;
    ls.l = l;
d939 1
a939 1
    Lst_ForEach(&targ->suff->children, SuffAddSrc, &ls);
d957 3
a959 3
    LstNode ln;
    Src *s;
    int t = 0;
d962 3
a964 3
    printf("cleaning %lx: ", (unsigned long)l);
    Lst_Every(l, PrintAddr);
    printf("\n");
d968 7
a974 7
    for (ln = Lst_First(l); ln != NULL; ln = Lst_Adv(ln)) {
	s = (Src *)Lst_Datum(ln);
	if (s->children == 0) {
	    free(s->file);
	    if (!s->parent)
		free(s->pref);
	    else {
d976 3
a978 3
		LstNode ln2 = Lst_Member(&s->parent->cp, s);
		if (ln2 != NULL)
		    Lst_Remove(&s->parent->cp, ln2);
d980 2
a981 2
		--s->parent->children;
	    }
d983 2
a984 2
	    printf("free: [l=%x] p=%x %d\n", l, s, s->children);
	    Lst_Destroy(&s->cp, NOFREE);
d986 5
a990 5
	    Lst_Remove(l, ln);
	    free(s);
	    t |= 1;
	    return true;
	}
d992 6
a997 4
	else {
	    printf("keep: [l=%x] p=%x %d: ", l, s, s->children);
	    Lst_Every(&s->cp, PrintAddr);
	    printf("\n");
a998 2
#endif
    }
d1000 1
a1000 1
    return t;
d1017 10
a1026 3
    Src 	   *s;		/* current Src */
    Src 	   *rs; 	/* returned Src */
    char	   *ptr;
d1028 5
a1032 12
    rs = NULL;

    while ((s = (Src *)Lst_DeQueue(srcs)) != NULL) {
	if (DEBUG(SUFF)) {
	    printf("\ttrying %s...", s->file);
	}

	/*
	 * A file is considered to exist if either a node exists in the
	 * graph for it or the file actually exists.
	 */
	if (Targ_FindNode(s->file, TARG_NOCREATE) != NULL) {
d1034 1
a1034 1
	    printf("remove %x from %x\n", s, srcs);
d1036 3
a1038 3
	    rs = s;
	    break;
	}
d1040 3
a1042 2
	if ((ptr = Dir_FindFile(s->file, &s->suff->searchPath)) != NULL) {
	    rs = s;
d1044 1
a1044 1
	    printf("remove %x from %x\n", s, srcs);
d1046 10
a1055 2
	    free(ptr);
	    break;
d1058 2
a1059 2
	if (DEBUG(SUFF)) {
	    printf("not there\n");
d1061 1
a1061 9

	SuffAddLevel(srcs, s);
	Lst_AtEnd(slst, s);
    }

    if (DEBUG(SUFF) && rs) {
	printf("got it\n");
    }
    return rs;
d1083 54
a1136 49
    LstNode		ln;	/* General-purpose list node */
    GNode		*t,	/* Target GNode */
			*s;	/* Source GNode */
    int 		prefLen;/* The length of the defined prefix */
    Suff		*suff;	/* Suffix on matching beastie */
    Src 		*ret;	/* Return value */
    const char		*cp;

    t = targ->node;
    prefLen = strlen(targ->pref);

    for (ln = Lst_First(&t->children); ln != NULL; ln = Lst_Adv(ln)) {
	s = (GNode *)Lst_Datum(ln);

	cp = strrchr(s->name, '/');
	if (cp == NULL) {
	    cp = s->name;
	} else {
	    cp++;
	}
	if (strncmp(cp, targ->pref, prefLen) == 0) {
	    /* The node matches the prefix ok, see if it has a known
	     * suffix.	*/
	    LstNode ln2;
	    ln2 = suff_find_by_name(&cp[prefLen]);
	    if (ln2 != NULL) {
		/*
		 * It even has a known suffix, see if there's a transformation
		 * defined between the node's suffix and the target's suffix.
		 *
		 * XXX: Handle multi-stage transformations here, too.
		 */
		suff = (Suff *)Lst_Datum(ln2);

		if (Lst_Member(&suff->parents, targ->suff) != NULL) {
		    /*
		     * Hot Damn! Create a new Src structure to describe
		     * this transformation (making sure to duplicate the
		     * source node's name so Suff_FindDeps can free it
		     * again (ick)), and return the new structure.
		     */
		    ret = emalloc(sizeof(Src));
		    ret->file = estrdup(s->name);
		    ret->pref = targ->pref;
		    ret->suff = suff;
		    ret->parent = targ;
		    ret->node = s;
		    ret->children = 0;
		    targ->children++;
d1138 11
a1148 9
		    Lst_Init(&ret->cp);
		    printf("3 add %x %x\n", targ, ret);
		    Lst_AtEnd(&targ->cp, ret);
#endif
		    Lst_AtEnd(slst, ret);
		    if (DEBUG(SUFF)) {
			printf ("\tusing existing source %s\n", s->name);
		    }
		    return ret;
a1149 1
	    }
d1151 1
a1151 2
    }
    return NULL;
d1157 4
a1160 3
    GNode	*gn;		/* New source 8) */
    char	*cp;		/* Expanded value */
    LIST	members;
d1162 2
d1165 6
a1170 2
    if (DEBUG(SUFF))
	printf("Expanding \"%s\"...", cgn->name);
d1172 1
a1172 6
    cp = Var_Subst(cgn->name, &pgn->context, true);
    if (cp == NULL) {
	printf("Problem substituting in %s", cgn->name);
	printf("\n");
	return;
    }
d1174 7
a1180 1
    Lst_Init(&members);
d1182 34
a1215 7
    if (cgn->type & OP_ARCHV) {
	/*
	 * Node was an archive(member) target, so we want to call
	 * on the Arch module to find the nodes for us, expanding
	 * variables in the parent's context.
	 */
	char	*sacrifice = cp;
d1217 5
a1221 38
	(void)Arch_ParseArchive(&sacrifice, &members, &pgn->context);
    } else {
	/* Break the result into a vector of strings whose nodes
	 * we can find, then add those nodes to the members list.
	 * Unfortunately, we can't use brk_string because it
	 * doesn't understand about variable specifications with
	 * spaces in them...  */
	char	    *start, *cp2;

	for (start = cp; *start == ' ' || *start == '\t'; start++)
	    continue;
	for (cp2 = start; *cp2 != '\0';) {
	    if (isspace(*cp2)) {
		/* White-space -- terminate element, find the node,
		 * add it, skip any further spaces.  */
		gn = Targ_FindNodei(start, cp2, TARG_CREATE);
		cp2++;
		Lst_AtEnd(&members, gn);
		while (isspace(*cp2))
		    cp2++;
		/* Adjust cp2 for increment at start of loop, but
		 * set start to first non-space.  */
		start = cp2;
	    } else if (*cp2 == '$')
		/* Start of a variable spec -- contact variable module
		 * to find the end so we can skip over it.  */
		Var_ParseSkip(&cp2, &pgn->context);
	    else if (*cp2 == '\\' && cp2[1] != '\0')
		/* Escaped something -- skip over it.  */
		cp2+=2;
	    else
	    	cp2++;
	}

	if (cp2 != start) {
	    /* Stuff left over -- add it to the list too.  */
	    gn = Targ_FindNodei(start, cp2, TARG_CREATE);
	    Lst_AtEnd(&members, gn);
d1223 13
a1235 3
    }
    /* Add all elements of the members list to the parent node.  */
    while ((gn = (GNode *)Lst_DeQueue(&members)) != NULL) {
d1237 1
a1237 12
	    printf("%s...", gn->name);
	if (Lst_Member(&pgn->children, gn) == NULL) {
	    Lst_Append(&pgn->children, after, gn);
	    after = Lst_Adv(after);
	    Lst_AtEnd(&gn->parents, pgn);
	    pgn->unmade++;
	}
    }
    /* Free the result.  */
    free(cp);
    if (DEBUG(SUFF))
	printf("\n");
d1243 2
a1244 2
    LstNode	ln;		/* List element for old source */
    char	*cp;		/* Expanded value */
d1246 2
a1247 2
    LIST	exp;	    /* List of expansions */
    Lst 	path;	    /* Search path along which to expand */
d1249 2
a1250 2
    if (DEBUG(SUFF))
	printf("Wildcard expanding \"%s\"...", cgn->name);
d1252 8
a1259 8
    /* Find a path along which to expand the word.
     *
     * If the word has a known suffix, use that path.
     * If it has no known suffix and we're allowed to use the null
     *	 suffix, use its path.
     * Else use the default system search path.  */
    cp = cgn->name + strlen(cgn->name);
    ln = Lst_FindConst(&sufflist, SuffSuffIsSuffixP, cp);
d1261 2
a1262 2
    if (ln != NULL) {
	Suff	*s = (Suff *)Lst_Datum(ln);
d1264 6
a1269 17
	if (DEBUG(SUFF))
	    printf("suffix is \"%s\"...", s->name);
	path = &s->searchPath;
    } else
	/* Use default search path.  */
	path = defaultPath;

    /* Expand the word along the chosen path. */
    Lst_Init(&exp);
    Dir_Expand(cgn->name, path, &exp);

    /* Fetch next expansion off the list and find its GNode.  */
    while ((cp = (char *)Lst_DeQueue(&exp)) != NULL) {
	GNode		*gn;		/* New source 8) */
	if (DEBUG(SUFF))
	    printf("%s...", cp);
	gn = Targ_FindNode(cp, TARG_CREATE);
d1271 19
a1289 7
	/* If gn isn't already a child of the parent, make it so and
	 * up the parent's count of unmade children.  */
	if (Lst_Member(&pgn->children, gn) == NULL) {
	    Lst_Append(&pgn->children, after, gn);
	    after = Lst_Adv(after);
	    Lst_AtEnd(&gn->parents, pgn);
	    pgn->unmade++;
a1290 1
    }
d1292 2
a1293 2
    if (DEBUG(SUFF))
	printf("\n");
d1313 23
a1335 23
    GNode	*cgn = (GNode *)cgnp;
    GNode	*pgn = (GNode *)pgnp;
    LstNode	ln;
    /* New nodes effectively take the place of the child, so we place them
     * after the child.  */
    ln = Lst_Member(&pgn->children, cgn);

    /* First do variable expansion -- this takes precedence over
     * wildcard expansion. If the result contains wildcards, they'll be gotten
     * to later since the resulting words are tacked on to the end of
     * the children list.  */
    if (strchr(cgn->name, '$') != NULL)
	SuffExpandVarChildren(ln, cgn, pgn);
    else if (Dir_HasWildcards(cgn->name))
	SuffExpandWildChildren(ln, cgn, pgn);
    else
	/* Third case: nothing to expand.  */
	return;

    /* Since the source was expanded, remove it from the list of children to
     * keep it from being processed.  */
    pgn->unmade--;
    Lst_Remove(&pgn->children, ln);
d1362 4
a1365 11
    LstNode	ln;	/* General node */
    LstNode	np;	    /* Next node for loop */
    char	*tname; /* Name of transformation rule */
    GNode	*gn;	/* Node for same */

    if (Lst_AddNew(&tGn->children, sGn)) {
	/* Not already linked, so form the proper links between the
	 * target and source.  */
	Lst_AtEnd(&sGn->parents, tGn);
	tGn->unmade++;
    }
d1367 1
a1367 9
    if ((sGn->type & OP_OPMASK) == OP_DOUBLEDEP) {
	/* When a :: node is used as the implied source of a node, we have
	 * to link all its cohorts in as sources as well. Only the initial
	 * sGn gets the target in its iParents list, however, as that
	 * will be sufficient to get the .IMPSRC variable set for tGn.	*/
	for (ln=Lst_First(&sGn->cohorts); ln != NULL; ln=Lst_Adv(ln)) {
	    gn = (GNode *)Lst_Datum(ln);

	    if (Lst_AddNew(&tGn->children, gn)) {
d1370 1
a1370 1
		Lst_AtEnd(&gn->parents, tGn);
a1371 1
	    }
a1372 5
    }
    /* Locate the transformation rule itself.  */
    tname = Str_concat(s->name, t->name, 0);
    ln = transform_find_by_name(tname);
    free(tname);
d1374 29
a1402 7
    if (ln == NULL)
	/*
	 * Not really such a transformation rule (can happen when we're
	 * called to link an OP_MEMBER and OP_ARCHV node), so return
	 * false.
	 */
	return false;
d1404 1
a1404 1
    gn = (GNode *)Lst_Datum(ln);
d1406 3
a1408 2
    if (DEBUG(SUFF))
	printf("\tapplying %s -> %s to \"%s\"\n", s->name, t->name, tGn->name);
d1410 2
a1411 2
    /* Record last child for expansion purposes.  */
    ln = Lst_Last(&tGn->children);
d1413 2
a1414 2
    /* Pass the buck to Make_HandleUse to apply the rule.  */
    Make_HandleUse(gn, tGn);
d1416 5
a1420 5
    /* Deal with wildcards and variables in any acquired sources.  */
    for (ln = Lst_Succ(ln); ln != NULL; ln = np) {
    	np = Lst_Adv(ln);
	SuffExpandChildren(Lst_Datum(ln), tGn);
    }
d1422 3
a1424 3
    /* Keep track of another parent to which this beast is transformed so
     * the .IMPSRC variable can be set correctly for the parent.  */
    Lst_AtEnd(&sGn->iParents, tGn);
d1426 1
a1426 1
    return true;
d1444 44
a1487 31
    char	*eoarch;    /* End of archive portion */
    char	*eoname;    /* End of member portion */
    GNode	*mem;	    /* Node for member */
    Suff	*ms;	    /* Suffix descriptor for member */
    char	*name;	    /* Start of member's name */

    /* The node is an archive(member) pair. so we must find a suffix
     * for both of them.  */
    eoarch = strchr(gn->name, '(');
    if (eoarch == NULL)
	return;

    name = eoarch + 1;

    eoname = strchr(name, ')');
    if (eoname == NULL)
	return;

    /* To simplify things, call Suff_FindDeps recursively on the member now,
     * so we can simply compare the member's .PREFIX and .TARGET variables
     * to locate its suffix. This allows us to figure out the suffix to
     * use for the archive without having to do a quadratic search over the
     * suffix list, backtracking for each one...  */
    mem = Targ_FindNodei(name, eoname, TARG_CREATE);
    SuffFindDeps(mem, slst);

    /* Create the link between the two nodes right off. */
    if (Lst_AddNew(&gn->children, mem)) {
	Lst_AtEnd(&mem->parents, gn);
	gn->unmade++;
    }
a1488 11
    /* Copy variables from member node to this one.  */
    Varq_Set(TARGET_INDEX, Varq_Value(TARGET_INDEX, mem), gn);
    Varq_Set(PREFIX_INDEX, Varq_Value(PREFIX_INDEX, mem), gn);

    ms = mem->suffix;
    if (ms == NULL) {
	/* Didn't know what it was -- use .NULL suffix if not in make mode.  */
	if (DEBUG(SUFF))
	    printf("using null suffix\n");
	ms = suffNull;
    }
d1490 3
d1494 8
a1501 3
    /* Set the other two local variables required for this target.  */
    Varq_Set(MEMBER_INDEX, mem->name, gn);
    Varq_Set(ARCHIVE_INDEX, gn->name, gn);
d1503 2
a1504 8
    if (ms != NULL) {
	/*
	 * Member has a known suffix, so look for a transformation rule from
	 * it to a possible suffix of the archive. Rather than searching
	 * through the entire list, we just look at suffixes to which the
	 * member's suffix may be transformed...
	 */
	LstNode     ln;
d1506 7
a1512 9
	/* Use first matching suffix...  */
	ln = Lst_FindConst(&ms->parents, SuffSuffIsSuffixP, eoarch);

	if (ln != NULL) {
	    /* Got one -- apply it.  */
	    if (!SuffApplyTransform(gn, mem, (Suff *)Lst_Datum(ln), ms) &&
		DEBUG(SUFF))
		printf("\tNo transformation from %s -> %s\n",
		       ms->name, ((Suff *)Lst_Datum(ln))->name);
a1513 1
    }
d1515 9
a1523 9
    /* Pretend gn appeared to the left of a dependency operator so
     * the user needn't provide a transformation from the member to the
     * archive.  */
    if (OP_NOP(gn->type))
	gn->type |= OP_DEPENDS;

    /* Flag the member as such so we remember to look in the archive for
     * its modification time.  */
    mem->type |= OP_MEMBER;
d1540 56
a1595 55
    char	*eoname;    /* End of name */
    char	*sopref;    /* Start of prefix */
    LstNode	ln;	    /* Next suffix node to check */
    LstNode	np;
    LIST	srcs;	    /* List of sources at which to look */
    LIST	targs;	    /* List of targets to which things can be
			     * transformed. They all have the same file,
			     * but different suff and pref fields */
    Src 	*bottom;    /* Start of found transformation path */
    Src 	*src;	    /* General Src pointer */
    char	*pref;	    /* Prefix to use */
    Src 	*targ;	    /* General Src target pointer */


    eoname = gn->name + strlen(gn->name);

    sopref = gn->name;

    /* Begin at the beginning...  */
    ln = Lst_First(&sufflist);
    Lst_Init(&srcs);
    Lst_Init(&targs);

    /* We're caught in a catch-22 here. On the one hand, we want to use any
     * transformation implied by the target's sources, but we can't examine
     * the sources until we've expanded any variables/wildcards they may hold,
     * and we can't do that until we've set up the target's local variables
     * and we can't do that until we know what the proper suffix for the
     * target is (in case there are two suffixes one of which is a suffix of
     * the other) and we can't know that until we've found its implied
     * source, which we may not want to use if there's an existing source
     * that implies a different transformation.
     *
     * In an attempt to get around this, which may not work all the time,
     * but should work most of the time, we look for implied sources first,
     * checking transformations to all possible suffixes of the target,
     * use what we find to set the target's local variables, expand the
     * children, then look for any overriding transformations they imply.
     * Should we find one, we discard the one we found before.	*/

    while (ln != NULL) {
	/* Look for next possible suffix...  */
	ln = Lst_FindFromConst(ln, SuffSuffIsSuffixP, eoname);

	if (ln != NULL) {
	    int     prefLen;	    /* Length of the prefix */
	    Src     *targ;

	    /* Allocate a Src structure to which things can be transformed.  */
	    targ = emalloc(sizeof(Src));
	    targ->file = estrdup(gn->name);
	    targ->suff = (Suff *)Lst_Datum(ln);
	    targ->node = gn;
	    targ->parent = NULL;
	    targ->children = 0;
d1597 1
a1597 1
	    Lst_Init(&targ->cp);
d1600 7
a1606 6
	    /* Allocate room for the prefix, whose end is found by subtracting
	     * the length of the suffix from the end of the name.  */
	    prefLen = (eoname - targ->suff->nameLen) - sopref;
	    targ->pref = emalloc(prefLen + 1);
	    memcpy(targ->pref, sopref, prefLen);
	    targ->pref[prefLen] = '\0';
d1608 2
a1609 2
	    /* Add nodes from which the target can be made.  */
	    SuffAddLevel(&srcs, targ);
d1611 2
a1612 2
	    /* Record the target so we can nuke it.  */
	    Lst_AtEnd(&targs, targ);
d1614 3
a1616 2
	    /* Search from this suffix's successor...  */
	    ln = Lst_Succ(ln);
a1617 1
    }
d1619 6
a1624 5
    /* Handle target of unknown suffix...  */
    if (Lst_IsEmpty(&targs) && suffNull != NULL) {
	if (DEBUG(SUFF)) {
	    printf("\tNo known suffix on %s. Using .NULL suffix\n", gn->name);
	}
d1626 7
a1632 7
	targ = emalloc(sizeof(Src));
	targ->file = estrdup(gn->name);
	targ->suff = suffNull;
	targ->node = gn;
	targ->parent = NULL;
	targ->children = 0;
	targ->pref = estrdup(sopref);
d1634 1
a1634 1
	Lst_Init(&targ->cp);
d1637 8
a1644 8
	/* Only use the default suffix rules if we don't have commands
	 * or dependencies defined for this gnode.  */
	if (Lst_IsEmpty(&gn->commands) && Lst_IsEmpty(&gn->children))
	    SuffAddLevel(&srcs, targ);
	else {
	    if (DEBUG(SUFF))
		printf("not ");
	}
d1646 2
a1647 2
	if (DEBUG(SUFF))
	    printf("adding suffix rules\n");
d1649 2
a1650 2
	Lst_AtEnd(&targs, targ);
    }
d1652 37
a1688 37
    /* Using the list of possible sources built up from the target suffix(es),
     * try and find an existing file/target that matches.  */
    bottom = SuffFindThem(&srcs, slst);

    if (bottom == NULL) {
	/* No known transformations -- use the first suffix found for setting
	 * the local variables.  */
	if (!Lst_IsEmpty(&targs))
	    targ = (Src *)Lst_Datum(Lst_First(&targs));
	else
	    targ = NULL;
    } else {
	/* Work up the transformation path to find the suffix of the
	 * target to which the transformation was made.  */
	for (targ = bottom; targ->parent != NULL; targ = targ->parent)
	    continue;
    }

    /* The .TARGET variable we always set to be the name at this point,
     * since it's only set to the path if the thing is only a source and
     * if it's only a source, it doesn't matter what we put here as far
     * as expanding sources is concerned, since it has none...	*/
    Varq_Set(TARGET_INDEX, gn->name, gn);

    pref = targ != NULL ? targ->pref : gn->name;
    Varq_Set(PREFIX_INDEX, pref, gn);

    /* Now we've got the important local variables set, expand any sources
     * that still contain variables or wildcards in their names.  */
    for (ln = Lst_First(&gn->children); ln != NULL; ln = np) {
    	np = Lst_Adv(ln);
	SuffExpandChildren(Lst_Datum(ln), gn);
    }

    if (targ == NULL) {
	if (DEBUG(SUFF))
	    printf("\tNo valid suffix on %s\n", gn->name);
d1691 57
a1747 28
	/* Deal with finding the thing on the default search path if the
	 * node is only a source (not on the lhs of a dependency operator
	 * or [XXX] it has neither children or commands).  */
	if (OP_NOP(gn->type) ||
	    (Lst_IsEmpty(&gn->children) && Lst_IsEmpty(&gn->commands)))
	{
	    gn->path = Dir_FindFile(gn->name,
				    (targ == NULL ? defaultPath :
				     &targ->suff->searchPath));
	    if (gn->path != NULL) {
		char *ptr;
		Varq_Set(TARGET_INDEX, gn->path, gn);

		if (targ != NULL) {
		    /* Suffix known for the thing -- trim the suffix off
		     * the path to form the proper .PREFIX variable.  */
		    int 	savep = strlen(gn->path) - targ->suff->nameLen;
		    char	savec;

		    gn->suffix = targ->suff;

		    savec = gn->path[savep];
		    gn->path[savep] = '\0';

		    if ((ptr = strrchr(gn->path, '/')) != NULL)
			ptr++;
		    else
			ptr = gn->path;
d1749 2
a1750 12
		    Varq_Set(PREFIX_INDEX, ptr, gn);

		    gn->path[savep] = savec;
		} else {
		    /* The .PREFIX gets the full path if the target has
		     * no known suffix.  */
		    gn->suffix = NULL;

		    if ((ptr = strrchr(gn->path, '/')) != NULL)
			ptr++;
		    else
			ptr = gn->path;
d1752 18
a1769 1
		    Varq_Set(PREFIX_INDEX, ptr, gn);
a1770 8
	    }
	} else {
	    /* Not appropriate to search for the thing -- set the
	     * path to be the name so Dir_MTime won't go grovelling for
	     * it.  */
	    gn->suffix = targ == NULL ? NULL : targ->suff;
	    efree(gn->path);
	    gn->path = estrdup(gn->name);
d1773 16
a1788 21
	goto sfnd_return;
    }

    /* If the suffix indicates that the target is a library, mark that in
     * the node's type field.  */
    if (targ->suff->flags & SUFF_LIBRARY) {
	gn->type |= OP_LIB;
    }

    /* Check for overriding transformation rule implied by sources.  */
    if (!Lst_IsEmpty(&gn->children)) {
	src = SuffFindCmds(targ, slst);

	if (src != NULL) {
	    /* Free up all the Src structures in the transformation path
	     * up to, but not including, the parent node.  */
	    while (bottom && bottom->parent != NULL) {
		(void)Lst_AddNew(slst, bottom);
		bottom = bottom->parent;
	    }
	    bottom = src;
a1789 1
    }
d1791 2
a1792 4
    if (bottom == NULL) {
	/* No idea from where it can come -- return now.  */
	goto sfnd_abort;
    }
d1794 1
a1794 13
    /* We now have a list of Src structures headed by 'bottom' and linked via
     * their 'parent' pointers. What we do next is create links between
     * source and target nodes (which may or may not have been created)
     * and set the necessary local variables in each target. The
     * commands for each target are set from the commands of the
     * transformation rule used to get from the src suffix to the targ
     * suffix. Note that this causes the commands list of the original
     * node, gn, to be replaced by the commands of the final
     * transformation rule. Also, the unmade field of gn is incremented.
     * Etc.  */
    if (bottom->node == NULL) {
	bottom->node = Targ_FindNode(bottom->file, TARG_CREATE);
    }
d1796 3
a1798 4
    for (src = bottom; src->parent != NULL; src = src->parent) {
	targ = src->parent;

	src->node->suffix = src->suff;
d1800 2
a1801 3
	if (targ->node == NULL) {
	    targ->node = Targ_FindNode(targ->file, TARG_CREATE);
	}
d1803 9
a1811 2
	SuffApplyTransform(targ->node, src->node,
			   targ->suff, src->suff);
d1813 1
a1813 9
	if (targ->node != gn) {
	    /* Finish off the dependency-search process for any nodes
	     * between bottom and gn (no point in questing around the
	     * filesystem for their implicit source when it's already
	     * known). Note that the node can't have any sources that
	     * need expanding, since SuffFindThem will stop on an existing
	     * node, so all we need to do is set the standard and System V
	     * variables.  */
	    targ->node->type |= OP_DEPS_FOUND;
d1815 2
a1816 3
	    Varq_Set(PREFIX_INDEX, targ->pref, targ->node);

	    Varq_Set(TARGET_INDEX, targ->node->name, targ->node);
a1817 1
    }
d1819 1
a1819 1
    gn->suffix = src->suff;
d1821 3
a1823 3
    /* So Dir_MTime doesn't go questing for it...  */
    efree(gn->path);
    gn->path = estrdup(gn->name);
d1825 2
a1826 2
    /* Nuke the transformation path and the Src structures left over in the
     * two lists.  */
d1828 2
a1829 2
    if (bottom)
	(void)Lst_AddNew(slst, bottom);
d1831 2
a1832 2
    while (SuffRemoveSrc(&srcs) || SuffRemoveSrc(&targs))
	continue;
d1834 2
a1835 2
    Lst_ConcatDestroy(slst, &srcs);
    Lst_ConcatDestroy(slst, &targs);
d1867 3
a1869 3
    SuffFindDeps(gn, &srclist);
    while (SuffRemoveSrc(&srclist))
	continue;
d1876 8
a1883 8
    if (gn->type & OP_DEPS_FOUND) {
	/*
	 * If dependencies already found, no need to do it again...
	 */
	return;
    } else {
	gn->type |= OP_DEPS_FOUND;
    }
d1885 3
a1887 3
    if (DEBUG(SUFF)) {
	printf("SuffFindDeps (%s)\n", gn->name);
    }
d1889 13
a1901 13
    if (gn->type & OP_ARCHV) {
	SuffFindArchiveDeps(gn, slst);
    } else if (gn->type & OP_LIB) {
	/*
	 * If the node is a library, it is the arch module's job to find it
	 * and set the TARGET variable accordingly. We merely provide the
	 * search path, assuming all libraries end in ".a" (if the suffix
	 * hasn't been defined, there's nothing we can do for it, so we just
	 * set the TARGET variable to the node's name in order to give it a
	 * value).
	 */
	LstNode ln;
	Suff	*s;
d1903 16
a1918 16
	ln = suff_find_by_name(LIBSUFF);
	if (ln != NULL) {
	    gn->suffix = s = (Suff *)Lst_Datum(ln);
	    Arch_FindLib(gn, &s->searchPath);
	} else {
	    gn->suffix = NULL;
	    Varq_Set(TARGET_INDEX, gn->name, gn);
	}
	/*
	 * Because a library (-lfoo) target doesn't follow the standard
	 * filesystem conventions, we don't set the regular variables for
	 * the thing. .PREFIX is simply made empty...
	 */
	Varq_Set(PREFIX_INDEX, "", gn);
    } else
	SuffFindNormalDeps(gn, slst);
d1937 2
a1938 2
    Suff    *s;
    LstNode ln;
d1940 15
a1954 5
    ln = suff_find_by_name(name);
    if (ln != NULL) {
	s = (Suff *)Lst_Datum(ln);
	if (suffNull != NULL) {
	    suffNull->flags &= ~SUFF_NULL;
a1955 9
	s->flags |= SUFF_NULL;
	/*
	 * XXX: Here's where the transformation mangling would take place
	 */
	suffNull = s;
    } else {
	Parse_Error(PARSE_WARNING, "Desired null suffix %s not defined.",
		     name);
    }
d1970 1
a1970 1
    Static_Lst_Init(&sufflist);
d1972 1
a1972 1
    Static_Lst_Init(&suffClean);
d1974 10
a1983 2
    Static_Lst_Init(&srclist);
    Static_Lst_Init(&transforms);
d1985 9
a1993 17
    sNum = 0;
    /*
     * Create null suffix for single-suffix rules (POSIX). The thing doesn't
     * actually go on the suffix list or everyone will think that's its
     * suffix.
     */
    emptySuff = suffNull = emalloc(sizeof(Suff));

    suffNull->name =	    estrdup("");
    suffNull->nameLen =     0;
    Lst_Init(&suffNull->searchPath);
    Dir_Concat(&suffNull->searchPath, defaultPath);
    Lst_Init(&suffNull->children);
    Lst_Init(&suffNull->parents);
    Lst_Init(&suffNull->ref);
    suffNull->sNum =	    sNum++;
    suffNull->flags =	    SUFF_NULL;
d2012 6
a2017 6
    Lst_Destroy(&sufflist, SuffFree);
    Lst_Destroy(&suffClean, SuffFree);
    if (suffNull)
	SuffFree(suffNull);
    Lst_Destroy(&srclist, NOFREE);
    Lst_Destroy(&transforms, NOFREE);
d2026 1
a2026 1
    printf("%s ", ((Suff *)s)->name);
d2032 25
a2056 24
    Suff    *s = (Suff *)sp;
    int     flags;
    int     flag;

    printf("# `%s' ", s->name);

    flags = s->flags;
    if (flags) {
	fputs(" (", stdout);
	while (flags) {
	    flag = 1 << (ffs(flags) - 1);
	    flags &= ~flag;
	    switch (flag) {
		case SUFF_NULL:
		    printf("NULL");
		    break;
		case SUFF_INCLUDE:
		    printf("INCLUDE");
		    break;
		case SUFF_LIBRARY:
		    printf("LIBRARY");
		    break;
	    }
	    fputc(flags ? '|' : ')', stdout);
d2058 10
a2067 11
    }
    fputc('\n', stdout);
    printf("#\tTo: ");
    Lst_Every(&s->parents, SuffPrintName);
    fputc('\n', stdout);
    printf("#\tFrom: ");
    Lst_Every(&s->children, SuffPrintName);
    fputc('\n', stdout);
    printf("#\tSearch Path: ");
    Dir_PrintPath(&s->searchPath);
    fputc('\n', stdout);
d2073 1
a2073 1
    GNode   *t = (GNode *)tp;
d2075 5
a2079 5
    printf("%-16s: ", t->name);
    Targ_PrintType(t->type);
    fputc('\n', stdout);
    Lst_Every(&t->commands, Targ_PrintCmd);
    fputc('\n', stdout);
d2085 2
a2086 2
    printf("#*** Suffixes:\n");
    Lst_Every(&sufflist, SuffPrintSuff);
d2088 2
a2089 2
    printf("#*** Transformations:\n");
    Lst_Every(&transforms, SuffPrintTrans);
d2096 1
a2096 1
    printf("%lx ", (unsigned long)a);
@


1.64
log
@rename dirSearchPath -> defaultPath, and openDirectories -> knownDirectories
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.63 2007/09/16 10:14:26 espie Exp $ */
d888 1
a888 1
	targ->children += 1;
d905 1
a905 1
    targ->children += 1;
d1127 1
a1127 1
		    targ->children += 1;
@


1.63
log
@cut up dir.c into dir.c/direxpand.c as there is very little interface between
two modules that do different things.
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.62 2007/09/16 09:49:24 espie Exp $ */
d759 1
a759 1
 *	directories in dirSearchPath. If paths were specified for the
d787 1
a787 1
	    Dir_Concat(&s->searchPath, dirSearchPath);
d789 1
a789 1
	    Lst_Clone(&s->searchPath, dirSearchPath, Dir_CopyDir);
d1259 1
a1259 1
	path = dirSearchPath;
d1682 1
a1682 1
				    (targ == NULL ? dirSearchPath :
d1968 1
a1968 1
    Dir_Concat(&suffNull->searchPath, dirSearchPath);
@


1.62
log
@more dead code: we always define LIBRARIES and INCLUDES
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.61 2007/09/16 09:46:14 espie Exp $ */
d97 1
@


1.61
log
@remove dead code: #define RECHECK is always on
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.56 2006/09/24 09:04:05 espie Exp $ */
a779 1
#ifdef INCLUDES
a782 2
#endif /* INCLUDES */
#ifdef LIBRARIES
a785 1
#endif /* LIBRARIES */
@


1.60
log
@everywhere except in Var_Parse, we always add/append variables to the
VAR_GLOBAL context, so make it the common case: rename the basic functions
to Var_Set_with_ctxt/Var_Append_with_ctxt, define Var_Set and Var_Append
as macros that specify VAR_GLOBAL, and use these.

okay miod@@
@
text
@@


1.59
log
@simplify computations in the var module: instead of advancing a char *
and keeping track of a length, we just advance the char *, and ditch
the length. We can still get the length at the end of the top-level
functions to satisfy existing interfaces.

Much simpler code, less error-prone.

Okay millert@@
@
text
@d795 1
a795 1
    Var_Set(".INCLUDES", ptr = Dir_MakeFlags("-I", &inIncludes), VAR_GLOBAL);
d797 1
a797 1
    Var_Set(".LIBS", ptr = Dir_MakeFlags("-L", &inLibs), VAR_GLOBAL);
@


1.58
log
@move the code that grabs a value in Var_Parse in its own function,
get_expanded_value.

Extend the code a bit to be much more thorough in case of a recursive
expansion: shows exactly the cycle of variable names involved.

okay millert@@
@
text
@@


1.57
log
@change Var_ParseSkip API to increment the position instead of returning a
length, simplifies code.

(warns a bit, symptom of some further issues to fix).

okay millert@@
@
text
@@


1.56
log
@revert for now, this breaks stuff elsewhere...
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.54 2004/11/29 06:20:03 jsg Exp $ */
d1202 1
a1202 1
		cp2 += Var_ParseSkip(cp2, &pgn->context, NULL);
@


1.55
log
@on .SUFFIXES: <empty>
also reset one-suffix rules.
@
text
@d162 2
a193 1
static Suff *emptySuff(void);
d343 3
d421 1
a421 1
    suffNull = emptySuff();
d477 1
d1966 1
d1968 9
a1976 1
    suffNull = emptySuff();
a1979 17
Suff *
emptySuff()
{
    Suff *s;
    s = emalloc(sizeof(Suff));

    s->name =	    estrdup("");
    s->nameLen =     0;
    Lst_Init(&s->searchPath);
    Dir_Concat(&s->searchPath, dirSearchPath);
    Lst_Init(&s->children);
    Lst_Init(&s->parents);
    Lst_Init(&s->ref);
    s->sNum =	    sNum++;
    s->flags =	    SUFF_NULL;
    return s;
}
@


1.54
log
@Spell precede correctly.
'looks fine' millert@@, krw@@. ok jmc@@
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.53 2004/06/19 13:34:30 robert Exp $ */
a161 2
static Suff	    *emptySuff; /* The empty suffix required for POSIX
				 * single-suffix transformation rules */
d192 1
a341 3
    if (s == emptySuff)
	emptySuff = NULL;

d417 1
a417 1
    suffNull = emptySuff;
a472 1
		 * XXX: Use emptySuff over suffNull?
a1960 1
    emptySuff = suffNull = emalloc(sizeof(Suff));
d1962 1
a1962 9
    suffNull->name =	    estrdup("");
    suffNull->nameLen =     0;
    Lst_Init(&suffNull->searchPath);
    Dir_Concat(&suffNull->searchPath, dirSearchPath);
    Lst_Init(&suffNull->children);
    Lst_Init(&suffNull->parents);
    Lst_Init(&suffNull->ref);
    suffNull->sNum =	    sNum++;
    suffNull->flags =	    SUFF_NULL;
d1966 17
@


1.53
log
@avoid a null pointer dereference if the .DEFAULT target has no commands;
ok espie@@
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.52 2004/05/05 09:10:47 espie Exp $ */
d760 1
a760 1
 *	called ".INCLUDES" with each directory preceeded by a -I. The same
@


1.52
log
@constify char *.
Add lookup functions for suffixes and transforms, and stat them.
okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.51 2004/04/07 13:11:36 espie Exp $ */
d603 2
a604 1
	(void)SuffParseTransform(gn->name, &s, &t);
@


1.51
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.50 2003/06/03 02:56:12 millert Exp $ */
d107 1
a168 1
static int SuffSuffHasNameP(void *, const void *);
d170 2
a171 1
static int SuffGNHasNameP(void *, const void *);
d195 3
a267 10
/*-
 *-----------------------------------------------------------------------
 * SuffSuffHasNameP --
 *	Callback procedure for finding a suffix based on its name. Used by
 *	Suff_GetPath.
 *
 * Results:
 *	0 if the suffix is of the given name. non-zero otherwise.
 *-----------------------------------------------------------------------
 */
d269 1
a269 1
SuffSuffHasNameP(void *s, const void *sname)
d274 23
a314 15
/*-
 *-----------------------------------------------------------------------
 * SuffGNHasNameP  --
 *	See if the graph node has the desired name
 *
 * Results:
 *	0 if it does. non-zero if it doesn't
 *-----------------------------------------------------------------------
 */
static int
SuffGNHasNameP(void *gn, const void *name)
{
    return strcmp((const char *)name, ((GNode *)gn)->name);
}

d491 1
a491 1
	    targLn = Lst_FindConst(&sufflist, SuffSuffHasNameP, str2);
d541 1
a541 1
    ln = Lst_FindConst(&transforms, SuffGNHasNameP, line);
d657 1
a657 1
	ln = Lst_FindConst(&sufflist, SuffSuffHasNameP, cp);
d673 1
a673 1
	ln = Lst_FindConst(&sufflist, SuffSuffHasNameP, transform->name);
d697 1
a697 1
Suff_AddSuffix(char *str)
d702 1
a702 1
    ln = Lst_FindConst(&sufflist, SuffSuffHasNameP, str);
d735 1
a735 1
Suff_GetPath(char *sname)
d740 1
a740 1
    ln = Lst_FindConst(&sufflist, SuffSuffHasNameP, sname);
d815 1
a815 1
Suff_AddInclude(char *sname)	/* Name of suffix to mark */
d820 1
a820 1
    ln = Lst_FindConst(&sufflist, SuffSuffHasNameP, sname);
d840 1
a840 1
Suff_AddLib(char *sname)	/* Name of suffix to mark */
d845 1
a845 1
    ln = Lst_FindConst(&sufflist, SuffSuffHasNameP, sname);
d1105 1
a1105 1
	    ln2 = Lst_FindConst(&sufflist, SuffSuffHasNameP, &cp[prefLen]);
d1384 1
a1384 1
    ln = Lst_FindConst(&transforms, SuffGNHasNameP, tname);
d1886 1
a1886 1
	ln = Lst_FindConst(&sufflist, SuffSuffHasNameP, LIBSUFF);
d1918 1
a1918 1
Suff_SetNull(char *name)
d1923 1
a1923 1
    ln = Lst_FindConst(&sufflist, SuffSuffHasNameP, name);
@


1.50
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.49 2002/02/26 14:33:45 espie Exp $ */
d201 1
a201 1
 *	See if pref is a prefix of str.
d208 1
a208 3
SuffStrIsPrefix(pref, str)
    const char	*pref;	/* possible prefix */
    const char	*str;	/* string to check */
d210 2
a211 2
    while (*str && *pref == *str) {
	pref++;
d215 1
a215 1
    return *pref ? NULL : (char *)str;
d230 1
a230 3
SuffSuffIsSuffix(s, str)
    Suff	   *s;		/* possible suffix */
    const char	   *str;	/* string to examine */
d259 1
a259 3
SuffSuffIsSuffixP(s, str)
    void	*s;
    const void	*str;
d275 1
a275 3
SuffSuffHasNameP(s, sname)
    void	*s;		    /* Suffix to check */
    const void	*sname; 	    /* Desired name */
d293 1
a293 3
SuffSuffIsPrefix(s, str)
    void	*s;		/* suffix to compare */
    const void	*str;	/* string to examine */
d308 1
a308 3
SuffGNHasNameP(gn, name)
    void	*gn;		/* current node we're looking at */
    const void	*name;		/* name we're looking for */
d316 1
a316 3
SuffUnRef(l, sp)
    Lst 	l;
    Suff	*sp;
d334 1
a334 2
SuffFree(sp)
    void	*sp;
d366 1
a366 3
SuffInsert(l, s)
    Lst 	  l;		/* the list where in s should be inserted */
    Suff	  *s;		/* the suffix to insert */
d412 1
a412 1
Suff_ClearSuffixes()
d435 4
a438 4
SuffParseTransform(str, srcPtr, targPtr)
    const char		*str;		/* String being parsed */
    Suff		**srcPtr;	/* Place to store source of trans. */
    Suff		**targPtr;	/* Place to store target of trans. */
d510 1
a510 2
Suff_IsTransform(str)
    const char	  *str; 	/* string to check */
d532 1
a532 2
Suff_AddTransform(line)
    const char	  *line;	/* name of transformation to add */
d592 1
a592 2
Suff_EndTransform(gnp)
    void *gnp;		/* Node for transformation */
d642 3
a644 3
SuffRebuildGraph(transformp, sp)
    void	*transformp;	/* Transformation to test */
    void	*sp;		/* Suffix to rebuild */
d695 1
a695 2
Suff_AddSuffix(str)
    char	  *str;     /* the name of the suffix to add */
d733 1
a733 2
Suff_GetPath(sname)
    char	  *sname;
d763 1
a763 1
Suff_DoPaths()
d813 1
a813 2
Suff_AddInclude(sname)
    char	  *sname;     /* Name of suffix to mark */
d838 1
a838 2
Suff_AddLib(sname)
    char	  *sname;     /* Name of suffix to mark */
d864 3
a866 3
SuffAddSrc(sp, lsp)
    void *sp;	    /* suffix for which to create a Src structure */
    void *lsp;	    /* list and parent for the new Src */
d927 3
a929 3
SuffAddLevel(l, targ)
    Lst 	   l;		/* list to which to add the new level */
    Src 	   *targ;	/* Src structure to use as the parent */
d952 1
a952 2
SuffRemoveSrc(l)
    Lst l;
d1010 3
a1012 3
SuffFindThem(srcs, slst)
    Lst 	   srcs;	/* list of Src structures to search through */
    Lst 	   slst;
d1075 3
a1077 3
SuffFindCmds(targ, slst)
    Src 	*targ;	/* Src structure to play with */
    Lst 	slst;
d1146 1
a1146 4
SuffExpandVarChildren(after, cgn, pgn)
    LstNode	after;
    GNode	*cgn;
    GNode	*pgn;
d1231 1
a1231 4
SuffExpandWildChildren(after, cgn, pgn)
    LstNode	after;
    GNode	*cgn;
    GNode	*pgn;
d1299 3
a1301 3
SuffExpandChildren(cgnp, pgnp)
    void	*cgnp;		/* Child to examine */
    void	*pgnp;		/* Parent node being processed */
d1346 5
a1350 5
SuffApplyTransform(tGn, sGn, t, s)
    GNode	*tGn;	/* Target node */
    GNode	*sGn;	/* Source node */
    Suff	*t;	/* Target suffix */
    Suff	*s;	/* Source suffix */
d1428 3
a1430 3
SuffFindArchiveDeps(gn, slst)
    GNode	*gn;	    /* Node for which to locate dependencies */
    Lst 	slst;
d1523 3
a1525 3
SuffFindNormalDeps(gn, slst)
    GNode	*gn;	    /* Node for which to find sources */
    Lst 	slst;
d1845 1
a1845 2
Suff_FindDeps(gn)
    GNode *gn;
d1855 1
a1855 3
SuffFindDeps(gn, slst)
    GNode	  *gn;		/* node we're dealing with */
    Lst 	  slst;
d1916 1
a1916 2
Suff_SetNull(name)
    char    *name;	    /* Name of null suffix */
d1948 1
a1948 1
Suff_Init()
d1990 1
a1990 1
Suff_End()
d2004 1
a2004 2
static void SuffPrintName(s)
    void *s;
d2010 1
a2010 2
SuffPrintSuff(sp)
    void *sp;
d2051 1
a2051 2
SuffPrintTrans(tp)
    void *tp;
d2063 1
a2063 1
Suff_PrintAll()
d2074 1
a2074 2
PrintAddr(a)
    void *a;
@


1.49
log
@close PR 2311
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.48 2001/11/23 23:42:45 deraadt Exp $ */
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.48
log
@back out changes that break kernel compiles.  good testing jobmk install!
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.46 2001/11/11 12:35:03 espie Exp $ */
d1235 2
@


1.47
log
@Explicitly mark nodes whose commands have been filled with
implicit (suffix) rules.  Then, only expand the IMPSRC/< variable
if the node has been marked.

This matches what Single Unix 2 and common sense say: implicit rules
shouldn't count when an explicit rule has been found (an explicit rule
being a full-scale dependency, with some associated commands)

Note that Single Unix leaves the `PREFIX' question open, so we leave
the PREFIX code as it is.

This fixes regression case mk14, which now fails as it should.

This is just a bug-fix. Some more correct (and faster) code should
probably be substituted. Namely, right now, the suffix code is too
greedy, whereas it should test for explicit rules earlier, and not
even bother instantiating implicit rules from templates when they
duplicate actual existing rules.

ok millert@@
@
text
@a1433 2
    if (Lst_IsEmpty(&tGn->commands))
	tGn->type |= OP_IS_SUFFIX;
@


1.46
log
@Fixed version... don't see how this could work on i386, since it didn't
initialize create in main.c.
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.45 2001/11/11 06:02:06 deraadt Exp $ */
d1434 2
@


1.45
log
@undo changes that crash on (at least) the alpha
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.43 2001/05/29 12:53:43 espie Exp $ */
d1987 1
a1987 1
    Lst_Init(&sufflist);
d1989 1
a1989 1
    Lst_Init(&suffClean);
d1991 2
a1992 2
    Lst_Init(&srclist);
    Lst_Init(&transforms);
@


1.44
log
@Redo LstInit as a macro: smaller and faster code in all cases, zeroing two
pointers is simpler than calling a function.
Recognize purely static lst headers, which don't really need any
initialization.
ok miod@@
@
text
@d1987 1
a1987 1
    Static_Lst_Init(&sufflist);
d1989 1
a1989 1
    Static_Lst_Init(&suffClean);
d1991 2
a1992 2
    Static_Lst_Init(&srclist);
    Static_Lst_Init(&transforms);
@


1.43
log
@Take includes out of lst.h, re-add what's needed to separate files.
Removes remaining lint stuff from lst.lib.
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.42 2001/05/23 12:34:49 espie Exp $ */
d1987 1
a1987 1
    Lst_Init(&sufflist);
d1989 1
a1989 1
    Lst_Init(&suffClean);
d1991 2
a1992 2
    Lst_Init(&srclist);
    Lst_Init(&transforms);
@


1.42
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: suff.c,v 1.14 1999/10/05 22:06:24 espie Exp $ */
d96 1
@


1.41
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d69 1
a69 1
 *	Suff_IsTransform	Return TRUE if the passed string is the lhs
d94 16
a109 14
#include	  <stddef.h>
#include	  <stdio.h>
#include	  "make.h"
#include	  "ohash.h"
#include	  "dir.h"

#ifndef lint
#if 0
static char sccsid[] = "@@(#)suff.c	8.4 (Berkeley) 3/21/94";
#else
UNUSED
static char rcsid[] = "$OpenBSD: suff.c,v 1.14 1999/10/05 22:06:24 espie Exp $";
#endif
#endif /* not lint */
d179 1
a179 1
static Boolean SuffParseTransform(const char *, Suff **, Suff **);
d189 1
a189 1
static Boolean SuffApplyTransform(GNode *, GNode *, Suff *, Suff *);
d197 3
d448 1
a448 1
 *	TRUE if the string is a valid transformation and FALSE otherwise.
d454 1
a454 1
static Boolean
d499 1
a499 1
		return TRUE;
d501 1
a501 1
	    return FALSE;
d513 1
a513 1
		return TRUE;
d522 1
a522 1
 *	Return TRUE if the given string is a transformation rule
d525 2
a526 2
 *	TRUE if the string is a concatenation of two known suffixes.
 *	FALSE otherwise
d529 1
a529 1
Boolean
d567 1
a567 1
	gn = Targ_NewGN(line, NULL);
d812 3
a814 5
	    Dir_Concat(&s->searchPath, &dirSearchPath);
	} else {
	    Lst_Destroy(&s->searchPath, Dir_Destroy);
	    Lst_Clone(&s->searchPath, &dirSearchPath, Dir_CopyDir);
	}
d926 1
a926 1
    s2->file =	    str_concat(targ->pref, s->name, 0);
d1014 1
a1014 1
	    return TRUE;
d1057 1
a1057 1
	if (Targ_FindNode(s->file, NULL, TARG_NOCREATE) != NULL) {
d1187 1
a1187 1
    cp = Var_Subst(cgn->name, &pgn->context, TRUE);
d1219 1
a1219 1
		gn = Targ_FindNode(start, cp2, TARG_CREATE);
d1238 1
a1238 1
	    gn = Targ_FindNode(start, cp2, TARG_CREATE);
d1291 1
a1291 1
	path = &dirSearchPath;
d1302 1
a1302 1
	gn = Targ_FindNode(cp, NULL, TARG_CREATE);
d1367 1
a1367 1
 *	TRUE if successful, FALSE if not.
d1377 1
a1377 1
static Boolean
d1389 1
a1389 1
    if (Lst_AddNew(&tGn->children, sGn) == SUCCESS) {
d1404 1
a1404 1
	    if (Lst_AddNew(&tGn->children, gn) == SUCCESS) {
d1413 1
a1413 1
    tname = str_concat(s->name, t->name, 0);
d1421 1
a1421 1
	 * FALSE.
d1423 1
a1423 1
	return FALSE;
d1446 1
a1446 1
    return TRUE;
d1487 1
a1487 1
    mem = Targ_FindNode(name, eoname, TARG_CREATE);
d1491 1
a1491 1
    if (Lst_AddNew(&gn->children, mem) == SUCCESS) {
d1714 1
a1714 1
				    (targ == NULL ? &dirSearchPath :
d1801 1
a1801 1
	bottom->node = Targ_FindNode(bottom->file, NULL, TARG_CREATE);
d1810 1
a1810 1
	    targ->node = Targ_FindNode(targ->file, NULL, TARG_CREATE);
d2004 1
a2004 1
    Dir_Concat(&suffNull->searchPath, &dirSearchPath);
d2024 1
a2027 1
#ifdef CLEANUP
d2034 1
a2035 1
}
d2110 9
@


1.40
log
@Clean-ups:
* Buf_Destroy can be a macro
* X_ instead of _X for struct names, to avoid infringing on the system's
namespace.
* better wildcard detection heuristics
* fix #ifdef CLEANUP code
* a few comments
@
text
@d1 2
a2 1
/*	$OpenBSD: suff.c,v 1.39 2000/11/22 17:22:28 espie Exp $	*/
d49 1
a49 1
 *	Suff_Init 	    	Initialize all things to do with suffixes.
d51 1
a51 1
 *	Suff_End 	    	Cleanup the module
d53 12
a64 12
 *	Suff_DoPaths	    	This function is used to make life easier
 *	    	  	    	when searching for a file according to its
 *	    	  	    	suffix. It takes the global search path,
 *	    	  	    	as defined using the .PATH: target, and appends
 *	    	  	    	its directories to the path of each of the
 *	    	  	    	defined suffixes, as specified using
 *	    	  	    	.PATH<suffix>: targets. In addition, all
 *	    	  	    	directories given for suffixes labeled as
 *	    	  	    	include files or libraries, using the .INCLUDES
 *	    	  	    	or .LIBS targets, are played with using
 *	    	  	    	Dir_MakeFlags to create the .INCLUDES and
 *	    	  	    	.LIBS global variables.
d66 2
a67 2
 *	Suff_ClearSuffixes  	Clear out all the suffixes and defined
 *	    	  	    	transformations.
d69 2
a70 2
 *	Suff_IsTransform    	Return TRUE if the passed string is the lhs
 *	    	  	    	of a transformation rule.
d72 1
a72 1
 *	Suff_AddSuffix	    	Add the passed string as another known suffix.
d74 1
a74 1
 *	Suff_GetPath	    	Return the search path for the given suffix.
d76 2
a77 2
 *	Suff_AddInclude	    	Mark the given suffix as denoting an include
 *	    	  	    	file.
d79 1
a79 1
 *	Suff_AddLib	    	Mark the given suffix as denoting a library.
d81 3
a83 3
 *	Suff_AddTransform   	Add another transformation to the suffix
 *	    	  	    	graph. Returns  GNode suitable for framing, I
 *	    	  	    	mean, tacking commands, attributes, etc. on.
d85 2
a86 2
 *	Suff_SetNull	    	Define the suffix to consider the suffix of
 *	    	  	    	any file that doesn't have a known one.
d88 4
a91 4
 *	Suff_FindDeps	    	Find implicit sources for and the location of
 *	    	  	    	a target based on its suffix. Returns the
 *	    	  	    	bottom-most node added to the graph or NULL
 *	    	  	    	if the target had no implicit sources.
d94 2
a95 2
#include          <stddef.h>
#include    	  <stdio.h>
d105 1
a105 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.39 2000/11/22 17:22:28 espie Exp $";
d109 1
a109 1
static LIST      sufflist;	/* Lst of suffixes */
d114 1
a114 1
static LIST      transforms;	/* Lst of transformation rules */
d116 1
a116 1
static int        sNum = 0;	/* Counter for assigning suffix numbers */
d122 3
a124 3
    char         *name;	    	/* The suffix itself */
    int		 nameLen;	/* Length of the suffix */
    short	 flags;      	/* Type of suffix */
d127 2
a128 2
#define SUFF_NULL 	  0x04	    /* The empty suffix */
    LIST    	 searchPath;	/* The path along which files of this suffix
d130 3
a132 3
    int          sNum;	      	/* The suffix number */
    LIST         parents;	/* Suffixes we have a transformation to */
    LIST         children;	/* Suffixes we have a transformation from */
d140 3
a142 3
    char            *file;	/* The file to look for */
    char    	    *pref;  	/* Prefix from which file was formed */
    Suff            *suff;	/* The suffix on the file */
d144 2
a145 2
    GNode           *node;	/* The node describing the file */
    int	    	    children;	/* Count of existing children (so we don't free
d148 1
a148 1
    LIST	    cp;		/* Debug; children list */
d157 2
a158 2
    Lst            l;
    Src            *s;
d161 2
a162 2
static Suff 	    *suffNull;	/* The NULL suffix for this run */
static Suff 	    *emptySuff;	/* The empty suffix required for POSIX
d166 28
a193 24
static char *SuffStrIsPrefix __P((char *, char *));
static char *SuffSuffIsSuffix __P((Suff *, char *));
static int SuffSuffIsSuffixP __P((void *, void *));
static int SuffSuffHasNameP __P((void *, void *));
static int SuffSuffIsPrefix __P((void *, void *));
static int SuffGNHasNameP __P((void *, void *));
static void SuffUnRef __P((Lst, Suff *));
static void SuffInsert __P((Lst, Suff *));
static void SuffRemove __P((Lst, Suff *));
static Boolean SuffParseTransform __P((char *, Suff **, Suff **));
static void SuffRebuildGraph __P((void *, void *));
static void SuffAddSrc __P((void *, void *));
static int SuffRemoveSrc __P((Lst));
static void SuffAddLevel __P((Lst, Src *));
static Src *SuffFindThem __P((Lst, Lst));
static Src *SuffFindCmds __P((Src *, Lst));
static void SuffExpandChildren __P((void *, void *));
static Boolean SuffApplyTransform __P((GNode *, GNode *, Suff *, Suff *));
static void SuffFindDeps __P((GNode *, Lst));
static void SuffFindArchiveDeps __P((GNode *, Lst));
static void SuffFindNormalDeps __P((GNode *, Lst));
static void SuffPrintName __P((void *));
static void SuffPrintSuff __P((void *));
static void SuffPrintTrans __P((void *));
a202 3
 *
 * Side Effects:
 *	None
d206 3
a208 3
SuffStrIsPrefix (pref, str)
    register char  *pref;	/* possible prefix */
    register char  *str;	/* string to check */
d215 1
a215 1
    return (*pref ? NULL : str);
d221 2
a222 2
 *	See if suff is a suffix of str. Str should point to THE END of the
 *	string to check. (THE END == the null byte)
d225 1
a225 1
 *	NULL if it ain't, pointer to character in str before suffix if
a226 3
 *
 * Side Effects:
 *	None
d230 3
a232 3
SuffSuffIsSuffix (s, str)
    register Suff  *s;		/* possible suffix */
    char           *str;	/* string to examine */
d234 2
a235 2
    register char  *p1;	    	/* Pointer into suffix name */
    register char  *p2;	    	/* Pointer into string being examined */
d240 1
a240 1
    while (p1 >= s->name && *p1 == *p2) {
d243 2
d247 1
a247 1
    return (p1 == s->name - 1 ? p2 : NULL);
a257 4
 *
 * Side Effects:
 *	None.
 *
d262 2
a263 2
    void *s;
    void *str;
d265 1
a265 1
    return !SuffSuffIsSuffix((Suff *)s, (char *)str);
a275 3
 *
 * Side Effects:
 *	None
d279 3
a281 3
SuffSuffHasNameP (s, sname)
    void *s;	    	    /* Suffix to check */
    void *sname; 	    /* Desired name */
d283 1
a283 1
    return (strcmp ((char *) sname, ((Suff *) s)->name));
a295 3
 *
 * Side Effects:
 *	None
d300 2
a301 2
    void *s;	/* suffix to compare */
    void *str;	/* string to examine */
d303 1
a303 1
    return SuffStrIsPrefix (((Suff *)s)->name, (char *)str) == NULL ? 1 : 0;
a312 3
 *
 * Side Effects:
 *	None
d317 2
a318 2
    void *gn;		/* current node we're looking at */
    void *name;		/* name we're looking for */
d320 1
a320 1
    return strcmp((char *)name, ((GNode *)gn)->name);
d323 1
a323 1
 	    /*********** Maintenance Functions ************/
d326 3
a328 3
SuffUnRef(l, s)
    Lst l;
    Suff *s;
d330 1
a330 1
    LstNode ln = Lst_Member(l, s);
d335 1
d338 5
a342 2
 * SuffRemove  --
 *	Remove the suffix from the list
d346 2
a347 3
SuffRemove(l, s)
    Lst l;
    Suff *s;
d349 15
a363 1
    SuffUnRef(l, s);
d365 3
a367 1

a373 3
 * Results:
 *	None
 *
d379 3
a381 3
SuffInsert (l, s)
    Lst           l;		/* the list where in s should be inserted */
    Suff          *s;		/* the suffix to insert */
d383 2
a384 2
    LstNode 	  ln;		/* current element in l we're examining */
    Suff          *s2 = NULL;	/* the suffix descriptor in this element */
d386 1
a386 2
    Lst_Open(l);
    while ((ln = Lst_Next(l)) != NULL) {
d388 1
a388 1
	if (s2->sNum >= s->sNum) {
a389 1
	}
a391 1
    Lst_Close (l);
a421 3
 * Results:
 *	none
 *
d427 1
a427 1
Suff_ClearSuffixes ()
a446 1
 *
d451 9
a459 9
    char    	  	*str;	    	/* String being parsed */
    Suff    	  	**srcPtr;   	/* Place to store source of trans. */
    Suff    	  	**targPtr;  	/* Place to store target of trans. */
{
    register LstNode	srcLn;	    /* element in suffix list of trans source*/
    register Suff    	*src;	    /* Source of transformation */
    register LstNode    targLn;	    /* element in suffix list of trans target*/
    register char    	*str2;	    /* Extra pointer (maybe target suffix) */
    LstNode 	    	singleLn;   /* element in suffix list of any suffix
d461 1
a461 1
    Suff    	    	*single = NULL;/* Source of possible transformation to
d474 4
a477 6
	if (srcLn == NULL) {
	    srcLn = Lst_Find(&sufflist, SuffSuffIsPrefix, str);
	} else {
	    srcLn = Lst_FindFrom(Lst_Succ(srcLn), 
				  SuffSuffIsPrefix, str);
	}
d494 1
a494 1
		return(TRUE);
d496 1
a496 1
	    return (FALSE);
d504 1
a504 1
	    targLn = Lst_Find(&sufflist, SuffSuffHasNameP, str2);
d508 1
a508 1
		return (TRUE);
a518 1
 *
a521 3
 *
 * Side Effects:
 *	None
d525 2
a526 2
Suff_IsTransform (str)
    char          *str;	    	/* string to check */
d528 1
a528 1
    Suff    	  *src, *targ;
d530 1
a530 1
    return (SuffParseTransform(str, &src, &targ));
d548 2
a549 2
Suff_AddTransform (line)
    char          *line;	/* name of transformation to add */
d551 4
a554 4
    GNode         *gn;		/* GNode of transformation rule */
    Suff          *s,		/* source suffix */
                  *t;		/* target suffix */
    LstNode 	  ln;	    	/* Node for existing transformation */
d556 1
a556 1
    ln = Lst_Find(&transforms, SuffGNHasNameP, line);
d573 1
a574 1
	Lst_Init(&gn->commands);
d592 1
a592 1
    return (gn);
a605 1
 *
d610 1
a610 1
    void *gnp;    	/* Node for transformation */
d627 1
a627 1
	 * Remove the source from the target's children list. 
d632 1
a632 1
	SuffRemove(&t->children, s);
d637 2
a638 1
	SuffRemove(&s->parents, t);
a656 1
 *
d661 2
a662 2
    void *transformp; 	/* Transformation to test */
    void *sp;	    	/* Suffix to rebuild */
d664 3
a666 3
    GNode   	*transform = (GNode *)transformp;
    Suff    	*s = (Suff *)sp;
    char 	*cp;
d668 1
a668 1
    Suff  	*s2;
d670 1
a670 3
    /*
     * First see if it is a transformation from this suffix.
     */
d673 1
a673 1
	ln = Lst_Find(&sufflist, SuffSuffHasNameP, cp);
d675 2
a676 4
	    /*
	     * Found target. Link in and return, since it can't be anything
	     * else.
	     */
d684 1
a684 3
    /*
     * Not from, maybe to?
     */
d687 5
a691 9
	/*
	 * Null-terminate the source suffix in order to find it.
	 */
	cp[1] = '\0';
	ln = Lst_Find(&sufflist, SuffSuffHasNameP, transform->name);
	/*
	 * Replace the start of the target suffix
	 */
	cp[1] = s->name[0];
d693 1
a693 3
	    /*
	     * Found it -- establish the proper relationship
	     */
a706 3
 * Results:
 *	None
 *
d713 2
a714 2
Suff_AddSuffix (str)
    char          *str;	    /* the name of the suffix to add */
d716 2
a717 2
    Suff          *s;	    /* new suffix descriptor */
    LstNode 	  ln;
d719 1
a719 1
    ln = Lst_Find(&sufflist, SuffSuffHasNameP, str);
d721 1
a721 1
	s = (Suff *) emalloc (sizeof (Suff));
d723 2
a724 2
	s->name =   	estrdup(str);
	s->nameLen = 	strlen(s->name);
d729 2
a730 2
	s->sNum =   	sNum++;
	s->flags =  	0;
d753 1
a753 1
    char    	  *sname;
d755 2
a756 2
    LstNode   	  ln;
    Suff    	  *s;
d758 2
a759 2
    ln = Lst_Find(&sufflist, SuffSuffHasNameP, sname);
    if (ln == NULL)
d761 1
a761 1
    else {
a772 3
 * Results:
 *	None.
 *
d785 2
a786 2
    register Suff   	*s;
    register LstNode  	ln;
d788 2
a789 4
    LIST    	    	inIncludes; /* Cumulative .INCLUDES path */
    LIST    	    	inLibs;	    /* Cumulative .LIBS path */

    Lst_Open(&sufflist);
d794 1
a794 1
    while ((ln = Lst_Next(&sufflist)) != NULL) {
a820 2

    Lst_Close(&sufflist);
a829 3
 * Results:
 *	None.
 *
a831 1
 *
d835 1
a835 1
Suff_AddInclude (sname)
d841 1
a841 1
    ln = Lst_Find(&sufflist, SuffSuffHasNameP, sname);
a855 3
 * Results:
 *	None.
 *
a857 1
 *
d861 1
a861 1
Suff_AddLib (sname)
d867 1
a867 1
    ln = Lst_Find(&sufflist, SuffSuffHasNameP, sname);
d874 1
a874 1
 	  /********** Implicit Source Search Functions *********/
d893 3
a895 3
    LstSrc      *ls = (LstSrc *)lsp;
    Src         *s2;	    /* new Src structure */
    Src    	*targ; 	    /* Target structure */
d899 1
a899 1
    if ((s->flags & SUFF_NULL) && (*s->name != '\0')) {
d905 6
a910 6
	s2 = (Src *) emalloc (sizeof (Src));
	s2->file =  	estrdup(targ->pref);
	s2->pref =  	targ->pref;
	s2->parent = 	targ;
	s2->node =  	NULL;
	s2->suff =  	s;
d922 2
a923 2
    s2 = (Src *) emalloc (sizeof (Src));
    s2->file = 	    str_concat(targ->pref, s->name, 0);
d926 2
a927 2
    s2->node = 	    NULL;
    s2->suff = 	    s;
d938 1
a945 3
 * Results:
 *	None
 *
d947 1
a947 1
 * 	Lots of structures are created and added to the list
d951 3
a953 3
SuffAddLevel (l, targ)
    Lst            l;		/* list to which to add the new level */
    Src            *targ;	/* Src structure to use as the parent */
d955 1
a955 1
    LstSrc         ls;
d969 1
a969 1
 *	True if an src was removed
d976 1
a976 1
SuffRemoveSrc (l)
a982 1
    Lst_Open(l);
d984 1
a984 1
    printf("cleaning %lx: ", (unsigned long) l);
d990 1
a990 1
    while ((ln = Lst_Next (l)) != NULL) {
d998 3
a1000 3
		LstNode ln = Lst_Member(&s->parent->cp, s);
		if (ln != NULL)
		    Lst_Remove(&s->parent->cp, ln);
a1010 1
	    Lst_Close(l);
a1021 2
    Lst_Close(l);

a1031 3
 *
 * Side Effects:
 *	None
d1035 3
a1037 3
SuffFindThem (srcs, slst)
    Lst            srcs;	/* list of Src structures to search through */
    Lst		   slst;
d1039 2
a1040 2
    Src            *s;		/* current Src */
    Src		   *rs;		/* returned Src */
d1043 1
a1043 1
    rs = (Src *) NULL;
d1047 1
a1047 1
	    printf ("\ttrying %s...", s->file);
d1054 1
a1054 1
	if (Targ_FindNode(s->file, TARG_NOCREATE) != NULL) {
d1072 1
a1072 1
	    printf ("not there\n");
d1075 1
a1075 1
	SuffAddLevel (srcs, s);
d1080 1
a1080 1
	printf ("got it\n");
d1082 1
a1082 1
    return (rs);
a1096 1
 *
d1100 11
a1110 11
SuffFindCmds (targ, slst)
    Src	    	*targ;	/* Src structure to play with */
    Lst		slst;
{
    LstNode 	  	ln; 	/* General-purpose list node */
    register GNode	*t, 	/* Target GNode */
	    	  	*s; 	/* Source GNode */
    int	    	  	prefLen;/* The length of the defined prefix */
    Suff    	  	*suff;	/* Suffix on matching beastie */
    Src	    	  	*ret;	/* Return value */
    char    	  	*cp;
d1113 1
a1113 2
    Lst_Open(&t->children);
    prefLen = strlen (targ->pref);
d1115 1
a1115 1
    while ((ln = Lst_Next(&t->children)) != NULL) {
d1118 2
a1119 2
	cp = strrchr (s->name, '/');
	if (cp == (char *)NULL) {
d1124 6
a1129 7
	if (strncmp (cp, targ->pref, prefLen) == 0) {
	    /*
	     * The node matches the prefix ok, see if it has a known
	     * suffix.
	     */
	    ln = Lst_Find(&sufflist, SuffSuffHasNameP, &cp[prefLen]);
	    if (ln != NULL) {
d1136 1
a1136 1
		suff = (Suff *)Lst_Datum(ln);
d1138 1
a1138 2
		if (Lst_Member(&suff->parents, targ->suff) != NULL)
		{
d1145 1
a1145 1
		    ret = (Src *)emalloc (sizeof (Src));
d1162 1
a1162 1
		    return (ret);
d1167 146
a1312 2
    Lst_Close(&t->children);
    return ((Src *)NULL);
d1324 1
a1324 2
 * 	may be added.
 *
d1329 2
a1330 2
    void *cgnp;	    /* Child to examine */
    void *pgnp;	    /* Parent node being processed */
d1332 6
a1337 6
    GNode   	*cgn = (GNode *)cgnp;
    GNode   	*pgn = (GNode *)pgnp;
    GNode	*gn;	    /* New source 8) */
    LstNode   	prevLN;    /* Node after which new source should be put */
    LstNode	ln; 	    /* List element for old source */
    char	*cp;	    /* Expanded value */
d1339 1
a1339 8
    /*
     * New nodes effectively take the place of the child, so place them
     * after the child
     */
    prevLN = Lst_Member(&pgn->children, cgn);

    /*
     * First do variable expansion -- this takes precedence over
d1342 8
a1349 30
     * the children list.
     */
    if (strchr(cgn->name, '$') != NULL) {
	if (DEBUG(SUFF))
	    printf("Expanding \"%s\"...", cgn->name);
	cp = Var_Subst(cgn->name, &pgn->context, TRUE);

	if (cp != NULL) {
	    LIST	members;

	    Lst_Init(&members);
	    if (cgn->type & OP_ARCHV) {
		/*
		 * Node was an archive(member) target, so we want to call
		 * on the Arch module to find the nodes for us, expanding
		 * variables in the parent's context.
		 */
		char	*sacrifice = cp;

		(void)Arch_ParseArchive(&sacrifice, &members, &pgn->context);
	    } else {
		/*
		 * Break the result into a vector of strings whose nodes
		 * we can find, then add those nodes to the members list.
		 * Unfortunately, we can't use brk_string b/c it
		 * doesn't understand about variable specifications with
		 * spaces in them...
		 */
		char	    *start;
		char	    *initcp = cp;   /* For freeing... */
d1351 4
a1354 145
		for (start = cp; *start == ' ' || *start == '\t'; start++)
		    continue;
		for (cp = start; *cp != '\0'; cp++) {
		    if (*cp == ' ' || *cp == '\t') {
			/*
			 * White-space -- terminate element, find the node,
			 * add it, skip any further spaces.
			 */
			*cp++ = '\0';
			gn = Targ_FindNode(start, TARG_CREATE);
			Lst_AtEnd(&members, gn);
			while (*cp == ' ' || *cp == '\t') {
			    cp++;
			}
			/*
			 * Adjust cp for increment at start of loop, but
			 * set start to first non-space.
			 */
			start = cp--;
		    } else if (*cp == '$') {
			/*
			 * Start of a variable spec -- contact variable module
			 * to find the end so we can skip over it.
			 */
			char	*junk;
			size_t 	len;
			Boolean	doFree;

			junk = Var_Parse(cp, &pgn->context, TRUE, &len, &doFree);
			if (junk != var_Error)
			    cp += len - 1;

			if (doFree)
			    free(junk);
		    } else if (*cp == '\\' && *cp != '\0') {
			/*
			 * Escaped something -- skip over it
			 */
			cp++;
		    }
		}

		if (cp != start) {
		    /*
		     * Stuff left over -- add it to the list too
		     */
		    gn = Targ_FindNode(start, TARG_CREATE);
		    Lst_AtEnd(&members, gn);
		}
		/*
		 * Point cp back at the beginning again so the variable value
		 * can be freed.
		 */
		cp = initcp;
	    }
	    /* Add all elements of the members list to the parent node.  */
	    while((gn = (GNode *)Lst_DeQueue(&members)) != NULL) {
		if (DEBUG(SUFF))
		    printf("%s...", gn->name);
		if (Lst_Member(&pgn->children, gn) == NULL) {
		    Lst_Append(&pgn->children, prevLN, gn);
		    prevLN = Lst_Succ(prevLN);
		    Lst_AtEnd(&gn->parents, pgn);
		    pgn->unmade++;
		}
	    }
	    Lst_Destroy(&members, NOFREE);
	    /* Free the result */
	    free(cp);
	}
	/*
	 * Now the source is expanded, remove it from the list of children to
	 * keep it from being processed.
	 */
	ln = Lst_Member(&pgn->children, cgn);
	pgn->unmade--;
	Lst_Remove(&pgn->children, ln);
	if (DEBUG(SUFF))
	    printf("\n");
    } else if (Dir_HasWildcards(cgn->name)) {
	LIST 	exp;	    /* List of expansions */
	Lst 	path;	    /* Search path along which to expand */

	/*
	 * Find a path along which to expand the word.
	 *
	 * If the word has a known suffix, use that path.
	 * If it has no known suffix and we're allowed to use the null
	 *   suffix, use its path.
	 * Else use the default system search path.
	 */
	cp = cgn->name + strlen(cgn->name);
	ln = Lst_Find(&sufflist, SuffSuffIsSuffixP, cp);

	if (DEBUG(SUFF))
	    printf("Wildcard expanding \"%s\"...", cgn->name);

	if (ln != NULL) {
	    Suff    *s = (Suff *)Lst_Datum(ln);

	    if (DEBUG(SUFF))
		printf("suffix is \"%s\"...", s->name);
	    path = &s->searchPath;
	} else {
	    /*
	     * Use default search path
	     */
	    path = &dirSearchPath;
	}

	/* Expand the word along the chosen path */
	Lst_Init(&exp);
	Dir_Expand(cgn->name, path, &exp);

	/* Fetch next expansion off the list and find its GNode.  */
	while ((cp = (char *)Lst_DeQueue(&exp)) != NULL) {
	    if (DEBUG(SUFF))
		printf("%s...", cp);
	    gn = Targ_FindNode(cp, TARG_CREATE);

	    /*
	     * If gn isn't already a child of the parent, make it so and
	     * up the parent's count of unmade children.
	     */
	    if (Lst_Member(&pgn->children, gn) == NULL) {
		Lst_Append(&pgn->children, prevLN, gn);
		prevLN = Lst_Succ(prevLN);
		Lst_AtEnd(&gn->parents, pgn);
		pgn->unmade++;
	    }
	}

	/* Nuke what's left of the list.  */
	Lst_Destroy(&exp, NOFREE);

	/*
	 * Now the source is expanded, remove it from the list of children to
	 * keep it from being processed.
	 */
	ln = Lst_Member(&pgn->children, cgn);
	pgn->unmade--;
	Lst_Remove(&pgn->children, ln);
	if (DEBUG(SUFF))
	    printf("\n");
    }
a1371 1
 *
d1376 4
a1379 4
    GNode   	*tGn;	    /* Target node */
    GNode   	*sGn;	    /* Source node */
    Suff    	*t; 	    /* Target suffix */
    Suff    	*s; 	    /* Source suffix */
d1381 1
a1381 1
    LstNode 	ln; 	    /* General node */
d1383 2
a1384 2
    char    	*tname;	    /* Name of transformation rule */
    GNode   	*gn;	    /* Node for same */
d1386 3
a1388 6
    if (Lst_Member(&tGn->children, sGn) == NULL) {
	/*
	 * Not already linked, so form the proper links between the
	 * target and source.
	 */
	Lst_AtEnd(&tGn->children, sGn);
d1390 1
a1390 1
	tGn->unmade += 1;
d1394 1
a1394 2
	/*
	 * When a :: node is used as the implied source of a node, we have
d1397 1
a1397 2
	 * will be sufficient to get the .IMPSRC variable set for tGn
	 */
d1401 3
a1403 6
	    if (Lst_Member(&tGn->children, gn) == NULL) {
		/*
		 * Not already linked, so form the proper links between the
		 * target and source.
		 */
		Lst_AtEnd(&tGn->children, gn);
d1405 1
a1405 1
		tGn->unmade += 1;
d1409 1
a1409 3
    /*
     * Locate the transformation rule itself
     */
d1411 1
a1411 1
    ln = Lst_Find(&transforms, SuffGNHasNameP, tname);
d1414 1
a1414 1
    if (ln == NULL) {
d1420 1
a1420 2
	return(FALSE);
    }
d1424 1
a1424 1
    if (DEBUG(SUFF)) {
a1425 1
    }
d1427 1
a1427 3
    /*
     * Record last child for expansion purposes
     */
d1430 2
a1431 4
    /*
     * Pass the buck to Make_HandleUse to apply the rule
     */
    (void)Make_HandleUse(gn, tGn);
d1433 1
a1433 3
    /*
     * Deal with wildcards and variables in any acquired sources
     */
d1439 2
a1440 4
    /*
     * Keep track of another parent to which this beast is transformed so
     * the .IMPSRC variable can be set correctly for the parent.
     */
d1443 1
a1443 1
    return(TRUE);
a1451 3
 * Results:
 *	None
 *
a1453 1
 *
d1458 2
a1459 2
    GNode   	*gn;	    /* Node for which to locate dependencies */
    Lst		slst;
d1461 10
a1470 13
    char    	*eoarch;    /* End of archive portion */
    char    	*eoname;    /* End of member portion */
    GNode   	*mem;	    /* Node for member */
    Suff    	*ms;	    /* Suffix descriptor for member */
    char    	*name;	    /* Start of member's name */

    /*
     * The node is an archive(member) pair. so we must find a
     * suffix for both of them.
     */
    eoarch = strchr (gn->name, '(');
    eoname = strchr (eoarch, ')');
    if (eoarch == NULL || eoname == NULL)
d1473 1
a1473 2
    *eoname = '\0';	  /* Nuke parentheses during suffix search */
    *eoarch = '\0';	  /* So a suffix can be found */
d1475 3
a1477 1
    name = eoarch + 1;
d1479 1
a1479 2
    /*
     * To simplify things, call Suff_FindDeps recursively on the member now,
d1483 2
a1484 3
     * suffix list, backtracking for each one...
     */
    mem = Targ_FindNode(name, TARG_CREATE);
d1487 2
a1488 5
    /*
     * Create the link between the two nodes right off
     */
    if (Lst_Member(&gn->children, mem) == NULL) {
	Lst_AtEnd(&gn->children, mem);
d1490 1
a1490 1
	gn->unmade += 1;
d1499 2
a1500 4
	/*
	 * Didn't know what it was -- use .NULL suffix if not in make mode
	 */
	if (DEBUG(SUFF)) {
a1501 1
	}
d1506 2
a1507 4
    /*
     * Set the other two local variables required for this target.
     */
    Varq_Set(MEMBER_INDEX, name, gn);
d1517 1
a1517 1
	LstNode	    ln;
d1519 2
a1520 4
	/*
	 * Use first matching suffix...
	 */
	ln = Lst_Find(&ms->parents, SuffSuffIsSuffixP, eoarch);
d1523 1
a1523 3
	    /*
	     * Got one -- apply it
	     */
a1525 1
	    {
a1527 1
	    }
d1531 1
a1531 8
    /*
     * Replace the opening and closing parens now we've no need of the separate
     * pieces.
     */
    *eoarch = '('; *eoname = ')';

    /*
     * Pretend gn appeared to the left of a dependency operator so
d1533 2
a1534 3
     * archive.
     */
    if (OP_NOP(gn->type)) {
a1535 1
    }
d1537 2
a1538 4
    /*
     * Flag the member as such so we remember to look in the archive for
     * its modification time.
     */
a1546 3
 * Results:
 *	None.
 *
a1548 1
 *
d1553 2
a1554 2
    GNode   	*gn;	    /* Node for which to find sources */
    Lst		slst;
d1556 3
a1558 3
    char    	*eoname;    /* End of name */
    char    	*sopref;    /* Start of prefix */
    LstNode 	ln; 	    /* Next suffix node to check */
d1560 2
a1561 2
    LIST    	srcs;	    /* List of sources at which to look */
    LIST    	targs;	    /* List of targets to which things can be
d1564 1
a1564 1
    Src	    	*bottom;    /* Start of found transformation path */
d1566 2
a1567 2
    char    	*pref;	    /* Prefix to use */
    Src	    	*targ;	    /* General Src target pointer */
d1574 1
a1574 3
    /*
     * Begin at the beginning...
     */
d1579 1
a1579 2
    /*
     * We're caught in a catch-22 here. On the one hand, we want to use any
d1594 1
a1594 2
     * Should we find one, we discard the one we found before.
     */
d1597 2
a1598 4
	/*
	 * Look for next possible suffix...
	 */
	ln = Lst_FindFrom(ln, SuffSuffIsSuffixP, eoname);
d1601 2
a1602 2
	    int	    prefLen;	    /* Length of the prefix */
	    Src	    *targ;
d1604 2
a1605 4
	    /*
	     * Allocate a Src structure to which things can be transformed
	     */
	    targ = (Src *)emalloc(sizeof (Src));
d1609 1
a1609 1
	    targ->parent = (Src *)NULL;
d1615 2
a1616 4
	    /*
	     * Allocate room for the prefix, whose end is found by subtracting
	     * the length of the suffix from the end of the name.
	     */
d1633 1
a1633 3
    /*
     * Handle target of unknown suffix...
     */
d1639 1
a1639 1
	targ = (Src *)emalloc(sizeof (Src));
d1643 1
a1643 1
	targ->parent = (Src *)NULL;
d1650 2
a1651 4
	/*
	 * Only use the default suffix rules if we don't have commands
	 * or dependencies defined for this gnode
	 */
d1665 2
a1666 4
    /*
     * Using the list of possible sources built up from the target suffix(es),
     * try and find an existing file/target that matches.
     */
d1670 2
a1671 4
	/*
	 * No known transformations -- use the first suffix found for setting
	 * the local variables.
	 */
d1677 2
a1678 4
	/*
	 * Work up the transformation path to find the suffix of the
	 * target to which the transformation was made.
	 */
d1683 1
a1683 2
    /*
     * The .TARGET variable we always set to be the name at this point,
d1686 1
a1686 2
     * as expanding sources is concerned, since it has none...
     */
d1689 1
a1689 1
    pref = (targ != NULL) ? targ->pref : gn->name;
d1692 2
a1693 4
    /*
     * Now we've got the important local variables set, expand any sources
     * that still contain variables or wildcards in their names.
     */
d1700 1
a1700 1
	if (DEBUG(SUFF)) {
a1701 1
	}
d1704 1
a1704 2
	/*
	 * Deal with finding the thing on the default search path if the
d1706 1
a1706 2
	 * or [XXX] it has neither children or commands).
	 */
d1718 3
a1720 5
		    /*
		     * Suffix known for the thing -- trim the suffix off
		     * the path to form the proper .PREFIX variable.
		     */
		    int		savep = strlen(gn->path) - targ->suff->nameLen;
d1737 2
a1738 4
		    /*
		     * The .PREFIX gets the full path if the target has
		     * no known suffix.
		     */
d1750 1
a1750 2
	    /*
	     * Not appropriate to search for the thing -- set the
d1752 2
a1753 3
	     * it.
	     */
	    gn->suffix = (targ == NULL) ? NULL : targ->suff;
d1761 2
a1762 4
    /*
     * If the suffix indicates that the target is a library, mark that in
     * the node's type field.
     */
d1767 1
a1767 3
    /*
     * Check for overriding transformation rule implied by sources
     */
d1771 3
a1773 5
	if (src != (Src *)NULL) {
	    /*
	     * Free up all the Src structures in the transformation path
	     * up to, but not including, the parent node.
	     */
d1775 1
a1775 3
		if (Lst_Member(slst, bottom) == NULL) {
		    Lst_AtEnd(slst, bottom);
		}
d1783 1
a1783 3
	/*
	 * No idea from where it can come -- return now.
	 */
d1787 1
a1787 2
    /*
     * We now have a list of Src structures headed by 'bottom' and linked via
d1796 1
a1796 2
     * Etc.
     */
d1798 1
a1798 1
	bottom->node = Targ_FindNode(bottom->file, TARG_CREATE);
d1801 1
a1801 1
    for (src = bottom; src->parent != (Src *)NULL; src = src->parent) {
d1807 1
a1807 1
	    targ->node = Targ_FindNode(targ->file, TARG_CREATE);
d1814 1
a1814 2
	    /*
	     * Finish off the dependency-search process for any nodes
d1820 1
a1820 2
	     * variables.
	     */
d1831 1
a1831 3
    /*
     * So Dir_MTime doesn't go questing for it...
     */
d1835 2
a1836 4
    /*
     * Nuke the transformation path and the Src structures left over in the
     * two lists.
     */
d1839 1
a1839 2
	if (Lst_Member(slst, bottom) == NULL)
	    Lst_AtEnd(slst, bottom);
a1854 3
 * Results:
 *	Nothing.
 *
a1869 1
 *
d1885 3
a1887 3
SuffFindDeps (gn, slst)
    GNode         *gn;	      	/* node we're dealing with */
    Lst		  slst;
d1899 1
a1899 1
	printf ("SuffFindDeps (%s)\n", gn->name);
d1913 1
a1913 1
	LstNode	ln;
d1916 1
a1916 1
	ln = Lst_Find(&sufflist, SuffSuffHasNameP, LIBSUFF);
d1930 1
a1930 1
    } else {
a1931 1
    }
a1938 3
 * Results:
 *	None.
 *
a1944 1
 *
d1954 1
a1954 1
    ln = Lst_Find(&sufflist, SuffSuffHasNameP, name);
d1957 1
a1957 1
	if (suffNull != (Suff *)NULL) {
d1966 1
a1966 1
	Parse_Error (PARSE_WARNING, "Desired null suffix %s not defined.",
a1975 3
 * Results:
 *	None
 *
d1981 1
a1981 1
Suff_Init ()
d1996 1
a1996 1
    emptySuff = suffNull = (Suff *) emalloc (sizeof (Suff));
d1998 1
a1998 1
    suffNull->name =   	    estrdup ("");
d2005 2
a2006 2
    suffNull->sNum =   	    sNum++;
    suffNull->flags =  	    SUFF_NULL;
a2015 3
 * Results:
 *	None
 *
d2048 2
a2049 2
    int	    flags;
    int	    flag;
d2073 2
a2074 1
    printf("\n#\tTo: ");
d2076 2
a2077 1
    printf("\n#\tFrom: ");
d2079 2
a2080 1
    printf("\n#\tSearch Path: ");
@


1.39
log
@Don't use light-weight Lst_ForEach when the list is going away from under
us. Need to cache the `next' pointer instead.

Do this manually, as adding a new function for one place in make where it's
needed is a bit icky, especially since suff.c's code might get cleaned up
at some point.

Bug reported by Niels.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.38 2000/09/14 13:46:45 espie Exp $	*/
d104 1
a104 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.38 2000/09/14 13:46:45 espie Exp $";
d120 1
a120 1
typedef struct _Suff {
d138 1
a138 1
typedef struct _Src {
d142 1
a142 1
    struct _Src     *parent;	/* The Src for which this is a source */
@


1.38
log
@Replace the old hash used to hold file names within a directory with
open hashing.

An interesting optimization is that the open hashing interface is more
fine-grained, hence we can compute the correct hash value at the start
of Dir_FindFile, and reuse it for each hash structure into which we look
(the effect is measurable on large directories along with objdir/VPATH).

Remove a few unnecessary Lst_Open/Lst_Close that serve no purpose except
obfuscating the code.

The interface to dir.h changes slightly, hence tedious includes changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.37 2000/09/14 13:40:03 espie Exp $	*/
d104 1
a104 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.37 2000/09/14 13:40:03 espie Exp $";
d1463 1
d1533 4
a1536 2
    ln = Lst_Succ(ln);
    Lst_ForEachFrom(ln, SuffExpandChildren, tGn);
d1697 1
d1856 4
a1859 1
    Lst_ForEach(&gn->children, SuffExpandChildren, gn);
@


1.37
log
@Use the new hash scheme to store the target nodes.
Scrap the list of all targets: it only slows make down.
The only visible difference is that the list of all targets is not
shown in order when debugging.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.36 2000/09/14 13:32:07 espie Exp $	*/
d93 1
d96 1
a96 1
#include	  "hash.h"
d104 1
a104 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.36 2000/09/14 13:32:07 espie Exp $";
@


1.36
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.35 2000/06/23 16:41:53 espie Exp $	*/
d103 1
a103 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.35 2000/06/23 16:41:53 espie Exp $";
d570 1
a570 1
	gn = Targ_NewGN (line);
@


1.35
log
@This patch replaces str_concat with a slightly unobfuscated version.

In particular, Dir_MakeFlags is abusing str_concat, and works much better
with buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.34 2000/06/23 16:21:43 espie Exp $	*/
a41 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)suff.c	8.4 (Berkeley) 3/21/94";
#else
static char rcsid[] = "$OpenBSD: suff.c,v 1.34 2000/06/23 16:21:43 espie Exp $";
#endif
#endif /* not lint */

d98 9
a170 1
static void SuffFree __P((void *));
a347 33
 * SuffFree  --
 *	Free up all memory associated with the given suffix structure.
 *
 * Results:
 *	none
 *
 * Side Effects:
 *	the suffix entry is detroyed
 *-----------------------------------------------------------------------
 */
static void
SuffFree(sp)
    void *sp;
{
    Suff           *s = (Suff *) sp;

    if (s == suffNull)
	suffNull = NULL;

    if (s == emptySuff)
	emptySuff = NULL;

    Lst_Destroy(&s->ref, NOFREE);
    Lst_Destroy(&s->children, NOFREE);
    Lst_Destroy(&s->parents, NOFREE);
    Lst_Destroy(&s->searchPath, Dir_Destroy);

    free(s->name);
    free(s);
}

/*-
 *-----------------------------------------------------------------------
a1564 1
    int	    	i;  	    /* Index into copy and vals */
@


1.34
log
@In various places, VAR_CMD is used to actually mean `no real context',
since lookup will start with VAR_CMD in any case.
This fixes VarFind and Var_Parse to handle ctxt == NULL correctly, and
replace those confusing VAR_CMD with proper NULL pointers.

This patch also handles three small details:
- .CURDIR is necessarily set in VAR_GLOBAL,
- suffix handling for archives copies two hard-coded variables, for
which it can use a quick path,
- typos in TargFreeGN.

Reviewed millert@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.33 2000/06/23 16:20:01 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.33 2000/06/23 16:20:01 espie Exp $";
d995 1
a995 1
    s2->file = 	    str_concat (targ->pref, s->name, 0);
@


1.33
log
@Once those special variable are taken care of, other Var functions can take
the GNode's context directly.  We rename that special Lst to `SymTable *'
in prevision of things to come.

Along the line, we lose the special GNodes affected to VAR_CMD, VAR_GLOBAL,
VAR_ENV, which become simple Lsts... This is not a problem, except when
getting to a context's name for debugging (handled very nicely by
offsetof).

Again, this is a preparatory patch, which does not gain anything except
for cleaning up issues...

Reviewed by millert@@ and miod@@, like the previous patch
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.32 2000/06/23 16:18:09 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.32 2000/06/23 16:18:09 espie Exp $";
a1597 4
    static char	*copy[] = { /* Variables to be copied from the member node */
	TARGET,	    	    /* Must be first */
	PREFIX,	    	    /* Must be second */
    };
d1635 3
a1637 7
    /*
     * Copy in the variables from the member node to this one.
     */
    for (i = (sizeof(copy)/sizeof(copy[0]))-1; i >= 0; i--) {
	Var_Set(copy[i], Var_Value(copy[i], &mem->context), &gn->context);

    }
@


1.32
log
@Start of variable fixes and speed-ups.

This patch may seem a bit non-sensical at first. It simply introduces some
new interface. Specifically, recognizes that some variable names
(.TARGET/$@@, .OODATE/$?, .ALLSRC/$>, .IMPSRC/$<, .PREFIX/$*, .ARCHIVE/$!,
.MEMBER/$%) are `special' (the actual variables which are local to a
target, e.g. GNode).

Currently, The Varq functions (for Varquick access) are only stubs to the
normal functions.

This fixes a very important detail before proceeding to turn variable lists
into hash tables: if every GNode holds a hash table, initialization times
for those will be very costly. But generic GNodes only hold those seven
special variables... which can be stored directly into a small array;
the only general cases are the environment, the command line and
global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.31 2000/06/23 16:15:50 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.31 2000/06/23 16:15:50 espie Exp $";
d1296 1
a1296 1
	cp = Var_Subst(cgn->name, pgn, TRUE);
d1310 1
a1310 1
		(void)Arch_ParseArchive(&sacrifice, &members, pgn);
d1350 1
a1350 1
			junk = Var_Parse(cp, pgn, TRUE, &len, &doFree);
d1643 1
a1643 1
	Var_Set(copy[i], Var_Value(copy[i], mem), gn);
@


1.31
log
@Trivial consequences of the previous list changes:

- audit code for Lst_Datum, it's never applied to an empty pointer,
so check can be removed -> turn into a macro,
- Lst_First, Lst_Last can become macro as well
- specialized version of Lst_Succ (Lst_Adv) to use in loops where it cannot
fail,
- Lst_Open can no longer fail. Trim down corresponding code.

Reviewed millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.30 2000/06/17 14:43:36 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.30 2000/06/17 14:43:36 espie Exp $";
d1662 2
a1663 2
    Var_Set (MEMBER, name, gn);
    Var_Set (ARCHIVE, gn->name, gn);
d1884 1
a1884 1
    Var_Set(TARGET, gn->name, gn);
d1887 1
a1887 1
    Var_Set(PREFIX, pref, gn);
d1914 1
a1914 1
		Var_Set(TARGET, gn->path, gn);
d1934 1
a1934 1
		    Var_Set(PREFIX, ptr, gn);
d1949 1
a1949 1
		    Var_Set(PREFIX, ptr, gn);
d2042 1
a2042 1
	    Var_Set(PREFIX, targ->pref, targ->node);
d2044 1
a2044 1
	    Var_Set(TARGET, targ->node->name, targ->node);
d2150 1
a2150 1
	    Var_Set (TARGET, gn->name, gn);
d2157 1
a2157 1
	Var_Set(PREFIX, "", gn);
@


1.30
log
@This removes the few instances of Lst_New left.
- replaces Lst_Duplicate with Lst_Clone, which does not allocate storage
- split Lst_Concat into Lst_Concat/Lst_ConcatDestroy
Thus, all the LstValid checks are gone, since we always invoke list
functions with valid pointers.

Note that dynamic list allocation accounted for roughly 20% of all calls
to malloc.  The extraneous calls to malloc left are now mostly in parse.c,
which makes some wasteful usage of temporary buffers.

With those few patches, the code is sturdier, and easier to maintain.

Reviewed by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.29 2000/06/17 14:38:19 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.29 2000/06/17 14:38:19 espie Exp $";
d414 3
a416 5
    if (Lst_Open (l) == FAILURE) {
	return;
    }
    while ((ln = Lst_Next (l)) != NULL) {
	s2 = (Suff *) Lst_Datum (ln);
d535 1
a535 1
	src = (Suff *) Lst_Datum (srcLn);
d612 1
a612 1
	gn = (GNode *) Lst_Datum (ln);
d851 1
a851 2
    if (Lst_Open(&sufflist) == FAILURE)
	return;
d857 1
a857 1
	s = (Suff *) Lst_Datum (ln);
d911 1
a911 1
	s = (Suff *) Lst_Datum (ln);
d941 1
a941 1
	s = (Suff *) Lst_Datum (ln);
d1057 1
a1057 3
    if (Lst_Open (l) == FAILURE) {
	return 0;
    }
d1066 1
a1066 1
	s = (Src *) Lst_Datum (ln);
d1195 1
a1195 1
    (void) Lst_Open(&t->children);
d1199 1
a1199 1
	s = (GNode *)Lst_Datum (ln);
d1220 1
a1220 1
		suff = (Suff *)Lst_Datum (ln);
d1515 1
a1515 1
	for (ln=Lst_First(&sGn->cohorts); ln != NULL; ln=Lst_Succ(ln)) {
d2146 1
a2146 1
	    gn->suffix = s = (Suff *) Lst_Datum (ln);
@


1.29
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.28 2000/06/10 01:41:06 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.28 2000/06/10 01:41:06 espie Exp $";
d106 1
a106 1
static Lst       sufflist;	/* Lst of suffixes */
d125 1
a125 1
    Lst    	 searchPath;	/* The path along which files of this suffix
d169 1
a169 1
static void SuffUnRef __P((void *, void *));
d337 3
a339 3
SuffUnRef(lp, sp)
    void *lp;
    void *sp;
d341 1
a341 3
    Lst l = (Lst) lp;

    LstNode ln = Lst_Member(l, sp);
d373 1
a373 1
    Lst_Delete(s->searchPath, Dir_Destroy);
d466 1
a466 1
    Lst_Concat(&suffClean, sufflist, LST_CONCLINK);
d468 1
a468 1
    sufflist = Lst_New();
d512 1
a512 1
	    srcLn = Lst_Find(sufflist, SuffSuffIsPrefix, str);
d543 1
a543 1
	    targLn = Lst_Find(sufflist, SuffSuffHasNameP, str2);
d719 1
a719 1
	ln = Lst_Find(sufflist, SuffSuffHasNameP, cp);
d741 1
a741 1
	ln = Lst_Find(sufflist, SuffSuffHasNameP, transform->name);
d778 1
a778 1
    ln = Lst_Find(sufflist, SuffSuffHasNameP, str);
d782 3
a784 3
	s->name =   	estrdup (str);
	s->nameLen = 	strlen (s->name);
	s->searchPath = Lst_New();
d791 1
a791 1
	Lst_AtEnd(sufflist, s);
a807 3
 *
 * Side Effects:
 *	None
d811 1
a811 1
Suff_GetPath (sname)
d817 6
a822 6
    ln = Lst_Find(sufflist, SuffSuffHasNameP, sname);
    if (ln == NULL) {
	return (NULL);
    } else {
	s = (Suff *) Lst_Datum (ln);
	return (s->searchPath);
d853 1
a853 1
    if (Lst_Open (sufflist) == FAILURE) {
a854 1
    }
d859 1
a859 1
    while ((ln = Lst_Next (sufflist)) != NULL) {
d861 1
a861 1
	if (!Lst_IsEmpty (s->searchPath)) {
d864 1
a864 1
		Dir_Concat(&inIncludes, s->searchPath);
d869 1
a869 1
		Dir_Concat(&inLibs, s->searchPath);
d872 1
a872 1
	    Dir_Concat(s->searchPath, &dirSearchPath);
d874 2
a875 2
	    Lst_Delete(s->searchPath, Dir_Destroy);
	    s->searchPath = Lst_Duplicate(&dirSearchPath, Dir_CopyDir);
d887 1
a887 1
    Lst_Close (sufflist);
d912 1
a912 1
    ln = Lst_Find(sufflist, SuffSuffHasNameP, sname);
d942 1
a942 1
    ln = Lst_Find(sufflist, SuffSuffHasNameP, sname);
d1148 1
a1148 1
	if ((ptr = Dir_FindFile (s->file, s->suff->searchPath)) != NULL) {
d1217 1
a1217 1
	    ln = Lst_Find(sufflist, SuffSuffHasNameP, &cp[prefLen]);
d1419 1
a1419 1
	ln = Lst_Find(sufflist, SuffSuffIsSuffixP, cp);
d1429 1
a1429 1
	    path = s->searchPath;
d1740 2
a1741 2
    Lst	    	srcs;	    /* List of sources at which to look */
    Lst	    	targs;	    /* List of targets to which things can be
d1757 3
a1759 3
    ln = Lst_First(sufflist);
    srcs = Lst_New();
    targs = Lst_New();
d1812 2
a1813 4
	    /*
	     * Add nodes from which the target can be made
	     */
	    SuffAddLevel(srcs, targ);
d1815 2
a1816 4
	    /*
	     * Record the target so we can nuke it
	     */
	    Lst_AtEnd(targs, targ);
d1818 1
a1818 3
	    /*
	     * Search from this suffix's successor...
	     */
d1826 1
a1826 1
    if (Lst_IsEmpty(targs) && suffNull != NULL) {
d1847 1
a1847 1
	    SuffAddLevel(srcs, targ);
d1856 1
a1856 1
	Lst_AtEnd(targs, targ);
d1863 1
a1863 1
    bottom = SuffFindThem(srcs, slst);
d1865 1
a1865 1
    if (bottom == (Src *)NULL) {
d1870 4
a1873 5
	if (!Lst_IsEmpty(targs)) {
	    targ = (Src *)Lst_Datum(Lst_First(targs));
	} else {
	    targ = (Src *)NULL;
	}
d1916 1
a1916 1
				     targ->suff->searchPath));
d2070 1
a2070 1
    while (SuffRemoveSrc(srcs) || SuffRemoveSrc(targs))
d2073 2
a2074 2
    Lst_Concat(slst, srcs, LST_CONCLINK);
    Lst_Concat(slst, targs, LST_CONCLINK);
d2149 1
a2149 1
	ln = Lst_Find(sufflist, SuffSuffHasNameP, LIBSUFF);
d2152 1
a2152 1
	    Arch_FindLib (gn, s->searchPath);
d2192 1
a2192 1
    ln = Lst_Find(sufflist, SuffSuffHasNameP, name);
d2224 1
a2224 1
    sufflist = Lst_New();
d2241 2
a2242 2
    suffNull->searchPath =  Lst_New();
    Dir_Concat(suffNull->searchPath, &dirSearchPath);
d2269 1
a2269 1
    Lst_Delete(sufflist, SuffFree);
d2322 1
a2322 1
    Dir_PrintPath(s->searchPath);
d2343 1
a2343 1
    Lst_Every(sufflist, SuffPrintSuff);
@


1.28
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.27 2000/06/10 01:32:23 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.27 2000/06/10 01:32:23 espie Exp $";
d108 1
a108 1
static Lst	 suffClean;	/* Lst of suffixes to be cleaned */
d110 2
a111 2
static Lst	 srclist;	/* Lst of sources */
static Lst       transforms;	/* Lst of transformation rules */
d128 3
a130 3
    Lst          parents;	/* Suffixes we have a transformation to */
    Lst          children;	/* Suffixes we have a transformation from */
    Lst		 ref;		/* List of lists this suffix is referenced */
d145 1
a145 1
    Lst		    cp;		/* Debug; children list */
d372 4
a375 4
    Lst_Destroy(s->ref, NOFREE);
    Lst_Destroy(s->children, NOFREE);
    Lst_Destroy(s->parents, NOFREE);
    Lst_Destroy(s->searchPath, Dir_Destroy);
d435 1
a435 1
	Lst_AtEnd(s->ref, l);
d441 1
a441 1
	Lst_AtEnd(s->ref, l);
d468 1
a468 1
    Lst_Concat(suffClean, sufflist, LST_CONCLINK);
d470 1
a470 1
    sufflist = Lst_Init();
d601 1
a601 1
    ln = Lst_Find(transforms, SuffGNHasNameP, line);
d608 1
a608 1
	Lst_AtEnd(transforms, gn);
d617 4
a620 4
	Lst_Destroy(gn->commands, NOFREE);
	Lst_Destroy(gn->children, NOFREE);
	gn->commands = Lst_Init();
	gn->children = Lst_Init();
d634 2
a635 2
    SuffInsert (t->children, s);
    SuffInsert (s->parents, t);
d660 2
a661 2
    if ((gn->type & OP_TRANSFORM) && Lst_IsEmpty(gn->commands) &&
	Lst_IsEmpty(gn->children))
d678 1
a678 1
	SuffRemove(t->children, s);
d683 1
a683 1
	SuffRemove(s->parents, t);
d728 2
a729 2
	    SuffInsert(s2->children, s);
	    SuffInsert(s->parents, s2);
d753 2
a754 2
	    SuffInsert(s->children, s2);
	    SuffInsert(s2->parents, s);
d786 4
a789 4
	s->searchPath = Lst_Init();
	s->children = 	Lst_Init();
	s->parents = 	Lst_Init();
	s->ref = 	Lst_Init();
d798 1
a798 1
	Lst_ForEach(transforms, SuffRebuildGraph, s);
d855 2
a856 2
    Lst	    	    	inIncludes; /* Cumulative .INCLUDES path */
    Lst	    	    	inLibs;	    /* Cumulative .LIBS path */
d862 2
a863 2
    inIncludes = Lst_Init();
    inLibs = Lst_Init();
d870 1
a870 1
		Dir_Concat(inIncludes, s->searchPath);
d875 1
a875 1
		Dir_Concat(inLibs, s->searchPath);
d878 1
a878 1
	    Dir_Concat(s->searchPath, dirSearchPath);
d880 2
a881 2
	    Lst_Destroy(s->searchPath, Dir_Destroy);
	    s->searchPath = Lst_Duplicate(dirSearchPath, Dir_CopyDir);
d885 1
a885 1
    Var_Set(".INCLUDES", ptr = Dir_MakeFlags("-I", inIncludes), VAR_GLOBAL);
d887 1
a887 1
    Var_Set(".LIBS", ptr = Dir_MakeFlags("-L", inLibs), VAR_GLOBAL);
d890 2
a891 2
    Lst_Destroy(inIncludes, Dir_Destroy);
    Lst_Destroy(inLibs, Dir_Destroy);
d996 2
a997 2
	s2->cp = Lst_Init();
	Lst_AtEnd(targ->cp, s2);
d1013 2
a1014 2
    s2->cp = Lst_Init();
    Lst_AtEnd(targ->cp, s2);
d1043 1
a1043 1
    Lst_ForEach(targ->suff->children, SuffAddSrc, &ls);
d1084 1
a1084 1
		LstNode ln = Lst_Member(s->parent->cp, s);
d1086 1
a1086 1
		    Lst_Remove(s->parent->cp, ln);
d1092 1
a1092 1
	    Lst_Destroy(s->cp, NOFREE);
d1103 1
a1103 1
	    Lst_Every(s->cp, PrintAddr);
d1206 1
a1206 1
    (void) Lst_Open (t->children);
d1209 1
a1209 1
    while ((ln = Lst_Next (t->children)) != NULL) {
d1233 1
a1233 1
		if (Lst_Member(suff->parents, targ->suff) != NULL)
d1250 1
a1250 1
		    ret->cp = Lst_Init();
d1252 1
a1252 1
		    Lst_AtEnd(targ->cp, ret);
d1263 1
a1263 1
    Lst_Close (t->children);
d1296 1
a1296 1
    prevLN = Lst_Member(pgn->children, cgn);
d1310 1
a1310 1
	    Lst	    members = Lst_Init();
d1312 1
d1321 1
a1321 1
		(void)Arch_ParseArchive(&sacrifice, members, pgn);
d1343 1
a1343 1
			Lst_AtEnd(members, gn);
d1380 1
a1380 1
		    Lst_AtEnd(members, gn);
d1388 2
a1389 4
	    /*
	     * Add all elements of the members list to the parent node.
	     */
	    while((gn = (GNode *)Lst_DeQueue(members)) != NULL) {
d1392 2
a1393 2
		if (Lst_Member(pgn->children, gn) == NULL) {
		    Lst_Append(pgn->children, prevLN, gn);
d1395 1
a1395 1
		    Lst_AtEnd(gn->parents, pgn);
d1399 2
a1400 4
	    Lst_Destroy(members, NOFREE);
	    /*
	     * Free the result
	     */
d1407 1
a1407 1
	ln = Lst_Member(pgn->children, cgn);
d1409 1
a1409 1
	Lst_Remove(pgn->children, ln);
d1413 1
a1413 1
	Lst 	exp;	    /* List of expansions */
d1440 1
a1440 1
	    path = dirSearchPath;
d1443 3
a1445 5
	/*
	 * Expand the word along the chosen path
	 */
	exp = Lst_Init();
	Dir_Expand(cgn->name, path, exp);
d1448 1
a1448 1
	while ((cp = (char *)Lst_DeQueue(exp)) != NULL) {
d1457 2
a1458 2
	    if (Lst_Member(pgn->children, gn) == NULL) {
		Lst_Append(pgn->children, prevLN, gn);
d1460 1
a1460 1
		Lst_AtEnd(gn->parents, pgn);
d1465 2
a1466 4
	/*
	 * Nuke what's left of the list
	 */
	Lst_Destroy(exp, NOFREE);
d1472 1
a1472 1
	ln = Lst_Member(pgn->children, cgn);
d1474 1
a1474 1
	Lst_Remove(pgn->children, ln);
d1509 1
a1509 1
    if (Lst_Member(tGn->children, sGn) == NULL) {
d1514 2
a1515 2
	Lst_AtEnd(tGn->children, sGn);
	Lst_AtEnd(sGn->parents, tGn);
d1526 1
a1526 1
	for (ln=Lst_First(sGn->cohorts); ln != NULL; ln=Lst_Succ(ln)) {
d1529 1
a1529 1
	    if (Lst_Member(tGn->children, gn) == NULL) {
d1534 2
a1535 2
		Lst_AtEnd(tGn->children, gn);
		Lst_AtEnd(gn->parents, tGn);
d1544 1
a1544 1
    ln = Lst_Find(transforms, SuffGNHasNameP, tname);
d1565 1
a1565 1
    ln = Lst_Last(tGn->children);
d1582 1
a1582 1
    Lst_AtEnd(sGn->iParents, tGn);
d1644 3
a1646 3
    if (Lst_Member(gn->children, mem) == NULL) {
	Lst_AtEnd(gn->children, mem);
	Lst_AtEnd(mem->parents, gn);
d1688 1
a1688 1
	ln = Lst_Find(ms->parents, SuffSuffIsSuffixP, eoarch);
d1764 2
a1765 2
    srcs = Lst_Init();
    targs = Lst_Init();
d1806 1
a1806 1
	    targ->cp = Lst_Init();
d1851 1
a1851 1
	targ->cp = Lst_Init();
d1858 1
a1858 1
	if (Lst_IsEmpty(gn->commands) && Lst_IsEmpty(gn->children))
d1911 1
a1911 1
    Lst_ForEach(gn->children, SuffExpandChildren, gn);
d1925 1
a1925 1
	    (Lst_IsEmpty(gn->children) && Lst_IsEmpty(gn->commands)))
d1928 1
a1928 1
				    (targ == NULL ? dirSearchPath :
d1995 1
a1995 1
    if (!Lst_IsEmpty(gn->children)) {
d2124 2
a2125 2
    SuffFindDeps(gn, srclist);
    while (SuffRemoveSrc(srclist))
d2237 1
a2237 1
    sufflist = Lst_Init();
d2239 1
a2239 1
    suffClean = Lst_Init();
d2241 2
a2242 2
    srclist = Lst_Init();
    transforms = Lst_Init();
d2254 5
a2258 5
    suffNull->searchPath =  Lst_Init();
    Dir_Concat(suffNull->searchPath, dirSearchPath);
    suffNull->children =    Lst_Init();
    suffNull->parents =	    Lst_Init();
    suffNull->ref =	    Lst_Init();
d2282 2
a2283 2
    Lst_Destroy(sufflist, SuffFree);
    Lst_Destroy(suffClean, SuffFree);
d2286 2
a2287 2
    Lst_Destroy(srclist, NOFREE);
    Lst_Destroy(transforms, NOFREE);
d2331 1
a2331 1
    Lst_Every(s->parents, SuffPrintName);
d2333 1
a2333 1
    Lst_Every(s->children, SuffPrintName);
d2348 1
a2348 1
    Lst_Every(t->commands, Targ_PrintCmd);
d2359 1
a2359 1
    Lst_Every(transforms, SuffPrintTrans);
@


1.27
log
@Thus, Lst_ForEach no longer needs returning a status.
In fact, it can become a macro based on Lst_ForEachFrom.
This also introduces Lst_Every, as a shortcut for the very common case where
Lst_ForEach does not need any user data.

Finally,  make consistent use of a few function typedefs, instead of having
explicit void (*)(Lst)  arguments all over the place.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.26 2000/06/10 01:26:37 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.26 2000/06/10 01:26:37 espie Exp $";
d165 6
a170 6
static int SuffSuffIsSuffixP __P((ClientData, ClientData));
static int SuffSuffHasNameP __P((ClientData, ClientData));
static int SuffSuffIsPrefix __P((ClientData, ClientData));
static int SuffGNHasNameP __P((ClientData, ClientData));
static void SuffUnRef __P((ClientData, ClientData));
static void SuffFree __P((ClientData));
d174 2
a175 2
static void SuffRebuildGraph __P((ClientData, ClientData));
static void SuffAddSrc __P((ClientData, ClientData));
d180 1
a180 1
static void SuffExpandChildren __P((ClientData, ClientData));
d185 3
a187 3
static void SuffPrintName __P((ClientData));
static void SuffPrintSuff __P((ClientData));
static void SuffPrintTrans __P((ClientData));
d264 2
a265 2
    ClientData   s;
    ClientData   str;
d267 1
a267 1
    return(!SuffSuffIsSuffix((Suff *) s, (char *) str));
d285 2
a286 2
    ClientData    s;	    	    /* Suffix to check */
    ClientData    sname; 	    /* Desired name */
d307 3
a309 3
SuffSuffIsPrefix (s, str)
    ClientData   s;		/* suffix to compare */
    ClientData   str;	/* string to examine */
d311 1
a311 1
    return (SuffStrIsPrefix (((Suff *) s)->name, (char *) str) == NULL ? 1 : 0);
d327 3
a329 3
SuffGNHasNameP (gn, name)
    ClientData      gn;		/* current node we're looking at */
    ClientData      name;	/* name we're looking for */
d331 1
a331 1
    return (strcmp ((char *) name, ((GNode *) gn)->name));
d338 2
a339 2
    ClientData lp;
    ClientData sp;
d361 2
a362 2
SuffFree (sp)
    ClientData sp;
d377 2
a378 2
    free ((Address)s->name);
    free ((Address)s);
d656 1
a656 1
    ClientData   gnp;    	/* Node for transformation */
d707 2
a708 2
    ClientData  transformp; /* Transformation to test */
    ClientData  sp;	    /* Suffix to rebuild */
d970 2
a971 2
    ClientData	sp;	    /* suffix for which to create a Src structure */
    ClientData  lsp;	    /* list and parent for the new Src */
d1079 1
a1079 1
	    free ((Address)s->file);
d1081 1
a1081 1
		free((Address)s->pref);
d1095 1
a1095 1
	    free ((Address)s);
d1282 2
a1283 2
    ClientData  cgnp;	    /* Child to examine */
    ClientData  pgnp;	    /* Parent node being processed */
d2302 1
a2302 1
    ClientData s;
d2309 1
a2309 1
    ClientData sp;
d2348 1
a2348 1
    ClientData tp;
@


1.26
log
@Lst_Find and Lst_ForEach do the same thing, except that the comparison
sense is reversed (Lst_Find  returns when proc says 0, whereas Lst_ForEach
goes on while proc says 0).

This patch turns a number of Lst_ForEach into Lst_Find.
Specifically, all Lst_ForEach that actually may return quickly as proc
does not always returns zero.

Of course, the corresponding proc need to be tweaked to swap 0 and 1...
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.25 2000/03/26 16:21:33 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.25 2000/03/26 16:21:33 espie Exp $";
d174 2
a175 2
static int SuffRebuildGraph __P((ClientData, ClientData));
static int SuffAddSrc __P((ClientData, ClientData));
d180 1
a180 1
static int SuffExpandChildren __P((ClientData, ClientData));
d185 3
a187 3
static int SuffPrintName __P((ClientData, ClientData));
static int SuffPrintSuff __P((ClientData, ClientData));
static int SuffPrintTrans __P((ClientData, ClientData));
d372 4
a375 4
    Lst_Destroy (s->ref, NOFREE);
    Lst_Destroy (s->children, NOFREE);
    Lst_Destroy (s->parents, NOFREE);
    Lst_Destroy (s->searchPath, Dir_Destroy);
d617 2
a618 2
	Lst_Destroy (gn->commands, NOFREE);
	Lst_Destroy (gn->children, NOFREE);
a647 3
 * Results:
 *	=== 0
 *
d654 2
a655 2
int
Suff_EndTransform(gnp, dummy)
a656 1
    ClientData   dummy;    	/* Node for transformation */
d658 1
a658 1
    GNode *gn = (GNode *) gnp;
a686 2

    return(dummy ? 0 : 0);
a698 3
 * Results:
 *	Always 0.
 *
d705 1
a705 1
static int
d710 2
a711 2
    GNode   	*transform = (GNode *) transformp;
    Suff    	*s = (Suff *) sp;
d720 1
a720 1
    if (cp != (char *)NULL) {
d730 1
a730 1
	    return(0);
d738 1
a738 1
    if (cp != (char *)NULL) {
a756 1
    return(0);
d880 1
a880 1
	    Lst_Destroy (s->searchPath, Dir_Destroy);
a963 3
 * Results:
 *	always returns 0
 *
d968 2
a969 2
static int
SuffAddSrc (sp, lsp)
d973 2
a974 2
    Suff	*s = (Suff *) sp;
    LstSrc      *ls = (LstSrc *) lsp;
d999 1
a999 1
	Lst_ForEach(ls->l, PrintAddr, NULL);
d1016 1
a1016 1
    Lst_ForEach(ls->l, PrintAddr, NULL);
a1018 2

    return(0);
d1043 1
a1043 1
    Lst_ForEach (targ->suff->children, SuffAddSrc, &ls);
d1071 1
a1071 1
    Lst_ForEach(l, PrintAddr, NULL);
d1103 1
a1103 1
	    Lst_ForEach(s->cp, PrintAddr, NULL);
a1272 3
 * Results:
 *	=== 0 (continue)
 *
d1280 1
a1280 1
static int
d1285 2
a1286 2
    GNode   	*cgn = (GNode *) cgnp;
    GNode   	*pgn = (GNode *) pgnp;
d1304 2
a1305 2
    if (strchr(cgn->name, '$') != (char *)NULL) {
	if (DEBUG(SUFF)) {
a1306 1
	}
d1309 1
a1309 1
	if (cp != (char *)NULL) {
d1361 1
a1361 1
			if (junk != var_Error) {
a1362 1
			}
d1364 1
a1364 1
			if (doFree) {
a1365 1
			}
d1391 1
a1391 1
		if (DEBUG(SUFF)) {
a1392 1
		}
d1404 1
a1404 1
	    free((char *)cp);
d1413 1
a1413 1
	if (DEBUG(SUFF)) {
a1414 1
	}
d1430 1
a1430 1
	if (DEBUG(SUFF)) {
a1431 1
	}
d1436 1
a1436 1
	    if (DEBUG(SUFF)) {
a1437 1
	    }
d1454 1
a1454 1
	    if (DEBUG(SUFF)) {
a1455 1
	    }
d1482 1
a1482 1
	if (DEBUG(SUFF)) {
a1483 1
	}
a1484 2

    return(0);
d1583 1
a1583 2
    if (ln != NULL)
	Lst_ForEachFrom(tGn->children, ln, SuffExpandChildren, tGn);
d2301 1
a2301 1
static int SuffPrintName(s, dummy)
a2302 1
    ClientData dummy;
d2304 1
a2304 2
    printf ("%s ", ((Suff *) s)->name);
    return (dummy ? 0 : 0);
d2307 2
a2308 2
static int
SuffPrintSuff (sp, dummy)
a2309 1
    ClientData dummy;
d2311 1
a2311 1
    Suff    *s = (Suff *) sp;
d2315 1
a2315 1
    printf ("# `%s' ", s->name);
d2319 1
a2319 1
	fputs (" (", stdout);
d2325 1
a2325 1
		    printf ("NULL");
d2328 1
a2328 1
		    printf ("INCLUDE");
d2331 1
a2331 1
		    printf ("LIBRARY");
d2337 7
a2343 11
    fputc ('\n', stdout);
    printf ("#\tTo: ");
    Lst_ForEach(s->parents, SuffPrintName, NULL);
    fputc ('\n', stdout);
    printf ("#\tFrom: ");
    Lst_ForEach(s->children, SuffPrintName, NULL);
    fputc ('\n', stdout);
    printf ("#\tSearch Path: ");
    Dir_PrintPath (s->searchPath);
    fputc ('\n', stdout);
    return (dummy ? 0 : 0);
d2346 2
a2347 2
static int
SuffPrintTrans (tp, dummy)
a2348 1
    ClientData dummy;
d2350 1
a2350 1
    GNode   *t = (GNode *) tp;
d2352 5
a2356 6
    printf ("%-16s: ", t->name);
    Targ_PrintType (t->type);
    fputc ('\n', stdout);
    Lst_ForEach(t->commands, Targ_PrintCmd, NULL);
    fputc ('\n', stdout);
    return(dummy ? 0 : 0);
d2362 2
a2363 2
    printf ("#*** Suffixes:\n");
    Lst_ForEach(sufflist, SuffPrintSuff, NULL);
d2365 2
a2366 2
    printf ("#*** Transformations:\n");
    Lst_ForEach(transforms, SuffPrintTrans, NULL);
@


1.25
log
@Remove idiotic, braindead casts T* -> void*
They serve no purpose, except hiding potential bugs.

In particular, remove (ClientData) cast from macro, showing potentially
troublesome use of Hashes to store time_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.24 2000/03/26 15:51:31 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.24 2000/03/26 15:51:31 espie Exp $";
d1067 1
a1067 1
 *	Ture if an src was removed
@


1.24
log
@Remove refCount for suffixes.
- suffixes can't be removed from suffList except when an explicit reset
is seen, e.g.,
.SUFFIXES:

This actually occurs seldom enough that the very small memory gain does
not justify the extra code and added complexity.

(Removing suffixes at other times, as the old code used to do, is a bug)
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.23 2000/03/14 19:00:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.23 2000/03/14 19:00:32 espie Exp $";
d392 1
a392 1
    SuffUnRef((ClientData) l, (ClientData) s);
d434 2
a435 2
	Lst_AtEnd (l, (ClientData)s);
	Lst_AtEnd(s->ref, (ClientData) l);
d440 2
a441 2
	Lst_Insert(l, ln, (ClientData)s);
	Lst_AtEnd(s->ref, (ClientData) l);
d514 1
a514 1
	    srcLn = Lst_Find(sufflist, SuffSuffIsPrefix, (ClientData)str);
d517 1
a517 1
				  SuffSuffIsPrefix, (ClientData)str);
d545 1
a545 1
	    targLn = Lst_Find(sufflist, SuffSuffHasNameP, (ClientData)str2);
d601 1
a601 1
    ln = Lst_Find(transforms, SuffGNHasNameP, (ClientData)line);
d608 1
a608 1
	Lst_AtEnd (transforms, (ClientData)gn);
d730 1
a730 1
	ln = Lst_Find(sufflist, SuffSuffHasNameP, (ClientData)cp);
d752 1
a752 1
	ln = Lst_Find(sufflist, SuffSuffHasNameP, (ClientData)transform->name);
d790 1
a790 1
    ln = Lst_Find(sufflist, SuffSuffHasNameP, (ClientData)str);
d803 1
a803 1
	Lst_AtEnd(sufflist, (ClientData)s);
d808 1
a808 1
	Lst_ForEach (transforms, SuffRebuildGraph, (ClientData)s);
d832 1
a832 1
    ln = Lst_Find(sufflist, SuffSuffHasNameP, (ClientData)sname);
d928 1
a928 1
    ln = Lst_Find(sufflist, SuffSuffHasNameP, (ClientData)sname);
d958 1
a958 1
    ln = Lst_Find(sufflist, SuffSuffHasNameP, (ClientData)sname);
d1007 1
a1007 1
	Lst_AtEnd(ls->l, (ClientData)s2);
d1010 1
a1010 1
	Lst_AtEnd(targ->cp, (ClientData) s2);
d1012 1
a1012 1
	Lst_ForEach(ls->l, PrintAddr, (ClientData) 0);
d1024 1
a1024 1
    Lst_AtEnd(ls->l, (ClientData)s2);
d1027 1
a1027 1
    Lst_AtEnd(targ->cp, (ClientData)s2);
d1029 1
a1029 1
    Lst_ForEach(ls->l, PrintAddr, (ClientData) 0);
d1058 1
a1058 1
    Lst_ForEach (targ->suff->children, SuffAddSrc, (ClientData)&ls);
d1086 1
a1086 1
    Lst_ForEach(l, PrintAddr, (ClientData) 0);
d1099 1
a1099 1
		LstNode ln = Lst_Member(s->parent->cp, (ClientData)s);
d1118 1
a1118 1
	    Lst_ForEach(s->cp, PrintAddr, (ClientData) 0);
d1183 1
a1183 1
	Lst_AtEnd(slst, (ClientData)s);
d1238 1
a1238 2
	    ln = Lst_Find(sufflist, SuffSuffHasNameP, 
	    	(ClientData)&cp[prefLen]);
d1248 1
a1248 2
		if (Lst_Member (suff->parents,
				(ClientData)targ->suff) != NULL)
d1267 1
a1267 1
		    Lst_AtEnd(targ->cp, (ClientData)ret);
d1269 1
a1269 1
		    Lst_AtEnd(slst, (ClientData)ret);
d1314 1
a1314 1
    prevLN = Lst_Member(pgn->children, (ClientData)cgn);
d1361 1
a1361 1
			Lst_AtEnd(members, (ClientData)gn);
d1400 1
a1400 1
		    Lst_AtEnd(members, (ClientData)gn);
d1415 2
a1416 2
		if (Lst_Member(pgn->children, (ClientData)gn) == NULL) {
		    Lst_Append(pgn->children, prevLN, (ClientData)gn);
d1418 1
a1418 1
		    Lst_AtEnd(gn->parents, (ClientData)pgn);
d1432 1
a1432 1
	ln = Lst_Member(pgn->children, (ClientData)cgn);
d1451 1
a1451 1
	ln = Lst_Find(sufflist, SuffSuffIsSuffixP, (ClientData)cp);
d1488 2
a1489 2
	    if (Lst_Member(pgn->children, (ClientData)gn) == NULL) {
		Lst_Append(pgn->children, prevLN, (ClientData)gn);
d1491 1
a1491 1
		Lst_AtEnd(gn->parents, (ClientData)pgn);
d1505 1
a1505 1
	ln = Lst_Member(pgn->children, (ClientData)cgn);
d1545 1
a1545 1
    if (Lst_Member(tGn->children, (ClientData)sGn) == NULL) {
d1550 2
a1551 2
	Lst_AtEnd(tGn->children, (ClientData)sGn);
	Lst_AtEnd(sGn->parents, (ClientData)tGn);
d1565 1
a1565 1
	    if (Lst_Member(tGn->children, (ClientData)gn) == NULL) {
d1570 2
a1571 2
		Lst_AtEnd(tGn->children, (ClientData)gn);
		Lst_AtEnd(gn->parents, (ClientData)tGn);
d1580 1
a1580 1
    ln = Lst_Find(transforms, SuffGNHasNameP, (ClientData)tname);
d1612 2
a1613 4
    if (ln != NULL) {
	Lst_ForEachFrom(tGn->children, ln,
			SuffExpandChildren, (ClientData)tGn);
    }
d1619 1
a1619 1
    Lst_AtEnd(sGn->iParents, (ClientData)tGn);
d1681 3
a1683 3
    if (Lst_Member(gn->children, (ClientData)mem) == NULL) {
	Lst_AtEnd(gn->children, (ClientData)mem);
	Lst_AtEnd(mem->parents, (ClientData)gn);
d1863 1
a1863 1
	    Lst_AtEnd(targs, (ClientData)targ);
d1905 1
a1905 1
	Lst_AtEnd(targs, (ClientData)targ);
d1948 1
a1948 1
    Lst_ForEach(gn->children, SuffExpandChildren, (ClientData)gn);
d2041 2
a2042 2
		if (Lst_Member(slst, (ClientData) bottom) == NULL) {
		    Lst_AtEnd(slst, (ClientData) bottom);
d2117 2
a2118 2
	if (Lst_Member(slst, (ClientData) bottom) == NULL)
	    Lst_AtEnd(slst, (ClientData) bottom);
d2199 1
a2199 1
	ln = Lst_Find(sufflist, SuffSuffHasNameP, (ClientData)LIBSUFF);
d2242 1
a2242 1
    ln = Lst_Find(sufflist, SuffSuffHasNameP, (ClientData)name);
d2372 1
a2372 1
    Lst_ForEach (s->parents, SuffPrintName, (ClientData)0);
d2375 1
a2375 1
    Lst_ForEach (s->children, SuffPrintName, (ClientData)0);
d2393 1
a2393 1
    Lst_ForEach (t->commands, Targ_PrintCmd, (ClientData)0);
d2402 1
a2402 1
    Lst_ForEach (sufflist, SuffPrintSuff, (ClientData)0);
d2405 1
a2405 1
    Lst_ForEach (transforms, SuffPrintTrans, (ClientData)0);
@


1.23
log
@Disable suffix removal for now, as it's buggy.

*If* refcounting is to be useful, the actual erasure of suffixes data
should occur when stuff is moved from the suffList to the cleanList, and
it's not at all clear whether all the extra baggage is actually any use.
How many suffixes are we talking about anyway ?

This lets gnupg build correctly without gnu-make.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.22 2000/01/08 09:45:15 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.22 2000/01/08 09:45:15 espie Exp $";
a127 1
    int		 refCount;	/* Reference count of list membership */
d172 1
a172 1
static Suff *SuffRemove __P((Lst, Suff *));
d344 1
a344 1
    if (ln != NULL) {
a345 2
	((Suff *) sp)->refCount--;
    }
a371 7
#ifdef notdef
    /* We don't delete suffixes in order, so we cannot use this */
    if (s->refCount)
	Punt("Internal error deleting suffix `%s' with refcount = %d", s->name,
	    s->refCount); 
#endif

d384 1
a384 8
 *	Remove the suffix into the list
 *
 * Results:
 *	None
 *
 * Side Effects:
 *	The reference count for the suffix is decremented and the
 *	suffix is possibly freed
d387 1
a387 1
static Suff *
a392 8
#if 0
    if (s->refCount == 0) {
	SuffUnRef ((ClientData) sufflist, (ClientData) s);
	SuffFree((ClientData) s);
	s = NULL;
    }
#endif
    return (s);
a434 1
	s->refCount++;
a440 1
	s->refCount++;
d677 1
a677 3
	 * Remove the source from the target's children list. We check for a
	 * null return to handle a beanhead saying something like
	 *  .c.o .c.o:
d682 1
a682 1
	s = SuffRemove(t->children, s);
d687 1
a687 2
	if (s != NULL)
	    SuffRemove(s->parents, t);
a801 1
	s->refCount =	0;
a1004 1
	s->refCount++;
a1021 1
    s->refCount++;
a1261 1
		    suff->refCount++;
a1842 1
	    targ->suff->refCount++;
a1886 1
	targ->suff->refCount++;
a1982 2
		    if (gn->suffix)
			gn->suffix->refCount--;
a1983 1
		    gn->suffix->refCount++;
a2000 2
		    if (gn->suffix)
			gn->suffix->refCount--;
a2016 2
	    if (gn->suffix)
		gn->suffix->refCount--;
a2017 2
	    if (gn->suffix)
		gn->suffix->refCount++;
a2079 2
	if (src->node->suffix)
	    src->node->suffix->refCount--;
a2080 1
	src->node->suffix->refCount++;
a2106 2
    if (gn->suffix)
	gn->suffix->refCount--;
a2107 1
    gn->suffix->refCount++;
a2203 2
	if (gn->suffix)
	    gn->suffix->refCount--;
a2205 1
	    gn->suffix->refCount++;
a2301 1
    suffNull->refCount =    1;
d2352 1
a2352 1
    printf ("# `%s' [%d] ", s->name, s->refCount);
@


1.22
log
@Finish changing all Var_Parse arguments to size_t. Thanks to millert@@
for reminding me.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.21 1999/12/19 00:04:25 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.21 1999/12/19 00:04:25 espie Exp $";
d410 1
d416 1
@


1.21
log
@Rearrange Lst_Find interface to conform better with other functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.20 1999/12/18 21:58:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.20 1999/12/18 21:58:07 espie Exp $";
d1410 1
a1410 1
			int 	len;
@


1.20
log
@Nothing ever checks ReturnStatus on Lst_Insert, Lst_Append, Lst_AtFront,
Lst_AtEnd, Lst_Concat, Lst_Remove, Lst_Replace.

Don't bother returning one.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.19 1999/12/18 21:56:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.19 1999/12/18 21:56:07 espie Exp $";
d539 1
a539 1
	    srcLn = Lst_Find(sufflist, (ClientData)str, SuffSuffIsPrefix);
d541 2
a542 2
	    srcLn = Lst_FindFrom (sufflist, Lst_Succ(srcLn), (ClientData)str,
				  SuffSuffIsPrefix);
d570 1
a570 1
	    targLn = Lst_Find(sufflist, (ClientData)str2, SuffSuffHasNameP);
d626 1
a626 1
    ln = Lst_Find (transforms, (ClientData)line, SuffGNHasNameP);
d758 1
a758 1
	ln = Lst_Find(sufflist, (ClientData)cp, SuffSuffHasNameP);
d780 1
a780 1
	ln = Lst_Find(sufflist, (ClientData)transform->name, SuffSuffHasNameP);
d818 1
a818 1
    ln = Lst_Find (sufflist, (ClientData)str, SuffSuffHasNameP);
d861 1
a861 1
    ln = Lst_Find (sufflist, (ClientData)sname, SuffSuffHasNameP);
d957 1
a957 1
    ln = Lst_Find (sufflist, (ClientData)sname, SuffSuffHasNameP);
d987 1
a987 1
    ln = Lst_Find (sufflist, (ClientData)sname, SuffSuffHasNameP);
d1269 2
a1270 2
	    ln = Lst_Find (sufflist, (ClientData)&cp[prefLen],
			   SuffSuffHasNameP);
d1485 1
a1485 1
	ln = Lst_Find(sufflist, (ClientData)cp, SuffSuffIsSuffixP);
d1614 1
a1614 1
    ln = Lst_Find(transforms, (ClientData)tname, SuffGNHasNameP);
d1761 1
a1761 1
	ln = Lst_Find(ms->parents, eoarch, SuffSuffIsSuffixP);
d1863 1
a1863 1
	ln = Lst_FindFrom(sufflist, ln, eoname, SuffSuffIsSuffixP);
d2252 1
a2252 1
	ln = Lst_Find (sufflist, (ClientData)LIBSUFF, SuffSuffHasNameP);
d2298 1
a2298 1
    ln = Lst_Find(sufflist, (ClientData)name, SuffSuffHasNameP);
@


1.19
log
@Lst_DeQueue already checks for empty lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.18 1999/12/18 21:53:33 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.18 1999/12/18 21:53:33 espie Exp $";
d457 1
a457 1
	(void)Lst_AtEnd (l, (ClientData)s);
d459 1
a459 1
	(void)Lst_AtEnd(s->ref, (ClientData) l);
d464 1
a464 1
	(void)Lst_Insert (l, ln, (ClientData)s);
d466 1
a466 1
	(void)Lst_AtEnd(s->ref, (ClientData) l);
d493 1
a493 1
    Lst_Concat (suffClean, sufflist, LST_CONCLINK);
d633 1
a633 1
	(void)Lst_AtEnd (transforms, (ClientData)gn);
d832 1
a832 1
	(void)Lst_AtEnd (sufflist, (ClientData)s);
d1037 1
a1037 1
	(void)Lst_AtEnd (ls->l, (ClientData)s2);
d1055 1
a1055 1
    (void)Lst_AtEnd (ls->l, (ClientData)s2);
d1058 1
a1058 1
    Lst_AtEnd(targ->cp, (ClientData) s2);
d1214 1
a1214 1
	Lst_AtEnd(slst, (ClientData) s);
d1301 1
a1301 1
		    Lst_AtEnd(targ->cp, (ClientData) ret);
d1303 1
a1303 1
		    Lst_AtEnd(slst, (ClientData) ret);
d1395 1
a1395 1
			(void)Lst_AtEnd(members, (ClientData)gn);
d1434 1
a1434 1
		    (void)Lst_AtEnd(members, (ClientData)gn);
d1450 1
a1450 1
		    (void)Lst_Append(pgn->children, prevLN, (ClientData)gn);
d1452 1
a1452 1
		    (void)Lst_AtEnd(gn->parents, (ClientData)pgn);
d1523 1
a1523 1
		(void)Lst_Append(pgn->children, prevLN, (ClientData)gn);
d1525 1
a1525 1
		(void)Lst_AtEnd(gn->parents, (ClientData)pgn);
d1584 2
a1585 2
	(void)Lst_AtEnd(tGn->children, (ClientData)sGn);
	(void)Lst_AtEnd(sGn->parents, (ClientData)tGn);
d1604 2
a1605 2
		(void)Lst_AtEnd(tGn->children, (ClientData)gn);
		(void)Lst_AtEnd(gn->parents, (ClientData)tGn);
d1655 1
a1655 1
    (void)Lst_AtEnd(sGn->iParents, (ClientData)tGn);
d1718 2
a1719 2
	(void)Lst_AtEnd(gn->children, (ClientData)mem);
	(void)Lst_AtEnd(mem->parents, (ClientData)gn);
d1900 1
a1900 1
	    (void)Lst_AtEnd(targs, (ClientData)targ);
d1943 1
a1943 1
	(void)Lst_AtEnd(targs, (ClientData)targ);
@


1.18
log
@NIL, NILGNODE, etc, are only glorified NULL.
Get rid of them.

Get rid of list.h, nothing uses it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.17 1999/12/18 02:11:27 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.17 1999/12/18 02:11:27 espie Exp $";
d1183 1
a1183 3
    while (!Lst_IsEmpty (srcs)) {
	s = (Src *) Lst_DeQueue (srcs);

d1445 1
a1445 3
	    while(!Lst_IsEmpty(members)) {
		gn = (GNode *)Lst_DeQueue(members);

d1511 2
a1512 6
	while (!Lst_IsEmpty(exp)) {
	    /*
	     * Fetch next expansion off the list and find its GNode
	     */
	    cp = (char *)Lst_DeQueue(exp);

@


1.17
log
@make does not use circular lists, get rid of the extra weight.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.16 1999/12/16 17:27:18 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.16 1999/12/16 17:27:18 espie Exp $";
d97 1
a97 1
 *	    	  	    	bottom-most node added to the graph or NILGNODE
d345 1
a345 1
    if (ln != NILLNODE) {
d442 1
a442 1
    while ((ln = Lst_Next (l)) != NILLNODE) {
d453 1
a453 1
    if (ln == NILLNODE) {
d528 2
a529 2
    srcLn = NILLNODE;
    singleLn = NILLNODE;
d538 1
a538 1
	if (srcLn == NILLNODE) {
d544 1
a544 1
	if (srcLn == NILLNODE) {
d548 1
a548 1
	    if (singleLn != NILLNODE) {
d571 1
a571 1
	    if (targLn != NILLNODE) {
d627 1
a627 1
    if (ln == NILLNODE) {
d703 1
a703 1
	 * nil return to handle a beanhead saying something like
d759 1
a759 1
	if (ln != NILLNODE) {
d785 1
a785 1
	if (ln != NILLNODE) {
d819 1
a819 1
    if (ln == NILLNODE) {
d847 1
a847 1
 *	The searchPath for the desired suffix or NILLST if the suffix isn't
d862 2
a863 2
    if (ln == NILLNODE) {
	return (NILLST);
d904 1
a904 1
    while ((ln = Lst_Next (sufflist)) != NILLNODE) {
d958 1
a958 1
    if (ln != NILLNODE) {
d988 1
a988 1
    if (ln != NILLNODE) {
d1032 1
a1032 1
	s2->node =  	NILGNODE;
d1050 1
a1050 1
    s2->node = 	    NILGNODE;
d1122 1
a1122 1
    while ((ln = Lst_Next (l)) != NILLNODE) {
d1131 1
a1131 1
		if (ln != NILLNODE)
d1194 1
a1194 1
	if (Targ_FindNode(s->file, TARG_NOCREATE) != NILGNODE) {
d1233 1
a1233 1
 *	The Src structure of the "winning" child, or NIL if no such beast.
d1257 1
a1257 1
    while ((ln = Lst_Next (t->children)) != NILLNODE) {
d1273 1
a1273 1
	    if (ln != NILLNODE) {
d1283 1
a1283 1
				(ClientData)targ->suff) != NILLNODE)
d1453 1
a1453 1
		if (Lst_Member(pgn->children, (ClientData)gn) == NILLNODE) {
d1495 1
a1495 1
	if (ln != NILLNODE) {
d1530 1
a1530 1
	    if (Lst_Member(pgn->children, (ClientData)gn) == NILLNODE) {
d1587 1
a1587 1
    if (Lst_Member(tGn->children, (ClientData)sGn) == NILLNODE) {
d1604 1
a1604 1
	for (ln=Lst_First(sGn->cohorts); ln != NILLNODE; ln=Lst_Succ(ln)) {
d1607 1
a1607 1
	    if (Lst_Member(tGn->children, (ClientData)gn) == NILLNODE) {
d1625 1
a1625 1
    if (ln == NILLNODE) {
d1654 1
a1654 1
    if (ln != NILLNODE) {
d1725 1
a1725 1
    if (Lst_Member(gn->children, (ClientData)mem) == NILLNODE) {
d1771 1
a1771 1
	if (ln != NILLNODE) {
d1867 1
a1867 1
    while (ln != NILLNODE) {
d1873 1
a1873 1
	if (ln != NILLNODE) {
d2096 1
a2096 1
		if (Lst_Member(slst, (ClientData) bottom) == NILLNODE) {
d2124 1
a2124 1
    if (bottom->node == NILGNODE) {
d2136 1
a2136 1
	if (targ->node == NILGNODE) {
d2178 1
a2178 1
	if (Lst_Member(slst, (ClientData) bottom) == NILLNODE)
d2263 1
a2263 1
	if (ln != NILLNODE) {
d2307 1
a2307 1
    if (ln != NILLNODE) {
@


1.16
log
@Var_Subst is actually two distinct functions folded into one:
split the function specific to for.c out, and give them more sensible
arguments at the same time.

This makes .for loop handling more efficient, as we have some heuristic
to evaluate the size of the buffer needed...
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.15 1999/12/06 22:28:44 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.15 1999/12/06 22:28:44 espie Exp $";
d495 1
a495 1
    sufflist = Lst_Init(FALSE);
d644 2
a645 2
	gn->commands = Lst_Init (FALSE);
	gn->children = Lst_Init (FALSE);
d824 4
a827 4
	s->searchPath = Lst_Init (FALSE);
	s->children = 	Lst_Init (FALSE);
	s->parents = 	Lst_Init (FALSE);
	s->ref = 	Lst_Init (FALSE);
d901 2
a902 2
    inIncludes = Lst_Init(FALSE);
    inLibs = Lst_Init(FALSE);
d1039 1
a1039 1
	s2->cp = Lst_Init(FALSE);
d1057 1
a1057 1
    s2->cp = Lst_Init(FALSE);
d1301 1
a1301 1
		    ret->cp = Lst_Init(FALSE);
d1365 1
a1365 1
	    Lst	    members = Lst_Init(FALSE);
d1512 1
a1512 1
	exp = Lst_Init(FALSE);
d1845 2
a1846 2
    srcs = Lst_Init(FALSE);
    targs = Lst_Init(FALSE);
d1888 1
a1888 1
	    targ->cp = Lst_Init(FALSE);
d1934 1
a1934 1
	targ->cp = Lst_Init(FALSE);
d2338 1
a2338 1
    sufflist = Lst_Init (FALSE);
d2340 1
a2340 1
    suffClean = Lst_Init(FALSE);
d2342 2
a2343 2
    srclist = Lst_Init (FALSE);
    transforms = Lst_Init (FALSE);
d2355 1
a2355 1
    suffNull->searchPath =  Lst_Init (FALSE);
d2357 3
a2359 3
    suffNull->children =    Lst_Init (FALSE);
    suffNull->parents =	    Lst_Init (FALSE);
    suffNull->ref =	    Lst_Init (FALSE);
@


1.15
log
@Extra parameter no longer needed, ditch.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.14 1999/10/05 22:06:24 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.14 1999/10/05 22:06:24 espie Exp $";
d1362 1
a1362 1
	cp = Var_Subst(NULL, cgn->name, pgn, TRUE);
@


1.14
log
@Efficiency patch from NetBSD:
make spends time freeing data structures right before exiting.
So don't bother.
Keep the code inside #ifdef, so that it's still there if someone
ever wants to use make code inside a library.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.13 1999/03/06 20:27:40 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.13 1999/03/06 20:27:40 millert Exp $";
d1735 1
a1735 3
	char *p1;
	Var_Set(copy[i], Var_Value(copy[i], mem, &p1), gn);
	efree(p1);
@


1.13
log
@back out changes that should not have escaped my local tree
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.11 1998/12/05 00:06:29 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.11 1998/12/05 00:06:29 espie Exp $";
d107 1
d109 1
d492 1
d494 1
d2341 1
d2343 1
d2385 1
d2392 1
@


1.12
log
@add missing reference to infocmp
@
text
@a688 1
	Lst	p;
a697 5
	 * Store s->parents because s could be deleted in SuffRemove
	 */
	p = s->parents;

	/*
d710 2
a711 1
	SuffRemove(p, t);
@


1.11
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.9 1998/07/02 21:32:10 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.9 1998/07/02 21:32:10 millert Exp $";
d689 1
d699 5
d716 1
a716 2
	if (s != NULL)
	    SuffRemove(s->parents, t);
@


1.10
log
@Better fix from Christos:
    deleting a suffix that has 0 source references causes core-dump.
    Fix: when an unused suffix gets removed, delete it from the suffix list.
There is still, however a duplicate free(), which I work around by passing
the Suffix back as a return value to SuffRemove() (it gets set to NULL
when the suffix is freed).  This is probably not the best way to fix this.
@
text
@d1733 1
a1733 2
	if (p1)
	    free(p1);
d2067 1
a2067 2
	    if (gn->path != NULL)
		free(gn->path);
d2167 1
a2167 2
    if (gn->path)
	free(gn->path);
@


1.9
log
@Check against suffNull, not the contents of name
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.8 1998/07/02 21:25:40 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.8 1998/07/02 21:25:40 millert Exp $";
d171 1
a171 1
static void SuffRemove __P((Lst, Suff *));
d373 7
d402 1
a402 1
static void
d408 2
a409 1
    if (s->refCount == 0)
d411 3
d705 1
a705 2
	if (t != suffNull)
	    SuffRemove(t->children, s);
d710 1
a710 1
	if (s != suffNull)
@


1.8
log
@better fix; may be a small memory leak though
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.7 1998/07/02 21:00:05 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.7 1998/07/02 21:00:05 millert Exp $";
d694 1
a694 1
	if (*t->name)
d700 1
a700 1
	if (*s->name)
@


1.7
log
@back out last patch; it causes incorrect behavior
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.6 1998/07/02 20:47:28 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.6 1998/07/02 20:47:28 millert Exp $";
d682 1
a682 1
	    printf("deleting transformation from %s to %s\n",
d694 2
a695 1
	SuffRemove(t->children, s);
d700 2
a701 1
	SuffRemove(s->parents, t);
@


1.6
log
@Fix a bug where make gets confused by targets beginning with a period (``.'')
and tried to do a suffix conversion, following a NULL pointer in the
proccess.  Also add some sanity checks so we don't blindly assume
strchr returns non-NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.5 1996/11/30 21:09:04 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.5 1996/11/30 21:09:04 millert Exp $";
a635 6
    /*
     * If there is nothing to transform to, *t->name will be NUL.
     * The rest is paranoia.
     */
    if (!s->name || !t->name || !*s->name || !*t->name)
	return(NULL);
@


1.5
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: suff.c,v 1.4 1996/09/02 16:04:19 briggs Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.4 1996/09/02 16:04:19 briggs Exp $";
d636 6
d1694 2
@


1.4
log
@Sync up with NetBSD:
(christos)
	Fix bug reported by Greg Hudson where leaf (source only) nodes were
	referenced only by their basename and not by their full pathname. This
	breaks when .PATH or MAKEOBJDIR are used. There might be Makefiles
	around that try to work around this bug by prepending ${.CURDIR} to
	the sources, and they should be found and fixed. Also a lot of the gunk
	in suff.c that was attempting to work around the same problem could be
	removed.
(christos)
	- Move -D flags from Makefile to config.h and explain what they do. Add
	  -Wall -Wno-unused to CFLAGS. Add new define SYSVVARSUB to enable SysV
	  style variable substitutions and enable them.
	- Add SunOS style command substitutions via SUNSHCMD
	- Fix core dump with '{variable = value'
(christos)
	Fix bug where make will always exit with 0, even when one or more
	parallel jobs failed. (Only affects parallel make code)
(christos)
	Protect __P from being multiply defined (for systems that already
	define it)
(christos) Add strdup() since ultrix is missing it.
	From Larry Schwimmer <rosebud@@cyclone.Stanford.EDU>
(christos) Add estrdup(), a checked version of strdup and use it.
(christos) Recognize SVR4 style long filename entries in archives.
(thorpej) Tidy up some RCS ids a bit.
@
text
@d1 2
a2 2
/*	$OpenBSD: suff.c,v 1.3 1996/06/26 05:36:38 deraadt Exp $	*/
/*	$NetBSD: suff.c,v 1.12 1996/08/13 16:42:16 christos Exp $	*/
d5 2
a6 2
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
d44 1
a44 1
static char sccsid[] = "@@(#)suff.c	5.6 (Berkeley) 6/1/90";
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.3 1996/06/26 05:36:38 deraadt Exp $";
a104 1
#include    	  "bit.h"
d168 1
d515 1
a515 1
    
d615 1
a615 1
	 * by the Parse module. 
d638 1
a638 1
     * link the two together in the proper relationship and order 
d673 1
a673 1
 
d822 1
a822 1
    } 
d1005 1
a1005 1
    
d1335 1
a1335 1
    
d1350 1
a1350 1
	    
d1371 1
a1371 1
		for (start = cp; *start == ' ' || *start == '\t'; start++) 
d1478 1
a1478 1
	
d1526 1
a1526 1
    
d1619 1
a1619 1
    
d1628 1
a1628 1
    
d1681 1
a1681 1
    
d1693 1
a1693 1
    
d1712 1
a1712 1
    
d1825 1
a1825 1
    
d1861 1
a1861 1
	    
d1875 1
a1875 1
	    
d1907 1
a1907 1
	    printf("\tNo known suffix on %s. Using .NULL suffix: ", gn->name);
d1909 1
a1909 1
	
d1929 1
a1929 1
	    if (DEBUG(SUFF)) 
d1933 1
a1933 1
	if (DEBUG(SUFF)) 
d1938 1
a1938 1
    
d1980 1
a1980 1
    
d2058 1
a2058 1
	
d2108 1
a2108 1
     * Etc. 
d2113 1
a2113 1
    
d2142 1
a2142 1
	
d2174 2
a2175 2
	
    
d2208 1
a2208 1
   
d2228 1
a2228 1
    
d2232 1
a2232 1
    
d2246 1
a2246 1
	
d2397 1
a2397 1
    
@


1.3
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: suff.c,v 1.11 1995/11/02 23:55:08 christos Exp $	*/
/*	$NetBSD: suff.c,v 1.11 1995/11/02 23:55:08 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: suff.c,v 1.11 1995/11/02 23:55:08 christos Exp $";
d806 1
a806 1
	s->name =   	strdup (str);
d1013 1
a1013 1
	s2->file =  	strdup(targ->pref);
d1276 1
a1276 1
		    ret->file = strdup(s->name);
d1866 1
a1866 1
	    targ->file = strdup(gn->name);
d1911 1
a1911 1
	targ->file = strdup(gn->name);
d1917 1
a1917 1
	targ->pref = strdup(sopref);
d2056 1
a2056 1
	    gn->path = strdup(gn->name);
d2157 1
a2157 1
    gn->path = strdup(gn->name);
d2338 1
a2338 1
    suffNull->name =   	    strdup ("");
@


1.2
log
@from christos@@netbsd:
Minor:
    - ${.PREFIX} should never contain a full pathname
    - Fixed gcc -Wall warnings
Major:
    - compatMake is now FALSE. This means that we are now running in
      full pmake mode:
          * rules on dependency lines can be executed in parallel and or
            out of sequence:

            foo: bar baz

            can fire the rule for baz before the rule for bar is fired.
            To enforce bar to be fired before baz, another rule needs to be
            added. [bar: baz]
          * adjacent shell commands in a target are now executed by a single
            invocation of the shell, not one invocation of the shell per line
      (compatMake can be turned off using the -B flag)
    - The -j flag now works... I.e. make -j 4 will fork up to four jobs in
      parallel when it can. The target name is printed before each burst
      of output caused by the target execution as '--- target ---', when j > 1
    - I have changed all the Makefiles so that they work with make -j N, and
      I have tested the whole netbsd by:
          'make -j 4 cleandir; make -j 4 depend; make -j 4; make -j 4 install'
    - I have not compiled or tested this version of make with -DREMOTE.
- Turn compat mode on by default. It gets turned off when the -j without
  the -B flag is specified. [Thus you can use -j 1 to turn it off].
- Fix malloc -> emalloc as Gordon noted.
Updates for POSIX/SVR4 compiling:
arch.c:          Don't require ranlib stuff. Not everybody has it.
dir.c:           SunOS-4 != Solaris; change #ifdef sun to #if sun && !__svr4__
job.c, compat.c: Don't use 'union wait', use int and the W*() macros.
main.c:          Check for uname() == -1; some unames return > 0...
util.c, job.c:   Add signal() with BSD semantics for svr4, don't use bsd
                 sigmask and friends.

from cgd@@netbsd:
pull in make.h.  (PAlloc() now uses emalloc(), which is prototyped in
make.h.  If the prototype is not in scope on the Alpha, I see lots
of "cast to pointer from integer of different size" warnings.)
@
text
@d1 1
d46 1
a46 1
static char rcsid[] = "$NetBSD: suff.c,v 1.11 1995/11/02 23:55:08 christos Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: suff.c,v 1.10 1995/09/25 02:46:30 christos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: suff.c,v 1.10 1995/09/25 02:46:30 christos Exp $";
d1430 1
a1430 1
	    while (!Lst_IsEmpty(members)) {
d1998 1
d2006 1
a2006 1
		    int		len = strlen(gn->path);
d2014 2
a2015 2
		    savec = gn->path[len-targ->suff->nameLen];
		    gn->path[len-targ->suff->nameLen] = '\0';
d2017 4
a2020 1
		    Var_Set(PREFIX, gn->path, gn);
d2022 3
a2024 1
		    gn->path[len-targ->suff->nameLen] = savec;
d2034 6
a2039 1
		    Var_Set(PREFIX, gn->path, gn);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
