head	1.3;
access;
symbols
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@.\" @;


1.3
date	2001.03.02.16.57.28;	author espie;	state dead;
branches;
next	1.2;

1.2
date	2001.01.28.15.45.44;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.28.10.12.49;	author espie;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Use the ohash_* that's now in libc.
@
text
@.\"	$OpenBSD: ohash.3,v 1.2 2001/01/28 15:45:44 espie Exp $
.\"
.\" Copyright (c) 1999 Marc Espie.
.\"
.\" Code written for the OpenBSD project.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
.\" ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
.\" PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd November 3, 1999
.Dt OPEN_HASH 3
.Os
.Sh NAME
.Nm hash_init ,
.Nm hash_delete ,
.Nm hash_lookup_string ,
.Nm hash_lookup_interval ,
.Nm hash_lookup_memory ,
.Nm hash_find ,
.Nm hash_remove ,
.Nm hash_insert ,
.Nm hash_first ,
.Nm hash_next ,
.Nm hash_entries
.Nd light-weight open hashing
.Sh SYNOPSIS
.Fd #include <sys/types.h>
.Fd #include <stddef.h>
.Fd #include <ohash.h>
.Ft void
.Fn hash_init "struct hash *h" "unsigned int size" "struct hash_info *info"
.Ft void
.Fn hash_delete "struct hash *h"
.Ft "unsigned int"
.Fn hash_lookup_string "struct hash *h" "const char *k" "u_int32_t v"
.Ft "unsigned int"
.Fn hash_lookup_interval "struct hash *h" "const char *start" "const char *end" "u_int32_t hv"
.Ft "unsigned int"
.Fn hash_lookup_memory "struct hash *h" "const char *k" "size_t s" "u_int32_t hv"
.Ft void *
.Fn hash_find "struct hash *h" "unsigned int i"
.Ft void *
.Fn hash_remove "struct hash *h" "unsigned int i"
.Ft void *
.Fn hash_insert "struct hash *h" "unsigned int i" "void *p"
.Ft void *
.Fn hash_first "struct hash *h" "unsigned int *i"
.Ft void *
.Fn hash_next "struct hash *h" "unsigned int *i"
.Ft "unsigned int"
.Fn hash_entries "struct hash *h"
.Sh DESCRIPTION
Those functions have been designed as a fast, extensible alternative to
the usual hash table functions.
These provide storing and retrieval of records indexed by keys,
where a key is a contiguous sequence of bytes at a fixed position in
each record.
Keys can either be  null-terminated strings, or fixed-size memory areas.
All functions take a pointer to a hash structure as the
.Fa h
function argument.
Storage for this structure should be provided by user code.
.Pp
.Fn hash_init
initializes the table to store roughly 2 to the power
.Fa size
elements.
.Fa info
holds the position of the key in each record, and two pointers to
.Xr calloc 3
and
.Xr free 3
-like functions, to use for managing the table internal storage.
.Pp
.Fn hash_delete
frees storage internal to
.Fa h .
Elements themselves should be freed by the user first, using  for instance
.Fn hash_first
and
.Fn hash_next .
.Pp
.Fn hash_lookup_string ,
.Fn hash_lookup_interval
and
.Fn hash_lookup_memory
are the basic look-up element functions.
The hashing function result is provided by the user as
.Fa hv .
These return a
.Qq slot
in the hash table
.Fa h ,
to be used with
.Fn hash_find ,
.Fn hash_insert ,
or
.Fn hash_remove .
This slot is only valid up to the next call to
.Fn hash_insert
or
.Fn hash_remove .
.Pp
.Fn hash_lookup_string
and
.Fn hash_lookup_interval
handle string-like keys.
.Fn hash_lookup_string
assumes a null-terminated
.Ft char *
.Fa k ,
whereas
.Fn hash_lookup_interval
assumes the key is the interval between
.Fa start
and
.Fa end ,
exclusive.
In both cases, the actual elements stored in the hash should contain
null-terminated keys.
.Pp
.Fn hash_lookup_memory
assumes the key is the memory area starting at
.Fa k
of size
.Fa s .
All bytes are significant in key comparison.
.Pp
.Fn hash_find
retrieves an element from a slot
.Fa i
returned by the
.Fn hash_lookup*
functions.
It returns
.Va NULL
if the slot is empty.
.Pp
.Fn hash_insert
inserts a new element
.Fa p
at slot
.Fa i .
Slot
.Fa i
must be empty and element
.Fa p
must have a key corresponding to the
.Fn hash_lookup*
call.
.Pp
.Fn hash_remove
removes element of hash table at slot
.Fa i .
It returns the removed element, for user code to dispose of, or
.Va NULL
if the slot was empty.
.Pp
.Fn hash_first
and
.Fn hash_next
can be used to access all elements in a hash table, like this:
.Pp
.Bd -literal
	for (n = hash_first(h, &i); n != NULL; n = hash_next(h, &i))
		do_something_with(n);
.Ed
.Pp
.Fa i
points to an auxiliary unsigned integer used to record the current position
in the hash table.
Those functions are safe to use even while entries are added to/removed
from the table, but in such a case they don't guarantee that new entries
will be returned.
As a special case, they can safely be used to free elements in the table.
.Pp
.Fn hash_entries
returns the number of elements in the hash table.
.Sh STORAGE HANDLING
Only
.Fn hash_init ,
.Fn hash_insert ,
.Fn hash_remove
and
.Fn hash_delete
may call the user-supplied memory functions.
It is the responsability of the user memory allocation code to verify
that those calls did not fail.
.Pp
In case memory allocation fails,
.Fn hash_init
returns a useless hash table.
.Fn hash_insert
and
.Fn hash_remove
still perform the requested operation, but the returned table should be
considered read-only.
It can still be accessed by
.Fn hash_lookup* ,
.Fn hash_find ,
.Fn hash_first
and
.Fn hash_next
to dump relevant information to disk before aborting.
.Sh THREAD SAFETY
The open hashing functions are not thread-safe by design.
In particular, it cannot be guaranteed that a
.Qq slot
will not move in a threaded environment between a
.Fn hash_lookup*
and a
.Fn hash_find ,
.Fn hash_insert
or
.Fn hash_remove
call.
.Pp
Multi-threaded applications should explicitly protect hash table access.
.Sh SEE ALSO
.Rs
.%A Donald E. Knuth
.%B The Art of Computer Programming
.%V Vol. 3
.%P pp 506-550
.%D 1973
.Re
.Sh HISTORY
Those functions were designed and written for
.Ox
make
by Marc Espie in 1999.
@


1.2
log
@Missing copyright
@
text
@d1 1
a1 1
.\"	$OpenBSD$
@


1.1
log
@unsigned -> unsigned int (implicit int is deprecated)
hv is a u_int32_t.
Add __BEGIN_DECLS/__END_DECLS
Remove unused macro (hash_to_info).

Add documentation for the hash functions.
@
text
@d1 27
d43 1
a43 1
.Nd light-weight open hashing 
d48 1
a48 1
.Ft void 
d72 4
a75 4
the usual hash table functions.  
These provide storing and retrieval of records indexed by keys, 
where a key is a contiguous sequence of bytes at a fixed position in 
each record.  
d79 1
a79 1
function argument.  
d85 1
a85 1
elements.  
d87 1
a87 1
holds the position of the key in each record, and two pointers to 
d94 1
a94 1
frees storage internal to 
d97 1
a97 1
.Fn hash_first 
d102 1
a102 1
.Fn hash_lookup_interval 
d105 2
a106 2
are the basic look-up element functions.  
The hashing function result is provided by the user as 
d108 1
a108 1
These return a 
d118 1
a118 1
.Fn hash_insert 
d125 1
a125 1
handle string-like keys. 
d127 1
a127 1
assumes a null-terminated 
d130 1
a130 1
whereas 
d132 1
a132 1
assumes the key is the interval between 
d136 2
a137 2
exclusive.  
In both cases, the actual elements stored in the hash should contain 
d147 4
a150 4
.Fn hash_find 
retrieves an element from a slot 
.Fa i 
returned by the 
d152 3
a154 3
functions.  
It returns 
.Va NULL 
d158 1
a158 1
inserts a new element 
d160 1
a160 1
at slot 
d162 1
a162 1
Slot 
d166 1
a166 1
must have a key corresponding to the 
d173 1
a173 1
It returns the removed element, for user code to dispose of, or 
d177 1
a177 1
.Fn hash_first 
d189 5
a193 5
in the hash table.  
Those functions are safe to use even while entries are added to/removed 
from the table, but in such a case they don't guarantee that new entries 
will be returned.  
As a special case, they can safely be used to free elements in the table. 
d201 1
a201 1
.Fn hash_remove 
d204 3
a206 3
may call the user-supplied memory functions.  
It is the responsability of the user memory allocation code to verify 
that those calls did not fail. 
d208 1
a208 1
In case memory allocation fails, 
d215 1
a215 1
considered read-only.  
d219 1
a219 1
.Fn hash_first 
d224 1
a224 1
The open hashing functions are not thread-safe by design.  
d227 1
a227 1
will not move in a threaded environment between a 
@

