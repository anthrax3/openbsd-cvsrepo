head	1.31;
access;
symbols
	OPENBSD_6_2:1.31.0.16
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.31.0.14
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.10
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.6
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.8
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.14
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.12
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.10
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.8
	OPENBSD_5_0:1.27.0.6
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.25.0.8
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.10
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.6
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.21.0.14
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.12
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.10
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.8
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.6
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.19.0.8
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.6
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.4
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.4
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2014.05.18.08.08.50;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2014.05.12.19.11.19;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.22.08.26.31;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2013.11.22.15.47.35;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.17.09.44.20;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.16.15.24.53;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.16.15.17.44;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.07.13.11.36;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.03.02.56.12;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.23.12.34.49;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.07.22.54.53;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.03.13.41.11;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.14.13.35.38;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.14.13.32.07;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.17.23.01.20;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.17.22.57.37;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.23.16.41.53;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.12.09.18.18.24;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.12.06.22.24.32;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	99.12.06.22.18.56;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	99.11.11.11.35.17;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	98.12.05.00.06.29;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	98.03.07.18.34.50;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.11.30.21.09.04;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.36.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.43.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.01.17.16.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.31
log
@a bit more reallocarray (and kill ecalloc, which isn't used)
okay chl@@
@
text
@/*	$OpenBSD: str.c,v 1.30 2014/05/12 19:11:19 espie Exp $	*/
/*	$NetBSD: str.c,v 1.13 1996/11/06 17:59:23 christos Exp $	*/

/*-
 * Copyright (c) 1988, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <string.h>
#include "config.h"
#include "defines.h"
#include "str.h"
#include "memory.h"
#include "buf.h"

/* helpers for Str_Matchi */
static bool range_match(char, const char **, const char *);
static bool star_match(const char *, const char *, const char *, const char *);

char *
Str_concati(const char *s1, const char *e1, const char *s2, const char *e2,
    int sep)
{
	size_t len1, len2;
	char *result;

	/* get the length of both strings */
	len1 = e1 - s1;
	len2 = e2 - s2;

	/* space for separator */
	if (sep)
		len1++;
	result = emalloc(len1 + len2 + 1);

	/* copy first string into place */
	memcpy(result, s1, len1);

	/* add separator character */
	if (sep)
		result[len1-1] = sep;

	/* copy second string plus EOS into place */
	memcpy(result + len1, s2, len2);
	result[len1+len2] = '\0';
	return result;
}

/*-
 * brk_string --
 *	Fracture a string into an array of words (as delineated by tabs or
 *	spaces) taking quotation marks into account.  Leading tabs/spaces
 *	are ignored.
 *
 * returns --
 *	Pointer to the array of pointers to the words.	To make life easier,
 *	the first word is always the value of the .MAKE variable.
 */
char **
brk_string(const char *str, int *store_argc, char **buffer)
{
	int argc;
	char ch;
	char inquote;
	const char *p;
	char *start, *t;
	size_t len;
	int argmax = 50;
	size_t curlen = 0;
	char **argv = ereallocarray(NULL, argmax + 1, sizeof(char *));

	/* skip leading space chars. */
	for (; *str == ' ' || *str == '\t'; ++str)
		continue;

	/* allocate room for a copy of the string */
	if ((len = strlen(str) + 1) > curlen)
		*buffer = emalloc(curlen = len);

	/*
	 * copy the string; at the same time, parse backslashes,
	 * quotes and build the argument list.
	 */
	argc = 0;
	inquote = '\0';
	for (p = str, start = t = *buffer;; ++p) {
		switch (ch = *p) {
		case '"':
		case '\'':
			if (inquote) {
				if (inquote == ch)
					inquote = '\0';
				else
					break;
			} else {
				inquote = ch;
				/* Don't miss "" or '' */
				if (start == NULL && p[1] == inquote) {
					start = t + 1;
					break;
				}
			}
			continue;
		case ' ':
		case '\t':
		case '\n':
			if (inquote)
				break;
			if (!start)
				continue;
			/* FALLTHROUGH */
		case '\0':
			/*
			 * end of a token -- make sure there's enough argv
			 * space and save off a pointer.
			 */
			if (!start)
				goto done;

			*t++ = '\0';
			if (argc == argmax) {
				argmax *= 2;	/* ramp up fast */
				argv = ereallocarray(argv,
				    (argmax + 1), sizeof(char *));
			}
			argv[argc++] = start;
			start = NULL;
			if (ch == '\n' || ch == '\0')
				goto done;
			continue;
		case '\\':
			switch (ch = *++p) {
			case '\0':
			case '\n':
				/* hmmm; fix it up as best we can */
				ch = '\\';
				--p;
				break;
			case 'b':
				ch = '\b';
				break;
			case 'f':
				ch = '\f';
				break;
			case 'n':
				ch = '\n';
				break;
			case 'r':
				ch = '\r';
				break;
			case 't':
				ch = '\t';
				break;
			}
			    break;
		}
		if (!start)
			start = t;
		*t++ = ch;
	}
    done:
	    argv[argc] = NULL;
	    *store_argc = argc;
	    return argv;
}


const char *
iterate_words(const char **end)
{
	const char	*start, *p;
	char	state = 0;
	start = *end;

	while (ISSPACE(*start))
		start++;
	if (*start == '\0')
		return NULL;

	for (p = start;; p++)
	    switch(*p) {
	    case '\\':
		    if (p[1] != '\0')
			    p++;
		    break;
	    case '\'':
	    case '"':
		    if (state == *p)
			    state = 0;
		    else if (state == 0)
			    state = *p;
		    break;
	    case ' ':
	    case '\t':
		    if (state != 0)
			    break;
		    /* FALLTHROUGH */
	    case '\0':
		    *end = p;
		    return start;
	    default:
		    break;
	    }
}

static bool
star_match(const char *string, const char *estring,
    const char *pattern, const char *epattern)
{
	/* '*' matches any substring.  We handle this by calling ourselves
	 * recursively for each postfix of string, until either we match or
	 * we reach the end of the string.  */
	pattern++;
	/* Skip over contiguous  sequences of `?*', so that
	 * recursive calls only occur on `real' characters.  */
	while (pattern != epattern &&
		(*pattern == '?' || *pattern == '*')) {
		if (*pattern == '?') {
			if (string == estring)
				return false;
			else
				string++;
		}
		pattern++;
	}
	if (pattern == epattern)
		return true;
	for (; string != estring; string++)
		if (Str_Matchi(string, estring, pattern,
		    epattern))
			return true;
	return false;
}

static bool
range_match(char c, const char **ppat, const char *epattern)
{
	if (*ppat == epattern) {
		if (c == '[')
			return true;
		else
			return false;
	}
	if (**ppat == '!' || **ppat == '^') {
		(*ppat)++;
		return !range_match(c, ppat, epattern);
	}
	for (;;) {
		if (**ppat == '\\') {
			if (++(*ppat) == epattern)
				return false;
		}
		if (**ppat == c)
			break;
		if ((*ppat)[1] == '-') {
			if (*ppat + 2 == epattern)
				return false;
			if (**ppat < c && c <= (*ppat)[2])
				break;
			if ((*ppat)[2] <= c && c < **ppat)
				break;
			*ppat += 3;
		} else
			(*ppat)++;
		/* The test for ']' is done at the end
		 * so that ']' can be used at the
		 * start of the range without '\' */
		if (*ppat == epattern || **ppat == ']')
			return false;
	}
	/* Found matching character, skip over rest
	 * of class.  */
	while (**ppat != ']') {
		if (**ppat == '\\')
			(*ppat)++;
		/* A non-terminated character class
		 * is ok. */
		if (*ppat == epattern)
			break;
		(*ppat)++;
	}
	return true;
}

bool
Str_Matchi(const char *string, const char *estring,
    const char *pattern, const char *epattern)
{
	while (pattern != epattern) {
		/* Check for a "*" as the next pattern character.  */
		if (*pattern == '*')
			return star_match(string, estring, pattern, epattern);
		else if (string == estring)
			return false;
		/* Check for a "[" as the next pattern character.  It is
		 * followed by a list of characters that are acceptable, or
		 * by a range (two characters separated by "-").  */
		else if (*pattern == '[') {
			pattern++;
			if (!range_match(*string, &pattern, epattern))
				return false;

		}
		/* '?' matches any single character, so shunt test.  */
		else if (*pattern != '?') {
			/* If the next pattern character is '\', just strip
			 * off the '\' so we do exact matching on the
			 * character that follows.  */
			if (*pattern == '\\') {
				if (++pattern == epattern)
					return false;
			}
			/* There's no special character.  Just make sure that
			 * the next characters of each string match.  */
			if (*pattern != *string)
				return false;
		}
		pattern++;
		string++;
	}
	if (string == estring)
		return true;
	else
		return false;
}


/*-
 *-----------------------------------------------------------------------
 * Str_SYSVMatch --
 *	Check word against pattern for a match (% is wild),
 *
 * Results:
 *	Returns the beginning position of a match or null. The number
 *	of characters matched is returned in len.
 *-----------------------------------------------------------------------
 */
const char *
Str_SYSVMatch(const char *word, const char *pattern, size_t *len)
{
	const char *p = pattern;
	const char *w = word;
	const char *m;

	if (*p == '\0') {
		/* Null pattern is the whole string.  */
		*len = strlen(w);
		return w;
	}

	if ((m = strchr(p, '%')) != NULL) {
		/* Check that the prefix matches.  */
		for (; p != m && *w && *w == *p; w++, p++)
			 continue;

		if (p != m)
			return NULL;	/* No match.  */

		if (*++p == '\0') {
			/* No more pattern, return the rest of the string. */
			*len = strlen(w);
			return w;
		}
	}

	m = w;

	/* Find a matching tail.  */
	do {
		if (strcmp(p, w) == 0) {
			*len = w - m;
			return m;
		}
	} while (*w++ != '\0');

	return NULL;
}


/*-
 *-----------------------------------------------------------------------
 * Str_SYSVSubst --
 *	Substitute '%' in the pattern with len characters from src.
 *	If the pattern does not contain a '%' prepend len characters
 *	from src.
 *
 * Side Effects:
 *	Adds result to buf
 *-----------------------------------------------------------------------
 */
void
Str_SYSVSubst(Buffer buf, const char *pat, const char *src, size_t len)
{
	const char *m;

	if ((m = strchr(pat, '%')) != NULL) {
		/* Copy the prefix.  */
		Buf_Addi(buf, pat, m);
		/* Skip the %.	*/
		pat = m + 1;
	}

	/* Copy the pattern.  */
	Buf_AddChars(buf, len, src);

	/* Append the rest.  */
	Buf_AddString(buf, pat);
}

char *
Str_dupi(const char *begin, const char *end)
{
	char *s;

	s = emalloc(end - begin + 1);
	memcpy(s, begin, end - begin);
	s[end-begin] = '\0';
	return s;
}

char *
escape_dupi(const char *begin, const char *end, const char *set)
{
	char *s, *t;

	t = s = emalloc(end - begin + 1);
	while (begin != end) {
		if (*begin == '\\') {
			begin++;
			if (begin == end) {
				*t++ = '\\';
				break;
			}
			if (strchr(set, *begin) == NULL)
				*t++ = '\\';
		}
		*t++ = *begin++;
	}
	*t++ = '\0';
	return s;
}

char *
Str_rchri(const char *begin, const char *end, int c)
{
	if (begin != end)
		do {
			if (*--end == c)
				return (char *)end;
		} while (end != begin);
	return NULL;
}
@


1.30
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.29 2014/04/22 08:26:31 espie Exp $	*/
d100 1
a100 1
	char **argv = emalloc((argmax + 1) * sizeof(char *));
@


1.29
log
@effectively use emult_realloc, okay guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.28 2013/11/22 15:47:35 espie Exp $	*/
d153 1
a153 1
				argv = emult_realloc(argv,
@


1.28
log
@wrappers for is*/to* that make damn sure their arguments are
cast to unsigned chars.

okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.27 2010/07/19 19:46:44 espie Exp $	*/
d153 2
a154 2
				argv = erealloc(argv,
				    (argmax + 1) * sizeof(char *));
@


1.27
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.26 2010/07/19 19:30:37 espie Exp $	*/
d205 1
a205 1
	while (isspace(*start))
@


1.26
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$	*/
@


1.25
log
@zap more spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: str.c,v 1.24 2007/09/17 09:28:36 espie Exp $	*/
@


1.24
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: str.c,v 1.23 2007/09/16 15:24:53 espie Exp $	*/
d370 1
a370 1
Str_SYSVMatch(const char *word, const char *pattern, size_t *len)	
@


1.23
log
@finish reindenting str.c
@
text
@d2 1
a2 1
/*	$OpenBSD: str.c,v 1.21 2004/04/07 13:11:36 espie Exp $	*/
d52 1
a52 1
Str_concati(const char *s1, const char *e1, const char *s2, const char *e2, 
d154 1
a154 1
				argv = erealloc(argv, 
d238 1
a238 1
star_match(const char *string, const char *estring, 
d242 1
a242 1
	 * recursively for each postfix of string, until either we match or 
d245 1
a245 1
	/* Skip over contiguous  sequences of `?*', so that 
d247 1
a247 1
	while (pattern != epattern && 
d260 1
a260 1
		if (Str_Matchi(string, estring, pattern, 
d272 1
a272 1
		else 
d278 1
a278 1
	} 
d296 2
a297 2
		/* The test for ']' is done at the end 
		 * so that ']' can be used at the 
d302 1
a302 1
	/* Found matching character, skip over rest 
d307 1
a307 1
		/* A non-terminated character class 
d317 1
a317 1
Str_Matchi(const char *string, const char *estring, 
d337 2
a338 2
			/* If the next pattern character is '\', just strip 
			 * off the '\' so we do exact matching on the 
@


1.22
log
@remove some of the complexity of Str_Matchi by separating code into
range_match and star_match to handle special characters.

reindent.
@
text
@d55 2
a56 2
    size_t len1, len2;
    char *result;
d58 20
a77 20
    /* get the length of both strings */
    len1 = e1 - s1;
    len2 = e2 - s2;

    /* space for separator */
    if (sep)
	len1++;
    result = emalloc(len1 + len2 + 1);

    /* copy first string into place */
    memcpy(result, s1, len1);

    /* add separator character */
    if (sep)
	result[len1-1] = sep;

    /* copy second string plus EOS into place */
    memcpy(result + len1, s2, len2);
    result[len1+len2] = '\0';
    return result;
d93 12
a104 48
    int argc;
    char ch;
    char inquote;
    const char *p;
    char *start, *t;
    size_t len;
    int argmax = 50;
    size_t curlen = 0;
    char **argv = emalloc((argmax + 1) * sizeof(char *));

    /* skip leading space chars. */
    for (; *str == ' ' || *str == '\t'; ++str)
	continue;

    /* allocate room for a copy of the string */
    if ((len = strlen(str) + 1) > curlen)
	*buffer = emalloc(curlen = len);

    /*
     * copy the string; at the same time, parse backslashes,
     * quotes and build the argument list.
     */
    argc = 0;
    inquote = '\0';
    for (p = str, start = t = *buffer;; ++p) {
	switch (ch = *p) {
	case '"':
	case '\'':
	    if (inquote) {
		if (inquote == ch)
		    inquote = '\0';
		else
		    break;
	    } else {
		inquote = ch;
		/* Don't miss "" or '' */
		if (start == NULL && p[1] == inquote) {
		    start = t + 1;
		    break;
		}
	    }
	    continue;
	case ' ':
	case '\t':
	case '\n':
	    if (inquote)
		break;
	    if (!start)
d106 48
a153 12
	    /* FALLTHROUGH */
	case '\0':
	    /*
	     * end of a token -- make sure there's enough argv
	     * space and save off a pointer.
	     */
	    if (!start)
		goto done;

	    *t++ = '\0';
	    if (argc == argmax) {
		argmax *= 2;		/* ramp up fast */
d156 35
a190 31
	    }
	    argv[argc++] = start;
	    start = NULL;
	    if (ch == '\n' || ch == '\0')
		goto done;
	    continue;
	case '\\':
	    switch (ch = *++p) {
	    case '\0':
	    case '\n':
		/* hmmm; fix it up as best we can */
		ch = '\\';
		--p;
		break;
	    case 'b':
		ch = '\b';
		break;
	    case 'f':
		ch = '\f';
		break;
	    case 'n':
		ch = '\n';
		break;
	    case 'r':
		ch = '\r';
		break;
	    case 't':
		ch = '\t';
		break;
	    }
		break;
a191 4
	if (!start)
	    start = t;
	*t++ = ch;
    }
d193 3
a195 3
    argv[argc] = NULL;
    *store_argc = argc;
    return argv;
d202 8
a209 8
    const char	*start, *p;
    char	state = 0;
    start = *end;

    while (isspace(*start))
	start++;
    if (*start == '\0')
	return NULL;
d211 2
a212 2
    for (p = start;; p++)
	switch(*p) {
d214 3
a216 3
		if (p[1] != '\0')
		    p++;
		break;
d219 5
a223 5
		if (state == *p)
		    state = 0;
		else if (state == 0)
		    state = *p;
		break;
d226 3
a228 3
		if (state != 0)
		    break;
		/* FALLTHROUGH */
d230 2
a231 2
		*end = p;
		return start;
d233 1
a233 1
		break;
d244 1
a244 1
	    pattern++;
d247 2
a248 2
	    while (pattern != epattern && 
	    	(*pattern == '?' || *pattern == '*')) {
d250 4
a253 4
		    if (string == estring)
			return false;
		    else
			string++;
d256 2
a257 2
	    }
	    if (pattern == epattern)
d259 1
a259 1
	    for (; string != estring; string++)
d262 2
a263 2
		    return true;
	    return false;
d273 2
a274 2
			    return false;
		    }
d278 2
a279 2
		}
		for (;;) {
d282 2
a283 2
			    return false;
		    }
d288 1
a288 1
			    return false;
d290 1
a290 1
			    break;
d292 1
a292 1
			    break;
d294 1
a294 1
		    } else
d301 1
a301 1
		}
d312 1
a312 1
	    }
d334 3
a336 3
	}
	/* '?' matches any single character, so shunt test.  */
	else if (*pattern != '?') {
d340 15
a354 7
	    if (*pattern == '\\') {
		if (++pattern == epattern)
		    return false;
	    }
	    /* There's no special character.  Just make sure that
	     * the next characters of each string match.  */
	    if (*pattern != *string)
a355 8
	}
	pattern++;
	string++;
    }
    if (string == estring)
	return true;
    else
	return false;
d372 23
a394 22
    const char *p = pattern;
    const char *w = word;
    const char *m;

    if (*p == '\0') {
	/* Null pattern is the whole string.  */
	*len = strlen(w);
	return w;
    }

    if ((m = strchr(p, '%')) != NULL) {
	/* Check that the prefix matches.  */
	for (; p != m && *w && *w == *p; w++, p++)
	     continue;

	if (p != m)
	    return NULL;	/* No match.  */

	if (*++p == '\0') {
	    /* No more pattern, return the rest of the string.	*/
	    *len = strlen(w);
	    return w;
a395 1
    }
d397 1
a397 1
    m = w;
d399 7
a405 7
    /* Find a matching tail.  */
    do {
	if (strcmp(p, w) == 0) {
	    *len = w - m;
	    return m;
	}
    } while (*w++ != '\0');
d407 1
a407 1
    return NULL;
d425 1
a425 1
    const char *m;
d427 6
a432 6
    if ((m = strchr(pat, '%')) != NULL) {
	/* Copy the prefix.  */
	Buf_Addi(buf, pat, m);
	/* Skip the %.	*/
	pat = m + 1;
    }
d434 2
a435 2
    /* Copy the pattern.  */
    Buf_AddChars(buf, len, src);
d437 2
a438 2
    /* Append the rest.  */
    Buf_AddString(buf, pat);
d444 1
a444 1
    char *s;
d446 4
a449 4
    s = emalloc(end - begin + 1);
    memcpy(s, begin, end - begin);
    s[end-begin] = '\0';
    return s;
d455 1
a455 1
    char *s, *t;
d457 12
a468 10
    t = s = emalloc(end - begin + 1);
    while (begin != end) {
	if (*begin == '\\') {
	    begin++;
	    if (begin == end) {
		*t++ = '\\';
		break;
	    }
	    if (strchr(set, *begin) == NULL)
		*t++ = '\\';
d470 2
a471 4
	*t++ = *begin++;
    }
    *t++ = '\0';
    return s;
d477 6
a482 6
    if (begin != end)
	do {
	    if (*--end == c)
		return (char *)end;
	} while (end != begin);
    return NULL;
@


1.21
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: str.c,v 1.20 2003/06/03 02:56:12 millert Exp $	*/
d47 4
d154 2
a155 1
		argv = erealloc(argv, (argmax + 1) * sizeof(char *));
d192 1
a192 1
done:
d237 2
a238 2
bool
Str_Matchi(const char *string, const char *estring, 
d241 3
a243 6
    while (pattern != epattern) {
	/* Check for a "*" as the next pattern character.  It matches
	 * any substring.  We handle this by calling ourselves
	 * recursively for each postfix of string, until either we
	 * match or we reach the end of the string.  */
	if (*pattern == '*') {
d245 2
a246 2
	    /* Skip over contiguous  sequences of `?*', so that recursive
	     * calls only occur on `real' characters.  */
d260 2
a261 1
		if (Str_Matchi(string, estring, pattern, epattern))
d264 9
a272 17
	} else if (string == estring)
	    return false;
	/* Check for a "[" as the next pattern character.  It is
	 * followed by a list of characters that are acceptable, or
	 * by a range (two characters separated by "-").  */
	else if (*pattern == '[') {
	    pattern++;
	    if (pattern == epattern)
		return false;
	    if (*pattern == '!' || *pattern == '^') {
		pattern++;
		if (pattern == epattern)
			return false;
		/* Negative match */
		for (;;) {
		    if (*pattern == '\\') {
			if (++pattern == epattern)
d275 3
a277 18
		    if (*pattern == *string)
			return false;
		    if (pattern[1] == '-') {
			if (pattern + 2 == epattern)
			    return false;
			if (*pattern < *string && *string <= pattern[2])
			    return false;
			if (pattern[2] <= *string && *string < *pattern)
			    return false;
			pattern += 3;
		    } else
			pattern++;
		    if (pattern == epattern)
			return false;
		    /* The test for ']' is done at the end so that ']'
		     * can be used at the start of the range without '\' */
		    if (*pattern == ']')
			break;
a278 1
	    } else {
d280 2
a281 2
		    if (*pattern == '\\') {
			if (++pattern == epattern)
d284 1
a284 1
		    if (*pattern == *string)
d286 2
a287 2
		    if (pattern[1] == '-') {
			if (pattern + 2 == epattern)
d289 1
a289 1
			if (*pattern < *string && *string <= pattern[2])
d291 1
a291 1
			if (pattern[2] <= *string && *string < *pattern)
d293 1
a293 1
			pattern += 3;
d295 5
a299 4
			pattern++;
		    /* The test for ']' is done at the end so that ']'
		     * can be used at the start of the range without '\' */
		    if (pattern == epattern || *pattern == ']')
d302 8
a309 6
		/* Found matching character, skip over rest of class.  */
		while (*pattern != ']') {
		    if (*pattern == '\\')
			pattern++;
		    /* A non-terminated character class is ok.	*/
		    if (pattern == epattern)
d311 1
a311 2
		    pattern++;
		}
d313 21
d337 3
a339 2
	    /* If the next pattern character is '\', just strip off the
	     * '\' so we do exact matching on the character that follows.  */
a405 1

@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: str.c,v 1.19 2001/05/23 12:34:49 espie Exp $	*/
d48 2
a49 3
Str_concati(s1, e1, s2, e2, sep)
    const char *s1, *e1, *s2, *e2;
    int sep;
d87 1
a87 4
brk_string(str, store_argc, buffer)
    const char *str;
    int *store_argc;
    char **buffer;
d195 1
a195 2
iterate_words(end)
    const char	**end;
d233 2
a234 5
Str_Matchi(string, estring, pattern, end)
    const char *string; 		/* String */
    const char *estring;		/* End of string */
    const char *pattern;		/* Pattern */
    const char *end;			/* End of Pattern */
d236 1
a236 1
    while (pattern != end) {
d245 2
a246 1
	    while (pattern != end && (*pattern == '?' || *pattern == '*')) {
d255 1
a255 1
	    if (pattern == end)
d258 1
a258 1
		if (Str_Matchi(string, estring, pattern, end))
d268 1
a268 1
	    if (pattern == end)
d272 1
a272 1
		if (pattern == end)
d277 1
a277 1
			if (++pattern == end)
d283 1
a283 1
			if (pattern + 2 == end)
d292 1
a292 1
		    if (pattern == end)
d302 1
a302 1
			if (++pattern == end)
d308 1
a308 1
			if (pattern + 2 == end)
d319 1
a319 1
		    if (pattern == end || *pattern == ']')
d327 1
a327 1
		    if (pattern == end)
d338 1
a338 1
		if (++pattern == end)
d367 1
a367 4
Str_SYSVMatch(word, pattern, len)
    const char	*word;		/* Word to examine */
    const char	*pattern;	/* Pattern to examine against */
    size_t	*len;		/* Number of characters to substitute */
d412 1
a412 1
 *	Substitute '%' on the pattern with len characters from src.
d417 1
a417 1
 *	Places result on buf
d421 1
a421 5
Str_SYSVSubst(buf, pat, src, len)
    Buffer buf;
    const char *pat;
    const char *src;
    size_t   len;
d440 1
a440 3
Str_dupi(begin, end)
    const char *begin;
    const char *end;
d451 1
a451 4
escape_dupi(begin, end, set)
    const char *begin;
    const char *end;
    const char *set;
d473 1
a473 4
Str_rchri(s, e, c)
    const char *s;
    const char *e;
    int c;
d475 1
a475 1
    if (s != e)
d477 3
a479 3
	    if (*--e == c)
		return (char *)e;
	} while (e != s);
@


1.19
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: str.c,v 1.18 2001/05/07 22:54:53 espie Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.18
log
@Even though str_concati is supposed to handle intervals, it was still
assuming '\0' at the end.

-> importance of proper make bug reports, this was first diagnosed as
a for loop issue...
@
text
@d2 1
a2 1
/*	$OpenBSD: str.c,v 1.17 2001/05/03 13:41:11 espie Exp $	*/
d43 7
a49 1
#include "make.h"
a50 16
#ifndef lint
#if 0
static char	sccsid[] = "@@(#)str.c	5.8 (Berkeley) 6/1/90";
#else
UNUSED
static char rcsid[] = "$OpenBSD: str.c,v 1.17 2001/05/03 13:41:11 espie Exp $";
#endif
#endif				/* not lint */

/*-
 * str_concati --
 *	concatenate the two strings, possibly inserting a separator
 *
 * returns --
 *	the resulting string in allocated space.
 */
d52 2
a53 2
str_concati(s1, s2, e2, sep)
    const char *s1, *s2, *e2;
d60 1
a60 1
    len1 = strlen(s1);
d201 1
a201 9
/* Iterate through a string word by word,
 * without needing to copy anything.
 * More light-weight than brk_string, handles \ ' " as well.
 *
 * position = s;
 * while ((begin = iterate_words(&position)) != NULL) {
 *   do_something_with_word_interval(begin, position);
 * }
 */
d241 2
a242 11
/*
 * Str_Matchi --
 *
 * See if a particular string matches a particular pattern.
 *
 * Results: TRUE is returned if string matches pattern, FALSE otherwise. The
 * matching operation permits the following special characters in the
 * pattern: *?\[] (see the man page for details on what these mean).
 */
Boolean
Str_Matchi(string, pattern, end)
d244 1
d259 2
a260 2
		    if (*string == '\0')
			return FALSE;
d267 7
a273 7
		return TRUE;
	    for (; *string != '\0'; string++)
		if (Str_Matchi(string, pattern, end))
		    return TRUE;
	    return FALSE;
	} else if (*string == '\0')
	    return FALSE;
d280 1
a280 1
		return FALSE;
d284 1
a284 1
			return FALSE;
d289 1
a289 1
			    return FALSE;
d292 1
a292 1
			return FALSE;
d295 1
a295 1
			    return FALSE;
d297 1
a297 1
			    return FALSE;
d299 1
a299 1
			    return FALSE;
d304 1
a304 1
			return FALSE;
d314 1
a314 1
			    return FALSE;
d320 1
a320 1
			    return FALSE;
d331 1
a331 1
			return FALSE;
d350 1
a350 1
		    return FALSE;
d355 1
a355 1
		return FALSE;
d360 2
a361 2
    if (*string == '\0')
	return TRUE;
d363 1
a363 1
	return FALSE;
d445 1
a445 1
	Buf_AddInterval(buf, pat, m);
d458 1
a458 1
interval_dup(begin, end)
a469 1
/* copy interval, skipping characters in the set.  */
d471 1
a471 1
escape_dup(begin, end, set)
d496 1
a496 1
lastchar(s, e, c)
@


1.17
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d2 1
a2 1
/*	$OpenBSD: str.c,v 1.7 1998/12/05 00:06:29 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: str.c,v 1.7 1998/12/05 00:06:29 espie Exp $";
d86 2
a87 1
    memcpy(result + len1, s2, len2 + 1);
@


1.16
log
@Two new functions:

iterate_words: light-weight equivalent to brk_string,
which does not need to copy the string, and does not do \ interpretation
which are only needed for the string.

escape_dup: handles escape sequence in a systematic way.

This speeds up variable modifiers.

This also makes .for loops more consistent, as they use the same definition
of `a word' as the rest of make.
@
text
@d1 2
a2 1
/*	$OpenBSD: str.c,v 1.15 2000/09/14 13:32:07 espie Exp $	*/
d47 1
a47 1
static char     sccsid[] = "@@(#)str.c	5.8 (Berkeley) 6/1/90";
d50 1
a50 1
static char rcsid[] = "$OpenBSD: str.c,v 1.15 2000/09/14 13:32:07 espie Exp $";
d55 1
a55 1
 * str_concat --
d62 3
a64 3
str_concat(s1, s2, sep)
    const char *s1, *s2;
    char sep;
d71 1
a71 1
    len2 = strlen(s2);
d82 1
a82 1
    if (sep) 
d97 1
a97 1
 *	Pointer to the array of pointers to the words.  To make life easier,
d101 4
a104 5
brk_string(str, store_argc, expand, buffer)
	const char *str;
	int *store_argc;
	Boolean expand;
	char **buffer;
d106 48
a153 11
	register int argc, ch;
	char inquote;
	const char *p;
	char *start, *t;
	size_t len;
	int argmax = 50;
	size_t curlen = 0;
    	char **argv = (char **)emalloc((argmax + 1) * sizeof(char *));

	/* skip leading space chars. */
	for (; *str == ' ' || *str == '\t'; ++str)
d155 44
a198 98

	/* allocate room for a copy of the string */
	if ((len = strlen(str) + 1) > curlen)
		*buffer = emalloc(curlen = len);

	/*
	 * copy the string; at the same time, parse backslashes,
	 * quotes and build the argument list.
	 */
	argc = 0;
	inquote = '\0';
	for (p = str, start = t = *buffer;; ++p) {
		switch(ch = *p) {
		case '"':
		case '\'':
			if (inquote) {
				if (inquote == ch)
					inquote = '\0';
				else
					break;
			} else {
				inquote = (char) ch;
				/* Don't miss "" or '' */
				if (start == NULL && p[1] == inquote) {
					start = t + 1;
					break;
				}
			}
			if (!expand) {
				if (!start)
					start = t;
				*t++ = ch;
			}
			continue;
		case ' ':
		case '\t':
		case '\n':
			if (inquote)
				break;
			if (!start)
				continue;
			/* FALLTHROUGH */
		case '\0':
			/*
			 * end of a token -- make sure there's enough argv
			 * space and save off a pointer.
			 */
			if (!start)
			    goto done;

			*t++ = '\0';
			if (argc == argmax) {
				argmax *= 2;		/* ramp up fast */
				argv = (char **)erealloc(argv,
				    (argmax + 1) * sizeof(char *));
			}
			argv[argc++] = start;
			start = (char *)NULL;
			if (ch == '\n' || ch == '\0')
				goto done;
			continue;
		case '\\':
			if (!expand) {
				if (!start)
					start = t;
				*t++ = '\\';
				ch = *++p;
				break;
			}

			switch (ch = *++p) {
			case '\0':
			case '\n':
				/* hmmm; fix it up as best we can */
				ch = '\\';
				--p;
				break;
			case 'b':
				ch = '\b';
				break;
			case 'f':
				ch = '\f';
				break;
			case 'n':
				ch = '\n';
				break;
			case 'r':
				ch = '\r';
				break;
			case 't':
				ch = '\t';
				break;
			}
			break;
		}
		if (!start)
			start = t;
		*t++ = (char) ch;
d200 8
a207 3
done:	argv[argc] = (char *)NULL;
	*store_argc = argc;
	return(argv);
d221 1
a221 1
    const char 	**end;
d223 1
a223 1
    const char 	*start, *p;
d228 1
a228 1
    	start++;
d230 1
a230 1
    	return NULL;
d233 1
a233 1
    	switch(*p) {
d235 1
a235 1
	    	if (p[1] != '\0')
d240 1
a240 1
	    	if (state == *p)
d247 1
a247 1
	    	if (state != 0)
d249 1
a249 1
	    	/* FALLTHROUGH */
d251 1
a251 1
	    	*end = p;
d254 1
a254 1
	    	break;
d257 1
a257 1
	
d259 1
a259 1
 * Str_Match --
d268 2
a269 2
Str_Match(string, pattern)
    const char *string;			/* String */
d271 1
d273 1
a273 1
    while (*pattern != '\0') {
d282 1
a282 1
	    while (*pattern == '?' || *pattern == '*') {
d291 1
a291 1
	    if (*pattern == '\0')
d294 1
a294 1
		if (Str_Match(string, pattern))
d297 1
a297 1
	} else if (*string == '\0') 
d304 2
a305 2
	    if (*pattern == '\0')
	    	return FALSE;
d308 1
a308 1
		if (*pattern == '\0')
d313 1
a313 1
			if (*++pattern == '\0')
d319 1
a319 1
			if (pattern[2] == '\0')
d328 2
a329 2
		    if (*pattern == '\0')
		    	return FALSE;
d333 1
a333 1
		    	break;
d338 1
a338 1
			if (*++pattern == '\0')
d344 1
a344 1
			if (pattern[2] == '\0')
d355 2
a356 2
		    if (*pattern == '\0' || *pattern == ']')
		    	return FALSE;
d362 2
a363 2
		    /* A non-terminated character class is ok.  */
		    if (*pattern == '\0')
d374 1
a374 1
		if (*++pattern == '\0')
d377 1
a377 1
	    /* There's no special character.  Just make sure that 
d391 1
d413 1
a413 1
	/* Null pattern is the whole string */
d419 1
a419 1
	/* check that the prefix matches */
d424 1
a424 1
	    return NULL;	/* No match */
d427 1
a427 1
	    /* No more pattern, return the rest of the string */
d435 2
a436 2
    /* Find a matching tail */
    do
d441 2
a442 1
    while (*w++ != '\0');
d469 1
a469 1
	/* Copy the prefix */
d471 1
a471 1
	/* skip the % */
d475 1
a475 1
    /* Copy the pattern */
d478 1
a478 1
    /* append the rest */
d506 1
a506 1
    	if (*begin == '\\') {
d509 1
a509 1
	    	*t++ = '\\';
d512 2
a513 2
	    if (strchr(set, *begin) == NULL) 
	    	*t++ = '\\';
d521 13
@


1.15
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.14 2000/07/17 23:01:20 espie Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: str.c,v 1.14 2000/07/17 23:01:20 espie Exp $";
d222 48
d503 27
@


1.14
log
@This does replace Str_Match with a better routine, which handles negated
intervals, and \\ in intervals.

Accordingly, var.c no longer needs to copy the :Marg to replace \: with :

We don't use fnmatch(3) because of various optimizations which are harder
to achieve in a generic setting.

Also add regression suite for the Str_Match function.
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.13 2000/07/17 22:57:37 espie Exp $	*/
d42 2
d48 2
a49 1
static char rcsid[] = "$OpenBSD: str.c,v 1.13 2000/07/17 22:57:37 espie Exp $";
a51 2

#include "make.h"
@


1.13
log
@Constify a few functions, propagated from VarModify.
Replace a few int -> size_t

Reviewed by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.12 2000/06/23 16:41:53 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: str.c,v 1.12 2000/06/23 16:41:53 espie Exp $";
d226 1
a226 1
 * Results: Non-zero is returned if string matches pattern, 0 otherwise. The
a228 2
 *
 * Side effects: None.
d230 1
a230 1
int
d232 2
a233 2
	const char *string;		/* String */
	const char *pattern;		/* Pattern */
d235 61
a295 28
	char c2;

	for (;;) {
		/*
		 * See if we're at the end of both the pattern and the
		 * string. If, we succeeded.  If we're at the end of the
		 * pattern but not at the end of the string, we failed.
		 */
		if (*pattern == 0)
			return(!*string);
		if (*string == 0 && *pattern != '*')
			return(0);
		/*
		 * Check for a "*" as the next pattern character.  It matches
		 * any substring.  We handle this by calling ourselves
		 * recursively for each postfix of string, until either we
		 * match or we reach the end of the string.
		 */
		if (*pattern == '*') {
			pattern += 1;
			if (*pattern == 0)
				return(1);
			while (*string != 0) {
				if (Str_Match(string, pattern))
					return(1);
				++string;
			}
			return(0);
d297 22
a318 35
		/*
		 * Check for a "?" as the next pattern character.  It matches
		 * any single character.
		 */
		if (*pattern == '?')
			goto thisCharOK;
		/*
		 * Check for a "[" as the next pattern character.  It is
		 * followed by a list of characters that are acceptable, or
		 * by a range (two characters separated by "-").
		 */
		if (*pattern == '[') {
			++pattern;
			for (;;) {
				if ((*pattern == ']') || (*pattern == 0))
					return(0);
				if (*pattern == *string)
					break;
				if (pattern[1] == '-') {
					c2 = pattern[2];
					if (c2 == 0)
						return(0);
					if ((*pattern <= *string) &&
					    (c2 >= *string))
						break;
					if ((*pattern >= *string) &&
					    (c2 <= *string))
						break;
					pattern += 2;
				}
				++pattern;
			}
			while ((*pattern != ']') && (*pattern != 0))
				++pattern;
			goto thisCharOK;
d320 8
a327 8
		/*
		 * If the next pattern character is '/', just strip off the
		 * '/' so we do exact matching on the character that follows.
		 */
		if (*pattern == '\\') {
			++pattern;
			if (*pattern == 0)
				return(0);
d329 1
a329 8
		/*
		 * There's no special character.  Just make sure that the
		 * next characters of each string match.
		 */
		if (*pattern != *string)
			return(0);
thisCharOK:	++pattern;
		++string;
d331 20
a351 1

@


1.12
log
@This patch replaces str_concat with a slightly unobfuscated version.

In particular, Dir_MakeFlags is abusing str_concat, and works much better
with buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.11 1999/12/09 18:18:24 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: str.c,v 1.11 1999/12/09 18:18:24 espie Exp $";
d100 1
a100 1
	register char *str;
d106 6
a111 3
	register char inquote, *p, *start, *t;
	int len;
	int argmax = 50, curlen = 0;
d234 2
a235 2
	register char *string;		/* String */
	register char *pattern;		/* Pattern */
a330 4
 *
 * Side Effects:
 *	None
 *
d333 1
a333 1
char *
d335 3
a337 3
    char	*word;		/* Word to examine */
    char	*pattern;	/* Pattern to examine against */
    int		*len;		/* Number of characters to substitute */
d339 3
a341 3
    char *p = pattern;
    char *w = word;
    char *m;
a384 3
 * Results:
 *	None
 *
a386 1
 *
d392 3
a394 3
    char *pat;
    char *src;
    int   len;
d396 1
a396 1
    char *m;
@


1.11
log
@Introduce `common usage' buf patterns and use them.
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.10 1999/12/06 22:24:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: str.c,v 1.10 1999/12/06 22:24:32 espie Exp $";
d54 1
a54 2
 *	concatenate the two strings, inserting a space or slash between them,
 *	freeing them if requested.
d60 3
a62 3
str_concat(s1, s2, flags)
	char *s1, *s2;
	int flags;
d64 2
a65 2
	register int len1, len2;
	register char *result;
d67 19
a85 28
	/* get the length of both strings */
	len1 = strlen(s1);
	len2 = strlen(s2);

	/* allocate length plus separator plus EOS */
	result = emalloc((u_int)(len1 + len2 + 2));

	/* copy first string into place */
	memcpy(result, s1, len1);

	/* add separator character */
	if (flags & STR_ADDSPACE) {
		result[len1] = ' ';
		++len1;
	} else if (flags & STR_ADDSLASH) {
		result[len1] = '/';
		++len1;
	}

	/* copy second string plus EOS into place */
	memcpy(result + len1, s2, len2 + 1);

	/* free original strings */
	if (flags & STR_DOFREE) {
		(void)free(s1);
		(void)free(s2);
	}
	return(result);
@


1.10
log
@Clean up buffers interface somewhat:

- buf.c deals exclusively with chars. Be explicit about it, and remove
extraneous dumb casts to char (can hide real type errors).
- buffer sizes are size_t. Note that bp->left can never become NULL.
- Buf_GetAll is happy with a NULL pointer for the size, remove unneeded
extra pointers.
- Propagate size_t to all places where buffer functions are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.9 1999/12/06 22:18:56 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: str.c,v 1.9 1999/12/06 22:18:56 espie Exp $";
d415 1
a415 1
	Buf_AddChars(buf, m - pat, pat);
d424 1
a424 1
    Buf_AddChars(buf, strlen(pat), pat);
@


1.9
log
@- introduce interval_dup in str.c
- use it to replace .for parsing with something approaching sanity.
(this removes one of the few most blatant misuses of Bufs in make.

More changes to come... patch reviewed by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.8 1999/11/11 11:35:17 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: str.c,v 1.8 1999/11/11 11:35:17 espie Exp $";
d415 1
a415 1
	Buf_AddBytes(buf, m - pat, (Byte *) pat);
d421 1
a421 1
    Buf_AddBytes(buf, len, (Byte *) src);
d424 1
a424 1
    Buf_AddBytes(buf, strlen(pat), (Byte *) pat);
@


1.8
log
@Kill Str_FindSubString, it's strstr.
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.7 1998/12/05 00:06:29 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: str.c,v 1.7 1998/12/05 00:06:29 espie Exp $";
d425 13
@


1.7
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.5 1996/11/30 21:09:04 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: str.c,v 1.5 1996/11/30 21:09:04 millert Exp $";
a225 38
}

/*
 * Str_FindSubstring -- See if a string contains a particular substring.
 *
 * Results: If string contains substring, the return value is the location of
 * the first matching instance of substring in string.  If string doesn't
 * contain substring, the return value is NULL.  Matching is done on an exact
 * character-for-character basis with no wildcards or special characters.
 *
 * Side effects: None.
 */
char *
Str_FindSubstring(string, substring)
	register char *string;		/* String to search. */
	char *substring;		/* Substring to find in string */
{
	register char *a, *b;

	/*
	 * First scan quickly through the two strings looking for a single-
	 * character match.  When it's found, then compare the rest of the
	 * substring.
	 */

	for (b = substring; *string != 0; string += 1) {
		if (*string != *b)
			continue;
		a = string;
		for (;;) {
			if (*b == 0)
				return(string);
			if (*a++ != *b++)
				break;
		}
		b = substring;
	}
	return((char *) NULL);
@


1.6
log
@make gcc 2.8 happy
@
text
@a51 34
static char **argv, *buffer;
static int argmax, curlen;

/*
 * str_init --
 *	Initialize the strings package
 *
 */
void
str_init()
{
    char *p1;
    argv = (char **)emalloc(((argmax = 50) + 1) * sizeof(char *));
    argv[0] = Var_Value(".MAKE", VAR_GLOBAL, &p1);
}


/*
 * str_end --
 *	Cleanup the strings package
 *
 */
void
str_end()
{
    if (argv) {
	if (argv[0])
	    free(argv[0]);
	free((Address) argv);
    }
    if (buffer)
	free(buffer);
}

d109 1
a109 1
brk_string(str, store_argc, expand)
d113 1
d118 2
d126 2
a127 5
	if ((len = strlen(str) + 1) > curlen) {
		if (buffer)
		    free(buffer);
		buffer = emalloc(curlen = len);
	}
d133 1
a133 1
	argc = 1;
d135 1
a135 1
	for (p = str, start = t = buffer;; ++p) {
@


1.5
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: str.c,v 1.4 1996/06/26 05:36:37 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: str.c,v 1.4 1996/06/26 05:36:37 deraadt Exp $";
d173 1
a173 1
			if (inquote)
d178 1
a178 1
			else {
@


1.4
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: str.c,v 1.12 1996/03/29 02:17:34 jtc Exp $	*/
/*	$NetBSD: str.c,v 1.12 1996/03/29 02:17:34 jtc Exp $	*/
d5 2
a6 2
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
d46 1
a46 1
static char rcsid[] = "$OpenBSD: str.c,v 1.12 1996/03/29 02:17:34 jtc Exp $";
d77 3
a79 2
    if (argv[0]) {
	free(argv[0]);
d227 1
a227 1
				
d264 1
a264 1
 * 
d269 1
a269 1
 * 
d302 1
a302 1
 * 
d304 1
a304 1
 * 
d308 1
a308 1
 * 
d405 2
a406 2
 *	Check word against pattern for a match (% is wild), 
 *	
d456 1
a456 1
	    
d467 1
a467 1
 *	
@


1.3
log
@sync to netbsd 960418
@
text
@d1 1
d46 1
a46 1
static char rcsid[] = "$NetBSD: str.c,v 1.12 1996/03/29 02:17:34 jtc Exp $";
@


1.2
log
@Always ensure space for trailing NULL in argv
@
text
@d1 1
a1 1
/*	$NetBSD: str.c,v 1.10.2.1 1995/10/30 22:55:14 jtc Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: str.c,v 1.10.2.1 1995/10/30 22:55:14 jtc Exp $";
d209 2
a210 3
				if (!(argv = (char **)realloc(argv,
				    (argmax + 1) * sizeof(char *))))
				enomem();
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: str.c,v 1.10 1995/06/14 15:19:56 christos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: str.c,v 1.10 1995/06/14 15:19:56 christos Exp $";
d63 1
a63 1
    argv = (char **)emalloc((argmax = 50) * sizeof(char *));
d210 1
a210 1
				    argmax * sizeof(char *))))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

