head	1.73;
access;
symbols
	OPENBSD_6_2:1.73.0.2
	OPENBSD_6_2_BASE:1.73
	OPENBSD_6_1:1.71.0.4
	OPENBSD_6_1_BASE:1.71
	OPENBSD_6_0:1.70.0.4
	OPENBSD_6_0_BASE:1.70
	OPENBSD_5_9:1.70.0.2
	OPENBSD_5_9_BASE:1.70
	OPENBSD_5_8:1.69.0.6
	OPENBSD_5_8_BASE:1.69
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.68.0.6
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.68.0.4
	OPENBSD_5_5_BASE:1.68
	OPENBSD_5_4:1.67.0.2
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.65.0.2
	OPENBSD_5_3_BASE:1.65
	OPENBSD_5_2:1.63.0.2
	OPENBSD_5_2_BASE:1.63
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.2
	OPENBSD_5_0:1.61.0.6
	OPENBSD_5_0_BASE:1.61
	OPENBSD_4_9:1.61.0.4
	OPENBSD_4_9_BASE:1.61
	OPENBSD_4_8:1.61.0.2
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.60.0.2
	OPENBSD_4_7_BASE:1.60
	OPENBSD_4_6:1.59.0.4
	OPENBSD_4_6_BASE:1.59
	OPENBSD_4_5:1.58.0.2
	OPENBSD_4_5_BASE:1.58
	OPENBSD_4_4:1.57.0.4
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.57.0.2
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.35.0.14
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.35.0.12
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.10
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.35.0.8
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.35.0.6
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.35.0.4
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.35.0.2
	OPENBSD_3_6_BASE:1.35
	OPENBSD_3_5:1.34.0.2
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	OPENBSD_3_3:1.32.0.6
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.32.0.4
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.32.0.2
	OPENBSD_3_1_BASE:1.32
	OPENBSD_3_0:1.27.0.2
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.73
date	2017.06.22.17.09.10;	author espie;	state Exp;
branches;
next	1.72;
commitid	D167jwLxvaxDsH0a;

1.72
date	2017.06.22.17.08.20;	author espie;	state Exp;
branches;
next	1.71;
commitid	m7jGakx58gVJKqZP;

1.71
date	2016.10.21.16.12.38;	author espie;	state Exp;
branches;
next	1.70;
commitid	aLVdeKrJ0t5upS3l;

1.70
date	2015.08.21.02.19.49;	author jsg;	state Exp;
branches;
next	1.69;
commitid	3FM8i00XyBvkmr5M;

1.69
date	2015.01.23.13.18.40;	author espie;	state Exp;
branches;
next	1.68;
commitid	iXa5WmoY9RgeqDsn;

1.68
date	2014.01.06.12.21.45;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2013.05.22.12.14.08;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2013.04.23.14.32.53;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2012.12.08.12.54.17;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2012.10.09.19.49.28;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2012.04.21.04.35.32;	author guenther;	state Exp;
branches;
next	1.62;

1.62
date	2011.11.03.20.55.22;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2009.08.16.09.53.43;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2009.05.10.11.07.37;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2008.11.04.07.22.36;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2008.01.12.13.08.59;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2007.12.01.15.14.34;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.28.09.41.03;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.28.09.40.08;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2007.11.26.22.48.18;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.24.15.41.01;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2007.11.18.09.20.25;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.17.16.39.45;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.10.13.59.48;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.10.12.51.40;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.06.21.12.23;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2007.11.06.21.09.42;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.03.11.45.52;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.03.10.39.22;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.02.17.27.24;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.17.12.01.17;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.17.08.53.59;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.17.08.36.57;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.16.12.09.36;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.16.10.39.07;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.16.09.46.14;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.07.13.11.36;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.08.19.17.29;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.03.02.56.12;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.23.23.42.45;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.22.21.18.10;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.11.12.35.02;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.11.06.02.06;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.11.01.19.23;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.29.12.53.42;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.23.12.34.46;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.03.13.41.08;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.24.14.36.34;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2000.09.14.13.52.42;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.14.13.46.45;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.14.13.32.07;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.23.16.18.09;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.23.16.15.50;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.17.14.43.36;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.17.14.38.18;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.10.01.41.05;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.10.01.32.23;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.26.16.21.32;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.02.13.47.48;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	99.12.18.21.58.07;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.12.18.21.56.07;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.12.18.21.53.32;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	99.12.18.02.11.27;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	99.12.06.22.28.44;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	98.12.05.00.06.28;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	97.04.28.01.52.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.04.01.07.28.17;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.11.30.21.09.00;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.02.16.04.14;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.03.27.19.32.38;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.73
log
@zap trailing spaces from the previous commits and also other trailing
spaces
@
text
@/*	$OpenBSD: make.c,v 1.72 2017/06/22 17:08:20 espie Exp $	*/
/*	$NetBSD: make.c,v 1.10 1996/11/06 17:59:15 christos Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*-
 * make.c --
 *	The functions which perform the examination of targets and
 *	their suitability for creation
 *
 * Interface:
 *	Make_Run		Initialize things for the module and recreate
 *				whatever needs recreating. Returns true if
 *				work was (or would have been) done and
 *				false
 *				otherwise.
 *
 *	Make_Update		Update all parents of a given child. Performs
 *				various bookkeeping chores like finding the
 *				youngest child of the parent, filling
 *				the IMPSRC context variable, etc. It will
 *				place the parent on the toBeMade queue if it
 *				should be.
 *
 */

#include <limits.h>
#include <signal.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ohash.h>
#include "config.h"
#include "defines.h"
#include "dir.h"
#include "job.h"
#include "suff.h"
#include "var.h"
#include "error.h"
#include "make.h"
#include "gnode.h"
#include "extern.h"
#include "timestamp.h"
#include "engine.h"
#include "lst.h"
#include "targ.h"
#include "targequiv.h"
#include "garray.h"
#include "memory.h"

/* what gets added each time. Kept as one static array so that it doesn't
 * get resized every time.
 */
static struct growableArray examine;
/* The current fringe of the graph. These are nodes which await examination by
 * MakeOODate. It is added to by Make_Update and subtracted from by
 * MakeStartJobs */
static struct growableArray toBeMade;	

/* Hold back on nodes where equivalent stuff is already building... */
static struct growableArray heldBack;

static struct ohash targets;	/* stuff we must build */

static void MakeAddChild(void *, void *);
static void MakeHandleUse(void *, void *);
static bool MakeStartJobs(void);
static void MakePrintStatus(void *);

/* Cycle detection functions */
static bool targets_contain_cycles(void);
static void print_unlink_cycle(struct growableArray *, GNode *);
static void break_and_print_cycles(Lst);
static GNode *find_cycle(Lst, struct growableArray *);

static bool try_to_make_node(GNode *);
static void add_targets_to_make(Lst);

static bool has_unmade_predecessor(GNode *);
static void requeue_successors(GNode *);
static void random_setup(void);

static bool randomize_queue;
long random_delay = 0;

bool
no_jobs_left()
{
	return Array_IsEmpty(&toBeMade);
}

static void
random_setup()
{
	randomize_queue = Var_Definedi("RANDOM_ORDER", NULL);

/* no random delay in the new engine for now */
#if 0
	if (Var_Definedi("RANDOM_DELAY", NULL))
		random_delay = strtonum(Var_Value("RANDOM_DELAY"), 0, 1000,
		    NULL) * 1000000;
#endif

}

static void
randomize_garray(struct growableArray *g)
{
	/* This is a fairly standard algorithm to randomize an array. */
	unsigned int i, v;
	GNode *e;

	for (i = g->n; i > 0; i--) {
		v = arc4random_uniform(i);
		if (v == i-1)
			continue;
		else {
			e = g->a[i-1];
			g->a[i-1] = g->a[v];
			g->a[v] = e;
		}
	}
}

static bool
has_unmade_predecessor(GNode *gn)
{
	LstNode ln;

	if (Lst_IsEmpty(&gn->preds))
		return false;


	for (ln = Lst_First(&gn->preds); ln != NULL; ln = Lst_Adv(ln)) {
		GNode	*pgn = Lst_Datum(ln);

		if (pgn->must_make && pgn->built_status == UNKNOWN) {
			if (DEBUG(MAKE))
				printf("predecessor %s not made yet.\n",
				    pgn->name);
			return true;
		}
	}
	return false;
}

static void
requeue_successors(GNode *gn)
{
	LstNode ln;
	/* Deal with successor nodes. If any is marked for making and has an
	 * unmade count of 0, has not been made and isn't in the examination
	 * queue, it means we need to place it in the queue as it restrained
	 * itself before.	*/
	for (ln = Lst_First(&gn->successors); ln != NULL; ln = Lst_Adv(ln)) {
		GNode	*succ = Lst_Datum(ln);

		if (succ->must_make && succ->unmade == 0
		    && succ->built_status == UNKNOWN)
			Array_PushNew(&toBeMade, succ);
	}
}

static void
requeue(GNode *gn)
{
	/* this is where we go inside the array and move things around */
	unsigned int i, j;

	for (i = 0, j = 0; i < heldBack.n; i++, j++) {
		if (heldBack.a[i]->watched == gn) {
			j--;
			heldBack.a[i]->built_status = UNKNOWN;
			if (DEBUG(HELDJOBS))
				printf("%s finished, releasing: %s\n",
				    gn->name, heldBack.a[i]->name);
			Array_Push(&toBeMade, heldBack.a[i]);
			continue;
		}
		heldBack.a[j] = heldBack.a[i];
	}
	heldBack.n = j;
}

/*-
 *-----------------------------------------------------------------------
 * Make_Update	--
 *	Perform update on the parents of a node. Used by JobFinish once
 *	a node has been dealt with and by MakeStartJobs if it finds an
 *	up-to-date node.
 *
 * Results:
 *	Always returns 0
 *
 * Side Effects:
 *	The unmade field of pgn is decremented and pgn may be placed on
 *	the toBeMade queue if this field becomes 0.
 *
 *	If the child was made, the parent's childMade field will be set to
 *	true
 *-----------------------------------------------------------------------
 */
void
Make_Update(GNode *cgn)	/* the child node */
{
	GNode	*pgn;	/* the parent node */
	LstNode	ln;	/* Element in parents list */

	/*
	 * If the child was actually made, see what its modification time is
	 * now -- some rules won't actually update the file. If the file still
	 * doesn't exist, make its mtime now.
	 */
	if (cgn->built_status != UPTODATE) {
		/*
		 * This is what Make does and it's actually a good thing, as it
		 * allows rules like
		 *
		 *	cmp -s y.tab.h parse.h || cp y.tab.h parse.h
		 *
		 * to function as intended. Unfortunately, thanks to the
		 * stateless nature of NFS, there are times when the
		 * modification time of a file created on a remote machine
		 * will not be modified before the local stat() implied by
		 * the Dir_MTime occurs, thus leading us to believe that the
		 * file is unchanged, wreaking havoc with files that depend
		 * on this one.
		 */
		if (noExecute || is_out_of_date(Dir_MTime(cgn)))
			clock_gettime(CLOCK_REALTIME, &cgn->mtime);
		if (DEBUG(MAKE))
			printf("update time: %s\n",
			    time_to_string(&cgn->mtime));
	}

	requeue(cgn);
	/* SIB: this is where I should mark the build as finished */
	for (ln = Lst_First(&cgn->parents); ln != NULL; ln = Lst_Adv(ln)) {
		pgn = Lst_Datum(ln);
		/* SIB: there should be a siblings loop there */
		pgn->unmade--;
		if (pgn->must_make) {
			if (DEBUG(MAKE))
				printf("%s--=%d ",
				    pgn->name, pgn->unmade);

			if ( ! (cgn->type & (OP_EXEC|OP_USE))) {
				if (cgn->built_status == MADE)
					pgn->childMade = true;
				(void)Make_TimeStamp(pgn, cgn);
			}
			if (pgn->unmade == 0) {
				/*
				 * Queue the node up -- any unmade
				 * predecessors will be dealt with in
				 * MakeStartJobs.
				 */
				if (DEBUG(MAKE))
					printf("QUEUING ");
				Array_Push(&toBeMade, pgn);
			} else if (pgn->unmade < 0) {
				Error("Child %s discovered graph cycles through %s", cgn->name, pgn->name);
			}
		}
	}
	if (DEBUG(MAKE))
		printf("\n");
	requeue_successors(cgn);
}

static bool
try_to_make_node(GNode *gn)
{
	if (DEBUG(MAKE))
		printf("Examining %s...", gn->name);
		
	if (gn->built_status == HELDBACK) {
		if (DEBUG(HELDJOBS))
			printf("%s already held back ???\n", gn->name);
		return false;
	}

	if (gn->unmade != 0) {
		if (DEBUG(MAKE))
			printf(" Requeuing (%d)\n", gn->unmade);
		add_targets_to_make(&gn->children);
		Array_Push(&toBeMade, gn);
		return false;
	}
	if (has_been_built(gn)) {
		if (DEBUG(MAKE))
			printf(" already made\n");
		return false;
	}
	if (has_unmade_predecessor(gn)) {
		if (DEBUG(MAKE))
			printf(" Dropping for now\n");
		return false;
	}

	/* SIB: this is where there should be a siblings loop */
	if (gn->unmade != 0) {
		if (DEBUG(MAKE))
			printf(" Requeuing (after deps: %d)\n", gn->unmade);
		add_targets_to_make(&gn->children);
		return false;
	}
	/* this is where we hold back nodes */
	if (gn->groupling != NULL) {
		GNode *gn2;
		for (gn2 = gn->groupling; gn2 != gn; gn2 = gn2->groupling)
			if (gn2->built_status == BUILDING) {
				gn->watched = gn2;
				gn->built_status = HELDBACK;
				if (DEBUG(HELDJOBS))
					printf("Holding back job %s, "
					    "groupling to %s\n",
					    gn->name, gn2->name);
				Array_Push(&heldBack, gn);
				return false;
			}
	}
	if (gn->sibling != gn) {
		GNode *gn2;
		for (gn2 = gn->sibling; gn2 != gn; gn2 = gn2->sibling)
			if (gn2->built_status == BUILDING) {
				gn->watched = gn2;
				gn->built_status = HELDBACK;
				if (DEBUG(HELDJOBS))
					printf("Holding back job %s, "
					    "sibling to %s\n",
					    gn->name, gn2->name);
				Array_Push(&heldBack, gn);
				return false;
			}
	}
	if (Make_OODate(gn)) {
		if (DEBUG(MAKE))
			printf("out-of-date\n");
		if (queryFlag)
			return true;
		/* SIB: this is where commands should get prepared */
		Make_DoAllVar(gn);
		Job_Make(gn);
	} else {
		if (DEBUG(MAKE))
			printf("up-to-date\n");
		gn->built_status = UPTODATE;
		if (gn->type & OP_JOIN) {
			/*
			 * Even for an up-to-date .JOIN node, we need it
			 * to have its context variables so references
			 * to it get the correct value for .TARGET when
			 * building up the context variables of its
			 * parent(s)...
			 */
			Make_DoAllVar(gn);
		}

		Make_Update(gn);
	}
	return false;
}

/*
 *-----------------------------------------------------------------------
 * MakeStartJobs --
 *	Start as many jobs as possible.
 *
 * Results:
 *	If the query flag was given to pmake, no job will be started,
 *	but as soon as an out-of-date target is found, this function
 *	returns true. At all other times, this function returns false.
 *
 * Side Effects:
 *	Nodes are removed from the toBeMade queue and job table slots
 *	are filled.
 *-----------------------------------------------------------------------
 */
static bool
MakeStartJobs(void)
{
	GNode	*gn;

	while (can_start_job() && (gn = Array_Pop(&toBeMade)) != NULL) {
		if (try_to_make_node(gn))
			return true;
	}
	return false;
}

static void
MakePrintStatus(void *gnp)
{
	GNode	*gn = gnp;
	if (gn->built_status == UPTODATE) {
		printf("`%s' is up to date.\n", gn->name);
	} else if (gn->unmade != 0) {
		printf("`%s' not remade because of errors.\n", gn->name);
	}
}

static void
MakeAddChild(void *to_addp, void *ap)
{
	GNode *gn = to_addp;
	struct growableArray *a = ap;

	if (!gn->must_make && !(gn->type & OP_USE))
		Array_Push(a, gn);
}

static void
MakeHandleUse(void *cgnp, void *pgnp)
{
	GNode *cgn = cgnp;
	GNode *pgn = pgnp;

	if (cgn->type & OP_USE)
		Make_HandleUse(cgn, pgn);
}

/* Add stuff to the toBeMade queue. we try to sort things so that stuff
 * that can be done directly is done right away.  This won't be perfect,
 * since some dependencies are only discovered later (e.g., SuffFindDeps).
 */
static void
add_targets_to_make(Lst todo)
{
	GNode *gn;

	unsigned int slot;

	AppendList2Array(todo, &examine);

	while ((gn = Array_Pop(&examine)) != NULL) {
		if (gn->must_make) 	/* already known */
			continue;
		gn->must_make = true;

		slot = ohash_qlookup(&targets, gn->name);
		if (!ohash_find(&targets, slot))
			ohash_insert(&targets, slot, gn);


		look_harder_for_target(gn);
		kludge_look_harder_for_target(gn);
		/*
		 * Apply any .USE rules before looking for implicit
		 * dependencies to make sure everything that should have
		 * commands has commands ...
		 */
		Lst_ForEach(&gn->children, MakeHandleUse, gn);
		Suff_FindDeps(gn);
		expand_all_children(gn);

		if (gn->unmade != 0) {
			if (DEBUG(MAKE))
				printf("%s: not queuing (%d unmade children)\n",
				    gn->name, gn->unmade);
			Lst_ForEach(&gn->children, MakeAddChild,
			    &examine);
		} else {
			if (DEBUG(MAKE))
				printf("%s: queuing\n", gn->name);
			Array_Push(&toBeMade, gn);
		}
	}
	if (randomize_queue)
		randomize_garray(&toBeMade);
}

/*-
 *-----------------------------------------------------------------------
 * Make_Run --
 *	Initialize the nodes to remake and the list of nodes which are
 *	ready to be made by doing a breadth-first traversal of the graph
 *	starting from the nodes in the given list. Once this traversal
 *	is finished, all the 'leaves' of the graph are in the toBeMade
 *	queue.
 *	Using this queue and the Job module, work back up the graph,
 *	calling on MakeStartJobs to keep the job table as full as
 *	possible.
 *
 * Results:
 *	true if work was done. false otherwise.
 *
 * Side Effects:
 *	The must_make field of all nodes involved in the creation of the given
 *	targets is set to 1. The toBeMade list is set to contain all the
 *	'leaves' of these subgraphs.
 *-----------------------------------------------------------------------
 */
bool
Make_Run(Lst targs)		/* the initial list of targets */
{
	bool problem;	/* errors occurred */

	/* wild guess at initial sizes */
	Array_Init(&toBeMade, 500);
	Array_Init(&examine, 150);
	Array_Init(&heldBack, 100);
	ohash_init(&targets, 10, &gnode_info);
	if (DEBUG(PARALLEL))
		random_setup();

	add_targets_to_make(targs);
	if (queryFlag) {
		/*
		 * We wouldn't do any work unless we could start some jobs in
		 * the next loop... (we won't actually start any, of course,
		 * this is just to see if any of the targets was out of date)
		 */
		return MakeStartJobs();
	} else {
		/*
		 * Initialization. At the moment, no jobs are running and until
		 * some get started, nothing will happen since the remaining
		 * upward traversal of the graph is performed by the routines
		 * in job.c upon the finishing of a job. So we fill the Job
		 * table as much as we can before going into our loop.
		 */
		(void)MakeStartJobs();
	}

	/*
	 * Main Loop: The idea here is that the ending of jobs will take
	 * care of the maintenance of data structures and the waiting for output
	 * will cause us to be idle most of the time while our children run as
	 * much as possible. Because the job table is kept as full as possible,
	 * the only time when it will be empty is when all the jobs which need
	 * running have been run, so that is the end condition of this loop.
	 * Note that the Job module will exit if there were any errors unless
	 * the keepgoing flag was given.
	 */
	while (!Job_Empty()) {
		handle_running_jobs();
		(void)MakeStartJobs();
	}

	problem = Job_Finish();

	/*
	 * Print the final status of each target. E.g. if it wasn't made
	 * because some inferior reported an error.
	 */
	if (targets_contain_cycles()) {
		break_and_print_cycles(targs);
		problem = true;
	}
	Lst_Every(targs, MakePrintStatus);
	if (problem)
		Fatal("Errors while building");

	return true;
}

/* round-about detection: assume make is bug-free, if there are targets
 * that have not been touched, it means they never were reached, so we can
 * look for a cycle
 */
static bool
targets_contain_cycles(void)
{
	GNode *gn;
	unsigned int i;
	bool cycle = false;
	bool first = true;

	for (gn = ohash_first(&targets, &i); gn != NULL;
	    gn = ohash_next(&targets, &i)) {
	    	if (has_been_built(gn))
			continue;
		cycle = true;
		if (first)
			printf("Error target(s) unaccounted for: ");
		printf("%s ", gn->name);
		first = false;
	}
	if (!first)
		printf("\n");
	return cycle;
}

static void
print_unlink_cycle(struct growableArray *l, GNode *c)
{
	LstNode ln;
	GNode *gn = NULL;
	unsigned int i;
	
	printf("Cycle found: ");

	for (i = 0; i != l->n; i++) {
		gn = l->a[i];
		if (gn == c)
			printf("(");
		printf("%s -> ", gn->name);
	}
	printf("%s)\n", c->name);
	assert(gn);

	/* So the first element is tied to our node, find and kill the link */
	for (ln = Lst_First(&gn->children); ln != NULL; ln = Lst_Adv(ln)) {
		GNode *gn2 = Lst_Datum(ln);
		if (gn2 == c) {
			Lst_Remove(&gn->children, ln);
			return;
		}
	}
	/* this shouldn't happen ever */
	assert(0);
}

/* each call to find_cycle records a cycle in cycle, to break at node c.
 * this will stop eventually.
 */
static void
break_and_print_cycles(Lst t)
{
	struct growableArray cycle;

	Array_Init(&cycle, 16); /* cycles are generally shorter */
	while (1) {
		GNode *c;

		Array_Reset(&cycle);
		c = find_cycle(t, &cycle);
		if (c)
			print_unlink_cycle(&cycle, c);
		else
			break;
	}
	free(cycle.a);
}


static GNode *
find_cycle(Lst l, struct growableArray *cycle)
{
	LstNode ln;

	for (ln = Lst_First(l); ln != NULL; ln = Lst_Adv(ln)) {
		GNode *gn = Lst_Datum(ln);
		if (gn->in_cycle) {
			/* we should print the cycle and not do more */
			return gn;
		}
		
		if (gn->built_status == UPTODATE)
			continue;
		if (gn->unmade != 0) {
			GNode *c;

			gn->in_cycle = true;
			Array_Push(cycle, gn);
			c = find_cycle(&gn->children, cycle);
			gn->in_cycle = false;
			if (c)
				return c;
			Array_Pop(cycle);
		}
	}
	return NULL;
}
@


1.72
log
@better display of cycles in -j mode.
lots of tests by krw@@
review and comments by pirofti@@, more tweaks to come
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.71 2016/10/21 16:12:38 espie Exp $	*/
d120 1
a120 1
bool 
d134 1
a134 1
		random_delay = strtonum(Var_Value("RANDOM_DELAY"), 0, 1000, 
d173 1
a173 1
				printf("predecessor %s not made yet.\n", 
d192 1
a192 1
		if (succ->must_make && succ->unmade == 0 
d209 1
a209 1
				printf("%s finished, releasing: %s\n", 
d266 1
a266 1
			printf("update time: %s\n", 
d278 1
a278 1
				printf("%s--=%d ", 
d351 1
a351 1
					    "groupling to %s\n", 
d365 1
a365 1
					    "sibling to %s\n", 
d457 1
a457 1
/* Add stuff to the toBeMade queue. we try to sort things so that stuff 
d604 1
a604 1
	for (gn = ohash_first(&targets, &i); gn != NULL; 
d687 1
a687 1
			GNode *c; 
@


1.71
log
@small obvious cleanups:
- remove a lot of unnecessary casts
- zap extra param that's no longer needed
- add proper prototype and make function static

okay natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.70 2015/08/21 02:19:49 jsg Exp $	*/
d102 8
a109 1
static void MakePrintStatus(void *, void *);
a425 11
/*-
 *-----------------------------------------------------------------------
 * MakePrintStatus --
 *	Print the status of a top-level node, viz. it being up-to-date
 *	already or not created due to an error in a lower level.
 *	Callback function for Make_Run via Lst_ForEach.
 *
 * Side Effects:
 *	A message may be printed.
 *-----------------------------------------------------------------------
 */
d427 1
a427 5
MakePrintStatus(
    void *gnp,		    /* Node to examine */
    void *cyclep)	    /* True if gn->unmade being non-zero implies
			     * a cycle in the graph, not an error in an
			     * inferior */
a429 2
	bool 	*cp = cyclep;
	bool	cycle = *cp;
d433 1
a433 25
		if (cycle) {
			bool t = true;
			/*
			 * If printing cycles and came to one that has unmade
			 * children, print out the cycle by recursing on its
			 * children. Note a cycle like:
			 *	a : b
			 *	b : c
			 *	c : b
			 * will cause this to erroneously complain about a
			 * being in the cycle, but this is a good approximation.
			 */
			if (gn->built_status == CYCLE) {
				Error("Graph cycles through `%s'", gn->name);
				gn->built_status = ENDCYCLE;
				Lst_ForEach(&gn->children, MakePrintStatus, &t);
				gn->built_status = UNKNOWN;
			} else if (gn->built_status != ENDCYCLE) {
				gn->built_status = CYCLE;
				Lst_ForEach(&gn->children, MakePrintStatus, &t);
			}
		} else {
			printf("`%s' not remade because of errors.\n",
			    gn->name);
		}
a436 1

a531 3
	GNode *gn;
	unsigned int i;
	bool cycle;
a575 1
	cycle = false;
a576 9
	for (gn = ohash_first(&targets, &i); gn != NULL; 
	    gn = ohash_next(&targets, &i)) {
	    	if (has_been_built(gn))
			continue;
		cycle = true;
		problem = true;
	    	printf("Error: target %s unaccounted for (%s)\n", 
		    gn->name, status_to_string(gn));
	}
d581 5
a585 1
	Lst_ForEach(targs, MakePrintStatus, &cycle);
d590 109
@


1.70
log
@correctly indent a line to make the intent clear
ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.69 2015/01/23 13:18:40 espie Exp $	*/
d162 1
a162 1
		GNode	*pgn = (GNode *)Lst_Datum(ln);
d183 1
a183 1
		GNode	*succ = (GNode *)Lst_Datum(ln);
d266 1
a266 1
		pgn = (GNode *)Lst_Datum(ln);
@


1.69
log
@remove a bunch of dangerous casts (useless casts from void * to something
else, in some cases by adding extra temporary variables.
IMO, it's much better practice to do

void *a;
int *p = a;
*p = 42;

rather than
void *a;
*(int *)a = 42;

okay miod@@... to be revisited for some possible const additions later.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.68 2014/01/06 12:21:45 espie Exp $	*/
d320 1
a320 1
			return false;
@


1.68
log
@Suff_FindDeps must happen before SuffExpandChildren (expand_all_children)
so that dynamic variables are solved properly
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.67 2013/05/22 12:14:08 espie Exp $	*/
d437 3
a439 2
	GNode	*gn = (GNode *)gnp;
	bool	cycle = *(bool *)cyclep;
d475 2
a476 1
	GNode *gn = (GNode *)to_addp;
d479 1
a479 1
		Array_Push((struct growableArray *)ap, gn);
d485 2
a486 2
	GNode *cgn = (GNode *)cgnp;
	GNode *pgn = (GNode *)pgnp;
@


1.67
log
@as checked through thorough tests, youngest->mtime == ctime, so ditch
the extra field.

remove some extra abstraction layer: use clock_gettime directly
instead of ts_set_from_now (what is "now" anyways)

time_to_string takes param by pointer

rename "now" into starttime (more accurate term)

randomize queue uses arc4random_uniform (prompted by deraadt@@)

display debug timestamp with ns too (it's debug, so it doesn't really
matter whichever way it's done, as long as it's done)

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.66 2013/04/23 14:32:53 espie Exp $	*/
a328 1
	Suff_FindDeps(gn);
d521 1
@


1.66
log
@remove TIMESTAMP abstraction layer, prodded by theo.
while there, clean up includes.
use strtoll for ar timestamps (pretty much unused in reality, more
standard conforming than anything)

use idea from Todd to adapt to time_t being 32 bits OR 64 bits
(pedantically correct: INT_MIN would work just fine up to 1910 or so...)

okay millert@@, gone thru a make build.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.65 2012/12/08 12:54:17 espie Exp $	*/
d51 3
a53 3
 *				various bookkeeping chores like the updating
 *				of the cmtime field of the parent, filling
 *				of the IMPSRC context variable, etc. It will
d124 2
d129 1
a130 12
	if (randomize_queue || random_delay) {
		unsigned int random_seed;
		char *t;
		
		t = Var_Value("RANDOM_SEED");
		if (t != NULL)
			random_seed = strtonum(t, 0, UINT_MAX, NULL);
		else
			random_seed = time(NULL);
		fprintf(stderr, "RANDOM_SEED=%u\n", random_seed);
		srandom(random_seed);
	}
d141 1
a141 1
		v = random() % i;
d226 2
a227 6
 *	If the child was made, the parent's childMade field will be set true
 *	and its cmtime set to now.
 *
 *	If the child wasn't made, the cmtime field of the parent will be
 *	altered if the child's mtime is big enough.
 *
d257 1
a257 1
			ts_set_from_now(cgn->mtime);
d259 2
a260 1
			printf("update time: %s\n", time_to_string(cgn->mtime));
@


1.65
log
@document a bit of job.c
notice that Job_Finish() really returns a boolean, so unconfuse
that accordingly (it's likely the extra Fatal() message is not
needed and we could just call finish)
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.64 2012/10/09 19:49:28 espie Exp $	*/
a59 1
#include <stdio.h>
d62 2
@


1.64
log
@actual engine change: prevent jobs from stomping on each other's files.
namely:
- targets that ARE the same file shouldn't build concurrently.
- targets in the same group (e.g., file.c file.c: file.y) shouldn't build
concurrently.

This probably fixes all the remaining races in make -j4 build in src.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.63 2012/04/21 04:35:32 guenther Exp $	*/
d575 1
a575 1
	int errors;	/* Number of errors the Job module reports */
d622 1
a622 1
	errors = Job_Finish();
d630 1
a630 1
		errors++;
d639 1
a639 1
	if (errors)
@


1.63
log
@When a new parent is attached to an already examined child (prerequisite),
use the same logic to update the parent (factored out as SuffLinkParent())
as is used for updating the original parent.  Fixes the "make -j2" problem
reported by tedu@@ at c2k11

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.62 2011/11/03 20:55:22 schwarze Exp $	*/
d93 3
d199 21
d274 1
a275 1
	cgn->build_lock = false;
d315 6
d347 29
a376 1
		/* SIB: if a sibling is getting built, I don't build it right now */
a382 2
		/* SIB: this is where I should make the gn as `being built */
		gn->build_lock = true;
d583 1
@


1.62
log
@Garbage collect an unused variable.
Found by Michael W. Bombardieri <mwb at bom dot nom dot co> using lint.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.61 2010/07/19 19:46:44 espie Exp $	*/
d262 1
a262 1
				if (cgn->built_status == MADE) {
d264 1
a264 6
					if (is_strictly_before(pgn->cmtime,
					    cgn->mtime))
						pgn->cmtime = cgn->mtime;
				} else {
					(void)Make_TimeStamp(pgn, cgn);
				}
@


1.61
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.60 2009/08/16 09:53:43 espie Exp $	*/
a221 1
	char	*cname; /* the child's name */
a222 2

	cname = Var(TARGET_INDEX, cgn);
@


1.60
log
@modify timestamp handling to grab current time instead of relying on a
stale timestamp.

all those diffs sent to people ages ago, who didn't answer, except for
Theo, who said he ran it with no issues, so let's get this in...
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$	*/
@


1.59
log
@simplify job handling a great deal: we don't care when jobs get
stopped/continued, as we won't try to start new jobs when other stuff
is stopped.

Redo signal handling so that most stuff can be done directly in the handler.
This requires blocking/unblocking signals while creating new jobs, and creating
a small list that only contains job's pids.

Switch to pgrps for jobs, since that works.

Add a clamping heuristic that avoids starting new jobs while an expensive job
is running (expensive meaning "very likely to be a recursive make run"). This
idea is mostly from Theo, through the implementation is mine.
@
text
@d249 1
a249 1
			cgn->mtime = now;
@


1.58
log
@changes to get target equivalence to work better.
- add new file to create lists of equivalent targets (siblings)
- use that for sequential mode to have much better VPATH support
- separate checking commands from reporting error, for later.
- zap DieHorribly accordingly
- renumber existing flags
- signal_running_jobs() is simpler than pass_signal_to_jobs()
- new debug option -dn for name matching.

Similar code to handle parallel make is still missing.

thanks to Mark, Miod, Theo, Otto, Todd for tests and/or comments.
@
text
@d377 1
a377 1
	while (!Job_Full() && (gn = Array_Pop(&toBeMade)) != NULL) {
@


1.57
log
@better error reporting/job handling error:
- systematically reorder jobs based on who did output last, so that the
last job to output is *first* to output again.
- better reaction to errors: any job that outputs is checked for termination
directly, and the Error message is printed right afterwards.
- better error messages, giving more useful information in -j mode.
@
text
@d81 1
d254 2
d258 1
d318 1
d327 1
d332 1
d334 2
d446 1
a446 1
MakeHandleUse(void *pgn, void *cgn)
d448 5
a452 1
	Make_HandleUse((GNode *)pgn, (GNode *)cgn);
d479 1
@


1.56
log
@I was sure I had committed this already, grrrr.
Anyways, switch to a growable array for job to do.
Allows us to randomize it.
fix manpage.
do not add delay if just one job to run.
@
text
@d556 1
a556 2
		Job_CatchOutput();
		Job_CatchChildren();
@


1.55
log
@grrr
@
text
@d81 11
a92 5
static LIST	toBeMade;	/* The current fringe of the graph. These
				 * are nodes which await examination by
				 * MakeOODate. It is added to by
				 * Make_Update and subtracted from by
				 * MakeStartJobs */
d109 6
d138 19
d192 1
a192 1
			(void)Lst_QueueNew(&toBeMade, succ);
d279 1
a279 1
				Lst_Push(&toBeMade, pgn);
d300 1
a300 1
		Lst_Push(&toBeMade, gn);
d368 1
a368 1
	while (!Job_Full() && (gn = (GNode *)Lst_Pop(&toBeMade)) != NULL) {
d428 1
a428 1
MakeAddChild(void *to_addp, void *lp)
d433 1
a433 1
		Lst_Push((Lst)lp, gn);
d450 1
a450 1
	LIST examine;
d453 1
a453 1
	Lst_Clone(&examine, todo, NOCOPY);
d455 1
a455 1
	while ((gn = (GNode *)Lst_Pop(&examine)) != NULL) {
d483 1
a483 1
			Lst_Push(&toBeMade, gn);
d486 2
a518 1
	Static_Lst_Init(&toBeMade);
d520 2
@


1.54
log
@debug scaffolding: allows the insertion of a random delay before firing up
jobs in parallel mode.
@
text
@d224 1
a225 1
			pgn->unmade--;
@


1.53
log
@keep unmade uptodate all the time, even for targets we're not making yet,
since we might want to make them later.

okay millert@@, beck@@
@
text
@d64 1
d98 27
a223 1
		pgn->unmade--;
d225 1
d248 1
a248 1
				Lst_EnQueue(&toBeMade, pgn);
d269 1
a269 1
		Lst_EnQueue(&toBeMade, gn);
d337 1
a337 1
	while (!Job_Full() && (gn = (GNode *)Lst_DeQueue(&toBeMade)) != NULL) {
d402 1
a402 1
		Lst_EnQueue((Lst)lp, gn);
d424 1
a424 1
	while ((gn = (GNode *)Lst_DeQueue(&examine)) != NULL) {
d452 1
a452 1
			Lst_EnQueue(&toBeMade, gn);
d487 1
d489 2
@


1.52
log
@more parallel make fixes.

Preparations to fix the engine:
- new function has_been_built(gn), that tells you what's the status of
a given node. Allows us to run Suff_FindDeps later, by updating the number
of unmade children correctly.
- take out the code that handles shell expansions in an expand_children*
set of functions, called by Suff_FindDeps, among others. These must be
called early in the engine to avoid creating bogus nodes.

Engine fixes:
- take the predecessor/successor special handling out, deal with it in
separate functions.
- don't count nodes. Explicitly track them all in a hash table (better
way to deal with non-built issues).
- don't run Suff_FindDeps at start, but just before building an actual node.
This allows make to find all dependencies correctly, as in groff.

Pfiou! now it works.
@
text
@d196 1
a197 1
			pgn->unmade--;
@


1.51
log
@simplify, no sense to break just to do return afterwards
@
text
@d63 3
d86 1
a86 3
static int	numNodes;	/* Number of nodes to be processed. If this
				 * is non-zero when Job_Empty() returns
				 * true, there's a cycle in the graph */
d95 5
a99 12
/*-
 *-----------------------------------------------------------------------
 * MakeAddChild  --
 *	Function used by Make_Run to add a child to the list l.
 *	It will only add the child if its make field is false.
 *
 * Side Effects:
 *	The given list is extended
 *-----------------------------------------------------------------------
 */
static void
MakeAddChild(void *to_addp, void *lp)
d101 4
a104 2
	GNode	   *to_add = (GNode *)to_addp;
	Lst 	   l = (Lst)lp;
d106 12
a117 2
	if (!to_add->must_make && !(to_add->type & OP_USE))
		Lst_EnQueue(l, to_add);
d121 1
a121 1
MakeHandleUse(void *pgn, void *cgn)
d123 12
a134 1
	Make_HandleUse((GNode *)pgn, (GNode *)cgn);
d198 3
d218 2
d222 1
a222 1
				Error("Graph cycles through %s", pgn->name);
d226 3
a228 11
	/* Deal with successor nodes. If any is marked for making and has an
	 * unmade count of 0, has not been made and isn't in the examination
	 * queue, it means we need to place it in the queue as it restrained
	 * itself before.	*/
	for (ln = Lst_First(&cgn->successors); ln != NULL; ln = Lst_Adv(ln)) {
		GNode	*succ = (GNode *)Lst_Datum(ln);

		if (succ->must_make && succ->unmade == 0 
		    && succ->built_status == UNKNOWN)
			(void)Lst_QueueNew(&toBeMade, succ);
	}
d236 18
a253 6
	/*
	 * Make sure any and all predecessors that are going to be made,
	 * have been.
	 */
	if (!Lst_IsEmpty(&gn->preds)) {
		LstNode ln;
d255 6
a260 19
		for (ln = Lst_First(&gn->preds); ln != NULL; ln = Lst_Adv(ln)){
			GNode	*pgn = (GNode *)Lst_Datum(ln);

			if (pgn->must_make && pgn->built_status == UNKNOWN) {
				if (DEBUG(MAKE))
					printf(
					    "predecessor %s not made yet.\n", 
					    pgn->name);
				/*
				 * there's a predecessor as yet unmade, so we
				 * just drop this node on the floor. When the
				 * node in question has been made, it will
				 * notice this node as being ready to make but
				 * as yet unmade and will place the node on the
				 * queue.
				 */
				return false;
			}
		}
a261 2

	numNodes--;
d368 18
a385 7
/*
 * Make an initial downward pass over the graph, marking nodes to be
 * made as we go down. We call Suff_FindDeps to find where a node is and
 * to get some children for it if it has none and also has no commands.
 * If the node is a leaf, we stick it on the toBeMade queue to
 * be looked at in a minute, otherwise we add its children to our queue
 * and go on about our business.
d388 1
a388 1
add_targets_to_make(Lst targs)
a389 1
	LIST examine;	/* List of targets to examine */
d391 4
a395 1
	Lst_Clone(&examine, targs, NOCOPY);
d397 3
a399 3
		if (!gn->must_make) {
			gn->must_make = true;
			numNodes++;
d401 13
a413 8
			look_harder_for_target(gn);
			/*
			 * Apply any .USE rules before looking for implicit
			 * dependencies to make sure everything that should have
			 * commands has commands ...
			 */
			Lst_ForEach(&gn->children, MakeHandleUse, gn);
			Suff_FindDeps(gn);
d415 10
a424 5
			if (gn->unmade != 0)
				Lst_ForEach(&gn->children, MakeAddChild,
				    &examine);
			else
				Lst_EnQueue(&toBeMade, gn);
d453 4
a456 1
	int 	    errors;	/* Number of errors the Job module reports */
d459 1
a459 2

	numNodes = 0;
d497 1
d499 9
d512 3
a514 2
	errors = errors == 0 && numNodes != 0;
	Lst_ForEach(targs, MakePrintStatus, &errors);
@


1.50
log
@simplify dynamic variable handling a great deal:
first remove all usage of Varq_Append by building the string directly.
then replace `common' handling with specialized handling for dynamic
strings (since they no longer need a buffer). Finally, identify the place
where the variable value needs to be copied because it's going to be free'd
or erased soon, and finally, use simple char* pointers.

Shaves about 80 bytes off every gnode structure, and kills quite a few
unnecessary malloc()s as well.
@
text
@d237 9
a245 1
				break;
a247 9
		/*
		 * If ln isn't NULL, there's a predecessor as yet
		 * unmade, so we just drop this node on the floor. When
		 * the node in question has been made, it will notice
		 * this node as being ready to make but as yet unmade
		 * and will place the node on the queue.
		 */
		if (ln != NULL)
			return false;
@


1.49
log
@UNMADE -> UNKNOWN
@
text
@d149 1
a149 1
	cname = Varq_Value(TARGET_INDEX, cgn);
@


1.48
log
@rename make -> must_make, made -> built_status
to make them easier to find in source files.
@
text
@d212 1
a212 1
		    && succ->built_status == UNMADE)
d232 1
a232 1
			if (pgn->must_make && pgn->built_status == UNMADE) {
d345 1
a345 1
				gn->built_status = UNMADE;
@


1.47
log
@simplify the way we deal with implicit rules and handle $<.

Having an `iParents' field is actually backwards, it's ways simpler to
store the pointer in the child, as an impliedsrc, and to set the variable
just in time along with all the rest in DoAllVar.

This is simpler, and it should allow us to call SuffFindDeps much later.
@
text
@d110 1
a110 1
	if (!to_add->make && !(to_add->type & OP_USE))
d156 1
a156 1
	if (cgn->made != UPTODATE) {
d179 1
a179 1
		if (pgn->make) {
d183 1
a183 1
				if (cgn->made == MADE) {
d211 2
a212 1
		if (succ->make && succ->unmade == 0 && succ->made == UNMADE)
d232 1
a232 1
			if (pgn->make && pgn->made == UNMADE) {
d262 1
a262 1
		gn->made = UPTODATE;
d326 1
a326 1
	if (gn->made == UPTODATE) {
d341 1
a341 1
			if (gn->made == CYCLE) {
d343 1
a343 1
				gn->made = ENDCYCLE;
d345 3
a347 3
				gn->made = UNMADE;
			} else if (gn->made != ENDCYCLE) {
				gn->made = CYCLE;
d374 2
a375 2
		if (!gn->make) {
			gn->make = true;
d412 1
a412 1
 *	The make field of all nodes involved in the creation of the given
@


1.46
log
@get make.c in a more readable state, by extracting code into separate
functions.

Restore a big more debug: if DEBUG(JOB), print commands (unexpanded).
@
text
@a139 3
 *	Finally, if the child is the implied source for the parent, the
 *	parent's IMPSRC variable is set appropriately.
 *
d147 1
a147 1
	LstNode	ln;	/* Element in parents and iParents lists */
a213 9

	/* Set the .IMPSRC variables for all the implied parents
	 * of this node.  */
	for (ln = Lst_First(&cgn->iParents); ln != NULL; ln = Lst_Adv(ln)) {
		pgn = (GNode *)Lst_Datum(ln);
		if (pgn->make)
			Varq_Set(IMPSRC_INDEX, cname, pgn);
	}

@


1.45
log
@zap dead code
@
text
@d91 2
d117 1
a117 1
    Make_HandleUse((GNode *)pgn, (GNode *)cgn);
d228 62
d311 2
a312 55
		if (DEBUG(MAKE))
			printf("Examining %s...", gn->name);
		/*
		 * Make sure any and all predecessors that are going to be made,
		 * have been.
		 */
		if (!Lst_IsEmpty(&gn->preds)) {
			LstNode ln;

			for (ln = Lst_First(&gn->preds); ln != NULL;
			    ln = Lst_Adv(ln)){
				GNode	*pgn = (GNode *)Lst_Datum(ln);

				if (pgn->make && pgn->made == UNMADE) {
					if (DEBUG(MAKE))
					    printf("predecessor %s not made yet.\n", pgn->name);
					break;
				}
			}
			/*
			 * If ln isn't NULL, there's a predecessor as yet
			 * unmade, so we just drop this node on the floor. When
			 * the node in question has been made, it will notice
			 * this node as being ready to make but as yet unmade
			 * and will place the node on the queue.
			 */
			if (ln != NULL)
				continue;
		}

		numNodes--;
		if (Make_OODate(gn)) {
			if (DEBUG(MAKE))
				printf("out-of-date\n");
			if (queryFlag)
				return true;
			Make_DoAllVar(gn);
			Job_Make(gn);
		} else {
			if (DEBUG(MAKE))
				printf("up-to-date\n");
			gn->made = UPTODATE;
			if (gn->type & OP_JOIN) {
				/*
				 * Even for an up-to-date .JOIN node, we need it
				 * to have its context variables so references
				 * to it get the correct value for .TARGET when
				 * building up the context variables of its
				 * parent(s)...
				 */
				Make_DoAllVar(gn);
			}

			Make_Update(gn);
		}
d369 38
a430 2
	GNode	    *gn;	/* a temporary pointer */
	LIST	    examine;	/* List of targets to examine */
a434 1
	Lst_Clone(&examine, targs, NOCOPY);
d437 1
a437 30
	/*
	 * Make an initial downward pass over the graph, marking nodes to be
	 * made as we go down. We call Suff_FindDeps to find where a node is and
	 * to get some children for it if it has none and also has no commands.
	 * If the node is a leaf, we stick it on the toBeMade queue to
	 * be looked at in a minute, otherwise we add its children to our queue
	 * and go on about our business.
	 */
	while ((gn = (GNode *)Lst_DeQueue(&examine)) != NULL) {
		if (!gn->make) {
			gn->make = true;
			numNodes++;

			look_harder_for_target(gn);
			/*
			 * Apply any .USE rules before looking for implicit
			 * dependencies to make sure everything that should have
			 * commands has commands ...
			 */
			Lst_ForEach(&gn->children, MakeHandleUse, gn);
			Suff_FindDeps(gn);

			if (gn->unmade != 0)
				Lst_ForEach(&gn->children, MakeAddChild,
				    &examine);
			else
				Lst_EnQueue(&toBeMade, gn);
		}
	}

@


1.44
log
@suff.c sets IMPSRC correctly, whereas this is bogus and strips the path
a lot of the time.
@
text
@a217 3
	{
	char	*cpref = Varq_Value(PREFIX_INDEX, cgn);

a221 1
	}
@


1.43
log
@Work done at p2k7.


This is a really big step towards getting parallel make to work.


Note that this is not yet complete. There are still a few `details' to
fix before this works 100%.  Specifically: sequential make (compat) and
parallel make don't use the same engine, and the parallel engine still
has a few limitations. For instance, some known issues:
- parallel make does not deal with .phony targets correctly all the time.
- some errors are deadly in parallel make mode.
- parallel make NEEDS way more sturdy correspondance of file system paths
and target names, since it often needs to match dependencies to targets
before the corresponding files exist.
- some local variables like $* get set in a bogus way in some cases.
- suffix handling has issues, especially related to the NULL suffix.
So, if you find stuff that does NOT yet work with parallel make, don't go
blindly try to fix the Makefile. It's very likely you might have stumbled
into a make bug. (unless you really, really, understand Makefiles, DON'T
GO CHANGING THEM YET).



Tested by lots of people, thanks go to miod@@, and robert@@ among other people.

Quick summary of what this does:

- remove `saving commands' extension (it's not really usable, nor used)
- move compat job runner and parallel interrupt handling into engine.c
- tweak the code so that both compat and parallel mode use the same job runner
and the same interrupt handling. Remove the other one.
- optimize job runner so that, in parallel mode, the last command does not
fork if we can avoid it (as it's already running in a sub shell).
- scrape all the code that dealt with creating shell scripts from commands.
- scrape all the code that dealt with recognizing special sequences in
command output to print/not print output.
- fix the parallel job pipe to not keep around file descriptors that are not
needed.
- replace the parallel job buffering with a nicer one, that deals with
non-blocking descriptors to try to agregate as much output from one job in
one go (greed) to unconfuse the users.
- create two pipes per job, so that stdout and stderr stay separate.
- make job token printing a debug option.
- always use the parallel job-runner to `execute' commands, even if we just
print them out.
- store list of errors encountered during parallel make running, and print them
on exit, so that we know what went wrong.
- add a dirty hack to targ.c to deal with paths produced by gccmakedep.
@
text
@d216 1
a216 1
	/* Set the .PREFIX and .IMPSRC variables for all the implied parents
d223 1
a223 1
		if (pgn->make) {
a224 2
			Varq_Set(PREFIX_INDEX, cpref, pgn);
		}
@


1.42
log
@make usePipes the default, zap undocumented -P.
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.41 2007/09/17 09:28:36 espie Exp $	*/
d62 1
d76 1
a170 3
		 * XXX If we are saving commands pretend that
		 * the target is made now. Otherwise archives with ... rules
		 * don't work!
d172 1
a172 2
		if (noExecute || (cgn->type & OP_SAVE_CMDS) ||
		    is_out_of_date(Dir_MTime(cgn)))
d410 1
@


1.41
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.40 2007/09/17 08:53:59 espie Exp $	*/
d458 1
a458 1
		Job_CatchChildren(!usePipes);
@


1.40
log
@reindent, zap useless comments
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.35 2004/04/07 13:11:36 espie Exp $	*/
d162 3
a164 3
		 * to function as intended. Unfortunately, thanks to the 
		 * stateless nature of NFS, there are times when the 
		 * modification time of a file created on a remote machine 
d166 2
a167 2
		 * the Dir_MTime occurs, thus leading us to believe that the 
		 * file is unchanged, wreaking havoc with files that depend 
d188 1
a188 1
					if (is_strictly_before(pgn->cmtime, 
d197 2
a198 2
				 * Queue the node up -- any unmade 
				 * predecessors will be dealt with in 
d207 3
a209 3
	/* Deal with successor nodes. If any is marked for making and has an 
	 * unmade count of 0, has not been made and isn't in the examination 
	 * queue, it means we need to place it in the queue as it restrained 
d264 1
a264 1
			for (ln = Lst_First(&gn->preds); ln != NULL; 
d275 1
a275 1
			 * If ln isn't NULL, there's a predecessor as yet 
d277 2
a278 2
			 * the node in question has been made, it will notice 
			 * this node as being ready to make but as yet unmade 
d299 4
a302 4
				 * Even for an up-to-date .JOIN node, we need it 
				 * to have its context variables so references 
				 * to it get the correct value for .TARGET when 
				 * building up the context variables of its 
d340 2
a341 2
			 * If printing cycles and came to one that has unmade 
			 * children, print out the cycle by recursing on its 
d346 1
a346 1
			 * will cause this to erroneously complain about a 
d359 1
a359 1
			printf("`%s' not remade because of errors.\n", 
d400 1
a400 1
	 * Make an initial downward pass over the graph, marking nodes to be 
d413 1
a413 1
			 * Apply any .USE rules before looking for implicit 
d421 1
a421 1
				Lst_ForEach(&gn->children, MakeAddChild, 
d430 2
a431 2
		 * We wouldn't do any work unless we could start some jobs in 
		 * the next loop... (we won't actually start any, of course, 
d439 2
a440 2
		 * upward traversal of the graph is performed by the routines 
		 * in job.c upon the finishing of a job. So we fill the Job 
d453 1
a453 1
	 * Note that the Job module will exit if there were any errors unless 
@


1.39
log
@kill += 1, -= 1     -> ++, --
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.38 2007/09/16 12:09:36 espie Exp $	*/
a57 12
 *	Make_TimeStamp		Function to set the parent's cmtime field
 *				based on a child's modification time.
 *
 *	Make_DoAllVar		Set up the various local variables for a
 *				target, including the .ALLSRC variable, making
 *				sure that any variable that needs to exist
 *				at the very least has the empty value.
 *
 *	Make_OODate		Determine if a target is out-of-date.
 *
 *	Make_HandleUse		See if a child is a .USE node for a parent
 *				and perform the .USE actions if so.
d89 1
d101 1
a101 3
MakeAddChild(
    void *gnp,		/* the node to add */
    void *lp)		/* the list to which to add it */
d103 2
a104 2
    GNode	   *gn = (GNode *)gnp;
    Lst 	   l = (Lst)lp;
d106 2
a107 2
    if (!gn->make && !(gn->type & OP_USE))
	Lst_EnQueue(l, gn);
d111 1
a111 3
MakeHandleUse(
    void *pgn,	/* the current parent */
    void *cgn)	/* the child we've just examined */
d144 6
a149 12
    GNode	*pgn;	/* the parent node */
    char	*cname; /* the child's name */
    LstNode	ln;	/* Element in parents and iParents lists */

    cname = Varq_Value(TARGET_INDEX, cgn);

    /*
     * If the child was actually made, see what its modification time is
     * now -- some rules won't actually update the file. If the file still
     * doesn't exist, make its mtime now.
     */
    if (cgn->made != UPTODATE) {
d151 3
a153 16
	 * This is what Make does and it's actually a good thing, as it
	 * allows rules like
	 *
	 *	cmp -s y.tab.h parse.h || cp y.tab.h parse.h
	 *
	 * to function as intended. Unfortunately, thanks to the stateless
	 * nature of NFS (by which I mean the loose coupling of two clients
	 * using the same file from a common server), there are times
	 * when the modification time of a file created on a remote
	 * machine will not be modified before the local stat() implied by
	 * the Dir_MTime occurs, thus leading us to believe that the file
	 * is unchanged, wreaking havoc with files that depend on this one.
	 *
	 * I have decided it is better to make too much than to make too
	 * little, so this stuff is commented out unless you're sure it's ok.
	 * -- ardeb 1/12/88
d155 51
a205 8
	/*
	 * Christos, 4/9/92: If we are	saving commands pretend that
	 * the target is made now. Otherwise archives with ... rules
	 * don't work!
	 */
	if (noExecute || (cgn->type & OP_SAVE_CMDS) ||
	    is_out_of_date(Dir_MTime(cgn))) {
	    cgn->mtime = now;
d207 9
a215 2
	if (DEBUG(MAKE)) {
	    printf("update time: %s\n", time_to_string(cgn->mtime));
a216 1
    }
d218 10
a227 12
    for (ln = Lst_First(&cgn->parents); ln != NULL; ln = Lst_Adv(ln)) {
	pgn = (GNode *)Lst_Datum(ln);
	if (pgn->make) {
	    pgn->unmade--;

	    if ( ! (cgn->type & (OP_EXEC|OP_USE))) {
		if (cgn->made == MADE) {
		    pgn->childMade = true;
		    if (is_strictly_before(pgn->cmtime, cgn->mtime))
			pgn->cmtime = cgn->mtime;
		} else {
		    (void)Make_TimeStamp(pgn, cgn);
a228 10
	    }
	    if (pgn->unmade == 0) {
		/*
		 * Queue the node up -- any unmade predecessors will
		 * be dealt with in MakeStartJobs.
		 */
		Lst_EnQueue(&toBeMade, pgn);
	    } else if (pgn->unmade < 0) {
		Error("Graph cycles through %s", pgn->name);
	    }
a229 22
    }
    /* Deal with successor nodes. If any is marked for making and has an unmade
     * count of 0, has not been made and isn't in the examination queue,
     * it means we need to place it in the queue as it restrained itself
     * before.	*/
    for (ln = Lst_First(&cgn->successors); ln != NULL; ln = Lst_Adv(ln)) {
	GNode	*succ = (GNode *)Lst_Datum(ln);

	if (succ->make && succ->unmade == 0 && succ->made == UNMADE)
	    (void)Lst_QueueNew(&toBeMade, succ);
    }

    /* Set the .PREFIX and .IMPSRC variables for all the implied parents
     * of this node.  */
    {
    char	*cpref = Varq_Value(PREFIX_INDEX, cgn);

    for (ln = Lst_First(&cgn->iParents); ln != NULL; ln = Lst_Adv(ln)) {
	pgn = (GNode *)Lst_Datum(ln);
	if (pgn->make) {
	    Varq_Set(IMPSRC_INDEX, cname, pgn);
	    Varq_Set(PREFIX_INDEX, cpref, pgn);
d231 1
a231 2
    }
    }
d234 1
a234 1
/*-
d252 1
a252 1
    GNode	*gn;
d254 9
a262 13
    while (!Job_Full() && (gn = (GNode *)Lst_DeQueue(&toBeMade)) != NULL) {
	if (DEBUG(MAKE)) {
	    printf("Examining %s...", gn->name);
	}
	/*
	 * Make sure any and all predecessors that are going to be made,
	 * have been.
	 */
	if (!Lst_IsEmpty(&gn->preds)) {
	    LstNode ln;

	    for (ln = Lst_First(&gn->preds); ln != NULL; ln = Lst_Adv(ln)){
		GNode	*pgn = (GNode *)Lst_Datum(ln);
d264 19
a282 5
		if (pgn->make && pgn->made == UNMADE) {
		    if (DEBUG(MAKE)) {
			printf("predecessor %s not made yet.\n", pgn->name);
		    }
		    break;
a283 11
	    }
	    /*
	     * If ln isn't NULL, there's a predecessor as yet unmade, so we
	     * just drop this node on the floor. When the node in question
	     * has been made, it will notice this node as being ready to
	     * make but as yet unmade and will place the node on the queue.
	     */
	    if (ln != NULL) {
		continue;
	    }
	}
d285 22
a306 24
	numNodes--;
	if (Make_OODate(gn)) {
	    if (DEBUG(MAKE)) {
		printf("out-of-date\n");
	    }
	    if (queryFlag) {
		return true;
	    }
	    Make_DoAllVar(gn);
	    Job_Make(gn);
	} else {
	    if (DEBUG(MAKE)) {
		printf("up-to-date\n");
	    }
	    gn->made = UPTODATE;
	    if (gn->type & OP_JOIN) {
		/*
		 * Even for an up-to-date .JOIN node, we need it to have its
		 * context variables so references to it get the correct
		 * value for .TARGET when building up the context variables
		 * of its parent(s)...
		 */
		Make_DoAllVar(gn);
	    }
d308 2
a309 1
	    Make_Update(gn);
d311 1
a311 2
    }
    return false;
d332 30
a361 28
    GNode	*gn = (GNode *)gnp;
    bool	cycle = *(bool *)cyclep;
    if (gn->made == UPTODATE) {
	printf("`%s' is up to date.\n", gn->name);
    } else if (gn->unmade != 0) {
	if (cycle) {
	    bool t = true;
	    /*
	     * If printing cycles and came to one that has unmade children,
	     * print out the cycle by recursing on its children. Note a
	     * cycle like:
	     *	a : b
	     *	b : c
	     *	c : b
	     * will cause this to erroneously complain about a being in
	     * the cycle, but this is a good approximation.
	     */
	    if (gn->made == CYCLE) {
		Error("Graph cycles through `%s'", gn->name);
		gn->made = ENDCYCLE;
		Lst_ForEach(&gn->children, MakePrintStatus, &t);
		gn->made = UNMADE;
	    } else if (gn->made != ENDCYCLE) {
		gn->made = CYCLE;
		Lst_ForEach(&gn->children, MakePrintStatus, &t);
	    }
	} else {
	    printf("`%s' not remade because of errors.\n", gn->name);
a362 1
    }
d390 54
a443 34
    GNode	    *gn;	/* a temporary pointer */
    LIST	    examine;	/* List of targets to examine */
    int 	    errors;	/* Number of errors the Job module reports */

    Static_Lst_Init(&toBeMade);

    Lst_Clone(&examine, targs, NOCOPY);
    numNodes = 0;

    /*
     * Make an initial downward pass over the graph, marking nodes to be made
     * as we go down. We call Suff_FindDeps to find where a node is and
     * to get some children for it if it has none and also has no commands.
     * If the node is a leaf, we stick it on the toBeMade queue to
     * be looked at in a minute, otherwise we add its children to our queue
     * and go on about our business.
     */
    while ((gn = (GNode *)Lst_DeQueue(&examine)) != NULL) {
	if (!gn->make) {
	    gn->make = true;
	    numNodes++;

	    /*
	     * Apply any .USE rules before looking for implicit dependencies
	     * to make sure everything has commands that should...
	     */
	    Lst_ForEach(&gn->children, MakeHandleUse, gn);
	    Suff_FindDeps(gn);

	    if (gn->unmade != 0) {
		Lst_ForEach(&gn->children, MakeAddChild, &examine);
	    } else {
		Lst_EnQueue(&toBeMade, gn);
	    }
a444 1
    }
a445 1
    if (queryFlag) {
d447 8
a454 3
	 * We wouldn't do any work unless we could start some jobs in the
	 * next loop... (we won't actually start any, of course, this is just
	 * to see if any of the targets was out of date)
d456 8
a463 2
	return MakeStartJobs();
    } else {
d465 2
a466 5
	 * Initialization. At the moment, no jobs are running and until some
	 * get started, nothing will happen since the remaining upward
	 * traversal of the graph is performed by the routines in job.c upon
	 * the finishing of a job. So we fill the Job table as much as we can
	 * before going into our loop.
d468 2
a469 27
	(void)MakeStartJobs();
    }

    /*
     * Main Loop: The idea here is that the ending of jobs will take
     * care of the maintenance of data structures and the waiting for output
     * will cause us to be idle most of the time while our children run as
     * much as possible. Because the job table is kept as full as possible,
     * the only time when it will be empty is when all the jobs which need
     * running have been run, so that is the end condition of this loop.
     * Note that the Job module will exit if there were any errors unless the
     * keepgoing flag was given.
     */
    while (!Job_Empty()) {
	Job_CatchOutput();
	Job_CatchChildren(!usePipes);
	(void)MakeStartJobs();
    }

    errors = Job_Finish();

    /*
     * Print the final status of each target. E.g. if it wasn't made
     * because some inferior reported an error.
     */
    errors = errors == 0 && numNodes != 0;
    Lst_ForEach(targs, MakePrintStatus, &errors);
d471 1
a471 1
    return true;
@


1.38
log
@rename Targ_FmtTime into time_to_string and move it, as it's not related
to target nodes at all (reduces modules inter-dependencies)
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.37 2007/09/16 10:39:07 espie Exp $	*/
d206 1
a206 1
	    pgn->unmade -= 1;
@


1.37
log
@first step towards sanity: take the functions common to parallel/not parallel
make outside of make.c and job.c, and create an engine.c file to hold them.
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.36 2007/09/16 09:46:14 espie Exp $	*/
a79 1
#include "targ.h"
d199 1
a199 1
	    printf("update time: %s\n", Targ_FmtTime(cgn->mtime));
@


1.36
log
@remove dead code: #define RECHECK is always on
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.35 2004/04/07 13:11:36 espie Exp $	*/
a77 1
#include "arch.h"
d86 1
a98 2
static void MakeAddAllSrc(void *, void *);
static void MakeTimeStamp(void *, void *);
a103 171
 * Make_TimeStamp --
 *	Set the cmtime field of a parent node based on the mtime stamp in its
 *	child.
 *
 * Side Effects:
 *	The cmtime of the parent node will be changed if the mtime
 *	field of the child is greater than it.
 *-----------------------------------------------------------------------
 */
void
Make_TimeStamp(
    GNode *pgn, /* the current parent */
    GNode *cgn) /* the child we've just examined */
{
    if (is_strictly_before(pgn->cmtime, cgn->mtime))
	pgn->cmtime = cgn->mtime;
}

/* Wrapper to call Make_TimeStamp from a forEach loop.	*/
static void
MakeTimeStamp(
    void *pgn,	/* the current parent */
    void *cgn)	/* the child we've just examined */
{
    Make_TimeStamp((GNode *)pgn, (GNode *)cgn);
}

/*-
 *-----------------------------------------------------------------------
 * Make_OODate --
 *	See if a given node is out of date with respect to its sources.
 *	Used by Make_Run when deciding which nodes to place on the
 *	toBeMade queue initially and by Make_Update to screen out USE and
 *	EXEC nodes. In the latter case, however, any other sort of node
 *	must be considered out-of-date since at least one of its children
 *	will have been recreated.
 *
 * Results:
 *	true if the node is out of date. false otherwise.
 *
 * Side Effects:
 *	The mtime field of the node and the cmtime field of its parents
 *	will/may be changed.
 *-----------------------------------------------------------------------
 */
bool
Make_OODate(GNode *gn)	/* the node to check */
{
    bool	    oodate;

    /*
     * Certain types of targets needn't even be sought as their datedness
     * doesn't depend on their modification time...
     */
    if ((gn->type & (OP_JOIN|OP_USE|OP_EXEC)) == 0) {
	(void)Dir_MTime(gn);
	if (DEBUG(MAKE)) {
	    if (!is_out_of_date(gn->mtime)) {
		printf("modified %s...", Targ_FmtTime(gn->mtime));
	    } else {
		printf("non-existent...");
	    }
	}
    }

    /*
     * A target is remade in one of the following circumstances:
     *	its modification time is smaller than that of its youngest child
     *	    and it would actually be run (has commands or type OP_NOP)
     *	it's the object of a force operator
     *	it has no children, was on the lhs of an operator and doesn't exist
     *	    already.
     *
     * Libraries are only considered out-of-date if the archive module says
     * they are.
     *
     * These weird rules are brought to you by Backward-Compatibility and
     * the strange people who wrote 'Make'.
     */
    if (gn->type & OP_USE) {
	/*
	 * If the node is a USE node it is *never* out of date
	 * no matter *what*.
	 */
	if (DEBUG(MAKE)) {
	    printf(".USE node...");
	}
	oodate = false;
    } else if ((gn->type & OP_LIB) && Arch_IsLib(gn)) {
	if (DEBUG(MAKE)) {
	    printf("library...");
	}

	/*
	 * always out of date if no children and :: target
	 */

	oodate = Arch_LibOODate(gn) ||
	    (is_out_of_date(gn->cmtime) && (gn->type & OP_DOUBLEDEP));
    } else if (gn->type & OP_JOIN) {
	/*
	 * A target with the .JOIN attribute is only considered
	 * out-of-date if any of its children was out-of-date.
	 */
	if (DEBUG(MAKE)) {
	    printf(".JOIN node...");
	}
	oodate = gn->childMade;
    } else if (gn->type & (OP_FORCE|OP_EXEC|OP_PHONY)) {
	/*
	 * A node which is the object of the force (!) operator or which has
	 * the .EXEC attribute is always considered out-of-date.
	 */
	if (DEBUG(MAKE)) {
	    if (gn->type & OP_FORCE) {
		printf("! operator...");
	    } else if (gn->type & OP_PHONY) {
		printf(".PHONY node...");
	    } else {
		printf(".EXEC node...");
	    }
	}
	oodate = true;
    } else if (is_strictly_before(gn->mtime, gn->cmtime) ||
	       (is_out_of_date(gn->cmtime) &&
		(is_out_of_date(gn->mtime) || (gn->type & OP_DOUBLEDEP))))
    {
	/*
	 * A node whose modification time is less than that of its
	 * youngest child or that has no children (cmtime == OUT_OF_DATE) and
	 * either doesn't exist (mtime == OUT_OF_DATE) or was the object of a
	 * :: operator is out-of-date. Why? Because that's the way Make does
	 * it.
	 */
	if (DEBUG(MAKE)) {
	    if (is_strictly_before(gn->mtime, gn->cmtime)) {
		printf("modified before source...");
	    } else if (is_out_of_date(gn->mtime)) {
		printf("non-existent and no sources...");
	    } else {
		printf(":: operator and no sources...");
	    }
	}
	oodate = true;
    } else {
#if 0
	/* WHY? */
	if (DEBUG(MAKE)) {
	    printf("source %smade...", gn->childMade ? "" : "not ");
	}
	oodate = gn->childMade;
#else
	oodate = false;
#endif /* 0 */
    }

    /*
     * If the target isn't out-of-date, the parents need to know its
     * modification time. Note that targets that appear to be out-of-date
     * but aren't, because they have no commands and aren't of type OP_NOP,
     * have their mtime stay below their children's mtime to keep parents from
     * thinking they're out-of-date.
     */
    if (!oodate)
	Lst_ForEach(&gn->parents, MakeTimeStamp, gn);

    return oodate;
}

/*-
 *-----------------------------------------------------------------------
a123 58
/*-
 *-----------------------------------------------------------------------
 * Make_HandleUse --
 *	Function called by Make_Run and SuffApplyTransform on the downward
 *	pass to handle .USE and transformation nodes. A callback function
 *	for Lst_ForEach, it implements the .USE and transformation
 *	functionality by copying the node's commands, type flags
 *	and children to the parent node. Should be called before the
 *	children are enqueued to be looked at by MakeAddChild.
 *
 *	A .USE node is much like an explicit transformation rule, except
 *	its commands are always added to the target node, even if the
 *	target already has commands.
 *
 * Side Effects:
 *	Children and commands may be added to the parent and the parent's
 *	type may be changed.
 *
 *-----------------------------------------------------------------------
 */
void
Make_HandleUse(
    GNode	*cgn,	/* The .USE node */
    GNode	*pgn)	/* The target of the .USE node */
{
    GNode	*gn;	/* A child of the .USE node */
    LstNode	ln;	/* An element in the children list */

    if (cgn->type & (OP_USE|OP_TRANSFORM)) {
	if ((cgn->type & OP_USE) || Lst_IsEmpty(&pgn->commands)) {
	    /* .USE or transformation and target has no commands -- append
	     * the child's commands to the parent.  */
	    Lst_Concat(&pgn->commands, &cgn->commands);
	}

	for (ln = Lst_First(&cgn->children); ln != NULL; ln = Lst_Adv(ln)) {
	    gn = (GNode *)Lst_Datum(ln);

	    if (Lst_AddNew(&pgn->children, gn)) {
		Lst_AtEnd(&gn->parents, pgn);
		pgn->unmade += 1;
	    }
	}

	pgn->type |= cgn->type & ~(OP_OPMASK|OP_USE|OP_TRANSFORM);

	/*
	 * This child node is now "made", so we decrement the count of
	 * unmade children in the parent... We also remove the child
	 * from the parent's list to accurately reflect the number of decent
	 * children the parent has. This is used by Make_Run to decide
	 * whether to queue the parent or examine its children...
	 */
	if (cgn->type & OP_USE) {
	    pgn->unmade--;
	}
    }
}
a252 94
}

/*-
 *-----------------------------------------------------------------------
 * MakeAddAllSrc --
 *	Add a child's name to the ALLSRC and OODATE variables of the given
 *	node. Called from Make_DoAllVar via Lst_ForEach. A child is added only
 *	if it has not been given the .EXEC, .USE or .INVISIBLE attributes.
 *	.EXEC and .USE children are very rarely going to be files, so...
 *	A child is added to the OODATE variable if its modification time is
 *	later than that of its parent, as defined by Make, except if the
 *	parent is a .JOIN node. In that case, it is only added to the OODATE
 *	variable if it was actually made (since .JOIN nodes don't have
 *	modification times, the comparison is rather unfair...)..
 *
 * Side Effects:
 *	The ALLSRC variable for the given node is extended.
 *-----------------------------------------------------------------------
 */
static void
MakeAddAllSrc(
    void *cgnp, /* The child to add */
    void *pgnp) /* The parent to whose ALLSRC variable it should be */
			/* added */
{
    GNode	*cgn = (GNode *)cgnp;
    GNode	*pgn = (GNode *)pgnp;
    if ((cgn->type & (OP_EXEC|OP_USE|OP_INVISIBLE)) == 0) {
	const char *child;

	if (OP_NOP(cgn->type) ||
	    (child = Varq_Value(TARGET_INDEX, cgn)) == NULL) {
	    /*
	     * this node is only source; use the specific pathname for it
	     */
	    child = cgn->path != NULL ? cgn->path : cgn->name;
	}

	Varq_Append(ALLSRC_INDEX, child, pgn);
	if (pgn->type & OP_JOIN) {
	    if (cgn->made == MADE) {
		Varq_Append(OODATE_INDEX, child, pgn);
	    }
	} else if (is_strictly_before(pgn->mtime, cgn->mtime) ||
		   (!is_strictly_before(cgn->mtime, now) && cgn->made == MADE))
	{
	    /*
	     * It goes in the OODATE variable if the parent is younger than the
	     * child or if the child has been modified more recently than
	     * the start of the make. This is to keep pmake from getting
	     * confused if something else updates the parent after the
	     * make starts (shouldn't happen, I know, but sometimes it
	     * does). In such a case, if we've updated the kid, the parent
	     * is likely to have a modification time later than that of
	     * the kid and anything that relies on the OODATE variable will
	     * be hosed.
	     *
	     */
	    Varq_Append(OODATE_INDEX, child, pgn);
	}
    }
}

/*-
 *-----------------------------------------------------------------------
 * Make_DoAllVar --
 *	Set up the ALLSRC and OODATE variables. Sad to say, it must be
 *	done separately, rather than while traversing the graph. This is
 *	because Make defined OODATE to contain all sources whose modification
 *	times were later than that of the target, *not* those sources that
 *	were out-of-date. Since in both compatibility and native modes,
 *	the modification time of the parent isn't found until the child
 *	has been dealt with, we have to wait until now to fill in the
 *	variable. As for ALLSRC, the ordering is important and not
 *	guaranteed when in native mode, so it must be set here, too.
 *
 * Side Effects:
 *	The ALLSRC and OODATE variables of the given node is filled in.
 *	If the node is a .JOIN node, its TARGET variable will be set to
 *	match its ALLSRC variable.
 *-----------------------------------------------------------------------
 */
void
Make_DoAllVar(GNode *gn)
{
    Lst_ForEach(&gn->children, MakeAddAllSrc, gn);

    if (Varq_Value(OODATE_INDEX, gn) == NULL)
	Varq_Set(OODATE_INDEX, "", gn);
    if (Varq_Value(ALLSRC_INDEX, gn) == NULL)
	Varq_Set(ALLSRC_INDEX, "", gn);

    if (gn->type & OP_JOIN)
	Varq_Set(TARGET_INDEX, Varq_Value(ALLSRC_INDEX, gn), gn);
@


1.35
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.34 2003/11/08 19:17:29 jmc Exp $	*/
a402 29
#ifndef RECHECK
	/*
	 * We can't re-stat the thing, but we can at least take care of rules
	 * where a target depends on a source that actually creates the
	 * target, but only if it has changed, e.g.
	 *
	 * parse.h : parse.o
	 *
	 * parse.o : parse.y
	 *	yacc -d parse.y
	 *	cc -c y.tab.c
	 *	mv y.tab.o parse.o
	 *	cmp -s y.tab.h parse.h || mv y.tab.h parse.h
	 *
	 * In this case, if the definitions produced by yacc haven't changed
	 * from before, parse.h won't have been updated and cgn->mtime will
	 * reflect the current modification time for parse.h. This is
	 * something of a kludge, I admit, but it's a useful one..
	 * XXX: People like to use a rule like
	 *
	 * FRC:
	 *
	 * To force things that depend on FRC to be made, so we have to
	 * check for gn->children being empty as well...
	 */
	if (!Lst_IsEmpty(&cgn->commands) || Lst_IsEmpty(&cgn->children)) {
	    cgn->mtime = now;
	}
#else
a432 1
#endif
a540 4
	     * XXX: This will cause all made children to go in the OODATE
	     * variable, even if they're not touched, if RECHECK isn't defined,
	     * since cgn->mtime is set to now in Make_Update. According to
	     * some people, this is good...
@


1.34
log
@typos from Jonathon Gray;
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.33 2003/06/03 02:56:12 millert Exp $	*/
d116 3
a118 3
Make_TimeStamp(pgn, cgn)
    GNode *pgn; /* the current parent */
    GNode *cgn; /* the child we've just examined */
d126 3
a128 3
MakeTimeStamp(pgn, cgn)
    void *pgn;	/* the current parent */
    void *cgn;	/* the child we've just examined */
d152 1
a152 2
Make_OODate(gn)
    GNode	    *gn;	      /* the node to check */
d286 3
a288 3
MakeAddChild(gnp, lp)
    void *gnp;		/* the node to add */
    void *lp;		/* the list to which to add it */
d318 3
a320 3
Make_HandleUse(cgn, pgn)
    GNode	*cgn;	/* The .USE node */
    GNode	*pgn;	/* The target of the .USE node */
d356 3
a358 3
MakeHandleUse(pgn, cgn)
    void *pgn;	/* the current parent */
    void *cgn;	/* the child we've just examined */
d389 1
a389 2
Make_Update(cgn)
    GNode	*cgn;	/* the child node */
d534 3
a536 3
MakeAddAllSrc(cgnp, pgnp)
    void *cgnp; /* The child to add */
    void *pgnp; /* The parent to whose ALLSRC variable it should be */
d601 1
a601 2
Make_DoAllVar(gn)
    GNode	*gn;
d630 1
a630 1
MakeStartJobs()
d709 3
a711 3
MakePrintStatus(gnp, cyclep)
    void *gnp;		    /* Node to examine */
    void *cyclep;	    /* True if gn->unmade being non-zero implies
d770 1
a770 2
Make_Run(targs)
    Lst 	    targs;	/* the initial list of targets */
@


1.33
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.32 2001/11/23 23:42:45 deraadt Exp $	*/
d183 1
a183 1
     * These weird rules are brought to you by Backward-Compatability and
@


1.32
log
@back out changes that break kernel compiles.  good testing jobmk install!
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.30 2001/11/11 12:35:02 espie Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.31
log
@Explicitly mark nodes whose commands have been filled with
implicit (suffix) rules.  Then, only expand the IMPSRC/< variable
if the node has been marked.

This matches what Single Unix 2 and common sense say: implicit rules
shouldn't count when an explicit rule has been found (an explicit rule
being a full-scale dependency, with some associated commands)

Note that Single Unix leaves the `PREFIX' question open, so we leave
the PREFIX code as it is.

This fixes regression case mk14, which now fails as it should.

This is just a bug-fix. Some more correct (and faster) code should
probably be substituted. Namely, right now, the suffix code is too
greedy, whereas it should test for explicit rules earlier, and not
even bother instantiating implicit rules from templates when they
duplicate actual existing rules.

ok millert@@
@
text
@d515 1
a515 2
	    if (pgn->type & OP_IS_SUFFIX)
		Varq_Set(IMPSRC_INDEX, cname, pgn);
@


1.30
log
@Fixed version... don't see how this could work on i386, since it didn't
initialize create in main.c.
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.29 2001/11/11 06:02:06 deraadt Exp $	*/
d515 2
a516 1
	    Varq_Set(IMPSRC_INDEX, cname, pgn);
@


1.29
log
@undo changes that crash on (at least) the alpha
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.27 2001/05/29 12:53:42 espie Exp $	*/
d784 1
a784 1
    Lst_Init(&toBeMade);
@


1.28
log
@Redo LstInit as a macro: smaller and faster code in all cases, zeroing two
pointers is simpler than calling a function.
Recognize purely static lst headers, which don't really need any
initialization.
ok miod@@
@
text
@d784 1
a784 1
    Static_Lst_Init(&toBeMade);
@


1.27
log
@Take includes out of lst.h, re-add what's needed to separate files.
Removes remaining lint stuff from lst.lib.
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.26 2001/05/23 12:34:46 espie Exp $	*/
d784 1
a784 1
    Lst_Init(&toBeMade);
@


1.26
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: make.c,v 1.7 1998/12/05 00:06:28 espie Exp $	*/
d76 1
@


1.25
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d50 3
a52 2
 *				whatever needs recreating. Returns TRUE if
 *				work was (or would have been) done and FALSE
d76 15
a90 15
#include    <stddef.h>
#include    "make.h"
#include    "ohash.h"
#include    "dir.h"
#include    "job.h"

#ifndef lint
#if 0
static char sccsid[] = "@@(#)make.c	8.1 (Berkeley) 6/6/93";
#else
UNUSED
static char rcsid[] = "$OpenBSD: make.c,v 1.7 1998/12/05 00:06:28 espie Exp $";
#endif
#endif /* not lint */

d99 1
a99 1
				 * TRUE, there's a cycle in the graph */
d105 1
a105 1
static Boolean MakeStartJobs(void);
d123 1
a123 1
    if (is_before(pgn->cmtime, cgn->mtime))
d147 1
a147 1
 *	TRUE if the node is out of date. FALSE otherwise.
d154 1
a154 1
Boolean
d158 1
a158 1
    Boolean	    oodate;
d197 1
a197 1
	oodate = FALSE;
d232 2
a233 2
	oodate = TRUE;
    } else if (is_before(gn->mtime, gn->cmtime) ||
d245 1
a245 1
	    if (is_before(gn->mtime, gn->cmtime)) {
d253 1
a253 1
	oodate = TRUE;
d262 1
a262 1
	oodate = FALSE;
d283 1
a283 1
 *	It will only add the child if its make field is FALSE.
d339 1
a339 1
	    if (Lst_AddNew(&pgn->children, gn) == SUCCESS) {
d477 2
a478 2
		    pgn->childMade = TRUE;
		    if (is_before(pgn->cmtime, cgn->mtime))
d562 2
a563 2
	} else if (is_before(pgn->mtime, cgn->mtime) ||
		   (!is_before(cgn->mtime, now) && cgn->made == MADE))
d628 1
a628 1
 *	returns TRUE. At all other times, this function returns FALSE.
d635 1
a635 1
static Boolean
d678 1
a678 1
		return TRUE;
d700 1
a700 1
    return FALSE;
d722 1
a722 1
    Boolean	cycle = *(Boolean *)cyclep;
d727 1
a727 1
	    Boolean t = TRUE;
d767 1
a767 1
 *	TRUE if work was done. FALSE otherwise.
d775 1
a775 1
Boolean
d798 1
a798 1
	    gn->make = TRUE;
d859 1
a859 1
    return TRUE;
@


1.24
log
@Change the time stamp interface to use an abstract datatype.
Define two possible interfaces: the classic one,
and the new one (used where available) that depends on timespec.

Better granularity, make is now able to distinguish between files that
were built during the same second.
@
text
@d1 2
a2 1
/*	$OpenBSD: make.c,v 1.23 2000/09/14 13:52:42 espie Exp $	*/
d49 19
a67 19
 *	Make_Run 	    	Initialize things for the module and recreate
 *	    	  	    	whatever needs recreating. Returns TRUE if
 *	    	    	    	work was (or would have been) done and FALSE
 *	    	  	    	otherwise.
 *
 *	Make_Update	    	Update all parents of a given child. Performs
 *	    	  	    	various bookkeeping chores like the updating
 *	    	  	    	of the cmtime field of the parent, filling
 *	    	  	    	of the IMPSRC context variable, etc. It will
 *	    	  	    	place the parent on the toBeMade queue if it
 *	    	  	    	should be.
 *
 *	Make_TimeStamp	    	Function to set the parent's cmtime field
 *	    	  	    	based on a child's modification time.
 *
 *	Make_DoAllVar	    	Set up the various local variables for a
 *	    	  	    	target, including the .ALLSRC variable, making
 *	    	  	    	sure that any variable that needs to exist
 *	    	  	    	at the very least has the empty value.
d69 1
a69 1
 *	Make_OODate 	    	Determine if a target is out-of-date.
d86 1
a86 1
static char rcsid[] = "$OpenBSD: make.c,v 1.23 2000/09/14 13:52:42 espie Exp $";
d90 2
a91 1
static LIST     toBeMade;	/* The current fringe of the graph. These
d96 1
a96 1
static int  	numNodes;   	/* Number of nodes to be processed. If this
d100 6
a105 6
static void MakeAddChild __P((void *, void *));
static void MakeAddAllSrc __P((void *, void *));
static void MakeTimeStamp __P((void *, void *));
static void MakeHandleUse __P((void *, void *));
static Boolean MakeStartJobs __P((void));
static void MakePrintStatus __P((void *, void *));
d110 1
a110 1
 *	child. Called from MakeOODate via Lst_ForEach.
d119 2
a120 2
    GNode *pgn;	/* the current parent */
    GNode *cgn;	/* the child we've just examined */
d126 1
a126 1
/* Wrapper to call Make_TimeStamp from a forEach loop */
d134 1
a134 1

d154 2
a155 2
Make_OODate (gn)
    register GNode *gn;	      /* the node to check */
d157 1
a157 1
    Boolean         oodate;
d167 1
a167 1
		printf ("modified %s...", Targ_FmtTime(gn->mtime));
d169 1
a169 1
		printf ("non-existent...");
d206 1
a206 1
	oodate = Arch_LibOODate (gn) ||
d275 1
a275 1
    return (oodate);
d277 1
a277 1

d293 2
a294 2
    GNode          *gn = (GNode *)gnp;
    Lst            l = (Lst)lp;
d299 1
a299 1

d323 1
a323 1
    GNode   	*pgn;	/* The target of the .USE node */
d325 2
a326 2
    GNode	*gn; 	/* A child of the .USE node */
    LstNode	ln; 	/* An element in the children list */
d330 2
a331 4
	    /*
	     * .USE or transformation and target has no commands -- append
	     * the child's commands to the parent.
	     */
d335 1
a335 2
	Lst_Open(&cgn->children);
	while ((ln = Lst_Next(&cgn->children)) != NULL) {
d338 1
a338 2
	    if (Lst_Member(&pgn->children, gn) == NULL) {
		Lst_AtEnd(&pgn->children, gn);
a342 1
	Lst_Close(&cgn->children);
d365 1
a365 1

d368 1
a368 1
 * Make_Update  --
d380 1
a380 1
 * 	If the child was made, the parent's childMade field will be set true
d392 2
a393 2
Make_Update (cgn)
    register GNode *cgn;	/* the child node */
d395 3
a397 3
    register GNode 	*pgn;	/* the parent node */
    register char  	*cname;	/* the child's name */
    register LstNode	ln; 	/* Element in parents and iParents lists */
d416 4
a419 4
	 *  	yacc -d parse.y
	 *  	cc -c y.tab.c
	 *  	mv y.tab.o parse.o
	 *  	cmp -s y.tab.h parse.h || mv y.tab.h parse.h
d455 1
a455 1
	 * Christos, 4/9/92: If we are  saving commands pretend that
d459 1
a459 1
	if (noExecute || (cgn->type & OP_SAVE_CMDS) || 
d469 1
a469 2
    Lst_Open(&cgn->parents);
    while ((ln = Lst_Next(&cgn->parents)) != NULL) {
d477 1
a477 1
		    if (is_before(pgn->cmtime, cgn->mtime)) {
a478 1
		    }
d490 1
a490 1
		Error ("Graph cycles through %s", pgn->name);
d494 1
a494 3
    Lst_Close(&cgn->parents);
    /*
     * Deal with successor nodes. If any is marked for making and has an unmade
d497 1
a497 2
     * before.
     */
d501 2
a502 3
	if (succ->make && succ->unmade == 0 && succ->made == UNMADE &&
	    Lst_Member(&toBeMade, succ) == NULL)
	    Lst_EnQueue(&toBeMade, succ);
d505 2
a506 4
    /*
     * Set the .PREFIX and .IMPSRC variables for all the implied parents
     * of this node.
     */
d510 5
a514 7
	Lst_Open(&cgn->iParents);
	while ((ln = Lst_Next(&cgn->iParents)) != NULL) {
	    pgn = (GNode *)Lst_Datum (ln);
	    if (pgn->make) {
		Varq_Set(IMPSRC_INDEX, cname, pgn);
		Varq_Set(PREFIX_INDEX, cpref, pgn);
	    }
d516 1
a516 1
	Lst_Close(&cgn->iParents);
d519 1
a519 1

d539 2
a540 2
    void *cgnp;		/* The child to add */
    void *pgnp;		/* The parent to whose ALLSRC variable it should be */
d543 2
a544 2
    GNode	*cgn = (GNode *) cgnp;
    GNode	*pgn = (GNode *) pgnp;
d546 1
a546 1
	char *child;
d553 1
a553 1
	    child = cgn->path ? cgn->path : cgn->name;
d558 1
a558 1
	    if (cgn->made == MADE)
d560 1
d584 1
a584 1

a597 3
 * Results:
 *	None
 *
d601 1
a601 1
 * 	match its ALLSRC variable.
d605 1
a605 1
Make_DoAllVar (gn)
d610 1
a610 1
    if (!Varq_Exists(OODATE_INDEX, gn))
d612 1
a612 1
    if (!Varq_Exists(ALLSRC_INDEX, gn))
d618 1
a618 1

a631 1
 *
d635 1
a635 1
MakeStartJobs ()
d637 1
a637 1
    register GNode	*gn;
d641 1
a641 1
	    printf ("Examining %s...", gn->name);
d661 1
a661 1
	     * If ln isn't null, there's a predecessor as yet unmade, so we
d672 1
a672 1
	if (Make_OODate (gn)) {
d674 1
a674 1
		printf ("out-of-date\n");
d677 1
a677 1
		return (TRUE);
d679 2
a680 2
	    Make_DoAllVar (gn);
	    Job_Make (gn);
d683 1
a683 1
		printf ("up-to-date\n");
d693 1
a693 1
		Make_DoAllVar (gn);
d696 1
a696 1
	    Make_Update (gn);
d699 1
a699 1
    return (FALSE);
d701 1
a701 1

d708 3
d715 2
a716 2
    void 	*gnp;	    /* Node to examine */
    void 	*cyclep;    /* True if gn->unmade being non-zero implies
d720 2
a721 2
    GNode   	*gn = (GNode *) gnp;
    Boolean 	cycle = *(Boolean *) cyclep;
d723 1
a723 1
	printf ("`%s' is up to date.\n", gn->name);
d747 1
a747 1
	    printf ("`%s' not remade because of errors.\n", gn->name);
d751 1
a751 1

d776 1
a776 1
    Lst             targs;	/* the initial list of targets */
d778 3
a780 3
    register GNode  *gn;	/* a temporary pointer */
    LIST    examine; 		/* List of targets to examine */
    int	    	    errors; 	/* Number of errors the Job module reports */
a795 1

d805 1
a805 1
	    Suff_FindDeps (gn);
a814 2
    Lst_Destroy(&examine, NOFREE);

d821 1
a821 1
	return (MakeStartJobs());
d830 1
a830 1
	(void) MakeStartJobs();
d843 3
a845 3
    while (!Job_Empty ()) {
	Job_CatchOutput ();
	Job_CatchChildren (!usePipes);
d855 1
a855 1
    errors = ((errors == 0) && (numNodes != 0));
d858 1
a858 1
    return (TRUE);
@


1.23
log
@Introduce a few macros to handle timestamps in an abstract way.

Replace the time stamp hash in dir.c with an open hashing structure.

In doing so, remove some nasty casts, simplify code a bit:
Dir_MTime can return a modification time, since make does not make
a distinction between out-of-date and non-existent files.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.22 2000/09/14 13:46:45 espie Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: make.c,v 1.22 2000/09/14 13:46:45 espie Exp $";
a109 3
 * Results:
 *	Always returns 0.
 *
d120 1
a120 1
    if (cgn->mtime > pgn->cmtime)
d124 1
d205 1
a205 1
	    (gn->cmtime == OUT_OF_DATE && (gn->type & OP_DOUBLEDEP));
d230 3
a232 3
    } else if (gn->mtime < gn->cmtime ||
	       (gn->cmtime == OUT_OF_DATE &&
		(gn->mtime == OUT_OF_DATE || (gn->type & OP_DOUBLEDEP))))
d242 1
a242 1
	    if (gn->mtime < gn->cmtime) {
d244 1
a244 1
	    } else if (gn->mtime == OUT_OF_DATE) {
d481 1
a481 1
		    if (pgn->cmtime < cgn->mtime) {
d485 1
a485 1
		    (void)Make_TimeStamp (pgn, cgn);
d573 2
a574 2
	} else if ((pgn->mtime < cgn->mtime) ||
		   (cgn->mtime >= now && cgn->made == MADE))
@


1.22
log
@Replace the old hash used to hold file names within a directory with
open hashing.

An interesting optimization is that the open hashing interface is more
fine-grained, hence we can compute the correct hash value at the start
of Dir_FindFile, and reuse it for each hash structure into which we look
(the effect is measurable on large directories along with objdir/VPATH).

Remove a few unnecessary Lst_Open/Lst_Close that serve no purpose except
obfuscating the code.

The interface to dir.h changes slightly, hence tedious includes changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.21 2000/09/14 13:32:07 espie Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: make.c,v 1.21 2000/09/14 13:32:07 espie Exp $";
d164 1
a164 1
	(void) Dir_MTime (gn);
d166 1
a166 1
	    if (gn->mtime != OUT_OF_DATE) {
d464 2
a465 1
	if (noExecute || (cgn->type & OP_SAVE_CMDS) || Dir_MTime(cgn) == FALSE) {
@


1.21
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.20 2000/06/23 16:18:09 espie Exp $	*/
d74 1
d76 1
a76 1
#include    "hash.h"
d85 1
a85 1
static char rcsid[] = "$OpenBSD: make.c,v 1.20 2000/06/23 16:18:09 espie Exp $";
@


1.20
log
@Start of variable fixes and speed-ups.

This patch may seem a bit non-sensical at first. It simply introduces some
new interface. Specifically, recognizes that some variable names
(.TARGET/$@@, .OODATE/$?, .ALLSRC/$>, .IMPSRC/$<, .PREFIX/$*, .ARCHIVE/$!,
.MEMBER/$%) are `special' (the actual variables which are local to a
target, e.g. GNode).

Currently, The Varq functions (for Varquick access) are only stubs to the
normal functions.

This fixes a very important detail before proceeding to turn variable lists
into hash tables: if every GNode holds a hash table, initialization times
for those will be very costly. But generic GNodes only hold those seven
special variables... which can be stored directly into a small array;
the only general cases are the environment, the command line and
global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.19 2000/06/23 16:15:50 espie Exp $	*/
a41 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)make.c	8.1 (Berkeley) 6/6/93";
#else
static char rcsid[] = "$OpenBSD: make.c,v 1.19 2000/06/23 16:15:50 espie Exp $";
#endif
#endif /* not lint */

d78 9
@


1.19
log
@Trivial consequences of the previous list changes:

- audit code for Lst_Datum, it's never applied to an empty pointer,
so check can be removed -> turn into a macro,
- Lst_First, Lst_Last can become macro as well
- specialized version of Lst_Succ (Lst_Adv) to use in loops where it cannot
fail,
- Lst_Open can no longer fail. Trim down corresponding code.

Reviewed millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.18 2000/06/17 14:43:36 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.18 2000/06/17 14:43:36 espie Exp $";
d402 1
a402 1
    cname = Var_Value(TARGET, cgn);
d518 1
a518 1
    char	*cpref = Var_Value(PREFIX, cgn);
d524 2
a525 2
		Var_Set (IMPSRC, cname, pgn);
		Var_Set (PREFIX, cpref, pgn);
d561 1
a561 1
	    (child = Var_Value(TARGET, cgn)) == NULL) {
d568 1
a568 1
	Var_Append (ALLSRC, child, pgn);
d570 2
a571 3
	    if (cgn->made == MADE) {
		Var_Append(OODATE, child, pgn);
	    }
d591 1
a591 1
	    Var_Append(OODATE, child, pgn);
d624 4
a627 6
    if (!Var_Exists (OODATE, gn)) {
	Var_Set (OODATE, "", gn);
    }
    if (!Var_Exists (ALLSRC, gn)) {
	Var_Set (ALLSRC, "", gn);
    }
d630 1
a630 1
	Var_Set(TARGET, Var_Value(ALLSRC, gn), gn);
@


1.18
log
@This removes the few instances of Lst_New left.
- replaces Lst_Duplicate with Lst_Clone, which does not allocate storage
- split Lst_Concat into Lst_Concat/Lst_ConcatDestroy
Thus, all the LstValid checks are gone, since we always invoke list
functions with valid pointers.

Note that dynamic list allocation accounted for roughly 20% of all calls
to malloc.  The extraneous calls to malloc left are now mostly in parse.c,
which makes some wasteful usage of temporary buffers.

With those few patches, the code is sturdier, and easier to maintain.

Reviewed by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.17 2000/06/17 14:38:18 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.17 2000/06/17 14:38:18 espie Exp $";
d335 8
a342 9
	if (Lst_Open(&cgn->children) == SUCCESS) {
	    while ((ln = Lst_Next(&cgn->children)) != NULL) {
		gn = (GNode *)Lst_Datum (ln);

		if (Lst_Member(&pgn->children, gn) == NULL) {
		    Lst_AtEnd(&pgn->children, gn);
		    Lst_AtEnd(&gn->parents, pgn);
		    pgn->unmade += 1;
		}
a343 1
	    Lst_Close(&cgn->children);
d345 1
d471 11
a481 14
    if (Lst_Open(&cgn->parents) == SUCCESS) {
	while ((ln = Lst_Next(&cgn->parents)) != NULL) {
	    pgn = (GNode *)Lst_Datum (ln);
	    if (pgn->make) {
		pgn->unmade -= 1;

		if ( ! (cgn->type & (OP_EXEC|OP_USE))) {
		    if (cgn->made == MADE) {
			pgn->childMade = TRUE;
			if (pgn->cmtime < cgn->mtime) {
			    pgn->cmtime = cgn->mtime;
			}
		    } else {
			(void)Make_TimeStamp (pgn, cgn);
d483 2
d486 9
a494 9
		if (pgn->unmade == 0) {
		    /*
		     * Queue the node up -- any unmade predecessors will
		     * be dealt with in MakeStartJobs.
		     */
		    Lst_EnQueue(&toBeMade, pgn);
		} else if (pgn->unmade < 0) {
		    Error ("Graph cycles through %s", pgn->name);
		}
a496 1
	Lst_Close(&cgn->parents);
d498 1
d505 1
a505 1
    for (ln = Lst_First(&cgn->successors); ln != NULL; ln = Lst_Succ(ln)) {
d517 2
a518 2
    if (Lst_Open(&cgn->iParents) == SUCCESS) {
	char	*cpref = Var_Value(PREFIX, cgn);
d520 1
d668 1
a668 1
	    for (ln = Lst_First(&gn->preds); ln != NULL; ln = Lst_Succ(ln)){
@


1.17
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.16 2000/06/10 01:41:05 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.16 2000/06/10 01:41:05 espie Exp $";
d332 1
a332 1
	    Lst_Concat(&pgn->commands, &cgn->commands, LST_CONCNEW);
d795 1
a795 1
    register Lst    examine; 	/* List of targets to examine */
d800 1
a800 1
    examine = Lst_Duplicate(targs, NOCOPY);
d811 1
a811 1
    while ((gn = (GNode *)Lst_DeQueue(examine)) != NULL) {
d825 1
a825 1
		Lst_ForEach(&gn->children, MakeAddChild, examine);
d832 1
a832 1
    Lst_Delete(examine, NOFREE);
@


1.16
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.15 2000/06/10 01:32:23 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.15 2000/06/10 01:32:23 espie Exp $";
d87 1
a87 1
static Lst     	toBeMade;	/* The current fringe of the graph. These
d271 1
a271 1
	Lst_ForEach(gn->parents, MakeTimeStamp, gn);
d327 1
a327 1
	if ((cgn->type & OP_USE) || Lst_IsEmpty(pgn->commands)) {
d332 1
a332 1
	    Lst_Concat (pgn->commands, cgn->commands, LST_CONCNEW);
d335 2
a336 2
	if (Lst_Open (cgn->children) == SUCCESS) {
	    while ((ln = Lst_Next (cgn->children)) != NULL) {
d339 3
a341 3
		if (Lst_Member (pgn->children, gn) == NULL) {
		    Lst_AtEnd(pgn->children, gn);
		    Lst_AtEnd(gn->parents, pgn);
d345 1
a345 1
	    Lst_Close (cgn->children);
d436 1
a436 1
	if (!Lst_IsEmpty(cgn->commands) || Lst_IsEmpty(cgn->children)) {
d472 2
a473 2
    if (Lst_Open (cgn->parents) == SUCCESS) {
	while ((ln = Lst_Next (cgn->parents)) != NULL) {
d493 1
a493 1
		    Lst_EnQueue(toBeMade, pgn);
d499 1
a499 1
	Lst_Close (cgn->parents);
d507 1
a507 1
    for (ln = Lst_First(cgn->successors); ln != NULL; ln = Lst_Succ(ln)) {
d511 2
a512 4
	    Lst_Member(toBeMade, succ) == NULL)
	{
	    Lst_EnQueue(toBeMade, succ);
	}
d519 1
a519 1
    if (Lst_Open (cgn->iParents) == SUCCESS) {
d522 1
a522 1
	while ((ln = Lst_Next (cgn->iParents)) != NULL) {
d529 1
a529 1
	Lst_Close (cgn->iParents);
d624 1
a624 1
    Lst_ForEach(gn->children, MakeAddAllSrc, gn);
d658 1
a658 1
    while (!Job_Full() && (gn = (GNode *)Lst_DeQueue(toBeMade)) != NULL) {
d666 1
a666 1
	if (!Lst_IsEmpty(gn->preds)) {
d669 1
a669 1
	    for (ln = Lst_First(gn->preds); ln != NULL; ln = Lst_Succ(ln)){
d756 1
a756 1
		Lst_ForEach(gn->children, MakePrintStatus, &t);
d760 1
a760 1
		Lst_ForEach(gn->children, MakePrintStatus, &t);
d791 1
a791 1
Make_Run (targs)
d798 1
a798 1
    toBeMade = Lst_Init();
d821 1
a821 1
	    Lst_ForEach (gn->children, MakeHandleUse, gn);
d825 1
a825 1
		Lst_ForEach (gn->children, MakeAddChild, examine);
d827 1
a827 1
		Lst_EnQueue(toBeMade, gn);
d832 1
a832 1
    Lst_Destroy(examine, NOFREE);
@


1.15
log
@Thus, Lst_ForEach no longer needs returning a status.
In fact, it can become a macro based on Lst_ForEachFrom.
This also introduces Lst_Every, as a shortcut for the very common case where
Lst_ForEach does not need any user data.

Finally,  make consistent use of a few function typedefs, instead of having
explicit void (*)(Lst)  arguments all over the place.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.14 2000/03/26 16:21:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.14 2000/03/26 16:21:32 espie Exp $";
d96 4
a99 4
static void MakeAddChild __P((ClientData, ClientData));
static void MakeAddAllSrc __P((ClientData, ClientData));
static void MakeTimeStamp __P((ClientData, ClientData));
static void MakeHandleUse __P((ClientData, ClientData));
d101 1
a101 1
static void MakePrintStatus __P((ClientData, ClientData));
d127 2
a128 2
    ClientData pgn;	/* the current parent */
    ClientData cgn;	/* the child we've just examined */
d288 2
a289 2
    ClientData     gnp;		/* the node to add */
    ClientData     lp;		/* the list to which to add it */
d364 2
a365 2
    ClientData pgn;	/* the current parent */
    ClientData cgn;	/* the child we've just examined */
d554 2
a555 2
    ClientData	cgnp;	/* The child to add */
    ClientData	pgnp;	/* The parent to whose ALLSRC variable it should be */
d733 2
a734 2
    ClientData  gnp;	    /* Node to examine */
    ClientData 	cyclep;	    /* True if gn->unmade being non-zero implies
@


1.14
log
@Remove idiotic, braindead casts T* -> void*
They serve no purpose, except hiding potential bugs.

In particular, remove (ClientData) cast from macro, showing potentially
troublesome use of Hashes to store time_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.13 2000/02/02 13:47:48 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.13 2000/02/02 13:47:48 espie Exp $";
d96 4
a99 4
static int MakeAddChild __P((ClientData, ClientData));
static int MakeAddAllSrc __P((ClientData, ClientData));
static int MakeTimeStamp __P((ClientData, ClientData));
static int MakeHandleUse __P((ClientData, ClientData));
d101 1
a101 1
static int MakePrintStatus __P((ClientData, ClientData));
d116 2
a117 2
int
Make_TimeStamp (pgn, cgn)
d121 1
a121 1
    if (cgn->mtime > pgn->cmtime) {
a122 2
    }
    return (0);
d125 2
a126 2
static int
MakeTimeStamp (pgn, cgn)
d130 1
a130 1
    return Make_TimeStamp((GNode *) pgn, (GNode *) cgn);
d270 1
a270 1
    if (!oodate) {
a271 1
    }
a281 3
 * Results:
 *	Always returns 0
 *
d286 2
a287 2
static int
MakeAddChild (gnp, lp)
d291 2
a292 2
    GNode          *gn = (GNode *) gnp;
    Lst            l = (Lst) lp;
d294 1
a294 1
    if (!gn->make && !(gn->type & OP_USE)) {
a295 2
    }
    return (0);
a311 3
 * Results:
 *	returns 0.
 *
d318 4
a321 4
int
Make_HandleUse (cgn, pgn)
    register GNode	*cgn;	/* The .USE node */
    register GNode   	*pgn;	/* The target of the .USE node */
d323 2
a324 2
    register GNode	*gn; 	/* A child of the .USE node */
    register LstNode	ln; 	/* An element in the children list */
a360 1
    return (0);
d362 2
a363 2
static int
MakeHandleUse (pgn, cgn)
d367 1
a367 1
    return Make_HandleUse((GNode *) pgn, (GNode *) cgn);
a547 3
 * Results:
 *	Always returns 0
 *
d552 2
a553 2
static int
MakeAddAllSrc (cgnp, pgnp)
a597 1
    return (0);
a728 7
 *
 * Results:
 *	Always returns 0.
 *
 * Side Effects:
 *	A message may be printed.
 *
d731 1
a731 1
static int
a767 1
    return (0);
d834 1
a834 1
    Lst_Destroy (examine, NOFREE);
@


1.13
log
@Bug-fix: make should behave sensibly when presented with negative times...

- let *_MTime return booleans, as that's what they're used for, the time_t
is set as a side effect.

- use OUT_OF_DATE for a date starting point, set it at the origin of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.12 1999/12/18 21:58:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.12 1999/12/18 21:58:07 espie Exp $";
d273 1
a273 1
	Lst_ForEach (gn->parents, MakeTimeStamp, (ClientData)gn);
d301 1
a301 1
	Lst_EnQueue(l, (ClientData)gn);
d505 1
a505 1
		    (void)Lst_EnQueue (toBeMade, (ClientData)pgn);
d523 1
a523 1
	    Lst_Member(toBeMade, (ClientData)succ) == NULL)
d525 1
a525 1
	    Lst_EnQueue(toBeMade, (ClientData)succ);
d642 1
a642 1
    Lst_ForEach (gn->children, MakeAddAllSrc, (ClientData) gn);
d781 1
a781 1
		Lst_ForEach(gn->children, MakePrintStatus, (ClientData) &t);
d785 1
a785 1
		Lst_ForEach(gn->children, MakePrintStatus, (ClientData) &t);
d847 1
a847 1
	    Lst_ForEach (gn->children, MakeHandleUse, (ClientData)gn);
d851 1
a851 1
		Lst_ForEach (gn->children, MakeAddChild, (ClientData)examine);
d853 1
a853 1
		Lst_EnQueue(toBeMade, (ClientData)gn);
d901 1
a901 1
    Lst_ForEach(targs, MakePrintStatus, (ClientData) &errors);
@


1.12
log
@Nothing ever checks ReturnStatus on Lst_Insert, Lst_Append, Lst_AtFront,
Lst_AtEnd, Lst_Concat, Lst_Remove, Lst_Replace.

Don't bother returning one.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.11 1999/12/18 21:56:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.11 1999/12/18 21:56:07 espie Exp $";
d166 1
a166 1
	    if (gn->mtime != 0) {
d207 1
a207 1
	    ((gn->cmtime == 0) && (gn->type & OP_DOUBLEDEP));
d232 3
a234 3
    } else if ((gn->mtime < gn->cmtime) ||
	       ((gn->cmtime == 0) &&
		((gn->mtime==0) || (gn->type & OP_DOUBLEDEP))))
d238 2
a239 2
	 * youngest child or that has no children (cmtime == 0) and
	 * either doesn't exist (mtime == 0) or was the object of a
d246 1
a246 1
	    } else if (gn->mtime == 0) {
d475 1
a475 1
	if (noExecute || (cgn->type & OP_SAVE_CMDS) || Dir_MTime(cgn) == 0) {
@


1.11
log
@Lst_DeQueue already checks for empty lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.10 1999/12/18 21:53:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.10 1999/12/18 21:53:32 espie Exp $";
d301 1
a301 1
	(void)Lst_EnQueue (l, (ClientData)gn);
d343 1
a343 1
	    (void) Lst_Concat (pgn->commands, cgn->commands, LST_CONCNEW);
d351 2
a352 2
		    (void) Lst_AtEnd (pgn->children, gn);
		    (void) Lst_AtEnd (gn->parents, pgn);
d525 1
a525 1
	    (void)Lst_EnQueue(toBeMade, (ClientData)succ);
d853 1
a853 1
		(void)Lst_EnQueue (toBeMade, (ClientData)gn);
@


1.10
log
@NIL, NILGNODE, etc, are only glorified NULL.
Get rid of them.

Get rid of list.h, nothing uses it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.9 1999/12/18 02:11:27 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.9 1999/12/18 02:11:27 espie Exp $";
d676 1
a676 2
    while (!Job_Full() && !Lst_IsEmpty (toBeMade)) {
	gn = (GNode *) Lst_DeQueue (toBeMade);
d837 1
a837 2
    while (!Lst_IsEmpty (examine)) {
	gn = (GNode *) Lst_DeQueue (examine);
@


1.9
log
@make does not use circular lists, get rid of the extra weight.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.8 1999/12/06 22:28:44 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.8 1999/12/06 22:28:44 espie Exp $";
d347 1
a347 1
	    while ((ln = Lst_Next (cgn->children)) != NILLNODE) {
d350 1
a350 1
		if (Lst_Member (pgn->children, gn) == NILLNODE) {
d485 1
a485 1
	while ((ln = Lst_Next (cgn->parents)) != NILLNODE) {
d519 1
a519 1
    for (ln = Lst_First(cgn->successors); ln != NILLNODE; ln = Lst_Succ(ln)) {
d523 1
a523 1
	    Lst_Member(toBeMade, (ClientData)succ) == NILLNODE)
d536 1
a536 1
	while ((ln = Lst_Next (cgn->iParents)) != NILLNODE) {
d688 1
a688 1
	    for (ln = Lst_First(gn->preds); ln != NILLNODE; ln = Lst_Succ(ln)){
d699 1
a699 1
	     * If ln isn't nil, there's a predecessor as yet unmade, so we
d704 1
a704 1
	    if (ln != NILLNODE) {
@


1.8
log
@Extra parameter no longer needed, ditch.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.7 1998/12/05 00:06:28 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.7 1998/12/05 00:06:28 espie Exp $";
d825 1
a825 1
    toBeMade = Lst_Init (FALSE);
@


1.7
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: make.c,v 1.5 1997/04/01 07:28:17 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.5 1997/04/01 07:28:17 millert Exp $";
a413 1
    char *p1;
d415 1
a415 2
    cname = Var_Value (TARGET, cgn, &p1);
    efree(p1);
d534 1
a534 2
	char    *p1;
	char	*cpref = Var_Value(PREFIX, cgn, &p1);
a542 1
	efree(p1);
a576 1
	char *p1 = NULL;
d579 1
a579 1
	    (child = Var_Value(TARGET, cgn, &p1)) == NULL) {
a611 1
	efree(p1);
d651 2
a652 5
    if (gn->type & OP_JOIN) {
	char *p1;
	Var_Set (TARGET, Var_Value (ALLSRC, gn, &p1), gn);
	efree(p1);
    }
@


1.6
log
@Back out newer .USE code as it caused problems.  I've done a "make build"
without problems and the problem Theo saw before is gone.
@
text
@d132 1
a132 1
    return (Make_TimeStamp((GNode *) pgn, (GNode *) cgn));
d379 1
a379 1
    return (Make_HandleUse((GNode *) pgn, (GNode *) cgn));
d417 1
a417 2
    if (p1)
	free(p1);
d546 1
a546 2
	if (p1)
	    free(p1);
d617 1
a617 2
	if (p1)
	    free(p1);
d660 1
a660 2
	if (p1)
	    free(p1);
d905 1
a905 1
    errors = Job_End();
@


1.5
log
@Sync with NetBSD (mostly by christos initial substitution/regexp from Der Mouse)

- fix the variable substitution code in make [PR/2748]
      1. change s/a/b/ so that it substitutes the first occurance of the
         pattern on each word, not only the first word.
      2. add flag '1' to the variable substitution so that the substitutions
         get performed only once.

  ***THIS IS AN INCOMPATIBLE CHANGE!***

  Unfortunately there was no way to make things consistent without
  modifying the current behavior. Fortunately none of our Makefiles
  depended on this.

            OLD:

                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4

            NEW:
                VAR      = aa1 aa2 aa3 aa4

                S/a/b/   = ba1 ba2 ba3 ba4
                S/a/b/1  = ba1 aa2 aa3 aa4
                S/a/b/g  = bb1 bb2 bb3 bb4
                S/a/b/1g = bb1 aa2 aa3 aa4
- add regexp variable substitution via 'C/foo/bar/' [PR/2752]
- add variable quoting via the ${VAR:Q} modifier. This is useful when running
  recursive invocations of make(1):

        make VAR=${VAR:Q}

  will always work... (This may prove useful in the kernel builds...) [PR/2981]
- BSD did not traditionally have <sys/cdefs.h>; use BSD4_4 instead and include
  <sys/param.h> to grab it.
- Don't compile the regex code if MAKE_BOOTSTRAP (from gwr)
- Use explicit .c.o rule in Makefile.boot so that the bootstrap process works.
- Use only integral types in procedure arguments. [buf.c buf.h]
- Include <stdlib.h> to get getenv() prototype on SVR4
- if __STDC__ -> ifdef __STDC__ to appease SVR4
- Define const and volatile for non __STDC__
- Implement snprintf() and vsnprintf() for non BSD4_4 systems.
- Make $MACHINE_ARCH settable from the environment.
- Fix .USE directive problems: (reported by cgd)
    1. ${.*} variables did not get expanded in dependencies.
    2. expanded ${.*} variables in .USE dependencies can cause tree
       restructuring; handle it.
    3. in compat mode, expand .USE before evaluating the list of targets,
       instead of doing .USE expansions on demand, because they can cause
       tree restructuring.
- Add a .MADE directive to indicated that the children of a target are
  up-to-date, even when they are not. This is to simulate our current
  make install behavior with proper dependencies.
- Fix problems in the RE substitution error handling.
- Locate all the children of a node marked as MADE.
- Do not compile-in ${MACHINE} (as per NetBSD PR#3386)
- Disable globbing for targets/dependencies when POSIX is defined.
- Fix globbing so that patterns that don't have a matching number of [] or {}
  don't get expanded. (before the [ case got expanded to nothing!) This is
  disabled.
- Make sure that the children of nodes that are marked .MADE, are marked
  UPTODATE and their timestamps are consistent.
- Don't disable wildcards completely; they are used by other Makefiles.
@
text
@d1 2
a2 2
/*	$OpenBSD: make.c,v 1.4 1996/11/30 21:09:00 millert Exp $	*/
/*	$NetBSD: make.c,v 1.14 1997/03/28 22:31:21 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.4 1996/11/30 21:09:00 millert Exp $";
a79 3
 *
 *	Make_ExpandUse		Expand .USE nodes and return the new list of
 *				targets.
a96 1
static int MakeFindChild __P((ClientData, ClientData));
a307 30
 * MakeFindChild  --
 *	Function used by Make_Run to find the pathname of a child
 *	that was already made.
 *
 * Results:
 *	Always returns 0
 *
 * Side Effects:
 *	The path and mtime of the node and the cmtime of the parent are
 *	updated
 *-----------------------------------------------------------------------
 */
static int
MakeFindChild (gnp, pgnp)
    ClientData     gnp;		/* the node to find */
    ClientData     pgnp;
{
    GNode          *gn = (GNode *) gnp;
    GNode          *pgn = (GNode *) pgnp;

    (void) Dir_MTime(gn);
    if (pgn->cmtime < gn->mtime)
	pgn->cmtime = gn->mtime;
    gn->made = UPTODATE;

    return (0);
}

/*-
 *-----------------------------------------------------------------------
d334 1
d348 1
a348 21
		register GNode *tgn, *gn = (GNode *)Lst_Datum (ln);

		/*
		 * Expand variables in the .USE node's name
		 * and save the unexpanded form.
		 * We don't need to do this for commands.
		 * They get expanded properly when we execute.
		 */
		if (gn->uname == NULL) {
		    gn->uname = gn->name;
		} else {
		    if (gn->name)
			free(gn->name);
		}
		gn->name = Var_Subst(NULL, gn->uname, pgn, FALSE);
		if (gn->name && gn->uname && strcmp(gn->name, gn->uname) != 0) {
		    /* See if we have a target for this node. */
		    tgn = Targ_FindNode(gn->name, TARG_NOCREATE);
		    if (tgn != NILGNODE)
			gn = tgn;
		}
d368 1
a368 3
	if ((cgn->type & OP_USE) &&
	    (ln = Lst_Member (pgn->children, (ClientData) cgn)) != NILLNODE) {
	    Lst_Remove(pgn->children, ln);
d811 10
a820 2
 * Make_ExpandUse --
 *	Expand .USE nodes and create a new targets list
d822 1
a822 1
 *	The new list of targets.
d825 3
a827 1
 *	numNodes is set to the number of elements in the list of targets.
d830 2
a831 2
Lst
Make_ExpandUse (targs)
d836 1
a836 1
    register Lst    ntargs;	/* List of new targets to be made */
d838 1
a838 1
    ntargs = Lst_Init (FALSE);
a860 2
	     * Make sure that the TARGET is set, so that we can make
	     * expansions.
a861 1
	    Var_Set (TARGET, gn->name, gn);
d865 1
a865 1
	    if (gn->unmade != 0 && (gn->type & OP_MADE) == 0) {
d868 1
a868 3
		(void)Lst_EnQueue (ntargs, (ClientData)gn);
		if (gn->type & OP_MADE)
		    Lst_ForEach (gn->children, MakeFindChild, (ClientData)gn);
a873 31
    return (ntargs); 
}

/*-
 *-----------------------------------------------------------------------
 * Make_Run --
 *	Initialize the nodes to remake and the list of nodes which are
 *	ready to be made by doing a breadth-first traversal of the graph
 *	starting from the nodes in the given list. Once this traversal
 *	is finished, all the 'leaves' of the graph are in the toBeMade
 *	queue.
 *	Using this queue and the Job module, work back up the graph,
 *	calling on MakeStartJobs to keep the job table as full as
 *	possible.
 *
 * Results:
 *	TRUE if work was done. FALSE otherwise.
 *
 * Side Effects:
 *	The make field of all nodes involved in the creation of the given
 *	targets is set to 1. The toBeMade list is set to contain all the
 *	'leaves' of these subgraphs.
 *-----------------------------------------------------------------------
 */
Boolean
Make_Run (targs)
    Lst             targs;	/* the initial list of targets */
{
    int	    	    errors; 	/* Number of errors the Job module reports */

    toBeMade = Make_ExpandUse (targs);
@


1.4
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 2
a2 2
/*	$OpenBSD: make.c,v 1.3 1996/09/02 16:04:14 briggs Exp $	*/
/*	$NetBSD: make.c,v 1.10 1996/11/06 17:59:15 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.3 1996/09/02 16:04:14 briggs Exp $";
d78 1
a78 1
 *	Make_HandleUse	    	See if a child is a .USE node for a parent
d80 3
d100 1
d136 1
a136 1
    return Make_TimeStamp((GNode *) pgn, (GNode *) cgn);
d303 1
d309 27
d337 3
a367 1
    register GNode	*gn;	/* A child of the .USE node */
d381 21
a401 1
		gn = (GNode *)Lst_Datum (ln);
d421 4
a424 2
	if (cgn->type & OP_USE) {
	    pgn->unmade -= 1;
d434 1
a434 1
    return Make_HandleUse((GNode *) pgn, (GNode *) cgn);
d640 2
a641 1
	if (OP_NOP(cgn->type)) {
d647 1
a647 2
	else
	    child = Var_Value(TARGET, cgn, &p1);
d863 1
d866 2
a867 10
 * Make_Run --
 *	Initialize the nodes to remake and the list of nodes which are
 *	ready to be made by doing a breadth-first traversal of the graph
 *	starting from the nodes in the given list. Once this traversal
 *	is finished, all the 'leaves' of the graph are in the toBeMade
 *	queue.
 *	Using this queue and the Job module, work back up the graph,
 *	calling on MakeStartJobs to keep the job table as full as
 *	possible.
 *
d869 1
a869 1
 *	TRUE if work was done. FALSE otherwise.
d872 1
a872 3
 *	The make field of all nodes involved in the creation of the given
 *	targets is set to 1. The toBeMade list is set to contain all the
 *	'leaves' of these subgraphs.
d875 2
a876 2
Boolean
Make_Run (targs)
d881 1
a881 1
    int	    	    errors; 	/* Number of errors the Job module reports */
d883 1
a883 1
    toBeMade = Lst_Init (FALSE);
d906 2
d909 1
d913 1
a913 1
	    if (gn->unmade != 0) {
d916 3
a918 1
		(void)Lst_EnQueue (toBeMade, (ClientData)gn);
d924 31
@


1.3
log
@Sync up with NetBSD:
(christos)
	Fix bug reported by Greg Hudson where leaf (source only) nodes were
	referenced only by their basename and not by their full pathname. This
	breaks when .PATH or MAKEOBJDIR are used. There might be Makefiles
	around that try to work around this bug by prepending ${.CURDIR} to
	the sources, and they should be found and fixed. Also a lot of the gunk
	in suff.c that was attempting to work around the same problem could be
	removed.
(christos)
	- Move -D flags from Makefile to config.h and explain what they do. Add
	  -Wall -Wno-unused to CFLAGS. Add new define SYSVVARSUB to enable SysV
	  style variable substitutions and enable them.
	- Add SunOS style command substitutions via SUNSHCMD
	- Fix core dump with '{variable = value'
(christos)
	Fix bug where make will always exit with 0, even when one or more
	parallel jobs failed. (Only affects parallel make code)
(christos)
	Protect __P from being multiply defined (for systems that already
	define it)
(christos) Add strdup() since ultrix is missing it.
	From Larry Schwimmer <rosebud@@cyclone.Stanford.EDU>
(christos) Add estrdup(), a checked version of strdup and use it.
(christos) Recognize SVR4 style long filename entries in archives.
(thorpej) Tidy up some RCS ids a bit.
@
text
@d1 2
a2 2
/*	$OpenBSD: make.c,v 1.2 1996/03/27 19:32:38 niklas Exp $	*/
/*	$NetBSD: make.c,v 1.9 1996/08/30 23:21:10 christos Exp $	*/
d5 2
a6 2
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
d44 1
a44 2
static char sccsid[] = "@@(#)make.c	5.3 (Berkeley) 6/1/90";
static char rcsid[] = "$NetBSD: make.c,v 1.8 1996/03/15 21:52:37 christos Exp $";
d46 1
a46 1
static char rcsid[] = "$OpenBSD: make.c,v 1.2 1996/03/27 19:32:38 niklas Exp $";
d106 1
a106 1
 *	child. Called from MakeOODate via Lst_ForEach. 
d109 1
a109 1
 *	Always returns 0. 
d146 1
a146 1
 *	TRUE if the node is out of date. FALSE otherwise. 
d197 1
a197 1
    } else if (gn->type & OP_LIB) {
d344 1
a344 1
	
d357 1
a357 1
	
d386 1
a386 1
 *	up-to-date node. 
d485 1
a485 1
    
d530 1
a530 1
    
d687 1
a687 1
    
d720 1
a720 1
	
d745 1
a745 1
	    
d840 1
a840 1
    
d847 1
a847 1
     * and go on about our business. 
d851 1
a851 1
	
d855 1
a855 1
	    
d870 1
a870 1
    
d886 1
a886 1
	 * before going into our loop. 
d915 1
a915 1
    
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: make.c,v 1.8 1996/03/15 21:52:37 christos Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD$";
d583 1
a583 1
	char *p1;
d585 8
a592 1
	child = Var_Value(TARGET, cgn, &p1);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: make.c,v 1.7 1995/06/14 15:19:40 christos Exp $	*/
d45 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: make.c,v 1.7 1995/06/14 15:19:40 christos Exp $";
d218 1
a218 1
    } else if (gn->type & (OP_FORCE|OP_EXEC)) {
d226 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
