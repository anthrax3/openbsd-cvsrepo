head	1.46;
access;
symbols
	OPENBSD_6_1:1.46.0.12
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.8
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.4
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.46.0.6
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.45.0.6
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.43.0.2
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.42.0.12
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.10
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.8
	OPENBSD_5_0:1.42.0.6
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.4
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.40.0.4
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.39.0.6
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.4
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.37.0.2
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.30.0.12
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.10
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.8
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.6
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.4
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	OPENBSD_3_3:1.28.0.4
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.26.0.4
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2015.01.23.13.18.40;	author espie;	state Exp;
branches;
next	1.45;
commitid	iXa5WmoY9RgeqDsn;

1.45
date	2013.11.22.15.47.35;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2013.11.01.17.54.37;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2013.05.06.11.29.18;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2010.07.15.10.37.32;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2009.05.13.10.47.54;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.16.09.46.14;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2007.07.30.09.51.53;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2007.07.24.23.29.49;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2007.07.24.18.58.48;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2007.07.24.18.56.15;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.24.18.52.47;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.20.12.32.45;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2007.03.20.03.50.39;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.07.13.11.36;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.13.23.26.39;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.11.21.12.11;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.29.12.53.40;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.23.12.34.42;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.03.13.41.05;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.24.14.29.55;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.14.13.35.38;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.14.13.32.06;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.17.21.48.40;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.23.16.23.26;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.17.14.38.15;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.10.01.41.05;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.10.01.32.22;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.26.16.21.32;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	99.12.18.02.11.26;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	99.12.16.17.27.18;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	99.12.16.17.24.11;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.12.16.17.07.20;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.12.16.17.02.45;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	99.12.16.16.41.41;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	99.12.09.18.18.24;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	99.12.06.22.24.31;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	99.12.06.22.18.56;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	99.11.11.11.42.19;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	98.12.05.00.06.27;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	96.11.30.21.08.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.36.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.42;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.46
log
@remove a bunch of dangerous casts (useless casts from void * to something
else, in some cases by adding extra temporary variables.
IMO, it's much better practice to do

void *a;
int *p = a;
*p = 42;

rather than
void *a;
*(int *)a = 42;

okay miod@@... to be revisited for some possible const additions later.
@
text
@/*	$OpenBSD: for.c,v 1.45 2013/11/22 15:47:35 espie Exp $	*/
/*	$NetBSD: for.c,v 1.4 1996/11/06 17:59:05 christos Exp $ */

/*
 * Copyright (c) 1999 Marc Espie.
 *
 * Extensive code modifications for the OpenBSD project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1992, The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <assert.h>
#include <ctype.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "config.h"
#include "defines.h"
#include "buf.h"
#include "for.h"
#include "lst.h"
#include "error.h"
#include "var.h"
#include "lowparse.h"
#include "str.h"
#include "memory.h"

/*
 * For statements are of the form:
 *
 * .for <variable> [variable...] in <varlist>
 * ...
 * .endfor
 *
 * The trick is to look for the matching .end inside .for loops.
 * To do that, we keep track of the nesting level of .for loops
 * and matching .endfor statements, accumulating all statements between
 * the initial .for loop and the matching .endfor,
 * then we evaluate the .for loop for each variable in the varlist.
 */

/* State of a for loop.  */
struct For_ {
	char		*text;		/* Unexpanded text		*/
	LIST		vars;		/* List of variables		*/
	LstNode		var;		/* Current var			*/
	int		nvars;		/* Total number of vars		*/
	LIST		lst;		/* List of items		*/
	size_t		guess;		/* Estimated expansion size	*/
	BUFFER		buf;		/* Accumulating text		*/
	unsigned long	lineno; 	/* Line number at start of loop */
	unsigned long	level;		/* Nesting level		*/
	bool		freeold;
};

/* ForExec(value, handle);
 *	Expands next variable in loop sequence described by handle to value. */
static void ForExec(void *, void *);

/* n = build_words_list(lst, s);
 *	Cuts string into words, pushes words into list, in reverse order,
 *	because Parse_FromString works as a stack.
 *	Returns the number of words.  */
static unsigned long build_words_list(Lst, const char *);

static unsigned long
build_words_list(Lst lst, const char *s)
{
	const char *end, *wrd;
	unsigned long n;

	n = 0;
	end = s;

	while ((wrd = iterate_words(&end)) != NULL) {
		Lst_AtFront(lst, escape_dupi(wrd, end, "\"'"));
		n++;
	}
	return n;
}

For *
For_Eval(const char *line)
{
	const char	*ptr = line;
	const char	*wrd;
	char	*sub;
	const char	*endVar;
	For 	*arg;
	unsigned long n;

	while (ISSPACE(*ptr))
		ptr++;

	/* Parse loop.  */

	arg = emalloc(sizeof(*arg));
	arg->nvars = 0;
	Lst_Init(&arg->vars);

	for (;;) {
		/* Grab the variables.  */
		for (wrd = ptr; *ptr && !ISSPACE(*ptr); ptr++)
			continue;
		if (ptr - wrd == 0) {
			Parse_Error(PARSE_FATAL, "Syntax error in for");
			return 0;
		}
		endVar = ptr++;
		while (ISSPACE(*ptr))
			ptr++;
		/* End of variable list ? */
		if (endVar - wrd == 2 && wrd[0] == 'i' && wrd[1] == 'n')
			break;
		Lst_AtEnd(&arg->vars, Var_NewLoopVar(wrd, endVar));
		arg->nvars++;
	}
	if (arg->nvars == 0) {
		Parse_Error(PARSE_FATAL, "Missing variable in for");
		return 0;
	}

	/* Make a list with the remaining words.  */
	sub = Var_Subst(ptr, NULL, false);
	if (DEBUG(FOR)) {
		LstNode ln;
		(void)fprintf(stderr, "For: Iterator ");
		for (ln = Lst_First(&arg->vars); ln != NULL; ln = Lst_Adv(ln))
			(void)fprintf(stderr, "%s ",
			    Var_LoopVarName(Lst_Datum(ln)));
		(void)fprintf(stderr, "List %s\n", sub);
	}

	Lst_Init(&arg->lst);
	n = build_words_list(&arg->lst, sub);
	free(sub);
	if (arg->nvars != 1 && n % arg->nvars != 0) {
		LstNode ln;

		Parse_Error(PARSE_FATAL, "Wrong number of items in for loop");
		(void)fprintf(stderr, "%lu items for %d variables:", 
		    n, arg->nvars);
		for (ln = Lst_First(&arg->lst); ln != NULL; ln = Lst_Adv(ln)) {
			char *p = Lst_Datum(ln);

			(void)fprintf(stderr, " %s", p);
		}
		(void)fprintf(stderr, "\n");
		return 0;
	}
	arg->lineno = Parse_Getlineno();
	arg->level = 1;
	Buf_Init(&arg->buf, 0);

	return arg;
}


bool
For_Accumulate(For *arg, const char *line)
{
	const char *ptr = line;

	assert(arg->level > 0);

	if (*ptr == '.') {

		for (ptr++; ISSPACE(*ptr); ptr++)
			continue;

		if (strncmp(ptr, "endfor", 6) == 0 &&
		    (ISSPACE(ptr[6]) || !ptr[6])) {
			if (DEBUG(FOR))
				(void)fprintf(stderr, "For: end for %lu\n",
				    arg->level);
			/* If matching endfor, don't add line to buffer.  */
			if (--arg->level == 0)
				return false;
		}
		else if (strncmp(ptr, "for", 3) == 0 &&
		     ISSPACE(ptr[3])) {
			arg->level++;
			if (DEBUG(FOR))
				(void)fprintf(stderr, "For: new loop %lu\n",
				    arg->level);
		}
	}
	Buf_AddString(&arg->buf, line);
	Buf_AddChar(&arg->buf, '\n');
	return true;
}


#define GUESS_EXPANSION 32
static void
ForExec(void *valuep, void *argp)
{
	char *value = valuep;
	For *arg = argp;
	BUFFER buf;

	/* Parse_FromString pushes stuff back, so we need to go over vars in
	   reverse.  */
	if (arg->var == NULL) {
		arg->var = Lst_Last(&arg->vars);
		arg->text = Buf_Retrieve(&arg->buf);
		arg->freeold = false;
	}

	if (DEBUG(FOR))
		(void)fprintf(stderr, "--- %s = %s\n",
		    Var_LoopVarName(Lst_Datum(arg->var)), value);
	Buf_Init(&buf, arg->guess);
	Var_SubstVar(&buf, arg->text, Lst_Datum(arg->var), value);
	if (arg->freeold)
		free(arg->text);
	arg->text = Buf_Retrieve(&buf);
	arg->freeold = true;
	arg->var = Lst_Rev(arg->var);
	if (arg->var == NULL)
		Parse_FromString(arg->text, arg->lineno);
}


void
For_Run(For *arg)
{
	arg->text = Buf_Retrieve(&arg->buf);
	arg->guess = Buf_Size(&arg->buf) + GUESS_EXPANSION;

	arg->var = NULL;
	Lst_ForEach(&arg->lst, ForExec, arg);
	Buf_Destroy(&arg->buf);
	Lst_Destroy(&arg->vars, (SimpleProc)Var_DeleteLoopVar);
	Lst_Destroy(&arg->lst, (SimpleProc)free);
	free(arg);
}
@


1.45
log
@wrappers for is*/to* that make damn sure their arguments are
cast to unsigned chars.

okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.44 2013/11/01 17:54:37 espie Exp $	*/
d247 2
a248 2
	char *value = (char *)valuep;
	For *arg = (For *)argp;
@


1.44
log
@silence warning
okay guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.43 2013/05/06 11:29:18 espie Exp $	*/
d141 1
a141 1
	while (isspace(*ptr))
d152 1
a152 1
		for (wrd = ptr; *ptr && !isspace(*ptr); ptr++)
d159 1
a159 1
		while (isspace(*ptr))
d217 1
a217 1
		for (ptr++; isspace(*ptr); ptr++)
d221 1
a221 1
		    (isspace(ptr[6]) || !ptr[6])) {
d230 1
a230 1
		     isspace(ptr[3])) {
@


1.43
log
@actually show list of mismatched for loops when a fatal error occurs.
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.42 2010/07/19 19:46:44 espie Exp $	*/
d188 1
d192 5
a196 2
		for (ln = Lst_First(&arg->lst); ln != NULL; ln = Lst_Adv(ln))
			(void)fprintf(stderr, " %s", Lst_Datum(ln));
@


1.42
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.41 2010/07/15 10:37:32 espie Exp $	*/
d187 1
d189 5
@


1.41
log
@whitespace
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$	*/
@


1.40
log
@fix loopvar debug prints. Issue reported by naddy@@
@
text
@d179 1
a179 1
			(void)fprintf(stderr, "%s ", 
@


1.39
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: for.c,v 1.38 2007/09/16 09:46:14 espie Exp $	*/
d179 2
a180 1
			(void)fprintf(stderr, "%s ", (char *)Lst_Datum(ln));
d252 1
a252 1
		    (char *)Lst_Datum(arg->var), value);
@


1.38
log
@remove dead code: #define RECHECK is always on
@
text
@d2 1
a2 1
/*	$OpenBSD: for.c,v 1.31 2007/03/20 03:50:39 tedu Exp $	*/
d213 1
a213 1
				(void)fprintf(stderr, "For: end for %lu\n", 
d223 1
a223 1
				(void)fprintf(stderr, "For: new loop %lu\n", 
d250 1
a250 1
		(void)fprintf(stderr, "--- %s = %s\n", 
@


1.37
log
@everywhere except in Var_Parse, we always add/append variables to the
VAR_GLOBAL context, so make it the common case: rename the basic functions
to Var_Set_with_ctxt/Var_Append_with_ctxt, define Var_Set and Var_Append
as macros that specify VAR_GLOBAL, and use these.

okay miod@@
@
text
@@


1.36
log
@reindent, no binary change
@
text
@@


1.35
log
@simplify computations in the var module: instead of advancing a char *
and keeping track of a length, we just advance the char *, and ditch
the length. We can still get the length at the end of the top-level
functions to satisfy existing interfaces.

Much simpler code, less error-prone.

Okay millert@@
@
text
@d94 10
a103 10
    char		*text;		/* Unexpanded text		*/
    LIST		vars;		/* List of variables		*/
    LstNode		var;		/* Current var			*/
    int			nvars;		/* Total number of vars		*/
    LIST		lst;		/* List of items		*/
    size_t		guess;		/* Estimated expansion size	*/
    BUFFER		buf;		/* Accumulating text		*/
    unsigned long	lineno; 	/* Line number at start of loop */
    unsigned long	level;		/* Nesting level		*/
    bool		freeold;
d119 2
a120 2
    const char *end, *wrd;
    unsigned long n;
d122 2
a123 2
    n = 0;
    end = s;
d125 5
a129 5
    while ((wrd = iterate_words(&end)) != NULL) {
	Lst_AtFront(lst, escape_dupi(wrd, end, "\"'"));
	n++;
    }
    return n;
d135 46
a180 23
    const char	*ptr = line;
    const char	*wrd;
    char	*sub;
    const char	*endVar;
    For 	*arg;
    unsigned long n;

    while (isspace(*ptr))
	ptr++;

    /* Parse loop.  */

    arg = emalloc(sizeof(*arg));
    arg->nvars = 0;
    Lst_Init(&arg->vars);

    for (;;) {
	/* Grab the variables.  */
	for (wrd = ptr; *ptr && !isspace(*ptr); ptr++)
	    continue;
	if (ptr - wrd == 0) {
	    Parse_Error(PARSE_FATAL, "Syntax error in for");
	    return 0;
a181 34
	endVar = ptr++;
	while (isspace(*ptr))
	    ptr++;
	/* End of variable list ? */
	if (endVar - wrd == 2 && wrd[0] == 'i' && wrd[1] == 'n')
	    break;
	Lst_AtEnd(&arg->vars, Var_NewLoopVar(wrd, endVar));
	arg->nvars++;
    }
    if (arg->nvars == 0) {
	Parse_Error(PARSE_FATAL, "Missing variable in for");
	return 0;
    }

    /* Make a list with the remaining words.  */
    sub = Var_Subst(ptr, NULL, false);
    if (DEBUG(FOR)) {
    	LstNode ln;
	(void)fprintf(stderr, "For: Iterator ");
	for (ln = Lst_First(&arg->vars); ln != NULL; ln = Lst_Adv(ln))
		(void)fprintf(stderr, "%s ", (char *)Lst_Datum(ln));
	(void)fprintf(stderr, "List %s\n", sub);
    }

    Lst_Init(&arg->lst);
    n = build_words_list(&arg->lst, sub);
    free(sub);
    if (arg->nvars != 1 && n % arg->nvars != 0) {
	Parse_Error(PARSE_FATAL, "Wrong number of items in for loop");
    	return 0;
    }
    arg->lineno = Parse_Getlineno();
    arg->level = 1;
    Buf_Init(&arg->buf, 0);
d183 12
a194 1
    return arg;
d201 1
a201 1
    const char	    *ptr = line;
d203 1
a203 1
    assert(arg->level > 0);
d205 1
a205 1
    if (*ptr == '.') {
d207 2
a208 2
	for (ptr++; isspace(*ptr); ptr++)
	    continue;
d210 20
a229 18
	if (strncmp(ptr, "endfor", 6) == 0 &&
	    (isspace(ptr[6]) || !ptr[6])) {
	    if (DEBUG(FOR))
		(void)fprintf(stderr, "For: end for %lu\n", arg->level);
	    /* If matching endfor, don't add line to buffer.  */
	    if (--arg->level == 0)
		return false;
	}
	else if (strncmp(ptr, "for", 3) == 0 &&
		 isspace(ptr[3])) {
	    arg->level++;
	    if (DEBUG(FOR))
		(void)fprintf(stderr, "For: new loop %lu\n", arg->level);
	}
    }
    Buf_AddString(&arg->buf, line);
    Buf_AddChar(&arg->buf, '\n');
    return true;
d237 11
a247 11
    char *value = (char *)valuep;
    For *arg = (For *)argp;
    BUFFER buf;

    /* Parse_FromString pushes stuff back, so we need to go over vars in
       reverse.  */
    if (arg->var == NULL) {
    	arg->var = Lst_Last(&arg->vars);
	arg->text = Buf_Retrieve(&arg->buf);
	arg->freeold = false;
    }
d249 12
a260 12
    if (DEBUG(FOR))
	(void)fprintf(stderr, "--- %s = %s\n", (char *)Lst_Datum(arg->var),
	    value);
    Buf_Init(&buf, arg->guess);
    Var_SubstVar(&buf, arg->text, Lst_Datum(arg->var), value);
    if (arg->freeold)
    	free(arg->text);
    arg->text = Buf_Retrieve(&buf);
    arg->freeold = true;
    arg->var = Lst_Rev(arg->var);
    if (arg->var == NULL)
	Parse_FromString(arg->text, arg->lineno);
d267 2
a268 2
    arg->text = Buf_Retrieve(&arg->buf);
    arg->guess = Buf_Size(&arg->buf) + GUESS_EXPANSION;
d270 6
a275 6
    arg->var = NULL;
    Lst_ForEach(&arg->lst, ForExec, arg);
    Buf_Destroy(&arg->buf);
    Lst_Destroy(&arg->vars, (SimpleProc)Var_DeleteLoopVar);
    Lst_Destroy(&arg->lst, (SimpleProc)free);
    free(arg);
@


1.34
log
@move the code that grabs a value in Var_Parse in its own function,
get_expanded_value.

Extend the code a bit to be much more thorough in case of a recursive
expansion: shows exactly the cycle of variable names involved.

okay millert@@
@
text
@@


1.33
log
@change Var_ParseSkip API to increment the position instead of returning a
length, simplifies code.

(warns a bit, symptom of some further issues to fix).

okay millert@@
@
text
@@


1.32
log
@big clean-up patch:
- rename a few functions in var.c to names that make more sense.
- introduce Var_Deletei because it makes more sense.
- rewrite .for loops to use a local LoopVar construct to avoid looking up more
stuff.
- reformat var.c to near K&R
- rewrite most comments in var.c

shown to a few people. millert@@ gave me his okay since it passes through
ports correctly.
@
text
@@


1.31
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d2 1
a2 1
/*	$OpenBSD: for.c,v 1.30 2004/04/07 13:11:36 espie Exp $	*/
d165 1
a165 1
	Lst_AtEnd(&arg->vars, Str_dupi(wrd, endVar));
d271 1
a271 1
    Lst_Destroy(&arg->vars, (SimpleProc)free);
@


1.30
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: for.c,v 1.29 2003/06/03 02:56:11 millert Exp $	*/
d142 1
a142 1
    while (*ptr && isspace(*ptr))
d160 1
a160 1
	while (*ptr && isspace(*ptr))
d207 1
a207 1
	for (ptr++; *ptr && isspace(*ptr); ptr++)
@


1.29
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: for.c,v 1.28 2002/06/13 23:26:39 espie Exp $	*/
d117 1
a117 3
build_words_list(lst, s)
    Lst lst;
    const char *s;
d133 1
a133 2
For_Eval(line)
    const char	    *line;    /* Line to parse */
d199 1
a199 3
For_Accumulate(arg, line)
    For 	    *arg;
    const char	    *line;    /* Line to parse */
d233 1
a233 3
ForExec(valuep, argp)
    void *valuep;
    void *argp;
d263 1
a263 2
For_Run(arg)
    For *arg;
@


1.28
log
@synch comments with actual code.
Okay miod@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: for.c,v 1.27 2002/06/11 21:12:11 espie Exp $	*/
d44 1
a44 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.27
log
@This is the first step in sanitizing the conditional parser.

Change the conditional recognition algorithm:
scan for a sequence of alphabetic characters, hash it, and compare it against
a small table (using ohash functions).
This makes Cond_Eval entry more logical, and allows for some shortcuts in
recognizing .include, .for, .undef.

This also means that conditionals must have an intervening blank between
the keyword and the actual test, e.g.,
.ifA
will no longer work.

(but no-one actually uses this, and it's highly obfuscated)

Okay miod@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: for.c,v 1.26 2001/05/29 12:53:40 espie Exp $	*/
d152 1
a152 1
    /* We found a for loop, and now we are going to parse it.  */
@


1.26
log
@Take includes out of lst.h, re-add what's needed to separate files.
Removes remaining lint stuff from lst.lib.
@
text
@d2 1
a2 1
/*	$OpenBSD: for.c,v 1.25 2001/05/23 12:34:42 espie Exp $	*/
a147 7

    /* If we are not in a for loop quickly determine if the statement is
     * a for.  */
    if (ptr[0] != 'f' || ptr[1] != 'o' || ptr[2] != 'r' ||
	!isspace(ptr[3]))
	return NULL;
    ptr += 4;
@


1.25
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: for.c,v 1.4 1998/12/05 00:06:27 espie Exp $	*/
d69 1
@


1.24
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d65 15
a79 25
/*-
 * for.c --
 *	Functions to handle loops in a makefile.
 *
 * Interface:
 *	For_Eval	Evaluate the .for in the passed line.
 *	For_Accumulate	Add lines to an accumulating loop
 *	For_Run 	Run accumulated loop
 *
 */

#include    <ctype.h>
#include    <assert.h>
#include    <stddef.h>
#include    "make.h"
#include    "buf.h"

#ifndef lint
#if 0
static char sccsid[] = "@@(#)for.c	8.1 (Berkeley) 6/6/93";
#else
UNUSED
static char rcsid[] = "$OpenBSD: for.c,v 1.4 1998/12/05 00:06:27 espie Exp $";
#endif
#endif /* not lint */
d97 4
a100 4
    char		*text;		/* unexpanded text		*/
    LIST		vars;		/* list of variables		*/
    LstNode		var;		/* current var			*/
    int			nvars;		/* total number of vars		*/
d106 1
a106 1
    Boolean		freeold;
d109 2
d112 5
a118 1
/* Cut a string into words, stuff that into list.  */
d131 1
a131 1
	Lst_AtFront(lst, escape_dup(wrd, end, "\"'"));
a136 13
/*
 *-----------------------------------------------------------------------
 * For_Eval --
 *	Evaluate the for loop in the passed line. The line
 *	looks like this:
 *	    .for <variable> in <varlist>
 *
 * Results:
 *	Loop structure, to accumulate further lines.
 *	NULL if this was not a for loop after all.
 *-----------------------------------------------------------------------
 */

d175 1
a175 1
	/* finished variable list */
d178 1
a178 1
	Lst_AtEnd(&arg->vars, interval_dup(wrd, endVar));
d187 1
a187 1
    sub = Var_Subst(ptr, NULL, FALSE);
d211 1
a211 14
/*-
 *-----------------------------------------------------------------------
 * For_Accumulate --
 *	Accumulate lines in a for loop, until we find the matching endfor.
 *
 * Results:
 *	TRUE: keep accumulating lines.
 *	FALSE: We found the matching .endfor
 *
 * Side Effects:
 *	Accumulate lines in arg.
 *-----------------------------------------------------------------------
 */
Boolean
d231 1
a231 1
		return FALSE;
d242 1
a242 1
    return TRUE;
a246 6
/*-
 *-----------------------------------------------------------------------
 * ForExec --
 *	Expand the for loop for this index and push it in the Makefile
 *-----------------------------------------------------------------------
 */
d248 2
a249 2
ForExec(namep, argp)
    void *namep;
d252 1
a252 1
    char *name = (char *)namep;
d261 1
a261 1
	arg->freeold = FALSE;
d265 2
a266 1
	(void)fprintf(stderr, "--- %s = %s\n", (char *)Lst_Datum(arg->var), name);
d268 1
a268 1
    Var_SubstVar(&buf, arg->text, Lst_Datum(arg->var), name);
d272 1
a272 1
    arg->freeold = TRUE;
a277 7

/*-
 *-----------------------------------------------------------------------
 * For_Run --
 *	Run the for loop, pushing expanded lines for reparse
 *-----------------------------------------------------------------------
 */
@


1.23
log
@Take advantage of VarModifiers_Apply, which can parse a variable spec
and expand it directly, without needing a variable context.

Use it in Var_SubstVar, so that .for loops values don't need to be entered
into any context nor looked up.

This speeds up .for loops some, and avoids nasty variable capture
side-effects.

Ok'd millert@@, miod@@, naddy@@   (naddy spotted a problem with the first
version of that change).
@
text
@d1 3
a3 2
/*	$OpenBSD: for.c,v 1.22 2000/09/14 13:35:38 espie Exp $	*/
/*	$NetBSD: for.c,v 1.4 1996/11/06 17:59:05 christos Exp $	*/
d70 1
a70 1
 *	For_Eval 	Evaluate the .for in the passed line
d72 1
a72 1
 *	For_Run		Run accumulated loop
d87 1
a87 1
static char rcsid[] = "$OpenBSD: for.c,v 1.22 2000/09/14 13:35:38 espie Exp $";
d94 1
a94 1
 * .for <variable> in <varlist>
d107 5
a111 3
    char		*text;		/* unexpanded text       	*/
    char		*var;		/* Index name		 	*/
    LIST  		lst;		/* List of items	 	*/
d113 2
a114 2
    BUFFER		buf;		/* Accumulating text	 	*/
    unsigned long	lineno;		/* Line number at start of loop */
d116 1
d119 2
a120 2
static void ForExec __P((void *, void *));
static void build_words_list __P((Lst, const char *));
d123 1
a123 1
static void
d129 1
d131 1
d134 5
a138 2
    while ((wrd = iterate_words(&end)) != NULL)
    	Lst_AtFront(lst, escape_dup(wrd, end, "\"'"));
d156 1
a156 1
    char    	    *line;    /* Line to parse */
d158 4
a161 4
    char 	*ptr = line;
    char	*wrd;
    char 	*sub;
    char	*endVar;
d163 1
a164 2
    for (ptr++; *ptr && isspace(*ptr); ptr++)
	continue;
d177 23
a199 5
    /* Grab the variable.  */
    for (wrd = ptr; *ptr && !isspace(*ptr); ptr++)
	continue;
    if (ptr - wrd == 0) {
	Parse_Error(PARSE_FATAL, "missing variable in for");
a201 17
    endVar = ptr++;

    while (*ptr && isspace(*ptr))
	ptr++;

    /* Grab the `in'.  */
    if (ptr[0] != 'i' || ptr[1] != 'n' ||
	!isspace(ptr[2])) {
	Parse_Error(PARSE_FATAL, "missing `in' in for");
	printf("%s\n", ptr);
	return NULL;
    }
    ptr += 3;

    /* .for loop is go, collate what we need.  */
    arg = emalloc(sizeof(*arg));
    arg->var = interval_dup(wrd, endVar);
d205 7
a211 2
    if (DEBUG(FOR))
	(void)fprintf(stderr, "For: Iterator %s List %s\n", arg->var, sub);
d214 1
a214 1
    build_words_list(&arg->lst, sub);
d216 4
d227 1
a227 1

d243 2
a244 2
    For		    *arg;
    const char      *line;    /* Line to parse */
d290 9
d301 10
a310 3
	(void)fprintf(stderr, "--- %s = %s\n", arg->var, name);
    Parse_FromString(Var_SubstVar(arg->text, arg->var, name, 
    	arg->guess), arg->lineno);
d313 1
a313 1

d328 1
d330 2
a331 2
    free(arg->var);
    free(arg->text);
@


1.22
log
@Two new functions:

iterate_words: light-weight equivalent to brk_string,
which does not need to copy the string, and does not do \ interpretation
which are only needed for the string.

escape_dup: handles escape sequence in a systematic way.

This speeds up variable modifiers.

This also makes .for loops more consistent, as they use the same definition
of `a word' as the rest of make.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.21 2000/09/14 13:32:06 espie Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: for.c,v 1.21 2000/09/14 13:32:06 espie Exp $";
a272 2
    Buf_Init(&arg->buf, arg->guess);
    Var_Set(arg->var, name, VAR_GLOBAL);
d275 2
a276 6
    Var_SubstVar(&arg->buf, arg->text, arg->var, VAR_GLOBAL);
    if (Buf_Size(&arg->buf) >= arg->guess)
    	arg->guess = Buf_Size(&arg->buf) + GUESS_EXPANSION;
    
    Parse_FromString(Buf_Retrieve(&arg->buf), arg->lineno);
    Var_Delete(arg->var, VAR_GLOBAL);
@


1.21
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.20 2000/07/17 21:48:40 espie Exp $	*/
d86 1
a86 1
static char rcsid[] = "$OpenBSD: for.c,v 1.20 2000/07/17 21:48:40 espie Exp $";
d124 1
a124 1
    const char *wrd;
d126 4
a129 11
    for (;;) {
	for (; *s != '\0' && isspace(*s); s++)
	    continue;
	if (*s == '\0')
	    break;
	for (wrd = s; *s != '\0' && !isspace(*s); s++)
	    continue;
    	/* note that we fill the list backward, since 
     	 * Parse_FromString stacks strings.  */
	Lst_AtFront(lst, interval_dup(wrd, s));
    }
@


1.20
log
@Consistency bug: for substitution should look in the same places other
variable substitution is.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.19 2000/06/23 16:23:26 espie Exp $	*/
d85 2
a86 1
static char rcsid[] = "$OpenBSD: for.c,v 1.19 2000/06/23 16:23:26 espie Exp $";
@


1.19
log
@This patch separates local contexts from global contexts for good.
Apart from a few casts, VAR_GLOBAL and friends are separate
data structures, so we use a small array for local variables.

We also junk allVars, since TargFreeGN can release local nodes,
and var.c has explicit lists for its variables already.

Reviewed millert@@ and miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.18 2000/06/17 14:38:15 espie Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: for.c,v 1.18 2000/06/17 14:38:15 espie Exp $";
d201 1
a201 1
    sub = Var_Subst(ptr, (SymTable *)VAR_GLOBAL, FALSE);
@


1.18
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.17 2000/06/10 01:41:05 espie Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: for.c,v 1.17 2000/06/10 01:41:05 espie Exp $";
d201 1
a201 1
    sub = Var_Subst(ptr, VAR_GLOBAL, FALSE);
@


1.17
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.16 2000/06/10 01:32:22 espie Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: for.c,v 1.16 2000/06/10 01:32:22 espie Exp $";
d107 1
a107 1
    Lst  		lst;		/* List of items	 	*/
d205 2
a206 2
    arg->lst = Lst_Init();
    build_words_list(arg->lst, sub);
d306 1
a306 1
    Lst_ForEach(arg->lst, ForExec, arg);
d309 1
a309 1
    Lst_Destroy(arg->lst, (SimpleProc)free);
@


1.16
log
@Thus, Lst_ForEach no longer needs returning a status.
In fact, it can become a macro based on Lst_ForEachFrom.
This also introduces Lst_Every, as a shortcut for the very common case where
Lst_ForEach does not need any user data.

Finally,  make consistent use of a few function typedefs, instead of having
explicit void (*)(Lst)  arguments all over the place.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.15 2000/03/26 16:21:32 espie Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: for.c,v 1.15 2000/03/26 16:21:32 espie Exp $";
d114 1
a114 1
static void ForExec __P((ClientData, ClientData));
d273 2
a274 2
    ClientData namep;
    ClientData argp;
@


1.15
log
@Remove idiotic, braindead casts T* -> void*
They serve no purpose, except hiding potential bugs.

In particular, remove (ClientData) cast from macro, showing potentially
troublesome use of Hashes to store time_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.14 1999/12/18 02:11:26 espie Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: for.c,v 1.14 1999/12/18 02:11:26 espie Exp $";
d114 1
a114 1
static int ForExec __P((ClientData, ClientData));
d271 1
a271 1
static int
a288 1
    return 0;
d309 1
a309 1
    Lst_Destroy(arg->lst, (void (*) __P((ClientData)))free);
@


1.14
log
@make does not use circular lists, get rid of the extra weight.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.13 1999/12/16 17:27:18 espie Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: for.c,v 1.13 1999/12/16 17:27:18 espie Exp $";
d134 1
a134 1
	Lst_AtFront(lst, (ClientData)interval_dup(wrd, s));
d307 1
a307 1
    Lst_ForEach(arg->lst, ForExec, (ClientData)arg);
@


1.13
log
@Var_Subst is actually two distinct functions folded into one:
split the function specific to for.c out, and give them more sensible
arguments at the same time.

This makes .for loop handling more efficient, as we have some heuristic
to evaluate the size of the buffer needed...
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.12 1999/12/16 17:24:11 espie Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: for.c,v 1.12 1999/12/16 17:24:11 espie Exp $";
d205 1
a205 1
    arg->lst = Lst_Init(FALSE);
@


1.12
log
@remaining part of the previous patch... patch got confused somehow.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.11 1999/12/16 17:07:20 espie Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: for.c,v 1.11 1999/12/16 17:07:20 espie Exp $";
d108 1
d201 1
a201 1
    sub = Var_Subst(NULL, ptr, VAR_GLOBAL, FALSE);
d264 1
d279 1
d283 5
a287 2
    Parse_FromString(Var_Subst(arg->var, arg->text, VAR_GLOBAL, FALSE), 
    	arg->lineno);
d305 1
@


1.11
log
@for.c becomes sane.
- split For_Eval into For_Eval (first line of loop) / For_Accumulate
(remaining lines).
- encapsulate state into a For structure, instead of brain damaged static
variables that need copy.

Very minor performance hit, specifically, For structure is allocated with
malloc/free, instead of playing tricks with static/auto variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.10 1999/12/16 17:02:45 espie Exp $	*/
a63 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)for.c	8.1 (Berkeley) 6/6/93";
#else
static char rcsid[] = "$OpenBSD: for.c,v 1.10 1999/12/16 17:02:45 espie Exp $";
#endif
#endif /* not lint */

d69 2
a70 1
 *	For_Eval 	Evaluate the loop in the passed line.
d76 2
a78 2
#include    "hash.h"
#include    "dir.h"
d80 8
@


1.10
log
@Allocate buffers as static data structures.
This cuts down quite a lot of malloc, since in actual use,
buffer usage is mostly static.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.9 1999/12/16 16:41:41 espie Exp $	*/
d68 1
a68 1
static char rcsid[] = "$OpenBSD: for.c,v 1.9 1999/12/16 16:41:41 espie Exp $";
d95 5
a99 5
 * The trick is to look for the matching end inside for for loop
 * To do that, we count the current nesting level of the for loops.
 * and the .endfor statements, accumulating all the statements between
 * the initial .for loop and the matching .endfor;
 * then we evaluate the for loop for each variable in the varlist.
d102 9
a110 5
static int  	  forLevel = 0;  	/* Nesting level	     */
static char	 *forVar;		/* Iteration variable	     */
static BUFFER	  forBuf;		/* Commands in loop	     */
static Lst	  forLst;		/* List of items	     */
static unsigned long forLineno;		/* Line at beginning of loop */
d112 1
a112 11
/*
 * State of a for loop.
 */
typedef struct _For {
    Buffer	  buf;			/* Unexpanded buffer	     */
    char*	  var;			/* Index name		     */
    Lst  	  lst;			/* List of variables	     */
    unsigned long lineno;
} For;

static int ForExec	__P((ClientData, ClientData));
d130 2
a131 2
	    /* note that we fill the list backward, since 
	     * Parse_FromString stacks strings.  */
d136 1
a136 2

/*-
d144 2
a145 7
 *	TRUE: We found a for loop, or we are inside a for loop
 *	FALSE: We did not find a for loop, or we found the end of the for
 *	       for loop.
 *
 * Side Effects:
 *	None.
 *
d148 3
a150 2
int
For_Eval (line)
d153 28
a180 2
    char	    *ptr = line;
    int	    	    level;  	/* Level at which to report errors. */
d182 2
a183 1
    level = PARSE_FATAL;
d185 8
d194 3
a196 4
    if (forLevel == 0) {
	char	    *endVar;
	char 	    *sub;
	char	    *wrd;
d198 4
a201 12
	for (ptr++; *ptr && isspace((unsigned char) *ptr); ptr++)
	    continue;
	/* If we are not in a for loop quickly determine if the statement is
	 * a for.  */
	if (ptr[0] != 'f' || ptr[1] != 'o' || ptr[2] != 'r' ||
	    !isspace((unsigned char) ptr[3]))
	    return FALSE;
	ptr += 3;

	/* We found a for loop, and now we are going to parse it.  */
	while (*ptr && isspace((unsigned char) *ptr))
	    ptr++;
d203 6
a208 3
	/* Grab the variable.  */
	for (wrd = ptr; *ptr && !isspace((unsigned char) *ptr); ptr++)
	    continue;
d210 2
a211 5
	if (ptr - wrd == 0) {
	    Parse_Error(level, "missing variable in for");
	    return 0;
	}
	endVar = ptr++;
d213 20
a232 2
	while (*ptr && isspace((unsigned char) *ptr))
	    ptr++;
d234 1
a234 11
	/* Grab the `in'.  */
	if (ptr[0] != 'i' || ptr[1] != 'n' ||
	    !isspace((unsigned char) ptr[2])) {
	    Parse_Error(level, "missing `in' in for");
	    printf("%s\n", ptr);
	    return 0;
	}
	ptr += 3;

	/* .for loop is go, collate what we need.  */
	forVar = interval_dup(wrd, endVar);
d236 1
a236 14
	/* Make a list with the remaining words.  */
	sub = Var_Subst(NULL, ptr, VAR_GLOBAL, FALSE);
	if (DEBUG(FOR))
	    (void)fprintf(stderr, "For: Iterator %s List %s\n", forVar, sub);

	forLst = Lst_Init(FALSE);
	build_words_list(forLst, sub);
	free(sub);
	forLineno = Parse_Getlineno();
	Buf_Init(&forBuf, 0);
	forLevel++;
	return 1;
    }
    else if (*ptr == '.') {
d238 1
a238 1
	for (ptr++; *ptr && isspace((unsigned char) *ptr); ptr++)
d242 1
a242 1
	    (isspace((unsigned char) ptr[6]) || !ptr[6])) {
d244 4
a247 5
		(void) fprintf(stderr, "For: end for %d\n", forLevel);
	    if (--forLevel < 0) {
		Parse_Error(level, "for-less endfor");
		return 0;
	    }
d250 2
a251 2
		 isspace((unsigned char) ptr[3])) {
	    forLevel++;
d253 1
a253 1
		(void) fprintf(stderr, "For: new loop %d\n", forLevel);
d256 4
a260 9
    if (forLevel != 0) {
	Buf_AddString(&forBuf, line);
	Buf_AddChar(&forBuf, '\n');
	return 1;
    }
    else {
	return 0;
    }
}
a265 7
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	None.
 *
d273 3
a275 2
    char *name = (char *) namep;
    For *arg = (For *) argp;
d278 3
a280 3
	(void) fprintf(stderr, "--- %s = %s\n", arg->var, name);
    Parse_FromString(Var_Subst(arg->var, Buf_Retrieve(arg->buf),
			       VAR_GLOBAL, FALSE), arg->lineno);
a281 1

d289 1
a289 8
 *	Run the for loop, immitating the actions of an include file
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	None.
 *
d292 1
d294 2
a295 1
For_Run()
d297 1
a297 1
    For arg;
d299 5
a303 14
    if (forVar == NULL || forLst == NULL)
	return;
    arg.var = forVar;
    arg.buf = &forBuf;
    arg.lst = forLst;
    arg.lineno = forLineno;
    forVar = NULL;
    forLst = NULL;

    Lst_ForEach(arg.lst, ForExec, (ClientData) &arg);

    free((Address)arg.var);
    Lst_Destroy(arg.lst, (void (*) __P((ClientData))) free);
    Buf_Destroy(arg.buf);
@


1.9
log
@Split Buf_GetAll into Buf_Retrieve/Buf_Size.
(idiotic to retrieve size every time when it's used half the time)
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.8 1999/12/09 18:18:24 espie Exp $	*/
d68 1
a68 1
static char rcsid[] = "$OpenBSD: for.c,v 1.8 1999/12/09 18:18:24 espie Exp $";
d104 1
a104 1
static Buffer	  forBuf;		/* Commands in loop	     */
d222 1
a222 1
	forBuf = Buf_Init(0);
d249 2
a250 2
	Buf_AddString(forBuf, line);
	Buf_AddChar(forBuf, '\n');
d307 1
a307 1
    if (forVar == NULL || forBuf == NULL || forLst == NULL)
d310 1
a310 1
    arg.buf = forBuf;
a313 1
    forBuf = NULL;
d320 1
a320 1
    Buf_Destroy(arg.buf, TRUE);
@


1.8
log
@Introduce `common usage' buf patterns and use them.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.7 1999/12/06 22:24:31 espie Exp $	*/
d68 1
a68 1
static char rcsid[] = "$OpenBSD: for.c,v 1.7 1999/12/06 22:24:31 espie Exp $";
d281 1
a281 1
    Parse_FromString(Var_Subst(arg->var, Buf_GetAll(arg->buf, NULL),
@


1.7
log
@Clean up buffers interface somewhat:

- buf.c deals exclusively with chars. Be explicit about it, and remove
extraneous dumb casts to char (can hide real type errors).
- buffer sizes are size_t. Note that bp->left can never become NULL.
- Buf_GetAll is happy with a NULL pointer for the size, remove unneeded
extra pointers.
- Propagate size_t to all places where buffer functions are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.6 1999/12/06 22:18:56 espie Exp $	*/
d68 1
a68 1
static char rcsid[] = "$OpenBSD: for.c,v 1.6 1999/12/06 22:18:56 espie Exp $";
d249 1
a249 1
	Buf_AddChars(forBuf, strlen(line), line);
@


1.6
log
@- introduce interval_dup in str.c
- use it to replace .for parsing with something approaching sanity.
(this removes one of the few most blatant misuses of Bufs in make.

More changes to come... patch reviewed by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.5 1999/11/11 11:42:19 espie Exp $	*/
d68 1
a68 1
static char rcsid[] = "$OpenBSD: for.c,v 1.5 1999/11/11 11:42:19 espie Exp $";
d249 2
a250 2
	Buf_AddBytes(forBuf, strlen(line), (Byte *) line);
	Buf_AddByte(forBuf, (Byte) '\n');
a277 1
    int len;
d281 1
a281 1
    Parse_FromString(Var_Subst(arg->var, (char *) Buf_GetAll(arg->buf, &len),
@


1.5
log
@Communicate line numbers between parse.c and for.c.
Parse_String starts in the current line, but at a given line number.

.for loops yield correct line numbers, much easier to debug !
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.4 1998/12/05 00:06:27 espie Exp $	*/
d5 27
d68 1
a68 1
static char rcsid[] = "$OpenBSD: for.c,v 1.4 1998/12/05 00:06:27 espie Exp $";
d119 1
d121 7
d129 12
d164 1
a164 1
    char	    *ptr = line, *sub, *wrd;
d171 3
a173 2
	Buffer	    buf;
	int	    varlen;
d177 2
a178 4
	/*
	 * If we are not in a for loop quickly determine if the statement is
	 * a for.
	 */
d184 1
a184 3
	/*
	 * we found a for loop, and now we are going to parse it.
	 */
d188 1
a188 4
	/*
	 * Grab the variable
	 */
	buf = Buf_Init(0);
a190 1
	Buf_AddBytes(buf, ptr - wrd, (Byte *) wrd);
d192 2
a193 3
	forVar = (char *) Buf_GetAll(buf, &varlen);
	if (varlen == 0) {
	    Parse_Error (level, "missing variable in for");
d196 1
a196 1
	Buf_Destroy(buf, FALSE);
d201 1
a201 3
	/*
	 * Grab the `in'
	 */
d204 1
a204 1
	    Parse_Error (level, "missing `in' in for");
d210 2
a211 2
	while (*ptr && isspace((unsigned char) *ptr))
	    ptr++;
d213 1
a213 6
	/*
	 * Make a list with the remaining words
	 */
	forLst = Lst_Init(FALSE);
	forLineno = Parse_Getlineno();
	buf = Buf_Init(0);
a214 18

#define ADDWORD() \
	Buf_AddBytes(buf, ptr - wrd, (Byte *) wrd), \
	Buf_AddByte(buf, (Byte) '\0'), \
	Lst_AtFront(forLst, (ClientData) Buf_GetAll(buf, &varlen)), \
	Buf_Destroy(buf, FALSE)

	for (ptr = sub; *ptr && isspace((unsigned char) *ptr); ptr++)
	    continue;

	for (wrd = ptr; *ptr; ptr++)
	    if (isspace((unsigned char) *ptr)) {
		ADDWORD();
		buf = Buf_Init(0);
		while (*ptr && isspace((unsigned char) *ptr))
		    ptr++;
		wrd = ptr--;
	    }
d216 1
a216 6
	    (void) fprintf(stderr, "For: Iterator %s List %s\n", forVar, sub);
	if (ptr - wrd > 0)
	    ADDWORD();
	else
	    Buf_Destroy(buf, TRUE);
	free((Address) sub);
d218 4
d236 1
a236 1
		Parse_Error (level, "for-less endfor");
@


1.4
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: for.c,v 1.2 1996/06/26 05:36:30 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: for.c,v 1.2 1996/06/26 05:36:30 deraadt Exp $";
d75 5
a79 4
static int  	  forLevel = 0;  	/* Nesting level	*/
static char	 *forVar;		/* Iteration variable	*/
static Buffer	  forBuf;		/* Commands in loop	*/
static Lst	  forLst;		/* List of items	*/
d85 4
a88 3
    Buffer	  buf;			/* Unexpanded buffer	*/
    char*	  var;			/* Index name		*/
    Lst  	  lst;			/* List of variables	*/
d180 1
d270 1
a270 1
			       VAR_GLOBAL, FALSE));
d300 1
@


1.3
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@@


1.2
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: for.c,v 1.3 1995/06/14 15:19:13 christos Exp $	*/
/*	$NetBSD: for.c,v 1.3 1995/06/14 15:19:13 christos Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)for.c	5.6 (Berkeley) 6/1/90";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: for.c,v 1.3 1995/06/14 15:19:13 christos Exp $";
d71 1
a71 1
 * the initial .for loop and the matching .endfor; 
d135 1
a135 1
	
d141 1
a141 1
	
d146 1
a146 1
	for (wrd = ptr; *ptr && !isspace((unsigned char) *ptr); ptr++) 
d179 1
a179 1
	sub = Var_Subst(NULL, ptr, VAR_GLOBAL, FALSE); 
d184 1
a184 1
	Lst_AtEnd(forLst, (ClientData) Buf_GetAll(buf, &varlen)), \
d200 1
a200 1
	if (ptr - wrd > 0) 
d205 1
a205 1
	    
d266 1
a266 1
    Parse_FromString(Var_Subst(arg->var, (char *) Buf_GetAll(arg->buf, &len), 
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: for.c,v 1.3 1995/06/14 15:19:13 christos Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
