head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.6
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.6
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3;
locks; strict;
comment	@ * @;


1.9
date	2016.10.21.16.12.38;	author espie;	state Exp;
branches;
next	1.8;
commitid	aLVdeKrJ0t5upS3l;

1.8
date	2015.01.23.22.35.57;	author espie;	state Exp;
branches;
next	1.7;
commitid	WtGGWUPWONvkhNGN;

1.7
date	2015.01.23.13.18.40;	author espie;	state Exp;
branches;
next	1.6;
commitid	iXa5WmoY9RgeqDsn;

1.6
date	2014.05.18.08.08.50;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2013.05.22.12.14.08;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2013.04.23.14.32.53;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2012.10.09.19.45.34;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2012.10.02.10.29.30;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	;


desc
@@


1.9
log
@small obvious cleanups:
- remove a lot of unnecessary casts
- zap extra param that's no longer needed
- add proper prototype and make function static

okay natano@@
@
text
@/* $OpenBSD: dump.c,v 1.8 2015/01/23 22:35:57 espie Exp $ */
/*
 * Copyright (c) 2012 Marc Espie.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <limits.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ohash.h>
#include "defines.h"
#include "gnode.h"
#include "dump.h"
#include "targ.h"
#include "var.h"
#include "memory.h"
#include "suff.h"
#include "lst.h"
#include "timestamp.h"
#include "dir.h"

/* since qsort doesn't have user data, this needs to be a global... */
static ptrdiff_t cmp_offset;
static void targ_dump(bool);

static int 
compare_names(const void *a, const void *b)
{
	const char **pa = (const char **)a;
	const char **pb = (const char **)b;
	return strcmp((*pa) + cmp_offset, (*pb) + cmp_offset);
}

void *
sort_ohash_by_name(struct ohash *h)
{
	cmp_offset = h->info.key_offset;

	return sort_ohash(h, compare_names);
}

void *
sort_ohash(struct ohash *h, int (*comparison)(const void *, const void *))
{
	unsigned int i, j;
	void *e;
	size_t n = ohash_entries(h);
	void **t = ereallocarray(NULL, n+1, sizeof(void *));
	cmp_offset = h->info.key_offset;

	for (i = 0, e = ohash_first(h, &j); e != NULL; e = ohash_next(h, &j))
	    	t[i++] = e;
	qsort(t, n, sizeof(void *), comparison);
	/* add an extra entry to be able to figure out the end without needing
	 * to keep a counter */
	t[n] = NULL;
	return t;
}

static void
TargPrintName(void *gnp)
{
	const GNode *gn = gnp;
	printf("%s ", gn->name);
}

static void
TargPrintOnlySrc(GNode *gn)
{
	if (OP_NOP(gn->type) && gn->special == SPECIAL_NONE &&
	    !(gn->type & OP_DUMMY)) {
	    	if (gn->path != NULL)
			printf("#\t%s [%s]\n", gn->name, 
			    strcmp(gn->path, gn->name) == 0 ? "=" : gn->path);
		else
			printf("#\t%s\n", gn->name);
    	}
}

static void
TargPrintNode(GNode *gn, bool full)
{
	if (OP_NOP(gn->type))
		return;
	switch((gn->special & SPECIAL_MASK)) {
	case SPECIAL_SUFFIXES:
	case SPECIAL_PHONY:
	case SPECIAL_ORDER:
	case SPECIAL_NOTHING:
	case SPECIAL_MAIN:
	case SPECIAL_IGNORE:
		return;
	default:
		break;
	}
	if (full) {
		printf("# %d unmade prerequisites\n", gn->unmade);
		if (! (gn->type & (OP_JOIN|OP_USE|OP_EXEC))) {
			if (!is_out_of_date(gn->mtime)) {
				printf("# last modified %s: %s\n",
				      time_to_string(&gn->mtime),
				      status_to_string(gn));
			} else if (gn->built_status != UNKNOWN) {
				printf("# non-existent (maybe): %s\n",
				    status_to_string(gn));
			} else {
				printf("# unmade\n");
			}
		}
	}
	if (!Lst_IsEmpty(&gn->parents)) {
		printf("# parent targets: ");
		Lst_Every(&gn->parents, TargPrintName);
		fputc('\n', stdout);
	}
	if (gn->impliedsrc)
		printf("# implied prerequisite: %s\n", gn->impliedsrc->name);

	printf("%-16s", gn->name);
	switch (gn->type & OP_OPMASK) {
	case OP_DEPENDS:
		printf(": "); break;
	case OP_FORCE:
		printf("! "); break;
	case OP_DOUBLEDEP:
		printf(":: "); break;
	}
	Targ_PrintType(gn->type);
	Lst_Every(&gn->children, TargPrintName);
	fputc('\n', stdout);
	Lst_Every(&gn->commands, Targ_PrintCmd);
	printf("\n\n");
	if (gn->type & OP_DOUBLEDEP) {
		LstNode ln;

		for (ln = Lst_First(&gn->cohorts); ln != NULL; ln = Lst_Adv(ln))
			TargPrintNode(Lst_Datum(ln), full);
	}
}

static void
dump_special(GNode **t, const char *name, int prop)
{
	unsigned int i;
	bool first = true;

	for (i = 0; t[i] != NULL; i++)
		if (t[i]->type & prop) {
			if (first) {
				printf("%s:", name);
				first = false;
			}
			printf(" %s", t[i]->name);
	    	}
	if (!first)
		printf("\n\n");
}

static void
targ_dump(bool full)
{
	GNode **t = sort_ohash_by_name(targets_hash());
	unsigned int i;

	printf("#   Input graph:\n");
	for (i = 0; t[i] != NULL; i++)
		TargPrintNode(t[i], full);
	printf("\n\n");

	dump_special(t, ".PHONY", OP_PHONY);
	dump_special(t, ".PRECIOUS", OP_PRECIOUS);
	dump_special(t, ".SILENT", OP_SILENT);
	dump_special(t, ".IGNORE", OP_IGNORE);
	printf("#   Other target names:\n");
	for (i = 0; t[i] != NULL; i++)
		TargPrintOnlySrc(t[i]);
	printf("\n");
	free(t);
}

static bool dumped_once = false;

void
dump_data(void)
{
	Var_Dump();
	Suff_PrintAll();
	targ_dump(false);
	dumped_once = true;
}

void
post_mortem(void)
{
	if (!dumped_once) {
		Var_Dump();
		Suff_PrintAll();
	}
	targ_dump(true);
}
@


1.8
log
@a wee little bit more cleanup (more const and remove noise from CDIAGFLAGS...
-pedantic kind of requires -std=c99 here to avoid LL warnings)
okay miod@@, millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: dump.c,v 1.7 2015/01/23 13:18:40 espie Exp $ */
d159 1
a159 1
			TargPrintNode((GNode *)Lst_Datum(ln), full);
@


1.7
log
@remove a bunch of dangerous casts (useless casts from void * to something
else, in some cases by adding extra temporary variables.
IMO, it's much better practice to do

void *a;
int *p = a;
*p = 42;

rather than
void *a;
*(int *)a = 42;

okay miod@@... to be revisited for some possible const additions later.
@
text
@d1 1
a1 1
/* $OpenBSD: dump.c,v 1.6 2014/05/18 08:08:50 espie Exp $ */
d85 1
a85 1
	GNode *gn = gnp;
@


1.6
log
@a bit more reallocarray (and kill ecalloc, which isn't used)
okay chl@@
@
text
@d1 1
a1 1
/* $OpenBSD: dump.c,v 1.5 2013/05/22 12:14:08 espie Exp $ */
d85 1
a85 1
	GNode *gn = (GNode *)gnp;
@


1.5
log
@as checked through thorough tests, youngest->mtime == ctime, so ditch
the extra field.

remove some extra abstraction layer: use clock_gettime directly
instead of ts_set_from_now (what is "now" anyways)

time_to_string takes param by pointer

rename "now" into starttime (more accurate term)

randomize queue uses arc4random_uniform (prompted by deraadt@@)

display debug timestamp with ns too (it's debug, so it doesn't really
matter whichever way it's done, as long as it's done)

okay millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: dump.c,v 1.4 2013/04/23 14:32:53 espie Exp $ */
d70 1
a70 1
	void **t = emalloc(sizeof(void *) * (n+1));
@


1.4
log
@remove TIMESTAMP abstraction layer, prodded by theo.
while there, clean up includes.
use strtoll for ar timestamps (pretty much unused in reality, more
standard conforming than anything)

use idea from Todd to adapt to time_t being 32 bits OR 64 bits
(pedantically correct: INT_MIN would work just fine up to 1910 or so...)

okay millert@@, gone thru a make build.
@
text
@d1 1
a1 1
/* $OpenBSD: dump.c,v 1.3 2012/10/09 19:45:34 espie Exp $ */
d123 1
a123 1
				      time_to_string(gn->mtime),
@


1.3
log
@- SPECIAL_DEPRECATED -> SPECIAL_NOTHING
- nodes for .POSIX and .SCCS_GET (which don't do anything)
- zap remaining suffix crud.

new scaffolding:
- groupling list and HELDBACK state to avoid races in engine.
- parser recognizes lists of targets that shoul be grouped together
- OP_DOUBLE to mark nodes that have multiple lists of commands
@
text
@d1 1
a1 1
/* $OpenBSD: dump.c,v 1.2 2012/10/02 10:29:30 espie Exp $ */
d26 2
a28 1
#include <stddef.h>
d30 1
d32 1
a32 3
#include <stdlib.h>
#include <limits.h>
#include "ohash.h"
@


1.2
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d1 1
a1 1
/* $OpenBSD: dump.c,v 1.1 2012/09/21 07:55:20 espie Exp $ */
d111 1
a111 1
	case SPECIAL_DEPRECATED:
a185 1
	bool first;
@


1.1
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a4 2
 * Extensive code modifications for the OpenBSD project.
 *
d26 7
d34 1
d37 168
d209 14
a222 1
	Targ_PrintGraph(1);
@

