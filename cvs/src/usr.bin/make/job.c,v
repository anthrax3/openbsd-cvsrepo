head	1.139;
access;
symbols
	OPENBSD_6_2_BASE:1.139
	OPENBSD_6_1:1.139.0.4
	OPENBSD_6_1_BASE:1.139
	OPENBSD_6_0:1.136.0.6
	OPENBSD_6_0_BASE:1.136
	OPENBSD_5_9:1.136.0.2
	OPENBSD_5_9_BASE:1.136
	OPENBSD_5_8:1.136.0.4
	OPENBSD_5_8_BASE:1.136
	OPENBSD_5_7:1.135.0.6
	OPENBSD_5_7_BASE:1.135
	OPENBSD_5_6:1.135.0.10
	OPENBSD_5_6_BASE:1.135
	OPENBSD_5_5:1.135.0.8
	OPENBSD_5_5_BASE:1.135
	OPENBSD_5_4:1.135.0.4
	OPENBSD_5_4_BASE:1.135
	OPENBSD_5_3:1.135.0.2
	OPENBSD_5_3_BASE:1.135
	OPENBSD_5_2:1.122.0.2
	OPENBSD_5_2_BASE:1.122
	OPENBSD_5_1_BASE:1.120
	OPENBSD_5_1:1.120.0.8
	OPENBSD_5_0:1.120.0.6
	OPENBSD_5_0_BASE:1.120
	OPENBSD_4_9:1.120.0.4
	OPENBSD_4_9_BASE:1.120
	OPENBSD_4_8:1.120.0.2
	OPENBSD_4_8_BASE:1.120
	OPENBSD_4_7:1.118.0.2
	OPENBSD_4_7_BASE:1.118
	OPENBSD_4_6:1.117.0.4
	OPENBSD_4_6_BASE:1.117
	OPENBSD_4_5:1.115.0.2
	OPENBSD_4_5_BASE:1.115
	OPENBSD_4_4:1.113.0.2
	OPENBSD_4_4_BASE:1.113
	OPENBSD_4_3:1.112.0.2
	OPENBSD_4_3_BASE:1.112
	OPENBSD_4_2:1.62.0.2
	OPENBSD_4_2_BASE:1.62
	OPENBSD_4_1:1.61.0.2
	OPENBSD_4_1_BASE:1.61
	OPENBSD_4_0:1.59.0.6
	OPENBSD_4_0_BASE:1.59
	OPENBSD_3_9:1.59.0.4
	OPENBSD_3_9_BASE:1.59
	OPENBSD_3_8:1.59.0.2
	OPENBSD_3_8_BASE:1.59
	OPENBSD_3_7:1.58.0.2
	OPENBSD_3_7_BASE:1.58
	OPENBSD_3_6:1.57.0.2
	OPENBSD_3_6_BASE:1.57
	OPENBSD_3_5:1.55.0.4
	OPENBSD_3_5_BASE:1.55
	OPENBSD_3_4:1.55.0.2
	OPENBSD_3_4_BASE:1.55
	OPENBSD_3_3:1.53.0.2
	OPENBSD_3_3_BASE:1.53
	OPENBSD_3_2:1.52.0.2
	OPENBSD_3_2_BASE:1.52
	OPENBSD_3_1:1.50.0.2
	OPENBSD_3_1_BASE:1.50
	OPENBSD_3_0:1.43.0.2
	OPENBSD_3_0_BASE:1.43
	OPENBSD_2_9_BASE:1.39
	OPENBSD_2_9:1.39.0.2
	OPENBSD_2_8:1.37.0.2
	OPENBSD_2_8_BASE:1.37
	OPENBSD_2_7:1.25.0.2
	OPENBSD_2_7_BASE:1.25
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.139
date	2017.01.21.12.35.40;	author natano;	state Exp;
branches;
next	1.138;
commitid	XSW6C0qsm6j97kTD;

1.138
date	2017.01.21.12.31.34;	author natano;	state Exp;
branches;
next	1.137;
commitid	Kffdq0NZJG0sK99n;

1.137
date	2017.01.21.11.30.11;	author deraadt;	state Exp;
branches;
next	1.136;
commitid	5gJcKtrSv7DFokam;

1.136
date	2015.07.28.14.22.26;	author espie;	state Exp;
branches;
next	1.135;
commitid	qC7sZdci1GkmIXtJ;

1.135
date	2012.12.14.11.10.03;	author espie;	state Exp;
branches;
next	1.134;

1.134
date	2012.12.08.12.54.17;	author espie;	state Exp;
branches;
next	1.133;

1.133
date	2012.11.24.11.05.33;	author espie;	state Exp;
branches;
next	1.132;

1.132
date	2012.10.23.20.32.21;	author espie;	state Exp;
branches;
next	1.131;

1.131
date	2012.10.18.17.54.43;	author espie;	state Exp;
branches;
next	1.130;

1.130
date	2012.10.09.19.46.33;	author espie;	state Exp;
branches;
next	1.129;

1.129
date	2012.10.06.19.19.53;	author espie;	state Exp;
branches;
next	1.128;

1.128
date	2012.10.06.09.32.40;	author espie;	state Exp;
branches;
next	1.127;

1.127
date	2012.10.04.13.20.46;	author espie;	state Exp;
branches;
next	1.126;

1.126
date	2012.10.02.10.29.30;	author espie;	state Exp;
branches;
next	1.125;

1.125
date	2012.09.21.08.18.40;	author espie;	state Exp;
branches;
next	1.124;

1.124
date	2012.09.21.07.55.20;	author espie;	state Exp;
branches;
next	1.123;

1.123
date	2012.08.25.08.12.56;	author espie;	state Exp;
branches;
next	1.122;

1.122
date	2012.04.11.18.27.30;	author espie;	state Exp;
branches;
next	1.121;

1.121
date	2012.03.22.13.47.12;	author espie;	state Exp;
branches;
next	1.120;

1.120
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.119;

1.119
date	2010.07.15.10.37.32;	author espie;	state Exp;
branches;
next	1.118;

1.118
date	2009.08.16.09.50.13;	author espie;	state Exp;
branches;
next	1.117;

1.117
date	2009.05.10.11.07.37;	author espie;	state Exp;
branches;
next	1.116;

1.116
date	2009.04.26.09.25.49;	author espie;	state Exp;
branches;
next	1.115;

1.115
date	2008.11.11.09.32.20;	author espie;	state Exp;
branches;
next	1.114;

1.114
date	2008.11.04.07.22.35;	author espie;	state Exp;
branches;
next	1.113;

1.113
date	2008.03.24.18.03.53;	author espie;	state Exp;
branches;
next	1.112;

1.112
date	2008.01.29.22.23.10;	author espie;	state Exp;
branches;
next	1.111;

1.111
date	2008.01.12.13.08.59;	author espie;	state Exp;
branches;
next	1.110;

1.110
date	2007.12.01.15.14.34;	author espie;	state Exp;
branches;
next	1.109;

1.109
date	2007.11.28.09.40.08;	author espie;	state Exp;
branches;
next	1.108;

1.108
date	2007.11.10.12.51.40;	author espie;	state Exp;
branches;
next	1.107;

1.107
date	2007.11.06.21.09.42;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2007.11.03.14.05.39;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2007.11.03.11.44.30;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2007.11.03.10.41.48;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2007.11.03.10.38.14;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2007.11.03.10.36.48;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2007.11.02.17.27.24;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2007.10.14.09.02.10;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2007.10.09.09.41.51;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2007.10.09.09.41.24;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2007.10.09.09.40.26;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2007.10.09.09.39.21;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2007.10.09.09.35.43;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2007.10.09.09.34.05;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2007.10.09.09.32.03;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2007.10.06.19.34.32;	author cnst;	state Exp;
branches;
next	1.91;

1.91
date	2007.09.29.09.59.04;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2007.09.29.09.47.23;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2007.09.29.09.02.05;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2007.09.23.14.58.50;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2007.09.23.12.53.21;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2007.09.23.12.51.59;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2007.09.23.12.49.04;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2007.09.23.09.46.08;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2007.09.23.09.44.39;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2007.09.23.09.41.11;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2007.09.23.09.39.18;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2007.09.18.08.27.22;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2007.09.18.07.45.25;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2007.09.17.12.42.09;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2007.09.17.12.03.40;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2007.09.17.12.01.16;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2007.09.17.11.48.13;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2007.09.17.10.37.08;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2007.09.17.10.33.28;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2007.09.17.10.31.13;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2007.09.17.10.28.48;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2007.09.17.10.22.30;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2007.09.17.10.17.26;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2007.09.17.09.28.36;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2007.09.17.08.36.57;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2007.09.16.15.12.12;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2007.09.16.12.01.11;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2007.09.16.10.57.02;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2007.09.16.10.39.07;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.12.16.33.27;	author cnst;	state Exp;
branches;
next	1.61;

1.61
date	2007.03.02.04.32.32;	author ray;	state Exp;
branches;
next	1.60;

1.60
date	2007.01.04.17.55.35;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2005.04.13.02.33.08;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2004.11.29.06.20.03;	author jsg;	state Exp;
branches;
next	1.57;

1.57
date	2004.07.19.02.10.47;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2004.04.07.13.11.36;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2003.04.06.22.47.14;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2003.02.18.13.14.43;	author jmc;	state Exp;
branches;
next	1.52;

1.52
date	2002.07.31.19.29.20;	author mickey;	state Exp;
branches;
next	1.51;

1.51
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.50;

1.50
date	2002.03.19.00.08.31;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.02.13.42.51;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2002.03.02.00.23.13;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2001.11.17.19.37.46;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2001.11.11.12.35.02;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.11.06.02.06;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.11.01.19.23;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2001.09.04.23.35.58;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.29.12.53.40;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2001.05.23.12.34.44;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2001.05.03.13.41.06;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2000.12.27.19.07.58;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2000.11.24.14.36.34;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2000.09.14.13.52.42;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.14.13.46.45;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.14.13.32.06;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.30.23.26.25;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.23.16.41.53;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.23.16.20.01;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.23.16.18.09;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.23.16.15.49;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.17.14.38.15;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.10.01.41.05;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.10.01.32.22;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.10.01.26.36;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.26.16.21.32;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2000.03.26.16.08.27;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.01.03.23.32;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2000.01.20.18.14.58;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	99.12.19.00.04.25;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	99.12.18.21.58.07;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	99.12.18.21.56.07;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	99.12.18.21.53.32;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	99.12.18.02.11.26;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	99.12.16.17.27.18;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	99.12.06.22.28.44;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	99.11.11.11.35.17;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	99.10.05.22.06.24;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	98.12.05.00.06.27;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	98.07.13.02.11.37;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.06.03.17.00.05;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.03.15.22.19.24;	author flipk;	state Exp;
branches;
next	1.8;

1.8
date	97.12.16.22.26.21;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.06.15.21.29.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.11.30.21.08.56;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.02.16.04.11;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.36.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.02.22.22.24.47;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.23.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.42;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.139
log
@Dedup prototype for really_kill().
@
text
@/*	$OpenBSD: job.c,v 1.138 2017/01/21 12:31:34 natano Exp $	*/
/*	$NetBSD: job.c,v 1.16 1996/11/06 17:59:08 christos Exp $	*/

/*
 * Copyright (c) 2012 Marc Espie.
 *
 * Extensive code modifications for the OpenBSD project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*-
 * job.c --
 *	handle the creation etc. of our child processes.
 *
 * Interface:
 *	Job_Make		Start the creation of the given target.
 *
 *	Job_Init		Called to initialize this module. 
 *
 *	Job_Begin		execute commands attached to the .BEGIN target
 *				if any.
 *
 *	can_start_job		Return true if we can start job
 *
 *	Job_Empty		Return true if the job table is completely
 *				empty.
 *
 *	Job_Finish		Perform any final processing which needs doing.
 *				This includes the execution of any commands
 *				which have been/were attached to the .END
 *				target. 
 *
 *	Job_AbortAll		Abort all current jobs. It doesn't
 *				handle output or do anything for the jobs,
 *				just kills them. 
 *
 *	Job_Wait		Wait for all running jobs to finish.
 */

#include <sys/types.h>
#include <sys/wait.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "config.h"
#include "defines.h"
#include "job.h"
#include "engine.h"
#include "pathnames.h"
#include "var.h"
#include "targ.h"
#include "error.h"
#include "extern.h"
#include "lst.h"
#include "gnode.h"
#include "memory.h"
#include "make.h"
#include "buf.h"

static int	aborting = 0;	    /* why is the make aborting? */
#define ABORT_ERROR	1	    /* Because of an error */
#define ABORT_INTERRUPT 2	    /* Because it was interrupted */
#define ABORT_WAIT	3	    /* Waiting for jobs to finish */

static int	maxJobs;	/* The most children we can run at once */
static int	nJobs;		/* Number of jobs already allocated */
static bool	no_new_jobs;	/* Mark recursive shit so we shouldn't start
				 * something else at the same time
				 */
Job *runningJobs;		/* Jobs currently running a process */
Job *errorJobs;			/* Jobs in error at end */
static Job *heldJobs;		/* Jobs not running yet because of expensive */
static pid_t mypid;		/* Used for printing debugging messages */

static volatile sig_atomic_t got_fatal;

static volatile sig_atomic_t got_SIGINT, got_SIGHUP, got_SIGQUIT, got_SIGTERM, 
    got_SIGINFO;

static sigset_t sigset, emptyset;

static void handle_fatal_signal(int);
static void handle_siginfo(void);
static void postprocess_job(Job *, bool);
static Job *prepare_job(GNode *);
static void determine_job_next_step(Job *);
static void remove_job(Job *, bool);
static void may_continue_job(Job *);
static void continue_job(Job *);
static Job *reap_finished_job(pid_t);
static bool reap_jobs(void);

static void loop_handle_running_jobs(void);
static bool expensive_job(Job *);
static bool expensive_command(const char *);
static void setup_signal(int);
static void notice_signal(int);
static void setup_all_signals(void);
static const char *really_kill(Job *, int);
static void debug_kill_printf(const char *, ...);
static void debug_vprintf(const char *, va_list);
static void may_remove_target(Job *);
static void print_error(Job *);
static void internal_print_errors(void);

static int dying_signal = 0;

const char *	basedirectory = NULL;

static const char *
really_kill(Job *job, int signo)
{
	pid_t pid = job->pid;
	if (getpgid(pid) != getpgrp()) {
		if (killpg(pid, signo) == 0)
			return "group got signal";
		pid = -pid;
	} else {
		if (kill(pid, signo) == 0)
			return "process got signal";
	}
	if (errno == ESRCH)
		job->flags |= JOB_LOST;
	return strerror(errno);
}

static void
may_remove_target(Job *j)
{
	int dying = check_dying_signal();

	if (dying && !noExecute && !Targ_Precious(j->node)) {
		const char *file = Var(TARGET_INDEX, j->node);
		int r = eunlink(file);

		if (DEBUG(JOB) && r == -1)
			fprintf(stderr, " *** would unlink %s\n", file);
		if (r != -1)
			fprintf(stderr, " *** %s removed\n", file);
	}
}

static void
buf_addcurdir(BUFFER *buf)
{
	const char *v = Var_Value(".CURDIR");
	if (basedirectory != NULL) {
		size_t len = strlen(basedirectory);
		if (strncmp(basedirectory, v, len) == 0 &&
		    v[len] == '/') {
			v += len+1;
		} else if (strcmp(basedirectory, v) == 0) {
			Buf_AddString(buf, ".");
			return;
		}
	}
	Buf_AddString(buf, v);
}

static const char *
shortened_curdir(void)
{
	static BUFFER buf;
	bool first = true;
	if (first) {
		Buf_Init(&buf, 0);
		buf_addcurdir(&buf);
		first = false;
	}
	return Buf_Retrieve(&buf);
}

static void 
quick_error(Job *j, int signo, bool first)
{
	if (first) {
		fprintf(stderr, "*** Signal SIG%s", sys_signame[signo]);
		fprintf(stderr, " in %s (", shortened_curdir());
	} else
		fprintf(stderr, " ");

	fprintf(stderr, "%s", j->node->name);
	free(j->cmd);
}

static void 
print_error(Job *j)
{
	static bool first = true;
	BUFFER buf;

	Buf_Init(&buf, 0);

	if (j->exit_type == JOB_EXIT_BAD)
		Buf_printf(&buf, "*** Error %d", j->code);
	else if (j->exit_type == JOB_SIGNALED) {
		if (j->code < NSIG)
			Buf_printf(&buf, "*** Signal SIG%s", 
			    sys_signame[j->code]);
		else
			Buf_printf(&buf, "*** unknown signal %d", j->code);
	} else
		Buf_printf(&buf, "*** Should not happen %d/%d", 
		    j->exit_type, j->code);
	if (DEBUG(KILL) && (j->flags & JOB_LOST))
		Buf_AddChar(&buf, '!');
	if (first) {
		Buf_AddString(&buf, " in ");
		buf_addcurdir(&buf);
		first = false;
	}
	Buf_printf(&buf, " (%s:%lu", j->location->fname, j->location->lineno);
	Buf_printf(&buf, " '%s'", j->node->name);
	if ((j->flags & (JOB_SILENT | JOB_IS_EXPENSIVE)) == JOB_SILENT
	    && Buf_Size(&buf) < 140-2) {
		size_t len = strlen(j->cmd);
		Buf_AddString(&buf, ": ");
		if (len + Buf_Size(&buf) < 140)
			Buf_AddString(&buf, j->cmd);
		else {
			Buf_AddChars(&buf, 140 - Buf_Size(&buf), j->cmd);
			Buf_AddString(&buf, "...");
		}
	}
	fprintf(stderr, "%s)\n", Buf_Retrieve(&buf));
	Buf_Destroy(&buf);
	free(j->cmd);
}
static void
quick_summary(int signo)
{
	Job *j, *k, *jnext;
	bool first = true;

	k = errorJobs;
	errorJobs = NULL;
	for (j = k; j != NULL; j = jnext) {
		jnext = j->next;
		if ((j->exit_type == JOB_EXIT_BAD && j->code == signo+128) ||
		    (j->exit_type == JOB_SIGNALED && j->code == signo)) {
			quick_error(j, signo, first);
			first = false;
		} else {
			j->next = errorJobs;
			errorJobs = j;
		}
	}
	if (!first)
		fprintf(stderr, ")\n");
}

static void
internal_print_errors()
{
	Job *j, *k, *jnext;
	int dying;

	if (!errorJobs)
		fprintf(stderr, "Stop in %s\n", shortened_curdir());

	for (j = errorJobs; j != NULL; j = j->next)
		may_remove_target(j);
	dying = check_dying_signal();
	if (dying)
		quick_summary(dying);
	while (errorJobs != NULL) {
		k = errorJobs;
		errorJobs = NULL;
		for (j = k; j != NULL; j = jnext) {
			jnext = j->next;
			if (j->location->fname == k->location->fname)
				print_error(j);
			else {
				j->next = errorJobs;
				errorJobs = j;
			}
		}
	}
}

void
print_errors(void)
{
	handle_all_signals();
	internal_print_errors();
}

static void
setup_signal(int sig)
{
	if (signal(sig, SIG_IGN) != SIG_IGN) {
		(void)signal(sig, notice_signal);
		sigaddset(&sigset, sig);
	}
}

static void
notice_signal(int sig)
{

	switch(sig) {
	case SIGINT:
		got_SIGINT++;
		got_fatal = 1;
		break;
	case SIGHUP:
		got_SIGHUP++;
		got_fatal = 1;
		break;
	case SIGQUIT:
		got_SIGQUIT++;
		got_fatal = 1;
		break;
	case SIGTERM:
		got_SIGTERM++;
		got_fatal = 1;
		break;
	case SIGINFO:
		got_SIGINFO++;
		break;
	case SIGCHLD:
		break;
	}
}

static void
setup_all_signals(void)
{
	sigemptyset(&sigset);
	sigemptyset(&emptyset);
	/*
	 * Catch the four signals that POSIX specifies if they aren't ignored.
	 * handle_signal will take care of calling JobInterrupt if appropriate.
	 */
	setup_signal(SIGINT);
	setup_signal(SIGHUP);
	setup_signal(SIGQUIT);
	setup_signal(SIGTERM);
	/* Display running jobs on SIGINFO */
	setup_signal(SIGINFO);
	/* Have to see SIGCHLD */
	setup_signal(SIGCHLD);
	got_fatal = 0;
}

static void 
handle_siginfo(void)
{
	static BUFFER buf;
	static size_t length = 0;

	Job *job;
	bool first = true;

	got_SIGINFO = 0;
	/* we have to store the info in a buffer, because status from all
	 * makes running would get intermixed otherwise
	 */

	if (length == 0) {
		Buf_Init(&buf, 0);
		Buf_printf(&buf, "%s in ", Var_Value("MAKE"));
		buf_addcurdir(&buf);
		Buf_AddString(&buf, ": ");
		length = Buf_Size(&buf);
	} else
		Buf_Truncate(&buf, length);

	for (job = runningJobs; job != NULL ; job = job->next) {
		if (!first)
			Buf_puts(&buf, ", ");
		first = false;
		Buf_puts(&buf, job->node->name);
	}
	Buf_puts(&buf, first ? "nothing running\n" : "\n");

	fputs(Buf_Retrieve(&buf), stderr);
}

int
check_dying_signal(void)
{
	sigset_t set;
	if (dying_signal)
		return dying_signal;
	sigpending(&set);
	if (got_SIGINT || sigismember(&set, SIGINT))
		return dying_signal = SIGINT;
	if (got_SIGHUP || sigismember(&set, SIGHUP))
		return dying_signal = SIGHUP;
	if (got_SIGQUIT || sigismember(&set, SIGQUIT))
		return dying_signal = SIGQUIT;
	if (got_SIGTERM || sigismember(&set, SIGTERM))
		return dying_signal = SIGTERM;
	return 0;
}

void
handle_all_signals(void)
{
	if (got_SIGINFO)
		handle_siginfo();
	while (got_fatal) {
		got_fatal = 0;
		aborting = ABORT_INTERRUPT;

		if (got_SIGINT) {
			got_SIGINT=0;
			handle_fatal_signal(SIGINT);
		}
		if (got_SIGHUP) {
			got_SIGHUP=0;
			handle_fatal_signal(SIGHUP);
		}
		if (got_SIGQUIT) {
			got_SIGQUIT=0;
			handle_fatal_signal(SIGQUIT);
		}
		if (got_SIGTERM) {
			got_SIGTERM=0;
			handle_fatal_signal(SIGTERM);
		}
	}
}

static void
debug_vprintf(const char *fmt, va_list va)
{
	(void)printf("[%ld] ", (long)mypid);
	(void)vprintf(fmt, va);
	fflush(stdout);
}

void
debug_job_printf(const char *fmt, ...)
{
	if (DEBUG(JOB)) {
		va_list va;
		va_start(va, fmt);
		debug_vprintf(fmt, va);
		va_end(va);
	}
}

static void
debug_kill_printf(const char *fmt, ...)
{
	if (DEBUG(KILL)) {
		va_list va;
		va_start(va, fmt);
		debug_vprintf(fmt, va);
		va_end(va);
	}
}

/*-
 *-----------------------------------------------------------------------
 * postprocess_job  --
 *	Do final processing for the given job including updating
 *	parents and starting new jobs as available/necessary.
 *
 * Side Effects:
 *	If we got an error and are aborting (aborting == ABORT_ERROR) and
 *	the job list is now empty, we are done for the day.
 *	If we recognized an error we set the aborting flag
 *	to ABORT_ERROR so no more jobs will be started.
 *-----------------------------------------------------------------------
 */
/*ARGSUSED*/

static void
postprocess_job(Job *job, bool okay)
{
	if (okay &&
	    aborting != ABORT_ERROR &&
	    aborting != ABORT_INTERRUPT) {
		/* As long as we aren't aborting and the job didn't return a
		 * non-zero status that we shouldn't ignore, we call
		 * Make_Update to update the parents. */
		job->node->built_status = MADE;
		Make_Update(job->node);
		free(job);
	}

	if (errorJobs != NULL && !keepgoing &&
	    aborting != ABORT_INTERRUPT)
		aborting = ABORT_ERROR;

	if (aborting == ABORT_ERROR && DEBUG(QUICKDEATH))
		handle_fatal_signal(SIGINT);
	if (aborting == ABORT_ERROR && Job_Empty())
		Finish();
}

/* expensive jobs handling: in order to avoid forking an exponential number
 * of jobs, make tries to figure out "recursive make" configurations.
 * It may err on the side of caution.
 * Basically, a command is "expensive" if it's likely to fork an extra
 * level of make: either by looking at the command proper, or if it has
 * some specific qualities ('+cmd' are likely to be recursive, as are
 * .MAKE: commands).  It's possible to explicitly say some targets are
 * expensive or cheap with .EXPENSIVE or .CHEAP.
 *
 * While an expensive command is running, no_new_jobs
 * is set, so jobs that would fork new processes are accumulated in the
 * heldJobs list instead.
 *
 * This heuristics is also used on error exit: we display silent commands
 * that failed, unless those ARE expensive commands: expensive commands
 * are likely to not be failing by themselves, but to be the result of
 * a cascade of failures in descendant makes.
 */
void
determine_expensive_job(Job *job)
{ 
	if (expensive_job(job)) {
		job->flags |= JOB_IS_EXPENSIVE;
		no_new_jobs = true;
	} else
		job->flags &= ~JOB_IS_EXPENSIVE;
	if (DEBUG(EXPENSIVE))
		fprintf(stderr, "[%ld] Target %s running %.50s: %s\n",
		    (long)mypid, job->node->name, job->cmd,
		    job->flags & JOB_IS_EXPENSIVE ? "expensive" : "cheap");
}

static bool
expensive_job(Job *job)
{
	if (job->node->type & OP_CHEAP)
		return false;
	if (job->node->type & (OP_EXPENSIVE | OP_MAKE))
		return true;
	return expensive_command(job->cmd);
}

static bool
expensive_command(const char *s)
{
	const char *p;
	bool include = false;
	bool expensive = false;

	/* okay, comments are cheap, always */
	if (*s == '#')
		return false;
	/* and commands we always execute are expensive */
	if (*s == '+')
		return true;

	for (p = s; *p != '\0'; p++) {
		if (*p == ' ' || *p == '\t') {
			include = false;
			if (p[1] == '-' && p[2] == 'I')
				include = true;
		}
		if (include)
			continue;
		/* KMP variant, avoid looking twice at the same
		 * letter.
		 */
		if (*p != 'm')
			continue;
		if (p[1] != 'a')
			continue;
		p++;
		if (p[1] != 'k')
			continue;
		p++;
		if (p[1] != 'e')
			continue;
		p++;
		expensive = true;
		while (p[1] != '\0' && p[1] != ' ' && p[1] != '\t') {
			if (p[1] == '.' || p[1] == '/') {
				expensive = false;
				break;
			}
		    	p++;
		}
		if (expensive)
			return true;
	}
	return false;
}

static Job *
prepare_job(GNode *gn)
{
	/* a new job is prepared unless its commands are bogus (we don't
	 * have anything for it), or if we're in touch mode.
	 *
	 * Note that even in noexec mode, some commands may still run
	 * thanks to the +cmd construct.
	 */
	if (node_find_valid_commands(gn)) {
		if (touchFlag) {
			Job_Touch(gn);
			return NULL;
		} else {
			Job *job;       	

			job = emalloc(sizeof(Job));
			if (job == NULL)
				Punt("can't create job: out of memory");

			job_attach_node(job, gn);
			return job;
		}
	} else {
		node_failure(gn);
		return NULL;
	}
}

static void
may_continue_job(Job *job)
{
	if (no_new_jobs) {
		if (DEBUG(EXPENSIVE))
			fprintf(stderr, "[%ld] expensive -> hold %s\n",
			    (long)mypid, job->node->name);
		job->next = heldJobs;
		heldJobs = job;
	} else
		continue_job(job);
}

static void
continue_job(Job *job)
{
	bool finished = job_run_next(job);
	if (finished)
		remove_job(job, true);
	else
		determine_expensive_job(job);
}

/*-
 *-----------------------------------------------------------------------
 * Job_Make  --
 *	Start a target-creation process going for the target described
 *	by the graph node gn.
 *
 * Side Effects:
 *	A new Job node is created and  its commands continued, which
 *	may fork the first command of that job.
 *-----------------------------------------------------------------------
 */
void
Job_Make(GNode *gn)
{
	Job *job;

	job = prepare_job(gn);
	if (!job)
		return;
	nJobs++;
	may_continue_job(job);
}

static void
determine_job_next_step(Job *job)
{
	bool okay;
	if (job->flags & JOB_IS_EXPENSIVE) {
		no_new_jobs = false;
		if (DEBUG(EXPENSIVE))
			fprintf(stderr, "[%ld] "
			    "Returning from expensive target %s, "
			    "allowing new jobs\n", (long)mypid, 
			    job->node->name);
	}

	okay = job->exit_type == JOB_EXIT_OKAY;
	if (!okay || job->next_cmd == NULL)
		remove_job(job, okay);
	else
		may_continue_job(job);
}

static void
remove_job(Job *job, bool okay)
{
	nJobs--;
	postprocess_job(job, okay);
	while (!no_new_jobs) {
		if (heldJobs != NULL) {
			job = heldJobs;
			heldJobs = heldJobs->next;
			if (DEBUG(EXPENSIVE))
				fprintf(stderr, "[%ld] cheap -> release %s\n",
				    (long)mypid, job->node->name);
			continue_job(job);
		} else
			break;
	}
}

/*
 * job = reap_finished_job(pid):
 * 	retrieve and remove a job from runningJobs, based on its pid
 *
 *	Note that we remove it right away, so that handle_signals()
 *	is accurate.
 */
static Job *
reap_finished_job(pid_t pid)
{
	Job **j, *job;

	for (j = &runningJobs; *j != NULL; j = &((*j)->next))
		if ((*j)->pid == pid) {
			job = *j;
			*j = job->next;
			return job;
		}

	return NULL;
}

/*
 * classic waitpid handler: retrieve as many dead children as possible.
 * returns true if succesful
 */
static bool
reap_jobs(void)
{
 	pid_t pid;	/* pid of dead child */
 	int status;	/* Exit/termination status */
	bool reaped = false;
	Job *job;

	while ((pid = waitpid(WAIT_ANY, &status, WNOHANG)) > 0) {
		reaped = true;
		job = reap_finished_job(pid);

		if (job == NULL) {
			Punt("Child (%ld) not in table?", (long)pid);
		} else {
			job_handle_status(job, status);
			determine_job_next_step(job);
		}
	}
	/* sanity check, should not happen */
	if (pid == -1 && errno == ECHILD && runningJobs != NULL)
		Punt("Process has no children, but runningJobs is not empty ?");
	return reaped;
}

void
handle_running_jobs(void)
{
	sigset_t old;
	/* reaping children in the presence of caught signals */

	/* first, we make sure to hold on new signals, to synchronize
	 * reception of new stuff on sigsuspend
	 */
	sigprocmask(SIG_BLOCK, &sigset, &old);
	/* note this will NOT loop until runningJobs == NULL.
	 * It's merely an optimisation, namely that we don't need to go 
	 * through the logic if no job is present. As soon as a job 
	 * gets reaped, we WILL exit the loop through the break.
	 */
	while (runningJobs != NULL) {
		/* did we already have pending stuff that advances things ?
		 * then handle_all_signals() will not return
		 * or reap_jobs() will reap_jobs()
		 */
		handle_all_signals();
		if (reap_jobs())
			break;
		/* okay, so it's safe to suspend, we have nothing to do but
		 * wait...
		 */
		sigsuspend(&emptyset);
	}
	sigprocmask(SIG_SETMASK, &old, NULL);
}

void
handle_one_job(Job *job)
{
	int stat;
	int status;
	sigset_t old;

	sigprocmask(SIG_BLOCK, &sigset, &old);
	while (1) {
		handle_all_signals();
		stat = waitpid(job->pid, &status, WNOHANG);
		if (stat == job->pid)
			break;
		sigsuspend(&emptyset);
	}
	runningJobs = NULL;
	job_handle_status(job, status);
	sigprocmask(SIG_SETMASK, &old, NULL);
}

static void
loop_handle_running_jobs()
{
	while (runningJobs != NULL)
		handle_running_jobs();
}

void
Job_Init(int maxproc)
{
	runningJobs = NULL;
	heldJobs = NULL;
	errorJobs = NULL;
	maxJobs = maxproc;
	mypid = getpid();

	nJobs = 0;

	aborting = 0;
	setup_all_signals();
}

bool
can_start_job(void)
{
	if (aborting || nJobs >= maxJobs)
		return false;
	else
		return true;
}

bool
Job_Empty(void)
{
	return runningJobs == NULL;
}

/*-
 *-----------------------------------------------------------------------
 * handle_fatal_signal --
 *	Handle the receipt of a fatal interrupt
 *
 * Side Effects:
 *	All children are killed. Another job may be started if there
 *	is an interrupt target and the signal was SIGINT.
 *-----------------------------------------------------------------------
 */
static void
handle_fatal_signal(int signo)
{
	Job *job;

	debug_kill_printf("handle_fatal_signal(%d) called.\n", signo);

	dying_signal = signo;
	for (job = runningJobs; job != NULL; job = job->next) {
		debug_kill_printf("passing to "
		    "child %ld running %s: %s\n", (long)job->pid,
		    job->node->name, really_kill(job, signo));
		may_remove_target(job);
	}

	if (signo == SIGINT && !touchFlag) {
		if ((interrupt_node->type & OP_DUMMY) == 0) {
			ignoreErrors = false;

			Job_Make(interrupt_node);
		}
	}
	loop_handle_running_jobs();
	internal_print_errors();

	/* die by that signal */
	sigprocmask(SIG_BLOCK, &sigset, NULL);
	signal(signo, SIG_DFL);
	kill(getpid(), signo);
	sigprocmask(SIG_SETMASK, &emptyset, NULL);
	/*NOTREACHED*/
	fprintf(stderr, "This should never happen\n");
	exit(1);
}

/*
 *-----------------------------------------------------------------------
 * Job_Finish --
 *	Do final processing such as the running of the commands
 *	attached to the .END target.
 *
 *	return true if fatal errors have happened.
 *-----------------------------------------------------------------------
 */
bool
Job_Finish(void)
{
	bool problem = errorJobs != NULL;

	if ((end_node->type & OP_DUMMY) == 0) {
		if (problem) {
			Error("Errors reported so .END ignored");
		} else {
			Job_Make(end_node);
			loop_handle_running_jobs();
		}
	}
	return problem;
}

void
Job_Begin(void)
{
	if ((begin_node->type & OP_DUMMY) == 0) {
		Job_Make(begin_node);
		loop_handle_running_jobs();
	}
}

/*-
 *-----------------------------------------------------------------------
 * Job_Wait --
 *	Waits for all running jobs to finish and returns. Sets 'aborting'
 *	to ABORT_WAIT to prevent other jobs from starting.
 *
 * Side Effects:
 *	Currently running jobs finish.
 *
 *-----------------------------------------------------------------------
 */
void
Job_Wait(void)
{
	aborting = ABORT_WAIT;
	loop_handle_running_jobs();
	aborting = 0;
}

/*-
 *-----------------------------------------------------------------------
 * Job_AbortAll --
 *	Abort all currently running jobs without handling output or anything.
 *	This function is to be called only in the event of a major
 *	error.
 *
 * Side Effects:
 *	All children are killed
 *-----------------------------------------------------------------------
 */
void
Job_AbortAll(void)
{
	Job *job;	/* the job descriptor in that element */
	int foo;

	aborting = ABORT_ERROR;

	for (job = runningJobs; job != NULL; job = job->next) {
		killpg(job->pid, SIGINT);
		killpg(job->pid, SIGKILL);
	}

	/*
	 * Catch as many children as want to report in at first, then give up
	 */
	while (waitpid(WAIT_ANY, &foo, WNOHANG) > 0)
		continue;
}
@


1.138
log
@Use errno to make the debug message more descriptive.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.137 2017/01/21 11:30:11 deraadt Exp $	*/
a161 1
static const char *really_kill(Job *, int);
@


1.137
log
@Stop calling out to sudo/doas to kill processes.  Reliance on system
configuration to perform a racy behaviour is not wise.
ok natano
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.136 2015/07/28 14:22:26 espie Exp $	*/
d182 1
a182 1
	if (errno == ESRCH) {
d184 1
a184 3
		return "not found";
	} else
		return "should not happen";
@


1.136
log
@let the hack that lets make kill jobs after sudo also work with doas.
okay tedu@@, millert@@, tweaks by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.135 2012/12/14 11:10:03 espie Exp $	*/
a158 1
static void kill_with_doas_maybe(pid_t, int, const char *);
a169 31
static void 
kill_with_doas_maybe(pid_t pid, int signo, const char *p)
{
	char buf[32]; /* largely enough */
	int sudo;

	for (;*p != '\0'; p++) {
		if (*p == 's')
			sudo = 1;
		else if (*p == 'd')
			sudo = 0;
		else
			continue;
		if (sudo && p[1] != 'u' || !sudo && p[1] != 'o')
			continue;
		p++;
		if (sudo && p[1] != 'd' || !sudo && p[1] != 'a')
			continue;
		p++;
		if (sudo && p[1] != 'o' || !sudo && p[1] != 's')
			continue;
		snprintf(buf, sizeof buf, "%s -n /bin/kill -%d %ld", 
		    sudo ? "sudo" : "doas",
		    signo, (long)pid);
		debug_kill_printf("trying to kill with %s", buf);
		system(buf);
		return;
	}

}

a184 3
	} else if (errno == EPERM) {
		kill_with_doas_maybe(pid, signo, job->cmd);
		return "";
@


1.135
log
@a few more comments
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.134 2012/12/08 12:54:17 espie Exp $	*/
d159 1
a159 1
static void kill_with_sudo_maybe(pid_t, int, const char *);
d172 1
a172 1
kill_with_sudo_maybe(pid_t pid, int signo, const char *p)
d175 1
d178 5
a182 1
		if (*p != 's')
d184 1
a184 1
		if (p[1] != 'u')
d187 1
a187 1
		if (p[1] != 'd')
d190 1
a190 1
		if (p[1] != 'o')
d192 2
a193 1
		snprintf(buf, sizeof buf, "sudo -n /bin/kill -%d %ld", 
d218 1
a218 1
		kill_with_sudo_maybe(pid, signo, job->cmd);
@


1.134
log
@document a bit of job.c
notice that Job_Finish() really returns a boolean, so unconfuse
that accordingly (it's likely the extra Fatal() message is not
needed and we could just call finish)
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.133 2012/11/24 11:05:33 espie Exp $	*/
d417 1
a417 1
void
d852 5
@


1.133
log
@Don't output a . at the end of directory, as it is confusing.
okay beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.132 2012/10/23 20:32:21 espie Exp $	*/
d132 1
a132 1
static pid_t mypid;
d982 1
a982 1
	bool errors = errorJobs != NULL;
d985 1
a985 1
		if (errors) {
d992 1
a992 1
	return errors;
@


1.132
log
@fix fringe case where length is around 140.
problem found by Tobias Ulmer.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.131 2012/10/18 17:54:43 espie Exp $	*/
d350 1
a350 1
		fprintf(stderr, "Stop in %s.\n", shortened_curdir());
@


1.131
log
@numerous error message fixes:
- do ^C checking differently: don't record sent signals, but when jobs
die, recheck whether we received/have pending a INT/QUIT/TERM/HUP signal.
Then don't display our process group "normally", instead group together
everything dying by signal/shell dying by signal (just give the target
names).

- make certain we always handle signals before dying from "other conditions"
- have the parser messages look more like normal messages
- remove double error messages from some parser errors
- make sure unclosed variables ARE errors when some modifiers are present

- keep track of the base directory we're run from, so that submakes can
get shortened directories...
- make sure the whole error message including silent command fits into a
reasonable length.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.130 2012/10/09 19:46:33 espie Exp $	*/
d306 1
a306 1
	    && Buf_Size(&buf) < 140) {
@


1.130
log
@tweak error messages yet some more, lots of feedback from
deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.129 2012/10/06 19:19:53 espie Exp $	*/
d163 7
a199 1
	job->sent_signal = signo;
d221 3
a223 3
	if ((j->sent_signal == SIGINT || j->sent_signal == SIGQUIT ||
	    j->sent_signal == SIGHUP || j->sent_signal == SIGTERM) 
	    && !noExecute && !Targ_Precious(j->node)) {
d234 43
d281 3
d285 3
a287 6
	if (j->exit_type == JOB_EXIT_BAD) {
		fprintf(stderr, "*** Error %d", j->code);
		if (j->sent_signal != 0 && j->code == j->sent_signal + 128)
			fprintf(stderr, " (SIG%s in shell)", 
			    sys_signame[j->sent_signal]);
	} else if (j->exit_type == JOB_SIGNALED) {
d289 1
a289 1
			fprintf(stderr, "*** Signal SIG%s", 
d292 1
a292 1
			fprintf(stderr, "*** unknown signal %d", j->code);
d294 2
a295 1
		fprintf(stderr, "*** Should not happen %d", j->code);
d297 1
a297 1
		fprintf(stderr, "!");
d299 2
a300 1
		fprintf(stderr, " in %s", Var_Value(".CURDIR"));
d303 15
a317 6
	fprintf(stderr, " (%s:%lu", j->location->fname, j->location->lineno);
	fprintf(stderr, " '%s'", j->node->name);
	if ((j->flags & (JOB_SILENT | JOB_IS_EXPENSIVE)) == JOB_SILENT)
		fprintf(stderr, ": %.120s%s", j->cmd, 
		    strlen(j->cmd) > 120 ? "..." : "");
	fprintf(stderr, ")\n");
d319 22
a340 1
	may_remove_target(j);
d343 2
a344 2
void
print_errors(void)
d347 1
d350 1
a350 1
		fprintf(stderr, "Stop in %s.\n", Var_Value(".CURDIR"));
d352 5
d372 7
d453 3
a455 1
		Buf_printf(&buf, "%s in %s: ", Var_Value("MAKE"), Var_Value(".CURDIR"));
d471 18
a845 1

d942 1
a942 1

d958 1
a958 1
	print_errors();
d966 2
@


1.129
log
@truncate silent command output to two lines. okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.128 2012/10/06 09:32:40 espie Exp $	*/
d208 2
a209 1
	}
d229 1
a229 1
print_error(Job *j, Job *k)
d231 1
a231 1
	const char *type;
d240 1
a240 1
			fprintf(stderr, "*** SIG%s", 
d248 6
a253 5
	fprintf(stderr, " (line %lu", j->location->lineno);
	if (j == k)
		fprintf(stderr, " of %s,", j->location->fname);
	else
		fputs(",", stderr);
d255 3
a257 5
		fprintf(stderr, "\n     target '%s': %.150s%s", j->node->name, 
		    j->cmd, strlen(j->cmd) > 150 ? "..." : "");
	else
		fprintf(stderr, " target '%s'", j->node->name);
	fputs(")\n", stderr);
d267 2
a268 2
	fprintf(stderr, "\nStop in %s%c\n", Var_Value(".CURDIR"),
	    errorJobs ? ':' : '.');
d276 1
a276 1
				print_error(j, k);
@


1.128
log
@- extra juice for debugging signal passing.  Note when we can't pass the
signal because the process already bought it (pgroups will do that to you)
(lots of discussion with Todd on that one)
- tweak error handling some more to make it less verbose when just one job
is running...
- show signal name in case of signal interrupts.
- zap OP_LIB, move that stuff to the location where we warn when we meet
that bug.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.127 2012/10/04 13:20:46 espie Exp $	*/
d253 2
a254 2
		fprintf(stderr, "\n     target '%s': %s", j->node->name, 
		    j->cmd);
@


1.127
log
@backout pgroup/job control from make, there is something deeply bogus
in stdin interaction.

Fixes update-patches as reported by aja...
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.126 2012/10/02 10:29:30 espie Exp $	*/
d134 1
a134 1
static volatile sig_atomic_t got_fatal, got_other;
d137 1
a137 2
    got_SIGINFO, got_SIGTSTP, got_SIGTTOU, got_SIGTTIN, got_SIGCONT, 
    got_SIGWINCH;
a141 1
static void pass_job_control_signal(int);
d158 5
a162 2
static void setup_job_control_interrupts(void);
static void killcheck(pid_t, int);
d164 2
a165 2
static void
killcheck(pid_t pid, int signo)
d167 17
a183 1
	if (kill(pid, signo) == 0)
d185 17
d203 2
a204 3
		fprintf(stderr, 
		    "Can't send signal %d to %ld: pid not found\n",
		    signo, (long)pid);
d206 18
a223 3
		fprintf(stderr, 
		    "Can't send signal %d to %ld: not permitted\n",
		    signo, (long)pid);
d232 16
a247 9
	if (j->exit_type == JOB_EXIT_BAD)
		type = "Exit status";
	else if (j->exit_type == JOB_SIGNALED)
		type = "Received signal";
	else
		type = "Should not happen";
	fprintf(stderr, " %s %d (", type, j->code);
	fprintf(stderr, "line %lu",
	    j->location->lineno);
d253 2
a254 1
		fprintf(stderr, "\n     target %s: %s", j->node->name, j->cmd);
d256 1
a256 1
		fprintf(stderr, " target %s", j->node->name);
d259 1
a319 20
	case SIGTSTP:
		got_SIGTSTP++;
		got_other = 1;
		break;
	case SIGTTOU:
		got_SIGTTOU++;
		got_other = 1;
		break;
	case SIGTTIN:
		got_SIGTTIN++;
		got_other = 1;
		break;
	case SIGCONT:
		got_SIGCONT++;
		got_other = 1;
		break;
	case SIGWINCH:
		got_SIGWINCH++;
		got_other = 1;
		break;
a322 8
static void
setup_job_control_interrupts(void)
{
	setup_signal(SIGTSTP);
	setup_signal(SIGTTOU);
	setup_signal(SIGTTIN);
}

a340 1
	got_other = 0;
a379 23
	while (got_other) {
		got_other = 0;
		if (got_SIGWINCH) {
			got_SIGWINCH=0;
			pass_job_control_signal(SIGWINCH);
		}
		if (got_SIGTTIN) {
			got_SIGTTIN=0;
			pass_job_control_signal(SIGTTIN);
		}
		if (got_SIGTTOU) {
			got_SIGTTOU=0;
			pass_job_control_signal(SIGTTOU);
		}
		if (got_SIGTSTP) {
			got_SIGTSTP=0;
			pass_job_control_signal(SIGTSTP);
		}
		if (got_SIGCONT) {
			got_SIGCONT=0;
			pass_job_control_signal(SIGCONT);
		}
	}
d403 8
a415 1
		(void)printf("[%ld] ", (long)mypid);
d417 12
a428 2
		(void)vprintf(fmt, va);
		fflush(stdout);
a811 27
static void
pass_job_control_signal(int signo)
{
	Job *job;

	debug_job_printf("pass_job_control_signal(%d) called.\n", signo);


	for (job = runningJobs; job != NULL; job = job->next) {
		debug_job_printf("pass_job_control_signal to "
		    "child %ld running %s.\n", (long)job->pid,
		    job->node->name);
		killcheck(job->pid, signo);
	}
	/* after forwarding the signal, those should interrupt us */
	if (signo == SIGTSTP || signo == SIGTTOU || signo == SIGTTIN) {
		sigprocmask(SIG_BLOCK, &sigset, NULL);
		signal(signo, SIG_DFL);
		kill(getpid(), signo);
		sigprocmask(SIG_SETMASK, &emptyset, NULL);
	}
	/* SIGWINCH is irrelevant for us, SIGCONT must put back normal
	 * handling for other job control signals */
	if (signo == SIGCONT)
		setup_job_control_interrupts();
}

d827 1
a827 1
	debug_job_printf("handle_fatal_signal(%d) called.\n", signo);
d831 4
a834 10
		if (!Targ_Precious(job->node)) {
			const char *file = Var(TARGET_INDEX, job->node);

			if (!noExecute && eunlink(file) != -1)
				Error("*** %s removed", file);
		}
		debug_job_printf("handle_fatal_signal: passing to "
		    "child %ld running %s.\n", (long)job->pid,
		    job->node->name);
		killcheck(job->pid, signo);
@


1.126
log
@more changes, discussed and tested by various people.
- put back some job control, turns out it's necessary when we don't run a
shell.
- zap old #ifdef CLEANUP code... probably doesn't even compile.
- kill most of the OP_LIB code. Just keep a wee little bit for compatibility
(deprecated .LIBS and .INCLUDES, warns for weird dependencies instead of
erroring out).
- much improved debugging and -p output: sort variables, targets, rules,
output stuff in a nicer format mimicing input.
- better error message when no command is found, explain where the target comes from.
- sort final error list by file.
- show system files in errors as <bsd.prog.mk>
- reincorporate random delay, that was dropped
- optimize siginfo output by not regenerating the whole string each time.
- finish zapping old LocationInfo field that's no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.125 2012/09/21 08:18:40 espie Exp $	*/
d161 17
a311 3
	setup_job_control_interrupts();
	setup_signal(SIGWINCH);
	setup_signal(SIGCONT);
d802 1
a802 1
		killpg(job->pid, signo);
d845 1
a845 1
		killpg(job->pid, signo);
@


1.125
log
@vax, found by fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.124 2012/09/21 07:55:20 espie Exp $	*/
a75 2
 *	Job_End 		Should cleanup any memory used.
 *
d134 1
a134 1
static volatile sig_atomic_t got_fatal;
d137 2
a138 1
    got_SIGINFO;
d142 2
a143 1
static void handle_signal(int);
d160 27
a186 1
static void really_kill(int, pid_t);
d191 1
a191 2
	Job *j;
	const char *previous = NULL;
d196 12
a207 23
	for (j = errorJobs; j != NULL; j = j->next) {
		const char *type;

		if (j->exit_type == JOB_EXIT_BAD)
			type = "Exit status";
		else if (j->exit_type == JOB_SIGNALED)
			type = "Received signal";
		else
			type = "Should not happen";
		fprintf(stderr, " %s %d (", type, j->code);
		fprintf(stderr, "line %lu",
		    j->location->lineno);
		if (j->location->fname == previous)
			fputs(",", stderr);
		else
			fprintf(stderr, " of %s,", j->location->fname);
		previous = j->location->fname;
		if ((j->flags & (JOB_SILENT | JOB_IS_EXPENSIVE)) == JOB_SILENT)
			fprintf(stderr, "\n     target %s: %s", j->node->name, j->cmd);
		else
			fprintf(stderr, " target %s", j->node->name);
		fputs(")\n", stderr);
		free(j->cmd);
d223 1
d246 20
d269 8
d295 4
d304 3
a307 1
	BUFFER buf;
a313 1
	Buf_Init(&buf, 0);
d315 6
a320 1
	Buf_printf(&buf, "%s in %s: ", Var_Value("MAKE"), Var_Value(".CURDIR"));
a330 1
	Buf_Destroy(&buf);
d338 23
d367 1
a367 1
			handle_signal(SIGINT);
d371 1
a371 1
			handle_signal(SIGHUP);
d375 1
a375 1
			handle_signal(SIGQUIT);
d379 1
a379 1
			handle_signal(SIGTERM);
d431 1
a431 1
		handle_signal(SIGINT);
a594 1
	bool finished;
d777 1
a777 1
really_kill(pid_t pid, int sig)
d779 22
a800 3
	killpg(pid, sig);
	if (killpg(pid, sig) == - 1 && errno == ESRCH)
		kill(pid, sig);
d802 1
d805 2
a806 2
 * handle_signal --
 *	Handle the receipt of an interrupt.
d809 2
a810 2
 *	All children are killed. Another job may be started if the
 *	.INTERRUPT target was given.
d814 1
a814 1
handle_signal(int signo)
d818 1
a818 1
	debug_job_printf("handle_signal(%d) called.\n", signo);
d828 1
a828 1
		debug_job_printf("handle_signal passing signal to "
d831 1
a831 1
		really_kill(job->pid, signo);
d847 1
a847 1
	really_kill(getpid(), signo);
a885 7
#ifdef CLEANUP
void
Job_End(void)
{
}
#endif

d925 2
a926 2
		really_kill(job->pid, SIGINT);
		really_kill(job->pid, SIGKILL);
@


1.124
log
@major overhaul of the way make handle jobs, inspired by dpb:
instead of forking a "job" per target, and having that job further fork
separate commands, have make maintain a list of jobs, indexed by pid
of currently running commands, and handle process termination
continuation-style.  This has lots of benefits:
- make is responsible for most printing, so we no longer need pipes nor
job control: make -j jobs see the tty.
- no more special-casing for jobs that don't really execute anything.
- unify code for make -jn and make -B, including signal handlers and
job waiting.  So make -n, make -q, +cmd now run commands in the same
way in all cases.
- unified more accurate error-reporting, as make knows precisely which
command failed. Commands are tagged with their lines, and we display failing
commands in silent mode.
- fine-grained "expensive" command handling (recursion limiter). Do it
per-command instead of per-target.

Moreover, signal response is now simpler, as we just block the signals
in a small critical sections, test for events, and sigpause (thanks a lot
to guenther@@ and millert@@), so running make is now almost always paused
without any busy-waiting.

Thanks to everyone who tested and gave input.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.123 2012/08/25 08:12:56 espie Exp $	*/
d166 1
a169 1
	const char *previous = NULL;
@


1.123
log
@- make wrong variable specs (unterminated) parse errors.
- add info to be able to pinpoint parse errors at runtime.
- let job runners abort when a parse error happens while expanding a variable
during execution
- fix an infinite loop when compiling without FEATURE_RECVARS.

okay millert@@, krw@@
the very few errors found out by this (less than 10 over src/X/ports)
fixed trivially beforehand, as requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.122 2012/04/11 18:27:30 espie Exp $	*/
d5 26
d71 4
a74 5
 *	Job_Init		Called to initialize this module. in addition,
 *				any commands attached to the .BEGIN target
 *				are executed before this function returns.
 *				Hence, the makefile must have been parsed
 *				before this function is called.
d76 1
a76 1
 *	Job_End 		Cleanup any memory used.
d86 1
a86 2
 *				target. It should only be called when the
 *				job table is empty.
d90 1
a90 2
 *				just kills them. It should only be called in
 *				an emergency, as it were.
d114 1
a115 1
#include "extern.h"
d119 1
a119 55

/*
 * The SEL_ constants determine the maximum amount of time spent in select
 * before coming out to see if a child has finished. SEL_SEC is the number of
 * seconds and SEL_USEC is the number of micro-seconds
 */
#define SEL_SEC 	0
#define SEL_USEC	500000


/*-
 * Job Table definitions.
 *
 * Each job has several things associated with it:
 *	1) The process id of the child shell
 *	2) The graph node describing the target being made by this job
 *	3) An FILE* for writing out the commands. This is only
 *	   used before the job is actually started.
 *	4) Things used for handling the shell's output.
 *	   the output is being caught via a pipe and
 *	   the descriptors of our pipe, an array in which output is line
 *	   buffered and the current position in that buffer are all
 *	   maintained for each job.
 *	5) A word of flags which determine how the module handles errors,
 *	   echoing, etc. for the job
 *
 * The job "table" is kept as a linked Lst in 'jobs', with the number of
 * active jobs maintained in the 'nJobs' variable. At no time will this
 * exceed the value of 'maxJobs', initialized by the Job_Init function.
 *
 * When a job is finished, the Make_Update function is called on each of the
 * parents of the node which was just remade. This takes care of the upward
 * traversal of the dependency graph.
 */
#define JOB_BUFSIZE	1024
struct job_pipe {
	int fd;
	char buffer[JOB_BUFSIZE];
	size_t pos;
};

typedef struct Job_ {
    pid_t 	pid;	    /* The child's process ID */
    GNode	*node;	    /* The target the child is making */
    short	flags;	    /* Flags to control treatment of job */
    LstNode	p;
#define JOB_DIDOUTPUT	0x001
#define JOB_IS_SPECIAL	0x004	/* Target is a special one. */
#define JOB_IS_EXPENSIVE 0x002
    struct job_pipe in[2];
} Job;

struct job_pid {
	pid_t pid;
};
d127 8
a134 31
static int	nJobs;		/* The number of current children */
static bool	expensive_job;
static LIST	runningJobs;	/* The structures that describe them */
static GNode	*lastNode;	/* The node for which output was most recently
				 * produced. */
static LIST	job_pids;	/* a simple list that doesn't move that much */

/* data structure linked to job handling through select */
static fd_set *output_mask = NULL;	/* File descriptors to look for */

static fd_set *actual_mask = NULL;	/* actual select argument */
static int largest_fd = -1;
static size_t mask_size = 0;

/* wait possibilities */
#define JOB_EXITED 0
#define JOB_SIGNALED 1
#define JOB_UNKNOWN 4

static LIST	errorsList;
static int	errors;
struct error_info {
	int reason;
	int code;
	GNode *n;
};

/* for blocking/unblocking */
static sigset_t oset, set;
static void block_signals(void);
static void unblock_signals(void);
d136 1
a136 26
static void handle_all_signals(void);
static void handle_signal(int);
static int JobCmpPid(void *, void *);
static void process_job_status(Job *, int);
static void JobExec(Job *);
static void JobStart(GNode *, int);
static void JobInterrupt(bool, int);
static void debug_printf(const char *, ...);
static Job *prepare_job(GNode *, int);
static void banner(Job *, FILE *);
static bool Job_Full(void);

/***
 ***  Input/output from jobs
 ***/

/* prepare_pipe(jp, &fd):
 *	set up pipe data structure (buffer and pos) corresponding to
 *	pointed fd, and prepare to watch for it.
 */
static void prepare_pipe(struct job_pipe *, int *);

/* close_job_pipes(j):
 *	handle final output from job, and close pipes properly
 */
static void close_job_pipes(Job *);
d138 2
d141 1
a141 1
static void handle_all_jobs_output(void);
d143 10
a152 4
/* handle_job_output(job, n, finish):
 *	n = 0 or 1 (stdout/stderr), set finish to retrieve everything.
 */
static void handle_job_output(Job *, int, bool);
a153 7
static void print_partial_buffer(struct job_pipe *, Job *, FILE *, size_t);
static void print_partial_buffer_and_shift(struct job_pipe *, Job *, FILE *,
    size_t);
static bool print_complete_lines(struct job_pipe *, Job *, FILE *, size_t);


static void register_error(int, int, Job *);
d155 6
a160 1
static void Job_CatchChildren(void);
d162 2
a163 2
static void
register_error(int reason, int code, Job *job)
d165 5
a169 1
	struct error_info *p;
d171 2
a172 7
	errors++;
	p = emalloc(sizeof(struct error_info));
	p->reason = reason;
	p->code = code;
	p->n = job->node;
	Lst_AtEnd(&errorsList, p);
}
d174 1
a174 11
void
print_errors()
{
	LstNode ln;
	struct error_info *p;
	const char *type;

	for (ln = Lst_First(&errorsList); ln != NULL; ln = Lst_Adv(ln)) {
		p = (struct error_info *)Lst_Datum(ln);
		switch(p->reason) {
		case JOB_EXITED:
d176 1
a176 2
			break;
		case JOB_SIGNALED:
d178 1
a178 2
			break;
		default:
d180 14
a193 7
			break;
		}
	if (p->n->origin.lineno)
		Error(" %s %d (%s, line %lu of %s)",
		    type, p->code, p->n->name, p->n->origin.lineno, p->n->origin.fname);
	else
		Error(" %s %d (%s)", type, p->code, p->n->name);
d198 1
a198 1
banner(Job *job, FILE *out)
d200 3
a202 4
	if (job->node != lastNode) {
		if (DEBUG(JOBBANNER))
			(void)fprintf(out, "--- %s ---\n", job->node->name);
		lastNode = job->node;
a205 2
volatile sig_atomic_t got_SIGTSTP, got_SIGTTOU, got_SIGTTIN, got_SIGWINCH,
    got_SIGCONT;
d207 1
a207 47
handle_all_signals()
{
	while (got_signal) {
		got_signal = 0;

		if (got_SIGINT) {
			got_SIGINT=0;
			handle_signal(SIGINT);
		}
		if (got_SIGHUP) {
			got_SIGHUP=0;
			handle_signal(SIGHUP);
		}
		if (got_SIGQUIT) {
			got_SIGQUIT=0;
			handle_signal(SIGQUIT);
		}
		if (got_SIGTERM) {
			got_SIGTERM=0;
			handle_signal(SIGTERM);
		}
		if (got_SIGTSTP) {
			got_SIGTSTP=0;
			signal(SIGTSTP, parallel_handler);
		}
		if (got_SIGTTOU) {
			got_SIGTTOU=0;
			signal(SIGTTOU, parallel_handler);
		}
		if (got_SIGTTIN) {
			got_SIGTTIN=0;
			signal(SIGTTIN, parallel_handler);
		}
		if (got_SIGWINCH) {
			got_SIGWINCH=0;
			signal(SIGWINCH, parallel_handler);
		}
		if (got_SIGCONT) {
			got_SIGCONT = 0;
			signal(SIGCONT, parallel_handler);
		}
	}
}

/* this is safe from interrupts, actually */
void
parallel_handler(int signo)
d209 1
a209 9
	int save_errno = errno;
	LstNode ln;
	for (ln = Lst_First(&job_pids); ln != NULL; ln = Lst_Adv(ln)) {
	    	struct job_pid *p = Lst_Datum(ln);
		killpg(p->pid, signo);
	}
	errno = save_errno;

	switch(signo) {
d212 2
a213 2
		got_signal = 1;
		return;
d216 2
a217 2
		got_signal = 1;
		return;
d220 2
a221 2
		got_signal = 1;
		return;
d224 1
a224 9
		got_signal = 1;
		return;
	case SIGTSTP:
		got_SIGTSTP++;
		got_signal = 1;
		break;
	case SIGTTOU:
		got_SIGTTOU++;
		got_signal = 1;
d226 2
a227 3
	case SIGTTIN:
		got_SIGTTIN++;
		got_signal = 1;
d229 1
a229 7
	case SIGWINCH:
		got_SIGWINCH++;
		got_signal = 1;
		break;
	case SIGCONT:
		got_SIGCONT++;
		got_signal = 1;
d232 1
a232 1
	(void)killpg(getpid(), signo);
d234 18
a251 2
	(void)signal(signo, SIG_DFL);
	errno = save_errno;
d254 2
a255 9
/*-
 *-----------------------------------------------------------------------
 * handle_signal --
 *	handle a signal for ourselves
 *
 *-----------------------------------------------------------------------
 */
static void
handle_signal(int signo)
d257 3
a259 4
	if (DEBUG(JOB)) {
		(void)fprintf(stdout, "handle_signal(%d) called.\n", signo);
		(void)fflush(stdout);
	}
d261 3
a263 5
	/*
	 * Deal with proper cleanup based on the signal received. We only run
	 * the .INTERRUPT target if the signal was in fact an interrupt. The
	 * other three termination signals are more of a "get out *now*"
	 * command.
d265 11
a275 4
	if (signo == SIGINT)
		JobInterrupt(true, signo);
	else if (signo == SIGHUP || signo == SIGTERM || signo == SIGQUIT)
		JobInterrupt(false, signo);
d277 2
a278 2
	if (signo == SIGQUIT)
		Finish(0);
d281 2
a282 14
/*-
 *-----------------------------------------------------------------------
 * JobCmpPid  --
 *	Compare the pid of the job with the given pid and return 0 if they
 *	are equal. This function is called from Job_CatchChildren via
 *	Lst_Find to find the job descriptor of the finished job.
 *
 * Results:
 *	0 if the pid's match
 *-----------------------------------------------------------------------
 */
static int
JobCmpPid(void *job,	/* job to examine */
    void *pid)		/* process id desired */
d284 23
a306 1
	return *(pid_t *)pid - ((Job *)job)->pid;
d309 2
a310 2
static void
debug_printf(const char *fmt, ...)
d314 1
a314 1

d316 1
a316 1
		(void)vfprintf(stdout, fmt, va);
a321 12
static void
close_job_pipes(Job *job)
{
	int i;

	for (i = 1; i >= 0; i--) {
		FD_CLR(job->in[i].fd, output_mask);
		handle_job_output(job, i, true);
		(void)close(job->in[i].fd);
	}
}

d324 2
a325 2
 * process_job_status  --
 *	Do processing for the given job including updating
a328 3
 *	Some nodes may be put on the toBeMade queue.
 *	Final commands for the job are placed on end_node.
 *
d338 1
a338 1
process_job_status(Job *job, int status)
d340 1
a340 78
	int reason, code;
	bool	 done;

	debug_printf("Process %ld (%s) exited with status %d.\n",
	    (long)job->pid, job->node->name, status);
	/* parse status */
	if (WIFEXITED(status)) {
		reason = JOB_EXITED;
		code = WEXITSTATUS(status);
	} else if (WIFSIGNALED(status)) {
		reason = JOB_SIGNALED;
		code = WTERMSIG(status);
	} else {
		/* can't happen, set things to be bad. */
		reason = UNKNOWN;
		code = status;
	}

	if ((reason == JOB_EXITED &&
	     code != 0 && !(job->node->type & OP_IGNORE)) ||
	    reason == JOB_SIGNALED) {
		/*
		 * If it exited non-zero and either we're doing things our
		 * way or we're not ignoring errors, the job is finished.
		 * Similarly, if the shell died because of a signal
		 * the job is also finished. In these
		 * cases, finish out the job's output before printing the exit
		 * status...
		 */
		close_job_pipes(job);
		done = true;
	} else if (reason == JOB_EXITED) {
		/*
		 * Deal with ignored errors. We need to print a message telling
		 * of the ignored error as well as setting status.w_status to 0
		 * so the next command gets run. To do this, we set done to be
		 * true and the job exited non-zero.
		 */
		done = code != 0;
		close_job_pipes(job);
	} else {
		/*
		 * No need to close things down or anything.
		 */
		done = false;
	}

	if (done || DEBUG(JOB)) {
		if (reason == JOB_EXITED) {
			debug_printf("Process %ld (%s) exited.\n",
			    (long)job->pid, job->node->name);
			if (code != 0) {
				banner(job, stdout);
				(void)fprintf(stdout, "*** Error code %d %s\n",
				    code,
				    (job->node->type & OP_IGNORE) ?
				    "(ignored)" : "");

				if (job->node->type & OP_IGNORE) {
					reason = JOB_EXITED;
					code = 0;
				}
			} else if (DEBUG(JOB)) {
				(void)fprintf(stdout,
				    "*** %ld (%s) Completed successfully\n",
				    (long)job->pid, job->node->name);
			}
		} else {
			banner(job, stdout);
			(void)fprintf(stdout, "*** Signal %d\n", code);
		}

		(void)fflush(stdout);
	}

	done = true;

	if (done &&
d342 1
a342 2
	    aborting != ABORT_INTERRUPT &&
	    reason == JOB_EXITED && code == 0) {
d348 1
a348 2
	} else if (!(reason == JOB_EXITED && code == 0)) {
		register_error(reason, code, job);
a349 1
	free(job);
d351 1
a351 1
	if (errors && !keepgoing &&
d355 2
d358 1
a358 1
		Finish(errors);
d361 30
a390 27
static void
prepare_pipe(struct job_pipe *p, int *fd)
{
	p->pos = 0;
	(void)fcntl(fd[0], F_SETFD, FD_CLOEXEC);
	p->fd = fd[0];
	close(fd[1]);

	if (output_mask == NULL || p->fd > largest_fd) {
		int fdn, ofdn;

		fdn = howmany(p->fd+1, NFDBITS);
		ofdn = howmany(largest_fd+1, NFDBITS);

		if (fdn != ofdn) {
			output_mask = emult_realloc(output_mask, fdn,
			    sizeof(fd_mask));
			memset(((char *)output_mask) + ofdn * sizeof(fd_mask),
			    0, (fdn-ofdn) * sizeof(fd_mask));
			actual_mask = emult_realloc(actual_mask, fdn,
			    sizeof(fd_mask));
			mask_size = fdn * sizeof(fd_mask);
		}
		largest_fd = p->fd;
	}
	fcntl(p->fd, F_SETFL, O_NONBLOCK);
	FD_SET(p->fd, output_mask);
d393 2
a394 12
/*-
 *-----------------------------------------------------------------------
 * JobExec --
 *	Execute the shell for the given job. Called from JobStart
 *
 * Side Effects:
 *	A shell is executed, outputs is altered and the Job structure added
 *	to the job table.
 *-----------------------------------------------------------------------
 */
static void
JobExec(Job *job)
d396 5
a400 87
	pid_t cpid; 	/* ID of new child */
	struct job_pid *p;
	int fds[4];
	int *fdout = fds;
	int *fderr = fds+2;
	int i;

	banner(job, stdout);

	setup_engine(1);

	/* Create the pipe by which we'll get the shell's output.
	 */
	if (pipe(fdout) == -1)
		Punt("Cannot create pipe: %s", strerror(errno));

	if (pipe(fderr) == -1)
		Punt("Cannot create pipe: %s", strerror(errno));

	block_signals();
	if ((cpid = fork()) == -1) {
		Punt("Cannot fork");
		unblock_signals();
	} else if (cpid == 0) {
		supervise_jobs = false;
		/* standard pipe code to route stdout and stderr */
		close(fdout[0]);
		if (dup2(fdout[1], 1) == -1)
			Punt("Cannot dup2(outPipe): %s", strerror(errno));
		if (fdout[1] != 1)
			close(fdout[1]);
		close(fderr[0]);
		if (dup2(fderr[1], 2) == -1)
			Punt("Cannot dup2(errPipe): %s", strerror(errno));
		if (fderr[1] != 2)
			close(fderr[1]);

		/*
		 * We want to switch the child into a different process family
		 * so we can kill it and all its descendants in one fell swoop,
		 * by killing its process family, but not commit suicide.
		 */
		(void)setpgid(0, getpid());

		if (random_delay)
			if (!(nJobs == 1 && no_jobs_left()))
				usleep(random() % random_delay);

		setup_all_signals(SigHandler, SIG_DFL);
		unblock_signals();
		/* this exits directly */
		run_gnode_parallel(job->node);
		/*NOTREACHED*/
	} else {
		supervise_jobs = true;
		job->pid = cpid;

		/* we set the current position in the buffers to the beginning
		 * and mark another stream to watch in the outputs mask
		 */
		for (i = 0; i < 2; i++)
			prepare_pipe(&job->in[i], fds+2*i);
	}
	/*
	 * Now the job is actually running, add it to the table.
	 */
	nJobs++;
	Lst_AtEnd(&runningJobs, job);
	if (job->flags & JOB_IS_EXPENSIVE)
		expensive_job = true;
	p = emalloc(sizeof(struct job_pid));
	p->pid = cpid;
	Lst_AtEnd(&job_pids, p);
	job->p = Lst_Last(&job_pids);

	unblock_signals();
	if (DEBUG(JOB)) {
		LstNode ln;

		(void)fprintf(stdout, "Running %ld (%s)\n", (long)cpid,
		    job->node->name);
		for (ln = Lst_First(&job->node->commands); ln != NULL ;
		    ln = Lst_Adv(ln))
		    	fprintf(stdout, "\t%s\n", (char *)Lst_Datum(ln));
		(void)fflush(stdout);
	}

d413 3
d441 1
a441 1
			if (p[1] == '.') {
a452 10
static bool
expensive_commands(Lst l)
{
	LstNode ln;
	for (ln = Lst_First(l); ln != NULL; ln = Lst_Adv(ln))
		if (expensive_command(Lst_Datum(ln)))
			return true;
	return false;
}

d454 1
a454 1
prepare_job(GNode *gn, int flags)
d456 5
a460 6
	bool cmdsOK;     	/* true if the nodes commands were all right */
	bool noExec;     	/* Set true if we decide not to run the job */

	/*
	 * Check the commands now so any attributes from .DEFAULT have a chance
	 * to migrate to the node
d462 6
a467 12
	cmdsOK = Job_CheckCommands(gn);
	expand_commands(gn);
	if (fatal_errors)
		Punt("can't continue");

	if ((gn->type & OP_MAKE) || (!noExecute && !touchFlag)) {
		/*
		 * We're serious here, but if the commands were bogus, we're
		 * also dead...
		 */
		if (!cmdsOK)
			job_failure(gn, Punt);
d469 3
a471 4
		if (Lst_IsEmpty(&gn->commands))
			noExec = true;
		else
			noExec = false;
d473 3
a475 5
	} else if (noExecute) {
		if (!cmdsOK || Lst_IsEmpty(&gn->commands))
			noExec = true;
		else
			noExec = false;
d477 2
a478 8
		/*
		 * Just touch the target and note that no shell should be
		 * executed.  Check
		 * the commands, too, but don't die if they're no good -- it
		 * does no harm to keep working up the graph.
		 */
		Job_Touch(gn);
		noExec = true;
d480 1
d482 12
a493 27
	/*
	 * If we're not supposed to execute a shell, don't.
	 */
	if (noExec) {
		/*
		 * We only want to work our way up the graph if we aren't here
		 * because the commands for the job were no good.
		 */
		if (cmdsOK && !aborting) {
			gn->built_status = MADE;
			Make_Update(gn);
		}
		return NULL;
	} else {
		Job *job;       	/* new job descriptor */
		job = emalloc(sizeof(Job));
		if (job == NULL)
			Punt("JobStart out of memory");

		job->node = gn;

		/*
		 * Set the initial value of the flags for this job based on the
		 * global ones and the node's attributes... Any flags supplied
		 * by the caller are also added to the field.
		 */
		job->flags = flags;
d495 8
a502 8
		if (gn->type & OP_CHEAP)
			return job;
		if ((gn->type & OP_EXPENSIVE) || 
		    expensive_commands(&gn->expanded))
			job->flags |= JOB_IS_EXPENSIVE;

		return job;
	}
d507 1
a507 1
 * JobStart  --
d512 2
a513 2
 *	A new Job node is created and added to the list of running
 *	jobs. Make is forked and a child shell created.
d516 2
a517 4
static void
JobStart(GNode *gn,	      	/* target to create */
    int flags)      		/* flags for the job to override normal ones.
			       	 * e.g. JOB_IS_SPECIAL */
d520 3
a522 1
	job = prepare_job(gn, flags);
d525 2
a526 1
	JobExec(job);
a528 4
/* Helper functions for JobDoOutput */


/* output debugging banner and print characters from 0 to endpos */
d530 1
a530 1
print_partial_buffer(struct job_pipe *p, Job *job, FILE *out, size_t endPos)
d532 9
a540 1
	size_t i;
d542 5
a546 4
	banner(job, out);
	job->flags |= JOB_DIDOUTPUT;
	for (i = 0; i < endPos; i++)
		putc(p->buffer[i], out);
a548 1
/* print partial buffer and shift remaining contents */
d550 1
a550 2
print_partial_buffer_and_shift(struct job_pipe *p, Job *job, FILE *out,
    size_t endPos)
d552 12
a563 23
	size_t i;

	print_partial_buffer(p, job, out, endPos);

	for (i = endPos; i < p->pos; i++)
		p->buffer[i-endPos] = p->buffer[i];
	p->pos -= endPos;
}

/* print complete lines, looking back to the limit position
 * (stuff before limit was already scanned).
 * returns true if something was printed.
 */
static bool
print_complete_lines(struct job_pipe *p, Job *job, FILE *out, size_t limit)
{
	size_t i;

	for (i = p->pos; i > limit; i--) {
		if (p->buffer[i-1] == '\n') {
			print_partial_buffer_and_shift(p, job, out, i);
			return true;
		}
a564 1
	return false;
d567 3
a569 7
/*-
 *-----------------------------------------------------------------------
 * handle_pipe	--
 *	This functions is called whenever there is something to read on the
 *	pipe. We collect more output from the given job and store it in the
 *	job's outBuf. If this makes up lines, we print it tagged by the job's
 *	identifier, as necessary.
d571 2
a572 3
 * Side Effects:
 *	curPos may be shifted as may the contents of outBuf.
 *-----------------------------------------------------------------------
d574 2
a575 3
static void
handle_pipe(struct job_pipe *p,
	Job *job, FILE *out, bool finish)
d577 1
a577 2
	int nr;		  	/* number of bytes read */
	int oldpos;		/* optimization */
d579 5
a583 13
	/* want to get everything ? -> we block */
	if (finish)
		fcntl(p->fd, F_SETFL, 0);

	do {
		nr = read(p->fd, &p->buffer[p->pos],
		    JOB_BUFSIZE - p->pos);
		if (nr == -1) {
			if (errno == EAGAIN)
				break;
			if (DEBUG(JOB)) {
				perror("JobDoOutput(piperead)");
			}
a584 8
		oldpos = p->pos;
		p->pos += nr;
		if (!print_complete_lines(p, job, out, oldpos))
			if (p->pos == JOB_BUFSIZE) {
				print_partial_buffer(p, job, out, p->pos);
				p->pos = 0;
			}
	} while (nr != 0);
d586 1
a586 7
	/* at end of file, we print whatever is left */
	if (nr == 0) {
		print_partial_buffer(p, job, out, p->pos);
		if (p->pos > 0 && p->buffer[p->pos - 1] != '\n')
			putchar('\n');
		p->pos = 0;
	}
d589 6
a594 8
static void
handle_job_output(Job *job, int i, bool finish)
{
	handle_pipe(&job->in[i], job, i == 0 ? stdout : stderr, finish);
}

static void
remove_job(LstNode ln, int status)
d596 3
a600 39
	job = (Job *)Lst_Datum(ln);
	Lst_Remove(&runningJobs, ln);
	block_signals();
	free(Lst_Datum(job->p));
	Lst_Remove(&job_pids, job->p);
	unblock_signals();
	nJobs--;
	if (job->flags & JOB_IS_EXPENSIVE)
		expensive_job = false;
	process_job_status(job, status);
}

/*-
 *-----------------------------------------------------------------------
 * Job_CatchChildren --
 *	Handle the exit of a child. Called by handle_running_jobs
 *
 * Side Effects:
 *	The job descriptor is removed from the list of children.
 *
 * Notes:
 *	We do waits, blocking or not, according to the wisdom of our
 *	caller, until there are no more children to report. For each
 *	job, call process_job_status to finish things off.
 *-----------------------------------------------------------------------
 */
void
Job_CatchChildren()
{
	pid_t pid;	/* pid of dead child */
	LstNode jnode;	/* list element for finding job */
	int status;	/* Exit/termination status */

	/*
	 * Don't even bother if we know there's no one around.
	 */
	if (nJobs == 0)
		return;

d602 2
a603 3
		handle_all_signals();

		jnode = Lst_Find(&runningJobs, JobCmpPid, &pid);
d605 2
a606 2
		if (jnode == NULL) {
			Error("Child (%ld) not in table?", (long)pid);
d608 2
a609 1
			remove_job(jnode, status);
d612 4
d619 1
a619 1
handle_all_jobs_output(void)
d621 1
a621 6
	int nfds;
	struct timeval timeout;
	LstNode ln, ln2;
	Job *job;
	int i;
	int status;
d623 1
a623 3
	/* no jobs */
	if (Lst_IsEmpty(&runningJobs))
		return;
d625 16
a640 25
	(void)fflush(stdout);

	memcpy(actual_mask, output_mask, mask_size);
	timeout.tv_sec = SEL_SEC;
	timeout.tv_usec = SEL_USEC;

	nfds = select(largest_fd+1, actual_mask, NULL, NULL, &timeout);
	handle_all_signals();
	for (ln = Lst_First(&runningJobs); nfds && ln != NULL; ln = ln2) {
	    	ln2 = Lst_Adv(ln);
		job = (Job *)Lst_Datum(ln);
		job->flags &= ~JOB_DIDOUTPUT;
		for (i = 1; i >= 0; i--) {
			if (FD_ISSET(job->in[i].fd, actual_mask)) {
				nfds--;
				handle_job_output(job, i, false);
			}
		}
		if (job->flags & JOB_DIDOUTPUT) {
			if (waitpid(job->pid, &status, WNOHANG) == job->pid) {
				remove_job(ln, status);
			} else {
				Lst_Requeue(&runningJobs, ln);
			}
		}
d642 1
d646 1
a646 1
handle_running_jobs()
d648 15
a662 2
	handle_all_jobs_output();
	Job_CatchChildren();
d668 1
a668 1
	while (nJobs)
a670 15
/*-
 *-----------------------------------------------------------------------
 * Job_Make --
 *	Start the creation of a target. Basically a front-end for
 *	JobStart used by the Make module.
 *
 * Side Effects:
 *	Another job is started.
 *-----------------------------------------------------------------------
 */
void
Job_Make(GNode *gn)
{
	(void)JobStart(gn, 0);
}
a671 22

static void
block_signals()
{
	sigprocmask(SIG_BLOCK, &set, &oset);
}

static void
unblock_signals()
{
	sigprocmask(SIG_SETMASK, &oset, NULL);
}

/*-
 *-----------------------------------------------------------------------
 * Job_Init --
 *	Initialize the process module
 *
 * Side Effects:
 *	lists and counters are initialized
 *-----------------------------------------------------------------------
 */
d675 3
a677 2
	Static_Lst_Init(&runningJobs);
	Static_Lst_Init(&errorsList);
d679 2
a681 9
	errors = 0;
	sigemptyset(&set);
	sigaddset(&set, SIGINT);
	sigaddset(&set, SIGHUP);
	sigaddset(&set, SIGQUIT);
	sigaddset(&set, SIGTERM);
	sigaddset(&set, SIGTSTP);
	sigaddset(&set, SIGTTOU);
	sigaddset(&set, SIGTTIN);
d684 1
a684 7

	lastNode = NULL;

	if ((begin_node->type & OP_DUMMY) == 0) {
		JobStart(begin_node, JOB_IS_SPECIAL);
		loop_handle_running_jobs();
	}
a686 16
static bool
Job_Full()
{
	return aborting || (nJobs >= maxJobs);
}
/*-
 *-----------------------------------------------------------------------
 * Job_Full --
 *	See if the job table is full. It is considered full
 *	if we are in the process of aborting OR if we have
 *	reached/exceeded our quota.
 *
 * Results:
 *	true if the job table is full, false otherwise
 *-----------------------------------------------------------------------
 */
d690 1
a690 1
	if (Job_Full() || expensive_job)
a695 9
/*-
 *-----------------------------------------------------------------------
 * Job_Empty --
 *	See if the job table is empty.
 *
 * Results:
 *	true if it is. false if it ain't.
 * -----------------------------------------------------------------------
 */
d699 1
a699 4
	if (nJobs == 0)
		return true;
	else
		return false;
d702 7
d711 1
a711 1
 * JobInterrupt --
d715 1
a715 1
 *	All children are killed. Another job will be started if the
d720 1
a720 3
JobInterrupt(bool runINTERRUPT,	/* true if commands for the .INTERRUPT
				 * target should be executed */
    int signo)			/* signal received */
d722 1
a722 2
	LstNode ln;		/* element in job table */
	Job *job; 		/* job descriptor in that element */
d724 1
a724 1
	aborting = ABORT_INTERRUPT;
a725 2
	for (ln = Lst_First(&runningJobs); ln != NULL; ln = Lst_Adv(ln)) {
		job = (Job *)Lst_Datum(ln);
d727 1
d729 3
a731 3
			const char *file = job->node->path == NULL ?
			    job->node->name : job->node->path;
			if (!noExecute && eunlink(file) != -1) {
a732 6
			}
		}
		if (job->pid) {
			debug_printf("JobInterrupt passing signal to "
			    "child %ld.\n", (long)job->pid);
			killpg(job->pid, signo);
d734 4
d740 1
a740 1
	if (runINTERRUPT && !touchFlag) {
d744 1
a744 2
			JobStart(interrupt_node, 0);
			loop_handle_running_jobs();
d747 9
a755 1
	exit(signo);
d764 1
a764 3
 * Results:
 *	Number of errors reported.
 *
d767 1
a767 1
int
d770 2
d776 1
a776 1
			JobStart(end_node, JOB_IS_SPECIAL);
d783 9
d823 1
a823 1
 *	error. Most definitely NOT to be called from JobInterrupt.
d826 1
a826 1
 *	All children are killed, not just the firstborn
a831 1
	LstNode ln;	/* element in job table */
d837 3
a839 12
	if (nJobs) {
		for (ln = Lst_First(&runningJobs); ln != NULL;
		    ln = Lst_Adv(ln)) {
			job = (Job *)Lst_Datum(ln);

			/*
			 * kill the child process with increasingly drastic
			 * signals to make darn sure it's dead.
			 */
			killpg(job->pid, SIGINT);
			killpg(job->pid, SIGKILL);
		}
a847 1

@


1.122
log
@make has had heuristics to avoid parallel make recursion.
Sometimes they mess up, so add .CHEAP/.EXPENSIVE to explicitly tell make
'hey this is not THAT bad' or 'worse than you think'.
agreed by guenther@@, millert@@ (and some tweaks)
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.121 2012/03/22 13:47:12 espie Exp $	*/
d782 2
@


1.121
log
@minor cleanup: error messages include lineno and fileno together, so
recognize that and create a struct Location_ for it.

mostly from Jonathan Calmels, a few nits from me.

okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.120 2010/07/19 19:46:44 espie Exp $	*/
d839 5
a843 1
		if (expensive_commands(&gn->expanded)) {
a844 1
		}
@


1.120
log
@Correct $OpenBSD$ stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.119 2010/07/15 10:37:32 espie Exp $	*/
d268 1
a268 1
	if (p->n->lineno)
d270 1
a270 1
		    type, p->code, p->n->name, p->n->lineno, p->n->fname);
@


1.119
log
@whitespace
@
text
@d1 1
a1 2
/*	$OpenPackages$ */
/*	$OpenBSD$	*/
@


1.118
log
@remove useless comments
@
text
@d137 1
a137 1
	
d168 1
a168 1
				 
d221 1
a221 1
/* handle_job_output(job, n, finish): 
d227 1
a227 1
static void print_partial_buffer_and_shift(struct job_pipe *, Job *, FILE *, 
d272 1
a272 1
	else 
d281 1
a281 1
		if (DEBUG(JOBBANNER)) 
d450 1
a450 1
	
d467 1
a467 1
 *	parents and starting new jobs as available/necessary. 
d487 1
a487 1
	debug_printf("Process %ld (%s) exited with status %d.\n", 
d533 1
a533 1
			debug_printf("Process %ld (%s) exited.\n", 
d539 1
a539 1
				    (job->node->type & OP_IGNORE) ? 
d548 1
a548 1
				    "*** %ld (%s) Completed successfully\n", 
d575 1
a575 1
	if (errors && !keepgoing && 
d583 1
a583 1
static void 
d588 1
a588 1
	p->fd = fd[0]; 
d598 1
a598 1
			output_mask = emult_realloc(output_mask, fdn, 
d600 1
a600 1
			memset(((char *)output_mask) + ofdn * sizeof(fd_mask), 
d602 1
a602 1
			actual_mask = emult_realloc(actual_mask, fdn, 
d615 1
a615 1
 *	Execute the shell for the given job. Called from JobStart 
d636 1
a636 1
	/* Create the pipe by which we'll get the shell's output. 
d706 1
a706 1
		for (ln = Lst_First(&job->node->commands); ln != NULL ; 
d931 1
a931 1
handle_pipe(struct job_pipe *p, 
d1003 1
a1003 1
 *	job, call process_job_status to finish things off. 
d1162 1
a1162 1
 *	reached/exceeded our quota. 
d1173 1
a1173 1
	else 
d1180 1
a1180 1
 *	See if the job table is empty.	
d1315 1
a1315 1
		for (ln = Lst_First(&runningJobs); ln != NULL; 
@


1.117
log
@simplify job handling a great deal: we don't care when jobs get
stopped/continued, as we won't try to start new jobs when other stuff
is stopped.

Redo signal handling so that most stuff can be done directly in the handler.
This requires blocking/unblocking signals while creating new jobs, and creating
a small list that only contains job's pids.

Switch to pgrps for jobs, since that works.

Add a clamping heuristic that avoids starting new jobs while an expensive job
is running (expensive meaning "very likely to be a recursive make run"). This
idea is mostly from Theo, through the implementation is mine.
@
text
@a415 3
	/*
	 * Leave gracefully if SIGQUIT, rather than core dumping.
	 */
d1054 1
a1054 2
	for (ln = Lst_First(&runningJobs); nfds && ln != NULL;
	    ln = ln2) {
@


1.116
log
@move code around a bit, extract code from run_prepared_gnode
into a run_gnode_parallel. That simplifies the control flow of that routine
a bit, to allow for more tweaks in the parallel case.

okay kettenis@@, otto@@
@
text
@d54 1
a54 1
 *	Job_Full		Return true if the job table is filled.
d65 1
a65 1
 *	Job_AbortAll		Abort all currently running jobs. It doesn't
d70 1
a70 1
 *	Job_Wait		Wait for all currently-running jobs to finish.
d142 1
a142 7
#define JOB_SPECIAL	0x004	/* Target is a special one. */
#define JOB_RESTART	0x080	/* Job needs to be completely restarted */
#define JOB_RESUME	0x100	/* Job needs to be resumed b/c it stopped,
				 * for some reason */
#define JOB_CONTINUING	0x200	/* We are in the process of resuming this job.
				 * Used to avoid infinite recursion between
				 * JobFinish and JobRestart */
d144 2
d149 3
d159 2
a160 1
static int	nJobs;		/* The number of children currently running */
a161 2
static bool	jobFull;	/* Flag to tell when the job table is full. It
				 * is set true when nJobs equals maxJobs */
d164 1
a172 2
static LIST	stoppedJobs;	

a175 2
#define JOB_CONTINUED 2
#define JOB_STOPPED 3
d186 4
a190 11
#if defined(USE_PGRP) && defined(SYSV)
# define KILL(pid, sig) 	killpg(-(pid), (sig))
#else
# if defined(USE_PGRP)
#  define KILL(pid, sig)	killpg((pid), (sig))
# else
#  define KILL(pid, sig)	kill((pid), (sig))
# endif
#endif

static void signal_running_jobs(int);
d194 1
a194 2
static void JobFinish(Job *, int);
static void finish_job(Job *, int, int);
a195 1
static void JobRestart(Job *);
d197 1
a197 2
static void JobInterrupt(int, int);
static void JobRestartJobs(void);
a199 1
static void start_queued_job(Job *);
d201 1
a264 6
		case JOB_STOPPED:
			type = "Stopped";
			break;
		case JOB_CONTINUED:
			type = "Continued";
			break;
d287 2
d292 1
a292 1
	if (got_signal)
a293 2
	else
		return;
d295 36
a330 31
	if (got_SIGINT) {
		got_SIGINT=0;
		handle_signal(SIGINT);
	}
	if (got_SIGHUP) {
		got_SIGHUP=0;
		handle_signal(SIGHUP);
	}
	if (got_SIGQUIT) {
		got_SIGQUIT=0;
		handle_signal(SIGQUIT);
	}
	if (got_SIGTERM) {
		got_SIGTERM=0;
		handle_signal(SIGTERM);
	}
	if (got_SIGTSTP) {
		got_SIGTSTP=0;
		handle_signal(SIGTSTP);
	}
	if (got_SIGTTOU) {
		got_SIGTTOU=0;
		handle_signal(SIGTTOU);
	}
	if (got_SIGTTIN) {
		got_SIGTTIN=0;
		handle_signal(SIGTTIN);
	}
	if (got_SIGWINCH) {
		got_SIGWINCH=0;
		handle_signal(SIGWINCH);
d334 3
a336 2
static void
signal_running_jobs(int signo)
d338 1
d340 43
a382 9
	for (ln = Lst_First(&runningJobs); ln != NULL; ln = Lst_Adv(ln)) {
	    	Job *job = Lst_Datum(ln);
		if (DEBUG(JOB)) {
			(void)fprintf(stdout,
			    "signal %d to child %ld.\n",
			    signo, (long)job->pid);
			(void)fflush(stdout);
		}
		KILL(job->pid, signo);
d384 4
d393 1
a393 2
 *	Pass a signal to all local jobs if USE_PGRP is defined,
 *	then die ourselves.
a394 2
 * Side Effects:
 *	We die by the same signal.
d398 1
a398 1
handle_signal(int signo) /* The signal number we've received */
a399 3
	sigset_t nmask, omask;
	struct sigaction act;

a403 1
	signal_running_jobs(signo);
d411 1
a411 1
	if (signo == SIGINT) {
d413 1
a413 1
	} else if (signo == SIGHUP || signo == SIGTERM || signo == SIGQUIT) {
a414 1
	}
d419 1
a419 1
	if (signo == SIGQUIT) {
a420 33
	}

	/*
	 * Send ourselves the signal now we've given the message to everyone
	 * else.  Note we block everything else possible while we're getting
	 * the signal.  This ensures that all our jobs get continued when we
	 * wake up before we take any other signal.
	 */
	sigemptyset(&nmask);
	sigaddset(&nmask, signo);
	sigprocmask(SIG_SETMASK, &nmask, &omask);
	memset(&act, 0, sizeof act);
	act.sa_handler = SIG_DFL;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
	sigaction(signo, &act, NULL);

	if (DEBUG(JOB)) {
		(void)fprintf(stdout,
		    "handle_signal passing signal to self, mask = %x.\n",
		    ~0 & ~(1 << (signo-1)));
		(void)fflush(stdout);
	}
	(void)signal(signo, SIG_DFL);

	(void)KILL(getpid(), signo);

	signal_running_jobs(SIGCONT);

	(void)sigprocmask(SIG_SETMASK, &omask, NULL);
	sigprocmask(SIG_SETMASK, &omask, NULL);
	act.sa_handler = SigHandler;
	sigaction(signo, &act, NULL);
d468 2
a469 2
 * JobFinish  --
 *	Do final processing for the given job including updating
d485 1
a485 1
JobFinish(Job *job, int status)
d488 4
a498 6
	} else if (WIFCONTINUED(status)) {
		reason = JOB_CONTINUED;
		code = 0;
    	} else if (WIFSTOPPED(status)) {
		reason = JOB_STOPPED;
		code = WSTOPSIG(status);
a503 8
	finish_job(job, reason, code);
}


static void
finish_job(Job *job, int reason, int code)
{
	bool	 done;
d507 1
a507 1
	    (reason == JOB_SIGNALED && code != SIGCONT)) {
d520 4
a523 5
		 * Deal with ignored errors in -B mode. We need to print a
		 * message telling of the ignored error as well as setting
		 * status.w_status to 0 so the next command gets run. To do
		 * this, we set done to be true if in -B mode and the job
		 * exited non-zero.
a533 40
	if (reason == JOB_STOPPED) {
		debug_printf("Process %ld stopped.\n", (long)job->pid);
		banner(job, stdout);
		(void)fprintf(stdout, "*** Stopped -- signal %d\n",
		    code);
		job->flags |= JOB_RESUME;
		Lst_AtEnd(&stoppedJobs, job);
		(void)fflush(stdout);
		return;
	}
	if (reason == JOB_SIGNALED && code == SIGCONT) {
		/*
		 * If the beastie has continued, shift the Job from the
		 * stopped list to the running one (or re-stop it if
		 * concurrency is exceeded) and go and get another
		 * child.
		 */
		if (job->flags & (JOB_RESUME|JOB_RESTART)) {
			banner(job, stdout);
			(void)fprintf(stdout, "*** Continued\n");
		}
		if (!(job->flags & JOB_CONTINUING)) {
			debug_printf(
			    "Warning: "
			    "process %ld was not continuing.\n",
			    (long)job->pid);
		}
		job->flags &= ~JOB_CONTINUING;
		Lst_AtEnd(&runningJobs, job);
		nJobs++;
		debug_printf("Process %ld is continuing locally.\n",
		    (long)job->pid);
		if (nJobs == maxJobs) {
			jobFull = true;
			debug_printf("Job queue is full.\n");
		}
		(void)fflush(stdout);
		return;
	}

d536 2
a537 1
			debug_printf("Process %ld exited.\n", (long)job->pid);
a549 1
				banner(job, stdout);
d551 2
a552 1
				    "*** Completed successfully\n");
a572 1
		free(job);
a574 1
		free(job);
d576 1
a577 3
	/*
	 * Set aborting if any error.
	 */
d579 1
a579 6
	    aborting != ABORT_INTERRUPT) {
		/*
		 * If we found any errors in this batch of children and the -k
		 * flag wasn't given, we set the aborting flag so no more jobs
		 * get started.
		 */
a580 1
	}
d582 1
a582 7
	if (aborting != ABORT_ERROR)
		JobRestartJobs();

	if (aborting == ABORT_ERROR && Job_Empty()) {
		/*
		 * If we are aborting and the job table is now empty, we finish.
		 */
a583 1
	}
d618 1
a618 2
 *	Execute the shell for the given job. Called from JobStart and
 *	JobRestart.
d629 1
a634 16
	if (DEBUG(JOB)) {
		LstNode ln;

		(void)fprintf(stdout, "Running %s\n", job->node->name);
		for (ln = Lst_First(&job->node->commands); ln != NULL ; 
		    ln = Lst_Adv(ln))
		    	fprintf(stdout, "\t%s\n", (char *)Lst_Datum(ln));
		(void)fflush(stdout);
	}

	/*
	 * Some jobs produce no output and it's disconcerting to have
	 * no feedback of their running (since they produce no output, the
	 * banner with their name in it never appears). This is an attempt to
	 * provide that feedback, even if nothing follows it.
	 */
d637 1
a637 1
	setup_engine();
d647 1
d650 1
a664 1
#ifdef USE_PGRP
a669 3
# if defined(SYSV)
		(void)setsid();
# else
a670 2
# endif
#endif /* USE_PGRP */
d676 2
a690 1

d696 6
a701 4
	if (nJobs == maxJobs) {
		jobFull = true;
	}
}
d703 1
a703 3
static void
start_queued_job(Job *job)
{
d705 3
a707 1
		(void)fprintf(stdout, "Restarting %s...",
d709 3
d714 1
a714 18
	if (nJobs >= maxJobs && !(job->flags & JOB_SPECIAL)) {
		/*
		 * Can't be exported and not allowed to run locally --
		 * put it back on the hold queue and mark the table
		 * full
		 */
		debug_printf("holding\n");
		Lst_AtFront(&stoppedJobs, job);
		jobFull = true;
		debug_printf("Job queue is full.\n");
		return;
	} else {
		/*
		 * Job may be run locally.
		 */
		debug_printf("running locally\n");
	}
	JobExec(job);
d717 2
a718 11
/*-
 *-----------------------------------------------------------------------
 * JobRestart --
 *	Restart a job that stopped for some reason.
 *
 * Side Effects:
 *	jobFull will be set if the job couldn't be run.
 *-----------------------------------------------------------------------
 */
static void
JobRestart(Job *job)
d720 3
a722 15
	if (job->flags & JOB_RESTART) {
		start_queued_job(job);
	} else {
		/*
		 * The job has stopped and needs to be restarted. Why it
		 * stopped, we don't know...
		 */
		debug_printf("Resuming %s...", job->node->name);
		if ((nJobs < maxJobs || ((job->flags & JOB_SPECIAL) &&
		    maxJobs == 0)) && nJobs != maxJobs) {
			/*
			 * If we haven't reached the concurrency limit already
			 * (or maxJobs is 0), it's ok to resume the job.
			 */
			bool error;
d724 3
a726 1
			error = KILL(job->pid, SIGCONT) != 0;
d728 27
a754 15
			if (!error) {
				/*
				 * Make sure the user knows we've continued the
				 * beast and actually put the thing in the job
				 * table.
				 */
				job->flags |= JOB_CONTINUING;
				finish_job(job, JOB_SIGNALED, SIGCONT);

				job->flags &= ~(JOB_RESUME|JOB_CONTINUING);
				debug_printf("done\n");
			} else {
				Error("couldn't resume %s: %s",
				    job->node->name, strerror(errno));
				finish_job(job, JOB_EXITED, 1);
d756 1
a756 9
		} else {
			/*
			 * Job cannot be restarted. Mark the table as full and
			 * place the job back on the list of stopped jobs.
			 */
			debug_printf("table full\n");
			Lst_AtFront(&stoppedJobs, job);
			jobFull = true;
			debug_printf("Job queue is full.\n");
d758 2
d761 11
d843 3
d865 1
a865 1
			       	 * e.g. JOB_SPECIAL */
d871 1
a871 27
	if (nJobs >= maxJobs && !(job->flags & JOB_SPECIAL) &&
	    maxJobs != 0) {
		/*
		 * The job can only be run locally, but we've hit the limit of
		 * local concurrency, so put the job on hold until some other
		 * job finishes. Note that the special jobs (.BEGIN, .INTERRUPT
		 * and .END) may be run locally even when the local limit has
		 * been reached (e.g. when maxJobs == 0), though they will be
		 * exported if at all possible. In addition, any target marked
		 * with .NOEXPORT will be run locally if maxJobs is 0.
		 */
		jobFull = true;

		debug_printf("Can only run job locally.\n");
		job->flags |= JOB_RESTART;
		Lst_AtEnd(&stoppedJobs, job);
	} else {
		if (nJobs >= maxJobs) {
			/*
			 * If we're running this job locally as a special case
			 * (see above), at least say the table is full.
			 */
			jobFull = true;
			debug_printf("Local job queue is full.\n");
		}
		JobExec(job);
	}
d978 17
d1006 1
a1006 2
 *	job, call JobFinish to finish things off. This will take care of
 *	putting jobs on the stoppedJobs queue.
a1012 1
	Job *job; 	/* job descriptor for dead child */
d1022 1
a1022 1
	while ((pid = waitpid((pid_t) -1, &status, WNOHANG|WUNTRACED)) > 0) {
a1023 1
		debug_printf("Process %ld exited or stopped.\n", (long)pid);
d1028 1
a1028 13
			if (WIFSIGNALED(status) &&
			    (WTERMSIG(status) == SIGCONT)) {
				jnode = Lst_Find(&stoppedJobs, JobCmpPid, &pid);
				if (jnode == NULL) {
					Error("Resumed child (%ld) not in table", (long)pid);
					continue;
				}
				job = (Job *)Lst_Datum(jnode);
				Lst_Remove(&stoppedJobs, jnode);
			} else {
				Error("Child (%ld) not in table?", (long)pid);
				continue;
			}
d1030 1
a1030 6
			job = (Job *)Lst_Datum(jnode);
			Lst_Remove(&runningJobs, jnode);
			nJobs--;
			if (jobFull)
				debug_printf("Job queue is no longer full.\n");
			jobFull = false;
a1031 2

		JobFinish(job, status);
d1069 2
a1070 6
			if (wait4(job->pid, &status, WNOHANG|WUNTRACED, NULL) ==
			    job->pid) {
			    	Lst_Remove(&runningJobs, ln);
			    	nJobs--;
				jobFull = false;
				JobFinish(job, status);
d1107 13
a1132 1
	Static_Lst_Init(&stoppedJobs);
d1134 2
a1135 3
	maxJobs =	  maxproc;
	nJobs =	  	  0;
	jobFull =	  false;
d1137 8
d1146 1
a1146 1
	aborting =	  0;
d1148 1
a1148 1
	lastNode =	  NULL;
d1151 1
a1151 1
		JobStart(begin_node, JOB_SPECIAL);
d1156 5
d1164 1
a1164 1
 *	See if the job table is full. It is considered full if it is OR
d1166 1
a1166 2
 *	reached/exceeded our local quota. This prevents any more jobs
 *	from starting up.
d1173 1
a1173 1
Job_Full(void)
d1175 4
a1178 1
	return aborting || jobFull;
d1184 1
a1184 4
 *	See if the job table is empty.	Because the local concurrency may
 *	be set to 0, it is possible for the job table to become empty,
 *	while the list of stoppedJobs remains non-empty. In such a case,
 *	we want to restart as many jobs as we can.
d1193 3
a1195 13
	if (nJobs == 0) {
		if (!Lst_IsEmpty(&stoppedJobs) && !aborting) {
			/*
			 * The job table is obviously not full if it has no
			 * jobs in it...Try and restart the stopped jobs.
			 */
			jobFull = false;
			JobRestartJobs();
			return false;
		} else {
			return true;
		}
	} else {
a1196 1
	}
d1210 1
a1210 1
JobInterrupt(int runINTERRUPT,	/* Non-zero if commands for the .INTERRUPT
d1232 1
a1232 1
			KILL(job->pid, signo);
d1265 1
a1265 1
			JobStart(end_node, JOB_SPECIAL);
d1327 2
a1328 2
			KILL(job->pid, SIGINT);
			KILL(job->pid, SIGKILL);
d1335 1
a1335 1
	while (waitpid(-1, &foo, WNOHANG) > 0)
a1338 23
/*-
 *-----------------------------------------------------------------------
 * JobRestartJobs --
 *	Tries to restart stopped jobs if there are slots available.
 *	Note that this tries to restart them regardless of pending errors.
 *	It's not good to leave stopped jobs lying around!
 *
 * Side Effects:
 *	Resumes(and possibly migrates) jobs.
 *-----------------------------------------------------------------------
 */
static void
JobRestartJobs(void)
{
	Job *job;

	while (!Job_Full() && 
	    (job = (Job *)Lst_DeQueue(&stoppedJobs)) != NULL) {
		debug_printf("Job queue is not full. "
		    "Restarting a stopped job.\n");
		JobRestart(job);
	}
}
@


1.115
log
@allocate job only when it's needed.
okay otto@@
@
text
@a716 1
	int result;
d780 3
a782 12
		/* most cases won't return, but will exit directly */
		result = run_prepared_gnode(job->node, 1);
		switch(result) {
		case MADE:
			exit(0);
		case ERROR:
			exit(1);
		default:
			fprintf(stderr, 
			    "Could not run gnode, returned %d\n", result);
			exit(1);
		}
d1398 1
a1398 1
	if (end_node != NULL && !Lst_IsEmpty(&end_node->commands)) {
@


1.114
log
@changes to get target equivalence to work better.
- add new file to create lists of equivalent targets (siblings)
- use that for sequential mode to have much better VPATH support
- separate checking commands from reporting error, for later.
- zap DieHorribly accordingly
- renumber existing flags
- signal_running_jobs() is simpler than pass_signal_to_jobs()
- new debug option -dn for name matching.

Similar code to handle parallel make is still missing.

thanks to Mark, Miod, Theo, Otto, Todd for tests and/or comments.
@
text
@a903 1
	Job *job;       	/* new job descriptor */
a906 14
	job = emalloc(sizeof(Job));
	if (job == NULL) {
		Punt("JobStart out of memory");
	}

	job->node = gn;

	/*
	 * Set the initial value of the flags for this job based on the global
	 * ones and the node's attributes... Any flags supplied by the caller
	 * are also added to the field.
	 */
	job->flags = flags;

d951 3
a953 5
		if (cmdsOK) {
			if (aborting == 0) {
				job->node->built_status = MADE;
				Make_Update(job->node);
			}
a954 1
		free(job);
d957 14
@


1.113
log
@bye, bye recalloc. Bad interface for various reasons.
discussed with deraadt@@ and otto@@ and millert@@
@
text
@a173 5
/*
 * When JobStart attempts to run a job but isn't allowed to,
 * the job is placed on the queuedJobs queue to be run
 * when the next job finishes.
 */
a174 1
static LIST	queuedJobs;
d202 1
a202 1
static void pass_signal_to_job(void *, void *);
a349 10
/*-
 *-----------------------------------------------------------------------
 * JobCondPassSig --
 *	Pass a signal to a job if USE_PGRP
 *	is defined.
 *
 * Side Effects:
 *	None, except the job may bite it.
 *-----------------------------------------------------------------------
 */
d351 1
a351 2
pass_signal_to_job(void *jobp,	/* Job to biff */
    void *signop)		/* Signal to send it */
d353 10
a362 7
	Job *job = (Job *)jobp;
	int signo = *(int *)signop;
	if (DEBUG(JOB)) {
		(void)fprintf(stdout,
		    "pass_signal_to_job passing signal %d to child %ld.\n",
		    signo, (long)job->pid);
		(void)fflush(stdout);
a363 1
	KILL(job->pid, signo);
d386 1
a386 1
	Lst_ForEach(&runningJobs, pass_signal_to_job, &signo);
d432 1
a432 2
	signo = SIGCONT;
	Lst_ForEach(&runningJobs, pass_signal_to_job, &signo);
a553 5
		/*
		 * Old comment said: "Note we don't want to close down any of
		 * the streams until we know we're at the end." But we do.
		 * Otherwise when are we going to print the rest of the stuff?
		 */
a587 10
#if 0
			/*
			 * We don't really want to restart a job from
			 * scratch just because it continued,
			 * especially not without killing the
			 * continuing process!	That's why this is
			 * ifdef'ed out.  FD - 9/17/90
			 */
			JobRestart(job);
#endif
d926 1
a926 1
	cmdsOK = Job_CheckCommands(gn, Error);
d934 2
a935 3
		if (!cmdsOK) {
			DieHorribly();
		}
d987 1
a987 1
 *	jobs. PMake is forked and a child shell created.
a1283 1
	Static_Lst_Init(&queuedJobs);
@


1.112
log
@A few changes:
- expand commands earlier, so that we can eventually scan them to take
smarter decisions.
- clean up the select() mask code and rename variables to sensible things.
- quite a few minor renames for readability
- erecalloc
- clean up wait status handling, do not try to rebuild wait status, but
instead parse it early and deal with the parsed code.

tested by lots of people, thanks guys!
@
text
@d716 1
a716 1
			output_mask = erecalloc(output_mask, fdn, 
d718 3
a720 1
			actual_mask = erecalloc(actual_mask, fdn, 
@


1.111
log
@better error reporting/job handling error:
- systematically reorder jobs based on who did output last, so that the
last job to output is *first* to output again.
- better reaction to errors: any job that outputs is checked for termination
directly, and the Error message is printed right afterwards.
- better error messages, giving more useful information in -j mode.
@
text
@a163 3
static fd_set	*outputsp;	/* Set of descriptors of pipes connected to
				 * the output channels of children */
static int	outputsn;
d166 8
d181 8
d192 2
a193 1
	int status;
a197 1

a207 20
/*
 * Grmpf... There is no way to set bits of the wait structure
 * anymore with the stupid W*() macros. I liked the union wait
 * stuff much more. So, we devise our own macros... This is
 * really ugly, use dramamine sparingly. You have been warned.
 */
#define W_SETMASKED(st, val, fun)				\
	{							\
		int sh = (int) ~0;				\
		int mask = fun(sh);				\
								\
		for (sh = 0; ((mask >> sh) & 1) == 0; sh++)	\
			continue;				\
		*(st) = (*(st) & ~mask) | ((val) << sh);	\
	}

#define W_SETTERMSIG(st, val) W_SETMASKED(st, val, WTERMSIG)
#define W_SETEXITSTATUS(st, val) W_SETMASKED(st, val, WEXITSTATUS)


a211 1
static void JobClose(Job *);
d213 1
d223 24
d251 3
a253 3
static void prepare_pipe(struct job_pipe *, int *);
static void handle_job_output(Job *, int, bool);
static void register_error(int, Job *);
a255 1
static void Job_CatchOutput(void);
d258 1
a258 1
register_error(int status, Job *job)
d264 2
a265 1
	p->status = status;
a275 1
	int r;
d279 2
a280 1
		if (WIFEXITED(p->status)) {
d282 2
a283 2
			r = WEXITSTATUS(p->status);
		} else if (WIFSIGNALED(p->status)) {
d285 10
a294 4
			r = WTERMSIG(p->status);
		} else {
			type = "Status";
			r = p->status;
d298 1
a298 1
		    type, r, p->n->name, p->n->lineno, p->n->fname);
d300 1
a300 1
		Error(" %s %d (%s)", type, r, p->n->name);
a486 9
/*-
 *-----------------------------------------------------------------------
 * JobClose --
 *	Called to close both input and output pipes when a job is finished.
 *
 * Side Effects:
 *	The file descriptors associated with the job are closed.
 *-----------------------------------------------------------------------
 */
d488 1
a488 1
JobClose(Job *job)
d492 2
a493 2
	for (i = 0; i < 2; i++) {
		FD_CLR(job->in[i].fd, outputsp);
d516 1
d520 26
d548 3
a550 3
	if ((WIFEXITED(status) &&
	     WEXITSTATUS(status) != 0 && !(job->node->type & OP_IGNORE)) ||
	    (WIFSIGNALED(status) && WTERMSIG(status) != SIGCONT)) {
d559 1
a559 1
		JobClose(job);
d561 1
a561 1
	} else if (WIFEXITED(status)) {
d569 1
a569 1
		done = WEXITSTATUS(status) != 0;
d575 1
a575 1
		JobClose(job);
d583 52
a634 5
	if (done ||
	    WIFSTOPPED(status) ||
	    (WIFSIGNALED(status) && WTERMSIG(status) == SIGCONT) ||
	    DEBUG(JOB)) {
		if (WIFEXITED(status)) {
d636 1
a636 1
			if (WEXITSTATUS(status) != 0) {
d639 1
a639 1
				    WEXITSTATUS(status),
d644 2
a645 1
					status = 0;
a651 47
		} else if (WIFSTOPPED(status)) {
			debug_printf("Process %ld stopped.\n", (long)job->pid);
			banner(job, stdout);
			(void)fprintf(stdout, "*** Stopped -- signal %d\n",
			    WSTOPSIG(status));
			job->flags |= JOB_RESUME;
			Lst_AtEnd(&stoppedJobs, job);
			(void)fflush(stdout);
			return;
		} else if (WTERMSIG(status) == SIGCONT) {
			/*
			 * If the beastie has continued, shift the Job from the
			 * stopped list to the running one (or re-stop it if
			 * concurrency is exceeded) and go and get another
			 * child.
			 */
			if (job->flags & (JOB_RESUME|JOB_RESTART)) {
				banner(job, stdout);
				(void)fprintf(stdout, "*** Continued\n");
			}
			if (!(job->flags & JOB_CONTINUING)) {
				debug_printf(
				    "Warning: "
				    "process %ld was not continuing.\n",
				    (long)job->pid);
#if 0
				/*
				 * We don't really want to restart a job from
				 * scratch just because it continued,
				 * especially not without killing the
				 * continuing process!	That's why this is
				 * ifdef'ed out.  FD - 9/17/90
				 */
				JobRestart(job);
#endif
			}
			job->flags &= ~JOB_CONTINUING;
			Lst_AtEnd(&runningJobs, job);
			nJobs++;
			debug_printf("Process %ld is continuing locally.\n",
			    (long)job->pid);
			if (nJobs == maxJobs) {
				jobFull = true;
				debug_printf("Job queue is full.\n");
			}
			(void)fflush(stdout);
			return;
d654 1
a654 2
			(void)fprintf(stdout, "*** Signal %d\n",
			    WTERMSIG(status));
d665 1
a665 1
	    status == 0) {
d672 2
a673 2
	} else if (status != 0) {
		register_error(status, job);
d709 1
a709 1
	if (outputsp == NULL || p->fd > outputsn) {
a710 1
		fd_set *tmp;
d713 1
a713 1
		ofdn = outputsn ? howmany(outputsn+1, NFDBITS) : 0;
d716 5
a720 4
			tmp = recalloc(outputsp, fdn, sizeof(fd_mask));
			if (tmp == NULL)
				return;
			outputsp = tmp;
d722 1
a722 1
		outputsn = p->fd;
d725 1
a725 1
	FD_SET(p->fd, outputsp);
d811 1
a811 1
		result = run_gnode(job->node, 1);
a897 1
			int status = 0;
d908 1
a908 2
				W_SETTERMSIG(&status, SIGCONT);
				JobFinish(job, status);
d915 1
a915 2
				W_SETEXITSTATUS(&status, 1);
				JobFinish(job, status);
d956 1
d1188 1
a1188 1
	if (nJobs == 0) {
a1189 1
	}
a1223 6
/*-
 *-----------------------------------------------------------------------
 * Job_CatchOutput --
 *	Catch the output from our children.
 * -----------------------------------------------------------------------
 */
d1225 1
a1225 1
Job_CatchOutput(void)
d1234 3
a1236 2
	int count = howmany(outputsn+1, NFDBITS) * sizeof(fd_mask);
	fd_set *readfdsp = malloc(count);
a1238 2
	if (readfdsp == NULL)
		return;
d1240 1
a1240 1
	memcpy(readfdsp, outputsp, count);
d1244 1
a1244 1
	nfds = select(outputsn+1, readfdsp, NULL, NULL, &timeout);
d1252 1
a1252 1
			if (FD_ISSET(job->in[i].fd, readfdsp)) {
a1268 1
	free(readfdsp);
d1274 1
a1274 1
	Job_CatchOutput();
@


1.110
log
@I was sure I had committed this already, grrrr.
Anyways, switch to a growable array for job to do.
Allows us to randomize it.
fix manpage.
do not add delay if just one job to run.
@
text
@a45 13
 *	Job_CatchChildren	Check for and handle the termination of any
 *				children. This must be called reasonably
 *				frequently to keep the whole make going at
 *				a decent clip, since job table entries aren't
 *				removed until their process is caught this way.
 *
 *	Job_CatchOutput 	Print any output our children have produced.
 *				Should also be called fairly frequently to
 *				keep the user informed of what's going on.
 *				If no output is waiting, it will block for
 *				a time given by the SEL_* constants, below,
 *				or until output is ready.
 *
d149 1
d180 1
a180 1
	char *name;
d237 3
d249 2
a250 3
	p->name = job->node->name;
	if (p)
		Lst_AtEnd(&errorsList, p);
d258 2
d264 2
a265 2
			Error("\tExit status %d in target %s", 
			    WEXITSTATUS(p->status), p->name);
d267 2
a268 2
			Error("\tReceived signal %d in target s", 
			    WTERMSIG(p->status), p->name);
d270 2
a271 1
			Error("\tStatus %d in target %s", p->status, p->name);
d273 5
d550 1
a550 1
				(void)fprintf(stdout, "*** Error code %d%s\n",
a635 2
	JobRestartJobs();

d649 3
d1029 1
d1065 1
d1126 1
a1126 1
 *	Handle the exit of a child. Called from Make_Make.
d1189 1
a1189 8
 *	Catch the output from our children, if we're using
 *	pipes do so. Otherwise just block time until we get a
 *	signal (most likely a SIGCHLD) since there's no point in
 *	just spinning when there's nothing to do and the reaping
 *	of a child can wait for a while.
 *
 * Side Effects:
 *	Output is read from pipes if we're piping.
d1197 1
a1197 1
	LstNode ln;
d1200 1
d1215 20
a1234 9
	if (nfds > 0) {
		for (ln = Lst_First(&runningJobs); nfds && ln != NULL;
		    ln = Lst_Adv(ln)) {
			job = (Job *)Lst_Datum(ln);
			for (i = 0; i < 2; i++) {
				if (FD_ISSET(job->in[i].fd, readfdsp)) {
					handle_job_output(job, i, false);
					nfds--;
				}
d1241 13
d1297 1
a1297 4
		while (nJobs) {
			Job_CatchOutput();
			Job_CatchChildren();
		}
d1393 1
a1393 4
			while (nJobs) {
				Job_CatchOutput();
				Job_CatchChildren();
			}
d1418 1
a1418 5

			while (nJobs) {
				Job_CatchOutput();
				Job_CatchChildren();
			}
d1446 1
a1446 4
	while (nJobs != 0) {
		Job_CatchOutput();
		Job_CatchChildren();
	}
d1507 2
a1508 1
	while (!jobFull && (job = (Job *)Lst_DeQueue(&stoppedJobs)) != NULL) {
@


1.109
log
@debug scaffolding: allows the insertion of a random delay before firing up
jobs in parallel mode.
@
text
@d767 2
a768 1
			usleep(random() % random_delay);
@


1.108
log
@rename make -> must_make, made -> built_status
to make them easier to find in source files.
@
text
@d766 3
@


1.107
log
@get make.c in a more readable state, by extracting code into separate
functions.

Restore a big more debug: if DEBUG(JOB), print commands (unexpanded).
@
text
@d630 1
a630 1
		job->node->made = MADE;
d956 1
a956 1
				job->node->made = MADE;
@


1.106
log
@simplify: Job_CheckCommands deals with silent and ignerr now, so there's
no need to duplicate that info at the job level since we can just use
the gn->type.
@
text
@d710 2
d713 3
@


1.105
log
@token is a confusing name, rename to banner
@
text
@a154 2
#define JOB_IGNERR	0x001	/* Ignore non-zero exits */
#define JOB_SILENT	0x002	/* no output */
d491 1
a491 5
 *	parents and starting new jobs as available/necessary. Note
 *	that we pay no attention to the JOB_IGNERR flag here.
 *	This is because when we're called because of a noexecute flag
 *	or something, jstat.w_status is 0 and when called from
 *	Job_CatchChildren, the status is zeroed if it s/b ignored.
d510 1
a510 1
	     WEXITSTATUS(status) != 0 && !(job->flags & JOB_IGNERR)) ||
d554 2
a555 2
				    (job->flags & JOB_IGNERR) ? "(ignored)" :
				    "");
d557 1
a557 1
				if (job->flags & JOB_IGNERR) {
a903 6
	if (Targ_Ignore(gn)) {
		job->flags |= JOB_IGNERR;
	}
	if (Targ_Silent(gn)) {
		job->flags |= JOB_SILENT;
	}
d937 1
a937 1
		Job_Touch(gn, job->flags & JOB_SILENT);
@


1.104
log
@fix an obnoxious bug: in parallel mode, dieing in the job controller is not
the same as dieing in a sub job, since waiting on sub-jobs won't work.
So keep track of who we are via a state variable.
@
text
@d243 1
a243 1
static void token(Job *, FILE *);
d286 1
a286 1
token(Job *job, FILE *out)
d289 1
a289 1
		if (DEBUG(JOBTOKEN)) 
d557 1
a557 1
				token(job, stdout);
d567 1
a567 1
				token(job, stdout);
d573 1
a573 1
			token(job, stdout);
d588 1
a588 1
				token(job, stdout);
d619 1
a619 1
			token(job, stdout);
d726 1
a726 1
	token(job, stdout);
d1026 1
a1026 1
/* output debugging token and print characters from 0 to endpos */
d1032 1
a1032 1
	token(job, out);
@


1.103
log
@zap confusing old comment
@
text
@d741 1
a741 1

d780 1
@


1.102
log
@mark nodes as made when there is no command around the target.
real files get updated anyways, but phony nodes stay around as unmade,
which breaks things in subtle ways, since parallel mode just assumes things
get built.
@
text
@a921 6
	/*
	 * If the -n flag wasn't given, we open up OUR (not the child's)
	 * temporary file to stuff commands in it. The thing is rd/wr so we
	 * don't need to reopen it to feed it to the shell. If the -n flag
	 * *was* given, we just set the file to be stdout. Cute, huh?
	 */
@


1.101
log
@Work done at p2k7.


This is a really big step towards getting parallel make to work.


Note that this is not yet complete. There are still a few `details' to
fix before this works 100%.  Specifically: sequential make (compat) and
parallel make don't use the same engine, and the parallel engine still
has a few limitations. For instance, some known issues:
- parallel make does not deal with .phony targets correctly all the time.
- some errors are deadly in parallel make mode.
- parallel make NEEDS way more sturdy correspondance of file system paths
and target names, since it often needs to match dependencies to targets
before the corresponding files exist.
- some local variables like $* get set in a bogus way in some cases.
- suffix handling has issues, especially related to the NULL suffix.
So, if you find stuff that does NOT yet work with parallel make, don't go
blindly try to fix the Makefile. It's very likely you might have stumbled
into a make bug. (unless you really, really, understand Makefiles, DON'T
GO CHANGING THEM YET).



Tested by lots of people, thanks go to miod@@, and robert@@ among other people.

Quick summary of what this does:

- remove `saving commands' extension (it's not really usable, nor used)
- move compat job runner and parallel interrupt handling into engine.c
- tweak the code so that both compat and parallel mode use the same job runner
and the same interrupt handling. Remove the other one.
- optimize job runner so that, in parallel mode, the last command does not
fork if we can avoid it (as it's already running in a sub shell).
- scrape all the code that dealt with creating shell scripts from commands.
- scrape all the code that dealt with recognizing special sequences in
command output to print/not print output.
- fix the parallel job pipe to not keep around file descriptors that are not
needed.
- replace the parallel job buffering with a nicer one, that deals with
non-blocking descriptors to try to agregate as much output from one job in
one go (greed) to unconfuse the users.
- create two pipes per job, so that stdout and stderr stay separate.
- make job token printing a debug option.
- always use the parallel job-runner to `execute' commands, even if we just
print them out.
- store list of errors encountered during parallel make running, and print them
on exit, so that we know what went wrong.
- add a dirty hack to targ.c to deal with paths produced by gccmakedep.
@
text
@d968 1
@


1.100
log
@allows node to be run twice, by not destroying the cmdnode contents.
This way, you can run `make .BEGIN'. Okay, this will run .BEGIN twice.
@
text
@d145 6
a153 5
    LstNode	tailCmds;   /* The node of the first command to be
			     * saved when the job has been run */
    FILE	*cmdFILE;   /* When creating the shell script, this is
			     * where the commands go */
    int 	rmtID;	   /* ID returned from Rmt module */
a157 2
#define JOB_IGNDOTS	0x008	/* Ignore "..." lines when processing
				 * commands */
d164 1
a164 8
    int 	inPipe;		/* Input side of pipe associated
				 * with job's output channel */
    int 	outPipe;	/* Output side of pipe associated with
				 * job's output channel */
    char	outBuf[JOB_BUFSIZE + 1];
				/* Buffer for storing the output of the
				 * job, line by line */
    int 	curPos;		/* Current position in op_outBuf */
a167 4
/*
 * error handling variables
 */
static int	errors = 0;	    /* number of errors reported */
a172 15
static int	  numCommands;	    /* The number of commands actually printed
				     * for a target. Should this number be
				     * 0, no shell will be executed. */

#define SHELL_ECHO_OFF	"set -"
#define SHELL_ECHO_ON	"set -v"
#define SHELL_ERROR_ON	"set -e"
#define SHELL_ERROR_OFF	"set +e"
#define SHELL_ECHO_FLAG "v"
#define SHELL_ERROR_FLAG "e"

static const char *shellPath = _PATH_BSHELL;
static const char *shellName = "sh";


a182 8
static char	*targFmt;	/* Format string to use to head output from a
				 * job when it's not the most-recent job heard
				 * from */

# define TARG_FMT  "--- %s ---\n" /* Default format */
# define MESSAGE(fp, gn) \
	(void)fprintf(fp, targFmt, gn->name);

d190 7
a229 1
static void SigHandler(int);
a232 2
static int JobPrintCommand(LstNode, void *);
static void JobSaveCommand(void *, void *);
d234 2
a235 3
static void JobFinish(Job *, int *);
static void JobExec(Job *, char **);
static void JobMakeArgv(Job *, char **);
a237 2
static char *JobOutput(Job *, char *, char *, int);
static void JobDoOutput(Job *, bool);
a239 1
static void DBPRINTF(Job *, const char *, ...);
a240 3
static FILE *new_command_file(void);
static void setup_signal(int);
static void setup_all_signals(void);
d243 8
d252 4
a255 1
static volatile sig_atomic_t got_signal;
d257 7
a263 2
static volatile sig_atomic_t got_SIGINT, got_SIGHUP, got_SIGQUIT,
    got_SIGTERM, got_SIGTSTP, got_SIGTTOU, got_SIGTTIN, got_SIGWINCH;
d265 2
a266 5

#define TMPPAT	"/tmp/makeXXXXXXXXXX"

static FILE *
new_command_file()
d268 2
a269 3
	int fd;
	FILE *f;
	char tmp[] = TMPPAT;
d271 12
a282 8
	fd = mkstemp(tmp);
	if (fd == -1)
		return NULL;
	f = fdopen(fd, "w");
	if (f == NULL)
		close(fd);
	eunlink(tmp);
	return f;
d286 1
a286 1
SigHandler(int sig)
d288 4
a291 35
	switch(sig) {
	case SIGINT:
		got_SIGINT++;
		got_signal = 1;
		break;
	case SIGHUP:
		got_SIGHUP++;
		got_signal = 1;
		break;
	case SIGQUIT:
		got_SIGQUIT++;
		got_signal = 1;
		break;
	case SIGTERM:
		got_SIGTERM++;
		got_signal = 1;
		break;
#ifdef USE_PGRP
	case SIGTSTP:
		got_SIGTSTP++;
		got_signal = 1;
		break;
	case SIGTTOU:
		got_SIGTTOU++;
		got_signal = 1;
		break;
	case SIGTTIN:
		got_SIGTTIN++;
		got_signal = 1;
		break;
	case SIGWINCH:
		got_SIGWINCH++;
		got_signal = 1;
		break;
#endif
a455 13
DBPRINTF(Job *job, const char *fmt, ...)
{
	va_list va;
	va_start(va, fmt);
	if (DEBUG(JOB)) {
		(void)vfprintf(stdout, fmt, va);
		fflush(stdout);
	}
	vfprintf(job->cmdFILE, fmt, va);
	va_end(va);
}

static void
a469 150
 * JobPrintCommand  --
 *	Put out another command for the given job. If the command starts
 *	with an @@ or a - we process it specially. In the former case,
 *	so long as the -s and -n flags weren't given to make, we stick
 *	a shell-specific echoOff command in the script. In the latter,
 *	we ignore errors for the entire job, unless the shell has error
 *	control.
 *	If the command is just "..." we take all future commands for this
 *	job to be commands to be executed once the entire graph has been
 *	made and return non-zero to signal that the end of the commands
 *	was reached. These commands are later attached to the end_node
 *	node and executed by Job_End when all things are done.
 *	This function is called from JobStart via Lst_Find
 *
 * Results:
 *	Always 1, unless the command was "..."
 *
 * Side Effects:
 *	If the command begins with a '-' and the shell has no error control,
 *	the JOB_IGNERR flag is set in the job descriptor.
 *	If the command is "..." and we're not ignoring such things,
 *	tailCmds is set to the successor node of the cmd.
 *	numCommands is incremented if the command is actually printed.
 *-----------------------------------------------------------------------
 */
static int
JobPrintCommand(LstNode cmdNode,	/* command string to print */
    void *jobp)			    	/* job for which to print it */
{
	bool noSpecials;	    	/* true if we shouldn't worry about
					 * inserting special commands into
					 * the input stream. */
	bool shutUp = false;   		/* true if we put a no echo command
					 * into the command file */
	bool errOff = false;   		/* true if we turned error checking
					 * off before printing the command
					 * and need to turn it back on */
	char *cmdTemplate;     		/* Template to use when printing the
					 * command */
	char *cmdStart;	    		/* Start of expanded command */
	char *cmd = (char *)Lst_Datum(cmdNode);
	Job *job = (Job *)jobp;

	noSpecials = (noExecute && !(job->node->type & OP_MAKE));

	if (strcmp(cmd, "...") == 0) {
		job->node->type |= OP_SAVE_CMDS;
		if ((job->flags & JOB_IGNDOTS) == 0) {
			job->tailCmds = Lst_Succ(cmdNode);
			return 0;
		}
		return 1;
	}


	numCommands++;

	/* For debugging, we replace each command with the result of expanding
	 * the variables in the command.  */
	cmdStart = cmd = Var_Subst(cmd, &job->node->context, false);

	cmdTemplate = "%s\n";

	/*
	 * Check for leading @@' and -'s to control echoing and error checking.
	 */
	for (;; cmd++) {
		if (*cmd == '@@')
			shutUp = DEBUG(LOUD) ? false : true;
		else if (*cmd == '-')
			errOff = true;
		else if (*cmd != '+')
			break;
	}

	while (isspace(*cmd))
		cmd++;

	if (shutUp) {
		if (!(job->flags & JOB_SILENT) && !noSpecials) {
			DBPRINTF(job, "%s\n", SHELL_ECHO_OFF);
		} else {
			shutUp = false;
		}
	}

	if (errOff) {
		if ( !(job->flags & JOB_IGNERR) && !noSpecials) {
			/*
			 * we don't want the error-control commands showing
			 * up either, so we turn off echoing while executing
			 * them. We could put another field in the shell
			 * structure to tell JobDoOutput to look for this
			 * string too, but why make it any more complex than
			 * it already is?
			 */
			if (!(job->flags & JOB_SILENT) && !shutUp) {
				DBPRINTF(job, "%s; %s; %s\n", SHELL_ECHO_OFF,
				    SHELL_ERROR_OFF, SHELL_ECHO_ON);
			} else {
				DBPRINTF(job, "%s\n", SHELL_ERROR_OFF);
			}
		} else {
			errOff = false;
		}
	}

	DBPRINTF(job, cmdTemplate, cmd);

	if (errOff) {
		/*
		 * If echoing is already off, there's no point in issuing the
		 * echoOff command. Otherwise we issue it and pretend it was on
		 * for the whole command...
		 */
		if (!shutUp && !(job->flags & JOB_SILENT)) {
			DBPRINTF(job, "%s\n", SHELL_ECHO_OFF);
			shutUp = true;
		}
		DBPRINTF(job, "%s\n", SHELL_ERROR_ON);
	}
	if (shutUp) {
		DBPRINTF(job, "%s\n", SHELL_ECHO_ON);
	}
	return 1;
}

/*-
 *-----------------------------------------------------------------------
 * JobSaveCommand --
 *	Save a command to be executed when everything else is done.
 *	Callback function for JobFinish...
 *
 * Side Effects:
 *	The command is tacked onto the end of end_node's commands list.
 *-----------------------------------------------------------------------
 */
static void
JobSaveCommand(void *cmd, void *gn)
{
	GNode *g = (GNode *)gn;
	char *result;

	result = Var_Subst((char *)cmd, &g->context, false);
	Lst_AtEnd(&end_node->commands, result);
}


/*-
 *-----------------------------------------------------------------------
d480 6
a485 3
	FD_CLR(job->inPipe, outputsp);
	if (job->outPipe != job->inPipe) {
	       (void)close(job->outPipe);
a486 2
	JobDoOutput(job, true);
	(void)close(job->inPipe);
d505 1
a505 1
 *	If we recognized an error (errors !=0), we set the aborting flag
d511 1
a511 2
JobFinish(Job *job,		/* job to finish */
    int *status)		/* sub-why job went away */
d515 3
a517 3
	if ((WIFEXITED(*status) &&
	     WEXITSTATUS(*status) != 0 && !(job->flags & JOB_IGNERR)) ||
	    (WIFSIGNALED(*status) && WTERMSIG(*status) != SIGCONT)) {
a526 3
		if (job->cmdFILE != NULL && job->cmdFILE != stdout) {
		       (void)fclose(job->cmdFILE);
		}
d528 1
a528 1
	} else if (WIFEXITED(*status)) {
d536 1
a536 1
		done = WEXITSTATUS(*status) != 0;
d551 2
a552 2
	    WIFSTOPPED(*status) ||
	    (WIFSIGNALED(*status) && WTERMSIG(*status) == SIGCONT) ||
d554 1
a554 5
		FILE *out;

		out = stdout;

		if (WIFEXITED(*status)) {
d556 4
a559 7
			if (WEXITSTATUS(*status) != 0) {
				if (job->node != lastNode) {
					MESSAGE(out, job->node);
					lastNode = job->node;
				}
				(void)fprintf(out, "*** Error code %d%s\n",
				    WEXITSTATUS(*status),
d564 1
a564 1
					*status = 0;
d567 2
a568 5
				if (job->node != lastNode) {
					MESSAGE(out, job->node);
					lastNode = job->node;
				}
				(void)fprintf(out,
d571 1
a571 1
		} else if (WIFSTOPPED(*status)) {
d573 3
a575 6
			if (job->node != lastNode) {
				MESSAGE(out, job->node);
				lastNode = job->node;
			}
			(void)fprintf(out, "*** Stopped -- signal %d\n",
			    WSTOPSIG(*status));
d578 1
a578 1
			(void)fflush(out);
d580 1
a580 1
		} else if (WTERMSIG(*status) == SIGCONT) {
d588 2
a589 5
				if (job->node != lastNode) {
					MESSAGE(out, job->node);
					lastNode = job->node;
				}
				(void)fprintf(out, "*** Continued\n");
d616 1
a616 1
			(void)fflush(out);
d619 3
a621 6
			if (job->node != lastNode) {
				MESSAGE(out, job->node);
				lastNode = job->node;
			}
			(void)fprintf(out, "*** Signal %d\n",
			    WTERMSIG(*status));
d624 1
a624 1
		(void)fflush(out);
d632 1
a632 1
	    *status == 0) {
d635 1
a635 3
		 * Make_Update to update the parents. In addition, any saved
		 * commands for the node are placed on the .END target.	*/
		Lst_ForEachFrom(job->tailCmds, JobSaveCommand, job->node);
d639 2
a640 2
	} else if (*status != 0) {
		errors++;
d649 2
a650 1
	if (errors && !keepgoing && aborting != ABORT_INTERRUPT) {
d667 27
d706 1
a706 1
JobExec(Job *job, char **argv)
d709 5
a713 1
	static int signals_caught = 0;
a715 2
		int i;

a716 5
		(void)fprintf(stdout, "\tCommand: ");
		for (i = 0; argv[i] != NULL; i++) {
			(void)fprintf(stdout, "%s ", argv[i]);
		}
		(void)fprintf(stdout, "\n");
d726 8
a733 4
	if (lastNode != job->node && !(job->flags & JOB_SILENT)) {
		MESSAGE(stdout, job->node);
		lastNode = job->node;
	}
d735 2
a736 4
	if (!signals_caught) {
		signals_caught = 1;
		setup_all_signals();
	}
d742 11
a752 26
		/*
		 * Must duplicate the input stream down to the child's input
		 * and reset it to the beginning (again). Since the stream was
		 * marked close-on-exec, we must clear that bit in the new
		 * input.
		 */
		if (dup2(fileno(job->cmdFILE), 0) == -1)
			Punt("Cannot dup2(job->cmdFile): %s", strerror(errno));
		(void)fcntl(0, F_SETFD, 0);
		(void)lseek(0, 0, SEEK_SET);

		/*
		 * Set up the child's output to be routed through the pipe
		 * we've created for it.
		 */
		if (dup2(job->outPipe, 1) == -1)
			Punt("Cannot dup2(job->outPipe): %s", strerror(errno));
		/*
		 * The output channels are marked close on exec. This bit was
		 * duplicated by the dup2 (on some systems), so we have to
		 * clear it before routing the shell's error output to the same
		 * place as its standard output.
		 */
		(void)fcntl(1, F_SETFD, 0);
		if (dup2(1, 2) == -1)
			Punt("Cannot dup2(stdout): %s", strerror(errno));
d767 12
a778 5
		(void)execv(shellPath, argv);

		(void)write(STDERR_FILENO, "Could not execute shell\n",
		    sizeof("Could not execute shell"));
		_exit(1);
d782 1
a782 1
		/* we set the current position in the buffer to the beginning
d785 2
a786 26
		job->curPos = 0;

		if (outputsp == NULL || job->inPipe > outputsn) {
			int fdn, ofdn;
			fd_set *tmp;

			fdn = howmany(job->inPipe+1, NFDBITS);
			ofdn = outputsn ? howmany(outputsn+1, NFDBITS) : 0;

			if (fdn != ofdn) {
				tmp = recalloc(outputsp, fdn, sizeof(fd_mask));
				if (tmp == NULL)
					return;
				outputsp = tmp;
			}
			outputsn = job->inPipe;
		}
		FD_SET(job->inPipe, outputsp);

		/*
		 * XXX: Used to not happen if REMOTE. Why?
		 */
		if (job->cmdFILE != NULL && job->cmdFILE != stdout) {
			(void)fclose(job->cmdFILE);
			job->cmdFILE = NULL;
		}
a798 26
/*-
 *-----------------------------------------------------------------------
 * JobMakeArgv --
 *	Create the argv needed to execute the shell for a given job.
 *-----------------------------------------------------------------------
 */
static void
JobMakeArgv(Job *job, char **argv)
{
	int argc;
	static char args[10];	/* For merged arguments */

	argv[0] = (char *)shellName;
	argc = 1;

	(void)snprintf(args, sizeof(args), "-%s%s",
	    (job->flags & JOB_IGNERR) ? "" : SHELL_ERROR_FLAG,
	    (job->flags & JOB_SILENT) ? "" : SHELL_ECHO_FLAG);

	if (args[1]) {
		argv[argc] = args;
		argc++;
	}
	argv[argc] = NULL;
}

a801 13
	/*
	 * Set up the control arguments to the shell. This is based on
	 * the flags set earlier for this job. If the JOB_IGNERR flag
	 * is clear, the 'exit' flag of the commandShell is used to
	 * cause it to exit upon receiving an error. If the JOB_SILENT
	 * flag is clear, the 'echo' flag of the commandShell is used
	 * to get it to start echoing as soon as it starts processing
	 * commands.
	 */
	char *argv[4];

	JobMakeArgv(job, argv);

d824 1
a824 1
	JobExec(job, argv);
d854 1
a854 1
			int status;
d866 1
a866 1
				JobFinish(job, &status);
a872 1
				status = 0;
d874 1
a874 1
				JobFinish(job, &status);
a901 1
	job->tailCmds = NULL;
d937 4
a940 10
		job->cmdFILE = new_command_file();
		if (job->cmdFILE == NULL) {
			Punt("Error creating command file");
		}
		(void)fcntl(fileno(job->cmdFILE), F_SETFD, FD_CLOEXEC);
		/*
		 * Send the commands to the command file, flush all its buffers
		 * then rewind and remove the thing.
		 */
		noExec = false;
d942 2
a943 14
		/*
		 * We can do all the commands at once. hooray for
		 * sanity
		 */
		numCommands = 0;
		Lst_ForEachNodeWhile(&gn->commands, JobPrintCommand,
		    job);

		/*
		 * If we didn't print out any commands to the shell
		 * script, there's not much point in executing the
		 * shell, is there?
		 */
		if (numCommands == 0) {
d945 2
a946 26
		}
	} else if (noExecute) {
		/*
		 * Not executing anything -- just print all the commands to
		 * stdout in one fell swoop. This will still set up
		 * job->tailCmds correctly.
		 */
		if (lastNode != gn) {
			MESSAGE(stdout, gn);
			lastNode = gn;
		}
		job->cmdFILE = stdout;
		/*
		 * Only print the commands if they're ok, but don't die if
		 * they're not -- just let the user know they're bad and keep
		 * going. It doesn't do any harm in this case and may do some
		 * good.
		 */
		if (cmdsOK) {
			Lst_ForEachNodeWhile(&gn->commands, JobPrintCommand,
			    job);
		}
		/*
		 * Don't execute the shell, thank you.
		 */
		noExec = true;
d950 1
a950 1
		 * executed.  Set cmdFILE to stdout to make life easier. Check
a953 1
		job->cmdFILE = stdout;
a962 10
		 * Unlink and close the command file if we opened one
		 */
		if (job->cmdFILE != stdout) {
			if (job->cmdFILE != NULL)
				(void)fclose(job->cmdFILE);
		} else {
			 (void)fflush(stdout);
		}

		/*
a967 2
				Lst_ForEachFrom(job->tailCmds, JobSaveCommand,
				    job->node);
a973 1
		(void)fflush(job->cmdFILE);
a994 2
	char *argv[4];   	/* Argument vector to shell */
	int fd[2];
a997 15
	/* Create the pipe by which we'll get the shell's output. 
	 */
	if (pipe(fd) == -1)
		Punt("Cannot create pipe: %s", strerror(errno));
	job->inPipe = fd[0];
	job->outPipe = fd[1];
	(void)fcntl(job->inPipe, F_SETFD, FD_CLOEXEC);
	(void)fcntl(job->outPipe, F_SETFD, FD_CLOEXEC);

	/*
	 * Set up the control arguments to the shell. This is based on the flags
	 * set earlier for this job.
	 */
	JobMakeArgv(job, argv);

d1023 1
a1023 1
		JobExec(job, argv);
d1027 6
a1032 2
static char *
JobOutput(Job *job, char *cp, char *endp, int msg)
d1034 1
a1034 1
	char *ecp;
d1036 32
a1067 31
	ecp = strstr(cp, SHELL_ECHO_OFF);
	while (ecp != NULL) {
		if (cp != ecp) {
			*ecp = '\0';
			if (msg && job->node != lastNode) {
				MESSAGE(stdout, job->node);
				lastNode = job->node;
			}
			/*
			 * The only way there wouldn't be a newline after
			 * this line is if it were the last in the buffer.
			 * however, since the non-printable comes after it,
			 * there must be a newline, so we don't print one.
			 */
			(void)fprintf(stdout, "%s", cp);
			(void)fflush(stdout);
		}
		cp = ecp + strlen(SHELL_ECHO_OFF);
		if (cp != endp) {
			/*
			 * Still more to print, look again after skipping
			 * the whitespace following the non-printable
			 * command....
			 */
			cp++;
			while (*cp == ' ' || *cp == '\t' || *cp == '\n') {
				cp++;
			}
			ecp = strstr(cp, SHELL_ECHO_OFF);
		} else {
			return cp;
d1070 1
a1070 1
	return cp;
a1071 1

d1074 1
a1074 1
 * JobDoOutput	--
d1077 1
a1077 1
 *	job's outBuf. If this makes up a line, we print it tagged by the job's
a1078 5
 *	We also keep our figurative eye out for the
 *	'noPrint' line for the shell from which the output came. If
 *	we recognize a line, we don't print it. If the command is not
 *	alone on the line (the character after it is not \0 or \n), we
 *	do print whatever follows it.
d1085 2
a1086 3
JobDoOutput(Job *job,   	/* the job whose output needs printing */
    bool finish)	  	/* true if this is the last time we'll be
				 * called for this job */
a1087 2
	bool gotNL = false;  	/* true if got a newline */
	bool fbuf; 	  	/* true if our buffer filled up */
d1089 1
a1089 3
	int i;		  	/* auxiliary index into outBuf */
	int max;	  	/* limit for i (end of current data) */
	int nRead;	  	/* (Temporary) number of bytes read */
d1091 13
a1103 12
	/*
	 * Read as many bytes as will fit in the buffer.
	 */
end_loop:
	gotNL = false;
	fbuf = false;

	nRead = read(job->inPipe, &job->outBuf[job->curPos],
	    JOB_BUFSIZE - job->curPos);
	if (nRead == -1) {
		if (DEBUG(JOB)) {
			perror("JobDoOutput(piperead)");
d1105 8
a1112 4
		nr = 0;
	} else {
		nr = nRead;
	}
d1114 6
a1119 12
	/*
	 * If we hit the end-of-file (the job is dead), we must flush its
	 * remaining output, so pretend we read a newline if there's any
	 * output remaining in the buffer.
	 * Also clear the 'finish' flag so we stop looping.
	 */
	if (nr == 0 && job->curPos != 0) {
		job->outBuf[job->curPos] = '\n';
		nr = 1;
		finish = false;
	} else if (nr == 0) {
		finish = false;
d1121 1
d1123 4
a1126 87
	/*
	 * Look for the last newline in the bytes we just got. If there is
	 * one, break out of the loop with 'i' as its index and gotNL set
	 * true.
	 */
	max = job->curPos + nr;
	for (i = job->curPos + nr - 1; i >= job->curPos; i--) {
		if (job->outBuf[i] == '\n') {
			gotNL = true;
			break;
		} else if (job->outBuf[i] == '\0') {
			/*
			 * To be fixed: don't use printf, it stops at NUL bytes.
			 */
			job->outBuf[i] = ' ';
		}
	}

	if (!gotNL) {
		job->curPos += nr;
		if (job->curPos == JOB_BUFSIZE) {
			/*
			 * If we've run out of buffer space, we have no choice
			 * but to print the stuff. sigh.
			 */
			fbuf = true;
			i = job->curPos;
		}
	}
	if (gotNL || fbuf) {
		/*
		 * Need to send the output to the screen. Null terminate it
		 * first, overwriting the newline character if there was one.
		 * So long as the line isn't one we should filter (according
		 * to the shell description), we print the line, preceded
		 * by a target banner if this target isn't the same as the
		 * one for which we last printed something.
		 * The rest of the data in the buffer are then shifted down
		 * to the start of the buffer and curPos is set accordingly.
		 */
		job->outBuf[i] = '\0';
		if (i >= job->curPos) {
			char *cp;

			cp = JobOutput(job, job->outBuf, &job->outBuf[i],
			    false);

			/*
			 * There's still more in that thar buffer. This time,
			 * though, we know there's no newline at the end, so we
			 * add one of our own free will.
			 */
			if (*cp != '\0') {
				if (job->node != lastNode) {
					MESSAGE(stdout, job->node);
					lastNode = job->node;
				}
				(void)fprintf(stdout, "%s%s", cp,
				    gotNL ? "\n" : "");
				(void)fflush(stdout);
			}
		}
		if (i < max - 1) {
			/* shift the remaining characters down */
			(void)memcpy(job->outBuf, &job->outBuf[i + 1],
			    max - (i + 1));
			job->curPos = max - (i + 1);

		} else {
			/*
			 * We have written everything out, so we just start over
			 * from the start of the buffer. No copying. No nothing.
			 */
			job->curPos = 0;
		}
	}
	if (finish) {
		/*
		 * If the finish flag is true, we must loop until we hit
		 * end-of-file on the pipe. This is guaranteed to happen
		 * eventually since the other end of the pipe is now closed
		 * (we closed it explicitly and the child has exited). When
		 * we do get an EOF, finish will be set false and we'll fall
		 * through and out.
		 */
		goto end_loop;
	}
d1188 1
a1188 1
		JobFinish(job, &status);
d1212 1
d1231 5
a1235 3
			if (FD_ISSET(job->inPipe, readfdsp)) {
				JobDoOutput(job, false);
				nfds--;
a1257 33
static void
setup_signal(int sig)
{
	if (signal(sig, SIG_IGN) != SIG_IGN) {
		(void)signal(sig, SigHandler);
	}
}

static void
setup_all_signals()
{
	/*
	 * Catch the four signals that POSIX specifies if they aren't ignored.
	 * handle_signal will take care of calling JobInterrupt if appropriate.
	 */
	setup_signal(SIGINT);
	setup_signal(SIGHUP);
	setup_signal(SIGQUIT);
	setup_signal(SIGTERM);
	/*
	 * There are additional signals that need to be caught and passed if
	 * either the export system wants to be told directly of signals or if
	 * we're giving each job its own process group (since then it won't get
	 * signals from the terminal driver as we own the terminal)
	 */
#if defined(USE_PGRP)
	setup_signal(SIGTSTP);
	setup_signal(SIGTTOU);
	setup_signal(SIGTTIN);
	setup_signal(SIGWINCH);
#endif
}

d1273 1
d1277 1
a1279 1
	errors =	  0;
a1282 10
	if (maxJobs == 1) {
		/*
		 * If only one job can run at a time, there's no need for a
		 * banner, no is there?
		 */
		targFmt = "";
	} else {
		targFmt = TARG_FMT;
	}

d1383 1
a1383 1
			JobStart(interrupt_node, JOB_IGNDOTS);
d1411 1
a1411 1
			JobStart(end_node, JOB_SPECIAL | JOB_IGNDOTS);
@


1.99
log
@factor out identical code
@
text
@a595 1
	Lst_Replace(cmdNode, cmdStart);
@


1.98
log
@cut up JobStart, prepare the job to be run in a separate function
@
text
@a1311 5
			free(job);
			return NULL;
		} else {
			free(job);
			return NULL;
d1313 2
@


1.97
log
@don't bother returning anything from JobStart, we don't look at it anyways
@
text
@d279 1
d1175 2
a1176 15
/*-
 *-----------------------------------------------------------------------
 * JobStart  --
 *	Start a target-creation process going for the target described
 *	by the graph node gn.
 *
 * Side Effects:
 *	A new Job node is created and added to the list of running
 *	jobs. PMake is forked and a child shell created.
 *-----------------------------------------------------------------------
 */
static void
JobStart(GNode *gn,	      	/* target to create */
    int flags)      		/* flags for the job to override normal ones.
			       	 * e.g. JOB_SPECIAL */
a1178 1
	char *argv[4];   	/* Argument vector to shell */
a1180 1
	int fd[2];
d1313 1
a1313 1
			return;
d1316 1
a1316 1
			return;
d1320 1
d1322 1
d1324 22
@


1.96
log
@minor refactor: introduce function start_queued_job, to make it more apparent
JobStart and JobRestart often do the same thing.
Move JobMakeArgv call around for similar reasons.
Introduce new list (queuedJobs) we don't use yet.
@
text
@a188 8
/*
 * Return values from JobStart.
 */
#define JOB_RUNNING	0	/* Job is running */
#define JOB_ERROR	1	/* Error in starting the job */
#define JOB_FINISHED	2	/* The job is already finished */
#define JOB_STOPPED	3	/* The job is stopped */

d269 1
a269 1
static int JobStart(GNode *, int);
a1179 5
 * Results:
 *	JOB_ERROR if there was an error in the commands, JOB_FINISHED
 *	if there isn't actually anything left to do for the job and
 *	JOB_RUNNING if the job has been started.
 *
d1185 1
a1185 1
static int
d1327 1
a1327 1
			return JOB_FINISHED;
d1330 1
a1330 1
			return JOB_ERROR;
a1377 1
	return JOB_RUNNING;
@


1.95
log
@rename jobs to more descriptive runningJobs (and easier to grep)
@
text
@d228 1
a228 1
 * the job is placed on the stoppedJobs queue to be run
d231 2
a232 3
static LIST	stoppedJobs;	/* Lst of Job structures describing
				 * jobs that were stopped due to concurrency
				 * limits or migration home */
d287 1
d1078 41
d1132 1
a1132 36
		/*
		 * Set up the control arguments to the shell. This is based on
		 * the flags set earlier for this job. If the JOB_IGNERR flag
		 * is clear, the 'exit' flag of the commandShell is used to
		 * cause it to exit upon receiving an error. If the JOB_SILENT
		 * flag is clear, the 'echo' flag of the commandShell is used
		 * to get it to start echoing as soon as it starts processing
		 * commands.
		 */
		char *argv[4];

		JobMakeArgv(job, argv);

		if (DEBUG(JOB)) {
			(void)fprintf(stdout, "Restarting %s...",
			    job->node->name);
			(void)fflush(stdout);
		}
		if (nJobs >= maxJobs && !(job->flags & JOB_SPECIAL)) {
			/*
			 * Can't be exported and not allowed to run locally --
			 * put it back on the hold queue and mark the table
			 * full
			 */
			debug_printf("holding\n");
			Lst_AtFront(&stoppedJobs, job);
			jobFull = true;
			debug_printf("Job queue is full.\n");
			return;
		} else {
			/*
			 * Job may be run locally.
			 */
			debug_printf("running locally\n");
		}
		JobExec(job, argv);
a1348 6
	/*
	 * Set up the control arguments to the shell. This is based on the flags
	 * set earlier for this job.
	 */
	JobMakeArgv(job, argv);

d1358 6
d1758 1
@


1.94
log
@just-in-time signal handling: do not setup the handlers until we need them.
@
text
@d210 1
a210 1
static LIST	jobs;		/* The structures that describe them */
d442 1
a442 1
	Lst_ForEach(&jobs, pass_signal_to_job, &signo);
d489 1
a489 1
	Lst_ForEach(&jobs, pass_signal_to_job, &signo);
d851 1
a851 1
			Lst_AtEnd(&jobs, job);
d1046 1
a1046 1
	Lst_AtEnd(&jobs, job);
d1613 1
a1613 1
		jnode = Lst_Find(&jobs, JobCmpPid, &pid);
d1631 1
a1631 1
			Lst_Remove(&jobs, jnode);
d1677 1
a1677 1
		for (ln = Lst_First(&jobs); nfds && ln != NULL;
d1750 1
a1750 1
	Static_Lst_Init(&jobs);
d1850 1
a1850 1
	for (ln = Lst_First(&jobs); ln != NULL; ln = Lst_Adv(ln)) {
d1960 2
a1961 1
		for (ln = Lst_First(&jobs); ln != NULL; ln = Lst_Adv(ln)) {
@


1.93
log
@rename functions for clarity.
Add a global `got_signals' to quick-path thru handle_all_signals.
remove most of the #ifdef USE_PGRP cruft: always be ready to handle those
signals, just do not define a handler for them yet.
@
text
@d287 1
d424 1
a424 1
 * JobPassSig --
d929 1
d954 5
d1713 25
a1769 21

	/*
	 * Catch the four signals that POSIX specifies if they aren't ignored.
	 * JobPassSig will take care of calling JobInterrupt if appropriate.
	 */
	setup_signal(SIGINT);
	setup_signal(SIGHUP);
	setup_signal(SIGQUIT);
	setup_signal(SIGTERM);
	/*
	 * There are additional signals that need to be caught and passed if
	 * either the export system wants to be told directly of signals or if
	 * we're giving each job its own process group (since then it won't get
	 * signals from the terminal driver as we own the terminal)
	 */
#if defined(USE_PGRP)
	setup_signal(SIGTSTP);
	setup_signal(SIGTTOU);
	setup_signal(SIGTTIN);
	setup_signal(SIGWINCH);
#endif
@


1.92
log
@replace realloc/memset/pointer-arithmetic with recalloc; ok millert@@ ray@@ espie@@
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.91 2007/09/29 09:59:04 espie Exp $	*/
d126 1
a126 4
 *	3) A LstNode for the first command to be saved after the job
 *	   completes. This is NULL if there was no "..." in the job's
 *	   commands.
 *	4) An FILE* for writing out the commands. This is only
d128 1
a128 1
 *	5) Things used for handling the shell's output.
d133 1
a133 3
 *	6) An identifier provided by and for the exclusive use of the
 *	   Rmt module.
 *	7) A word of flags which determine how the module handles errors,
d266 1
a266 1
static void JobCondPassSig(void *, void *);
d268 2
a269 2
static void HandleSigs(void);
static void JobPassSig(int);
d286 3
d291 2
a292 5
    got_SIGTERM;
#if defined(USE_PGRP)
static volatile sig_atomic_t got_SIGTSTP, got_SIGTTOU, got_SIGTTIN,
    got_SIGWINCH;
#endif
d319 1
d323 1
d327 1
d331 1
d333 1
a333 1
#if defined(USE_PGRGP)
d336 1
d340 1
d344 1
d348 1
d355 1
a355 1
HandleSigs()
d357 5
d364 1
a364 1
		JobPassSig(SIGINT);
d368 1
a368 1
		JobPassSig(SIGHUP);
d372 1
a372 1
		JobPassSig(SIGQUIT);
d376 1
a376 1
		JobPassSig(SIGTERM);
a377 1
#if defined(USE_PGRP)
d380 1
a380 1
		JobPassSig(SIGTSTP);
d384 1
a384 1
		JobPassSig(SIGTTOU);
d388 1
a388 1
		JobPassSig(SIGTTIN);
d392 1
a392 1
		JobPassSig(SIGWINCH);
a393 1
#endif
d407 1
a407 1
JobCondPassSig(void *jobp,	/* Job to biff */
d414 1
a414 1
		    "JobCondPassSig passing signal %d to child %ld.\n",
d432 1
a432 1
JobPassSig(int signo) /* The signal number we've received */
d438 1
a438 1
		(void)fprintf(stdout, "JobPassSig(%d) called.\n", signo);
d441 1
a441 1
	Lst_ForEach(&jobs, JobCondPassSig, &signo);
d479 1
a479 1
		    "JobPassSig passing signal to self, mask = %x.\n",
d488 1
a488 1
	Lst_ForEach(&jobs, JobCondPassSig, &signo);
d1603 1
a1603 1
		HandleSigs();
d1668 1
a1668 1
	HandleSigs();
d1698 8
d1743 4
a1746 12
	if (signal(SIGINT, SIG_IGN) != SIG_IGN) {
		(void)signal(SIGINT, SigHandler);
	}
	if (signal(SIGHUP, SIG_IGN) != SIG_IGN) {
		(void)signal(SIGHUP, SigHandler);
	}
	if (signal(SIGQUIT, SIG_IGN) != SIG_IGN) {
		(void)signal(SIGQUIT, SigHandler);
	}
	if (signal(SIGTERM, SIG_IGN) != SIG_IGN) {
		(void)signal(SIGTERM, SigHandler);
	}
d1754 4
a1757 12
	if (signal(SIGTSTP, SIG_IGN) != SIG_IGN) {
		(void)signal(SIGTSTP, SigHandler);
	}
	if (signal(SIGTTOU, SIG_IGN) != SIG_IGN) {
		(void)signal(SIGTTOU, SigHandler);
	}
	if (signal(SIGTTIN, SIG_IGN) != SIG_IGN) {
		(void)signal(SIGTTIN, SigHandler);
	}
	if (signal(SIGWINCH, SIG_IGN) != SIG_IGN) {
		(void)signal(SIGWINCH, SigHandler);
	}
@


1.91
log
@simple refactoring: replace convoluted code with simple equivalent test
structure.
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d1004 2
a1005 2
			int bytes, obytes;
			char *tmp;
d1007 2
a1008 5
			bytes = howmany(job->inPipe+1, NFDBITS) *
			    sizeof(fd_mask);
			obytes = outputsn ?
			    howmany(outputsn+1, NFDBITS) *
			    sizeof(fd_mask) : 0;
d1010 2
a1011 2
			if (bytes != obytes) {
				tmp = realloc(outputsp, bytes);
d1014 1
a1014 2
				memset(tmp + obytes, 0, bytes - obytes);
				outputsp = (fd_set *)tmp;
@


1.90
log
@use constant FD_CLOEXEC, more readable than 1.
zap comment that should have gone with setting use_pipes.
@
text
@d1656 1
d1665 3
a1667 7
	if ((nfds = select(outputsn+1, readfdsp, (fd_set *) 0,
	    (fd_set *) 0, &timeout)) <= 0) {
		HandleSigs();
		free(readfdsp);
		return;
	} else {
		HandleSigs();
@


1.89
log
@remove comment that no longer apply.
Replace a stupid comment with something that makes sense.
(this function needs a rewrite, it's incredibly stupid anyways)
@
text
@d1240 1
a1240 1
		(void)fcntl(fileno(job->cmdFILE), F_SETFD, 1);
d1340 1
a1340 4
	/*
	 * If we're using pipes to catch output, create the pipe by which we'll
	 * get the shell's output. If we're using files, print out that we're
	 * starting a job and then set up its temporary-file name.
d1346 2
a1347 2
	(void)fcntl(job->inPipe, F_SETFD, 1);
	(void)fcntl(job->outPipe, F_SETFD, 1);
@


1.88
log
@don't even attempt to reuse the same temp file name.
Just create a new one each time we need it, and kill the file right away.
@
text
@d1426 5
a1430 12
 *	This function is called at different times depending on
 *	whether the user has specified that output is to be collected
 *	via pipes or temporary files. In the former case, we are called
 *	whenever there is something to read on the pipe. We collect more
 *	output from the given job and store it in the job's outBuf. If
 *	this makes up a line, we print it tagged by the job's identifier,
 *	as necessary.
 *	If output has been collected in a temporary file, we open the
 *	file and read it line by line, transfering it to our own
 *	output channel until the file is empty. At which point we
 *	remove the temporary file.
 *	In both cases, however, we keep our figurative eye out for the
d1496 1
a1496 1
			 * Why?
@


1.87
log
@now, JOB_FIRST is always set, so kill more conditional code.
(taken from NetBSD)
@
text
@a110 2
#define TMPPAT	"/tmp/makeXXXXXXXXXX"

a201 8
/*
 * tfile is the name of a file into which all shell commands are put. It is
 * used over by removing it before the child shell is executed. The XXXXXXXXXX
 * in the string are replaced by mkstemp(3).
 */
static char	tfile[sizeof(TMPPAT)];


d290 1
d299 19
a902 1
		(void)eunlink(tfile);
d1236 1
a1236 1
		job->cmdFILE = fopen(tfile, "w+");
d1238 1
a1238 1
			Punt("Could not open %s", tfile);
a1307 1
			(void)eunlink(tfile);
a1331 1
		(void)eunlink(tfile);
a1720 8
	int tfd;

	(void)strlcpy(tfile, TMPPAT, sizeof(tfile));
	if ((tfd = mkstemp(tfile)) == -1)
		Punt("Cannot create temp file: %s", strerror(errno));
	else
		(void)close(tfd);

a1885 1
	(void)eunlink(tfile);
a1897 3
 * Side Effects:
 *	The process' temporary file (tfile) is removed if it still
 *	existed.
a1914 1
	(void)eunlink(tfile);
a1984 1
	(void)eunlink(tfile);
@


1.86
log
@last parameter to JobStart is always NULL, so nuke it.
@
text
@a165 1
#define JOB_FIRST	0x020	/* Job is first job for the node */
d932 1
a932 2
	if (lastNode != job->node && (job->flags & JOB_FIRST) &&
	    !(job->flags & JOB_SILENT)) {
d989 4
a992 7
		if (job->flags & JOB_FIRST) {
			/*
			 * The first time a job is run for a node, we set the
			 * current position in the buffer to the beginning and
			 * mark another stream to watch in the outputs mask
			 */
			job->curPos = 0;
d994 16
a1009 18
			if (outputsp == NULL || job->inPipe > outputsn) {
				int bytes, obytes;
				char *tmp;

				bytes = howmany(job->inPipe+1, NFDBITS) *
				    sizeof(fd_mask);
				obytes = outputsn ?
				    howmany(outputsn+1, NFDBITS) *
				    sizeof(fd_mask) : 0;

				if (bytes != obytes) {
					tmp = realloc(outputsp, bytes);
					if (tmp == NULL)
						return;
					memset(tmp + obytes, 0, bytes - obytes);
					outputsp = (fd_set *)tmp;
				}
				outputsn = job->inPipe;
d1011 1
a1011 1
			FD_SET(job->inPipe, outputsp);
d1013 1
d1183 1
a1188 1
	flags |= JOB_FIRST;
d1198 1
a1198 1
	job->flags = 0;
a1204 1
	job->flags |= flags;
d1210 1
a1210 5
	if (job->flags & JOB_FIRST) {
		cmdsOK = Job_CheckCommands(gn, Error);
	} else {
		cmdsOK = true;
	}
d1287 1
a1287 1
		Job_Touch(gn, job->flags&JOB_SILENT);
d1338 6
a1343 9
	if (job->flags & JOB_FIRST) {
		int fd[2];
		if (pipe(fd) == -1)
			Punt("Cannot create pipe: %s", strerror(errno));
		job->inPipe = fd[0];
		job->outPipe = fd[1];
		(void)fcntl(job->inPipe, F_SETFD, 1);
		(void)fcntl(job->outPipe, F_SETFD, 1);
	}
@


1.85
log
@compatMake is never true in there, so kill dead code.
@
text
@d294 1
a294 1
static int JobStart(GNode *, int, Job *);
d1182 2
a1183 4
    int flags,      		/* flags for the job to override normal ones.
			       	 * e.g. JOB_SPECIAL or JOB_IGNDOTS */
    Job *previous)  		/* The previous Job structure for this node,
			         * if any. */
d1190 3
a1192 9
	if (previous != NULL) {
		previous->flags &= ~(JOB_FIRST|JOB_IGNERR|JOB_SILENT);
		job = previous;
	} else {
		job = emalloc(sizeof(Job));
		if (job == NULL) {
			Punt("JobStart out of memory");
		}
		flags |= JOB_FIRST;
d1194 1
d1713 1
a1713 1
	(void)JobStart(gn, 0, NULL);
d1795 1
a1795 1
		JobStart(begin_node, JOB_SPECIAL, (Job *)0);
d1894 1
a1894 1
			JobStart(interrupt_node, JOB_IGNDOTS, (Job *)0);
d1926 1
a1926 1
			JobStart(end_node, JOB_SPECIAL | JOB_IGNDOTS, NULL);
@


1.84
log
@replace if (DEBUG(job)) { fprintf(stdout,...); fflush(stdout); }
with a debug_printf() function.
Maybe slightly slower, but it's ways easier to read.
@
text
@d857 1
a857 28
	/*
	 * Now handle the -B-mode stuff. If the beast still isn't finished,
	 * try and restart the job on the next command. If JobStart says it's
	 * ok, it's ok. If there's an error, this puppy is done.
	 */
	if (compatMake && WIFEXITED(*status) && job->node->current != NULL) {
		switch (JobStart(job->node, job->flags & JOB_IGNDOTS, job)) {
		case JOB_RUNNING:
			done = false;
			break;
		case JOB_ERROR:
			done = true;
			W_SETEXITSTATUS(status, 1);
			break;
		case JOB_FINISHED:
			/*
			 * If we got back a JOB_FINISHED code, JobStart has
			 * already called Make_Update and freed the job
			 * descriptor. We set done to false here to avoid fake
			 * cycles and double frees.  JobStart needs to do the
			 * update so we can proceed up the graph when given the
			 * -n flag..
			 */
			done = false;
			break;
		}
	} else
		done = true;
d1224 1
a1224 1
	if (!compatMake && job->flags & JOB_FIRST) {
d1257 2
a1258 2
		 * used to be backwards; replace when start doing multiple
		 * commands per shell.
d1260 3
a1262 44
		if (compatMake) {
			/*
			 * Be compatible: If this is the first time for this
			 * node, verify its commands are ok and open the
			 * commands list for sequential access by later
			 * invocations of JobStart.  Once that is done, we take
			 * the next command off the list and print it to the
			 * command file. If the command was an ellipsis, note
			 * that there's nothing more to execute.
			 */
			if ((job->flags&JOB_FIRST))
				gn->current = Lst_First(&gn->commands);
			else
				gn->current = Lst_Succ(gn->current);

			if (gn->current == NULL ||
			    !JobPrintCommand(gn->current, job)) {
				noExec = true;
				gn->current = NULL;
			}
			if (noExec && !(job->flags & JOB_FIRST)) {
				/*
				 * If we're not going to execute anything, the
				 * job is done and we need to close down the
				 * various file descriptors we've opened for
				 * output, then call JobDoOutput to catch the
				 * final characters or send the file to the
				 * screen... Note that the i/o streams are only
				 * open if this isn't the first job.  Note also
				 * that this could not be done in
				 * Job_CatchChildren b/c it wasn't clear if
				 * there were more commands to execute or
				 * not...
				 */
				JobClose(job);
			}
		} else {
			/*
			 * We can do all the commands at once. hooray for
			 * sanity
			 */
			numCommands = 0;
			Lst_ForEachNodeWhile(&gn->commands, JobPrintCommand,
			    job);
d1264 7
a1270 8
			/*
			 * If we didn't print out any commands to the shell
			 * script, there's not much point in executing the
			 * shell, is there?
			 */
			if (numCommands == 0) {
				noExec = true;
			}
d1356 1
a1356 1
	if (!compatMake || (job->flags & JOB_FIRST)) {
@


1.83
log
@kill local/jobs distinction. Correctly this time...
@
text
@d300 1
d512 13
d770 1
a770 5
			if (DEBUG(JOB)) {
				(void)fprintf(stdout,
				    "Process %ld exited.\n", (long)job->pid);
				(void)fflush(stdout);
			}
d793 1
a793 5
			if (DEBUG(JOB)) {
				(void)fprintf(stdout,
				    "Process %ld stopped.\n", (long)job->pid);
				(void)fflush(stdout);
			}
d819 4
a822 6
				if (DEBUG(JOB)) {
					(void)fprintf(stdout,
					    "Warning: process %ld was not continuing.\n",
					    (long)job->pid);
					(void)fflush(stdout);
				}
d837 2
a838 6
			if (DEBUG(JOB)) {
				(void)fprintf(stdout,
				    "Process %ld is continuing locally.\n",
				    (long)job->pid);
				(void)fflush(stdout);
			}
d841 1
a841 5
				if (DEBUG(JOB)) {
					(void)fprintf(stdout,
					    "Job queue is full.\n");
					(void)fflush(stdout);
				}
d1130 1
a1130 4
			if (DEBUG(JOB)) {
				(void)fprintf(stdout, "holding\n");
				(void)fflush(stdout);
			}
d1133 1
a1133 4
			if (DEBUG(JOB)) {
				(void)fprintf(stdout, "Job queue is full.\n");
				(void)fflush(stdout);
			}
d1139 1
a1139 4
			if (DEBUG(JOB)) {
				(void)fprintf(stdout, "running locally\n");
				(void)fflush(stdout);
			}
d1147 1
a1147 4
		if (DEBUG(JOB)) {
		       (void)fprintf(stdout, "Resuming %s...", job->node->name);
		       (void)fflush(stdout);
		}
d1170 1
a1170 4
				if (DEBUG(JOB)) {
				       (void)fprintf(stdout, "done\n");
				       (void)fflush(stdout);
				}
d1183 1
a1183 4
			if (DEBUG(JOB)) {
				(void)fprintf(stdout, "table full\n");
				(void)fflush(stdout);
			}
d1186 1
a1186 4
			if (DEBUG(JOB)) {
				(void)fprintf(stdout, "Job queue is full.\n");
				(void)fflush(stdout);
			}
d1448 1
a1448 4
		if (DEBUG(JOB)) {
		       (void)fprintf(stdout, "Can only run job locally.\n");
		       (void)fflush(stdout);
		}
d1458 1
a1458 5
			if (DEBUG(JOB)) {
				(void)fprintf(stdout, 
				    "Local job queue is full.\n");
				(void)fflush(stdout);
			}
d1695 1
a1695 6
		if (DEBUG(JOB)) {
			(void)fprintf(stdout,
			    "Process %ld exited or stopped.\n", (long)pid);
			(void)fflush(stdout);
		}

d1717 2
a1718 5
			if (jobFull && DEBUG(JOB)) {
				(void)fprintf(stdout,
				    "Job queue is no longer full.\n");
				(void)fflush(stdout);
			}
d1960 2
a1961 6
			if (DEBUG(JOB)) {
				(void)fprintf(stdout,
				    "JobInterrupt passing signal to child %ld.\n",
				    (long)job->pid);
				(void)fflush(stdout);
			}
d2101 2
a2102 5
		if (DEBUG(JOB)) {
			(void)fprintf(stdout,
			    "Job queue is not full. Restarting a stopped job.\n");
			(void)fflush(stdout);
		}
@


1.82
log
@more specific error messages if dup2 fails
@
text
@d163 1
a163 2
#define JOB_SPECIAL	0x004	/* Target is a special one. i.e. run it locally
				 * if we can't export it and maxLocal is 0 */
d225 1
a225 3
static int	maxLocal;	/* The most local ones we can have */
static int	nJobs = 0;	/* The number of children currently running */
static int	nLocal; 	/* The number of local children */
d228 1
a228 4
				 * is set true when (1) the total number of
				 * running jobs equals the maximum allowed or
				 * (2) a job can only be run locally, but
				 * nLocal equals maxLocal */
a838 1
			nLocal++;
a1060 1
	nLocal += 1;
d1128 1
a1128 1
		if (nLocal >= maxLocal && !(job->flags & JOB_SPECIAL)) {
d1164 2
a1165 2
		if ((nLocal < maxLocal || ((job->flags & JOB_SPECIAL) &&
		    maxLocal == 0)) && nJobs != maxJobs) {
d1168 1
a1168 1
			 * (or maxLocal is 0), it's ok to resume the job.
a1241 1
	bool local;      	/* Set true if the job was run locally */
d1460 2
a1461 4
	local = true;

	if (local && nLocal >= maxLocal && !(job->flags & JOB_SPECIAL) &&
	    maxLocal != 0) {
d1467 1
a1467 1
		 * been reached (e.g. when maxLocal == 0), though they will be
d1469 1
a1469 1
		 * with .NOEXPORT will be run locally if maxLocal is 0.
d1480 1
a1480 1
		if (nLocal >= maxLocal && local) {
d1721 1
a1721 1
	if (nLocal == 0) {
a1759 1
			nLocal--;
d1842 1
a1842 1
Job_Init(int maxproc, int maxlocal)
a1854 1
	maxLocal =	  maxlocal;
a1855 1
	nLocal =	  0;
@


1.81
log
@zap sunos bug work-around
@
text
@d988 1
a988 1
			Punt("Cannot dup2: %s", strerror(errno));
d997 1
a997 1
			Punt("Cannot dup2: %s", strerror(errno));
d1006 1
a1006 1
			Punt("Cannot dup2: %s", strerror(errno));
@


1.80
log
@reindent new part
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.79 2007/09/18 07:45:25 espie Exp $	*/
a193 6
/*
 * XXX: Avoid SunOS bug... FILENO() is fp->_file, and file
 * is a char! So when we go above 127 we turn negative!
 */
#define FILENO(a) ((unsigned) fileno(a))

d987 1
a987 1
		if (dup2(FILENO(job->cmdFILE), 0) == -1)
d1310 1
a1310 1
		(void)fcntl(FILENO(job->cmdFILE), F_SETFD, 1);
@


1.79
log
@revert maxLocal removal, there's something fishy going on.
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.78 2007/09/17 12:42:09 espie Exp $	*/
d1143 16
a1158 15
		    /*
		     * Can't be exported and not allowed to run locally -- put
		     * it back on the hold queue and mark the table full
		     */
		    if (DEBUG(JOB)) {
			(void)fprintf(stdout, "holding\n");
			(void)fflush(stdout);
		    }
		    Lst_AtFront(&stoppedJobs, job);
		    jobFull = true;
		    if (DEBUG(JOB)) {
			(void)fprintf(stdout, "Job queue is full.\n");
			(void)fflush(stdout);
		    }
		    return;
d1160 7
a1166 7
		    /*
		     * Job may be run locally.
		     */
		    if (DEBUG(JOB)) {
			(void)fprintf(stdout, "running locally\n");
			(void)fflush(stdout);
		    }
@


1.78
log
@rewrite of the basic suffix/target parsing: use hash for suffixes.

Store special targets in target hash, and use them for the parsing.

Use OP_DUMMY flag to mark targets that don't really exist yet, such
as interrupt and default nodes.

Also, .PATHxxx is special in suffixes.

Small tweaks to compat.c, so that run_commands does more stuff after
the fork() (and thus no need to free things).

Remove distinction between local and global jobs.
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.74 2007/09/17 10:37:08 espie Exp $	*/
d163 4
a166 4
#define JOB_SPECIAL	0x004	/* Target is a special one. i.e., always run */
				/* it even when the table is full */
#define JOB_IGNDOTS	0x008	/* Ignore "..." lines when processing */
				/* commands */
d169 5
a173 5
#define JOB_RESUME	0x100	/* Job needs to be resumed b/c it stopped, */
				/* for some reason */
#define JOB_CONTINUING	0x200	/* We are in the process of resuming this job */
				/* Used to avoid infinite recursion between */
				/* JobFinish and JobRestart */
d232 1
d234 1
d236 5
a240 1
static bool	jobFull;	/* Flag to tell when the job table is full. */
d851 1
d1074 1
d1142 16
a1157 17
		if (nJobs >= maxJobs && !(job->flags & JOB_SPECIAL)) {
			/*
			 * Can't be exported and not allowed to run locally --
			 * put it back on the hold queue and mark the table
			 * full
			 */
			if (DEBUG(JOB)) {
				(void)fprintf(stdout, "holding\n");
				(void)fflush(stdout);
			}
			Lst_AtFront(&stoppedJobs, job);
			jobFull = true;
			if (DEBUG(JOB)) {
				(void)fprintf(stdout, "Job queue is full.\n");
				(void)fflush(stdout);
			}
			return;
d1159 7
a1165 7
			/*
			 * Job may be run locally.
			 */
			if (DEBUG(JOB)) {
				(void)fprintf(stdout, "running locally\n");
				(void)fflush(stdout);
			}
d1177 2
a1178 1
		if (nJobs != maxJobs || (job->flags & JOB_SPECIAL)) {
d1180 2
a1181 2
			 * If we haven't reached the concurrency limit already,
			 * it's ok to resume the job.
d1476 10
a1485 3
	if (nJobs >= maxJobs && !(job->flags & JOB_SPECIAL)) {
		/* we've hit the limit of concurrency, so put the job on hold
		 * until some other job finishes.
d1495 14
d1737 1
a1737 1
	if (nJobs == 0) {
d1776 1
d1859 1
a1859 1
Job_Init(int maxproc)
d1872 3
@


1.77
log
@remove C99ism
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.76 2007/09/17 12:01:16 espie Exp $	*/
a50 2
 *				Its single argument is true if the function
 *				should block waiting for a child to terminate.
d133 1
a133 1
 *	5) Things used for handling the shell's output. 
d137 1
a137 1
 *	   maintained for each job. 
d163 4
a166 4
#define JOB_SPECIAL	0x004	/* Target is a special one. i.e. run it locally
				 * if we can't export it and maxLocal is 0 */
#define JOB_IGNDOTS	0x008	/* Ignore "..." lines when processing
				 * commands */
d169 5
a173 5
#define JOB_RESUME	0x100	/* Job needs to be resumed b/c it stopped,
				 * for some reason */
#define JOB_CONTINUING	0x200	/* We are in the process of resuming this job.
				 * Used to avoid infinite recursion between
				 * JobFinish and JobRestart */
d184 1
a199 7
/*
 * post-make command processing. The node postCommands is really just the
 * .END target but we keep it around to avoid having to search for it
 * all the time.
 */
static GNode	  *postCommands;    /* node containing commands to execute when
				     * everything else is done */
d230 1
a231 1
static int	maxLocal;	/* The most local ones we can have */
a232 1
static int	nLocal; 	/* The number of local children */
d234 1
a234 5
static bool	jobFull;	/* Flag to tell when the job table is full. It
				 * is set true when (1) the total number of
				 * running jobs equals the maximum allowed or
				 * (2) a job can only be run locally, but
				 * nLocal equals maxLocal */
d529 1
a529 1
 *	was reached. These commands are later attached to the postCommands
d545 2
a546 2
JobPrintCommand(LstNode cmdNode,    /* command string to print */
    void *jobp)			    /* job for which to print it */
d548 11
a558 11
	bool noSpecials;	/* true if we shouldn't worry about
			 	 * inserting special commands into
				 * the input stream. */
	bool shutUp = false;   	/* true if we put a no echo command
				 * into the command file */
	bool errOff = false;   	/* true if we turned error checking
				 * off before printing the command
				 * and need to turn it back on */
	char *cmdTemplate;     	/* Template to use when printing the
				 * command */
	char *cmdStart;	    	/* Start of expanded command */
d573 1
d609 6
a614 7
			 * we don't want the error-control commands
			 * showing up either, so we turn off echoing
			 * while executing them. We could put another
			 * field in the shell structure to tell
			 * JobDoOutput to look for this string too, but
			 * why make it any more complex than it already
			 * is?
d654 1
a654 1
 *	The command is tacked onto the end of postCommands's commands list.
d664 1
a664 1
	Lst_AtEnd(&postCommands->commands, result);
d700 1
a700 1
 *	Final commands for the job are placed on postCommands.
d713 1
a713 1
	bool done;
d763 2
a764 2
				(void)fprintf(stdout, "Process %ld exited.\n",
				    (long)job->pid);
d790 2
a791 2
				(void)fprintf(stdout, "Process %ld stopped.\n",
				    (long)job->pid);
d821 1
a821 1
				"Warning: process %ld was not continuing.\n",
a844 1
			nLocal++;
d953 1
a953 1
		int	  i;
d992 2
a993 2
		 * Set up the child's output to be routed through the
		 * pipe we've created for it.
a1057 1
		nLocal++;
d1099 1
a1099 1
 	}
d1134 1
a1134 1
		if (nLocal >= maxLocal && !(job->flags & JOB_SPECIAL)) {
d1170 1
a1170 4
		if ((nLocal < maxLocal ||
		    ((job->flags & JOB_SPECIAL) &&
		     maxLocal == 0)
		   ) && nJobs != maxJobs) {
d1172 2
a1173 2
			 * If we haven't reached the concurrency limit already
			 * (or maxLocal is 0), it's ok to resume the job.
d1238 11
a1248 11
JobStart(GNode	  *gn,	      /* target to create */
    int 	   flags,      /* flags for the job to override normal ones.
			       * e.g. JOB_SPECIAL or JOB_IGNDOTS */
    Job 	  *previous)  /* The previous Job structure for this node,
			       * if any. */
{
	Job *job;	/* new job descriptor */
	char *argv[4];  /* Argument vector to shell */
	bool cmdsOK;    /* true if the nodes commands were all right */
	bool local;     /* Set true if the job was run locally */
	bool noExec;    /* Set true if we decide not to run the job */
d1468 3
a1470 12
	if (local && nLocal >= maxLocal &&
	    !(job->flags & JOB_SPECIAL) &&
	    maxLocal != 0
	    ) {
		/*
		 * The job can only be run locally, but we've hit the limit of
		 * local concurrency, so put the job on hold until some other
		 * job finishes. Note that the special jobs (.BEGIN, .INTERRUPT
		 * and .END) may be run locally even when the local limit has
		 * been reached (e.g. when maxLocal == 0), though they will be
		 * exported if at all possible. In addition, any target marked
		 * with .NOEXPORT will be run locally if maxLocal is 0.
a1479 14
	} else {
		if (nLocal >= maxLocal && local) {
			/*
			 * If we're running this job locally as a special case
			 * (see above), at least say the table is full.
			 */
			jobFull = true;
			if (DEBUG(JOB)) {
				(void)fprintf(stdout,
				    "Local job queue is full.\n");
				(void)fflush(stdout);
			}
		}
		JobExec(job, argv);
d1498 4
a1501 5
			 * The only way there wouldn't be a newline
			 * after this line is if it were the last in
			 * the buffer.  however, since the
			 * non-printable comes after it, there must be
			 * a newline, so we don't print one.
d1509 3
a1511 3
			 * Still more to print, look again after
			 * skipping the whitespace following the
			 * non-printable command....
d1514 1
a1514 2
			while (*cp == ' ' || *cp == '\t' ||
			    *cp == '\n') {
d1554 1
a1554 1
	bool gotNL = false;	/* true if got a newline */
d1558 2
a1559 2
	int max;		/* limit for i (end of current data) */
	int nRead;	 	/* (Temporary) number of bytes read */
d1580 4
a1583 4
	 * If we hit the end-of-file (the job is dead), we must flush
	 * its remaining output, so pretend we read a newline if
	 * there's any output remaining in the buffer.  Also clear the
	 * 'finish' flag so we stop looping.
d1594 3
a1596 3
	 * Look for the last newline in the bytes we just got. If there
	 * is one, break out of the loop with 'i' as its index and
	 * gotNL set true.
d1615 2
a1616 2
			 * If we've run out of buffer space, we have no
			 * choice but to print the stuff. sigh.
d1624 8
a1631 10
		 * Need to send the output to the screen. Null
		 * terminate it first, overwriting the newline
		 * character if there was one.  So long as the line
		 * isn't one we should filter (according to the shell
		 * description), we print the line, preceded by a
		 * target banner if this target isn't the same as the
		 * one for which we last printed something.  The rest
		 * of the data in the buffer are then shifted down to
		 * the start of the buffer and curPos is set
		 * accordingly.
d1637 2
a1638 2
			cp = JobOutput(job, job->outBuf,
			    &job->outBuf[i], false);
d1641 3
a1643 3
			 * There's still more in that thar buffer. This
			 * time, though, we know there's no newline at
			 * the end, so we add one of our own free will.
d1663 2
a1664 3
			 * We have written everything out, so we just
			 * start over from the start of the buffer. No
			 * copying.  No nothing.
d1671 6
a1676 6
		 * If the finish flag is true, we must loop until we
		 * hit end-of-file on the pipe. This is guaranteed to
		 * happen eventually since the other end of the pipe is
		 * now closed (we closed it explicitly and the child
		 * has exited). When we do get an EOF, finish will be
		 * set false and we'll fall through and out.
d1700 4
a1703 4
	pid_t pid;		/* pid of dead child */
	Job *job; 		/* job descriptor for dead child */
	LstNode jnode;		/* list element for finding job */
	int status;		/* Exit/termination status */
d1708 1
a1708 1
	if (nLocal == 0) {
a1746 1
			nLocal--;
a1775 1

d1829 1
a1829 4
Job_Init(int 	  maxproc,  /* the greatest number of jobs which may be
			     * running at one time */
    int 	  maxlocal) /* the greatest number of local jobs which may
			     * be running at once. */
a1830 1
	GNode *begin;     /* node for commands to do at the very start */
a1841 3
	maxLocal =	  maxlocal;
	nJobs =	  0;
	nLocal =	  0;
d1896 2
a1897 4
	begin = Targ_FindNode(".BEGIN", TARG_NOCREATE);

	if (begin != NULL) {
		JobStart(begin, JOB_SPECIAL, (Job *)0);
a1902 1
	postCommands = Targ_FindNode(".END", TARG_CREATE);
d1971 1
a1971 2
	Job  *job; 		/* job descriptor in that element */
	GNode *interrupt;	/* the node describing the .INTERRUPT target */
d1997 1
a1997 2
		interrupt = Targ_FindNode(".INTERRUPT", TARG_NOCREATE);
		if (interrupt != NULL) {
d2000 1
a2000 1
			JobStart(interrupt, JOB_IGNDOTS, (Job *)0);
d2028 1
a2028 1
	if (postCommands != NULL && !Lst_IsEmpty(&postCommands->commands)) {
d2032 1
a2032 1
			JobStart(postCommands, JOB_SPECIAL | JOB_IGNDOTS, NULL);
a2043 9
/*-
 *-----------------------------------------------------------------------
 * Job_End --
 *	Cleanup any memory used by the jobs module
 *
 * Side Effects:
 *	Memory is freed
 *-----------------------------------------------------------------------
 */
a2047 1
	efree(shellArgv);
@


1.76
log
@make usePipes the default, zap undocumented -P.
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.75 2007/09/17 11:48:13 espie Exp $	*/
a1820 1
	(void)fflush(stdout);
d1823 2
@


1.75
log
@one single printf
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.74 2007/09/17 10:37:08 espie Exp $	*/
d135 2
a136 3
 *	5) A union of things used for handling the shell's output. Different
 *	   parts of the union are used based on the value of the usePipes
 *	   flag. If it is true, the output is being caught via a pipe and
d139 1
a139 3
 *	   maintained for each job. If, on the other hand, usePipes is false,
 *	   the output is routed to a temporary file and all that is kept
 *	   is the name of the file and the descriptor open to the file.
d176 8
a183 24
    union {
	struct {
	    int 	op_inPipe;	/* Input side of pipe associated
					 * with job's output channel */
	    int 	op_outPipe;	/* Output side of pipe associated with
					 * job's output channel */
	    char	op_outBuf[JOB_BUFSIZE + 1];
					/* Buffer for storing the output of the
					 * job, line by line */
	    int 	op_curPos;	/* Current position in op_outBuf */
	}	    o_pipe;	    /* data used when catching the output via
				     * a pipe */
	struct {
	    char	of_outFile[sizeof(TMPPAT)];
					/* Name of file to which shell output
					 * was rerouted */
	    int 	of_outFd;	/* Stream open to the output
					 * file. Used to funnel all
					 * from a single job to one file
					 * while still allowing
					 * multiple shell invocations */
	}	    o_file;	    /* Data used when catching the output in
				     * a temporary file */
    }		output;     /* Data for tracking a shell's output */
a185 7
#define outPipe 	output.o_pipe.op_outPipe
#define inPipe		output.o_pipe.op_inPipe
#define outBuf		output.o_pipe.op_outBuf
#define curPos		output.o_pipe.op_curPos
#define outFile 	output.o_file.of_outFile
#define outFd		output.o_file.of_outFd

d693 3
a695 10
	if (usePipes) {
		FD_CLR(job->inPipe, outputsp);
		if (job->outPipe != job->inPipe) {
		       (void)close(job->outPipe);
		}
		JobDoOutput(job, true);
		(void)close(job->inPipe);
	} else {
		(void)close(job->outFd);
		JobDoOutput(job, true);
d697 2
d772 1
a772 10
		if (compatMake && !usePipes && (job->flags & JOB_IGNERR)) {
			/*
			 * If output is going to a file and this job is ignoring
			 * errors, arrange to have the exit status sent to the
			 * output file as well.
			 */
			out = fdopen(job->outFd, "w");
		} else {
			out = stdout;
		}
d781 1
a781 1
				if (usePipes && job->node != lastNode) {
d794 1
a794 1
				if (usePipes && job->node != lastNode) {
d807 1
a807 1
			if (usePipes && job->node != lastNode) {
d825 1
a825 1
				if (usePipes && job->node != lastNode) {
d870 1
a870 1
			if (usePipes && job->node != lastNode) {
d1005 6
a1010 16
		if (usePipes) {
			/*
			 * Set up the child's output to be routed through the
			 * pipe we've created for it.
			 */
			if (dup2(job->outPipe, 1) == -1)
				Punt("Cannot dup2: %s", strerror(errno));
		} else {
			/*
			 * We're capturing output in a file, so we duplicate the
			 * descriptor to the temporary file into the standard
			 * output.
			 */
			if (dup2(job->outFd, 1) == -1)
				Punt("Cannot dup2: %s", strerror(errno));
		}
d1042 1
a1042 1
		if (usePipes && (job->flags & JOB_FIRST) ) {
d1475 7
a1481 18
		if (usePipes) {
			int fd[2];
			if (pipe(fd) == -1)
				Punt("Cannot create pipe: %s", strerror(errno));
			job->inPipe = fd[0];
			job->outPipe = fd[1];
			(void)fcntl(job->inPipe, F_SETFD, 1);
			(void)fcntl(job->outPipe, F_SETFD, 1);
		} else {
			(void)fprintf(stdout, "Remaking `%s'\n", gn->name);
			(void)fflush(stdout);
			(void)strlcpy(job->outFile, TMPPAT,
			    sizeof(job->outFile));
			if ((job->outFd = mkstemp(job->outFile)) == -1)
				Punt("Cannot create temp file: %s",
				    strerror(errno));
			(void)fcntl(job->outFd, F_SETFD, 1);
		}
d1604 3
a1606 8
	FILE *oFILE;	  	/* Stream pointer to shell's output file */
	char inLine[132];


	if (usePipes) {
		/*
		 * Read as many bytes as will fit in the buffer.
		 */
d1608 2
a1609 2
		gotNL = false;
		fbuf = false;
d1611 5
a1615 9
		nRead = read(job->inPipe, &job->outBuf[job->curPos],
		    JOB_BUFSIZE - job->curPos);
		if (nRead == -1) {
			if (DEBUG(JOB)) {
				perror("JobDoOutput(piperead)");
			}
			nr = 0;
		} else {
			nr = nRead;
d1617 4
d1622 13
a1634 13
		/*
		 * If we hit the end-of-file (the job is dead), we must flush
		 * its remaining output, so pretend we read a newline if
		 * there's any output remaining in the buffer.  Also clear the
		 * 'finish' flag so we stop looping.
		 */
		if (nr == 0 && job->curPos != 0) {
			job->outBuf[job->curPos] = '\n';
			nr = 1;
			finish = false;
		} else if (nr == 0) {
			finish = false;
		}
d1636 15
a1650 16
		/*
		 * Look for the last newline in the bytes we just got. If there
		 * is one, break out of the loop with 'i' as its index and
		 * gotNL set true.
		 */
		max = job->curPos + nr;
		for (i = job->curPos + nr - 1; i >= job->curPos; i--) {
			if (job->outBuf[i] == '\n') {
				gotNL = true;
				break;
			} else if (job->outBuf[i] == '\0') {
				/*
				 * Why?
				 */
				job->outBuf[i] = ' ';
			}
d1652 1
d1654 3
a1656 12
		if (!gotNL) {
			job->curPos += nr;
			if (job->curPos == JOB_BUFSIZE) {
				/*
				 * If we've run out of buffer space, we have no
				 * choice but to print the stuff. sigh.
				 */
				fbuf = true;
				i = job->curPos;
			}
		}
		if (gotNL || fbuf) {
d1658 2
a1659 10
			 * Need to send the output to the screen. Null
			 * terminate it first, overwriting the newline
			 * character if there was one.  So long as the line
			 * isn't one we should filter (according to the shell
			 * description), we print the line, preceded by a
			 * target banner if this target isn't the same as the
			 * one for which we last printed something.  The rest
			 * of the data in the buffer are then shifted down to
			 * the start of the buffer and curPos is set
			 * accordingly.
d1661 20
a1680 3
			job->outBuf[i] = '\0';
			if (i >= job->curPos) {
				char *cp;
d1682 2
a1683 2
				cp = JobOutput(job, job->outBuf,
				    &job->outBuf[i], false);
d1685 9
a1693 13
				/*
				 * There's still more in that thar buffer. This
				 * time, though, we know there's no newline at
				 * the end, so we add one of our own free will.
				 */
				if (*cp != '\0') {
					if (job->node != lastNode) {
						MESSAGE(stdout, job->node);
						lastNode = job->node;
					}
					(void)fprintf(stdout, "%s%s", cp,
					    gotNL ? "\n" : "");
					(void)fflush(stdout);
d1695 3
d1699 6
a1704 5
			if (i < max - 1) {
				/* shift the remaining characters down */
				(void)memcpy(job->outBuf, &job->outBuf[i + 1],
				    max - (i + 1));
				job->curPos = max - (i + 1);
d1706 1
a1706 10
			} else {
				/*
				 * We have written everything out, so we just
				 * start over from the start of the buffer. No
				 * copying.  No nothing.
				 */
				job->curPos = 0;
			}
		}
		if (finish) {
d1708 3
a1710 6
			 * If the finish flag is true, we must loop until we
			 * hit end-of-file on the pipe. This is guaranteed to
			 * happen eventually since the other end of the pipe is
			 * now closed (we closed it explicitly and the child
			 * has exited). When we do get an EOF, finish will be
			 * set false and we'll fall through and out.
d1712 1
a1712 1
			goto end_loop;
d1714 2
a1715 1
	} else {
d1717 8
a1724 40
		 * We've been called to retrieve the output of the job from the
		 * temporary file where it's been squirreled away. This
		 * consists of opening the file, reading the output line by
		 * line, being sure not to print the noPrint line for the shell
		 * we used, then close and remove the temporary file. Very
		 * simple.
		 *
		 * Change to read in blocks and do FindSubString type things as
		 * for pipes? That would allow for "@@echo -n..."
		 */
		oFILE = fopen(job->outFile, "r");
		if (oFILE != NULL) {
			(void)fprintf(stdout, "Results of making %s:\n",
			    job->node->name);
			(void)fflush(stdout);
			while (fgets(inLine, sizeof(inLine), oFILE) != NULL) {
				char *cp, *endp, *oendp;

				cp = inLine;
				oendp = endp = inLine + strlen(inLine);
				if (endp != inLine && endp[-1] == '\n') {
					*--endp = '\0';
				}
				cp = JobOutput(job, inLine, endp, false);

				/*
				 * There's still more in that thar buffer. This
				 * time, though, we know there's no newline at
				 * the end, so we add one of our own free will.
				 */
				(void)fprintf(stdout, "%s", cp);
				(void)fflush(stdout);
				if (endp != oendp) {
					(void)fprintf(stdout, "\n");
					(void)fflush(stdout);
				}
			}
			(void)fclose(oFILE);
			(void)eunlink(job->outFile);
		}
d1744 1
a1744 1
Job_CatchChildren(bool block)	/* true if should block on the wait. */
d1758 1
a1758 2
	while ((pid = waitpid((pid_t) -1, &status,
	    (block?0:WNOHANG)|WUNTRACED)) > 0) {
d1822 8
a1829 5
	if (usePipes) {
		int count = howmany(outputsn+1, NFDBITS) * sizeof(fd_mask);
		fd_set *readfdsp = malloc(count);
		if (readfdsp == NULL)
			return;
d1831 13
a1843 18
		memcpy(readfdsp, outputsp, count);
		timeout.tv_sec = SEL_SEC;
		timeout.tv_usec = SEL_USEC;

		if ((nfds = select(outputsn+1, readfdsp, (fd_set *) 0,
		    (fd_set *) 0, &timeout)) <= 0) {
			HandleSigs();
			free(readfdsp);
			return;
		} else {
			HandleSigs();
			for (ln = Lst_First(&jobs); nfds && ln != NULL;
			    ln = Lst_Adv(ln)) {
				job = (Job *)Lst_Datum(ln);
				if (FD_ISSET(job->inPipe, readfdsp)) {
					JobDoOutput(job, false);
					nfds--;
				}
a1845 1
		free(readfdsp);
d1847 1
d1956 1
a1956 1
			Job_CatchChildren(!usePipes);
d2062 1
a2062 1
				Job_CatchChildren(!usePipes);
d2095 1
a2095 1
				Job_CatchChildren(!usePipes);
d2137 1
a2137 1
		Job_CatchChildren(!usePipes);
@


1.74
log
@byebye shellspecs
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.73 2007/09/17 10:33:28 espie Exp $	*/
d656 2
a657 3
				DBPRINTF(job, "%s\n", SHELL_ECHO_OFF);
				DBPRINTF(job, "%s\n", SHELL_ERROR_OFF);
				DBPRINTF(job, "%s\n", SHELL_ECHO_ON);
@


1.73
log
@we have valid err/echo flags
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.72 2007/09/17 10:31:13 espie Exp $	*/
a211 52

/*-
 * Shell Specifications:
 * Each shell type has associated with it the following information:
 *	1) The string which must match the last character of the shell name
 *	   for the shell to be considered of this type. The longest match
 *	   wins.
 *	2) A command to issue to turn off echoing of command lines
 *	3) A command to issue to turn echoing back on again
 *	4) What the shell prints, and its length, when given the echo-off
 *	   command. This line will not be printed when received from the shell
 *	5) A boolean to tell if the shell has the ability to control
 *	   error checking for individual commands.
 *	6) The string to turn this checking on.
 *	7) The string to turn it off.
 *	8) The command-flag to give to cause the shell to start echoing
 *	   commands right away.
 *	9) The command-flag to cause the shell to Lib_Exit when an error is
 *	   detected in one of the commands.
 *
 * Some special stuff goes on if a shell doesn't have error control. In such
 * a case, errCheck becomes a printf template for echoing the command,
 * should echoing be on and ignErr becomes another printf template for
 * executing the command while ignoring the return status. If either of these
 * strings is empty when hasErrCtl is false, the command will be executed
 * anyway as is and if it causes an error, so be it.
 */
typedef struct Shell_ {
    char	  *name;	/* the name of the shell. For Bourne and C
				 * shells, this is used only to find the
				 * shell description when used as the single
				 * source of a .SHELL target. For user-defined
				 * shells, this is the full path of the shell.
				 */
    bool	  hasEchoCtl;	/* True if both echoOff and echoOn defined */
    char	  *echoOff;	/* command to turn off echo */
    char	  *echoOn;	/* command to turn it back on again */
    char	  *noPrint;	/* command to skip when printing output from
				 * shell. This is usually the command which
				 * was executed to turn off echoing */
    int 	  noPLen;	/* length of noPrint command */
    bool	  hasErrCtl;	/* set if can control error checking for
				 * individual commands */
    char	  *errCheck;	/* string to turn error checking on */
    char	  *ignErr;	/* string to turn off error checking */
    /*
     * command-line flags
     */
    char	  *echo;	/* echo commands */
    char	  *exit;	/* exit on error */
}		Shell;

a253 41
/*
 * Descriptions for various shells.
 */
static Shell	shells[] = {
    /*
     * CSH description. The csh can do echo control by playing
     * with the setting of the 'echo' shell variable. Sadly,
     * however, it is unable to do error control nicely.
     */
{
    "csh",
    true, "unset verbose", "set verbose", "unset verbose", 10,
    false, "echo \"%s\"\n", "csh -c \"%s || exit 0\"",
    "v", "e",
},
    /*
     * SH description. Echo control is also possible and, under
     * sun UNIX anyway, one can even control error checking.
     */
{
    "sh",
    true, "set -", "set -v", "set -", 5,
    true, "set -e", "set +e",
#ifdef OLDBOURNESHELL
    false, "echo \"%s\"\n", "sh -c '%s || exit 0'\n",
#endif
    "v", "e",
},
    /*
     * UNKNOWN.
     */
{
    (char *)0,
    false, (char *)0, (char *)0, (char *)0, 0,
    false, (char *)0, (char *)0,
    (char *)0, (char *)0,
}
};
static Shell	*commandShell = &shells[DEFSHELL];/* this is the shell to
						   * which we pass all
						   * commands in the Makefile*/
d1592 7
a1598 18
	if (commandShell->noPrint) {
		ecp = strstr(cp, commandShell->noPrint);
		while (ecp != NULL) {
			if (cp != ecp) {
				*ecp = '\0';
				if (msg && job->node != lastNode) {
					MESSAGE(stdout, job->node);
					lastNode = job->node;
				}
				/*
				 * The only way there wouldn't be a newline
				 * after this line is if it were the last in
				 * the buffer.  however, since the
				 * non-printable comes after it, there must be
				 * a newline, so we don't print one.
				 */
				(void)fprintf(stdout, "%s", cp);
				(void)fflush(stdout);
d1600 20
a1619 7
			cp = ecp + commandShell->noPLen;
			if (cp != endp) {
				/*
				 * Still more to print, look again after
				 * skipping the whitespace following the
				 * non-printable command....
				 */
a1620 7
				while (*cp == ' ' || *cp == '\t' ||
				    *cp == '\n') {
					cp++;
				}
				ecp = strstr(cp, commandShell->noPrint);
			} else {
				return cp;
d1622 3
a2023 7
	}

	if (commandShell->exit == NULL) {
		commandShell->exit = "";
	}
	if (commandShell->echo == NULL) {
		commandShell->echo = "";
@


1.72
log
@we have echoctl and errctl
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.71 2007/09/17 10:28:48 espie Exp $	*/
d1251 8
a1258 29
	if ((commandShell->exit && *commandShell->exit != '-') ||
	    (commandShell->echo && *commandShell->echo != '-')) {
		/*
		 * At least one of the flags doesn't have a minus before it, so
		 * merge them together. Have to do this because the
		 * *(&(@@*#*&#$# Bourne shell thinks its second argument is a
		 * file to source.  Grrrr. Note the ten-character limitation on
		 * the combined arguments.
		 */
		(void)snprintf(args, sizeof(args), "-%s%s",
		    ((job->flags & JOB_IGNERR) ? "" :
		    (commandShell->exit ? commandShell->exit : "")),
		    ((job->flags & JOB_SILENT) ? "" :
		    (commandShell->echo ? commandShell->echo : "")));

		if (args[1]) {
			argv[argc] = args;
			argc++;
		}
	} else {
		if (!(job->flags & JOB_IGNERR) && commandShell->exit) {
			argv[argc] = commandShell->exit;
			argc++;
		}
		if (!(job->flags & JOB_SILENT) && commandShell->echo) {
			argv[argc] = commandShell->echo;
			argc++;
		}
	}
@


1.71
log
@hardcode some more shell
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.70 2007/09/17 10:22:30 espie Exp $	*/
d730 1
a730 2
		if (!(job->flags & JOB_SILENT) && !noSpecials &&
		    commandShell->hasEchoCtl) {
d739 13
a751 44
			if (commandShell->hasErrCtl) {
				/*
				 * we don't want the error-control commands
				 * showing up either, so we turn off echoing
				 * while executing them. We could put another
				 * field in the shell structure to tell
				 * JobDoOutput to look for this string too, but
				 * why make it any more complex than it already
				 * is?
				 */
				if (!(job->flags & JOB_SILENT) && !shutUp &&
				    commandShell->hasEchoCtl) {
					DBPRINTF(job, "%s\n", SHELL_ECHO_OFF);
					DBPRINTF(job, "%s\n", SHELL_ERROR_OFF);
					DBPRINTF(job, "%s\n", SHELL_ECHO_ON);
				} else {
					DBPRINTF(job, "%s\n", SHELL_ERROR_OFF);
				}
			} else if (commandShell->ignErr &&
			    (*commandShell->ignErr != '\0')) {
				/*
				 * The shell has no error control, so we need
				 * to be weird to get it to ignore any errors
				 * from the command.  If echoing is turned on,
				 * we turn it off and use the errCheck template
				 * to echo the command. Leave echoing off so
				 * the user doesn't see the weirdness we go
				 * through to ignore errors. Set cmdTemplate to
				 * use the weirdness instead of the simple
				 * "%s\n" template.
				 */
				if (!(job->flags & JOB_SILENT) && !shutUp &&
				    commandShell->hasEchoCtl) {
					DBPRINTF(job, "%s\n", SHELL_ECHO_OFF);
					DBPRINTF(job, SHELL_ERROR_ON, cmd);
					shutUp = true;
				}
				cmdTemplate = SHELL_ERROR_OFF;
				/*
				 * The error ignoration (hee hee) is already
				 * taken care of by the ignErr template, so
				 * pretend error checking is still on.
				 */
				errOff = false;
d753 1
a753 1
				errOff = false;
d768 1
a768 2
		if (!shutUp && !(job->flags & JOB_SILENT) &&
		    commandShell->hasEchoCtl){
@


1.70
log
@start hardcoding the shell. we always run with sh anyways.
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.69 2007/09/17 10:17:26 espie Exp $	*/
d732 1
a732 1
			DBPRINTF(job, "%s\n", commandShell->echoOff);
d752 3
a754 3
					DBPRINTF(job, "%s\n", commandShell->echoOff);
					DBPRINTF(job, "%s\n", commandShell->ignErr);
					DBPRINTF(job, "%s\n", commandShell->echoOn);
d756 1
a756 1
					DBPRINTF(job, "%s\n", commandShell->ignErr);
d773 2
a774 2
					DBPRINTF(job, "%s\n", commandShell->echoOff);
					DBPRINTF(job, commandShell->errCheck, cmd);
d777 1
a777 1
				cmdTemplate = commandShell->ignErr;
d802 1
a802 1
			DBPRINTF(job, "%s\n", commandShell->echoOff);
d805 1
a805 1
		DBPRINTF(job, "%s\n", commandShell->errCheck);
d808 1
a808 1
		DBPRINTF(job, "%s\n", commandShell->echoOn);
@


1.69
log
@make DBPRINTF into a real function with variable number of arguments
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.68 2007/09/17 09:28:36 espie Exp $	*/
a111 1
#include "str.h"
d347 6
a352 3
static char	*shellPath = NULL,		  /* full pathname of
						   * executable image */
		*shellName = NULL;		  /* last component of shell */
d354 2
d1281 1
a1281 1
	argv[0] = shellName;
a2172 13
	}

	if (shellPath == NULL) {
		/*
		 * The user didn't specify a shell to use, so we are using the
		 * default one... Both the absolute path and the last component
		 * must be set. The last component is taken from the 'name'
		 * field of the default shell description pointed-to by
		 * commandShell.  All default shells are located in
		 * _PATH_DEFSHELLDIR.
		 */
		shellName = commandShell->name;
		shellPath = Str_concat(_PATH_DEFSHELLDIR, shellName, '/');
@


1.68
log
@kill extra spaces at end of line
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.67 2007/09/17 08:36:57 espie Exp $	*/
d94 1
a94 1
#include <stddef.h>
d350 1
a350 2
		*shellName = NULL,		  /* last component of shell */
		*shellArgv = NULL;		  /* Custom shell args */
d433 1
d632 13
a700 7
#define DBPRINTF(fmt, arg) if (DEBUG(JOB)) {	\
	(void)fprintf(stdout, fmt, arg);	\
	(void)fflush(stdout);			\
    }						\
   (void)fprintf(job->cmdFILE, fmt, arg);	\
   (void)fflush(job->cmdFILE);

d728 1
a728 1
			DBPRINTF("%s\n", commandShell->echoOff);
d748 3
a750 3
					DBPRINTF("%s\n", commandShell->echoOff);
					DBPRINTF("%s\n", commandShell->ignErr);
					DBPRINTF("%s\n", commandShell->echoOn);
d752 1
a752 1
					DBPRINTF("%s\n", commandShell->ignErr);
d769 2
a770 2
					DBPRINTF("%s\n", commandShell->echoOff);
					DBPRINTF(commandShell->errCheck, cmd);
d788 1
a788 1
	DBPRINTF(cmdTemplate, cmd);
d798 1
a798 1
			DBPRINTF("%s\n", commandShell->echoOff);
d801 1
a801 1
		DBPRINTF("%s\n", commandShell->errCheck);
d804 1
a804 1
		DBPRINTF("%s\n", commandShell->echoOn);
@


1.67
log
@kill += 1, -= 1     -> ++, --
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.66 2007/09/16 15:12:12 espie Exp $	*/
d542 1
a542 1
 *	Pass a signal to all local jobs if USE_PGRP is defined, 
d790 1
a790 1
		if (!shutUp && !(job->flags & JOB_SILENT) && 
d933 1
a933 1
				(void)fprintf(stdout, "Process %ld exited.\n", 
d944 1
a944 1
				    (job->flags & JOB_IGNERR) ? "(ignored)" : 
d955 1
a955 1
				(void)fprintf(out, 
d960 1
a960 1
				(void)fprintf(stdout, "Process %ld stopped.\n", 
d1019 1
a1019 1
					(void)fprintf(stdout, 
d1031 1
a1031 1
			(void)fprintf(out, "*** Signal %d\n", 
d1221 1
a1221 1
				bytes = howmany(job->inPipe+1, NFDBITS) * 
d1223 2
a1224 2
				obytes = outputsn ? 
				    howmany(outputsn+1, NFDBITS) * 
d1333 1
a1333 1
			(void)fprintf(stdout, "Restarting %s...", 
d1566 1
a1566 1
			Lst_ForEachNodeWhile(&gn->commands, JobPrintCommand, 
d1596 1
a1596 1
			Lst_ForEachNodeWhile(&gn->commands, JobPrintCommand, 
d1636 1
a1636 1
				Lst_ForEachFrom(job->tailCmds, JobSaveCommand, 
d1674 1
a1674 1
			(void)strlcpy(job->outFile, TMPPAT, 
d1677 1
a1677 1
				Punt("Cannot create temp file: %s", 
d1714 1
a1714 1
				(void)fprintf(stdout, 
d1756 1
a1756 1
				while (*cp == ' ' || *cp == '\t' || 
d1888 1
a1888 1
				cp = JobOutput(job, job->outBuf, 
d1901 1
a1901 1
					(void)fprintf(stdout, "%s%s", cp, 
d1908 1
a1908 1
				(void)memcpy(job->outBuf, &job->outBuf[i + 1], 
d1946 1
a1946 1
			(void)fprintf(stdout, "Results of making %s:\n", 
d2011 1
a2011 1
			(void)fprintf(stdout, 
d2020 1
a2020 1
			if (WIFSIGNALED(status) && 
d2038 1
a2038 1
				(void)fprintf(stdout, 
d2089 1
a2089 1
			for (ln = Lst_First(&jobs); nfds && ln != NULL; 
@


1.66
log
@reindent
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.65 2007/09/16 12:01:11 espie Exp $	*/
d695 1
a695 1
	numCommands += 1;
d1008 1
a1008 1
			nJobs += 1;
d1015 1
a1015 1
			nLocal += 1;
d1080 1
a1080 1
		errors += 1;
d1239 1
a1239 1
		nLocal += 1;
d1252 1
a1252 1
	nJobs += 1;
d2036 1
a2036 1
			nJobs -= 1;
d2043 1
a2043 1
			nLocal -= 1;
d2094 1
a2094 1
					nfds -= 1;
@


1.65
log
@remove warnings
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.64 2007/09/16 10:57:02 espie Exp $	*/
d528 9
a536 9
    Job *job = (Job *)jobp;
    int signo = *(int *)signop;
    if (DEBUG(JOB)) {
	(void)fprintf(stdout,
		       "JobCondPassSig passing signal %d to child %ld.\n",
		       signo, (long)job->pid);
	(void)fflush(stdout);
    }
    KILL(job->pid, signo);
d552 2
a553 2
    sigset_t nmask, omask;
    struct sigaction act;
d555 17
a571 5
    if (DEBUG(JOB)) {
	(void)fprintf(stdout, "JobPassSig(%d) called.\n", signo);
	(void)fflush(stdout);
    }
    Lst_ForEach(&jobs, JobCondPassSig, &signo);
d573 6
a578 10
    /*
     * Deal with proper cleanup based on the signal received. We only run
     * the .INTERRUPT target if the signal was in fact an interrupt. The other
     * three termination signals are more of a "get out *now*" command.
     */
    if (signo == SIGINT) {
	JobInterrupt(true, signo);
    } else if (signo == SIGHUP || signo == SIGTERM || signo == SIGQUIT) {
	JobInterrupt(false, signo);
    }
d580 14
a593 6
    /*
     * Leave gracefully if SIGQUIT, rather than core dumping.
     */
    if (signo == SIGQUIT) {
	Finish(0);
    }
d595 7
a601 22
    /*
     * Send ourselves the signal now we've given the message to everyone else.
     * Note we block everything else possible while we're getting the signal.
     * This ensures that all our jobs get continued when we wake up before
     * we take any other signal.
     */
    sigemptyset(&nmask);
    sigaddset(&nmask, signo);
    sigprocmask(SIG_SETMASK, &nmask, &omask);
    memset(&act, 0, sizeof act);
    act.sa_handler = SIG_DFL;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    sigaction(signo, &act, NULL);

    if (DEBUG(JOB)) {
	(void)fprintf(stdout,
		       "JobPassSig passing signal to self, mask = %x.\n",
		       ~0 & ~(1 << (signo-1)));
	(void)fflush(stdout);
    }
    (void)signal(signo, SIG_DFL);
d603 1
a603 1
    (void)KILL(getpid(), signo);
d605 2
a606 2
    signo = SIGCONT;
    Lst_ForEach(&jobs, JobCondPassSig, &signo);
d608 4
a611 4
    (void)sigprocmask(SIG_SETMASK, &omask, NULL);
    sigprocmask(SIG_SETMASK, &omask, NULL);
    act.sa_handler = SigHandler;
    sigaction(signo, &act, NULL);
d629 1
a629 1
    return *(pid_t *)pid - ((Job *)job)->pid;
d663 23
a685 21
    bool	  noSpecials;	    /* true if we shouldn't worry about
				     * inserting special commands into
				     * the input stream. */
    bool	  shutUp = false;   /* true if we put a no echo command
				     * into the command file */
    bool	  errOff = false;   /* true if we turned error checking
				     * off before printing the command
				     * and need to turn it back on */
    char	  *cmdTemplate;     /* Template to use when printing the
				     * command */
    char	  *cmdStart;	    /* Start of expanded command */
    char	  *cmd = (char *)Lst_Datum(cmdNode);
    Job 	  *job = (Job *)jobp;

    noSpecials = (noExecute && !(job->node->type & OP_MAKE));

    if (strcmp(cmd, "...") == 0) {
	job->node->type |= OP_SAVE_CMDS;
	if ((job->flags & JOB_IGNDOTS) == 0) {
	    job->tailCmds = Lst_Succ(cmdNode);
	    return 0;
a686 2
	return 1;
    }
d695 1
a695 1
    numCommands += 1;
d697 4
a700 4
    /* For debugging, we replace each command with the result of expanding
     * the variables in the command.  */
    cmdStart = cmd = Var_Subst(cmd, &job->node->context, false);
    Lst_Replace(cmdNode, cmdStart);
d702 1
a702 1
    cmdTemplate = "%s\n";
d704 10
a713 21
    /*
     * Check for leading @@' and -'s to control echoing and error checking.
     */
    for (;; cmd++) {
	if (*cmd == '@@')
	    shutUp = DEBUG(LOUD) ? false : true;
	else if (*cmd == '-')
	    errOff = true;
	else if (*cmd != '+')
	    break;
    }

    while (isspace(*cmd))
	cmd++;

    if (shutUp) {
	if (!(job->flags & JOB_SILENT) && !noSpecials &&
	    commandShell->hasEchoCtl) {
		DBPRINTF("%s\n", commandShell->echoOff);
	} else {
	    shutUp = false;
a714 1
    }
d716 5
a720 12
    if (errOff) {
	if ( !(job->flags & JOB_IGNERR) && !noSpecials) {
	    if (commandShell->hasErrCtl) {
		/*
		 * we don't want the error-control commands showing
		 * up either, so we turn off echoing while executing
		 * them. We could put another field in the shell
		 * structure to tell JobDoOutput to look for this
		 * string too, but why make it any more complex than
		 * it already is?
		 */
		if (!(job->flags & JOB_SILENT) && !shutUp &&
a722 2
			DBPRINTF("%s\n", commandShell->ignErr);
			DBPRINTF("%s\n", commandShell->echoOn);
d724 55
a778 1
		    DBPRINTF("%s\n", commandShell->ignErr);
d780 9
a788 11
	    } else if (commandShell->ignErr &&
		      (*commandShell->ignErr != '\0'))
	    {
		/*
		 * The shell has no error control, so we need to be
		 * weird to get it to ignore any errors from the command.
		 * If echoing is turned on, we turn it off and use the
		 * errCheck template to echo the command. Leave echoing
		 * off so the user doesn't see the weirdness we go through
		 * to ignore errors. Set cmdTemplate to use the weirdness
		 * instead of the simple "%s\n" template.
d790 2
a791 2
		if (!(job->flags & JOB_SILENT) && !shutUp &&
		    commandShell->hasEchoCtl) {
a792 1
			DBPRINTF(commandShell->errCheck, cmd);
d795 4
a798 12
		cmdTemplate = commandShell->ignErr;
		/*
		 * The error ignoration (hee hee) is already taken care
		 * of by the ignErr template, so pretend error checking
		 * is still on.
		 */
		errOff = false;
	    } else {
		errOff = false;
	    }
	} else {
	    errOff = false;
d800 1
a800 20
    }

    DBPRINTF(cmdTemplate, cmd);

    if (errOff) {
	/*
	 * If echoing is already off, there's no point in issuing the
	 * echoOff command. Otherwise we issue it and pretend it was on
	 * for the whole command...
	 */
	if (!shutUp && !(job->flags & JOB_SILENT) && commandShell->hasEchoCtl){
	    DBPRINTF("%s\n", commandShell->echoOff);
	    shutUp = true;
	}
	DBPRINTF("%s\n", commandShell->errCheck);
    }
    if (shutUp) {
	DBPRINTF("%s\n", commandShell->echoOn);
    }
    return 1;
d816 2
a817 2
    GNode	*g = (GNode *)gn;
    char	*result;
d819 2
a820 2
    result = Var_Subst((char *)cmd, &g->context, false);
    Lst_AtEnd(&postCommands->commands, result);
d836 11
a846 11
    if (usePipes) {
	FD_CLR(job->inPipe, outputsp);
	if (job->outPipe != job->inPipe) {
	   (void)close(job->outPipe);
	}
	JobDoOutput(job, true);
	(void)close(job->inPipe);
    } else {
	(void)close(job->outFd);
	JobDoOutput(job, true);
    }
d874 1
a874 1
    bool	 done;
d876 36
a911 15
    if ((WIFEXITED(*status) &&
	 WEXITSTATUS(*status) != 0 && !(job->flags & JOB_IGNERR)) ||
	(WIFSIGNALED(*status) && WTERMSIG(*status) != SIGCONT))
    {
	/*
	 * If it exited non-zero and either we're doing things our
	 * way or we're not ignoring errors, the job is finished.
	 * Similarly, if the shell died because of a signal
	 * the job is also finished. In these
	 * cases, finish out the job's output before printing the exit
	 * status...
	 */
	JobClose(job);
	if (job->cmdFILE != NULL && job->cmdFILE != stdout) {
	   (void)fclose(job->cmdFILE);
a912 23
	done = true;
    } else if (WIFEXITED(*status)) {
	/*
	 * Deal with ignored errors in -B mode. We need to print a message
	 * telling of the ignored error as well as setting status.w_status
	 * to 0 so the next command gets run. To do this, we set done to be
	 * true if in -B mode and the job exited non-zero.
	 */
	done = WEXITSTATUS(*status) != 0;
	/*
	 * Old comment said: "Note we don't
	 * want to close down any of the streams until we know we're at the
	 * end."
	 * But we do. Otherwise when are we going to print the rest of the
	 * stuff?
	 */
	JobClose(job);
    } else {
	/*
	 * No need to close things down or anything.
	 */
	done = false;
    }
d914 16
a929 17
    if (done ||
	WIFSTOPPED(*status) ||
	(WIFSIGNALED(*status) && WTERMSIG(*status) == SIGCONT) ||
	DEBUG(JOB))
    {
	FILE	  *out;

	if (compatMake && !usePipes && (job->flags & JOB_IGNERR)) {
	    /*
	     * If output is going to a file and this job is ignoring
	     * errors, arrange to have the exit status sent to the
	     * output file as well.
	     */
	    out = fdopen(job->outFd, "w");
	} else {
	    out = stdout;
	}
d931 73
a1003 67
	if (WIFEXITED(*status)) {
	    if (DEBUG(JOB)) {
		(void)fprintf(stdout, "Process %ld exited.\n", (long)job->pid);
		(void)fflush(stdout);
	    }
	    if (WEXITSTATUS(*status) != 0) {
		if (usePipes && job->node != lastNode) {
		    MESSAGE(out, job->node);
		    lastNode = job->node;
		}
		(void)fprintf(out, "*** Error code %d%s\n",
			       WEXITSTATUS(*status),
			       (job->flags & JOB_IGNERR) ? "(ignored)" : "");

		if (job->flags & JOB_IGNERR) {
		    *status = 0;
		}
	    } else if (DEBUG(JOB)) {
		if (usePipes && job->node != lastNode) {
		    MESSAGE(out, job->node);
		    lastNode = job->node;
		}
		(void)fprintf(out, "*** Completed successfully\n");
	    }
	} else if (WIFSTOPPED(*status)) {
	    if (DEBUG(JOB)) {
		(void)fprintf(stdout, "Process %ld stopped.\n", (long)job->pid);
		(void)fflush(stdout);
	    }
	    if (usePipes && job->node != lastNode) {
		MESSAGE(out, job->node);
		lastNode = job->node;
	    }
	    (void)fprintf(out, "*** Stopped -- signal %d\n",
		WSTOPSIG(*status));
	    job->flags |= JOB_RESUME;
	    Lst_AtEnd(&stoppedJobs, job);
	    (void)fflush(out);
	    return;
	} else if (WTERMSIG(*status) == SIGCONT) {
	    /*
	     * If the beastie has continued, shift the Job from the stopped
	     * list to the running one (or re-stop it if concurrency is
	     * exceeded) and go and get another child.
	     */
	    if (job->flags & (JOB_RESUME|JOB_RESTART)) {
		if (usePipes && job->node != lastNode) {
		    MESSAGE(out, job->node);
		    lastNode = job->node;
		}
		(void)fprintf(out, "*** Continued\n");
	    }
	    if (!(job->flags & JOB_CONTINUING)) {
		if (DEBUG(JOB)) {
		    (void)fprintf(stdout,
				   "Warning: process %ld was not continuing.\n",
				   (long)job->pid);
		    (void)fflush(stdout);
		}
#ifdef notdef
		/*
		 * We don't really want to restart a job from scratch just
		 * because it continued, especially not without killing the
		 * continuing process!	That's why this is ifdef'ed out.
		 * FD - 9/17/90
		 */
		JobRestart(job);
d1005 28
a1032 16
	    }
	    job->flags &= ~JOB_CONTINUING;
	    Lst_AtEnd(&jobs, job);
	    nJobs += 1;
	    if (DEBUG(JOB)) {
		(void)fprintf(stdout,
			       "Process %ld is continuing locally.\n",
			       (long)job->pid);
		(void)fflush(stdout);
	    }
	    nLocal += 1;
	    if (nJobs == maxJobs) {
		jobFull = true;
		if (DEBUG(JOB)) {
		    (void)fprintf(stdout, "Job queue is full.\n");
		    (void)fflush(stdout);
d1034 2
a1035 9
	    }
	    (void)fflush(out);
	    return;
	} else {
	    if (usePipes && job->node != lastNode) {
		MESSAGE(out, job->node);
		lastNode = job->node;
	    }
	    (void)fprintf(out, "*** Signal %d\n", WTERMSIG(*status));
d1038 28
a1065 2
	(void)fflush(out);
    }
d1067 16
a1082 44
    /*
     * Now handle the -B-mode stuff. If the beast still isn't finished,
     * try and restart the job on the next command. If JobStart says it's
     * ok, it's ok. If there's an error, this puppy is done.
     */
    if (compatMake && WIFEXITED(*status) && job->node->current != NULL) {
	switch (JobStart(job->node, job->flags & JOB_IGNDOTS, job)) {
	case JOB_RUNNING:
	    done = false;
	    break;
	case JOB_ERROR:
	    done = true;
	    W_SETEXITSTATUS(status, 1);
	    break;
	case JOB_FINISHED:
	    /*
	     * If we got back a JOB_FINISHED code, JobStart has already
	     * called Make_Update and freed the job descriptor. We set
	     * done to false here to avoid fake cycles and double frees.
	     * JobStart needs to do the update so we can proceed up the
	     * graph when given the -n flag..
	     */
	    done = false;
	    break;
	}
    } else
	done = true;

    if (done &&
	aborting != ABORT_ERROR &&
	aborting != ABORT_INTERRUPT &&
	*status == 0) {
	/* As long as we aren't aborting and the job didn't return a non-zero
	 * status that we shouldn't ignore, we call Make_Update to update
	 * the parents. In addition, any saved commands for the node are placed
	 * on the .END target.	*/
	Lst_ForEachFrom(job->tailCmds, JobSaveCommand, job->node);
	job->node->made = MADE;
	Make_Update(job->node);
	free(job);
    } else if (*status != 0) {
	errors += 1;
	free(job);
    }
d1084 1
a1084 1
    JobRestartJobs();
a1085 4
    /*
     * Set aborting if any error.
     */
    if (errors && !keepgoing && aborting != ABORT_INTERRUPT) {
d1087 1
a1087 3
	 * If we found any errors in this batch of children and the -k flag
	 * wasn't given, we set the aborting flag so no more jobs get
	 * started.
d1089 8
a1096 2
	aborting = ABORT_ERROR;
    }
d1098 7
a1104 7
    if (aborting == ABORT_ERROR && Job_Empty()) {
	/*
	 * If we are aborting and the job table is now empty, we finish.
	 */
	(void)eunlink(tfile);
	Finish(errors);
    }
d1121 1
a1121 1
    pid_t 	  cpid; 	/* ID of new child */
d1123 2
a1124 2
    if (DEBUG(JOB)) {
	int	  i;
d1126 7
a1132 4
	(void)fprintf(stdout, "Running %s\n", job->node->name);
	(void)fprintf(stdout, "\tCommand: ");
	for (i = 0; argv[i] != NULL; i++) {
	    (void)fprintf(stdout, "%s ", argv[i]);
a1133 3
	(void)fprintf(stdout, "\n");
	(void)fflush(stdout);
    }
d1135 11
a1145 15
    /*
     * Some jobs produce no output and it's disconcerting to have
     * no feedback of their running (since they produce no output, the
     * banner with their name in it never appears). This is an attempt to
     * provide that feedback, even if nothing follows it.
     */
    if (lastNode != job->node && (job->flags & JOB_FIRST) &&
	!(job->flags & JOB_SILENT)) {
	MESSAGE(stdout, job->node);
	lastNode = job->node;
    }

    if ((cpid = fork()) == -1) {
	Punt("Cannot fork");
    } else if (cpid == 0) {
d1147 3
a1149 9
	/*
	 * Must duplicate the input stream down to the child's input and
	 * reset it to the beginning (again). Since the stream was marked
	 * close-on-exec, we must clear that bit in the new input.
	 */
	if (dup2(FILENO(job->cmdFILE), 0) == -1)
	    Punt("Cannot dup2: %s", strerror(errno));
	(void)fcntl(0, F_SETFD, 0);
	(void)lseek(0, 0, SEEK_SET);
d1151 36
a1186 25
	if (usePipes) {
	    /*
	     * Set up the child's output to be routed through the pipe
	     * we've created for it.
	     */
	    if (dup2(job->outPipe, 1) == -1)
		Punt("Cannot dup2: %s", strerror(errno));
	} else {
	    /*
	     * We're capturing output in a file, so we duplicate the
	     * descriptor to the temporary file into the standard
	     * output.
	     */
	    if (dup2(job->outFd, 1) == -1)
		Punt("Cannot dup2: %s", strerror(errno));
	}
	/*
	 * The output channels are marked close on exec. This bit was
	 * duplicated by the dup2 (on some systems), so we have to clear
	 * it before routing the shell's error output to the same place as
	 * its standard output.
	 */
	(void)fcntl(1, F_SETFD, 0);
	if (dup2(1, 2) == -1)
	    Punt("Cannot dup2: %s", strerror(errno));
d1189 5
a1193 5
	/*
	 * We want to switch the child into a different process family so
	 * we can kill it and all its descendants in one fell swoop,
	 * by killing its process family, but not commit suicide.
	 */
d1195 1
a1195 1
	(void)setsid();
d1197 1
a1197 1
	(void)setpgid(0, getpid());
d1201 37
a1237 1
	   (void)execv(shellPath, argv);
d1239 8
a1246 32
	(void)write(STDERR_FILENO, "Could not execute shell\n",
		     sizeof("Could not execute shell"));
	_exit(1);
    } else {
	job->pid = cpid;

	if (usePipes && (job->flags & JOB_FIRST) ) {
	    /*
	     * The first time a job is run for a node, we set the current
	     * position in the buffer to the beginning and mark another
	     * stream to watch in the outputs mask
	     */
	    job->curPos = 0;

	    if (outputsp == NULL || job->inPipe > outputsn) {
		int bytes, obytes;
		char *tmp;

		bytes = howmany(job->inPipe+1, NFDBITS) * sizeof(fd_mask);
		obytes = outputsn ?
		    howmany(outputsn+1, NFDBITS) * sizeof(fd_mask) : 0;

		if (bytes != obytes) {
			tmp = realloc(outputsp, bytes);
			if (tmp == NULL)
				return;
			memset(tmp + obytes, 0, bytes - obytes);
			outputsp = (fd_set *)tmp;
		}
		outputsn = job->inPipe;
	    }
	    FD_SET(job->inPipe, outputsp);
a1248 1
	nLocal += 1;
d1250 1
a1250 1
	 * XXX: Used to not happen if REMOTE. Why?
d1252 4
a1255 3
	if (job->cmdFILE != NULL && job->cmdFILE != stdout) {
	    (void)fclose(job->cmdFILE);
	    job->cmdFILE = NULL;
a1256 10
    }

    /*
     * Now the job is actually running, add it to the table.
     */
    nJobs += 1;
    Lst_AtEnd(&jobs, job);
    if (nJobs == maxJobs) {
	jobFull = true;
    }
d1268 2
a1269 2
    int 	  argc;
    static char   args[10];	/* For merged arguments */
d1271 2
a1272 2
    argv[0] = shellName;
    argc = 1;
d1274 28
a1301 27
    if ((commandShell->exit && *commandShell->exit != '-') ||
	(commandShell->echo && *commandShell->echo != '-'))
    {
	/*
	 * At least one of the flags doesn't have a minus before it, so
	 * merge them together. Have to do this because the *(&(@@*#*&#$#
	 * Bourne shell thinks its second argument is a file to source.
	 * Grrrr. Note the ten-character limitation on the combined arguments.
	 */
	(void)snprintf(args, sizeof(args), "-%s%s",
		      ((job->flags & JOB_IGNERR) ? "" :
		       (commandShell->exit ? commandShell->exit : "")),
		      ((job->flags & JOB_SILENT) ? "" :
		       (commandShell->echo ? commandShell->echo : "")));

	if (args[1]) {
	    argv[argc] = args;
	    argc++;
	}
    } else {
	if (!(job->flags & JOB_IGNERR) && commandShell->exit) {
	    argv[argc] = commandShell->exit;
	    argc++;
	}
	if (!(job->flags & JOB_SILENT) && commandShell->echo) {
	    argv[argc] = commandShell->echo;
	    argc++;
d1303 1
a1303 2
    }
    argv[argc] = NULL;
d1318 11
a1328 10
    if (job->flags & JOB_RESTART) {
	/*
	 * Set up the control arguments to the shell. This is based on the
	 * flags set earlier for this job. If the JOB_IGNERR flag is clear,
	 * the 'exit' flag of the commandShell is used to cause it to exit
	 * upon receiving an error. If the JOB_SILENT flag is clear, the
	 * 'echo' flag of the commandShell is used to get it to start echoing
	 * as soon as it starts processing commands.
	 */
	char	  *argv[4];
d1330 1
a1330 1
	JobMakeArgv(job, argv);
a1331 10
	if (DEBUG(JOB)) {
	    (void)fprintf(stdout, "Restarting %s...", job->node->name);
	    (void)fflush(stdout);
	}
	{
	    if (nLocal >= maxLocal && !(job->flags & JOB_SPECIAL)) {
		/*
		 * Can't be exported and not allowed to run locally -- put it
		 * back on the hold queue and mark the table full
		 */
d1333 3
a1335 2
		    (void)fprintf(stdout, "holding\n");
		    (void)fflush(stdout);
d1337 25
a1361 5
		Lst_AtFront(&stoppedJobs, job);
		jobFull = true;
		if (DEBUG(JOB)) {
		    (void)fprintf(stdout, "Job queue is full.\n");
		    (void)fflush(stdout);
d1363 2
a1364 2
		return;
	    } else {
d1366 2
a1367 1
		 * Job may be run locally.
d1370 2
a1371 2
		    (void)fprintf(stdout, "running locally\n");
		    (void)fflush(stdout);
d1373 50
a1422 39
	    }
	}
	JobExec(job, argv);
    } else {
	/*
	 * The job has stopped and needs to be restarted. Why it stopped,
	 * we don't know...
	 */
	if (DEBUG(JOB)) {
	   (void)fprintf(stdout, "Resuming %s...", job->node->name);
	   (void)fflush(stdout);
	}
	if ((nLocal < maxLocal ||
	    ((job->flags & JOB_SPECIAL) &&
	     maxLocal == 0)
	   ) && nJobs != maxJobs)
	{
	    /*
	     * If we haven't reached the concurrency limit already (or
	     * maxLocal is 0), it's ok to resume the job.
	     */
	    bool error;
	    int status;

		error = KILL(job->pid, SIGCONT) != 0;

	    if (!error) {
		/*
		 * Make sure the user knows we've continued the beast and
		 * actually put the thing in the job table.
		 */
		job->flags |= JOB_CONTINUING;
		W_SETTERMSIG(&status, SIGCONT);
		JobFinish(job, &status);

		job->flags &= ~(JOB_RESUME|JOB_CONTINUING);
		if (DEBUG(JOB)) {
		   (void)fprintf(stdout, "done\n");
		   (void)fflush(stdout);
a1423 22
	    } else {
		Error("couldn't resume %s: %s",
		    job->node->name, strerror(errno));
		status = 0;
		W_SETEXITSTATUS(&status, 1);
		JobFinish(job, &status);
	    }
	} else {
	    /*
	     * Job cannot be restarted. Mark the table as full and
	     * place the job back on the list of stopped jobs.
	     */
	    if (DEBUG(JOB)) {
		(void)fprintf(stdout, "table full\n");
		(void)fflush(stdout);
	    }
	    Lst_AtFront(&stoppedJobs, job);
	    jobFull = true;
	    if (DEBUG(JOB)) {
		(void)fprintf(stdout, "Job queue is full.\n");
		(void)fflush(stdout);
	    }
a1424 1
    }
d1450 15
a1464 13
    Job 	  *job;       /* new job descriptor */
    char	  *argv[4];   /* Argument vector to shell */
    bool	  cmdsOK;     /* true if the nodes commands were all right */
    bool	  local;      /* Set true if the job was run locally */
    bool	  noExec;     /* Set true if we decide not to run the job */

    if (previous != NULL) {
	previous->flags &= ~(JOB_FIRST|JOB_IGNERR|JOB_SILENT);
	job = previous;
    } else {
	job = emalloc(sizeof(Job));
	if (job == NULL) {
	    Punt("JobStart out of memory");
a1465 2
	flags |= JOB_FIRST;
    }
d1467 2
a1468 2
    job->node = gn;
    job->tailCmds = NULL;
a1469 31
    /*
     * Set the initial value of the flags for this job based on the global
     * ones and the node's attributes... Any flags supplied by the caller
     * are also added to the field.
     */
    job->flags = 0;
    if (Targ_Ignore(gn)) {
	job->flags |= JOB_IGNERR;
    }
    if (Targ_Silent(gn)) {
	job->flags |= JOB_SILENT;
    }
    job->flags |= flags;

    /*
     * Check the commands now so any attributes from .DEFAULT have a chance
     * to migrate to the node
     */
    if (!compatMake && job->flags & JOB_FIRST) {
	cmdsOK = Job_CheckCommands(gn, Error);
    } else {
	cmdsOK = true;
    }

    /*
     * If the -n flag wasn't given, we open up OUR (not the child's)
     * temporary file to stuff commands in it. The thing is rd/wr so we don't
     * need to reopen it to feed it to the shell. If the -n flag *was* given,
     * we just set the file to be stdout. Cute, huh?
     */
    if ((gn->type & OP_MAKE) || (!noExecute && !touchFlag)) {
d1471 3
a1473 2
	 * We're serious here, but if the commands were bogus, we're
	 * also dead...
d1475 6
a1480 2
	if (!cmdsOK) {
	    DieHorribly();
d1482 1
a1483 5
	job->cmdFILE = fopen(tfile, "w+");
	if (job->cmdFILE == NULL) {
	    Punt("Could not open %s", tfile);
	}
	(void)fcntl(FILENO(job->cmdFILE), F_SETFD, 1);
d1485 2
a1486 2
	 * Send the commands to the command file, flush all its buffers then
	 * rewind and remove the thing.
d1488 5
a1492 1
	noExec = false;
d1495 4
a1498 2
	 * used to be backwards; replace when start doing multiple commands
	 * per shell.
d1500 8
a1507 13
	if (compatMake) {
	    /*
	     * Be compatible: If this is the first time for this node,
	     * verify its commands are ok and open the commands list for
	     * sequential access by later invocations of JobStart.
	     * Once that is done, we take the next command off the list
	     * and print it to the command file. If the command was an
	     * ellipsis, note that there's nothing more to execute.
	     */
	    if ((job->flags&JOB_FIRST))
		gn->current = Lst_First(&gn->commands);
	    else
		gn->current = Lst_Succ(gn->current);
d1509 93
a1601 2
	    if (gn->current == NULL ||
		!JobPrintCommand(gn->current, job)) {
d1603 6
a1608 13
		gn->current = NULL;
	    }
	    if (noExec && !(job->flags & JOB_FIRST)) {
		/*
		 * If we're not going to execute anything, the job
		 * is done and we need to close down the various
		 * file descriptors we've opened for output, then
		 * call JobDoOutput to catch the final characters or
		 * send the file to the screen... Note that the i/o streams
		 * are only open if this isn't the first job.
		 * Note also that this could not be done in
		 * Job_CatchChildren b/c it wasn't clear if there were
		 * more commands to execute or not...
d1610 2
a1611 14
		JobClose(job);
	    }
	} else {
	    /*
	     * We can do all the commands at once. hooray for sanity
	     */
	    numCommands = 0;
	    Lst_ForEachNodeWhile(&gn->commands, JobPrintCommand, job);

	    /*
	     * If we didn't print out any commands to the shell script,
	     * there's not much point in executing the shell, is there?
	     */
	    if (numCommands == 0) {
a1612 1
	    }
d1614 1
a1614 1
    } else if (noExecute) {
d1616 1
a1616 2
	 * Not executing anything -- just print all the commands to stdout
	 * in one fell swoop. This will still set up job->tailCmds correctly.
d1618 11
a1628 28
	if (lastNode != gn) {
	    MESSAGE(stdout, gn);
	    lastNode = gn;
	}
	job->cmdFILE = stdout;
	/*
	 * Only print the commands if they're ok, but don't die if they're
	 * not -- just let the user know they're bad and keep going. It
	 * doesn't do any harm in this case and may do some good.
	 */
	if (cmdsOK) {
	    Lst_ForEachNodeWhile(&gn->commands, JobPrintCommand, job);
	}
	/*
	 * Don't execute the shell, thank you.
	 */
	noExec = true;
    } else {
	/*
	 * Just touch the target and note that no shell should be executed.
	 * Set cmdFILE to stdout to make life easier. Check the commands, too,
	 * but don't die if they're no good -- it does no harm to keep working
	 * up the graph.
	 */
	job->cmdFILE = stdout;
	Job_Touch(gn, job->flags&JOB_SILENT);
	noExec = true;
    }
d1630 16
a1645 11
    /*
     * If we're not supposed to execute a shell, don't.
     */
    if (noExec) {
	/*
	 * Unlink and close the command file if we opened one
	 */
	if (job->cmdFILE != stdout) {
	    (void)eunlink(tfile);
	    if (job->cmdFILE != NULL)
		(void)fclose(job->cmdFILE);
d1647 2
a1648 1
	     (void)fflush(stdout);
d1652 2
a1653 2
	 * We only want to work our way up the graph if we aren't here because
	 * the commands for the job were no good.
d1655 1
a1655 15
	if (cmdsOK) {
	    if (aborting == 0) {
		Lst_ForEachFrom(job->tailCmds, JobSaveCommand, job->node);
		Make_Update(job->node);
	    }
	    free(job);
	    return JOB_FINISHED;
	} else {
	    free(job);
	    return JOB_ERROR;
	}
    } else {
	(void)fflush(job->cmdFILE);
	(void)eunlink(tfile);
    }
d1657 24
a1680 27
    /*
     * Set up the control arguments to the shell. This is based on the flags
     * set earlier for this job.
     */
    JobMakeArgv(job, argv);

    /*
     * If we're using pipes to catch output, create the pipe by which we'll
     * get the shell's output. If we're using files, print out that we're
     * starting a job and then set up its temporary-file name.
     */
    if (!compatMake || (job->flags & JOB_FIRST)) {
	if (usePipes) {
	    int fd[2];
	    if (pipe(fd) == -1)
		Punt("Cannot create pipe: %s", strerror(errno));
	    job->inPipe = fd[0];
	    job->outPipe = fd[1];
	    (void)fcntl(job->inPipe, F_SETFD, 1);
	    (void)fcntl(job->outPipe, F_SETFD, 1);
	} else {
	    (void)fprintf(stdout, "Remaking `%s'\n", gn->name);
	    (void)fflush(stdout);
	    (void)strlcpy(job->outFile, TMPPAT, sizeof(job->outFile));
	    if ((job->outFd = mkstemp(job->outFile)) == -1)
		Punt("Cannot create temp file: %s", strerror(errno));
	    (void)fcntl(job->outFd, F_SETFD, 1);
a1681 1
    }
d1685 14
a1698 15
    if (local && nLocal >= maxLocal &&
	!(job->flags & JOB_SPECIAL) &&
	maxLocal != 0
	)
    {
	/*
	 * The job can only be run locally, but we've hit the limit of
	 * local concurrency, so put the job on hold until some other job
	 * finishes. Note that the special jobs (.BEGIN, .INTERRUPT and .END)
	 * may be run locally even when the local limit has been reached
	 * (e.g. when maxLocal == 0), though they will be exported if at
	 * all possible. In addition, any target marked with .NOEXPORT will
	 * be run locally if maxLocal is 0.
	 */
	jobFull = true;
d1700 20
a1719 17
	if (DEBUG(JOB)) {
	   (void)fprintf(stdout, "Can only run job locally.\n");
	   (void)fflush(stdout);
	}
	job->flags |= JOB_RESTART;
	Lst_AtEnd(&stoppedJobs, job);
    } else {
	if (nLocal >= maxLocal && local) {
	    /*
	     * If we're running this job locally as a special case (see above),
	     * at least say the table is full.
	     */
	    jobFull = true;
	    if (DEBUG(JOB)) {
		(void)fprintf(stdout, "Local job queue is full.\n");
		(void)fflush(stdout);
	    }
d1721 1
a1721 3
	JobExec(job, argv);
    }
    return JOB_RUNNING;
d1727 1
a1727 1
    char *ecp;
d1729 35
a1763 28
    if (commandShell->noPrint) {
	ecp = strstr(cp, commandShell->noPrint);
	while (ecp != NULL) {
	    if (cp != ecp) {
		*ecp = '\0';
		if (msg && job->node != lastNode) {
		    MESSAGE(stdout, job->node);
		    lastNode = job->node;
		}
		/*
		 * The only way there wouldn't be a newline after
		 * this line is if it were the last in the buffer.
		 * however, since the non-printable comes after it,
		 * there must be a newline, so we don't print one.
		 */
		(void)fprintf(stdout, "%s", cp);
		(void)fflush(stdout);
	    }
	    cp = ecp + commandShell->noPLen;
	    if (cp != endp) {
		/*
		 * Still more to print, look again after skipping
		 * the whitespace following the non-printable
		 * command....
		 */
		cp++;
		while (*cp == ' ' || *cp == '\t' || *cp == '\n') {
		    cp++;
a1764 4
		ecp = strstr(cp, commandShell->noPrint);
	    } else {
		return cp;
	    }
d1766 1
a1766 2
    }
    return cp;
d1794 10
a1803 10
JobDoOutput(Job 	  *job,   /* the job whose output needs printing */
    bool	   finish)	  /* true if this is the last time we'll be
				   * called for this job */
{
    bool	  gotNL = false;  /* true if got a newline */
    bool	  fbuf; 	  /* true if our buffer filled up */
    int 	  nr;		  /* number of bytes read */
    int 	  i;		  /* auxiliary index into outBuf */
    int 	  max;		  /* limit for i (end of current data) */
    int 	  nRead;	  /* (Temporary) number of bytes read */
d1805 2
a1806 2
    FILE	  *oFILE;	  /* Stream pointer to shell's output file */
    char	  inLine[132];
d1809 4
a1812 4
    if (usePipes) {
	/*
	 * Read as many bytes as will fit in the buffer.
	 */
d1814 2
a1815 2
	gotNL = false;
	fbuf = false;
d1817 10
a1826 10
	nRead = read(job->inPipe, &job->outBuf[job->curPos],
			 JOB_BUFSIZE - job->curPos);
	if (nRead == -1) {
	    if (DEBUG(JOB)) {
		perror("JobDoOutput(piperead)");
	    }
	    nr = 0;
	} else {
	    nr = nRead;
	}
d1828 13
a1840 13
	/*
	 * If we hit the end-of-file (the job is dead), we must flush its
	 * remaining output, so pretend we read a newline if there's any
	 * output remaining in the buffer.
	 * Also clear the 'finish' flag so we stop looping.
	 */
	if (nr == 0 && job->curPos != 0) {
	    job->outBuf[job->curPos] = '\n';
	    nr = 1;
	    finish = false;
	} else if (nr == 0) {
	    finish = false;
	}
a1841 11
	/*
	 * Look for the last newline in the bytes we just got. If there is
	 * one, break out of the loop with 'i' as its index and gotNL set
	 * true.
	 */
	max = job->curPos + nr;
	for (i = job->curPos + nr - 1; i >= job->curPos; i--) {
	    if (job->outBuf[i] == '\n') {
		gotNL = true;
		break;
	    } else if (job->outBuf[i] == '\0') {
d1843 3
a1845 1
		 * Why?
d1847 12
a1858 3
		job->outBuf[i] = ' ';
	    }
	}
d1860 83
a1942 95
	if (!gotNL) {
	    job->curPos += nr;
	    if (job->curPos == JOB_BUFSIZE) {
		/*
		 * If we've run out of buffer space, we have no choice
		 * but to print the stuff. sigh.
		 */
		fbuf = true;
		i = job->curPos;
	    }
	}
	if (gotNL || fbuf) {
	    /*
	     * Need to send the output to the screen. Null terminate it
	     * first, overwriting the newline character if there was one.
	     * So long as the line isn't one we should filter (according
	     * to the shell description), we print the line, preceded
	     * by a target banner if this target isn't the same as the
	     * one for which we last printed something.
	     * The rest of the data in the buffer are then shifted down
	     * to the start of the buffer and curPos is set accordingly.
	     */
	    job->outBuf[i] = '\0';
	    if (i >= job->curPos) {
		char *cp;

		cp = JobOutput(job, job->outBuf, &job->outBuf[i], false);

		/*
		 * There's still more in that thar buffer. This time, though,
		 * we know there's no newline at the end, so we add one of
		 * our own free will.
		 */
		if (*cp != '\0') {
		    if (job->node != lastNode) {
			MESSAGE(stdout, job->node);
			lastNode = job->node;
		    }
		    (void)fprintf(stdout, "%s%s", cp, gotNL ? "\n" : "");
		    (void)fflush(stdout);
		}
	    }
	    if (i < max - 1) {
		/* shift the remaining characters down */
		(void)memcpy(job->outBuf, &job->outBuf[i + 1], max - (i + 1));
		job->curPos = max - (i + 1);

	    } else {
		/*
		 * We have written everything out, so we just start over
		 * from the start of the buffer. No copying. No nothing.
		 */
		job->curPos = 0;
	    }
	}
	if (finish) {
	    /*
	     * If the finish flag is true, we must loop until we hit
	     * end-of-file on the pipe. This is guaranteed to happen
	     * eventually since the other end of the pipe is now closed
	     * (we closed it explicitly and the child has exited). When
	     * we do get an EOF, finish will be set false and we'll fall
	     * through and out.
	     */
	    goto end_loop;
	}
    } else {
	/*
	 * We've been called to retrieve the output of the job from the
	 * temporary file where it's been squirreled away. This consists of
	 * opening the file, reading the output line by line, being sure not
	 * to print the noPrint line for the shell we used, then close and
	 * remove the temporary file. Very simple.
	 *
	 * Change to read in blocks and do FindSubString type things as for
	 * pipes? That would allow for "@@echo -n..."
	 */
	oFILE = fopen(job->outFile, "r");
	if (oFILE != NULL) {
	    (void)fprintf(stdout, "Results of making %s:\n", job->node->name);
	    (void)fflush(stdout);
	    while (fgets(inLine, sizeof(inLine), oFILE) != NULL) {
		char	*cp, *endp, *oendp;

		cp = inLine;
		oendp = endp = inLine + strlen(inLine);
		if (endp != inLine && endp[-1] == '\n') {
		    *--endp = '\0';
		}
		cp = JobOutput(job, inLine, endp, false);

		/*
		 * There's still more in that thar buffer. This time, though,
		 * we know there's no newline at the end, so we add one of
		 * our own free will.
d1944 30
a1973 9
		(void)fprintf(stdout, "%s", cp);
		(void)fflush(stdout);
		if (endp != oendp) {
		    (void)fprintf(stdout, "\n");
		    (void)fflush(stdout);
		}
	    }
	    (void)fclose(oFILE);
	    (void)eunlink(job->outFile);
a1974 1
    }
d1995 4
a1998 4
    pid_t 	  pid;		/* pid of dead child */
    Job 	  *job; 	/* job descriptor for dead child */
    LstNode	  jnode;	/* list element for finding job */
    int 	  status;	/* Exit/termination status */
d2000 5
a2004 14
    /*
     * Don't even bother if we know there's no one around.
     */
    if (nLocal == 0) {
	return;
    }

    while ((pid = waitpid((pid_t) -1, &status,
			  (block?0:WNOHANG)|WUNTRACED)) > 0)
    {
    	HandleSigs();
	if (DEBUG(JOB)) {
	    (void)fprintf(stdout, "Process %ld exited or stopped.\n", (long)pid);
	    (void)fflush(stdout);
d2007 9
d2017 1
a2017 1
	jnode = Lst_Find(&jobs, JobCmpPid, &pid);
a2018 3
	if (jnode == NULL) {
	    if (WIFSIGNALED(status) && (WTERMSIG(status) == SIGCONT)) {
		jnode = Lst_Find(&stoppedJobs, JobCmpPid, &pid);
d2020 24
a2043 2
		    Error("Resumed child (%ld) not in table", (long)pid);
		    continue;
d2045 2
a2046 16
		job = (Job *)Lst_Datum(jnode);
		Lst_Remove(&stoppedJobs, jnode);
	    } else {
		Error("Child (%ld) not in table?", (long)pid);
		continue;
	    }
	} else {
	    job = (Job *)Lst_Datum(jnode);
	    Lst_Remove(&jobs, jnode);
	    nJobs -= 1;
	    if (jobFull && DEBUG(JOB)) {
		(void)fprintf(stdout, "Job queue is no longer full.\n");
		(void)fflush(stdout);
	    }
	    jobFull = false;
	    nLocal -= 1;
a2047 3

	JobFinish(job, &status);
    }
d2066 31
a2096 28
    int 		  nfds;
    struct timeval	  timeout;
    LstNode		  ln;
    Job 		  *job;

    (void)fflush(stdout);
    if (usePipes) {
	int count = howmany(outputsn+1, NFDBITS) * sizeof(fd_mask);
	fd_set *readfdsp = malloc(count);
	if (readfdsp == NULL)
	    return;

	memcpy(readfdsp, outputsp, count);
	timeout.tv_sec = SEL_SEC;
	timeout.tv_usec = SEL_USEC;

	if ((nfds = select(outputsn+1, readfdsp, (fd_set *) 0,
			   (fd_set *) 0, &timeout)) <= 0) {
	    HandleSigs();
	    free(readfdsp);
	    return;
	} else {
	    HandleSigs();
	    for (ln = Lst_First(&jobs); nfds && ln != NULL; ln = Lst_Adv(ln)) {
		job = (Job *)Lst_Datum(ln);
		if (FD_ISSET(job->inPipe, readfdsp)) {
		    JobDoOutput(job, false);
		    nfds -= 1;
d2098 1
a2098 1
	    }
a2099 2
	free(readfdsp);
    }
d2115 1
a2115 1
    (void)JobStart(gn, 0, NULL);
d2133 19
a2151 2
    GNode	  *begin;     /* node for commands to do at the very start */
    int 	  tfd;
d2153 1
a2153 13
    (void)strlcpy(tfile, TMPPAT, sizeof(tfile));
    if ((tfd = mkstemp(tfile)) == -1)
	Punt("Cannot create temp file: %s", strerror(errno));
    else
	(void)close(tfd);

    Static_Lst_Init(&jobs);
    Static_Lst_Init(&stoppedJobs);
    maxJobs =	  maxproc;
    maxLocal =	  maxlocal;
    nJobs =	  0;
    nLocal =	  0;
    jobFull =	  false;
d2155 9
a2163 2
    aborting =	  0;
    errors =	  0;
d2165 19
a2183 1
    lastNode =	  NULL;
a2184 1
    if (maxJobs == 1) {
d2186 2
a2187 2
	 * If only one job can run at a time, there's no need for a banner,
	 * no is there?
d2189 12
a2200 6
	targFmt = "";
    } else {
	targFmt = TARG_FMT;
    }

    if (shellPath == NULL) {
d2202 4
a2205 5
	 * The user didn't specify a shell to use, so we are using the
	 * default one... Both the absolute path and the last component
	 * must be set. The last component is taken from the 'name' field
	 * of the default shell description pointed-to by commandShell.
	 * All default shells are located in _PATH_DEFSHELLDIR.
a2206 33
	shellName = commandShell->name;
	shellPath = Str_concat(_PATH_DEFSHELLDIR, shellName, '/');
    }

    if (commandShell->exit == NULL) {
	commandShell->exit = "";
    }
    if (commandShell->echo == NULL) {
	commandShell->echo = "";
    }

    /*
     * Catch the four signals that POSIX specifies if they aren't ignored.
     * JobPassSig will take care of calling JobInterrupt if appropriate.
     */
    if (signal(SIGINT, SIG_IGN) != SIG_IGN) {
	(void)signal(SIGINT, SigHandler);
    }
    if (signal(SIGHUP, SIG_IGN) != SIG_IGN) {
	(void)signal(SIGHUP, SigHandler);
    }
    if (signal(SIGQUIT, SIG_IGN) != SIG_IGN) {
	(void)signal(SIGQUIT, SigHandler);
    }
    if (signal(SIGTERM, SIG_IGN) != SIG_IGN) {
	(void)signal(SIGTERM, SigHandler);
    }
    /*
     * There are additional signals that need to be caught and passed if
     * either the export system wants to be told directly of signals or if
     * we're giving each job its own process group (since then it won't get
     * signals from the terminal driver as we own the terminal)
     */
d2208 12
a2219 12
    if (signal(SIGTSTP, SIG_IGN) != SIG_IGN) {
	(void)signal(SIGTSTP, SigHandler);
    }
    if (signal(SIGTTOU, SIG_IGN) != SIG_IGN) {
	(void)signal(SIGTTOU, SigHandler);
    }
    if (signal(SIGTTIN, SIG_IGN) != SIG_IGN) {
	(void)signal(SIGTTIN, SigHandler);
    }
    if (signal(SIGWINCH, SIG_IGN) != SIG_IGN) {
	(void)signal(SIGWINCH, SigHandler);
    }
d2222 1
a2222 1
    begin = Targ_FindNode(".BEGIN", TARG_NOCREATE);
d2224 6
a2229 5
    if (begin != NULL) {
	JobStart(begin, JOB_SPECIAL, (Job *)0);
	while (nJobs) {
	    Job_CatchOutput();
	    Job_CatchChildren(!usePipes);
d2231 1
a2231 2
    }
    postCommands = Targ_FindNode(".END", TARG_CREATE);
d2249 1
a2249 1
    return aborting || jobFull;
d2267 12
a2278 9
    if (nJobs == 0) {
	if (!Lst_IsEmpty(&stoppedJobs) && !aborting) {
	    /*
	     * The job table is obviously not full if it has no jobs in
	     * it...Try and restart the stopped jobs.
	     */
	    jobFull = false;
	    JobRestartJobs();
	    return false;
d2280 1
a2280 1
	    return true;
a2281 3
    } else {
	return false;
    }
d2297 1
a2297 1
    int     signo)		/* signal received */
d2299 25
a2323 25
    LstNode	  ln;		/* element in job table */
    Job 	  *job; 	/* job descriptor in that element */
    GNode	  *interrupt;	/* the node describing the .INTERRUPT target */

    aborting = ABORT_INTERRUPT;

    for (ln = Lst_First(&jobs); ln != NULL; ln = Lst_Adv(ln)) {
	job = (Job *)Lst_Datum(ln);

	if (!Targ_Precious(job->node)) {
	    const char	*file = job->node->path == NULL ?
				 job->node->name :
				 job->node->path;
	    if (!noExecute && eunlink(file) != -1) {
		Error("*** %s removed", file);
	    }
	}
	if (job->pid) {
	    if (DEBUG(JOB)) {
		(void)fprintf(stdout,
			       "JobInterrupt passing signal to child %ld.\n",
			       (long)job->pid);
		(void)fflush(stdout);
	    }
	    KILL(job->pid, signo);
a2324 1
    }
d2326 11
a2336 10
    if (runINTERRUPT && !touchFlag) {
	interrupt = Targ_FindNode(".INTERRUPT", TARG_NOCREATE);
	if (interrupt != NULL) {
	    ignoreErrors = false;

	    JobStart(interrupt, JOB_IGNDOTS, (Job *)0);
	    while (nJobs) {
		Job_CatchOutput();
		Job_CatchChildren(!usePipes);
	    }
d2338 2
a2339 3
    }
    (void)eunlink(tfile);
    exit(signo);
d2359 5
a2363 5
    if (postCommands != NULL && !Lst_IsEmpty(&postCommands->commands)) {
	if (errors) {
	    Error("Errors reported so .END ignored");
	} else {
	    JobStart(postCommands, JOB_SPECIAL | JOB_IGNDOTS, NULL);
d2365 5
a2369 4
	    while (nJobs) {
		Job_CatchOutput();
		Job_CatchChildren(!usePipes);
	    }
d2371 2
a2372 3
    }
    (void)eunlink(tfile);
    return errors;
d2388 1
a2388 1
    efree(shellArgv);
d2406 6
a2411 6
    aborting = ABORT_WAIT;
    while (nJobs != 0) {
	Job_CatchOutput();
	Job_CatchChildren(!usePipes);
    }
    aborting = 0;
d2428 3
a2430 3
    LstNode		ln;	/* element in job table */
    Job 		*job;	/* the job descriptor in that element */
    int 		foo;
d2432 1
a2432 1
    aborting = ABORT_ERROR;
d2434 11
a2444 10
    if (nJobs) {
	for (ln = Lst_First(&jobs); ln != NULL; ln = Lst_Adv(ln)) {
	    job = (Job *)Lst_Datum(ln);

	    /*
	     * kill the child process with increasingly drastic signals to make
	     * darn sure it's dead.
	     */
	    KILL(job->pid, SIGINT);
	    KILL(job->pid, SIGKILL);
a2445 1
    }
d2447 6
a2452 6
    /*
     * Catch as many children as want to report in at first, then give up
     */
    while (waitpid(-1, &foo, WNOHANG) > 0)
	continue;
    (void)eunlink(tfile);
d2469 1
a2469 1
    Job *job;
d2471 7
a2477 5
    while (!jobFull && (job = (Job *)Lst_DeQueue(&stoppedJobs)) != NULL) {
	if (DEBUG(JOB)) {
	    (void)fprintf(stdout,
		       "Job queue is not full. Restarting a stopped job.\n");
	    (void)fflush(stdout);
a2478 2
	JobRestart(job);
    }
@


1.64
log
@kill .SHELL, make doesn't even support it in non-parallel mode.
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.63 2007/09/16 10:39:07 espie Exp $	*/
a431 1
static Shell *JobMatchShell(char *);
@


1.63
log
@first step towards sanity: take the functions common to parallel/not parallel
make outside of make.c and job.c, and create an engine.c file to hold them.
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.62 2007/06/12 16:33:27 cnst Exp $	*/
a73 4
 *	Job_ParseShell		Given the line following a .SHELL target, parse
 *				the line as a shell specification. Returns
 *				false if the spec was incorrect.
 *
a84 5
 *	Job_CheckCommands	Verify that the commands for a target are
 *				ok. Provide them if necessary and possible.
 *
 *	Job_Touch		Update a target without really updating it.
 *
d347 1
a347 3
						   * commands in the Makefile.
						   * It is set by the
						   * Job_ParseShell function */
a2242 203
}

/*-
 *-----------------------------------------------------------------------
 * JobMatchShell --
 *	Find a matching shell in 'shells' given its final component.
 *
 * Results:
 *	A pointer to the Shell structure.
 *-----------------------------------------------------------------------
 */
static Shell *
JobMatchShell(char *name)     /* Final component of shell path */
{
    Shell	  *sh;	      /* Pointer into shells table */
    Shell	  *match;     /* Longest-matching shell */
    char	  *cp1,
		  *cp2;
    char	  *eoname;

    eoname = name + strlen(name);

    match = NULL;

    for (sh = shells; sh->name != NULL; sh++) {
	for (cp1 = eoname - strlen(sh->name), cp2 = sh->name;
	     *cp1 != '\0' && *cp1 == *cp2;
	     cp1++, cp2++) {
		 continue;
	}
	if (*cp1 != *cp2) {
	    continue;
	} else if (match == NULL || strlen(match->name) < strlen(sh->name)) {
	   match = sh;
	}
    }
    return match == NULL ? sh : match;
}

/*-
 *-----------------------------------------------------------------------
 * Job_ParseShell --
 *	Parse a shell specification and set up commandShell, shellPath
 *	and shellName appropriately.
 *
 * Results:
 *	false if the specification was incorrect.
 *
 * Side Effects:
 *	commandShell points to a Shell structure (either predefined or
 *	created from the shell spec), shellPath is the full path of the
 *	shell described by commandShell, while shellName is just the
 *	final component of shellPath.
 *
 * Notes:
 *	A shell specification consists of a .SHELL target, with dependency
 *	operator, followed by a series of blank-separated words. Double
 *	quotes can be used to use blanks in words. A backslash escapes
 *	anything (most notably a double-quote and a space) and
 *	provides the functionality it does in C. Each word consists of
 *	keyword and value separated by an equal sign. There should be no
 *	unnecessary spaces in the word. The keywords are as follows:
 *	    name	    Name of shell.
 *	    path	    Location of shell. Overrides "name" if given
 *	    quiet	    Command to turn off echoing.
 *	    echo	    Command to turn echoing on
 *	    filter	    Result of turning off echoing that shouldn't be
 *			    printed.
 *	    echoFlag	    Flag to turn echoing on at the start
 *	    errFlag	    Flag to turn error checking on at the start
 *	    hasErrCtl	    True if shell has error checking control
 *	    check	    Command to turn on error checking if hasErrCtl
 *			    is true or template of command to echo a command
 *			    for which error checking is off if hasErrCtl is
 *			    false.
 *	    ignore	    Command to turn off error checking if hasErrCtl
 *			    is true or template of command to execute a
 *			    command so as to ignore any errors it returns if
 *			    hasErrCtl is false.
 *-----------------------------------------------------------------------
 */
bool
Job_ParseShell(const char *line)	/* The shell spec */
{
    char	  **words;
    int 	  wordCount;
    char	  **argv;
    int 	  argc;
    char	  *path;
    Shell	  newShell;
    bool	  fullSpec = false;

    while (isspace(*line)) {
	line++;
    }

    efree(shellArgv);

    words = brk_string(line, &wordCount, &shellArgv);

    memset(&newShell, 0, sizeof(newShell));

    /*
     * Parse the specification by keyword
     */
    for (path = NULL, argc = wordCount - 1, argv = words;
	 argc != 0;
	 argc--, argv++) {
	     if (strncmp(*argv, "path=", 5) == 0) {
		 path = &argv[0][5];
	     } else if (strncmp(*argv, "name=", 5) == 0) {
		 newShell.name = &argv[0][5];
	     } else {
		 if (strncmp(*argv, "quiet=", 6) == 0) {
		     newShell.echoOff = &argv[0][6];
		 } else if (strncmp(*argv, "echo=", 5) == 0) {
		     newShell.echoOn = &argv[0][5];
		 } else if (strncmp(*argv, "filter=", 7) == 0) {
		     newShell.noPrint = &argv[0][7];
		     newShell.noPLen = strlen(newShell.noPrint);
		 } else if (strncmp(*argv, "echoFlag=", 9) == 0) {
		     newShell.echo = &argv[0][9];
		 } else if (strncmp(*argv, "errFlag=", 8) == 0) {
		     newShell.exit = &argv[0][8];
		 } else if (strncmp(*argv, "hasErrCtl=", 10) == 0) {
		     char c = argv[0][10];
		     newShell.hasErrCtl = !(c != 'Y' && c != 'y' &&
					   c != 'T' && c != 't');
		 } else if (strncmp(*argv, "check=", 6) == 0) {
		     newShell.errCheck = &argv[0][6];
		 } else if (strncmp(*argv, "ignore=", 7) == 0) {
		     newShell.ignErr = &argv[0][7];
		 } else {
		     Parse_Error(PARSE_FATAL, "Unknown keyword \"%s\"",
				  *argv);
		     free(words);
		     return false;
		 }
		 fullSpec = true;
	     }
    }

    if (path == NULL) {
	/*
	 * If no path was given, the user wants one of the pre-defined shells,
	 * yes? So we find the one s/he wants with the help of JobMatchShell
	 * and set things up the right way. shellPath will be set up by
	 * Job_Init.
	 */
	if (newShell.name == NULL) {
	    Parse_Error(PARSE_FATAL, "Neither path nor name specified");
	    return false;
	} else {
	    commandShell = JobMatchShell(newShell.name);
	    shellName = newShell.name;
	}
    } else {
	/*
	 * The user provided a path. If s/he gave nothing else (fullSpec is
	 * false), try and find a matching shell in the ones we know of.
	 * Else we just take the specification at its word and copy it
	 * to a new location. In either case, we need to record the
	 * path the user gave for the shell.
	 */
	shellPath = path;
	path = strrchr(path, '/');
	if (path == NULL) {
	    path = shellPath;
	} else {
	    path += 1;
	}
	if (newShell.name != NULL) {
	    shellName = newShell.name;
	} else {
	    shellName = path;
	}
	if (!fullSpec) {
	    commandShell = JobMatchShell(shellName);
	} else {
	    commandShell = emalloc(sizeof(Shell));
	    *commandShell = newShell;
	}
    }

    if (commandShell->echoOn && commandShell->echoOff) {
	commandShell->hasEchoCtl = true;
    }

    if (!commandShell->hasErrCtl) {
	if (commandShell->errCheck == NULL) {
	    commandShell->errCheck = "";
	}
	if (commandShell->ignErr == NULL) {
	    commandShell->ignErr = "%s\n";
	}
    }

    /*
     * Do not free up the words themselves, since they might be in use by the
     * shell specification...
     */
    free(words);
    return true;
@


1.62
log
@Fix a 10-year-old pointer-arithmetic bug in make,
introduced on 1997-12-16, make/job.c revision 1.8.

This should fix the CPU spinout bug when running make with a -j option --
from now on, `make -j24` successfully completes the kernel build on my
Core 2 Duo, instead of halting the build and eating one CPU until ^C.

Found and debugged by myself, with the help of malloc.conf options.

"definitely a bug, nice catch" beck@@
"let's also fix a [potential] memory leak in realloc" by millert@@
"should go in" deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.61 2007/03/02 04:32:32 ray Exp $	*/
a101 1
#include <limits.h>
a109 1
#include "dir.h"
d111 1
a112 1
#include "arch.h"
a115 1
#include "str.h"
d121 1
a121 2
#include "timestamp.h"
#include "main.h"
a1106 129
}

/*-
 *-----------------------------------------------------------------------
 * Job_Touch --
 *	Touch the given target. Called by JobStart when the -t flag was
 *	given
 *
 * Side Effects:
 *	The data modification of the file is changed. In addition, if the
 *	file did not exist, it is created.
 *-----------------------------------------------------------------------
 */
void
Job_Touch(GNode *gn,		/* the node of the file to touch */
    bool silent)		/* true if should not print messages */
{
    int 	  streamID;	/* ID of stream opened to do the touch */

    if (gn->type & (OP_JOIN|OP_USE|OP_EXEC|OP_OPTIONAL)) {
	/*
	 * .JOIN, .USE, .ZEROTIME and .OPTIONAL targets are "virtual" targets
	 * and, as such, shouldn't really be created.
	 */
	return;
    }

    if (!silent) {
	(void)fprintf(stdout, "touch %s\n", gn->name);
	(void)fflush(stdout);
    }

    if (noExecute) {
	return;
    }

    if (gn->type & OP_ARCHV) {
	Arch_Touch(gn);
    } else if (gn->type & OP_LIB) {
	Arch_TouchLib(gn);
    } else {
	const char *file = gn->path != NULL ? gn->path : gn->name;

	if (set_times(file) == -1){
	    streamID = open(file, O_RDWR | O_CREAT, 0666);

	    if (streamID >= 0) {
		char	c;

		/*
		 * Read and write a byte to the file to change the
		 * modification time, then close the file.
		 */
		if (read(streamID, &c, 1) == 1) {
		    (void)lseek(streamID, 0, SEEK_SET);
		    (void)write(streamID, &c, 1);
		}

		(void)close(streamID);
	    } else {
		(void)fprintf(stdout, "*** couldn't touch %s: %s",
			       file, strerror(errno));
		(void)fflush(stdout);
	    }
	}
    }
}

/*-
 *-----------------------------------------------------------------------
 * Job_CheckCommands --
 *	Make sure the given node has all the commands it needs.
 *
 * Results:
 *	true if the commands list is/was ok.
 *
 * Side Effects:
 *	The node will have commands from the .DEFAULT rule added to it
 *	if it needs them.
 *-----------------------------------------------------------------------
 */
bool
Job_CheckCommands(GNode *gn, 		/* The target whose commands need
				     	 * verifying */
    void (*abortProc)(char *, ...)) 	/* Function to abort with message */
{
    if (OP_NOP(gn->type) && Lst_IsEmpty(&gn->commands) &&
	(gn->type & OP_LIB) == 0) {
	/*
	 * No commands. Look for .DEFAULT rule from which we might infer
	 * commands
	 */
	if (DEFAULT != NULL && !Lst_IsEmpty(&DEFAULT->commands)) {
	    /*
	     * Make only looks for a .DEFAULT if the node was never the
	     * target of an operator, so that's what we do too. If
	     * a .DEFAULT was given, we substitute its commands for gn's
	     * commands and set the IMPSRC variable to be the target's name
	     * The DEFAULT node acts like a transformation rule, in that
	     * gn also inherits any attributes or sources attached to
	     * .DEFAULT itself.
	     */
	    Make_HandleUse(DEFAULT, gn);
	    Varq_Set(IMPSRC_INDEX, Varq_Value(TARGET_INDEX, gn), gn);
	} else if (is_out_of_date(Dir_MTime(gn))) {
	    /*
	     * The node wasn't the target of an operator we have no .DEFAULT
	     * rule to go on and the target doesn't already exist. There's
	     * nothing more we can do for this branch. If the -k flag wasn't
	     * given, we stop in our tracks, otherwise we just don't update
	     * this node's parents so they never get examined.
	     */
	    static const char msg[] = "make: don't know how to make";

	    if (gn->type & OP_OPTIONAL) {
		(void)fprintf(stdout, "%s %s(ignored)\n", msg, gn->name);
		(void)fflush(stdout);
	    } else if (keepgoing) {
		(void)fprintf(stdout, "%s %s(continuing)\n", msg, gn->name);
		(void)fflush(stdout);
		return false;
	    } else {
		(*abortProc)("%s %s. Stop in %s.", msg, gn->name,
			Var_Value(".CURDIR"));
		return false;
	    }
	}
    }
    return true;
@


1.61
log
@strlen fixes from Charles Longeau.

OK moritz@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.60 2007/01/04 17:55:35 espie Exp $	*/
d1352 2
a1353 2
		int bytes = howmany(job->inPipe+1, NFDBITS) * sizeof(fd_mask);
		int obytes = howmany(outputsn+1, NFDBITS) * sizeof(fd_mask);
d1355 7
a1361 3
		if (outputsp == NULL || obytes != bytes) {
			outputsp = realloc(outputsp, bytes);
			if (outputsp == NULL)
d1363 2
a1364 1
			memset(outputsp + obytes, 0, bytes - obytes);
@


1.60
log
@having a function that iterates through node's datum so that we retrieve
the list item with lst_member is non-sensical, create a new function
(Lst_ForEachNodeWhile) that iterates through lstnodes directly and use
it.

Less obfuscated, slightly more efficient...

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.59 2005/04/13 02:33:08 deraadt Exp $	*/
d2058 1
a2058 1
		if (endp[-1] == '\n') {
@


1.59
log
@use STD{IN,OUT,ERR}_FILENO
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.58 2004/11/29 06:20:03 jsg Exp $	*/
d437 1
a437 1
static int JobPrintCommand(void *, void *);
d675 1
a675 1
JobPrintCommand(void *cmdp,	    /* command string to print */
d689 1
a689 2
    LstNode	  cmdNode;	    /* Node for replacing the command */
    char	  *cmd = (char *)cmdp;
d697 1
a697 1
	    job->tailCmds = Lst_Succ(Lst_Member(&job->node->commands, cmd));
a713 1
    cmdNode = Lst_Member(&job->node->commands, cmd);
d1665 1
a1665 1
		!JobPrintCommand(Lst_Datum(gn->current), job)) {
d1688 1
a1688 1
	    Lst_Find(&gn->commands, JobPrintCommand, job);
d1714 1
a1714 1
	    Lst_Find(&gn->commands, JobPrintCommand, job);
@


1.58
log
@Spell precede correctly.
'looks fine' millert@@, krw@@. ok jmc@@
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.57 2004/07/19 02:10:47 espie Exp $	*/
d1339 1
a1339 1
	(void)write(2, "Could not execute shell\n",
@


1.57
log
@fix signal race in job.c: the signal handler only sets a flag, and
the main loop polls for that signal periodically.

Fixes make -j kernel.

okay art@@
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.56 2004/04/07 13:11:36 espie Exp $	*/
d1990 1
a1990 1
	     * to the shell description), we print the line, preceeded
@


1.56
log
@ISO function declarations, trim a few comments, rename a few variables to
more explicit/more consistent names.

okay otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.55 2003/06/03 02:56:11 millert Exp $	*/
d433 2
d451 79
a567 1
    int save_errno = errno;
d625 1
a625 1
    act.sa_handler = JobPassSig;
a626 1
    errno = save_errno;
d2116 1
d2188 1
d2192 1
d2292 1
a2292 1
	(void)signal(SIGINT, JobPassSig);
d2295 1
a2295 1
	(void)signal(SIGHUP, JobPassSig);
d2298 1
a2298 1
	(void)signal(SIGQUIT, JobPassSig);
d2301 1
a2301 1
	(void)signal(SIGTERM, JobPassSig);
d2311 1
a2311 1
	(void)signal(SIGTSTP, JobPassSig);
d2314 1
a2314 1
	(void)signal(SIGTTOU, JobPassSig);
d2317 1
a2317 1
	(void)signal(SIGTTIN, JobPassSig);
d2320 1
a2320 1
	(void)signal(SIGWINCH, JobPassSig);
@


1.55
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.54 2003/04/06 22:47:14 espie Exp $	*/
d460 2
a461 3
JobCondPassSig(jobp, signop)
    void		*jobp;		/* Job to biff */
    void		*signop;	/* Signal to send it */
d485 1
a485 2
JobPassSig(signo)
    int     signo;	/* The signal number we've received */
d562 2
a563 3
JobCmpPid(job, pid)
    void *job;	/* job to examine */
    void *pid;	/* process id desired */
d596 2
a597 3
JobPrintCommand(cmdp, jobp)
    void	*cmdp;		    /* command string to print */
    void	*jobp;		    /* job for which to print it */
d749 1
a749 3
JobSaveCommand(cmd, gn)
    void	*cmd;
    void	*gn;
d769 1
a769 2
JobClose(job)
    Job *job;
d806 2
a807 3
JobFinish(job, status)
    Job 	*job;		  /* job to finish */
    int 	*status;	  /* sub-why job went away */
d1048 2
a1049 3
Job_Touch(gn, silent)
    GNode	  *gn;		/* the node of the file to touch */
    bool	  silent;	/* true if should not print messages */
d1116 3
a1118 5
Job_CheckCommands(gn, abortProc)
    GNode	   *gn; 	    /* The target whose commands need
				     * verifying */
    void	 (*abortProc)(char *, ...);
			/* Function to abort with message */
d1177 1
a1177 3
JobExec(job, argv)
    Job 	  *job; 	/* Job to execute */
    char	  **argv;
d1316 1
a1316 3
JobMakeArgv(job, argv)
    Job 	  *job;
    char	  **argv;
d1366 1
a1366 2
JobRestart(job)
    Job 	  *job; 	/* Job to restart */
d1493 2
a1494 3
JobStart(gn, flags, previous)
    GNode	  *gn;	      /* target to create */
    int 	   flags;      /* flags for the job to override normal ones.
d1496 1
a1496 1
    Job 	  *previous;  /* The previous Job structure for this node,
d1762 1
a1762 4
JobOutput(job, cp, endp, msg)
    Job *job;
    char *cp, *endp;
    int msg;
d1829 2
a1830 3
JobDoOutput(job, finish)
    Job 	  *job;   /* the job whose output needs printing */
    bool	   finish;	  /* true if this is the last time we'll be
d2020 1
a2020 2
Job_CatchChildren(block)
    bool	  block;	/* true if should block on the wait. */
d2088 1
a2088 1
Job_CatchOutput()
d2134 1
a2134 2
Job_Make(gn)
    GNode   *gn;
d2149 1
a2149 2
Job_Init(maxproc, maxlocal)
    int 	  maxproc;  /* the greatest number of jobs which may be
d2151 1
a2151 1
    int 	  maxlocal; /* the greatest number of local jobs which may
d2267 1
a2267 1
Job_Full()
d2285 1
a2285 1
Job_Empty()
d2314 1
a2314 2
JobMatchShell(name)
    char	  *name;      /* Final component of shell path */
d2384 1
a2384 2
Job_ParseShell(line)
    char	  *line;  /* The shell spec */
d2518 1
a2518 2
JobInterrupt(runINTERRUPT, signo)
    int     runINTERRUPT;	/* Non-zero if commands for the .INTERRUPT
d2520 1
a2520 1
    int     signo;		/* signal received */
d2581 1
a2581 1
Job_Finish()
d2610 1
a2610 1
Job_End()
d2628 1
a2628 1
Job_Wait()
d2650 1
a2650 1
Job_AbortAll()
d2691 1
a2691 1
JobRestartJobs()
@


1.54
log
@get rid of some strcpy/sprintf.
ok krw@@, matthieu@@, deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.53 2003/02/18 13:14:43 jmc Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.53
log
@intial -> initial;

the great intial witch hunt, as prompted by tdeval@@

os-aix-dso.c: ok henning@@
ab.C: ok drahn@@
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.52 2002/07/31 19:29:20 mickey Exp $	*/
d1352 1
a1352 1
	(void)sprintf(args, "-%s%s",
d1734 1
a1734 1
	    (void)strcpy(job->outFile, TMPPAT);
d2185 1
a2185 1
    (void)strcpy(tfile, TMPPAT);
@


1.52
log
@use fork, not vfork. seems to fix misterious trapframe trashing on hppa; deraadt@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.51 2002/06/12 06:07:16 mpech Exp $	*/
d65 1
a65 1
 *	Job_Init		Called to intialize this module. in addition,
@


1.51
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.50 2002/03/19 00:08:31 espie Exp $	*/
d1222 1
a1222 1
    if ((cpid = vfork()) == -1) {
@


1.50
log
@Kill remote comments, un-expose private code.
ok millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.49 2002/03/02 13:42:51 espie Exp $	*/
d176 1
a176 1
    int 	pid;	    /* The child's process ID */
d472 2
a473 2
		       "JobCondPassSig passing signal %d to child %d.\n",
		       signo, job->pid);
d572 1
a572 1
    return *(int *)pid - ((Job *)job)->pid;
d883 1
a883 1
		(void)fprintf(stdout, "Process %d exited.\n", job->pid);
d907 1
a907 1
		(void)fprintf(stdout, "Process %d stopped.\n", job->pid);
d936 2
a937 2
				   "Warning: process %d was not continuing.\n",
				   job->pid);
d955 2
a956 2
			       "Process %d is continuing locally.\n",
			       job->pid);
d1196 1
a1196 1
    int 	  cpid; 	/* ID of new child */
d2048 1
a2048 1
    int 	  pid;		/* pid of dead child */
d2064 1
a2064 1
	    (void)fprintf(stdout, "Process %d exited or stopped.\n", pid);
d2075 1
a2075 1
		    Error("Resumed child (%d) not in table", pid);
d2081 1
a2081 1
		Error("Child (%d) not in table?", pid);
d2573 2
a2574 2
			       "JobInterrupt passing signal to child %d.\n",
			       job->pid);
d2705 1
a2705 1
    while (waitpid((pid_t) -1, &foo, WNOHANG) > 0)
@


1.49
log
@Kill JOB_REMIGRATE.
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.48 2002/03/02 00:23:13 espie Exp $	*/
d131 151
d397 2
a398 3
 * When JobStart attempts to run a job remotely but can't, and isn't allowed
 * to run the job locally, or when Job_CatchChildren detects a job that has
 * been migrated home, the job is placed on the stoppedJobs queue to be run
d456 1
a456 1
 *	Pass a signal to a job if the job is remote or if USE_PGRP
a469 4
    /*
     * Assume that sending the signal to job->pid will signal any remote
     * job as well.
     */
d482 2
a483 2
 *	Pass a signal on to all remote jobs and to all local jobs if
 *	USE_PGRP is defined, then die ourselves.
d1448 2
a1449 5
	     * If the job is remote, it's ok to resume it as long as the
	     * maximum concurrency won't be exceeded. If it's local and
	     * we haven't reached the local concurrency limit already (or the
	     * job must be run locally and maxLocal is 0), it's also ok to
	     * resume it.
@


1.48
log
@kill #ifdef REMOTE stuff that only obfuscates issues.
ok millert@@, miod@@
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.47 2001/11/17 19:37:46 deraadt Exp $	*/
d768 2
a769 4
	    if (!(job->flags & JOB_REMIGRATE)) {
		(void)fprintf(out, "*** Stopped -- signal %d\n",
		    WSTOPSIG(*status));
	    }
d780 1
a780 1
	    if (job->flags & (JOB_RESUME|JOB_REMIGRATE|JOB_RESTART)) {
d1242 1
a1242 47
    if (job->flags & JOB_REMIGRATE) {
	if (DEBUG(JOB)) {
	   (void)fprintf(stdout, "*** remigrating %x(%s)\n",
			   job->pid, job->node->name);
	   (void)fflush(stdout);
	}

	    if (nLocal != maxLocal) {
		/*
		 * Job cannot be remigrated, but there's room on the local
		 * machine, so resume the job and note that another
		 * local job has started.
		 */
		if (DEBUG(JOB)) {
		    (void)fprintf(stdout, "*** resuming on local machine\n");
		    (void)fflush(stdout);
		}
		KILL(job->pid, SIGCONT);
		nLocal +=1;
		job->flags &= ~(JOB_REMIGRATE|JOB_RESUME);
	} else {
		/*
		 * Job cannot be restarted. Mark the table as full and
		 * place the job back on the list of stopped jobs.
		 */
		if (DEBUG(JOB)) {
		   (void)fprintf(stdout, "*** holding\n");
		   (void)fflush(stdout);
		}
		Lst_AtFront(&stoppedJobs, job);
		jobFull = true;
		if (DEBUG(JOB)) {
		   (void)fprintf(stdout, "Job queue is full.\n");
		   (void)fflush(stdout);
		}
		return;
	    }
	Lst_AtEnd(&jobs, job);
	nJobs += 1;
	if (nJobs == maxJobs) {
	    jobFull = true;
	    if (DEBUG(JOB)) {
		(void)fprintf(stdout, "Job queue is full.\n");
		(void)fflush(stdout);
	    }
	}
    } else if (job->flags & JOB_RESTART) {
@


1.47
log
@errno saving
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.46 2001/11/11 12:35:02 espie Exp $	*/
a130 7
#ifdef REMOTE
#include "rmt.h"
# define STATIC
#else
# define STATIC static
#endif

d224 4
a227 4
STATIC int	nJobs = 0;	/* The number of children currently running */
STATIC int	nLocal; 	/* The number of local children */
STATIC LIST	jobs;		/* The structures that describe them */
STATIC bool	jobFull;	/* Flag to tell when the job table is full. It
a231 1
#ifndef RMT_WILL_WATCH
d235 1
a235 3
#endif

STATIC GNode	*lastNode;	/* The node for which output was most recently
d237 1
a237 1
STATIC char	*targFmt;	/* Format string to use to head output from a
a240 5
#ifdef REMOTE
# define TARG_FMT  "--- %s at %s ---\n" /* Default format */
# define MESSAGE(fp, gn) \
	(void)fprintf(fp, targFmt, gn->name, gn->rem.hname);
#else
a243 1
#endif
d251 1
a251 1
STATIC LIST	stoppedJobs;	/* Lst of Job structures describing
a291 6
#ifdef REMOTE
static int JobCmpRmtID(Job *, int);
# ifdef RMT_WILL_WATCH
static void JobLocalInput(int, Job *);
# endif
#else
a293 1
#endif
a319 7
#ifdef RMT_WANTS_SIGNALS
    if (job->flags & JOB_REMOTE) {
	(void)Rmt_Signal(job, signo);
    } else {
	KILL(job->pid, signo);
    }
#else
a330 1
#endif
a428 20
#ifdef REMOTE
/*-
 *-----------------------------------------------------------------------
 * JobCmpRmtID	--
 *	Compare the rmtID of the job with the given rmtID and return 0 if they
 *	are equal.
 *
 * Results:
 *	0 if the rmtID's match
 *-----------------------------------------------------------------------
 */
static int
JobCmpRmtID(job, rmtID)
    void	*job;	/* job to examine */
    void	*rmtID; /* remote id desired */
{
    return *(int *)rmtID - *(int *)job->rmtID;
}
#endif

a636 3
#ifdef RMT_WILL_WATCH
	Rmt_Ignore(job->inPipe);
#else
a637 1
#endif
a688 3
#ifdef REMOTE
	KILL(job->pid, SIGCONT);
#endif
a693 4
#ifdef REMOTE
	if (job->flags & JOB_REMOTE)
	    Rmt_Done(job->rmtID, job->node);
#endif
a709 4
#ifdef REMOTE
	if (job->flags & JOB_REMOTE)
	    Rmt_Done(job->rmtID, job->node);
#endif /* REMOTE */
a773 4
#ifdef REMOTE
	    if (job->flags & JOB_REMIGRATE)
		JobRestart(job);
#endif
d809 5
a813 8
	    if (!(job->flags & JOB_REMOTE)) {
		if (DEBUG(JOB)) {
		    (void)fprintf(stdout,
				   "Process %d is continuing locally.\n",
				   job->pid);
		    (void)fflush(stdout);
		}
		nLocal += 1;
d815 1
a1034 19
#ifdef RMT_WILL_WATCH
/*-
 *-----------------------------------------------------------------------
 * JobLocalInput --
 *	Handle a pipe becoming readable. Callback function for Rmt_Watch
 *
 * Side Effects:
 *	JobDoOutput is called.
 *-----------------------------------------------------------------------
 */
/*ARGSUSED*/
static void
JobLocalInput(stream, job)
    int     stream;	/* Stream that's ready (ignored) */
    Job     *job;	/* Job to which the stream belongs */
{
    JobDoOutput(job, false);
}
#endif /* RMT_WILL_WATCH */
d1057 1
a1057 2
	(void)fprintf(stdout, "Running %s %sly\n", job->node->name,
		       job->flags&JOB_REMOTE?"remote":"local");
a1077 6
#ifdef RMT_NO_EXEC
    if (job->flags & JOB_REMOTE) {
	goto jobExecFinish;
    }
#endif /* RMT_NO_EXEC */

a1130 5
#ifdef REMOTE
	if (job->flags & JOB_REMOTE) {
	    Rmt_Exec(shellPath, argv, false);
	} else
#endif /* REMOTE */
a1136 7
#ifdef REMOTE
	sigset_t mask, omask;

	sigemptyset(&mask);
	sigaddset(&mask, SIGCHLD);
	sigprocmask(SIG_BLOCK, &mask, &omask);
#endif
a1146 3
#ifdef RMT_WILL_WATCH
	    Rmt_Watch(job->inPipe, JobLocalInput, job);
#else
a1159 1
#endif /* RMT_WILL_WATCH */
d1162 7
a1168 15
	if (job->flags & JOB_REMOTE) {
#ifndef REMOTE
	    job->rmtID = 0;
#else
	    job->rmtID = Rmt_LastID(job->pid);
#endif /* REMOTE */
	} else {
	    nLocal += 1;
	    /*
	     * XXX: Used to not happen if REMOTE. Why?
	     */
	    if (job->cmdFILE != NULL && job->cmdFILE != stdout) {
		(void)fclose(job->cmdFILE);
		job->cmdFILE = NULL;
	    }
a1169 3
#ifdef REMOTE
	sigprocmask(SIG_SETMASK, &omask, NULL);
#endif
a1171 3
#ifdef RMT_NO_EXEC
jobExecFinish:
#endif
a1243 4
#ifdef REMOTE
    int host;
#endif

d1245 1
a1245 5
	if (
#ifdef REMOTE
	    verboseRemigrates ||
#endif
	    DEBUG(JOB)) {
a1250 7
#ifdef REMOTE
	if (!Rmt_ReExport(job->pid, job->node, &host)) {
	    if (verboseRemigrates || DEBUG(JOB)) {
		(void)fprintf(stdout, "*** couldn't migrate...\n");
		(void)fflush(stdout);
	    }
#endif
d1257 1
a1257 5
		if (
#ifdef REMOTE
		    verboseRemigrates ||
#endif
		    DEBUG(JOB)) {
a1262 4
#ifdef REMOTE
		job->flags &= ~(JOB_REMIGRATE|JOB_RESUME|JOB_REMOTE);
		job->flags |= JOB_CONTINUING;
#else
a1263 1
#endif
d1269 1
a1269 5
		if (
#ifdef REMOTE
		    verboseRemigrates ||
#endif
		    DEBUG(JOB)) {
a1280 13
#ifdef REMOTE
	} else {
	    /*
	     * Clear out the remigrate and resume flags. Set the continuing
	     * flag so we know later on that the process isn't exiting just
	     * because of a signal.
	     */
	    job->flags &= ~(JOB_REMIGRATE|JOB_RESUME);
	    job->flags |= JOB_CONTINUING;
	    job->rmtID = host;
	}
#endif

a1306 9
#ifdef REMOTE
	if ((job->node->type&OP_NOEXPORT) ||
	    (nLocal < maxLocal && runLocalFirst)
# ifdef RMT_NO_EXEC
	    || !Rmt_Export(shellPath, argv, job)
# else
	    || !Rmt_Begin(shellPath, argv, job->node)
# endif
#endif
a1331 11
		job->flags &= ~JOB_REMOTE;
	    }
	}
#ifdef REMOTE
	else {
	    /*
	     * Can be exported. Hooray!
	     */
	    if (DEBUG(JOB)) {
		(void)fprintf(stdout, "exporting\n");
		(void)fflush(stdout);
a1332 1
	    job->flags |= JOB_REMOTE;
a1333 1
#endif
d1344 1
a1344 3
	if (((job->flags & JOB_REMOTE) ||
	    nLocal < maxLocal ||
#ifdef REMOTE
a1345 1
	      (job->node->type & OP_NOEXPORT) &&
a1346 4
#else
	    ((job->flags & JOB_SPECIAL) &&
	     maxLocal == 0)
#endif
a1358 5
#ifdef RMT_WANTS_SIGNALS
	    if (job->flags & JOB_REMOTE) {
		error = !Rmt_Signal(job, SIGCONT);
	    } else
#endif	/* RMT_WANTS_SIGNALS */
d1432 1
a1432 1
	previous->flags &= ~(JOB_FIRST|JOB_IGNERR|JOB_SILENT|JOB_REMOTE);
a1645 12
#ifdef REMOTE
    if (!(gn->type & OP_NOEXPORT) && !(runLocalFirst && nLocal < maxLocal)) {
#ifdef RMT_NO_EXEC
	local = !Rmt_Export(shellPath, argv, job);
#else
	local = !Rmt_Begin(shellPath, argv, job->node);
#endif /* RMT_NO_EXEC */
	if (!local) {
	    job->flags |= JOB_REMOTE;
	}
    } else
#endif
a1649 3
#ifdef REMOTE
	(!(gn->type & OP_NOEXPORT) || maxLocal != 0)
#else
a1650 1
#endif
d1757 1
a1757 1
STATIC void
a1997 10
#ifdef REMOTE
	    if (!(job->flags & JOB_REMOTE)) {
		if (DEBUG(JOB)) {
		    (void)fprintf(stdout,
				   "Job queue has one fewer local process.\n");
		    (void)fflush(stdout);
		}
		nLocal -= 1;
	    }
#else
a1998 1
#endif
a2024 3
#ifdef RMT_WILL_WATCH
    int 		  pnJobs;	/* Previous nJobs */
#endif
a2026 23
#ifdef RMT_WILL_WATCH
    pnJobs = nJobs;

    /*
     * It is possible for us to be called with nJobs equal to 0. This happens
     * if all the jobs finish and a job that is stopped cannot be run
     * locally (eg if maxLocal is 0) and cannot be exported. The job will
     * be placed back on the stoppedJobs queue, Job_Empty() will return false,
     * Make_Run will call us again when there's nothing for which to wait.
     * nJobs never changes, so we loop forever. Hence the check. It could
     * be argued that we should sleep for a bit so as not to swamp the
     * exportation system with requests. Perhaps we should.
     *
     * NOTE: IT IS THE RESPONSIBILITY OF Rmt_Wait TO CALL Job_CatchChildren
     * IN A TIMELY FASHION TO CATCH ANY LOCALLY RUNNING JOBS THAT EXIT.
     * It may use the variable nLocal to determine if it needs to call
     * Job_CatchChildren (if nLocal is 0, there's nothing for which to
     * wait...)
     */
    while (nJobs != 0 && pnJobs == nJobs) {
	Rmt_Wait();
    }
#else
a2051 1
#endif /* RMT_WILL_WATCH */
d2109 1
a2109 5
    if (maxJobs == 1
#ifdef REMOTE
	|| noMessages
#endif
		     ) {
d2160 1
a2160 1
#if defined(RMT_WANTS_SIGNALS) || defined(USE_PGRP)
a2180 1
#ifndef RMT_WILL_WATCH
a2181 1
#endif /* RMT_WILL_WATCH */
a2474 20
#ifdef RMT_WANTS_SIGNALS
	if (job->flags & JOB_REMOTE) {
	    /*
	     * If job is remote, let the Rmt module do the killing.
	     */
	    if (!Rmt_Signal(job, signo)) {
		/*
		 * If couldn't kill the thing, finish it out now with an
		 * error code, since no exit report will come in likely.
		 */
		int status;

		status.w_status = 0;
		status.w_retcode = 1;
		JobFinish(job, &status);
	    }
	} else if (job->pid) {
	    KILL(job->pid, signo);
	}
#else
a2483 59
#endif /* RMT_WANTS_SIGNALS */
    }

#ifdef REMOTE
    for (ln = Lst_First(&stoppedJobs); ln != NULL; ln = Lst_Adv(ln)) {
	job = (Job *)Lst_Datum(ln);

	if (job->flags & JOB_RESTART) {
	    if (DEBUG(JOB)) {
		(void)fprintf(stdout, "%s%s",
			       "JobInterrupt skipping job on stopped queue",
			       "-- it was waiting to be restarted.\n");
		(void)fflush(stdout);
	    }
	    continue;
	}
	if (!Targ_Precious(job->node)) {
	    char	*file = job->node->path == NULL ?
				 job->node->name :
				 job->node->path;
	    if (eunlink(file) == 0) {
		Error("*** %s removed", file);
	    }
	}
	/*
	 * Resume the thing so it will take the signal.
	 */
	if (DEBUG(JOB)) {
	    (void)fprintf(stdout,
			   "JobInterrupt passing CONT to stopped child %d.\n",
			   job->pid);
	    (void)fflush(stdout);
	}
	KILL(job->pid, SIGCONT);
#ifdef RMT_WANTS_SIGNALS
	if (job->flags & JOB_REMOTE) {
	    /*
	     * If job is remote, let the Rmt module do the killing.
	     */
	    if (!Rmt_Signal(job, SIGINT)) {
		/*
		 * If couldn't kill the thing, finish it out now with an
		 * error code, since no exit report will come in likely.
		 */
		int status;
		status.w_status = 0;
		status.w_retcode = 1;
		JobFinish(job, &status);
	    }
	} else if (job->pid) {
	    if (DEBUG(JOB)) {
		(void)fprintf(stdout,
		       "JobInterrupt passing interrupt to stopped child %d.\n",
			       job->pid);
		(void)fflush(stdout);
	    }
	    KILL(job->pid, SIGINT);
	}
#endif /* RMT_WANTS_SIGNALS */
a2484 1
#endif
a2493 1
#ifndef RMT_WILL_WATCH
a2494 1
#endif /* RMT_WILL_WATCH */
a2526 1
#ifndef RMT_WILL_WATCH
a2527 1
#endif /* RMT_WILL_WATCH */
a2568 1
#ifndef RMT_WILL_WATCH
a2569 1
#endif /* RMT_WILL_WATCH */
a2601 9
#ifdef RMT_WANTS_SIGNALS
	    if (job->flags & JOB_REMOTE) {
		Rmt_Signal(job, SIGINT);
		Rmt_Signal(job, SIGKILL);
	    } else {
		KILL(job->pid, SIGINT);
		KILL(job->pid, SIGKILL);
	    }
#else
a2603 1
#endif /* RMT_WANTS_SIGNALS */
a2613 49

#ifdef REMOTE
/*-
 *-----------------------------------------------------------------------
 * JobFlagForMigration --
 *	Handle the eviction of a child. Called from RmtStatusChange.
 *	Flags the child as remigratable and then suspends it.
 *
 * Side Effects:
 *	The job descriptor is flagged for remigration.
 *-----------------------------------------------------------------------
 */
void
JobFlagForMigration(hostID)
    int 	  hostID;	/* ID of host we used, for matching children. */
{
    Job 	  *job; 	/* job descriptor for dead child */
    LstNode	  jnode;	/* list element for finding job */

    if (DEBUG(JOB)) {
	(void)fprintf(stdout, "JobFlagForMigration(%d) called.\n", hostID);
	(void)fflush(stdout);
    }
    jnode = Lst_Find(&jobs, JobCmpRmtID, &hostID);

    if (jnode == NULL) {
	jnode = Lst_Find(&stoppedJobs, JobCmpRmtID, &hostID);
		if (jnode == NULL) {
		    if (DEBUG(JOB)) {
			Error("Evicting host(%d) not in table", hostID);
		    }
		    return;
		}
    }
    job = (Job *)Lst_Datum(jnode);

    if (DEBUG(JOB)) {
	(void)fprintf(stdout,
		       "JobFlagForMigration(%d) found job '%s'.\n", hostID,
		       job->node->name);
	(void)fflush(stdout);
    }

    KILL(job->pid, SIGSTOP);

    job->flags |= JOB_REMIGRATE;
}

#endif
@


1.46
log
@Fixed version... don't see how this could work on i386, since it didn't
initialize create in main.c.
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.45 2001/11/11 06:02:06 deraadt Exp $	*/
d378 1
d438 1
@


1.45
log
@undo changes that crash on (at least) the alpha
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.43 2001/09/04 23:35:58 millert Exp $	*/
d2351 2
a2352 2
    Lst_Init(&jobs);
    Lst_Init(&stoppedJobs);
@


1.44
log
@Redo LstInit as a macro: smaller and faster code in all cases, zeroing two
pointers is simpler than calling a function.
Recognize purely static lst headers, which don't really need any
initialization.
ok miod@@
@
text
@d2351 2
a2352 2
    Static_Lst_Init(&jobs);
    Static_Lst_Init(&stoppedJobs);
@


1.43
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.42 2001/05/29 12:53:40 espie Exp $	*/
d2351 2
a2352 2
    Lst_Init(&jobs);
    Lst_Init(&stoppedJobs);
@


1.42
log
@Take includes out of lst.h, re-add what's needed to separate files.
Removes remaining lint stuff from lst.lib.
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.41 2001/05/23 12:34:44 espie Exp $	*/
d1239 5
a1243 1
	int omask = sigblock(sigmask(SIGCHLD));
d1291 1
a1291 1
	(void)sigsetmask(omask);
@


1.41
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d2 1
a2 1
/*	$OpenBSD: job.c,v 1.39 2000/12/27 19:07:58 espie Exp $	*/
d106 1
d110 1
@


1.40
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d55 1
a55 1
 *				Its single argument is TRUE if the function
d73 1
a73 1
 *	Job_Full		Return TRUE if the job table is filled.
d75 1
a75 1
 *	Job_Empty		Return TRUE if the job table is completely
d80 1
a80 1
 *				FAILURE if the spec was incorrect.
a101 3
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/time.h>
d103 2
d106 1
a106 2
#include <errno.h>
#include <utime.h>
d110 3
a112 3
#include <signal.h>
#include "make.h"
#include "ohash.h"
d116 13
a135 10
#ifndef lint
#if 0
static char sccsid[] = "@@(#)job.c	8.2 (Berkeley) 3/19/94";
#else
UNUSED
static char rcsid[] = "$OpenBSD: job.c,v 1.13 1999/10/05 22:06:24 espie Exp $";
#endif
#endif /* not lint */


d189 2
a190 2
    TRUE, "unset verbose", "set verbose", "unset verbose", 10,
    FALSE, "echo \"%s\"\n", "csh -c \"%s || exit 0\"",
d199 2
a200 2
    TRUE, "set -", "set -v", "set -", 5,
    TRUE, "set -e", "set +e",
d202 1
a202 1
    FALSE, "echo \"%s\"\n", "sh -c '%s || exit 0'\n",
d211 2
a212 2
    FALSE, (char *)0, (char *)0, (char *)0, 0,
    FALSE, (char *)0, (char *)0,
d229 1
a229 1
STATIC int	nJobs;		/* The number of children currently running */
d232 2
a233 2
STATIC Boolean	jobFull;	/* Flag to tell when the job table is full. It
				 * is set TRUE when (1) the total number of
d319 1
a319 1
static void JobDoOutput(Job *, Boolean);
d391 1
a391 1
	JobInterrupt(TRUE, signo);
d393 1
a393 1
	JobInterrupt(FALSE, signo);
d508 1
a508 1
    Boolean	  noSpecials;	    /* true if we shouldn't worry about
d511 1
a511 1
    Boolean	  shutUp = FALSE;   /* true if we put a no echo command
d513 1
a513 1
    Boolean	  errOff = FALSE;   /* true if we turned error checking
d546 1
a546 1
    cmdStart = cmd = Var_Subst(cmd, &job->node->context, FALSE);
d556 1
a556 1
	    shutUp = DEBUG(LOUD) ? FALSE : TRUE;
d558 1
a558 1
	    errOff = TRUE;
d571 1
a571 1
	    shutUp = FALSE;
d610 1
a610 1
			shutUp = TRUE;
d618 1
a618 1
		errOff = FALSE;
d620 1
a620 1
		errOff = FALSE;
d623 1
a623 1
	    errOff = FALSE;
d637 1
a637 1
	    shutUp = TRUE;
d665 1
a665 1
    result = Var_Subst((char *)cmd, &g->context, FALSE);
d692 1
a692 1
	JobDoOutput(job, TRUE);
d696 1
a696 1
	JobDoOutput(job, TRUE);
d726 1
a726 1
    Boolean	 done;
d747 1
a747 1
	done = TRUE;
d757 1
a757 1
	 * TRUE if in -B mode and the job exited non-zero.
d776 1
a776 1
	done = FALSE;
d885 1
a885 1
		jobFull = TRUE;
d912 1
a912 1
	    done = FALSE;
d915 1
a915 1
	    done = TRUE;
d926 1
a926 1
	    done = FALSE;
d930 1
a930 1
	done = TRUE;
d986 1
a986 1
    Boolean	  silent;	/* TRUE if should not print messages */
d1045 1
a1045 1
 *	TRUE if the commands list is/was ok.
d1052 1
a1052 1
Boolean
d1093 1
a1093 1
		return FALSE;
d1097 1
a1097 1
		return FALSE;
d1101 1
a1101 1
    return TRUE;
d1119 1
a1119 1
    JobDoOutput(job, FALSE);
d1227 1
a1227 1
	    Rmt_Exec(shellPath, argv, FALSE);
d1298 1
a1298 1
	jobFull = TRUE;
d1422 1
a1422 1
		jobFull = TRUE;
d1445 1
a1445 1
	    jobFull = TRUE;
d1488 1
a1488 1
		jobFull = TRUE;
d1546 1
a1546 1
	    Boolean error;
d1587 1
a1587 1
	    jobFull = TRUE;
d1622 3
a1624 3
    Boolean	  cmdsOK;     /* true if the nodes commands were all right */
    Boolean	  local;      /* Set true if the job was run locally */
    Boolean	  noExec;     /* Set true if we decide not to run the job */
d1661 1
a1661 1
	cmdsOK = TRUE;
d1688 1
a1688 1
	noExec = FALSE;
d1710 1
a1710 1
		noExec = TRUE;
d1739 1
a1739 1
		noExec = TRUE;
d1763 1
a1763 1
	noExec = TRUE;
d1773 1
a1773 1
	noExec = TRUE;
d1853 1
a1853 1
	local = TRUE;
d1873 1
a1873 1
	jobFull = TRUE;
d1887 1
a1887 1
	    jobFull = TRUE;
d1971 1
a1971 1
    Boolean	   finish;	  /* TRUE if this is the last time we'll be
d1974 2
a1975 2
    Boolean	  gotNL = FALSE;  /* true if got a newline */
    Boolean	  fbuf; 	  /* true if our buffer filled up */
d1990 2
a1991 2
	gotNL = FALSE;
	fbuf = FALSE;
d2013 1
a2013 1
	    finish = FALSE;
d2015 1
a2015 1
	    finish = FALSE;
d2021 1
a2021 1
	 * TRUE.
d2026 1
a2026 1
		gotNL = TRUE;
d2043 1
a2043 1
		fbuf = TRUE;
d2062 1
a2062 1
		cp = JobOutput(job, job->outBuf, &job->outBuf[i], FALSE);
d2097 1
a2097 1
	     * we do get an EOF, finish will be set FALSE and we'll fall
d2125 1
a2125 1
		cp = JobOutput(job, inLine, endp, FALSE);
d2162 1
a2162 1
    Boolean	  block;	/* TRUE if should block on the wait. */
d2208 1
a2208 1
	    jobFull = FALSE;
d2293 1
a2293 1
		    JobDoOutput(job, FALSE);
d2351 1
a2351 1
    jobFull =	  FALSE;
d2381 1
a2381 1
	shellPath = str_concat(_PATH_DEFSHELLDIR, shellName, '/');
d2428 1
a2428 1
    begin = Targ_FindNode(".BEGIN", NULL, TARG_NOCREATE);
d2439 1
a2439 1
    postCommands = Targ_FindNode(".END", NULL, TARG_CREATE);
d2451 1
a2451 1
 *	TRUE if the job table is full, FALSE otherwise
d2454 1
a2454 1
Boolean
d2469 1
a2469 1
 *	TRUE if it is. FALSE if it ain't.
d2472 1
a2472 1
Boolean
d2481 1
a2481 1
	    jobFull = FALSE;
d2483 1
a2483 1
	    return FALSE;
d2485 1
a2485 1
	    return TRUE;
d2488 1
a2488 1
	return FALSE;
d2537 1
a2537 1
 *	FAILURE if the specification was incorrect.
d2563 1
a2563 1
 *			    is TRUE or template of command to echo a command
d2565 1
a2565 1
 *			    FALSE.
d2567 1
a2567 1
 *			    is TRUE or template of command to execute a
d2569 1
a2569 1
 *			    hasErrCtl is FALSE.
d2572 1
a2572 1
ReturnStatus
d2582 1
a2582 1
    Boolean	  fullSpec = FALSE;
d2628 1
a2628 1
		     return FAILURE;
d2630 1
a2630 1
		 fullSpec = TRUE;
d2643 1
a2643 1
	    return FAILURE;
d2651 1
a2651 1
	 * FALSE), try and find a matching shell in the ones we know of.
d2677 1
a2677 1
	commandShell->hasEchoCtl = TRUE;
d2694 1
a2694 1
    return SUCCESS;
d2822 1
a2822 1
	interrupt = Targ_FindNode(".INTERRUPT", NULL, TARG_NOCREATE);
d2824 1
a2824 1
	    ignoreErrors = FALSE;
d2883 1
a2886 1
#ifdef CLEANUP
d2888 1
a2889 1
}
@


1.39
log
@Show CURDIR in that failure case too. Can't show a Makefile name yet
though...

Ok'ed miod@@.
@
text
@d1 2
a2 1
/*	$OpenBSD: job.c,v 1.38 2000/11/24 14:36:34 espie Exp $	*/
d48 1
a48 1
 *	Job_Make  	    	Start the creation of the given target.
d50 42
a91 42
 *	Job_CatchChildren   	Check for and handle the termination of any
 *	    	  	    	children. This must be called reasonably
 *	    	  	    	frequently to keep the whole make going at
 *	    	  	    	a decent clip, since job table entries aren't
 *	    	  	    	removed until their process is caught this way.
 *	    	  	    	Its single argument is TRUE if the function
 *	    	  	    	should block waiting for a child to terminate.
 *
 *	Job_CatchOutput	    	Print any output our children have produced.
 *	    	  	    	Should also be called fairly frequently to
 *	    	  	    	keep the user informed of what's going on.
 *	    	  	    	If no output is waiting, it will block for
 *	    	  	    	a time given by the SEL_* constants, below,
 *	    	  	    	or until output is ready.
 *
 *	Job_Init  	    	Called to intialize this module. in addition,
 *	    	  	    	any commands attached to the .BEGIN target
 *	    	  	    	are executed before this function returns.
 *	    	  	    	Hence, the makefile must have been parsed
 *	    	  	    	before this function is called.
 *
 *	Job_End  	    	Cleanup any memory used.
 *
 *	Job_Full  	    	Return TRUE if the job table is filled.
 *
 *	Job_Empty 	    	Return TRUE if the job table is completely
 *	    	  	    	empty.
 *
 *	Job_ParseShell	    	Given the line following a .SHELL target, parse
 *	    	  	    	the line as a shell specification. Returns
 *	    	  	    	FAILURE if the spec was incorrect.
 *
 *	Job_Finish  	    	Perform any final processing which needs doing.
 *	    	  	    	This includes the execution of any commands
 *	    	  	    	which have been/were attached to the .END
 *	    	  	    	target. It should only be called when the
 *	    	  	    	job table is empty.
 *
 *	Job_AbortAll	    	Abort all currently running jobs. It doesn't
 *	    	  	    	handle output or do anything for the jobs,
 *	    	  	    	just kills them. It should only be called in
 *	    	  	    	an emergency, as it were.
d93 2
a94 2
 *	Job_CheckCommands   	Verify that the commands for a target are
 *	    	  	    	ok. Provide them if necessary and possible.
d96 1
a96 1
 *	Job_Touch 	    	Update a target without really updating it.
d98 1
a98 1
 *	Job_Wait  	    	Wait for all currently-running jobs to finish.
d130 1
a130 1
static char rcsid[] = "$OpenBSD: job.c,v 1.38 2000/11/24 14:36:34 espie Exp $";
d134 1
d138 5
a142 5
static int     	errors = 0;	    /* number of errors reported */
static int    	aborting = 0;	    /* why is the make aborting? */
#define ABORT_ERROR	1   	    /* Because of an error */
#define ABORT_INTERRUPT	2   	    /* Because it was interrupted */
#define ABORT_WAIT	3   	    /* Waiting for jobs to finish */
d155 1
a155 1
static GNode   	  *postCommands;    /* node containing commands to execute when
d157 1
a157 1
static int     	  numCommands; 	    /* The number of commands actually printed
d164 4
a167 4
#define JOB_RUNNING	0   	/* Job is running */
#define JOB_ERROR 	1   	/* Error in starting the job */
#define JOB_FINISHED	2   	/* The job is already finished */
#define JOB_STOPPED	3   	/* The job is stopped */
d170 3
a172 2
 * tfile is used to build temp file names to store shell commands to
 * execute. 
d174 1
a174 1
static char     tfile[sizeof(TMPPAT)];
d180 1
a180 1
static Shell    shells[] = {
d209 4
a212 4
    (char *) 0,
    FALSE, (char *) 0, (char *) 0, (char *) 0, 0,
    FALSE, (char *) 0, (char *) 0,
    (char *) 0, (char *) 0,
d215 1
a215 1
static Shell 	*commandShell = &shells[DEFSHELL];/* this is the shell to
d220 1
a220 1
static char   	*shellPath = NULL,		  /* full pathname of
d222 1
a222 1
               	*shellName = NULL,     	      	  /* last component of shell */
d226 6
a231 6
static int  	maxJobs;    	/* The most children we can run at once */
static int  	maxLocal;    	/* The most local ones we can have */
STATIC int     	nJobs;	    	/* The number of children currently running */
STATIC int	nLocal;    	/* The number of local children */
STATIC LIST    	jobs;		/* The structures that describe them */
STATIC Boolean	jobFull;    	/* Flag to tell when the job table is full. It
d237 1
a237 1
static fd_set  	*outputsp;    	/* Set of descriptors of pipes connected to
d242 1
a242 1
STATIC GNode   	*lastNode;	/* The node for which output was most recently
d244 1
a244 1
STATIC char    	*targFmt;   	/* Format string to use to head output from a
d251 1
a251 1
	(void) fprintf(fp, targFmt, gn->name, gn->rem.hname);
d255 1
a255 1
	(void) fprintf(fp, targFmt, gn->name);
d270 1
a270 1
# define KILL(pid, sig)		killpg(-(pid), (sig))
d299 6
a304 6
static void JobCondPassSig __P((void *, void *));
static void JobPassSig __P((int));
static int JobCmpPid __P((void *, void *));
static int JobPrintCommand __P((void *, void *));
static void JobSaveCommand __P((void *, void *));
static void JobClose __P((Job *));
d306 1
a306 1
static int JobCmpRmtID __P((Job *, void *));
d308 1
a308 1
static void JobLocalInput __P((int, Job *));
d311 2
a312 2
static void JobFinish __P((Job *, int *));
static void JobExec __P((Job *, char **));
d314 8
a321 8
static void JobMakeArgv __P((Job *, char **));
static void JobRestart __P((Job *));
static int JobStart __P((GNode *, int, Job *));
static char *JobOutput __P((Job *, char *, char *, int));
static void JobDoOutput __P((Job *, Boolean));
static Shell *JobMatchShell __P((char *));
static void JobInterrupt __P((int, int));
static void JobRestartJobs __P((void));
a330 1
 *
d335 2
a336 2
    void *jobp;	    	/* Job to biff */
    void *signop;	/* Signal to send it */
d338 2
a339 2
    Job	*job = (Job *) jobp;
    int	signo = *(int *) signop;
d342 1
a342 1
	(void) Rmt_Signal(job, signo);
d352 1
a352 1
	(void) fprintf(stdout,
d355 1
a355 1
	(void) fflush(stdout);
a366 3
 * Results:
 *	None.
 *
a368 1
 *
d373 1
a373 1
    int	    signo;	/* The signal number we've received */
d379 2
a380 2
	(void) fprintf(stdout, "JobPassSig(%d) called.\n", signo);
	(void) fflush(stdout);
d391 1
a391 1
    } else if ((signo == SIGHUP) || (signo == SIGTERM) || (signo == SIGQUIT)) {
d418 1
a418 1
	(void) fprintf(stdout,
d421 1
a421 1
	(void) fflush(stdout);
d423 1
a423 1
    (void) signal(signo, SIG_DFL);
d425 1
a425 1
    (void) KILL(getpid(), signo);
d430 1
a430 1
    (void) sigprocmask(SIG_SETMASK, &omask, NULL);
a444 3
 *
 * Side Effects:
 *	None
d458 1
a458 1
 * JobCmpRmtID  --
a463 3
 *
 * Side Effects:
 *	None.
d468 2
a469 2
    void *job;	/* job to examine */
    void *rmtID;	/* remote id desired */
d471 1
a471 1
    return *(int *) rmtID - *(int *) job->rmtID;
d489 1
a489 1
 *	This function is called from JobStart via Lst_ForEach.
d504 2
a505 2
    void *cmdp;	    	    /* command string to print */
    void *jobp;	    	    /* job for which to print it */
d510 1
a510 1
    Boolean       shutUp = FALSE;   /* true if we put a no echo command
d515 1
a515 1
    char       	  *cmdTemplate;	    /* Template to use when printing the
d517 4
a520 4
    char    	  *cmdStart;	    /* Start of expanded command */
    LstNode 	  cmdNode;  	    /* Node for replacing the command */
    char     	  *cmd = (char *) cmdp;
    Job           *job = (Job *) jobp;
d534 2
a535 2
	(void) fprintf(stdout, fmt, arg); 	\
	(void) fflush(stdout); 			\
d537 2
a538 2
   (void) fprintf(job->cmdFILE, fmt, arg);	\
   (void) fflush(job->cmdFILE);
d542 2
a543 4
    /*
     * For debugging, we replace each command with the result of expanding
     * the variables in the command.
     */
d554 2
a555 2
    	if (*cmd == '@@')
	    shutUp = TRUE;
d562 1
a562 1
    while (isspace((unsigned char) *cmd))
a653 1
 *
d658 2
a659 2
    void *cmd;
    void *gn;
d661 2
a662 1
    char *result;
d664 1
a664 1
    result = Var_Subst((char *)cmd, &((GNode *)gn)->context, FALSE);
a673 3
 * Results:
 *	Nada
 *
a675 1
 *
d689 1
a689 1
	   (void) close(job->outPipe);
d692 1
a692 1
	(void) close(job->inPipe);
d694 1
a694 1
	(void) close(job->outFd);
a708 3
 * Results:
 *	None
 *
d722 2
a723 2
    Job         *job;	      	  /* job to finish */
    int	  	*status;     	  /* sub-why job went away */
d725 1
a725 1
    Boolean 	 done;
d728 2
a729 2
	 (((WEXITSTATUS(*status) != 0) && !(job->flags & JOB_IGNERR)))) ||
	(WIFSIGNALED(*status) && (WTERMSIG(*status) != SIGCONT)))
d744 1
a744 1
	   (void) fclose(job->cmdFILE);
d780 1
a780 1
	(WIFSIGNALED(*status) && (WTERMSIG(*status) == SIGCONT)) ||
d798 2
a799 2
		(void) fprintf(stdout, "Process %d exited.\n", job->pid);
		(void) fflush(stdout);
d806 1
a806 1
		(void) fprintf(out, "*** Error code %d%s\n",
d818 1
a818 1
		(void) fprintf(out, "*** Completed successfully\n");
d822 2
a823 2
		(void) fprintf(stdout, "Process %d stopped.\n", job->pid);
		(void) fflush(stdout);
d830 1
a830 1
		(void) fprintf(out, "*** Stopped -- signal %d\n",
d839 1
a839 1
	    (void) fflush(out);
d852 1
a852 1
		(void) fprintf(out, "*** Continued\n");
d856 1
a856 1
		    (void) fprintf(stdout,
d859 1
a859 1
		    (void) fflush(stdout);
d865 1
a865 1
		 * continuing process!  That's why this is ifdef'ed out.
d872 1
a872 1
 	    Lst_AtEnd(&jobs, job);
d876 1
a876 1
		    (void) fprintf(stdout,
d879 2
a880 2
		    (void) fflush(stdout);
  		}
d886 6
a891 6
		    (void) fprintf(stdout, "Job queue is full.\n");
		    (void) fflush(stdout);
  		}
  	    }
	    (void) fflush(out);
  	    return;
d897 1
a897 1
	    (void) fprintf(out, "*** Signal %d\n", WTERMSIG(*status));
d900 1
a900 1
	(void) fflush(out);
d908 1
a908 2
    if (compatMake && (WIFEXITED(*status) &&
	!Lst_IsAtEnd(&job->node->commands))) {
d928 1
a928 1
    } else {
a929 2
    }

d932 4
a935 6
	(aborting != ABORT_ERROR) &&
	(aborting != ABORT_INTERRUPT) &&
	(*status == 0))
    {
	/*
	 * As long as we aren't aborting and the job didn't return a non-zero
d938 1
a938 2
	 * on the .END target.
	 */
d953 1
a953 1
    if (errors && !keepgoing && (aborting != ABORT_INTERRUPT)) {
d962 1
a962 1
    if ((aborting == ABORT_ERROR) && Job_Empty())
d966 1
d968 1
a976 3
 * Results:
 *	None
 *
d984 2
a985 2
    GNode         *gn;	      	/* the node of the file to touch */
    Boolean 	  silent;   	/* TRUE if should not print messages */
d987 1
a987 1
    int		  streamID;   	/* ID of stream opened to do the touch */
d998 2
a999 2
	(void) fprintf(stdout, "touch %s\n", gn->name);
	(void) fflush(stdout);
d1011 1
a1011 1
	char	*file = gn->path ? gn->path : gn->name;
d1013 1
a1013 1
	if (set_times(file) == -1) {
d1024 2
a1025 2
		    (void) lseek(streamID, 0, SEEK_SET);
		    (void) write(streamID, &c, 1);
d1028 1
a1028 1
		(void) close(streamID);
d1030 1
a1030 1
		(void) fprintf(stdout, "*** couldn't touch %s: %s",
d1032 1
a1032 1
		(void) fflush(stdout);
d1053 1
a1053 1
    GNode          *gn;	    	    /* The target whose commands need
d1055 1
a1055 1
    void    	 (*abortProc) __P((char *, ...));
d1064 1
a1064 1
	if ((DEFAULT != NULL) && !Lst_IsEmpty(&DEFAULT->commands)) {
d1087 2
a1088 2
		(void) fprintf(stdout, "%s %s(ignored)\n", msg, gn->name);
		(void) fflush(stdout);
d1090 3
a1092 3
		(void) fprintf(stdout, "%s %s(continuing)\n", msg, gn->name);
		(void) fflush(stdout);
  		return FALSE;
d1095 1
a1095 1
			Var_Value(".CURDIR", VAR_GLOBAL));
a1107 3
 * Results:
 *	None
 *
a1109 1
 *
d1115 2
a1116 2
    int	    stream; 	/* Stream that's ready (ignored) */
    Job	    *job;   	/* Job to which the stream belongs */
a1127 3
 * Results:
 *	None.
 *
a1130 1
 *
d1135 2
a1136 2
    Job	    	  *job; 	/* Job to execute */
    char    	  **argv;
d1138 1
a1138 1
    int	    	  cpid;	    	/* ID of new child */
d1141 1
a1141 1
	int 	  i;
d1143 1
a1143 1
	(void) fprintf(stdout, "Running %s %sly\n", job->node->name,
d1145 1
a1145 1
	(void) fprintf(stdout, "\tCommand: ");
d1147 1
a1147 1
	    (void) fprintf(stdout, "%s ", argv[i]);
d1149 2
a1150 2
 	(void) fprintf(stdout, "\n");
 	(void) fflush(stdout);
d1159 1
a1159 1
    if ((lastNode != job->node) && (job->flags & JOB_FIRST) &&
d1182 2
a1183 2
	(void) fcntl(0, F_SETFD, 0);
	(void) lseek(0, 0, SEEK_SET);
d1207 1
a1207 1
	(void) fcntl(1, F_SETFD, 0);
d1218 1
a1218 1
	(void) setsid();
d1220 1
a1220 1
	(void) setpgid(0, getpid());
d1229 1
a1229 1
	   (void) execv(shellPath, argv);
d1231 1
a1231 1
	(void) write(2, "Could not execute shell\n",
d1279 1
a1279 1
		(void) fclose(job->cmdFILE);
d1284 1
a1284 1
	(void) sigsetmask(omask);
a1304 6
 *
 *
 * Results:
 *
 * Side Effects:
 *
d1309 1
a1309 1
    Job	    	  *job;
d1312 2
a1313 2
    int	    	  argc;
    static char	  args[10]; 	/* For merged arguments */
d1318 2
a1319 2
    if ((commandShell->exit && (*commandShell->exit != '-')) ||
	(commandShell->echo && (*commandShell->echo != '-')))
a1354 3
 * Results:
 *	None.
 *
a1356 1
 *
d1361 1
a1361 1
    Job 	  *job;    	/* Job to restart */
d1373 1
a1373 1
	   (void) fprintf(stdout, "*** remigrating %x(%s)\n",
d1375 1
a1375 1
	   (void) fflush(stdout);
d1381 2
a1382 2
		(void) fprintf(stdout, "*** couldn't migrate...\n");
		(void) fflush(stdout);
d1396 2
a1397 2
		    (void) fprintf(stdout, "*** resuming on local machine\n");
		    (void) fflush(stdout);
d1417 3
a1419 3
		   (void) fprintf(stdout, "*** holding\n");
		   (void) fflush(stdout);
  		}
d1423 2
a1424 2
		   (void) fprintf(stdout, "Job queue is full.\n");
		   (void) fflush(stdout);
d1446 2
a1447 2
		(void) fprintf(stdout, "Job queue is full.\n");
		(void) fflush(stdout);
d1464 2
a1465 2
	    (void) fprintf(stdout, "Restarting %s...", job->node->name);
	    (void) fflush(stdout);
d1469 1
a1469 1
 	    (nLocal < maxLocal && runLocalFirst)
d1477 1
a1477 1
	    if (((nLocal >= maxLocal) && !(job->flags & JOB_SPECIAL))) {
d1483 2
a1484 2
		    (void) fprintf(stdout, "holding\n");
		    (void) fflush(stdout);
d1489 2
a1490 2
		    (void) fprintf(stdout, "Job queue is full.\n");
		    (void) fflush(stdout);
d1498 2
a1499 2
		    (void) fprintf(stdout, "running locally\n");
		    (void) fflush(stdout);
d1510 2
a1511 2
		(void) fprintf(stdout, "exporting\n");
		(void) fflush(stdout);
d1523 2
a1524 2
	   (void) fprintf(stdout, "Resuming %s...", job->node->name);
	   (void) fflush(stdout);
d1527 1
a1527 1
	    (nLocal < maxLocal) ||
d1529 3
a1531 3
	    (((job->flags & JOB_SPECIAL) &&
	      (job->node->type & OP_NOEXPORT)) &&
	     (maxLocal == 0))) &&
d1534 1
a1534 1
	     (maxLocal == 0))) &&
d1536 1
a1536 1
	   (nJobs != maxJobs))
d1553 1
a1553 1
		error = (KILL(job->pid, SIGCONT) != 0);
d1566 2
a1567 2
		   (void) fprintf(stdout, "done\n");
		   (void) fflush(stdout);
d1582 2
a1583 2
		(void) fprintf(stdout, "table full\n");
		(void) fflush(stdout);
d1588 2
a1589 2
		(void) fprintf(stdout, "Job queue is full.\n");
		(void) fflush(stdout);
d1613 2
a1614 2
    GNode         *gn;	      /* target to create */
    int	  	   flags;      /* flags for the job to override normal ones.
d1619 1
a1619 1
    register Job  *job;       /* new job descriptor */
d1622 2
a1623 3
    Boolean 	  local;      /* Set true if the job was run locally */
    Boolean 	  noExec;     /* Set true if we decide not to run the job */
    int	          tfd;	      /* where to stash those pesky commands */
d1629 1
a1629 1
	job = (Job *) emalloc(sizeof(Job));
d1678 1
a1678 5
	(void) strcpy(tfile, TMPPAT);
	if ((tfd = mkstemp(tfile)) == -1)
	    Punt("Cannot create temp file: %s", strerror(errno));
	job->cmdFILE = fdopen(tfd, "w+");
	eunlink(tfile);
a1679 1
	    close(tfd);
d1682 1
a1682 1
	(void) fcntl(FILENO(job->cmdFILE), F_SETFD, 1);
a1693 1
	    LstNode ln;
d1703 3
a1705 2
	    	Lst_Open(&gn->commands);
	    ln = Lst_Next(&gn->commands);
d1707 2
a1708 1
	    if ((ln == NULL) || !JobPrintCommand(Lst_Datum(ln), job)) {
d1710 1
a1710 1
		Lst_Close(&gn->commands);
d1756 1
a1756 1
	if (cmdsOK)
d1758 1
d1771 1
a1771 1
    	Job_Touch(gn, job->flags&JOB_SILENT);
d1783 1
d1785 1
a1785 1
		(void) fclose(job->cmdFILE);
d1787 1
a1787 1
	     (void) fflush(stdout);
d1796 1
a1796 1
 		Lst_ForEachFrom(job->tailCmds, JobSaveCommand, job->node);
d1806 2
a1807 1
	(void) fflush(job->cmdFILE);
d1828 2
a1829 2
	    (void) fcntl(job->inPipe, F_SETFD, 1);
	    (void) fcntl(job->outPipe, F_SETFD, 1);
d1831 3
a1833 3
	    (void) fprintf(stdout, "Remaking `%s'\n", gn->name);
  	    (void) fflush(stdout);
	    (void) strcpy(job->outFile, TMPPAT);
d1836 1
a1836 1
	    (void) fcntl(job->outFd, F_SETFD, 1);
d1854 1
a1854 1
    if (local && (((nLocal >= maxLocal) &&
d1857 1
a1857 1
	(!(gn->type & OP_NOEXPORT) || (maxLocal != 0))
d1859 1
a1859 1
	(maxLocal != 0)
d1861 1
a1861 1
	)))
d1875 2
a1876 2
	   (void) fprintf(stdout, "Can only run job locally.\n");
	   (void) fflush(stdout);
d1881 1
a1881 1
	if ((nLocal >= maxLocal) && local) {
d1888 2
a1889 2
		(void) fprintf(stdout, "Local job queue is full.\n");
		(void) fflush(stdout);
d1894 1
a1894 1
    return(JOB_RUNNING);
d1899 2
a1900 2
    register Job *job;
    register char *cp, *endp;
d1903 1
a1903 1
    register char *ecp;
d1920 2
a1921 2
		(void) fprintf(stdout, "%s", cp);
		(void) fflush(stdout);
d1945 1
a1945 1
 * JobDoOutput  --
a1962 3
 * Results:
 *	None
 *
d1969 1
a1969 1
    register Job   *job;	  /* the job whose output needs printing */
d1973 6
a1978 6
    Boolean       gotNL = FALSE;  /* true if got a newline */
    Boolean       fbuf;  	  /* true if our buffer filled up */
    register int  nr;	      	  /* number of bytes read */
    register int  i;	      	  /* auxiliary index into outBuf */
    register int  max;	      	  /* limit for i (end of current data) */
    int		  nRead;      	  /* (Temporary) number of bytes read */
d1980 2
a1981 2
    FILE      	  *oFILE;	  /* Stream pointer to shell's output file */
    char          inLine[132];
d1994 1
a1994 1
	if (nRead < 0) {
d2009 1
a2009 1
	if ((nr == 0) && (job->curPos != 0)) {
d2073 2
a2074 2
		    (void) fprintf(stdout, "%s%s", cp, gotNL ? "\n" : "");
		    (void) fflush(stdout);
d2079 1
a2079 1
		(void) memcpy(job->outBuf, &job->outBuf[i + 1], max - (i + 1));
d2114 2
a2115 2
	    (void) fprintf(stdout, "Results of making %s:\n", job->node->name);
	    (void) fflush(stdout);
d2117 1
a2117 1
		register char	*cp, *endp, *oendp;
d2131 2
a2132 2
		(void) fprintf(stdout, "%s", cp);
		(void) fflush(stdout);
d2134 2
a2135 2
		    (void) fprintf(stdout, "\n");
		    (void) fflush(stdout);
d2138 2
a2139 2
	    (void) fclose(oFILE);
	    (void) eunlink(job->outFile);
a2148 3
 * Results:
 *	none.
 *
a2156 1
 *
d2161 1
a2161 1
    Boolean	  block;    	/* TRUE if should block on the wait. */
d2163 4
a2166 4
    int    	  pid;	    	/* pid of dead child */
    register Job  *job;	    	/* job descriptor for dead child */
    LstNode       jnode;    	/* list element for finding job */
    int	  	  status;   	/* Exit/termination status */
d2179 2
a2180 2
	    (void) fprintf(stdout, "Process %d exited or stopped.\n", pid);
	    (void) fflush(stdout);
d2204 2
a2205 2
		(void) fprintf(stdout, "Job queue is no longer full.\n");
		(void) fflush(stdout);
d2211 1
a2211 1
		    (void) fprintf(stdout,
d2213 1
a2213 1
		    (void) fflush(stdout);
a2234 3
 * Results:
 *	None
 *
d2242 1
a2242 1
    int           	  nfds;
d2244 2
a2245 2
    register LstNode	  ln;
    register Job   	  *job;
d2247 1
a2247 1
    int	    	  	  pnJobs;   	/* Previous nJobs */
d2250 1
a2250 1
    (void) fflush(stdout);
d2289 1
a2289 2
	    Lst_Open(&jobs);
	    while (nfds && (ln = Lst_Next(&jobs)) != NULL) {
a2295 1
	    Lst_Close(&jobs);
a2307 3
 * Results:
 *	None.
 *
a2309 1
 *
d2316 1
a2316 1
    (void) JobStart(gn, 0, NULL);
a2323 3
 * Results:
 *	none
 *
d2330 1
a2330 1
    int           maxproc;  /* the greatest number of jobs which may be
d2332 1
a2332 1
    int	    	  maxlocal; /* the greatest number of local jobs which may
d2335 8
a2342 1
    GNode         *begin;     /* node for commands to do at the very start */
d2346 5
a2350 5
    maxJobs = 	  maxproc;
    maxLocal = 	  maxlocal;
    nJobs = 	  0;
    nLocal = 	  0;
    jobFull = 	  FALSE;
d2352 2
a2353 2
    aborting = 	  0;
    errors = 	  0;
d2395 1
a2395 1
	(void) signal(SIGINT, JobPassSig);
d2398 1
a2398 1
	(void) signal(SIGHUP, JobPassSig);
d2401 1
a2401 1
	(void) signal(SIGQUIT, JobPassSig);
d2404 1
a2404 1
	(void) signal(SIGTERM, JobPassSig);
d2414 1
a2414 1
	(void) signal(SIGTSTP, JobPassSig);
d2417 1
a2417 1
	(void) signal(SIGTTOU, JobPassSig);
d2420 1
a2420 1
	(void) signal(SIGTTIN, JobPassSig);
d2423 1
a2423 1
	(void) signal(SIGWINCH, JobPassSig);
d2427 1
a2427 1
    begin = Targ_FindNode(".BEGIN", TARG_NOCREATE);
d2438 1
a2438 1
    postCommands = Targ_FindNode(".END", TARG_CREATE);
a2450 2
 * Side Effects:
 *	None.
d2456 1
a2456 1
    return(aborting || jobFull);
d2462 1
a2462 1
 *	See if the job table is empty.  Because the local concurrency may
a2468 4
 *
 * Side Effects:
 *	None.
 *
d2482 1
a2482 1
	    return(FALSE);
d2484 1
a2484 1
	    return(TRUE);
d2487 1
a2487 1
	return(FALSE);
a2497 4
 *
 * Side Effects:
 *	None.
 *
d2504 3
a2506 3
    register Shell *sh;	      /* Pointer into shells table */
    Shell	   *match;    /* Longest-matching shell */
    register char *cp1,
d2526 1
a2526 1
    return(match == NULL ? sh : match);
d2552 4
a2555 4
 *	    name  	    Name of shell.
 *	    path  	    Location of shell. Overrides "name" if given
 *	    quiet 	    Command to turn off echoing.
 *	    echo  	    Command to turn echoing on
d2557 1
a2557 1
 *	    	  	    printed.
d2561 4
a2564 4
 *	    check 	    Command to turn on error checking if hasErrCtl
 *	    	  	    is TRUE or template of command to echo a command
 *	    	  	    for which error checking is off if hasErrCtl is
 *	    	  	    FALSE.
d2566 3
a2568 4
 *	    	  	    is TRUE or template of command to execute a
 *	    	  	    command so as to ignore any errors it returns if
 *	    	  	    hasErrCtl is FALSE.
 *
d2575 7
a2581 7
    char    	  **words;
    int	    	  wordCount;
    register char **argv;
    register int  argc;
    char    	  *path;
    Shell   	  newShell;
    Boolean 	  fullSpec = FALSE;
d2588 2
a2589 2
	 	  
    words = brk_string(line, &wordCount, TRUE, &shellArgv);
d2617 2
a2618 2
		     newShell.hasErrCtl = !((c != 'Y') && (c != 'y') &&
					   (c != 'T') && (c != 't'));
d2627 1
a2627 1
		     return(FAILURE);
d2642 1
a2642 1
	    return(FAILURE);
d2670 1
a2670 1
	    commandShell = (Shell *) emalloc(sizeof(Shell));
a2700 3
 * Results:
 *	None
 *
d2708 1
a2708 1
    int	    runINTERRUPT;   	/* Non-zero if commands for the .INTERRUPT
d2710 1
a2710 1
    int	    signo;		/* signal received */
d2712 3
a2714 3
    LstNode 	  ln;		/* element in job table */
    Job           *job;	    	/* job descriptor in that element */
    GNode         *interrupt;	/* the node describing the .INTERRUPT target */
d2718 1
a2718 2
    Lst_Open(&jobs);
    while ((ln = Lst_Next(&jobs)) != NULL) {
d2722 1
a2722 1
	    char  	*file = (job->node->path == NULL ?
d2724 1
a2724 1
				 job->node->path);
d2751 1
a2751 1
		(void) fprintf(stdout,
d2754 1
a2754 1
		(void) fflush(stdout);
d2762 1
a2762 2
    Lst_Open(&stoppedJobs);
    while ((ln = Lst_Next(&stoppedJobs)) != NULL) {
d2767 1
a2767 1
		(void) fprintf(stdout, "%s%s",
d2770 1
a2770 1
		(void) fflush(stdout);
d2775 1
a2775 1
	    char  	*file = (job->node->path == NULL ?
d2777 1
a2777 1
				 job->node->path);
d2786 1
a2786 1
	    (void) fprintf(stdout,
d2789 1
a2789 1
	    (void) fflush(stdout);
d2809 1
a2809 1
		(void) fprintf(stdout,
d2812 1
a2812 1
		(void) fflush(stdout);
a2818 1
    Lst_Close(&stoppedJobs);
d2821 1
a2821 1
	interrupt = Targ_FindNode(".INTERRUPT", TARG_NOCREATE);
d2834 1
d2846 4
d2869 2
a2870 1
    return(errors);
a2877 3
 * Results:
 *	None.
 *
d2889 1
a2889 1
 
a2895 3
 * Results:
 *	None.
 *
a2920 3
 * Results:
 *	None
 *
d2928 3
a2930 3
    LstNode           	ln;	/* element in job table */
    Job            	*job;	/* the job descriptor in that element */
    int     	  	foo;
d2935 1
a2935 3

	Lst_Open(&jobs);
	while ((ln = Lst_Next(&jobs)) != NULL) {
d2962 1
a2971 3
 * Results:
 *	none.
 *
a2973 1
 *
d2978 1
a2978 1
    int 	  hostID;    	/* ID of host we used, for matching children. */
d2980 2
a2981 2
    register Job  *job;	    	/* job descriptor for dead child */
    LstNode       jnode;    	/* list element for finding job */
d2984 2
a2985 2
	(void) fprintf(stdout, "JobFlagForMigration(%d) called.\n", hostID);
	(void) fflush(stdout);
d3001 1
a3001 1
	(void) fprintf(stdout,
d3004 1
a3004 1
	(void) fflush(stdout);
d3013 1
a3013 1

a3020 3
 * Results:
 *	None.
 *
a3022 1
 *
d3030 1
a3030 1
    while (!jobFull && (job = (Job *)Lst_DeQueue(&stoppedJobs)) != NULL)  {
d3032 1
a3032 1
	    (void) fprintf(stdout,
d3034 1
a3034 1
	    (void) fflush(stdout);
@


1.38
log
@Change the time stamp interface to use an abstract datatype.
Define two possible interfaces: the classic one,
and the new one (used where available) that depends on timespec.

Better granularity, make is now able to distinguish between files that
were built during the same second.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.37 2000/09/14 13:52:42 espie Exp $	*/
d129 1
a129 1
static char rcsid[] = "$OpenBSD: job.c,v 1.37 2000/09/14 13:52:42 espie Exp $";
d1118 2
a1119 1
		(*abortProc)("%s %s. Stop", msg, gn->name);
@


1.37
log
@Introduce a few macros to handle timestamps in an abstract way.

Replace the time stamp hash in dir.c with an open hashing structure.

In doing so, remove some nasty casts, simplify code a bit:
Dir_MTime can return a modification time, since make does not make
a distinction between out-of-date and non-existent files.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.36 2000/09/14 13:46:45 espie Exp $	*/
d129 1
a129 1
static char rcsid[] = "$OpenBSD: job.c,v 1.36 2000/09/14 13:46:45 espie Exp $";
a1011 1
    struct utimbuf times;	/* Times for utime() call */
d1037 1
a1037 2
	times.actime = times.modtime = now;
	if (utime(file, &times) < 0){
@


1.36
log
@Replace the old hash used to hold file names within a directory with
open hashing.

An interesting optimization is that the open hashing interface is more
fine-grained, hence we can compute the correct hash value at the start
of Dir_FindFile, and reuse it for each hash structure into which we look
(the effect is measurable on large directories along with objdir/VPATH).

Remove a few unnecessary Lst_Open/Lst_Close that serve no purpose except
obfuscating the code.

The interface to dir.h changes slightly, hence tedious includes changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.35 2000/09/14 13:32:06 espie Exp $	*/
d129 1
a129 1
static char rcsid[] = "$OpenBSD: job.c,v 1.35 2000/09/14 13:32:06 espie Exp $";
d1102 1
a1102 1
	} else if (Dir_MTime(gn) == 0) {
@


1.35
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.34 2000/06/30 23:26:25 espie Exp $	*/
d108 1
d113 1
a113 1
#include "hash.h"
d129 1
a129 1
static char rcsid[] = "$OpenBSD: job.c,v 1.34 2000/06/30 23:26:25 espie Exp $";
@


1.34
log
@Recognize `+cmd' as a command that should always be executed, even in
make -n mode.

Currently works only in sequential make mode. In parallel make mode,
it's just a no-op.

Useful to debug recursive Makefiles, and part of POSIX.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.33 2000/06/23 16:41:53 espie Exp $	*/
a41 8
#ifndef lint
#if 0
static char sccsid[] = "@@(#)job.c	8.2 (Berkeley) 3/19/94";
#else
static char rcsid[] = "$OpenBSD: job.c,v 1.33 2000/06/23 16:41:53 espie Exp $";
#endif
#endif /* not lint */

d123 8
@


1.33
log
@This patch replaces str_concat with a slightly unobfuscated version.

In particular, Dir_MakeFlags is abusing str_concat, and works much better
with buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.32 2000/06/23 16:20:01 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.32 2000/06/23 16:20:01 espie Exp $";
d562 2
a563 2
    while (*cmd == '@@' || *cmd == '-') {
	if (*cmd == '@@') {
d565 1
a565 1
	} else {
d567 2
a568 2
	}
	cmd++;
@


1.32
log
@Once those special variable are taken care of, other Var functions can take
the GNode's context directly.  We rename that special Lst to `SymTable *'
in prevision of things to come.

Along the line, we lose the special GNodes affected to VAR_CMD, VAR_GLOBAL,
VAR_ENV, which become simple Lsts... This is not a problem, except when
getting to a context's name for debugging (handled very nicely by
offsetof).

Again, this is a preparatory patch, which does not gain anything except
for cleaning up issues...

Reviewed by millert@@ and miod@@, like the previous patch
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.31 2000/06/23 16:18:09 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.31 2000/06/23 16:18:09 espie Exp $";
d2436 1
a2436 1
	shellPath = str_concat(_PATH_DEFSHELLDIR, shellName, STR_ADDSLASH);
@


1.31
log
@Start of variable fixes and speed-ups.

This patch may seem a bit non-sensical at first. It simply introduces some
new interface. Specifically, recognizes that some variable names
(.TARGET/$@@, .OODATE/$?, .ALLSRC/$>, .IMPSRC/$<, .PREFIX/$*, .ARCHIVE/$!,
.MEMBER/$%) are `special' (the actual variables which are local to a
target, e.g. GNode).

Currently, The Varq functions (for Varquick access) are only stubs to the
normal functions.

This fixes a very important detail before proceeding to turn variable lists
into hash tables: if every GNode holds a hash table, initialization times
for those will be very costly. But generic GNodes only hold those seven
special variables... which can be stored directly into a small array;
the only general cases are the environment, the command line and
global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.30 2000/06/23 16:15:49 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.30 2000/06/23 16:15:49 espie Exp $";
d554 1
a554 1
    cmdStart = cmd = Var_Subst(cmd, job->node, FALSE);
d673 1
a673 1
    result = Var_Subst((char *)cmd, (GNode *)gn, FALSE);
@


1.30
log
@Trivial consequences of the previous list changes:

- audit code for Lst_Datum, it's never applied to an empty pointer,
so check can be removed -> turn into a macro,
- Lst_First, Lst_Last can become macro as well
- specialized version of Lst_Succ (Lst_Adv) to use in loops where it cannot
fail,
- Lst_Open can no longer fail. Trim down corresponding code.

Reviewed millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.29 2000/06/17 14:38:15 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.29 2000/06/17 14:38:15 espie Exp $";
d1100 1
a1100 1
	    Var_Set(IMPSRC, Var_Value(TARGET, gn), gn);
@


1.29
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.28 2000/06/10 01:41:05 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.28 2000/06/10 01:41:05 espie Exp $";
d1742 1
d1751 3
a1753 4
	    if ((job->flags&JOB_FIRST) && (Lst_Open(&gn->commands) != SUCCESS)){
		cmdsOK = FALSE;
	    } else {
		LstNode	ln = Lst_Next(&gn->commands);
d1755 17
a1771 18
		if ((ln == NULL) || !JobPrintCommand(Lst_Datum(ln), job)) {
		    noExec = TRUE;
		    Lst_Close(&gn->commands);
		}
		if (noExec && !(job->flags & JOB_FIRST)) {
		    /*
		     * If we're not going to execute anything, the job
		     * is done and we need to close down the various
		     * file descriptors we've opened for output, then
		     * call JobDoOutput to catch the final characters or
		     * send the file to the screen... Note that the i/o streams
		     * are only open if this isn't the first job.
		     * Note also that this could not be done in
		     * Job_CatchChildren b/c it wasn't clear if there were
		     * more commands to execute or not...
		     */
		    JobClose(job);
		}
d2251 1
a2251 1
	    job = (Job *) Lst_Datum(jnode);
d2343 1
a2343 4
	    if (Lst_Open(&jobs) == FAILURE) {
		free(readfdsp);
		Punt("Cannot open job table");
	    }
d2345 1
a2345 1
		job = (Job *) Lst_Datum(ln);
d2788 1
a2788 1
   (void) Lst_Open(&jobs);
d2790 1
a2790 1
	job = (Job *) Lst_Datum(ln);
d2833 1
a2833 1
   (void)Lst_Open(&stoppedJobs);
d2835 1
a2835 1
	job = (Job *) Lst_Datum(ln);
d3012 1
a3012 1
	(void) Lst_Open(&jobs);
d3014 1
a3014 1
	    job = (Job *) Lst_Datum(ln);
d3079 1
a3079 1
    job = (Job *) Lst_Datum(jnode);
@


1.28
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.27 2000/06/10 01:32:22 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.27 2000/06/10 01:32:22 espie Exp $";
d226 1
a226 1
STATIC Lst     	jobs;		/* The structures that describe them */
d260 1
a260 1
STATIC Lst	stoppedJobs;	/* Lst of Job structures describing
d383 1
a383 1
    Lst_ForEach(jobs, JobCondPassSig, &signo);
d429 1
a429 1
    Lst_ForEach(jobs, JobCondPassSig, &signo);
d534 1
a534 2
	    job->tailCmds = Lst_Succ(Lst_Member(job->node->commands,
						cmd));
d553 1
a553 1
    cmdNode = Lst_Member(job->node->commands, cmd);
d674 1
a674 1
    Lst_AtEnd(postCommands->commands, result);
d850 1
a850 1
	    Lst_AtEnd(stoppedJobs, job);
d888 1
a888 1
 	    Lst_AtEnd(jobs, job);
d925 1
a925 1
	!Lst_IsAtEnd(job->node->commands))) {
d1083 1
a1083 1
    if (OP_NOP(gn->type) && Lst_IsEmpty(gn->commands) &&
d1089 1
a1089 1
	if ((DEFAULT != NULL) && !Lst_IsEmpty(DEFAULT->commands)) {
d1327 1
a1327 1
    Lst_AtEnd(jobs, job);
d1462 1
a1462 1
		Lst_AtFront(stoppedJobs, job);
d1483 1
a1483 1
	Lst_AtEnd(jobs, job);
d1528 1
a1528 1
		Lst_AtFront(stoppedJobs, job);
d1627 1
a1627 1
	    Lst_AtFront(stoppedJobs, job);
d1750 1
a1750 1
	    if ((job->flags&JOB_FIRST) && (Lst_Open(gn->commands) != SUCCESS)){
d1753 1
a1753 1
		LstNode	ln = Lst_Next(gn->commands);
d1757 1
a1757 1
		    Lst_Close(gn->commands);
d1779 1
a1779 1
	    Lst_Find(gn->commands, JobPrintCommand, job);
d1805 1
a1805 1
	    Lst_Find(gn->commands, JobPrintCommand, job);
d1924 1
a1924 1
	Lst_AtEnd(stoppedJobs, job);
d2236 1
a2236 1
	jnode = Lst_Find(jobs, JobCmpPid, &pid);
d2240 1
a2240 1
		jnode = Lst_Find(stoppedJobs, JobCmpPid, &pid);
d2246 1
a2246 1
		(void) Lst_Remove(stoppedJobs, jnode);
d2253 1
a2253 1
	    Lst_Remove(jobs, jnode);
d2344 1
a2344 1
	    if (Lst_Open(jobs) == FAILURE) {
d2348 1
a2348 1
	    while (nfds && (ln = Lst_Next(jobs)) != NULL) {
d2355 1
a2355 1
	    Lst_Close(jobs);
d2404 2
a2405 2
    jobs =  	  Lst_Init();
    stoppedJobs = Lst_Init();
d2541 1
a2541 1
	if (!Lst_IsEmpty(stoppedJobs) && !aborting) {
d2792 2
a2793 2
   (void) Lst_Open(jobs);
    while ((ln = Lst_Next(jobs)) != NULL) {
d2837 2
a2838 2
   (void)Lst_Open(stoppedJobs);
    while ((ln = Lst_Next(stoppedJobs)) != NULL) {
d2895 1
a2895 1
    Lst_Close(stoppedJobs);
d2927 1
a2927 1
    if (postCommands != NULL && !Lst_IsEmpty(postCommands->commands)) {
d3016 2
a3017 2
	(void) Lst_Open(jobs);
	while ((ln = Lst_Next(jobs)) != NULL) {
d3072 1
a3072 1
    jnode = Lst_Find(jobs, JobCmpRmtID, &hostID);
d3075 1
a3075 1
	jnode = Lst_Find(stoppedJobs, JobCmpRmtID, &hostID);
d3119 1
a3119 1
    while (!jobFull && (job = (Job *)Lst_DeQueue(stoppedJobs)) != NULL)  {
@


1.27
log
@Thus, Lst_ForEach no longer needs returning a status.
In fact, it can become a macro based on Lst_ForEachFrom.
This also introduces Lst_Every, as a shortcut for the very common case where
Lst_ForEach does not need any user data.

Finally,  make consistent use of a few function typedefs, instead of having
explicit void (*)(Lst)  arguments all over the place.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.26 2000/06/10 01:26:36 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.26 2000/06/10 01:26:36 espie Exp $";
d295 1
a295 1
static void JobCondPassSig __P((ClientData, ClientData));
d297 3
a299 3
static int JobCmpPid __P((ClientData, ClientData));
static int JobPrintCommand __P((ClientData, ClientData));
static void JobSaveCommand __P((ClientData, ClientData));
d302 1
a302 1
static int JobCmpRmtID __P((Job *, ClientData));
d332 2
a333 2
    ClientData	    	jobp;	    /* Job to biff */
    ClientData	    	signop;	    /* Signal to send it */
d453 2
a454 2
    ClientData        job;	/* job to examine */
    ClientData        pid;	/* process id desired */
d456 1
a456 1
    return *(int *) pid - ((Job *) job)->pid;
d475 2
a476 2
    ClientData      job;	/* job to examine */
    ClientData      rmtID;	/* remote id desired */
d511 2
a512 2
    ClientData    cmdp;	    	    /* command string to print */
    ClientData    jobp;	    	    /* job for which to print it */
d669 2
a670 2
    ClientData   cmd;
    ClientData   gn;
d672 4
a675 2
    cmd = (ClientData) Var_Subst((char *) cmd, (GNode *) gn, FALSE);
    Lst_AtEnd(postCommands->commands, cmd);
d965 1
a965 1
	free((Address)job);
d968 1
a968 1
	free((Address)job);
d1846 2
a1847 2
	    free((Address)job);
	    return(JOB_FINISHED);
d1849 2
a1850 2
	    free((Address)job);
	    return(JOB_ERROR);
d2663 1
a2663 1
    memset((Address)&newShell, 0, sizeof(newShell));
@


1.26
log
@Lst_Find and Lst_ForEach do the same thing, except that the comparison
sense is reversed (Lst_Find  returns when proc says 0, whereas Lst_ForEach
goes on while proc says 0).

This patch turns a number of Lst_ForEach into Lst_Find.
Specifically, all Lst_ForEach that actually may return quickly as proc
does not always returns zero.

Of course, the corresponding proc need to be tweaked to swap 0 and 1...
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.25 2000/03/26 16:21:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.25 2000/03/26 16:21:32 espie Exp $";
d295 1
a295 1
static int JobCondPassSig __P((ClientData, ClientData));
d299 1
a299 1
static int JobSaveCommand __P((ClientData, ClientData));
a324 3
 * Results:
 *	=== 0
 *
d330 1
a330 1
static int
a355 1
    return 0;
a661 3
 * Results:
 *	Always returns 0
 *
d667 1
a667 1
static int
a673 1
    return(0);
d960 1
a960 5
	if (job->tailCmds != NULL) {
	    Lst_ForEachFrom(job->node->commands, job->tailCmds,
			     JobSaveCommand,
			    job->node);
	}
d1841 1
a1841 5
		if (job->tailCmds != NULL) {
		    Lst_ForEachFrom(job->node->commands, job->tailCmds,
				    JobSaveCommand,
				   job->node);
		}
@


1.25
log
@Remove idiotic, braindead casts T* -> void*
They serve no purpose, except hiding potential bugs.

In particular, remove (ClientData) cast from macro, showing potentially
troublesome use of Hashes to store time_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.24 2000/03/26 16:08:27 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.24 2000/03/26 16:08:27 espie Exp $";
d503 1
a503 1
 *	Always 0, unless the command was "..."
d540 1
a540 1
	    return 1;
d542 1
a542 1
	return 0;
d657 1
a657 1
    return 0;
d1766 1
a1766 3
		if ((ln == NULL) ||
		    JobPrintCommand(Lst_Datum(ln), job))
		{
d1790 1
a1790 1
	    Lst_ForEach(gn->commands, JobPrintCommand, job);
d1815 2
a1816 3
	if (cmdsOK) {
	    Lst_ForEach(gn->commands, JobPrintCommand, job);
	}
@


1.24
log
@Passing an (int) instead of an (int*) won't work.
Those casts are evil...
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.23 2000/02/01 03:23:32 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.23 2000/02/01 03:23:32 deraadt Exp $";
d387 1
a387 1
    Lst_ForEach(jobs, JobCondPassSig, (ClientData) &signo);
d433 1
a433 1
    Lst_ForEach(jobs, JobCondPassSig, (ClientData) &signo);
d539 1
a539 1
						(ClientData)cmd));
d558 1
a558 1
    cmdNode = Lst_Member(job->node->commands, (ClientData)cmd);
d560 1
a560 1
    Lst_Replace(cmdNode, (ClientData)cmdStart);
d857 1
a857 1
	    Lst_AtEnd(stoppedJobs, (ClientData)job);
d895 1
a895 1
 	    Lst_AtEnd(jobs, (ClientData)job);
d971 1
a971 1
			    (ClientData)job->node);
d1338 1
a1338 1
    Lst_AtEnd(jobs, (ClientData)job);
d1473 1
a1473 1
		Lst_AtFront(stoppedJobs, (ClientData)job);
d1494 1
a1494 1
	Lst_AtEnd(jobs, (ClientData)job);
d1539 1
a1539 1
		Lst_AtFront(stoppedJobs, (ClientData)job);
d1638 1
a1638 1
	    Lst_AtFront(stoppedJobs, (ClientData)job);
d1767 1
a1767 2
		    JobPrintCommand((ClientData) Lst_Datum(ln),
				    (ClientData) job))
d1792 1
a1792 1
	    Lst_ForEach(gn->commands, JobPrintCommand, (ClientData)job);
d1818 1
a1818 1
	    Lst_ForEach(gn->commands, JobPrintCommand, (ClientData)job);
d1859 1
a1859 1
				   (ClientData)job->node);
d1942 1
a1942 1
	Lst_AtEnd(stoppedJobs, (ClientData)job);
d2254 1
a2254 1
	jnode = Lst_Find(jobs, JobCmpPid, (ClientData)&pid);
d2258 1
a2258 1
		jnode = Lst_Find(stoppedJobs, JobCmpPid, (ClientData)&pid);
d3090 1
a3090 1
    jnode = Lst_Find(jobs, JobCmpRmtID, (ClientData)&hostID);
d3093 1
a3093 1
	jnode = Lst_Find(stoppedJobs, JobCmpRmtID, (ClientData)&hostID);
@


1.23
log
@no need to extern int errno if errno.h is included
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.22 2000/01/20 18:14:58 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.22 2000/01/20 18:14:58 espie Exp $";
d302 1
a302 1
static int JobCmpRmtID __P((Job *, int));
d482 1
a482 1
    return(*(int *) rmtID - *(int *) job->rmtID);
d3091 1
a3091 1
    jnode = Lst_Find(jobs, JobCmpRmtID, (ClientData)hostID);
d3094 1
a3094 1
	jnode = Lst_Find(stoppedJobs, JobCmpRmtID, (ClientData)hostID);
@


1.22
log
@Fix problem pointed out by FreeBSD, regen temp file name each time, to
avoid races.

Make use of basic Unix semantics, namely you can unlink a file while holding
open fd on the data.  Avoid all the mess of having to track useless file names
around.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.21 1999/12/19 00:04:25 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.21 1999/12/19 00:04:25 espie Exp $";
a130 1
extern int  errno;
a1598 1
	    extern int errno;
@


1.21
log
@Rearrange Lst_Find interface to conform better with other functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.20 1999/12/18 21:58:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.20 1999/12/18 21:58:07 espie Exp $";
d168 2
a169 3
 * tfile is the name of a file into which all shell commands are put. It is
 * used over by removing it before the child shell is executed. The XXXXXXXXXX
 * in the string are replaced by mkstemp(3).
d996 1
a996 1
    if ((aborting == ABORT_ERROR) && Job_Empty()) {
a999 1
	(void) eunlink(tfile);
a1000 1
    }
d1679 1
d1734 5
a1738 1
	job->cmdFILE = fopen(tfile, "w+");
d1740 1
a1846 1
	    (void) eunlink(tfile);
a1873 1
	(void) eunlink(tfile);
a2423 7
    int	          tfd;

    (void) strcpy(tfile, TMPPAT);
    if ((tfd = mkstemp(tfile)) == -1)
	Punt("Cannot create temp file: %s", strerror(errno));
    else
	(void) close(tfd);
a2931 1
    (void) eunlink(tfile);
a2942 4
 *
 * Side Effects:
 *	The process' temporary file (tfile) is removed if it still
 *	existed.
a2961 1
    (void) eunlink(tfile);
a3064 1
    (void) eunlink(tfile);
@


1.20
log
@Nothing ever checks ReturnStatus on Lst_Insert, Lst_Append, Lst_AtFront,
Lst_AtEnd, Lst_Concat, Lst_Remove, Lst_Replace.

Don't bother returning one.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.19 1999/12/18 21:56:07 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.19 1999/12/18 21:56:07 espie Exp $";
d2256 1
a2256 1
	jnode = Lst_Find(jobs, (ClientData)&pid, JobCmpPid);
d2260 1
a2260 1
		jnode = Lst_Find(stoppedJobs, (ClientData) &pid, JobCmpPid);
d3106 1
a3106 1
    jnode = Lst_Find(jobs, (ClientData)hostID, JobCmpRmtID);
d3109 1
a3109 1
	jnode = Lst_Find(stoppedJobs, (ClientData)hostID, JobCmpRmtID);
@


1.19
log
@Lst_DeQueue already checks for empty lists.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.18 1999/12/18 21:53:32 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.18 1999/12/18 21:53:32 espie Exp $";
d682 1
a682 1
    (void) Lst_AtEnd(postCommands->commands, cmd);
d859 1
a859 1
	    (void)Lst_AtEnd(stoppedJobs, (ClientData)job);
d1342 1
a1342 1
    (void) Lst_AtEnd(jobs, (ClientData)job);
d1477 1
a1477 1
		(void)Lst_AtFront(stoppedJobs, (ClientData)job);
d1498 1
a1498 1
	(void)Lst_AtEnd(jobs, (ClientData)job);
d1543 1
a1543 1
		(void)Lst_AtFront(stoppedJobs, (ClientData)job);
d1643 1
a1643 1
	    (void) Lst_AtFront(stoppedJobs, (ClientData)job);
d1944 1
a1944 1
	(void) Lst_AtEnd(stoppedJobs, (ClientData)job);
d2273 1
a2273 1
	    (void) Lst_Remove(jobs, jnode);
@


1.18
log
@NIL, NILGNODE, etc, are only glorified NULL.
Get rid of them.

Get rid of list.h, nothing uses it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.17 1999/12/18 02:11:26 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.17 1999/12/18 02:11:26 espie Exp $";
d3151 3
a3153 1
    while (!jobFull && !Lst_IsEmpty(stoppedJobs)) {
d3159 1
a3159 1
	JobRestart((Job *)Lst_DeQueue(stoppedJobs));
@


1.17
log
@make does not use circular lists, get rid of the extra weight.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.16 1999/12/16 17:27:18 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.16 1999/12/16 17:27:18 espie Exp $";
d970 1
a970 1
	if (job->tailCmds != NILLNODE) {
d1104 1
a1104 1
	if ((DEFAULT != NILGNODE) && !Lst_IsEmpty(DEFAULT->commands)) {
d1695 1
a1695 1
    job->tailCmds = NILLNODE;
d1765 1
a1765 1
		if ((ln == NILLNODE) ||
d1857 1
a1857 1
		if (job->tailCmds != NILLNODE) {
d2258 1
a2258 1
	if (jnode == NILLNODE) {
d2261 1
a2261 1
		if (jnode == NILLNODE) {
d2368 1
a2368 1
	    while (nfds && (ln = Lst_Next(jobs)) != NILLNODE) {
d2442 1
a2442 1
    lastNode =	  NILGNODE;
d2516 1
a2516 1
    if (begin != NILGNODE) {
d2820 1
a2820 1
    while ((ln = Lst_Next(jobs)) != NILLNODE) {
d2865 1
a2865 1
    while ((ln = Lst_Next(stoppedJobs)) != NILLNODE) {
d2926 1
a2926 1
	if (interrupt != NILGNODE) {
d2959 1
a2959 1
    if (postCommands != NILGNODE && !Lst_IsEmpty(postCommands->commands)) {
d3050 1
a3050 1
	while ((ln = Lst_Next(jobs)) != NILLNODE) {
d3108 1
a3108 1
    if (jnode == NILLNODE) {
d3110 1
a3110 1
		if (jnode == NILLNODE) {
@


1.16
log
@Var_Subst is actually two distinct functions folded into one:
split the function specific to for.c out, and give them more sensible
arguments at the same time.

This makes .for loop handling more efficient, as we have some heuristic
to evaluate the size of the buffer needed...
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.15 1999/12/06 22:28:44 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.15 1999/12/06 22:28:44 espie Exp $";
d2431 2
a2432 2
    jobs =  	  Lst_Init(FALSE);
    stoppedJobs = Lst_Init(FALSE);
@


1.15
log
@Extra parameter no longer needed, ditch.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.14 1999/11/11 11:35:17 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.14 1999/11/11 11:35:17 espie Exp $";
d561 1
a561 1
    cmdStart = cmd = Var_Subst(NULL, cmd, job->node, FALSE);
d681 1
a681 1
    cmd = (ClientData) Var_Subst(NULL, (char *) cmd, (GNode *) gn, FALSE);
@


1.14
log
@Kill Str_FindSubString, it's strstr.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.13 1999/10/05 22:06:24 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.13 1999/10/05 22:06:24 espie Exp $";
a1104 1
	    char *p1;
d1115 1
a1115 2
	    Var_Set(IMPSRC, Var_Value(TARGET, gn, &p1), gn);
	    efree(p1);
@


1.13
log
@Efficiency patch from NetBSD:
make spends time freeing data structures right before exiting.
So don't bother.
Keep the code inside #ifdef, so that it's still there if someone
ever wants to use make code inside a library.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.12 1998/12/05 00:06:27 espie Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.12 1998/12/05 00:06:27 espie Exp $";
d1973 1
a1973 1
	ecp = Str_FindSubstring(cp, commandShell->noPrint);
d2001 1
a2001 1
		ecp = Str_FindSubstring(cp, commandShell->noPrint);
@


1.12
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.10 1998/06/03 17:00:05 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.10 1998/06/03 17:00:05 deraadt Exp $";
d2994 1
d2996 1
@


1.11
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d78 2
d89 1
a89 1
 *	Job_End	  	    	Perform any final processing which needs doing.
d220 2
a221 1
               	*shellName;	      	      	  /* last component of shell */
d1117 1
a1117 2
	    if (p1)
		free(p1);
d2686 4
a2689 1
    words = brk_string(line, &wordCount, TRUE);
d2696 1
a2696 1
    for (path = NULL, argc = wordCount - 1, argv = words + 1;
d2726 1
d2946 1
a2946 1
 * Job_End --
d2959 1
a2959 1
Job_End()
d2979 18
@


1.10
log
@zero sigaction before use
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.9 1998/03/15 22:19:24 flipk Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.9 1998/03/15 22:19:24 flipk Exp $";
d1061 1
a1061 1
		    (void) lseek(streamID, 0L, L_SET);
d1230 1
a1230 1
	(void) lseek(0, 0, L_SET);
@


1.9
log
@fix possibility of null pointer deref when using make's "-j" option.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.8 1997/12/16 22:26:21 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.8 1997/12/16 22:26:21 deraadt Exp $";
d415 1
@


1.8
log
@do not overflow fd_set
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.7 1997/06/15 21:29:22 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.7 1997/06/15 21:29:22 millert Exp $";
d1301 1
a1301 1
		if (obytes != bytes) {
@


1.7
log
@Avoid possible /tmp races by using mkstemp(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.6 1996/11/30 21:08:56 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.6 1996/11/30 21:08:56 millert Exp $";
d232 1
a232 1
static fd_set  	outputs;    	/* Set of descriptors of pipes connected to
d234 1
d704 1
a704 1
	FD_CLR(job->inPipe, &outputs);
d1282 1
a1282 1
	long omask = sigblock(sigmask(SIGCHLD));
d1297 13
a1309 1
	    FD_SET(job->inPipe, &outputs);
a2317 1
    fd_set           	  readfds;
d2349 6
a2354 1
	readfds = outputs;
d2358 3
a2360 2
	if ((nfds = select(FD_SETSIZE, &readfds, (fd_set *) 0,
			   (fd_set *) 0, &timeout)) <= 0)
d2362 1
a2362 1
	else {
d2364 1
d2369 1
a2369 1
		if (FD_ISSET(job->inPipe, &readfds)) {
d2376 1
@


1.6
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: job.c,v 1.5 1996/09/02 16:04:11 briggs Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.5 1996/09/02 16:04:11 briggs Exp $";
d167 2
a168 3
 * used over by removing it before the child shell is executed. The XXXXX in
 * the string are replaced by the pid of the make process in a 5-character
 * field with leading zeroes.
d170 1
a170 1
static char     tfile[] = TMPPAT;
a1664 1
    static int    jobno = 0;  /* job number of catching output in a file */
d1870 1
a1870 2
     * starting a job and then set up its temporary-file name. This is just
     * tfile with two extra digits tacked on -- jobno.
d1884 3
a1886 3
	    sprintf(job->outFile, "%s%02d", tfile, jobno);
	    jobno = (jobno + 1) % 100;
	    job->outFd = open(job->outFile,O_WRONLY|O_CREAT|O_APPEND,0600);
d2402 1
d2404 5
a2408 1
    (void) sprintf(tfile, "/tmp/make%05d", getpid());
@


1.5
log
@Sync up with NetBSD:
(christos)
	Fix bug reported by Greg Hudson where leaf (source only) nodes were
	referenced only by their basename and not by their full pathname. This
	breaks when .PATH or MAKEOBJDIR are used. There might be Makefiles
	around that try to work around this bug by prepending ${.CURDIR} to
	the sources, and they should be found and fixed. Also a lot of the gunk
	in suff.c that was attempting to work around the same problem could be
	removed.
(christos)
	- Move -D flags from Makefile to config.h and explain what they do. Add
	  -Wall -Wno-unused to CFLAGS. Add new define SYSVVARSUB to enable SysV
	  style variable substitutions and enable them.
	- Add SunOS style command substitutions via SUNSHCMD
	- Fix core dump with '{variable = value'
(christos)
	Fix bug where make will always exit with 0, even when one or more
	parallel jobs failed. (Only affects parallel make code)
(christos)
	Protect __P from being multiply defined (for systems that already
	define it)
(christos) Add strdup() since ultrix is missing it.
	From Larry Schwimmer <rosebud@@cyclone.Stanford.EDU>
(christos) Add estrdup(), a checked version of strdup and use it.
(christos) Recognize SVR4 style long filename entries in archives.
(thorpej) Tidy up some RCS ids a bit.
@
text
@d1 2
a2 2
/*	$OpenBSD: job.c,v 1.4 1996/06/26 05:36:32 deraadt Exp $	*/
/*	$NetBSD: job.c,v 1.15 1996/05/29 15:28:05 christos Exp $	*/
d44 1
a44 1
static char sccsid[] = "@@(#)job.c	5.15 (Berkeley) 3/1/91";
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.4 1996/06/26 05:36:32 deraadt Exp $";
a113 1
#include <signal.h>
d124 1
a124 1
# define STATIC 
d132 1
a132 1
 * error handling variables 
d140 1
a140 1
/* 
d169 1
a169 1
 * field with leading zeroes. 
d257 1
a257 1
 * when the next job finishes. 
d274 1
a274 1
/* 
d312 1
d351 1
a351 1
	(void) fprintf(stdout, 
d372 1
a372 1
 *	
d381 1
a381 1
    
d398 1
a398 1
    
d405 1
a405 1
    
d458 1
a458 1
    return( *(int *) pid - ((Job *) job)->pid);
d466 1
a466 1
 *	are equal. 
d529 1
a529 1
    Job           *job = (Job *) jobp;	
d534 1
a534 1
	job->node->type |= OP_SAVE_CMDS; 
d538 1
a538 1
	    return(1);
d540 1
a540 1
	return(0);
d625 1
a625 1
		 * The error ignoration(hee hee) is already taken care
d637 1
a637 1
    
d639 1
a639 1
    
d734 1
a734 1
 *	If we got an error and are aborting(aborting == ABORT_ERROR) and
d736 1
a736 1
 *	If we recognized an error(errors !=0), we set the aborting flag
d780 1
a780 1
	/* 
d798 1
a798 1
    
d805 1
a805 1
	
d851 2
a852 1
		fprintf(out, "*** Stopped -- signal %d\n", WSTOPSIG(*status));
d865 1
a865 1
	     * list to the running one(or re-stop it if concurrency is
d953 1
a953 1
		
d992 1
a992 1
    
d1031 1
a1031 1
    
d1063 1
a1063 1
		
d1077 1
a1077 1
 *	Make sure the given node has all the commands it needs. 
d1091 1
a1091 1
    void    	 (*abortProc) __P((char *, ...));   
d1098 1
a1098 1
	 * commands 
d1121 1
a1121 1
	     * this node's parents so they never get examined. 
d1151 1
a1151 1
 *	
d1157 1
a1157 1
    int	    stream; 	/* Stream that's ready(ignored) */
d1185 1
a1185 1
    
d1188 1
a1188 1
	
d1198 1
a1198 1
    
d1201 1
a1201 1
     * no feedback of their running(since they produce no output, the
d1210 1
a1210 1
    
d1223 1
a1223 1
	 * reset it to the beginning(again). Since the stream was marked
d1230 1
a1230 1
	
d1249 1
a1249 1
	 * duplicated by the dup2(on some systems), so we have to clear
d1273 1
a1273 1
	} else 
d1293 1
a1293 1
	    
d1323 1
a1323 1
jobExecFinish:    
d1339 1
a1339 1
 *	
d1354 1
a1354 1
    
d1393 1
a1393 1
 *	Restart a job that stopped for some reason. 
d1410 1
a1410 1
    
d1484 1
a1484 1
	
d1501 1
a1501 1
	 * as soon as it starts processing commands. 
d1504 1
a1504 1
	
d1513 1
a1513 1
 	    (nLocal < maxLocal && runLocalFirst) 
d1585 1
a1585 1
	     * we haven't reached the local concurrency limit already(or the
d1592 1
a1592 1
	    
d1608 1
a1608 1
		
d1644 1
a1644 1
 *	by the graph node gn. 
d1708 1
a1708 1
    
d1710 1
a1710 1
     * If the -n flag wasn't given, we open up OUR(not the child's)
d1723 1
a1723 1
	
d1752 1
a1752 1
		    
d1781 1
a1781 1
	    
d1825 1
a1825 1
     * If we're not supposed to execute a shell, don't. 
d1920 1
a1920 1
	 * finishes. Note that the special jobs(.BEGIN, .INTERRUPT and .END)
d1922 1
a1922 1
	 *(e.g. when maxLocal == 0), though they will be exported if at
d1927 1
a1927 1
	
d1937 1
a1937 1
	     * If we're running this job locally as a special case(see above),
d1951 1
a1951 1
static char * 
d2014 1
a2014 1
 *	alone on the line(the character after it is not \0 or \n), we
d2034 2
a2035 2
    register int  max;	      	  /* limit for i(end of current data) */
    int		  nRead;      	  /*(Temporary) number of bytes read */
d2040 1
a2040 1
    
d2048 1
a2048 1
	
d2061 1
a2061 1
	 * If we hit the end-of-file(the job is dead), we must flush its
d2073 1
a2073 1
	
d2077 1
a2077 1
	 * TRUE. 
d2091 1
a2091 1
	
d2097 1
a2097 1
		 * but to print the stuff. sigh. 
d2107 1
a2107 1
	     * So long as the line isn't one we should filter(according
d2112 1
a2112 1
	     * to the start of the buffer and curPos is set accordingly. 
d2117 2
a2118 2
  
		cp = JobOutput(job, job->outBuf, &job->outBuf[i]);
d2136 3
a2138 3
		(void) memcpy(job->outBuf, &job->outBuf[i + 1], max -(i + 1));
		job->curPos = max -(i + 1);
		
d2150 5
a2154 4
	     * end-of-file on the pipe. This is guaranteed to happen eventually
	     * since the other end of the pipe is now closed(we closed it
	     * explicitly and the child has exited). When we do get an EOF,
	     * finish will be set FALSE and we'll fall through and out.
d2235 1
a2235 1
    
d2243 1
a2243 1
	    
d2251 1
a2251 1
		    Error("Resumed child(%d) not in table", pid);
d2257 1
a2257 1
		Error("Child(%d) not in table?", pid);
d2292 1
a2292 1
 *	signal(most likely a SIGCHLD) since there's no point in
d2294 1
a2294 1
 *	of a child can wait for a while. 
d2297 1
a2297 1
 *	None 
d2332 1
a2332 1
     * Job_CatchChildren(if nLocal is 0, there's nothing for which to
d2434 1
a2434 1
    
d2473 1
a2473 1
     * we're giving each job its own process group(since then it won't get
d2490 1
a2490 1
    
d2664 1
a2664 1
    
d2720 1
a2720 1
	 * The user provided a path. If s/he gave nothing else(fullSpec is
d2749 1
a2749 1
    
d2758 1
a2758 1
    
d2789 1
a2789 1
    
d2827 1
a2827 1
			       "JobInterrupt passing signal to child %d.\n", 
d2863 1
a2863 1
			   "JobInterrupt passing CONT to stopped child %d.\n", 
d2919 1
a2919 1
 *	attached to the .END target. 
d2925 1
a2925 1
 *	The process' temporary file(tfile) is removed if it still
d2997 1
a2997 1
    
d2999 1
a2999 1
    
d3008 1
a3008 1
	     * darn sure it's dead. 
d3024 1
a3024 1
    
@


1.4
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: job.c,v 1.14 1996/02/04 22:20:42 christos Exp $	*/
/*	$NetBSD: job.c,v 1.14 1996/02/04 22:20:42 christos Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: job.c,v 1.14 1996/02/04 22:20:42 christos Exp $";
d973 1
a973 1
    } else if (*status == 0) {
@


1.3
log
@From NetBSD:
Support SVR4 style archives.
Fix pr/1421 (from Matthew Green) and pr/1997 (from Jeff Thieleke).
In ParseDoInclude(), make a temporary copy of the current file name
while searching for ""-type include files, since the current file name
might not be a writeable string.
@
text
@d1 1
d46 1
a46 1
static char rcsid[] = "$NetBSD: job.c,v 1.14 1996/02/04 22:20:42 christos Exp $";
@


1.2
log
@from christos@@netbsd:
Minor:
    - ${.PREFIX} should never contain a full pathname
    - Fixed gcc -Wall warnings
Major:
    - compatMake is now FALSE. This means that we are now running in
      full pmake mode:
          * rules on dependency lines can be executed in parallel and or
            out of sequence:

            foo: bar baz

            can fire the rule for baz before the rule for bar is fired.
            To enforce bar to be fired before baz, another rule needs to be
            added. [bar: baz]
          * adjacent shell commands in a target are now executed by a single
            invocation of the shell, not one invocation of the shell per line
      (compatMake can be turned off using the -B flag)
    - The -j flag now works... I.e. make -j 4 will fork up to four jobs in
      parallel when it can. The target name is printed before each burst
      of output caused by the target execution as '--- target ---', when j > 1
    - I have changed all the Makefiles so that they work with make -j N, and
      I have tested the whole netbsd by:
          'make -j 4 cleandir; make -j 4 depend; make -j 4; make -j 4 install'
    - I have not compiled or tested this version of make with -DREMOTE.
- Turn compat mode on by default. It gets turned off when the -j without
  the -B flag is specified. [Thus you can use -j 1 to turn it off].
- Fix malloc -> emalloc as Gordon noted.
Updates for POSIX/SVR4 compiling:
arch.c:          Don't require ranlib stuff. Not everybody has it.
dir.c:           SunOS-4 != Solaris; change #ifdef sun to #if sun && !__svr4__
job.c, compat.c: Don't use 'union wait', use int and the W*() macros.
main.c:          Check for uname() == -1; some unames return > 0...
util.c, job.c:   Add signal() with BSD semantics for svr4, don't use bsd
                 sigmask and friends.

from cgd@@netbsd:
pull in make.h.  (PAlloc() now uses emalloc(), which is prototyped in
make.h.  If the prototype is not in scope on the Alpha, I see lots
of "cast to pointer from integer of different size" warnings.)
@
text
@d1 1
a1 1
/*	$NetBSD: job.c,v 1.13 1995/11/22 17:40:09 christos Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: job.c,v 1.13 1995/11/22 17:40:09 christos Exp $";
d112 1
d379 1
d411 7
a417 2
    sigfillset(&nmask);
    (void) sigprocmask(SIG_BLOCK, &nmask, &omask);
d433 3
a435 2
    (void) signal(signo, JobPassSig);

d1020 1
a1020 1
    struct timeval times[2];	/* Times for utimes() call */
d1046 2
a1047 3
	times[0].tv_sec = times[1].tv_sec = now;
	times[0].tv_usec = times[1].tv_usec = 0;
	if (utimes(file, times) < 0){
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: job.c,v 1.11 1995/09/27 18:44:40 jtc Exp $	*/
d45 1
a45 1
static char rcsid[] = "$NetBSD: job.c,v 1.11 1995/09/27 18:44:40 jtc Exp $";
d121 6
d139 5
a155 1

d195 2
d198 1
d205 4
a208 4
    (char *)0,
    FALSE, (char *)0, (char *)0, (char *)0, 0,
    FALSE, (char *)0, (char *)0,
    (char *)0, (char *)0,
d216 1
a216 1
static char   	*shellPath = (char *) NULL,	  /* full pathname of
d223 4
a226 4
int     	nJobs;	    	/* The number of children currently running */
int  		nLocal;    	/* The number of local children */
Lst     	jobs;		/* The structures that describe them */
Boolean		jobFull;    	/* Flag to tell when the job table is full. It
d236 1
a236 1
GNode   	*lastNode;	/* The node for which output was most recently
d238 1
a238 1
char    	*targFmt;   	/* Format string to use to head output from a
d241 10
a250 1
#define TARG_FMT  "--- %s ---\n" /* Default format */
d258 1
a258 1
Lst		stoppedJobs;	/* Lst of Job structures describing
d264 1
a264 1
#define KILL(pid,sig)	killpg (-(pid),(sig))
d267 1
a267 1
#define KILL(pid,sig)	killpg ((pid),(sig))
d269 1
a269 1
#define KILL(pid,sig)	kill ((pid),(sig))
d273 20
d298 8
a305 1
static void JobFinish __P((Job *, union wait));
d307 1
d313 2
a314 1
static void JobInterrupt __P((int));
d339 1
a339 1
	(void)Rmt_Signal(job, signo);
d348 6
d356 1
a356 1
    return(0);
d377 1
a377 1
    int	    mask;
d379 5
a383 1
    Lst_ForEach(jobs, JobCondPassSig, (ClientData)(long)signo);
d391 1
a391 1
	JobInterrupt(TRUE);
d393 1
a393 1
	JobInterrupt(FALSE);
d409 10
a418 3
    mask = sigblock(0);
    (void) sigsetmask(~0 & ~(1 << (signo-1)));
    signal(signo, SIG_DFL);
d420 1
a420 1
    kill(getpid(), signo);
d425 2
a426 2
    sigsetmask(mask);
    signal(signo, JobPassSig);
d445 1
a445 1
JobCmpPid (job, pid)
d449 1
a449 1
    return ( *(int *) pid - ((Job *) job)->pid);
d452 23
d503 1
a503 1
JobPrintCommand (cmdp, jobp)
d522 1
a522 1
    noSpecials = (noExecute && ! (job->node->type & OP_MAKE));
d524 1
a524 1
    if (strcmp (cmd, "...") == 0) {
d527 5
a531 5
	    job->tailCmds = Lst_Succ (Lst_Member (job->node->commands,
						  (ClientData)cmd));
	    return (1);
	}
	return (0);
d534 6
a539 1
#define DBPRINTF(fmt, arg) if (DEBUG(JOB)) printf (fmt, arg); fprintf (job->cmdFILE, fmt, arg)
d547 3
a549 3
    cmdNode = Lst_Member (job->node->commands, (ClientData)cmd);
    cmdStart = cmd = Var_Subst (NULL, cmd, job->node, FALSE);
    Lst_Replace (cmdNode, (ClientData)cmdStart);
d569 1
a569 1
	if (! (job->flags & JOB_SILENT) && !noSpecials &&
d571 1
a571 1
		DBPRINTF ("%s\n", commandShell->echoOff);
d578 1
a578 1
	if ( ! (job->flags & JOB_IGNERR) && !noSpecials) {
d588 1
a588 1
		if (! (job->flags & JOB_SILENT) && !shutUp &&
d590 3
a592 3
			DBPRINTF ("%s\n", commandShell->echoOff);
			DBPRINTF ("%s\n", commandShell->ignErr);
			DBPRINTF ("%s\n", commandShell->echoOn);
d594 1
a594 1
		    DBPRINTF ("%s\n", commandShell->ignErr);
d597 1
a597 1
		       (*commandShell->ignErr != '\0'))
d608 1
a608 1
		if (! (job->flags & JOB_SILENT) && !shutUp &&
d610 2
a611 2
			DBPRINTF ("%s\n", commandShell->echoOff);
			DBPRINTF (commandShell->errCheck, cmd);
d616 1
a616 1
		 * The error ignoration (hee hee) is already taken care
d629 1
a629 1
    DBPRINTF (cmdTemplate, cmd);
d638 1
a638 1
	    DBPRINTF ("%s\n", commandShell->echoOff);
d641 1
a641 1
	DBPRINTF ("%s\n", commandShell->errCheck);
d644 1
a644 1
	DBPRINTF ("%s\n", commandShell->echoOn);
d646 1
a646 1
    return (0);
d664 1
a664 1
JobSaveCommand (cmd, gn)
d668 38
a705 3
    cmd = (ClientData) Var_Subst (NULL, (char *) cmd, (GNode *) gn, FALSE);
    (void)Lst_AtEnd (postCommands->commands, cmd);
    return (0);
d725 1
a725 1
 *	If we got an error and are aborting (aborting == ABORT_ERROR) and
d727 1
a727 1
 *	If we recognized an error (errors !=0), we set the aborting flag
d733 9
a741 9
JobFinish (job, status)
    Job           *job;	      	  /* job to finish */
    union wait	  status;     	  /* sub-why job went away */
{
    Boolean 	  done;

    if ((WIFEXITED(status) &&
	  (((status.w_retcode != 0) && !(job->flags & JOB_IGNERR)))) ||
	(WIFSIGNALED(status) && (status.w_termsig != SIGCONT)))
d751 4
a754 16
	if (usePipes) {
#ifdef RMT_WILL_WATCH
	    Rmt_Ignore(job->inPipe);
#else
	    FD_CLR(job->inPipe, &outputs);
#endif /* RMT_WILL_WATCH */
	    if (job->outPipe != job->inPipe) {
		(void)close (job->outPipe);
	    }
	    JobDoOutput (job, TRUE);
	    (void)close (job->inPipe);
	} else {
	    (void)close (job->outFd);
	    JobDoOutput (job, TRUE);
	}

d756 1
a756 1
	    fclose(job->cmdFILE);
d759 5
a763 1
    } else if (WIFEXITED(status) && status.w_retcode != 0) {
d768 5
a772 1
	 * TRUE if in -B mode and the job exited non-zero. Note we don't
d774 9
a782 3
	 * end.
	 */
	done = TRUE;
d791 2
a792 2
	WIFSTOPPED(status) ||
	(WIFSIGNALED(status) && (status.w_termsig == SIGCONT)) ||
d797 1
a797 1
	if (!usePipes && (job->flags & JOB_IGNERR)) {
d803 1
a803 1
	    out = fdopen (job->outFd, "w");
d808 6
a813 2
	if (WIFEXITED(status)) {
	    if (status.w_retcode != 0) {
d815 1
a815 1
		    fprintf (out, targFmt, job->node->name);
d818 3
a820 2
		fprintf (out, "*** Error code %d%s\n", status.w_retcode,
			 (job->flags & JOB_IGNERR) ? " (ignored)" : "");
d823 1
a823 1
		    status.w_status = 0;
d827 1
a827 1
		    fprintf (out, targFmt, job->node->name);
d830 6
a835 1
		fprintf (out, "*** Completed successfully\n");
a836 1
	} else if (WIFSTOPPED(status)) {
d838 1
a838 1
		fprintf (out, targFmt, job->node->name);
d841 2
a842 2
	    if (! (job->flags & JOB_REMIGRATE)) {
		fprintf (out, "*** Stopped -- signal %d\n", status.w_stopsig);
d846 5
a850 1
	    fflush(out);
d852 1
a852 1
	} else if (status.w_termsig == SIGCONT) {
d855 1
a855 1
	     * list to the running one (or re-stop it if concurrency is
d860 1
a860 1
		    fprintf (out, targFmt, job->node->name);
d863 1
a863 1
		fprintf (out, "*** Continued\n");
d865 14
a878 1
	    if (! (job->flags & JOB_CONTINUING)) {
d880 13
a892 12
	    } else {
		Lst_AtEnd(jobs, (ClientData)job);
		nJobs += 1;
		if (! (job->flags & JOB_REMOTE)) {
		    nLocal += 1;
		}
		if (nJobs == maxJobs) {
		    jobFull = TRUE;
		    if (DEBUG(JOB)) {
			printf("Job queue is full.\n");
		    }
		}
d894 9
a902 2
	    fflush(out);
	    return;
d905 1
a905 1
		fprintf (out, targFmt, job->node->name);
d908 1
a908 1
	    fprintf (out, "*** Signal %d\n", status.w_termsig);
d911 1
a911 1
	fflush (out);
d919 20
a938 24
    if ((status.w_status == 0) &&
	!Lst_IsAtEnd (job->node->commands))
    {
	switch (JobStart (job->node,
			  job->flags & JOB_IGNDOTS,
			  job))
	{
	    case JOB_RUNNING:
		done = FALSE;
		break;
	    case JOB_ERROR:
		done = TRUE;
		status.w_retcode = 1;
		break;
	    case JOB_FINISHED:
		/*
		 * If we got back a JOB_FINISHED code, JobStart has already
		 * called Make_Update and freed the job descriptor. We set
		 * done to false here to avoid fake cycles and double frees.
		 * JobStart needs to do the update so we can proceed up the
		 * graph when given the -n flag..
		 */
		done = FALSE;
		break;
d948 1
a948 1
	(status.w_status == 0))
d957 1
a957 1
	    Lst_ForEachFrom (job->node->commands, job->tailCmds,
d959 1
a959 1
			     (ClientData)job->node);
d962 1
a962 1
	Make_Update (job->node);
d964 1
a964 1
    } else if (status.w_status) {
d969 1
a969 3
    while (!errors && !jobFull && !Lst_IsEmpty(stoppedJobs)) {
	JobRestart((Job *)Lst_DeQueue(stoppedJobs));
    }
d987 2
a988 2
	(void) unlink (tfile);
	Finish (errors);
d1007 1
a1007 1
Job_Touch (gn, silent)
d1023 2
a1024 1
	printf ("touch %s\n", gn->name);
d1032 1
a1032 1
	Arch_Touch (gn);
d1034 1
a1034 1
	Arch_TouchLib (gn);
d1041 1
a1041 1
	    streamID = open (file, O_RDWR | O_CREAT, 0666);
d1051 2
a1052 2
		    lseek(streamID, (off_t) 0, SEEK_SET);
		    write(streamID, &c, 1);
d1055 6
a1060 3
		(void)close (streamID);
	    } else
		printf("*** couldn't touch %s: %s", file, strerror(errno));
d1079 1
a1079 1
Job_CheckCommands (gn, abortProc)
d1082 1
a1082 1
    void    	  (*abortProc) __P((char *, ...));   
d1085 1
a1085 1
    if (OP_NOP(gn->type) && Lst_IsEmpty (gn->commands) &&
d1103 1
a1103 1
	    Var_Set (IMPSRC, Var_Value (TARGET, gn, &p1), gn);
d1106 1
a1106 1
	} else if (Dir_MTime (gn) == 0) {
d1114 2
d1117 2
a1118 2
		printf ("make: don't know how to make %s (ignored)\n",
			gn->name);
d1120 3
a1122 3
		printf ("make: don't know how to make %s (continuing)\n",
			gn->name);
		return (FALSE);
d1124 2
a1125 3
		(*abortProc) ("make: don't know how to make %s. Stop",
			     gn->name);
		return(FALSE);
d1129 1
a1129 1
    return (TRUE);
d1148 1
a1148 1
    int	    stream; 	/* Stream that's ready (ignored) */
d1180 5
a1184 5
	printf("Running %s %sly\n", job->node->name,
	       job->flags&JOB_REMOTE?"remote":"local");
	printf("\tCommand: ");
	for (i = 0; argv[i] != (char *)NULL; i++) {
	    printf("%s ", argv[i]);
d1186 2
a1187 1
	printf("\n");
d1192 1
a1192 1
     * no feedback of their running (since they produce no output, the
d1197 2
a1198 3
	!(job->flags & JOB_SILENT))
    {
	printf(targFmt, job->node->name);
d1208 2
a1209 2
    if ((cpid =  vfork()) == -1) {
	Punt ("Cannot fork");
d1214 1
a1214 1
	 * reset it to the beginning (again). Since the stream was marked
d1217 4
a1220 3
	(void) dup2(fileno(job->cmdFILE), 0);
	fcntl(0, F_SETFD, 0);
	lseek(0, (off_t) 0, SEEK_SET);
d1227 2
a1228 1
	    (void) dup2 (job->outPipe, 1);
d1235 2
a1236 1
	    (void) dup2 (job->outFd, 1);
d1240 1
a1240 1
	 * duplicated by the dup2 (on some systems), so we have to clear
d1244 3
a1246 2
	fcntl(1, F_SETFD, 0);
	(void) dup2 (1, 2);
d1254 6
a1259 3
	
	(void) setpgrp(0, getpid());
#endif USE_PGRP
d1261 10
a1270 4
	(void) execv (shellPath, argv);
	(void) write (2, "Could not execute shell\n",
		 sizeof ("Could not execute shell"));
	_exit (1);
d1272 3
d1293 1
d1295 3
d1301 1
a1301 1
	     * XXX: Used to not happen if CUSTOMS. Why?
d1303 2
a1304 2
	    if (job->cmdFILE != stdout) {
		fclose(job->cmdFILE);
d1308 3
d1320 1
a1320 1
    (void)Lst_AtEnd (jobs, (ClientData)job);
d1378 1
a1378 1
    argv[argc] = (char *)NULL;
d1398 4
d1403 8
a1410 2
	if (DEBUG(JOB)) {
	    printf("Remigrating %x\n", job->pid);
d1412 9
a1420 1
	if (nLocal != maxLocal) {
d1426 8
a1433 3
		if (DEBUG(JOB)) {
		    printf("resuming on local machine\n");
	        }
d1436 4
d1441 1
d1447 8
a1454 3
		if (DEBUG(JOB)) {
		    printf("holding\n");
		}
d1458 2
a1459 1
		    printf("Job queue is full.\n");
d1462 11
d1474 1
d1481 2
a1482 1
		printf("Job queue is full.\n");
d1497 1
a1497 1
	
d1499 2
a1500 1
	    printf("Restarting %s...", job->node->name);
d1502 11
a1512 1
	if (((nLocal >= maxLocal) && ! (job->flags & JOB_SPECIAL))) {
d1518 2
a1519 1
		    printf("holding\n");
d1524 2
a1525 1
		    printf("Job queue is full.\n");
d1528 1
a1528 1
	} else {
d1533 2
a1534 1
		    printf("running locally\n");
d1537 12
d1550 1
d1558 2
a1559 1
	    printf("Resuming %s...", job->node->name);
d1562 10
a1571 4
	     (nLocal < maxLocal) ||
	     (((job->flags & JOB_SPECIAL)) &&
	      (maxLocal == 0))) &&
	    (nJobs != maxJobs))
d1576 1
a1576 1
	     * we haven't reached the local concurrency limit already (or the
d1582 1
a1582 1
	    union wait status;
d1597 2
a1598 2
		status.w_termsig = SIGCONT;
		JobFinish(job, status);
d1602 2
a1603 1
		    printf("done\n");
d1608 3
a1610 3
		status.w_status = 0;
		status.w_retcode = 1;
		JobFinish(job, status);
d1618 2
a1619 1
		printf("table full\n");
d1621 1
a1621 1
	    (void)Lst_AtFront(stoppedJobs, (ClientData)job);
d1624 2
a1625 1
		printf("Job queue is full.\n");
d1648 1
a1648 1
JobStart (gn, flags, previous)
d1662 2
a1663 2
    if (previous != (Job *)NULL) {
	previous->flags &= ~ (JOB_FIRST|JOB_IGNERR|JOB_SILENT|JOB_REMOTE);
d1666 2
a1667 2
	job = (Job *) emalloc (sizeof (Job));
	if (job == (Job *)NULL) {
d1682 1
a1682 1
    if (Targ_Ignore (gn)) {
d1685 1
a1685 1
    if (Targ_Silent (gn)) {
d1694 1
a1694 1
    if (job->flags & JOB_FIRST) {
d1701 1
a1701 1
     * If the -n flag wasn't given, we open up OUR (not the child's)
d1715 3
a1717 3
	job->cmdFILE = fopen (tfile, "w+");
	if (job->cmdFILE == (FILE *) NULL) {
	    Punt ("Could not open %s", tfile);
d1719 1
a1719 1
	fcntl(fileno(job->cmdFILE), F_SETFD, 1);
d1742 1
a1742 1
		LstNode	ln = Lst_Next (gn->commands);
d1745 2
a1746 1
		    JobPrintCommand ((char *)Lst_Datum (ln), job))
d1749 1
a1749 1
		    Lst_Close (gn->commands);
d1763 1
a1763 15
		    if (usePipes) {
#ifdef RMT_WILL_WATCH
			Rmt_Ignore(job->inPipe);
#else
			FD_CLR(job->inPipe, &outputs);
#endif
			if (job->outPipe != job->inPipe) {
			    (void)close (job->outPipe);
			}
			JobDoOutput (job, TRUE);
			(void)close (job->inPipe);
		    } else {
			(void)close (job->outFd);
			JobDoOutput (job, TRUE);
		    }
d1771 1
a1771 1
	    Lst_ForEach (gn->commands, JobPrintCommand, (ClientData)job);
d1787 1
a1787 1
	    printf (targFmt, gn->name);
d1811 1
a1811 1
    	Job_Touch (gn, job->flags&JOB_SILENT);
d1823 3
a1825 2
	    (void) unlink (tfile);
	    fclose(job->cmdFILE);
d1827 1
a1827 1
	    fflush (stdout);
d1839 1
a1839 1
				    (ClientData)job->node);
d1850 2
a1851 2
	fflush (job->cmdFILE);
	(void) unlink (tfile);
d1866 1
a1866 1
    if (job->flags & JOB_FIRST) {
d1869 2
a1870 1
	    (void) pipe(fd); 
d1873 2
a1874 2
	    (void)fcntl (job->inPipe, F_SETFD, 1);
	    (void)fcntl (job->outPipe, F_SETFD, 1);
d1876 3
a1878 3
	    printf ("Remaking `%s'\n", gn->name);
	    fflush (stdout);
	    sprintf (job->outFile, "%s%02d", tfile, jobno);
d1881 1
a1881 1
	    (void)fcntl (job->outFd, F_SETFD, 1);
d1885 13
a1897 1
    local = TRUE;
d1900 7
a1906 2
	 !(job->flags & JOB_SPECIAL) &&
	 (maxLocal != 0))))
d1911 1
a1911 1
	 * finishes. Note that the special jobs (.BEGIN, .INTERRUPT and .END)
d1913 3
a1915 2
	 * (e.g. when maxLocal == 0), though they will be exported if at
	 * all possible. 
d1920 2
a1921 1
	    printf("Can only run job locally.\n");
d1924 1
a1924 1
	(void)Lst_AtEnd(stoppedJobs, (ClientData)job);
d1928 1
a1928 1
	     * If we're running this job locally as a special case (see above),
d1933 2
a1934 1
		printf("Local job queue is full.\n");
d1942 46
d2005 1
a2005 1
 *	alone on the line (the character after it is not \0 or \n), we
d2015 2
a2016 2
static void
JobDoOutput (job, finish)
d2022 1
d2025 2
a2026 2
    register int  max;	      	  /* limit for i (end of current data) */
    int		  nRead;      	  /* (Temporary) number of bytes read */
d2037 2
d2040 1
a2040 1
	nRead = read (job->inPipe, &job->outBuf[job->curPos],
d2052 1
a2052 1
	 * If we hit the end-of-file (the job is dead), we must flush its
d2090 1
a2090 1
		gotNL = TRUE;
d2094 1
a2094 1
	if (gotNL) {
d2098 1
a2098 1
	     * So long as the line isn't one we should filter (according
d2107 3
a2109 39
		register char	*cp, *ecp;

		cp = job->outBuf;
		if (commandShell->noPrint) {
		    ecp = Str_FindSubstring(job->outBuf,
					    commandShell->noPrint);
		    while (ecp != (char *)NULL) {
			if (cp != ecp) {
			    *ecp = '\0';
			    if (job->node != lastNode) {
				printf (targFmt, job->node->name);
				lastNode = job->node;
			    }
			    /*
			     * The only way there wouldn't be a newline after
			     * this line is if it were the last in the buffer.
			     * however, since the non-printable comes after it,
			     * there must be a newline, so we don't print one.
			     */
			    printf ("%s", cp);
			}
			cp = ecp + commandShell->noPLen;
			if (cp != &job->outBuf[i]) {
			    /*
			     * Still more to print, look again after skipping
			     * the whitespace following the non-printable
			     * command....
			     */
			    cp++;
			    while (*cp == ' ' || *cp == '\t' || *cp == '\n') {
				cp++;
			    }
			    ecp = Str_FindSubstring (cp,
						     commandShell->noPrint);
			} else {
			    break;
			}
		    }
		}
d2118 1
a2118 1
			printf (targFmt, job->node->name);
d2121 2
a2122 1
		    printf ("%s\n", cp);
a2123 2

		fflush (stdout);
d2127 2
a2128 2
		memcpy ( job->outBuf, &job->outBuf[i + 1], max - (i + 1));
		job->curPos = max - (i + 1);
d2142 1
a2142 1
	     * since the other end of the pipe is now closed (we closed it
d2159 6
a2164 5
	oFILE = fopen (job->outFile, "r");
	if (oFILE != (FILE *) NULL) {
	    printf ("Results of making %s:\n", job->node->name);
	    while (fgets (inLine, sizeof(inLine), oFILE) != NULL) {
		register char	*cp, *ecp, *endp;
d2167 1
a2167 1
		endp = inLine + strlen(inLine);
d2171 1
a2171 30
		if (commandShell->noPrint) {
		    ecp = Str_FindSubstring(cp, commandShell->noPrint);
		    while (ecp != (char *)NULL) {
			if (cp != ecp) {
			    *ecp = '\0';
			    /*
			     * The only way there wouldn't be a newline after
			     * this line is if it were the last in the buffer.
			     * however, since the non-printable comes after it,
			     * there must be a newline, so we don't print one.
			     */
			    printf ("%s", cp);
			}
			cp = ecp + commandShell->noPLen;
			if (cp != endp) {
			    /*
			     * Still more to print, look again after skipping
			     * the whitespace following the non-printable
			     * command....
			     */
			    cp++;
			    while (*cp == ' ' || *cp == '\t' || *cp == '\n') {
				cp++;
			    }
			    ecp = Str_FindSubstring(cp, commandShell->noPrint);
			} else {
			    break;
			}
		    }
		}
d2178 5
a2182 2
		if (*cp != '\0') {
		    printf ("%s\n", cp);
d2185 2
a2186 2
	    fclose (oFILE);
	    (void) unlink (job->outFile);
a2188 1
    fflush(stdout);
d2211 1
a2211 1
Job_CatchChildren (block)
d2217 1
a2217 1
    union wait	  status;   	/* Exit/termination status */
d2226 2
a2227 2
    while ((pid = wait3((int *)&status, (block?0:WNOHANG)|WUNTRACED,
			(struct rusage *)0)) > 0)
d2229 4
a2232 2
	if (DEBUG(JOB))
	    printf("Process %d exited or stopped.\n", pid);
d2235 1
a2235 1
	jnode = Lst_Find (jobs, (ClientData)&pid, JobCmpPid);
d2238 1
a2238 1
	    if (WIFSIGNALED(status) && (status.w_termsig == SIGCONT)) {
d2241 1
a2241 1
		    Error("Resumed child (%d) not in table", pid);
d2245 1
a2245 1
		(void)Lst_Remove(stoppedJobs, jnode);
d2247 1
a2247 1
		Error ("Child (%d) not in table?", pid);
d2251 2
a2252 2
	    job = (Job *) Lst_Datum (jnode);
	    (void)Lst_Remove (jobs, jnode);
d2255 2
a2256 1
		printf("Job queue is no longer full.\n");
d2259 10
d2270 1
d2273 1
a2273 1
	JobFinish (job, status);
d2282 1
a2282 1
 *	signal (most likely a SIGCHLD) since there's no point in
d2294 1
a2294 1
Job_CatchOutput ()
d2305 1
a2305 1
    fflush(stdout);
d2322 1
a2322 1
     * Job_CatchChildren (if nLocal is 0, there's nothing for which to
d2334 2
a2335 2
	if ((nfds = select (FD_SETSIZE, &readfds, (fd_set *) 0, (fd_set *) 0, &timeout)) < 0)
	{
d2337 3
a2339 3
	} else {
	    if (Lst_Open (jobs) == FAILURE) {
		Punt ("Cannot open job table");
d2341 2
a2342 2
	    while (nfds && (ln = Lst_Next (jobs)) != NILLNODE) {
		job = (Job *) Lst_Datum (ln);
d2344 1
a2344 1
		    JobDoOutput (job, FALSE);
d2348 1
a2348 1
	    Lst_Close (jobs);
d2369 1
a2369 1
Job_Make (gn)
d2372 1
a2372 1
    (void)JobStart (gn, 0, (Job *)NULL);
d2388 1
a2388 1
Job_Init (maxproc, maxlocal)
d2396 1
a2396 1
    sprintf (tfile, "/tmp/make%05d", getpid());
d2398 1
a2398 1
    jobs =  	  Lst_Init (FALSE);
d2411 5
a2415 1
    if (maxJobs == 1) {
d2425 1
a2425 1
    if (shellPath == (char *) NULL) {
d2434 1
a2434 1
	shellPath = str_concat (_PATH_DEFSHELLDIR, shellName, STR_ADDSLASH);
d2437 1
a2437 1
    if (commandShell->exit == (char *)NULL) {
d2440 1
a2440 1
    if (commandShell->echo == (char *)NULL) {
d2448 2
a2449 2
    if (signal (SIGINT, SIG_IGN) != SIG_IGN) {
	signal (SIGINT, JobPassSig);
d2451 2
a2452 2
    if (signal (SIGHUP, SIG_IGN) != SIG_IGN) {
	signal (SIGHUP, JobPassSig);
d2454 2
a2455 2
    if (signal (SIGQUIT, SIG_IGN) != SIG_IGN) {
	signal (SIGQUIT, JobPassSig);
d2457 2
a2458 2
    if (signal (SIGTERM, SIG_IGN) != SIG_IGN) {
	signal (SIGTERM, JobPassSig);
d2463 1
a2463 1
     * we're giving each job its own process group (since then it won't get
d2467 2
a2468 2
    if (signal (SIGTSTP, SIG_IGN) != SIG_IGN) {
	signal (SIGTSTP, JobPassSig);
d2470 2
a2471 2
    if (signal (SIGTTOU, SIG_IGN) != SIG_IGN) {
	signal (SIGTTOU, JobPassSig);
d2473 2
a2474 2
    if (signal (SIGTTIN, SIG_IGN) != SIG_IGN) {
	signal (SIGTTIN, JobPassSig);
d2476 2
a2477 2
    if (signal (SIGWINCH, SIG_IGN) != SIG_IGN) {
	signal (SIGWINCH, JobPassSig);
d2481 1
a2481 1
    begin = Targ_FindNode (".BEGIN", TARG_NOCREATE);
d2484 1
a2484 1
	JobStart (begin, JOB_SPECIAL, (Job *)0);
d2488 1
a2488 1
	    Job_CatchChildren (!usePipes);
d2492 1
a2492 1
    postCommands = Targ_FindNode (".END", TARG_CREATE);
d2510 1
a2510 1
Job_Full ()
d2512 1
a2512 1
    return (aborting || jobFull);
d2532 1
a2532 1
Job_Empty ()
d2541 1
a2541 3
	    while (!jobFull && !Lst_IsEmpty(stoppedJobs)) {
		JobRestart((Job *)Lst_DeQueue(stoppedJobs));
	    }
d2565 1
a2565 1
JobMatchShell (name)
d2574 1
a2574 1
    eoname = name + strlen (name);
d2576 1
a2576 1
    match = (Shell *) NULL;
d2579 1
a2579 1
	for (cp1 = eoname - strlen (sh->name), cp2 = sh->name;
d2586 2
a2587 3
	} else if (match == (Shell *) NULL ||
		   strlen (match->name) < strlen (sh->name)) {
		       match = sh;
d2590 1
a2590 1
    return (match == (Shell *) NULL ? sh : match);
d2637 1
a2637 1
Job_ParseShell (line)
d2648 1
a2648 1
    while (isspace (*line)) {
d2651 1
a2651 1
    words = brk_string (line, &wordCount, TRUE);
d2653 1
a2653 1
    memset ((Address)&newShell, 0, sizeof(newShell));
d2658 1
a2658 1
    for (path = (char *)NULL, argc = wordCount - 1, argv = words + 1;
d2661 1
a2661 1
	     if (strncmp (*argv, "path=", 5) == 0) {
d2663 1
a2663 1
	     } else if (strncmp (*argv, "name=", 5) == 0) {
d2666 1
a2666 1
		 if (strncmp (*argv, "quiet=", 6) == 0) {
d2668 1
a2668 1
		 } else if (strncmp (*argv, "echo=", 5) == 0) {
d2670 1
a2670 1
		 } else if (strncmp (*argv, "filter=", 7) == 0) {
d2673 1
a2673 1
		 } else if (strncmp (*argv, "echoFlag=", 9) == 0) {
d2675 1
a2675 1
		 } else if (strncmp (*argv, "errFlag=", 8) == 0) {
d2677 1
a2677 1
		 } else if (strncmp (*argv, "hasErrCtl=", 10) == 0) {
d2680 2
a2681 2
					    (c != 'T') && (c != 't'));
		 } else if (strncmp (*argv, "check=", 6) == 0) {
d2683 1
a2683 1
		 } else if (strncmp (*argv, "ignore=", 7) == 0) {
d2686 1
a2686 1
		     Parse_Error (PARSE_FATAL, "Unknown keyword \"%s\"",
d2688 1
a2688 1
		     return (FAILURE);
d2694 1
a2694 1
    if (path == (char *)NULL) {
d2701 3
a2703 3
	if (newShell.name == (char *)NULL) {
	    Parse_Error (PARSE_FATAL, "Neither path nor name specified");
	    return (FAILURE);
d2705 1
a2705 1
	    commandShell = JobMatchShell (newShell.name);
d2710 1
a2710 1
	 * The user provided a path. If s/he gave nothing else (fullSpec is
d2717 2
a2718 2
	path = strrchr (path, '/');
	if (path == (char *)NULL) {
d2723 1
a2723 1
	if (newShell.name != (char *)NULL) {
d2729 1
a2729 1
	    commandShell = JobMatchShell (shellName);
d2741 1
a2741 1
	if (commandShell->errCheck == (char *)NULL) {
d2744 1
a2744 1
	if (commandShell->ignErr == (char *)NULL) {
d2753 1
a2753 1
    free (words);
d2771 1
a2771 1
JobInterrupt (runINTERRUPT)
d2774 1
d2782 3
a2784 3
    (void)Lst_Open (jobs);
    while ((ln = Lst_Next (jobs)) != NILLNODE) {
	job = (Job *) Lst_Datum (ln);
d2786 2
a2787 2
	if (!Targ_Precious (job->node)) {
	    char  	*file = (job->node->path == (char *)NULL ?
d2790 2
a2791 4
	    struct stat st;
	    if (!noExecute && lstat(file, &st) != -1 && !S_ISDIR(st.st_mode) && 
		unlink(file) != -1) {
		Error ("*** %s removed", file);
d2799 1
a2799 1
	    if (!Rmt_Signal(job, SIGINT)) {
d2804 1
a2804 1
		union wait status;
d2808 1
a2808 1
		JobFinish(job, status);
d2811 1
a2811 1
	    KILL(job->pid, SIGINT);
d2815 65
d2884 2
a2885 1
    Lst_Close (jobs);
d2888 1
a2888 1
	interrupt = Targ_FindNode (".INTERRUPT", TARG_NOCREATE);
d2892 1
a2892 1
	    JobStart (interrupt, JOB_IGNDOTS, (Job *)0);
d2896 1
a2896 1
		Job_CatchChildren (!usePipes);
d2901 2
a2902 2
    (void) unlink (tfile);
    exit (0);
d2915 1
a2915 1
 *	The process' temporary file (tfile) is removed if it still
d2920 1
a2920 1
Job_End ()
d2922 1
a2922 1
    if (postCommands != NILGNODE && !Lst_IsEmpty (postCommands->commands)) {
d2924 1
a2924 1
	    Error ("Errors reported so .END ignored");
d2926 1
a2926 2
	    JobStart (postCommands, JOB_SPECIAL | JOB_IGNDOTS,
		       (Job *)0);
d2931 1
a2931 1
		Job_CatchChildren (!usePipes);
d2936 1
a2936 1
    (void) unlink (tfile);
d2982 1
a2982 1
Job_AbortAll ()
d2984 1
a2984 1
    LstNode           	ln;		/* element in job table */
d2992 3
a2994 3
	(void)Lst_Open (jobs);
	while ((ln = Lst_Next (jobs)) != NILLNODE) {
	    job = (Job *) Lst_Datum (ln);
d3018 1
a3018 1
    while (wait3(&foo, WNOHANG, (struct rusage *)0) > 0)
d3020 82
a3101 1
    (void) unlink (tfile);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

