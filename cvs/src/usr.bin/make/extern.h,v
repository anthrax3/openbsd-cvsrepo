head	1.43;
access;
symbols
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.43.0.26
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.22
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.24
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.43.0.16
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.43.0.20
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.43.0.18
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.14
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.12
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.10
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.8
	OPENBSD_5_0:1.43.0.6
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.4
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.41.0.8
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.41.0.10
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.6
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.41.0.4
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.39.0.18
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.39.0.16
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.39.0.14
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.39.0.12
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.39.0.10
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.39.0.8
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.39.0.6
	OPENBSD_3_6_BASE:1.39
	OPENBSD_3_5:1.39.0.4
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	OPENBSD_3_3:1.38.0.8
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.38.0.6
	OPENBSD_3_2_BASE:1.38
	OPENBSD_3_1:1.38.0.4
	OPENBSD_3_1_BASE:1.38
	OPENBSD_3_0:1.38.0.2
	OPENBSD_3_0_BASE:1.38
	OPENBSD_2_9_BASE:1.36
	OPENBSD_2_9:1.36.0.2
	OPENBSD_2_8:1.34.0.2
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.17.12.42.09;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.17.12.01.16;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.23.12.34.42;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.03.13.41.05;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2000.11.24.14.36.34;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.24.14.29.55;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.13.08.30.51;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.14.13.52.42;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.14.13.40.03;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.14.13.35.38;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2000.09.14.13.32.06;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.18.20.17.19;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.17.22.57.37;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.23.16.41.53;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.23.16.23.26;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.23.16.20.01;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.23.16.18.09;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.17.14.40.28;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.10.01.41.05;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.10.01.32.22;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.17.23.45.23;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.02.13.47.47;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.08.09.45.15;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	99.12.16.17.27.18;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	99.12.16.17.07.20;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	99.12.09.18.20.06;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	99.12.06.23.16.56;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	99.12.06.22.28.44;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	99.12.06.22.18.56;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.11.11.11.47.27;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.11.11.11.42.19;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	99.11.11.11.35.17;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	99.11.11.11.33.02;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	98.12.05.00.06.28;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	96.11.30.21.09.01;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.02.16.04.16;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.36.35;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.23.43.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.23.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Correct $OpenBSD$ stuff
@
text
@#ifndef EXTERN_H
#define EXTERN_H

/*	$OpenBSD: extern.h,v 1.42 2010/07/19 19:30:37 espie Exp $	*/
/*	$NetBSD: nonints.h,v 1.12 1996/11/06 17:59:19 christos Exp $	*/

/*-
 * Copyright (c) 1988, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)nonints.h	8.3 (Berkeley) 3/19/94
 */

extern bool	compatMake;	/* True if we are make compatible */
extern bool	ignoreErrors;	/* True if should ignore all errors */
extern bool	beSilent;	/* True if should print no commands */
extern bool	noExecute;	/* True if should execute nothing */
extern bool	allPrecious;	/* True if every target is precious */
extern bool	keepgoing;	/* True if should continue on unaffected
				 * portions of the graph when have an error
				 * in one portion */
extern bool	touchFlag;	/* true if targets should just be 'touched'
				 * if out of date. Set by the -t flag */
extern bool	queryFlag;	/* true if we aren't supposed to really make
				 * anything, just see if the targets are out-
				 * of-date */

#endif
@


1.42
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d4 1
a4 2
/*	$OpenPackages$ */
/*	$OpenBSD$	*/
@


1.41
log
@rewrite of the basic suffix/target parsing: use hash for suffixes.

Store special targets in target hash, and use them for the parsing.

Use OP_DUMMY flag to mark targets that don't really exist yet, such
as interrupt and default nodes.

Also, .PATHxxx is special in suffixes.

Small tweaks to compat.c, so that run_commands does more stuff after
the fork() (and thus no need to free things).

Remove distinction between local and global jobs.
@
text
@d5 1
a5 1
/*	$OpenBSD: extern.h,v 1.39 2003/06/03 02:56:11 millert Exp $	*/
@


1.40
log
@make usePipes the default, zap undocumented -P.
@
text
@@


1.39
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d5 1
a5 1
/*	$OpenBSD: extern.h,v 1.38 2001/05/23 12:34:42 espie Exp $	*/
a53 4
extern bool	usePipes;	/* true if should capture the output of
				 * subshells by means of pipes. Otherwise it
				 * is routed to temporary files from which it
				 * is retrieved when the shell exits */
@


1.38
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d5 1
a5 1
/*	$OpenBSD: nonints.h,v 1.7 1998/12/05 00:06:28 espie Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.37
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d1 3
d48 17
a64 142
/* arch.c */
extern ReturnStatus Arch_ParseArchive(char **, Lst, SymTable *);
extern void Arch_Touch(GNode *);
extern void Arch_TouchLib(GNode *);
extern TIMESTAMP Arch_MTime(GNode *);
extern TIMESTAMP Arch_MemMTime(GNode *);
extern void Arch_FindLib(GNode *, Lst);
extern Boolean Arch_LibOODate(GNode *);
extern void Arch_Init(void);
extern void Arch_End(void);
extern Boolean Arch_IsLib(GNode *);

/* compat.c */
extern void Compat_Run(Lst);

/* cond.c */
extern int Cond_Eval(char *);
extern void Cond_End(void);

#include "error.h"

/* for.c */
typedef struct For_ For;
extern For *For_Eval(const char *);
extern Boolean For_Accumulate(For *, const char *);
extern void For_Run (For *);

/* main.c */
extern void Main_ParseArgLine(char *);
extern char *Cmd_Exec(const char *, char **);
extern void Error(char *, ...);
extern void Fatal(char *, ...);
extern void Punt(char *, ...);
extern void DieHorribly(void);
extern void PrintAddr(void *);
extern void Finish(int);

/* make.c */
extern void Make_TimeStamp(GNode *, GNode *);
extern Boolean Make_OODate(GNode *);
extern void Make_HandleUse(GNode *, GNode *);
extern void Make_Update(GNode *);
extern void Make_DoAllVar(GNode *);
extern Boolean Make_Run(Lst);

/* parse.c */
extern void Parse_Error(int, char *, ...);
extern Boolean Parse_AnyExport(void);
extern Boolean Parse_IsVar(char *);
extern void Parse_DoVar(const char *, GSymT *);
extern void Parse_AddIncludeDir(const char *);
extern void Parse_File(char *, FILE *);
extern void Parse_Init(void);
extern void Parse_End(void);
extern void Parse_FromString(char *, unsigned long);
extern unsigned long Parse_Getlineno(void);
extern const char *Parse_Getfilename(void);
extern void Parse_MainName(Lst);

/* stats.h */
extern void Init_Stats(void);

/* str.c */
extern void str_init(void);
extern void str_end(void);
extern char *lastchar(const char *, const char *, int);
extern char *str_concati(const char *, const char *, const char *, int);
#define str_concat(s1, s2, sep) str_concati(s1, s2, strchr(s2, '\0'), sep)
extern char **brk_string(const char *, int *, char **);
extern const char *iterate_words(const char **);
extern Boolean Str_Matchi(const char *, const char *, const char *);
#define Str_Match(string, pattern) \
	Str_Matchi(string, pattern, strchr(pattern, '\0'))
extern const char *Str_SYSVMatch(const char *, const char *, size_t *);
extern void Str_SYSVSubst(Buffer, const char *, const char *, size_t);
extern char *interval_dup(const char *, const char *);
extern char *escape_dup(const char *, const char *, const char *);

/* suff.c */
extern void Suff_ClearSuffixes(void);
extern Boolean Suff_IsTransform(const char *);
extern GNode *Suff_AddTransform(const char *);
extern void Suff_EndTransform(void *);
extern void Suff_AddSuffix(char *);
extern Lst Suff_GetPath(char *);
extern void Suff_DoPaths(void);
extern void Suff_AddInclude(char *);
extern void Suff_AddLib(char *);
extern void Suff_FindDeps(GNode *);
extern void Suff_SetNull(char *);
extern void Suff_Init(void);
extern void Suff_End(void);
extern void Suff_PrintAll(void);

/* targ.c */
extern void Targ_Init(void);
extern void Targ_End(void);
extern GNode *Targ_NewGN(const char *, const char *);
extern GNode *Targ_FindNode(const char *, const char *, int);
extern void Targ_FindList(Lst, Lst);
extern Boolean Targ_Ignore(GNode *);
extern Boolean Targ_Silent(GNode *);
extern Boolean Targ_Precious(GNode *);
extern void Targ_SetMain(GNode *);
extern void Targ_PrintCmd(void *);
extern char *Targ_FmtTime(TIMESTAMP);
extern void Targ_PrintType(int);
extern void Targ_PrintGraph(int);

/* var.c */
extern void Var_Delete(const char *);
extern void Var_Set_interval(const char *, const char *, const char *,
	GSymT *);
extern void Varq_Set(int, const char *, GNode *);
extern void Var_Append_interval(const char *, const char *,
	const char *, GSymT  *);
extern void Varq_Append(int, const char *, GNode *);
extern char *Var_Value_interval(const char *, const char *);
extern char *Varq_Value(int,  GNode *);
extern char *Var_Parse(const char *, SymTable *, Boolean, size_t *,
	Boolean *);
extern size_t Var_ParseSkip(const char *, SymTable *, ReturnStatus *);
extern ReturnStatus Var_ParseBuffer(Buffer, const char *, SymTable *,
	Boolean, size_t *);
extern char *Var_Subst(const char *, SymTable *, Boolean);
extern void Var_SubstVar(Buffer, const char *, const char *, const char *);
extern void Var_Init(void);
extern void Var_End(void);
extern void Var_Dump(void);
extern void SymTable_Init(SymTable *);
extern void SymTable_Destroy(SymTable *);
#define Var_Set(n, v, ctxt)	Var_Set_interval(n, NULL, v, ctxt)
#define Var_Append(n, v, ctxt)	Var_Append_interval(n, NULL, v, ctxt)
#define Var_Value(n)	Var_Value_interval(n, NULL)
extern void Var_AddCmdline(const char *);

/* Used to store temporary names, after $ expansion */
struct Name {
	const char 	*s;
	const char 	*e;
	Boolean		tofree;
};
d66 1
a66 3
extern const char *Var_Name_Get(const char *, struct Name *, SymTable *, 
    Boolean, const char *(*)(const char *));
extern void Var_Name_Free(struct Name *);
@


1.36
log
@Change the time stamp interface to use an abstract datatype.
Define two possible interfaces: the classic one,
and the new one (used where available) that depends on timespec.

Better granularity, make is now able to distinguish between files that
were built during the same second.
@
text
@d1 2
a2 1
/*	$OpenBSD: extern.h,v 1.35 2000/11/24 14:29:55 espie Exp $	*/
d46 10
a55 10
extern ReturnStatus Arch_ParseArchive __P((char **, Lst, SymTable *));
extern void Arch_Touch __P((GNode *));
extern void Arch_TouchLib __P((GNode *));
extern TIMESTAMP Arch_MTime __P((GNode *));
extern TIMESTAMP Arch_MemMTime __P((GNode *));
extern void Arch_FindLib __P((GNode *, Lst));
extern Boolean Arch_LibOODate __P((GNode *));
extern void Arch_Init __P((void));
extern void Arch_End __P((void));
extern int Arch_IsLib __P((GNode *));
d58 1
a58 1
extern void Compat_Run __P((Lst));
d61 2
a62 2
extern int Cond_Eval __P((char *));
extern void Cond_End __P((void));
d68 3
a70 3
extern For *For_Eval __P((char *));
extern Boolean For_Accumulate __P((For *, const char *));
extern void For_Run  __P((For *));
d73 8
a80 8
extern void Main_ParseArgLine __P((char *));
extern char *Cmd_Exec __P((char *, char **));
extern void Error __P((char *, ...));
extern void Fatal __P((char *, ...));
extern void Punt __P((char *, ...));
extern void DieHorribly __P((void));
extern void PrintAddr __P((void *));
extern void Finish __P((int));
d83 6
a88 6
extern void Make_TimeStamp __P((GNode *, GNode *));
extern Boolean Make_OODate __P((GNode *));
extern void Make_HandleUse __P((GNode *, GNode *));
extern void Make_Update __P((GNode *));
extern void Make_DoAllVar __P((GNode *));
extern Boolean Make_Run __P((Lst));
d91 15
a105 12
extern void Parse_Error __P((int, char *, ...));
extern Boolean Parse_AnyExport __P((void));
extern Boolean Parse_IsVar __P((char *));
extern void Parse_DoVar __P((char *, GSymT *));
extern void Parse_AddIncludeDir __P((char *));
extern void Parse_File __P((char *, FILE *));
extern void Parse_Init __P((void));
extern void Parse_End __P((void));
extern void Parse_FromString __P((char *, unsigned long));
extern void Parse_MainName __P((Lst));
extern unsigned long Parse_Getlineno __P((void));
extern const char *Parse_Getfilename __P((void));
d108 14
a121 10
extern void str_init __P((void));
extern void str_end __P((void));
extern char *str_concat __P((const char *, const char *, char));
extern char **brk_string __P((const char *, int *, Boolean, char **));
extern const char *iterate_words __P((const char **));
extern int Str_Match __P((const char *, const char *));
extern const char *Str_SYSVMatch __P((const char *, const char *, size_t *len));
extern void Str_SYSVSubst __P((Buffer, const char *, const char *, size_t));
extern char *interval_dup __P((const char *begin, const char *end));
extern char *escape_dup __P((const char *, const char *, const char *));
d124 14
a137 14
extern void Suff_ClearSuffixes __P((void));
extern Boolean Suff_IsTransform __P((char *));
extern GNode *Suff_AddTransform __P((char *));
extern void Suff_EndTransform __P((void *));
extern void Suff_AddSuffix __P((char *));
extern Lst Suff_GetPath __P((char *));
extern void Suff_DoPaths __P((void));
extern void Suff_AddInclude __P((char *));
extern void Suff_AddLib __P((char *));
extern void Suff_FindDeps __P((GNode *));
extern void Suff_SetNull __P((char *));
extern void Suff_Init __P((void));
extern void Suff_End __P((void));
extern void Suff_PrintAll __P((void));
d140 13
a152 13
extern void Targ_Init __P((void));
extern void Targ_End __P((void));
extern GNode *Targ_NewGN __P((const char *, const char *));
extern GNode *Targ_FindNode __P((const char *, int));
extern void Targ_FindList __P((Lst, Lst));
extern Boolean Targ_Ignore __P((GNode *));
extern Boolean Targ_Silent __P((GNode *));
extern Boolean Targ_Precious __P((GNode *));
extern void Targ_SetMain __P((GNode *));
extern void Targ_PrintCmd __P((void *));
extern char *Targ_FmtTime __P((TIMESTAMP));
extern void Targ_PrintType __P((int));
extern void Targ_PrintGraph __P((int));
d155 36
a190 21
extern void Var_Delete __P((const char *, GSymT *));
extern void Var_Set __P((const char *, const char *, GSymT *));
extern void Varq_Set __P((int, const char *, GNode *));
extern void Var_Append __P((const char *, const char *, GSymT *));
extern void Varq_Append __P((int, const char *, GNode *));
extern Boolean Var_Exists __P((const char *, GSymT *));
extern Boolean Varq_Exists __P((int, GNode *));
extern char *Var_Value __P((const char *, GSymT *));
extern char *Varq_Value __P((int,  GNode *));
extern char *Var_Parse __P((char *, SymTable *, Boolean, size_t *, Boolean *));
extern char *Var_Subst __P((char *, SymTable *, Boolean));
extern char *Var_SubstVar __P((const char *, const char *, const char *, 
	size_t));
extern char *Var_GetTail __P((char *));
extern char *Var_GetHead __P((char *));
extern void Var_Init __P((void));
extern void Var_End __P((void));
extern void Var_Dump __P((GSymT *));
extern void SymTable_Init __P((SymTable *));
extern void SymTable_Destroy __P((SymTable *));
extern void Var_AddCmdline __P((const char *));
@


1.35
log
@Take advantage of VarModifiers_Apply, which can parse a variable spec
and expand it directly, without needing a variable context.

Use it in Var_SubstVar, so that .for loops values don't need to be entered
into any context nor looked up.

This speeds up .for loops some, and avoids nasty variable capture
side-effects.

Ok'd millert@@, miod@@, naddy@@   (naddy spotted a problem with the first
version of that change).
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.34 2000/10/13 08:30:51 espie Exp $	*/
d142 1
a142 1
extern char *Targ_FmtTime __P((time_t));
@


1.34
log
@Fix Arch_MemMTime (previous change I did was bogus)
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.33 2000/09/14 13:52:42 espie Exp $	*/
d158 2
a159 1
extern void Var_SubstVar __P((Buffer, char *, const char *, GSymT *));
@


1.33
log
@Introduce a few macros to handle timestamps in an abstract way.

Replace the time stamp hash in dir.c with an open hashing structure.

In doing so, remove some nasty casts, simplify code a bit:
Dir_MTime can return a modification time, since make does not make
a distinction between out-of-date and non-existent files.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.32 2000/09/14 13:40:03 espie Exp $	*/
d49 1
a49 1
extern Boolean Arch_MemMTime __P((GNode *));
@


1.32
log
@Use the new hash scheme to store the target nodes.
Scrap the list of all targets: it only slows make down.
The only visible difference is that the list of all targets is not
shown in order when debugging.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.31 2000/09/14 13:35:38 espie Exp $	*/
d48 1
a48 1
extern Boolean Arch_MTime __P((GNode *));
@


1.31
log
@Two new functions:

iterate_words: light-weight equivalent to brk_string,
which does not need to copy the string, and does not do \ interpretation
which are only needed for the string.

escape_dup: handles escape sequence in a systematic way.

This speeds up variable modifiers.

This also makes .for loops more consistent, as they use the same definition
of `a word' as the rest of make.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.30 2000/09/14 13:32:06 espie Exp $	*/
d134 2
a135 2
extern GNode *Targ_NewGN __P((char *));
extern GNode *Targ_FindNode __P((char *, int));
@


1.30
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.29 2000/07/18 20:17:19 espie Exp $	*/
d108 1
d113 1
@


1.29
log
@Handle MAKEFLAGS variation mandated by POSIX.

Code to pass variable definitions to submakes through make flags.
Not activated yet, need to fix src/ first.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.28 2000/07/17 22:57:37 espie Exp $	*/
d45 10
a54 10
ReturnStatus Arch_ParseArchive __P((char **, Lst, SymTable *));
void Arch_Touch __P((GNode *));
void Arch_TouchLib __P((GNode *));
Boolean Arch_MTime __P((GNode *));
Boolean Arch_MemMTime __P((GNode *));
void Arch_FindLib __P((GNode *, Lst));
Boolean Arch_LibOODate __P((GNode *));
void Arch_Init __P((void));
void Arch_End __P((void));
int Arch_IsLib __P((GNode *));
d57 1
a57 1
void Compat_Run __P((Lst));
d60 2
a61 2
int Cond_Eval __P((char *));
void Cond_End __P((void));
d67 3
a69 3
For *For_Eval __P((char *));
Boolean For_Accumulate __P((For *, const char *));
void For_Run  __P((For *));
d72 8
a79 8
void Main_ParseArgLine __P((char *));
char *Cmd_Exec __P((char *, char **));
void Error __P((char *, ...));
void Fatal __P((char *, ...));
void Punt __P((char *, ...));
void DieHorribly __P((void));
void PrintAddr __P((void *));
void Finish __P((int));
d82 6
a87 6
void Make_TimeStamp __P((GNode *, GNode *));
Boolean Make_OODate __P((GNode *));
void Make_HandleUse __P((GNode *, GNode *));
void Make_Update __P((GNode *));
void Make_DoAllVar __P((GNode *));
Boolean Make_Run __P((Lst));
d90 12
a101 12
void Parse_Error __P((int, char *, ...));
Boolean Parse_AnyExport __P((void));
Boolean Parse_IsVar __P((char *));
void Parse_DoVar __P((char *, GSymT *));
void Parse_AddIncludeDir __P((char *));
void Parse_File __P((char *, FILE *));
void Parse_Init __P((void));
void Parse_End __P((void));
void Parse_FromString __P((char *, unsigned long));
void Parse_MainName __P((Lst));
unsigned long Parse_Getlineno __P((void));
const char *Parse_Getfilename __P((void));
d104 8
a111 8
void str_init __P((void));
void str_end __P((void));
char *str_concat __P((const char *, const char *, char));
char **brk_string __P((const char *, int *, Boolean, char **));
int Str_Match __P((const char *, const char *));
const char *Str_SYSVMatch __P((const char *, const char *, size_t *len));
void Str_SYSVSubst __P((Buffer, const char *, const char *, size_t));
char *interval_dup __P((const char *begin, const char *end));
d114 14
a127 14
void Suff_ClearSuffixes __P((void));
Boolean Suff_IsTransform __P((char *));
GNode *Suff_AddTransform __P((char *));
void Suff_EndTransform __P((void *));
void Suff_AddSuffix __P((char *));
Lst Suff_GetPath __P((char *));
void Suff_DoPaths __P((void));
void Suff_AddInclude __P((char *));
void Suff_AddLib __P((char *));
void Suff_FindDeps __P((GNode *));
void Suff_SetNull __P((char *));
void Suff_Init __P((void));
void Suff_End __P((void));
void Suff_PrintAll __P((void));
d130 13
a142 13
void Targ_Init __P((void));
void Targ_End __P((void));
GNode *Targ_NewGN __P((char *));
GNode *Targ_FindNode __P((char *, int));
void Targ_FindList __P((Lst, Lst));
Boolean Targ_Ignore __P((GNode *));
Boolean Targ_Silent __P((GNode *));
Boolean Targ_Precious __P((GNode *));
void Targ_SetMain __P((GNode *));
void Targ_PrintCmd __P((void *));
char *Targ_FmtTime __P((time_t));
void Targ_PrintType __P((int));
void Targ_PrintGraph __P((int));
d145 19
a163 19
void Var_Delete __P((char *, GSymT *));
void Var_Set __P((char *, char *, GSymT *));
void Varq_Set __P((int, char *, GNode *));
void Var_Append __P((char *, char *, GSymT *));
void Varq_Append __P((int, char *, GNode *));
Boolean Var_Exists __P((char *, GSymT *));
Boolean Varq_Exists __P((int, GNode *));
char *Var_Value __P((char *, GSymT *));
char *Varq_Value __P((int,  GNode *));
char *Var_Parse __P((char *, SymTable *, Boolean, size_t *, Boolean *));
char *Var_Subst __P((char *, SymTable *, Boolean));
void Var_SubstVar __P((Buffer, char *, const char *, GSymT *));
char *Var_GetTail __P((char *));
char *Var_GetHead __P((char *));
void Var_Init __P((void));
void Var_End __P((void));
void Var_Dump __P((GSymT *));
void SymTable_Init __P((SymTable *));
void SymTable_Destroy __P((SymTable *));
@


1.28
log
@Constify a few functions, propagated from VarModify.
Replace a few int -> size_t

Reviewed by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.27 2000/06/23 16:41:53 espie Exp $	*/
d164 1
@


1.27
log
@This patch replaces str_concat with a slightly unobfuscated version.

In particular, Dir_MakeFlags is abusing str_concat, and works much better
with buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.26 2000/06/23 16:23:26 espie Exp $	*/
d107 4
a110 4
char **brk_string __P((char *, int *, Boolean, char **));
int Str_Match __P((char *, char *));
char *Str_SYSVMatch __P((char *, char *, int *len));
void Str_SYSVSubst __P((Buffer, char *, char *, int));
@


1.26
log
@This patch separates local contexts from global contexts for good.
Apart from a few casts, VAR_GLOBAL and friends are separate
data structures, so we use a small array for local variables.

We also junk allVars, since TargFreeGN can release local nodes,
and var.c has explicit lists for its variables already.

Reviewed millert@@ and miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.25 2000/06/23 16:20:01 espie Exp $	*/
d106 1
a106 1
char *str_concat __P((char *, char *, int));
@


1.25
log
@Once those special variable are taken care of, other Var functions can take
the GNode's context directly.  We rename that special Lst to `SymTable *'
in prevision of things to come.

Along the line, we lose the special GNodes affected to VAR_CMD, VAR_GLOBAL,
VAR_ENV, which become simple Lsts... This is not a problem, except when
getting to a context's name for debugging (handled very nicely by
offsetof).

Again, this is a preparatory patch, which does not gain anything except
for cleaning up issues...

Reviewed by millert@@ and miod@@, like the previous patch
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.24 2000/06/23 16:18:09 espie Exp $	*/
d93 1
a93 1
void Parse_DoVar __P((char *, SymTable *));
d145 2
a146 2
void Var_Delete __P((char *, SymTable *));
void Var_Set __P((char *, char *, SymTable *));
d148 1
a148 1
void Var_Append __P((char *, char *, SymTable *));
d150 1
a150 1
Boolean Var_Exists __P((char *, SymTable *));
d152 1
a152 1
char *Var_Value __P((char *, SymTable *));
d156 1
a156 1
void Var_SubstVar __P((Buffer, char *, const char *, SymTable *));
d161 1
a161 1
void Var_Dump __P((SymTable *));
d163 1
@


1.24
log
@Start of variable fixes and speed-ups.

This patch may seem a bit non-sensical at first. It simply introduces some
new interface. Specifically, recognizes that some variable names
(.TARGET/$@@, .OODATE/$?, .ALLSRC/$>, .IMPSRC/$<, .PREFIX/$*, .ARCHIVE/$!,
.MEMBER/$%) are `special' (the actual variables which are local to a
target, e.g. GNode).

Currently, The Varq functions (for Varquick access) are only stubs to the
normal functions.

This fixes a very important detail before proceeding to turn variable lists
into hash tables: if every GNode holds a hash table, initialization times
for those will be very costly. But generic GNodes only hold those seven
special variables... which can be stored directly into a small array;
the only general cases are the environment, the command line and
global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.23 2000/06/17 14:40:28 espie Exp $	*/
d45 1
a45 1
ReturnStatus Arch_ParseArchive __P((char **, Lst, GNode *));
d93 1
a93 1
void Parse_DoVar __P((char *, GNode *));
d145 2
a146 2
void Var_Delete __P((char *, GNode *));
void Var_Set __P((char *, char *, GNode *));
d148 1
a148 1
void Var_Append __P((char *, char *, GNode *));
d150 1
a150 1
Boolean Var_Exists __P((char *, GNode *));
d152 1
a152 1
char *Var_Value __P((char *, GNode *));
d154 3
a156 3
char *Var_Parse __P((char *, GNode *, Boolean, size_t *, Boolean *));
char *Var_Subst __P((char *, GNode *, Boolean));
void Var_SubstVar __P((Buffer, char *, const char *, GNode *));
d161 2
a162 1
void Var_Dump __P((GNode *));
@


1.23
log
@A few assorted changes, to remove more dynamic lists.
- in Dir_Expand, path is a misnomer. Use a temp variable instead...
Reformat code for readability.
- Change Parse_MainName/Targ_FindList so that they fill arguments instead
of allocating new lists.
- nuke Targ_FindList(TG_NOCREATE), as this is never used.

- close a small memory hole (forgot to free sysMkPath if CLEANUP).

Reviewed by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.22 2000/06/10 01:41:05 espie Exp $	*/
d147 1
d149 1
d151 1
d153 1
@


1.22
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.21 2000/06/10 01:32:22 espie Exp $	*/
d99 1
a99 1
Lst Parse_MainName __P((void));
d134 1
a134 1
Lst Targ_FindList __P((Lst, int));
@


1.21
log
@Thus, Lst_ForEach no longer needs returning a status.
In fact, it can become a macro based on Lst_ForEachFrom.
This also introduces Lst_Every, as a shortcut for the very common case where
Lst_ForEach does not need any user data.

Finally,  make consistent use of a few function typedefs, instead of having
explicit void (*)(Lst)  arguments all over the place.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.20 2000/04/17 23:45:23 espie Exp $	*/
d78 1
a78 1
void PrintAddr __P((ClientData));
d117 1
a117 1
void Suff_EndTransform __P((ClientData));
d139 1
a139 1
void Targ_PrintCmd __P((ClientData));
@


1.20
log
@Don't free Makefile filenames when the file is finished reading, but
keep them for error reporting.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.19 2000/02/02 13:47:47 espie Exp $	*/
d78 1
a78 1
int PrintAddr __P((ClientData, ClientData));
d82 1
a82 1
int Make_TimeStamp __P((GNode *, GNode *));
d84 1
a84 1
int Make_HandleUse __P((GNode *, GNode *));
d117 1
a117 1
int Suff_EndTransform __P((ClientData, ClientData));
d139 1
a139 1
int Targ_PrintCmd __P((ClientData, ClientData));
@


1.19
log
@Bug-fix: make should behave sensibly when presented with negative times...

- let *_MTime return booleans, as that's what they're used for, the time_t
is set as a side effect.

- use OUT_OF_DATE for a date starting point, set it at the origin of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.18 2000/01/08 09:45:15 espie Exp $	*/
d101 1
@


1.18
log
@Finish changing all Var_Parse arguments to size_t. Thanks to millert@@
for reminding me.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.17 1999/12/16 17:27:18 espie Exp $	*/
d48 2
a49 2
time_t Arch_MTime __P((GNode *));
time_t Arch_MemMTime __P((GNode *));
@


1.17
log
@Var_Subst is actually two distinct functions folded into one:
split the function specific to for.c out, and give them more sensible
arguments at the same time.

This makes .for loop handling more efficient, as we have some heuristic
to evaluate the size of the buffer needed...
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.16 1999/12/16 17:07:20 espie Exp $	*/
d149 1
a149 1
char *Var_Parse __P((char *, GNode *, Boolean, int *, Boolean *));
@


1.16
log
@for.c becomes sane.
- split For_Eval into For_Eval (first line of loop) / For_Accumulate
(remaining lines).
- encapsulate state into a For structure, instead of brain damaged static
variables that need copy.

Very minor performance hit, specifically, For structure is allocated with
malloc/free, instead of playing tricks with static/auto variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.15 1999/12/09 18:20:06 espie Exp $	*/
d150 2
a151 1
char *Var_Subst __P((char *, char *, GNode *, Boolean));
@


1.15
log
@Split some allocation/error handling functions out of main.c
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.14 1999/12/06 23:16:56 espie Exp $	*/
d66 4
a69 2
int For_Eval __P((char *));
void For_Run  __P((void));
@


1.14
log
@main prototype properly in main.c, remove dup.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.13 1999/12/06 22:28:44 espie Exp $	*/
d63 2
a77 8
char *estrdup __P((const char *));
void *emalloc __P((size_t));
/* efree(x) works when x==NULL. STDC behavior, may need some different
 * definition for cross-builds on deficient systems */
#define efree	free
void *erealloc __P((void *, size_t));
void enomem __P((void));
int eunlink __P((const char *));
@


1.13
log
@Extra parameter no longer needed, ditch.
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.12 1999/12/06 22:18:56 espie Exp $	*/
a68 1
int main __P((int, char **));
@


1.12
log
@- introduce interval_dup in str.c
- use it to replace .for parsing with something approaching sanity.
(this removes one of the few most blatant misuses of Bufs in make.

More changes to come... patch reviewed by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.11 1999/11/11 11:47:27 espie Exp $	*/
d153 1
a153 1
char *Var_Value __P((char *, GNode *, char **));
@


1.11
log
@extern.h is a better name than nonints.h
(cvs file was copied from nonints.h to give a better sense of history).
@
text
@d1 1
a1 1
/*	$OpenBSD: extern.h,v 1.10 1999/11/11 11:42:19 espie Exp $	*/
d115 1
@


1.10
log
@Communicate line numbers between parse.c and for.c.
Parse_String starts in the current line, but at a given line number.

.for loops yield correct line numbers, much easier to debug !
@
text
@d1 1
a1 1
/*	$OpenBSD: nonints.h,v 1.7 1998/12/05 00:06:28 espie Exp $	*/
@


1.9
log
@Kill Str_FindSubString, it's strstr.
@
text
@d1 1
a1 1
/*	$OpenBSD: nonints.h,v 1.8 1999/11/11 11:33:02 espie Exp $	*/
d103 1
a103 1
void Parse_FromString __P((char *));
d105 1
@


1.8
log
@Move all prototypes to nonints.h. Comment no longer reflects reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: nonints.h,v 1.7 1998/12/05 00:06:28 espie Exp $	*/
a110 1
char *Str_FindSubstring __P((char *, char *));
@


1.7
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: nonints.h,v 1.5 1996/09/02 16:04:16 briggs Exp $	*/
d85 8
@


1.6
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d48 2
a49 2
int Arch_MTime __P((GNode *));
int Arch_MemMTime __P((GNode *));
d79 3
d102 1
a102 1
char **brk_string __P((char *, int *, Boolean));
@


1.5
log
@Sync up with NetBSD:
(christos)
	Fix bug reported by Greg Hudson where leaf (source only) nodes were
	referenced only by their basename and not by their full pathname. This
	breaks when .PATH or MAKEOBJDIR are used. There might be Makefiles
	around that try to work around this bug by prepending ${.CURDIR} to
	the sources, and they should be found and fixed. Also a lot of the gunk
	in suff.c that was attempting to work around the same problem could be
	removed.
(christos)
	- Move -D flags from Makefile to config.h and explain what they do. Add
	  -Wall -Wno-unused to CFLAGS. Add new define SYSVVARSUB to enable SysV
	  style variable substitutions and enable them.
	- Add SunOS style command substitutions via SUNSHCMD
	- Fix core dump with '{variable = value'
(christos)
	Fix bug where make will always exit with 0, even when one or more
	parallel jobs failed. (Only affects parallel make code)
(christos)
	Protect __P from being multiply defined (for systems that already
	define it)
(christos) Add strdup() since ultrix is missing it.
	From Larry Schwimmer <rosebud@@cyclone.Stanford.EDU>
(christos) Add estrdup(), a checked version of strdup and use it.
(christos) Recognize SVR4 style long filename entries in archives.
(thorpej) Tidy up some RCS ids a bit.
@
text
@d1 2
a2 2
/*	$OpenBSD: nonints.h,v 1.4 1996/06/26 05:36:35 deraadt Exp $	*/
/*	$NetBSD: nonints.h,v 1.11 1996/08/13 16:42:11 christos Exp $	*/
d5 2
a6 2
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
d41 1
a41 1
 *	from: @@(#)nonints.h	5.6 (Berkeley) 4/18/91
d54 1
@


1.4
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: nonints.h,v 1.9 1996/03/31 21:30:07 christos Exp $	*/
/*	$NetBSD: nonints.h,v 1.9 1996/03/31 21:30:07 christos Exp $	*/
d69 1
d76 1
@


1.3
log
@sync to netbsd 960418
@
text
@d1 1
@


1.2
log
@from christos@@netbsd:
Minor:
    - ${.PREFIX} should never contain a full pathname
    - Fixed gcc -Wall warnings
Major:
    - compatMake is now FALSE. This means that we are now running in
      full pmake mode:
          * rules on dependency lines can be executed in parallel and or
            out of sequence:

            foo: bar baz

            can fire the rule for baz before the rule for bar is fired.
            To enforce bar to be fired before baz, another rule needs to be
            added. [bar: baz]
          * adjacent shell commands in a target are now executed by a single
            invocation of the shell, not one invocation of the shell per line
      (compatMake can be turned off using the -B flag)
    - The -j flag now works... I.e. make -j 4 will fork up to four jobs in
      parallel when it can. The target name is printed before each burst
      of output caused by the target execution as '--- target ---', when j > 1
    - I have changed all the Makefiles so that they work with make -j N, and
      I have tested the whole netbsd by:
          'make -j 4 cleandir; make -j 4 depend; make -j 4; make -j 4 install'
    - I have not compiled or tested this version of make with -DREMOTE.
- Turn compat mode on by default. It gets turned off when the -j without
  the -B flag is specified. [Thus you can use -j 1 to turn it off].
- Fix malloc -> emalloc as Gordon noted.
Updates for POSIX/SVR4 compiling:
arch.c:          Don't require ranlib stuff. Not everybody has it.
dir.c:           SunOS-4 != Solaris; change #ifdef sun to #if sun && !__svr4__
job.c, compat.c: Don't use 'union wait', use int and the W*() macros.
main.c:          Check for uname() == -1; some unames return > 0...
util.c, job.c:   Add signal() with BSD semantics for svr4, don't use bsd
                 sigmask and friends.

from cgd@@netbsd:
pull in make.h.  (PAlloc() now uses emalloc(), which is prototyped in
make.h.  If the prototype is not in scope on the Alpha, I see lots
of "cast to pointer from integer of different size" warnings.)
@
text
@d1 1
a1 1
/*	$NetBSD: nonints.h,v 1.7 1995/11/02 23:55:00 christos Exp $	*/
d74 2
a75 1
char *emalloc __P((size_t));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nonints.h,v 1.6 1995/06/14 15:19:45 christos Exp $	*/
d76 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
