head	1.31;
access;
symbols
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.31.0.8
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.29.0.24
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.16
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.20
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.18
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.14
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.12
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.10
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.8
	OPENBSD_5_0:1.29.0.6
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.27.0.8
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.10
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.6
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.4
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.26.0.4
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.14
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.12
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.10
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.8
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.6
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.24.0.6
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.4
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.4
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2015.10.14.13.52.11;	author espie;	state Exp;
branches;
next	1.30;
commitid	WKo3Yog5CNmN9aF9;

1.30
date	2015.10.14.13.50.22;	author espie;	state Exp;
branches;
next	1.29;
commitid	N2KJxs0d4DGFAkuD;

1.29
date	2010.07.19.19.46.44;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2010.07.19.19.30.37;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2008.01.12.13.08.59;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2007.01.04.17.55.35;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.03.02.56.11;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.11.12.35.02;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.11.06.02.06;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.11.01.19.23;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.29.12.53.41;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.23.12.34.45;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.03.13.41.07;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.14.13.32.07;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.23.16.15.49;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.17.14.43.36;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.17.14.38.17;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.17.14.34.04;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.10.01.41.05;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.10.01.32.23;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.12.19.00.04.25;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.12.18.21.58.07;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	99.12.18.21.53.32;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	99.12.18.02.11.27;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	99.07.29.19.55.19;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.12.05.00.06.28;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	97.07.25.21.05.34;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.11.30.21.08.58;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.36.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.22.22.24.48;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.42;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.31
log
@gc lst_ForEachNodeWhile, which isn't actually in use anywhere
@
text
@#ifndef _LST_H_
#define _LST_H_

/*	$OpenBSD: lst.h,v 1.30 2015/10/14 13:50:22 espie Exp $ */
/*	$NetBSD: lst.h,v 1.7 1996/11/06 17:59:12 christos Exp $ */

/*
 * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.
 * Copyright (c) 1988, 1989 by Adam de Boor
 * Copyright (c) 1989 by Berkeley Softworks
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam de Boor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)lst.h 8.1 (Berkeley) 6/6/93
 */

/*-
 * lst.h --
 *	Header for using the list library
 */

/* These data structures are PRIVATE !!!
 * Here for efficiency, so that some functions can be recoded as inlines,
 * and so that lst headers don't need dynamic allocation most of the time.  */
struct ListNode_ {
	struct ListNode_    *prevPtr;	/* previous element in list */
	struct ListNode_    *nextPtr;	/* next in list */
	void		    *datum;	/* datum associated with this element */
};

#ifndef LIST_TYPE
#include "lst_t.h"
#endif

typedef void (*SimpleProc)(void *);
typedef bool (*FindProc)(void *, void *);
typedef int (*FindProcConst)(void *, const void *);
typedef void (*ForEachProc)(void *, void *);
typedef void *(*DuplicateProc)(void *);

/*
 * NOFREE can be used as the freeProc to Lst_Destroy when the elements are
 *	not to be freed.
 * NOCOPY performs similarly when given as the copyProc to Lst_Duplicate.
 */
#define NOFREE		((SimpleProc) 0)
#define NOCOPY		((DuplicateProc) 0)

/*
 * Creation/destruction functions
 */
/* Create a new list */
#define Lst_Init(l)	(l)->firstPtr = (l)->lastPtr = NULL
/* Static lists are already okay */
#define Static_Lst_Init(l)

/* Duplicate an existing list */
extern Lst		Lst_Clone(Lst, Lst, DuplicateProc);
/* Destroy an old one */
extern void		Lst_Destroy(LIST *, SimpleProc);
/* True if list is empty */
#define 	Lst_IsEmpty(l)	((l)->firstPtr == NULL)

/*
 * Functions to modify a list
 */
/* Insert an element before another */
extern void		Lst_Insert(Lst, LstNode, void *);
extern void		Lst_AtFront(Lst, void *);
/* Insert an element after another */
extern void		Lst_Append(Lst, LstNode, void *);
extern void		Lst_AtEnd(Lst, void *);
/* Remove an element */
extern void		Lst_Remove(Lst, LstNode);
/* Replace a node with a new value */
extern void		Lst_Replace(LstNode, void *);
/* Concatenate two lists, destructive.	*/
extern void		Lst_ConcatDestroy(Lst, Lst);
/* Concatenate two lists, non-destructive.  */
extern void		Lst_Concat(Lst, Lst);
/* requeue element already in list at front of list */
extern void		Lst_Requeue(Lst, LstNode);

/*
 * Node-specific functions
 */
/* Return first element in list */
/* Return last element in list */
/* Return successor to given element */
extern LstNode		Lst_Succ(LstNode);

/*
 * Functions for entire lists
 */
/* Find an element starting from somewhere */
extern LstNode		Lst_FindFrom(LstNode, FindProc, void *);
/*
 * See if the given datum is on the list. Returns the LstNode containing
 * the datum
 */
extern LstNode		Lst_Member(Lst, void *);
/* Apply a function to elements of a lst starting from a certain point.  */
extern void		Lst_ForEachFrom(LstNode, ForEachProc, void *);
extern void		Lst_Every(Lst, SimpleProc);

extern bool		Lst_AddNew(Lst, void *);
/*
 * for using the list as a queue
 */
/* Place an element at tail of queue */
#define Lst_EnQueue	Lst_AtEnd
#define Lst_QueueNew	Lst_AddNew

/*
 * for using the list as a stack
 */
#define Lst_Push	Lst_AtFront
#define Lst_Pop		Lst_DeQueue

/* Remove an element from head of queue */
extern void *	Lst_DeQueue(Lst);

#define Lst_Datum(ln)	((ln)->datum)
#define Lst_First(l)	((l)->firstPtr)
#define Lst_Last(l)	((l)->lastPtr)
#define Lst_ForEach(l, proc, d) Lst_ForEachFrom(Lst_First(l), proc, d)
#define Lst_Find(l, cProc, d)	Lst_FindFrom(Lst_First(l), cProc, d)
#define Lst_Adv(ln)	((ln)->nextPtr)
#define Lst_Rev(ln)	((ln)->prevPtr)


/* Inlines are preferable to macros here because of the type checking. */
#ifdef HAS_INLINES
static INLINE LstNode
Lst_FindConst(Lst l, FindProcConst cProc, const void *d)
{
	return Lst_FindFrom(Lst_First(l), (FindProc)cProc, (void *)d);
}

static INLINE LstNode
Lst_FindFromConst(LstNode ln, FindProcConst cProc, const void *d)
{
	return Lst_FindFrom(ln, (FindProc)cProc, (void *)d);
}
#else
#define Lst_FindConst(l, cProc, d) \
	Lst_FindFrom(Lst_First(l), (FindProc)cProc, (void *)d)
#define Lst_FindFromConst(ln, cProc, d) \
	Lst_FindFrom(ln, (FindProc)cProc, (void *)d)
#endif

#endif /* _LST_H_ */
@


1.30
log
@make sure we use stdbool.h
Mostly diff by Daniel Dickman, who told me to commit in his stead,
as he's tied up at work.
@
text
@d4 1
a4 1
/*	$OpenBSD: lst.h,v 1.29 2010/07/19 19:46:44 espie Exp $ */
a62 1
typedef int (*ForEachNodeWhileProc)(LstNode, void *);
a130 2

extern void		Lst_ForEachNodeWhile(Lst, ForEachNodeWhileProc, void *);
@


1.29
log
@Correct $OpenBSD$ stuff
@
text
@d4 1
a4 1
/*	$OpenBSD: lst.h,v 1.28 2010/07/19 19:30:37 espie Exp $ */
d62 1
a62 1
typedef int (*FindProc)(void *, void *);
@


1.28
log
@two small changes:
- allow variables in SysV modifiers, as requested by matthieu@@
(since recursive variables are an extension, this just extends the
extension)
- variation on :Q  called :QL (quote list), which does quote every character
EXCEPT for whitespace. e.g.,

toto:
	@@for i in ${VAR:QL} ...
@
text
@d4 1
a4 2
/*	$OpenPackages$ */
/*	$OpenBSD$ */
@


1.27
log
@better error reporting/job handling error:
- systematically reorder jobs based on who did output last, so that the
last job to output is *first* to output again.
- better reaction to errors: any job that outputs is checked for termination
directly, and the Error message is printed right afterwards.
- better error messages, giving more useful information in -j mode.
@
text
@@


1.26
log
@having a function that iterates through node's datum so that we retrieve
the list item with lst_member is non-sensical, create a new function
(Lst_ForEachNodeWhile) that iterates through lstnodes directly and use
it.

Less obfuscated, slightly more efficient...

okay otto@@
@
text
@d5 1
a5 1
/*	$OpenBSD: lst.h,v 1.25 2003/06/03 02:56:11 millert Exp $ */
d109 2
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d5 1
a5 1
/*	$OpenBSD: lst.h,v 1.24 2001/11/11 12:35:02 espie Exp $ */
d64 1
d131 2
@


1.24
log
@Fixed version... don't see how this could work on i386, since it didn't
initialize create in main.c.
@
text
@d5 1
a5 1
/*	$OpenBSD: lst.h,v 1.23 2001/11/11 06:02:06 deraadt Exp $ */
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.23
log
@undo changes that crash on (at least) the alpha
@
text
@d5 1
a5 1
/*	$OpenBSD: lst.h,v 1.21 2001/05/29 12:53:41 espie Exp $ */
d84 4
a87 1
extern void		Lst_Init(LIST *);
@


1.22
log
@Redo LstInit as a macro: smaller and faster code in all cases, zeroing two
pointers is simpler than calling a function.
Recognize purely static lst headers, which don't really need any
initialization.
ok miod@@
@
text
@d84 1
a84 4
#define Lst_Init(l)	(l)->firstPtr = (l)->lastPtr = NULL
/* Static lists are already okay */
#define Static_Lst_Init(l)

@


1.21
log
@Take includes out of lst.h, re-add what's needed to separate files.
Removes remaining lint stuff from lst.lib.
@
text
@d5 1
a5 1
/*	$OpenBSD: lst.h,v 1.20 2001/05/23 12:34:45 espie Exp $ */
d84 4
a87 1
extern void		Lst_Init(LIST *);
@


1.20
log
@Mostly clean-up:
- cut up those huge include files into separate interfaces for all modules.
Put the interface documentation there, and not with the implementation.
- light-weight includes for needed concrete types (lst_t.h, timestamp_t.h).
- cut out some more logically separate parts: cmd_exec, varname, parsevar,
timestamp.
- put all error handling functions together, so that we will be able to
clean them up.
- more systematic naming: functioni  to handle interval, function to handle
string.
- put the init/end code apart to minimize coupling.
- kill weird types like ReturnStatus and Boolean. Use standard bool (with a
fallback for non-iso systems)
- better interface documentation for lots of subsystems.

As a result, make compilation goes somewhat faster (5%, even considering
the largish BSD copyrights to read). The corresponding preprocessed
source goes down from 1,5M to 1M.

A few minor code changes as well: Parse_DoVar is no longer destructive.
Parse_IsVar functionality is folded into Parse_DoVar (as it knows what an
assignment is), a few more interval handling functions. Avoid calling
XXX_End when they do nothing, just #define XXX_End   to nothing.

Parse_DoVar is slightly more general: it will handle compound assignments
as long as they make sense, e.g., VAR +!= cmd
will work.  As a side effect, VAR++=value now triggers an error
(two + in assignment).
- this stuff doesn't occur in portable Makefiles.
- writing VAR++ = value or VAR+ +=value  disambiguates it.
- this is a good thing, it uncovered a bug in bsd.port.mk.

Tested by naddy@@. Okayed millert@@. I'll handle the fallback if there is
any. This went through a full make build anyways, including isakmpd
(without mickey's custom binutils, as he didn't see fit to share it with me).
@
text
@d5 1
a5 1
/*	$OpenBSD: lst.h,v 1.7 1999/07/29 19:55:19 deraadt Exp $ */
a51 4
#include	<sys/param.h>
#ifdef __STDC__
#include	<stdlib.h>
#endif
@


1.19
log
@Synch with my current work.
Numerous changes:
- generate can build several tables
- style cleanup
- statistics code
- use variable names throughout (struct Name)
- recursive variables everywhere
- faster parser (pass buffer along instead of allocating multiple copies)
- correct parser. Handles comments everywhere, and ; correctly
- more string intervals
- simplified dir.c, less recursion.
- extended for loops
- sinclude()
- finished removing extra junk from Lst_*
- handles ${@@D} and friends in a simpler way
- cleaned up and modular VarModifiers handling.
- recognizes some gnu Makefile usages and errors out about them.

Additionally, some extra functionality is defined by FEATURES. The set of
functionalities is currently hardcoded to OpenBSD defaults, but this may
include support for some NetBSD extensions, like ODE modifiers.

Backed by miod@@ and millert@@, who finally got sick of my endless patches...
@
text
@d1 3
a51 4
#ifndef _LST_H_
#define _LST_H_

#include	"sprite.h"
d60 1
a60 1
typedef struct ListNode_ {
d64 1
a64 1
} *LstNode;
d66 3
a68 6
typedef struct	{
	LstNode 	firstPtr; /* first node in list */
	LstNode 	lastPtr;  /* last node in list */
} LIST;

typedef LIST *Lst;
d136 1
a136 1
extern ReturnStatus	Lst_AddNew(Lst, void *);
d144 6
d162 1
@


1.18
log
@Some systematic clean-up.
- UNUSED macro that expands to __attribute__((unused)) for gcc
- move rcsid around so that they can be tagged UNUSED.
- activate -Wunused.
- use UNUSED instead of kludgy junk for function arguments.
- add extern to all extern prototypes.
- update comments in lst.h.
- clean up var.c a little bit, constifying arguments, updating comments...
@
text
@d1 3
a3 2
/*	$OpenBSD: lst.h,v 1.17 2000/06/23 16:15:49 espie Exp $	*/
/*	$NetBSD: lst.h,v 1.7 1996/11/06 17:59:12 christos Exp $	*/
d42 1
a42 1
 *	from: @@(#)lst.h	8.1 (Berkeley) 6/6/93
d62 2
a63 6
	struct ListNode_    *prevPtr;   /* previous element in list */
	struct ListNode_    *nextPtr;   /* next in list */
	short	    	    useCount:8, /* Count of functions using the node.
			    	         * node may not be deleted until count
				         * goes to 0 */
 	    	    	    flags:8;    /* Node status flags */
a66 4
typedef enum {
    Head, Middle, Tail, Unknown
} Where;

d68 2
a69 11
	LstNode  	firstPtr; /* first node in list */
	LstNode  	lastPtr;  /* last node in list */
/*
 * fields for sequential access
 */
	Where	  	atEnd;	  /* Where in the list the last access was */
	Boolean	  	isOpen;	  /* true if list has been Lst_Open'ed */
	LstNode  	curPtr;	  /* current node, if open. NULL if
				   * *just* opened */
	LstNode  	prevPtr;  /* Previous node, if open. Used by
				   * Lst_Remove */
a72 3
/*
 * basic typedef. This is what the Lst_ functions handle
 */
d74 5
a78 4
typedef int (*FindProc) __P((void *, void *));
typedef void (*SimpleProc) __P((void *));
typedef void (*ForEachProc) __P((void *, void *));
typedef void * (*DuplicateProc) __P((void *));
d83 1
a83 1
 * NOCOPY performs similarly when given as the copyProc to Lst_Clone.
d85 2
a86 2
#define NOFREE		((SimpleProc)0)
#define NOCOPY		((DuplicateProc)0)
d89 1
a89 1
 * Constructors/destructors
d92 3
a94 1
extern void		Lst_Init __P((Lst));
d96 1
a96 4
extern void		Lst_Destroy __P((Lst, SimpleProc));

/* Duplicate an existing list */
extern Lst		Lst_Clone __P((Lst, Lst, DuplicateProc));
d98 1
a98 1
extern Boolean		Lst_IsEmpty __P((Lst));
d101 1
a101 1
 * List modifications
d104 2
a105 1
extern void		Lst_Insert __P((Lst, LstNode, void *));
d107 2
a108 5
extern void		Lst_Append __P((Lst, LstNode, void *));
/* Place an element at the front of a lst. */
extern void		Lst_AtFront __P((Lst, void *));
/* Place an element at the end of a lst. */
extern void		Lst_AtEnd __P((Lst, void *));
d110 1
a110 1
extern void		Lst_Remove __P((Lst, LstNode));
d112 5
a116 5
extern void		Lst_Replace __P((LstNode, void *));
/* Concatenate two lists, destructive.  */
extern void		Lst_ConcatDestroy __P((Lst, Lst));
/* Concatenate two lists, non destructive */
extern void		Lst_Concat __P((Lst, Lst));
d119 1
a119 1
 * Node handling
a121 1
#define	Lst_First(l)	((l)->firstPtr)
a122 1
#define Lst_Last(l)	((l)->lastPtr)
d124 1
a124 5
extern LstNode		Lst_Succ __P((LstNode));
/* Return successor to existing element */
#define Lst_Adv(ln)	((ln)->nextPtr)
/* Get datum from LstNode */
#define Lst_Datum(ln)	((ln)->datum)
d127 1
a127 1
 * Apply to entire lists
a128 4

/* Find an element in a list */
#define Lst_Find(l, cProc, d)	Lst_FindFrom(Lst_First(l), cProc, d)

d130 1
a130 12
extern LstNode		Lst_FindFrom __P((LstNode, FindProc, void *));

/* Apply a function to all elements of a lst */
#define Lst_ForEach(l, proc, d)	Lst_ForEachFrom(Lst_First(l), proc, d)
/* Apply a function to all elements of a lst starting from a certain point.  */
extern void		Lst_ForEachFrom __P((LstNode, ForEachProc, void *));
extern void		Lst_Every __P((Lst, SimpleProc));


/* Find datum in a list. Returns the LstNode containing the datum */
extern LstNode		Lst_Member __P((Lst, void *));

d132 2
a133 2
 * Visitor-like pattern.  Except the visitor is kept in the list.
 * Error-prone and wasteful (used by only a few lists), to be killed.
d135 4
a138 8
/* Open the list */
extern void		Lst_Open __P((Lst));
/* Next element please */
extern LstNode		Lst_Next __P((Lst));
/* Done yet? */
extern Boolean		Lst_IsAtEnd __P((Lst));
/* Finish table access */
extern void		Lst_Close __P((Lst));
d140 1
d142 1
a142 1
 * Queue manipulators
d145 3
a147 1
extern void		Lst_EnQueue __P((Lst, void *));
d149 29
a177 1
extern void *	Lst_DeQueue __P((Lst));
@


1.17
log
@Trivial consequences of the previous list changes:

- audit code for Lst_Datum, it's never applied to an empty pointer,
so check can be removed -> turn into a macro,
- Lst_First, Lst_Last can become macro as well
- specialized version of Lst_Succ (Lst_Adv) to use in loops where it cannot
fail,
- Lst_Open can no longer fail. Trim down corresponding code.

Reviewed millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lst.h,v 1.16 2000/06/17 14:43:36 espie Exp $	*/
d107 1
a107 1
 * Creation/destruction functions
a108 1
/* CTOR/DTOR, ala C++ */
d110 1
a110 1
void		Lst_Init __P((Lst));
d112 1
a112 1
void		Lst_Destroy __P((Lst, SimpleProc));
d115 1
a115 1
Lst		Lst_Clone __P((Lst, Lst, DuplicateProc));
d117 1
a117 1
Boolean		Lst_IsEmpty __P((Lst));
d120 1
a120 1
 * Functions to modify a list
d123 1
a123 1
void		Lst_Insert __P((Lst, LstNode, void *));
d125 1
a125 1
void		Lst_Append __P((Lst, LstNode, void *));
d127 1
a127 1
void		Lst_AtFront __P((Lst, void *));
d129 1
a129 1
void		Lst_AtEnd __P((Lst, void *));
d131 1
a131 1
void		Lst_Remove __P((Lst, LstNode));
d133 1
a133 1
void		Lst_Replace __P((LstNode, void *));
d135 1
a135 1
void		Lst_ConcatDestroy __P((Lst, Lst));
d137 1
a137 1
void		Lst_Concat __P((Lst, Lst));
d140 1
a140 1
 * Node-specific functions
d147 1
a147 1
LstNode		Lst_Succ __P((LstNode));
d154 1
a154 1
 * Functions for entire lists
d161 1
a161 1
LstNode		Lst_FindFrom __P((LstNode, FindProc, void *));
d166 2
a167 2
void		Lst_ForEachFrom __P((LstNode, ForEachProc, void *));
void		Lst_Every __P((Lst, SimpleProc));
d170 2
a171 5
/*
 * See if the given datum is on the list. Returns the LstNode containing
 * the datum
 */
LstNode		Lst_Member __P((Lst, void *));
d174 2
a175 3
 * these functions are for dealing with a list as a table, of sorts.
 * An idea of the "current element" is kept and used by all the functions
 * between Lst_Open() and Lst_Close().
d178 1
a178 1
void		Lst_Open __P((Lst));
d180 1
a180 1
LstNode		Lst_Next __P((Lst));
d182 1
a182 1
Boolean		Lst_IsAtEnd __P((Lst));
d184 1
a184 1
void		Lst_Close __P((Lst));
d187 1
a187 1
 * for using the list as a queue
d190 1
a190 1
void		Lst_EnQueue __P((Lst, void *));
d192 1
a192 1
void *	Lst_DeQueue __P((Lst));
@


1.16
log
@This removes the few instances of Lst_New left.
- replaces Lst_Duplicate with Lst_Clone, which does not allocate storage
- split Lst_Concat into Lst_Concat/Lst_ConcatDestroy
Thus, all the LstValid checks are gone, since we always invoke list
functions with valid pointers.

Note that dynamic list allocation accounted for roughly 20% of all calls
to malloc.  The extraneous calls to malloc left are now mostly in parse.c,
which makes some wasteful usage of temporary buffers.

With those few patches, the code is sturdier, and easier to maintain.

Reviewed by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lst.h,v 1.15 2000/06/17 14:38:17 espie Exp $	*/
d144 1
a144 1
LstNode		Lst_First __P((Lst));
d146 1
a146 1
LstNode		Lst_Last __P((Lst));
d149 2
d152 1
a152 1
void *	Lst_Datum __P((LstNode));
d183 1
a183 1
ReturnStatus	Lst_Open __P((Lst));
@


1.15
log
@This patch introduces a distinction between
Lst_Init (constructor) and Lst_New (allocation + construction)
Lst_Destroy (destructor) and Lst_Delete (deallocation + destruction),
and uses that to turn most dynamic allocation of lists (Lst pointers)
into static structures (LIST).

Most of this is mundane, except for allGNs in targ.c, where the code must
be checked to verify that Targ_Init is called soon enough.

Lst_New is a temporary addition. All lists will soon be static.

Reviewed by millert@@, like the previous patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: lst.h,v 1.14 2000/06/17 14:34:04 espie Exp $	*/
d101 1
a101 1
 * NOCOPY performs similarly when given as the copyProc to Lst_Duplicate.
a105 3
#define LST_CONCNEW	0   /* create new LstNode's when using Lst_Concat */
#define LST_CONCLINK	1   /* relink LstNode's when using Lst_Concat */

d110 1
d112 1
a114 4
/* Create a new list */
Lst		Lst_New __P((void));
/* Destroy an old one */
void		Lst_Delete __P((Lst, SimpleProc));
d116 1
a116 1
Lst		Lst_Duplicate __P((Lst, DuplicateProc));
d135 4
a138 2
/* Concatenate two lists */
void		Lst_Concat __P((Lst, Lst, int));
@


1.14
log
@This patch moves the definition of lists and list nodes to lst.h.
C is not well-suited for opaque data structures.

Then it proceeds by removing a lot of non-sensical casts and white space.

There are two motivations behind this change:
* small functions like Lst_First can now be redefined as macros safely
(otherwise, the cast would mean that you might write Lst_First(5) and
find out about it rather late)
* the size of the Lst data structure is exposed to user code. This will
be used to allocate lists statically, instead of malloc/free them like
crazy.
@
text
@d1 1
a1 1
/*	$OpenBSD: lst.h,v 1.13 2000/06/10 01:41:05 espie Exp $	*/
d112 4
d117 3
a119 1
Lst		Lst_Init __P((void));
a121 2
/* Destroy an old one */
void		Lst_Destroy __P((Lst, SimpleProc));
@


1.13
log
@Clean-up patch: use `void *' instead of old-fashioned ClientData/Address.
@
text
@d1 1
a1 1
/*	$OpenBSD: lst.h,v 1.12 2000/06/10 01:32:23 espie Exp $	*/
d57 32
a92 2
typedef	struct	Lst	*Lst;
typedef	struct	LstNode	*LstNode;
@


1.12
log
@Thus, Lst_ForEach no longer needs returning a status.
In fact, it can become a macro based on Lst_ForEachFrom.
This also introduces Lst_Every, as a shortcut for the very common case where
Lst_ForEach does not need any user data.

Finally,  make consistent use of a few function typedefs, instead of having
explicit void (*)(Lst)  arguments all over the place.
@
text
@d1 1
a1 1
/*	$OpenBSD: lst.h,v 1.11 1999/12/19 00:04:25 espie Exp $	*/
d63 4
a66 4
typedef int (*FindProc) __P((ClientData, ClientData));
typedef void (*SimpleProc) __P((ClientData));
typedef void (*ForEachProc) __P((ClientData, ClientData));
typedef ClientData (*DuplicateProc) __P((ClientData));
d95 1
a95 1
void		Lst_Insert __P((Lst, LstNode, ClientData));
d97 1
a97 1
void		Lst_Append __P((Lst, LstNode, ClientData));
d99 1
a99 1
void		Lst_AtFront __P((Lst, ClientData));
d101 1
a101 1
void		Lst_AtEnd __P((Lst, ClientData));
d105 1
a105 1
void		Lst_Replace __P((LstNode, ClientData));
d119 1
a119 1
ClientData	Lst_Datum __P((LstNode));
d129 1
a129 1
LstNode		Lst_FindFrom __P((LstNode, FindProc, ClientData));
d134 1
a134 1
void		Lst_ForEachFrom __P((LstNode, ForEachProc, ClientData));
d142 1
a142 1
LstNode		Lst_Member __P((Lst, ClientData));
d162 1
a162 1
void		Lst_EnQueue __P((Lst, ClientData));
d164 1
a164 1
ClientData	Lst_DeQueue __P((Lst));
@


1.11
log
@Rearrange Lst_Find interface to conform better with other functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: lst.h,v 1.10 1999/12/18 21:58:07 espie Exp $	*/
d63 4
a66 1
typedef int (*FindProc)__P((ClientData, ClientData));
d73 2
a74 2
#define NOFREE		((void (*) __P((ClientData))) 0)
#define NOCOPY		((ClientData (*) __P((ClientData))) 0)
d85 1
a85 1
Lst		Lst_Duplicate __P((Lst, ClientData (*)(ClientData)));
d87 1
a87 1
void		Lst_Destroy __P((Lst, void (*)(ClientData)));
d130 8
d143 1
a143 11
/* Apply a function to all elements of a lst */
void		Lst_ForEach __P((Lst, int (*)(ClientData, ClientData),
				 ClientData));
/*
 * Apply a function to all elements of a lst starting from a certain point.
 * If the list is circular, the application will wrap around to the
 * beginning of the list again.
 */
void		Lst_ForEachFrom __P((Lst, LstNode,
				     int (*)(ClientData, ClientData),
				     ClientData));
@


1.10
log
@Nothing ever checks ReturnStatus on Lst_Insert, Lst_Append, Lst_AtFront,
Lst_AtEnd, Lst_Concat, Lst_Remove, Lst_Replace.

Don't bother returning one.
@
text
@d1 1
a1 1
/*	$OpenBSD: lst.h,v 1.9 1999/12/18 21:53:32 espie Exp $	*/
d63 1
d121 1
d123 2
a124 2
LstNode		Lst_Find __P((Lst, ClientData,
			      int (*)(ClientData, ClientData)));
d126 1
a126 2
LstNode		Lst_FindFrom __P((Lst, LstNode, ClientData,
				  int (*cProc)(ClientData, ClientData)));
@


1.9
log
@NIL, NILGNODE, etc, are only glorified NULL.
Get rid of them.

Get rid of list.h, nothing uses it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: lst.h,v 1.8 1999/12/18 02:11:27 espie Exp $	*/
d91 1
a91 1
ReturnStatus	Lst_Insert __P((Lst, LstNode, ClientData));
d93 1
a93 1
ReturnStatus	Lst_Append __P((Lst, LstNode, ClientData));
d95 1
a95 1
ReturnStatus	Lst_AtFront __P((Lst, ClientData));
d97 1
a97 1
ReturnStatus	Lst_AtEnd __P((Lst, ClientData));
d99 1
a99 1
ReturnStatus	Lst_Remove __P((Lst, LstNode));
d101 1
a101 1
ReturnStatus	Lst_Replace __P((LstNode, ClientData));
d103 1
a103 1
ReturnStatus	Lst_Concat __P((Lst, Lst, int));
d160 1
a160 1
ReturnStatus	Lst_EnQueue __P((Lst, ClientData));
@


1.8
log
@make does not use circular lists, get rid of the extra weight.
@
text
@d1 1
a1 1
/*	$OpenBSD: lst.h,v 1.7 1999/07/29 19:55:19 deraadt Exp $	*/
a62 3

#define	NILLST		((Lst) NIL)
#define	NILLNODE	((LstNode) NIL)
@


1.7
log
@"sprite.h"; soren@@t.dk
@
text
@d1 1
a1 1
/*	$OpenBSD: lst.h,v 1.6 1998/12/05 00:06:28 espie Exp $	*/
d82 1
a82 1
Lst		Lst_Init __P((Boolean));
@


1.6
log
@Modifications from netbsd:
- don't interfere with MACHINE/MACHINE_ARCH defines for bootstrap
- type clean-up, time_t, and printing `unknown' ints
- fix TARGET/MEMBER bug in archive rules
- memmove...
- cleaner Error handler.
- reentrant brk_string
- .MAKE env variable
- preliminary scaffolding for .NOPATH

Other improvements:
- efree
- shellneed streamlined
- display Stop in .CURDIR after an error.
- document most features and misfeatures.
- add a few OpenBSD notes to the tutorial.
@
text
@d1 1
a1 1
/*	$OpenBSD: lst.h,v 1.4 1996/11/30 21:08:58 millert Exp $	*/
d51 1
a51 1
#include	<sprite.h>
@


1.5
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@@


1.4
log
@Sync with NetBSD:
- Merge in FreeBSD and Lite2 changes.
- Fix bug where a non-archive target with a .a suffix would always
  be considered to be out of date, since it does not have a TOC.
- Fix NetBSD PR #2930: declare missing variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: lst.h,v 1.3 1996/06/26 05:36:35 deraadt Exp $	*/
d53 1
a53 1
#if __STDC__
@


1.3
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: lst.h,v 1.6 1996/02/04 22:20:46 christos Exp $	*/
/*	$NetBSD: lst.h,v 1.6 1996/02/04 22:20:46 christos Exp $	*/
d41 1
a41 1
 *	from: @@(#)lst.h	5.3 (Berkeley) 6/1/90
d124 1
a124 1
LstNode		Lst_Find __P((Lst, ClientData, 
d129 1
a129 1
/* 
@


1.2
log
@From NetBSD:
Support SVR4 style archives.
Fix pr/1421 (from Matthew Green) and pr/1997 (from Jeff Thieleke).
In ParseDoInclude(), make a temporary copy of the current file name
while searching for ""-type include files, since the current file name
might not be a writeable string.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: lst.h,v 1.5 1995/06/14 15:19:31 christos Exp $	*/
d51 1
a51 1
#include	<sys/cdefs.h>
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
