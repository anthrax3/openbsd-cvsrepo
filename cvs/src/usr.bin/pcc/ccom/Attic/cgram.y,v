head	1.11;
access;
symbols
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.14
	OPENBSD_5_0:1.10.0.12
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.10
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8;
locks; strict;
comment	@ * @;


1.11
date	2012.04.12.11.51.12;	author pirofti;	state dead;
branches;
next	1.10;

1.10
date	2008.08.17.18.40.12;	author ragge;	state Exp;
branches;
next	1.9;

1.9
date	2008.04.11.20.45.52;	author stefan;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.12.17.26.16;	author ragge;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.25.10.27.35;	author stefan;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.22.15.06.43;	author stefan;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.18.17.39.55;	author ragge;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.16.09.00.12;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.29.18.26.31;	author stefan;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.07.18.34.41;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.07.17.58.51;	author otto;	state Exp;
branches;
next	;


desc
@@


1.11
log
@tedu(tm) pcc.

Message sent. Okay deraadt@@.
@
text
@/*	$OpenBSD: cgram.y,v 1.10 2008/08/17 18:40:12 ragge Exp $	*/

/*
 * Copyright (c) 2003 Anders Magnusson (ragge@@ludd.luth.se).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright(C) Caldera International Inc. 2001-2002. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code and documentation must retain the above
 * copyright notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 * 	This product includes software developed or owned by Caldera
 *	International, Inc.
 * Neither the name of Caldera International, Inc. nor the names of other
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
 * INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE
 * FOR ANY DIRECT, INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OFLIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Comments for this grammar file. Ragge 021123
 *
 * ANSI support required rewrite of the function header and declaration
 * rules almost totally.
 *
 * The lex/yacc shared keywords are now split from the keywords used
 * in the rest of the compiler, to simplify use of other frontends.
 */

/*
 * At last count, there were 3 shift/reduce and no reduce/reduce conflicts
 * Two was funct_idn and the third was "dangling else".
 */

/*
 * Token used in C lex/yacc communications.
 */
%token	C_STRING	/* a string constant */
%token	C_ICON		/* an integer constant */
%token	C_FCON		/* a floating point constant */
%token	C_NAME		/* an identifier */
%token	C_TYPENAME	/* a typedef'd name */
%token	C_ANDAND	/* && */
%token	C_OROR		/* || */
%token	C_GOTO		/* unconditional goto */
%token	C_RETURN	/* return from function */
%token	C_TYPE		/* a type */
%token	C_CLASS		/* a storage class */
%token	C_ASOP		/* assignment ops */
%token	C_RELOP		/* <=, <, >=, > */
%token	C_EQUOP		/* ==, != */
%token	C_DIVOP		/* /, % */
%token	C_SHIFTOP	/* <<, >> */
%token	C_INCOP		/* ++, -- */
%token	C_UNOP		/* !, ~ */
%token	C_STROP		/* ., -> */
%token	C_STRUCT
%token	C_IF
%token	C_ELSE
%token	C_SWITCH
%token	C_BREAK
%token	C_CONTINUE
%token	C_WHILE	
%token	C_DO
%token	C_FOR
%token	C_DEFAULT
%token	C_CASE
%token	C_SIZEOF
%token	C_ENUM
%token	C_ELLIPSIS
%token	C_QUALIFIER
%token	C_FUNSPEC
%token	C_ASM
%token	NOMATCH

/*
 * Precedence
 */
%left ','
%right '=' C_ASOP
%right '?' ':'
%left C_OROR
%left C_ANDAND
%left '|'
%left '^'
%left '&'
%left C_EQUOP
%left C_RELOP
%left C_SHIFTOP
%left '+' '-'
%left '*' C_DIVOP
%right C_UNOP
%right C_INCOP C_SIZEOF
%left '[' '(' C_STROP
%{
# include "pass1.h"
# include <stdarg.h>
# include <string.h>
# include <stdlib.h>

int fun_inline;	/* Reading an inline function */
int oldstyle;	/* Current function being defined */
static struct symtab *xnf;
extern int enummer, tvaloff;
extern struct rstack *rpole;
static int ctval, widestr;

#define	NORETYP	SNOCREAT /* no return type, save in unused field in symtab */

static NODE *bdty(int op, ...);
static void fend(void);
static void fundef(NODE *tp, NODE *p);
static void olddecl(NODE *p);
static struct symtab *init_declarator(NODE *tn, NODE *p, int assign);
static void resetbc(int mask);
static void swend(void);
static void addcase(NODE *p);
static void adddef(void);
static void savebc(void);
static void swstart(int, TWORD);
static void genswitch(int, TWORD, struct swents **, int);
static NODE *structref(NODE *p, int f, char *name);
static char *mkpstr(char *str);
static struct symtab *clbrace(NODE *);
static NODE *cmop(NODE *l, NODE *r);
static NODE *xcmop(NODE *out, NODE *in, NODE *str);
static void mkxasm(char *str, NODE *p);
static NODE *xasmop(char *str, NODE *p);
static int maxstlen(char *str);
static char *stradd(char *old, char *new);
static NODE *biop(int op, NODE *l, NODE *r);
static void flend(void);

/*
 * State for saving current switch state (when nested switches).
 */
struct savbc {
	struct savbc *next;
	int brklab;
	int contlab;
	int flostat;
	int swx;
} *savbc, *savctx;

%}

%union {
	int intval;
	NODE *nodep;
	struct symtab *symp;
	struct rstack *rp;
	char *strp;
}

	/* define types */
%start ext_def_list

%type <intval> con_e ifelprefix ifprefix whprefix forprefix doprefix switchpart
		type_qualifier_list
%type <nodep> e .e term enum_dcl struct_dcl cast_type funct_idn declarator
		direct_declarator elist type_specifier merge_attribs
		parameter_declaration abstract_declarator initializer
		parameter_type_list parameter_list addrlbl
		declaration_specifiers pointer direct_abstract_declarator
		specifier_qualifier_list merge_specifiers nocon_e
		identifier_list arg_param_list
		designator_list designator xasm oplist oper cnstr funtype
%type <strp>	string C_STRING
%type <rp>	str_head
%type <symp>	xnfdeclarator clbrace enum_head

%type <intval> C_CLASS C_STRUCT C_RELOP C_DIVOP C_SHIFTOP
		C_ANDAND C_OROR C_STROP C_INCOP C_UNOP C_ASOP C_EQUOP

%type <nodep>  C_TYPE C_QUALIFIER C_ICON C_FCON
%type <strp>	C_NAME C_TYPENAME

%%

ext_def_list:	   ext_def_list external_def
		| { ftnend(); }
		;

external_def:	   funtype kr_args compoundstmt { fend(); }
		|  declaration  { blevel = 0; symclear(0); }
		|  asmstatement ';'
		|  ';'
		|  error { blevel = 0; }
		;

funtype:	  /* no type given */ declarator {
		    fundef(mkty(INT, 0, MKSUE(INT)), $1);
		    cftnsp->sflags |= NORETYP;
		}
		| declaration_specifiers declarator { fundef($1,$2); }
		;

kr_args:	  /* empty */
		| arg_dcl_list
		;

/*
 * Returns a node pointer or NULL, if no types at all given.
 * Type trees are checked for correctness and merged into one
 * type node in typenode().
 */
declaration_specifiers:
		   merge_attribs { $$ = typenode($1); }
		;

merge_attribs:	   C_CLASS { $$ = block(CLASS, NIL, NIL, $1, 0, 0); }
		|  C_CLASS merge_attribs { $$ = block(CLASS, $2, NIL, $1,0,0);}
		|  type_specifier { $$ = $1; }
		|  type_specifier merge_attribs { $1->n_left = $2; $$ = $1; }
		|  C_QUALIFIER { $$ = $1; }
		|  C_QUALIFIER merge_attribs { $1->n_left = $2; $$ = $1; }
		|  function_specifiers { $$ = NIL; }
		|  function_specifiers merge_attribs { $$ = $2; }
		;

function_specifiers:
		   C_FUNSPEC { fun_inline = 1; }
		;

type_specifier:	   C_TYPE { $$ = $1; }
		|  C_TYPENAME { 
			struct symtab *sp = lookup($1, 0);
			$$ = mkty(sp->stype, sp->sdf, sp->ssue);
			$$->n_sp = sp;
		}
		|  struct_dcl { $$ = $1; }
		|  enum_dcl { $$ = $1; }
		;

/*
 * Adds a pointer list to front of the declarators.
 * Note the UMUL right node pointer usage.
 */
declarator:	   pointer direct_declarator {
			$$ = $1; $1->n_right->n_left = $2;
		}
		|  direct_declarator { $$ = $1; }
		;

/*
 * Return an UMUL node type linked list of indirections.
 */
pointer:	   '*' { $$ = bdty(UMUL, NIL); $$->n_right = $$; }
		|  '*' type_qualifier_list {
			$$ = bdty(UMUL, NIL);
			$$->n_qual = $2;
			$$->n_right = $$;
		}
		|  '*' pointer {
			$$ = bdty(UMUL, $2);
			$$->n_right = $2->n_right;
		}
		|  '*' type_qualifier_list pointer {
			$$ = bdty(UMUL, $3);
			$$->n_qual = $2;
			$$->n_right = $3->n_right;
		}
		;

type_qualifier_list:
		   C_QUALIFIER { $$ = $1->n_type; nfree($1); }
		|  type_qualifier_list C_QUALIFIER {
			$$ = $1 | $2->n_type; nfree($2);
		}
		;

/*
 * Sets up a function declarator. The call node will have its parameters
 * connected to its right node pointer.
 */
direct_declarator: C_NAME { $$ = bdty(NAME, $1); }
		|  '(' declarator ')' { $$ = $2; }
		|  direct_declarator '[' nocon_e ']' { 
			$3 = optim($3);
			if ((blevel == 0 || rpole != NULL) && !nncon($3))
				uerror("array size not constant");
			/*
			 * Checks according to 6.7.5.2 clause 1:
			 * "...the expression shall have an integer type."
			 * "If the expression is a constant expression,
			 * it shall have a value greater than zero."
			 */
			if (!ISINTEGER($3->n_type))
				werror("array size is not an integer");
			else if ($3->n_op == ICON) {
				if ($3->n_lval < 0) {
					uerror("array size cannot be negative");
					$3->n_lval = 1;
				}
#ifdef notyet
				if ($3->n_lval == 0 && Wgcc)
					werror("gcc extension; zero size");
#endif
			}
			$$ = biop(LB, $1, $3);
		}
		|  direct_declarator '[' ']' {
			$$ = biop(LB, $1, bcon(NOOFFSET));
		}
		|  direct_declarator '(' parameter_type_list ')' {
			$$ = bdty(CALL, $1, $3);
		}
		|  direct_declarator '(' identifier_list ')' { 
			$$ = bdty(CALL, $1, $3);
			if (blevel != 0)
				uerror("function declaration in bad context");
			oldstyle = 1;
		}
		|  direct_declarator '(' ')' {
			ctval = tvaloff;
			$$ = bdty(UCALL, $1);
		}
		;

identifier_list:   C_NAME { $$ = bdty(NAME, $1); }
		|  identifier_list ',' C_NAME { $$ = cmop($1, bdty(NAME, $3)); }
		;

/*
 * Returns as parameter_list, but can add an additional ELLIPSIS node.
 */
parameter_type_list:
		   parameter_list { $$ = $1; }
		|  parameter_list ',' C_ELLIPSIS {
			$$ = cmop($1, biop(ELLIPSIS, NIL, NIL));
		}
		;

/*
 * Returns a linked lists of nodes of op CM with parameters on
 * its right and additional CM nodes of its left pointer.
 * No CM nodes if only one parameter.
 */
parameter_list:	   parameter_declaration { $$ = $1; }
		|  parameter_list ',' parameter_declaration {
			$$ = cmop($1, $3);
		}
		;

/*
 * Returns a node pointer to the declaration.
 */
parameter_declaration:
		   declaration_specifiers declarator {
			if ($1->n_lval != SNULL && $1->n_lval != REGISTER)
				uerror("illegal parameter class");
			$$ = tymerge($1, $2);
			nfree($1);
		
		}
		|  declaration_specifiers abstract_declarator { 
			$$ = tymerge($1, $2);
			nfree($1);
		}
		|  declaration_specifiers {
			$$ = tymerge($1, bdty(NAME, NULL));
			nfree($1);
		}
		;

abstract_declarator:
		   pointer { $$ = $1; $1->n_right->n_left = bdty(NAME, NULL); }
		|  direct_abstract_declarator { $$ = $1; }
		|  pointer direct_abstract_declarator { 
			$$ = $1; $1->n_right->n_left = $2;
		}
		;

direct_abstract_declarator:
		   '(' abstract_declarator ')' { $$ = $2; }
		|  '[' ']' { $$ = biop(LB, bdty(NAME, NULL), bcon(NOOFFSET)); }
		|  '[' con_e ']' { $$ = bdty(LB, bdty(NAME, NULL), $2); }
		|  direct_abstract_declarator '[' ']' {
			$$ = biop(LB, $1, bcon(NOOFFSET));
		}
		|  direct_abstract_declarator '[' con_e ']' {
			$$ = bdty(LB, $1, $3);
		}
		|  '(' ')' { $$ = bdty(UCALL, bdty(NAME, NULL)); }
		|  '(' parameter_type_list ')' {
			$$ = bdty(CALL, bdty(NAME, NULL), $2);
		}
		|  direct_abstract_declarator '(' ')' {
			$$ = bdty(UCALL, $1);
		}
		|  direct_abstract_declarator '(' parameter_type_list ')' {
			$$ = bdty(CALL, $1, $3);
		}
		;

/*
 * K&R arg declaration, between ) and {
 */
arg_dcl_list:	   arg_declaration
		|  arg_dcl_list arg_declaration
		;


arg_declaration:   declaration_specifiers arg_param_list ';' {
			nfree($1);
		}
		;

arg_param_list:	   declarator { olddecl(tymerge($<nodep>0, $1)); }
		|  arg_param_list ',' declarator {
			olddecl(tymerge($<nodep>0, $3));
		}
		;

/*
 * Declarations in beginning of blocks.
 */
block_item_list:   block_item
		|  block_item_list block_item
		;

block_item:	   declaration
		|  statement
		;

/*
 * Here starts the old YACC code.
 */

/*
 * Variables are declared in init_declarator.
 */
declaration:	   declaration_specifiers ';' { nfree($1); fun_inline = 0; }
		|  declaration_specifiers init_declarator_list ';' {
			nfree($1);
			fun_inline = 0;
		}
		;

/*
 * Normal declaration of variables. curtype contains the current type node.
 * Returns nothing, variables are declared in init_declarator.
 */
init_declarator_list:
		   init_declarator
		|  init_declarator_list ',' { $<nodep>$ = $<nodep>0; } init_declarator
		;

enum_dcl:	   enum_head '{' moe_list optcomma '}' { $$ = enumdcl($1); }
		|  C_ENUM C_NAME {  $$ = enumref($2); }
		;

enum_head:	   C_ENUM { $$ = enumhd(NULL); }
		|  C_ENUM C_NAME {  $$ = enumhd($2); }
		;

moe_list:	   moe
		|  moe_list ',' moe
		;

moe:		   C_NAME {  moedef($1); }
		|  C_TYPENAME {  moedef($1); }
		|  C_NAME '=' con_e { enummer = $3; moedef($1); }
		|  C_TYPENAME '=' con_e { enummer = $3; moedef($1); }
		;

struct_dcl:	   str_head '{' struct_dcl_list '}' empty {
			$$ = dclstruct($1); 
		}
		|  C_STRUCT C_NAME {  $$ = rstruct($2,$1); }
		|  str_head '{' '}' {
#ifndef GCC_COMPAT
			werror("gcc extension");
#endif
			$$ = dclstruct($1); 
		}
		;

empty:		   { /* Get yacc read the next token before reducing */ }
		|  NOMATCH
		;

str_head:	   C_STRUCT {  $$ = bstruct(NULL, $1);  }
		|  C_STRUCT C_NAME {  $$ = bstruct($2,$1);  }
		;

struct_dcl_list:   struct_declaration
		|  struct_dcl_list struct_declaration
		;

struct_declaration:
		   specifier_qualifier_list struct_declarator_list ';' {
			nfree($1);
		}
		;

specifier_qualifier_list:
		   merge_specifiers { $$ = typenode($1); }
		;

merge_specifiers:  type_specifier merge_specifiers { $1->n_left = $2;$$ = $1; }
		|  type_specifier { $$ = $1; }
		|  C_QUALIFIER merge_specifiers { $1->n_left = $2; $$ = $1; }
		|  C_QUALIFIER { $$ = $1; }
		;

struct_declarator_list:
		   struct_declarator { }
		|  struct_declarator_list ',' { $<nodep>$=$<nodep>0; } 
			struct_declarator { }
		;

struct_declarator: declarator {
			tymerge($<nodep>0, $1);
			soumemb($1, (char *)$1->n_sp, 0);
			nfree($1);
		}
		|  ':' con_e {
			if (fldchk($2))
				$2 = 1;
			falloc(NULL, $2, -1, $<nodep>0);
		}
		|  declarator ':' con_e {
			if (fldchk($3))
				$3 = 1;
			if ($1->n_op == NAME) {
				tymerge($<nodep>0, $1);
				soumemb($1, (char *)$1->n_sp, FIELD | $3);
				nfree($1);
			} else
				uerror("illegal declarator");
		}
		;

		/* always preceeded by attributes */
xnfdeclarator:	   declarator { $$ = xnf = init_declarator($<nodep>0, $1, 1); }
		;

/*
 * Handles declarations and assignments.
 * Returns nothing.
 */
init_declarator:   declarator { init_declarator($<nodep>0, $1, 0); }
		|  declarator C_ASM '(' string ')' {
#ifdef GCC_COMPAT
			pragma_renamed = newstring($4, strlen($4));
			init_declarator($<nodep>0, $1, 0);
#else
			werror("gcc extension");
			init_declarator($<nodep>0, $1, 0);
#endif
		}
		|  xnfdeclarator '=' e { simpleinit($1, $3); xnf = NULL; }
		|  xnfdeclarator '=' begbr init_list optcomma '}' {
			endinit();
			xnf = NULL;
		}
		|  xnfdeclarator '=' addrlbl { simpleinit($1, $3); xnf = NULL; }
		;

begbr:		   '{' { beginit($<symp>-1); }
		;

initializer:	   e %prec ',' {  $$ = $1; }
		|  addrlbl {  $$ = $1; }
		|  ibrace init_list optcomma '}' { $$ = NULL; }
		;

init_list:	   designation initializer { asginit($2); }
		|  init_list ','  designation initializer { asginit($4); }
		;

designation:	   designator_list '=' { desinit($1); }
		|  { /* empty */ }
		;

designator_list:   designator { $$ = $1; }
		|  designator_list designator { $$ = $2; $$->n_left = $1; }
		;

designator:	   '[' con_e ']' {
			if ($2 < 0) {
				uerror("designator must be non-negative");
				$2 = 0;
			}
			$$ = biop(LB, NIL, bcon($2));
		}
		|  C_STROP C_NAME {
			if ($1 != DOT)
				uerror("invalid designator");
			$$ = bdty(NAME, $2);
		}
		;

optcomma	:	/* VOID */
		|  ','
		;

ibrace:		   '{' {  ilbrace(); }
		;

/*	STATEMENTS	*/

compoundstmt:	   begin block_item_list '}' { flend(); }
		|  begin '}' { flend(); }
		;

begin:		  '{' {
			struct savbc *bc = tmpalloc(sizeof(struct savbc));
			if (blevel == 1) {
#ifdef STABS
				if (gflag)
					stabs_line(lineno);
#endif
				dclargs();
			}
#ifdef STABS
			if (gflag && blevel > 1)
				stabs_lbrac(blevel+1);
#endif
			++blevel;
			oldstyle = 0;
			bc->contlab = autooff;
			bc->next = savctx;
			savctx = bc;
			bccode();
			if (sspflag && blevel == 2)
				sspstart();
		}
		;

statement:	   e ';' { ecomp( $1 ); symclear(blevel); }
		|  compoundstmt
		|  ifprefix statement { plabel($1); reached = 1; }
		|  ifelprefix statement {
			if ($1 != NOLAB) {
				plabel( $1);
				reached = 1;
			}
		}
		|  whprefix statement {
			branch(contlab);
			plabel( brklab );
			if( (flostat&FBRK) || !(flostat&FLOOP))
				reached = 1;
			else
				reached = 0;
			resetbc(0);
		}
		|  doprefix statement C_WHILE '(' e ')' ';' {
			plabel(contlab);
			if (flostat & FCONT)
				reached = 1;
			if (reached)
				cbranch($5, bcon($1));
			else
				tfree($5);
			plabel( brklab);
			reached = 1;
			resetbc(0);
		}
		|  forprefix .e ')' statement
			{  plabel( contlab );
			    if( flostat&FCONT ) reached = 1;
			    if( $2 ) ecomp( $2 );
			    branch($1);
			    plabel( brklab );
			    if( (flostat&FBRK) || !(flostat&FLOOP) ) reached = 1;
			    else reached = 0;
			    resetbc(0);
			    }
		| switchpart statement
			{ if( reached ) branch( brklab );
			    plabel( $1 );
			    swend();
			    plabel( brklab);
			    if( (flostat&FBRK) || !(flostat&FDEF) ) reached = 1;
			    resetbc(FCONT);
			    }
		|  C_BREAK  ';' {
			if (brklab == NOLAB)
				uerror("illegal break");
			else if (reached)
				branch(brklab);
			flostat |= FBRK;
			reached = 0;
		}
		|  C_CONTINUE  ';' {
			if (contlab == NOLAB)
				uerror("illegal continue");
			else
				branch(contlab);
			flostat |= FCONT;
			goto rch;
		}
		|  C_RETURN  ';' {
			branch(retlab);
			if (cftnsp->stype != VOID && 
			    (cftnsp->sflags & NORETYP) == 0 &&
			    cftnsp->stype != VOID+FTN)
				uerror("return value required");
			rch:
			if (!reached && Wunreachable_code)
				werror( "statement is not reached");
			reached = 0;
		}
		|  C_RETURN e  ';' {
			register NODE *temp;

			temp = nametree(cftnsp);
			temp->n_type = DECREF(temp->n_type);
			temp = buildtree(RETURN, temp, $2);

			if (temp->n_type == VOID)
				ecomp(temp->n_right);
			else
				ecomp(buildtree(FORCE, temp->n_right, NIL));
			tfree(temp->n_left);
			nfree(temp);
			branch(retlab);
			reached = 0;
		}
		|  C_GOTO C_NAME ';' { gotolabel($2); goto rch; }
		|  C_GOTO '*' e ';' { ecomp(biop(GOTO, $3, NIL)); }
		|  asmstatement ';'
		|   ';'
		|  error  ';'
		|  error '}'
		|  label statement
		;

asmstatement:	   C_ASM mvol '(' string ')' { send_passt(IP_ASM, mkpstr($4)); }
		|  C_ASM mvol '(' string xasm ')' { mkxasm($4, $5); }
		;

mvol:		   /* empty */
		|  C_QUALIFIER { nfree($1); }
		;

xasm:		   ':' oplist { $$ = xcmop($2, NIL, NIL); }
		|  ':' oplist ':' oplist { $$ = xcmop($2, $4, NIL); }
		|  ':' oplist ':' oplist ':' cnstr { $$ = xcmop($2, $4, $6); }
		;

oplist:		   /* nothing */ { $$ = NIL; }
		|  oper { $$ = $1; }
		;

oper:		   string '(' e ')' { $$ = xasmop($1, $3); }
		|  oper ',' string '(' e ')' { $$ = cmop($1, xasmop($3, $5)); }
		;

cnstr:		   string { $$ = xasmop($1, bcon(0)); }
		|  cnstr ',' string { $$ = cmop($1, xasmop($3, bcon(0))); }
                ;

label:		   C_NAME ':' { deflabel($1); reached = 1; }
		|  C_TYPENAME ':' { deflabel($1); reached = 1; }
		|  C_CASE e ':' { addcase($2); reached = 1; }
		|  C_DEFAULT ':' { reached = 1; adddef(); flostat |= FDEF; }
		;

doprefix:	C_DO {
			savebc();
			brklab = getlab();
			contlab = getlab();
			plabel(  $$ = getlab());
			reached = 1;
		}
		;
ifprefix:	C_IF '(' e ')' {
			cbranch(buildtree(NOT, $3, NIL), bcon($$ = getlab()));
			reached = 1;
		}
		;
ifelprefix:	  ifprefix statement C_ELSE {
			if (reached)
				branch($$ = getlab());
			else
				$$ = NOLAB;
			plabel( $1);
			reached = 1;
		}
		;

whprefix:	  C_WHILE  '('  e  ')' {
			savebc();
			if ($3->n_op == ICON && $3->n_lval != 0)
				flostat = FLOOP;
			plabel( contlab = getlab());
			reached = 1;
			brklab = getlab();
			if (flostat == FLOOP)
				tfree($3);
			else
				cbranch(buildtree(NOT, $3, NIL), bcon(brklab));
		}
		;
forprefix:	  C_FOR  '('  .e  ';' .e  ';' {
			if ($3)
				ecomp($3);
			savebc();
			contlab = getlab();
			brklab = getlab();
			plabel( $$ = getlab());
			reached = 1;
			if ($5)
				cbranch(buildtree(NOT, $5, NIL), bcon(brklab));
			else
				flostat |= FLOOP;
		}
		|  C_FOR '(' incblev declaration .e ';' {
			blevel--;
			savebc();
			contlab = getlab();
			brklab = getlab();
			plabel( $$ = getlab());
			reached = 1;
			if ($5)
				cbranch(buildtree(NOT, $5, NIL), bcon(brklab));
			else
				flostat |= FLOOP;
		}
		;

incblev:	   { blevel++; }
		;

switchpart:	   C_SWITCH  '('  e  ')' {
			NODE *p;
			int num;
			TWORD t;

			savebc();
			brklab = getlab();
			if (($3->n_type != BOOL && $3->n_type > ULONGLONG) ||
			    $3->n_type < CHAR) {
				uerror("switch expression must have integer "
				       "type");
				t = INT;
			} else {
				$3 = intprom($3);
				t = $3->n_type;
			}
			p = tempnode(0, t, 0, MKSUE(t));
			num = regno(p);
			ecomp(buildtree(ASSIGN, p, $3));
			branch( $$ = getlab());
			swstart(num, t);
			reached = 0;
		}
		;
/*	EXPRESSIONS	*/
con_e:		{ $<rp>$ = rpole; rpole = NULL; } e %prec ',' {
			$$ = icons($2);
			rpole = $<rp>1;
		}
		;

nocon_e:	{ $<rp>$ = rpole; rpole = NULL; } e %prec ',' {
			rpole = $<rp>1;
			$$ = $2;
		}
		;

.e:		   e
		| 	{ $$=0; }
		;

elist:		   e %prec ','
		|  elist  ','  e { $$ = buildtree(CM, $1, $3); }
		|  elist  ','  cast_type { /* hack for stdarg */
			$3->n_op = TYPE;
			$$ = buildtree(CM, $1, $3);
		}
		;

/*
 * Precedence order of operators.
 */
e:		   e ',' e { $$ = buildtree(COMOP, $1, $3); }
		|  e '=' e {  $$ = buildtree(ASSIGN, $1, $3); }
		|  e C_ASOP e {  $$ = buildtree($2, $1, $3); }
		|  e '?' e ':' e {
			$$=buildtree(QUEST, $1, buildtree(COLON, $3, $5));
		}
		|  e C_OROR e { $$ = buildtree($2, $1, $3); }
		|  e C_ANDAND e { $$ = buildtree($2, $1, $3); }
		|  e '|' e { $$ = buildtree(OR, $1, $3); }
		|  e '^' e { $$ = buildtree(ER, $1, $3); }
		|  e '&' e { $$ = buildtree(AND, $1, $3); }
		|  e C_EQUOP  e { $$ = buildtree($2, $1, $3); }
		|  e C_RELOP e { $$ = buildtree($2, $1, $3); }
		|  e C_SHIFTOP e { $$ = buildtree($2, $1, $3); }
		|  e '+' e { $$ = buildtree(PLUS, $1, $3); }
		|  e '-' e { $$ = buildtree(MINUS, $1, $3); }
		|  e C_DIVOP e { $$ = buildtree($2, $1, $3); }
		|  e '*' e { $$ = buildtree(MUL, $1, $3); }
		|  e '=' addrlbl { $$ = buildtree(ASSIGN, $1, $3); }
		|  '(' begin block_item_list e ';' '}' ')' { $$ = $4; flend(); }
		|  term
		;

addrlbl:	  C_ANDAND C_NAME {
#ifdef GCC_COMPAT
			struct symtab *s = lookup($2, SLBLNAME);
			if (s->soffset == 0)
				s->soffset = -getlab();
			$$ = buildtree(ADDROF, nametree(s), NIL);
#else
			uerror("gcc extension");
#endif
		}
		;

term:		   term C_INCOP {  $$ = buildtree( $2, $1, bcon(1) ); }
		|  '*' term { $$ = buildtree(UMUL, $2, NIL); }
		|  '&' term {
			if( ISFTN($2->n_type)/* || ISARY($2->n_type) */){
#ifdef notdef
				werror( "& before array or function: ignored" );
#endif
				$$ = $2;
			} else
				$$ = buildtree(ADDROF, $2, NIL);
		}
		|  '-' term { $$ = buildtree(UMINUS, $2, NIL ); }
		|  '+' term { $$ = $2; }
		|  C_UNOP term { $$ = buildtree( $1, $2, NIL ); }
		|  C_INCOP term {
			$$ = buildtree($1 == INCR ? PLUSEQ : MINUSEQ,
			    $2, bcon(1));
		}
		|  C_SIZEOF term { $$ = doszof($2); }
		|  '(' cast_type ')' term  %prec C_INCOP {
			register NODE *q;
			$$ = buildtree(CAST, $2, $4);
			nfree($$->n_left);
			q = $$->n_right;
			nfree($$);
			$$ = q;
		}
		|  C_SIZEOF '(' cast_type ')'  %prec C_SIZEOF {
			$$ = doszof($3);
		}
		| '(' cast_type ')' clbrace init_list optcomma '}' {
			endinit();
			$$ = nametree($4);
		}
		|  term '[' e ']' {
			$$ = buildtree( UMUL,
			    buildtree( PLUS, $1, $3 ), NIL );
		}
		|  funct_idn  ')' { $$ = doacall($1, NIL); }
		|  funct_idn elist ')' { $$ = doacall($1, $2); }
		|  term C_STROP C_NAME { $$ = structref($1, $2, $3); }
		|  term C_STROP C_TYPENAME { $$ = structref($1, $2, $3); }
		|  C_NAME {
			struct symtab *sp;

			sp = lookup($1, 0);
			if (sp->sflags & SINLINE)
				inline_ref(sp);
			$$ = nametree(sp);
			if (sp->sflags & SDYNARRAY)
				$$ = buildtree(UMUL, $$, NIL);
		}
		|  C_ICON { $$ = $1; }
		|  C_FCON { $$ = $1; }
		|  string {  $$ = strend(widestr, $1); }
		|   '('  e  ')' { $$=$2; }
		;

clbrace:	   '{'	{ $$ = clbrace($<nodep>-1); }
		;

string:		   C_STRING { widestr = $1[0] == 'L'; $$ = stradd("", $1); }
		|  string C_STRING { $$ = stradd($1, $2); }
		;

cast_type:	   specifier_qualifier_list {
			$$ = tymerge($1, bdty(NAME, NULL));
			nfree($1);
		}
		|  specifier_qualifier_list abstract_declarator {
			$$ = tymerge($1, $2);
			nfree($1);
		}
		;

funct_idn:	   C_NAME  '(' {
			struct symtab *s = lookup($1, 0);
			if (s->stype == UNDEF) {
				register NODE *q;
				q = block(NAME, NIL, NIL, FTN|INT, 0, MKSUE(INT));
				q->n_sp = s;
				defid(q, EXTERN);
				nfree(q);
			}
			if (s->sflags & SINLINE)
				inline_ref(s);
			$$ = nametree(s);
		}
		|  term  '(' 
		;
%%

NODE *
mkty(TWORD t, union dimfun *d, struct suedef *sue)
{
	return block(TYPE, NIL, NIL, t, d, sue);
}

static NODE *
bdty(int op, ...)
{
	va_list ap;
	int val;
	register NODE *q;

	va_start(ap, op);
	q = biop(op, NIL, NIL);

	switch (op) {
	case UMUL:
	case UCALL:
		q->n_left = va_arg(ap, NODE *);
		q->n_rval = 0;
		break;

	case CALL:
		q->n_left = va_arg(ap, NODE *);
		q->n_right = va_arg(ap, NODE *);
		break;

	case LB:
		q->n_left = va_arg(ap, NODE *);
		if ((val = va_arg(ap, int)) <= 0) {
			uerror("array size must be positive");
			val = 1;
		}
		q->n_right = bcon(val);
		break;

	case NAME:
		q->n_sp = va_arg(ap, struct symtab *); /* XXX survive tymerge */
		break;

	default:
		cerror("bad bdty");
	}
	va_end(ap);

	return q;
}

static void
flend(void)
{
	if (sspflag && blevel == 2)
		sspend();
#ifdef STABS
	if (gflag && blevel > 2)
		stabs_rbrac(blevel);
#endif
	--blevel;
	if( blevel == 1 )
		blevel = 0;
	symclear(blevel); /* Clean ut the symbol table */
	if (autooff > maxautooff)
		maxautooff = autooff;
	autooff = savctx->contlab;
	savctx = savctx->next;
}

static void
savebc(void)
{
	struct savbc *bc = tmpalloc(sizeof(struct savbc));

	bc->brklab = brklab;
	bc->contlab = contlab;
	bc->flostat = flostat;
	bc->next = savbc;
	savbc = bc;
	flostat = 0;
}

static void
resetbc(int mask)
{
	flostat = savbc->flostat | (flostat&mask);
	contlab = savbc->contlab;
	brklab = savbc->brklab;
	savbc = savbc->next;
}

struct swdef {
	struct swdef *next;	/* Next in list */
	int deflbl;		/* Label for "default" */
	struct swents *ents;	/* Linked sorted list of case entries */
	int nents;		/* # of entries in list */
	int num;		/* Node value will end up in */
	TWORD type;		/* Type of switch expression */
} *swpole;

/*
 * add case to switch
 */
static void
addcase(NODE *p)
{
	struct swents **put, *w, *sw = tmpalloc(sizeof(struct swents));
	CONSZ val;

	p = optim(p);  /* change enum to ints */
	if (p->n_op != ICON || p->n_sp != NULL) {
		uerror( "non-constant case expression");
		return;
	}
	if (swpole == NULL) {
		uerror("case not in switch");
		return;
	}

	if (DEUNSIGN(swpole->type) != DEUNSIGN(p->n_type)) {
		val = p->n_lval;
		p = makety(p, swpole->type, 0, 0, MKSUE(swpole->type));
		if (p->n_op != ICON)
			cerror("could not cast case value to type of switch "
			       "expression");
		if (p->n_lval != val)
			werror("case expression truncated");
	}
	sw->sval = p->n_lval;
	tfree(p);
	put = &swpole->ents;
	if (ISUNSIGNED(swpole->type)) {
		for (w = swpole->ents;
		     w != NULL && (U_CONSZ)w->sval < (U_CONSZ)sw->sval;
		     w = w->next)
			put = &w->next;
	} else {
		for (w = swpole->ents; w != NULL && w->sval < sw->sval;
		     w = w->next)
			put = &w->next;
	}
	if (w != NULL && w->sval == sw->sval) {
		uerror("duplicate case in switch");
		return;
	}
	plabel(sw->slab = getlab());
	*put = sw;
	sw->next = w;
	swpole->nents++;
}

/*
 * add default case to switch
 */
static void
adddef(void)
{
	if (swpole == NULL)
		uerror("default not inside switch");
	else if (swpole->deflbl != 0)
		uerror("duplicate default in switch");
	else
		plabel( swpole->deflbl = getlab());
}

static void
swstart(int num, TWORD type)
{
	struct swdef *sw = tmpalloc(sizeof(struct swdef));

	sw->deflbl = sw->nents = 0;
	sw->ents = NULL;
	sw->next = swpole;
	sw->num = num;
	sw->type = type;
	swpole = sw;
}

/*
 * end a switch block
 */
static void
swend(void)
{
	struct swents *sw, **swp;
	int i;

	sw = tmpalloc(sizeof(struct swents));
	swp = tmpalloc(sizeof(struct swents *) * (swpole->nents+1));

	sw->slab = swpole->deflbl;
	swp[0] = sw;

	for (i = 1; i <= swpole->nents; i++) {
		swp[i] = swpole->ents;
		swpole->ents = swpole->ents->next;
	}
	genswitch(swpole->num, swpole->type, swp, swpole->nents);

	swpole = swpole->next;
}

/*
 * num: tempnode the value of the switch expression is in
 * type: type of the switch expression
 *
 * p points to an array of structures, each consisting
 * of a constant value and a label.
 * The first is >=0 if there is a default label;
 * its value is the label number
 * The entries p[1] to p[n] are the nontrivial cases
 * n is the number of case statements (length of list)
 */
static void
genswitch(int num, TWORD type, struct swents **p, int n)
{
	NODE *r, *q;
	int i;

	if (mygenswitch(num, type, p, n))
		return;

	/* simple switch code */
	for (i = 1; i <= n; ++i) {
		/* already in 1 */
		r = tempnode(num, type, 0, MKSUE(type));
		q = xbcon(p[i]->sval, NULL, type);
		r = buildtree(NE, r, clocal(q));
		cbranch(buildtree(NOT, r, NIL), bcon(p[i]->slab));
	}
	if (p[0]->slab > 0)
		branch(p[0]->slab);
}

/*
 * Declare a variable or prototype.
 */
static struct symtab *
init_declarator(NODE *tn, NODE *p, int assign)
{
	int class = tn->n_lval;
	NODE *typ;

	typ = tymerge(tn, p);
	typ->n_sp = lookup((char *)typ->n_sp, 0); /* XXX */

	if (fun_inline && ISFTN(typ->n_type))
		typ->n_sp->sflags |= SINLINE;

	if (ISFTN(typ->n_type) == 0) {
		if (assign) {
			defid(typ, class);
			typ->n_sp->sflags |= SASG;
			if (typ->n_sp->sflags & SDYNARRAY)
				uerror("can't initialize dynamic arrays");
			lcommdel(typ->n_sp);
		} else {
			nidcl(typ, class);
		}
	} else {
		if (assign)
			uerror("cannot initialise function");
		defid(typ, uclass(class));
	}
	nfree(p);
	return typ->n_sp;
}

/*
 * Declare function arguments.
 */
static void
funargs(NODE *p)
{
	if (p->n_op == ELLIPSIS)
		return;
	if (oldstyle) {
		p->n_op = TYPE;
		p->n_type = FARG;
	}
	p->n_sp = lookup((char *)p->n_sp, 0);/* XXX */
	if (ISFTN(p->n_type))
		p->n_type = INCREF(p->n_type);
	defid(p, PARAM);
}

/*
 * Declare a function.
 */
static void
fundef(NODE *tp, NODE *p)
{
	extern int prolab;
	struct symtab *s;
	NODE *q = p;
	int class = tp->n_lval, oclass;
	char *c;

	for (q = p; coptype(q->n_op) != LTYPE && q->n_left->n_op != NAME;
	    q = q->n_left)
		;
	if (q->n_op != CALL && q->n_op != UCALL) {
		uerror("invalid function definition");
		p = bdty(UCALL, p);
	}

	argoff = ARGINIT;
	ctval = tvaloff;
	blevel++;

	if (q->n_op == CALL && q->n_right->n_type != VOID) {
		/* declare function arguments */
		listf(q->n_right, funargs);
		ftnarg(q);
	}

	blevel--;
	tymerge(tp, p);
	s = p->n_sp = lookup((char *)p->n_sp, 0); /* XXX */

	oclass = s->sclass;
	if (class == STATIC && oclass == EXTERN)
		werror("%s was first declared extern, then static", s->sname);

	if (fun_inline) {
		/* special syntax for inline functions */
		if ((oclass == SNULL || oclass == USTATIC) &&
		    (class == STATIC || class == SNULL)) {
		/* Unreferenced, store it for (eventual) later use */
		/* Ignore it if it not declared static */
			s->sflags |= SINLINE;
			inline_start(s);
		} else if (class == EXTERN)
			class = EXTDEF;
	} else if (class == EXTERN)
		class = SNULL; /* same result */

	cftnsp = s;
	defid(p, class);
	prolab = getlab();
	c = cftnsp->soname;
	send_passt(IP_PROLOG, -1, -1, c, cftnsp->stype,
	    cftnsp->sclass == EXTDEF, prolab, ctval);
	blevel++;
#ifdef STABS
	if (gflag)
		stabs_func(s);
#endif
	nfree(tp);
	nfree(p);

}

static void
fend(void)
{
	if (blevel)
		cerror("function level error");
	ftnend();
	fun_inline = 0;
	cftnsp = NULL;
}

static NODE *
structref(NODE *p, int f, char *name)
{
	NODE *r;

	if (f == DOT)
		p = buildtree(ADDROF, p, NIL);
	r = biop(NAME, NIL, NIL);
	r->n_name = name;
	r = buildtree(STREF, p, r);
	return r;
}

static void
olddecl(NODE *p)
{
	struct symtab *s;

	s = lookup((char *)p->n_sp, 0);
	if (s->slevel != 1 || s->stype == UNDEF)
		uerror("parameter '%s' not defined", s->sname);
	else if (s->stype != FARG)
		uerror("parameter '%s' redefined", s->sname);
	s->stype = p->n_type;
	s->sdf = p->n_df;
	s->ssue = p->n_sue;
	nfree(p);
}

void
branch(int lbl)
{
	int r = reached++;
	ecomp(biop(GOTO, bcon(lbl), NIL));
	reached = r;
}

/*
 * Create a printable string based on an encoded string.
 */
static char *
mkpstr(char *str)
{
	char *s, *os;
	int v, l = strlen(str)+3; /* \t + \n + \0 */

	os = s = inlalloc(l);
	*s++ = '\t';
	for (; *str; ) {
		if (*str++ == '\\')
			v = esccon(&str);
		else
			v = str[-1];
		*s++ = v;
	}
	*s++ = '\n';
	*s = 0;
	return os;
}

/*
 * Estimate the max length a string will have in its internal 
 * representation based on number of \ characters.
 */
static int
maxstlen(char *str)
{
	int i;

	for (i = 0; *str; str++, i++)
		if (*str == '\\' || *str < 32 || *str > 0176)
			i += 3;
	return i;
}

static char *
voct(char *d, unsigned int v)
{
	v &= (1 << SZCHAR) - 1;
	*d++ = '\\';
	*d++ = v/64 + '0'; v &= 077;
	*d++ = v/8 + '0'; v &= 7;
	*d++ = v + '0';
	return d;
}
	

/*
 * Convert a string to internal format.  The resulting string may be no
 * more than len characters long.
 */
static void
fixstr(char *d, char *s, int len)
{
	unsigned int v;

	while (*s) {
		if (len <= 0)
			cerror("fixstr");
		if (*s == '\\') {
			s++;
			v = esccon(&s);
			d = voct(d, v);
			len -= 4;
		} else if (*s < ' ' || *s > 0176) {
			d = voct(d, *s++);
			len -= 4;
		} else
			*d++ = *s++, len--;
	}
	*d = 0;
}

/*
 * Add "raw" string new to cleaned string old.
 */
static char *
stradd(char *old, char *new)
{
	char *rv;
	int len;

	if (*new == 'L' && new[1] == '\"')
		widestr = 1, new++;
	if (*new == '\"') {
		new++;			 /* remove first " */
		new[strlen(new) - 1] = 0;/* remove last " */
	}
	len = strlen(old) + maxstlen(new) + 1;
	rv = tmpalloc(len);
	strlcpy(rv, old, len);
	fixstr(rv + strlen(old), new, maxstlen(new) + 1);
	return rv;
}

static struct symtab *
clbrace(NODE *p)
{
	struct symtab *sp;

	if (blevel == 0 && xnf != NULL)
		cerror("no level0 compound literals");

	sp = getsymtab("cl", STEMP);
	sp->stype = p->n_type;
	sp->squal = p->n_qual;
	sp->sdf = p->n_df;
	sp->ssue = p->n_sue;
	sp->sclass = blevel ? AUTO : STATIC;
	if (!ISARY(sp->stype) || sp->sdf->ddim != NOOFFSET) {
		sp->soffset = NOOFFSET;
		oalloc(sp, &autooff);
	}
	tfree(p);
	beginit(sp);
	return sp;
}

NODE *
biop(int op, NODE *l, NODE *r)
{
	return block(op, l, r, INT, 0, MKSUE(INT));
}

static NODE *
cmop(NODE *l, NODE *r)
{
	return biop(CM, l, r);
}

static NODE *
voidcon(void)
{
	return block(ICON, NIL, NIL, STRTY, 0, MKSUE(VOID));
}

/* Support for extended assembler a' la' gcc style follows below */

static NODE *
xmrg(NODE *out, NODE *in)
{
	NODE *p = in;

	if (p->n_op == XARG) {
		in = cmop(out, p);
	} else {
		while (p->n_left->n_op == CM)
			p = p->n_left;
		p->n_left = cmop(out, p->n_left);
	}
	return in;
}

/*
 * Put together in and out node lists in one list, and balance it with
 * the constraints on the right side of a CM node.
 */
static NODE *
xcmop(NODE *out, NODE *in, NODE *str)
{
	NODE *p, *q;

	if (out) {
		/* D out-list sanity check */
		for (p = out; p->n_op == CM; p = p->n_left) {
			q = p->n_right;
			if (q->n_name[0] != '=' && q->n_name[0] != '+')
				uerror("output missing =");
		}
		if (p->n_name[0] != '=' && p->n_name[0] != '+')
			uerror("output missing =");
		if (in == NIL)
			p = out;
		else
			p = xmrg(out, in);
	} else if (in) {
		p = in;
	} else
		p = voidcon();

	if (str == NIL)
		str = voidcon();
	return cmop(p, str);
}

/*
 * Generate a XARG node based on a string and an expression.
 */
static NODE *
xasmop(char *str, NODE *p)
{

	p = biop(XARG, p, NIL);
	p->n_name = isinlining ? newstring(str, strlen(str)+1) : str;
	return p;
}

/*
 * Generate a XASM node based on a string and an expression.
 */
static void
mkxasm(char *str, NODE *p)
{
	NODE *q;

	q = biop(XASM, p->n_left, p->n_right);
	q->n_name = isinlining ? newstring(str, strlen(str)+1) : str;
	nfree(p);
	ecomp(q);
}
@


1.10
log
@Updates from master repo.  Can now compile both userland and kernel.
(with some patches...)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgram.y,v 1.9 2008/04/11 20:45:52 stefan Exp $	*/
@


1.9
log
@Sync with master repo. Reminded by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a81 1
%token	C_WSTRING	/* a wide string constant */
d145 1
a145 1
static int fun_inline;	/* Reading an inline function */
a146 1
int noretype;
d150 3
a152 1
static int ctval;
d173 4
a176 1

d210 3
a212 3
		identifier_list arg_param_list arg_declaration arg_dcl_list
		designator_list designator xasm oplist oper cnstr
%type <strp>	string wstring C_STRING C_WSTRING
d228 1
a228 1
external_def:	   function_definition { blevel = 0; }
d235 9
a243 23
function_definition:
	/* Ansi (or K&R header without parameter types) */
		   declaration_specifiers declarator {
			fundef($1, $2);
		} compoundstmt { fend(); }
	/* Same as above but without declaring function type */
		|  declarator {
			noretype = 1;
			fundef(mkty(INT, 0, MKSUE(INT)), $1);
		} compoundstmt { fend(); noretype = 0; }
	/* K&R function without type declaration */
		|  declarator {
			noretype = 1;
			if (oldstyle == 0)
				uerror("bad declaration in ansi function");
			fundef(mkty(INT, 0, MKSUE(INT)), $1);
		} arg_dcl_list compoundstmt { fend(); noretype = 0; }
	/* K&R function with type declaration */
		|  declaration_specifiers declarator {
			if (oldstyle == 0)
				uerror("bad declaration in ansi function");
			fundef($1, $2);
		} arg_dcl_list compoundstmt { fend(); }
d266 1
a266 5
		   C_FUNSPEC {
			if (fun_inline)
				uerror("too many inline");
			fun_inline = 1;
		}
d324 1
a324 1
			if (blevel == 0 && !nncon($3))
d326 6
d334 9
a342 3
			else if ($3->n_op == ICON && $3->n_lval < 0) {
				uerror("array size must be non-negative");
				$3->n_lval = 1;
d344 7
a350 1
			$$ = block(LB, $1, $3, INT, 0, MKSUE(INT));
d352 2
a353 10
		|  direct_declarator '[' ']' { $$ = bdty(LB, $1, 0); }
		|  direct_declarator '(' fundcl parameter_type_list ')' {
			if (blevel-- > 1)
				symclear(blevel);
			$$ = bdty(CALL, $1, $4);
		}
		|  direct_declarator '(' fundcl identifier_list ')' { 
			if (blevel-- > 1)
				symclear(blevel);
			$$ = bdty(CALL, $1, $4);
d364 2
a365 14
fundcl:		   { if (++blevel == 1) argoff = ARGINIT; ctval = tvaloff; }
		;

identifier_list:   C_NAME {
			$$ = mkty(FARG, NULL, MKSUE(INT));
			$$->n_sp = lookup($1, 0);
			defid($$, PARAM);
		}
		|  identifier_list ',' C_NAME { 
			$$ = mkty(FARG, NULL, MKSUE(INT));
			$$->n_sp = lookup($3, 0);
			defid($$, PARAM);
			$$ = block(CM, $1, $$, 0, 0, 0);
		}
d374 1
a374 2
			$$ = block(CM, $1, block(ELLIPSIS, NIL, NIL, 0, 0, 0),
			    0, 0, 0);
d385 1
a385 1
			$$ = block(CM, $1, $3, 0, 0, 0);
d394 1
a394 2
			if ($1->n_lval == AUTO || $1->n_lval == TYPEDEF ||
			    $1->n_lval == EXTERN || $1->n_lval == STATIC)
a396 6
			if (blevel == 1) {
				$$->n_sp = lookup((char *)$$->n_sp, 0);/* XXX */
				if (ISFTN($$->n_type))
					$$->n_type = INCREF($$->n_type);
				defid($$, PARAM);
			}
d420 1
a420 1
		|  '[' ']' { $$ = bdty(LB, bdty(NAME, NULL), 0); }
d422 3
a424 1
		|  direct_abstract_declarator '[' ']' { $$ = bdty(LB, $1, 0); }
d477 1
a477 1
declaration:	   declaration_specifiers ';' { nfree($1); goto inl; }
a479 1
			inl:
d559 1
a559 2
			soumemb($1, (char *)$1->n_sp,
			    $<nodep>0->n_lval); /* XXX */
d630 1
a630 1
			$$ = bdty(LB, NULL, $2);
d648 2
a649 28
compoundstmt:	   begin block_item_list '}' {  
#ifdef STABS
			if (gflag && blevel > 2)
				stabs_rbrac(blevel);
#endif
			--blevel;
			if( blevel == 1 )
				blevel = 0;
			symclear(blevel); /* Clean ut the symbol table */
			if (autooff > maxautooff)
				maxautooff = autooff;
			autooff = savctx->contlab;
			savctx = savctx->next;
		}
		|  begin '}' {
#ifdef STABS
			if (gflag && blevel > 2)
				stabs_rbrac(blevel);
#endif
			--blevel;
			if( blevel == 1 )
				blevel = 0;
			symclear(blevel); /* Clean ut the symbol table */
			if (autooff > maxautooff)
				maxautooff = autooff;
			autooff = savctx->contlab;
			savctx = savctx->next;
		}
d671 2
d742 2
a743 1
			if (cftnsp->stype != VOID && noretype &&
d747 1
a747 1
			if (!reached)
d754 1
a754 2
			spname = cftnsp;
			temp = buildtree( NAME, NIL, NIL );
d768 1
a768 3
		|  C_GOTO '*' e ';' {
			ecomp(block(GOTO, $3, NIL, INT, 0, 0));
		}
d776 6
a781 2
asmstatement:	   C_ASM '(' string ')' { send_passt(IP_ASM, mkpstr($3)); }
		|  C_ASM '(' string xasm ')' { mkxasm($3, $4); }
d802 1
a808 2
			if (!reached)
				werror("loop not entered at top");
a831 2
			if (!reached)
				werror("loop not entered at top");
a845 2
			else if (!reached)
				werror("loop not entered at top");
d944 1
d953 1
a953 2
			spname = s;
			$$ = buildtree(ADDROF, buildtree(NAME, NIL, NIL), NIL);
d963 1
a963 1
			if( ISFTN($2->n_type) || ISARY($2->n_type) ){
d992 1
a992 2
			spname = $4;
			$$ = buildtree(NAME, NIL, NIL);
d1003 7
a1009 5
			spname = lookup($1, 0);
			if (spname->sflags & SINLINE)
				inline_ref(spname);
			$$ = buildtree(NAME, NIL, NIL);
			if (spname->sflags & SDYNARRAY)
d1014 1
a1014 2
		|  string {  $$ = strend(0, $1); /* get string contents */ }
		|  wstring { $$ = strend('L', $1); }
d1021 2
a1022 24
string:		   C_STRING {
			int len = strlen($1) + 1;
			$$ = tmpalloc(len);
			strlcpy($$, $1, len);
		}
		|  string C_STRING { 
			int len = strlen($1) + strlen($2) + 1;
			$$ = tmpalloc(len);
			strlcpy($$, $1, len);
			strlcat($$, $2, len);
		}
		;

wstring:	  C_WSTRING {
			int len = strlen($1) + 1;
			$$ = tmpalloc(len);
			strlcpy($$, $1, len);
		}
		|  string C_WSTRING { 
			int len = strlen($1) + strlen($2) + 1;
			$$ = tmpalloc(len);
			strlcpy($$, $1, len);
			strlcat($$, $2, len);
		}
d1046 1
a1046 2
			spname = s;
			$$ = buildtree(NAME, NIL, NIL);
d1066 1
a1066 1
	q = block(op, NIL, NIL, INT, 0, MKSUE(INT));
d1082 5
a1086 3
		if ((val = va_arg(ap, int)) < 0)
			uerror("array size must be non-negative");
		q->n_right = bcon(val < 0 ? 1 : val);
d1102 19
d1170 9
a1178 8
	val = p->n_lval;
	p = makety(p, swpole->type, 0, 0, MKSUE(swpole->type));
	if (p->n_op != ICON)
		cerror("could not cast case value to type of switch "
		       "expression");
	if (p->n_lval != val)
		werror("case expression truncated");

d1320 18
d1349 3
a1351 2
	while (q->n_op == UMUL)
		q = q->n_left;
d1357 9
a1365 3
	/* Save function args before they are clobbered in tymerge() */
	/* Typecheck against prototype will be done in defid(). */
	ftnarg(p);
d1367 1
d1375 4
a1378 2
	if ((oclass == SNULL || oclass == USTATIC) &&
	    class == STATIC && fun_inline) {
d1381 5
a1385 4
		s->sflags |= SINLINE;
		inline_start(s);
	}
	if (class == EXTERN)
d1421 1
a1421 1
	r = block(NAME, NIL, NIL, INT, 0, MKSUE(INT));
d1447 1
a1447 1
	ecomp(block(GOTO, bcon(lbl), NIL, INT, 0, 0));
d1460 1
a1460 1
	os = s = isinlining ? permalloc(l) : tmpalloc(l);
d1474 75
d1563 1
a1563 1
	if (!ISARY(sp->stype) || sp->sdf->ddim != 0) {
d1572 5
a1576 1
/* Support for extended assembler a' la' gcc style follows below */
d1581 1
a1581 1
	return block(CM, l, r, INT, 0, MKSUE(INT));
d1590 2
d1620 1
a1620 1
			if (q->n_name[0] != '=')
d1623 1
a1623 1
		if (p->n_name[0] != '=')
d1646 2
a1647 2
	p = block(XARG, p, NIL, INT, 0, MKSUE(INT));
	p->n_name = str;
d1659 2
a1660 2
	q = block(XASM, p->n_left, p->n_right, INT, 0, MKSUE(INT));
	q->n_name = str;
@


1.8
log
@Large update from master repo:
> Pragma not position dependent
> Accept declarations anywhere in the C code.
> Just typing "a;" is not allowed anymore when declaring variables.
> Change to new initializer handling.
> Use symtab entry, not name to identify inline functions.
> Remove "suse" symtab element and replace it with output name.
> Print out strings directly, do not store them until end.
> Make prtdcon() target dependent to allow for float constants in code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgram.y,v 1.7 2007/11/25 10:27:35 stefan Exp $	*/
d150 3
a152 1
extern int enummer;
d166 1
a166 1
static NODE * structref(NODE *p, int f, char *name);
d169 5
d208 1
a208 1
		designator_list designator
d338 3
d350 3
a352 1
		|  direct_declarator '(' notype parameter_type_list ')' {
d355 3
a357 1
		|  direct_declarator '(' notype identifier_list ')' { 
d363 4
a366 1
		|  direct_declarator '(' ')' { $$ = bdty(UCALL, $1); }
d369 1
a369 1
notype:		   { /* extern int notype, doproto; notype = 0; doproto=1; printf("notype\n"); */ }
d372 5
a376 1
identifier_list:   C_NAME { $$ = bdty(NAME, $1); $$->n_type = FARG; }
d378 3
a380 2
			$$ = bdty(NAME, $3);
			$$->n_type = FARG;
a386 1
 * Calls revert() to get the parameter list in the forward order.
d412 3
d416 6
d423 1
d452 2
a453 2
		|  '(' notype parameter_type_list ')' {
			$$ = bdty(CALL, bdty(NAME, NULL), $3);
d458 2
a459 2
		|  direct_abstract_declarator '(' notype parameter_type_list ')' {
			$$ = bdty(CALL, $1, $4);
d530 1
d532 1
a538 1
		|  C_STRUCT C_TYPENAME {  $$ = rstruct($2,$1); }
a552 1
		|  C_STRUCT C_TYPENAME {  $$ = bstruct($2,$1);  }
d583 2
a584 2
			$1->n_sp = getsymtab((char *)$1->n_sp, SMOSNAME); /* XXX */
			defid($1, $<nodep>0->n_lval); 
d588 1
a588 4
			if (!(instruct&INSTRUCT))
				uerror( "field outside of structure" );
			if ($2 < 0 || $2 >= FIELD) {
				uerror("illegal field size");
a589 1
			}
d593 1
a593 4
			if (!(instruct&INSTRUCT))
				uerror( "field outside of structure" );
			if( $3<0 || $3 >= FIELD ){
				uerror( "illegal field size" );
a594 1
			}
d597 1
a597 2
				$1->n_sp = getsymtab((char *)$1->n_sp,SMOSNAME);
				defid($1, FIELD|$3);
d657 5
a661 1
		|  C_STROP C_NAME { $$ = bdty(NAME, $2); }
d725 1
a725 1
statement:	   e ';' { ecomp( $1 ); }
d828 10
d840 8
d908 12
d921 4
d950 3
a952 3
con_e:		{ $<intval>$=instruct; instruct=0; } e %prec ',' {
			$$ = icons( $2 );
			instruct=$<intval>1;
d956 2
a957 2
nocon_e:	{ $<intval>$=instruct; instruct=0; } e %prec ',' {
			instruct=$<intval>1;
d1042 1
a1042 1
		| '(' cast_type ')' clbrace init_list '}' {
d1357 2
d1380 1
d1384 8
a1391 1
	/* Enter function args before they are clobbered in tymerge() */
d1417 2
a1418 2
	    cftnsp->sclass == EXTDEF, prolab);
	blevel = 1;
d1482 1
a1482 1
	int v, l = strlen(str)+1;
d1485 1
d1493 1
d1519 87
@


1.7
log
@Pull from master repo:
Complain about invalid bit-field size for unnamed bit-fields as well.
ok ragge@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgram.y,v 1.6 2007/11/22 15:06:43 stefan Exp $	*/
d119 1
a119 7

/*
 * These tokens are only used for pragmas; let yacc handle syntax check.
 */
%token	PRAG_PACKED
%token	PRAG_ALIGNED
%token	PRAG_RENAMED
a150 4
#ifdef GCC_COMPAT
char *renname; /* for renaming of variables */
#endif

d193 1
a193 1
		type_qualifier_list str_attr
d202 1
a202 1
%type <strp>	string wstring C_STRING C_WSTRING PRAG_RENAMED
a207 1
		PRAG_PACKED PRAG_ALIGNED
d331 6
d454 6
a459 2
declaration_list:  declaration
		|  declaration_list declaration
a465 4
stmt_list:	   stmt_list statement
		|  { bccode(); }
		;

d502 2
a503 2
struct_dcl:	   str_head '{' struct_dcl_list '}' str_attr {
			$$ = dclstruct($1, $5); 
d511 1
a511 1
			$$ = dclstruct($1, 0); 
d515 2
a516 3
str_attr:	   { $$ = 0; /* nothing */ }
		|  PRAG_PACKED { $$ = PRAG_PACKED; }
		|  PRAG_ALIGNED { $$ = PRAG_ALIGNED; }
a590 4
		|  declarator PRAG_RENAMED {
			renname = $2; /* XXX ugly */
			init_declarator($<nodep>0, $1, 0);
		}
d593 1
a593 1
			renname = $4;
d628 7
a634 1
designator:	   '[' con_e ']' { $$ = bdty(LB, NULL, $2); }
d647 1
a647 1
compoundstmt:	   begin declaration_list stmt_list '}' {  
d661 1
a661 1
		|  begin stmt_list '}' {
d695 1
d882 1
a882 1
			num = p->n_lval;
a996 10
			/* recognize identifiers in initializations */
			if (blevel==0 && spname->stype == UNDEF) {
				register NODE *q;
				werror("undeclared initializer name %s",
				    spname->sname);
				q = block(NAME, NIL, NIL, INT, 0, MKSUE(INT));
				q->n_sp = spname;
				defid(q, EXTERN);
				nfree(q);
			}
d998 1
a998 1
				inline_ref($1);
a999 1
			spname->suse = -lineno;
d1005 2
a1006 2
		|  string {  $$ = strend($1); /* get string contents */ }
		|  wstring { $$ = wstrend($1); }
d1059 1
a1059 1
				inline_ref($1);
a1061 1
			s->suse = -lineno;
d1077 1
d1097 3
a1099 1
		q->n_right = bcon(va_arg(ap, int));
d1270 1
a1270 3
		q = block(ICON, NIL, NIL, type, 0, MKSUE(type));
		q->n_sp = NULL;
		q->n_lval = p[i]->sval;
a1293 1
		setloc1(DATA);
a1320 1
	setloc1(PROG);
d1337 1
a1337 1
		inline_start(s->sname);
d1345 1
a1345 4
	c = cftnsp->sname;
#ifdef GCC_COMPAT
	c = gcc_findname(cftnsp);
#endif
@


1.6
log
@Pull from master repo:

Put the genswitch() code that is found in most backends into
the MI part. The backend version is renamed to mygenswitch()
and can provide improved translations for switch statements.

Improved implementation of the switch constraints/semantics
described in the standard.

ok ragge@@, otto@@

With help and comments from ragge and gmcgarry
@
text
@d1 1
a1 1
/*	$OpenBSD: cgram.y,v 1.5 2007/11/18 17:39:55 ragge Exp $	*/
d565 4
@


1.5
log
@(Large) update from master repo:
> Use structure assignment instead of calling memcpy directly in struct return.
> Rewrite enum handling.
> In C99 enums are treated like INTs so convert them early to int.
> Move the enum tag handling out of defid(), tags are in their own namespace.
> This will be done with struct/union tags also.
> Comment out enum types.
> Remove ENUMTY/MOETY from target code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgram.y,v 1.4 2007/11/16 09:00:12 otto Exp $	*/
d172 2
a173 1
static void swstart(int);
d867 1
d871 8
a878 7
			if ($3->n_type != INT) {
				/* must cast to integer */
				p = block(NAME, NIL, NIL, INT, 0, MKSUE(INT));
				p = buildtree(CAST, p, $3);
				$3 = p->n_right;
				nfree(p->n_left);
				nfree(p);
d880 1
a880 2
//			ecomp( buildtree( FORCE, $3, NIL ) );
			p = tempnode(0, INT, 0, MKSUE(INT));
d884 1
a884 1
			swstart(num);
d1150 1
d1160 1
d1172 8
d1181 1
d1183 11
a1193 3
	for (w = swpole->ents; w != NULL && w->sval < sw->sval; w = w->next)
		put = &w->next;
	if (w != NULL && w->sval == sw->sval)
d1195 1
a1195 5
	else {
		plabel(sw->slab = getlab());
		*put = sw;
		sw->next = w;
		swpole->nents++;
d1197 4
a1200 1
	tfree(p);
d1218 1
a1218 1
swstart(int num)
d1226 1
d1249 1
a1249 1
	genswitch(swpole->num, swp, swpole->nents);
d1252 34
@


1.4
log
@sync tree with master repo; Nov 16 2007
@
text
@d1 1
a1 1
/*	$OpenBSD: cgram.y,v 1.175 2007/11/15 23:54:29 gmcgarry Exp $	*/
d156 1
d212 2
a213 2
%type <rp>	enum_head str_head
%type <symp>	xnfdeclarator clbrace
d490 2
a491 3
enum_dcl:	   enum_head '{' moe_list optcomma '}' { $$ = dclstruct($1, 0); }
		|  C_ENUM C_NAME {  $$ = rstruct($2,0);  }
		|  C_ENUM C_TYPENAME {  $$ = rstruct($2,0);  }
d494 2
a495 3
enum_head:	   C_ENUM {  $$ = bstruct(NULL,0); }
		|  C_ENUM C_NAME {  $$ = bstruct($2,0); }
		|  C_ENUM C_TYPENAME {  $$ = bstruct($2,0); }
d502 2
a503 2
moe:		   C_NAME {  moedef( $1 ); }
		|  C_NAME '=' con_e {  strucoff = $3;  moedef( $1 ); }
@


1.3
log
@Pull from master repo:
Fix sorting bug in addcase(). Spotted by Gregory McGarry.
ok gmcgarry, ragge@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgram.y,v 1.2 2007/10/07 18:34:41 otto Exp $	*/
d150 1
d784 1
a784 1
			nfree(temp->n_left);
d970 1
d973 1
d975 1
a975 1
			$$ = $$->n_right; /* XXX use after free */
@


1.2
log
@Merge from ragge's repo:
Add initial support for packed/aligned/rename pragmas.
Still missing:  Support for architectures with strict alignment.
TODO: Cleanup the rename stuff so that it's not depending on gcc
compat.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgram.y,v 1.1 2007/10/07 17:58:51 otto Exp $	*/
d1154 1
a1154 1
	struct swents *w, *sw = tmpalloc(sizeof(struct swents));
d1167 10
a1176 28
	plabel( sw->slab = getlab());
	w = swpole->ents;
	if (swpole->ents == NULL) {
		sw->next = NULL;
		swpole->ents = sw;
	} else if (swpole->ents->next == NULL) {
		if (swpole->ents->sval == sw->sval) {
			uerror("duplicate case in switch");
		} else if (swpole->ents->sval < sw->sval) {
			sw->next = NULL;
			swpole->ents->next = sw;
		} else {
			sw->next = swpole->ents;
			swpole->ents = sw;
		}
	} else {
		while (w->next->next != NULL && w->next->sval < sw->sval) {
			w = w->next;
		}
		if (w->next->sval == sw->sval) {
			uerror("duplicate case in switch");
		} else if (w->next->sval > sw->sval) {
			sw->next = w->next;
			w->next = sw;
		} else {
			sw->next = NULL;
			w->next->next = sw;
		}
a1177 1
	swpole->nents++;
@


1.1
log
@reorg pcc tree; requested by and ok deraadt@@; ok ragge@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgram.y,v 1.3 2007/10/01 18:51:57 otto Exp $	*/
d121 7
d200 1
a200 1
		type_qualifier_list
d209 1
a209 1
%type <strp>	string wstring C_STRING C_WSTRING
d215 2
d488 1
a488 1
enum_dcl:	   enum_head '{' moe_list optcomma '}' { $$ = dclstruct($1); }
d506 3
a508 1
struct_dcl:	   str_head '{' struct_dcl_list '}' { $$ = dclstruct($1);  }
d515 1
a515 1
			$$ = dclstruct($1); 
d519 5
d592 4
d972 1
a972 1
			$$ = $$->n_right;
d1354 2
a1355 1
	return buildtree(STREF, p, r);
@

