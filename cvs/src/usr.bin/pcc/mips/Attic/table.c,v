head	1.6;
access;
symbols
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.16
	OPENBSD_5_0:1.5.0.14
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.12
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.10
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.6
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.8
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4;
locks; strict;
comment	@ * @;


1.6
date	2012.04.12.11.51.13;	author pirofti;	state dead;
branches;
next	1.5;

1.5
date	2008.04.11.20.45.52;	author stefan;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.22.22.56.31;	author stefan;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.22.14.12.26;	author stefan;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.16.08.34.55;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.07.17.58.51;	author otto;	state Exp;
branches;
next	;


desc
@@


1.6
log
@tedu(tm) pcc.

Message sent. Okay deraadt@@.
@
text
@/*	$OpenBSD: table.c,v 1.5 2008/04/11 20:45:52 stefan Exp $	*/
/*
 * Copyright (c) 2003 Anders Magnusson (ragge@@ludd.luth.se).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * MIPS port by Jan Enoksson (janeno-1@@student.ltu.se) and
 * Simon Olsson (simols-1@@student.ltu.se) 2005.
 *
 * It appears that the target machine was big endian.  The original
 * code contained many endian aspects which are now handled in
 * machine-independent code.
 * 
 * On MIPS, the assembler does an amazing amount of work for us.
 * We don't have to worry about PIC, nor about finding the address
 * of SNAMES.  Whenever possible, we defer the work to the assembler.
 */

#include "pass2.h"

#define TUWORD TUNSIGNED|TULONG
#define TSWORD TINT|TLONG
#define TWORD TUWORD|TSWORD

struct optab table[] = {
/* First entry must be an empty entry */
{ -1, FOREFF, SANY, TANY, SANY, TANY, 0, 0, "", },

/* PCONVs are usually not necessary */
{ PCONV,	INAREG,
	SAREG,	TWORD|TPOINT,
	SAREG,	TWORD|TPOINT,
		0,	RLEFT,
		"	# convert between word and pointer", },

/*
 * Conversions of integral<->integral types
 */

{ SCONV,	INAREG,
	SOREG,  TCHAR,
	SAREG,	TSWORD|TSHORT,
		NAREG,	RESC1,
		"	lb A1,AL	# convert oreg char to short/int\n"
		"	nop\n", },

{ SCONV, 	INAREG,
	SOREG,	TCHAR,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
		NAREG,	RESC1,
		"	lbu A1,AL	# conver oreg char to uchar/ushort/uint\n"
		"	nop\n", },

{ SCONV,	INAREG,
	SOREG,  TUCHAR,
	SAREG,	TWORD|TSHORT|TUSHORT,
		NAREG,	RESC1,
		"	lbu A1,AL	# convert oreg uchar to (u)short/(u)int\n"
		"	nop\n", },

{ SCONV,	INBREG,
	SOREG,	TCHAR,
	SBREG,	TLONGLONG,
		NBREG,	RESC1,
      		"	lb A1,AL	# convert oreg char to longlong\n"
      		"	nop\n"
      		"	sra U1,A1,31\n", },

/* chor -> ulonglong handled later */

{ SCONV,	INBREG,
	SOREG,	TUCHAR,
	SBREG,	TLONGLONG|TULONGLONG,
		NBREG,	RESC1,
		"	lbu A1,AL	# convert oreg uchar to (u)longlong\n"
      		"	move U1,$zero\n", },

{ SCONV,	INAREG,
	SOREG,	TSHORT|TUSHORT,
	SAREG,	TCHAR,
		NAREG,	RESC1,
		"	lb A1,AL	# convert oreg (u)short to char (endianness problem?)\n"
		"	nop\n", },

{ SCONV,	INAREG,
	SOREG,	TSHORT|TUSHORT,
	SAREG,  TUCHAR,
		NAREG,	RESC1,
		"	lbu A1,AL	# convert oreg (u)short to uchar (endianness problem?)\n"
		"	nop\n", },

{ SCONV,	INAREG,
	SOREG,	TSHORT,
	SAREG,	TSWORD,
		NAREG,	RESC1,
		"	lh A1,AL	# convert oreg short to int\n"
		"	nop\n", },

{ SCONV,	INAREG,
	SOREG,	TSHORT,
	SAREG,	TUWORD,
		NAREG,	RESC1,
		"	lhu A1,AL	# convert oreg short to uint\n"
		"	nop\n", },

{ SCONV,	INAREG,
	SOREG,	TUSHORT,
	SAREG,	TWORD,
		NAREG,	RESC1,
		"	lhu A1,AL	# convert oreg ushort to (u)int\n"
		"	nop\n", },

{ SCONV,	INBREG,
	SOREG,	TSHORT,
	SBREG,	TLONGLONG,
		NBREG,	RESC1,
      		"	lh A1,AL	# convert oreg short to longlong\n"
      		"	nop\n"
      		"	sra U1,A1,31\n", },

{ SCONV,	INBREG,
	SOREG,	TSHORT,
	SBREG,	TULONGLONG,
		NBREG,	RESC1,
      		"	lhu A1,AL	# convert oreg short to ulonglong\n"
      		"	nop\n"
		"	move U1,$zero\n", },

{ SCONV,	INBREG,
	SOREG,	TUSHORT,
	SBREG,	TLONGLONG|TULONGLONG,
		NBREG,	RESC1,
		"	lhu A1,AL	# convert oreg ushort to (u)longlong\n"
      		"	move U1,$zero\n", },

{ SCONV,	INAREG,
	SOREG,	TWORD,
	SAREG,	TCHAR,
		NAREG,	RESC1,
		"	lb A1,AL	# convert oreg word to char (endianness problem here?)\n"
		"	nop\n", },

{ SCONV,	INAREG,
	SOREG,	TWORD,
	SAREG,	TUCHAR,
		NAREG,	RESC1,
		"	lbu A1,AL	# convert oreg word to uchar (endianness problem here?)\n"
		"	nop\n", },
    
{ SCONV,	INAREG,
	SOREG,	TWORD,
	SAREG,	TSHORT,
		NAREG,	RESC1,
		"	lh A1,AL	# convert oreg word to short (endianness problem here?)\n"
		"	nop\n", },

/* convert (u)long to ushort */
{ SCONV,	INAREG,
	SOREG,	TWORD,
	SAREG,	TUSHORT,
		NAREG,	RESC1,
		"	lhu A1,AL	# convert oreg word to ushort (endianness problem here?)\n"
		"	nop\n", },

{ SCONV,	INBREG,
	SOREG,	TSWORD,
	SBREG,	TLONGLONG|TULONGLONG,
		NBREG,	RESC1,
      		"	lw A1,AL	# convert oreg int/long to (u)llong (endianness problem here?)\n"
      		"	nop\n"
      		"	sra U1,A1,31\n" },

{ SCONV,	INBREG,
	SOREG,	TUWORD,
	SBREG,	TLONGLONG|TULONGLONG,
		NBREG,	RESC1,
		"	lw A1,AL	# convert oreg (u)int to (u)llong (endianness problem here?)\n"
      		"	move U1,$zero\n", },

{ SCONV,	INAREG,
	SOREG,	TLONGLONG|TULONGLONG,
	SAREG,	TCHAR,
		NAREG,	RESC1,
		"	lb A1,AL	# convert oreg (u)llong to char	(endianness problem here?)\n"
		"	nop\n", },

{ SCONV,	INAREG,
	SOREG,	TLONGLONG|TULONGLONG,
	SAREG,	TUCHAR,
		NAREG,	RESC1,
		"	lbu A1,AL	# convert oreg (u)llong to uchar (endianness problem?)\n"
		"	nop\n", },
    
{ SCONV,	INAREG,
	SOREG,	TLONGLONG|TULONGLONG,
	SAREG,	TSHORT,
		NAREG,	RESC1,
		"	lh A1,AL	# convert oreg (u)llong to short (endianness problem?)\n"
		"	nop\n", },

{ SCONV,	INAREG,
	SOREG,	TLONGLONG|TULONGLONG,
	SAREG,	TUSHORT,
		NAREG,	RESC1,
		"	lhu A1,AL	# convert oreg (u)llong to ushort (endianness problem here?)\n"
		"	nop\n", },

{ SCONV,	INAREG,
	SOREG,	TLONGLONG|TULONGLONG,
	SAREG,	TWORD,
		NAREG,	RESC1,
      		"	lw A1,AL	# convert oreg (u)llong to (u)int (endianness problem here?)\n"
		"	nop\n", },

/*
 * Conversions of integral types (register-register)
 *
 * For each deunsigned type, they look something like this:
 *
 * signed -> bigger signed      - nothing to do
 * signed -> bigger unsigned    - clear the top bits (of source type)
 *
 * signed -> smaller signed     - sign-extend the bits (to dest type)
 * signed -> smaller unsigned   - clear the top bits (of dest type)
 * unsigned -> smaller signed   - sign-extend top bits (to dest type)
 * unsigned -> smaller unsigned - clear the top bits (of dest type)
 *
 * unsigned -> bigger           - nothing to do
 */

{ SCONV,	INAREG,
	SAREG,	TPOINT|TWORD,
	SAREG,	TPOINT|TWORD,
		0,	RLEFT,
		"	# convert int to int\n", },

{ SCONV,	INBREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SBREG,	TLONGLONG|TULONGLONG,
		0,	RLEFT,
		"	# convert (u)longlong to (u)longlong", },

{ SCONV,	INAREG,
	SAREG,	TCHAR,
	SAREG,	TSWORD|TSHORT,
		0,	RLEFT,
		"	# convert char to short/int\n", },

{ SCONV,	INAREG,
	SAREG,	TCHAR,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
		NAREG|NASL,	RESC1,
		"	andi A1,AL,255	# convert char to uchar/ushort/uint\n", },

{ SCONV,	INAREG,
	SAREG,	TUCHAR,
	SAREG,	TCHAR,
		NAREG|NASL,	RESC1,
		"	sll A1,AL,24	# convert uchar to char\n"
		"	sra A1,A1,24\n", },

{ SCONV,	INAREG,
	SAREG,	TUCHAR,
	SAREG,	TWORD|TSHORT|TUSHORT,
		0,	RLEFT,
		"	# convert uchar to (u)short/(u)int\n", },

{ SCONV,	INAREG,
	SAREG,	TSHORT,
	SAREG,	TCHAR,
		NAREG|NASL,	RESC1,
		"	sll A1,AL,24	# convert short to char\n"
		"	sra A1,A1,24\n", },

{ SCONV,	INAREG,
	SAREG,	TSHORT,
	SAREG,	TUCHAR,
		NAREG|NASL,	RESC1,
		"	andi A1,AL,255	# convert short to uchar\n", },

{ SCONV,	INAREG,
	SAREG,	TSHORT,
	SAREG,	TUWORD|TUSHORT,
		NAREG|NASL,	RESC1,
		"	andi A1,AL,65535	# convert short to ushort\n", },

{ SCONV,	INAREG,
	SAREG,	TSHORT,
	SAREG,	TSWORD,
		NAREG|NASL,	RESC1,
		"	sll A1,AL,16	# convert short to ushort\n"
		"	sra A1,A1,16\n", },

{ SCONV,	INAREG,
	SAREG,	TUSHORT,
	SAREG,	TCHAR,
		NAREG|NASL,	RESC1,
		"	sll A1,AL,24	# convert short to char\n"
		"	sra A1,A1,24\n", },

{ SCONV,	INAREG,
	SAREG,	TUSHORT,
	SAREG,	TUCHAR,
		NAREG|NASL,	RESC1,
		"	andi A1,AL,255	# convert ushort to char\n", },

{ SCONV,	INAREG,
	SAREG,	TUSHORT,
	SAREG,	TSHORT,
		NAREG|NASL,	RESC1,
		"	sll A1,AL,16	# convert short to ushort\n"
		"	sra A1,A1,16\n", },

{ SCONV,	INAREG,
	SAREG,	TUSHORT,
	SAREG,	TWORD,
		0,	RDEST,
		"	# convert ushort to (u)int\n", },

{ SCONV,	INAREG,
	SAREG,	TSWORD,
	SAREG,	TCHAR,
		NAREG|NASL,	RESC1,
		"	sll A1,AL,8	# convert int to char\n"
		"	sra A1,A1,8\n", },

{ SCONV,	INAREG,
	SAREG,	TSWORD,
	SAREG,	TUCHAR,
		NAREG|NASL,	RESC1,
		"	andi A1,AL,255	# convert int to uchar\n", },

{ SCONV,	INAREG,
	SAREG,	TSWORD,
	SAREG,	TSHORT,
		NAREG|NASL,	RESC1,
		"	sll A1,AL,16	# convert int to short\n"
		"	sra A1,A1,16\n", },

{ SCONV,	INAREG,
	SAREG,	TSWORD,
	SAREG,	TUSHORT,
		NAREG|NASL,	RESC1,
		"	andi A1,AL,65535	# convert int to ushort\n", },

{ SCONV,	INAREG,
	SAREG,	TUWORD,
	SAREG,	TCHAR,
		NAREG|NASL,	RESC1,
		"	sll A1,AL,24	# convert int to char\n"
		"	sra A1,A1,24\n", },

{ SCONV,	INAREG,
	SAREG,	TUWORD,
	SAREG,	TUCHAR,
		NAREG|NASL,	RESC1,
		"	andi A1,AL,255	# convert int to uchar\n", },

{ SCONV,	INAREG,
	SAREG,	TUWORD,
	SAREG,	TSHORT,
		NAREG|NASL,	RESC1,
		"	sll A1,AL,16	# convert int to short\n"
		"	sra A1,A1,16\n", },

{ SCONV,	INAREG,
	SAREG,	TUWORD,
	SAREG,	TUSHORT,
		NAREG|NASL,	RESC1,
		"	andi A1,AL,65535	# convert int to ushort\n", },

{ SCONV,	INBREG,
	SAREG,	TSWORD|TSHORT|TCHAR,
	SBREG,	TLONGLONG,
		NBREG,	RESC1,
		"	move A1,AL	# convert int/short/char to longlong\n"
		"	sra U1,AL,31\n", },

{ SCONV,	INBREG,
	SAREG,	TSWORD|TSHORT|TCHAR,
	SBREG,	TULONGLONG,
		NBREG,	RESC1,
		"	move A1,AL	# convert int/short/char to ulonglong\n"
		"	move U1,$zero\n", },

{ SCONV,	INBREG,
	SAREG,	TWORD|TUSHORT|TSHORT|TUCHAR|TCHAR,
	SBREG,	TLONGLONG|TULONGLONG,
		NBREG,	RESC1,
		"	move A1,AL	# convert (u)int/(u)short/(u)char to ulonglong\n"
		"	move U1,$zero\n", },

{ SCONV,	INAREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SAREG,	TWORD,
		NAREG,	RESC1,
		"	move A1,AL	# convert (u)longlong to int\n", },

{ SCONV,	INAREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SAREG,	TSHORT,
		NAREG,	RESC1,
		"	sll A1,AL,16	# convert (u)longlong to short\n"
		"	sra A1,AL,16\n", },

{ SCONV,	INAREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SAREG,	TCHAR,
		NAREG,	RESC1,
		"	sll A1,AL,24	# convert (u)longlong to char\n"
		"	sra A1,AL,24\n", },

{ SCONV,	INAREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SAREG,	TUSHORT,
		NAREG,	RESC1,
		"	andi A1,AL,65535	# convert (u)longlong to ushort\n", },

{ SCONV,	INAREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SAREG,	TUCHAR,
		NAREG,	RESC1,
		"	andi A1,AL,255	# convert (u)longlong to uchar\n", },

{ SCONV,	INCREG,
	SCREG,	TFLOAT,
	SCREG,	TDOUBLE|TLDOUBLE,
		NCREG,	RESC1,
		"	cvt.d.s A1,AL	# convert float to (l)double\n", },

{ SCONV,	INCREG,
	SCREG,	TDOUBLE|TLDOUBLE,
	SCREG,	TFLOAT,
		NCREG,	RESC1,
		"	cvt.s.d A1,AL	# convert (l)double to float\n", },

{ SCONV,	INCREG,
	SAREG,	TWORD,
	SCREG,	TFLOAT,
		NCREG,	RESC1,
		"	mtc1 AL,A1	# convert (u)int to float\n"
		"	nop\n"
		"	cvt.s.w A1,A1\n", },

{ SCONV,	INCREG,
	SOREG,	TWORD,
	SCREG,	TFLOAT,
		NCREG,	RESC1,
		"	l.s A1,AL	# convert (u)int to float\n"
		"	nop\n"
		"	cvt.s.w A1,A1\n", },

{ SCONV,	INCREG,
	SAREG,	TWORD,
	SCREG,	TDOUBLE|TLDOUBLE,
		NCREG,	RESC1,
		"	mtc1 AL,A1	# convert (u)int to (l)double\n"
		"	nop\n"
		"	cvt.d.w A1,A1\n", },

{ SCONV,	INCREG,
	SOREG,	TWORD,
	SCREG,	TDOUBLE|TLDOUBLE,
		NCREG,	RESC1,
		"	l.d A1,AL	# convert (u)int to (l)double\n"
		"	nop\n"
		"	cvt.d.w A1,A1\n", },

{ SCONV,	INAREG,
	SCREG,	TFLOAT,
	SAREG,	TWORD,
		NCREG|NAREG,	RESC1,
		"	cvt.w.s A2,AL	# convert float to (u)int\n"
		"	mfc1 A1,A2\n"
		"	nop\n", },

{ SCONV,	FOREFF,
	SCREG,	TFLOAT,
	SOREG,	TWORD,
		NCREG,	RDEST,
		"	cvt.w.s A1,AL	# convert float to (u)int\n"
		"	s.s A1,AR\n"
		"	nop\n", },

{ SCONV,	INAREG,
	SCREG,	TDOUBLE|TLDOUBLE,
	SAREG,	TWORD,
		NCREG|NAREG,	RESC1,
		"	cvt.w.d A2,AL	# convert (l)double to (u)int\n"
		"	mfc1 A1,A2\n"
		"	nop\n", },

{ SCONV,	INCREG,
	SCREG,	TDOUBLE|TLDOUBLE,
	SCREG,	TDOUBLE|TLDOUBLE,
		0,	RLEFT,
		"	# convert between double and ldouble\n", },

{ SCONV,	INCREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SCREG,	TFLOAT,
		NSPECIAL|NCREG,	RESC1,
		"ZF", },

{ SCONV,	INCREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SCREG,	TDOUBLE|TLDOUBLE,
		NSPECIAL|NCREG,	RESC1,
		"ZF", },

{ SCONV,	INBREG,
	SCREG,	TDOUBLE|TLDOUBLE,
	SBREG,	TLONGLONG|TULONGLONG,
		NSPECIAL|NBREG,		RESC1,
		"ZF", },

{ SCONV,	INBREG,
	SCREG,	TFLOAT,
	SBREG,	TLONGLONG|TULONGLONG,
		NSPECIAL|NBREG,		RESC1,
		"ZF", },

/*
 * Multiplication and division
 */

{ MUL,	INAREG,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
		NAREG|NASR|NASL,	RESC1,
		"	multu AL,AR	# unsigned multiply\n"
		"	mflo A1\n"
		"	nop\n"
		"	nop\n", },

/* this previous will match on unsigned/unsigned multiplication first */
{ MUL,	INAREG,
	SAREG,	TWORD|TUSHORT|TSHORT|TUCHAR|TCHAR,
	SAREG,	TWORD|TUSHORT|TSHORT|TUCHAR|TCHAR,
		NAREG|NASR|NASL,	RESC1,
		"	mult AL,AR	# signed multiply\n"
		"	mflo A1\n"
		"	nop\n"
		"	nop\n", },

{ MUL,	INBREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SBREG,	TLONGLONG|TULONGLONG,
		2*NBREG,	RESC1,
		"	multu AL,AR\n"
		"	mfhi U1\n"
		"	mflo A1\n"
		"	mult AL,UR\n"
		"	mflo A2\n"
		"	nop\n"
		"	nop\n"
		"	addu A2,U1,A2\n"
		"	mult UL,AR\n"
		"	mflo U2\n"
		"	nop\n"
		"	nop\n"
		"	addu U1,A2,U2\n", },

{ MUL,	INCREG,
	SCREG,	TFLOAT,
	SCREG,	TFLOAT,
		NCREG,	RESC1,
		"	mul.s A1,AL,AR		# floating-point multiply\n", },

{ MUL,	INCREG,
	SCREG,	TDOUBLE|TLDOUBLE,
	SCREG,	TDOUBLE|TLDOUBLE,
		NCREG,	RESC1, 
		"	mul.d	A1,AL,AR	# double-floating-point multiply\n", },

{ DIV,	INAREG,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
		NAREG|NASR|NASL,	RESC1,
		"	divu AL,AR	# unsigned division\n"
		"	mflo A1\n"
		"	nop\n"
		"	nop\n", },

/* the previous rule will match unsigned/unsigned first */
{ DIV,	INAREG,
	SAREG,	TWORD|TUSHORT|TSHORT|TUCHAR|TCHAR,
	SAREG,	TWORD|TUSHORT|TSHORT|TUCHAR|TCHAR,
		NAREG|NASR|NASL,	RESC1,
		"	div AL,AR	# signed division\n"
		"	mflo A1\n"
		"	nop\n"
		"	nop\n", },

{ DIV, INBREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SBREG,	TLONGLONG|TULONGLONG,
		NSPECIAL|NBREG,	RESC1,
		"ZE", },

{ DIV,	INCREG,
	SCREG,	TFLOAT,
	SCREG,	TFLOAT,
		NCREG,	RESC1,
		"	div.s A1,AL,AR		# floating-point division\n", },

{ DIV,	INCREG,
	SCREG,	TDOUBLE|TLDOUBLE,
	SCREG,	TDOUBLE|TLDOUBLE,
		NCREG,	RESC1, 
		"	div.d	A1,AL,AR	# double-floating-point division\n", },

{ MOD,  INAREG,
        SAREG,  TUWORD|TUSHORT|TUCHAR,
        SAREG,  TUWORD|TUSHORT|TUCHAR,
                NAREG,  RESC1,
                "       divu AL,AR	# signed modulo\n"
		"	mfhi A1\n"
		"	nop\n"
		"	nop\n", },

/* the previous rule will match unsigned%unsigned first */
{ MOD,  INAREG,
        SAREG,  TWORD|TUSHORT|TSHORT|TUCHAR|TCHAR,
        SAREG,  TWORD|TUSHORT|TSHORT|TUCHAR|TCHAR,
                NAREG,  RESC1,
                "	div AL,AR	# signed modulo\n"
		"	mfhi A1\n"
		"	nop\n"
		"	nop\n", },

{ MOD,  INBREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SBREG,	TLONGLONG|TULONGLONG,
                NSPECIAL|NBREG,  RESC1,
                "ZE", },
    
/*
 * Templates for unsigned values needs to come before OPSIMP 
 */

{ PLUS,	INBREG,
	SBREG,	TULONGLONG|TLONGLONG,
	SBREG,	TULONGLONG|TLONGLONG,
		2*NBREG,	RESC1,
      		"	addu A1,AL,AR	# 64-bit addition\n"
      		"	sltu A2,A1,AR\n"
      		"	addu U1,UL,UR\n"
      		"	addu U1,U1,A2\n", },

{ PLUS,	INAREG,
	SAREG,	TSWORD|TSHORT|TCHAR,
	SAREG,	TSWORD|TSHORT|TCHAR,
		NAREG|NASL,	RESC1,
      		"	add A1,AL,AR\n", },

{ PLUS,	INAREG,
	SAREG,	TSWORD|TSHORT|TCHAR,
	SSCON,	TWORD,
		NAREG|NASL,	RESC1,
		"	addi A1,AL,AR\n", },

{ PLUS,	INAREG,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
	SSCON,	TWORD,
		NAREG|NASL,	RESC1,
		"	addiu A1,AL,AR\n", },

{ PLUS,	INAREG,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
		NAREG|NASL,	RESC1,
      		"	addu A1,AL,AR\n", },

{ PLUS,	INCREG,
	SCREG,	TFLOAT,
	SCREG,	TFLOAT,
		NCREG|NCSL,	RESC1,
		"	add.s A1,AL,AR\n", },

{ PLUS,	INCREG,
	SCREG,	TDOUBLE|TLDOUBLE,
	SCREG,	TDOUBLE|TLDOUBLE,
		NCREG|NCSL,	RESC1,
		"	add.d A1,AL,AR\n", },

{ MINUS,	INBREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SBREG,	TLONGLONG|TULONGLONG,
		2*NBREG,	RESC1,
      		"	sltu A2,AL,AR	# 64-bit subtraction\n"
      		"	subu A1,AL,AR\n"
      		"	subu U1,UL,UR\n"
      		"	subu U1,U1,A2\n", },

{ MINUS,	INAREG,
	SAREG,	TSWORD|TSHORT|TCHAR,
	SAREG,	TSWORD|TSHORT|TCHAR,
		NAREG|NASL,	RESC1,
      		"	sub A1,AL,AR\n", },

{ MINUS,	INAREG,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
		NAREG|NASL,	RESC1,
      		"	subu A1,AL,AR\n", },

{ MINUS,	INAREG,
	SAREG,	TWORD|TPOINT|TSHORT|TUSHORT|TCHAR|TUCHAR,
	SSCON,	TANY,
		NAREG|NASL,	RESC1,
		"	subu A1,AL,AR\n", },

{ MINUS,	INCREG,
	SCREG,	TFLOAT,
	SCREG,	TFLOAT,
		NCREG|NCSL,	RESC1,
		"	sub.s A1,AL,AR\n", },

{ MINUS,	INCREG,
	SCREG,	TDOUBLE|TLDOUBLE,
	SCREG,	TDOUBLE|TLDOUBLE,
		NCREG|NCSL,	RESC1,
		"	sub.d A1,AL,AR\n", },

{ UMINUS,	INAREG,
	SAREG,	TWORD|TPOINT|TSHORT|TUSHORT|TCHAR|TUCHAR,
	SANY,	TANY,
		NAREG|NASL,	RESC1,
		"	neg A1,AL\n", },

{ UMINUS,	INBREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SANY,	TANY,
		NBREG|NAREG|NBSL,	RESC1,
		"	subu A1,$zero,AL\n"
		"	subu U1,$zero,UL\n"
		"	sltu A2,$zero,A1\n"
		"	subu U1,U1,A2\n", },

{ UMINUS,	INCREG,
	SCREG,	TFLOAT,
	SCREG,	TFLOAT,
		NCREG|NCSL,	RESC1,
		"	neg.s A1,AL\n", },

{ UMINUS,	INCREG,
	SCREG,	TDOUBLE|TLDOUBLE,
	SCREG,	TDOUBLE|TLDOUBLE,
		NCREG|NCSL,	RESC1,
		"	neg.d A1,AL\n", },

/* Simple 'op rd, rs, rt' or 'op rt, rs, imm' operations */

{ OPSIMP,	INBREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SBREG,	TLONGLONG|TULONGLONG,
		NBREG|NBSR|NBSL,	RESC1,
      		"	O A1,AL,AR\n"
      		"	O U1,UL,UR\n", },
    
{ OPSIMP,	INAREG,
	SAREG,	TWORD|TPOINT|TSHORT|TUSHORT|TUCHAR|TCHAR,
	SAREG,	TWORD|TPOINT|TSHORT|TUSHORT|TUCHAR|TCHAR,
		NAREG|NASR|NASL,	RESC1,
		"	O A1,AL,AR\n", },

{ OPSIMP,	INAREG,
	SAREG,	TWORD|TPOINT|TSHORT|TUSHORT|TUCHAR|TCHAR,
	SPCON,	TSHORT|TUSHORT|TUCHAR|TCHAR,
		NAREG|NASL,	RESC1,
		"	Oi A1,AL,AR\n", },

/*
 * Shift instructions
 */

{ RS,	INAREG,
	SAREG,	TSWORD|TSHORT|TCHAR,
	SCON,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
		NAREG|NASL,	RESC1,
		"	sra A1,AL,AR	# shift right by constant\n", },

{ RS,	INAREG,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
	SCON,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
		NAREG|NASL,	RESC1,
		"	srl A1,AL,AR	# shift right by constant\n", },

{ LS,	INAREG,
	SAREG,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
	SCON,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
		NAREG|NASL,	RESC1,
		"	sll A1,AL,AR	# shift left by constant\n", },
    
{ RS,	INAREG,
	SAREG,	TSWORD|TSHORT|TCHAR,
	SAREG,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
		NAREG|NASL,	RESC1,
		"	srav A1,AL,AR	# shift right by register\n", },

{ RS,	INAREG,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
	SAREG,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
		NAREG|NASL,	RESC1,
		"	srlv A1,AL,AR	# shift right by register\n", },

{ LS,	INAREG,
	SAREG,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
	SAREG,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
		NAREG|NASL,	RESC1,
		"	sllv A1,AL,AR	# shift left by register\n", },	

{ RS,	INBREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SCON,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
		NBREG,	RESC1,
		"ZO", },

{ LS,	INBREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SCON,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
		NBREG,	RESC1,
		"ZO", },

{ RS,	INBREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SAREG,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
		NSPECIAL|NBREG,	RESC1,
		"ZE", },

{ LS,	INBREG,
	SBREG,	TLONGLONG|TULONGLONG,
	SAREG,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
		NSPECIAL|NBREG,	RESC1,
		"ZE", },

/*
 * Rule for unary one's complement
 */

{ COMPL,        INAREG,
        SAREG,  TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
        SANY,   TANY,
                NAREG|NASL,   RESC1,
                "	nor A1,$zero,AL	# complement\n", },
    
{ COMPL,        INBREG,
	SBREG,	TLONGLONG|TULONGLONG,
        SANY,   TANY,
                NBREG|NBSL,   RESC1,
                "	nor A1,$zero,AL	# complement\n"
                "	nor U1,$zero,UL\n", },
    
/*
 * The next rules takes care of assignments. "=".
 */

{ ASSIGN,	FOREFF|INAREG,
	SOREG|SNAME,	TWORD|TPOINT,
	SAREG,		TWORD|TPOINT,
		0,	RDEST,
		"	sw AR,AL		# store (u)int/(u)long\n"
		"	nop\n", },

{ ASSIGN,	FOREFF|INAREG,
	SOREG|SNAME,	TSHORT|TUSHORT,
	SAREG,		TSHORT|TUSHORT,
		0,	RDEST,
        	"	sh AR,AL		# store (u)short\n"
		"	nop\n", },	

{ ASSIGN,	FOREFF|INAREG,
	SOREG|SNAME,	TCHAR|TUCHAR,
	SAREG,		TCHAR|TUCHAR,
		0,	RDEST,
        	"	sb AR,AL		# store (u)char\n"
		"	nop\n", },	

{ ASSIGN,	FOREFF|INBREG,
	SOREG|SNAME,	TLONGLONG|TULONGLONG,
	SBREG,		TLONGLONG|TULONGLONG,
		0,	RDEST,
      		"	sw UR,UL		# store (u)longlong\n"
		"	nop\n"
      		"	sw AR,AL\n"
		"	nop\n", },

{ ASSIGN,	FOREFF|INBREG,
	SBREG,		TLONGLONG|TULONGLONG,
	SBREG,		TLONGLONG|TULONGLONG,
		0,	RDEST,
      		"	move UL,UR		# register move\n"
      		"	move AL,AR\n", },
    
{ ASSIGN,	FOREFF|INAREG,
	SAREG,	TANY,
	SAREG,	TANY,
		0,	RDEST,
        	"	move AL,AR		# register move\n", },

{ ASSIGN,	FOREFF|INCREG,
	SCREG,	TFLOAT,
	SCREG,	TFLOAT,
		0,	RDEST,
        	"	mov.s AL,AR		# register move\n", },

{ ASSIGN,	FOREFF|INCREG,
	SCREG,	TDOUBLE|TLDOUBLE,
	SCREG,	TDOUBLE|TLDOUBLE,
		0,	RDEST,
        	"	mov.d AL,AR		# register move\n", },

{ ASSIGN,	FOREFF|INCREG,
	SNAME|SOREG,	TFLOAT,
	SCREG,		TFLOAT,
		0,	RDEST,
		"	s.s AR,AL		# store floating-point reg to oreg/sname\n"
		"	nop\n", },

{ ASSIGN,	FOREFF|INCREG,
	SNAME|SOREG,	TDOUBLE|TLDOUBLE,
	SCREG,		TDOUBLE|TLDOUBLE,
		0,	RDEST,
		"	s.d AR,AL		# store double floating-point reg to oreg/sname\n"
		"	nop\n", },

{ ASSIGN,	FOREFF|INAREG,
	SFLD,		TANY,
	SOREG|SNAME,	TANY,
		3*NAREG,	RDEST,
		"	lw A1,AR		# bit-field assignment\n"
		"	li A3,M\n"
		"	lw A2,AL\n"
		"	sll A1,A1,H\n"
		"	and A1,A1,A3\n"
		"	nor A3,$zero,A3\n"
		"	and A2,A2,A3\n"
		"	or A2,A2,A1\n"
		"	sw A2,AL\n"
		"F	lw AD,AR\n"
		"F	nop\n"
		"F	sll AD,AD,32-S\n"
		"F	sra AD,AD,32-S\n", },

/* XXX we can optimise this away */
{ ASSIGN,	FOREFF|INAREG,
	SFLD,		TANY,
	SCON,		TANY,
		3*NAREG,	RDEST,
		"	li A1,AR		# bit-field assignment\n"
		"	lw A2,AL\n"
		"	li A3,M\n"
		"	sll A1,A1,H\n"
		"	and A1,A1,A3\n"
		"	nor A3,$zero,A3\n"
		"	and A2,A2,A3\n"
		"	or A2,A2,A1\n"
		"	sw A2,AL\n"
		"F	li AD,AR\n"
		"F	sll AD,AD,32-S\n"
		"F	sra AD,AD,32-S\n", },

{ ASSIGN,	FOREFF|INAREG,
	SFLD,		TANY,
	SAREG,		TANY,
		3*NAREG,	RDEST,
		"	move A1,AR		# bit-field assignment\n"
		"	lw A2,AL\n"
		"	li A3,M\n"
		"	sll A1,A1,H\n"
		"	and A1,A1,A3\n"
		"	nor A3,$zero,A3\n"
		"	and A2,A2,A3\n"
		"	or A2,A2,A1\n"
		"	sw A2,AL\n"
		"F	move AR,AD\n"
		"F	sll AD,AD,32-S\n"
		"F	sra AD,AD,32-S\n", },

{ STASG,        INAREG|FOREFF,
        SOREG|SNAME,	TANY,
        SAREG,  	TPTRTO|TANY,
                NSPECIAL,       RRIGHT,
                "ZQ", },

/*
 * Compare instructions
 */

{ EQ,	FORCC,
        SAREG,		TWORD|TPOINT|TSHORT|TUSHORT|TCHAR|TUCHAR,
        SAREG,		TWORD|TPOINT|TSHORT|TUSHORT|TCHAR|TUCHAR,
                0,      RESCC,
                "	beq AL,AR,LC\n"
		"	nop\n", },

{ NE,	FORCC,
        SAREG,		TWORD|TPOINT|TSHORT|TUSHORT|TCHAR|TUCHAR,
        SAREG,		TWORD|TPOINT|TSHORT|TUSHORT|TCHAR|TUCHAR,
                0,      RESCC,
                "	bne AL,AR,LC\n"
		"	nop\n", },

{ OPLOG,	FORCC,
        SAREG,		TWORD|TPOINT|TSHORT|TUSHORT|TCHAR|TUCHAR,
        SZERO,		TANY,
                0,      RESCC,
                "	O AL,LC\n"
		"	nop\n", },

{ OPLOG,	FORCC,
        SAREG,		TWORD|TPOINT|TSHORT|TUSHORT|TCHAR|TUCHAR,
        SAREG,		TWORD|TPOINT|TSHORT|TUSHORT|TCHAR|TUCHAR,
                NAREG|NASL,     RESCC,
		"	sub A1,AL,AR\n"
                "	O A1,LC\n"
		"	nop\n", },

{ OPLOG,	FORCC,
        SAREG,		TWORD|TPOINT|TSHORT|TUSHORT|TCHAR|TUCHAR,
        SSCON,		TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
                NAREG|NASL,     RESCC,
		"	sub A1,AL,AR\n"
                "	O A1,LC\n"
		"	nop\n", },

{ OPLOG,	FORCC,
	SBREG,		TLONGLONG|TULONGLONG,
	SBREG,		TLONGLONG|TULONGLONG,
		NAREG,	RESCC,
		"ZD", },

{ OPLOG,	FORCC,
	SCREG,	TFLOAT|TDOUBLE|TLDOUBLE,
	SCREG,	TFLOAT|TDOUBLE|TLDOUBLE,
		0,	RESCC,
		"ZG", },

/*
 * Convert LTYPE to reg.
 */

{ OPLTYPE,	INAREG,
	SANY,		TANY,
	SOREG|SNAME,	TCHAR,
		NAREG,	RESC1,
		"	lb A1,AL	# load char to reg\n"
		"	nop\n", },
	
{ OPLTYPE,	INAREG,
	SANY,		TANY,
	SOREG|SNAME,	TUCHAR,
		NAREG,	RESC1,
		"	lbu A1,AL	# load uchar to reg\n"
		"	nop\n", },

{ OPLTYPE,	INAREG,
	SANY,		TANY,
	SOREG|SNAME,	TSHORT,
		NAREG,	RESC1,
		"	lh A1,AL	# load short to reg\n"
		"	nop\n", },

{ OPLTYPE,	INAREG,
	SANY,		TANY,
	SOREG|SNAME,	TUSHORT,
		NAREG,	RESC1,
		"	lhu A1,AL	# load ushort to reg\n"
		"	nop\n", },

{ OPLTYPE,	INAREG,
	SANY,		TANY,
	SOREG|SNAME,	TWORD|TPOINT,
		NAREG,	RESC1,
		"	lw A1,AL	# load (u)int/(u)long to reg\n"
		"	nop\n", },

{ OPLTYPE,	INBREG,
	SANY,		TANY,
	SOREG|SNAME,	TLONGLONG|TULONGLONG,
		NBREG,	RESC1,
		"	lw U1,UL	# load (u)longlong to reg\n"
		"	nop\n"
		"	lw A1,AL\n"
      		"	nop\n", },

{ OPLTYPE,	INAREG,
	SANY,	TANY,
	SCON,	TPOINT,
		NAREG,	RESC1,
		"	la A1,AL	# load constant address to reg\n", },

{ OPLTYPE,	INAREG,
	SANY,	TANY,
	SZERO,	TANY,
		NAREG,	RESC1,
		"	move A1,$zero	# load 0 to reg\n", },

{ OPLTYPE,	INAREG,
	SANY,	TANY,
	SCON,	TANY,
		NAREG,	RESC1,
		"	li A1,AL	# load constant to reg\n", },

{ OPLTYPE,	INBREG,
	SANY,	TANY,
	SZERO,	TANY,
		NBREG,	RESC1,
		"	move A1,$zero	# load 0 to reg\n"
		"	move U1,$zero\n", },

{ OPLTYPE,	INBREG,
	SANY,	TANY,
	SCON,	TANY,
		NBREG,	RESC1,
		"	li A1,AL	# load constant to reg\n"
		"	li U1,UL\n", },

{ OPLTYPE,	INAREG,
	SANY,	TANY,
	SANY,	TANY,
		NAREG,	RESC1,
		"	move A1,AL\n", },

{ OPLTYPE,	INCREG,
	SANY,	TANY,
	SZERO,	TFLOAT,
		NCREG,	RESC1,
		"	mtc1 $zero,A1	# load 0 to float reg\n"
		"	nop\n", },

{ OPLTYPE,	INCREG,
	SANY,	TANY,
	SZERO,	TDOUBLE|TLDOUBLE,
		NCREG,	RESC1,
		"	mtc1 $zero,A1	# load 0 to (l)double reg\n"
		"	mtc1 $zero,U1\n"
		"	nop\n", },

{ OPLTYPE,	INCREG,
	SANY,	TANY,
	SOREG|SNAME,	TFLOAT,
		NCREG,	RESC1,
		"	l.s A1,AL	# load into floating-point reg\n"
		"	nop\n", },

{ OPLTYPE,	INCREG,
	SANY,	TANY,
	OREG|SNAME,	TDOUBLE|TLDOUBLE,
		NCREG,	RESC1,
		"	l.d A1,AL	# load into double floating-point reg\n"
		"	nop\n", },
    
/*
 * Jumps.
 */
{ GOTO, 	FOREFF,
	SCON,	TANY,
	SANY,	TANY,
		0,	RNOP,
		"	j LL		# goto label\n"
		"	nop\n"
		"	nop\n", },

/*
 * Subroutine calls.
 */

{ CALL,         FOREFF,
        SCON,		TANY,
        SANY,           TANY,
                0,      0,
                "	subu $sp,$sp,16	# call (args, no result) to scon/sname\n"
                "	jal CL\n"
		"	nop\n"
		"ZC", },

{ UCALL,        FOREFF,
        SCON,		TANY,
        SANY,           TANY,
                0,      0,
                "	jal CL			# call (no args, no result) to scon/sname\n"
		"	nop\n", },

{ CALL,         INAREG,
        SCON,		TANY,
        SAREG,          TANY,
                NAREG,     RESC1,  /* should be 0 */
                "	subu $sp,$sp,16	# call (args, result in v0) to scon/sname\n"
		"	jal CL\n"
		"	nop\n"
		"ZC", },

{ UCALL,        INAREG,
        SCON,		TANY,
        SAREG,          TANY,
                NAREG,     RESC1,  /* should be 0 */
                "	jal CL   # call (no args, result in v0) to scon/sname\n"
		"	nop\n",
 },

{ CALL,         INBREG,
        SCON,		TANY,
        SBREG,          TANY,
                NBREG,     RESC1,  /* should be 0 */
                "	subu $sp,$sp,16	# call (args, result in v0:v1) to scon/sname\n"
		"	jal CL\n"
		"	nop\n"
		"ZC", },

{ UCALL,        INBREG,
        SCON,		TANY,
        SBREG,          TANY,
                NBREG,     RESC1,  /* should be 0 */
                "	jal CL   # call (no args, result in v0:v1) to scon/sname\n"
		"	nop\n",
 },

{ CALL,         INCREG,
        SCON,		TANY,
        SCREG,          TANY,
                NCREG,     RESC1,  /* should be 0 */
                "	subu $sp,$sp,16	# call (args, result in f0:f1) to scon/sname\n"
		"	jal CL\n"
		"	nop\n"
		"ZC", },

{ UCALL,        INCREG,
        SCON,		TANY,
        SCREG,          TANY,
                NCREG,     RESC1,  /* should be 0 */
                "	jal CL   # call (no args, result in v0:v1) to scon/sname\n"
		"	nop\n",
 },

{ CALL,         FOREFF,
        SAREG,		TANY,
        SANY,		TANY,
                0,      0,
                "	subu $sp,$sp,16	# call (args, no result) to reg\n"
		"	move $25,AL\n"
                "	jal $25\n"
		"	nop\n"
		"ZC", },

{ UCALL,        FOREFF,
        SAREG,		TANY,
        SANY,		TANY,
                0,      0,
		"	move $25,AL\n"
                "	jal $25			# call (no args, no result) to reg\n"
		"	nop\n", },

{ CALL,         INAREG,
        SAREG,		TANY,
        SAREG,		TANY,
                NAREG,     RESC1,  /* should be 0 */
                "	subu $sp,$sp,16	# call (args, result) to reg\n"
		"	move $25,AL\n"
                "	jal $25\n"
		"	nop\n"
		"ZC", },

{ UCALL,        INAREG,
        SAREG,		TANY,
        SAREG,		TANY,
                NAREG,     RESC1,  /* should be 0 */
		"	move $25,AL\n"
                "	jal $25		# call (no args, result) to reg\n"
		"	nop\n", },

{ CALL,         INBREG,
        SAREG,		TANY,
        SBREG,		TANY,
                NBREG,     RESC1,  /* should be 0 */
                "	subu $sp,$sp,16	# call (args, result) to reg\n"
		"	move $25,AL\n"
                "	jal $25\n"
		"	nop\n"
		"ZC", },

{ UCALL,        INBREG,
        SAREG,		TANY,
        SBREG,		TANY,
                NBREG,     RESC1,  /* should be 0 */
		"	move $25,AL\n"
                "	jal $25			# call (no args, result) to reg\n"
		"	nop\n", },

{ CALL,         INCREG,
        SAREG,		TANY,
        SCREG,		TANY,
                NCREG,     RESC1,  /* should be 0 */
                "	subu $sp,$sp,16	# call (args, result) to reg\n"
		"	move $25,AL\n"
                "	jal $25\n"
		"	nop\n"
		"ZC", },

{ UCALL,        INCREG,
        SCREG,		TANY,
        SCREG,		TANY,
                NCREG,     RESC1,  /* should be 0 */
		"	move $25,AL\n"
                "	jal $25			# call (no args, result) to reg\n"
		"	nop\n", },


/* struct return */
{ USTCALL,      FOREFF,
	SCON|SNAME,	TANY,
	SANY,   	TANY,
		0,	0,
		"	jal CL\n"
		"	nop\n", },

{ USTCALL,      FOREFF,
	SAREG,		TANY,
	SANY,   	TANY,
		0,	0,
		"	move $25,AL\n"
                "	jal $25\n"
		"	nop\n", },

{ USTCALL,      INAREG,
	SCON|SNAME,	TANY,
	SANY,   	TANY,
		NAREG|NASL,	RESC1,
		"	jal CL\n"
		"	nop\n", },

{ USTCALL,      INAREG,
	SAREG,		TANY,
	SANY,   	TANY,
		NAREG|NASL,	RESC1,
		"	move $25,AL\n"
                "	jal $25\n"
		"	nop\n", },

{ STCALL,      FOREFF,
	SCON|SNAME,	TANY,
	SANY,   	TANY,
		0,	0,
		"	jal CL\n"
		"	nop\n"
		"ZC", },

{ STCALL,      FOREFF,
	SAREG,	TANY,
	SANY,   	TANY,
		0,	0,
		"	move $25,AL\n"
                "	jal $25\n"
		"	nop\n"
		"ZC", },

{ STCALL,      INAREG,
	SCON|SNAME,	TANY,
	SANY,   	TANY,
		NAREG|NASL,	RESC1,
		"	jal CL\n"
		"	nop\n"
		"ZC", },

{ STCALL,      INAREG,
	SAREG,	TANY,
	SANY,   	TANY,
		0,	0,
		"	move $25,AL\n"
                "	jal $25\n"
		"	nop\n"
		"ZC", },


/*
 *  Function arguments
 */

/* intentionally write out the register for (u)short/(u)char */
{ FUNARG,       FOREFF,
        SAREG,  TWORD|TPOINT|TUSHORT|TSHORT|TUCHAR|TCHAR,
        SANY,   TWORD|TPOINT|TUSHORT|TSHORT|TUCHAR|TCHAR,
                0,      0,
                "	subu $sp,$sp,4		# save function arg to stack\n"
		"	sw AL,($sp)\n"
		"	#nop\n", },

{ FUNARG,	FOREFF,
	SBREG,	TLONGLONG|TULONGLONG,
	SANY,	TLONGLONG|TULONGLONG,
		0,	0,
		"	addi $sp,$sp,-8		# save function arg to stack (endian problem here?\n"
		"	sw UL,4($sp)\n"
		"	sw AL,($sp)\n"
		"	#nop\n", },

{ FUNARG,	FOREFF,
	SCREG,	TFLOAT,
	SANY,	TFLOAT,
		0,	0,
		"	addi $sp,$sp,-4		# save function arg to stack\n"
		"	s.s AL,($sp)\n"
		"	#nop\n", },

{ FUNARG,	FOREFF,
	SCREG,	TDOUBLE|TLDOUBLE,
	SANY,	TDOUBLE|TLDOUBLE,
		0,	0,
		"	addi $sp,$sp,-8		# save function arg to stack\n"
		"	s.d AL,($sp)\n"
		"	#nop\n", },

{ STARG,	FOREFF,
	SAREG,		TANY,
	SANY,		TSTRUCT,
		NSPECIAL,	0,
		"ZH", },

/*
 * Indirection operators.
 */
{ UMUL, INAREG,
	SANY,	TPOINT|TWORD,
	SOREG,	TPOINT|TWORD,
    		NAREG,     RESC1,
        	"	lw A1,AL		# word load\n"
		"	nop\n", },

{ UMUL, INAREG,
	SANY,	TSHORT|TUSHORT,
	SOREG,	TSHORT|TUSHORT,
    		NAREG,     RESC1,
        	"	lh A1,AL		# (u)short load\n"
		"	nop\n", },

{ UMUL, INAREG,
	SANY,	TCHAR|TUCHAR,
	SOREG,	TCHAR|TUCHAR,
    		NAREG,     RESC1,
        	"	lb A1,AL		# (u)char load\n"
		"	nop\n", },

{ UMUL,	INBREG,
	SANY,	TLONGLONG|TULONGLONG,
	SOREG,	TLONGLONG|TULONGLONG,
		NBREG,	RESC1,
		"	lw A1,AL		# (u)longlong load - endian problem here?\n"
		"	nop\n"
		"	lw U1,UL\n"
		"	nop\n", },

{ UMUL,	INCREG,
	SANY,	TFLOAT,
	SOREG,	TFLOAT,
		NCREG,	RESC1,
		"	l.s A1,AL		# float load\n"
		"	nop\n", },

{ UMUL,	INCREG,
	SANY,	TDOUBLE|TLDOUBLE,
	SOREG,	TDOUBLE|TLDOUBLE,
		NCREG,	RESC1,
		"	l.d A1,AL		# float load\n"
		"	nop\n", },

#if 0
{ UMUL,	INCREG,
	SANY,	TDOUBLE|TLDOUBLE,
	SAREG,	TPOINT,
		NCREG,	RESC1,
		"	l.d A1,(AL)\n"
		"	nop\n", },
    
{ UMUL, INAREG,
	SANY,	TPOINT|TWORD,
	SNAME,	TPOINT|TWORD,
    		NAREG,     RESC1,
        	"	la A1,AL		# sname word load\n"
		"	lw A1,(A1)\n"
		"	nop\n", },

{ UMUL, INAREG,
	SANY,	TSHORT|TUSHORT,
	SNAME,	TSHORT|TUSHORT,
    		NAREG,     RESC1,
        	"	la A1,AL		# sname (u)short load\n"
		"	lh A1,(A1)\n"
		"	nop\n", },

{ UMUL, INAREG,
	SANY,	TCHAR|TUCHAR,
	SNAME,	TCHAR|TUCHAR,
    		NAREG,     RESC1,
        	"	la A1,AL		# sname (u)char load\n"
		"	lb A1,(A1)\n"
		"	nop\n", },

{ UMUL, INBREG,
	SANY,	TLONGLONG|TULONGLONG,
	SNAME,	TLONGLONG|TULONGLONG,
		NBREG|NAREG,	RESC1,
		"	la A2,AL		# sname (u)long long load - endian problems here?\n"
		"	lw A1,(A1)\n"
		"	nop\n"
		"	lw U1,4(A1)\n"
		"	nop\n", },
#endif

{ UMUL, INAREG,
	SANY,	TPOINT|TWORD,
	SAREG,	TPOINT|TWORD,
    		NAREG,     RESC1,
        	"	lw A1,(AL)		# word load\n"
		"	nop\n", },

#if 0
{ UMUL, INAREG,
	SANY,	TSHORT|TUSHORT,
	SAREG,	TPTRTO|TSHORT|TUSHORT,
    		NAREG,     RESC1,
        	"	lh A1,(AL)		# (u)short load\n"
		"	nop\n", },

{ UMUL, INAREG,
	SANY,	TCHAR|TUCHAR,
	SAREG,	TPTRTO|TCHAR|TUCHAR,
    		NAREG|NASL,     RESC1,
        	"	lb A1,(AL)		# (u)char load\n"
		"	nop\n", },

{ UMUL, INBREG,
	SANY,	TLONGLONG|TULONGLONG,
	SAREG,	TPTRTO|TLONGLONG|TULONGLONG,
		NBREG,	RESC1,
		"	lw A1,(AL)		# (u)long long load - endianness problems?\n"
		"	nop\n"
		"	lw U1,4(AL)"
		"	nop\n", },
#endif

#define DF(x) FORREW,SANY,TANY,SANY,TANY,REWRITE,x,""

{ FLD, DF(FLD), },

{ FREE,	FREE,	FREE,	FREE,	FREE,	FREE,	FREE,	FREE,	"help; I'm in trouble\n" },
};

int tablesize = sizeof(table)/sizeof(table[0]);
@


1.5
log
@Sync with master repo. Reminded by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4
log
@Sync with main repo.
@
text
@@


1.3
log
@Sync with main repo.
@
text
@a43 4
#define TLL TLONGLONG|TULONGLONG
#define ANYSIGNED TINT|TLONG|TSHORT|TCHAR
#define ANYUSIGNED TUNSIGNED|TULONG|TUSHORT|TUCHAR
#define ANYFIXED ANYSIGNED|ANYUSIGNED
d52 7
a62 1
/* convert char to (u)short */
d65 8
a72 1
	SAREG,	TWORD|TSHORT|TUSHORT,
d74 1
a74 1
		"	lb A1,AL	# convert oreg char to (u)short/word\n"
a76 1
/* convert uchar to (u)short */
d81 1
a81 1
		"	lbu A1,AL	# convert oreg uchar to (u)short\n"
a83 1
/* convert char to (u)long long - big endian*/
d86 1
a86 1
	SBREG,	TLL,
d88 1
a88 1
      		"	lb U1,AL	# convert oreg char to (u)longlong\n"
d90 3
a92 2
      		"	sra A1,U1,31\n"
      		"	sub A1,$zero,A1\n", },
a93 1
/* convert uchar to (u)long long */
d96 1
a96 1
	SBREG,	TLL,
d98 2
a99 2
		"	lbu U1,AL	# convert oreg uchar to (u)longlong\n"
      		"	move A1,$zero\n", },
a100 1
/* convert (u)short to char */
a107 1
/* convert (u)short to uchar */
a114 1
/* convert short to (u)long */
d117 8
a124 1
	SAREG,	TWORD,
d126 1
a126 1
		"	lh A1,AL	# convert oreg short to (u)int\n"
a128 1
/* convert ushort to (u)long */
a135 1
/* convert short to (u)long long */
d138 9
a146 1
	SBREG,	TLL,
d148 1
a148 1
      		"	lh U1,AL	# convert oreg short to (u)longlong\n"
d150 1
a150 2
      		"	sra A1,U1,31\n"
      		"	sub A1,$zero,A1\n", },
a151 1
/* convert ushort to (u)long long */
d154 1
a154 1
	SBREG,	TLL,
d156 2
a157 2
		"	lhu U1,AL	# convert oreg (u)short to (u)longlong\n"
      		"	move A1,$zero\n", },
a158 1
/* convert (u)long to char */
a165 1
/* convert (u)long to uchar */
a172 1
/* convert (u)long to short */
a187 1
/* convert long to (u)long long */
d190 1
a190 1
	SBREG,	TLL,
d194 1
a194 2
      		"	sra U1,A1,31\n"
      		"	sub U1,$zero,U1\n", },
a195 1
/* convert ulong to (u)long long */
d198 1
a198 1
	SBREG,	TLL,
a202 1
/* convert (u)long long to char */
d204 1
a204 1
	SOREG,	TLL,
a209 1
/* convert (u)long long to uchar */
d211 1
a211 1
	SOREG,	TLL,
a216 1
/* convert (u)long long to short */
d218 1
a218 1
	SOREG,	TLL,
a223 1
/* convert (u)long long to ushort */
d225 1
a225 1
	SOREG,	TLL,
a230 1
/* convert (u)long long to long */
d232 2
a233 2
	SOREG,	TLL,
	SAREG,	TSWORD,
d235 1
a235 1
      		"	lw U1,AL	# convert oreg (u)llong to short (endianness problem here?)\n"
d238 138
a375 1
/* convert (u)long long to ulong */
a376 1
	SOREG,	TLL,
d378 16
a393 3
		NAREG,	RESC1,
      		"	lw U1,AL	# convert oreg (u)longlong to uint (endianness problem here?)\n"
		"	nop\n", },
d395 6
a400 1
/* Register to register conversion with long long */
d403 5
a407 4
	SBREG,	TLL,
	SBREG,	TLL,
		0,	RLEFT,
		"	# convert (u)longlong to (u)longlong", },
d410 2
a411 2
	SAREG,	TPOINT|TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
	SBREG,	TLL,
d413 22
a434 2
		"	move A1,AL	# convert (u)int/(u)short/(u)char to (u)longlong\n"
		"	sra A1,AL,31\n", },
d437 2
a438 2
	SBREG,	TLL,
	SAREG,	TPOINT|TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
d440 1
a440 1
		"	move A1,AL\n", },
a441 2
/* For register to register conversion with bit length <= 32, do nothing */
/* XXX This doesn't seem correct.  USHORT->TCHAR must be sign extended */
d443 4
a446 4
	SAREG,	TPOINT|TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
	SAREG,	TPOINT|TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
		0,	RLEFT,
		"	# convert reg to reg\n", },
d523 1
a523 1
	SBREG,	TLL,
d529 1
a529 1
	SBREG,	TLL,
d536 1
a536 1
	SBREG,	TLL,
d542 1
a542 1
	SBREG,	TLL,
a568 1

d570 2
a571 2
	SBREG,	TLL,
	SBREG,	TLL,
a598 1

d619 2
a620 2
	SBREG,		TLL,
	SBREG,		TLL,
d656 2
a657 2
        SBREG,  TLL,
        SBREG,  TLL,
d677 1
a677 1
		NBREG|NAREG,	RESC1,
a680 6
	SAREG,	TUWORD|TUSHORT|TUCHAR,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
		NBREG|NAREG,	RESC1,
      		"	addu A1,AL,AR\n", },

{ PLUS,	INAREG,
d682 1
a682 1
	SSCON,	TANY,
d688 1
a688 1
	SSCON,	TANY,
d692 6
d722 1
a722 1
		NBREG|NAREG,	RESC1,
d728 1
a728 1
		NBREG|NAREG,	RESC1,
d756 1
a756 1
	SBREG,	TLL,
d779 2
a780 2
	SBREG,	TLL,
	SBREG,	TLL,
d814 1
a814 1
	SAREG,	TWORD|TUSHORT|TSHORT|TCHAR|TUCHAR,
d820 1
d822 5
d838 1
a838 1
	SBREG,	TLL,
d844 1
a844 1
	SBREG,	TLL,
d850 1
a850 1
	SBREG,	TLL,
d856 1
a856 1
	SBREG,	TLL,
d869 1
a869 1
                "	nor A1,AL	# complement\n", },
d872 1
a872 1
        SBREG,  TLL,
d875 2
a876 2
                "	nor A1,AL	# complement\n"
                "	nor U1,UL\n", },
d904 2
a905 2
	SOREG|SNAME,	TLL,
	SBREG,		TLL,
d913 2
a914 2
	SBREG,	TLL,
	SBREG,	TLL,
d941 1
a941 1
		"	s.s AR,AL		# store floating-point reg to sname\n"
d948 1
a948 1
		"	s.d AR,AL		# store double floating-point reg to sname\n"
d956 1
a956 1
		"	li A3,ML\n"
d958 1
a958 1
		"	sll A1,A1,HL\n"
d960 1
a960 1
		"	nor A3,A3\n"
d964 4
a967 1
		"	nop\n", },
d976 2
a977 2
		"	li A3,ML\n"
		"	sll A1,A1,HL\n"
d979 1
a979 1
		"	nor A3,A3\n"
d983 3
a985 1
		"	nop\n", },
d993 2
a994 2
		"	li A3,ML\n"
		"	sll A1,A1,HL\n"
d996 1
a996 1
		"	nor A3,A3\n"
d1000 3
a1002 20
		"	nop\n", },

{ ASSIGN,	FOREFF|INAREG,
	SFLD,		TANY,
	SFLD,		TANY,
		2*NAREG,	RDEST,
		"	lw A1,AR		# bit-field copy\n"
		"	li A3,MR\n"
		"	and A1,A1,A3\n"
		"	sll A1,A1,32-SR-HR\n"
		"	sra A1,A1,32-SR\n"
		"	lw A2,AL\n"
		"	li A3,ML\n"
		"	sll A1,A1,HL\n"
		"	and A1,A1,A3\n"
		"	nor A3,A3\n"
		"	and A2,A2,A3\n"
		"	or A2,A2,A1\n"
		"	sw A2,AL\n"
		"	nop\n", } ,
d1045 1
a1045 1
        SCON,		TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
d1052 2
a1053 2
	SBREG,		TLL,
	SBREG,		TLL,
d1104 1
a1104 1
	SOREG|SNAME,	TLL,
d1119 6
d1129 1
a1129 1
{ OPLTYPE,	INAREG,
d1132 3
a1134 2
		NAREG,	RESC1,
		"	move A1,$zero	# load 0 to reg\n", },
a1142 7
{ OPLTYPE,	INBREG,
	SANY,	TANY,
	SZERO,	TANY,
		NBREG,	RESC1,
		"	move A1,$zero	# load 0 to reg\n"
		"	move U1,$zero\n", },

d1413 2
a1414 2
	SBREG,	TLL,
	SANY,	TLL,
d1468 2
a1469 2
	SANY,	TLL,
	SOREG,	TLL,
d1473 1
a1473 1
		"	lw U1,AL\n"
d1490 1
d1523 2
a1524 2
	SANY,	TLL,
	SNAME,	TLL,
d1531 1
a1531 1
		
d1540 1
d1543 1
a1543 1
	SAREG,	TSHORT|TUSHORT,
d1550 1
a1550 1
	SAREG,	TCHAR|TUCHAR,
d1556 2
a1557 2
	SANY,	TLL,
	SCREG,	TLL,
d1563 1
@


1.2
log
@sync with repe; commit from gmcgarry@@:

Bring MIPS support fully up-to-date.  Includes the following changes:

Support use of different assemblers.
Handle big-endian and little-endian code generation.
Start support for n32/n64
PIC code generation
Update to arguments-in-registers infrastructure.
Cleanup handling of branches.
Fix register coloring
Fix structure assignment.
Add longlong instructions
Remove unused functions.
Indentation fixes.

Tested on NetBSD/pmax (little endian).
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.3 2007/11/16 00:17:40 gmcgarry Exp $	*/
d57 1
a57 1
 * A bunch conversions of integral<->integral types
d63 1
a63 1
	SAREG,	TWORD|SHORT|TUSHORT,
d76 1
a76 1
/* convert char to (u)long long */
d84 1
a84 1
      		"	sub A1,0,A1\n", },
d92 1
a92 1
      		"	move A1,0\n", },
d134 1
a134 1
      		"	sub A1,0,A1\n", },
d142 1
a142 1
      		"	move A1,0\n", },
d157 1
a157 1
		"	lbu AL,AR	# convert oreg word to uchar (endianness problem here?)\n"
d165 1
a165 1
		"	lh AL,AR	# convert oreg word to short (endianness problem here?)\n"
d173 1
a173 1
		"	lhu A1,AR	# convert oreg word to ushort (endianness problem here?)\n"
d184 1
a184 1
      		"	sub U1,0,U1\n", },
d192 1
a192 1
      		"	move U1,0\n", },
d239 1
a239 1
      		"	lwu U1,AL	# convert oreg (u)longlong to uint (endianness problem here?)\n"
d247 2
a248 2
		0,	0,
		"	; convert (u)longlong to (u)longlong", },
d251 1
a251 1
	SAREG,	TPOINT|TWORD|SHORT|TUSHORT|TCHAR|TUCHAR,
d253 3
a255 3
		NBREG,	0,
		"	move A1,AR\n"
		"	move U1,0\n", },
d258 3
a260 3
	SAREG,	TLL,
	SAREG,	TPOINT|TWORD|SHORT|TUSHORT|TCHAR|TUCHAR,
		NAREG,	0,
d264 1
a264 1

d268 100
a367 2
		0,	0,
		"	; convert reg to reg", },
d374 2
a375 2
	SAREG,	TSWORD|TSHORT|TCHAR,
	SAREG,	TSWORD|TSHORT|TCHAR,
d377 1
a377 1
		"	mult AL,AR	# signed multiply\n"
d382 1
d384 2
a385 2
	SAREG,	TUWORD|TUSHORT|TUCHAR,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
d387 1
a387 1
		"	multu AL,AR	# unsigned multiply\n"
d392 1
d396 2
a397 3
		2*NBREG|NASR|NASL,	RESC1,
		"	li A2,AR\n"
		"	multu AL,A2\n"
d400 2
a401 3
		"	move A2,UR\n"
		"	mult AL,A2\n"
		"	mflo U2\n"
d404 2
a405 3
		"	addu A2,U1,U2\n"
		"	li U2,AR\n"
		"	mult UL,U2\n"
d415 1
a415 1
		"	mul.s A1,Al,AR		#floating-point multiply\n", },
d418 2
a419 2
	SCREG,	TDOUBLE,
	SCREG,	TDOUBLE,
d423 1
d425 2
a426 2
	SAREG,	TSWORD|TSHORT|TCHAR,
	SAREG,	TSWORD|TSHORT|TCHAR,
d428 1
a428 1
		"	div AL,AR	# signed division\n"
d433 1
d435 2
a436 2
	SAREG,	TUWORD|TUSHORT|TUCHAR,
	SAREG,	TUWORD|TUSHORT|TUCHAR,
d438 1
a438 1
		"	divu AL,AR	# unsigned division\n"
d445 2
a446 2
	SBREG|SCON,	TLL,
		NBREG,	RESC1,
d449 12
d462 2
a463 2
        SAREG,  TSWORD|TSHORT|TCHAR,
        SAREG,  TSWORD|TSHORT|TCHAR,
d465 1
a465 1
                "       div AL,AR	# signed modulo\n"
d468 1
a468 2
		"	nop\n"
                "       sub A1,A1,AL\n", },
d470 1
d472 2
a473 2
        SAREG,  TUWORD|TUSHORT|TUCHAR,
        SAREG,  TUWORD|TUSHORT|TUCHAR,
d475 1
a475 1
                "       divu AL,AR	# signed modulo\n"
d478 1
a478 2
		"	nop\n"
                "       sub A1,A1,AL\n", },
d491 4
a494 4
	SBREG,	TULONGLONG,
	SBREG,	TULONGLONG,
		NBREG|NAREG,	RESC1,
      		"	addu A1,AL,AR\n"
d521 13
a533 1
		"	addui A1,AL,AR\n", },
d536 4
a539 4
	SBREG,	TULONGLONG,
	SBREG,	TULONGLONG,
		NBREG|NAREG,	RESC1,
      		"	sltu A2,AL,AR\n"
d560 13
a572 1
		"	subui A1,AL,AR\n", },
d584 3
a586 3
		"	subu A1,0,AL\n"
		"	subu U1,0,UL\n"
		"	sltu A2,0,A1\n"
d589 12
d618 1
a618 1
	SSCON,	TSHORT|TUSHORT|TUCHAR|TCHAR,
d627 7
a633 1
	SAREG,	TWORD|TUSHORT|TSHORT|TCHAR|TUCHAR,
d659 1
a659 1
		NBREG|NBSL,	RESC1,
d665 1
a665 1
		NBREG|NBSL,	RESC1,
d705 1
a705 1
        	"	sw AR,AL		# store (u)int/(u)long\n"
a730 26
#if 0
{ ASSIGN,	FOREFF|INAREG,
	SNAME,	TWORD|TPOINT,
	SAREG,	TWORD|TPOINT,
		NAREG,	RDEST,
        	"	la A1,AL		# store word into sname\n"
		"	sw AR,0(A1)\n"
		"	nop\n", },

{ ASSIGN,	FOREFF|INAREG,
	SNAME,	TSHORT|TUSHORT,
	SAREG,	TSHORT|TUSHORT,
		NAREG,	RDEST,
        	"	la A1,AL		# store (u)short into sname\n"
		"	sh AR,0(A1)\n"
		"	nop\n", },

{ ASSIGN,	FOREFF|INAREG,
	SNAME,	TCHAR|TUCHAR,
	SAREG,	TCHAR|TUCHAR,
		NAREG,	RDEST,
        	"	la A1,AL		# store (u)char into sname\n"
		"	sb AR,0(A1)\n"
		"	nop\n", },	
#endif

d745 13
a757 1
	SNAME|OREG,	TFLOAT,
d760 2
a761 1
		"	s.s	AR,AL		# store floating-point reg to sname\n", },
d764 2
a765 2
	SNAME|OREG,	TDOUBLE,
	SCREG,		TDOUBLE,
d767 67
a833 1
		"	s.d	AR,AL		# store double-floating-point reg to sname\n", },
a840 1

d845 3
a847 3
{ EQ,   FORCC,
        SAREG,		TANY,
        SAREG,		TANY,
d849 2
a850 1
                "	beq AL,AR,LC\n", },
d852 3
a854 3
{ NE,   FORCC,
        SAREG,		TANY,
        SAREG,		TANY,
d856 2
a857 1
                "	bne AL,AR,LC\n", },
d859 2
a860 2
{ OPLOG,   FORCC,
        SAREG,		TANY,
d863 2
a864 1
                "	O AL,LC\n", },
d866 12
a877 4
{ OPLOG,   FORCC,
        SAREG,		TANY,
        SAREG|SCON,	TANY,
                NAREG|NBSL,     RESCC,
d879 14
a892 1
                "	O A1,LC\n", },       
d902 1
a902 1
		"	lb A1,AR	# load char to reg\n"
d909 1
a909 1
		"	lbu A1,AR	# load uchar to reg\n"
d916 1
a916 1
		"	lh A1,AR	# load short to reg\n"
d923 1
a923 1
		"	lhu A1,AR	# load ushort to reg\n"
d930 1
a930 1
		"	lw A1,AR	# load (u)int/(u)long to reg\n"
d937 1
a937 55
		"	lw U1,UR	# load (u)longlong to reg\n"
		"	nop\n"
		"	lw A1,AR\n"
      		"	nop\n", },

#if 0

// don't need these with the gas assembler

{ OPLTYPE,	INAREG,
	SANY,	TANY,
	SNAME,	TCHAR,
		2*NAREG,	RESC1,
		"	la A2,AL	# load char sname to reg\n"
		"	lb A1,0(A2)\n"
		"	nop\n", },

{ OPLTYPE,	INAREG,
	SANY,	TANY,
	SNAME,	TUCHAR,
		2*NAREG,	RESC1,
		"	la A2,AR	# load uchar sname to reg\n"
		"	lbu A1,0(A2)\n"
		"	nop\n", },

{ OPLTYPE,	INAREG,
	SANY,	TANY,
	SNAME,	TSHORT,
		2*NAREG,	RESC1,
		"	la A2,AR	# load short sname to reg\n"
		"	lh A1,0(A2)\n"
		"	nop\n", },

{ OPLTYPE,	INAREG,
	SANY,	TANY,
	SNAME,	TUSHORT,
		2*NAREG,	RESC1,
		"	la A2,AR	# load ushort sname to reg\n"
		"	lhu A1,0(A2)\n"
		"	nop\n", },

{ OPLTYPE,	INAREG,
	SANY,	TANY,
	SNAME,	TWORD|TPOINT,
		2*NAREG,	RESC1,
		"	la A2,AR	# load (u)int/(u)long to reg\n"
		"	lw A1,0(A2)\n"
		"	nop\n", },

{ OPLTYPE,	INBREG,
	SANY,	TANY,
	SNAME,	TLL,
		2*NBREG,	RESC1,
		"	la A2,UR	# load (u)longlong to reg (endiannes problems?)\n"
		"	lw U1,0(A2)\n"
d939 1
a939 2
		"	la A2,AR\n"
		"	lw A1,0(A2)\n"
a941 2
#endif

d946 1
a946 1
		"	la A1,AR	# load constant address to reg\n", },
d952 1
a952 1
		"	li A1,AR	# load constant to reg\n", },
d958 1
a958 1
		"	move A1,0	# load 0 to reg\n", },
d964 2
a965 2
		"	li A1,AR	# load constant to reg\n"
		"	li U1,UR\n", },
d971 2
a972 2
		"	move A1,0	# load 0 to reg\n"
		"	move U1,0\n", },
a973 2
#if 0
/* Matches REG nodes. XXX - shouldn't be necessary? */
d978 16
a993 2
		"	move A1,AR\n", },
#endif
d999 2
a1000 1
		"	l.s	A1,AR	# load into floating-point reg\n", },
d1004 1
a1004 1
	OREG|SNAME,	TDOUBLE,
d1006 2
a1007 1
		"	l.d	A1,AR	# load into double-floating-point reg\n", },
d1017 1
d1025 1
a1025 1
        SCON|SNAME,     TANY,
d1028 1
a1028 1
                "	addi $sp,$sp,-16	# call (args, no result) to scon/sname\n"
d1034 1
a1034 1
        SCON|SNAME,     TANY,
d1041 1
a1041 1
        SCON|SNAME,     TANY,
d1044 1
a1044 1
                "	addi $sp,$sp,-16	# call (args, result in v0) to scon/sname\n"
d1050 1
a1050 1
        SCON|SNAME,     TANY,
d1053 35
a1087 1
                "	jal CL   ; call (no args, result in v0) to scon/sname\n"
d1091 73
d1166 63
a1228 5
        SCON|SNAME,   TANY,
        SANY,   TANY,
                0,     0,
                "       call CL\n"
		"	ZC", },
d1234 1
d1236 2
a1237 2
        SAREG,  TWORD|TPOINT,
        SANY,   TWORD|TPOINT,
d1239 19
a1257 2
                "	addi $sp,$sp,-4		# save function arg to stack\n"
		"	sw AL,0($sp)\n"
d1260 6
a1265 6
{ FUNARG,       FOREFF,
        SAREG,  TSHORT|TUSHORT,
        SANY,   TSHORT|TUSHORT,
                0,      0,
                "	addi $sp,$sp,-4		# save function arg to stack\n"
		"	sh AL,0($sp)\n"
d1268 5
a1272 7
{ FUNARG,       FOREFF,
        SAREG,  TCHAR|TUCHAR,
        SANY,   TCHAR|TUCHAR,
                0,      0,
                "	addi $sp,$sp,-4		# save function arg to stack\n"
                "	sb AL,0($sp)\n"
		"	#nop\n", },    
d1297 30
d1333 1
a1333 1
		"	lw A1,0(A1)\n"
d1341 1
a1341 1
		"	lh A1,0(A1)\n"
d1349 1
a1349 1
		"	lb A1,0(A1)\n"
d1352 11
d1367 1
a1367 1
        	"	lw A1,0(AL)		# word load\n"
d1374 1
a1374 1
        	"	lh A1,0(AL)		# (u)short load\n"
d1381 10
a1390 1
        	"	lb A1,0(AL)		# (u)char load\n"
d1392 5
a1396 1
    
@


1.1
log
@reorg pcc tree; requested by and ok deraadt@@; ok ragge@@
@
text
@d1 1
a1 1
/*	$OpenBSD: table.c,v 1.2 2007/09/15 22:04:38 ray Exp $	*/
a4 2


d32 19
a50 11
 */

# include "pass2.h"

# define TLL TLONGLONG|TULONGLONG
# define ANYSIGNED TINT|TLONG|TSHORT|TCHAR
# define ANYUSIGNED TUNSIGNED|TULONG|TUSHORT|TUCHAR
# define ANYFIXED ANYSIGNED|ANYUSIGNED
# define TUWORD TUNSIGNED|TULONG
# define TSWORD TINT|TLONG
# define TWORD TUWORD|TSWORD
a55 1

a59 5





d61 1
a61 1
{ SCONV,	INTAREG,
d63 1
a63 1
	SAREG,	TSHORT|TUSHORT,
d65 2
a66 1
		"	lb A1, ZA\n	nop\n", },
d69 1
a69 15
{ SCONV,	INTAREG,
	SOREG,  TUCHAR,
	SAREG,	TSHORT|TUSHORT,
		NAREG,	RESC1,
		"	lbu A1, ZA\n	nop\n", },

/* convert char to (u)long */
{ SCONV,	INTAREG,
	SOREG,  TCHAR,
	SAREG,	TWORD,
		NAREG,	RESC1,
		"	lb A1, ZA\n	nop\n", },

/* convert uchar to (u)long */
{ SCONV,	INTAREG,
d71 1
a71 1
	SAREG,	TWORD,
d73 2
a74 1
      		"	lbu A1, ZA\n	nop\n", },
d77 1
a77 1
{ SCONV,	INTAREG,
d79 3
a81 3
	SAREG,	TLL,
		NAREG,	RESC1,
      		"	lb U1, ZA\n"
d83 2
a84 2
      		"	sra A1, U1, 31\n"
      		"	sub A1, $zero, A1\n", },
d87 1
a87 1
{ SCONV,	INTAREG,
d89 4
a92 8
	SAREG,	TLL,
		NAREG,	RESC1,
		"	lbu U1, ZA\n"
      		"	move A1, $zero\n", },


    
    
d95 1
a95 1
{ SCONV,	INTAREG,
d99 2
a100 1
		"	lb A1, ZA\n	nop\n", },
d103 1
a103 1
{ SCONV,	INTAREG,
d107 2
a108 2
		"	lbu A1, ZA\n	nop\n", },

d111 1
a111 1
{ SCONV,	INTAREG,
d115 2
a116 1
		"	lh A1, ZA\n	nop\n", },
d119 1
a119 1
{ SCONV,	INTAREG,
d123 2
a124 1
		"	lhu A1, ZA\n	nop\n", },
d127 1
a127 1
{ SCONV,	INTAREG,
d129 3
a131 3
	SAREG,	TLL,
		NAREG,	RESC1,
      		"	lh U1, ZA\n"
d133 2
a134 2
      		"	sra A1, U1, 31\n"
      		"	sub A1, $zero, A1\n", },
d137 1
a137 1
{ SCONV,	INTAREG,
d139 4
a142 8
	SAREG,	TLL,
		NAREG,	RESC1,
		"	lhu U1, ZA\n"
      		"	move A1, $zero\n", },




d145 1
a145 1
{ SCONV,	INTAREG,
d149 2
a150 1
		"	lb A1, ZA\n	nop\n", },
d153 1
a153 1
{ SCONV,	INTAREG,
d157 2
a158 1
		"	lbu A1, ZA\n	nop\n", },
d161 1
a161 1
{ SCONV,	INTAREG,
d165 2
a166 1
		"	lh A1, ZA\n	nop\n", },
d169 1
a169 1
{ SCONV,	INTAREG,
d173 2
a174 1
		"	lhu A1, ZA\n	nop\n", },
d177 1
a177 1
{ SCONV,	INTAREG,
d179 3
a181 3
	SAREG,	TLL,
		NAREG,	RESC1,
      		"	lw U1, ZA\n"
d183 2
a184 2
      		"	sra A1, U1, 31\n"
      		"	sub A1, $zero, A1\n", },
d187 1
a187 1
{ SCONV,	INTAREG,
d189 4
a192 8
	SAREG,	TLL,
		NAREG,	RESC1,
		"	lw U1, ZA\n"
      		"	move A1, $zero\n", },




d195 1
a195 1
{ SCONV,	INTAREG,
d199 2
a200 1
		"	lb A1, ZA\n	nop\n", },
d203 1
a203 1
{ SCONV,	INTAREG,
d207 2
a208 1
		"	lbu A1, ZA\n	nop\n", },
d211 1
a211 1
{ SCONV,	INTAREG,
d215 2
a216 1
		"	lh A1, ZA\n	nop\n", },
d219 1
a219 1
{ SCONV,	INTAREG,
d223 2
a224 1
		"	lhu A1, ZA\n	nop\n", },
d227 1
a227 1
{ SCONV,	INTAREG,
d231 2
a232 1
      		"	lw U1, ZA\n	nop\n", },
d234 2
a235 2
/* convert (u)long long to (u)long long */
{ SCONV,	INTAREG,
d239 2
a240 7
      		"	lwu U1, ZA\n	nop\n", },





    
d244 3
a246 3
{ SCONV,	INTAREG,
	SAREG,	TLL,
	SAREG,	TLL,
d248 1
a248 1
		"", },
d250 1
a250 1
{ SCONV,	INTAREG,
d252 4
a255 4
	SAREG,	TLL,
		NAREG,	0,
		"move A1, AR\n"
		"move U1, $zero\n", },
d257 1
a257 1
{ SCONV,	INTAREG,
d261 1
a261 4
		"move A1, AL\n", },

    

d265 1
a265 1
{ SCONV,	INTAREG,
d269 1
a269 5
		"", },


    

a270 1
    
d275 1
a275 1
{ MUL,	INAREG|FOREFF,
d279 4
a282 1
		"	mult AL, AR\n	mflo A1\n	nop\n	nop\n", },
d284 1
a284 1
{ MUL,	INAREG|FOREFF,
d288 37
a324 1
		"	multu AL, AR\n	mflo A1\n	nop\n	nop\n", },
d326 1
a326 1
{ DIV,	INAREG|FOREFF,
d330 4
a333 1
		"	div AL, AR\n	mflo A1\n	nop\n	nop\n", },
d335 1
a335 1
{ DIV,	INAREG|FOREFF,
d339 37
a375 2
		"	divu AL, AR\n	mflo A1\n	nop\n	nop\n", },

d380 17
a396 17
{ PLUS,	INAREG|FOREFF,
	SAREG,	TLL,
	SAREG,	TLL,
		3*NAREG,	RESC3,
      		"	addu A1, AL, AR\n"
      		"	sltu A2, A1, AR\n"
      		"	addu A3, UL, UR\n"
      		"	addu A3, A3, A2\n", },
    
{ PLUS,	INAREG|FOREFF,
	SAREG,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
	SCON,	TUSHORT|TSHORT|TCHAR|TUCHAR,
		NAREG|NASR|NASL,	RESC1,
		"	addiu A1, AL, AR\n", },
    
    /*
{ PLUS,	INAREG|FOREFF,
d398 10
d409 20
a428 4
		NAREG|NASR|NASL,	RESC1,
		"	addu A1, AL, AR\n", },
	
{ MINUS,	INAREG|FOREFF,
d431 2
a432 18
		NAREG|NASR|NASL,	RESC1,
		"	subu A1, AL, AR\n", },
    */

{ MINUS,	INAREG|FOREFF,
	SAREG,	TLL,
	SAREG,	TLL,
		NAREG|NASR|NASL,	RESC1,
      		"	sltu A1, AL, AR\n"
      		"	subu AR, AL, AR\n"
      		"	subu UR, UL, UR\n"
      		"	subu UR, UR, A1\n", },
    
{ MINUS,	INAREG|FOREFF,
	SAREG,	TWORD|TSHORT|TUSHORT|TCHAR|TUCHAR,
	SCON,	TUSHORT|TSHORT|TCHAR|TUCHAR,
		NAREG|NASR|NASL,	RESC1,
		"	subiu A1, AL, AR\n", },
d434 5
d440 1
a440 1
{ UMINUS,	INAREG|FOREFF|INTAREG,
d444 10
a453 1
		"	neg A1, AL\n", },
a454 1
    
d457 6
a462 6
{ OPSIMP,	INAREG|FOREFF,
	SAREG,	TLL,
	SAREG,	TLL,
		NAREG|NASR|NASL,	RESC1,
      		"	O A1, AL, AR\n"
      		"	O U1, UL, UR\n", },
d464 1
a464 1
{ OPSIMP,	INAREG|FOREFF,
d468 1
a468 1
		"	O A1, AL, AR\n", },
d470 1
a470 1
{ OPSIMP,	INAREG|FOREFF,
d472 3
a474 3
	SCON,	TSHORT|TUSHORT|TUCHAR|TCHAR,
		NAREG|NASR|NASL,	RESC1,
		"	Oi A1, AL, AR\n", },
d480 1
a480 2
    /* order.c SPECIAL
{ RS,	INAREG|INTAREG|FOREFF,
d484 1
a484 1
		"	srl A1, AL, AR\n", },
d486 1
a486 1
{ LS,	INAREG|INTAREG|FOREFF,
d490 1
a490 2
		"	sll A1, AL, AR\n", },
    */
d492 1
a492 1
{ RS,	INAREG|INTAREG|FOREFF,
d496 1
a496 1
		"	srlv A1, AL, AR\n", },
d498 1
a498 1
{ LS,	INAREG|INTAREG|FOREFF,
d502 25
a526 1
		"	sllv A1, AL, AR\n", },	
d532 1
a532 1
{ COMPL,        INTAREG,
d536 8
a543 1
                "	not A1, AL\n", },
d549 29
a577 5
{ ASSIGN,	INTAREG,
	SOREG,	TWORD|TPOINT,
	SAREG,	TWORD|TPOINT,
		0,	RRIGHT,
        	"	sw AR, AL\n", },
d579 2
a580 20
{ ASSIGN,	INTAREG,
	SOREG,	TSHORT|TUSHORT,
	SAREG,	TSHORT|TUSHORT,
		0,	RRIGHT,
        	"	sh AR, AL\n", },	

{ ASSIGN,	INTAREG,
	SOREG,	TCHAR|TUCHAR,
	SAREG,	TCHAR|TUCHAR,
		0,	RRIGHT,
        	"	sb AR, AL\n", },	

{ ASSIGN,	INTAREG,
	SOREG,	TLL,
	SAREG,	TLL,
		0,	RRIGHT,
      		"	sw UR, UL\n"
      		"	sw AR, AL\n", },

{ ASSIGN,	INTAREG, // XXX: Funkar ej A1 == AR
d583 4
a586 2
		NAREG,	RRIGHT,
        	"	la A1, AL\n	sw AR, 0(A1)\n", },
d588 1
a588 1
{ ASSIGN,	INTAREG,
d591 4
a594 2
		NAREG,	RRIGHT,
        	"	la A1, AL\n	sh AR, 0(A1)\n", },
d596 1
a596 1
{ ASSIGN,	INTAREG,
d599 5
a603 2
		NAREG,	RRIGHT,
        	"	la A1, AL\n	sb AR, 0(A1)\n", },	
d605 30
a634 6
{ ASSIGN,	INTAREG,
	SNAME,	TLL,
	SAREG,	TLL,
		0,	RRIGHT,
      		"	sw UR, UL\n"
      		"	sw AR, AL\n", },
a635 12
{ ASSIGN,	INTAREG,
	SAREG,	TLL,
	SAREG,	TLL,
		0,	RRIGHT,
      		"	move UR, UL\n"
      		"	move AR, AL\n", },
    
{ ASSIGN,	INTAREG|FOREFF,
	SAREG,	TANY,
	SAREG,	TANY,
		0,	RLEFT,
        	"	move AL, AR\n", },
a636 9
#if 0
/* XXX - Stupid rule, shouldn't exist */
{ ASSIGN,	INTAREG,
	SANY,	TANY,
	SAREG,	TANY,
		0,	RLEFT,
        	"	move AL, AR\n", },
#endif
    
d641 24
a664 17
{ EQ,	FORCC,
	SAREG,	TANY,
	SAREG,	TANY,
		0,	RESCC,
		"	ZQ\n", },

{ NE,	FORCC,
	SAREG,	TANY,
	SAREG,	TANY,
		0,	RESCC,
		"	ZQ\n", },	

{ LE,	FORCC,
	SAREG,	TANY,
	SAREG,	TANY,
		NAREG|NASL,	RESCC,
		"	sub A1, AL, AR\n	ZQ\n", },	
a665 19
{ LT,	FORCC,
	SAREG,	TANY,
	SAREG,	TANY,
		NAREG|NASL,	RESCC,
		"	sub A1, AL, AR\n	ZQ\n", },	

{ GE,	FORCC,
	SAREG,	TANY,
	SAREG,	TANY,
		NAREG|NASL,	RESCC,
		"	sub A1, AL, AR\n	ZQ\n", },

{ GT,	FORCC,
	SAREG,	TANY,
	SAREG,	TANY,
		NAREG|NASL,	RESCC,
		"	sub A1, AL, AR\n	ZQ\n", },

	
d670 3
a672 6

/* from OREG to REG */

{ OPLTYPE,	INTAREG,
	SANY,	TANY,
	SOREG,	TCHAR,
d674 2
a675 1
		"	lb A1,AR\n	nop\n", },
d677 36
a712 5
{ OPLTYPE,	INTAREG,
	SANY,	TANY,
	SOREG,	TUCHAR,
		NAREG,	RESC1,
		"	lbu A1,AR\n	nop\n", },
d714 1
a714 5
{ OPLTYPE,	INTAREG,
	SANY,	TANY,
	SOREG,	TSHORT,
		NAREG,	RESC1,
		"	lh A1,AR\n	nop\n", },
d716 1
a716 5
{ OPLTYPE,	INTAREG,
	SANY,	TANY,
	SOREG,	TUSHORT,
		NAREG,	RESC1,
		"	lhu A1,AR\n	nop\n", },
d718 1
a718 17
{ OPLTYPE,	INTAREG,
	SANY,	TANY,
	SOREG,	TWORD|TPOINT,
		NAREG,	RESC1,
		"	lw A1, AR\n	nop\n", },

{ OPLTYPE,	INTAREG,
	SANY,	TANY,
	SOREG,	TLL,
		NAREG,	RESC1,
		"	lw U1, UR\n"
		"	lw A1, AR\n"
      		"	nop\n", },

/* from NAME to REG */

{ OPLTYPE,	INTAREG,
d722 3
a724 1
		"	la A2, AR\n	lb A1, 0(A2)\n	nop\n", },
d726 1
a726 1
{ OPLTYPE,	INTAREG,
d730 3
a732 1
		"	la A2, AR\n	lbu A1, 0(A2)\n	nop\n", },
d734 1
a734 1
{ OPLTYPE,	INTAREG,
d738 3
a740 1
		"	la A2, AR\n	lh A1, 0(A2)\n	nop\n", },
d742 1
a742 1
{ OPLTYPE,	INTAREG,
d746 3
a748 1
		"	la A2, AR\n	lhu A1, 0(A2)\n	nop\n", },
d750 1
a750 1
{ OPLTYPE,	INTAREG,
d754 3
a756 1
		"	la A2, AR\n	lw A1, 0(A2)\n	nop\n", },
d758 1
a758 1
{ OPLTYPE,	INTAREG,
d761 6
a766 5
		2*NAREG,	RESC1,
		"	la A2, UR\n"
		"	lw U1, 0(A2)\n"
		"	la A2, AR\n"
		"	lw A1, 0(A2)\n"
d769 3
a771 2
/* from CON to REG */
{ OPLTYPE,	INTAREG,
d775 1
a775 1
		"	la A1, AR\n", },
d777 1
a777 1
{ OPLTYPE,	INTAREG,
d781 21
a801 1
		"	li A1, AR\n", },
d805 1
a805 1
{ OPLTYPE,	INTAREG,
d809 1
a809 1
		"	move A1, AR\n", },
d811 12
d831 2
a832 1
		"	j LL\n	nop\n", },
d838 32
a869 5
{ UCALL,        INTAREG|FOREFF,
        SCON,   TANY,
        SANY,   TANY,
	  	NAREG,     RESC1,
                "	addi $sp, $sp, -16\n	jal AL\n	nop\nZC\n", },
d872 2
a873 2
{ USTCALL,      INTAREG|FOREFF,
        SCON,   TANY,
d875 3
a877 2
                NAREG|NASL,     RESC1,  /* should be 0 */
                "       call CL\nZC", },
d882 1
a882 2
	
	
d884 1
a884 1
        SAREG,	TWORD|TPOINT,
d886 4
a889 2
                0,      RNULL,
                "	addi $sp, $sp, -4\n	sw AL, 0($sp)\n", },
d892 1
a892 1
        SAREG, TSHORT|TUSHORT,
d894 5
a898 2
                0,      RNULL,
                "	addi $sp, $sp, -4\n	sh AL, 0($sp)\n", },
d900 1
a900 1
        SAREG, TCHAR|TUCHAR,
d902 4
a905 3
                0,      RNULL,
                "	addi $sp, $sp, -4\n	sb AL, 0($sp)\n", },    

d910 1
a910 2
{ UMUL, INTAREG,
	SOREG,	TPOINT|TWORD|TPTRTO,
d912 4
a915 2
    		NAREG|NASL,     RESC1,
        	"	lw A1, AL\n	nop\n", },
d917 1
a917 2
{ UMUL, INTAREG,
	SOREG,	TSHORT|TUSHORT|TPTRTO,
d919 4
a922 2
    		NAREG|NASL,     RESC1,
        	"	lh A1, AL\n	nop\n", },
d924 1
a924 2
{ UMUL, INTAREG,
	SOREG,	TCHAR|TUCHAR|TPTRTO,
d926 4
a929 2
    		NAREG|NASL,     RESC1,
        	"	lb A1, AL\n	nop\n", },
d931 1
a931 2
{ UMUL, INTAREG,
	SNAME,	TPOINT|TWORD|TPTRTO,
d933 5
a937 2
    		NAREG|NASL,     RESC1,
        	"	la A1, AL\n	lw A1, 0(A1)\n	nop\n", },
d939 1
a939 2
{ UMUL, INTAREG,
	SNAME,	TSHORT|TUSHORT|TPTRTO,
d941 5
a945 2
    		NAREG|NASL,     RESC1,
        	"	la A1, AL\n	lh A1, 0(A1)\n	nop\n", },
d947 1
a947 2
{ UMUL, INTAREG,
	SNAME,	TCHAR|TUCHAR|TPTRTO,
d949 5
a953 2
    		NAREG|NASL,     RESC1,
        	"	la A1, AL\n	lb A1, 0(A1)\n	nop\n", },
d955 1
a955 2
{ UMUL, INTAREG,
	SAREG,	TPOINT|TWORD|TPTRTO,
d957 4
a960 2
    		NAREG|NASL,     RESC1,
        	"	lw A1, 0(AL)\n	nop\n", },
d962 1
a962 2
{ UMUL, INTAREG,
	SAREG,	TSHORT|TUSHORT|TPTRTO,
d964 4
a967 2
    		NAREG|NASL,     RESC1,
        	"	lh A1, 0(AL)\n	nop\n", },
d969 1
a969 2
{ UMUL, INTAREG,
	SAREG,	TCHAR|TUCHAR|TPTRTO,
d971 1
d973 2
a974 1
        	"	lb A1, 0(AL)\n	nop\n", },
@

