head	1.7;
access;
symbols
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.16
	OPENBSD_5_0:1.6.0.14
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.12
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.10
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.6
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5;
locks; strict;
comment	@ * @;


1.7
date	2012.04.12.11.51.13;	author pirofti;	state dead;
branches;
next	1.6;

1.6
date	2008.04.11.20.45.52;	author stefan;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.22.22.56.31;	author stefan;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.22.14.12.26;	author stefan;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.18.17.39.55;	author ragge;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.16.08.34.55;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.07.17.58.51;	author otto;	state Exp;
branches;
next	;


desc
@@


1.7
log
@tedu(tm) pcc.

Message sent. Okay deraadt@@.
@
text
@/*	$OpenBSD: local.c,v 1.6 2008/04/11 20:45:52 stefan Exp $	*/
/*
 * Copyright (c) 2003 Anders Magnusson (ragge@@ludd.luth.se).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * MIPS port by Jan Enoksson (janeno-1@@student.ltu.se) and
 * Simon Olsson (simols-1@@student.ltu.se) 2005.
 */

#include <assert.h>
#include "pass1.h"

static int inbits, inval;

/* this is called to do local transformations on
 * an expression tree preparitory to its being
 * written out in intermediate code.
 */
NODE *
clocal(NODE *p)
{
	struct symtab *q;
	NODE *r, *l;
	int o;
	int m;
	TWORD ty;
	int tmpnr, isptrvoid = 0;

#ifdef PCC_DEBUG
	if (xdebug) {
		printf("clocal in: %p\n", p);
		fwalk(p, eprint, 0);
	}
#endif

	switch (o = p->n_op) {

	case UCALL:
	case CALL:
	case STCALL:
	case USTCALL:
		if (p->n_type == VOID)
			break;
		/*
		 * if the function returns void*, ecode() invokes
		 * delvoid() to convert it to uchar*.
		 * We just let this happen on the ASSIGN to the temp,
		 * and cast the pointer back to void* on access
		 * from the temp.
		 */
		if (p->n_type == PTR+VOID)
			isptrvoid = 1;
		r = tempnode(0, p->n_type, p->n_df, p->n_sue);
		tmpnr = regno(r);
		r = block(ASSIGN, r, p, p->n_type, p->n_df, p->n_sue);

		p = tempnode(tmpnr, r->n_type, r->n_df, r->n_sue);
		if (isptrvoid) {
			p = block(PCONV, p, NIL, PTR+VOID,
			    p->n_df, MKSUE(PTR+VOID));
		}
		p = buildtree(COMOP, r, p);
		break;

	case NAME:
		if ((q = p->n_sp) == NULL)
			return p; /* Nothing to care about */

		switch (q->sclass) {

		case PARAM:
		case AUTO:
			/* fake up a structure reference */
			r = block(REG, NIL, NIL, PTR+STRTY, 0, 0);
			r->n_lval = 0;
			r->n_rval = FP;
			p = stref(block(STREF, r, p, 0, 0, 0));
			break;

		case STATIC:
			if (q->slevel == 0)
				break;
			p->n_lval = 0;
			p->n_sp = q;
			break;

		case REGISTER:
			p->n_op = REG;
			p->n_lval = 0;
			p->n_rval = q->soffset;
			break;

		}
		break;

	case FUNARG:
		/* Args smaller than int are given as int */
		if (p->n_type != CHAR && p->n_type != UCHAR && 
		    p->n_type != SHORT && p->n_type != USHORT)
			break;
		p->n_left = block(SCONV, p->n_left, NIL, INT, 0, MKSUE(INT));
		p->n_type = INT;
		p->n_sue = MKSUE(INT);
		p->n_rval = SZINT;
		break;

	case CBRANCH:
		l = p->n_left;

		/*
		 * Remove unneccessary conversion ops.
		 */
		if (clogop(l->n_op) && l->n_left->n_op == SCONV) {
			if (coptype(l->n_op) != BITYPE)
				break;
			if (l->n_right->n_op == ICON) {
				r = l->n_left->n_left;
				if (r->n_type >= FLOAT && r->n_type <= LDOUBLE)
					break;
				/* Type must be correct */
				ty = r->n_type;
				nfree(l->n_left);
				l->n_left = r;
				l->n_type = ty;
				l->n_right->n_type = ty;
			}
#if 0
			  else if (l->n_right->n_op == SCONV &&
			    l->n_left->n_type == l->n_right->n_type) {
				r = l->n_left->n_left;
				nfree(l->n_left);
				l->n_left = r;
				r = l->n_right->n_left;
				nfree(l->n_right);
				l->n_right = r;
			}
#endif
		}
		break;

	case PCONV:
		/* Remove redundant PCONV's. Be careful */
		l = p->n_left;
		if (l->n_op == ICON) {
			l->n_lval = (unsigned)l->n_lval;
			goto delp;
		}
		if (l->n_type < INT || DEUNSIGN(l->n_type) == LONGLONG) {
			/* float etc? */
			p->n_left = block(SCONV, l, NIL,
			    UNSIGNED, 0, MKSUE(UNSIGNED));
			break;
		}
		/* if left is SCONV, cannot remove */
		if (l->n_op == SCONV)
			break;

		/* avoid ADDROF TEMP */
		if (l->n_op == ADDROF && l->n_left->n_op == TEMP)
			break;

		/* if conversion to another pointer type, just remove */
		if (p->n_type > BTMASK && l->n_type > BTMASK)
			goto delp;
		break;

	delp:	l->n_type = p->n_type;
		l->n_qual = p->n_qual;
		l->n_df = p->n_df;
		l->n_sue = p->n_sue;
		nfree(p);
		p = l;
		break;

	case SCONV:
		l = p->n_left;

		if (p->n_type == l->n_type) {
			nfree(p);
			p = l;
			break;
		}

		if ((p->n_type & TMASK) == 0 && (l->n_type & TMASK) == 0 &&
		    btdims[p->n_type].suesize == btdims[l->n_type].suesize) {
			if (p->n_type != FLOAT && p->n_type != DOUBLE &&
			    l->n_type != FLOAT && l->n_type != DOUBLE &&
			    l->n_type != LDOUBLE && p->n_type != LDOUBLE) {
				if (l->n_op == NAME || l->n_op == UMUL ||
				    l->n_op == TEMP) {
					l->n_type = p->n_type;
					nfree(p);
					p = l;
					break;
				}
			}
		}

		if (DEUNSIGN(p->n_type) == INT && DEUNSIGN(l->n_type) == INT &&
		    coptype(l->n_op) == BITYPE) {
			l->n_type = p->n_type;
			nfree(p);
			p = l;
		}

		if (DEUNSIGN(p->n_type) == SHORT &&
		    DEUNSIGN(l->n_type) == SHORT) {
			nfree(p);
			p = l;
		}

		/* convert float/double to int before to (u)char/(u)short */
		if ((DEUNSIGN(p->n_type) == CHAR ||
		    DEUNSIGN(p->n_type) == SHORT) &&
                    (l->n_type == FLOAT || l->n_type == DOUBLE ||
		    l->n_type == LDOUBLE)) {
			p = block(SCONV, p, NIL, p->n_type, p->n_df, p->n_sue);
			p->n_left->n_type = INT;
			break;
                }

		/* convert (u)char/(u)short to int before float/double */
		if  ((p->n_type == FLOAT || p->n_type == DOUBLE ||
		    p->n_type == LDOUBLE) && (DEUNSIGN(l->n_type) == CHAR ||
		    DEUNSIGN(l->n_type) == SHORT)) {
			p = block(SCONV, p, NIL, p->n_type, p->n_df, p->n_sue);
			p->n_left->n_type = INT;
			break;
                }

		o = l->n_op;
		m = p->n_type;

		if (o == ICON) {
			CONSZ val = l->n_lval;

			if (!ISPTR(m)) /* Pointers don't need to be conv'd */
			    switch (m) {
			case BOOL:
				l->n_lval = l->n_lval != 0;
				break;
			case CHAR:
				l->n_lval = (char)val;
				break;
			case UCHAR:
				l->n_lval = val & 0377;
				break;
			case SHORT:
				l->n_lval = (short)val;
				break;
			case USHORT:
				l->n_lval = val & 0177777;
				break;
			case ULONG:
			case UNSIGNED:
				l->n_lval = val & 0xffffffff;
				break;
			case LONG:
			case INT:
				l->n_lval = (int)val;
				break;
			case LONGLONG:
				l->n_lval = (long long)val;
				break;
			case ULONGLONG:
				l->n_lval = val;
				break;
			case VOID:
				break;
			case LDOUBLE:
			case DOUBLE:
			case FLOAT:
				l->n_op = FCON;
				l->n_dcon = val;
				break;
			default:
				cerror("unknown type %d", m);
			}
			l->n_type = m;
			nfree(p);
			p = l;
		}
		break;

	case MOD:
	case DIV:
		if (o == DIV && p->n_type != CHAR && p->n_type != SHORT)
			break;
		if (o == MOD && p->n_type != CHAR && p->n_type != SHORT)
			break;
		/* make it an int division by inserting conversions */
		p->n_left = block(SCONV, p->n_left, NIL, INT, 0, MKSUE(INT));
		p->n_right = block(SCONV, p->n_right, NIL, INT, 0, MKSUE(INT));
		p = block(SCONV, p, NIL, p->n_type, 0, MKSUE(p->n_type));
		p->n_left->n_type = INT;
		break;

	case PMCONV:
	case PVCONV:
                if( p->n_right->n_op != ICON ) cerror( "bad conversion", 0);
                nfree(p);
                p = buildtree(o==PMCONV?MUL:DIV, p->n_left, p->n_right);
		break;

	case FORCE:
		/* put return value in return reg */
		p->n_op = ASSIGN;
		p->n_right = p->n_left;
		p->n_left = block(REG, NIL, NIL, p->n_type, 0, MKSUE(INT));
		p->n_left->n_rval = RETREG(p->n_type);
		break;
	}

#ifdef PCC_DEBUG
	if (xdebug) {
		printf("clocal out: %p\n", p);
		fwalk(p, eprint, 0);
	}
#endif

	return(p);
}

void
myp2tree(NODE *p)
{
	struct symtab *sp;

	if (p->n_op != FCON) 
		return;

	/* Write float constants to memory */
 
	sp = tmpalloc(sizeof(struct symtab));
	sp->sclass = STATIC;
	sp->slevel = 1; /* fake numeric label */
	sp->soffset = getlab();
	sp->sflags = 0;
	sp->stype = p->n_type;
	sp->squal = (CON >> TSHIFT);

	defloc(sp);
	ninval(0, btdims[p->n_type].suesize, p);

	p->n_op = NAME;
	p->n_lval = 0;
	p->n_sp = sp;

}

/*ARGSUSED*/
int
andable(NODE *p)
{
	return(1);  /* all names can have & taken on them */
}

/*
 * at the end of the arguments of a ftn, set the automatic offset
 */
void
cendarg()
{
	autooff = AUTOINIT;
}

/*
 * is an automatic variable of type t OK for a register variable
 */
int
cisreg(TWORD t)
{
	if (t == INT || t == UNSIGNED || t == LONG || t == ULONG)
		return(1);
	return 0; /* XXX - fix reg assignment in pftn.c */
}

/*
 * return a node, for structure references, which is suitable for
 * being added to a pointer of type t, in order to be off bits offset
 * into a structure
 * t, d, and s are the type, dimension offset, and sizeoffset
 * Be careful about only handling first-level pointers, the following
 * indirections must be fullword.
 */
NODE *
offcon(OFFSZ off, TWORD t, union dimfun *d, struct suedef *sue)
{
	NODE *p;

	if (xdebug)
		printf("offcon: OFFSZ %lld type %x dim %p siz %d\n",
		    off, t, d, sue->suesize);

	p = bcon(off/SZCHAR);
	return p;
}

/*
 * Allocate off bits on the stack.  p is a tree that when evaluated
 * is the multiply count for off, t is a NAME node where to write
 * the allocated address.
 */
void
spalloc(NODE *t, NODE *p, OFFSZ off)
{
	NODE *sp;
	int nbytes = off / SZCHAR;

	p = buildtree(MUL, p, bcon(nbytes));
	p = buildtree(PLUS, p, bcon(7));
	p = buildtree(AND, p, bcon(~7));

	/* subtract the size from sp */
	sp = block(REG, NIL, NIL, p->n_type, 0, 0);
	sp->n_lval = 0;
	sp->n_rval = SP;
	ecomp(buildtree(MINUSEQ, sp, p));

	/* save the address of sp */
	sp = block(REG, NIL, NIL, PTR+INT, t->n_df, t->n_sue);
	sp->n_rval = SP;
	t->n_type = sp->n_type;
	ecomp(buildtree(ASSIGN, t, sp)); /* Emit! */
}

/*
 * print out a constant node
 * mat be associated with a label
 */
void
ninval(CONSZ off, int fsz, NODE *p)
{
        union { float f; double d; int i[2]; } u;
        struct symtab *q;
        TWORD t;
#ifndef USE_GAS
        int i, j;
#endif

        t = p->n_type;
        if (t > BTMASK)
                t = INT; /* pointer */

        if (p->n_op != ICON && p->n_op != FCON)
                cerror("ninval: init node not constant");

        if (p->n_op == ICON && p->n_sp != NULL && DEUNSIGN(t) != INT)
                uerror("element not constant");

        switch (t) {
        case LONGLONG:
        case ULONGLONG:
#ifdef USE_GAS
                printf("\t.dword %lld\n", (long long)p->n_lval);
#else
                i = p->n_lval >> 32;
                j = p->n_lval & 0xffffffff;
                p->n_type = INT;
		if (bigendian) {
			p->n_lval = j;
	                ninval(off, 32, p);
			p->n_lval = i;
			ninval(off+32, 32, p);
		} else {
			p->n_lval = i;
	                ninval(off, 32, p);
			p->n_lval = j;
			ninval(off+32, 32, p);
		}
#endif
                break;
        case BOOL:
                if (p->n_lval > 1)
                        p->n_lval = p->n_lval != 0;
                /* FALLTHROUGH */
        case INT:
        case UNSIGNED:
                printf("\t.word " CONFMT, (CONSZ)p->n_lval);
                if ((q = p->n_sp) != NULL) {
                        if ((q->sclass == STATIC && q->slevel > 0) ||
                            q->sclass == ILABEL) {
                                printf("+" LABFMT, q->soffset);
                        } else
                                printf("+%s", exname(q->soname));
                }
                printf("\n");
                break;
        case SHORT:
        case USHORT:
                printf("\t.half %d\n", (int)p->n_lval & 0xffff);
                break;
        case CHAR:
        case UCHAR:
                printf("\t.byte %d\n", (int)p->n_lval & 0xff);
                break;
        case LDOUBLE:
        case DOUBLE:
                u.d = (double)p->n_dcon;
		if (bigendian) {
	                printf("\t.word\t%d\n", u.i[0]);
			printf("\t.word\t%d\n", u.i[1]);
		} else {
			printf("\t.word\t%d\n", u.i[1]);
	                printf("\t.word\t%d\n", u.i[0]);
		}
                break;
        case FLOAT:
                u.f = (float)p->n_dcon;
                printf("\t.word\t0x%x\n", u.i[0]);
                break;
        default:
                cerror("ninval");
        }
}

/* make a name look like an external name in the local machine */
char *
exname(char *p)
{
	if (p == NULL)
		return "";
	return p;
}

/*
 * map types which are not defined on the local machine
 */
TWORD
ctype(TWORD type)
{
	switch (BTYPE(type)) {
	case LONG:
		MODTYPE(type,INT);
		break;

	case ULONG:
		MODTYPE(type,UNSIGNED);

	}
	return (type);
}

/* curid is a variable which is defined but
 * is not initialized (and not a function );
 * This routine returns the storage class for an uninitialized declaration
 */
int
noinit()
{
	return(EXTERN);
}

void
calldec(NODE *p, NODE *q) 
{
}

void
extdec(struct symtab *q)
{
}

/*
 * Print out a string of characters.
 * Assume that the assembler understands C-style escape
 * sequences.
 */
void
instring(struct symtab *sp)
{
	char *s, *str;

	defloc(sp);
	str = sp->sname;

	/* be kind to assemblers and avoid long strings */
	printf("\t.ascii \"");
	for (s = str; *s != 0; ) {
		if (*s++ == '\\') {
			(void)esccon(&s);
		}
		if (s - str > 60) {
			fwrite(str, 1, s - str, stdout);
			printf("\"\n\t.ascii \"");
			str = s;
		}
	}
	fwrite(str, 1, s - str, stdout);
	printf("\\0\"\n");
}

/*
 * Print out a wide string by calling ninval().
 */
void
inwstring(struct symtab *sp)
{
	char *s = sp->sname;
	NODE *p;

	defloc(sp);
	p = bcon(0);
	do {
		if (*s++ == '\\')
			p->n_lval = esccon(&s);
		else
			p->n_lval = (unsigned char)s[-1];
		ninval(0, (MKSUE(WCHAR_TYPE))->suesize, p);
	} while (s[-1] != 0);
	nfree(p);
}

/* make a common declaration for id, if reasonable */
void
defzero(struct symtab *sp)
{
	int off;

	off = tsize(sp->stype, sp->sdf, sp->ssue);
	off = (off+(SZCHAR-1))/SZCHAR;
	printf("	.%scomm ", sp->sclass == STATIC ? "l" : "");
	if (sp->slevel == 0)
		printf("%s,0%o\n", exname(sp->soname), off);
	else
		printf(LABFMT ",0%o\n", sp->soffset, off);
}


#ifdef notdef
/* make a common declaration for id, if reasonable */
void
commdec(struct symtab *q)
{
	int off;

	off = tsize(q->stype, q->sdf, q->ssue);
	off = (off+(SZCHAR-1))/SZCHAR;

	printf("	.comm %s,%d\n", exname(q->soname), off);
}

/* make a local common declaration for id, if reasonable */
void
lcommdec(struct symtab *q)
{
	int off;

	off = tsize(q->stype, q->sdf, q->ssue);
	off = (off+(SZCHAR-1))/SZCHAR;
	if (q->slevel == 0)
		printf("\t.lcomm %s,%d\n", exname(q->soname), off);
	else
		printf("\t.lcomm " LABFMT ",%d\n", q->soffset, off);
}

/*
 * print a (non-prog) label.
 */
void
deflab1(int label)
{
	printf(LABFMT ":\n", label);
}

/* ro-text, rw-data, ro-data, ro-strings */
static char *loctbl[] = { "text", "data", "rdata", "rdata" };

void
setloc1(int locc)
{
	if (locc == lastloc && locc != STRNG)
		return;
	if (locc == DATA && lastloc == STRNG)
		return;

	if (locc != lastloc) {
		lastloc = locc;
		printf("\t.%s\n", loctbl[locc]);
	}

	if (locc == STRNG)
		printf("\t.align 2\n");
}
#endif

/*
 * Initialize a bitfield.
 */
void
infld(CONSZ off, int fsz, CONSZ val)
{
        if (idebug)
                printf("infld off %lld, fsz %d, val %lld inbits %d\n",
                    off, fsz, val, inbits);
        val &= (1 << fsz)-1;
        while (fsz + inbits >= SZCHAR) {
                inval |= (val << inbits);
                printf("\t.byte %d\n", inval & 255);
                fsz -= (SZCHAR - inbits);
                val >>= (SZCHAR - inbits);
                inval = inbits = 0;
        }
        if (fsz) {
                inval |= (val << inbits);
                inbits += fsz;
        }
}

/*
 * set fsz bits in sequence to zero.
 */
void
zbits(OFFSZ off, int fsz)
{
        int m;

        if (idebug)
                printf("zbits off %lld, fsz %d inbits %d\n", off, fsz, inbits);
        if ((m = (inbits % SZCHAR))) {
                m = SZCHAR - m;
                if (fsz < m) {
                        inbits += fsz;
                        return;
                } else {
                        fsz -= m;
                        printf("\t.byte %d\n", inval);
                        inval = inbits = 0;
                }
        }
        if (fsz >= SZCHAR) {
                printf("\t.zero %d\n", fsz/SZCHAR);
                fsz -= (fsz/SZCHAR) * SZCHAR;
        }
        if (fsz) {
                inval = 0;
                inbits = fsz;
        }
}

/*
 * va_start(ap, last) implementation.
 *
 * f is the NAME node for this builtin function.
 * a is the argument list containing:
 *	   CM
 *	ap   last
 *
 * It turns out that this is easy on MIPS.  Just write the
 * argument registers to the stack in va_arg_start() and
 * use the traditional method of walking the stackframe.
 */
NODE *
mips_builtin_stdarg_start(NODE *f, NODE *a)
{
	NODE *p, *q;
	int sz = 1;
	int i;

	/* check num args and type */
	if (a == NULL || a->n_op != CM || a->n_left->n_op == CM ||
	    !ISPTR(a->n_left->n_type))
		goto bad;

	/*
	 * look at the offset of the last org to calculate the
	 * number of remain registers that need to be written
	 * to the stack.
	 */
	if (xtemps) {
		for (i = 0; i < nargregs; i++) {
			q = block(REG, NIL, NIL, PTR+INT, 0, MKSUE(INT));
			q->n_rval = A0 + i;
			p = block(REG, NIL, NIL, PTR+INT, 0, MKSUE(INT));
			p->n_rval = SP;
			p = block(PLUS, p, bcon(ARGINIT+i), PTR+INT, 0, MKSUE(INT));
			p = buildtree(UMUL, p, NIL);
			p = buildtree(ASSIGN, p, q);
			ecomp(p);
		}
	}

	/* must first deal with argument size; use int size */
	p = a->n_right;
	if (p->n_type < INT) {
		/* round up to word */
		sz = SZINT / tsize(p->n_type, p->n_df, p->n_sue);
	}

	/*
	 * Once again, if xtemps, the register is written to a
	 * temp.  We cannot take the address of the temp and
	 * walk from there.
	 *
	 * No solution at the moment...
	 */
	assert(!xtemps);

	p = buildtree(ADDROF, p, NIL);	/* address of last arg */
	p = optim(buildtree(PLUS, p, bcon(sz)));
	q = block(NAME, NIL, NIL, PTR+VOID, 0, 0);
	q = buildtree(CAST, q, p);
	p = q->n_right;
	nfree(q->n_left);
	nfree(q);
	p = buildtree(ASSIGN, a->n_left, p);
	tfree(f);
	nfree(a);

	return p;

bad:
	uerror("bad argument to __builtin_stdarg_start");
	return bcon(0);
}

NODE *
mips_builtin_va_arg(NODE *f, NODE *a)
{
	NODE *p, *q, *r;
	int sz, tmpnr;

	/* check num args and type */
	if (a == NULL || a->n_op != CM || a->n_left->n_op == CM ||
	    !ISPTR(a->n_left->n_type) || a->n_right->n_op != TYPE)
		goto bad;

	/* create a copy to a temp node */
	p = tcopy(a->n_left);
	q = tempnode(0, p->n_type, p->n_df, p->n_sue);
	tmpnr = regno(q);
	p = buildtree(ASSIGN, q, p);

	r = a->n_right;
	sz = tsize(r->n_type, r->n_df, r->n_sue) / SZCHAR;
	if (sz < SZINT/SZCHAR) {
		werror("%s%s promoted to int when passed through ...",
			r->n_type & 1 ? "unsigned " : "",
			DEUNSIGN(r->n_type) == SHORT ? "short" : "char");
		sz = SZINT/SZCHAR;
	}
	q = buildtree(PLUSEQ, a->n_left, bcon(sz));
	q = buildtree(COMOP, p, q);

	nfree(a->n_right);
	nfree(a);
	nfree(f); 

	p = tempnode(tmpnr, INCREF(r->n_type), r->n_df, r->n_sue);
	p = buildtree(UMUL, p, NIL);
	p = buildtree(COMOP, q, p);

	return p;

bad:
	uerror("bad argument to __builtin_va_arg");
	return bcon(0);
}

NODE *
mips_builtin_va_end(NODE *f, NODE *a)
{
	tfree(f);
	tfree(a);
	return bcon(0);
}

NODE *
mips_builtin_va_copy(NODE *f, NODE *a)
{
	if (a == NULL || a->n_op != CM || a->n_left->n_op == CM)
		goto bad;
	tfree(f);
	f = buildtree(ASSIGN, a->n_left, a->n_right);
	nfree(a);
	return f;

bad:
	uerror("bad argument to __buildtin_va_copy");
	return bcon(0);
}
/*
 * Give target the opportunity of handling pragmas.
 */
int
mypragma(char **ary)
{
	return 0; }

/*
 * Called when a identifier has been declared, to give target last word.
 */
void
fixdef(struct symtab *sp)
{
}

@


1.6
log
@Sync with master repo. Reminded by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.5
log
@Sync with main repo.
@
text
@d78 1
a78 1
		tmpnr = r->n_lval;
d351 22
d509 1
a509 1
                                printf("+%s", exname(q->sname));
d588 67
d664 1
a664 5
#ifdef GCC_COMPAT
	printf("	.comm %s,%d\n", gcc_findname(q), off);
#else
	printf("	.comm %s,%d\n", exname(q->sname), off);
#endif
d676 1
a676 5
#ifdef GCC_COMPAT
		printf("\t.lcomm %s,%d\n", gcc_findname(q), off);
#else
		printf("\t.lcomm %s,%d\n", exname(q->sname), off);
#endif
d709 1
d855 1
a855 1
	tmpnr = q->n_lval;
d906 16
@


1.4
log
@Sync with main repo.
@
text
@d263 3
d410 1
d412 9
a420 12
	if ((off % SZINT) == 0)
		p =  buildtree(MUL, p, bcon(off/SZINT));
	else if ((off % SZSHORT) == 0) {
		p = buildtree(MUL, p, bcon(off/SZSHORT));
		p = buildtree(PLUS, p, bcon(1));
		p = buildtree(RS, p, bcon(1));
	} else if ((off % SZCHAR) == 0) {
		p = buildtree(MUL, p, bcon(off/SZCHAR));
		p = buildtree(PLUS, p, bcon(3));
		p = buildtree(RS, p, bcon(2));
	} else
		cerror("roundsp");
a426 6

	/* subtract the size from sp */
	sp = block(REG, NIL, NIL, p->n_type, 0, 0);
	sp->n_lval = 0;
	sp->n_rval = SP;
	ecomp(buildtree(MINUSEQ, sp, p));
d436 1
a436 1
        union { float f; double d; long double l; int i[3]; } u;
d457 1
a457 1
                printf("\t.dword 0x%llx\n", (long long)p->n_lval);
d481 1
a481 1
                printf("\t.word 0x%x", (int)p->n_lval);
d493 1
a493 1
                printf("\t.half 0x%x\n", (int)p->n_lval & 0xffff);
d503 2
a504 2
	                printf("\t.word\t0x%x\n", u.i[0]);
			printf("\t.word\t0x%x\n", u.i[1]);
d506 2
a507 2
			printf("\t.word\t0x%x\n", u.i[1]);
	                printf("\t.word\t0x%x\n", u.i[0]);
d615 1
a615 2
	if ((locc == lastloc) || (lastloc == DATA && locc == STRNG) ||
	    (locc == STRNG && lastloc == DATA))
d617 10
a626 2
	lastloc = locc;
	printf("\t.%s\n", loctbl[locc]);
@


1.3
log
@(Large) update from master repo:
> Use structure assignment instead of calling memcpy directly in struct return.
> Rewrite enum handling.
> In C99 enums are treated like INTs so convert them early to int.
> Move the enum tag handling out of defid(), tags are in their own namespace.
> This will be done with struct/union tags also.
> Comment out enum types.
> Remove ENUMTY/MOETY from target code.
@
text
@d1 1
a1 1
/*	$OpenBSD: local.c,v 1.2 2007/11/16 08:34:55 otto Exp $	*/
d34 1
a38 47
#ifdef MIPS_BIGENDIAN
/*
 * If we're big endian, then all OREG loads of a type
 * larger than the destination, must have the
 * offset changed to point to the correct bytes in memory.
 */
static NODE *
offchg(NODE *p)
{
	NODE *l = p->n_left;

	if (p->n_op != SCONV)
		return;

	switch (l->n_type) {
	case SHORT:
	case USHORT:
		if (DEUNSIGN(p->n_type) == CHAR)
			l->n_lval += 1;
		break;
	case LONG:
	case ULONG:
	case INT:
	case UNSIGNED:
		if (DEUNSIGN(p->n_type) == CHAR)
			l->n_lval += 3;
		else if (DEUNSIGNED(p->n_type) == SHORT)
			l->n_lval += 2;
		break;
	case LONGLONG:
	case ULONGLONG:
		if (DEUNSIGN(p->n_type) == CHAR)
			l->n_lval += 7;
		else if (DEUNSIGNED(p->n_type) == SHORT)
			l->n_lval += 6;
		else if (DEUNSIGN(p->n_type) == INT ||
		    DEUNSIGN(p->n_type) == LONG)
			p->n_lval += 4;
	default:
		comperr("offchg: unknown type");
		break;
	}

	return p;
}
#endif

d49 10
a58 2
	int m, ml;
	TWORD t;
d60 1
a60 2
//printf("in:\n");
//fwalk(p, eprint, 0);
d62 26
a87 1
	switch( o = p->n_op ){
d117 1
a117 1
			}
d145 1
a145 1
				t = r->n_type;
d148 2
a149 2
				l->n_type = t;
				l->n_right->n_type = t;
d166 1
a166 1
		ml = p->n_left->n_type;
d168 12
a179 2
		if ((ml == CHAR || ml == UCHAR || ml == SHORT || ml == USHORT)
		    && l->n_op != ICON)
d181 11
a191 1
		l->n_type = p->n_type;
d204 2
a205 1
			return l;
a207 10
#ifdef MIPS_BIGENDIAN
		/*
		 * If we're big endian, then all OREG loads of a type
		 * larger than the destination, must have the
		 * offset changed to point to the correct bytes in memory.
		 */
		if (l->n_type == OREG) 
			p = offchg(p);
#endif

d213 2
a214 1
				if (l->n_op == NAME || l->n_op == UMUL) {
d217 2
a218 1
					return l;
d223 9
a231 2
		if ((p->n_type == INT || p->n_type == UNSIGNED) &&
		    ISPTR(l->n_type)) {
d233 1
a233 1
			return l;
d236 19
a301 5
			return l;
		}
		if (DEUNSIGN(p->n_type) == SHORT &&
		    DEUNSIGN(l->n_type) == SHORT) {
			nfree(p);
d323 2
a324 1
                return(buildtree(o==PMCONV?MUL:DIV, p->n_left, p->n_right));
d335 6
a340 2
//printf("ut:\n");
//fwalk(p, eprint, 0);
d423 1
a423 2
	sp->n_lval = 0;
	sp->n_rval = STKREG;
d427 1
a427 1
	/* add the size to sp */
d430 2
a431 2
	sp->n_rval = STKREG;
	ecomp(buildtree(PLUSEQ, sp, p));
d445 1
a445 1
        int i;
d464 2
a465 2
                i = (p->n_lval >> 32);
                p->n_lval &= 0xffffffff;
d467 11
a477 3
                ninval(off, 32, p);
                p->n_lval = i;
                ninval(off+32, 32, p);
a504 4
                u.i[2] = 0;
                u.l = (long double)p->n_dcon;
                printf("\t.word\t0x%x,0x%x,0x%x\n", u.i[0], u.i[1], u.i[2]);
                break;
d507 7
a513 2
                printf("\t.word\t0x%x\n", u.i[0]);
                printf("\t.word\t0x%x\n", u.i[1]);
d581 1
a581 1
	printf("	.comm %s,0%o\n", gcc_findname(q), off);
d583 1
a583 1
	printf("	.comm %s,0%o\n", exname(q->sname), off);
d597 1
a597 1
		printf("\t.lcomm %s,0%o\n", gcc_findname(q), off);
d599 1
a599 1
		printf("\t.lcomm %s,0%o\n", exname(q->sname), off);
d602 1
a602 1
		printf("\t.lcomm " LABFMT ",0%o\n", q->soffset, off);
d614 2
a615 1
static char *loctbl[] = { "text", "data", "bss", "data" };
d620 2
a621 2
	//printf("setloc1(%d)\n", locc);
	if ((locc == lastloc) || (lastloc == DATA && locc == STRNG) || (locc == STRNG || lastloc == DATA))
d679 142
@


1.2
log
@sync with repe; commit from gmcgarry@@:

Bring MIPS support fully up-to-date.  Includes the following changes:

Support use of different assemblers.
Handle big-endian and little-endian code generation.
Start support for n32/n64
PIC code generation
Update to arguments-in-registers infrastructure.
Cleanup handling of branches.
Fix register coloring
Fix structure assignment.
Add longlong instructions
Remove unused functions.
Indentation fixes.

Tested on NetBSD/pmax (little endian).
@
text
@d1 1
a1 1
/*	$OpenBSD: local.c,v 1.3 2007/11/16 00:17:40 gmcgarry Exp $	*/
a253 2
			case ENUMTY:
			case MOETY:
@


1.1
log
@reorg pcc tree; requested by and ok deraadt@@; ok ragge@@
@
text
@d1 1
a1 1
/*	$OpenBSD: local.c,v 1.2 2007/09/15 22:04:38 ray Exp $	*/
d34 1
a34 1
# include "pass1.h"
d36 1
a36 1
/*	this file contains code which is dependent on the target machine */
d38 51
d92 4
a95 16
	/* this is called to do local transformations on
	   an expression tree preparitory to its being
	   written out in intermediate code.
	*/

	/* the major essential job is rewriting the
	   automatic variables and arguments in terms of
	   REG and OREG nodes */
	/* conversion ops which are not necessary are also clobbered here */
	/* in addition, any special features (such as rewriting
	   exclusive or) are easily handled here as well */

	register struct symtab *q;
	register NODE *r, *l;
	register int o;
	register int m, ml;
d100 1
d114 1
a114 1
			r->n_rval = FPREG;
d201 10
a223 1
#if 0
a228 1
#endif
d311 2
a312 3
		p->n_left = block(REG, NIL, NIL, p->n_type, 0,
				  MKSUE(INT));
		p->n_left->n_rval = RETREG;
d315 1
a318 1

a358 2
 * For pdp10, return the type-specific index number which calculation
 * is based on its size. For example, short a[3] would return 3.
d365 1
a365 1
	register NODE *p;
d371 2
a372 3
	p = bcon(0);
	p->n_lval = off/SZCHAR;	/* Default */
	return(p);
d417 1
a417 1
ninval(NODE *p)
d419 6
a424 2
	struct symtab *q;
	TWORD t;
d426 65
a490 54
	p = p->n_left;
	t = p->n_type;
	if (t > BTMASK)
		t = INT; /* pointer */

	switch (t) {
	case LONGLONG:
	case ULONGLONG:
		inval(p->n_lval & 0xffffffff);
		inval(p->n_lval >> 32);
		break;
	case INT:
	case UNSIGNED:
		printf("\t.long 0x%x", (int)p->n_lval);
		if ((q = p->n_sp) != NULL) {
			if ((q->sclass == STATIC && q->slevel > 0) ||
			    q->sclass == ILABEL) {
				printf("+" LABFMT, q->soffset);
			} else
				printf("+%s", exname(q->sname));
		}
		printf("\n");
		break;
	default:
		cerror("ninval");
	}
}

/*
 * print out an integer.
 */
void
inval(CONSZ word)
{
	word &= 0xffffffff;
	printf("	.long 0x%llx\n", word);
}

/* output code to initialize a floating point value */
/* the proper alignment has been obtained */
void
finval(NODE *p)
{
	switch (p->n_type) {
	case LDOUBLE:
		printf("\t.tfloat\t0t%.20Le\n", p->n_dcon);
		break;
	case DOUBLE:
		printf("\t.dfloat\t0d%.20e\n", (double)p->n_dcon);
		break;
	case FLOAT:
		printf("\t.ffloat\t0f%.20e\n", (float)p->n_dcon);
		break;
	}
d566 1
a566 1
		printf("	.lcomm %s,0%o\n", gcc_findname(q), off);
d568 1
a568 1
		printf("	.lcomm %s,0%o\n", exname(q->sname), off);
d571 1
a571 1
		printf("	.lcomm " LABFMT ",0%o\n", q->soffset, off);
d583 1
a583 1
static char *loctbl[] = { "text", "data", "section .rodata", "section .rodata" };
d588 2
a589 1
	if (locc == lastloc)
d592 55
a646 1
	printf("	.%s\n", loctbl[locc]);
@

