head	1.7;
access;
symbols
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.14
	OPENBSD_5_0:1.6.0.12
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.10
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.8
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5;
locks; strict;
comment	@ * @;


1.7
date	2012.04.12.11.51.13;	author pirofti;	state dead;
branches;
next	1.6;

1.6
date	2008.08.17.18.40.13;	author ragge;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.12.17.30.42;	author ragge;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.17.12.00.37;	author ragge;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.29.16.38.55;	author ragge;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.27.14.19.18;	author ragge;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.07.17.58.52;	author otto;	state Exp;
branches;
next	;


desc
@@


1.7
log
@tedu(tm) pcc.

Message sent. Okay deraadt@@.
@
text
@/*	$OpenBSD: local.c,v 1.6 2008/08/17 18:40:13 ragge Exp $	*/
/*
 * Copyright(C) Caldera International Inc. 2001-2002. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code and documentation must retain the above
 * copyright notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditionsand the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed or owned by Caldera
 *	International, Inc.
 * Neither the name of Caldera International, Inc. nor the names of other
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
 * INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.	IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE
 * FOR ANY DIRECT, INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OFLIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */

# include "pass1.h"

/*	this file contains code which is dependent on the target machine */

#if 0
NODE *
cast( p, t ) register NODE *p; TWORD t; {
	/* cast node p to type t */

	p = buildtree( CAST, block( NAME, NIL, NIL, t, 0, (int)t ), p );
	p->left->op = FREE;
	p->op = FREE;
	return( p->right );
	}
#endif

NODE *
clocal(p) NODE *p; {

	/* this is called to do local transformations on
	   an expression tree preparitory to its being
	   written out in intermediate code.
	*/

	/* the major essential job is rewriting the
	   automatic variables and arguments in terms of
	   REG and OREG nodes */
	/* conversion ops which are not necessary are also clobbered here */
	/* in addition, any special features (such as rewriting
	   exclusive or) are easily handled here as well */

	register struct symtab *q;
	register NODE *r;
	register int o;
	register int m, ml;

	switch( o = p->n_op ){

	case NAME:
		if((q = p->n_sp) == 0 ) { /* already processed; ignore... */
			return(p);
			}
		switch( q->sclass ){

		case AUTO:
		case PARAM:
			/* fake up a structure reference */
			r = block( REG, NIL, NIL, PTR+STRTY, 0, 0 );
			r->n_lval = 0;
			r->n_rval = (q->sclass==AUTO?STKREG:ARGREG);
			p = stref( block( STREF, r, p, 0, 0, 0 ) );
			break;

		case STATIC:
			if( q->slevel == 0 ) break;
			p->n_lval = 0;
			p->n_rval = -q->soffset;
			break;

		case REGISTER:
			p->n_op = REG;
			p->n_lval = 0;
			p->n_rval = q->soffset;
			break;

			}
		break;

	case PCONV:
		/* do pointer conversions for char and longs */
		ml = p->n_left->n_type;
		if( ( ml==CHAR || ml==UCHAR || ml==SHORT || ml==USHORT ) && p->n_left->n_op != ICON ) break;

		/* pointers all have the same representation; the type is inherited */

	inherit:
		p->n_left->n_type = p->n_type;
		p->n_left->n_df = p->n_df;
		p->n_left->n_sue = p->n_sue;
		r = p->n_left;
		nfree(p);
		return( r );

	case SCONV:
		m = (p->n_type == FLOAT || p->n_type == DOUBLE );
		ml = (p->n_left->n_type == FLOAT || p->n_left->n_type == DOUBLE );
		if( m != ml ) break;

		/* now, look for conversions downwards */

		m = p->n_type;
		ml = p->n_left->n_type;
		if( p->n_left->n_op == ICON ){ /* simulate the conversion here */
			CONSZ val;
			val = p->n_left->n_lval;
			switch( m ){
			case CHAR:
				p->n_left->n_lval = (char) val;
				break;
			case UCHAR:
				p->n_left->n_lval = val & 0XFF;
				break;
			case USHORT:
				p->n_left->n_lval = val & 0XFFFFL;
				break;
			case SHORT:
				p->n_left->n_lval = (short)val;
				break;
			case UNSIGNED:
				p->n_left->n_lval = val & 0xFFFFFFFFL;
				break;
			case INT:
				p->n_left->n_lval = (int)val;
				break;
				}
			p->n_left->n_type = m;
			}
		else {
			/* meaningful ones are conversion of int to char, int to short,
			   and short to char, and unsigned version of them */
			if( m==CHAR || m==UCHAR ){
				if( ml!=CHAR && ml!= UCHAR ) break;
				}
			else if( m==SHORT || m==USHORT ){
				if( ml!=CHAR && ml!=UCHAR && ml!=SHORT && ml!=USHORT ) break;
				}
			}

		/* clobber conversion */
		if( tlen(p) == tlen(p->n_left) ) goto inherit;
		r = p->n_left;
		nfree(p);
		return( r );  /* conversion gets clobbered */

	case PVCONV:
	case PMCONV:
		if( p->n_right->n_op != ICON ) cerror( "bad conversion", 0);
		r = buildtree( o==PMCONV?MUL:DIV, p->n_left, p->n_right);
		nfree(p);
		return r;

	case RS:
	case RSEQ:
		/* convert >> to << with negative shift count */
		/* only if type of left operand is not unsigned */
		if( ISUNSIGNED(p->n_left->n_type) ) break;
		p->n_right = buildtree( UMINUS, p->n_right, NIL );
		if( p->n_op == RS ) p->n_op = LS;
		else p->n_op = LSEQ;
		break;

	case FORCE:
		p->n_op = ASSIGN;
		p->n_right = p->n_left;
		p->n_left = block(REG, NIL, NIL, p->n_type, 0, MKSUE(INT));
		p->n_left->n_rval = p->n_left->n_type == BOOL ? 
		    RETREG(CHAR) : RETREG(p->n_type);
		break;

	case STCALL:
	case CALL:
		/* Fix function call arguments. On vax, just add funarg */
		for (r = p->n_right; r->n_op == CM; r = r->n_left) {
			if (r->n_right->n_op != STARG &&
			    r->n_right->n_op != FUNARG)
				r->n_right = block(FUNARG, r->n_right, NIL, 
				    r->n_right->n_type, r->n_right->n_df,
				    r->n_right->n_sue);
		}
		if (r->n_op != STARG && r->n_op != FUNARG) {
			NODE *l = talloc();
			*l = *r;
			r->n_op = FUNARG; r->n_left = l; r->n_type = l->n_type;
		}
		break;
	}

	return(p);
}

void
myp2tree(NODE *p)
{
	int o = p->n_op, i;

	if (o != FCON) 
		return;

	/* Write float constants to memory */
	/* Should be volontary per architecture */
 
	setloc1(RDATA);
	defalign(p->n_type == FLOAT ? ALFLOAT : p->n_type == DOUBLE ?
	    ALDOUBLE : ALLDOUBLE );
	deflab1(i = getlab()); 
	ninval(0, btdims[p->n_type].suesize, p);
	p->n_op = NAME;
	p->n_lval = 0;	
	p->n_sp = tmpalloc(sizeof(struct symtab_hdr));
	p->n_sp->sclass = ILABEL;
	p->n_sp->soffset = i;
	p->n_sp->sflags = 0;

}

/*
 * Can we take & of a NAME?
 */
int
andable(NODE *p)
{

	if ((p->n_type & ~BTMASK) == FTN)
		return 1; /* functions are called by name */
	return 0; /* Delay name reference to table, for PIC code generation */
}
 
void
cendarg(){ /* at the end of the arguments of a ftn, set the automatic offset */
	autooff = AUTOINIT;
	}

int
cisreg( t ) TWORD t; { /* is an automatic variable of type t OK for a register variable */
	return(1);	/* all are now */
	}

NODE *
offcon(OFFSZ off, TWORD t, union dimfun *d, struct suedef *sue)
{

	/* return a node, for structure references, which is suitable for
	   being added to a pointer of type t, in order to be off bits offset
	   into a structure */

	register NODE *p;

	/* t, d, and s are the type, dimension offset, and sizeoffset */
	/* in general they  are necessary for offcon, but not on H'well */

	p = bcon(0);
	p->n_lval = off/SZCHAR;
	return(p);

	}

void
spalloc(NODE *t, NODE *p, OFFSZ off)
{
	cerror("spalloc");
}

static int inbits, inval;

/*
 * set fsz bits in sequence to zero.
 */
void
zbits(OFFSZ off, int fsz)
{
	int m;

	if (idebug)
		printf("zbits off %lld, fsz %d inbits %d\n", off, fsz, inbits);
	if ((m = (inbits % SZCHAR))) {
		m = SZCHAR - m;
		if (fsz < m) {
			inbits += fsz;
			return;
		} else {
			fsz -= m;
			printf("\t.byte %d\n", inval);
			inval = inbits = 0;
		}
	}
	if (fsz >= SZCHAR) {
		printf("\t.space %d\n", fsz/SZCHAR);
		fsz -= (fsz/SZCHAR) * SZCHAR;
	}
	if (fsz) {
		inval = 0;
		inbits = fsz;
	}
}

/*
 * Initialize a bitfield.
 */
void
infld(CONSZ off, int fsz, CONSZ val)
{
	if (idebug)
		printf("infld off %lld, fsz %d, val %lld inbits %d\n",
		    off, fsz, val, inbits);
	val &= ((CONSZ)1 << fsz)-1;
	while (fsz + inbits >= SZCHAR) {
		inval |= (val << inbits);
		printf("\t.byte %d\n", inval & 255);
		fsz -= (SZCHAR - inbits);
		val >>= (SZCHAR - inbits);
		inval = inbits = 0;
	}
	if (fsz) {
		inval |= (val << inbits);
		inbits += fsz;
	}
}


char *
exname( p ) char *p; {
	/* make a name look like an external name in the local machine */
	/* vad is elf now */
	if (p == NULL)
		return "";
	return( p );
	}

TWORD
ctype(TWORD type ){ /* map types which are not defined on the local machine */
	switch( BTYPE(type) ){

	case LONG:
		MODTYPE(type,INT);
		break;

	case ULONG:
		MODTYPE(type,UNSIGNED);
		break;

	case LDOUBLE:	/* for now */
		MODTYPE(type,DOUBLE);
		}
	return( type );
	}

void
calldec(NODE *p, NODE *q) 
{
}

void
extdec(struct symtab *q)
{
}

void
commdec( struct symtab *q ){ /* make a common declaration for id, if reasonable */
	OFFSZ off;

	printf( "	.comm	%s,", exname( q->soname ) );
	off = tsize( q->stype, q->sdf, q->ssue );
	printf( CONFMT, off/SZCHAR );
	printf( "\n" );
	}

/* make a local common declaration for id, if reasonable */
void
lcommdec(struct symtab *q)
{
	int off;

	off = tsize(q->stype, q->sdf, q->ssue);
	off = (off+(SZCHAR-1))/SZCHAR;
	if (q->slevel == 0)
		printf("	.lcomm %s,0%o\n", exname(q->soname), off);
	else
		printf("	.lcomm " LABFMT ",0%o\n", q->soffset, off);
}


static char *loctbl[] = { "text", "data", "section .rodata", "section .rodata" };

void
setloc1(int locc)
{
	if (locc == lastloc)
		return;
	lastloc = locc;
	printf("	.%s\n", loctbl[locc]);
}

/*
 * print out a constant node, may be associated with a label.
 * Do not free the node after use.
 * off is bit offset from the beginning of the aggregate
 * fsz is the number of bits this is referring to
 * XXX - floating point constants may be wrong if cross-compiling.
 */
void
ninval(CONSZ off, int fsz, NODE *p)
{
	union { float f; double d; long double l; int i[3]; } u;
	struct symtab *q;
	TWORD t;

	t = p->n_type;
	if (t > BTMASK)
		t = INT; /* pointer */

	if (p->n_op != ICON && p->n_op != FCON)
		cerror("ninval: init node not constant");

	if (p->n_op == ICON && p->n_sp != NULL && DEUNSIGN(t) != INT)
		uerror("element not constant");

	switch (t) {
	case LONGLONG:
	case ULONGLONG:
		printf("\t.long 0x%x", (int)p->n_lval);
		printf("\t.long 0x%x", (int)(p->n_lval >> 32));
		break;
	case INT:
	case UNSIGNED:
		printf("\t.long 0x%x", (int)p->n_lval);
		if ((q = p->n_sp) != NULL) {
			if ((q->sclass == STATIC && q->slevel > 0) ||
			    q->sclass == ILABEL) {
				printf("+" LABFMT, q->soffset);
			} else
				printf("+%s", exname(q->soname));
		}
		printf("\n");
		break;
	case SHORT:
	case USHORT:
		printf("\t.short 0x%x\n", (int)p->n_lval & 0xffff);
		break;
	case BOOL:
		if (p->n_lval > 1)
			p->n_lval = p->n_lval != 0;
		/* FALLTHROUGH */
	case CHAR:
	case UCHAR:
		printf("\t.byte %d\n", (int)p->n_lval & 0xff);
		break;
	case LDOUBLE:
		u.i[2] = 0;
		u.l = (long double)p->n_dcon;
		printf("\t.long\t0x%x,0x%x,0x%x\n", u.i[0], u.i[1], u.i[2]);
		break;
	case DOUBLE:
		u.d = (double)p->n_dcon;
		printf("\t.long\t0x%x,0x%x\n", u.i[0], u.i[1]);
		break;
	case FLOAT:
		u.f = (float)p->n_dcon;
		printf("\t.long\t0x%x\n", u.i[0]);
		break;
	default:
		cerror("ninval");
	}

}
/*
 * Give target the opportunity of handling pragmas.
 */
int
mypragma(char **ary)
{
	return 0; }

/*
 * Called when a identifier has been declared, to give target last word.
 */
void
fixdef(struct symtab *sp)
{
}

void
pass1_lastchance(struct interpass *ip)
{
}
@


1.6
log
@Updates from master repo.  Can now compile both userland and kernel.
(with some patches...)
@
text
@d1 1
a1 1
/*	$OpenBSD: local.c,v 1.5 2008/01/12 17:30:42 ragge Exp $	*/
@


1.5
log
@Updates from master repo.
@
text
@d1 1
a1 1
/*	$OpenBSD: local.c,v 1.4 2007/11/17 12:00:37 ragge Exp $	*/
d506 4
@


1.4
log
@Updates from master repo:
Replace ugly target macros with function calls (gmcgarry).
@
text
@d1 1
a1 1
/*	$OpenBSD: local.c,v 1.3 2007/10/29 16:38:55 ragge Exp $	*/
d219 20
d386 1
a386 1
	printf( "	.comm	%s,", exname( q->sname ) );
d401 1
a401 5
#ifdef GCC_COMPAT
		printf("	.lcomm %s,0%o\n", gcc_findname(q), off);
#else
		printf("	.lcomm %s,0%o\n", exname(q->sname), off);
#endif
d456 1
a456 1
				printf("+%s", exname(q->sname));
d490 16
@


1.3
log
@From master repo:
> calls argument numbers are in registers, not bytes.
> If a jump is to the return label, emit ret insn instead.
> Add ADDROF table entry.
> Remove some unused entries.
> Do a Z call for emitted GOTOs.
> Only create constants for function names, they are called by name anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: local.c,v 1.2 2007/10/27 14:19:18 ragge Exp $	*/
d214 5
@


1.2
log
@Sync with master repo: At least compiles now.
@
text
@d1 1
a1 1
/*	$OpenBSD: local.c,v 1.1 2007/10/07 17:58:52 otto Exp $	*/
d216 3
d220 7
a226 3
andable( p ) NODE *p; {
	return(1);  /* all names can have & taken on them */
	}
@


1.1
log
@reorg pcc tree; requested by and ok deraadt@@; ok ragge@@
@
text
@d1 1
a1 1
/*	$OpenBSD: local.c,v 1.2 2007/09/15 22:04:38 ray Exp $	*/
d16 1
a16 1
 * 	This product includes software developed or owned by Caldera
d26 1
a26 1
 * DISCLAIMED.  IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE
d36 1
a36 1
# include "mfile1"
d40 1
d50 1
d69 2
a70 2
	register o;
	register m, ml;
d72 1
a72 1
	switch( o = p->op ){
d75 1
a75 1
		if( p->rval < 0 ) { /* already processed; ignore... */
a77 1
		q = &stab[p->rval];
d84 2
a85 2
			r->lval = 0;
			r->rval = (q->sclass==AUTO?STKREG:ARGREG);
a88 2
		case ULABEL:
		case LABEL:
d91 2
a92 2
			p->lval = 0;
			p->rval = -q->offset;
d96 3
a98 3
			p->op = REG;
			p->lval = 0;
			p->rval = q->offset;
d106 2
a107 2
		ml = p->left->type;
		if( ( ml==CHAR || ml==UCHAR || ml==SHORT || ml==USHORT ) && p->left->op != ICON ) break;
d112 6
a117 5
		p->left->type = p->type;
		p->left->cdim = p->cdim;
		p->left->csiz = p->csiz;
		p->op = FREE;
		return( p->left );
d120 2
a121 2
		m = (p->type == FLOAT || p->type == DOUBLE );
		ml = (p->left->type == FLOAT || p->left->type == DOUBLE );
d126 3
a128 3
		m = p->type;
		ml = p->left->type;
		if( p->left->op == ICON ){ /* simulate the conversion here */
d130 1
a130 1
			val = p->left->lval;
d133 1
a133 1
				p->left->lval = (char) val;
d136 1
a136 1
				p->left->lval = val & 0XFF;
d139 1
a139 1
				p->left->lval = val & 0XFFFFL;
d142 1
a142 1
				p->left->lval = (short)val;
d145 1
a145 1
				p->left->lval = val & 0xFFFFFFFFL;
d148 1
a148 1
				p->left->lval = (int)val;
d151 1
a151 1
			p->left->type = m;
d165 4
a168 3
		if( tlen(p) == tlen(p->left) ) goto inherit;
		p->op = FREE;
		return( p->left );  /* conversion gets clobbered */
d172 4
a175 3
		if( p->right->op != ICON ) cerror( "bad conversion", 0);
		p->op = FREE;
		return( buildtree( o==PMCONV?MUL:DIV, p->left, p->right ) );
d178 1
a178 1
	case ASG RS:
d181 12
a192 4
		if( ISUNSIGNED(p->left->type) ) break;
		p->right = buildtree( UNARY MINUS, p->right, NIL );
		if( p->op == RS ) p->op = LS;
		else p->op = ASG LS;
d195 14
d210 2
d214 1
a214 1
	}
d216 1
d220 2
a221 1

d226 1
d228 1
a228 5

	if( t==INT || t==UNSIGNED || t==LONG || t==ULONG	/* tbl */
		|| t==CHAR || t==UCHAR || t==SHORT || t==USHORT	/* tbl */
		|| ISPTR(t)) return(1);			/* tbl */
	return(0);
d232 2
a233 1
offcon( off, t, d, s ) OFFSZ off; TWORD t; {
d245 1
a245 1
	p->lval = off/SZCHAR;
d250 5
d256 1
a256 1
incode( p, sz ) register NODE *p; {
d258 7
a264 14
	/* generate initialization code for assigning a constant c
		to a field of width sz */
	/* we assume that the proper alignment has been obtained */
	/* inoff is updated to have the proper final value */
	/* we also assume sz  < SZINT */

	inoff += sz;
	if (sz>SZSHORT) 
		printf("	.long	%d:%d\n", sz, p->lval);
	else if (sz>SZCHAR)
		printf("	.word	%d:%d\n", sz, p->lval);
	else
		printf("	.byte	%d:%d\n", sz, p->lval);
	}
d266 12
a277 10
fincode( d, sz ) double d; {
	/* output code to initialize space of size sz to the value d */
	/* the proper alignment has been obtained */
	/* inoff is updated to have the proper final value */
	/* on the target machine, write it out in octal! */


	printf("	%s	0%c%.20e\n", sz == SZDOUBLE ? ".double" : ".float",
		sz == SZDOUBLE ? 'd' : 'f', d);
	inoff += sz;
d279 7
a285 8

cinit( p, sz ) NODE *p; {
	/* arrange for the initialization of p into a space of
	size sz */
	/* the proper alignment has been opbtained */
	/* inoff is updated to have the proper final value */
	ecode( p );
	inoff += sz;
d287 1
d289 20
a308 12
vfdzero( n ){ /* define n bits of zeros in a vfd */
	register i;

	if( n <= 0 ) return;

	inoff += n;
	i = n;
	while (i>=SZCHAR) {
		printf("	.byte	0\n");
		i -= SZCHAR;
	}
	if (i) printf("	.byte	%d:0\n", i);
d310 1
d316 4
a319 14

	static char text[NCHNAM+1];

	register i;

	text[0] = '_';
	for( i=1; *p&&i<NCHNAM; ++i ){
		text[i] = *p++;
		}

	text[i] = '\0';
	text[NCHNAM] = '\0';  /* truncate */

	return( text );
d322 2
a323 1
ctype( type ){ /* map types which are not defined on the local machine */
d332 4
d340 4
a343 3
noinit( t ) { /* curid is a variable which is defined but
	is not initialized (and not a function );
	This routine returns the stroage class for an uninitialized declaration */
d345 4
a348 1
	return(EXTERN);
d350 3
a352 5
	}

commdec( id ){ /* make a common declaration for id, if reasonable */
	register struct symtab *q;
	OFFSZ off, tsize();
a353 1
	q = &stab[id];
d355 1
a355 1
	off = tsize( q->stype, q->dimoff, q->sizoff );
d360 5
a364 2
isitlong( cb, ce ){ /* is lastcon to be long or short */
	/* cb is the first character of the representation, ce the last */
d366 11
a376 4
	if( ce == 'l' || ce == 'L' ||
		lastcon >= (1L << (SZINT-1) ) ) return (1);
	return(0);
	}
d379 1
a379 5
isitfloat( s ) char *s; {
	double atof();
	dcon = atof(s);
	return( FCON );
	}
d381 8
a388 1
ecode( p ) NODE *p; {
d390 39
a428 51
	/* walk the tree and write out the nodes.. */

	if( nerrors ) return;
	p2tree( p );
	p2compile( p );
	}
	
#include "a.out.h"
int ddebug;
int gdebug;


outstab(p)
struct symtab *p; {
	register TWORD ptype;
	register char *pname;
	register char pclass;
	register int poffset;

	if (!gdebug) return;

	ptype = p->stype;
	pname = p->sname;
	pclass = p->sclass;
	poffset = p->offset;

	if (ISFTN(ptype)) {
		return;
	}
	
	switch (pclass) {
	
	case AUTO:
		pstab(pname, N_LSYM);
		printf("0,%d,%d\n", ptype, (-poffset)/SZCHAR);
		poffs(p);
		return;
	
	case EXTDEF:
	case EXTERN:
		pstab(pname, N_GSYM);
		printf("0,%d,0\n", ptype);
		poffs(p);
		return;
			
	case STATIC:
		pstab(pname, N_STSYM);
		if (p->slevel > 1) {
			printf("0,%d,L%d\n", ptype, poffset);
		} else {
			printf("0,%d,%s\n", ptype, exname(pname));
d430 27
a456 20
		poffs(p);
		return;
	
	case REGISTER:
		pstab(pname, N_RSYM);
		printf("0,%d,%d\n", ptype, poffset);
		poffs(p);
		return;
	
	case MOS:
	case MOU:
		pstab(pname, N_SSYM);
		printf("0,%d,%d\n", ptype, poffset/SZCHAR);
		poffs(p);
		return;
	
	case PARAM:
		/* parameter stab entries are processed in dclargs() */
		return;
	
d458 1
a458 24
		if (ddebug) printf("	No .stab for %.8s\n", pname);
	}
}

pstab(name, type)
char *name;
int type; {
	register int i;
	register char c;
	if (!gdebug) return;
	printf("	.stab	");
	for(i=0; i<8; i++) 
		if (c = name[i]) printf("'%c,", c);
		else printf("0,");
	printf("0%o,", type);
}

poffs(p)
register struct symtab *p; {
	int s;
	if (!gdebug) return;
	if ((s = dimtab[p->sizoff]/SZCHAR) > 1) {
		pstab(p->sname, N_LENG);
		printf("1,0,%d\n", s);
a459 36
}

char NULLNAME[8];
int  labelno;
int  fdefflag;

psline() {
	static int lastlineno;
	register char *cp, *cq;
	register int i;
	
	if (!gdebug) return;

	cq = ititle;
	cp = ftitle;

	while ( *cq ) if ( *cp++ != *cq++ ) goto neq;
	if ( *cp == '\0' ) goto eq;
	
neq:	for (i=0; i<100; i++)
		ititle[i] = '\0';
	cp = ftitle;
	cq = ititle;
	while ( *cp )  
		*cq++ = *cp++;
	*cq = '\0';
	*--cq = '\0';
	for ( cp = ititle+1; *(cp-1); cp += 8 ) {
		pstab(cp, N_SOL);
		if (gdebug) printf("0,0,LL%d\n", labelno);
		}
	*cq = '"';
	printf("LL%d:\n", labelno++);

eq:	if (lineno == lastlineno) return;
	lastlineno = lineno;
a460 26
	if (fdefflag) {
		pstab(NULLNAME, N_SLINE);
		printf("0,%d,LL%d\n", lineno, labelno);
		printf("LL%d:\n", labelno++);
		}
	}
	
plcstab(level) {
	if (!gdebug) return;
	pstab(NULLNAME, N_LBRAC);
	printf("0,%d,LL%d\n", level, labelno);
	printf("LL%d:\n", labelno++);
	}
	
prcstab(level) {
	if (!gdebug) return;
	pstab(NULLNAME, N_RBRAC);
	printf("0,%d,LL%d\n", level, labelno);
	printf("LL%d:\n", labelno++);
	}
	
pfstab(sname) 
char *sname; {
	if (!gdebug) return;
	pstab(sname, N_FUN);
	printf("0,%d,_%.7s\n", lineno, sname);
a461 21

#ifndef ONEPASS
tlen(p) NODE *p; 
{
	switch(p->type) {
		case CHAR:
		case UCHAR:
			return(1);
			
		case SHORT:
		case USHORT:
			return(2);
			
		case DOUBLE:
			return(8);
			
		default:
			return(4);
		}
	}
#endif
@

