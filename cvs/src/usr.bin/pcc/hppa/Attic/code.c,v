head	1.5;
access;
symbols
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.16
	OPENBSD_5_0:1.4.0.14
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.12
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.10
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.6
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.8
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.4
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3;
locks; strict;
comment	@ * @;


1.5
date	2012.04.12.11.51.12;	author pirofti;	state dead;
branches;
next	1.4;

1.4
date	2008.04.11.20.45.52;	author stefan;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.19.20.19.54;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.22.15.06.43;	author stefan;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.16.08.36.23;	author otto;	state Exp;
branches;
next	;


desc
@@


1.5
log
@tedu(tm) pcc.

Message sent. Okay deraadt@@.
@
text
@/*	$OpenBSD: code.c,v 1.4 2008/04/11 20:45:52 stefan Exp $	*/

/*
 * Copyright (c) 2007 Michael Shalayeff
 * Copyright (c) 2003 Anders Magnusson (ragge@@ludd.luth.se).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


# include "pass1.h"

NODE *funarg(NODE *, int *);
int argreg(TWORD, int *);

/*
 * Define everything needed to print out some data (or text).
 * This means segment, alignment, visibility, etc.
 */
void
defloc(struct symtab *sp)
{
	extern char *nextsect;
	static char *loctbl[] = { "text", "data", "section .rodata" };
	static int lastloc = -1;
	TWORD t;
	int s;

	if (sp == NULL) {
		lastloc = -1;
		return;
	}
	t = sp->stype;
	s = ISFTN(t) ? PROG : ISCON(cqual(t, sp->squal)) ? RDATA : DATA;
	if (nextsect) {
		printf("\t.section %s\n", nextsect);
		nextsect = NULL;
		s = -1;
	} else if (s != lastloc)
		printf("\t.%s\n", loctbl[s]);
	lastloc = s;
	while (ISARY(t))
		t = DECREF(t);
	if (t > UCHAR)
		printf("\t.align\t%d\n", ISFTN(t)? 4 : talign(t, sp->ssue));
	if (sp->sclass == EXTDEF)
		printf("\t.export %s, data\n", sp->soname);
	if (sp->slevel == 0)
		printf("\t.label %s\n", sp->soname);
	else
		printf("\t.label\t" LABFMT "\n", sp->soffset);
}

/*
 * code for the end of a function
 * deals with struct return here
 */
void
efcode()
{
	NODE *p, *q;
	int sz;

	if (cftnsp->stype != STRTY+FTN && cftnsp->stype != UNIONTY+FTN)
		return;
	/* address of return struct is in eax */
	/* create a call to memcpy() */
	/* will get the result in %ret0 */
	p = block(REG, NIL, NIL, CHAR+PTR, 0, MKSUE(CHAR+PTR));
	p->n_rval = RET0;
	q = block(OREG, NIL, NIL, CHAR+PTR, 0, MKSUE(CHAR+PTR));
	q->n_rval = FP;
	q->n_lval = 8; /* return buffer offset */
	p = block(CM, q, p, INT, 0, MKSUE(INT));
	sz = (tsize(STRTY, cftnsp->sdf, cftnsp->ssue)+SZCHAR-1)/SZCHAR;
	p = block(CM, p, bcon(sz), INT, 0, MKSUE(INT));
	p->n_right->n_name = "";
	p = block(CALL, bcon(0), p, CHAR+PTR, 0, MKSUE(CHAR+PTR));
	p->n_left->n_name = "memcpy";
	p = clocal(p);
	send_passt(IP_NODE, p);
}

int
argreg(TWORD t, int *n)
{
	switch (t) {
	case FLOAT:
		return FR7L - 2 * (*n)++;
	case DOUBLE:
	case LDOUBLE:
		*n += 2;
		return FR6 - *n - 2;
	case LONGLONG:
	case ULONGLONG:
		*n += 2;
		return AD1 - (*n - 2) / 2;
	default:
		return ARG0 - (*n)++;
	}
}

/*
 * code for the beginning of a function; 'a' is an array of
 * indices in symtab for the arguments; n is the number
 */
void
bfcode(struct symtab **a, int cnt)
{
	struct symtab *sp;
	NODE *p, *q;
	int i, n, sz;

	if (cftnsp->stype == STRTY+FTN || cftnsp->stype == UNIONTY+FTN) {
	/* Function returns struct, adjust arg offset */
	for (i = 0; i < n; i++)
		a[i]->soffset += SZPOINT(INT);
	}

	/* recalculate the arg offset and create TEMP moves */
	for (n = 0, i = 0; i < cnt; i++) {
		sp = a[i];

		sz = szty(sp->stype);
		if (n % sz)
			n++;	/* XXX LDOUBLE */

		if (n < 4) {
			p = tempnode(0, sp->stype, sp->sdf, sp->ssue);
			/* TODO p->n_left->n_lval = -(32 + n * 4); */
			q = block(REG, NIL, NIL, sp->stype, sp->sdf, sp->ssue);
			q->n_rval = argreg(sp->stype, &n);
			p = buildtree(ASSIGN, p, q);
			sp->soffset = regno(p->n_left);
			sp->sflags |= STNODE;
			ecomp(p);
		} else {
			sp->soffset += SZINT * n;
			if (xtemps) {
				/* put stack args in temps if optimizing */
				p = tempnode(0, sp->stype, sp->sdf, sp->ssue);
				p = buildtree(ASSIGN, p, buildtree(NAME, 0, 0));
				sp->soffset = regno(p->n_left);
				sp->sflags |= STNODE;
				ecomp(p);
			}
		}
	}
}


/*
 * by now, the automatics and register variables are allocated
 */
void
bccode()
{
	SETOFF(autooff, SZINT);
}

/* called just before final exit */
/* flag is 1 if errors, 0 if none */
void
ejobcode(int errors)
{
	if (errors)
		return;

	printf("\t.end\n");
}

void
bjobcode(void)
{
	printf("\t.import $global$, data\n");
}

/*
 * return the alignment of field of type t
 */
int
fldal(unsigned int t)
{
	uerror("illegal field type");
	return(ALINT);
}

/* fix up type of field p */
void
fldty(struct symtab *p)
{
}

/*
 * XXX - fix genswitch.
 */
int
mygenswitch(int num, TWORD type, struct swents **p, int n)
{
	return 0;
}

NODE *
funarg(NODE *p, int *n)
{
	NODE *r;
	int sz;

	if (p->n_op == CM) {
		p->n_left = funarg(p->n_left, n);
		p->n_right = funarg(p->n_right, n);
		return p;
	}

	sz = szty(p->n_type);
	if (*n % sz)
		(*n)++;	/* XXX LDOUBLE */

	if (*n >= 4) {
		*n += sz;
		r = block(OREG, NIL, NIL, p->n_type|PTR, 0,
		    MKSUE(p->n_type|PTR));
		r->n_rval = SP;
		r->n_lval = -(32 + *n * 4);
	} else {
		r = block(REG, NIL, NIL, p->n_type, 0, 0);
		r->n_lval = 0;
		r->n_rval = argreg(p->n_type, n);
	}
	p = block(ASSIGN, r, p, p->n_type, 0, 0);
	clocal(p);

	return p;
}

/*
 * Called with a function call with arguments as argument.
 * This is done early in buildtree() and only done once.
 */
NODE *
funcode(NODE *p)
{
	int n = 0;

	p->n_right = funarg(p->n_right, &n);
	return p;
}
@


1.4
log
@Sync with master repo. Reminded by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: code.c,v 1.2 2007/11/22 15:06:43 stefan Exp $	*/
@


1.3
log
@sync to main repo; requested by mickey
@
text
@d35 1
d38 2
a39 2
 * cause the alignment to become a multiple of n
 * never called for text segment.
d42 1
a42 1
defalign(int n)
d44 8
a51 2
	n /= SZCHAR;
	if (n == 1)
d53 20
a72 1
	printf("\t.align %d\n", n);
a75 18
 * define the current location as the name p->sname
 * never called for text segment.
 */
void
defnam(struct symtab *p)
{
	char *c = p->sname;

#ifdef GCC_COMPAT
	c = gcc_findname(p);
#endif
	if (p->sclass == EXTDEF)
		printf("\t.export %s, data\n", c);
	printf("\t.label %s\n", c);
}


/*
d105 19
d129 1
a129 1
bfcode(struct symtab **a, int n)
d131 3
a133 1
	int i;
d135 1
a135 2
	if (cftnsp->stype != STRTY+FTN && cftnsp->stype != UNIONTY+FTN)
		return;
d139 31
a199 34
 * Print character t at position i in one string, until t == -1.
 * Locctr & label is already defined.
 */
void
bycode(int t, int i)
{
	static	int	lastoctal = 0;

	/* put byte i+1 in a string */

	if (t < 0) {
		if (i != 0)
			puts("\"");
	} else {
		if (i == 0)
			printf("\t.ascii\t\"");
		if (t == '\\' || t == '"') {
			lastoctal = 0;
			putchar('\\');
			putchar(t);
		} else if (t < 040 || t >= 0177) {
			lastoctal++;
			printf("\\%o",t);
		} else if (lastoctal && '0' <= t && t <= '9') {
			lastoctal = 0;
			printf("\"\n\t.ascii\t\"%c", t);
		} else {	
			lastoctal = 0;
			putchar(t);
		}
	}
}

/*
d238 1
a238 1
		(*n)++;	/* XXX */
d249 1
a249 19
		switch (p->n_type) {
		case FLOAT:
			r->n_rval = FR7L - 2 * (*n)++;
			break;
		case DOUBLE:
		case LDOUBLE:
			*n = (*n + 1) & ~1;
			r->n_rval = FR6 - *n;
			*n += 2;
			break;
		case LONGLONG:
		case ULONGLONG:
			*n = (*n + 1) & ~1;
			r->n_rval = AD1 - *n / 2;
			*n += 2;
			break;
		default:
			r->n_rval = ARG0 - (*n)++;
		}
@


1.2
log
@Pull from master repo:

Put the genswitch() code that is found in most backends into
the MI part. The backend version is renamed to mygenswitch()
and can provide improved translations for switch statements.

Improved implementation of the switch constraints/semantics
described in the standard.

ok ragge@@, otto@@

With help and comments from ragge and gmcgarry
@
text
@d1 1
a1 1
/*	$OpenBSD: code.c,v 1.1 2007/11/16 08:36:23 otto Exp $	*/
d34 2
d156 1
a156 1
			printf("\t.ascii \"");
d166 1
a166 1
			printf("\"\n\t.ascii \"%c", t);
a174 10
 * n integer words of zeros
 */
void
zecode(int n)
{
	printf("\t.block %d\n", n * (SZINT/SZCHAR));
/*	inoff += n * SZINT; */
}

/*
d198 52
d257 3
@


1.1
log
@sync with repo and brink in hppa backend from mickey. afaik, it needs
some changes in the mi parts that are not yet committed
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d198 1
a198 5
/* p points to an array of structures, each consisting
 * of a constant value and a label.
 * The first is >=0 if there is a default label;
 * its value is the label number
 * The entries p[1] to p[n] are the nontrivial cases
d201 2
a202 2
void
genswitch(int num, struct swents **p, int n)
d204 1
a204 12
	NODE *r;
	int i;

	/* simple switch code */
	for (i = 1; i <= n; ++i) {
		/* already in 1 */
		r = tempnode(num, INT, 0, MKSUE(INT));
		r = buildtree(NE, r, bcon(p[i]->sval));
		cbranch(buildtree(NOT, r, NIL), bcon(p[i]->slab));
	}
	if (p[0]->slab > 0)
		branch(p[0]->slab);
@

