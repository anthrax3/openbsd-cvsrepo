head	1.8;
access;
symbols
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.16
	OPENBSD_5_0:1.7.0.14
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.12
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.10
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.6
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.8
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6;
locks; strict;
comment	@ * @;


1.8
date	2012.04.12.11.51.13;	author pirofti;	state dead;
branches;
next	1.7;

1.7
date	2008.04.11.20.45.52;	author stefan;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.22.22.56.31;	author stefan;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.22.14.05.04;	author stefan;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.25.12.54.09;	author stefan;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.03.09.55.56;	author stefan;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.01.10.52.58;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.20.10.01.38;	author otto;	state Exp;
branches;
next	;


desc
@@


1.8
log
@tedu(tm) pcc.

Message sent. Okay deraadt@@.
@
text
@/*	$OpenBSD: local2.c,v 1.7 2008/04/11 20:45:52 stefan Exp $	*/
/*
 * Copyright (c) 2003 Anders Magnusson (ragge@@ludd.luth.se).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <assert.h>

#include "pass1.h" // for exname()
#include "pass2.h"
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

#define LOWREG		0
#define HIREG		1

char *rnames[] = {
	REGPREFIX "r0", REGPREFIX "r1",
	REGPREFIX "r2", REGPREFIX "r3",
	REGPREFIX "r4", REGPREFIX "r5",
	REGPREFIX "r6", REGPREFIX "r7",
	REGPREFIX "r8", REGPREFIX "r9",
	REGPREFIX "r10", REGPREFIX "r11",
	REGPREFIX "r12", REGPREFIX "r13",
	REGPREFIX "r14", REGPREFIX "r15",
	REGPREFIX "r16", REGPREFIX "r17",
	REGPREFIX "r18", REGPREFIX "r19",
	REGPREFIX "r20", REGPREFIX "r21",
	REGPREFIX "r22", REGPREFIX "r23",
	REGPREFIX "r24", REGPREFIX "r25",
	REGPREFIX "r26", REGPREFIX "r27",
	REGPREFIX "r28", REGPREFIX "r29",
	REGPREFIX "r30", REGPREFIX "r31",
	"r4\0r3\0", "r5\0r4\0", "r6\0r5\0", "r7\0r6\0",
	"r8\0r7\0", "r9\0r8\0", "r10r9\0", "r15r14", "r17r16",
	"r19r18", "r21r20", "r23r22", "r25r24", "r27r26",
	"r29r28", "r31r30",
	REGPREFIX "f0", REGPREFIX "f1",
	REGPREFIX "f2", REGPREFIX "f3",
	REGPREFIX "f4", REGPREFIX "f5",
	REGPREFIX "f6", REGPREFIX "f7",
	REGPREFIX "f8", REGPREFIX "f9",
	REGPREFIX "f10", REGPREFIX "f11",
	REGPREFIX "f12", REGPREFIX "f13",
	REGPREFIX "f14", REGPREFIX "f15",
	REGPREFIX "f16", REGPREFIX "f17",
	REGPREFIX "f18", REGPREFIX "f19",
	REGPREFIX "f20", REGPREFIX "f21",
	REGPREFIX "f22", REGPREFIX "f23",
	REGPREFIX "f24", REGPREFIX "f25",
	REGPREFIX "f26", REGPREFIX "f27",
	REGPREFIX "f28", REGPREFIX "f29",
	REGPREFIX "f30", REGPREFIX "f31",
};

static int argsize(NODE *p);

static int p2calls;
static int p2temps;		/* TEMPs which aren't autos yet */
static int p2framesize;
static int p2maxstacksize;

void
deflab(int label)
{
	printf(LABFMT ":\n", label);
}

static TWORD ftype;

/*
 * Print out the prolog assembler.
 */
void
prologue(struct interpass_prolog *ipp)
{
	int addto;

#ifdef PCC_DEBUG
	if (x2debug)
		printf("prologue: type=%d, lineno=%d, name=%s, vis=%d, ipptype=%d, regs=0x%x, autos=%d, tmpnum=%d, lblnum=%d\n",
			ipp->ipp_ip.type,
			ipp->ipp_ip.lineno,
			ipp->ipp_name,
			ipp->ipp_vis,
			ipp->ipp_type,
			ipp->ipp_regs,
			ipp->ipp_autos,
			ipp->ip_tmpnum,
			ipp->ip_lblnum);
#endif

	ftype = ipp->ipp_type;

	addto = p2framesize;

	if (p2calls != 0 || kflag) {
		// get return address (not required for leaf function)
		printf("\tmflr %s\n", rnames[R0]);
		printf("\tstw %s,8(%s)\n", rnames[R0], rnames[R1]);
	}
	// save registers R30 and R31
	printf("\tstmw %s,-8(%s)\n", rnames[R30], rnames[R1]);
#ifdef FPREG
	printf("\tmr %s,%s\n", rnames[FPREG], rnames[R1]);
#endif
	// create the new stack frame
	if (addto > 65535) {
		printf("\tlis %s,%d\n", rnames[R0], (-addto) >> 16);
		printf("\tori %s,%s,%d\n", rnames[R0],
		    rnames[R0], (-addto) & 0xffff);
		printf("\tstwux %s,%s,%s\n", rnames[R1],
		    rnames[R1], rnames[R0]);
	} else {
		printf("\tstwu %s,-%d(%s)\n", rnames[R1], addto, rnames[R1]);
	}

	if (kflag) {
#if defined(ELFABI)
		printf("\tbl _GLOBAL_OFFSET_TABLE_@@local-4\n");
		printf("\tmflr %s\n", rnames[GOTREG]);
#elif defined(MACHOABI)
		printf("\tbcl 20,31,L%s$pb\n", ipp->ipp_name);
		printf("L%s$pb:\n", ipp->ipp_name);
		printf("\tmflr %s\n", rnames[GOTREG]);
#endif
	}

}


void
eoftn(struct interpass_prolog *ipp)
{

#ifdef PCC_DEBUG
	if (x2debug)
		printf("eoftn:\n");
#endif

	if (ipp->ipp_ip.ip_lbl == 0)
		return; /* no code needs to be generated */

	/* struct return needs special treatment */
	if (ftype == STRTY || ftype == UNIONTY) 
		cerror("eoftn");

	/* unwind stack frame */
	printf("\tlwz %s,0(%s)\n", rnames[R1], rnames[R1]);
	if (p2calls != 0 || kflag) {
		printf("\tlwz %s,8(%s)\n", rnames[R0], rnames[R1]);
		printf("\tmtlr %s\n", rnames[R0]);
	}
	printf("\tlmw %s,-8(%s)\n", rnames[R30], rnames[R1]);
	printf("\tblr\n");
}

/*
 * add/sub/...
 *
 * Param given:
 */
void
hopcode(int f, int o)
{
	char *str;

	switch (o) {
	case PLUS:
		str = "addw";
		break;
	case MINUS:
		str = "subw";
		break;
	case AND:
		str = "and";
		break;
	case OR:
		str = "or";
		break;
	case ER:
		str = "xor";
		break;
	default:
		comperr("hopcode2: %d", o);
		str = 0; /* XXX gcc */
	}
	printf("%s%c", str, f);
}

/*
 * Return type size in bytes.  Used by R2REGS, arg 2 to offset().
 */
int
tlen(NODE *p)
{
	switch(p->n_type) {
		case CHAR:
		case UCHAR:
			return(1);

		case SHORT:
		case USHORT:
			return(SZSHORT/SZCHAR);

		case DOUBLE:
			return(SZDOUBLE/SZCHAR);

		case INT:
		case UNSIGNED:
		case LONG:
		case ULONG:
			return(SZINT/SZCHAR);

		case LONGLONG:
		case ULONGLONG:
			return SZLONGLONG/SZCHAR;

		default:
			if (!ISPTR(p->n_type))
				comperr("tlen type %d not pointer");
			return SZPOINT(p->n_type)/SZCHAR;
		}
}

/*
 * Emit code to compare two longlong numbers.
 */
static void
twollcomp(NODE *p)
{
	int o = p->n_op;
	int s = getlab();
	int e = p->n_label;
	int cb1, cb2;

	if (o >= ULE)
		o -= (ULE-LE);
	switch (o) {
	case NE:
		cb1 = 0;
		cb2 = NE;
		break;
	case EQ:
		cb1 = NE;
		cb2 = 0;
		break;
	case LE:
	case LT:
		cb1 = GT;
		cb2 = LT;
		break;
	case GE:
	case GT:
		cb1 = LT;
		cb2 = GT;
		break;
	
	default:
		cb1 = cb2 = 0; /* XXX gcc */
	}
	if (p->n_op >= ULE)
		cb1 += 4, cb2 += 4;
	if (p->n_op >= ULE)
		expand(p, 0, "\tcmplw UL,UR" COM "compare 64-bit values (upper)\n");
	else
		expand(p, 0, "\tcmpw UL,UR" COM "compare 64-bit values (upper)\n");
	if (cb1) cbgen(cb1, s);
	if (cb2) cbgen(cb2, e);
	if (p->n_op >= ULE)
		expand(p, 0, "\tcmplw AL,AR" COM "(and lower)\n");
	else
		expand(p, 0, "\tcmpw AL,AR" COM "(and lower)\n");
	cbgen(p->n_op, e);
	deflab(s);
}

static void
shiftop(NODE *p)
{
	NODE *r = p->n_right;
	TWORD ty = p->n_type;

	if (p->n_op == LS && r->n_op == ICON && r->n_lval < 32) {
		expand(p, INBREG, "\tsrwi A1,AL,32-AR" COM "64-bit left-shift\n");
		expand(p, INBREG, "\tslwi U1,UL,AR\n");
		expand(p, INBREG, "\tor U1,U1,A1\n");
		expand(p, INBREG, "\tslwi A1,AL,AR\n");
	} else if (p->n_op == LS && r->n_op == ICON && r->n_lval < 64) {
		expand(p, INBREG, "\tli A1,0" COM "64-bit left-shift\n");
		if (r->n_lval == 32)
			expand(p, INBREG, "\tmr U1,AL\n");
		else
			expand(p, INBREG, "\tslwi U1,AL,AR-32\n");
	} else if (p->n_op == LS && r->n_op == ICON) {
		expand(p, INBREG, "\tli A1,0" COM "64-bit left-shift\n");
		expand(p, INBREG, "\tli U1,0\n");
	} else if (p->n_op == RS && r->n_op == ICON && r->n_lval < 32) {
		expand(p, INBREG, "\tslwi U1,UL,32-AR" COM "64-bit right-shift\n");
		expand(p, INBREG, "\tsrwi A1,AL,AR\n");
		expand(p, INBREG, "\tor A1,A1,U1\n");
		if (ty == LONGLONG)
			expand(p, INBREG, "\tsrawi U1,UL,AR\n");
		else
			expand(p, INBREG, "\tsrwi U1,UL,AR\n");
	} else if (p->n_op == RS && r->n_op == ICON && r->n_lval < 64) {
		if (ty == LONGLONG)
			expand(p, INBREG, "\tli U1,-1" COM "64-bit right-shift\n");
		else
			expand(p, INBREG, "\tli U1,0" COM "64-bit right-shift\n");
		if (r->n_lval == 32)
			expand(p, INBREG, "\tmr A1,UL\n");
		else if (ty == LONGLONG)
			expand(p, INBREG, "\tsrawi A1,UL,AR-32\n");
		else
			expand(p, INBREG, "\tsrwi A1,UL,AR-32\n");
	} else if (p->n_op == RS && r->n_op == ICON) {
		expand(p, INBREG, "\tli A1,0" COM "64-bit right-shift\n");
		expand(p, INBREG, "\tli U1,0\n");
	}
}

/*
 * Structure assignment.
 */
static void
stasg(NODE *p)
{
        /* R3 = dest, R4 = src, R5 = len */
        printf("\tli %s,%d\n", rnames[R5], p->n_stsize);
        if (p->n_left->n_op == OREG) {
                printf("\taddi %s,%s," CONFMT "\n",
                    rnames[R3], rnames[regno(p->n_left)],
                    p->n_left->n_lval);
        } else if (p->n_left->n_op == NAME) {
#if defined(ELFABI)
                printf("\tli %s,", rnames[R3]);
                adrput(stdout, p->n_left);
		printf("@@ha\n");
                printf("\taddi %s,%s,", rnames[R3], rnames[R3]);
                adrput(stdout, p->n_left);
		printf("@@l\n");
#elif defined(MACHOABI)
                printf("\tli %s,ha16(", rnames[R3]);
                adrput(stdout, p->n_left);
		printf(")\n");
                printf("\taddi %s,%s,lo16(", rnames[R3], rnames[R3]);
                adrput(stdout, p->n_left);
		printf(")\n");
#endif
        }
	if (kflag) {
#if defined(ELFABI)
	        printf("\tbl %s@@got(30)\n", exname("memcpy"));
#elif defined(MACHOABI)
	        printf("\tbl L%s$stub\n", "memcpy");
		addstub(&stublist, "memcpy");
#endif
	} else {
	        printf("\tbl %s\n", exname("memcpy"));
	}
}

static void
fpemul(NODE *p)
{
	NODE *l = p->n_left;
	char *ch = NULL;

	if (p->n_op == PLUS && p->n_type == FLOAT) ch = "addsf3";
	else if (p->n_op == PLUS && p->n_type == DOUBLE) ch = "adddf3";
	else if (p->n_op == PLUS && p->n_type == LDOUBLE) ch = "addtf3";

	else if (p->n_op == MINUS && p->n_type == FLOAT) ch = "subsf3";
	else if (p->n_op == MINUS && p->n_type == DOUBLE) ch = "subdf3";
	else if (p->n_op == MINUS && p->n_type == LDOUBLE) ch = "subtf3";

	else if (p->n_op == MUL && p->n_type == FLOAT) ch = "mulsf3";
	else if (p->n_op == MUL && p->n_type == DOUBLE) ch = "muldf3";
	else if (p->n_op == MUL && p->n_type == LDOUBLE) ch = "multf3";

	else if (p->n_op == DIV && p->n_type == FLOAT) ch = "divsf3";
	else if (p->n_op == DIV && p->n_type == DOUBLE) ch = "divdf3";
	else if (p->n_op == DIV && p->n_type == LDOUBLE) ch = "divtf3";

	else if (p->n_op == UMINUS && p->n_type == FLOAT) ch = "negsf2";
	else if (p->n_op == UMINUS && p->n_type == DOUBLE) ch = "negdf2";
	else if (p->n_op == UMINUS && p->n_type == LDOUBLE) ch = "negtf2";

	else if (p->n_op == EQ && l->n_type == FLOAT) ch = "eqsf2";
	else if (p->n_op == EQ && l->n_type == DOUBLE) ch = "eqdf2";
	else if (p->n_op == EQ && l->n_type == LDOUBLE) ch = "eqtf2";

	else if (p->n_op == NE && l->n_type == FLOAT) ch = "nesf2";
	else if (p->n_op == NE && l->n_type == DOUBLE) ch = "nedf2";
	else if (p->n_op == NE && l->n_type == LDOUBLE) ch = "netf2";

	else if (p->n_op == GE && l->n_type == FLOAT) ch = "gesf2";
	else if (p->n_op == GE && l->n_type == DOUBLE) ch = "gedf2";
	else if (p->n_op == GE && l->n_type == LDOUBLE) ch = "getf2";

	else if (p->n_op == LE && l->n_type == FLOAT) ch = "lesf2";
	else if (p->n_op == LE && l->n_type == DOUBLE) ch = "ledf2";
	else if (p->n_op == LE && l->n_type == LDOUBLE) ch = "letf2";

	else if (p->n_op == GT && l->n_type == FLOAT) ch = "gtsf2";
	else if (p->n_op == GT && l->n_type == DOUBLE) ch = "gtdf2";
	else if (p->n_op == GT && l->n_type == LDOUBLE) ch = "gttf2";

	else if (p->n_op == LT && l->n_type == FLOAT) ch = "ltsf2";
	else if (p->n_op == LT && l->n_type == DOUBLE) ch = "ltdf2";
	else if (p->n_op == LT && l->n_type == LDOUBLE) ch = "lttf2";

	else if (p->n_op == SCONV && p->n_type == FLOAT) {
		if (l->n_type == DOUBLE) ch = "truncdfsf2";
		else if (l->n_type == LDOUBLE) ch = "truncdfsf2";
		else if (l->n_type == ULONGLONG) ch = "floatunsdisf";
		else if (l->n_type == LONGLONG) ch = "floatdisf";
		else if (l->n_type == LONG) ch = "floatsisf";
		else if (l->n_type == ULONG) ch = "floatunsisf";
		else if (l->n_type == INT) ch = "floatsisf";
		else if (l->n_type == UNSIGNED) ch = "floatunsisf";
	} else if (p->n_op == SCONV && p->n_type == DOUBLE) {
		if (l->n_type == FLOAT) ch = "extendsfdf2";
		else if (l->n_type == LDOUBLE) ch = "truncdfdf2";
		else if (l->n_type == ULONGLONG) ch = "floatunsdidf";
		else if (l->n_type == LONGLONG) ch = "floatdidf";
		else if (l->n_type == LONG) ch = "floatsidf";
		else if (l->n_type == ULONG) ch = "floatunssidf";
		else if (l->n_type == INT) ch = "floatsidf";
		else if (l->n_type == UNSIGNED) ch = "floatunssidf";
	} else if (p->n_op == SCONV && p->n_type == LDOUBLE) {
		if (l->n_type == FLOAT) ch = "extendsfdf2";
		else if (l->n_type == DOUBLE) ch = "extenddfdf2";
		else if (l->n_type == ULONGLONG) ch = "floatunsdidf";
		else if (l->n_type == LONGLONG) ch = "floatdidf";
		else if (l->n_type == LONG) ch = "floatsidf";
		else if (l->n_type == ULONG) ch = "floatunssidf";
		else if (l->n_type == INT) ch = "floatsidf";
		else if (l->n_type == UNSIGNED) ch = "floatunsidf";
	} else if (p->n_op == SCONV && p->n_type == ULONGLONG) {
		if (l->n_type == FLOAT) ch = "fixunssfdi";
		else if (l->n_type == DOUBLE) ch = "fixunsdfdi";
		else if (l->n_type == LDOUBLE) ch = "fixunsdfdi";
	} else if (p->n_op == SCONV && p->n_type == LONGLONG) {
		if (l->n_type == FLOAT) ch = "fixsfdi";
		else if (l->n_type == DOUBLE) ch = "fixdfdi";
		else if (l->n_type == LDOUBLE) ch = "fixtfdi";
	} else if (p->n_op == SCONV && p->n_type == LONG) {
		if (l->n_type == FLOAT) ch = "fixsfdi";
		else if (l->n_type == DOUBLE) ch = "fixdfdi";
		else if (l->n_type == LDOUBLE) ch = "fixtfdi";
	} else if (p->n_op == SCONV && p->n_type == ULONG) {
		if (l->n_type == FLOAT) ch = "fixunssfdi";
		else if (l->n_type == DOUBLE) ch = "fixunsdfdi";
		else if (l->n_type == LDOUBLE) ch = "fixunstfdi";
	} else if (p->n_op == SCONV && p->n_type == INT) {
		if (l->n_type == FLOAT) ch = "fixsfsi";
		else if (l->n_type == DOUBLE) ch = "fixdfsi";
		else if (l->n_type == LDOUBLE) ch = "fixdfsi";
	} else if (p->n_op == SCONV && p->n_type == UNSIGNED) {
		if (l->n_type == FLOAT) ch = "fixunssfsi";
		else if (l->n_type == DOUBLE) ch = "fixunsdfsi";
		else if (l->n_type == LDOUBLE) ch = "fixunsdfsi";
	}

	if (ch == NULL) comperr("ZF: op=0x%x (%d)\n", p->n_op, p->n_op);

	if (kflag) {
#if defined(ELFABI)
		printf("\tbl __%s@@got(30)" COM "soft-float\n", exname(ch));
#elif defined(MACHOABI)
		char buf[32];
		printf("\tbl L__%s$stub" COM "soft-float\n", ch);
		snprintf(buf, 32, "__%s", ch);
		addstub(&stublist, buf);
#endif
	} else {
		printf("\tbl __%s" COM "soft-float\n", exname(ch));
	}

	if (p->n_op >= EQ && p->n_op <= GT)
		printf("\tcmpwi %s,0\n", rnames[R3]);
}

/*
 * http://gcc.gnu.org/onlinedocs/gccint/Integer-library-routines.html#Integer-library-routines
 */

static void
emul(NODE *p)
{
	char *ch = NULL;

        if (p->n_op == LS && DEUNSIGN(p->n_type) == LONGLONG) ch = "ashldi3";
        else if (p->n_op == LS && (DEUNSIGN(p->n_type) == LONG ||
            DEUNSIGN(p->n_type) == INT))
                ch = "ashlsi3";

        else if (p->n_op == RS && p->n_type == ULONGLONG) ch = "lshrdi3";
        else if (p->n_op == RS && (p->n_type == ULONG || p->n_type == INT))
                ch = "lshrsi3";

        else if (p->n_op == RS && p->n_type == LONGLONG) ch = "ashrdi3";
        else if (p->n_op == RS && (p->n_type == LONG || p->n_type == INT))
                ch = "ashrsi3";
        
        else if (p->n_op == DIV && p->n_type == LONGLONG) ch = "divdi3";
        else if (p->n_op == DIV && (p->n_type == LONG || p->n_type == INT))
                ch = "divsi3";

        else if (p->n_op == DIV && p->n_type == ULONGLONG) ch = "udivdi3";
        else if (p->n_op == DIV && (p->n_type == ULONG ||
            p->n_type == UNSIGNED))
                ch = "udivsi3";

        else if (p->n_op == MOD && p->n_type == LONGLONG) ch = "moddi3";
        else if (p->n_op == MOD && (p->n_type == LONG || p->n_type == INT))
                ch = "modsi3";

        else if (p->n_op == MOD && p->n_type == ULONGLONG) ch = "umoddi3";
        else if (p->n_op == MOD && (p->n_type == ULONG ||
            p->n_type == UNSIGNED))
                ch = "umodsi3";

        else if (p->n_op == MUL && p->n_type == LONGLONG) ch = "muldi3";
        else if (p->n_op == MUL && (p->n_type == LONG || p->n_type == INT))
                ch = "mulsi3";

        else if (p->n_op == UMINUS && p->n_type == LONGLONG) ch = "negdi2";
        else if (p->n_op == UMINUS && p->n_type == LONG) ch = "negsi2";

	else ch = 0, comperr("ZE");
	if (kflag) {
#if defined(ELFABI)
		printf("\tbl __%s@@got(30)" COM "emulated op\n", exname(ch));
#elif defined(MACHOABI)
		char buf[32];
		printf("\tbl L__%s$stub" COM "emulated op\n", ch);
		snprintf(buf, 32, "__%s", ch);
		addstub(&stublist, buf);
#endif
	} else {
		printf("\tbl __%s" COM "emulated operation\n", exname(ch));
	}
}

/*
 *  Floating-point conversions (int -> float/double & float/double -> int)
 */

static void
ftoi(NODE *p)
{
	NODE *l = p->n_left;

	printf(COM "start conversion float/(l)double to int\n");

	if (l->n_op != OREG) {
		expand(p, 0, "\tstw AL,-4");
		printf("(%s)\n", rnames[SPREG]);
		if (l->n_type == FLOAT)
			expand(p, 0, "\tlfs A2,");
		else
			expand(p, 0, "\tlfd A2,\n");
		printf("-4(%s)\n", rnames[SPREG]);
	} else {
		if (l->n_type == FLOAT)
			expand(p, 0, "\tlfs A2,AL\n");
		else
			expand(p, 0, "\tlfd A2,AL\n");
	}

	expand(p, 0, "\tfctiwz A2,A2\n");
	expand(p, 0, "\tstfd A2,");
	printf("-8(%s)\n", rnames[SPREG]);
	expand(p, 0, "\tlwz A1,");
	printf("-4(%s)\n", rnames[SPREG]);

	printf(COM "end conversion\n");
}

static void
ftou(NODE *p)
{
	static int lab = 0;
	NODE *l = p->n_left;
	int lab1 = getlab();
	int lab2 = getlab();

	printf(COM "start conversion of float/(l)double to unsigned\n");

	if (lab == 0) {
		lab = getlab();
		expand(p, 0, "\t.data\n");
		printf(LABFMT ":\t.long 0x41e00000\n\t.long 0\n", lab);
		expand(p, 0, "\t.text\n");
	}

	if (l->n_op != OREG) {
		expand(p, 0, "\tstw AL,");
		printf("-4(%s)\n", rnames[SPREG]);
		if (l->n_type == FLOAT)
			expand(p, 0, "\tlfs A3,");
		else
			expand(p, 0, "\tlfd A3,");
		printf("-4(%s)\n", rnames[SPREG]);
		
	} else {
		if (l->n_type == FLOAT)
			expand(p, 0, "\tlfs A3,AL\n");
		else
			expand(p, 0, "\tlfd A3,AL\n");
	}

#if 0
	if (kflag) {
		expand(p, 0, "\taddis A1,");
		printf("%s,ha16(", rnames[R31]);
		printf(LABFMT, lab);
		printf("-L%s$pb)\n", cftnsp->soname);
       		expand(p, 0, "\tlfd A2,lo16(");
		printf(LABFMT, lab);
		printf("-L%s$pb)", cftnsp->soname);
		expand(p, 0, "(A1)\n");
	} else {
               	expand(p, 0, "\tlfd A2,");
		printf(LABFMT "\n", lab);
	}
#endif

#if defined(ELFABI)

	expand(p, 0, "\taddis A1,");
	printf("%s," LABFMT "@@ha\n", rnames[R31], lab);
       	expand(p, 0, "\tlfd A2,");
	printf(LABFMT "@@l", lab);
	expand(p, 0, "(A1)\n");

#elif defined(MACHOABI)

	expand(p, 0, "\taddis A1,");
	printf("%s,ha16(", rnames[R31]);
	printf(LABFMT, lab);
	if (kflag)
		printf("-L%s$pb", cftnsp->soname);
	printf(")\n");
       	expand(p, 0, "\tlfd A2,lo16(");
	printf(LABFMT, lab);
	if (kflag)
		printf("-L%s$pb", cftnsp->soname);
	expand(p, 0, ")(A1)\n");

#endif

	expand(p, 0, "\tfcmpu cr7,A3,A2\n");
	printf("\tcror 30,29,30\n");
	printf("\tbeq cr7,"LABFMT "\n", lab1);

	expand(p, 0, "\tfctiwz A2,A3\n");
	expand(p, 0, "\tstfd A2,");
	printf("-8(%s)\n", rnames[SPREG]);
	expand(p, 0, "\tlwz A1,");
	printf("-4(%s)\n", rnames[SPREG]);
	printf("\tba " LABFMT "\n", lab2);

	deflab(lab1);

        expand(p, 0, "\tfsub A2,A3,A2\n");
        expand(p, 0, "\tfctiwz A2,A2\n");
	expand(p, 0, "\tstfd A2,");
	printf("-8(%s)\n", rnames[SPREG]);
	expand(p, 0, "\tlwz A1,");
	printf("-4(%s)\n", rnames[SPREG]);
        expand(p, 0, "\txoris A1,A1,0x8000\n");

	deflab(lab2);

	printf(COM "end conversion\n");
}

static void
itof(NODE *p)
{
	static int labu = 0;
	static int labi = 0;
	int lab;
	NODE *l = p->n_left;

	printf(COM "start conversion (u)int to float/(l)double\n");

	if (labi == 0 && l->n_type == INT) {
		labi = getlab();
		expand(p, 0, "\t.data\n");
		printf(LABFMT ":\t.long 0x43300000\n\t.long 0x80000000\n", labi);
		expand(p, 0, "\t.text\n");
	} else if (labu == 0 && l->n_type == UNSIGNED) {
		labu = getlab();
		expand(p, 0, "\t.data\n");
		printf(LABFMT ":\t.long 0x43300000\n\t.long 0x00000000\n", labu);
		expand(p, 0, "\t.text\n");
	}

	if (l->n_type == INT) {
		expand(p, 0, "\txoris A1,AL,0x8000\n");
		lab = labi;
	} else {
		lab = labu;
	}
	expand(p, 0, "\tstw A1,");
	printf("-4(%s)\n", rnames[SPREG]);
        expand(p, 0, "\tlis A1,0x4330\n");
        expand(p, 0, "\tstw A1,");
	printf("-8(%s)\n", rnames[SPREG]);
        expand(p, 0, "\tlfd A3,");
	printf("-8(%s)\n", rnames[SPREG]);

#if 0
	if (kflag) {
		expand(p, 0, "\taddis A1,");
		printf("%s,ha16(", rnames[R31]);
		printf(LABFMT, lab);
		printf("-L%s$pb)\n", cftnsp->soname);
       		expand(p, 0, "\tlfd A2,lo16(");
		printf(LABFMT, lab);
		printf("-L%s$pb)", cftnsp->soname);
		expand(p, 0, "(A1)\n");
	} else {
               	expand(p, 0, "\tlfd A2,");
		printf(LABFMT "\n", lab);
	}
#endif

#if defined(ELFABI)

	expand(p, 0, "\taddis A1,");
	printf("%s," LABFMT "@@ha\n", rnames[R31], lab);
       	expand(p, 0, "\tlfd A2,");
	printf(LABFMT "@@l", lab);
	expand(p, 0, "(A1)\n");

#elif defined(MACHOABI)

	expand(p, 0, "\taddis A1,");
	printf("%s,ha16(", rnames[R31]);
	printf(LABFMT, lab);
	if (kflag)
		printf("-L%s$pb", cftnsp->soname);
	printf(")\n");
       	expand(p, 0, "\tlfd A2,lo16(");
	printf(LABFMT, lab);
	if (kflag)
		printf("-L%s$pb", cftnsp->soname);
	expand(p, 0, ")(A1)\n");

#endif

	expand(p, 0, "\tfsub A3,A3,A2\n");
	if (p->n_type == FLOAT)
		expand(p, 0, "\tfrsp A3,A3\n");

	printf(COM "end conversion\n");
}


static void
fpconv(NODE *p)
{
	NODE *l = p->n_left;

#ifdef PCC_DEBUG
	if (p->n_op != SCONV)
		cerror("fpconv 1");
#endif

	if (DEUNSIGN(l->n_type) == INT)
		itof(p);
	else if (p->n_type == INT)
		ftoi(p);
	else if (p->n_type == UNSIGNED)
		ftou(p);
	else
		cerror("unhandled floating-point conversion");

}

void
zzzcode(NODE *p, int c)
{
	switch (c) {

	case 'C': /* floating-point conversions */
		fpconv(p);
		break;

	case 'D': /* long long comparision */
		twollcomp(p);
		break;

	case 'E': /* print out emulated ops */
		emul(p);
		break;

	case 'F': /* print out emulate floating-point ops */
		fpemul(p);
		break;

	case 'O': /* 64-bit left and right shift operators */
		shiftop(p);
		break;

	case 'Q': /* emit struct assign */
		stasg(p);
		break;

	default:
		comperr("zzzcode %c", c);
	}
}

/*ARGSUSED*/
int
rewfld(NODE *p)
{
	return(1);
}

int canaddr(NODE *);
int
canaddr(NODE *p)
{
	int o = p->n_op;

	if (o == NAME || o == REG || o == ICON || o == OREG ||
	    (o == UMUL && shumul(p->n_left)))
		return(1);
	return 0;
}

int
fldexpand(NODE *p, int cookie, char **cp)
{
	CONSZ val;
	int shft;

	if (p->n_op == ASSIGN)
		p = p->n_left;

	shft = SZINT - UPKFSZ(p->n_rval) - UPKFOFF(p->n_rval);

	switch (**cp) {
	case 'S':
		printf("%d", UPKFSZ(p->n_rval));
		break;
	case 'H':
		printf("%d", shft);
		break;
	case 'M':
	case 'N':
		val = (CONSZ)1 << UPKFSZ(p->n_rval);
		--val;
		val <<= shft;
		printf(CONFMT, (**cp == 'M' ? val : ~val)  & 0xffffffff);
		break;
	default:
		comperr("fldexpand");
	}
	return 1;
}

/*
 * Does the bitfield shape match?
 */
int
flshape(NODE *p)
{
	int o = p->n_op;

	if (o == OREG || o == REG || o == NAME)
		return SRDIR; /* Direct match */
	if (o == UMUL && shumul(p->n_left))
		return SROREG; /* Convert into oreg */
	return SRREG; /* put it into a register */
}

/* INTEMP shapes must not contain any temporary registers */
/* XXX should this go away now? */
int
shtemp(NODE *p)
{
	printf("; shtemp\n");
	return 0;
#if 0
	int r;

	if (p->n_op == STARG )
		p = p->n_left;

	switch (p->n_op) {
	case REG:
		return (!istreg(regno(p)));

	case OREG:
		r = regno(p);
		if (R2TEST(r)) {
			if (istreg(R2UPK1(r)))
				return(0);
			r = R2UPK2(r);
		}
		return (!istreg(r));

	case UMUL:
		p = p->n_left;
		return (p->n_op != UMUL && shtemp(p));
	}

	if (optype(p->n_op) != LTYPE)
		return(0);
	return(1);
#endif
}

void
adrcon(CONSZ val)
{
	printf( CONFMT, val);
}

void
conput(FILE *fp, NODE *p)
{
	int val = p->n_lval;

	switch (p->n_op) {
	case ICON:
		if (p->n_name[0] != '\0') {
			fprintf(fp, "%s", p->n_name);
			if (val)
				fprintf(fp, "+%d", val);
		} else {
			if (GCLASS(p->n_type) == CLASSB)
				fprintf(fp, CONFMT, p->n_lval >> 32);
			else
				fprintf(fp, "%d", val);
		}
		return;

	default:
		comperr("illegal conput, p %p", p);
	}
}

/*ARGSUSED*/
void
insput(NODE *p)
{
	comperr("insput");
}

/*
 * Print lower or upper name of 64-bit register.
 */
static void
reg64name(int reg, int hi)
{
	int idx;
	int off = 0;

	assert(GCLASS(reg) == CLASSB);

	idx = (reg > R14R15 ? (2*(reg - R14R15) + R14) : (reg - R3R4 + R3));

	if ((hi == HIREG && !features(FEATURE_BIGENDIAN)) ||
	    (hi == LOWREG && features(FEATURE_BIGENDIAN)))
		off = 1;
		
	fprintf(stdout, "%s" , rnames[idx + off]);
}

/*
 * Write out the upper address, like the upper register of a 2-register
 * reference, or the next memory location.
 */
void
upput(NODE *p, int size)
{
	size /= SZCHAR;
	switch (p->n_op) {
	case REG:
		reg64name(regno(p), HIREG);
		break;

	case NAME:
	case OREG:
		if (features(FEATURE_BIGENDIAN))
			fprintf(stdout, "%d", (int)p->n_lval);
		else
			fprintf(stdout, "%d", (int)(p->n_lval + 4));
		fprintf(stdout, "(%s)", rnames[regno(p)]);
		break;

	case ICON:
		fprintf(stdout, CONFMT, p->n_lval >> 32);
		break;

	default:
		comperr("upput bad op %d size %d", p->n_op, size);
	}
}

void
adrput(FILE *io, NODE *p)
{
	/* output an address, with offsets, from p */

	if (p->n_op == FLD)
		p = p->n_left;

	switch (p->n_op) {

	case NAME:
		if (p->n_name[0] != '\0') {
			fputs(p->n_name, io);
			if (p->n_lval != 0)
				fprintf(io, "+" CONFMT, p->n_lval);
		} else
			fprintf(io, CONFMT, p->n_lval);
		return;

	case OREG:
		if (DEUNSIGN(p->n_type) == LONGLONG &&
		    features(FEATURE_BIGENDIAN))
			fprintf(io, "%d", (int)(p->n_lval + 4));
		else
			fprintf(io, "%d", (int)p->n_lval);
		fprintf(io, "(%s)", rnames[regno(p)]);
		return;

	case ICON:
		/* addressable value of the constant */
		conput(io, p);
		return;

	case REG:
		if (GCLASS(regno(p)) == CLASSB)
			reg64name(regno(p), LOWREG);
		else
			fprintf(io, "%s", rnames[regno(p)]);
#if 0
		switch (p->n_type) {
		case DOUBLE:
		case LDOUBLE:
			if (features(FEATURE_HARDFLOAT)) {
				fprintf(io, "%s", rnames[regno(p)]);
				break;
			}
			/* FALL-THROUGH */
		case LONGLONG:
		case ULONGLONG:
			reg64name(regno(p), LOWREG);
			break;
		default:
			fprintf(io, "%s", rnames[regno(p)]);
		}
#endif
		return;

	default:
		comperr("illegal address, op %d, node %p", p->n_op, p);
		return;

	}
}

/*
 * these mnemonics match the order of the preprocessor decls
 * EQ, NE, LE, LT, GE, GT, ULE, ULT, UGE, UGT
 */

static char *
ccbranches[] = {
	"beq",		/* branch if equal */
	"bne",		/* branch if not-equal */
	"ble",		/* branch if less-than-or-equal */
	"blt",		/* branch if less-than */
	"bge",		/* branch if greater-than-or-equal */
	"bgt",		/* branch if greater-than */
	/* what should these be ? */
	"ble",		/* branch if less-than-or-equal */
	"blt",		/* branch if less-than */
	"bge",		/* branch if greater-than-or-equal */
	"bgt",		/* branch if greater-than */

};


/*   printf conditional and unconditional branches */
void
cbgen(int o, int lab)
{
	if (o < EQ || o > UGT)
		comperr("bad conditional branch: %s", opst[o]);
	printf("\t%s " LABFMT "\n", ccbranches[o-EQ], lab);
}

static int
argsize(NODE *p)
{
	TWORD t = p->n_type;

	if (t < LONGLONG || t == FLOAT || t > BTMASK)
		return 4;
	if (t == LONGLONG || t == ULONGLONG)
		return 8;
	if (t == DOUBLE || t == LDOUBLE)
		return 8;
	if (t == STRTY || t == UNIONTY)
		return p->n_stsize;
	comperr("argsize");
	return 0;
}

static int
calc_args_size(NODE *p)
{
	int n = 0;
        
        if (p->n_op == CM) {
                n += calc_args_size(p->n_left);
                n += calc_args_size(p->n_right);
                return n;
        }

        n += argsize(p);

        return n;
}


static void
fixcalls(NODE *p)
{
	int n = 0;

	switch (p->n_op) {
	case STCALL:
	case CALL:
		n = calc_args_size(p->n_right);
		if (n > p2maxstacksize)
			p2maxstacksize = n;
		/* FALLTHROUGH */
	case USTCALL:
	case UCALL:
		++p2calls;
		break;
	case TEMP:
		p2temps += argsize(p);
		break;
	}
}

/*
 * Must store floats in memory if there are two function calls involved.
 */
static int
storefloat(struct interpass *ip, NODE *p)
{
	int l, r;

	switch (optype(p->n_op)) {
	case BITYPE:
		l = storefloat(ip, p->n_left);
		r = storefloat(ip, p->n_right);
		if (p->n_op == CM)
			return 0; /* arguments, don't care */
		if (callop(p->n_op))
			return 1; /* found one */
#define ISF(p) ((p)->n_type == FLOAT || (p)->n_type == DOUBLE || \
	(p)->n_type == LDOUBLE)
		if (ISF(p->n_left) && ISF(p->n_right) && l && r) {
			/* must store one. store left */
			struct interpass *nip;
			TWORD t = p->n_left->n_type;
			NODE *ll;
			int off;

                	off = BITOOR(freetemp(szty(t)));
                	ll = mklnode(OREG, off, SPREG, t);
			nip = ipnode(mkbinode(ASSIGN, ll, p->n_left, t));
			p->n_left = mklnode(OREG, off, SPREG, t);
                	DLIST_INSERT_BEFORE(ip, nip, qelem);
		}
		return l|r;

	case UTYPE:
		l = storefloat(ip, p->n_left);
		if (callop(p->n_op))
			l = 1;
		return l;
	default:
		return 0;
	}
}

void
myreader(struct interpass *ipole)
{
	struct interpass *ip;

	p2calls = 0;
	p2temps = 0;
	p2maxstacksize = 0;

	DLIST_FOREACH(ip, ipole, qelem) {
		if (ip->type != IP_NODE)
			continue;
		walkf(ip->ip_node, fixcalls);
		storefloat(ip, ip->ip_node);
	}

	if (p2maxstacksize < NARGREGS*SZINT/SZCHAR)
		p2maxstacksize = NARGREGS*SZINT/SZCHAR;

	p2framesize = ARGINIT/SZCHAR;		/* stack ptr / return addr */
	p2framesize += 8;			/* for R31 and R30 */
	p2framesize += p2maxautooff;		/* autos */
	p2framesize += p2temps;			/* TEMPs that aren't autos */
	if (p2calls != 0)
		p2framesize += p2maxstacksize;	/* arguments to functions */
	p2framesize += (ALSTACK/SZCHAR - 1);	/* round to 16-byte boundary */
	p2framesize &= ~(ALSTACK/SZCHAR - 1);

#if 0
	printf("!!! MYREADER\n");
	printf("!!! p2maxautooff = %d\n", p2maxautooff);
	printf("!!! p2autooff = %d\n", p2autooff);
	printf("!!! p2temps = %d\n", p2temps);
	printf("!!! p2calls = %d\n", p2calls);
	printf("!!! p2maxstacksize = %d\n", p2maxstacksize);
#endif

	if (x2debug)
		printip(ipole);
}

/*
 * Remove some PCONVs after OREGs are created.
 */
static void
pconv2(NODE *p)
{
	NODE *q;

	if (p->n_op == PLUS) {
		if (p->n_type == (PTR|SHORT) || p->n_type == (PTR|USHORT)) {
			if (p->n_right->n_op != ICON)
				return;
			if (p->n_left->n_op != PCONV)
				return;
			if (p->n_left->n_left->n_op != OREG)
				return;
			q = p->n_left->n_left;
			nfree(p->n_left);
			p->n_left = q;
			/*
			 * This will be converted to another OREG later.
			 */
		}
	}
}

void
mycanon(NODE *p)
{
	walkf(p, pconv2);
}

void
myoptim(struct interpass *ip)
{
#ifdef PCC_DEBUG
	if (x2debug) {
		printf("myoptim\n");
	}
#endif
}

/*
 * Move data between registers.  While basic registers aren't a problem,
 * we have to handle the special case of overlapping composite registers.
 * It might just be easier to modify the register allocator so that
 * moves between overlapping registers isn't possible.
 */
void
rmove(int s, int d, TWORD t)
{
	switch (t) {
	case LDOUBLE:
	case DOUBLE:
		if (features(FEATURE_HARDFLOAT)) {
			printf("\tfmr %s,%s" COM "rmove\n",
			    rnames[d], rnames[s]);
			break;
		}
		/* FALL-THROUGH */
	case LONGLONG:
	case ULONGLONG:
		if (s == d+1) {
			/* dh = sl, copy low word first */
			printf("\tmr ");
			reg64name(d, LOWREG);
			printf(",");
			reg64name(s, LOWREG);
			printf("\n");
			printf("\tmr ");
			reg64name(d, HIREG);
			printf(",");
			reg64name(s, HIREG);
			printf("\n");
		} else {
			/* copy high word first */
			printf("\tmr ");
			reg64name(d, HIREG);
			printf(",");
			reg64name(s, HIREG);
			printf("\n");
			printf("\tmr ");
			reg64name(d, LOWREG);
			printf(",");
			reg64name(s, LOWREG);
			printf("\n");
		}
		break;
	case FLOAT:
		if (features(FEATURE_HARDFLOAT)) {
			printf("\tfmr %s,%s" COM "rmove\n",
			    rnames[d], rnames[s]);
			break;
		}
		/* FALL-THROUGH */
	default:
		printf("\tmr %s,%s" COM "rmove\n", rnames[d], rnames[s]);
	}
}

/*
 * For class c, find worst-case displacement of the number of
 * registers in the array r[] indexed by class.
 *
 * On PowerPC, we have:
 *
 * 32 32-bit registers (2 reserved)
 * 16 64-bit pseudo registers
 * 32 floating-point registers
 */
int
COLORMAP(int c, int *r)
{
	int num = 0;

        switch (c) {
        case CLASSA:
                num += r[CLASSA];
                num += 2*r[CLASSB];
                return num < 30;
        case CLASSB:
                num += 2*r[CLASSB];
                num += r[CLASSA];
                return num < 16;
	case CLASSC:
		return num < 32;
        }
        assert(0);
        return 0; /* XXX gcc */
}

/*
 * Return a class suitable for a specific type.
 */
int
gclass(TWORD t)
{
	if (t == LONGLONG || t == ULONGLONG)
		return CLASSB;
	if (t == FLOAT || t == DOUBLE || t == LDOUBLE) {
		if (features(FEATURE_HARDFLOAT))
			return CLASSC;
		if (t == FLOAT)
			return CLASSA;
		else
			return CLASSB;
	}
	return CLASSA;
}

int
retreg(int t)
{
	int c = gclass(t);
	if (c == CLASSB)
		return R3R4;
	else if (c == CLASSC)
		return F1;
	return R3;
}

/*
 * Calculate argument sizes.
 */
void
lastcall(NODE *p)
{
	NODE *op = p;
	int size = 0;

#ifdef PCC_DEBUG
	if (x2debug)
		printf("lastcall:\n");
#endif

	p->n_qual = 0;
	if (p->n_op != CALL && p->n_op != FORTCALL && p->n_op != STCALL)
		return;

	for (p = p->n_right; p->n_op == CM; p = p->n_left)
		size += argsize(p->n_right);
	size += argsize(p);
	op->n_qual = size; /* XXX */
}

/*
 * Special shapes.
 */
int
special(NODE *p, int shape)
{
	int o = p->n_op;

	switch (shape) {
	case SFUNCALL:
		if (o == STCALL || o == USTCALL)
			return SRREG;
		break;
	case SPCON:
		if (o == ICON && p->n_name[0] == 0 && (p->n_lval & ~0x7fff) == 0)
			return SRDIR;
		break;
	}
	return SRNOPE;
}

static int fset = FEATURE_BIGENDIAN | FEATURE_HARDFLOAT;

/*
 * Target-dependent command-line options.
 */
void
mflags(char *str)
{
	if (strcasecmp(str, "big-endian") == 0) {
		fset |= FEATURE_BIGENDIAN;
	} else if (strcasecmp(str, "little-endian") == 0) {
		fset &= ~FEATURE_BIGENDIAN;
	} else if (strcasecmp(str, "soft-float") == 0) {
		fset &= ~FEATURE_HARDFLOAT;
	} else if (strcasecmp(str, "hard-float") == 0) {
		fset |= FEATURE_HARDFLOAT;
	} else {
		fprintf(stderr, "unknown m option '%s'\n", str);
		exit(1);
	}
}

int
features(int mask)
{
	return ((fset & mask) == mask);
}
@


1.7
log
@Sync with master repo. Reminded by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.6
log
@Sync with main repo.
@
text
@d1 1
a1 1
/*	$OpenBSD: local2.c,v 1.5 2007/12/22 14:05:04 stefan Exp $	*/
d37 2
a38 1
int argsize(NODE *p);
d40 38
a77 1
static int stkpos;
d79 1
a79 2
extern struct stub stublist;
extern struct stub nlplist;
d81 4
a84 16
static void
addstub(struct stub *list, char *name)
{
	struct stub *s;

	DLIST_FOREACH(s, list, link) {
		if (strcmp(s->name, name) == 0)
			return;
	}

	if ((s = malloc(sizeof(struct stub))) == NULL)
		cerror("addstub: malloc");
	if ((s->name = strdup(name)) == NULL)
		cerror("addstub: strdup");
	DLIST_INSERT_BEFORE(list, s, link);
}
a91 1
static int regoff[7];
a93 1
static char *funcname = NULL;
a95 1
 * addto and regoff are already calculated.
a96 75
static void
prtprolog(struct interpass_prolog *ipp, int addto)
{
#if 1
	int i, j;
#endif
	addto = FIXEDSTACKSIZE;

	// get return address (not required for leaf function)
	printf("	mflr %s\n", rnames[R0]);
	// save registers R30 and R31
	printf("	stmw %s,-8(%s)\n", rnames[R30], rnames[R1]);
	// save return address (not required for leaf function)
	printf("	stw %s,8(%s)\n", rnames[R0], rnames[R1]);
	// create the new stack frame
	printf("	stwu %s,-%d(%s)\n", rnames[R1], addto, rnames[R1]);

	if (kflag) {
		funcname = ipp->ipp_name;
		printf("	bcl 20,31,L%s$pb\n", exname(ipp->ipp_name));
		printf("L%s$pb:\n", exname(ipp->ipp_name));
		printf("	mflr %s\n", rnames[R31]);
	}

#ifdef PCC_DEBUG
	if (x2debug) {
		printf("ipp_regs = 0x%x\n", ipp->ipp_regs);
	}
#endif

	for (i = ipp->ipp_regs, j = 0; i; i >>= 1, j++) {
		if (i & 1) {
			printf("	stw %s,%d(%s)\n",
			    rnames[j], regoff[j], rnames[FPREG]);
		}
	}
}

/*
 * calculate stack size and offsets
 */
static int
offcalc(struct interpass_prolog *ipp)
{
	int i, j, addto;

#ifdef PCC_DEBUG
	if (x2debug)
		printf("offcalc: p2maxautooff=%d\n", p2maxautooff);
#endif

	addto = p2maxautooff;

	// space is always allocated on the stack to save the registers
	for (i = ipp->ipp_regs, j = 0; i ; i >>= 1, j++) {
		if (i & 1) {
			addto += SZINT/SZCHAR;
			regoff[j] = addto;
		}
	}

	addto += 8; /* for R31 and R30 */

	/* round to 16-byte boundary */
	addto += 15;
	addto &= ~15;

#ifdef PCC_DEBUG
	if (x2debug)
		printf("offcalc: addto=%d\n", addto);
#endif

	return addto;
}

d117 35
a151 10
	if (ipp->ipp_vis)
		printf("	.globl %s\n", exname(ipp->ipp_name));
	printf("	.align 2\n");
	printf("%s:\n", exname(ipp->ipp_name));
	/*
	 * We here know what register to save and how much to 
	 * add to the stack.
	 */
	addto = offcalc(ipp);
	prtprolog(ipp, addto);
d154 1
a157 1
	int i, j;
d167 3
a169 9
	/* return from function code */
	for (i = ipp->ipp_regs, j = 0; i ; i >>= 1, j++) {
		if (i & 1)
			printf("\tlwz %s,%d(%s)\n",
			    rnames[j], regoff[j], rnames[FPREG]);
			
	}

//	assert(ftype != ipp->ipp_type);
d171 3
a173 9
	/* struct return needs special treatment */
	if (ftype == STRTY || ftype == UNIONTY) {
		assert(0);
		printf("	movl 8(%%ebp),%%eax\n");
		printf("	leave\n");
		printf("	ret $4\n");
	} else {
		// unwind stack frame
		printf("\tlwz %s,0(%s)\n", rnames[R1], rnames[R1]);
a175 2
		printf("\tlmw %s,-8(%s)\n", rnames[R30], rnames[R1]);
		printf("\tblr\n");
d177 2
d287 4
a290 1
	expand(p, 0, "\tcmplw UR,UL		# compare 64-bit values (upper)\n");
d293 4
a296 1
	expand(p, 0, "\tcmplw AR,AL		# (and lower)\n");
d301 45
a345 1
#if 0
d347 1
a347 2
 * Assign to a bitfield.
 * Clumsy at least, but what to do?
d350 1
a350 1
bfasg(NODE *p)
d352 33
a384 45
	NODE *fn = p->n_left;
	int shift = UPKFOFF(fn->n_rval);
	int fsz = UPKFSZ(fn->n_rval);
	int andval, tch = 0;

	/* get instruction size */
	switch (p->n_type) {
	case CHAR: case UCHAR: tch = 'b'; break;
	case SHORT: case USHORT: tch = 'w'; break;
	case INT: case UNSIGNED: tch = 'l'; break;
	default: comperr("bfasg");
	}

	/* put src into a temporary reg */
	fprintf(stdout, "	mov%c ", tch);
	adrput(stdout, getlr(p, 'R'));
	fprintf(stdout, ",");
	adrput(stdout, getlr(p, '1'));
	fprintf(stdout, "\n");

	/* AND away the bits from dest */
	andval = ~(((1 << fsz) - 1) << shift);
	fprintf(stdout, "	and%c $%d,", tch, andval);
	adrput(stdout, fn->n_left);
	fprintf(stdout, "\n");

	/* AND away unwanted bits from src */
	andval = ((1 << fsz) - 1);
	fprintf(stdout, "	and%c $%d,", tch, andval);
	adrput(stdout, getlr(p, '1'));
	fprintf(stdout, "\n");

	/* SHIFT left src number of bits */
	if (shift) {
		fprintf(stdout, "	sal%c $%d,", tch, shift);
		adrput(stdout, getlr(p, '1'));
		fprintf(stdout, "\n");
	}

	/* OR in src to dest */
	fprintf(stdout, "	or%c ", tch);
	adrput(stdout, getlr(p, '1'));
	fprintf(stdout, ",");
	adrput(stdout, fn->n_left);
	fprintf(stdout, "\n");
a385 1
#endif
a386 5
#if 0
/*
 * Push a structure on stack as argument.
 * the scratch registers are already free here
 */
d388 1
a388 1
starg(NODE *p)
d390 2
a391 1
	FILE *fp = stdout;
d393 114
a506 7
	fprintf(fp, "	subl $%d,%%esp\n", p->n_stsize);
	fprintf(fp, "	pushl $%d\n", p->n_stsize);
	expand(p, 0, "	pushl AL\n");
	expand(p, 0, "	leal 8(%esp),A1\n");
	expand(p, 0, "	pushl A1\n");
	fprintf(fp, "	call memcpy\n");
	fprintf(fp, "	addl $12,%%esp\n");
a507 1
#endif
a508 1
#if 0
d510 1
a510 1
 * Compare two floating point numbers.
d512 1
d514 1
a514 1
fcomp(NODE *p)  
d516 52
a567 33
	if (p->n_left->n_op == REG) {
		if (p->n_su & DORIGHT)
			expand(p, 0, "	fxch\n");
		expand(p, 0, "	fucompp\n");	/* emit compare insn  */
	} else if (p->n_left->n_type == DOUBLE)
		expand(p, 0, "	fcompl AL\n");	/* emit compare insn  */
	else if (p->n_left->n_type == FLOAT)
		expand(p, 0, "	fcomp AL\n");	/* emit compare insn  */
	else
		comperr("bad compare %p\n", p);
	expand(p, 0, "	fnstsw %ax\n");	/* move status reg to ax */
	
	switch (p->n_op) {
	case EQ:
		expand(p, 0, "	andb $64,%ah\n	jne LC\n");
		break;
	case NE:
		expand(p, 0, "	andb $64,%ah\n	je LC\n");
		break;
	case LE:
		expand(p, 0, "	andb $65,%ah\n	cmpb $1,%ah\n	jne LC\n");
		break;
	case LT:
		expand(p, 0, "	andb $65,%ah\n	je LC\n");
		break;
	case GT:
		expand(p, 0, "	andb $1,%ah\n	jne LC\n");
		break;
	case GE:
		expand(p, 0, "	andb $65,%ah\n	jne LC\n");
		break;
	default:
		comperr("fcomp op %d\n", p->n_op);
a569 1
#endif
a570 1
#if 0
d572 1
a572 1
 * Convert an unsigned long long to floating point number.
d574 1
d576 1
a576 1
ulltofp(NODE *p)
d578 3
a580 2
	static int loadlab;
	int jmplab;
d582 14
a595 17
	if (loadlab == 0) {
		loadlab = getlab();
		expand(p, 0, "	.data\n");
		printf(LABFMT ":	.long 0,0x80000000,0x403f\n", loadlab);
		expand(p, 0, "	.text\n");
	}
	jmplab = getlab();
	expand(p, 0, "	pushl UL\n	pushl AL\n");
	expand(p, 0, "	fildq (%esp)\n");
	expand(p, 0, "	addl $8,%esp\n");
	expand(p, 0, "	cmpl $0,UL\n");
	printf("	jge " LABFMT "\n", jmplab);
	printf("	fldt " LABFMT "\n", loadlab);
	printf("	faddp %%st,%%st(1)\n");
	printf(LABFMT ":\n", jmplab);
}
#endif
d597 5
a601 4
static int
argsiz(NODE *p)
{
	TWORD t = p->n_type;
d603 1
a603 10
	if (t < LONGLONG || t == FLOAT || t > BTMASK)
		return 4;
	if (t == LONGLONG || t == ULONGLONG || t == DOUBLE)
		return 8;
	if (t == LDOUBLE)
		return 12;
	if (t == STRTY || t == UNIONTY)
		return p->n_stsize;
	comperr("argsiz");
	return 0;
d606 2
a607 2
void
zzzcode(NODE *p, int c)
d609 30
d640 13
a652 3
	NODE *r, *l;
	int pr, lr, s;
	char *ch;
a653 1
	char inst[50];
d655 22
a676 11
	switch (c) {
#if 0
	case 'C':  /* remove from stack after subroutine call */
		pr = p->n_qual;
		if (p->n_op == STCALL || p->n_op == USTCALL)
			pr += 4;
		if (p->n_op == UCALL)
			return; /* XXX remove ZC from UCALL */
		if (pr)
			printf("	addl $%d, %s\n", pr, rnames[ESP]);
		break;
d679 61
a739 3
	case 'D': /* Long long comparision */
		twollcomp(p);
		break;
d742 16
a757 3
	case 'E': /* Assign to bitfield */
		bfasg(p);
		break;
d759 5
a763 4
	case 'F': /* Structure argument */
		if (p->n_stalign != 0) /* already on stack */
			starg(p);
		break;
d765 1
a765 3
	case 'G': /* Floating point compare */
		fcomp(p);
		break;
d767 11
a777 3
	case 'J': /* convert unsigned long long to floating point */
		ulltofp(p);
		break;
a778 3
	case 'N': /* output extended reg name */
		printf("%s", rnames[getlr(p, '1')->n_rval]);
		break;
d781 6
a786 1
	case 'O': /* 64-bit left and right shift operators */
a787 18
		if (p->n_op == LS && p->n_right->n_lval < 32) {
			expand(p, INBREG, "\tsrwi A1,AL,32-AR        ; 64-bit left-shift\n");
			expand(p, INBREG, "\tslwi U1,UL,AR\n");
			expand(p, INBREG, "\tor U1,U1,A1\n");
			expand(p, INBREG, "\tslwi A1,AL,AR\n");
		} else if (p->n_op == LS) {
			expand(p, INBREG, "\tli A1,0	; 64-bit left-shift\n");
			expand(p, INBREG, "\tslwi U1,AL,AR-32\n");
		} else if (p->n_op == RS && p->n_right->n_lval < 32) {
			expand(p, INBREG, "\tslwi U1,UL,32-AR        ; 64-bit right-shift\n");
			expand(p, INBREG, "\tsrwi A1,AL,AR\n");
			expand(p, INBREG, "\tor A1,A1,U1\n");
			expand(p, INBREG, "\tsrwi U1,UL,AR\n");
		} else if (p->n_op == RS) {
			expand(p, INBREG, "\tli U1,0	; 64-bit right-shift\n");
			expand(p, INBREG, "\tsrwi A1,UL,AR-32\n");
		}
		break;
d789 4
d794 3
a796 20
#if 0
	case 'O': /* print out emulated ops */
		pr = 16;
		if (p->n_op == RS || p->n_op == LS) {
			expand(p, INAREG, "\tpushl AR\n");
			pr = 12;
		} else
			expand(p, INCREG, "\tpushl UR\n\tpushl AR\n");
		expand(p, INCREG, "\tpushl UL\n\tpushl AL\n");
		if (p->n_op == DIV && p->n_type == ULONGLONG) ch = "udiv";
		else if (p->n_op == DIV) ch = "div";
		else if (p->n_op == MUL) ch = "mul";
		else if (p->n_op == MOD && p->n_type == ULONGLONG) ch = "umod";
		else if (p->n_op == MOD) ch = "mod";
		else if (p->n_op == RS && p->n_type == ULONGLONG) ch = "lshr";
		else if (p->n_op == RS) ch = "ashr";
		else if (p->n_op == LS) ch = "ashl";
		else ch = 0, comperr("ZO");
		printf("\tbl __%sdi3\n\n", ch,);
                break;
d799 26
a824 8
#if 0
	case 'P': /* push hidden argument on stack */
		r = (NODE *)p->n_sue;
		printf("\tleal -%d(%%ebp),", stkpos);
		adrput(stdout, getlr(p, '1'));
		printf("\n\tpushl ");
		adrput(stdout, getlr(p, '1'));
		putchar('\n');
a825 1
#endif
d827 3
a829 3
	case 'Q': /* emit struct assign */
		if (p->n_stsize == 4) {
			int sz = sizeof inst;
d831 3
a833 6
			snprintf(inst, sz, "\tlwz %s,0(AR)\n", rnames[R5]);
			expand(p, INAREG, inst);
			snprintf(inst, sz, "\tstw %s,AL\n", rnames[R5]);
			expand(p, INAREG, inst);
			return;
		}
d835 2
a836 10
		if ((p->n_stsize & ~0xffff) != 0) {
			printf("\tlis %s,%d\n", rnames[R5], p->n_stsize & 0xffff);
			printf("\taddis %s,%s,%d\n", rnames[R5], rnames[R5], (p->n_stsize >> 16) & 0xffff);
		} else {
			printf("\tli %s,%d\n", rnames[R5], p->n_stsize);
		}
		printf("\taddi %s,%s,%lld\n", rnames[R3], rnames[p->n_left->n_rval], p->n_left->n_lval);
		printf("\tbl %s%s\n", exname("memcpy"),
		    kflag ? "$stub" : "");
		addstub(&stublist, exname("memcpy"));
d857 2
a858 2
	if (o==NAME || o==REG || o==ICON || o==OREG ||
	    (o==UMUL && shumul(p->n_left)))
d860 1
a860 1
	return(0);
d866 26
a891 1
	return 0;
d924 1
a924 1
		return (!istreg(p->n_rval));
d927 1
a927 1
		r = p->n_rval;
a954 1
	char *s;
d959 3
a961 30
#if 0
		if (p->n_sp)
			printf(" [class=%d,level=%d] ", p->n_sp->sclass, p->n_sp->slevel);
#endif
		if (p->n_sp == NULL || (p->n_sp->sclass == ILABEL ||
		   (p->n_sp->sclass == STATIC && p->n_sp->slevel > 0)))
			s = p->n_name;
		else
			s = exname(p->n_name);
			
		if (*s != '\0') {
			if (kflag && p->n_sp && ISFTN(p->n_sp->stype)) {
				if (p->n_sp && p->n_sp->sclass == EXTERN) {
					fprintf(fp, "%s$stub", s);
					addstub(&stublist, s);
				} else {
					fprintf(fp, "%s", s);
				}
			} else if (kflag) {
				if (p->n_sp && p->n_sp->sclass == EXTERN) {
					fprintf(fp, "L%s$non_lazy_ptr", s);
					addstub(&nlplist, s);
				} else {
					fprintf(fp, "%s", s);
				}
				fprintf(fp, "-L%s$pb", exname(funcname));
			} else {
				fprintf(fp, "%s", s);
			}
			if (val > 0)
d963 6
a968 4
			else if (val < 0)
				fprintf(fp, "-%d", -val);
		} else
			fprintf(fp, "%d", val);
d987 1
a987 1
reg64name(int rval, int hi)
d989 2
a990 1
	int off = 3 * (hi != 0);
d992 3
a994 3
#ifdef ELFABI
	fputc('%', stdout);
#endif
d996 5
a1000 5
	fprintf(stdout, "%c%c",
		 rnames[rval][off],
		 rnames[rval][off + 1]);
	if (rnames[rval][off + 2])
		fputc(rnames[rval][off + 2], stdout);
a1009 1

d1013 1
a1013 1
		reg64name(p->n_rval, 1);
d1018 5
a1022 3
		p->n_lval += size;
		adrput(stdout, p);
		p->n_lval -= size;
d1024 1
d1028 1
a1036 1
	int r;
d1046 1
a1046 13
			if (kflag && p->n_sp && (p->n_sp->sclass == EXTERN || p->n_sp->sclass == EXTDEF)) {
				fprintf(io, "L%s$non_lazy_ptr", exname(p->n_name));
				addstub(&nlplist, exname(p->n_name));
				fprintf(io, "-L%s$pb", exname(funcname));
			} else if (kflag && p->n_sp && p->n_sp->sclass == STATIC && p->n_sp->slevel == 0) {
				fprintf(io, "%s", exname(p->n_name));
				fprintf(io, "-L%s$pb", exname(funcname));
			} else if (kflag && p->n_sp && (p->n_sp->sclass == ILABEL || (p->n_sp->sclass == STATIC && p->n_sp->sclass > 0))) {
				fprintf(io, "%s", p->n_name);
				fprintf(io, "-L%s$pb", exname(funcname));
			} else {
				fputs(p->n_name, io);
			}
d1054 6
a1059 3
		r = p->n_rval;
		fprintf(io, "%d", (int)p->n_lval);
		fprintf(io, "(%s)", rnames[p->n_rval]);
a1066 1
	case MOVE:
d1068 5
d1074 7
d1083 1
a1083 1
			reg64name(p->n_rval, 0);
d1086 1
a1086 1
			fprintf(io, "%s", rnames[p->n_rval]);
d1088 1
d1129 34
d1166 2
a1167 1
	/* Prepare for struct return by allocating bounce space on stack */
d1170 5
d1176 5
a1180 2
		if (p->n_stsize+p2autooff > stkpos)
			stkpos = p->n_stsize+p2autooff;
d1211 1
a1211 1
                	ll = mklnode(OREG, off, FPREG, t);
d1213 1
a1213 1
			p->n_left = mklnode(OREG, off, FPREG, t);
d1233 4
a1236 1
	stkpos = p2autooff;
d1243 22
a1264 4
	if (stkpos > p2autooff)
		p2autooff = stkpos;
	if (stkpos > p2maxautooff)
		p2maxautooff = stkpos;
d1321 8
d1334 1
a1334 1
			reg64name(d,0);
d1336 1
a1336 1
			reg64name(s,0);
d1339 1
a1339 1
			reg64name(d,1);
d1341 1
a1341 1
			reg64name(s,1);
d1346 1
a1346 1
			reg64name(d,1);
d1348 1
a1348 1
			reg64name(s,1);
d1351 1
a1351 1
			reg64name(d,0);
d1353 1
a1353 1
			reg64name(s,0);
d1357 7
a1363 6
	case LDOUBLE:
#ifdef notdef
		/* a=b()*c(); will generate this */
		comperr("bad float rmove: %d %d", s, d);
#endif
		break;
d1365 1
a1365 1
		printf("\tmr %s,%s\n", rnames[d], rnames[s]);
d1384 14
a1397 12
	switch (c) {
	case CLASSA:
		num += r[CLASSA];
		num += 2*r[CLASSB];
		return num < 30;
	case CLASSB:
		num += 2*r[CLASSB];
		num += r[CLASSA];
		return num < 16;
	}
	assert(0);
	return 0; /* XXX gcc */
a1399 26
#ifdef ELFABI
char *rnames[] = {
	"%r0", "%r1", "%r2", "%r3","%r4","%r5", "%r6", "%r7", "%r8",
	"%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15", "%r16",
	"%r17", "%r18", "%r19", "%r20", "%r21", "%r22", "%r23", "%r24",
	"%r25", "%r26", "%r27", "%r28", "%r29", "%r30", "%r31",
	/* the order is flipped, because we are big endian */
	"r4\0r3\0", "r5\0r4\0", "r6\0r5\0", "r7\0r6\0",
	"r8\0r7\0", "r9\0r8\0", "r10r9\0", "r15r14", "r17r16",
	"r19r18", "r21r20", "r23r22", "r25r24", "r27r26",
	"r29r28", "r31r30",
};
#else
char *rnames[] = {
	"r0", "r1", "r2", "r3","r4","r5", "r6", "r7", "r8",
	"r9", "r10", "r11", "r12", "r13", "r14", "r15", "r16",
	"r17", "r18", "r19", "r20", "r21", "r22", "r23", "r24",
	"r25", "r26", "r27", "r28", "r29", "r30", "r31",
	/* the order is flipped, because we are big endian */
	"r4\0r3\0", "r5\0r4\0", "r6\0r5\0", "r7\0r6\0",
	"r8\0r7\0", "r9\0r8\0", "r10r9\0", "r15r14", "r17r16",
	"r19r18", "r21r20", "r23r22", "r25r24", "r27r26",
	"r29r28", "r31r30",
};
#endif

d1406 1
a1406 1
	if (t == FLOAT || t == DOUBLE || t == LDOUBLE)
d1408 8
d1419 11
d1447 1
d1449 2
a1450 2
		size += argsiz(p->n_right);
	size += argsiz(p);
d1468 1
a1468 1
		if (o == ICON && p->n_name[0] == 0 && (p->n_lval & ~0xffff) == 0)
d1475 2
d1483 18
@


1.5
log
@Sync with main repo.
@
text
@d1 1
a1 1
/*	$OpenBSD: local2.c,v 1.4 2007/11/25 12:54:09 stefan Exp $	*/
d650 6
@


1.4
log
@Pull from master repo:
Check malloc/strdup return values.
@
text
@d1 1
a1 1
/*	$OpenBSD: local2.c,v 1.3 2007/11/03 09:55:56 stefan Exp $	*/
d327 1
a327 1
	expand(p, 0, "	cmpl UR,UL\n");
d330 1
a330 1
	expand(p, 0, "	cmpl AR,AL\n");
d508 1
a604 1
#if 0
d606 2
a607 8
		/* XXX - optimize for small structs */
		printf("\tpushl $%d\n", p->n_stsize);
		expand(p, INAREG, "\tpushl AR\n");
		expand(p, INAREG, "\tleal AL,%eax\n\tpushl %eax\n");
		printf("\tcall memcpy\n");
		printf("\taddl $12,%%esp\n");
		break;
#endif
d609 6
a614 38
#if 0
	case 'S': /* emit eventual move after cast from longlong */
		pr = DECRA(p->n_reg, 0);
		lr = p->n_left->n_rval;
		switch (p->n_type) {
		case CHAR:
		case UCHAR:
			if (rnames[pr][2] == 'l' && rnames[lr][2] == 'x' &&
			    rnames[pr][1] == rnames[lr][1])
				break;
			if (rnames[lr][2] == 'x') {
				printf("\tmovb %%%cl,%s\n",
				    rnames[lr][1], rnames[pr]);
				break;
			}
			/* Must go via stack */
			s = BITOOR(freetemp(1));
			printf("\tmovl %%e%ci,%d(%%ebp)\n", rnames[lr][1], s);
			printf("\tmovb %d(%%ebp),%s\n", s, rnames[pr]);
//			comperr("SCONV1 %s->%s", rnames[lr], rnames[pr]);
			break;

		case SHORT:
		case USHORT:
			if (rnames[lr][1] == rnames[pr][2] &&
			    rnames[lr][2] == rnames[pr][3])
				break;
			printf("\tmovw %%%c%c,%%%s\n",
			    rnames[lr][1], rnames[lr][2], rnames[pr]+2);
			break;
		case INT:
		case UNSIGNED:
			if (rnames[lr][1] == rnames[pr][2] &&
			    rnames[lr][2] == rnames[pr][3])
				break;
			printf("\tmovl %%e%c%c,%s\n",
				    rnames[lr][1], rnames[lr][2], rnames[pr]);
			break;
d616 5
a620 6
		default:
			if (rnames[lr][1] == rnames[pr][2] &&
			    rnames[lr][2] == rnames[pr][3])
				break;
			comperr("SCONV2 %s->%s", rnames[lr], rnames[pr]);
			break;
d622 4
a627 2
#endif

d730 6
a735 2
				fprintf(fp, "%s$stub", s);
				addstub(&stublist, s);
d1025 6
a1030 7
#if 0
static char rl[] =
  { EAX, EAX, EAX, EAX, EAX, EDX, EDX, EDX, EDX, ECX, ECX, ECX, EBX, EBX, ESI };
static char rh[] =
  { EDX, ECX, EBX, ESI, EDI, ECX, EBX, ESI, EDI, EBX, ESI, EDI, ESI, EDI, EDI };
#endif

a1033 3
#if 0
	int sl, sh, dl, dh;

d1037 24
a1060 18
#if 1
		sl = rl[s-EAXEDX];
		sh = rh[s-EAXEDX];
		dl = rl[d-EAXEDX];
		dh = rh[d-EAXEDX];

		/* sanity checks, remove when satisfied */
		if (memcmp(rnames[s], rnames[sl]+1, 3) != 0 ||
		    memcmp(rnames[s]+3, rnames[sh]+1, 3) != 0)
			comperr("rmove source error");
		if (memcmp(rnames[d], rnames[dl]+1, 3) != 0 ||
		    memcmp(rnames[d]+3, rnames[dh]+1, 3) != 0)
			comperr("rmove dest error");
#define	SW(x,y) { int i = x; x = y; y = i; }
		if (sl == dh || sh == dl) {
			/* Swap if moving to itself */
			SW(sl, sh);
			SW(dl, dh);
a1061 18
		if (sl != dl)
			printf("	movl %s,%s\n", rnames[sl], rnames[dl]);
		if (sh != dh)
			printf("	movl %s,%s\n", rnames[sh], rnames[dh]);
#else
		if (memcmp(rnames[s], rnames[d], 3) != 0)
			printf("	movl %%%c%c%c,%%%c%c%c\n",
			    rnames[s][0],rnames[s][1],rnames[s][2],
			    rnames[d][0],rnames[d][1],rnames[d][2]);
		if (memcmp(&rnames[s][3], &rnames[d][3], 3) != 0)
			printf("	movl %%%c%c%c,%%%c%c%c\n",
			    rnames[s][3],rnames[s][4],rnames[s][5],
			    rnames[d][3],rnames[d][4],rnames[d][5]);
#endif
		break;
	case CHAR:
	case UCHAR:
		printf("	movb %s,%s\n", rnames[s], rnames[d]);
a1062 2
	case FLOAT:
	case DOUBLE:
d1070 1
a1070 1
		printf("	movl %s,%s\n", rnames[s], rnames[d]);
a1071 1
#endif
d1077 6
d1087 1
a1087 3
	return 1;
#if 0
	int num;
a1090 2
		num = r[CLASSB] > 4 ? 4 : r[CLASSB];
		num += 2*r[CLASSC];
d1092 2
a1093 1
		return num < 6;
d1095 3
a1097 11
		num = r[CLASSA];
		num += 2*r[CLASSC];
		num += r[CLASSB];
		return num < 4;
	case CLASSC:
		num = r[CLASSA];
		num += r[CLASSB] > 4 ? 4 : r[CLASSB];
		num += 2*r[CLASSC];
		return num < 5;
	case CLASSD:
		return r[CLASSD] < DREGCNT;
d1099 1
a1100 1
#endif
d1182 8
@


1.3
log
@Print out names of register pairs correctly. ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: local2.c,v 1.2 2007/11/01 10:52:58 otto Exp $	*/
d54 4
a57 2
	s = malloc(sizeof(struct stub));
	s->name = strdup(name);
@


1.2
log
@Pull from master repo, commit by myself:
next step for ELFABI, hello world works with ELFABI, but register
pairs still produce wrong assembly; with Dale Rahn
@
text
@d1 1
a1 1
/*	$OpenBSD: local2.c,v 1.3 2007/10/31 00:47:23 gmcgarry Exp $	*/
d799 19
d828 1
a828 5
		fprintf(stdout, "%c%c",
			 rnames[p->n_rval][3],
			 rnames[p->n_rval][4]);
		if (rnames[p->n_rval][5])
			fputc(rnames[p->n_rval][5], stdout);
d893 1
a893 5
			fprintf(stdout, "%c%c",
				 rnames[p->n_rval][0],
				 rnames[p->n_rval][1]);
			if (rnames[p->n_rval][2])
				fputc(rnames[p->n_rval][2], stdout);
d1165 4
a1168 4
	"%r4\0%r3\0", "%r5\0%r4\0", "%r6\0%r5\0", "%r7\0%r6\0",
	"%r8\0%r7\0", "%r9\0%r8\0", "%r10%r9\0", "%r15%r14", "%r17%r16",
	"%r19%r18", "%r21%r20", "%r23%r22", "%r25%r24", "%r27%r26",
	"%r29%r28", "%r31%r30",
@


1.1
log
@Start of a powerpc backend by Gregory McGarry. Not complete yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: local2.c,v 1.1 2007/10/19 18:34:53 gmcgarry Exp $	*/
a59 7
lineid(int l, char *fn)
{
	/* identify line l and file fn */
	printf("#	line %d, file %s\n", l, fn);
}

void
d84 1
a84 1
	printf("	stmw %s, -8(%s)\n", rnames[R30], rnames[R1]);
d86 1
a86 1
	printf("	stw %s, 8(%s)\n", rnames[R0], rnames[R1]);
d88 1
a88 1
	printf("	stwu %s, -%d(%s)\n", rnames[R1], addto, rnames[R1]);
d196 1
a196 1
			printf("	lwz %s, %d(%s)\n",
d211 5
a215 5
		printf("	lwz %s,0(%s)\n", rnames[R1], rnames[R1]);
		printf("	lwz %s,8(%s)\n", rnames[R0], rnames[R1]);
		printf("	mtlr %s\n", rnames[R0]);
		printf("	lmw %s,-8(%s)\n", rnames[R30], rnames[R1]);
		printf("	blr\n");
d256 1
a256 1
tlen(p) NODE *p;
d754 2
a755 1
		printf("XXX type = %x\n", p->n_type);
d757 4
a760 5
		if (p->n_sp != NULL &&
#if 0
		   (p->n_sp->sclass != STATIC) &&
#endif
		   (p->n_sp->sclass != ILABEL))
a761 2
		else
			s = p->n_name;
d767 2
a768 3
			} else if (kflag && p->n_sp) {
//				printf("sclass=%x sflags=%x\n", p->n_sp->sclass, p->n_sp->sflags);
				if (p->n_sp && (p->n_sp->sclass != STATIC && p->n_sp->sflags != SSTRING)) {
d843 1
a843 1
			if (kflag && p->n_sp && (p->n_sp->sclass == STATIC || p->n_sp->sflags != SSTRING)) {
d847 1
a847 1
			} else if (kflag) {
d850 6
a855 2
			} else
				fputs(exname(p->n_name), io);
d924 1
a924 1
	printf("	%s " LABFMT "\n", ccbranches[o-EQ], lab);
d1147 13
d1171 1
d1220 2
a1221 3
#if 0
	case SSYMBOL:
		if (p->n_op == NAME && !kflag)
d1223 1
a1223 1
#endif
@

