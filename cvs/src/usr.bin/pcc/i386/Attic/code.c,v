head	1.10;
access;
symbols
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.14
	OPENBSD_5_0:1.9.0.12
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7;
locks; strict;
comment	@ * @;


1.10
date	2012.04.12.11.51.13;	author pirofti;	state dead;
branches;
next	1.9;

1.9
date	2008.08.17.18.40.13;	author ragge;	state Exp;
branches;
next	1.8;

1.8
date	2008.04.11.20.45.52;	author stefan;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.12.17.29.09;	author ragge;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.09.18.54.39;	author ragge;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.22.15.06.43;	author stefan;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.18.17.39.55;	author ragge;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.16.09.00.12;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.04.18.55.21;	author ragge;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.22.13.39.37;	author otto;	state Exp;
branches;
next	;


desc
@@


1.10
log
@tedu(tm) pcc.

Message sent. Okay deraadt@@.
@
text
@/*	$OpenBSD: code.c,v 1.9 2008/08/17 18:40:13 ragge Exp $	*/
/*
 * Copyright (c) 2003 Anders Magnusson (ragge@@ludd.luth.se).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


# include "pass1.h"

int lastloc = -1;

/*
 * Define everything needed to print out some data (or text).
 * This means segment, alignment, visibility, etc.
 */
void
defloc(struct symtab *sp)
{
	extern char *nextsect;
#if defined(ELFABI) || defined(PECOFFABI)
	static char *loctbl[] = { "text", "data", "section .rodata" };
#elif defined(MACHOABI)
	static char *loctbl[] = { "text", "data", "const_data" };
#endif
	TWORD t;
	int s;

	if (sp == NULL) {
		lastloc = -1;
		return;
	}
	t = sp->stype;
	s = ISFTN(t) ? PROG : ISCON(cqual(t, sp->squal)) ? RDATA : DATA;
#ifdef TLS
	if (sp->sflags & STLS) {
		if (s != DATA)
			cerror("non-data symbol in tls section");
		nextsect = ".tdata";
	}
#endif
	if (nextsect) {
		printf("	.section %s\n", nextsect);
		nextsect = NULL;
		s = -1;
	} else if (s != lastloc)
		printf("	.%s\n", loctbl[s]);
	lastloc = s;
	while (ISARY(t))
		t = DECREF(t);
	if (t > UCHAR)
		printf("	.align %d\n", t > USHORT ? 4 : 2);
	if (sp->sclass == EXTDEF)
		printf("	.globl %s\n", exname(sp->soname));
#if defined(ELFABI)
	if (ISFTN(t))
		printf("\t.type %s,@@function\n", exname(sp->soname));
#endif
	if (sp->slevel == 0)
		printf("%s:\n", exname(sp->soname));
	else
		printf(LABFMT ":\n", sp->soffset);
}

/*
 * code for the end of a function
 * deals with struct return here
 */
void
efcode()
{
	extern int gotnr;
	NODE *p, *q;

	gotnr = 0;	/* new number for next fun */
	if (cftnsp->stype != STRTY+FTN && cftnsp->stype != UNIONTY+FTN)
		return;
	/* Create struct assignment */
	q = block(OREG, NIL, NIL, PTR+STRTY, 0, cftnsp->ssue);
	q->n_rval = EBP;
	q->n_lval = 8; /* return buffer offset */
	q = buildtree(UMUL, q, NIL);
	p = block(REG, NIL, NIL, PTR+STRTY, 0, cftnsp->ssue);
	p = buildtree(UMUL, p, NIL);
	p = buildtree(ASSIGN, q, p);
	ecomp(p);
}

/*
 * code for the beginning of a function; a is an array of
 * indices in symtab for the arguments; n is the number
 */
void
bfcode(struct symtab **sp, int cnt)
{
#ifdef os_win32
	extern int argstacksize;
#endif
	struct symtab *sp2;
	extern int gotnr;
	NODE *n, *p;
	int i;

	if (cftnsp->stype == STRTY+FTN || cftnsp->stype == UNIONTY+FTN) {
		/* Function returns struct, adjust arg offset */
		for (i = 0; i < cnt; i++) 
			sp[i]->soffset += SZPOINT(INT);
	}

#ifdef os_win32
	/*
	 * Count the arguments and mangle name in symbol table as a callee.
	 */
	argstacksize = 0;
	if (cftnsp->sflags & SSTDCALL) {
		char buf[64];
		for (i = 0; i < cnt; i++) {
			TWORD t = sp[i]->stype;
			if (t == STRTY || t == UNIONTY)
				argstacksize += sp[i]->ssue->suesize;
			else
				argstacksize += szty(t) * SZINT / SZCHAR;
		}
		snprintf(buf, 64, "%s@@%d", cftnsp->soname, argstacksize);
		cftnsp->soname = newstring(buf, strlen(buf));
	}
#endif

	if (kflag) {
		/* Put ebx in temporary */
		n = block(REG, NIL, NIL, INT, 0, MKSUE(INT));
		n->n_rval = EBX;
		p = tempnode(0, INT, 0, MKSUE(INT));
		gotnr = regno(p);
		ecomp(buildtree(ASSIGN, p, n));
	}
	if (xtemps == 0)
		return;

	/* put arguments in temporaries */
	for (i = 0; i < cnt; i++) {
		if (sp[i]->stype == STRTY || sp[i]->stype == UNIONTY ||
		    cisreg(sp[i]->stype) == 0)
			continue;
		sp2 = sp[i];
		n = tempnode(0, sp[i]->stype, sp[i]->sdf, sp[i]->ssue);
		n = buildtree(ASSIGN, n, nametree(sp2));
		sp[i]->soffset = regno(n->n_left);
		sp[i]->sflags |= STNODE;
		ecomp(n);
	}
}


/*
 * by now, the automatics and register variables are allocated
 */
void
bccode()
{
	SETOFF(autooff, SZINT);
}

#if defined(MACHOABI)
struct stub stublist;
struct stub nlplist;
#endif

/* called just before final exit */
/* flag is 1 if errors, 0 if none */
void
ejobcode(int flag )
{
#if defined(MACHOABI)
	/*
	 * iterate over the stublist and output the PIC stubs
`	 */
	if (kflag) {
		struct stub *p;

		DLIST_FOREACH(p, &stublist, link) {
			printf("\t.section __IMPORT,__jump_table,symbol_stubs,self_modifying_code+pure_instructions,5\n");
			printf("L%s$stub:\n", p->name);
			printf("\t.indirect_symbol %s\n", exname(p->name));
			printf("\thlt ; hlt ; hlt ; hlt ; hlt\n");
			printf("\t.subsections_via_symbols\n");
		}

		printf("\t.section __IMPORT,__pointers,non_lazy_symbol_pointers\n");
		DLIST_FOREACH(p, &nlplist, link) {
			printf("L%s$non_lazy_ptr:\n", p->name);
			printf("\t.indirect_symbol %s\n", exname(p->name));
			printf("\t.long 0\n");
	        }

	}
#endif

#define _MKSTR(x) #x
#define MKSTR(x) _MKSTR(x)
#define OS MKSTR(TARGOS)
        printf("\t.ident \"PCC: %s (%s)\"\n", PACKAGE_STRING, OS);
}

void
bjobcode()
{
#if defined(MACHOABI)
	DLIST_INIT(&stublist, link);
	DLIST_INIT(&nlplist, link);
#endif
}

/*
 * Called with a function call with arguments as argument.
 * This is done early in buildtree() and only done once.
 * Returns p.
 */
NODE *
funcode(NODE *p)
{
	extern int gotnr;
	NODE *r, *l;

	/* Fix function call arguments. On x86, just add funarg */
	for (r = p->n_right; r->n_op == CM; r = r->n_left) {
		if (r->n_right->n_op != STARG)
			r->n_right = block(FUNARG, r->n_right, NIL,
			    r->n_right->n_type, r->n_right->n_df,
			    r->n_right->n_sue);
	}
	if (r->n_op != STARG) {
		l = talloc();
		*l = *r;
		r->n_op = FUNARG;
		r->n_left = l;
		r->n_type = l->n_type;
	}
	if (kflag == 0)
		return p;
#if defined(ELFABI)
	/* Create an ASSIGN node for ebx */
	l = block(REG, NIL, NIL, INT, 0, MKSUE(INT));
	l->n_rval = EBX;
	l = buildtree(ASSIGN, l, tempnode(gotnr, INT, 0, MKSUE(INT)));
	if (p->n_right->n_op != CM) {
		p->n_right = block(CM, l, p->n_right, INT, 0, MKSUE(INT));
	} else {
		for (r = p->n_right; r->n_left->n_op == CM; r = r->n_left)
			;
		r->n_left = block(CM, l, r->n_left, INT, 0, MKSUE(INT));
	}
#endif
	return p;
}

/*
 * return the alignment of field of type t
 */
int
fldal(unsigned int t)
{
	uerror("illegal field type");
	return(ALINT);
}

/* fix up type of field p */
void
fldty(struct symtab *p)
{
}

/*
 * XXX - fix genswitch.
 */
int
mygenswitch(int num, TWORD type, struct swents **p, int n)
{
	return 0;
}
@


1.9
log
@Updates from master repo.  Can now compile both userland and kernel.
(with some patches...)
@
text
@d1 1
a1 1
/*	$OpenBSD: code.c,v 1.8 2008/04/11 20:45:52 stefan Exp $	*/
@


1.8
log
@Sync with master repo. Reminded by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: code.c,v 1.7 2008/01/12 17:29:09 ragge Exp $	*/
d32 2
d42 1
d44 3
a46 1
	static int lastloc = -1;
d75 5
a79 1
		printf("	.globl %s\n", sp->soname);
d81 1
a81 1
		printf("%s:\n", sp->soname);
d117 4
d130 20
d166 1
a166 1
		spname = sp[i];
d168 1
a168 1
		n = buildtree(ASSIGN, n, buildtree(NAME, 0, 0));
d185 5
d195 29
d229 4
d262 1
d274 1
@


1.7
log
@Updates from master repo:
> Change to new initializer handling.
> Make prtdcon() target dependent to allow for float constants in code.
@
text
@d1 1
a1 1
/*	$OpenBSD: code.c,v 1.6 2007/12/09 18:54:39 ragge Exp $	*/
d51 7
@


1.6
log
@Updates from master repo:
- Add support for PIC code.
@
text
@d1 1
a1 1
/*	$OpenBSD: code.c,v 1.5 2007/11/22 15:06:43 stefan Exp $	*/
d33 2
a34 2
 * cause the alignment to become a multiple of n
 * never called for text segment.
d37 1
a37 1
defalign(int n)
d39 8
a46 2
	n /= SZCHAR;
	if (n == 1)
d48 20
a67 18
	printf("	.align %d\n", n);
}

/*
 * define the current location as the name p->sname
 * never called for text segment.
 */
void
defnam(struct symtab *p)
{
	char *c = p->sname;

#ifdef GCC_COMPAT
	c = gcc_findname(p);
#endif
	if (p->sclass == EXTDEF)
		printf("	.globl %s\n", c);
	printf("%s:\n", c);
a69 1

d115 1
a115 1
		gotnr = p->n_lval;
d129 1
a129 1
		sp[i]->soffset = n->n_left->n_lval;
a195 34
}

/*
 * Print character t at position i in one string, until t == -1.
 * Locctr & label is already defined.
 */
void
bycode(int t, int i)
{
	static	int	lastoctal = 0;

	/* put byte i+1 in a string */

	if (t < 0) {
		if (i != 0)
			puts("\"");
	} else {
		if (i == 0)
			printf("\t.ascii \"");
		if (t == '\\' || t == '"') {
			lastoctal = 0;
			putchar('\\');
			putchar(t);
		} else if (t < 040 || t >= 0177) {
			lastoctal++;
			printf("\\%o",t);
		} else if (lastoctal && '0' <= t && t <= '9') {
			lastoctal = 0;
			printf("\"\n\t.ascii \"%c", t);
		} else {	
			lastoctal = 0;
			putchar(t);
		}
	}
@


1.5
log
@Pull from master repo:

Put the genswitch() code that is found in most backends into
the MI part. The backend version is renamed to mygenswitch()
and can provide improved translations for switch statements.

Improved implementation of the switch constraints/semantics
described in the standard.

ok ragge@@, otto@@

With help and comments from ragge and gmcgarry
@
text
@d1 1
a1 1
/*	$OpenBSD: code.c,v 1.4 2007/11/18 17:39:55 ragge Exp $	*/
d186 1
a186 1
		r->n_left = block(CM, l, p->n_left, INT, 0, MKSUE(INT));
a222 10
}

/*
 * n integer words of zeros
 */
void
zecode(int n)
{
	printf("	.zero %d\n", n * (SZINT/SZCHAR));
//	inoff += n * SZINT;
@


1.4
log
@(Large) update from master repo:
> Use structure assignment instead of calling memcpy directly in struct return.
> Rewrite enum handling.
> In C99 enums are treated like INTs so convert them early to int.
> Move the enum tag handling out of defid(), tags are in their own namespace.
> This will be done with struct/union tags also.
> Comment out enum types.
> Remove ENUMTY/MOETY from target code.
@
text
@d1 1
a1 1
/*	$OpenBSD: code.c,v 1.3 2007/11/16 09:00:12 otto Exp $	*/
d251 1
a251 5
/* p points to an array of structures, each consisting
 * of a constant value and a label.
 * The first is >=0 if there is a default label;
 * its value is the label number
 * The entries p[1] to p[n] are the nontrivial cases
d254 2
a255 2
void
genswitch(int num, struct swents **p, int n)
d257 1
a257 12
	NODE *r;
	int i;

	/* simple switch code */
	for (i = 1; i <= n; ++i) {
		/* already in 1 */
		r = tempnode(num, INT, 0, MKSUE(INT));
		r = buildtree(NE, r, bcon(p[i]->sval));
		cbranch(buildtree(NOT, r, NIL), bcon(p[i]->slab));
	}
	if (p[0]->slab > 0)
		branch(p[0]->slab);
@


1.3
log
@sync tree with master repo; Nov 16 2007
@
text
@d1 1
a1 1
/*	$OpenBSD: code.c,v 1.17 2007/11/12 19:02:15 ragge Exp $	*/
a71 1
	int sz;
d76 2
a77 6
	/* address of return struct is in eax */
	/* create a call to memcpy() */
	/* will get the result in eax */
	p = block(REG, NIL, NIL, CHAR+PTR, 0, MKSUE(CHAR+PTR));
	p->n_rval = EAX;
	q = block(OREG, NIL, NIL, CHAR+PTR, 0, MKSUE(CHAR+PTR));
d80 5
a84 8
	p = block(CM, q, p, INT, 0, MKSUE(INT));
	sz = (tsize(STRTY, cftnsp->sdf, cftnsp->ssue)+SZCHAR-1)/SZCHAR;
	p = block(CM, p, bcon(sz), INT, 0, MKSUE(INT));
	p->n_right->n_name = "";
	p = block(CALL, bcon(0), p, CHAR+PTR, 0, MKSUE(CHAR+PTR));
	p->n_left->n_name = "memcpy";
	p = clocal(p);
	send_passt(IP_NODE, p);
@


1.2
log
@Update from master repo:
> Work in progress: PIC code for i386.
> Still missing: ebx as argument to functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: code.c,v 1.1 2007/10/22 13:39:37 otto Exp $	*/
d100 1
a100 1
bfcode(struct symtab **a, int n)
d102 2
d106 14
a119 1
	if (cftnsp->stype != STRTY+FTN && cftnsp->stype != UNIONTY+FTN)
d121 13
a133 3
	/* Function returns struct, adjust arg offset */
	for (i = 0; i < n; i++)
		a[i]->soffset += SZPOINT(INT);
d156 41
@


1.1
log
@move from x86 to i386; gentle push by deraadt@@, ok ragge@@
@
text
@d1 1
a1 1
/*	$OpenBSD: code.c,v 1.1 2007/10/07 17:58:52 otto Exp $	*/
d70 1
d74 1
@

