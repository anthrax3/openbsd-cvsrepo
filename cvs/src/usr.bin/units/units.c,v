head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.6
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.20.0.10
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.4
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.17.0.4
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.14.0.18
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.16
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.14
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.10
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.12
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.8
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.10
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.8
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.6
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	sbrB3Q5CNxcwZpfU;

1.21
date	2015.10.06.13.29.56;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	7BRjIdHv6svYhVlJ;

1.20
date	2013.11.27.00.13.24;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2013.11.17.20.19.36;	author okan;	state Exp;
branches;
next	1.18;

1.18
date	2013.01.04.19.31.28;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2011.10.07.20.07.25;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2011.10.06.23.27.04;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2011.10.06.17.58.04;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.29.20.13.57;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.24.03.28.16;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.20.01.56.12;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.02.22.54.55;	author pat;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.01.16.41.07;	author pat;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.02.01.57.15;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.10.22.20.53;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.17.19.29.49;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.06.13.16.34.21;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	97.07.08.18.32.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.08.11.00.17.31;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.42.15;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.44.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.30;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Change all tame callers to namechange to pledge(2).
@
text
@/*	$OpenBSD: units.c,v 1.21 2015/10/06 13:29:56 deraadt Exp $	*/
/*	$NetBSD: units.c,v 1.6 1996/04/06 06:01:03 thorpej Exp $	*/

/*
 * units.c   Copyright (c) 1993 by Adrian Mariano (adrian@@cam.cornell.edu)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * Disclaimer:  This software is provided by the author "as is".  The author
 * shall not be liable for any damages caused in any way by this software.
 *
 * I would appreciate (though I do not require) receiving a copy of any
 * improvements you might make to this program.
 */

#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <err.h>

#define UNITSFILE "/usr/share/misc/units.lib"

#define VERSION "1.0"

#define MAXUNITS 1000
#define MAXPREFIXES 100

#define MAXSUBUNITS 500

#define PRIMITIVECHAR '!'

char *powerstring = "^";

struct {
	char *uname;
	char *uval;
} unittable[MAXUNITS];

struct unittype {
	char *numerator[MAXSUBUNITS];
	char *denominator[MAXSUBUNITS];
	double factor;
};

struct {
	char *prefixname;
	char *prefixval;
} prefixtable[MAXPREFIXES];


char *NULLUNIT = "";

int unitcount;
int prefixcount;

char *dupstr(char *);
void readunits(char *);
void initializeunit(struct unittype *);
int addsubunit(char *[], char *);
void showunit(struct unittype *);
void zeroerror(void);
int addunit(struct unittype *, char *, int);
int compare(const void *, const void *);
void sortunit(struct unittype *);
void cancelunit(struct unittype *);
char *lookupunit(char *);
int reduceproduct(struct unittype *, int);
int reduceunit(struct unittype *);
int compareproducts(char **, char **);
int compareunits(struct unittype *, struct unittype *);
int completereduce(struct unittype *);
void showanswer(struct unittype *, struct unittype *);
void usage(void);

char *
dupstr(char *str)
{
	char *ret;

	ret = strdup(str);
	if (!ret) {
		fprintf(stderr, "Memory allocation error\n");
		exit(3);
	}
	return (ret);
}


void
readunits(char *userfile)
{
	char line[512], *lineptr;
	int len, linenum, i;
	FILE *unitfile;

	unitcount = 0;
	linenum = 0;

	if (userfile) {
		unitfile = fopen(userfile, "r");
		if (!unitfile) {
			fprintf(stderr, "Unable to open units file '%s'\n",
			    userfile);
			exit(1);
		}
	} else {
		unitfile = fopen(UNITSFILE, "r");
		if (!unitfile) {
			fprintf(stderr, "Can't find units file '%s'\n",
			    UNITSFILE);
			exit(1);
		}
	}
	while (!feof(unitfile)) {
		if (!fgets(line, sizeof(line), unitfile))
			break;
		linenum++;
		lineptr = line;
		if (*lineptr == '/')
			continue;
		lineptr += strspn(lineptr, " \n\t");
		len = strcspn(lineptr, " \n\t");
		lineptr[len] = 0;
		if (!strlen(lineptr))
			continue;
		if (lineptr[strlen(lineptr) - 1] == '-') { /* it's a prefix */
			if (prefixcount == MAXPREFIXES) {
				fprintf(stderr,
				    "Memory for prefixes exceeded in line %d\n",
				    linenum);
				continue;
			}

			lineptr[strlen(lineptr) - 1] = 0;
			for (i = 0; i < prefixcount; i++) {
				if (!strcmp(prefixtable[i].prefixname, lineptr))
					break;
			}
			if (i < prefixcount) {
				fprintf(stderr, "Redefinition of prefix '%s' "
				    "on line %d ignored\n", lineptr, linenum);
				continue;	/* skip duplicate prefix */
			}

			prefixtable[prefixcount].prefixname = dupstr(lineptr);
			lineptr += len + 1;
			lineptr += strspn(lineptr, " \n\t");
			len = strcspn(lineptr, "\n\t");
			if (len == 0) {
				fprintf(stderr, "Unexpected end of prefix on "
				    "line %d\n", linenum);
				free(prefixtable[prefixcount].prefixname);
				continue;
			}
			lineptr[len] = 0;
			prefixtable[prefixcount++].prefixval = dupstr(lineptr);
		} else {		/* it's not a prefix */
			if (unitcount == MAXUNITS) {
				fprintf(stderr,
				    "Memory for units exceeded in line %d\n",
				    linenum);
				continue;
			}

			for (i = 0; i < unitcount; i++) {
				if (!strcmp(unittable[i].uname, lineptr))
					break;
			}
			if (i < unitcount) {
				fprintf(stderr, "Redefinition of unit '%s' "
				    "on line %d ignored\n", lineptr, linenum);
				continue;	/* skip duplicate unit */
			}

			unittable[unitcount].uname = dupstr(lineptr);
			lineptr += len + 1;
			lineptr += strspn(lineptr, " \n\t");
			if (!strlen(lineptr)) {
				fprintf(stderr, "Unexpected end of unit on "
				    "line %d\n", linenum);
				free(unittable[unitcount].uname);
				continue;
			}
			len = strcspn(lineptr, "\n\t");
			lineptr[len] = 0;
			unittable[unitcount++].uval = dupstr(lineptr);
		}
	}
	fclose(unitfile);
}

void
initializeunit(struct unittype *theunit)
{
	theunit->factor = 1.0;
	theunit->numerator[0] = theunit->denominator[0] = NULL;
}


int
addsubunit(char *product[], char *toadd)
{
	char **ptr;

	for (ptr = product; *ptr && *ptr != NULLUNIT; ptr++);
	if (ptr >= product + MAXSUBUNITS) {
		fprintf(stderr, "Memory overflow in unit reduction\n");
		return 1;
	}
	if (!*ptr)
		*(ptr + 1) = 0;
	*ptr = dupstr(toadd);
	return 0;
}


void
showunit(struct unittype *theunit)
{
	char **ptr;
	int printedslash;
	int counter = 1;

	printf("\t%.8g", theunit->factor);
	for (ptr = theunit->numerator; *ptr; ptr++) {
		if (ptr > theunit->numerator && **ptr &&
		    !strcmp(*ptr, *(ptr - 1)))
			counter++;
		else {
			if (counter > 1)
				printf("%s%d", powerstring, counter);
			if (**ptr)
				printf(" %s", *ptr);
			counter = 1;
		}
	}
	if (counter > 1)
		printf("%s%d", powerstring, counter);
	counter = 1;
	printedslash = 0;
	for (ptr = theunit->denominator; *ptr; ptr++) {
		if (ptr > theunit->denominator && **ptr &&
		    !strcmp(*ptr, *(ptr - 1)))
			counter++;
		else {
			if (counter > 1)
				printf("%s%d", powerstring, counter);
			if (**ptr) {
				if (!printedslash)
					printf(" /");
				printedslash = 1;
				printf(" %s", *ptr);
			}
			counter = 1;
		}
	}
	if (counter > 1)
		printf("%s%d", powerstring, counter);
	printf("\n");
}


void
zeroerror(void)
{
	fprintf(stderr, "Unit reduces to zero\n");
}

/*
   Adds the specified string to the unit.
   Flip is 0 for adding normally, 1 for adding reciprocal.

   Returns 0 for successful addition, nonzero on error.
*/

int
addunit(struct unittype *theunit, char *toadd, int flip)
{
	char *scratch, *savescr;
	char *item;
	char *divider, *slash;
	int doingtop;

	savescr = scratch = dupstr(toadd);
	for (slash = scratch + 1; *slash; slash++)
		if (*slash == '-' &&
		    (tolower((unsigned char)*(slash - 1)) != 'e' ||
		    !strchr(".0123456789", *(slash + 1))))
			*slash = ' ';
	slash = strchr(scratch, '/');
	if (slash)
		*slash = 0;
	doingtop = 1;
	do {
		item = strtok(scratch, " *\t\n/");
		while (item) {
			if (strchr("0123456789.", *item)) { /* item is a number */
				double num;

				divider = strchr(item, '|');
				if (divider) {
					*divider = 0;
					num = atof(item);
					if (!num) {
						zeroerror();
						free(savescr);
						return 1;
					}
					if (doingtop ^ flip)
						theunit->factor *= num;
					else
						theunit->factor /= num;
					num = atof(divider + 1);
					if (!num) {
						zeroerror();
						free(savescr);
						return 1;
					}
					if (doingtop ^ flip)
						theunit->factor /= num;
					else
						theunit->factor *= num;
				} else {
					num = atof(item);
					if (!num) {
						zeroerror();
						free(savescr);
						return 1;
					}
					if (doingtop ^ flip)
						theunit->factor *= num;
					else
						theunit->factor /= num;

				}
			} else {	/* item is not a number */
				int repeat = 1;

				if (strchr("23456789",
				    item[strlen(item) - 1])) {
					repeat = item[strlen(item) - 1] - '0';
					item[strlen(item) - 1] = 0;
				}
				for (; repeat; repeat--)
					if (addsubunit(doingtop ^ flip
					    ? theunit->numerator
					    : theunit->denominator, item)) {
						free(savescr);
						return 1;
					}
			}
			item = strtok(NULL, " *\t/\n");
		}
		doingtop--;
		if (slash) {
			scratch = slash + 1;
		} else
			doingtop--;
	} while (doingtop >= 0);
	free(savescr);
	return 0;
}


int
compare(const void *item1, const void *item2)
{
	return strcmp(*(char **) item1, *(char **) item2);
}


void
sortunit(struct unittype *theunit)
{
	char **ptr;
	int count;

	for (count = 0, ptr = theunit->numerator; *ptr; ptr++, count++);
	qsort(theunit->numerator, count, sizeof(char *), compare);
	for (count = 0, ptr = theunit->denominator; *ptr; ptr++, count++);
	qsort(theunit->denominator, count, sizeof(char *), compare);
}


void
cancelunit(struct unittype *theunit)
{
	char **den, **num;
	int comp;

	den = theunit->denominator;
	num = theunit->numerator;

	while (*num && *den) {
		comp = strcmp(*den, *num);
		if (!comp) {
			*den++ = NULLUNIT;
			*num++ = NULLUNIT;
		} else if (comp < 0)
			den++;
		else
			num++;
	}
}




/*
   Looks up the definition for the specified unit.
   Returns a pointer to the definition or a null pointer
   if the specified unit does not appear in the units table.
*/

static char buffer[500];	/* buffer for lookupunit answers with
				   prefixes */

char *
lookupunit(char *unit)
{
	size_t len;
	int i;
	char *copy;

	for (i = 0; i < unitcount; i++) {
		if (!strcmp(unittable[i].uname, unit))
			return unittable[i].uval;
	}

	len = strlen(unit);
	if (len == 0)
		return NULL;
	if (unit[len - 1] == '^') {
		copy = dupstr(unit);
		copy[len - 1] = '\0';
		for (i = 0; i < unitcount; i++) {
			if (!strcmp(unittable[i].uname, copy)) {
				strlcpy(buffer, copy, sizeof(buffer));
				free(copy);
				return buffer;
			}
		}
		free(copy);
	}
	if (unit[len - 1] == 's') {
		copy = dupstr(unit);
		copy[len - 1] = '\0';
		--len;
		for (i = 0; i < unitcount; i++) {
			if (!strcmp(unittable[i].uname, copy)) {
				strlcpy(buffer, copy, sizeof(buffer));
				free(copy);
				return buffer;
			}
		}
		if (len != 0 && copy[len - 1] == 'e') {
			copy[len - 1] = 0;
			for (i = 0; i < unitcount; i++) {
				if (!strcmp(unittable[i].uname, copy)) {
					strlcpy(buffer, copy, sizeof(buffer));
					free(copy);
					return buffer;
				}
			}
		}
		free(copy);
	}
	for (i = 0; i < prefixcount; i++) {
		len = strlen(prefixtable[i].prefixname);
		if (!strncmp(prefixtable[i].prefixname, unit, len)) {
			if (!strlen(unit + len) || lookupunit(unit + len)) {
				snprintf(buffer, sizeof(buffer), "%s %s",
				    prefixtable[i].prefixval, unit + len);
				return buffer;
			}
		}
	}
	return NULL;
}



/*
   reduces a product of symbolic units to primitive units.
   The three low bits are used to return flags:

     bit 0 (1) set on if reductions were performed without error.
     bit 1 (2) set on if no reductions are performed.
     bit 2 (4) set on if an unknown unit is discovered.
*/


#define ERROR 4

int
reduceproduct(struct unittype *theunit, int flip)
{
	char *toadd, **product;
	int didsomething = 2;

	if (flip)
		product = theunit->denominator;
	else
		product = theunit->numerator;

	for (; *product; product++) {

		for (;;) {
			if (!strlen(*product))
				break;
			toadd = lookupunit(*product);
			if (!toadd) {
				printf("unknown unit '%s'\n", *product);
				return ERROR;
			}
			if (strchr(toadd, PRIMITIVECHAR))
				break;
			didsomething = 1;
			if (*product != NULLUNIT) {
				free(*product);
				*product = NULLUNIT;
			}
			if (addunit(theunit, toadd, flip))
				return ERROR;
		}
	}
	return didsomething;
}


/*
   Reduces numerator and denominator of the specified unit.
   Returns 0 on success, or 1 on unknown unit error.
*/

int
reduceunit(struct unittype *theunit)
{
	int ret;

	ret = 1;
	while (ret & 1) {
		ret = reduceproduct(theunit, 0) | reduceproduct(theunit, 1);
		if (ret & 4)
			return 1;
	}
	return 0;
}


int
compareproducts(char **one, char **two)
{
	while (*one || *two) {
		if (!*one && *two != NULLUNIT)
			return 1;
		if (!*two && *one != NULLUNIT)
			return 1;
		if (*one == NULLUNIT)
			one++;
		else if (*two == NULLUNIT)
			two++;
		else if (strcmp(*one, *two))
			return 1;
		else
			one++, two++;
	}
	return 0;
}


/* Return zero if units are compatible, nonzero otherwise */

int
compareunits(struct unittype *first, struct unittype *second)
{
	return compareproducts(first->numerator, second->numerator) ||
	    compareproducts(first->denominator, second->denominator);
}


int
completereduce(struct unittype *unit)
{
	if (reduceunit(unit))
		return 1;
	sortunit(unit);
	cancelunit(unit);
	return 0;
}


void
showanswer(struct unittype *have, struct unittype *want)
{
	if (compareunits(have, want)) {
		printf("conformability error\n");
		showunit(have);
		showunit(want);
	} else
		printf("\t* %.8g\n\t/ %.8g\n", have->factor / want->factor,
		    want->factor / have->factor);
}


void
usage(void)
{
	fprintf(stderr,
	    "usage: units [-qv] [-f filename] [[count] from-unit to-unit]\n");
	exit(3);
}


int
main(int argc, char **argv)
{

	struct unittype have, want;
	char havestr[81], wantstr[81];
	int optchar;
	char *userfile = 0;
	int quiet = 0;

	extern char *optarg;
	extern int optind;

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	while ((optchar = getopt(argc, argv, "vqf:")) != -1) {
		switch (optchar) {
		case 'f':
			userfile = optarg;
			break;
		case 'q':
			quiet = 1;
			break;
		case 'v':
			fprintf(stderr,
			    "units version %s Copyright (c) 1993 by Adrian Mariano\n",
			    VERSION);
			fprintf(stderr,
			    "This program may be freely distributed\n");
			usage();
		default:
			usage();
			break;
		}
	}

	argc -= optind;
	argv += optind;

	if (argc != 3 && argc != 2 && argc != 0)
		usage();

	readunits(userfile);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	if (argc == 3) {
		strlcpy(havestr, argv[0], sizeof(havestr));
		strlcat(havestr, " ", sizeof(havestr));
		strlcat(havestr, argv[1], sizeof(havestr));
		argc--;
		argv++;
		argv[0] = havestr;
	}

	if (argc == 2) {
		strlcpy(havestr, argv[0], sizeof(havestr));
		strlcpy(wantstr, argv[1], sizeof(wantstr));
		initializeunit(&have);
		addunit(&have, havestr, 0);
		completereduce(&have);
		initializeunit(&want);
		addunit(&want, wantstr, 0);
		completereduce(&want);
		showanswer(&have, &want);
	} else {
		if (!quiet)
			printf("%d units, %d prefixes\n", unitcount,
			    prefixcount);
		for (;;) {
			do {
				initializeunit(&have);
				if (!quiet)
					printf("You have: ");
				if (!fgets(havestr, sizeof(havestr), stdin)) {
					if (!quiet)
						putchar('\n');
					exit(0);
				}
			} while (addunit(&have, havestr, 0) ||
			    completereduce(&have));
			do {
				initializeunit(&want);
				if (!quiet)
					printf("You want: ");
				if (!fgets(wantstr, sizeof(wantstr), stdin)) {
					if (!quiet)
						putchar('\n');
					exit(0);
				}
			} while (addunit(&want, wantstr, 0) ||
			    completereduce(&want));
			showanswer(&have, &want);
		}
	}
	return (0);
}
@


1.21
log
@tame "stdio rpath" before opening the file, tame "stdio" after that
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.20 2013/11/27 00:13:24 deraadt Exp $	*/
d635 2
a636 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
d667 2
a668 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.20
log
@unsigned char for ctype
ok okan
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.19 2013/11/17 20:19:36 okan Exp $	*/
d26 1
d635 3
d666 3
@


1.19
log
@Include unistd.h as it is the standard location for getopt().

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.18 2013/01/04 19:31:28 jmc Exp $	*/
d293 1
a293 1
		    (tolower(*(slash - 1)) != 'e' ||
@


1.18
log
@an undocumented feature of units was the ability to specify a prefix
in non-interactive mode. document that now, but also allow for the
prefix to be given without a need to quote it;

code lifted from atatat (netbsd -r1.10); otto helped me paste it in.

ok otto millert
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.17 2011/10/07 20:07:25 jmc Exp $	*/
d25 1
@


1.17
log
@do not search PATH for a units datafile; from pjanzen
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.16 2011/10/06 23:27:04 jmc Exp $	*/
d615 1
a615 1
	    "usage: units [-qv] [-f filename] [from-unit to-unit]\n");
d654 4
a657 1
	if (optind != argc - 2 && optind != argc)
d662 12
a673 3
	if (optind == argc - 2) {
		strlcpy(havestr, argv[optind], sizeof(havestr));
		strlcpy(wantstr, argv[optind + 1], sizeof(wantstr));
@


1.16
log
@just define UNITSFILE directly, and do away with the need for pathnames.h;
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.15 2011/10/06 17:58:04 jmc Exp $	*/
a57 2
#define SEPERATOR	":"

d114 3
a116 20
			char filename[1000], separator[2] = SEPERATOR;
			char *direc, *env;

			env = getenv("PATH");
			if (env) {
				direc = strtok(env, separator);
				while (direc) {
					snprintf(filename, sizeof(filename),
					    "%s/%s", direc, UNITSFILE);
					unitfile = fopen(filename, "r");
					if (unitfile)
						break;
					direc = strtok(NULL, separator);
				}
			}
			if (!unitfile) {
				fprintf(stderr, "Can't find units file '%s'\n",
				    UNITSFILE);
				exit(1);
			}
@


1.15
log
@from pjanzen:
Bump MAXPREFIXES (and a few string lengths) prior to units.lib
commit of more prefixes.  Add FreeBSD fixes (circa 2001) to prefix
and other units.lib parsing.  Do minor obvious code tidying.
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.14 2007/03/29 20:13:57 jmc Exp $	*/
d26 1
a26 1
#include "pathnames.h"
a28 4

#ifndef UNITSFILE
#define UNITSFILE _PATH_UNITSLIB
#endif
@


1.14
log
@sync usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.13 2007/02/24 03:28:16 ray Exp $	*/
d35 1
a35 1
#define MAXPREFIXES 50
a61 3
#ifdef DOS
#define SEPERATOR	";"
#else
a62 1
#endif
a67 1
void readerror(int);
a100 8
readerror(int linenum)
{
	fprintf(stderr, "Error in units file '%s' line %d\n", UNITSFILE,
	    linenum);
}


void
d103 1
a103 1
	char line[80], *lineptr;
d111 1
a111 1
		unitfile = fopen(userfile, "rt");
d118 1
a118 1
		unitfile = fopen(UNITSFILE, "rt");
d129 1
a129 1
					unitfile = fopen(filename, "rt");
d175 5
a179 2
			if (!strlen(lineptr)) {
				readerror(linenum);
a182 2
			lineptr += strspn(lineptr, " \n\t");
			len = strcspn(lineptr, "\n\t");
d207 2
a208 1
				readerror(linenum);
a424 6
#if 0
			if (*den!=NULLUNIT)
				free(*den);
			if (*num!=NULLUNIT)
				free(*num);
#endif
d443 1
a443 1
static char buffer[100];	/* buffer for lookupunit answers with
d499 3
a501 4
			unit += len;
			if (!strlen(unit) || lookupunit(unit)) {
				snprintf(buffer, sizeof(buffer),
				    "%s %s", prefixtable[i].prefixval, unit);
@


1.13
log
@- Don't access buffers with negative indexes.
- Save a ton of strlen calls.
- Return NULL pointer, not 0.

``boy there is a lot of strlen()'' millert@@ and OK moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.11 2004/12/02 22:54:55 pat Exp $	*/
d655 2
a656 4
	fprintf(stderr, "units [-f unitsfile] [-q] [-v] [from-unit to-unit]\n");
	fprintf(stderr, "    -f specify units file\n");
	fprintf(stderr, "    -q suppress prompting (quiet)\n");
	fprintf(stderr, "    -v print version number\n");
@


1.12
log
@Change hard coded numbers to sizeof(buf).  Also change some
sizeof(buf) - 1 to sizeof(buf), since fgets takes the whole buffer size.

Based on diff from Charles Longeau <chl at tuxfamily dot org> long ago.

OK millert@@.
@
text
@d466 1
d475 4
a478 1
	if (unit[strlen(unit) - 1] == '^') {
d480 1
a480 1
		copy[strlen(copy) - 1] = '\0';
d490 1
a490 1
	if (unit[strlen(unit) - 1] == 's') {
d492 2
a493 1
		copy[strlen(copy) - 1] = 0;
d501 2
a502 2
		if (copy[strlen(copy) - 1] == 'e') {
			copy[strlen(copy) - 1] = 0;
d514 3
a516 3
		if (!strncmp(prefixtable[i].prefixname, unit,
			strlen(prefixtable[i].prefixname))) {
			unit += strlen(prefixtable[i].prefixname);
d524 1
a524 1
	return 0;
@


1.11
log
@* fix the duplicate prefix and duplicate unit parsing

with suggestion & ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.10 2004/12/01 16:41:07 pat Exp $	*/
d156 1
a156 1
		if (!fgets(line, 79, unitfile))
d716 1
a716 1
				if (!fgets(havestr, 80, stdin)) {
d727 1
a727 1
				if (!fgets(wantstr, 80, stdin)) {
@


1.10
log
@* plug memory leaks in the file parser and in the interactive mode parser

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.9 2003/07/02 01:57:15 deraadt Exp $	*/
d174 1
d176 10
a186 7
			for (i = 0; i < prefixcount; i++)
				if (!strcmp(prefixtable[i].prefixname, lineptr)) {
					fprintf(stderr,
					    "Redefinition of prefix '%s' on line %d ignored\n",
					    lineptr, linenum);
					continue;
				}
d204 11
a215 7
			for (i = 0; i < unitcount; i++)
				if (!strcmp(unittable[i].uname, lineptr)) {
					fprintf(stderr,
					    "Redefinition of unit '%s' on line %d ignored\n",
					    lineptr, linenum);
					continue;
				}
@


1.9
log
@cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.8 2003/06/10 22:20:53 deraadt Exp $	*/
d186 1
d212 1
d337 1
d347 1
d358 1
d376 4
a379 1
					if (addsubunit(doingtop ^ flip ? theunit->numerator : theunit->denominator, item))
d381 1
@


1.8
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.7 2001/01/17 19:29:49 deraadt Exp $	*/
d71 19
d105 1
a105 1
void 
d113 1
a113 1
void 
a115 1
	FILE *unitfile;
d118 1
d133 1
a134 2
			char filename[1000];
			char separator[2] = SEPERATOR;
d192 1
a192 2
		}
		else {		/* it's not a prefix */
d221 2
a222 2
void 
initializeunit(struct unittype * theunit)
d229 1
a229 1
int 
d246 2
a247 2
void 
showunit(struct unittype * theunit)
d292 1
a292 1
void 
d305 2
a306 2
int 
addunit(struct unittype * theunit, char *toadd, int flip)
d350 1
a350 2
				}
				else {
d362 1
a362 2
			}
			else {	/* item is not a number */
d379 1
a379 2
		}
		else
d387 1
a387 1
int 
d394 2
a395 2
void 
sortunit(struct unittype * theunit)
d407 2
a408 2
void 
cancelunit(struct unittype * theunit)
d419 6
a424 2
/*      if (*den!=NULLUNIT) free(*den);
      if (*num!=NULLUNIT) free(*num);*/
d427 1
a427 2
		}
		else if (comp < 0)
d519 2
a520 2
int 
reduceproduct(struct unittype * theunit, int flip)
d522 1
a522 3

	char *toadd;
	char **product;
d560 2
a561 2
int 
reduceunit(struct unittype * theunit)
d575 1
a575 1
int 
d598 2
a599 2
int 
compareunits(struct unittype * first, struct unittype * second)
d601 2
a602 3
	return
	compareproducts(first->numerator, second->numerator) ||
	compareproducts(first->denominator, second->denominator);
d606 2
a607 2
int 
completereduce(struct unittype * unit)
d617 2
a618 2
void 
showanswer(struct unittype * have, struct unittype * want)
d624 1
a624 2
	}
	else
d630 1
a630 1
void 
d690 1
a690 2
	}
	else {
@


1.7
log
@use more strlcpy()
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.6 1999/06/13 16:34:21 pjanzen Exp $	*/
d276 1
a276 1
zeroerror()
d618 1
a618 1
usage()
@


1.6
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.5 1997/07/08 18:32:27 millert Exp $	*/
d46 1
a46 1
}      unittable[MAXUNITS];
d57 1
a57 1
}      prefixtable[MAXPREFIXES];
d77 1
a77 1
	ret = malloc(strlen(str) + 1);
a81 1
	strcpy(ret, str);
d445 1
a445 2
				strncpy(buffer, copy, sizeof(buffer) - 1);
				buffer[sizeof(buffer) - 1] = '\0';
d457 1
a457 2
				strncpy(buffer, copy, sizeof(buffer) - 1);
				buffer[sizeof(buffer) - 1] = '\0';
d466 1
a466 2
					strncpy(buffer, copy, sizeof(buffer) - 1);
					buffer[sizeof(buffer) - 1] = '\0';
d668 2
a669 4
		strncpy(havestr, argv[optind], sizeof(havestr) - 1);
		havestr[sizeof(havestr) - 1] = '\0';
		strncpy(wantstr, argv[optind + 1], sizeof(wantstr) - 1);
		wantstr[sizeof(wantstr) - 1] = '\0';
@


1.5
log
@- replace some strn?cpy/strn?cat pairs w/ snprintf
- strcpy() -> strncpy()
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.4 1996/08/11 00:17:31 deraadt Exp $	*/
d626 1
a626 1
	fprintf(stderr, "    -q supress prompting (quiet)\n");
@


1.4
log
@two fixes from freebsd plus some more by me
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.3 1996/06/26 05:42:15 deraadt Exp $	*/
d123 2
a124 6
					strcpy(filename, "");
					strncat(filename, direc, 999);
					strncat(filename, "/",
					    999 - strlen(filename));
					strncat(filename, UNITSFILE,
					    999 - strlen(filename));
d443 1
a443 1
		copy[strlen(copy) - 1] = 0;
d446 2
a447 1
				strcpy(buffer, copy);
d459 2
a460 1
				strcpy(buffer, copy);
d469 2
a470 1
					strcpy(buffer, copy);
d483 2
a484 3
				strcpy(buffer, prefixtable[i].prefixval);
				strcat(buffer, " ");
				strcat(buffer, unit);
d672 4
a675 2
		strcpy(havestr, argv[optind]);
		strcpy(wantstr, argv[optind + 1]);
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: units.c,v 1.6 1996/04/06 06:01:03 thorpej Exp $	*/
d62 6
d112 1
a112 2
	}
	else {
d117 1
a117 1
			char separator[2];
a120 4
				if (strchr(env, ';'))
					strcpy(separator, ";");
				else
					strcpy(separator, ":");
d156 2
a157 1
				fprintf(stderr, "Memory for prefixes exceeded in line %d\n",
d165 2
a166 1
					fprintf(stderr, "Redefinition of prefix '%s' on line %d ignored\n",
d182 2
a183 1
				fprintf(stderr, "Memory for units exceeded in line %d\n",
d190 2
a191 1
					fprintf(stderr, "Redefinition of unit '%s' on line %d ignored\n",
d626 2
a627 2
	fprintf(stderr, "\nunits [-f unitsfile] [-q] [-v] [from-unit to-unit]\n");
	fprintf(stderr, "\n    -f specify units file\n");
d656 2
a657 1
			fprintf(stderr, "\n  units version %s  Copyright (c) 1993 by Adrian Mariano\n",
d659 2
a660 1
			fprintf(stderr, "                    This program may be freely distributed\n");
d686 1
a686 1
			printf("%d units, %d prefixes\n\n", unitcount,
d694 2
a695 2
					if (!quiet);
					putchar('\n');
d714 1
@


1.2
log
@sync to netbsd 960418
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 2
a17 2
 *
 *	$Id: units.c,v 1.3 1994/12/21 07:22:00 jtc Exp $
d628 1
a628 1
void 
d634 1
a634 1
	char optchar;
d641 1
a641 1
	while (EOF != (optchar = getopt(argc, argv, "vqf:"))) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
