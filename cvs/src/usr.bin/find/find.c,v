head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.14
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.12
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.8
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.6
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.12
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.8
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.6
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.10
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.10
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.8
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2017.01.04.09.21.26;	author tb;	state Exp;
branches;
next	1.21;
commitid	A7STm2Bznt1aoYZ2;

1.21
date	2017.01.03.21.31.16;	author tedu;	state Exp;
branches;
next	1.20;
commitid	cr2jR3uz1Q8R6G8A;

1.20
date	2015.10.10.20.35.00;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	m38BXhkh3XknrpM6;

1.19
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	sbrB3Q5CNxcwZpfU;

1.18
date	2015.10.05.15.25.16;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	uWZKXvI9OxOC3pzV;

1.17
date	2014.12.01.03.11.55;	author millert;	state Exp;
branches;
next	1.16;
commitid	A97pomWPFGq4hEhz;

1.16
date	2012.01.02.23.19.45;	author pascal;	state Exp;
branches;
next	1.15;

1.15
date	2011.04.21.01.14.21;	author jacekm;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.38;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.10.09.00.18;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.26.20.59.01;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.20.03.50.25;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.26.07.27.29;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.02.56.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.17.19.50.53;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.10.04.21.17.32;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.10.03.19.07.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.06.30.23.54.07;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.17.20.58.08;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.10.24.03.46.04;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.33.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.13;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@If find(1) may end up calling execve(2), it needs "proc exec" in addition
to its other promises.  Previously, find ran unpledged if the -exec{,dir}
or -ok primaries were specified: the tame(2) calls for find(1) were added
a few days before the "exec" promise was implemented and these code paths
were never revisited.

ok millert
@
text
@/*	$OpenBSD: find.c,v 1.21 2017/01/03 21:31:16 tedu Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Cimarron D. Taylor of the University of California, Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <err.h>
#include <errno.h>
#include <fts.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

int	mayexecve;

#include "find.h"

/*
 * find_formplan --
 *	process the command line and create a "plan" corresponding to the
 *	command arguments.
 */
PLAN *
find_formplan(char **argv)
{
	PLAN *plan, *tail, *new;

	/*
	 * for each argument in the command line, determine what kind of node
	 * it is, create the appropriate node type and add the new plan node
	 * to the end of the existing plan.  The resulting plan is a linked
	 * list of plan nodes.  For example, the string:
	 *
	 *	% find . -name foo -newer bar -print
	 *
	 * results in the plan:
	 *
	 *	[-name foo]--> [-newer bar]--> [-print]
	 *
	 * in this diagram, `[-name foo]' represents the plan node generated
	 * by c_name() with an argument of foo and `-->' represents the
	 * plan->next pointer.
	 */
	for (plan = tail = NULL; *argv;) {
		if (!(new = find_create(&argv)))
			continue;
		if (plan == NULL)
			tail = plan = new;
		else {
			tail->next = new;
			tail = new;
		}
	}
    
	/*
	 * if the user didn't specify one of -print, -ok or -exec, then -print
	 * is assumed so we bracket the current expression with parens, if
	 * necessary, and add a -print node on the end.
	 */
	if (!isoutput) {
		if (plan == NULL) {
			new = c_print(NULL, NULL, 0);
			tail = plan = new;
		} else {
			new = c_openparen(NULL, NULL, 0);
			new->next = plan;
			plan = new;
			new = c_closeparen(NULL, NULL, 0);
			tail->next = new;
			tail = new;
			new = c_print(NULL, NULL, 0);
			tail->next = new;
			tail = new;
		}
	}
    
	/*
	 * the command line has been completely processed into a search plan
	 * except for the (, ), !, and -o operators.  Rearrange the plan so
	 * that the portions of the plan which are affected by the operators
	 * are moved into operator nodes themselves.  For example:
	 *
	 *	[!]--> [-name foo]--> [-print]
	 *
	 * becomes
	 *
	 *	[! [-name foo] ]--> [-print]
	 *
	 * and
	 *
	 *	[(]--> [-depth]--> [-name foo]--> [)]--> [-print]
	 *
	 * becomes
	 *
	 *	[expr [-depth]-->[-name foo] ]--> [-print]
	 *
	 * operators are handled in order of precedence.
	 */

	plan = paren_squish(plan);		/* ()'s */
	plan = not_squish(plan);		/* !'s */
	plan = or_squish(plan);			/* -o's */
	return (plan);
}
 
FTS *tree;			/* pointer to top of FTS hierarchy */

/*
 * find_execute --
 *	take a search plan and an array of search paths and executes the plan
 *	over all FTSENT's returned for the given search paths.
 */

FTSENT *entry;			/* shared with SIGINFO handler */

int
find_execute(PLAN *plan,	/* search plan */
    char **paths)		/* array of pathnames to traverse */
{
	sigset_t fullset, oset;
	int r, rval;
	PLAN *p;

	if (mayexecve == 0) {
		if (isdelete) {
			if (pledge("stdio rpath cpath getpw", NULL) == -1)
				err(1, "pledge");
		} else {
			if (pledge("stdio rpath getpw", NULL) == -1)
				err(1, "pledge");
		}
	} else {
		if (isdelete) {
			if (pledge("stdio rpath cpath getpw proc exec", NULL)
			    == -1)
				err(1, "pledge");
		} else {
			if (pledge("stdio rpath getpw proc exec", NULL) == -1)
				err(1, "pledge");
		}
	}

	rval = 0;
    
	if (!(tree = fts_open(paths, ftsoptions, NULL)))
		err(1, "fts_open");

	sigfillset(&fullset);
	for (;;) {
		(void)sigprocmask(SIG_BLOCK, &fullset, &oset);
		entry = fts_read(tree);
		(void)sigprocmask(SIG_SETMASK, &oset, NULL);
		if (entry == NULL) {
			if (errno)
				err(1, "fts_read");
			break;
		}

		switch (entry->fts_info) {
		case FTS_D:
			if (isdepth)
				continue;
			break;
		case FTS_DP:
			if (!isdepth)
				continue;
			break;
		case FTS_DNR:
		case FTS_ERR:
		case FTS_NS:
			(void)fflush(stdout);
			warnc(entry->fts_errno, "%s", entry->fts_path);
			rval = 1;
			continue;
		}
#define	BADCH	" \t\n\\'\""
		if (isxargs && strpbrk(entry->fts_path, BADCH)) {
			(void)fflush(stdout);
			warnx("%s: illegal path", entry->fts_path);
			rval = 1;
			continue;
		}

		/*
		 * Call all the functions in the execution plan until one is
		 * false or all have been executed.  This is where we do all
		 * the work specified by the user on the command line.
		 */
		for (p = plan; p && (p->eval)(p, entry); p = p->next)
		    ;
	}
	(void)fts_close(tree);

	/*
	 * Cleanup any plans with leftover state.
	 * Keep the last non-zero return value.
	 */
	if ((r = find_traverse(plan, plan_cleanup, NULL)) != 0)
		rval = r;
	return (rval);
}

/*
 * find_traverse --
 *	traverse the plan tree and execute func() on all plans.  This
 *	does not evaluate each plan's eval() function; it is intended
 *	for operations that must run on all plans, such as state
 *	cleanup.
 *
 *	If any func() returns non-zero, then so will find_traverse().
 */
int
find_traverse(PLAN *plan, int (*func)(PLAN *, void *), void *arg)
{
	PLAN *p;
	int r, rval;

	rval = 0;
	for (p = plan; p; p = p->next) {
		if ((r = func(p, arg)) != 0)
			rval = r;
		if (p->type == N_EXPR || p->type == N_OR) {
			if (p->p_data[0])
				if ((r = find_traverse(p->p_data[0],
					    func, arg)) != 0)
					rval = r;
			if (p->p_data[1])
				if ((r = find_traverse(p->p_data[1],
					    func, arg)) != 0)
					rval = r;
		}
	}
	return rval;
}
@


1.21
log
@add -delete option which can simplify the common case of wanting to delete
lots of files without the arcane -exec or error prone xargs.
code from freebsd.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.20 2015/10/10 20:35:00 deraadt Exp $	*/
d163 9
@


1.20
log
@normalize a few more tame request orderings, to help review
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.19 2015/10/09 01:37:07 deraadt Exp $	*/
d157 9
a165 3
	if (mayexecve == 0)
		if (pledge("stdio rpath getpw", NULL) == -1)
			err(1, "pledge");
@


1.19
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.18 2015/10/05 15:25:16 deraadt Exp $	*/
d158 1
a158 1
		if (pledge("stdio getpw rpath", NULL) == -1)
@


1.18
log
@If expression omits -exec/execdir/-ok primaries, then find will never
enter the fork+execve codepath.  That allows use of "stdio getpw rpath"!
Use of -exec methods have been discouraged for years anyways, with
-print0/xargs -0 now considered safer practice.
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.17 2014/12/01 03:11:55 millert Exp $	*/
d158 2
a159 2
		if (tame("stdio getpw rpath", NULL) == -1)
			err(1, "tame");
@


1.17
log
@Use warnc() to use the correct errno value for FTS_DNR, FTS_NS and
FTS_ERR.  From Piotr Durlej.
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.16 2012/01/02 23:19:45 pascal Exp $	*/
d45 3
d156 4
@


1.16
log
@Add support for "find ... -exec foo {} \+".

From the manpage:

If terminated by a plus sign (``+''), the pathnames for which the
primary is evaluated are aggregated into sets, and utility will
be invoked once per set, similar to xargs(1).  If any invocation
exits with non-zero exit status, then find will eventually do so
as well, but this does not cause find to exit early.  The string
``{}'' must appear, and must appear last.  Each set is limited to
no more than 5,000 pathnames, and is also limited such that the
invocation of utility does not exceed ARG_MAX.

Code comes from NetBSD, written by John Hawkinson.  Tested by eivinde at
terraplane dot org and myself for quite some time.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.15 2011/04/21 01:14:21 jacekm Exp $	*/
d183 1
a183 1
			warn("%s", entry->fts_path);
@


1.15
log
@find: return exit code 1 if any path could not be traversed
matches posix and the manual, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.14 2009/10/27 23:59:38 deraadt Exp $	*/
d151 1
a151 1
	int rval;
d204 7
d212 33
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.13 2007/05/10 09:00:18 jmc Exp $	*/
d146 1
a146 1
void
d151 1
d153 2
d184 1
d191 1
d204 1
@


1.13
log
@ftsopen -> fts_open; partly from Alexander Holupirek, documentation/5472
ok simon art
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.12 2006/12/26 20:59:01 otto Exp $	*/
a33 5

#ifndef lint
/*static char sccsid[] = "from: @@(#)find.c	8.1 (Berkeley) 6/6/93";*/
static char rcsid[] = "$OpenBSD: find.c,v 1.12 2006/12/26 20:59:01 otto Exp $";
#endif /* not lint */
@


1.12
log
@fts_read returning NULL and errno set is an error. ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.11 2004/07/20 03:50:25 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: find.c,v 1.11 2004/07/20 03:50:25 deraadt Exp $";
d159 1
a159 1
		err(1, "ftsopen");
@


1.11
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.10 2003/06/26 07:27:29 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: find.c,v 1.10 2003/06/26 07:27:29 deraadt Exp $";
d166 3
a168 1
		if (entry == NULL)
d170 1
@


1.10
log
@bring protypes into scope.  this requires some quirky handling, but in
the end everything is much clearer; ok tedu (itojun might like to see
how ifconfig looks after this)
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.9 2003/06/03 02:56:08 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: find.c,v 1.9 2003/06/03 02:56:08 millert Exp $";
d59 1
a59 2
find_formplan(argv)
	char **argv;
d152 2
a153 3
find_execute(plan, paths)
	PLAN *plan;		/* search plan */
	char **paths;		/* array of pathnames to traverse */
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.8 2001/11/17 19:50:53 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: find.c,v 1.8 2001/11/17 19:50:53 millert Exp $";
d98 1
a98 1
			new = c_print();
d101 1
a101 1
			new = c_openparen();
d104 1
a104 1
			new = c_closeparen();
d107 1
a107 1
			new = c_print();
@


1.8
log
@o Block signals when running fts_read() so the SIGINFO handler will
  be sure to have a valid "entry" pointer
o In SIGINFO handler, do nothing if "entry" is NULL (Theo)
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.7 1999/10/04 21:17:32 millert Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: find.c,v 1.7 1999/10/04 21:17:32 millert Exp $";
@


1.7
log
@Move the chdir/fchdir hack so that it is local to the -execdir
function, since that's the only place it needs to be.  Doing it for
each function caused problems with multiple directories.
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.6 1999/10/03 19:07:35 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: find.c,v 1.6 1999/10/03 19:07:35 millert Exp $";
d50 1
d161 1
d167 8
a174 1
	while ((entry = fts_read(tree))) {
@


1.6
log
@Do not use FTS_CHDIRROOT flag as it is fatally flawed.  Instead,
do the chdir ourselves.  This fixes a problem with the -execdir option
with multiple relative directories.
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.5 1997/06/30 23:54:07 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: find.c,v 1.5 1997/06/30 23:54:07 millert Exp $";
a189 7
		 * Since fts does not chdir for the root node we
		 * have to do this ourselves to make -execdir work.
		 */
		if (entry->fts_level == FTS_ROOTLEVEL)
			chdir(entry->fts_accpath);
		 
		/*
a195 4

		/* Undo the chdir above to make fts happy. */
		if (entry->fts_level == FTS_ROOTLEVEL)
			fchdir(tree->fts_rfd);
@


1.5
log
@Some -Wall cleanliness.
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.4 1997/06/17 20:58:08 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: find.c,v 1.4 1997/06/17 20:58:08 kstailey Exp $";
d166 1
a166 1
		switch(entry->fts_info) {
d188 7
d197 1
a197 1
		 * call all the functions in the execution plan until one is
d201 6
a206 1
		for (p = plan; p && (p->eval)(p, entry); p = p->next);
@


1.4
log
@(foo *)NULL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.3 1996/10/24 03:46:04 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: find.c,v 1.3 1996/10/24 03:46:04 tholo Exp $";
d165 1
a165 1
	while (entry = fts_read(tree)) {
@


1.3
log
@Respond to SIGINFO; from PR #42
@
text
@d1 1
a1 1
/*	$OpenBSD: find.c,v 1.2 1996/06/26 05:33:09 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: find.c,v 1.2 1996/06/26 05:33:09 deraadt Exp $";
d162 1
a162 1
	if (!(tree = fts_open(paths, ftsoptions, (int (*)())NULL)))
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: find.c,v 1.1.1.1 1995/10/18 08:45:13 deraadt Exp $";
d152 3
a159 1
	register FTSENT *entry;
@


1.1
log
@Initial revision
@
text
@d1 2
d41 1
a41 1
static char rcsid[] = "$Id: find.c,v 1.6 1994/07/18 09:55:36 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
