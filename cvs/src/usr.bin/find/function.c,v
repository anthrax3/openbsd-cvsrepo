head	1.45;
access;
symbols
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.44.0.6
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.40.0.6
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.38.0.6
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.4
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.2
	OPENBSD_5_0:1.36.0.4
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.35.0.4
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.31.0.20
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.16
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.14
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.12
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.10
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.8
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.6
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.4
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.30.0.4
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.28.0.4
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	OPENBSD_3_0:1.20.0.6
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.4
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2017.01.03.21.31.16;	author tedu;	state Exp;
branches;
next	1.44;
commitid	cr2jR3uz1Q8R6G8A;

1.44
date	2015.04.18.18.28.37;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	6b2lLILbgCR1fvia;

1.43
date	2015.03.15.00.41.28;	author millert;	state Exp;
branches;
next	1.42;
commitid	IbVxlqGw2UipKdDr;

1.42
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	Uu5nFG3wCl0LACBb;

1.41
date	2014.05.18.08.10.00;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2013.04.20.04.52.24;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2013.04.19.15.51.27;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2012.01.05.10.21.33;	author sthen;	state Exp;
branches;
next	1.37;

1.37
date	2012.01.02.23.19.45;	author pascal;	state Exp;
branches;
next	1.36;

1.36
date	2010.12.01.01.20.29;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2009.12.09.13.59.43;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.27.23.59.38;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2009.09.16.12.06.33;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2009.08.27.16.19.27;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.15.14.19.45;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2004.07.20.03.50.25;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.01.18.25.47;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.26.07.27.29;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.10.22.20.46;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.03.02.56.08;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.30.15.16.41;	author matthieu;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.03.15.21.09;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.17.19.42.30;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.16.21.27.46;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.19.19.02.13;	author mpech;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.19.19.30.10;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.08.16.09.34;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.07.15.25.30;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.12.04.22.42.32;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	99.10.04.21.26.10;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	99.10.04.21.17.32;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.10.03.19.07.35;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.03.17.17.36.30;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	98.09.26.09.04.43;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.11.13.08.30.33;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.09.01.02.44.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.06.30.23.54.07;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.12.23.04.58.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.09.01.04.56.26;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.09.01.04.30.17;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.08.31.22.40.21;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.33.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.25.20.48.31;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.28.12.31.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.13;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.45
log
@add -delete option which can simplify the common case of wanting to delete
lots of files without the arcane -exec or error prone xargs.
code from freebsd.
ok millert
@
text
@/*	$OpenBSD: function.c,v 1.44 2015/04/18 18:28:37 deraadt Exp $	*/

/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Cimarron D. Taylor of the University of California, Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/mount.h>

#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <fnmatch.h>
#include <fts.h>
#include <grp.h>
#include <libgen.h>
#include <limits.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "find.h"
#include "extern.h"

#define	COMPARE(a, b) {							\
	switch (plan->flags) {						\
	case F_EQUAL:							\
		return (a == b);					\
	case F_LESSTHAN:						\
		return (a < b);						\
	case F_GREATER:							\
		return (a > b);						\
	default:							\
		abort();						\
	}								\
}

static PLAN *palloc(enum ntype, int (*)(PLAN *, FTSENT *));
static long long find_parsenum(PLAN *plan, char *option, char *vp, char *endch);
static void run_f_exec(PLAN *plan);
static PLAN *palloc(enum ntype t, int (*f)(PLAN *, FTSENT *));

int	f_amin(PLAN *, FTSENT *);
int	f_atime(PLAN *, FTSENT *);
int	f_cmin(PLAN *, FTSENT *);
int	f_ctime(PLAN *, FTSENT *);
int	f_always_true(PLAN *, FTSENT *);
int	f_empty(PLAN *, FTSENT *);
int	f_exec(PLAN *, FTSENT *);
int	f_execdir(PLAN *, FTSENT *);
int	f_flags(PLAN *, FTSENT *);
int	f_fstype(PLAN *, FTSENT *);
int	f_group(PLAN *, FTSENT *);
int	f_inum(PLAN *, FTSENT *);
int	f_empty(PLAN *, FTSENT *);
int	f_links(PLAN *, FTSENT *);
int	f_ls(PLAN *, FTSENT *);
int	f_maxdepth(PLAN *, FTSENT *);
int	f_mindepth(PLAN *, FTSENT *);
int	f_mtime(PLAN *, FTSENT *);
int	f_mmin(PLAN *, FTSENT *);
int	f_name(PLAN *, FTSENT *);
int	f_iname(PLAN *, FTSENT *);
int	f_newer(PLAN *, FTSENT *);
int	f_anewer(PLAN *, FTSENT *);
int	f_cnewer(PLAN *, FTSENT *);
int	f_nogroup(PLAN *, FTSENT *);
int	f_nouser(PLAN *, FTSENT *);
int	f_path(PLAN *, FTSENT *);
int	f_perm(PLAN *, FTSENT *);
int	f_print(PLAN *, FTSENT *);
int	f_print0(PLAN *, FTSENT *);
int	f_prune(PLAN *, FTSENT *);
int	f_size(PLAN *, FTSENT *);
int	f_type(PLAN *, FTSENT *);
int	f_user(PLAN *, FTSENT *);
int	f_expr(PLAN *, FTSENT *);
int	f_not(PLAN *, FTSENT *);
int	f_or(PLAN *, FTSENT *);

extern int dotfd;
extern time_t now;
extern FTS *tree;

/*
 * find_parsenum --
 *	Parse a string of the form [+-]# and return the value.
 */
static long long
find_parsenum(PLAN *plan, char *option, char *vp, char *endch)
{
	long long value;
	char *endchar, *str;	/* Pointer to character ending conversion. */
    
	/* Determine comparison from leading + or -. */
	str = vp;
	switch (*str) {
	case '+':
		++str;
		plan->flags = F_GREATER;
		break;
	case '-':
		++str;
		plan->flags = F_LESSTHAN;
		break;
	default:
		plan->flags = F_EQUAL;
		break;
	}
    
	/*
	 * Convert the string with strtoll().  Note, if strtoll() returns
	 * zero and endchar points to the beginning of the string we know
	 * we have a syntax error.
	 */
	value = strtoll(str, &endchar, 10);
	if (value == 0 && endchar == str)
		errx(1, "%s: %s: illegal numeric value", option, vp);
	if (endchar[0] && (endch == NULL || endchar[0] != *endch))
		errx(1, "%s: %s: illegal trailing character", option, vp);
	if (endch)
		*endch = endchar[0];
	return (value);
}

/*
 * The value of n for the inode times (atime, ctime, and mtime) is a range,
 * i.e. n matches from (n - 1) to n 24 hour periods.  This interacts with
 * -n, such that "-mtime -1" would be less than 0 days, which isn't what the
 * user wanted.  Correct so that -1 is "less than 1".
 */
#define	TIME_CORRECT(p, ttype)						\
	if ((p)->type == ttype && (p)->flags == F_LESSTHAN)		\
		++((p)->sec_data);

/*
 * -amin n functions --
 *
 *     True if the difference between the file access time and the
 *     current time is n min periods.
 */
int
f_amin(PLAN *plan, FTSENT *entry)
{
	extern time_t now;

	COMPARE((now - entry->fts_statp->st_atime +
	    60 - 1) / 60, plan->sec_data);
}

PLAN *
c_amin(char *arg, char ***ignored, int unused)
{
	PLAN *new;

	ftsoptions &= ~FTS_NOSTAT;

	new = palloc(N_AMIN, f_amin);
	new->sec_data = find_parsenum(new, "-amin", arg, NULL);
	TIME_CORRECT(new, N_AMIN);
	return (new);
}

/*
 * -atime n functions --
 *
 *	True if the difference between the file access time and the
 *	current time is n 24 hour periods.
 */
int
f_atime(PLAN *plan, FTSENT *entry)
{

	COMPARE((now - entry->fts_statp->st_atime +
	    SECSPERDAY - 1) / SECSPERDAY, plan->sec_data);
}
 
PLAN *
c_atime(char *arg, char ***ignored, int unused)
{
	PLAN *new;

	ftsoptions &= ~FTS_NOSTAT;

	new = palloc(N_ATIME, f_atime);
	new->sec_data = find_parsenum(new, "-atime", arg, NULL);
	TIME_CORRECT(new, N_ATIME);
	return (new);
}

/*
 * -cmin n functions --
 *
 *     True if the difference between the last change of file
 *     status information and the current time is n min periods.
 */
int
f_cmin(PLAN *plan, FTSENT *entry)
{
	extern time_t now;

	COMPARE((now - entry->fts_statp->st_ctime +
	    60 - 1) / 60, plan->sec_data);
}

PLAN *
c_cmin(char *arg, char ***ignored, int unused)
{
	PLAN *new;

	ftsoptions &= ~FTS_NOSTAT;

	new = palloc(N_CMIN, f_cmin);
	new->sec_data = find_parsenum(new, "-cmin", arg, NULL);
	TIME_CORRECT(new, N_CMIN);
	return (new);
}

/*
 * -ctime n functions --
 *
 *	True if the difference between the last change of file
 *	status information and the current time is n 24 hour periods.
 */
int
f_ctime(PLAN *plan, FTSENT *entry)
{

	COMPARE((now - entry->fts_statp->st_ctime +
	    SECSPERDAY - 1) / SECSPERDAY, plan->sec_data);
}
 
PLAN *
c_ctime(char *arg, char ***ignored, int unused)
{
	PLAN *new;

	ftsoptions &= ~FTS_NOSTAT;

	new = palloc(N_CTIME, f_ctime);
	new->sec_data = find_parsenum(new, "-ctime", arg, NULL);
	TIME_CORRECT(new, N_CTIME);
	return (new);
}

/*
 * -depth functions --
 *
 *	Always true, causes descent of the directory hierarchy to be done
 *	so that all entries in a directory are acted on before the directory
 *	itself.
 */
int
f_always_true(PLAN *plan, FTSENT *entry)
{
	return (1);
}
 
PLAN *
c_depth(char *ignore, char ***ignored, int unused)
{
	isdepth = 1;

	return (palloc(N_DEPTH, f_always_true));
}

/*
 * -delete functions
 */
int
f_delete(PLAN *plan, FTSENT *entry)
{

	/* can't delete these */
	if (strcmp(entry->fts_accpath, ".") == 0 ||
	    strcmp(entry->fts_accpath, "..") == 0)
		return 1;

	/* sanity check */
	if (isdepth == 0 ||                     /* depth off */
	    (ftsoptions & FTS_NOSTAT))          /* not stat()ing */
		errx(1, "-delete: insecure options got turned on");
	if (!(ftsoptions & FTS_PHYSICAL) ||     /* physical off */
	    (ftsoptions & FTS_LOGICAL))         /* or finally, logical on */
		errx(1, "-delete: forbidden when symlinks are followed");

	/* Potentially unsafe - do not accept relative paths whatsoever */
	if (entry->fts_level > FTS_ROOTLEVEL &&
	    strchr(entry->fts_accpath, '/') != NULL)
		errx(1, "-delete: %s: relative path potentially not safe",
		    entry->fts_accpath);
#if 0
	/* Turn off user immutable bits if running as root */
	if ((entry->fts_statp->st_flags & (UF_APPEND|UF_IMMUTABLE)) &&
	    !(entry->fts_statp->st_flags & (SF_APPEND|SF_IMMUTABLE)) &&
	    geteuid() == 0)
		lchflags(entry->fts_accpath,
		    entry->fts_statp->st_flags &= ~(UF_APPEND|UF_IMMUTABLE));
#endif
	/* rmdir directories, unlink everything else */
	if (S_ISDIR(entry->fts_statp->st_mode)) {
		if (rmdir(entry->fts_accpath) < 0 && errno != ENOTEMPTY)
			warn("-delete: rmdir(%s)", entry->fts_path);
	} else {
		if (unlink(entry->fts_accpath) < 0)
			warn("-delete: unlink(%s)", entry->fts_path);

	}

	return 1;
}

PLAN *
c_delete(char *ignore, char ***ignored, int unused)
{
	ftsoptions &= ~FTS_NOSTAT;
	isoutput = 1;
	isdelete = 1;
	isdepth = 1;

	return (palloc(N_DELETE, f_delete));
}
 
/*
 * -empty functions --
 *
 *	True if the file or directory is empty
 */
int
f_empty(PLAN *plan, FTSENT *entry)
{
	if (S_ISREG(entry->fts_statp->st_mode) && entry->fts_statp->st_size == 0)
		return (1);
	if (S_ISDIR(entry->fts_statp->st_mode)) {
		struct dirent *dp;
		int empty;
		DIR *dir;

		empty = 1;
		dir = opendir(entry->fts_accpath);
		if (dir == NULL)
			return (0);
		for (dp = readdir(dir); dp; dp = readdir(dir))
			if (dp->d_name[0] != '.' ||
			    (dp->d_name[1] != '\0' &&
			     (dp->d_name[1] != '.' || dp->d_name[2] != '\0'))) {
				empty = 0;
				break;
			}
		closedir(dir);
		return (empty);
	}
	return (0);
}

PLAN *
c_empty(char *ignore, char ***ignored, int unused)
{
	ftsoptions &= ~FTS_NOSTAT;

	return (palloc(N_EMPTY, f_empty));
}

/*
 * [-exec | -ok] utility [arg ... ] ; functions --
 * [-exec | -ok] utility [arg ... ] {} + functions --
 *
 *	If the end of the primary expression is delimited by a
 *	semicolon: true if the executed utility returns a zero value
 *	as exit status.  If "{}" occurs anywhere, it gets replaced by
 *	the current pathname.
 *
 *	If the end of the primary expression is delimited by a plus
 *	sign: always true. Pathnames for which the primary is
 *	evaluated shall be aggregated into sets. The utility will be
 *	executed once per set, with "{}" replaced by the entire set of
 *	pathnames (as if xargs). "{}" must appear last.
 *
 *	The current directory for the execution of utility is the same
 *	as the current directory when the find utility was started.
 *
 *	The primary -ok is different in that it requests affirmation
 *	of the user before executing the utility.
 */
int
f_exec(PLAN *plan, FTSENT *entry)
{
	int cnt, l;
	pid_t pid;
	int status;

	if (plan->flags & F_PLUSSET) {
		/*
		 * Confirm sufficient buffer space, then copy the path
		 * to the buffer.
		 */
		l = strlen(entry->fts_path);
		if (plan->ep_p + l < plan->ep_ebp) {
			plan->ep_bxp[plan->ep_narg++] = plan->ep_p;
			strlcpy(plan->ep_p, entry->fts_path, l + 1);
			plan->ep_p += l + 1;

			if (plan->ep_narg == plan->ep_maxargs)
				run_f_exec(plan);
		} else {
			/*
			 * Without sufficient space to copy in the next
			 * argument, run the command to empty out the
			 * buffer before re-attepting the copy.
			 */
			run_f_exec(plan);
			if (plan->ep_p + l < plan->ep_ebp) {
				plan->ep_bxp[plan->ep_narg++] = plan->ep_p;
				strlcpy(plan->ep_p, entry->fts_path, l + 1);
				plan->ep_p += l + 1;
			} else
				errx(1, "insufficient space for argument");
		}
		return (1);
	} else {
		for (cnt = 0; plan->e_argv[cnt]; ++cnt)
			if (plan->e_len[cnt])
				brace_subst(plan->e_orig[cnt],
				    &plan->e_argv[cnt],
				    entry->fts_path,
				    plan->e_len[cnt]);
		if (plan->flags & F_NEEDOK && !queryuser(plan->e_argv))
			return (0);

		/* don't mix output of command with find output */
		fflush(stdout);
		fflush(stderr);

		switch (pid = vfork()) {
		case -1:
			err(1, "fork");
			/* NOTREACHED */
		case 0:
			if (fchdir(dotfd)) {
				warn("chdir");
				_exit(1);
			}
			execvp(plan->e_argv[0], plan->e_argv);
			warn("%s", plan->e_argv[0]);
			_exit(1);
		}
		pid = waitpid(pid, &status, 0);
		return (pid != -1 && WIFEXITED(status) && !WEXITSTATUS(status));
	}
}

static void
run_f_exec(PLAN *plan)
{
	pid_t pid;
	int rval, status;

	/* Ensure arg list is null terminated. */
	plan->ep_bxp[plan->ep_narg] = NULL;

	/* Don't mix output of command with find output. */
 	fflush(stdout);
 	fflush(stderr);

	switch (pid = vfork()) {
	case -1:
		err(1, "vfork");
		/* NOTREACHED */
	case 0:
		if (fchdir(dotfd)) {
			warn("chdir");
			_exit(1);
		}
		execvp(plan->e_argv[0], plan->e_argv);
		warn("%s", plan->e_argv[0]);
		_exit(1);
	}

	/* Clear out the argument list. */
	plan->ep_narg = 0;
	plan->ep_bxp[plan->ep_narg] = NULL;
	/* As well as the argument buffer. */
	plan->ep_p = plan->ep_bbp;
	*plan->ep_p = '\0';

	pid = waitpid(pid, &status, 0);
	if (WIFEXITED(status))
		rval = WEXITSTATUS(status);
	else
		rval = -1;

	/*
	 * If we have a non-zero exit status, preserve it so find(1) can
	 * later exit with it.
	 */
	if (rval)
		plan->ep_rval = rval;
}
 
/*
 * c_exec --
 *	build three parallel arrays, one with pointers to the strings passed
 *	on the command line, one with (possibly duplicated) pointers to the
 *	argv array, and one with integer values that are lengths of the
 *	strings, but also flags meaning that the string has to be massaged.
 *
 *	If -exec ... {} +, use only the first array, but make it large
 *	enough to hold 5000 args (cf. src/usr.bin/xargs/xargs.c for a
 *	discussion), and then allocate ARG_MAX - 4K of space for args.
 */
PLAN *
c_exec(char *unused, char ***argvp, int isok)
{
	PLAN *new;			/* node returned */
	int cnt, brace, lastbrace;
	char **argv, **ap, *p;

	/* make sure the current directory is readable */
	if (dotfd == -1)
		errx(1, "%s: cannot open \".\"", isok ? "-ok" : "-exec");

	isoutput = 1;
    
	new = palloc(N_EXEC, f_exec);
	if (isok)
		new->flags |= F_NEEDOK;

	/*
	 * Terminate if we encounter an arg exactly equal to ";", or an
	 * arg exactly equal to "+" following an arg exactly equal to
	 * "{}".
	 */
	for (ap = argv = *argvp, brace = 0;; ++ap) {
		if (!*ap)
			errx(1, "%s: no terminating \";\" or \"+\"",
			    isok ? "-ok" : "-exec");
		lastbrace = brace;
		brace = 0;
		if (strcmp(*ap, "{}") == 0)
			brace = 1;
		if (strcmp(*ap, ";") == 0)
			break;
		if (strcmp(*ap, "+") == 0 && lastbrace) {
			new->flags |= F_PLUSSET;
			break;
		}
	}


	/*
	 * POSIX says -ok ... {} + "need not be supported," and it does
	 * not make much sense anyway.
	 */
	if (new->flags & F_NEEDOK && new->flags & F_PLUSSET)
		errx(1, "-ok: terminating \"+\" not permitted.");

	if (new->flags & F_PLUSSET) {
		u_int c, bufsize;

		cnt = ap - *argvp - 1;			/* units are words */
		new->ep_maxargs = 5000;
		new->e_argv = ereallocarray(NULL,
		    (size_t)(cnt + new->ep_maxargs), sizeof(char **));

		/* We start stuffing arguments after the user's last one. */
		new->ep_bxp = &new->e_argv[cnt];
		new->ep_narg = 0;

		/*
		 * Count up the space of the user's arguments, and
		 * subtract that from what we allocate.
		 */
		for (argv = *argvp, c = 0, cnt = 0;
		     argv < ap;
		     ++argv, ++cnt) {
			c += strlen(*argv) + 1;
 			new->e_argv[cnt] = *argv;
 		}
		bufsize = ARG_MAX - 4 * 1024 - c;


		/*
		 * Allocate, and then initialize current, base, and
		 * end pointers.
		 */
		new->ep_p = new->ep_bbp = malloc(bufsize + 1);
		new->ep_ebp = new->ep_bbp + bufsize - 1;
		new->ep_rval = 0;
	} else { /* !F_PLUSSET */
		cnt = ap - *argvp + 1;
		new->e_argv = ereallocarray(NULL, cnt, sizeof(char *));
		new->e_orig = ereallocarray(NULL, cnt, sizeof(char *));
		new->e_len = ereallocarray(NULL, cnt, sizeof(int));

		for (argv = *argvp, cnt = 0; argv < ap; ++argv, ++cnt) {
			new->e_orig[cnt] = *argv;
			for (p = *argv; *p; ++p)
				if (p[0] == '{' && p[1] == '}') {
					new->e_argv[cnt] =
						emalloc((u_int)PATH_MAX);
					new->e_len[cnt] = PATH_MAX;
					break;
				}
			if (!*p) {
				new->e_argv[cnt] = *argv;
				new->e_len[cnt] = 0;
			}
		}
		new->e_orig[cnt] = NULL;
 	}

	new->e_argv[cnt] = NULL;
	*argvp = argv + 1;
	return (new);
}
 
/*
 * -execdir utility [arg ... ] ; functions --
 *
 *	True if the executed utility returns a zero value as exit status.
 *	The end of the primary expression is delimited by a semicolon.  If
 *	"{}" occurs anywhere, it gets replaced by the unqualified pathname.
 *	The current directory for the execution of utility is the same as
 *	the directory where the file lives.
 */
int
f_execdir(PLAN *plan, FTSENT *entry)
{
	int cnt;
	pid_t pid;
	int status, fd;
	char base[PATH_MAX];

	/* fts(3) does not chdir for the root level so we do it ourselves. */
	if (entry->fts_level == FTS_ROOTLEVEL) {
		if ((fd = open(".", O_RDONLY)) == -1) {
			warn("cannot open \".\"");
			return (0);
		}
		if (chdir(entry->fts_accpath)) {
			(void) close(fd);
			return (0);
		}
	}

	/* Substitute basename(path) for {} since cwd is it's parent dir */
	(void)strncpy(base, basename(entry->fts_path), sizeof(base) - 1);
	base[sizeof(base) - 1] = '\0';
	for (cnt = 0; plan->e_argv[cnt]; ++cnt)
		if (plan->e_len[cnt])
			brace_subst(plan->e_orig[cnt], &plan->e_argv[cnt],
			    base, plan->e_len[cnt]);

	/* don't mix output of command with find output */
	fflush(stdout);
	fflush(stderr);

	switch (pid = vfork()) {
	case -1:
		err(1, "fork");
		/* NOTREACHED */
	case 0:
		execvp(plan->e_argv[0], plan->e_argv);
		warn("%s", plan->e_argv[0]);
		_exit(1);
	}

	/* Undo the above... */
	if (entry->fts_level == FTS_ROOTLEVEL) {
		if (fchdir(fd) == -1) {
			warn("unable to chdir back to starting directory");
			(void) close(fd);
			return (0);
		}
		(void) close(fd);
	}

	pid = waitpid(pid, &status, 0);
	return (pid != -1 && WIFEXITED(status) && !WEXITSTATUS(status));
}
 
/*
 * c_execdir --
 *	build three parallel arrays, one with pointers to the strings passed
 *	on the command line, one with (possibly duplicated) pointers to the
 *	argv array, and one with integer values that are lengths of the
 *	strings, but also flags meaning that the string has to be massaged.
 */
PLAN *
c_execdir(char *ignored, char ***argvp, int unused)
{
	PLAN *new;			/* node returned */
	int cnt;
	char **argv, **ap, *p;

	ftsoptions &= ~FTS_NOSTAT;
	isoutput = 1;
    
	new = palloc(N_EXECDIR, f_execdir);

	for (ap = argv = *argvp;; ++ap) {
		if (!*ap)
			errx(1,
			    "-execdir: no terminating \";\"");
		if (**ap == ';')
			break;
	}

	cnt = ap - *argvp + 1;
	new->e_argv = ereallocarray(NULL, cnt, sizeof(char *));
	new->e_orig = ereallocarray(NULL, cnt, sizeof(char *));
	new->e_len = ereallocarray(NULL, cnt, sizeof(int));

	for (argv = *argvp, cnt = 0; argv < ap; ++argv, ++cnt) {
		new->e_orig[cnt] = *argv;
		for (p = *argv; *p; ++p)
			if (p[0] == '{' && p[1] == '}') {
				new->e_argv[cnt] = emalloc((u_int)PATH_MAX);
				new->e_len[cnt] = PATH_MAX;
				break;
			}
		if (!*p) {
			new->e_argv[cnt] = *argv;
			new->e_len[cnt] = 0;
		}
	}
	new->e_argv[cnt] = new->e_orig[cnt] = NULL;

	*argvp = argv + 1;
	return (new);
}

/*
 * -flags functions --
 *
 *	The flags argument is used to represent file flags bits.
 */
int
f_flags(PLAN *plan, FTSENT *entry)
{
	u_int flags;

	flags = entry->fts_statp->st_flags &
	    (UF_NODUMP | UF_IMMUTABLE | UF_APPEND | UF_OPAQUE |
	     SF_ARCHIVED | SF_IMMUTABLE | SF_APPEND);
	if (plan->flags == F_ATLEAST)
		/* note that plan->fl_flags always is a subset of
		   plan->fl_mask */
		return ((flags & plan->fl_mask) == plan->fl_flags);
	else
		return (flags == plan->fl_flags);
	/* NOTREACHED */
}

PLAN *
c_flags(char *flags_str, char ***ignored, int unused)
{
	PLAN *new;
	u_int32_t flags, notflags;

	ftsoptions &= ~FTS_NOSTAT;

	new = palloc(N_FLAGS, f_flags);

	if (*flags_str == '-') {
		new->flags = F_ATLEAST;
		++flags_str;
	}

	if (strtofflags(&flags_str, &flags, &notflags) == 1)
		errx(1, "-flags: %s: illegal flags string", flags_str);

	new->fl_flags = flags;
	new->fl_mask = flags | notflags;
	return (new);
}
 
/*
 * -follow functions --
 *
 *	Always true, causes symbolic links to be followed on a global
 *	basis.
 */
PLAN *
c_follow(char *ignore, char ***ignored, int unused)
{
	ftsoptions &= ~FTS_PHYSICAL;
	ftsoptions |= FTS_LOGICAL;

	return (palloc(N_FOLLOW, f_always_true));
}
 
/*
 * -fstype functions --
 *
 *	True if the file is of a certain type.
 */
int
f_fstype(PLAN *plan, FTSENT *entry)
{
	static dev_t curdev;	/* need a guaranteed illegal dev value */
	static int first = 1;
	struct statfs sb;
	static short val;
	static char fstype[MFSNAMELEN];
	char *p, save[2];

	/* Only check when we cross mount point. */
	if (first || curdev != entry->fts_statp->st_dev) {
		curdev = entry->fts_statp->st_dev;

		/*
		 * Statfs follows symlinks; find wants the link's file system,
		 * not where it points.
		 */
		if (entry->fts_info == FTS_SL ||
		    entry->fts_info == FTS_SLNONE) {
			if ((p = strrchr(entry->fts_accpath, '/')))
				++p;
			else
				p = entry->fts_accpath;
			save[0] = p[0];
			p[0] = '.';
			save[1] = p[1];
			p[1] = '\0';
			
		} else 
			p = NULL;

		if (statfs(entry->fts_accpath, &sb))
			err(1, "%s", entry->fts_accpath);

		if (p) {
			p[0] = save[0];
			p[1] = save[1];
		}

		first = 0;

		/*
		 * Further tests may need both of these values, so
		 * always copy both of them.
		 */
		val = sb.f_flags;
		strncpy(fstype, sb.f_fstypename, MFSNAMELEN);
	}
	switch (plan->flags) {
	case F_MTFLAG:
		return (val & plan->mt_data);	
	case F_MTTYPE:
		return (strncmp(fstype, plan->c_data, MFSNAMELEN) == 0);
	default:
		abort();
	}
}
 
PLAN *
c_fstype(char *arg, char ***ignored, int unused)
{
	PLAN *new;
    
	ftsoptions &= ~FTS_NOSTAT;
    
	new = palloc(N_FSTYPE, f_fstype);
	switch (*arg) {
	case 'l':
		if (!strcmp(arg, "local")) {
			new->flags = F_MTFLAG;
			new->mt_data = MNT_LOCAL;
			return (new);
		}
		break;
	case 'r':
		if (!strcmp(arg, "rdonly")) {
			new->flags = F_MTFLAG;
			new->mt_data = MNT_RDONLY;
			return (new);
		}
		break;
	}

	new->flags = F_MTTYPE;
	new->c_data = arg;
	return (new);
}
 
/*
 * -group gname functions --
 *
 *	True if the file belongs to the group gname.  If gname is numeric and
 *	an equivalent of the getgrnam() function does not return a valid group
 *	name, gname is taken as a group ID.
 */
int
f_group(PLAN *plan, FTSENT *entry)
{
	return (entry->fts_statp->st_gid == plan->g_data);
}
 
PLAN *
c_group(char *gname, char ***ignored, int unused)
{
	PLAN *new;
	struct group *g;
	gid_t gid;
    
	ftsoptions &= ~FTS_NOSTAT;

	g = getgrnam(gname);
	if (g == NULL) {
		const char *errstr;

		gid = strtonum(gname, 0, GID_MAX, &errstr);
		if (errstr)
			errx(1, "-group: %s: no such group", gname);
	} else
		gid = g->gr_gid;
    
	new = palloc(N_GROUP, f_group);
	new->g_data = gid;
	return (new);
}

/*
 * -inum n functions --
 *
 *	True if the file has inode # n.
 */
int
f_inum(PLAN *plan, FTSENT *entry)
{
	COMPARE(entry->fts_statp->st_ino, plan->i_data);
}
 
PLAN *
c_inum(char *arg, char ***ignored, int unused)
{
	long long inum;
	PLAN *new;
    
	ftsoptions &= ~FTS_NOSTAT;
    
	new = palloc(N_INUM, f_inum);
	inum = find_parsenum(new, "-inum", arg, NULL);
	if (inum != (ino_t)inum)
		errx(1, "-inum: %s: number too great", arg);
	new->i_data = inum;
	return (new);
}
 
/*
 * -links n functions --
 *
 *	True if the file has n links.
 */
int
f_links(PLAN *plan, FTSENT *entry)
{
	COMPARE(entry->fts_statp->st_nlink, plan->l_data);
}
 
PLAN *
c_links(char *arg, char ***ignored, int unused)
{
	PLAN *new;
	long long nlink;
    
	ftsoptions &= ~FTS_NOSTAT;
    
	new = palloc(N_LINKS, f_links);
	nlink = find_parsenum(new, "-links", arg, NULL);
	if (nlink != (nlink_t)nlink)
		errx(1, "-links: %s: number too great", arg);
	new->l_data = nlink;
	return (new);
}
 
/*
 * -ls functions --
 *
 *	Always true - prints the current entry to stdout in "ls" format.
 */
int
f_ls(PLAN *plan, FTSENT *entry)
{
	printlong(entry->fts_path, entry->fts_accpath, entry->fts_statp);
	return (1);
}
 
PLAN *
c_ls(char *ignore, char ***ignored, int unused)
{
	ftsoptions &= ~FTS_NOSTAT;
	isoutput = 1;
    
	return (palloc(N_LS, f_ls));
}

/*
 * - maxdepth n functions --
 *
 *	True if the current search depth is less than or equal to the
 *	maximum depth specified
 */
int
f_maxdepth(PLAN *plan, FTSENT *entry)
{

	if (entry->fts_level >= plan->max_data)
		fts_set(tree, entry, FTS_SKIP);
	return (entry->fts_level <= plan->max_data);
}

PLAN *
c_maxdepth(char *arg, char ***ignored, int unused)
{
	PLAN *new;
	const char *errstr = NULL;

	new = palloc(N_MAXDEPTH, f_maxdepth);
	new->max_data = strtonum(arg, 0, FTS_MAXLEVEL, &errstr);
	if (errstr)
		errx(1, "%s: maxdepth value %s", arg, errstr);
	return (new);
}

/*
 * - mindepth n functions --
 *
 *	True if the current search depth is greater than or equal to the
 *	minimum depth specified
 */
int
f_mindepth(PLAN *plan, FTSENT *entry)
{

	return (entry->fts_level >= plan->min_data);
}

PLAN *
c_mindepth(char *arg, char ***ignored, int unused)
{
	PLAN *new;
	const char *errstr = NULL;

	new = palloc(N_MINDEPTH, f_mindepth);
	new->min_data = strtonum(arg, 0, INT_MAX, &errstr);
	if (errstr)
		errx(1, "-mindepth: %s: value %s", arg, errstr);
	return (new);
}

/*
 * -mtime n functions --
 *
 *	True if the difference between the file modification time and the
 *	current time is n 24 hour periods.
 */
int
f_mtime(PLAN *plan, FTSENT *entry)
{

	COMPARE((now - entry->fts_statp->st_mtime + SECSPERDAY - 1) /
	    SECSPERDAY, plan->sec_data);
}
 
PLAN *
c_mtime(char *arg, char ***ignored, int unused)
{
	PLAN *new;

	ftsoptions &= ~FTS_NOSTAT;

	new = palloc(N_MTIME, f_mtime);
	new->sec_data = find_parsenum(new, "-mtime", arg, NULL);
	TIME_CORRECT(new, N_MTIME);
	return (new);
}

/*
 * -mmin n functions --
 *
 *     True if the difference between the file modification time and the
 *     current time is n min periods.
 */
int
f_mmin(PLAN *plan, FTSENT *entry)
{
	extern time_t now;

	COMPARE((now - entry->fts_statp->st_mtime + 60 - 1) /
	    60, plan->sec_data);
}

PLAN *
c_mmin(char *arg, char ***ignored, int unused)
{
	PLAN *new;

	ftsoptions &= ~FTS_NOSTAT;

	new = palloc(N_MMIN, f_mmin);
	new->sec_data = find_parsenum(new, "-mmin", arg, NULL);
	TIME_CORRECT(new, N_MMIN);
	return (new);
}

/*
 * -name functions --
 *
 *	True if the basename of the filename being examined
 *	matches pattern using Pattern Matching Notation S3.14
 */
int
f_name(PLAN *plan, FTSENT *entry)
{
	return (!fnmatch(plan->c_data, entry->fts_name, 0));
}
 
PLAN *
c_name(char *pattern, char ***ignored, int unused)
{
	PLAN *new;

	new = palloc(N_NAME, f_name);
	new->c_data = pattern;
	return (new);
}

/*
 * -iname functions --
 *
 *	Similar to -name, but does case insensitive matching
 *	
 */
int
f_iname(PLAN *plan, FTSENT *entry)
{
	return (!fnmatch(plan->c_data, entry->fts_name, FNM_CASEFOLD));
}
 
PLAN *
c_iname(char *pattern, char ***ignored, int unused)
{
	PLAN *new;

	new = palloc(N_INAME, f_iname);
	new->c_data = pattern;
	return (new);
}
 
/*
 * -newer file functions --
 *
 *	True if the current file has been modified more recently
 *	then the modification time of the file named by the pathname
 *	file.
 */
int
f_newer(PLAN *plan, FTSENT *entry)
{

	return (entry->fts_statp->st_mtimespec.tv_sec > plan->t_data.tv_sec ||
	    (entry->fts_statp->st_mtimespec.tv_sec == plan->t_data.tv_sec &&
	    entry->fts_statp->st_mtimespec.tv_nsec > plan->t_data.tv_nsec));
}
 
PLAN *
c_newer(char *filename, char ***ignored, int unused)
{
	PLAN *new;
	struct stat sb;
    
	ftsoptions &= ~FTS_NOSTAT;

	if (stat(filename, &sb))
		err(1, "%s", filename);
	new = palloc(N_NEWER, f_newer);
	memcpy(&new->t_data, &sb.st_mtimespec, sizeof(struct timespec));
	return (new);
}
 
/*
 * -anewer file functions --
 *
 *	True if the current file has been accessed more recently
 *	then the access time of the file named by the pathname
 *	file.
 */
int
f_anewer(PLAN *plan, FTSENT *entry)
{

	return (entry->fts_statp->st_atimespec.tv_sec > plan->t_data.tv_sec ||
	    (entry->fts_statp->st_atimespec.tv_sec == plan->t_data.tv_sec &&
	    entry->fts_statp->st_atimespec.tv_nsec > plan->t_data.tv_nsec));
}
 
PLAN *
c_anewer(char *filename, char ***ignored, int unused)
{
	PLAN *new;
	struct stat sb;
    
	ftsoptions &= ~FTS_NOSTAT;

	if (stat(filename, &sb))
		err(1, "%s", filename);
	new = palloc(N_NEWER, f_anewer);
	memcpy(&new->t_data, &sb.st_atimespec, sizeof(struct timespec));
	return (new);
}
 
/*
 * -cnewer file functions --
 *
 *	True if the current file has been changed more recently
 *	then the inode change time of the file named by the pathname
 *	file.
 */
int
f_cnewer(PLAN *plan, FTSENT *entry)
{

	return (entry->fts_statp->st_ctimespec.tv_sec > plan->t_data.tv_sec ||
	    (entry->fts_statp->st_ctimespec.tv_sec == plan->t_data.tv_sec &&
	    entry->fts_statp->st_ctimespec.tv_nsec > plan->t_data.tv_nsec));
}
 
PLAN *
c_cnewer(char *filename, char ***ignored, int unused)
{
	PLAN *new;
	struct stat sb;
    
	ftsoptions &= ~FTS_NOSTAT;

	if (stat(filename, &sb))
		err(1, "%s", filename);
	new = palloc(N_NEWER, f_cnewer);
	memcpy(&new->t_data, &sb.st_ctimespec, sizeof(struct timespec));
	return (new);
}
 
/*
 * -nogroup functions --
 *
 *	True if file belongs to a user ID for which the equivalent
 *	of the getgrnam() 9.2.1 [POSIX.1] function returns NULL.
 */
int
f_nogroup(PLAN *plan, FTSENT *entry)
{
	return (group_from_gid(entry->fts_statp->st_gid, 1) ? 0 : 1);
}
 
PLAN *
c_nogroup(char *ignore, char ***ignored, int unused)
{
	ftsoptions &= ~FTS_NOSTAT;

	return (palloc(N_NOGROUP, f_nogroup));
}
 
/*
 * -nouser functions --
 *
 *	True if file belongs to a user ID for which the equivalent
 *	of the getpwuid() 9.2.2 [POSIX.1] function returns NULL.
 */
int
f_nouser(PLAN *plan, FTSENT *entry)
{
	return (user_from_uid(entry->fts_statp->st_uid, 1) ? 0 : 1);
}
 
PLAN *
c_nouser(char *ignore, char ***ignored, int unused)
{
	ftsoptions &= ~FTS_NOSTAT;

	return (palloc(N_NOUSER, f_nouser));
}
 
/*
 * -path functions --
 *
 *	True if the path of the filename being examined
 *	matches pattern using Pattern Matching Notation S3.14
 */
int
f_path(PLAN *plan, FTSENT *entry)
{
	return (!fnmatch(plan->c_data, entry->fts_path, 0));
}
 
PLAN *
c_path(char *pattern, char ***ignored, int unused)
{
	PLAN *new;

	new = palloc(N_NAME, f_path);
	new->c_data = pattern;
	return (new);
}
 
/*
 * -perm functions --
 *
 *	The mode argument is used to represent file mode bits.  If it starts
 *	with a leading digit, it's treated as an octal mode, otherwise as a
 *	symbolic mode.
 */
int
f_perm(PLAN *plan, FTSENT *entry)
{
	mode_t mode;

	mode = entry->fts_statp->st_mode &
	    (S_ISUID|S_ISGID|S_ISTXT|S_IRWXU|S_IRWXG|S_IRWXO);
	if (plan->flags == F_ATLEAST)
		return ((plan->m_data | mode) == mode);
	else
		return (mode == plan->m_data);
	/* NOTREACHED */
}
 
PLAN *
c_perm(char *perm, char ***ignored, int unused)
{
	PLAN *new;
	void *set;

	ftsoptions &= ~FTS_NOSTAT;

	new = palloc(N_PERM, f_perm);

	if (*perm == '-') {
		new->flags = F_ATLEAST;
		++perm;
	}

	if ((set = setmode(perm)) == NULL)
		errx(1, "-perm: %s: illegal mode string", perm);

	new->m_data = getmode(set, 0);
	free(set);
	return (new);
}
 
/*
 * -print functions --
 *
 *	Always true, causes the current pathame to be written to
 *	standard output.
 */
int
f_print(PLAN *plan, FTSENT *entry)
{
	(void)printf("%s\n", entry->fts_path);
	return(1);
}

/* ARGSUSED */
int
f_print0(PLAN *plan, FTSENT *entry)
{
	(void)fputs(entry->fts_path, stdout);
	(void)fputc('\0', stdout);
	return(1);
}
 
PLAN *
c_print(char *ignore, char ***ignored, int unused)
{
	isoutput = 1;

	return(palloc(N_PRINT, f_print));
}

PLAN *
c_print0(char *ignore, char ***ignored, int unused)
{
	isoutput = 1;

	return(palloc(N_PRINT0, f_print0));
}
 
/*
 * -prune functions --
 *
 *	Prune a portion of the hierarchy.
 */
int
f_prune(PLAN *plan, FTSENT *entry)
{

	if (fts_set(tree, entry, FTS_SKIP))
		err(1, "%s", entry->fts_path);
	return (1);
}
 
PLAN *
c_prune(char *ignore, char ***ignored, int unused)
{
	return (palloc(N_PRUNE, f_prune));
}
 
/*
 * -size n[c] functions --
 *
 *	True if the file size in bytes, divided by an implementation defined
 *	value and rounded up to the next integer, is n.  If n is followed by
 *	a c, the size is in bytes.
 */
#define	FIND_SIZE	512
static int divsize = 1;

int
f_size(PLAN *plan, FTSENT *entry)
{
	off_t size;

	size = divsize ? (entry->fts_statp->st_size + FIND_SIZE - 1) /
	    FIND_SIZE : entry->fts_statp->st_size;
	COMPARE(size, plan->o_data);
}
 
PLAN *
c_size(char *arg, char ***ignored, int unused)
{
	PLAN *new;
	char endch;
    
	ftsoptions &= ~FTS_NOSTAT;

	new = palloc(N_SIZE, f_size);
	endch = 'c';
	new->o_data = find_parsenum(new, "-size", arg, &endch);
	if (endch == 'c')
		divsize = 0;
	return (new);
}
 
/*
 * -type c functions --
 *
 *	True if the type of the file is c, where c is b, c, d, p, or f for
 *	block special file, character special file, directory, FIFO, or
 *	regular file, respectively.
 */
int
f_type(PLAN *plan, FTSENT *entry)
{
	return ((entry->fts_statp->st_mode & S_IFMT) == plan->m_data);
}
 
PLAN *
c_type(char *typestring, char ***ignored, int unused)
{
	PLAN *new;
	mode_t  mask;
    
	ftsoptions &= ~FTS_NOSTAT;

	switch (typestring[0]) {
	case 'b':
		mask = S_IFBLK;
		break;
	case 'c':
		mask = S_IFCHR;
		break;
	case 'd':
		mask = S_IFDIR;
		break;
	case 'f':
		mask = S_IFREG;
		break;
	case 'l':
		mask = S_IFLNK;
		break;
	case 'p':
		mask = S_IFIFO;
		break;
	case 's':
		mask = S_IFSOCK;
		break;
	default:
		errx(1, "-type: %s: unknown type", typestring);
	}
    
	new = palloc(N_TYPE, f_type);
	new->m_data = mask;
	return (new);
}
 
/*
 * -user uname functions --
 *
 *	True if the file belongs to the user uname.  If uname is numeric and
 *	an equivalent of the getpwnam() S9.2.2 [POSIX.1] function does not
 *	return a valid user name, uname is taken as a user ID.
 */
int
f_user(PLAN *plan, FTSENT *entry)
{
	return (entry->fts_statp->st_uid == plan->u_data);
}
 
PLAN *
c_user(char *username, char ***ignored, int unused)
{
	PLAN *new;
	struct passwd *p;
	uid_t uid;
    
	ftsoptions &= ~FTS_NOSTAT;

	p = getpwnam(username);
	if (p == NULL) {
		const char *errstr;

		uid = strtonum(username, 0, UID_MAX, &errstr);
		if (errstr)
			errx(1, "-user: %s: no such user", username);
	} else
		uid = p->pw_uid;

	new = palloc(N_USER, f_user);
	new->u_data = uid;
	return (new);
}
 
/*
 * -xdev functions --
 *
 *	Always true, causes find not to decend past directories that have a
 *	different device ID (st_dev, see stat() S5.6.2 [POSIX.1])
 */
PLAN *
c_xdev(char *ignore, char ***ignored, int unused)
{
	ftsoptions |= FTS_XDEV;

	return (palloc(N_XDEV, f_always_true));
}

/*
 * ( expression ) functions --
 *
 *	True if expression is true.
 */
int
f_expr(PLAN *plan, FTSENT *entry)
{
	PLAN *p;
	int state;

	for (p = plan->p_data[0];
	    p && (state = (p->eval)(p, entry)); p = p->next);
	return (state);
}
 
/*
 * N_OPENPAREN and N_CLOSEPAREN nodes are temporary place markers.  They are
 * eliminated during phase 2 of find_formplan() --- the '(' node is converted
 * to a N_EXPR node containing the expression and the ')' node is discarded.
 */
PLAN *
c_openparen(char *ignore, char ***ignored, int unused)
{
	return (palloc(N_OPENPAREN, (int (*)(PLAN *, FTSENT *))-1));
}
 
PLAN *
c_closeparen(char *ignore, char ***ignored, int unused)
{
	return (palloc(N_CLOSEPAREN, (int (*)(PLAN *, FTSENT *))-1));
}
 
/*
 * ! expression functions --
 *
 *	Negation of a primary; the unary NOT operator.
 */
int
f_not(PLAN *plan, FTSENT *entry)
{
	PLAN *p;
	int state;

	for (p = plan->p_data[0];
	    p && (state = (p->eval)(p, entry)); p = p->next);
	return (!state);
}
 
PLAN *
c_not(char *ignore, char ***ignored, int unused)
{
	return (palloc(N_NOT, f_not));
}
 
/*
 * expression -o expression functions --
 *
 *	Alternation of primaries; the OR operator.  The second expression is
 * not evaluated if the first expression is true.
 */
int
f_or(PLAN *plan, FTSENT *entry)
{
	PLAN *p;
	int state;

	for (p = plan->p_data[0];
	    p && (state = (p->eval)(p, entry)); p = p->next);

	if (state)
		return (1);

	for (p = plan->p_data[1];
	    p && (state = (p->eval)(p, entry)); p = p->next);
	return (state);
}

PLAN *
c_or(char *ignore, char ***ignored, int unused)
{
	return (palloc(N_OR, f_or));
}


/*
 * plan_cleanup --
 *	Check and see if the specified plan has any residual state,
 *	and if so, clean it up as appropriate.
 *
 *	At the moment, only N_EXEC has state. Two kinds: 1)
 * 	lists of files to feed to subprocesses 2) State on exit
 *	statusses of past subprocesses.
 */
/* ARGSUSED1 */
int
plan_cleanup(PLAN *plan, void *arg)
{
	if (plan->type==N_EXEC && plan->ep_narg)
		run_f_exec(plan);

	return plan->ep_rval;		/* Passed save exit-status up chain */
}


static PLAN *
palloc(enum ntype t, int (*f)(PLAN *, FTSENT *))
{
	PLAN *new;

	if ((new = calloc(1, sizeof(PLAN)))) {
		new->type = t;
		new->eval = f;
		return (new);
	}
	err(1, NULL);
	/* NOTREACHED */
}
@


1.44
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.43 2015/03/15 00:41:28 millert Exp $	*/
d297 57
@


1.43
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.42 2015/01/16 06:40:07 deraadt Exp $	*/
d886 4
a889 2
		gid = atoi(gname);
		if (gid == 0 && gname[0] != '0')
d1019 1
d1022 3
a1024 1
	new->min_data = atoi(arg);
d1496 4
a1499 2
		uid = atoi(username);
		if (uid == 0 && username[0] != '0')
@


1.42
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.41 2014/05/18 08:10:00 espie Exp $	*/
a51 1
#include <tzfile.h>
@


1.41
log
@use reallocarray
okay chl@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.40 2013/04/20 04:52:24 deraadt Exp $	*/
a34 2
#include <sys/param.h>
#include <sys/ucred.h>
d576 2
a577 2
						emalloc((u_int)MAXPATHLEN);
					new->e_len[cnt] = MAXPATHLEN;
d608 1
a608 1
	char base[MAXPATHLEN];
d694 2
a695 2
				new->e_argv[cnt] = emalloc((u_int)MAXPATHLEN);
				new->e_len[cnt] = MAXPATHLEN;
@


1.40
log
@adjust comment
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.39 2013/04/19 15:51:27 deraadt Exp $	*/
d540 2
a541 2
		new->e_argv = (char **)emalloc((u_int)(cnt + new->ep_maxargs)
						* sizeof(char **));
d569 3
a571 3
		new->e_argv = (char **)emalloc((u_int)cnt * sizeof(char *));
		new->e_orig = (char **)emalloc((u_int)cnt * sizeof(char *));
		new->e_len = (int *)emalloc((u_int)cnt * sizeof(int));
d688 3
a690 3
	new->e_argv = (char **)emalloc((u_int)cnt * sizeof(char *));
	new->e_orig = (char **)emalloc((u_int)cnt * sizeof(char *));
	new->e_len = (int *)emalloc((u_int)cnt * sizeof(int));
@


1.39
log
@handle large numbers.  this fixes time_t beyond 2038, constrains the
range of i_num correctly, and now handles files > 4GB in size on 32-bit
machines.
ok otto millert
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.38 2012/01/05 10:21:33 sthen Exp $	*/
d147 3
a149 3
	 * Convert the string with strtol().  Note, if strtol() returns zero
	 * and endchar points to the beginning of the string we know we have
	 * a syntax error.
@


1.38
log
@Fix typos in comment (s,exacty,exactly,)
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.37 2012/01/02 23:19:45 pascal Exp $	*/
d74 1
a74 1
static long find_parsenum(PLAN *plan, char *option, char *vp, char *endch);
d124 1
a124 1
static long
d127 1
a127 1
	long value;
d151 1
a151 1
	value = strtol(str, &endchar, 10);
d914 1
d920 4
a923 1
	new->i_data = find_parsenum(new, "-inum", arg, NULL);
d942 1
d947 4
a950 1
	new->l_data = (nlink_t)find_parsenum(new, "-links", arg, NULL);
@


1.37
log
@Add support for "find ... -exec foo {} \+".

From the manpage:

If terminated by a plus sign (``+''), the pathnames for which the
primary is evaluated are aggregated into sets, and utility will
be invoked once per set, similar to xargs(1).  If any invocation
exits with non-zero exit status, then find will eventually do so
as well, but this does not cause find to exit early.  The string
``{}'' must appear, and must appear last.  Each set is limited to
no more than 5,000 pathnames, and is also limited such that the
invocation of utility does not exceed ARG_MAX.

Code comes from NetBSD, written by John Hawkinson.  Tested by eivinde at
terraplane dot org and myself for quite some time.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.36 2010/12/01 01:20:29 millert Exp $	*/
d507 2
a508 2
	 * Terminate if we encounter an arg exacty equal to ";", or an
	 * arg exacty equal to "+" following an arg exacty equal to
@


1.36
log
@Don't error out if we can't opendir() when -empty is used.
Fix by Bakul Shah.  OK deraadt@@ halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.35 2009/12/09 13:59:43 millert Exp $	*/
d49 1
d75 1
d344 1
d346 13
a358 5
 *	True if the executed utility returns a zero value as exit status.
 *	The end of the primary expression is delimited by a semicolon.  If
 *	"{}" occurs anywhere, it gets replaced by the current pathname.
 *	The current directory for the execution of utility is the same as
 *	the current directory when the find utility was started.
d360 2
a361 2
 *	The primary -ok is different in that it requests affirmation of the
 *	user before executing the utility.
d366 1
a366 1
	int cnt;
d370 65
a434 4
	for (cnt = 0; plan->e_argv[cnt]; ++cnt)
		if (plan->e_len[cnt])
			brace_subst(plan->e_orig[cnt], &plan->e_argv[cnt],
			    entry->fts_path, plan->e_len[cnt]);
d436 2
a437 2
	if (plan->flags == F_NEEDOK && !queryuser(plan->e_argv))
		return (0);
d439 3
a441 3
	/* don't mix output of command with find output */
	fflush(stdout);
	fflush(stderr);
d445 1
a445 1
		err(1, "fork");
d456 8
d465 11
a475 1
	return (pid != -1 && WIFEXITED(status) && !WEXITSTATUS(status));
d484 4
d493 1
a493 1
	int cnt;
d504 1
a504 1
		new->flags = F_NEEDOK;
d506 6
a511 1
	for (ap = argv = *argvp;; ++ap) {
d513 10
a522 3
			errx(1,
			    "%s: no terminating \";\"", isok ? "-ok" : "-exec");
		if (**ap == ';')
d524 1
a526 4
	cnt = ap - *argvp + 1;
	new->e_argv = (char **)emalloc((u_int)cnt * sizeof(char *));
	new->e_orig = (char **)emalloc((u_int)cnt * sizeof(char *));
	new->e_len = (int *)emalloc((u_int)cnt * sizeof(int));
d528 57
a584 7
	for (argv = *argvp, cnt = 0; argv < ap; ++argv, ++cnt) {
		new->e_orig[cnt] = *argv;
		for (p = *argv; *p; ++p)
			if (p[0] == '{' && p[1] == '}') {
				new->e_argv[cnt] = emalloc((u_int)MAXPATHLEN);
				new->e_len[cnt] = MAXPATHLEN;
				break;
a585 3
		if (!*p) {
			new->e_argv[cnt] = *argv;
			new->e_len[cnt] = 0;
d587 2
a588 2
	}
	new->e_argv[cnt] = new->e_orig[cnt] = NULL;
d590 1
d1594 21
@


1.35
log
@We only need to fchdir(dotfd) for the -exec and -ok primaries so
defer the check for dotfd != -1 until we know we will need it.
Based on a diff from schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.34 2009/10/27 23:59:38 deraadt Exp $	*/
d318 1
a318 1
			err(1, "%s", entry->fts_accpath);
@


1.34
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.33 2009/09/16 12:06:33 millert Exp $	*/
d401 4
@


1.33
log
@Allow -maxdepth 0; noticed by bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.32 2009/08/27 16:19:27 millert Exp $	*/
a33 5

#ifndef lint
/*static char sccsid[] = "from: @@(#)function.c	8.1 (Berkeley) 6/6/93";*/
static char rcsid[] = "$OpenBSD: function.c,v 1.32 2009/08/27 16:19:27 millert Exp $";
#endif /* not lint */
@


1.32
log
@Don't stop traversing a directory hierarchy if we reach SHRT_MAX,
just stop updating fts_level so we don't overflow it.  This allows
rm, find, etc to operate on very deep hierarchies.  Consumers of
fts(3) do need to be aware that the actual level may be larger
than fts_level.  During the next libc major bump we will make
fts_level an int instead of a short.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.31 2005/06/15 14:19:45 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: function.c,v 1.31 2005/06/15 14:19:45 millert Exp $";
d839 1
a839 1
	new->max_data = strtonum(arg, 1, FTS_MAXLEVEL, &errstr);
@


1.31
log
@no more whiteouts
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.30 2004/07/20 03:50:25 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: function.c,v 1.30 2004/07/20 03:50:25 deraadt Exp $";
d836 1
d839 3
a841 1
	new->max_data = atoi(arg);
@


1.30
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.29 2004/07/01 18:25:47 otto Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: function.c,v 1.29 2004/07/01 18:25:47 otto Exp $";
a1278 7
#ifdef S_IFWHT
	case 'W':
		mask = S_IFWHT;
		if ((ftsoptions & FTS_WHITEOUT) == 0)
			warnx("-type W without -W is a no-op");
		break;
#endif
@


1.29
log
@setmode(3) returns void *, not mode_t *.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.28 2003/06/26 07:27:29 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: function.c,v 1.28 2003/06/26 07:27:29 deraadt Exp $";
d128 1
a128 3
find_parsenum(plan, option, vp, endch)
	PLAN *plan;
	char *option, *vp, *endch;
d181 1
a181 3
f_amin(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d209 1
a209 3
f_atime(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d236 1
a236 3
f_cmin(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d264 1
a264 3
f_ctime(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d292 1
a292 3
f_always_true(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d311 1
a311 3
f_empty(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d358 1
a358 3
f_exec(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d455 1
a455 3
f_execdir(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d567 1
a567 3
f_flags(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d627 1
a627 3
f_fstype(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d723 1
a723 3
f_group(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d756 1
a756 3
f_inum(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d779 1
a779 3
f_links(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d802 1
a802 3
f_ls(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d824 1
a824 3
f_maxdepth(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d849 1
a849 3
f_mindepth(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d872 1
a872 3
f_mtime(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d899 1
a899 3
f_mmin(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d927 1
a927 3
f_name(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d949 1
a949 3
f_iname(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d972 1
a972 3
f_newer(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1003 1
a1003 3
f_anewer(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1034 1
a1034 3
f_cnewer(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1064 1
a1064 3
f_nogroup(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1084 1
a1084 3
f_nouser(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1104 1
a1104 3
f_path(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1127 1
a1127 3
f_perm(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1170 1
a1170 3
f_print(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1178 1
a1178 3
f_print0(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1207 1
a1207 3
f_prune(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1232 1
a1232 3
f_size(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1265 1
a1265 3
f_type(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1324 1
a1324 3
f_user(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1371 1
a1371 3
f_expr(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1404 1
a1404 3
f_not(plan, entry)
	PLAN *plan;
	FTSENT *entry;
d1427 1
a1427 3
f_or(plan, entry)
	PLAN *plan;
	FTSENT *entry;
@


1.28
log
@bring protypes into scope.  this requires some quirky handling, but in
the end everything is much clearer; ok tedu (itojun might like to see
how ifconfig looks after this)
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.27 2003/06/10 22:20:46 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: function.c,v 1.27 2003/06/10 22:20:46 deraadt Exp $";
d1200 1
a1200 1
	mode_t *set;
@


1.27
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.26 2003/06/03 02:56:08 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: function.c,v 1.26 2003/06/03 02:56:08 millert Exp $";
d62 1
d78 40
d194 1
a194 2
c_amin(arg)
	char *arg;
d223 1
a223 2
c_atime(arg)
	char *arg;
d253 1
a253 2
c_cmin(arg)
	char *arg;
d282 1
a282 2
c_ctime(arg)
	char *arg;
d310 1
a310 1
c_depth(void)
d352 1
a352 1
c_empty(void)
d417 1
a417 3
c_exec(argvp, isok)
	char ***argvp;
	int isok;
d536 1
a536 2
c_execdir(argvp)
	char ***argvp;
d604 1
a604 2
c_flags(flags_str)
	char *flags_str;
d633 1
a633 1
c_follow(void)
d708 1
a708 2
c_fstype(arg)
	char *arg;
d753 1
a753 2
c_group(gname)
	char *gname;
d788 1
a788 2
c_inum(arg)
	char *arg;
d813 1
a813 2
c_links(arg)
	char *arg;
d839 1
a839 1
c_ls(void)
d865 1
a865 2
c_maxdepth(arg)
	char *arg;
d890 1
a890 2
c_mindepth(arg)
	char *arg;
d916 1
a916 2
c_mtime(arg)
	char *arg;
d946 1
a946 2
c_mmin(arg)
	char *arg;
d973 1
a973 2
c_name(pattern)
	char *pattern;
d997 1
a997 2
c_iname(pattern)
	char *pattern;
d1025 1
a1025 2
c_newer(filename)
	char *filename;
d1058 1
a1058 2
c_anewer(filename)
	char *filename;
d1091 1
a1091 2
c_cnewer(filename)
	char *filename;
d1120 1
a1120 1
c_nogroup(void)
d1142 1
a1142 1
c_nouser(void)
d1164 1
a1164 2
c_path(pattern)
	char *pattern;
d1197 1
a1197 2
c_perm(perm)
	char *perm;
d1246 1
a1246 1
c_print(void)
d1254 1
a1254 1
c_print0(void)
d1278 1
a1278 1
c_prune(void)
d1306 1
a1306 2
c_size(arg)
	char *arg;
d1337 1
a1337 2
c_type(typestring)
	char *typestring;
d1398 1
a1398 2
c_user(username)
	char *username;
d1426 1
a1426 1
c_xdev(void)
d1457 1
a1457 1
c_openparen(void)
d1459 1
a1459 1
	return (palloc(N_OPENPAREN, (int (*)())-1));
d1463 1
a1463 1
c_closeparen(void)
d1465 1
a1465 1
	return (palloc(N_CLOSEPAREN, (int (*)())-1));
d1487 1
a1487 1
c_not(void)
d1518 1
a1518 1
c_or(void)
d1524 1
a1524 3
palloc(t, f)
	enum ntype t;
	int (*f)(PLAN *, FTSENT *);
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.25 2002/06/30 15:16:41 matthieu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: function.c,v 1.25 2002/06/30 15:16:41 matthieu Exp $";
d273 1
a273 1
c_depth()
d315 1
a315 1
c_empty()
d600 1
a600 1
c_follow()
d810 1
a810 1
c_ls()
d1100 1
a1100 1
c_nogroup()
d1122 1
a1122 1
c_nouser()
d1228 1
a1228 1
c_print()
d1236 1
a1236 1
c_print0()
d1260 1
a1260 1
c_prune()
d1411 1
a1411 1
c_xdev()
d1442 1
a1442 1
c_openparen()
d1448 1
a1448 1
c_closeparen()
d1472 1
a1472 1
c_not()
d1503 1
a1503 1
c_or()
@


1.25
log
@remove local declaration of user_from_uid()/group_from_uid()
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.24 2002/05/03 15:21:09 millert Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: function.c,v 1.24 2002/05/03 15:21:09 millert Exp $";
@


1.24
log
@Fix pasto in -anewer and -cnewer options that caused them to behave
as -newer; Dave Horsfall
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.23 2002/02/17 19:42:30 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.23 2002/02/17 19:42:30 millert Exp $";
a1099 2
	char *group_from_gid();

a1121 2
	char *user_from_uid();

@


1.23
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.22 2002/02/16 21:27:46 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.22 2002/02/16 21:27:46 millert Exp $";
d1050 1
a1050 1
	new = palloc(N_NEWER, f_newer);
d1084 1
a1084 1
	new = palloc(N_NEWER, f_newer);
@


1.22
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.21 2001/11/19 19:02:13 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.21 2001/11/19 19:02:13 mpech Exp $";
d80 1
a80 1
static PLAN *palloc __P((enum ntype, int (*)(PLAN *, FTSENT *)));
@


1.21
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.20 2000/07/19 19:30:10 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.20 2000/07/19 19:30:10 mickey Exp $";
d80 1
a80 1
static PLAN *palloc __P((enum ntype, int (*) __P((PLAN *, FTSENT *))));
d1519 1
a1519 1
	int (*f) __P((PLAN *, FTSENT *));
@


1.20
log
@new strtofflags/fflagstostr
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.19 2000/07/08 16:09:34 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.19 2000/07/08 16:09:34 millert Exp $";
d340 1
a340 1
	register PLAN *plan;
d343 1
a343 1
	register int cnt;
d389 2
a390 2
	register int cnt;
	register char **argv, **ap, *p;
d441 1
a441 1
	register PLAN *plan;
d444 1
a444 1
	register int cnt;
d509 2
a510 2
	register int cnt;
	register char **argv, **ap, *p;
d682 1
a682 1
	register PLAN *new;
d1436 2
a1437 2
	register PLAN *p;
	register int state;
d1471 2
a1472 2
	register PLAN *p;
	register int state;
d1496 2
a1497 2
	register PLAN *p;
	register int state;
@


1.19
log
@Add a -flags option similar to -perm but for filke flags (ala
chflags).  Adapted from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.18 2000/06/07 15:25:30 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.18 2000/06/07 15:25:30 deraadt Exp $";
d578 1
a578 1
	u_int flags, notflags;
d589 1
a589 1
	if (string_to_flags(&flags_str, &flags, &notflags) == 1)
@


1.18
log
@-iname support; karls@@inet.no
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.17 1999/12/04 22:42:32 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.17 1999/12/04 22:42:32 millert Exp $";
d548 48
d1202 1
a1202 1
		err(1, "-perm: %s: illegal mode string", perm);
@


1.17
log
@o use nanosecond precision with the -newer option
o add -anewer and -cnewer options like GNU find.
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.16 1999/10/04 21:26:10 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.16 1999/10/04 21:26:10 millert Exp $";
d910 25
@


1.16
log
@If we can't chdir to the root dir in -execdir, just return instead
of generating an error.  Most times this is just because the target
is not a directory.  Also close an fd leak introduced in the last
commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.15 1999/10/04 21:17:32 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.15 1999/10/04 21:17:32 millert Exp $";
d137 1
a137 1
		++((p)->t_data);
d153 1
a153 1
	    60 - 1) / 60, plan->t_data);
d165 1
a165 1
	new->t_data = find_parsenum(new, "-amin", arg, NULL);
d183 1
a183 1
	    SECSPERDAY - 1) / SECSPERDAY, plan->t_data);
d195 1
a195 1
	new->t_data = find_parsenum(new, "-atime", arg, NULL);
d214 1
a214 1
	    60 - 1) / 60, plan->t_data);
d226 1
a226 1
	new->t_data = find_parsenum(new, "-cmin", arg, NULL);
d244 1
a244 1
	    SECSPERDAY - 1) / SECSPERDAY, plan->t_data);
d256 1
a256 1
	new->t_data = find_parsenum(new, "-ctime", arg, NULL);
d841 1
a841 1
	    SECSPERDAY, plan->t_data);
d853 1
a853 1
	new->t_data = find_parsenum(new, "-mtime", arg, NULL);
d872 1
a872 1
	    60, plan->t_data);
d884 1
a884 1
	new->t_data = find_parsenum(new, "-mmin", arg, NULL);
d926 4
a929 1
	return (entry->fts_statp->st_mtime > plan->t_data);
d944 69
a1012 1
	new->t_data = sb.st_mtime;
d1450 1
a1450 1
	if ((new = malloc(sizeof(PLAN)))) {
a1452 2
		new->flags = 0;
		new->next = NULL;
@


1.15
log
@Move the chdir/fchdir hack so that it is local to the -execdir
function, since that's the only place it needs to be.  Doing it for
each function caused problems with multiple directories.
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.14 1999/10/03 19:07:35 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.14 1999/10/03 19:07:35 millert Exp $";
d456 1
a456 1
			warn("cannot chdir to %s", entry->fts_accpath);
d487 1
d490 1
@


1.14
log
@Do not use FTS_CHDIRROOT flag as it is fatally flawed.  Instead,
do the chdir ourselves.  This fixes a problem with the -execdir option
with multiple relative directories.
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.13 1999/03/17 17:36:30 espie Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.13 1999/03/17 17:36:30 espie Exp $";
d53 1
d446 1
a446 1
	int status;
d449 12
d482 9
@


1.13
log
@Add -W option so -type W gets a chance to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.12 1998/09/26 09:04:43 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.12 1998/09/26 09:04:43 deraadt Exp $";
a488 1
	ftsoptions |= FTS_CHDIRROOT;
@


1.12
log
@more setmode() leaks -- kill 'em all
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.11 1997/11/13 08:30:33 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.11 1997/11/13 08:30:33 deraadt Exp $";
d1173 2
@


1.11
log
@Add the primaries -mmin, -amin, -cmin to find, similar to the GNU find; wosch
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.10 1997/09/01 02:44:19 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.10 1997/09/01 02:44:19 millert Exp $";
d1038 1
@


1.10
log
@Fix problem with ``find -execdir'' not having the correct initial cwd.
Adds a new flag to fts(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.9 1997/06/30 23:54:07 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.9 1997/06/30 23:54:07 millert Exp $";
d139 31
d198 32
d832 31
@


1.9
log
@Some -Wall cleanliness.
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.8 1996/12/23 04:58:10 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.8 1996/12/23 04:58:10 millert Exp $";
d56 1
d383 1
a383 7
	char *file;

	/* XXX - if file/dir ends in '/' this will not work -- can it? */
	if ((file = strrchr(entry->fts_path, '/')))
	    file++;
	else
	    file = entry->fts_path;
d385 3
d391 1
a391 1
			    file, plan->e_len[cnt]);
d426 1
@


1.8
log
@Add -execdir support.
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.7 1996/09/01 04:56:26 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.7 1996/09/01 04:56:26 tholo Exp $";
d80 4
a147 1
	extern time_t now;
a176 1
	extern time_t now;
a277 1
	extern int dotfd;
a378 1
	extern int dotfd;
d506 1
a506 1
			if (p = strrchr(entry->fts_accpath, '/'))
a699 1
	extern FTS *tree;
a727 1
	extern FTS *tree;
a753 1
	extern time_t now;
d964 1
a999 1
	extern FTS *tree;
d1260 1
a1260 1
	if (new = malloc(sizeof(PLAN))) {
@


1.7
log
@Add support for -empty
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.6 1996/09/01 04:30:17 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.6 1996/09/01 04:30:17 tholo Exp $";
d336 100
@


1.6
log
@Add support for -mindepth while at it
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.5 1996/08/31 22:40:21 tholo Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.5 1996/08/31 22:40:21 tholo Exp $";
d50 1
d217 42
@


1.5
log
@Add support for -maxdepth option
@
text
@d1 1
a1 1
/*	$OpenBSD: function.c,v 1.4 1996/06/26 05:33:10 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.4 1996/06/26 05:33:10 deraadt Exp $";
d553 1
a553 1
f_mdepth(plan, entry)
d559 1
a559 1
	if (entry->fts_level >= plan->d_data)
d561 1
a561 1
	return (entry->fts_level <= plan->d_data);
d565 1
a565 1
c_mdepth(arg)
d570 29
a598 2
	new = palloc(N_MDEPTH, f_mdepth);
	new->d_data = atoi(arg);
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: function.c,v 1.3 1996/06/25 20:48:31 deraadt Exp $";
d544 29
@


1.3
log
@indent nice
@
text
@d1 2
d41 1
a41 1
static char rcsid[] = "$Id: function.c,v 1.2 1996/05/28 12:31:20 deraadt Exp $";
@


1.2
log
@support whiteouts; netbsd pr#2394; mike.long@@analog.com
@
text
@d39 1
a39 1
static char rcsid[] = "$Id: function.c,v 1.1.1.1 1995/10/18 08:45:13 deraadt Exp $";
d879 3
a881 3
      case 'W':
              mask = S_IFWHT;
              break;
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
static char rcsid[] = "$Id: function.c,v 1.16 1995/06/18 11:00:17 cgd Exp $";
d878 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
