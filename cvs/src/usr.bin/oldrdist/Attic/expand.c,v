head	1.16;
access;
symbols
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.28
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.24
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.22
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.20
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.18
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.18
	OPENBSD_2_8:1.6.0.16
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.14
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.16
date	2014.07.10.14.26.16;	author tedu;	state dead;
branches;
next	1.15;
commitid	Hzb21S9Xr5CMEb0F;

1.15
date	2013.06.02.06.20.35;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.22.18.26.18;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.06.17.57.45;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.18.17.17.39;	author pvalchev;	state Exp;
branches;
next	1.6;

1.6
date	97.02.09.19.24.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.22.20.33.18;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.07.25.05.13.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.07.19.21.57.32;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.37.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.02.03.12.11.56;	author dm;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Snakes. Why'd it have to be snakes?
@
text
@/*	$OpenBSD: expand.c,v 1.15 2013/06/02 06:20:35 guenther Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "defs.h"

#define	GAVSIZ	NCARGS / 6
#define LC '{'
#define RC '}'

static char	shchars[] = "${[*?";

int	which;		/* bit mask of types to expand */
int	eargc;		/* expanded arg count */
char	**eargv;	/* expanded arg vectors */
char	pathbuf[BUFSIZ];
char	*path;
char	*pathp;
char	*lastpathp;
char	*tilde;		/* "~user" if not expanding tilde, else "" */
char	*tpathp;
int	nleft;

int	expany;		/* any expansions done? */
char	*entp;
char	**sortbase;

#define sort()	qsort((char *)sortbase, &eargv[eargc] - sortbase, \
		      sizeof(*sortbase), argcmp), sortbase = &eargv[eargc]

static void	Cat(char *, char *);
static void	addpath(int);
static int	amatch(char *, char *);
static int	argcmp(const void *, const void *);
static int	execbrc(char *, char *);
static void	expsh(char *);
static void	expstr(char *);
static int	match(char *, char *);
static void	matchdir(char *);
static int	smatch(char *, char *);

/*
 * Take a list of names and expand any macros, etc.
 * wh = E_VARS if expanding variables.
 * wh = E_SHELL if expanding shell characters.
 * wh = E_TILDE if expanding `~'.
 * or any of these or'ed together.
 *
 * Major portions of this were snarfed from csh/sh.glob.c.
 */
struct namelist *
expand(list, wh)
	struct namelist *list;
	int wh;
{
	struct namelist *nl, *prev;
	int n;
	char *argvbuf[GAVSIZ];

	if (debug) {
		printf("expand(%lx, %d)\nlist = ", (long)list, wh);
		prnames(list);
	}

	if (wh == 0) {
		char *cp;

		for (nl = list; nl != NULL; nl = nl->n_next)
			for (cp = nl->n_name; *cp; cp++)
				*cp = *cp & TRIM;
		return(list);
	}

	which = wh;
	path = tpathp = pathp = pathbuf;
	*pathp = '\0';
	lastpathp = &path[sizeof pathbuf - 2];
	tilde = "";
	eargc = 0;
	eargv = sortbase = argvbuf;
	*eargv = 0;
	nleft = NCARGS - 4;
	/*
	 * Walk the name list and expand names into eargv[];
	 */
	for (nl = list; nl != NULL; nl = nl->n_next)
		expstr(nl->n_name);
	/*
	 * Take expanded list of names from eargv[] and build a new list.
	 */
	list = prev = NULL;
	for (n = 0; n < eargc; n++) {
		nl = makenl(NULL);
		nl->n_name = eargv[n];
		if (prev == NULL)
			list = prev = nl;
		else {
			prev->n_next = nl;
			prev = nl;
		}
	}
	if (debug) {
		printf("expanded list = ");
		prnames(list);
	}
	return(list);
}

static void
expstr(s)
	char *s;
{
	char *cp, *cp1;
	struct namelist *tp;
	char *tail;
	char buf[BUFSIZ];
	int savec, oeargc;
	extern char homedir[];

	if (s == NULL || *s == '\0')
		return;

	if ((which & E_VARS) && (cp = strchr(s, '$')) != NULL) {
		*cp++ = '\0';
		if (*cp == '\0') {
			yyerror("no variable name after '$'");
			return;
		}
		if (*cp == LC) {
			cp++;
			if ((tail = strchr(cp, RC)) == NULL) {
				yyerror("unmatched '{'");
				return;
			}
			*tail++ = savec = '\0';
			if (*cp == '\0') {
				yyerror("no variable name after '$'");
				return;
			}
		} else {
			tail = cp + 1;
			savec = *tail;
			*tail = '\0';
		}
		tp = lookup(cp, LOOKUP, 0);
		if (savec != '\0')
			*tail = savec;
		if (tp != NULL) {
			for (; tp != NULL; tp = tp->n_next) {
				snprintf(buf, sizeof(buf), "%s%s%s", s,
					tp->n_name, tail);
				expstr(buf);
			}
			return;
		}
		snprintf(buf, sizeof(buf), "%s%s", s, tail);
		expstr(buf);
		return;
	}
	if ((which & ~E_VARS) == 0 || !strcmp(s, "{") || !strcmp(s, "{}")) {
		Cat(s, "");
		sort();
		return;
	}
	if (*s == '~') {
		cp = ++s;
		if (*cp == '\0' || *cp == '/') {
			tilde = "~";
			cp1 = homedir;
		} else {
			tilde = cp1 = buf;
			*cp1++ = '~';
			do
				*cp1++ = *cp++;
			while (*cp && *cp != '/');
			*cp1 = '\0';
			if (pw == NULL || strcmp(pw->pw_name, buf+1) != 0) {
				if ((pw = getpwnam(buf+1)) == NULL) {
					strlcat(buf, ": unknown user name",
						sizeof buf);
					yyerror(buf+1);
					return;
				}
			}
			cp1 = pw->pw_dir;
			s = cp;
		}
		for (cp = path; *cp++ = *cp1++; )
			;
		tpathp = pathp = cp - 1;
	} else {
		tpathp = pathp = path;
		tilde = "";
	}
	*pathp = '\0';
	if (!(which & E_SHELL)) {
		if (which & E_TILDE)
			Cat(path, s);
		else
			Cat(tilde, s);
		sort();
		return;
	}
	oeargc = eargc;
	expany = 0;
	expsh(s);
	if (eargc == oeargc)
		Cat(s, "");		/* "nonomatch" is set */
	sort();
}

static int
argcmp(a1, a2)
	const void *a1, *a2;
{

	return (strcmp(*(char **)a1, *(char **)a2));
}

/*
 * If there are any Shell meta characters in the name,
 * expand into a list, after searching directory
 */
static void
expsh(s)
	char *s;
{
	char *cp;
	char *spathp, *oldcp;
	struct stat stb;

	spathp = pathp;
	cp = s;
	while (!any(*cp, shchars)) {
		if (*cp == '\0') {
			if (!expany || stat(path, &stb) >= 0) {
				if (which & E_TILDE)
					Cat(path, "");
				else
					Cat(tilde, tpathp);
			}
			goto endit;
		}
		addpath(*cp++);
	}
	oldcp = cp;
	while (cp > s && *cp != '/')
		cp--, pathp--;
	if (*cp == '/')
		cp++, pathp++;
	*pathp = '\0';
	if (*oldcp == '{') {
		execbrc(cp, NULL);
		return;
	}
	matchdir(cp);
endit:
	pathp = spathp;
	*pathp = '\0';
}

static void
matchdir(pattern)
	char *pattern;
{
	struct stat stb;
	struct dirent *dp;
	DIR *dirp;

	dirp = opendir(path);
	if (dirp == NULL) {
		if (expany)
			return;
		goto patherr2;
	}
	if (fstat(dirfd(dirp), &stb) < 0)
		goto patherr1;
	if (!ISDIR(stb.st_mode)) {
		errno = ENOTDIR;
		goto patherr1;
	}
	while ((dp = readdir(dirp)) != NULL)
		if (match(dp->d_name, pattern)) {
			if (which & E_TILDE)
				Cat(path, dp->d_name);
			else {
				strlcpy(pathp, dp->d_name,
					pathbuf + sizeof pathbuf - pathp);
				Cat(tilde, tpathp);
				*pathp = '\0';
			}
		}
	closedir(dirp);
	return;

patherr1:
	closedir(dirp);
patherr2:
	strlcat(path, ": ", pathbuf + sizeof pathbuf - path);
	strlcat(path, strerror(errno), pathbuf + sizeof pathbuf - path);
	yyerror(path);
}

static int
execbrc(p, s)
	char *p, *s;
{
	char restbuf[BUFSIZ + 2];
	char *pe, *pm, *pl;
	int brclev = 0;
	char *lm, savec, *spathp;

	for (lm = restbuf; *p != '{'; *lm++ = *p++)
		continue;
	for (pe = ++p; *pe; pe++)
		switch (*pe) {

		case '{':
			brclev++;
			continue;

		case '}':
			if (brclev == 0)
				goto pend;
			brclev--;
			continue;

		case '[':
			for (pe++; *pe && *pe != ']'; pe++)
				continue;
			if (!*pe)
				yyerror("Missing ']'");
			continue;
		}
pend:
	if (brclev || !*pe) {
		yyerror("Missing '}'");
		return (0);
	}
	for (pl = pm = p; pm <= pe; pm++)
		switch (*pm & (QUOTE|TRIM)) {

		case '{':
			brclev++;
			continue;

		case '}':
			if (brclev) {
				brclev--;
				continue;
			}
			goto doit;

		case ',':
			if (brclev)
				continue;
doit:
			savec = *pm;
			*pm = 0;
			strlcpy(lm, pl, restbuf + sizeof restbuf - lm);
			strlcat(restbuf, pe + 1, sizeof restbuf);
			*pm = savec;
			if (s == 0) {
				spathp = pathp;
				expsh(restbuf);
				pathp = spathp;
				*pathp = 0;
			} else if (amatch(s, restbuf))
				return (1);
			sort();
			pl = pm + 1;
			continue;

		case '[':
			for (pm++; *pm && *pm != ']'; pm++)
				continue;
			if (!*pm)
				yyerror("Missing ']'");
			continue;
		}
	return (0);
}

static int
match(s, p)
	char *s, *p;
{
	int c;
	char *sentp;
	char sexpany = expany;

	if (*s == '.' && *p != '.')
		return (0);
	sentp = entp;
	entp = s;
	c = amatch(s, p);
	entp = sentp;
	expany = sexpany;
	return (c);
}

static int
amatch(s, p)
	char *s, *p;
{
	int scc;
	int ok, lc;
	char *spathp;
	struct stat stb;
	int c, cc;

	expany = 1;
	for (;;) {
		scc = *s++ & TRIM;
		switch (c = *p++) {

		case '{':
			return (execbrc(p - 1, s - 1));

		case '[':
			ok = 0;
			lc = 077777;
			while (cc = *p++) {
				if (cc == ']') {
					if (ok)
						break;
					return (0);
				}
				if (cc == '-') {
					if (lc <= scc && scc <= *p++)
						ok++;
				} else
					if (scc == (lc = cc))
						ok++;
			}
			if (cc == 0) {
				yyerror("Missing ']'");
				return (0);
			}
			continue;

		case '*':
			if (!*p)
				return (1);
			if (*p == '/') {
				p++;
				goto slash;
			}
			for (s--; *s; s++)
				if (amatch(s, p))
					return (1);
			return (0);

		case '\0':
			return (scc == '\0');

		default:
			if ((c & TRIM) != scc)
				return (0);
			continue;

		case '?':
			if (scc == '\0')
				return (0);
			continue;

		case '/':
			if (scc)
				return (0);
slash:
			s = entp;
			spathp = pathp;
			while (*s)
				addpath(*s++);
			addpath('/');
			if (stat(path, &stb) == 0 && ISDIR(stb.st_mode))
				if (*p == '\0') {
					if (which & E_TILDE)
						Cat(path, "");
					else
						Cat(tilde, tpathp);
				} else
					expsh(p);
			pathp = spathp;
			*pathp = '\0';
			return (0);
		}
	}
}

static int
smatch(s, p)
	char *s, *p;
{
	int scc;
	int ok, lc;
	int c, cc;

	for (;;) {
		scc = *s++ & TRIM;
		switch (c = *p++) {

		case '[':
			ok = 0;
			lc = 077777;
			while (cc = *p++) {
				if (cc == ']') {
					if (ok)
						break;
					return (0);
				}
				if (cc == '-') {
					if (lc <= scc && scc <= *p++)
						ok++;
				} else
					if (scc == (lc = cc))
						ok++;
			}
			if (cc == 0) {
				yyerror("Missing ']'");
				return (0);
			}
			continue;

		case '*':
			if (!*p)
				return (1);
			for (s--; *s; s++)
				if (smatch(s, p))
					return (1);
			return (0);

		case '\0':
			return (scc == '\0');

		default:
			if ((c & TRIM) != scc)
				return (0);
			continue;

		case '?':
			if (scc == 0)
				return (0);
			continue;

		}
	}
}

static void
Cat(s1, s2)
	char *s1, *s2;
{
	int len = strlen(s1) + strlen(s2) + 1;
	char *s;

	nleft -= len;
	if (nleft <= 0 || ++eargc >= GAVSIZ)
		yyerror("Arguments too long");
	eargv[eargc] = 0;
	eargv[eargc - 1] = s = malloc(len);
	if (s == NULL)
		fatal("ran out of memory\n");
	while (*s++ = *s1++ & TRIM)
		;
	s--;
	while (*s++ = *s2++ & TRIM)
		;
}

static void
addpath(c)
	int c;
{

	if (pathp >= lastpathp)
		yyerror("Pathname too long");
	else {
		*pathp++ = c & TRIM;
		*pathp = '\0';
	}
}

/*
 * Expand file names beginning with `~' into the
 * user's home directory path name. Return a pointer in buf to the
 * part corresponding to `file'.
 */
char *
exptilde(buf, file, maxlen)
	char buf[];
	char *file;
	int maxlen;
{
	char *s1, *s2, *s3;
	extern char homedir[];

	if (*file != '~') {
		strlcpy(buf, file, maxlen);
		return(buf);
	}
	if (*++file == '\0') {
		s2 = homedir;
		s3 = NULL;
	} else if (*file == '/') {
		s2 = homedir;
		s3 = file;
	} else {
		s3 = file;
		while (*s3 && *s3 != '/')
			s3++;
		if (*s3 == '/')
			*s3 = '\0';
		else
			s3 = NULL;
		if (pw == NULL || strcmp(pw->pw_name, file) != 0) {
			if ((pw = getpwnam(file)) == NULL) {
				error("%s: unknown user name\n", file);
				if (s3 != NULL)
					*s3 = '/';
				return(NULL);
			}
		}
		if (s3 != NULL)
			*s3 = '/';
		s2 = pw->pw_dir;
	}
	for (s1 = buf; (*s1++ = *s2++) && s1 < buf+maxlen; )
		;
	s2 = --s1;
	if (s3 != NULL && s1 < buf+maxlen) {
		s2++;
		while ((*s1++ = *s3++) && s1 < buf+maxlen)
			;
	}
	if (s1 == buf+maxlen)
		return (NULL);
	return(s2);
}
@


1.15
log
@Switch from antique struct direct to struct dirent
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.14 2011/07/22 18:26:18 matthew Exp $	*/
@


1.14
log
@Use dirfd(dirp) instead of dirp->dd_fd.

No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.13 2011/04/06 11:36:26 miod Exp $	*/
d294 1
a294 1
	struct direct *dp;
@


1.13
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.12 2009/10/27 23:59:41 deraadt Exp $	*/
d303 1
a303 1
	if (fstat(dirp->dd_fd, &stb) < 0)
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.11 2003/06/03 02:56:14 millert Exp $	*/
d172 1
a172 1
		tp = lookup(cp, NULL, 0);
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.10 2003/04/06 17:57:45 ho Exp $	*/
a30 5

#ifndef lint
/* from: static char sccsid[] = "@@(#)expand.c	8.1 (Berkeley) 6/9/93"; */
static char *rcsid = "$OpenBSD: expand.c,v 1.10 2003/04/06 17:57:45 ho Exp $";
#endif /* not lint */
@


1.10
log
@strcpy/strcat cleanup. Ick millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.9 2002/02/16 21:27:50 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 1
a34 1
static char *rcsid = "$OpenBSD: expand.c,v 1.9 2002/02/16 21:27:50 millert Exp $";
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.8 2001/11/19 19:02:15 mpech Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: expand.c,v 1.8 2001/11/19 19:02:15 mpech Exp $";
d52 1
a93 1
	char pathbuf[BUFSIZ];
d215 2
a216 1
					strcat(buf, ": unknown user name");
d323 2
a324 1
				strcpy(pathp, dp->d_name);
d335 2
a336 2
	strcat(path, ": ");
	strcat(path, strerror(errno));
d396 2
a397 2
			strcpy(lm, pl);
			strcat(restbuf, pe + 1);
d635 1
a635 1
		strcpy(buf, file);
@


1.8
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.7 2001/07/18 17:17:39 pvalchev Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: expand.c,v 1.7 2001/07/18 17:17:39 pvalchev Exp $";
d66 10
a75 10
static void	Cat __P((char *, char *));
static void	addpath __P((int));
static int	amatch __P((char *, char *));
static int	argcmp __P((const void *, const void *));
static int	execbrc __P((char *, char *));
static void	expsh __P((char *));
static void	expstr __P((char *));
static int	match __P((char *, char *));
static void	matchdir __P((char *));
static int	smatch __P((char *, char *));
@


1.7
log
@-Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.6 1997/02/09 19:24:57 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: expand.c,v 1.6 1997/02/09 19:24:57 deraadt Exp $";
d91 2
a92 2
	register struct namelist *nl, *prev;
	register int n;
d102 1
a102 1
		register char *cp;
d149 2
a150 2
	register char *cp, *cp1;
	register struct namelist *tp;
d263 2
a264 2
	register char *cp;
	register char *spathp, *oldcp;
d302 1
a302 1
	register struct direct *dp;
d343 1
a343 1
	register char *pe, *pm, *pl;
d422 2
a423 2
	register int c;
	register char *sentp;
d438 1
a438 1
	register char *s, *p;
d440 1
a440 1
	register int scc;
d527 1
a527 1
	register char *s, *p;
d529 1
a529 1
	register int scc;
d586 1
a586 1
	register char *s1, *s2;
d589 1
a589 1
	register char *s;
d626 1
a626 1
	register char *file;
d629 1
a629 1
	register char *s1, *s2, *s3;
@


1.6
log
@buf oflow, eivind@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.5 1996/08/22 20:33:18 millert Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: expand.c,v 1.5 1996/08/22 20:33:18 millert Exp $";
d97 1
a97 1
		printf("expand(%x, %d)\nlist = ", list, wh);
@


1.5
log
@NetBSD changes: use POSIX regex routines and fix more buff oflow
Can't use mkstemp() so go back to mktemp and open(2) with sane flags.
Now uses rcmdsh and fixes memory leak in NetBSD POSIX regex support
(leak fixed by Charles Amos <amos@@umiacs.umd.edu>).
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.4 1996/07/25 05:13:48 millert Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: expand.c,v 1.4 1996/07/25 05:13:48 millert Exp $";
d624 1
a624 1
exptilde(buf, file)
d627 1
d662 1
a662 1
	for (s1 = buf; *s1++ = *s2++; )
d665 1
a665 1
	if (s3 != NULL) {
d667 1
a667 1
		while (*s1++ = *s3++)
d670 2
@


1.4
log
@Replaced sprintf() with snprintf() where buffer size is obvious.
Probably just paranoia but why take the chance?  Just four occurences
of sprintf() left.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.3 1996/07/19 21:57:32 millert Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: expand.c,v 1.3 1996/07/19 21:57:32 millert Exp $";
d186 1
a186 1
				snprintf(buf, BUFSIZ, "%s%s%s", s,
d192 1
a192 1
		snprintf(buf, BUFSIZ, "%s%s", s, tail);
@


1.3
log
@oldrdist now uses rsh so doesn't need to be setuid.
Incorporates some changes from Chris Siebenmann <cks@@utcc.utoronto.ca>
and rdist 6.1.2.  Also fixes at least one possible core dump and
uses strr?chr() instead of r?index().
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.2 1996/06/26 05:37:38 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: expand.c,v 1.2 1996/06/26 05:37:38 deraadt Exp $";
d186 2
a187 1
				sprintf(buf, "%s%s%s", s, tp->n_name, tail);
d192 1
a192 1
		sprintf(buf, "%s%s", s, tail);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: expand.c,v 1.1 1996/02/03 12:11:56 dm Exp $";
d159 1
a159 1
	if ((which & E_VARS) && (cp = index(s, '$')) != NULL) {
d167 1
a167 1
			if ((tail = index(cp, RC)) == NULL) {
@


1.1
log
@rdist 6.1.1
@
text
@d1 2
d38 1
a38 1
static char *rcsid = "$Id: expand.c,v 1.1.1.1 1995/10/18 08:45:59 deraadt Exp $";
@
