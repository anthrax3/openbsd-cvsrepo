head	1.35;
access;
symbols
	OPENBSD_5_5:1.34.0.6
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.2
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.32.0.14
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.12
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.10
	OPENBSD_5_0:1.32.0.8
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.6
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.31.0.10
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.6
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.4
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.4
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.29.0.6
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.29.0.4
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.26.0.4
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.8
	OPENBSD_2_8:1.12.0.6
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.4
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.35
date	2014.07.10.14.26.16;	author tedu;	state dead;
branches;
next	1.34;
commitid	Hzb21S9Xr5CMEb0F;

1.34
date	2013.06.02.06.20.35;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2013.04.16.22.37.28;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.17.20.10.44;	author chl;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.08.03.19.13;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.04.01.54.10;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.13.02.33.08;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2004.10.04.05.21.27;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.16.01.12.35;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.15.19.12.31;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.01.15.53.35;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.06.17.57.45;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.05.17.18.26;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.23.03.07.21;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.09.21.11.22;	author hin;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.05.22.32.42;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.09.07.04.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.08.17.09.13.16;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.05.18.19.13.20;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.04.27.03.13.53;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.25.21.05.37;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.02.09.19.24.59;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.22.03.26.00;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.08.22.20.33.24;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.07.25.05.13.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.07.19.21.57.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.37.41;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.28.12.31.57;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.02.03.12.12.03;	author dm;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Snakes. Why'd it have to be snakes?
@
text
@/*	$OpenBSD: server.c,v 1.34 2013/06/02 06:20:35 guenther Exp $	*/

/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/wait.h>

#include <stdarg.h>
#include <libgen.h>

#include "defs.h"

#define	ack() 	(void) write(rem, "\0\n", 2)
#define	err() 	(void) write(rem, "\1\n", 2)

struct	linkbuf *ihead;		/* list of files with more than one link */
char	buf[BUFSIZ];		/* general purpose buffer */
char	target[BUFSIZ];		/* target/source directory name */
char	source[BUFSIZ];		/* source directory name */
char	*tp;			/* pointer to end of target name */
char	*Tdest;			/* pointer to last T dest*/
int	catname;		/* cat name to target name */
char	*stp[32];		/* stack of saved tp's for directories */
int	oumask;			/* old umask for creating files */

extern	FILE *lfp;		/* log file for mailing changes */

static int	chkparent(char *);
static void	clean(char *);
static void	comment(char *);
static void	dospecial(char *);
static int	fchog(int, char *, char *, char *, int);
static void	hardlink(char *);
static void	note(const char *, ...);
static void	query(char *);
static void	recvf(char *, int);
static void	removeit(struct stat *);
static int	response(void);
static void	rmchk(int);
static struct linkbuf *
		    savelink(struct stat *);
static void	sendf(char *, int);
static int	update(char *, int, struct stat *);

/*
 * Server routine to read requests and process them.
 * Commands are:
 *	Tname	- Transmit file if out of date
 *	Vname	- Verify if file out of date or not
 *	Qname	- Query if file exists. Return mtime & size if it does.
 */
void
server()
{
	char cmdbuf[BUFSIZ];
	char *cp;

	signal(SIGHUP, cleanup);
	signal(SIGINT, cleanup);
	signal(SIGQUIT, cleanup);
	signal(SIGTERM, cleanup);
	signal(SIGPIPE, cleanup);

	rem = 0;
	oumask = umask(0);
	(void) snprintf(buf, sizeof(buf), "V%d\n", VERSION);
	(void) write(rem, buf, strlen(buf));

#if	!defined(DIRECT_RCMD)
	if (getuid() != geteuid()) {
		error("This version of rdist should not be installed setuid.\n");
		return;
	}
#endif	/* DIRECT_RCMD */

	for (;;) {
		cp = cmdbuf;
		if (read(rem, cp, 1) <= 0)
			return;
		if (*cp++ == '\n') {
			error("server: expected control record\n");
			continue;
		}
		do {
			if (read(rem, cp, 1) != 1)
				cleanup(0);
		} while (*cp++ != '\n' && cp < &cmdbuf[BUFSIZ]);
		*--cp = '\0';
		cp = cmdbuf;
		switch (*cp++) {
		case 'T':  /* init target file/directory name */
			catname = 1;	/* target should be directory */
			goto dotarget;

		case 't':  /* init target file/directory name */
			catname = 0;
		dotarget:
			if (exptilde(target, cp, sizeof (target)) == NULL)
				continue;
			tp = target;
			while (*tp)
				tp++;
			ack();
			continue;

		case 'R':  /* Transfer a regular file. */
			recvf(cp, S_IFREG);
			continue;

		case 'D':  /* Transfer a directory. */
			recvf(cp, S_IFDIR);
			continue;

		case 'K':  /* Transfer symbolic link. */
			recvf(cp, S_IFLNK);
			continue;

		case 'k':  /* Transfer hard link. */
			hardlink(cp);
			continue;

		case 'E':  /* End. (of directory) */
			*tp = '\0';
			if (catname <= 0) {
				error("server: too many 'E's\n");
				continue;
			}
			tp = stp[--catname];
			*tp = '\0';
			ack();
			continue;

		case 'C':  /* Clean. Cleanup a directory */
			clean(cp);
			continue;

		case 'Q':  /* Query. Does the file/directory exist? */
			query(cp);
			continue;

		case 'S':  /* Special. Execute commands */
			dospecial(cp);
			continue;

#ifdef notdef
		/*
		 * These entries are reserved but not currently used.
		 * The intent is to allow remote hosts to have master copies.
		 * Currently, only the host rdist runs on can have masters.
		 */
		case 'X':  /* start a new list of files to exclude */
			except = bp = NULL;
		case 'x':  /* add name to list of files to exclude */
			if (*cp == '\0') {
				ack();
				continue;
			}
			if (*cp == '~') {
				if (exptilde(buf, cp, sizeof (buf)) == NULL)
					continue;
				cp = buf;
			}
			if (bp == NULL)
				except = bp = expand(makeblock(NAME, cp), E_VARS);
			else
				bp->b_next = expand(makeblock(NAME, cp), E_VARS);
			while (bp->b_next != NULL)
				bp = bp->b_next;
			ack();
			continue;

		case 'I':  /* Install. Transfer file if out of date. */
			opts = 0;
			while (*cp >= '0' && *cp <= '7')
				opts = (opts << 3) | (*cp++ - '0');
			if (*cp++ != ' ') {
				error("server: options not delimited\n");
				return;
			}
			install(cp, opts);
			continue;

		case 'L':  /* Log. save message in log file */
			logit(lfp, "%s", cp);
			continue;
#endif

		case '\1':
			nerrs++;
			continue;

		case '\2':
			return;

		default:
			error("server: unknown command '%s'\n", cp);
		case '\0':
			continue;
		}
	}
}

/*
 * Update the file(s) if they are different.
 * destdir = 1 if destination should be a directory
 * (i.e., more than one source is being copied to the same destination).
 */
void
install(src, dest, destdir, opts)
	char *src, *dest;
	int destdir, opts;
{
	char *rname;
	char destcopy[BUFSIZ];

	if (opts & WHOLE)
		source[0] = '\0';
	else
		strlcpy(source, src, sizeof source);

	if (dest == NULL) {
		opts &= ~WHOLE; /* WHOLE mode only useful if renaming */
		dest = src;
	}

	if (nflag || debug) {
		printf("%s%s%s%s%s %s %s\n", opts & VERIFY ? "verify":"install",
			opts & WHOLE ? " -w" : "",
			opts & YOUNGER ? " -y" : "",
			opts & COMPARE ? " -b" : "",
			opts & REMOVE ? " -R" : "", src, dest);
		if (nflag)
			return;
	}

	rname = exptilde(target, src, sizeof(target));
	if (rname == NULL)
		return;
	tp = target;
	while (*tp)
		tp++;
	/*
	 * If we are renaming a directory and we want to preserve
	 * the directory hierarchy (-w), we must strip off the leading
	 * directory name and preserve the rest.
	 */
	if (opts & WHOLE) {
		while (*rname == '/')
			rname++;
		destdir = 1;
	} else {
		rname = basename(target);
	}
	if (debug)
		printf("target = %s, rname = %s\n", target, rname);
	/*
	 * Pass the destination file/directory name to remote.
	 */
	(void) snprintf(buf, sizeof(buf), "%c%s\n", destdir ? 'T' : 't', dest);
	if (debug)
		printf("buf = %s", buf);
	(void) write(rem, buf, strlen(buf));
	if (response() < 0)
		return;

	/*
	 * Save the name of the remote target destination if we are
	 * in WHOLE mode (destdir > 0) or if the source and destination
	 * are not the same.  This info will be used later for maintaining
	 * hardlink info.
	 */
	if (destdir || (src && dest && strcmp(src, dest))) {
		strlcpy(destcopy, dest, sizeof destcopy);
		Tdest = destcopy;
	}
	sendf(rname, opts);
	Tdest = 0;
}

static char *
remotename(pathname, src)
	char *pathname;
	char *src;
{
	char *cp;
	int len;

	cp = pathname;
	len = strlen(src);
	if (0 == strncmp(pathname, src, len))
	        cp += len;
	if (*cp == '/')
	        cp ++;
	return(cp);
}

void
installlink(lp, rname, opts)
	struct linkbuf *lp;
	char *rname;
	int opts;
{
	if (*lp->target == 0)
		(void) snprintf(buf, sizeof(buf), "k%o %s %s\n",
		    opts, lp->pathname, rname);
	else
		(void) snprintf(buf, sizeof(buf), "k%o %s/%s %s\n",
		    opts, lp->target,
		    remotename(lp->pathname, lp->src), rname);

	if (debug) {
	        printf("lp->src      = %s\n", lp->src);
	        printf("lp->target   = %s\n", lp->target);
	        printf("lp->pathname = %s\n", lp->pathname);
	        printf("rname        = %s\n", rname);
	        printf("buf          = %s",   buf);
	}
	(void) write(rem, buf, strlen(buf));
	(void) response();
}

#define protoname() (pw ? pw->pw_name : user)
#define protogroup() (gr ? gr->gr_name : group)
/*
 * Transfer the file or directory in target[].
 * rname is the name of the file on the remote host.
 */
static void
sendf(rname, opts)
	char *rname;
	int opts;
{
	struct subcmd *sc;
	struct stat stb;
	int sizerr, f, u, len;
	off_t i;
	DIR *d;
	struct dirent *dp;
	char *otp, *cp;
	extern struct subcmd *subcmds;
	static char user[15], group[15];

	if (debug)
		printf("sendf(%s, %x)\n", rname, opts);

	if (except(target))
		return;
	if ((opts & FOLLOW ? stat(target, &stb) : lstat(target, &stb)) < 0) {
		error("%s: %s\n", target, strerror(errno));
		return;
	}
	if ((u = update(rname, opts, &stb)) == 0) {
		if ((stb.st_mode & S_IFMT) == S_IFREG && stb.st_nlink > 1)
			(void) savelink(&stb);
		return;
	}

	if (pw == NULL || pw->pw_uid != stb.st_uid)
		if ((pw = getpwuid(stb.st_uid)) == NULL) {
			logit(lfp, "%s: no password entry for uid %u \n",
				target, stb.st_uid);
			pw = NULL;
			(void) snprintf(user, sizeof(user), ":%u", stb.st_uid);
		}
	if (gr == NULL || gr->gr_gid != stb.st_gid)
		if ((gr = getgrgid(stb.st_gid)) == NULL) {
			logit(lfp, "%s: no name for group %u\n",
				target, stb.st_gid);
			gr = NULL;
			(void) snprintf(group, sizeof(group), ":%u",
				stb.st_gid);
		}
	if (u == 1) {
		if (opts & VERIFY) {
			logit(lfp, "need to install: %s\n", target);
			goto dospecial;
		}
		logit(lfp, "installing: %s\n", target);
		opts &= ~(COMPARE|REMOVE);
	}

	switch (stb.st_mode & S_IFMT) {
	case S_IFDIR:
		if ((d = opendir(target)) == NULL) {
			error("%s: %s\n", target, strerror(errno));
			return;
		}
		(void) snprintf(buf, sizeof(buf), "D%o %04o 0 0 %s %s %s\n",
			opts, stb.st_mode & 07777, protoname(), protogroup(),
			rname);
		if (debug)
			printf("buf = %s", buf);
		(void) write(rem, buf, strlen(buf));
		if (response() < 0) {
			closedir(d);
			return;
		}

		if (opts & REMOVE)
			rmchk(opts);

		otp = tp;
		len = tp - target;
		while (dp = readdir(d)) {
			if (!strcmp(dp->d_name, ".") ||
			    !strcmp(dp->d_name, ".."))
				continue;
			if (len + 1 + strlen(dp->d_name) >= BUFSIZ - 1) {
				error("%s/%s: Name too long\n", target,
					dp->d_name);
				continue;
			}
			tp = otp;
			*tp++ = '/';
			cp = dp->d_name;
			while (*tp++ = *cp++)
				;
			tp--;
			sendf(dp->d_name, opts);
		}
		closedir(d);
		(void) write(rem, "E\n", 2);
		(void) response();
		tp = otp;
		*tp = '\0';
		return;

	case S_IFLNK:
		if (u != 1)
			opts |= COMPARE;
		if (stb.st_nlink > 1) {
			struct linkbuf *lp;

			if ((lp = savelink(&stb)) != NULL) {
				installlink(lp, rname, opts);
				return;
			}
		}
		(void) snprintf(buf, sizeof(buf), "K%o %o %qd %ld %s %s %s\n",
			opts, stb.st_mode & 07777, stb.st_size,
			(long)stb.st_mtime, protoname(), protogroup(), rname);
		if (debug)
			printf("buf = %s", buf);
		(void) write(rem, buf, strlen(buf));
		if (response() < 0)
			return;
		sizerr = (readlink(target, buf, BUFSIZ-1) != stb.st_size);
		(void) write(rem, buf, stb.st_size);
		if (debug)
			printf("readlink = %.*s\n", (int)stb.st_size, buf);
		goto done;

	case S_IFREG:
		break;

	default:
		error("%s: not a file or directory\n", target);
		return;
	}

	if (u == 2) {
		if (opts & VERIFY) {
			logit(lfp, "need to update: %s\n", target);
			goto dospecial;
		}
		logit(lfp, "updating: %s\n", target);
	}

	if (stb.st_nlink > 1) {
		struct linkbuf *lp;

		if ((lp = savelink(&stb)) != NULL) {
			installlink(lp, rname, opts);
			return;
		}
	}

	if ((f = open(target, O_RDONLY)) < 0) {
		error("%s: %s\n", target, strerror(errno));
		return;
	}
	(void) snprintf(buf, sizeof(buf), "R%o %o %qd %ld %s %s %s\n", opts,
		stb.st_mode & 07777, stb.st_size, (long)stb.st_mtime,
		protoname(), protogroup(), rname);
	if (debug)
		printf("buf = %s", buf);
	(void) write(rem, buf, strlen(buf));
	if (response() < 0) {
		(void) close(f);
		return;
	}
	sizerr = 0;
	for (i = 0; i < stb.st_size; i += BUFSIZ) {
		int amt = BUFSIZ;
		if (i + amt > stb.st_size)
			amt = stb.st_size - i;
		if (sizerr == 0 && read(f, buf, amt) != amt)
			sizerr = 1;
		(void) write(rem, buf, amt);
	}
	(void) close(f);
done:
	if (sizerr) {
		error("%s: file changed size\n", target);
		err();
	} else
		ack();
	f = response();
	if (f < 0 || f == 0 && (opts & COMPARE))
		return;
dospecial:
	for (sc = subcmds; sc != NULL; sc = sc->sc_next) {
		if (sc->sc_type != SPECIAL)
			continue;
		if (sc->sc_args != NULL && !inlist(sc->sc_args, target))
			continue;
		logit(lfp, "special \"%s\"\n", sc->sc_name);
		if (opts & VERIFY)
			continue;
		(void) snprintf(buf, sizeof(buf), "SFILE=%s;%s\n", target,
			sc->sc_name);
		if (debug)
			printf("buf = %s", buf);
		(void) write(rem, buf, strlen(buf));
		while (response() > 0)
			;
	}
}

static struct linkbuf *
savelink(stp)
	struct stat *stp;
{
	struct linkbuf *lp;

	for (lp = ihead; lp != NULL; lp = lp->nextp)
		if (lp->inum == stp->st_ino && lp->devnum == stp->st_dev) {
			lp->count--;
			return(lp);
		}
	lp = (struct linkbuf *) malloc(sizeof(*lp));
	if (lp == NULL)
		logit(lfp, "out of memory, link information lost\n");
	else {
		lp->nextp = ihead;
		ihead = lp;
		lp->inum = stp->st_ino;
		lp->devnum = stp->st_dev;
		lp->count = stp->st_nlink - 1;
		strlcpy(lp->pathname, target, sizeof lp->pathname);
		strlcpy(lp->src, source, sizeof lp->src);
		if (Tdest)
			strlcpy(lp->target, Tdest, sizeof lp->target);
		else
			*lp->target = 0;
	}
	return(NULL);
}

/*
 * Check to see if file needs to be updated on the remote machine.
 * Returns 0 if no update, 1 if remote doesn't exist, 2 if out of date
 * and 3 if comparing binaries to determine if out of date.
 */
static int
update(rname, opts, stp)
	char *rname;
	int opts;
	struct stat *stp;
{
	char *cp, *s;
	off_t size;
	time_t mtime;

	if (debug) 
		printf("update(%s, %x, %p)\n", rname, opts, stp);

	/*
	 * Check to see if the file exists on the remote machine.
	 */
	(void) snprintf(buf, sizeof(buf), "Q%s\n", rname);
	if (debug)
		printf("buf = %s", buf);
	(void) write(rem, buf, strlen(buf));
again:
	cp = s = buf;
	do {
		if (read(rem, cp, 1) != 1)
			lostconn(0);
	} while (*cp++ != '\n' && cp < &buf[BUFSIZ]);

	switch (*s++) {
	case 'Y':
		break;

	case 'N':  /* file doesn't exist so install it */
		return(1);

	case '\1':
		nerrs++;
		if (*s != '\n') {
			if (!iamremote) {
				fflush(stdout);
				(void) write(STDERR_FILENO, s, cp - s);
			}
			if (lfp != NULL)
				(void) fwrite(s, 1, cp - s, lfp);
		}
		return(0);

	case '\3':
		*--cp = '\0';
		if (lfp != NULL) 
			logit(lfp, "update: note: %s\n", s);
		goto again;

	default:
		*--cp = '\0';
		error("update: unexpected response '%s'\n", s);
		return(0);
	}

	if (*s == '\n')
		return(2);

	if (opts & COMPARE)
		return(3);

	size = 0;
	while (isdigit(*s))
		size = size * 10 + (*s++ - '0');
	if (*s++ != ' ') {
		error("update: size not delimited\n");
		return(0);
	}
	mtime = 0;
	while (isdigit(*s))
		mtime = mtime * 10 + (*s++ - '0');
	if (*s != '\n') {
		error("update: mtime not delimited\n");
		return(0);
	}
	/*
	 * File needs to be updated?
	 */
	if (opts & YOUNGER) {
		if (stp->st_mtime == mtime)
			return(0);
		if (stp->st_mtime < mtime) {
			logit(lfp, "Warning: %s: remote copy is newer\n", target);
			return(0);
		}
	} else if (stp->st_mtime == mtime && stp->st_size == size)
		return(0);
	return(2);
}

/*
 * Query. Check to see if file exists. Return one of the following:
 *	N\n		- doesn't exist
 *	Ysize mtime\n	- exists and its a regular file (size & mtime of file)
 *	Y\n		- exists and its a directory or symbolic link
 *	^Aerror message\n
 */
static void
query(name)
	char *name;
{
	struct stat stb;

	if (catname)
		(void) snprintf(tp, sizeof(target) - (tp - target),
			"/%s", name);

	if (lstat(target, &stb) < 0) {
		if (errno == ENOENT)
			(void) write(rem, "N\n", 2);
		else
			error("%s:%s: %s\n", host, target, strerror(errno));
		*tp = '\0';
		return;
	}

	switch (stb.st_mode & S_IFMT) {
	case S_IFREG:
		(void) snprintf(buf, sizeof(buf), "Y%qd %ld\n", stb.st_size,
			(long)stb.st_mtime);
		(void) write(rem, buf, strlen(buf));
		break;

	case S_IFLNK:
	case S_IFDIR:
		(void) write(rem, "Y\n", 2);
		break;

	default:
		error("%s: not a file or directory\n", name);
		break;
	}
	*tp = '\0';
}

static void
recvf(cmd, type)
	char *cmd;
	int type;
{
	char *cp = cmd;
	int f = -1, mode, opts = 0, wrerr, olderrno;
	off_t i, size;
	time_t mtime;
	struct stat stb;
	struct timeval tvp[2];
	char *owner, *group;
	char new[BUFSIZ];
	extern char *tempname;

	while (*cp >= '0' && *cp <= '7')
		opts = (opts << 3) | (*cp++ - '0');
	if (*cp++ != ' ') {
		error("recvf: options not delimited\n");
		return;
	}
	mode = 0;
	while (*cp >= '0' && *cp <= '7')
		mode = (mode << 3) | (*cp++ - '0');
	if (*cp++ != ' ') {
		error("recvf: mode not delimited\n");
		return;
	}
	size = 0;
	while (isdigit(*cp))
		size = size * 10 + (*cp++ - '0');
	if (*cp++ != ' ') {
		error("recvf: size not delimited\n");
		return;
	}
	mtime = 0;
	while (isdigit(*cp))
		mtime = mtime * 10 + (*cp++ - '0');
	if (*cp++ != ' ') {
		error("recvf: mtime not delimited\n");
		return;
	}
	owner = cp;
	while (*cp && *cp != ' ')
		cp++;
	if (*cp != ' ') {
		error("recvf: owner name not delimited\n");
		return;
	}
	*cp++ = '\0';
	group = cp;
	while (*cp && *cp != ' ')
		cp++;
	if (*cp != ' ') {
		error("recvf: group name not delimited\n");
		return;
	}
	*cp++ = '\0';

	if (type == S_IFDIR) {
		if (catname >= sizeof(stp)) {
			error("%s:%s: too many directory levels\n",
				host, target);
			return;
		}
		stp[catname] = tp;
		if (catname++) {
			*tp++ = '/';
			while (*tp++ = *cp++)
				;
			tp--;
		}
		if (opts & VERIFY) {
			ack();
			return;
		}
		if (lstat(target, &stb) == 0) {
			if (ISDIR(stb.st_mode)) {
				if ((stb.st_mode & 07777) == mode) {
					ack();
					return;
				}
				buf[0] = '\0';
				(void) snprintf(buf + 1, sizeof(buf) - 1,
					"%s: Warning: remote mode %o != local mode %o\n",
					target, stb.st_mode & 07777, mode);
				(void) write(rem, buf, strlen(buf + 1) + 1);
				return;
			}
			errno = ENOTDIR;
		} else if (errno == ENOENT && (mkdir(target, mode) == 0 ||
		    chkparent(target) == 0 && mkdir(target, mode) == 0)) {
			if (fchog(-1, target, owner, group, mode) == 0)
				ack();
			return;
		}
		error("%s:%s: %s\n", host, target, strerror(errno));
		tp = stp[--catname];
		*tp = '\0';
		return;
	}

	if (catname)
		(void) snprintf(tp, sizeof(target) - (tp - target), "/%s", cp);
	cp = strrchr(target, '/');
	if (cp == NULL)
		strlcpy(new, tempname, sizeof new);
	else if (cp == target)
		(void) snprintf(new, sizeof(new), "/%s", tempname);
	else {
		*cp = '\0';
		(void) snprintf(new, sizeof(new), "%s/%s", target, tempname);
		*cp = '/';
	}

	if (type == S_IFLNK) {
		int j;

		ack();
		cp = buf;
		for (i = 0; i < size; i += j) {
			if ((j = read(rem, cp, size - i)) <= 0)
				cleanup(0);
			cp += j;
		}
		*cp = '\0';
		if (response() < 0) {
			err();
			return;
		}
		if (symlink(buf, new) < 0) {
			if (errno != ENOENT || chkparent(new) < 0 ||
			    symlink(buf, new) < 0)
				goto badnew1;
		}
		mode &= 0777;
		if (opts & COMPARE) {
			char tbuf[BUFSIZ];

			if ((i = readlink(target, tbuf, BUFSIZ)) >= 0 &&
			    i == size && strncmp(buf, tbuf, size) == 0) {
				(void) unlink(new);
				ack();
				return;
			}
			if (opts & VERIFY)
				goto differ;
		}
		goto fixup;
	}

	if ((f = creat(new, mode)) < 0) {
		if (errno != ENOENT || chkparent(new) < 0 ||
		    (f = creat(new, mode)) < 0)
			goto badnew1;
	}

	ack();
	wrerr = 0;
	for (i = 0; i < size; i += BUFSIZ) {
		int amt = BUFSIZ;

		cp = buf;
		if (i + amt > size)
			amt = size - i;
		do {
			int j = read(rem, cp, amt);

			if (j <= 0) {
				(void) close(f);
				(void) unlink(new);
				cleanup(0);
			}
			amt -= j;
			cp += j;
		} while (amt > 0);
		amt = BUFSIZ;
		if (i + amt > size)
			amt = size - i;
		if (wrerr == 0 && write(f, buf, amt) != amt) {
			olderrno = errno;
			wrerr++;
		}
	}
	if (response() < 0) {
		err();
		goto badnew2;
	}
	if (wrerr)
		goto badnew1;
	if (opts & COMPARE) {
		FILE *f1, *f2;
		int c;

		if ((f1 = fopen(target, "r")) == NULL)
			goto badtarget;
		if ((f2 = fopen(new, "r")) == NULL) {
badnew1:		error("%s:%s: %s\n", host, new, strerror(errno));
			goto badnew2;
		}
		while ((c = getc(f1)) == getc(f2))
			if (c == EOF) {
				(void) fclose(f1);
				(void) fclose(f2);
				ack();
				goto badnew2;
			}
		(void) fclose(f1);
		(void) fclose(f2);
		if (opts & VERIFY) {
differ:			buf[0] = '\0';
			(void) snprintf(buf + 1, sizeof(buf) - 1,
				"need to update: %s\n",target);
			(void) write(rem, buf, strlen(buf + 1) + 1);
			goto badnew2;
		}
	}

	/*
	 * Set last modified time
	 */
	tvp[0].tv_sec = time(NULL);
	tvp[0].tv_usec = 0;
	tvp[1].tv_sec = mtime;
	tvp[1].tv_usec = 0;
	if (utimes(new, tvp) < 0)
		note("%s: utimes failed %s: %s\n", host, new, strerror(errno));

	if (fchog(f, new, owner, group, mode) < 0) {
badnew2:	
		if (f >= 0)
			(void) close(f);
		(void) unlink(new);
		return;
	}
	(void) close(f);

fixup:	if (rename(new, target) < 0) {
badtarget:	error("%s:%s: %s\n", host, target, strerror(errno));
		(void) unlink(new);
		return;
	}

	if (opts & COMPARE) {
		buf[0] = '\0';
		(void) snprintf(buf + 1, sizeof(buf) - 1,
			"updated %s\n", target);
		(void) write(rem, buf, strlen(buf + 1) + 1);
	} else
		ack();
}

/*
 * Creat a hard link to existing file.
 */
static void
hardlink(cmd)
	char *cmd;
{
	char *cp = cmd;
	struct stat stb;
	char *oldname;
	int opts = 0, exists = 0;

	while (*cp >= '0' && *cp <= '7')
		opts = (opts << 3) | (*cp++ - '0');
	if (*cp++ != ' ') {
		error("hardlink: options not delimited\n");
		return;
	}
	oldname = cp;
	while (*cp && *cp != ' ')
		cp++;
	if (*cp != ' ') {
		error("hardlink: oldname name not delimited\n");
		return;
	}
	*cp++ = '\0';

	if (catname) {
		(void) snprintf(tp, sizeof(target) - (tp - target), "/%s", cp);
	}
	if (lstat(target, &stb) == 0) {
		int mode = stb.st_mode & S_IFMT;
		if (mode != S_IFREG && mode != S_IFLNK) {
			error("%s:%s: not a regular file\n", host, target);
			return;
		}
		exists = 1;
	}
	if (chkparent(target) < 0 ) {
		error("%s:%s: %s (no parent)\n",
			host, target, strerror(errno));
		return;
	}
	if (exists && (unlink(target) < 0)) {
		error("%s:%s: %s (unlink)\n",
			host, target, strerror(errno));
		return;
	}
	if (link(oldname, target) < 0) {
		error("%s:can't link %s to %s\n",
			host, target, oldname);
		return;
	}
	ack();
}

/*
 * Check to see if parent directory exists and create one if not.
 */
static int
chkparent(name)
	char *name;
{
	char *cp;
	struct stat stb;

	cp = strrchr(name, '/');
	if (cp == NULL || cp == name)
		return(0);
	*cp = '\0';
	if (lstat(name, &stb) < 0) {
		if (errno == ENOENT && chkparent(name) >= 0 &&
		    mkdir(name, 0777 & ~oumask) >= 0) {
			*cp = '/';
			return(0);
		}
	} else if (ISDIR(stb.st_mode)) {
		*cp = '/';
		return(0);
	}
	*cp = '/';
	return(-1);
}

/*
 * Change owner, group and mode of file.
 */
static int
fchog(fd, file, owner, group, mode)
	int fd;
	char *file, *owner, *group;
	int mode;
{
	int i;
	uid_t uid;
	gid_t gid;
	extern char user[];
	extern uid_t userid;

	uid = userid;
	if (userid == 0) {
		if (*owner == ':') {
			uid = atoi(owner + 1);
		} else if (pw == NULL || strcmp(owner, pw->pw_name) != 0) {
			if ((pw = getpwnam(owner)) == NULL) {
				if (mode & 04000) {
					note("%s:%s: unknown login name, clearing setuid",
						host, owner);
					mode &= ~04000;
					uid = 0;
				}
			} else
				uid = pw->pw_uid;
		} else
			uid = pw->pw_uid;
		if (*group == ':') {
			gid = atoi(group + 1);
			goto ok;
		}
	} else if ((mode & 04000) && strcmp(user, owner) != 0)
		mode &= ~04000;
	gid = -1;
	if (gr == NULL || strcmp(group, gr->gr_name) != 0) {
		if ((*group == ':' && (getgrgid(gid = atoi(group + 1)) == NULL))
		   || ((gr = getgrnam(group)) == NULL)) {
			if (mode & 02000) {
				note("%s:%s: unknown group", host, group);
				mode &= ~02000;
			}
		} else
			gid = gr->gr_gid;
	} else
		gid = gr->gr_gid;
	if (userid && gid >= 0) {
		if (gr) for (i = 0; gr->gr_mem[i] != NULL; i++)
			if (!(strcmp(user, gr->gr_mem[i])))
				goto ok;
		mode &= ~02000;
		gid = -1;
	}
ok:	if (fd != -1 && fchown(fd, uid, gid) < 0 || chown(file, uid, gid) < 0)
		note("%s: %s chown: %s", host, file, strerror(errno));
	else if (mode & 07000 &&
	   (fd != -1 && fchmod(fd, mode) < 0 || chmod(file, mode) < 0))
		note("%s: %s chmod: %s", host, file, strerror(errno));
	return(0);
}

/*
 * Check for files on the machine being updated that are not on the master
 * machine and remove them.
 */
static void
rmchk(opts)
	int opts;
{
	char *cp, *s;
	struct stat stb;

	if (debug)
		printf("rmchk()\n");

	/*
	 * Tell the remote to clean the files from the last directory sent.
	 */
	(void) snprintf(buf, sizeof(buf), "C%o\n", opts & VERIFY);
	if (debug)
		printf("buf = %s", buf);
	(void) write(rem, buf, strlen(buf));
	if (response() < 0)
		return;
	for (;;) {
		cp = s = buf;
		do {
			if (read(rem, cp, 1) != 1)
				lostconn(0);
		} while (*cp++ != '\n' && cp < &buf[BUFSIZ]);

		switch (*s++) {
		case 'Q': /* Query if file should be removed */
			/*
			 * Return the following codes to remove query.
			 * N\n -- file exists - DON'T remove.
			 * Y\n -- file doesn't exist - REMOVE.
			 */
			*--cp = '\0';
			(void) snprintf(tp, sizeof(target) - (tp - target),
				"/%s", s);
			if (debug)
				printf("check %s\n", target);
			if (except(target))
				(void) write(rem, "N\n", 2);
			else if (lstat(target, &stb) < 0)
				(void) write(rem, "Y\n", 2);
			else
				(void) write(rem, "N\n", 2);
			break;

		case '\0':
			*--cp = '\0';
			if (*s != '\0')
				logit(lfp, "%s\n", s);
			break;

		case 'E':
			*tp = '\0';
			ack();
			return;

		case '\1':
		case '\2':
			nerrs++;
			if (*s != '\n') {
				if (!iamremote) {
					fflush(stdout);
					(void) write(STDERR_FILENO, s, cp - s);
				}
				if (lfp != NULL)
					(void) fwrite(s, 1, cp - s, lfp);
			}
			if (buf[0] == '\2')
				lostconn(0);
			break;

		default:
			error("rmchk: unexpected response '%s'\n", buf);
			err();
		}
	}
}

/*
 * Check the current directory (initialized by the 'T' command to server())
 * for extraneous files and remove them.
 */
static void
clean(cp)
	char *cp;
{
	DIR *d;
	struct dirent *dp;
	struct stat stb;
	char *otp;
	int len, opts;

	opts = 0;
	while (*cp >= '0' && *cp <= '7')
		opts = (opts << 3) | (*cp++ - '0');
	if (*cp != '\0') {
		error("clean: options not delimited\n");
		return;
	}
	if ((d = opendir(target)) == NULL) {
		error("%s:%s: %s\n", host, target, strerror(errno));
		return;
	}
	ack();

	otp = tp;
	len = tp - target;
	while (dp = readdir(d)) {
		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
			continue;
		if (len + 1 + strlen(dp->d_name) >= BUFSIZ - 1) {
			error("%s:%s/%s: Name too long\n",
				host, target, dp->d_name);
			continue;
		}
		tp = otp;
		*tp++ = '/';
		cp = dp->d_name;
		while (*tp++ = *cp++)
			;
		tp--;
		if (lstat(target, &stb) < 0) {
			error("%s:%s: %s\n", host, target, strerror(errno));
			continue;
		}
		(void) snprintf(buf, sizeof(buf), "Q%s\n", dp->d_name);
		(void) write(rem, buf, strlen(buf));
		cp = buf;
		do {
			if (read(rem, cp, 1) != 1)
				cleanup(0);
		} while (*cp++ != '\n' && cp < &buf[BUFSIZ]);
		*--cp = '\0';
		cp = buf;
		if (*cp != 'Y')
			continue;
		if (opts & VERIFY) {
			cp = buf;
			*cp++ = '\0';
			(void) snprintf(cp, sizeof(buf) - 1,
				"need to remove: %s\n", target);
			(void) write(rem, buf, strlen(cp) + 1);
		} else
			removeit(&stb);
	}
	closedir(d);
	(void) write(rem, "E\n", 2);
	(void) response();
	tp = otp;
	*tp = '\0';
}

/*
 * Remove a file or directory (recursively) and send back an acknowledge
 * or an error message.
 */
static void
removeit(stp)
	struct stat *stp;
{
	DIR *d;
	struct dirent *dp;
	char *cp;
	struct stat stb;
	char *otp;
	int len;

	switch (stp->st_mode & S_IFMT) {
	case S_IFREG:
	case S_IFLNK:
		if (unlink(target) < 0)
			goto bad;
		goto removed;

	case S_IFDIR:
		break;

	default:
		error("%s:%s: not a plain file\n", host, target);
		return;
	}

	if ((d = opendir(target)) == NULL)
		goto bad;

	otp = tp;
	len = tp - target;
	while (dp = readdir(d)) {
		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
			continue;
		if (len + 1 + strlen(dp->d_name) >= BUFSIZ - 1) {
			error("%s:%s/%s: Name too long\n",
				host, target, dp->d_name);
			continue;
		}
		tp = otp;
		*tp++ = '/';
		cp = dp->d_name;
		while (*tp++ = *cp++)
			;
		tp--;
		if (lstat(target, &stb) < 0) {
			error("%s:%s: %s\n", host, target, strerror(errno));
			continue;
		}
		removeit(&stb);
	}
	closedir(d);
	tp = otp;
	*tp = '\0';
	if (rmdir(target) < 0) {
bad:
		error("%s:%s: %s\n", host, target, strerror(errno));
		return;
	}
removed:
	cp = buf;
	*cp++ = '\0';
	(void) snprintf(cp, sizeof(buf) - 1, "removed %s\n", target);
	(void) write(rem, buf, strlen(cp) + 1);
}

/*
 * Execute a shell command to handle special cases.
 */
static void
dospecial(cmd)
	char *cmd;
{
	int fd[2], status;
	char *cp, *s;
	char sbuf[BUFSIZ];
	pid_t pid, i;
#if     defined(DIRECT_RCMD)
	extern uid_t userid;
	extern gid_t groupid;
#endif  /* DIRECT_RCMD */

	if (pipe(fd) < 0) {
		error("%s\n", strerror(errno));
		return;
	}
	if ((pid = fork()) == 0) {
		/*
		 * Return everything the shell commands print.
		 */
		(void) close(0);
		(void) close(1);
		(void) close(2);
		(void) open(_PATH_DEVNULL, O_RDONLY);
		(void) dup(fd[1]);
		(void) dup(fd[1]);
		(void) close(fd[0]);
		(void) close(fd[1]);
#if	defined(DIRECT_RCMD)
		if (setgroups(1, &groupid) == -1 ||
		    setresgid(groupid, groupid, groupid) == -1 ||
		    setresuid(userid, userid, userid) == -1)
			_exit(127);
#endif	/* DIRECT_RCMD */
		execl(_PATH_BSHELL, "sh", "-c", cmd, (char *)NULL);
		_exit(127);
	}
	(void) close(fd[1]);
	s = sbuf;
	*s++ = '\0';
	while ((i = read(fd[0], buf, sizeof(buf))) > 0) {
		cp = buf;
		do {
			*s++ = *cp++;
			if (cp[-1] != '\n') {
				if (s < &sbuf[sizeof(sbuf)-1])
					continue;
				*s++ = '\n';
			}
			/*
			 * Throw away blank lines.
			 */
			if (s == &sbuf[2]) {
				s--;
				continue;
			}
			(void) write(rem, sbuf, s - sbuf);
			s = &sbuf[1];
		} while (--i);
	}
	if (s > &sbuf[1]) {
		*s++ = '\n';
		(void) write(rem, sbuf, s - sbuf);
	}
	while ((i = wait(&status)) != pid && i != -1)
		;
	if (i == -1)
		status = -1;
	(void) close(fd[0]);
	if (status)
		error("shell returned %d\n", status);
	else
		ack();
}

void
logit(FILE *fp, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	/* Print changes locally if not quiet mode */
	if (!qflag)
		(void) vprintf(fmt, ap);

	/* Save changes (for mailing) if really updating files */
	if (!(options & VERIFY) && fp != NULL)
		(void) vfprintf(fp, fmt, ap);
	va_end(ap);
}

void
error(const char *fmt, ...)
{
	static FILE *fp;
	va_list ap;

	va_start(ap, fmt);
	++nerrs;
	if (iamremote) {
		if (!fp && (rem < 0 || !(fp = fdopen(rem, "w"))))
			return;
		(void) fprintf(fp, "%crdist: ", 0x01);
		(void) vfprintf(fp, fmt, ap);
		fflush(fp);
	}
	else {
		fflush(stdout);
		(void) fprintf(stderr, "rdist: ");
		(void) vfprintf(stderr, fmt, ap);
		fflush(stderr);
	}
	if (lfp != NULL) {
		(void) fprintf(lfp, "rdist: ");
		(void) vfprintf(lfp, fmt, ap);
		fflush(lfp);
	}
	va_end(ap);
}

void
fatal(const char *fmt, ...)
{
	static FILE *fp;
	va_list ap;

	va_start(ap, fmt);
	++nerrs;
	if (!fp && !(fp = fdopen(rem, "w")))
		return;
	if (iamremote) {
		(void) fprintf(fp, "%crdist: ", 0x02);
		(void) vfprintf(fp, fmt, ap);
		fflush(fp);
	}
	else {
		fflush(stdout);
		(void) fprintf(stderr, "rdist: ");
		(void) vfprintf(stderr, fmt, ap);
		fflush(stderr);
	}
	if (lfp != NULL) {
		(void) fprintf(lfp, "rdist: ");
		(void) vfprintf(lfp, fmt, ap);
		fflush(lfp);
	}
	va_end(ap);
	cleanup(0);
}

static int
response()
{
	char *cp, *s;
	char resp[BUFSIZ];

	if (debug)
		printf("response()\n");

	cp = s = resp;
	do {
		if (read(rem, cp, 1) != 1)
			lostconn(0);
	} while (*cp++ != '\n' && cp < &resp[BUFSIZ]);

	switch (*s++) {
	case '\0':
		*--cp = '\0';
		if (*s != '\0') {
			logit(lfp, "%s\n", s);
			return(1);
		}
		return(0);
	case '\3':
		*--cp = '\0';
		logit(lfp, "Note: %s\n",s);
		return(response());

	default:
		s--;
		/* fall into... */
	case '\1':
	case '\2':
		nerrs++;
		if (*s != '\n') {
			if (!iamremote) {
				fflush(stdout);
				(void) write(STDERR_FILENO, s, cp - s);
			}
			if (lfp != NULL)
				(void) fwrite(s, 1, cp - s, lfp);
		}
		if (resp[0] == '\2')
			lostconn(0);
		return(-1);
	}
}

/*
 * Remove temporary files and do any cleanup operations before exiting.
 */
void
cleanup(signo)
	int signo;
{
	(void) unlink(tempfile);
	exit(1);
}

static void
note(const char *fmt, ...)
{
	static char buf[BUFSIZ];
	va_list ap;

	va_start(ap, fmt);
	(void) vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);
	comment(buf);
}

static void
comment(s)
	char *s;
{
	char c;

	c = '\3';
	write(rem, &c, 1);
	write(rem, s, strlen(s));
	c = '\n';
	write(rem, &c, 1);
}
@


1.34
log
@Switch from antique struct direct to struct dirent
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.33 2013/04/16 22:37:28 deraadt Exp $	*/
@


1.33
log
@time(NULL) looks better than time(0)
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.32 2009/10/27 23:59:41 deraadt Exp $	*/
d364 1
a364 1
	struct direct *dp;
d1221 1
a1221 1
	struct direct *dp;
d1295 1
a1295 1
	struct direct *dp;
@


1.32
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.31 2007/10/17 20:10:44 chl Exp $	*/
d950 1
a950 1
	tvp[0].tv_sec = time(0);
@


1.31
log
@remove "unused variable" warnings

tested by deraadt@@ on a gcc2 arch

looks ok ray@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.30 2007/02/08 03:19:13 ray Exp $	*/
a30 5

#ifndef lint
/* from: static char sccsid[] = "@@(#)server.c	8.1 (Berkeley) 6/9/93"; */
static char *rcsid = "$OpenBSD: server.c,v 1.30 2007/02/08 03:19:13 ray Exp $";
#endif /* not lint */
@


1.30
log
@Remove double semicolons.

From Pierre Riteau <pierre dot riteau at free dot fr>.

OK jaredy@@ and moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.29 2005/07/04 01:54:10 djm Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: server.c,v 1.29 2005/07/04 01:54:10 djm Exp $";
d1372 1
d1375 1
@


1.29
log
@make these use setres[ug]id for simple privilege dropping;
ok deraadt@@ millert@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.28 2005/04/13 02:33:08 deraadt Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: server.c,v 1.28 2005/04/13 02:33:08 deraadt Exp $";
d1256 1
a1256 1
		cp = dp->d_name;;
d1336 1
a1336 1
		cp = dp->d_name;;
@


1.28
log
@use STD{IN,OUT,ERR}_FILENO
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.27 2004/10/04 05:21:27 jsg Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: server.c,v 1.27 2004/10/04 05:21:27 jsg Exp $";
d1392 4
a1395 4
		setegid(groupid);
		setgid(groupid);
		seteuid(userid);
		setuid(userid);
@


1.27
log
@hierarchy is spelt hierarchy, ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.26 2004/01/16 01:12:35 espie Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: server.c,v 1.26 2004/01/16 01:12:35 espie Exp $";
d635 1
a635 1
				(void) write(2, s, cp - s);
d1201 1
a1201 1
					(void) write(2, s, cp - s);
d1550 1
a1550 1
				(void) write(2, s, cp - s);
@


1.26
log
@log -> logit ISO C fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.25 2004/01/15 19:12:31 otto Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: server.c,v 1.25 2004/01/15 19:12:31 otto Exp $";
d275 1
a275 1
	 * the directory heirarchy (-w), we must strip off the leading
@


1.25
log
@Fix printf format strings. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.24 2003/06/03 02:56:14 millert Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: server.c,v 1.24 2003/06/03 02:56:14 millert Exp $";
d215 1
a215 1
			log(lfp, "%s", cp);
d391 1
a391 1
			log(lfp, "%s: no password entry for uid %u \n",
d398 1
a398 1
			log(lfp, "%s: no name for group %u\n",
d406 1
a406 1
			log(lfp, "need to install: %s\n", target);
d409 1
a409 1
		log(lfp, "installing: %s\n", target);
d494 1
a494 1
			log(lfp, "need to update: %s\n", target);
d497 1
a497 1
		log(lfp, "updating: %s\n", target);
d548 1
a548 1
		log(lfp, "special \"%s\"\n", sc->sc_name);
d574 1
a574 1
		log(lfp, "out of memory, link information lost\n");
d645 1
a645 1
			log(lfp, "update: note: %s\n", s);
d681 1
a681 1
			log(lfp, "Warning: %s: remote copy is newer\n", target);
d1187 1
a1187 1
				log(lfp, "%s\n", s);
d1439 1
a1439 1
log(FILE *fp, const char *fmt, ...)
d1532 1
a1532 1
			log(lfp, "%s\n", s);
d1538 1
a1538 1
		log(lfp, "Note: %s\n",s);
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.23 2003/06/01 15:53:35 deraadt Exp $	*/
d34 1
a34 1
static char *rcsid = "$OpenBSD: server.c,v 1.23 2003/06/01 15:53:35 deraadt Exp $";
d394 1
a394 1
			(void) snprintf(user, sizeof(user), ":%lu", stb.st_uid);
d401 1
a401 1
			(void) snprintf(group, sizeof(group), ":%lu",
d471 2
a472 2
			opts, stb.st_mode & 07777, stb.st_size, stb.st_mtime,
			protoname(), protogroup(), rname);
d514 1
a514 1
		stb.st_mode & 07777, stb.st_size, stb.st_mtime,
d607 1
a607 1
		printf("update(%s, %x, %x)\n", rname, opts, stp);
d718 1
a718 1
			stb.st_mtime);
@


1.23
log
@various format string cleanups; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.22 2003/04/06 17:57:45 ho Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 1
a34 1
static char *rcsid = "$OpenBSD: server.c,v 1.22 2003/04/06 17:57:45 ho Exp $";
@


1.22
log
@strcpy/strcat cleanup. Ick millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.21 2003/04/05 17:18:26 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.21 2003/04/05 17:18:26 deraadt Exp $";
d219 1
a219 1
			log(lfp, cp);
@


1.21
log
@string fixes; ok henning miod
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.20 2002/06/23 03:07:21 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.20 2002/06/23 03:07:21 deraadt Exp $";
d254 1
a254 1
		strcpy(source, src);
d585 2
a586 2
		strcpy(lp->pathname, target);
		strcpy(lp->src, source);
d588 1
a588 1
			strcpy(lp->target, Tdest);
@


1.20
log
@uid_t and gid_t are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.19 2002/06/12 06:07:16 mpech Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.19 2002/06/12 06:07:16 mpech Exp $";
d308 1
a308 1
		strcpy(destcopy, dest);
d844 1
a844 1
		strcpy(new, tempname);
@


1.19
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.18 2002/06/09 21:11:22 hin Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.18 2002/06/09 21:11:22 hin Exp $";
d395 1
a395 1
			log(lfp, "%s: no password entry for uid %d \n",
d402 1
a402 1
			log(lfp, "%s: no name for group %d\n",
@


1.18
log
@Remove private unused version of warn().
Replave private basename() with the real one.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.17 2002/02/19 19:39:38 millert Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.17 2002/02/19 19:39:38 millert Exp $";
d1084 2
a1085 1
	int uid, gid;
d1087 1
a1087 1
	extern int userid;
d1372 1
a1372 1
	int fd[2], status, pid, i;
d1375 3
a1377 1
	extern int userid, groupid;
@


1.17
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.16 2002/02/16 21:27:50 millert Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.16 2002/02/16 21:27:50 millert Exp $";
d42 1
d44 2
d287 1
a287 1
		rname = xbasename(target);
@


1.16
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.15 2001/11/19 19:02:15 mpech Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.15 2001/11/19 19:02:15 mpech Exp $";
d42 1
a1435 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a1436 1
#ifdef __STDC__
a1437 6
#else
log(fp, fmt, va_alist)
	FILE *fp;
	char *fmt;
        va_dcl
#endif
d1440 1
a1440 1
#ifdef __STDC__
a1441 3
#else
	va_start(ap);
#endif
a1452 1
#ifdef __STDC__
a1453 5
#else
error(fmt, va_alist)
	char *fmt;
        va_dcl
#endif
d1457 1
a1457 1
#ifdef __STDC__
a1458 4
#else
	va_start(ap);
#endif

a1481 1
#ifdef __STDC__
a1482 5
#else
fatal(fmt, va_alist)
	char *fmt;
        va_dcl
#endif
d1486 1
a1486 1
#ifdef __STDC__
a1487 4
#else
	va_start(ap);
#endif

a1570 1
#ifdef __STDC__
a1571 5
#else
note(fmt, va_alist)
	char *fmt;
        va_dcl
#endif
d1575 1
a1575 1
#ifdef __STDC__
a1576 3
#else
	va_start(ap);
#endif
@


1.15
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.14 2001/09/05 22:32:42 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.14 2001/09/05 22:32:42 deraadt Exp $";
d59 12
a70 12
static int	chkparent __P((char *));
static void	clean __P((char *));
static void	comment __P((char *));
static void	dospecial __P((char *));
static int	fchog __P((int, char *, char *, char *, int));
static void	hardlink __P((char *));
static void	note __P((const char *, ...));
static void	query __P((char *));
static void	recvf __P((char *, int));
static void	removeit __P((struct stat *));
static int	response __P((void));
static void	rmchk __P((int));
d72 3
a74 3
		    savelink __P((struct stat *));
static void	sendf __P((char *, int));
static int	update __P((char *, int, struct stat *));
@


1.14
log
@make sure that va_start() has matching va_end()
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.13 2001/07/09 07:04:50 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.13 2001/07/09 07:04:50 deraadt Exp $";
d87 1
a87 1
	register char *cp;
d364 1
a364 1
	register struct subcmd *sc;
d602 3
a604 3
	register char *cp, *s;
	register off_t size;
	register time_t mtime;
d739 1
a739 1
	register char *cp = cmd;
d993 1
a993 1
	register char *cp = cmd;
d1049 1
a1049 1
	register char *cp;
d1079 1
a1079 1
	register int i;
d1141 1
a1141 1
	register char *cp, *s;
d1222 1
a1222 1
	register char *cp;
d1225 1
a1225 1
	register struct direct *dp;
d1300 1
a1300 1
	register char *cp;
d1368 1
a1368 1
	register char *cp, *s;
@


1.13
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.12 1999/08/17 09:13:16 millert Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.12 1999/08/17 09:13:16 millert Exp $";
d1542 1
@


1.12
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.11 1998/05/18 19:13:20 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.11 1998/05/18 19:13:20 deraadt Exp $";
d1394 1
a1394 1
		execl(_PATH_BSHELL, "sh", "-c", cmd, 0);
@


1.11
log
@readlink len-1
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.10 1998/04/27 03:13:53 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.10 1998/04/27 03:13:53 deraadt Exp $";
d509 1
a509 1
	if ((f = open(target, O_RDONLY, 0)) < 0) {
@


1.10
log
@Correctly operate on hardlink when source and destination are not on the
same device; freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.9 1997/07/25 21:05:37 mickey Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.9 1997/07/25 21:05:37 mickey Exp $";
d478 1
a478 1
		sizerr = (readlink(target, buf, BUFSIZ) != stb.st_size);
@


1.9
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.8 1997/02/09 19:24:59 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.8 1997/02/09 19:24:59 deraadt Exp $";
d50 1
d247 5
d297 7
a303 1
	if (destdir) {
d311 42
d466 1
a466 12
				/* install link */
				if (*lp->target == 0)
				(void) snprintf(buf, sizeof(buf), "k%o %s %s\n",
					opts, lp->pathname, rname);
				else
				(void) snprintf(buf, sizeof(buf),
					"k%o %s/%s %s\n", opts, lp->target,
					lp->pathname, rname);
				if (debug)
					printf("buf = %s", buf);
				(void) write(rem, buf, strlen(buf));
				(void) response();
d504 1
a504 11
			/* install link */
			if (*lp->target == 0)
			(void) snprintf(buf, sizeof(buf), "k%o %s %s\n", opts,
				lp->pathname, rname);
			else
			(void) snprintf(buf, sizeof(buf), "k%o %s/%s %s\n",
				opts, lp->target, lp->pathname, rname);
			if (debug)
				printf("buf = %s", buf);
			(void) write(rem, buf, strlen(buf));
			(void) response();
d582 1
@


1.8
log
@buf oflow, eivind@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.7 1996/12/22 03:26:00 tholo Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.7 1996/12/22 03:26:00 tholo Exp $";
d1401 1
a1401 1
#if __STDC__
d1408 1
a1408 1
#if __STDC__
d1418 1
a1418 1
#if __STDC__
d1434 1
a1434 1
#if __STDC__
d1444 1
a1444 1
#if __STDC__
d1473 1
a1473 1
#if __STDC__
d1483 1
a1483 1
#if __STDC__
d1571 1
a1571 1
#if __STDC__
d1581 1
a1581 1
#if __STDC__
@


1.7
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.6 1996/08/22 20:33:24 millert Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.6 1996/08/22 20:33:24 millert Exp $";
d128 1
a128 1
			if (exptilde(target, cp) == NULL)
d189 1
a189 1
				if (exptilde(buf, cp) == NULL)
d261 1
a261 1
	rname = exptilde(target, src);
@


1.6
log
@NetBSD changes: use POSIX regex routines and fix more buff oflow
Can't use mkstemp() so go back to mktemp and open(2) with sane flags.
Now uses rcmdsh and fixes memory leak in NetBSD POSIX regex support
(leak fixed by Charles Amos <amos@@umiacs.umd.edu>).
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.5 1996/07/25 05:13:49 millert Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.5 1996/07/25 05:13:49 millert Exp $";
d1355 1
d1357 1
@


1.5
log
@Replaced sprintf() with snprintf() where buffer size is obvious.
Probably just paranoia but why take the chance?  Just four occurences
of sprintf() left.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.4 1996/07/19 21:57:34 millert Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.4 1996/07/19 21:57:34 millert Exp $";
d96 1
a96 1
	(void) snprintf(buf, BUFSIZ, "V%d\n", VERSION);
d99 1
d104 1
d284 1
a284 1
	(void) snprintf(buf, BUFSIZ, "%c%s\n", destdir ? 'T' : 't', dest);
d347 2
a348 1
			(void) snprintf(group, sizeof(group), ":%lu", stb.st_gid);
d365 3
a367 2
		(void) snprintf(buf, BUFSIZ, "D%o %04o 0 0 %s %s %s\n", opts,
			stb.st_mode & 07777, protoname(), protogroup(), rname);
d414 1
a414 1
				(void) snprintf(buf, BUFSIZ, "k%o %s %s\n",
d417 3
a419 2
				(void) snprintf(buf, BUFSIZ, "k%o %s/%s %s\n",
					opts, lp->target, lp->pathname, rname);
d427 1
a427 1
		(void) snprintf(buf, BUFSIZ, "K%o %o %qd %ld %s %s %s\n",
d463 1
a463 1
			(void) snprintf(buf, BUFSIZ, "k%o %s %s\n", opts,
d466 1
a466 1
			(void) snprintf(buf, BUFSIZ, "k%o %s/%s %s\n",
d480 1
a480 1
	(void) snprintf(buf, BUFSIZ, "R%o %o %qd %ld %s %s %s\n", opts,
d518 1
a518 1
		(void) snprintf(buf, BUFSIZ, "SFILE=%s;%s\n", target,
d578 1
a578 1
	(void) snprintf(buf, BUFSIZ, "Q%s\n", rname);
d669 2
a670 1
		(void) sprintf(tp, "/%s", name);
d683 2
a684 2
		(void) snprintf(buf, BUFSIZ, "Y%qd %ld\n", stb.st_size,
		    stb.st_mtime);
a714 3
	cp = cmd;
	opts = 0;
	f = 0;		/*  Initialize, so for links it remains 0.  */
d783 1
a783 1
				(void) snprintf(buf + 1, BUFSIZ - 1,
d803 1
a803 1
		(void) sprintf(tp, "/%s", cp);
d911 1
a911 1
			(void) snprintf(buf + 1, BUFSIZ - 1,
d930 1
a930 1
		if (f == -1)
d945 1
a945 1
		(void) snprintf(buf + 1, BUFSIZ - 1,
d959 1
a959 1
	register char *cp;
d962 1
a962 1
	int opts, exists = 0;
d980 1
a980 1
		(void) sprintf(tp, "/%s", cp);
d1116 1
a1116 1
	(void) snprintf(buf, BUFSIZ, "C%o\n", opts & VERIFY);
d1137 2
a1138 1
			(void) sprintf(tp, "/%s", s);
d1229 1
a1229 1
		(void) snprintf(buf, BUFSIZ, "Q%s\n", dp->d_name);
d1243 1
a1243 1
			(void) snprintf(cp, BUFSIZ - 1,
d1322 1
a1322 1
	(void) snprintf(cp, BUFSIZ - 1, "removed %s\n", target);
d1364 1
a1364 1
	while ((i = read(fd[0], buf, BUFSIZ)) > 0) {
d1584 1
a1584 1
	(void) vsnprintf(buf, BUFSIZ, fmt, ap);
@


1.4
log
@oldrdist now uses rsh so doesn't need to be setuid.
Incorporates some changes from Chris Siebenmann <cks@@utcc.utoronto.ca>
and rdist 6.1.2.  Also fixes at least one possible core dump and
uses strr?chr() instead of r?index().
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.3 1996/06/26 05:37:41 deraadt Exp $	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.3 1996/06/26 05:37:41 deraadt Exp $";
d96 1
a96 1
	(void) sprintf(buf, "V%d\n", VERSION);
d282 1
a282 1
	(void) sprintf(buf, "%c%s\n", destdir ? 'T' : 't', dest);
d338 1
a338 1
			(void)sprintf(user, ":%lu", stb.st_uid);
d345 1
a345 1
			(void)sprintf(group, ":%lu", stb.st_gid);
d362 1
a362 1
		(void) sprintf(buf, "D%o %04o 0 0 %s %s %s\n", opts,
d410 2
a411 2
				(void) sprintf(buf, "k%o %s %s\n", opts,
					lp->pathname, rname);
d413 2
a414 2
				(void) sprintf(buf, "k%o %s/%s %s\n", opts,
					lp->target, lp->pathname, rname);
d422 2
a423 2
		(void) sprintf(buf, "K%o %o %qd %ld %s %s %s\n", opts,
			stb.st_mode & 07777, stb.st_size, stb.st_mtime,
d458 1
a458 1
			(void) sprintf(buf, "k%o %s %s\n", opts,
d461 2
a462 2
			(void) sprintf(buf, "k%o %s/%s %s\n", opts,
				lp->target, lp->pathname, rname);
d475 1
a475 1
	(void) sprintf(buf, "R%o %o %qd %ld %s %s %s\n", opts,
d513 2
a514 1
		(void) sprintf(buf, "SFILE=%s;%s\n", target, sc->sc_name);
d573 1
a573 1
	(void) sprintf(buf, "Q%s\n", rname);
d677 1
a677 1
		(void) sprintf(buf, "Y%qd %ld\n", stb.st_size,
d780 1
a780 1
				(void) sprintf(buf + 1,
d805 1
a805 1
		(void) sprintf(new, "/%s", tempname);
d808 1
a808 1
		(void) sprintf(new, "%s/%s", target, tempname);
d908 2
a909 1
			(void) sprintf(buf + 1, "need to update: %s\n",target);
d942 2
a943 1
		(void) sprintf(buf + 1, "updated %s\n", target);
d1113 1
a1113 1
	(void) sprintf(buf, "C%o\n", opts & VERIFY);
d1225 1
a1225 1
		(void) sprintf(buf, "Q%s\n", dp->d_name);
d1239 2
a1240 1
			(void) sprintf(cp, "need to remove: %s\n", target);
d1318 1
a1318 1
	(void) sprintf(cp, "removed %s\n", target);
d1360 1
a1360 1
	while ((i = read(fd[0], buf, sizeof(buf))) > 0) {
d1419 1
a1419 1
		(void)vprintf(fmt, ap);
d1423 1
a1423 1
		(void)vfprintf(fp, fmt, ap);
d1448 2
a1449 2
		(void)fprintf(fp, "%crdist: ", 0x01);
		(void)vfprintf(fp, fmt, ap);
d1454 2
a1455 2
		(void)fprintf(stderr, "rdist: ");
		(void)vfprintf(stderr, fmt, ap);
d1459 2
a1460 2
		(void)fprintf(lfp, "rdist: ");
		(void)vfprintf(lfp, fmt, ap);
d1487 2
a1488 2
		(void)fprintf(fp, "%crdist: ", 0x02);
		(void)vfprintf(fp, fmt, ap);
d1493 2
a1494 2
		(void)fprintf(stderr, "rdist: ");
		(void)vfprintf(stderr, fmt, ap);
d1498 2
a1499 2
		(void)fprintf(lfp, "rdist: ");
		(void)vfprintf(lfp, fmt, ap);
d1580 1
a1580 1
	(void)vsnprintf(buf, sizeof(buf), fmt, ap);
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
static char *rcsid = "$OpenBSD: server.c,v 1.2 1996/05/28 12:31:57 deraadt Exp $";
d99 5
d275 1
a275 5
		rname = rindex(target, '/');
		if (rname == NULL)
			rname = target;
		else
			rname++;
d800 1
a800 1
	cp = rindex(target, '/');
d1012 1
a1012 1
	cp = rindex(name, '/');
d1346 1
d1349 1
a1440 2
	if (!fp && !(fp = fdopen(rem, "w")))
		return;
d1442 2
@


1.2
log
@sync
@
text
@d1 2
d38 1
a38 1
static char *rcsid = "$Id: server.c,v 1.1 1996/02/03 12:12:03 dm Exp $";
@


1.1
log
@rdist 6.1.1
@
text
@d36 1
a36 1
static char *rcsid = "$Id: server.c,v 1.2 1995/12/15 08:58:45 deraadt Exp $";
d695 2
a696 2
	register char *cp;
	int f, mode, opts, wrerr, olderrno;
d922 1
a922 1
		if (f)		/*  Don't close if f hasn't been opened.  */
a954 2
	cp = cmd;
	opts = 0;
@
