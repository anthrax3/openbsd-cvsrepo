head	1.37;
access;
symbols
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.4
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.6
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.14
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.12
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.10
	OPENBSD_5_0:1.32.0.8
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.6
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.30.0.10
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.6
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.4
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.8
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.6
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	0Dp7Dy9FuNZesYo2;

1.36
date	2015.03.15.00.41.28;	author millert;	state Exp;
branches;
next	1.35;
commitid	IbVxlqGw2UipKdDr;

1.35
date	2015.01.16.06.40.13;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Uu5nFG3wCl0LACBb;

1.34
date	2013.11.26.19.25.39;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2013.04.19.14.35.40;	author okan;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.27.23.59.46;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.11.15.50.34;	author sobrado;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.29;

1.29
date	2007.03.21.03.31.19;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.27.15.51.17;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.23.15.55.17;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.23.15.26.52;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.23.15.18.59;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2006.08.14.15.49.28;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.05.07.18.43;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.08.19.08.03;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.09.23.47.32;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.10.22.20.53;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.03.02.56.21;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.13.09.09.36;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.21.27.56;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.07.07.17.38;	author mpech;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.09.07.04.56;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.05.21.53.30;	author pjanzen;	state Exp;
branches;
next	1.12;

1.12
date	99.06.03.20.20.26;	author marc;	state Exp;
branches;
next	1.11;

1.11
date	99.02.12.01.21.07;	author marc;	state Exp;
branches;
next	1.10;

1.10
date	98.07.08.21.39.08;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.02.07.02.47.21;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.08.06.23.47.09;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.29.16.48.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.29.02.08.40;	author bitblt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.17.07.13.48;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.43.31;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.12.06.02.09.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.42.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.32;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@/*	$OpenBSD: vacation.c,v 1.36 2015/03/15 00:41:28 millert Exp $	*/
/*	$NetBSD: vacation.c,v 1.7 1995/04/29 05:58:27 cgd Exp $	*/

/*
 * Copyright (c) 1983, 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
**  Vacation
**  Copyright (c) 1983  Eric P. Allman
**  Berkeley, California
*/

#include <sys/stat.h>
#include <fcntl.h>
#include <pwd.h>
#include <db.h>
#include <time.h>
#include <syslog.h>
#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <paths.h>

/*
 *  VACATION -- return a message to the sender when on vacation.
 *
 *	This program is invoked as a message receiver.  It returns a
 *	message specified by the user to whomever sent the mail, taking
 *	care not to return a message too often to prevent "I am on
 *	vacation" loops.
 */

#define	MAXLINE	1024			/* max line from mail header */
#define	VDB	".vacation.db"		/* dbm's database */
#define	VMSG	".vacation.msg"		/* vacation message */

typedef struct alias {
	struct alias *next;
	char *name;
} ALIAS;
ALIAS *names;

DB *db;
char from[MAXLINE];
char subj[MAXLINE];

int junkmail(void);
int nsearch(char *, char *);
void readheaders(void);
int recent(void);
void sendmessage(char *);
void setinterval(time_t);
void setreply(void);
void usage(void);

#define	SECSPERDAY	(24 * 60 * 60)

int
main(int argc, char *argv[])
{
	int ch, iflag, flags;
	struct passwd *pw;
	time_t interval;
	struct stat sb;
	ALIAS *cur;

	opterr = iflag = 0;
	interval = -1;
	while ((ch = getopt(argc, argv, "a:Iir:")) != -1)
		switch ((char)ch) {
		case 'a':			/* alias */
			if (!(cur = malloc(sizeof(ALIAS))))
				break;
			cur->name = optarg;
			cur->next = names;
			names = cur;
			break;
		case 'I':			/* backward compatible */
		case 'i':			/* init the database */
			iflag = 1;
			break;
		case 'r':
			if (isdigit((unsigned char)*optarg)) {
				interval = atol(optarg) * SECSPERDAY;
				if (interval < 0)
					usage();
			} else
				interval = 0;	/* one time only */
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (argc != 1) {
		if (!iflag)
			usage();
		if (!(pw = getpwuid(getuid()))) {
			syslog(LOG_ERR,
			    "no such user uid %u.", getuid());
			exit(1);
		}
	} else if (!(pw = getpwnam(*argv))) {
		syslog(LOG_ERR, "no such user %s.", *argv);
		exit(1);
	}
	if (chdir(pw->pw_dir)) {
		syslog(LOG_NOTICE,
		    "no such directory %s.", pw->pw_dir);
		exit(1);
	}

	/*
	 * dbopen(3) can not deal with a zero-length file w/o O_TRUNC.
	 */
	if (iflag == 1 || (stat(VDB, &sb) == 0 && sb.st_size == (off_t)0))
		flags = O_CREAT|O_RDWR|O_TRUNC;
	else
		flags = O_CREAT|O_RDWR;

	db = dbopen(VDB, flags, S_IRUSR|S_IWUSR, DB_HASH, NULL);
	if (!db) {
		syslog(LOG_NOTICE, "%s: %m", VDB);
		exit(1);
	}

	if (interval != -1)
		setinterval(interval);

	if (iflag) {
		(void)(db->close)(db);
		exit(0);
	}

	if (!(cur = malloc(sizeof(ALIAS))))
		exit(1);
	cur->name = pw->pw_name;
	cur->next = names;
	names = cur;

	readheaders();
	if (!recent()) {
		setreply();
		(void)(db->close)(db);
		sendmessage(pw->pw_name);
	} else
		(void)(db->close)(db);
	exit(0);
	/* NOTREACHED */
}

/*
 * readheaders --
 *	read mail headers
 */
void
readheaders(void)
{
	char buf[MAXLINE], *p;
	int tome, cont;
	ALIAS *cur;

	cont = tome = 0;
	while (fgets(buf, sizeof(buf), stdin) && *buf != '\n')
		switch (*buf) {
		case 'A':		/* "Auto-Submitted:" */
		case 'a':
			cont = 0;
			if (strncasecmp(buf, "Auto-Submitted:", 15))
				break;
			for (p = buf + 15; isspace((unsigned char)*p); ++p)
				;
			/*
			 * RFC 3834 section 2:
			 * Automatic responses SHOULD NOT be issued in response
			 * to any message which contains an Auto-Submitted
			 * header where the field has any value other than "no".
			 */
			if ((p[0] == 'n' || p[0] == 'N') &&
			    (p[1] == 'o' || p[1] == 'O')) {
				for (p += 2; isspace((unsigned char)*p); ++p)
					;
				if (*p == '\0')
					break;	/* Auto-Submitted: no */
			}
			exit(0);
		case 'F':		/* "From " */
		case 'f':
			cont = 0;
			if (!strncasecmp(buf, "From ", 5)) {
				for (p = buf + 5; *p && *p != ' '; ++p)
					;
				*p = '\0';
				(void)strlcpy(from, buf + 5, sizeof(from));
				from[strcspn(from, "\n")] = '\0';
				if (junkmail())
					exit(0);
			}
			break;
		case 'L':		/* "List-Id:" */
		case 'l':
			cont = 0;
			/*
			 * If present (with any value), message is coming from a
			 * mailing list, cf. RFC2919.
			 */
			if (strncasecmp(buf, "List-Id:", 8) == 0)
				exit(0);
			break;
		case 'R':		/* "Return-Path:" */
		case 'r':
			cont = 0;
			if (strncasecmp(buf, "Return-Path:",
			    sizeof("Return-Path:")-1) ||
			    (buf[12] != ' ' && buf[12] != '\t'))
				break;
			for (p = buf + 12; isspace((unsigned char)*p); ++p)
				;
			if (strlcpy(from, p, sizeof(from)) >= sizeof(from)) {
				syslog(LOG_NOTICE,
				    "Return-Path %s exceeds limits", p);
				exit(1);
			}
			from[strcspn(from, "\n")] = '\0';
			if (junkmail())
				exit(0);
			break;
		case 'P':		/* "Precedence:" */
		case 'p':
			cont = 0;
			if (strncasecmp(buf, "Precedence:", 11))
				break;
			for (p = buf + 11; isspace((unsigned char)*p); ++p)
				;
			if (!strncasecmp(p, "junk", 4) ||
			    !strncasecmp(p, "bulk", 4) ||
			    !strncasecmp(p, "list", 4))
				exit(0);
			break;
		case 'S':		/* Subject: */
		case 's':
			cont = 0;
			if (strncasecmp(buf, "Subject:",
			    sizeof("Subject:")-1) ||
			    (buf[8] != ' ' && buf[8] != '\t'))
				break;
			for (p = buf + 8; isspace((unsigned char)*p); ++p)
				;
			if (strlcpy(subj, p, sizeof(subj)) >= sizeof(subj)) {
				syslog(LOG_NOTICE,
				    "Subject %s exceeds limits", p);
				exit(1);
			}
			subj[strcspn(subj, "\n")] = '\0';
			break;
		case 'C':		/* "Cc:" */
		case 'c':
			if (strncasecmp(buf, "Cc:", 3))
				break;
			cont = 1;
			goto findme;
		case 'T':		/* "To:" */
		case 't':
			if (strncasecmp(buf, "To:", 3))
				break;
			cont = 1;
			goto findme;
		default:
			if (!isspace((unsigned char)*buf) || !cont || tome) {
				cont = 0;
				break;
			}
findme:			for (cur = names; !tome && cur; cur = cur->next)
				tome += nsearch(cur->name, buf);
		}
	if (!tome)
		exit(0);
	if (!*from) {
		syslog(LOG_NOTICE,
		    "no initial \"From\" or \"Return-Path\"line.");
		exit(1);
	}
}

/*
 * nsearch --
 *	do a nice, slow, search of a string for a substring.
 */
int
nsearch(char *name, char *str)
{
	int len;

	for (len = strlen(name); *str; ++str)
		if (!strncasecmp(name, str, len))
			return(1);
	return(0);
}

/*
 * junkmail --
 *	read the header and return if automagic/junk/bulk/list mail
 */
int
junkmail(void)
{
	static struct ignore {
		char	*name;
		int	len;
	} ignore[] = {
		{ "-request", 8 },
		{ "postmaster", 10 },
		{ "uucp", 4 },
		{ "mailer-daemon", 13 },
		{ "mailer", 6 },
		{ "-relay", 6 },
		{ NULL, 0 }
	};
	struct ignore *cur;
	int len;
	char *p;

	/*
	 * This is mildly amusing, and I'm not positive it's right; trying
	 * to find the "real" name of the sender, assuming that addresses
	 * will be some variant of:
	 *
	 * From site!site!SENDER%site.domain%site.domain@@site.domain
	 */
	if (!(p = strchr(from, '%'))) {
		if (!(p = strchr(from, '@@'))) {
			if ((p = strrchr(from, '!')))
				++p;
			else
				p = from;
			for (; *p; ++p)
				;
		}
	}
	len = p - from;
	for (cur = ignore; cur->name; ++cur)
		if (len >= cur->len &&
		    !strncasecmp(cur->name, p - cur->len, cur->len))
			return(1);
	return(0);
}

#define	VIT	"__VACATION__INTERVAL__TIMER__"

/*
 * recent --
 *	find out if user has gotten a vacation message recently.
 *	use bcopy for machines with alignment restrictions
 */
int
recent(void)
{
	time_t then, next;
	DBT key, data;

	/* get interval time */
	key.data = VIT;
	key.size = sizeof(VIT);
	if ((db->get)(db, &key, &data, 0))
		next = SECSPERDAY * 7;
	else
		bcopy(data.data, &next, sizeof(next));

	/* get record for this address */
	key.data = from;
	key.size = strlen(from);
	if (!(db->get)(db, &key, &data, 0)) {
		bcopy(data.data, &then, sizeof(then));
		if (next == 0 ||
		    then + next > time(NULL))
			return(1);
	}
	return(0);
}

/*
 * setinterval --
 *	store the reply interval
 */
void
setinterval(time_t interval)
{
	DBT key, data;

	key.data = VIT;
	key.size = sizeof(VIT);
	data.data = &interval;
	data.size = sizeof(interval);
	(void)(db->put)(db, &key, &data, 0);
}

/*
 * setreply --
 *	store that this user knows about the vacation.
 */
void
setreply(void)
{
	DBT key, data;
	time_t now;

	key.data = from;
	key.size = strlen(from);
	(void)time(&now);
	data.data = &now;
	data.size = sizeof(now);
	(void)(db->put)(db, &key, &data, 0);
}

/*
 * sendmessage --
 *	exec sendmail to send the vacation file to sender
 */
void
sendmessage(char *myname)
{
	char buf[MAXLINE];
	FILE *mfp, *sfp;
	int pvect[2], i;

	mfp = fopen(VMSG, "r");
	if (mfp == NULL) {
		syslog(LOG_NOTICE, "no ~%s/%s file.", myname, VMSG);
		exit(1);
	}
	if (pipe(pvect) < 0) {
		syslog(LOG_ERR, "pipe: %m");
		exit(1);
	}
	i = vfork();
	if (i < 0) {
		syslog(LOG_ERR, "fork: %m");
		exit(1);
	}
	if (i == 0) {
		dup2(pvect[0], 0);
		close(pvect[0]);
		close(pvect[1]);
		close(fileno(mfp));
		execl(_PATH_SENDMAIL, "sendmail", "-f", myname, "--",
		    from, (char *)NULL);
		syslog(LOG_ERR, "can't exec %s: %m", _PATH_SENDMAIL);
		_exit(1);
	}
	close(pvect[0]);
	sfp = fdopen(pvect[1], "w");
	if (sfp == NULL) {
		/* XXX could not fdopen; likely out of memory */
		fclose(mfp);
		close(pvect[1]);
		return;
	}
	fprintf(sfp, "To: %s\n", from);
	fputs("Auto-Submitted: auto-replied\n", sfp);
	while (fgets(buf, sizeof buf, mfp)) {
		char *s = strstr(buf, "$SUBJECT");

		if (s) {
			*s = 0;
			fputs(buf, sfp);
			fputs(subj, sfp);
			fputs(s+8, sfp);
		} else {
			fputs(buf, sfp);
		}
	}
	fclose(mfp);
	fclose(sfp);
}

void
usage(void)
{
	syslog(LOG_NOTICE, "uid %u: usage: vacation [-i] [-a alias] login",
	    getuid());
	exit(1);
}
@


1.36
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.35 2015/01/16 06:40:13 deraadt Exp $	*/
d101 1
a101 1
			if (!(cur = (ALIAS *)malloc((u_int)sizeof(ALIAS))))
d165 1
a165 1
	if (!(cur = malloc((u_int)sizeof(ALIAS))))
@


1.35
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.34 2013/11/26 19:25:39 deraadt Exp $	*/
a44 1
#include <tzfile.h>
d85 2
d395 1
a395 1
		next = SECSPERDAY * DAYSPERWEEK;
@


1.34
log
@unsigned char casts for ctype
ok okan
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.33 2013/04/19 14:35:40 okan Exp $	*/
a38 1
#include <sys/param.h>
@


1.33
log
@match behavior of current sendmail-based vacation: eliminate the concept that
an interval (-r) of 0 indicates sending a reply to every message (per sender),
but rather match the 'non-numeric' case where only one reply will be sent (per
sender).  default remains unchanged.  vacation database should be reinitalized
sometime before 2038.

removes the need for time_t casts.

discussed with deraadt; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.32 2009/10/27 23:59:46 deraadt Exp $	*/
d112 1
a112 1
			if (isdigit(*optarg)) {
d201 1
a201 1
			for (p = buf + 15; isspace(*p); ++p)
d211 1
a211 1
				for (p += 2; isspace(*p); ++p)
d247 1
a247 1
			for (p = buf + 12; isspace(*p); ++p)
d263 1
a263 1
			for (p = buf + 11; isspace(*p); ++p)
d277 1
a277 1
			for (p = buf + 8; isspace(*p); ++p)
d299 1
a299 1
			if (!isspace(*buf) || !cont || tome) {
@


1.32
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.31 2009/10/11 15:50:34 sobrado Exp $	*/
d117 1
a117 1
				interval = (time_t)LONG_MAX;	/* XXX */
d404 1
a404 1
		if (next == (time_t)LONG_MAX ||			/* XXX */
@


1.31
log
@makes source code fit on a 80-column display, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.30 2007/09/11 15:47:17 gilles Exp $	*/
a31 13

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1983, 1987, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)vacation.c	8.2 (Berkeley) 1/26/94";
#endif
static char rcsid[] = "$OpenBSD: vacation.c,v 1.30 2007/09/11 15:47:17 gilles Exp $";
#endif /* not lint */
@


1.30
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.29 2007/03/21 03:31:19 tedu Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.29 2007/03/21 03:31:19 tedu Exp $";
d322 2
a323 1
		syslog(LOG_NOTICE, "no initial \"From\" or \"Return-Path\"line.");
@


1.29
log
@remove extra *p tests, from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.28 2007/02/27 15:51:17 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.28 2007/02/27 15:51:17 deraadt Exp $";
d238 1
a238 2
				if ((p = strchr(from, '\n')))
					*p = '\0';
d267 1
a267 2
			if ((p = strchr(from, '\n')))
				*p = '\0';
d297 1
a297 2
			if ((p = strchr(subj, '\n')))
				*p = '\0';
@


1.28
log
@support rfc2919 List-Id, from Tamas TEVESZ, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.27 2007/02/23 15:55:17 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.27 2007/02/23 15:55:17 millert Exp $";
d214 1
a214 1
			for (p = buf + 15; *p && isspace(*p); ++p)
d224 1
a224 1
				for (p += 2; *p && isspace(*p); ++p)
d261 1
a261 1
			for (p = buf + 12; *p && isspace(*p); ++p)
d278 1
a278 1
			for (p = buf + 11; *p && isspace(*p); ++p)
d292 1
a292 1
			for (p = buf + 8; *p && isspace(*p); ++p)
@


1.27
log
@Ignore trailing space after "Auto-Submitted: no"
Remove an unneeded check for !*p
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.26 2007/02/23 15:26:52 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.26 2007/02/23 15:26:52 deraadt Exp $";
d243 10
@


1.26
log
@add back in character count check by Tamas TEVESZ, though this does
not truly handle trailing whitespace on the line.  but that is handled
very weakly for other patterns, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.25 2007/02/23 15:18:59 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.25 2007/02/23 15:18:59 deraadt Exp $";
d222 8
a229 5
			if (!*p)
				exit(0);
			if (strlen(p) != 3 || strncasecmp(p, "no", 2))
				exit(0);
			break;
a269 2
			if (!*p)
				break;
@


1.25
log
@support for "Auto-Submitted: no" from Tamas TEVESZ; small tweak by millert,
ok millert (man page update being done by jmc)
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.24 2006/08/14 15:49:28 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.24 2006/08/14 15:49:28 millert Exp $";
d224 1
a224 1
			if (strncasecmp(p, "no", 2))
@


1.24
log
@Add Auto-Submitted header in generated mail as per RFC 3834.
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.23 2004/04/05 07:18:43 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.23 2004/04/05 07:18:43 deraadt Exp $";
d209 18
d263 1
a263 5
			if (strncasecmp(buf, "Precedence", 10) ||
			    (buf[10] != ':' && buf[10] != ' ' &&
			    buf[10] != '\t'))
				break;
			if (!(p = strchr(buf, ':')))
d265 1
a265 1
			while (*++p && isspace(*p))
@


1.23
log
@cope with fdopen failure better
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.22 2004/03/08 19:08:03 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.22 2004/03/08 19:08:03 deraadt Exp $";
d479 1
@


1.22
log
@knf.  there are some scary XXX in here which need fixing
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.21 2003/08/09 23:47:32 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.21 2003/08/09 23:47:32 millert Exp $";
a131 1
		case '?':
d472 6
@


1.21
log
@Fix off by one in strlcpy() check; Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.20 2003/06/10 22:20:53 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.20 2003/06/10 22:20:53 deraadt Exp $";
d103 1
d105 1
a107 2
	time_t interval;
	int ch, iflag, flags;
d112 1
a112 1
		switch((char)ch) {
d129 1
a129 2
			}
			else
d147 1
a147 2
	}
	else if (!(pw = getpwnam(*argv))) {
d164 1
a164 1
		
d190 1
a190 2
	}
	else
d203 2
a205 3
	char *p;
	int tome, cont;
	char buf[MAXLINE];
d209 1
a209 1
		switch(*buf) {
d228 1
a228 1
					sizeof("Return-Path:")-1) ||
d235 1
a235 1
				       "Return-Path %s exceeds limits", p);
d252 2
a253 1
			while (*++p && isspace(*p));
d265 1
a265 1
					sizeof("Subject:")-1) ||
d272 1
a272 1
				       "Subject %s exceeds limits", p);
d351 1
a351 1
	if (!(p = strchr(from, '%')))
d360 1
d379 1
a380 1
	time_t then, next;
d443 1
d445 1
a445 3
	int i;
	int pvect[2];
	char buf[MAXLINE];
d476 2
a477 1
		if ( s ) {
@


1.20
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.19 2003/06/03 02:56:21 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.19 2003/06/03 02:56:21 millert Exp $";
d221 1
a221 1
				(void)strlcpy(from, buf + 5, sizeof from);
d237 1
a237 1
			if (strlcpy(from, p, sizeof from ) > sizeof from) {
d273 1
a273 1
			if (strlcpy(subj, p, sizeof subj ) > sizeof subj) {
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.18 2003/03/13 09:09:36 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.18 2003/03/13 09:09:36 deraadt Exp $";
d101 1
a101 3
main(argc, argv)
	int argc;
	char **argv;
d204 1
a204 1
readheaders()
d314 1
a314 2
nsearch(name, str)
	char *name, *str;
d329 1
a329 1
junkmail()
d379 1
a379 1
recent()
d409 1
a409 2
setinterval(interval)
	time_t interval;
d425 1
a425 1
setreply()
d443 1
a443 2
sendmessage(myname)
	char *myname;
d493 1
a493 1
usage()
@


1.18
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.17 2002/02/16 21:27:56 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.17 2002/02/16 21:27:56 millert Exp $";
@


1.17
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.16 2002/02/07 07:17:38 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.16 2002/02/07 07:17:38 mpech Exp $";
d227 1
a227 1
				(void)strcpy(from, buf + 5);
@


1.16
log
@I want my vacation to be case nonsensitive in readheaders().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.15 2001/11/19 19:02:17 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.15 2001/11/19 19:02:17 mpech Exp $";
d95 8
a102 8
int junkmail __P((void));
int nsearch __P((char *, char *));
void readheaders __P((void));
int recent __P((void));
void sendmessage __P((char *));
void setinterval __P((time_t));
void setreply __P((void));
void usage __P((void));
@


1.15
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.14 2001/07/09 07:04:56 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.14 2001/07/09 07:04:56 deraadt Exp $";
d221 1
d223 1
a223 1
			if (!strncmp(buf, "From ", 5)) {
d235 1
d254 1
d271 1
d288 2
a289 1
			if (strncmp(buf, "Cc:", 3))
d294 2
a295 1
			if (strncmp(buf, "To:", 3))
@


1.14
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.13 2000/08/05 21:53:30 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.13 2000/08/05 21:53:30 pjanzen Exp $";
d212 2
a213 2
	register ALIAS *cur;
	register char *p;
d315 1
a315 1
	register char *name, *str;
d317 1
a317 1
	register int len;
d344 3
a346 3
	register struct ignore *cur;
	register int len;
	register char *p;
@


1.13
log
@Fix name comparison bug found by Thilo Manske in NetBSD PR 10638.  While I'm
at it, do some -Wall fixing.
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.12 1999/06/03 20:20:26 marc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.12 1999/06/03 20:20:26 marc Exp $";
d473 1
a473 1
		    from, NULL);
@


1.12
log
@add support for including the subject of a message being replied to
in the reply; OK'd by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.11 1999/02/12 01:21:07 marc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.11 1999/02/12 01:21:07 marc Exp $";
d227 1
a227 1
				if (p = strchr(from, '\n'))
d237 1
a237 1
			    buf[12] != ' ' && buf[12] != '\t')
d246 1
a246 1
			if (p = strchr(from, '\n'))
d254 2
a255 1
			    buf[10] != ':' && buf[10] != ' ' && buf[10] != '\t')
d271 1
a271 1
			    buf[8] != ' ' && buf[8] != '\t')
d280 1
a280 1
			if (p = strchr(subj, '\n'))
d320 1
a320 1
		if (*str == *name && !strncasecmp(name, str, len))
d336 7
a342 3
		"-request", 8,		"postmaster", 10,	"uucp", 4,
		"mailer-daemon", 13,	"mailer", 6,		"-relay", 6,
		NULL, NULL,
d357 1
a357 1
			if (p = strrchr(from, '!'))
@


1.11
log
@parse "Return-Path:" headers in addition to UUCP style
"From " lines; remove redundant program name from log messages
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.10 1998/07/08 21:39:08 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.10 1998/07/08 21:39:08 deraadt Exp $";
d93 1
d223 2
a224 1
				for (p = buf + 5; *p && *p != ' '; ++p);
d239 2
a240 1
			for (p = buf + 12; *p && isspace(*p); ++p);
d266 16
d356 2
a357 1
			for (; *p; ++p);
d475 11
a485 2
	while (fgets(buf, sizeof buf, mfp))
		fputs(buf, sfp);
@


1.10
log
@close(fileno()) inside vfork(); cgd
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.9 1998/02/07 02:47:21 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.9 1998/02/07 02:47:21 millert Exp $";
d150 1
a150 1
			    "vacation: no such user uid %u.", getuid());
d155 1
a155 1
		syslog(LOG_ERR, "vacation: no such user %s.", *argv);
d160 1
a160 1
		    "vacation: no such directory %s.", pw->pw_dir);
d174 1
a174 1
		syslog(LOG_NOTICE, "vacation: %s: %m", VDB);
d231 17
d284 1
a284 1
		syslog(LOG_NOTICE, "vacation: no initial \"From\" line.");
d430 1
a430 1
		syslog(LOG_NOTICE, "vacation: no ~%s/%s file.", myname, VMSG);
d434 1
a434 1
		syslog(LOG_ERR, "vacation: pipe: %m");
d439 1
a439 1
		syslog(LOG_ERR, "vacation: fork: %m");
d449 1
a449 1
		syslog(LOG_ERR, "vacation: can't exec %s: %m", _PATH_SENDMAIL);
@


1.9
log
@o Don't put newlines in syslog() messages and use %m, not strerror()
o If .vacation.db is size 0, dbopen() with O_TRUNC (otherwise vacation
  will do exit(1) and sendmail will be unhappy.  dbopen() should probably
  deal with zero-length files sanely.
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.8 1997/08/06 23:47:09 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.8 1997/08/06 23:47:09 deraadt Exp $";
d429 1
a429 1
		fclose(mfp);
@


1.8
log
@use -- instead; eric
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.7 1997/07/29 16:48:13 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.7 1997/07/29 16:48:13 deraadt Exp $";
a107 2
	extern int optind, opterr;
	extern char *optarg;
d109 1
d112 1
a112 1
	int ch, iflag;
d150 1
a150 1
			    "vacation: no such user uid %u.\n", getuid());
d155 1
a155 1
		syslog(LOG_ERR, "vacation: no such user %s.\n", *argv);
d160 1
a160 1
		    "vacation: no such directory %s.\n", pw->pw_dir);
d164 9
a172 2
	db = dbopen(VDB, O_CREAT|O_RDWR | (iflag ? O_TRUNC : 0),
	    S_IRUSR|S_IWUSR, DB_HASH, NULL);
d174 1
a174 1
		syslog(LOG_NOTICE, "vacation: %s: %s\n", VDB, strerror(errno));
d267 1
a267 1
		syslog(LOG_NOTICE, "vacation: no initial \"From\" line.\n");
d413 1
a413 1
		syslog(LOG_NOTICE, "vacation: no ~%s/%s file.\n", myname, VMSG);
d417 1
a417 1
		syslog(LOG_ERR, "vacation: pipe: %s", strerror(errno));
d422 1
a422 1
		syslog(LOG_ERR, "vacation: fork: %s", strerror(errno));
d432 1
a432 2
		syslog(LOG_ERR, "vacation: can't exec %s: %s",
			_PATH_SENDMAIL, strerror(errno));
d447 1
a447 1
	syslog(LOG_NOTICE, "uid %u: usage: vacation [-i] [-a alias] login\n",
@


1.7
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.6 1997/07/29 02:08:40 bitblt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.6 1997/07/29 02:08:40 bitblt Exp $";
d424 2
a425 1
		execl(_PATH_SENDMAIL, "sendmail", "-t", NULL);
a432 1
	fprintf(sfp, "From: %s\n", myname);
@


1.6
log
@Theo really wanted a hole in Allman code.  Now he's got one.
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.5 1997/01/17 07:13:48 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.5 1997/01/17 07:13:48 millert Exp $";
d432 1
a432 1
	fprintf(sfp, "From: %s\n, myname);
@


1.5
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.4 1997/01/15 23:43:31 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.4 1997/01/15 23:43:31 millert Exp $";
d424 1
a424 1
		execl(_PATH_SENDMAIL, "sendmail", "-f", myname, from, NULL);
d432 1
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.3 1996/12/06 02:09:22 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.3 1996/12/06 02:09:22 deraadt Exp $";
d219 1
a219 1
				if (p = index(from, '\n'))
d230 1
a230 1
			if (!(p = index(buf, ':')))
d308 3
a310 3
	if (!(p = index(from, '%')))
		if (!(p = index(from, '@@'))) {
			if (p = rindex(from, '!'))
@


1.3
log
@vfork w/ exit botch
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.2 1996/06/26 05:42:27 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.2 1996/06/26 05:42:27 deraadt Exp $";
d117 1
a117 1
	while ((ch = getopt(argc, argv, "a:Iir:")) != EOF)
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: vacation.c,v 1.7 1995/04/29 05:58:27 cgd Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: vacation.c,v 1.7 1995/04/29 05:58:27 cgd Exp $";
d427 1
a427 1
		exit(1);
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: vacation.c,v 1.7 1995/04/29 05:58:27 cgd Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
