head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.8
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.22.0.6
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.21.0.16
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.14
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.12
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.10
	OPENBSD_5_0:1.21.0.8
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.12
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.8
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.6
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.4
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.18.0.14
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.12
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.10
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.8
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.6
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.13.0.4
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.12.0.6
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.6
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	sbrB3Q5CNxcwZpfU;

1.26
date	2015.10.07.04.00.45;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	9IXhboLOqg3h1HkT;

1.25
date	2015.07.21.04.42.59;	author jasper;	state Exp;
branches;
next	1.24;
commitid	SldmfDSSVSAlHijO;

1.24
date	2015.01.16.06.40.08;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Uu5nFG3wCl0LACBb;

1.23
date	2014.10.11.04.31.55;	author doug;	state Exp;
branches;
next	1.22;
commitid	SXVdfbKycyZ10UOD;

1.22
date	2013.11.15.22.20.04;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.27.23.59.39;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.29.18.29.26;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.23.19.21.24;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.28.19.53.23;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.12.10.38.44;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.10.22.20.47;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.03.02.56.09;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.47;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.29.01.57.59;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.07.23.23.37.34;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	98.11.16.06.09.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.08.25.05.31.10;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.24.01.35.30;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.23.02.59.33;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.04.09.16.42.25;	author michaels;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.42.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.08.12.16.37.00;	author michaels;	state Exp;
branches;
next	1.4;

1.4
date	96.08.12.02.31.53;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.34.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.22.19.02.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Change all tame callers to namechange to pledge(2).
@
text
@/* $OpenBSD: join.c,v 1.26 2015/10/07 04:00:45 deraadt Exp $	*/

/*-
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Steve Hayman of the Computer Science Department, Indiana University,
 * Michiro Hikida and David Goodenough.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

/*
 * There's a structure per input file which encapsulates the state of the
 * file.  We repeatedly read lines from each file until we've read in all
 * the consecutive lines from the file with a common join field.  Then we
 * compare the set of lines with an equivalent set from the other file.
 */
typedef struct {
	char *line;			/* line */
	u_long linealloc;		/* line allocated count */
	char **fields;			/* line field(s) */
	u_long fieldcnt;		/* line field(s) count */
	u_long fieldalloc;		/* line field(s) allocated count */
	u_long cfieldc;			/* current field count */
	long	 fpos;			/* fpos of start of field */
} LINE;

typedef struct {
	FILE *fp;			/* file descriptor */
	u_long joinf;			/* join field (-1, -2, -j) */
	int unpair;			/* output unpairable lines (-a) */
	u_long number;			/* 1 for file 1, 2 for file 2 */
	LINE *set;			/* set of lines with same field */
	int pushbool;			/* if pushback is set */
	u_long pushback;		/* line on the stack */
	u_long setcnt;			/* set count */
	u_long setalloc;		/* set allocated count */
	u_long setusedc;		/* sets used  */
} INPUT;
INPUT input1 = { NULL, 0, 0, 1, NULL, 0, 0, 0, 0, 0 },
      input2 = { NULL, 0, 0, 2, NULL, 0, 0, 0, 0, 0 };

typedef struct {
	u_long	filenum;	/* file number */
	u_long	fieldno;	/* field number */
} OLIST;
OLIST *olist;			/* output field list */
u_long olistcnt;		/* output field list count */
u_long olistalloc;		/* output field allocated count */

int joinout = 1;		/* show lines with matched join fields (-v) */
int needsep;			/* need separator character */
int spans = 1;			/* span multiple delimiters (-t) */
char *empty;			/* empty field replacement string (-e) */
char *tabchar = " \t";		/* delimiter characters (-t) */

int  cmp(LINE *, u_long, LINE *, u_long);
void fieldarg(char *);
void joinlines(INPUT *, INPUT *);
void obsolete(char **);
void outfield(LINE *, u_long, int);
void outoneline(INPUT *, LINE *);
void outtwoline(INPUT *, LINE *, INPUT *, LINE *);
void slurp(INPUT *);
void slurpit(INPUT *);
void usage(void);

int
main(int argc, char *argv[])
{
	INPUT *F1, *F2;
	int aflag, ch, cval, vflag;
	char *end;

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	F1 = &input1;
	F2 = &input2;

	aflag = vflag = 0;
	obsolete(argv);
	while ((ch = getopt(argc, argv, "\01a:e:j:1:2:o:t:v:")) != -1) {
		switch (ch) {
		case '\01':		/* See comment in obsolete(). */
			aflag = 1;
			F1->unpair = F2->unpair = 1;
			break;
		case '1':
			if ((F1->joinf = strtol(optarg, &end, 10)) < 1)
				errx(1, "-1 option field number less than 1");
			if (*end)
				errx(1, "illegal field number -- %s", optarg);
			--F1->joinf;
			break;
		case '2':
			if ((F2->joinf = strtol(optarg, &end, 10)) < 1)
				errx(1, "-2 option field number less than 1");
			if (*end)
				errx(1, "illegal field number -- %s", optarg);
			--F2->joinf;
			break;
		case 'a':
			aflag = 1;
			switch(strtol(optarg, &end, 10)) {
			case 1:
				F1->unpair = 1;
				break;
			case 2:
				F2->unpair = 1;
				break;
			default:
				errx(1, "-a option file number not 1 or 2");
				break;
			}
			if (*end)
				errx(1, "illegal file number -- %s", optarg);
			break;
		case 'e':
			empty = optarg;
			break;
		case 'j':
			if ((F1->joinf = F2->joinf = strtol(optarg, &end, 10)) < 1)
				errx(1, "-j option field number less than 1");
			if (*end)
				errx(1, "illegal field number -- %s", optarg);
			--F1->joinf;
			--F2->joinf;
			break;
		case 'o':
			fieldarg(optarg);
			break;
		case 't':
			spans = 0;
			if (strlen(tabchar = optarg) != 1)
				errx(1, "illegal tab character specification");
			break;
		case 'v':
			vflag = 1;
			joinout = 0;
			switch (strtol(optarg, &end, 10)) {
			case 1:
				F1->unpair = 1;
				break;
			case 2:
				F2->unpair = 1;
				break;
			default:
				errx(1, "-v option file number not 1 or 2");
				break;
			}
			if (*end)
				errx(1, "illegal file number -- %s", optarg);
			break;
		case '?':
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (aflag && vflag)
		errx(1, "the -a and -v options are mutually exclusive");

	if (argc != 2)
		usage();

	/* Open the files; "-" means stdin. */
	if (!strcmp(*argv, "-"))
		F1->fp = stdin;
	else if ((F1->fp = fopen(*argv, "r")) == NULL)
		err(1, "%s", *argv);
	++argv;
	if (!strcmp(*argv, "-"))
		F2->fp = stdin;
	else if ((F2->fp = fopen(*argv, "r")) == NULL)
		err(1, "%s", *argv);
	if (F1->fp == stdin && F2->fp == stdin)
		errx(1, "only one input file may be stdin");

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	F1->setusedc = 0;
	F2->setusedc = 0;
	slurp(F1);
	slurp(F2);
	F1->set->cfieldc = 0;
	F2->set->cfieldc = 0;

	/*
	 * We try to let the files have the same field value, advancing
	 * whoever falls behind and always advancing the file(s) we output
	 * from.
	*/
	while (F1->setcnt && F2->setcnt) {
		cval = cmp(F1->set, F1->joinf, F2->set, F2->joinf);
		if (cval == 0) {
			/* Oh joy, oh rapture, oh beauty divine! */
			if (joinout)
				joinlines(F1, F2);
			slurp(F1);
			slurp(F2);
		}
		else {
			if (F1->unpair
			&& (cval < 0 || F2->set->cfieldc == F2->setusedc -1)) {
				joinlines(F1, NULL);
				slurp(F1);
			}
			else if (cval < 0)
				/* File 1 takes the lead... */
				slurp(F1);
			if (F2->unpair
			&& (cval > 0 || F1->set->cfieldc == F1->setusedc -1)) {
				joinlines(F2, NULL);
				slurp(F2);
			}
			else if (cval > 0)
				/* File 2 takes the lead... */
				slurp(F2);
		}
	}

	/*
	 * Now that one of the files is used up, optionally output any
	 * remaining lines from the other file.
	 */
	if (F1->unpair)
		while (F1->setcnt) {
			joinlines(F1, NULL);
			slurp(F1);
		}
	if (F2->unpair)
		while (F2->setcnt) {
			joinlines(F2, NULL);
			slurp(F2);
		}

	return 0;
}

/* wrapper around slurpit() to keep track of what field we are on */
void slurp(INPUT *F)
{
	long fpos;
	u_long cfieldc;

	if (F->set == NULL) {
		fpos = 0;
		cfieldc = 0;
	}
	else {
		fpos = F->set->fpos;
		cfieldc = F->set->cfieldc;
	}
	slurpit(F);
	if (F->set == NULL)
		return;
	else if (fpos != F->set->fpos)
		F->set->cfieldc = cfieldc+1;
}

void
slurpit(INPUT *F)
{
	LINE *lp, *lastlp, tmp;
	size_t len;
	u_long cnt;
	char *bp, *fieldp;
	long fpos;
	/*
	 * Read all of the lines from an input file that have the same
	 * join field.
	 */

	F->setcnt = 0;
	for (lastlp = NULL; ; ++F->setcnt, lastlp = lp) {
		/*
		 * If we're out of space to hold line structures, allocate
		 * more.  Initialize the structure so that we know that this
		 * is new space.
		 */
		if (F->setcnt == F->setalloc) {
			LINE *p;
			u_long newsize = F->setalloc + 50;
			cnt = F->setalloc;
			if ((p = reallocarray(F->set, newsize, sizeof(LINE)))
			    == NULL)
				err(1, NULL);
			F->set = p;
			F->setalloc = newsize;
			memset(F->set + cnt, 0, 50 * sizeof(LINE));
			/* re-set lastlp in case it moved */
			if (lastlp != NULL)
				lastlp = &F->set[F->setcnt - 1];
		}
		/*
		 * Get any pushed back line, else get the next line.  Allocate
		 * space as necessary.  If taking the line from the stack swap
		 * the two structures so that we don't lose space allocated to
		 * either structure.  This could be avoided by doing another
		 * level of indirection, but it's probably okay as is.
		 */
		lp = &F->set[F->setcnt];
		if (F->pushbool) {
			tmp = F->set[F->setcnt];
			F->set[F->setcnt] = F->set[F->pushback];
			F->set[F->pushback] = tmp;
			F->pushbool = 0;
			continue;
		}
		if ((bp = fgetln(F->fp, &len)) == NULL)
			return;
		/*
		 * we depend on knowing on what field we are, one safe way is
		 * the file position.
		*/
		fpos = ftell(F->fp) - len;
		if (lp->linealloc <= len + 1) {
			char *p;
			u_long newsize = lp->linealloc +
			    MAXIMUM(100, len + 1 - lp->linealloc);
			if ((p = realloc(lp->line, newsize)) == NULL)
				err(1, NULL);
			lp->line = p;
			lp->linealloc = newsize;
		}
		F->setusedc++;
		memmove(lp->line, bp, len);
		lp->fpos = fpos;
		/* Replace trailing newline, if it exists. */
		if (bp[len - 1] == '\n')
			lp->line[len - 1] = '\0';
		else
			lp->line[len] = '\0';
		bp = lp->line;

		/* Split the line into fields, allocate space as necessary. */
		lp->fieldcnt = 0;
		while ((fieldp = strsep(&bp, tabchar)) != NULL) {
			if (spans && *fieldp == '\0')
				continue;
			if (lp->fieldcnt == lp->fieldalloc) {
				char **p;
				u_long newsize = lp->fieldalloc + 50;
				if ((p = reallocarray(lp->fields, newsize,
				    sizeof(char *))) == NULL)
					err(1, NULL);
				lp->fields = p;
				lp->fieldalloc = newsize;
			}
			lp->fields[lp->fieldcnt++] = fieldp;
		}

		/* See if the join field value has changed. */
		if (lastlp != NULL && cmp(lp, F->joinf, lastlp, F->joinf)) {
			F->pushbool = 1;
			F->pushback = F->setcnt;
			break;
		}
	}
}

int
cmp(LINE *lp1, u_long fieldno1, LINE *lp2, u_long fieldno2)
{
	if (lp1->fieldcnt <= fieldno1)
		return (-1);
	else if (lp2->fieldcnt <= fieldno2)
		return (1);
	return (strcmp(lp1->fields[fieldno1], lp2->fields[fieldno2]));
}

void
joinlines(INPUT *F1, INPUT *F2)
{
	u_long cnt1, cnt2;

	/*
	 * Output the results of a join comparison.  The output may be from
	 * either file 1 or file 2 (in which case the first argument is the
	 * file from which to output) or from both.
	 */
	if (F2 == NULL) {
		for (cnt1 = 0; cnt1 < F1->setcnt; ++cnt1)
			outoneline(F1, &F1->set[cnt1]);
		return;
	}
	for (cnt1 = 0; cnt1 < F1->setcnt; ++cnt1)
		for (cnt2 = 0; cnt2 < F2->setcnt; ++cnt2)
			outtwoline(F1, &F1->set[cnt1], F2, &F2->set[cnt2]);
}

void
outoneline(INPUT *F, LINE *lp)
{
	u_long cnt;

	/*
	 * Output a single line from one of the files, according to the
	 * join rules.  This happens when we are writing unmatched single
	 * lines.  Output empty fields in the right places.
	 */
	if (olist)
		for (cnt = 0; cnt < olistcnt; ++cnt) {
			if (olist[cnt].filenum == F->number)
				outfield(lp, olist[cnt].fieldno, 0);
			else if (olist[cnt].filenum == 0)
				outfield(lp, F->joinf, 0);
			else
				outfield(lp, 0, 1);
		}
	else {
		/*
		 * Output the join field, then the remaining fields from F
		 */
		outfield(lp, F->joinf, 0);
		for (cnt = 0; cnt < lp->fieldcnt; ++cnt)
			if (F->joinf != cnt)
				outfield(lp, cnt, 0);
	}

	putchar('\n');
	if (ferror(stdout))
		err(1, "stdout");
	needsep = 0;
}

void
outtwoline(INPUT *F1, LINE *lp1, INPUT *F2, LINE *lp2)
{
	u_long cnt;

	/* Output a pair of lines according to the join list (if any). */
	if (olist) {
		for (cnt = 0; cnt < olistcnt; ++cnt)
			if (olist[cnt].filenum == 0) {
				if (lp1->fieldcnt >= F1->joinf)
					outfield(lp1, F1->joinf, 0);
				else
					outfield(lp2, F2->joinf, 0);
			} else if (olist[cnt].filenum == 1)
				outfield(lp1, olist[cnt].fieldno, 0);
			else /* if (olist[cnt].filenum == 2) */
				outfield(lp2, olist[cnt].fieldno, 0);
	} else {
		/*
		 * Output the join field, then the remaining fields from F1
		 * and F2.
		 */
		outfield(lp1, F1->joinf, 0);
		for (cnt = 0; cnt < lp1->fieldcnt; ++cnt)
			if (F1->joinf != cnt)
				outfield(lp1, cnt, 0);
		for (cnt = 0; cnt < lp2->fieldcnt; ++cnt)
			if (F2->joinf != cnt)
				outfield(lp2, cnt, 0);
	}
	putchar('\n');
	if (ferror(stdout))
		err(1, "stdout");
	needsep = 0;
}

void
outfield(LINE *lp, u_long fieldno, int out_empty)
{
	if (needsep++)
		putchar((int)*tabchar);
	if (!ferror(stdout)) {
		if (lp->fieldcnt <= fieldno || out_empty) {
			if (empty != NULL)
				fputs(empty, stdout);
		} else {
			if (*lp->fields[fieldno] == '\0')
				return;
			fputs(lp->fields[fieldno], stdout);
		}
	}
	if (ferror(stdout))
		err(1, "stdout");
}

/*
 * Convert an output list argument "2.1, 1.3, 2.4" into an array of output
 * fields.
 */
void
fieldarg(char *option)
{
	u_long fieldno, filenum;
	char *end, *token;

	while ((token = strsep(&option, ", \t")) != NULL) {
		if (*token == '\0')
			continue;
		if (token[0] == '0')
			filenum = fieldno = 0;
		else if ((token[0] == '1' || token[0] == '2') &&
		    token[1] == '.') {
			filenum = token[0] - '0';
			fieldno = strtol(token + 2, &end, 10);
			if (*end)
				errx(1, "malformed -o option field");
			if (fieldno == 0)
				errx(1, "field numbers are 1 based");
			--fieldno;
		} else
			errx(1, "malformed -o option field");
		if (olistcnt == olistalloc) {
			OLIST *p;
			u_long newsize = olistalloc + 50;
			if ((p = reallocarray(olist, newsize, sizeof(OLIST)))
			    == NULL)
				err(1, NULL);
			olist = p;
			olistalloc = newsize;
		}
		olist[olistcnt].filenum = filenum;
		olist[olistcnt].fieldno = fieldno;
		++olistcnt;
	}
}

void
obsolete(char **argv)
{
	size_t len;
	char **p, *ap, *t;

	while ((ap = *++argv) != NULL) {
		/* Return if "--". */
		if (ap[0] == '-' && ap[1] == '-')
			return;
		/* skip if not an option */
		if (ap[0] != '-')
			continue;
		switch (ap[1]) {
		case 'a':
			/*
			 * The original join allowed "-a", which meant the
			 * same as -a1 plus -a2.  POSIX 1003.2, Draft 11.2
			 * only specifies this as "-a 1" and "a -2", so we
			 * have to use another option flag, one that is
			 * unlikely to ever be used or accidentally entered
			 * on the command line.  (Well, we could reallocate
			 * the argv array, but that hardly seems worthwhile.)
			 */
			if (ap[2] == '\0' && (argv[1] == NULL ||
			    (strcmp(argv[1], "1") != 0 &&
			    strcmp(argv[1], "2") != 0))) {
				ap[1] = '\01';
				warnx("-a option used without an argument; "
				    "reverting to historical behavior");
			}
			break;
		case 'j':
			/*
			 * The original join allowed "-j[12] arg" and "-j arg".
			 * Convert the former to "-[12] arg".  Don't convert
			 * the latter since getopt(3) can handle it.
			 */
			switch(ap[2]) {
			case '1':
			case '2':
				if (ap[3] != '\0')
					goto jbad;
				ap[1] = ap[2];
				ap[2] = '\0';
				break;
			case '\0':
				break;
			default:
jbad:				warnx("unknown option -- %s", ap + 1);
				usage();
			}
			break;
		case 'o':
			/*
			 * The original join allowed "-o arg arg".
			 * Convert to "-o arg -o arg".
			 */
			if (ap[2] != '\0' || argv[1] == NULL)
				break;
			for (p = argv + 2; *p != NULL; ++p) {
				if (p[0][0] == '0' || ((p[0][0] != '1' &&
				    p[0][0] != '2') || p[0][1] != '.'))
					break;
				len = strlen(*p);
				if (len - 2 != strspn(*p + 2, "0123456789"))
					break;
				if ((t = malloc(len + 3)) == NULL)
					err(1, NULL);
				t[0] = '-';
				t[1] = 'o';
				memmove(t + 2, *p, len + 1);
				*p = t;
			}
			argv = p - 1;
			break;
		}
	}
}

void
usage(void)
{
	int len;
	extern char *__progname;

	len = strlen(__progname) + sizeof("usage: ");
	(void)fprintf(stderr, "usage: %s [-1 field] [-2 field] "
	    "[-a file_number | -v file_number] [-e string]\n"
	    "%*s[-o list] [-t char] file1 file2\n",
	    __progname, len, "");
	exit(1);
}
@


1.26
log
@tame "stdio rpath" at the start, then potentially some files are opened.
After that, tame "stdio" because that's all this program does.
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.25 2015/07/21 04:42:59 jasper Exp $	*/
d107 2
a108 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
d214 2
a215 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.25
log
@zap trailing whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.24 2015/01/16 06:40:08 deraadt Exp $	*/
d107 3
d213 3
@


1.24
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.23 2014/10/11 04:31:55 doug Exp $	*/
d238 1
a238 1
			else if (cval < 0)	
d278 1
a278 1
		cfieldc = 0;	
d289 1
a289 1
}	
d568 1
a568 1
			/* 
@


1.23
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.22 2013/11/15 22:20:04 millert Exp $	*/
a35 2
#include <sys/param.h>

d42 2
d350 1
a350 1
			    MAX(100, len + 1 - lp->linealloc);
@


1.22
log
@Include unistd.h as it is the standard location for getopt().
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.21 2009/10/27 23:59:39 deraadt Exp $	*/
d315 2
a316 2
			if ((p = realloc(F->set,
			    newsize * sizeof(LINE))) == NULL)
d374 2
a375 2
				if ((p = realloc(lp->fields,
				    newsize * sizeof(char *))) == NULL)
d541 2
a542 2
			if ((p = realloc(olist,
			    newsize * sizeof(OLIST))) == NULL)
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.20 2007/05/29 18:29:26 jmc Exp $	*/
d42 1
@


1.20
log
@remove -j from SYNOPSIS and usage(); it's deprecated and already
documented in STANDARDS;

ok otto
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.19 2007/04/23 19:21:24 millert Exp $	*/
a34 11

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1991, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "@@(#)join.c	8.6 (Berkeley) 5/4/95"; */
static const char rcsid[] = "$OpenBSD: join.c,v 1.19 2007/04/23 19:21:24 millert Exp $";
#endif /* not lint */
@


1.19
log
@Remove duplicate commment
Simplify -j parsing
Use warnx() not errx() for illegal -j option so that usage() gets called.
When parsing -o don't go past the end of argv
Sync usage() with man page, use __progname and make it line up nicely
Based on a diff from Tobias Stoeckmann
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.18 2003/12/28 19:53:23 otto Exp $	*/
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: join.c,v 1.18 2003/12/28 19:53:23 otto Exp $";
d652 1
a652 1
	    "%*s[-j file_number field] [-o list] [-t char] file1 file2\n",
@


1.18
log
@Follow Posix when writing non-matching lines. Historically, join(1)
did not change the order of fields of non-matching lines if no -o
option was used, but -a or -v was specified.  This update writes
the join field first, followed by the remaining fields of a
non-matching line.

This change breaks the old security(8), so don't forget to update
/etc/security. From PR 2208. Testing and man page help and ok by jmc@@

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.17 2003/12/12 10:38:44 otto Exp $	*/
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: join.c,v 1.17 2003/12/12 10:38:44 otto Exp $";
a340 1
		 * but it's probably okay as is.
a602 5
				if (ap[3] != '\0')
					goto jbad;
				ap[1] = '1';
				ap[2] = '\0';
				break;
d606 1
a606 1
				ap[1] = '2';
d612 1
a612 1
jbad:				errx(1, "illegal option -- %s", ap);
d621 1
a621 1
			if (ap[2] != '\0')
d646 8
a653 3
	(void)fprintf(stderr, "%s%s\n",
	    "usage: join [-a fileno | -v fileno ] [-e string] [-1 field] ",
	    "[-2 field]\n            [-o list] [-t char] file1 file2");
@


1.17
log
@Update, mostly from FreeBSD:

o Realloc cleanup.
o Some long vs int cleanup.
o Implement the Posix defined 0 as -o field value, meaning the join field.
o Allow both -a 1 and -a1, and warn if the backward compatibility "-a without
  a number" is used.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.16 2003/06/10 22:20:47 deraadt Exp $	*/
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: join.c,v 1.16 2003/06/10 22:20:47 deraadt Exp $";
d452 5
a456 1
	else
d458 4
a461 1
			outfield(lp, cnt, 0);
@


1.16
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.15 2003/06/03 02:56:09 millert Exp $	*/
d37 1
a37 1
static char copyright[] =
d44 1
a44 1
static char rcsid[] = "$OpenBSD: join.c,v 1.15 2003/06/03 02:56:09 millert Exp $";
a48 1
#include <ctype.h>
a49 1
#include <errno.h>
a52 1
#include <unistd.h>
d74 1
a74 1
	int number;			/* 1 for file 1, 2 for file 2 */
d82 2
a83 2
INPUT input1 = { NULL, 0, 0, 1, NULL, 0, 0, 0, },
      input2 = { NULL, 0, 0, 2, NULL, 0, 0, 0, };
d306 1
a306 1
	int cnt;
d322 2
d325 2
a326 3
			F->setalloc += 50;
			if ((F->set = realloc(F->set,
			    F->setalloc * sizeof(LINE))) == NULL)
d328 2
d359 4
a362 3
			lp->linealloc += MAX(100, len + 1 - lp->linealloc);
			if ((lp->line = realloc(lp->line, lp->linealloc))
			== NULL)
d364 2
d383 4
a386 3
				lp->fieldalloc += 50;
				if ((lp->fields = realloc(lp->fields,
				    lp->fieldalloc * sizeof(char *))) == NULL)
d388 2
d416 1
a416 1
	int cnt1, cnt2;
d436 1
a436 1
	int cnt;
d447 2
d464 1
a464 1
	int cnt;
d469 6
a474 1
			if (olist[cnt].filenum == 1)
d523 1
a523 1
	u_long fieldno;
d529 12
a540 4
		if ((token[0] != '1' && token[0] != '2') || token[1] != '.')
			errx(1, "malformed -o option field");
		fieldno = strtol(token + 2, &end, 10);
		if (*end)
a541 2
		if (fieldno == 0)
			errx(1, "field numbers are 1 based");
d543 4
a546 3
			olistalloc += 50;
			if ((olist = realloc(olist,
			    olistalloc * sizeof(OLIST))) == NULL)
d548 2
d551 2
a552 2
		olist[olistcnt].filenum = token[0] - '0';
		olist[olistcnt].fieldno = fieldno - 1;
d560 1
a560 1
	int len;
d581 3
a583 1
			if (ap[2] == '\0')
d585 3
d623 2
a624 1
				if ((p[0][0] != '1' && p[0][0] != '2') || p[0][1] != '.')
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.14 2002/02/16 21:27:47 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: join.c,v 1.14 2002/02/16 21:27:47 millert Exp $";
d114 1
a114 3
main(argc, argv)
	int argc;
	char *argv[];
d284 1
a284 2
void slurp(F)
	INPUT *F;
d305 1
a305 2
slurpit(F)
	INPUT *F;
d398 1
a398 3
cmp(lp1, fieldno1, lp2, fieldno2)
	LINE *lp1, *lp2;
	u_long fieldno1, fieldno2;
d408 1
a408 2
joinlines(F1, F2)
	INPUT *F1, *F2;
d428 1
a428 3
outoneline(F, lp)
	INPUT *F;
	LINE *lp;
d454 1
a454 3
outtwoline(F1, lp1, F2, lp2)
	INPUT *F1, *F2;
	LINE *lp1, *lp2;
d485 1
a485 4
outfield(lp, fieldno, out_empty)
	LINE *lp;
	u_long fieldno;
	int out_empty;
d508 1
a508 2
fieldarg(option)
	char *option;
d536 1
a536 2
obsolete(argv)
	char **argv;
d615 1
a615 1
usage()
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.13 2001/01/29 01:57:59 niklas Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d44 1
a44 1
static char rcsid[] = "$OpenBSD: join.c,v 1.13 2001/01/29 01:57:59 niklas Exp $";
@


1.13
log
@$OpenBSD$
@
text
@d1 1
a1 1
/* $OpenBSD: join.c,v 1.12 1999/07/23 23:37:34 aaron Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: join.c,v 1.12 1999/07/23 23:37:34 aaron Exp $";
d106 10
a115 10
int  cmp __P((LINE *, u_long, LINE *, u_long));
void fieldarg __P((char *));
void joinlines __P((INPUT *, INPUT *));
void obsolete __P((char **));
void outfield __P((LINE *, u_long, int));
void outoneline __P((INPUT *, LINE *));
void outtwoline __P((INPUT *, LINE *, INPUT *, LINE *));
void slurp __P((INPUT *));
void slurpit __P((INPUT *));
void usage __P((void));
@


1.12
log
@fieldcnt is the number of fields, not +1... this one was missed in 1995
when the other two were fixed
@
text
@d1 1
a1 1
/* $Id: join.c,v 1.11 1998/11/16 06:09:12 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$Id: join.c,v 1.11 1998/11/16 06:09:12 deraadt Exp $";
@


1.11
log
@more -Wall
@
text
@d1 1
a1 1
/* $Id: join.c,v 1.10 1997/08/25 05:31:10 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$Id: join.c,v 1.10 1997/08/25 05:31:10 deraadt Exp $";
d508 1
a508 1
		if (lp->fieldcnt < fieldno || out_empty) {
@


1.10
log
@require compat opts start with -; bug from kh@@mogami-wire.co.jp; fix from freebsd
@
text
@d1 1
a1 1
/* $Id: join.c,v 1.9 1997/07/24 01:35:30 deraadt Exp $
d48 1
a48 1
static char rcsid[] = "$Id: join.c,v 1.9 1997/07/24 01:35:30 deraadt Exp $";
d474 1
a474 1
	if (olist)
d480 1
a480 1
	else {
d507 1
a507 1
	if (!ferror(stdout))
d516 1
@


1.9
log
@argh
@
text
@d1 1
a1 1
/* $Id: join.c,v 1.8 1997/07/23 02:59:33 deraadt Exp $
d48 1
a48 1
static char rcsid[] = "$Id: join.c,v 1.8 1997/07/23 02:59:33 deraadt Exp $";
d564 3
@


1.8
log
@arg parsing bug in compat code; kh@@mogami-wire.co.jp
@
text
@d1 1
a1 1
/* $Id: join.c,v 1.7 1997/04/09 16:42:25 michaels Exp $
d48 1
a48 1
static char rcsid[] = "$Id: join.c,v 1.7 1997/04/09 16:42:25 michaels Exp $";
d562 1
a562 1
		if (ap[0] != '-' || ap[0] == '-' && ap[1] == '-')
@


1.7
log
@just clean up a stylistic mess I created myself long ago.
@
text
@d1 1
a1 1
/* $Id: join.c,v 1.6 1997/01/15 23:42:38 millert Exp $
d48 1
a48 1
static char rcsid[] = "$Id: join.c,v 1.6 1997/01/15 23:42:38 millert Exp $";
d562 1
a562 1
		if (ap[0] == '-' && ap[1] == '-')
@


1.6
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/* $Id: join.c,v 1.5 1996/08/12 16:37:00 michaels Exp $
d48 1
a48 1
static char rcsid[] = "$Id: join.c,v 1.5 1996/08/12 16:37:00 michaels Exp $";
d68 1
a68 1
	char *line;				/* line */
d72 2
a73 2
	u_long fieldalloc;	/* line field(s) allocated count */
	u_long cfieldc;		/* current field count */
d78 1
a78 1
	FILE *fp;				/* file descriptor */
d80 3
a82 4
	int unpair;				/* output unpairable lines (-a) */
	int number;				/* 1 for file 1, 2 for file 2 */

	LINE *set;				/* set of lines with same field */
d252 2
a253 1
			if (F1->unpair && (cval < 0 || F2->set->cfieldc == F2->setusedc -1)) {
d260 2
a261 1
			if (F2->unpair && (cval > 0 || F1->set->cfieldc == F1->setusedc -1)) {
d362 2
a363 3
		 * we depend on knowing on what field we are, one safe way is the 
		 *	file position, though we should perhaps find another way so we
		 *	won't have to call ftell() after each line read from file. 
d368 2
a369 1
			if ((lp->line = realloc(lp->line, lp->linealloc)) == NULL)
@


1.5
log
@remove dead code, add comments, put back original comments (Cthulu
may know how they were lost).
@
text
@d1 1
a1 1
/* $Id: join.c,v 1.4 1996/08/12 02:31:53 michaels Exp $
d48 1
a48 1
static char rcsid[] = "$Id: join.c,v 1.4 1996/08/12 02:31:53 michaels Exp $";
d132 1
a132 1
	while ((ch = getopt(argc, argv, "\01a:e:j:1:2:o:t:v:")) != EOF) {
@


1.4
log
@on Theo's suggestion replaced join with join from 44lite, fixed (?)
netbsd pr #1356 (reported by mouse@@Collatz.McRCIM.McGill.EDU, der Mouse)
@
text
@d1 1
a1 1
/*	$Id$                                                                  */   
d48 1
a48 1
static char rcsid[] = "$Id$";
a78 1
	char *fname;			/* file name */
d90 2
a91 2
INPUT input1 = { NULL, NULL, 0, 0, 1, NULL, 0, 0, 0, },
      input2 = { NULL, NULL, 0, 0, 2, NULL, 0, 0, 0, };
a222 1
	F1->fname = *argv;
a227 1
	F2->fname = *argv;
d235 2
a236 1
	F1->set->cfieldc = F2->set->cfieldc = 0;
d238 5
d249 1
a249 2
			if (F2->set->cfieldc < F2->setusedc -1)
				slurp(F1);
d253 1
a253 1
			if (F1->unpair && (cval < 0 || F2->set->cfieldc >= F2->setusedc -1)) {
d258 1
d260 1
a260 1
			if (F2->unpair && (cval >= 0 || F1->set->cfieldc >= F1->setusedc -1)) {
d264 2
a265 1
			else if (cval >= 0)
d284 1
d288 1
a288 1
/* wrapper around slurp() to keep track of what field we are on */
a294 1
	/* if fpos changes, new field */
d362 2
a363 2
		 *	file position, thoug we should perhaps find another way so we
		 *	won't have to call ftell() after each line read from file.
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 2
a5 2
 * Copyright (c) 1991 The Regents of the University of California.
 * All rights reserved.
d8 2
a9 2
 * Steve Hayman of Indiana University, Michiro Hikida and David
 * Goodenough.
d41 3
a43 3
char copyright[] =
"@@(#) Copyright (c) 1991 The Regents of the University of California.\n\
 All rights reserved.\n";
d47 2
a48 2
/*static char sccsid[] = "from: @@(#)join.c	5.1 (Berkeley) 11/18/91";*/
static char rcsid[] = "$OpenBSD: join.c,v 1.2 1995/12/22 19:02:55 deraadt Exp $";
d51 5
a55 1
#include <sys/types.h>
d59 1
a59 2
#include <ctype.h>
#include <errno.h>
d68 4
a71 4
	char *line;		/* line */
	u_long linealloc;	/* line allocated count */
	char **fields;		/* line field(s) */
	u_long fieldcnt;	/* line field(s) count */
d73 2
d78 12
a89 9
	FILE *fp;		/* file descriptor */
	u_long joinf;		/* join field (-1, -2, -j) */
	int unpair;		/* output unpairable lines (-a) */
	int number;		/* 1 for file 1, 2 for file 2 */

	LINE *set;		/* set of lines with same field */
	u_long pushback;	/* line on the stack */
	u_long setcnt;		/* set count */
	u_long setalloc;	/* set allocated count */
d91 2
a92 2
INPUT input1 = { NULL, 0, 0, 1, NULL, -1, 0, 0, },
      input2 = { NULL, 0, 0, 1, NULL, -1, 0, 0, };
d95 1
a95 1
	u_long	fileno;		/* file number */
a103 1
int showusage = 1;		/* show usage for usage err() calls */
a108 2
void enomem __P((void));
void err __P((const char *, ...));
d112 1
a112 1
void outfield __P((LINE *, u_long));
d116 1
d124 1
a124 1
	register INPUT *F1, *F2;
d135 1
a135 1
		case '\01':
d141 1
a141 1
				err("-1 option field number less than 1");
d143 1
a143 1
				err("illegal field number -- %s", optarg);
d148 1
a148 1
				err("-2 option field number less than 1");
d150 1
a150 1
				err("illegal field number -- %s", optarg);
d163 1
a163 1
				err("-a option file number not 1 or 2");
d167 1
a167 1
				err("illegal file number -- %s", optarg);
d173 2
a174 3
			if ((F1->joinf = F2->joinf =
			    strtol(optarg, &end, 10)) < 1)
				err("-j option field number less than 1");
d176 1
a176 1
				err("illegal field number -- %s", optarg);
d186 1
a186 1
				err("illegal tab character specification");
d191 1
a191 1
			switch(strtol(optarg, &end, 10)) {
d199 1
a199 1
				err("-v option file number not 1 or 2");
d203 1
a203 1
				err("illegal file number -- %s", optarg);
d214 1
a214 1
		err("-a and -v options mutually exclusive");
a217 1
	showusage = 0;
d223 2
a224 1
		err("%s: %s", *argv, strerror(errno));
d229 2
a230 1
		err("%s: %s", *argv, strerror(errno));
d232 1
a232 1
		err("only one input file may be stdin");
d234 2
d238 2
d246 2
a247 1
			slurp(F1);
d249 3
a251 3
		} else if (cval < 0) {
			/* File 1 takes the lead... */
			if (F1->unpair)
d253 5
a257 4
			slurp(F1);
		} else {
			/* File 2 takes the lead... */
			if (F2->unpair)
d259 4
a262 1
			slurp(F2);
d280 1
a280 1
	exit(0);
d283 23
d307 1
a307 1
slurp(F)
d310 1
a310 2
	register LINE *lp, *lastlp;
	LINE tmp;
d314 1
a314 1

d319 1
d321 1
a321 1
	for (lastlp = NULL;; ++F->setcnt, lastlp = lp) {
d329 1
a329 1
			F->setalloc += 100;
d332 5
a336 2
				enomem();
			bzero(F->set + cnt, 100 * sizeof(LINE *));
a337 1
			
d341 3
a343 2
		 * the two structures so that we don't lose the allocated space.
		 * This could be avoided by doing another level of indirection,
d347 1
a347 1
		if (F->pushback != -1) {
d351 1
a351 1
			F->pushback = -1;
d356 6
d363 8
a370 12
			if (lp->linealloc == 0)
				lp->linealloc = 128;
			while (lp->linealloc <= len + 1)
				lp->linealloc *= 2;

			if ((lp->line = realloc(lp->line,
			    lp->linealloc * sizeof(char))) == NULL)
				enomem();
		}
		bcopy(bp, lp->line, len+1);

		/* Replace trailing newline, if it exists. */ 
d383 1
a383 1
				lp->fieldalloc += 100;
d386 1
a386 1
					enomem();
d393 1
d405 1
a405 3
	if (fieldno1 >= lp1->fieldcnt)
		return (lp2->fieldcnt < fieldno2 ? 0 : 1);
	if (fieldno2 >= lp2->fieldcnt)
d407 2
d414 1
a414 1
	register INPUT *F1, *F2;
d416 1
a416 1
	register int cnt1, cnt2;
d436 1
a436 1
	register LINE *lp;
d438 1
a438 1
	register int cnt;
d447 4
a450 2
			if (olist[cnt].fileno == F->number)
				outfield(lp, olist[cnt].fieldno);
d454 2
a455 2
			outfield(lp, cnt);
	(void)printf("\n");
d457 1
a457 1
		err("stdout: %s", strerror(errno));
d463 2
a464 2
	register INPUT *F1, *F2;
	register LINE *lp1, *lp2;
d466 1
a466 1
	register int cnt;
d471 4
a474 4
			if (olist[cnt].fileno == 1)
				outfield(lp1, olist[cnt].fieldno);
			else /* if (olist[cnt].fileno == 2) */
				outfield(lp2, olist[cnt].fieldno);
d480 1
a480 1
		outfield(lp1, F1->joinf);
d483 1
a483 1
				outfield(lp1, cnt);
d486 1
a486 1
				outfield(lp2, cnt);
d488 1
a488 1
	(void)printf("\n");
d490 1
a490 1
		err("stdout: %s", strerror(errno));
d495 1
a495 1
outfield(lp, fieldno)
d498 1
d501 1
a501 1
		(void)printf("%c", *tabchar);
d503 1
a503 1
		if (lp->fieldcnt < fieldno) {
d505 1
a505 1
				(void)printf("%s", empty);
d509 1
a509 1
			(void)printf("%s", lp->fields[fieldno]);
d512 1
a512 1
		err("stdout: %s", strerror(errno));
d526 1
a526 1
	while ((token = strsep(&option, " \t")) != NULL) {
d529 2
a530 2
		if (token[0] != '1' && token[0] != '2' || token[1] != '.')
			err("malformed -o option field");
d533 1
a533 1
			err("malformed -o option field");
d535 1
a535 1
			err("field numbers are 1 based");
d540 1
a540 1
				enomem();
d542 1
a542 1
		olist[olistcnt].fileno = token[0] - '0';
d555 1
a555 1
	while (ap = *++argv) {
d595 1
a595 1
jbad:				err("illegal option -- %s", ap);
d601 2
a602 2
			 * The original join allowed "-o arg arg".  Convert to
			 * "-o arg -o arg".
d606 2
a607 3
			for (p = argv + 2; *p; ++p) {
				if (p[0][0] != '1' && p[0][0] != '2' ||
				    p[0][1] != '.')
d613 1
a613 1
					enomem();
d616 1
a616 1
				bcopy(*p, t + 2, len + 1);
a625 7
enomem()
{
	showusage = 0;
	err("%s", strerror(errno));
}

void
a631 31
}

#if __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

void
#if __STDC__
err(const char *fmt, ...)
#else
err(fmt, va_alist)
	char *fmt;
        va_dcl
#endif
{
	va_list ap;
#if __STDC__
	va_start(ap, fmt);
#else
	va_start(ap);
#endif
	(void)fprintf(stderr, "join: ");
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
	if (showusage)
		usage();
	exit(1);
	/* NOTREACHED */
@


1.2
log
@fieldcnt is number of fields, not +1; from mouse@@Collatz.McRCIM.McGill.EDU; netbsd pr#1356
@
text
@d1 2
d48 1
a48 1
static char rcsid[] = "$Id: join.c,v 1.1.1.1 1995/10/18 08:45:26 deraadt Exp $";
@


1.1
log
@Initial revision
@
text
@d46 1
a46 1
static char rcsid[] = "$Id: join.c,v 1.6 1994/01/04 05:24:34 cgd Exp $";
d359 1
a359 1
	if (lp1->fieldcnt < fieldno1)
d361 1
a361 1
	if (lp2->fieldcnt < fieldno2)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
