head	1.10;
access;
symbols
	OPENBSD_4_8:1.9.0.30
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.26
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.28
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.24
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.16
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2010.10.18.20.54.00;	author deraadt;	state dead;
branches;
next	1.9;

1.9
date	2003.09.05.03.28.27;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches
	1.8.4.1
	1.8.6.1;
next	1.7;

1.7
date	2001.05.04.22.16.16;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.02.22.56.53;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.29.21.52.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.09.16.10.42.57;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.04.01.07.35.38;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.39.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.16.11.46.58;	author deraadt;	state Exp;
branches;
next	;

1.8.4.1
date	2003.09.24.18.59.11;	author brad;	state Exp;
branches;
next	;

1.8.6.1
date	2003.09.24.19.05.59;	author brad;	state Exp;
branches;
next	;


desc
@@


1.10
log
@sup is no longer used. reminded by pirofti and jmc
@
text
@/*	$OpenBSD: supcparse.c,v 1.9 2003/09/05 03:28:27 tedu Exp $	*/

/*
 * Copyright (c) 1992 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 * sup collection parsing routines
 **********************************************************************
 * HISTORY
 *
 * 7-July-93  Nate Williams at Montana State University
 *	Modified SUP to use gzip based compression when sending files
 *	across the network to save BandWidth
 *
 * Revision 1.6  92/08/11  12:07:38  mrt
 * 	Added use-rel-suffix option corresponding to -u switch.
 * 	[92/07/26            mrt]
 * 
 * Revision 1.5  92/02/08  18:24:19  mja
 * 	Added "keep" supfile option, corresponding to -k switch.
 * 	[92/01/17            vdelvecc]
 * 
 * Revision 1.4  91/05/16  14:49:50  ern
 * 	Change default timeout from none to 3 hours so we don't accumalute 
 * 	processes running sups to dead hosts especially for users.
 * 	[91/05/16  14:49:21  ern]
 * 
 *
 * 10-Feb-88  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added timeout to backoff.
 *
 * 28-Jun-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code for "release" support.  Removed obsolete options.
 *
 * 25-May-87  Doug Philips (dwp) at Carnegie-Mellon University
 *	Split off from sup.c
 *
 **********************************************************************
 */

#include "supcdefs.h"
#include "supextern.h"


#ifdef	lint
static char _argbreak;
#else
extern char _argbreak;			/* break character from nxtarg */
#endif

typedef enum {				/* supfile options */
	OHOST, OBASE, OHOSTBASE, OPREFIX, ORELEASE,
	ONOTIFY, OLOGIN, OPASSWORD, OCRYPT,
	OBACKUP, ODELETE, OEXECUTE, OOLD, OTIMEOUT, OKEEP, OURELSUF,
	OCOMPRESS
} OPTION;

struct option {
	char *op_name;
	OPTION op_enum;
} options[] = {
	{ "host",	OHOST },
	{ "base",	OBASE },
	{ "hostbase",	OHOSTBASE },
	{ "prefix",	OPREFIX },
	{ "release",	ORELEASE },
	{ "notify",	ONOTIFY },
	{ "login",	OLOGIN },
	{ "password",	OPASSWORD },
	{ "crypt",	OCRYPT },
	{ "backup",	OBACKUP },
	{ "delete",	ODELETE },
	{ "execute",	OEXECUTE },
	{ "old",	OOLD },
	{ "timeout",	OTIMEOUT },
	{ "keep",	OKEEP },
	{ "use-rel-suffix", OURELSUF },
 	{ "compress", 	OCOMPRESS }
};

static void passdelim(char **, int );

static void
passdelim(ptr, delim)		/* skip over delimiter */
	char **ptr, delim;
{
	*ptr = skipover(*ptr, " \t");
	if (_argbreak != delim && **ptr == delim) {
		(*ptr)++;
		*ptr = skipover(*ptr, " \t");
	}
}

int
parsecoll(c, collname, args)
	COLLECTION *c;
	char *collname, *args;
{
	char *arg, *p;
	OPTION option;
	int opno;

	c->Cnext = NULL;
	c->Cname = strdup(collname);
	c->Chost = NULL;
	c->Chtree = NULL;
	c->Cbase = NULL;
	c->Chbase = NULL;
	c->Cprefix = NULL;
	c->Crelease = NULL;
	c->Cnotify = NULL;
	c->Clogin = NULL;
	c->Cpswd = NULL;
	c->Ccrypt = NULL;
	c->Ctimeout = 3*60*60;	/* default to 3 hours instead of no timeout */
	c->Cflags = 0;
	c->Cnogood = FALSE;
	c->Clockfd = -1;
	args = skipover(args, " \t");
	while (*(arg = nxtarg(&args, " \t="))) {
		for (opno = 0; opno < sizeofA(options); opno++)
			if (strcmp(arg, options[opno].op_name) == 0)
				break;
		if (opno == sizeofA(options)) {
			logerr("Invalid supfile option %s for collection %s",
			    arg, c->Cname);
			return (-1);
		}
		option = options[opno].op_enum;
		switch (option) {
		case OHOST:
			passdelim(&args, '=');
			do {
				arg = nxtarg(&args, ", \t");
				(void) Tinsert(&c->Chtree, arg, FALSE);
				arg = args;
				p = skipover(args, " \t");
				if (*p++ == ',')
					args = p;
			} while (arg != args);
			break;
		case OBASE:
			passdelim (&args, '=');
			arg = nxtarg (&args, " \t");
			c->Cbase = strdup(arg);
			break;
		case OHOSTBASE:
			passdelim(&args, '=');
			arg = nxtarg(&args, " \t");
			c->Chbase = strdup(arg);
			break;
		case OPREFIX:
			passdelim(&args, '=');
			arg = nxtarg(&args, " \t");
			c->Cprefix = strdup(arg);
			break;
		case ORELEASE:
			passdelim(&args, '=');
			arg = nxtarg (&args, " \t");
			c->Crelease = strdup(arg);
			break;
		case ONOTIFY:
			passdelim(&args, '=');
			arg = nxtarg(&args, " \t");
			c->Cnotify = strdup(arg);
			break;
		case OLOGIN:
			passdelim(&args, '=');
			arg = nxtarg(&args, " \t");
			c->Clogin = strdup(arg);
			break;
		case OPASSWORD:
			passdelim(&args, '=');
			arg = nxtarg(&args, " \t");
			c->Cpswd = strdup(arg);
			break;
		case OCRYPT:
			passdelim(&args, '=');
			arg = nxtarg(&args, " \t");
			c->Ccrypt = strdup(arg);
			break;
		case OBACKUP:
			c->Cflags |= CFBACKUP;
			break;
		case ODELETE:
			c->Cflags |= CFDELETE;
			break;
		case OEXECUTE:
			c->Cflags |= CFEXECUTE;
			break;
		case OOLD:
			c->Cflags |= CFOLD;
			break;
		case OKEEP:
			c->Cflags |= CFKEEP;
			break;
		case OURELSUF:
			c->Cflags |= CFURELSUF;
			break;
		case OCOMPRESS:
			c->Cflags |= CFCOMPRESS;
			break;
		case OTIMEOUT:
			passdelim(&args, '=');
			arg = nxtarg(&args, " \t");
			c->Ctimeout = atoi(arg);
			break;
		}
	}
	return (0);
}

time_t
getwhen(collection, relsuffix)
	char *collection, *relsuffix;
{
	char buf[STRINGLENGTH];
	char *ep;
	FILE *fp;
	time_t tstamp;

	(void) snprintf(buf, sizeof buf, FILEWHEN, collection, relsuffix);

	if ((fp = fopen(buf, "r")) == NULL)
		return 0;

	if (fgets(buf, sizeof(buf), fp) == NULL) {
		(void) fclose(fp);
		return 0;
	}

	(void) fclose(fp);

	if ((tstamp = strtol(buf, &ep, 0)) == -1 || *ep != '\n')
		return (0);

	return (tstamp);
}

int
putwhen(fname, tstamp)
	char *fname;
	time_t tstamp;
{
	FILE *fp;
	if ((fp = fopen(fname, "w")) == NULL)
		return (0);
	if (fprintf(fp, "%u\n", tstamp) < 0) {
		(void) fclose(fp);
		return (0);
	}
	if (fclose(fp) != 0)
		return (0);
	return (1);
}
@


1.9
log
@fp leak.  from Patrick Latifi.  ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supcparse.c,v 1.8 2002/02/16 21:27:54 millert Exp $	*/
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: supcparse.c,v 1.7 2001/05/04 22:16:16 millert Exp $	*/
d269 2
a270 1
	if (fprintf(fp, "%u\n", tstamp) < 0)
d272 1
@


1.8.6.1
log
@MFC:
Fixes by tedu@@ and beck@@

fp leak.  from Patrick Latifi.
and
millert's sup fix, tested here on client and server.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supcparse.c,v 1.8 2002/02/16 21:27:54 millert Exp $	*/
d269 1
a269 2
	if (fprintf(fp, "%u\n", tstamp) < 0) {
		(void) fclose(fp);
a270 1
	}
@


1.8.4.1
log
@MFC:
Fixes by tedu@@ and beck@@

fp leak.  from Patrick Latifi.
and
millert's sup fix, tested here on client and server.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supcparse.c,v 1.8 2002/02/16 21:27:54 millert Exp $	*/
d269 1
a269 2
	if (fprintf(fp, "%u\n", tstamp) < 0) {
		(void) fclose(fp);
a270 1
	}
@


1.7
log
@o kill register
o lots of KNF
o passes -Wall
o fix some [ug]id_t vs. int issues
o use strlcpy/strlcat in favor of strncpy/strncat
o use mem* routines everywhere instead of old b* ones
o marked several questionable things for later fixing
o kill ci.c and cvt.c -- we don't use them
o kill read_line.c since it requires fgetln() (bad for portability)
o kill salloc.c since it is the same as strup()
o Replaced some #ifdef __OpenBSD__ with better tests
o remaining problems: malloc return values are rarely checked, select misuse
@
text
@d1 1
a1 1
/*	$OpenBSD: supcparse.c,v 1.6 2001/05/02 22:56:53 millert Exp $	*/
d102 1
a102 1
static void passdelim __P((char **, int ));
@


1.6
log
@Sync with NetBSD.  Notable changes:
 o Add libwrap support to supfilesrv, conditioned by #ifdef LIBWRAP
   (on by default). <bouyer@@netbsd.org>
 o Renamed '-l' (the 'live' mode) to '-d' and '-l' is now used to
   enable logging of successfull connections. <bouyer@@netbsd.org>
 o Don't botch varargs: the are not always an array of void * in the stack...
   Write a separate function to convert a list of function parameters to
   explain why execv failed. <christos@@netbsd.org>
 o When in compress mode, don't overwrite the destination file directly,
   write a temp file and use rename when it is done. (From James Mathiesen
   <james@@deshaw.com>)
 o Rename errno variable to error to avoid collision with errno.h and remove
   explicit extern of errno (we get it from errno.h) <mycroft@@netbsd.org>
 o Cleanup unsigned char vs. char
 o Add -u flag, that prevents sup from attempting to restore a and m times
   on the received files.
 o Replace the provided read_line function with calls to the fparseln function
   in libutil.  Maintain compatibility on machines without fparseln through
   the NEED_READ_LINE define.
 o Rename login() to suplogin() to avoid name collition in util.h
 o If rmdir() fails, chmod the path to have r/w/x perms and run "rm -rf"
 o avoid last.temp filename collision by using rel-suffix
 o When creating directories, make sure you remove previous non-directories
   before doing so, otherwise sup fails.
 o Add -q flag to supscan for quiet operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: supcparse.c,v 1.5 2001/04/29 21:52:16 millert Exp $	*/
d104 3
a106 2
static void passdelim (ptr,delim)		/* skip over delimiter */
char **ptr,delim;
d108 1
a108 1
	*ptr = skipover (*ptr, " \t");
d111 1
a111 1
		*ptr = skipover (*ptr, " \t");
d115 4
a118 3
int parsecoll(c,collname,args)
COLLECTION *c;
char *collname,*args;
d120 2
a121 2
	register char *arg,*p;
	register OPTION option;
d125 1
a125 1
	c->Cname = salloc (collname);
d140 2
a141 2
	args = skipover (args," \t");
	while (*(arg=nxtarg(&args," \t="))) {
d143 1
a143 1
			if (strcmp (arg,options[opno].op_name) == 0)
d146 3
a148 3
			logerr ("Invalid supfile option %s for collection %s",
				arg,c->Cname);
			return(-1);
d153 1
a153 1
			passdelim (&args,'=');
d155 2
a156 2
				arg = nxtarg (&args,", \t");
				(void) Tinsert (&c->Chtree,arg,FALSE);
d158 3
a160 2
				p = skipover (args," \t");
				if (*p++ == ',')  args = p;
d164 3
a166 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			c->Cbase = salloc (arg);
d169 3
a171 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			c->Chbase = salloc (arg);
d174 3
a176 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			c->Cprefix = salloc (arg);
d179 3
a181 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			c->Crelease = salloc (arg);
d184 3
a186 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			c->Cnotify = salloc (arg);
d189 3
a191 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			c->Clogin = salloc (arg);
d194 3
a196 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			c->Cpswd = salloc (arg);
d199 3
a201 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			c->Ccrypt = salloc (arg);
d225 3
a227 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			c->Ctimeout = atoi (arg);
d231 1
a231 1
	return(0);
a233 1

d243 1
a243 1
	(void) snprintf (buf,sizeof buf,FILEWHEN,collection,relsuffix);
d256 1
a256 1
		return 0;
d258 1
a258 1
	return tstamp;
d268 1
a268 1
		return 0;
d270 1
a270 1
		return 0;
d272 2
a273 2
		return 0;
	return 1;
@


1.5
log
@Add a bunch of old revision history comments that we are missing to
make diffing easier.  No code changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: supcparse.c,v 1.4 1997/09/16 10:42:57 deraadt Exp $	*/
d267 1
a267 1
	if (fprintf(fp, "%ld\n", tstamp) < 0)
@


1.4
log
@snprintf this thing
@
text
@d1 1
a1 1
/*	$OpenBSD: supcparse.c,v 1.3 1997/04/01 07:35:38 todd Exp $	*/
d19 1
a19 1
 *  Software Distribution Coordinator  or  Software_Distribution@@CS.CMU.EDU
d35 14
@


1.3
log
@This merges in the latest NetBSD sup source.
- removed $Log: ...$ tags to not waste space in the repository
- now doesn't segfault on the alpha!

Note:
To compile sup on systems other than *BSD, you'll need a copy of
vis.c, vis.h, daemon.c, and sys/cdefs.h.  At least the first two
(for OSF/1).

From NetBSD changelog description (for credit where due):
.... 1996/12/23 19:42:05  christos
- add missing prototypes.
- fix function call inconsistencies
- fix int <-> long and pointer conversions
It should run now on 64 bit machines...

....  1996/12/31 18:08:00  christos
64 bit patches (mostly long -> time_t) from Matthew Jacob (?)
sup now works on the alpha!
@
text
@d1 1
a1 1
/*	$OpenBSD: supcparse.c,v 1.2 1996/06/26 05:39:53 deraadt Exp $	*/
d227 1
a227 1
	(void) sprintf (buf,FILEWHEN,collection,relsuffix);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a35 28
 * $Log: supcparse.c,v $
 * Revision 1.1  1995/12/16 11:46:58  deraadt
 * add sup to the tree
 *
 * Revision 1.4  1995/06/09 04:33:34  christos
 * fixed bug related to the ascii `when' files previous fix, where the -t
 * option would fail to read the timestamp files.
 *
 * Revision 1.2  1993/08/04  17:46:20  brezak
 * Changes from nate for gzip'ed sup
 *
 * Revision 1.1.1.1  1993/05/21  14:52:18  cgd
 * initial import of CMU's SUP to NetBSD
 *
 * Revision 1.6  92/08/11  12:07:38  mrt
 * 	Added use-rel-suffix option corresponding to -u switch.
 * 	[92/07/26            mrt]
 * 
 * Revision 1.5  92/02/08  18:24:19  mja
 * 	Added "keep" supfile option, corresponding to -k switch.
 * 	[92/01/17            vdelvecc]
 * 
 * Revision 1.4  91/05/16  14:49:50  ern
 * 	Change default timeout from none to 3 hours so we don't accumalute 
 * 	processes running sups to dead hosts especially for users.
 * 	[91/05/16  14:49:21  ern]
 * 
 *
d49 1
d69 17
a85 17
	"host",		OHOST,
	"base",		OBASE,
	"hostbase",	OHOSTBASE,
	"prefix",	OPREFIX,
	"release",	ORELEASE,
	"notify",	ONOTIFY,
	"login",	OLOGIN,
	"password",	OPASSWORD,
	"crypt",	OCRYPT,
	"backup",	OBACKUP,
	"delete",	ODELETE,
	"execute",	OEXECUTE,
	"old",		OOLD,
	"timeout",	OTIMEOUT,
	"keep",		OKEEP,
	"use-rel-suffix", OURELSUF,
 	"compress", 	OCOMPRESS
d88 3
a90 1
passdelim (ptr,delim)		/* skip over delimiter */
d100 1
a100 1
parsecoll(c,collname,args)
d218 1
a218 1
long
d225 1
a225 1
	long tstamp;
d248 1
a248 1
	long tstamp;
@


1.1
log
@add sup to the tree
@
text
@d1 2
d37 3
@
