head	1.24;
access;
symbols
	OPENBSD_4_8:1.23.0.12
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.8
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.10
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.20.0.10
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.8
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.6
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.4
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.12
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.24
date	2010.10.18.20.54.00;	author deraadt;	state dead;
branches;
next	1.23;

1.23
date	2007.11.25.16.40.03;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.17.20.10.44;	author chl;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.27.18.13.16;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.31.15.48.26;	author pedro;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.23.03.48.43;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.09.00.45.38;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.14.21.35.00;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.19.19.39.39;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.04.22.16.16;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.02.22.56.53;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.29.21.52.16;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.06.03.16.20.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.09.16.11.01.19;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.09.16.10.42.52;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.04.01.07.35.32;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.18.06;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.07.31.11.11.27;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.39.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.16.11.46.56;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@sup is no longer used. reminded by pirofti and jmc
@
text
@/*	$OpenBSD: supcmain.c,v 1.23 2007/11/25 16:40:03 jmc Exp $	*/

/*
 * Copyright (c) 1992 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 *	sup -- Software Upgrade Protocol client process
 *
 *	Usage:  sup [ flags ] [ supfile ] [ collection ... ]
 *
 *	The only required argument to sup is the name of a supfile.  It
 *	must either be given explicitly on the command line, or the -s
 *	flag must be specified.  If the -s flag is given, the system
 *	supfile will be used and a supfile command argument should not be
 *	specified.  The list of collections is optional and if specified
 *	will be the only collections upgraded.  The following flags affect
 *	all collections specified.
 *
 *	-s	"system upgrade" flag
 *			As described above.
 *
 *	-t	"upgrade time" flag
 *			When this flag is given, Sup will print the time
 *			that each collection was last upgraded, rather than
 *			performing actual upgrades.
 *
 *	-u	"utimes" flag
 *			When this flag is given sup will not attempt to
 *			restore access and modification files on the
 *			collection files from the server.
 *
 *	-R	"resource pause" flag
 *			Sup will not disable resource pausing and will not
 *			make filesystem space checks.
 *
 *	-N	"debug network" flag
 *			Sup will trace messages sent and received that
 *			implement the Sup network protocol.
 *
 *	-P	"debug ports" flag
 *	    		Sup will use a set of non-privileged network
 *			ports reserved for debugging purposes.
 *
 *	-X	"crosspatch" flag
 *	    		Sup is being run remotely with a crosspatch.
 *			Need to be careful as we may be running as root
 *			instead of collection owner.
 *
 *	The remaining flags affect all collections unless an explicit list
 *	of collections are given with the flags.  Multiple flags may be
 *	specified together that affect the same collections.  For the sake
 *	of convenience, any flags that always affect all collections can be
 *	specified with flags that affect only some collections.  For
 *	example, "sup -sde=coll1,coll2" would perform a system upgrade,
 *	and the first two collections would allow both file deletions and
 *	command executions.  Note that this is not the same command as
 *	"sup -sde=coll1 coll2", which would perform a system upgrade of
 *	just the coll2 collection and would ignore the flags given for the
 *	coll1 collection.
 *
 *	-a	"all files" flag
 *			All files in the collection will be copied from
 *			the repository, regardless of their status on the
 *			current machine.  Because of this, it is a very
 *			expensive operation and should only be done for
 *			small collections if data corruption is suspected
 *			and been confirmed.  In most cases, the -o flag
 *			should be sufficient.
 *
 *	-b	"backup files" flag
 *			If the -b flag if given, or the "backup" supfile
 *			option is specified, the contents of regular files
 *			on the local system will be saved before they are
 *			overwritten with new data.  The data will be saved
 *			in a subdirectory called "BACKUP" in the directory
 *			containing the original version of the file, in a
 *			file with the same non-directory part of the file
 *			name.  The files to backup are specified by the
 *			list file on the repository.
 *
 *	-B	"don't backup files" flag
 *			The -B flag overrides and disables the -b flag and
 *			the "backup" supfile option.
 *
 *	-d	"delete files" flag
 *			Files that are no longer in the collection on the
 *			repository will be deleted if present on the local
 *			machine.  This may also be specified in a supfile
 *			with the "delete" option.
 *
 *	-D	"don't delete files" flag
 *			The -D flag overrides and disables the -d flag and
 *			the "delete" supfile option.
 *
 *	-e	"execute files" flag
 *			Sup will execute commands sent from the repository
 *			that should be run when a file is upgraded.  If
 *			the -e flag is omitted, Sup will print a message
 *			that specifies the command to execute.  This may
 *			also be specified in a supfile with the "execute"
 *			option.
 *
 *	-E	"don't execute files" flag
 *			The -E flag overrides and disables the -e flag and
 *			the "execute" supfile option.
 *
 *	-f	"file listing" flag
 *			A "list-only" upgrade will be performed.  Messages
 *			will be printed that indicate what would happen if
 *			an actual upgrade were done.
 *
 *	-k	"keep newer files" flag
 *			The -k flag, or "keep" supfile option, will cause
 *			Sup to check to see whether there is a newer file on
 *			the local disk before updating files.  Only files
 *			which are newer on the repository will be updated.
 *
 *	-K	"don't keep newer files" flag
 *			The -K flag overrides and disables the -k flag and
 *			the "keep" supfile option.
 *
 *	-l	"local upgrade" flag
 *			Normally, Sup will not upgrade a collection if the
 *			repository is on the same machine.  This allows
 *			users to run upgrades on all machines without
 *			having to make special checks for the repository
 *			machine.  If the -l flag is specified, collections
 *			will be upgraded even if the repository is local.
 *
 *	-m	"mail" flag
 *			Normally, Sup used standard output for messages.
 *			If the -m flag if given, Sup will send mail to the
 *			user running Sup, or a user specified with the
 *			"notify" supfile option, that contains messages
 *			printed by Sup.
 *
 *	-o	"old files" flag
 *			Sup will normally only upgrade files that have
 *			changed on the repository since the last time an
 *			upgrade was performed.  The -o flag, or the "old"
 *			supfile option, will cause Sup to check all files
 *			in the collection for changes instead of just the
 *			new ones.
 *
 *	-O	"not old files" flag
 *			The -O flag overrides and disables the -o flag and
 *			the "old" supfile option.
 *
 *	-v	"verbose" flag
 *			Normally, Sup will only print messages if there
 *			are problems.  This flag causes Sup to also print
 *			messages during normal progress showing what Sup
 *			is doing.
 *
 **********************************************************************
 * HISTORY
 *
 * 7-July-93  Nate Williams at Montana State University
 *	Modified SUP to use gzip based compression when sending files
 *	across the network to save BandWidth
 *
 * Revision 1.6  92/08/11  12:06:59  mrt
 * 	Merged in Brad's changes. Made resource pausing code conditional
 * 	on MACH, rather than CMUCS. Fixed some calls to sprintf to
 * 	return void.
 * 	[92/08/09            mrt]
 * 
 * Revision 1.5  92/02/08  19:01:18  mja
 * 	Correct oldsigsys type when ANSI C.
 * 	[92/02/08  18:59:47  mja]
 * 
 * Revision 1.4  92/02/08  18:24:01  mja
 * 	Added -k and -K switches.
 * 	[92/01/17            vdelvecc]
 * 
 * 27-Dec-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added crosspatch support (is currently ignored).
 *
 * 28-Jun-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code for "release" support.
 *
 * 25-May-87  Doug Philips (dwp) at Carnegie-Mellon University
 *	Split into several files.  This is the main program and
 *	command line processing and old history log. [V5.21]
 *
 * 21-May-87  Chriss Stephens (chriss) at Carnegie Mellon University
 *	Merged divergent CS and ECE versions. ifdeffed out the resource
 *	pausing code - only compiled in if CMUCS defined. [V5.21a]
 *
 * 20-May-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Removed support for version 3 of SUP protocol.  Added changes
 *	to make lint happy.  Added calls to new logging routines. [V5.20]
 *
 * 01-Apr-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added -R switch to reenable resource pausing, which is currently
 *	disabled by default.  Added code to check for free disk space
 *	available on the target filesystem so that sup shouldn't run the
 *	system out of disk space as frequently. [V5.19]
 *
 * 19-Sep-86  Mike Accetta (mja) at Carnegie-Mellon University
 *	Changed default supfile name for system collections when -t
 *	is specified to use FILESUPTDEFAULT; added missing new-line
 *	in retry message. [V5.18]
 *
 * 21-Jun-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Missed a caller to a routine which had an extra argument added
 *	to it last edit. [V5.17]
 *
 * 07-Jun-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Changed getcoll() so that fatal errors are checked immediately
 *	instead of after sleeping for a little while.  Changed all
 *	rm -rf commands to rmdir since the Mach folks keep deleting
 *	their root and /usr directory trees.  Reversed the order of
 *	delete commands to that directories will possibly empty so
 *	that the rmdir's work. [V5.16]
 *
 * 30-May-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Changed temporary file names to #n.sup format. [V5.15]
 *
 * 19-Feb-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Moved PGMVERSION to supvers.c module. [V5.14]
 *
 * 06-Feb-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added check for file type before unlink when receiving a
 *	symbolic link.  Now runs "rm -rf" if the file type is a
 *	directory. [V5.13]
 *
 * 03-Feb-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Fixed small bug in signon that didn't retry connections if an
 *	error occurred on the first attempt to connect. [V5.12]
 *
 * 26-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	New command interface.  Added -bBDEO flags and "delete",
 *	"execute" and "old" supfile options.  Changed -d to work
 *	correctly without implying -o. [V5.11]
 *
 * 21-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Fix incorrect check for supfile changing.  Flush output buffers
 *	before restart. [V5.10]
 *
 * 17-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Add call to requestend() after connection errors are retried to
 *	free file descriptors. [V5.9]
 *
 * 15-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Fix SERIOUS merge error from previous edit.  Added notify
 *	when execute command fails. [V5.8]
 *
 * 11-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Changed ugconvert to clear setuid/setgid bits if it doesn't use
 *	the user and group specified by the remote system.  Changed
 *	execute code to invalidate collection if execute command returns
 *	with a non-zero exit status.  Added support for execv() of
 *	original arguments of supfile is upgraded successfully.  Changed
 *	copyfile to always use a temp file if possible. [V5.7]
 *
 * 04-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added support for fileserver busy messages and new nameserver
 *	protocol to support multiple repositories per collection.
 *	Added code to lock collections with lock files. [V5.6]
 *
 * 29-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Major rewrite for protocol version 4. [V4.5]
 *
 * 12-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Changed to check for DIFFERENT mtime (again). [V3.4]
 *
 * 08-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Replaced [ug]convert routines with ugconvert routine so that an
 *	appropriate group will be used if the default user is used.
 *	Changed switch parsing to allow multiple switches to be specified
 *	at the same time. [V3.3]
 *
 * 04-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added test to request a new copy of an old file that already
 *	exists if the mtime is different. [V3.2]
 *
 * 24-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added -l switch to enable upgrades from local repositories.
 *
 * 03-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Minor change in order -t prints so that columns line up.
 *
 * 22-Oct-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code to implement retry flag and pass this on to request().
 *
 * 22-Sep-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Merged 4.1 and 4.2 versions together.
 *
 * 04-Jun-85  Steven Shafer (sas) at Carnegie-Mellon University
 *	Created for 4.2 BSD.
 *
 **********************************************************************
 */

#define MSGFILE
#include "supcdefs.h"
#if	MACH
#include <sys/syscall.h>
#ifndef SYS_rpause
#define SYS_rpause	(-5)
#endif
#endif
#include "supextern.h"

/*********************************************
 ***    G L O B A L   V A R I A B L E S    ***
 *********************************************/

char program[] = "SUP";			/* program name for SCM messages */
pid_t progpid = -1;			/* and process id */

COLLECTION *firstC, *thisC;		/* collection list pointer */

extern int dontjump;			/* disable longjmp */
extern int scmdebug;			/* SCM debugging flag */

int silent;				/* silent run, print only errors */
int sysflag;				/* system upgrade flag */
int timeflag;				/* print times flag */
int noutime;				/* don't preserve utimes */
#if	MACH
int rpauseflag;				/* don't disable resource pausing */
#endif	/* MACH */
int xpatchflag;				/* crosspatched with remote system */
int portdebug;				/* network debugging ports */

int main(int, char **);
static int checkcoll(TREE *, void *);
static void doswitch(char *, TREE **, int *, int *);
static char *init(int, char **);

/*************************************
 ***    M A I N   R O U T I N E    ***
 *************************************/

int
main(argc, argv)
	int argc;
	char **argv;
{
	char *progname, *supfname;
	int restart, sfdev = 0, sfino = 0, sfmtime = 0;
	struct stat sbuf;
	struct sigaction ign;

	/* initialize global variables */
	pgmversion = PGMVERSION;	/* export version number */
	server = FALSE;			/* export that we're not a server */
	collname = NULL;		/* no current collection yet */
	dontjump = TRUE;		/* clear setjmp buffer */
	progname = strdup(argv[0]);

	supfname = init(argc, argv);
	restart = -1;			/* don't make restart checks */
	if (*progname == '/' && *supfname == '/') {
		if (stat(supfname, &sbuf) < 0) {
			logerr("Can't stat supfile %s", supfname);
		} else {
			sfdev = sbuf.st_dev;
			sfino = sbuf.st_ino;
			sfmtime = sbuf.st_mtime;
			restart = 0;
		}
	}
	if (timeflag) {
		for (thisC = firstC; thisC; thisC = thisC->Cnext)
			prtime();
	} else {
		/* ignore network pipe signals */
		memset(&ign, 0, sizeof ign);
		ign.sa_handler = SIG_IGN;
		ign.sa_flags = 0;
		sigemptyset(&ign.sa_mask);
		(void) sigaction(SIGPIPE,&ign,NULL);
		getnams();		/* find unknown repositories */
		for (thisC = firstC; thisC; thisC = thisC->Cnext) {
			getcoll();	/* upgrade each collection */
			if (restart == 0) {
				if (stat(supfname,&sbuf) < 0)
					logerr("Can't stat supfile %s",
						supfname);
				else if (sfmtime != sbuf.st_mtime ||
					 sfino != sbuf.st_ino ||
					 sfdev != sbuf.st_dev) {
					restart = 1;
					break;
				}
			}
		}
		endpwent();		/* close /etc/passwd */
		endgrent();		/* close /etc/group */
		if (restart == 1) {
			if (!silent)
				loginfo("SUP Restarting %s with new supfile %s",
					progname, supfname);
			closefrom(4);
			execv(progname, argv);
			logquit(1, "Restart failed");
		}
	}
	while ((thisC = firstC) != NULL) {
		firstC = firstC->Cnext;
		free(thisC->Cname);
		Tfree(&thisC->Chtree);
		free(thisC->Cbase);
		if (thisC->Chbase)
			free(thisC->Chbase);
		if (thisC->Cprefix)
			free(thisC->Cprefix);
		if (thisC->Crelease)
			free(thisC->Crelease);
		if (thisC->Cnotify)
			free(thisC->Cnotify);
		if (thisC->Clogin)
			free(thisC->Clogin);
		if (thisC->Cpswd)
			free(thisC->Cpswd);
		if (thisC->Ccrypt)
			free(thisC->Ccrypt);
		free (thisC);
	}
	exit (0);
}

/*****************************************
 ***    I N I T I A L I Z A T I O N    ***
 *****************************************/
/*
 * Set up collection list from supfile.  Check all fields except
 * hostname to be sure they make sense.
 */

#define Toflags	Tflags
#define Taflags	Tmode
#define Twant	Tuid
#define Tcount	Tgid

static void
doswitch(argp, collTp, oflagsp, aflagsp)
	char *argp;
	TREE **collTp;
	int *oflagsp, *aflagsp;
{
	TREE *t;
	char *coll;
	int oflags,aflags;

	oflags = aflags = 0;
	for (;;) {
		switch (*argp) {
		default:
			logerr("Invalid flag '%c' ignored", *argp);
			break;
		case '\0':
		case '=':
			if (*argp++ == '\0' || *argp == '\0') {
				*oflagsp |= oflags;
				*oflagsp &= ~aflags;
				*aflagsp |= aflags;
				*aflagsp &= ~oflags;
				return;
			}
			do {
				coll = nxtarg(&argp, ", \t");
				t = Tinsert(collTp, coll, TRUE);
				t->Toflags |= oflags;
				t->Toflags &= ~aflags;
				t->Taflags |= aflags;
				t->Taflags &= ~oflags;
				argp = skipover(argp, ", \t");
			} while (*argp);
			return;
		case 'N':
			scmdebug++;
			break;
		case 'P':
			portdebug = TRUE;
			break;
		case 'R':
#if	MACH
			rpauseflag = TRUE;
#endif	/* MACH */
			break;
		case 'X':
			xpatchflag = TRUE;
			break;
		case 'S':
			silent = TRUE;
			break;
		case 's':
			sysflag = TRUE;
			break;
		case 't':
			timeflag = TRUE;
			break;
		case 'a':
			oflags |= CFALL;
			break;
		case 'b':
			oflags |= CFBACKUP;
			aflags &= ~CFBACKUP;
			break;
		case 'B':
			oflags &= ~CFBACKUP;
			aflags |= CFBACKUP;
			break;
		case 'd':
			oflags |= CFDELETE;
			aflags &= ~CFDELETE;
			break;
		case 'D':
			oflags &= ~CFDELETE;
			aflags |= CFDELETE;
			break;
		case 'e':
			oflags |= CFEXECUTE;
			aflags &= ~CFEXECUTE;
			break;
		case 'E':
			oflags &= ~CFEXECUTE;
			aflags |= CFEXECUTE;
			break;
		case 'f':
			oflags |= CFLIST;
			break;
		case 'k':
			oflags |= CFKEEP;
			aflags &= ~CFKEEP;
			break;
		case 'K':
			oflags &= ~CFKEEP;
			aflags |= CFKEEP;
			break;
		case 'l':
			oflags |= CFLOCAL;
			break;
		case 'm':
			oflags |= CFMAIL;
			break;
		case 'o':
			oflags |= CFOLD;
			aflags &= ~CFOLD;
			break;
		case 'O':
			oflags &= ~CFOLD;
			aflags |= CFOLD;
			break;
		case 'u':
			noutime = TRUE;
			break;
		case 'v':
			oflags |= CFVERBOSE;
			break;
		case 'V':
			oflags |= CFVERBOSE|CFVERBOSE2;
			break;
		case 'z':
			oflags |= CFCOMPRESS;
			break;
		case 'Z':
			oflags &= ~CFCOMPRESS;
			break;
		}
		argp++;
	}
}

static char *
init(argc, argv)
	int argc;
	char **argv;
{
	char buf[STRINGLENGTH], *p;
	char username[STRINGLENGTH];
	char *supfname, *arg;
	COLLECTION *c, *lastC;
	FILE *f;
	int bogus;
	struct passwd *pw;
	TREE *t;
	TREE *collT;			/* collections we are interested in */
	time_t timenow;			/* startup time */
	int oflags, aflags;
	int cwant;
#ifdef	MACH
	void (*oldsigsys)();
#endif /* MACH */

	sysflag = FALSE;		/* not system upgrade */
	timeflag = FALSE;		/* don't print times */
#if	MACH
	rpauseflag = FALSE;		/* don't disable resource pausing */
#endif	/* MACH */
	xpatchflag = FALSE;		/* not normally crosspatched */
	scmdebug = 0;			/* level zero, no SCM debugging */
	portdebug = FALSE;		/* no debugging ports */

	collT = NULL;
	oflags = aflags = 0;
	while (argc > 1 && argv[1][0] == '-' && argv[1][1] != '\0') {
		doswitch(&argv[1][1], &collT, &oflags, &aflags);
		--argc;
		argv++;
	}
	if (argc == 1 && !sysflag)
		logquit (1, "Need either -s or supfile");
#if	MACH
	oldsigsys = signal(SIGSYS,SIG_IGN);
	if (rpauseflag != TRUE)
		if (syscall(SYS_rpause, ENOSPC, RPAUSE_ALL, RPAUSE_DISABLE) < 0)
		rpauseflag = TRUE;
	(void) signal(SIGSYS, oldsigsys);
#endif	/* MACH */
	if (sysflag) {
		(void) snprintf (buf, sizeof buf,
			timeflag ? FILESUPTDEFAULT : FILESUPDEFAULT, DEFDIR);
		supfname = buf;
	} else {
		supfname = argv[1];
		if (strcmp(supfname, "-") == 0)
			supfname = "";
		--argc;
		argv++;
	}
	cwant = argc > 1;
	while (argc > 1) {
		t = Tinsert(&collT, argv[1], TRUE);
		t->Twant = TRUE;
		--argc;
		argv++;
	}
	if ((p = getlogin()) ||
	    ((pw = getpwuid(getuid())) && (p = pw->pw_name))) {
		(void) strlcpy(username, p, sizeof username);
	} else
		*username = '\0';
	if (*supfname) {
		f = fopen(supfname, "r");
		if (f == NULL)
			logquit(1, "Can't open supfile %s", supfname);
	} else
		f = stdin;
	firstC = NULL;
	lastC = NULL;
	bogus = FALSE;
	while ((p = fgets(buf, sizeof(buf), f)) != NULL) {
		p[strcspn(p, "\n")] = '\0';
		if (strchr("#;:", *p))
			continue;
		arg = nxtarg (&p, " \t");
		if (*arg == '\0') {
			logerr("Missing collection name in supfile");
			bogus = TRUE;
			continue;
		}
		if (cwant) {
			TREE *t;
			if ((t = Tsearch(collT, arg)) == NULL)
				continue;
			t->Tcount++;
		}
		c = (COLLECTION *) malloc(sizeof(COLLECTION));
		if (firstC == NULL)
			firstC = c;
		if (lastC != NULL)
			lastC->Cnext = c;
		lastC = c;
		if (parsecoll(c,arg,p) < 0) {
			bogus = TRUE;
			continue;
		}
		c->Cflags |= oflags;
		c->Cflags &= ~aflags;
		if ((t = Tsearch(collT, c->Cname)) != NULL) {
			c->Cflags |= t->Toflags;
			c->Cflags &= ~t->Taflags;
		}
		if ((c->Cflags&CFMAIL) && c->Cnotify == NULL) {
			if (*username == '\0')
				logerr("User unknown, notification disabled");
			else
				c->Cnotify = strdup(username);
		}
		if (c->Cbase == NULL) {
			(void) snprintf(buf, sizeof buf,
				FILEBASEDEFAULT, c->Cname);
			c->Cbase = strdup(buf);
		}
	}
	if (bogus)
		logquit(1, "Aborted due to supfile errors");
	if (f != stdin)
		(void) fclose(f);
	if (cwant)
		(void) Tprocess(collT, checkcoll, NULL);
	Tfree (&collT);
	if (firstC == NULL)
		logquit(1, "No collections to upgrade");
	timenow = time(NULL);
	if (*supfname == '\0')
		p = "standard input";
	else if (sysflag)
		p = "system software";
	else {
		(void) snprintf(buf, sizeof buf, "file %s", supfname);
		p = buf;
	}
	if (!silent)
		loginfo("SUP %d.%d (%s) for %s at %s", PROTOVERSION, PGMVERSION,
			scmversion, p, fmttime(timenow));
	return (strdup(supfname));
}

static int
checkcoll(t, dummy)
	TREE *t;
	void *dummy;
{
	if (!t->Twant)
		return (SCMOK);
	if (t->Tcount == 0)
		logerr("Collection %s not found",t->Tname);
	if (t->Tcount > 1)
		logerr("Collection %s found more than once", t->Tname);
	return (SCMOK);
}
@


1.23
log
@spelling fixes, from Martynas Venckus;
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.22 2007/10/17 20:10:44 chl Exp $	*/
@


1.22
log
@remove "unused variable" warnings

tested by deraadt@@ on a gcc2 arch

looks ok ray@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.21 2007/09/11 15:47:17 gilles Exp $	*/
d67 1
a67 1
 *			Need to be carefull as we may be running as root
@


1.21
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.20 2005/04/27 18:13:16 mickey Exp $	*/
d595 1
a595 1
	char buf[STRINGLENGTH], *p, *q;
@


1.20
log
@make -v print only actual changes and add -V for old behaviour; beck@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.19 2004/05/31 15:48:26 pedro Exp $	*/
d669 1
a669 2
		if ((q = strchr(p, '\n')))
			*q = '\0';
@


1.19
log
@zap unused variables, ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.18 2004/01/23 03:48:43 deraadt Exp $	*/
d575 3
@


1.18
log
@Use closefrom(); ok millert tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.17 2002/12/09 00:45:38 millert Exp $	*/
a414 2
			int fd;

@


1.17
log
@From Andrushock, s/sucess/success/g
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.16 2002/06/14 21:35:00 todd Exp $	*/
d420 1
a420 2
			for (fd = getdtablesize(); fd > 3; fd--)
				(void) close(fd);
@


1.16
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.15 2002/06/12 06:07:16 mpech Exp $	*/
d275 1
a275 1
 *	original arguments of supfile is upgraded sucessfully.  Changed
@


1.15
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.14 2002/02/19 19:39:39 millert Exp $	*/
d73 1
a73 1
 *	of convience, any flags that always affect all collections can be
@


1.14
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.13 2002/02/16 21:27:54 millert Exp $	*/
d332 1
a332 1
int progpid = -1;			/* and process id */
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.12 2001/09/19 10:58:07 mpech Exp $	*/
a607 1
#ifdef	__STDC__
a608 3
#else
	int (*oldsigsys)();
#endif
@


1.12
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.11 2001/05/04 22:16:16 millert Exp $	*/
d349 4
a352 4
int main __P((int, char **));
static int checkcoll __P((TREE *, void *));
static void doswitch __P((char *, TREE **, int *, int *));
static char *init __P((int, char **));
@


1.11
log
@o kill register
o lots of KNF
o passes -Wall
o fix some [ug]id_t vs. int issues
o use strlcpy/strlcat in favor of strncpy/strncat
o use mem* routines everywhere instead of old b* ones
o marked several questionable things for later fixing
o kill ci.c and cvt.c -- we don't use them
o kill read_line.c since it requires fgetln() (bad for portability)
o kill salloc.c since it is the same as strup()
o Replaced some #ifdef __OpenBSD__ with better tests
o remaining problems: malloc return values are rarely checked, select misuse
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.10 2001/05/02 22:56:53 millert Exp $	*/
d251 1
a251 1
 *	error occured on the first attempt to connect. [V5.12]
@


1.10
log
@Sync with NetBSD.  Notable changes:
 o Add libwrap support to supfilesrv, conditioned by #ifdef LIBWRAP
   (on by default). <bouyer@@netbsd.org>
 o Renamed '-l' (the 'live' mode) to '-d' and '-l' is now used to
   enable logging of successfull connections. <bouyer@@netbsd.org>
 o Don't botch varargs: the are not always an array of void * in the stack...
   Write a separate function to convert a list of function parameters to
   explain why execv failed. <christos@@netbsd.org>
 o When in compress mode, don't overwrite the destination file directly,
   write a temp file and use rename when it is done. (From James Mathiesen
   <james@@deshaw.com>)
 o Rename errno variable to error to avoid collision with errno.h and remove
   explicit extern of errno (we get it from errno.h) <mycroft@@netbsd.org>
 o Cleanup unsigned char vs. char
 o Add -u flag, that prevents sup from attempting to restore a and m times
   on the received files.
 o Replace the provided read_line function with calls to the fparseln function
   in libutil.  Maintain compatibility on machines without fparseln through
   the NEED_READ_LINE define.
 o Rename login() to suplogin() to avoid name collition in util.h
 o If rmdir() fails, chmod the path to have r/w/x perms and run "rm -rf"
 o avoid last.temp filename collision by using rel-suffix
 o When creating directories, make sure you remove previous non-directories
   before doing so, otherwise sup fails.
 o Add -q flag to supscan for quiet operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.9 2001/04/29 21:52:16 millert Exp $	*/
d334 1
a334 1
COLLECTION *firstC,*thisC;		/* collection list pointer */
d359 3
a361 3
main (argc, argv)
int argc;
char **argv;
d363 2
a364 2
	char *progname,*supfname;
	int restart,sfdev = 0,sfino = 0, sfmtime = 0;
d373 1
a373 1
	progname = salloc (argv[0]);
d375 1
a375 1
	supfname = init (argc,argv);
d378 3
a380 4
		if (stat (supfname,&sbuf) < 0) {
			logerr ("Can't stat supfile %s",supfname);
		}
		else {
d389 1
a389 1
			prtime ();
d396 2
a397 2
		(void) sigaction (SIGPIPE,&ign,NULL);
		getnams ();		/* find unknown repositories */
d399 1
a399 1
			getcoll ();	/* upgrade each collection */
d401 2
a402 2
				if (stat (supfname,&sbuf) < 0)
					logerr ("Can't stat supfile %s",
d412 2
a413 2
		endpwent ();		/* close /etc/passwd */
		(void) endgrent ();	/* close /etc/group */
d416 1
d419 5
a423 5
					progname,supfname);
			for (fd = getdtablesize (); fd > 3; fd--)
				(void) close (fd);
			execv (progname,argv);
			logquit (1,"Restart failed");
d428 18
a445 11
		free (thisC->Cname);
		Tfree (&thisC->Chtree);
		free (thisC->Cbase);
		if (thisC->Chbase)  free (thisC->Chbase);
		if (thisC->Cprefix)  free (thisC->Cprefix);
		if (thisC->Crelease)  free (thisC->Crelease);
		if (thisC->Cnotify)  free (thisC->Cnotify);
		if (thisC->Clogin)  free (thisC->Clogin);
		if (thisC->Cpswd)  free (thisC->Cpswd);
		if (thisC->Ccrypt)  free (thisC->Ccrypt);
		free ((char *)thisC);
d453 2
a454 1
/* Set up collection list from supfile.  Check all fields except
d463 5
a467 4
static void doswitch (argp,collTp,oflagsp,aflagsp)
char *argp;
register TREE **collTp;
int *oflagsp,*aflagsp;
d469 3
a471 3
	register TREE *t;
	register char *coll;
	register int oflags,aflags;
d477 1
a477 1
			logerr ("Invalid flag '%c' ignored",*argp);
d489 2
a490 2
				coll = nxtarg (&argp,", \t");
				t = Tinsert (collTp,coll,TRUE);
d495 1
a495 1
				argp = skipover (argp,", \t");
d590 4
a593 3
static char *init (argc,argv)
int argc;
char **argv;
d595 1
a595 1
	char buf[STRINGLENGTH],*p;
d597 6
a602 6
	register char *supfname,*q,*arg;
	register COLLECTION *c,*lastC;
	register FILE *f;
	register int bogus;
	register struct passwd *pw;
	register TREE *t;
d605 1
a605 1
	int oflags,aflags;
d627 1
a627 1
		doswitch (&argv[1][1],&collT,&oflags,&aflags);
d632 1
a632 1
		logquit (1,"Need either -s or supfile");
d634 1
a634 1
	oldsigsys = signal (SIGSYS,SIG_IGN);
d636 1
a636 1
		if (syscall (SYS_rpause,ENOSPC,RPAUSE_ALL,RPAUSE_DISABLE) < 0)
d638 1
a638 1
	(void) signal (SIGSYS,oldsigsys);
d641 2
a642 3
		(void) snprintf (buf,sizeof buf,
			timeflag?FILESUPTDEFAULT:FILESUPDEFAULT,
			DEFDIR);
d646 1
a646 1
		if (strcmp (supfname,"-") == 0)
d653 1
a653 1
		t = Tinsert (&collT,argv[1],TRUE);
d659 2
a660 3
	    ((pw = getpwuid ((int)getuid())) && (p = pw->pw_name))) {
		(void) strncpy (username, p, sizeof username-1);
		username[sizeof username-1] = '\0';
d664 1
a664 1
		f = fopen (supfname,"r");
d666 1
a666 1
			logquit (1,"Can't open supfile %s",supfname);
d672 4
a675 2
	while ((p = read_line(f, NULL, NULL, NULL, 0)) != NULL) {
		if (strchr ("#;:", *p))
d677 1
a677 1
		arg = nxtarg (&p," \t");
d679 1
a679 1
			logerr ("Missing collection name in supfile");
d684 2
a685 2
			register TREE *t;
			if ((t = Tsearch (collT,arg)) == NULL)
d689 5
a693 3
		c = (COLLECTION *) malloc (sizeof(COLLECTION));
		if (firstC == NULL)  firstC = c;
		if (lastC != NULL) lastC->Cnext = c;
d701 1
a701 1
		if ((t = Tsearch (collT,c->Cname)) != NULL) {
d707 1
a707 1
				logerr ("User unknown, notification disabled");
d709 1
a709 1
				c->Cnotify = salloc (username);
d712 3
a714 3
			(void) snprintf (buf,sizeof buf,
				FILEBASEDEFAULT,c->Cname);
			c->Cbase = salloc (buf);
d717 6
a722 3
	if (bogus)  logquit (1,"Aborted due to supfile errors");
	if (f != stdin)  (void) fclose (f);
	if (cwant)  (void) Tprocess (collT,checkcoll, NULL);
d724 3
a726 2
	if (firstC == NULL)  logquit (1,"No collections to upgrade");
	timenow = time ((time_t *)NULL);
d732 1
a732 1
		(void) snprintf (buf,sizeof buf,"file %s",supfname);
d736 3
a738 3
	    loginfo ("SUP %d.%d (%s) for %s at %s",PROTOVERSION,PGMVERSION,
		    scmversion,p,fmttime (timenow));
	return (salloc (supfname));
d742 3
a744 3
checkcoll (t, dummy)
register TREE *t;
void *dummy;
d746 2
a747 1
	if (!t->Twant)  return (SCMOK);
d749 1
a749 1
		logerr ("Collection %s not found",t->Tname);
d751 1
a751 1
		logerr ("Collection %s found more than once",t->Tname);
@


1.9
log
@Add a bunch of old revision history comments that we are missing to
make diffing easier.  No code changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.8 1998/06/03 16:20:36 deraadt Exp $	*/
d48 5
d339 1
a339 1
int silent;				/* Silent run, print only errors */
d342 1
d564 3
d649 1
a649 1
	if ((p = (char *)getlogin()) ||
d651 1
a651 1
		(void) strncpy (username,p, sizeof username-1);
d664 3
a666 4
	while ((p = fgets (buf,STRINGLENGTH,f)) != NULL) {
		q = strchr (p,'\n');
		if (q)  *q = '\0';
		if (strchr ("#;:",*p))  continue;
@


1.8
log
@zero sigaction before use
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.7 1997/09/16 11:01:19 deraadt Exp $	*/
d19 1
a19 1
 *  Software Distribution Coordinator  or  Software_Distribution@@CS.CMU.EDU
d178 14
@


1.7
log
@strcpy whacking; ci.c and expand.c need more work
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.6 1997/09/16 10:42:52 deraadt Exp $	*/
d373 1
@


1.6
log
@snprintf this thing
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.5 1997/04/01 07:35:32 todd Exp $	*/
d626 4
a629 3
	    ((pw = getpwuid ((int)getuid())) && (p = pw->pw_name)))
		(void) strcpy (username,p);
	else
@


1.5
log
@This merges in the latest NetBSD sup source.
- removed $Log: ...$ tags to not waste space in the repository
- now doesn't segfault on the alpha!

Note:
To compile sup on systems other than *BSD, you'll need a copy of
vis.c, vis.h, daemon.c, and sys/cdefs.h.  At least the first two
(for OSF/1).

From NetBSD changelog description (for credit where due):
.... 1996/12/23 19:42:05  christos
- add missing prototypes.
- fix function call inconsistencies
- fix int <-> long and pointer conversions
It should run now on 64 bit machines...

....  1996/12/31 18:08:00  christos
64 bit patches (mostly long -> time_t) from Matthew Jacob (?)
sup now works on the alpha!
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.4 1997/01/17 07:18:06 millert Exp $	*/
d606 6
a611 5
	if (sysflag)
		(void) sprintf (supfname = buf,
				    timeflag?FILESUPTDEFAULT:FILESUPDEFAULT,
				    DEFDIR);
	else {
d676 2
a677 1
			(void) sprintf (buf,FILEBASEDEFAULT,c->Cname);
d691 4
a694 2
	else
		(void) sprintf (p = buf,"file %s",supfname);
@


1.4
log
@more r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.3 1996/07/31 11:11:27 niklas Exp $	*/
a177 36
 * $Log: supcmain.c,v $
 * Revision 1.3  1996/07/31 11:11:27  niklas
 * Better use time_t instead of long when dealing with times
 *
 * Revision 1.2  1996/06/26 05:39:51  deraadt
 * rcsid
 *
 * Revision 1.1  1995/12/16 11:46:56  deraadt
 * add sup to the tree
 *
 * Revision 1.4  1995/09/16 19:01:25  glass
 * if the function returns nothing, declare it void
 *
 * Revision 1.3  1993/08/04 17:46:17  brezak
 * Changes from nate for gzip'ed sup
 *
 * Revision 1.2  1993/05/24  17:57:28  brezak
 * Remove netcrypt.c. Remove unneeded files. Cleanup make.
 *
 * Revision 1.1.1.1  1993/05/21  14:52:18  cgd
 * initial import of CMU's SUP to NetBSD
 *
 * Revision 1.6  92/08/11  12:06:59  mrt
 * 	Merged in Brad's changes. Made resource pausing code conditional
 * 	on MACH, rather than CMUCS. Fixed some calls to sprintf to
 * 	return void.
 * 	[92/08/09            mrt]
 * 
 * Revision 1.5  92/02/08  19:01:18  mja
 * 	Correct oldsigsys type when ANSI C.
 * 	[92/02/08  18:59:47  mja]
 * 
 * Revision 1.4  92/02/08  18:24:01  mja
 * 	Added -k and -K switches.
 * 	[92/01/17            vdelvecc]
 * 
d306 1
d320 1
d329 5
d338 2
a339 1
main (argc,argv)
a342 1
	char *init ();
d344 1
a344 1
	int restart,sfdev,sfino,sfmtime;
d346 1
a346 1
	struct sigvec ignvec,oldvec;
d358 1
a358 1
		if (stat (supfname,&sbuf) < 0)
d360 1
d373 4
a376 4
		ignvec.sv_handler = SIG_IGN;
		ignvec.sv_onstack = 0;
		ignvec.sv_mask = 0;
		(void) sigvec (SIGPIPE,&ignvec,&oldvec);
d396 3
a398 2
			loginfo ("SUP Restarting %s with new supfile %s",
				progname,supfname);
d405 1
a405 1
	while (thisC = firstC) {
d434 1
a434 1
void doswitch (argp,collTp,oflagsp,aflagsp)
d482 3
d557 1
a557 1
char *init (argc,argv)
a570 1
	int checkcoll ();
a579 1
	char *fmttime();
d638 1
a638 1
	while (p = fgets (buf,STRINGLENGTH,f)) {
d664 1
a664 1
		if (t = Tsearch (collT,c->Cname)) {
d681 1
a681 1
	if (cwant)  (void) Tprocess (collT,checkcoll);
d691 3
a693 2
	loginfo ("SUP %d.%d (%s) for %s at %s",PROTOVERSION,PGMVERSION,
		scmversion,p,fmttime (timenow));
d697 2
a698 1
checkcoll (t)
d700 1
@


1.3
log
@Better use time_t instead of long when dealing with times
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmain.c,v 1.2 1996/06/26 05:39:51 deraadt Exp $	*/
d179 3
d665 1
a665 1
		q = index (p,'\n');
d667 1
a667 1
		if (index ("#;:",*p))  continue;
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d179 3
d591 1
a591 1
	long timenow;			/* startup time */
d707 1
a707 1
	timenow = time ((long *)NULL);
@


1.1
log
@add sup to the tree
@
text
@d1 2
d179 3
@
