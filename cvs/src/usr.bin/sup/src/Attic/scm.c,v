head	1.20;
access;
symbols
	OPENBSD_4_8:1.19.0.12
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.8
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.10
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.12
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.10
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.8
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.6
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.6
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.20
date	2010.10.18.20.54.00;	author deraadt;	state dead;
branches;
next	1.19;

1.19
date	2007.09.02.15.19.35;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.10.01.36.37;	author cloder;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.12.04.22.23;	author beck;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.19.19.39.39;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.05.15.56.04;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.04.22.16.16;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.02.22.56.53;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.29.21.52.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.01.03.23.40;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.12.20.29.55;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	97.10.11.23.34.20;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	97.09.16.11.01.17;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.25.21.05.42;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.04.01.07.35.22;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	96.08.04.12.58.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.39.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.16.11.46.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@sup is no longer used. reminded by pirofti and jmc
@
text
@/*	$OpenBSD: scm.c,v 1.19 2007/09/02 15:19:35 deraadt Exp $	*/

/*
 * Copyright (c) 1992 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 * SUP Communication Module for 4.3 BSD
 *
 * SUP COMMUNICATION MODULE SPECIFICATIONS:
 *
 * IN THIS MODULE:
 *
 * CONNECTION ROUTINES
 *
 *   FOR SERVER
 *	servicesetup (port)	establish TCP port connection
 *	  char *port;			name of service
 *	service ()		accept TCP port connection
 *	servicekill ()		close TCP port in use by another process
 *	serviceprep ()		close temp ports used to make connection
 *	serviceend ()		close TCP port
 *
 *   FOR CLIENT
 *	request (port,hostname,retry) establish TCP port connection
 *	  char *port,*hostname;		  name of service and host
 *	  int retry;			  true if retries should be used
 *	requestend ()		close TCP port
 *
 * HOST NAME CHECKING
 *	p = remotehost ()	remote host name (if known)
 *	  char *p;
 *	i = samehost ()		whether remote host is also this host
 *	  int i;
 *	i = matchhost (name)	whether remote host is same as name
 *	  int i;
 *	  char *name;
 *
 * RETURN CODES
 *	All procedures return values as indicated above.  Other routines
 *	normally return SCMOK on success, SCMERR on error.
 *
 * COMMUNICATION PROTOCOL
 *
 *	Described in scmio.c.
 *
 **********************************************************************
 * HISTORY
 *  2-Oct-92  Mary Thompson (mrt) at Carnegie-Mellon University
 *	Added conditional declarations of INADDR_NONE and INADDR_LOOPBACK
 *	since Tahoe version of <netinet/in.h> does not define them.
 *
 * Revision 1.13  92/08/11  12:05:35  mrt
 * 	Added changes from stump:
 * 	  Allow for multiple interfaces, and for numeric addresses.
 * 	  Changed to use builtin port for the "supfiledbg"
 * 	    service when getservbyname() cannot find it.
 * 	  Added forward static declatations, delinted.
 * 	  Updated variable argument usage.
 * 	[92/08/08            mrt]
 * 
 * Revision 1.12  92/02/08  19:01:11  mja
 * 	Add (struct sockaddr *) casts for HC 2.1.
 * 	[92/02/08  18:59:09  mja]
 * 
 * Revision 1.11  89/08/03  19:49:03  mja
 * 	Updated to use v*printf() in place of _doprnt().
 * 	[89/04/19            mja]
 * 
 * 11-Feb-88  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Moved sleep into computeBackoff, renamed to dobackoff.
 *
 * 10-Feb-88  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added timeout to backoff.
 *
 * 27-Dec-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Removed nameserver support.
 *
 * 09-Sep-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Fixed to depend less upon having name of remote host.
 *
 * 25-May-87  Doug Philips (dwp) at Carnegie-Mellon Universtiy
 *	Extracted backoff/sleeptime computation from "request" and
 *	created "computeBackoff" so that I could use it in sup.c when
 *	trying to get to nameservers as a group.
 *
 * 21-May-87  Chriss Stephens (chriss) at Carnegie Mellon University
 *	Merged divergent CS and EE versions.
 *
 * 02-May-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added some bullet-proofing code around hostname calls.
 *
 * 31-Mar-87  Dan Nydick (dan) at Carnegie-Mellon University
 *	Fixed for 4.3.
 *
 * 30-May-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code to use known values for well-known ports if they are
 *	not found in the host table.
 *
 * 19-Feb-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Changed setsockopt SO_REUSEADDR to be non-fatal.  Added fourth
 *	parameter as described in 4.3 manual entry.
 *
 * 15-Feb-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added call of readflush() to requestend() routine.
 *
 * 29-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Major rewrite for protocol version 4.  All read/write and crypt
 *	routines are now in scmio.c.
 *
 * 14-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added setsockopt SO_REUSEADDR call.
 *
 * 01-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Removed code to "gracefully" handle unexpected messages.  This
 *	seems reasonable since it didn't work anyway, and should be
 *	handled at a higher level anyway by adhering to protocol version
 *	number conventions.
 *
 * 26-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Fixed scm.c to free space for remote host name when connection
 *	is closed.
 *
 * 07-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Fixed 4.2 retry code to reload sin values before retry.
 *
 * 22-Oct-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code to retry initial connection open request.
 *
 * 22-Sep-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Merged 4.1 and 4.2 versions together.
 *
 * 21-Sep-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Add close() calls after pipe() call.
 *
 * 12-Jun-85  Steven Shafer (sas) at Carnegie-Mellon University
 *	Converted for 4.2 sockets; added serviceprep() routine.
 *
 * 04-Jun-85  Steven Shafer (sas) at Carnegie-Mellon University
 *	Created for 4.2 BSD.
 *
 **********************************************************************
 */

#include <libc.h>
#include <errno.h>
#include <sys/param.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#ifndef SIOCGIFCONF
#include <sys/sockio.h>
#endif
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <netdb.h>
#include <syslog.h>
#include <stdarg.h>
#include "supcdefs.h"
#include "supextern.h"

#ifndef INADDR_NONE
#define	INADDR_NONE		0xffffffff		/* -1 return */
#endif
#ifndef INADDR_LOOPBACK
#define	INADDR_LOOPBACK		(u_long)0x7f000001	/* 127.0.0.1 */
#endif

char scmversion[] = "4.3 BSD";
extern int silent;

/*************************
 ***    M A C R O S    ***
 *************************/

/* networking parameters */
#define NCONNECTS 5

/*********************************************
 ***    G L O B A L   V A R I A B L E S    ***
 *********************************************/

extern char program[];			/* name of program we are running */
extern pid_t progpid;			/* process id to display */

int netfile = -1;			/* network file descriptor */

static int sock = -1;			/* socket used to make connection */
static struct in_addr remoteaddr;	/* remote host address */
static char *remotename = NULL;		/* remote host name */
static int swapmode;			/* byte-swapping needed on server? */


static char *myhost(void);

/***************************************************
 ***    C O N N E C T I O N   R O U T I N E S    ***
 ***    F O R   S E R V E R                      ***
 ***************************************************/

/*
 * Mark that we are servicing a connection from host at ia.  We do
 * this by getting an exclusive lock on a file that is "ia" in
 * dotted decimal, in directory "lockdir".  For convienence's sake we
 * write our process ID in there.  Should be called from servicing
 * child, so lock goes away on exit.  Must be called after service()
 * sets global remoteaddr (above).
 *
 * Returns fd for file on success, -1 on failure.
 */
int
lock_host_file(lockdir)
	char *lockdir;
{
	char *dd, *lpath;
	int fd; 
	FILE *f;

	dd = strdup(inet_ntoa(remoteaddr));
	if (dd == NULL) {
		syslog(LOG_ERR, "Malloc failed in lock_host_file()");
		return(-1);
	}
	if (asprintf(&lpath, "%s/%s", lockdir, dd) == -1) {
		syslog(LOG_ERR, "Malloc failed in lock_host_file()");
		free(dd);
		return(-1);
	}
	free(dd);
	if ((fd = open(lpath, O_CREAT | O_WRONLY, 0600)) < 0) {
		syslog(LOG_ERR, "Couldn't open/create lock file %s (%m)", lpath);
		free(lpath);
		return(-1);
	}
#ifdef USE_LOCKF
	if (lockf(fd, F_TLOCK, 0) != 0) 
#else
	if (flock(fd, LOCK_EX | LOCK_NB ) != 0)
#endif
	{
		syslog(LOG_DEBUG, "Can't get lock on %s.", lpath);
		free(lpath);
		close(fd);
		return(-1);
	}
	if (ftruncate(fd, 0) < 0) {
		syslog(LOG_ERR,
		    "Couldn't ftruncate fd %d for lock file %s (%m)",
		    fd, lpath);
		free(lpath);
		close(fd);
		return(-1);
	}
	f = fdopen(fd, "w");
	if (f == NULL) {
		syslog(LOG_ERR, "Couldn't fopen fd %d for lock file %s (%m)",
		    fd, lpath);
		free(lpath);
		close(fd);
		return(-1);
	}
	(void)fprintf(f, "%ld\n", (long) getpid());
	fflush(f);
	free(lpath);
	return(fd);
}

int
servicesetup(server)		/* listen for clients */
	char *server;
{
	struct sockaddr_in sin;
	struct servent *sp;
	short port;
	int one = 1;

	if (myhost() == NULL)
		return (scmerr(-1, "Local hostname not known"));
	if ((sp = getservbyname(server, "tcp")) == 0) {
		if (strcmp(server, FILEPORT) == 0)
			port = htons((u_short)FILEPORTNUM);
		else if (strcmp(server, DEBUGFPORT) == 0)
			port = htons((u_short)DEBUGFPORTNUM);
		else
			return (scmerr(-1, "Can't find %s server description",
			    server));
		(void) scmerr(-1, "%s/tcp: unknown service: using port %d",
		    server, ntohs(port));
	} else
		port = sp->s_port;
	endservent();
	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0)
		return (scmerr(errno, "Can't create socket for connections"));
	if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(int)) < 0)
		(void) scmerr (errno,"Can't set SO_REUSEADDR socket option");
	(void) memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_port = port;
	if (bind(sock, (struct sockaddr *)&sin, sizeof(sin)) < 0)
		return (scmerr(errno, "Can't bind socket for connections"));
	if (listen(sock, NCONNECTS) < 0)
		return (scmerr(errno, "Can't listen on socket"));
	return (SCMOK);
}

int
service()
{
	struct sockaddr_in from;
	int x, len;

again:
	remotename = NULL;
	len = sizeof(from);
	do {
		netfile = accept(sock, (struct sockaddr *)&from, &len);
	} while (netfile < 0 && errno == EINTR);
	if (netfile < 0)
		return (scmerr(errno, "Can't accept connections"));

	/* protection against ftp bounce attack */
	if (from.sin_port == htons(20)) {
		close(netfile);
		goto again;
	}
	remoteaddr = from.sin_addr;
	if (read(netfile, (char *)&x, sizeof(int)) != sizeof(int))
		return (scmerr(errno, "Can't transmit data on connection"));
	if (x == 0x01020304)
		swapmode = 0;
	else if (x == 0x04030201)
		swapmode = 1;
	else
		return (scmerr(-1, "Unexpected byteswap mode %x", x));
	return (SCMOK);
}

int
serviceprep()		/* kill temp socket in daemon */
{

	if (sock >= 0) {
		(void) close (sock);
		sock = -1;
	}
	return (SCMOK);
}

int
servicekill()		/* kill net file in daemon's parent */
{

	if (netfile >= 0) {
		(void) close(netfile);
		netfile = -1;
	}
	if (remotename) {
		free(remotename);
		remotename = NULL;
	}
	return (SCMOK);
}

int
serviceend()		/* kill net file after use in daemon */
{

	if (netfile >= 0) {
		(void) close(netfile);
		netfile = -1;
	}
	if (remotename) {
		free(remotename);
		remotename = NULL;
	}
	return (SCMOK);
}

/***************************************************
 ***    C O N N E C T I O N   R O U T I N E S    ***
 ***    F O R   C L I E N T                      ***
 ***************************************************/

int dobackoff(t, b)
	int *t, *b;
{
	struct timeval tt;
	unsigned s;

	if (*t == 0)
		return (0);
	s = *b * 30;
	if (gettimeofday(&tt, NULL) >= 0)
		s += (tt.tv_usec >> 8) % s;
	if (*b < 32)
		*b <<= 1;
	if (*t != -1) {
		if (s > *t)
			s = *t;
		*t -= s;
	}
	if (!silent)
	    (void) scmerr(-1, "Will retry in %d seconds", s);
	sleep(s);
	return (1);
}

int
request(server, hostname, retry)	/* connect to server */
	char *server;
	char *hostname;
	int *retry;
{
	int x, backoff;
	struct hostent *h;
	struct servent *sp;
	struct sockaddr_in sin, tin;
	short port;

	if ((sp = getservbyname(server,"tcp")) == 0) {
		if (strcmp(server, FILEPORT) == 0)
			port = htons((u_short)FILEPORTNUM);
		else if (strcmp(server, DEBUGFPORT) == 0)
			port = htons((u_short)DEBUGFPORTNUM);
		else
			return (scmerr (-1, "Can't find %s server description",
					server));
		if (!silent)
		    (void) scmerr (-1, "%s/tcp: unknown service: using port %d",
				    server, ntohs(port));
	} else
		port = sp->s_port;
	(void) memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = inet_addr(hostname);
	if (sin.sin_addr.s_addr == (u_long) INADDR_NONE) {
		if ((h = gethostbyname(hostname)) == NULL)
			return (scmerr(-1, "Can't find host entry for %s",
					hostname));
		hostname = h->h_name;
		(void) memcpy(&sin.sin_addr, h->h_addr, h->h_length);
	}
	sin.sin_port = port;
	backoff = 1;
	for (;;) {
		netfile = socket(AF_INET, SOCK_STREAM, 0);
		if (netfile < 0)
			return (scmerr(errno, "Can't create socket"));
		tin = sin;
		if (connect(netfile, (struct sockaddr *)&tin, sizeof(tin)) >= 0)
			break;
		(void) scmerr (errno,"Can't connect to server for %s", server);
		(void) close(netfile);
		if (!dobackoff(retry,&backoff))
			return (SCMERR);
	}
	remoteaddr = sin.sin_addr;
	remotename = strdup(hostname);
	x = 0x01020304;
	(void) write (netfile, (char *)&x, sizeof(int));
	swapmode = 0;		/* swap only on server, not client */
	return (SCMOK);
}

int
requestend()			/* end connection to server */
{

	(void) readflush();
	if (netfile >= 0) {
		(void) close(netfile);
		netfile = -1;
	}
	if (remotename) {
		free(remotename);
		remotename = NULL;
	}
	return (SCMOK);
}

/*************************************************
 ***    H O S T   N A M E   C H E C K I N G    ***
 *************************************************/

static char *
myhost()		/* find my host name */
{
	struct hostent *h;
	static char name[MAXHOSTNAMELEN];

	if (name[0] == '\0') {
		if (gethostname(name,sizeof name) < 0)
			return (NULL);
		if ((h = gethostbyname(name)) == NULL)
			return (NULL);
		(void) strlcpy(name, h->h_name, sizeof name);
	}
	return (name);
}

char *
remotehost()		/* remote host name (if known) */
{
	struct hostent *h;

	if (remotename == NULL) {
		h = gethostbyaddr((char *)&remoteaddr, sizeof(remoteaddr),
				    AF_INET);
		remotename = strdup(h ? h->h_name : inet_ntoa(remoteaddr));
		if (remotename == NULL)
			return("UNKNOWN");
	}
	return (remotename);
}

int
thishost(host)
	char *host;
{
	struct hostent *h;
	char *name;

	if ((name = myhost()) == NULL)
		logquit (1, "Can't find my host entry '%s'", myhost());
	h = gethostbyname(host);
	if (h == NULL)
		return (0);
	return (strcasecmp(name, h->h_name) == 0);
}

int
samehost()		/* is remote host same as local host? */
{
	static struct in_addr *intp;
	static int nint = 0;
	struct in_addr *ifp;
	int n;

	if (nint <= 0) {
		int s;
		char buf[BUFSIZ];
		struct ifconf ifc;
		struct ifreq *ifr;
		struct sockaddr_in sin;

		if ((s = socket (AF_INET,SOCK_DGRAM,0)) < 0)
			logquit (1,"Can't create socket for SIOCGIFCONF");
		ifc.ifc_len = sizeof(buf);
		ifc.ifc_buf = buf;
		if (ioctl(s, SIOCGIFCONF, (char *)&ifc) < 0)
			logquit(1,"SIOCGIFCONF failed");
		(void) close(s);
		if ((nint = ifc.ifc_len / sizeof(struct ifreq)) <= 0)
			return (0);
		intp = (struct in_addr *)
			calloc (nint, sizeof(struct in_addr));
		if ((ifp = intp) == 0)
			logquit (1, "no space for interfaces");
		for (ifr = ifc.ifc_req, n = nint; n > 0; --n, ifr++) {
			(void) memcpy(&sin, &ifr->ifr_addr, sizeof(sin));
			*ifp++ = sin.sin_addr;
		}
	}
	if (remoteaddr.s_addr == htonl(INADDR_LOOPBACK))
		return (1);
	for (ifp = intp, n = nint; n > 0; --n, ifp++)
		if (remoteaddr.s_addr == ifp->s_addr)
			return (1);
	return (0);
}

int
matchhost(name)		/* is this name of remote host? */
	char *name;
{
	struct hostent *h;
	struct in_addr addr;
	char **ap;

	if ((addr.s_addr = inet_addr(name)) != (u_long) INADDR_NONE)
		return (addr.s_addr == remoteaddr.s_addr);
	if ((h = gethostbyname(name)) == 0)
		return (0);
	if (h->h_addrtype != AF_INET || h->h_length != sizeof(struct in_addr))
		return (0);
	for (ap = h->h_addr_list; *ap; ap++)
		if (memcmp(&remoteaddr, *ap, h->h_length) == 0)
			return (1);
	return (0);
}

int scmerr(int error,char *fmt,...)
{
	va_list ap;

	va_start(ap,fmt);
	(void) fflush(stdout);
	if (progpid > 0)
		fprintf(stderr, "%s %ld: ", program, (long)progpid);
	else
		fprintf(stderr,"%s: ", program);

	vfprintf(stderr, fmt, ap);
	va_end(ap);
	if (error >= 0)
		fprintf(stderr, ": %s\n", errmsg(error));
	else
		fprintf(stderr, "\n");
	(void) fflush(stderr);
	return (SCMERR);
}

/*******************************************************
 ***    I N T E G E R   B Y T E - S W A P P I N G    ***
 *******************************************************/

union intchar {
	int ui;
	char uc[sizeof(int)];
};

int byteswap(in)
	int in;
{
	union intchar x,y;
	int ix,iy;

	if (swapmode == 0)
		return (in);
	x.ui = in;
	iy = sizeof(int);
	for (ix=0; ix < sizeof(int); ix++) {
		--iy;
		y.uc[iy] = x.uc[ix];
	}
	return (y.ui);
}
@


1.19
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.18 2005/03/10 01:36:37 cloder Exp $	*/
@


1.18
log
@Use correct byte order when printing out port numbers.
OK deraadt@@, bruno rohee, hshoexer@@, jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.17 2004/01/12 04:22:23 beck Exp $	*/
d579 1
a579 1
			malloc (nint * sizeof(struct in_addr));
@


1.17
log
@fix string mishandling of lpath, ok millert, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.16 2002/06/12 06:07:16 mpech Exp $	*/
d310 1
a310 1
		    server,port);
d453 1
a453 1
				    server, port);
@


1.16
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.15 2002/02/19 19:39:39 millert Exp $	*/
d238 1
a238 1
	int i, fd; 
d246 1
a246 3
	i = strlen(lockdir) + strlen(dd) + 2; /* NUL and maybe a / */
	lpath = (char *)malloc(i);
	if (lpath == NULL) {
a249 9
	}
	(void) strlcpy(lpath, lockdir, i);
	if (lpath[strlen(lpath) - 1] != '/') {
		lpath[strlen(lpath)] = '/'; 
		lpath[strlen(lpath) + 1] = '\0';
	}
	if (strlcat(lpath, dd, i) >= i) {
		syslog(LOG_CRIT, "Buffer overrun in lock_host_file(). SHOULD NOT HAPPEN!");
		abort();
@


1.15
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.14 2002/02/16 21:27:54 millert Exp $	*/
d206 1
a206 1
extern int progpid;			/* process id to display */
d295 1
a295 1
	(void)fprintf(f, "%d\n", (int) getpid());
d633 1
a633 1
		fprintf(stderr, "%s %d: ", program, progpid);
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.13 2001/05/05 15:56:04 millert Exp $	*/
a179 1
#ifdef __STDC__
a180 3
#else
#include <varargs.h>
#endif
a625 1
#ifdef __STDC__
a626 5
#else
/*VARARGS*//*ARGSUSED*/
int scmerr(va_alist)
va_dcl
#endif
d629 1
a629 1
#ifdef __STDC__
a630 9
#else
	int error;
	char *fmt;

	va_start(ap);
	error = va_arg(ap,int);
	fmt = va_arg(ap,char *);
#endif

@


1.13
log
@Fix Makefile.sunos5.gcc so that it builds sup correctly on Solaris 8
Fix some -Wall found on Solaris
Fix some uid_t/gid_t stuff I missed before
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.12 2001/05/04 22:16:16 millert Exp $	*/
d220 1
a220 1
static char *myhost __P((void));
@


1.12
log
@o kill register
o lots of KNF
o passes -Wall
o fix some [ug]id_t vs. int issues
o use strlcpy/strlcat in favor of strncpy/strncat
o use mem* routines everywhere instead of old b* ones
o marked several questionable things for later fixing
o kill ci.c and cvt.c -- we don't use them
o kill read_line.c since it requires fgetln() (bad for portability)
o kill salloc.c since it is the same as strup()
o Replaced some #ifdef __OpenBSD__ with better tests
o remaining problems: malloc return values are rarely checked, select misuse
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.11 2001/05/02 22:56:53 millert Exp $	*/
d299 1
a299 1
	(void)fprintf(f, "%d\n", getpid());
@


1.11
log
@Sync with NetBSD.  Notable changes:
 o Add libwrap support to supfilesrv, conditioned by #ifdef LIBWRAP
   (on by default). <bouyer@@netbsd.org>
 o Renamed '-l' (the 'live' mode) to '-d' and '-l' is now used to
   enable logging of successfull connections. <bouyer@@netbsd.org>
 o Don't botch varargs: the are not always an array of void * in the stack...
   Write a separate function to convert a list of function parameters to
   explain why execv failed. <christos@@netbsd.org>
 o When in compress mode, don't overwrite the destination file directly,
   write a temp file and use rename when it is done. (From James Mathiesen
   <james@@deshaw.com>)
 o Rename errno variable to error to avoid collision with errno.h and remove
   explicit extern of errno (we get it from errno.h) <mycroft@@netbsd.org>
 o Cleanup unsigned char vs. char
 o Add -u flag, that prevents sup from attempting to restore a and m times
   on the received files.
 o Replace the provided read_line function with calls to the fparseln function
   in libutil.  Maintain compatibility on machines without fparseln through
   the NEED_READ_LINE define.
 o Rename login() to suplogin() to avoid name collition in util.h
 o If rmdir() fails, chmod the path to have r/w/x perms and run "rm -rf"
 o avoid last.temp filename collision by using rel-suffix
 o When creating directories, make sure you remove previous non-directories
   before doing so, otherwise sup fails.
 o Add -q flag to supscan for quiet operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.10 2001/04/29 21:52:15 millert Exp $	*/
d227 45
a271 45
int lock_host_file(char *lockdir) {

  /* mark that we are servicing a connection from host at ia.  we do
   * this by getting an exclusive lock on a file that is "ia" in
   * dotted decimal, in directory "lockdir". For convienence's sake we
   * write our process ID in there. Should be called from servicing
   * child, so lock goes away on exit. must be called after service()
   * sets global remoteaddr (above).
   *
   * returns fd for file on success,-1 on failure.
   */

  char *dd, *lpath;
  int i, fd; 
  FILE *f;

  dd=strdup(inet_ntoa(remoteaddr));
  if (dd == NULL) {
    syslog(LOG_ERR, "Malloc failed in lock_host_file()");
    return(-1);
  }
  i=strlen(lockdir) + strlen(dd) + 2; /* null and maybe a / */
  lpath=(char *)malloc(i * sizeof(char));
  lpath[i-1]='\0';
  if (lpath == NULL) {
    syslog(LOG_ERR, "Malloc failed in lock_host_file()");
    free(dd);
    return(-1);
  }
  (void) strncpy(lpath, lockdir, i-1);
  if (lpath[strlen(lpath) - 1] != '/') {
    lpath[strlen(lpath) + 1] = '\0';
    lpath[strlen(lpath)] = '/'; 
  }
  (void) strncat(lpath, dd, i - strlen(lpath)); 
  if (lpath[i-1] != '\0') {
    syslog(LOG_CRIT, "Buffer overrun in lock_host_file(). SHOULD NOT HAPPEN!");
    abort();
  }
  free(dd);
  if ((fd = open(lpath, O_CREAT | O_WRONLY, 0600)) < 0) {
    syslog(LOG_ERR, "Couldn't open/create lock file %s (%m)", lpath);
    free(lpath);
    return(-1);
  }
d273 1
a273 1
  if (lockf(fd, F_TLOCK, 0) != 0) 
d275 1
a275 1
  if (flock(fd, LOCK_EX | LOCK_NB ) != 0)
d277 26
a302 24
    {
      syslog(LOG_DEBUG, "Can't get lock on %s.", lpath);
      free(lpath);
      close(fd);
      return(-1);
    }
  if (ftruncate(fd, 0) < 0) {
    syslog(LOG_ERR, "Couldn't ftruncate fd %d for lock file %s (%m)",
	   fd, lpath);
    free(lpath);
    close(fd);
    return(-1);
  }
  f=fdopen(fd,"w");
  if (f == NULL) {
    syslog(LOG_ERR, "Couldn't fopen fd %d for lock file %s (%m)", fd, lpath);
    free(lpath);
    close(fd);
    return(-1);
  }
  (void)fprintf(f,"%d\n", getpid());
  fflush(f);
  free(lpath);
  return(fd);
d306 2
a307 2
servicesetup (server)		/* listen for clients */
char *server;
d314 3
a316 3
	if (myhost () == NULL)
		return (scmerr (-1,"Local hostname not known"));
	if ((sp = getservbyname(server,"tcp")) == 0) {
d322 4
a325 3
			return (scmerr (-1,"Can't find %s server description",server));
		(void) scmerr (-1,"%s/tcp: unknown service: using port %d",
					server,port);
d328 2
a329 2
	endservent ();
	sock = socket (AF_INET,SOCK_STREAM,0);
d331 2
a332 2
		return (scmerr (errno,"Can't create socket for connections"));
	if (setsockopt (sock,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(int)) < 0)
d334 1
a334 1
	(void) bzero ((char *)&sin,sizeof(sin));
d337 4
a340 4
	if (bind (sock,(struct sockaddr *)&sin,sizeof(sin)) < 0)
		return (scmerr (errno,"Can't bind socket for connections"));
	if (listen (sock,NCONNECTS) < 0)
		return (scmerr (errno,"Can't listen on socket"));
d345 1
a345 1
service ()
d348 1
a348 1
	int x,len;
d352 1
a352 1
	len = sizeof (from);
d354 1
a354 1
		netfile = accept (sock,(struct sockaddr *)&from,&len);
d357 1
a357 1
		return (scmerr (errno,"Can't accept connections"));
d365 2
a366 2
	if (read(netfile,(char *)&x,sizeof(int)) != sizeof(int))
		return (scmerr (errno,"Can't transmit data on connection"));
d372 1
a372 1
		return (scmerr (-1,"Unexpected byteswap mode %x",x));
d377 1
a377 1
serviceprep ()		/* kill temp socket in daemon */
d379 1
d388 1
a388 1
servicekill ()		/* kill net file in daemon's parent */
d390 1
d392 1
a392 1
		(void) close (netfile);
d396 1
a396 1
		free (remotename);
d403 1
a403 1
serviceend ()		/* kill net file after use in daemon */
d405 1
d407 1
a407 1
		(void) close (netfile);
d411 1
a411 1
		free (remotename);
d422 2
a423 2
int dobackoff (t,b)
int *t,*b;
d431 1
a431 1
	if (gettimeofday (&tt,(struct timezone *)NULL) >= 0)
d433 2
a434 1
	if (*b < 32) *b <<= 1;
d441 2
a442 2
	    (void) scmerr (-1,"Will retry in %d seconds",s);
	sleep (s);
d447 4
a450 4
request (server,hostname,retry)		/* connect to server */
char *server;
char *hostname;
int *retry;
d464 1
a464 1
			return (scmerr (-1,"Can't find %s server description",
d467 2
a468 2
		    (void) scmerr (-1,"%s/tcp: unknown service: using port %d",
				    server,port);
d471 1
a471 1
	(void) bzero ((char *)&sin,sizeof(sin));
d473 1
a473 1
	sin.sin_addr.s_addr = inet_addr (hostname);
d475 2
a476 2
		if ((h = gethostbyname (hostname)) == NULL)
			return (scmerr (-1,"Can't find host entry for %s",
d479 1
a479 1
		(void) bcopy (h->h_addr,(char *)&sin.sin_addr,h->h_length);
d484 1
a484 1
		netfile = socket (AF_INET,SOCK_STREAM,0);
d486 1
a486 1
			return (scmerr (errno,"Can't create socket"));
d488 1
a488 1
		if (connect(netfile,(struct sockaddr *)&tin,sizeof(tin)) >= 0)
d490 1
a490 1
		(void) scmerr (errno,"Can't connect to server for %s",server);
d492 1
a492 1
		if (!dobackoff (retry,&backoff))
d496 1
a496 1
	remotename = salloc(hostname);
d498 1
a498 1
	(void) write (netfile,(char *)&x,sizeof(int));
d504 1
a504 1
requestend ()			/* end connection to server */
d506 2
a507 1
	(void) readflush ();
d509 1
a509 1
		(void) close (netfile);
d513 1
a513 1
		free (remotename);
d523 2
a524 2
static
char *myhost ()		/* find my host name */
d530 1
a530 1
		if (gethostname (name,sizeof name) < 0)
d532 1
a532 1
		if ((h = gethostbyname (name)) == NULL)
d534 1
a534 2
		(void) strncpy (name,h->h_name,sizeof name-1);
		name[sizeof name-1] = '\0';
d539 2
a540 1
char *remotehost ()	/* remote host name (if known) */
d542 1
a542 1
	register struct hostent *h;
d545 1
a545 1
		h = gethostbyaddr ((char *)&remoteaddr,sizeof(remoteaddr),
d547 1
a547 1
		remotename = salloc (h ? h->h_name : inet_ntoa(remoteaddr));
d554 3
a556 2
int thishost (host)
register char *host;
d558 1
a558 1
	register struct hostent *h;
d561 6
a566 5
	if ((name = myhost ()) == NULL)
		logquit (1,"Can't find my host entry '%s'", myhost());
	h = gethostbyname (host);
	if (h == NULL) return (0);
	return (strcasecmp (name,h->h_name) == 0);
d569 2
a570 1
int samehost ()		/* is remote host same as local host? */
d588 2
a589 2
		if (ioctl (s,SIOCGIFCONF,(char *)&ifc) < 0)
			logquit (1,"SIOCGIFCONF failed");
d591 1
a591 1
		if ((nint = ifc.ifc_len/sizeof(struct ifreq)) <= 0)
d594 1
a594 1
			malloc ((unsigned) nint*sizeof(struct in_addr));
d596 1
a596 1
			logquit (1,"no space for interfaces");
d598 1
a598 1
			(void) bcopy ((char *)&ifr->ifr_addr,(char *)&sin,sizeof(sin));
d610 3
a612 2
int matchhost (name)	/* is this name of remote host? */
char *name;
d617 1
d620 1
a620 1
	if ((h = gethostbyname (name)) == 0)
d625 1
a625 1
		if (bcmp ((char *)&remoteaddr,*ap,h->h_length) == 0)
d631 1
a631 1
int scmerr (int error,char *fmt,...)
d634 1
a634 1
int scmerr (va_alist)
d650 1
a650 1
	(void) fflush (stdout);
d652 1
a652 1
		fprintf (stderr,"%s %d: ",program,progpid);
d654 1
a654 1
		fprintf (stderr,"%s: ",program);
d659 1
a659 1
		fprintf (stderr,": %s\n",errmsg(error));
d661 2
a662 2
		fprintf (stderr,"\n");
	(void) fflush (stderr);
d675 2
a676 2
int byteswap (in)
int in;
d679 1
a679 1
	register int ix,iy;
d681 2
a682 1
	if (swapmode == 0)  return (in);
d685 1
a685 1
	for (ix=0; ix<sizeof(int); ix++) {
@


1.10
log
@Add a bunch of old revision history comments that we are missing to
make diffing easier.  No code changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.9 2000/02/01 03:23:40 deraadt Exp $	*/
a194 1

a520 1

d522 1
a522 1
		if (gethostname (name,MAXHOSTNAMELEN) < 0)
d553 1
a553 1
		logquit (1,"Can't find my host entry");
d618 1
a618 1
int scmerr (int errno,char *fmt,...)
d629 1
a629 1
	int errno;
d633 1
a633 1
	errno = va_arg(ap,int);
d645 2
a646 2
	if (errno >= 0)
		fprintf (stderr,": %s\n",errmsg(errno));
@


1.9
log
@no need to extern int errno if errno.h is included
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.8 1997/10/12 20:29:55 beck Exp $	*/
d19 1
a19 1
 *  Software Distribution Coordinator  or  Software_Distribution@@CS.CMU.EDU
d72 17
@


1.8
log
@    ftruncate the lock file for supfilesrv -O before writing pid into it.
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.7 1997/10/11 23:34:20 beck Exp $	*/
a177 1
extern int errno;
@


1.7
log
@ -Kludges for SunOS 5 portablility,

 -Added -O option to supfilesrv. -O lockdir make serving process
 lock file in lockdir for each connecting ip address.  Will refuse a
 second connection from a host it's already serving a request for.
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.6 1997/09/16 11:01:17 deraadt Exp $	*/
d253 1
a253 1
    syslog(LOG_ERR, "Couldn't open/create lock file %s!", lpath);
d268 7
d277 1
a277 1
    syslog(LOG_ERR, "Couldn't fopen fd %d for lock file %s!", fd, lpath);
@


1.6
log
@strcpy whacking; ci.c and expand.c need more work
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.5 1997/07/25 21:05:42 mickey Exp $	*/
d162 1
d211 69
@


1.5
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.4 1997/04/01 07:35:22 todd Exp $	*/
d435 2
a436 1
		(void) strcpy (name,h->h_name);
@


1.4
log
@This merges in the latest NetBSD sup source.
- removed $Log: ...$ tags to not waste space in the repository
- now doesn't segfault on the alpha!

Note:
To compile sup on systems other than *BSD, you'll need a copy of
vis.c, vis.h, daemon.c, and sys/cdefs.h.  At least the first two
(for OSF/1).

From NetBSD changelog description (for credit where due):
.... 1996/12/23 19:42:05  christos
- add missing prototypes.
- fix function call inconsistencies
- fix int <-> long and pointer conversions
It should run now on 64 bit machines...

....  1996/12/31 18:08:00  christos
64 bit patches (mostly long -> time_t) from Matthew Jacob (?)
sup now works on the alpha!
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.3 1996/08/04 12:58:26 deraadt Exp $	*/
d162 1
a162 1
#if __STDC__
@


1.3
log
@ftp bounce protection
@
text
@d1 1
a1 1
/*	$OpenBSD: scm.c,v 1.2 1996/06/26 05:39:47 deraadt Exp $	*/
a71 33
 *
 * $Log: scm.c,v $
 * Revision 1.2  1996/06/26 05:39:47  deraadt
 * rcsid
 *
 * Revision 1.1  1995/12/16 11:46:51  deraadt
 * add sup to the tree
 *
 * Revision 1.2  1995/06/03 21:21:51  christos
 * Changes to write ascii timestamps in the when files.
 * Looked into making it 64 bit clean, but it is hopeless.
 * Added little program to convert from the old timestamp files
 * into the new ones.
 *
 * Revision 1.1.1.1  1993/05/21 14:52:17  cgd
 * initial import of CMU's SUP to NetBSD
 *
 * Revision 1.13  92/08/11  12:05:35  mrt
 * 	Added changes from stump:
 * 	  Allow for multiple interfaces, and for numeric addresses.
 * 	  Changed to use builtin port for the "supfiledbg"
 * 	    service when getservbyname() cannot find it.
 * 	  Added forward static declatations, delinted.
 * 	  Updated variable argument usage.
 * 	[92/08/08            mrt]
 * 
 * Revision 1.12  92/02/08  19:01:11  mja
 * 	Add (struct sockaddr *) casts for HC 2.1.
 * 	[92/02/08  18:59:09  mja]
 * 
 * Revision 1.11  89/08/03  19:49:03  mja
 * 	Updated to use v*printf() in place of _doprnt().
 * 	[89/04/19            mja]
d155 3
d167 2
a168 1
#include "sup.h"
a177 1
static char *myhost ();
d180 1
d203 2
a204 3
#if __STDC__
int scmerr(int,char *,...);
#endif
d211 1
d249 1
d281 1
d291 1
d305 1
d324 1
a324 1
dobackoff (t,b)
d341 2
a342 1
	(void) scmerr (-1,"Will retry in %d seconds",s);
d347 1
d367 3
a369 2
		(void) scmerr (-1,"%s/tcp: unknown service: using port %d",
					server,port);
d404 1
d525 1
a525 1
#if __STDC__
d533 4
a536 1
#if !__STDC__
d539 4
a543 1
	va_list ap;
d550 1
a550 7
#if __STDC__
	va_start(ap,fmt);
#else
	va_start(ap);
	errno = va_arg(ap,int);
	fmt = va_arg(ap,char *);
#endif
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 3
d283 1
d291 6
@


1.1
log
@add sup to the tree
@
text
@d1 2
d74 3
@
