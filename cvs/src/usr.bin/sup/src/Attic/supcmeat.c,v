head	1.24;
access;
symbols
	OPENBSD_4_8:1.23.0.12
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.8
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.10
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.21.0.10
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.8
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.6
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.4
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.19.0.8
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.12
	OPENBSD_2_8:1.9.0.10
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.24
date	2010.10.18.20.54.00;	author deraadt;	state dead;
branches;
next	1.23;

1.23
date	2007.09.14.14.29.20;	author chl;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.27.18.13.16;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.26.21.37.56;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.04.03.24.07;	author beck;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.15.07.21.09;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches
	1.17.2.1
	1.17.4.1;
next	1.16;

1.16
date	2002.02.19.19.39.39;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.04.22.16.16;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.02.22.56.53;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.29.22.45.12;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.29.21.52.16;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.29.18.16.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.05.18.19.13.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.09.16.11.01.20;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.09.16.10.42.54;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.28.09.47.38;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.04.01.07.35.33;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.18.07;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.07.31.11.11.28;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.39.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.16.11.46.56;	author deraadt;	state Exp;
branches;
next	;

1.17.2.1
date	2003.09.24.18.59.11;	author brad;	state Exp;
branches;
next	;

1.17.4.1
date	2003.09.24.19.05.59;	author brad;	state Exp;
branches;
next	;


desc
@@


1.24
log
@sup is no longer used. reminded by pirofti and jmc
@
text
@/*	$OpenBSD: supcmeat.c,v 1.23 2007/09/14 14:29:20 chl Exp $	*/

/*
 * Copyright (c) 1992 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 * sup "meat" routines
 **********************************************************************
 * HISTORY
 *
 * 7-July-93  Nate Williams at Montana State University
 *	Modified SUP to use gzip based compression when sending files
 *	across the network to save BandWidth
 *
 * Revision 1.16  92/09/09  22:04:51  mrt
 * 	Really added bww's recvone changes this time. 
 * 	Added code to support non-crypting version of sup.
 * 	[92/09/01            mrt]
 * 
 * Revision 1.15  92/08/11  12:07:09  mrt
 * 	Added support to add release to FILEWHEN name.
 * 	Updated variable arguemnt list usage - bww
 * 	Updated recvone() to take a va_list - bww
 * 	Changed conditional for rpausing code from CMUCS to MACH
 * 	[92/07/24            mrt]
 * 
 * Revision 1.14  92/02/08  18:24:12  mja
 * 	Only apply "keep" mode when local file is strictly newer
 * 	otherwise allow update as before if necessary.
 * 	[92/02/08  18:09:00  mja]
 * 
 * 	Added support for -k (keep) option to needone().  Rewrote and
 * 	commented other parts of needone().
 * 	[92/01/17            vdelvecc]
 * 
 * Revision 1.13  91/05/16  14:49:41  ern
 * 	Add timestap to fileserver.
 * 	Drop day of the week from 5 messages.
 * 	[91/05/16  14:47:53  ern]
 * 
 * Revision 1.12  89/08/23  14:55:44  gm0w
 * 	Changed msgf routines to msg routines.
 * 	[89/08/23            gm0w]
 * 
 * Revision 1.11  89/08/03  19:49:10  mja
 * 	Updated to use v*printf() in place of _doprnt().
 * 	[89/04/19            mja]
 * 
 * Revision 1.10  89/06/18  14:41:27  gm0w
 * 	Fixed up some notify messages of errors to use "SUP:" prefix.
 * 	[89/06/18            gm0w]
 * 
 * Revision 1.9  89/06/10  15:12:17  gm0w
 * 	Changed to always use rename to install targets.  This breaks hard
 * 	links and recreates those known to sup, other links will be orphaned.
 * 	[89/06/10            gm0w]
 * 
 * Revision 1.8  89/05/24  15:04:23  gm0w
 * 	Added code to check for EINVAL from FSPARAM ioctl for disk
 * 	space check failures when the ioctl is not implemented.
 * 	[89/05/24            gm0w]
 * 
 * Revision 1.7  89/01/16  18:22:28  gm0w
 * 	Changed needone() to check that mode of files match before
 * 	setting update if times also match.
 * 	[89/01/16            gm0w]
 * 
 * 10-Feb-88  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added timeout to backoff.
 *
 * 27-Dec-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added crosspatch support.
 *
 * 09-Sep-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code to be less verbose when updating files that have
 *	already been successfully upgraded.
 *
 * 28-Jun-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code for "release" support.
 *
 * 26-May-87  Doug Philips (dwp) at Carnegie-Mellon University
 *	Converted to end connection with more information.
 *	Added done routine.  Modified goaway routine to free old
 *	goawayreason.
 *
 * 26-May-87  Doug Philips (dwp) at Carnegie-Mellon University
 *	Use computeBackoff from scm instead of doing it ourselves.
 *
 * 25-May-87  Doug Philips (dwp) at Carnegie-Mellon University
 *	Split off from sup.c and reindented goaway calls.
 *
 **********************************************************************
 */

#include "supcdefs.h"
#include "supextern.h"
#include <sys/param.h>
#include <sys/wait.h>

TREE *lastT;				/* last filenames in collection */
jmp_buf sjbuf;				/* jump location for network errors */
int dontjump;				/* flag to void sjbuf */
int cancompress = FALSE;		/* Can we do compression? */
int docompress = FALSE;			/* Do we do compression? */

extern COLLECTION *thisC;		/* collection list pointer */
extern int rpauseflag;			/* don't disable resource pausing */
extern int portdebug;			/* network debugging ports */
extern int noutime;			/* don't set utimes */

/*************************************************
 ***    U P G R A D E   C O L L E C T I O N    ***
 *************************************************/

static int needone(TREE *, void *);
static int recvone(TREE *, va_list);
static int denyone(TREE *, void *);
static int deleteone(TREE *, void *);
static int linkone(TREE *, void *);
static int execone(TREE *, void *);
static int finishone(TREE *, void *);


/*
 * The next two routines define the fsm to support multiple fileservers
 * per collection.
 */
int
getonehost(t, v)
	TREE *t;
	void *v;
{
	long *state = v;

	if (t->Tflags != *state)
		return (SCMOK);
	if (*state != 0 && t->Tmode == SCMEOF) {
		t->Tflags = 0;
		return (SCMOK);
	}
	if (*state == 2)
		t->Tflags--;
	else
		t->Tflags++;
	thisC->Chost = t;
	return (SCMEOF);
}

TREE *
getcollhost(tout, backoff, state, nhostsp)
	int *tout, *backoff, *nhostsp;
	long *state;
{
	static long laststate = 0;
	static int nhosts = 0;

	if (*state != laststate) {
		*nhostsp = nhosts;
		laststate = *state;
		nhosts = 0;
	}
	if (Tprocess(thisC->Chtree, getonehost, state) == SCMEOF) {
		if (*state != 0 && nhosts == 0 && !dobackoff(tout, backoff))
			return (NULL);
		nhosts++;
		return (thisC->Chost);
	}
	if (nhosts == 0)
		return (NULL);
	if (*state == 2)
		(*state)--;
	else
		(*state)++;
	return (getcollhost(tout, backoff, state, nhostsp));
}

/*
 *  Upgrade a collection from the file server on the appropriate
 *  host machine.
 */
void
getcoll(void)
{
	TREE *t;
	int x;
	int tout, backoff, nhosts;
	long state;

	collname = thisC->Cname;
	tout = thisC->Ctimeout;
	lastT = NULL;
	backoff = 2;
	state = 0;
	nhosts = 0;
	for (;;) {
		t = getcollhost(&tout, &backoff, &state, &nhosts);
		if (t == NULL) {
			finishup(SCMEOF);
			notify(NULL);
			return;
		}
		t->Tmode = SCMEOF;
		dontjump = FALSE;
		if (!setjmp(sjbuf) && !signon(t, nhosts, &tout) && !setup(t))
			break;
		(void) requestend();
	}
	dontjump = FALSE;
	if (setjmp(sjbuf))
		x = SCMERR;
	else {
		suplogin();
		listfiles();
		recvfiles();
		x = SCMOK;
	}
	if (thisC->Clockfd >= 0) {
		(void) close(thisC->Clockfd);
		thisC->Clockfd = -1;
	}
	finishup(x);
	notify(NULL);
}

/***  Sign on to file server ***/

int signon (t, nhosts, tout)
	TREE *t;
	int nhosts;
	int *tout;
{
	int x;
	int timeout;
	time_t tloc;

	if ((thisC->Cflags&CFLOCAL) == 0 && thishost(thisC->Chost->Tname)) {
		vnotify("SUP: Skipping local collection %s\n", collname);
		t->Tmode = SCMEOF;
		return (TRUE);
	}
	if (nhosts == 1)
		timeout = *tout;
	else
		timeout = 0;
	x = request(portdebug ? DEBUGFPORT : FILEPORT, thisC->Chost->Tname,
	    &timeout);
	if (nhosts == 1)
		*tout = timeout;
	if (x != SCMOK) {
		if (nhosts) {
			notify("SUP: Can't connect to host %s\n",
			    thisC->Chost->Tname);
			t->Tmode = SCMEOF;
		} else
			t->Tmode = SCMOK;
		return (TRUE);
	}
	xpatch = FALSE;
	x = msgsignon();	/* signon to fileserver */
	if (x != SCMOK)
		goaway("Error sending signon request to fileserver");
	x = msgsignonack();	/* receive signon ack from fileserver */
	if (x != SCMOK)
		goaway("Error reading signon reply from fileserver");
	tloc = time(NULL);
	vnotify("SUP Fileserver %d.%d (%s) %ld on %s at %.8s\n", protver,
	    pgmver, scmver, (long)fspid, remotehost(), ctime(&tloc) + 11);
	free(scmver);
	scmver = NULL;
	if (protver < 4) {
		dontjump = TRUE;
		goaway("Fileserver sup protocol version is obsolete.");
		notify("SUP: This version of sup can only communicate with a fileserver using at least\n");
		notify("SUP: version 4 of the sup network protocol.  You should either run a newer\n");
		notify("SUP: version of the sup fileserver or find an older version of sup.\n");
		t->Tmode = SCMEOF;
		return (TRUE);
	}
	/* If protocol is > 7 then try compression */
	if (protver > 7) {
		cancompress = TRUE;
	}
	return (FALSE);
}

/***  Tell file server what to connect to ***/

int
setup(t)
	TREE *t;
{
	char relsufix[STRINGLENGTH];
	int x;
	struct stat sbuf;

	if (chdir(thisC->Cbase) < 0)
		goaway("Can't change to base directory %s", thisC->Cbase);
	if (stat ("sup", &sbuf) < 0) {
		(void) mkdir("sup", 0755);
		if (stat("sup",&sbuf) < 0)
			goaway("Can't create directory %s/sup", thisC->Cbase);
		vnotify("SUP Created directory %s/sup\n", thisC->Cbase);
	}
	if (thisC->Cprefix && chdir(thisC->Cprefix) < 0)
		goaway("Can't change to %s from base directory %s",
		    thisC->Cprefix, thisC->Cbase);
	if (stat(".", &sbuf) < 0)
		goaway("Can't stat %s directory %s",
			thisC->Cprefix ? "prefix" : "base",
			thisC->Cprefix ? thisC->Cprefix : thisC->Cbase);
	if (thisC->Cprefix)
		(void) chdir(thisC->Cbase);
	/* read time of last upgrade from when file */

	if ((thisC->Cflags&CFURELSUF) && thisC->Crelease)
		(void) snprintf(relsufix, sizeof relsufix, ".%s",
		    thisC->Crelease);
	else
		relsufix[0] = '\0';
	lasttime = getwhen(collname, relsufix);
	/* setup for msgsetup */
	basedir = thisC->Chbase;
	basedev = sbuf.st_dev;
	baseino = sbuf.st_ino;
	listonly = (thisC->Cflags&CFLIST);
	newonly = ((thisC->Cflags&(CFALL|CFDELETE|CFOLD)) == 0);
	release = thisC->Crelease;
	x = msgsetup();
	if (x != SCMOK)
		goaway ("Error sending setup request to file server");
	x = msgsetupack();
	if (x != SCMOK)
		goaway("Error reading setup reply from file server");
	if (setupack == FSETUPOK) {
		/* Test encryption */
		if (netcrypt(thisC->Ccrypt) != SCMOK)
			goaway("Running non-crypting sup");
		crypttest = CRYPTTEST;
		x = msgcrypt();
		if (x != SCMOK)
			goaway("Error sending encryption test request");
		x = msgcryptok();
		if (x == SCMEOF)
			goaway("Data encryption test failed");
		if (x != SCMOK)
			goaway("Error reading encryption test reply");
		return (FALSE);
	}
	switch (setupack) {
	case FSETUPSAME:
		notify("SUP: Attempt to upgrade from same host to same directory\n");
		done(FDONESRVERROR, "Overwrite error");
	case FSETUPHOST:
		notify("SUP: This host has no permission to access %s\n",
		    collname);
		done(FDONESRVERROR, "Permission denied");
	case FSETUPOLD:
		notify("SUP: This version of SUP is too old for the fileserver\n");
		done(FDONESRVERROR, "Obsolete client");
	case FSETUPRELEASE:
		notify("SUP: Invalid release %s for collection %s\n",
			release == NULL ? DEFRELEASE : release, collname);
		done(FDONESRVERROR, "Invalid release");
	case FSETUPBUSY:
		vnotify("SUP Fileserver is currently busy\n");
		t->Tmode = SCMOK;
		doneack = FDONESRVERROR;
		donereason = "Fileserver is busy";
		(void) netcrypt(NULL);
		(void) msgdone();
		return (TRUE);
	default:
		goaway("Unrecognized file server setup status %d", setupack);
	}
	/* NOTREACHED */
	return (FALSE);
}

/***  Tell file server what account to use ***/

void
suplogin(void)
{
	char buf[STRINGLENGTH];
	int f, x;

	/* lock collection if desired */
	(void) snprintf(buf, sizeof buf, FILELOCK, collname);
	f = open(buf, O_RDONLY, 0);
	if (f >= 0) {

#if defined(LOCK_EX)
# define TESTLOCK(f)	flock(f, LOCK_EX|LOCK_NB)
# define SHARELOCK(f)	flock(f, LOCK_SH|LOCK_NB)
# define WAITLOCK(f)	flock(f, LOCK_EX)
#elif defined(F_LOCK)
# define TESTLOCK(f)	lockf(f, F_TLOCK, 0)
# define SHARELOCK(f)	1
# define WAITLOCK(f)	lockf(f, F_LOCK, 0)
#else
# define TESTLOCK(f)	(close(f), f = -1, 1)
# define SHARELOCK(f)	1
# define WAITLOCK(f)	1
#endif
		if (TESTLOCK(f) < 0) {
			if (errno != EWOULDBLOCK && errno != EAGAIN) {
				(void) close(f);
				goaway("Can't lock collection %s", collname);
			}
			if (SHARELOCK(f) < 0) {
				(void) close(f);
				if (errno == EWOULDBLOCK && errno != EAGAIN)
					goaway("Collection %s is locked by another sup",collname);
				goaway("Can't lock collection %s", collname);
			}
			vnotify("SUP Waiting for exclusive access lock\n");
			if (WAITLOCK(f) < 0) {
				(void) close(f);
				goaway("Can't lock collection %s", collname);
			}
		}
		thisC->Clockfd = f;
		vnotify("SUP Locked collection %s for exclusive access\n",
		    collname);
	}
	logcrypt = NULL;
	loguser = thisC->Clogin;
	logpswd = thisC->Cpswd;

#ifndef	CRYPTING  /* Define CRYPTING for backwards compatibility with old supfileservers */
	if (thisC->Clogin != NULL) /* othewise we only encrypt if there is a login id */
#endif	/* CRYPTING */
	{
		logcrypt = CRYPTTEST;
		(void) netcrypt(PSWDCRYPT);	/* encrypt password data */
	}
	x = msglogin();
#ifndef CRYPTING
	if (thisC->Clogin != NULL) 
#endif
		(void) netcrypt(NULL);		/* turn off encryption */
	if (x != SCMOK)
		goaway("Error sending login request to file server");
	x = msglogack();
	if (x != SCMOK)
		goaway("Error reading login reply from file server");
	if (logack == FLOGNG) {
		notify("SUP: %s\n", logerror);
		free(logerror);
		logerror = NULL;
		notify("SUP: Improper login to %s account",
			thisC->Clogin ? thisC->Clogin : "default");
		done(FDONESRVERROR, "Improper login");
	}
	if (netcrypt (thisC->Ccrypt) != SCMOK)	/* restore encryption */
		goaway("Running non-crypting sup");
}

/*
 *  Send list of files that we are not interested in.  Receive list of
 *  files that are on the repository that could be upgraded.  Find the
 *  ones that we need.  Receive the list of files that the server could
 *  not access.  Delete any files that have been upgraded in the past
 *  which are no longer on the repository.
 */
void
listfiles()
{
	char buf[STRINGLENGTH];
	char relsufix[STRINGLENGTH];
	char *p;
	FILE *f;
	int x;

	if ((thisC->Cflags&CFURELSUF) && release)
		(void) snprintf(relsufix, sizeof relsufix, ".%s", release);
	else
		relsufix[0] = '\0';
	(void) snprintf(buf, sizeof buf, FILELAST, collname, relsufix);
	f = fopen(buf, "r");
	if (f) {
		while ((p = fgets(buf, sizeof(buf), f)) != NULL) {
			p[strcspn(p, "\n")] = '\0';
			if (strchr("#;:", *p))
				continue;
			(void) Tinsert(&lastT, p, FALSE);
		}
		(void) fclose(f);
	}
	refuseT = NULL;
	(void) snprintf(buf, sizeof buf, FILEREFUSE, collname);
	f = fopen(buf, "r");
	if (f) {
		while ((p = fgets(buf, sizeof(buf), f)) != NULL) {
			p[strcspn(p, "\n")] = '\0';
			if (strchr("#;:", *p))
				continue;
			(void) Tinsert(&refuseT, p, FALSE);
		}
		(void) fclose(f);
	}
	vnotify("SUP Requesting changes since %s", ctime(&lasttime) + 4);
	x = msgrefuse();
	if (x != SCMOK)
		goaway ("Error sending refuse list to file server");
	listT = NULL;
	x = msglist();
	if (x != SCMOK)
		goaway("Error reading file list from file server");
	if (thisC->Cprefix)
		(void) chdir(thisC->Cprefix);
	needT = NULL;
	(void) Tprocess(listT, needone, NULL);
	Tfree(&listT);
	x = msgneed();
	if (x != SCMOK)
		goaway("Error sending needed files list to file server");
	Tfree(&needT);
	denyT = NULL;
	x = msgdeny();
	if (x != SCMOK)
		goaway("Error reading denied files list from file server");
	if (thisC->Cflags&CFVERBOSE)
		(void) Tprocess(denyT, denyone, NULL);
	Tfree(&denyT);
	if (thisC->Cflags&(CFALL|CFDELETE|CFOLD))
		(void) Trprocess(lastT, deleteone, NULL);
	Tfree(&refuseT);
}

static int
needone(t, dummy)
	TREE *t;
	void *dummy;
{
	TREE *newt;
	int exists, fetch;
	struct stat sbuf;

	newt = Tinsert (&lastT,t->Tname,TRUE);
	if (!newt)
		return (SCMERR);
	newt->Tflags |= FUPDATE;
	fetch = TRUE;
	if ((thisC->Cflags&CFALL) == 0) {
		if ((t->Tflags&FNEW) == 0 && (thisC->Cflags&CFOLD) == 0)
			return (SCMOK);
		if (S_ISLNK(t->Tmode))
			exists = (lstat(t->Tname,&sbuf) == 0);
		else
			exists = (stat(t->Tname,&sbuf) == 0);
		/*
		 * This is moderately complicated:
		 * If the file is the wrong type or doesn't exist, we need to
		 * fetch the whole file.  If the file is a special file, we
		 * rely solely on the server:  if the file changed, we do an
		 * update; otherwise nothing. If the file is a normal file,
		 * we check timestamps.  If we are in "keep" mode, we fetch if
		 * the file on the server is newer, and do nothing otherwise.
		 * Otherwise, we fetch if the timestamp is wrong; if the file
		 * changed on the server but the timestamp is right, we do an
		 * update.  (Update refers to updating stat information, i.e.
		 * timestamp, owner, mode bits, etc.)
		 */
		if (exists && (sbuf.st_mode&S_IFMT) == (t->Tmode&S_IFMT)) {
			if (!S_ISREG(t->Tmode)) {
				if (t->Tflags&FNEW)
					fetch = FALSE;
				else
					return (SCMOK);
			} else if ((thisC->Cflags&CFKEEP) &&
			    sbuf.st_mtime > t->Tmtime) {
				return (SCMOK);
			} else if (sbuf.st_mtime == t->Tmtime) {
				if (t->Tflags&FNEW)
					fetch = FALSE;
				else
					return (SCMOK);
			}
		}
	}
	/* If we get this far, we're either doing an update or a full fetch. */
	newt = Tinsert(&needT, t->Tname, TRUE);
	if (!newt)
		return (SCMERR);
	if (!fetch && S_ISREG(t->Tmode))
		newt->Tflags |= FUPDATE;
	return (SCMOK);
}

static int
denyone(t, v)
	TREE *t;
	void *v;
{

	vnotify("SUP: Access denied to %s\n", t->Tname);
	return (SCMOK);
}

static int
deleteone(t, v)
	TREE *t;
	void *v;
{
	struct stat sbuf, pbuf;
	int x;
	char *name = t->Tname;
	char pname[MAXPATHLEN];

	if (t->Tflags&FUPDATE)		/* in current upgrade list */
		return (SCMOK);
	if (lstat(name, &sbuf) < 0)	/* doesn't exist */
		return (SCMOK);
	/* is it a symbolic link ? */
	if (S_ISLNK(sbuf.st_mode)) {
		if (Tlookup(refuseT, name)) {
			vnotify("SUP Would not delete symbolic link %s\n",
			    name);
			return (SCMOK);
		}
		if (thisC->Cflags&CFLIST) {
			vnotify("SUP Would delete symbolic link %s\n", name);
			return (SCMOK);
		}
		if ((thisC->Cflags&CFDELETE) == 0) {
			notify("SUP Please delete symbolic link %s\n", name);
			t->Tflags |= FUPDATE;
			return (SCMOK);
		}
		x = unlink(name);
		if (x < 0) {
			notify("SUP: Unable to delete symbolic link %s\n",
			    name);
			t->Tflags |= FUPDATE;
			return (SCMOK);
		}
		vnotify("SUP Deleted symbolic link %s\n", name);
		return (SCMOK);
	}
	/* is it a directory ? */
	if (S_ISDIR(sbuf.st_mode)) {
		if (Tlookup(refuseT, name)) {
			vnotify("SUP Would not delete directory %s\n", name);
			return (SCMOK);
		}
		if (thisC->Cflags&CFLIST) {
			vnotify("SUP Would delete directory %s\n", name);
			return (SCMOK);
		}
		if ((thisC->Cflags&CFDELETE) == 0) {
			notify("SUP Please delete directory %s\n", name);
			t->Tflags |= FUPDATE;
			return (SCMOK);
		}
		if (rmdir(name) < 0) {
			(void) chmod(name, sbuf.st_mode|S_IRWXU);
			if (snprintf(pname, sizeof(pname), "%s/..", name) <
			    sizeof(pname)) {
				if (stat(pname, &pbuf) == 0)
					(void) chmod(pname,
					    pbuf.st_mode|S_IRWXU);
			}
			runp("rm", "rm", "-rf", name, 0);
		}
		if (lstat(name, &sbuf) == 0) {
			notify("SUP: Unable to delete directory %s\n", name);
			t->Tflags |= FUPDATE;
			return (SCMOK);
		}
		vnotify("SUP Deleted directory %s\n", name);
		return (SCMOK);
	}
	/* it is a file */
	if (Tlookup(refuseT, name)) {
		vnotify("SUP Would not delete file %s\n", name);
		return (SCMOK);
	}
	if (thisC->Cflags&CFLIST) {
		vnotify("SUP Would delete file %s\n", name);
		return (SCMOK);
	}
	if ((thisC->Cflags&CFDELETE) == 0) {
		notify("SUP Please delete file %s\n", name);
		t->Tflags |= FUPDATE;
		return (SCMOK);
	}
	x = unlink(name);
	if (x < 0) {
		notify("SUP: Unable to delete file %s\n", name);
		t->Tflags |= FUPDATE;
		return (SCMOK);
	}
	vnotify("SUP Deleted file %s\n", name);
	return (SCMOK);
}

/***************************************
 ***    R E C E I V E   F I L E S    ***
 ***************************************/

/*
 * Note for these routines, return code SCMOK generally means
 * NETWORK communication is OK; it does not mean that the current
 * file was correctly received and stored.  If a file gets messed
 * up, too bad, just print a message and go on to the next one;
 * but if the network gets messed up, the whole sup program loses
 * badly and best just stop the program as soon as possible.
 */
void recvfiles (void)
{
	int x;
	int recvmore;

	/* Does the protocol support compression */
	if (cancompress) {
		/* Check for compression on sending files */
		docompress = (thisC->Cflags&CFCOMPRESS);
		x = msgcompress();
		if ( x != SCMOK) 
			goaway("Error sending compression check to server");
		if (docompress)
			vnotify("SUP Using compressed file transfer\n");
	}
	recvmore = TRUE;
	upgradeT = NULL;
	do {
		x = msgsend();
		if (x != SCMOK)
			goaway("Error sending receive file request to file server");
		(void) Tinsert(&upgradeT, NULL, FALSE);
		x = msgrecv(recvone, &recvmore);
		if (x != SCMOK)
			goaway("Error receiving file from file server");
		Tfree(&upgradeT);
	} while (recvmore);
}

/* prepare the target, if necessary */
int
prepare(name, mode, newp, statp)
	char *name;
	int mode, *newp;
	struct stat *statp;
{
	char *type;
	char pname[MAXPATHLEN];
	struct stat pbuf;

	if (mode == S_IFLNK)
		*newp = (lstat(name, statp) < 0);
	else
		*newp = (stat(name, statp) < 0);
	if (*newp) {
		if (thisC->Cflags&CFLIST)
			return (FALSE);
		if (establishdir(name))
			return (TRUE);
		return (FALSE);
	}
	if (mode == (statp->st_mode&S_IFMT))
		return (FALSE);
	*newp = TRUE;
	switch (statp->st_mode&S_IFMT) {
	case S_IFDIR:
		type = "directory";
		break;
	case S_IFLNK:
		type = "symbolic link";
		break;
	case S_IFREG:
		type = "regular file";
		break;
	default:
		type = "unknown file";
		break;
	}
	if (thisC->Cflags&CFLIST) {
		vnotify("SUP Would remove %s %s\n", type, name);
		return (FALSE);
	}
	if (S_ISDIR(statp->st_mode)) {
		if (rmdir (name) < 0) {
			(void) chmod(name, statp->st_mode|S_IRWXU);
			if (snprintf(pname, sizeof(pname), "%s/..", name) <
			    sizeof(pname)) {
				if (stat(pname, &pbuf) == 0)
					(void) chmod(pname,
					    pbuf.st_mode|S_IRWXU);
			}
			runp ("rm", "rm", "-rf", name, 0);
		}
	} else
		(void) unlink(name);
	if (stat(name, statp) < 0) {
		vnotify("SUP Removed %s %s\n", type, name);
		return (FALSE);
	}
	notify("SUP: Couldn't remove %s %s\n", type, name);
	return (TRUE);
}

static int
recvone(t, ap)
	TREE *t;
	va_list ap;
{
	int x = 0;
	int new;
	struct stat sbuf;
	int *recvmore;

	recvmore = va_arg(ap, int *);
	va_end(ap);
	/* check for end of file list */
	if (t == NULL) {
		*recvmore = FALSE;
		return (SCMOK);
	}
	/* check for failed access at fileserver */
	if (t->Tmode == 0) {
		notify("SUP: File server unable to transfer file %s\n",
		    t->Tname);
		thisC->Cnogood = TRUE;
		return (SCMOK);
	}
	if (prepare(t->Tname, t->Tmode&S_IFMT, &new, &sbuf)) {
		notify("SUP: Can't prepare path for %s\n", t->Tname);
		if (S_ISREG(t->Tmode)) {
			x = readskip();		/* skip over file */
			if (x != SCMOK)
				goaway("Can't skip file transfer");
		}
		thisC->Cnogood = TRUE;
		return (SCMOK);
	}
	/* make file mode specific changes */
	switch (t->Tmode&S_IFMT) {
	case S_IFDIR:
		x = recvdir(t, new, &sbuf);
		break;
	case S_IFLNK:
		x = recvsym(t, new, &sbuf);
		break;
	case S_IFREG:
		x = recvreg(t, new, &sbuf);
		break;
	default:
		goaway("Unknown file type %o\n", t->Tmode&S_IFMT);
	}
	if (x) {
		thisC->Cnogood = TRUE;
		return (SCMOK);
	}
	if (S_ISREG(t->Tmode))
		(void) Tprocess(t->Tlink, linkone, t->Tname);
	(void) Tprocess(t->Texec, execone, NULL);
	return (SCMOK);
}

int
recvdir(t, new, statp)		/* receive directory from network */
	TREE *t;
	int new;
	struct stat *statp;
{
	struct timeval tbuf[2];

	if (new) {
		if (thisC->Cflags&CFLIST) {
			vnotify("SUP Would create directory %s\n", t->Tname);
			return (FALSE);
		}
		if (makedir(t->Tname, 0755, statp) == -1) {
			vnotify("SUP: Can't create directory %s\n", t->Tname);
			return TRUE;
		}
	}
	if ((t->Tflags&FNOACCT) == 0) {
		/* convert user and group names to local ids */
		ugconvert(t->Tuser, t->Tgroup, &t->Tuid, &t->Tgid, &t->Tmode);
	}
	if (!new && (t->Tflags&FNEW) == 0 && statp->st_mtime == t->Tmtime) {
		if (t->Tflags&FNOACCT)
			return (FALSE);
		if (statp->st_uid == t->Tuid && statp->st_gid == t->Tgid)
			return (FALSE);
	}
	if (thisC->Cflags&CFLIST) {
		vnotify ("SUP Would update directory %s\n", t->Tname);
		return (FALSE);
	}
	if ((t->Tflags&FNOACCT) == 0) {
		(void) chown(t->Tname, t->Tuid, t->Tgid);
		(void) chmod(t->Tname, t->Tmode&S_IMODE);
	}
	tbuf[0].tv_sec = time(NULL);
	tbuf[0].tv_usec = 0;
	tbuf[1].tv_sec = t->Tmtime;
	tbuf[1].tv_usec = 0;
	if (!noutime)
		(void) utimes(t->Tname, tbuf);
	if (new)
		vnotify("SUP Created directory %s\n", t->Tname);
	else
		v2notify("SUP Updated directory %s\n", t->Tname);
	return (FALSE);
}

int
recvsym(t, new, statp)			/* receive symbolic link */
	TREE *t;
	int new;
	struct stat *statp;
{
	char buf[STRINGLENGTH];
	int n;
	char *linkname;

	if (t->Tlink == NULL || t->Tlink->Tname == NULL) {
		notify("SUP: Missing linkname for symbolic link %s\n",
			t->Tname);
		return (TRUE);
	}
	linkname = t->Tlink->Tname;
	memset(buf, 0, sizeof(buf));
	if (!new && (t->Tflags&FNEW) == 0 &&
	    (n = readlink(t->Tname, buf, sizeof(buf)-1)) >= 0 &&
	    (n == strlen(linkname)) && (strncmp (linkname, buf, n) == 0))
		return (FALSE);
	if (thisC->Cflags&CFLIST) {
		vnotify("SUP Would %s symbolic link %s to %s\n",
			new ? "create" : "update", t->Tname, linkname);
		return (FALSE);
	}
	if (!new)
		(void) unlink(t->Tname);
	if (symlink(linkname, t->Tname) < 0 || lstat(t->Tname, statp) < 0) {
		notify("SUP: Unable to create symbolic link %s\n", t->Tname);
		return (TRUE);
	}
	vnotify("SUP Created symbolic link %s to %s\n", t->Tname, linkname);
	return (FALSE);
}

int
recvreg(t, new, statp)			/* receive file from network */
	TREE *t;
	int new;
	struct stat *statp;
{
	FILE *fin, *fout;
	char dirpart[STRINGLENGTH], filepart[STRINGLENGTH];
	char filename[STRINGLENGTH], buf[STRINGLENGTH];
	struct timeval tbuf[2];
	int x;
	char *p;

	if (t->Tflags&FUPDATE) {
		if ((t->Tflags&FNOACCT) == 0) {
			/* convert user and group names to local ids */
			ugconvert(t->Tuser, t->Tgroup, &t->Tuid, &t->Tgid,
			    &t->Tmode);
		}
		if (!new && (t->Tflags&FNEW) == 0 &&
		    statp->st_mtime == t->Tmtime) {
			if (t->Tflags&FNOACCT)
				return (FALSE);
			if (statp->st_uid == t->Tuid &&
			    statp->st_gid == t->Tgid)
				return (FALSE);
		}
		if (thisC->Cflags&CFLIST) {
			vnotify("SUP Would update file %s\n", t->Tname);
			return (FALSE);
		}
		vnotify("SUP Updating file %s\n", t->Tname);
		if ((t->Tflags&FNOACCT) == 0) {
			(void) chown(t->Tname, t->Tuid, t->Tgid);
			(void) chmod(t->Tname, t->Tmode&S_IMODE);
		}
		tbuf[0].tv_sec = time(NULL);
		tbuf[0].tv_usec = 0;
		tbuf[1].tv_sec = t->Tmtime;
		tbuf[1].tv_usec = 0;
		if (!noutime)
			(void) utimes(t->Tname, tbuf);
		return (FALSE);
	}
	if (thisC->Cflags&CFLIST) {
		if (new)
			p = "create";
		else if (statp->st_mtime < t->Tmtime)
			p = "receive new";
		else if (statp->st_mtime > t->Tmtime)
			p = "receive old";
		else
			p = "receive";
		vnotify("SUP Would %s file %s\n", p, t->Tname);
		return (FALSE);
	}
	vnotify("SUP Receiving file %s\n", t->Tname);
	if (!new && S_ISREG(t->Tmode) &&
	    (t->Tflags&FBACKUP) && (thisC->Cflags&CFBACKUP)) {
		fin = fopen(t->Tname, "r");	/* create backup */
		if (fin == NULL) {
			x = readskip();		/* skip over file */
			if (x != SCMOK)
				goaway("Can't skip file transfer");
			notify("SUP: Can't open %s to create backup\n",
			    t->Tname);
			return (TRUE);		/* mark upgrade as nogood */
		}
		path(t->Tname, dirpart, sizeof dirpart, filepart, sizeof filepart);
		(void) snprintf(filename, sizeof filename, FILEBACKUP,
		    dirpart, filepart);
		fout = fopen(filename, "w");
		if (fout == NULL) {
			(void) snprintf(buf, sizeof buf, FILEBKDIR, dirpart);
			(void) mkdir(buf, 0755);
			fout = fopen(filename, "w");
		}
		if (fout == NULL) {
			x = readskip();		/* skip over file */
			if (x != SCMOK)
				goaway("Can't skip file transfer");
			notify("SUP: Can't create %s for backup\n", filename);
			(void) fclose(fin);
			return (TRUE);
		}
		ffilecopy(fin, fout);
		(void) fclose(fin);
		(void) fclose(fout);
		vnotify("SUP Backup of %s created\n", t->Tname);
	}
	x = copyfile(t->Tname, NULL);
	if (x)
		return (TRUE);
	if ((t->Tflags&FNOACCT) == 0) {
		/* convert user and group names to local ids */
		ugconvert(t->Tuser, t->Tgroup, &t->Tuid, &t->Tgid, &t->Tmode);
		(void) chown(t->Tname, t->Tuid, t->Tgid);
		(void) chmod(t->Tname, t->Tmode&S_IMODE);
	}
	tbuf[0].tv_sec = time(NULL);
	tbuf[0].tv_usec = 0;
	tbuf[1].tv_sec = t->Tmtime;
	tbuf[1].tv_usec = 0;
	if (!noutime)
		(void) utimes(t->Tname, tbuf);
	return (FALSE);
}

static int
linkone(t, fv)			/* link to file already received */
	TREE *t;
	void *fv;
{
	char *fname = fv;
	struct stat fbuf,sbuf;
	char *name = t->Tname;
	int new,x;
	char *type;

	if (stat(fname, &fbuf) < 0) {	/* source file */
		if (thisC->Cflags&CFLIST) {
			vnotify("SUP Would link %s to %s\n", name, fname);
			return (SCMOK);
		}
		notify("SUP: Can't link %s to missing file %s\n", name, fname);
		thisC->Cnogood = TRUE;
		return (SCMOK);
	}
	if (prepare(name,S_IFREG, &new, &sbuf)) {
		notify("SUP: Can't prepare path for link %s\n", name);
		thisC->Cnogood = TRUE;
		return (SCMOK);
	}
	if (!new && (t->Tflags&FNEW) == 0 &&
	    fbuf.st_dev == sbuf.st_dev && fbuf.st_ino == sbuf.st_ino)
		return (SCMOK);
	if (thisC->Cflags&CFLIST) {
		vnotify("SUP Would link %s to %s\n", name, fname);
		return (SCMOK);
	}
	(void) unlink(name);
	type = "";
	if ((x = link(fname,name)) < 0) {
		type = "symbolic ";
		x = symlink(fname, name);
	}
	if (x < 0 || lstat(name, &sbuf) < 0) {
		notify ("SUP: Unable to create %slink %s\n", type, name);
		return (TRUE);
	}
	vnotify("SUP Created %slink %s to %s\n", type, name, fname);
	return (SCMOK);
}

static int
execone(t, v)			/* execute command for file */
	TREE *t;
	void *v;
{
	int w;

	if (thisC->Cflags&CFLIST) {
		vnotify("SUP Would execute %s\n", t->Tname);
		return (SCMOK);
	}
	if ((thisC->Cflags&CFEXECUTE) == 0) {
		notify("SUP Please execute %s\n", t->Tname);
		return (SCMOK);
	}
	vnotify("SUP Executing %s\n", t->Tname);

	w = system(t->Tname);
	if (WIFEXITED(w) && WEXITSTATUS(w) != 0) {
		notify("SUP: Execute command returned failure status %#o\n",
		    WEXITSTATUS(w));
		thisC->Cnogood = TRUE;
	} else if (WIFSIGNALED(w)) {
		notify("SUP: Execute command killed by signal %d\n",
		    WTERMSIG(w));
		thisC->Cnogood = TRUE;
	} else if (WIFSTOPPED(w)) {
		notify("SUP: Execute command stopped by signal %d\n",
		    WSTOPSIG(w));
		thisC->Cnogood = TRUE;
	}
	return (SCMOK);
}

int
copyfile(to, from)
	char *to;
	char *from;		/* 0 if reading from network */
{
	int fromf, tof, istemp, x;
	char dpart[STRINGLENGTH], fpart[STRINGLENGTH];
	char tname[MAXPATHLEN];
	static int true = 1;
	static pid_t thispid = 0;	/* process id # */

	if (from) {			/* reading file */
		fromf = open(from, O_RDONLY, 0);
		if (fromf < 0) {
			notify("SUP: Can't open %s to copy to %s: %s\n",
			    from, to, errmsg(-1));
			return (TRUE);
		}
	} else				/* reading network */
		fromf = -1;
	istemp = TRUE;			/* try to create temp file */
	lockout(TRUE);			/* block interrupts */
	if (thispid == 0)
		thispid = getpid();
	/* Now try hard to find a temp file name.  Try VERY hard. */
	for (;;) {
	/* try destination directory */
		path(to, dpart, sizeof dpart, fpart, sizeof fpart);
		(void) snprintf(tname, sizeof tname, "%s/#%ld.sup.XXXXXXXXXX",
		    dpart, (long)thispid);
		tof = mkstemp(tname);
		if (tof >= 0)
			break;
	/* try sup directory */
		if (thisC->Cprefix)
			(void) chdir (thisC->Cbase);
		(void) snprintf(tname, sizeof tname, "sup/#%ld.sup.XXXXXXXXXX",
		    (long)thispid);
		tof = mkstemp(tname);
		if (tof >= 0) {
			if (thisC->Cprefix)
				(void) chdir(thisC->Cprefix);
			break;
		}
	/* try base directory */
		(void) snprintf(tname, sizeof tname, "#%ld.sup.XXXXXXXXXX",
		    (long)thispid);
		tof = mkstemp(tname);
		if (thisC->Cprefix)
			(void) chdir(thisC->Cprefix);
		if (tof >= 0)
			break;
#ifdef	VAR_TMP
	/* try /var/tmp */
		(void) snprintf(tname, sizeof tname,
		    "/var/tmp/#%ld.sup.XXXXXXXXXX", (long)thispid);
		tof = mkstemp(tname);
		if (tof >= 0)
			break;
#else
	/* try /usr/tmp */
		(void) snprintf(tname, sizeof tname,
		    "/usr/tmp/#%ld.sup.XXXXXXXXXX", (long)thispid);
		tof = mkstemp(tname);
		if (tof >= 0)
			break;
#endif
	/* try /tmp */
		(void) snprintf(tname, sizeof tname,
		    "/tmp/#%ld.sup.XXXXXXXXXX", (long)thispid);
		tof = mkstemp(tname);
		if (tof >= 0)
			break;
		istemp = FALSE;
	/* give up: try to create output file */
		if (!docompress)
			tof = open(to, (O_WRONLY|O_CREAT|O_TRUNC), 0600);
		if (tof >= 0)
			break;
	/* no luck */
		notify("SUP: Can't create %s or temp file for it\n", to);
		lockout (FALSE);
		if (fromf >= 0)
			(void) close (fromf);
		else {
			x = readskip();
			if (x != SCMOK)
				goaway("Can't skip file transfer");
		}
		if (true)
			return (TRUE);
	}
	if (fromf >= 0) {		/* read file */
		x = filecopy(fromf, tof);
		(void) close(fromf);
		(void) close(tof);
		if (x < 0) {
			notify("SUP: Error in copying %s to %s\n", from, to);
			if (istemp)
				(void) unlink(tname);
			lockout(FALSE);
			return (TRUE);
		}
	} else {			/* read network */
#if	MACH
		if (!rpauseflag) {
			int fsize;
			struct fsparam fsp;

			x = prereadcount(&fsize);
			if (x != SCMOK) {
				if (istemp)
					(void) unlink(tname);
				lockout(FALSE);
				x = readskip();
				if (x != SCMOK)
					goaway("Can't skip file transfer");
				goaway("Error in server space check");
				logquit(1, "Error in server space check");
			}
			errno = 0;
			if (ioctl(tof, FIOCFSPARAM, (char *)&fsp) < 0 &&
			    errno != EINVAL) {
				if (istemp)
					(void) unlink(tname);
				lockout(FALSE);
				x = readskip();
				if (x != SCMOK)
					goaway("Can't skip file transfer");
				goaway("Error in disk space check");
				logquit(1, "Error in disk space check");
			}
			if (errno == 0) {
				fsize = (fsize + 1023) / 1024;
				x = fsp.fsp_size * MAX (fsp.fsp_minfree, 1) / 100;
				fsp.fsp_free -= x;
				if (fsize > MAX (fsp.fsp_free, 0)) {
					if (istemp)
						(void) unlink(tname);
					lockout(FALSE);
					x = readskip();
					if (x != SCMOK)
						goaway("Can't skip file transfer");
					goaway("No disk space for file %s", to);
					logquit (1, "No disk space for file %s",
					    to);
				}
			}
		}
#endif	/* MACH */
		x = readfile(tof);
		(void) close(tof);
		if (x != SCMOK) {
			if (istemp)
				(void) unlink(tname);
			lockout(FALSE);
			goaway("Error in receiving %s\n", to);
		}
	}
	if (!istemp) {			/* no temp file used */
		lockout(FALSE);
		return (FALSE);
	}
	/*
	 * If the file is compressed, uncompress it in place.  We open the
	 * temp file for reading, unlink the file, and then open the same
	 * file again for writing.  Then we pipe through gzip.  When 
	 * finished the temp file contains the uncompressed version and we
	 * can continue as before.
	 *
	 * Since sup prefers to write close to the original file the
	 * benefits of atomic updates probably outweigh the cost of the
	 * extra filecopy which occurs when the temp file is on a different
	 * filesystem from the original.
	 */
	if (docompress) {
		char *av[4];
		int   ac = 0;
		int   infd = -1;
		int   outfd = -1;
		av[ac++] = "gzip";
		av[ac++] = "-d";
		av[ac++] = NULL;
		/* XXX - race between unlink and re-open */
		if ((infd = open(tname, O_RDONLY, 0)) == -1 ||
		     unlink(tname) == -1 ||
		     (outfd = open(tname, O_WRONLY|O_CREAT|O_EXCL, 0600)) == -1 ||
		     runiofd(av, infd, outfd, 2) != 0 ) {
			notify("SUP: Error in uncompressing file %s (%s)\n",
				to, tname);
			(void) unlink(tname);
			if (infd != -1)
				(void) close(infd);
			if (outfd != -1)
				(void) close(outfd);
			lockout(FALSE);
			return(TRUE);
		}
		(void) close(infd);
		(void) close(outfd);
	}
	/* move to destination */
	if (rename(tname, to) == 0) {
		(void) unlink(tname);
		lockout(FALSE);
		return(FALSE);
	}
	fromf = open(tname, O_RDONLY, 0);
	if (fromf < 0) {
		notify ("SUP: Error in moving temp file to %s: %s\n",
			to, errmsg (-1));
		(void) unlink(tname);
		lockout(FALSE);
		return (TRUE);
	}
	tof = open(to, O_WRONLY|O_CREAT|O_TRUNC, 0600);
	if (tof < 0) {
		(void) close(fromf);
		notify("SUP: Can't create %s from temp file: %s\n",
			to, errmsg(-1));
		(void) unlink(tname);
		lockout(FALSE);
		return (TRUE);
	}
	x = filecopy(fromf, tof);
	(void) close(fromf);
	(void) close(tof);
	(void) unlink(tname);
	lockout(FALSE);
	if (x < 0) {
		notify("SUP: Error in storing data in %s\n", to);
		return (TRUE);
	}
	return (FALSE);
}

/***  Finish connection with file server ***/

void
finishup(x)
	int x;
{
	char tname[STRINGLENGTH], fname[STRINGLENGTH];
	char relsufix[STRINGLENGTH];
	char collrelname[STRINGLENGTH];
	time_t tloc;
	FILE *finishfile;		/* record of all filenames */

	if ((thisC->Cflags&CFURELSUF) && release) {
		(void) snprintf(relsufix, sizeof relsufix, ".%s", release);
		(void) snprintf(collrelname, sizeof collrelname,
		    "%s-%s", collname, release);
	} else {
		relsufix[0] = '\0';
		(void) strlcpy(collrelname, collname, sizeof collrelname);
	}
	dontjump = TRUE;		/* once here, no more longjmp */
	(void) netcrypt(NULL);
	if (protver < 6) {
		/* done with server */
		if (x == SCMOK)
			goaway(NULL);
		(void) requestend();
	}
	tloc = time(NULL);
	if (x != SCMOK) {
		notify("SUP: Upgrade of %s aborted at %s", collrelname,
		    ctime(&tloc) + 4);
		Tfree(&lastT);
		if (protver < 6)
			return;
		/* if we've not been blown off, make sure he is! */
		if (x != SCMEOF)
			goaway("Aborted");
		(void) requestend();
		return;
	}
	if (thisC->Cnogood) {
		notify("SUP: Upgrade of %s completed with errors at %s",
		    collrelname, ctime(&tloc) + 4);
		notify("SUP: Upgrade time will not be updated\n");
		Tfree(&lastT);
		if (protver < 6)
			return;
		done(FDONEUSRERROR, "Completed with errors");
		(void) requestend();
		return;
	}
	if (thisC->Cprefix)
		(void) chdir(thisC->Cbase);
	vnotify("SUP Upgrade of %s completed at %s", collrelname,
	    ctime(&tloc) + 4);
	if (thisC->Cflags&CFLIST) {
		Tfree(&lastT);
		if (protver < 6)
			return;
		done(FDONEDONTLOG, "List only");
		(void) requestend();
		return;
	}
	(void) snprintf(fname, sizeof fname, FILEWHEN, collname, relsufix);
	if (establishdir(fname)) {
		notify("SUP: Can't create directory for upgrade timestamp\n");
		Tfree(&lastT);
		if (protver < 6)
			return;
		done(FDONEUSRERROR, "Couldn't timestamp");
		(void) requestend();
		return;
	}
	if (!putwhen(fname, scantime)) {
		notify("SUP: Can't record current time in %s: %s\n",
		    fname,errmsg (-1));
		Tfree(&lastT);
		if (protver < 6)
			return;
		done(FDONEUSRERROR,"Couldn't timestamp");
		(void) requestend();
		return;
	}
	if (protver >= 6) {
		/*
		 * At this point we have let the server go
		 * "I'm sorry, we've had to let you go"
		 */
		done(FDONESUCCESS, "Success");
		(void) requestend();
	}
	(void) snprintf(tname, sizeof tname, FILELASTTEMP, collname, relsufix);
	finishfile = fopen(tname, "w");
	if (finishfile == NULL) {
		notify("SUP: Can't record list of all files in %s\n", tname);
		Tfree(&lastT);
		return;
	}
	(void) Tprocess(lastT, finishone, finishfile);
	(void) fclose(finishfile);
	(void) snprintf(fname, sizeof fname, FILELAST, collname, relsufix);
	if (rename(tname, fname) < 0)
		notify("SUP: Can't change %s to %s\n", tname, fname);
	(void) unlink(tname);
	Tfree(&lastT);
}

int
finishone(t, fv)
	TREE *t;
	void *fv;
{
	FILE *finishfile = fv;

	if ((thisC->Cflags&CFDELETE) == 0 || (t->Tflags&FUPDATE))
		fprintf(finishfile, "%s\n", t->Tname);
	return (SCMOK);
}

void
done (int value,char *fmt,...)
{
	char buf[STRINGLENGTH];
	va_list ap;

	va_start(ap, fmt);
	(void) netcrypt(NULL);

	if (fmt) 
		vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);
	if (protver < 6) {
		if (goawayreason)
			free(goawayreason);
		goawayreason = (fmt) ? strdup(buf) : NULL;
		(void) msggoaway();
	}
	else {
		doneack = value;
		donereason = (fmt) ? buf : NULL;
		(void) msgdone();
	}
	if (!dontjump)
		longjmp(sjbuf, TRUE);
}

void
goaway (char *fmt,...)
{
	char buf[STRINGLENGTH];
	va_list ap;

	va_start(ap, fmt);
	(void) netcrypt (NULL);
	if (fmt) {
		vsnprintf(buf, sizeof(buf), fmt, ap);
		goawayreason = buf;
	} else
		goawayreason = NULL;
	va_end(ap);
	(void) msggoaway();
	if (fmt) {
		if (thisC)
			notify("SUP: %s\n", buf);
		else
			printf("SUP: %s\n", buf);
	}
	if (!dontjump)
		longjmp(sjbuf,TRUE);
}
@


1.23
log
@remove some warnings:
unused variable `variable'
`variable' might be used uninitialized in this function

ok gilles@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.22 2007/09/11 15:47:17 gilles Exp $	*/
@


1.22
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.21 2005/04/27 18:13:16 mickey Exp $	*/
d492 1
a492 1
	char *p,*q;
@


1.21
log
@make -v print only actual changes and add -V for old behaviour; beck@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.20 2005/03/26 21:37:56 mickey Exp $	*/
d504 1
a504 2
			if ((q = strchr(p, '\n')))
				*q = '\0';
d516 1
a516 2
			if ((q = strchr(p, '\n')))
				*q = '\0';
@


1.20
log
@check for null and return error instead of stepping over it
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.19 2003/09/04 03:24:07 beck Exp $	*/
d926 4
a929 1
	vnotify("SUP %s directory %s\n", new ? "Created" : "Updated", t->Tname);
@


1.19
log
@millert's sup fix, tested here on client and server.
committing in absentia for todd, ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.18 2003/04/15 07:21:09 deraadt Exp $	*/
d564 2
d607 2
@


1.18
log
@a bit of string cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.17 2002/06/12 06:07:16 mpech Exp $	*/
d1157 1
a1157 1
	char tname[STRINGLENGTH];
d1178 1
a1178 1
		(void) snprintf(tname, sizeof tname, "%s/#%ld.sup",
d1180 1
a1180 1
		tof = open(tname, (O_WRONLY|O_CREAT|O_TRUNC), 0600);
d1186 1
a1186 1
		(void) snprintf(tname, sizeof tname, "sup/#%ld.sup",
d1188 1
a1188 1
		tof = open(tname, (O_WRONLY|O_CREAT|O_TRUNC), 0600);
d1195 1
a1195 1
		(void) snprintf(tname, sizeof tname, "#%ld.sup",
d1197 1
a1197 1
		tof = open (tname,(O_WRONLY|O_CREAT|O_TRUNC),0600);
d1204 3
a1206 3
		(void) snprintf(tname, sizeof tname, "/var/tmp/#%ld.sup",
		    (long)thispid);
		tof = open(tname, (O_WRONLY|O_CREAT|O_TRUNC), 0600);
d1211 3
a1213 3
		(void) snprintf(tname, sizeof tname, "/usr/tmp/#%ld.sup",
			(long)thispid);
		tof = open(tname, (O_WRONLY|O_CREAT|O_TRUNC), 0600);
d1218 3
a1220 3
		(void) snprintf(tname, sizeof tname, "/tmp/#%ld.sup",
		    (long)thispid);
		tof = open(tname, (O_WRONLY|O_CREAT|O_TRUNC), 0600);
d1333 1
d1336 1
a1336 1
		     (outfd = open(tname, O_WRONLY|O_CREAT|O_TRUNC, 0600)) == -1 ||
@


1.17
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.16 2002/02/19 19:39:39 millert Exp $	*/
d1030 1
a1030 1
		path(t->Tname, dirpart, filepart, sizeof filepart);
d1177 1
a1177 1
		path(to, dpart, fpart, sizeof fpart);
@


1.17.4.1
log
@MFC:
Fixes by tedu@@ and beck@@

fp leak.  from Patrick Latifi.
and
millert's sup fix, tested here on client and server.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.17 2002/06/12 06:07:16 mpech Exp $	*/
d1157 1
a1157 1
	char tname[MAXPATHLEN];
d1178 1
a1178 1
		(void) snprintf(tname, sizeof tname, "%s/#%ld.sup.XXXXXXXXXX",
d1180 1
a1180 1
		tof = mkstemp(tname);
d1186 1
a1186 1
		(void) snprintf(tname, sizeof tname, "sup/#%ld.sup.XXXXXXXXXX",
d1188 1
a1188 1
		tof = mkstemp(tname);
d1195 1
a1195 1
		(void) snprintf(tname, sizeof tname, "#%ld.sup.XXXXXXXXXX",
d1197 1
a1197 1
		tof = mkstemp(tname);
d1204 3
a1206 3
		(void) snprintf(tname, sizeof tname,
		    "/var/tmp/#%ld.sup.XXXXXXXXXX", (long)thispid);
		tof = mkstemp(tname);
d1211 3
a1213 3
		(void) snprintf(tname, sizeof tname,
		    "/usr/tmp/#%ld.sup.XXXXXXXXXX", (long)thispid);
		tof = mkstemp(tname);
d1218 3
a1220 3
		(void) snprintf(tname, sizeof tname,
		    "/tmp/#%ld.sup.XXXXXXXXXX", (long)thispid);
		tof = mkstemp(tname);
a1332 1
		/* XXX - race between unlink and re-open */
d1335 1
a1335 1
		     (outfd = open(tname, O_WRONLY|O_CREAT|O_EXCL, 0600)) == -1 ||
@


1.17.2.1
log
@MFC:
Fixes by tedu@@ and beck@@

fp leak.  from Patrick Latifi.
and
millert's sup fix, tested here on client and server.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.17 2002/06/12 06:07:16 mpech Exp $	*/
d1157 1
a1157 1
	char tname[MAXPATHLEN];
d1178 1
a1178 1
		(void) snprintf(tname, sizeof tname, "%s/#%ld.sup.XXXXXXXXXX",
d1180 1
a1180 1
		tof = mkstemp(tname);
d1186 1
a1186 1
		(void) snprintf(tname, sizeof tname, "sup/#%ld.sup.XXXXXXXXXX",
d1188 1
a1188 1
		tof = mkstemp(tname);
d1195 1
a1195 1
		(void) snprintf(tname, sizeof tname, "#%ld.sup.XXXXXXXXXX",
d1197 1
a1197 1
		tof = mkstemp(tname);
d1204 3
a1206 3
		(void) snprintf(tname, sizeof tname,
		    "/var/tmp/#%ld.sup.XXXXXXXXXX", (long)thispid);
		tof = mkstemp(tname);
d1211 3
a1213 3
		(void) snprintf(tname, sizeof tname,
		    "/usr/tmp/#%ld.sup.XXXXXXXXXX", (long)thispid);
		tof = mkstemp(tname);
d1218 3
a1220 3
		(void) snprintf(tname, sizeof tname,
		    "/tmp/#%ld.sup.XXXXXXXXXX", (long)thispid);
		tof = mkstemp(tname);
a1332 1
		/* XXX - race between unlink and re-open */
d1335 1
a1335 1
		     (outfd = open(tname, O_WRONLY|O_CREAT|O_EXCL, 0600)) == -1 ||
@


1.16
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.15 2002/02/16 21:27:54 millert Exp $	*/
d287 2
a288 2
	vnotify("SUP Fileserver %d.%d (%s) %d on %s at %.8s\n", protver,
	    pgmver, scmver, fspid, remotehost(), ctime(&tloc) + 11);
d1159 1
a1159 1
	static int thispid = 0;		/* process id # */
d1178 2
a1179 2
		(void) snprintf(tname, sizeof tname, "%s/#%d.sup",
		    dpart, thispid);
d1186 2
a1187 1
		(void) snprintf(tname, sizeof tname, "sup/#%d.sup", thispid);
d1195 2
a1196 1
		(void) snprintf(tname, sizeof tname, "#%d.sup", thispid);
d1204 2
a1205 2
		(void) snprintf(tname, sizeof tname, "/var/tmp/#%d.sup",
		    thispid);
d1211 2
a1212 2
		(void) snprintf(tname, sizeof tname, "/usr/tmp/#%d.sup",
			thispid);
d1218 2
a1219 2
		(void) snprintf(tname, sizeof tname, "/tmp/#%d.sup",
		    thispid);
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.14 2001/05/04 22:16:16 millert Exp $	*/
a1503 1
#ifdef __STDC__
a1504 5
#else
/*VARARGS*//*ARGSUSED*/
done (va_alist)
va_dcl
#endif
a1508 1
#ifdef __STDC__
a1509 8
#else
	int value;
	char *fmt;

	va_start(ap);
	value = va_arg(ap, int);
	fmt = va_arg(ap, char *);
#endif
a1530 1
#ifdef __STDC__
a1531 5
#else
/*VARARGS*//*ARGSUSED*/
goaway (va_alist)
va_dcl
#endif
a1535 1
#ifdef __STDC__
a1536 7
#else
	char *fmt;

	va_start(ap);
	fmt = va_arg(ap, char *);
#endif

@


1.14
log
@o kill register
o lots of KNF
o passes -Wall
o fix some [ug]id_t vs. int issues
o use strlcpy/strlcat in favor of strncpy/strncat
o use mem* routines everywhere instead of old b* ones
o marked several questionable things for later fixing
o kill ci.c and cvt.c -- we don't use them
o kill read_line.c since it requires fgetln() (bad for portability)
o kill salloc.c since it is the same as strup()
o Replaced some #ifdef __OpenBSD__ with better tests
o remaining problems: malloc return values are rarely checked, select misuse
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.13 2001/05/02 22:56:53 millert Exp $	*/
d136 7
a142 7
static int needone __P((TREE *, void *));
static int recvone __P((TREE *, va_list));
static int denyone __P((TREE *, void *));
static int deleteone __P((TREE *, void *));
static int linkone __P((TREE *, void *));
static int execone __P((TREE *, void *));
static int finishone __P((TREE *, void *));
@


1.13
log
@Sync with NetBSD.  Notable changes:
 o Add libwrap support to supfilesrv, conditioned by #ifdef LIBWRAP
   (on by default). <bouyer@@netbsd.org>
 o Renamed '-l' (the 'live' mode) to '-d' and '-l' is now used to
   enable logging of successfull connections. <bouyer@@netbsd.org>
 o Don't botch varargs: the are not always an array of void * in the stack...
   Write a separate function to convert a list of function parameters to
   explain why execv failed. <christos@@netbsd.org>
 o When in compress mode, don't overwrite the destination file directly,
   write a temp file and use rename when it is done. (From James Mathiesen
   <james@@deshaw.com>)
 o Rename errno variable to error to avoid collision with errno.h and remove
   explicit extern of errno (we get it from errno.h) <mycroft@@netbsd.org>
 o Cleanup unsigned char vs. char
 o Add -u flag, that prevents sup from attempting to restore a and m times
   on the received files.
 o Replace the provided read_line function with calls to the fparseln function
   in libutil.  Maintain compatibility on machines without fparseln through
   the NEED_READ_LINE define.
 o Rename login() to suplogin() to avoid name collition in util.h
 o If rmdir() fails, chmod the path to have r/w/x perms and run "rm -rf"
 o avoid last.temp filename collision by using rel-suffix
 o When creating directories, make sure you remove previous non-directories
   before doing so, otherwise sup fails.
 o Add -q flag to supscan for quiet operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.12 2001/04/29 22:45:12 millert Exp $	*/
d124 2
a125 2
int cancompress=FALSE;			/* Can we do compression? */
int docompress=FALSE;			/* Do we do compression? */
d145 2
a146 1
/* The next two routines define the fsm to support multiple fileservers
d149 4
a152 3
int getonehost (t,v)
register TREE *t;
void *v;
d155 1
d170 4
a173 3
TREE *getcollhost (tout,backoff,state,nhostsp)
int *tout,*backoff,*nhostsp;
long *state;
d183 2
a184 2
	if (Tprocess (thisC->Chtree, getonehost, state) == SCMEOF) {
		if (*state != 0 && nhosts == 0 && !dobackoff (tout,backoff))
d195 1
a195 1
	return (getcollhost (tout,backoff,state,nhostsp));
d198 2
a199 1
/*  Upgrade a collection from the file server on the appropriate
d202 2
a203 2

void getcoll (void)
d205 3
a207 3
	register TREE *t;
	register int x;
	int tout,backoff,nhosts;
d217 1
a217 1
		t = getcollhost (&tout,&backoff,&state,&nhosts);
d219 2
a220 2
			finishup (SCMEOF);
			notify ((char *)NULL);
d225 1
a225 1
		if (!setjmp (sjbuf) && !signon (t,nhosts,&tout) && !setup (t))
d227 1
a227 1
		(void) requestend ();
d230 1
a230 1
	if (setjmp (sjbuf))
d233 3
a235 3
		suplogin ();
		listfiles ();
		recvfiles ();
d239 1
a239 1
		(void) close (thisC->Clockfd);
d242 2
a243 2
	finishup (x);
	notify ((char *)NULL);
d248 4
a251 4
int signon (t,nhosts,tout)
register TREE *t;
int nhosts;
int *tout;
d253 1
a253 1
	register int x;
d257 2
a258 2
	if ((thisC->Cflags&CFLOCAL) == 0 && thishost (thisC->Chost->Tname)) {
		vnotify ("SUP: Skipping local collection %s\n",collname);
d266 2
a267 2
	x = request (portdebug?DEBUGFPORT:FILEPORT,
			thisC->Chost->Tname,&timeout);
d272 2
a273 2
			notify ("SUP: Can't connect to host %s\n",
				thisC->Chost->Tname);
d280 1
a280 1
	x = msgsignon ();	/* signon to fileserver */
d282 2
a283 2
		goaway ("Error sending signon request to fileserver");
	x = msgsignonack ();	/* receive signon ack from fileserver */
d285 5
a289 5
		goaway ("Error reading signon reply from fileserver");
	tloc = time ((time_t *)NULL);
	vnotify ("SUP Fileserver %d.%d (%s) %d on %s at %.8s\n",
		protver,pgmver,scmver,fspid,remotehost(),ctime (&tloc) + 11);
	free (scmver);
d293 4
a296 4
		goaway ("Fileserver sup protocol version is obsolete.");
		notify ("SUP: This version of sup can only communicate with a fileserver using at least\n");
		notify ("SUP: version 4 of the sup network protocol.  You should either run a newer\n");
		notify ("SUP: version of the sup fileserver or find an older version of sup.\n");
d309 3
a311 2
int setup (t)
register TREE *t;
d314 1
a314 1
	register int x;
d317 4
a320 4
	if (chdir (thisC->Cbase) < 0)
		goaway ("Can't change to base directory %s",thisC->Cbase);
	if (stat ("sup",&sbuf) < 0) {
		(void) mkdir ("sup",0755);
d322 2
a323 2
			goaway ("Can't create directory %s/sup",thisC->Cbase);
		vnotify ("SUP Created directory %s/sup\n",thisC->Cbase);
d325 9
a333 8
	if (thisC->Cprefix && chdir (thisC->Cprefix) < 0)
		goaway ("Can't change to %s from base directory %s",
			thisC->Cprefix,thisC->Cbase);
	if (stat (".",&sbuf) < 0)
		goaway ("Can't stat %s directory %s",
			thisC->Cprefix?"prefix":"base",
			thisC->Cprefix?thisC->Cprefix:thisC->Cbase);
	if (thisC->Cprefix)  (void) chdir (thisC->Cbase);
d337 2
a338 2
		(void) snprintf (relsufix,sizeof relsufix,
			".%s",thisC->Crelease);
d341 1
a341 1
	lasttime = getwhen(collname,relsufix);
d349 1
a349 1
	x = msgsetup ();
d352 1
a352 1
	x = msgsetupack ();
d354 1
a354 1
		goaway ("Error reading setup reply from file server");
d357 2
a358 2
		if (netcrypt (thisC->Ccrypt) != SCMOK)
			goaway ("Running non-crypting sup");
d360 1
a360 1
		x = msgcrypt ();
d362 2
a363 2
			goaway ("Error sending encryption test request");
		x = msgcryptok ();
d365 1
a365 1
			goaway ("Data encryption test failed");
d367 1
a367 1
			goaway ("Error reading encryption test reply");
d372 2
a373 2
		notify ("SUP: Attempt to upgrade from same host to same directory\n");
		done (FDONESRVERROR,"Overwrite error");
d375 3
a377 3
		notify ("SUP: This host has no permission to access %s\n",
			collname);
		done (FDONESRVERROR,"Permission denied");
d379 2
a380 2
		notify ("SUP: This version of SUP is too old for the fileserver\n");
		done (FDONESRVERROR,"Obsolete client");
d382 3
a384 3
		notify ("SUP: Invalid release %s for collection %s\n",
			release == NULL ? DEFRELEASE : release,collname);
		done (FDONESRVERROR,"Invalid release");
d386 1
a386 1
		vnotify ("SUP Fileserver is currently busy\n");
d390 2
a391 2
		(void) netcrypt ((char *)NULL);
		(void) msgdone ();
d394 1
a394 1
		goaway ("Unrecognized file server setup status %d",setupack);
d397 1
a397 1
	return FALSE;
d402 2
a403 1
void suplogin (void)
d406 1
a406 1
	register int f,x;
d409 2
a410 2
	(void) snprintf (buf,sizeof buf,FILELOCK,collname);
	f = open (buf,O_RDONLY,0);
d429 1
a429 1
				goaway ("Can't lock collection %s",collname);
d432 4
a435 4
				(void) close (f);
				if (errno == EWOULDBLOCK  && errno != EAGAIN)
					goaway ("Collection %s is locked by another sup",collname);
				goaway ("Can't lock collection %s",collname);
d437 1
a437 1
			vnotify ("SUP Waiting for exclusive access lock\n");
d439 2
a440 2
				(void) close (f);
				goaway ("Can't lock collection %s",collname);
d444 2
a445 1
		vnotify ("SUP Locked collection %s for exclusive access\n",collname);
d447 1
a447 1
	logcrypt = (char *) NULL;
d452 1
a452 1
	if (thisC->Clogin != (char *) NULL) /* othewise we only encrypt if there is a login id */
d456 1
a456 1
		(void) netcrypt (PSWDCRYPT);	/* encrypt password data */
d458 1
a458 1
	x = msglogin ();
d460 1
a460 1
	if (thisC->Clogin != (char *) NULL) 
d462 1
a462 1
		(void) netcrypt ((char *)NULL);	/* turn off encryption */
d464 2
a465 2
		goaway ("Error sending login request to file server");
	x = msglogack ();
d467 1
a467 1
		goaway ("Error reading login reply from file server");
d469 2
a470 2
		notify ("SUP: %s\n",logerror);
		free (logerror);
d472 1
a472 1
		notify ("SUP: Improper login to %s account",
d474 1
a474 1
		done (FDONESRVERROR,"Improper login");
d481 1
a481 1
 *  send list of files that we are not interested in.  receive list of
d487 2
a488 2

void listfiles ()
d492 3
a494 4
	register char *p,*q;
	register FILE *f;
	register int x;

d497 1
a497 1
		(void) snprintf (relsufix,sizeof relsufix,".%s",release);
d500 2
a501 2
	(void) snprintf (buf,sizeof buf,FILELAST,collname,relsufix);
	f = fopen (buf,"r");
d503 6
a508 4
		while ((p = fgets (buf,STRINGLENGTH,f)) != NULL) {
			if (q = strchr (p,'\n'))  *q = '\0';
			if (strchr ("#;:",*p))  continue;
			(void) Tinsert (&lastT,p,FALSE);
d510 1
a510 1
		(void) fclose (f);
d513 2
a514 2
	(void) snprintf (buf,sizeof buf,FILEREFUSE,collname);
	f = fopen (buf,"r");
d516 6
a521 4
		while ((p = fgets (buf,STRINGLENGTH,f)) != NULL) {
			if (q = strchr (p,'\n'))  *q = '\0';
			if (strchr ("#;:",*p))  continue;
			(void) Tinsert (&refuseT,p,FALSE);
d523 1
a523 1
		(void) fclose (f);
d525 2
a526 2
	vnotify ("SUP Requesting changes since %s",ctime (&lasttime) + 4);
	x = msgrefuse ();
d530 1
a530 1
	x = msglist ();
d532 3
a534 2
		goaway ("Error reading file list from file server");
	if (thisC->Cprefix)  (void) chdir (thisC->Cprefix);
d536 3
a538 3
	(void) Tprocess (listT,needone, NULL);
	Tfree (&listT);
	x = msgneed ();
d540 2
a541 2
		goaway ("Error sending needed files list to file server");
	Tfree (&needT);
d543 1
a543 1
	x = msgdeny ();
d545 1
a545 1
		goaway ("Error reading denied files list from file server");
d547 2
a548 2
		(void) Tprocess (denyT,denyone, NULL);
	Tfree (&denyT);
d550 2
a551 2
		(void) Trprocess (lastT,deleteone, NULL);
	Tfree (&refuseT);
d554 4
a557 3
static int needone (t, dummy)
register TREE *t;
void *dummy;
d559 2
a560 2
	register TREE *newt;
	register int exists, fetch;
d570 1
a570 1
			exists = (lstat (t->Tname,&sbuf) == 0);
d572 14
a585 12
			exists = (stat (t->Tname,&sbuf) == 0);
		/* This is moderately complicated:
		   If the file is the wrong type or doesn't exist, we need to
		   fetch the whole file.  If the file is a special file, we
		   rely solely on the server:  if the file changed, we do an
		   update; otherwise nothing. If the file is a normal file,
		   we check timestamps.  If we are in "keep" mode, we fetch if
		   the file on the server is newer, and do nothing otherwise.
		   Otherwise, we fetch if the timestamp is wrong; if the file
		   changed on the server but the timestamp is right, we do an
		   update.  (Update refers to updating stat information, i.e.
		   timestamp, owner, mode bits, etc.) */
d590 2
a591 1
				else return (SCMOK);
d593 1
a593 1
				 sbuf.st_mtime > t->Tmtime) {
d598 2
a599 1
				else return (SCMOK);
d604 1
a604 1
	newt = Tinsert (&needT,t->Tname,TRUE);
d610 4
a613 3
static int denyone (t, v)
register TREE *t;
void *v;
d615 2
a616 1
	vnotify ("SUP: Access denied to %s\n",t->Tname);
d620 4
a623 3
static int deleteone (t, v)
TREE *t;
void *v;
d626 2
a627 2
	register int x;
	register char *name = t->Tname;
d632 1
a632 1
	if (lstat(name,&sbuf) < 0)	/* doesn't exist */
d636 3
a638 3
		if (Tlookup (refuseT,name)) {
			vnotify ("SUP Would not delete symbolic link %s\n",
				name);
d642 1
a642 1
			vnotify ("SUP Would delete symbolic link %s\n",name);
d646 1
a646 1
			notify ("SUP Please delete symbolic link %s\n",name);
d650 1
a650 1
		x = unlink (name);
d652 2
a653 2
			notify ("SUP: Unable to delete symbolic link %s\n",
				name);
d657 1
a657 1
		vnotify ("SUP Deleted symbolic link %s\n",name);
d662 2
a663 2
		if (Tlookup (refuseT,name)) {
			vnotify ("SUP Would not delete directory %s\n",name);
d667 1
a667 1
			vnotify ("SUP Would delete directory %s\n",name);
d671 1
a671 1
			notify ("SUP Please delete directory %s\n",name);
d675 7
a681 6
		if (rmdir (name) < 0) {
			(void) chmod (name,sbuf.st_mode|S_IRWXU);
			if (strlen(name) < MAXPATHLEN - 3) {
				sprintf (pname,"%s/..",name);
				if (stat (pname,&pbuf) == 0)
					(void) chmod (pname,pbuf.st_mode|S_IRWXU);
d683 1
a683 1
			runp ("rm","rm","-rf",name,0);
d685 2
a686 2
		if (lstat(name,&sbuf) == 0) {
			notify ("SUP: Unable to delete directory %s\n",name);
d690 1
a690 1
		vnotify ("SUP Deleted directory %s\n",name);
d694 2
a695 2
	if (Tlookup (refuseT,name)) {
		vnotify ("SUP Would not delete file %s\n",name);
d699 1
a699 1
		vnotify ("SUP Would delete file %s\n",name);
d703 1
a703 1
		notify ("SUP Please delete file %s\n",name);
d707 1
a707 1
	x = unlink (name);
d709 1
a709 1
		notify ("SUP: Unable to delete file %s\n",name);
d713 1
a713 1
	vnotify ("SUP Deleted file %s\n",name);
d721 2
a722 1
/* Note for these routines, return code SCMOK generally means
a728 1

d731 1
a731 1
	register int x;
d740 1
a740 1
			goaway ("Error sending compression check to server");
d747 1
a747 1
		x = msgsend ();
d749 3
a751 3
			goaway ("Error sending receive file request to file server");
		(void) Tinsert (&upgradeT,(char *)NULL,FALSE);
		x = msgrecv (recvone,&recvmore);
d753 2
a754 2
			goaway ("Error receiving file from file server");
		Tfree (&upgradeT);
d759 5
a763 4
int prepare (name,mode,newp,statp)
char *name;
int mode,*newp;
struct stat *statp;
d765 1
a765 1
	register char *type;
d770 1
a770 1
		*newp = (lstat (name,statp) < 0);
d772 1
a772 1
		*newp = (stat (name,statp) < 0);
d776 1
a776 1
		if (establishdir (name))
d798 1
a798 1
		vnotify ("SUP Would remove %s %s\n",type,name);
d803 6
a808 5
			(void) chmod (name,statp->st_mode|S_IRWXU);
			if (strlen(name) < MAXPATHLEN - 3) {
				sprintf(pname,"%s/..",name);
				if (stat(pname,&pbuf) == 0)
					(void) chmod (pname,pbuf.st_mode|S_IRWXU);
d810 1
a810 1
			runp ("rm","rm","-rf",name,0);
d813 3
a815 3
		(void) unlink (name);
	if (stat (name,statp) < 0) {
		vnotify ("SUP Removed %s %s\n",type,name);
d818 1
a818 1
	notify ("SUP: Couldn't remove %s %s\n",type,name);
d823 3
a825 3
recvone (t, ap)
register TREE *t;
va_list ap;
d841 2
a842 2
		notify ("SUP: File server unable to transfer file %s\n",
			t->Tname);
d846 2
a847 2
	if (prepare (t->Tname,t->Tmode&S_IFMT,&new,&sbuf)) {
		notify ("SUP: Can't prepare path for %s\n",t->Tname);
d849 1
a849 1
			x = readskip ();	/* skip over file */
d851 1
a851 1
				goaway ("Can't skip file transfer");
d859 1
a859 1
		x = recvdir (t,new,&sbuf);
d862 1
a862 1
		x = recvsym (t,new,&sbuf);
d865 1
a865 1
		x = recvreg (t,new,&sbuf);
d868 1
a868 1
		goaway ("Unknown file type %o\n",t->Tmode&S_IFMT);
d875 2
a876 2
		(void) Tprocess (t->Tlink,linkone,t->Tname);
	(void) Tprocess (t->Texec,execone, NULL);
d880 5
a884 4
int recvdir (t,new,statp)		/* receive directory from network */
register TREE *t;
register int new;
register struct stat *statp;
d890 1
a890 1
			vnotify ("SUP Would create directory %s\n",t->Tname);
d894 1
a894 1
			vnotify ("SUP: Can't create directory %s\n", t->Tname);
d900 1
a900 1
		ugconvert (t->Tuser,t->Tgroup,&t->Tuid,&t->Tgid,&t->Tmode);
d909 1
a909 1
		vnotify ("SUP Would update directory %s\n",t->Tname);
d913 2
a914 2
		(void) chown (t->Tname,t->Tuid,t->Tgid);
		(void) chmod (t->Tname,t->Tmode&S_IMODE);
d916 4
a919 2
	tbuf[0].tv_sec = time((time_t *)NULL);  tbuf[0].tv_usec = 0;
	tbuf[1].tv_sec = t->Tmtime;  tbuf[1].tv_usec = 0;
d921 2
a922 2
		(void) utimes (t->Tname,tbuf);
	vnotify ("SUP %s directory %s\n",new?"Created":"Updated",t->Tname);
d926 5
a930 4
int recvsym (t,new,statp)			/* receive symbolic link */
register TREE *t;
register int new;
register struct stat *statp;
d934 1
a934 1
	register char *linkname;
d937 1
a937 1
		notify ("SUP: Missing linkname for symbolic link %s\n",
d944 2
a945 2
	    (n = readlink (t->Tname,buf,sizeof(buf)-1)) >= 0 &&
	    (n == strlen (linkname)) && (strncmp (linkname,buf,n) == 0))
d948 2
a949 2
		vnotify ("SUP Would %s symbolic link %s to %s\n",
			new?"create":"update",t->Tname,linkname);
d953 3
a955 3
		(void) unlink (t->Tname);
	if (symlink (linkname,t->Tname) < 0 || lstat(t->Tname,statp) < 0) {
		notify ("SUP: Unable to create symbolic link %s\n",t->Tname);
d958 1
a958 1
	vnotify ("SUP Created symbolic link %s to %s\n",t->Tname,linkname);
d962 9
a970 8
int recvreg (t,new,statp)			/* receive file from network */
register TREE *t;
register int new;
register struct stat *statp;
{
	register FILE *fin,*fout;
	char dirpart[STRINGLENGTH],filepart[STRINGLENGTH];
	char filename[STRINGLENGTH],buf[STRINGLENGTH];
d972 2
a973 2
	register int x;
	register char *p;
d978 2
a979 2
			ugconvert (t->Tuser,t->Tgroup,&t->Tuid,&t->Tgid,
				&t->Tmode);
d990 1
a990 1
			vnotify ("SUP Would update file %s\n",t->Tname);
d993 1
a993 1
		vnotify ("SUP Updating file %s\n",t->Tname);
d995 2
a996 2
			(void) chown (t->Tname,t->Tuid,t->Tgid);
			(void) chmod (t->Tname,t->Tmode&S_IMODE);
d998 4
a1001 2
		tbuf[0].tv_sec = time((time_t *)NULL);  tbuf[0].tv_usec = 0;
		tbuf[1].tv_sec = t->Tmtime;  tbuf[1].tv_usec = 0;
d1003 1
a1003 1
			(void) utimes (t->Tname,tbuf);
d1015 1
a1015 1
		vnotify ("SUP Would %s file %s\n",p,t->Tname);
d1018 1
a1018 1
	vnotify ("SUP Receiving file %s\n",t->Tname);
d1021 1
a1021 1
		fin = fopen (t->Tname,"r");	/* create backup */
d1023 1
a1023 1
			x = readskip ();	/* skip over file */
d1025 3
a1027 3
				goaway ("Can't skip file transfer");
			notify ("SUP: Can't open %s to create backup\n",
				t->Tname);
d1030 4
a1033 4
		path (t->Tname,dirpart,filepart,sizeof filepart);
		(void) snprintf (filename,sizeof filename,
			FILEBACKUP,dirpart,filepart);
		fout = fopen (filename,"w");
d1035 3
a1037 3
			(void) snprintf (buf,sizeof buf,FILEBKDIR,dirpart);
			(void) mkdir (buf,0755);
			fout = fopen (filename,"w");
d1040 1
a1040 1
			x = readskip ();	/* skip over file */
d1042 3
a1044 3
				goaway ("Can't skip file transfer");
			notify ("SUP: Can't create %s for backup\n",filename);
			(void) fclose (fin);
d1047 4
a1050 4
		ffilecopy (fin,fout);
		(void) fclose (fin);
		(void) fclose (fout);
		vnotify ("SUP Backup of %s created\n", t->Tname);
d1052 1
a1052 1
	x = copyfile (t->Tname,(char *)NULL);
d1057 8
a1064 6
		ugconvert (t->Tuser,t->Tgroup,&t->Tuid,&t->Tgid,&t->Tmode);
		(void) chown (t->Tname,t->Tuid,t->Tgid);
		(void) chmod (t->Tname,t->Tmode&S_IMODE);
	}
	tbuf[0].tv_sec = time((time_t *)NULL);  tbuf[0].tv_usec = 0;
	tbuf[1].tv_sec = t->Tmtime;  tbuf[1].tv_usec = 0;
d1066 1
a1066 1
		(void) utimes (t->Tname,tbuf);
d1070 4
a1073 3
static int linkone (t,fv)			/* link to file already received */
register TREE *t;
void *fv;
d1075 1
a1075 1
	register char *fname = fv;
d1077 1
a1077 1
	register char *name = t->Tname;
d1081 1
a1081 1
	if (stat(fname,&fbuf) < 0) {	/* source file */
d1083 1
a1083 1
			vnotify ("SUP Would link %s to %s\n",name,fname);
d1086 1
a1086 1
		notify ("SUP: Can't link %s to missing file %s\n",name,fname);
d1090 2
a1091 2
	if (prepare (name,S_IFREG,&new,&sbuf)) {
		notify ("SUP: Can't prepare path for link %s\n",name);
d1099 1
a1099 1
		vnotify ("SUP Would link %s to %s\n",name,fname);
d1102 1
a1102 1
	(void) unlink (name);
d1104 1
a1104 1
	if ((x = link (fname,name)) < 0) {
d1106 1
a1106 1
		x = symlink (fname,name);
d1108 2
a1109 2
	if (x < 0 || lstat(name,&sbuf) < 0) {
		notify ("SUP: Unable to create %slink %s\n",type,name);
d1112 1
a1112 1
	vnotify ("SUP Created %slink %s to %s\n",type,name,fname);
d1116 4
a1119 3
static int execone (t, v)			/* execute command for file */
register TREE *t;
void *v;
d1124 1
a1124 1
		vnotify ("SUP Would execute %s\n",t->Tname);
d1128 1
a1128 1
		notify ("SUP Please execute %s\n",t->Tname);
d1131 1
a1131 1
	vnotify ("SUP Executing %s\n",t->Tname);
d1133 1
a1133 1
	w = system (t->Tname);
d1135 2
a1136 2
		notify ("SUP: Execute command returned failure status %#o\n",
			WEXITSTATUS(w));
d1139 2
a1140 2
		notify ("SUP: Execute command killed by signal %d\n",
			WTERMSIG(w));
d1143 2
a1144 2
		notify ("SUP: Execute command stopped by signal %d\n",
			WSTOPSIG(w));
d1150 4
a1153 3
int copyfile (to,from)
char *to;
char *from;		/* 0 if reading from network */
d1155 2
a1156 2
	register int fromf,tof,istemp,x;
	char dpart[STRINGLENGTH],fpart[STRINGLENGTH];
a1158 1

d1162 1
a1162 1
		fromf = open (from,O_RDONLY,0);
d1164 2
a1165 2
			notify ("SUP: Can't open %s to copy to %s: %s\n",
				from,to,errmsg (-1));
d1171 3
a1173 2
	lockout (TRUE);			/* block interrupts */
	if (thispid == 0)  thispid = getpid ();
d1177 6
a1182 5
		path (to,dpart,fpart,sizeof fpart);
		(void) snprintf (tname,sizeof tname,
			"%s/#%d.sup",dpart,thispid);
		tof = open (tname,(O_WRONLY|O_CREAT|O_TRUNC),0600);
		if (tof >= 0)  break;
d1184 4
a1187 4
		if (thisC->Cprefix)  (void) chdir (thisC->Cbase);
		(void) snprintf (tname,sizeof tname,
			"sup/#%d.sup",thispid);
		tof = open (tname,(O_WRONLY|O_CREAT|O_TRUNC),0600);
d1189 2
a1190 1
			if (thisC->Cprefix)  (void) chdir (thisC->Cprefix);
d1194 1
a1194 2
		(void) snprintf (tname,sizeof tname,
			"#%d.sup",thispid);
d1196 4
a1199 2
		if (thisC->Cprefix)  (void) chdir (thisC->Cprefix);
		if (tof >= 0)  break;
d1202 5
a1206 4
		(void) snprintf (tname,sizeof tname,
			"/var/tmp/#%d.sup",thispid);
		tof = open (tname,(O_WRONLY|O_CREAT|O_TRUNC),0600);
		if (tof >= 0)  break;
d1209 5
a1213 4
		(void) snprintf (tname,sizeof tname,
			"/usr/tmp/#%d.sup",thispid);
		tof = open (tname,(O_WRONLY|O_CREAT|O_TRUNC),0600);
		if (tof >= 0)  break;
d1216 5
a1220 4
		(void) snprintf (tname,sizeof tname,
			"/tmp/#%d.sup",thispid);
		tof = open (tname,(O_WRONLY|O_CREAT|O_TRUNC),0600);
		if (tof >= 0)  break;
d1224 3
a1226 2
			tof = open (to,(O_WRONLY|O_CREAT|O_TRUNC),0600);
		if (tof >= 0)  break;
d1228 1
a1228 1
		notify ("SUP: Can't create %s or temp file for it\n",to);
d1233 1
a1233 1
			x = readskip ();
d1235 1
a1235 1
				goaway ("Can't skip file transfer");
d1241 3
a1243 3
		x = filecopy (fromf,tof);
		(void) close (fromf);
		(void) close (tof);
d1245 4
a1248 3
			notify ("SUP: Error in copying %s to %s\n",from,to);
			if (istemp)  (void) unlink (tname);
			lockout (FALSE);
d1257 1
a1257 1
			x = prereadcount (&fsize);
d1259 4
a1262 3
				if (istemp)  (void) unlink (tname);
				lockout (FALSE);
				x = readskip ();
d1264 3
a1266 3
					goaway ("Can't skip file transfer");
				goaway ("Error in server space check");
				logquit (1,"Error in server space check");
d1269 1
a1269 1
			if (ioctl (tof,FIOCFSPARAM,(char *)&fsp) < 0 &&
d1271 4
a1274 3
				if (istemp)  (void) unlink (tname);
				lockout (FALSE);
				x = readskip ();
d1276 3
a1278 3
					goaway ("Can't skip file transfer");
				goaway ("Error in disk space check");
				logquit (1,"Error in disk space check");
d1282 1
a1282 1
				x = fsp.fsp_size * MAX (fsp.fsp_minfree,1) / 100;
d1284 5
a1288 4
				if (fsize > MAX (fsp.fsp_free,0)) {
					if (istemp)  (void) unlink (tname);
					lockout (FALSE);
					x = readskip ();
d1290 4
a1293 3
						goaway ("Can't skip file transfer");
					goaway ("No disk space for file %s", to);
					logquit (1,"No disk space for file %s",to);
d1298 2
a1299 2
		x = readfile (tof);
		(void) close (tof);
d1301 4
a1304 3
			if (istemp)  (void) unlink (tname);
			lockout (FALSE);
			goaway ("Error in receiving %s\n",to);
d1308 1
a1308 1
		lockout (FALSE);
d1312 11
a1322 11
	** If the file is compressed, uncompress it in place.  We open the
	** temp file for reading, unlink the file, and then open the same
	** file again for writing.  Then we pipe through gzip.  When 
	** finished the temp file contains the uncompressed version and we
	** can continue as before.
	**
	** Since sup prefers to write close to the original file the
	** benefits of atomic updates probably outweigh the cost of the
	** extra filecopy which occurs when the temp file is on a different
	** filesystem from the original.
	*/
d1331 1
a1331 1
		if ( (infd = open(tname, O_RDONLY)) == -1 ||
d1333 2
a1334 2
		     (outfd = open(tname, O_WRONLY|O_CREAT|O_TRUNC)) == -1 ||
		     runiofd( av, infd, outfd, 2 ) != 0 ) {
d1336 6
a1341 4
				to, tname );
			(void) unlink (tname);
			if ( infd != -1 ) (void) close (infd);
			if ( outfd != -1 ) (void) close (outfd);
d1349 4
a1352 4
	if (rename (tname,to) == 0) {
		(void) unlink (tname);
		lockout (FALSE);
		return (FALSE);
d1354 1
a1354 1
	fromf = open (tname,O_RDONLY,0);
d1357 3
a1359 3
			to,errmsg (-1));
		(void) unlink (tname);
		lockout (FALSE);
d1362 1
a1362 1
	tof = open (to,(O_WRONLY|O_CREAT|O_TRUNC),0600);
d1364 5
a1368 5
		(void) close (fromf);
		notify ("SUP: Can't create %s from temp file: %s\n",
			to,errmsg (-1));
		(void) unlink (tname);
		lockout (FALSE);
d1371 5
a1375 5
	x = filecopy (fromf,tof);
	(void) close (fromf);
	(void) close (tof);
	(void) unlink (tname);
	lockout (FALSE);
d1377 1
a1377 1
		notify ("SUP: Error in storing data in %s\n",to);
d1385 3
a1387 2
void finishup (x)
int x;
d1389 1
a1389 1
	char tname[STRINGLENGTH],fname[STRINGLENGTH];
d1396 3
a1398 4
		(void) snprintf (relsufix,sizeof relsufix,
			".%s",release);
		(void) snprintf (collrelname,sizeof collrelname,
			"%s-%s",collname,release);
d1401 1
a1401 2
		(void) strncpy (collrelname,collname,sizeof collrelname-1);
		collrelname[sizeof collrelname-1] = '\0';
d1404 1
a1404 1
	(void) netcrypt ((char *)NULL);
d1408 2
a1409 2
			goaway ((char *)NULL);
		(void) requestend ();
d1411 1
a1411 1
	tloc = time ((time_t *)NULL);
d1413 5
a1417 4
		notify ("SUP: Upgrade of %s aborted at %s",
			collrelname,ctime (&tloc) + 4);
		Tfree (&lastT);
		if (protver < 6)  return;
d1420 2
a1421 2
			goaway ("Aborted");
		(void) requestend ();
d1425 8
a1432 7
		notify ("SUP: Upgrade of %s completed with errors at %s",
			collrelname,ctime (&tloc) + 4);
		notify ("SUP: Upgrade time will not be updated\n");
		Tfree (&lastT);
		if (protver < 6)  return;
		done (FDONEUSRERROR,"Completed with errors");
		(void) requestend ();
d1435 4
a1438 3
	if (thisC->Cprefix)  (void) chdir (thisC->Cbase);
	vnotify ("SUP Upgrade of %s completed at %s",
		 collrelname,ctime (&tloc) + 4);
d1440 5
a1444 4
		Tfree (&lastT);
		if (protver < 6)  return;
		done (FDONEDONTLOG,"List only");
		(void) requestend ();
d1447 8
a1454 7
	(void) snprintf (fname,sizeof fname,FILEWHEN,collname,relsufix);
	if (establishdir (fname)) {
		notify ("SUP: Can't create directory for upgrade timestamp\n");
		Tfree (&lastT);
		if (protver < 6)  return;
		done (FDONEUSRERROR,"Couldn't timestamp");
		(void) requestend ();
d1458 7
a1464 6
		notify ("SUP: Can't record current time in %s: %s\n",
			fname,errmsg (-1));
		Tfree (&lastT);
		if (protver < 6)  return;
		done (FDONEUSRERROR,"Couldn't timestamp");
		(void) requestend ();
d1468 6
a1473 4
		/* At this point we have let the server go */
		/* "I'm sorry, we've had to let you go" */
		done (FDONESUCCESS,"Success");
		(void) requestend ();
d1475 2
a1476 2
	(void) snprintf (tname,sizeof tname,FILELASTTEMP,collname,relsufix);
	finishfile = fopen (tname,"w");
d1478 2
a1479 2
		notify ("SUP: Can't record list of all files in %s\n",tname);
		Tfree (&lastT);
d1482 7
a1488 7
	(void) Tprocess (lastT,finishone,finishfile);
	(void) fclose (finishfile);
	(void) snprintf (fname,sizeof fname,FILELAST,collname,relsufix);
	if (rename (tname,fname) < 0)
		notify ("SUP: Can't change %s to %s\n",tname,fname);
	(void) unlink (tname);
	Tfree (&lastT);
d1491 4
a1494 3
int finishone (t,fv)
TREE *t;
void *fv;
d1497 1
d1499 1
a1499 1
		fprintf (finishfile,"%s\n",t->Tname);
d1516 1
a1516 1
	va_start(ap,fmt);
d1522 2
a1523 2
	value = va_arg(ap,int);
	fmt = va_arg(ap,char *);
d1525 1
a1525 1
	(void) netcrypt ((char *)NULL);
d1532 3
a1534 3
			free (goawayreason);
		goawayreason = (fmt) ? salloc (buf) : (char *)NULL;
		(void) msggoaway ();
d1538 2
a1539 2
		donereason = (fmt) ? buf : (char *)NULL;
		(void) msgdone ();
d1542 1
a1542 1
		longjmp (sjbuf,TRUE);
d1558 1
a1558 1
	va_start(ap,fmt);
d1560 1
a1560 1
	register char *fmt;
d1563 1
a1563 1
	fmt = va_arg(ap,char *);
d1566 1
a1566 1
	(void) netcrypt ((char *)NULL);
d1573 1
a1573 1
	(void) msggoaway ();
d1576 1
a1576 1
			notify ("SUP: %s\n",buf);
d1578 1
a1578 1
			printf ("SUP: %s\n",buf);
d1581 1
a1581 1
		longjmp (sjbuf,TRUE);
@


1.12
log
@Zero a buffer prior to passing it to readlink() as readlink()
does not append a NUL itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.11 2001/04/29 21:52:16 millert Exp $	*/
d118 1
d130 1
d228 1
a228 1
		login ();
d395 1
a395 1
void login (void)
d604 1
a604 1
	struct stat sbuf;
d607 1
d654 9
a662 1
		(void) rmdir (name);
d743 2
d779 7
a785 1
		if (rmdir (name) < 0)
d787 1
d868 3
a870 4
		(void) mkdir (t->Tname,0755);
		if (stat (t->Tname,statp) < 0) {
			notify ("SUP: Can't create directory %s\n",t->Tname);
			return (TRUE);
d893 2
a894 1
	(void) utimes (t->Tname,tbuf);
d971 2
a972 1
		(void) utimes (t->Tname,tbuf);
d1032 2
a1033 1
	(void) utimes (t->Tname,tbuf);
d1262 12
a1273 1
	/* uncompress it first */
d1277 2
d1282 6
a1287 4
		if (runio(av, tname, to, NULL) != 0) {
			/* Uncompress it onto the destination */
			notify ("SUP: Error in uncompressing file %s\n",
				to);
d1289 4
a1292 4
			/* Just in case */
			(void) unlink (to);
			lockout (FALSE);
			return (TRUE);
d1294 2
a1295 3
		(void) unlink (tname);
		lockout (FALSE);
		return (FALSE);
d1514 1
a1514 1
	if (fmt)
d1519 1
@


1.11
log
@Add a bunch of old revision history comments that we are missing to
make diffing easier.  No code changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.10 2001/04/29 18:16:19 millert Exp $	*/
d894 1
@


1.10
log
@Use S_ISXXX macros where possible instead of doing this by hand
Noticed while diffing against NetBSD version
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.9 1998/05/18 19:13:37 deraadt Exp $	*/
d19 1
a19 1
 *  Software Distribution Coordinator  or  Software_Distribution@@CS.CMU.EDU
d36 53
@


1.9
log
@readlink len-1
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.8 1997/09/16 11:01:20 deraadt Exp $	*/
d500 1
a500 1
		if ((t->Tmode&S_IFMT) == S_IFLNK)
d515 2
a516 2
		if (exists && (sbuf.st_mode&S_IFMT) == (t->Tmode&S_IFMT))
			if ((t->Tmode&S_IFMT) != S_IFREG)
d520 2
a521 2
			else if ((thisC->Cflags&CFKEEP) &&
				 sbuf.st_mtime > t->Tmtime)
d523 1
a523 1
			else if (sbuf.st_mtime == t->Tmtime)
d527 2
d532 1
a532 1
	if (!fetch && (t->Tmode&S_IFMT) == S_IFREG)
d558 1
a558 1
	if ((sbuf.st_mode & S_IFMT) == S_IFLNK) {
d584 1
a584 1
	if ((sbuf.st_mode & S_IFMT) == S_IFDIR) {
d712 1
a712 1
	if ((statp->st_mode&S_IFMT) == S_IFDIR) {
d751 1
a751 1
		if ((t->Tmode&S_IFMT) == S_IFREG) {
d777 1
a777 1
	if ((t->Tmode&S_IFMT) == S_IFREG)
d913 1
a913 1
	if (!new && (t->Tmode&S_IFMT) == S_IFREG &&
@


1.8
log
@strcpy whacking; ci.c and expand.c need more work
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.7 1997/09/16 10:42:54 deraadt Exp $	*/
d840 1
a840 1
	    (n = readlink (t->Tname,buf,sizeof(buf))) >= 0 &&
@


1.7
log
@snprintf this thing
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.6 1997/07/28 09:47:38 deraadt Exp $	*/
d922 1
a922 1
		path (t->Tname,dirpart,filepart);
d1063 1
a1063 1
		path (to,dpart,fpart);
d1258 2
a1259 1
		(void) strcpy (collrelname,collname);
@


1.6
log
@uniqify names more; s.k.stevens@@ic.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.5 1997/04/01 07:35:33 todd Exp $	*/
d275 2
a276 1
		(void) sprintf (relsufix,".%s",thisC->Crelease);
d346 1
a346 1
	(void) sprintf (buf,FILELOCK,collname);
d434 1
a434 1
		(void) sprintf (relsufix,".%s",release);
d437 1
a437 1
	(void) sprintf (buf,FILELAST,collname,relsufix);
d448 1
a448 1
	(void) sprintf (buf,FILEREFUSE,collname);
d923 2
a924 1
		(void) sprintf (filename,FILEBACKUP,dirpart,filepart);
d927 1
a927 1
			(void) sprintf (buf,FILEBKDIR,dirpart);
d1064 2
a1065 1
		(void) sprintf (tname,"%s/#%d.sup",dpart,thispid);
d1070 2
a1071 1
		(void) sprintf (tname,"sup/#%d.sup",thispid);
d1078 2
a1079 1
		(void) sprintf (tname,"#%d.sup",thispid);
d1085 2
a1086 1
		(void) sprintf (tname,"/var/tmp/#%d.sup",thispid);
d1091 2
a1092 1
		(void) sprintf (tname,"/usr/tmp/#%d.sup",thispid);
d1097 2
a1098 1
		(void) sprintf (tname,"/tmp/#%d.sup",thispid);
d1252 4
a1255 2
		(void) sprintf (relsufix,".%s",release);
		(void) sprintf (collrelname,"%s-%s",collname,release);
d1300 1
a1300 1
	(void) sprintf (fname,FILEWHEN,collname,relsufix);
d1324 1
a1324 1
	(void) sprintf (tname,FILELASTTEMP,collname,relsufix);
d1333 1
a1333 1
	(void) sprintf (fname,FILELAST,collname,relsufix);
@


1.5
log
@This merges in the latest NetBSD sup source.
- removed $Log: ...$ tags to not waste space in the repository
- now doesn't segfault on the alpha!

Note:
To compile sup on systems other than *BSD, you'll need a copy of
vis.c, vis.h, daemon.c, and sys/cdefs.h.  At least the first two
(for OSF/1).

From NetBSD changelog description (for credit where due):
.... 1996/12/23 19:42:05  christos
- add missing prototypes.
- fix function call inconsistencies
- fix int <-> long and pointer conversions
It should run now on 64 bit machines...

....  1996/12/31 18:08:00  christos
64 bit patches (mostly long -> time_t) from Matthew Jacob (?)
sup now works on the alpha!
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.4 1997/01/17 07:18:07 millert Exp $	*/
d1314 1
a1314 1
	(void) sprintf (tname,FILELASTTEMP,collname);
@


1.4
log
@more r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.3 1996/07/31 11:11:28 niklas Exp $	*/
a35 87
 * $Log: supcmeat.c,v $
 * Revision 1.3  1996/07/31 11:11:28  niklas
 * Better use time_t instead of long when dealing with times
 *
 * Revision 1.2  1996/06/26 05:39:51  deraadt
 * rcsid
 *
 * Revision 1.1  1995/12/16 11:46:56  deraadt
 * add sup to the tree
 *
 * Revision 1.6  1995/10/29 23:54:47  christos
 * - runio fails when result != 0 not only < 0
 * - print vis-encoded file in the scanner.
 *
 * Revision 1.5  1995/06/24 16:21:48  christos
 * - Don't use system(3) to fork processes. It is a big security hole.
 * - Encode the filenames in the scan files using strvis(3), so filenames
 *   that contain newlines or other weird characters don't break the scanner.
 *
 * Revision 1.4  1995/06/03 21:21:56  christos
 * Changes to write ascii timestamps in the when files.
 * Looked into making it 64 bit clean, but it is hopeless.
 * Added little program to convert from the old timestamp files
 * into the new ones.
 *
 * Revision 1.3  1993/08/04 17:46:18  brezak
 * Changes from nate for gzip'ed sup
 *
 * Revision 1.2  1993/05/24  18:57:50  brezak
 * Use /var/tmp for NetBSD
 *
 * Revision 1.1.1.1  1993/05/21  14:52:18  cgd
 * initial import of CMU's SUP to NetBSD
 *
 * Revision 1.16  92/09/09  22:04:51  mrt
 * 	Really added bww's recvone changes this time. 
 * 	Added code to support non-crypting version of sup.
 * 	[92/09/01            mrt]
 * 
 * Revision 1.15  92/08/11  12:07:09  mrt
 * 	Added support to add release to FILEWHEN name.
 * 	Updated variable arguemnt list usage - bww
 * 	Updated recvone() to take a va_list - bww
 * 	Changed conditional for rpausing code from CMUCS to MACH
 * 	[92/07/24            mrt]
 * 
 * Revision 1.14  92/02/08  18:24:12  mja
 * 	Only apply "keep" mode when local file is strictly newer
 * 	otherwise allow update as before if necessary.
 * 	[92/02/08  18:09:00  mja]
 * 
 * 	Added support for -k (keep) option to needone().  Rewrote and
 * 	commented other parts of needone().
 * 	[92/01/17            vdelvecc]
 * 
 * Revision 1.13  91/05/16  14:49:41  ern
 * 	Add timestap to fileserver.
 * 	Drop day of the week from 5 messages.
 * 	[91/05/16  14:47:53  ern]
 * 
 * Revision 1.12  89/08/23  14:55:44  gm0w
 * 	Changed msgf routines to msg routines.
 * 	[89/08/23            gm0w]
 * 
 * Revision 1.11  89/08/03  19:49:10  mja
 * 	Updated to use v*printf() in place of _doprnt().
 * 	[89/04/19            mja]
 * 
 * Revision 1.10  89/06/18  14:41:27  gm0w
 * 	Fixed up some notify messages of errors to use "SUP:" prefix.
 * 	[89/06/18            gm0w]
 * 
 * Revision 1.9  89/06/10  15:12:17  gm0w
 * 	Changed to always use rename to install targets.  This breaks hard
 * 	links and recreates those known to sup, other links will be orphaned.
 * 	[89/06/10            gm0w]
 * 
 * Revision 1.8  89/05/24  15:04:23  gm0w
 * 	Added code to check for EINVAL from FSPARAM ioctl for disk
 * 	space check failures when the ioctl is not implemented.
 * 	[89/05/24            gm0w]
 * 
 * Revision 1.7  89/01/16  18:22:28  gm0w
 * 	Changed needone() to check that mode of files match before
 * 	setting update if times also match.
 * 	[89/01/16            gm0w]
 * 
d64 1
a65 5
#if __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif
a76 5
#if __STDC__
int done(int,char *,...);
int goaway(char *,...);
#endif

d81 9
d93 1
a93 1
getonehost (t,state)
d95 1
a95 1
int *state;
d97 1
d113 2
a114 1
int *tout,*backoff,*state,*nhostsp;
d116 1
a116 1
	static int laststate = 0;
d124 1
a124 1
	if (Tprocess (thisC->Chtree,getonehost,*state) == SCMEOF) {
d143 1
a143 1
getcoll ()
d147 2
a148 1
	int tout,backoff,state,nhosts;
d249 1
a249 1
setup (t)
d253 1
a253 1
	register int f,x;
d334 1
d339 1
a339 1
int login ()
d348 17
a364 2
		if (flock (f,(LOCK_EX|LOCK_NB)) < 0) {
			if (errno != EWOULDBLOCK)
d366 2
a367 1
			if (flock (f,(LOCK_SH|LOCK_NB)) < 0) {
d369 1
a369 1
				if (errno == EWOULDBLOCK)
d374 1
a374 1
			if (flock (f,LOCK_EX) < 0) {
d423 1
a423 1
int listfiles ()
a424 1
	int needone(), denyone(), deleteone();
d439 1
a439 1
		while (p = fgets (buf,STRINGLENGTH,f)) {
d450 1
a450 1
		while (p = fgets (buf,STRINGLENGTH,f)) {
d467 1
a467 1
	(void) Tprocess (listT,needone);
d478 1
a478 1
		(void) Tprocess (denyT,denyone);
d481 1
a481 1
		(void) Trprocess (lastT,deleteone);
d485 1
a485 1
needone (t)
d487 1
d534 1
a534 1
denyone (t)
d536 1
d542 1
a542 1
deleteone (t)
d544 1
d640 1
a640 1
recvfiles ()
a642 1
	int recvone ();
d670 1
a670 1
prepare (name,mode,newp,statp)
d722 2
a723 1
recvone (t,ap)
d727 1
a727 1
	register int x;
d730 1
a730 2
	int linkone (),execone ();
	int *recvmore = va_arg(ap,int *);
d732 2
d776 1
a776 1
	(void) Tprocess (t->Texec,execone);
d957 1
a957 1
linkone (t,fname)			/* link to file already received */
d959 1
a959 1
register char **fname;
d961 1
d967 1
a967 1
	if (stat(*fname,&fbuf) < 0) {	/* source file */
d969 1
a969 1
			vnotify ("SUP Would link %s to %s\n",name,*fname);
d972 1
a972 1
		notify ("SUP: Can't link %s to missing file %s\n",name,*fname);
d985 1
a985 1
		vnotify ("SUP Would link %s to %s\n",name,*fname);
d990 1
a990 1
	if ((x = link (*fname,name)) < 0) {
d992 1
a992 1
		x = symlink (*fname,name);
d998 1
a998 1
	vnotify ("SUP Created %slink %s to %s\n",type,name,*fname);
d1002 1
a1002 1
execone (t)			/* execute command for file */
d1004 1
d1006 1
a1006 1
	union wait w;
d1018 2
a1019 2
	w.w_status = system (t->Tname);
	if (WIFEXITED(w) && w.w_retcode != 0) {
d1021 1
a1021 1
			w.w_retcode);
d1025 1
a1025 1
			w.w_termsig);
d1029 1
a1029 1
			w.w_stopsig);
d1042 1
a1042 1
	struct stat sbuf;
d1108 2
a1109 1
		return (TRUE);
d1234 1
a1234 1
finishup (x)
a1241 1
	int f,finishone();
d1330 1
a1330 1
finishone (t,finishfile)
d1332 1
a1332 1
FILE **finishfile;
d1334 1
d1336 1
a1336 1
		fprintf (*finishfile,"%s\n",t->Tname);
d1340 2
a1341 1
#if __STDC__
a1348 4
#if !__STDC__
	int value;
	char *fmt;
#endif
d1352 1
a1352 2
	(void) netcrypt ((char *)NULL);
#if __STDC__
d1355 3
d1362 2
d1381 3
a1383 1
#if __STDC__
a1390 3
#if !__STDC__
	register char *fmt;
#endif
d1394 1
a1394 2
	(void) netcrypt ((char *)NULL);
#if __STDC__
d1397 2
d1402 2
@


1.3
log
@Better use time_t instead of long when dealing with times
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmeat.c,v 1.2 1996/06/26 05:39:51 deraadt Exp $	*/
d37 3
d508 2
a509 2
			if (q = index (p,'\n'))  *q = '\0';
			if (index ("#;:",*p))  continue;
d519 2
a520 2
			if (q = index (p,'\n'))  *q = '\0';
			if (index ("#;:",*p))  continue;
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 3
d276 1
a276 1
	long tloc;
d307 1
a307 1
	tloc = time ((long *)NULL);
d877 1
a877 1
	tbuf[0].tv_sec = time((long *)NULL);  tbuf[0].tv_usec = 0;
d953 1
a953 1
		tbuf[0].tv_sec = time((long *)NULL);  tbuf[0].tv_usec = 0;
d1012 1
a1012 1
	tbuf[0].tv_sec = time((long *)NULL);  tbuf[0].tv_usec = 0;
d1298 1
a1298 1
	long tloc;
d1317 1
a1317 1
	tloc = time ((long *)NULL);
@


1.1
log
@add sup to the tree
@
text
@d1 2
d37 3
@
