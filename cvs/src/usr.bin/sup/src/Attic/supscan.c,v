head	1.16;
access;
symbols
	OPENBSD_4_8:1.15.0.12
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.8
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.8
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.6
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.16
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.14
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.12
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.10
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.8
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.16
	OPENBSD_2_8:1.8.0.14
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.12
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.16
date	2010.10.18.20.54.00;	author deraadt;	state dead;
branches;
next	1.15;

1.15
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.23.17.29.22;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.19.19.39.39;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.04.22.16.17;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.02.22.56.54;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.29.21.52.17;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.09.16.11.01.24;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.09.16.10.43.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.21.05.43;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.04.01.07.35.49;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.18.11;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.07.31.11.11.35;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.39.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.16.11.47.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@sup is no longer used. reminded by pirofti and jmc
@
text
@/*	$OpenBSD: supscan.c,v 1.15 2007/09/11 15:47:17 gilles Exp $	*/

/*
 * Copyright (c) 1992 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 * supscan -- SUP Scan File Builder
 *
 * Usage: supscan [ -v ] collection [ basedir ]
 *	  supscan [ -v ] -f dirfile
 *	  supscan [ -v ] -s
 *	-f	"file" -- use dirfile instead of system coll.dir
 *	-s	"system" -- perform scan for system supfile
 *	-v	"verbose" -- print messages as you go
 *	collection	-- name of the desired collection if not -s
 *	basedir		-- name of the base directory, if not
 *			   the default or recorded in coll.dir
 *	dirfile		-- name of replacement for system coll.dir.
 *
 **********************************************************************
 * HISTORY
 * Revision 1.14  92/08/11  12:08:30  mrt
 * 	Picked up Brad's deliniting and variable argument changes
 * 	[92/08/10            mrt]
 * 
 * Revision 1.13  92/02/08  18:04:44  dlc
 * 	Once again revised localhost().  Do not use gethostbyname() at
 * 	all, but assume that the host names in the coll.host file are at
 * 	least a prefix of the fully qualified name.  Modcoll (and related
 * 	scripts) will maintain this fact.
 * 	[92/02/08            dlc]
 * 
 * Revision 1.12  91/08/17  23:35:31  dlc
 * 	Changes to localhost() function:
 * 		- Use host name in kernel for local host name; assume it is
 * 		  fully qualified.
 * 		- If gethostbyname() of host to see if we are the repository
 * 		  fails, with TRY_AGAIN or NO_RECOVERY, then use the "host"
 * 		  parameter.  Print a diagnostic in this case.
 * 	[91/08/17            dlc]
 * 
 * Revision 1.11  90/04/04  10:53:01  dlc
 * 	Changed localhost to retry getting the local host name 4 times with
 * 	30 second sleep intervals before aborting; after 4 tries, things are
 * 	probably too messed up for the supscan to do anything useful
 * 	[90/04/04            dlc]
 * 
 * Revision 1.10  89/08/03  19:49:33  mja
 * 	Updated to use v*printf() in place of _doprnt().
 * 	[89/04/19            mja]
 * 
 * Revision 1.9  89/06/18  14:41:37  gm0w
 * 	Fixed up some notify messages of errors to use "SUP:" prefix.
 * 	[89/06/18            gm0w]
 * 
 * 13-May-88  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Changed goaway to longjmp back to top-level to scan next
 *	collection. [V7.6]
 *
 * 19-Feb-88  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added -f <filename> switch to scan all (or part) of the
 *	collections in a file of collection/base-directory pairs.
 *	[V7.5]
 *
 * 27-Dec-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Removed nameserver support (which means to use a new
 *	datafile).
 *
 * 09-Sep-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Use case-insensitive hostname comparison.
 *
 * 28-Jun-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code for "release" support. [V6.4]
 *
 * 05-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Changed collection setup errors to be non-fatal. [V5.3]
 *
 * 29-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Moved most of the scanning code to scan.c. [V4.2]
 *
 * 02-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added "-s" option.
 *
 * 22-Sep-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Merged 4.1 and 4.2 versions together.
 *
 * 04-Jun-85  Steven Shafer (sas) at Carnegie-Mellon University
 *	Created for 4.2 BSD.
 *
 **********************************************************************
 */

#include <libc.h>
#include <c.h>
#include <netdb.h>
#include <setjmp.h>
#include <stdarg.h>
#include <sys/time.h>
#include <sys/param.h>
#include "supcdefs.h"
#include "supextern.h"

#define PGMVERSION 6

/*******************************************
 ***    D A T A   S T R U C T U R E S    ***
 *******************************************/

struct scan_collstruct {		/* one per collection to be upgraded */
	char *Cname;			/* collection name */
	char *Cbase;			/* local base directory */
	char *Cprefix;			/* local collection pathname prefix */
	struct scan_collstruct *Cnext;	/* next collection */
};
typedef struct scan_collstruct SCAN_COLLECTION;

/*********************************************
 ***    G L O B A L   V A R I A B L E S    ***
 *********************************************/

int trace;				/* -v flag */
int quiet;				/* -q flag */

SCAN_COLLECTION *firstC;		/* collection list pointer */
char *collname;				/* collection name */
char *basedir;				/* base directory name */
char *prefix;				/* collection pathname prefix */
time_t lasttime = 0;			/* time of last upgrade */
time_t scantime;			/* time of this scan */
int newonly = FALSE;			/* new files only */
jmp_buf sjbuf;				/* jump location for errors */

TREELIST *listTL;	/* list of all files specified by <coll>.list */
TREE *listT;		/* final list of files in collection */
TREE *refuseT = NULL;	/* list of all files specified by <coll>.list */


void usage(void);
void init(int, char **);
static SCAN_COLLECTION *getscancoll(char *, char *, char *);
int localhost(char *);
int main(int, char **);

/*************************************
 ***    M A I N   R O U T I N E    ***
 *************************************/

int
main(argc, argv)
	int argc;
	char **argv;
{
	SCAN_COLLECTION * volatile c;

	init(argc, argv);		/* process arguments */
	for (c = firstC; c; c = c->Cnext) {
		collname = c->Cname;
		basedir = c->Cbase;
		prefix = c->Cprefix;
		(void) chdir(basedir);
		scantime = time(NULL);
		if (!quiet)
			printf("SUP Scan for %s starting at %s", collname,
			    ctime(&scantime));
		(void) fflush(stdout);
		if (!setjmp(sjbuf)) {
			makescanlists(); /* record names in scan files */
			scantime = time(NULL);
			if (!quiet)
				printf("SUP Scan for %s completed at %s",
				    collname, ctime(&scantime));
		} else
			fprintf(stderr, "SUP: Scan for %s aborted at %s",
			    collname, ctime(&scantime));
		if (!quiet)
			(void) fflush(stdout);
	}
	while ((c = firstC) != NULL) {
		firstC = firstC->Cnext;
		free(c->Cname);
		free(c->Cbase);
		if (c->Cprefix)
			free(c->Cprefix);
		free(c);
	}
	exit (0);
}

/*****************************************
 ***    I N I T I A L I Z A T I O N    ***
 *****************************************/

void
usage()
{

	fprintf(stderr, "Usage: supscan [ -vq ] collection [ basedir ]\n");
	fprintf(stderr, "       supscan [ -vq ] -f dirfile\n");
	fprintf(stderr, "       supscan [ -vq ] -s\n");
	exit (1);
}

void
init(argc, argv)
	int argc;
	char **argv;
{
	char buf[STRINGLENGTH], fbuf[STRINGLENGTH], *p, *q;
	FILE *f;
	SCAN_COLLECTION **c;
	int fflag, sflag;
	char *filename = NULL;

	quiet = FALSE;
	trace = FALSE;
	fflag = FALSE;
	sflag = FALSE;
	while (argc > 1 && argv[1][0] == '-') {
		switch (argv[1][1]) {
		case 'f':
			fflag = TRUE;
			if (argc == 2)
				usage();
			--argc;
			argv++;
			filename = argv[1];
			break;
		case 'q':
			quiet = TRUE;
			break;
		case 'v':
			trace = TRUE;
			break;
		case 's':
			sflag = TRUE;
			break;
		default:
			fprintf(stderr, "supscan: Invalid flag %s ignored\n",
			    argv[1]);
			(void) fflush(stderr);
		}
		--argc;
		argv++;
	}
	if (!fflag) {
		(void) snprintf(fbuf, sizeof fbuf, FILEDIRS, DEFDIR);
		filename = fbuf;
	}
	if (sflag) {
		if (argc != 1)
			usage();
		firstC = NULL;
		c = &firstC;
		(void) snprintf(buf, sizeof buf, FILEHOSTS, DEFDIR);
		if ((f = fopen(buf, "r")) == NULL)
			quit(1, "supscan: Unable to open %s\n", buf);
		while ((p = fgets(buf, sizeof(buf), f)) != NULL) {
			p[strcspn(p, "\n")] = '\0';
			if (strchr("#;:", *p))
				continue;
			collname = nxtarg(&p, " \t=");
			p = skipover(p, " \t=");
			if (!localhost(p))
				continue;
			*c = getscancoll(filename, strdup(collname), NULL);
			if (*c)
				c = &((*c)->Cnext);
		}
		(void) fclose(f);
		return;
	}
	if (argc < 2 && fflag) {
		firstC = NULL;
		c = &firstC;
		if ((f = fopen(filename, "r")) == NULL)
			quit(1, "supscan: Unable to open %s\n", filename);
		while ((p = fgets(buf, sizeof(buf), f)) != NULL) {
			p[strcspn(p, "\n")] = '\0';
			if (strchr("#;:",*p))
				continue;
			q = nxtarg(&p, " \t=");
			p = skipover(p, " \t=");
			*c = getscancoll(filename, strdup(q), strdup(p));
			if (*c)
				c = &((*c)->Cnext);
		}
		(void) fclose(f);
		return;
	}
	if (argc < 2 || argc > 3)
		usage();
	firstC = getscancoll(filename, strdup(argv[1]),
	    argc > 2 ? strdup(argv[2]) : NULL);
}

static SCAN_COLLECTION *
getscancoll(filename, collname, basedir)
	char *filename, *collname, *basedir;
{
	char buf[STRINGLENGTH], *p, *q;
	FILE *f;
	SCAN_COLLECTION *c;

	if (basedir == NULL) {
		if ((f = fopen(filename, "r")) != NULL) {
			while ((p = fgets(buf, sizeof(buf), f)) != NULL) {
				p[strcspn(p, "\n")] = '\0';
				if (strchr("#;:", *p))
					continue;
				q = nxtarg(&p, " \t=");
				if (strcmp(q, collname) == 0) {
					p = skipover(p, " \t=");
					basedir = strdup(p);
					break;
				}
			}
			(void) fclose(f);
		}
		if (basedir == NULL) {
			(void) snprintf(buf, sizeof buf, FILEBASEDEFAULT,
			    collname);
			basedir = strdup(buf);
		}
	}
	if (chdir(basedir) < 0) {
		fprintf (stderr,
		    "supscan:  Can't chdir to base directory %s for %s\n",
		    basedir, collname);
		return (NULL);
	}
	prefix = NULL;
	(void) snprintf(buf, sizeof buf, FILEPREFIX, collname);
	if ((f = fopen(buf, "r")) != NULL) {
		while ((p = fgets(buf, sizeof(buf), f)) != NULL) {
			p[strcspn(p, "\n")] = '\0';
			if (strchr("#;:", *p))
				continue;
			prefix = strdup(p);
			if (chdir(prefix) < 0) {
				fprintf(stderr, "supscan: can't chdir to %s from base directory %s for %s\n",
				    prefix, basedir, collname);
				return (NULL);
			}
			break;
		}
		(void) fclose(f);
	}
	if ((c = (SCAN_COLLECTION *) malloc(sizeof(SCAN_COLLECTION))) == NULL)
		quit(1, "supscan: can't malloc collection structure\n");
	c->Cname = collname;
	c->Cbase = basedir;
	c->Cprefix = prefix;
	c->Cnext = NULL;
	return (c);
}

void
goaway(char *fmt,...)
{
	va_list ap;

	va_start(ap,fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void) putc ('\n', stderr);
	(void) fflush(stderr);
	longjmp(sjbuf,TRUE);
}

int
localhost (host)
	char *host;
{
	static char myhost[MAXHOSTNAMELEN];
	static int myhostlen;
	int hostlen;

	if (*myhost == '\0') {
		/*
		 * We assume that the host name in the kernel is the
		 * fully qualified form.
		 */
		if (gethostname(myhost, sizeof (myhost)) < 0)
			quit (1, "supscan: can't get kernel host name\n");
		myhostlen = strlen(myhost);
	}

	/*
	 * Here, we assume that the 'host' parameter from the
	 * coll.host file is at least a prefix of the fully qualified
	 * host name of some machine.  This will be true when modcoll(8)
	 * (and related scripts) maintain the relevant files, but if
	 * a person makes a manual change, problems could result.  In
	 * particular, if a nicname, such as "Y" for "GANDALF.CS.CMU.EDU"
	 * is present in the coll.host file, things will not work as
	 * expected.
	 */

	hostlen = strlen(host);

	return(strncasecmp(myhost, host,
	    hostlen < myhostlen ? hostlen : myhostlen) == 0);
}
@


1.15
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supscan.c,v 1.14 2006/01/23 17:29:22 millert Exp $	*/
@


1.14
log
@Include <sys/param.h> instead of <sys/types.h> so we get MAXHOSTNAMELEN
@
text
@d1 1
a1 1
/*	$OpenBSD: supscan.c,v 1.13 2002/02/19 19:39:39 millert Exp $	*/
d279 1
a279 3
			q = strchr(p, '\n');
			if (q)
				*q = '\0';
d299 1
a299 3
			q = strchr(p, '\n');
			if (q)
				*q = '\0';
d328 1
a328 3
				q = strchr(p, '\n');
				if (q)
					*q = '\0';
d356 1
a356 3
			q = strchr(p, '\n');
			if (q)
				*q = '\0';
@


1.13
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: supscan.c,v 1.12 2002/02/16 21:27:54 millert Exp $	*/
d120 1
a120 1
#include <sys/types.h>
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: supscan.c,v 1.11 2001/05/04 22:16:17 millert Exp $	*/
a117 1
#ifdef __STDC__
a118 3
#else
#include <varargs.h>
#endif
a386 1
#ifdef __STDC__
a387 5
#else
/*VARARGS*//*ARGSUSED*/
goaway(va_alist)
va_dcl
#endif
a390 1
#ifdef __STDC__
a391 7
#else
	char *fmt;

	va_start(ap);
	fmt = va_arg(ap, char *);
#endif

@


1.11
log
@o kill register
o lots of KNF
o passes -Wall
o fix some [ug]id_t vs. int issues
o use strlcpy/strlcat in favor of strncpy/strncat
o use mem* routines everywhere instead of old b* ones
o marked several questionable things for later fixing
o kill ci.c and cvt.c -- we don't use them
o kill read_line.c since it requires fgetln() (bad for portability)
o kill salloc.c since it is the same as strup()
o Replaced some #ifdef __OpenBSD__ with better tests
o remaining problems: malloc return values are rarely checked, select misuse
@
text
@d1 1
a1 1
/*	$OpenBSD: supscan.c,v 1.10 2001/05/02 22:56:54 millert Exp $	*/
d163 5
a167 5
void usage __P((void));
void init __P((int, char **));
static SCAN_COLLECTION *getscancoll __P((char *, char *, char *));
int localhost __P((char *));
int main __P((int, char **));
@


1.10
log
@Sync with NetBSD.  Notable changes:
 o Add libwrap support to supfilesrv, conditioned by #ifdef LIBWRAP
   (on by default). <bouyer@@netbsd.org>
 o Renamed '-l' (the 'live' mode) to '-d' and '-l' is now used to
   enable logging of successfull connections. <bouyer@@netbsd.org>
 o Don't botch varargs: the are not always an array of void * in the stack...
   Write a separate function to convert a list of function parameters to
   explain why execv failed. <christos@@netbsd.org>
 o When in compress mode, don't overwrite the destination file directly,
   write a temp file and use rename when it is done. (From James Mathiesen
   <james@@deshaw.com>)
 o Rename errno variable to error to avoid collision with errno.h and remove
   explicit extern of errno (we get it from errno.h) <mycroft@@netbsd.org>
 o Cleanup unsigned char vs. char
 o Add -u flag, that prevents sup from attempting to restore a and m times
   on the received files.
 o Replace the provided read_line function with calls to the fparseln function
   in libutil.  Maintain compatibility on machines without fparseln through
   the NEED_READ_LINE define.
 o Rename login() to suplogin() to avoid name collition in util.h
 o If rmdir() fails, chmod the path to have r/w/x perms and run "rm -rf"
 o avoid last.temp filename collision by using rel-suffix
 o When creating directories, make sure you remove previous non-directories
   before doing so, otherwise sup fails.
 o Add -q flag to supscan for quiet operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: supscan.c,v 1.9 2001/04/29 21:52:17 millert Exp $	*/
d174 3
a176 3
main (argc,argv)
int argc;
char **argv;
d178 1
a178 5
	SCAN_COLLECTION *c;
#if __GNUC__
	/* Avoid longjmp clobbering */
	(void) &c;
#endif
d180 1
a180 1
	init (argc,argv);		/* process arguments */
d185 2
a186 2
		(void) chdir (basedir);
		scantime = time ((time_t *)NULL);
d188 6
a193 6
			printf ("SUP Scan for %s starting at %s",collname,
				ctime (&scantime));
		(void) fflush (stdout);
		if (!setjmp (sjbuf)) {
			makescanlists (); /* record names in scan files */
			scantime = time ((time_t *)NULL);
d195 2
a196 2
				printf ("SUP Scan for %s completed at %s",
					collname, ctime (&scantime));
d198 2
a199 3
			fprintf(stderr, 
				"SUP: Scan for %s aborted at %s",collname,
				ctime (&scantime));
d201 1
a201 1
			(void) fflush (stdout);
d205 5
a209 4
		free (c->Cname);
		free (c->Cbase);
		if (c->Cprefix)  free (c->Cprefix);
		free ((char *)c);
d219 1
a219 1
usage ()
d221 4
a224 3
	fprintf (stderr,"Usage: supscan [ -vq ] collection [ basedir ]\n");
	fprintf (stderr,"       supscan [ -vq ] -f dirfile\n");
	fprintf (stderr,"       supscan [ -vq ] -s\n");
d229 3
a231 3
init (argc,argv)
int argc;
char **argv;
d233 1
a233 1
	char buf[STRINGLENGTH],fbuf[STRINGLENGTH],*p,*q;
d236 1
a236 1
	int fflag,sflag;
d248 1
a248 1
				usage ();
d263 3
a265 3
			fprintf (stderr,"supscan: Invalid flag %s ignored\n",
				argv[1]);
			(void) fflush (stderr);
d271 1
a271 1
		(void) snprintf (fbuf,sizeof fbuf,FILEDIRS,DEFDIR);
d276 1
a276 1
			usage ();
d279 16
a294 13
		(void) snprintf (buf,sizeof buf,FILEHOSTS,DEFDIR);
		if ((f = fopen (buf,"r")) == NULL)
			quit (1,"supscan: Unable to open %s\n",buf);
		while ((p = fgets (buf,STRINGLENGTH,f)) != NULL) {
			q = strchr (p,'\n');
			if (q)  *q = 0;
			if (strchr ("#;:",*p))  continue;
			collname = nxtarg (&p," \t=");
			p = skipover (p," \t=");
			if (!localhost (p))  continue;
			*c = getscancoll(filename,salloc (collname),
					(char *)NULL);
			if (*c)  c = &((*c)->Cnext);
d296 1
a296 1
		(void) fclose (f);
d302 13
a314 10
		if ((f = fopen (filename,"r")) == NULL)
			quit (1,"supscan: Unable to open %s\n",filename);
		while ((p = fgets (buf,STRINGLENGTH,f)) != NULL) {
			q = strchr (p,'\n');
			if (q)  *q = 0;
			if (strchr ("#;:",*p))  continue;
			q = nxtarg (&p," \t=");
			p = skipover (p," \t=");
			*c = getscancoll(filename,salloc (q),salloc (p));
			if (*c)  c = &((*c)->Cnext);
d316 1
a316 1
		(void) fclose (f);
d320 3
a322 3
		usage ();
	firstC = getscancoll(filename,salloc (argv[1]),
			argc > 2 ? salloc (argv[2]) : (char *)NULL);
d327 1
a327 1
register char *filename,*collname,*basedir;
d329 1
a329 1
	char buf[STRINGLENGTH],*p,*q;
d334 11
a344 9
		if ((f = fopen (filename,"r")) != NULL) {
			while ((p = fgets (buf,STRINGLENGTH,f)) != NULL) {
				q = strchr (p,'\n');
				if (q)  *q = 0;
				if (strchr ("#;:",*p))  continue;
				q = nxtarg (&p," \t=");
				if (strcmp (q,collname) == 0) {
					p = skipover (p," \t=");
					basedir = salloc (p);
d348 1
a348 1
			(void) fclose (f);
d351 3
a353 3
			(void) snprintf (buf,sizeof buf,
				FILEBASEDEFAULT,collname);
			basedir = salloc (buf);
d357 3
a359 2
		fprintf (stderr,"supscan:  Can't chdir to base directory %s for %s\n",
			basedir,collname);
d363 9
a371 7
	(void) snprintf (buf,sizeof buf,FILEPREFIX,collname);
	if ((f = fopen (buf,"r")) != NULL) {
		while ((p = fgets (buf,STRINGLENGTH,f)) != NULL) {
			q = strchr (p,'\n');
			if (q) *q = 0;
			if (strchr ("#;:",*p))  continue;
			prefix = salloc (p);
d373 2
a374 2
				fprintf (stderr,"supscan: can't chdir to %s from base directory %s for %s\n",
					prefix,basedir,collname);
d379 1
a379 1
		(void) fclose (f);
d381 2
a382 2
	if ((c = (SCAN_COLLECTION *) malloc (sizeof(SCAN_COLLECTION))) == NULL)
		quit (1,"supscan: can't malloc collection structure\n");
d392 1
a392 1
goaway (char *fmt,...)
d395 1
a395 1
goaway (va_alist)
d407 1
a407 1
	fmt = va_arg(ap,char *);
d412 3
a414 3
	(void) putc ('\n',stderr);
	(void) fflush (stderr);
	longjmp (sjbuf,TRUE);
d417 3
a419 2
int localhost (host)
register char *host;
d423 1
a423 1
	register int hostlen;
d430 2
a431 3
		if (gethostname (myhost,sizeof (myhost)) < 0) {
		    quit (1,"supscan: can't get kernel host name\n");
		}
d448 2
a449 3
	return(strncasecmp (myhost,
			    host,
			    hostlen < myhostlen ? hostlen : myhostlen) == 0);
@


1.9
log
@Add a bunch of old revision history comments that we are missing to
make diffing easier.  No code changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: supscan.c,v 1.8 1997/09/16 11:01:24 deraadt Exp $	*/
d147 1
d191 3
a193 2
		printf ("SUP Scan for %s starting at %s",collname,
			ctime (&scantime));
d198 3
a200 2
			printf ("SUP Scan for %s completed at %s",collname,
				ctime (&scantime));
d202 2
a203 1
			printf ("SUP: Scan for %s aborted at %s",collname,
d205 2
a206 1
		(void) fflush (stdout);
d225 3
a227 3
	fprintf (stderr,"Usage: supscan [ -v ] collection [ basedir ]\n");
	fprintf (stderr,"       supscan [ -v ] -f dirfile\n");
	fprintf (stderr,"       supscan [ -v ] -s\n");
d242 1
d256 3
d266 2
a267 1
			fprintf (stderr,"supscan: Invalid flag %s ignored\n",argv[1]);
d412 1
a412 1
	static char myhost[STRINGLENGTH];
@


1.8
log
@strcpy whacking; ci.c and expand.c need more work
@
text
@d1 1
a1 1
/*	$OpenBSD: supscan.c,v 1.7 1997/09/16 10:43:01 deraadt Exp $	*/
d19 1
a19 1
 *  Software Distribution Coordinator  or  Software_Distribution@@CS.CMU.EDU
d43 33
@


1.7
log
@snprintf this thing
@
text
@d1 1
a1 1
/*	$OpenBSD: supscan.c,v 1.6 1997/07/25 21:05:43 mickey Exp $	*/
d239 1
a239 1
		(void) snprintf (buf,sizeof buf,sizeof buf,FILEHOSTS,DEFDIR);
d303 1
a303 1
			(void) snprintf (buf,sizeof buf,sizeof buf,
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: supscan.c,v 1.5 1997/04/01 07:35:49 todd Exp $	*/
d231 1
a231 1
		(void) sprintf (fbuf,FILEDIRS,DEFDIR);
d239 1
a239 1
		(void) sprintf (buf,FILEHOSTS,DEFDIR);
d303 2
a304 1
			(void) sprintf (buf,FILEBASEDEFAULT,collname);
d314 1
a314 1
	(void) sprintf (buf,FILEPREFIX,collname);
@


1.5
log
@This merges in the latest NetBSD sup source.
- removed $Log: ...$ tags to not waste space in the repository
- now doesn't segfault on the alpha!

Note:
To compile sup on systems other than *BSD, you'll need a copy of
vis.c, vis.h, daemon.c, and sys/cdefs.h.  At least the first two
(for OSF/1).

From NetBSD changelog description (for credit where due):
.... 1996/12/23 19:42:05  christos
- add missing prototypes.
- fix function call inconsistencies
- fix int <-> long and pointer conversions
It should run now on 64 bit machines...

....  1996/12/31 18:08:00  christos
64 bit patches (mostly long -> time_t) from Matthew Jacob (?)
sup now works on the alpha!
@
text
@d1 1
a1 1
/*	$OpenBSD: supscan.c,v 1.4 1997/01/17 07:18:11 millert Exp $	*/
d85 1
a85 1
#if __STDC__
@


1.4
log
@more r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: supscan.c,v 1.3 1996/07/31 11:11:35 niklas Exp $	*/
a42 46
 * $Log: supscan.c,v $
 * Revision 1.3  1996/07/31 11:11:35  niklas
 * Better use time_t instead of long when dealing with times
 *
 * Revision 1.2  1996/06/26 05:39:56  deraadt
 * rcsid
 *
 * Revision 1.1  1995/12/16 11:47:01  deraadt
 * add sup to the tree
 *
 * Revision 1.1.1.1  1993/05/21 14:52:19  cgd
 * initial import of CMU's SUP to NetBSD
 *
 * Revision 1.14  92/08/11  12:08:30  mrt
 * 	Picked up Brad's deliniting and variable argument changes
 * 	[92/08/10            mrt]
 * 
 * Revision 1.13  92/02/08  18:04:44  dlc
 * 	Once again revised localhost().  Do not use gethostbyname() at
 * 	all, but assume that the host names in the coll.host file are at
 * 	least a prefix of the fully qualified name.  Modcoll (and related
 * 	scripts) will maintain this fact.
 * 	[92/02/08            dlc]
 * 
 * Revision 1.12  91/08/17  23:35:31  dlc
 * 	Changes to localhost() function:
 * 		- Use host name in kernel for local host name; assume it is
 * 		  fully qualified.
 * 		- If gethostbyname() of host to see if we are the repository
 * 		  fails, with TRY_AGAIN or NO_RECOVERY, then use the "host"
 * 		  parameter.  Print a diagnostic in this case.
 * 	[91/08/17            dlc]
 * 
 * Revision 1.11  90/04/04  10:53:01  dlc
 * 	Changed localhost to retry getting the local host name 4 times with
 * 	30 second sleep intervals before aborting; after 4 tries, things are
 * 	probably too messed up for the supscan to do anything useful
 * 	[90/04/04            dlc]
 * 
 * Revision 1.10  89/08/03  19:49:33  mja
 * 	Updated to use v*printf() in place of _doprnt().
 * 	[89/04/19            mja]
 * 
 * Revision 1.9  89/06/18  14:41:37  gm0w
 * 	Fixed up some notify messages of errors to use "SUP:" prefix.
 * 	[89/06/18            gm0w]
d92 2
a93 6
#include "sup.h"

#ifdef	lint
/*VARARGS1*//*ARGSUSED*/
static void quit(status) {};
#endif	/* lint */
d101 1
a101 1
struct collstruct {			/* one per collection to be upgraded */
d105 1
a105 1
	struct collstruct *Cnext;	/* next collection */
d107 1
a107 1
typedef struct collstruct COLLECTION;
d115 1
a115 1
COLLECTION *firstC;			/* collection list pointer */
d120 1
a120 1
time_t scantime;				/* time of this scan */
d128 7
d139 1
d144 5
a148 1
	register COLLECTION *c;
d170 1
a170 1
	while (c = firstC) {
d184 1
d193 1
d200 1
a200 1
	COLLECTION **c, *getcoll();
d202 1
a202 1
	char *filename;
d249 1
a249 1
			*c = getcoll(filename,salloc (collname),
d261 1
a261 1
		while (p = fgets (buf,STRINGLENGTH,f)) {
d267 1
a267 1
			*c = getcoll(filename,salloc (q),salloc (p));
d275 1
a275 1
	firstC = getcoll(filename,salloc (argv[1]),
d279 2
a280 2
COLLECTION *
getcoll(filename, collname, basedir)
d285 1
a285 1
	COLLECTION *c;
d288 2
a289 2
		if (f = fopen (filename,"r")) {
			while (p = fgets (buf,STRINGLENGTH,f)) {
d314 2
a315 2
	if (f = fopen (buf,"r")) {
		while (p = fgets (buf,STRINGLENGTH,f)) {
d329 1
a329 1
	if ((c = (COLLECTION *) malloc (sizeof(COLLECTION))) == NULL)
d337 3
a339 1
#if __STDC__
a346 3
#if !__STDC__
	char *fmt;
#endif
d349 1
a349 1
#if __STDC__
d352 2
@


1.3
log
@Better use time_t instead of long when dealing with times
@
text
@d1 1
a1 1
/*	$OpenBSD: supscan.c,v 1.2 1996/06/26 05:39:56 deraadt Exp $	*/
d44 3
d279 1
a279 1
			q = index (p,'\n');
d281 1
a281 1
			if (index ("#;:",*p))  continue;
d298 1
a298 1
			q = index (p,'\n');
d300 1
a300 1
			if (index ("#;:",*p))  continue;
d326 1
a326 1
				q = index (p,'\n');
d328 1
a328 1
				if (index ("#;:",*p))  continue;
d352 1
a352 1
			q = index (p,'\n');
d354 1
a354 1
			if (index ("#;:",*p))  continue;
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 3
d166 2
a167 2
long lasttime = 0;			/* time of last upgrade */
long scantime;				/* time of this scan */
a174 2
long time ();

d191 1
a191 1
		scantime = time ((long *)NULL);
d197 1
a197 1
			scantime = time ((long *)NULL);
@


1.1
log
@add sup to the tree
@
text
@d1 2
d44 3
@
