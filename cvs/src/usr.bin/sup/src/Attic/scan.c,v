head	1.17;
access;
symbols
	OPENBSD_4_8:1.16.0.12
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.8
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.10
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.6
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.18
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.16
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.14
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.12
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.16
	OPENBSD_2_8:1.8.0.14
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.12
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.17
date	2010.10.18.20.54.00;	author deraadt;	state dead;
branches;
next	1.16;

1.16
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.10.00.06.51;	author david;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.30.21.34.47;	author vincent;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.04.22.16.16;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.29.22.23.13;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.29.21.52.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.29.18.16.19;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.09.16.11.01.16;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.09.16.10.42.51;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.04.01.07.35.20;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	97.01.17.07.18.04;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.07.31.11.11.24;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.39.46;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.17.17.24.13;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.12.16.11.46.50;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@sup is no longer used. reminded by pirofti and jmc
@
text
@/*	$OpenBSD: scan.c,v 1.16 2007/09/11 15:47:17 gilles Exp $	*/

/*
 * Copyright (c) 1992 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 * scan.c - sup list file scanner
 *
 **********************************************************************
 * HISTORY
 * Revision 1.8  92/08/11  12:04:28  mrt
 * 	Brad's changes: delinted, added forward declarations of static
 * 	functions.Added Copyright.
 * 	[92/07/24            mrt]
 * 
 * 18-Mar-88  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added host=<hostfile> support to releases file.
 *
 * 11-Mar-88  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added "rsymlink" recursive symbolic link quoting directive.
 *
 * 28-Jun-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code for "release" support.
 *
 * 26-May-87  Doug Philips (dwp) at Carnegie-Mellon University
 *	Lets see if we'll be able to write the scan file BEFORE
 *	we collect the data for it.  Include sys/file.h and use
 *	new definitions for access check codes.
 *
 * 20-May-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added type casting information for lint.
 *
 * 21-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added check for newonly upgrade when lasttime is the same as
 *	scantime.  This will save us the trouble of parsing the scanfile
 *	when the client has successfully received everything in the
 *	scanfile already.
 *
 * 16-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Clear Texec pointers in execT so that Tfree of execT will not
 *	free command trees associated with files in listT.
 *
 * 06-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code to omit scanned files from list if we want new files
 *	only and they are old.
 *
 * 29-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Major rewrite for protocol version 4.  Added version numbers to
 *	scan file.  Also added mode of file in addition to flags.
 *	Execute commands are now immediately after file information.
 *
 * 13-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added comments to list file format.
 *
 * 08-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code to implement omitany.  Currently doesn't know about
 *	{a,b,c} patterns.
 *
 * 07-Oct-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Created.
 *
 **********************************************************************
 */

#include <libc.h>
#include <c.h>
#include <stdlib.h>
#include <vis.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/stat.h>
#ifdef HAS_POSIX_DIR
#include <dirent.h>
#else
#include <sys/dir.h>
#endif
#include <sys/file.h>
#include <unistd.h>
#include "supcdefs.h"
#include "supextern.h"

/*************************
 ***    M A C R O S    ***
 *************************/

#define SPECNUMBER 1000
	/* number of filenames produced by a single spec in the list file */

/*******************************************
 ***    D A T A   S T R U C T U R E S    ***
 *******************************************/

typedef enum {			/* release options */
	ONEXT,		OPREFIX,	OLIST,		OSCAN,
	OHOST
} OPTION;

static char *options[] = {
	"next",		"prefix",	"list",		"scan",
	"host",
	0
};

typedef enum {			/* <collection>/list file lines */
	LUPGRADE,	LOMIT,		LBACKUP,	LEXECUTE,
	LINCLUDE,	LNOACCT,	LOMITANY,	LALWAYS,
	LSYMLINK,	LRSYMLINK
} LISTTYPE;

static char *ltname[] = {
	"upgrade",	"omit",		"backup",	"execute",
	"include",	"noaccount",	"omitany",	"always",
	"symlink",	"rsymlink",
	0
};

#define FALWAYS		FUPDATE

/* list file lines */
static TREE *upgT;			/* files to upgrade */
static TREE *flagsT;			/* special flags: BACKUP NOACCT */
static TREE *omitT;			/* recursize file omition list */
static TREE *omanyT;			/* non-recursize file omition list */
static TREE *symT;			/* symbolic links to quote */
static TREE *rsymT;			/* recursive symbolic links to quote */
static TREE *execT;			/* execute command list */

/*************************
 ***    E X T E R N    ***
 *************************/

#ifdef	lint
static char _argbreak;
#else
extern char _argbreak;			/* break character from nxtarg */
#endif

extern TREELIST *listTL;		/* list of trees for scanning */
extern TREE *listT;			/* final list of files in collection */
extern TREE *refuseT;			/* files refused by client */

extern char *collname;			/* collection name */
extern char *basedir;			/* base directory name */
extern char *prefix;			/* collection pathname prefix */
extern time_t lasttime;			/* time of last upgrade */
extern time_t scantime;			/* time of this scan */
extern int trace;			/* trace directories */
extern int newonly;			/* new files only */

#ifdef RCSSTAT
extern char *rcs_branch;
extern int candorcs;
#endif

/*************************************************
 ***   STATIC   R O U T I N E S    ***
 *************************************************/
static void passdelim(char **, int );
static char *parserelease(TREELIST **, char *, char *);
static int scanone(TREE *, void *);
static void makescan(char *, char *);
static void getscan(char *, char *);
static void doscan(char *);
static void readlistfile(char *);
static void expTinsert(char *, TREE **, int, char *);
static int listone(TREE *, void *);
static void listentry(char *, char *, char *, int);
static void listname(char *, struct stat *);
static void listdir(char *, int);
static int omitanyone(TREE *, void *);
static int anyglob(char *, char *);
static int getscanfile(char *);
static void chkscanfile(char *);
static void makescanfile(char *);
static int recordone(TREE *, void *);
static int recordexec(TREE *, void *);


/*************************************************
 ***    L I S T   S C A N   R O U T I N E S    ***
 *************************************************/

static void
passdelim(ptr,delim)		/* skip over delimiter */
	char **ptr, delim;
{

	*ptr = skipover (*ptr, " \t");
	if (_argbreak != delim && **ptr == delim) {
		(*ptr)++;
		*ptr = skipover (*ptr, " \t");
	}
}

static char *
parserelease(tlp, relname, args)
	TREELIST **tlp;
	char *relname, *args;
{
	TREELIST *tl;
	char *arg;
	OPTION option;
	int opno;
	char *nextrel;

	tl = (TREELIST *) malloc(sizeof(TREELIST));
	if ((*tlp = tl) == NULL)
		goaway("Couldn't allocate TREELIST");
	tl->TLnext = NULL;
	tl->TLname = strdup(relname);
	tl->TLprefix = NULL;
	tl->TLlist = NULL;
	tl->TLscan = NULL;
	tl->TLhost = NULL;
	nextrel = NULL;
	args = skipover(args, " \t");
	while (*(arg = nxtarg(&args, " \t="))) {
		for (opno = 0; options[opno] != NULL; opno++)
			if (strcmp(arg, options[opno]) == 0)
				break;
		if (options[opno] == NULL)
			goaway("Invalid release option %s for release %s",
			    arg, relname);
		option = (OPTION) opno;
		switch (option) {
		case ONEXT:
			passdelim(&args, '=');
			arg = nxtarg(&args, " \t");
			nextrel = strdup(arg);
			break;
		case OPREFIX:
			passdelim(&args, '=');
			arg = nxtarg(&args, " \t");
			tl->TLprefix = strdup(arg);
			break;
		case OLIST:
			passdelim(&args,'=');
			arg = nxtarg(&args, " \t");
			tl->TLlist = strdup(arg);
			break;
		case OSCAN:
			passdelim(&args, '=');
			arg = nxtarg(&args, " \t");
			tl->TLscan = strdup(arg);
			break;
		case OHOST:
			passdelim(&args, '=');
			arg = nxtarg (&args, " \t");
			tl->TLhost = strdup(arg);
			break;
		}
	}
	return (nextrel);
}

int
getrelease (release)
	char *release;
{
	TREELIST *tl;
	char buf[STRINGLENGTH];
	char *p,*q;
	int rewound;
	FILE *f;

	if (release == NULL)
		release = strdup(DEFRELEASE);
	listTL = NULL;

	(void) snprintf(buf, sizeof buf, FILERELEASES, collname);
	f = fopen(buf, "r");
	if (f != NULL) {
		rewound = TRUE;
		for (;;) {
			p = fgets(buf, sizeof(buf), f);
			if (p == NULL) {
				if (rewound)
					break;
				rewind(f);
				rewound = TRUE;
				continue;
			}
			p[strcspn(p, "\n")] = '\0';
			if (strchr("#;:", *p))
				continue;
			q = nxtarg(&p, " \t");
			if (strcmp(q, release) != 0)
				continue;
			release = parserelease(&tl, release, p);
			if (tl->TLprefix == NULL)
				tl->TLprefix = prefix;
			else if (chdir(tl->TLprefix) < 0)
				return (FALSE);
			else
				(void) chdir(basedir);
			tl->TLnext = listTL;
			listTL = tl;
			if (release == NULL)
				break;
			rewound = FALSE;
		}
		(void) fclose(f);
	}
	if (release == NULL)
		return (TRUE);
	if (strcmp(release, DEFRELEASE) != 0)
		return (FALSE);
	(void) parserelease(&tl, release, "");
	tl->TLprefix = prefix;
	tl->TLnext = listTL;
	listTL = tl;
	return (TRUE);
}

void
makescanlists()
{
	TREELIST *tl;
	char buf[STRINGLENGTH];
	char *p,*q;
	FILE *f;
	char *saveprefix = prefix;
	int count = 0;

	(void) snprintf(buf, sizeof buf, FILERELEASES, collname);
	f = fopen(buf, "r");
	if (f != NULL) {
		while ((p = fgets(buf, sizeof(buf), f)) != NULL) {
			p[strcspn(p, "\n")] = '\0';
			if (strchr("#;:", *p))
				continue;
			q = nxtarg(&p, " \t");
			(void) parserelease(&tl, q, p);
			if ((prefix = tl->TLprefix) == NULL)
				prefix = saveprefix;
			if (prefix != NULL) {
				if (chdir(prefix) < 0)
					goaway("Can't chdir to %s", prefix);
				(void) chdir(basedir);
			}
			makescan(tl->TLlist, tl->TLscan);
			free(tl);
			count++;
		}
		(void) fclose(f);
	}
	if (count == 0)
		makescan(NULL, NULL);
}

static int
scanone(t, v)
	TREE *t;
	void *v;
{
	TREE *newt;

	if (newonly && (t->Tflags&FNEW) == 0)
		return (SCMOK);
	newt = Tinsert (&listT, t->Tname, FALSE);
	if (newt == NULL)
		return (SCMOK);
	newt->Tmode = t->Tmode;
	newt->Tflags = t->Tflags;
	newt->Tmtime = t->Tmtime;
	return (SCMOK);
}

void
getscanlists()
{
	TREELIST *tl,*stl;

	stl = listTL;
	listTL = NULL;
	while ((tl = stl) != NULL) {
		prefix = tl->TLprefix;
		getscan(tl->TLlist, tl->TLscan);
		tl->TLtree = listT;
		stl = tl->TLnext;
		tl->TLnext = listTL;
		listTL = tl;
	}
	listT = NULL;
	for (tl = listTL; tl != NULL; tl = tl->TLnext)
		(void) Tprocess(tl->TLtree, scanone, NULL);
}

static void
makescan(listfile, scanfile)
	char *listfile, *scanfile;
{
	listT = NULL;
	chkscanfile(scanfile);		/* can we can write a scan file? */
	doscan(listfile);		/* read list file and scan disk */
	makescanfile(scanfile);		/* record names in scan file */
	Tfree(&listT);			/* free file list tree */
}

static void
getscan(listfile, scanfile)
	char *listfile, *scanfile;
{
	listT = NULL;
	if (!getscanfile(scanfile)) {	/* check for pre-scanned file list */
		scantime = time(NULL);
		doscan(listfile);	/* read list file and scan disk */
	}
}

static void
doscan (listfile)
	char *listfile;
{
	char buf[STRINGLENGTH];

	upgT = NULL;
	flagsT = NULL;
	omitT = NULL;
	omanyT = NULL;
	execT = NULL;
	symT = NULL;
	rsymT = NULL;
	if (listfile == NULL)
		listfile = FILELISTDEF;
	(void) snprintf(buf, sizeof buf, FILELIST, collname, listfile);
	readlistfile(buf);		/* get contents of list file */
	(void) Tprocess(upgT, listone, NULL); /* build list of files specified */
	cdprefix(NULL);
	Tfree(&upgT);
	Tfree(&flagsT);
	Tfree(&omitT);
	Tfree(&omanyT);
	Tfree(&execT);
	Tfree(&symT);
	Tfree(&rsymT);
}

static void
readlistfile(fname)
	char *fname;
{
	char buf[STRINGLENGTH+MAXPATHLEN*4+1], *p;
	char *q, *r;
	FILE *f;
	int ltn, n, i, flags;
	TREE **t = NULL;
	LISTTYPE lt;
	char *speclist[SPECNUMBER];

	f = fopen(fname,"r");
	if (f == NULL)
		goaway("Can't read list file %s", fname);
	cdprefix(prefix);
	while ((p = fgets(buf, sizeof(buf), f)) != NULL) {
		p[strcspn(p, "\n")] = '\0';
		if (strchr("#;:", *p))
			continue;
		q = nxtarg (&p, " \t");
		if (*q == '\0')
			continue;
		for (ltn = 0; ltname[ltn] && strcmp(q, ltname[ltn]) != 0; ltn++)
			;
		if (ltname[ltn] == NULL)
			goaway("Invalid list file keyword %s", q);
		lt = (LISTTYPE) ltn;
		flags = 0;
		switch (lt) {
		case LUPGRADE:
			t = &upgT;
			break;
		case LBACKUP:
			t = &flagsT;
			flags = FBACKUP;
			break;
		case LNOACCT:
			t = &flagsT;
			flags = FNOACCT;
			break;
		case LSYMLINK:
			t = &symT;
			break;
		case LRSYMLINK:
			t = &rsymT;
			break;
		case LOMIT:
			t = &omitT;
			break;
		case LOMITANY:
			t = &omanyT;
			break;
		case LALWAYS:
			t = &upgT;
			flags = FALWAYS;
			break;
		case LINCLUDE:
			while (*(q = nxtarg(&p, " \t"))) {
				cdprefix(NULL);
				n = expand(q, speclist, SPECNUMBER);
				for (i = 0; i < n && i < SPECNUMBER; i++) {
					readlistfile(speclist[i]);
					cdprefix(NULL);
					free(speclist[i]);
				}
				cdprefix(prefix);
			}
			continue;
		case LEXECUTE:
			r = p = q = skipover(p, " \t");
			do {
				q = p = skipto(p, " \t(");
				p = skipover(p, " \t");
			} while (*p != '(' && *p != '\0');
			if (*p++ == '(') {
				*q = '\0';
				do {
					q = nxtarg(&p, " \t)");
					if (*q == 0)
						_argbreak = ')';
					else
						expTinsert(q, &execT, 0, r);
				} while (_argbreak != ')');
				continue;
			}
			/* fall through */
		default:
			goaway("Error in handling list file keyword %d", ltn);
		}
		while (*(q = nxtarg(&p, " \t"))) {
			if (lt == LOMITANY)
				(void) Tinsert(t, q, FALSE);
			else
				expTinsert(q, t, flags, NULL);
		}
	}
	(void) fclose(f);
}

static void
expTinsert(p, t, flags, exec)
	char *p;
	TREE **t;
	int flags;
	char *exec;
{
	int n, i;
	TREE *newt;
	char *speclist[SPECNUMBER];
	char buf[STRINGLENGTH];

	n = expand(p, speclist, SPECNUMBER);
	for (i = 0; i < n && i < SPECNUMBER; i++) {
		newt = Tinsert(t, speclist[i], TRUE);
		newt->Tflags |= flags;
		if (exec) {
			(void) snprintf(buf, sizeof buf, exec, speclist[i]);
			(void) Tinsert(&newt->Texec, buf, FALSE);
		}
		free(speclist[i]);
	}
}

static int
listone (t, v)		/* expand and add one name from upgrade list */
	TREE *t;
	void *v;
{

	listentry(t->Tname, t->Tname, NULL, (t->Tflags&FALWAYS) != 0);
	return (SCMOK);
}

static void
listentry(name, fullname, updir, always)
	char *name, *fullname, *updir;
	int always;
{
	struct stat statbuf;
	int link = 0;

	if (Tlookup (refuseT, fullname))
		return;
	if (!always) {
		if (Tsearch (omitT, fullname))
			return;
		if (Tprocess (omanyT, omitanyone, fullname) != SCMOK)
			return;
	}
	if (lstat(name, &statbuf) < 0)
		return;
	if (S_ISLNK(statbuf.st_mode)) {
		if (Tsearch(symT, fullname)) {
			listname(fullname, &statbuf);
			return;
		}
		if (Tlookup(rsymT, fullname)) {
			listname(fullname, &statbuf);
			return;
		}
		if (updir)
			link++;
		if (stat(name, &statbuf) < 0)
			return;
	}
	if (S_ISDIR(statbuf.st_mode)) {
		if (access(name, R_OK|X_OK) < 0)
			return;
		if (chdir(name) < 0)
			return;
		listname(fullname, &statbuf);
		if (trace) {
			printf("Scanning directory %s\n", fullname);
			(void) fflush(stdout);
		}
		listdir (fullname, always);
		if (updir == 0 || link) {
			(void) chdir(basedir);
			if (prefix)
				(void) chdir(prefix);
			if (updir && *updir)
				(void) chdir(updir);
		} else
			(void) chdir("..");
		return;
	}
	if (access(name, R_OK) < 0)
		return;
#ifdef RCSSTAT
        if (candorcs) {
                char rcs_release[STRINGLENGTH];
                int status;

                if (rcs_branch != NULL)
#ifdef CVS
                        snprintf(rcs_release, sizeof rcs_release,
				"-r %s", rcs_branch);
#else
                        snprintf(rcs_release, sizeof rcs_release,
				"-r%s", rcs_branch);
#endif
                else
                        rcs_release[0] = '\0';
#ifdef CVS
                snprintf(sys_com, sizeof sys_com,
		    "cvs -d %s -r -l -Q co -p %s %s > %s\n", cvs_root,
		    rcs_release, name, rcs_file);
#else
                status = runp("rcsstat", "rcsstat", "-q", rcs_release, name, 0);
#endif
                if (status != 0)
			return;
        }
#endif
	listname(fullname, &statbuf);
}

static void
listname(name,st)
	char *name;
	struct stat *st;
{
	TREE *t, *ts;
	int new;
	TREELIST *tl;

	new = st->st_ctime > lasttime;
	if (newonly && !new) {
		for (tl = listTL; tl != NULL; tl = tl->TLnext)
			if ((ts = Tsearch(tl->TLtree, name)) != NULL)
				ts->Tflags &= ~FNEW;
		return;
	}
	t = Tinsert(&listT, name, FALSE);
	if (t == NULL)
		return;
	t->Tmode = st->st_mode;
	t->Tctime = st->st_ctime;
	t->Tmtime = st->st_mtime;
	if (new)
		t->Tflags |= FNEW;
	if ((ts = Tsearch (flagsT, name)) != NULL)
		t->Tflags |= ts->Tflags;
	if ((ts = Tsearch (execT, name)) != NULL) {
		t->Texec = ts->Texec;
		ts->Texec = NULL;
	}
}

static void
listdir(name,always)		/* expand directory */
	char *name;
	int always;
{
#ifdef HAS_POSIX_DIR
	struct dirent *dentry;
#else
	struct direct *dentry;
#endif
	DIR *dirp;
	char ename[STRINGLENGTH], newname[STRINGLENGTH], filename[STRINGLENGTH];
	char *p, *newp;
	int i;

	dirp = opendir(".");
	if (dirp == 0)
		return;	/* unreadable: probably protected */

	p = name;		/* punt leading ./ and trailing / */
	newp = newname;
	if (p[0] == '.' && p[1] == '/') {
		p += 2;
		while (*p == '/')
			p++;
	}
	while ((*newp++ = *p++) != '\0')
		;	/* copy string */
	--newp;				/* trailing null */
	while (newp > newname && newp[-1] == '/')
		--newp; /* trailing / */
	*newp = 0;
	if (strcmp(newname, ".") == 0)
		newname[0] = 0;	/* "." ==> "" */

	while ((dentry=readdir(dirp)) != NULL) {
		if (dentry->d_ino == 0 || strcmp(dentry->d_name, ".") == 0 ||
		    strcmp(dentry->d_name, "..") == 0)
			continue;
		for (i=0; i <= MAXNAMLEN && dentry->d_name[i]; i++)
			ename[i] = dentry->d_name[i];
		ename[i] = 0;
		if (*newname)
			(void) snprintf(filename, sizeof filename, "%s/%s",
			    newname, ename);
		else
			(void) strlcpy(filename, ename, sizeof filename);
		listentry(ename, filename, newname, always);
	}
	closedir(dirp);
}

static int
omitanyone(t,fv)
	TREE *t;
	void *fv;
{
	char *filename = fv;

	if (anyglob(t->Tname, filename))
		return (SCMERR);
	return (SCMOK);
}

static int
anyglob(pattern, match)
	char *pattern, *match;
{
	char *p, *m;
	char *pb, *pe;

	p = pattern; 
	m = match;
	while (*m && *p == *m ) { 
		p++; 
		m++; 
	}
	if (*p == '\0' && *m == '\0')
		return (TRUE);
	switch (*p++) {
	case '*':
		for (;;) {
			if (*p == '\0')
				return (TRUE);
			if (*m == '\0')
				return (*p == '\0');
			if (anyglob (p, ++m))
				return (TRUE);
		}
	case '?':
		return (anyglob(p, ++m));
	case '[':
		pb = p;
		while (*(++p) != ']')
			if (*p == '\0')
				return (FALSE);
		pe = p;
		for (p = pb + 1; p != pe; p++) {
			switch (*p) {
			case '-':
				if (p == pb && *m == '-') {
					p = pe + 1;
					return (anyglob(p, ++m));
				}
				if (p == pb)
					continue;
				if ((p + 1) == pe)
					return (FALSE);
				if (*m > *(p - 1) &&
				    *m <= *(p + 1)) {
					p = pe + 1;
					return (anyglob(p, ++m));
				}
				continue;
			default:
				if (*m == *p) {
					p = pe + 1;
					return (anyglob(p, ++m));
				}
			}
		}
		return (FALSE);
	default:
		return (FALSE);
	}
}

/*****************************************
 ***    R E A D   S C A N   F I L E    ***
 *****************************************/

static
int getscanfile(scanfile)
	char *scanfile;
{
	char buf[STRINGLENGTH];
	char fname[MAXPATHLEN];
	struct stat sbuf;
	FILE *f;
	TREE ts;
	char *p, *q;
	TREE *tmp, *t = NULL;
	int notwanted;
	TREELIST *tl;
        
	if (scanfile == NULL)
		scanfile = FILESCANDEF;
	(void) snprintf(buf, sizeof buf, FILESCAN, collname, scanfile);
	if (stat(buf, &sbuf) < 0)
		return (FALSE);
	if ((f = fopen(buf, "r")) == NULL)
		return (FALSE);
	if ((p = fgets (buf, sizeof(buf), f)) == NULL) {
		(void) fclose(f);
		return (FALSE);
	}

	p[strcspn(p, "\n")] = '\0';

	if (*p++ != 'V') {
		(void) fclose(f);
		return (FALSE);
	}
	if (atoi (p) != SCANVERSION) {
		(void) fclose(f);
		return (FALSE);
	}
	scantime = sbuf.st_mtime;	/* upgrade time is time of supscan,
					 * i.e. time of creation of scanfile */
	if (newonly && scantime == lasttime) {
		(void) fclose(f);
		return (TRUE);
	}
	notwanted = FALSE;
	while ((p = fgets(buf, sizeof(buf), f)) != NULL) {
		p[strcspn(p, "\n")] = '\0';
		ts.Tflags = 0;
		if (*p == 'X') {
			if (notwanted)
				continue;
			if (t == NULL)
				goaway("scanfile format inconsistent");
			(void) Tinsert(&t->Texec, ++p, FALSE);
			continue;
		}
		notwanted = FALSE;
		if (*p == 'B') {
			p++;
			ts.Tflags |= FBACKUP;
		}
		if (*p == 'N') {
			p++;
			ts.Tflags |= FNOACCT;
		}
		if ((q = strchr(p, ' ')) == NULL)
			goaway("scanfile format inconsistent");
		*q++ = '\0';
		ts.Tmode = atoo(p);
		p = q;
		if ((q = strchr(p, ' ')) == NULL)
			goaway("scanfile format inconsistent");
		*q++ = '\0';
		ts.Tctime = atoi(p);
		p = q;
		if ((q = strchr(p, ' ')) == NULL)
			goaway("scanfile format inconsistent");
		*q++ = 0;
		ts.Tmtime = atoi(p);
		(void) strunvis(fname, q);
		if (ts.Tctime > lasttime)
			ts.Tflags |= FNEW;
		else if (newonly) {
			for (tl = listTL; tl != NULL; tl = tl->TLnext)
				if ((tmp = Tsearch(tl->TLtree, fname)) != NULL)
					tmp->Tflags &= ~FNEW;
			notwanted = TRUE;
			continue;
		}
		if (Tlookup(refuseT, fname)) {
			notwanted = TRUE;
			continue;
		}
		t = Tinsert(&listT, fname, TRUE);
		t->Tmode = ts.Tmode;
		t->Tflags = ts.Tflags;
		t->Tctime = ts.Tctime;
		t->Tmtime = ts.Tmtime;
	}
	(void) fclose(f);
	return (TRUE);
}

/*******************************************
 ***    W R I T E   S C A N   F I L E    ***
 *******************************************/

static void chkscanfile(scanfile)
char *scanfile;
{
	char tname[STRINGLENGTH], fname[STRINGLENGTH];
	FILE *f;

	if (scanfile == NULL)
		scanfile = FILESCANDEF;
	(void) snprintf(fname, sizeof fname, FILESCAN, collname, scanfile);
	(void) snprintf(tname, sizeof tname, "%s.temp", fname);
	if ((f = fopen(tname, "w")) == NULL)
		goaway("Can't test scan file temp %s for %s", tname, collname);
	else {
		(void) unlink(tname);
		(void) fclose(f);
	}
}

static void makescanfile(scanfile)
	char *scanfile;
{
	char tname[STRINGLENGTH],fname[STRINGLENGTH];
	struct timeval tbuf[2];
	FILE *scanF;			/* output file for scanned file list */

	if (scanfile == NULL)
		scanfile = FILESCANDEF;
	(void) snprintf(fname, sizeof fname, FILESCAN, collname, scanfile);
	(void) snprintf(tname, sizeof tname, "%s.temp", fname);
	scanF = fopen(tname, "w");
	if (scanF == NULL)
		goaway("Can't write scan file temp %s for %s", tname, collname);
	fprintf(scanF, "V%d\n", SCANVERSION);
	(void) Tprocess(listT, recordone, scanF);
	(void) fclose(scanF);
	if (rename(tname, fname) < 0)
		goaway("Can't change %s to %s", tname, fname);
	(void) unlink(tname);
	tbuf[0].tv_sec = time(NULL);
	tbuf[0].tv_usec = 0;
	tbuf[1].tv_sec = scantime;
	tbuf[1].tv_usec = 0;
	(void) utimes(fname, tbuf);
}

static int
recordone(t,v)
	TREE *t;
	void *v;
{
	FILE *scanF = v;
	char fname[MAXPATHLEN*4+1];

	if (t->Tflags&FBACKUP)
		fprintf(scanF, "B");
	if (t->Tflags&FNOACCT)
		fprintf(scanF, "N");
	strnvis(fname, t->Tname, sizeof fname, VIS_WHITE);
	fprintf(scanF, "%o %d %d %s\n", t->Tmode, t->Tctime, t->Tmtime, fname);
	(void) Tprocess(t->Texec, recordexec, scanF);
	return (SCMOK);
}

static int
recordexec(t,v)
	TREE *t;
	void *v;
{
	FILE *scanF = v;
	char fname[MAXPATHLEN*4+1];

	strlcpy(fname, t->Tname, sizeof fname);
	fprintf(scanF, "X%s\n", fname);
	return (SCMOK);
}

void
cdprefix(prefix)
	char *prefix;
{
	static char *curprefix = NULL;

	if (curprefix == NULL) {
		if (prefix == NULL)
			return;
		(void) chdir(prefix);
		curprefix = prefix;
		return;
	}
	if (prefix == NULL) {
		(void) chdir(basedir);
		curprefix = NULL;
		return;
	}
	if (prefix == curprefix)
		return;
	if (strcmp (prefix, curprefix) == 0) {
		curprefix = prefix;
		return;
	}
	(void) chdir(basedir);
	(void) chdir(prefix);
	curprefix = prefix;
}
@


1.16
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.c,v 1.15 2003/07/10 00:06:51 david Exp $	*/
@


1.15
log
@add missing includes
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.c,v 1.14 2003/04/30 21:34:47 vincent Exp $	*/
d305 1
a305 3
			q = strchr(p, '\n');
			if (q)
				*q = '\0';
d351 1
a351 3
			q = strchr(p,'\n');
			if (q)
				*q = '\0';
d478 1
a478 2
		if ((q = strchr(p, '\n')) != NULL)
			*q = '\0';
d867 3
a869 2
	if ((q = strchr(p,'\n')) != NULL)
		*q = '\0';
d886 1
a886 3
		q = strchr(p, '\n');
		if (q)
			*q = '\0';
@


1.14
log
@strvis -> strnvis

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.c,v 1.13 2002/02/16 21:27:54 millert Exp $	*/
d88 1
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.c,v 1.12 2001/05/04 22:16:16 millert Exp $	*/
d1009 1
a1009 1
	strvis(fname, t->Tname, VIS_WHITE);
@


1.12
log
@o kill register
o lots of KNF
o passes -Wall
o fix some [ug]id_t vs. int issues
o use strlcpy/strlcat in favor of strncpy/strncat
o use mem* routines everywhere instead of old b* ones
o marked several questionable things for later fixing
o kill ci.c and cvt.c -- we don't use them
o kill read_line.c since it requires fgetln() (bad for portability)
o kill salloc.c since it is the same as strup()
o Replaced some #ifdef __OpenBSD__ with better tests
o remaining problems: malloc return values are rarely checked, select misuse
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.c,v 1.11 2001/04/29 22:23:13 millert Exp $	*/
d179 19
a197 19
static void passdelim __P((char **, int ));
static char *parserelease __P((TREELIST **, char *, char *));
static int scanone __P((TREE *, void *));
static void makescan __P((char *, char *));
static void getscan __P((char *, char *));
static void doscan __P((char *));
static void readlistfile __P((char *));
static void expTinsert __P((char *, TREE **, int, char *));
static int listone __P((TREE *, void *));
static void listentry __P((char *, char *, char *, int));
static void listname __P((char *, struct stat *));
static void listdir __P((char *, int));
static int omitanyone __P((TREE *, void *));
static int anyglob __P((char *, char *));
static int getscanfile __P((char *));
static void chkscanfile __P((char *));
static void makescanfile __P((char *));
static int recordone __P((TREE *, void *));
static int recordexec __P((TREE *, void *));
@


1.11
log
@speling
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.c,v 1.10 2001/04/29 21:52:15 millert Exp $	*/
d205 2
a206 2
passdelim (ptr,delim)		/* skip over delimiter */
char **ptr,delim;
d208 1
d216 8
a223 8
static
char *parserelease(tlp,relname,args)
TREELIST **tlp;
char *relname,*args;
{
	register TREELIST *tl;
	register char *arg;
	register OPTION option;
d227 1
a227 1
	tl = (TREELIST *) malloc (sizeof(TREELIST));
d229 1
a229 1
		goaway ("Couldn't allocate TREELIST");
d231 1
a231 1
	tl->TLname = salloc (relname);
d237 2
a238 2
	args = skipover (args," \t");
	while (*(arg=nxtarg(&args," \t="))) {
d240 1
a240 1
			if (strcmp (arg,options[opno]) == 0)
d243 2
a244 2
			goaway ("Invalid release option %s for release %s",
				arg,relname);
d248 3
a250 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			nextrel = salloc (arg);
d253 3
a255 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			tl->TLprefix = salloc (arg);
d258 3
a260 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			tl->TLlist = salloc (arg);
d263 3
a265 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			tl->TLscan = salloc (arg);
d268 3
a270 3
			passdelim (&args,'=');
			arg = nxtarg (&args," \t");
			tl->TLhost = salloc (arg);
d279 1
a279 1
char *release;
d288 1
a288 1
		release = salloc (DEFRELEASE);
d291 2
a292 2
	(void) snprintf (buf,sizeof buf,FILERELEASES,collname);
	f = fopen (buf,"r");
d296 1
a296 1
			p = fgets (buf,sizeof(buf),f);
d300 1
a300 1
				rewind (f);
d304 4
a307 5
			q = strchr (p,'\n');
			if (q)  *q = 0;
			if (strchr ("#;:",*p))  continue;
			q = nxtarg (&p," \t");
			if (strcmp (q,release) != 0)
d309 4
a312 1
			release = parserelease (&tl,release,p);
d315 1
a315 1
			else if (chdir (tl->TLprefix) < 0)
d318 1
a318 1
				(void) chdir (basedir);
d325 1
a325 1
		(void) fclose (f);
d329 1
a329 1
	if (strcmp (release,DEFRELEASE) != 0)
d331 1
a331 1
	(void) parserelease (&tl,release,"");
d339 1
a339 1
makescanlists ()
d348 2
a349 2
	(void) snprintf (buf,sizeof buf,FILERELEASES,collname);
	f = fopen (buf,"r");
d351 8
a358 6
		while ((p = fgets (buf,sizeof(buf),f)) != NULL) {
			q = strchr (p,'\n');
			if (q)  *q = 0;
			if (strchr ("#;:",*p))  continue;
			q = nxtarg (&p," \t");
			(void) parserelease (&tl,q,p);
d362 3
a364 3
				if (chdir (prefix) < 0)
					goaway ("Can't chdir to %s",prefix);
				(void) chdir (basedir);
d366 2
a367 2
			makescan (tl->TLlist,tl->TLscan);
			free ((char *)tl);
d370 1
a370 1
		(void) fclose (f);
d373 1
a373 1
		makescan ((char *)NULL,(char *)NULL);
d377 3
a379 3
scanone (t, v)
register TREE *t;
void *v;
d381 1
a381 1
	register TREE *newt;
d385 1
a385 1
	newt = Tinsert (&listT,t->Tname,FALSE);
d395 1
a395 1
getscanlists ()
d403 1
a403 1
		getscan (tl->TLlist,tl->TLscan);
d411 1
a411 1
		(void) Tprocess (tl->TLtree, scanone, NULL);
d415 2
a416 2
makescan (listfile,scanfile)
char *listfile,*scanfile;
d419 4
a422 4
	chkscanfile (scanfile);		/* can we can write a scan file? */
	doscan (listfile);		/* read list file and scan disk */
	makescanfile (scanfile);	/* record names in scan file */
	Tfree (&listT);			/* free file list tree */
d426 2
a427 2
getscan (listfile,scanfile)
char *listfile,*scanfile;
d431 2
a432 2
		scantime = time ((time_t *)NULL);
		doscan (listfile);	/* read list file and scan disk */
d451 11
a461 11
	(void) snprintf (buf,sizeof buf,FILELIST,collname,listfile);
	readlistfile (buf);		/* get contents of list file */
	(void) Tprocess (upgT,listone, NULL); /* build list of files specified */
	cdprefix ((char *)NULL);
	Tfree (&upgT);
	Tfree (&flagsT);
	Tfree (&omitT);
	Tfree (&omanyT);
	Tfree (&execT);
	Tfree (&symT);
	Tfree (&rsymT);
d465 2
a466 2
readlistfile (fname)
char *fname;
d468 6
a473 6
	char buf[STRINGLENGTH+MAXPATHLEN*4+1],*p;
	register char *q,*r;
	register FILE *f;
	register int ltn,n,i,flags;
	register TREE **t = NULL;
	register LISTTYPE lt;
d476 14
a489 9
	f = fopen (fname,"r");
	if (f == NULL)  goaway ("Can't read list file %s",fname);
	cdprefix (prefix);
	while ((p = fgets (buf,sizeof(buf),f)) != NULL) {
		if ((q = strchr (p,'\n')) != NULL)  *q = '\0';
		if (strchr ("#;:",*p))  continue;
		q = nxtarg (&p," \t");
		if (*q == '\0') continue;
		for (ltn = 0; ltname[ltn] && strcmp(q,ltname[ltn]) != 0; ltn++);
d491 1
a491 1
			goaway ("Invalid list file keyword %s",q);
d523 3
a525 3
			while (*(q=nxtarg(&p," \t"))) {
				cdprefix ((char *)NULL);
				n = expand (q,speclist,SPECNUMBER);
d527 3
a529 3
					readlistfile (speclist[i]);
					cdprefix ((char *)NULL);
					free (speclist[i]);
d531 1
a531 1
				cdprefix (prefix);
d535 1
a535 1
			r = p = q = skipover (p," \t");
d537 2
a538 2
				q = p = skipto (p," \t(");
				p = skipover (p," \t");
d543 1
a543 1
					q = nxtarg (&p," \t)");
d547 1
a547 1
						expTinsert (q,&execT,0,r);
d553 1
a553 1
			goaway ("Error in handling list file keyword %d",ltn);
d555 1
a555 1
		while (*(q=nxtarg(&p," \t"))) {
d557 1
a557 1
				(void) Tinsert (t,q,FALSE);
d559 1
a559 1
				expTinsert (q,t,flags,(char *)NULL);
d562 1
a562 1
	(void) fclose (f);
d566 5
a570 5
expTinsert (p,t,flags,exec)
char *p;
TREE **t;
int flags;
char *exec;
d572 2
a573 2
	register int n, i;
	register TREE *newt;
d577 1
a577 1
	n = expand (p,speclist,SPECNUMBER);
d579 1
a579 1
		newt = Tinsert (t,speclist[i],TRUE);
d582 2
a583 2
			(void) snprintf (buf,sizeof buf,exec,speclist[i]);
			(void) Tinsert (&newt->Texec,buf,FALSE);
d585 1
a585 1
		free (speclist[i]);
d591 2
a592 2
TREE *t;
void *v;
d594 2
a595 1
	listentry(t->Tname,t->Tname,(char *)NULL,(t->Tflags&FALWAYS) != 0);
d600 3
a602 3
listentry(name,fullname,updir,always)
register char *name, *fullname, *updir;
int always;
d607 2
a608 1
	if (Tlookup (refuseT,fullname))  return;
d610 3
a612 2
		if (Tsearch (omitT,fullname))  return;
		if (Tprocess (omanyT,omitanyone,fullname) != SCMOK)
d615 1
a615 1
	if (lstat(name,&statbuf) < 0)
d618 2
a619 2
		if (Tsearch (symT,fullname)) {
			listname (fullname,&statbuf);
d622 2
a623 2
		if (Tlookup (rsymT,fullname)) {
			listname (fullname,&statbuf);
d626 4
a629 2
		if (updir) link++;
		if (stat(name,&statbuf) < 0) return;
d632 5
a636 3
		if (access(name,R_OK|X_OK) < 0) return;
		if (chdir(name) < 0) return;
		listname (fullname,&statbuf);
d638 2
a639 2
			printf ("Scanning directory %s\n",fullname);
			(void) fflush (stdout);
d641 1
a641 1
		listdir (fullname,always);
d643 5
a647 3
			(void) chdir (basedir);
			if (prefix) (void) chdir (prefix);
			if (updir && *updir) (void) chdir (updir);
d649 1
a649 1
			(void) chdir ("..");
d652 2
a653 1
	if (access(name,R_OK) < 0) return;
d658 1
d661 1
a661 1
                        snprintf(rcs_release,sizeof rcs_release,
d664 1
a664 1
                        snprintf(rcs_release,sizeof rcs_release,
d670 3
a672 1
                snprintf(sys_com, sizeof sys_com, "cvs -d %s -r -l -Q co -p %s %s > %s\n", cvs_root, rcs_release, name, rcs_file);
d676 2
a677 1
                if (status != 0) return;
d680 1
a680 1
	listname (fullname,&statbuf);
d684 7
a690 7
listname (name,st)
register char *name;
register struct stat *st;
{
	register TREE *t,*ts;
	register int new;
	register TREELIST *tl;
d695 1
a695 1
			if ((ts = Tsearch (tl->TLtree,name)) != NULL)
d699 3
a701 2
	t = Tinsert (&listT,name,FALSE);
	if (t == NULL)  return;
d705 3
a707 2
	if (new)  t->Tflags |= FNEW;
	if ((ts = Tsearch (flagsT,name)) != NULL)
d709 1
a709 1
	if ((ts = Tsearch (execT,name)) != NULL) {
d716 3
a718 3
listdir (name,always)		/* expand directory */
char *name;
int always;
d725 8
a732 7
	register DIR *dirp;
	char ename[STRINGLENGTH],newname[STRINGLENGTH],filename[STRINGLENGTH];
	register char *p,*newp;
	register int i;

	dirp = opendir (".");
	if (dirp == 0) return;	/* unreadable: probably protected */
d738 2
a739 1
		while (*p == '/') p++;
d741 2
a742 1
	while ((*newp++ = *p++) != '\0') ;	/* copy string */
d744 2
a745 1
	while (newp > newname && newp[-1] == '/') --newp; /* trailing / */
d747 2
a748 1
	if (strcmp (newname,".") == 0) newname[0] = 0;	/* "." ==> "" */
d751 4
a754 4
		if (dentry->d_ino == 0) continue;
		if (strcmp(dentry->d_name,".") == 0) continue;
		if (strcmp(dentry->d_name,"..") == 0) continue;
		for (i=0; i<=MAXNAMLEN && dentry->d_name[i]; i++)
d758 5
a762 6
			(void) snprintf (filename,sizeof filename,"%s/%s",newname,ename);
		else {
			(void) strncpy (filename,ename,sizeof filename-1);
			filename[sizeof filename-1] = '\0';
		}
		listentry(ename,filename,newname,always);
d764 1
a764 1
	closedir (dirp);
d768 3
a770 3
omitanyone (t,fv)
TREE *t;
void *fv;
d773 2
a774 1
	if (anyglob (t->Tname,filename))
d780 2
a781 2
anyglob (pattern,match)
char *pattern,*match;
d783 2
a784 2
	register char *p,*m;
	register char *pb,*pe;
d801 1
a801 1
			if (anyglob (p,++m))
d805 1
a805 1
		return (anyglob (p,++m));
d817 1
a817 1
					return (anyglob (p,++m));
d826 1
a826 1
					return (anyglob (p,++m));
d832 1
a832 1
					return (anyglob (p,++m));
d847 2
a848 2
int getscanfile (scanfile)
char *scanfile;
d853 1
a853 1
	register FILE *f;
d855 4
a858 4
	register char *p,*q;
	register TREE *tmp, *t = NULL;
	register notwanted;
	register TREELIST *tl;
d862 2
a863 2
	(void) snprintf (buf,sizeof buf,FILESCAN,collname,scanfile);
	if (stat(buf,&sbuf) < 0)
d865 1
a865 1
	if ((f = fopen (buf,"r")) == NULL)
d867 2
a868 2
	if ((p = fgets (buf,sizeof(buf),f)) == NULL) {
		(void) fclose (f);
d871 2
a872 1
	if ((q = strchr (p,'\n')) != NULL)  *q = '\0';
d874 1
a874 1
		(void) fclose (f);
d878 1
a878 1
		(void) fclose (f);
d884 1
a884 1
		(void) fclose (f);
d888 4
a891 3
	while ((p = fgets (buf,sizeof(buf),f)) != NULL) {
		q = strchr (p,'\n');
		if (q)  *q = 0;
d894 2
a895 1
			if (notwanted)  continue;
d897 2
a898 2
				goaway ("scanfile format inconsistent");
			(void) Tinsert (&t->Texec,++p,FALSE);
d910 2
a911 2
		if ((q = strchr (p,' ')) == NULL)
			goaway ("scanfile format inconsistent");
d913 1
a913 1
		ts.Tmode = atoo (p);
d915 2
a916 2
		if ((q = strchr (p,' ')) == NULL)
			goaway ("scanfile format inconsistent");
d918 1
a918 1
		ts.Tctime = atoi (p);
d920 2
a921 2
		if ((q = strchr (p,' ')) == NULL)
			goaway ("scanfile format inconsistent");
d923 1
a923 1
		ts.Tmtime = atoi (p);
d929 1
a929 1
				if ((tmp = Tsearch (tl->TLtree,fname)) != NULL)
d934 1
a934 1
		if (Tlookup (refuseT,fname)) {
d938 1
a938 1
		t = Tinsert (&listT,fname,TRUE);
d944 1
a944 1
	(void) fclose (f);
d952 1
a952 1
static void chkscanfile (scanfile)
d960 4
a963 4
	(void) snprintf (fname,sizeof fname,FILESCAN,collname,scanfile);
	(void) snprintf (tname,sizeof tname,"%s.temp",fname);
	if (NULL == (f = fopen (tname, "w")))
		goaway ("Can't test scan file temp %s for %s",tname,collname);
d965 2
a966 2
		(void) unlink (tname);
		(void) fclose (f);
d970 2
a971 2
static void makescanfile (scanfile)
char *scanfile;
d979 3
a981 3
	(void) snprintf (fname,sizeof fname,FILESCAN,collname,scanfile);
	(void) snprintf (tname,sizeof tname,"%s.temp",fname);
	scanF = fopen (tname,"w");
d983 12
a994 10
		goaway ("Can't write scan file temp %s for %s",tname,collname);
	fprintf (scanF,"V%d\n",SCANVERSION);
	(void) Tprocess (listT,recordone,scanF);
	(void) fclose (scanF);
	if (rename (tname,fname) < 0)
		goaway ("Can't change %s to %s",tname,fname);
	(void) unlink (tname);
	tbuf[0].tv_sec = time((time_t *)NULL);  tbuf[0].tv_usec = 0;
	tbuf[1].tv_sec = scantime;  tbuf[1].tv_usec = 0;
	(void) utimes (fname,tbuf);
d998 3
a1000 3
recordone (t,v)
TREE *t;
void *v;
d1005 4
a1008 2
	if (t->Tflags&FBACKUP)  fprintf (scanF,"B");
	if (t->Tflags&FNOACCT)  fprintf (scanF,"N");
d1010 2
a1011 3
	fprintf (scanF,"%o %d %d %s\n",
		t->Tmode,t->Tctime,t->Tmtime,fname);
	(void) Tprocess (t->Texec,recordexec, scanF);
d1016 3
a1018 3
recordexec (t,v)
TREE *t;
void *v;
d1022 3
a1024 3
	strncpy(fname, t->Tname, sizeof fname-1);
	fname[sizeof fname-1] = '\0';
	fprintf(scanF,"X%s\n",fname);
d1029 2
a1030 2
cdprefix (prefix)
char *prefix;
d1037 1
a1037 1
		(void) chdir (prefix);
d1042 1
a1042 1
		(void) chdir (basedir);
d1052 2
a1053 2
	(void) chdir (basedir);
	(void) chdir (prefix);
@


1.10
log
@Add a bunch of old revision history comments that we are missing to
make diffing easier.  No code changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.c,v 1.9 2001/04/29 18:16:19 millert Exp $	*/
d863 1
a863 1
				goaway ("scanfile format inconsistant");
d877 1
a877 1
			goaway ("scanfile format inconsistant");
d882 1
a882 1
			goaway ("scanfile format inconsistant");
d887 1
a887 1
			goaway ("scanfile format inconsistant");
@


1.9
log
@Use S_ISXXX macros where possible instead of doing this by hand
Noticed while diffing against NetBSD version
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.c,v 1.8 1997/09/16 11:01:16 deraadt Exp $	*/
d19 1
a19 1
 *  Software Distribution Coordinator  or  Software_Distribution@@CS.CMU.EDU
d32 4
@


1.8
log
@strcpy whacking; ci.c and expand.c need more work
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.c,v 1.7 1997/09/16 10:42:51 deraadt Exp $	*/
d600 1
a600 1
	if ((statbuf.st_mode&S_IFMT) == S_IFLNK) {
d612 1
a612 1
	if ((statbuf.st_mode&S_IFMT) == S_IFDIR) {
@


1.7
log
@snprintf this thing
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.c,v 1.6 1997/04/01 07:35:20 todd Exp $	*/
d724 4
a727 2
		else
			(void) strcpy (filename,ename);
d981 2
a982 1
	strcpy(fname, t->Tname);
@


1.6
log
@This merges in the latest NetBSD sup source.
- removed $Log: ...$ tags to not waste space in the repository
- now doesn't segfault on the alpha!

Note:
To compile sup on systems other than *BSD, you'll need a copy of
vis.c, vis.h, daemon.c, and sys/cdefs.h.  At least the first two
(for OSF/1).

From NetBSD changelog description (for credit where due):
.... 1996/12/23 19:42:05  christos
- add missing prototypes.
- fix function call inconsistencies
- fix int <-> long and pointer conversions
It should run now on 64 bit machines...

....  1996/12/31 18:08:00  christos
64 bit patches (mostly long -> time_t) from Matthew Jacob (?)
sup now works on the alpha!
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.c,v 1.5 1997/01/17 07:18:04 millert Exp $	*/
d286 1
a286 1
	(void) sprintf (buf,FILERELEASES,collname);
d341 1
a341 1
	(void) sprintf (buf,FILERELEASES,collname);
d442 1
a442 1
	(void) sprintf (buf,FILELIST,collname,listfile);
d568 1
a568 1
			(void) sprintf (buf,exec,speclist[i]);
d636 2
a637 1
                        sprintf(rcs_release, "-r %s", rcs_branch);
d639 2
a640 1
                        sprintf(rcs_release, "-r%s", rcs_branch);
d645 1
a645 1
                sprintf(sys_com, "cvs -d %s -r -l -Q co -p %s %s > %s\n", cvs_root, rcs_release, name, rcs_file);
d723 1
a723 1
			(void) sprintf (filename,"%s/%s",newname,ename);
d825 1
a825 1
	(void) sprintf (buf,FILESCAN,collname,scanfile);
d920 2
a921 2
	(void) sprintf (fname,FILESCAN,collname,scanfile);
	(void) sprintf (tname,"%s.temp",fname);
d939 2
a940 2
	(void) sprintf (fname,FILESCAN,collname,scanfile);
	(void) sprintf (tname,"%s.temp",fname);
@


1.5
log
@more r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.c,v 1.4 1996/07/31 11:11:24 niklas Exp $	*/
a31 32
 * $Log: scan.c,v $
 * Revision 1.4  1996/07/31 11:11:24  niklas
 * Better use time_t instead of long when dealing with times
 *
 * Revision 1.3  1996/06/26 05:39:46  deraadt
 * rcsid
 *
 * Revision 1.2  1996/04/17 17:24:13  dm
 * Shouldn't visually encode execute commands, only file names.
 *
 * Revision 1.1  1995/12/16 11:46:50  deraadt
 * add sup to the tree
 *
 * Revision 1.4  1995/10/29 23:54:45  christos
 * - runio fails when result != 0 not only < 0
 * - print vis-encoded file in the scanner.
 *
 * Revision 1.3  1995/06/24 16:21:42  christos
 * - Don't use system(3) to fork processes. It is a big security hole.
 * - Encode the filenames in the scan files using strvis(3), so filenames
 *   that contain newlines or other weird characters don't break the scanner.
 *
 * Revision 1.2  1994/01/03 14:47:25  brezak
 * Change <sys/dir.h> to <dirent.h>
 *
 * Revision 1.1.1.1  1993/05/21  14:52:17  cgd
 * initial import of CMU's SUP to NetBSD
 *
 * Revision 1.8  92/08/11  12:04:28  mrt
 * 	Brad's changes: delinted, added forward declarations of static
 * 	functions.Added Copyright.
 * 	[92/07/24            mrt]
d95 3
a97 1
#include "sup.h"
d175 19
a194 16
static makescan();
static getscan();
static doscan();
static readlistfile();
static expTinsert();
static listone();
static listentry();
static listname();
static listdir();
static omitanyone();
static anyglob();
static int getscanfile();
static chkscanfile();
static makescanfile();
static recordone();
static recordexec();
d200 1
a200 1
static
d272 1
d331 1
d344 1
a344 1
		while (p = fgets (buf,sizeof(buf),f)) {
d367 2
a368 2
static
scanone (t)
d370 1
d385 1
d402 1
a402 1
		(void) Tprocess (tl->TLtree,scanone);
d405 1
a405 1
static
d416 1
a416 1
static
a419 2
        struct tm *utc_time;
        
d427 1
a427 1
static
a431 1
	int listone ();
d444 1
a444 1
	(void) Tprocess (upgT,listone); /* build list of files specified */
d455 1
a455 1
static
d463 1
a463 1
	register TREE **t;
d470 2
a471 2
	while (p = fgets (buf,sizeof(buf),f)) {
		if (q = strchr (p,'\n'))  *q = '\0';
d551 1
a551 1
static
d575 2
a576 2
static
listone (t)		/* expand and add one name from upgrade list */
d578 1
d584 1
a584 1
static
a590 1
	int omitanyone ();
d653 1
a653 1
static
d665 1
a665 1
			if (ts = Tsearch (tl->TLtree,name))
d675 1
a675 1
	if (ts = Tsearch (flagsT,name))
d677 1
a677 1
	if (ts = Tsearch (execT,name)) {
d683 1
a683 1
static
d707 1
a707 1
	while (*newp++ = *p++) ;	/* copy string */
d713 1
a713 1
	while (dentry=readdir(dirp)) {
d729 2
a730 2
static
omitanyone (t,filename)
d732 1
a732 1
char **filename;
d734 2
a735 1
	if (anyglob (t->Tname,*filename))
d740 1
a740 1
static
d832 1
a832 1
	if (q = strchr (p,'\n'))  *q = '\0';
d848 1
a848 1
	while (p = fgets (buf,sizeof(buf),f)) {
d887 1
a887 1
				if (tmp = Tsearch (tl->TLtree,fname))
d910 1
a910 1
static chkscanfile (scanfile)
d928 1
a928 1
static makescanfile (scanfile)
a933 1
	int recordone ();
d953 2
a954 2
static
recordone (t,scanF)
d956 1
a956 1
FILE **scanF;
d958 1
a958 1
	int recordexec ();
d961 2
a962 2
	if (t->Tflags&FBACKUP)  fprintf (*scanF,"B");
	if (t->Tflags&FNOACCT)  fprintf (*scanF,"N");
d964 1
a964 1
	fprintf (*scanF,"%o %d %d %s\n",
d966 1
a966 1
	(void) Tprocess (t->Texec,recordexec,*scanF);
d970 2
a971 2
static
recordexec (t,scanF)
d973 1
a973 1
FILE **scanF;
d975 1
d978 1
a978 1
	fprintf(*scanF,"X%s\n",fname);
d982 1
@


1.4
log
@Better use time_t instead of long when dealing with times
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.c,v 1.3 1996/06/26 05:39:46 deraadt Exp $	*/
d33 3
d325 1
a325 1
			q = index (p,'\n');
d327 1
a327 1
			if (index ("#;:",*p))  continue;
d370 1
a370 1
			q = index (p,'\n');
d372 1
a372 1
			if (index ("#;:",*p))  continue;
d497 2
a498 2
		if (q = index (p,'\n'))  *q = '\0';
		if (index ("#;:",*p))  continue;
d857 1
a857 1
	if (q = index (p,'\n'))  *q = '\0';
d874 1
a874 1
		q = index (p,'\n');
d893 1
a893 1
		if ((q = index (p,' ')) == NULL)
d898 1
a898 1
		if ((q = index (p,' ')) == NULL)
d903 1
a903 1
		if ((q = index (p,' ')) == NULL)
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 3
d189 2
a190 2
extern long lasttime;			/* time of last upgrade */
extern long scantime;			/* time of this scan */
a198 2
extern long time();

d444 1
a444 1
		scantime = time ((long *)NULL);
d971 1
a971 1
	tbuf[0].tv_sec = time((long *)NULL);  tbuf[0].tv_usec = 0;
@


1.2
log
@Shouldn't visually encode execute commands, only file names.
@
text
@d1 2
d33 3
@


1.1
log
@add sup to the tree
@
text
@d31 3
d993 1
a993 1
	strvis(fname, t->Tname, VIS_WHITE);
@
