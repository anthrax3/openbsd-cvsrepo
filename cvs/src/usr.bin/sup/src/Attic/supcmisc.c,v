head	1.17;
access;
symbols
	OPENBSD_4_8:1.16.0.14
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.10
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.12
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.16
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.14
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.12
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.16
	OPENBSD_2_8:1.6.0.14
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.12
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.17
date	2010.10.18.20.54.00;	author deraadt;	state dead;
branches;
next	1.16;

1.16
date	2007.05.17.11.00.37;	author moritz;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.15.07.21.09;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.30.01.59.47;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.19.19.39.39;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.07.02.08.02;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.05.15.56.04;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.04.22.16.16;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.02.22.56.53;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.29.21.52.16;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.16.11.01.21;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.09.16.10.42.55;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.04.01.07.35.35;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	96.07.31.11.11.29;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.39.52;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.16.11.46.57;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@sup is no longer used. reminded by pirofti and jmc
@
text
@/*	$OpenBSD: supcmisc.c,v 1.16 2007/05/17 11:00:37 moritz Exp $	*/

/*
 * Copyright (c) 1992 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*
 * sup misc. routines, include list processing.
 **********************************************************************
 * HISTORY
 * Revision 1.5  92/08/11  12:07:22  mrt
 * 	Added release to FILEWHEN name.
 * 	Brad's changes: delinted and updated variable argument usage.
 * 	[92/07/26            mrt]
 * 
 * Revision 1.3  89/08/15  15:31:28  bww
 * 	Updated to use v*printf() in place of _doprnt().
 * 	From "[89/04/19            mja]" at CMU.
 * 	[89/08/15            bww]
 * 
 * 27-Dec-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Fixed bug in ugconvert() which left pw uninitialized.
 *
 * 25-May-87  Doug Philips (dwp) at Carnegie-Mellon University
 *	Split off from sup.c and changed goaway to use printf
 *	instead of notify if thisC is NULL.
 *
 **********************************************************************
 */

#include "supcdefs.h"
#include "supextern.h"
#include <limits.h>

#ifndef UID_MAX
#define UID_MAX	((uid_t)-1)
#endif

struct liststruct {		/* uid and gid lists */
	char *Lname;		/* name */
	int Lnumber;		/* uid or gid */
	struct liststruct *Lnext;
};
typedef struct liststruct LIST;

#define HASHBITS	4
#define HASHSIZE	(1<<HASHBITS)
#define HASHMASK	(HASHSIZE-1)
#define LISTSIZE	(HASHSIZE*HASHSIZE)

static LIST *uidL[LISTSIZE];		/* uid and gid lists */
static LIST *gidL[LISTSIZE];

extern COLLECTION *thisC;		/* collection list pointer */

static int Lhash(char *);
static void Linsert(LIST **, char *, int);
static LIST *Llookup(LIST **, char *);

/*************************************************
 ***    P R I N T   U P D A T E   T I M E S    ***
 *************************************************/

void
prtime()
{
	char buf[STRINGLENGTH];
	char relsufix[STRINGLENGTH];
	time_t twhen;

	if ((thisC->Cflags&CFURELSUF) && thisC->Crelease)
		(void) snprintf(relsufix, sizeof relsufix, ".%s",
		    thisC->Crelease);
	else
		relsufix[0] = '\0';
	if (chdir(thisC->Cbase) < 0)
		logerr("Can't change to base directory %s for collection %s",
		    thisC->Cbase, thisC->Cname);
	twhen = getwhen(thisC->Cname, relsufix);
	(void) strlcpy(buf, ctime(&twhen), sizeof buf);
	buf[strlen(buf)-1] = '\0';	/* strip newline */
	loginfo("Last update occurred at %s for collection %s%s",
	    buf, thisC->Cname, relsufix);
}

int
establishdir(fname)
	char *fname;
{
	char dpart[STRINGLENGTH], fpart[STRINGLENGTH];

	path(fname, dpart, sizeof dpart, fpart, sizeof fpart);
	return (estabd(fname, dpart));
}

int
makedir(fname, mode, statp)
	char *fname;
	int mode;
	struct stat *statp;
{
	if (lstat(fname, statp) != -1 && !S_ISDIR(statp->st_mode)) {
		if (unlink(fname) == -1) {
			notify("SUP: Can't delete %s\n", fname);
			return (-1);
		}
	}

	(void) mkdir(fname, 0755);

	return (stat(fname, statp));
}

int
estabd(fname, dname)
	char *fname, *dname;
{
	char dpart[STRINGLENGTH], fpart[STRINGLENGTH];
	struct stat sbuf;
	int x;

	if (stat(dname, &sbuf) >= 0)
		return (FALSE); /* exists */
	path(dname, dpart, sizeof dpart, fpart, sizeof fpart);
	if (strcmp(fpart,".") == 0) {		/* dname is / or . */
		notify("SUP: Can't create directory %s for %s\n", dname, fname);
		return (TRUE);
	}
	x = estabd(fname, dpart);
	if (x)
		return (TRUE);
	if (makedir(dname, 0755, &sbuf) < 0) {
		vnotify("SUP: Can't create directory %s for %s\n",
		    dname, fname);
		return TRUE;
	}
	vnotify("SUP Created directory %s for %s\n", dname, fname);
	return (FALSE);
}

/***************************************
 ***    L I S T   R O U T I N E S    ***
 ***************************************/

/*
 * Hash function is:  HASHSIZE * (strlen mod HASHSIZE)
 *		      +          (char   mod HASHSIZE)
 * where "char" is last character of name (if name is non-null).
 */
static int
Lhash(name)
	char *name;
{
	int len;
	char c;

	len = strlen(name);
	if (len > 0)
		c = name[len-1];
	else
		c = 0;
	return (((len&HASHMASK)<<HASHBITS)|(((int)c)&HASHMASK));
}

static void
Linsert(table, name, number)
	LIST **table;
	char *name;
	int number;
{
	LIST *l;
	int lno;
	lno = Lhash(name);
	l = (LIST *) malloc(sizeof(LIST));
	l->Lname = name;
	l->Lnumber = number;
	l->Lnext = table[lno];
	table[lno] = l;
}

static LIST *
Llookup(table, name)
	LIST **table;
	char *name;
{
	int lno;
	LIST *l;

	lno = Lhash(name);
	for (l = table[lno]; l && strcmp(l->Lname,name) != 0; l = l->Lnext)
		;
	return (l);
}

void
ugconvert(uname, gname, uid, gid, mode)
	char *uname, *gname;
	uid_t *uid;
	gid_t *gid;
	int *mode;
{
	LIST *u, *g;
	struct passwd *pw;
	struct group *gr;
	struct stat sbuf;
	static uid_t defuid = UID_MAX;
	static gid_t defgid;
	static int first = TRUE;

	if (first) {
		memset(uidL, 0, sizeof(uidL));
		memset(gidL, 0, sizeof(gidL));
		first = FALSE;
	}
	pw = NULL;
	if ((u = Llookup(uidL, uname)) != NULL)
		*uid = (uid_t) u->Lnumber;
	else if ((pw = getpwnam(uname)) != NULL) {
		Linsert(uidL, strdup(uname), pw->pw_uid);
		*uid = pw->pw_uid;
	}
	if (u || pw) {
		if ((g = Llookup(gidL, gname)) != NULL) {
			*gid = (gid_t) g->Lnumber;
			return;
		}
		if ((gr = getgrnam(gname)) != NULL) {
			Linsert(gidL, strdup(gname), gr->gr_gid);
			*gid = gr->gr_gid;
			return;
		}
		if (pw == NULL && (pw = getpwnam(uname)) == NULL)
			goto defids;
		*mode &= ~S_ISGID;
		*gid = pw->pw_gid;
		return;
	}
defids:
	*mode &= ~(S_ISUID|S_ISGID);
	if (defuid != UID_MAX) {
		*uid = defuid;
		*gid = defgid;
		return;
	}
	if (stat(".", &sbuf) < 0) {
		*uid = defuid = getuid();
		*gid = defgid = getgid();
		return;
	}
	*uid = defuid = sbuf.st_uid;
	*gid = defgid = sbuf.st_gid;
}


/*********************************************
 ***    U T I L I T Y   R O U T I N E S    ***
 *********************************************/

void
notify (char *fmt,...)		/* record error message */
{
	char buf[STRINGLENGTH];
	char collrelname[STRINGLENGTH];
	time_t tloc;
	static FILE *noteF = NULL;	/* mail program on pipe */
	va_list ap;

	va_start(ap, fmt);
	if (fmt == NULL) {
		if (noteF && noteF != stdout)
			(void) pclose(noteF);
		noteF = NULL;
		return;
	}
	if ((thisC->Cflags&CFURELSUF) && thisC->Crelease) 
		(void) snprintf(collrelname, sizeof collrelname, "%s-%s",
		    collname, thisC->Crelease);
	else
		(void) strlcpy(collrelname, collname, sizeof collrelname);
	
	if (noteF == NULL) {
		/* XXX - it would be nicer to run sendmail directly (millert) */
		if ((thisC->Cflags&CFMAIL) && thisC->Cnotify) {
			(void) snprintf(buf, sizeof buf,
				"mail -s \"SUP Upgrade of %s\" %s >/dev/null",
				collrelname, thisC->Cnotify);
			noteF = popen(buf, "w");
			if (noteF == NULL) {
				logerr ("Can't send mail to %s for %s",
					thisC->Cnotify, collrelname);
				noteF = stdout;
			}
		} else
			noteF = stdout;
		tloc = time(NULL);
		fprintf(noteF, "SUP Upgrade of %s at %s", collrelname,
		    ctime(&tloc));
		(void) fflush(noteF);
	}
	vfprintf(noteF, fmt, ap);
	va_end(ap);
	(void) fflush(noteF);
}

void
lockout(on)		/* lock out interrupts */
	int on;
{
	static sigset_t oset;
	sigset_t nset;

	if (on) {
		sigemptyset(&nset);
		sigaddset(&nset, SIGHUP);
		sigaddset(&nset, SIGINT);
		sigaddset(&nset, SIGTERM);
		sigaddset(&nset, SIGQUIT);
		(void) sigprocmask(SIG_BLOCK, &nset, &oset);
	} else {
		(void) sigprocmask(SIG_SETMASK, &oset, NULL);
	}
}

char *
fmttime(time)
	time_t time;
{
	static char buf[16];
	char *p;

	/*
	 * Copy ctime to buf, stripping day of week, year, and newline.
	 * E.g.: "Thu Nov 24 18:22:48 1986\n" -> "Nov 24 18:22:48"
	 */
	p = ctime(&time) + 4;
	(void) strlcpy(buf, p, sizeof(buf));
	return (buf);
}
@


1.16
log
@Check getpwnam() return value for NULL before dereferencing it.

ok ray@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.15 2003/04/15 07:21:09 deraadt Exp $	*/
@


1.15
log
@a bit of string cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.14 2002/04/30 01:59:47 deraadt Exp $	*/
d252 2
a253 2
		if (pw == NULL)
			pw = getpwnam(uname);
d258 1
@


1.14
log
@arguement -> argument
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.13 2002/02/19 19:39:39 millert Exp $	*/
d112 1
a112 1
	path(fname, dpart, fpart, sizeof fpart);
d144 1
a144 1
	path(dname, dpart, fpart, sizeof fpart);
@


1.13
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.12 2002/02/16 21:27:54 millert Exp $	*/
d33 1
a33 1
 * 	Brad's changes: delinted and updated variable arguement usage.
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.11 2001/05/07 02:08:02 millert Exp $	*/
a278 1
#ifdef __STDC__
a279 5
#else
/*VARARGS*//*ARGSUSED*/
notify (va_alist)		/* record error message */
va_dcl
#endif
a286 1
#ifdef __STDC__
a287 6
#else
	char *fmt;

	va_start(ap);
	fmt = va_arg(ap, char *);
#endif
@


1.11
log
@Use a smaller buffer in fmttime() since the date string is of a
known fixed size.
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.10 2001/05/05 15:56:04 millert Exp $	*/
d76 3
a78 3
static int Lhash __P((char *));
static void Linsert __P((LIST **, char *, int));
static LIST *Llookup __P((LIST **, char *));
@


1.10
log
@Fix Makefile.sunos5.gcc so that it builds sup correctly on Solaris 8
Fix some -Wall found on Solaris
Fix some uid_t/gid_t stuff I missed before
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.9 2001/05/04 22:16:16 millert Exp $	*/
d356 2
a357 1
char *fmttime(time)
d360 1
a360 1
	static char buf[STRINGLENGTH];
d368 1
a368 1
	(void) strlcpy(buf, p, strlen(p) - 5);
@


1.9
log
@o kill register
o lots of KNF
o passes -Wall
o fix some [ug]id_t vs. int issues
o use strlcpy/strlcat in favor of strncpy/strncat
o use mem* routines everywhere instead of old b* ones
o marked several questionable things for later fixing
o kill ci.c and cvt.c -- we don't use them
o kill read_line.c since it requires fgetln() (bad for portability)
o kill salloc.c since it is the same as strup()
o Replaced some #ifdef __OpenBSD__ with better tests
o remaining problems: malloc return values are rarely checked, select misuse
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.8 2001/05/02 22:56:53 millert Exp $	*/
d218 3
a220 1
	int *uid, *gid, *mode;
d237 1
a237 1
		*uid = u->Lnumber;
d244 1
a244 1
			*gid = g->Lnumber;
@


1.8
log
@Sync with NetBSD.  Notable changes:
 o Add libwrap support to supfilesrv, conditioned by #ifdef LIBWRAP
   (on by default). <bouyer@@netbsd.org>
 o Renamed '-l' (the 'live' mode) to '-d' and '-l' is now used to
   enable logging of successfull connections. <bouyer@@netbsd.org>
 o Don't botch varargs: the are not always an array of void * in the stack...
   Write a separate function to convert a list of function parameters to
   explain why execv failed. <christos@@netbsd.org>
 o When in compress mode, don't overwrite the destination file directly,
   write a temp file and use rename when it is done. (From James Mathiesen
   <james@@deshaw.com>)
 o Rename errno variable to error to avoid collision with errno.h and remove
   explicit extern of errno (we get it from errno.h) <mycroft@@netbsd.org>
 o Cleanup unsigned char vs. char
 o Add -u flag, that prevents sup from attempting to restore a and m times
   on the received files.
 o Replace the provided read_line function with calls to the fparseln function
   in libutil.  Maintain compatibility on machines without fparseln through
   the NEED_READ_LINE define.
 o Rename login() to suplogin() to avoid name collition in util.h
 o If rmdir() fails, chmod the path to have r/w/x perms and run "rm -rf"
 o avoid last.temp filename collision by using rel-suffix
 o When creating directories, make sure you remove previous non-directories
   before doing so, otherwise sup fails.
 o Add -q flag to supscan for quiet operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.7 2001/04/29 21:52:16 millert Exp $	*/
d53 5
d85 1
a85 1
prtime ()
d92 2
a93 1
		(void) snprintf (relsufix,sizeof relsufix,".%s",thisC->Crelease);
d96 8
a103 9
	if (chdir (thisC->Cbase) < 0)
		logerr ("Can't change to base directory %s for collection %s",
			thisC->Cbase,thisC->Cname);
	twhen = getwhen(thisC->Cname,relsufix);
	buf[0] = '\0';
	(void) strncat (buf,ctime (&twhen), sizeof buf-1);
	buf[strlen(buf)-1] = '\0';
	loginfo ("Last update occurred at %s for collection %s%s",
		buf,thisC->Cname,relsufix);
d106 3
a108 2
int establishdir (fname)
char *fname;
d110 4
a113 3
	char dpart[STRINGLENGTH],fpart[STRINGLENGTH];
	path (fname,dpart,fpart,sizeof fpart);
	return (estabd (fname,dpart));
d116 5
a120 4
int makedir(fname, mode, statp)
char *fname;
int mode;
struct stat *statp;
d124 2
a125 2
			notify ("SUP: Can't delete %s\n", fname);
			return -1;
d129 1
a129 1
	(void) mkdir (fname, 0755);
d131 1
a131 1
	return stat (fname, statp);
d134 3
a136 2
int estabd (fname,dname)
char *fname,*dname;
d138 1
a138 1
	char dpart[STRINGLENGTH],fpart[STRINGLENGTH];
d140 1
a140 1
	register int x;
d142 5
a146 4
	if (stat (dname,&sbuf) >= 0)  return (FALSE); /* exists */
	path (dname,dpart,fpart,sizeof fpart);
	if (strcmp (fpart,".") == 0) {		/* dname is / or . */
		notify ("SUP: Can't create directory %s for %s\n",dname,fname);
d149 3
a151 2
	x = estabd (fname,dpart);
	if (x)  return (TRUE);
d153 2
a154 1
		vnotify ("SUP: Can't create directory %s for %s\n",dname,fname);
d157 1
a157 1
	vnotify ("SUP Created directory %s for %s\n",dname,fname);
d165 11
a175 8
static
int Lhash (name)
char *name;
{
	/* Hash function is:  HASHSIZE * (strlen mod HASHSIZE)
	 *		      +          (char   mod HASHSIZE)
	 * where "char" is last character of name (if name is non-null).
	 */
d177 5
a181 6
	register int len;
	register char c;

	len = strlen (name);
	if (len > 0)	c = name[len-1];
	else		c = 0;
d186 9
a194 9
Linsert (table,name,number)
LIST **table;
char *name;
int number;
{
	register LIST *l;
	register int lno;
	lno = Lhash (name);
	l = (LIST *) malloc (sizeof(LIST));
d201 11
a211 9
static
LIST *Llookup (table,name)
LIST **table;
char *name;
{
	register int lno;
	register LIST *l;
	lno = Lhash (name);
	for (l = table[lno]; l && strcmp(l->Lname,name) != 0; l = l->Lnext);
d215 8
a222 7
void ugconvert (uname,gname,uid,gid,mode)
char *uname,*gname;
int *uid,*gid,*mode;
{
	register LIST *u,*g;
	register struct passwd *pw;
	register struct group *gr;
d224 2
a225 2
	static int defuid = -1;
	static int defgid;
d229 2
a230 2
		bzero ((char *)uidL, sizeof (uidL));
		bzero ((char *)gidL, sizeof (gidL));
d234 1
a234 1
	if ((u = Llookup (uidL,uname)) != NULL)
d236 2
a237 2
	else if ((pw = getpwnam (uname)) != NULL) {
		Linsert (uidL,salloc(uname),pw->pw_uid);
d241 1
a241 1
		if ((g = Llookup (gidL,gname)) != NULL) {
d245 2
a246 2
		if ((gr = getgrnam (gname)) != NULL) {
			Linsert (gidL,salloc(gname),gr->gr_gid);
d251 1
a251 1
			pw = getpwnam (uname);
d257 1
a257 1
	if (defuid >= 0) {
d262 3
a264 3
	if (stat (".",&sbuf) < 0) {
		*uid = defuid = getuid ();
		*gid = defgid = getgid ();
d292 1
a292 1
	va_start(ap,fmt);
d297 1
a297 1
	fmt = va_arg(ap,char *);
d301 1
a301 1
			(void) pclose (noteF);
d306 4
a309 6
		(void) snprintf (collrelname,sizeof collrelname,
			"%s-%s",collname,thisC->Crelease);
	else {
		(void) strncpy (collrelname,collname,sizeof collrelname-1);
		collrelname[sizeof collrelname-1] = '\0';
	}
d312 1
d314 1
a314 1
			(void) snprintf (buf,sizeof buf,
d316 2
a317 2
				collrelname,thisC->Cnotify);
			noteF = popen (buf,"w");
d320 1
a320 1
					thisC->Cnotify,collrelname);
d325 4
a328 4
		tloc = time ((time_t *)NULL);
		fprintf (noteF,"SUP Upgrade of %s at %s",
			collrelname,ctime (&tloc));
		(void) fflush (noteF);
d330 1
a330 1
	vfprintf(noteF,fmt,ap);
d332 1
a332 1
	(void) fflush (noteF);
d336 2
a337 2
lockout (on)		/* lock out interrupts */
int on;
d349 1
a349 2
	}
	else {
d354 2
a355 2
char *fmttime (time)
time_t time;
d358 1
a358 1
	int len;
d360 6
a365 5
	(void) strncpy (buf,ctime (&time), sizeof buf-1);
	buf[sizeof buf-1] = '\0';
	len = strlen(buf+4)-6;
	(void) strncpy (buf,buf+4,len);		/* XXX TDR */
	buf[sizeof buf-1] = '\0';
@


1.7
log
@Add a bunch of old revision history comments that we are missing to
make diffing easier.  No code changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.6 1997/09/16 11:01:21 deraadt Exp $	*/
d94 5
a98 4
	(void) strncpy (buf,ctime (&twhen), sizeof buf-1);
	buf[sizeof buf-1] = '\0';
	loginfo ("Last update occurred at %s for collection %s",
		buf,thisC->Cname);
d109 17
d141 3
a143 4
	(void) mkdir (dname,0755);
	if (stat (dname,&sbuf) < 0) {		/* didn't work */
		notify ("SUP: Can't create directory %s for %s\n",dname,fname);
		return (TRUE);
@


1.6
log
@strcpy whacking; ci.c and expand.c need more work
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.5 1997/09/16 10:42:55 deraadt Exp $	*/
d19 1
a19 1
 *  Software Distribution Coordinator  or  Software_Distribution@@CS.CMU.EDU
d31 9
@


1.5
log
@snprintf this thing
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.4 1997/04/01 07:35:35 todd Exp $	*/
d85 2
a86 2
	(void) strcpy (buf,ctime (&twhen));
	buf[strlen(buf)-1] = '\0';
d95 1
a95 1
	path (fname,dpart,fpart);
d107 1
a107 1
	path (dname,dpart,fpart);
d265 4
a268 2
	else
		(void) strcpy (collrelname,collname);
d319 2
a320 1
	(void) strcpy (buf,ctime (&time));
d322 2
a323 2
	(void) strncpy (buf,buf+4,len);
	buf[len] = '\0';
@


1.4
log
@This merges in the latest NetBSD sup source.
- removed $Log: ...$ tags to not waste space in the repository
- now doesn't segfault on the alpha!

Note:
To compile sup on systems other than *BSD, you'll need a copy of
vis.c, vis.h, daemon.c, and sys/cdefs.h.  At least the first two
(for OSF/1).

From NetBSD changelog description (for credit where due):
.... 1996/12/23 19:42:05  christos
- add missing prototypes.
- fix function call inconsistencies
- fix int <-> long and pointer conversions
It should run now on 64 bit machines...

....  1996/12/31 18:08:00  christos
64 bit patches (mostly long -> time_t) from Matthew Jacob (?)
sup now works on the alpha!
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.3 1996/07/31 11:11:29 niklas Exp $	*/
d78 1
a78 1
		(void) sprintf (relsufix,".%s",thisC->Crelease);
d263 2
a264 1
		(void) sprintf (collrelname,"%s-%s",collname,thisC->Crelease);
d270 2
a271 1
			(void) sprintf (buf,"mail -s \"SUP Upgrade of %s\" %s >/dev/null",
@


1.3
log
@Better use time_t instead of long when dealing with times
@
text
@d1 1
a1 1
/*	$OpenBSD: supcmisc.c,v 1.2 1996/06/26 05:39:52 deraadt Exp $	*/
a30 25
 * $Log: supcmisc.c,v $
 * Revision 1.2  1996/06/26 05:39:52  deraadt
 * rcsid
 *
 * Revision 1.1  1995/12/16 11:46:57  deraadt
 * add sup to the tree
 *
 * Revision 1.2  1995/06/03 21:21:57  christos
 * Changes to write ascii timestamps in the when files.
 * Looked into making it 64 bit clean, but it is hopeless.
 * Added little program to convert from the old timestamp files
 * into the new ones.
 *
 * Revision 1.1.1.1  1993/05/21 14:52:18  cgd
 * initial import of CMU's SUP to NetBSD
 *
 * Revision 1.5  92/08/11  12:07:22  mrt
 * 	Added release to FILEWHEN name.
 * 	Brad's changes: delinted and updated variable arguement usage.
 * 	[92/07/26            mrt]
 * 
 * Revision 1.3  89/08/15  15:31:28  bww
 * 	Updated to use v*printf() in place of _doprnt().
 * 	From "[89/04/19            mja]" at CMU.
 * 	[89/08/15            bww]
a41 5
#if __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif
d43 1
d61 4
a64 3
#if __STDC__
int notify (char *, ...);
#endif
d70 1
a75 1
	int f;
d145 1
a145 1
static
d173 1
a173 1
ugconvert (uname,gname,uid,gid,mode)
d191 1
a191 1
	if (u = Llookup (uidL,uname))
d193 1
a193 1
	else if (pw = getpwnam (uname)) {
d198 1
a198 1
		if (g = Llookup (gidL,gname)) {
d202 1
a202 1
		if (gr = getgrnam (gname)) {
d233 2
a234 1
#if __STDC__
a241 3
#if !__STDC__
	char *fmt;
#endif
d248 1
a248 1
#if __STDC__
d251 2
d289 1
d293 2
a294 2
	register int x;
	static int lockmask;
d297 6
a302 3
		x = sigmask (SIGHUP) | sigmask (SIGINT) |
		    sigmask (SIGQUIT) | sigmask (SIGTERM);
		lockmask = sigblock (x);
d305 1
a305 1
		(void) sigsetmask (lockmask);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 3
d102 1
a102 1
	long twhen;
d274 1
a274 1
	long tloc;
d307 1
a307 1
		tloc = time ((long *)NULL);
d334 1
a334 1
long time;
@


1.1
log
@add sup to the tree
@
text
@d1 2
d32 3
@
