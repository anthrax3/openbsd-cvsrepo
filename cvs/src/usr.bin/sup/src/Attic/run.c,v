head	1.15;
access;
symbols
	OPENBSD_4_8:1.14.0.22
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.18
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.20
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.16
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.14
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.12
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.10
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.12
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.10
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.8
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.6
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.12
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.15
date	2010.10.18.20.54.00;	author deraadt;	state dead;
branches;
next	1.14;

1.14
date	2005.07.04.01.54.10;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.19.19.39.39;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.25.16.54.11;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.07.19.26.03;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.04.22.16.15;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.02.22.56.52;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.29.21.52.15;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.06.03.16.20.35;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.04.01.07.35.16;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	96.12.22.03.26.04;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.39.45;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.16.11.46.49;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@sup is no longer used. reminded by pirofti and jmc
@
text
@/*	$OpenBSD: run.c,v 1.14 2005/07/04 01:54:10 djm Exp $	*/

/*
 * Copyright (c) 1991 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator   or   Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the rights
 * to redistribute these changes.
 */
/*  run, runv, runp, runvp --  execute process and wait for it to exit
 *
 *  Usage:
 *	i = run (file, arg1, arg2, ..., argn, 0);
 *	i = runv (file, arglist);
 *	i = runp (file, arg1, arg2, ..., argn, 0);
 *	i = runvp (file, arglist);
 *	i = runio (argv, in, out, err);
 *
 *  Run, runv, runp and runvp have argument lists exactly like the
 *  corresponding routines, execl, execv, execlp, execvp.  The run
 *  routines perform a fork, then:
 *  IN THE NEW PROCESS, an execl[p] or execv[p] is performed with the
 *  specified arguments.  The process returns with a -1 code if the
 *  exec was not successful.
 *  IN THE PARENT PROCESS, the signals SIGQUIT and SIGINT are disabled,
 *  the process waits until the newly forked process exits, the
 *  signals are restored to their original status, and the return
 *  status of the process is analyzed.
 *  All run routines return:  -1 if the exec failed or if the child was
 *  terminated abnormally; otherwise, the exit code of the child is
 *  returned.
 *
 **********************************************************************
 * HISTORY
 * Revision 1.1  89/10/14  19:53:39  rvb
 * Initial revision
 * 
 * Revision 1.2  89/08/03  14:36:46  mja
 * 	Update run() and runp() to use <varargs.h>.
 * 	[89/04/19            mja]
 * 
 * 23-Sep-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Merged old runv and runvp modules.
 *
 * 22-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added check and kill if child process was stopped.
 *
 * 30-Apr-85  Steven Shafer (sas) at Carnegie-Mellon University
 *	Adapted for 4.2 BSD UNIX:  Conforms to new signals and wait.
 *
 * 15-July-82 Mike Accetta (mja) and Neal Friedman (naf)
 *				  at Carnegie-Mellon University
 *	Added a return(-1) if vfork fails.  This should only happen
 *	if there are no more processes available.
 *
 * 28-Jan-80  Steven Shafer (sas) at Carnegie-Mellon University
 *	Added setuid and setgid for system programs' use.
 *
 * 21-Jan-80  Steven Shafer (sas) at Carnegie-Mellon University
 *	Changed fork to vfork.
 *
 * 20-Nov-79  Steven Shafer (sas) at Carnegie-Mellon University
 *	Created for VAX.  The proper way to fork-and-execute a system
 *	program is now by "runvp" or "runp", with the program name
 *	(rather than an absolute pathname) as the first argument;
 *	that way, the "PATH" variable in the environment does the right
 *	thing.  Too bad execvp and execlp (hence runvp and runp) don't
 *	accept a pathlist as an explicit argument.
 *
 **********************************************************************
 */

#include <stdio.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/wait.h>

#include "supcdefs.h"
#include "supextern.h"

static int dorun(char *, char **, int);
static char **makearglist(va_list);

static char **
makearglist(ap)
	va_list ap;
{
	static size_t ns = 0;
	static char **np = NULL;
	int i = 0;

	do {
		if (i >= ns) {
			ns += 20;
			if ((np = realloc(np, ns)) == NULL)
				return NULL;
		}
		np[i] = va_arg(ap, char *);
	}
	while (np[i++] != NULL)
		;
	return np;
}

int
run(char *name, ...)
{
	int val;
	va_list ap;
	char **argv;
	va_start(ap, name);

	if ((argv = makearglist(ap)) == NULL)
		return -1;
	val = runv (name, argv);
	va_end(ap);
	return(val);
}

int runv (name,argv)
char *name,**argv;
{
	return (dorun(name, argv, 0));
}

int
runp(char *name, ...)
{
	int val;
	va_list ap;
	char **argv;

	va_start(ap, name);
	if ((argv = makearglist(ap)) == NULL)
		return -1;
	val = runvp (name, argv);
	va_end(ap);
	return (val);
}

int runvp (name, argv)
	char *name, **argv;
{
	return (dorun(name, argv, 1));
}

static int
dorun(name, argv, usepath)
	char *name,**argv;
	int usepath;
{
	pid_t wpid;
	pid_t pid;
	struct sigaction ignoresig, intsig, quitsig;
	int status;
	uid_t uid;
	gid_t gid;

	if ((pid = fork()) == -1)
		return(-1);	/* no more process's, so exit with error */

	if (pid == 0) {			/* child process */
		uid = getuid();
		gid = getgid();
		if (setgroups(1, &gid) == -1 ||
		    setresgid(gid, gid, gid) == -1 ||
		    setresuid(uid, uid, uid) == -1)
			_exit(0377);
		if (usepath)
		    execvp(name,argv);
		else
		    execv(name,argv);
		fprintf (stderr,"run: can't exec %s: %s\n",name,
		    strerror(errno));
		_exit(0377);
	}

	memset(&ignoresig, 0, sizeof ignoresig);
	ignoresig.sa_handler = SIG_IGN;	/* ignore INT and QUIT signals */
	sigemptyset(&ignoresig.sa_mask);
	ignoresig.sa_flags = 0;
	sigaction(SIGINT, &ignoresig, &intsig);
	sigaction(SIGQUIT, &ignoresig, &quitsig);
	do {
		wpid = waitpid(-1, &status, WUNTRACED);
		if (WIFSTOPPED(status)) {
			kill(0, SIGTSTP);
			wpid = 0;
		}
	} while (wpid != pid && wpid != -1);
	sigaction (SIGINT, &intsig, 0);	/* restore signals */
	sigaction (SIGQUIT, &quitsig, 0);

	if (WIFSIGNALED(status) || WEXITSTATUS(status) == 0377)
		return (-1);

	return (WEXITSTATUS(status));
}

/*
 * Like system(3), but with an argument list and explicit redirections
 * that does not use the shell
 */
int
runio(argv, infile, outfile, errfile)
	char *const argv[];
	const char *infile;
	const char *outfile;
	const char *errfile;
{
	int	fd;
	pid_t	pid;
	int	status;

	switch ((pid = fork())) {
	case -1:
		return -1;

	case 0:
		if (infile) {
			(void) close(0);
			if ((fd = open(infile, O_RDONLY)) == -1)
				exit(1);
			if (fd != 0)
				(void) dup2(fd, 0);
		}

		if (outfile) {
			(void) close(1);
			if ((fd = open(outfile, O_RDWR|O_CREAT|O_TRUNC,
				       0666)) == -1)
				exit(1);
			if (fd != 1)
				(void) dup2(fd, 1);
		}

		if (errfile) {
			(void) close(2);
			if ((fd = open(errfile, O_RDWR|O_CREAT|O_TRUNC,
				       0666)) == -1)
				exit(1);
			if (fd != 2)
				(void) dup2(fd, 2);
		}
		execvp(argv[0], argv);
		exit(1);
		/*NOTREACHED*/
		return 0;
	
	default:
		if (waitpid(pid, &status, 0) == -1)
			return -1;
		return status;
	}
}

/*
 * Like runio, but works with filedescriptors instead of filenames
 */
int
runiofd(argv, infile, outfile, errfile)
	char *const argv[];
	const int infile;
	const int outfile;
	const int errfile;
{
	pid_t	pid;
	int	status;

	switch ((pid = fork())) {
	case -1:
		return -1;

	case 0:
		if (infile  != 0) dup2(infile, 0);
		if (outfile != 1) dup2(outfile,1);
		if (errfile != 2) dup2(errfile,2);
		execvp(argv[0], argv);
		exit(1);
		/*NOTREACHED*/
		return 0;
	
	default:
		if (waitpid(pid, &status, 0) == -1)
			return -1;
		return status;
	}
}
@


1.14
log
@make these use setres[ug]id for simple privilege dropping;
ok deraadt@@ millert@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.13 2002/06/12 06:07:16 mpech Exp $	*/
@


1.13
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.12 2002/02/19 19:39:39 millert Exp $	*/
d173 2
d180 6
a185 4
		setegid(getgid());
		setgid(getgid());
		seteuid(getuid());
		setuid(getuid());
@


1.12
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.11 2002/02/16 21:27:54 millert Exp $	*/
d169 2
a170 2
	int wpid;
	int pid;
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.10 2001/07/25 16:54:11 deraadt Exp $	*/
a97 6
#ifndef __STDC__
#ifndef const
#define const
#endif
#endif

a122 1
#ifdef __STDC__
a123 4
#else
run(va_alist)
va_dcl
#endif
a127 1
#ifdef __STDC__
a128 6
#else
	char *name;

	va_start(ap);
	name = va_arg(ap, char *);
#endif
a143 1
#ifdef __STDC__
a144 4
#else
runp (va_alist)
va_dcl
#endif
d149 1
a149 1
#ifdef __STDC__
a150 7
#else
	char *name;

	va_start(ap);
	name = va_arg(ap, char *);
#endif

@


1.10
log
@do not use vfork() unsafely
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.9 2001/05/07 19:26:03 millert Exp $	*/
d104 2
a105 2
static int dorun __P((char *, char **, int));
static char **makearglist __P((va_list));
@


1.9
log
@remove waitpid-related XXX's -- this is OK
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.8 2001/05/04 22:16:15 millert Exp $	*/
d204 1
a204 1
	if ((pid = vfork()) == -1)
@


1.8
log
@o kill register
o lots of KNF
o passes -Wall
o fix some [ug]id_t vs. int issues
o use strlcpy/strlcat in favor of strncpy/strncat
o use mem* routines everywhere instead of old b* ones
o marked several questionable things for later fixing
o kill ci.c and cvt.c -- we don't use them
o kill read_line.c since it requires fgetln() (bad for portability)
o kill salloc.c since it is the same as strup()
o Replaced some #ifdef __OpenBSD__ with better tests
o remaining problems: malloc return values are rarely checked, select misuse
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.7 2001/05/02 22:56:52 millert Exp $	*/
a227 1
		/* XXX - just give waitpid() pid instead of -1? (millert) */
d230 2
a231 2
		    kill(0, SIGTSTP);
		    wpid = 0;
@


1.7
log
@Sync with NetBSD.  Notable changes:
 o Add libwrap support to supfilesrv, conditioned by #ifdef LIBWRAP
   (on by default). <bouyer@@netbsd.org>
 o Renamed '-l' (the 'live' mode) to '-d' and '-l' is now used to
   enable logging of successfull connections. <bouyer@@netbsd.org>
 o Don't botch varargs: the are not always an array of void * in the stack...
   Write a separate function to convert a list of function parameters to
   explain why execv failed. <christos@@netbsd.org>
 o When in compress mode, don't overwrite the destination file directly,
   write a temp file and use rename when it is done. (From James Mathiesen
   <james@@deshaw.com>)
 o Rename errno variable to error to avoid collision with errno.h and remove
   explicit extern of errno (we get it from errno.h) <mycroft@@netbsd.org>
 o Cleanup unsigned char vs. char
 o Add -u flag, that prevents sup from attempting to restore a and m times
   on the received files.
 o Replace the provided read_line function with calls to the fparseln function
   in libutil.  Maintain compatibility on machines without fparseln through
   the NEED_READ_LINE define.
 o Rename login() to suplogin() to avoid name collition in util.h
 o If rmdir() fails, chmod the path to have r/w/x perms and run "rm -rf"
 o avoid last.temp filename collision by using rel-suffix
 o When creating directories, make sure you remove previous non-directories
   before doing so, otherwise sup fails.
 o Add -q flag to supscan for quiet operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.6 2001/04/29 21:52:15 millert Exp $	*/
d123 2
a124 1
	while (np[i++] != NULL);
d158 1
a158 1
	return (dorun (name, argv, 0));
d188 2
a189 2
int runvp (name,argv)
char *name,**argv;
d191 1
a191 1
	return (dorun (name, argv, 1));
d194 4
a197 4
static
int dorun (name,argv,usepath)
char *name,**argv;
int usepath;
d200 2
a201 2
	register int pid;
	struct sigaction ignoresig,intsig,quitsig;
d208 4
a211 4
		setegid (getgid());
		setgid (getgid());
		seteuid (getuid());
		setuid (getuid());
d218 1
a218 1
		_exit (0377);
d225 2
a226 2
	sigaction (SIGINT,&ignoresig,&intsig);
	sigaction (SIGQUIT,&ignoresig,&quitsig);
d228 4
a231 3
		wpid = wait3 (&status, WUNTRACED, 0);
		if (WIFSTOPPED (status)) {
		    kill (0,SIGTSTP);
d235 2
a236 2
	sigaction (SIGINT,&intsig,0);	/* restore signals */
	sigaction (SIGQUIT,&quitsig,0);
d238 1
a238 1
	if (WIFSIGNALED (status) || WEXITSTATUS(status) == 0377)
@


1.6
log
@Add a bunch of old revision history comments that we are missing to
make diffing easier.  No code changes...
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.5 1998/06/03 16:20:35 deraadt Exp $	*/
d105 21
d147 2
a148 1
	argv = va_arg(ap, char **);
d180 2
a181 1
	argv = va_arg(ap, char **);
d215 2
a216 1
		fprintf (stderr,"run: can't exec %s\n",name);
d287 11
d299 21
@


1.5
log
@zero sigaction before use
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.4 1997/04/01 07:35:16 todd Exp $	*/
d52 6
@


1.4
log
@This merges in the latest NetBSD sup source.
- removed $Log: ...$ tags to not waste space in the repository
- now doesn't segfault on the alpha!

Note:
To compile sup on systems other than *BSD, you'll need a copy of
vis.c, vis.h, daemon.c, and sys/cdefs.h.  At least the first two
(for OSF/1).

From NetBSD changelog description (for credit where due):
.... 1996/12/23 19:42:05  christos
- add missing prototypes.
- fix function call inconsistencies
- fix int <-> long and pointer conversions
It should run now on 64 bit machines...

....  1996/12/31 18:08:00  christos
64 bit patches (mostly long -> time_t) from Matthew Jacob (?)
sup now works on the alpha!
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.3 1996/12/22 03:26:04 tholo Exp $	*/
d190 1
@


1.3
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.2 1996/06/26 05:39:45 deraadt Exp $	*/
a51 21
 * $Log: run.c,v $
 * Revision 1.2  1996/06/26 05:39:45  deraadt
 * rcsid
 *
 * Revision 1.1  1995/12/16 11:46:49  deraadt
 * add sup to the tree
 *
 * Revision 1.2  1995/06/24 16:21:33  christos
 * - Don't use system(3) to fork processes. It is a big security hole.
 * - Encode the filenames in the scan files using strvis(3), so filenames
 *   that contain newlines or other weird characters don't break the scanner.
 *
 * Revision 1.1.1.1  1993/05/21 14:52:17  cgd
 * initial import of CMU's SUP to NetBSD
 *
 * Revision 1.1  89/10/14  19:53:39  rvb
 * Initial revision
 * 
 * Revision 1.2  89/08/03  14:36:46  mja
 * 	Update run() and runp() to use <varargs.h>.
 * 	[89/04/19            mja]
d88 3
a90 1
#include <varargs.h>
d98 1
a98 1
static int dorun();
d100 5
a104 2
int run (name,va_alist)
char *name;
d106 1
d110 5
d117 5
a121 1
	val = runv (name,ap);
d132 5
a136 2
int runp (name,va_alist)
char *name;
d138 1
d142 5
d149 5
a153 1
	val = runvp (name,ap);
d171 2
a172 4
	struct sigvec ignoresig,intsig,quitsig;
	union wait status;
	int execvp(), execv();
	int (*execrtn)() = usepath ? execvp : execv;
d182 4
a185 1
		(*execrtn) (name,argv);
d190 5
a194 5
	ignoresig.sv_handler = SIG_IGN;	/* ignore INT and QUIT signals */
	ignoresig.sv_mask = 0;
	ignoresig.sv_onstack = 0;
	sigvec (SIGINT,&ignoresig,&intsig);
	sigvec (SIGQUIT,&ignoresig,&quitsig);
d196 1
a196 1
		wpid = wait3 (&status.w_status, WUNTRACED, 0);
d202 2
a203 2
	sigvec (SIGINT,&intsig,0);	/* restore signals */
	sigvec (SIGQUIT,&quitsig,0);
d205 1
a205 1
	if (WIFSIGNALED (status) || status.w_retcode == 0377)
d208 1
a208 1
	return (status.w_retcode);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 3
d173 1
d175 1
@


1.1
log
@add sup to the tree
@
text
@d1 2
d53 3
@
