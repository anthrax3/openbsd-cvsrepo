head	1.39;
access;
symbols
	OPENBSD_4_8:1.38.0.12
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.8
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.10
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.6
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.4
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.38.0.2
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.36.0.6
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.4
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.36.0.2
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.35.0.4
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.34.0.4
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	OPENBSD_3_3:1.31.0.2
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	OPENBSD_2_6:1.15.0.6
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.4
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.39
date	2010.10.18.20.54.00;	author deraadt;	state dead;
branches;
next	1.38;

1.38
date	2007.09.14.14.29.20;	author chl;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.04.16.18.06;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.04.01.54.10;	author djm;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.31.15.48.26;	author pedro;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.23.03.48.43;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.04.03.24.07;	author beck;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.10.03.53.32;	author david;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2002.06.23.03.07.22;	author deraadt;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.19.19.39.39;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.23.19.31.28;	author camield;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.12.12.03.03;	author heko;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.07.19.26.02;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.07.02.08.02;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.04.22.16.17;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.02.22.56.54;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.29.18.16.19;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.09.03.19.51;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.20.18.42.42;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2000.02.01.03.23.40;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.21.00.26.48;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.06.03.16.20.38;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.05.18.19.13.39;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.11.17.08.54.05;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.10.11.23.34.21;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	97.09.16.11.01.23;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.09.16.10.42.59;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.09.08.23.59.43;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.25.21.05.42;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.04.01.07.35.43;	author todd;	state Exp;
branches;
next	1.6;

1.6
date	97.01.17.07.18.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.22.03.26.05;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.07.31.11.11.31;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.39.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.20.45.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.16.11.46.59;	author deraadt;	state Exp;
branches;
next	;

1.30.2.1
date	2003.09.24.18.59.11;	author brad;	state Exp;
branches;
next	;

1.31.2.1
date	2003.09.24.19.05.59;	author brad;	state Exp;
branches;
next	;


desc
@@


1.39
log
@sup is no longer used. reminded by pirofti and jmc
@
text
@/*	$OpenBSD: supfilesrv.c,v 1.38 2007/09/14 14:29:20 chl Exp $	*/

/*
 * Copyright (c) 1992 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 *
 */
/*
 * supfilesrv -- SUP File Server
 *
 * Usage:  supfilesrv [-d] [-l] [-P] [-N] [-R] [-S]
 *	-d	"debug" -- don't fork daemon
 *	-l	"log" -- print successull connects (when compiled with libwrap)
 *	-P	"debug ports" -- use debugging network ports
 *	-N	"debug network" -- print debugging messages for network i/o
 *	-R	"RCS mode" -- if file is an rcs file, use co to get contents
 *	-S	"Operate silently" -- Only print error messages
 *
 **********************************************************************
 * HISTORY
 * 2-Aug-99   Manuel Bouyer at LIP6
 *	Added libwrap support
 *
 * 13-Sep-92  Mary Thompson (mrt) at Carnegie-Mellon University
 *	Changed name of sup program in xpatch from /usr/cs/bin/sup to
 *	/usr/bin/sup for exported version of sup.
 *
 * 7-July-93  Nate Williams at Montana State University
 *	Modified SUP to use gzip based compression when sending files
 *	across the network to save BandWidth
 *
 * Revision 1.20  92/09/09  22:05:00  mrt
 * 	Added Brad's change to make sendfile take a va_list.
 * 	Added support in login to accept an non-encrypted login
 * 	message if no user or password is being sent. This supports
 * 	a non-crypting version of sup. Also fixed to skip leading
 * 	white space from crypts in host files.
 * 	[92/09/01            mrt]
 * 
 * Revision 1.19  92/08/11  12:07:59  mrt
 * 		Made maxchildren a patchable variable, which can be set by the
 * 		command line switch -C or else defaults to the MAXCHILDREN
 * 		defined in sup.h. Added most of Brad's STUMP changes.
 * 	Increased PGMVERSION to 12 to reflect substantial changes.
 * 	[92/07/28            mrt]
 * 
 * Revision 1.18  90/12/25  15:15:39  ern
 * 	Yet another rewrite of the logging code. Make up the text we will write
 * 	   and then get in, write it and get out.
 * 	Also set error on write-to-full-disk if the logging is for recording
 * 	   server is busy.
 * 	[90/12/25  15:15:15  ern]
 * 
 * Revision 1.17  90/05/07  09:31:13  dlc
 * 	Sigh, some more fixes to the new "crypt" file handling code.  First,
 * 	just because the "crypt" file is in a local file system does not mean
 * 	it can be trusted.  We have to check for hard links to root owned
 * 	files whose contents could be interpretted as a crypt key.  For
 * 	checking this fact, the new routine stat_info_ok() was added.  This
 * 	routine also makes other sanity checks, such as owner only permission,
 * 	the file is a regular file, etc.  Also, even if the uid/gid of th
 * 	"crypt" file is not going to be used, still use its contents in order
 * 	to cause fewer surprises to people supping out of a shared file system
 * 	such as AFS.
 * 	[90/05/07            dlc]
 * 
 * Revision 1.16  90/04/29  04:21:08  dlc
 * 	Fixed logic bug in docrypt() which would not get the stat information
 * 	from the crypt file if the crypt key had already been set from a
 * 	"host" file.
 * 	[90/04/29            dlc]
 * 
 * Revision 1.15  90/04/18  19:51:27  dlc
 * 	Added the new routines local_file(), link_nofollow() for use in
 * 	dectecting whether a file is located in a local file system.  These
 * 	routines probably should have been in another module, but only
 * 	supfilesrv needs to do the check and none of its other modules seemed
 * 	appropriate.  Note, the implementation should be changed once we have
 * 	direct kernel support, for example the fstatfs(2) system call, for
 * 	detecting the type of file system a file resides.  Also, I changed
 * 	the routines which read the crosspatch crypt file or collection crypt
 * 	file to save the uid and gid from the stat information obtained via
 * 	the local_file() call (when the file is local) at the same time the
 * 	crypt key is read.  This change disallows non-local files for the
 * 	crypt key to plug a security hole involving the usage of the uid/gid
 * 	of the crypt file to define who the file server should run as.  If
 * 	the saved uid/gid are both valid, then the server will set its uid/gid
 * 	to these values.
 * 	[90/04/18            dlc]
 * 
 * Revision 1.14  89/08/23  14:56:15  gm0w
 * 	Changed msgf routines to msg routines.
 * 	[89/08/23            gm0w]
 * 
 * Revision 1.13  89/08/03  19:57:33  mja
 * 	Remove setaid() call.
 * 
 * Revision 1.12  89/08/03  19:49:24  mja
 * 	Updated to use v*printf() in place of _doprnt().
 * 	[89/04/19            mja]
 * 
 * 11-Sep-88  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code to record release name in logfile.
 *
 * 18-Mar-88  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added host=<hostfile> support to releases file. [V7.12]
 *
 * 27-Dec-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added crosspatch support.  Created docrypt() routine for crypt
 *	test message.
 *
 * 09-Sep-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Removed common information logging code, the quiet switch, and
 *	moved samehost() check to after device/inode check.
 *
 * 28-Jun-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code for "release" support. [V5.11]
 *
 * 26-May-87  Doug Philips (dwp) at Carnegie-Mellon University
 *	Added code to record final status of client in logfile. [V5.10]
 *
 * 22-May-87  Chriss Stephens (chriss) at Carnegie Mellon University
 *	Mergered divergent CS and ECE versions. [V5.9a]
 *
 * 20-May-87  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Removed support for version 3 of SUP protocol.  Added changes
 *	to make lint happy.  Added calls to new logging routines. [V5.9]
 *
 * 31-Mar-87  Dan Nydick (dan) at Carnegie-Mellon University
 *	Fixed so no password check is done when crypts are used.
 *
 * 25-Nov-86  Rudy Nedved (ern) at Carnegie-Mellon University
 *	Set F_APPEND fcntl in logging to increase the chance
 *	that the log entry from this incarnation of the file
 *	server will not be lost by another incarnation. [V5.8]
 *
 * 20-Oct-86  Dan Nydick (dan) at Carnegie-Mellon University
 *	Changed not to call okmumbles when not compiled with CMUCS.
 *
 * 04-Aug-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code to increment scmdebug as more -N flags are
 *	added. [V5.7]
 *
 * 25-May-86  Jonathan J. Chew (jjc) at Carnegie-Mellon University
 *	Renamed local variable in main program from "sigmask" to
 *	"signalmask" to avoid name conflict with 4.3BSD identifier.
 *	Conditionally compile in calls to CMU routines, "setaid" and
 *	"logaccess". [V5.6]
 *
 * 21-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Changed supfilesrv to use the crypt file owner and group for
 *	access purposes, rather than the directory containing the crypt
 *	file. [V5.5]
 *
 * 07-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code to keep logfiles in repository collection directory.
 *	Added code for locking collections. [V5.4]
 *
 * 05-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code to support new FSETUPBUSY return.  Now accepts all
 *	connections and tells any clients after the 8th that the
 *	fileserver is busy.  New clients will retry again later. [V5.3]
 *
 * 29-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Major rewrite for protocol version 4. [V4.2]
 *
 * 12-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Fixed close of crypt file to use file pointer as argument
 *	instead of string pointer.
 *
 * 24-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Allow "!hostname" lines and comments in collection "host" file.
 *
 * 13-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Don't use access() on symbolic links since they may not point to
 *	an existing file.
 *
 * 22-Oct-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Added code to restrict file server availability to when it has
 *	less than or equal to eight children.
 *
 * 22-Sep-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Merged 4.1 and 4.2 versions together.
 *
 * 04-Jun-85  Steven Shafer (sas) at Carnegie-Mellon University
 *	Created for 4.2 BSD.
 *
 **********************************************************************
 */

#include <libc.h>
#ifdef AFS
#include <afs/param.h>
#undef MAXNAMLEN
#endif
#include <sys/param.h>
#include <c.h>
#include <signal.h>
#include <errno.h>
#include <setjmp.h>
#include <pwd.h>
#include <grp.h>
#include <fcntl.h>
#include <limits.h>
#include <stdarg.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/mount.h>
#ifndef HAS_POSIX_DIR
#include <sys/dir.h>
#else
#include <dirent.h>
#endif
#if	MACH
#include <sys/ioctl.h>
#endif
#if	CMUCS
#include <acc.h>
#include <sys/ttyloc.h>
#include <access.h>
#include <sys/viceioctl.h>
#else /* CMUCS */
#define ACCESS_CODE_OK		0
#define ACCESS_CODE_BADPASSWORD (-2)
#endif /*  CMUCS */

#ifdef __linux__
# include <sys/vfs.h>
# include <linux/nfs_fs.h>
#endif

#ifdef __SVR4
# include <sys/mkdev.h>
# include <sys/statvfs.h>
#endif

#ifdef LIBWRAP
# include <tcpd.h>
#endif

#ifdef HAS_LOGIN_CAP
# include <login_cap.h>
#endif

#include "supcdefs.h"
#include "supextern.h"
#define MSGFILE
#include "supmsg.h"

#ifndef UID_MAX
#define UID_MAX ((uid_t)-1)
#define GID_MAX ((gid_t)-1)
#else
#ifndef GID_MAX
#define GID_MAX	UID_MAX
#endif
#endif

int maxchildren;

/*
 * These are used to save the stat information from the crosspatch crypt
 * file or collection crypt file at the time it is opened for the crypt
 * key and it is verified to be a local file.
 */
uid_t runas_uid = UID_MAX;
gid_t runas_gid = GID_MAX;

#define PGMVERSION 13

/*************************
 ***    M A C R O S    ***
 *************************/

#define HASHBITS 8
#define HASHSIZE (1<<HASHBITS)
#define HASHMASK (HASHSIZE-1)
#define HASHFUNC(x,y) ((x)&HASHMASK)

/*******************************************
 ***    D A T A   S T R U C T U R E S    ***
 *******************************************/

struct hashstruct {			/* hash table for number lists */
	int Hnum1;			/* numeric keys */
	int Hnum2;
	char *Hname;			/* string value */
	TREE *Htree;			/* TREE value */
	struct hashstruct *Hnext;
};
typedef struct hashstruct HASH;

/*********************************************
 ***    G L O B A L   V A R I A B L E S    ***
 *********************************************/

char program[] = "supfilesrv";		/* program name for SCM messages */
pid_t progpid = -1;			/* and process id */

jmp_buf sjbuf;				/* jump location for network errors */
TREELIST *listTL;			/* list of trees to upgrade */

char *oneconnect = NULL;		/* -O flag */
int silent;				/* -S flag */
#ifdef LIBWRAP
int clog;				/* -l flag */
#endif
int live;				/* -d flag */
int dbgportsq;				/* -P flag */
extern int scmdebug;			/* -N flag */
extern int netfile;
#ifdef RCS
int candorcs;				/* -R flag */
int dorcs = FALSE;
#endif

char *clienthost;			/* host name of client */
int nchildren;				/* number of children that exist */
char *prefix;				/* collection pathname prefix */
char *release;				/* collection release name */
char *cryptkey;				/* encryption key if non-null */
#ifdef CVS
char *cvs_root;				/* RCS root */
#endif
char *rcs_branch;			/* RCS branch name */
int lockfd;				/* descriptor of lock file */

/* global variables for scan functions */
int trace = FALSE;			/* directory scan trace */
int cancompress = FALSE;		/* Can we compress files */
int docompress = FALSE;			/* Do we compress files */

HASH *uidH[HASHSIZE];			/* for uid and gid lookup */
HASH *gidH[HASHSIZE];
HASH *inodeH[HASHSIZE];			/* for inode lookup for linked file check */


/* supfilesrv.c */
int main(int, char **);
void chldsig(int);
void usage(void);
void init(int, char **);
void answer(void);
void srvsignon(void);
void srvsetup(void);
void docrypt(void);
void srvlogin(void);
void listfiles(void);
int denyone(TREE *, void *);
void sendfiles(void);
int sendone(TREE *, void *);
int senddir(TREE *, void *);
int sendfile(TREE *, va_list);
void srvfinishup(time_t);
void Hfree(HASH **);
HASH *Hlookup(HASH **, int, int );
void Hinsert(HASH **, int, int, char *, TREE *);
TREE *linkcheck(TREE *, int, int );
char *uconvert(uid_t);
char *gconvert(gid_t);
char *changeuid(char *, char *, uid_t, gid_t);
void goaway(char *, ...);
char *fmttime(time_t);
int local_file(int, struct stat *);
int stat_info_ok(struct stat *, struct stat *);
int link_nofollow(int);
int link_nofollow(int);
int opentmp(char *, size_t);

/*************************************
 ***    M A I N   R O U T I N E    ***
 *************************************/

int
main (argc,argv)
int argc;
char **argv;
{
	int x;
	pid_t pid;
	sigset_t nset, oset;
	struct sigaction chld,ign;
	time_t tloc;
#ifdef LIBWRAP
        struct request_info req;
#endif  

	/* initialize global variables */
	pgmversion = PGMVERSION;	/* export version number */
	server = TRUE;			/* export that we're not a server */
	collname = NULL;		/* no current collection yet */
	maxchildren = MAXCHILDREN;	/* defined in sup.h */

	init (argc,argv);		/* process arguments */

	if (!live)			/* if not debugging, turn into daemon */
#ifdef HAS_DAEMON
		daemon(0, 0);
#else
		/* XXX - child should close fd's */
		switch (fork()) {
			case 0:
				setsid();	/* child, start new session */
				break;
			case -1:
				perror("fork:");
				exit(1);
			default:
				exit(0);	/* parent just exits */
		}
#endif

	logopen("supfile");
	tloc = time(NULL);
	loginfo("SUP File Server Version %d.%d (%s) starting at %s",
	    PROTOVERSION, PGMVERSION, scmversion, fmttime(tloc));
	if (live) {
		x = service ();

		if (x != SCMOK)
			logquit(1, "Can't connect to network");
#ifdef LIBWRAP
		request_init(&req, RQ_DAEMON, "supfilesrv", RQ_FILE, netfile,
		    0);      
		fromhost(&req);
		if (hosts_access(&req) == 0) {
			logdeny("refused connection from %.500s",
			    eval_client(&req));   
			servicekill();       
			exit(1);
		}
		if (clog)
			logallow("connection from %.500s", eval_client(&req));
#endif
		answer();
		(void) serviceend();
		exit(0);
	}
	memset(&ign, 0, sizeof ign);
	ign.sa_handler = SIG_IGN;
	sigemptyset(&ign.sa_mask);
	ign.sa_flags = 0;
	(void) sigaction(SIGHUP,&ign,NULL);
	(void) sigaction(SIGINT,&ign,NULL);
	(void) sigaction(SIGPIPE,&ign,NULL);
	memset(&chld, 0, sizeof chld);
	chld.sa_handler = chldsig;
	sigemptyset(&chld.sa_mask);
	chld.sa_flags = 0;
	(void) sigaction(SIGCHLD,&chld,NULL);
	nchildren = 0;
	for (;;) {
		x = service();
		if (x != SCMOK) {
			logerr("Error in establishing network connection");
			(void) servicekill();
			continue;
		}
		sigemptyset(&nset);
		sigaddset(&nset, SIGCHLD);
		sigprocmask(SIG_BLOCK, &nset, &oset);
		if ((pid = fork()) == 0) { /* server process */
#ifdef LIBWRAP
			request_init(&req, RQ_DAEMON, "supfilesrv", RQ_FILE,
			    netfile, 0);      
			fromhost(&req);
			if (hosts_access(&req) == 0) {
				logdeny("refused connection from %.500s",
				    eval_client(&req));   
				servicekill();       
				exit(1);
			}
			if (clog) {
				logallow("connection from %.500s",
				    eval_client(&req));
			}
#endif
			(void) serviceprep();
			answer();
			(void) serviceend();
			exit(0);
		}
		(void) servicekill();	/* parent */
		if (pid > 0)
			nchildren++;
		(void) sigprocmask(SIG_SETMASK, &oset, NULL);
	}
}

/*
 * Child status signal handler
 */
void
chldsig(snum)
	int snum;
{
	int w;

	while (waitpid(-1, &w, WNOHANG) > 0) {
		if (nchildren)
			nchildren--;
	}
}

/*****************************************
 ***    I N I T I A L I Z A T I O N    ***
 *****************************************/

void
usage()
{
#ifdef LIBWRAP
	quit(1,"Usage: supfilesrv [ -l | -d | -P | -N | -C <max children> | -H <host> <user> <cryptfile> <supargs> ]\n");
#else
	quit(1,"Usage: supfilesrv [ -d | -P | -N | -C <max children> | -H <host> <user> <cryptfile> <supargs> ]\n");
#endif
}

void
init(argc, argv)
	int argc;
	char **argv;
{
	int i;
	int x;
	char *clienthost, *clientuser;
	char *p;
	char buf[STRINGLENGTH];
	int maxsleep;
	FILE *f;

#ifdef RCS
        candorcs = FALSE;
#endif
	live = FALSE;
#ifdef LIBWRAP
	clog = FALSE;
#endif
	dbgportsq = FALSE;
	scmdebug = 0;
	clienthost = NULL;
	clientuser = NULL;
	maxsleep = 5;
	if (--argc < 0)
		usage ();
	argv++;
	while (clienthost == NULL && argc > 0 && argv[0][0] == '-') {
		switch (argv[0][1]) {
		case 'S':
			silent = TRUE;
			break;
#ifdef LIBWRAP
		case 'l':
			clog = TRUE;
			break;
#endif
		case 'd':
			live = TRUE;
			break;
		case 'P':
			dbgportsq = TRUE;
			break;
		case 'N':
			scmdebug++;
			break;
		case 'C':
			if (--argc < 1)
				quit (1,"Missing arg to -C\n");
			argv++;
			maxchildren = atoi(argv[0]);
			break;
		case 'O':
			if (--argc < 1)
				quit (1,"Missing arg to -O\n");
			argv++;
			oneconnect = argv[0];
			break;
		case 'H':
			if (--argc < 3)
				quit (1,"Missing args to -H\n");
			argv++;
			clienthost = argv[0];
			clientuser = argv[1];
			cryptkey = argv[2];
			argc -= 2;
			argv += 2;
			break;
#ifdef RCS
                case 'R':
                        candorcs = TRUE;
                        break;
#endif
		default:
			fprintf(stderr, "Unknown flag %s ignored\n", argv[0]);
			break;
		}
		--argc;
		argv++;
	}
	if (clienthost == NULL) {
		if (argc != 0)
			usage ();
		x = servicesetup(dbgportsq ? DEBUGFPORT : FILEPORT);
		if (x != SCMOK)
			quit(1,"Error in network setup");
		for (i = 0; i < HASHSIZE; i++)
			uidH[i] = gidH[i] = inodeH[i] = NULL;
		return;
	}
	server = FALSE;
	if (argc < 1)
		usage();
	f = fopen(cryptkey, "r");
	if (f == NULL)
		quit(1, "Unable to open cryptfile %s\n", cryptkey);
	if ((p = fgets(buf, sizeof(buf), f)) != NULL) {
		p[strcspn(p, "\n")] = '\0';
		if (*p == '\0')
			quit(1, "No cryptkey found in %s\n", cryptkey);
		cryptkey = strdup(buf);
		if (cryptkey == NULL)
			quit(1, "Unable to allocate memory\n");
			
	}
	(void) fclose(f);
	x = request (dbgportsq ? DEBUGFPORT : FILEPORT, clienthost, &maxsleep);
	if (x != SCMOK)
		quit(1, "Unable to connect to host %s\n", clienthost);
	x = msgsignon ();
	if (x != SCMOK)
		quit(1, "Error sending signon request to fileserver\n");
	x = msgsignonack();
	if (x != SCMOK)
		quit(1, "Error reading signon reply from fileserver\n");
	printf("SUP Fileserver %d.%d (%s) %ld on %s\n", protver, pgmver,
	    scmver, (long)fspid, remotehost());
	free(scmver);
	scmver = NULL;
	if (protver < 7)
		quit(1, "Remote fileserver does not implement reverse sup\n");
	xpatch = TRUE;
	xuser = clientuser;
	x = msgsetup();
	if (x != SCMOK)
		quit(1, "Error sending setup request to fileserver\n");
	x = msgsetupack();
	if (x != SCMOK)
		quit(1, "Error reading setup reply from fileserver\n");
	switch(setupack) {
	case FSETUPOK:
		break;
	case FSETUPSAME:
		quit(1, "User %s not found on remote client\n", xuser);
	case FSETUPHOST:
		quit(1, "This host has no permission to reverse sup\n");
	default:
		quit(1, "Unrecognized file server setup status %d\n", setupack);
	}
	if (netcrypt(cryptkey) != SCMOK )
		quit(1, "Running non-crypting fileserver\n");
	crypttest = CRYPTTEST;
	x = msgcrypt();
	if (x != SCMOK)
		quit(1, "Error sending encryption test request\n");
	x = msgcryptok();
	if (x == SCMEOF)
		quit(1, "Data encryption test failed\n");
	if (x != SCMOK)
		quit(1, "Error reading encryption test reply\n");
	logcrypt = CRYPTTEST;
	loguser = NULL;
	logpswd = NULL;
	if (netcrypt(PSWDCRYPT) != SCMOK)	/* encrypt password data */
		quit(1, "Running non-crypting fileserver\n");
	x = msglogin();
	(void) netcrypt(NULL);	/* turn off encryption */
	if (x != SCMOK)
		quit(1, "Error sending login request to file server\n");
	x = msglogack();
	if (x != SCMOK)
		quit(1, "Error reading login reply from file server\n");
	if (logack == FLOGNG)
		quit(1, "%s\nImproper login to %s account\n", logerror, xuser);
	xargc = argc;
	xargv = argv;
	x = msgxpatch();
	if (x != SCMOK)
		quit(1, "Error sending crosspatch request\n");
    	crosspatch();
	exit(0);
}

/*****************************************
 ***    A N S W E R   R E Q U E S T    ***
 *****************************************/

void
answer()
{
	time_t starttime;
	int x;

	progpid = fspid = getpid();
	collname = NULL;
	basedir = NULL;
	prefix = NULL;
	release = NULL;
        rcs_branch = NULL;
#ifdef CVS
        cvs_root = NULL;
#endif
	goawayreason = NULL;
	donereason = NULL;
	lockfd = -1;
	starttime = time(NULL);
	if (!setjmp(sjbuf)) {
		srvsignon();
		srvsetup();
		docrypt();
		srvlogin();
		if (xpatch) {
			x = msgxpatch();
			if (x != SCMOK)
				exit(0);
			xargv[0] = "sup";
			xargv[1] = "-X";
			xargv[xargc] = NULL;
			(void) dup2(netfile,0);
			(void) dup2(netfile,1);
			(void) dup2(netfile,2);
			closefrom(3);
			execvp(xargv[0], xargv);
			exit(0);
		}
		listfiles();
		sendfiles();
	}
	srvfinishup(starttime);
	if (collname)
		free(collname);
	if (basedir)
		free(basedir);
	if (prefix)
		free(prefix);
	if (release)
		free(release);
	if (rcs_branch)
		free(rcs_branch);
#ifdef CVS
	if (cvs_root)
		free(cvs_root);
#endif
	if (goawayreason) {
		if (donereason == goawayreason)
			donereason = NULL;
		free(goawayreason);
	}
	if (donereason)
		free(donereason);
	if (lockfd >= 0)
		(void) close(lockfd);
	endpwent();
	endgrent();
#if	CMUCS
	endacent();
#endif	/* CMUCS */
	Hfree(uidH);
	Hfree(gidH);
	Hfree(inodeH);
}

/*****************************************
 ***    S I G N   O N   C L I E N T    ***
 *****************************************/

void
srvsignon()
{
	int x;

	xpatch = FALSE;
	x = msgsignon();
	if (x != SCMOK)
		goaway("Error reading signon request from client");
	x = msgsignonack();
	if (x != SCMOK)
		goaway("Error sending signon reply to client");
	free(scmver);
	scmver = NULL;
}

/*****************************************************************
 ***    E X C H A N G E   S E T U P   I N F O R M A T I O N    ***
 *****************************************************************/

void
srvsetup()
{
	int x;
	char *p,*q;
	char buf[STRINGLENGTH];
	FILE *f;
	struct stat sbuf;
	TREELIST *tl;

	if (protver > 7)
		cancompress = TRUE;
	x = msgsetup();
	if (x != SCMOK)
		goaway("Error reading setup request from client");
	if (protver < 4) {
		setupack = FSETUPOLD;
		(void) msgsetupack();
		if (protver >= 6)
			longjmp(sjbuf, TRUE);
		goaway("Sup client using obsolete version of protocol");
	}
	if (xpatch) {
		struct passwd *pw;

		if ((pw = getpwnam(xuser)) == NULL) {
			setupack = FSETUPSAME;
			(void) msgsetupack();
			if (protver >= 6)
				longjmp(sjbuf,TRUE);
			goaway("User `%s' not found", xuser);
		}
		(void) free(xuser);
		xuser = strdup(pw->pw_dir);

		/* check crosspatch host access file */
		cryptkey = NULL;
		(void) snprintf(buf, sizeof buf, FILEXPATCH, xuser);

		/* Turn off link following */
		if (link_nofollow(1) != -1) {
			int hostok = FALSE;
			/* get stat info before open */
			if (stat(buf, &sbuf) == -1)
				(void) memset(&sbuf, 0, sizeof(sbuf));

			if ((f = fopen(buf, "r")) != NULL) {
				struct stat fsbuf;

				while ((p = fgets(buf, sizeof(buf), f)) != NULL) {
					p[strcspn(p, "\n")] = '\0';
					if (strchr("#;:", *p))
						continue;
					q = nxtarg(&p, " \t");
					if (*p == '\0')
						continue;
					if (!matchhost(q))
						continue;

					cryptkey = strdup(p);
					hostok = TRUE;
					if (local_file(fileno(f), &fsbuf) > 0
					    && stat_info_ok(&sbuf, &fsbuf)) {
						runas_uid = sbuf.st_uid;
						runas_gid = sbuf.st_gid;
					}
					break;
				}
				(void) fclose(f);
			}

			/* Restore link following */
			if (link_nofollow(0) == -1)
				goaway ("Restore link following");

			if (!hostok) {
				setupack = FSETUPHOST;
				(void) msgsetupack();
				if (protver >= 6)
					longjmp(sjbuf, TRUE);
				goaway("Host not on access list");
			}
		}
		setupack = FSETUPOK;
		x = msgsetupack();
		if (x != SCMOK)
			goaway("Error sending setup reply to client");
		return;
	}
#ifdef RCS
        if (candorcs && release != NULL &&
            (strncmp(release, "RCS.", 4) == 0)) {
                rcs_branch = strdup(&release[4]);
                free(release);
                release = strdup("RCS");
                dorcs = TRUE;
        }
#endif
	if (release == NULL)
		release = strdup(DEFRELEASE);
	if (basedir == NULL || *basedir == '\0') {
		basedir = NULL;
		(void) snprintf(buf, sizeof buf, FILEDIRS, DEFDIR);
		f = fopen(buf, "r");
		if (f) {
			while ((p = fgets(buf, sizeof(buf), f)) != NULL) {
				p[strcspn(p, "\n")] = '\0';
				if (strchr("#;:", *p))
					continue;
				q = nxtarg(&p, " \t=");
				if (strcmp(q, collname) == 0) {
					basedir = skipover(p, " \t=");
					basedir = strdup(basedir);
					break;
				}
			}
			(void) fclose(f);
		}
		if (basedir == NULL) {
			(void) snprintf(buf, sizeof buf, FILEBASEDEFAULT,
			    collname);
			basedir = strdup(buf);
		}
	}
	if (chdir(basedir) < 0)
		goaway("Can't chdir to base directory %s", basedir);
	(void) snprintf(buf, sizeof buf, FILEPREFIX, collname);
	f = fopen(buf, "r");
	if (f) {
		while ((p = fgets(buf, sizeof(buf), f)) != NULL) {
			p[strcspn(p, "\n")] = '\0';
			if (strchr("#;:", *p))
				continue;
			prefix = strdup(p);
			if (chdir(prefix) < 0)
				goaway("Can't chdir to %s from base directory %s",
				    prefix,basedir);
			break;
		}
		(void) fclose(f);
	}
	x = stat(".", &sbuf);
	if (prefix)
		(void) chdir(basedir);
	if (x < 0)
		goaway("Can't stat base/prefix directory");
	if (nchildren >= maxchildren) {
		setupack = FSETUPBUSY;
		(void) msgsetupack();
		if (protver >= 6)
			longjmp(sjbuf, TRUE);
		goaway("Sup client told to try again later");
	}
	if (sbuf.st_dev == basedev && sbuf.st_ino == baseino && samehost()) {
		setupack = FSETUPSAME;
		(void) msgsetupack();
		if (protver >= 6)
			longjmp(sjbuf, TRUE);
		goaway("Attempt to upgrade to same directory on same host");
	}
	/* obtain release information */
	if (!getrelease(release)) {
		setupack = FSETUPRELEASE;
		(void) msgsetupack();
		if (protver >= 6)
			longjmp(sjbuf, TRUE);
		goaway("Invalid release information");
	}
	/* check host access file */
	cryptkey = NULL;
	for (tl = listTL; tl != NULL; tl = tl->TLnext) {
		char *h;
		if ((h = tl->TLhost) == NULL)
			h = FILEHOSTDEF;
		(void) snprintf(buf, sizeof buf, FILEHOST, collname, h);
		f = fopen(buf, "r");
		if (f) {
			int hostok = FALSE;

			while ((p = fgets (buf, sizeof(buf), f)) != NULL) {
				int not;

				p[strcspn(p, "\n")] = '\0';
				if (strchr("#;:", *p))
					continue;
				q = nxtarg(&p, " \t");
				if ((not = (*q == '!')) && *++q == '\0')
					q = nxtarg(&p, " \t");
				hostok = (not == (matchhost(q) == 0));
				if (hostok) {
					while ((*p == ' ') || (*p == '\t'))
						p++;
					if (*p)
						cryptkey = strdup(p);
					break;
				}
			}
			(void) fclose(f);
			if (!hostok) {
				setupack = FSETUPHOST;
				(void) msgsetupack();
				if (protver >= 6)
					longjmp(sjbuf, TRUE);
				goaway("Host not on access list for %s",
				    collname);
			}
		}
	}
	/* try to lock collection */
	(void) snprintf(buf, sizeof buf, FILELOCK, collname);
#ifdef LOCK_SH
	x = open(buf, O_RDONLY, 0);
	if (x >= 0) {
		if (flock(x, LOCK_SH|LOCK_NB) < 0) {
			(void) close(x);
			if (errno != EWOULDBLOCK)
				goaway("Can't lock collection %s", collname);
			setupack = FSETUPBUSY;
			(void) msgsetupack();
			if (protver >= 6)
				longjmp(sjbuf, TRUE);
			goaway("Sup client told to wait for lock");
		}
		lockfd = x;
	}
#endif
	if (oneconnect != NULL && (lock_host_file(oneconnect) < 0))
		goaway("I'm still working on a previous request from your host.");
	setupack = FSETUPOK;
	x = msgsetupack();
	if (x != SCMOK)
		goaway("Error sending setup reply to client");
}

/** Test data encryption **/
void
docrypt()
{
	int x;
	char *p;
	char buf[STRINGLENGTH];
	FILE *f;
	struct stat sbuf;

	if (!xpatch) {
		(void) snprintf(buf, sizeof buf, FILECRYPT, collname);

		/* Turn off link following */
		if (link_nofollow(1) != -1) {
			/* get stat info before open */
			if (stat(buf, &sbuf) == -1)
				(void) memset(&sbuf, 0, sizeof(sbuf));

			if ((f = fopen(buf, "r")) != NULL) {
				struct stat fsbuf;

				if (cryptkey == NULL &&
				    (p = fgets(buf, sizeof(buf), f))) {
					p[strcspn(p, "\n")] = '\0';
					if (*p)
						cryptkey = strdup(buf);
				}
				if (local_file(fileno(f), &fsbuf) > 0
				    && stat_info_ok(&sbuf, &fsbuf)) {
					runas_uid = sbuf.st_uid;
					runas_gid = sbuf.st_gid;
				}
				(void) fclose(f);
			}
			/* Restore link following */
			if (link_nofollow(0) == -1)
				goaway("Restore link following");
		}
	}
	if (netcrypt (cryptkey) != SCMOK)
		goaway("Runing non-crypting supfilesrv");
	x = msgcrypt();
	if (x != SCMOK)
		goaway("Error reading encryption test request from client");
	(void) netcrypt(NULL);
	if (strcmp(crypttest, CRYPTTEST) != 0)
		goaway("Client not encrypting data properly");
	free(crypttest);
	crypttest = NULL;
	x = msgcryptok();
	if (x != SCMOK)
		goaway("Error sending encryption test reply to client");
}

/***************************************************************
 ***    C O N N E C T   T O   P R O P E R   A C C O U N T    ***
 ***************************************************************/

void
srvlogin()
{
	int x;
	uid_t fileuid = UID_MAX;
	gid_t filegid = GID_MAX;

	(void) netcrypt(PSWDCRYPT);	/* encrypt acct name and password */
	x = msglogin();
	(void) netcrypt(NULL);		/* turn off encryption */
	if (x != SCMOK)
		goaway("Error reading login request from client");
	if (logcrypt) {
	    if (strcmp(logcrypt, CRYPTTEST) != 0) {
		logack = FLOGNG;
		logerror = "Improper login encryption";
		(void) msglogack();
		goaway("Client not encrypting login information properly");
	    }
	    free(logcrypt);
	    logcrypt = NULL;
	}
	if (loguser == NULL) {
		if (cryptkey) {
			if (runas_uid != UID_MAX && runas_gid != GID_MAX) {
				fileuid = runas_uid;
				filegid = runas_gid;
				loguser = NULL;
			} else
				loguser = strdup(DEFUSER);
		} else
			loguser = strdup(DEFUSER);
	}
	if ((logerror = changeuid(loguser, logpswd, fileuid, filegid)) != NULL) {
		logack = FLOGNG;
		(void) msglogack();
		if (protver >= 6)
			longjmp(sjbuf, TRUE);
		goaway("Client denied login access");
	}
	if (loguser)
		free(loguser);
	if (logpswd)
		free(logpswd);
	logack = FLOGOK;
	x = msglogack();
	if (x != SCMOK)
		goaway("Error sending login reply to client");
	if (!xpatch)	/* restore desired encryption */
		if (netcrypt(cryptkey) != SCMOK)
			goaway("Running non-crypting supfilesrv");
	free(cryptkey);
	cryptkey = NULL;
}

/*****************************************
 ***    M A K E   N A M E   L I S T    ***
 *****************************************/

void
listfiles()
{
	int x;

	refuseT = NULL;
	x = msgrefuse();
	if (x != SCMOK)
		goaway("Error reading refuse list from client");
	getscanlists();
	Tfree(&refuseT);
	x = msglist();
	if (x != SCMOK)
		goaway("Error sending file list to client");
	Tfree(&listT);
	listT = NULL;
	needT = NULL;
	x = msgneed();
	if (x != SCMOK)
		goaway("Error reading needed files list from client");
	denyT = NULL;
	(void) Tprocess(needT, denyone, NULL);
	Tfree(&needT);
	x = msgdeny();
	if (x != SCMOK)
		goaway("Error sending denied files list to client");
	Tfree(&denyT);
}


int
denyone(t, v)
	TREE *t;
	void *v;
{
	TREELIST *tl;
	char *name = t->Tname;
	int update = (t->Tflags&FUPDATE) != 0;
	struct stat sbuf;
	TREE *tlink;
	char slinkname[STRINGLENGTH];
	int x;

	for (tl = listTL; tl != NULL; tl = tl->TLnext)
		if ((t = Tsearch(tl->TLtree, name)) != NULL)
			break;
	if (t == NULL) {
		(void) Tinsert(&denyT, name, FALSE);
		return (SCMOK);
	}
	cdprefix(tl->TLprefix);
	if (S_ISLNK(t->Tmode))
		x = lstat(name, &sbuf);
	else
		x = stat(name, &sbuf);
	if (x < 0 || (sbuf.st_mode&S_IFMT) != (t->Tmode&S_IFMT)) {
		(void) Tinsert(&denyT, name, FALSE);
		return (SCMOK);
	}
	switch (t->Tmode&S_IFMT) {
	case S_IFLNK:
		if ((x = readlink(name, slinkname, sizeof slinkname-1)) <= 0) {
			(void) Tinsert(&denyT, name, FALSE);
			return (SCMOK);
		}
		slinkname[x] = '\0';
		(void) Tinsert(&t->Tlink, slinkname, FALSE);
		break;
	case S_IFREG:
		if (sbuf.st_nlink > 1 &&
		    (tlink = linkcheck(t, (int)sbuf.st_dev, (int)sbuf.st_ino)))
		{
			(void) Tinsert(&tlink->Tlink, name, FALSE);
			return (SCMOK);
		}
		if (update)
			t->Tflags |= FUPDATE;
	case S_IFDIR:
		t->Tuid = sbuf.st_uid;
		t->Tgid = sbuf.st_gid;
		break;
	default:
		(void) Tinsert(&denyT, name, FALSE);
		return (SCMOK);
	}
	t->Tflags |= FNEEDED;
	return (SCMOK);
}

/*********************************
 ***    S E N D   F I L E S    ***
 *********************************/

void
sendfiles()
{
	TREELIST *tl;
	int x;

	/* Does the protocol support compression */
	if (cancompress) {
		/* Check for compression on sending files */
		x = msgcompress();
		if ( x != SCMOK)
			goaway("Error sending compression check to server");
	}
	/* send all files */
	for (tl = listTL; tl != NULL; tl = tl->TLnext) {
		cdprefix(tl->TLprefix);
#ifdef CVS
                if (candorcs) {
                        cvs_root = getcwd(NULL, MAXPATHLEN);
                        if (!cvs_root || access("CVSROOT", F_OK) < 0)
                                dorcs = FALSE;
                        else {
                                loginfo("is a CVSROOT \"%s\"\n", cvs_root);
                                dorcs = TRUE;
                        }
                }
#endif
		(void) Tprocess(tl->TLtree, sendone, NULL);
	}
	/* send directories in reverse order */
	for (tl = listTL; tl != NULL; tl = tl->TLnext) {
		cdprefix(tl->TLprefix);
		(void) Trprocess(tl->TLtree, senddir, NULL);
	}
	x = msgsend();
	if (x != SCMOK)
		goaway("Error reading receive file request from client");
	upgradeT = NULL;
	x = msgrecv(sendfile, 0);
	if (x != SCMOK)
		goaway("Error sending file to client");
}

int
sendone(t, v)
	TREE *t;
	void *v;
{
	int x, fd, ifd;
	char temp_file[MAXPATHLEN];
	char *av[50];	/* More than enough */

	if ((t->Tflags&FNEEDED) == 0)	/* only send needed files */
		return (SCMOK);
	if (S_ISDIR(t->Tmode))		/* send no directories this pass */
		return (SCMOK);
	x = msgsend();
	if (x != SCMOK)
		goaway("Error reading receive file request from client");
	upgradeT = t;			/* upgrade file pointer */
	fd = -1;			/* no open file */
	if (S_ISREG(t->Tmode)) {
		if (!listonly && (t->Tflags&FUPDATE) == 0) {
#ifdef RCS
                        if (dorcs) {
                                char rcs_release[MAXPATHLEN];

				fd = opentmp(rcs_file, sizeof(rcs_file));
				if (fd < 0)
					goaway ("We died trying to create temp file");
				close(fd);
                                if (strcmp(&t->Tname[strlen(t->Tname)-2], ",v") == 0) {
                                        t->Tname[strlen(t->Tname)-2] = '\0';
					ac = 0;
#ifdef CVS
					av[ac++] = "cvs";
					av[ac++] = "-d";
					av[ac++] = cvs_root;
					av[ac++] = "-r";
					av[ac++] = "-l";
					av[ac++] = "-Q";
					av[ac++] = "co";
					av[ac++] = "-p";
					if (rcs_branch != NULL) {
						av[ac++] = "-r";
						av[ac++] = rcs_branch;
					}
#else
					av[ac++] = "co";
					av[ac++] = "-q";
					av[ac++] = "-p";
					if (rcs_branch != NULL) {
						snprintf(rcs_release,
						    sizeof rcs_release,
						    "-r%s", rcs_branch);
						av[ac++] = rcs_release;
					}
#endif
					av[ac++] = t->Tname;
					av[ac++] = NULL;
					status = runio(av, NULL, rcs_file,
					    "/dev/null");
                                        /*loginfo("using rcs mode \n");*/
                                        if (status < 0 || WEXITSTATUS(status)) {
                                                /* Just in case */
                                                unlink(rcs_file);
                                                if (status < 0) {
                                                        goaway("We died trying to run cvs or rcs on %s", rcs_file);
                                                        t->Tmode = 0;
                                                } else {
#if 0
                                                        logerr("rcs command failed = %d\n",
                                                               WEXITSTATUS(status));
#endif
                                                        t->Tflags |= FUPDATE;
                                                }
                                        } else if (docompress) {
                                                fd = opentmp(temp_file, sizeof(temp_file));
						if (fd < 0)
							goaway ("We died trying to create temp file");
						ifd = open(rcs_file, O_RDONLY, 0);
						if (ifd < 0)
							goaway ("We died trying to open %s", rcs_file);
						av[0] = "gzip";
						av[1] = "-cf";
						av[2] = NULL;
						if (runiofd(av, ifd, fd, 2) != 0) {
							close(fd);
							close(ifd);
                                                        /* Just in case */
                                                        unlink(temp_file);
                                                        unlink(rcs_file);
                                                        goaway("We died trying to gzip %s", rcs_file);
                                                        t->Tmode = 0;
                                                }
						lseek(fd, (off_t)0, SEEK_SET);
						close(ifd);
                                        } else
                                                fd = open (rcs_file,O_RDONLY,0);
                                }
                        }
#endif
                        if (fd == -1) {
                                if (docompress) {
					fd = opentmp(temp_file, sizeof(temp_file));
					if (fd < 0)
						goaway ("We died trying to create temp file");
					ifd = open(t->Tname, O_RDONLY, 0);
					if (ifd < 0)
						goaway ("We died trying to open %s", t->Tname);
					av[0] = "gzip";
					av[1] = "-cf";
					av[2] = NULL;
					if (runiofd(av, ifd, fd, 2) != 0) {
						close(fd);
						close(ifd);
                                                /* Just in case */
                                                unlink(temp_file);
                                                goaway("We died trying to run gzip %s", t->Tname);
                                                t->Tmode = 0;
                                        }
					lseek(fd, (off_t)0, SEEK_SET);
					close(ifd);
                                } else
                                        fd = open(t->Tname, O_RDONLY, 0);
                        }
			if (fd < 0 && (t->Tflags&FUPDATE) == 0)
				t->Tmode = 0;
		}
		if (t->Tmode) {
			t->Tuser = strdup(uconvert(t->Tuid));
			t->Tgroup = strdup(gconvert(t->Tgid));
		}
	}
	x = msgrecv(sendfile,fd);
	if (docompress)
		unlink(temp_file);
#ifdef RCS
	if (dorcs)
		unlink(rcs_file);
#endif
	if (x != SCMOK)
		goaway("Error sending file %s to client", t->Tname);
	return (SCMOK);
}

int
senddir(t, v)
	TREE *t;
	void *v;
{
	int x;

	if ((t->Tflags&FNEEDED) == 0)	/* only send needed files */
		return (SCMOK);
	if (!S_ISDIR(t->Tmode))		/* send only directories this pass */
		return (SCMOK);
	x = msgsend();
	if (x != SCMOK)
		goaway("Error reading receive file request from client");
	upgradeT = t;			/* upgrade file pointer */
	t->Tuser = strdup(uconvert(t->Tuid));
	t->Tgroup = strdup(gconvert(t->Tgid));
	x = msgrecv(sendfile,0);
	if (x != SCMOK)
		goaway("Error sending file %s to client", t->Tname);
	return (SCMOK);
}

int
sendfile(t, ap)
	TREE *t;
	va_list ap;
{
	int x, fd;

	fd = va_arg(ap,int);
	if (!S_ISREG(t->Tmode) || listonly || (t->Tflags&FUPDATE))
		return (SCMOK);
	x = writefile(fd);
	if (x != SCMOK)
		goaway("Error sending file %s to client", t->Tname);
        (void) close(fd);
	return (SCMOK);
}

/*****************************************
 ***    E N D   C O N N E C T I O N    ***
 *****************************************/

void
srvfinishup(starttime)
	time_t starttime;
{
	int x = SCMOK;
	char tmpbuf[BUFSIZ], lognam[STRINGLENGTH];
	int logfd;
	time_t finishtime;
	char *releasename;

	/*
	 * Because we are headed for an exit() we don't bother to
	 * free memory allocated by this function.
	 */
	(void) netcrypt(NULL);
	if (protver < 6) {
		if (goawayreason != NULL)
			free(goawayreason);
		goawayreason = NULL;
		x = msggoaway();
		doneack = FDONESUCCESS;
		donereason = strdup("Unknown");
	} else if (goawayreason == NULL)
		x = msgdone();
	else {
		doneack = FDONEGOAWAY;
		donereason = goawayreason;
	}
	if (x == SCMEOF || x == SCMERR) {
		doneack = FDONEUSRERROR;
		donereason = strdup("Premature EOF on network");
	} else if (x != SCMOK) {
		doneack = FDONESRVERROR;
		donereason = strdup("Unknown SCM code");
	}
	if (doneack == FDONEDONTLOG)
		return;
	if (donereason == NULL)
		donereason = strdup("No reason");
	if (doneack == FDONESRVERROR || doneack == FDONEUSRERROR)
		logerr("%s", donereason);
	else if (doneack == FDONEGOAWAY)
		logerr("GOAWAY: %s", donereason);
	else if (doneack != FDONESUCCESS)
		logerr("Reason %d:  %s", doneack, donereason);
	goawayreason = donereason;
	cdprefix(NULL);
	if (collname == NULL) {
		logerr("NULL collection in svrfinishup");
		return;
	}
	(void) snprintf(lognam, sizeof lognam, FILELOGFILE, collname);
	if ((logfd = open(lognam, O_APPEND|O_WRONLY, 0644)) < 0)
		return; /* can not open file up...error */
	if ((releasename = release) == NULL)
		releasename = "UNKNOWN";
	finishtime = time(NULL);
	(void) snprintf(tmpbuf, sizeof tmpbuf, "%s %s %s %s %s %d %s\n",
	    strdup(fmttime(lasttime)), strdup(fmttime(starttime)),
	    strdup(fmttime(finishtime)), remotehost(), releasename,
	    FDONESUCCESS-doneack, donereason);
#if	MACH
	/* if we are busy dont get stuck updating the disk if full */
	if (setupack == FSETUPBUSY) {
		long l = FIOCNOSPC_ERROR;
		ioctl(logfd, FIOCNOSPC, &l);
	}
#endif	/* MACH */
	(void) write(logfd, tmpbuf, strlen(tmpbuf));
	(void) close(logfd);
}

/***************************************************
 ***    H A S H   T A B L E   R O U T I N E S    ***
 ***************************************************/

void
Hfree(table)
	HASH **table;
{
	HASH *h;
	int i;

	for (i = 0; i < HASHSIZE; i++)
		while ((h = table[i]) != NULL) {
			table[i] = h->Hnext;
			if (h->Hname)
				free(h->Hname);
			free(h);
		}
}

HASH *
Hlookup(table, num1, num2)
	HASH **table;
	int num1, num2;
{
	HASH *h;
	int hno;

	hno = HASHFUNC(num1, num2);
	for (h = table[hno]; h && (h->Hnum1 != num1 || h->Hnum2 != num2);
	    h = h->Hnext)
		;
	return (h);
}

void
Hinsert(table, num1, num2, name, tree)
	HASH **table;
	int num1, num2;
	char *name;
	TREE *tree;
{
	HASH *h;
	int hno;

	hno = HASHFUNC(num1, num2);
	h = (HASH *) malloc(sizeof(HASH));
	h->Hnum1 = num1;
	h->Hnum2 = num2;
	h->Hname = name;
	h->Htree = tree;
	h->Hnext = table[hno];
	table[hno] = h;
}

/*********************************************
 ***    U T I L I T Y   R O U T I N E S    ***
 *********************************************/

TREE *
linkcheck(t, d, i)
	TREE *t;
	int d, i;		/* inode # and device # */
{
	HASH *h;

	h = Hlookup(inodeH,i,d);
	if (h)
		return (h->Htree);
	Hinsert(inodeH, i, d, NULL, t);
	return (NULL);
}

char *
uconvert(uid)
	uid_t uid;
{
	struct passwd *pw;
	char *p;
	HASH *u;

	u = Hlookup(uidH, uid, 0);
	if (u)
		return (u->Hname);
	pw = getpwuid (uid);
	if (pw == NULL)
		return ("");
	p = strdup(pw->pw_name);
	Hinsert(uidH, uid, 0, p, NULL);
	return (p);
}

char *
gconvert(gid)
	gid_t gid;
{
	struct group *gr;
	char *p;
	HASH *g;

	g = Hlookup(gidH, gid, 0);
	if (g)
		return (g->Hname);
	gr = getgrgid(gid);
	if (gr == NULL)
		return ("");
	p = strdup(gr->gr_name);
	Hinsert(gidH, gid, 0, p, NULL);
	return (p);
}

char *
changeuid(namep, passwordp, fileuid, filegid)
	char *namep, *passwordp;
	uid_t fileuid;
	gid_t filegid;
{
	char *group,*account,*pswdp;
	struct passwd *pwd;
	struct group *grp;
#if	CMUCS
	struct account *acc;
	struct ttyloc tlc;
#endif	/* CMUCS */
	int status = ACCESS_CODE_OK;
	char nbuf[STRINGLENGTH];
	static char errbuf[STRINGLENGTH];
#if	CMUCS
	int *grps;
#endif	/* CMUCS */
	char *p = NULL;

	if (namep == NULL) {
		pwd = getpwuid(fileuid);
		if (pwd == NULL) {
			(void) snprintf(errbuf, sizeof errbuf,
				"Reason:  Unknown user id %u", fileuid);
			return (errbuf);
		}
		grp = getgrgid(filegid);
		if (grp)
			(void) strlcpy(group=nbuf, grp->gr_name, sizeof nbuf);
		else
			group = NULL;
		account = NULL;
		pswdp = NULL;
	} else {
		(void) strlcpy(nbuf, namep, sizeof nbuf);
		account = group = strchr(nbuf, ',');
		if (group != NULL) {
			*group++ = '\0';
			account = strchr(group, ',');
			if (account != NULL) {
				*account++ = '\0';
				if (*account == '\0')
					account = NULL;
			}
			if (*group == '\0')
				group = NULL;
		}
		pwd = getpwnam(nbuf);
		if (pwd == NULL) {
			(void) snprintf(errbuf, sizeof errbuf,
				"Reason:  Unknown user %s", nbuf);
			return (errbuf);
		}
		if (strcmp(nbuf, DEFUSER) == 0)
			pswdp = NULL;
		else
			pswdp = passwordp ? passwordp : "";
#ifdef AFS
                if (strcmp(nbuf, DEFUSER) != 0) {
                        char *reason;

                        setpag(); /* set a pag */
                        if (ka_UserAuthenticate(pwd->pw_name, "", 0,
                                                pswdp, 1, &reason)) {
                                (void) snprintf(errbuf, sizeof errbuf,
					"AFS authentication failed, %s",
                                        reason);
                                logerr ("Attempt by %s; %s", nbuf, errbuf);
                                return (errbuf);
                        }
                }
#endif
	}
	if (getuid() != 0) {
		if (getuid() == pwd->pw_uid)
			return (NULL);
		if (strcmp(pwd->pw_name, DEFUSER) == 0)
			return (NULL);
		logerr("Fileserver not superuser");
		return ("Reason:  fileserver is not running privileged");
	}
#if	CMUCS
	tlc.tlc_hostid = TLC_UNKHOST;
	tlc.tlc_ttyid = TLC_UNKTTY;
	if (okaccess(pwd->pw_name,ACCESS_TYPE_SU,0,-1,tlc) != 1)
		status = ACCESS_CODE_DENIED;
	else {
		grp = NULL;
		acc = NULL;
		status = oklogin(pwd->pw_name, group, &account, pswdp, &pwd,
		    &grp, &acc, &grps);
		if (status == ACCESS_CODE_OK) {
			if ((p = okpassword(pswdp, pwd->pw_name, pwd->pw_gecos)) != NULL)
				status = ACCESS_CODE_INSECUREPWD;
		}
	}
#else	/* CMUCS */
	status = ACCESS_CODE_OK;
	if (namep && strcmp(pwd->pw_name, DEFUSER) != 0)
		if (strcmp(pwd->pw_passwd, crypt(pswdp, pwd->pw_passwd)))
			status = ACCESS_CODE_BADPASSWORD;
#endif	/* CMUCS */
	switch (status) {
	case ACCESS_CODE_OK:
		break;
	case ACCESS_CODE_BADPASSWORD:
		p = "Reason:  Invalid password";
		break;
#if	CMUCS
	case ACCESS_CODE_INSECUREPWD:
		(void) snprintf(errbuf, sizeof errbuf, "Reason:  %s", p);
		p = errbuf;
		break;
	case ACCESS_CODE_DENIED:
		p = "Reason:  Access denied";
		break;
	case ACCESS_CODE_NOUSER:
		p = errbuf;
		break;
	case ACCESS_CODE_ACCEXPIRED:
		p = "Reason:  Account expired";
		break;
	case ACCESS_CODE_GRPEXPIRED:
		p = "Reason:  Group expired";
		break;
	case ACCESS_CODE_ACCNOTVALID:
		p = "Reason:  Invalid account";
		break;
	case ACCESS_CODE_MANYDEFACC:
		p = "Reason:  User has more than one default account";
		break;
	case ACCESS_CODE_NOACCFORGRP:
		p = "Reason:  No account for group";
		break;
	case ACCESS_CODE_NOGRPFORACC:
		p = "Reason:  No group for account";
		break;
	case ACCESS_CODE_NOGRPDEFACC:
		p = "Reason:  No group for default account";
		break;
	case ACCESS_CODE_NOTGRPMEMB:
		p = "Reason:  Not member of group";
		break;
	case ACCESS_CODE_NOTDEFMEMB:
		p = "Reason:  Not member of default group";
		break;
	case ACCESS_CODE_OOPS:
		p = "Reason:  Internal error";
		break;
#endif	/* CMUCS */
	default:
		(void) snprintf(errbuf, sizeof errbuf, "Reason:  Status %d",
		    status);
		p = errbuf;
		break;
	}
	if (pwd == NULL)
		return (p);
	if (status != ACCESS_CODE_OK) {
		logerr("Login failure for %s", pwd->pw_name);
		logerr("%s", p);
#if	CMUCS
		logaccess(pwd->pw_name, ACCESS_TYPE_SUP, status, 0, -1, tlc);
#endif	/* CMUCS */
		return (p);
	}
#if	CMUCS
	if (setgroups(grps[0], &grps[1]) < 0)
		logerr("setgroups: %%m");
	if (setresgid(grp->gr_gid, grp->gr_gid, grp->gr_gid) < 0)
		logerr("setresgid: %%m");
	if (setresuid(pwd->pw_uid, pwd->pw_uid, pwd->pw_uid) < 0)
		logerr("setresuid: %%m");
#else   /* CMUCS */
#ifdef HAS_LOGIN_CAP
	if (setusercontext(NULL, pwd, pwd->pw_uid, LOGIN_SETALL) < 0)
		return ("Error setting user context");
#else
	if (initgroups(pwd->pw_name,pwd->pw_gid) < 0)
		return ("Error setting group list");
	if (setresgid(pwd->pw_gid, pwd->pw_gid, pwd->pw_gid) < 0)
		logerr("setresgid: %%m");
#ifndef NO_SETLOGIN
	if (setlogin(pwd->pw_name) < 0)
		logerr("setlogin: %%m");
#endif
	if (setresuid(pwd->pw_uid, pwd->pw_uid, pwd->pw_uid) < 0)
		logerr("setresuid: %%m");
#endif	/* HAS_LOGIN_CAP */
#endif	/* CMUCS */
	return (NULL);
}

void
goaway(char *fmt,...)
{
	char buf[STRINGLENGTH];
	va_list ap;

	va_start(ap, fmt);
	(void) netcrypt(NULL);

	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);
	strlcat(buf, " [", sizeof(buf));
	strlcat(buf, remotehost(), sizeof(buf));
	strlcat(buf, "]", sizeof(buf));
	goawayreason = strdup(buf);
	(void) msggoaway();
	logerr("%s", buf);
	longjmp(sjbuf, TRUE);
}

char *
fmttime(time)
	time_t time;
{
	static char buf[16];
	char *p;

	/*
	 * Copy ctime to buf, stripping day of week, year, and newline.
	 * E.g.: "Thu Nov 24 18:22:48 1986\n" -> "Nov 24 18:22:48"
	 */
	p = ctime(&time) + 4;
	(void) strlcpy(buf, p, sizeof(buf));
	return (buf);
}

/*
 * Determine whether the file referenced by the file descriptor 'handle' can
 * be trusted, namely is it a file resident in the local file system.
 *
 * The main method of operation is to perform operations on the file
 * descriptor so that an attempt to spoof the checks should fail, for
 * example renamimg the file from underneath us and/or changing where the
 * file lives from underneath us.
 *
 * returns: -1 for error, indicating that we can not tell
 *	     0 for file is definitely not local, or it is an RFS link
 *	     1 for file is local and can be trusted
 *
 * Side effect: copies the stat information into the supplied buffer,
 * regardless of the type of file system the file resides.
 *
 * Currently, the cases that we try to distinguish are RFS, AFS, NFS and
 * UFS, where the latter is considered a trusted file.  We assume that the
 * caller has disabled link following and will detect an attempt to access
 * a file through an RFS link, except in the case the last component is
 * an RFS link.  With link following disabled, the last component itself is
 * interpreted as a regular file if it is really an RFS link, so we
 * disallow the RFS link identified by group "symlink" and mode "IEXEC by
 * owner only". An AFS file is
 * detected by trying the VIOCIGETCELL ioctl, which is one of the few AFS
 * ioctls which operate on a file descriptor.  Note, this AFS ioctl is
 * implemented in the cache manager, so the decision does not involve a
 * query with the AFS file server.  An NFS file is detected by looking at
 * the major device number and seeing if it matches the known values for
 * MACH NSF/Sun OS 3.x or Sun OS 4.x.
 *
 * Having the fstatfs() system call would make this routine easier and
 * more reliable.
 *
 * Note, in order to make the checks simpler, the file referenced by the
 * file descriptor can not be a BSD style symlink.  Even with symlink
 * following of the last path component disabled, the attempt to open a
 * file which is a symlink will succeed, so we check for the BSD symlink
 * file type here.  Also, the link following on/off and RFS file types
 * are only relevant in a MACH environment. 
 */
#ifdef	AFS
#include <sys/viceioctl.h>
#endif

#define SYMLINK_GRP 64

int local_file(handle, sinfo)
	int handle;
	struct stat *sinfo;
{
	struct stat sb;
#ifdef	VIOCIGETCELL
	/*
	 * dummies for the AFS ioctl
	 */
	struct ViceIoctl vdata;
	char cellname[512];
#endif	/* VIOCIGETCELL */

	if (fstat(handle, &sb) < 0)
		return(-1);
	if (sinfo != NULL)
		*sinfo = sb;

#if	CMUCS
	/*
	 * If the following test succeeds, then the file referenced by
	 * 'handle' is actually an RFS link, so we will not trust it.
	 * See <sys/inode.h>.
	 */
	if (sb.st_gid == SYMLINK_GRP
		&& (sb.st_mode & (S_IFMT|S_IEXEC|(S_IEXEC>>3)|(S_IEXEC>>6)))
			== (S_IFREG|S_IEXEC))
		return(0);
#endif	/* CMUCS */

	/*
	 * Do not trust BSD style symlinks either.
	 */
	if (S_ISLNK(sb.st_mode))
		return(0);

#ifdef	VIOCIGETCELL
	/*
	 * This is the VIOCIGETCELL ioctl, which takes an fd, not
	 * a path name.  If it succeeds, then the file is in AFS.
	 *
	 * On failure, ENOTTY indicates that the file was not in
	 * AFS; all other errors are pessimistically assumed to be
	 * a temporary AFS error.
	 */
	vdata.in_size = 0;
	vdata.out_size = sizeof(cellname);
	vdata.out = cellname;
	if (ioctl(handle, VIOCIGETCELL, (char *)&vdata) != -1)
		return(0);
	if (errno != ENOTTY)
		return(-1);
#endif	/* VIOCIGETCELL */

	/*
	 * Verify the file is not in NFS.
	 */
#ifdef __SVR4
	{
		struct statvfs sf;

		if (fstatvfs(handle, &sf) == -1)
			return(-1);
		return strncmp(sf.f_basetype, "nfs", 3) != 0;
	}
#elif defined(__NetBSD__) || defined(__OpenBSD__)
	{
		struct statfs sf;
		if (fstatfs(handle, &sf) == -1)
			return(-1);
		return strncmp(sf.f_fstypename, "nfs", 3) != 0;
	}
#elif defined(__linux__)
	{
		struct statfs sf;

		if (fstatfs(handle, &sf) == -1)
			return(-1);
		return sf.f_type != NFS_SUPER_MAGIC;
	}
#else
	/*
	 * Sun OS 3.x use major device 255 for NFS files;
	 * Sun OS 4.x seems to use 130 (I have only determined
	 * this empirically -- DLC).  Without a fstatfs()
	 * system call, this will have to do for now.
	 */

	return !(major(sb.st_dev) == 255 || major(sb.st_dev) == 130);

#endif
}

/*
 * Companion routine for ensuring that a local file can be trusted.  Compare
 * various pieces of the stat information to make sure that the file can be
 * trusted.  Returns true for stat information which meets the criteria
 * for being trustworthy.  The main paranoia is to prevent a hard link to
 * a root owned file.  Since the link could be removed after the file is
 * opened, a simply fstat() can not be relied upon.  The two stat buffers
 * for comparison should come from a stat() on the file name and a following
 * fstat() on the open file.  Some of the following checks are also an
 * additional level of paranoia.  Also, this test will fail (correctly) if
 * either or both of the stat structures have all fields zeroed; typically
 * due to a stat() failure.
 */
int
stat_info_ok(sb1, sb2)
	struct stat *sb1, *sb2;
{
	return (sb1->st_ino == sb2->st_ino &&	/* Still the same file */
		sb1->st_dev == sb2->st_dev &&	/* On the same device */
		sb1->st_mode == sb2->st_mode && /* Perms (and type) same */
		S_ISREG(sb1->st_mode) &&	/* Only allow reg files */
		(sb1->st_mode & 077) == 0 &&	/* Owner only perms */
		sb1->st_nlink == sb2->st_nlink && /* # hard links same... */
		sb1->st_nlink == 1 &&		/* and only 1 */
		sb1->st_uid == sb2->st_uid &&	/* owner and ... */
		sb1->st_gid == sb2->st_gid &&	/* group unchanged */
		sb1->st_mtime == sb2->st_mtime && /* Unmodified between stats */
		sb1->st_ctime == sb2->st_ctime); /* Inode unchanged.  Hopefully
						    a catch-all paranoid test */
}

#if MACH
/*
 * Twiddle symbolic/RFS link following on/off.  This is a no-op in a non
 * CMUCS/MACH environment.  Also, the setmodes/getmodes interface is used
 * mainly because it is simpler than using table(2) directly.
 */
#include <sys/table.h>

int
link_nofollow(on)
	int on;
{
	static int modes = -1;

	if (modes == -1 && (modes = getmodes()) == -1)
		return(-1);
	if (on)
		return(setmodes(modes | UMODE_NOFOLLOW));
	return(setmodes(modes));
}
#else	/* MACH */
/*ARGSUSED*/
int
link_nofollow(on)
	int on;
{
	return(0);
}
#endif	/* MACH */

int
opentmp(path, psize)
	char *path;
	size_t psize;
{
	char *tdir;

	if ((tdir = getenv("TMPDIR")) == NULL || *tdir == '\0')
		tdir = "/tmp";
	if (snprintf(path, psize, "%s/supfilesrv.XXXXXXXXXX", tdir) >= psize) {
		errno = ENAMETOOLONG;
		return (-1);
	}
	return (mkstemp(path));
}
@


1.38
log
@remove some warnings:
unused variable `variable'
`variable' might be used uninitialized in this function

ok gilles@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.37 2007/09/11 15:47:17 gilles Exp $	*/
@


1.37
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.36 2006/03/04 16:18:06 miod Exp $	*/
d550 1
a550 1
	char *p, *q;
d1058 1
a1058 1
	char *p,*q;
@


1.36
log
@the the
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.35 2005/07/04 01:54:10 djm Exp $	*/
d640 1
a640 2
		if ((q = strchr(p, '\n')))
			*q = '\0';
d644 3
d869 1
a869 3
					q = strchr(p, '\n');
					if (q)
						*q = '\0';
d925 1
a925 3
				q = strchr(p, '\n');
				if (q)
					*q = '\0';
d949 1
a949 3
			q = strchr(p, '\n');
			if (q)
				*q = '\0';
d1001 1
a1001 3
				q = strchr (p,'\n');
				if (q)
					*q = '\0';
d1077 1
a1077 2
					if ((q = strchr(p, '\n')) != NULL)
						*q = '\0';
@


1.35
log
@make these use setres[ug]id for simple privilege dropping;
ok deraadt@@ millert@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.34 2004/05/31 15:48:26 pedro Exp $	*/
d106 1
a106 1
 * 	of the crypt file to define who the the file server should run as.  If
d1934 1
a1934 1
 * a file through an RFS link, except in the case the the last component is
@


1.34
log
@zap unused variables, ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.33 2004/01/23 03:48:43 deraadt Exp $	*/
d1855 4
a1858 8
	if (setegid((gid_t)grp->gr_gid) < 0)
		logerr("setegid: %%m");
	if (setgid((gid_t)grp->gr_gid) < 0)
		logerr("setgid: %%m");
	if (seteuid(pwd->pw_uid) < 0)
		logerr("seteuid: %%m");
	if (setuid(pwd->pw_uid) < 0)
		logerr("setuid: %%m");
d1866 2
a1867 4
	if (setegid(pwd->pw_gid) < 0)
		logerr("setegid: %%m");
	if (setgid(pwd->pw_gid) < 0)
		logerr("setgid: %%m");
d1872 2
a1873 4
	if (seteuid(pwd->pw_uid) < 0)
		logerr("seteuid: %%m");
	if (setuid(pwd->pw_uid) < 0)
		logerr("setuid: %%m");
@


1.33
log
@Use closefrom(); ok millert tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.32 2003/09/04 03:24:07 beck Exp $	*/
a742 2
			int fd;

@


1.32
log
@millert's sup fix, tested here on client and server.
committing in absentia for todd, ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.31 2003/03/10 03:53:32 david Exp $	*/
d754 1
a754 3
			fd = getdtablesize();
			while (--fd > 2)
				(void) close(fd);
@


1.31
log
@spelling fixes
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.30 2002/06/23 03:07:22 deraadt Exp $	*/
d391 1
d1323 2
a1324 2
	int x, fd;
	char temp_file[STRINGLENGTH];
d1340 1
a1340 1
                                char rcs_release[STRINGLENGTH];
d1342 4
a1345 1
				tmpnam(rcs_file);
d1392 6
a1397 1
                                                tmpnam(temp_file);
d1401 3
a1403 2
						if (runio(av, rcs_file,
						    temp_file, NULL) != 0) {
d1410 2
a1411 1
                                                fd = open(temp_file,O_RDONLY,0);
d1419 6
a1424 1
                                        tmpnam(temp_file);
d1428 3
a1430 1
					if (runio(av, t->Tname, temp_file, NULL) != 0) {
d1436 2
a1437 1
                                        fd = open(temp_file, O_RDONLY, 0);
d2127 16
@


1.31.2.1
log
@MFC:
Fixes by tedu@@ and beck@@

fp leak.  from Patrick Latifi.
and
millert's sup fix, tested here on client and server.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.31 2003/03/10 03:53:32 david Exp $	*/
a390 1
int opentmp(char *, size_t);
d1322 2
a1323 2
	int x, fd, ifd;
	char temp_file[MAXPATHLEN];
d1339 1
a1339 1
                                char rcs_release[MAXPATHLEN];
d1341 1
a1341 4
				fd = opentmp(rcs_file, sizeof(rcs_file));
				if (fd < 0)
					goaway ("We died trying to create temp file");
				close(fd);
d1388 1
a1388 6
                                                fd = opentmp(temp_file, sizeof(temp_file));
						if (fd < 0)
							goaway ("We died trying to create temp file");
						ifd = open(rcs_file, O_RDONLY, 0);
						if (ifd < 0)
							goaway ("We died trying to open %s", rcs_file);
d1392 2
a1393 3
						if (runiofd(av, ifd, fd, 2) != 0) {
							close(fd);
							close(ifd);
d1400 1
a1400 2
						lseek(fd, (off_t)0, SEEK_SET);
						close(ifd);
d1408 1
a1408 6
					fd = opentmp(temp_file, sizeof(temp_file));
					if (fd < 0)
						goaway ("We died trying to create temp file");
					ifd = open(t->Tname, O_RDONLY, 0);
					if (ifd < 0)
						goaway ("We died trying to open %s", t->Tname);
d1412 1
a1412 3
					if (runiofd(av, ifd, fd, 2) != 0) {
						close(fd);
						close(ifd);
d1418 1
a1418 2
					lseek(fd, (off_t)0, SEEK_SET);
					close(ifd);
a2107 16

int
opentmp(path, psize)
	char *path;
	size_t psize;
{
	char *tdir;

	if ((tdir = getenv("TMPDIR")) == NULL || *tdir == '\0')
		tdir = "/tmp";
	if (snprintf(path, psize, "%s/supfilesrv.XXXXXXXXXX", tdir) >= psize) {
		errno = ENAMETOOLONG;
		return (-1);
	}
	return (mkstemp(path));
}
@


1.30
log
@uid_t and gid_t are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.29 2002/06/12 06:07:16 mpech Exp $	*/
d1918 1
a1918 1
 *	     0 for file is definately not local, or it is an RFS link
@


1.30.2.1
log
@MFC:
Fixes by tedu@@ and beck@@

fp leak.  from Patrick Latifi.
and
millert's sup fix, tested here on client and server.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.30 2002/06/23 03:07:22 deraadt Exp $	*/
a390 1
int opentmp(char *, size_t);
d1322 2
a1323 2
	int x, fd, ifd;
	char temp_file[MAXPATHLEN];
d1339 1
a1339 1
                                char rcs_release[MAXPATHLEN];
d1341 1
a1341 4
				fd = opentmp(rcs_file, sizeof(rcs_file));
				if (fd < 0)
					goaway ("We died trying to create temp file");
				close(fd);
d1388 1
a1388 6
                                                fd = opentmp(temp_file, sizeof(temp_file));
						if (fd < 0)
							goaway ("We died trying to create temp file");
						ifd = open(rcs_file, O_RDONLY, 0);
						if (ifd < 0)
							goaway ("We died trying to open %s", rcs_file);
d1392 2
a1393 3
						if (runiofd(av, ifd, fd, 2) != 0) {
							close(fd);
							close(ifd);
d1400 1
a1400 2
						lseek(fd, (off_t)0, SEEK_SET);
						close(ifd);
d1408 1
a1408 6
					fd = opentmp(temp_file, sizeof(temp_file));
					if (fd < 0)
						goaway ("We died trying to create temp file");
					ifd = open(t->Tname, O_RDONLY, 0);
					if (ifd < 0)
						goaway ("We died trying to open %s", t->Tname);
d1412 1
a1412 3
					if (runiofd(av, ifd, fd, 2) != 0) {
						close(fd);
						close(ifd);
d1418 1
a1418 2
					lseek(fd, (off_t)0, SEEK_SET);
					close(ifd);
a2107 16

int
opentmp(path, psize)
	char *path;
	size_t psize;
{
	char *tdir;

	if ((tdir = getenv("TMPDIR")) == NULL || *tdir == '\0')
		tdir = "/tmp";
	if (snprintf(path, psize, "%s/supfilesrv.XXXXXXXXXX", tdir) >= psize) {
		errno = ENAMETOOLONG;
		return (-1);
	}
	return (mkstemp(path));
}
@


1.29
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.28 2002/02/19 19:39:39 millert Exp $	*/
d1694 1
a1694 1
				"Reason:  Unknown user id %d", fileuid);
@


1.28
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.27 2002/02/16 21:27:54 millert Exp $	*/
d321 1
a321 1
int progpid = -1;			/* and process id */
d401 2
a402 1
	int x,pid;
d655 2
a656 2
	printf("SUP Fileserver %d.%d (%s) %d on %s\n", protver, pgmver,
	    scmver, fspid, remotehost());
@


1.27
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.26 2001/08/23 19:31:28 camield Exp $	*/
a224 1
#ifdef __STDC__
a225 3
#else
#include <varargs.h>
#endif
a1871 1
#ifdef __STDC__
a1872 5
#else
/*VARARGS*//*ARGSUSED*/
goaway(va_alist)
va_dcl
#endif
a1876 1
#ifdef __STDC__
a1877 6
#else
	char *fmt;

	va_start(ap);
	fmt = va_arg(ap, char *);
#endif
@


1.26
log
@end request with 0, not NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.25 2001/08/12 12:03:03 heko Exp $	*/
d366 29
a394 29
int main __P((int, char **));
void chldsig __P((int));
void usage __P((void));
void init __P((int, char **));
void answer __P((void));
void srvsignon __P((void));
void srvsetup __P((void));
void docrypt __P((void));
void srvlogin __P((void));
void listfiles __P((void));
int denyone __P((TREE *, void *));
void sendfiles __P((void));
int sendone __P((TREE *, void *));
int senddir __P((TREE *, void *));
int sendfile __P((TREE *, va_list));
void srvfinishup __P((time_t));
void Hfree __P((HASH **));
HASH *Hlookup __P((HASH **, int, int ));
void Hinsert __P((HASH **, int, int, char *, TREE *));
TREE *linkcheck __P((TREE *, int, int ));
char *uconvert __P((uid_t));
char *gconvert __P((gid_t));
char *changeuid __P((char *, char *, uid_t, gid_t));
void goaway __P((char *, ...));
char *fmttime __P((time_t));
int local_file __P((int, struct stat *));
int stat_info_ok __P((struct stat *, struct stat *));
int link_nofollow __P((int));
int link_nofollow __P((int));
@


1.25
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.24 2001/05/07 19:26:02 millert Exp $	*/
d449 1
a449 1
		    NULL);      
d490 1
a490 1
			    netfile, NULL);      
@


1.24
log
@remove waitpid-related XXX's -- this is OK
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.23 2001/05/07 02:08:02 millert Exp $	*/
d249 1
a249 1
#else	CMUCS
d252 1
a252 1
#endif  CMUCS
@


1.23
log
@Use a smaller buffer in fmttime() since the date string is of a
known fixed size.
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.22 2001/05/04 22:16:17 millert Exp $	*/
a523 1
	/* XXX - should deal with suspended processes (millert) */
@


1.22
log
@o kill register
o lots of KNF
o passes -Wall
o fix some [ug]id_t vs. int issues
o use strlcpy/strlcat in favor of strncpy/strncat
o use mem* routines everywhere instead of old b* ones
o marked several questionable things for later fixing
o kill ci.c and cvt.c -- we don't use them
o kill read_line.c since it requires fgetln() (bad for portability)
o kill salloc.c since it is the same as strup()
o Replaced some #ifdef __OpenBSD__ with better tests
o remaining problems: malloc return values are rarely checked, select misuse
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.21 2001/05/02 22:56:54 millert Exp $	*/
d1910 1
a1910 1
fmttime (time)
d1913 1
a1913 1
	static char buf[STRINGLENGTH];
d1921 1
a1921 1
	(void) strlcpy(buf, p, strlen(p) - 5);
@


1.21
log
@Sync with NetBSD.  Notable changes:
 o Add libwrap support to supfilesrv, conditioned by #ifdef LIBWRAP
   (on by default). <bouyer@@netbsd.org>
 o Renamed '-l' (the 'live' mode) to '-d' and '-l' is now used to
   enable logging of successfull connections. <bouyer@@netbsd.org>
 o Don't botch varargs: the are not always an array of void * in the stack...
   Write a separate function to convert a list of function parameters to
   explain why execv failed. <christos@@netbsd.org>
 o When in compress mode, don't overwrite the destination file directly,
   write a temp file and use rename when it is done. (From James Mathiesen
   <james@@deshaw.com>)
 o Rename errno variable to error to avoid collision with errno.h and remove
   explicit extern of errno (we get it from errno.h) <mycroft@@netbsd.org>
 o Cleanup unsigned char vs. char
 o Add -u flag, that prevents sup from attempting to restore a and m times
   on the received files.
 o Replace the provided read_line function with calls to the fparseln function
   in libutil.  Maintain compatibility on machines without fparseln through
   the NEED_READ_LINE define.
 o Rename login() to suplogin() to avoid name collition in util.h
 o If rmdir() fails, chmod the path to have r/w/x perms and run "rm -rf"
 o avoid last.temp filename collision by using rel-suffix
 o When creating directories, make sure you remove previous non-directories
   before doing so, otherwise sup fails.
 o Add -q flag to supscan for quiet operation.
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.20 2001/04/29 18:16:19 millert Exp $	*/
d224 1
d253 1
d255 2
a256 2
#include <sys/vfs.h>
#include <linux/nfs_fs.h>
d277 9
d293 2
a294 2
int runas_uid = -1;
int runas_gid = -1;
d386 3
a388 3
char *uconvert __P((int));
char *gconvert __P((int));
char *changeuid __P((char *, char *, int, int ));
d405 1
a405 1
	register int x,pid;
d425 11
a435 12
	{
	  int r;
	  r=fork();
	  if (r>0) {
	    exit(0);
	  }
	  else if (r < 0) {
	    perror("fork:");
	    exit(1);
	  }
	  setsid();
	}
d438 4
a441 4
	logopen ("supfile");
	tloc = time ((time_t *)NULL);
	loginfo ("SUP File Server Version %d.%d (%s) starting at %s",
		PROTOVERSION,PGMVERSION,scmversion,fmttime (tloc));
d446 1
a446 1
			logquit (1,"Can't connect to network");
d457 1
a457 1
		if (clog) {
a458 1
		}
d460 3
a462 3
		answer ();
		(void) serviceend ();
		exit (0);
d468 3
a470 3
	(void) sigaction (SIGHUP,&ign,NULL);
	(void) sigaction (SIGINT,&ign,NULL);
	(void) sigaction (SIGPIPE,&ign,NULL);
d475 1
a475 1
	(void) sigaction (SIGCHLD,&chld,NULL);
d478 1
a478 1
		x = service ();
d480 2
a481 2
			logerr ("Error in establishing network connection");
			(void) servicekill ();
d503 8
a510 7
			(void) serviceprep ();
			answer ();
			(void) serviceend ();
			exit (0);
		}
		(void) servicekill ();	/* parent */
		if (pid > 0) nchildren++;
a517 1

d524 4
a527 2
	while (wait3((int *) &w, WNOHANG, (struct rusage *)0) > 0) {
		if (nchildren) nchildren--;
d536 1
a536 1
usage ()
d539 1
a539 1
	quit (1,"Usage: supfilesrv [ -l | -d | -P | -N | -C <max children> | -H <host> <user> <cryptfile> <supargs> ]\n");
d541 1
a541 1
	quit (1,"Usage: supfilesrv [ -d | -P | -N | -C <max children> | -H <host> <user> <cryptfile> <supargs> ]\n");
d546 8
a553 8
init (argc,argv)
int argc;
char **argv;
{
	register int i;
	register int x;
	char *clienthost,*clientuser;
	char *p,*q;
d556 1
a556 1
	register FILE *f;
d620 1
a620 1
			fprintf (stderr,"Unknown flag %s ignored\n",argv[0]);
d629 1
a629 1
		x = servicesetup (dbgportsq ? DEBUGFPORT : FILEPORT);
d631 1
a631 1
			quit (1,"Error in network setup");
d638 2
a639 2
		usage ();
	f = fopen (cryptkey,"r");
d641 4
a644 3
		quit (1,"Unable to open cryptfile %s\n",cryptkey);
	if ((p = fgets (buf,STRINGLENGTH,f)) != NULL) {
		if (q = strchr (p,'\n'))  *q = '\0';
d646 2
a647 2
			quit (1,"No cryptkey found in %s\n",cryptkey);
		cryptkey = salloc (buf);
d649 2
a650 2
	(void) fclose (f);
	x = request (dbgportsq ? DEBUGFPORT : FILEPORT,clienthost,&maxsleep);
d652 1
a652 1
		quit (1,"Unable to connect to host %s\n",clienthost);
d655 2
a656 2
		quit (1,"Error sending signon request to fileserver\n");
	x = msgsignonack ();
d658 4
a661 4
		quit (1,"Error reading signon reply from fileserver\n");
	printf ("SUP Fileserver %d.%d (%s) %d on %s\n",
		protver,pgmver,scmver,fspid,remotehost());
	free (scmver);
d664 1
a664 1
		quit (1,"Remote fileserver does not implement reverse sup\n");
d667 1
a667 1
	x = msgsetup ();
d669 2
a670 2
		quit (1,"Error sending setup request to fileserver\n");
	x = msgsetupack ();
d672 2
a673 2
		quit (1,"Error reading setup reply from fileserver\n");
	switch (setupack) {
d677 1
a677 1
		quit (1,"User %s not found on remote client\n",xuser);
d679 1
a679 1
		quit (1,"This host has no permission to reverse sup\n");
d681 1
a681 1
		quit (1,"Unrecognized file server setup status %d\n",setupack);
d683 2
a684 2
	if (netcrypt (cryptkey) != SCMOK )
		quit (1,"Running non-crypting fileserver\n");
d686 1
a686 1
	x = msgcrypt ();
d688 2
a689 2
		quit (1,"Error sending encryption test request\n");
	x = msgcryptok ();
d691 1
a691 1
		quit (1,"Data encryption test failed\n");
d693 1
a693 1
		quit (1,"Error reading encryption test reply\n");
d697 4
a700 4
	if (netcrypt (PSWDCRYPT) != SCMOK)	/* encrypt password data */
		quit (1,"Running non-crypting fileserver\n");
	x = msglogin ();
	(void) netcrypt ((char *)NULL);	/* turn off encryption */
d702 2
a703 2
		quit (1,"Error sending login request to file server\n");
	x = msglogack ();
d705 1
a705 1
		quit (1,"Error reading login reply from file server\n");
d707 1
a707 1
		quit (1,"%s\nImproper login to %s account\n",logerror,xuser);
d710 1
a710 1
	x = msgxpatch ();
d712 3
a714 3
		quit (1,"Error sending crosspatch request\n");
    	crosspatch ();
	exit (0);
d722 1
a722 1
answer ()
d725 1
a725 1
	register int x;
d727 1
a727 1
	progpid = fspid = getpid ();
d739 6
a744 6
	starttime = time ((time_t *)NULL);
	if (!setjmp (sjbuf)) {
		srvsignon ();
		srvsetup ();
		docrypt ();
		srvlogin ();
d748 1
a748 1
			x = msgxpatch ();
d750 1
a750 1
				exit (0);
d753 5
a757 5
			xargv[xargc] = (char *)NULL;
			(void) dup2 (netfile,0);
			(void) dup2 (netfile,1);
			(void) dup2 (netfile,2);
			fd = getdtablesize ();
d759 18
a776 13
				(void) close (fd);
			execvp (xargv[0],xargv);
			exit (0);
		}
		listfiles ();
		sendfiles ();
	}
	srvfinishup (starttime);
	if (collname)  free (collname);
	if (basedir)  free (basedir);
	if (prefix)  free (prefix);
	if (release)  free (release);
	if (rcs_branch)  free (rcs_branch);
d778 2
a779 1
	if (cvs_root)  free (cvs_root);
d784 1
a784 1
		free (goawayreason);
d786 6
a791 4
	if (donereason)  free (donereason);
	if (lockfd >= 0)  (void) close (lockfd);
	endpwent ();
	(void) endgrent ();
d793 1
a793 1
	endacent ();
d795 3
a797 3
	Hfree (uidH);
	Hfree (gidH);
	Hfree (inodeH);
d805 1
a805 1
srvsignon ()
d807 1
a807 1
	register int x;
d810 7
a816 5
	x = msgsignon ();
	if (x != SCMOK)  goaway ("Error reading signon request from client");
	x = msgsignonack ();
	if (x != SCMOK)  goaway ("Error sending signon reply to client");
	free (scmver);
d825 1
a825 1
srvsetup ()
d827 1
a827 1
	register int x;
d830 1
a830 1
	register FILE *f;
d832 1
a832 1
	register TREELIST *tl;
d834 1
a834 1
	if (protver > 7) {
d836 3
a838 3
	}
	x = msgsetup ();
	if (x != SCMOK)  goaway ("Error reading setup request from client");
d841 4
a844 3
		(void) msgsetupack ();
		if (protver >= 6)  longjmp (sjbuf,TRUE);
		goaway ("Sup client using obsolete version of protocol");
d847 1
a847 1
		register struct passwd *pw;
d849 1
a849 1
		if ((pw = getpwnam (xuser)) == NULL) {
d851 4
a854 3
			(void) msgsetupack ();
			if (protver >= 6)  longjmp (sjbuf,TRUE);
			goaway ("User `%s' not found", xuser);
d856 2
a857 2
		(void) free (xuser);
		xuser = salloc (pw->pw_dir);
d861 1
a861 1
		(void) snprintf (buf,sizeof buf,FILEXPATCH,xuser);
d868 1
a868 1
				(void) bzero((char *)&sbuf, sizeof(sbuf));
d870 1
a870 1
			if ((f = fopen (buf,"r")) != NULL) {
d873 11
a883 7
				while ((p = fgets (buf,STRINGLENGTH,f)) != NULL) {
					q = strchr (p,'\n');
					if (q)  *q = 0;
					if (strchr ("#;:",*p))  continue;
					q = nxtarg (&p," \t");
					if (*p == '\0')  continue;
					if (!matchhost(q)) continue;
d885 1
a885 1
					cryptkey = salloc (p);
d894 1
a894 1
				(void) fclose (f);
d903 4
a906 3
				(void) msgsetupack ();
				if (protver >= 6)  longjmp (sjbuf,TRUE);
				goaway ("Host not on access list");
d910 1
a910 1
		x = msgsetupack ();
d912 1
a912 1
			goaway ("Error sending setup reply to client");
d918 1
a918 1
                rcs_branch = salloc(&release[4]);
d920 1
a920 1
                release = salloc("RCS");
d925 1
a925 1
		release = salloc (DEFRELEASE);
d928 2
a929 2
		(void) snprintf (buf,sizeof buf,FILEDIRS,DEFDIR);
		f = fopen (buf,"r");
d931 10
a940 8
			while ((p = fgets (buf,STRINGLENGTH,f)) != NULL) {
				q = strchr (p,'\n');
				if (q)  *q = 0;
				if (strchr ("#;:",*p))  continue;
				q = nxtarg (&p," \t=");
				if (strcmp(q,collname) == 0) {
					basedir = skipover(p," \t=");
					basedir = salloc (basedir);
d944 1
a944 1
			(void) fclose (f);
d947 3
a949 2
			(void) snprintf (buf,sizeof buf,FILEBASEDEFAULT,collname);
			basedir = salloc(buf);
d952 4
a955 4
	if (chdir (basedir) < 0)
		goaway ("Can't chdir to base directory %s",basedir);
	(void) snprintf (buf,sizeof buf,FILEPREFIX,collname);
	f = fopen (buf,"r");
d957 10
a966 8
		while ((p = fgets (buf,STRINGLENGTH,f)) != NULL) {
			q = strchr (p,'\n');
			if (q)  *q = 0;
			if (strchr ("#;:",*p))  continue;
			prefix = salloc(p);
			if (chdir (prefix) < 0)
				goaway ("Can't chdir to %s from base directory %s",
					prefix,basedir);
d969 1
a969 1
		(void) fclose (f);
d971 3
a973 2
	x = stat (".",&sbuf);
	if (prefix)  (void) chdir (basedir);
d975 1
a975 1
		goaway ("Can't stat base/prefix directory");
d978 4
a981 3
		(void) msgsetupack ();
		if (protver >= 6)  longjmp (sjbuf,TRUE);
		goaway ("Sup client told to try again later");
d985 4
a988 3
		(void) msgsetupack ();
		if (protver >= 6)  longjmp (sjbuf,TRUE);
		goaway ("Attempt to upgrade to same directory on same host");
d991 1
a991 1
	if (!getrelease (release)) {
d993 4
a996 3
		(void) msgsetupack ();
		if (protver >= 6)  longjmp (sjbuf,TRUE);
		goaway ("Invalid release information");
d1004 2
a1005 2
		(void) snprintf (buf,sizeof buf,FILEHOST,collname,h);
		f = fopen (buf,"r");
d1008 2
a1009 1
			while ((p = fgets (buf,STRINGLENGTH,f)) != NULL) {
d1011 1
d1013 5
a1017 3
				if (q)  *q = 0;
				if (strchr ("#;:",*p))  continue;
				q = nxtarg (&p," \t");
d1019 1
a1019 1
					q = nxtarg (&p," \t");
d1022 4
a1025 2
					while ((*p == ' ') || (*p == '\t')) p++;
					if (*p)  cryptkey = salloc (p);
d1029 1
a1029 1
			(void) fclose (f);
d1032 5
a1036 4
				(void) msgsetupack ();
				if (protver >= 6)  longjmp (sjbuf,TRUE);
				goaway ("Host not on access list for %s",
					collname);
d1041 1
a1041 1
	(void) snprintf (buf,sizeof buf,FILELOCK,collname);
d1043 1
a1043 1
	x = open (buf,O_RDONLY,0);
d1045 2
a1046 2
		if (flock (x,(LOCK_SH|LOCK_NB)) < 0) {
			(void) close (x);
d1048 1
a1048 1
				goaway ("Can't lock collection %s",collname);
d1050 4
a1053 3
			(void) msgsetupack ();
			if (protver >= 6)  longjmp (sjbuf,TRUE);
			goaway ("Sup client told to wait for lock");
d1058 2
a1059 4
	if (oneconnect != NULL
	    && (lock_host_file(oneconnect) < 0)) {
	  goaway("I'm still working on a previous request from your host.");
	}
d1061 3
a1063 2
	x = msgsetupack ();
	if (x != SCMOK)  goaway ("Error sending setup reply to client");
d1066 1
d1068 1
a1068 2
/** Test data encryption **/
docrypt ()
d1070 1
a1070 1
	register int x;
d1073 1
a1073 1
	register FILE *f;
d1077 1
a1077 1
		(void) snprintf (buf,sizeof buf,FILECRYPT,collname);
d1083 1
a1083 1
				(void) bzero((char *)&sbuf, sizeof(sbuf));
d1085 1
a1085 1
			if ((f = fopen (buf,"r")) != NULL) {
d1089 2
a1090 2
				    (p = fgets (buf,STRINGLENGTH,f))) {
					if ((q = strchr (p,'\n')) != NULL)
d1092 2
a1093 1
					if (*p)  cryptkey = salloc (buf);
d1100 1
a1100 1
				(void) fclose (f);
d1104 1
a1104 1
				goaway ("Restore link following");
d1107 9
a1115 9
	if ( netcrypt (cryptkey) != SCMOK )
		goaway ("Runing non-crypting supfilesrv");
	x = msgcrypt ();
	if (x != SCMOK)
		goaway ("Error reading encryption test request from client");
	(void) netcrypt ((char *)NULL);
	if (strcmp(crypttest,CRYPTTEST) != 0)
		goaway ("Client not encrypting data properly");
	free (crypttest);
d1117 1
a1117 1
	x = msgcryptok ();
d1119 1
a1119 1
		goaway ("Error sending encryption test reply to client");
d1127 1
a1127 1
srvlogin ()
d1129 11
a1139 8
	register int x,fileuid = -1,filegid = -1;

	(void) netcrypt (PSWDCRYPT);	/* encrypt acct name and password */
	x = msglogin ();
	(void) netcrypt ((char *)NULL); /* turn off encryption */
	if (x != SCMOK)  goaway ("Error reading login request from client");
	if ( logcrypt ) {
	    if (strcmp(logcrypt,CRYPTTEST) != 0) {
d1142 2
a1143 2
		(void) msglogack ();
		goaway ("Client not encrypting login information properly");
d1145 1
a1145 1
	    free (logcrypt);
d1150 1
a1150 1
			if (runas_uid >= 0 && runas_gid >= 0) {
d1155 1
a1155 1
				loguser = salloc (DEFUSER);
d1157 1
a1157 1
			loguser = salloc (DEFUSER);
d1159 1
a1159 1
	if ((logerror = changeuid (loguser,logpswd,fileuid,filegid)) != NULL) {
d1161 9
a1169 6
		(void) msglogack ();
		if (protver >= 6)  longjmp (sjbuf,TRUE);
		goaway ("Client denied login access");
	}
	if (loguser)  free (loguser);
	if (logpswd)  free (logpswd);
d1171 5
a1175 4
	x = msglogack ();
	if (x != SCMOK)  goaway ("Error sending login reply to client");
	if (!xpatch)  /* restore desired encryption */
		if (netcrypt (cryptkey) != SCMOK)
d1177 1
a1177 1
	free (cryptkey);
d1186 1
a1186 1
listfiles ()
d1188 1
a1188 1
	register int x;
d1191 9
a1199 7
	x = msgrefuse ();
	if (x != SCMOK)  goaway ("Error reading refuse list from client");
	getscanlists ();
	Tfree (&refuseT);
	x = msglist ();
	if (x != SCMOK)  goaway ("Error sending file list to client");
	Tfree (&listT);
d1202 1
a1202 1
	x = msgneed ();
d1204 1
a1204 1
		goaway ("Error reading needed files list from client");
d1206 6
a1211 5
	(void) Tprocess (needT,denyone, NULL);
	Tfree (&needT);
	x = msgdeny ();
	if (x != SCMOK)  goaway ("Error sending denied files list to client");
	Tfree (&denyT);
d1216 7
a1222 7
denyone (t, v)
register TREE *t;
void *v;
{
	register TREELIST *tl;
	register char *name = t->Tname;
	register int update = (t->Tflags&FUPDATE) != 0;
d1224 1
a1224 1
	register TREE *tlink;
d1226 1
a1226 1
	register int x;
d1229 1
a1229 1
		if ((t = Tsearch (tl->TLtree,name)) != NULL)
d1232 1
a1232 1
		(void) Tinsert (&denyT,name,FALSE);
d1235 1
a1235 1
	cdprefix (tl->TLprefix);
d1237 1
a1237 1
		x = lstat(name,&sbuf);
d1239 1
a1239 1
		x = stat(name,&sbuf);
d1241 1
a1241 1
		(void) Tinsert (&denyT,name,FALSE);
d1246 2
a1247 2
		if ((x = readlink (name,slinkname,sizeof slinkname-1)) <= 0) {
			(void) Tinsert (&denyT,name,FALSE);
d1251 1
a1251 1
		(void) Tinsert (&t->Tlink,slinkname,FALSE);
d1255 1
a1255 1
		    (tlink = linkcheck (t,(int)sbuf.st_dev,(int)sbuf.st_ino)))
d1257 1
a1257 1
			(void) Tinsert (&tlink->Tlink,name,FALSE);
d1260 2
a1261 1
		if (update)  t->Tflags |= FUPDATE;
d1267 1
a1267 1
		(void) Tinsert (&denyT,name,FALSE);
d1279 1
a1279 1
sendfiles ()
d1281 2
a1282 2
	register TREELIST *tl;
	register int x;
d1289 1
a1289 1
			goaway ("Error sending compression check to server");
d1293 1
a1293 1
		cdprefix (tl->TLprefix);
d1305 1
a1305 1
		(void) Tprocess (tl->TLtree,sendone, NULL);
d1309 2
a1310 2
		cdprefix (tl->TLprefix);
		(void) Trprocess (tl->TLtree,senddir, NULL);
d1312 1
a1312 1
	x = msgsend ();
d1314 1
a1314 1
		goaway ("Error reading receive file request from client");
d1316 1
a1316 1
	x = msgrecv (sendfile,0);
d1318 1
a1318 1
		goaway ("Error sending file to client");
d1322 3
a1324 3
sendone (t, v)
TREE *t;
void *v;
d1326 1
a1326 1
	register int x,fd;
d1334 3
a1336 2
	x = msgsend ();
	if (x != SCMOK)  goaway ("Error reading receive file request from client");
d1369 1
a1369 1
						    "-r%s",rcs_branch);
d1376 1
a1376 1
							"/dev/null");
d1382 1
a1382 1
                                                        goaway ("We died trying to run cvs or rcs on %s", rcs_file);
d1384 1
a1384 2
                                                }
                                                else {
d1391 1
a1391 2
                                        }
                                        else if (docompress) {
d1396 2
a1397 1
						if (runio(av, rcs_file, temp_file, NULL) != 0) {
d1401 1
a1401 1
                                                        goaway ("We died trying to gzip %s", rcs_file);
d1404 2
a1405 3
                                                fd = open (temp_file,O_RDONLY,0);
                                        }
                                        else
d1419 1
a1419 1
                                                goaway ("We died trying to run gzip %s", t->Tname);
d1422 3
a1424 4
                                        fd = open (temp_file,O_RDONLY,0);
                                }
                                else
                                        fd = open (t->Tname,O_RDONLY,0);
d1426 2
a1427 1
			if (fd < 0 && (t->Tflags&FUPDATE) == 0)  t->Tmode = 0;
d1430 2
a1431 2
			t->Tuser = salloc (uconvert (t->Tuid));
			t->Tgroup = salloc (gconvert (t->Tgid));
d1434 1
a1434 1
	x = msgrecv (sendfile,fd);
d1441 2
a1442 1
	if (x != SCMOK)  goaway ("Error sending file %s to client", t->Tname);
d1447 3
a1449 3
senddir (t, v)
TREE *t;
void *v;
d1451 1
a1451 1
	register int x;
d1457 3
a1459 2
	x = msgsend ();
	if (x != SCMOK)  goaway ("Error reading receive file request from client");
d1461 5
a1465 4
	t->Tuser = salloc (uconvert (t->Tuid));
	t->Tgroup = salloc (gconvert (t->Tgid));
	x = msgrecv (sendfile,0);
	if (x != SCMOK)  goaway ("Error sending file %s to client", t->Tname);
d1474 1
a1474 1
	register int x, fd;
d1479 4
a1482 3
	x = writefile (fd);
	if (x != SCMOK)  goaway ("Error sending file %s to client", t->Tname);
        (void) close (fd);
d1491 2
a1492 2
srvfinishup (starttime)
time_t starttime;
d1494 2
a1495 2
	register int x = SCMOK;
	char tmpbuf[BUFSIZ], *p, lognam[STRINGLENGTH];
d1500 5
a1504 1
	(void) netcrypt ((char *)NULL);
d1507 2
a1508 2
			free (goawayreason);
		goawayreason = (char *)NULL;
d1511 3
a1513 3
		donereason = salloc ("Unknown");
	} else if (goawayreason == (char *)NULL)
		x = msgdone ();
d1520 1
a1520 1
		donereason = salloc ("Premature EOF on network");
d1523 1
a1523 1
		donereason = salloc ("Unknown SCM code");
d1528 1
a1528 1
		donereason = salloc ("No reason");
d1530 1
a1530 1
		logerr ("%s", donereason);
d1532 1
a1532 1
		logerr ("GOAWAY: %s",donereason);
d1534 1
a1534 1
		logerr ("Reason %d:  %s",doneack,donereason);
d1536 1
a1536 1
	cdprefix ((char *)NULL);
d1538 1
a1538 1
		logerr ("NULL collection in svrfinishup");
d1541 2
a1542 2
	(void) snprintf (lognam,sizeof lognam,FILELOGFILE,collname);
	if ((logfd = open(lognam,O_APPEND|O_WRONLY,0644)) < 0)
a1543 8
	finishtime = time ((time_t *)NULL);
	p = tmpbuf;
	(void) snprintf (p,sizeof tmpbuf-(p-tmpbuf),"%s ",fmttime (lasttime));
	p += strlen(p);
	(void) snprintf (p,sizeof tmpbuf-(p-tmpbuf),"%s ",fmttime (starttime));
	p += strlen(p);
	(void) snprintf (p,sizeof tmpbuf-(p-tmpbuf),"%s ",fmttime (finishtime));
	p += strlen(p);
d1546 5
a1550 3
	(void) snprintf (p,sizeof tmpbuf-(p-tmpbuf),"%s %s %d %s\n",
		remotehost(),releasename, FDONESUCCESS-doneack,donereason);
	p += strlen(p);
d1553 3
a1555 3
	if(setupack == FSETUPBUSY) {
	    long l = FIOCNOSPC_ERROR;
	    ioctl(logfd, FIOCNOSPC, &l);
d1558 1
a1558 1
	(void) write(logfd,tmpbuf,(p - tmpbuf));
d1567 2
a1568 2
Hfree (table)
HASH **table;
d1570 3
a1572 2
	register HASH *h;
	register int i;
d1576 3
a1578 2
			if (h->Hname)  free (h->Hname);
			free ((char *)h);
d1582 4
a1585 3
HASH *Hlookup (table,num1,num2)
HASH **table;
int num1,num2;
d1587 7
a1593 4
	register HASH *h;
	register int hno;
	hno = HASHFUNC(num1,num2);
	for (h = table[hno]; h && (h->Hnum1 != num1 || h->Hnum2 != num2); h = h->Hnext);
d1598 11
a1608 10
Hinsert (table,num1,num2,name,tree)
HASH **table;
int num1,num2;
char *name;
TREE *tree;
{
	register HASH *h;
	register int hno;
	hno = HASHFUNC(num1,num2);
	h = (HASH *) malloc (sizeof(HASH));
d1621 25
a1645 19
TREE *linkcheck (t,d,i)
TREE *t;
int d,i;			/* inode # and device # */
{
	register HASH *h;
	h = Hlookup (inodeH,i,d);
	if (h)  return (h->Htree);
	Hinsert (inodeH,i,d,(char *)NULL,t);
	return ((TREE *)NULL);
}

char *uconvert (uid)
int uid;
{
	register struct passwd *pw;
	register char *p;
	register HASH *u;
	u = Hlookup (uidH,uid,0);
	if (u)  return (u->Hname);
d1647 4
a1650 3
	if (pw == NULL)  return ("");
	p = salloc (pw->pw_name);
	Hinsert (uidH,uid,0,p,(TREE*)NULL);
d1654 16
a1669 12
char *gconvert (gid)
int gid;
{
	register struct group *gr;
	register char *p;
	register HASH *g;
	g = Hlookup (gidH,gid,0);
	if (g)  return (g->Hname);
	gr = getgrgid (gid);
	if (gr == NULL)  return ("");
	p = salloc (gr->gr_name);
	Hinsert (gidH,gid,0,p,(TREE *)NULL);
d1673 5
a1677 3
char *changeuid (namep,passwordp,fileuid,filegid)
char *namep,*passwordp;
int fileuid,filegid;
d1686 1
a1686 1
	register int status = ACCESS_CODE_OK;
d1695 1
a1695 1
		pwd = getpwuid (fileuid);
d1697 2
a1698 3
			(void) snprintf (errbuf,sizeof errbuf,
				"Reason:  Unknown user id %d",
				fileuid);
d1701 5
a1705 6
		grp = getgrgid (filegid);
		if (grp) {
			group = strncpy (nbuf,grp->gr_name, sizeof nbuf-1);
			nbuf[sizeof nbuf-1] = '\0';
		}
		else  group = NULL;
d1709 2
a1710 3
		(void) strncpy (nbuf,namep, sizeof nbuf-1);
		nbuf[sizeof nbuf-1] = '\0';
		account = group = strchr (nbuf,',');
d1713 1
a1713 1
			account = strchr (group,',');
d1716 2
a1717 1
				if (*account == '\0')  account = NULL;
d1719 2
a1720 1
			if (*group == '\0')  group = NULL;
d1722 1
a1722 1
		pwd = getpwnam (nbuf);
d1724 2
a1725 3
			(void) snprintf (errbuf,sizeof errbuf,
				"Reason:  Unknown user %s",
				nbuf);
d1728 1
a1728 1
		if (strcmp (nbuf,DEFUSER) == 0)
d1733 1
a1733 1
                if (strcmp (nbuf,DEFUSER) != 0) {
d1735 1
d1739 1
a1739 1
                                (void) snprintf (errbuf,sizeof errbuf,
d1742 1
a1742 2
                                logerr ("Attempt by %s; %s",
                                        nbuf, errbuf);
d1748 2
a1749 2
	if (getuid () != 0) {
		if (getuid () == pwd->pw_uid)
d1751 1
a1751 1
		if (strcmp (pwd->pw_name,DEFUSER) == 0)
d1753 1
a1753 1
		logerr ("Fileserver not superuser");
d1764 2
a1765 1
		status = oklogin(pwd->pw_name,group,&account,pswdp,&pwd,&grp,&acc,&grps);
d1767 1
a1767 1
			if ((p = okpassword(pswdp,pwd->pw_name,pwd->pw_gecos)) != NULL)
d1774 1
a1774 1
		if (strcmp(pwd->pw_passwd,(char *)crypt(pswdp,pwd->pw_passwd)))
d1785 1
a1785 1
		(void) snprintf (errbuf,sizeof errbuf,"Reason:  %s",p);
d1826 2
a1827 2
		(void) snprintf (errbuf,sizeof errbuf,
			"Reason:  Status %d",status);
d1834 2
a1835 2
		logerr ("Login failure for %s",pwd->pw_name);
		logerr ("%s",p);
d1837 1
a1837 1
		logaccess (pwd->pw_name,ACCESS_TYPE_SUP,status,0,-1,tlc);
d1842 10
a1851 10
	if (setgroups (grps[0], &grps[1]) < 0)
		logerr ("setgroups: %%m");
	if (setegid ((gid_t)grp->gr_gid) < 0)
		logerr ("setegid: %%m");
	if (setgid ((gid_t)grp->gr_gid) < 0)
		logerr ("setgid: %%m");
	if (seteuid ((uid_t)pwd->pw_uid) < 0)
		logerr ("seteuid: %%m");
	if (setuid ((uid_t)pwd->pw_uid) < 0)
		logerr ("setuid: %%m");
d1855 1
a1855 1
		return("Error setting user context");
d1857 6
a1862 6
	if (initgroups (pwd->pw_name,pwd->pw_gid) < 0)
		return("Error setting group list");
	if (setegid (pwd->pw_gid) < 0)
		logerr ("setegid: %%m");
	if (setgid (pwd->pw_gid) < 0)
		logerr ("setgid: %%m");
d1864 2
a1865 2
	if (setlogin (pwd->pw_name) < 0)
		logerr ("setlogin: %%m");
d1867 4
a1870 4
	if (seteuid (pwd->pw_uid) < 0)
		logerr ("seteuid: %%m");
	if (setuid (pwd->pw_uid) < 0)
		logerr ("setuid: %%m");
d1878 1
a1878 1
goaway (char *fmt,...)
d1881 1
a1881 1
goaway (va_alist)
d1889 1
a1889 1
	va_start(ap,fmt);
d1891 1
a1891 1
	register char *fmt;
d1894 1
a1894 1
	fmt = va_arg(ap,char *);
d1896 1
a1896 1
	(void) netcrypt ((char *)NULL);
d1900 7
a1906 7
	strcat(buf, " [");
	strcat(buf, remotehost());
	strcat(buf, "]");
	goawayreason = salloc (buf);
	(void) msggoaway ();
	logerr ("%s",buf);
	longjmp (sjbuf,TRUE);
d1909 3
a1911 2
char *fmttime (time)
time_t time;
d1914 1
a1914 1
	int len;
d1916 6
a1921 5
	(void) strncpy (buf,ctime (&time), sizeof buf-1);
	buf[sizeof buf-1] = '\0';
	len = strlen(buf+4)-6;
	(void) strncpy (buf,buf+4,len);		/* XXX TDR */
	buf[len] = '\0';
d1973 2
a1974 2
int handle;
struct stat *sinfo;
a2028 1

d2078 3
a2080 4


int stat_info_ok(sb1, sb2)
struct stat *sb1, *sb2;
d2082 12
a2093 12
    return (sb1->st_ino == sb2->st_ino &&	/* Still the same file */
	    sb1->st_dev == sb2->st_dev &&	/* On the same device */
	    sb1->st_mode == sb2->st_mode &&     /* Perms (and type) same */
	    S_ISREG(sb1->st_mode) &&		/* Only allow reg files */
	    (sb1->st_mode & 077) == 0 &&	/* Owner only perms */
	    sb1->st_nlink == sb2->st_nlink &&	/* # hard links same... */
	    sb1->st_nlink == 1 &&		/* and only 1 */
	    sb1->st_uid == sb2->st_uid &&	/* owner and ... */
	    sb1->st_gid == sb2->st_gid &&	/* group unchanged */
	    sb1->st_mtime == sb2->st_mtime &&	/* Unmodified between stats */
	    sb1->st_ctime == sb2->st_ctime);	/* Inode unchanged.  Hopefully
						   a catch-all paranoid test */
d2104 3
a2106 2
int link_nofollow(on)
int on;
d2118 3
a2120 2
int link_nofollow(on)
int on;
@


1.20
log
@Use S_ISXXX macros where possible instead of doing this by hand
Noticed while diffing against NetBSD version
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.19 2001/03/09 03:19:51 deraadt Exp $	*/
d19 1
a19 1
 *  Software Distribution Coordinator  or  Software_Distribution@@CS.CMU.EDU
d31 3
a33 2
 * Usage:  supfilesrv [-l] [-P] [-N] [-R] [-S] [-O]
 *	-l	"live" -- don't fork daemon
a37 1
 *      -O      "One Connection" -- Reject servicing multiple connections
d41 3
d52 70
d262 4
d319 1
a319 1
char *oneconnect = NULL;	        /* -O flag */
d321 4
a324 1
int live;				/* -l flag */
d398 3
d434 1
d437 14
d479 15
d527 5
a531 1
	quit (1,"Usage: supfilesrv [ -l | -P | -N | -C <max children> | -H <host> <user> <cryptfile> <supargs> ]\n");
d551 3
d567 1
d569 4
d830 1
a830 1
			goaway ("User `%s' not found",xuser);
d1190 1
a1190 1
		if ((x = readlink (name,slinkname,STRINGLENGTH-1)) <= 0) {
d1248 1
a1248 1
		(void) Tprocess (tl->TLtree,sendone,NULL);
d1253 1
a1253 1
		(void) Trprocess (tl->TLtree,senddir,NULL);
d1329 2
a1330 2
							logerr("rcs command failed = %d\n",
								WEXITSTATUS(status));
d1411 3
a1413 3
sendfile (t, ap)
TREE *t;
va_list ap;
d1473 4
d1491 1
a1491 2
		remotehost(),releasename,
		FDONESUCCESS-doneack,donereason);
@


1.19
log
@exit(-#) is wrong
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.18 2000/08/20 18:42:42 millert Exp $	*/
d1055 1
a1055 1
	if ((t->Tmode&S_IFMT) == S_IFLNK)
d1150 1
a1150 1
	if ((t->Tmode&S_IFMT) == S_IFDIR) /* send no directories this pass */
d1156 1
a1156 1
	if ((t->Tmode&S_IFMT) == S_IFREG) {
d1273 1
a1273 1
	if ((t->Tmode&S_IFMT) != S_IFDIR) /* send only directories this pass */
d1293 1
a1293 1
	if ((t->Tmode&S_IFMT) != S_IFREG || listonly || (t->Tflags&FUPDATE))
d1798 1
a1798 1
	if ((sb.st_mode & S_IFMT) == S_IFLNK)
d1880 1
a1880 1
	    (sb1->st_mode & S_IFMT) == S_IFREG && /* Only allow reg files */
@


1.18
log
@Add calls to setusercontext() and login_get*().  We basically call
setusercontext() in most places where previously we did a setlogin().
Add default login.conf file and put root in the "daemon" login class.
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.17 2000/02/01 03:23:40 deraadt Exp $	*/
d339 1
a339 1
	    exit(-1);
@


1.17
log
@no need to extern int errno if errno.h is included
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.16 2000/01/21 00:26:48 millert Exp $	*/
d189 4
d1648 4
d1666 1
@


1.16
log
@Deal with getcwd() returning NULL.  This code is not currently
compiled but dixing it now means that it won't get flagged again
in a future audit.  Noted by Oleg Safiullin <form@@vell.nsc.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.15 1998/06/03 16:20:38 deraadt Exp $	*/
a193 1
extern int errno;
@


1.15
log
@zero sigaction before use
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.14 1998/05/18 19:13:39 deraadt Exp $	*/
d1111 2
a1112 2
                        cvs_root = getcwd(NULL, 256);
                        if (access("CVSROOT", F_OK) < 0)
@


1.14
log
@readlink len-1
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.13 1997/11/17 08:54:05 deraadt Exp $	*/
d354 1
d361 1
@


1.13
log
@match nfs3 and regular nfs; christos
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.12 1997/10/11 23:34:21 beck Exp $	*/
d1060 1
a1060 1
		if ((x = readlink (name,slinkname,STRINGLENGTH)) <= 0) {
@


1.12
log
@ -Kludges for SunOS 5 portablility,

 -Added -O option to supfilesrv. -O lockdir make serving process
 lock file in lockdir for each connecting ip address.  Will refuse a
 second connection from a host it's already serving a request for.
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.11 1997/09/16 11:01:23 deraadt Exp $	*/
d1819 1
a1819 1
		return strcmp(sf.f_basetype, "nfs") != 0;
d1826 1
a1826 1
		return strcmp(sf.f_fstypename, "nfs") != 0;
@


1.11
log
@strcpy whacking; ci.c and expand.c need more work
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.10 1997/09/16 10:42:59 deraadt Exp $	*/
d31 1
a31 1
 * Usage:  supfilesrv [-l] [-P] [-N] [-R] [-S]
d37 1
d239 1
d324 1
a325 1
	if (!live)			/* if not debugging, turn into daemon */
d327 13
d457 6
d882 4
d1649 1
d1652 1
@


1.10
log
@snprintf this thing
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.9 1997/09/08 23:59:43 millert Exp $	*/
d1467 4
a1470 1
		if (grp)  group = strcpy (nbuf,grp->gr_name);
d1475 2
a1476 1
		(void) strcpy (nbuf,namep);
d1673 2
a1674 1
	(void) strcpy (buf,ctime (&time));
d1676 1
a1676 1
	(void) strncpy (buf,buf+4,len);
@


1.9
log
@Use setlogin(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.8 1997/07/25 21:05:42 mickey Exp $	*/
d686 1
a686 1
		(void) sprintf (buf,FILEXPATCH,xuser);
d748 1
a748 1
		(void) sprintf (buf,FILEDIRS,DEFDIR);
d765 1
a765 1
			(void) sprintf (buf,FILEBASEDEFAULT,collname);
d771 1
a771 1
	(void) sprintf (buf,FILEPREFIX,collname);
d815 1
a815 1
		(void) sprintf (buf,FILEHOST,collname,h);
d845 1
a845 1
	(void) sprintf (buf,FILELOCK,collname);
d877 1
a877 1
		(void) sprintf (buf,FILECRYPT,collname);
d1154 3
a1156 2
						sprintf(rcs_release, "-r%s",
							rcs_branch);
d1318 1
a1318 1
	(void) sprintf (lognam,FILELOGFILE,collname);
d1323 1
a1323 1
	(void) sprintf (p,"%s ",fmttime (lasttime));
d1325 1
a1325 1
	(void) sprintf (p,"%s ",fmttime (starttime));
d1327 1
a1327 1
	(void) sprintf (p,"%s ",fmttime (finishtime));
d1331 2
a1332 1
	(void) sprintf (p,"%s %s %d %s\n",remotehost(),releasename,
d1461 2
a1462 1
			(void) sprintf (errbuf,"Reason:  Unknown user id %d",
d1485 2
a1486 1
			(void) sprintf (errbuf,"Reason:  Unknown user %s",
d1500 3
a1502 2
                                (void) sprintf (errbuf,"AFS authentication failed, %s",
                                                reason);
d1546 1
a1546 1
		(void) sprintf (errbuf,"Reason:  %s",p);
d1587 3
a1589 1
		(void) sprintf (p = errbuf,"Reason:  Status %d",status);
@


1.8
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.7 1997/04/01 07:35:43 todd Exp $	*/
d1613 2
@


1.7
log
@This merges in the latest NetBSD sup source.
- removed $Log: ...$ tags to not waste space in the repository
- now doesn't segfault on the alpha!

Note:
To compile sup on systems other than *BSD, you'll need a copy of
vis.c, vis.h, daemon.c, and sys/cdefs.h.  At least the first two
(for OSF/1).

From NetBSD changelog description (for credit where due):
.... 1996/12/23 19:42:05  christos
- add missing prototypes.
- fix function call inconsistencies
- fix int <-> long and pointer conversions
It should run now on 64 bit machines...

....  1996/12/31 18:08:00  christos
64 bit patches (mostly long -> time_t) from Matthew Jacob (?)
sup now works on the alpha!
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.6 1997/01/17 07:18:10 millert Exp $	*/
d150 1
a150 1
#if __STDC__
@


1.6
log
@more r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.5 1996/12/22 03:26:05 tholo Exp $	*/
d27 1
d31 1
a31 1
 * Usage:  supfilesrv [-l] [-P] [-N] [-R]
d36 1
a47 110
 * $Log: supfilesrv.c,v $
 * Revision 1.5  1996/12/22 03:26:05  tholo
 * Deal with _POSIX_SAVED_IDS when relinquishing privileges
 *
 * Revision 1.4  1996/07/31 11:11:31  niklas
 * Better use time_t instead of long when dealing with times
 *
 * Revision 1.3  1996/06/26 05:39:54  deraadt
 * rcsid
 *
 * Revision 1.2  1996/06/10 20:45:35  deraadt
 * hack: print hostname connection failed with
 *
 * Revision 1.1  1995/12/16 11:46:59  deraadt
 * add sup to the tree
 *
 * Revision 1.8  1995/10/29 23:54:49  christos
 * - runio fails when result != 0 not only < 0
 * - print vis-encoded file in the scanner.
 *
 * Revision 1.7  1995/06/24 16:21:55  christos
 * - Don't use system(3) to fork processes. It is a big security hole.
 * - Encode the filenames in the scan files using strvis(3), so filenames
 *   that contain newlines or other weird characters don't break the scanner.
 *
 * Revision 1.6  1995/06/03 21:22:00  christos
 * Changes to write ascii timestamps in the when files.
 * Looked into making it 64 bit clean, but it is hopeless.
 * Added little program to convert from the old timestamp files
 * into the new ones.
 *
 * Revision 1.5  1993/08/04 17:46:21  brezak
 * Changes from nate for gzip'ed sup
 *
 * Revision 1.3  1993/06/05  21:32:17  cgd
 * use daemon() to put supfilesrv into daemon mode...
 *
 * Revision 1.2  1993/05/24  17:57:31  brezak
 * Remove netcrypt.c. Remove unneeded files. Cleanup make.
 *
 * Revision 1.20  92/09/09  22:05:00  mrt
 * 	Added Brad's change to make sendfile take a va_list.
 * 	Added support in login to accept an non-encrypted login
 * 	message if no user or password is being sent. This supports
 * 	a non-crypting version of sup. Also fixed to skip leading
 * 	white space from crypts in host files.
 * 	[92/09/01            mrt]
 * 
 * Revision 1.19  92/08/11  12:07:59  mrt
 * 		Made maxchildren a patchable variable, which can be set by the
 * 		command line switch -C or else defaults to the MAXCHILDREN
 * 		defined in sup.h. Added most of Brad's STUMP changes.
 * 	Increased PGMVERSION to 12 to reflect substantial changes.
 * 	[92/07/28            mrt]
 * 
 * Revision 1.18  90/12/25  15:15:39  ern
 * 	Yet another rewrite of the logging code. Make up the text we will write
 * 	   and then get in, write it and get out.
 * 	Also set error on write-to-full-disk if the logging is for recording
 * 	   server is busy.
 * 	[90/12/25  15:15:15  ern]
 * 
 * Revision 1.17  90/05/07  09:31:13  dlc
 * 	Sigh, some more fixes to the new "crypt" file handling code.  First,
 * 	just because the "crypt" file is in a local file system does not mean
 * 	it can be trusted.  We have to check for hard links to root owned
 * 	files whose contents could be interpretted as a crypt key.  For
 * 	checking this fact, the new routine stat_info_ok() was added.  This
 * 	routine also makes other sanity checks, such as owner only permission,
 * 	the file is a regular file, etc.  Also, even if the uid/gid of th
 * 	"crypt" file is not going to be used, still use its contents in order
 * 	to cause fewer surprises to people supping out of a shared file system
 * 	such as AFS.
 * 	[90/05/07            dlc]
 * 
 * Revision 1.16  90/04/29  04:21:08  dlc
 * 	Fixed logic bug in docrypt() which would not get the stat information
 * 	from the crypt file if the crypt key had already been set from a
 * 	"host" file.
 * 	[90/04/29            dlc]
 * 
 * Revision 1.15  90/04/18  19:51:27  dlc
 * 	Added the new routines local_file(), link_nofollow() for use in
 * 	dectecting whether a file is located in a local file system.  These
 * 	routines probably should have been in another module, but only
 * 	supfilesrv needs to do the check and none of its other modules seemed
 * 	appropriate.  Note, the implementation should be changed once we have
 * 	direct kernel support, for example the fstatfs(2) system call, for
 * 	detecting the type of file system a file resides.  Also, I changed
 * 	the routines which read the crosspatch crypt file or collection crypt
 * 	file to save the uid and gid from the stat information obtained via
 * 	the local_file() call (when the file is local) at the same time the
 * 	crypt key is read.  This change disallows non-local files for the
 * 	crypt key to plug a security hole involving the usage of the uid/gid
 * 	of the crypt file to define who the the file server should run as.  If
 * 	the saved uid/gid are both valid, then the server will set its uid/gid
 * 	to these values.
 * 	[90/04/18            dlc]
 * 
 * Revision 1.14  89/08/23  14:56:15  gm0w
 * 	Changed msgf routines to msg routines.
 * 	[89/08/23            gm0w]
 * 
 * Revision 1.13  89/08/03  19:57:33  mja
 * 	Remove setaid() call.
 * 
 * Revision 1.12  89/08/03  19:49:24  mja
 * 	Updated to use v*printf() in place of _doprnt().
 * 	[89/04/19            mja]
 * 
d149 1
d160 2
d163 3
d178 12
a189 1
#include "sup.h"
a192 5
#ifdef	lint
/*VARARGS1*//*ARGSUSED*/
static void quit(status) {};
#endif	/* lint */

a193 2
uid_t getuid ();

d238 1
d268 31
a298 4
char *fmttime ();			/* time format routine */
#if __STDC__
int goaway(char *fmt,...);
#endif
d304 1
d309 3
a311 3
	register int x,pid,signalmask;
	struct sigvec chldvec,ignvec,oldvec;
	void chldsig();
d339 10
a348 10
	ignvec.sv_handler = SIG_IGN;
	ignvec.sv_onstack = 0;
	ignvec.sv_mask = 0;
	(void) sigvec (SIGHUP,&ignvec,&oldvec);
	(void) sigvec (SIGINT,&ignvec,&oldvec);
	(void) sigvec (SIGPIPE,&ignvec,&oldvec);
	chldvec.sv_handler = chldsig;
	chldvec.sv_mask = 0;
	chldvec.sv_onstack = 0;
	(void) sigvec (SIGCHLD,&chldvec,&oldvec);
d357 3
a359 1
		signalmask = sigblock(sigmask(SIGCHLD));
d368 1
a368 1
		(void) sigsetmask(signalmask);
d380 1
a380 1
	union wait w;
d391 1
d397 1
d424 3
d480 1
a480 1
	if (p = fgets (buf,STRINGLENGTH,f)) {
d558 1
d578 2
a579 2
		signon ();
		setup ();
d581 1
a581 1
		login ();
d603 1
a603 1
	finishup (starttime);
d633 2
a634 1
signon ()
d651 2
a652 1
setup ()
a673 1
		extern int link_nofollow(), local_file();
d679 1
a679 1
			goaway ("User not found");
d698 1
a698 1
				while (p = fgets (buf,STRINGLENGTH,f)) {
d751 1
a751 1
			while (p = fgets (buf,STRINGLENGTH,f)) {
d774 1
a774 1
		while (p = fgets (buf,STRINGLENGTH,f)) {
d819 1
a819 1
			while (p = fgets (buf,STRINGLENGTH,f)) {
d846 1
d860 1
d866 1
a874 1
	extern int  link_nofollow(), local_file();
d890 2
a891 1
					if (q = strchr (p,'\n'))  *q = '\0';
d925 2
a926 1
login ()
d928 1
a928 2
	char *changeuid ();
	register int x,fileuid,filegid;
d977 1
a979 1
	int denyone();
d996 1
a996 1
	(void) Tprocess (needT,denyone);
d1003 3
a1005 1
denyone (t)
d1007 1
a1013 1
	TREE *linkcheck ();
d1066 1
a1068 1
	int sendone(),senddir(),sendfile();
d1093 1
a1093 1
		(void) Tprocess (tl->TLtree,sendone);
d1098 1
a1098 1
		(void) Trprocess (tl->TLtree,senddir);
d1109 2
a1110 1
sendone (t)
d1112 1
d1115 1
a1115 6
	register int fdtmp;
	char temp_file[STRINGLENGTH], rcs_file[STRINGLENGTH];
        union wait status;
	char *uconvert(),*gconvert();
	int sendfile ();
	int ac;
d1161 2
a1162 4
					status.w_status = runio(av,
							        NULL,
							        rcs_file,
							        "/dev/null");
d1164 1
a1164 1
                                        if (status.w_status < 0 || status.w_retcode) {
d1167 2
a1168 2
                                                if (status.w_status < 0) {
                                                        goaway ("We died trying to run cvs or rcs");
d1172 4
a1175 2
                                                        /*logerr("rcs command failed = %d\n",
                                                               status.w_retcode);*/
d1182 1
a1182 1
						av[1] = "-c";
d1188 1
a1188 1
                                                        goaway ("We died trying to gzip a file");
d1202 1
a1202 1
					av[1] = "-c";
d1207 1
a1207 1
                                                goaway ("We died trying to run gzip");
d1229 1
a1229 1
	if (x != SCMOK)  goaway ("Error sending file to client");
d1233 2
a1234 1
senddir (t)
d1236 1
a1238 2
	char *uconvert(),*gconvert();
	int sendfile ();
d1250 1
a1250 1
	if (x != SCMOK)  goaway ("Error sending file to client");
d1254 3
a1256 2
sendfile (t,ap)
register TREE *t;
d1259 3
a1261 2
	register int x;
	int fd = va_arg(ap,int);
d1265 1
a1265 1
	if (x != SCMOK)  goaway ("Error sending file to client");
d1274 2
a1275 1
finishup (starttime)
a1280 1
	struct stat sbuf;
d1348 1
d1355 1
a1355 1
		while (h = table[i]) {
d1373 1
a1440 1
	char *okpassword ();
d1454 1
a1454 1
	char *p;
d1621 2
a1622 1
#if __STDC__
a1629 3
#if !__STDC__
	register char *fmt;
#endif
d1633 1
a1633 2
	(void) netcrypt ((char *)NULL);
#if __STDC__
d1636 2
d1641 2
d1770 30
a1799 4
	 *
	 * Our current implementation and Sun OS 3.x use major device
	 * 255 for NFS files; Sun OS 4.x seems to use 130 (I have only
	 * determined this empirically -- DLC).  Without a fstatfs()
a1801 2
	if (major(sb.st_dev) == 255 || major(sb.st_dev) == 130)
		return(0);
d1803 3
a1805 1
	return(1);
@


1.5
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.4 1996/07/31 11:11:31 niklas Exp $	*/
d47 3
d543 1
a543 1
		if (q = index (p,'\n'))  *q = '\0';
d759 1
a759 1
					q = index (p,'\n');
d761 1
a761 1
					if (index ("#;:",*p))  continue;
d812 1
a812 1
				q = index (p,'\n');
d814 1
a814 1
				if (index ("#;:",*p))  continue;
d835 1
a835 1
			q = index (p,'\n');
d837 1
a837 1
			if (index ("#;:",*p))  continue;
d881 1
a881 1
				q = index (p,'\n');
d883 1
a883 1
				if (index ("#;:",*p))  continue;
d948 1
a948 1
					if (q = index (p,'\n'))  *q = '\0';
d1525 1
a1525 1
		account = group = index (nbuf,',');
d1528 1
a1528 1
			account = index (group,',');
@


1.4
log
@Better use time_t instead of long when dealing with times
@
text
@d1 1
a1 1
/*	$OpenBSD: supfilesrv.c,v 1.3 1996/06/26 05:39:54 deraadt Exp $	*/
d47 3
d1650 2
d1654 2
d1661 2
d1665 2
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 3
a283 1
long time ();
d375 1
a375 1
	long tloc;
d391 1
a391 1
	tloc = time ((long *)NULL);
d616 1
a616 1
	long starttime;
d631 1
a631 1
	starttime = time ((long *)NULL);
d1325 1
a1325 1
long starttime;
d1331 1
a1331 1
	long finishtime;
d1370 1
a1370 1
	finishtime = time ((long *)NULL);
d1695 1
a1695 1
long time;
@


1.2
log
@hack: print hostname connection failed with
@
text
@d1 2
d47 3
@


1.1
log
@add sup to the tree
@
text
@d45 3
d1678 3
@
