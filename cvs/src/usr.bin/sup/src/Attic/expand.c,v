head	1.16;
access;
symbols
	OPENBSD_4_8:1.15.0.26
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.22
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.24
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.20
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.18
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.16
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.14
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.12
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.10
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.12
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.16
date	2010.10.18.20.54.00;	author deraadt;	state dead;
branches;
next	1.15;

1.15
date	2004.04.05.14.30.51;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.07.20.39.29;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.17.19.42.32;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.05.15.56.04;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.04.22.16.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.29.21.55.59;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.29.18.16.19;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.02.04.10.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.16.23.03.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.09.16.11.13.59;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.04.01.07.35.01;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	97.01.17.07.13.20;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.39.40;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.16.11.46.45;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@sup is no longer used. reminded by pirofti and jmc
@
text
@/*	$OpenBSD: expand.c,v 1.15 2004/04/05 14:30:51 aaron Exp $	*/

/*
 * Copyright (c) 1991 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator   or   Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the rights
 * to redistribute these changes.
 */
/*
 *  expand - expand wildcard filename specifications
 *
 *  Usage:
 *	int expand(spec, buffer, bufsize);
 *	char *spec, **buffer;
 *	int bufsize;
 *
 *  Expand takes a file specification, and expands it into filenames
 *  by resolving the characters '*', '?', '[', ']', '{', '}' and '~'
 *  in the same manner as the shell.  You provide "buffer", which is
 *  an array of char *'s, and you tell how big it is in bufsize.
 *  Expand will compute the corresponding filenames, and will fill up
 *  the entries of buffer with pointers to malloc'd strings.
 *
 *  The value returned by expand is the number of filenames found.  If
 *  this value is -1, then malloc failed to allocate a string.  If the
 *  value is bufsize + 1, then too many names were found and you can try
 *  again with a bigger buffer.
 *
 *  This routine was basically created from the csh sh.glob.c file with
 *  the following intended differences:
 *
 *	Filenames are not sorted.
 *	All expanded filenames returned exist.
 *
 **********************************************************************
 * HISTORY
 * 13-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Replaced a stat() with lstat() and changed glob() to only call
 *	matchdir() for directories.
 *
 * 20-Oct-85  Glenn Marcy (gm0w) at Carnegie-Mellon University
 *	Created from csh glob() function and 4.1 expand() function.
 *
 **********************************************************************
 */
#include <sys/param.h>
#include <sys/stat.h>
#ifdef HAS_POSIX_DIR
#include <dirent.h>
#else
#include <sys/dir.h>
#endif
#include <pwd.h>
#include <ctype.h>
#include <libc.h>
#include <setjmp.h>
#include <stdlib.h>
#include <unistd.h>

static	jmp_buf	sjbuf;

static	char	pathbuf[MAXPATHLEN];
static	char	*path, *pathp, *lastpathp;

static	char	*globchars = "{[*?";	/* meta characters */
static	char	*entp;			/* current dir entry pointer */

static	char	**BUFFER;		/* pointer to the buffer */
static	int	BUFSIZE;		/* maximum number in buffer */
static	int	bufcnt;			/* current number in buffer */

#define fixit(a) (a[0] ? a : ".")

int expand(char *, char **, int);
static void glob(char *);
static void matchdir(char *);
static int execbrc(char *, char *);
static int match(char *, char *);
static int amatch(char *, char *);
static void addone(char *, char *);
static int addpath(int);
static int gethdir(char *, size_t);

int
expand(spec, buffer, bufsize)
	char *spec;
	char **buffer;
	int bufsize;
{
	pathp = path = pathbuf;
	*pathp = 0;
	lastpathp = &path[MAXPATHLEN - 2];
	BUFFER = buffer;
	BUFSIZE = bufsize;
	bufcnt = 0;
	if (setjmp(sjbuf) == 0)
		glob(spec);
	return(bufcnt);
}

static void
glob(as)
	char *as;
{
	char *cs;
	char *spathp, *oldcs;
	char *home;
	struct stat stb;

	if ((home = getenv("HOME")) != NULL && *home == '\0')
		home = NULL;

	spathp = pathp;
	cs = as;
	if (*cs == '~' && home && pathp == path) {
		if (addpath('~'))
			goto endit;
		for (cs++; isalnum((unsigned char) *cs) || *cs == '_' || *cs == '-';)
			if (addpath(*cs++))
				goto endit;
		if (!*cs || *cs == '/') {
			if (pathp != path + 1) {
				*pathp = 0;
				if (gethdir(path + 1, sizeof pathbuf - 1))
					goto endit;
				memmove(path, path + 1, strlen(path));
			} else
				strlcpy(path, home, sizeof pathbuf);
			pathp = path + strlen(path);
		}
	}
	while (*cs == 0 || strchr(globchars, *cs) == 0) {
		if (*cs == 0) {
			if (lstat(fixit(path), &stb) >= 0)
				addone(path, "");
			goto endit;
		}
		if (addpath(*cs++))
			goto endit;
	}
	oldcs = cs;
	while (cs > as && *cs != '/')
		cs--, pathp--;
	if (*cs == '/')
		cs++, pathp++;
	*pathp = 0;
	if (*oldcs == '{') {
		execbrc(cs, NULL);
		return;
	}
	/* this should not be an lstat */
	if (stat(fixit(path), &stb) >= 0 && S_ISDIR(stb.st_mode))
		matchdir(cs);
endit:
	pathp = spathp;
	*pathp = 0;
	return;
}

static void matchdir(pattern)
	char *pattern;
{
#ifdef HAS_POSIX_DIR
	struct dirent *dp;
#else
	struct direct *dp;
#endif
	DIR *dirp;

	dirp = opendir(fixit(path));
	if (dirp == NULL)
		return;
	while ((dp = readdir(dirp)) != NULL) {
#if defined(HAS_POSIX_DIR) && !defined(__SVR4)
		if (dp->d_fileno == 0)
			continue;
#else
		if (dp->d_ino == 0)
			continue;
#endif
		if (match(dp->d_name, pattern))
			addone(path, dp->d_name);
	}
	closedir(dirp);
	return;
}

static int execbrc(p, s)
	char *p, *s;
{
	char restbuf[MAXPATHLEN + 1];
	char *pe, *pm, *pl;
	int brclev = 0;
	char *lm, savec, *spathp;

	for (lm = restbuf; *p != '{'; *lm++ = *p++)
		continue;
	for (pe = ++p; *pe; pe++) {
		switch (*pe) {
		case '{':
			brclev++;
			continue;
		case '}':
			if (brclev == 0)
				goto pend;
			brclev--;
			continue;
		case '[':
			for (pe++; *pe && *pe != ']'; pe++)
				continue;
			if (!*pe)
				break;
			continue;
		}
	}
pend:
	if (brclev || !*pe)
		return (0);
	for (pl = pm = p; pm <= pe; pm++) {
		switch (*pm & 0177) {
		case '{':
			brclev++;
			continue;
		case '}':
			if (brclev) {
				brclev--;
				continue;
			}
			goto doit;
		case ',':
			if (brclev) continue;
doit:
			savec = *pm;
			*pm = 0;
			snprintf(lm, sizeof(restbuf) - (lm - restbuf),
			    "%s%s", pl, pe + 1);
			*pm = savec;
			if (s == 0) {
				spathp = pathp;
				glob(restbuf);
				pathp = spathp;
				*pathp = 0;
			} else if (amatch(s, restbuf))
				return (1);
			pl = pm + 1;
			continue;

		case '[':
			for (pm++; *pm && *pm != ']'; pm++)
				continue;
			if (!*pm)
				break;
			continue;
		}
	}
	return (0);
}

static int
match(s, p)
	char *s, *p;
{
	int c;
	char *sentp;

	if (*s == '.' && *p != '.')
		return(0);
	sentp = entp;
	entp = s;
	c = amatch(s, p);
	entp = sentp;
	return (c);
}

static int
amatch(s, p)
	char *s, *p;
{
	int scc;
	int ok, lc;
	char *spathp;
	struct stat stb;
	int c, cc;

	for (;;) {
		scc = *s++ & 0177;
		switch (c = *p++) {
		case '{':
			return (execbrc(p - 1, s - 1));
		case '[':
			ok = 0;
			lc = 077777;
			while ((cc = *p++) != 0) {
				if (cc == ']') {
					if (ok)
						break;
					return (0);
				}
				if (cc == '-') {
					if (lc <= scc && scc <= *p++)
						ok++;
				} else
					if (scc == (lc = cc))
						ok++;
			}
			if (cc == 0)
				return (0);
			continue;
		case '*':
			if (!*p)
				return (1);
			if (*p == '/') {
				p++;
				goto slash;
			}
			for (s--; *s; s++)
				if (amatch(s, p))
					return (1);
			return (0);
		case 0:
			return (scc == 0);
		default:
			if (c != scc)
				return (0);
			continue;
		case '?':
			if (scc == 0)
				return (0);
			continue;
		case '/':
			if (scc)
				return (0);
slash:
			s = entp;
			spathp = pathp;
			while (*s) {
				if (addpath(*s++))
					goto pathovfl;
			}
			if (addpath('/'))
				goto pathovfl;
			if (stat(fixit(path), &stb) >= 0 &&
			    S_ISDIR(stb.st_mode)) {
				if (*p == 0)
					addone(path, "");
				else
					glob(p);
			}
pathovfl:
			pathp = spathp;
			*pathp = 0;
			return (0);
		}
	}
}

static void
addone(s1, s2)
	char *s1, *s2;
{
	char *ep;

	if (bufcnt >= BUFSIZE) {
		bufcnt = BUFSIZE + 1;
		longjmp(sjbuf, 1);
	}
	ep = (char *)malloc(strlen(s1) + strlen(s2) + 1);
	if (ep == 0) {
		bufcnt = -1;
		longjmp(sjbuf, 1);
	}
	BUFFER[bufcnt++] = ep;
	while (*s1)
		*ep++ = *s1++;
	while ((*ep++ = *s2++) != '\0')
		continue;
}

static int
addpath(c)
	char c;
{
	if (pathp >= lastpathp)
		return(1);
	*pathp++ = c;
	*pathp = 0;
	return(0);
}

static int gethdir(home, homelen)
	char *home;
	size_t homelen;
{
	struct passwd *pp = getpwnam(home);

	if (pp == 0)
		return(1);
	strlcpy(home, pp->pw_dir, homelen);
	return(0);
}
@


1.15
log
@Pass correct buffer length to gethdir(), and also change int arg to size_t
per anil@@. deraadt@@, millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.14 2003/05/07 20:39:29 deraadt Exp $	*/
@


1.14
log
@bounds were sizeof(pointer) rather than size of the object; found with
anil's gcc bounds checker mod
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.13 2002/02/17 19:42:32 millert Exp $	*/
d100 1
a100 1
static int gethdir(char *, int);
d142 1
a142 1
				if (gethdir(path + 1, sizeof path - 1))
d410 1
a410 1
	int homelen;
@


1.13
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.12 2002/02/16 21:27:54 millert Exp $	*/
d146 1
a146 1
				strlcpy(path, home, sizeof path);
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.11 2001/05/05 15:56:04 millert Exp $	*/
a90 8

#ifndef __P
#ifdef __STDC__
#define __P(a)	a
#else
#define __P(a)	()
#endif
#endif
@


1.11
log
@Fix Makefile.sunos5.gcc so that it builds sup correctly on Solaris 8
Fix some -Wall found on Solaris
Fix some uid_t/gid_t stuff I missed before
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.10 2001/05/04 22:16:15 millert Exp $	*/
d100 9
a108 9
int expand __P((char *, char **, int));
static void glob __P((char *));
static void matchdir __P((char *));
static int execbrc __P((char *, char *));
static int match __P((char *, char *));
static int amatch __P((char *, char *));
static void addone __P((char *, char *));
static int addpath __P((int));
static int gethdir __P((char *, int));
@


1.10
log
@o kill register
o lots of KNF
o passes -Wall
o fix some [ug]id_t vs. int issues
o use strlcpy/strlcat in favor of strncpy/strncat
o use mem* routines everywhere instead of old b* ones
o marked several questionable things for later fixing
o kill ci.c and cvt.c -- we don't use them
o kill read_line.c since it requires fgetln() (bad for portability)
o kill salloc.c since it is the same as strup()
o Replaced some #ifdef __OpenBSD__ with better tests
o remaining problems: malloc return values are rarely checked, select misuse
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.9 2001/04/29 21:55:59 millert Exp $	*/
d144 1
a144 1
		for (cs++; isalnum(*cs) || *cs == '_' || *cs == '-';)
@


1.9
log
@labels should precede actual code, not braces; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.8 2001/04/29 18:16:19 millert Exp $	*/
d110 3
a112 2
int expand(spec, buffer, bufsize)
	register char *spec;
d123 1
a123 1
	    glob(spec);
d127 2
a128 1
static void glob(as)
d131 2
a132 2
	register char *cs;
	register char *spathp, *oldcs;
d142 2
a143 1
		if (addpath('~')) goto endit;
d145 2
a146 1
			if (addpath(*cs++)) goto endit;
d150 3
a152 2
				if (gethdir(path + 1,sizeof path-1)) goto endit;
				strncpy(path, path + 1, sizeof path-1);
d154 1
a154 2
				strncpy(path, home, sizeof path-1);
			path[sizeof path-1] = '\0';
d160 2
a161 1
			if (lstat(fixit(path), &stb) >= 0) addone(path, "");
d164 2
a165 1
		if (addpath(*cs++)) goto endit;
d190 1
a190 1
	register struct dirent *dp;
d192 1
a192 1
	register struct direct *dp;
d201 2
a202 1
		if (dp->d_fileno == 0) continue;
d204 2
a205 1
		if (dp->d_ino == 0) continue;
d218 1
a218 1
	register char *pe, *pm, *pl;
d224 15
a238 11
	for (pe = ++p; *pe; pe++)
	switch (*pe) {
	case '{':
		brclev++;
		continue;
	case '}':
		if (brclev == 0) goto pend;
		brclev--;
		continue;
	case '[':
		for (pe++; *pe && *pe != ']'; pe++)
d240 1
a240 2
		if (!*pe) break;
		continue;
d243 3
a245 2
	if (brclev || !*pe) return (0);
	for (pl = pm = p; pm <= pe; pm++)
d277 2
a278 1
			if (!*pm) break;
d281 1
d285 2
a286 1
static int match(s, p)
d289 2
a290 2
	register int c;
	register char *sentp;
d292 2
a293 1
	if (*s == '.' && *p != '.') return(0);
d301 3
a303 2
static int amatch(s, p)
	register char *s, *p;
d305 1
a305 1
	register int scc;
d321 2
a322 1
					if (ok) break;
d332 2
a333 1
			if (cc == 0) return (0);
d336 2
a337 1
			if (!*p) return (1);
d349 2
a350 1
			if (c != scc) return (0);
d353 2
a354 1
			if (scc == 0) return (0);
d357 2
a358 1
			if (scc) return (0);
d362 6
a367 3
			while (*s)
				if (addpath(*s++)) goto pathovfl;
			if (addpath('/')) goto pathovfl;
d383 3
a385 2
static void addone(s1, s2)
	register char *s1, *s2;
d387 1
a387 1
	register char *ep;
d399 2
a400 1
	while (*s1) *ep++ = *s1++;
d405 2
a406 1
static int addpath(c)
d416 1
a416 1
static int gethdir(home,homelen)
d420 1
a420 1
	register struct passwd *pp = getpwnam(home);
d424 1
a424 2
	strncpy(home, pp->pw_dir, homelen-1);
	home[homelen-1] = '\0';
@


1.8
log
@Use S_ISXXX macros where possible instead of doing this by hand
Noticed while diffing against NetBSD version
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.7 2000/08/02 04:10:49 millert Exp $	*/
d348 1
a349 1
			}
@


1.7
log
@$HOME paranoia: never use getenv("HOME") w/o checking for NULL and non-zero
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.6 1997/09/16 23:03:10 millert Exp $	*/
d172 1
a172 1
	if (stat(fixit(path), &stb) >= 0 && (stb.st_mode&S_IFMT) == S_IFDIR)
d343 1
a343 1
			    (stb.st_mode&S_IFMT) == S_IFDIR)
d349 1
@


1.6
log
@Possible buf oflow, from Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.5 1997/09/16 11:13:59 deraadt Exp $	*/
d131 1
d134 3
d139 1
a139 1
	if (*cs == '~' && pathp == path) {
d149 1
a149 1
				strncpy(path, (char *)getenv("HOME"), sizeof path-1);
@


1.5
log
@one more strcpy after this
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.4 1997/04/01 07:35:01 todd Exp $	*/
d245 2
a246 2
			strcpy(lm, pl);
			strcat(restbuf, pe + 1);
@


1.4
log
@This merges in the latest NetBSD sup source.
- removed $Log: ...$ tags to not waste space in the repository
- now doesn't segfault on the alpha!

Note:
To compile sup on systems other than *BSD, you'll need a copy of
vis.c, vis.h, daemon.c, and sys/cdefs.h.  At least the first two
(for OSF/1).

From NetBSD changelog description (for credit where due):
.... 1996/12/23 19:42:05  christos
- add missing prototypes.
- fix function call inconsistencies
- fix int <-> long and pointer conversions
It should run now on 64 bit machines...

....  1996/12/31 18:08:00  christos
64 bit patches (mostly long -> time_t) from Matthew Jacob (?)
sup now works on the alpha!
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.3 1997/01/17 07:13:20 millert Exp $	*/
d108 1
a108 1
static int gethdir __P((char *));
d142 2
a143 2
				if (gethdir(path + 1)) goto endit;
				strcpy(path, path + 1);
d145 3
a147 3
				strcpy(path, (char *)getenv("HOME"));
			pathp = path;
			while (*pathp) pathp++;
d382 1
a382 1
static int gethdir(home)
d384 1
d390 2
a391 1
	strcpy(home, pp->pw_dir);
@


1.3
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: expand.c,v 1.2 1996/06/26 05:39:40 deraadt Exp $	*/
d75 2
d90 19
a108 8
static void glob();
static void matchdir();
static int execbrc();
static int match();
static int amatch();
static void addone();
static int addpath();
static int gethdir();
d152 1
a152 1
			if (lstat(path, &stb) >= 0) addone(path, "");
d168 1
a168 1
	if (stat(path, &stb) >= 0 && (stb.st_mode&S_IFMT) == S_IFDIR)
d186 1
a186 1
	dirp = opendir(path);
d190 1
a190 1
#ifdef HAS_POSIX_DIR
d298 1
a298 1
			while (cc = *p++) {
d338 1
a338 1
			if (stat(path, &stb) >= 0 &&
d368 2
a369 1
	while (*ep++ = *s2++);
a384 1
	struct passwd *getpwnam();
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d137 1
a137 1
	while (*cs == 0 || index(globchars, *cs) == 0) {
@


1.1
log
@add sup to the tree
@
text
@d1 2
@
