head	1.94;
access;
symbols
	OPENBSD_6_2_BASE:1.94
	OPENBSD_6_1:1.91.0.4
	OPENBSD_6_1_BASE:1.91
	OPENBSD_6_0:1.74.0.2
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31;
locks; strict;
comment	@ * @;


1.94
date	2017.06.24.14.38.27;	author schwarze;	state Exp;
branches;
next	1.93;
commitid	ebFpCjoYaInwxToS;

1.93
date	2017.06.20.17.24.09;	author schwarze;	state Exp;
branches;
next	1.92;
commitid	0zrcQOD2y2LNXh12;

1.92
date	2017.04.19.00.59.32;	author schwarze;	state Exp;
branches;
next	1.91;
commitid	bscY3X9QWPe9S7j4;

1.91
date	2017.03.18.16.48.07;	author schwarze;	state Exp;
branches;
next	1.90;
commitid	kD0rfl2ai0ZCKtsB;

1.90
date	2017.03.18.16.18.45;	author schwarze;	state Exp;
branches;
next	1.89;
commitid	enBqdUhQOeqoCax6;

1.89
date	2017.03.15.13.49.26;	author schwarze;	state Exp;
branches;
next	1.88;
commitid	RuArmGpgS9J6JEFx;

1.88
date	2017.03.15.13.18.48;	author schwarze;	state Exp;
branches;
next	1.87;
commitid	YBHYEQNsQHFwF0iX;

1.87
date	2017.03.15.10.17.08;	author schwarze;	state Exp;
branches;
next	1.86;
commitid	b8etEua6tLImc6Sc;

1.86
date	2017.02.22.16.16.35;	author schwarze;	state Exp;
branches;
next	1.85;
commitid	MnLiTi32ys0rzHDx;

1.85
date	2017.01.25.03.19.56;	author deraadt;	state Exp;
branches;
next	1.84;
commitid	w0gCVi7dw1JK0zeX;

1.84
date	2017.01.25.02.14.41;	author schwarze;	state Exp;
branches;
next	1.83;
commitid	t5qXBiFCvZnIxlr1;

1.83
date	2017.01.21.01.20.29;	author schwarze;	state Exp;
branches;
next	1.82;
commitid	t1CIT40aRIdTYb2t;

1.82
date	2017.01.19.13.55.49;	author schwarze;	state Exp;
branches;
next	1.81;
commitid	Xw0EeYpKvZlaKF3L;

1.81
date	2017.01.19.13.34.59;	author schwarze;	state Exp;
branches;
next	1.80;
commitid	kkzxtGlbuEtTMCNs;

1.80
date	2016.09.11.23.59.02;	author bentley;	state Exp;
branches;
next	1.79;
commitid	lciMuFD6BDMUKTFM;

1.79
date	2016.09.03.21.24.35;	author schwarze;	state Exp;
branches;
next	1.78;
commitid	oUeHruT6nPiyMD1h;

1.78
date	2016.09.01.15.07.19;	author schwarze;	state Exp;
branches;
next	1.77;
commitid	TdxRERkthYF6Gw9U;

1.77
date	2016.08.18.00.44.37;	author jsg;	state Exp;
branches;
next	1.76;
commitid	qgt3iYg1421EJD82;

1.76
date	2016.08.10.18.39.04;	author schwarze;	state Exp;
branches;
next	1.75;
commitid	HH7aT4cwyKr7fQbe;

1.75
date	2016.07.31.23.35.26;	author schwarze;	state Exp;
branches;
next	1.74;
commitid	dIF3fuBIlI4XwoPN;

1.74
date	2016.07.11.22.46.57;	author schwarze;	state Exp;
branches;
next	1.73;
commitid	S0A6v7XxnTt6HQVD;

1.73
date	2016.07.10.10.03.15;	author schwarze;	state Exp;
branches;
next	1.72;
commitid	R6sNGWOmYohzlHm0;

1.72
date	2016.07.09.19.44.52;	author schwarze;	state Exp;
branches;
next	1.71;
commitid	I2Daw9D0BmXiRhJw;

1.71
date	2016.05.28.13.40.44;	author schwarze;	state Exp;
branches;
next	1.70;
commitid	v1hfPQWQHx8ja44H;

1.70
date	2016.04.29.10.45.06;	author schwarze;	state Exp;
branches;
next	1.69;
commitid	XOcWfuAH72AtrgC5;

1.69
date	2016.04.28.17.59.00;	author schwarze;	state Exp;
branches;
next	1.68;
commitid	qHRsq1OBHCBLvjCQ;

1.68
date	2016.04.15.21.14.03;	author schwarze;	state Exp;
branches;
next	1.67;
commitid	ivUatWoOScv3DB8C;

1.67
date	2016.04.15.16.42.39;	author schwarze;	state Exp;
branches;
next	1.66;
commitid	Whk14htRKerVXY7C;

1.66
date	2016.04.15.15.13.02;	author schwarze;	state Exp;
branches;
next	1.65;
commitid	fGnYapLyFXJbOeJM;

1.65
date	2016.04.15.01.33.48;	author schwarze;	state Exp;
branches;
next	1.64;
commitid	drsdJADRUglwJN9G;

1.64
date	2016.04.15.00.51.39;	author schwarze;	state Exp;
branches;
next	1.63;
commitid	EQ397H7dp8olHUS6;

1.63
date	2016.04.15.00.36.18;	author schwarze;	state Exp;
branches;
next	1.62;
commitid	iG0C4F7AeFDYv9mN;

1.62
date	2016.04.15.00.12.50;	author schwarze;	state Exp;
branches;
next	1.61;
commitid	nB2iaS1LJyk7Jv83;

1.61
date	2016.04.14.23.48.06;	author schwarze;	state Exp;
branches;
next	1.60;
commitid	D31eoaBzPa2twZRo;

1.60
date	2016.04.14.20.38.50;	author schwarze;	state Exp;
branches;
next	1.59;
commitid	HtNvM0msRaNT7ujb;

1.59
date	2016.04.13.12.58.13;	author schwarze;	state Exp;
branches;
next	1.58;
commitid	XRmxLCmjMB1XYiJK;

1.58
date	2016.03.18.13.21.07;	author schwarze;	state Exp;
branches;
next	1.57;
commitid	sc9lSItcLGP9IOXp;

1.57
date	2016.03.17.22.06.30;	author schwarze;	state Exp;
branches;
next	1.56;
commitid	4iY4JCuCo3zKyTfN;

1.56
date	2016.03.17.21.22.43;	author schwarze;	state Exp;
branches;
next	1.55;
commitid	2oOuOpYX8euwdRL4;

1.55
date	2015.12.25.20.16.19;	author bentley;	state Exp;
branches;
next	1.54;
commitid	iF76y4z8cvMBergM;

1.54
date	2015.11.07.17.58.52;	author schwarze;	state Exp;
branches;
next	1.53;
commitid	9ZfFG7Q71jrU5djH;

1.53
date	2015.11.05.20.55.46;	author schwarze;	state Exp;
branches;
next	1.52;
commitid	YYJdncPyh9PKAW5L;

1.52
date	2015.11.05.17.47.53;	author schwarze;	state Exp;
branches;
next	1.51;
commitid	WbqcnWX758pHZNHM;

1.51
date	2015.10.22.22.05.42;	author schwarze;	state Exp;
branches;
next	1.50;
commitid	h8gIY5ljbuMubFWJ;

1.50
date	2015.10.20.02.00.49;	author schwarze;	state Exp;
branches;
next	1.49;
commitid	v6RrmxwM663z4mTF;

1.49
date	2015.10.13.22.57.49;	author schwarze;	state Exp;
branches;
next	1.48;
commitid	jXIG8UzKLXm2Z9i6;

1.48
date	2015.10.06.18.30.43;	author schwarze;	state Exp;
branches;
next	1.47;
commitid	hxQV8O1pNUaef4ir;

1.47
date	2015.04.18.16.34.03;	author schwarze;	state Exp;
branches;
next	1.46;
commitid	PxhkeHVIvdTMOTs6;

1.46
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.45;
commitid	6MYJ7cd8mhJ77AGH;

1.45
date	2015.03.27.21.17.16;	author schwarze;	state Exp;
branches;
next	1.44;
commitid	r1NPkDobCJs0RcWM;

1.44
date	2015.03.27.17.36.56;	author schwarze;	state Exp;
branches;
next	1.43;
commitid	3WUgQM2C53CGXRkK;

1.43
date	2015.02.10.08.05.07;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	udnlyXKeRKvRFGfq;

1.42
date	2015.01.15.04.26.06;	author schwarze;	state Exp;
branches;
next	1.41;
commitid	TgtfgXU8Rz8XgmeH;

1.41
date	2014.11.26.00.57.32;	author schwarze;	state Exp;
branches;
next	1.40;
commitid	IOKUpkybiRSyInCy;

1.40
date	2014.11.11.19.03.10;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	D7uokBruncZXc8f1;

1.39
date	2014.10.28.17.35.42;	author schwarze;	state Exp;
branches;
next	1.38;
commitid	pNwmOla3ZQwLgu2f;

1.38
date	2014.10.07.18.20.42;	author schwarze;	state Exp;
branches;
next	1.37;
commitid	6E6Z19ADF5DrkYTs;

1.37
date	2014.10.07.18.17.05;	author schwarze;	state Exp;
branches;
next	1.36;
commitid	ovhOTvwzuIxZwsAn;

1.36
date	2014.09.14.19.44.20;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	xQi9xrBkZVjDWFu5;

1.35
date	2014.08.27.00.06.08;	author schwarze;	state Exp;
branches;
next	1.34;
commitid	52PkSro00emV8qcw;

1.34
date	2014.08.26.11.13.58;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	JoQimTe5VxCeJ5Bp;

1.33
date	2014.08.21.16.03.50;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	rbIQ7V44CdGRyV9l;

1.32
date	2014.08.08.17.17.42;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	QANdLZwqi0wzR9ql;

1.31
date	2014.07.25.21.05.38;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	BxHYVWJCqhTfc3XR;

1.30
date	2014.07.25.20.08.49;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	WrtuIvI8Q3jpN4cq;

1.29
date	2014.07.25.19.36.02;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	cS08gpqSrrpabEXb;

1.28
date	2014.07.25.18.19.33;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	hX5q8OXldHkl1ejz;

1.27
date	2014.07.25.17.51.33;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	y3ZWnKUhZuQQduEE;

1.26
date	2014.07.25.17.33.51;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	RWIzrQFG3sHfPhVc;

1.25
date	2014.07.25.16.55.40;	author schwarze;	state Exp;
branches;
next	1.24;
commitid	yXgYzaqanMwsutxf;

1.24
date	2014.07.25.16.43.05;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	ad1SUhQNcgMDMPEz;

1.23
date	2014.07.25.16.06.19;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	ObUrg1MrjDo2h7j5;

1.22
date	2014.07.24.20.30.38;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	uytSUPmIkoEPLLy1;

1.21
date	2014.07.24.08.25.45;	author schwarze;	state Exp;
branches;
next	1.20;
commitid	OtZGSTUQeNcGO3jI;

1.20
date	2014.07.22.18.14.05;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	0fPck2RfFrcFaGpY;

1.19
date	2014.07.21.22.32.55;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	DyGfFj9YoQQXCHqt;

1.18
date	2014.07.21.15.44.22;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	FZSgGHpUssvn2lLF;

1.17
date	2014.07.19.13.15.07;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	IhSVU4oTLzktwomd;

1.16
date	2014.07.19.11.35.09;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	8AEnNw3xivau9Iqs;

1.15
date	2014.07.18.19.02.07;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	EEaeeF6UE6XbFrFV;

1.14
date	2014.07.18.14.46.20;	author schwarze;	state Exp;
branches;
next	1.13;
commitid	Zl57VcbtrPwifaWI;

1.13
date	2014.07.13.15.38.06;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	YAnjixKEwtDnF0CY;

1.12
date	2014.07.13.12.55.24;	author schwarze;	state Exp;
branches;
next	1.11;
commitid	S5SJ4LQuwyS7j6Oc;

1.11
date	2014.07.13.12.44.57;	author schwarze;	state Exp;
branches;
next	1.10;
commitid	tWrR6S0DSFYzfKEw;

1.10
date	2014.07.13.12.31.00;	author schwarze;	state Exp;
branches;
next	1.9;
commitid	5ixPryUeLemjxgSm;

1.9
date	2014.07.13.09.58.52;	author schwarze;	state Exp;
branches;
next	1.8;
commitid	gsZSYQZIRBisEsht;

1.8
date	2014.07.12.23.40.44;	author schwarze;	state Exp;
branches;
next	1.7;
commitid	xFMaTkt3OeFEAKBV;

1.7
date	2014.07.12.18.05.50;	author schwarze;	state Exp;
branches;
next	1.6;
commitid	ShegTcjBf4Wea2kz;

1.6
date	2014.07.12.17.18.13;	author schwarze;	state Exp;
branches;
next	1.5;
commitid	1xBj6oxJSNTSootF;

1.5
date	2014.07.12.16.13.36;	author schwarze;	state Exp;
branches;
next	1.4;
commitid	MjPeOkxuPxP6xSLV;

1.4
date	2014.07.12.01.52.57;	author schwarze;	state Exp;
branches;
next	1.3;
commitid	wZsxKuzSo9LB5Y0m;

1.3
date	2014.07.11.22.16.11;	author tedu;	state Exp;
branches;
next	1.2;
commitid	57BntE9TB3zxvNzW;

1.2
date	2014.07.11.22.14.39;	author tedu;	state Exp;
branches;
next	1.1;
commitid	ZX3ZKhDubaDRrkh2;

1.1
date	2014.07.11.15.37.22;	author schwarze;	state Exp;
branches;
next	;
commitid	FuqGkunXbHbHFHDy;


desc
@@


1.94
log
@Split -Wstyle into -Wstyle and the even lower -Wbase, and add
-Wopenbsd and -Wnetbsd to check conventions for the base system of
a specific operating system.  Mark operating system specific messages
with "(OpenBSD)" at the end.

Please use just "-Tlint" to check base system manuals (defaulting
to -Wall, which is now -Wbase), but prefer "-Tlint -Wstyle" for the
manuals of portable software projects you maintain that are not
part of OpenBSD base, to avoid bogus recommendations about base
system conventions that do not apply.

Issue originally reported by semarie@@, solution using
an idea from tedu@@, discussed with jmc@@ and jca@@.
@
text
@/*	$OpenBSD: cgi.c,v 1.93 2017/06/20 17:24:09 schwarze Exp $ */
/*
 * Copyright (c) 2011, 2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2014, 2015, 2016, 2017 Ingo Schwarze <schwarze@@usta.de>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#include <sys/time.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "man.h"
#include "main.h"
#include "manconf.h"
#include "mansearch.h"
#include "cgi.h"

/*
 * A query as passed to the search function.
 */
struct	query {
	char		*manpath; /* desired manual directory */
	char		*arch; /* architecture */
	char		*sec; /* manual section */
	char		*query; /* unparsed query expression */
	int		 equal; /* match whole names, not substrings */
};

struct	req {
	struct query	  q;
	char		**p; /* array of available manpaths */
	size_t		  psz; /* number of available manpaths */
	int		  isquery; /* QUERY_STRING used, not PATH_INFO */
};

enum	focus {
	FOCUS_NONE = 0,
	FOCUS_QUERY
};

static	void		 html_print(const char *);
static	void		 html_putchar(char);
static	int		 http_decode(char *);
static	void		 parse_manpath_conf(struct req *);
static	void		 parse_path_info(struct req *req, const char *path);
static	void		 parse_query_string(struct req *, const char *);
static	void		 pg_error_badrequest(const char *);
static	void		 pg_error_internal(void);
static	void		 pg_index(const struct req *);
static	void		 pg_noresult(const struct req *, const char *);
static	void		 pg_redirect(const struct req *, const char *);
static	void		 pg_search(const struct req *);
static	void		 pg_searchres(const struct req *,
				struct manpage *, size_t);
static	void		 pg_show(struct req *, const char *);
static	void		 resp_begin_html(int, const char *, const char *);
static	void		 resp_begin_http(int, const char *);
static	void		 resp_catman(const struct req *, const char *);
static	void		 resp_copy(const char *);
static	void		 resp_end_html(void);
static	void		 resp_format(const struct req *, const char *);
static	void		 resp_searchform(const struct req *, enum focus);
static	void		 resp_show(const struct req *, const char *);
static	void		 set_query_attr(char **, char **);
static	int		 validate_filename(const char *);
static	int		 validate_manpath(const struct req *, const char *);
static	int		 validate_urifrag(const char *);

static	const char	 *scriptname = SCRIPT_NAME;

static	const int sec_prios[] = {1, 4, 5, 8, 6, 3, 7, 2, 9};
static	const char *const sec_numbers[] = {
    "0", "1", "2", "3", "3p", "4", "5", "6", "7", "8", "9"
};
static	const char *const sec_names[] = {
    "All Sections",
    "1 - General Commands",
    "2 - System Calls",
    "3 - Library Functions",
    "3p - Perl Library",
    "4 - Device Drivers",
    "5 - File Formats",
    "6 - Games",
    "7 - Miscellaneous Information",
    "8 - System Manager\'s Manual",
    "9 - Kernel Developer\'s Manual"
};
static	const int sec_MAX = sizeof(sec_names) / sizeof(char *);

static	const char *const arch_names[] = {
    "amd64",       "alpha",       "armv7",	"arm64",
    "hppa",        "i386",        "landisk",
    "loongson",    "luna88k",     "macppc",      "mips64",
    "octeon",      "sgi",         "socppc",      "sparc64",
    "amiga",       "arc",         "armish",      "arm32",
    "atari",       "aviion",      "beagle",      "cats",
    "hppa64",      "hp300",
    "ia64",        "mac68k",      "mvme68k",     "mvme88k",
    "mvmeppc",     "palm",        "pc532",       "pegasos",
    "pmax",        "powerpc",     "solbourne",   "sparc",
    "sun3",        "vax",         "wgrisc",      "x68k",
    "zaurus"
};
static	const int arch_MAX = sizeof(arch_names) / sizeof(char *);

/*
 * Print a character, escaping HTML along the way.
 * This will pass non-ASCII straight to output: be warned!
 */
static void
html_putchar(char c)
{

	switch (c) {
	case '"':
		printf("&quot;");
		break;
	case '&':
		printf("&amp;");
		break;
	case '>':
		printf("&gt;");
		break;
	case '<':
		printf("&lt;");
		break;
	default:
		putchar((unsigned char)c);
		break;
	}
}

/*
 * Call through to html_putchar().
 * Accepts NULL strings.
 */
static void
html_print(const char *p)
{

	if (NULL == p)
		return;
	while ('\0' != *p)
		html_putchar(*p++);
}

/*
 * Transfer the responsibility for the allocated string *val
 * to the query structure.
 */
static void
set_query_attr(char **attr, char **val)
{

	free(*attr);
	if (**val == '\0') {
		*attr = NULL;
		free(*val);
	} else
		*attr = *val;
	*val = NULL;
}

/*
 * Parse the QUERY_STRING for key-value pairs
 * and store the values into the query structure.
 */
static void
parse_query_string(struct req *req, const char *qs)
{
	char		*key, *val;
	size_t		 keysz, valsz;

	req->isquery	= 1;
	req->q.manpath	= NULL;
	req->q.arch	= NULL;
	req->q.sec	= NULL;
	req->q.query	= NULL;
	req->q.equal	= 1;

	key = val = NULL;
	while (*qs != '\0') {

		/* Parse one key. */

		keysz = strcspn(qs, "=;&");
		key = mandoc_strndup(qs, keysz);
		qs += keysz;
		if (*qs != '=')
			goto next;

		/* Parse one value. */

		valsz = strcspn(++qs, ";&");
		val = mandoc_strndup(qs, valsz);
		qs += valsz;

		/* Decode and catch encoding errors. */

		if ( ! (http_decode(key) && http_decode(val)))
			goto next;

		/* Handle key-value pairs. */

		if ( ! strcmp(key, "query"))
			set_query_attr(&req->q.query, &val);

		else if ( ! strcmp(key, "apropos"))
			req->q.equal = !strcmp(val, "0");

		else if ( ! strcmp(key, "manpath")) {
#ifdef COMPAT_OLDURI
			if ( ! strncmp(val, "OpenBSD ", 8)) {
				val[7] = '-';
				if ('C' == val[8])
					val[8] = 'c';
			}
#endif
			set_query_attr(&req->q.manpath, &val);
		}

		else if ( ! (strcmp(key, "sec")
#ifdef COMPAT_OLDURI
		    && strcmp(key, "sektion")
#endif
		    )) {
			if ( ! strcmp(val, "0"))
				*val = '\0';
			set_query_attr(&req->q.sec, &val);
		}

		else if ( ! strcmp(key, "arch")) {
			if ( ! strcmp(val, "default"))
				*val = '\0';
			set_query_attr(&req->q.arch, &val);
		}

		/*
		 * The key must be freed in any case.
		 * The val may have been handed over to the query
		 * structure, in which case it is now NULL.
		 */
next:
		free(key);
		key = NULL;
		free(val);
		val = NULL;

		if (*qs != '\0')
			qs++;
	}
}

/*
 * HTTP-decode a string.  The standard explanation is that this turns
 * "%4e+foo" into "n foo" in the regular way.  This is done in-place
 * over the allocated string.
 */
static int
http_decode(char *p)
{
	char             hex[3];
	char		*q;
	int              c;

	hex[2] = '\0';

	q = p;
	for ( ; '\0' != *p; p++, q++) {
		if ('%' == *p) {
			if ('\0' == (hex[0] = *(p + 1)))
				return 0;
			if ('\0' == (hex[1] = *(p + 2)))
				return 0;
			if (1 != sscanf(hex, "%x", &c))
				return 0;
			if ('\0' == c)
				return 0;

			*q = (char)c;
			p += 2;
		} else
			*q = '+' == *p ? ' ' : *p;
	}

	*q = '\0';
	return 1;
}

static void
resp_begin_http(int code, const char *msg)
{

	if (200 != code)
		printf("Status: %d %s\r\n", code, msg);

	printf("Content-Type: text/html; charset=utf-8\r\n"
	     "Cache-Control: no-cache\r\n"
	     "Pragma: no-cache\r\n"
	     "\r\n");

	fflush(stdout);
}

static void
resp_copy(const char *filename)
{
	char	 buf[4096];
	ssize_t	 sz;
	int	 fd;

	if ((fd = open(filename, O_RDONLY)) != -1) {
		fflush(stdout);
		while ((sz = read(fd, buf, sizeof(buf))) > 0)
			write(STDOUT_FILENO, buf, sz);
		close(fd);
	}
}

static void
resp_begin_html(int code, const char *msg, const char *file)
{
	char	*cp;

	resp_begin_http(code, msg);

	printf("<!DOCTYPE html>\n"
	       "<html>\n"
	       "<head>\n"
	       "  <meta charset=\"UTF-8\"/>\n"
	       "  <link rel=\"stylesheet\" href=\"%s/mandoc.css\""
	       " type=\"text/css\" media=\"all\">\n"
	       "  <title>",
	       CSS_DIR);
	if (file != NULL) {
		if ((cp = strrchr(file, '/')) != NULL)
			file = cp + 1;
		if ((cp = strrchr(file, '.')) != NULL) {
			printf("%.*s(%s) - ", (int)(cp - file), file, cp + 1);
		} else
			printf("%s - ", file);
	}
	printf("%s</title>\n"
	       "</head>\n"
	       "<body>\n",
	       CUSTOMIZE_TITLE);

	resp_copy(MAN_DIR "/header.html");
}

static void
resp_end_html(void)
{

	resp_copy(MAN_DIR "/footer.html");

	puts("</body>\n"
	     "</html>");
}

static void
resp_searchform(const struct req *req, enum focus focus)
{
	int		 i;

	printf("<form action=\"/%s\" method=\"get\">\n"
	       "  <fieldset>\n"
	       "    <legend>Manual Page Search Parameters</legend>\n",
	       scriptname);

	/* Write query input box. */

	printf("    <input type=\"text\" name=\"query\" value=\"");
	if (req->q.query != NULL)
		html_print(req->q.query);
	printf( "\" size=\"40\"");
	if (focus == FOCUS_QUERY)
		printf(" autofocus");
	puts(">");

	/* Write submission buttons. */

	printf(	"    <button type=\"submit\" name=\"apropos\" value=\"0\">"
		"man</button>\n"
		"    <button type=\"submit\" name=\"apropos\" value=\"1\">"
		"apropos</button>\n"
		"    <br/>\n");

	/* Write section selector. */

	puts("    <select name=\"sec\">");
	for (i = 0; i < sec_MAX; i++) {
		printf("      <option value=\"%s\"", sec_numbers[i]);
		if (NULL != req->q.sec &&
		    0 == strcmp(sec_numbers[i], req->q.sec))
			printf(" selected=\"selected\"");
		printf(">%s</option>\n", sec_names[i]);
	}
	puts("    </select>");

	/* Write architecture selector. */

	printf(	"    <select name=\"arch\">\n"
		"      <option value=\"default\"");
	if (NULL == req->q.arch)
		printf(" selected=\"selected\"");
	puts(">All Architectures</option>");
	for (i = 0; i < arch_MAX; i++) {
		printf("      <option value=\"%s\"", arch_names[i]);
		if (NULL != req->q.arch &&
		    0 == strcmp(arch_names[i], req->q.arch))
			printf(" selected=\"selected\"");
		printf(">%s</option>\n", arch_names[i]);
	}
	puts("    </select>");

	/* Write manpath selector. */

	if (req->psz > 1) {
		puts("    <select name=\"manpath\">");
		for (i = 0; i < (int)req->psz; i++) {
			printf("      <option ");
			if (strcmp(req->q.manpath, req->p[i]) == 0)
				printf("selected=\"selected\" ");
			printf("value=\"");
			html_print(req->p[i]);
			printf("\">");
			html_print(req->p[i]);
			puts("</option>");
		}
		puts("    </select>");
	}

	puts("  </fieldset>\n"
	     "</form>");
}

static int
validate_urifrag(const char *frag)
{

	while ('\0' != *frag) {
		if ( ! (isalnum((unsigned char)*frag) ||
		    '-' == *frag || '.' == *frag ||
		    '/' == *frag || '_' == *frag))
			return 0;
		frag++;
	}
	return 1;
}

static int
validate_manpath(const struct req *req, const char* manpath)
{
	size_t	 i;

	for (i = 0; i < req->psz; i++)
		if ( ! strcmp(manpath, req->p[i]))
			return 1;

	return 0;
}

static int
validate_filename(const char *file)
{

	if ('.' == file[0] && '/' == file[1])
		file += 2;

	return ! (strstr(file, "../") || strstr(file, "/..") ||
	    (strncmp(file, "man", 3) && strncmp(file, "cat", 3)));
}

static void
pg_index(const struct req *req)
{

	resp_begin_html(200, NULL, NULL);
	resp_searchform(req, FOCUS_QUERY);
	printf("<p>\n"
	       "This web interface is documented in the\n"
	       "<a class=\"Xr\" href=\"/%s%sman.cgi.8\">man.cgi(8)</a>\n"
	       "manual, and the\n"
	       "<a class=\"Xr\" href=\"/%s%sapropos.1\">apropos(1)</a>\n"
	       "manual explains the query syntax.\n"
	       "</p>\n",
	       scriptname, *scriptname == '\0' ? "" : "/",
	       scriptname, *scriptname == '\0' ? "" : "/");
	resp_end_html();
}

static void
pg_noresult(const struct req *req, const char *msg)
{
	resp_begin_html(200, NULL, NULL);
	resp_searchform(req, FOCUS_QUERY);
	puts("<p>");
	puts(msg);
	puts("</p>");
	resp_end_html();
}

static void
pg_error_badrequest(const char *msg)
{

	resp_begin_html(400, "Bad Request", NULL);
	puts("<h1>Bad Request</h1>\n"
	     "<p>\n");
	puts(msg);
	printf("Try again from the\n"
	       "<a href=\"/%s\">main page</a>.\n"
	       "</p>", scriptname);
	resp_end_html();
}

static void
pg_error_internal(void)
{
	resp_begin_html(500, "Internal Server Error", NULL);
	puts("<p>Internal Server Error</p>");
	resp_end_html();
}

static void
pg_redirect(const struct req *req, const char *name)
{
	printf("Status: 303 See Other\r\n"
	    "Location: /");
	if (*scriptname != '\0')
		printf("%s/", scriptname);
	if (strcmp(req->q.manpath, req->p[0]))
		printf("%s/", req->q.manpath);
	if (req->q.arch != NULL)
		printf("%s/", req->q.arch);
	printf("%s", name);
	if (req->q.sec != NULL)
		printf(".%s", req->q.sec);
	printf("\r\nContent-Type: text/html; charset=utf-8\r\n\r\n");
}

static void
pg_searchres(const struct req *req, struct manpage *r, size_t sz)
{
	char		*arch, *archend;
	const char	*sec;
	size_t		 i, iuse;
	int		 archprio, archpriouse;
	int		 prio, priouse;

	for (i = 0; i < sz; i++) {
		if (validate_filename(r[i].file))
			continue;
		warnx("invalid filename %s in %s database",
		    r[i].file, req->q.manpath);
		pg_error_internal();
		return;
	}

	if (req->isquery && sz == 1) {
		/*
		 * If we have just one result, then jump there now
		 * without any delay.
		 */
		printf("Status: 303 See Other\r\n"
		    "Location: /");
		if (*scriptname != '\0')
			printf("%s/", scriptname);
		if (strcmp(req->q.manpath, req->p[0]))
			printf("%s/", req->q.manpath);
		printf("%s\r\n"
		    "Content-Type: text/html; charset=utf-8\r\n\r\n",
		    r[0].file);
		return;
	}

	/*
	 * In man(1) mode, show one of the pages
	 * even if more than one is found.
	 */

	iuse = 0;
	if (req->q.equal || sz == 1) {
		priouse = 20;
		archpriouse = 3;
		for (i = 0; i < sz; i++) {
			sec = r[i].file;
			sec += strcspn(sec, "123456789");
			if (sec[0] == '\0')
				continue;
			prio = sec_prios[sec[0] - '1'];
			if (sec[1] != '/')
				prio += 10;
			if (req->q.arch == NULL) {
				archprio =
				    ((arch = strchr(sec + 1, '/'))
					== NULL) ? 3 :
				    ((archend = strchr(arch + 1, '/'))
					== NULL) ? 0 :
				    strncmp(arch, "amd64/",
					archend - arch) ? 2 : 1;
				if (archprio < archpriouse) {
					archpriouse = archprio;
					priouse = prio;
					iuse = i;
					continue;
				}
				if (archprio > archpriouse)
					continue;
			}
			if (prio >= priouse)
				continue;
			priouse = prio;
			iuse = i;
		}
		resp_begin_html(200, NULL, r[iuse].file);
	} else
		resp_begin_html(200, NULL, NULL);

	resp_searchform(req,
	    req->q.equal || sz == 1 ? FOCUS_NONE : FOCUS_QUERY);

	if (sz > 1) {
		puts("<table class=\"results\">");
		for (i = 0; i < sz; i++) {
			printf("  <tr>\n"
			       "    <td>"
			       "<a class=\"Xr\" href=\"/");
			if (*scriptname != '\0')
				printf("%s/", scriptname);
			if (strcmp(req->q.manpath, req->p[0]))
				printf("%s/", req->q.manpath);
			printf("%s\">", r[i].file);
			html_print(r[i].names);
			printf("</a></td>\n"
			       "    <td><span class=\"Nd\">");
			html_print(r[i].output);
			puts("</span></td>\n"
			     "  </tr>");
		}
		puts("</table>");
	}

	if (req->q.equal || sz == 1) {
		puts("<hr>");
		resp_show(req, r[iuse].file);
	}

	resp_end_html();
}

static void
resp_catman(const struct req *req, const char *file)
{
	FILE		*f;
	char		*p;
	size_t		 sz;
	ssize_t		 len;
	int		 i;
	int		 italic, bold;

	if ((f = fopen(file, "r")) == NULL) {
		puts("<p>You specified an invalid manual file.</p>");
		return;
	}

	puts("<div class=\"catman\">\n"
	     "<pre>");

	p = NULL;
	sz = 0;

	while ((len = getline(&p, &sz, f)) != -1) {
		bold = italic = 0;
		for (i = 0; i < len - 1; i++) {
			/*
			 * This means that the catpage is out of state.
			 * Ignore it and keep going (although the
			 * catpage is bogus).
			 */

			if ('\b' == p[i] || '\n' == p[i])
				continue;

			/*
			 * Print a regular character.
			 * Close out any bold/italic scopes.
			 * If we're in back-space mode, make sure we'll
			 * have something to enter when we backspace.
			 */

			if ('\b' != p[i + 1]) {
				if (italic)
					printf("</i>");
				if (bold)
					printf("</b>");
				italic = bold = 0;
				html_putchar(p[i]);
				continue;
			} else if (i + 2 >= len)
				continue;

			/* Italic mode. */

			if ('_' == p[i]) {
				if (bold)
					printf("</b>");
				if ( ! italic)
					printf("<i>");
				bold = 0;
				italic = 1;
				i += 2;
				html_putchar(p[i]);
				continue;
			}

			/*
			 * Handle funny behaviour troff-isms.
			 * These grok'd from the original man2html.c.
			 */

			if (('+' == p[i] && 'o' == p[i + 2]) ||
					('o' == p[i] && '+' == p[i + 2]) ||
					('|' == p[i] && '=' == p[i + 2]) ||
					('=' == p[i] && '|' == p[i + 2]) ||
					('*' == p[i] && '=' == p[i + 2]) ||
					('=' == p[i] && '*' == p[i + 2]) ||
					('*' == p[i] && '|' == p[i + 2]) ||
					('|' == p[i] && '*' == p[i + 2]))  {
				if (italic)
					printf("</i>");
				if (bold)
					printf("</b>");
				italic = bold = 0;
				putchar('*');
				i += 2;
				continue;
			} else if (('|' == p[i] && '-' == p[i + 2]) ||
					('-' == p[i] && '|' == p[i + 1]) ||
					('+' == p[i] && '-' == p[i + 1]) ||
					('-' == p[i] && '+' == p[i + 1]) ||
					('+' == p[i] && '|' == p[i + 1]) ||
					('|' == p[i] && '+' == p[i + 1]))  {
				if (italic)
					printf("</i>");
				if (bold)
					printf("</b>");
				italic = bold = 0;
				putchar('+');
				i += 2;
				continue;
			}

			/* Bold mode. */

			if (italic)
				printf("</i>");
			if ( ! bold)
				printf("<b>");
			bold = 1;
			italic = 0;
			i += 2;
			html_putchar(p[i]);
		}

		/*
		 * Clean up the last character.
		 * We can get to a newline; don't print that.
		 */

		if (italic)
			printf("</i>");
		if (bold)
			printf("</b>");

		if (i == len - 1 && p[i] != '\n')
			html_putchar(p[i]);

		putchar('\n');
	}
	free(p);

	puts("</pre>\n"
	     "</div>");

	fclose(f);
}

static void
resp_format(const struct req *req, const char *file)
{
	struct manoutput conf;
	struct mparse	*mp;
	struct roff_man	*man;
	void		*vp;
	int		 fd;
	int		 usepath;

	if (-1 == (fd = open(file, O_RDONLY, 0))) {
		puts("<p>You specified an invalid manual file.</p>");
		return;
	}

	mchars_alloc();
	mp = mparse_alloc(MPARSE_SO | MPARSE_UTF8 | MPARSE_LATIN1,
	    MANDOCERR_MAX, NULL, MANDOC_OS_OTHER, req->q.manpath);
	mparse_readfd(mp, fd, file);
	close(fd);

	memset(&conf, 0, sizeof(conf));
	conf.fragment = 1;
	conf.style = mandoc_strdup(CSS_DIR "/mandoc.css");
	usepath = strcmp(req->q.manpath, req->p[0]);
	mandoc_asprintf(&conf.man, "/%s%s%s%s%%N.%%S",
	    scriptname, *scriptname == '\0' ? "" : "/",
	    usepath ? req->q.manpath : "", usepath ? "/" : "");

	mparse_result(mp, &man, NULL);
	if (man == NULL) {
		warnx("fatal mandoc error: %s/%s", req->q.manpath, file);
		pg_error_internal();
		mparse_free(mp);
		mchars_free();
		return;
	}

	vp = html_alloc(&conf);

	if (man->macroset == MACROSET_MDOC) {
		mdoc_validate(man);
		html_mdoc(vp, man);
	} else {
		man_validate(man);
		html_man(vp, man);
	}

	html_free(vp);
	mparse_free(mp);
	mchars_free();
	free(conf.man);
	free(conf.style);
}

static void
resp_show(const struct req *req, const char *file)
{

	if ('.' == file[0] && '/' == file[1])
		file += 2;

	if ('c' == *file)
		resp_catman(req, file);
	else
		resp_format(req, file);
}

static void
pg_show(struct req *req, const char *fullpath)
{
	char		*manpath;
	const char	*file;

	if ((file = strchr(fullpath, '/')) == NULL) {
		pg_error_badrequest(
		    "You did not specify a page to show.");
		return;
	}
	manpath = mandoc_strndup(fullpath, file - fullpath);
	file++;

	if ( ! validate_manpath(req, manpath)) {
		pg_error_badrequest(
		    "You specified an invalid manpath.");
		free(manpath);
		return;
	}

	/*
	 * Begin by chdir()ing into the manpath.
	 * This way we can pick up the database files, which are
	 * relative to the manpath root.
	 */

	if (chdir(manpath) == -1) {
		warn("chdir %s", manpath);
		pg_error_internal();
		free(manpath);
		return;
	}
	free(manpath);

	if ( ! validate_filename(file)) {
		pg_error_badrequest(
		    "You specified an invalid manual file.");
		return;
	}

	resp_begin_html(200, NULL, file);
	resp_searchform(req, FOCUS_NONE);
	resp_show(req, file);
	resp_end_html();
}

static void
pg_search(const struct req *req)
{
	struct mansearch	  search;
	struct manpaths		  paths;
	struct manpage		 *res;
	char			**argv;
	char			 *query, *rp, *wp;
	size_t			  ressz;
	int			  argc;

	/*
	 * Begin by chdir()ing into the root of the manpath.
	 * This way we can pick up the database files, which are
	 * relative to the manpath root.
	 */

	if (chdir(req->q.manpath) == -1) {
		warn("chdir %s", req->q.manpath);
		pg_error_internal();
		return;
	}

	search.arch = req->q.arch;
	search.sec = req->q.sec;
	search.outkey = "Nd";
	search.argmode = req->q.equal ? ARG_NAME : ARG_EXPR;
	search.firstmatch = 1;

	paths.sz = 1;
	paths.paths = mandoc_malloc(sizeof(char *));
	paths.paths[0] = mandoc_strdup(".");

	/*
	 * Break apart at spaces with backslash-escaping.
	 */

	argc = 0;
	argv = NULL;
	rp = query = mandoc_strdup(req->q.query);
	for (;;) {
		while (isspace((unsigned char)*rp))
			rp++;
		if (*rp == '\0')
			break;
		argv = mandoc_reallocarray(argv, argc + 1, sizeof(char *));
		argv[argc++] = wp = rp;
		for (;;) {
			if (isspace((unsigned char)*rp)) {
				*wp = '\0';
				rp++;
				break;
			}
			if (rp[0] == '\\' && rp[1] != '\0')
				rp++;
			if (wp != rp)
				*wp = *rp;
			if (*rp == '\0')
				break;
			wp++;
			rp++;
		}
	}

	res = NULL;
	ressz = 0;
	if (req->isquery && req->q.equal && argc == 1)
		pg_redirect(req, argv[0]);
	else if (mansearch(&search, &paths, argc, argv, &res, &ressz) == 0)
		pg_noresult(req, "You entered an invalid query.");
	else if (ressz == 0)
		pg_noresult(req, "No results found.");
	else
		pg_searchres(req, res, ressz);

	free(query);
	mansearch_free(res, ressz);
	free(paths.paths[0]);
	free(paths.paths);
}

int
main(void)
{
	struct req	 req;
	struct itimerval itimer;
	const char	*path;
	const char	*querystring;
	int		 i;

	/*
	 * The "rpath" pledge could be revoked after mparse_readfd()
	 * if the file desciptor to "/footer.html" would be opened
	 * up front, but it's probably not worth the complication
	 * of the code it would cause: it would require scattering
	 * pledge() calls in multiple low-level resp_*() functions.
	 */

	if (pledge("stdio rpath", NULL) == -1) {
		warn("pledge");
		pg_error_internal();
		return EXIT_FAILURE;
	}

	/* Poor man's ReDoS mitigation. */

	itimer.it_value.tv_sec = 2;
	itimer.it_value.tv_usec = 0;
	itimer.it_interval.tv_sec = 2;
	itimer.it_interval.tv_usec = 0;
	if (setitimer(ITIMER_VIRTUAL, &itimer, NULL) == -1) {
		warn("setitimer");
		pg_error_internal();
		return EXIT_FAILURE;
	}

	/*
	 * First we change directory into the MAN_DIR so that
	 * subsequent scanning for manpath directories is rooted
	 * relative to the same position.
	 */

	if (chdir(MAN_DIR) == -1) {
		warn("MAN_DIR: %s", MAN_DIR);
		pg_error_internal();
		return EXIT_FAILURE;
	}

	memset(&req, 0, sizeof(struct req));
	req.q.equal = 1;
	parse_manpath_conf(&req);

	/* Parse the path info and the query string. */

	if ((path = getenv("PATH_INFO")) == NULL)
		path = "";
	else if (*path == '/')
		path++;

	if (*path != '\0') {
		parse_path_info(&req, path);
		if (req.q.manpath == NULL || req.q.sec == NULL ||
		    *req.q.query == '\0' || access(path, F_OK) == -1)
			path = "";
	} else if ((querystring = getenv("QUERY_STRING")) != NULL)
		parse_query_string(&req, querystring);

	/* Validate parsed data and add defaults. */

	if (req.q.manpath == NULL)
		req.q.manpath = mandoc_strdup(req.p[0]);
	else if ( ! validate_manpath(&req, req.q.manpath)) {
		pg_error_badrequest(
		    "You specified an invalid manpath.");
		return EXIT_FAILURE;
	}

	if ( ! (NULL == req.q.arch || validate_urifrag(req.q.arch))) {
		pg_error_badrequest(
		    "You specified an invalid architecture.");
		return EXIT_FAILURE;
	}

	/* Dispatch to the three different pages. */

	if ('\0' != *path)
		pg_show(&req, path);
	else if (NULL != req.q.query)
		pg_search(&req);
	else
		pg_index(&req);

	free(req.q.manpath);
	free(req.q.arch);
	free(req.q.sec);
	free(req.q.query);
	for (i = 0; i < (int)req.psz; i++)
		free(req.p[i]);
	free(req.p);
	return EXIT_SUCCESS;
}

/*
 * If PATH_INFO is not a file name, translate it to a query.
 */
static void
parse_path_info(struct req *req, const char *path)
{
	char	*dir[4];
	int	 i;

	req->isquery = 0;
	req->q.equal = 1;
	req->q.manpath = mandoc_strdup(path);
	req->q.arch = NULL;

	/* Mandatory manual page name. */
	if ((req->q.query = strrchr(req->q.manpath, '/')) == NULL) {
		req->q.query = req->q.manpath;
		req->q.manpath = NULL;
	} else
		*req->q.query++ = '\0';

	/* Optional trailing section. */
	if ((req->q.sec = strrchr(req->q.query, '.')) != NULL) {
		if(isdigit((unsigned char)req->q.sec[1])) {
			*req->q.sec++ = '\0';
			req->q.sec = mandoc_strdup(req->q.sec);
		} else
			req->q.sec = NULL;
	}

	/* Handle the case of name[.section] only. */
	if (req->q.manpath == NULL)
		return;
	req->q.query = mandoc_strdup(req->q.query);

	/* Split directory components. */
	dir[i = 0] = req->q.manpath;
	while ((dir[i + 1] = strchr(dir[i], '/')) != NULL) {
		if (++i == 3) {
			pg_error_badrequest(
			    "You specified too many directory components.");
			exit(EXIT_FAILURE);
		}
		*dir[i]++ = '\0';
	}

	/* Optional manpath. */
	if ((i = validate_manpath(req, req->q.manpath)) == 0)
		req->q.manpath = NULL;
	else if (dir[1] == NULL)
		return;

	/* Optional section. */
	if (strncmp(dir[i], "man", 3) == 0) {
		free(req->q.sec);
		req->q.sec = mandoc_strdup(dir[i++] + 3);
	}
	if (dir[i] == NULL) {
		if (req->q.manpath == NULL)
			free(dir[0]);
		return;
	}
	if (dir[i + 1] != NULL) {
		pg_error_badrequest(
		    "You specified an invalid directory component.");
		exit(EXIT_FAILURE);
	}

	/* Optional architecture. */
	if (i) {
		req->q.arch = mandoc_strdup(dir[i]);
		if (req->q.manpath == NULL)
			free(dir[0]);
	} else
		req->q.arch = dir[0];
}

/*
 * Scan for indexable paths.
 */
static void
parse_manpath_conf(struct req *req)
{
	FILE	*fp;
	char	*dp;
	size_t	 dpsz;
	ssize_t	 len;

	if ((fp = fopen("manpath.conf", "r")) == NULL) {
		warn("%s/manpath.conf", MAN_DIR);
		pg_error_internal();
		exit(EXIT_FAILURE);
	}

	dp = NULL;
	dpsz = 0;

	while ((len = getline(&dp, &dpsz, fp)) != -1) {
		if (dp[len - 1] == '\n')
			dp[--len] = '\0';
		req->p = mandoc_realloc(req->p,
		    (req->psz + 1) * sizeof(char *));
		if ( ! validate_urifrag(dp)) {
			warnx("%s/manpath.conf contains "
			    "unsafe path \"%s\"", MAN_DIR, dp);
			pg_error_internal();
			exit(EXIT_FAILURE);
		}
		if (strchr(dp, '/') != NULL) {
			warnx("%s/manpath.conf contains "
			    "path with slash \"%s\"", MAN_DIR, dp);
			pg_error_internal();
			exit(EXIT_FAILURE);
		}
		req->p[req->psz++] = dp;
		dp = NULL;
		dpsz = 0;
	}
	free(dp);

	if (req->p == NULL) {
		warnx("%s/manpath.conf is empty", MAN_DIR);
		pg_error_internal();
		exit(EXIT_FAILURE);
	}
}
@


1.93
log
@KNF: remove parentheses from switch case labels; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.92 2017/04/19 00:59:32 schwarze Exp $ */
d831 1
a831 1
	    MANDOCLEVEL_BADARG, NULL, req->q.manpath);
@


1.92
log
@More thoroughly reject direct access to unintended files, such that
URIs like http://man.openbsd.org/OpenBSD-current/mandoc.db and
http://man.openbsd.org/OpenBSD-current/man1/ do not cause display
of garbage.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.91 2017/03/18 16:48:07 schwarze Exp $ */
d139 1
a139 1
	case ('"'):
d142 1
a142 1
	case ('&'):
d145 1
a145 1
	case ('>'):
d148 1
a148 1
	case ('<'):
@


1.91
log
@Simplify: write HTTP 303 redirects with relative locations.
Suggested by bentley@@.

Delete the HTTP_HOST configuration variable that is now obsolete.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.90 2017/03/18 16:18:45 schwarze Exp $ */
d1070 2
a1071 1
		if (req.q.manpath == NULL || access(path, F_OK) == -1)
@


1.90
log
@Bugfix: use SCRIPT_NAME for .Xr hyperlinks.
Patch from <andreas at AndreasVoegele dot com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.89 2017/03/15 13:49:26 schwarze Exp $ */
d553 2
a554 2
	printf("Status: 303 See Other\r\n");
	printf("Location: http://%s/", HTTP_HOST);
d590 9
a598 8
		printf("Status: 303 See Other\r\n");
		printf("Location: http://%s/%s%s%s/%s",
		    HTTP_HOST, scriptname,
		    *scriptname == '\0' ? "" : "/",
		    req->q.manpath, r[0].file);
		printf("\r\n"
		     "Content-Type: text/html; charset=utf-8\r\n"
		     "\r\n");
@


1.89
log
@In URIs in apropos(1) result tables,
only write the manpath if it does not match the default.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.88 2017/03/15 13:18:48 schwarze Exp $ */
d838 2
a839 1
	mandoc_asprintf(&conf.man, "/%s%s%%N.%%S",
@


1.88
log
@Mention the manual page name and section in the HTML page <title>.
Based on a patch from <Anton dot Lindqvist at gmail dot com>,
but simplified and also covering apropos(1) search results.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.87 2017/03/15 10:17:08 schwarze Exp $ */
d652 6
a657 3
			       "<a class=\"Xr\" href=\"/%s%s%s/%s\">",
			    scriptname, *scriptname == '\0' ? "" : "/",
			    req->q.manpath, r[i].file);
@


1.87
log
@It's annoying that people keep writing URIs including redundant parts
like "/OpenBSD-current/manN/".  To discourage that, let man.cgi(8)
redirect search form results to nice, concise URIs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.86 2017/02/22 16:16:35 schwarze Exp $ */
d80 1
a80 1
static	void		 resp_begin_html(int, const char *);
d345 1
a345 1
resp_begin_html(int code, const char *msg)
d347 1
d357 11
a367 1
	       "  <title>%s</title>\n"
d370 1
a370 1
	       CSS_DIR, CUSTOMIZE_TITLE);
d503 1
a503 1
	resp_begin_html(200, NULL);
d520 1
a520 1
	resp_begin_html(200, NULL);
d532 1
a532 1
	resp_begin_html(400, "Bad Request");
d545 1
a545 1
	resp_begin_html(500, "Internal Server Error");
a600 22
	resp_begin_html(200, NULL);
	resp_searchform(req,
	    req->q.equal || sz == 1 ? FOCUS_NONE : FOCUS_QUERY);

	if (sz > 1) {
		puts("<table class=\"results\">");
		for (i = 0; i < sz; i++) {
			printf("  <tr>\n"
			       "    <td>"
			       "<a class=\"Xr\" href=\"/%s%s%s/%s\">",
			    scriptname, *scriptname == '\0' ? "" : "/",
			    req->q.manpath, r[i].file);
			html_print(r[i].names);
			printf("</a></td>\n"
			       "    <td><span class=\"Nd\">");
			html_print(r[i].output);
			puts("</span></td>\n"
			     "  </tr>");
		}
		puts("</table>");
	}

d606 1
a607 2
		puts("<hr>");
		iuse = 0;
d640 27
d918 1
a918 1
	resp_begin_html(200, NULL);
@


1.86
log
@Pledge man.cgi(8).
Based on a more complicated patch from semarie@@.
Sebastien and tb@@ both agree with the simplification.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.85 2017/01/25 03:19:56 deraadt Exp $ */
d75 1
d540 17
d973 5
a977 1
	if (0 == mansearch(&search, &paths, argc, argv, &res, &ressz))
d979 1
a979 1
	else if (0 == ressz)
@


1.85
log
@+arm64
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.84 2017/01/25 02:14:41 schwarze Exp $ */
d976 14
@


1.84
log
@Improve HTML formatting of .Bl -tag.

In particular, when using the style sheet, put the body on the same
line as the head for short heads, or on the next line for long
heads, in a way that preserves both correct indentation and correct
vertical spacing with and without -compact, and with one or more
heads per body (hi, Zaphod) - eight use cases so far - and with and
without -tag, and with and without -offset, 32 use cases grand total.

Using many ideas from zhuk@@, from <David dot Dahlberg at fkie dot
fraunhofer dot de>, and from Benny Lofgren <bl dash lists at lofgren
dot biz>, and a few of my own.

This is an excellent demonstration that CSS is an extremely hostile
language, much more trapful and much harder to use than, say, C.
When matthew@@ reported this in July 2014 (!), it was already a known
issue, and i no longer remember for how long.  My first serious
attempt at fixing it (in November 2015) failed miserably.  I'd love
to see simplifications of both the generated HTML code and of the
style sheet, but without breaking any of the 32 use cases, please.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.83 2017/01/21 01:20:29 schwarze Exp $ */
d114 1
a114 1
    "amd64",       "alpha",       "armv7",
@


1.83
log
@clean up the remaining class attributes
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.82 2017/01/19 13:55:49 schwarze Exp $ */
d800 1
d828 1
@


1.82
log
@Adjust indentation of the HTML output to the conventions established
by html.c.  No semantic change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.81 2017/01/19 13:34:59 schwarze Exp $ */
d495 1
a495 1
	       "<a href=\"/%s%sman.cgi.8\">man.cgi(8)</a>\n"
d497 1
a497 1
	       "<a href=\"/%s%sapropos.1\">apropos(1)</a>\n"
d577 1
a577 3
		puts("<div class=\"results\">");
		puts("<table>");

d580 2
a581 2
			       "    <td class=\"title\">"
			       "<a href=\"/%s%s%s/%s",
a583 1
			printf("\">");
d586 1
a586 1
			       "    <td class=\"desc\">");
d588 1
a588 1
			puts("</td>\n"
d591 1
a591 3

		puts("</table>\n"
		     "</div>");
@


1.81
log
@Start cleanup: trim useless HTML comments and <div> elements
on the <html> and <body> levels.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.80 2016/09/11 23:59:02 bentley Exp $ */
d352 2
a353 2
	       "<meta charset=\"UTF-8\"/>\n"
	       "<link rel=\"stylesheet\" href=\"%s/mandoc.css\""
d355 1
a355 1
	       "<title>%s</title>\n"
d379 2
a380 2
	       "<fieldset>\n"
	       "<legend>Manual Page Search Parameters</legend>\n",
d385 1
a385 1
	printf("<input type=\"text\" name=\"query\" value=\"");
d395 1
a395 1
	printf(	"<button type=\"submit\" name=\"apropos\" value=\"0\">"
d397 3
a399 2
		"<button type=\"submit\" name=\"apropos\" value=\"1\">"
		"apropos</button>\n<br/>\n");
d403 1
a403 1
	puts("<select name=\"sec\">");
d405 1
a405 1
		printf("<option value=\"%s\"", sec_numbers[i]);
d411 1
a411 1
	puts("</select>");
d415 2
a416 2
	printf(	"<select name=\"arch\">\n"
		"<option value=\"default\"");
d421 1
a421 1
		printf("<option value=\"%s\"", arch_names[i]);
d427 1
a427 1
	puts("</select>");
d432 1
a432 1
		puts("<select name=\"manpath\">");
d434 1
a434 1
			printf("<option ");
d443 1
a443 1
		puts("</select>");
d446 1
a446 1
	puts("</fieldset>\n"
d581 2
a582 2
			printf("<tr>\n"
			       "<td class=\"title\">\n"
d588 2
a589 3
			printf("</a>\n"
			       "</td>\n"
			       "<td class=\"desc\">");
d592 1
a592 1
			     "</tr>");
@


1.80
log
@Use the proper HTML escape for double quote ("): &quot; not &quote;.

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.79 2016/09/03 21:24:35 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014, 2015, 2016 Ingo Schwarze <schwarze@@usta.de>
d357 1
a357 2
	       "<body>\n"
	       "<!-- Begin page content. //-->\n",
d378 1
a378 3
	puts("<!-- Begin search form. //-->");
	printf("<div id=\"mancgi\">\n"
	       "<form action=\"/%s\" method=\"get\">\n"
d446 1
a446 3
	     "</form>\n"
	     "</div>");
	puts("<!-- End search form. //-->");
@


1.79
log
@move zaurus down to the discontinued architectures
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.78 2016/09/01 15:07:19 schwarze Exp $ */
d139 1
a139 1
		printf("&quote;");
@


1.78
log
@move "sparc" down to discontinued architectures
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.77 2016/08/18 00:44:37 jsg Exp $ */
d117 1
a117 2
    "octeon",      "sgi",         "socppc",
    "sparc64",     "zaurus",
d124 2
a125 1
    "sun3",        "vax",         "wgrisc",      "x68k"
@


1.77
log
@fix an fd leak
ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.76 2016/08/10 18:39:04 schwarze Exp $ */
d117 1
a117 1
    "octeon",      "sgi",         "socppc",      "sparc",
d124 2
a125 2
    "pmax",        "powerpc",     "solbourne",   "sun3",
    "vax",         "wgrisc",      "x68k"
@


1.76
log
@move armish and hppa64 down in the dropdown box; reminded by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.75 2016/07/31 23:35:26 schwarze Exp $ */
d339 1
@


1.75
log
@Some base system pages, for example perl(1), contain non-ASCII
characters in their source code, so switch on charset autodetection
in the same way as in man(1) itself.
Issue reported by Pavan Maddamsetti at gmail dot com on bugs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.74 2016/07/11 22:46:57 schwarze Exp $ */
d114 2
a115 2
    "amd64",       "alpha",       "armish",      "armv7",
    "hppa",        "hppa64",      "i386",        "landisk",
d119 3
a121 2
    "amiga",       "arc",         "arm32",       "atari",
    "aviion",      "beagle",      "cats",        "hp300",       
@


1.74
log
@Make all components of the URI individually optional,
independent of each other, as in:
http://man.openbsd.org[/manpath][/mansec][/arch]/name[.sec]
The restrictions in the past kept confusing people.
Triggered by a question from RafaelNeves at gmail dot com.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.73 2016/07/10 10:03:15 schwarze Exp $ */
d801 2
a802 1
	mp = mparse_alloc(MPARSE_SO, MANDOCLEVEL_BADARG, NULL, req->q.manpath);
@


1.73
log
@Simplify the code and the server setup by deleting the pseudo-manpath
"mandoc" that was used for man.cgi(8) documentation and by assuming
that the apropos(1) and man.cgi(8) manuals are simply installed in
the default manpath.  Even though man.cgi(8) is not installed by
default when installing OpenBSD, it is easy to copy it into the
default manpath used for man.cgi(8).

Idea found when considering a question asked by wrant dot com.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.72 2016/07/09 19:44:52 schwarze Exp $ */
d1065 2
a1066 1
	char	*dir;
d1071 1
d1090 1
a1090 2
	if (req->q.manpath == NULL) {
		req->q.arch = NULL;
d1092 11
a1103 1
	req->q.query = mandoc_strdup(req->q.query);
d1105 5
a1109 8
	/* Optional architecture. */
	dir = strrchr(req->q.manpath, '/');
	if (dir != NULL && strncmp(dir + 1, "man", 3) != 0) {
		*dir++ = '\0';
		req->q.arch = mandoc_strdup(dir);
		dir = strrchr(req->q.manpath, '/');
	} else
		req->q.arch = NULL;
d1111 2
a1112 3
	/* Optional directory name. */
	if (dir != NULL && strncmp(dir + 1, "man", 3) == 0) {
		*dir++ = '\0';
d1114 1
a1114 1
		req->q.sec = mandoc_strdup(dir + 3);
d1116 18
@


1.72
log
@Do not treat PATH_INFO as a complete path if it doesn't contain
a manpath.  For example, this makes http://man.openbsd.org/mandoc
work as expected.
Bug reported by tb@@, reminded by Svyatoslav Mishyn.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.71 2016/05/28 13:40:44 schwarze Exp $ */
a470 3
	if ( ! strcmp(manpath, "mandoc"))
		return 1;

d497 1
a497 1
	       "<a href=\"/%s%smandoc/man8/man.cgi.8\">man.cgi</a>\n"
d499 1
a499 1
	       "<a href=\"/%s%smandoc/man1/apropos.1\">apropos</a>\n"
d882 1
a882 6

	if (strcmp(manpath, "mandoc")) {
		free(req->q.manpath);
		req->q.manpath = manpath;
	} else
		free(manpath);
@


1.71
log
@Simplify search form: minus two visible control elements, minus
one table, minus twenty lines of code, no loss of functionality.
No idea why i didn't do this earlier...
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.70 2016/04/29 10:45:06 schwarze Exp $ */
d1027 1
a1027 1
		if (access(path, F_OK) == -1)
@


1.70
log
@Only focus on the query input box when no manual page is displayed,
that is, for the index page, for the noresult page, and for the
result of an apropos(1) query with more than one page.
As noted by bentley@@, when a manual page is displayed, it is more
important that people can quickly use the space bar for paging and
Ctrl-F for searching.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.69 2016/04/28 17:59:00 schwarze Exp $ */
d386 1
a386 2
	printf(	"<table><tr><td>\n"
		"<input type=\"text\" name=\"query\" value=\"");
d394 1
a394 1
	/* Write submission and reset buttons. */
d396 4
a399 11
	printf(	"<input type=\"submit\" value=\"Submit\">\n"
		"<input type=\"reset\" value=\"Reset\">\n");

	/* Write show radio button */

	printf(	"</td><td>\n"
		"<input type=\"radio\" ");
	if (req->q.equal)
		printf("checked=\"checked\" ");
	printf(	"name=\"apropos\" id=\"show\" value=\"0\">\n"
		"<label for=\"show\">Show named manual page</label>\n");
d403 1
a403 2
	puts(	"</td></tr><tr><td>\n"
		"<select name=\"sec\">");
d446 1
a446 11
	/* Write search radio button */

	printf(	"</td><td>\n"
		"<input type=\"radio\" ");
	if (0 == req->q.equal)
		printf("checked=\"checked\" ");
	printf(	"name=\"apropos\" id=\"search\" value=\"1\">\n"
		"<label for=\"search\">Search with apropos query</label>\n");

	puts("</td></tr></table>\n"
	     "</fieldset>\n"
@


1.69
log
@Set the "autofocus" attribute on the query text box.
Patch from Fabian dot Raetz at gmail dot com.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.68 2016/04/15 21:14:03 schwarze Exp $ */
d60 5
d85 1
a85 1
static	void		 resp_searchform(const struct req *);
d373 1
a373 1
resp_searchform(const struct req *req)
d388 1
a388 1
	if (NULL != req->q.query)
d390 4
a393 1
	puts("\" size=\"40\" autofocus>");
d516 1
a516 1
	resp_searchform(req);
d533 1
a533 1
	resp_searchform(req);
d597 2
a598 1
	resp_searchform(req);
d918 1
a918 1
	resp_searchform(req);
@


1.68
log
@Rename five static functions to make the classification of functions
as parsers, page generators, and result generators more obvious.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.67 2016/04/15 16:42:39 schwarze Exp $ */
d385 1
a385 1
	puts("\" size=\"40\">");
@


1.67
log
@prefer warn[x](3) over fprintf(3) where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.66 2016/04/15 15:13:02 schwarze Exp $ */
a59 2
static	void		 catman(const struct req *, const char *);
static	void		 format(const struct req *, const char *);
d63 3
a65 3
static	void		 http_parse(struct req *, const char *);
static	void		 pathgen(struct req *);
static	void		 path_parse(struct req *req, const char *path);
d76 1
d79 1
d186 1
a186 1
http_parse(struct req *req, const char *qs)
d662 1
a662 1
catman(const struct req *req, const char *file)
d799 1
a799 1
format(const struct req *req, const char *file)
d857 1
a857 1
		catman(req, file);
d859 1
a859 1
		format(req, file);
d1026 1
a1026 1
	pathgen(&req);
d1036 1
a1036 1
		path_parse(&req, path);
d1040 1
a1040 1
		http_parse(&req, querystring);
d1081 1
a1081 1
path_parse(struct req *req, const char *path)
d1133 1
a1133 1
pathgen(struct req *req)
@


1.66
log
@Fix parsing of PATH_INFO if both a section directory and an
architecture subdirectory are specified.  Issue reported by tb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.65 2016/04/15 01:33:48 schwarze Exp $ */
d22 1
d566 1
a566 1
		fprintf(stderr, "invalid filename %s in %s database\n",
d826 1
a826 2
		fprintf(stderr, "fatal mandoc error: %s/%s\n",
		    req->q.manpath, file);
d890 1
a890 2
		fprintf(stderr, "chdir %s: %s\n",
		    manpath, strerror(errno));
d931 2
a932 3
	if (-1 == (chdir(req->q.manpath))) {
		fprintf(stderr, "chdir %s: %s\n",
		    req->q.manpath, strerror(errno));
d1007 1
a1007 1
		fprintf(stderr, "setitimer: %s\n", strerror(errno));
d1018 2
a1019 3
	if (-1 == chdir(MAN_DIR)) {
		fprintf(stderr, "MAN_DIR: %s: %s\n",
		    MAN_DIR, strerror(errno));
d1140 2
a1141 3
	if (NULL == (fp = fopen("manpath.conf", "r"))) {
		fprintf(stderr, "%s/manpath.conf: %s\n",
			MAN_DIR, strerror(errno));
d1155 2
a1156 2
			fprintf(stderr, "%s/manpath.conf contains "
			    "unsafe path \"%s\"\n", MAN_DIR, dp);
d1160 3
a1162 3
		if (NULL != strchr(dp, '/')) {
			fprintf(stderr, "%s/manpath.conf contains "
			    "path with slash \"%s\"\n", MAN_DIR, dp);
d1172 2
a1173 2
	if ( req->p == NULL ) {
		fprintf(stderr, "%s/manpath.conf is empty\n", MAN_DIR);
@


1.65
log
@Make HTML tags lower case for better stylistic agreement with what
html.c does.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.64 2016/04/15 00:51:39 schwarze Exp $ */
d1086 1
a1086 1
	int	 dir_done;
d1116 7
a1122 9
	dir_done = 0;
	for (;;) {
		if ((req->q.arch = strrchr(req->q.manpath, '/')) == NULL)
			break;
		*req->q.arch++ = '\0';
		if (dir_done || strncmp(req->q.arch, "man", 3)) {
			req->q.arch = mandoc_strdup(req->q.arch);
			break;
		}
d1124 5
a1128 7
		/* Optional directory name. */
		req->q.arch += 3;
		if (*req->q.arch != '\0') {
			free(req->q.sec);
			req->q.sec = mandoc_strdup(req->q.arch);
		}
		dir_done = 1;
@


1.64
log
@In the architectures dropdown, move aviion, ia64, solbourne, and vax
down to the currently unsupported entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.63 2016/04/15 00:36:18 schwarze Exp $ */
d342 8
a349 8
	       "<HTML>\n"
	       "<HEAD>\n"
	       "<META CHARSET=\"UTF-8\" />\n"
	       "<LINK REL=\"stylesheet\" HREF=\"%s/mandoc.css\""
	       " TYPE=\"text/css\" media=\"all\">\n"
	       "<TITLE>%s</TITLE>\n"
	       "</HEAD>\n"
	       "<BODY>\n"
d362 2
a363 2
	puts("</BODY>\n"
	     "</HTML>");
d372 4
a375 4
	printf("<DIV ID=\"mancgi\">\n"
	       "<FORM ACTION=\"/%s\" METHOD=\"get\">\n"
	       "<FIELDSET>\n"
	       "<LEGEND>Manual Page Search Parameters</LEGEND>\n",
d380 2
a381 2
	printf(	"<TABLE><TR><TD>\n"
		"<INPUT TYPE=\"text\" NAME=\"query\" VALUE=\"");
d384 1
a384 1
	puts("\" SIZE=\"40\">");
d388 2
a389 2
	printf(	"<INPUT TYPE=\"submit\" VALUE=\"Submit\">\n"
		"<INPUT TYPE=\"reset\" VALUE=\"Reset\">\n");
d393 2
a394 2
	printf(	"</TD><TD>\n"
		"<INPUT TYPE=\"radio\" ");
d396 3
a398 3
		printf("CHECKED=\"checked\" ");
	printf(	"NAME=\"apropos\" ID=\"show\" VALUE=\"0\">\n"
		"<LABEL FOR=\"show\">Show named manual page</LABEL>\n");
d402 2
a403 2
	puts(	"</TD></TR><TR><TD>\n"
		"<SELECT NAME=\"sec\">");
d405 1
a405 1
		printf("<OPTION VALUE=\"%s\"", sec_numbers[i]);
d408 2
a409 2
			printf(" SELECTED=\"selected\"");
		printf(">%s</OPTION>\n", sec_names[i]);
d411 1
a411 1
	puts("</SELECT>");
d415 2
a416 2
	printf(	"<SELECT NAME=\"arch\">\n"
		"<OPTION VALUE=\"default\"");
d418 2
a419 2
		printf(" SELECTED=\"selected\"");
	puts(">All Architectures</OPTION>");
d421 1
a421 1
		printf("<OPTION VALUE=\"%s\"", arch_names[i]);
d424 2
a425 2
			printf(" SELECTED=\"selected\"");
		printf(">%s</OPTION>\n", arch_names[i]);
d427 1
a427 1
	puts("</SELECT>");
d432 1
a432 1
		puts("<SELECT NAME=\"manpath\">");
d434 1
a434 1
			printf("<OPTION ");
d436 2
a437 2
				printf("SELECTED=\"selected\" ");
			printf("VALUE=\"");
d441 1
a441 1
			puts("</OPTION>");
d443 1
a443 1
		puts("</SELECT>");
d448 2
a449 2
	printf(	"</TD><TD>\n"
		"<INPUT TYPE=\"radio\" ");
d451 8
a458 8
		printf("CHECKED=\"checked\" ");
	printf(	"NAME=\"apropos\" ID=\"search\" VALUE=\"1\">\n"
		"<LABEL FOR=\"search\">Search with apropos query</LABEL>\n");

	puts("</TD></TR></TABLE>\n"
	     "</FIELDSET>\n"
	     "</FORM>\n"
	     "</DIV>");
d508 1
a508 1
	printf("<P>\n"
d510 1
a510 1
	       "<A HREF=\"/%s%smandoc/man8/man.cgi.8\">man.cgi</A>\n"
d512 1
a512 1
	       "<A HREF=\"/%s%smandoc/man1/apropos.1\">apropos</A>\n"
d514 1
a514 1
	       "</P>\n",
d525 1
a525 1
	puts("<P>");
d527 1
a527 1
	puts("</P>");
d536 2
a537 2
	puts("<H1>Bad Request</H1>\n"
	     "<P>\n");
d540 2
a541 2
	       "<A HREF=\"/%s\">main page</A>.\n"
	       "</P>", scriptname);
d549 1
a549 1
	puts("<P>Internal Server Error</P>");
d591 2
a592 2
		puts("<DIV CLASS=\"results\">");
		puts("<TABLE>");
d595 3
a597 3
			printf("<TR>\n"
			       "<TD CLASS=\"title\">\n"
			       "<A HREF=\"/%s%s%s/%s",
d602 3
a604 3
			printf("</A>\n"
			       "</TD>\n"
			       "<TD CLASS=\"desc\">");
d606 2
a607 2
			puts("</TD>\n"
			     "</TR>");
d610 2
a611 2
		puts("</TABLE>\n"
		     "</DIV>");
d620 1
a620 1
		puts("<HR>");
d671 1
a671 1
		puts("<P>You specified an invalid manual file.</P>");
d675 2
a676 2
	puts("<DIV CLASS=\"catman\">\n"
	     "<PRE>");
d702 1
a702 1
					printf("</I>");
d704 1
a704 1
					printf("</B>");
d715 1
a715 1
					printf("</B>");
d717 1
a717 1
					printf("<I>");
d739 1
a739 1
					printf("</I>");
d741 1
a741 1
					printf("</B>");
d753 1
a753 1
					printf("</I>");
d755 1
a755 1
					printf("</B>");
d765 1
a765 1
				printf("</I>");
d767 1
a767 1
				printf("<B>");
d780 1
a780 1
			printf("</I>");
d782 1
a782 1
			printf("</B>");
d791 2
a792 2
	puts("</PRE>\n"
	     "</DIV>");
d808 1
a808 1
		puts("<P>You specified an invalid manual file.</P>");
@


1.63
log
@If PATH_INFO contains a complete and correct path to a manual page
file, for example "/OpenBSD-5.9/man2/pledge.2", no database query
is needed and the file is delivered directly.

But even in this case, let's parse the PATH_INFO and fill the query
structure such that the search form at the top of the result page
gets pre-filled with useful values.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.62 2016/04/15 00:12:50 schwarze Exp $ */
d109 4
a112 5
    "aviion",      "hppa",        "hppa64",      "i386",
    "ia64",        "landisk",     "loongson",    "luna88k",
    "macppc",      "mips64",      "octeon",      "sgi",
    "socppc",      "solbourne",   "sparc",       "sparc64",
    "vax",         "zaurus",
d114 5
a118 4
    "beagle",      "cats",        "hp300",       "mac68k",
    "mvme68k",     "mvme88k",     "mvmeppc",     "palm",
    "pc532",       "pegasos",     "pmax",        "powerpc",
    "sun3",        "wgrisc",      "x68k"
@


1.62
log
@omit list of other results one there is only one match
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.61 2016/04/14 23:48:06 schwarze Exp $ */
d1038 1
a1038 1
	if (*path != '\0' && access(path, F_OK) == -1) {
d1040 2
a1041 1
		path = "";
@


1.61
log
@for .Xr links, use short PATH_INFO style URIs
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.60 2016/04/14 20:38:50 schwarze Exp $ */
a588 2
	puts("<DIV CLASS=\"results\">");
	puts("<TABLE>");
d590 22
a611 14
	for (i = 0; i < sz; i++) {
		printf("<TR>\n"
		       "<TD CLASS=\"title\">\n"
		       "<A HREF=\"/%s%s%s/%s",
		    scriptname, *scriptname == '\0' ? "" : "/",
		    req->q.manpath, r[i].file);
		printf("\">");
		html_print(r[i].names);
		printf("</A>\n"
		       "</TD>\n"
		       "<TD CLASS=\"desc\">");
		html_print(r[i].output);
		puts("</TD>\n"
		     "</TR>");
a613 3
	puts("</TABLE>\n"
	     "</DIV>");

d619 1
a619 1
	if (req->q.equal) {
@


1.60
log
@do not rewrite short URIs
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.59 2016/04/13 12:58:13 schwarze Exp $ */
d817 2
a818 6
	mandoc_asprintf(&conf.man, "/%s?query=%%N&sec=%%S%s%s%s%s",
	    scriptname,
	    req->q.arch	? "&arch="       : "",
	    req->q.arch	? req->q.arch    : "",
	    usepath	? "&manpath="    : "",
	    usepath	? req->q.manpath : "");
@


1.59
log
@Give manuals in purely numerical sections priority over manuals of
the same name in sections with an alphabetical suffix; same logic
as in main.c rev. 1.171.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.58 2016/03/18 13:21:07 schwarze Exp $ */
d56 1
d190 1
d571 1
a571 1
	if (1 == sz) {
d1088 1
@


1.58
log
@Make the SCRIPT_NAME logic simpler, safer, and make it actually work;
in part based on ideas by bentley@@.
While here, improve the documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.57 2016/03/17 22:06:30 schwarze Exp $ */
d555 2
a556 1
	size_t		 i, iuse, isec;
a558 1
	char		 sec;
d617 1
a617 1
		priouse = 10;
d620 3
a622 3
			isec = strcspn(r[i].file, "123456789");
			sec = r[i].file[isec];
			if ('\0' == sec)
d624 4
a627 2
			prio = sec_prios[sec - '1'];
			if (NULL == req->q.arch) {
d629 4
a632 4
				    (NULL == (arch = strchr(
					r[i].file + isec, '/'))) ? 3 :
				    (NULL == (archend = strchr(
					arch + 1, '/'))) ? 0 :
@


1.57
log
@make man(1) mode the default rather than apropos(1) mode
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.56 2016/03/17 21:22:43 schwarze Exp $ */
d85 1
a85 1
static	const char	 *scriptname; /* CGI script name */
d371 1
a371 1
	       "<FORM ACTION=\"%s\" METHOD=\"get\">\n"
d508 1
a508 1
	       "<A HREF=\"%s/mandoc/man8/man.cgi.8\">man.cgi</A>\n"
d510 1
a510 1
	       "<A HREF=\"%s/mandoc/man1/apropos.1\">apropos</A>\n"
d513 2
a514 1
	       scriptname, scriptname);
d538 1
a538 1
	       "<A HREF=\"%s\">main page</A>.\n"
d575 4
a578 2
		printf("Location: http://%s%s/%s/%s",
		    HTTP_HOST, scriptname, req->q.manpath, r[0].file);
d593 3
a595 2
		       "<A HREF=\"%s/%s/%s",
		    scriptname, req->q.manpath, r[i].file);
d813 1
a813 1
	mandoc_asprintf(&conf.man, "%s?query=%%N&sec=%%S%s%s%s%s",
a1006 12
		pg_error_internal();
		return EXIT_FAILURE;
	}

	/* Scan our run-time environment. */

	if (NULL == (scriptname = getenv("SCRIPT_NAME")))
		scriptname = "";

	if ( ! validate_urifrag(scriptname)) {
		fprintf(stderr, "unsafe SCRIPT_NAME \"%s\"\n",
		    scriptname);
@


1.56
log
@support short URIs for man.openbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.55 2015/12/25 20:16:19 bentley Exp $ */
d4 1
a4 1
 * Copyright (c) 2014, 2015 Ingo Schwarze <schwarze@@usta.de>
d1033 1
@


1.55
log
@Don't retain the search query in the resulting manual links.
Clean, simple URLs are best.

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.54 2015/11/07 17:58:52 schwarze Exp $ */
d65 1
d1035 1
a1035 1
	/* Next parse out the query string. */
d1037 9
a1045 1
	if (NULL != (querystring = getenv("QUERY_STRING")))
d1048 2
a1065 6
	path = getenv("PATH_INFO");
	if (NULL == path)
		path = "";
	else if ('/' == *path)
		path++;

d1081 55
@


1.54
log
@Modernization, no functional change intended:
Use the POSIX function getline(3) rather than the slightly
dangerous BSD function fgetln(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.53 2015/11/05 20:55:46 schwarze Exp $ */
a63 3
static	void		 http_print(const char *);
static	void		 http_putchar(char);
static	void		 http_printquery(const struct req *, const char *);
a146 34
static void
http_printquery(const struct req *req, const char *sep)
{

	if (NULL != req->q.query) {
		printf("query=");
		http_print(req->q.query);
	}
	if (0 == req->q.equal)
		printf("%sapropos=1", sep);
	if (NULL != req->q.sec) {
		printf("%ssec=", sep);
		http_print(req->q.sec);
	}
	if (NULL != req->q.arch) {
		printf("%sarch=", sep);
		http_print(req->q.arch);
	}
	if (strcmp(req->q.manpath, req->p[0])) {
		printf("%smanpath=", sep);
		http_print(req->q.manpath);
	}
}

static void
http_print(const char *p)
{

	if (NULL == p)
		return;
	while ('\0' != *p)
		http_putchar(*p++);
}

a266 14
static void
http_putchar(char c)
{

	if (isalnum((unsigned char)c)) {
		putchar((unsigned char)c);
		return;
	} else if (' ' == c) {
		putchar('+');
		return;
	}
	printf("%%%.2x", c);
}

d573 1
a573 1
		printf("Location: http://%s%s/%s/%s?",
a574 1
		http_printquery(req, "&");
d589 1
a589 1
		       "<A HREF=\"%s/%s/%s?",
a590 1
		http_printquery(req, "&amp;");
@


1.53
log
@Use include files "header.html" and "footer.html" rather than a
compiled-in string.  This is not a security risk, we read the file
manpath.conf from the same directory, anyway.  No error handling
is needed; even if the files are absent, that's not an error.

This is more flexible without causing complication of the code or
the user interface.  It helps the upcoming revamp of the online
manual pages on man.NetBSD.org.

Based on an idea by Jean-Yves Migeon <jeanyves dot migeon at free dot fr>,
but implemented in a much simpler way.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.52 2015/11/05 17:47:53 schwarze Exp $ */
d705 3
a707 1
	size_t		 len;
a708 1
	char		*p;
d711 1
a711 1
	if (NULL == (f = fopen(file, "r"))) {
d719 4
a722 1
	while (NULL != (p = fgetln(f, &len))) {
d724 1
a724 1
		for (i = 0; i < (int)len - 1; i++) {
d749 1
a749 1
			} else if (i + 2 >= (int)len)
d825 1
a825 1
		if (i == (int)len - 1 && '\n' != p[i])
d830 1
d1140 1
d1149 6
a1154 3
	while (NULL != (dp = fgetln(fp, &dpsz))) {
		if ('\n' == dp[dpsz - 1])
			dpsz--;
a1156 1
		dp = mandoc_strndup(dp, dpsz);
d1170 2
d1173 1
@


1.52
log
@simplify: use one stylesheet rather than two; from bentley@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.51 2015/10/22 22:05:42 schwarze Exp $ */
d78 1
d370 14
d400 2
d408 2
a418 1
	puts(CUSTOMIZE_BEGIN);
@


1.51
log
@use the new function man_validate() here, too
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.50 2015/10/20 02:00:49 schwarze Exp $ */
d378 1
a378 3
	       "<LINK REL=\"stylesheet\" HREF=\"%s/man-cgi.css\""
	       " TYPE=\"text/css\" media=\"all\">\n"
	       "<LINK REL=\"stylesheet\" HREF=\"%s/man.css\""
d384 1
a384 1
	       CSS_DIR, CSS_DIR, CUSTOMIZE_TITLE);
@


1.50
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.49 2015/10/13 22:57:49 schwarze Exp $ */
d35 1
d862 2
a863 1
	} else
d865 1
@


1.49
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.48 2015/10/06 18:30:43 schwarze Exp $ */
d34 1
d858 2
a859 1
	if (man->macroset == MACROSET_MDOC)
d861 1
a861 1
	else
@


1.48
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.47 2015/04/18 16:34:03 schwarze Exp $ */
a819 1
	struct mchars	*mchars;
d830 2
a831 3
	mchars = mchars_alloc();
	mp = mparse_alloc(MPARSE_SO, MANDOCLEVEL_BADARG, NULL,
	    mchars, req->q.manpath);
d851 1
a851 1
		mchars_free(mchars);
d855 1
a855 1
	vp = html_alloc(mchars, &conf);
d864 1
a864 1
	mchars_free(mchars);
@


1.47
log
@Profit from the unified struct roff_man and reduce the number of
arguments of mparse_result() by one.  No functional change.
Written on the ICE Bruxelles-Koeln on the way back from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.46 2015/04/18 16:04:40 schwarze Exp $ */
d333 1
a333 1
				return(0);
d335 1
a335 1
				return(0);
d337 1
a337 1
				return(0);
d339 1
a339 1
				return(0);
d348 1
a348 1
	return(1);
d500 1
a500 1
			return(0);
d503 1
a503 1
	return(1);
d512 1
a512 1
		return(1);
d516 1
a516 1
			return(1);
d518 1
a518 1
	return(0);
d528 2
a529 2
	return ( ! (strstr(file, "../") || strstr(file, "/..") ||
	    (strncmp(file, "man", 3) && strncmp(file, "cat", 3))));
d1032 1
a1032 1
		return(EXIT_FAILURE);
d1044 1
a1044 1
		return(EXIT_FAILURE);
d1057 1
a1057 1
		return(EXIT_FAILURE);
d1073 1
a1073 1
		return(EXIT_FAILURE);
d1079 1
a1079 1
		return(EXIT_FAILURE);
d1104 1
a1104 1
	return(EXIT_SUCCESS);
@


1.46
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.45 2015/03/27 21:17:16 schwarze Exp $ */
d31 1
d33 1
a33 1
#include "mandoc_aux.h"
a820 1
	struct roff_man	*mdoc;
d847 2
a848 2
	mparse_result(mp, &mdoc, &man, NULL);
	if (NULL == man && NULL == mdoc) {
d859 2
a860 2
	if (NULL != mdoc)
		html_mdoc(vp, mdoc);
@


1.45
log
@Actually use the new man.conf(5) "output" directive.
Additional functionality, yet minus 45 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.44 2015/03/27 17:36:56 schwarze Exp $ */
d820 2
a821 2
	struct mdoc	*mdoc;
	struct man	*man;
@


1.44
log
@Parse the new man.conf(5) "output" directive.
The next step will be to actually use the parsed data.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.43 2015/02/10 08:05:07 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014 Ingo Schwarze <schwarze@@usta.de>
d817 1
a822 1
	char		*opts;
d837 2
d840 1
a840 2
	mandoc_asprintf(&opts,
	    "fragment,man=%s?query=%%N&sec=%%S%s%s%s%s",
d857 1
a857 1
	vp = html_alloc(mchars, opts);
d867 1
a867 1
	free(opts);
@


1.43
log
@trim trailing white space, no code change;
from Svyatoslav Mishyn <juef at openmailboxd dot org>, Crux Linux
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.42 2015/01/15 04:26:06 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d34 1
a34 1
#include "manpath.h"
@


1.42
log
@Fatal errors no longer exist.
If a file can be opened, mandoc will produce some output;
at worst, the output may be almost empty.
Simplifies error handling and frees a message type for future use.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.41 2014/11/26 00:57:32 schwarze Exp $ */
d59 1
a59 1
static	int 		 http_decode(char *);
d62 1
a62 1
static	void 		 http_putchar(char);
d187 1
a187 1
	
d622 1
a622 1
		       "<A HREF=\"%s/%s/%s?", 
d702 1
a702 1
			/* 
d743 1
a743 1
			/* 
d781 1
a781 1
			
d792 1
a792 1
		/* 
d794 1
a794 1
		 * We can get to a newline; don't print that. 
d892 1
a892 1
	} 
d1057 1
a1057 1
	} 
@


1.41
log
@Make the code sipler and more robust by always assigning a value
to q.manpath and dropping the (incomplete) later NULL checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.40 2014/11/11 19:03:10 schwarze Exp $ */
a822 1
	enum mandoclevel rc;
d832 1
a832 1
	mp = mparse_alloc(MPARSE_SO, MANDOCLEVEL_FATAL, NULL,
d834 1
a834 1
	rc = mparse_readfd(mp, fd, file);
a835 7

	if (rc >= MANDOCLEVEL_FATAL) {
		fprintf(stderr, "fatal mandoc error: %s/%s\n",
		    req->q.manpath, file);
		pg_error_internal();
		return;
	}
@


1.40
log
@In man(1) mode without -a, stop searching after the first manual tree
that contained at least one match in order to not prefer mdoc(1) from
ports over mdoc(7).  As a bonus, this results in a speedup.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.39 2014/10/28 17:35:42 schwarze Exp $ */
a17 1

d164 1
a164 2
	if (NULL != req->q.manpath &&
	    strcmp(req->q.manpath, req->p[0])) {
a297 5

	/* Fall back to the default manpath. */

	if (req->q.manpath == NULL)
		req->q.manpath = mandoc_strdup(req->p[0]);
d464 1
a464 2
			if (NULL == req->q.manpath ? 0 == i :
			    0 == strcmp(req->q.manpath, req->p[i]))
d1075 3
a1077 2
	if ( ! (NULL == req.q.manpath ||
	    validate_manpath(&req, req.q.manpath))) {
@


1.39
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.38 2014/10/07 18:20:42 schwarze Exp $ */
d979 1
@


1.38
log
@be a bit more patient, 1s is sometimes insufficient for legitimate queries
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.37 2014/10/07 18:17:05 schwarze Exp $ */
d826 1
d840 1
d842 1
a842 1
	    req->q.manpath);
d868 1
d872 1
a872 1
	vp = html_alloc(opts);
d881 1
@


1.37
log
@Switch HTML output to polyglot HTML5; have only one single -Thml mode.
Replace hard-coded widths and alignments with a minimal embedded stylesheet.
Do not use <p> because it cannot appear inside block macros.
Remove the "summary" attribute because it is not HTML5.

Written by kristaps@@ some months ago, finished during EuroBSDCon.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.36 2014/09/14 19:44:20 schwarze Exp $ */
d1035 1
a1035 1
	itimer.it_value.tv_sec = 1;
d1037 1
a1037 1
	itimer.it_interval.tv_sec = 1;
@


1.36
log
@Support backslash-escaping of white space in the query expression,
to be more similar to apropos(1) called from the shell.
Missing feature reported by Marcus MERIGHI <mcmer dash openbsd at
tor dot at> on misc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.35 2014/08/27 00:06:08 schwarze Exp $ */
d378 1
a378 3
	printf("<!DOCTYPE HTML PUBLIC "
	       " \"-//W3C//DTD HTML 4.01//EN\""
	       " \"http://www.w3.org/TR/html4/strict.dtd\">\n"
d381 1
a381 2
	       "<META HTTP-EQUIV=\"Content-Type\""
	       " CONTENT=\"text/html; charset=utf-8\">\n"
@


1.35
log
@Add an implementation of man(1) into the /usr/bin/mandoc binary and
provide a unified set of command line options for mandoc(1), man(1),
apropos(1), and whatis(1), each option doing the same for all four.
Not adding any completely new options, only extending exiting ones
from one tool to the others.  New options are:
* apropos & whatis -acfkw  (in the past, these were man(1) only)
* apropos & whatis -a -IOTW  (in the past, mandoc(1) only)
* mandoc -ac  (in the past, man(1) only)
* man -IOTW  (in the past, mandoc(1) only)

Before we can decide whether or not we want to replace src/usr.bin/man
with this implementation, considerable bugfixing, testing, and
performance measurements are needed, which i'd rather do in the tree
than outside.  Note that these bugs only affect the new man(1) mode,
existing mandoc(1), apropos(1), and whatis(1) is fine.

The new functionality in mandoc(1), apropos(1), and whatis(1)
is fully enabled.  To play with the new man(1), you can try:
# mv /usr/bin/man /usr/bin/oman
# ln -s /usr/bin/mandoc /usr/bin/man

Positive feedback about the general direction from sthen@@ and jmc@@,
and deraadt@@ is not against it.
@
text
@d1 1
a1 1
/*	$OpenBSD: cgi.c,v 1.34 2014/08/26 11:13:58 schwarze Exp $ */
d956 2
a957 2
	char			**cp;
	const char		 *ep, *start;
d959 1
a959 1
	int			  i, sz;
d984 1
a984 2
	 * Poor man's tokenisation: just break apart by spaces.
	 * Yes, this is half-ass.  But it works for now.
d987 25
a1011 16
	ep = req->q.query;
	while (ep && isspace((unsigned char)*ep))
		ep++;

	sz = 0;
	cp = NULL;
	while (ep && '\0' != *ep) {
		cp = mandoc_reallocarray(cp, sz + 1, sizeof(char *));
		start = ep;
		while ('\0' != *ep && ! isspace((unsigned char)*ep))
			ep++;
		cp[sz] = mandoc_malloc((ep - start) + 1);
		memcpy(cp[sz], start, ep - start);
		cp[sz++][ep - start] = '\0';
		while (isspace((unsigned char)*ep))
			ep++;
d1014 1
a1014 1
	if (0 == mansearch(&search, &paths, sz, cp, &res, &ressz))
d1021 2
a1022 11
	for (i = 0; i < sz; i++)
		free(cp[i]);
	free(cp);

	for (i = 0; i < (int)ressz; i++) {
		free(res[i].file);
		free(res[i].names);
		free(res[i].output);
	}
	free(res);

@


1.34
log
@Unify console and CGI section titles, bringing them closer to groff,
is an attempt to reduce confusion for users switching between media
and between different operating systems.

Not using the groff title for section 4 is intentional,
it is just too awful ("Kernel Interfaces Manual"), and
the difference from sections 2 and 9 would be too hard to see.

Positive feedback from at least deraadt@@ millert@@ bluhm@@ jca@@.
Previously also agreed with the general direction: jmc@@ Nick@@.
The title for 3p was polished by bluhm@@.
The existing mismatches were originally noticed by jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d976 2
a977 2
	search.deftype = req->q.equal ? TYPE_Nm : (TYPE_Nm | TYPE_Nd);
	search.flags = req->q.equal ? MANSEARCH_MAN : 0;
d1006 1
a1006 1
	if (0 == mansearch(&search, &paths, sz, cp, "Nd", &res, &ressz))
@


1.33
log
@limit CGI process execution time to make REDoS attacks less effective;
attack surface pointed out by Sebastien Marie
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.32 2014/08/08 17:17:42 schwarze Exp $ */
d94 3
a96 3
    "3 - Subroutines",
    "3p - Perl Subroutines",
    "4 - Special Files",
d99 3
a101 3
    "7 - Macros and Conventions",
    "8 - Maintenance Commands",
    "9 - Kernel Interface"
@


1.32
log
@mansearch.h uses uint64_t, so it needs stdint.h; found on Linux
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.31 2014/07/25 21:05:38 schwarze Exp $ */
d18 4
d1032 1
d1036 12
@


1.31
log
@Choosing the right encoding is a tricky business...

Printing query strings for URIs *always* needs URI-encoding, and when
embedding the URI into an HTML document, it needs replacement of
the "&" separators by "&amp;" *in addition to that*, not instead.
Delete the function html_primtquery(), it was completely wrong.

You can see the badness by entering "mandoc &sec=2" into the query input
box before this patch and click "Submit".  You come to the right page at
first (...man.cgi?query=mandoc+%26sec%3D2&apropos=0&sec=0&...), but now
the link to mandoc(1) is wrong: ...mandoc.1?query=mandoc &amp;sec=2&amp;...
Clicking on that, the "&sec=2" disappears from the query input box and
suddenly you have the first dropdown set to "2 - System Calls".  Oops.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.30 2014/07/25 20:08:49 schwarze Exp $ */
d22 1
@


1.30
log
@Sort the URI keys for .Xr links in the same order used by the search form,
and leave out the manpath when it is the default.
For building the HTML formatter options, do not use a static buffer.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.29 2014/07/25 19:36:02 schwarze Exp $ */
a53 1
static	void		 html_printquery(const struct req *);
d59 1
a59 1
static	void		 http_printquery(const struct req *);
d143 1
a143 1
http_printquery(const struct req *req)
d151 1
a151 1
		printf("&apropos=1");
d153 1
a153 1
		printf("&sec=");
d157 1
a157 1
		printf("&arch=");
d162 1
a162 1
		printf("&manpath=");
a167 25
html_printquery(const struct req *req)
{

	if (NULL != req->q.query) {
		printf("query=");
		html_print(req->q.query);
	}
	if (0 == req->q.equal)
		printf("&amp;apropos=1");
	if (NULL != req->q.sec) {
		printf("&amp;sec=");
		html_print(req->q.sec);
	}
	if (NULL != req->q.arch) {
		printf("&amp;arch=");
		html_print(req->q.arch);
	}
	if (NULL != req->q.manpath &&
	    strcmp(req->q.manpath, req->p[0])) {
		printf("&amp;manpath=");
		html_print(req->q.manpath);
	}
}

static void
d613 1
a613 1
		http_printquery(req);
d630 1
a630 1
		html_printquery(req);
@


1.29
log
@oops, we must not try to validate a manpath we don't have;
fixing an oversight introduced in rev. 1.17
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.28 2014/07/25 18:19:33 schwarze Exp $ */
a849 1
	int		 fd;
d853 1
d855 2
a856 1
	char		 opts[PATH_MAX + 128];
d875 8
a882 5
	snprintf(opts, sizeof(opts), "fragment,man=%s?"
	    "manpath=%s&query=%%N&sec=%%S%s%s",
	    scriptname, req->q.manpath,
	    req->q.arch ? "&arch=" : "",
	    req->q.arch ? req->q.arch : "");
d902 1
@


1.28
log
@We cannot easily control the order of the QUERY_STRING keys generated
by the search form, it's just the order of the fields in the form.
Actually, that's not too bad; the generated URI resembles the
generating form.

To minimize confusion for people looking at URIs, give the keys
in the same order when generating URIs for search listings and
search redirections, the latter being used instead of search
listings that would have only one single entry.  Also, if the
manpath is the default, remove it form the generated URIs.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.27 2014/07/25 17:51:33 schwarze Exp $ */
d1085 2
a1086 1
	if ( ! validate_manpath(&req, req.q.manpath)) {
@


1.27
log
@In generated .Xr links, avoid double encoding of ampersands
and avoid empty arch= keys.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.26 2014/07/25 17:33:51 schwarze Exp $ */
d147 3
a149 3
	if (NULL != req->q.manpath) {
		printf("&manpath=");
		http_print(req->q.manpath);
d151 2
d161 4
a164 3
	if (NULL != req->q.query) {
		printf("&query=");
		http_print(req->q.query);
a165 2
	if (0 == req->q.equal)
		printf("&apropos=1");
d172 3
a174 3
	if (NULL != req->q.manpath) {
		printf("&amp;manpath=");
		html_print(req->q.manpath);
d176 2
d186 4
a189 3
	if (NULL != req->q.query) {
		printf("&amp;query=");
		html_print(req->q.query);
a190 2
	if (0 == req->q.equal)
		printf("&amp;apropos=1");
@


1.26
log
@Even though this is not XHTML yet, remove some gratuitious violations
of XHTML syntax.  Also add some cosmetic newlines to the HTML code.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.25 2014/07/25 16:55:40 schwarze Exp $ */
d873 1
a873 1
	    "manpath=%s&amp;query=%%N&amp;sec=%%S&amp;arch=%s",
d875 1
@


1.25
log
@The names of all other struct query memebers match the corresponding
QUERY_STRING keys, so rename "expr" to "query".
Also add some missing function prototypes.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.24 2014/07/25 16:43:05 schwarze Exp $ */
d454 1
a454 1
		printf("CHECKED ");
d460 1
a460 1
	printf(	"</TD></TR><TR><TD>\n"
d466 1
a466 1
			printf(" SELECTED");
d476 1
a476 1
		printf(" SELECTED");
d482 1
a482 1
			printf(" SELECTED");
d495 1
a495 1
				printf("SELECTED ");
d510 1
a510 1
		printf("CHECKED ");
d568 4
a571 4
	       "This web interface is documented in the "
	       "<A HREF=\"%s/mandoc/man8/man.cgi.8\">man.cgi</A> "
	       "manual, and the "
	       "<A HREF=\"%s/mandoc/man1/apropos.1\">apropos</A> "
@


1.24
log
@clean up pg_show() to not modify a string returned from getenv(3)
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.23 2014/07/25 16:06:19 schwarze Exp $ */
d41 1
a41 1
	char		*expr; /* unparsed expression string */
d75 4
d159 1
a159 1
	if (NULL != req->q.expr) {
d161 1
a161 1
		http_print(req->q.expr);
d183 1
a183 1
	if (NULL != req->q.expr) {
d185 1
a185 1
		html_print(req->q.expr);
d245 1
a245 1
	req->q.expr	= NULL;
d273 1
a273 1
			set_query_attr(&req->q.expr, &val);
d440 2
a441 2
	if (NULL != req->q.expr)
		html_print(req->q.expr);
d1001 1
a1001 1
	ep = req->q.expr;
d1104 1
a1104 1
	else if (NULL != req.q.expr)
d1112 1
a1112 1
	free(req.q.expr);
@


1.23
log
@Rewrite http_parse() completely:
1. Make sure the last occurrence of each key is used, even if
it is empty, in which case it resets the value to the default.
2. When there is an HTTP encoding error, skip the affected
key-value pair only, but not all subsequent key-value pairs.
3. Do not modify a string returned from getenv(3).
4. Do not assume the NULL pointer is all null bits.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.22 2014/07/24 20:30:38 schwarze Exp $ */
d907 1
a907 1
pg_show(struct req *req, const char *path)
d909 2
a910 1
	char		*sub;
d912 1
a912 1
	if (NULL == path || NULL == (sub = strchr(path, '/'))) {
d917 2
a918 1
	*sub++ = '\0';
d920 1
a920 1
	if ( ! validate_manpath(req, path)) {
d923 1
d933 1
a933 1
	if (-1 == chdir(path)) {
d935 1
a935 1
		    path, strerror(errno));
d937 1
d941 7
a947 1
	if ( ! validate_filename(sub)) {
a952 5
	if (strcmp(path, "mandoc")) {
		free(req->q.manpath);
		req->q.manpath = mandoc_strdup(path);
	}

d955 1
a955 1
	resp_show(req, sub);
@


1.22
log
@Sort result pages first by section number, then by name.
By moving the sort from cgi.c to mansearch.c, we get two advantages:
Easier access to the data needed for sorting, in particular the section
number, and the apropos(1) command line utility profits as well.

Feature requested by deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.21 2014/07/24 08:25:45 schwarze Exp $ */
d38 4
a41 4
	const char	*manpath; /* desired manual directory */
	const char	*arch; /* architecture */
	const char	*sec; /* manual section */
	const char	*expr; /* unparsed expression string */
d57 1
a57 1
static	void		 http_parse(struct req *, char *);
d212 2
a213 3
 * Parse out key-value pairs from an HTTP request variable.
 * This can be either a cookie or a POST/GET string, although man.cgi
 * uses only GET for simplicity.
d216 1
a216 1
http_parse(struct req *req, char *p)
a217 1
	char            *key, *val;
d219 27
a245 3
	memset(&req->q, 0, sizeof(struct query));
	req->q.manpath = req->p[0];
	req->q.equal = 1;
d247 15
a261 3
	while ('\0' != *p) {
		key = p;
		val = NULL;
d263 2
a264 5
		p += (int)strcspn(p, ";&");
		if ('\0' != *p)
			*p++ = '\0';
		if (NULL != (val = strchr(key, '=')))
			*val++ = '\0';
d266 1
a266 2
		if ('\0' == *key || NULL == val || '\0' == *val)
			continue;
d268 2
a269 1
		/* Just abort handling. */
d271 4
a274 8
		if ( ! http_decode(key))
			break;
		if (NULL != val && ! http_decode(val))
			break;

		if (0 == strcmp(key, "query"))
			req->q.expr = val;
		else if (0 == strcmp(key, "manpath")) {
d276 1
a276 1
			if (0 == strncmp(val, "OpenBSD ", 8)) {
d282 4
a285 6
			req->q.manpath = val;
		} else if (0 == strcmp(key, "apropos"))
			req->q.equal = !strcmp(val, "0");
		else if (0 == strcmp(key, "sec")) {
			if (strcmp(val, "0"))
				req->q.sec = val;
d287 1
a287 3
		} else if (0 == strcmp(key, "sektion")) {
			if (strcmp(val, "0"))
				req->q.sec = val;
d289 4
a292 3
		} else if (0 == strcmp(key, "arch")) {
			if (strcmp(val, "default"))
				req->q.arch = val;
d294 20
d315 5
d943 4
a946 2
	if (strcmp(path, "mandoc"))
		req->q.manpath = path;
d1037 1
a1037 1
	char		*querystring;
d1100 4
@


1.21
log
@Provide a dropdown entry "All Architectures" and make it the default.
Still, amd64 remains the default in the following sense:
If a man(1) mode search returns more than one page of the same name,
prefer amd64 over other architectures for immediate display.
ok deraadt@@ daniel@@
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.20 2014/07/22 18:14:05 schwarze Exp $ */
a51 1
static	int	 	 cmp(const void *, const void *);
a590 2
	qsort(r, sz, sizeof(struct manpage), cmp);

a1052 8
}

static int
cmp(const void *p1, const void *p2)
{

	return(strcasecmp(((const struct manpage *)p1)->names,
	    ((const struct manpage *)p2)->names));
@


1.20
log
@Security fix to prevent XSS attacks:
Restrict the character set of strings passed into html_alloc(),
in particular architecture names that come from the QUERY_STRING,
but also SCRIPT_NAME and manpath.conf content for additional safety,
and bail out safely on violations.
Issue reported by Sebastien Marie <semarie-openbsd at latrappe dot fr>.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.19 2014/07/21 22:32:55 schwarze Exp $ */
d421 5
a425 1
	puts("<SELECT NAME=\"arch\">");
d562 1
d564 1
d627 1
d634 17
@


1.19
log
@fix a minibug reported by kristaps@@:
preserve manpath and arch in .Xr links
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.18 2014/07/21 15:44:22 schwarze Exp $ */
d466 14
d973 7
d1007 6
d1064 14
a1077 1
		req->p[req->psz++] = mandoc_strndup(dp, dpsz);
@


1.18
log
@Kristaps points out that the current HTTP/1.1 draft standard (RFC
2616) requires the Location: response-header field to be an absolute
URI (14.30), and only the most recent proposed standard (RFC 7231),
which is barely a month old, allows a relative Location: (7.1.2).
While most modern browsers appear to support relative Location:
headers, some may not, and it's maybe a bit early to rely on relative
Location: headers.

I'm not going back to the HTTP_HOST or SERVER_NAME CGI variables,
though.  While some CGI programs certainly require those, in which
case both the CGI programmer and the web server admin have to be
very careful to keep the system secure and reliable, man.cgi(8)
does not really need them.  We always know at compile time which
domain we are running for, and for man.cgi(8), security and reliability
are definitely much more important than flexibility.  So make HTTP_HOST
a compile-time definition for now.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.17 2014/07/19 13:15:07 schwarze Exp $ */
d70 1
a70 1
static	void		 pg_show(const struct req *, const char *);
d784 4
a787 3
	snprintf(opts, sizeof(opts),
	    "fragment,man=%s?query=%%N&amp;sec=%%S",
	    scriptname);
d823 1
a823 1
pg_show(const struct req *req, const char *path)
d858 3
@


1.17
log
@Security fix:
Validate the manpath up front and report a Bad Request if it is not
listed in manpath.conf, such that clients can't probe which directories
exist on the server.  In case of configuration errors, consistently
report Internal Server Error without disclosing any further information.

Partially based on a patch from Sebastien Marie <semarie-openbsd at
latrappe dot fr>, but avoiding a couple of issues with that patch
and approaching the issue in a somewhat more rigorous way.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.16 2014/07/19 11:35:09 schwarze Exp $ */
d563 2
a564 2
		printf("Location: %s/%s/%s?",
		    scriptname, req->q.manpath, r[0].file);
@


1.16
log
@Security fix:
Validate the name of the file to show before opening it.
Only allow relative filenames starting with "man" or "cat"
and containing neither "/.." nor "../".

While here, correct the condition discarding an initial "./".

Vulnerability found by Sebastien Marie <semarie-openbsd at latrappe dot fr>.
Many thanks for sending a patch; however, i did not use it but made the
checks even stricter.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.15 2014/07/18 19:02:07 schwarze Exp $ */
d466 15
d833 6
d846 3
a848 2
		pg_error_badrequest(
		    "You specified an invalid manpath.");
d882 3
a884 2
		pg_error_badrequest(
		    "You specified an invalid manpath.");
d975 6
@


1.15
log
@Do not use the HTTP_HOST CGI variable,
just make the HTTP redirect Location: relative.
Less user input is good, it reduces the attack surface.
Besides, this removes one global variable and 4 lines of code.

Patch from Sebastien Marie <semarie-openbsd at latrappe dot fr>.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.14 2014/07/18 14:46:20 schwarze Exp $ */
d465 11
d533 9
d796 2
a797 1
	if ('.' == file[0] || '/' == file[1])
d827 6
@


1.14
log
@When the MAN_DIR/manpath.conf configuration file does not exist or is empty,
log the problem, hand the pg_error_internal() error page to the client,
and exit(3) in a controlled way instead of stumbling on and segfaulting
later.

Patch from Sebastien Marie <semarie-openbsd at latrappe dot fr>,
messages tweaked by me.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.13 2014/07/13 15:38:06 schwarze Exp $ */
a77 1
static	const char	 *httphost; /* hostname used in the URIs */
d528 2
a529 2
		printf("Location: http://%s%s/%s/%s?",
		    httphost, scriptname, req->q.manpath, r[0].file);
a903 3

	if (NULL == (httphost = getenv("HTTP_HOST")))
		httphost = "localhost";
@


1.13
log
@Compatibility hack for the old "manpath=OpenBSD<blank>" query parameter format;
unfortunate, more than 400 links needing this are scattered all around
the www.openbsd.org website, and CVSweb needs this as well.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.12 2014/07/13 12:55:24 schwarze Exp $ */
d969 6
a974 2
	if (NULL == (fp = fopen("manpath.conf", "r")))
		return;
d982 6
@


1.12
log
@Make the calltree a bit easier to understand by giving the
functions that call resp_begin_html() names starting with "pg_"
and those called after resp_begin_html() names with "resp_".
No functional change, purely renaming functions.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.11 2014/07/13 12:44:57 schwarze Exp $ */
d249 8
a256 1
		else if (0 == strcmp(key, "manpath"))
d258 1
a258 1
		else if (0 == strcmp(key, "apropos"))
d260 1
a260 2
		else if (0 == strcmp(key, "sec") ||
			 0 == strcmp(key, "sektion")) {
d263 5
@


1.11
log
@make source vs. formatted guessing a bit more robust
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.10 2014/07/13 12:31:00 schwarze Exp $ */
d63 4
d68 2
a73 7
static	void		 resp_error_badrequest(const char *);
static	void		 resp_error_internal(void);
static	void		 resp_index(const struct req *);
static	void		 resp_noresult(const struct req *,
				const char *);
static	void		 resp_search(const struct req *,
				struct manpage *, size_t);
d456 1
a456 1
resp_index(const struct req *req)
d473 1
a473 1
resp_noresult(const struct req *req, const char *msg)
d484 1
a484 1
resp_error_badrequest(const char *msg)
d498 1
a498 1
resp_error_internal(void)
d506 1
a506 1
resp_search(const struct req *req, struct manpage *r, size_t sz)
d735 1
a735 1
		resp_error_internal();
d747 1
a747 1
		resp_error_internal();
d781 1
a781 1
		resp_error_badrequest(
d794 1
a794 1
		resp_error_badrequest(
d823 1
a823 1
		resp_error_badrequest(
d861 1
a861 1
		resp_noresult(req, "You entered an invalid query.");
d863 1
a863 1
		resp_noresult(req, "No results found.");
d865 1
a865 1
		resp_search(req, res, ressz);
d907 1
a907 1
		resp_error_internal();
d932 1
a932 1
		resp_index(&req);
@


1.10
log
@By popular demand, bring man.cgi default mode closer to what man(1) does:
Even when there are multiple pages with the same name in different
sections, show one of them, using the same priorities as in the
default man.conf(5) file.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.9 2014/07/13 09:58:52 schwarze Exp $ */
d767 2
@


1.9
log
@Install the manuals of the web interface below the same directory
as manpath.conf, such that we do not need to mix our own documentation
into the documentation we are serving, which may not even be possible
if the latter is updated automatically.

Based on an idea by beck@@.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.8 2014/07/12 23:40:44 schwarze Exp $ */
d76 1
d81 1
d509 3
a511 1
	size_t		 i;
d553 24
d590 1
a590 2
		resp_error_badrequest(
		    "You specified an invalid manual file.");
a593 2
	resp_begin_html(200, NULL);
	resp_searchform(req);
d707 1
a707 3
	     "</DIV>\n"
	     "</BODY>\n"
	     "</HTML>");
d724 1
a724 2
		resp_error_badrequest(
		    "You specified an invalid manual file.");
a752 3
	resp_begin_html(200, NULL);
	resp_searchform(req);

a759 3
	puts("</BODY>\n"
	     "</HTML>");

d765 10
d798 4
a801 4
	if ('c' == *sub)
		catman(req, sub);
	else
		format(req, sub);
@


1.8
log
@Polish the search form using feedback from beck@@ and others,
in particular introduce a section dropdown and an architecture dropdown.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.7 2014/07/12 18:05:50 schwarze Exp $ */
d462 4
a465 4
	       "<A HREF=\"%s?query=man.cgi&amp;sec=8\">"
	       "man.cgi</A> manual, and the "
	       "<A HREF=\"%s?query=apropos&amp;sec=1\">"
	       "apropos</A> manual explains the query syntax.\n"
@


1.7
log
@No need for run-time configuration, add minimal compile-time
configuration facilities, just two paths and two HTML strings.
Show the title on all pages, not just the index page.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.6 2014/07/12 17:18:13 schwarze Exp $ */
d80 33
d370 1
a370 3
	       "<LEGEND>Search Parameters</LEGEND>\n"
	       "<INPUT TYPE=\"submit\" VALUE=\"Search\"> "
	       "for manuals \n",
d372 18
a389 2
	printf("<SELECT NAME=\"apropos\">\n"
	       "<OPTION VALUE=\"0\"");
d391 31
a421 18
		printf(" SELECTED=\"selected\"");
	printf(">named</OPTION>\n"
	       "<OPTION VALUE=\"1\"");
	if (0 == req->q.equal)
		printf(" SELECTED=\"selected\"");
	printf(">matching</OPTION>\n"
	       "</SELECT>\n"
	       "<INPUT TYPE=\"text\" NAME=\"query\" VALUE=\"");
	html_print(req->q.expr ? req->q.expr : "");
	printf("\">, section "
	       "<INPUT TYPE=\"text\""
	       " SIZE=\"4\" NAME=\"sec\" VALUE=\"");
	html_print(req->q.sec ? req->q.sec : "");
	printf("\">, arch "
	       "<INPUT TYPE=\"text\""
	       " SIZE=\"8\" NAME=\"arch\" VALUE=\"");
	html_print(req->q.arch ? req->q.arch : "");
	printf("\">");
d423 1
a423 1
		puts(", in <SELECT NAME=\"manpath\">");
d428 1
a428 1
				printf("SELECTED=\"selected\" ");
d437 11
a447 2
	puts("&mdash;\n"
	     "<INPUT TYPE=\"reset\" VALUE=\"Reset\">\n"
@


1.6
log
@Simplify: Delete 74 lines of code including one enum type, one
global lookup table, two functions, two function arguments, one
struct member, one local variable, and the "search/" and "show/"
part of the URIs, all without losing functionality.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.5 2014/07/12 16:13:36 schwarze Exp $ */
d32 1
a77 2
static	const char	 *mandir; /* contains all manpath directories */
static	const char	 *cssdir; /* css directory */
d312 1
a312 1
	       "<TITLE>System Manpage Reference</TITLE>\n"
d316 1
a316 1
	       cssdir, cssdir);
d332 1
a389 4
	puts("<H1>\n"
	     "Online manuals with "
	     "<A HREF=\"http://mdocml.bsd.lv/\">mandoc</A>\n"
	     "</H1>");
a795 3
	if (NULL == (mandir = getenv("MAN_DIR")))
		mandir = "/man";

a798 3
	if (NULL == (cssdir = getenv("CSS_DIR")))
		cssdir = "";

d803 1
a803 1
	 * First we change directory into the mandir so that
d808 1
a808 1
	if (-1 == chdir(mandir)) {
d810 1
a810 1
		    mandir, strerror(errno));
@


1.5
log
@Start fixing issues that beck@@ helped find:

Distinguish between man(1) and apropos(1) mode by adding back the classical
QUERY_STRING variable "apropos=".  Change the default back to "apropos=0".
Control it by adding a HTML <SELECT> element for it.

Rename the "expr=" QUERY_STRING variable back to its classical name "query=",
i don't see how the new name is better than the classical one.

While here, drop the concept of a "legacy mode".  Simply continue to
support the features, and use what we consider best.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.4 2014/07/12 01:52:57 schwarze Exp $ */
a32 7
enum	page {
	PAGE_INDEX,
	PAGE_SEARCH,
	PAGE_SHOW,
	PAGE__MAX
};

a47 1
	enum page	  page;
d62 2
a63 3
static	void		 pg_index(const struct req *, char *);
static	void		 pg_search(const struct req *, char *);
static	void		 pg_show(const struct req *, char *);
a68 1
static	void		 resp_error_notfound(const char *);
a80 6
static	const char * const pages[PAGE__MAX] = {
	"index", /* PAGE_INDEX */ 
	"search", /* PAGE_SEARCH */
	"show", /* PAGE_SHOW */
};

d335 1
a335 1
	       "<FORM ACTION=\"%s/search\" METHOD=\"get\">\n"
d397 1
a397 1
	       "<A HREF=\"%s/search?expr=Nm~^man\\.cgi$&amp;sec=8\">"
d399 1
a399 1
	       "<A HREF=\"%s/search?expr=Nm~^apropos$&amp;sec=1\">"
a431 18
resp_error_notfound(const char *page)
{

	resp_begin_html(404, "Not Found");
	puts("<H1>Page Not Found</H1>\n"
	     "<P>\n"
	     "The page you're looking for, ");
	printf("<B>");
	html_print(page);
	printf("</B>,\n"
	       "could not be found.\n"
	       "Try searching from the\n"
	       "<A HREF=\"%s\">main page</A>.\n"
	       "</P>", scriptname);
	resp_end_html();
}

static void
d450 1
a450 1
		printf("Location: http://%s%s/show/%s/%s?",
d469 1
a469 1
		       "<A HREF=\"%s/show/%s/%s?", 
a486 8
/* ARGSUSED */
static void
pg_index(const struct req *req, char *path)
{

	resp_index(req);
}

d654 1
a654 1
	    "fragment,man=%s/search?sec=%%S&expr=Nm~^%%N$",
d684 1
a684 1
pg_show(const struct req *req, char *path)
d714 1
a714 1
pg_search(const struct req *req, char *path)
d793 3
a796 2
	struct req	 req;
	char		*querystring, *path, *subpath;
d833 1
a833 6
	/*
	 * Now juggle paths to extract information.
	 * We want to extract our filetype (the file suffix), the
	 * initial path component, then the trailing component(s).
	 * Start with leading subpath component. 
	 */
d835 12
a846 39
	subpath = path = NULL;
	req.page = PAGE__MAX;

	if (NULL == (path = getenv("PATH_INFO")) || '\0' == *path)
		req.page = PAGE_INDEX;

	if (NULL != path && '/' == *path && '\0' == *++path)
		req.page = PAGE_INDEX;

	/* Resolve subpath component. */

	if (NULL != path && NULL != (subpath = strchr(path, '/')))
		*subpath++ = '\0';

	/* Map path into one we recognise. */

	if (NULL != path && '\0' != *path)
		for (i = 0; i < (int)PAGE__MAX; i++) 
			if (0 == strcmp(pages[i], path)) {
				req.page = (enum page)i;
				break;
			}

	/* Route pages. */

	switch (req.page) {
	case (PAGE_INDEX):
		pg_index(&req, subpath);
		break;
	case (PAGE_SEARCH):
		pg_search(&req, subpath);
		break;
	case (PAGE_SHOW):
		pg_show(&req, subpath);
		break;
	default:
		resp_error_notfound(path);
		break;
	}
@


1.4
log
@fix the two links on the start page
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.3 2014/07/11 22:16:11 tedu Exp $ */
d48 1
a48 1
	int		 legacy; /* whether legacy mode */
d141 2
a142 2
		printf("&expr=");
		http_print(req->q.expr ? req->q.expr : "");
d144 2
d165 1
a165 1
		printf("&amp;expr=");
d168 2
a204 1
	int		 legacy;
d208 1
a209 1
	legacy = -1;
d230 1
a230 1
		if (0 == strcmp(key, "expr"))
a231 8
		else if (0 == strcmp(key, "query"))
			req->q.expr = val;
		else if (0 == strcmp(key, "sec"))
			req->q.sec = val;
		else if (0 == strcmp(key, "sektion"))
			req->q.sec = val;
		else if (0 == strcmp(key, "arch"))
			req->q.arch = val;
d235 9
a243 1
			legacy = 0 == strcmp(val, "0");
a244 16

	/* Test for old man.cgi compatibility mode. */

	req->q.legacy = legacy > 0;

	/* 
	 * Section "0" means no section when in legacy mode.
	 * For some man.cgi scripts, "default" arch is none.
	 */

	if (req->q.legacy && NULL != req->q.sec)
		if (0 == strcmp(req->q.sec, "0"))
			req->q.sec = NULL;
	if (req->q.legacy && NULL != req->q.arch)
		if (0 == strcmp(req->q.arch, "default"))
			req->q.arch = NULL;
d354 2
a355 3
	       "<INPUT TYPE=\"submit\" "
	       " VALUE=\"Search\"> for manuals matching \n"
	       "<INPUT TYPE=\"text\" NAME=\"expr\" VALUE=\"",
d357 11
d780 2
a781 2
	search.deftype = TYPE_Nm | TYPE_Nd;
	search.flags = 0;
@


1.3
log
@make http decode linear time.  also remove a redundant null check.
ok schwarze
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.2 2014/07/11 22:14:39 tedu Exp $ */
d414 8
a421 7
	puts("<P>\n"
	     "This web interface is documented in the "
	     "<A HREF=\"search?expr=Nm~^man\\.cgi$&amp;sec=8\">"
	     "man.cgi</A> manual, and the "
	     "<A HREF=\"search?expr=Nm~^apropos$&amp;sec=1\">"
	     "apropos</A> manual explains the query syntax.\n"
	     "</P>");
@


1.2
log
@http headers must end lines with CRLF. ok schwarze
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.1 2014/07/11 15:37:22 schwarze Exp $ */
d164 1
a164 1
		html_print(req->q.expr ? req->q.expr : "");
d283 1
d288 2
a289 1
	for ( ; '\0' != *p; p++) {
d300 2
a301 2
			*p = (char)c;
			memmove(p + 1, p + 3, strlen(p + 3) + 1);
d303 1
a303 1
			*p = '+' == *p ? ' ' : *p;
d306 1
a306 1
	*p = '\0';
@


1.1
log
@Bring in man.cgi(8) to maintain it in our tree together with mandoc.
It will not be enabled in the build nor installed by default.

A comment in the Makefile lists the three simple steps
needed to build, install, and run it on the two machines
worldwide that are going to run it.

deraadt@@ agrees with having the code in the tree.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.61 2014/07/10 00:52:50 schwarze Exp $ */
d313 1
a313 1
		printf("Status: %d %s\n", code, msg);
d315 4
a318 4
	puts("Content-Type: text/html; charset=utf-8\n"
	     "Cache-Control: no-cache\n"
	     "Pragma: no-cache\n"
	     "");
d483 1
a483 1
		puts("Status: 303 See Other");
d487 3
a489 2
		puts("\n"
		     "Content-Type: text/html; charset=utf-8\n");
@

