head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.6
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.14
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.10
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.8
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	191tWtskbsgcpQqV;

1.12
date	2015.01.28.17.30.37;	author schwarze;	state Exp;
branches;
next	1.11;
commitid	B9i4oMLogJsiyrd5;

1.11
date	2015.01.28.15.02.25;	author schwarze;	state Exp;
branches;
next	1.10;
commitid	Um2gz4HrZv1IOy6F;

1.10
date	2015.01.26.13.02.53;	author schwarze;	state Exp;
branches;
next	1.9;
commitid	TckXsclN2hfFrBFF;

1.9
date	2015.01.26.00.54.09;	author schwarze;	state Exp;
branches;
next	1.8;
commitid	vhh5zuNKcPCGcJgK;

1.8
date	2015.01.14.22.44.51;	author schwarze;	state Exp;
branches;
next	1.7;
commitid	7qvZiyLLUmJiYfWk;

1.7
date	2014.11.28.19.25.03;	author schwarze;	state Exp;
branches;
next	1.6;
commitid	1m1y3OocNVYDnyZE;

1.6
date	2014.11.25.06.39.20;	author bentley;	state Exp;
branches;
next	1.5;
commitid	CNNKMNAx6VpnMTwU;

1.5
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2011.01.09.14.30.48;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.13
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@/*	$OpenBSD: tbl_opts.c,v 1.12 2015/01/28 17:30:37 schwarze Exp $ */
/*
 * Copyright (c) 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc.h"
#include "libmandoc.h"
#include "libroff.h"

#define	KEY_DPOINT	0
#define	KEY_DELIM	1
#define	KEY_LINESIZE	2
#define	KEY_TAB		3

struct	tbl_phrase {
	const char	*name;
	int		 key;
};

static	const struct tbl_phrase keys[] = {
	{"decimalpoint", 0},
	{"delim",	 0},
	{"linesize",	 0},
	{"tab",		 0},
	{"allbox",	 TBL_OPT_ALLBOX | TBL_OPT_BOX},
	{"box",		 TBL_OPT_BOX},
	{"frame",	 TBL_OPT_BOX},
	{"center",	 TBL_OPT_CENTRE},
	{"centre",	 TBL_OPT_CENTRE},
	{"doublebox",	 TBL_OPT_DBOX},
	{"doubleframe",  TBL_OPT_DBOX},
	{"expand",	 TBL_OPT_EXPAND},
	{"nokeep",	 TBL_OPT_NOKEEP},
	{"nospaces",	 TBL_OPT_NOSPACE},
	{"nowarn",	 TBL_OPT_NOWARN},
};

#define KEY_MAXKEYS ((int)(sizeof(keys)/sizeof(keys[0])))

static	void	 arg(struct tbl_node *, int, const char *, int *, int);


static void
arg(struct tbl_node *tbl, int ln, const char *p, int *pos, int key)
{
	int		 len, want;

	while (p[*pos] == ' ' || p[*pos] == '\t')
		(*pos)++;

	/* Arguments are enclosed in parentheses. */

	len = 0;
	if (p[*pos] == '(') {
		(*pos)++;
		while (p[*pos + len] != ')')
			len++;
	}

	switch (key) {
	case KEY_DELIM:
		mandoc_vmsg(MANDOCERR_TBLOPT_EQN, tbl->parse,
		    ln, *pos, "%.*s", len, p + *pos);
		want = 2;
		break;
	case KEY_TAB:
		want = 1;
		if (len == want)
			tbl->opts.tab = p[*pos];
		break;
	case KEY_LINESIZE:
		want = 0;
		break;
	case KEY_DPOINT:
		want = 1;
		if (len == want)
			tbl->opts.decimal = p[*pos];
		break;
	default:
		abort();
	}

	if (len == 0)
		mandoc_msg(MANDOCERR_TBLOPT_NOARG,
		    tbl->parse, ln, *pos, keys[key].name);
	else if (want && len != want)
		mandoc_vmsg(MANDOCERR_TBLOPT_ARGSZ,
		    tbl->parse, ln, *pos, "%s want %d have %d",
		    keys[key].name, want, len);

	*pos += len;
	if (p[*pos] == ')')
		(*pos)++;
}

/*
 * Parse one line of options up to the semicolon.
 * Each option can be preceded by blanks and/or commas,
 * and some options are followed by arguments.
 */
void
tbl_option(struct tbl_node *tbl, int ln, const char *p, int *offs)
{
	int		 i, pos, len;

	pos = *offs;
	for (;;) {
		while (p[pos] == ' ' || p[pos] == '\t' || p[pos] == ',')
			pos++;

		if (p[pos] == ';') {
			*offs = pos + 1;
			return;
		}

		/* Parse one option name. */

		len = 0;
		while (isalpha((unsigned char)p[pos + len]))
			len++;

		if (len == 0) {
			mandoc_vmsg(MANDOCERR_TBLOPT_ALPHA,
			    tbl->parse, ln, pos, "%c", p[pos]);
			pos++;
			continue;
		}

		/* Look up the option name. */

		i = 0;
		while (i < KEY_MAXKEYS &&
		    (strncasecmp(p + pos, keys[i].name, len) ||
		     keys[i].name[len] != '\0'))
			i++;

		if (i == KEY_MAXKEYS) {
			mandoc_vmsg(MANDOCERR_TBLOPT_BAD, tbl->parse,
			    ln, pos, "%.*s", len, p + pos);
			pos += len;
			continue;
		}

		/* Handle the option. */

		pos += len;
		if (keys[i].key)
			tbl->opts.opts |= keys[i].key;
		else
			arg(tbl, ln, p, &pos, i);
	}
}
@


1.12
log
@* Polish tbl(7) error reporting.
* Do not print out macro names in tbl(7) data blocks.
* Like with GNU tbl, let empty tables cause a blank line.
* Avoid producing empty tables in -Tman.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_opts.c,v 1.11 2015/01/28 15:02:25 schwarze Exp $ */
a99 1
		/* NOTREACHED */
@


1.11
log
@For now, it can't be helped that mandoc tbl(7) ignores high-level macros,
but stop throwing away their arguments.  This fixes information loss in a
handful of Xenocara manuals, at the price of a small amount of formatting
noise creeping through.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_opts.c,v 1.10 2015/01/26 13:02:53 schwarze Exp $ */
d81 2
a82 1
		mandoc_msg(MANDOCERR_TBLEQN, tbl->parse, ln, *pos, NULL);
@


1.10
log
@More improvements regarding tbl(7) options.
* Treat "allbox" as an alias for "box" for now.
* Parse and ignore the GNU tbl "nowarn" option.
* For separation, allow spaces, tabs, and commas only.
* Mark eqn(7) within tbl(7) as unsupported.
* Simplify the option table.
* Improve and sort documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_opts.c,v 1.9 2015/01/26 00:54:09 schwarze Exp $ */
d121 1
a121 1
tbl_option(struct tbl_node *tbl, int ln, const char *p)
d125 1
a125 1
	pos = 0;
d130 2
a131 1
		if (p[pos] == ';')
d133 1
@


1.9
log
@Improve (or rather, rewrite) tbl(7) option parsing.
* Allow the layout to start after the semicolon on the options line.
* Ignore leading commas.
* Option arguments cannot contain closing parentheses.
* Avoid needless UNSUPP messages.
* Better ERROR reporting.
* Delete unused "linesize" field in struct tbl_opts.
* No need for static buffers.
* Garbage collect one almost empty wrapper function.
Improved functionality, but minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_opts.c,v 1.8 2015/01/14 22:44:51 schwarze Exp $ */
d29 4
a32 16
enum	tbl_ident {
	KEY_CENTRE = 0,
	KEY_DELIM,
	KEY_EXPAND,
	KEY_BOX,
	KEY_DBOX,
	KEY_ALLBOX,
	KEY_TAB,
	KEY_LINESIZE,
	KEY_NOKEEP,
	KEY_DPOINT,
	KEY_NOSPACE,
	KEY_FRAME,
	KEY_DFRAME,
	KEY_MAX
};
a36 1
	enum tbl_ident	 ident;
d39 17
a55 2
/* Handle Commonwealth/American spellings. */
#define	KEY_MAXKEYS	 14
d57 1
a57 16
static	const struct tbl_phrase keys[KEY_MAXKEYS] = {
	{ "center",	 TBL_OPT_CENTRE,	KEY_CENTRE},
	{ "centre",	 TBL_OPT_CENTRE,	KEY_CENTRE},
	{ "delim",	 0,			KEY_DELIM},
	{ "expand",	 TBL_OPT_EXPAND,	KEY_EXPAND},
	{ "box",	 TBL_OPT_BOX,		KEY_BOX},
	{ "doublebox",	 TBL_OPT_DBOX,		KEY_DBOX},
	{ "allbox",	 TBL_OPT_ALLBOX,	KEY_ALLBOX},
	{ "frame",	 TBL_OPT_BOX,		KEY_FRAME},
	{ "doubleframe", TBL_OPT_DBOX,		KEY_DFRAME},
	{ "tab",	 0,			KEY_TAB},
	{ "linesize",	 0,			KEY_LINESIZE},
	{ "nokeep",	 TBL_OPT_NOKEEP,	KEY_NOKEEP},
	{ "decimalpoint", 0,			KEY_DPOINT},
	{ "nospaces",	 TBL_OPT_NOSPACE,	KEY_NOSPACE},
};
d59 1
a59 2
static	void		 arg(struct tbl_node *, int,
				const char *, int *, enum tbl_ident);
d63 1
a63 1
arg(struct tbl_node *tbl, int ln, const char *p, int *pos, enum tbl_ident key)
a64 1
	const char	*optname;
d67 1
a67 1
	while (isspace((unsigned char)p[*pos]))
d81 1
a81 1
		optname = "delim";
a84 1
		optname = "tab";
a89 1
		optname = "linesize";
a92 1
		optname = "decimalpoint";
d104 1
a104 1
		    tbl->parse, ln, *pos, optname);
d107 2
a108 2
		    tbl->parse, ln, *pos,
		    "%s want %d have %d", optname, want, len);
d127 1
a127 1
		while (isspace((unsigned char)p[pos]) || p[pos] == ',')
d167 1
a167 1
			arg(tbl, ln, p, &pos, keys[i].ident);
@


1.8
log
@simplify by getting rid of ROFF_ERR in tbl(7) parsing; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_opts.c,v 1.7 2014/11/28 19:25:03 schwarze Exp $ */
d4 1
a54 6
/* Maximum length of key name string. */
#define	KEY_MAXNAME	 13

/* Maximum length of key number size. */
#define	KEY_MAXNUMSZ	 10

d72 1
a72 1
static	int		 arg(struct tbl_node *, int,
a73 2
static	void		 opt(struct tbl_node *, int,
				const char *, int *);
d76 1
a76 1
static int
d79 2
a80 2
	int		 i;
	char		 buf[KEY_MAXNUMSZ];
d85 1
a85 1
	/* Arguments always begin with a parenthesis. */
d87 5
a91 4
	if ('(' != p[*pos]) {
		mandoc_msg(MANDOCERR_TBL, tbl->parse,
		    ln, *pos, NULL);
		return(0);
a93 8
	(*pos)++;

	/*
	 * The arguments can be ANY value, so we can't just stop at the
	 * next close parenthesis (the argument can be a closed
	 * parenthesis itself).
	 */

d96 2
a97 11
		if ('\0' == p[(*pos)++]) {
			mandoc_msg(MANDOCERR_TBL, tbl->parse,
			    ln, *pos - 1, NULL);
			return(0);
		}

		if ('\0' == p[(*pos)++]) {
			mandoc_msg(MANDOCERR_TBL, tbl->parse,
			    ln, *pos - 1, NULL);
			return(0);
		}
d100 5
a104 6
		if ('\0' != (tbl->opts.tab = p[(*pos)++]))
			break;

		mandoc_msg(MANDOCERR_TBL, tbl->parse,
		    ln, *pos - 1, NULL);
		return(0);
d106 3
a108 14
		for (i = 0; i < KEY_MAXNUMSZ && p[*pos]; i++, (*pos)++) {
			buf[i] = p[*pos];
			if ( ! isdigit((unsigned char)buf[i]))
				break;
		}

		if (i < KEY_MAXNUMSZ) {
			buf[i] = '\0';
			tbl->opts.linesize = atoi(buf);
			break;
		}

		mandoc_msg(MANDOCERR_TBL, tbl->parse, ln, *pos, NULL);
		return(0);
d110 5
a114 6
		if ('\0' != (tbl->opts.decimal = p[(*pos)++]))
			break;

		mandoc_msg(MANDOCERR_TBL, tbl->parse,
		    ln, *pos - 1, NULL);
		return(0);
d120 7
a126 1
	/* End with a close parenthesis. */
d128 3
a130 5
	if (')' == p[(*pos)++])
		return(1);

	mandoc_msg(MANDOCERR_TBL, tbl->parse, ln, *pos - 1, NULL);
	return(0);
d133 7
a139 2
static void
opt(struct tbl_node *tbl, int ln, const char *p, int *pos)
d141 1
a141 2
	int		 i, sv;
	char		 buf[KEY_MAXNAME];
d143 4
a146 17
	/*
	 * Parse individual options from the stream as surrounded by
	 * this goto.  Each pass through the routine parses out a single
	 * option and registers it.  Option arguments are processed in
	 * the arg() function.
	 */

again:	/*
	 * EBNF describing this section:
	 *
	 * options	::= option_list [:space:]* [;][\n]
	 * option_list	::= option option_tail
	 * option_tail	::= [,:space:]+ option_list |
	 *		::= epsilon
	 * option	::= [:alpha:]+ args
	 * args		::= [:space:]* [(] [:alpha:]+ [)]
	 */
d148 2
a149 2
	while (isspace((unsigned char)p[*pos]))
		(*pos)++;
d151 1
a151 1
	/* Safe exit point. */
d153 10
a162 12
	if (';' == p[*pos])
		return;

	/* Copy up to first non-alpha character. */

	for (sv = *pos, i = 0; i < KEY_MAXNAME; i++, (*pos)++) {
		buf[i] = (char)tolower((unsigned char)p[*pos]);
		if ( ! isalpha((unsigned char)buf[i]))
			break;
	}

	/* Exit if buffer is empty (or overrun). */
d164 1
a164 9
	if (KEY_MAXNAME == i || 0 == i) {
		mandoc_msg(MANDOCERR_TBL, tbl->parse, ln, *pos, NULL);
		return;
	}

	buf[i] = '\0';

	while (isspace((unsigned char)p[*pos]) || p[*pos] == ',')
		(*pos)++;
d166 10
a175 7
	/*
	 * Look through all of the available keys to find one that
	 * matches the input.  FIXME: hashtable this.
	 */

	for (i = 0; i < KEY_MAXKEYS; i++) {
		if (strcmp(buf, keys[i].name))
d177 1
d179 1
a179 6
		/*
		 * Note: this is more difficult to recover from, as we
		 * can be anywhere in the option sequence and it's
		 * harder to jump to the next.  Meanwhile, just bail out
		 * of the sequence altogether.
		 */
d181 1
d184 2
a185 4
		else if ( ! arg(tbl, ln, p, pos, keys[i].ident))
			return;

		break;
a186 26

	/*
	 * Allow us to recover from bad options by continuing to another
	 * parse sequence.
	 */

	if (KEY_MAXKEYS == i)
		mandoc_msg(MANDOCERR_TBLOPT, tbl->parse, ln, sv, NULL);

	goto again;
	/* NOTREACHED */
}

void
tbl_option(struct tbl_node *tbl, int ln, const char *p)
{
	int		 pos;

	/*
	 * Table options are always on just one line, so automatically
	 * switch into the next input mode here.
	 */
	tbl->part = TBL_PART_LAYOUT;

	pos = 0;
	opt(tbl, ln, p, &pos);
@


1.7
log
@Add some missing OpenBSD RCS markers
and a few missing <sys/types.h> inclusions; no code change.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d253 1
a253 1
int
a265 3

	/* Always succeed. */
	return(1);
@


1.6
log
@Allow comma-separated options in tbl(7) tables.

Provides better groff compatibility.

ok schwarze@@
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.5 2014/04/20 16:44:44 schwarze Exp $ */
d17 2
@


1.5
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.4 2011/04/24 16:22:02 schwarze Exp $ */
d181 1
a181 1
	 * option_tail	::= [:space:]+ option_list |
d212 1
a212 1
	while (isspace((unsigned char)p[*pos]))
@


1.4
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.3 2011/04/21 22:59:54 schwarze Exp $ */
d61 1
a61 1
	{ "delim",	 0,	       		KEY_DELIM},
d63 2
a64 2
	{ "box",	 TBL_OPT_BOX,   	KEY_BOX},
	{ "doublebox",	 TBL_OPT_DBOX,  	KEY_DBOX},
d75 1
a75 1
static	int		 arg(struct tbl_node *, int, 
d77 1
a77 1
static	void		 opt(struct tbl_node *, int, 
d80 1
d93 2
a94 2
		mandoc_msg(MANDOCERR_TBL, tbl->parse, 
				ln, *pos, NULL);
d107 1
a107 1
	case (KEY_DELIM):
d110 1
a110 1
					ln, *pos - 1, NULL);
d112 1
a112 1
		} 
d116 1
a116 1
					ln, *pos - 1, NULL);
d118 1
a118 1
		} 
d120 1
a120 1
	case (KEY_TAB):
d125 1
a125 1
				ln, *pos - 1, NULL);
d127 1
a127 1
	case (KEY_LINESIZE):
d142 1
a142 1
	case (KEY_DPOINT):
d146 2
a147 2
		mandoc_msg(MANDOCERR_TBL, tbl->parse, 
				ln, *pos - 1, NULL);
d182 1
a182 1
	 * 		::= epsilon
d215 1
a215 1
	/* 
d231 1
a231 1
		if (keys[i].key) 
d239 1
a239 1
	/* 
@


1.3
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.2 2011/01/09 14:30:48 schwarze Exp $ */
d23 1
d92 2
a93 1
		TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos);
d108 2
a109 1
			TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos - 1);
d114 2
a115 1
			TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos - 1);
d123 2
a124 1
		TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos - 1);
d139 1
a139 1
		(*tbl->msg)(MANDOCERR_TBL, tbl->data, ln, *pos, NULL);
d145 2
a146 1
		TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos - 1);
d158 1
a158 1
	TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos - 1);
d205 1
a205 1
		TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos);
d244 1
a244 1
		TBL_MSG(tbl, MANDOCERR_TBLOPT, ln, sv);
@


1.2
log
@Sync tbl handling to bsd.lv release 1.10.9:
* .T} can be followed by a delimiter, then more data.
* Do not limit table column widths (improves terminfo(5)).
* Let numerical cells respect explicitly specified minimum cell widths.
* Let terminal output survive missing data cells.
* Parse and ignore arguments in parentheses on layout cell specifications.
* Move tbl_calc() into out.c such that it can be used by all frontends.
* Give tables an HTML class.
* Some cleanup in tbl -Thtml code.
All code by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.1 2011/01/04 22:28:17 schwarze Exp $ */
d191 1
a191 1
		buf[i] = tolower((unsigned char)p[*pos]);
@


1.1
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.1 2010/12/28 13:46:07 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d75 1
a75 1
				const char *, int *, int);
d80 1
a80 1
arg(struct tbl_node *tbl, int ln, const char *p, int *pos, int key)
d105 1
a105 1
		if ('\0' == (tbl->opts.delims[0] = p[(*pos)++])) {
d110 1
a110 1
		if ('\0' == (tbl->opts.delims[1] = p[(*pos)++])) {
d191 1
a191 1
		buf[i] = tolower(p[*pos]);
@

