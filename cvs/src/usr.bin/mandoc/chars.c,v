head	1.40;
access;
symbols
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.23.0.6
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.4
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.2
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.40
date	2017.06.02.12.41.28;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	yquNWge1dwMN4Llf;

1.39
date	2017.02.17.18.26.16;	author schwarze;	state Exp;
branches;
next	1.38;
commitid	AlAytSS97a7mJryn;

1.38
date	2015.10.13.22.57.49;	author schwarze;	state Exp;
branches;
next	1.37;
commitid	jXIG8UzKLXm2Z9i6;

1.37
date	2015.10.06.18.30.43;	author schwarze;	state Exp;
branches;
next	1.36;
commitid	hxQV8O1pNUaef4ir;

1.36
date	2015.02.17.20.33.44;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	bzSwTm9b9VF7LbRZ;

1.35
date	2014.10.29.00.17.01;	author schwarze;	state Exp;
branches;
next	1.34;
commitid	DT3doJsSOKw5l7CZ;

1.34
date	2014.10.28.17.35.42;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	pNwmOla3ZQwLgu2f;

1.33
date	2014.10.28.13.22.57;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	KVARFxH9JPv3WrlG;

1.32
date	2014.10.27.13.29.30;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	rqEyu52UjJCimBJX;

1.31
date	2014.10.26.18.06.28;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	35r4kUpCbAKnK6uq;

1.30
date	2014.10.26.17.11.18;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	d5isKf7CwbLlT0IO;

1.29
date	2014.07.23.15.00.00;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	SvLJOe7wZSQdJYIG;

1.28
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2014.01.22.20.58.35;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2013.06.20.22.29.38;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2013.05.18.16.38.54;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2011.11.12.22.43.18;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.08.16.59.50;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2011.05.29.21.26.57;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2011.01.30.16.05.29;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.20.20.43.38;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.13.22.04.01;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2010.08.20.00.53.35;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.18.02.46.37;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.31.21.43.07;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.06.20.30.08;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.26.02.39.58;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.26.01.22.05;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.18.02.11.25;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.24.02.08.14;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.19.09.56.35;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.10.19.09.16.58;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.40
log
@add about 15 missing character escape sequences found in groff_char(7);
triggered by multimedia/mkvtoolnix mkvmerge(1) using \(S2
@
text
@/*	$OpenBSD: chars.c,v 1.39 2017/02/17 18:26:16 schwarze Exp $ */
/*
 * Copyright (c) 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011, 2014, 2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc.h"
#include "mandoc_aux.h"
#include "mandoc_ohash.h"
#include "libmandoc.h"

struct	ln {
	const char	  roffcode[16];
	const char	 *ascii;
	int		  unicode;
};

/* Special break control characters. */
static const char ascii_nbrsp[2] = { ASCII_NBRSP, '\0' };
static const char ascii_break[2] = { ASCII_BREAK, '\0' };

static struct ln lines[] = {

	/* Spacing. */
	{ " ",			ascii_nbrsp,	0x00a0	},
	{ "~",			ascii_nbrsp,	0x00a0	},
	{ "0",			" ",		0x2002	},
	{ "|",			"",		0	},
	{ "^",			"",		0	},
	{ "&",			"",		0	},
	{ "%",			"",		0	},
	{ ":",			ascii_break,	0	},
	/* XXX The following three do not really belong here. */
	{ "t",			"",		0	},
	{ "c",			"",		0	},
	{ "}",			"",		0	},

	/* Lines. */
	{ "ba",			"|",		0x007c	},
	{ "br",			"|",		0x2502	},
	{ "ul",			"_",		0x005f	},
	{ "rn",			"-",		0x203e	},
	{ "bb",			"|",		0x00a6	},
	{ "sl",			"/",		0x002f	},
	{ "rs",			"\\",		0x005c	},

	/* Text markers. */
	{ "ci",			"O",		0x25cb	},
	{ "bu",			"+\bo",		0x2022	},
	{ "dd",			"|\b=",		0x2021	},
	{ "dg",			"|\b-",		0x2020	},
	{ "lz",			"<>",		0x25ca	},
	{ "sq",			"[]",		0x25a1	},
	{ "ps",			"<par>",	0x00b6	},
	{ "sc",			"<sec>",	0x00a7	},
	{ "lh",			"<=",		0x261c	},
	{ "rh",			"=>",		0x261e	},
	{ "at",			"@@",		0x0040	},
	{ "sh",			"#",		0x0023	},
	{ "CR",			"_|",		0x21b5	},
	{ "OK",			"\\/",		0x2713	},
	{ "CL",			"<club>",	0x2663	},
	{ "SP",			"<spade>",	0x2660	},
	{ "HE",			"<heart>",	0x2665	},
	{ "DI",			"<diamond>",	0x2666	},

	/* Legal symbols. */
	{ "co",			"(C)",		0x00a9	},
	{ "rg",			"(R)",		0x00ae	},
	{ "tm",			"tm",		0x2122	},

	/* Punctuation. */
	{ "em",			"--",		0x2014	},
	{ "en",			"-",		0x2013	},
	{ "hy",			"-",		0x2010	},
	{ "e",			"\\",		0x005c	},
	{ ".",			".",		0x002e	},
	{ "r!",			"!",		0x00a1	},
	{ "r?",			"?",		0x00bf	},

	/* Quotes. */
	{ "Bq",			",,",		0x201e	},
	{ "bq",			",",		0x201a	},
	{ "lq",			"\"",		0x201c	},
	{ "rq",			"\"",		0x201d	},
	{ "Lq",			"\"",		0x201c	},
	{ "Rq",			"\"",		0x201d	},
	{ "oq",			"`",		0x2018	},
	{ "cq",			"\'",		0x2019	},
	{ "aq",			"\'",		0x0027	},
	{ "dq",			"\"",		0x0022	},
	{ "Fo",			"<<",		0x00ab	},
	{ "Fc",			">>",		0x00bb	},
	{ "fo",			"<",		0x2039	},
	{ "fc",			">",		0x203a	},

	/* Brackets. */
	{ "lB",			"[",		0x005b	},
	{ "rB",			"]",		0x005d	},
	{ "lC",			"{",		0x007b	},
	{ "rC",			"}",		0x007d	},
	{ "la",			"<",		0x27e8	},
	{ "ra",			">",		0x27e9	},
	{ "bv",			"|",		0x23aa	},
	{ "braceex",		"|",		0x23aa	},
	{ "bracketlefttp",	"|",		0x23a1	},
	{ "bracketleftbt",	"|",		0x23a3	},
	{ "bracketleftex",	"|",		0x23a2	},
	{ "bracketrighttp",	"|",		0x23a4	},
	{ "bracketrightbt",	"|",		0x23a6	},
	{ "bracketrightex",	"|",		0x23a5	},
	{ "lt",			",-",		0x23a7	},
	{ "bracelefttp",	",-",		0x23a7	},
	{ "lk",			"{",		0x23a8	},
	{ "braceleftmid",	"{",		0x23a8	},
	{ "lb",			"`-",		0x23a9	},
	{ "braceleftbt",	"`-",		0x23a9	},
	{ "braceleftex",	"|",		0x23aa	},
	{ "rt",			"-.",		0x23ab	},
	{ "bracerighttp",	"-.",		0x23ab	},
	{ "rk",			"}",		0x23ac	},
	{ "bracerightmid",	"}",		0x23ac	},
	{ "rb",			"-\'",		0x23ad	},
	{ "bracerightbt",	"-\'",		0x23ad	},
	{ "bracerightex",	"|",		0x23aa	},
	{ "parenlefttp",	"/",		0x239b	},
	{ "parenleftbt",	"\\",		0x239d	},
	{ "parenleftex",	"|",		0x239c	},
	{ "parenrighttp",	"\\",		0x239e	},
	{ "parenrightbt",	"/",		0x23a0	},
	{ "parenrightex",	"|",		0x239f	},

	/* Arrows and lines. */
	{ "<-",			"<-",		0x2190	},
	{ "->",			"->",		0x2192	},
	{ "<>",			"<->",		0x2194	},
	{ "da",			"|\bv",		0x2193	},
	{ "ua",			"|\b^",		0x2191	},
	{ "va",			"^v",		0x2195	},
	{ "lA",			"<=",		0x21d0	},
	{ "rA",			"=>",		0x21d2	},
	{ "hA",			"<=>",		0x21d4	},
	{ "uA",			"=\b^",		0x21d1	},
	{ "dA",			"=\bv",		0x21d3	},
	{ "vA",			"^=v",		0x21d5	},
	{ "an",			"-",		0x23af	},

	/* Logic. */
	{ "AN",			"^",		0x2227	},
	{ "OR",			"v",		0x2228	},
	{ "no",			"~",		0x00ac	},
	{ "tno",		"~",		0x00ac	},
	{ "te",			"3",		0x2203	},
	{ "fa",			"-\bV",		0x2200	},
	{ "st",			"-)",		0x220b	},
	{ "tf",			".:.",		0x2234	},
	{ "3d",			".:.",		0x2234	},
	{ "or",			"|",		0x007c	},

	/* Mathematicals. */
	{ "pl",			"+",		0x002b	},
	{ "mi",			"-",		0x2212	},
	{ "-",			"-",		0x002d	},
	{ "-+",			"-+",		0x2213	},
	{ "+-",			"+-",		0x00b1	},
	{ "t+-",		"+-",		0x00b1	},
	{ "pc",			".",		0x00b7	},
	{ "md",			".",		0x22c5	},
	{ "mu",			"x",		0x00d7	},
	{ "tmu",		"x",		0x00d7	},
	{ "c*",			"O\bx",		0x2297	},
	{ "c+",			"O\b+",		0x2295	},
	{ "di",			"-:-",		0x00f7	},
	{ "tdi",		"-:-",		0x00f7	},
	{ "f/",			"/",		0x2044	},
	{ "**",			"*",		0x2217	},
	{ "<=",			"<=",		0x2264	},
	{ ">=",			">=",		0x2265	},
	{ "<<",			"<<",		0x226a	},
	{ ">>",			">>",		0x226b	},
	{ "eq",			"=",		0x003d	},
	{ "!=",			"!=",		0x2260	},
	{ "==",			"==",		0x2261	},
	{ "ne",			"!==",		0x2262	},
	{ "ap",			"~",		0x223c	},
	{ "|=",			"-~",		0x2243	},
	{ "=~",			"=~",		0x2245	},
	{ "~~",			"~~",		0x2248	},
	{ "~=",			"~=",		0x2248	},
	{ "pt",			"oc",		0x221d	},
	{ "es",			"{}",		0x2205	},
	{ "mo",			"E",		0x2208	},
	{ "nm",			"!E",		0x2209	},
	{ "sb",			"(=",		0x2282	},
	{ "nb",			"(!=",		0x2284	},
	{ "sp",			"=)",		0x2283	},
	{ "nc",			"!=)",		0x2285	},
	{ "ib",			"(=\b_",	0x2286	},
	{ "ip",			"=\b_)",	0x2287	},
	{ "ca",			"(^)",		0x2229	},
	{ "cu",			"U",		0x222a	},
	{ "/_",			"_\b/",		0x2220	},
	{ "pp",			"_\b|",		0x22a5	},
	{ "is",			"'\b,\bI",	0x222b	},
	{ "integral",		"'\b,\bI",	0x222b	},
	{ "sum",		"E",		0x2211	},
	{ "product",		"TT",		0x220f	},
	{ "coproduct",		"U",		0x2210	},
	{ "gr",			"V",		0x2207	},
	{ "sr",			"\\/",		0x221a	},
	{ "sqrt",		"\\/",		0x221a	},
	{ "lc",			"|~",		0x2308	},
	{ "rc",			"~|",		0x2309	},
	{ "lf",			"|_",		0x230a	},
	{ "rf",			"_|",		0x230b	},
	{ "if",			"oo",		0x221e	},
	{ "Ah",			"N",		0x2135	},
	{ "Im",			"I",		0x2111	},
	{ "Re",			"R",		0x211c	},
	{ "wp",			"P",		0x2118	},
	{ "pd",			"a",		0x2202	},
	{ "-h",			"/h",		0x210f	},
	{ "hbar",		"/h",		0x210f	},
	{ "12",			"1/2",		0x00bd	},
	{ "14",			"1/4",		0x00bc	},
	{ "34",			"3/4",		0x00be	},
	{ "18",			"1/8",		0x215B	},
	{ "38",			"3/8",		0x215C	},
	{ "58",			"5/8",		0x215D	},
	{ "78",			"7/8",		0x215E	},
	{ "S1",			"1",		0x00B9	},
	{ "S2",			"2",		0x00B2	},
	{ "S3",			"3",		0x00B3	},

	/* Ligatures. */
	{ "ff",			"ff",		0xfb00	},
	{ "fi",			"fi",		0xfb01	},
	{ "fl",			"fl",		0xfb02	},
	{ "Fi",			"ffi",		0xfb03	},
	{ "Fl",			"ffl",		0xfb04	},
	{ "AE",			"AE",		0x00c6	},
	{ "ae",			"ae",		0x00e6	},
	{ "OE",			"OE",		0x0152	},
	{ "oe",			"oe",		0x0153	},
	{ "ss",			"ss",		0x00df	},
	{ "IJ",			"IJ",		0x0132	},
	{ "ij",			"ij",		0x0133	},

	/* Accents. */
	{ "a\"",		"\"",		0x02dd	},
	{ "a-",			"-",		0x00af	},
	{ "a.",			".",		0x02d9	},
	{ "a^",			"^",		0x005e	},
	{ "aa",			"\'",		0x00b4	},
	{ "\'",			"\'",		0x00b4	},
	{ "ga",			"`",		0x0060	},
	{ "`",			"`",		0x0060	},
	{ "ab",			"'\b`",		0x02d8	},
	{ "ac",			",",		0x00b8	},
	{ "ad",			"\"",		0x00a8	},
	{ "ah",			"v",		0x02c7	},
	{ "ao",			"o",		0x02da	},
	{ "a~",			"~",		0x007e	},
	{ "ho",			",",		0x02db	},
	{ "ha",			"^",		0x005e	},
	{ "ti",			"~",		0x007e	},

	/* Accented letters. */
	{ "'A",			"'\bA",		0x00c1	},
	{ "'E",			"'\bE",		0x00c9	},
	{ "'I",			"'\bI",		0x00cd	},
	{ "'O",			"'\bO",		0x00d3	},
	{ "'U",			"'\bU",		0x00da	},
	{ "'a",			"'\ba",		0x00e1	},
	{ "'e",			"'\be",		0x00e9	},
	{ "'i",			"'\bi",		0x00ed	},
	{ "'o",			"'\bo",		0x00f3	},
	{ "'u",			"'\bu",		0x00fa	},
	{ "`A",			"`\bA",		0x00c0	},
	{ "`E",			"`\bE",		0x00c8	},
	{ "`I",			"`\bI",		0x00cc	},
	{ "`O",			"`\bO",		0x00d2	},
	{ "`U",			"`\bU",		0x00d9	},
	{ "`a",			"`\ba",		0x00e0	},
	{ "`e",			"`\be",		0x00e8	},
	{ "`i",			"`\bi",		0x00ec	},
	{ "`o",			"`\bo",		0x00f2	},
	{ "`u",			"`\bu",		0x00f9	},
	{ "~A",			"~\bA",		0x00c3	},
	{ "~N",			"~\bN",		0x00d1	},
	{ "~O",			"~\bO",		0x00d5	},
	{ "~a",			"~\ba",		0x00e3	},
	{ "~n",			"~\bn",		0x00f1	},
	{ "~o",			"~\bo",		0x00f5	},
	{ ":A",			"\"\bA",	0x00c4	},
	{ ":E",			"\"\bE",	0x00cb	},
	{ ":I",			"\"\bI",	0x00cf	},
	{ ":O",			"\"\bO",	0x00d6	},
	{ ":U",			"\"\bU",	0x00dc	},
	{ ":a",			"\"\ba",	0x00e4	},
	{ ":e",			"\"\be",	0x00eb	},
	{ ":i",			"\"\bi",	0x00ef	},
	{ ":o",			"\"\bo",	0x00f6	},
	{ ":u",			"\"\bu",	0x00fc	},
	{ ":y",			"\"\by",	0x00ff	},
	{ "^A",			"^\bA",		0x00c2	},
	{ "^E",			"^\bE",		0x00ca	},
	{ "^I",			"^\bI",		0x00ce	},
	{ "^O",			"^\bO",		0x00d4	},
	{ "^U",			"^\bU",		0x00db	},
	{ "^a",			"^\ba",		0x00e2	},
	{ "^e",			"^\be",		0x00ea	},
	{ "^i",			"^\bi",		0x00ee	},
	{ "^o",			"^\bo",		0x00f4	},
	{ "^u",			"^\bu",		0x00fb	},
	{ ",C",			",\bC",		0x00c7	},
	{ ",c",			",\bc",		0x00e7	},
	{ "/L",			"/\bL",		0x0141	},
	{ "/l",			"/\bl",		0x0142	},
	{ "/O",			"/\bO",		0x00d8	},
	{ "/o",			"/\bo",		0x00f8	},
	{ "oA",			"o\bA",		0x00c5	},
	{ "oa",			"o\ba",		0x00e5	},

	/* Special letters. */
	{ "-D",			"-\bD",		0x00d0	},
	{ "Sd",			"d",		0x00f0	},
	{ "TP",			"Th",		0x00de	},
	{ "Tp",			"th",		0x00fe	},
	{ ".i",			"i",		0x0131	},
	{ ".j",			"j",		0x0237	},

	/* Currency. */
	{ "Do",			"$",		0x0024	},
	{ "ct",			"/\bc",		0x00a2	},
	{ "Eu",			"EUR",		0x20ac	},
	{ "eu",			"EUR",		0x20ac	},
	{ "Ye",			"=\bY",		0x00a5	},
	{ "Po",			"GBP",		0x00a3	},
	{ "Cs",			"o\bx",		0x00a4	},
	{ "Fn",			",\bf",		0x0192	},

	/* Units. */
	{ "de",			"<deg>",	0x00b0	},
	{ "%0",			"%o",		0x2030	},
	{ "fm",			"\'",		0x2032	},
	{ "sd",			"''",		0x2033	},
	{ "mc",			",\bu",		0x00b5	},
	{ "Of",			"_\ba",		0x00aa	},
	{ "Om",			"_\bo",		0x00ba	},

	/* Greek characters. */
	{ "*A",			"A",		0x0391	},
	{ "*B",			"B",		0x0392	},
	{ "*G",			"G",		0x0393	},
	{ "*D",			"_\b/_\b\\",	0x0394	},
	{ "*E",			"E",		0x0395	},
	{ "*Z",			"Z",		0x0396	},
	{ "*Y",			"H",		0x0397	},
	{ "*H",			"-\bO",		0x0398	},
	{ "*I",			"I",		0x0399	},
	{ "*K",			"K",		0x039a	},
	{ "*L",			"/\\",		0x039b	},
	{ "*M",			"M",		0x039c	},
	{ "*N",			"N",		0x039d	},
	{ "*C",			"_\bH",		0x039e	},
	{ "*O",			"O",		0x039f	},
	{ "*P",			"TT",		0x03a0	},
	{ "*R",			"P",		0x03a1	},
	{ "*S",			"S",		0x03a3	},
	{ "*T",			"T",		0x03a4	},
	{ "*U",			"Y",		0x03a5	},
	{ "*F",			"I\bO",		0x03a6	},
	{ "*X",			"X",		0x03a7	},
	{ "*Q",			"I\bY",		0x03a8	},
	{ "*W",			"_\bO",		0x03a9	},
	{ "*a",			"a",		0x03b1	},
	{ "*b",			"B",		0x03b2	},
	{ "*g",			"y",		0x03b3	},
	{ "*d",			"d",		0x03b4	},
	{ "*e",			"e",		0x03b5	},
	{ "*z",			",\bC",		0x03b6	},
	{ "*y",			"n",		0x03b7	},
	{ "*h",			"-\b0",		0x03b8	},
	{ "*i",			"i",		0x03b9	},
	{ "*k",			"k",		0x03ba	},
	{ "*l",			">\b\\",	0x03bb	},
	{ "*m",			",\bu",		0x03bc	},
	{ "*n",			"v",		0x03bd	},
	{ "*c",			",\bE",		0x03be	},
	{ "*o",			"o",		0x03bf	},
	{ "*p",			"-\bn",		0x03c0	},
	{ "*r",			"p",		0x03c1	},
	{ "*s",			"-\bo",		0x03c3	},
	{ "*t",			"~\bt",		0x03c4	},
	{ "*u",			"u",		0x03c5	},
	{ "*f",			"|\bo",		0x03d5	},
	{ "*x",			"x",		0x03c7	},
	{ "*q",			"|\bu",		0x03c8	},
	{ "*w",			"w",		0x03c9	},
	{ "+h",			"-\b0",		0x03d1	},
	{ "+f",			"|\bo",		0x03c6	},
	{ "+p",			"-\bw",		0x03d6	},
	{ "+e",			"e",		0x03f5	},
	{ "ts",			"s",		0x03c2	},
};

static	struct ohash	  mchars;


void
mchars_free(void)
{

	ohash_delete(&mchars);
}

void
mchars_alloc(void)
{
	size_t		  i;
	unsigned int	  slot;

	mandoc_ohash_init(&mchars, 9, offsetof(struct ln, roffcode));
	for (i = 0; i < sizeof(lines)/sizeof(lines[0]); i++) {
		slot = ohash_qlookup(&mchars, lines[i].roffcode);
		assert(ohash_find(&mchars, slot) == NULL);
		ohash_insert(&mchars, slot, lines + i);
	}
}

int
mchars_spec2cp(const char *p, size_t sz)
{
	const struct ln	*ln;
	const char	*end;

	end = p + sz;
	ln = ohash_find(&mchars, ohash_qlookupi(&mchars, p, &end));
	return ln != NULL ? ln->unicode : sz == 1 ? (unsigned char)*p : -1;
}

int
mchars_num2char(const char *p, size_t sz)
{
	int	  i;

	i = mandoc_strntoi(p, sz, 10);
	return i >= 0 && i < 256 ? i : -1;
}

int
mchars_num2uc(const char *p, size_t sz)
{
	int	 i;

	i = mandoc_strntoi(p, sz, 16);
	assert(i >= 0 && i <= 0x10FFFF);
	return i;
}

const char *
mchars_spec2str(const char *p, size_t sz, size_t *rsz)
{
	const struct ln	*ln;
	const char	*end;

	end = p + sz;
	ln = ohash_find(&mchars, ohash_qlookupi(&mchars, p, &end));
	if (ln == NULL) {
		*rsz = 1;
		return sz == 1 ? p : NULL;
	}

	*rsz = strlen(ln->ascii);
	return ln->ascii;
}

const char *
mchars_uc2str(int uc)
{
	size_t	  i;

	for (i = 0; i < sizeof(lines)/sizeof(lines[0]); i++)
		if (uc == lines[i].unicode)
			return lines[i].ascii;
	return "<?>";
}
@


1.39
log
@Many people have been complaining for a long time that ``...'' looks
ugly in -Tascii output.  For that reason, bentley@@ submitted patches
to render "..." instead to groff in November 2014 (yes, more than
two years ago).  Carsten Kunze yesterday merged them for the upcoming
groff-1.22.4 release.  Yay!

Consequently, do the same in mandoc: Render \(Lq and \(Rq (which
are used for .Do, .Dq, .Lb, and .St) as '"' in -Tascii output.
All other output modes including -Tutf8 remain unchanged.
@
text
@d1 1
a1 1
/*	$OpenBSD: chars.c,v 1.38 2015/10/13 22:57:49 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
d82 4
d166 1
d240 1
d243 1
d247 7
d369 2
@


1.38
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$OpenBSD: chars.c,v 1.37 2015/10/06 18:30:43 schwarze Exp $ */
d102 2
a103 2
	{ "Lq",			"``",		0x201c	},
	{ "Rq",			"''",		0x201d	},
@


1.37
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: chars.c,v 1.36 2015/02/17 20:33:44 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d22 2
d29 1
a31 3
#define	PRINT_HI	 126
#define	PRINT_LO	 32

d33 1
a33 2
	struct ln	 *next;
	const char	 *code;
d38 372
a409 12
#define	LINES_MAX	  332

#define CHAR(in, ch, code) \
	{ NULL, (in), (ch), (code) },

#define	CHAR_TBL_START	  static struct ln lines[LINES_MAX] = {
#define	CHAR_TBL_END	  };

#include "chars.in"

struct	mchars {
	struct ln	**htab;
d412 1
a412 2
static	const struct ln	 *find(const struct mchars *,
				const char *, size_t);
d416 1
a416 1
mchars_free(struct mchars *arg)
d419 1
a419 2
	free(arg->htab);
	free(arg);
d422 1
a422 1
struct mchars *
d425 8
a432 25
	struct mchars	 *tab;
	struct ln	**htab;
	struct ln	 *pp;
	int		  i, hash;

	/*
	 * Constructs a very basic chaining hashtable.  The hash routine
	 * is simply the integral value of the first character.
	 * Subsequent entries are chained in the order they're processed.
	 */

	tab = mandoc_malloc(sizeof(struct mchars));
	htab = mandoc_calloc(PRINT_HI - PRINT_LO + 1, sizeof(struct ln *));

	for (i = 0; i < LINES_MAX; i++) {
		hash = (int)lines[i].code[0] - PRINT_LO;

		if (NULL == (pp = htab[hash])) {
			htab[hash] = &lines[i];
			continue;
		}

		for ( ; pp->next; pp = pp->next)
			/* Scan ahead. */ ;
		pp->next = &lines[i];
a433 3

	tab->htab = htab;
	return tab;
d437 1
a437 1
mchars_spec2cp(const struct mchars *arg, const char *p, size_t sz)
d440 1
d442 2
a443 1
	ln = find(arg, p, sz);
d467 1
a467 2
mchars_spec2str(const struct mchars *arg,
		const char *p, size_t sz, size_t *rsz)
d470 1
d472 2
a473 1
	ln = find(arg, p, sz);
d486 1
a486 1
	int	 i;
d488 1
a488 1
	for (i = 0; i < LINES_MAX; i++)
a491 21
}

static const struct ln *
find(const struct mchars *tab, const char *p, size_t sz)
{
	const struct ln	 *pp;
	int		  hash;

	assert(p);

	if (0 == sz || p[0] < PRINT_LO || p[0] > PRINT_HI)
		return NULL;

	hash = (int)p[0] - PRINT_LO;

	for (pp = tab->htab[hash]; pp; pp = pp->next)
		if (0 == strncmp(pp->code, p, sz) &&
		    '\0' == pp->code[(int)sz])
			return pp;

	return NULL;
@


1.36
log
@Render \(lq and \(rq as '"' in -Tascii mode but leave the rendering
of .Do/.Dc, .Dq, .Lb, and .St untouched.
Reduces groff-mandoc differences in base by about 7%.
Reminded of the issue by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: chars.c,v 1.35 2014/10/29 00:17:01 schwarze Exp $ */
d96 1
a96 1
	return(tab);
d105 1
a105 1
	return(ln != NULL ? ln->unicode : sz == 1 ? (unsigned char)*p : -1);
d114 1
a114 1
	return(i >= 0 && i < 256 ? i : -1);
d124 1
a124 1
	return(i);
d136 1
a136 1
		return(sz == 1 ? p : NULL);
d140 1
a140 1
	return(ln->ascii);
d150 2
a151 2
			return(lines[i].ascii);
	return("<?>");
d163 1
a163 1
		return(NULL);
d170 1
a170 1
			return(pp);
d172 1
a172 1
	return(NULL);
@


1.35
log
@In terminal output, unify handling of Unicode and numbered character
escape sequences just like it was earlier implemented for -Thtml.
Do not let control characters other than ASCII 9 (horizontal tab)
propagate to the output, even though groff allows them; but that
really doesn't look like a great idea.

Let mchars_num2char() return int such that we can distinguish invalid \N
syntax from \N'0'.  This also reduces the danger of signed char issues
popping up.
@
text
@d1 1
a1 1
/*	$OpenBSD: chars.c,v 1.34 2014/10/28 17:35:42 schwarze Exp $ */
d39 1
a39 1
#define	LINES_MAX	  330
@


1.34
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: chars.c,v 1.33 2014/10/28 13:22:57 schwarze Exp $ */
d108 1
a108 1
char
d113 2
a114 4
	if ((i = mandoc_strntoi(p, sz, 10)) < 0)
		return('\0');

	return(i > 0 && i < 256 && isprint(i) ? i : '\0');
@


1.33
log
@Tighten Unicode escape name parsing.
Accept only 0xXXXX, 0xYXXXX, 0x10XXXX with Y != 0.
This simplifies mchars_num2uc().
@
text
@d1 1
a1 1
/*	$OpenBSD: chars.c,v 1.32 2014/10/27 13:29:30 schwarze Exp $ */
d105 1
a105 1
	return(ln != NULL ? ln->unicode : sz == 1 ? *p : 0xFFFD);
@


1.32
log
@Fix a regression in term.c rev. 1.89 reported by bentley@@:
In UTF-8 output, do not print anything if mchars_spec2cp() returns 0.
In particular, this repairs handling of zero-width spaces (\&).

While here, let mchars_spec2cp() return 0xFFFD instead of -1
if the character is not found, simplifying the using code.
In HTML output, do not print obfuscated ASCII characters and
do not test for one-char escapes, mchars_spec2cp() already does that.
@
text
@d1 1
a1 1
/*	$OpenBSD: chars.c,v 1.31 2014/10/26 18:06:28 schwarze Exp $ */
d124 3
a126 8
	if ((i = mandoc_strntoi(p, sz, 16)) < 0)
		return(0xFFFD);

	/*
	 * XXX Code is missing here to exclude bogus ranges.
	 */

	return(i <= 0x10FFFF ? i : 0xFFFD);
@


1.31
log
@In -Tascii mode, provide approximations even for some Unicode escape
sequences above codepoint 512 by doing a reverse lookup in the
existing mandoc_char(7) character table.

Again, groff isn't smart enough to do this and silently discards such
escape sequences without printing anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: chars.c,v 1.30 2014/10/26 17:11:18 schwarze Exp $ */
d105 1
a105 1
	return(ln != NULL ? ln->unicode : sz == 1 ? *p : -1);
@


1.30
log
@Improve -Tascii output for Unicode escape sequences: For the first 512
code points, provide ASCII approximations.  This is already much better
than what groff does, which prints nothing for most code points.

A few minor fixes while here:
* Handle Unicode escape sequences in the ASCII range.
* In case of errors, use the REPLACEMENT CHARACTER U+FFFD for -Tutf8
and the string "<?>" for -Tascii output.
* Handle all one-character escape sequences in mchars_spec2{cp,str}()
and remove the workarounds on the higher level.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d18 2
d148 11
@


1.29
log
@Security fix:
After decoding numeric (\N) and one-character (\<, \> etc.)
character escape sequences, do not forget to HTML-encode the
resulting ASCII character.  Malicious manuals were able to smuggle
XSS content by roff-escaping the HTML-special characters they need.
That's a classic bug type in many web applications, actually...  :-(

Found myself while auditing the HTML formatter for safe output handling.
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.28 2014/04/20 16:44:44 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
d103 1
a103 3
	if (NULL == ln)
		return(-1);
	return(ln->unicode);
d123 1
a123 1
		return('\0');
a125 7
	 * Security warning:
	 * Never extend the range of accepted characters
	 * to overlap with the ASCII range, 0x00-0x7F
	 * without re-auditing the callers of this function.
	 * Some callers might relay on the fact that we never
	 * return ASCII characters for their escaping decisions.
	 *
d129 1
a129 1
	return(i > 0x80 && i <= 0x10FFFF ? i : '\0');
d139 1
a139 1
	if (NULL == ln) {
d141 1
a141 1
		return(NULL);
@


1.28
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.27 2014/03/21 22:17:01 schwarze Exp $ */
d126 12
a137 1
	/* FIXME: make sure we're not in a bogus range. */
@


1.27
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.26 2014/01/22 20:58:35 schwarze Exp $ */
d51 1
a51 1
static	const struct ln	 *find(const struct mchars *, 
d54 1
d111 1
a111 1
	int		  i;
d115 2
a116 2
	return(i > 0 && i < 256 && isprint(i) ? 
			/* LINTED */ i : '\0');
d122 1
a122 1
	int               i;
d131 1
a131 1
mchars_spec2str(const struct mchars *arg, 
d160 2
a161 2
		if (0 == strncmp(pp->code, p, sz) && 
				'\0' == pp->code[(int)sz])
@


1.26
log
@Implement the \: (optional line break) escape sequence,
documented in the Ossanna-Kernighan-Ritter troff manual
and also supported by groff.

Missing feature reported by Steffen Nurpmeso <sdaoden at gmail dot com>.
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.25 2013/06/20 22:29:38 schwarze Exp $ */
d24 1
@


1.25
log
@Improve handling of the roff(7) "\t" escape sequence:
* Parsing macro arguments has to be done in copy mode,
  which implies replacing "\t" by a literal tab character.
* Otherwise, render "\t" as the empty string, not as a 't' character.

This fixes formatting of the distfile example in the oldrdist(1) manual.
This also shows up in the unzip(1) manual as one of several issues
preventing the removal of USE_GROFF from the archivers/unzip port.
Thanks to espie@@ for attracting my attention to the unzip(1) manual.
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.24 2013/05/18 16:38:54 schwarze Exp $ */
d36 1
a36 1
#define	LINES_MAX	  329
@


1.24
log
@Even though the size of a pointer should not depend on the type of the
data pointed to, pass the size of the right pointer type to calloc;
cosmetic issue reported by Ulrich Spoerlein <uqs@@spoerlein.net>
found in Coverity Scan CID 978734.
No binary change - ok cmp(1).
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.23 2011/11/12 22:43:18 schwarze Exp $ */
d36 1
a36 1
#define	LINES_MAX	  328
@


1.23
log
@mark some arguments "const" that will not be changed; from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.22 2011/09/18 10:25:28 schwarze Exp $ */
d76 1
a76 1
	htab = mandoc_calloc(PRINT_HI - PRINT_LO + 1, sizeof(struct ln **));
@


1.22
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.21 2011/07/08 16:59:50 schwarze Exp $ */
d50 2
a51 1
static	const struct ln	 *find(struct mchars *, const char *, size_t);
d96 1
a96 1
mchars_spec2cp(struct mchars *arg, const char *p, size_t sz)
d113 2
a114 1
	return(i > 0 && i < 256 && isprint(i) ? i : '\0');
d129 2
a130 1
mchars_spec2str(struct mchars *arg, const char *p, size_t sz, size_t *rsz)
d145 1
a145 1
find(struct mchars *tab, const char *p, size_t sz)
d147 1
a147 1
	struct ln	 *pp;
@


1.21
log
@simplify: there's really no need for extra code to reorder
the hash chain or an extra function for checking matches;
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.20 2011/05/29 21:26:57 schwarze Exp $ */
d36 1
a36 1
#define	LINES_MAX	  325
d110 1
a110 1
	if ((i = mandoc_strntou(p, sz, 10)) < 0)
d120 1
a120 1
	if ((i = mandoc_strntou(p, sz, 16)) < 0)
@


1.20
log
@Fix two regressions introduced in 1.11.3:
* Do not pass integers outside the ASCII range to isprint().
* Make sure escaped characters are really printed verbatim
  when the escape sequence has no special meaning.
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.18 2011/04/24 16:22:02 schwarze Exp $ */
a19 1
#include <stdio.h>
a49 1
static	inline int	  match(const struct ln *, const char *, size_t);
d71 1
a71 2
	 * Subsequent entries are chained in the order they're processed
	 * (they're in-line re-ordered during lookup).
a93 4

/* 
 * Special character to Unicode codepoint.
 */
a104 7
/*
 * Numbered character string to ASCII codepoint.
 * This can only be a printable character (i.e., alnum, punct, space) so
 * prevent the character from ruining our state (backspace, newline, and
 * so on).
 * If the character is illegal, returns '\0'.
 */
a114 4
/*
 * Hex character string to Unicode codepoint.
 * If the character is illegal, returns '\0'.
 */
a125 3
/* 
 * Special character to string array.
 */
d144 1
a144 2
	struct ln	 *pp, *prev;
	struct ln	**htab;
a147 2
	if (0 == sz)
		return(NULL);
d149 1
a149 1
	if (p[0] < PRINT_LO || p[0] > PRINT_HI)
a151 6
	/*
	 * Lookup the symbol in the symbol hash.  See ascii2htab for the
	 * hashtable specs.  This dynamically re-orders the hash chain
	 * to optimise for repeat hits.
	 */

a152 1
	htab = tab->htab;
d154 4
a157 17
	if (NULL == (pp = htab[hash]))
		return(NULL);

	for (prev = NULL; pp; pp = pp->next) {
		if ( ! match(pp, p, sz)) {
			prev = pp;
			continue;
		}

		if (prev) {
			prev->next = pp->next;
			pp->next = htab[hash];
			htab[hash] = pp;
		}

		return(pp);
	}
a159 9
}

static inline int
match(const struct ln *ln, const char *p, size_t sz)
{

	if (strncmp(ln->code, p, sz))
		return(0);
	return('\0' == ln->code[(int)sz]);
@


1.19
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d126 1
a126 1
	return(isprint(i) ? i : '\0');
d153 2
a154 1
	if (NULL == ln)
d156 1
@


1.18
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.17 2011/04/21 22:59:54 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d19 1
d25 1
a25 1
#include "out.h"
a34 4
	int		  type;
#define	CHARS_CHAR	 (1 << 0)
#define	CHARS_STRING	 (1 << 1)
#define CHARS_BOTH	 (CHARS_CHAR | CHARS_STRING)
d37 1
a37 1
#define	LINES_MAX	  353
d40 1
a40 5
	{ NULL, (in), (ch), (code), CHARS_CHAR },
#define STRING(in, ch, code) \
	{ NULL, (in), (ch), (code), CHARS_STRING },
#define BOTH(in, ch, code) \
	{ NULL, (in), (ch), (code), CHARS_BOTH },
d47 1
a47 2
struct	ctab {
	enum chars	  type;
d51 2
a52 4
static	inline int	  match(const struct ln *,
				const char *, size_t, int);
static	const struct ln	 *find(struct ctab *, const char *, size_t, int);

d55 1
a55 1
chars_free(void *arg)
a56 3
	struct ctab	*tab;

	tab = (struct ctab *)arg;
d58 2
a59 2
	free(tab->htab);
	free(tab);
d62 2
a63 3

void *
chars_init(enum chars type)
d65 1
a65 1
	struct ctab	 *tab;
d77 1
a77 1
	tab = mandoc_malloc(sizeof(struct ctab));
a93 1
	tab->type = type;
d102 1
a102 1
chars_spec2cp(void *arg, const char *p, size_t sz)
d106 1
a106 1
	ln = find((struct ctab *)arg, p, sz, CHARS_CHAR);
d112 6
a117 3

/* 
 * Reserved word to Unicode codepoint.
d119 2
a120 2
int
chars_res2cp(void *arg, const char *p, size_t sz)
d122 1
a122 1
	const struct ln	*ln;
d124 3
a126 4
	ln = find((struct ctab *)arg, p, sz, CHARS_STRING);
	if (NULL == ln)
		return(-1);
	return(ln->unicode);
a128 1

d130 2
a131 2
 * Numbered character to literal character,
 * represented as a null-terminated string for additional safety.
d133 2
a134 2
const char *
chars_num2char(const char *p, size_t sz)
d136 1
a136 2
	int		  i;
	static char	  c[2];
d138 4
a141 8
	if (sz > 3)
		return(NULL);
	i = atoi(p);
	if (i < 0 || i > 255)
		return(NULL);
	c[0] = (char)i;
	c[1] = '\0';
	return(c);
a143 1

d148 1
a148 1
chars_spec2str(void *arg, const char *p, size_t sz, size_t *rsz)
d152 1
a152 1
	ln = find((struct ctab *)arg, p, sz, CHARS_CHAR);
a159 18

/* 
 * Reserved word to string array.
 */
const char *
chars_res2str(void *arg, const char *p, size_t sz, size_t *rsz)
{
	const struct ln	*ln;

	ln = find((struct ctab *)arg, p, sz, CHARS_STRING);
	if (NULL == ln)
		return(NULL);

	*rsz = strlen(ln->ascii);
	return(ln->ascii);
}


d161 1
a161 1
find(struct ctab *tab, const char *p, size_t sz, int type)
d187 1
a187 1
		if ( ! match(pp, p, sz, type)) {
a203 1

d205 1
a205 1
match(const struct ln *ln, const char *p, size_t sz, int type)
a207 2
	if ( ! (ln->type & type))
		return(0);
@


1.17
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.16 2011/01/30 16:05:29 schwarze Exp $ */
d24 1
a24 1
#include "chars.h"
d40 1
a40 1
#define	LINES_MAX	  351
@


1.16
log
@Implement the \N'number' (numbered character) roff escape sequence.
Don't use it in new manuals, it is inherently non-portable, but we
need it for backward-compatibility with existing manuals, for example
in Xenocara driver pages.
ok kristaps@@ matthieu@@ jmc@@
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.15 2011/01/04 22:28:17 schwarze Exp $ */
d91 2
a92 11
	tab = malloc(sizeof(struct ctab));
	if (NULL == tab) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}

	htab = calloc(PRINT_HI - PRINT_LO + 1, sizeof(struct ln **));
	if (NULL == htab) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
@


1.15
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.14 2010/09/20 20:43:38 schwarze Exp $ */
d4 1
d149 21
@


1.14
log
@remove remaining pod2man escapes, mandoc now uses the standard preamble;
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.13 2010/09/13 22:04:01 schwarze Exp $ */
d53 1
a53 1
struct	tbl {
d60 1
a60 1
static	const struct ln	 *find(struct tbl *, const char *, size_t, int);
d66 1
a66 1
	struct tbl	*tab;
d68 1
a68 1
	tab = (struct tbl *)arg;
d78 1
a78 1
	struct tbl	 *tab;
d90 1
a90 1
	tab = malloc(sizeof(struct tbl));
d129 1
a129 1
	ln = find((struct tbl *)arg, p, sz, CHARS_CHAR);
d144 1
a144 1
	ln = find((struct tbl *)arg, p, sz, CHARS_STRING);
d159 1
a159 1
	ln = find((struct tbl *)arg, p, sz, CHARS_CHAR);
d176 1
a176 1
	ln = find((struct tbl *)arg, p, sz, CHARS_STRING);
d186 1
a186 1
find(struct tbl *tab, const char *p, size_t sz, int type)
@


1.13
log
@Parse and ignore the \k, \o, \w, and \z roff escapes, and recursively
ignore embedded escapes and mathematical roff subexpressions.
In roff copy mode, resolve "\\" to '\'.
Allow ".xx\}" where xx is a macro to close roff conditional scope.
Mandoc now handles the special character definitions in the pod2man(1)
preamble, so remove the explicit redefinitions in chars.c/chars.in.
From kristaps@@.

I have checked that this causes no relevant change to the Perl manuals.
The only change introduced is that some non-ASCII characters rendered
incorrectly before are now rendered incorrectly in a different way.
For example, e accent aigu was "e", now is "e'"
and c cedille was "c", now is "c,".
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.12 2010/08/20 00:53:35 schwarze Exp $ */
d39 1
a39 1
#define	LINES_MAX	  362
d93 1
a93 1
		exit(MANDOCLEVEL_SYSERR);
d99 1
a99 1
		exit(MANDOCLEVEL_SYSERR);
@


1.12
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.11 2010/08/18 02:46:37 schwarze Exp $ */
d39 1
a39 1
#define	LINES_MAX	  369
@


1.11
log
@Remove the standard pod2man \*(C+ pre-predefined string ("C++").
It is always defined in the preamble using .ds when used in manuals.
Since we now support .ds, it is no longer necessary to provide it.
Triggered by a bug report from Thomas Jeunet, patch by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.10 2010/07/31 21:43:07 schwarze Exp $ */
d93 1
a93 1
		exit(EXIT_FAILURE);
d99 1
a99 1
		exit(EXIT_FAILURE);
@


1.10
log
@Merge bsd.lv version 1.10.5: last larger batch of bug fixes before release.
NOT including Kristaps' .Bd -literal changes which cause regressions.
Features:
* -Tpdf now fully working
Bugfixes:
* proper handling of quoted strings by .ds in roff(7)
* allow empty .Dd
* make .Sm start no-spacing after the first output word
* underline .Ad
* minor fixes in -Thtml
and some optimisations in terminal output.
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.9 2010/07/25 18:05:54 schwarze Exp $ */
d39 1
a39 1
#define	LINES_MAX	  370
@


1.9
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.8 2010/06/06 20:30:08 schwarze Exp $ */
a31 1
	size_t		  asciisz;
d41 6
a46 6
#define CHAR(in, ch, chsz, code) \
	{ NULL, (in), (ch), (chsz), (code), CHARS_CHAR },
#define STRING(in, ch, chsz, code) \
	{ NULL, (in), (ch), (chsz), (code), CHARS_STRING },
#define BOTH(in, ch, chsz, code) \
	{ NULL, (in), (ch), (chsz), (code), CHARS_BOTH },
d163 1
a163 1
	*rsz = ln->asciisz;
d180 1
a180 1
	*rsz = ln->asciisz;
@


1.8
log
@Merge bsd.lv version 1.10.1 (to be released soon).

The main step forward is that this now has *much* better .Bl -column
support, now supporting many manuals that previously errored out
without producing any output.

Other fixes include:
* do not die from multiple list types, use the first and warn
* in .Bl without a type, default to -item
* various tweaks to .Dt
* fix .In, .Fd, .Ft, .Fn and .Fo formatting
* some documentation fixes and additions
* and fix a couple of bugs reported by Ulrich Spoerlein:
* better support for roff block-end "\}" without a preceding dot
* .In must not break the line outside SYNOPSIS
* spelling in some error messages

While merging, fix one regression in .In spacing
that needs to go to bsd.lv, too.
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.7 2010/05/26 02:39:58 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2009 Kristaps Dzonsons <kristaps@@kth.se>
a31 2
	const char	 *html;
	size_t		  codesz;
d33 1
a33 1
	size_t		  htmlsz;
d42 6
a47 6
#define CHAR(w, x, y, z, a, b) \
	{ NULL, (w), (y), (a), (x), (z), (b), CHARS_CHAR },
#define STRING(w, x, y, z, a, b) \
	{ NULL, (w), (y), (a), (x), (z), (b), CHARS_STRING },
#define BOTH(w, x, y, z, a, b) \
	{ NULL, (w), (y), (a), (x), (z), (b), CHARS_BOTH },
d61 1
a61 2
static	const char	 *find(struct tbl *, const char *, 
				size_t, size_t *, int);
d122 33
d156 1
a156 1
chars_a2ascii(void *arg, const char *p, size_t sz, size_t *rsz)
d158 5
d164 2
a165 1
	return(find((struct tbl *)arg, p, sz, rsz, CHARS_CHAR));
d169 3
d173 1
a173 1
chars_a2res(void *arg, const char *p, size_t sz, size_t *rsz)
d175 5
d181 2
a182 1
	return(find((struct tbl *)arg, p, sz, rsz, CHARS_STRING));
d186 2
a187 2
static const char *
find(struct tbl *tab, const char *p, size_t sz, size_t *rsz, int type)
d194 2
a195 1
	assert(sz > 0);
d224 1
a224 6
		if (CHARS_HTML == tab->type) {
			*rsz = pp->htmlsz;
			return(pp->html);
		}
		*rsz = pp->asciisz;
		return(pp->ascii);
d237 1
a237 1
	if (ln->codesz != sz)
d239 1
a239 1
	return(0 == strncmp(ln->code, p, sz));
@


1.7
log
@When a word does not fully fit onto the output line, but it contains
at least one hyphen, we already had support for breaking the line a the
last fitting hyphen.  This patch improves this functionality by only
breaking at hyphens in free-form text, and by not breaking at hyphens
* at the beginning or end of a word   or
* immediately preceded or followed by another hyphen   or
* escaped by a preceding backslash.

Before this patch, differences in break-at-hyphen support were one
of the major sources of noise in automatic comparisons to mdoc(7)
groff output.  Now, the remaining differences are hard to find among
the noise coming from other sources.

Where there are still differences, what we do seems to be better than
what groff does, see e.g. the chio(1) exchange and position commands
for one of the now rare examples.

idea and coding by kristaps@@

Besides, this was the last substantial code difference left
between bsd.lv and openbsd.org.  We are now in full sync.
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.6 2010/03/26 01:22:05 schwarze Exp $ */
d42 1
a42 1
#define	LINES_MAX	  369
@


1.6
log
@merge 1.9.17, keeping local patches

* much improved pod2man support and low-level roff robustness
* have -Tlint imply -Wall and -fstrict
* use fewer macros and more enum in libman
* and various bug fixes
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.5 2010/02/18 02:11:25 schwarze Exp $ */
d22 1
@


1.5
log
@sync to release 1.9.15:
 * corrected .Vt handling (spotted by Joerg Sonnenberger)
 * corrected .Xr argument handling (based on my patch)
 * removed \\ escape sequence (because it is for low-level roff only)
 * warn about trailing whitespace (suggested by jmc@@)
 * -Txhtml support
 * and some general cleanup and doc improvements
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.4 2009/12/24 02:08:14 schwarze Exp $ */
d41 1
a41 1
#define	LINES_MAX	  350
@


1.4
log
@sync to 1.9.14: rewrite escape sequence handling:
- new function a2roffdeco
- font modes (\f) only affect the current stack point
- implement scaling (\s)
- implement space suppression (\c)
- implement non-breaking space (\~) in -Tascii
- many manual improvements
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.3 2009/12/22 23:58:00 schwarze Exp $ */
d41 1
a41 1
#define	LINES_MAX	  351
a163 12

	if (NULL == pp->next) {
		if ( ! match(pp, p, sz, type)) 
			return(NULL);

		if (CHARS_HTML == tab->type) {
			*rsz = pp->htmlsz;
			return(pp->html);
		}
		*rsz = pp->asciisz;
		return(pp->ascii);
	}
@


1.3
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.2 2009/10/19 09:56:35 schwarze Exp $ */
d38 1
a38 1
#define CHARS_BOTH	 (0x03)
d50 3
a52 1
static	struct ln lines[LINES_MAX] = {
a53 1
};
@


1.2
log
@sync to 1.9.6: here is the sync of special characters to new groff
as mentioned in the preceding manual commit (oops)
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.1 2009/10/19 09:16:58 schwarze Exp $ */
d18 1
a18 1
#include <err.h>
d92 5
a96 3
	if (NULL == (tab = malloc(sizeof(struct tbl))))
		err(1, "malloc");
	tab->type = type;
d99 4
a102 2
	if (NULL == htab)
		err(1, "malloc");
d118 1
@


1.1
log
@sync to 1.9.5: partial rewrite of special character and predefined string
tables and the supporting infrastructure, mostly in preparation for
HTML output support
@
text
@d1 1
a1 1
/*	$Id: chars.c,v 1.2 2009/09/17 08:21:42 kristaps Exp $ */
d41 1
a41 1
#define	LINES_MAX	  266
@

