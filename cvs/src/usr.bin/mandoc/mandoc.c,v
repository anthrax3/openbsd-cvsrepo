head	1.71;
access;
symbols
	OPENBSD_6_2:1.71.0.2
	OPENBSD_6_2_BASE:1.71
	OPENBSD_6_1:1.66.0.8
	OPENBSD_6_1_BASE:1.66
	OPENBSD_6_0:1.66.0.4
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.60.0.6
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.60.0.2
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.35.0.4
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.2
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.2
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7;
locks; strict;
comment	@ * @;


1.71
date	2017.07.03.13.40.00;	author schwarze;	state Exp;
branches;
next	1.70;
commitid	1dutikfSlALoEQie;

1.70
date	2017.06.14.01.31.19;	author schwarze;	state Exp;
branches;
next	1.69;
commitid	PPUZg39EU736tntb;

1.69
date	2017.06.11.19.36.31;	author schwarze;	state Exp;
branches;
next	1.68;
commitid	XRYVv5vPYVYMmfcL;

1.68
date	2017.06.02.19.21.03;	author schwarze;	state Exp;
branches;
next	1.67;
commitid	P297MbnOCh21x0GC;

1.67
date	2017.06.01.19.05.15;	author schwarze;	state Exp;
branches;
next	1.66;
commitid	dWvl4SBMkA0iJYZz;

1.66
date	2015.11.12.22.43.30;	author schwarze;	state Exp;
branches;
next	1.65;
commitid	OeYYVNOpjgEA3k5E;

1.65
date	2015.10.15.23.35.38;	author schwarze;	state Exp;
branches;
next	1.64;
commitid	ZZYY6Czx66FgtwMk;

1.64
date	2015.10.13.23.30.42;	author schwarze;	state Exp;
branches;
next	1.63;
commitid	A4ygCil1Mn9VDkml;

1.63
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.62;
commitid	Ql2ha5NS80pwfGNT;

1.62
date	2015.10.06.18.30.43;	author schwarze;	state Exp;
branches;
next	1.61;
commitid	hxQV8O1pNUaef4ir;

1.61
date	2015.08.29.22.39.59;	author schwarze;	state Exp;
branches;
next	1.60;
commitid	uZ3q71CI3hhNH9ko;

1.60
date	2015.02.20.23.51.54;	author schwarze;	state Exp;
branches;
next	1.59;
commitid	NtjtRARbGeQfouLq;

1.59
date	2015.01.21.20.20.49;	author schwarze;	state Exp;
branches;
next	1.58;
commitid	oPCJQka1zVKJ04b2;

1.58
date	2015.01.01.18.10.09;	author schwarze;	state Exp;
branches;
next	1.57;
commitid	KrvHfL0MlExM8p3R;

1.57
date	2014.12.15.17.29.58;	author schwarze;	state Exp;
branches;
next	1.56;
commitid	YBDsCYrwS4D1DFMF;

1.56
date	2014.11.28.19.25.03;	author schwarze;	state Exp;
branches;
next	1.55;
commitid	1m1y3OocNVYDnyZE;

1.55
date	2014.10.28.13.22.57;	author schwarze;	state Exp;
branches;
next	1.54;
commitid	KVARFxH9JPv3WrlG;

1.54
date	2014.10.13.17.16.25;	author schwarze;	state Exp;
branches;
next	1.53;
commitid	jpiiMiQjvkBFydXP;

1.53
date	2014.08.18.13.25.54;	author schwarze;	state Exp;
branches;
next	1.52;
commitid	2D3T1LRf8eUgSud4;

1.52
date	2014.07.06.19.08.56;	author schwarze;	state Exp;
branches;
next	1.51;
commitid	rolX8OitNNoUBJoD;

1.51
date	2014.07.06.18.36.49;	author schwarze;	state Exp;
branches;
next	1.50;
commitid	jn2zhnL4VZSN5epY;

1.50
date	2014.07.01.22.36.35;	author schwarze;	state Exp;
branches;
next	1.49;
commitid	6SNWblzmBTWk9YRA;

1.49
date	2014.06.20.17.23.09;	author schwarze;	state Exp;
branches;
next	1.48;
commitid	gTaF7NL9JpgvI2ni;

1.48
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2014.04.08.01.36.50;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2014.04.07.17.50.43;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2013.12.30.18.27.15;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2013.12.30.00.52.18;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2013.12.26.02.55.35;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2013.12.25.22.45.16;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2013.12.25.00.50.03;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2013.11.10.20.17.14;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2013.10.05.21.17.29;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2013.08.08.20.07.24;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2013.06.20.22.29.38;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2012.07.07.18.27.36;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2012.05.28.22.45.33;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2012.05.28.17.08.48;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2012.05.28.13.00.51;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2011.11.17.11.58.11;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2011.11.12.22.31.22;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2011.10.24.20.29.21;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2011.03.15.03.03.49;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2011.03.07.01.35.33;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2011.01.03.22.27.21;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.27.21.25.28;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.13.22.04.01;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2010.08.20.00.53.35;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2010.08.18.02.38.40;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.16.00.34.33;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.26.17.56.43;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.06.20.30.08;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.26.02.39.58;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.15.15.37.53;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.15.09.20.01;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.14.19.52.43;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.07.23.15.05;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.18.02.11.26;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.12.24.02.08.14;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.23.22.30.17;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.22.15.18.11;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.07.18.14.44.54;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.07.08.00.04.10;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.71
log
@warn about time machines; suggested by Thomas Klausner <wiz @@ NetBSD>
@
text
@/*	$OpenBSD: mandoc.c,v 1.70 2017/06/14 01:31:19 schwarze Exp $ */
/*
 * Copyright (c) 2008-2011, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011-2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "libmandoc.h"

static	int	 a2time(time_t *, const char *, const char *);
static	char	*time2a(time_t);


enum mandoc_esc
mandoc_escape(const char **end, const char **start, int *sz)
{
	const char	*local_start;
	int		 local_sz;
	char		 term;
	enum mandoc_esc	 gly;

	/*
	 * When the caller doesn't provide return storage,
	 * use local storage.
	 */

	if (NULL == start)
		start = &local_start;
	if (NULL == sz)
		sz = &local_sz;

	/*
	 * Beyond the backslash, at least one input character
	 * is part of the escape sequence.  With one exception
	 * (see below), that character won't be returned.
	 */

	gly = ESCAPE_ERROR;
	*start = ++*end;
	*sz = 0;
	term = '\0';

	switch ((*start)[-1]) {
	/*
	 * First the glyphs.  There are several different forms of
	 * these, but each eventually returns a substring of the glyph
	 * name.
	 */
	case '(':
		gly = ESCAPE_SPECIAL;
		*sz = 2;
		break;
	case '[':
		gly = ESCAPE_SPECIAL;
		term = ']';
		break;
	case 'C':
		if ('\'' != **start)
			return ESCAPE_ERROR;
		*start = ++*end;
		gly = ESCAPE_SPECIAL;
		term = '\'';
		break;

	/*
	 * Escapes taking no arguments at all.
	 */
	case 'd':
	case 'u':
	case ',':
	case '/':
		return ESCAPE_IGNORE;
	case 'p':
		return ESCAPE_BREAK;

	/*
	 * The \z escape is supposed to output the following
	 * character without advancing the cursor position.
	 * Since we are mostly dealing with terminal mode,
	 * let us just skip the next character.
	 */
	case 'z':
		return ESCAPE_SKIPCHAR;

	/*
	 * Handle all triggers matching \X(xy, \Xx, and \X[xxxx], where
	 * 'X' is the trigger.  These have opaque sub-strings.
	 */
	case 'F':
	case 'g':
	case 'k':
	case 'M':
	case 'm':
	case 'n':
	case 'V':
	case 'Y':
		gly = ESCAPE_IGNORE;
		/* FALLTHROUGH */
	case 'f':
		if (ESCAPE_ERROR == gly)
			gly = ESCAPE_FONT;
		switch (**start) {
		case '(':
			*start = ++*end;
			*sz = 2;
			break;
		case '[':
			*start = ++*end;
			term = ']';
			break;
		default:
			*sz = 1;
			break;
		}
		break;

	/*
	 * These escapes are of the form \X'Y', where 'X' is the trigger
	 * and 'Y' is any string.  These have opaque sub-strings.
	 * The \B and \w escapes are handled in roff.c, roff_res().
	 */
	case 'A':
	case 'b':
	case 'D':
	case 'R':
	case 'X':
	case 'Z':
		gly = ESCAPE_IGNORE;
		/* FALLTHROUGH */
	case 'o':
		if (**start == '\0')
			return ESCAPE_ERROR;
		if (gly == ESCAPE_ERROR)
			gly = ESCAPE_OVERSTRIKE;
		term = **start;
		*start = ++*end;
		break;

	/*
	 * These escapes are of the form \X'N', where 'X' is the trigger
	 * and 'N' resolves to a numerical expression.
	 */
	case 'h':
	case 'H':
	case 'L':
	case 'l':
	case 'S':
	case 'v':
	case 'x':
		if (strchr(" %&()*+-./0123456789:<=>", **start)) {
			if ('\0' != **start)
				++*end;
			return ESCAPE_ERROR;
		}
		switch ((*start)[-1]) {
		case 'h':
			gly = ESCAPE_HORIZ;
			break;
		case 'l':
			gly = ESCAPE_HLINE;
			break;
		default:
			gly = ESCAPE_IGNORE;
			break;
		}
		term = **start;
		*start = ++*end;
		break;

	/*
	 * Special handling for the numbered character escape.
	 * XXX Do any other escapes need similar handling?
	 */
	case 'N':
		if ('\0' == **start)
			return ESCAPE_ERROR;
		(*end)++;
		if (isdigit((unsigned char)**start)) {
			*sz = 1;
			return ESCAPE_IGNORE;
		}
		(*start)++;
		while (isdigit((unsigned char)**end))
			(*end)++;
		*sz = *end - *start;
		if ('\0' != **end)
			(*end)++;
		return ESCAPE_NUMBERED;

	/*
	 * Sizes get a special category of their own.
	 */
	case 's':
		gly = ESCAPE_IGNORE;

		/* See +/- counts as a sign. */
		if ('+' == **end || '-' == **end || ASCII_HYPH == **end)
			*start = ++*end;

		switch (**end) {
		case '(':
			*start = ++*end;
			*sz = 2;
			break;
		case '[':
			*start = ++*end;
			term = ']';
			break;
		case '\'':
			*start = ++*end;
			term = '\'';
			break;
		case '3':
		case '2':
		case '1':
			*sz = (*end)[-1] == 's' &&
			    isdigit((unsigned char)(*end)[1]) ? 2 : 1;
			break;
		default:
			*sz = 1;
			break;
		}

		break;

	/*
	 * Anything else is assumed to be a glyph.
	 * In this case, pass back the character after the backslash.
	 */
	default:
		gly = ESCAPE_SPECIAL;
		*start = --*end;
		*sz = 1;
		break;
	}

	assert(ESCAPE_ERROR != gly);

	/*
	 * Read up to the terminating character,
	 * paying attention to nested escapes.
	 */

	if ('\0' != term) {
		while (**end != term) {
			switch (**end) {
			case '\0':
				return ESCAPE_ERROR;
			case '\\':
				(*end)++;
				if (ESCAPE_ERROR ==
				    mandoc_escape(end, NULL, NULL))
					return ESCAPE_ERROR;
				break;
			default:
				(*end)++;
				break;
			}
		}
		*sz = (*end)++ - *start;
	} else {
		assert(*sz > 0);
		if ((size_t)*sz > strlen(*start))
			return ESCAPE_ERROR;
		*end += *sz;
	}

	/* Run post-processors. */

	switch (gly) {
	case ESCAPE_FONT:
		if (2 == *sz) {
			if ('C' == **start) {
				/*
				 * Treat constant-width font modes
				 * just like regular font modes.
				 */
				(*start)++;
				(*sz)--;
			} else {
				if ('B' == (*start)[0] && 'I' == (*start)[1])
					gly = ESCAPE_FONTBI;
				break;
			}
		} else if (1 != *sz)
			break;

		switch (**start) {
		case '3':
		case 'B':
			gly = ESCAPE_FONTBOLD;
			break;
		case '2':
		case 'I':
			gly = ESCAPE_FONTITALIC;
			break;
		case 'P':
			gly = ESCAPE_FONTPREV;
			break;
		case '1':
		case 'R':
			gly = ESCAPE_FONTROMAN;
			break;
		}
		break;
	case ESCAPE_SPECIAL:
		if (1 == *sz && 'c' == **start)
			gly = ESCAPE_NOSPACE;
		/*
		 * Unicode escapes are defined in groff as \[u0000]
		 * to \[u10FFFF], where the contained value must be
		 * a valid Unicode codepoint.  Here, however, only
		 * check the length and range.
		 */
		if (**start != 'u' || *sz < 5 || *sz > 7)
			break;
		if (*sz == 7 && ((*start)[1] != '1' || (*start)[2] != '0'))
			break;
		if (*sz == 6 && (*start)[1] == '0')
			break;
		if (*sz == 5 && (*start)[1] == 'D' &&
		    strchr("89ABCDEF", (*start)[2]) != NULL)
			break;
		if ((int)strspn(*start + 1, "0123456789ABCDEFabcdef")
		    + 1 == *sz)
			gly = ESCAPE_UNICODE;
		break;
	default:
		break;
	}

	return gly;
}

/*
 * Parse a quoted or unquoted roff-style request or macro argument.
 * Return a pointer to the parsed argument, which is either the original
 * pointer or advanced by one byte in case the argument is quoted.
 * NUL-terminate the argument in place.
 * Collapse pairs of quotes inside quoted arguments.
 * Advance the argument pointer to the next argument,
 * or to the NUL byte terminating the argument line.
 */
char *
mandoc_getarg(struct mparse *parse, char **cpp, int ln, int *pos)
{
	char	 *start, *cp;
	int	  quoted, pairs, white;

	/* Quoting can only start with a new word. */
	start = *cpp;
	quoted = 0;
	if ('"' == *start) {
		quoted = 1;
		start++;
	}

	pairs = 0;
	white = 0;
	for (cp = start; '\0' != *cp; cp++) {

		/*
		 * Move the following text left
		 * after quoted quotes and after "\\" and "\t".
		 */
		if (pairs)
			cp[-pairs] = cp[0];

		if ('\\' == cp[0]) {
			/*
			 * In copy mode, translate double to single
			 * backslashes and backslash-t to literal tabs.
			 */
			switch (cp[1]) {
			case 't':
				cp[0] = '\t';
				/* FALLTHROUGH */
			case '\\':
				pairs++;
				cp++;
				break;
			case ' ':
				/* Skip escaped blanks. */
				if (0 == quoted)
					cp++;
				break;
			default:
				break;
			}
		} else if (0 == quoted) {
			if (' ' == cp[0]) {
				/* Unescaped blanks end unquoted args. */
				white = 1;
				break;
			}
		} else if ('"' == cp[0]) {
			if ('"' == cp[1]) {
				/* Quoted quotes collapse. */
				pairs++;
				cp++;
			} else {
				/* Unquoted quotes end quoted args. */
				quoted = 2;
				break;
			}
		}
	}

	/* Quoted argument without a closing quote. */
	if (1 == quoted)
		mandoc_msg(MANDOCERR_ARG_QUOTE, parse, ln, *pos, NULL);

	/* NUL-terminate this argument and move to the next one. */
	if (pairs)
		cp[-pairs] = '\0';
	if ('\0' != *cp) {
		*cp++ = '\0';
		while (' ' == *cp)
			cp++;
	}
	*pos += (int)(cp - start) + (quoted ? 1 : 0);
	*cpp = cp;

	if ('\0' == *cp && (white || ' ' == cp[-1]))
		mandoc_msg(MANDOCERR_SPACE_EOL, parse, ln, *pos, NULL);

	return start;
}

static int
a2time(time_t *t, const char *fmt, const char *p)
{
	struct tm	 tm;
	char		*pp;

	memset(&tm, 0, sizeof(struct tm));

	pp = strptime(p, fmt, &tm);
	if (NULL != pp && '\0' == *pp) {
		*t = mktime(&tm);
		return 1;
	}

	return 0;
}

static char *
time2a(time_t t)
{
	struct tm	*tm;
	char		*buf, *p;
	size_t		 ssz;
	int		 isz;

	tm = localtime(&t);
	if (tm == NULL)
		return NULL;

	/*
	 * Reserve space:
	 * up to 9 characters for the month (September) + blank
	 * up to 2 characters for the day + comma + blank
	 * 4 characters for the year and a terminating '\0'
	 */

	p = buf = mandoc_malloc(10 + 4 + 4 + 1);

	if ((ssz = strftime(p, 10 + 1, "%B ", tm)) == 0)
		goto fail;
	p += (int)ssz;

	/*
	 * The output format is just "%d" here, not "%2d" or "%02d".
	 * That's also the reason why we can't just format the
	 * date as a whole with "%B %e, %Y" or "%B %d, %Y".
	 * Besides, the present approach is less prone to buffer
	 * overflows, in case anybody should ever introduce the bug
	 * of looking at LC_TIME.
	 */

	if ((isz = snprintf(p, 4 + 1, "%d, ", tm->tm_mday)) == -1)
		goto fail;
	p += isz;

	if (strftime(p, 4 + 1, "%Y", tm) == 0)
		goto fail;
	return buf;

fail:
	free(buf);
	return NULL;
}

char *
mandoc_normdate(struct roff_man *man, char *in, int ln, int pos)
{
	char		*cp;
	time_t		 t;

	/* No date specified: use today's date. */

	if (in == NULL || *in == '\0' || strcmp(in, "$" "Mdocdate$") == 0) {
		mandoc_msg(MANDOCERR_DATE_MISSING, man->parse, ln, pos, NULL);
		return time2a(time(NULL));
	}

	/* Valid mdoc(7) date format. */

	if (a2time(&t, "$" "Mdocdate: %b %d %Y $", in) ||
	    a2time(&t, "%b %d, %Y", in)) {
		cp = time2a(t);
		if (t > time(NULL) + 86400)
			mandoc_msg(MANDOCERR_DATE_FUTURE, man->parse,
			    ln, pos, cp);
		return cp;
	}

	/* In man(7), do not warn about the legacy format. */

	if (a2time(&t, "%Y-%m-%d", in) == 0)
		mandoc_msg(MANDOCERR_DATE_BAD, man->parse, ln, pos, in);
	else if (t > time(NULL) + 86400)
		mandoc_msg(MANDOCERR_DATE_FUTURE, man->parse, ln, pos, in);
	else if (man->macroset == MACROSET_MDOC)
		mandoc_vmsg(MANDOCERR_DATE_LEGACY, man->parse,
		    ln, pos, "Dd %s", in);

	/* Use any non-mdoc(7) date verbatim. */

	return mandoc_strdup(in);
}

int
mandoc_eos(const char *p, size_t sz)
{
	const char	*q;
	int		 enclosed, found;

	if (0 == sz)
		return 0;

	/*
	 * End-of-sentence recognition must include situations where
	 * some symbols, such as `)', allow prior EOS punctuation to
	 * propagate outward.
	 */

	enclosed = found = 0;
	for (q = p + (int)sz - 1; q >= p; q--) {
		switch (*q) {
		case '\"':
		case '\'':
		case ']':
		case ')':
			if (0 == found)
				enclosed = 1;
			break;
		case '.':
		case '!':
		case '?':
			found = 1;
			break;
		default:
			return found &&
			    (!enclosed || isalnum((unsigned char)*q));
		}
	}

	return found && !enclosed;
}

/*
 * Convert a string to a long that may not be <0.
 * If the string is invalid, or is less than 0, return -1.
 */
int
mandoc_strntoi(const char *p, size_t sz, int base)
{
	char		 buf[32];
	char		*ep;
	long		 v;

	if (sz > 31)
		return -1;

	memcpy(buf, p, sz);
	buf[(int)sz] = '\0';

	errno = 0;
	v = strtol(buf, &ep, base);

	if (buf[0] == '\0' || *ep != '\0')
		return -1;

	if (v > INT_MAX)
		v = INT_MAX;
	if (v < INT_MIN)
		v = INT_MIN;

	return (int)v;
}
@


1.70
log
@implement the roff(7) \p (break output line) escape sequence
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.69 2017/06/11 19:36:31 schwarze Exp $ */
d521 1
d534 7
a540 2
	    a2time(&t, "%b %d, %Y", in))
		return time2a(t);
d546 2
@


1.69
log
@Style message about legacy man(7) date format in mdoc(7) documents
and operating system dependent messages about missing or unexpected
Mdocdate; inspired by mdoclint(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.68 2017/06/02 19:21:03 schwarze Exp $ */
d97 2
@


1.68
log
@Partial implementation of \h (horizontal line drawing function).
A full implementation would require access to output device properties
and state variables (both only available after the main parser has
finalized the parse tree) before numerical expansions in the roff
preprocessor (i.e., before the main parser is even started).

Not trying to pull that stunt right now because the static-width
implementation committed here is sufficient for tcl-style manual pages
and already more complicated than i would have suspected.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.67 2017/06/01 19:05:15 schwarze Exp $ */
d29 1
d31 1
a31 1
#include "mandoc_aux.h"
d517 1
a517 1
mandoc_normdate(struct mparse *parse, char *in, int ln, int pos)
d524 1
a524 1
		mandoc_msg(MANDOCERR_DATE_MISSING, parse, ln, pos, NULL);
d534 1
a534 1
	/* Do not warn about the legacy man(7) format. */
d536 5
a540 2
	if ( ! a2time(&t, "%Y-%m-%d", in))
		mandoc_msg(MANDOCERR_DATE_BAD, parse, ln, pos, in);
@


1.67
log
@Minimal implementation of the \h (horizontal motion) escape sequence.
Good enough to cope with the average DocBook insanity.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.66 2015/11/12 22:43:30 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011-2015 Ingo Schwarze <schwarze@@openbsd.org>
d176 11
a186 1
		gly = (*start)[-1] == 'h' ? ESCAPE_HORIZ : ESCAPE_IGNORE;
@


1.66
log
@Simplify the logic in mandoc_normdate() and add some comments.
Also add a comment in time2a() explaining why it isn't possible
to use just one single call to strftime().
Do some style cleanup while here.
No functional change.
Triggered by a very different patch from des@@FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.65 2015/10/15 23:35:38 schwarze Exp $ */
d176 1
a176 1
		gly = ESCAPE_IGNORE;
@


1.65
log
@Delete two preprocessor constants that are no longer used.
Patch from Michael Reed <m dot reed at mykolab dot com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.64 2015/10/13 23:30:42 schwarze Exp $ */
d476 1
d479 1
a479 1
	if (0 == (ssz = strftime(p, 10 + 1, "%B ", tm)))
d483 10
a492 1
	if (-1 == (isz = snprintf(p, 4 + 1, "%d, ", tm->tm_mday)))
d496 1
a496 1
	if (0 == strftime(p, 4 + 1, "%Y", tm))
a507 1
	char		*out;
d510 3
a512 2
	if (NULL == in || '\0' == *in ||
	    0 == strcmp(in, "$" "Mdocdate$")) {
d514 1
a514 1
		time(&t);
d516 10
a525 4
	else if (a2time(&t, "%Y-%m-%d", in))
		t = 0;
	else if (!a2time(&t, "$" "Mdocdate: %b %d %Y $", in) &&
	    !a2time(&t, "%b %d, %Y", in)) {
d527 4
a530 4
		t = 0;
	}
	out = t ? time2a(t) : NULL;
	return out ? out : mandoc_strdup(in);
@


1.64
log
@Reject the escape sequences \[uD800] to \[uDFFF] in the parser.
These surrogates are not valid Unicode codepoints,
so treat them just like any other undefined character escapes:
Warn about them and do not produce output.
Issue noticed while talking to stsp@@, semarie@@, and bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.63 2015/10/12 00:07:27 schwarze Exp $ */
a31 2

#define DATESIZE 32
@


1.63
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.62 2015/10/06 18:30:43 schwarze Exp $ */
d333 3
@


1.62
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.61 2015/08/29 22:39:59 schwarze Exp $ */
a93 1
		/* FALLTHROUGH */
a94 1
		/* FALLTHROUGH */
a95 1
		/* FALLTHROUGH */
a112 1
		/* FALLTHROUGH */
a113 1
		/* FALLTHROUGH */
a114 1
		/* FALLTHROUGH */
a115 1
		/* FALLTHROUGH */
a116 1
		/* FALLTHROUGH */
a117 1
		/* FALLTHROUGH */
a118 1
		/* FALLTHROUGH */
a145 1
		/* FALLTHROUGH */
a146 1
		/* FALLTHROUGH */
a147 1
		/* FALLTHROUGH */
a148 1
		/* FALLTHROUGH */
a149 1
		/* FALLTHROUGH */
a166 1
		/* FALLTHROUGH */
a167 1
		/* FALLTHROUGH */
a168 1
		/* FALLTHROUGH */
a169 1
		/* FALLTHROUGH */
a170 1
		/* FALLTHROUGH */
a171 1
		/* FALLTHROUGH */
a226 1
			/* FALLTHROUGH */
a227 1
			/* FALLTHROUGH */
a302 1
			/* FALLTHROUGH */
a306 1
			/* FALLTHROUGH */
a313 1
			/* FALLTHROUGH */
a534 1
			/* FALLTHROUGH */
a535 1
			/* FALLTHROUGH */
a536 1
			/* FALLTHROUGH */
a541 1
			/* FALLTHROUGH */
a542 1
			/* FALLTHROUGH */
@


1.61
log
@Parse and ignore the escape sequences \, and \/ (italic corrections).
Actually using these is very stupid because they are groff extensions
and other roff(7) implementations typically print unintended characters
at the places where they are used.
Nevertheless, some manuals contain them, for example ocserv(8).
Problem reported by Kurt Jaeger <pi at FreeBSD>.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.60 2015/02/20 23:51:54 schwarze Exp $ */
d84 1
a84 1
			return(ESCAPE_ERROR);
d100 1
a100 1
		return(ESCAPE_IGNORE);
d109 1
a109 1
		return(ESCAPE_SKIPCHAR);
d170 1
a170 1
			return(ESCAPE_ERROR);
d197 1
a197 1
			return(ESCAPE_ERROR);
d210 1
a210 1
			return(ESCAPE_ERROR);
d214 1
a214 1
			return(ESCAPE_IGNORE);
d222 1
a222 1
		return(ESCAPE_NUMBERED);
d284 1
a284 1
				return(ESCAPE_ERROR);
d289 1
a289 1
					return(ESCAPE_ERROR);
d300 1
a300 1
			return(ESCAPE_ERROR);
d368 1
a368 1
	return(gly);
d463 1
a463 1
	return(start);
d477 1
a477 1
		return(1);
d480 1
a480 1
	return(0);
d493 1
a493 1
		return(NULL);
d513 1
a513 1
	return(buf);
d517 1
a517 1
	return(NULL);
d539 1
a539 1
	return(out ? out : mandoc_strdup(in));
d549 1
a549 1
		return(0);
d578 2
a579 1
			return(found && (!enclosed || isalnum((unsigned char)*q)));
d583 1
a583 1
	return(found && !enclosed);
d598 1
a598 1
		return(-1);
d607 1
a607 1
		return(-1);
d614 1
a614 1
	return((int)v);
@


1.60
log
@For selecting a two-digit font size, support the historic syntax \s12
in addition to the classic syntax \s(12, the modern syntax \s[12],
and the alternative syntax \s'12'.  The historic syntax only works
for the font sizes 10-39.
Real-world usage found by naddy@@ in plan9/rc.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.59 2015/01/21 20:20:49 schwarze Exp $ */
d96 4
@


1.59
log
@Rudimentary implementation of the roff(7) \o escape sequence (overstrike).
This is of some relevance because the pod2man(1) preamble abuses it
for the icelandic letter Thorn, instead of simply using \(TP and \(Tp.
Missing feature found by sthen@@ in DateTime::Locale::is_IS(3p).
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.58 2015/01/01 18:10:09 schwarze Exp $ */
d242 8
@


1.58
log
@Fix a read buffer overrun triggered by trailing \s- or trailing \s+
without the required subsequent argument; found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.57 2014/12/15 17:29:58 schwarze Exp $ */
a156 2
	case 'o':
		/* FALLTHROUGH */
d162 4
a165 1
		if ('\0' == **start)
d167 2
a168 1
		gly = ESCAPE_IGNORE;
@


1.57
log
@Catch localtime() failure for additional safety;
patch from Jan Stary <hans at stare dot cz> some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: mandoc.c,v 1.56 2014/11/28 19:25:03 schwarze Exp $ */
d3 2
a4 2
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011, 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d226 1
a226 1
			(*end)++;
@


1.56
log
@Add some missing OpenBSD RCS markers
and a few missing <sys/types.h> inclusions; no code change.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d478 2
@


1.55
log
@Tighten Unicode escape name parsing.
Accept only 0xXXXX, 0xYXXXX, 0x10XXXX with Y != 0.
This simplifies mchars_num2uc().
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.54 2014/10/13 17:16:25 schwarze Exp $ */
@


1.54
log
@Stricter syntax checking of Unicode character names:
Require exactly 4, 5 or 6 hex digits and allow nothing else.
This avoids mishandling stuff like \[ua] and \C'uA' as Unicode
and also fixes underlining in eqn(7) -Thtml output which uses \[ul].
Problem found and semantics suggested by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.53 2014/08/18 13:25:54 schwarze Exp $ */
d335 1
a335 1
		 * Unicode escapes are defined in groff as \[uXXXX]
d338 1
a338 1
		 * check the length and the validity of all digits.
d340 7
a346 2
		else if (*sz > 4 && *sz < 8 && **start == 'u' &&
		    (int)strspn(*start + 1, "0123456789ABCDEFabcdef")
@


1.53
log
@kristaps@@ found this with valgrind, merge his patch from bsd.lv:
Fix a corner case where \H<nil> (where <nil> is the \0 character) would
cause mandoc_escape() to read past the end of an allocated string.
Found when a script scanning of all Mac OSX manuals accidentally also
scanned binary (gzip'd) files, discussed with schwarze@@ on tech@@mdocml.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.86 2014/08/18 09:11:47 kristaps Exp $ */
a79 8
		/*
		 * Unicode escapes are defined in groff as \[uXXXX] to
		 * \[u10FFFF], where the contained value must be a valid
		 * Unicode codepoint.  Here, however, only check whether
		 * it's not a zero-width escape.
		 */
		if ('u' == (*start)[0] && ']' != (*start)[1])
			gly = ESCAPE_UNICODE;
d86 1
a86 4
		if ('u' == (*start)[0] && '\'' != (*start)[1])
			gly = ESCAPE_UNICODE;
		else
			gly = ESCAPE_SPECIAL;
d334 10
@


1.52
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.51 2014/07/06 18:36:49 schwarze Exp $ */
d200 2
a201 1
			++*end;
@


1.51
log
@Fix handling of escape sequences taking numeric arguments.
* Repair detection of invalid delimiters.
* Discard the invalid delimiter together with the invalid sequence.

Note to self: In general, strchr("\0...", c) is a thoroughly bad idea.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.50 2014/07/01 22:36:35 schwarze Exp $ */
d428 1
a428 1
		mandoc_msg(MANDOCERR_BADQUOTE, parse, ln, *pos, NULL);
d442 1
a442 1
		mandoc_msg(MANDOCERR_EOLNSPACE, parse, ln, *pos, NULL);
@


1.50
log
@Clean up the warnings related to document structure.
* Hierarchical naming of the related enum mandocerr items.
* Mention the offending macro, section title, or string.
While here, improve some wordings:
* Descriptive instead of imperative style.
* Uniform style for "missing" and "skipping".
* Where applicable, mention the fallback used.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.49 2014/06/20 17:23:09 schwarze Exp $ */
d199 2
a200 1
		if (strchr("\0 %&()*+-./0123456789:<=>", **start))
d202 1
@


1.49
log
@Start systematic improvements of error reporting.
So far, this covers all WARNINGs related to the prologue.

1) hierarchical naming of MANDOCERR_* constants
2) mention the macro name in messages where that adds clarity
3) add one missing MANDOCERR_DATE_MISSING msg
4) fix the wording of one message related to the man(7) prologue

Started on the plane back from Ottawa.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.48 2014/04/20 16:44:44 schwarze Exp $ */
d512 1
a512 1
		mandoc_msg(MANDOCERR_DATE_BAD, parse, ln, pos, NULL);
@


1.48
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.47 2014/04/08 01:36:50 schwarze Exp $ */
d505 1
a505 1
		mandoc_msg(MANDOCERR_NODATE, parse, ln, pos, NULL);
d512 1
a512 1
		mandoc_msg(MANDOCERR_BADDATE, parse, ln, pos, NULL);
@


1.47
log
@Fully implement the \B (validate numerical expression) and
partially implement the \w (measure text width) escape sequence
in a way that makes them usable in numerical expressions and in
conditional requests, similar to how \n (interpolate number register)
and \* (expand user-defined string) are implemented.

This lets mandoc(1) handle the baroque low-level roff code
found at the beginning of the ggrep(1) manual.
Thanks to pascal@@ for the report.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.46 2014/04/07 17:50:43 schwarze Exp $ */
d45 1
a45 1
	enum mandoc_esc	 gly; 
d74 1
a74 1
	case ('('):
d78 1
a78 1
	case ('['):
d90 1
a90 1
	case ('C'):
d104 1
a104 1
	case ('d'):
d106 1
a106 1
	case ('u'):
d111 1
a111 1
	 * character without advancing the cursor position.  
d115 1
a115 1
	case ('z'):
d122 1
a122 1
	case ('F'):
d124 1
a124 1
	case ('g'):
d126 1
a126 1
	case ('k'):
d128 1
a128 1
	case ('M'):
d130 1
a130 1
	case ('m'):
d132 1
a132 1
	case ('n'):
d134 1
a134 1
	case ('V'):
d136 1
a136 1
	case ('Y'):
d139 1
a139 1
	case ('f'):
d143 1
a143 1
		case ('('):
d147 1
a147 1
		case ('['):
d162 1
a162 1
	case ('A'):
d164 1
a164 1
	case ('b'):
d166 1
a166 1
	case ('D'):
d168 1
a168 1
	case ('o'):
d170 1
a170 1
	case ('R'):
d172 1
a172 1
	case ('X'):
d174 1
a174 1
	case ('Z'):
d186 1
a186 1
	case ('h'):
d188 1
a188 1
	case ('H'):
d190 1
a190 1
	case ('L'):
d192 1
a192 1
	case ('l'):
d194 1
a194 1
	case ('S'):
d196 1
a196 1
	case ('v'):
d198 1
a198 1
	case ('x'):
d210 1
a210 1
	case ('N'):
d226 1
a226 1
	/* 
d229 1
a229 1
	case ('s'):
d237 1
a237 1
		case ('('):
d241 1
a241 1
		case ('['):
d245 1
a245 1
		case ('\''):
d277 1
a277 1
			case ('\0'):
d279 1
a279 1
			case ('\\'):
d301 1
a301 1
	case (ESCAPE_FONT):
d319 1
a319 1
		case ('3'):
d321 1
a321 1
		case ('B'):
d324 1
a324 1
		case ('2'):
d326 1
a326 1
		case ('I'):
d329 1
a329 1
		case ('P'):
d332 1
a332 1
		case ('1'):
d334 1
a334 1
		case ('R'):
d339 1
a339 1
	case (ESCAPE_SPECIAL):
d371 1
a371 1
	} 
d390 1
a390 1
			case ('t'):
d393 1
a393 1
			case ('\\'):
d397 1
a397 1
			case (' '):
d537 1
a537 1
		case ('\"'):
d539 1
a539 1
		case ('\''):
d541 1
a541 1
		case (']'):
d543 1
a543 1
		case (')'):
d547 1
a547 1
		case ('.'):
d549 1
a549 1
		case ('!'):
d551 1
a551 1
		case ('?'):
@


1.46
log
@Accept arbitrary argument delimiters for various roff(7) escape sequences.
Needed for example by the new Perl pod2man(1) preamble.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.45 2014/03/21 22:17:01 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d160 1
a165 2
	case ('B'):
		/* FALLTHROUGH */
a170 2
		/* FALLTHROUGH */
	case ('w'):
@


1.45
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.44 2013/12/30 18:27:15 schwarze Exp $ */
d178 1
a178 1
		if ('\'' != **start)
d181 1
a182 1
		term = '\'';
d202 1
a202 1
		if ('\'' != **start)
d205 1
a206 1
		term = '\'';
@


1.44
log
@Remove duplicate const specifiers from the declaration of mandoc_escape().
Found by Thomas Klausner <wiz at NetBSD dot org> using clang.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.43 2013/12/30 00:52:18 schwarze Exp $ */
d30 1
a350 68
}

void *
mandoc_calloc(size_t num, size_t size)
{
	void		*ptr;

	ptr = calloc(num, size);
	if (NULL == ptr) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}

	return(ptr);
}


void *
mandoc_malloc(size_t size)
{
	void		*ptr;

	ptr = malloc(size);
	if (NULL == ptr) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}

	return(ptr);
}


void *
mandoc_realloc(void *ptr, size_t size)
{

	ptr = realloc(ptr, size);
	if (NULL == ptr) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}

	return(ptr);
}

char *
mandoc_strndup(const char *ptr, size_t sz)
{
	char		*p;

	p = mandoc_malloc(sz + 1);
	memcpy(p, ptr, sz);
	p[(int)sz] = '\0';
	return(p);
}

char *
mandoc_strdup(const char *ptr)
{
	char		*p;

	p = strdup(ptr);
	if (NULL == p) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}

	return(p);
@


1.43
log
@Simplify: Remove an unused argument from the mandoc_eos() function.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.42 2013/12/26 02:55:35 schwarze Exp $ */
d39 1
a39 1
mandoc_escape(const char const **end, const char const **start, int *sz)
@


1.42
log
@I have no idea how it happened that \B, \H, \h, \L, and \l got
mapped to ESCAPE_NUMBERED (which is for \N and only for \N), that
made no sense at all.  Properly remap them to ESCAPE_IGNORE.

While here, move \B and \w from the group taking number arguments
to the group taking string arguments; right now, that doesn't imply
any functional change, but if we ever go ahead and implement a
parser for roff(7) numerical expressions, it will suddenly start
to matter, and cause confusion.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.41 2013/12/25 22:45:16 schwarze Exp $ */
d590 1
a590 1
mandoc_eos(const char *p, size_t sz, int enclosed)
d592 2
a593 2
	const char *q;
	int found;
d604 1
a604 1
	found = 0;
@


1.41
log
@Parse and ignore the roff(7) escape sequences \d (move half line down)
und \u (move half line up).  Found by bentley@@ in some DocBook crap.
Surprisingly, these two do actually occur in our terminfo(5),
so this patch reduces groff-mandoc differences in base by 0.03%.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.40 2013/12/25 00:50:03 schwarze Exp $ */
d164 2
d172 2
a187 2
	case ('B'):
		/* FALLTHROUGH */
a194 1
		gly = ESCAPE_NUMBERED;
a199 2
	case ('w'):
		/* FALLTHROUGH */
d203 1
a203 2
		if (ESCAPE_ERROR == gly)
			gly = ESCAPE_IGNORE;
@


1.40
log
@s/[Nn]ull/NUL/ in comments where appropriate;
suggested by Thomas Klausner <wiz @@ NetBSD dot org>.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.39 2013/11/10 20:17:14 schwarze Exp $ */
d99 8
@


1.39
log
@Support the alternative syntax \C'uXXXX' for Unicode characters.
It is already documented in the Heirloom troff manual,
and groff handles it as well.

Bug reported by Bjarni Ingi Gislason <bjarniig at rhi dot hi dot is>
on <bug-groff at gnu dot org>.  Well, admittedly, that bug was reported
against groff, but mandoc was even more broken than groff with respect
to this syntax...
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.38 2013/10/05 21:17:29 schwarze Exp $ */
d418 1
a418 1
 * Null-terminate the argument in place.
d421 1
a421 1
 * or to the null byte terminating the argument line.
d492 1
a492 1
	/* Null-terminate this argument and move to the next one. */
@


1.38
log
@Cleanup suggested by gcc-4.8.1, following hints by Christos Zoulas:
- avoid bad qualifier casting in roff.c, roff_parsetext()
  by changing the mandoc_escape arguments to "const char const **"
- avoid bad qualifier casting in mandocdb.c, index_merge()
- garbage collect a few unused variables elsewhere
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.37 2013/08/08 20:07:24 schwarze Exp $ */
a91 1
		gly = ESCAPE_SPECIAL;
d93 4
@


1.37
log
@Implement the roff(7) font-escape sequence \f(BI "bold+italic".
This improves the formatting of about 40 base manuals
and reduces groff-mandoc formatting differences in base by about 5%.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.36 2013/06/20 22:29:38 schwarze Exp $ */
d39 1
a39 1
mandoc_escape(const char **end, const char **start, int *sz)
@


1.36
log
@Improve handling of the roff(7) "\t" escape sequence:
* Parsing macro arguments has to be done in copy mode,
  which implies replacing "\t" by a literal tab character.
* Otherwise, render "\t" as the empty string, not as a 't' character.

This fixes formatting of the distfile example in the oldrdist(1) manual.
This also shows up in the unzip(1) manual as one of several issues
preventing the removal of USE_GROFF from the archivers/unzip port.
Thanks to espie@@ for attracting my attention to the unzip(1) manual.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.35 2012/07/07 18:27:36 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d295 13
a307 7
		/*
		 * Pretend that the constant-width font modes are the
		 * same as the regular font modes.
		 */
		if (2 == *sz && 'C' == **start) {
			(*start)++;
			(*sz)--;
@


1.35
log
@Support the .cc request; code by kristaps@@, tests by me.
Needed for sqlite3(1) as reported by espie@@.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.34 2012/05/28 22:45:33 schwarze Exp $ */
d431 5
a435 1
		/* Move left after quoted quotes and escaped backslashes. */
d438 1
d440 9
a448 2
			if ('\\' == cp[1]) {
				/* Poor man's copy mode. */
d451 2
a452 1
			} else if (0 == quoted && ' ' == cp[1])
d454 6
a459 1
				cp++;
@


1.34
log
@While i already got my fingers dirty on mandoc_escape(),
profit of the occasion to pull out some spaghetti, that is,
three confusing variables and fourteen pointless assignments
among them; instead, always operate on the official pointers
**start, **end, and *sz, each of which conveys an obvious meaning.

No functional change intended, and the new tests confirm that
everything still (err...) "works", as far as that word can be
applied to the kind of roff(7) mock-up code i'm polishing here.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.33 2012/05/28 17:08:48 schwarze Exp $ */
a596 26
}

/*
 * Find out whether a line is a macro line or not.  If it is, adjust the
 * current position and return one; if it isn't, return zero and don't
 * change the current position.
 */
int
mandoc_getcontrol(const char *cp, int *ppos)
{
	int		pos;

	pos = *ppos;

	if ('\\' == cp[pos] && '.' == cp[pos + 1])
		pos += 2;
	else if ('.' == cp[pos] || '\'' == cp[pos])
		pos++;
	else
		return(0);

	while (' ' == cp[pos] || '\t' == cp[pos])
		pos++;

	*ppos = pos;
	return(1);
@


1.33
log
@Make recursive parsing of roff(7) escapes actually work in the general case,
in particular when the inner escapes are preceded or followed by other terms.
While doing so, remove lots of bogus code that was trying to make pointless
distinctions between numeric and non-numeric escape sequences, while both
actually share the same syntax and we ignore the semantics anyway.

This prevents some of the strings defined in the pod2man(1) preamble
from producing garbage output, in particular in scandinavian words.
Of course, proper rendering of scandinavian national characters
cannot be expected even with these fixes.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.32 2012/05/28 13:00:51 schwarze Exp $ */
d41 3
a43 3
	char		 c, term;
	int		 i, rlim;
	const char	*cp, *rstart;
d46 16
a61 5
	cp = *end;
	rstart = cp;
	if (start)
		*start = rstart;
	i = rlim = 0;
d63 2
d67 1
a67 1
	switch ((c = cp[i++])) {
d75 1
a75 1
		rlim = 2;
d85 1
a85 1
		if ('u' == cp[i] && ']' != cp[i + 1])
d90 1
a90 1
		if ('\'' != cp[i])
d93 1
a103 1
		(*end)++;
d130 1
a130 6

		rstart= &cp[i];
		if (start) 
			*start = rstart;

		switch (cp[i++]) {
d132 2
a133 1
			rlim = 2;
d136 1
d140 1
a140 2
			rlim = 1;
			i--;
d162 1
a162 1
		if ('\'' != cp[i++])
d165 1
d191 2
d195 1
a195 2
		if ('\'' != cp[i++])
			return(ESCAPE_ERROR);
d204 1
a204 1
		if ('\0' == cp[i])
d206 3
a208 2
		*end = &cp[++i];
		if (isdigit((unsigned char)cp[i-1]))
d210 2
d214 1
a214 4
		if (start)
			*start = &cp[i];
		if (sz)
			*sz = *end - &cp[i];
a224 4
		rstart = &cp[i];
		if (start) 
			*start = rstart;

d226 2
a227 3
		c = cp[i];
		if ('+' == c || '-' == c || ASCII_HYPH == c)
			++i;
d229 1
a229 1
		switch (cp[i++]) {
d231 2
a232 1
			rlim = 2;
d235 1
d239 1
d243 1
a243 2
			rlim = 1;
			i--;
a246 5
		/* See +/- counts as a sign. */
		c = cp[i];
		if ('+' == c || '-' == c || ASCII_HYPH == c)
			++i;

d251 1
d255 2
a256 2
		rlim = 1;
		i--;
a261 4
	*end = rstart = &cp[i];
	if (start)
		*start = rstart;

d283 1
a283 1
		rlim = (*end)++ - rstart;
d285 2
a286 2
		assert(rlim > 0);
		if ((size_t)rlim > strlen(rstart))
d288 1
a288 1
		*end += rlim;
a289 2
	if (sz)
		*sz = rlim;
d299 4
a302 3
		if (2 == rlim && 'C' == *rstart)
			rstart++;
		else if (1 != rlim)
d305 1
a305 1
		switch (*rstart) {
d327 1
a327 3
		if (1 != rlim)
			break;
		if ('c' == *rstart)
@


1.32
log
@Implement the roff \z escape sequence, intended to output the next
character without advancing the cursor position; implement it to
simply skip the next character, as it will usually be overwritten.

With this change, the pod2man(1) preamble user-defined string \*:,
intended to render as a diaeresis or umlaut diacritic above the
preceding character, is rendered in a slightly less ugly way,
though still not correctly.  It was rendered as "z.." and is now
rendered as ".".

Given that the definition of \*: uses elaborate manual \h positioning,
there is little chance for mandoc(1) to ever render it correctly,
but at least we can refrain from printing out a spurious "z", and
we can make the \z do something semi-reasonable for easier cases.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.31 2011/11/17 11:58:11 schwarze Exp $ */
a35 1
static	int	 numescape(const char *);
a36 57
/*
 * Pass over recursive numerical expressions.  This context of this
 * function is important: it's only called within character-terminating
 * escapes (e.g., \s[xxxyyy]), so all we need to do is handle initial
 * recursion: we don't care about what's in these blocks. 
 * This returns the number of characters skipped or -1 if an error
 * occurs (the caller should bail).
 */
static int
numescape(const char *start)
{
	int		 i;
	size_t		 sz;
	const char	*cp;

	i = 0;

	/* The expression consists of a subexpression. */

	if ('\\' == start[i]) {
		cp = &start[++i];
		/*
		 * Read past the end of the subexpression.
		 * Bail immediately on errors.
		 */
		if (ESCAPE_ERROR == mandoc_escape(&cp, NULL, NULL))
			return(-1);
		return(i + cp - &start[i]);
	} 

	if ('(' != start[i++])
		return(0);

	/*
	 * A parenthesised subexpression.  Read until the closing
	 * parenthesis, making sure to handle any nested subexpressions
	 * that might ruin our parse.
	 */

	while (')' != start[i]) {
		sz = strcspn(&start[i], ")\\");
		i += (int)sz;

		if ('\0' == start[i])
			return(-1);
		else if ('\\' != start[i])
			continue;

		cp = &start[++i];
		if (ESCAPE_ERROR == mandoc_escape(&cp, NULL, NULL))
			return(-1);
		i += cp - &start[i];
	}

	/* Read past the terminating ')'. */
	return(++i);
}
d41 2
a42 2
	char		 c, term, numeric;
	int		 i, lim, ssz, rlim;
d50 1
a50 1
	i = lim = 0;
d52 1
a52 1
	term = numeric = '\0';
d62 1
a62 1
		lim = 2;
d124 1
a124 1
			lim = 2;
d130 1
a130 1
			lim = 1;
d185 1
a185 1
		term = numeric = '\'';
d225 1
a225 1
			lim = 2;
d228 1
a228 1
			term = numeric = ']';
d231 1
a231 1
			term = numeric = '\'';
d234 1
a234 1
			lim = 1;
d251 1
a251 1
		lim = 1;
d258 1
a258 1
	rstart = &cp[i];
d263 2
a264 19
	 * If a terminating block has been specified, we need to
	 * handle the case of recursion, which could have their
	 * own terminating blocks that mess up our parse.  This, by the
	 * way, means that the "start" and "size" values will be
	 * effectively meaningless.
	 */

	ssz = 0;
	if (numeric && -1 == (ssz = numescape(&cp[i])))
		return(ESCAPE_ERROR);

	i += ssz;
	rlim = -1;

	/*
	 * We have a character terminator.  Try to read up to that
	 * character.  If we can't (i.e., we hit the nil), then return
	 * an error; if we can, calculate our length, read past the
	 * terminating character, and exit.
d268 19
a286 2
		*end = strchr(&cp[i], term);
		if ('\0' == *end)
d288 1
a288 6

		rlim = *end - &cp[i];
		if (sz)
			*sz = rlim;
		(*end)++;
		goto out;
a289 13

	assert(lim > 0);

	/*
	 * We have a numeric limit.  If the string is shorter than that,
	 * stop and return an error.  Else adjust our endpoint, length,
	 * and return the current glyph.
	 */

	if ((size_t)lim > strlen(&cp[i]))
		return(ESCAPE_ERROR);

	rlim = lim;
a291 5

	*end = &cp[i] + lim;

out:
	assert(rlim >= 0 && rstart);
@


1.31
log
@ISO style "%Y-%m-%d" dates are common in man(7) .TH.
They have been considered valid in the past, but were reformatted
to the mdoc(7) "Month day, year" style.
To make page footers more similar to groff, no longer reformat them,
just print them as they are.
This doesn't change anything with respect to what's considered valid
or what is warned about.

Putting this in now such that i can improve the unit test suite.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.30 2011/11/12 22:31:22 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
d140 10
@


1.30
log
@Parse and ignore the C font family in \f escapes.
Helps with some real-world manuals that (incorrectly)
assume that the C font family means "constant width".
Suggested by Andreas Vogele, patch by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.29 2011/10/24 20:29:21 schwarze Exp $ */
d619 2
d622 1
a622 2
	    !a2time(&t, "%b %d, %Y", in) &&
	    !a2time(&t, "%Y-%m-%d", in)) {
@


1.29
log
@Handle \N numbered character escapes the same way as groff:
If \N is followed by a digit, ignore \N and the digit.
If \N is followed by a non-digit, the next non-digit
ends the character number; the two delimiters need not match.
Kristaps calls that "gross, but not our fault".

This fixes most of src/regress/usr.bin/mandoc/char/N/basic.in, except
that handling of non-printable characters still differs from groff.

For now, i'm fixing \N only.  Other escapes taking numeric arguments
may or may not need similar handling, but \N is by far the most
important for practical purposes.

ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.28 2011/09/18 15:54:48 schwarze Exp $ */
d368 7
a374 1
		if (1 != rlim)
d376 1
@


1.28
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.27 2011/09/18 10:25:28 schwarze Exp $ */
d160 1
a160 2
		if (ESCAPE_ERROR == gly)
			gly = ESCAPE_IGNORE;
d220 1
a220 4
		/* FALLTHROUGH */
	case ('N'):
		if (ESCAPE_ERROR == gly)
			gly = ESCAPE_NUMBERED;
d235 20
@


1.27
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.26 2011/05/29 21:22:18 schwarze Exp $ */
d553 1
a553 1
	struct tm	 tm;
d558 1
a558 1
	localtime_r(&t, &tm);
d568 1
a568 1
	if (0 == (ssz = strftime(p, 10 + 1, "%B ", &tm)))
d572 1
a572 1
	if (-1 == (isz = snprintf(p, 4 + 1, "%d, ", tm.tm_mday)))
d576 1
a576 1
	if (0 == strftime(p, 4 + 1, "%Y", &tm))
a646 27
}

int
mandoc_hyph(const char *start, const char *c)
{

	/*
	 * Choose whether to break at a hyphenated character.  We only
	 * do this if it's free-standing within a word.
	 */

	/* Skip first/last character of buffer. */
	if (c == start || '\0' == *(c + 1))
		return(0);
	/* Skip first/last character of word. */
	if ('\t' == *(c + 1) || '\t' == *(c - 1))
		return(0);
	if (' ' == *(c + 1) || ' ' == *(c - 1))
		return(0);
	/* Skip double invocations. */
	if ('-' == *(c + 1) || '-' == *(c - 1))
		return(0);
	/* Skip escapes. */
	if ('\\' == *(c - 1))
		return(0);

	return(1);
@


1.26
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.25 2011/04/24 16:22:02 schwarze Exp $ */
d431 10
d707 1
a707 1
mandoc_strntou(const char *p, size_t sz, int base)
d725 4
a728 4
	if ((errno == ERANGE && 
			(v == LONG_MAX || v == LONG_MIN)) ||
			(v > INT_MAX || v < 0))
		return(-1);
a731 1

@


1.25
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.24 2011/04/21 22:59:54 schwarze Exp $ */
d22 2
d36 1
d38 10
a47 2
int
mandoc_special(char *p)
d49 21
a69 7
	int		 len, i;
	char		 term;
	char		*sv;
	
	len = 0;
	term = '\0';
	sv = p;
d71 69
a139 2
	assert('\\' == *p);
	p++;
d141 5
a145 3
	switch (*p++) {
#if 0
	case ('Z'):
d147 1
a147 1
	case ('X'):
d149 1
a149 1
	case ('x'):
d151 1
a151 1
	case ('S'):
d153 1
a153 1
	case ('R'):
d155 1
a155 1
	case ('N'):
d157 1
a157 1
	case ('l'):
d159 3
a161 1
	case ('L'):
d163 27
a189 1
	case ('H'):
d191 1
a191 1
	case ('h'):
d195 1
a195 1
	case ('C'):
d197 1
a197 1
	case ('b'):
d199 1
a199 1
	case ('B'):
d201 4
a204 5
	case ('a'):
		/* FALLTHROUGH */
	case ('A'):
		if (*p++ != '\'')
			return(0);
d207 7
a213 1
#endif
d216 12
d230 13
d244 1
a244 2
		if (ASCII_HYPH == *p)
			*p = '-';
d246 8
a253 5
		i = 0;
		if ('+' == *p || '-' == *p) {
			p++;
			i = 1;
		}
d255 1
a255 1
		switch (*p++) {
d257 1
a257 1
			len = 2;
d260 1
a260 1
			term = ']';
d263 1
a263 1
			term = '\'';
a264 3
		case ('0'):
			i = 1;
			/* FALLTHROUGH */
d266 2
a267 2
			len = 1;
			p--;
d271 71
a341 18
		if (ASCII_HYPH == *p)
			*p = '-';
		if ('+' == *p || '-' == *p) {
			if (i)
				return(0);
			p++;
		} 
		
		/* Handle embedded numerical subexp or escape. */

		if ('(' == *p) {
			while (*p && ')' != *p)
				if ('\\' == *p++) {
					i = mandoc_special(--p);
					if (0 == i)
						return(0);
					p += i;
				}
d343 4
a346 2
			if (')' == *p++)
				break;
d348 1
a348 6
			return(0);
		} else if ('\\' == *p) {
			if (0 == (i = mandoc_special(p)))
				return(0);
			p += i;
		}
d350 14
a363 25
		break;
#if 0
	case ('Y'):
		/* FALLTHROUGH */
	case ('V'):
		/* FALLTHROUGH */
	case ('$'):
		/* FALLTHROUGH */
	case ('n'):
		/* FALLTHROUGH */
#endif
	case ('k'):
		/* FALLTHROUGH */
	case ('M'):
		/* FALLTHROUGH */
	case ('m'):
		/* FALLTHROUGH */
	case ('f'):
		/* FALLTHROUGH */
	case ('F'):
		/* FALLTHROUGH */
	case ('*'):
		switch (*p++) {
		case ('('):
			len = 2;
d365 2
a366 2
		case ('['):
			term = ']';
d368 4
a371 3
		default:
			len = 1;
			p--;
d375 5
a379 2
	case ('('):
		len = 2;
a380 20
	case ('['):
		term = ']';
		break;
	case ('z'):
		len = 1;
		if ('\\' == *p) {
			if (0 == (i = mandoc_special(p)))
				return(0);
			p += i;
			return(*p ? (int)(p - sv) : 0);
		}
		break;
	case ('o'):
		/* FALLTHROUGH */
	case ('w'):
		if ('\'' == *p++) {
			term = '\'';
			break;
		}
		/* FALLTHROUGH */
a381 2
		len = 1;
		p--;
d385 1
a385 11
	if (term) {
		for ( ; *p && term != *p; p++)
			if (ASCII_HYPH == *p)
				*p = '-';
		return(*p ? (int)(p - sv) : 0);
	}

	for (i = 0; *p && i < len; i++, p++)
		if (ASCII_HYPH == *p)
			*p = '-';
	return(i == len ? (int)(p - sv) : 0);
a387 1

d463 1
d467 1
a467 2
	} else
		quoted = 0;
d608 1
a608 1
	 * propogate outward.
d691 32
@


1.24
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.23 2011/03/15 03:03:49 schwarze Exp $ */
d295 1
a295 1
mandoc_getarg(char **cpp, mandocmsg msg, void *data, int ln, int *pos)
d342 2
a343 2
	if (1 == quoted && msg)
		(*msg)(MANDOCERR_BADQUOTE, data, ln, *pos, NULL);
d356 2
a357 2
	if ('\0' == *cp && msg && (white || ' ' == cp[-1]))
		(*msg)(MANDOCERR_EOLNSPACE, data, ln, *pos, NULL);
d415 1
a415 1
mandoc_normdate(char *in, mandocmsg msg, void *data, int ln, int pos)
d422 1
a422 1
		(*msg)(MANDOCERR_NODATE, data, ln, pos, NULL);
d428 1
a428 1
		(*msg)(MANDOCERR_BADDATE, data, ln, pos, NULL);
d506 3
a508 3
 * Check if a string is a punctuation delimiter.  This only applies to
 * mdoc(7) documents, but as it's used in both front-ends and back-ends,
 * it needs to go here (instead of, say, in libmdoc.h).
d510 2
a511 2
enum mdelim
mandoc_isdelim(const char *p)
d513 1
d515 1
a515 2
	if ('\0' == p[0])
		return(DELIM_NONE);
d517 6
a522 27
	if ('\0' == p[1])
		switch (p[0]) {
		case('('):
			/* FALLTHROUGH */
		case('['):
			return(DELIM_OPEN);
		case('|'):
			return(DELIM_MIDDLE);
		case('.'):
			/* FALLTHROUGH */
		case(','):
			/* FALLTHROUGH */
		case(';'):
			/* FALLTHROUGH */
		case(':'):
			/* FALLTHROUGH */
		case('?'):
			/* FALLTHROUGH */
		case('!'):
			/* FALLTHROUGH */
		case(')'):
			/* FALLTHROUGH */
		case(']'):
			return(DELIM_CLOSE);
		default:
			return(DELIM_NONE);
		}
d524 2
a525 2
	if ('\\' != p[0])
		return(DELIM_NONE);
d527 2
a528 6
	if (0 == strcmp(p + 1, "."))
		return(DELIM_CLOSE);
	if (0 == strcmp(p + 1, "*(Ba"))
		return(DELIM_MIDDLE);

	return(DELIM_NONE);
@


1.23
log
@my $buf = "string"; return $string;  is cool in Perl, but not in C;
found by Ulrich Spoerlein <uqs at freebsd> using the clang static analyzer;
"ok, but please document the numbers" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.22 2011/03/07 01:35:33 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d353 1
a353 1
	*pos += (cp - start) + (quoted ? 1 : 0);
a361 1

a378 1

a413 1

a434 1

a477 1

d503 51
@


1.22
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.21 2011/01/03 22:27:21 schwarze Exp $ */
d385 2
a386 3
	char		 buf[DATESIZE];
	char		*p;
	size_t		 nsz, rsz;
d391 11
a401 11
	p = buf;
	rsz = DATESIZE;

	if (0 == (nsz = strftime(p, rsz, "%B ", &tm)))
		return(NULL);

	p += (int)nsz;
	rsz -= nsz;

	if (-1 == (isz = snprintf(p, rsz, "%d, ", tm.tm_mday)))
		return(NULL);
d403 2
a405 1
	rsz -= isz;
d407 7
a413 1
	return(strftime(p, rsz, "%Y", &tm) ? buf : NULL);
d435 1
a435 1
	return(mandoc_strdup(out ? out : in));
@


1.21
log
@Unify roff macro argument parsing (in roff.c, roff_userdef()) and man macro
argument parsing (in man_argv.c, man_args()), both having different bugs,
to use one common macro argument parser (in mandoc.c, mandoc_getarg()),
because from the point of view of roff, man macros are just roff macros,
hence their arguments are parsed in exactly the same way.

While doing so, fix these bugs:
 * Escaped blanks (i.e. those preceded by an odd number of backslashes)
   were mishandled as argument separators in unquoted arguments to
   user-defined roff macros.
 * Unescaped blanks preceded by an even number of backslashes were not
   recognized as argument separators in unquoted arguments to man macros.
 * Escaped backslashes (i.e. pairs of backslashes) were not reduced
   to single backslashes both in unquoted and quoted arguments both
   to user-defined roff macros and to man macros.
 * Escaped quotes (i.e. pairs of quotes inside quoted arguments) were
   not reduced to single quotes in man macros.

OK kristaps@@

Note that mdoc macro argument parsing is yet another beast for no good
reason and is probably afflicted by similar bugs.  But i don't attempt
to fix that right now because it is intricately entangled with lots of
unrelated high-level mdoc(7) functionality, like delimiter handling and
column list phrase handling.  Disentagling that would waste too much
time now.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.20 2010/09/27 21:25:28 schwarze Exp $ */
d30 2
d33 1
a33 1

d381 32
a412 6
/*
 * Convert from a manual date string (see mdoc(7) and man(7)) into a
 * date according to the stipulated date type.
 */
time_t
mandoc_a2time(int flags, const char *p)
d414 1
d417 10
a426 20
	if (MTIME_MDOCDATE & flags) {
		if (0 == strcmp(p, "$" "Mdocdate$"))
			return(time(NULL));
		if (a2time(&t, "$" "Mdocdate: %b %d %Y $", p))
			return(t);
	}

	if (MTIME_CANONICAL & flags || MTIME_REDUCED & flags) 
		if (a2time(&t, "%b %d, %Y", p))
			return(t);

	if (MTIME_ISO_8601 & flags) 
		if (a2time(&t, "%Y-%m-%d", p))
			return(t);

	if (MTIME_REDUCED & flags) {
		if (a2time(&t, "%d, %Y", p))
			return(t);
		if (a2time(&t, "%Y", p))
			return(t);
d428 2
a429 2

	return(0);
@


1.20
log
@Merge the last bits of 1.10.6 (released today), most were already in:
* ignore double-.Pp
* ignore .Pp before .Bd and .Bl (unless -compact in specified)
* avoid double blank line upon .Pp, .br and friends in literal context
* cast enums to int when passing them to exit(3) to please lint(1)
While merging, fix a regression introduced by kristaps@@:
Outside literal mode, double blank lines must both be printed.
To achieve this again after kristaps@@ improvements in 1.10.6,
treat such blank lines as .sp (instead of .Pp as in 1.10.5)
and drop .Pp before .sp just like dropping .Pp before .Pp.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.19 2010/09/13 22:04:01 schwarze Exp $ */
d4 1
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d281 77
@


1.19
log
@Parse and ignore the \k, \o, \w, and \z roff escapes, and recursively
ignore embedded escapes and mathematical roff subexpressions.
In roff copy mode, resolve "\\" to '\'.
Allow ".xx\}" where xx is a macro to close roff conditional scope.
Mandoc now handles the special character definitions in the pod2man(1)
preamble, so remove the explicit redefinitions in chars.c/chars.in.
From kristaps@@.

I have checked that this causes no relevant change to the Perl manuals.
The only change introduced is that some non-ASCII characters rendered
incorrectly before are now rendered incorrectly in a different way.
For example, e accent aigu was "e", now is "e'"
and c cedille was "c", now is "c,".
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.18 2010/08/20 00:53:35 schwarze Exp $ */
d232 1
a232 1
		exit(MANDOCLEVEL_SYSERR);
d247 1
a247 1
		exit(MANDOCLEVEL_SYSERR);
d261 1
a261 1
		exit(MANDOCLEVEL_SYSERR);
d276 1
a276 1
		exit(MANDOCLEVEL_SYSERR);
d372 1
a372 1
			return(found && (!enclosed || isalnum(*q)));
@


1.18
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.17 2010/08/18 02:38:40 schwarze Exp $ */
a53 2
	case ('w'):
		/* FALLTHROUGH */
a57 2
	case ('o'):
		/* FALLTHROUGH */
d125 21
d156 1
a158 1
#endif
d187 17
@


1.17
log
@Ignore \h (local horizontal motion) and \v (local vertical motion) escapes
just in the same way as \s (font size) escapes, and handle \s escapes
not having an explicit plus or minus sign.
This fixes the very ugly rendering of "C++" in gcc(1).
Reported by Thomas Jeunet, fixed by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.16 2010/07/25 18:05:54 schwarze Exp $ */
d198 1
a198 1
		exit(EXIT_FAILURE);
d213 1
a213 1
		exit(EXIT_FAILURE);
d227 1
a227 1
		exit(EXIT_FAILURE);
d242 1
a242 1
		exit(EXIT_FAILURE);
@


1.16
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.15 2010/07/16 00:34:33 schwarze Exp $ */
a55 2
	case ('v'):
		/* FALLTHROUGH */
d88 4
d95 3
a97 1
		if ('+' == *p || '-' == *p)
d99 2
a100 2

		i = ('s' != *(p - 1));
d113 1
a113 1
			i++;
d124 1
a124 1
			if (i++)
a128 2
		if (0 == i)
			return(0);
@


1.15
log
@Text ending in a full stop, exclamation mark or question mark
should not flag the end of a sentence if:

1) The punctuation is followed by closing delimiters
and not preceded by alphanumeric characters, like in
"There is no full stop (.) in this sentence"

or

2) The punctuation is a child of a macro
and not preceded by alphanumeric characters, like in
"There is no full stop
.Pq \&.
in this sentence"

jmc@@ and sobrado@@ like this
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.14 2010/06/26 17:56:43 schwarze Exp $ */
a29 18
static	int	 spec_norm(char *, int);


/*
 * "Normalise" a special string by converting its ASCII_HYPH entries
 * into actual hyphens.
 */
static int
spec_norm(char *p, int sz)
{
	int		 i;

	for (i = 0; i < sz; i++)
		if (ASCII_HYPH == p[i])
			p[i] = '-';

	return(sz);
}
d35 2
a36 3
	int		 terminator;	/* Terminator for \s. */
	int		 lim;		/* Limit for N in \s. */
	int		 c, i;
d39 2
d43 2
a44 2
	if ('\\' != *p++)
		return(spec_norm(sv, 0));
d46 7
a52 2
	switch (*p) {
	case ('\''):
d54 1
a54 1
	case ('`'):
d56 1
a56 1
	case ('q'):
d58 1
a58 1
	case (ASCII_HYPH):
d60 1
a60 1
	case ('-'):
d62 1
a62 1
	case ('~'):
d64 1
a64 1
	case ('^'):
d66 1
a66 1
	case ('%'):
d68 1
a68 1
	case ('0'):
d70 1
a70 1
	case (' '):
d72 1
a72 1
	case ('}'):
d74 1
a74 1
	case ('|'):
d76 1
a76 1
	case ('&'):
d78 1
a78 1
	case ('.'):
d80 1
a80 1
	case (':'):
d82 1
a82 1
	case ('c'):
d84 6
a89 2
	case ('e'):
		return(spec_norm(sv, 2));
d91 4
a94 2
		if ('\0' == *++p)
			return(spec_norm(sv, 2));
d96 1
a96 20
		c = 2;
		terminator = 0;
		lim = 1;

		if (*p == '\'') {
			lim = 0;
			terminator = 1;
			++p;
			++c;
		} else if (*p == '[') {
			lim = 0;
			terminator = 2;
			++p;
			++c;
		} else if (*p == '(') {
			lim = 2;
			terminator = 3;
			++p;
			++c;
		}
d98 17
a114 3
		if (*p == '+' || *p == '-') {
			++p;
			++c;
d117 27
a143 45
		if (*p == '\'') {
			if (terminator)
				return(spec_norm(sv, 0));
			lim = 0;
			terminator = 1;
			++p;
			++c;
		} else if (*p == '[') {
			if (terminator)
				return(spec_norm(sv, 0));
			lim = 0;
			terminator = 2;
			++p;
			++c;
		} else if (*p == '(') {
			if (terminator)
				return(spec_norm(sv, 0));
			lim = 2;
			terminator = 3;
			++p;
			++c;
		}

		/* TODO: needs to handle floating point. */

		if ( ! isdigit((u_char)*p))
			return(spec_norm(sv, 0));

		for (i = 0; isdigit((u_char)*p); i++) {
			if (lim && i >= lim)
				break;
			++p;
			++c;
		}

		if (terminator && terminator < 3) {
			if (1 == terminator && *p != '\'')
				return(spec_norm(sv, 0));
			if (2 == terminator && *p != ']')
				return(spec_norm(sv, 0));
			++p;
			++c;
		}

		return(spec_norm(sv, c));
d149 1
a149 3
		if ('\0' == *++p || isspace((u_char)*p))
			return(spec_norm(sv, 0));
		switch (*p) {
d151 2
a152 3
			if ('\0' == *++p || isspace((u_char)*p))
				return(spec_norm(sv, 0));
			return(spec_norm(sv, 4));
d154 2
a155 4
			for (c = 3, p++; *p && ']' != *p; p++, c++)
				if (isspace((u_char)*p))
					break;
			return(spec_norm(sv, *p == ']' ? c : 0));
d157 2
d161 1
a161 1
		return(spec_norm(sv, 3));
d163 2
a164 5
		if ('\0' == *++p || isspace((u_char)*p))
			return(spec_norm(sv, 0));
		if ('\0' == *++p || isspace((u_char)*p))
			return(spec_norm(sv, 0));
		return(spec_norm(sv, 4));
d166 1
d169 3
a171 1
		return(spec_norm(sv, 0));
d174 6
a179 3
	for (c = 3, p++; *p && ']' != *p; p++, c++)
		if (isspace((u_char)*p))
			break;
d181 4
a184 1
	return(spec_norm(sv, *p == ']' ? c : 0));
d304 1
a304 1
	int found = 0;
d315 2
a316 1
	for (q = p + sz - 1; q >= p; q--) {
@


1.14
log
@merge release 1.10.2
* bug fixes:
- interaction of ASCII_HYPH with special chars (found by Ulrich Spoerlein)
- handling of roff conditionals (found by Ulrich Spoerlein)
- .Bd -offset will no more default to 6n
* maintenance:
- more caching of .Bd and .Bl arguments for efficiency
- deconstify man(7) validation routines
- add FreeBSD library names (provided by Ulrich Spoerlein)
* start PostScript font-switching
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.13 2010/06/06 20:30:08 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
d327 1
a327 1
mandoc_eos(const char *p, size_t sz)
d329 2
d341 2
a342 2
	for ( ; sz; sz--) {
		switch (p[(int)sz - 1]) {
d350 2
a353 3
			/* Escaped periods. */
			if (sz > 1 && '\\' == p[(int)sz - 2])
				return(0);
d358 2
a359 1
			return(1);
d361 1
a361 1
			return(0);
d365 1
a365 1
	return(0);
@


1.13
log
@Merge bsd.lv version 1.10.1 (to be released soon).

The main step forward is that this now has *much* better .Bl -column
support, now supporting many manuals that previously errored out
without producing any output.

Other fixes include:
* do not die from multiple list types, use the first and warn
* in .Bl without a type, default to -item
* various tweaks to .Dt
* fix .In, .Fd, .Ft, .Fn and .Fo formatting
* some documentation fixes and additions
* and fix a couple of bugs reported by Ulrich Spoerlein:
* better support for roff block-end "\}" without a preceding dot
* .In must not break the line outside SYNOPSIS
* spelling in some error messages

While merging, fix one regression in .In spacing
that needs to go to bsd.lv, too.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.12 2010/05/26 02:39:58 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d26 1
d29 19
a47 1
static int	 a2time(time_t *, const char *, const char *);
d51 1
a51 1
mandoc_special(const char *p)
d56 1
d58 2
d61 1
a61 1
		return(0);
d70 2
d95 1
a95 1
		return(2);
d97 1
a97 1
		return(2);
d100 1
a100 1
			return(2);
d130 1
a130 1
				return(0);
d137 1
a137 1
				return(0);
d144 1
a144 1
				return(0);
d154 1
a154 1
			return(0);
d165 1
a165 1
				return(0);
d167 1
a167 1
				return(0);
d172 1
a172 1
		return(c);
d178 2
a179 2
		if (0 == *++p || ! isgraph((u_char)*p))
			return(0);
d182 3
a184 3
			if (0 == *++p || ! isgraph((u_char)*p))
				return(0);
			return(4);
d187 1
a187 1
				if ( ! isgraph((u_char)*p))
d189 1
a189 1
			return(*p == ']' ? c : 0);
d193 1
a193 1
		return(3);
d195 5
a199 5
		if (0 == *++p || ! isgraph((u_char)*p))
			return(0);
		if (0 == *++p || ! isgraph((u_char)*p))
			return(0);
		return(4);
d203 1
a203 1
		return(0);
d207 1
a207 1
		if ( ! isgraph((u_char)*p))
d210 1
a210 1
	return(*p == ']' ? c : 0);
@


1.12
log
@When a word does not fully fit onto the output line, but it contains
at least one hyphen, we already had support for breaking the line a the
last fitting hyphen.  This patch improves this functionality by only
breaking at hyphens in free-form text, and by not breaking at hyphens
* at the beginning or end of a word   or
* immediately preceded or followed by another hyphen   or
* escaped by a preceding backslash.

Before this patch, differences in break-at-hyphen support were one
of the major sources of noise in automatic comparisons to mdoc(7)
groff output.  Now, the remaining differences are hard to find among
the noise coming from other sources.

Where there are still differences, what we do seems to be better than
what groff does, see e.g. the chio(1) exchange and position commands
for one of the now rare examples.

idea and coding by kristaps@@

Besides, this was the last substantial code difference left
between bsd.lv and openbsd.org.  We are now in full sync.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.11 2010/05/15 15:37:53 schwarze Exp $ */
d59 2
@


1.11
log
@more end-of-sentence (EOS) handling:
* recognize the end of quoted sentences, and of those in parantheses
* detect EOS in append_delims, so it works after all macros
by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.10 2010/05/15 09:20:01 schwarze Exp $ */
d338 28
@


1.10
log
@block-implicit macros now up-propogate end-of-sentence spacing;
from bsd.lv mandoc.c 1.13 and mdoc_macro.c 1.64
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.9 2010/05/14 19:52:43 schwarze Exp $ */
d307 26
a332 4
	switch (p[(int)sz - 1]) {
	case ('.'):
		/* Escaped periods. */
		if (sz > 1 && '\\' == p[(int)sz - 2])
d334 1
a334 7
		/* FALLTHROUGH */
	case ('!'):
		/* FALLTHROUGH */
	case ('?'):
		break;
	default:
		return(0);
d337 1
a337 1
	return(1);
@


1.9
log
@Integrate kristaps@@' end-of-sentence (EOS) framework
which is simpler and more powerful than mine, and remove mine.

* man(7) now has EOS handling, too
* put EOS detection into its own function in libmandoc
* use node and termp flags to communicate the EOS condition
* no more EOS pseudo-macro
* no more non-printable EOS marker character on the formatter level

This slightly breaks EOS detection after trailing punctuation
in mdoc(7) macros, but that will be restored soon.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.8 2010/04/07 23:15:05 schwarze Exp $ */
d304 2
a305 1
	assert(sz);
@


1.8
log
@Merge the good parts of 1.9.23,
avoid the bad parts of 1.9.23, and keep local patches.

Input in general:
 * Basic handling of roff-style font escapes \f, \F.
 * Quoted punctuation does not count as punctuation.

mdoc(7) parser:
 * Make .Pf callable; noted by Claus Assmann.
 * Let .Bd and .Bl ignore unknown arguments; noted by deraadt@@.
 * Do not warn when .Er is used outside certain sections.
 * Replace mdoc_node_free[list] by mdoc_node_delete.
 * Replace #define by enum for rew*() return values.

man(7) parser:
 * When .TH is missing, use default section and date.

Output in general:
 * Curly braces do not count as punctuation.
 * No space after .Fl w/o args when a macro follows on the same line.

HTML output:
 * Unify PAIR_*_INIT macros, introduce new PAIR_ID_INIT().
 * Print whitespace after, not before .Vt .Fn .Ft .Fo.

Checked that all manuals in base still build.
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.7 2010/02/18 02:11:26 schwarze Exp $ */
d299 23
@


1.7
log
@sync to release 1.9.15:
 * corrected .Vt handling (spotted by Joerg Sonnenberger)
 * corrected .Xr argument handling (based on my patch)
 * removed \\ escape sequence (because it is for low-level roff only)
 * warn about trailing whitespace (suggested by jmc@@)
 * -Txhtml support
 * and some general cleanup and doc improvements
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.6 2009/12/24 02:08:14 schwarze Exp $ */
a71 4
	case ('f'):
		if ('\0' == *++p || ! isgraph((u_char)*p))
			return(0);
		return(3);
d147 4
@


1.6
log
@sync to 1.9.14: rewrite escape sequence handling:
- new function a2roffdeco
- font modes (\f) only affect the current stack point
- implement scaling (\s)
- implement space suppression (\c)
- implement non-breaking space (\~) in -Tascii
- many manual improvements
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.5 2009/12/23 22:30:17 schwarze Exp $ */
a41 2
	case ('\\'):
		/* FALLTHROUGH */
@


1.5
log
@sync to 1.9.13: minor fixes:

correctness/functionality:
 - bugfix: properly ignore lines with only a dot in -man
 - bugfix: .Bl -ohang doesn't allow -width, warn about this
 - improve date string handling by new function mandoc_a2time
 - some HTML improvements
 - significant documentation additions in man.7 and mdoc.7

portability:
 - replace __dead by __attribute__((noreturn))
 - bugfix: correct .Dx rendering
 - some more library names for NetBSD

simplicity:
 - replace hand-rolled putchar(3)-loops by fwrite(3)
 - replace single-character printf(3) by putchar(3)
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.4 2009/12/22 23:58:00 schwarze Exp $ */
d34 3
a36 1
	int		 c;
d75 1
a75 1
		if (0 == *++p || ! isgraph((u_char)*p))
d78 75
@


1.4
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.3 2009/08/22 15:18:11 schwarze Exp $ */
d24 1
d28 3
d170 54
@


1.3
log
@sync to 1.8.4: recognize the \c escape (only used in -man)
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.2 2009/07/18 14:44:54 schwarze Exp $ */
d22 2
d108 58
@


1.2
log
@sync to 1.8.0: <sys/types.h> needed for u_char; <uqs at spoerlein dot net>
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.1 2009/07/08 00:04:10 schwarze Exp $ */
d62 2
@


1.1
log
@sync to 1.7.21: unified escape sequence validation for mdoc and man
checking is still incomplete, but a bit better, in particular for man
now in sync with 1.7.22: the only 1.7.22 diff was already in
@
text
@d1 1
a1 1
/*	$Id: mandoc.c,v 1.1 2009/07/04 09:01:55 kristaps Exp $ */
d17 2
@

