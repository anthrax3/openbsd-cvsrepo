head	1.20;
access;
symbols
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2;
locks; strict;
comment	@ * @;


1.20
date	2017.02.10.15.44.31;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	jWIgaURhUN1Qo7t2;

1.19
date	2017.01.27.13.47.17;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	MgmMgxX5WBbY1YFd;

1.18
date	2016.05.23.18.59.00;	author millert;	state Exp;
branches;
next	1.17;
commitid	ICHi88Dajz4juEOX;

1.17
date	2015.11.07.17.58.52;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	9ZfFG7Q71jrU5djH;

1.16
date	2015.10.11.21.06.59;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	fBGuLyDivJdmK1wz;

1.15
date	2015.05.07.12.07.29;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	OqaaVBWxHNv27KOg;

1.14
date	2015.03.27.17.36.56;	author schwarze;	state Exp;
branches;
next	1.13;
commitid	3WUgQM2C53CGXRkK;

1.13
date	2015.03.26.22.42.01;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	Fj1jHXZJBnCTlkBf;

1.12
date	2015.03.21.17.18.17;	author schwarze;	state Exp;
branches;
next	1.11;
commitid	N0ofDfh2sNqWva0r;

1.11
date	2014.11.18.19.40.38;	author schwarze;	state Exp;
branches;
next	1.10;
commitid	7og1PHOGxbasNxE6;

1.10
date	2014.04.23.21.06.33;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2013.11.21.01.47.10;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2013.05.29.23.15.11;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2012.12.04.02.24.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2011.12.24.21.51.40;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2011.12.19.02.26.33;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2011.12.12.01.59.13;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.26.16.41.35;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.20
log
@In -Ttree output mode, show the BROKEN node flag and
provide a -Onoval output option to show the unvalidated tree.
@
text
@/*	$OpenBSD: manpath.c,v 1.19 2017/01/27 13:47:17 schwarze Exp $	*/
/*
 * Copyright (c) 2011, 2014, 2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc_aux.h"
#include "manconf.h"

#define MAN_CONF_FILE	"/etc/man.conf"
#define MANPATH_DEFAULT	"/usr/share/man:/usr/X11R6/man:/usr/local/man"

static	void	 manconf_file(struct manconf *, const char *);
static	void	 manpath_add(struct manpaths *, const char *, int);
static	void	 manpath_parseline(struct manpaths *, char *, int);


void
manconf_parse(struct manconf *conf, const char *file,
		char *defp, char *auxp)
{
	char		*insert;

	/* Always prepend -m. */
	manpath_parseline(&conf->manpath, auxp, 1);

	/* If -M is given, it overrides everything else. */
	if (NULL != defp) {
		manpath_parseline(&conf->manpath, defp, 1);
		return;
	}

	/* MANPATH and man.conf(5) cooperate. */
	defp = getenv("MANPATH");
	if (NULL == file)
		file = MAN_CONF_FILE;

	/* No MANPATH; use man.conf(5) only. */
	if (NULL == defp || '\0' == defp[0]) {
		manconf_file(conf, file);
		return;
	}

	/* Prepend man.conf(5) to MANPATH. */
	if (':' == defp[0]) {
		manconf_file(conf, file);
		manpath_parseline(&conf->manpath, defp, 0);
		return;
	}

	/* Append man.conf(5) to MANPATH. */
	if (':' == defp[strlen(defp) - 1]) {
		manpath_parseline(&conf->manpath, defp, 0);
		manconf_file(conf, file);
		return;
	}

	/* Insert man.conf(5) into MANPATH. */
	insert = strstr(defp, "::");
	if (NULL != insert) {
		*insert++ = '\0';
		manpath_parseline(&conf->manpath, defp, 0);
		manconf_file(conf, file);
		manpath_parseline(&conf->manpath, insert + 1, 0);
		return;
	}

	/* MANPATH overrides man.conf(5) completely. */
	manpath_parseline(&conf->manpath, defp, 0);
}

/*
 * Parse a FULL pathname from a colon-separated list of arrays.
 */
static void
manpath_parseline(struct manpaths *dirs, char *path, int complain)
{
	char	*dir;

	if (NULL == path)
		return;

	for (dir = strtok(path, ":"); dir; dir = strtok(NULL, ":"))
		manpath_add(dirs, dir, complain);
}

/*
 * Add a directory to the array, ignoring bad directories.
 * Grow the array one-by-one for simplicity's sake.
 */
static void
manpath_add(struct manpaths *dirs, const char *dir, int complain)
{
	char		 buf[PATH_MAX];
	struct stat	 sb;
	char		*cp;
	size_t		 i;

	if (NULL == (cp = realpath(dir, buf))) {
		if (complain)
			warn("manpath: %s", dir);
		return;
	}

	for (i = 0; i < dirs->sz; i++)
		if (0 == strcmp(dirs->paths[i], dir))
			return;

	if (stat(cp, &sb) == -1) {
		if (complain)
			warn("manpath: %s", dir);
		return;
	}

	dirs->paths = mandoc_reallocarray(dirs->paths,
	    dirs->sz + 1, sizeof(char *));

	dirs->paths[dirs->sz++] = mandoc_strdup(cp);
}

void
manconf_free(struct manconf *conf)
{
	size_t		 i;

	for (i = 0; i < conf->manpath.sz; i++)
		free(conf->manpath.paths[i]);

	free(conf->manpath.paths);
	free(conf->output.includes);
	free(conf->output.man);
	free(conf->output.paper);
	free(conf->output.style);
}

static void
manconf_file(struct manconf *conf, const char *file)
{
	const char *const toks[] = { "manpath", "output", "_whatdb" };
	char manpath_default[] = MANPATH_DEFAULT;

	FILE		*stream;
	char		*line, *cp, *ep;
	size_t		 linesz, tok, toklen;
	ssize_t		 linelen;

	if ((stream = fopen(file, "r")) == NULL)
		goto out;

	line = NULL;
	linesz = 0;

	while ((linelen = getline(&line, &linesz, stream)) != -1) {
		cp = line;
		ep = cp + linelen - 1;
		while (ep > cp && isspace((unsigned char)*ep))
			*ep-- = '\0';
		while (isspace((unsigned char)*cp))
			cp++;
		if (cp == ep || *cp == '#')
			continue;

		for (tok = 0; tok < sizeof(toks)/sizeof(toks[0]); tok++) {
			toklen = strlen(toks[tok]);
			if (cp + toklen < ep &&
			    isspace((unsigned char)cp[toklen]) &&
			    strncmp(cp, toks[tok], toklen) == 0) {
				cp += toklen;
				while (isspace((unsigned char)*cp))
					cp++;
				break;
			}
		}

		switch (tok) {
		case 2:  /* _whatdb */
			while (ep > cp && ep[-1] != '/')
				ep--;
			if (ep == cp)
				continue;
			*ep = '\0';
			/* FALLTHROUGH */
		case 0:  /* manpath */
			manpath_add(&conf->manpath, cp, 0);
			*manpath_default = '\0';
			break;
		case 1:  /* output */
			manconf_output(&conf->output, cp, 1);
			break;
		default:
			break;
		}
	}
	free(line);
	fclose(stream);

out:
	if (*manpath_default != '\0')
		manpath_parseline(&conf->manpath, manpath_default, 0);
}

int
manconf_output(struct manoutput *conf, const char *cp, int fromfile)
{
	const char *const toks[] = {
	    "includes", "man", "paper", "style",
	    "indent", "width", "fragment", "mdoc", "noval"
	};

	const char	*errstr;
	char		*oldval;
	size_t		 len, tok;

	for (tok = 0; tok < sizeof(toks)/sizeof(toks[0]); tok++) {
		len = strlen(toks[tok]);
		if ( ! strncmp(cp, toks[tok], len) &&
		    strchr(" =	", cp[len]) != NULL) {
			cp += len;
			if (*cp == '=')
				cp++;
			while (isspace((unsigned char)*cp))
				cp++;
			break;
		}
	}

	if (tok < 6 && *cp == '\0') {
		warnx("-O %s=?: Missing argument value", toks[tok]);
		return -1;
	}
	if ((tok == 6 || tok == 7) && *cp != '\0') {
		warnx("-O %s: Does not take a value: %s", toks[tok], cp);
		return -1;
	}

	switch (tok) {
	case 0:
		if (conf->includes != NULL) {
			oldval = mandoc_strdup(conf->includes);
			break;
		}
		conf->includes = mandoc_strdup(cp);
		return 0;
	case 1:
		if (conf->man != NULL) {
			oldval = mandoc_strdup(conf->man);
			break;
		}
		conf->man = mandoc_strdup(cp);
		return 0;
	case 2:
		if (conf->paper != NULL) {
			oldval = mandoc_strdup(conf->paper);
			break;
		}
		conf->paper = mandoc_strdup(cp);
		return 0;
	case 3:
		if (conf->style != NULL) {
			oldval = mandoc_strdup(conf->style);
			break;
		}
		conf->style = mandoc_strdup(cp);
		return 0;
	case 4:
		if (conf->indent) {
			mandoc_asprintf(&oldval, "%zu", conf->indent);
			break;
		}
		conf->indent = strtonum(cp, 0, 1000, &errstr);
		if (errstr == NULL)
			return 0;
		warnx("-O indent=%s is %s", cp, errstr);
		return -1;
	case 5:
		if (conf->width) {
			mandoc_asprintf(&oldval, "%zu", conf->width);
			break;
		}
		conf->width = strtonum(cp, 58, 1000, &errstr);
		if (errstr == NULL)
			return 0;
		warnx("-O width=%s is %s", cp, errstr);
		return -1;
	case 6:
		conf->fragment = 1;
		return 0;
	case 7:
		conf->mdoc = 1;
		return 0;
	case 8:
		conf->noval = 1;
		return 0;
	default:
		if (fromfile)
			warnx("-O %s: Bad argument", cp);
		return -1;
	}
	if (fromfile == 0)
		warnx("-O %s=%s: Option already set to %s",
		    toks[tok], cp, oldval);
	free(oldval);
	return -1;
}
@


1.19
log
@warn about invalid output options
and error out if they occur on the command line;
missing feature found in the TODO file
@
text
@d1 1
a1 1
/*	$OpenBSD: manpath.c,v 1.18 2016/05/23 18:59:00 millert Exp $	*/
d228 1
a228 1
	    "indent", "width", "fragment", "mdoc"
d311 3
@


1.18
log
@Trim trailing whitespace from man.conf lines.  OK schwarze@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: manpath.c,v 1.17 2015/11/07 17:58:52 schwarze Exp $	*/
d3 1
a3 1
 * Copyright (c) 2011, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
d209 1
a209 1
			manconf_output(&conf->output, cp);
d223 2
a224 2
void
manconf_output(struct manoutput *conf, const char *cp)
d231 3
a233 1
	size_t	 len, tok;
d248 8
a255 2
	if (tok < 6 && *cp == '\0')
		return;
d259 6
a264 3
		if (conf->includes == NULL)
			conf->includes = mandoc_strdup(cp);
		break;
d266 6
a271 3
		if (conf->man == NULL)
			conf->man = mandoc_strdup(cp);
		break;
d273 6
a278 3
		if (conf->paper == NULL)
			conf->paper = mandoc_strdup(cp);
		break;
d280 6
a285 3
		if (conf->style == NULL)
			conf->style = mandoc_strdup(cp);
		break;
d287 9
a295 3
		if (conf->indent == 0)
			conf->indent = strtonum(cp, 0, 1000, NULL);
		break;
d297 9
a305 3
		if (conf->width == 0)
			conf->width = strtonum(cp, 58, 1000, NULL);
		break;
d308 1
a308 1
		break;
d311 1
a311 1
		break;
d313 3
a315 1
		break;
d317 5
@


1.17
log
@Modernization, no functional change intended:
Use the POSIX function getline(3) rather than the slightly
dangerous BSD function fgetln(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: manpath.c,v 1.16 2015/10/11 21:06:59 schwarze Exp $	*/
d176 3
a178 4
		ep = cp + linelen;
		if (ep[-1] != '\n')
			break;
		*--ep = '\0';
d181 1
a181 1
		if (*cp == '#')
@


1.16
log
@Finally use __progname, err(3) and warn(3).
That's more readable and less error-prone than fumbling around
with argv[0], fprintf(3), strerror(3), perror(3), and exit(3).
It also shortens the code by 50 lines.

It's a bad idea to boycott good interfaces merely because standards
committees ignore them.  Instead, it's the job of the portable
distribution to provide compatibility modules for archaic systems
(like commercial Solaris) that still don't have them.  Actually,
the compat code for the portable distribution already exists and
will be committed right after this.
@
text
@d1 1
a1 1
/*	$OpenBSD: manpath.c,v 1.15 2015/05/07 12:07:29 schwarze Exp $	*/
d164 3
a166 2
	char		*cp, *ep;
	size_t		 len, tok;
d171 6
a176 2
	while ((cp = fgetln(stream, &len)) != NULL) {
		ep = cp + len;
d186 5
a190 5
			len = strlen(toks[tok]);
			if (cp + len < ep &&
			    isspace((unsigned char)cp[len]) &&
			    !strncmp(cp, toks[tok], len)) {
				cp += len;
d216 1
@


1.15
log
@Do not let the -m option or MANPATH with leading, trailing, or double
colon override the default manpath, let them add to the default manpath.
Only override the default manpath by the -M option, by MANPATH without
leading, trailing, or double colon, or by "manpath" in man.conf(5).

Problem reported by Jan Stary <hans at stare dot cz>.
Patch OK'ed by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: manpath.c,v 1.14 2015/03/27 17:36:56 schwarze Exp $	*/
d22 1
d121 2
a122 4
		if (complain) {
			fputs("manpath: ", stderr);
			perror(dir);
		}
d131 2
a132 4
		if (complain) {
			fputs("manpath: ", stderr);
			perror(dir);
		}
@


1.14
log
@Parse the new man.conf(5) "output" directive.
The next step will be to actually use the parsed data.
@
text
@d1 1
a1 1
/*	$OpenBSD: manpath.c,v 1.13 2015/03/26 22:42:01 schwarze Exp $	*/
a41 1
	char		 manpath_default[] = MANPATH_DEFAULT;
a60 2
		if (conf->manpath.sz == 0)
			manpath_parseline(&conf->manpath, manpath_default, 0);
d164 1
d171 1
a171 1
		return;
d205 1
d214 1
d216 3
a218 1
	fclose(stream);
@


1.13
log
@Add a new directive "manpath path"
to replace the legacy "_whatdb path/whatis.db".
Keep _whatdb support for backward compat, for now.
Discussed with many, jmc@@ and ajacoutot@@ agree with the general direction.
@
text
@d1 1
a1 1
/*	$OpenBSD: manpath.c,v 1.12 2015/03/21 17:18:17 schwarze Exp $	*/
d28 1
a28 1
#include "manpath.h"
d33 1
d37 1
d39 1
a39 1
manpath_parse(struct manpaths *dirs, const char *file,
d46 1
a46 1
	manpath_parseline(dirs, auxp, 1);
d50 1
a50 1
		manpath_parseline(dirs, defp, 1);
d61 3
a63 3
		manpath_manconf(dirs, file);
		if (dirs->sz == 0)
			manpath_parseline(dirs, manpath_default, 0);
d69 2
a70 2
		manpath_manconf(dirs, file);
		manpath_parseline(dirs, defp, 0);
d76 2
a77 2
		manpath_parseline(dirs, defp, 0);
		manpath_manconf(dirs, file);
d85 3
a87 3
		manpath_parseline(dirs, defp, 0);
		manpath_manconf(dirs, file);
		manpath_parseline(dirs, insert + 1, 0);
d92 1
a92 1
	manpath_parseline(dirs, defp, 0);
d149 1
a149 1
manpath_free(struct manpaths *p)
d153 2
a154 2
	for (i = 0; i < p->sz; i++)
		free(p->paths[i]);
d156 5
a160 1
	free(p->paths);
d163 2
a164 2
void
manpath_manconf(struct manpaths *dirs, const char *file)
d166 1
a166 1
	const char *const toks[] = { "manpath", "_whatdb" };
d198 1
a198 1
		case 1:  /* _whatdb */
d206 4
a209 1
			manpath_add(dirs, cp, 0);
d217 62
@


1.12
log
@when there is no -m, no -M, no MANPATH and no /etc/man.conf,
fall back to /usr/share/man:/usr/X11R6/man:/usr/local/man
@
text
@d1 1
a1 1
/*	$OpenBSD: manpath.c,v 1.11 2014/11/18 19:40:38 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
a20 1
#include <assert.h>
a30 1
#define MAN_CONF_KEY	"_whatdb"
d160 2
d163 2
a164 5
	char		*p, *q;
	size_t		 len, keysz;

	keysz = strlen(MAN_CONF_KEY);
	assert(keysz > 0);
d166 1
a166 1
	if (NULL == (stream = fopen(file, "r")))
d169 3
a171 2
	while (NULL != (p = fgetln(stream, &len))) {
		if (0 == len || '\n' != p[--len])
d173 4
a176 4
		p[len] = '\0';
		while (isspace((unsigned char)*p))
			p++;
		if (strncmp(MAN_CONF_KEY, p, keysz))
d178 27
a204 9
		p += keysz;
		while (isspace((unsigned char)*p))
			p++;
		if ('\0' == *p)
			continue;
		if (NULL == (q = strrchr(p, '/')))
			continue;
		*q = '\0';
		manpath_add(dirs, p, 0);
@


1.11
log
@Ignore invalid directories in man.conf(5) and MANPATH, even if their
parent directories exist, but complain about invalid directories
given on the command line.
Intended to fix an oddity reported by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d3 1
a3 1
 * Copyright (c) 2011, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d33 1
d42 1
d62 2
@


1.10
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
* Change eight reallocs to reallocarray to be safe from overflows.
* Change one malloc to reallocarray to be safe from overflows.
* Change one calloc to reallocarray, no zeroing needed.
* Change the order of arguments of three callocs (aesthetical).
@
text
@d1 1
a1 1
/*	$Id: manpath.c,v 1.9 2014/04/20 16:44:44 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
d18 2
d34 2
a35 2
static	void	 manpath_add(struct manpaths *, const char *);
static	void	 manpath_parseline(struct manpaths *, char *);
d44 1
a44 1
	manpath_parseline(dirs, auxp);
d48 1
a48 1
		manpath_parseline(dirs, defp);
d66 1
a66 1
		manpath_parseline(dirs, defp);
d72 1
a72 1
		manpath_parseline(dirs, defp);
d81 1
a81 1
		manpath_parseline(dirs, defp);
d83 1
a83 1
		manpath_parseline(dirs, insert + 1);
d88 1
a88 1
	manpath_parseline(dirs, defp);
d95 1
a95 1
manpath_parseline(struct manpaths *dirs, char *path)
d103 1
a103 1
		manpath_add(dirs, dir);
d111 1
a111 1
manpath_add(struct manpaths *dirs, const char *dir)
d114 1
d118 5
a122 1
	if (NULL == (cp = realpath(dir, buf)))
d124 1
d130 8
d184 1
a184 1
		manpath_add(dirs, p);
@


1.9
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: manpath.c,v 1.8 2014/03/21 22:17:01 schwarze Exp $ */
d122 2
a123 2
	dirs->paths = mandoc_realloc(dirs->paths,
	    (dirs->sz + 1) * sizeof(char *));
@


1.8
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: manpath.c,v 1.7 2013/11/21 01:47:10 schwarze Exp $ */
d122 2
a123 3
	dirs->paths = mandoc_realloc
		(dirs->paths,
		 (dirs->sz + 1) * sizeof(char *));
@


1.7
log
@My audit of mandoc revealed two missing (unsigned char) casts
in isspace() and tolower() arguments containing arbitrary char data.
Thanks to deraadt@@ for triggering the audit.
@
text
@d1 1
a1 1
/*	$Id: manpath.c,v 1.6 2013/05/29 23:15:11 schwarze Exp $ */
d26 1
a26 1
#include "mandoc.h"
@


1.6
log
@Trivial sync to bsd.lv:
Kristaps changed the size member of struct manpaths from int to size_t.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: manpath.c,v 1.5 2012/12/04 02:24:47 deraadt Exp $ */
d162 1
a162 1
		while (isspace(*p))
@


1.5
log
@remove some unnecessary sys/param.h inclusions
@
text
@d1 1
a1 1
/*	$Id: manpath.c,v 1.4 2011/12/24 21:51:40 schwarze Exp $ */
d69 1
a69 1
	if (':' == defp[(int)strlen(defp) - 1]) {
d113 1
a113 1
	int		 i;
d124 1
a124 1
		 ((size_t)dirs->sz + 1) * sizeof(char *));
d132 1
a132 1
	int		 i;
@


1.4
log
@Support leading, trailing and double colons in MANPATH
to prepend, append or insert the man.conf(5) default path;
compatible with GNU manpath(1), implementation by kristaps@@,
heavily tweaked by me.
@
text
@d1 1
a1 1
/*	$Id: manpath.c,v 1.3 2011/12/19 02:26:33 schwarze Exp $ */
a17 2

#include <sys/param.h>
@


1.3
log
@Improvements from kristaps@@:
(1) Make the database format simpler and smaller by
- storing the file type as a single character and
- storing paths relative to the dir containing the database.
The latter allows to move trees around.
Both together typically save 15-25% of the index size.
(2) Make sure apropos(1) "any" really covers all search keys.
(3) Make manpath_parseline() static, drop manpath_parseconf() completely.
@
text
@d1 1
a1 1
/*	$Id: manpath.c,v 1.2 2011/12/12 01:59:13 schwarze Exp $ */
d41 1
d43 1
d46 23
a68 2
	if (NULL == defp)
		defp = getenv("MANPATH");
d70 2
a71 3
	if (NULL == defp)
		manpath_manconf(dirs, file ? file : MAN_CONF_FILE);
	else
d73 16
@


1.2
log
@implement -C (alternative config file) for apropos(1) and mandocdb(8);
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: manpath.c,v 1.1 2011/11/26 16:41:35 schwarze Exp $ */
d19 2
a20 1
#include <sys/types.h>
d35 1
d48 1
a48 1
		manpath_parseconf(dirs, file);
d56 1
a56 1
void
a90 7
}

void
manpath_parseconf(struct manpaths *dirs, const char *file)
{

	manpath_manconf(dirs, file ? file : MAN_CONF_FILE);
@


1.1
log
@Resync to bsd.lv, most code from kristaps@@.
In particular, support the MANPATH environment variable
and don't confuse index record numbers when working with
multiple mandoc databases at once.
Besides, remove lots of gratuitious code and whitespace differences.
@
text
@d1 1
a1 1
/*	$Id: manpath.c,v 1.1 2011/11/17 14:52:32 schwarze Exp $ */
d36 2
a37 1
manpath_parse(struct manpaths *dirs, char *defp, char *auxp)
d46 1
a46 1
		manpath_parseconf(dirs);
d92 1
a92 1
manpath_parseconf(struct manpaths *dirs)
d95 1
a95 1
	manpath_manconf(MAN_CONF_FILE, dirs);
d110 1
a110 1
manpath_manconf(const char *file, struct manpaths *dirs)
@

