head	1.192;
access;
symbols
	OPENBSD_6_1:1.165.0.4
	OPENBSD_6_1_BASE:1.165
	OPENBSD_6_0:1.156.0.4
	OPENBSD_6_0_BASE:1.156
	OPENBSD_5_9:1.156.0.2
	OPENBSD_5_9_BASE:1.156
	OPENBSD_5_8:1.144.0.4
	OPENBSD_5_8_BASE:1.144
	OPENBSD_5_7:1.135.0.2
	OPENBSD_5_7_BASE:1.135
	OPENBSD_5_6:1.94.0.4
	OPENBSD_5_6_BASE:1.94
	OPENBSD_5_5:1.67.0.4
	OPENBSD_5_5_BASE:1.67
	OPENBSD_5_4:1.51.0.2
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.48.0.4
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.2
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.2
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10;
locks; strict;
comment	@ * @;


1.192
date	2017.07.08.15.28.05;	author schwarze;	state Exp;
branches;
next	1.191;
commitid	SkrSkPOd3m4ZvSwI;

1.191
date	2017.07.08.14.51.01;	author schwarze;	state Exp;
branches;
next	1.190;
commitid	Gn9C5KmUiz1MgVXP;

1.190
date	2017.07.04.22.49.59;	author schwarze;	state Exp;
branches;
next	1.189;
commitid	yViI6jj64J9alfn2;

1.189
date	2017.06.25.07.23.53;	author bentley;	state Exp;
branches;
next	1.188;
commitid	bTszF5pV5yWJ9O5p;

1.188
date	2017.06.24.14.38.28;	author schwarze;	state Exp;
branches;
next	1.187;
commitid	ebFpCjoYaInwxToS;

1.187
date	2017.06.18.17.35.40;	author schwarze;	state Exp;
branches;
next	1.186;
commitid	8HibBVlKkTGWZtha;

1.186
date	2017.06.17.23.06.43;	author schwarze;	state Exp;
branches;
next	1.185;
commitid	IbYSiNWSEwkdSFTZ;

1.185
date	2017.06.17.22.40.27;	author schwarze;	state Exp;
branches;
next	1.184;
commitid	eh9zSUWrW3gWUWkZ;

1.184
date	2017.06.14.22.50.37;	author schwarze;	state Exp;
branches;
next	1.183;
commitid	4ZRNcVtsOVT4OCx6;

1.183
date	2017.06.14.19.39.05;	author schwarze;	state Exp;
branches;
next	1.182;
commitid	0FiHwvTG2c1O6PBC;

1.182
date	2017.06.14.14.01.34;	author schwarze;	state Exp;
branches;
next	1.181;
commitid	LpZGryK8779C9pqd;

1.181
date	2017.06.14.13.00.13;	author schwarze;	state Exp;
branches;
next	1.180;
commitid	vsjV08uuy9BaspKR;

1.180
date	2017.06.13.13.50.17;	author schwarze;	state Exp;
branches;
next	1.179;
commitid	N2y4pvZ3THWegTGW;

1.179
date	2017.06.08.19.35.34;	author schwarze;	state Exp;
branches;
next	1.178;
commitid	7R0rb4PhH6mz3C84;

1.178
date	2017.06.07.00.50.30;	author schwarze;	state Exp;
branches;
next	1.177;
commitid	qEagbOjCH3up4xpY;

1.177
date	2017.06.06.15.00.56;	author schwarze;	state Exp;
branches;
next	1.176;
commitid	LdhzICSunbnL2oyB;

1.176
date	2017.06.04.22.43.50;	author schwarze;	state Exp;
branches;
next	1.175;
commitid	HuVlLkzV75UMAm6A;

1.175
date	2017.06.04.00.08.56;	author schwarze;	state Exp;
branches;
next	1.174;
commitid	utobDj41l6WSbX2y;

1.174
date	2017.05.08.20.33.40;	author schwarze;	state Exp;
branches;
next	1.173;
commitid	W079BW3GQUdhvqNr;

1.173
date	2017.05.08.15.33.43;	author schwarze;	state Exp;
branches;
next	1.172;
commitid	wam7mxa5wtd9m7Af;

1.172
date	2017.05.07.17.30.58;	author schwarze;	state Exp;
branches;
next	1.171;
commitid	pfMPALNhm77dpGFF;

1.171
date	2017.05.05.15.16.25;	author schwarze;	state Exp;
branches;
next	1.170;
commitid	sNJdFUhzoVfGBx2p;

1.170
date	2017.05.05.13.17.04;	author schwarze;	state Exp;
branches;
next	1.169;
commitid	GvSRKa33jIoa4JAJ;

1.169
date	2017.05.05.02.06.17;	author schwarze;	state Exp;
branches;
next	1.168;
commitid	JMX1RJlA2uFuu13l;

1.168
date	2017.05.04.17.48.24;	author schwarze;	state Exp;
branches;
next	1.167;
commitid	RHQLdCAdHKxKe8Eu;

1.167
date	2017.04.29.12.43.55;	author schwarze;	state Exp;
branches;
next	1.166;
commitid	7BLUwozNEzUO8xfK;

1.166
date	2017.04.24.23.06.09;	author schwarze;	state Exp;
branches;
next	1.165;
commitid	2CfzvK3gmiJH7vY0;

1.165
date	2017.03.09.15.27.52;	author schwarze;	state Exp;
branches;
next	1.164;
commitid	hZQW7I8cjaxk0oSz;

1.164
date	2017.03.08.13.17.28;	author schwarze;	state Exp;
branches;
next	1.163;
commitid	VW5BBU3pOCDWw0N2;

1.163
date	2017.03.03.13.55.06;	author schwarze;	state Exp;
branches;
next	1.162;
commitid	ebZHhO3JQ20kqPTN;

1.162
date	2017.03.03.11.49.33;	author schwarze;	state Exp;
branches;
next	1.161;
commitid	1H5H2zEdUsAUhnfd;

1.161
date	2017.02.17.03.01.39;	author schwarze;	state Exp;
branches;
next	1.160;
commitid	O5xxdhbA9fDXbANL;

1.160
date	2017.01.12.18.02.24;	author schwarze;	state Exp;
branches;
next	1.159;
commitid	zr5SnmgTWagH0rHe;

1.159
date	2017.01.10.21.54.34;	author schwarze;	state Exp;
branches;
next	1.158;
commitid	iaEy6J4gJ8kh18cm;

1.158
date	2017.01.10.14.09.03;	author schwarze;	state Exp;
branches;
next	1.157;
commitid	sEUuUVzUG4x1Cm92;

1.157
date	2017.01.10.13.46.53;	author schwarze;	state Exp;
branches;
next	1.156;
commitid	aFt8sLe7F06PjFYh;

1.156
date	2016.01.08.17.48.04;	author schwarze;	state Exp;
branches;
next	1.155;
commitid	DoGoemryKYV644MI;

1.155
date	2015.10.22.21.53.49;	author schwarze;	state Exp;
branches;
next	1.154;
commitid	b31415iHGGouYvkz;

1.154
date	2015.10.21.23.49.05;	author schwarze;	state Exp;
branches;
next	1.153;
commitid	shiLX2ph584rkqmV;

1.153
date	2015.10.20.02.00.50;	author schwarze;	state Exp;
branches;
next	1.152;
commitid	v6RrmxwM663z4mTF;

1.152
date	2015.10.15.23.35.38;	author schwarze;	state Exp;
branches;
next	1.151;
commitid	ZZYY6Czx66FgtwMk;

1.151
date	2015.10.13.22.57.49;	author schwarze;	state Exp;
branches;
next	1.150;
commitid	jXIG8UzKLXm2Z9i6;

1.150
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.149;
commitid	Ql2ha5NS80pwfGNT;

1.149
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.148;
commitid	hxQV8O1pNUaef4ir;

1.148
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.147;
commitid	191tWtskbsgcpQqV;

1.147
date	2015.08.29.23.55.53;	author schwarze;	state Exp;
branches;
next	1.146;
commitid	omcLxGpjSygulztm;

1.146
date	2015.08.29.21.37.11;	author schwarze;	state Exp;
branches;
next	1.145;
commitid	W2KOqVilZJ9avCRg;

1.145
date	2015.08.29.20.24.34;	author schwarze;	state Exp;
branches;
next	1.144;
commitid	garA3ZzWdZ74bO1V;

1.144
date	2015.06.27.13.25.30;	author schwarze;	state Exp;
branches;
next	1.143;
commitid	o44IQyqlebXS5v4c;

1.143
date	2015.05.31.23.12.16;	author schwarze;	state Exp;
branches;
next	1.142;
commitid	LI7iM1p3QpsGk8nB;

1.142
date	2015.05.01.16.01.53;	author schwarze;	state Exp;
branches;
next	1.141;
commitid	Z9Pokbi3EU6dbOos;

1.141
date	2015.04.23.16.17.04;	author schwarze;	state Exp;
branches;
next	1.140;
commitid	DWHgiJTn6DvDpekX;

1.140
date	2015.04.19.14.57.16;	author schwarze;	state Exp;
branches;
next	1.139;
commitid	FaoA4UzPphKw0cyB;

1.139
date	2015.04.19.14.25.05;	author schwarze;	state Exp;
branches;
next	1.138;
commitid	E1gJfKuheBoo64Vb;

1.138
date	2015.04.19.13.50.10;	author schwarze;	state Exp;
branches;
next	1.137;
commitid	QSaLMe5iBgPB4hUe;

1.137
date	2015.04.18.17.28.08;	author schwarze;	state Exp;
branches;
next	1.136;
commitid	zD52rmYwzwgofy8v;

1.136
date	2015.04.04.13.52.59;	author schwarze;	state Exp;
branches;
next	1.135;
commitid	H8QD2cQfDJtJZRVF;

1.135
date	2015.02.21.14.46.33;	author schwarze;	state Exp;
branches;
next	1.134;
commitid	ANhezdEKR3pAmsQ7;

1.134
date	2015.02.17.17.55.12;	author schwarze;	state Exp;
branches;
next	1.133;
commitid	zjdyug6hqjQybPuq;

1.133
date	2015.02.17.17.16.12;	author schwarze;	state Exp;
branches;
next	1.132;
commitid	OFJD5u0rlv8RzJvR;

1.132
date	2015.02.06.16.05.51;	author schwarze;	state Exp;
branches;
next	1.131;
commitid	Bj9alpGWXCQILmH9;

1.131
date	2015.01.30.00.19.26;	author schwarze;	state Exp;
branches;
next	1.130;
commitid	DKDLMx5b7EoPZ5e8;

1.130
date	2015.01.28.17.30.37;	author schwarze;	state Exp;
branches;
next	1.129;
commitid	B9i4oMLogJsiyrd5;

1.129
date	2015.01.28.15.02.25;	author schwarze;	state Exp;
branches;
next	1.128;
commitid	Um2gz4HrZv1IOy6F;

1.128
date	2015.01.24.02.41.32;	author schwarze;	state Exp;
branches;
next	1.127;
commitid	TIJT04XdY4be3Or5;

1.127
date	2015.01.23.20.17.25;	author schwarze;	state Exp;
branches;
next	1.126;
commitid	RaU9eiJgbWR4z9Sc;

1.126
date	2015.01.23.00.38.42;	author schwarze;	state Exp;
branches;
next	1.125;
commitid	nzPhVsQa0WQJ7Tyu;

1.125
date	2015.01.22.22.50.31;	author schwarze;	state Exp;
branches;
next	1.124;
commitid	VJcgMm6nLxuBTwFa;

1.124
date	2015.01.21.02.16.11;	author schwarze;	state Exp;
branches;
next	1.123;
commitid	DlysXJnTbGxFKwLI;

1.123
date	2015.01.20.21.12.46;	author schwarze;	state Exp;
branches;
next	1.122;
commitid	yL1piccWr1moLOpy;

1.122
date	2015.01.16.16.52.39;	author schwarze;	state Exp;
branches;
next	1.121;
commitid	a3pvIbTlibjLtRgw;

1.121
date	2015.01.14.22.57.57;	author schwarze;	state Exp;
branches;
next	1.120;
commitid	pB8ZvBlUeO92L1BP;

1.120
date	2015.01.07.12.19.17;	author schwarze;	state Exp;
branches;
next	1.119;
commitid	Uhmq3PK0fBjvMjMc;

1.119
date	2015.01.01.19.28.29;	author schwarze;	state Exp;
branches;
next	1.118;
commitid	Qmz82PR6kmeVFoDy;

1.118
date	2014.12.28.14.16.07;	author schwarze;	state Exp;
branches;
next	1.117;
commitid	qYukdS3OHCfcCcLL;

1.117
date	2014.12.25.17.18.40;	author schwarze;	state Exp;
branches;
next	1.116;
commitid	x8yeuHYTp1C1IKJI;

1.116
date	2014.12.18.17.43.07;	author schwarze;	state Exp;
branches;
next	1.115;
commitid	799XcRPZtFFR5Ih8;

1.115
date	2014.12.16.23.44.16;	author schwarze;	state Exp;
branches;
next	1.114;
commitid	r7Pkn5lMmGIVLeBR;

1.114
date	2014.12.16.03.52.31;	author schwarze;	state Exp;
branches;
next	1.113;
commitid	Cph3Q0TRvxxeTtt7;

1.113
date	2014.12.16.01.21.37;	author schwarze;	state Exp;
branches;
next	1.112;
commitid	tQ5akar4jZojCYGJ;

1.112
date	2014.12.15.23.42.31;	author schwarze;	state Exp;
branches;
next	1.111;
commitid	zjLcNiczZDP7qYu5;

1.111
date	2014.11.19.01.20.18;	author schwarze;	state Exp;
branches;
next	1.110;
commitid	K22eowDUnG23Ymz9;

1.110
date	2014.11.01.06.02.43;	author schwarze;	state Exp;
branches;
next	1.109;
commitid	3fBnp5rg5xbTeWnZ;

1.109
date	2014.10.28.17.35.42;	author schwarze;	state Exp;
branches;
next	1.108;
commitid	pNwmOla3ZQwLgu2f;

1.108
date	2014.10.25.15.23.25;	author schwarze;	state Exp;
branches;
next	1.107;
commitid	IOTAcvn9jmdmlFmh;

1.107
date	2014.10.25.14.32.07;	author schwarze;	state Exp;
branches;
next	1.106;
commitid	0lmH8qIaoxl2FlKf;

1.106
date	2014.10.20.19.21.31;	author schwarze;	state Exp;
branches;
next	1.105;
commitid	7LDoViU00JgOAI7G;

1.105
date	2014.10.20.15.04.37;	author schwarze;	state Exp;
branches;
next	1.104;
commitid	RPnN3Sr675COITtw;

1.104
date	2014.10.20.02.31.44;	author schwarze;	state Exp;
branches;
next	1.103;
commitid	jVScYQL5VkcOk52z;

1.103
date	2014.10.16.01.27.48;	author schwarze;	state Exp;
branches;
next	1.102;
commitid	8sREjp0N7bEt7mXh;

1.102
date	2014.10.16.01.10.06;	author schwarze;	state Exp;
branches;
next	1.101;
commitid	3N6FMKugsVoc1dko;

1.101
date	2014.09.07.00.21.23;	author schwarze;	state Exp;
branches;
next	1.100;
commitid	7q4cteBLaUEM9Gca;

1.100
date	2014.09.06.23.24.27;	author schwarze;	state Exp;
branches;
next	1.99;
commitid	cVS8Yl9euSk9Ay5F;

1.99
date	2014.09.06.22.38.35;	author schwarze;	state Exp;
branches;
next	1.98;
commitid	TDPFPNCkor60BTJO;

1.98
date	2014.08.19.05.18.16;	author daniel;	state Exp;
branches;
next	1.97;
commitid	KvrTNw6N0919qpqw;

1.97
date	2014.08.08.15.54.10;	author schwarze;	state Exp;
branches;
next	1.96;
commitid	yBKHNskikm52fHMo;

1.96
date	2014.08.08.15.48.43;	author schwarze;	state Exp;
branches;
next	1.95;
commitid	G8BpeOpuFhU22sI2;

1.95
date	2014.08.08.15.15.27;	author schwarze;	state Exp;
branches;
next	1.94;
commitid	fgZ1S3QYW6RU4QWI;

1.94
date	2014.07.07.21.35.42;	author schwarze;	state Exp;
branches;
next	1.93;
commitid	O2S43bw50KTGcriR;

1.93
date	2014.07.07.11.34.41;	author schwarze;	state Exp;
branches;
next	1.92;
commitid	SxiKID1BRkm7SsXU;

1.92
date	2014.07.06.19.08.56;	author schwarze;	state Exp;
branches;
next	1.91;
commitid	rolX8OitNNoUBJoD;

1.91
date	2014.07.06.18.46.51;	author schwarze;	state Exp;
branches;
next	1.90;
commitid	AyMIDY05fx2kBW39;

1.90
date	2014.07.04.16.11.41;	author schwarze;	state Exp;
branches;
next	1.89;
commitid	sgqZ9hnRM3L6yvgn;

1.89
date	2014.07.03.21.23.08;	author schwarze;	state Exp;
branches;
next	1.88;
commitid	fILxF31MgcuaKrF8;

1.88
date	2014.07.01.00.32.02;	author schwarze;	state Exp;
branches;
next	1.87;
commitid	WpYqQEl7uLoW6c5R;

1.87
date	2014.06.29.23.23.16;	author schwarze;	state Exp;
branches;
next	1.86;
commitid	reFB2LXVMqk7piJJ;

1.86
date	2014.06.29.22.38.41;	author schwarze;	state Exp;
branches;
next	1.85;
commitid	TfqYy8KA31gg1MSK;

1.85
date	2014.06.29.22.12.54;	author schwarze;	state Exp;
branches;
next	1.84;
commitid	0q8PJtpXMYCyUZJE;

1.84
date	2014.06.29.21.19.34;	author schwarze;	state Exp;
branches;
next	1.83;
commitid	l57OfKpGuDZcv2cP;

1.83
date	2014.06.25.00.19.17;	author schwarze;	state Exp;
branches;
next	1.82;
commitid	JeAYFU7kC8rIy3dQ;

1.82
date	2014.04.23.16.07.06;	author schwarze;	state Exp;
branches;
next	1.81;

1.81
date	2014.04.20.19.39.35;	author schwarze;	state Exp;
branches;
next	1.80;

1.80
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.79;

1.79
date	2014.04.08.01.36.50;	author schwarze;	state Exp;
branches;
next	1.78;

1.78
date	2014.04.07.21.00.00;	author schwarze;	state Exp;
branches;
next	1.77;

1.77
date	2014.04.07.15.05.12;	author schwarze;	state Exp;
branches;
next	1.76;

1.76
date	2014.04.05.20.33.38;	author schwarze;	state Exp;
branches;
next	1.75;

1.75
date	2014.03.21.22.52.21;	author schwarze;	state Exp;
branches;
next	1.74;

1.74
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.73;

1.73
date	2014.03.20.02.57.13;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2014.03.19.21.50.59;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2014.03.08.04.43.39;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2014.03.07.18.37.32;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2014.03.07.17.57.28;	author schwarze;	state Exp;
branches;
next	1.68;

1.68
date	2014.03.07.02.21.55;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2014.02.14.23.24.17;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2014.02.14.23.05.08;	author schwarze;	state Exp;
branches;
next	1.65;

1.65
date	2014.02.14.22.27.32;	author schwarze;	state Exp;
branches;
next	1.64;

1.64
date	2014.01.06.23.46.01;	author schwarze;	state Exp;
branches;
next	1.63;

1.63
date	2014.01.06.21.33.00;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2013.12.30.18.42.55;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2013.12.25.00.50.03;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2013.12.15.21.18.00;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2013.10.22.20.37.54;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2013.10.14.01.42.26;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2013.10.05.21.17.29;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2013.10.04.02.01.58;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2013.10.03.22.56.18;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2013.10.03.22.50.02;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2013.10.03.22.04.08;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2013.10.03.19.32.25;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2013.07.13.12.51.38;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2013.06.27.09.48.22;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2013.05.31.22.08.03;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2012.07.07.18.27.36;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2012.06.02.23.18.30;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2012.05.31.01.36.56;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2011.10.24.21.38.56;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2011.09.19.07.53.54;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2011.09.18.23.26.18;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.31.14.11.48;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2011.07.07.20.07.38;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2011.07.05.04.12.41;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2011.04.24.16.28.48;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.05.22.19.11;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2011.03.20.23.36.42;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2011.01.25.00.23.23;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.20.21.33.11;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2011.01.12.20.56.40;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.10.23.53.32;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.03.23.19.33;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2011.01.03.22.27.21;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2010.12.21.01.30.58;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2010.12.09.20.56.30;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2010.12.07.00.08.52;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2010.11.28.19.35.33;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2010.11.28.01.00.40;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2010.11.27.20.52.34;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2010.11.25.23.07.58;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2010.11.25.22.41.51;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2010.11.25.22.23.31;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.26.23.34.38;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.26.22.28.57;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.27.21.25.28;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.13.22.04.01;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.20.00.53.35;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.31.21.43.07;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.03.15.59.05;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.27.21.54.42;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.26.17.56.43;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.06.20.30.08;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.06.18.08.41;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.20.00.58.02;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.16.00.54.03;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.192
log
@fix an assertion failure triggered by .ce in next-line scope;
found by jsg@@ with afl(1)
@
text
@/*	$OpenBSD: roff.c,v 1.191 2017/07/08 14:51:01 schwarze Exp $ */
/*
 * Copyright (c) 2008-2012, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010-2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc.h"
#include "mandoc_aux.h"
#include "mandoc_ohash.h"
#include "roff.h"
#include "libmandoc.h"
#include "roff_int.h"
#include "libroff.h"

/* Maximum number of string expansions per line, to break infinite loops. */
#define	EXPAND_LIMIT	1000

/* Types of definitions of macros and strings. */
#define	ROFFDEF_USER	(1 << 1)  /* User-defined. */
#define	ROFFDEF_PRE	(1 << 2)  /* Predefined. */
#define	ROFFDEF_REN	(1 << 3)  /* Renamed standard macro. */
#define	ROFFDEF_STD	(1 << 4)  /* mdoc(7) or man(7) macro. */
#define	ROFFDEF_ANY	(ROFFDEF_USER | ROFFDEF_PRE | \
			 ROFFDEF_REN | ROFFDEF_STD)

/* --- data types --------------------------------------------------------- */

/*
 * An incredibly-simple string buffer.
 */
struct	roffstr {
	char		*p; /* nil-terminated buffer */
	size_t		 sz; /* saved strlen(p) */
};

/*
 * A key-value roffstr pair as part of a singly-linked list.
 */
struct	roffkv {
	struct roffstr	 key;
	struct roffstr	 val;
	struct roffkv	*next; /* next in list */
};

/*
 * A single number register as part of a singly-linked list.
 */
struct	roffreg {
	struct roffstr	 key;
	int		 val;
	struct roffreg	*next;
};

/*
 * Association of request and macro names with token IDs.
 */
struct	roffreq {
	enum roff_tok	 tok;
	char		 name[];
};

struct	roff {
	struct mparse	*parse; /* parse point */
	struct roff_man	*man; /* mdoc or man parser */
	struct roffnode	*last; /* leaf of stack */
	int		*rstack; /* stack of inverted `ie' values */
	struct ohash	*reqtab; /* request lookup table */
	struct roffreg	*regtab; /* number registers */
	struct roffkv	*strtab; /* user-defined strings & macros */
	struct roffkv	*rentab; /* renamed strings & macros */
	struct roffkv	*xmbtab; /* multi-byte trans table (`tr') */
	struct roffstr	*xtab; /* single-byte trans table (`tr') */
	const char	*current_string; /* value of last called user macro */
	struct tbl_node	*first_tbl; /* first table parsed */
	struct tbl_node	*last_tbl; /* last table parsed */
	struct tbl_node	*tbl; /* current table being parsed */
	struct eqn_node	*last_eqn; /* equation parser */
	struct eqn_node	*eqn; /* active equation parser */
	int		 eqn_inline; /* current equation is inline */
	int		 options; /* parse options */
	int		 rstacksz; /* current size limit of rstack */
	int		 rstackpos; /* position in rstack */
	int		 format; /* current file in mdoc or man format */
	int		 argc; /* number of args of the last macro */
	char		 control; /* control character */
	char		 escape; /* escape character */
};

struct	roffnode {
	enum roff_tok	 tok; /* type of node */
	struct roffnode	*parent; /* up one in stack */
	int		 line; /* parse line */
	int		 col; /* parse col */
	char		*name; /* node name, e.g. macro name */
	char		*end; /* end-rules: custom token */
	int		 endspan; /* end-rules: next-line or infty */
	int		 rule; /* current evaluation rule */
};

#define	ROFF_ARGS	 struct roff *r, /* parse ctx */ \
			 enum roff_tok tok, /* tok of macro */ \
			 struct buf *buf, /* input buffer */ \
			 int ln, /* parse line */ \
			 int ppos, /* original pos in buffer */ \
			 int pos, /* current pos in buffer */ \
			 int *offs /* reset offset of buffer data */

typedef	enum rofferr (*roffproc)(ROFF_ARGS);

struct	roffmac {
	roffproc	 proc; /* process new macro */
	roffproc	 text; /* process as child text of macro */
	roffproc	 sub; /* process as child of macro */
	int		 flags;
#define	ROFFMAC_STRUCT	(1 << 0) /* always interpret */
};

struct	predef {
	const char	*name; /* predefined input name */
	const char	*str; /* replacement symbol */
};

#define	PREDEF(__name, __str) \
	{ (__name), (__str) },

/* --- function prototypes ------------------------------------------------ */

static	void		 roffnode_cleanscope(struct roff *);
static	void		 roffnode_pop(struct roff *);
static	void		 roffnode_push(struct roff *, enum roff_tok,
				const char *, int, int);
static	enum rofferr	 roff_als(ROFF_ARGS);
static	enum rofferr	 roff_block(ROFF_ARGS);
static	enum rofferr	 roff_block_text(ROFF_ARGS);
static	enum rofferr	 roff_block_sub(ROFF_ARGS);
static	enum rofferr	 roff_br(ROFF_ARGS);
static	enum rofferr	 roff_cblock(ROFF_ARGS);
static	enum rofferr	 roff_cc(ROFF_ARGS);
static	void		 roff_ccond(struct roff *, int, int);
static	enum rofferr	 roff_cond(ROFF_ARGS);
static	enum rofferr	 roff_cond_text(ROFF_ARGS);
static	enum rofferr	 roff_cond_sub(ROFF_ARGS);
static	enum rofferr	 roff_ds(ROFF_ARGS);
static	enum rofferr	 roff_ec(ROFF_ARGS);
static	enum rofferr	 roff_eo(ROFF_ARGS);
static	enum rofferr	 roff_eqndelim(struct roff *, struct buf *, int);
static	int		 roff_evalcond(struct roff *r, int, char *, int *);
static	int		 roff_evalnum(struct roff *, int,
				const char *, int *, int *, int);
static	int		 roff_evalpar(struct roff *, int,
				const char *, int *, int *, int);
static	int		 roff_evalstrcond(const char *, int *);
static	void		 roff_free1(struct roff *);
static	void		 roff_freereg(struct roffreg *);
static	void		 roff_freestr(struct roffkv *);
static	size_t		 roff_getname(struct roff *, char **, int, int);
static	int		 roff_getnum(const char *, int *, int *, int);
static	int		 roff_getop(const char *, int *, char *);
static	int		 roff_getregn(const struct roff *,
				const char *, size_t);
static	int		 roff_getregro(const struct roff *,
				const char *name);
static	const char	*roff_getstrn(const struct roff *,
				const char *, size_t, int *);
static	int		 roff_hasregn(const struct roff *,
				const char *, size_t);
static	enum rofferr	 roff_insec(ROFF_ARGS);
static	enum rofferr	 roff_it(ROFF_ARGS);
static	enum rofferr	 roff_line_ignore(ROFF_ARGS);
static	void		 roff_man_alloc1(struct roff_man *);
static	void		 roff_man_free1(struct roff_man *);
static	enum rofferr	 roff_manyarg(ROFF_ARGS);
static	enum rofferr	 roff_nr(ROFF_ARGS);
static	enum rofferr	 roff_onearg(ROFF_ARGS);
static	enum roff_tok	 roff_parse(struct roff *, char *, int *,
				int, int);
static	enum rofferr	 roff_parsetext(struct roff *, struct buf *,
				int, int *);
static	enum rofferr	 roff_renamed(ROFF_ARGS);
static	enum rofferr	 roff_res(struct roff *, struct buf *, int, int);
static	enum rofferr	 roff_rm(ROFF_ARGS);
static	enum rofferr	 roff_rn(ROFF_ARGS);
static	enum rofferr	 roff_rr(ROFF_ARGS);
static	void		 roff_setstr(struct roff *,
				const char *, const char *, int);
static	void		 roff_setstrn(struct roffkv **, const char *,
				size_t, const char *, size_t, int);
static	enum rofferr	 roff_so(ROFF_ARGS);
static	enum rofferr	 roff_tr(ROFF_ARGS);
static	enum rofferr	 roff_Dd(ROFF_ARGS);
static	enum rofferr	 roff_TE(ROFF_ARGS);
static	enum rofferr	 roff_TS(ROFF_ARGS);
static	enum rofferr	 roff_EQ(ROFF_ARGS);
static	enum rofferr	 roff_EN(ROFF_ARGS);
static	enum rofferr	 roff_T_(ROFF_ARGS);
static	enum rofferr	 roff_unsupp(ROFF_ARGS);
static	enum rofferr	 roff_userdef(ROFF_ARGS);

/* --- constant data ------------------------------------------------------ */

#define	ROFFNUM_SCALE	(1 << 0)  /* Honour scaling in roff_getnum(). */
#define	ROFFNUM_WHITE	(1 << 1)  /* Skip whitespace in roff_evalnum(). */

const char *__roff_name[MAN_MAX + 1] = {
	"br",		"ce",		"ft",		"ll",
	"mc",		"po",		"rj",		"sp",
	"ta",		"ti",		NULL,
	"ab",		"ad",		"af",		"aln",
	"als",		"am",		"am1",		"ami",
	"ami1",		"as",		"as1",		"asciify",
	"backtrace",	"bd",		"bleedat",	"blm",
        "box",		"boxa",		"bp",		"BP",
	"break",	"breakchar",	"brnl",		"brp",
	"brpnl",	"c2",		"cc",
	"cf",		"cflags",	"ch",		"char",
	"chop",		"class",	"close",	"CL",
	"color",	"composite",	"continue",	"cp",
	"cropat",	"cs",		"cu",		"da",
	"dch",		"Dd",		"de",		"de1",
	"defcolor",	"dei",		"dei1",		"device",
	"devicem",	"di",		"do",		"ds",
	"ds1",		"dwh",		"dt",		"ec",
	"ecr",		"ecs",		"el",		"em",
	"EN",		"eo",		"EP",		"EQ",
	"errprint",	"ev",		"evc",		"ex",
	"fallback",	"fam",		"fc",		"fchar",
	"fcolor",	"fdeferlig",	"feature",	"fkern",
	"fl",		"flig",		"fp",		"fps",
	"fschar",	"fspacewidth",	"fspecial",	"ftr",
	"fzoom",	"gcolor",	"hc",		"hcode",
	"hidechar",	"hla",		"hlm",		"hpf",
	"hpfa",		"hpfcode",	"hw",		"hy",
	"hylang",	"hylen",	"hym",		"hypp",
	"hys",		"ie",		"if",		"ig",
	"index",	"it",		"itc",		"IX",
	"kern",		"kernafter",	"kernbefore",	"kernpair",
	"lc",		"lc_ctype",	"lds",		"length",
	"letadj",	"lf",		"lg",		"lhang",
	"linetabs",	"lnr",		"lnrf",		"lpfx",
	"ls",		"lsm",		"lt",
	"mediasize",	"minss",	"mk",		"mso",
	"na",		"ne",		"nh",		"nhychar",
	"nm",		"nn",		"nop",		"nr",
	"nrf",		"nroff",	"ns",		"nx",
	"open",		"opena",	"os",		"output",
	"padj",		"papersize",	"pc",		"pev",
	"pi",		"PI",		"pl",		"pm",
	"pn",		"pnr",		"ps",
	"psbb",		"pshape",	"pso",		"ptr",
	"pvs",		"rchar",	"rd",		"recursionlimit",
	"return",	"rfschar",	"rhang",
	"rm",		"rn",		"rnn",		"rr",
	"rs",		"rt",		"schar",	"sentchar",
	"shc",		"shift",	"sizes",	"so",
	"spacewidth",	"special",	"spreadwarn",	"ss",
	"sty",		"substring",	"sv",		"sy",
	"T&",		"tc",		"TE",
	"TH",		"tkf",		"tl",
	"tm",		"tm1",		"tmc",		"tr",
	"track",	"transchar",	"trf",		"trimat",
	"trin",		"trnt",		"troff",	"TS",
	"uf",		"ul",		"unformat",	"unwatch",
	"unwatchn",	"vpt",		"vs",		"warn",
	"warnscale",	"watch",	"watchlength",	"watchn",
	"wh",		"while",	"write",	"writec",
	"writem",	"xflag",	".",		NULL,
	NULL,		"text",
	"Dd",		"Dt",		"Os",		"Sh",
	"Ss",		"Pp",		"D1",		"Dl",
	"Bd",		"Ed",		"Bl",		"El",
	"It",		"Ad",		"An",		"Ap",
	"Ar",		"Cd",		"Cm",		"Dv",
	"Er",		"Ev",		"Ex",		"Fa",
	"Fd",		"Fl",		"Fn",		"Ft",
	"Ic",		"In",		"Li",		"Nd",
	"Nm",		"Op",		"Ot",		"Pa",
	"Rv",		"St",		"Va",		"Vt",
	"Xr",		"%A",		"%B",		"%D",
	"%I",		"%J",		"%N",		"%O",
	"%P",		"%R",		"%T",		"%V",
	"Ac",		"Ao",		"Aq",		"At",
	"Bc",		"Bf",		"Bo",		"Bq",
	"Bsx",		"Bx",		"Db",		"Dc",
	"Do",		"Dq",		"Ec",		"Ef",
	"Em",		"Eo",		"Fx",		"Ms",
	"No",		"Ns",		"Nx",		"Ox",
	"Pc",		"Pf",		"Po",		"Pq",
	"Qc",		"Ql",		"Qo",		"Qq",
	"Re",		"Rs",		"Sc",		"So",
	"Sq",		"Sm",		"Sx",		"Sy",
	"Tn",		"Ux",		"Xc",		"Xo",
	"Fo",		"Fc",		"Oo",		"Oc",
	"Bk",		"Ek",		"Bt",		"Hf",
	"Fr",		"Ud",		"Lb",		"Lp",
	"Lk",		"Mt",		"Brq",		"Bro",
	"Brc",		"%C",		"Es",		"En",
	"Dx",		"%Q",		"%U",		"Ta",
	NULL,
	"TH",		"SH",		"SS",		"TP",
	"LP",		"PP",		"P",		"IP",
	"HP",		"SM",		"SB",		"BI",
	"IB",		"BR",		"RB",		"R",
	"B",		"I",		"IR",		"RI",
	"nf",		"fi",
	"RE",		"RS",		"DT",		"UC",
	"PD",		"AT",		"in",
	"OP",		"EX",		"EE",		"UR",
	"UE",		"MT",		"ME",		NULL
};
const	char *const *roff_name = __roff_name;

static	struct roffmac	 roffs[TOKEN_NONE] = {
	{ roff_br, NULL, NULL, 0 },  /* br */
	{ roff_onearg, NULL, NULL, 0 },  /* ce */
	{ roff_onearg, NULL, NULL, 0 },  /* ft */
	{ roff_onearg, NULL, NULL, 0 },  /* ll */
	{ roff_onearg, NULL, NULL, 0 },  /* mc */
	{ roff_onearg, NULL, NULL, 0 },  /* po */
	{ roff_onearg, NULL, NULL, 0 },  /* rj */
	{ roff_onearg, NULL, NULL, 0 },  /* sp */
	{ roff_manyarg, NULL, NULL, 0 },  /* ta */
	{ roff_onearg, NULL, NULL, 0 },  /* ti */
	{ NULL, NULL, NULL, 0 },  /* ROFF_MAX */
	{ roff_unsupp, NULL, NULL, 0 },  /* ab */
	{ roff_line_ignore, NULL, NULL, 0 },  /* ad */
	{ roff_line_ignore, NULL, NULL, 0 },  /* af */
	{ roff_unsupp, NULL, NULL, 0 },  /* aln */
	{ roff_als, NULL, NULL, 0 },  /* als */
	{ roff_block, roff_block_text, roff_block_sub, 0 },  /* am */
	{ roff_block, roff_block_text, roff_block_sub, 0 },  /* am1 */
	{ roff_block, roff_block_text, roff_block_sub, 0 },  /* ami */
	{ roff_block, roff_block_text, roff_block_sub, 0 },  /* ami1 */
	{ roff_ds, NULL, NULL, 0 },  /* as */
	{ roff_ds, NULL, NULL, 0 },  /* as1 */
	{ roff_unsupp, NULL, NULL, 0 },  /* asciify */
	{ roff_line_ignore, NULL, NULL, 0 },  /* backtrace */
	{ roff_line_ignore, NULL, NULL, 0 },  /* bd */
	{ roff_line_ignore, NULL, NULL, 0 },  /* bleedat */
	{ roff_unsupp, NULL, NULL, 0 },  /* blm */
	{ roff_unsupp, NULL, NULL, 0 },  /* box */
	{ roff_unsupp, NULL, NULL, 0 },  /* boxa */
	{ roff_line_ignore, NULL, NULL, 0 },  /* bp */
	{ roff_unsupp, NULL, NULL, 0 },  /* BP */
	{ roff_unsupp, NULL, NULL, 0 },  /* break */
	{ roff_line_ignore, NULL, NULL, 0 },  /* breakchar */
	{ roff_line_ignore, NULL, NULL, 0 },  /* brnl */
	{ roff_br, NULL, NULL, 0 },  /* brp */
	{ roff_line_ignore, NULL, NULL, 0 },  /* brpnl */
	{ roff_unsupp, NULL, NULL, 0 },  /* c2 */
	{ roff_cc, NULL, NULL, 0 },  /* cc */
	{ roff_insec, NULL, NULL, 0 },  /* cf */
	{ roff_line_ignore, NULL, NULL, 0 },  /* cflags */
	{ roff_line_ignore, NULL, NULL, 0 },  /* ch */
	{ roff_unsupp, NULL, NULL, 0 },  /* char */
	{ roff_unsupp, NULL, NULL, 0 },  /* chop */
	{ roff_line_ignore, NULL, NULL, 0 },  /* class */
	{ roff_insec, NULL, NULL, 0 },  /* close */
	{ roff_unsupp, NULL, NULL, 0 },  /* CL */
	{ roff_line_ignore, NULL, NULL, 0 },  /* color */
	{ roff_unsupp, NULL, NULL, 0 },  /* composite */
	{ roff_unsupp, NULL, NULL, 0 },  /* continue */
	{ roff_line_ignore, NULL, NULL, 0 },  /* cp */
	{ roff_line_ignore, NULL, NULL, 0 },  /* cropat */
	{ roff_line_ignore, NULL, NULL, 0 },  /* cs */
	{ roff_line_ignore, NULL, NULL, 0 },  /* cu */
	{ roff_unsupp, NULL, NULL, 0 },  /* da */
	{ roff_unsupp, NULL, NULL, 0 },  /* dch */
	{ roff_Dd, NULL, NULL, 0 },  /* Dd */
	{ roff_block, roff_block_text, roff_block_sub, 0 },  /* de */
	{ roff_block, roff_block_text, roff_block_sub, 0 },  /* de1 */
	{ roff_line_ignore, NULL, NULL, 0 },  /* defcolor */
	{ roff_block, roff_block_text, roff_block_sub, 0 },  /* dei */
	{ roff_block, roff_block_text, roff_block_sub, 0 },  /* dei1 */
	{ roff_unsupp, NULL, NULL, 0 },  /* device */
	{ roff_unsupp, NULL, NULL, 0 },  /* devicem */
	{ roff_unsupp, NULL, NULL, 0 },  /* di */
	{ roff_unsupp, NULL, NULL, 0 },  /* do */
	{ roff_ds, NULL, NULL, 0 },  /* ds */
	{ roff_ds, NULL, NULL, 0 },  /* ds1 */
	{ roff_unsupp, NULL, NULL, 0 },  /* dwh */
	{ roff_unsupp, NULL, NULL, 0 },  /* dt */
	{ roff_ec, NULL, NULL, 0 },  /* ec */
	{ roff_unsupp, NULL, NULL, 0 },  /* ecr */
	{ roff_unsupp, NULL, NULL, 0 },  /* ecs */
	{ roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT },  /* el */
	{ roff_unsupp, NULL, NULL, 0 },  /* em */
	{ roff_EN, NULL, NULL, 0 },  /* EN */
	{ roff_eo, NULL, NULL, 0 },  /* eo */
	{ roff_unsupp, NULL, NULL, 0 },  /* EP */
	{ roff_EQ, NULL, NULL, 0 },  /* EQ */
	{ roff_line_ignore, NULL, NULL, 0 },  /* errprint */
	{ roff_unsupp, NULL, NULL, 0 },  /* ev */
	{ roff_unsupp, NULL, NULL, 0 },  /* evc */
	{ roff_unsupp, NULL, NULL, 0 },  /* ex */
	{ roff_line_ignore, NULL, NULL, 0 },  /* fallback */
	{ roff_line_ignore, NULL, NULL, 0 },  /* fam */
	{ roff_unsupp, NULL, NULL, 0 },  /* fc */
	{ roff_unsupp, NULL, NULL, 0 },  /* fchar */
	{ roff_line_ignore, NULL, NULL, 0 },  /* fcolor */
	{ roff_line_ignore, NULL, NULL, 0 },  /* fdeferlig */
	{ roff_line_ignore, NULL, NULL, 0 },  /* feature */
	{ roff_line_ignore, NULL, NULL, 0 },  /* fkern */
	{ roff_line_ignore, NULL, NULL, 0 },  /* fl */
	{ roff_line_ignore, NULL, NULL, 0 },  /* flig */
	{ roff_line_ignore, NULL, NULL, 0 },  /* fp */
	{ roff_line_ignore, NULL, NULL, 0 },  /* fps */
	{ roff_unsupp, NULL, NULL, 0 },  /* fschar */
	{ roff_line_ignore, NULL, NULL, 0 },  /* fspacewidth */
	{ roff_line_ignore, NULL, NULL, 0 },  /* fspecial */
	{ roff_line_ignore, NULL, NULL, 0 },  /* ftr */
	{ roff_line_ignore, NULL, NULL, 0 },  /* fzoom */
	{ roff_line_ignore, NULL, NULL, 0 },  /* gcolor */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hc */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hcode */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hidechar */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hla */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hlm */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hpf */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hpfa */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hpfcode */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hw */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hy */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hylang */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hylen */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hym */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hypp */
	{ roff_line_ignore, NULL, NULL, 0 },  /* hys */
	{ roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT },  /* ie */
	{ roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT },  /* if */
	{ roff_block, roff_block_text, roff_block_sub, 0 },  /* ig */
	{ roff_unsupp, NULL, NULL, 0 },  /* index */
	{ roff_it, NULL, NULL, 0 },  /* it */
	{ roff_unsupp, NULL, NULL, 0 },  /* itc */
	{ roff_line_ignore, NULL, NULL, 0 },  /* IX */
	{ roff_line_ignore, NULL, NULL, 0 },  /* kern */
	{ roff_line_ignore, NULL, NULL, 0 },  /* kernafter */
	{ roff_line_ignore, NULL, NULL, 0 },  /* kernbefore */
	{ roff_line_ignore, NULL, NULL, 0 },  /* kernpair */
	{ roff_unsupp, NULL, NULL, 0 },  /* lc */
	{ roff_unsupp, NULL, NULL, 0 },  /* lc_ctype */
	{ roff_unsupp, NULL, NULL, 0 },  /* lds */
	{ roff_unsupp, NULL, NULL, 0 },  /* length */
	{ roff_line_ignore, NULL, NULL, 0 },  /* letadj */
	{ roff_insec, NULL, NULL, 0 },  /* lf */
	{ roff_line_ignore, NULL, NULL, 0 },  /* lg */
	{ roff_line_ignore, NULL, NULL, 0 },  /* lhang */
	{ roff_unsupp, NULL, NULL, 0 },  /* linetabs */
	{ roff_unsupp, NULL, NULL, 0 },  /* lnr */
	{ roff_unsupp, NULL, NULL, 0 },  /* lnrf */
	{ roff_unsupp, NULL, NULL, 0 },  /* lpfx */
	{ roff_line_ignore, NULL, NULL, 0 },  /* ls */
	{ roff_unsupp, NULL, NULL, 0 },  /* lsm */
	{ roff_line_ignore, NULL, NULL, 0 },  /* lt */
	{ roff_line_ignore, NULL, NULL, 0 },  /* mediasize */
	{ roff_line_ignore, NULL, NULL, 0 },  /* minss */
	{ roff_line_ignore, NULL, NULL, 0 },  /* mk */
	{ roff_insec, NULL, NULL, 0 },  /* mso */
	{ roff_line_ignore, NULL, NULL, 0 },  /* na */
	{ roff_line_ignore, NULL, NULL, 0 },  /* ne */
	{ roff_line_ignore, NULL, NULL, 0 },  /* nh */
	{ roff_line_ignore, NULL, NULL, 0 },  /* nhychar */
	{ roff_unsupp, NULL, NULL, 0 },  /* nm */
	{ roff_unsupp, NULL, NULL, 0 },  /* nn */
	{ roff_unsupp, NULL, NULL, 0 },  /* nop */
	{ roff_nr, NULL, NULL, 0 },  /* nr */
	{ roff_unsupp, NULL, NULL, 0 },  /* nrf */
	{ roff_line_ignore, NULL, NULL, 0 },  /* nroff */
	{ roff_line_ignore, NULL, NULL, 0 },  /* ns */
	{ roff_insec, NULL, NULL, 0 },  /* nx */
	{ roff_insec, NULL, NULL, 0 },  /* open */
	{ roff_insec, NULL, NULL, 0 },  /* opena */
	{ roff_line_ignore, NULL, NULL, 0 },  /* os */
	{ roff_unsupp, NULL, NULL, 0 },  /* output */
	{ roff_line_ignore, NULL, NULL, 0 },  /* padj */
	{ roff_line_ignore, NULL, NULL, 0 },  /* papersize */
	{ roff_line_ignore, NULL, NULL, 0 },  /* pc */
	{ roff_line_ignore, NULL, NULL, 0 },  /* pev */
	{ roff_insec, NULL, NULL, 0 },  /* pi */
	{ roff_unsupp, NULL, NULL, 0 },  /* PI */
	{ roff_line_ignore, NULL, NULL, 0 },  /* pl */
	{ roff_line_ignore, NULL, NULL, 0 },  /* pm */
	{ roff_line_ignore, NULL, NULL, 0 },  /* pn */
	{ roff_line_ignore, NULL, NULL, 0 },  /* pnr */
	{ roff_line_ignore, NULL, NULL, 0 },  /* ps */
	{ roff_unsupp, NULL, NULL, 0 },  /* psbb */
	{ roff_unsupp, NULL, NULL, 0 },  /* pshape */
	{ roff_insec, NULL, NULL, 0 },  /* pso */
	{ roff_line_ignore, NULL, NULL, 0 },  /* ptr */
	{ roff_line_ignore, NULL, NULL, 0 },  /* pvs */
	{ roff_unsupp, NULL, NULL, 0 },  /* rchar */
	{ roff_line_ignore, NULL, NULL, 0 },  /* rd */
	{ roff_line_ignore, NULL, NULL, 0 },  /* recursionlimit */
	{ roff_unsupp, NULL, NULL, 0 },  /* return */
	{ roff_unsupp, NULL, NULL, 0 },  /* rfschar */
	{ roff_line_ignore, NULL, NULL, 0 },  /* rhang */
	{ roff_rm, NULL, NULL, 0 },  /* rm */
	{ roff_rn, NULL, NULL, 0 },  /* rn */
	{ roff_unsupp, NULL, NULL, 0 },  /* rnn */
	{ roff_rr, NULL, NULL, 0 },  /* rr */
	{ roff_line_ignore, NULL, NULL, 0 },  /* rs */
	{ roff_line_ignore, NULL, NULL, 0 },  /* rt */
	{ roff_unsupp, NULL, NULL, 0 },  /* schar */
	{ roff_line_ignore, NULL, NULL, 0 },  /* sentchar */
	{ roff_line_ignore, NULL, NULL, 0 },  /* shc */
	{ roff_unsupp, NULL, NULL, 0 },  /* shift */
	{ roff_line_ignore, NULL, NULL, 0 },  /* sizes */
	{ roff_so, NULL, NULL, 0 },  /* so */
	{ roff_line_ignore, NULL, NULL, 0 },  /* spacewidth */
	{ roff_line_ignore, NULL, NULL, 0 },  /* special */
	{ roff_line_ignore, NULL, NULL, 0 },  /* spreadwarn */
	{ roff_line_ignore, NULL, NULL, 0 },  /* ss */
	{ roff_line_ignore, NULL, NULL, 0 },  /* sty */
	{ roff_unsupp, NULL, NULL, 0 },  /* substring */
	{ roff_line_ignore, NULL, NULL, 0 },  /* sv */
	{ roff_insec, NULL, NULL, 0 },  /* sy */
	{ roff_T_, NULL, NULL, 0 },  /* T& */
	{ roff_unsupp, NULL, NULL, 0 },  /* tc */
	{ roff_TE, NULL, NULL, 0 },  /* TE */
	{ roff_Dd, NULL, NULL, 0 },  /* TH */
	{ roff_line_ignore, NULL, NULL, 0 },  /* tkf */
	{ roff_unsupp, NULL, NULL, 0 },  /* tl */
	{ roff_line_ignore, NULL, NULL, 0 },  /* tm */
	{ roff_line_ignore, NULL, NULL, 0 },  /* tm1 */
	{ roff_line_ignore, NULL, NULL, 0 },  /* tmc */
	{ roff_tr, NULL, NULL, 0 },  /* tr */
	{ roff_line_ignore, NULL, NULL, 0 },  /* track */
	{ roff_line_ignore, NULL, NULL, 0 },  /* transchar */
	{ roff_insec, NULL, NULL, 0 },  /* trf */
	{ roff_line_ignore, NULL, NULL, 0 },  /* trimat */
	{ roff_unsupp, NULL, NULL, 0 },  /* trin */
	{ roff_unsupp, NULL, NULL, 0 },  /* trnt */
	{ roff_line_ignore, NULL, NULL, 0 },  /* troff */
	{ roff_TS, NULL, NULL, 0 },  /* TS */
	{ roff_line_ignore, NULL, NULL, 0 },  /* uf */
	{ roff_line_ignore, NULL, NULL, 0 },  /* ul */
	{ roff_unsupp, NULL, NULL, 0 },  /* unformat */
	{ roff_line_ignore, NULL, NULL, 0 },  /* unwatch */
	{ roff_line_ignore, NULL, NULL, 0 },  /* unwatchn */
	{ roff_line_ignore, NULL, NULL, 0 },  /* vpt */
	{ roff_line_ignore, NULL, NULL, 0 },  /* vs */
	{ roff_line_ignore, NULL, NULL, 0 },  /* warn */
	{ roff_line_ignore, NULL, NULL, 0 },  /* warnscale */
	{ roff_line_ignore, NULL, NULL, 0 },  /* watch */
	{ roff_line_ignore, NULL, NULL, 0 },  /* watchlength */
	{ roff_line_ignore, NULL, NULL, 0 },  /* watchn */
	{ roff_unsupp, NULL, NULL, 0 },  /* wh */
	{ roff_unsupp, NULL, NULL, 0 },  /* while */
	{ roff_insec, NULL, NULL, 0 },  /* write */
	{ roff_insec, NULL, NULL, 0 },  /* writec */
	{ roff_insec, NULL, NULL, 0 },  /* writem */
	{ roff_line_ignore, NULL, NULL, 0 },  /* xflag */
	{ roff_cblock, NULL, NULL, 0 },  /* . */
	{ roff_renamed, NULL, NULL, 0 },
	{ roff_userdef, NULL, NULL, 0 }
};

/* Array of injected predefined strings. */
#define	PREDEFS_MAX	 38
static	const struct predef predefs[PREDEFS_MAX] = {
#include "predefs.in"
};

static	int	 roffce_lines;	/* number of input lines to center */
static	struct roff_node *roffce_node;  /* active request */
static	int	 roffit_lines;  /* number of lines to delay */
static	char	*roffit_macro;  /* nil-terminated macro line */


/* --- request table ------------------------------------------------------ */

struct ohash *
roffhash_alloc(enum roff_tok mintok, enum roff_tok maxtok)
{
	struct ohash	*htab;
	struct roffreq	*req;
	enum roff_tok	 tok;
	size_t		 sz;
	unsigned int	 slot;

	htab = mandoc_malloc(sizeof(*htab));
	mandoc_ohash_init(htab, 8, offsetof(struct roffreq, name));

	for (tok = mintok; tok < maxtok; tok++) {
		if (roff_name[tok] == NULL)
			continue;
		sz = strlen(roff_name[tok]);
		req = mandoc_malloc(sizeof(*req) + sz + 1);
		req->tok = tok;
		memcpy(req->name, roff_name[tok], sz + 1);
		slot = ohash_qlookup(htab, req->name);
		ohash_insert(htab, slot, req);
	}
	return htab;
}

void
roffhash_free(struct ohash *htab)
{
	struct roffreq	*req;
	unsigned int	 slot;

	if (htab == NULL)
		return;
	for (req = ohash_first(htab, &slot); req != NULL;
	     req = ohash_next(htab, &slot))
		free(req);
	ohash_delete(htab);
	free(htab);
}

enum roff_tok
roffhash_find(struct ohash *htab, const char *name, size_t sz)
{
	struct roffreq	*req;
	const char	*end;

	if (sz) {
		end = name + sz;
		req = ohash_find(htab, ohash_qlookupi(htab, name, &end));
	} else
		req = ohash_find(htab, ohash_qlookup(htab, name));
	return req == NULL ? TOKEN_NONE : req->tok;
}

/* --- stack of request blocks -------------------------------------------- */

/*
 * Pop the current node off of the stack of roff instructions currently
 * pending.
 */
static void
roffnode_pop(struct roff *r)
{
	struct roffnode	*p;

	assert(r->last);
	p = r->last;

	r->last = r->last->parent;
	free(p->name);
	free(p->end);
	free(p);
}

/*
 * Push a roff node onto the instruction stack.  This must later be
 * removed with roffnode_pop().
 */
static void
roffnode_push(struct roff *r, enum roff_tok tok, const char *name,
		int line, int col)
{
	struct roffnode	*p;

	p = mandoc_calloc(1, sizeof(struct roffnode));
	p->tok = tok;
	if (name)
		p->name = mandoc_strdup(name);
	p->parent = r->last;
	p->line = line;
	p->col = col;
	p->rule = p->parent ? p->parent->rule : 0;

	r->last = p;
}

/* --- roff parser state data management ---------------------------------- */

static void
roff_free1(struct roff *r)
{
	struct tbl_node	*tbl;
	int		 i;

	while (NULL != (tbl = r->first_tbl)) {
		r->first_tbl = tbl->next;
		tbl_free(tbl);
	}
	r->first_tbl = r->last_tbl = r->tbl = NULL;

	if (r->last_eqn != NULL)
		eqn_free(r->last_eqn);
	r->last_eqn = r->eqn = NULL;

	while (r->last)
		roffnode_pop(r);

	free (r->rstack);
	r->rstack = NULL;
	r->rstacksz = 0;
	r->rstackpos = -1;

	roff_freereg(r->regtab);
	r->regtab = NULL;

	roff_freestr(r->strtab);
	roff_freestr(r->rentab);
	roff_freestr(r->xmbtab);
	r->strtab = r->rentab = r->xmbtab = NULL;

	if (r->xtab)
		for (i = 0; i < 128; i++)
			free(r->xtab[i].p);
	free(r->xtab);
	r->xtab = NULL;
}

void
roff_reset(struct roff *r)
{
	roff_free1(r);
	r->format = r->options & (MPARSE_MDOC | MPARSE_MAN);
	r->control = '\0';
	r->escape = '\\';
	roffce_lines = 0;
	roffce_node = NULL;
	roffit_lines = 0;
	roffit_macro = NULL;
}

void
roff_free(struct roff *r)
{
	roff_free1(r);
	roffhash_free(r->reqtab);
	free(r);
}

struct roff *
roff_alloc(struct mparse *parse, int options)
{
	struct roff	*r;

	r = mandoc_calloc(1, sizeof(struct roff));
	r->parse = parse;
	r->reqtab = roffhash_alloc(0, ROFF_USERDEF);
	r->options = options;
	r->format = options & (MPARSE_MDOC | MPARSE_MAN);
	r->rstackpos = -1;
	r->escape = '\\';
	return r;
}

/* --- syntax tree state data management ---------------------------------- */

static void
roff_man_free1(struct roff_man *man)
{

	if (man->first != NULL)
		roff_node_delete(man, man->first);
	free(man->meta.msec);
	free(man->meta.vol);
	free(man->meta.os);
	free(man->meta.arch);
	free(man->meta.title);
	free(man->meta.name);
	free(man->meta.date);
}

static void
roff_man_alloc1(struct roff_man *man)
{

	memset(&man->meta, 0, sizeof(man->meta));
	man->first = mandoc_calloc(1, sizeof(*man->first));
	man->first->type = ROFFT_ROOT;
	man->last = man->first;
	man->last_es = NULL;
	man->flags = 0;
	man->macroset = MACROSET_NONE;
	man->lastsec = man->lastnamed = SEC_NONE;
	man->next = ROFF_NEXT_CHILD;
}

void
roff_man_reset(struct roff_man *man)
{

	roff_man_free1(man);
	roff_man_alloc1(man);
}

void
roff_man_free(struct roff_man *man)
{

	roff_man_free1(man);
	free(man);
}

struct roff_man *
roff_man_alloc(struct roff *roff, struct mparse *parse,
	const char *os_s, int quick)
{
	struct roff_man *man;

	man = mandoc_calloc(1, sizeof(*man));
	man->parse = parse;
	man->roff = roff;
	man->os_s = os_s;
	man->quick = quick;
	roff_man_alloc1(man);
	roff->man = man;
	return man;
}

/* --- syntax tree handling ----------------------------------------------- */

struct roff_node *
roff_node_alloc(struct roff_man *man, int line, int pos,
	enum roff_type type, int tok)
{
	struct roff_node	*n;

	n = mandoc_calloc(1, sizeof(*n));
	n->line = line;
	n->pos = pos;
	n->tok = tok;
	n->type = type;
	n->sec = man->lastsec;

	if (man->flags & MDOC_SYNOPSIS)
		n->flags |= NODE_SYNPRETTY;
	else
		n->flags &= ~NODE_SYNPRETTY;
	if (man->flags & MDOC_NEWLINE)
		n->flags |= NODE_LINE;
	man->flags &= ~MDOC_NEWLINE;

	return n;
}

void
roff_node_append(struct roff_man *man, struct roff_node *n)
{

	switch (man->next) {
	case ROFF_NEXT_SIBLING:
		if (man->last->next != NULL) {
			n->next = man->last->next;
			man->last->next->prev = n;
		} else
			man->last->parent->last = n;
		man->last->next = n;
		n->prev = man->last;
		n->parent = man->last->parent;
		break;
	case ROFF_NEXT_CHILD:
		if (man->last->child != NULL) {
			n->next = man->last->child;
			man->last->child->prev = n;
		} else
			man->last->last = n;
		man->last->child = n;
		n->parent = man->last;
		break;
	default:
		abort();
	}
	man->last = n;

	switch (n->type) {
	case ROFFT_HEAD:
		n->parent->head = n;
		break;
	case ROFFT_BODY:
		if (n->end != ENDBODY_NOT)
			return;
		n->parent->body = n;
		break;
	case ROFFT_TAIL:
		n->parent->tail = n;
		break;
	default:
		return;
	}

	/*
	 * Copy over the normalised-data pointer of our parent.  Not
	 * everybody has one, but copying a null pointer is fine.
	 */

	n->norm = n->parent->norm;
	assert(n->parent->type == ROFFT_BLOCK);
}

void
roff_word_alloc(struct roff_man *man, int line, int pos, const char *word)
{
	struct roff_node	*n;

	n = roff_node_alloc(man, line, pos, ROFFT_TEXT, TOKEN_NONE);
	n->string = roff_strdup(man->roff, word);
	roff_node_append(man, n);
	n->flags |= NODE_VALID | NODE_ENDED;
	man->next = ROFF_NEXT_SIBLING;
}

void
roff_word_append(struct roff_man *man, const char *word)
{
	struct roff_node	*n;
	char			*addstr, *newstr;

	n = man->last;
	addstr = roff_strdup(man->roff, word);
	mandoc_asprintf(&newstr, "%s %s", n->string, addstr);
	free(addstr);
	free(n->string);
	n->string = newstr;
	man->next = ROFF_NEXT_SIBLING;
}

void
roff_elem_alloc(struct roff_man *man, int line, int pos, int tok)
{
	struct roff_node	*n;

	n = roff_node_alloc(man, line, pos, ROFFT_ELEM, tok);
	roff_node_append(man, n);
	man->next = ROFF_NEXT_CHILD;
}

struct roff_node *
roff_block_alloc(struct roff_man *man, int line, int pos, int tok)
{
	struct roff_node	*n;

	n = roff_node_alloc(man, line, pos, ROFFT_BLOCK, tok);
	roff_node_append(man, n);
	man->next = ROFF_NEXT_CHILD;
	return n;
}

struct roff_node *
roff_head_alloc(struct roff_man *man, int line, int pos, int tok)
{
	struct roff_node	*n;

	n = roff_node_alloc(man, line, pos, ROFFT_HEAD, tok);
	roff_node_append(man, n);
	man->next = ROFF_NEXT_CHILD;
	return n;
}

struct roff_node *
roff_body_alloc(struct roff_man *man, int line, int pos, int tok)
{
	struct roff_node	*n;

	n = roff_node_alloc(man, line, pos, ROFFT_BODY, tok);
	roff_node_append(man, n);
	man->next = ROFF_NEXT_CHILD;
	return n;
}

void
roff_addtbl(struct roff_man *man, const struct tbl_span *tbl)
{
	struct roff_node	*n;

	if (man->macroset == MACROSET_MAN)
		man_breakscope(man, ROFF_TS);
	n = roff_node_alloc(man, tbl->line, 0, ROFFT_TBL, TOKEN_NONE);
	n->span = tbl;
	roff_node_append(man, n);
	n->flags |= NODE_VALID | NODE_ENDED;
	man->next = ROFF_NEXT_SIBLING;
}

void
roff_node_unlink(struct roff_man *man, struct roff_node *n)
{

	/* Adjust siblings. */

	if (n->prev)
		n->prev->next = n->next;
	if (n->next)
		n->next->prev = n->prev;

	/* Adjust parent. */

	if (n->parent != NULL) {
		if (n->parent->child == n)
			n->parent->child = n->next;
		if (n->parent->last == n)
			n->parent->last = n->prev;
	}

	/* Adjust parse point. */

	if (man == NULL)
		return;
	if (man->last == n) {
		if (n->prev == NULL) {
			man->last = n->parent;
			man->next = ROFF_NEXT_CHILD;
		} else {
			man->last = n->prev;
			man->next = ROFF_NEXT_SIBLING;
		}
	}
	if (man->first == n)
		man->first = NULL;
}

void
roff_node_free(struct roff_node *n)
{

	if (n->args != NULL)
		mdoc_argv_free(n->args);
	if (n->type == ROFFT_BLOCK || n->type == ROFFT_ELEM)
		free(n->norm);
	if (n->eqn != NULL)
		eqn_box_free(n->eqn);
	free(n->string);
	free(n);
}

void
roff_node_delete(struct roff_man *man, struct roff_node *n)
{

	while (n->child != NULL)
		roff_node_delete(man, n->child);
	roff_node_unlink(man, n);
	roff_node_free(n);
}

void
deroff(char **dest, const struct roff_node *n)
{
	char	*cp;
	size_t	 sz;

	if (n->type != ROFFT_TEXT) {
		for (n = n->child; n != NULL; n = n->next)
			deroff(dest, n);
		return;
	}

	/* Skip leading whitespace. */

	for (cp = n->string; *cp != '\0'; cp++) {
		if (cp[0] == '\\' && cp[1] != '\0' &&
		    strchr(" %&0^|~", cp[1]) != NULL)
			cp++;
		else if ( ! isspace((unsigned char)*cp))
			break;
	}

	/* Skip trailing backslash. */

	sz = strlen(cp);
	if (sz > 0 && cp[sz - 1] == '\\')
		sz--;

	/* Skip trailing whitespace. */

	for (; sz; sz--)
		if ( ! isspace((unsigned char)cp[sz-1]))
			break;

	/* Skip empty strings. */

	if (sz == 0)
		return;

	if (*dest == NULL) {
		*dest = mandoc_strndup(cp, sz);
		return;
	}

	mandoc_asprintf(&cp, "%s %*s", *dest, (int)sz, cp);
	free(*dest);
	*dest = cp;
}

/* --- main functions of the roff parser ---------------------------------- */

/*
 * In the current line, expand escape sequences that tend to get
 * used in numerical expressions and conditional requests.
 * Also check the syntax of the remaining escape sequences.
 */
static enum rofferr
roff_res(struct roff *r, struct buf *buf, int ln, int pos)
{
	char		 ubuf[24]; /* buffer to print the number */
	const char	*start;	/* start of the string to process */
	char		*stesc;	/* start of an escape sequence ('\\') */
	const char	*stnam;	/* start of the name, after "[(*" */
	const char	*cp;	/* end of the name, e.g. before ']' */
	const char	*res;	/* the string to be substituted */
	char		*nbuf;	/* new buffer to copy buf->buf to */
	size_t		 maxl;  /* expected length of the escape name */
	size_t		 naml;	/* actual length of the escape name */
	enum mandoc_esc	 esc;	/* type of the escape sequence */
	enum mandoc_os	 os_e;	/* kind of RCS id seen */
	int		 inaml;	/* length returned from mandoc_escape() */
	int		 expand_count;	/* to avoid infinite loops */
	int		 npos;	/* position in numeric expression */
	int		 arg_complete; /* argument not interrupted by eol */
	int		 done;	/* no more input available */
	int		 deftype; /* type of definition to paste */
	char		 term;	/* character terminating the escape */

	/* Search forward for comments. */

	done = 0;
	start = buf->buf + pos;
	for (stesc = buf->buf + pos; *stesc != '\0'; stesc++) {
		if (stesc[0] != r->escape || stesc[1] == '\0')
			continue;
		stesc++;
		if (*stesc != '"' && *stesc != '#')
			continue;

		/* Comment found, look for RCS id. */

		if ((cp = strstr(stesc, "$" "OpenBSD")) != NULL) {
			os_e = MANDOC_OS_OPENBSD;
			cp += 8;
		} else if ((cp = strstr(stesc, "$" "NetBSD")) != NULL) {
			os_e = MANDOC_OS_NETBSD;
			cp += 7;
		}
		if (cp != NULL &&
		    isalnum((unsigned char)*cp) == 0 &&
		    strchr(cp, '$') != NULL) {
			if (r->man->meta.rcsids & (1 << os_e))
				mandoc_msg(MANDOCERR_RCS_REP, r->parse,
				    ln, stesc + 1 - buf->buf, stesc + 1);
			r->man->meta.rcsids |= 1 << os_e;
		}

		/* Handle trailing whitespace. */

		cp = strchr(stesc--, '\0') - 1;
		if (*cp == '\n') {
			done = 1;
			cp--;
		}
		if (*cp == ' ' || *cp == '\t')
			mandoc_msg(MANDOCERR_SPACE_EOL, r->parse,
			    ln, cp - buf->buf, NULL);
		while (stesc > start && stesc[-1] == ' ')
			stesc--;
		*stesc = '\0';
		break;
	}
	if (stesc == start)
		return ROFF_CONT;
	stesc--;

	/* Notice the end of the input. */

	if (*stesc == '\n') {
		*stesc-- = '\0';
		done = 1;
	}

	expand_count = 0;
	while (stesc >= start) {

		/* Search backwards for the next backslash. */

		if (*stesc != r->escape) {
			if (*stesc == '\\') {
				*stesc = '\0';
				buf->sz = mandoc_asprintf(&nbuf, "%s\\e%s",
				    buf->buf, stesc + 1) + 1;
				start = nbuf + pos;
				stesc = nbuf + (stesc - buf->buf);
				free(buf->buf);
				buf->buf = nbuf;
			}
			stesc--;
			continue;
		}

		/* If it is escaped, skip it. */

		for (cp = stesc - 1; cp >= start; cp--)
			if (*cp != r->escape)
				break;

		if ((stesc - cp) % 2 == 0) {
			while (stesc > cp)
				*stesc-- = '\\';
			continue;
		} else if (stesc[1] != '\0') {
			*stesc = '\\';
		} else {
			*stesc-- = '\0';
			if (done)
				continue;
			else
				return ROFF_APPEND;
		}

		/* Decide whether to expand or to check only. */

		term = '\0';
		cp = stesc + 1;
		switch (*cp) {
		case '*':
			res = NULL;
			break;
		case 'B':
		case 'w':
			term = cp[1];
			/* FALLTHROUGH */
		case 'n':
			res = ubuf;
			break;
		default:
			esc = mandoc_escape(&cp, &stnam, &inaml);
			if (esc == ESCAPE_ERROR ||
			    (esc == ESCAPE_SPECIAL &&
			     mchars_spec2cp(stnam, inaml) < 0))
				mandoc_vmsg(MANDOCERR_ESC_BAD,
				    r->parse, ln, (int)(stesc - buf->buf),
				    "%.*s", (int)(cp - stesc), stesc);
			stesc--;
			continue;
		}

		if (EXPAND_LIMIT < ++expand_count) {
			mandoc_msg(MANDOCERR_ROFFLOOP, r->parse,
			    ln, (int)(stesc - buf->buf), NULL);
			return ROFF_IGN;
		}

		/*
		 * The third character decides the length
		 * of the name of the string or register.
		 * Save a pointer to the name.
		 */

		if (term == '\0') {
			switch (*++cp) {
			case '\0':
				maxl = 0;
				break;
			case '(':
				cp++;
				maxl = 2;
				break;
			case '[':
				cp++;
				term = ']';
				maxl = 0;
				break;
			default:
				maxl = 1;
				break;
			}
		} else {
			cp += 2;
			maxl = 0;
		}
		stnam = cp;

		/* Advance to the end of the name. */

		naml = 0;
		arg_complete = 1;
		while (maxl == 0 || naml < maxl) {
			if (*cp == '\0') {
				mandoc_msg(MANDOCERR_ESC_BAD, r->parse,
				    ln, (int)(stesc - buf->buf), stesc);
				arg_complete = 0;
				break;
			}
			if (maxl == 0 && *cp == term) {
				cp++;
				break;
			}
			if (*cp++ != '\\' || stesc[1] != 'w') {
				naml++;
				continue;
			}
			switch (mandoc_escape(&cp, NULL, NULL)) {
			case ESCAPE_SPECIAL:
			case ESCAPE_UNICODE:
			case ESCAPE_NUMBERED:
			case ESCAPE_OVERSTRIKE:
				naml++;
				break;
			default:
				break;
			}
		}

		/*
		 * Retrieve the replacement string; if it is
		 * undefined, resume searching for escapes.
		 */

		switch (stesc[1]) {
		case '*':
			if (arg_complete) {
				deftype = ROFFDEF_USER | ROFFDEF_PRE;
				res = roff_getstrn(r, stnam, naml, &deftype);
			}
			break;
		case 'B':
			npos = 0;
			ubuf[0] = arg_complete &&
			    roff_evalnum(r, ln, stnam, &npos,
			      NULL, ROFFNUM_SCALE) &&
			    stnam + npos + 1 == cp ? '1' : '0';
			ubuf[1] = '\0';
			break;
		case 'n':
			if (arg_complete)
				(void)snprintf(ubuf, sizeof(ubuf), "%d",
				    roff_getregn(r, stnam, naml));
			else
				ubuf[0] = '\0';
			break;
		case 'w':
			/* use even incomplete args */
			(void)snprintf(ubuf, sizeof(ubuf), "%d",
			    24 * (int)naml);
			break;
		}

		if (res == NULL) {
			mandoc_vmsg(MANDOCERR_STR_UNDEF,
			    r->parse, ln, (int)(stesc - buf->buf),
			    "%.*s", (int)naml, stnam);
			res = "";
		} else if (buf->sz + strlen(res) > SHRT_MAX) {
			mandoc_msg(MANDOCERR_ROFFLOOP, r->parse,
			    ln, (int)(stesc - buf->buf), NULL);
			return ROFF_IGN;
		}

		/* Replace the escape sequence by the string. */

		*stesc = '\0';
		buf->sz = mandoc_asprintf(&nbuf, "%s%s%s",
		    buf->buf, res, cp) + 1;

		/* Prepare for the next replacement. */

		start = nbuf + pos;
		stesc = nbuf + (stesc - buf->buf) + strlen(res);
		free(buf->buf);
		buf->buf = nbuf;
	}
	return ROFF_CONT;
}

/*
 * Process text streams.
 */
static enum rofferr
roff_parsetext(struct roff *r, struct buf *buf, int pos, int *offs)
{
	size_t		 sz;
	const char	*start;
	char		*p;
	int		 isz;
	enum mandoc_esc	 esc;

	/* Spring the input line trap. */

	if (roffit_lines == 1) {
		isz = mandoc_asprintf(&p, "%s\n.%s", buf->buf, roffit_macro);
		free(buf->buf);
		buf->buf = p;
		buf->sz = isz + 1;
		*offs = 0;
		free(roffit_macro);
		roffit_lines = 0;
		return ROFF_REPARSE;
	} else if (roffit_lines > 1)
		--roffit_lines;

	if (roffce_node != NULL && buf->buf[pos] != '\0') {
		if (roffce_lines < 1) {
			r->man->last = roffce_node;
			r->man->next = ROFF_NEXT_SIBLING;
			roffce_lines = 0;
			roffce_node = NULL;
		} else
			roffce_lines--;
	}

	/* Convert all breakable hyphens into ASCII_HYPH. */

	start = p = buf->buf + pos;

	while (*p != '\0') {
		sz = strcspn(p, "-\\");
		p += sz;

		if (*p == '\0')
			break;

		if (*p == '\\') {
			/* Skip over escapes. */
			p++;
			esc = mandoc_escape((const char **)&p, NULL, NULL);
			if (esc == ESCAPE_ERROR)
				break;
			while (*p == '-')
				p++;
			continue;
		} else if (p == start) {
			p++;
			continue;
		}

		if (isalpha((unsigned char)p[-1]) &&
		    isalpha((unsigned char)p[1]))
			*p = ASCII_HYPH;
		p++;
	}
	return ROFF_CONT;
}

enum rofferr
roff_parseln(struct roff *r, int ln, struct buf *buf, int *offs)
{
	enum roff_tok	 t;
	enum rofferr	 e;
	int		 pos;	/* parse point */
	int		 spos;	/* saved parse point for messages */
	int		 ppos;	/* original offset in buf->buf */
	int		 ctl;	/* macro line (boolean) */

	ppos = pos = *offs;

	/* Handle in-line equation delimiters. */

	if (r->tbl == NULL &&
	    r->last_eqn != NULL && r->last_eqn->delim &&
	    (r->eqn == NULL || r->eqn_inline)) {
		e = roff_eqndelim(r, buf, pos);
		if (e == ROFF_REPARSE)
			return e;
		assert(e == ROFF_CONT);
	}

	/* Expand some escape sequences. */

	e = roff_res(r, buf, ln, pos);
	if (e == ROFF_IGN || e == ROFF_APPEND)
		return e;
	assert(e == ROFF_CONT);

	ctl = roff_getcontrol(r, buf->buf, &pos);

	/*
	 * First, if a scope is open and we're not a macro, pass the
	 * text through the macro's filter.
	 * Equations process all content themselves.
	 * Tables process almost all content themselves, but we want
	 * to warn about macros before passing it there.
	 */

	if (r->last != NULL && ! ctl) {
		t = r->last->tok;
		e = (*roffs[t].text)(r, t, buf, ln, pos, pos, offs);
		if (e == ROFF_IGN)
			return e;
		assert(e == ROFF_CONT);
	}
	if (r->eqn != NULL && strncmp(buf->buf + ppos, ".EN", 3)) {
		eqn_read(r->eqn, buf->buf + ppos);
		return ROFF_IGN;
	}
	if (r->tbl != NULL && ( ! ctl || buf->buf[pos] == '\0'))
		return tbl_read(r->tbl, ln, buf->buf, ppos);
	if ( ! ctl)
		return roff_parsetext(r, buf, pos, offs);

	/* Skip empty request lines. */

	if (buf->buf[pos] == '"') {
		mandoc_msg(MANDOCERR_COMMENT_BAD, r->parse,
		    ln, pos, NULL);
		return ROFF_IGN;
	} else if (buf->buf[pos] == '\0')
		return ROFF_IGN;

	/*
	 * If a scope is open, go to the child handler for that macro,
	 * as it may want to preprocess before doing anything with it.
	 * Don't do so if an equation is open.
	 */

	if (r->last) {
		t = r->last->tok;
		return (*roffs[t].sub)(r, t, buf, ln, ppos, pos, offs);
	}

	/* No scope is open.  This is a new request or macro. */

	spos = pos;
	t = roff_parse(r, buf->buf, &pos, ln, ppos);

	/* Tables ignore most macros. */

	if (r->tbl != NULL && (t == TOKEN_NONE || t == ROFF_TS ||
	    t == ROFF_br || t == ROFF_ce || t == ROFF_rj || t == ROFF_sp)) {
		mandoc_msg(MANDOCERR_TBLMACRO, r->parse,
		    ln, pos, buf->buf + spos);
		if (t != TOKEN_NONE)
			return ROFF_IGN;
		while (buf->buf[pos] != '\0' && buf->buf[pos] != ' ')
			pos++;
		while (buf->buf[pos] == ' ')
			pos++;
		return tbl_read(r->tbl, ln, buf->buf, pos);
	}

	/* For now, let high level macros abort .ce mode. */

	if (ctl && roffce_node != NULL &&
	    (t == TOKEN_NONE || t == ROFF_EQ || t == ROFF_TS)) {
		r->man->last = roffce_node;
		r->man->next = ROFF_NEXT_SIBLING;
		roffce_lines = 0;
		roffce_node = NULL;
	}

	/*
	 * This is neither a roff request nor a user-defined macro.
	 * Let the standard macro set parsers handle it.
	 */

	if (t == TOKEN_NONE)
		return ROFF_CONT;

	/* Execute a roff request or a user defined macro. */

	return (*roffs[t].proc)(r, t, buf, ln, spos, pos, offs);
}

void
roff_endparse(struct roff *r)
{

	if (r->last)
		mandoc_msg(MANDOCERR_BLK_NOEND, r->parse,
		    r->last->line, r->last->col,
		    roff_name[r->last->tok]);

	if (r->eqn) {
		mandoc_msg(MANDOCERR_BLK_NOEND, r->parse,
		    r->eqn->node->line, r->eqn->node->pos, "EQ");
		eqn_parse(r->eqn);
		r->eqn = NULL;
	}

	if (r->tbl) {
		mandoc_msg(MANDOCERR_BLK_NOEND, r->parse,
		    r->tbl->line, r->tbl->pos, "TS");
		tbl_end(&r->tbl);
	}
}

/*
 * Parse a roff node's type from the input buffer.  This must be in the
 * form of ".foo xxx" in the usual way.
 */
static enum roff_tok
roff_parse(struct roff *r, char *buf, int *pos, int ln, int ppos)
{
	char		*cp;
	const char	*mac;
	size_t		 maclen;
	int		 deftype;
	enum roff_tok	 t;

	cp = buf + *pos;

	if ('\0' == *cp || '"' == *cp || '\t' == *cp || ' ' == *cp)
		return TOKEN_NONE;

	mac = cp;
	maclen = roff_getname(r, &cp, ln, ppos);

	deftype = ROFFDEF_USER | ROFFDEF_REN;
	r->current_string = roff_getstrn(r, mac, maclen, &deftype);
	switch (deftype) {
	case ROFFDEF_USER:
		t = ROFF_USERDEF;
		break;
	case ROFFDEF_REN:
		t = ROFF_RENAMED;
		break;
	default:
		t = roffhash_find(r->reqtab, mac, maclen);
		break;
	}
	if (t != TOKEN_NONE)
		*pos = cp - buf;
	return t;
}

/* --- handling of request blocks ----------------------------------------- */

static enum rofferr
roff_cblock(ROFF_ARGS)
{

	/*
	 * A block-close `..' should only be invoked as a child of an
	 * ignore macro, otherwise raise a warning and just ignore it.
	 */

	if (r->last == NULL) {
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "..");
		return ROFF_IGN;
	}

	switch (r->last->tok) {
	case ROFF_am:
		/* ROFF_am1 is remapped to ROFF_am in roff_block(). */
	case ROFF_ami:
	case ROFF_de:
		/* ROFF_de1 is remapped to ROFF_de in roff_block(). */
	case ROFF_dei:
	case ROFF_ig:
		break;
	default:
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "..");
		return ROFF_IGN;
	}

	if (buf->buf[pos] != '\0')
		mandoc_vmsg(MANDOCERR_ARG_SKIP, r->parse, ln, pos,
		    ".. %s", buf->buf + pos);

	roffnode_pop(r);
	roffnode_cleanscope(r);
	return ROFF_IGN;

}

static void
roffnode_cleanscope(struct roff *r)
{

	while (r->last) {
		if (--r->last->endspan != 0)
			break;
		roffnode_pop(r);
	}
}

static void
roff_ccond(struct roff *r, int ln, int ppos)
{

	if (NULL == r->last) {
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "\\}");
		return;
	}

	switch (r->last->tok) {
	case ROFF_el:
	case ROFF_ie:
	case ROFF_if:
		break;
	default:
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "\\}");
		return;
	}

	if (r->last->endspan > -1) {
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "\\}");
		return;
	}

	roffnode_pop(r);
	roffnode_cleanscope(r);
	return;
}

static enum rofferr
roff_block(ROFF_ARGS)
{
	const char	*name, *value;
	char		*call, *cp, *iname, *rname;
	size_t		 csz, namesz, rsz;
	int		 deftype;

	/* Ignore groff compatibility mode for now. */

	if (tok == ROFF_de1)
		tok = ROFF_de;
	else if (tok == ROFF_dei1)
		tok = ROFF_dei;
	else if (tok == ROFF_am1)
		tok = ROFF_am;
	else if (tok == ROFF_ami1)
		tok = ROFF_ami;

	/* Parse the macro name argument. */

	cp = buf->buf + pos;
	if (tok == ROFF_ig) {
		iname = NULL;
		namesz = 0;
	} else {
		iname = cp;
		namesz = roff_getname(r, &cp, ln, ppos);
		iname[namesz] = '\0';
	}

	/* Resolve the macro name argument if it is indirect. */

	if (namesz && (tok == ROFF_dei || tok == ROFF_ami)) {
		deftype = ROFFDEF_USER;
		name = roff_getstrn(r, iname, namesz, &deftype);
		if (name == NULL) {
			mandoc_vmsg(MANDOCERR_STR_UNDEF,
			    r->parse, ln, (int)(iname - buf->buf),
			    "%.*s", (int)namesz, iname);
			namesz = 0;
		} else
			namesz = strlen(name);
	} else
		name = iname;

	if (namesz == 0 && tok != ROFF_ig) {
		mandoc_msg(MANDOCERR_REQ_EMPTY, r->parse,
		    ln, ppos, roff_name[tok]);
		return ROFF_IGN;
	}

	roffnode_push(r, tok, name, ln, ppos);

	/*
	 * At the beginning of a `de' macro, clear the existing string
	 * with the same name, if there is one.  New content will be
	 * appended from roff_block_text() in multiline mode.
	 */

	if (tok == ROFF_de || tok == ROFF_dei) {
		roff_setstrn(&r->strtab, name, namesz, "", 0, 0);
		roff_setstrn(&r->rentab, name, namesz, NULL, 0, 0);
	} else if (tok == ROFF_am || tok == ROFF_ami) {
		deftype = ROFFDEF_ANY;
		value = roff_getstrn(r, iname, namesz, &deftype);
		switch (deftype) {  /* Before appending, ... */
		case ROFFDEF_PRE: /* copy predefined to user-defined. */
			roff_setstrn(&r->strtab, name, namesz,
			    value, strlen(value), 0);
			break;
		case ROFFDEF_REN: /* call original standard macro. */
			csz = mandoc_asprintf(&call, ".%.*s \\$* \\\"\n",
			    (int)strlen(value), value);
			roff_setstrn(&r->strtab, name, namesz, call, csz, 0);
			roff_setstrn(&r->rentab, name, namesz, NULL, 0, 0);
			free(call);
			break;
		case ROFFDEF_STD:  /* rename and call standard macro. */
			rsz = mandoc_asprintf(&rname, "__%s_renamed", name);
			roff_setstrn(&r->rentab, rname, rsz, name, namesz, 0);
			csz = mandoc_asprintf(&call, ".%.*s \\$* \\\"\n",
			    (int)rsz, rname);
			roff_setstrn(&r->strtab, name, namesz, call, csz, 0);
			free(call);
			free(rname);
			break;
		default:
			break;
		}
	}

	if (*cp == '\0')
		return ROFF_IGN;

	/* Get the custom end marker. */

	iname = cp;
	namesz = roff_getname(r, &cp, ln, ppos);

	/* Resolve the end marker if it is indirect. */

	if (namesz && (tok == ROFF_dei || tok == ROFF_ami)) {
		deftype = ROFFDEF_USER;
		name = roff_getstrn(r, iname, namesz, &deftype);
		if (name == NULL) {
			mandoc_vmsg(MANDOCERR_STR_UNDEF,
			    r->parse, ln, (int)(iname - buf->buf),
			    "%.*s", (int)namesz, iname);
			namesz = 0;
		} else
			namesz = strlen(name);
	} else
		name = iname;

	if (namesz)
		r->last->end = mandoc_strndup(name, namesz);

	if (*cp != '\0')
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, r->parse,
		    ln, pos, ".%s ... %s", roff_name[tok], cp);

	return ROFF_IGN;
}

static enum rofferr
roff_block_sub(ROFF_ARGS)
{
	enum roff_tok	t;
	int		i, j;

	/*
	 * First check whether a custom macro exists at this level.  If
	 * it does, then check against it.  This is some of groff's
	 * stranger behaviours.  If we encountered a custom end-scope
	 * tag and that tag also happens to be a "real" macro, then we
	 * need to try interpreting it again as a real macro.  If it's
	 * not, then return ignore.  Else continue.
	 */

	if (r->last->end) {
		for (i = pos, j = 0; r->last->end[j]; j++, i++)
			if (buf->buf[i] != r->last->end[j])
				break;

		if (r->last->end[j] == '\0' &&
		    (buf->buf[i] == '\0' ||
		     buf->buf[i] == ' ' ||
		     buf->buf[i] == '\t')) {
			roffnode_pop(r);
			roffnode_cleanscope(r);

			while (buf->buf[i] == ' ' || buf->buf[i] == '\t')
				i++;

			pos = i;
			if (roff_parse(r, buf->buf, &pos, ln, ppos) !=
			    TOKEN_NONE)
				return ROFF_RERUN;
			return ROFF_IGN;
		}
	}

	/*
	 * If we have no custom end-query or lookup failed, then try
	 * pulling it out of the hashtable.
	 */

	t = roff_parse(r, buf->buf, &pos, ln, ppos);

	if (t != ROFF_cblock) {
		if (tok != ROFF_ig)
			roff_setstr(r, r->last->name, buf->buf + ppos, 2);
		return ROFF_IGN;
	}

	return (*roffs[t].proc)(r, t, buf, ln, ppos, pos, offs);
}

static enum rofferr
roff_block_text(ROFF_ARGS)
{

	if (tok != ROFF_ig)
		roff_setstr(r, r->last->name, buf->buf + pos, 2);

	return ROFF_IGN;
}

static enum rofferr
roff_cond_sub(ROFF_ARGS)
{
	enum roff_tok	 t;
	char		*ep;
	int		 rr;

	rr = r->last->rule;
	roffnode_cleanscope(r);

	/*
	 * If `\}' occurs on a macro line without a preceding macro,
	 * drop the line completely.
	 */

	ep = buf->buf + pos;
	if (ep[0] == '\\' && ep[1] == '}')
		rr = 0;

	/* Always check for the closing delimiter `\}'. */

	while ((ep = strchr(ep, '\\')) != NULL) {
		switch (ep[1]) {
		case '}':
			memmove(ep, ep + 2, strlen(ep + 2) + 1);
			roff_ccond(r, ln, ep - buf->buf);
			break;
		case '\0':
			++ep;
			break;
		default:
			ep += 2;
			break;
		}
	}

	/*
	 * Fully handle known macros when they are structurally
	 * required or when the conditional evaluated to true.
	 */

	t = roff_parse(r, buf->buf, &pos, ln, ppos);
	return t != TOKEN_NONE && (rr || roffs[t].flags & ROFFMAC_STRUCT)
	    ? (*roffs[t].proc)(r, t, buf, ln, ppos, pos, offs) : rr
	    ? ROFF_CONT : ROFF_IGN;
}

static enum rofferr
roff_cond_text(ROFF_ARGS)
{
	char		*ep;
	int		 rr;

	rr = r->last->rule;
	roffnode_cleanscope(r);

	ep = buf->buf + pos;
	while ((ep = strchr(ep, '\\')) != NULL) {
		if (*(++ep) == '}') {
			*ep = '&';
			roff_ccond(r, ln, ep - buf->buf - 1);
		}
		if (*ep != '\0')
			++ep;
	}
	return rr ? ROFF_CONT : ROFF_IGN;
}

/* --- handling of numeric and conditional expressions -------------------- */

/*
 * Parse a single signed integer number.  Stop at the first non-digit.
 * If there is at least one digit, return success and advance the
 * parse point, else return failure and let the parse point unchanged.
 * Ignore overflows, treat them just like the C language.
 */
static int
roff_getnum(const char *v, int *pos, int *res, int flags)
{
	int	 myres, scaled, n, p;

	if (NULL == res)
		res = &myres;

	p = *pos;
	n = v[p] == '-';
	if (n || v[p] == '+')
		p++;

	if (flags & ROFFNUM_WHITE)
		while (isspace((unsigned char)v[p]))
			p++;

	for (*res = 0; isdigit((unsigned char)v[p]); p++)
		*res = 10 * *res + v[p] - '0';
	if (p == *pos + n)
		return 0;

	if (n)
		*res = -*res;

	/* Each number may be followed by one optional scaling unit. */

	switch (v[p]) {
	case 'f':
		scaled = *res * 65536;
		break;
	case 'i':
		scaled = *res * 240;
		break;
	case 'c':
		scaled = *res * 240 / 2.54;
		break;
	case 'v':
	case 'P':
		scaled = *res * 40;
		break;
	case 'm':
	case 'n':
		scaled = *res * 24;
		break;
	case 'p':
		scaled = *res * 10 / 3;
		break;
	case 'u':
		scaled = *res;
		break;
	case 'M':
		scaled = *res * 6 / 25;
		break;
	default:
		scaled = *res;
		p--;
		break;
	}
	if (flags & ROFFNUM_SCALE)
		*res = scaled;

	*pos = p + 1;
	return 1;
}

/*
 * Evaluate a string comparison condition.
 * The first character is the delimiter.
 * Succeed if the string up to its second occurrence
 * matches the string up to its third occurence.
 * Advance the cursor after the third occurrence
 * or lacking that, to the end of the line.
 */
static int
roff_evalstrcond(const char *v, int *pos)
{
	const char	*s1, *s2, *s3;
	int		 match;

	match = 0;
	s1 = v + *pos;		/* initial delimiter */
	s2 = s1 + 1;		/* for scanning the first string */
	s3 = strchr(s2, *s1);	/* for scanning the second string */

	if (NULL == s3)		/* found no middle delimiter */
		goto out;

	while ('\0' != *++s3) {
		if (*s2 != *s3) {  /* mismatch */
			s3 = strchr(s3, *s1);
			break;
		}
		if (*s3 == *s1) {  /* found the final delimiter */
			match = 1;
			break;
		}
		s2++;
	}

out:
	if (NULL == s3)
		s3 = strchr(s2, '\0');
	else if (*s3 != '\0')
		s3++;
	*pos = s3 - v;
	return match;
}

/*
 * Evaluate an optionally negated single character, numerical,
 * or string condition.
 */
static int
roff_evalcond(struct roff *r, int ln, char *v, int *pos)
{
	char	*cp, *name;
	size_t	 sz;
	int	 deftype, number, savepos, istrue, wanttrue;

	if ('!' == v[*pos]) {
		wanttrue = 0;
		(*pos)++;
	} else
		wanttrue = 1;

	switch (v[*pos]) {
	case '\0':
		return 0;
	case 'n':
	case 'o':
		(*pos)++;
		return wanttrue;
	case 'c':
	case 'e':
	case 't':
	case 'v':
		(*pos)++;
		return !wanttrue;
	case 'd':
	case 'r':
		cp = v + *pos + 1;
		while (*cp == ' ')
			cp++;
		name = cp;
		sz = roff_getname(r, &cp, ln, cp - v);
		if (sz == 0)
			istrue = 0;
		else if (v[*pos] == 'r')
			istrue = roff_hasregn(r, name, sz);
		else {
			deftype = ROFFDEF_ANY;
		        roff_getstrn(r, name, sz, &deftype);
			istrue = !!deftype;
		}
		*pos = cp - v;
		return istrue == wanttrue;
	default:
		break;
	}

	savepos = *pos;
	if (roff_evalnum(r, ln, v, pos, &number, ROFFNUM_SCALE))
		return (number > 0) == wanttrue;
	else if (*pos == savepos)
		return roff_evalstrcond(v, pos) == wanttrue;
	else
		return 0;
}

static enum rofferr
roff_line_ignore(ROFF_ARGS)
{

	return ROFF_IGN;
}

static enum rofferr
roff_insec(ROFF_ARGS)
{

	mandoc_msg(MANDOCERR_REQ_INSEC, r->parse,
	    ln, ppos, roff_name[tok]);
	return ROFF_IGN;
}

static enum rofferr
roff_unsupp(ROFF_ARGS)
{

	mandoc_msg(MANDOCERR_REQ_UNSUPP, r->parse,
	    ln, ppos, roff_name[tok]);
	return ROFF_IGN;
}

static enum rofferr
roff_cond(ROFF_ARGS)
{

	roffnode_push(r, tok, NULL, ln, ppos);

	/*
	 * An `.el' has no conditional body: it will consume the value
	 * of the current rstack entry set in prior `ie' calls or
	 * defaults to DENY.
	 *
	 * If we're not an `el', however, then evaluate the conditional.
	 */

	r->last->rule = tok == ROFF_el ?
	    (r->rstackpos < 0 ? 0 : r->rstack[r->rstackpos--]) :
	    roff_evalcond(r, ln, buf->buf, &pos);

	/*
	 * An if-else will put the NEGATION of the current evaluated
	 * conditional into the stack of rules.
	 */

	if (tok == ROFF_ie) {
		if (r->rstackpos + 1 == r->rstacksz) {
			r->rstacksz += 16;
			r->rstack = mandoc_reallocarray(r->rstack,
			    r->rstacksz, sizeof(int));
		}
		r->rstack[++r->rstackpos] = !r->last->rule;
	}

	/* If the parent has false as its rule, then so do we. */

	if (r->last->parent && !r->last->parent->rule)
		r->last->rule = 0;

	/*
	 * Determine scope.
	 * If there is nothing on the line after the conditional,
	 * not even whitespace, use next-line scope.
	 */

	if (buf->buf[pos] == '\0') {
		r->last->endspan = 2;
		goto out;
	}

	while (buf->buf[pos] == ' ')
		pos++;

	/* An opening brace requests multiline scope. */

	if (buf->buf[pos] == '\\' && buf->buf[pos + 1] == '{') {
		r->last->endspan = -1;
		pos += 2;
		while (buf->buf[pos] == ' ')
			pos++;
		goto out;
	}

	/*
	 * Anything else following the conditional causes
	 * single-line scope.  Warn if the scope contains
	 * nothing but trailing whitespace.
	 */

	if (buf->buf[pos] == '\0')
		mandoc_msg(MANDOCERR_COND_EMPTY, r->parse,
		    ln, ppos, roff_name[tok]);

	r->last->endspan = 1;

out:
	*offs = pos;
	return ROFF_RERUN;
}

static enum rofferr
roff_ds(ROFF_ARGS)
{
	char		*string;
	const char	*name;
	size_t		 namesz;

	/* Ignore groff compatibility mode for now. */

	if (tok == ROFF_ds1)
		tok = ROFF_ds;
	else if (tok == ROFF_as1)
		tok = ROFF_as;

	/*
	 * The first word is the name of the string.
	 * If it is empty or terminated by an escape sequence,
	 * abort the `ds' request without defining anything.
	 */

	name = string = buf->buf + pos;
	if (*name == '\0')
		return ROFF_IGN;

	namesz = roff_getname(r, &string, ln, pos);
	if (name[namesz] == '\\')
		return ROFF_IGN;

	/* Read past the initial double-quote, if any. */
	if (*string == '"')
		string++;

	/* The rest is the value. */
	roff_setstrn(&r->strtab, name, namesz, string, strlen(string),
	    ROFF_as == tok);
	roff_setstrn(&r->rentab, name, namesz, NULL, 0, 0);
	return ROFF_IGN;
}

/*
 * Parse a single operator, one or two characters long.
 * If the operator is recognized, return success and advance the
 * parse point, else return failure and let the parse point unchanged.
 */
static int
roff_getop(const char *v, int *pos, char *res)
{

	*res = v[*pos];

	switch (*res) {
	case '+':
	case '-':
	case '*':
	case '/':
	case '%':
	case '&':
	case ':':
		break;
	case '<':
		switch (v[*pos + 1]) {
		case '=':
			*res = 'l';
			(*pos)++;
			break;
		case '>':
			*res = '!';
			(*pos)++;
			break;
		case '?':
			*res = 'i';
			(*pos)++;
			break;
		default:
			break;
		}
		break;
	case '>':
		switch (v[*pos + 1]) {
		case '=':
			*res = 'g';
			(*pos)++;
			break;
		case '?':
			*res = 'a';
			(*pos)++;
			break;
		default:
			break;
		}
		break;
	case '=':
		if ('=' == v[*pos + 1])
			(*pos)++;
		break;
	default:
		return 0;
	}
	(*pos)++;

	return *res;
}

/*
 * Evaluate either a parenthesized numeric expression
 * or a single signed integer number.
 */
static int
roff_evalpar(struct roff *r, int ln,
	const char *v, int *pos, int *res, int flags)
{

	if ('(' != v[*pos])
		return roff_getnum(v, pos, res, flags);

	(*pos)++;
	if ( ! roff_evalnum(r, ln, v, pos, res, flags | ROFFNUM_WHITE))
		return 0;

	/*
	 * Omission of the closing parenthesis
	 * is an error in validation mode,
	 * but ignored in evaluation mode.
	 */

	if (')' == v[*pos])
		(*pos)++;
	else if (NULL == res)
		return 0;

	return 1;
}

/*
 * Evaluate a complete numeric expression.
 * Proceed left to right, there is no concept of precedence.
 */
static int
roff_evalnum(struct roff *r, int ln, const char *v,
	int *pos, int *res, int flags)
{
	int		 mypos, operand2;
	char		 operator;

	if (NULL == pos) {
		mypos = 0;
		pos = &mypos;
	}

	if (flags & ROFFNUM_WHITE)
		while (isspace((unsigned char)v[*pos]))
			(*pos)++;

	if ( ! roff_evalpar(r, ln, v, pos, res, flags))
		return 0;

	while (1) {
		if (flags & ROFFNUM_WHITE)
			while (isspace((unsigned char)v[*pos]))
				(*pos)++;

		if ( ! roff_getop(v, pos, &operator))
			break;

		if (flags & ROFFNUM_WHITE)
			while (isspace((unsigned char)v[*pos]))
				(*pos)++;

		if ( ! roff_evalpar(r, ln, v, pos, &operand2, flags))
			return 0;

		if (flags & ROFFNUM_WHITE)
			while (isspace((unsigned char)v[*pos]))
				(*pos)++;

		if (NULL == res)
			continue;

		switch (operator) {
		case '+':
			*res += operand2;
			break;
		case '-':
			*res -= operand2;
			break;
		case '*':
			*res *= operand2;
			break;
		case '/':
			if (operand2 == 0) {
				mandoc_msg(MANDOCERR_DIVZERO,
					r->parse, ln, *pos, v);
				*res = 0;
				break;
			}
			*res /= operand2;
			break;
		case '%':
			if (operand2 == 0) {
				mandoc_msg(MANDOCERR_DIVZERO,
					r->parse, ln, *pos, v);
				*res = 0;
				break;
			}
			*res %= operand2;
			break;
		case '<':
			*res = *res < operand2;
			break;
		case '>':
			*res = *res > operand2;
			break;
		case 'l':
			*res = *res <= operand2;
			break;
		case 'g':
			*res = *res >= operand2;
			break;
		case '=':
			*res = *res == operand2;
			break;
		case '!':
			*res = *res != operand2;
			break;
		case '&':
			*res = *res && operand2;
			break;
		case ':':
			*res = *res || operand2;
			break;
		case 'i':
			if (operand2 < *res)
				*res = operand2;
			break;
		case 'a':
			if (operand2 > *res)
				*res = operand2;
			break;
		default:
			abort();
		}
	}
	return 1;
}

/* --- register management ------------------------------------------------ */

void
roff_setreg(struct roff *r, const char *name, int val, char sign)
{
	struct roffreg	*reg;

	/* Search for an existing register with the same name. */
	reg = r->regtab;

	while (reg && strcmp(name, reg->key.p))
		reg = reg->next;

	if (NULL == reg) {
		/* Create a new register. */
		reg = mandoc_malloc(sizeof(struct roffreg));
		reg->key.p = mandoc_strdup(name);
		reg->key.sz = strlen(name);
		reg->val = 0;
		reg->next = r->regtab;
		r->regtab = reg;
	}

	if ('+' == sign)
		reg->val += val;
	else if ('-' == sign)
		reg->val -= val;
	else
		reg->val = val;
}

/*
 * Handle some predefined read-only number registers.
 * For now, return -1 if the requested register is not predefined;
 * in case a predefined read-only register having the value -1
 * were to turn up, another special value would have to be chosen.
 */
static int
roff_getregro(const struct roff *r, const char *name)
{

	switch (*name) {
	case '$':  /* Number of arguments of the last macro evaluated. */
		return r->argc;
	case 'A':  /* ASCII approximation mode is always off. */
		return 0;
	case 'g':  /* Groff compatibility mode is always on. */
		return 1;
	case 'H':  /* Fixed horizontal resolution. */
		return 24;
	case 'j':  /* Always adjust left margin only. */
		return 0;
	case 'T':  /* Some output device is always defined. */
		return 1;
	case 'V':  /* Fixed vertical resolution. */
		return 40;
	default:
		return -1;
	}
}

int
roff_getreg(const struct roff *r, const char *name)
{
	struct roffreg	*reg;
	int		 val;

	if ('.' == name[0] && '\0' != name[1] && '\0' == name[2]) {
		val = roff_getregro(r, name + 1);
		if (-1 != val)
			return val;
	}

	for (reg = r->regtab; reg; reg = reg->next)
		if (0 == strcmp(name, reg->key.p))
			return reg->val;

	return 0;
}

static int
roff_getregn(const struct roff *r, const char *name, size_t len)
{
	struct roffreg	*reg;
	int		 val;

	if ('.' == name[0] && 2 == len) {
		val = roff_getregro(r, name + 1);
		if (-1 != val)
			return val;
	}

	for (reg = r->regtab; reg; reg = reg->next)
		if (len == reg->key.sz &&
		    0 == strncmp(name, reg->key.p, len))
			return reg->val;

	return 0;
}

static int
roff_hasregn(const struct roff *r, const char *name, size_t len)
{
	struct roffreg	*reg;
	int		 val;

	if ('.' == name[0] && 2 == len) {
		val = roff_getregro(r, name + 1);
		if (-1 != val)
			return 1;
	}

	for (reg = r->regtab; reg; reg = reg->next)
		if (len == reg->key.sz &&
		    0 == strncmp(name, reg->key.p, len))
			return 1;

	return 0;
}

static void
roff_freereg(struct roffreg *reg)
{
	struct roffreg	*old_reg;

	while (NULL != reg) {
		free(reg->key.p);
		old_reg = reg;
		reg = reg->next;
		free(old_reg);
	}
}

static enum rofferr
roff_nr(ROFF_ARGS)
{
	char		*key, *val;
	size_t		 keysz;
	int		 iv;
	char		 sign;

	key = val = buf->buf + pos;
	if (*key == '\0')
		return ROFF_IGN;

	keysz = roff_getname(r, &val, ln, pos);
	if (key[keysz] == '\\')
		return ROFF_IGN;
	key[keysz] = '\0';

	sign = *val;
	if (sign == '+' || sign == '-')
		val++;

	if (roff_evalnum(r, ln, val, NULL, &iv, ROFFNUM_SCALE))
		roff_setreg(r, key, iv, sign);

	return ROFF_IGN;
}

static enum rofferr
roff_rr(ROFF_ARGS)
{
	struct roffreg	*reg, **prev;
	char		*name, *cp;
	size_t		 namesz;

	name = cp = buf->buf + pos;
	if (*name == '\0')
		return ROFF_IGN;
	namesz = roff_getname(r, &cp, ln, pos);
	name[namesz] = '\0';

	prev = &r->regtab;
	while (1) {
		reg = *prev;
		if (reg == NULL || !strcmp(name, reg->key.p))
			break;
		prev = &reg->next;
	}
	if (reg != NULL) {
		*prev = reg->next;
		free(reg->key.p);
		free(reg);
	}
	return ROFF_IGN;
}

/* --- handler functions for roff requests -------------------------------- */

static enum rofferr
roff_rm(ROFF_ARGS)
{
	const char	 *name;
	char		 *cp;
	size_t		  namesz;

	cp = buf->buf + pos;
	while (*cp != '\0') {
		name = cp;
		namesz = roff_getname(r, &cp, ln, (int)(cp - buf->buf));
		roff_setstrn(&r->strtab, name, namesz, NULL, 0, 0);
		roff_setstrn(&r->rentab, name, namesz, NULL, 0, 0);
		if (name[namesz] == '\\')
			break;
	}
	return ROFF_IGN;
}

static enum rofferr
roff_it(ROFF_ARGS)
{
	int		 iv;

	/* Parse the number of lines. */

	if ( ! roff_evalnum(r, ln, buf->buf, &pos, &iv, 0)) {
		mandoc_msg(MANDOCERR_IT_NONUM, r->parse,
		    ln, ppos, buf->buf + 1);
		return ROFF_IGN;
	}

	while (isspace((unsigned char)buf->buf[pos]))
		pos++;

	/*
	 * Arm the input line trap.
	 * Special-casing "an-trap" is an ugly workaround to cope
	 * with DocBook stupidly fiddling with man(7) internals.
	 */

	roffit_lines = iv;
	roffit_macro = mandoc_strdup(iv != 1 ||
	    strcmp(buf->buf + pos, "an-trap") ?
	    buf->buf + pos : "br");
	return ROFF_IGN;
}

static enum rofferr
roff_Dd(ROFF_ARGS)
{
	int		 mask;
	enum roff_tok	 t, te;

	switch (tok) {
	case ROFF_Dd:
		tok = MDOC_Dd;
		te = MDOC_MAX;
		if (r->format == 0)
			r->format = MPARSE_MDOC;
		mask = MPARSE_MDOC | MPARSE_QUICK;
		break;
	case ROFF_TH:
		tok = MAN_TH;
		te = MAN_MAX;
		if (r->format == 0)
			r->format = MPARSE_MAN;
		mask = MPARSE_QUICK;
		break;
	default:
		abort();
	}
	if ((r->options & mask) == 0)
		for (t = tok; t < te; t++)
			roff_setstr(r, roff_name[t], NULL, 0);
	return ROFF_CONT;
}

static enum rofferr
roff_TE(ROFF_ARGS)
{

	if (NULL == r->tbl)
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "TE");
	else if ( ! tbl_end(&r->tbl)) {
		free(buf->buf);
		buf->buf = mandoc_strdup(".sp");
		buf->sz = 4;
		return ROFF_REPARSE;
	}
	return ROFF_IGN;
}

static enum rofferr
roff_T_(ROFF_ARGS)
{

	if (NULL == r->tbl)
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "T&");
	else
		tbl_restart(ln, ppos, r->tbl);

	return ROFF_IGN;
}

/*
 * Handle in-line equation delimiters.
 */
static enum rofferr
roff_eqndelim(struct roff *r, struct buf *buf, int pos)
{
	char		*cp1, *cp2;
	const char	*bef_pr, *bef_nl, *mac, *aft_nl, *aft_pr;

	/*
	 * Outside equations, look for an opening delimiter.
	 * If we are inside an equation, we already know it is
	 * in-line, or this function wouldn't have been called;
	 * so look for a closing delimiter.
	 */

	cp1 = buf->buf + pos;
	cp2 = strchr(cp1, r->eqn == NULL ?
	    r->last_eqn->odelim : r->last_eqn->cdelim);
	if (cp2 == NULL)
		return ROFF_CONT;

	*cp2++ = '\0';
	bef_pr = bef_nl = aft_nl = aft_pr = "";

	/* Handle preceding text, protecting whitespace. */

	if (*buf->buf != '\0') {
		if (r->eqn == NULL)
			bef_pr = "\\&";
		bef_nl = "\n";
	}

	/*
	 * Prepare replacing the delimiter with an equation macro
	 * and drop leading white space from the equation.
	 */

	if (r->eqn == NULL) {
		while (*cp2 == ' ')
			cp2++;
		mac = ".EQ";
	} else
		mac = ".EN";

	/* Handle following text, protecting whitespace. */

	if (*cp2 != '\0') {
		aft_nl = "\n";
		if (r->eqn != NULL)
			aft_pr = "\\&";
	}

	/* Do the actual replacement. */

	buf->sz = mandoc_asprintf(&cp1, "%s%s%s%s%s%s%s", buf->buf,
	    bef_pr, bef_nl, mac, aft_nl, aft_pr, cp2) + 1;
	free(buf->buf);
	buf->buf = cp1;

	/* Toggle the in-line state of the eqn subsystem. */

	r->eqn_inline = r->eqn == NULL;
	return ROFF_REPARSE;
}

static enum rofferr
roff_EQ(ROFF_ARGS)
{
	struct roff_node	*n;

	n = roff_node_alloc(r->man, ln, ppos, ROFFT_EQN, TOKEN_NONE);
	if (ln > r->man->last->line)
		n->flags |= NODE_LINE;
	n->eqn = mandoc_calloc(1, sizeof(*n->eqn));
	n->eqn->expectargs = UINT_MAX;
	roff_node_append(r->man, n);
	r->man->next = ROFF_NEXT_SIBLING;

	assert(r->eqn == NULL);
	if (r->last_eqn == NULL)
		r->last_eqn = eqn_alloc(r->parse);
	else
		eqn_reset(r->last_eqn);
	r->eqn = r->last_eqn;
	r->eqn->node = n;

	if (buf->buf[pos] != '\0')
		mandoc_vmsg(MANDOCERR_ARG_SKIP, r->parse, ln, pos,
		    ".EQ %s", buf->buf + pos);

	return ROFF_IGN;
}

static enum rofferr
roff_EN(ROFF_ARGS)
{
	if (r->eqn != NULL) {
		eqn_parse(r->eqn);
		r->eqn = NULL;
	} else
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse, ln, ppos, "EN");
	if (buf->buf[pos] != '\0')
		mandoc_vmsg(MANDOCERR_ARG_SKIP, r->parse, ln, pos,
		    "EN %s", buf->buf + pos);
	return ROFF_IGN;
}

static enum rofferr
roff_TS(ROFF_ARGS)
{
	struct tbl_node	*tbl;

	if (r->tbl) {
		mandoc_msg(MANDOCERR_BLK_BROKEN, r->parse,
		    ln, ppos, "TS breaks TS");
		tbl_end(&r->tbl);
	}

	tbl = tbl_alloc(ppos, ln, r->parse);

	if (r->last_tbl)
		r->last_tbl->next = tbl;
	else
		r->first_tbl = r->last_tbl = tbl;

	r->tbl = r->last_tbl = tbl;
	return ROFF_IGN;
}

static enum rofferr
roff_onearg(ROFF_ARGS)
{
	struct roff_node	*n;
	char			*cp;
	int			 npos;

	if (r->man->flags & (MAN_BLINE | MAN_ELINE) &&
	    (tok == ROFF_ce || tok == ROFF_rj || tok == ROFF_sp ||
	     tok == ROFF_ti))
		man_breakscope(r->man, tok);

	if (roffce_node != NULL && (tok == ROFF_ce || tok == ROFF_rj)) {
		r->man->last = roffce_node;
		r->man->next = ROFF_NEXT_SIBLING;
	}

	roff_elem_alloc(r->man, ln, ppos, tok);
	n = r->man->last;

	cp = buf->buf + pos;
	if (*cp != '\0') {
		while (*cp != '\0' && *cp != ' ')
			cp++;
		while (*cp == ' ')
			*cp++ = '\0';
		if (*cp != '\0')
			mandoc_vmsg(MANDOCERR_ARG_EXCESS,
			    r->parse, ln, cp - buf->buf,
			    "%s ... %s", roff_name[tok], cp);
		roff_word_alloc(r->man, ln, pos, buf->buf + pos);
	}

	if (tok == ROFF_ce || tok == ROFF_rj) {
		if (r->man->last->type == ROFFT_ELEM) {
			roff_word_alloc(r->man, ln, pos, "1");
			r->man->last->flags |= NODE_NOSRC;
		}
		npos = 0;
		if (roff_evalnum(r, ln, r->man->last->string, &npos,
		    &roffce_lines, 0) == 0) {
			mandoc_vmsg(MANDOCERR_CE_NONUM,
			    r->parse, ln, pos, "ce %s", buf->buf + pos);
			roffce_lines = 1;
		}
		if (roffce_lines < 1) {
			r->man->last = r->man->last->parent;
			roffce_node = NULL;
			roffce_lines = 0;
		} else
			roffce_node = r->man->last->parent;
	} else {
		n->flags |= NODE_VALID | NODE_ENDED;
		r->man->last = n;
	}
	n->flags |= NODE_LINE;
	r->man->next = ROFF_NEXT_SIBLING;
	return ROFF_IGN;
}

static enum rofferr
roff_manyarg(ROFF_ARGS)
{
	struct roff_node	*n;
	char			*sp, *ep;

	roff_elem_alloc(r->man, ln, ppos, tok);
	n = r->man->last;

	for (sp = ep = buf->buf + pos; *sp != '\0'; sp = ep) {
		while (*ep != '\0' && *ep != ' ')
			ep++;
		while (*ep == ' ')
			*ep++ = '\0';
		roff_word_alloc(r->man, ln, sp - buf->buf, sp);
	}

	n->flags |= NODE_LINE | NODE_VALID | NODE_ENDED;
	r->man->last = n;
	r->man->next = ROFF_NEXT_SIBLING;
	return ROFF_IGN;
}

static enum rofferr
roff_als(ROFF_ARGS)
{
	char		*oldn, *newn, *end, *value;
	size_t		 oldsz, newsz, valsz;

	newn = oldn = buf->buf + pos;
	if (*newn == '\0')
		return ROFF_IGN;

	newsz = roff_getname(r, &oldn, ln, pos);
	if (newn[newsz] == '\\' || *oldn == '\0')
		return ROFF_IGN;

	end = oldn;
	oldsz = roff_getname(r, &end, ln, oldn - buf->buf);
	if (oldsz == 0)
		return ROFF_IGN;

	valsz = mandoc_asprintf(&value, ".%.*s \\$*\\\"\n",
	    (int)oldsz, oldn);
	roff_setstrn(&r->strtab, newn, newsz, value, valsz, 0);
	roff_setstrn(&r->rentab, newn, newsz, NULL, 0, 0);
	free(value);
	return ROFF_IGN;
}

static enum rofferr
roff_br(ROFF_ARGS)
{
	if (r->man->flags & (MAN_BLINE | MAN_ELINE))
		man_breakscope(r->man, ROFF_br);
	roff_elem_alloc(r->man, ln, ppos, ROFF_br);
	if (buf->buf[pos] != '\0')
		mandoc_vmsg(MANDOCERR_ARG_SKIP, r->parse, ln, pos,
		    "%s %s", roff_name[tok], buf->buf + pos);
	r->man->last->flags |= NODE_LINE | NODE_VALID | NODE_ENDED;
	r->man->next = ROFF_NEXT_SIBLING;
	return ROFF_IGN;
}

static enum rofferr
roff_cc(ROFF_ARGS)
{
	const char	*p;

	p = buf->buf + pos;

	if (*p == '\0' || (r->control = *p++) == '.')
		r->control = '\0';

	if (*p != '\0')
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, r->parse,
		    ln, p - buf->buf, "cc ... %s", p);

	return ROFF_IGN;
}

static enum rofferr
roff_ec(ROFF_ARGS)
{
	const char	*p;

	p = buf->buf + pos;
	if (*p == '\0')
		r->escape = '\\';
	else {
		r->escape = *p;
		if (*++p != '\0')
			mandoc_vmsg(MANDOCERR_ARG_EXCESS, r->parse,
			    ln, p - buf->buf, "ec ... %s", p);
	}
	return ROFF_IGN;
}

static enum rofferr
roff_eo(ROFF_ARGS)
{
	r->escape = '\0';
	if (buf->buf[pos] != '\0')
		mandoc_vmsg(MANDOCERR_ARG_SKIP, r->parse,
		    ln, pos, "eo %s", buf->buf + pos);
	return ROFF_IGN;
}

static enum rofferr
roff_tr(ROFF_ARGS)
{
	const char	*p, *first, *second;
	size_t		 fsz, ssz;
	enum mandoc_esc	 esc;

	p = buf->buf + pos;

	if (*p == '\0') {
		mandoc_msg(MANDOCERR_REQ_EMPTY, r->parse, ln, ppos, "tr");
		return ROFF_IGN;
	}

	while (*p != '\0') {
		fsz = ssz = 1;

		first = p++;
		if (*first == '\\') {
			esc = mandoc_escape(&p, NULL, NULL);
			if (esc == ESCAPE_ERROR) {
				mandoc_msg(MANDOCERR_ESC_BAD, r->parse,
				    ln, (int)(p - buf->buf), first);
				return ROFF_IGN;
			}
			fsz = (size_t)(p - first);
		}

		second = p++;
		if (*second == '\\') {
			esc = mandoc_escape(&p, NULL, NULL);
			if (esc == ESCAPE_ERROR) {
				mandoc_msg(MANDOCERR_ESC_BAD, r->parse,
				    ln, (int)(p - buf->buf), second);
				return ROFF_IGN;
			}
			ssz = (size_t)(p - second);
		} else if (*second == '\0') {
			mandoc_vmsg(MANDOCERR_TR_ODD, r->parse,
			    ln, first - buf->buf, "tr %s", first);
			second = " ";
			p--;
		}

		if (fsz > 1) {
			roff_setstrn(&r->xmbtab, first, fsz,
			    second, ssz, 0);
			continue;
		}

		if (r->xtab == NULL)
			r->xtab = mandoc_calloc(128,
			    sizeof(struct roffstr));

		free(r->xtab[(int)*first].p);
		r->xtab[(int)*first].p = mandoc_strndup(second, ssz);
		r->xtab[(int)*first].sz = ssz;
	}

	return ROFF_IGN;
}

static enum rofferr
roff_rn(ROFF_ARGS)
{
	const char	*value;
	char		*oldn, *newn, *end;
	size_t		 oldsz, newsz;
	int		 deftype;

	oldn = newn = buf->buf + pos;
	if (*oldn == '\0')
		return ROFF_IGN;

	oldsz = roff_getname(r, &newn, ln, pos);
	if (oldn[oldsz] == '\\' || *newn == '\0')
		return ROFF_IGN;

	end = newn;
	newsz = roff_getname(r, &end, ln, newn - buf->buf);
	if (newsz == 0)
		return ROFF_IGN;

	deftype = ROFFDEF_ANY;
	value = roff_getstrn(r, oldn, oldsz, &deftype);
	switch (deftype) {
	case ROFFDEF_USER:
		roff_setstrn(&r->strtab, newn, newsz, value, strlen(value), 0);
		roff_setstrn(&r->strtab, oldn, oldsz, NULL, 0, 0);
		roff_setstrn(&r->rentab, newn, newsz, NULL, 0, 0);
		break;
	case ROFFDEF_PRE:
		roff_setstrn(&r->strtab, newn, newsz, value, strlen(value), 0);
		roff_setstrn(&r->rentab, newn, newsz, NULL, 0, 0);
		break;
	case ROFFDEF_REN:
		roff_setstrn(&r->rentab, newn, newsz, value, strlen(value), 0);
		roff_setstrn(&r->rentab, oldn, oldsz, NULL, 0, 0);
		roff_setstrn(&r->strtab, newn, newsz, NULL, 0, 0);
		break;
	case ROFFDEF_STD:
		roff_setstrn(&r->rentab, newn, newsz, oldn, oldsz, 0);
		roff_setstrn(&r->strtab, newn, newsz, NULL, 0, 0);
		break;
	default:
		roff_setstrn(&r->strtab, newn, newsz, NULL, 0, 0);
		roff_setstrn(&r->rentab, newn, newsz, NULL, 0, 0);
		break;
	}
	return ROFF_IGN;
}

static enum rofferr
roff_so(ROFF_ARGS)
{
	char *name, *cp;

	name = buf->buf + pos;
	mandoc_vmsg(MANDOCERR_SO, r->parse, ln, ppos, "so %s", name);

	/*
	 * Handle `so'.  Be EXTREMELY careful, as we shouldn't be
	 * opening anything that's not in our cwd or anything beneath
	 * it.  Thus, explicitly disallow traversing up the file-system
	 * or using absolute paths.
	 */

	if (*name == '/' || strstr(name, "../") || strstr(name, "/..")) {
		mandoc_vmsg(MANDOCERR_SO_PATH, r->parse, ln, ppos,
		    ".so %s", name);
		buf->sz = mandoc_asprintf(&cp,
		    ".sp\nSee the file %s.\n.sp", name) + 1;
		free(buf->buf);
		buf->buf = cp;
		*offs = 0;
		return ROFF_REPARSE;
	}

	*offs = pos;
	return ROFF_SO;
}

/* --- user defined strings and macros ------------------------------------ */

static enum rofferr
roff_userdef(ROFF_ARGS)
{
	const char	 *arg[16], *ap;
	char		 *cp, *n1, *n2;
	int		  expand_count, i, ib, ie;
	size_t		  asz, rsz;

	/*
	 * Collect pointers to macro argument strings
	 * and NUL-terminate them.
	 */

	r->argc = 0;
	cp = buf->buf + pos;
	for (i = 0; i < 16; i++) {
		if (*cp == '\0')
			arg[i] = "";
		else {
			arg[i] = mandoc_getarg(r->parse, &cp, ln, &pos);
			r->argc = i + 1;
		}
	}

	/*
	 * Expand macro arguments.
	 */

	buf->sz = strlen(r->current_string) + 1;
	n1 = n2 = cp = mandoc_malloc(buf->sz);
	memcpy(n1, r->current_string, buf->sz);
	expand_count = 0;
	while (*cp != '\0') {

		/* Scan ahead for the next argument invocation. */

		if (*cp++ != '\\')
			continue;
		if (*cp++ != '$')
			continue;
		if (*cp == '*') {  /* \\$* inserts all arguments */
			ib = 0;
			ie = r->argc - 1;
		} else {  /* \\$1 .. \\$9 insert one argument */
			ib = ie = *cp - '1';
			if (ib < 0 || ib > 8)
				continue;
		}
		cp -= 2;

		/*
		 * Prevent infinite recursion.
		 */

		if (cp >= n2)
			expand_count = 1;
		else if (++expand_count > EXPAND_LIMIT) {
			mandoc_msg(MANDOCERR_ROFFLOOP, r->parse,
			    ln, (int)(cp - n1), NULL);
			free(buf->buf);
			buf->buf = n1;
			return ROFF_IGN;
		}

		/*
		 * Determine the size of the expanded argument,
		 * taking escaping of quotes into account.
		 */

		asz = ie > ib ? ie - ib : 0;  /* for blanks */
		for (i = ib; i <= ie; i++) {
			for (ap = arg[i]; *ap != '\0'; ap++) {
				asz++;
				if (*ap == '"')
					asz += 3;
			}
		}
		if (asz != 3) {

			/*
			 * Determine the size of the rest of the
			 * unexpanded macro, including the NUL.
			 */

			rsz = buf->sz - (cp - n1) - 3;

			/*
			 * When shrinking, move before
			 * releasing the storage.
			 */

			if (asz < 3)
				memmove(cp + asz, cp + 3, rsz);

			/*
			 * Resize the storage for the macro
			 * and readjust the parse pointer.
			 */

			buf->sz += asz - 3;
			n2 = mandoc_realloc(n1, buf->sz);
			cp = n2 + (cp - n1);
			n1 = n2;

			/*
			 * When growing, make room
			 * for the expanded argument.
			 */

			if (asz > 3)
				memmove(cp + asz, cp + 3, rsz);
		}

		/* Copy the expanded argument, escaping quotes. */

		n2 = cp;
		for (i = ib; i <= ie; i++) {
			for (ap = arg[i]; *ap != '\0'; ap++) {
				if (*ap == '"') {
					memcpy(n2, "\\(dq", 4);
					n2 += 4;
				} else
					*n2++ = *ap;
			}
			if (i < ie)
				*n2++ = ' ';
		}
	}

	/*
	 * Replace the macro invocation
	 * by the expanded macro.
	 */

	free(buf->buf);
	buf->buf = n1;
	*offs = 0;

	return buf->sz > 1 && buf->buf[buf->sz - 2] == '\n' ?
	   ROFF_REPARSE : ROFF_APPEND;
}

/*
 * Calling a high-level macro that was renamed with .rn.
 * r->current_string has already been set up by roff_parse().
 */
static enum rofferr
roff_renamed(ROFF_ARGS)
{
	char	*nbuf;

	buf->sz = mandoc_asprintf(&nbuf, ".%s%s%s", r->current_string,
	    buf->buf[pos] == '\0' ? "" : " ", buf->buf + pos) + 1;
	free(buf->buf);
	buf->buf = nbuf;
	return ROFF_CONT;
}

static size_t
roff_getname(struct roff *r, char **cpp, int ln, int pos)
{
	char	 *name, *cp;
	size_t	  namesz;

	name = *cpp;
	if ('\0' == *name)
		return 0;

	/* Read until end of name and terminate it with NUL. */
	for (cp = name; 1; cp++) {
		if ('\0' == *cp || ' ' == *cp) {
			namesz = cp - name;
			break;
		}
		if ('\\' != *cp)
			continue;
		namesz = cp - name;
		if ('{' == cp[1] || '}' == cp[1])
			break;
		cp++;
		if ('\\' == *cp)
			continue;
		mandoc_vmsg(MANDOCERR_NAMESC, r->parse, ln, pos,
		    "%.*s", (int)(cp - name + 1), name);
		mandoc_escape((const char **)&cp, NULL, NULL);
		break;
	}

	/* Read past spaces. */
	while (' ' == *cp)
		cp++;

	*cpp = cp;
	return namesz;
}

/*
 * Store *string into the user-defined string called *name.
 * To clear an existing entry, call with (*r, *name, NULL, 0).
 * append == 0: replace mode
 * append == 1: single-line append mode
 * append == 2: multiline append mode, append '\n' after each call
 */
static void
roff_setstr(struct roff *r, const char *name, const char *string,
	int append)
{
	size_t	 namesz;

	namesz = strlen(name);
	roff_setstrn(&r->strtab, name, namesz, string,
	    string ? strlen(string) : 0, append);
	roff_setstrn(&r->rentab, name, namesz, NULL, 0, 0);
}

static void
roff_setstrn(struct roffkv **r, const char *name, size_t namesz,
		const char *string, size_t stringsz, int append)
{
	struct roffkv	*n;
	char		*c;
	int		 i;
	size_t		 oldch, newch;

	/* Search for an existing string with the same name. */
	n = *r;

	while (n && (namesz != n->key.sz ||
			strncmp(n->key.p, name, namesz)))
		n = n->next;

	if (NULL == n) {
		/* Create a new string table entry. */
		n = mandoc_malloc(sizeof(struct roffkv));
		n->key.p = mandoc_strndup(name, namesz);
		n->key.sz = namesz;
		n->val.p = NULL;
		n->val.sz = 0;
		n->next = *r;
		*r = n;
	} else if (0 == append) {
		free(n->val.p);
		n->val.p = NULL;
		n->val.sz = 0;
	}

	if (NULL == string)
		return;

	/*
	 * One additional byte for the '\n' in multiline mode,
	 * and one for the terminating '\0'.
	 */
	newch = stringsz + (1 < append ? 2u : 1u);

	if (NULL == n->val.p) {
		n->val.p = mandoc_malloc(newch);
		*n->val.p = '\0';
		oldch = 0;
	} else {
		oldch = n->val.sz;
		n->val.p = mandoc_realloc(n->val.p, oldch + newch);
	}

	/* Skip existing content in the destination buffer. */
	c = n->val.p + (int)oldch;

	/* Append new content to the destination buffer. */
	i = 0;
	while (i < (int)stringsz) {
		/*
		 * Rudimentary roff copy mode:
		 * Handle escaped backslashes.
		 */
		if ('\\' == string[i] && '\\' == string[i + 1])
			i++;
		*c++ = string[i++];
	}

	/* Append terminating bytes. */
	if (1 < append)
		*c++ = '\n';

	*c = '\0';
	n->val.sz = (int)(c - n->val.p);
}

static const char *
roff_getstrn(const struct roff *r, const char *name, size_t len,
    int *deftype)
{
	const struct roffkv	*n;
	int			 i;
	enum roff_tok		 tok;

	if (*deftype & ROFFDEF_USER) {
		for (n = r->strtab; n != NULL; n = n->next) {
			if (strncmp(name, n->key.p, len) == 0 &&
			    n->key.p[len] == '\0' &&
			    n->val.p != NULL) {
				*deftype = ROFFDEF_USER;
				return n->val.p;
			}
		}
	}
	if (*deftype & ROFFDEF_PRE) {
		for (i = 0; i < PREDEFS_MAX; i++) {
			if (strncmp(name, predefs[i].name, len) == 0 &&
			    predefs[i].name[len] == '\0') {
				*deftype = ROFFDEF_PRE;
				return predefs[i].str;
			}
		}
	}
	if (*deftype & ROFFDEF_REN) {
		for (n = r->rentab; n != NULL; n = n->next) {
			if (strncmp(name, n->key.p, len) == 0 &&
			    n->key.p[len] == '\0' &&
			    n->val.p != NULL) {
				*deftype = ROFFDEF_REN;
				return n->val.p;
			}
		}
	}
	if (*deftype & ROFFDEF_STD) {
		if (r->man->macroset != MACROSET_MAN) {
			for (tok = MDOC_Dd; tok < MDOC_MAX; tok++) {
				if (strncmp(name, roff_name[tok], len) == 0 &&
				    roff_name[tok][len] == '\0') {
					*deftype = ROFFDEF_STD;
					return NULL;
				}
			}
		}
		if (r->man->macroset != MACROSET_MDOC) {
			for (tok = MAN_TH; tok < MAN_MAX; tok++) {
				if (strncmp(name, roff_name[tok], len) == 0 &&
				    roff_name[tok][len] == '\0') {
					*deftype = ROFFDEF_STD;
					return NULL;
				}
			}
		}
	}
	*deftype = 0;
	return NULL;
}

static void
roff_freestr(struct roffkv *r)
{
	struct roffkv	 *n, *nn;

	for (n = r; n; n = nn) {
		free(n->key.p);
		free(n->val.p);
		nn = n->next;
		free(n);
	}
}

/* --- accessors and utility functions ------------------------------------ */

const struct tbl_span *
roff_span(const struct roff *r)
{

	return r->tbl ? tbl_span(r->tbl) : NULL;
}

/*
 * Duplicate an input string, making the appropriate character
 * conversations (as stipulated by `tr') along the way.
 * Returns a heap-allocated string with all the replacements made.
 */
char *
roff_strdup(const struct roff *r, const char *p)
{
	const struct roffkv *cp;
	char		*res;
	const char	*pp;
	size_t		 ssz, sz;
	enum mandoc_esc	 esc;

	if (NULL == r->xmbtab && NULL == r->xtab)
		return mandoc_strdup(p);
	else if ('\0' == *p)
		return mandoc_strdup("");

	/*
	 * Step through each character looking for term matches
	 * (remember that a `tr' can be invoked with an escape, which is
	 * a glyph but the escape is multi-character).
	 * We only do this if the character hash has been initialised
	 * and the string is >0 length.
	 */

	res = NULL;
	ssz = 0;

	while ('\0' != *p) {
		assert((unsigned int)*p < 128);
		if ('\\' != *p && r->xtab && r->xtab[(unsigned int)*p].p) {
			sz = r->xtab[(int)*p].sz;
			res = mandoc_realloc(res, ssz + sz + 1);
			memcpy(res + ssz, r->xtab[(int)*p].p, sz);
			ssz += sz;
			p++;
			continue;
		} else if ('\\' != *p) {
			res = mandoc_realloc(res, ssz + 2);
			res[ssz++] = *p++;
			continue;
		}

		/* Search for term matches. */
		for (cp = r->xmbtab; cp; cp = cp->next)
			if (0 == strncmp(p, cp->key.p, cp->key.sz))
				break;

		if (NULL != cp) {
			/*
			 * A match has been found.
			 * Append the match to the array and move
			 * forward by its keysize.
			 */
			res = mandoc_realloc(res,
			    ssz + cp->val.sz + 1);
			memcpy(res + ssz, cp->val.p, cp->val.sz);
			ssz += cp->val.sz;
			p += (int)cp->key.sz;
			continue;
		}

		/*
		 * Handle escapes carefully: we need to copy
		 * over just the escape itself, or else we might
		 * do replacements within the escape itself.
		 * Make sure to pass along the bogus string.
		 */
		pp = p++;
		esc = mandoc_escape(&p, NULL, NULL);
		if (ESCAPE_ERROR == esc) {
			sz = strlen(pp);
			res = mandoc_realloc(res, ssz + sz + 1);
			memcpy(res + ssz, pp, sz);
			break;
		}
		/*
		 * We bail out on bad escapes.
		 * No need to warn: we already did so when
		 * roff_res() was called.
		 */
		sz = (int)(p - pp);
		res = mandoc_realloc(res, ssz + sz + 1);
		memcpy(res + ssz, pp, sz);
		ssz += sz;
	}

	res[(int)ssz] = '\0';
	return res;
}

int
roff_getformat(const struct roff *r)
{

	return r->format;
}

/*
 * Find out whether a line is a macro line or not.
 * If it is, adjust the current position and return one; if it isn't,
 * return zero and don't change the current position.
 * If the control character has been set with `.cc', then let that grain
 * precedence.
 * This is slighly contrary to groff, where using the non-breaking
 * control character when `cc' has been invoked will cause the
 * non-breaking macro contents to be printed verbatim.
 */
int
roff_getcontrol(const struct roff *r, const char *cp, int *ppos)
{
	int		pos;

	pos = *ppos;

	if (r->control != '\0' && cp[pos] == r->control)
		pos++;
	else if (r->control != '\0')
		return 0;
	else if ('\\' == cp[pos] && '.' == cp[pos + 1])
		pos += 2;
	else if ('.' == cp[pos] || '\'' == cp[pos])
		pos++;
	else
		return 0;

	while (' ' == cp[pos] || '\t' == cp[pos])
		pos++;

	*ppos = pos;
	return 1;
}
@


1.191
log
@1. Eliminate struct eqn, instead use the existing members
of struct roff_node which is allocated for each equation anyway.
2. Do not keep a list of equation parsers, one parser is enough.
Minus fifty lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.190 2017/07/04 22:49:59 schwarze Exp $ */
d2935 2
a2936 1
	    (tok == ROFF_sp || tok == ROFF_ti))
@


1.190
log
@Fix handling of \} on roff request lines.
Cures bogus error messages in pages generated with pod2man(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.189 2017/06/25 07:23:53 bentley Exp $ */
d99 2
a100 3
	struct eqn_node	*last_eqn; /* last equation parsed */
	struct eqn_node	*first_eqn; /* first equation parsed */
	struct eqn_node	*eqn; /* current equation being parsed */
a694 1
	struct eqn_node	*e;
d703 3
a705 5
	while (NULL != (e = r->first_eqn)) {
		r->first_eqn = e->next;
		eqn_free(e);
	}
	r->first_eqn = r->last_eqn = r->eqn = NULL;
a980 13
roff_addeqn(struct roff_man *man, const struct eqn *eqn)
{
	struct roff_node	*n;

	n = roff_node_alloc(man, eqn->ln, eqn->pos, ROFFT_EQN, TOKEN_NONE);
	n->eqn = eqn;
	if (eqn->ln > man->last->line)
		n->flags |= NODE_LINE;
	roff_node_append(man, n);
	man->next = ROFF_NEXT_SIBLING;
}

void
d1039 2
d1498 4
a1501 2
	if (r->eqn != NULL)
		return eqn_read(&r->eqn, ln, buf->buf, ppos, offs);
d1581 3
a1583 2
		    r->eqn->eqn.ln, r->eqn->eqn.pos, "EQ");
		eqn_end(&r->eqn);
d2866 9
a2874 1
	struct eqn_node *e;
d2877 6
a2882 11
	e = eqn_alloc(ppos, ln, r->parse);

	if (r->last_eqn) {
		r->last_eqn->next = e;
		e->delim = r->last_eqn->delim;
		e->odelim = r->last_eqn->odelim;
		e->cdelim = r->last_eqn->cdelim;
	} else
		r->first_eqn = r->last_eqn = e;

	r->eqn = r->last_eqn = e;
d2894 8
a2901 2

	mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse, ln, ppos, "EN");
a3605 7
}

const struct eqn *
roff_eqn(const struct roff *r)
{

	return r->last_eqn ? &r->last_eqn->eqn : NULL;
@


1.189
log
@Add support for the MT and ME mailto macros, used for example in wg(8).

feedback and ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.188 2017/06/24 14:38:28 schwarze Exp $ */
a1926 9
	t = roff_parse(r, buf->buf, &pos, ln, ppos);

	/*
	 * Fully handle known macros when they are structurally
	 * required or when the conditional evaluated to true.
	 */

	if (t != TOKEN_NONE && (rr || roffs[t].flags & ROFFMAC_STRUCT))
		return (*roffs[t].proc)(r, t, buf, ln, ppos, pos, offs);
d1940 11
a1950 3
		if (*(++ep) == '}') {
			*ep = '&';
			roff_ccond(r, ln, ep - buf->buf - 1);
a1951 2
		if (*ep != '\0')
			++ep;
d1953 10
a1962 1
	return rr ? ROFF_CONT : ROFF_IGN;
@


1.188
log
@Split -Wstyle into -Wstyle and the even lower -Wbase, and add
-Wopenbsd and -Wnetbsd to check conventions for the base system of
a specific operating system.  Mark operating system specific messages
with "(OpenBSD)" at the end.

Please use just "-Tlint" to check base system manuals (defaulting
to -Wall, which is now -Wbase), but prefer "-Tlint -Wstyle" for the
manuals of portable software projects you maintain that are not
part of OpenBSD base, to avoid bogus recommendations about base
system conventions that do not apply.

Issue originally reported by semarie@@, solution using
an idea from tedu@@, discussed with jmc@@ and jca@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.187 2017/06/18 17:35:40 schwarze Exp $ */
d331 1
a331 1
	"UE",		NULL
@


1.187
log
@Implement appending to standard man(7) and mdoc(7) macros with .am.

With roff_getstrn(), provide finer control which definitions
can be used for what:
* All definitions can be used for .if d tests and .am appending.
* User-defined for \* expansion, .dei expansion, and macro calling.
* Predefined for \* expansion.
* Standard macros, original or renamed, for macro calling.

Several related improvements while here:
* Do not return string table entries that have explicitly been removed.
* Do not create a rentab entry when trying to rename a non-existent macro.
* Clear an existing rentab entry when the external interface
roff_setstr() is called with its name.
* Avoid trailing blanks in macro lines generated from renamed
and from aliased macros.
* Delete the duplicate __m*_reserved[] tables, just use roff_name[].
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.186 2017/06/17 23:06:43 schwarze Exp $ */
d820 1
a820 1
	const char *defos, int quick)
d827 1
a827 1
	man->defos = defos;
d1139 1
a1139 1
	enum mdoc_os	 os_e;	/* kind of RCS id seen */
d1162 1
a1162 1
			os_e = MDOC_OS_OPENBSD;
d1165 1
a1165 1
			os_e = MDOC_OS_NETBSD;
@


1.186
log
@style message about duplicate RCS ids; inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.185 2017/06/17 22:40:27 schwarze Exp $ */
d40 8
a185 2
static	const char	*roff_getrenn(const struct roff *,
				const char *, size_t);
d187 1
a187 1
				const char *, size_t);
a213 1
static	enum rofferr	 roff_TH(ROFF_ARGS);
d542 1
a542 1
	{ roff_TH, NULL, NULL, 0 },  /* TH */
a579 33
/* not currently implemented: Ds em Eq LP Me PP pp Or Rd Sf SH */
const	char *const __mdoc_reserved[] = {
	"Ac", "Ad", "An", "Ao", "Ap", "Aq", "Ar", "At",
	"Bc", "Bd", "Bf", "Bk", "Bl", "Bo", "Bq",
	"Brc", "Bro", "Brq", "Bsx", "Bt", "Bx",
	"Cd", "Cm", "Db", "Dc", "Dd", "Dl", "Do", "Dq",
	"Dt", "Dv", "Dx", "D1",
	"Ec", "Ed", "Ef", "Ek", "El", "Em",
	"En", "Eo", "Er", "Es", "Ev", "Ex",
	"Fa", "Fc", "Fd", "Fl", "Fn", "Fo", "Fr", "Ft", "Fx",
	"Hf", "Ic", "In", "It", "Lb", "Li", "Lk", "Lp",
	"Ms", "Mt", "Nd", "Nm", "No", "Ns", "Nx",
	"Oc", "Oo", "Op", "Os", "Ot", "Ox",
	"Pa", "Pc", "Pf", "Po", "Pp", "Pq",
	"Qc", "Ql", "Qo", "Qq", "Re", "Rs", "Rv",
	"Sc", "Sh", "Sm", "So", "Sq",
	"Ss", "St", "Sx", "Sy",
	"Ta", "Tn", "Ud", "Ux", "Va", "Vt", "Xc", "Xo", "Xr",
	"%A", "%B", "%C", "%D", "%I", "%J", "%N", "%O",
	"%P", "%Q", "%R", "%T", "%U", "%V",
	NULL
};

/* not currently implemented: BT DE DS ME MT PT SY TQ YS */
const	char *const __man_reserved[] = {
	"AT", "B", "BI", "BR", "DT",
	"EE", "EN", "EQ", "EX", "HP", "I", "IB", "IP", "IR",
	"LP", "OP", "P", "PD", "PP",
	"R", "RB", "RE", "RI", "RS", "SB", "SH", "SM", "SS",
	"TE", "TH", "TP", "TS", "T&", "UC", "UE", "UR",
	NULL
};

d1145 1
d1343 4
a1346 2
			if (arg_complete)
				res = roff_getstrn(r, stnam, naml);
d1615 1
d1626 13
a1638 5
	t = (r->current_string = roff_getstrn(r, mac, maclen)) ?
	    ROFF_USERDEF :
	    (r->current_string = roff_getrenn(r, mac, maclen)) ?
	    ROFF_RENAMED : roffhash_find(r->reqtab, mac, maclen);

a1640 1

d1732 4
a1735 3
	const char	*name;
	char		*iname, *cp;
	size_t		 namesz;
d1763 3
a1765 1
		if ((name = roff_getstrn(r, iname, namesz)) == NULL) {
d1792 27
d1832 3
a1834 1
		if ((name = roff_getstrn(r, iname, namesz)) == NULL) {
d2106 1
a2106 1
	int	 number, savepos, istrue, wanttrue;
d2134 9
a2142 3
		istrue = sz && (v[*pos] == 'r' ? roff_hasregn(r, name, sz) :
		    (roff_getstrn(r, name, sz) != NULL ||
		     roff_getrenn(r, name, sz) != NULL));
d2747 2
a2748 23
	const char *const	*cp;

	if ((r->options & (MPARSE_MDOC | MPARSE_QUICK)) == 0)
		for (cp = __mdoc_reserved; *cp; cp++)
			roff_setstr(r, *cp, NULL, 0);

	if (r->format == 0)
		r->format = MPARSE_MDOC;

	return ROFF_CONT;
}

static enum rofferr
roff_TH(ROFF_ARGS)
{
	const char *const	*cp;

	if ((r->options & MPARSE_QUICK) == 0)
		for (cp = __man_reserved; *cp; cp++)
			roff_setstr(r, *cp, NULL, 0);

	if (r->format == 0)
		r->format = MPARSE_MAN;
d2750 21
d3025 2
a3026 1
	valsz = mandoc_asprintf(&value, ".%.*s \\$*\n", (int)oldsz, oldn);
d3159 1
d3174 4
a3177 7
	/*
	 * Rename a user-defined macro bearing the old name,
	 * overriding an existing renamed high-level macro
	 * bearing the new name, if that exists.
	 */

	if ((value = roff_getstrn(r, oldn, oldsz)) != NULL) {
d3181 6
a3186 12
		return ROFF_IGN;
	}

	/*
	 * Rename a high-level macro bearing the old name,
	 * either renaming it a second time if it was already
	 * renamed before, or renaming it for the first time.
	 * In both cases, override an existing user-defined
	 * macro bearing the new name, if that exists.
	 */

	if ((value = roff_getrenn(r, oldn, oldsz)) != NULL) {
d3189 3
a3191 1
	} else
d3193 7
a3199 1
	roff_setstrn(&r->strtab, newn, newsz, NULL, 0, 0);
d3386 2
a3387 2
	buf->sz = mandoc_asprintf(&nbuf, ".%s %s", r->current_string,
	    buf->buf + pos) + 1;
d3442 1
d3444 2
a3445 1
	roff_setstrn(&r->strtab, name, strlen(name), string,
d3447 1
d3523 2
a3524 1
roff_getstrn(const struct roff *r, const char *name, size_t len)
d3526 54
a3579 30
	const struct roffkv *n;
	int i;

	for (n = r->strtab; n; n = n->next)
		if (0 == strncmp(name, n->key.p, len) &&
		    '\0' == n->key.p[(int)len])
			return n->val.p;

	for (i = 0; i < PREDEFS_MAX; i++)
		if (0 == strncmp(name, predefs[i].name, len) &&
				'\0' == predefs[i].name[(int)len])
			return predefs[i].str;

	return NULL;
}

/*
 * Check whether *name is the renamed name of a high-level macro.
 * Return the standard name, or NULL if it is not.
 */
static const char *
roff_getrenn(const struct roff *r, const char *name, size_t len)
{
	const struct roffkv *n;

	for (n = r->rentab; n; n = n->next)
		if (0 == strncmp(name, n->key.p, len) &&
		    '\0' == n->key.p[(int)len])
			return n->val.p;

@


1.185
log
@style message about missing RCS ids; inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.184 2017/06/14 22:50:37 schwarze Exp $ */
d1197 4
a1200 1
		    strchr(cp, '$') != NULL)
d1202 1
@


1.184
log
@Naive implementation of the roff(7) .po (page offset) request.

This clearly works when .po is called on the top level, but might
not be sophisticated enough if people call .po inside indentation-changing
contexts, but i haven't seen that in manual pages (yet :).
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.183 2017/06/14 19:39:05 schwarze Exp $ */
d1167 1
d1185 17
@


1.183
log
@simple implementation of the roff(7) .als (macro alias) request,
sufficient for pages using po4a(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.182 2017/06/14 14:01:34 schwarze Exp $ */
d224 2
a225 2
	"mc",		"rj",		"sp",		"ta",
	"ti",		NULL,
d266 1
a266 1
	"pn",		"pnr",		"po",		"ps",
d336 1
a501 1
	{ roff_line_ignore, NULL, NULL, 0 },  /* po */
@


1.182
log
@implement the roff(7) d (macro or string defined) conditional
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.181 2017/06/14 13:00:13 schwarze Exp $ */
d147 1
d345 1
a345 1
	{ roff_unsupp, NULL, NULL, 0 },  /* als */
d1781 1
a1781 1
	if (tok == ROFF_de || tok == ROFF_dei)
d1783 2
d2253 1
d2665 1
d2964 26
d3194 1
a3194 1
	const char	 *arg[9], *ap;
d3206 1
a3206 1
	for (i = 0; i < 9; i++) {
@


1.181
log
@implement roff(7) .rj (right justify) request
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.180 2017/06/13 13:50:17 schwarze Exp $ */
d2066 1
a2066 1
	int	 number, savepos, wanttrue;
a2081 1
	case 'd':
d2087 1
d2089 8
a2096 2
		cp = name = v + ++*pos;
		sz = roff_getname(r, &cp, ln, *pos);
d2098 1
a2098 1
		return (sz && roff_hasregn(r, name, sz)) == wanttrue;
@


1.180
log
@Explicitly ignore .br, .ce, and .sp inside tbl(7) text blocks.
With the current code structure, they would appear at the wrong
place in the syntax tree, so it is better to not insert them
into the tree at all and issue an UNSUPP message instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.179 2017/06/08 19:35:34 schwarze Exp $ */
d223 2
a224 2
	"mc",		"sp",		"ta",		"ti",
	NULL,
d268 1
a268 1
	"return",	"rfschar",	"rhang",	"rj",
d335 1
a512 1
	{ roff_line_ignore, NULL, NULL, 0 },  /* rj */
d1550 1
a1550 1
	    t == ROFF_br || t == ROFF_ce || t == ROFF_sp)) {
d2881 1
a2881 1
	if (tok == ROFF_ce && roffce_node != NULL) {
d2902 2
a2903 2
	if (tok == ROFF_ce) {
		if (r->man->last->tok == ROFF_ce) {
@


1.179
log
@Properly reinitialize roffce_node between parses,
or this may crash with use-after-free in makewhatis(8);
reported by jmc@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.178 2017/06/07 00:50:30 schwarze Exp $ */
d1549 2
a1550 1
	if (r->tbl != NULL && (t == TOKEN_NONE || t == ROFF_TS)) {
d1553 1
a1553 1
		if (t == ROFF_TS)
@


1.178
log
@Implement the roff(7) .rn (rename macro or string) request.
Renaming a user-defined macro is very simple: just copy
the definition to the new name and delete the old name.
Renaming high-level macros is a bit tricky: use a dedicated
key-value-table, with non-standard names as keys and standard
names as values.  When a macro is found that is not user-defined,
look it up in the "renamed" table and translate it back to the
standard name before passing it on to the high-level parsers.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.177 2017/06/06 15:00:56 schwarze Exp $ */
d768 4
@


1.177
log
@Minimal implementation of the roff(7) .ce request (center a number
of input lines without filling).
Contrary to groff, high-level macros abort .ce mode for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.176 2017/06/04 22:43:50 schwarze Exp $ */
d84 1
d177 2
d195 1
d198 1
d284 1
a284 1
	"text",
d514 1
a514 1
	{ roff_unsupp, NULL, NULL, 0 },  /* rn */
d570 1
d750 1
d752 1
a752 1
	r->strtab = r->xmbtab = NULL;
d1622 4
a1625 2
	t = (r->current_string = roff_getstrn(r, mac, maclen))
	    ? ROFF_USERDEF : roffhash_find(r->reqtab, mac, maclen);
d3068 50
d3291 16
d3448 17
@


1.176
log
@Implement the roff(7) .mc (right margin character) request.
The Tcl/Tk manual pages use this extensively.
Delete the TERM_MAXMARGIN hack, it breaks .mc inside .nf;
instead, implement a proper TERMP_BRNEVER flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.175 2017/06/04 00:08:56 schwarze Exp $ */
d190 2
a191 1
static	enum rofferr	 roff_parsetext(struct buf *, int, int *);
d217 3
a219 2
	"br",		"ft",		"ll",		"mc",
	"sp",		"ta",		"ti",		NULL,
d226 1
a226 1
	"brpnl",	"c2",		"cc",		"ce",
d326 1
a360 1
	{ roff_line_ignore, NULL, NULL, 0 },  /* ce */
d607 2
d1392 1
a1392 1
roff_parsetext(struct buf *buf, int pos, int *offs)
d1414 10
d1509 1
a1509 1
		return roff_parsetext(buf, pos, offs);
d1550 10
d2861 1
d2867 5
d2888 23
a2910 2
	n->flags |= NODE_LINE | NODE_VALID | NODE_ENDED;
	r->man->last = n;
@


1.175
log
@Pure preprocessor implementation of the roff(7) .ec and .eo requests
(escape character control), touching nothing after the preprocessing
stage and keeping even the state variable local to the preprocessor.
Since the escape character is also used for line continuation, this
requires pulling the implementation of line continuation from the
input reader to the preprocessor, which also considerably shortens
the code required for that.

When the escape character is changed, simply let the preprocessor
replace bare by escaped backslashes and instances of the non-standard
escape character with bare backslashes - that's all we need.

Oh, and if anybody dares to use these requests in OpenBSD manuals,
sending a medium-sized pack of axe-murderes after them might be a
worthwhile part of the punishment, but probably insuffient on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.174 2017/05/08 20:33:40 schwarze Exp $ */
d216 2
a217 2
	"br",		"ft",		"ll",		"sp",
	"ta",		"ti",		NULL,
d250 1
a250 1
	"ls",		"lsm",		"lt",		"mc",
d326 1
a461 1
	{ roff_line_ignore, NULL, NULL, 0 },  /* mc */
@


1.174
log
@Line-breaking roff(7) requests also break man(7) next-line scope.
Considering that real roff implements next-line scope using input
line traps, that isn't all that surprising.
Issue found in the games/xbattle port.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.173 2017/05/08 15:33:43 schwarze Exp $ */
d100 1
d157 2
d389 1
a389 1
	{ roff_unsupp, NULL, NULL, 0 },  /* ec */
d395 1
a395 1
	{ roff_unsupp, NULL, NULL, 0 },  /* eo */
d755 2
a756 1
	r->control = 0;
d778 1
d1155 1
d1158 34
d1193 1
a1193 3
	start = buf->buf + pos;
	stesc = strchr(start, '\0') - 1;
	while (stesc-- > start) {
d1197 11
a1207 1
		if (*stesc != '\\')
d1209 1
d1214 1
a1214 1
			if (*cp != '\\')
d1218 2
a1219 1
			stesc = (char *)cp;
d1221 8
d1254 1
d1469 1
a1469 1
	if (e == ROFF_IGN)
d2909 1
a2909 1
		r->control = 0;
d2919 27
d3472 1
a3472 1
	if (0 != r->control && cp[pos] == r->control)
d3474 1
a3474 1
	else if (0 != r->control)
@


1.173
log
@Basic implementation of the roff(7) .ti (temporary indent) request.
Needed by about four dozen ports (thanks to naddy@@ for the research).
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.172 2017/05/07 17:30:58 schwarze Exp $ */
d1010 1
a1010 1
		man_breakscope(man, TOKEN_NONE);
d2779 4
d2831 2
@


1.172
log
@Basic implementation of the roff(7) .ta (define tab stops) request.
This is the first feature made possible by the parser reorganization.
Improves the formatting of the SYNOPSIS in many Xenocara GL manuals.
Also important for ports, as reported by many, including naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.171 2017/05/05 15:16:25 schwarze Exp $ */
d214 1
a214 1
	"ta",		NULL,
d265 1
a265 1
	"TH",		"ti",		"tkf",		"tl",
d325 1
a526 1
	{ roff_unsupp, NULL, NULL, 0 },  /* ti */
@


1.171
log
@Move .sp to the roff modules.  Enough infrastructure is in place
now that this actually saves code: -70 LOC.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.170 2017/05/05 13:17:04 schwarze Exp $ */
d182 1
d214 1
a214 1
	NULL,
d264 1
a264 1
	"T&",		"ta",		"tc",		"TE",
d324 1
a522 1
	{ roff_unsupp, NULL, NULL, 0 },  /* ta */
d2793 23
@


1.170
log
@move .ll to the roff modules
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.169 2017/05/05 02:06:17 schwarze Exp $ */
d212 2
a213 1
	"br",		"ft",		"ll",		NULL,
d303 2
a304 2
	"Dx",		"%Q",		"sp",
	"%U",		"Ta",		NULL,
d310 1
a310 1
	"sp",		"nf",		"fi",
d322 1
@


1.169
log
@Move handling of the roff(7) .ft request from the man(7)
modules to the new roff(7) modules.  As a side effect,
mdoc(7) now handles .ft, too.  Of course, do not use that.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.168 2017/05/04 17:48:24 schwarze Exp $ */
d212 1
a212 1
	"br",		"ft",		NULL,
d303 1
a303 1
	"%U",		"Ta",		"ll",		NULL,
d313 1
a313 1
	"UE",		"ll",		NULL
d320 1
@


1.168
log
@Parser reorg:
Generate the first node on the roff level: .br
Fix some column numbers in diagnostic messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.167 2017/04/29 12:43:55 schwarze Exp $ */
d183 1
d212 1
a212 1
	"br",		NULL,
d311 1
a311 1
	"PD",		"AT",		"in",		"ft",
d319 1
d2766 28
@


1.167
log
@Parser unification: use nice ohashes for all three request and macro tables;
no functional change, minus two source files, minus 200 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.166 2017/04/24 23:06:09 schwarze Exp $ */
d78 1
d148 1
a148 1
static	enum rofferr	 roff_brp(ROFF_ARGS);
d211 1
d301 1
a301 1
	"Dx",		"%Q",		"br",		"sp",
d308 1
a308 1
	"br",		"sp",		"nf",		"fi",
d317 2
d342 1
a342 1
	{ roff_brp, NULL, NULL, 0 },  /* brp */
d615 2
d831 1
d1481 1
a1481 1
	return (*roffs[t].proc)(r, t, buf, ln, ppos, pos, offs);
d2641 1
a2641 1
		tbl_restart(ppos, ln, r->tbl);
d2768 1
a2768 1
roff_brp(ROFF_ARGS)
d2770 7
a2776 3

	buf->buf[pos - 1] = '\0';
	return ROFF_CONT;
@


1.166
log
@Continue parser unification:
* Make enum rofft an internal interface as enum roff_tok in "roff.h".
* Represent mdoc and man macros in enum roff_tok.
* Make TOKEN_NONE a proper enum value and use it throughout.
* Put the prologue macros first in the macro tables.
* Unify mdoc_macroname[] and man_macroname[] into roff_name[].
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.165 2017/03/09 15:27:52 schwarze Exp $ */
d23 2
d31 1
d68 8
d80 1
a122 1
	const char	*name; /* macro name */
a127 1
	struct roffmac	*next;
a139 2
static	enum roff_tok	 roffhash_find(const char *, size_t);
static	void		 roffhash_init(void);
a205 6
/* See roffhash_find() */

#define	ASCII_HI	 126
#define	ASCII_LO	 33
#define	HASHWIDTH	(ASCII_HI - ASCII_LO + 1)

a313 2
static	struct roffmac	*hash[HASHWIDTH];

d315 236
a550 236
	{ "ab", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ad", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "af", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "aln", roff_unsupp, NULL, NULL, 0, NULL },
	{ "als", roff_unsupp, NULL, NULL, 0, NULL },
	{ "am", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "am1", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "ami", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "ami1", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "as", roff_ds, NULL, NULL, 0, NULL },
	{ "as1", roff_ds, NULL, NULL, 0, NULL },
	{ "asciify", roff_unsupp, NULL, NULL, 0, NULL },
	{ "backtrace", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "bd", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "bleedat", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "blm", roff_unsupp, NULL, NULL, 0, NULL },
	{ "box", roff_unsupp, NULL, NULL, 0, NULL },
	{ "boxa", roff_unsupp, NULL, NULL, 0, NULL },
	{ "bp", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "BP", roff_unsupp, NULL, NULL, 0, NULL },
	{ "break", roff_unsupp, NULL, NULL, 0, NULL },
	{ "breakchar", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "brnl", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "brp", roff_brp, NULL, NULL, 0, NULL },
	{ "brpnl", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "c2", roff_unsupp, NULL, NULL, 0, NULL },
	{ "cc", roff_cc, NULL, NULL, 0, NULL },
	{ "ce", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "cf", roff_insec, NULL, NULL, 0, NULL },
	{ "cflags", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ch", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "char", roff_unsupp, NULL, NULL, 0, NULL },
	{ "chop", roff_unsupp, NULL, NULL, 0, NULL },
	{ "class", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "close", roff_insec, NULL, NULL, 0, NULL },
	{ "CL", roff_unsupp, NULL, NULL, 0, NULL },
	{ "color", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "composite", roff_unsupp, NULL, NULL, 0, NULL },
	{ "continue", roff_unsupp, NULL, NULL, 0, NULL },
	{ "cp", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "cropat", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "cs", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "cu", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "da", roff_unsupp, NULL, NULL, 0, NULL },
	{ "dch", roff_unsupp, NULL, NULL, 0, NULL },
	{ "Dd", roff_Dd, NULL, NULL, 0, NULL },
	{ "de", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "de1", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "defcolor", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "dei", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "dei1", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "device", roff_unsupp, NULL, NULL, 0, NULL },
	{ "devicem", roff_unsupp, NULL, NULL, 0, NULL },
	{ "di", roff_unsupp, NULL, NULL, 0, NULL },
	{ "do", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ds", roff_ds, NULL, NULL, 0, NULL },
	{ "ds1", roff_ds, NULL, NULL, 0, NULL },
	{ "dwh", roff_unsupp, NULL, NULL, 0, NULL },
	{ "dt", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ec", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ecr", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ecs", roff_unsupp, NULL, NULL, 0, NULL },
	{ "el", roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT, NULL },
	{ "em", roff_unsupp, NULL, NULL, 0, NULL },
	{ "EN", roff_EN, NULL, NULL, 0, NULL },
	{ "eo", roff_unsupp, NULL, NULL, 0, NULL },
	{ "EP", roff_unsupp, NULL, NULL, 0, NULL },
	{ "EQ", roff_EQ, NULL, NULL, 0, NULL },
	{ "errprint", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ev", roff_unsupp, NULL, NULL, 0, NULL },
	{ "evc", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ex", roff_unsupp, NULL, NULL, 0, NULL },
	{ "fallback", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fam", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fc", roff_unsupp, NULL, NULL, 0, NULL },
	{ "fchar", roff_unsupp, NULL, NULL, 0, NULL },
	{ "fcolor", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fdeferlig", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "feature", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fkern", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fl", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "flig", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fp", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fps", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fschar", roff_unsupp, NULL, NULL, 0, NULL },
	{ "fspacewidth", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fspecial", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ftr", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fzoom", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "gcolor", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hc", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hcode", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hidechar", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hla", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hlm", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hpf", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hpfa", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hpfcode", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hw", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hy", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hylang", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hylen", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hym", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hypp", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hys", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ie", roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT, NULL },
	{ "if", roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT, NULL },
	{ "ig", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "index", roff_unsupp, NULL, NULL, 0, NULL },
	{ "it", roff_it, NULL, NULL, 0, NULL },
	{ "itc", roff_unsupp, NULL, NULL, 0, NULL },
	{ "IX", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "kern", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "kernafter", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "kernbefore", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "kernpair", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "lc", roff_unsupp, NULL, NULL, 0, NULL },
	{ "lc_ctype", roff_unsupp, NULL, NULL, 0, NULL },
	{ "lds", roff_unsupp, NULL, NULL, 0, NULL },
	{ "length", roff_unsupp, NULL, NULL, 0, NULL },
	{ "letadj", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "lf", roff_insec, NULL, NULL, 0, NULL },
	{ "lg", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "lhang", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "linetabs", roff_unsupp, NULL, NULL, 0, NULL },
	{ "lnr", roff_unsupp, NULL, NULL, 0, NULL },
	{ "lnrf", roff_unsupp, NULL, NULL, 0, NULL },
	{ "lpfx", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ls", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "lsm", roff_unsupp, NULL, NULL, 0, NULL },
	{ "lt", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "mc", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "mediasize", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "minss", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "mk", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "mso", roff_insec, NULL, NULL, 0, NULL },
	{ "na", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ne", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "nh", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "nhychar", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "nm", roff_unsupp, NULL, NULL, 0, NULL },
	{ "nn", roff_unsupp, NULL, NULL, 0, NULL },
	{ "nop", roff_unsupp, NULL, NULL, 0, NULL },
	{ "nr", roff_nr, NULL, NULL, 0, NULL },
	{ "nrf", roff_unsupp, NULL, NULL, 0, NULL },
	{ "nroff", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ns", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "nx", roff_insec, NULL, NULL, 0, NULL },
	{ "open", roff_insec, NULL, NULL, 0, NULL },
	{ "opena", roff_insec, NULL, NULL, 0, NULL },
	{ "os", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "output", roff_unsupp, NULL, NULL, 0, NULL },
	{ "padj", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "papersize", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pc", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pev", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pi", roff_insec, NULL, NULL, 0, NULL },
	{ "PI", roff_unsupp, NULL, NULL, 0, NULL },
	{ "pl", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pm", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pn", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pnr", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "po", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ps", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "psbb", roff_unsupp, NULL, NULL, 0, NULL },
	{ "pshape", roff_unsupp, NULL, NULL, 0, NULL },
	{ "pso", roff_insec, NULL, NULL, 0, NULL },
	{ "ptr", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pvs", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "rchar", roff_unsupp, NULL, NULL, 0, NULL },
	{ "rd", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "recursionlimit", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "return", roff_unsupp, NULL, NULL, 0, NULL },
	{ "rfschar", roff_unsupp, NULL, NULL, 0, NULL },
	{ "rhang", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "rj", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "rm", roff_rm, NULL, NULL, 0, NULL },
	{ "rn", roff_unsupp, NULL, NULL, 0, NULL },
	{ "rnn", roff_unsupp, NULL, NULL, 0, NULL },
	{ "rr", roff_rr, NULL, NULL, 0, NULL },
	{ "rs", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "rt", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "schar", roff_unsupp, NULL, NULL, 0, NULL },
	{ "sentchar", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "shc", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "shift", roff_unsupp, NULL, NULL, 0, NULL },
	{ "sizes", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "so", roff_so, NULL, NULL, 0, NULL },
	{ "spacewidth", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "special", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "spreadwarn", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ss", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "sty", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "substring", roff_unsupp, NULL, NULL, 0, NULL },
	{ "sv", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "sy", roff_insec, NULL, NULL, 0, NULL },
	{ "T&", roff_T_, NULL, NULL, 0, NULL },
	{ "ta", roff_unsupp, NULL, NULL, 0, NULL },
	{ "tc", roff_unsupp, NULL, NULL, 0, NULL },
	{ "TE", roff_TE, NULL, NULL, 0, NULL },
	{ "TH", roff_TH, NULL, NULL, 0, NULL },
	{ "ti", roff_unsupp, NULL, NULL, 0, NULL },
	{ "tkf", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "tl", roff_unsupp, NULL, NULL, 0, NULL },
	{ "tm", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "tm1", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "tmc", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "tr", roff_tr, NULL, NULL, 0, NULL },
	{ "track", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "transchar", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "trf", roff_insec, NULL, NULL, 0, NULL },
	{ "trimat", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "trin", roff_unsupp, NULL, NULL, 0, NULL },
	{ "trnt", roff_unsupp, NULL, NULL, 0, NULL },
	{ "troff", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "TS", roff_TS, NULL, NULL, 0, NULL },
	{ "uf", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ul", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "unformat", roff_unsupp, NULL, NULL, 0, NULL },
	{ "unwatch", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "unwatchn", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "vpt", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "vs", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "warn", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "warnscale", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "watch", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "watchlength", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "watchn", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "wh", roff_unsupp, NULL, NULL, 0, NULL },
	{ "while", roff_unsupp, NULL, NULL, 0, NULL },
	{ "write", roff_insec, NULL, NULL, 0, NULL },
	{ "writec", roff_insec, NULL, NULL, 0, NULL },
	{ "writem", roff_insec, NULL, NULL, 0, NULL },
	{ "xflag", roff_line_ignore, NULL, NULL, 0, NULL },
	{ ".", roff_cblock, NULL, NULL, 0, NULL },
	{ NULL, roff_userdef, NULL, NULL, 0, NULL },
a591 3
/* See roffhash_find() */
#define	ROFF_HASH(p)	(p[0] - ASCII_LO)

d598 2
a599 2
static void
roffhash_init(void)
d601 5
a605 2
	struct roffmac	 *n;
	int		  buc, i;
d607 2
a608 3
	for (i = 0; i < (int)ROFF_USERDEF; i++) {
		assert(roffs[i].name[0] >= ASCII_LO);
		assert(roffs[i].name[0] <= ASCII_HI);
d610 7
a616 8
		buc = ROFF_HASH(roffs[i].name);

		if (NULL != (n = hash[buc])) {
			for ( ; n->next; n = n->next)
				/* Do nothing. */ ;
			n->next = &roffs[i];
		} else
			hash[buc] = &roffs[i];
d618 1
d621 2
a622 6
/*
 * Look up a roff token by its name.  Returns TOKEN_NONE if no macro by
 * the nil-terminated string name could be found.
 */
static enum roff_tok
roffhash_find(const char *p, size_t s)
d624 2
a625 2
	int		 buc;
	struct roffmac	*n;
d627 21
a647 19
	/*
	 * libroff has an extremely simple hashtable, for the time
	 * being, which simply keys on the first character, which must
	 * be printable, then walks a chain.  It works well enough until
	 * optimised.
	 */

	if (p[0] < ASCII_LO || p[0] > ASCII_HI)
		return TOKEN_NONE;

	buc = ROFF_HASH(p);

	if (NULL == (n = hash[buc]))
		return TOKEN_NONE;
	for ( ; n; n = n->next)
		if (0 == strncmp(n->name, p, s) && '\0' == n->name[(int)s])
			return (enum roff_tok)(n - roffs);

	return TOKEN_NONE;
a737 1

a745 1

d747 1
d758 1
a761 3

	roffhash_init();

d1484 1
a1484 1
		    roffs[r->last->tok].name);
d1520 1
a1520 1
	    ? ROFF_USERDEF : roffhash_find(mac, maclen);
d1658 1
a1658 1
		    ln, ppos, roffs[tok].name);
d1699 1
a1699 1
		    ln, pos, ".%s ... %s", roffs[tok].name, cp);
d2008 1
a2008 1
	    ln, ppos, roffs[tok].name);
d2017 1
a2017 1
	    ln, ppos, roffs[tok].name);
d2090 1
a2090 1
		    ln, ppos, roffs[tok].name);
@


1.165
log
@Fix blunder in previous:  we must keep the line parse buffer
consistent even when aborting the parsing of the line.  That buffer
is not our own, but owned and reused by mparse_buf_r(), read.c.
Returning without cleanup leaked memory and caused write overruns
of the old, typically much smaller buffer in mparse_buf_r().
Promptly noticed by tb@@ with afl(1), using MALLOC_OPTIONS=C.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.164 2017/03/08 13:17:28 schwarze Exp $ */
a38 247
enum	rofft {
	ROFF_ab,
	ROFF_ad,
	ROFF_af,
	ROFF_aln,
	ROFF_als,
	ROFF_am,
	ROFF_am1,
	ROFF_ami,
	ROFF_ami1,
	ROFF_as,
	ROFF_as1,
	ROFF_asciify,
	ROFF_backtrace,
	ROFF_bd,
	ROFF_bleedat,
	ROFF_blm,
	ROFF_box,
	ROFF_boxa,
	ROFF_bp,
	ROFF_BP,
	/* MAN_br, MDOC_br */
	ROFF_break,
	ROFF_breakchar,
	ROFF_brnl,
	ROFF_brp,
	ROFF_brpnl,
	ROFF_c2,
	ROFF_cc,
	ROFF_ce,
	ROFF_cf,
	ROFF_cflags,
	ROFF_ch,
	ROFF_char,
	ROFF_chop,
	ROFF_class,
	ROFF_close,
	ROFF_CL,
	ROFF_color,
	ROFF_composite,
	ROFF_continue,
	ROFF_cp,
	ROFF_cropat,
	ROFF_cs,
	ROFF_cu,
	ROFF_da,
	ROFF_dch,
	ROFF_Dd,
	ROFF_de,
	ROFF_de1,
	ROFF_defcolor,
	ROFF_dei,
	ROFF_dei1,
	ROFF_device,
	ROFF_devicem,
	ROFF_di,
	ROFF_do,
	ROFF_ds,
	ROFF_ds1,
	ROFF_dwh,
	ROFF_dt,
	ROFF_ec,
	ROFF_ecr,
	ROFF_ecs,
	ROFF_el,
	ROFF_em,
	ROFF_EN,
	ROFF_eo,
	ROFF_EP,
	ROFF_EQ,
	ROFF_errprint,
	ROFF_ev,
	ROFF_evc,
	ROFF_ex,
	ROFF_fallback,
	ROFF_fam,
	ROFF_fc,
	ROFF_fchar,
	ROFF_fcolor,
	ROFF_fdeferlig,
	ROFF_feature,
	/* MAN_fi; ignored in mdoc(7) */
	ROFF_fkern,
	ROFF_fl,
	ROFF_flig,
	ROFF_fp,
	ROFF_fps,
	ROFF_fschar,
	ROFF_fspacewidth,
	ROFF_fspecial,
	/* MAN_ft; ignored in mdoc(7) */
	ROFF_ftr,
	ROFF_fzoom,
	ROFF_gcolor,
	ROFF_hc,
	ROFF_hcode,
	ROFF_hidechar,
	ROFF_hla,
	ROFF_hlm,
	ROFF_hpf,
	ROFF_hpfa,
	ROFF_hpfcode,
	ROFF_hw,
	ROFF_hy,
	ROFF_hylang,
	ROFF_hylen,
	ROFF_hym,
	ROFF_hypp,
	ROFF_hys,
	ROFF_ie,
	ROFF_if,
	ROFF_ig,
	/* MAN_in; ignored in mdoc(7) */
	ROFF_index,
	ROFF_it,
	ROFF_itc,
	ROFF_IX,
	ROFF_kern,
	ROFF_kernafter,
	ROFF_kernbefore,
	ROFF_kernpair,
	ROFF_lc,
	ROFF_lc_ctype,
	ROFF_lds,
	ROFF_length,
	ROFF_letadj,
	ROFF_lf,
	ROFF_lg,
	ROFF_lhang,
	ROFF_linetabs,
	/* MAN_ll, MDOC_ll */
	ROFF_lnr,
	ROFF_lnrf,
	ROFF_lpfx,
	ROFF_ls,
	ROFF_lsm,
	ROFF_lt,
	ROFF_mc,
	ROFF_mediasize,
	ROFF_minss,
	ROFF_mk,
	ROFF_mso,
	ROFF_na,
	ROFF_ne,
	/* MAN_nf; ignored in mdoc(7) */
	ROFF_nh,
	ROFF_nhychar,
	ROFF_nm,
	ROFF_nn,
	ROFF_nop,
	ROFF_nr,
	ROFF_nrf,
	ROFF_nroff,
	ROFF_ns,
	ROFF_nx,
	ROFF_open,
	ROFF_opena,
	ROFF_os,
	ROFF_output,
	ROFF_padj,
	ROFF_papersize,
	ROFF_pc,
	ROFF_pev,
	ROFF_pi,
	ROFF_PI,
	ROFF_pl,
	ROFF_pm,
	ROFF_pn,
	ROFF_pnr,
	ROFF_po,
	ROFF_ps,
	ROFF_psbb,
	ROFF_pshape,
	ROFF_pso,
	ROFF_ptr,
	ROFF_pvs,
	ROFF_rchar,
	ROFF_rd,
	ROFF_recursionlimit,
	ROFF_return,
	ROFF_rfschar,
	ROFF_rhang,
	ROFF_rj,
	ROFF_rm,
	ROFF_rn,
	ROFF_rnn,
	ROFF_rr,
	ROFF_rs,
	ROFF_rt,
	ROFF_schar,
	ROFF_sentchar,
	ROFF_shc,
	ROFF_shift,
	ROFF_sizes,
	ROFF_so,
	/* MAN_sp, MDOC_sp */
	ROFF_spacewidth,
	ROFF_special,
	ROFF_spreadwarn,
	ROFF_ss,
	ROFF_sty,
	ROFF_substring,
	ROFF_sv,
	ROFF_sy,
	ROFF_T_,
	ROFF_ta,
	ROFF_tc,
	ROFF_TE,
	ROFF_TH,
	ROFF_ti,
	ROFF_tkf,
	ROFF_tl,
	ROFF_tm,
	ROFF_tm1,
	ROFF_tmc,
	ROFF_tr,
	ROFF_track,
	ROFF_transchar,
	ROFF_trf,
	ROFF_trimat,
	ROFF_trin,
	ROFF_trnt,
	ROFF_troff,
	ROFF_TS,
	ROFF_uf,
	ROFF_ul,
	ROFF_unformat,
	ROFF_unwatch,
	ROFF_unwatchn,
	ROFF_vpt,
	ROFF_vs,
	ROFF_warn,
	ROFF_warnscale,
	ROFF_watch,
	ROFF_watchlength,
	ROFF_watchn,
	ROFF_wh,
	ROFF_while,
	ROFF_write,
	ROFF_writec,
	ROFF_writem,
	ROFF_xflag,
	ROFF_cblock,
	ROFF_USERDEF,
	ROFF_MAX
};

d90 1
a90 1
	enum rofft	 tok; /* type of node */
d101 1
a101 1
			 enum rofft tok, /* tok of macro */ \
d130 1
a130 1
static	enum rofft	 roffhash_find(const char *, size_t);
d134 1
a134 1
static	void		 roffnode_push(struct roff *, enum rofft,
d174 1
a174 1
static	enum rofft	 roff_parse(struct roff *, char *, int *,
d207 105
d314 1
a314 1
static	struct roffmac	 roffs[ROFF_MAX] = {
d623 1
a623 1
 * Look up a roff token by its name.  Returns ROFF_MAX if no macro by
d626 1
a626 1
static enum rofft
d640 1
a640 1
		return ROFF_MAX;
d645 1
a645 1
		return ROFF_MAX;
d648 1
a648 1
			return (enum rofft)(n - roffs);
d650 1
a650 1
	return ROFF_MAX;
d678 1
a678 1
roffnode_push(struct roff *r, enum rofft tok, const char *name,
d1380 1
a1380 1
	enum rofft	 t;
a1418 1
		assert(roffs[t].text);
d1420 1
a1420 2
		assert(e == ROFF_IGN || e == ROFF_CONT);
		if (e != ROFF_CONT)
d1422 1
a1447 1
		assert(roffs[t].sub);
d1458 1
a1458 1
	if (r->tbl != NULL && (t == ROFF_MAX || t == ROFF_TS)) {
d1475 1
a1475 1
	if (t == ROFF_MAX)
a1479 1
	assert(roffs[t].proc);
d1509 1
a1509 1
static enum rofft
d1515 1
a1515 1
	enum rofft	 t;
d1520 1
a1520 1
		return ROFF_MAX;
d1528 1
a1528 1
	if (ROFF_MAX != t)
d1713 1
a1713 1
	enum rofft	t;
d1742 1
a1742 1
			    ROFF_MAX)
a1760 1
	assert(roffs[t].proc);
d1777 1
a1777 1
	enum rofft	 t;
d1790 1
a1790 3
	if ((t != ROFF_MAX) &&
	    (rr || roffs[t].flags & ROFFMAC_STRUCT)) {
		assert(roffs[t].proc);
a1791 1
	}
@


1.164
log
@prevent infinite recursion while expanding the arguments
of a user-defined macro; issue found by tb@@ with afl(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.163 2017/03/03 13:55:06 schwarze Exp $ */
d3093 2
@


1.163
log
@remove a few redundant conditions that jsg@@ found with cppcheck
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.162 2017/03/03 11:49:33 schwarze Exp $ */
d3039 1
a3039 1
	int		  i, ib, ie;
d3063 1
a3063 1
	n1 = cp = mandoc_malloc(buf->sz);
d3065 1
d3083 12
@


1.162
log
@Fix previous: do not access the byte before the string if the string
is empty; found by jsg@@ with afl(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.161 2017/02/17 03:01:39 schwarze Exp $ */
d1609 1
a1609 1
		while (buf->buf[pos] != '\0' && buf->buf[pos] == ' ')
@


1.161
log
@Fix a read buffer overrun that copied random data from memory into
text nodes when a string passed to deroff() ended in a backslash
and the byte after the terminating NUL was non-NUL, found by tb@@
with afl(1).

Invalid bytes so copied with the high bit set could later sometimes
trigger another out of bounds read access to static memory in
roff_strdup(), so add an assertion there to abort safely in case
of similar data corruption.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.160 2017/01/12 18:02:24 schwarze Exp $ */
d1237 1
a1237 1
	if (cp[sz - 1] == '\\')
@


1.160
log
@Skipping all escape sequences at the beginning of strings in deroff()
was too aggressive.  There are strings that legitimately begin with
an escape sequence.  Only skip leading escape sequences representing
whitespace.

Bug reported by martijn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.159 2017/01/10 21:54:34 schwarze Exp $ */
d1227 2
a1228 1
		if (cp[0] == '\\' && strchr(" %&0^|~", cp[1]) != NULL)
d1234 6
d1242 1
a1242 1
	for (sz = strlen(cp); sz; sz--)
d3366 2
a3367 1
		if ('\\' != *p && r->xtab && r->xtab[(int)*p].p) {
@


1.159
log
@For the .Ux/.Ox family of macros, do text production at the validation
stage rather than in each and every individual formatter, using the
new NODE_NOSRC flag.  More rigorous and also ten lines less code.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.158 2017/01/10 14:09:03 schwarze Exp $ */
d1224 1
a1224 1
	/* Skip leading whitespace and escape sequences. */
d1226 2
a1227 3
	cp = n->string;
	while (*cp != '\0') {
		if ('\\' == *cp) {
d1229 1
a1229 4
			mandoc_escape((const char **)&cp, NULL, NULL);
		} else if (isspace((unsigned char)*cp))
			cp++;
		else
@


1.158
log
@simplify; NODE_ENDED does no harm in man(7)
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.157 2017/01/10 13:46:53 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2015 Ingo Schwarze <schwarze@@openbsd.org>
d1018 5
a1024 1
		n->parent->last = n;
@


1.157
log
@unify names of AST node flags; no change of cpp output
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.156 2016/01/08 17:48:04 schwarze Exp $ */
d1060 1
a1060 4
	if (man->macroset == MACROSET_MDOC)
		n->flags |= NODE_VALID | NODE_ENDED;
	else
		n->flags |= NODE_VALID;
d1145 1
a1145 4
	if (man->macroset == MACROSET_MDOC)
		n->flags |= NODE_VALID | NODE_ENDED;
	else
		n->flags |= NODE_VALID;
@


1.156
log
@Delete the redundant "nchild" member of struct roff_node, replacing
most uses by one, a few by two pointer checks, and only one by a
tiny loop - not only making data smaller, but code shorter as well.

This gets rid of an implicit invariant that confused both static
analysis tools and human auditors.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.155 2015/10/22 21:53:49 schwarze Exp $ */
d992 1
a992 1
		n->flags |= MDOC_SYNPRETTY;
d994 1
a994 1
		n->flags &= ~MDOC_SYNPRETTY;
d996 1
a996 1
		n->flags |= MDOC_LINE;
d1061 1
a1061 1
		n->flags |= MDOC_VALID | MDOC_ENDED;
d1063 1
a1063 1
		n->flags |= MAN_VALID;
d1133 1
a1133 1
		n->flags |= MDOC_LINE;
d1149 1
a1149 1
		n->flags |= MDOC_VALID | MDOC_ENDED;
d1151 1
a1151 1
		n->flags |= MAN_VALID;
@


1.155
log
@move man(7) validation into the dedicated validation phase, too
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.154 2015/10/21 23:49:05 schwarze Exp $ */
a1024 1
	n->parent->nchild++;
a1168 1
		n->parent->nchild--;
a1209 1
	assert(n->nchild == 0);
@


1.154
log
@Move all mdoc(7) node validation done before child parsing
to the new separate validation pass, except for a tiny bit
needed by the parser which goes to the new mdoc_state() module;
cleaner, simpler, and surprisingly also shorter by 15 lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.153 2015/10/20 02:00:50 schwarze Exp $ */
d1064 1
a1064 1
		man_valid_post(man);
d1152 1
a1152 1
		man_valid_post(man);
@


1.153
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.152 2015/10/15 23:35:38 schwarze Exp $ */
d1026 1
a1026 21

	/*
	 * Copy over the normalised-data pointer of our parent.  Not
	 * everybody has one, but copying a null pointer is fine.
	 */

	switch (n->type) {
	case ROFFT_BODY:
		if (n->end != ENDBODY_NOT)
			break;
		/* FALLTHROUGH */
	case ROFFT_TAIL:
	case ROFFT_HEAD:
		n->norm = n->parent->norm;
		break;
	default:
		break;
	}

	if (man->macroset == MACROSET_MDOC)
		mdoc_valid_pre(man, n);
a1029 1
		assert(n->parent->type == ROFFT_BLOCK);
d1033 2
a1034 3
		if (n->end)
			break;
		assert(n->parent->type == ROFFT_BLOCK);
a1037 1
		assert(n->parent->type == ROFFT_BLOCK);
d1041 1
a1041 1
		break;
d1043 8
a1050 1
	man->last = n;
@


1.152
log
@Delete two preprocessor constants that are no longer used.
Patch from Michael Reed <m dot reed at mykolab dot com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.151 2015/10/13 22:57:49 schwarze Exp $ */
d1008 5
d1020 1
a1025 1
	n->parent->last = n;
d1078 1
a1078 1
		mdoc_valid_post(man);
d1166 1
a1166 1
		mdoc_valid_post(man);
@


1.151
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.150 2015/10/12 00:07:27 schwarze Exp $ */
a32 3

/* Maximum number of nested if-else conditionals. */
#define	RSTACK_MAX	128
@


1.150
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.149 2015/10/06 18:30:44 schwarze Exp $ */
a316 1
	const struct mchars *mchars; /* character table */
d901 1
a901 1
roff_alloc(struct mparse *parse, const struct mchars *mchars, int options)
a906 1
	r->mchars = mchars;
d1343 1
a1343 1
			     mchars_spec2cp(r->mchars, stnam, inaml) < 0))
@


1.149
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.148 2015/09/26 00:53:15 schwarze Exp $ */
a1037 1
		/* FALLTHROUGH */
a1334 1
			/* FALLTHROUGH */
a1408 1
				/* FALLTHROUGH */
a1409 1
				/* FALLTHROUGH */
a1410 1
				/* FALLTHROUGH */
a1716 1
		/* FALLTHROUGH */
a1717 1
		/* FALLTHROUGH */
a1719 1
		/* FALLTHROUGH */
a1720 1
		/* FALLTHROUGH */
a1761 1
		/* FALLTHROUGH */
a1762 1
		/* FALLTHROUGH */
a2048 1
		/* FALLTHROUGH */
a2052 1
		/* FALLTHROUGH */
a2140 1
		/* FALLTHROUGH */
a2144 1
		/* FALLTHROUGH */
a2145 1
		/* FALLTHROUGH */
a2146 1
		/* FALLTHROUGH */
a2147 1
		/* FALLTHROUGH */
a2322 1
		/* FALLTHROUGH */
a2323 1
		/* FALLTHROUGH */
a2324 1
		/* FALLTHROUGH */
a2325 1
		/* FALLTHROUGH */
a2326 1
		/* FALLTHROUGH */
a2327 1
		/* FALLTHROUGH */
@


1.148
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.147 2015/08/29 23:55:53 schwarze Exp $ */
d786 1
a786 1
		return(ROFF_MAX);
d791 1
a791 1
		return(ROFF_MAX);
d794 1
a794 1
			return((enum rofft)(n - roffs));
d796 1
a796 1
	return(ROFF_MAX);
d915 1
a915 1
	return(r);
d978 1
a978 1
	return(man);
d1004 1
a1004 1
	return(n);
d1118 1
a1118 1
	return(n);
d1129 1
a1129 1
	return(n);
d1140 1
a1140 1
	return(n);
d1357 1
a1357 1
			return(ROFF_IGN);
d1464 1
a1464 1
			return(ROFF_IGN);
d1480 1
a1480 1
	return(ROFF_CONT);
d1505 1
a1505 1
		return(ROFF_REPARSE);
d1539 1
a1539 1
	return(ROFF_CONT);
d1561 1
a1561 1
			return(e);
d1569 1
a1569 1
		return(e);
d1588 1
a1588 1
			return(e);
d1591 1
a1591 1
		return(eqn_read(&r->eqn, ln, buf->buf, ppos, offs));
d1593 1
a1593 1
		return(tbl_read(r->tbl, ln, buf->buf, ppos));
d1595 1
a1595 1
		return(roff_parsetext(buf, pos, offs));
d1602 1
a1602 1
		return(ROFF_IGN);
d1604 1
a1604 1
		return(ROFF_IGN);
d1615 1
a1615 1
		return((*roffs[t].sub)(r, t, buf, ln, ppos, pos, offs));
d1629 1
a1629 1
			return(ROFF_IGN);
d1634 1
a1634 1
		return(tbl_read(r->tbl, ln, buf->buf, pos));
d1643 1
a1643 1
		return(ROFF_CONT);
d1648 1
a1648 1
	return((*roffs[t].proc)(r, t, buf, ln, ppos, pos, offs));
d1688 1
a1688 1
		return(ROFF_MAX);
d1699 1
a1699 1
	return(t);
d1716 1
a1716 1
		return(ROFF_IGN);
d1735 1
a1735 1
		return(ROFF_IGN);
d1744 1
a1744 1
	return(ROFF_IGN);
d1839 1
a1839 1
		return(ROFF_IGN);
d1854 1
a1854 1
		return(ROFF_IGN);
d1881 1
a1881 1
	return(ROFF_IGN);
d1917 2
a1918 2
				return(ROFF_RERUN);
			return(ROFF_IGN);
d1932 1
a1932 1
		return(ROFF_IGN);
d1936 1
a1936 1
	return((*roffs[t].proc)(r, t, buf, ln, ppos, pos, offs));
d1946 1
a1946 1
	return(ROFF_IGN);
d1968 1
a1968 1
		return((*roffs[t].proc)(r, t, buf, ln, ppos, pos, offs));
d1990 1
a1990 1
	return(rr ? ROFF_CONT : ROFF_IGN);
d2011 1
a2011 1
	return(rr ? ROFF_CONT : ROFF_IGN);
d2087 1
a2087 1
	return(1);
d2130 1
a2130 1
	return(match);
d2152 1
a2152 1
		return(0);
d2157 1
a2157 1
		return(wanttrue);
d2168 1
a2168 1
		return(!wanttrue);
d2173 1
a2173 1
		return((sz && roff_hasregn(r, name, sz)) == wanttrue);
d2180 1
a2180 1
		return((number > 0) == wanttrue);
d2182 1
a2182 1
		return(roff_evalstrcond(v, pos) == wanttrue);
d2184 1
a2184 1
		return (0);
d2191 1
a2191 1
	return(ROFF_IGN);
d2200 1
a2200 1
	return(ROFF_IGN);
d2209 1
a2209 1
	return(ROFF_IGN);
d2287 1
a2287 1
	return(ROFF_RERUN);
d2312 1
a2312 1
		return(ROFF_IGN);
d2316 1
a2316 1
		return(ROFF_IGN);
d2325 1
a2325 1
	return(ROFF_IGN);
d2391 1
a2391 1
		return(0);
d2395 1
a2395 1
	return(*res);
d2408 1
a2408 1
		return(roff_getnum(v, pos, res, flags));
d2412 1
a2412 1
		return(0);
d2423 1
a2423 1
		return(0);
d2425 1
a2425 1
	return(1);
d2449 1
a2449 1
		return(0);
d2464 1
a2464 1
			return(0);
d2537 1
a2537 1
	return(1);
d2583 1
a2583 1
		return(r->argc);
d2585 1
a2585 1
		return(0);
d2587 1
a2587 1
		return(1);
d2589 1
a2589 1
		return (24);
d2591 1
a2591 1
		return(0);
d2593 1
a2593 1
		return(1);
d2595 1
a2595 1
		return (40);
d2597 1
a2597 1
		return (-1);
d2610 1
a2610 1
			return (val);
d2615 1
a2615 1
			return(reg->val);
d2617 1
a2617 1
	return(0);
d2629 1
a2629 1
			return (val);
d2635 1
a2635 1
			return(reg->val);
d2637 1
a2637 1
	return(0);
d2649 1
a2649 1
			return(1);
d2655 1
a2655 1
			return(1);
d2657 1
a2657 1
	return(0);
d2683 1
a2683 1
		return(ROFF_IGN);
d2687 1
a2687 1
		return(ROFF_IGN);
d2697 1
a2697 1
	return(ROFF_IGN);
d2709 1
a2709 1
		return(ROFF_IGN);
d2725 1
a2725 1
	return(ROFF_IGN);
d2745 1
a2745 1
	return(ROFF_IGN);
d2758 1
a2758 1
		return(ROFF_IGN);
d2774 1
a2774 1
	return(ROFF_IGN);
d2789 1
a2789 1
	return(ROFF_CONT);
d2804 1
a2804 1
	return(ROFF_CONT);
d2818 1
a2818 1
		return(ROFF_REPARSE);
d2820 1
a2820 1
	return(ROFF_IGN);
d2833 1
a2833 1
	return(ROFF_IGN);
d2856 1
a2856 1
		return(ROFF_CONT);
d2899 1
a2899 1
	return(ROFF_REPARSE);
d2924 1
a2924 1
	return(ROFF_IGN);
d2932 1
a2932 1
	return(ROFF_IGN);
d2954 1
a2954 1
	return(ROFF_IGN);
d2962 1
a2962 1
	return(ROFF_CONT);
d2979 1
a2979 1
	return(ROFF_IGN);
d2993 1
a2993 1
		return(ROFF_IGN);
d3005 1
a3005 1
				return(ROFF_IGN);
d3016 1
a3016 1
				return(ROFF_IGN);
d3041 1
a3041 1
	return(ROFF_IGN);
d3067 1
a3067 1
		return(ROFF_REPARSE);
d3071 1
a3071 1
	return(ROFF_SO);
d3199 2
a3200 2
	return(buf->sz > 1 && buf->buf[buf->sz - 2] == '\n' ?
	   ROFF_REPARSE : ROFF_APPEND);
d3211 1
a3211 1
		return(0);
d3238 1
a3238 1
	return(namesz);
d3338 1
a3338 1
			return(n->val.p);
d3343 1
a3343 1
			return(predefs[i].str);
d3345 1
a3345 1
	return(NULL);
d3367 1
a3367 1
	return(r->tbl ? tbl_span(r->tbl) : NULL);
d3374 1
a3374 1
	return(r->last_eqn ? &r->last_eqn->eqn : NULL);
d3392 1
a3392 1
		return(mandoc_strdup(p));
d3394 1
a3394 1
		return(mandoc_strdup(""));
d3466 1
a3466 1
	return(res);
d3473 1
a3473 1
	return(r->format);
d3496 1
a3496 1
		return(0);
d3502 1
a3502 1
		return(0);
d3508 1
a3508 1
	return(1);
@


1.147
log
@If we have to reparse the text line because we spring an input line trap,
we must not escape breakable hyphens yet, or mparse_buf_r() in read.c
will complain and replace the escaped hyphens with question marks.
Bug found in ocserv(8) following a report from Kurt Jaeger <pi at FreeBSD>.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.146 2015/08/29 21:37:11 schwarze Exp $ */
a1022 1
		/* NOTREACHED */
d2060 1
a2060 1
		/* FALLTROUGH */
d2065 1
a2065 1
		/* FALLTROUGH */
@


1.146
log
@Implement the escape sequence \\$*, expanding to all arguments
of the current user-defined macro.
This is another missing feature required for ocserv(8).
Problem reported by Kurt Jaeger <pi at FreeBSD>.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.145 2015/08/29 20:24:34 schwarze Exp $ */
d1485 1
a1485 3
 * Process text streams:
 * Convert all breakable hyphens into ASCII_HYPH.
 * Decrement and spring input line trap.
d1496 16
a1539 13

	/* Spring the input line trap. */
	if (roffit_lines == 1) {
		isz = mandoc_asprintf(&p, "%s\n.%s", buf->buf, roffit_macro);
		free(buf->buf);
		buf->buf = p;
		buf->sz = isz + 1;
		*offs = 0;
		free(roffit_macro);
		roffit_lines = 0;
		return(ROFF_REPARSE);
	} else if (roffit_lines > 1)
		--roffit_lines;
@


1.145
log
@Minimal implementation of the read-only number register \n(.$
which returns the number of arguments of the current macro.
This is one of the missing features required for ocserv(8).
Problem reported by Kurt Jaeger <pi at FreeBSD>.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.144 2015/06/27 13:25:30 schwarze Exp $ */
d3081 1
a3081 1
	int		  i;
d3115 8
a3122 3
		i = *cp - '1';
		if (0 > i || 8 < i)
			continue;
d3130 7
a3136 5
		asz = 0;
		for (ap = arg[i]; *ap != '\0'; ap++) {
			asz++;
			if (*ap == '"')
				asz += 3;
d3177 10
a3186 6
		for (ap = arg[i]; *ap != '\0'; ap++) {
			if (*ap == '"') {
				memcpy(n2, "\\(dq", 4);
				n2 += 4;
			} else
				*n2++ = *ap;
@


1.144
log
@Ignore blank characters at the beginning of a conditional block,
that is, after "\{".
Issue found by Markus <Waldeck at gmx dot de> in bash(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.143 2015/05/31 23:12:16 schwarze Exp $ */
d336 1
d413 2
a414 1
static	int		 roff_getregro(const char *name);
d2578 1
a2578 1
roff_getregro(const char *name)
d2582 2
d2608 1
a2608 1
		val = roff_getregro(name + 1);
d2627 1
a2627 1
		val = roff_getregro(name + 1);
d2647 1
a2647 1
		val = roff_getregro(name + 1);
d3089 1
d3091 8
a3098 3
	for (i = 0; i < 9; i++)
		arg[i] = *cp == '\0' ? "" :
		    mandoc_getarg(r->parse, &cp, ln, &pos);
@


1.143
log
@Implement the roff(7) `r' (register exists) conditional.
Missing feature found by Markus <Waldeck at gmx dot de>
in Debian's bash(1) manual page.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.142 2015/05/01 16:01:53 schwarze Exp $ */
d2266 2
@


1.142
log
@Setting the "last" member of struct roff_node was done at an extremely
weird place.  Move it to the obviously correct place.
Surprisingly, this didn't cause any misformatting in the test suite
or in any base system manuals, but i cannot believe the code was
really correct for all conceivable input, and it would be very hard
to verify.  At the very least, it cannot have worked for man(7).
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.141 2015/04/23 16:17:04 schwarze Exp $ */
d398 1
a398 2
static	int		 roff_evalcond(struct roff *r, int,
				const char *, int *);
d415 2
d2136 1
a2136 1
roff_evalcond(struct roff *r, int ln, const char *v, int *pos)
d2138 2
a2161 2
	case 'r':
		/* FALLTHROUGH */
d2167 5
d2630 20
@


1.141
log
@Unify mdoc_deroff() and man_deroff() into a common function deroff().
No functional change except that for mdoc(7), it now skips leading
escape sequences just like it already did for man(7).
Escape sequences rarely occur in mdoc(7) code and if they do,
skipping them is an improvement in this context.
Minus 30 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.140 2015/04/19 14:57:16 schwarze Exp $ */
d1023 1
@


1.140
log
@Unify trickier node handling functions.
* man_elem_alloc() -> roff_elem_alloc()
* man_block_alloc() -> roff_block_alloc()
The functions mdoc_elem_alloc() and mdoc_block_alloc() remain for
now because they need to do mdoc(7)-specific argument processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.139 2015/04/19 14:25:05 schwarze Exp $ */
d1229 46
@


1.139
log
@Unify some node handling functions that use TOKEN_NONE.
* mdoc_word_alloc(), man_word_alloc() -> roff_word_alloc()
* mdoc_word_append(), man_word_append() -> roff_word_append()
* mdoc_addspan(), man_addspan() -> roff_addtbl()
* mdoc_addeqn(), man_addeqn() -> roff_addeqn()
Minus 50 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.138 2015/04/19 13:50:10 schwarze Exp $ */
d1095 21
@


1.138
log
@Unify node handling functions:
* node_alloc() for mdoc and man_node_alloc() -> roff_node_alloc()
* node_append() for mdoc and man_node_append() -> roff_node_append()
* mdoc_head_alloc() and man_head_alloc() -> roff_head_alloc()
* mdoc_body_alloc() and man_body_alloc() -> roff_body_alloc()
* mdoc_node_unlink() and man_node_unlink() -> roff_node_unlink()
* mdoc_node_free() and man_node_free() -> roff_node_free()
* mdoc_node_delete() and man_node_delete() -> roff_node_delete()
Minus 130 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.137 2015/04/18 17:28:08 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2009-2012, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
a32 1
#include "libmdoc.h"
d1067 30
d1117 30
@


1.137
log
@Unify {mdoc,man}_{alloc,reset,free}() into roff_man_{alloc,reset,free}().
Minus 80 lines of code, no functional change.
Written on the train from Koeln to Wolfsburg returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.136 2015/04/04 13:52:59 schwarze Exp $ */
d31 1
d33 1
d41 2
d379 2
d445 2
d743 2
d797 2
d839 2
d916 2
d922 2
a923 6
	if (man->first != NULL) {
		if (man->macroset == MACROSET_MDOC)
			mdoc_node_delete(man, man->first);
		else
			man_node_delete(man, man->first);
	}
d979 174
d1572 2
d1884 2
d2403 2
d2569 2
d2915 2
d3184 2
@


1.136
log
@Don't allow breaking the output line after hyphens following escape
sequences.  Improves tic(1), sxpm(1), and a few Perl manuals.
Quirk found by naddy@@ in milter-greylist(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.135 2015/02/21 14:46:33 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2010, 2011, 2012, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
d29 1
d414 2
d900 65
@


1.135
log
@Escape quotes when expanding macro arguments.
This fixes a bug naddy@@ found in plan9/rc(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.134 2015/02/17 17:55:12 schwarze Exp $ */
d1129 2
@


1.134
log
@Cope with another one of the many kinds of DocBook stupidity:

Instead of just using .br, DocBook sometimes fiddles with the
utterly unportable internal register \n[an-break-flag] that is
only available in the GNU implementation of man(7) and then arms
an input line trap to call the equally unportable internal macro
.an-trap that, in the GNU implementation, inspects that variable;
all the world is GNU, isn't it?

Since naddy@@ reports that quite a few ports manuals suffer from
this insanity, let's just translate it to the intended .br.

Et ceterum censeo DocBookem esse delendam.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.133 2015/02/17 17:16:12 schwarze Exp $ */
d2654 1
a2654 1
	const char	 *arg[9];
d2657 1
d2663 1
d2672 14
a2685 7
	buf->sz = 0;
	n1 = cp = mandoc_strdup(r->current_string);
	while ((cp = strstr(cp, "\\$")) != NULL) {
		i = cp[2] - '1';
		if (0 > i || 8 < i) {
			/* Not an argument invocation. */
			cp += 2;
d2687 58
a2745 6
		*cp = '\0';
		buf->sz = mandoc_asprintf(&n2, "%s%s%s",
		    n1, arg[i], cp + 3) + 1;
		cp = n2 + (cp - n1);
		free(n1);
		n1 = n2;
d2752 1
a2754 2
	if (buf->sz == 0)
		buf->sz = strlen(buf->buf) + 1;
@


1.133
log
@Let .it accept numerical expressions, not just numerical constants.
For .it, ignore scaling units in roff_getnum().
Inside parentheses, skip whitespace after a sign in roff_getnum().
Parse and ignore unary plus in roff_getnum().
As a bonus, get rid of the only call to mandoc_strntoi() in roff.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.132 2015/02/06 16:05:51 schwarze Exp $ */
d2338 8
a2345 1
	/* Arm the input line trap. */
d2348 3
a2350 1
	roffit_macro = mandoc_strdup(buf->buf + pos);
@


1.132
log
@replace the last legacy generic message type, "argument count wrong",
by more specific messages, improving diagnostics for .cc .tr .Bl -column
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.131 2015/01/30 00:19:26 schwarze Exp $ */
d397 1
a397 1
				const char *, int *, int *);
d403 1
a403 1
static	int		 roff_getnum(const char *, int *, int *);
d442 3
d1054 2
a1055 1
			    roff_evalnum(r, ln, stnam, &npos, NULL, 0) &&
d1633 1
a1633 1
roff_getnum(const char *v, int *pos, int *res)
d1635 1
a1635 1
	int	 myres, n, p;
d1642 1
a1642 1
	if (n)
d1645 4
d1661 1
a1661 1
		*res *= 65536;
d1664 1
a1664 1
		*res *= 240;
d1667 1
a1667 2
		*res *= 240;
		*res /= 2.54;
d1672 1
a1672 1
		*res *= 40;
d1677 1
a1677 1
		*res *= 24;
d1680 1
a1680 2
		*res *= 10;
		*res /= 3;
d1683 1
d1686 1
a1686 2
		*res *= 6;
		*res /= 25;
d1689 1
d1693 2
d1784 1
a1784 1
	if (roff_evalnum(r, ln, v, pos, &number, 0))
d2007 1
a2007 1
	const char *v, int *pos, int *res)
d2011 1
a2011 1
		return(roff_getnum(v, pos, res));
d2014 1
a2014 1
	if ( ! roff_evalnum(r, ln, v, pos, res, 1))
d2037 1
a2037 1
	int *pos, int *res, int skipwhite)
d2047 1
a2047 1
	if (skipwhite)
d2051 1
a2051 1
	if ( ! roff_evalpar(r, ln, v, pos, res))
d2055 1
a2055 1
		if (skipwhite)
d2062 1
a2062 1
		if (skipwhite)
d2066 1
a2066 1
		if ( ! roff_evalpar(r, ln, v, pos, &operand2))
d2069 1
a2069 1
		if (skipwhite)
d2273 1
a2273 1
	if (roff_evalnum(r, ln, val, NULL, &iv, 0))
a2327 2
	char		*cp;
	size_t		 len;
d2331 2
a2332 4
	cp = buf->buf + pos;
	len = strcspn(cp, " \t");
	cp[len] = '\0';
	if ((iv = mandoc_strntoi(cp, len, 10)) <= 0) {
a2336 1
	cp += len + 1;
d2339 1
d2341 1
a2341 1
	roffit_macro = mandoc_strdup(cp);
@


1.131
log
@correctly handle table layout lines starting with a dot
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.130 2015/01/28 17:30:37 schwarze Exp $ */
d2539 2
a2540 1
		mandoc_msg(MANDOCERR_ARGCOUNT, r->parse, ln, ppos, NULL);
d2555 1
a2555 1
		mandoc_msg(MANDOCERR_ARGCOUNT, r->parse, ln, ppos, NULL);
d2583 2
a2584 2
			mandoc_msg(MANDOCERR_ARGCOUNT, r->parse,
			    ln, (int)(p - buf->buf), NULL);
@


1.130
log
@* Polish tbl(7) error reporting.
* Do not print out macro names in tbl(7) data blocks.
* Like with GNU tbl, let empty tables cause a blank line.
* Avoid producing empty tables in -Tman.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.129 2015/01/28 15:02:25 schwarze Exp $ */
d1203 1
a1203 1
		return(tbl_read(r->tbl, ln, buf->buf, pos));
@


1.129
log
@For now, it can't be helped that mandoc tbl(7) ignores high-level macros,
but stop throwing away their arguments.  This fixes information loss in a
handful of Xenocara manuals, at the price of a small amount of formatting
noise creeping through.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.128 2015/01/24 02:41:32 schwarze Exp $ */
d2377 6
a2382 3
	else
		tbl_end(&r->tbl);

@


1.128
log
@Strangely, ignoring the roff(7) .na request was implemented in the man(7)
parser.  Simplify the code by moving it into the roff(7) parser, also
making it work for mdoc(7).
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.127 2015/01/23 20:17:25 schwarze Exp $ */
d1238 7
a1244 1
		return(ROFF_IGN);
@


1.127
log
@While ignoring the .ta (set tab stops) and .ti (temp indent) requests
is sometimes harmless, it often causes seriously ugly output,
so flag these requests as unsupported rather than ignoring them.
Discussed with naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.126 2015/01/23 00:38:42 schwarze Exp $ */
d180 1
a180 1
	/* MAN_na; ignored in mdoc(7) */
d581 1
@


1.126
log
@Wonders of roff(7): Integer numbers in numerical expressions can carry
scaling units, and some manuals (e.g. in devel/grcs) actually use that,
so let's support it.  Missing feature reported by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.125 2015/01/22 22:50:31 schwarze Exp $ */
d609 1
a609 1
	{ "pshape", roff_line_ignore, NULL, NULL, 0, NULL },
d641 1
a641 1
	{ "ta", roff_line_ignore, NULL, NULL, 0, NULL },
d645 1
a645 1
	{ "ti", roff_line_ignore, NULL, NULL, 0, NULL },
@


1.125
log
@Slightly improve \w width measurements:
Count special characters with the same width as ASCII characters
and treat all other escape sequences as if they had a width of 0.
Certainly not perfect, but a bit better.
For example, GNU RCS ci(1) needs this; reported by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.124 2015/01/21 02:16:11 schwarze Exp $ */
d1642 40
a1681 2
	*pos = p;
	return 1;
@


1.124
log
@pass empty request lines through to tbl(7); sometimes, they end a layout
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.123 2015/01/20 21:12:46 schwarze Exp $ */
d1005 1
d1007 1
a1007 1
		for (naml = 0; maxl == 0 || naml < maxl; naml++, cp++) {
d1016 17
@


1.123
log
@Split the -Werror message level into -Werror (broken manual, probably
using mandoc is better than using groff) and -Wunsupp (manual using
unsupported low-level roff(7) feature, probably using groff is better
than using mandoc).  Once this feature is complete, it is intended
to help porting, making the decision whether to USE_GROFF easier.

As a first step, distinguish four classes of roff(7) requests:
1. Supported (currently 24 requests)
2. Currently ignored because unimportant (120)  ->  no message
3. Ignored for good because insecure (14)  ->  -Werror
4. Currently unsupported (68)  ->  these trigger the new -Wunsupp messages
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.122 2015/01/16 16:52:39 schwarze Exp $ */
d1167 4
a1170 4
	 * text through the macro's filter.  If a scope isn't open and
	 * we're not a macro, just let it through.
	 * Finally, if there's an equation scope open, divert it into it
	 * no matter our state.
d1173 1
a1173 1
	if (r->last && ! ctl) {
d1181 1
a1181 1
	if (r->eqn)
d1183 3
a1185 3
	if ( ! ctl) {
		if (r->tbl)
			return(tbl_read(r->tbl, ln, buf->buf, pos));
a1186 1
	}
@


1.122
log
@Parse and ignore .IX (generate index entry) macros because pod2man(1)
emits them, by default without defining them, relying on the roff(7)
quirk that undefined macros have no effect.
This cures 1996 mandoc ERRORs in src/gnu.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.121 2015/01/14 22:57:57 schwarze Exp $ */
d39 1
d41 3
d45 1
d47 1
a47 1
	ROFF_am1,
d49 17
d68 18
d87 2
d90 5
a94 1
	ROFF_de1,
d96 6
d103 10
d114 26
d142 5
d150 2
d153 28
d182 1
d184 4
d189 2
d192 11
d204 4
d209 12
d222 2
d225 7
d233 10
d244 9
d254 7
a260 2
	ROFF_Dd,
	ROFF_TH,
d262 18
a279 5
	ROFF_TE,
	ROFF_T_,
	ROFF_EQ,
	ROFF_EN,
	ROFF_IX,
d383 1
d410 1
d433 1
d445 1
d447 3
d451 1
d453 1
a453 1
	{ "am1", roff_block, roff_block_text, roff_block_sub, 0, NULL },
d455 16
d473 18
d492 2
d495 5
a499 1
	{ "de1", roff_block, roff_block_text, roff_block_sub, 0, NULL },
d501 6
d508 10
d519 24
d545 5
d553 1
d555 26
d583 4
d588 2
d591 11
d603 4
d608 12
d621 2
d624 7
d632 9
d642 9
d652 7
a658 2
	{ "Dd", roff_Dd, NULL, NULL, 0, NULL },
	{ "TH", roff_TH, NULL, NULL, 0, NULL },
d660 18
a677 5
	{ "TE", roff_TE, NULL, NULL, 0, NULL },
	{ "T&", roff_T_, NULL, NULL, 0, NULL },
	{ "EQ", roff_EQ, NULL, NULL, 0, NULL },
	{ "EN", roff_EN, NULL, NULL, 0, NULL },
	{ "IX", roff_line_ignore, NULL, NULL, 0, NULL },
d1388 2
d1392 2
d1729 18
d1829 7
d2453 8
@


1.121
log
@downgrade ".so with absolute path" from FATAL to ERROR;
allows to get rid of ROFF_ERR
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.120 2015/01/07 12:19:17 schwarze Exp $ */
d76 1
d276 1
@


1.120
log
@Bugfix: When the invocation of a user-defined macro follows a roff
conditional request on the same input line, don't skip the first few
bytes of its content.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.119 2015/01/01 19:28:29 schwarze Exp $ */
d2104 1
a2104 1
	char *name;
d2119 6
a2124 1
		return(ROFF_ERR);
@


1.119
log
@Fix a buffer overrun triggered by a trailing backslash at EOF in
an unclosed conditional body.  If the memory contained the byte
sequence "\}" after the end of the buffer before the next NUL, this
could even write beyond the end of the buffer, specifically '&' to
the location of the '}'.  Found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.118 2014/12/28 14:16:07 schwarze Exp $ */
d2170 1
@


1.118
log
@improve previous: do the size check up front to avoid leaking memory
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.117 2014/12/25 17:18:40 schwarze Exp $ */
d3 2
a4 2
 * Copyright (c) 2010, 2011, 2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010-2014 Ingo Schwarze <schwarze@@openbsd.org>
d1164 2
a1165 1
		++ep;
d1185 2
a1186 1
		++ep;
@


1.117
log
@Reduce memory and time consumption on certain malformed input files
by limiting the length of expanded input lines during the
(usually recursive) expansion of user defined strings.
Resource hogging found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.116 2014/12/18 17:43:07 schwarze Exp $ */
d652 4
a662 6

		if (buf->sz > SHRT_MAX) {
			mandoc_msg(MANDOCERR_ROFFLOOP, r->parse,
			    ln, (int)(stesc - buf->buf), NULL);
			return(ROFF_IGN);
		}
@


1.116
log
@Don't let the modulo operator divide by zero.
Found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.115 2014/12/16 23:44:16 schwarze Exp $ */
d22 1
d659 6
@


1.115
log
@Ignore mdoc(7) and man(7) macros inside tbl(7) code because they
would abort the table in an unclean way, causing assertion failures
found by jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.114 2014/12/16 03:52:31 schwarze Exp $ */
d1577 1
a1577 1
			if (0 == operand2) {
d1586 6
@


1.114
log
@When a string comparison condition contains no mismatching character
but ends without the final delimiter, the parse point was advanced
one character too far and the invalid pointer returned to the
caller of roff_parseln().  Later use could potentially advance
the pointer even further and maybe even write to it.
Fixing a buffer overrun found by jsg@@ with afl (the most severe so far).
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.113 2014/12/16 01:21:37 schwarze Exp $ */
d731 1
d802 13
d816 2
a817 3
	 * Lastly, as we've no scope open, try to look up and execute
	 * the new macro.  If no macro is found, simply return and let
	 * the compilers handle it.
d820 1
a820 1
	if ((t = roff_parse(r, buf->buf, &pos, ln, ppos)) == ROFF_MAX)
d822 2
@


1.113
log
@When a numerical condition errors out after consuming at least one
character of input, treat it as false, do not retry it as a string
comparison condition.  This also fixes a read buffer overrun that
happened when the numerical condition advanced to the end of the
input line before erroring out, found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.112 2014/12/15 23:42:31 schwarze Exp $ */
d1237 1
a1237 1
	else
@


1.112
log
@Empty conditions count as false.
When negated, they still count as false.
Found when investigating crashes jsg@@ found with afl.
Not completely fixing the crashes yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.111 2014/11/19 01:20:18 schwarze Exp $ */
d1250 1
a1250 1
	int	 wanttrue, number;
d1283 1
d1286 2
d1289 1
a1289 1
		return(roff_evalstrcond(v, pos) == wanttrue);
@


1.111
log
@Support the ".if v" conditional operator (vroff mode, always false)
for groff compatibility because pod2man(1) uses it that way.
Weirdly, groff documents it as "for compatibility with other
troff versions" but neither Heirloom nor Plan 9 have it.
Issue reported by giovanni@@ via sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.110 2014/11/01 06:02:43 schwarze Exp $ */
d1259 2
@


1.110
log
@Use struct buf in libroff, it is very natural there
and reduces the number of arguments of many functions.
While here, sprinkle some KNF.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.109 2014/10/28 17:35:42 schwarze Exp $ */
d1273 2
@


1.109
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.108 2014/10/25 15:23:25 schwarze Exp $ */
d143 1
a143 2
			 char **bufp, /* input buffer */ \
			 size_t *szp, /* size of input buffer */ \
d185 1
a185 2
static	enum rofferr	 roff_eqndelim(struct roff *,
				char **, size_t *, int);
d209 2
a210 3
static	enum rofferr	 roff_parsetext(char **, size_t *, int, int *);
static	enum rofferr	 roff_res(struct roff *,
				char **, size_t *, int, int);
d497 1
a497 1
roff_res(struct roff *r, char **bufp, size_t *szp, int ln, int pos)
d505 1
a505 1
	char		*nbuf;	/* new buffer to copy bufp to */
d516 1
a516 1
	start = *bufp + pos;
d522 1
a522 1
		if ('\\' != *stesc)
d528 1
a528 1
			if ('\\' != *cp)
d531 1
a531 1
		if (0 == (stesc - cp) % 2) {
d558 1
a558 1
				    r->parse, ln, (int)(stesc - *bufp),
d565 1
a565 1
			    ln, (int)(stesc - *bufp), NULL);
d575 1
a575 1
		if ('\0' == term) {
d602 2
a603 2
		for (naml = 0; 0 == maxl || naml < maxl; naml++, cp++) {
			if ('\0' == *cp) {
d605 1
a605 1
				    ln, (int)(stesc - *bufp), stesc);
d609 1
a609 1
			if (0 == maxl && *cp == term) {
d646 1
a646 1
		if (NULL == res) {
d648 1
a648 1
			    r->parse, ln, (int)(stesc - *bufp),
d656 2
a657 2
		*szp = mandoc_asprintf(&nbuf, "%s%s%s",
		    *bufp, res, cp) + 1;
d662 3
a664 3
		stesc = nbuf + (stesc - *bufp) + strlen(res);
		free(*bufp);
		*bufp = nbuf;
d675 1
a675 1
roff_parsetext(char **bufp, size_t *szp, int pos, int *offs)
d683 1
a683 1
	start = p = *bufp + pos;
d685 1
a685 1
	while ('\0' != *p) {
d689 1
a689 1
		if ('\0' == *p)
d692 1
a692 1
		if ('\\' == *p) {
d696 1
a696 1
			if (ESCAPE_ERROR == esc)
d711 5
a715 5
	if (1 == roffit_lines) {
		isz = mandoc_asprintf(&p, "%s\n.%s", *bufp, roffit_macro);
		free(*bufp);
		*bufp = p;
		*szp = isz + 1;
d720 1
a720 1
	} else if (1 < roffit_lines)
d726 1
a726 2
roff_parseln(struct roff *r, int ln, char **bufp,
		size_t *szp, int pos, int *offs)
d730 5
a734 1
	int		 ppos, ctl;
d741 1
a741 1
		e = roff_eqndelim(r, bufp, szp, pos);
d749 2
a750 2
	e = roff_res(r, bufp, szp, ln, pos);
	if (ROFF_IGN == e)
d752 1
a752 1
	assert(ROFF_CONT == e);
d754 1
a754 2
	ppos = pos;
	ctl = roff_getcontrol(r, *bufp, &pos);
d767 3
a769 3
		e = (*roffs[t].text)(r, t, bufp, szp, ln, pos, pos, offs);
		assert(ROFF_IGN == e || ROFF_CONT == e);
		if (ROFF_CONT != e)
d773 1
a773 1
		return(eqn_read(&r->eqn, ln, *bufp, ppos, offs));
d776 2
a777 2
			return(tbl_read(r->tbl, ln, *bufp, pos));
		return(roff_parsetext(bufp, szp, pos, offs));
d782 1
a782 1
	if ((*bufp)[pos] == '"') {
d786 1
a786 1
	} else if ((*bufp)[pos] == '\0')
d798 1
a798 2
		return((*roffs[t].sub)(r, t, bufp, szp,
		    ln, ppos, pos, offs));
d807 1
a807 1
	if (ROFF_MAX == (t = roff_parse(r, *bufp, &pos, ln, ppos)))
d811 1
a811 1
	return((*roffs[t].proc)(r, t, bufp, szp, ln, ppos, pos, offs));
d874 1
a874 1
	if (NULL == r->last) {
d899 1
a899 1
	if ((*bufp)[pos])
d901 1
a901 1
		    ".. %s", *bufp + pos);
d963 1
a963 1
	if (ROFF_de1 == tok)
d965 1
a965 1
	else if (ROFF_am1 == tok)
d970 2
a971 2
	cp = *bufp + pos;
	if (ROFF_ig == tok) {
d982 2
a983 2
	if (namesz && (ROFF_dei == tok || ROFF_ami == tok)) {
		if (NULL == (name = roff_getstrn(r, iname, namesz))) {
d985 1
a985 1
			    r->parse, ln, (int)(iname - *bufp),
d993 1
a993 1
	if (0 == namesz && ROFF_ig != tok) {
d1007 1
a1007 1
	if (ROFF_de == tok || ROFF_dei == tok)
d1010 1
a1010 1
	if ('\0' == *cp)
d1020 2
a1021 2
	if (namesz && (ROFF_dei == tok || ROFF_ami == tok)) {
		if (NULL == (name = roff_getstrn(r, iname, namesz))) {
d1023 1
a1023 1
			    r->parse, ln, (int)(iname - *bufp),
d1034 1
a1034 1
	if ('\0' != *cp)
d1058 1
a1058 1
			if ((*bufp)[i] != r->last->end[j])
d1061 4
a1064 4
		if ('\0' == r->last->end[j] &&
		    ('\0' == (*bufp)[i] ||
		     ' '  == (*bufp)[i] ||
		     '\t' == (*bufp)[i])) {
d1068 1
a1068 1
			while (' ' == (*bufp)[i] || '\t' == (*bufp)[i])
d1072 2
a1073 1
			if (ROFF_MAX != roff_parse(r, *bufp, &pos, ln, ppos))
d1084 1
a1084 1
	t = roff_parse(r, *bufp, &pos, ln, ppos);
d1086 3
a1088 3
	if (ROFF_cblock != t) {
		if (ROFF_ig != tok)
			roff_setstr(r, r->last->name, *bufp + ppos, 2);
d1093 1
a1093 1
	return((*roffs[t].proc)(r, t, bufp, szp, ln, ppos, pos, offs));
d1100 2
a1101 2
	if (ROFF_ig != tok)
		roff_setstr(r, r->last->name, *bufp + pos, 2);
d1115 1
a1115 1
	t = roff_parse(r, *bufp, &pos, ln, ppos);
d1122 2
a1123 2
	if ((ROFF_MAX != t) &&
	    (rr || ROFFMAC_STRUCT & roffs[t].flags)) {
d1125 1
a1125 2
		return((*roffs[t].proc)(r, t, bufp, szp,
		    ln, ppos, pos, offs));
d1133 2
a1134 2
	ep = *bufp + pos;
	if ('\\' == ep[0] && '}' == ep[1])
d1139 2
a1140 2
	while (NULL != (ep = strchr(ep, '\\'))) {
		if ('}' == *(++ep)) {
d1142 1
a1142 1
			roff_ccond(r, ln, ep - *bufp - 1);
d1158 3
a1160 3
	ep = *bufp + pos;
	while (NULL != (ep = strchr(ep, '\\'))) {
		if ('}' == *(++ep)) {
d1162 1
a1162 1
			roff_ccond(r, ln, ep - *bufp - 1);
d1306 1
a1306 1
	r->last->rule = ROFF_el == tok ?
d1308 1
a1308 1
	    roff_evalcond(r, ln, *bufp, &pos);
d1315 1
a1315 1
	if (ROFF_ie == tok) {
d1335 1
a1335 1
	if ('\0' == (*bufp)[pos]) {
d1340 1
a1340 1
	while (' ' == (*bufp)[pos])
d1345 1
a1345 1
	if ('\\' == (*bufp)[pos] && '{' == (*bufp)[pos + 1]) {
d1357 1
a1357 1
	if ('\0' == (*bufp)[pos])
d1381 2
a1382 2
	name = string = *bufp + pos;
	if ('\0' == *name)
d1386 1
a1386 1
	if ('\\' == name[namesz])
d1390 1
a1390 1
	if ('"' == *string)
d1722 2
a1723 2
	key = val = *bufp + pos;
	if ('\0' == *key)
d1727 1
a1727 1
	if ('\\' == key[keysz])
d1732 1
a1732 1
	if ('+' == sign || '-' == sign)
d1748 2
a1749 2
	name = cp = *bufp + pos;
	if ('\0' == *name)
d1757 1
a1757 1
		if (NULL == reg || !strcmp(name, reg->key.p))
d1761 1
a1761 1
	if (NULL != reg) {
d1776 2
a1777 2
	cp = *bufp + pos;
	while ('\0' != *cp) {
d1779 1
a1779 1
		namesz = roff_getname(r, &cp, ln, (int)(cp - *bufp));
d1781 1
a1781 1
		if ('\\' == name[namesz])
d1795 1
a1795 1
	cp = *bufp + pos;
d1800 1
a1800 1
		    ln, ppos, *bufp + 1);
d1871 1
a1871 1
roff_eqndelim(struct roff *r, char **bufp, size_t *szp, int pos)
d1883 1
a1883 1
	cp1 = *bufp + pos;
d1894 1
a1894 1
	if (**bufp != '\0') {
d1922 1
a1922 1
	*szp = mandoc_asprintf(&cp1, "%s%s%s%s%s%s%s", *bufp,
d1924 2
a1925 2
	free(*bufp);
	*bufp = cp1;
d1938 1
a1938 1
	assert(NULL == r->eqn);
d1951 1
a1951 1
	if ((*bufp)[pos])
d1953 1
a1953 1
		    ".EQ %s", *bufp + pos);
d1993 1
a1993 1
	p = *bufp + pos;
d1995 1
a1995 1
	if ('\0' == *p || '.' == (r->control = *p++))
d1998 1
a1998 1
	if ('\0' != *p)
d2011 1
a2011 1
	p = *bufp + pos;
d2013 1
a2013 1
	if ('\0' == *p) {
d2018 1
a2018 1
	while ('\0' != *p) {
d2022 1
a2022 1
		if ('\\' == *first) {
d2024 1
a2024 1
			if (ESCAPE_ERROR == esc) {
d2026 1
a2026 1
				    ln, (int)(p - *bufp), first);
d2033 1
a2033 1
		if ('\\' == *second) {
d2035 1
a2035 1
			if (ESCAPE_ERROR == esc) {
d2037 1
a2037 1
				    ln, (int)(p - *bufp), second);
d2041 1
a2041 1
		} else if ('\0' == *second) {
d2043 1
a2043 1
			    ln, (int)(p - *bufp), NULL);
d2054 1
a2054 1
		if (NULL == r->xtab)
d2071 1
a2071 1
	name = *bufp + pos;
d2081 1
a2081 1
	if ('/' == *name || strstr(name, "../") || strstr(name, "/..")) {
d2102 1
a2102 1
	cp = *bufp + pos;
d2104 1
a2104 1
		arg[i] = '\0' == *cp ? "" :
d2110 1
a2110 1
	*szp = 0;
d2112 1
a2112 1
	while (NULL != (cp = strstr(cp, "\\$"))) {
d2120 1
a2120 1
		*szp = mandoc_asprintf(&n2, "%s%s%s",
d2131 4
a2134 4
	free(*bufp);
	*bufp = n1;
	if (0 == *szp)
		*szp = strlen(*bufp) + 1;
d2136 1
a2136 1
	return(*szp > 1 && '\n' == (*bufp)[(int)*szp - 2] ?
@


1.108
log
@With the current architecture, we can't support inline equations
inside tables, sorry.  So don't even try to parse tbl(7) blocks for
eqn(7) delimiters.
Broken table layout found in glPixelMap(3) while investigating
a bug report by Theo Buehler <theo at math dot ethz dot ch>.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.107 2014/10/25 14:32:07 schwarze Exp $ */
d108 1
d478 1
a478 1
roff_alloc(struct mparse *parse, int options)
d484 1
d511 2
d556 4
a559 1
			if (ESCAPE_ERROR == mandoc_escape(&cp, NULL, NULL))
@


1.107
log
@Report arguments to .EQ as an error, and simplify the code:
* drop trivial wrapper function roff_openeqn()
* drop unused first arg of function eqn_alloc()
* drop usused member "name" of struct eqn_node
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.106 2014/10/20 19:21:31 schwarze Exp $ */
d731 2
a732 1
	if (r->last_eqn != NULL && r->last_eqn->delim &&
@


1.106
log
@protect the roff parser from dividing by zero;
issue found and patch written by kristaps@@
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.105 2014/10/20 15:04:37 schwarze Exp $ */
a207 2
static	void		 roff_openeqn(struct roff *, const char *,
				int, int, const char *);
d1927 2
a1928 3
static void
roff_openeqn(struct roff *r, const char *name, int line,
		int offs, const char *buf)
a1930 1
	int		 poff;
d1933 1
a1933 1
	e = eqn_alloc(name, offs, line, r->parse);
d1945 3
a1947 9
	if (buf) {
		poff = 0;
		eqn_read(&r->eqn, line, buf, offs, &poff);
	}
}

static enum rofferr
roff_EQ(ROFF_ARGS)
{
a1948 1
	roff_openeqn(r, *bufp + pos, ln, ppos, NULL);
@


1.105
log
@correctly parse spacing around in-line equations
at the beginning and at the end of input lines;
issue reported by kristaps@@
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.104 2014/10/20 02:31:44 schwarze Exp $ */
d187 6
a192 3
static	int		 roff_evalcond(const char *, int *);
static	int		 roff_evalnum(const char *, int *, int *, int);
static	int		 roff_evalpar(const char *, int *, int *);
d626 1
a626 1
			    roff_evalnum(stnam, &npos, NULL, 0) &&
d1244 1
a1244 1
roff_evalcond(const char *v, int *pos)
d1275 1
a1275 1
	if (roff_evalnum(v, pos, &number, 0))
d1304 1
a1304 1
	    roff_evalcond(*bufp, &pos);
d1470 2
a1471 1
roff_evalpar(const char *v, int *pos, int *res)
d1478 1
a1478 1
	if ( ! roff_evalnum(v, pos, res, 1))
d1500 2
a1501 1
roff_evalnum(const char *v, int *pos, int *res, int skipwhite)
d1515 1
a1515 1
	if ( ! roff_evalpar(v, pos, res))
d1530 1
a1530 1
		if ( ! roff_evalpar(v, pos, &operand2))
d1551 6
d1731 1
a1731 1
	if (roff_evalnum(val, NULL, &iv, 0))
@


1.104
log
@correct spacing before inline equations
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.103 2014/10/16 01:27:48 schwarze Exp $ */
d1858 2
a1859 1
	char	*cp1, *cp2;
d1874 15
a1888 1
	/* Replace the delimiter with an equation macro. */
d1890 19
a1908 3
	*cp2++ = '\0';
	*szp = mandoc_asprintf(&cp1, "%s%s%s", *bufp,
	    r->eqn == NULL ? "\\&\n.EQ\n" : "\n.EN\n\\&", cp2) + 1;
@


1.103
log
@oops, don't escape the first token of inline equations
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.102 2014/10/16 01:10:06 schwarze Exp $ */
a1872 9
	/* Found a delimiter; get rid of surrounding blanks. */

	cp1 = cp2++;
	while (cp2[0] == ' ')
		cp2++;
	while (cp1[-1] == ' ')
		cp1--;
	*cp1 = '\0';

d1875 3
a1877 2
	*szp = mandoc_asprintf(&cp1, "%s\n.E%s%s", *bufp,
	    r->eqn == NULL ? "Q\n" : "N\n\\&", cp2) + 1;
@


1.102
log
@Implement in-line equations, much needed by Xenocara manuals.
Put the steering into the roff parser rather than into the mdoc
parser such that it works for all macro languages and on both text
and macro lines.
Line breaks and blank characters generated before and after in-line
equations are not perfect yet, but let's do one thing at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.101 2014/09/07 00:21:23 schwarze Exp $ */
d1884 2
a1885 2
	*szp = mandoc_asprintf(&cp1, "%s\n.E%c\n\\&%s", *bufp,
	    r->eqn == NULL ? 'Q' : 'N', cp2) + 1;
@


1.101
log
@Parse and ignore the .pl (page length) request;
Daniel Levai reports that Slackware Linux uses this.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.100 2014/09/06 23:24:27 schwarze Exp $ */
d121 1
d185 2
d728 11
a738 4
	/*
	 * Run the reserved-word filter only if we have some reserved
	 * words to fill in.
	 */
d1852 5
a1856 3
#if 0
static int
roff_closeeqn(struct roff *r)
d1858 1
d1860 33
a1892 1
	return(r->eqn && ROFF_EQN == eqn_end(&r->eqn) ? 1 : 0);
a1893 1
#endif
d1905 1
a1905 1
	if (r->last_eqn)
d1907 4
a1910 1
	else
@


1.100
log
@Simplify by handling empty request lines at the one logical place
in the roff parser instead of in three other places in other parsers.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: roff.c,v 1.99 2014/09/06 22:38:35 schwarze Exp $ */
d61 1
d258 1
@


1.99
log
@Move main format autodetection from the parser dispatcher to the
roff parser where .Dd and .TH are already detected, anyway.  This
improves robustness because it correctly handles whitespace or an
alternate control character before Dd.  In the parser dispatcher,
provide a fallback looking ahead in the input buffer instead of
always assuming man(7).  This corrects autodetection when Dd is
preceded by other macros or macro-like handled requests like .ll.

Triggered by reports from Daniel Levai about issues on Slackware Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d759 9
@


1.98
log
@libroff depends on libmandoc and so libmandoc should be included first.

this change makes the code slightly more portable by removing a gcc
extension (incomplete enum types) which is not part of ISO C.

ok schwarze@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.97 2014/08/08 15:54:10 schwarze Exp $ */
d18 2
d123 1
d458 1
d478 1
d1780 1
a1780 1
	if (0 == ((MPARSE_MDOC | MPARSE_QUICK) & r->options))
d1784 3
d1795 1
a1795 1
	if (0 == (MPARSE_QUICK & r->options))
d1799 3
d2315 7
@


1.97
log
@mention requests and macros in more messages
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.96 2014/08/08 15:48:43 schwarze Exp $ */
d26 1
a27 1
#include "libmandoc.h"
@


1.96
log
@Dynamically allocate the stack of roff(7) .ie condition values
and thus get rid of the last useless fatal error.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.95 2014/08/08 15:15:27 schwarze Exp $ */
d1974 1
a1974 1
	mandoc_vmsg(MANDOCERR_SO, r->parse, ln, ppos, ".so %s", name);
d2066 2
a2067 1
		mandoc_msg(MANDOCERR_NAMESC, r->parse, ln, pos, NULL);
@


1.95
log
@better name and wording for the last two non-generic errors
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.94 2014/07/07 21:35:42 schwarze Exp $ */
a104 1
	int		 options; /* parse options */
d106 1
a106 3
	int		 rstack[RSTACK_MAX]; /* stack of !`ie' rules */
	char		 control; /* control character */
	int		 rstackpos; /* position in rstack */
d118 4
a419 1

a425 1

d431 8
a440 1

a442 4
	roff_freereg(r->regtab);

	r->regtab = NULL;

a445 1

d1283 4
a1286 4
		if (r->rstackpos == RSTACK_MAX - 1) {
			mandoc_msg(MANDOCERR_MEM,
			    r->parse, ln, ppos, NULL);
			return(ROFF_ERR);
@


1.94
log
@Clean up ERROR messages related to document structure and macros:
Hierarchical naming and mention macro names in messages.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.93 2014/07/07 11:34:41 schwarze Exp $ */
d1757 1
a1757 1
		mandoc_msg(MANDOCERR_NUMERIC, r->parse,
@


1.93
log
@implement .dei and .ami
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.92 2014/07/06 19:08:56 schwarze Exp $ */
d785 3
a787 2
		mandoc_msg(MANDOCERR_SCOPEEXIT, r->parse,
		    r->last->line, r->last->col, NULL);
d790 2
a791 2
		mandoc_msg(MANDOCERR_SCOPEEXIT, r->parse,
		    r->eqn->eqn.ln, r->eqn->eqn.pos, NULL);
d796 2
a797 2
		mandoc_msg(MANDOCERR_SCOPEEXIT, r->parse,
		    r->tbl->line, r->tbl->pos, NULL);
d841 2
a842 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d860 2
a861 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d891 2
a892 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d904 2
a905 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d910 2
a911 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d1798 2
a1799 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d1811 2
a1812 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d1863 1
a1863 1
	mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d1873 2
a1874 1
		mandoc_msg(MANDOCERR_SCOPEBROKEN, r->parse, ln, ppos, NULL);
@


1.92
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.91 2014/07/06 18:46:51 schwarze Exp $ */
d846 1
a849 2
	case ROFF_am1:
		/* FALLTHROUGH */
d917 2
a918 1
	char		*name, *cp;
d921 1
a921 2
	name = cp = *bufp + pos;
	namesz = 0;
d923 16
a938 6
	if (ROFF_ig != tok) {
		if ('\0' == *cp) {
			mandoc_msg(MANDOCERR_REQ_EMPTY, r->parse,
			    ln, ppos, roffs[tok].name);
			return(ROFF_IGN);
		}
d940 1
a940 4
		/*
		 * Re-write `de1', since we don't really care about
		 * groff's strange compatibility mode, into `de'.
		 */
d942 10
a951 5
		if (ROFF_de1 == tok)
			tok = ROFF_de;
		else if (ROFF_de != tok)
			mandoc_msg(MANDOCERR_REQUEST, r->parse, ln, ppos,
			    roffs[tok].name);
d953 5
a957 4
		namesz = roff_getname(r, &cp, ln, ppos);
		name[namesz] = '\0';
	} else
		name = NULL;
d967 1
a967 1
	if (namesz && ROFF_de == tok)
d973 1
a973 1
	/* If present, process the custom end-of-line marker. */
d975 1
a975 1
	name = cp;
d977 14
a1044 4
	/*
	 * Macros other than block-end are only significant
	 * in `de' blocks; elsewhere, simply throw them away.
	 */
d1046 1
a1046 1
		if (ROFF_de == tok)
d1059 1
a1059 1
	if (ROFF_de == tok)
@


1.91
log
@Fix expansion of escape sequences with incomplete arguments.
* For \* and \n, discard the incomplete arg, expand to empty string.
* For \B, discard the incomplete arg, expand to the digit 0.
* For \w, use the incomplete arg (behaviour unchanged).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.90 2014/07/04 16:11:41 schwarze Exp $ */
d541 3
a543 2
				mandoc_msg(MANDOCERR_BADESCAPE, r->parse,
				    ln, (int)(stesc - *bufp), NULL);
d588 2
a589 2
				mandoc_msg(MANDOCERR_BADESCAPE, r->parse,
				    ln, (int)(stesc - *bufp), NULL);
d631 3
a633 2
			mandoc_msg(MANDOCERR_BADESCAPE, r->parse,
			    ln, (int)(stesc - *bufp), NULL);
d1895 2
a1896 3
				mandoc_msg(MANDOCERR_BADESCAPE,
				    r->parse, ln,
				    (int)(p - *bufp), NULL);
d1906 2
a1907 3
				mandoc_msg(MANDOCERR_BADESCAPE,
				    r->parse, ln,
				    (int)(p - *bufp), NULL);
@


1.90
log
@Clean up messages regarding excess arguments:
* Downgrade ".Bf -emphasis Em" from FATAL to WARNING.
* Mention the macros, the arguments, and the fallbacks.
* Hierarchical naming.
Also fix the handling of excess .It head arguments in -Tman.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.89 2014/07/03 21:23:08 schwarze Exp $ */
d499 1
a499 1
	int		 irc;	/* return code from roff_evalnum() */
d584 1
d589 1
d605 2
a606 1
			res = roff_getstrn(r, stnam, naml);
d610 3
a612 3
			irc = roff_evalnum(stnam, &npos, NULL, 0);
			ubuf[0] = irc && stnam + npos + 1 == cp
			    ? '1' : '0';
d616 5
a620 2
			(void)snprintf(ubuf, sizeof(ubuf), "%d",
			    roff_getregn(r, stnam, naml));
d623 1
@


1.89
log
@MANDOCERR_NOARGS reported three completely unrelated classes of problems.
Split the roff(7) parts out of it and report the request names for these cases.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.88 2014/07/01 00:32:02 schwarze Exp $ */
d855 2
a856 1
		mandoc_msg(MANDOCERR_ARGSLOST, r->parse, ln, pos, NULL);
d960 2
a961 1
		mandoc_msg(MANDOCERR_ARGSLOST, r->parse, ln, pos, NULL);
@


1.88
log
@The previous commit to this file broke the control flow keywords \{ and \}
when they immediately follow a request or macro name, without intervening
whitespace.  Minimal fix.

The lesson learnt here is that, despite their appearance, \{ and \} are
not escape sequences, so never skip them when parsing for names.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.87 2014/06/29 23:23:16 schwarze Exp $ */
d916 2
a917 1
			mandoc_msg(MANDOCERR_NOARGS, r->parse, ln, ppos, NULL);
d1285 2
a1286 1
		mandoc_msg(MANDOCERR_NOARGS, r->parse, ln, ppos, NULL);
@


1.87
log
@Use the freshly improved roff_getname() function
for the main roff request parsing routine, roff_parse().

In request or macro invocations, escape sequences now terminate the
request or macro name; what follows is treated as arguments.  Besides,
the names of user-defined macros can now contain backslashes (eek!).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.86 2014/06/29 22:38:41 schwarze Exp $ */
d2017 3
a2022 1
		namesz = cp - name - 1;
@


1.86
log
@Use the freshly improved roff_getname() function
for the .de parsing routine, roff_block(),
to correctly handle names terminated by escape sequences.
Besides, this saves us 20 lines of code.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.85 2014/06/29 22:12:54 schwarze Exp $ */
d199 2
a200 1
static	enum rofft	 roff_parse(struct roff *, const char *, int *);
d764 1
a764 1
	if (ROFF_MAX == (t = roff_parse(r, *bufp, &pos)))
d797 1
a797 1
roff_parse(struct roff *r, const char *buf, int *pos)
d799 1
d804 3
a806 2
	if ('\0' == buf[*pos] || '"' == buf[*pos] ||
	    '\t' == buf[*pos] || ' ' == buf[*pos])
d809 2
a810 4
	/* We stop the macro parse at an escape, tab, space, or nil. */

	mac = buf + *pos;
	maclen = strcspn(mac, " \\\t\0");
d815 2
a816 4
	*pos += (int)maclen;

	while (buf[*pos] && ' ' == buf[*pos])
		(*pos)++;
d994 1
a994 1
			if (ROFF_MAX != roff_parse(r, *bufp, &pos))
d1005 1
a1005 1
	t = roff_parse(r, *bufp, &pos);
d1040 1
a1040 1
	t = roff_parse(r, *bufp, &pos);
@


1.85
log
@Major roff_getname() cleanup.
* Return the name even if it is terminated by an escape sequence, not a blank.
* Skip the full escape sequence using mandoc_escape(), not just the first byte.
* Make it non-destructive, return the length instead of writing a '\0'.
* Let .ds and .as cope with the above changes to the internal interface.
* Fix .rm and .rr to accept an escape sequence as the end of a name.
* Fix .nr and .rr to not set/delete a register with an empty name.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.84 2014/06/29 21:19:34 schwarze Exp $ */
d909 2
a910 3
	int		sv;
	size_t		sz;
	char		*name;
d912 2
a913 1
	name = NULL;
d916 1
a916 1
		if ('\0' == (*bufp)[pos]) {
d928 1
a928 3
		if (ROFF_de == tok)
			name = *bufp + pos;
		else
d932 4
a935 6
		while ((*bufp)[pos] && ! isspace((unsigned char)(*bufp)[pos]))
			pos++;

		while (isspace((unsigned char)(*bufp)[pos]))
			(*bufp)[pos++] = '\0';
	}
d945 2
a946 2
	if (ROFF_de == tok)
		roff_setstr(r, name, "", 0);
d948 1
a948 1
	if ('\0' == (*bufp)[pos])
d953 4
a956 12
	sv = pos;
	while ((*bufp)[pos] && ! isspace((unsigned char)(*bufp)[pos]))
		pos++;

	/*
	 * Note: groff does NOT like escape characters in the input.
	 * Instead of detecting this, we're just going to let it fly and
	 * to hell with it.
	 */

	assert(pos > sv);
	sz = (size_t)(pos - sv);
d958 1
a958 9
	if (1 == sz && '.' == (*bufp)[sv])
		return(ROFF_IGN);

	r->last->end = mandoc_malloc(sz + 1);

	memcpy(r->last->end, *bufp + sv, sz);
	r->last->end[(int)sz] = '\0';

	if ((*bufp)[pos])
@


1.84
log
@Bugfix in roff_setstrn():
Do not call strcmp() on an array of char that might not be NUL-terminated.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.83 2014/06/25 00:19:17 schwarze Exp $ */
d186 1
a186 1
static	char		*roff_getname(struct roff *, char **, int, int);
d1317 3
a1319 1
	char		*name, *string;
d1322 3
a1324 7
	 * A symbol is named by the first word following the macro
	 * invocation up to a space.  Its value is anything after the
	 * name's trailing whitespace and optional double-quote.  Thus,
	 *
	 *  [.ds foo "bar  "     ]
	 *
	 * will have `bar  "     ' as its value.
d1327 1
a1327 2
	string = *bufp + pos;
	name = roff_getname(r, &string, ln, pos);
d1331 5
a1335 1
	/* Read past initial double-quote. */
d1340 2
a1341 1
	roff_setstr(r, name, string, ROFF_as == tok);
d1655 2
a1656 2
	const char	*key;
	char		*val;
d1660 8
a1667 2
	val = *bufp + pos;
	key = roff_getname(r, &val, ln, pos);
d1683 2
a1684 2
	const char	*name;
	char		*cp;
d1686 5
a1690 2
	cp = *bufp + pos;
	name = roff_getname(r, &cp, ln, pos);
d1712 1
d1716 5
a1720 3
		name = roff_getname(r, &cp, ln, (int)(cp - *bufp));
		if ('\0' != *name)
			roff_setstr(r, name, NULL, 0);
d2020 1
a2020 1
static char *
d2024 1
d2028 1
a2028 1
		return(name);
d2030 6
a2035 2
	/* Read until end of name. */
	for (cp = name; '\0' != *cp && ' ' != *cp; cp++) {
d2041 1
d2043 2
a2044 2
		*cp = '\0';
		name = cp;
a2046 4
	/* Nil-terminate name. */
	if ('\0' != *cp)
		*(cp++) = '\0';

d2052 1
a2052 1
	return(name);
@


1.83
log
@Improve messages related to the roff(7) .so request.

In all these messages, show the filename argument that was passed
to the .so request.

In case of failure, show an additional message reporting the file
and the line number where the failing request was found.
The existing message reporting the reason for the failure -
for example, "Permission denied" - is left in place, unchanged.

Inspired by a question asked by Nick@@ after he saw the
confusing old messages that used to be emitted in this area.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.82 2014/04/23 16:07:06 schwarze Exp $ */
d2067 2
a2068 1
	while (n && strcmp(name, n->key.p))
@


1.82
log
@Audit strlcpy(3)/strlcat(3) usage.

* Repair three instances of silent truncation, use asprintf(3).
* Change two instances of strlen(3)+malloc(3)+strlcpy(3)+strlcat(3)+...
to use asprintf(3) instead to make them less error prone.
* Cast the return value of four instances where the destination
buffer is known to be large enough to (void).
* Completely remove three useless instances of strlcpy(3)/strlcat(3).
* Mark two places in -Thtml with XXX that can cause information loss
and crashes but are not easy to fix, requiring design changes of
some internal interfaces.
* The file mandocdb.c remains to be audited.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.81 2014/04/20 19:39:35 schwarze Exp $ */
d1937 2
a1938 1
	mandoc_msg(MANDOCERR_SO, r->parse, ln, ppos, NULL);
a1946 1
	name = *bufp + pos;
d1948 2
a1949 1
		mandoc_msg(MANDOCERR_SOPATH, r->parse, ln, pos, NULL);
@


1.81
log
@make sure static buffers for snprintf(3) are large enough
and cast snprintf return value to (void) where they are
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.80 2014/04/20 16:44:44 schwarze Exp $ */
d489 1
a489 1
	const char	*stesc;	/* start of an escape sequence ('\\') */
a495 1
	size_t		 ressz;	/* size of the replacement string */
d518 1
a518 1
			stesc = cp;
a625 1
		ressz = strlen(res);
d629 3
a631 6
		*szp += ressz + 1;
		nbuf = mandoc_malloc(*szp);

		strlcpy(nbuf, *bufp, (size_t)(stesc - *bufp + 1));
		strlcat(nbuf, res, *szp);
		strlcat(nbuf, cp, *szp);
d636 1
a636 1
		stesc = nbuf + (stesc - *bufp) + ressz;
d1984 3
a1986 8

		*szp = strlen(n1) - 3 + strlen(arg[i]) + 1;
		n2 = mandoc_malloc(*szp);

		strlcpy(n2, n1, (size_t)(cp - n1 + 1));
		strlcat(n2, arg[i], *szp);
		strlcat(n2, cp + 3, *szp);

@


1.80
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.79 2014/04/08 01:36:50 schwarze Exp $ */
d487 1
a487 1
	char		 ubuf[12]; /* buffer to print the number */
d613 1
a613 1
			snprintf(ubuf, sizeof(ubuf), "%d",
d617 1
a617 1
			snprintf(ubuf, sizeof(ubuf), "%d",
@


1.79
log
@Fully implement the \B (validate numerical expression) and
partially implement the \w (measure text width) escape sequence
in a way that makes them usable in numerical expressions and in
conditional requests, similar to how \n (interpolate number register)
and \* (expand user-defined string) are implemented.

This lets mandoc(1) handle the baroque low-level roff code
found at the beginning of the ggrep(1) manual.
Thanks to pascal@@ for the report.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.78 2014/04/07 21:00:00 schwarze Exp $ */
d136 1
a136 1
		 	 char **bufp, /* input buffer */ \
d192 1
a192 1
static	const char	*roff_getstrn(const struct roff *, 
d201 1
a201 1
static	enum rofferr	 roff_res(struct roff *, 
d207 1
a207 1
static	void		 roff_setstrn(struct roffkv **, const char *, 
d314 1
a366 1

d377 1
a377 1
	p = r->last; 
a384 1

a406 1

a455 1

a463 1

d473 1
a473 1
	
d528 1
a528 1
		case ('*'):
d531 1
a531 1
		case ('B'):
d533 1
a533 1
		case ('w'):
d536 1
a536 1
		case ('n'):
d560 1
a560 1
			case ('\0'):
d563 1
a563 1
			case ('('):
d567 1
a567 1
			case ('['):
d586 2
a587 4
				mandoc_msg
					(MANDOCERR_BADESCAPE, 
					 r->parse, ln, 
					 (int)(stesc - *bufp), NULL);
d602 1
a602 1
		case ('*'):
d605 1
a605 1
		case ('B'):
d612 1
a612 1
		case ('n'):
d616 1
a616 1
		case ('w'):
d623 2
a624 3
			mandoc_msg
				(MANDOCERR_BADESCAPE, r->parse, 
				 ln, (int)(stesc - *bufp), NULL);
d705 1
a705 1
roff_parseln(struct roff *r, int ln, char **bufp, 
d736 1
a736 2
		e = (*roffs[t].text)
			(r, t, bufp, szp, ln, pos, pos, offs);
d758 2
a759 3
		return((*roffs[t].sub)
				(r, t, bufp, szp, 
				 ln, ppos, pos, offs));
d772 1
a772 3
	return((*roffs[t].proc)
			(r, t, bufp, szp, 
			 ln, ppos, pos, offs));
a774 1

d781 1
a781 1
				r->last->line, r->last->col, NULL);
d784 2
a785 2
		mandoc_msg(MANDOCERR_SCOPEEXIT, r->parse, 
				r->eqn->eqn.ln, r->eqn->eqn.pos, NULL);
d790 2
a791 2
		mandoc_msg(MANDOCERR_SCOPEEXIT, r->parse, 
				r->tbl->line, r->tbl->pos, NULL);
d807 2
a808 2
	if ('\0' == buf[*pos] || '"' == buf[*pos] || 
			'\t' == buf[*pos] || ' ' == buf[*pos])
a826 1
/* ARGSUSED */
d842 1
a842 1
	case (ROFF_am):
d844 1
a844 1
	case (ROFF_ami):
d846 1
a846 1
	case (ROFF_am1):
d848 1
a848 1
	case (ROFF_de):
d851 1
a851 1
	case (ROFF_dei):
d853 1
a853 1
	case (ROFF_ig):
a868 1

a879 1

d890 1
a890 1
	case (ROFF_el):
d892 1
a892 1
	case (ROFF_ie):
d894 1
a894 1
	case (ROFF_if):
a910 2

/* ARGSUSED */
a988 2

/* ARGSUSED */
d1009 4
a1012 4
		if ('\0' == r->last->end[j] && 
				('\0' == (*bufp)[i] ||
				 ' ' == (*bufp)[i] ||
				 '\t' == (*bufp)[i])) {
d1044 1
a1044 2
	return((*roffs[t].proc)(r, t, bufp, szp, 
				ln, ppos, pos, offs));
a1046 2

/* ARGSUSED */
a1056 2

/* ARGSUSED */
d1077 1
a1077 1
					ln, ppos, pos, offs));
a1100 1
/* ARGSUSED */
d1211 1
a1211 1
	case ('n'):
d1213 1
a1213 1
	case ('o'):
d1216 1
a1216 1
	case ('c'):
d1218 1
a1218 1
	case ('d'):
d1220 1
a1220 1
	case ('e'):
d1222 1
a1222 1
	case ('r'):
d1224 1
a1224 1
	case ('t'):
a1236 1
/* ARGSUSED */
a1243 1
/* ARGSUSED */
d1250 1
a1250 1
	/* 
d1253 1
a1253 1
	 * defaults to DENY.  
d1259 2
a1260 2
		(r->rstackpos < 0 ? 0 : r->rstack[r->rstackpos--]) :
		roff_evalcond(*bufp, &pos);
d1269 2
a1270 2
			mandoc_msg(MANDOCERR_MEM, 
				r->parse, ln, ppos, NULL);
d1301 1
a1301 1
	} 
a1318 2

/* ARGSUSED */
d1360 1
a1360 1
	case ('+'):
d1362 1
a1362 1
	case ('-'):
d1364 1
a1364 1
	case ('*'):
d1366 1
a1366 1
	case ('/'):
d1368 1
a1368 1
	case ('%'):
d1370 1
a1370 1
	case ('&'):
d1372 1
a1372 1
	case (':'):
d1376 1
a1376 1
		case ('='):
d1380 1
a1380 1
		case ('>'):
d1384 1
a1384 1
		case ('?'):
d1394 1
a1394 1
		case ('='):
d1398 1
a1398 1
		case ('?'):
d1492 1
a1492 1
		case ('+'):
d1495 1
a1495 1
		case ('-'):
d1498 1
a1498 1
		case ('*'):
d1501 1
a1501 1
		case ('/'):
d1504 1
a1504 1
		case ('%'):
d1507 1
a1507 1
		case ('<'):
d1510 1
a1510 1
		case ('>'):
d1513 1
a1513 1
		case ('l'):
d1516 1
a1516 1
		case ('g'):
d1519 1
a1519 1
		case ('='):
d1522 1
a1522 1
		case ('!'):
d1525 1
a1525 1
		case ('&'):
d1528 1
a1528 1
		case (':'):
d1531 1
a1531 1
		case ('i'):
d1535 1
a1535 1
		case ('a'):
d1586 1
a1586 1
	case ('A'):  /* ASCII approximation mode is always off. */
d1588 1
a1588 1
	case ('g'):  /* Groff compatibility mode is always on. */
d1590 1
a1590 1
	case ('H'):  /* Fixed horizontal resolution. */
d1592 1
a1592 1
	case ('j'):  /* Always adjust left margin only. */
d1594 1
a1594 1
	case ('T'):  /* Some output device is always defined. */
d1596 1
a1596 1
	case ('V'):  /* Fixed vertical resolution. */
a1700 1
/* ARGSUSED */
a1715 1
/* ARGSUSED */
d1729 1
a1729 1
				ln, ppos, *bufp + 1);
a1739 1
/* ARGSUSED */
a1751 1
/* ARGSUSED */
a1763 1
/* ARGSUSED */
a1775 1
/* ARGSUSED */
d1798 1
a1798 1
roff_openeqn(struct roff *r, const char *name, int line, 
a1819 1
/* ARGSUSED */
a1827 1
/* ARGSUSED */
a1835 1
/* ARGSUSED */
a1856 1
/* ARGSUSED */
a1872 1
/* ARGSUSED */
d1894 3
a1896 3
				mandoc_msg
					(MANDOCERR_BADESCAPE, r->parse, 
					 ln, (int)(p - *bufp), NULL);
d1906 3
a1908 3
				mandoc_msg
					(MANDOCERR_BADESCAPE, r->parse, 
					 ln, (int)(p - *bufp), NULL);
d1913 2
a1914 2
			mandoc_msg(MANDOCERR_ARGCOUNT, r->parse, 
					ln, (int)(p - *bufp), NULL);
d1920 2
a1921 2
			roff_setstrn(&r->xmbtab, first, 
					fsz, second, ssz, 0);
d1926 2
a1927 2
			r->xtab = mandoc_calloc
				(128, sizeof(struct roffstr));
a1936 1
/* ARGSUSED */
a1960 1
/* ARGSUSED */
d2061 1
a2061 1
			string ? strlen(string) : 0, append);
d2142 2
a2143 2
		if (0 == strncmp(name, n->key.p, len) && 
				'\0' == n->key.p[(int)len])
d2170 1
a2170 1
	
d2177 1
a2177 1
	
d2236 2
a2237 2
			res = mandoc_realloc
				(res, ssz + cp->val.sz + 1);
d2258 2
a2259 2
		/* 
		 * We bail out on bad escapes. 
d2274 1
a2274 1
 * Find out whether a line is a macro line or not.  
@


1.78
log
@We already supported (outer) user-defined strings containing references
to other (inner) user-defined strings in their values, such that the inner
ones get expanded at expansion time of the outer ones (delayed evaluation).
Now we also support specifying the name of an (outer) user-defined
string to expand using the expanded values of some other (inner)
user-defined strings (indirect reference).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.77 2014/04/07 15:05:12 schwarze Exp $ */
d484 3
a486 3
 * In the current line, expand user-defined strings ("\*")
 * and references to number registers ("\n").
 * Also check the syntax of other escape sequences.
d502 3
d527 1
a527 4
		/*
		 * Everything except user-defined strings and number
		 * registers is only checked, not expanded.
		 */
d529 1
d535 5
d562 20
a581 9
		switch (*++cp) {
		case ('\0'):
			continue;
		case ('('):
			cp++;
			maxl = 2;
			break;
		case ('['):
			cp++;
a582 4
			break;
		default:
			maxl = 1;
			break;
d594 1
a594 1
				continue;
d596 2
a597 1
			if (0 == maxl && ']' == *cp)
d599 1
d607 2
a608 1
		if (NULL == res)
d610 9
a618 1
		else
d621 6
d643 1
a643 1
		strlcat(nbuf, cp + (maxl ? 0 : 1), *szp);
d1155 4
a1158 1
	int p, n;
d1462 6
a1467 1
	/* If the trailing parenthesis is missing, ignore the error. */
d1470 2
d1516 3
@


1.77
log
@Almost complete implementation of roff(7) numerical expressions.
Support all binary operators except ';' (scale conversion).
Fully support chained operations and nested parentheses.
Use this for the .nr, .if, and .ie requests.
While here, fix parsing of integer numbers in roff_getnum().
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.76 2014/04/05 20:33:38 schwarze Exp $ */
d492 1
a497 1
	size_t		 nsz;	/* size of the new buffer */
d500 1
d504 3
d508 15
a522 4
again:
	cp = *bufp + pos;
	while (NULL != (cp = strchr(cp, '\\'))) {
		stesc = cp++;
d525 2
a526 3
		 * The second character must be an asterisk or an n.
		 * If it isn't, skip it anyway:  It is escaped,
		 * so it can't start another escape sequence.
d529 1
a529 3
		if ('\0' == *cp)
			return(ROFF_CONT);

d538 4
a541 6
			if (ESCAPE_ERROR != mandoc_escape(&cp, NULL, NULL))
				continue;
			mandoc_msg
				(MANDOCERR_BADESCAPE, r->parse, 
				 ln, (int)(stesc - *bufp), NULL);
			return(ROFF_CONT);
d544 5
a548 1
		cp++;
d556 1
a556 1
		switch (*cp) {
d558 1
a558 1
			return(ROFF_CONT);
d581 1
a581 1
				return(ROFF_CONT);
d604 1
d608 2
a609 1
		pos = stesc - *bufp;
d611 3
a613 2
		nsz = *szp + strlen(res) + 1;
		nbuf = mandoc_malloc(nsz);
d615 1
a615 3
		strlcpy(nbuf, *bufp, (size_t)(stesc - *bufp + 1));
		strlcat(nbuf, res, nsz);
		strlcat(nbuf, cp + (maxl ? 0 : 1), nsz);
d617 2
a619 1

a620 8
		*szp = nsz;

		if (EXPAND_LIMIT >= ++expand_count)
			goto again;

		/* Just leave the string unexpanded. */
		mandoc_msg(MANDOCERR_ROFFLOOP, r->parse, ln, pos, NULL);
		return(ROFF_IGN);
@


1.76
log
@Implement the roff(7) .rr (remove register) request.
As reported by sthen@@, the perl-5.18 pod2man(1) preamble
thinks cool kids use that in manuals.  I hope *you* know better.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.75 2014/03/21 22:52:21 schwarze Exp $ */
d180 2
d1108 6
d1125 1
a1125 1
		*res += 10 * *res + v[p] - '0';
a1135 28
static int
roff_getop(const char *v, int *pos, char *res)
{
	int e;

	*res = v[*pos];
	e = v[*pos + 1] == '=';

	switch (*res) {
	case '=':
		break;
	case '>':
		if (e)
			*res = 'g';
		break;
	case '<':
		if (e)
			*res = 'l';
		break;
	default:
		return(0);
	}

	*pos += 1 + e;

	return(*res);
}

d1179 4
d1186 1
a1186 2
	int	 wanttrue, lh, rh;
	char	 op;
d1215 3
a1217 1
	if (!roff_getnum(v, pos, &lh))
a1218 19
	if (!roff_getop(v, pos, &op))
		return((lh > 0) == wanttrue);
	if (!roff_getnum(v, pos, &rh))
		return(0);

	switch (op) {
	case 'g':
		return((lh >= rh) == wanttrue);
	case 'l':
		return((lh <= rh) == wanttrue);
	case '=':
		return((lh == rh) == wanttrue);
	case '>':
		return((lh > rh) == wanttrue);
	case '<':
		return((lh < rh) == wanttrue);
	default:
		return(0);
	}
d1336 188
a1632 1
/* ARGSUSED */
a1637 1
	size_t		 sz;
d1648 2
a1649 4
	sz = strspn(val, "0123456789");
	iv = sz ? mandoc_strntoi(val, sz, 10) : 0;

	roff_setreg(r, key, iv, sign);
@


1.75
log
@avoid repetitive code for asprintf error handling
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.74 2014/03/21 22:17:01 schwarze Exp $ */
d61 1
d202 1
d252 1
d1501 25
@


1.74
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.73 2014/03/20 02:57:13 schwarze Exp $ */
d655 1
a655 5
		isz = asprintf(&p, "%s\n.%s", *bufp, roffit_macro);
		if (-1 == isz) {
			perror(NULL);
			exit((int)MANDOCLEVEL_SYSERR);
		}
@


1.73
log
@Remove currently unimplemented macros from the lists of used-defined
macros to be cleared during .Dd and .TH because clearing them at that
point defeats the purpose of backup implementations provided in the
manual page itself, some of which _do_ work with mandoc(1).
While here, add the new .%C macro to the list to be cleared.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.72 2014/03/19 21:50:59 schwarze Exp $ */
d25 1
@


1.72
log
@Generalize the mparse_alloc() and roff_alloc() functions by giving
them an "options" argument, replacing the existing "inttype" and
"quick" arguments, preparing for a future MPARSE_SO option.
Store this argument in struct mparse and struct roff, replacing the
existing "inttype", "parsetype", and "quick" members.
No functional change except one tiny cosmetic fix in roff_TH().
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.71 2014/03/08 04:43:39 schwarze Exp $ */
d263 1
d269 3
a271 3
	"Ds", "Dt", "Dv", "Dx", "D1",
	"Ec", "Ed", "Ef", "Ek", "El", "Em", "em",
	"En", "Eo", "Eq", "Er", "Es", "Ev", "Ex",
d273 2
a274 2
	"Hf", "Ic", "In", "It", "Lb", "Li", "Lk", "Lp", "LP",
	"Me", "Ms", "Mt", "Nd", "Nm", "No", "Ns", "Nx",
d276 3
a278 3
	"Pa", "Pc", "Pf", "Po", "Pp", "PP", "pp", "Pq",
	"Qc", "Ql", "Qo", "Qq", "Or", "Rd", "Re", "Rs", "Rv",
	"Sc", "Sf", "Sh", "SH", "Sm", "So", "Sq",
d281 1
a281 1
	"%A", "%B", "%D", "%I", "%J", "%N", "%O",
d286 1
d288 5
a292 5
	"AT", "B", "BI", "BR", "BT", "DE", "DS", "DT",
	"EE", "EN", "EQ", "EX", "HF", "HP", "I", "IB", "IP", "IR",
	"LP", "ME", "MT", "OP", "P", "PD", "PP", "PT",
	"R", "RB", "RE", "RI", "RS", "SB", "SH", "SM", "SS", "SY",
	"TE", "TH", "TP", "TQ", "TS", "T&", "UC", "UE", "UR", "YS",
@


1.71
log
@Improve .if/.ie condition handling.
* Support string comparisons.
* Support negation not only for numerical, but for all conditions.
* Switch the `o' condition from false to true.
* Handle the `c', `d', and `r' conditions as false for now.
* Use int for boolean data instead of rolling our own "enum roffrule";
needed such that we can use the standard ! and == operators.

Havard Eidnes reported via the NetBSD bug tracking system that some
Tcl*(3) manuals need this, and Thomas Klausner <wiz at NetBSD>
forwarded the report to me.  This doesn't make the crazy Tcl*(3)
macrology maze happy yet, but brings us a bit closer.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.70 2014/03/07 18:37:32 schwarze Exp $ */
a101 1
	enum mparset	 parsetype; /* requested parse type */
d103 1
a103 1
	int		 quick; /* skip standard macro deletion */
d461 1
a461 1
roff_alloc(enum mparset type, struct mparse *parse, int quick)
a465 1
	r->parsetype = type;
d467 1
a467 1
	r->quick = quick;
d1549 1
a1549 1
	if (0 == r->quick && MPARSE_MDOC != r->parsetype)
d1562 1
a1562 1
	if (0 == r->quick && MPARSE_MDOC != r->parsetype)
@


1.70
log
@In roff_cond_sub(), make sure that the incorrect input sequence `\\}',
when found on a macro line, does not close a conditional block.
The companion function roff_cond_text() already did this correctly,
but make the code more readable without functional change.
While here, report the correct column number in related error messages.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.69 2014/03/07 17:57:28 schwarze Exp $ */
a74 5
enum	roffrule {
	ROFFRULE_DENY,
	ROFFRULE_ALLOW
};

d106 1
a106 1
	enum roffrule	 rstack[RSTACK_MAX]; /* stack of !`ie' rules */
d130 1
a130 1
	enum roffrule	 rule; /* current evaluation rule */
d178 2
a179 1
static	enum roffrule	 roff_evalcond(const char *, int *);
d396 1
a396 1
	p->rule = p->parent ? p->parent->rule : ROFFRULE_DENY;
a1044 1
	enum roffrule	 rr;
d1046 1
d1058 1
a1058 2
	    (ROFFRULE_ALLOW == rr ||
	     ROFFMAC_STRUCT & roffs[t].flags)) {
d1071 1
a1071 1
		rr = ROFFRULE_DENY;
d1082 1
a1082 1
	return(ROFFRULE_DENY == rr ? ROFF_IGN : ROFF_CONT);
d1090 1
a1090 1
	enum roffrule	 rr;
d1103 1
a1103 1
	return(ROFFRULE_DENY == rr ? ROFF_IGN : ROFF_CONT);
d1156 44
a1199 1
static enum roffrule
d1202 1
a1202 1
	int	 not, lh, rh;
d1205 6
d1213 2
d1216 5
a1220 1
		return(ROFFRULE_ALLOW);
d1223 1
a1223 1
	case ('o'):
d1227 1
a1227 5
		return(ROFFRULE_DENY);
	case ('!'):
		(*pos)++;
		not = 1;
		break;
a1228 1
		not = 0;
d1233 3
a1235 6
		return ROFFRULE_DENY;
	if (!roff_getop(v, pos, &op)) {
		if (lh < 0)
			lh = 0;
		goto out;
	}
d1237 2
a1238 1
		return ROFFRULE_DENY;
d1241 1
a1241 2
		lh = lh >= rh;
		break;
d1243 1
a1243 2
		lh = lh <= rh;
		break;
d1245 1
a1245 2
		lh = lh == rh;
		break;
d1247 1
a1247 2
		lh = lh > rh;
		break;
d1249 1
a1249 2
		lh = lh < rh;
		break;
d1251 1
a1251 1
		return ROFFRULE_DENY;
a1252 4
out:
	if (not)
		lh = !lh;
	return lh ? ROFFRULE_ALLOW : ROFFRULE_DENY;
d1279 1
a1279 2
		(r->rstackpos < 0 ? 
		 ROFFRULE_DENY : r->rstack[r->rstackpos--]) :
d1293 1
a1293 3
		r->rstack[++r->rstackpos] = 
			ROFFRULE_DENY == r->last->rule ?
			ROFFRULE_ALLOW : ROFFRULE_DENY;
d1298 2
a1299 2
	if (r->last->parent && ROFFRULE_DENY == r->last->parent->rule)
		r->last->rule = ROFFRULE_DENY;
@


1.69
log
@Even on macro lines, \} must not cause whitespace.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.68 2014/03/07 02:21:55 schwarze Exp $ */
d1081 5
a1085 4
		if ('}' != *(++ep))
			continue;
		*ep = '&';
		roff_ccond(r, ln, pos);
d1100 7
a1106 7
	ep = &(*bufp)[pos];
	for ( ; NULL != (ep = strchr(ep, '\\')); ep++) {
		ep++;
		if ('}' != *ep)
			continue;
		*ep = '&';
		roff_ccond(r, ln, pos);
@


1.68
log
@Three bugfixes related to the closing of conditional blocks:
1. Handle more than one `\}' on macro lines, as it was already done
for text lines.
2. Do not treat `\}' as a macro invocation after a dot at the beginning
of a line.  That allows more than one `\}' to work on lines starting
with `.\}'.  It also simplifies the code.
3. Do not complain about characters following `\}'.  Those are not lost,
but handled normally both on text and macro lines.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.67 2014/02/14 23:24:17 schwarze Exp $ */
d1069 9
a1079 1
	ep = &(*bufp)[pos];
d1083 1
a1083 13

		/*
		 * If we're at the end of line, then just chop
		 * off the \} and resize the buffer.
		 * If we aren't, then convert it to spaces.
		 */

		if ('\0' == *(ep + 1)) {
			*--ep = '\0';
			*szp -= 2;
		} else
			*(ep - 1) = *ep = ' ';

@


1.67
log
@Parse and ignore the roff(7) .ce request (center some lines).

We even parse and ignore the .ad request (adjustment mode),
and it doesn't make sense to more prominently warn about
temporary than about permanent adjustment changes.

Request found by naddy@@ in xloadimage(1) and by juanfra@@ in racket(1).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.66 2014/02/14 23:05:08 schwarze Exp $ */
a70 1
	ROFF_ccond,
d178 1
a178 1
static	enum rofferr	 roff_ccond(ROFF_ARGS);
a264 1
	{ "\\}", roff_ccond, NULL, NULL, 0, NULL },
d787 1
a787 5
	/*
	 * We stop the macro parse at an escape, tab, space, or nil.
	 * However, `\}' is also a valid macro, so make sure we don't
	 * clobber it by seeing the `\' as the end of token.
	 */
d790 1
a790 1
	maclen = strcspn(mac + 1, " \\\t\0") + 1;
d859 2
a860 3
/* ARGSUSED */
static enum rofferr
roff_ccond(ROFF_ARGS)
d865 1
a865 1
		return(ROFF_IGN);
d877 1
a877 1
		return(ROFF_IGN);
d882 1
a882 1
		return(ROFF_IGN);
a884 3
	if ((*bufp)[pos])
		mandoc_msg(MANDOCERR_ARGSLOST, r->parse, ln, pos, NULL);

d887 1
a887 1
	return(ROFF_IGN);
d1062 1
a1062 1
	    (ROFF_ccond == t || ROFFRULE_ALLOW == rr ||
d1088 1
a1088 3
		roff_ccond(r, ROFF_ccond, bufp, szp, 
				ln, pos, pos + 2, offs);
		break;
d1109 1
a1109 2
		roff_ccond(r, ROFF_ccond, bufp, szp, 
				ln, pos, pos + 2, offs);
@


1.66
log
@Implement the roff(7) .as request (append to user-defined string).
Missing feature found by jca@@ in ratpoison(1).
The ratpoison(1) manual still doesn't work because it uses .shift
and .while, too (apparently, ratpoison is so complex that it
needs a Turing-complete language to even format its manual :-).

Written at Christchurch International Airport.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.65 2014/02/14 22:27:32 schwarze Exp $ */
d41 1
d236 1
@


1.65
log
@Handle some predefined read-only number registers, e.g. .H and .V.
In particular, this improves handling of the pod2man(1) preamble;
for examples of the effect, see some author names in perlthrtut(1).

Missing feature reported by Andreas Voegele <mail at andreasvoegele dot com>
more than two years ago.  Written at Christchurch International Airport.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.64 2014/01/06 23:46:01 schwarze Exp $ */
d39 1
d233 1
d940 1
a940 1
	 * added from roff_block_text() in multiline mode.
d1030 1
a1030 1
			roff_setstr(r, r->last->name, *bufp + ppos, 1);
d1046 1
a1046 1
		roff_setstr(r, r->last->name, *bufp + pos, 1);
d1349 1
a1349 1
	roff_setstr(r, name, string, 0);
a1848 2
 * In multiline mode, append to an existing entry and append '\n';
 * else replace the existing entry, if there is one.
d1850 3
d1856 1
a1856 1
	int multiline)
d1860 1
a1860 1
			string ? strlen(string) : 0, multiline);
d1865 1
a1865 1
		const char *string, size_t stringsz, int multiline)
d1887 1
a1887 2
	} else if (0 == multiline) {
		/* In multiline mode, append; else replace. */
d1900 1
a1900 1
	newch = stringsz + (multiline ? 2u : 1u);
d1927 1
a1927 1
	if (multiline)
@


1.64
log
@Gprof(1) is fun.  You should use it more often.

Another 10% speedup for mandocdb(8) -Q, and even 3% without -Q.
With -Q, we are now at 41% of the time required by makewhatis(8).

Do not copy predefined strings into the dynamic string table, just
leave them in their own static table and use that one as a fallback
at lookup time.  This saves us copying and deleting them for each manual.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.63 2014/01/06 21:33:00 schwarze Exp $ */
d191 1
d1380 28
d1412 7
d1431 7
@


1.63
log
@Another 25% speedup for mandocdb(8) -Q mode, found with gprof(1).
For /usr/share/man, we only need 56% of the time of makewhatis(8) now.

In groff, user-defined macros clashing with mdoc(7) or man(7)
standard macros are cleared when parsing the .Dd or .TH macro,
respectively.  Of course, we continue doing that in standard mode
to assure full groff bug compatibility.

However, in -Q mode, full groff bug compatibility makes no sense
when it's unreasonably expensive, so skip this step in -Q mode.
Real-world manuals hardly ever redefine standard macros,
that's terrible style, and if they do, it's pointless to do so
before .Dd or .TH because it has no effect.  Even if someone does,
it's extremely unlikely to break mandocdb(8) -Q parsing because we
abort the parse sequence after the NAME section, anyway.

So if you manually redefine .Sh, .Nm, .Nd, or .SH in a way that doesn't
work at all and rely on .Dd or .TH to fix it up for you, your broken
manual will no longer get a perfect apropos(1) entry until you re-run
mandocdb(8) without -Q.  It think that consequence is acceptable
in order to get a 25% speedup for everyone else.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.62 2013/12/30 18:42:55 schwarze Exp $ */
a446 1
	int		 i;
a448 1

a449 3

	for (i = 0; i < PREDEFS_MAX; i++) 
		roff_setstr(r, predefs[i].name, predefs[i].str, 0);
a465 1
	int		 i;
a474 3
	for (i = 0; i < PREDEFS_MAX; i++) 
		roff_setstr(r, predefs[i].name, predefs[i].str, 0);

d1893 1
d1899 5
@


1.62
log
@Oops, missed one:
Remove duplicate const specifier from a call to mandoc_escape().
Found by Thomas Klausner <wiz at NetBSD dot org> using clang.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.61 2013/12/25 00:50:03 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d108 1
d468 1
a468 1
roff_alloc(enum mparset type, struct mparse *parse)
d476 1
d1498 1
a1498 1
	if (MPARSE_MDOC != r->parsetype)
d1511 1
a1511 1
	if (MPARSE_MDOC != r->parsetype)
@


1.61
log
@s/[Nn]ull/NUL/ in comments where appropriate;
suggested by Thomas Klausner <wiz @@ NetBSD dot org>.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.60 2013/12/15 21:18:00 schwarze Exp $ */
d645 1
a645 2
			esc = mandoc_escape
				((const char const **)&p, NULL, NULL);
@


1.60
log
@The "value" argument to the roff(7) .nr requests ends right before
the first non-digit character.  While here, implement and document
an optional sign, requesting increment or decrement, as documented
in the Ossanna/Kernighan/Ritter troff manual and supported by groff.

Reported by bentley@@ on discuss at mdocml.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.59 2013/10/22 20:37:54 schwarze Exp $ */
d1732 1
a1732 1
	 * and null-terminate them.
@


1.59
log
@Parse and ignore .hw (hyphenation points in words); this is safe because
we don't do hyphenation anyway, so there is no point in throwing an ERROR
when encountering .hw.
Real-world usage of the request found by naddy@@ in sysutils/dwdiff(1).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.58 2013/10/14 01:42:26 schwarze Exp $ */
d1359 1
a1359 1
roff_setreg(struct roff *r, const char *name, int val)
d1374 1
d1379 6
a1384 1
	reg->val = val;
d1431 1
d1433 1
d1438 6
a1443 1
	iv = mandoc_strntoi(val, strlen(val), 10);
d1445 1
a1445 1
	roff_setreg(r, key, iv);
@


1.58
log
@Parse and ignore the .fam (font family) request.
Fixes irunner(1) in devel/ipython and uim-xim(1) in inputmethods/uim.
Thanks to naddy@@ for bringing these to my attention.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.57 2013/10/05 21:17:29 schwarze Exp $ */
d46 1
d237 1
@


1.57
log
@Cleanup suggested by gcc-4.8.1, following hints by Christos Zoulas:
- avoid bad qualifier casting in roff.c, roff_parsetext()
  by changing the mandoc_escape arguments to "const char const **"
- avoid bad qualifier casting in mandocdb.c, index_merge()
- garbage collect a few unused variables elsewhere
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.56 2013/10/04 02:01:58 schwarze Exp $ */
d45 1
d235 1
@


1.56
log
@Support simple numerical conditions.

Original code from Christos Zoulas, NetBSD rev. 1.11-1.13, April 3, 2013.

I tweaked the code as follows:
* In roff_getnum(), don't skip a minus that isn't followed by a digit.
* In roff_getop(), do not handle "!=", groff doesn't support it either.
* In roff_evalcond(), treat negative numbers as false, like groff.
Besides, make the interfaces of roff_getnum() and roff_getop() more
similar to each other and simplify parts of the code a bit.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.55 2013/10/03 22:56:18 schwarze Exp $ */
d642 1
a642 1
				((const char **)&p, NULL, NULL);
@


1.55
log
@ROFFRULE_ALLOW = 0, ROFFRULE_DENY = 1 was confusing, so exchange the
two entries in enum roffrule; no functional change.
From Christos Zoulas, NetBSD rev. 1.11, April 4, 2013.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.54 2013/10/03 22:50:02 schwarze Exp $ */
d184 2
d1126 50
d1179 2
d1193 4
d1198 1
d1202 32
a1233 3
	while (v[*pos] && ' ' != v[*pos])
		(*pos)++;
	return(ROFFRULE_DENY);
@


1.54
log
@Avoid code duplication in roff_parseln() as suggested by
Christos Zoulas in NetBSD rev. 1.11;
i'm even going a step further and making this yet a bit shorter.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.53 2013/10/03 22:04:08 schwarze Exp $ */
d73 2
a74 2
	ROFFRULE_ALLOW,
	ROFFRULE_DENY
@


1.53
log
@Expand references to number registers in exactly the same way as
references to user-defined strings.  While here, make number registers
signed int, like in groff.

Inspired by NetBSD roff.c rev. 1.8 and read.c rev. 1.7
written by Christos Zoulas on March 21, 2013, but implemented
in a completely different way, without hacking into read.c,
where this functionality really doesn't belong.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.52 2013/10/03 19:32:25 schwarze Exp $ */
d711 4
a714 2
		if (r->eqn)
			return(eqn_read(&r->eqn, ln, *bufp, pos, offs));
d718 1
a718 8
	} else if ( ! ctl) {
		if (r->eqn)
			return(eqn_read(&r->eqn, ln, *bufp, pos, offs));
		if (r->tbl)
			return(tbl_read(r->tbl, ln, *bufp, pos));
		return(roff_parsetext(bufp, szp, pos, offs));
	} else if (r->eqn)
		return(eqn_read(&r->eqn, ln, *bufp, ppos, offs));
@


1.52
log
@Support setting arbitrary roff(7) number registers,
preserving read support for the ".nr nS" SYNOPSIS state register;
read support for arbitrary registers is still not available.

Inspired by NetBSD roff.c rev. 1.18 (Christos Zoulas, March 21, 2013),
but implemented differently.  I don't want to have yet another different
implementation of a hash table in mandoc - it would be the second one
in roff.c alone and the fifth one in mandoc grand total.
Instead, i designed and implemented roff_setreg() and roff_getreg()
to be similar to roff_setstrn() and roff_getstrn().

Once we feel the need to optimize, we can introduce one common
hash table implementation for everything in mandoc.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.51 2013/07/13 12:51:38 schwarze Exp $ */
a95 1
 * Registers are assumed to be unsigned ints for now.
d99 1
a99 1
	unsigned int	 u;
d184 2
d480 3
a482 4
 * Pre-filter each and every line for reserved words (one beginning with
 * `\*', e.g., `\*(ab').  These must be handled before the actual line
 * is processed. 
 * This also checks the syntax of regular escapes.
d487 1
a487 1
	enum mandoc_esc	 esc;
d492 5
a496 3
	int		 i, maxl, expand_count;
	size_t		 nsz;
	char		*n;
d506 1
a506 1
		 * The second character must be an asterisk.
d514 9
a522 4
		if ('*' != *cp) {
			res = cp;
			esc = mandoc_escape(&cp, NULL, NULL);
			if (ESCAPE_ERROR != esc)
a523 1
			cp = res;
d534 1
a534 1
		 * of the name of the string.
d557 1
a557 1
		for (i = 0; 0 == maxl || i < maxl; i++, cp++) {
d574 5
a578 1
		res = roff_getstrn(r, stnam, (size_t)i);
d592 1
a592 1
		n = mandoc_malloc(nsz);
d594 3
a596 3
		strlcpy(n, *bufp, (size_t)(stesc - *bufp + 1));
		strlcat(n, res, nsz);
		strlcat(n, cp + (maxl ? 0 : 1), nsz);
d600 1
a600 1
		*bufp = n;
d1272 1
a1272 1
roff_setreg(struct roff *r, const char *name, unsigned int val)
d1291 1
a1291 1
	reg->u = val;
d1294 1
a1294 1
unsigned int
d1301 14
a1314 1
			return(reg->u);
a1343 2
	if (0 > iv)
		iv = 0;
d1345 1
a1345 1
	roff_setreg(r, key, (unsigned)iv);
@


1.51
log
@Rudimentary implementation of the .it request (input line trap).
As with any low-level roff request involving subtle interactions
with macro internals, this implementation is not exact, but it
does handle the simplest cases.

This request occurs in man(7) code generated from DocBook,
for example mysql(1) and yasm_arch(7).
Thanks to brad@@ for reporting the issue back in January 2011.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.50 2013/06/27 09:48:22 schwarze Exp $ */
a77 10
 * A single register entity.  If "set" is zero, the value of the
 * register should be the default one, which is per-register.
 * Registers are assumed to be unsigned ints for now.
 */
struct	reg {
	int		 set; /* whether set or not */
	unsigned int	 u; /* unsigned integer */
};

/*
d94 10
d111 1
a111 1
	struct reg	 regs[REG__MAX];
d182 1
d424 4
a443 1
	memset(&r->regs, 0, sizeof(struct reg) * REG__MAX);
d1261 2
a1262 2
int
roff_regisset(const struct roff *r, enum regs reg)
d1264 7
d1272 10
a1281 1
	return(r->regs[(int)reg].set);
d1285 1
a1285 1
roff_regget(const struct roff *r, enum regs reg)
d1287 5
d1293 1
a1293 1
	return(r->regs[(int)reg].u);
d1296 2
a1297 2
void
roff_regunset(struct roff *r, enum regs reg)
d1299 1
d1301 6
a1306 1
	r->regs[(int)reg].set = 0;
d1320 5
a1324 7
	if (0 == strcmp(key, "nS")) {
		r->regs[(int)REG_nS].set = 1;
		if ((iv = mandoc_strntoi(val, strlen(val), 10)) >= 0)
			r->regs[(int)REG_nS].u = (unsigned)iv;
		else
			r->regs[(int)REG_nS].u = 0u;
	}
@


1.50
log
@Parse for the closing delimiter `\}' for conditionals
even when the conditional evaluated to false.

While here, reshuffle the code to reduce indentation and make it
more readable; that way, we can even trim down the comments because
it becomes obvious what the code does.

Found in zipinfo(1) - thanks to espie@@ and naddy@@
for making me look at that manual page.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.49 2013/05/31 22:08:03 schwarze Exp $ */
d20 1
d186 1
d192 1
a192 1
static	enum rofferr	 roff_parsetext(char *);
d234 1
a234 1
	{ "it", roff_line_ignore, NULL, NULL, 0, NULL },
d296 3
d600 3
a602 1
 * Process text streams: convert all breakable hyphens into ASCII_HYPH.
d605 1
a605 1
roff_parsetext(char *p)
d609 2
d613 1
a613 1
	start = p;
d641 16
d701 1
a701 1
		return(roff_parsetext(*bufp + pos));
d707 1
a707 1
		return(roff_parsetext(*bufp + pos));
a1143 3
	if (ROFF_it == tok)
		mandoc_msg(MANDOCERR_REQUEST, r->parse, ln, ppos, "it");

d1313 25
@


1.49
log
@More cleanup: Consistently use the name "struct tbl_node *tbl"
that is already used almost everywhere instead of gratuitiously
inventing different names at four places.  No functional change.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.48 2012/07/07 18:27:36 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d1027 1
d1030 2
a1031 4
	 * If the macro is unknown, first check if it contains a closing
	 * delimiter `\}'.  If it does, close out our scope and return
	 * the currently-scoped rule (ignore or continue).  Else, drop
	 * into the currently-scoped rule.
d1034 7
a1040 6
	if (ROFF_MAX == (t = roff_parse(r, *bufp, &pos))) {
		ep = &(*bufp)[pos];
		for ( ; NULL != (ep = strchr(ep, '\\')); ep++) {
			ep++;
			if ('}' != *ep)
				continue;
d1042 1
a1042 14
			/*
			 * Make the \} go away.
			 * This is a little haphazard, as it's not quite
			 * clear how nroff does this.
			 * If we're at the end of line, then just chop
			 * off the \} and resize the buffer.
			 * If we aren't, then conver it to spaces.
			 */

			if ('\0' == *(ep + 1)) {
				*--ep = '\0';
				*szp -= 2;
			} else
				*(ep - 1) = *ep = ' ';
d1044 4
a1047 6
			roff_ccond(r, ROFF_ccond, bufp, szp, 
					ln, pos, pos + 2, offs);
			break;
		}
		return(ROFFRULE_DENY == rr ? ROFF_IGN : ROFF_CONT);
	}
d1049 5
a1053 5
	/*
	 * A denied conditional must evaluate its children if and only
	 * if they're either structurally required (such as loops and
	 * conditionals) or a closing macro.
	 */
d1055 5
a1059 4
	if (ROFFRULE_DENY == rr)
		if ( ! (ROFFMAC_STRUCT & roffs[t].flags))
			if (ROFF_ccond != t)
				return(ROFF_IGN);
d1061 5
a1065 3
	assert(roffs[t].proc);
	return((*roffs[t].proc)(r, t, bufp, szp, 
				ln, ppos, pos, offs));
@


1.48
log
@Support the .cc request; code by kristaps@@, tests by me.
Needed for sqlite3(1) as reported by espie@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.47 2012/06/02 23:18:30 schwarze Exp $ */
d392 1
a392 1
	struct tbl_node	*t;
d396 3
a398 3
	while (NULL != (t = r->first_tbl)) {
		r->first_tbl = t->next;
		tbl_free(t);
d1412 1
a1412 1
	struct tbl_node	*t;
d1419 1
a1419 1
	t = tbl_alloc(ppos, ln, r->parse);
d1422 1
a1422 1
		r->last_tbl->next = t;
d1424 1
a1424 1
		r->first_tbl = r->last_tbl = t;
d1426 1
a1426 1
	r->tbl = r->last_tbl = t;
@


1.47
log
@In groff, trying to redefine standard man(7) macros before .TH has no effect;
after .TH, it works.  Trying to redefine standard mdoc(7) macros before .Dd
works when calling groff with the -mdoc command line option, but does not
when calling groff with -mandoc; after .Dd, it always works.

Arguably, one might call that buggy behaviour in groff, but it is very
unlikely that anybody will change groff in this respect (certainly, i'm
not volunteering).  So let's be bug-compatible.

This fixes the vertical spacing in sox(1).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.46 2012/05/31 01:36:56 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
d38 1
d108 1
d173 1
d222 1
d433 1
d654 1
a654 1
	ctl = mandoc_getcontrol(*bufp, &pos);
d1432 17
d1842 35
@


1.46
log
@Fix blank line handling in .if.

In particular, two cases were wrong:
 - single-line .if with trailing whitespace gave no blank line
 - multiline .if with \{ but without \{\ gave no blank line

While here, simplify roff_cond() by partially reordering the code.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.45 2011/10/24 21:38:56 schwarze Exp $ */
d57 2
d103 1
d197 2
d238 2
d250 31
d446 1
a446 1
roff_alloc(struct mparse *parse)
d452 1
d1299 26
@


1.45
log
@Handle infinite recursion the same way as groff:
When string expansion exceeds the recursion limit, drop the whole
input line, instead of leaving just the string unexpanded.

This fixes src/regress/usr.bin/mandoc/roff/string/infinite.in.

ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.44 2011/09/19 07:53:54 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011 Ingo Schwarze <schwarze@@openbsd.org>
d777 1
a777 1
		if (--r->last->endspan < 0)
d1097 2
a1098 2
	int		 sv;
	enum roffrule	 rule;
d1108 1
a1108 1
	rule = ROFF_el == tok ?
a1112 20
	sv = pos;
	while (' ' == (*bufp)[pos])
		pos++;

	/*
	 * Roff is weird.  If we have just white-space after the
	 * conditional, it's considered the BODY and we exit without
	 * really doing anything.  Warn about this.  It's probably
	 * wrong.
	 */

	if ('\0' == (*bufp)[pos] && sv != pos) {
		mandoc_msg(MANDOCERR_NOARGS, r->parse, ln, ppos, NULL);
		return(ROFF_IGN);
	}

	roffnode_push(r, tok, NULL, ln, ppos);

	r->last->rule = rule;

d1135 3
a1137 3
	 * Determine scope.  If we're invoked with "\{" trailing the
	 * conditional, then we're in a multiline scope.  Else our scope
	 * expires on the next line.
d1140 9
a1148 1
	r->last->endspan = 1;
d1153 1
d1157 3
a1159 2
	 * If there are no arguments on the line, the next-line scope is
	 * assumed.
d1163 1
a1163 1
		return(ROFF_IGN);
d1165 1
a1165 1
	/* Otherwise re-run the roff parser after recalculating. */
d1167 1
@


1.44
log
@Breaking the line at a hyphen is only allowed if the hyphen
is both preceded and followed by an alphabetic character.
This fixes about a dozen places in base.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.43 2011/09/18 23:26:18 schwarze Exp $ */
d185 1
a185 1
static	void		 roff_res(struct roff *, 
d431 1
a431 1
static void
d457 1
a457 1
			return;
d468 1
a468 1
			return;
d481 1
a481 1
			return;
d504 1
a504 1
				return;
d545 1
a545 1
		return;
d547 1
d604 4
a607 1
	roff_res(r, bufp, szp, ln, pos);
@


1.43
log
@Fix another regression introduced in 1.11.7:
If a string is defined in terms of itself, the REPARSE_LIMIT in read.c
used to break the cycle.  This no longer works since all the work
is now done in the function roff_res(), looping indefinitely.

Make this loop finite by arbitrarily limiting the number of times one
string may be expanded; when that limit is reached, leave the remaining
string references unexpanded.

This changes behaviour compared to 1.11.5, where the whole line would
have been dropped.  The new behaviour is better because it loses less
information.  We don't want to imitate groff-1.20.1 behaviour anyway
because groff aborts parsing of the whole file.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.42 2011/09/18 15:54:48 schwarze Exp $ */
a554 1
	char		 l, r;
d581 2
a582 8
		l = *(p - 1);
		r = *(p + 1);
		if ('\\' != l &&
				'\t' != r && '\t' != l &&
				' ' != r && ' ' != l &&
				'-' != r && '-' != l &&
				! isdigit((unsigned char)l) &&
				! isdigit((unsigned char)r))
@


1.42
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.41 2011/09/18 10:25:28 schwarze Exp $ */
d30 3
d439 1
a439 1
	int		 i, maxl;
d443 2
d539 7
a545 1
		goto again;
@


1.41
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.40 2011/07/31 14:11:48 schwarze Exp $ */
d76 2
a77 2
	int		  set; /* whether set or not */
	unsigned int	  u; /* unsigned integer */
d80 3
d84 11
a94 3
	char		*name; /* key of symbol */
	char		*string; /* current value */
	struct roffstr	*next; /* next in list */
d103 3
a105 1
	struct roffstr	*first_string; /* user-defined strings & macros */
d155 6
d171 2
a172 1
static	void		 roff_freestr(struct roff *);
d180 3
a182 1
static	int		 roff_res(struct roff *, 
d187 2
d190 1
d198 1
a198 1
/* See roff_hash_find() */
d229 1
a229 1
	{ "tr", roff_line_ignore, NULL, NULL, 0, NULL },
d246 1
a246 10
static	void		 roff_free1(struct roff *);
static	enum rofft	 roff_hash_find(const char *, size_t);
static	void		 roff_hash_init(void);
static	void		 roffnode_cleanscope(struct roff *);
static	void		 roffnode_push(struct roff *, enum rofft,
				const char *, int, int);
static	void		 roffnode_pop(struct roff *);
static	enum rofft	 roff_parse(struct roff *, const char *, int *);

/* See roff_hash_find() */
d250 1
a250 1
roff_hash_init(void)
d275 1
a275 1
roff_hash_find(const char *p, size_t s)
d349 1
d368 11
a378 1
	roff_freestr(r);
a380 1

d414 1
a414 1
	roff_hash_init();
a421 1

d426 1
d428 1
a428 1
static int
d431 1
d440 1
a440 2
	/* Search for a leading backslash and save a pointer to it. */

d452 15
a466 3
			return(1);
		if ('*' != *cp++)
			continue;
d476 1
a476 1
			return(1);
d494 7
a500 2
			if ('\0' == *cp)
				return(1); /* Error. */
d513 3
a515 2
			/* TODO: keep track of the correct position. */
			mandoc_msg(MANDOCERR_BADESCAPE, r->parse, ln, pos, NULL);
d521 2
d534 47
a580 1
		return(0);
d583 1
a583 1
	return(1);
a585 1

d599 1
a599 2
	if (r->first_string && ! roff_res(r, bufp, szp, ln, pos))
		return(ROFF_REPARSE);
d624 1
a624 1
		return(ROFF_CONT);
d630 1
a630 1
		return(ROFF_CONT);
d710 1
a710 1
	    ? ROFF_USERDEF : roff_hash_find(mac, maclen);
d1363 65
d1549 13
a1561 9
	struct roffstr	 *n;
	char		 *c;
	size_t		  oldch, newch;

	/* XXX workaround for the Perl preamble until we get .tr */
	if ( ! strcmp(name, "--")) {
		string = "--";
		multiline = 0;
	}
d1564 3
a1566 2
	n = r->first_string;
	while (n && strcmp(name, n->name))
d1571 7
a1577 5
		n = mandoc_malloc(sizeof(struct roffstr));
		n->name = mandoc_strdup(name);
		n->string = NULL;
		n->next = r->first_string;
		r->first_string = n;
d1580 3
a1582 2
		free(n->string);
		n->string = NULL;
d1592 5
a1596 4
	newch = strlen(string) + (multiline ? 2u : 1u);
	if (NULL == n->string) {
		n->string = mandoc_malloc(newch);
		*n->string = '\0';
d1599 2
a1600 2
		oldch = strlen(n->string);
		n->string = mandoc_realloc(n->string, oldch + newch);
d1604 1
a1604 1
	c = n->string + (int)oldch;
d1607 2
a1608 1
	while (*string) {
d1613 3
a1615 3
		if ('\\' == *string && '\\' == *(string + 1))
			string++;
		*c++ = *string++;
d1621 1
d1623 1
d1629 1
a1629 1
	const struct roffstr *n;
d1631 4
a1634 3
	n = r->first_string;
	while (n && (strncmp(name, n->name, len) || '\0' != n->name[(int)len]))
		n = n->next;
d1636 1
a1636 1
	return(n ? n->string : NULL);
d1640 1
a1640 1
roff_freestr(struct roff *r)
d1642 1
a1642 1
	struct roffstr	 *n, *nn;
d1644 3
a1646 3
	for (n = r->first_string; n; n = nn) {
		free(n->name);
		free(n->string);
a1649 2

	r->first_string = NULL;
d1664 92
@


1.40
log
@Workaround to prevent misrendering of \*(-- as "O-" in pod2man(1)-
generated manuals; this fixes more than 500 manuals in base alone.
As a real fix, .tr will be supported after unlock.
OK kristaps@@  to put in the workaround for now
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.39 2011/07/07 20:07:38 schwarze Exp $ */
d70 10
d91 1
a91 1
	struct regset	*regs; /* read/writable registers */
d158 2
d362 2
d379 1
a379 1
roff_alloc(struct regset *regs, struct mparse *parse)
a384 1
	r->regs = regs;
d531 1
a531 1
			return(eqn_read(&r->eqn, ln, *bufp, pos));
d537 1
a537 1
			return(eqn_read(&r->eqn, ln, *bufp, pos));
d542 1
a542 1
		return(eqn_read(&r->eqn, ln, *bufp, ppos));
d584 2
a585 3
				r->eqn->eqn.line, r->eqn->eqn.pos, NULL);
		eqn_end(r->eqn);
		r->eqn = NULL;
d591 1
a591 2
		tbl_end(r->tbl);
		r->tbl = NULL;
d1114 20
a1141 1
	struct reg	*rg;
a1144 1
	rg = r->regs->regs;
d1147 3
a1149 3
		rg[(int)REG_nS].set = 1;
		if ((iv = mandoc_strntou(val, strlen(val), 10)) >= 0)
			rg[REG_nS].v.u = (unsigned)iv;
d1151 1
a1151 1
			rg[(int)REG_nS].v.u = 0u;
d1181 1
a1181 1
		tbl_end(r->tbl);
a1182 1
	r->tbl = NULL;
d1199 12
a1210 3
/* ARGSUSED */
static enum rofferr
roff_EQ(ROFF_ARGS)
d1212 2
a1213 1
	struct eqn_node	*e;
d1216 1
a1216 1
	e = eqn_alloc(ppos, ln);
d1224 13
d1257 1
a1257 1
		tbl_end(r->tbl);
@


1.39
log
@Fix a bogus "unknown macro" error reported in the pod2man(1) preamble:
- Actually let roff_parse() recognize ".\}" as a cond block end request.
- Do not rewrite "\}" to the zero-width space "\&" because that prevents
recognition of immediately preceding macros; use normal blanks instead.
- To avoid a vertical spacing regression in pod2man(1) manuals,
drop one vertical spacing request just before NAME.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.38 2011/07/05 04:12:41 schwarze Exp $ */
d1346 6
@


1.38
log
@Sync to bsd.lv (all coded by kristaps@@):
 - mdoc(7): fix an assertion if the first line after .Bd -column
   starts with a blank, and some simplifications in mdoc_argv.c
 - man(7): literal mode ends at .SH and .SS (bug reported by naddy@@)
 - allow .RS/.RE blocks to nest (bug reported by dcoppa@@ and gsoares@@)
 - improve vertical spacing of man(7) blocks
 - roff(7): clear user-defined strings when starting a new file
 - correct ID tags in -T[x]html
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.37 2011/05/29 21:22:18 schwarze Exp $ */
d595 2
a596 1
	if ('\0' == buf[*pos] || '"' == buf[*pos])
d599 6
d606 1
a606 1
	maclen = strcspn(mac, " \\\t\0");
d888 16
a903 1
			*ep = '&';
@


1.37
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.36 2011/04/24 16:28:48 schwarze Exp $ */
d346 1
d349 3
@


1.36
log
@User defined macros may invoke high-level macros.
The latter got lost due to a regression in bsd.lv rev. 1.130.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.35 2011/04/24 16:22:02 schwarze Exp $ */
a18 1
#include <errno.h>
a19 1
#include <limits.h>
a21 1
#include <stdio.h>
d27 1
d60 1
a60 1
	ROFF_ccond, /* FIXME: remove this. */
d124 8
d149 1
a149 1
				char **, size_t *, int);
d203 6
a216 1
static	int		 roff_parse_nat(const char *, unsigned int *);
a241 1

d364 1
d372 4
d386 1
a386 1
roff_res(struct roff *r, char **bufp, size_t *szp, int pos)
d453 3
a455 2
			cp -= maxl ? 1 : 0;
			continue;
d491 1
a491 1
	if (r->first_string && ! roff_res(r, bufp, szp, pos))
a607 21

static int
roff_parse_nat(const char *buf, unsigned int *res)
{
	char		*ep;
	long		 lval;

	errno = 0;
	lval = strtol(buf, &ep, 10);
	if (buf[0] == '\0' || *ep != '\0')
		return(0);
	if ((errno == ERANGE && 
			(lval == LONG_MAX || lval == LONG_MIN)) ||
			(lval > INT_MAX || lval < 0))
		return(0);

	*res = (unsigned int)lval;
	return(1);
}


d859 1
d862 1
d864 5
a868 3
	/* 
	 * Clean out scope.  If we've closed ourselves, then don't
	 * continue. 
a870 2
	roffnode_cleanscope(r);

d872 10
a881 4
		if ('\\' == (*bufp)[pos] && '}' == (*bufp)[pos + 1])
			return(roff_ccond
				(r, ROFF_ccond, bufp, szp,
				 ln, pos, pos + 2, offs));
d890 1
a900 1

d905 1
a905 1
	char		*ep, *st;
d909 1
d911 8
a918 11
	/*
	 * We display the value of the text if out current evaluation
	 * scope permits us to do so.
	 */

	/* FIXME: use roff_ccond? */

	st = &(*bufp)[pos];
	if (NULL == (ep = strstr(st, "\\}"))) {
		roffnode_cleanscope(r);
		return(ROFFRULE_DENY == rr ? ROFF_IGN : ROFF_CONT);
a919 5

	if (ep == st || (ep > st && '\\' != *(ep - 1)))
		roffnode_pop(r);

	roffnode_cleanscope(r);
a922 1

d1084 1
d1093 4
a1096 2
		if ( ! roff_parse_nat(val, &rg[(int)REG_nS].v.u))
			rg[(int)REG_nS].v.u = 0;
@


1.35
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.34 2011/04/21 22:59:54 schwarze Exp $ */
d828 1
a828 2
	if (ROFF_MAX == (t = roff_parse(r, *bufp, &pos)))
		return(ROFF_IGN);
@


1.34
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.33 2011/04/05 22:19:11 schwarze Exp $ */
a26 1
#include "roff.h"
a31 3
#define	ROFF_CTL(c) \
	('.' == (c) || '\'' == (c))

d79 1
a80 2
	mandocmsg	 msg; /* err/warn/fatal messages */
	void		*data; /* privdata for messages */
a275 4
	if (ROFF_el == p->tok)
		if (r->rstackpos > -1)
			r->rstackpos--;

d351 1
a351 1
roff_alloc(struct regset *regs, void *data, const mandocmsg msg)
d357 1
a357 2
	r->msg = msg;
	r->data = data;
d468 1
a468 1
	int		 ppos;
d478 3
d489 1
a489 1
	if (r->last && ! ROFF_CTL((*bufp)[pos])) {
d498 1
a498 1
			return(eqn_read(&r->eqn, ln, *bufp, *offs));
d500 1
a500 1
			return(tbl_read(r->tbl, ln, *bufp, *offs));
d502 1
a502 1
	} else if ( ! ROFF_CTL((*bufp)[pos])) {
d504 1
a504 1
			return(eqn_read(&r->eqn, ln, *bufp, *offs));
d506 1
a506 1
			return(tbl_read(r->tbl, ln, *bufp, *offs));
d509 1
a509 1
		return(eqn_read(&r->eqn, ln, *bufp, *offs));
d522 1
a522 1
				 ln, pos, pos, offs));
a530 1
	ppos = pos;
d546 1
a546 1
		(*r->msg)(MANDOCERR_SCOPEEXIT, r->data,
d550 1
a550 1
		(*r->msg)(MANDOCERR_SCOPEEXIT, r->data, 
d557 1
a557 1
		(*r->msg)(MANDOCERR_SCOPEEXIT, r->data, 
a563 1

d575 1
a575 7
	assert(ROFF_CTL(buf[*pos]));
	(*pos)++;

	while (' ' == buf[*pos] || '\t' == buf[*pos])
		(*pos)++;

	if ('\0' == buf[*pos])
d585 1
d624 1
a624 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d643 1
a643 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d648 1
a648 1
		(*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, pos, NULL);
d675 1
a675 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d687 1
a687 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d692 1
a692 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d697 1
a697 1
		(*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, pos, NULL);
d717 1
a717 1
			(*r->msg)(MANDOCERR_NOARGS, r->data, ln, ppos, NULL);
d731 1
a731 1
			(*r->msg)(MANDOCERR_REQUEST, r->data, ln, ppos,
d779 1
a779 1
		(*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, pos, NULL);
d802 1
a802 5
		i = pos + 1;
		while (' ' == (*bufp)[i] || '\t' == (*bufp)[i])
			i++;

		for (j = 0; r->last->end[j]; j++, i++)
d813 4
d828 2
a829 2
	ppos = pos;
	t = roff_parse(r, *bufp, &pos);
a865 1
	ppos = pos;
d959 1
a959 1
		(*r->msg)(MANDOCERR_REQUEST, r->data, ln, ppos, "it");
d971 7
a977 6
	/* Stack overflow! */

	if (ROFF_ie == tok && r->rstackpos == RSTACK_MAX - 1) {
		(*r->msg)(MANDOCERR_MEM, r->data, ln, ppos, NULL);
		return(ROFF_ERR);
	}
d979 4
a982 13
	/* First, evaluate the conditional. */

	if (ROFF_el == tok) {
		/* 
		 * An `.el' will get the value of the current rstack
		 * entry set in prior `ie' calls or defaults to DENY.
	 	 */
		if (r->rstackpos < 0)
			rule = ROFFRULE_DENY;
		else
			rule = r->rstack[r->rstackpos];
	} else
		rule = roff_evalcond(*bufp, &pos);
a984 1

d996 1
a996 1
		(*r->msg)(MANDOCERR_NOARGS, r->data, ln, ppos, NULL);
d1004 5
d1010 8
a1017 9
		/*
		 * An if-else will put the NEGATION of the current
		 * evaluated conditional into the stack.
		 */
		r->rstackpos++;
		if (ROFFRULE_DENY == r->last->rule)
			r->rstack[r->rstackpos] = ROFFRULE_ALLOW;
		else
			r->rstack[r->rstackpos] = ROFFRULE_DENY;
d1127 1
a1127 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d1141 1
a1141 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d1171 1
a1171 1
	(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d1182 1
a1182 1
		(*r->msg)(MANDOCERR_SCOPEBROKEN, r->data, ln, ppos, NULL);
d1186 1
a1186 1
	t = tbl_alloc(ppos, ln, r->data, r->msg);
d1203 1
a1203 1
	(*r->msg)(MANDOCERR_SO, r->data, ln, ppos, NULL);
d1214 1
a1214 1
		(*r->msg)(MANDOCERR_SOPATH, r->data, ln, pos, NULL);
d1237 1
a1237 1
		    mandoc_getarg(&cp, r->msg, r->data, ln, &pos);
d1293 1
a1293 1
		(*r->msg)(MANDOCERR_NAMESC, r->data, ln, pos, NULL);
@


1.33
log
@On .de macro lines, after the new macro name, space and tab are equivalent.
Bug reported by Tristan dot LeGuern at gmail dot com in fvwm(1).
tweaks and ok kristaps@@; earlier version looked good to espie@@ as well
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.32 2011/03/20 23:36:42 schwarze Exp $ */
d599 1
a599 1
	*pos += maclen;
d1134 1
a1134 1
		name = roff_getname(r, &cp, ln, cp - *bufp);
d1369 1
a1369 1
	newch = strlen(string) + (multiline ? 2 : 1);
d1380 1
a1380 1
	c = n->string + oldch;
@


1.32
log
@Import the foundation for eqn(7) support.
Written by kristaps@@.

For now, i'm adding one line to each of the four frontends
to just pass the input text through to the output,
not yet interpreting any of then eqn keywords.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.31 2011/01/25 00:23:23 schwarze Exp $ */
d748 1
a748 1
		while ((*bufp)[pos] && ' ' != (*bufp)[pos])
d751 1
a751 1
		while (' ' == (*bufp)[pos])
d772 1
a772 3
	while ((*bufp)[pos] &&
			' ' != (*bufp)[pos] && 
			'\t' != (*bufp)[pos])
@


1.31
log
@Ignore .ns (no-space mode), .ps (change point size), .ta (tab control)
for now.  All of these just cause a bit too much or too little
whitespace, but no serious formatting problems.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.30 2011/01/20 21:33:11 schwarze Exp $ */
d63 2
d94 3
d155 2
d195 2
d319 1
d321 1
a321 2
	while (r->first_tbl) {
		t = r->first_tbl;
d328 7
d492 2
d502 5
a506 1
		if (ROFF_CONT == e && r->tbl)
d508 1
a508 1
		return(e);
d510 2
d515 2
a516 1
	}
d521 1
d557 7
d1172 27
a1298 1

a1331 1

a1400 1

a1412 1

d1433 7
@


1.30
log
@When finding the roff .it request (line trap),
make it clear that you cannot use mandoc to format that page (yet).
Triggered by a report from brad@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.29 2011/01/12 20:56:40 schwarze Exp $ */
d54 2
d58 1
d179 2
d183 1
@


1.29
log
@Implement the roff .rm request (remove macro).
Using the new roff_getname() function, this is really simple.
Breaks mandoc of the habit of reporting an error in each pod2man(1) preamble.
Reminded by a report from brad@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.28 2011/01/10 23:53:32 schwarze Exp $ */
d50 1
d172 1
d935 3
@


1.28
log
@Refactoring in preparation for .rm support:
Unify parsing of names given as roff request arguments into a new
function roff_getname(), which is rather different from the parsing
function for normal arguments, mandoc_getarg(), because names cannot
be quoted and cannot contain whitespace or escaped characters.
The new function now throws an ERROR when finding escaped characters
in a name.
"I'm fine with this." kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.27 2011/01/04 22:28:17 schwarze Exp $ */
a136 1
static	enum rofferr	 roff_line_error(ROFF_ARGS);
d140 1
d174 1
a174 1
	{ "rm", roff_line_error, NULL, NULL, 0, NULL },
a938 9
roff_line_error(ROFF_ARGS)
{

	(*r->msg)(MANDOCERR_REQUEST, r->data, ln, ppos, roffs[tok].name);
	return(ROFF_IGN);
}

/* ARGSUSED */
static enum rofferr
d1080 16
@


1.27
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.26 2011/01/03 23:19:33 schwarze Exp $ */
d133 1
d1056 2
a1057 1
	name = *bufp + pos;
d1061 2
a1062 15
	string = name;
	/* Read until end of name. */
	while (*string && ' ' != *string)
		string++;

	/* Nil-terminate name. */
	if (*string)
		*(string++) = '\0';
	
	/* Read past spaces. */
	while (*string && ' ' == *string)
		string++;

	/* Read passed initial double-quote. */
	if (*string && '"' == *string)
d1075 2
a1076 1
	const char	*key, *val;
d1079 2
a1080 1
	key = &(*bufp)[pos];
a1082 19
	/* Parse register request. */
	while ((*bufp)[pos] && ' ' != (*bufp)[pos])
		pos++;

	/*
	 * Set our nil terminator.  Because this line is going to be
	 * ignored anyway, we can munge it as we please.
	 */
	if ((*bufp)[pos])
		(*bufp)[pos++] = '\0';

	/* Skip whitespace to register token. */
	while ((*bufp)[pos] && ' ' == (*bufp)[pos])
		pos++;

	val = &(*bufp)[pos];

	/* Process register token. */

d1220 35
@


1.26
log
@Calling a macro with fewer arguments than it is defined with is OK;
the remaining ones default to the empty string, not to NULL.
Regression reported and fix tested by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.25 2011/01/03 22:27:21 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
a17 4
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

d28 1
d56 3
a69 1

d85 3
d143 3
d176 3
d300 9
d312 1
d452 1
d472 9
a480 4
		return((*roffs[t].text)
				(r, t, bufp, szp, 
				 ln, pos, pos, offs));
	} else if ( ! ROFF_CTL((*bufp)[pos]))
d482 1
d514 1
a514 1
int
d518 10
a527 4
	if (NULL == r->last)
		return(1);
	return((*r->msg)(MANDOCERR_SCOPEEXIT, r->data, r->last->line, 
				r->last->col, NULL));
d596 1
a596 2
		if ( ! (*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
d615 1
a615 2
		if ( ! (*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
d620 1
a620 2
		if ( ! (*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, pos, NULL))
			return(ROFF_ERR);
d647 1
a647 2
		if ( ! (*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
d659 1
a659 2
		if ( ! (*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
d664 1
a664 2
		if ( ! (*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
d669 1
a669 2
		if ( ! (*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, pos, NULL))
			return(ROFF_ERR);
d1122 49
d1345 7
@


1.25
log
@Unify roff macro argument parsing (in roff.c, roff_userdef()) and man macro
argument parsing (in man_argv.c, man_args()), both having different bugs,
to use one common macro argument parser (in mandoc.c, mandoc_getarg()),
because from the point of view of roff, man macros are just roff macros,
hence their arguments are parsed in exactly the same way.

While doing so, fix these bugs:
 * Escaped blanks (i.e. those preceded by an odd number of backslashes)
   were mishandled as argument separators in unquoted arguments to
   user-defined roff macros.
 * Unescaped blanks preceded by an even number of backslashes were not
   recognized as argument separators in unquoted arguments to man macros.
 * Escaped backslashes (i.e. pairs of backslashes) were not reduced
   to single backslashes both in unquoted and quoted arguments both
   to user-defined roff macros and to man macros.
 * Escaped quotes (i.e. pairs of quotes inside quoted arguments) were
   not reduced to single quotes in man macros.

OK kristaps@@

Note that mdoc macro argument parsing is yet another beast for no good
reason and is probably afflicted by similar bugs.  But i don't attempt
to fix that right now because it is intricately entangled with lots of
unrelated high-level mdoc(7) functionality, like delimiter handling and
column list phrase handling.  Disentagling that would waste too much
time now.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.24 2010/12/21 01:30:58 schwarze Exp $ */
d1135 1
a1135 1
		arg[i] = '\0' == *cp ? NULL :
@


1.24
log
@Kristaps questioned the efficiency of the algorithm used in roff.c r1.23.
An indeed, this optimization (using suggestions by Joerg Sonnenberger)
saves about 40% of the processing time needed for the roff_res()
function when processing typical manuals.
No functional change, and the new code is not harder to understand.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.23 2010/12/09 20:56:30 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d1127 1
a1127 1
	int		  i, quoted, pairs;
d1134 3
a1136 40
	for (i = 0; i < 9; i++) {
		/* Quoting can only start with a new word. */
		if ('"' == *cp) {
			quoted = 1;
			cp++;
		} else
			quoted = 0;
		arg[i] = cp;
		for (pairs = 0; '\0' != *cp; cp++) {
			/* Unquoted arguments end at blanks. */
			if (0 == quoted) {
				if (' ' == *cp)
					break;
				continue;
			}
			/* After pairs of quotes, move left. */
			if (pairs)
				cp[-pairs] = cp[0];
			/* Pairs of quotes do not end words, ... */
			if ('"' == cp[0] && '"' == cp[1]) {
				pairs++;
				cp++;
				continue;
			}
			/* ... but solitary quotes do. */
			if ('"' != *cp)
				continue;
			if (pairs)
				cp[-pairs] = '\0';
			*cp = ' ';
			break;
		}
		/* Last argument; the remaining ones are empty strings. */
		if ('\0' == *cp)
			continue;
		/* Null-terminate argument and move to the next one. */
		*cp++ = '\0';
		while (' ' == *cp)
			cp++;
	}
@


1.23
log
@Roff only interpolates \* strings when the leading backslash is not escaped.
Kristaps@@ agrees with the idea, even though he didn't review the final patch.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.22 2010/12/07 00:08:52 schwarze Exp $ */
d348 1
a348 1
	/* String escape sequences have at least three characters. */
d350 3
a352 10
	for (cp = *bufp + pos; cp[0] && cp[1] && cp[2]; cp++) {

		/*
		 * The first character must be a backslash.
		 * Save a pointer to it.
		 */

		if ('\\' != *cp)
			continue;
		stesc = cp;
d360 3
a362 1
		if ('*' != *(++cp))
d371 3
a373 1
		switch (*(++cp)) {
@


1.22
log
@Complete the merge of bsd.lv version 1.10.7:
No more functional changes, just sync ordering, comments and white space.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.21 2010/11/28 19:35:33 schwarze Exp $ */
d340 4
a343 1
	const char	*cp, *cpp, *st, *res;
d348 29
a376 4
	/* LINTED */
	for (cp = &(*bufp)[pos]; (cpp = strstr(cp, "\\*")); cp++) {
		cp = cpp + 2;
		switch (*cp) {
d389 1
d391 1
a391 1
		st = cp;
d400 6
a405 1
		res = roff_getstrn(r, st, (size_t)i);
d412 2
d417 1
a417 3
		*n = '\0';

		strlcat(n, *bufp, (size_t)(cpp - *bufp + 1));
d581 1
@


1.21
log
@To avoid FATAL errors, we have been parsing and ignoring the roff
requests .am, .ami, .am1, .dei, and .rm for a long time.
Since ignoring them can (rarely) cause information loss and serious
misformatting, throw an ERROR: NOT IMPLEMENTED when finding them.
Implementing them would not be too difficult, but they are so rare
in practice that i can find better use for my time right now.

In this context,
- Put the string "NOT IMPLEMENTED" into two other error messages
as well, to distinguish them from those caused by broken input.
- Print the string "unknown macro" once, not twice in the error message
associated with MANDOCERR_MACRO, and begin printing the buffer at the
point where the unknown macro really is, not at the start of line.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.20 2010/11/28 01:00:40 schwarze Exp $ */
d636 6
d649 1
d652 1
d664 1
d671 2
d674 2
a675 1
	while ((*bufp)[pos] && ' ' != (*bufp)[pos] && 
d697 1
a697 2
		if ( ! (*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, pos, NULL))
			return(ROFF_ERR);
a871 1

a879 1

a888 1

d930 2
a931 3
		if ((*r->msg)(MANDOCERR_NOARGS, r->data, ln, ppos, NULL))
			return(ROFF_IGN);
		return(ROFF_ERR);
a1063 1

d1072 7
a1087 1

@


1.20
log
@Parse and ignore the .ad, .hy, .nh, and .ne roff requests.
Ignoring these can neither cause information loss nor serious
formatting issues.  As they are frequently used by pod2man(1),
this considerably reduces ERROR noise from mandoc -Tlint
for the Perl manuals.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.19 2010/11/27 20:52:34 schwarze Exp $ */
d133 2
a134 1
static	enum rofferr	 roff_line(ROFF_ARGS);
d152 1
a152 1
	{ "ad", roff_line, NULL, NULL, 0, NULL },
d161 1
a161 1
	{ "hy", roff_line, NULL, NULL, 0, NULL },
d165 2
a166 2
	{ "ne", roff_line, NULL, NULL, 0, NULL },
	{ "nh", roff_line, NULL, NULL, 0, NULL },
d168 1
a168 1
	{ "rm", roff_line, NULL, NULL, 0, NULL },
d170 1
a170 1
	{ "tr", roff_line, NULL, NULL, 0, NULL },
d640 3
d864 1
a864 1
roff_line(ROFF_ARGS)
d867 10
@


1.19
log
@Two related bugfixes:

1) When using a user-defined string of length 0 as a macro,
do not access memory before the start of the string (segfault).

2) When beginning to define a user-defined macro, initialize
the string representing the macro to the empty string,
not to the NULL pointer, such that, in case the macro turns
out to not have any content, like in
.de IX
..
the macro will be defined and empty instead of undefined.

This avoids large numbers of bogus mandoc ERROR messages about
undefined macros (which are actually defined and empty), in
particular in man(7) code generated from pod2man(1), for example
in Perl and OpenSSL.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.18 2010/11/25 23:07:58 schwarze Exp $ */
d40 1
d49 1
d53 2
d151 1
d160 1
d164 2
@


1.18
log
@Make .de1 a symnonym for .de, not .ig as it was before.

The .de1 instructions is a GNU extension not found in traditional roff and
not even in old groff, defined as "define a macro that will be executed with
traditional roff compatibility mode switched off during macro execution".
Since we ran into it in the wild, we have been parsing and ignoring it for
a long time.  Now that we have proper .de support, we can as well use the
contents, even though we don't implement compatibility mode at all.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.17 2010/11/25 22:41:51 schwarze Exp $ */
d645 1
a645 1
		roff_setstr(r, name, NULL, 0);
d1143 1
a1143 1
	return(*szp && '\n' == (*bufp)[(int)*szp - 2] ?
@


1.17
log
@Support quoting of arguments passed to user-defined macros,
such that arguments can contain blank characters.
Also support escaping of quote characters by doubling them.
For example, the argument "a""b c." resolves to: a"b c.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.16 2010/11/25 22:23:31 schwarze Exp $ */
a540 2
	case (ROFF_de1):
		/* FALLTHROUGH */
d627 2
@


1.16
log
@Implement the .de (define macro) roff instruction.
This fixes various Xenocara manuals.
Do not define your own macros in new manuals, though:
this code exists purely to cope with existing and old stuff.

Like in both traditional and GNU roff, the .de and .ds (define string)
roff instructions share the same string table, so one can abuse strings
as macros and vice versa.  This implementation supports multi-line
user-defined macros and user-defined macros taking up to 9 arguments.

Project started near the end of p2k10, now mature for production,
but there is still room for future improvements in various respects.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.15 2010/10/26 23:34:38 schwarze Exp $ */
d1061 1
a1061 1
	int		  i;
d1069 6
d1076 25
a1100 2
		while ('\0' != *cp && ' ' != *cp)
			cp++;
d1103 1
@


1.15
log
@Warn developers that .so is fragile and suggest using ln(1) instead;
throwing a warning here was suggested by Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.14 2010/10/26 22:28:57 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d57 1
d80 2
a81 1
	struct roffstr	*first_string;
d89 1
d134 1
a134 1
				const char *, const char *);
d136 1
a136 1
static	char		*roff_strdup(const char *);
d164 1
d168 1
a168 1
static	enum rofft	 roff_hash_find(const char *);
d171 2
a172 2
static	void		 roffnode_push(struct roff *, 
				enum rofft, int, int);
d174 1
a174 1
static	enum rofft	 roff_parse(const char *, int *);
d186 1
a186 1
	for (i = 0; i < (int)ROFF_MAX; i++) {
d207 1
a207 1
roff_hash_find(const char *p)
d227 1
a227 1
		if (0 == strcmp(n->name, p))
d251 2
a252 2
	if (p->end)
		free(p->end);
d262 2
a263 1
roffnode_push(struct roff *r, enum rofft tok, int line, int col)
d269 2
d402 1
a402 1
		return(ROFF_RERUN);
d439 1
a439 1
	if (ROFF_MAX == (t = roff_parse(*bufp, &pos)))
d465 1
a465 1
roff_parse(const char *buf, int *pos)
d467 2
a468 2
	int		 j;
	char		 mac[5];
d474 1
a474 1
	while (buf[*pos] && (' ' == buf[*pos] || '\t' == buf[*pos]))
d480 2
a481 8
	for (j = 0; j < 4; j++, (*pos)++)
		if ('\0' == (mac[j] = buf[*pos]))
			break;
		else if (' ' == buf[*pos] || (j && '\\' == buf[*pos]))
			break;

	if (j == 4 || j < 1)
		return(ROFF_MAX);
d483 2
a484 4
	mac[j] = '\0';

	if (ROFF_MAX == (t = roff_hash_find(mac)))
		return(t);
d486 1
d620 3
d624 7
a630 5
	if (ROFF_ig != tok && '\0' == (*bufp)[pos]) {
		if ( ! (*r->msg)(MANDOCERR_NOARGS, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
		return(ROFF_IGN);
	} else if (ROFF_ig != tok) {
d634 1
a634 1
			pos++;
d637 9
a645 1
	roffnode_push(r, tok, ln, ppos);
d712 1
a712 1
			if (ROFF_MAX != roff_parse(*bufp, &pos))
d724 1
a724 1
	t = roff_parse(*bufp, &pos);
d726 7
a732 2
	/* If we're not a comment-end, then throw it away. */
	if (ROFF_cblock != t)
d734 1
d747 3
d771 1
a771 1
	if (ROFF_MAX == (t = roff_parse(*bufp, &pos))) {
d905 1
a905 1
	roffnode_push(r, tok, ln, ppos);
d992 1
a992 1
	roff_setstr(r, name, string);
d1055 3
a1057 2
static char *
roff_strdup(const char *name)
d1059 3
a1061 1
	char		*namecopy, *sv;
d1063 18
a1080 3
	/* 
	 * This isn't a nice simple mandoc_strdup() because we must
	 * handle roff's stupid double-escape rule. 
d1082 20
a1101 5
	sv = namecopy = mandoc_malloc(strlen(name) + 1);
	while (*name) {
		if ('\\' == *name && '\\' == *(name + 1))
			name++;
		*namecopy++ = *name++;
d1104 11
a1114 2
	*namecopy = '\0';
	return(sv);
d1117 6
a1122 1

d1124 2
a1125 1
roff_setstr(struct roff *r, const char *name, const char *string)
d1128 2
a1129 1
	char		 *namecopy;
d1131 1
d1137 1
a1137 1
		namecopy = mandoc_strdup(name);
d1139 2
a1140 1
		n->name = namecopy;
d1143 2
a1144 1
	} else
d1146 33
d1180 4
a1183 2
	/* Don't use mandoc_strdup: clean out double-escapes. */
	n->string = string ? roff_strdup(string) : NULL;
@


1.14
log
@Support .so (low-level roff "switch source file"),
needed for Xenocara and various ports.
Accept only relative paths and no ascension to the parent directory
as suggested by Joerg Sonnenberger; code looked over by Joerg, too.
Useful discussions with various people, among others espie@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.13 2010/09/27 21:25:28 schwarze Exp $ */
d1019 2
@


1.13
log
@Merge the last bits of 1.10.6 (released today), most were already in:
* ignore double-.Pp
* ignore .Pp before .Bd and .Bl (unless -compact in specified)
* avoid double blank line upon .Pp, .br and friends in literal context
* cast enums to int when passing them to exit(3) to please lint(1)
While merging, fix a regression introduced by kristaps@@:
Outside literal mode, double blank lines must both be printed.
To achieve this again after kristaps@@ improvements in 1.10.6,
treat such blank lines as .sp (instead of .Pp as in 1.10.5)
and drop .Pp before .sp just like dropping .Pp before .Pp.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.12 2010/09/13 22:04:01 schwarze Exp $ */
d51 1
d53 1
a56 1
	ROFF_nr,
d132 1
d155 1
d157 1
a160 1
	{ "nr", roff_nr, NULL, NULL, 0, NULL },
d1011 17
@


1.12
log
@Parse and ignore the \k, \o, \w, and \z roff escapes, and recursively
ignore embedded escapes and mathematical roff subexpressions.
In roff copy mode, resolve "\\" to '\'.
Allow ".xx\}" where xx is a macro to close roff conditional scope.
Mandoc now handles the special character definitions in the pod2man(1)
preamble, so remove the explicit redefinitions in chars.c/chars.in.
From kristaps@@.

I have checked that this causes no relevant change to the Perl manuals.
The only change introduced is that some non-ASCII characters rendered
incorrectly before are now rendered incorrectly in a different way.
For example, e accent aigu was "e", now is "e'"
and c cedille was "c", now is "c,".
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.11 2010/08/20 00:53:35 schwarze Exp $ */
d54 1
a54 1
	ROFF_ccond,
a734 1
	struct roffnode	*l;
a743 1
	l = r->last;
d783 2
@


1.11
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.10 2010/07/31 21:43:07 schwarze Exp $ */
d131 1
d748 5
a752 4
	if (l != r->last)
		return(ROFFRULE_DENY == rr ? ROFF_IGN : ROFF_CONT);

	if (ROFF_MAX == (t = roff_parse(*bufp, &pos)))
d754 1
d1011 21
d1051 2
a1052 1
	n->string = string ? strdup(string) : NULL;
@


1.10
log
@Merge bsd.lv version 1.10.5: last larger batch of bug fixes before release.
NOT including Kristaps' .Bd -literal changes which cause regressions.
Features:
* -Tpdf now fully working
Bugfixes:
* proper handling of quoted strings by .ds in roff(7)
* allow empty .Dd
* make .Sm start no-spacing after the first output word
* underline .Ad
* minor fixes in -Thtml
and some optimisations in terminal output.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.9 2010/07/25 18:05:54 schwarze Exp $ */
d163 1
a163 1
static	int		 roffnode_push(struct roff *, 
d253 1
a253 1
static int
d258 1
a258 5
	if (NULL == (p = calloc(1, sizeof(struct roffnode)))) {
		(*r->msg)(MANDOCERR_MEM, r->data, line, col, NULL);
		return(0);
	}

a265 1
	return(1);
d297 1
a297 1
roff_alloc(struct regset *regs, const mandocmsg msg, void *data)
d301 1
a301 5
	if (NULL == (r = calloc(1, sizeof(struct roff)))) {
		(*msg)(MANDOCERR_MEM, data, 0, 0, NULL);
		return(0);
	}

d628 1
a628 2
	if ( ! roffnode_push(r, tok, ln, ppos))
		return(ROFF_ERR);
d650 1
a650 6
	r->last->end = malloc(sz + 1);

	if (NULL == r->last->end) {
		(*r->msg)(MANDOCERR_MEM, r->data, ln, pos, NULL);
		return(ROFF_ERR);
	}
d877 1
a877 2
	if ( ! roffnode_push(r, tok, ln, ppos))
		return(ROFF_ERR);
@


1.9
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.8 2010/07/13 01:09:13 schwarze Exp $ */
d946 11
a956 1
	char *name, *string, *end;
d963 1
d966 2
d969 7
a975 1
		*(string++) = NULL;
a977 10
	while (*string && ' ' == *string)
		string++;
	end = string;
	while (*end)
		end++;
	if (string < end) {
		end--;
		if (*end == '"')
			*end = '\0';
	}
d979 1
d1053 1
a1053 1
	while (n && (strncmp(name, n->name, len) || '\0' != n->name[len]))
@


1.8
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.7 2010/07/03 15:59:05 schwarze Exp $ */
d127 2
a128 2
static	int		 roff_res(struct roff *, int, 
				char **, size_t *, int, int *);
d327 1
a327 2
roff_res(struct roff *r, int ln, char **bufp,
		size_t *szp, int pos, int *offs)
d334 1
d399 1
a399 1
	if (r->first_string && ! roff_res(r, ln, bufp, szp, pos, offs))
@


1.7
log
@Rudimentary implementation of user-defined strings;
no time for more refinement right now.
In particular, fixes terminfo(3) and mdoc.samples(7).
ok kristaps@@, who will add the HTML frontend bits
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.6 2010/06/27 21:54:42 schwarze Exp $ */
d4 1
a30 1
#include "regs.h"
d32 1
d64 7
d78 1
a111 6
struct roffstr {
	char		*name;
	char		*string;
	struct roffstr	*next;
} *first_string;

d121 4
d127 4
a130 1
static	enum roffrule	 roff_evalcond(const char *, int *);
d280 1
a280 1
	roff_freestr();
d321 66
d395 8
d412 2
a413 1
				(r, t, bufp, szp, ln, pos, pos, offs));
d426 2
a427 1
				(r, t, bufp, szp, ln, pos, pos, offs));
d442 2
a443 1
			(r, t, bufp, szp, ln, ppos, pos, offs));
d970 1
a970 1
	roff_setstr(name, string);
d1014 2
a1015 2
char *
roff_setstr(const char *name, const char *string)
d1020 1
a1020 1
	n = first_string;
d1023 8
a1030 1
	if (n) {
d1032 2
a1033 16
	} else {
		if (NULL == (namecopy = strdup(name)))
			return(NULL);
		if (NULL == (n = malloc(sizeof(struct roffstr)))) {
			free(n);
			return(NULL);
		}
		n->name = namecopy;
		n->next = first_string;
		first_string = n;
	}
	if (string)
		n->string = strdup(string);
	else
		n->string = NULL;
	return(n->string);
a1035 13
char *
roff_getstr(const char *name)
{
	struct roffstr	 *n;

	n = first_string;
	while (n && strcmp(name, n->name))
		n = n->next;
	if (n)
		return(n->string);
	else
		return(NULL);
}
d1037 2
a1038 2
char *
roff_getstrn(const char *name, size_t len)
d1040 1
a1040 1
	struct roffstr	 *n;
d1042 1
a1042 1
	n = first_string;
d1045 2
a1046 4
	if (n)
		return(n->string);
	else
		return(NULL);
d1049 3
a1051 2
void
roff_freestr(void)
d1055 1
a1055 1
	for (n = first_string; n; n = nn) {
d1061 2
a1062 1
	first_string = NULL;
@


1.6
log
@Full .nr nS support, unbreaking the kernel manuals.

Kristaps coded this from scratch after reading my .nr patch;
it is simpler and more powerful.

Registers live in struct regset in regs.h, struct man and struct mdoc
contain pointers to it.  The nS register is cleared when parsing .Sh.
Frontends respect the MDOC_SYNPRETTY flag set in mdoc node_alloc.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.5 2010/06/26 17:56:43 schwarze Exp $ */
d103 6
d117 1
d137 1
a137 1
	{ "ds", roff_line, NULL, NULL, 0, NULL },
d270 1
d857 33
d924 72
@


1.5
log
@merge release 1.10.2
* bug fixes:
- interaction of ASCII_HYPH with special chars (found by Ulrich Spoerlein)
- handling of roff conditionals (found by Ulrich Spoerlein)
- .Bd -offset will no more default to 6n
* maintenance:
- more caching of .Bd and .Bl arguments for efficiency
- deconstify man(7) validation routines
- add FreeBSD library names (provided by Ulrich Spoerlein)
* start PostScript font-switching
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.4 2010/06/06 20:30:08 schwarze Exp $ */
d22 1
d24 1
d30 1
d54 1
d69 1
d111 2
a113 1
static	enum rofferr	 roff_line(ROFF_ARGS);
d139 1
d150 1
d284 1
a284 1
roff_alloc(const mandocmsg msg, void *data)
d293 1
d304 2
a305 2
roff_parseln(struct roff *r, int ln, 
		char **bufp, size_t *szp, int pos, int *offs)
d404 20
d634 2
a635 2
	return((*roffs[t].proc)(r, t, bufp, 
			szp, ln, ppos, pos, offs));
d684 2
a685 2
	return((*roffs[t].proc)
			(r, t, bufp, szp, ln, ppos, pos, offs));
d744 9
d849 1
a849 1
roff_line(ROFF_ARGS)
d851 30
@


1.4
log
@Merge bsd.lv version 1.10.1 (to be released soon).

The main step forward is that this now has *much* better .Bl -column
support, now supporting many manuals that previously errored out
without producing any output.

Other fixes include:
* do not die from multiple list types, use the first and warn
* in .Bl without a type, default to -item
* various tweaks to .Dt
* fix .In, .Fd, .Ft, .Fn and .Fo formatting
* some documentation fixes and additions
* and fix a couple of bugs reported by Ulrich Spoerlein:
* better support for roff block-end "\}" without a preceding dot
* .In must not break the line outside SYNOPSIS
* spelling in some error messages

While merging, fix one regression in .In spacing
that needs to go to bsd.lv, too.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.3 2010/06/06 18:08:41 schwarze Exp $ */
d106 1
d625 1
d630 10
a639 1
	roff_cond_text(r, tok, bufp, szp, ln, ppos, pos, offs);
d688 25
a716 1
	int		 cpos;  /* position of the condition */
d718 1
d727 1
a727 1
	cpos = pos;
d729 11
a739 10
	if (ROFF_if == tok || ROFF_ie == tok) {
		/*
		 * Read ahead past the conditional.  FIXME: this does
		 * not work, as conditionals don't end on whitespace,
		 * but are parsed according to a formal grammar.  It's
		 * good enough for now, however.
		 */
		while ((*bufp)[pos] && ' ' != (*bufp)[pos])
			pos++;
	}
d742 1
d752 1
d754 3
a756 3
		if ( ! (*r->msg)(MANDOCERR_NOARGS, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
		return(ROFF_IGN);
d762 1
a762 1
	/* XXX: Implement more conditionals. */
a763 13
	if (ROFF_if == tok || ROFF_ie == tok)
		r->last->rule = 'n' == (*bufp)[cpos] ?
		    ROFFRULE_ALLOW : ROFFRULE_DENY;
	else if (ROFF_el == tok) {
		/* 
		 * An `.el' will get the value of the current rstack
		 * entry set in prior `ie' calls or defaults to DENY.
	 	 */
		if (r->rstackpos < 0)
			r->last->rule = ROFFRULE_DENY;
		else
			r->last->rule = r->rstack[r->rstackpos];
	}
d775 3
d780 6
@


1.3
log
@Merge bsd.lv release 1.10.0,
which is mostly the post-hackathon release,
bringing in the OpenBSD changes to bsd.lv,
but which also has a few additional minor fixes:

* .Lb is an in-line macro, not in_line_eoln
* .Bt, .Ud now warn when discarding arguments
* allow bad -man dates to flow verbatim into the front-ends
- so far all reported by Ulrich Spoerlein
* .Ar, .Fl and .Li starting with closing punctuation emit an empty element
* empty .Li macros print nothing, but may cause spacing
* proper EOS handling for .Bt, .Ex, .Rv, and .Ud.
* cleanup: collapse posts_xr into posts_wtext (which is the same)
* efficiency: very simple table lookup for roff.c
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.2 2010/05/20 00:58:02 schwarze Exp $ */
d669 1
a669 2
	if (ep > st && '\\' != *(ep - 1)) {
		ep = '\0';
a670 1
	}
@


1.2
log
@Support nested roff instructions:
* allow roff_parseln() to be re-run
* allow roff_parseln() to manipulate the line buffer offset
* support the offset in the man and mdoc libraries
* adapt .if, .ie, .el, .ig, .am* and .de* support
* interpret some instructions even in conditional-negative context
Coded by kristaps during the last day of the mandoc hackathon.

To avoid regressions in the OpenBSD tree, commit this together
with some small local additions:
* detect roff block end "\}" even on macro lines
* actually implement the ".if n" conditional
* ignore .ds, .rm and .tr in libroff

Also back my old .if/.ie/.el-handling out of libman, reverting:
man.h 1.15 man.c 1.25 man_macro.c 1.15 man_validate.c 1.19
man_action.c 1.15 man_term.c 1.28 man_html.c 1.9.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.1 2010/05/16 00:54:03 schwarze Exp $ */
d22 1
d95 1
d108 24
a131 16
const	struct roffmac	 roffs[ROFF_MAX] = {
	{ "am", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "ami", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "am1", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "de", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "dei", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "de1", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "ds", roff_line, NULL, NULL, 0 },
	{ "el", roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT },
	{ "ie", roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT },
	{ "if", roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT },
	{ "ig", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "rm", roff_line, NULL, NULL, 0 },
	{ "tr", roff_line, NULL, NULL, 0 },
	{ ".", roff_cblock, NULL, NULL, 0 },
	{ "\\}", roff_ccond, NULL, NULL, 0 },
d136 1
d143 24
d175 2
a176 3
	int		 i;

	/* FIXME: make this be fast and efficient. */
d178 17
a194 3
	for (i = 0; i < (int)ROFF_MAX; i++)
		if (0 == strcmp(roffs[i].name, p))
			return((enum rofft)i);
d287 2
@


1.1
log
@In theory, Kristaps never intended to write a roff parser,
but in practice, most real legacy man(7)uals are using so much
low level roff that we can't really get away without at least
partially handling some roff instructions.

As doing this in man(7) only has become messy and as even some
mdoc(7) pages need it, start a minimal partial roff preprocessor.
As a first step, move handling of .am[i], .de[i] and .ig there.
Do not use the roff preprocessor for new manuals!

Now that we have three main parser libraries - roff, man and mdoc -
each one having its own error handling is becoming messy, too.
Thus, start unifying message handling in one central place,
introducing a new generic function mmsg().

coded by kristaps@@
@
text
@d1 1
a1 1
/*	$Id$ */
d24 1
d29 5
d35 3
d40 5
a44 2
	ROFF_am,
	ROFF_ami,
d46 4
a49 1
	ROFF_close,
d53 5
d62 2
a68 1
	char		*end; /* custom end-token */
d71 3
d81 3
a83 1
			 int ppos /* current pos in buffer */
d89 5
a93 2
	roffproc	 sub; /* child of control black */
	roffproc	 new; /* root of stack (type = ROFF_MAX) */
d96 9
a104 3
static	enum rofferr	 roff_new_close(ROFF_ARGS);
static	enum rofferr	 roff_new_ig(ROFF_ARGS);
static	enum rofferr	 roff_sub_ig(ROFF_ARGS);
d107 15
a121 6
	{ "de", roff_sub_ig, roff_new_ig },
	{ "dei", roff_sub_ig, roff_new_ig },
	{ "am", roff_sub_ig, roff_new_ig },
	{ "ami", roff_sub_ig, roff_new_ig },
	{ "ig", roff_sub_ig, roff_new_ig },
	{ ".", NULL, roff_new_close },
d126 1
d161 10
a170 3
	if (NULL == (p = r->last))
		return;
	r->last = p->parent;
d193 1
d238 1
d244 2
a245 1
roff_parseln(struct roff *r, int ln, char **bufp, size_t *szp)
d250 20
a269 5
	if (NULL != r->last) {
		/*
		 * If there's a node on the stack, then jump directly
		 * into its processing function.
		 */
d272 12
a283 3
		return((*roffs[t].sub)(r, t, bufp, szp, ln, 0));
	} else if ('.' != (*bufp)[0] && NULL == r->last)
		/* Return when in free text without a context. */
d286 5
a290 1
	/* There's nothing on the stack: make us anew. */
d292 3
a294 2
	if (ROFF_MAX == (t = roff_parse(*bufp, &ppos)))
		return(ROFF_CONT);
d296 4
a299 2
	assert(roffs[t].new);
	return((*roffs[t].new)(r, t, bufp, szp, ln, ppos));
d314 2
a315 2
	assert('.' == buf[0]);
	*pos = 1;
d326 1
a326 1
		else if (' ' == buf[*pos])
d346 1
a346 1
roff_sub_ig(ROFF_ARGS)
a347 1
	int		 i, j;
d349 10
a358 1
	/* Ignore free-text lines. */
d360 18
a377 1
	if ('.' != (*bufp)[ppos])
d379 11
a390 2
	if (r->last->end) {
		i = ppos + 1;
d392 3
a394 2
		while ((*bufp)[i] && ' ' == (*bufp)[i])
			i++;
d396 6
a401 3
		for (j = 0; r->last->end[j]; i++, j++)
			if ((*bufp)[i] != r->last->end[j])
				return(ROFF_IGN);
a402 4
		if (r->last->end[j])
			return(ROFF_IGN);
		if ((*bufp)[i] && ' ' != (*bufp)[i])
			return(ROFF_IGN);
d404 4
a407 2
		while (' ' == (*bufp)[i])
			i++;
d409 3
a411 1
	} else if (ROFF_close != roff_parse(*bufp, &i))
d413 1
d415 12
a426 1
	roffnode_pop(r);
d428 3
a430 1
	if ('\0' == (*bufp)[i])
d432 5
a436 2
	if ( ! (*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, i, NULL))
		return(ROFF_ERR);
d438 2
d446 1
a446 1
roff_new_close(ROFF_ARGS)
d448 19
d468 21
a488 1
	if ( ! (*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL))
d490 8
d505 1
a505 1
roff_new_ig(ROFF_ARGS)
d507 20
a526 1
	int		 i;
d528 6
a533 2
	if ( ! roffnode_push(r, tok, ln, ppos))
		return(ROFF_ERR);
d535 4
a538 5
	if (ROFF_ig != tok) {
		while ((*bufp)[ppos] && ' ' != (*bufp)[ppos])
			ppos++;
		while (' ' == (*bufp)[ppos])
			ppos++;
d541 4
a544 1
	i = (int)ppos;
d546 2
a547 2
	while ((*bufp)[i] && ' ' != (*bufp)[i])
		i++;
d549 2
a550 1
	if (i == (int)ppos)
d553 54
a606 3
	if ((*bufp)[i])
		if ( ! (*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, i, NULL))
			return(ROFF_ERR);
d609 2
a610 8
	 * If the macro has arguments, the first argument (up to the
	 * next whitespace) is interpreted as an argument marking the
	 * macro close.  Thus, `.ig foo' will close at `.foo'.
	 *
	 * NOTE: the closing macro `.foo' in the above case is not
	 * allowed to have leading spaces with old groff!  Thus `.foo'
	 * != `. foo'.  Oh yeah, everything after the `.foo' is lost.
	 * Merry fucking Christmas.
d613 26
a638 2
	r->last->end = malloc((size_t)(i - ppos) + 1);
	if (NULL == r->last->end) {
d643 77
a719 2
	memcpy(r->last->end, &(*bufp)[ppos], (size_t)(i - ppos));
	r->last->end[i - ppos] = '\0';
d721 2
a722 1
	return(ROFF_IGN);
d726 3
a728 2
int
roff_endparse(struct roff *r)
d731 1
a731 4
	if (NULL == r->last)
		return(1);
	return((*r->msg)(MANDOCERR_SCOPEEXIT, r->data, 
				r->last->line, r->last->col, NULL));
@

