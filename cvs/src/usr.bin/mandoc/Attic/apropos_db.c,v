head	1.20;
access;
symbols
	OPENBSD_5_4:1.18.0.6
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.4
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2;
locks; strict;
comment	@ * @;


1.20
date	2013.12.31.00.40.19;	author schwarze;	state dead;
branches;
next	1.19;

1.19
date	2013.10.05.21.17.29;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2012.04.15.11.54.47;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2011.12.25.14.51.33;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2011.12.20.00.41.24;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2011.12.19.02.26.33;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2011.12.10.22.18.20;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2011.12.03.22.47.27;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2011.12.03.14.53.12;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.29.22.30.56;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.28.00.16.38;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.27.23.11.32;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.26.16.41.35;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.18.01.10.03;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.17.15.38.27;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.17.14.52.32;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.16.13.23.27;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.13.11.07.10;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.13.10.40.52;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.13.10.28.38;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Replace the Berkeley-DB based mandocdb(8) by an SQLite3-based version,
aiming for more flexible development and optimization options.
Kristaps started this during the summer 2012, i did some very heavy
bugfixing during t2k13 and finally, during the last few days,
got it to a state where it is ripe for in-tree development.
Beware, neither the user interfaces nor the database formats
are expected to be stable just yet.

Will not be installed or activated until further discussion.
No functional change to mandoc(1).

"As long as it remains off until we decide the cost, fine." deraadt@@
@
text
@/*	$Id: apropos_db.c,v 1.19 2013/10/05 21:17:29 schwarze Exp $ */
/*
 * Copyright (c) 2011, 2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/param.h>
#include <sys/types.h>

#include <assert.h>
#include <fcntl.h>
#include <regex.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <db.h>

#include "mandocdb.h"
#include "apropos_db.h"
#include "mandoc.h"

#define	RESFREE(_x) \
	do { \
		free((_x)->file); \
		free((_x)->cat); \
		free((_x)->title); \
		free((_x)->arch); \
		free((_x)->desc); \
		free((_x)->matches); \
	} while (/*CONSTCOND*/0)

struct	expr {
	int		 regex; /* is regex? */
	int		 index; /* index in match array */
	uint64_t 	 mask; /* type-mask */
	int		 and; /* is rhs of logical AND? */
	char		*v; /* search value */
	regex_t	 	 re; /* compiled re, if regex */
	struct expr	*next; /* next in sequence */
	struct expr	*subexpr;
};

struct	type {
	uint64_t	 mask;
	const char	*name;
};

struct	rectree {
	struct res	*node; /* record array for dir tree */
	int		 len; /* length of record array */
};

static	const struct type types[] = {
	{ TYPE_An, "An" },
	{ TYPE_Ar, "Ar" },
	{ TYPE_At, "At" },
	{ TYPE_Bsx, "Bsx" },
	{ TYPE_Bx, "Bx" },
	{ TYPE_Cd, "Cd" },
	{ TYPE_Cm, "Cm" },
	{ TYPE_Dv, "Dv" },
	{ TYPE_Dx, "Dx" },
	{ TYPE_Em, "Em" },
	{ TYPE_Er, "Er" },
	{ TYPE_Ev, "Ev" },
	{ TYPE_Fa, "Fa" },
	{ TYPE_Fl, "Fl" },
	{ TYPE_Fn, "Fn" },
	{ TYPE_Fn, "Fo" },
	{ TYPE_Ft, "Ft" },
	{ TYPE_Fx, "Fx" },
	{ TYPE_Ic, "Ic" },
	{ TYPE_In, "In" },
	{ TYPE_Lb, "Lb" },
	{ TYPE_Li, "Li" },
	{ TYPE_Lk, "Lk" },
	{ TYPE_Ms, "Ms" },
	{ TYPE_Mt, "Mt" },
	{ TYPE_Nd, "Nd" },
	{ TYPE_Nm, "Nm" },
	{ TYPE_Nx, "Nx" },
	{ TYPE_Ox, "Ox" },
	{ TYPE_Pa, "Pa" },
	{ TYPE_Rs, "Rs" },
	{ TYPE_Sh, "Sh" },
	{ TYPE_Ss, "Ss" },
	{ TYPE_St, "St" },
	{ TYPE_Sy, "Sy" },
	{ TYPE_Tn, "Tn" },
	{ TYPE_Va, "Va" },
	{ TYPE_Va, "Vt" },
	{ TYPE_Xr, "Xr" },
	{ UINT64_MAX, "any" },
	{ 0, NULL }
};

static	DB	*btree_open(void);
static	int	 btree_read(const DBT *, const DBT *,
			const struct mchars *,
			uint64_t *, recno_t *, char **);
static	int	 expreval(const struct expr *, int *);
static	void	 exprexec(const struct expr *,
			const char *, uint64_t, struct res *);
static	int	 exprmark(const struct expr *,
			const char *, uint64_t, int *);
static	struct expr *exprexpr(int, char *[], int *, int *, size_t *);
static	struct expr *exprterm(char *, int);
static	DB	*index_open(void);
static	int	 index_read(const DBT *, const DBT *, int,
			const struct mchars *, struct res *);
static	void	 norm_string(const char *,
			const struct mchars *, char **);
static	size_t	 norm_utf8(unsigned int, char[7]);
static	int	 single_search(struct rectree *, const struct opts *,
			const struct expr *, size_t terms,
			struct mchars *, int);

/*
 * Open the keyword mandoc-db database.
 */
static DB *
btree_open(void)
{
	BTREEINFO	 info;
	DB		*db;

	memset(&info, 0, sizeof(BTREEINFO));
	info.lorder = 4321;
	info.flags = R_DUP;

	db = dbopen(MANDOC_DB, O_RDONLY, 0, DB_BTREE, &info);
	if (NULL != db)
		return(db);

	return(NULL);
}

/*
 * Read a keyword from the database and normalise it.
 * Return 0 if the database is insane, else 1.
 */
static int
btree_read(const DBT *k, const DBT *v, const struct mchars *mc,
		uint64_t *mask, recno_t *rec, char **buf)
{
	uint64_t	 vbuf[2];

	/* Are our sizes sane? */
	if (k->size < 2 || sizeof(vbuf) != v->size)
		return(0);

	/* Is our string nil-terminated? */
	if ('\0' != ((const char *)k->data)[(int)k->size - 1])
		return(0);

	norm_string((const char *)k->data, mc, buf);
	memcpy(vbuf, v->data, v->size);
	*mask = betoh64(vbuf[0]);
	*rec  = betoh64(vbuf[1]);
	return(1);
}

/*
 * Take a Unicode codepoint and produce its UTF-8 encoding.
 * This isn't the best way to do this, but it works.
 * The magic numbers are from the UTF-8 packaging.
 * They're not as scary as they seem: read the UTF-8 spec for details.
 */
static size_t
norm_utf8(unsigned int cp, char out[7])
{
	int		 rc;

	rc = 0;

	if (cp <= 0x0000007F) {
		rc = 1;
		out[0] = (char)cp;
	} else if (cp <= 0x000007FF) {
		rc = 2;
		out[0] = (cp >> 6  & 31) | 192;
		out[1] = (cp       & 63) | 128;
	} else if (cp <= 0x0000FFFF) {
		rc = 3;
		out[0] = (cp >> 12 & 15) | 224;
		out[1] = (cp >> 6  & 63) | 128;
		out[2] = (cp       & 63) | 128;
	} else if (cp <= 0x001FFFFF) {
		rc = 4;
		out[0] = (cp >> 18 & 7) | 240;
		out[1] = (cp >> 12 & 63) | 128;
		out[2] = (cp >> 6  & 63) | 128;
		out[3] = (cp       & 63) | 128;
	} else if (cp <= 0x03FFFFFF) {
		rc = 5;
		out[0] = (cp >> 24 & 3) | 248;
		out[1] = (cp >> 18 & 63) | 128;
		out[2] = (cp >> 12 & 63) | 128;
		out[3] = (cp >> 6  & 63) | 128;
		out[4] = (cp       & 63) | 128;
	} else if (cp <= 0x7FFFFFFF) {
		rc = 6;
		out[0] = (cp >> 30 & 1) | 252;
		out[1] = (cp >> 24 & 63) | 128;
		out[2] = (cp >> 18 & 63) | 128;
		out[3] = (cp >> 12 & 63) | 128;
		out[4] = (cp >> 6  & 63) | 128;
		out[5] = (cp       & 63) | 128;
	} else
		return(0);

	out[rc] = '\0';
	return((size_t)rc);
}

/*
 * Normalise strings from the index and database.
 * These strings are escaped as defined by mandoc_char(7) along with
 * other goop in mandoc.h (e.g., soft hyphens).
 * This function normalises these into a nice UTF-8 string.
 * Returns 0 if the database is fucked.
 */
static void
norm_string(const char *val, const struct mchars *mc, char **buf)
{
	size_t		  sz, bsz;
	char		  utfbuf[7];
	const char	 *seq, *cpp;
	int		  len, u, pos;
	enum mandoc_esc	  esc;
	static const char res[] = { '\\', '\t',
				ASCII_NBRSP, ASCII_HYPH, '\0' };

	/* Pre-allocate by the length of the input */

	bsz = strlen(val) + 1;
	*buf = mandoc_realloc(*buf, bsz);
	pos = 0;

	while ('\0' != *val) {
		/*
		 * Halt on the first escape sequence.
		 * This also halts on the end of string, in which case
		 * we just copy, fallthrough, and exit the loop.
		 */
		if ((sz = strcspn(val, res)) > 0) {
			memcpy(&(*buf)[pos], val, sz);
			pos += (int)sz;
			val += (int)sz;
		}

		if (ASCII_HYPH == *val) {
			(*buf)[pos++] = '-';
			val++;
			continue;
		} else if ('\t' == *val || ASCII_NBRSP == *val) {
			(*buf)[pos++] = ' ';
			val++;
			continue;
		} else if ('\\' != *val)
			break;

		/* Read past the slash. */

		val++;
		u = 0;

		/*
		 * Parse the escape sequence and see if it's a
		 * predefined character or special character.
		 */

		esc = mandoc_escape(&val, &seq, &len);
		if (ESCAPE_ERROR == esc)
			break;

		/*
		 * XXX - this just does UTF-8, but we need to know
		 * beforehand whether we should do text substitution.
		 */

		switch (esc) {
		case (ESCAPE_SPECIAL):
			if (0 != (u = mchars_spec2cp(mc, seq, len)))
				break;
			/* FALLTHROUGH */
		default:
			continue;
		}

		/*
		 * If we have a Unicode codepoint, try to convert that
		 * to a UTF-8 byte string.
		 */

		cpp = utfbuf;
		if (0 == (sz = norm_utf8(u, utfbuf)))
			continue;

		/* Copy the rendered glyph into the stream. */

		sz = strlen(cpp);
		bsz += sz;

		*buf = mandoc_realloc(*buf, bsz);

		memcpy(&(*buf)[pos], cpp, sz);
		pos += (int)sz;
	}

	(*buf)[pos] = '\0';
}

/*
 * Open the filename-index mandoc-db database.
 * Returns NULL if opening failed.
 */
static DB *
index_open(void)
{
	DB		*db;

	db = dbopen(MANDOC_IDX, O_RDONLY, 0, DB_RECNO, NULL);
	if (NULL != db)
		return(db);

	return(NULL);
}

/*
 * Safely unpack from an index file record into the structure.
 * Returns 1 if an entry was unpacked, 0 if the database is insane.
 */
static int
index_read(const DBT *key, const DBT *val, int index,
		const struct mchars *mc, struct res *rec)
{
	size_t		 left;
	char		*np, *cp;
	char		 type;

#define	INDEX_BREAD(_dst) \
	do { \
		if (NULL == (np = memchr(cp, '\0', left))) \
			return(0); \
		norm_string(cp, mc, &(_dst)); \
		left -= (np - cp) + 1; \
		cp = np + 1; \
	} while (/* CONSTCOND */ 0)

	if (0 == (left = val->size))
		return(0);

	cp = val->data;
	assert(sizeof(recno_t) == key->size);
	memcpy(&rec->rec, key->data, key->size);
	rec->volume = index;

	if ('d' == (type = *cp++))
		rec->type = RESTYPE_MDOC;
	else if ('a' == type)
		rec->type = RESTYPE_MAN;
	else if ('c' == type)
		rec->type = RESTYPE_CAT;
	else
		return(0);

	left--;
	INDEX_BREAD(rec->file);
	INDEX_BREAD(rec->cat);
	INDEX_BREAD(rec->title);
	INDEX_BREAD(rec->arch);
	INDEX_BREAD(rec->desc);
	return(1);
}

/*
 * Search mandocdb databases in paths for expression "expr".
 * Filter out by "opts".
 * Call "res" with the results, which may be zero.
 * Return 0 if there was a database error, else return 1.
 */
int
apropos_search(int pathsz, char **paths, const struct opts *opts,
		const struct expr *expr, size_t terms, void *arg,
		size_t *sz, struct res **resp,
		void (*res)(struct res *, size_t, void *))
{
	struct rectree	 tree;
	struct mchars	*mc;
	int		 i;

	memset(&tree, 0, sizeof(struct rectree));

	mc = mchars_alloc();
	*sz = 0;
	*resp = NULL;

	/*
	 * Main loop.  Change into the directory containing manpage
	 * databases.  Run our expession over each database in the set.
	 */

	for (i = 0; i < pathsz; i++) {
		assert('/' == paths[i][0]);
		if (chdir(paths[i]))
			continue;
		if (single_search(&tree, opts, expr, terms, mc, i))
			continue;

		resfree(tree.node, tree.len);
		mchars_free(mc);
		return(0);
	}

	(*res)(tree.node, tree.len, arg);
	*sz = tree.len;
	*resp = tree.node;
	mchars_free(mc);
	return(1);
}

static int
single_search(struct rectree *tree, const struct opts *opts,
		const struct expr *expr, size_t terms,
		struct mchars *mc, int vol)
{
	int		 root, leaf, ch;
	DBT		 key, val;
	DB		*btree, *idx;
	char		*buf;
	struct res	*rs;
	struct res	 r;
	uint64_t	 mask;
	recno_t		 rec;

	root	= -1;
	leaf	= -1;
	btree	= NULL;
	idx	= NULL;
	buf	= NULL;
	rs	= tree->node;

	memset(&r, 0, sizeof(struct res));

	if (NULL == (btree = btree_open()))
		return(1);

	if (NULL == (idx = index_open())) {
		(*btree->close)(btree);
		return(1);
	}

	while (0 == (ch = (*btree->seq)(btree, &key, &val, R_NEXT))) {
		if ( ! btree_read(&key, &val, mc, &mask, &rec, &buf))
			break;

		/*
		 * See if this keyword record matches any of the
		 * expressions we have stored.
		 */
		if ( ! exprmark(expr, buf, mask, NULL))
			continue;

		/*
		 * O(log n) scan for prior records.  Since a record
		 * number is unbounded, this has decent performance over
		 * a complex hash function.
		 */

		for (leaf = root; leaf >= 0; )
			if (rec > rs[leaf].rec &&
					rs[leaf].rhs >= 0)
				leaf = rs[leaf].rhs;
			else if (rec < rs[leaf].rec &&
					rs[leaf].lhs >= 0)
				leaf = rs[leaf].lhs;
			else
				break;

		/*
		 * If we find a record, see if it has already evaluated
		 * to true.  If it has, great, just keep going.  If not,
		 * try to evaluate it now and continue anyway.
		 */

		if (leaf >= 0 && rs[leaf].rec == rec) {
			if (0 == rs[leaf].matched)
				exprexec(expr, buf, mask, &rs[leaf]);
			continue;
		}

		/*
		 * We have a new file to examine.
		 * Extract the manpage's metadata from the index
		 * database, then begin partial evaluation.
		 */

		key.data = &rec;
		key.size = sizeof(recno_t);

		if (0 != (*idx->get)(idx, &key, &val, 0))
			break;

		r.lhs = r.rhs = -1;
		if ( ! index_read(&key, &val, vol, mc, &r))
			break;

		/* XXX: this should be elsewhere, I guess? */

		if (opts->cat && strcasecmp(opts->cat, r.cat))
			continue;

		if (opts->arch && *r.arch)
			if (strcasecmp(opts->arch, r.arch))
				continue;

		tree->node = rs = mandoc_realloc
			(rs, (tree->len + 1) * sizeof(struct res));

		memcpy(&rs[tree->len], &r, sizeof(struct res));
		memset(&r, 0, sizeof(struct res));
		rs[tree->len].matches =
			mandoc_calloc(terms, sizeof(int));

		exprexec(expr, buf, mask, &rs[tree->len]);

		/* Append to our tree. */

		if (leaf >= 0) {
			if (rec > rs[leaf].rec)
				rs[leaf].rhs = tree->len;
			else
				rs[leaf].lhs = tree->len;
		} else
			root = tree->len;

		tree->len++;
	}

	(*btree->close)(btree);
	(*idx->close)(idx);

	free(buf);
	RESFREE(&r);
	return(1 == ch);
}

void
resfree(struct res *rec, size_t sz)
{
	size_t		 i;

	for (i = 0; i < sz; i++)
		RESFREE(&rec[i]);
	free(rec);
}

/*
 * Compile a list of straight-up terms.
 * The arguments are re-written into ~[[:<:]]term[[:>:]], or "term"
 * surrounded by word boundaries, then pumped through exprterm().
 * Terms are case-insensitive.
 * This emulates whatis(1) behaviour.
 */
struct expr *
termcomp(int argc, char *argv[], size_t *tt)
{
	char		*buf;
	int		 pos;
	struct expr	*e, *next;
	size_t		 sz;

	buf = NULL;
	e = NULL;
	*tt = 0;

	for (pos = argc - 1; pos >= 0; pos--) {
		sz = strlen(argv[pos]) + 18;
		buf = mandoc_realloc(buf, sz);
		strlcpy(buf, "Nm~[[:<:]]", sz);
		strlcat(buf, argv[pos], sz);
		strlcat(buf, "[[:>:]]", sz);
		if (NULL == (next = exprterm(buf, 0))) {
			free(buf);
			exprfree(e);
			return(NULL);
		}
		next->next = e;
		e = next;
		(*tt)++;
	}

	free(buf);
	return(e);
}

/*
 * Compile a sequence of logical expressions.
 * See apropos.1 for a grammar of this sequence.
 */
struct expr *
exprcomp(int argc, char *argv[], size_t *tt)
{
	int		 pos, lvl;
	struct expr	*e;

	pos = lvl = 0;
	*tt = 0;

	e = exprexpr(argc, argv, &pos, &lvl, tt);

	if (0 == lvl && pos >= argc)
		return(e);

	exprfree(e);
	return(NULL);
}

/*
 * Compile an array of tokens into an expression.
 * An informal expression grammar is defined in apropos(1).
 * Return NULL if we fail doing so.  All memory will be cleaned up.
 * Return the root of the expression sequence if alright.
 */
static struct expr *
exprexpr(int argc, char *argv[], int *pos, int *lvl, size_t *tt)
{
	struct expr	*e, *first, *next;
	int		 log;

	first = next = NULL;

	for ( ; *pos < argc; (*pos)++) {
		e = next;

		/*
		 * Close out a subexpression.
		 */

		if (NULL != e && 0 == strcmp(")", argv[*pos])) {
			if (--(*lvl) < 0)
				goto err;
			break;
		}

		/*
		 * Small note: if we're just starting, don't let "-a"
		 * and "-o" be considered logical operators: they're
		 * just tokens unless pairwise joining, in which case we
		 * record their existence (or assume "OR").
		 */
		log = 0;

		if (NULL != e && 0 == strcmp("-a", argv[*pos]))
			log = 1;
		else if (NULL != e && 0 == strcmp("-o", argv[*pos]))
			log = 2;

		if (log > 0 && ++(*pos) >= argc)
			goto err;

		/*
		 * Now we parse the term part.  This can begin with
		 * "-i", in which case the expression is case
		 * insensitive.
		 */

		if (0 == strcmp("(", argv[*pos])) {
			++(*pos);
			++(*lvl);
			next = mandoc_calloc(1, sizeof(struct expr));
			next->subexpr = exprexpr(argc, argv, pos, lvl, tt);
			if (NULL == next->subexpr) {
				free(next);
				next = NULL;
			}
		} else if (0 == strcmp("-i", argv[*pos])) {
			if (++(*pos) >= argc)
				goto err;
			next = exprterm(argv[*pos], 0);
		} else
			next = exprterm(argv[*pos], 1);

		if (NULL == next)
			goto err;

		next->and = log == 1;
		next->index = (int)(*tt)++;

		/* Append to our chain of expressions. */

		if (NULL == first) {
			assert(NULL == e);
			first = next;
		} else {
			assert(NULL != e);
			e->next = next;
		}
	}

	return(first);
err:
	exprfree(first);
	return(NULL);
}

/*
 * Parse a terminal expression with the grammar as defined in
 * apropos(1).
 * Return NULL if we fail the parse.
 */
static struct expr *
exprterm(char *buf, int cs)
{
	struct expr	 e;
	struct expr	*p;
	char		*key;
	int		 i;

	memset(&e, 0, sizeof(struct expr));

	/* Choose regex or substring match. */

	if (NULL == (e.v = strpbrk(buf, "=~"))) {
		e.regex = 0;
		e.v = buf;
	} else {
		e.regex = '~' == *e.v;
		*e.v++ = '\0';
	}

	/* Determine the record types to search for. */

	e.mask = 0;
	if (buf < e.v) {
		while (NULL != (key = strsep(&buf, ","))) {
			i = 0;
			while (types[i].mask &&
					strcmp(types[i].name, key))
				i++;
			e.mask |= types[i].mask;
		}
	}
	if (0 == e.mask)
		e.mask = TYPE_Nm | TYPE_Nd;

	if (e.regex) {
		i = REG_EXTENDED | REG_NOSUB | (cs ? 0 : REG_ICASE);
		if (regcomp(&e.re, e.v, i))
			return(NULL);
	}

	e.v = mandoc_strdup(e.v);

	p = mandoc_calloc(1, sizeof(struct expr));
	memcpy(p, &e, sizeof(struct expr));
	return(p);
}

void
exprfree(struct expr *p)
{
	struct expr	*pp;

	while (NULL != p) {
		if (p->subexpr)
			exprfree(p->subexpr);
		if (p->regex)
			regfree(&p->re);
		free(p->v);
		pp = p->next;
		free(p);
		p = pp;
	}
}

static int
exprmark(const struct expr *p, const char *cp,
		uint64_t mask, int *ms)
{

	for ( ; p; p = p->next) {
		if (p->subexpr) {
			if (exprmark(p->subexpr, cp, mask, ms))
				return(1);
			continue;
		} else if ( ! (mask & p->mask))
			continue;

		if (p->regex) {
			if (regexec(&p->re, cp, 0, NULL, 0))
				continue;
		} else if (NULL == strcasestr(cp, p->v))
			continue;

		if (NULL == ms)
			return(1);
		else
			ms[p->index] = 1;
	}

	return(0);
}

static int
expreval(const struct expr *p, int *ms)
{
	int		 match;

	/*
	 * AND has precedence over OR.  Analysis is left-right, though
	 * it doesn't matter because there are no side-effects.
	 * Thus, step through pairwise ANDs and accumulate their Boolean
	 * evaluation.  If we encounter a single true AND collection or
	 * standalone term, the whole expression is true (by definition
	 * of OR).
	 */

	for (match = 0; p && ! match; p = p->next) {
		/* Evaluate a subexpression, if applicable. */
		if (p->subexpr && ! ms[p->index])
			ms[p->index] = expreval(p->subexpr, ms);

		match = ms[p->index];
		for ( ; p->next && p->next->and; p = p->next) {
			/* Evaluate a subexpression, if applicable. */
			if (p->next->subexpr && ! ms[p->next->index])
				ms[p->next->index] =
					expreval(p->next->subexpr, ms);
			match = match && ms[p->next->index];
		}
	}

	return(match);
}

/*
 * First, update the array of terms for which this expression evaluates
 * to true.
 * Second, logically evaluate all terms over the updated array of truth
 * values.
 * If this evaluates to true, mark the expression as satisfied.
 */
static void
exprexec(const struct expr *e, const char *cp,
		uint64_t mask, struct res *r)
{

	assert(0 == r->matched);
	exprmark(e, cp, mask, r->matches);
	r->matched = expreval(e, r->matches);
}
@


1.19
log
@Cleanup suggested by gcc-4.8.1, following hints by Christos Zoulas:
- avoid bad qualifier casting in roff.c, roff_parsetext()
  by changing the mandoc_escape arguments to "const char const **"
- avoid bad qualifier casting in mandocdb.c, index_merge()
- garbage collect a few unused variables elsewhere
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.18 2012/04/15 11:54:47 schwarze Exp $ */
@


1.18
log
@Simplify by not pre-filtering the result vector for satisfied matches:
we can do this in the frontend; from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.17 2011/12/25 14:51:33 schwarze Exp $ */
d404 1
a404 1
	int		 i, rc;
a407 1
	rc = 0;
@


1.17
log
@For binary compatability of the databases across architectures,
use pointers to arrays, not pointers to structs.  It is now possible
to create databases on sparc64 and use them on i386 and vice versa.
Kristaps@@ can't think of anything else that might be required, either.
Put this in now such that we can move on.
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.16 2011/12/20 00:41:24 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
d18 1
d20 1
d35 9
a43 13
struct	rec {
	struct res	 res; /* resulting record info */
	/*
	 * Maintain a binary tree for checking the uniqueness of `rec'
	 * when adding elements to the results array.
	 * Since the results array is dynamic, use offset in the array
	 * instead of a pointer to the structure.
	 */
	int		 lhs;
	int		 rhs;
	int		 matched; /* expression is true */
	int		*matches; /* partial truth evaluations */
};
d62 1
a62 1
	struct rec	*node; /* record array for dir tree */
d116 1
a116 1
			const char *, uint64_t, struct rec *);
d123 1
a123 1
			const struct mchars *, struct rec *);
a126 1
static	void	 recfree(struct rec *);
d349 1
a349 1
		const struct mchars *mc, struct rec *rec)
d369 2
a370 2
	memcpy(&rec->res.rec, key->data, key->size);
	rec->res.volume = index;
d373 1
a373 1
		rec->res.type = RESTYPE_MDOC;
d375 1
a375 1
		rec->res.type = RESTYPE_MAN;
d377 1
a377 1
		rec->res.type = RESTYPE_CAT;
d382 5
a386 5
	INDEX_BREAD(rec->res.file);
	INDEX_BREAD(rec->res.cat);
	INDEX_BREAD(rec->res.title);
	INDEX_BREAD(rec->res.arch);
	INDEX_BREAD(rec->res.desc);
d399 1
d404 1
a404 2
	struct res	*ress;
	int		 i, mlen, rc;
d410 2
d419 1
d422 6
a427 2
		if ( ! single_search(&tree, opts, expr, terms, mc, i))
			goto out;
d430 3
a432 25
	/*
	 * Count matching files, transfer to a "clean" array, then feed
	 * them to the output handler.
	 */

	for (mlen = i = 0; i < tree.len; i++)
		if (tree.node[i].matched)
			mlen++;

	ress = mandoc_malloc(mlen * sizeof(struct res));

	for (mlen = i = 0; i < tree.len; i++)
		if (tree.node[i].matched)
			memcpy(&ress[mlen++], &tree.node[i].res,
					sizeof(struct res));

	(*res)(ress, mlen, arg);
	free(ress);

	rc = 1;
out:
	for (i = 0; i < tree.len; i++)
		recfree(&tree.node[i]);

	free(tree.node);
d434 1
a434 1
	return(rc);
d446 2
a447 2
	struct rec	*rs;
	struct rec	 r;
d458 1
a458 1
	memset(&r, 0, sizeof(struct rec));
d486 1
a486 1
			if (rec > rs[leaf].res.rec &&
d489 1
a489 1
			else if (rec < rs[leaf].res.rec &&
d501 1
a501 1
		if (leaf >= 0 && rs[leaf].res.rec == rec) {
d525 1
a525 1
		if (opts->cat && strcasecmp(opts->cat, r.res.cat))
d528 2
a529 2
		if (opts->arch && *r.res.arch)
			if (strcasecmp(opts->arch, r.res.arch))
d533 1
a533 1
			(rs, (tree->len + 1) * sizeof(struct rec));
d535 2
a536 2
		memcpy(&rs[tree->len], &r, sizeof(struct rec));
		memset(&r, 0, sizeof(struct rec));
d545 1
a545 1
			if (rec > rs[leaf].res.rec)
d559 1
a559 1
	recfree(&r);
d563 2
a564 2
static void
recfree(struct rec *rec)
d566 1
d568 3
a570 7
	free(rec->res.file);
	free(rec->res.cat);
	free(rec->res.title);
	free(rec->res.arch);
	free(rec->res.desc);

	free(rec->matches);
d861 1
a861 1
		uint64_t mask, struct rec *r)
@


1.16
log
@Do not cast void pointers to pointers requiring alignment.
This makes mandocdb(8)/apropos(1) work on strict alignment architectures.
Basic way to fix this confirmed by deraadt@@ and kettenis@@, thanks.

This now works on both sparc64 and i386, but note that the binary
database format is still machine-dependent.
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.15 2011/12/19 02:26:33 schwarze Exp $ */
d114 2
a115 2
			const struct mchars *, 
			struct db_val *, char **);
d159 2
a160 3
btree_read(const DBT *k, const DBT *v, 
		const struct mchars *mc, 
		struct db_val *dbv, char **buf)
d162 1
a162 1
	struct db_val	 raw_dbv;
d165 1
a165 1
	if (k->size < 2 || sizeof(struct db_val) != v->size)
d173 3
a175 3
	memcpy(&raw_dbv, v->data, v->size);
	dbv->rec = betoh32(raw_dbv.rec);
	dbv->mask = betoh64(raw_dbv.mask);
d466 2
a467 1
	struct db_val	 vb;
d487 1
a487 1
		if ( ! btree_read(&key, &val, mc, &vb, &buf))
d494 1
a494 1
		if ( ! exprmark(expr, buf, vb.mask, NULL))
d504 1
a504 1
			if (vb.rec > rs[leaf].res.rec &&
d507 1
a507 1
			else if (vb.rec < rs[leaf].res.rec &&
d519 1
a519 1
		if (leaf >= 0 && rs[leaf].res.rec == vb.rec) {
d521 1
a521 1
				exprexec(expr, buf, vb.mask, &rs[leaf]);
d531 1
a531 1
		key.data = &vb.rec;
d558 1
a558 1
		exprexec(expr, buf, vb.mask, &rs[tree->len]);
d563 1
a563 1
			if (vb.rec > rs[leaf].res.rec)
@


1.15
log
@Improvements from kristaps@@:
(1) Make the database format simpler and smaller by
- storing the file type as a single character and
- storing paths relative to the dir containing the database.
The latter allows to move trees around.
Both together typically save 15-25% of the index size.
(2) Make sure apropos(1) "any" really covers all search keys.
(3) Make manpath_parseline() static, drop manpath_parseconf() completely.
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.14 2011/12/10 22:18:20 schwarze Exp $ */
d163 1
a163 1
	const struct db_val *vp;
a172 1
	vp = v->data;
d174 3
a176 2
	dbv->rec = betoh32(vp->rec);
	dbv->mask = betoh64(vp->mask);
d372 2
a373 1
	rec->res.rec = *(recno_t *)key->data;
@


1.14
log
@Bugfixes from kristaps@@:
(1) Always show architecture-independent manuals,
even when an architecture is specified on the command line.
(2) Do not leak memory when a manual is skipped
because it's the wrong section or architecture.
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.13 2011/12/03 22:47:27 schwarze Exp $ */
d108 1
a108 1
	{ INT_MAX, "any" },
d189 1
a189 1
	size_t		 rc;
d230 1
a230 1
	return(rc);
d357 1
d368 2
a369 2
	left = val->size;
	cp = (char *)val->data;
d371 1
d375 10
a384 1
	INDEX_BREAD(rec->res.type);
a583 1
	free(rec->res.type);
@


1.13
log
@remove useless "#ifdef __linux__" that crept in,
and trivial sync to bsd.lv (two new comments)
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.12 2011/12/03 14:53:12 schwarze Exp $ */
d533 4
a536 2
		if (opts->arch && strcasecmp(opts->arch, r.res.arch))
			continue;
d542 1
a557 1
		memset(&r, 0, sizeof(struct rec));
d565 1
@


1.12
log
@Make the mandocdb(8) format endian-neutral by storing integer data
in network byte order; from kristaps@@.

Hopefully, this finishes the database format.
This commit requires another rebuild of your mandoc databases
by running "sudo mandocdb".
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.11 2011/11/29 22:30:56 schwarze Exp $ */
d27 1
a27 6

#ifdef __linux__
# include <db_185.h>
#else
# include <db.h>
#endif
@


1.11
log
@Sync to bsd.lv, mostly from kristaps@@.
Make `-i' only apply to regular expressions.
For substring matches, always use strcasestr().
Also, improve some manuals and comments.
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.10 2011/11/28 00:16:38 schwarze Exp $ */
d18 1
d118 3
a120 2
static	int	 btree_read(const DBT *,
			const struct mchars *, char **);
d149 1
d164 3
a166 1
btree_read(const DBT *v, const struct mchars *mc, char **buf)
d168 1
d170 3
a172 3
	/* Sanity: are we nil-terminated? */

	assert(v->size > 0);
d174 2
a175 1
	if ('\0' != ((char *)v->data)[(int)v->size - 1])
d178 4
a181 1
	norm_string((char *)v->data, mc, buf);
a454 1
	uint64_t	 mask;
a457 1
	recno_t		 rec;
d460 1
a460 1
	struct db_val	*vbuf;
d480 1
a480 3
		if (key.size < 2 || sizeof(struct db_val) != val.size)
			break;
		if ( ! btree_read(&key, mc, &buf))
a482 4
		vbuf = val.data;
		rec = vbuf->rec;
		mask = vbuf->mask;

d487 1
a487 1
		if ( ! exprmark(expr, buf, mask, NULL))
d497 1
a497 1
			if (rec > rs[leaf].res.rec &&
d500 1
a500 1
			else if (rec < rs[leaf].res.rec &&
d512 1
a512 1
		if (leaf >= 0 && rs[leaf].res.rec == rec) {
d514 1
a514 1
				exprexec(expr, buf, mask, &rs[leaf]);
d524 1
a524 1
		key.data = &rec;
d548 1
a548 1
		exprexec(expr, buf, mask, &rs[tree->len]);
d553 1
a553 1
			if (rec > rs[leaf].res.rec)
d575 1
@


1.10
log
@Implement whatis(1) as a special apropos(1) mode as a part of
the mandoc(1) binary; not yet enabled for the general public.
Intended to replace src/usr.bin/whatis at a later time.
Coded by kristaps@@, with a few tweaks by me.

To test this:
 $ mandocdb  # unless you have already done so earlier
 $ sudo ln -s /usr/bin/mandoc /usr/bin/whatis.m
 $ whatis.m mandoc apropos whatis
 $ whatis.m man
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.9 2011/11/27 23:11:32 schwarze Exp $ */
a54 1
	int		 cs; /* is case-sensitive? */
a695 1
			next->cs = 1;
a745 2
	e.cs = cs;

d817 2
a818 7
		} else if (p->cs) {
			if (NULL == strstr(cp, p->v))
				continue;
		} else {
			if (NULL == strcasestr(cp, p->v))
				continue;
		}
@


1.9
log
@Save the manual type (mdoc, man, or cat) in the index file
of the mandoc databases, as suggested by kristaps@@.
Given the well-structured code, this is surprisingly simple.

This changes the mandoc.index database format.
Run "sudo mandocdb" to regenerate your databases.
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.8 2011/11/26 16:41:35 schwarze Exp $ */
d583 43
d776 1
a776 1
		i = REG_EXTENDED | REG_NOSUB | cs ? 0 : REG_ICASE;
@


1.8
log
@Resync to bsd.lv, most code from kristaps@@.
In particular, support the MANPATH environment variable
and don't confuse index record numbers when working with
multiple mandoc databases at once.
Besides, remove lots of gratuitious code and whitespace differences.
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.7 2011/11/18 01:10:03 schwarze Exp $ */
d369 1
@


1.7
log
@Support parenthised subexpressions in apropos(1);
written by kristaps@@, massive conflict resolution by me.
Lightly tested, putting it in for polishing it in-tree.
This concludes p2k11 for me, thanks robert@@!
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.6 2011/11/17 15:38:27 schwarze Exp $ */
a36 5
struct	rectree {
	struct rec	*node;
	int		 len;
};

d68 5
d128 1
a128 1
static	int	 index_read(const DBT *, const DBT *, 
d136 1
a136 1
			struct mchars *);
d151 1
a151 1
	if (NULL != db) 
d168 1
d179 1
a179 1
 * The magic numbers are from the UTF-8 packaging.  
d244 1
a244 1
	static const char res[] = { '\\', '\t', 
d290 1
a290 1
		/* 
d348 1
a348 1
index_read(const DBT *key, const DBT *val, 
d367 1
d378 1
a378 1
 * Search the mandocdb database for the expression "expr".
d384 2
a385 2
apropos_search(int argc, char *argv[], const struct opts *opts,
		const struct expr *expr, size_t terms, void *arg, 
d395 1
a396 1
	rc = 1;
d398 7
a404 2
	for (i = 0; i < argc; i++) {
		if (chdir(argv[i]))
d406 2
a407 2
		if (0 == single_search(&tree, opts, expr, terms, mc))
			rc = 0;
d411 2
a412 2
	 * Count the matching files
	 * and feed them to the output handler.
d418 1
d420 1
d423 1
a423 1
			memcpy(&ress[mlen++], &tree.node[i].res, 
d425 1
d429 2
d434 2
a435 3
	if (mc)
		mchars_free(mc);

d442 1
a442 1
		struct mchars *mc)
d444 2
a445 1
	int		 root, leaf, rc;
a459 1
	rc      = 0;
d463 7
a469 1
	/* XXX: return fact that we've errored? */
d471 3
a473 13
	if (NULL == (btree = btree_open())) 
		goto out;
	if (NULL == (idx = index_open())) 
		goto out;

	while (0 == (*btree->seq)(btree, &key, &val, R_NEXT)) {
		/* 
		 * Low-water mark for key and value.
		 * The key must have something in it, and the value must
		 * have the correct tags/recno mix.
		 */
		if (key.size < 2 || sizeof(struct db_val) != val.size) 
			goto out;
d475 5
a479 1
			goto out;
d485 1
a485 2
		vbuf = val.data;
		if ( ! exprmark(expr, buf, vbuf->mask, NULL))
a486 1
		rec = vbuf->rec;
d501 1
a501 1
			else 
d512 1
a512 1
				exprexec(expr, buf, vbuf->mask, &rs[leaf]);
d526 1
a526 1
			goto out;
d529 2
a530 2
		if ( ! index_read(&key, &val, mc, &r))
			goto out;
d533 1
d543 2
a544 1
		rs[tree->len].matches = mandoc_calloc(terms, sizeof(int));
d546 1
a546 1
		exprexec(expr, buf, vbuf->mask, &rs[tree->len]);
d557 1
a557 1
		
a560 4
	rc = 1;

out:
	recfree(&r);
d562 2
a563 4
	if (btree)
		(*btree->close)(btree);
	if (idx)
		(*idx->close)(idx);
d566 1
a566 2

	return(rc);
d636 1
a636 1
			log = 1;			
d748 1
a748 1
	
d762 2
a763 1
exprmark(const struct expr *p, const char *cp, uint64_t mask, int *ms)
d790 2
d834 2
a835 1
exprexec(const struct expr *e, const char *cp, uint64_t mask, struct rec *r)
@


1.6
log
@Change the search type mask from 32 to 64 bit such that a full set
of search types can be supported in the future.  While here, replace
a couple of memcpy(3)s by proper, statically type-checked assignments,
and de-obfuscate some magical numbers using sizeof().
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.5 2011/11/17 14:52:32 schwarze Exp $ */
d42 14
d57 9
a65 7
	int		 regex;
	int		 index;
	uint64_t 	 mask;
	int		 and;
	char		*v;
	regex_t	 	 re;
	struct expr	*next;
d118 9
a126 5
static	int	 btree_read(const DBT *, const struct mchars *, char **);
static	int	 exprexecpre(const struct expr *, const char *, uint64_t);
static	void	 exprexecpost(const struct expr *, 
			const char *, uint64_t, int *, size_t);
static	struct expr *exprterm(char *, int, int);
d134 1
a134 1
static	void	 single_search(struct rectree *, const struct opts *,
d365 1
a365 1
	rec->rec = *(recno_t *)key->data;
d367 5
a371 5
	INDEX_BREAD(rec->file);
	INDEX_BREAD(rec->cat);
	INDEX_BREAD(rec->title);
	INDEX_BREAD(rec->arch);
	INDEX_BREAD(rec->desc);
d379 1
d381 1
a381 1
void
d384 1
a384 1
		void (*res)(struct rec *, size_t, void *))
d388 2
a389 2
	struct rec	*recs;
	int		 i, mlen;
a392 2
	/* XXX: error out with bad regexp? */

d394 1
d399 2
a400 1
		single_search(&tree, opts, expr, terms, mc);
d409 1
a409 1
		if (tree.node[i].matches[0])
d411 1
a411 1
	recs = mandoc_malloc(mlen * sizeof(struct rec));
d413 5
a417 5
		if (tree.node[i].matches[0])
			memcpy(&recs[mlen++], &tree.node[i], 
					sizeof(struct rec));
	(*res)(recs, mlen, arg);
	free(recs);
d424 2
d428 1
a428 1
static void
d433 1
a433 1
	int		 root, leaf;
a435 1
	int		 ch;
d438 2
a439 2
	struct rec	*recs;
	struct rec	 srec;
d447 2
a448 1
	recs	= tree->node;
d450 1
a450 1
	memset(&srec, 0, sizeof(struct rec));
d459 1
a459 1
	while (0 == (ch = (*btree->seq)(btree, &key, &val, R_NEXT))) {
d466 1
a466 1
			break;
d468 1
a468 1
			break;
d475 1
a475 1
		if ( ! exprexecpre(expr, buf, vbuf->mask))
d486 6
a491 4
			if (rec > recs[leaf].rec && recs[leaf].rhs >= 0)
				leaf = recs[leaf].rhs;
			else if (rec < recs[leaf].rec && recs[leaf].lhs >= 0)
				leaf = recs[leaf].lhs;
d495 9
a503 5
		if (leaf >= 0 && recs[leaf].rec == rec) {
			if (0 == recs[leaf].matches[0])
				exprexecpost
					(expr, buf, vbuf->mask, 
					 recs[leaf].matches, terms);
d508 3
a510 2
		 * Now we actually extract the manpage's metadata from
		 * the index database.
d517 1
a517 1
			break;
d519 3
a521 3
		srec.lhs = srec.rhs = -1;
		if ( ! index_read(&key, &val, mc, &srec))
			break;
d523 2
a524 1
		if (opts->cat && strcasecmp(opts->cat, srec.cat))
d526 1
a526 1
		if (opts->arch && strcasecmp(opts->arch, srec.arch))
d529 2
a530 2
		tree->node = recs = mandoc_realloc
			(recs, (tree->len + 1) * sizeof(struct rec));
d532 2
a533 3
		memcpy(&recs[tree->len], &srec, sizeof(struct rec));
		recs[tree->len].matches = 
			mandoc_calloc(terms + 1, sizeof(int));
d535 1
a535 3
		exprexecpost
			(expr, buf, vbuf->mask, 
			 recs[tree->len].matches, terms);
d540 2
a541 2
			if (rec > recs[leaf].rec)
				recs[leaf].rhs = tree->len;
d543 1
a543 1
				recs[leaf].lhs = tree->len;
d547 1
a547 1
		memset(&srec, 0, sizeof(struct rec));
d550 1
a550 2

	/* XXX handle database errors? */
d553 1
a553 1
	recfree(&srec);
d561 2
d569 6
a574 1
	free(rec->file);
a575 4
	free(rec->cat);
	free(rec->title);
	free(rec->arch);
	free(rec->desc);
d581 24
d606 1
a606 1
	int		 pos, log;
a608 1
	(*tt) = 0;
d610 1
a610 1
	for (pos = 0; pos < argc; pos++) {
d612 17
d631 1
a631 1
		if (0 == strcmp("-a", argv[pos]))
d633 1
a633 1
		else if (0 == strcmp("-o", argv[pos]))
d636 1
a636 1
		if (log > 0 && ++pos >= argc)
d639 18
a656 2
		if (0 == strcmp("-i", argv[pos])) {
			if (++pos >= argc)
d658 1
a658 1
			next = exprterm(argv[pos], 1, log == 1);
d660 1
a660 1
			next = exprterm(argv[pos], 0, log == 1);
d665 1
d668 2
d685 5
d691 1
a691 1
exprterm(char *buf, int cs, int and)
d700 3
a702 5
	e.and = and;
 
 	/*
 	 * Choose regex or substring match.
	 */
d712 1
a712 3
	/*
	 * Determine the record types to search for.
	 */
d719 1
a719 1
			    strcmp(types[i].name, key))
d728 1
a728 1
		i = REG_EXTENDED | REG_NOSUB | cs ? REG_ICASE : 0;
d746 2
a756 4
/*
 * See if this expression evaluates to true for any terms.
 * Return 1 if any expression evaluates to true, else 0.
 */
d758 1
a758 1
exprexecpre(const struct expr *p, const char *cp, uint64_t mask)
d761 6
a766 2
	for ( ; NULL != p; p = p->next) {
		if ( ! (mask & p->mask))
d768 1
d770 11
a780 3
			if (0 == regexec(&p->re, cp, 0, NULL, 0))
				return(1);
		} else if (NULL != strcasestr(cp, p->v))
d782 2
d785 32
a816 1
	return(0);
d827 1
a827 2
exprexecpost(const struct expr *e, const char *cp, 
		uint64_t mask, int *matches, size_t matchsz)
a828 22
	const struct expr *p;
	int		   match;

	assert(0 == matches[0]);

	for (p = e; p; p = p->next) {
		if ( ! (mask & p->mask))
			continue;
		if (p->regex) {
			if (regexec(&p->re, cp, 0, NULL, 0))
				continue;
		} else if (NULL == strcasestr(cp, p->v))
			continue;

		matches[p->index + 1] = 1;
	}

	for (match = 0, p = e; p && ! match; p = p->next) {
		match = matches[p->index + 1];
		for ( ; p->next && p->next->and; p = p->next)
			match = match && matches[p->next->index + 1];
	}
d830 3
a832 1
	matches[0] = match;
@


1.5
log
@Minimal man.conf(5) _whatdb support for mandocdb(8) and apropos(1),
and add the standard options -M and -m to apropos(1).
Including a bugfix to prevent mandocdb(8) from leaking
database file descriptors.
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.4 2011/11/16 13:23:27 schwarze Exp $ */
d22 1
d45 1
a45 1
	int	 	 mask;
d53 1
a53 1
	int		 mask;
d59 4
d64 4
d70 2
d74 3
d78 5
d85 2
d88 3
d92 2
d103 1
a103 1
static	int	 exprexecpre(const struct expr *, const char *, int);
d105 1
a105 1
			const char *, int, int *, size_t);
d410 1
a410 1
	int		 root, leaf, mask;
d418 1
d442 1
a442 1
		if (key.size < 2 || 8 != val.size) 
a446 2
		mask = *(int *)val.data;

d451 2
a452 1
		if ( ! exprexecpre(expr, buf, mask))
d454 1
a454 2

		memcpy(&rec, val.data + 4, sizeof(recno_t));
d473 1
a473 1
					(expr, buf, mask, 
d506 1
a506 1
			(expr, buf, mask, 
d670 1
a670 1
exprexecpre(const struct expr *p, const char *cp, int mask)
d694 1
a694 1
		int mask, int *matches, size_t matchsz)
@


1.4
log
@Support multiple search terms, and logical operations -a and -o
to combine them.  The default remains -o; usual precedence applies.
No explicit grouping by parentheses yet.
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.3 2011/11/13 11:07:10 schwarze Exp $ */
d24 1
d36 5
d88 3
d335 2
a336 2
apropos_search(const struct opts *opts, const struct expr *expr,
		size_t terms, void *arg, 
d339 46
a384 1
	int		 i, len, root, leaf, mask, mlen;
a386 1
	struct mchars	*mc;
d390 1
a390 1
	struct rec	*recs, *rrecs;
a396 1
	mc	= NULL;
d398 1
a398 2
	recs	= NULL;
	len	= 0;
a401 4
	/* XXX: error out with bad regexp? */

	mc = mchars_alloc();

d473 2
a474 2
		recs = mandoc_realloc
			(recs, (len + 1) * sizeof(struct rec));
d476 2
a477 2
		memcpy(&recs[len], &srec, sizeof(struct rec));
		recs[len].matches = 
d482 1
a482 1
			 recs[len].matches, terms);
d488 1
a488 1
				recs[leaf].rhs = len;
d490 1
a490 1
				recs[leaf].lhs = len;
d492 1
a492 1
			root = len;
d495 1
a495 1
		len++;
d498 1
a498 12
	if (1 == ch) {
		for (mlen = i = 0; i < len; i++)
			if (recs[i].matches[0])
				mlen++;
		rrecs = mandoc_malloc(mlen * sizeof(struct rec));
		for (mlen = i = 0; i < len; i++)
			if (recs[i].matches[0])
				memcpy(&rrecs[mlen++], &recs[i], 
						sizeof(struct rec));
		(*res)(rrecs, mlen, arg);
		free(rrecs);
	}
a499 1
	/* XXX: else?  corrupt database error? */
a500 3
	for (i = 0; i < len; i++)
		recfree(&recs[i]);

a502 2
	if (mc)
		mchars_free(mc);
a508 1
	free(recs);
@


1.3
log
@Rewrite the expression parser for a more concise syntax:

 apropos [search_type[,...]=]substring
 apropos search_type[,...][,i]~regex

... and expression evaluation must take the search type into account.

This allows to:
* drop the global -I option and
* drop the enum match, just using a boolean int.

"go ahead" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.2 2011/11/13 10:40:52 schwarze Exp $ */
d37 1
d39 1
d42 1
d71 4
a74 1
static	int	 exprexec(const struct expr *, char *, int);
d81 1
d327 2
a328 1
		void *arg, void (*res)(struct rec *, size_t, void *))
d330 1
a330 1
	int		 i, len, root, leaf;
d337 1
a337 1
	struct rec	*recs;
d373 7
a379 1
		if ( ! exprexec(expr, buf, *(int *)val.data))
d398 5
a402 1
		if (leaf >= 0 && recs[leaf].rec == rec)
d404 1
d430 6
d451 12
a462 2
	if (1 == ch)
		(*res)(recs, len, arg);
d466 2
a467 7
	for (i = 0; i < len; i++) {
		free(recs[i].file);
		free(recs[i].cat);
		free(recs[i].title);
		free(recs[i].arch);
		free(recs[i].desc);
	}
d469 1
a469 5
	free(srec.file);
	free(srec.cat);
	free(srec.title);
	free(srec.arch);
	free(srec.desc);
d482 12
d495 49
a543 1
exprcomp(int argc, char *argv[])
d545 1
a546 1
	struct expr	 e;
d548 1
a548 1
	int		 i, icase;
d550 1
a550 2
	if (0 >= argc)
		return(NULL);
d552 4
a555 2
	/*
	 * Choose regex or substring match.
d558 1
a558 1
	if (NULL == (e.v = strpbrk(*argv, "=~"))) {
d560 1
a560 1
		e.v = *argv;
a569 1
	icase = 0;
d571 2
a572 6
	if (*argv < e.v) {
		while (NULL != (key = strsep(argv, ","))) {
			if ('i' == key[0] && '\0' == key[1]) {
				icase = REG_ICASE;
				continue;
			}
d583 5
a587 3
	if (e.regex &&
	    regcomp(&e.re, e.v, REG_EXTENDED | REG_NOSUB | icase))
		return(NULL);
d599 11
d611 7
a617 2
	if (NULL == p)
		return;
d619 10
a628 5
	if (p->regex)
		regfree(&p->re);

	free(p->v);
	free(p);
d631 10
a640 2
static int
exprexec(const struct expr *p, char *cp, int mask)
d642 2
d645 19
a663 2
	if ( ! (mask & p->mask))
		return(0);
d665 1
a665 4
	if (p->regex)
		return(0 == regexec(&p->re, cp, 0, NULL, 0));
	else
		return(NULL != strcasestr(cp, p->v));
@


1.2
log
@Inventing new keywords for mostly the same thing when a well-established
set of keywords already exists is a bad idea, so reuse the mdoc(7)
macro names as apropos(1) search types.  This is a gain in brevity
as well.  Some time ago, kristaps@@ agreed in principle.

The search type bit field constants are used by both mandocdb(8) and
apropos(1) and should better stay in sync, so give them their own
header file.
@
text
@d1 1
a1 1
/*	$Id: apropos_db.c,v 1.1 2011/11/13 10:28:38 schwarze Exp $ */
d4 1
a34 7
enum	match {
	MATCH_REGEX,
	MATCH_REGEXCASE,
	MATCH_STR,
	MATCH_STRCASE
};

d36 1
a36 1
	enum match	 match;
d68 1
a68 1
static	int	 exprexec(const struct expr *, char *);
d365 1
a365 1
		if ( ! exprexec(expr, buf))
d457 1
a457 1
exprcomp(int cs, char *argv[], int argc)
d461 2
a462 1
	int		 i, pos, ch;
d464 1
a464 3
	pos = 0;

	if (pos > argc)
d467 11
a477 3
	for (i = 0; 0 != types[i].mask; i++)
		if (0 == strcmp(types[i].name, argv[pos]))
			break;
d479 21
a499 2
	if (0 == (e.mask = types[i].mask))
		return(NULL);
d501 2
a502 1
	if (++pos > argc--)
d505 1
a505 28
	if ('-' != *argv[pos]) 
		e.match = cs ? MATCH_STRCASE : MATCH_STR;
	else if (0 == strcmp("-eq", argv[pos]))
		e.match = cs ? MATCH_STRCASE : MATCH_STR;
	else if (0 == strcmp("-ieq", argv[pos]))
		e.match = MATCH_STRCASE;
	else if (0 == strcmp("-re", argv[pos]))
		e.match = cs ? MATCH_REGEXCASE : MATCH_REGEX;
	else if (0 == strcmp("-ire", argv[pos]))
		e.match = MATCH_REGEXCASE;
	else
		return(NULL);

	if ('-' == *argv[pos])
		pos++;

	if (pos > argc--)
		return(NULL);

	e.v = mandoc_strdup(argv[pos]);

	if (MATCH_REGEX == e.match || MATCH_REGEXCASE == e.match) {
		ch = REG_EXTENDED | REG_NOSUB;
		if (MATCH_REGEXCASE == e.match)
			ch |= REG_ICASE;
		if (regcomp(&e.re, e.v, ch))
			return(NULL);
	}
d519 1
a519 1
	if (MATCH_REGEX == p->match)
d527 1
a527 1
exprexec(const struct expr *p, char *cp)
d530 2
a531 4
	if (MATCH_STR == p->match)
		return(0 == strcmp(p->v, cp));
	else if (MATCH_STRCASE == p->match)
		return(0 == strcasecmp(p->v, cp));
d533 4
a536 2
	assert(MATCH_REGEX == p->match);
	return(0 == regexec(&p->re, cp, 0, NULL, 0));
@


1.1
log
@Split the common code to be reused by other mandocdb clients,
for example the future man.cgi, out of apropos.c (which still
contains the apropos(1) main program, command line handling, and
the terminal output formatter) into apropos_db.{h,c} (which now
contains the database searching backend code).

... and actually commit the two new files.  Oops.
@
text
@d1 1
a1 1
/*	$Id: db.c,v 1.1 2011/11/09 01:24:23 kristaps Exp $ */
d30 1
d54 15
a68 14
	{ TYPE_NAME, "name" },
	{ TYPE_FUNCTION, "func" },
	{ TYPE_UTILITY, "utility" },
	{ TYPE_INCLUDES, "incl" },
	{ TYPE_VARIABLE, "var" },
	{ TYPE_STANDARD, "stand" },
	{ TYPE_AUTHOR, "auth" },
	{ TYPE_CONFIG, "conf" },
	{ TYPE_DESC, "desc" },
	{ TYPE_XREF, "xref" },
	{ TYPE_PATH, "path" },
	{ TYPE_ENV, "env" },
	{ TYPE_ERR, "err" },
	{ INT_MAX, "all" },
d94 1
a94 1
	db = dbopen("mandoc.db", O_RDONLY, 0, DB_BTREE, &info);
d279 1
a279 1
	db = dbopen("mandoc.index", O_RDONLY, 0, DB_RECNO, NULL);
@

