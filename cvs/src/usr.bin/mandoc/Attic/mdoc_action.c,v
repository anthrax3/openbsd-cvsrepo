head	1.48;
access;
symbols
	OPENBSD_4_8:1.44.0.2
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9;
locks; strict;
comment	@ * @;


1.48
date	2010.12.01.22.02.29;	author schwarze;	state dead;
branches;
next	1.47;

1.47
date	2010.10.26.22.48.07;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2010.10.24.18.15.43;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2010.10.16.13.38.29;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2010.07.31.21.43.07;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.01.22.31.52;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.26.17.56.43;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.06.20.30.08;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.06.18.08.41;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.24.02.24.05;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.24.00.00.10;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.23.22.45.00;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.15.18.25.51;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.15.16.48.12;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.14.19.52.43;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2010.05.14.14.47.44;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.14.01.54.37;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.07.23.15.05;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.04.17.36.57;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.02.12.39.47;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2010.03.02.00.38.59;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.23.22.30.17;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.19.16.27.52;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.19.15.44.01;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.21.21.11.37;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.22.22.50.17;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.22.15.36.58;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.22.15.29.23;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.09.19.59.13;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.26.01.59.46;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.18.19.44.38;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.12.22.35.08;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.12.21.45.44;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.12.21.08.29;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.12.20.30.27;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.06.21.40.30;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.27.12.43.11;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.23.23.02.54;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.21.19.40.15;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.21.19.09.58;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.19.07.20.19;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.18.23.34.53;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.18.01.19.02;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.14.23.00.57;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.20.30.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Merge mdoc_action.c into mdoc_validate.c, because having two places to do
basically the same things just causes code duplication and confusion.
Work by kristaps@@, including a few bugfixes he found during the merge,
and reapplying OpenBSD changes on top.
@
text
@/*	$Id: mdoc_action.c,v 1.47 2010/10/26 22:48:07 schwarze Exp $ */
/*
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifndef	OSNAME
#include <sys/utsname.h>
#endif

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mandoc.h"
#include "libmdoc.h"
#include "libmandoc.h"

#include "out.h"
#include "term.h"
#include "tbl.h"

/* 
 * FIXME: this file is deprecated.  All future "actions" should be
 * pushed into mdoc_validate.c.
 */

#define	POST_ARGS struct mdoc *m, struct mdoc_node *n
#define	PRE_ARGS  struct mdoc *m, struct mdoc_node *n

#define	NUMSIZ	  32
#define	DATESIZE  32

struct	actions {
	int	(*pre)(PRE_ARGS);
	int	(*post)(POST_ARGS);
};

static	int	  concat(struct mdoc *, char *,
			const struct mdoc_node *, size_t);
static	inline int order_rs(enum mdoct);

static	int	  post_ar(POST_ARGS);
static	int	  post_at(POST_ARGS);
static	int	  post_bl(POST_ARGS);
static	int	  post_bl_head(POST_ARGS);
static	int	  post_bl_tagwidth(POST_ARGS);
static	int	  post_bl_width(POST_ARGS);
static	int	  post_dd(POST_ARGS);
static	int	  post_display(POST_ARGS);
static	int	  post_dt(POST_ARGS);
static	int	  post_lb(POST_ARGS);
static	int	  post_li(POST_ARGS);
static	int	  post_nm(POST_ARGS);
static	int	  post_os(POST_ARGS);
static	int	  post_pa(POST_ARGS);
static	int	  post_prol(POST_ARGS);
static	int	  post_rs(POST_ARGS);
static	int	  post_sh(POST_ARGS);
static	int	  post_st(POST_ARGS);
static	int	  post_std(POST_ARGS);

static	int	  pre_bd(PRE_ARGS);
static	int	  pre_dl(PRE_ARGS);
static	int	  pre_ts(PRE_ARGS);

static	const struct actions mdoc_actions[MDOC_MAX] = {
	{ NULL, NULL }, /* Ap */
	{ NULL, post_dd }, /* Dd */ 
	{ NULL, post_dt }, /* Dt */ 
	{ NULL, post_os }, /* Os */ 
	{ NULL, post_sh }, /* Sh */ 
	{ NULL, NULL }, /* Ss */ 
	{ NULL, NULL }, /* Pp */ 
	{ NULL, NULL }, /* D1 */
	{ pre_dl, post_display }, /* Dl */
	{ pre_bd, post_display }, /* Bd */ 
	{ NULL, NULL }, /* Ed */
	{ NULL, post_bl }, /* Bl */ 
	{ NULL, NULL }, /* El */
	{ NULL, NULL }, /* It */
	{ NULL, NULL }, /* Ad */ 
	{ NULL, NULL }, /* An */
	{ NULL, post_ar }, /* Ar */
	{ NULL, NULL }, /* Cd */
	{ NULL, NULL }, /* Cm */
	{ NULL, NULL }, /* Dv */ 
	{ NULL, NULL }, /* Er */ 
	{ NULL, NULL }, /* Ev */ 
	{ NULL, post_std }, /* Ex */
	{ NULL, NULL }, /* Fa */ 
	{ NULL, NULL }, /* Fd */ 
	{ NULL, NULL }, /* Fl */
	{ NULL, NULL }, /* Fn */ 
	{ NULL, NULL }, /* Ft */ 
	{ NULL, NULL }, /* Ic */ 
	{ NULL, NULL }, /* In */ 
	{ NULL, post_li }, /* Li */
	{ NULL, NULL }, /* Nd */ 
	{ NULL, post_nm }, /* Nm */ 
	{ NULL, NULL }, /* Op */
	{ NULL, NULL }, /* Ot */
	{ NULL, post_pa }, /* Pa */
	{ NULL, post_std }, /* Rv */
	{ NULL, post_st }, /* St */
	{ NULL, NULL }, /* Va */
	{ NULL, NULL }, /* Vt */ 
	{ NULL, NULL }, /* Xr */
	{ NULL, NULL }, /* %A */
	{ NULL, NULL }, /* %B */
	{ NULL, NULL }, /* %D */
	{ NULL, NULL }, /* %I */
	{ NULL, NULL }, /* %J */
	{ NULL, NULL }, /* %N */
	{ NULL, NULL }, /* %O */
	{ NULL, NULL }, /* %P */
	{ NULL, NULL }, /* %R */
	{ NULL, NULL }, /* %T */
	{ NULL, NULL }, /* %V */
	{ NULL, NULL }, /* Ac */
	{ NULL, NULL }, /* Ao */
	{ NULL, NULL }, /* Aq */
	{ NULL, post_at }, /* At */ 
	{ NULL, NULL }, /* Bc */
	{ NULL, NULL }, /* Bf */ 
	{ NULL, NULL }, /* Bo */
	{ NULL, NULL }, /* Bq */
	{ NULL, NULL }, /* Bsx */
	{ NULL, NULL }, /* Bx */
	{ NULL, NULL }, /* Db */
	{ NULL, NULL }, /* Dc */
	{ NULL, NULL }, /* Do */
	{ NULL, NULL }, /* Dq */
	{ NULL, NULL }, /* Ec */
	{ NULL, NULL }, /* Ef */
	{ NULL, NULL }, /* Em */ 
	{ NULL, NULL }, /* Eo */
	{ NULL, NULL }, /* Fx */
	{ NULL, NULL }, /* Ms */
	{ NULL, NULL }, /* No */
	{ NULL, NULL }, /* Ns */
	{ NULL, NULL }, /* Nx */
	{ NULL, NULL }, /* Ox */
	{ NULL, NULL }, /* Pc */
	{ NULL, NULL }, /* Pf */
	{ NULL, NULL }, /* Po */
	{ NULL, NULL }, /* Pq */
	{ NULL, NULL }, /* Qc */
	{ NULL, NULL }, /* Ql */
	{ NULL, NULL }, /* Qo */
	{ NULL, NULL }, /* Qq */
	{ NULL, NULL }, /* Re */
	{ NULL, post_rs }, /* Rs */
	{ NULL, NULL }, /* Sc */
	{ NULL, NULL }, /* So */
	{ NULL, NULL }, /* Sq */
	{ NULL, NULL }, /* Sm */
	{ NULL, NULL }, /* Sx */
	{ NULL, NULL }, /* Sy */
	{ NULL, NULL }, /* Tn */
	{ NULL, NULL }, /* Ux */
	{ NULL, NULL }, /* Xc */
	{ NULL, NULL }, /* Xo */
	{ NULL, NULL }, /* Fo */ 
	{ NULL, NULL }, /* Fc */ 
	{ NULL, NULL }, /* Oo */
	{ NULL, NULL }, /* Oc */
	{ NULL, NULL }, /* Bk */
	{ NULL, NULL }, /* Ek */
	{ NULL, NULL }, /* Bt */
	{ NULL, NULL }, /* Hf */
	{ NULL, NULL }, /* Fr */
	{ NULL, NULL }, /* Ud */
	{ NULL, post_lb }, /* Lb */
	{ NULL, NULL }, /* Lp */
	{ NULL, NULL }, /* Lk */
	{ NULL, NULL }, /* Mt */
	{ NULL, NULL }, /* Brq */
	{ NULL, NULL }, /* Bro */
	{ NULL, NULL }, /* Brc */
	{ NULL, NULL }, /* %C */
	{ NULL, NULL }, /* Es */
	{ NULL, NULL }, /* En */
	{ NULL, NULL }, /* Dx */
	{ NULL, NULL }, /* %Q */
	{ NULL, NULL }, /* br */
	{ NULL, NULL }, /* sp */
	{ NULL, NULL }, /* %U */
	{ NULL, NULL }, /* Ta */
	{ pre_ts, NULL }, /* TS */
	{ NULL, NULL }, /* TE */
};

#define	RSORD_MAX 14

static	const enum mdoct rsord[RSORD_MAX] = {
	MDOC__A,
	MDOC__T,
	MDOC__B,
	MDOC__I,
	MDOC__J,
	MDOC__R,
	MDOC__N,
	MDOC__V,
	MDOC__P,
	MDOC__Q,
	MDOC__D,
	MDOC__O,
	MDOC__C,
	MDOC__U
};


int
mdoc_action_pre(struct mdoc *m, struct mdoc_node *n)
{

	switch (n->type) {
	case (MDOC_ROOT):
		/* FALLTHROUGH */
	case (MDOC_TEXT):
		return(1);
	default:
		break;
	}

	if (NULL == mdoc_actions[n->tok].pre)
		return(1);
	return((*mdoc_actions[n->tok].pre)(m, n));
}


int
mdoc_action_post(struct mdoc *m)
{

	if (MDOC_ACTED & m->last->flags)
		return(1);
	m->last->flags |= MDOC_ACTED;

	switch (m->last->type) {
	case (MDOC_TEXT):
		/* FALLTHROUGH */
	case (MDOC_ROOT):
		return(1);
	default:
		break;
	}

	if (NULL == mdoc_actions[m->last->tok].post)
		return(1);
	return((*mdoc_actions[m->last->tok].post)(m, m->last));
}


/*
 * Concatenate sibling nodes together.  All siblings must be of type
 * MDOC_TEXT or an assertion is raised.  Concatenation is separated by a
 * single whitespace.
 */
static int
concat(struct mdoc *m, char *p, const struct mdoc_node *n, size_t sz)
{

	assert(sz);
	p[0] = '\0';
	for ( ; n; n = n->next) {
		assert(MDOC_TEXT == n->type);
		/*
		 * XXX: yes, these can technically be resized, but it's
		 * highly unlikely that we're going to get here, so let
		 * it slip for now.
		 */
		if (strlcat(p, n->string, sz) >= sz) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}
		if (NULL == n->next)
			continue;
		if (strlcat(p, " ", sz) >= sz) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}
	}

	return(1);
}


/*
 * Macros accepting `-std' as an argument have the name of the current
 * document (`Nm') filled in as the argument if it's not provided.
 */
static int
post_std(POST_ARGS)
{
	struct mdoc_node *nn;

	if (n->child)
		return(1);
	if (NULL == m->meta.name)
		return(1);
	
	nn = n;
	m->next = MDOC_NEXT_CHILD;

	if ( ! mdoc_word_alloc(m, n->line, n->pos, m->meta.name))
		return(0);
	m->last = nn;
	return(1);
}


/*
 * The `Nm' macro's first use sets the name of the document.  See also
 * post_std(), etc.
 */
static int
post_nm(POST_ARGS)
{
	char		 buf[BUFSIZ];

	if (m->meta.name)
		return(1);
	if ( ! concat(m, buf, n->child, BUFSIZ))
		return(0);
	m->meta.name = mandoc_strdup(buf);
	return(1);
}


/*
 * Look up the value of `Lb' for matching predefined strings.  If it has
 * one, then substitute the current value for the formatted value.  Note
 * that the lookup may fail (we can provide arbitrary strings).
 */
/* ARGSUSED */
static int
post_lb(POST_ARGS)
{
	const char	*p;
	char		*buf;
	size_t		 sz;

	assert(MDOC_TEXT == n->child->type);
	p = mdoc_a2lib(n->child->string);

	if (p) {
		free(n->child->string);
		n->child->string = mandoc_strdup(p);
		return(1);
	}

	sz = strlen(n->child->string) +
		2 + strlen("\\(lqlibrary\\(rq");
	buf = mandoc_malloc(sz);
	snprintf(buf, sz, "library \\(lq%s\\(rq", n->child->string);
	free(n->child->string);
	n->child->string = buf;
	return(1);
}


/*
 * Substitute the value of `St' for the corresponding formatted string.
 * We're guaranteed that this exists (it's been verified during the
 * validation phase).
 */
/* ARGSUSED */
static int
post_st(POST_ARGS)
{
	const char	*p;

	assert(MDOC_TEXT == n->child->type);
	p = mdoc_a2st(n->child->string);
	if (p != NULL) {
		free(n->child->string);
		n->child->string = mandoc_strdup(p);
	}
	return(1);
}


/*
 * Look up the standard string in a table.  We know that it exists from
 * the validation phase, so assert on failure.  If a standard key wasn't
 * supplied, supply the default ``AT&T UNIX''.
 */
static int
post_at(POST_ARGS)
{
	struct mdoc_node *nn;
	const char	 *p, *q;
	char		 *buf;
	size_t		  sz;

	if (n->child) {
		assert(MDOC_TEXT == n->child->type);
		p = mdoc_a2att(n->child->string);
		if (p) {
			free(n->child->string);
			n->child->string = mandoc_strdup(p);
		} else {
			p = "AT&T UNIX ";
			q = n->child->string;
			sz = strlen(p) + strlen(q) + 1;
			buf = mandoc_malloc(sz);
			strlcpy(buf, p, sz);
			strlcat(buf, q, sz);
			free(n->child->string);
			n->child->string = buf;
		}
		return(1);
	}

	nn = n;
	m->next = MDOC_NEXT_CHILD;
	if ( ! mdoc_word_alloc(m, nn->line, nn->pos, "AT&T UNIX"))
		return(0);
	m->last = nn;
	return(1);
}


/*
 * Mark the current section.  The ``named'' section (lastnamed) is set
 * whenever the current section isn't a custom section--we use this to
 * keep track of section ordering.  Also check that the section is
 * allowed within the document's manual section.
 */
static int
post_sh(POST_ARGS)
{
	enum mdoc_sec	 sec;
	char		 buf[BUFSIZ];

	if (MDOC_HEAD != n->type)
		return(1);

	if ( ! concat(m, buf, n->child, BUFSIZ))
		return(0);
	sec = mdoc_str2sec(buf);
	/*
	 * The first section should always make us move into a non-new
	 * state.
	 */
	if (SEC_NONE == m->lastnamed || SEC_CUSTOM != sec)
		m->lastnamed = sec;

	/*
	 * Switch the parser's SYNOPSIS mode, to be copied
	 * into individual nodes when creating them.
	 * Note that this mode can also be set and unset
	 * using the roff nS register.
	 */
	if (SEC_SYNOPSIS == sec)
		m->flags |= MDOC_SYNOPSIS;
	else
		m->flags &= ~MDOC_SYNOPSIS;

	/* Some sections only live in certain manual sections. */

	switch ((m->lastsec = sec)) {
	case (SEC_RETURN_VALUES):
		/* FALLTHROUGH */
	case (SEC_ERRORS):
		assert(m->meta.msec);
		if (*m->meta.msec == '2')
			break;
		if (*m->meta.msec == '3')
			break;
		if (*m->meta.msec == '9')
			break;
		return(mdoc_nmsg(m, n, MANDOCERR_SECMSEC));
	default:
		break;
	}
	return(1);
}


/*
 * Parse out the contents of `Dt'.  See in-line documentation for how we
 * handle the various fields of this macro.
 */
static int
post_dt(POST_ARGS)
{
	struct mdoc_node *nn;
	const char	 *cp;

	if (m->meta.title)
		free(m->meta.title);
	if (m->meta.vol)
		free(m->meta.vol);
	if (m->meta.arch)
		free(m->meta.arch);

	m->meta.title = m->meta.vol = m->meta.arch = NULL;
	/* Handles: `.Dt' 
	 *   --> title = unknown, volume = local, msec = 0, arch = NULL
	 */

	if (NULL == (nn = n->child)) {
		/* XXX: make these macro values. */
		/* FIXME: warn about missing values. */
		m->meta.title = mandoc_strdup("UNKNOWN");
		m->meta.vol = mandoc_strdup("LOCAL");
		m->meta.msec = mandoc_strdup("1");
		return(post_prol(m, n));
	}

	/* Handles: `.Dt TITLE' 
	 *   --> title = TITLE, volume = local, msec = 0, arch = NULL
	 */

	m->meta.title = mandoc_strdup
		('\0' == nn->string[0] ? "UNKNOWN" : nn->string);

	if (NULL == (nn = nn->next)) {
		/* FIXME: warn about missing msec. */
		/* XXX: make this a macro value. */
		m->meta.vol = mandoc_strdup("LOCAL");
		m->meta.msec = mandoc_strdup("1");
		return(post_prol(m, n));
	}

	/* Handles: `.Dt TITLE SEC'
	 *   --> title = TITLE, volume = SEC is msec ? 
	 *           format(msec) : SEC,
	 *       msec = SEC is msec ? atoi(msec) : 0,
	 *       arch = NULL
	 */

	cp = mdoc_a2msec(nn->string);
	if (cp) {
		m->meta.vol = mandoc_strdup(cp);
		m->meta.msec = mandoc_strdup(nn->string);
	} else if (mdoc_nmsg(m, n, MANDOCERR_BADMSEC)) {
		m->meta.vol = mandoc_strdup(nn->string);
		m->meta.msec = mandoc_strdup(nn->string);
	} else
		return(0);

	if (NULL == (nn = nn->next))
		return(post_prol(m, n));

	/* Handles: `.Dt TITLE SEC VOL'
	 *   --> title = TITLE, volume = VOL is vol ?
	 *       format(VOL) : 
	 *           VOL is arch ? format(arch) : 
	 *               VOL
	 */

	cp = mdoc_a2vol(nn->string);
	if (cp) {
		free(m->meta.vol);
		m->meta.vol = mandoc_strdup(cp);
	} else {
		/* FIXME: warn about bad arch. */
		cp = mdoc_a2arch(nn->string);
		if (NULL == cp) {
			free(m->meta.vol);
			m->meta.vol = mandoc_strdup(nn->string);
		} else 
			m->meta.arch = mandoc_strdup(cp);
	}	

	/* Ignore any subsequent parameters... */
	/* FIXME: warn about subsequent parameters. */

	return(post_prol(m, n));
}


/*
 * Set the operating system by way of the `Os' macro.  Note that if an
 * argument isn't provided and -DOSNAME="\"foo\"" is provided during
 * compilation, this value will be used instead of filling in "sysname
 * release" from uname().
 */
static int
post_os(POST_ARGS)
{
	char		  buf[BUFSIZ];
#ifndef OSNAME
	struct utsname	  utsname;
#endif

	free(m->meta.os);

	if ( ! concat(m, buf, n->child, BUFSIZ))
		return(0);

	/* XXX: yes, these can all be dynamically-adjusted buffers, but
	 * it's really not worth the extra hackery.
	 */

	if ('\0' == buf[0]) {
#ifdef OSNAME
		if (strlcat(buf, OSNAME, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}
#else /*!OSNAME */
		if (uname(&utsname)) {
			mdoc_nmsg(m, n, MANDOCERR_UNAME);
			m->meta.os = mandoc_strdup("UNKNOWN");
			return(post_prol(m, n));
		}

		if (strlcat(buf, utsname.sysname, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}
		if (strlcat(buf, " ", BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}
		if (strlcat(buf, utsname.release, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}
#endif /*!OSNAME*/
	}

	m->meta.os = mandoc_strdup(buf);
	return(post_prol(m, n));
}


/*
 * Calculate the -width for a `Bl -tag' list if it hasn't been provided.
 * Uses the first head macro.  NOTE AGAIN: this is ONLY if the -width
 * argument has NOT been provided.  See post_bl_width() for converting
 * the -width string.
 */
static int
post_bl_tagwidth(POST_ARGS)
{
	struct mdoc_node *nn;
	size_t		  sz, ssz;
	int		  i;
	char		  buf[NUMSIZ];

	sz = 10;

	for (nn = n->body->child; nn; nn = nn->next) {
		if (MDOC_It != nn->tok)
			continue;

		assert(MDOC_BLOCK == nn->type);
		nn = nn->head->child;

		if (nn == NULL)
			break;

		if (MDOC_TEXT == nn->type) {
			sz = strlen(nn->string) + 1;
			break;
		}

		if (0 != (ssz = mdoc_macro2len(nn->tok)))
			sz = ssz;

		break;
	} 

	/* Defaults to ten ens. */

	snprintf(buf, NUMSIZ, "%zun", sz);

	/*
	 * We have to dynamically add this to the macro's argument list.
	 * We're guaranteed that a MDOC_Width doesn't already exist.
	 */

	assert(n->args);
	i = (int)(n->args->argc)++;

	n->args->argv = mandoc_realloc(n->args->argv, 
			n->args->argc * sizeof(struct mdoc_argv));

	n->args->argv[i].arg = MDOC_Width;
	n->args->argv[i].line = n->line;
	n->args->argv[i].pos = n->pos;
	n->args->argv[i].sz = 1;
	n->args->argv[i].value = mandoc_malloc(sizeof(char *));
	n->args->argv[i].value[0] = mandoc_strdup(buf);

	/* Set our width! */
	n->data.Bl->width = n->args->argv[i].value[0];
	return(1);
}


/*
 * Calculate the real width of a list from the -width string, which may
 * contain a macro (with a known default width), a literal string, or a
 * scaling width.
 */
static int
post_bl_width(POST_ARGS)
{
	size_t		  width;
	int		  i;
	enum mdoct	  tok;
	char		  buf[NUMSIZ];

	/*
	 * If the value to -width is a macro, then we re-write it to be
	 * the macro's width as set in share/tmac/mdoc/doc-common.
	 */

	if (0 == strcmp(n->data.Bl->width, "Ds"))
		width = 6;
	else if (MDOC_MAX == (tok = mdoc_hash_find(n->data.Bl->width)))
		return(1);
	else if (0 == (width = mdoc_macro2len(tok))) 
		return(mdoc_nmsg(m, n, MANDOCERR_BADWIDTH));

	/* The value already exists: free and reallocate it. */

	assert(n->args);

	for (i = 0; i < (int)n->args->argc; i++) 
		if (MDOC_Width == n->args->argv[i].arg)
			break;

	assert(i < (int)n->args->argc);

	snprintf(buf, NUMSIZ, "%zun", width);
	free(n->args->argv[i].value[0]);
	n->args->argv[i].value[0] = mandoc_strdup(buf);

	/* Set our width! */
	n->data.Bl->width = n->args->argv[i].value[0];
	return(1);
}


/*
 * Do processing for -column lists, which can have two distinct styles
 * of invocation.  Merge this two styles into a consistent form.
 */
/* ARGSUSED */
static int
post_bl_head(POST_ARGS)
{
	int			 i, c;
	struct mdoc_node	*np, *nn, *nnp;

	if (LIST_column != n->data.Bl->type)
		return(1);
	else if (NULL == n->child)
		return(1);

	np = n->parent;
	assert(np->args);

	for (c = 0; c < (int)np->args->argc; c++) 
		if (MDOC_Column == np->args->argv[c].arg)
			break;

	assert(c < (int)np->args->argc);
	assert(0 == np->args->argv[c].sz);

	/*
	 * Accomodate for new-style groff column syntax.  Shuffle the
	 * child nodes, all of which must be TEXT, as arguments for the
	 * column field.  Then, delete the head children.
	 */

	np->args->argv[c].sz = (size_t)n->nchild;
	np->args->argv[c].value = mandoc_malloc
		((size_t)n->nchild * sizeof(char *));

	n->data.Bl->ncols = np->args->argv[c].sz;
	n->data.Bl->cols = (const char **)np->args->argv[c].value;

	for (i = 0, nn = n->child; nn; i++) {
		np->args->argv[c].value[i] = nn->string;
		nn->string = NULL;
		nnp = nn;
		nn = nn->next;
		mdoc_node_delete(NULL, nnp);
	}

	n->nchild = 0;
	n->child = NULL;
	return(1);
}


static int
post_bl(POST_ARGS)
{

	if (MDOC_HEAD == n->type)
		return(post_bl_head(m, n));
	if (MDOC_BLOCK != n->type)
		return(1);

	/*
	 * These are fairly complicated, so we've broken them into two
	 * functions.  post_bl_tagwidth() is called when a -tag is
	 * specified, but no -width (it must be guessed).  The second
	 * when a -width is specified (macro indicators must be
	 * rewritten into real lengths).
	 */

	if (LIST_tag == n->data.Bl->type && NULL == n->data.Bl->width) {
		if ( ! post_bl_tagwidth(m, n))
			return(0);
	} else if (NULL != n->data.Bl->width) {
		if ( ! post_bl_width(m, n))
			return(0);
	} else 
		return(1);

	assert(n->data.Bl->width);
	return(1);
}


/*
 * The `Pa' macro defaults to a tilde if no value is provided as an
 * argument.
 */
static int
post_pa(POST_ARGS)
{
	struct mdoc_node *np;

	if (n->child)
		return(1);
	
	np = n;
	m->next = MDOC_NEXT_CHILD;
	if ( ! mdoc_word_alloc(m, n->line, n->pos, "~"))
		return(0);
	m->last = np;
	return(1);
}


/*
 * Empty `Li' macros get an empty string to make front-ends add an extra
 * space.
 */
static int
post_li(POST_ARGS)
{
	struct mdoc_node *np;

	if (n->child)
		return(1);
	
	np = n;
	m->next = MDOC_NEXT_CHILD;
	if ( ! mdoc_word_alloc(m, n->line, n->pos, ""))
		return(0);
	m->last = np;
	return(1);
}


/*
 * The `Ar' macro defaults to two strings "file ..." if no value is
 * provided as an argument.
 */
static int
post_ar(POST_ARGS)
{
	struct mdoc_node *np;

	if (n->child)
		return(1);
	
	np = n;
	m->next = MDOC_NEXT_CHILD;
	/* XXX: make into macro values. */
	if ( ! mdoc_word_alloc(m, n->line, n->pos, "file"))
		return(0);
	if ( ! mdoc_word_alloc(m, n->line, n->pos, "..."))
		return(0);
	m->last = np;
	return(1);
}


/*
 * Parse the date field in `Dd'.
 */
static int
post_dd(POST_ARGS)
{
	char		buf[DATESIZE];

	if (NULL == n->child) {
		m->meta.date = time(NULL);
		return(post_prol(m, n));
	}

	if ( ! concat(m, buf, n->child, DATESIZE))
		return(0);

	m->meta.date = mandoc_a2time
		(MTIME_MDOCDATE | MTIME_CANONICAL, buf);

	if (0 == m->meta.date) {
		if ( ! mdoc_nmsg(m, n, MANDOCERR_BADDATE))
			return(0);
		m->meta.date = time(NULL);
	}

	return(post_prol(m, n));
}


/*
 * Remove prologue macros from the document after they're processed.
 * The final document uses mdoc_meta for these values and discards the
 * originals.
 */
static int
post_prol(POST_ARGS)
{

	mdoc_node_delete(m, n);
	if (m->meta.title && m->meta.date && m->meta.os)
		m->flags |= MDOC_PBODY;
	return(1);
}


/*
 * Trigger a literal context.
 */
static int
pre_dl(PRE_ARGS)
{

	if (MDOC_BODY == n->type)
		m->flags |= MDOC_LITERAL;
	return(1);
}


static int
pre_bd(PRE_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);

	assert(n->data.Bd);
	if (DISP_literal == n->data.Bd->type)
		m->flags |= MDOC_LITERAL;
	if (DISP_unfilled == n->data.Bd->type)
		m->flags |= MDOC_LITERAL;

	return(1);
}


/* ARGSUSED */
static int
pre_ts(PRE_ARGS)
{

	if (MDOC_BLOCK == n->type)
		n->data.TS = tbl_alloc();

	return(1);
}


static int
post_display(POST_ARGS)
{

	if (MDOC_BODY == n->type)
		m->flags &= ~MDOC_LITERAL;
	return(1);
}


static inline int
order_rs(enum mdoct t)
{
	int		i;

	for (i = 0; i < (int)RSORD_MAX; i++)
		if (rsord[i] == t)
			return(i);

	abort();
	/* NOTREACHED */
}


/* ARGSUSED */
static int
post_rs(POST_ARGS)
{
	struct mdoc_node	*nn, *next, *prev;
	int			 o;

	if (MDOC_BLOCK != n->type)
		return(1);

	assert(n->body->child);
	for (next = NULL, nn = n->body->child->next; nn; nn = next) {
		o = order_rs(nn->tok);

		/* Remove `nn' from the chain. */
		next = nn->next;
		if (next)
			next->prev = nn->prev;

		prev = nn->prev;
		if (prev)
			prev->next = nn->next;

		nn->prev = nn->next = NULL;

		/* 
		 * Scan back until we reach a node that's ordered before
		 * us, then set ourselves as being the next. 
		 */
		for ( ; prev; prev = prev->prev)
			if (order_rs(prev->tok) <= o)
				break;

		nn->prev = prev;
		if (prev) {
			if (prev->next)
				prev->next->prev = nn;
			nn->next = prev->next;
			prev->next = nn;
			continue;
		} 

		n->body->child->prev = nn;
		nn->next = n->body->child;
		n->body->child = nn;
	}
	return(1);
}
@


1.47
log
@Downgrade nearly 20 ERRORS to WARNINGS.
All these indicate problems in the mdoc(7) or man(7) source code,
but they can't cause relevant information loss or clobbered formatting.
While here, error message improve wording and make it more uniform,
don't throw MANDOCERR_NOWIDTHARG twice when there is one single issue,
and consolidate MANDOCERR_WIDTHARG into MANDOCERR_IGNARGV.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.46 2010/10/24 18:15:43 schwarze Exp $ */
@


1.46
log
@Do not throw FATAL errors when there is no need to:
 - when encountering nested displays (.Bd containing .Bd, .D1, .D1)
 - when a block end macro was forgotten
 - when ending a block that was never started
 - when the uname(3) system call failed
along with a little related cleanup
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.45 2010/10/16 13:38:29 schwarze Exp $ */
d668 1
a668 4
		if (nn == NULL) {
			/* No -width for .Bl and first .It is emtpy */
			if ( ! mdoc_nmsg(m, n, MANDOCERR_NOWIDTHARG))
				return(0);
a669 1
		}
a677 2
		else if ( ! mdoc_nmsg(m, n, MANDOCERR_NOWIDTHARG))
			return(0);
@


1.45
log
@Support tbl(1) code embedded into mdoc(7) input files.
Very similar to what i have done in man(7) yesterday.
Allows to build cpu(4) on HPPA, wi(4), and phantasia(6).
Now we are able to build all tbl code in base.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.44 2010/07/31 21:43:07 schwarze Exp $ */
d603 1
a603 2
	if (m->meta.os)
		free(m->meta.os);
d619 5
a623 2
		if (-1 == uname(&utsname))
			return(mdoc_nmsg(m, n, MANDOCERR_UTSNAME));
d629 1
a629 1
		if (strlcat(buf, " ", 64) >= BUFSIZ) {
@


1.44
log
@Merge bsd.lv version 1.10.5: last larger batch of bug fixes before release.
NOT including Kristaps' .Bd -literal changes which cause regressions.
Features:
* -Tpdf now fully working
Bugfixes:
* proper handling of quoted strings by .ds in roff(7)
* allow empty .Dd
* make .Sm start no-spacing after the first output word
* underline .Ad
* minor fixes in -Thtml
and some optimisations in terminal output.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.43 2010/07/13 01:09:13 schwarze Exp $ */
d31 4
d44 1
a44 1
#define	DATESIZ	  32
d77 1
d202 2
d915 1
a915 1
	char		buf[DATESIZ];
d922 1
a922 1
	if ( ! concat(m, buf, n->child, DATESIZ))
d979 12
@


1.43
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.42 2010/07/01 22:31:52 schwarze Exp $ */
d659 7
d909 5
@


1.42
log
@In the mdoc(7) parser, inspect roff registers early such that all parts
of the parser can use the resulting cues.  In particular, this allows
to use .nr nS to force SYNOPSIS-style .Nm indentation outside the
SYNOPSIS as needed by ifconfig(8).

To actually make this useable, .Pp must rewind .Nm, or the rest of the
section would end up indented.  Implement a quick hack for now,
a generic solution can be designed later.

ok kristaps@@ sobrado@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.41 2010/06/26 17:56:43 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
d31 5
d695 1
a695 1
	n->data.Bl.width = n->args->argv[i].value[0];
d718 1
a718 1
	if (0 == strcmp(n->data.Bl.width, "Ds"))
d720 1
a720 1
	else if (MDOC_MAX == (tok = mdoc_hash_find(n->data.Bl.width)))
d740 1
a740 1
	n->data.Bl.width = n->args->argv[i].value[0];
d756 1
a756 1
	if (LIST_column != n->data.Bl.type)
d781 3
a800 2
	struct mdoc_node *nn;
	const char	 *ww;
d815 1
a815 3
	ww = n->data.Bl.width;

	if (LIST_tag == n->data.Bl.type && NULL == n->data.Bl.width) {
d818 1
a818 1
	} else if (NULL != n->data.Bl.width) {
d824 1
a824 11
	assert(n->data.Bl.width);

	/* If it has changed, propogate new width to children. */

	if (ww == n->data.Bl.width)
		return(1);

	for (nn = n->child; nn; nn = nn->next)
		if (MDOC_Bl == nn->tok)
			nn->data.Bl.width = n->data.Bl.width;

d955 2
a956 1
	if (DISP_literal == n->data.Bd.type)
d958 1
a958 1
	if (DISP_unfilled == n->data.Bd.type)
@


1.41
log
@merge release 1.10.2
* bug fixes:
- interaction of ASCII_HYPH with special chars (found by Ulrich Spoerlein)
- handling of roff conditionals (found by Ulrich Spoerlein)
- .Bd -offset will no more default to 6n
* maintenance:
- more caching of .Bd and .Bl arguments for efficiency
- deconstify man(7) validation routines
- add FreeBSD library names (provided by Ulrich Spoerlein)
* start PostScript font-switching
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.40 2010/06/06 20:30:08 schwarze Exp $ */
d450 11
@


1.40
log
@Merge bsd.lv version 1.10.1 (to be released soon).

The main step forward is that this now has *much* better .Bl -column
support, now supporting many manuals that previously errored out
without producing any output.

Other fixes include:
* do not die from multiple list types, use the first and warn
* in .Bl without a type, default to -item
* various tweaks to .Dt
* fix .In, .Fd, .Ft, .Fn and .Fo formatting
* some documentation fixes and additions
* and fix a couple of bugs reported by Ulrich Spoerlein:
* better support for roff block-end "\}" without a preceding dot
* .In must not break the line outside SYNOPSIS
* spelling in some error messages

While merging, fix one regression in .In spacing
that needs to go to bsd.lv, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.39 2010/06/06 18:08:41 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
a66 1
static	int	  pre_bl(PRE_ARGS);
a67 1
static	int	  pre_offset(PRE_ARGS);
d81 1
a81 1
	{ pre_bl, post_bl }, /* Bl */ 
d630 1
a630 1
	size_t		  sz;
d634 1
a634 3
	/* Defaults to ten ens. */

	sz = 10; /* XXX: make this a macro value. */
d637 2
a638 3
		if (MDOC_It == nn->tok)
			break;
	}
a639 1
	if (nn) {
d642 2
a643 8
		if (MDOC_TEXT != nn->type) {
			sz = mdoc_macro2len(nn->tok);
			if (sz == 0) {
				if ( ! mdoc_nmsg(m, n, MANDOCERR_NOWIDTHARG))
					return(0);
				sz = 10;
			}
		} else
d645 9
d656 2
d665 5
a669 3
	nn = n;
	assert(nn->args);
	i = (int)(nn->args->argc)++;
d671 6
a676 2
	nn->args->argv = mandoc_realloc(nn->args->argv, 
			nn->args->argc * sizeof(struct mdoc_argv));
d678 2
a679 6
	nn->args->argv[i].arg = MDOC_Width;
	nn->args->argv[i].line = n->line;
	nn->args->argv[i].pos = n->pos;
	nn->args->argv[i].sz = 1;
	nn->args->argv[i].value = mandoc_malloc(sizeof(char *));
	nn->args->argv[i].value[0] = mandoc_strdup(buf);
a695 12
	char		 *p;

	if (NULL == n->args)
		return(1);

	for (i = 0; i < (int)n->args->argc; i++)
		if (MDOC_Width == n->args->argv[i].arg)
			break;

	if (i == (int)n->args->argc)
		return(1);
	p = n->args->argv[i].value[0];
d702 1
a702 1
	if (0 == strcmp(p, "Ds"))
d704 1
a704 1
	else if (MDOC_MAX == (tok = mdoc_hash_find(p)))
d711 8
d722 3
d740 3
a742 1
	if (NULL == n->child)
d752 1
a752 2
	if (c == (int)np->args->argc)
		return(1);
d782 2
a783 1
	int		  i, r, len;
d798 1
a798 1
	len = (int)(n->args ? n->args->argc : 0);
d800 1
a800 8
	for (r = i = 0; i < len; i++) {
		if (MDOC_Tag == n->args->argv[i].arg)
			r |= 1 << 0;
		if (MDOC_Width == n->args->argv[i].arg)
			r |= 1 << 1;
	}

	if (r & (1 << 0) && ! (r & (1 << 1))) {
d803 1
a803 1
	} else if (r & (1 << 1))
d806 13
a837 1
	/* XXX: make into macro value. */
a942 38
/* ARGSUSED */
static int
pre_offset(PRE_ARGS)
{
	int		 i;

	/* 
	 * Make sure that an empty offset produces an 8n length space as
	 * stipulated by mdoc.samples. 
	 */

	for (i = 0; n->args && i < (int)n->args->argc; i++) {
		if (MDOC_Offset != n->args->argv[i].arg) 
			continue;
		if (n->args->argv[i].sz)
			break;
		assert(1 == n->args->refcnt);
		/* If no value set, length of <string>. */
		n->args->argv[i].sz++;
		n->args->argv[i].value = mandoc_malloc(sizeof(char *));
		n->args->argv[i].value[0] = mandoc_strdup("8n");
		break;
	}

	return(1);
}


static int
pre_bl(PRE_ARGS)
{

	if (MDOC_BLOCK == n->type)
		return(pre_offset(m, n));
	return(1);
}


a945 1
	int		 i;
a946 2
	if (MDOC_BLOCK == n->type)
		return(pre_offset(m, n));
d950 4
a953 7
	/* Enter literal context if `Bd -literal' or `-unfilled'. */

	for (n = n->parent, i = 0; i < (int)n->args->argc; i++)
		if (MDOC_Literal == n->args->argv[i].arg)
			m->flags |= MDOC_LITERAL;
		else if (MDOC_Unfilled == n->args->argv[i].arg)
			m->flags |= MDOC_LITERAL;
@


1.39
log
@Merge bsd.lv release 1.10.0,
which is mostly the post-hackathon release,
bringing in the OpenBSD changes to bsd.lv,
but which also has a few additional minor fixes:

* .Lb is an in-line macro, not in_line_eoln
* .Bt, .Ud now warn when discarding arguments
* allow bad -man dates to flow verbatim into the front-ends
- so far all reported by Ulrich Spoerlein
* .Ar, .Fl and .Li starting with closing punctuation emit an empty element
* empty .Li macros print nothing, but may cause spacing
* proper EOS handling for .Bt, .Ex, .Rv, and .Ud.
* cleanup: collapse posts_xr into posts_wtext (which is the same)
* efficiency: very simple table lookup for roff.c
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.38 2010/05/24 02:24:05 schwarze Exp $ */
d193 1
d499 2
a500 2
		m->meta.title = mandoc_strdup("unknown");
		m->meta.vol = mandoc_strdup("local");
d509 2
a510 1
	m->meta.title = mandoc_strdup(nn->string);
d515 1
a515 1
		m->meta.vol = mandoc_strdup("local");
d947 1
a947 2
	assert(n->args);
	for (i = 0; i < (int)n->args->argc; i++) {
a966 1
	int		 pos;
d968 3
a970 55
	if (MDOC_BLOCK != n->type) {
		assert(n->parent);
		assert(MDOC_BLOCK == n->parent->type);
		assert(MDOC_Bl == n->parent->tok);
		assert(LIST__NONE != n->parent->data.list);
		n->data.list = n->parent->data.list;
		return(1);
	}

	assert(LIST__NONE == n->data.list);

	for (pos = 0; pos < (int)n->args->argc; pos++) {
		switch (n->args->argv[pos].arg) {
		case (MDOC_Bullet):
			n->data.list = LIST_bullet;
			break;
		case (MDOC_Dash):
			n->data.list = LIST_dash;
			break;
		case (MDOC_Enum):
			n->data.list = LIST_enum;
			break;
		case (MDOC_Hyphen):
			n->data.list = LIST_hyphen;
			break;
		case (MDOC_Item):
			n->data.list = LIST_item;
			break;
		case (MDOC_Tag):
			n->data.list = LIST_tag;
			break;
		case (MDOC_Diag):
			n->data.list = LIST_diag;
			break;
		case (MDOC_Hang):
			n->data.list = LIST_hang;
			break;
		case (MDOC_Ohang):
			n->data.list = LIST_ohang;
			break;
		case (MDOC_Inset):
			n->data.list = LIST_inset;
			break;
		case (MDOC_Column):
			n->data.list = LIST_column;
			break;
		default:
			break;
		}
		if (LIST__NONE != n->data.list)
			break;
	}

	assert(LIST__NONE != n->data.list);
	return(pre_offset(m, n));
@


1.38
log
@The input
  .Bl -tag
  .Sm off
  .It ...
triggered an assertion, which it shouldn't;
the warning that .Bl -tag "requires the width argument" is enough.

From Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.37 2010/05/24 00:00:10 schwarze Exp $ */
d56 1
d102 1
a102 1
	{ NULL, NULL }, /* Li */
d830 21
@


1.37
log
@Increase performance by saving the list type in struct mdoc_node.
This will eventually be used so that mdoc_macro can know whether to
dump list line arguments into the body (`Bl -column' overflowing).
Remove a2list() and arg_listtype() because of this.

From kristaps@@.

While merging, fix a regression in mdoc_term.c, print_bvspace():
The bsd.lv version of this broke vertical spacing in .Bl -column.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.36 2010/05/23 22:45:00 schwarze Exp $ */
d636 5
a640 1
	nn = n->body->child;
a643 1
		assert(MDOC_It == nn->tok);
@


1.36
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.35 2010/05/15 18:25:51 schwarze Exp $ */
d32 1
a32 1
#define	PRE_ARGS  struct mdoc *m, const struct mdoc_node *n
d215 1
a215 1
mdoc_action_pre(struct mdoc *m, const struct mdoc_node *n)
d941 1
d943 55
a997 1
	return(MDOC_BLOCK == n->type ? pre_offset(m, n) : 1);
@


1.35
log
@allow non-numeric manual sections in -mdoc;
while here, allow LIBRARY in section 9;
by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.34 2010/05/15 16:48:12 schwarze Exp $ */
d27 1
d269 9
a277 2
		if (strlcat(p, n->string, sz) >= sz)
			return(mdoc_nerr(m, n, ETOOLONG));
d280 4
a283 2
		if (strlcat(p, " ", sz) >= sz)
			return(mdoc_nerr(m, n, ETOOLONG));
d297 1
a297 1
	struct mdoc_node	*nn;
d301 2
d306 1
a306 1
	assert(m->meta.name);
d464 1
a464 1
		return(mdoc_nwarn(m, n, EWRONGMSEC));
d528 1
a528 1
	} else if (mdoc_nwarn(m, n, EBADMSEC)) {
d585 4
d591 4
a594 2
		if (strlcat(buf, OSNAME, BUFSIZ) >= BUFSIZ)
			return(mdoc_nerr(m, n, EUTSNAME));
d597 14
a610 7
			return(mdoc_nerr(m, n, EUTSNAME));
		if (strlcat(buf, utsname.sysname, BUFSIZ) >= BUFSIZ)
			return(mdoc_nerr(m, n, ETOOLONG));
		if (strlcat(buf, " ", 64) >= BUFSIZ)
			return(mdoc_nerr(m, n, ETOOLONG));
		if (strlcat(buf, utsname.release, BUFSIZ) >= BUFSIZ)
			return(mdoc_nerr(m, n, ETOOLONG));
d645 1
a645 1
				if ( ! mdoc_nwarn(m, n, ENOWIDTH))
a707 1
		/* XXX: make into a macro. */
d712 1
a712 1
		return(mdoc_nwarn(m, n, ENOWIDTH));
d871 1
a871 1
		if ( ! mdoc_nwarn(m, n, EBADDATE))
@


1.34
log
@various improvements regarding errors and warnings Joerg Sonnenberger:
* If the last -column .Bl isn't specified, it is auto-sized.
* An invalid .St argument should be a warning, not an error.
  Just put the argument into the output.
* An invalid .At argument should be a warning, not an error.
  Just print the argument, like new groff does.
* Remove warnings concerning manual section (like 1, 6, 8).
  It was only used for .Ex and not really useful.
* Remove warnings concerning page section (like SYNOPSIS).
  These were only used for .Fd and .Lb and not really useful.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.33 2010/05/14 19:52:43 schwarze Exp $ */
d445 2
a446 6
		switch (m->meta.msec) {
		case (2):
			/* FALLTHROUGH */
		case (3):
			/* FALLTHROUGH */
		case (9):
d448 5
a452 4
		default:
			return(mdoc_nwarn(m, n, EBADSEC));
		}
		break;
a468 2
	char		 *ep;
	long		  lval;
a477 2
	m->meta.msec = 0;

d484 1
d487 1
d498 1
d501 1
a513 1
		/* FIXME: where is strtonum!? */
d515 2
a516 4
		lval = strtol(nn->string, &ep, 10);
		if (nn->string[0] != '\0' && *ep == '\0')
			m->meta.msec = (int)lval;
	} else 
d518 3
d537 1
@


1.33
log
@Integrate kristaps@@' end-of-sentence (EOS) framework
which is simpler and more powerful than mine, and remove mine.

* man(7) now has EOS handling, too
* put EOS detection into its own function in libmandoc
* use node and termp flags to communicate the EOS condition
* no more EOS pseudo-macro
* no more non-printable EOS marker character on the formatter level

This slightly breaks EOS detection after trailing punctuation
in mdoc(7) macros, but that will be restored soon.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.32 2010/05/14 14:47:44 schwarze Exp $ */
d365 4
a368 3
	assert(p);
	free(n->child->string);
	n->child->string = mandoc_strdup(p);
d381 4
a384 2
	struct mdoc_node	*nn;
	const char		*p;
d389 13
a401 3
		assert(p);
		free(n->child->string);
		n->child->string = mandoc_strdup(p);
@


1.32
log
@Merge 1.9.25, keeping local patches;
this does not merge kristaps' end-of-sentences handling yet,
i will check that separately.  This one includes:
* handle \*(Ba as a delimiter
* introduce ARGS_PEND for .Bl -column .It end-of-line special casing
* section ordering: expect EXIT STATUS at the right place
* line break fixes in SYNOPSIS
* allow literal contexts to have arbitrary line lengths
* the input file column number can not be used to identify the beginning
  of a line because white space is allowed after the initial '.'
* proper leading spaces in -man -Tascii mode
* do not let Lb break lines in -mdoc -Thtml LIBRARY
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.31 2010/05/14 01:54:37 schwarze Exp $ */
a190 1
	{ NULL, NULL }, /* eos */
@


1.31
log
@merge 1.9.24, keeping local patches; some changes:
* preserve multiple consecutive space characters in input
* do not restrict .Cd and .Rv to certain sections (requested by Joerg)
* do not run lookup() on quoted words
* enum return types for mdoc_args and mdoc_argv
* fix auto-closing of LINK tag in -Txhtml (from Daniel Friesel)
* various lint and manual fixes
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.30 2010/04/07 23:15:05 schwarze Exp $ */
d419 1
a419 1
	sec = mdoc_atosec(buf);
@


1.30
log
@Merge the good parts of 1.9.23,
avoid the bad parts of 1.9.23, and keep local patches.

Input in general:
 * Basic handling of roff-style font escapes \f, \F.
 * Quoted punctuation does not count as punctuation.

mdoc(7) parser:
 * Make .Pf callable; noted by Claus Assmann.
 * Let .Bd and .Bl ignore unknown arguments; noted by deraadt@@.
 * Do not warn when .Er is used outside certain sections.
 * Replace mdoc_node_free[list] by mdoc_node_delete.
 * Replace #define by enum for rew*() return values.

man(7) parser:
 * When .TH is missing, use default section and date.

Output in general:
 * Curly braces do not count as punctuation.
 * No space after .Fl w/o args when a macro follows on the same line.

HTML output:
 * Unify PAIR_*_INIT macros, introduce new PAIR_ID_INIT().
 * Print whitespace after, not before .Vt .Fn .Ft .Fo.

Checked that all manuals in base still build.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.29 2010/04/04 17:36:57 schwarze Exp $ */
d43 1
a43 1
static	inline int order_rs(int);
d196 1
a196 1
static	const int rsord[RSORD_MAX] = {
d945 1
a945 1
order_rs(int t)
d949 1
a949 1
	for (i = 0; i < RSORD_MAX; i++)
@


1.29
log
@Make sure we never stay in SEC_NONE when passing by .Sh.
Fixing the x11/scrotwm build.
Problem reported by naddy@@, thanks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.28 2010/04/02 12:39:47 schwarze Exp $ */
d420 4
d729 1
a729 1
		mdoc_node_free(nnp);
a853 19
	struct mdoc_node *np;

	if (n->parent->child == n)
		n->parent->child = n->prev;
	if (n->prev)
		n->prev->next = NULL;

	np = n;
	assert(NULL == n->next);

	if (n->prev) {
		m->last = n->prev;
		m->next = MDOC_NEXT_SIBLING;
	} else {
		m->last = n->parent;
		m->next = MDOC_NEXT_CHILD;
	}

	mdoc_node_freelist(np);
d855 1
a857 1

@


1.28
log
@merge 1.9.22, keeping local patches
* convert mdoc tokens from #define to enum
* fix a segfault with .Xo/.Xc in explicit blocks
* Thorn is \*(Th, not \*(TH; noticed by Joerg Sonnenberger
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.27 2010/03/02 00:38:59 schwarze Exp $ */
d420 1
a420 1
	if (SEC_CUSTOM != sec)
@


1.27
log
@Proper inter-sentence spacing for mdoc(7).
When a text line or a non-block macro line in the source code ends
in any of ".!?", consider that an end of sentence (EOS).
This makes Jason's rule "new sentence, new line" even more important.
Let the parser detect the EOS and insert a token into the AST.
Let the -Tascii frontend render the EOS token as a double space before
the next word.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.26 2009/12/23 22:30:17 schwarze Exp $ */
d647 2
a648 1
	int		  i, tok;
@


1.26
log
@sync to 1.9.13: minor fixes:

correctness/functionality:
 - bugfix: properly ignore lines with only a dot in -man
 - bugfix: .Bl -ohang doesn't allow -width, warn about this
 - improve date string handling by new function mandoc_a2time
 - some HTML improvements
 - significant documentation additions in man.7 and mdoc.7

portability:
 - replace __dead by __attribute__((noreturn))
 - bugfix: correct .Dx rendering
 - some more library names for NetBSD

simplicity:
 - replace hand-rolled putchar(3)-loops by fwrite(3)
 - replace single-character printf(3) by putchar(3)
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.25 2009/12/22 23:58:00 schwarze Exp $ */
d191 1
@


1.25
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.24 2009/10/27 21:40:07 schwarze Exp $ */
d817 1
a817 2
 * Parse the date field in `Dd', primarily through mdoc_atotime().
 * FIXME: push mdoc_atotime() into here.
d827 3
a829 1
	m->meta.date = mdoc_atotime(buf);
@


1.24
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.23 2009/10/19 16:27:52 schwarze Exp $ */
a21 1
#include <errno.h>
d28 1
d33 3
d41 2
a42 3
static	int	  concat(struct mdoc *, 
			const struct mdoc_node *, 
			char *, size_t);
d57 1
a62 1
static	int	  post_tilde(POST_ARGS);
d105 1
a105 1
	{ NULL, post_tilde }, /* Pa */
d255 5
d261 1
a261 2
concat(struct mdoc *m, const struct mdoc_node *n, 
		char *buf, size_t sz)
d264 2
d268 1
a268 1
		if (strlcat(buf, n->string, sz) >= sz)
d272 1
a272 1
		if (strlcat(buf, " ", sz) >= sz)
d280 4
a297 1

d302 4
d309 1
a309 1
	char		 buf[64];
d313 1
a313 3

	buf[0] = 0;
	if ( ! concat(m, n->child, buf, sizeof(buf)))
d315 1
a315 3
	if (NULL == (m->meta.name = strdup(buf)))
		return(mdoc_nerr(m, n, EMALLOC));

d320 6
d335 2
a336 8
	if (NULL == p) {
		sz = strlen(n->child->string) +
			2 + strlen("\\(lqlibrary\\(rq");
		buf = malloc(sz);
		if (NULL == buf)
			return(mdoc_nerr(m, n, EMALLOC));
		(void)snprintf(buf, sz, "library \\(lq%s\\(rq", 
				n->child->string);
d338 1
a338 1
		n->child->string = buf;
d342 4
d347 1
a347 4
	n->child->string = strdup(p);
	if (NULL == n->child->string)
		return(mdoc_nerr(m, n, EMALLOC));

d352 6
d367 1
a367 4
	n->child->string = strdup(p);
	if (NULL == n->child->string)
		return(mdoc_nerr(m, n, EMALLOC));

d372 5
d388 1
a388 3
		n->child->string = strdup(p);
		if (NULL == n->child->string)
			return(mdoc_nerr(m, n, EMALLOC));
a393 1

a396 1

d401 6
d411 1
a411 7
	char		 buf[64];

	/*
	 * We keep track of the current section /and/ the "named"
	 * section, which is one of the conventional ones, in order to
	 * check ordering.
	 */
d416 1
a416 2
	buf[0] = 0;
	if ( ! concat(m, n->child, buf, sizeof(buf)))
d418 2
a419 1
	if (SEC_CUSTOM != (sec = mdoc_atosec(buf)))
d422 2
d446 4
d473 3
a475 4
		if (NULL == (m->meta.title = strdup("unknown")))
			return(mdoc_nerr(m, n, EMALLOC));
		if (NULL == (m->meta.vol = strdup("local")))
			return(mdoc_nerr(m, n, EMALLOC));
d483 1
a483 2
	if (NULL == (m->meta.title = strdup(nn->string)))
		return(mdoc_nerr(m, n, EMALLOC));
d486 2
a487 2
		if (NULL == (m->meta.vol = strdup("local")))
			return(mdoc_nerr(m, n, EMALLOC));
d500 2
a501 3
		if (NULL == (m->meta.vol = strdup(cp)))
			return(mdoc_nerr(m, n, EMALLOC));
		errno = 0;
d505 2
a506 2
	} else if (NULL == (m->meta.vol = strdup(nn->string)))
		return(mdoc_nerr(m, n, EMALLOC));
d521 1
a521 2
		if (NULL == (m->meta.vol = strdup(cp)))
			return(mdoc_nerr(m, n, EMALLOC));
d526 3
a528 4
			if (NULL == (m->meta.vol = strdup(nn->string)))
				return(mdoc_nerr(m, n, EMALLOC));
		} else if (NULL == (m->meta.arch = strdup(cp)))
			return(mdoc_nerr(m, n, EMALLOC));
d532 1
d538 6
d547 2
a548 2
	char		  buf[64];
#ifndef	OSNAME
a551 6
	/*
	 * Setting OSNAME to be the name of the target operating system,
	 * e.g., "OpenBSD 4.4", will result in the compile-time constant
	 * by supplied instead of the value in uname().
	 */

d555 1
a555 2
	buf[0] = 0;
	if ( ! concat(m, n->child, buf, sizeof(buf)))
d558 3
a560 3
	if (0 == buf[0]) {
#ifdef	OSNAME
		if (strlcat(buf, OSNAME, 64) >= 64)
d562 1
a562 1
#else
d565 1
a565 1
		if (strlcat(buf, utsname.sysname, 64) >= 64)
d567 1
a567 1
		if (strlcat(buf, " ", 64) >= 64)
d569 1
a569 1
		if (strlcat(buf, utsname.release, 64) >= 64)
d571 1
a571 1
#endif
d574 1
a574 3
	if (NULL == (m->meta.os = strdup(buf)))
		return(mdoc_nerr(m, n, EMALLOC));

d581 3
a583 1
 * Uses the first head macro.
d588 4
a591 3
	struct mdoc_node  *nn;
	int		   sz;
	char		   buf[32];
d593 1
a593 4
	/*
	 * Use the text width, if a text node, or the default macro
	 * width if a macro.
	 */
d595 1
d597 1
a601 5
	}

	sz = 10; /* Default size. */

	if (nn) {
d603 2
a604 1
			if (0 == (sz = (int)mdoc_macro2len(nn->tok)))
d607 2
d610 1
a610 1
			sz = (int)strlen(nn->string) + 1;
d613 1
a613 2
	if (-1 == snprintf(buf, sizeof(buf), "%dn", sz))
		return(mdoc_nerr(m, n, ENUMFMT));
d622 1
a622 1
	sz = (int)(nn->args->argc)++;
d624 1
a624 1
	nn->args->argv = realloc(nn->args->argv, 
d627 6
a632 14
	if (NULL == nn->args->argv)
		return(mdoc_nerr(m, n, EMALLOC));

	nn->args->argv[sz].arg = MDOC_Width;
	nn->args->argv[sz].line = n->line;
	nn->args->argv[sz].pos = n->pos;
	nn->args->argv[sz].sz = 1;
	nn->args->argv[sz].value = calloc(1, sizeof(char *));

	if (NULL == nn->args->argv[sz].value)
		return(mdoc_nerr(m, n, EMALLOC));
	if (NULL == (nn->args->argv[sz].value[0] = strdup(buf)))
		return(mdoc_nerr(m, n, EMALLOC));

d637 5
d647 1
a647 1
	char		  buf[32];
d667 1
d676 1
a676 3
	if (-1 == snprintf(buf, sizeof(buf), "%zun", width))
		return(mdoc_nerr(m, n, ENUMFMT));

d678 1
a678 4
	n->args->argv[i].value[0] = strdup(buf);
	if (NULL == n->args->argv[i].value[0])
		return(mdoc_nerr(m, n, EMALLOC));

d683 4
a703 2
	/* Only process -column. */

a705 1
	
d715 1
a715 1
	np->args->argv[c].value = malloc
a727 1

d770 4
d775 1
a775 1
post_tilde(POST_ARGS)
d784 1
a784 1

a787 1

d792 4
d806 1
a811 1

d816 4
d823 1
a823 1
	char		  buf[64];
d825 1
a825 2
	buf[0] = 0;
	if ( ! concat(m, n->child, buf, sizeof(buf)))
d828 2
a829 1
	if (0 == (m->meta.date = mdoc_atotime(buf))) {
d839 5
a848 2
	/* Remove prologue macros from AST.  */

d874 3
d887 1
a905 4
		n->args->argv[i].value = 
		calloc(1, sizeof(char *));
		if (NULL == n->args->argv[i].value)
			return(mdoc_nerr(m, n, EMALLOC));
d907 2
a908 3
		n->args->argv[i].value[0] = strdup("8n");
		if (NULL == n->args->argv[i].value[0])
			return(mdoc_nerr(m, n, EMALLOC));
@


1.23
log
@sync to 1.9.6: multiple improvements to references (.Rs)
 * validate and order .Rs child nodes
 * underline book title (.%B) and issuer (.%I)
 * enclose title of article (.%T) in quotes
 * avoid calling mdoc_verr directly, use a proper error code instead
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.22 2009/10/19 15:44:01 schwarze Exp $ */
d17 1
d19 1
d26 1
d176 1
a176 1
	{ NULL, post_tilde }, /* Lk */
d188 1
d191 1
a191 1
#define	RSORD_MAX 13
d206 2
a207 1
	MDOC__C
d524 1
d526 7
d542 4
d554 1
a773 1
	/* XXX: not documented for `Lk'. */
@


1.22
log
@sync to 1.9.6: do not die from .Bd -literal -offset w/o arg (and similar)
Actually, our ancient groff behaves slightly differently than this fix,
but not to die is already an improvement.  Needs a closer look later.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.21 2009/09/21 21:11:37 schwarze Exp $ */
d35 5
d53 1
d150 1
a150 1
	{ NULL, NULL }, /* Rs */
d187 17
a203 2
static	int	  concat(struct mdoc *, const struct mdoc_node *, 
			char *, size_t);
d919 62
@


1.21
log
@sync to 1.9.5: lookup hashes are now static tables
shortening the code, and, according to kristaps@@, speeding it up
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.20 2009/08/22 22:50:17 schwarze Exp $ */
d54 1
d56 1
d70 1
a70 1
	{ NULL, post_bl }, /* Bl */ 
d826 41
d871 2
a877 5
	/* 
	 * TODO: `-offset' without an argument should be the width of
	 * the literal "<string>".
	 */

d880 1
a880 1
			break;
d882 1
a882 4
			break;

	if (i < (int)n->args->argc)
		m->flags |= MDOC_LITERAL;
@


1.20
log
@sync to 1.9.1: .Rv and .Ex accept multiple arguments
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.19 2009/08/22 15:36:58 schwarze Exp $ */
d56 1
a56 1
const	struct actions mdoc_actions[MDOC_MAX] = {
d616 1
a616 1
	else if (MDOC_MAX == (tok = mdoc_hash_find(m->htab, p)))
@


1.19
log
@sync to 1.8.4: LLVM findings from <uqs at spoerlein dot net>
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.18 2009/08/22 15:29:23 schwarze Exp $ */
d27 1
a28 1
#define	POST_ARGS struct mdoc *m
d74 1
a74 1
	{ NULL, NULL }, /* Cd */ /* FIXME: tabs are accepted! */
d221 1
a221 1
	return((*mdoc_actions[m->last->tok].post)(m));
d247 1
d249 1
a249 6
	/*
	 * If '-std' is invoked without an argument, fill it in with our
	 * name (if it's been set).
	 */

	if (NULL == m->last->args)
d251 3
a253 3
	if (m->last->args->argv[0].sz)
		return(1);

d255 3
a257 9

	m->last->args->argv[0].value = calloc(1, sizeof(char *));
	if (NULL == m->last->args->argv[0].value)
		return(mdoc_nerr(m, m->last, EMALLOC));

	m->last->args->argv[0].sz = 1;
	m->last->args->argv[0].value[0] = strdup(m->meta.name);
	if (NULL == m->last->args->argv[0].value[0])
		return(mdoc_nerr(m, m->last, EMALLOC));
d272 1
a272 1
	if ( ! concat(m, m->last->child, buf, sizeof(buf)))
a273 1

d275 1
a275 1
		return(mdoc_nerr(m, m->last, EMALLOC));
d288 2
a289 2
	assert(MDOC_TEXT == m->last->child->type);
	p = mdoc_a2lib(m->last->child->string);
d291 1
a291 1
		sz = strlen(m->last->child->string) +
d295 1
a295 1
			return(mdoc_nerr(m, m->last, EMALLOC));
d297 3
a299 3
				m->last->child->string);
		free(m->last->child->string);
		m->last->child->string = buf;
d303 5
a307 4
	free(m->last->child->string);
	m->last->child->string = strdup(p);
	if (NULL == m->last->child->string)
		return(mdoc_nerr(m, m->last, EMALLOC));
d317 2
a318 2
	assert(MDOC_TEXT == m->last->child->type);
	p = mdoc_a2st(m->last->child->string);
d320 5
a324 4
	free(m->last->child->string);
	m->last->child->string = strdup(p);
	if (NULL == m->last->child->string)
		return(mdoc_nerr(m, m->last, EMALLOC));
d332 2
a333 2
	struct mdoc_node *n;
	const char	 *p;
d335 3
a337 3
	if (m->last->child) {
		assert(MDOC_TEXT == m->last->child->type);
		p = mdoc_a2att(m->last->child->string);
d339 4
a342 4
		free(m->last->child->string);
		m->last->child->string = strdup(p);
		if (NULL == m->last->child->string)
			return(mdoc_nerr(m, m->last, EMALLOC));
d346 1
a346 1
	n = m->last;
d349 1
a349 1
	if ( ! mdoc_word_alloc(m, n->line, n->pos, "AT&T UNIX"))
d351 1
a352 2
	m->last = n;
	m->next = MDOC_NEXT_SIBLING;
d369 1
a369 1
	if (MDOC_HEAD != m->last->type)
d373 1
a373 1
	if ( ! concat(m, m->last->child, buf, sizeof(buf)))
d390 1
a390 1
			return(mdoc_nwarn(m, m->last, EBADSEC));
d403 1
a403 1
	struct mdoc_node *n;
d422 1
a422 1
	if (NULL == (n = m->last->child)) {
d424 1
a424 1
			return(mdoc_nerr(m, m->last, EMALLOC));
d426 2
a427 2
			return(mdoc_nerr(m, m->last, EMALLOC));
		return(post_prol(m));
d434 2
a435 2
	if (NULL == (m->meta.title = strdup(n->string)))
		return(mdoc_nerr(m, m->last, EMALLOC));
d437 1
a437 1
	if (NULL == (n = n->next)) {
d439 2
a440 2
			return(mdoc_nerr(m, m->last, EMALLOC));
		return(post_prol(m));
d450 1
a450 1
	cp = mdoc_a2msec(n->string);
d453 1
a453 1
			return(mdoc_nerr(m, m->last, EMALLOC));
d455 2
a456 2
		lval = strtol(n->string, &ep, 10);
		if (n->string[0] != '\0' && *ep == '\0')
d458 2
a459 2
	} else if (NULL == (m->meta.vol = strdup(n->string)))
		return(mdoc_nerr(m, m->last, EMALLOC));
d461 2
a462 2
	if (NULL == (n = n->next))
		return(post_prol(m));
d471 1
a471 1
	cp = mdoc_a2vol(n->string);
d475 1
a475 1
			return(mdoc_nerr(m, m->last, EMALLOC));
d477 1
a477 1
		cp = mdoc_a2arch(n->string);
d480 2
a481 2
			if (NULL == (m->meta.vol = strdup(n->string)))
				return(mdoc_nerr(m, m->last, EMALLOC));
d483 1
a483 1
			return(mdoc_nerr(m, m->last, EMALLOC));
d488 1
a488 1
	return(post_prol(m));
d502 1
a502 1
	if ( ! concat(m, m->last->child, buf, sizeof(buf)))
d507 1
a507 1
			return(mdoc_nerr(m, m->last, EUTSNAME));
d509 1
a509 1
			return(mdoc_nerr(m, m->last, ETOOLONG));
d511 1
a511 1
			return(mdoc_nerr(m, m->last, ETOOLONG));
d513 1
a513 1
			return(mdoc_nerr(m, m->last, ETOOLONG));
d517 1
a517 1
		return(mdoc_nerr(m, m->last, EMALLOC));
d519 1
a519 1
	return(post_prol(m));
d528 1
a528 1
post_bl_tagwidth(struct mdoc *m)
d530 1
a530 1
	struct mdoc_node  *n;
d539 5
a543 5
	n = m->last->body->child;
	if (n) {
		assert(MDOC_BLOCK == n->type);
		assert(MDOC_It == n->tok);
		n = n->head->child;
d548 4
a551 4
	if (n) {
		if (MDOC_TEXT != n->type) {
			if (0 == (sz = (int)mdoc_macro2len(n->tok)))
				if ( ! mdoc_nwarn(m, m->last, ENOWIDTH))
d554 1
a554 1
			sz = (int)strlen(n->string) + 1;
d558 1
a558 1
		return(mdoc_nerr(m, m->last, ENUMFMT));
d565 3
a567 3
	n = m->last;
	assert(n->args);
	sz = (int)(n->args->argc)++;
d569 2
a570 2
	n->args->argv = realloc(n->args->argv, 
			n->args->argc * sizeof(struct mdoc_argv));
d572 2
a573 2
	if (NULL == n->args->argv)
		return(mdoc_nerr(m, m->last, EMALLOC));
d575 5
a579 5
	n->args->argv[sz].arg = MDOC_Width;
	n->args->argv[sz].line = m->last->line;
	n->args->argv[sz].pos = m->last->pos;
	n->args->argv[sz].sz = 1;
	n->args->argv[sz].value = calloc(1, sizeof(char *));
d581 4
a584 4
	if (NULL == n->args->argv[sz].value)
		return(mdoc_nerr(m, m->last, EMALLOC));
	if (NULL == (n->args->argv[sz].value[0] = strdup(buf)))
		return(mdoc_nerr(m, m->last, EMALLOC));
d591 1
a591 1
post_bl_width(struct mdoc *m)
d598 1
a598 1
	if (NULL == m->last->args)
d601 2
a602 2
	for (i = 0; i < (int)m->last->args->argc; i++)
		if (MDOC_Width == m->last->args->argv[i].arg)
d605 1
a605 1
	if (i == (int)m->last->args->argc)
d607 1
a607 1
	p = m->last->args->argv[i].value[0];
d619 1
a619 1
		return(mdoc_nwarn(m, m->last, ENOWIDTH));
d624 1
a624 1
		return(mdoc_nerr(m, m->last, ENUMFMT));
d626 4
a629 4
	free(m->last->args->argv[i].value[0]);
	m->last->args->argv[i].value[0] = strdup(buf);
	if (NULL == m->last->args->argv[i].value[0])
		return(mdoc_nerr(m, m->last, EMALLOC));
d635 1
d640 1
a640 1
	struct mdoc_node	*n, *nn, *nnp;
d642 1
a642 1
	if (NULL == m->last->child)
d645 2
a646 2
	n = m->last->parent;
	assert(n->args);
d648 2
a649 2
	for (c = 0; c < (int)n->args->argc; c++) 
		if (MDOC_Column == n->args->argv[c].arg)
d654 1
a654 1
	if (c == (int)n->args->argc)
d657 1
a657 1
	assert(0 == n->args->argv[c].sz);
d665 3
a667 3
	n->args->argv[c].sz = (size_t)m->last->nchild;
	n->args->argv[c].value = malloc
		((size_t)m->last->nchild * sizeof(char *));
d669 2
a670 2
	for (i = 0, nn = m->last->child; nn; i++) {
		n->args->argv[c].value[i] = nn->string;
d677 2
a678 2
	m->last->nchild = 0;
	m->last->child = NULL;
d689 3
a691 3
	if (MDOC_HEAD == m->last->type)
		return(post_bl_head(m));
	if (MDOC_BLOCK != m->last->type)
d702 1
a702 1
	len = (int)(m->last->args ? m->last->args->argc : 0);
d705 1
a705 1
		if (MDOC_Tag == m->last->args->argv[i].arg)
d707 1
a707 1
		if (MDOC_Width == m->last->args->argv[i].arg)
d712 1
a712 1
		if ( ! post_bl_tagwidth(m))
d715 1
a715 1
		if ( ! post_bl_width(m))
d725 1
a725 1
	struct mdoc_node *n;
d727 1
a727 1
	if (m->last->child)
d730 1
a730 1
	n = m->last;
d734 1
a734 1
	if ( ! mdoc_word_alloc(m, m->last->line, m->last->pos, "~"))
d736 1
a737 2
	m->last = n;
	m->next = MDOC_NEXT_SIBLING;
d745 1
a745 1
	struct mdoc_node *n;
d747 1
a747 1
	if (m->last->child)
d750 1
a750 1
	n = m->last;
d752 1
a752 1
	if ( ! mdoc_word_alloc(m, m->last->line, m->last->pos, "file"))
d754 1
a754 2
	m->next = MDOC_NEXT_SIBLING;
	if ( ! mdoc_word_alloc(m, m->last->line, m->last->pos, "..."))
d756 1
a757 2
	m->last = n;
	m->next = MDOC_NEXT_SIBLING;
d768 1
a768 1
	if ( ! concat(m, m->last->child, buf, sizeof(buf)))
d772 1
a772 1
		if ( ! mdoc_nwarn(m, m->last, EBADDATE))
d777 1
a777 1
	return(post_prol(m));
d784 1
a784 1
	struct mdoc_node *n;
d786 1
a786 4
	/* 
	 * The end document shouldn't have the prologue macros as part
	 * of the syntax tree (they encompass only meta-data).  
	 */
d788 4
a791 4
	if (m->last->parent->child == m->last)
		m->last->parent->child = m->last->prev;
	if (m->last->prev)
		m->last->prev->next = NULL;
d793 2
a794 2
	n = m->last;
	assert(NULL == m->last->next);
d796 2
a797 2
	if (m->last->prev) {
		m->last = m->last->prev;
d800 1
a800 1
		m->last = m->last->parent;
d804 1
a804 1
	mdoc_node_freelist(n);
d808 1
a818 1

d855 1
a855 1
	if (MDOC_BODY == m->last->type)
@


1.18
log
@sync to 1.8.4: do not error out in case of out-of-order prologue macros
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.17 2009/08/09 19:59:13 schwarze Exp $ */
a485 1
		n = n->next;
d833 1
d846 6
a851 1
	/* Enter literal context if `Bd -literal' or * -unfilled'. */
@


1.17
log
@sync to 1.8.3: .Pa without arguments is a synonym for .Pa ~
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.16 2009/07/26 01:59:46 schwarze Exp $ */
a529 1
	m->flags |= MDOC_PBODY;
d821 3
@


1.16
log
@sync to 1.8.1: support .br and .sp
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.15 2009/07/18 19:44:38 schwarze Exp $ */
a44 1
static	int	  post_lk(POST_ARGS);
d51 1
d92 1
a92 1
	{ NULL, NULL }, /* Pa */
d165 1
a165 1
	{ NULL, post_lk }, /* Lk */
d734 1
a734 1
post_lk(POST_ARGS)
d744 1
a744 1
	/* XXX: this isn't documented anywhere! */
@


1.15
log
@sync to 1.8.0: move mdoc_a2att, mdoc_a2st, and mdoc_a2lib to libmdoc
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.14 2009/07/12 22:35:08 schwarze Exp $ */
d175 2
@


1.14
log
@sync to 1.7.23: pass warning code to mdoc_pwarn() instead of warning message
define additional warning macro mdoc_nwarn()
remove obsolete warning functions mdoc_warn(), pwarn(), vwarn(), nwarn()
remove various now unused "enum mdoc_warn" and "enum mwarn"
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.13 2009/07/12 21:45:44 schwarze Exp $ */
a34 3
static	int	  concat(struct mdoc *, const struct mdoc_node *, 
			char *, size_t);

d36 1
d39 1
a40 1
static	int	  post_bl_tagwidth(POST_ARGS);
d44 1
d50 1
d94 1
a94 1
	{ NULL, NULL }, /* St */
d112 1
a112 1
	{ NULL, NULL }, /* At */ 
d163 1
a163 1
	{ NULL, NULL }, /* Lb */
d177 3
d291 75
d741 3
a743 3
	/* FIXME: this isn't documented anywhere! */
	if ( ! mdoc_word_alloc(m, m->last->line,
				m->last->pos, "~"))
d762 1
a762 2
	if ( ! mdoc_word_alloc(m, m->last->line,
				m->last->pos, "file"))
d765 1
a765 2
	if ( ! mdoc_word_alloc(m, m->last->line, 
				m->last->pos, "..."))
@


1.13
log
@sync to 1.7.23: pass error code to mdoc_perr() instead of error string
and use the so improved mdoc_nerr() at many places;
get rid of now unused static functions perr()
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.12 2009/07/12 21:08:29 schwarze Exp $ */
a26 6
enum	mwarn {
	WBADSEC,
	WNOWIDTH,
	WBADDATE
};

a34 1
static	int	  pwarn(struct mdoc *, int, int, enum mwarn);
a55 2
#define	vwarn(m, t) pwarn((m), (m)->last->line, (m)->last->pos, (t))

a239 25
pwarn(struct mdoc *m, int line, int pos, enum mwarn type)
{
	char		*p;
	int		 c;

	p = NULL;
	c = WARN_SYNTAX;
	switch (type) {
	case (WBADSEC):
		p = "inappropriate document section in manual section";
		c = WARN_COMPAT;
		break;
	case (WNOWIDTH):
		p = "cannot determine default width";
		break;
	case (WBADDATE):
		p = "malformed date syntax";
		break;
	}
	assert(p);
	return(mdoc_pwarn(m, line, pos, c, p));
}


static int
d320 1
a320 1
			return(vwarn(m, WBADSEC));
d483 1
a483 1
				if ( ! vwarn(m, WNOWIDTH))
d551 1
a551 1
		return(vwarn(m, WNOWIDTH));
d708 1
a708 1
		if ( ! vwarn(m, WBADDATE))
@


1.12
log
@sync to 1.7.23: pass error code to mdoc_nerr() instead of error string
and use the so improved mdoc_nerr() at many places
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.11 2009/07/12 20:30:27 schwarze Exp $ */
a41 1
static	int	  perr(struct mdoc *, int, int, enum merr);
a63 2
#define	verr(m, t) perr((m), (m)->last->line, (m)->last->pos, (t))
#define	nerr(m, n, t) perr((m), (n)->line, (n)->pos, (t))
a244 25
}


static int
perr(struct mdoc *m, int line, int pos, enum merr type)
{
	char		*p;

	p = NULL;
	switch (type) {
	case (ENUMFMT):
		p = "bad number format";
		break;
	case (ETOOLONG):
		p = "argument text too long";
		break;
	case (EUTSNAME):
		p = "utsname";
		break;
	case (EMALLOC):
		p = "memory exhausted";
		break;
	}
	assert(p);
	return(mdoc_perr(m, line, pos, p));
@


1.11
log
@sync to 1.7.23: unify the various "enum merr" into libman.h and libmdoc.h,
use it as a new argument to mdoc_err(), the same way as for for man_err(),
and use string tables instead of switch statements to select error messages
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.10 2009/07/06 21:40:30 schwarze Exp $ */
d240 1
a240 1
			return(nerr(m, n, ETOOLONG));
d244 1
a244 1
			return(nerr(m, n, ETOOLONG));
d319 1
a319 1
		return(verr(m, EMALLOC));
d324 1
a324 1
		return(verr(m, EMALLOC));
d343 1
a343 1
		return(verr(m, EMALLOC));
d416 1
a416 1
			return(verr(m, EMALLOC));
d418 1
a418 1
			return(verr(m, EMALLOC));
d427 1
a427 1
		return(verr(m, EMALLOC));
d431 1
a431 1
			return(verr(m, EMALLOC));
d445 1
a445 1
			return(verr(m, EMALLOC));
d451 1
a451 1
		return(verr(m, EMALLOC));
d467 1
a467 1
			return(verr(m, EMALLOC));
d474 1
a474 1
				return(verr(m, EMALLOC));
d476 1
a476 1
			return(verr(m, EMALLOC));
d500 1
a500 1
			return(verr(m, EUTSNAME));
d502 1
a502 1
			return(verr(m, ETOOLONG));
d504 1
a504 1
			return(verr(m, ETOOLONG));
d506 1
a506 1
			return(verr(m, ETOOLONG));
d510 1
a510 1
		return(verr(m, EMALLOC));
d552 1
a552 1
		return(verr(m, ENUMFMT));
d567 1
a567 1
		return(verr(m, EMALLOC));
d576 1
a576 1
		return(verr(m, EMALLOC));
d578 1
a578 1
		return(verr(m, EMALLOC));
d618 1
a618 1
		return(verr(m, ENUMFMT));
d623 1
a623 1
		return(verr(m, EMALLOC));
@


1.10
log
@sync to 1.7.21: convert the last plain mdoc_err() in this file to verr();
this is still not really good, but can stay like this for now
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.9 2009/06/27 12:43:11 schwarze Exp $ */
a30 7
};

enum	merr {
	ETOOLONG,
	EMALLOC,
	EUTSNAME,
	ENUMFMT
@


1.9
log
@sync to 1.7.20: (1) -width Ds is 6 spaces, not 8, see the manual.
(2) When determining the offset, add two more spaces to the width.
For -width Ds, these two bugs cancelled each other,
but for -width [01-9]+n, they did not, leaving the offset to narrow.
(3) When determining the width using strlen,
we need to add two spaces instead of one, just like in the case (2).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.8 2009/06/23 23:02:54 schwarze Exp $ */
d36 1
d271 3
d507 1
a507 1
			return(mdoc_err(m, "utsname"));
@


1.8
log
@sync to 1.7.20: like for the -man case, add an nchild counter to the -mdoc
nodes, simplifying the validation code; no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.7 2009/06/21 19:40:15 schwarze Exp $ */
d92 1
a92 1
	{ NULL, NULL }, /* Cd */
d612 1
a612 1
		width = 8;
@


1.7
log
@sync to 1.7.19: simplify code; no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.6 2009/06/21 19:09:58 schwarze Exp $ */
d661 3
a663 5
	for (i = 0, nn = m->last->child; nn; nn = nn->next, i++)
		/* Count children. */;

	n->args->argv[c].sz = (size_t)i;
	n->args->argv[c].value = malloc((size_t)i * sizeof(char *));
d673 1
d675 1
@


1.6
log
@sync to 1.7.19: .Bl -column  now correctly handles tail entries,
for example:  .Bl -column -compact -offset ... args ...
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.5 2009/06/19 07:20:19 schwarze Exp $ */
d817 2
a818 3
	if (MDOC_BODY != n->type)
		return(1);
	m->flags |= MDOC_LITERAL;
@


1.5
log
@sync to 1.7.19: more elegant section handling
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.4 2009/06/18 23:34:53 schwarze Exp $ */
d54 1
d633 48
d685 2
@


1.4
log
@sync to 1.7.19: improved comment handling
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.3 2009/06/18 01:19:02 schwarze Exp $ */
a512 1
	m->lastnamed = m->lastsec = SEC_BODY;
d514 1
@


1.3
log
@sync to 1.7.16: make a couple of macros callable, reserve "|",
and some tweaks to .Lk
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.2 2009/06/14 23:00:57 schwarze Exp $ */
d74 1
a74 1
	{ NULL, NULL }, /* \" */
a180 1
	{ NULL, NULL }, /* Ap */
@


1.2
log
@sync to 1.7.16: comments, whitespace and spelling fixes; no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.11 2009/06/12 12:52:51 kristaps Exp $ */
d59 1
d183 1
a183 1
	{ NULL, NULL }, /* Lk */
d536 2
a537 1
	if ((n = m->last->body->child)) {
d664 21
@


1.1
log
@Initial check-in of mandoc for formatting manuals. ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: mdoc_action.c,v 1.6 2009/04/06 08:53:12 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d343 1
d346 1
@

