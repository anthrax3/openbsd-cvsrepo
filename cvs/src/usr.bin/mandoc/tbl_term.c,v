head	1.45;
access;
symbols
	OPENBSD_6_2:1.45.0.4
	OPENBSD_6_2_BASE:1.45
	OPENBSD_6_1:1.31.0.8
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.4
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8;
locks; strict;
comment	@ * @;


1.45
date	2017.07.31.16.14.04;	author schwarze;	state Exp;
branches;
next	1.44;
commitid	EtxzWx5nXgZGSvi8;

1.44
date	2017.07.08.13.43.09;	author schwarze;	state Exp;
branches;
next	1.43;
commitid	H1M5pRgn4pwFwy6o;

1.43
date	2017.06.27.18.23.29;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	Hchs3a6RO49ixqKW;

1.42
date	2017.06.17.14.55.02;	author schwarze;	state Exp;
branches;
next	1.41;
commitid	NjfD9WWGgFCUSOhr;

1.41
date	2017.06.16.20.00.41;	author schwarze;	state Exp;
branches;
next	1.40;
commitid	Ws0YHuIypb6sve4L;

1.40
date	2017.06.14.17.50.43;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	SAEkKP1XAbzvhv7H;

1.39
date	2017.06.13.14.38.38;	author schwarze;	state Exp;
branches;
next	1.38;
commitid	yNUYHJniANfrBz4k;

1.38
date	2017.06.12.22.48.52;	author schwarze;	state Exp;
branches;
next	1.37;
commitid	gNw2mdFtiI1VLvbn;

1.37
date	2017.06.12.20.44.57;	author schwarze;	state Exp;
branches;
next	1.36;
commitid	53JT8ncM99APT5E5;

1.36
date	2017.06.12.20.14.03;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	lFlQfhoqp8OzbXSc;

1.35
date	2017.06.12.18.55.42;	author schwarze;	state Exp;
branches;
next	1.34;
commitid	S6KuOKZjNULZvGWe;

1.34
date	2017.06.08.18.11.15;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	iJqHiCg2x8ufqICJ;

1.33
date	2017.06.07.17.38.08;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	Lq4DRasN5AQvZkGt;

1.32
date	2017.06.04.22.43.50;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	HuVlLkzV75UMAm6A;

1.31
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	Ql2ha5NS80pwfGNT;

1.30
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	hxQV8O1pNUaef4ir;

1.29
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	191tWtskbsgcpQqV;

1.28
date	2015.03.09.17.41.36;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	EhhvqT5WwS4ZT2a7;

1.27
date	2015.03.09.17.30.29;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	r1WgCQO9Z80UjMXk;

1.26
date	2015.01.31.00.11.52;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	qr0IBCEkFSkiYkBc;

1.25
date	2015.01.30.17.31.20;	author schwarze;	state Exp;
branches;
next	1.24;
commitid	8uPgte1HahL1XRHj;

1.24
date	2015.01.30.04.08.37;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	KL58yWbJhw6UbgSB;

1.23
date	2015.01.30.02.08.37;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	vvSu12hfLARx94BX;

1.22
date	2015.01.28.04.18.31;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	ocR6zTNiM1va6QkO;

1.21
date	2015.01.27.05.20.30;	author schwarze;	state Exp;
branches;
next	1.20;
commitid	x93gRIdSgdjntkaE;

1.20
date	2014.12.24.15.37.23;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	y0mQnZaFXZeM8X5C;

1.19
date	2014.10.14.18.16.57;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	9r7EpXDHQfmQjagd;

1.18
date	2014.10.14.02.16.02;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	CvxMGBcRTJn11Q3v;

1.17
date	2014.10.13.23.31.26;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	8tCCJ2tENQLjxSIK;

1.16
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2014.03.28.23.25.54;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2013.05.31.21.37.09;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2012.05.27.01.01.24;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2012.05.26.20.53.17;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2012.05.26.20.03.34;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2011.09.20.23.05.46;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.25.12.07.26;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.16.01.11.50;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.09.14.30.48;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.15.22.16.51;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.15.22.07.12;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.15.21.33.47;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.15.19.20.03;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Ignore explicitly specified negative column widths rather than
wrapping around to huge numbers and risking memory exhaustion;
fixes Debian ps(1).  Bug reported by Dr. Markus Waldeck.
@
text
@/*	$OpenBSD: tbl_term.c,v 1.44 2017/07/08 13:43:09 schwarze Exp $ */
/*
 * Copyright (c) 2009, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011,2012,2014,2015,2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc.h"
#include "out.h"
#include "term.h"

#define	IS_HORIZ(cp)	((cp)->pos == TBL_CELL_HORIZ || \
			 (cp)->pos == TBL_CELL_DHORIZ)

static	size_t	term_tbl_len(size_t, void *);
static	size_t	term_tbl_strlen(const char *, void *);
static	size_t	term_tbl_sulen(const struct roffsu *, void *);
static	void	tbl_char(struct termp *, char, size_t);
static	void	tbl_data(struct termp *, const struct tbl_opts *,
			const struct tbl_cell *,
			const struct tbl_dat *,
			const struct roffcol *);
static	void	tbl_literal(struct termp *, const struct tbl_dat *,
			const struct roffcol *);
static	void	tbl_number(struct termp *, const struct tbl_opts *,
			const struct tbl_dat *,
			const struct roffcol *);
static	void	tbl_hrule(struct termp *, const struct tbl_span *, int);
static	void	tbl_word(struct termp *, const struct tbl_dat *);


static size_t
term_tbl_sulen(const struct roffsu *su, void *arg)
{
	int	 i;

	i = term_hen((const struct termp *)arg, su);
	return i > 0 ? i : 0;
}

static size_t
term_tbl_strlen(const char *p, void *arg)
{
	return term_strlen((const struct termp *)arg, p);
}

static size_t
term_tbl_len(size_t sz, void *arg)
{
	return term_len((const struct termp *)arg, sz);
}

void
term_tbl(struct termp *tp, const struct tbl_span *sp)
{
	const struct tbl_cell	*cp, *cpn, *cpp;
	const struct tbl_dat	*dp;
	static size_t		 offset;
	size_t			 coloff, tsz;
	int			 ic, horiz, spans, vert, more;
	char			 fc;

	/* Inhibit printing of spaces: we do padding ourselves. */

	tp->flags |= TERMP_NOSPACE | TERMP_NONOSPACE;

	/*
	 * The first time we're invoked for a given table block,
	 * calculate the table widths and decimal positions.
	 */

	if (tp->tbl.cols == NULL) {
		tp->tbl.len = term_tbl_len;
		tp->tbl.slen = term_tbl_strlen;
		tp->tbl.sulen = term_tbl_sulen;
		tp->tbl.arg = tp;

		tblcalc(&tp->tbl, sp, tp->tcol->offset, tp->tcol->rmargin);

		/* Tables leak .ta settings to subsequent text. */

		term_tab_set(tp, NULL);
		coloff = sp->opts->opts & (TBL_OPT_BOX | TBL_OPT_DBOX) ||
		    sp->opts->lvert;
		for (ic = 0; ic < sp->opts->cols; ic++) {
			coloff += tp->tbl.cols[ic].width;
			term_tab_iset(coloff);
			coloff += tp->tbl.cols[ic].spacing;
		}

		/* Center the table as a whole. */

		offset = tp->tcol->offset;
		if (sp->opts->opts & TBL_OPT_CENTRE) {
			tsz = sp->opts->opts & (TBL_OPT_BOX | TBL_OPT_DBOX)
			    ? 2 : !!sp->opts->lvert + !!sp->opts->rvert;
			for (ic = 0; ic + 1 < sp->opts->cols; ic++)
				tsz += tp->tbl.cols[ic].width +
				    tp->tbl.cols[ic].spacing;
			if (sp->opts->cols)
				tsz += tp->tbl.cols[sp->opts->cols - 1].width;
			if (offset + tsz > tp->tcol->rmargin)
				tsz -= 1;
			tp->tcol->offset = offset + tp->tcol->rmargin > tsz ?
			    (offset + tp->tcol->rmargin - tsz) / 2 : 0;
		}

		/* Horizontal frame at the start of boxed tables. */

		if (sp->opts->opts & TBL_OPT_DBOX)
			tbl_hrule(tp, sp, 3);
		if (sp->opts->opts & (TBL_OPT_DBOX | TBL_OPT_BOX))
			tbl_hrule(tp, sp, 2);
	}

	/* Set up the columns. */

	tp->flags |= TERMP_MULTICOL;
	horiz = 0;
	switch (sp->pos) {
	case TBL_SPAN_HORIZ:
	case TBL_SPAN_DHORIZ:
		horiz = 1;
		term_setcol(tp, 1);
		break;
	case TBL_SPAN_DATA:
		term_setcol(tp, sp->opts->cols + 2);
		coloff = tp->tcol->offset;

		/* Set up a column for a left vertical frame. */

		if (sp->opts->opts & (TBL_OPT_BOX | TBL_OPT_DBOX) ||
		    sp->opts->lvert)
			coloff++;
		tp->tcol->rmargin = coloff;

		/* Set up the data columns. */

		dp = sp->first;
		spans = 0;
		for (ic = 0; ic < sp->opts->cols; ic++) {
			if (spans == 0) {
				tp->tcol++;
				tp->tcol->offset = coloff;
			}
			coloff += tp->tbl.cols[ic].width;
			tp->tcol->rmargin = coloff;
			if (ic + 1 < sp->opts->cols)
				coloff += tp->tbl.cols[ic].spacing;
			if (spans) {
				spans--;
				continue;
			}
			if (dp == NULL)
				continue;
			spans = dp->spans;
			if (ic || sp->layout->first->pos != TBL_CELL_SPAN)
				dp = dp->next;
		}

		/* Set up a column for a right vertical frame. */

		tp->tcol++;
		tp->tcol->offset = coloff + 1;
		tp->tcol->rmargin = tp->maxrmargin;

		/* Spans may have reduced the number of columns. */

		tp->lasttcol = tp->tcol - tp->tcols;

		/* Fill the buffers for all data columns. */

		tp->tcol = tp->tcols;
		cp = cpn = sp->layout->first;
		dp = sp->first;
		spans = 0;
		for (ic = 0; ic < sp->opts->cols; ic++) {
			if (cpn != NULL) {
				cp = cpn;
				cpn = cpn->next;
			}
			if (spans) {
				spans--;
				continue;
			}
			tp->tcol++;
			tp->col = 0;
			tbl_data(tp, sp->opts, cp, dp, tp->tbl.cols + ic);
			if (dp == NULL)
				continue;
			spans = dp->spans;
			if (cp->pos != TBL_CELL_SPAN)
				dp = dp->next;
		}
		break;
	}

	do {
		/* Print the vertical frame at the start of each row. */

		tp->tcol = tp->tcols;
		fc = '\0';
		if (sp->layout->vert ||
		    (sp->next != NULL && sp->next->layout->vert &&
		     sp->next->pos == TBL_SPAN_DATA) ||
		    (sp->prev != NULL && sp->prev->layout->vert &&
		     (horiz || (IS_HORIZ(sp->layout->first) &&
		       !IS_HORIZ(sp->prev->layout->first)))) ||
		    sp->opts->opts & (TBL_OPT_BOX | TBL_OPT_DBOX))
			fc = horiz || IS_HORIZ(sp->layout->first) ? '+' : '|';
		else if (horiz && sp->opts->lvert)
			fc = '-';
		if (fc != '\0') {
			(*tp->advance)(tp, tp->tcols->offset);
			(*tp->letter)(tp, fc);
			tp->viscol = tp->tcol->offset + 1;
		}

		/* Print the data cells. */

		more = 0;
		if (horiz) {
			tbl_hrule(tp, sp, 0);
			term_flushln(tp);
		} else {
			cp = sp->layout->first;
			cpn = sp->next == NULL ? NULL :
			    sp->next->layout->first;
			cpp = sp->prev == NULL ? NULL :
			    sp->prev->layout->first;
			dp = sp->first;
			spans = 0;
			for (ic = 0; ic < sp->opts->cols; ic++) {

				/*
				 * Figure out whether to print a
				 * vertical line after this cell
				 * and advance to next layout cell.
				 */

				if (cp != NULL) {
					vert = cp->vert;
					switch (cp->pos) {
					case TBL_CELL_HORIZ:
						fc = '-';
						break;
					case TBL_CELL_DHORIZ:
						fc = '=';
						break;
					default:
						fc = ' ';
						break;
					}
				} else {
					vert = 0;
					fc = ' ';
				}
				if (cpp != NULL) {
					if (vert == 0 &&
					    cp != NULL &&
					    ((IS_HORIZ(cp) &&
					      !IS_HORIZ(cpp)) ||
					     (cp->next != NULL &&
					      cpp->next != NULL &&
					      IS_HORIZ(cp->next) &&
					      !IS_HORIZ(cpp->next))))
						vert = cpp->vert;
					cpp = cpp->next;
				}
				if (vert == 0 &&
				    sp->opts->opts & TBL_OPT_ALLBOX)
					vert = 1;
				if (cpn != NULL) {
					if (vert == 0)
						vert = cpn->vert;
					cpn = cpn->next;
				}
				if (cp != NULL)
					cp = cp->next;

				/*
				 * Skip later cells in a span,
				 * figure out whether to start a span,
				 * and advance to next data cell.
				 */

				if (spans) {
					spans--;
					continue;
				}
				if (dp != NULL) {
					spans = dp->spans;
					if (ic || sp->layout->first->pos
					    != TBL_CELL_SPAN)
						dp = dp->next;
				}

				/*
				 * Print one line of text in the cell
				 * and remember whether there is more.
				 */

				tp->tcol++;
				if (tp->tcol->col < tp->tcol->lastcol)
					term_flushln(tp);
				if (tp->tcol->col < tp->tcol->lastcol)
					more = 1;

				/*
				 * Vertical frames between data cells,
				 * but not after the last column.
				 */

				if (fc == ' ' && ((vert == 0 &&
				     (cp == NULL || !IS_HORIZ(cp))) ||
				    tp->tcol + 1 == tp->tcols + tp->lasttcol))
					continue;

				if (tp->viscol < tp->tcol->rmargin) {
					(*tp->advance)(tp, tp->tcol->rmargin
					   - tp->viscol);
					tp->viscol = tp->tcol->rmargin;
				}
				while (tp->viscol < tp->tcol->rmargin +
				    tp->tbl.cols[ic].spacing / 2) {
					(*tp->letter)(tp, fc);
					tp->viscol++;
				}

				if (tp->tcol + 1 == tp->tcols + tp->lasttcol)
					continue;

				if (fc == ' ' && cp != NULL) {
					switch (cp->pos) {
					case TBL_CELL_HORIZ:
						fc = '-';
						break;
					case TBL_CELL_DHORIZ:
						fc = '=';
						break;
					default:
						break;
					}
				}
				if (tp->tbl.cols[ic].spacing) {
					(*tp->letter)(tp, fc == ' ' ? '|' :
					    vert ? '+' : fc);
					tp->viscol++;
				}

				if (fc != ' ') {
					if (cp != NULL &&
					    cp->pos == TBL_CELL_HORIZ)
						fc = '-';
					else if (cp != NULL &&
					    cp->pos == TBL_CELL_DHORIZ)
						fc = '=';
					else
						fc = ' ';
				}
				if (tp->tbl.cols[ic].spacing > 2 &&
				    (vert > 1 || fc != ' ')) {
					(*tp->letter)(tp, fc == ' ' ? '|' :
					    vert > 1 ? '+' : fc);
					tp->viscol++;
				}
			}
		}

		/* Print the vertical frame at the end of each row. */

		fc = '\0';
		if ((sp->layout->last->vert &&
		     sp->layout->last->col + 1 == sp->opts->cols) ||
		    (sp->next != NULL &&
		     sp->next->layout->last->vert &&
		     sp->next->layout->last->col + 1 == sp->opts->cols) ||
		    (sp->prev != NULL &&
		     sp->prev->layout->last->vert &&
		     sp->prev->layout->last->col + 1 == sp->opts->cols &&
		     (horiz || (IS_HORIZ(sp->layout->last) &&
		      !IS_HORIZ(sp->prev->layout->last)))) ||
		    (sp->opts->opts & (TBL_OPT_BOX | TBL_OPT_DBOX)))
			fc = horiz || IS_HORIZ(sp->layout->last) ? '+' : '|';
		else if (horiz && sp->opts->rvert)
			fc = '-';
		if (fc != '\0') {
			if (horiz == 0 && (IS_HORIZ(sp->layout->last) == 0 ||
			    sp->layout->last->col + 1 < sp->opts->cols)) {
				tp->tcol++;
				(*tp->advance)(tp,
				    tp->tcol->offset > tp->viscol ?
				    tp->tcol->offset - tp->viscol : 1);
			}
			(*tp->letter)(tp, fc);
		}
		(*tp->endline)(tp);
		tp->viscol = 0;
	} while (more);

	/*
	 * Clean up after this row.  If it is the last line
	 * of the table, print the box line and clean up
	 * column data; otherwise, print the allbox line.
	 */

	term_setcol(tp, 1);
	tp->flags &= ~TERMP_MULTICOL;
	tp->tcol->rmargin = tp->maxrmargin;
	if (sp->next == NULL) {
		if (sp->opts->opts & (TBL_OPT_DBOX | TBL_OPT_BOX)) {
			tbl_hrule(tp, sp, 2);
			tp->skipvsp = 1;
		}
		if (sp->opts->opts & TBL_OPT_DBOX) {
			tbl_hrule(tp, sp, 3);
			tp->skipvsp = 2;
		}
		assert(tp->tbl.cols);
		free(tp->tbl.cols);
		tp->tbl.cols = NULL;
		tp->tcol->offset = offset;
	} else if (horiz == 0 && sp->opts->opts & TBL_OPT_ALLBOX &&
	    (sp->next == NULL || sp->next->pos == TBL_SPAN_DATA ||
	     sp->next->next != NULL))
		tbl_hrule(tp, sp, 1);

	tp->flags &= ~TERMP_NONOSPACE;
}

/*
 * Kinds of horizontal rulers:
 * 0: inside the table (single or double line with crossings)
 * 1: inside the table (single or double line with crossings and ends)
 * 2: inner frame (single line with crossings and ends)
 * 3: outer frame (single line without crossings with ends)
 */
static void
tbl_hrule(struct termp *tp, const struct tbl_span *sp, int kind)
{
	const struct tbl_cell *cp, *cpn, *cpp;
	const struct roffcol *col;
	int	 vert;
	char	 line, cross;

	line = (kind < 2 && TBL_SPAN_DHORIZ == sp->pos) ? '=' : '-';
	cross = (kind < 3) ? '+' : '-';

	if (kind)
		term_word(tp, "+");
	cp = sp->layout->first;
	cpp = kind || sp->prev == NULL ? NULL : sp->prev->layout->first;
	if (cpp == cp)
		cpp = NULL;
	cpn = kind > 1 || sp->next == NULL ? NULL : sp->next->layout->first;
	if (cpn == cp)
		cpn = NULL;
	for (;;) {
		col = tp->tbl.cols + cp->col;
		tbl_char(tp, line, col->width + col->spacing / 2);
		vert = cp->vert;
		if ((cp = cp->next) == NULL)
			 break;
		if (cpp != NULL) {
			if (vert < cpp->vert)
				vert = cpp->vert;
			cpp = cpp->next;
		}
		if (cpn != NULL) {
			if (vert < cpn->vert)
				vert = cpn->vert;
			cpn = cpn->next;
		}
		if (sp->opts->opts & TBL_OPT_ALLBOX && !vert)
			vert = 1;
		if (col->spacing)
			tbl_char(tp, vert ? cross : line, 1);
		if (col->spacing > 2)
			tbl_char(tp, vert > 1 ? cross : line, 1);
		if (col->spacing > 4)
			tbl_char(tp, line, (col->spacing - 3) / 2);
	}
	if (kind) {
		term_word(tp, "+");
		term_flushln(tp);
	}
}

static void
tbl_data(struct termp *tp, const struct tbl_opts *opts,
    const struct tbl_cell *cp, const struct tbl_dat *dp,
    const struct roffcol *col)
{
	switch (cp->pos) {
	case TBL_CELL_HORIZ:
		tbl_char(tp, '-', col->width);
		return;
	case TBL_CELL_DHORIZ:
		tbl_char(tp, '=', col->width);
		return;
	default:
		break;
	}

	if (dp == NULL)
		return;

	switch (dp->pos) {
	case TBL_DATA_NONE:
		return;
	case TBL_DATA_HORIZ:
	case TBL_DATA_NHORIZ:
		tbl_char(tp, '-', col->width);
		return;
	case TBL_DATA_NDHORIZ:
	case TBL_DATA_DHORIZ:
		tbl_char(tp, '=', col->width);
		return;
	default:
		break;
	}

	switch (cp->pos) {
	case TBL_CELL_LONG:
	case TBL_CELL_CENTRE:
	case TBL_CELL_LEFT:
	case TBL_CELL_RIGHT:
		tbl_literal(tp, dp, col);
		break;
	case TBL_CELL_NUMBER:
		tbl_number(tp, opts, dp, col);
		break;
	case TBL_CELL_DOWN:
	case TBL_CELL_SPAN:
		break;
	default:
		abort();
	}
}

static void
tbl_char(struct termp *tp, char c, size_t len)
{
	size_t		i, sz;
	char		cp[2];

	cp[0] = c;
	cp[1] = '\0';

	sz = term_strlen(tp, cp);

	for (i = 0; i < len; i += sz)
		term_word(tp, cp);
}

static void
tbl_literal(struct termp *tp, const struct tbl_dat *dp,
		const struct roffcol *col)
{
	size_t		 len, padl, padr, width;
	int		 ic, spans;

	assert(dp->string);
	len = term_strlen(tp, dp->string);
	width = col->width;
	ic = dp->layout->col;
	spans = dp->spans;
	while (spans--)
		width += tp->tbl.cols[++ic].width + 3;

	padr = width > len ? width - len : 0;
	padl = 0;

	switch (dp->layout->pos) {
	case TBL_CELL_LONG:
		padl = term_len(tp, 1);
		padr = padr > padl ? padr - padl : 0;
		break;
	case TBL_CELL_CENTRE:
		if (2 > padr)
			break;
		padl = padr / 2;
		padr -= padl;
		break;
	case TBL_CELL_RIGHT:
		padl = padr;
		padr = 0;
		break;
	default:
		break;
	}

	tbl_char(tp, ASCII_NBRSP, padl);
	tbl_word(tp, dp);
	tbl_char(tp, ASCII_NBRSP, padr);
}

static void
tbl_number(struct termp *tp, const struct tbl_opts *opts,
		const struct tbl_dat *dp,
		const struct roffcol *col)
{
	char		*cp;
	char		 buf[2];
	size_t		 sz, psz, ssz, d, padl;
	int		 i;

	/*
	 * See calc_data_number().  Left-pad by taking the offset of our
	 * and the maximum decimal; right-pad by the remaining amount.
	 */

	assert(dp->string);

	sz = term_strlen(tp, dp->string);

	buf[0] = opts->decimal;
	buf[1] = '\0';

	psz = term_strlen(tp, buf);

	if ((cp = strrchr(dp->string, opts->decimal)) != NULL) {
		for (ssz = 0, i = 0; cp != &dp->string[i]; i++) {
			buf[0] = dp->string[i];
			ssz += term_strlen(tp, buf);
		}
		d = ssz + psz;
	} else
		d = sz + psz;

	if (col->decimal > d && col->width > sz) {
		padl = col->decimal - d;
		if (padl + sz > col->width)
			padl = col->width - sz;
		tbl_char(tp, ASCII_NBRSP, padl);
	} else
		padl = 0;
	tbl_word(tp, dp);
	if (col->width > sz + padl)
		tbl_char(tp, ASCII_NBRSP, col->width - sz - padl);
}

static void
tbl_word(struct termp *tp, const struct tbl_dat *dp)
{
	int		 prev_font;

	prev_font = tp->fonti;
	if (dp->layout->flags & TBL_CELL_BOLD)
		term_fontpush(tp, TERMFONT_BOLD);
	else if (dp->layout->flags & TBL_CELL_ITALIC)
		term_fontpush(tp, TERMFONT_UNDER);

	term_word(tp, dp->string);

	term_fontpopq(tp, prev_font);
}
@


1.44
log
@Correctly handle horizontal spans at the beginning of rows,
fixing an assertion failure found by jsg@@ with afl(1).

While here, also drop printing of whitespace in tbl_data()
which makes no difference because column positioning code
in term_tbl() already takes care of that.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.43 2017/06/27 18:23:29 schwarze Exp $ */
d52 4
a55 1
	return term_hen((const struct termp *)arg, su);
@


1.43
log
@Implement spacing of columns as defined in the table layout;
this is for example used by lftp(1)
and, ironically, misused by our very own tbl(7) manual...
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.42 2017/06/17 14:55:02 schwarze Exp $ */
d171 2
a172 1
			dp = dp->next;
d206 2
a207 1
			dp = dp->next;
d307 3
a309 1
					dp = dp->next;
d519 1
a519 2
	if (dp == NULL) {
		tbl_char(tp, ASCII_NBRSP, col->width);
a520 1
	}
a523 1
		tbl_char(tp, ASCII_NBRSP, col->width);
d548 1
a548 1
		tbl_char(tp, ASCII_NBRSP, col->width);
@


1.42
log
@tables leak tab settings to subsequent text
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.41 2017/06/16 20:00:41 schwarze Exp $ */
d102 1
a102 1
			coloff += 3;
d111 5
a115 3
			for (ic = 0; ic < sp->opts->cols; ic++)
				tsz += tp->tbl.cols[ic].width + 3;
			tsz -= 3;
a161 1
			coloff++;
d163 1
a163 1
				coloff += 2;
d177 1
a177 1
		tp->tcol->offset = coloff;
d329 1
a329 1
				if (tp->tcol->rmargin > tp->viscol) {
d334 2
a335 2

				if (tp->tcol->rmargin + 1 > tp->viscol) {
d355 5
a359 4

				(*tp->letter)(tp,
				    fc == ' ' ? '|' : vert ? '+' : fc);
				tp->viscol++;
d371 2
a372 1
				if (vert > 1 || fc != ' ') {
d452 1
d469 2
a470 1
		tbl_char(tp, line, tp->tbl.cols[cp->col].width + 1);
d486 6
a491 4
		if (vert)
			tbl_char(tp, cross, vert);
		if (vert < 2)
			tbl_char(tp, line, 2 - vert);
@


1.41
log
@Multiple tbl(7) improvements:
* Do not discard data that lacks a matching layout cell but remains
within the number of columns of the table as a whole.
* Do not insert dummy data rows for any layout row starting with a
horizontal line, but only for layout rows that would discard all
the data on a matching non-empty data row.
* Print horizontal lines specified in the layout even if there is
no matching data cell.
* Improve the logic for extending vertical lines to adjacent rows,
for choosing cross marks versus line segments, and some related details.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.40 2017/06/14 17:50:43 schwarze Exp $ */
d93 11
@


1.40
log
@improve rounding rules for scaling units
in horizontal orientation in the terminal formatter
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.39 2017/06/13 14:38:38 schwarze Exp $ */
d29 3
d37 1
d70 1
a70 1
	const struct tbl_cell	*cp;
d112 2
a114 2
		if (sp->opts->opts & (TBL_OPT_DBOX | TBL_OPT_BOX))
			tbl_hrule(tp, sp, 1);
d166 1
a166 4
		if (sp->opts->opts & (TBL_OPT_BOX | TBL_OPT_DBOX) ||
		    sp->opts->rvert)
			coloff++;
		tp->tcol->rmargin = coloff;
d175 1
d179 4
d189 1
a189 1
			tbl_data(tp, sp->opts, dp, tp->tbl.cols + ic);
d204 5
a208 1
		    (sp->prev != NULL && sp->prev->layout->vert) ||
d210 1
a210 1
			fc = horiz ? '+' : '|';
d227 4
d235 5
a239 1
				/* Advance to next layout cell. */
d243 36
a279 2
				} else
					vert = 0;
d281 5
a285 1
				/* Skip later cells in a span. */
a290 3

				/* Advance to next data cell. */

d296 4
a299 1
				/* Print one line of text in the cell. */
d312 16
a329 5
				if (vert == 0 &&
				    sp->opts->opts & TBL_OPT_ALLBOX)
					vert = 1;
				if (vert == 0)
					continue;
d331 26
a356 4
				if (tp->tcol->rmargin + 1 > tp->viscol) {
					(*tp->advance)(tp, tp->tcol->rmargin
					   + 1 - tp->viscol);
					tp->viscol = tp->tcol->rmargin + 1;
d358 3
a360 2
				while (vert--) {
					(*tp->letter)(tp, '|');
d369 10
a378 2
		if (sp->layout->last->vert ||
		    (sp->prev != NULL && sp->prev->layout->last->vert) ||
d380 1
a380 1
			fc = horiz ? '+' : '|';
d384 2
a385 1
			if (horiz == 0) {
d398 3
a400 2
	 * If we're the last row, clean up after ourselves: clear the
	 * existing table configuration and set it to NULL.
d408 1
a408 1
			tbl_hrule(tp, sp, 1);
d412 1
a412 1
			tbl_hrule(tp, sp, 2);
d430 3
a432 2
 * 1: inner frame (single line with crossings and ends)
 * 2: outer frame (single line without crossings with ends)
d437 1
a437 1
	const struct tbl_cell *c1, *c2;
d441 2
a442 2
	line = (kind == 0 && TBL_SPAN_DHORIZ == sp->pos) ? '=' : '-';
	cross = (kind < 2) ? '+' : '-';
d446 7
a452 4
	c1 = sp->layout->first;
	c2 = sp->prev == NULL ? NULL : sp->prev->layout->first;
	if (c2 == c1)
		c2 = NULL;
d454 3
a456 3
		tbl_char(tp, line, tp->tbl.cols[c1->col].width + 1);
		vert = c1->vert;
		if ((c1 = c1->next) == NULL)
d458 9
a466 4
		if (c2 != NULL) {
			if (vert < c2->vert)
				vert = c2->vert;
			c2 = c2->next;
d483 2
a484 2
	const struct tbl_dat *dp,
	const struct roffcol *col)
d486 10
d518 1
a518 7
	switch (dp->layout->pos) {
	case TBL_CELL_HORIZ:
		tbl_char(tp, '-', col->width);
		break;
	case TBL_CELL_DHORIZ:
		tbl_char(tp, '=', col->width);
		break;
@


1.39
log
@fix the interaction of the allbox option with spanned cells in the layout
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.38 2017/06/12 22:48:52 schwarze Exp $ */
d48 1
a48 1
	return term_hspan((const struct termp *)arg, su) / 24;
@


1.38
log
@Two minor fixes for the "allbox" modifier:
1. It does not reduce explicit "||" in the layout to "|".
2. It does not cause three horizontal lines at the end of a table,
even if the table ends with an explicit "_" data line.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.37 2017/06/12 20:44:57 schwarze Exp $ */
a219 15
				if (spans == 0) {
					tp->tcol++;
					if (dp != NULL) {
						spans = dp->spans;
						dp = dp->next;
					}
					if (tp->tcol->col < tp->tcol->lastcol)
						term_flushln(tp);
					if (tp->tcol->col < tp->tcol->lastcol)
						more = 1;
					if (tp->tcol + 1 ==
					    tp->tcols + tp->lasttcol)
						continue;
				} else
					spans--;
d221 1
a221 1
				/* Vertical frames between data cells. */
d228 30
@


1.37
log
@implement the tbl(7) "allbox" option;
used for example by curs_getch(3) and GLwDrawingArea(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.36 2017/06/12 20:14:03 schwarze Exp $ */
d243 2
a244 1
				if (sp->opts->opts & TBL_OPT_ALLBOX)
d304 3
a306 1
	} else if (horiz == 0 && sp->opts->opts & TBL_OPT_ALLBOX)
@


1.36
log
@fix column width calculation for text block cells
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.35 2017/06/12 18:55:42 schwarze Exp $ */
d243 2
d303 3
a305 1
	}
d341 2
@


1.35
log
@Implement automatic line breaking
inside individual table cells that contain text blocks.
This cures overlong lines in various Xenocara manuals.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.34 2017/06/08 18:11:15 schwarze Exp $ */
d88 1
a88 1
		tblcalc(&tp->tbl, sp, tp->tcol->rmargin - tp->tcol->offset);
@


1.34
log
@Implement w layout specifier (minimum column width).
Improve width calculation of text blocks.
Reduces the groff/mandoc diff in Base+Xenocara by about 800 lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.33 2017/06/07 17:38:08 schwarze Exp $ */
d69 3
a71 2
	size_t			 tsz;
	int			 ic, horiz, spans, vert;
d75 1
a75 1
	tp->flags |= TERMP_NOSPACE | TERMP_NONOSPACE | TERMP_BRNEVER;
d113 1
a113 1
	/* Vertical frame at the start of each row. */
d115 18
a132 1
	horiz = sp->pos == TBL_SPAN_HORIZ || sp->pos == TBL_SPAN_DHORIZ;
d134 1
a134 6
	if (sp->layout->vert ||
	    (sp->prev != NULL && sp->prev->layout->vert) ||
	    sp->opts->opts & (TBL_OPT_BOX | TBL_OPT_DBOX))
		term_word(tp, horiz ? "+" : "|");
	else if (sp->opts->lvert)
		tbl_char(tp, horiz ? '-' : ASCII_NBRSP, 1);
d136 36
a171 4
	/*
	 * Now print the actual data itself depending on the span type.
	 * Match data cells to column numbers.
	 */
d173 1
a173 2
	if (sp->pos == TBL_SPAN_DATA) {
		cp = sp->layout->first;
d177 31
d209 1
a209 10
			/*
			 * Remeber whether we need a vertical bar
			 * after this cell.
			 */

			vert = cp == NULL ? 0 : cp->vert;

			/*
			 * Print the data and advance to the next cell.
			 */
d211 43
a253 5
			if (spans == 0) {
				tbl_data(tp, sp->opts, dp, tp->tbl.cols + ic);
				if (dp != NULL) {
					spans = dp->spans;
					dp = dp->next;
d255 2
a256 4
			} else
				spans--;
			if (cp != NULL)
				cp = cp->next;
d258 1
a258 4
			/*
			 * Separate columns, except in the middle
			 * of spans and after the last cell.
			 */
d260 19
a278 21
			if (ic + 1 == sp->opts->cols || spans)
				continue;

			tbl_char(tp, ASCII_NBRSP, 1);
			if (vert > 0)
				tbl_char(tp, '|', vert);
			if (vert < 2)
				tbl_char(tp, ASCII_NBRSP, 2 - vert);
		}
	} else if (horiz)
		tbl_hrule(tp, sp, 0);

	/* Vertical frame at the end of each row. */

	if (sp->layout->last->vert ||
	    (sp->prev != NULL && sp->prev->layout->last->vert) ||
	    (sp->opts->opts & (TBL_OPT_BOX | TBL_OPT_DBOX)))
		term_word(tp, horiz ? "+" : " |");
	else if (sp->opts->rvert)
		tbl_char(tp, horiz ? '-' : ASCII_NBRSP, 1);
	term_flushln(tp);
d285 3
d302 1
a302 1
	tp->flags &= ~(TERMP_NONOSPACE | TERMP_BRNEVER);
@


1.33
log
@Prepare the terminal driver for filling multiple columns in parallel,
first step: split column data out of the terminal state struct into
a new column state struct and use an array of such column state
structs.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.32 2017/06/04 22:43:50 schwarze Exp $ */
d31 1
d46 6
a53 1

a59 1

d84 1
@


1.32
log
@Implement the roff(7) .mc (right margin character) request.
The Tcl/Tk manual pages use this extensively.
Delete the TERM_MAXMARGIN hack, it breaks .mc inside .nf;
instead, implement a proper TERMP_BRNEVER flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.31 2015/10/12 00:07:27 schwarze Exp $ */
d81 1
a81 1
		tblcalc(&tp->tbl, sp, tp->rmargin - tp->offset);
d85 1
a85 1
		offset = tp->offset;
d92 1
a92 1
			if (offset + tsz > tp->rmargin)
d94 2
a95 2
			tp->offset = (offset + tp->rmargin > tsz) ?
			    (offset + tp->rmargin - tsz) / 2 : 0;
d194 1
a194 1
		tp->offset = offset;
@


1.31
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.30 2015/10/06 18:30:44 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
d64 1
a64 1
	size_t			 rmargin, maxrmargin, tsz;
a66 5
	rmargin = tp->rmargin;
	maxrmargin = tp->maxrmargin;

	tp->rmargin = tp->maxrmargin = TERM_MAXMARGIN;

d69 1
a69 2
	tp->flags |= TERMP_NONOSPACE;
	tp->flags |= TERMP_NOSPACE;
d81 1
a81 1
		tblcalc(&tp->tbl, sp, rmargin - tp->offset);
d92 1
a92 1
			if (offset + tsz > rmargin)
d94 2
a95 2
			tp->offset = (offset + rmargin > tsz) ?
			    (offset + rmargin - tsz) / 2 : 0;
d196 1
a196 4

	tp->flags &= ~TERMP_NONOSPACE;
	tp->rmargin = rmargin;
	tp->maxrmargin = maxrmargin;
@


1.30
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.29 2015/09/26 00:53:15 schwarze Exp $ */
a266 1
		/* FALLTHROUGH */
a270 1
		/* FALLTHROUGH */
a285 1
		/* FALLTHROUGH */
a286 1
		/* FALLTHROUGH */
a287 1
		/* FALLTHROUGH */
@


1.29
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.28 2015/03/09 17:41:36 schwarze Exp $ */
d48 1
a48 1
	return(term_strlen((const struct termp *)arg, p));
d55 1
a55 1
	return(term_len((const struct termp *)arg, sz));
@


1.28
log
@Fix vertical spacing at the beginning of tables.
man(7) always prints a blank line, mdoc(7) doesn't.
Problem in mdoc(7) reported by kristaps@@.
mdoc(7) part of the patch tested by kristaps@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.27 2015/03/09 17:30:29 schwarze Exp $ */
a303 1
		/* NOTREACHED */
@


1.27
log
@Flush the line preceding a table before clearing the right margin,
such that that line isn't output with unlimited width.
Problem reported and fix OK by kristaps@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.26 2015/01/31 00:11:52 schwarze Exp $ */
a65 3

	if (tp->tbl.cols == NULL)
		term_flushln(tp);
@


1.26
log
@Use relative offsets instead of absolute pointers for the terminal
font stack.  The latter fail after the stack is grown with realloc().
Fixing an assertion failure found by jsg@@ with afl some time ago
(test case number 51).
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.25 2015/01/30 17:31:20 schwarze Exp $ */
d67 3
a85 2
		term_flushln(tp);

@


1.25
log
@Delete the redundant tbl span flags, just inspect the actual data
where needed, which is less fragile.
This fixes a subtle NULL pointer access to tp->tbl.cols:
Due to a bug in the man(7) parser, the first span of a table can
end up in a .TP head, in which case tblcalc() was never called.
Found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.24 2015/01/30 04:08:37 schwarze Exp $ */
d415 1
a415 1
	const void	*prev_font;
d417 1
a417 1
	prev_font = term_fontq(tp);
@


1.24
log
@Abolish struct tbl_head and replace it by an "int col" member in
struct tbl_cell.  No functional change, minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.23 2015/01/30 02:08:37 schwarze Exp $ */
d82 1
a82 1
	if (sp->flags & TBL_SPAN_FIRST) {
d190 1
a190 1
	if (sp->flags & TBL_SPAN_LAST) {
@


1.23
log
@Auditing the tbl(7) code for more NULL pointer accesses, i came out
empty-handed; so this is just KNF and some code simplifications,
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.22 2015/01/28 04:18:31 schwarze Exp $ */
a60 1
	const struct tbl_head	*hp;
d65 1
a65 1
	int			 horiz, spans, vert;
d97 2
a98 2
			for (hp = sp->head; hp != NULL; hp = hp->next)
				tsz += tp->tbl.cols[hp->ident].width + 3;
d127 1
a127 2
	 * Spanner spans get a horizontal rule; data spanners have their
	 * data printed by matching data to header.
a130 1
		/* Iterate over template headers. */
d134 1
a134 1
		for (hp = sp->head; hp != NULL; hp = hp->next) {
d148 1
a148 2
				tbl_data(tp, sp->opts, dp,
				    tp->tbl.cols + hp->ident);
d163 1
a163 1
			if (hp->next == NULL || spans)
d169 1
a169 1
			if (vert < 2 && hp->next != NULL)
d233 1
a233 1
		tbl_char(tp, line, tp->tbl.cols[c1->head->ident].width + 1);
d329 2
a330 3
	struct tbl_head		*hp;
	size_t			 width, len, padl, padr;
	int			 spans;
a333 2

	hp = dp->layout->head->next;
d335 4
a338 2
	for (spans = dp->spans; spans--; hp = hp->next)
		width += tp->tbl.cols[hp->ident].width + 3;
@


1.22
log
@implement the tbl(7) "center" layout option
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.21 2015/01/27 05:20:30 schwarze Exp $ */
d263 1
a263 1
	if (NULL == dp) {
a266 1
	assert(dp->layout);
d396 1
a396 2
	if (NULL != (cp = strrchr(dp->string, opts->decimal))) {
		buf[1] = '\0';
@


1.21
log
@Multiple parser and formatter fixes for line drawing in tbl(7).
* Allow mixing vertical line bars with the layout options
of the preceding layout cell.
* Correctly combine box options with layout lines.
* Correctly print vertical lines in data rows, with the right spacing.
* Correctly print cross markers and left and right ends of
horizontal lines even if vertical lines differ above and below.
* Avoid the bogus error message "no table data cells"
when a table data section starts with a horizontal line.
No increase in code size.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.20 2014/12/24 15:37:23 schwarze Exp $ */
d64 2
a66 1
	size_t			 rmargin, maxrmargin;
d92 15
d206 1
a211 1

@


1.20
log
@Prevent unsigned integer underflow when a number is too wide
for a table cell with an "nz" layout specification,
causing essentially infinite output as found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.19 2014/10/14 18:16:57 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012, 2014 Ingo Schwarze <schwarze@@openbsd.org>
a34 2
static	size_t	tbl_rulewidth(struct termp *, const struct tbl_head *);
static	void	tbl_hframe(struct termp *, const struct tbl_span *, int);
d40 1
a40 2
static	void	tbl_hrule(struct termp *, const struct tbl_span *);
static	void	tbl_vrule(struct termp *, const struct tbl_head *);
d62 1
d64 1
a64 2
	struct roffcol		*col;
	int			 spans;
d82 1
a82 1
	if (TBL_SPAN_FIRST & sp->flags) {
a89 1
	}
d91 1
a91 1
	/* Horizontal frame at the start of boxed tables. */
d93 4
a96 6
	if (TBL_SPAN_FIRST & sp->flags) {
		if (TBL_OPT_DBOX & sp->opts->opts)
			tbl_hframe(tp, sp, 1);
		if (TBL_OPT_DBOX & sp->opts->opts ||
		    TBL_OPT_BOX  & sp->opts->opts)
			tbl_hframe(tp, sp, 0);
d101 8
a108 4
	if ((TBL_OPT_BOX | TBL_OPT_DBOX) & sp->opts->opts ||
	    (sp->head != NULL && sp->head->vert))
		term_word(tp, TBL_SPAN_HORIZ == sp->pos ||
		    TBL_SPAN_DHORIZ == sp->pos ? "+" : "|");
d116 1
a116 7
	switch (sp->pos) {
	case TBL_SPAN_HORIZ:
		/* FALLTHROUGH */
	case TBL_SPAN_DHORIZ:
		tbl_hrule(tp, sp);
		break;
	case TBL_SPAN_DATA:
d118 1
d121 1
a121 1
		for (hp = sp->head; hp; hp = hp->next) {
d124 2
a125 3
			 * If the current data header is invoked during
			 * a spanner ("spans" > 0), don't emit anything
			 * at all.
d128 1
a128 4
			if (--spans >= 0)
				continue;

			/* Separate columns. */
d130 3
a132 2
			if (NULL != hp->prev)
				tbl_vrule(tp, hp);
d134 11
a144 2
			col = &tp->tbl.cols[hp->ident];
			tbl_data(tp, sp->opts, dp, col);
d147 2
a148 2
			 * Go to the next data cell and assign the
			 * number of subsequent spans, if applicable.
d151 8
a158 4
			if (dp) {
				spans = dp->spans;
				dp = dp->next;
			}
d160 2
a161 2
		break;
	}
d165 6
a170 4
	if ((TBL_OPT_BOX | TBL_OPT_DBOX) & sp->opts->opts ||
	    sp->layout->vert)
		term_word(tp, TBL_SPAN_HORIZ == sp->pos ||
		    TBL_SPAN_DHORIZ == sp->pos ? "+" : " |");
d178 3
a180 4
	if (TBL_SPAN_LAST & sp->flags) {
		if (TBL_OPT_DBOX & sp->opts->opts ||
		    TBL_OPT_BOX  & sp->opts->opts) {
			tbl_hframe(tp, sp, 0);
d183 2
a184 2
		if (TBL_OPT_DBOX & sp->opts->opts) {
			tbl_hframe(tp, sp, 1);
d199 4
a202 23
 * Horizontal rules extend across the entire table.
 * Calculate the width by iterating over columns.
 */
static size_t
tbl_rulewidth(struct termp *tp, const struct tbl_head *hp)
{
	size_t		 width;

	width = tp->tbl.cols[hp->ident].width;

	/* Account for leading blanks. */
	if (hp->prev)
		width += 2 - hp->vert;

	/* Account for trailing blank. */
	width++;

	return(width);
}

/*
 * Rules inside the table can be single or double
 * and have crossings with vertical rules marked with pluses.
d205 1
a205 1
tbl_hrule(struct termp *tp, const struct tbl_span *sp)
d207 27
a233 11
	const struct tbl_head *hp;
	char		 c;

	c = '-';
	if (TBL_SPAN_DHORIZ == sp->pos)
		c = '=';

	for (hp = sp->head; hp; hp = hp->next) {
		if (hp->prev && hp->vert)
			tbl_char(tp, '+', hp->vert);
		tbl_char(tp, c, tbl_rulewidth(tp, hp));
d235 3
a237 18
}

/*
 * Rules above and below the table are always single
 * and have an additional plus at the beginning and end.
 * For double frames, this function is called twice,
 * and the outer one does not have crossings.
 */
static void
tbl_hframe(struct termp *tp, const struct tbl_span *sp, int outer)
{
	const struct tbl_head *hp;

	term_word(tp, "+");
	for (hp = sp->head; hp; hp = hp->next) {
		if (hp->prev && hp->vert)
			tbl_char(tp, (outer ? '-' : '+'), hp->vert);
		tbl_char(tp, '-', tbl_rulewidth(tp, hp));
a238 2
	term_word(tp, "+");
	term_flushln(tp);
a296 11
}

static void
tbl_vrule(struct termp *tp, const struct tbl_head *hp)
{

	tbl_char(tp, ASCII_NBRSP, 1);
	if (0 < hp->vert)
		tbl_char(tp, '|', hp->vert);
	if (2 > hp->vert)
		tbl_char(tp, ASCII_NBRSP, 2 - hp->vert);
@


1.19
log
@even if a table has zero columns, do not segfault in the formatter;
bug reported by bentley@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.18 2014/10/14 02:16:02 schwarze Exp $ */
d418 7
a424 3
	padl = col->decimal - d;

	tbl_char(tp, ASCII_NBRSP, padl);
@


1.18
log
@Rudimentary implementation of the e, x, and z table layout modifiers
to equalize, maximize, and ignore the width of columns.
Does not yet take vertical rulers into account,
and does not do line breaks within table cells.
Considerably improves the lftp(1) manual; issue noticed by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_term.c,v 1.17 2014/10/13 23:31:26 schwarze Exp $ */
d108 1
a108 1
	    sp->head->vert)
@


1.17
log
@implement font modifiers in table layouts
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d92 1
a92 1
		tblcalc(&tp->tbl, sp);
@


1.16
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.15 2014/03/28 23:25:54 schwarze Exp $ */
d18 2
d44 1
d380 1
a380 1
	term_word(tp, dp->string);
d421 1
a421 1
	term_word(tp, dp->string);
d426 15
@


1.15
log
@Allow leading and trailing vertical lines,
and format them in the same way as groff.
While here, do not require whitespace before vertical lines
in layout specifications.
Issues found by bentley@@ in mpv(1).
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.14 2013/05/31 21:37:09 schwarze Exp $ */
d31 1
a31 1
			const struct tbl_dat *, 
d35 1
a35 1
static	void	tbl_literal(struct termp *, const struct tbl_dat *, 
d37 2
a38 2
static	void	tbl_number(struct termp *, const struct tbl_opts *, 
			const struct tbl_dat *, 
d65 1
a65 1
	size_t		   	 rmargin, maxrmargin;
d107 1
a107 1
			TBL_SPAN_DHORIZ == sp->pos ? "+" : "|");
d116 1
a116 1
	case (TBL_SPAN_HORIZ):
d118 1
a118 1
	case (TBL_SPAN_DHORIZ):
d121 1
a121 1
	case (TBL_SPAN_DATA):
d127 1
a127 1
			/* 
d144 1
a144 1
			/* 
d162 1
a162 1
			TBL_SPAN_DHORIZ == sp->pos ? "+" : " |");
d256 2
a257 2
		const struct tbl_dat *dp, 
		const struct roffcol *col)
d267 1
a267 1
	case (TBL_DATA_NONE):
d270 1
a270 1
	case (TBL_DATA_HORIZ):
d272 1
a272 1
	case (TBL_DATA_NHORIZ):
d275 1
a275 1
	case (TBL_DATA_NDHORIZ):
d277 1
a277 1
	case (TBL_DATA_DHORIZ):
d283 1
a283 1
	
d285 1
a285 1
	case (TBL_CELL_HORIZ):
d288 1
a288 1
	case (TBL_CELL_DHORIZ):
d291 1
a291 1
	case (TBL_CELL_LONG):
d293 1
a293 1
	case (TBL_CELL_CENTRE):
d295 1
a295 1
	case (TBL_CELL_LEFT):
d297 1
a297 1
	case (TBL_CELL_RIGHT):
d300 1
a300 1
	case (TBL_CELL_NUMBER):
d303 1
a303 1
	case (TBL_CELL_DOWN):
d339 1
a339 1
tbl_literal(struct termp *tp, const struct tbl_dat *dp, 
d358 1
a358 1
	case (TBL_CELL_LONG):
d362 1
a362 1
	case (TBL_CELL_CENTRE):
d368 1
a368 1
	case (TBL_CELL_RIGHT):
@


1.14
log
@The name "struct tbl" was badly misleading for two reasons:
1) This struct almost exclusively contains the table options.
2) Information about the table as a whole is actually in "struct tbl_node".
Besides, "struct tbl" was almost impossible to search for.
So rename it to "struct tbl_opts".  No functional change.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.13 2012/05/27 01:01:24 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d104 2
a105 1
	if (TBL_OPT_BOX & sp->opts->opts || TBL_OPT_DBOX & sp->opts->opts)
d159 2
a160 1
	if (TBL_OPT_BOX & sp->opts->opts || TBL_OPT_DBOX & sp->opts->opts)
@


1.13
log
@Fix the vertical spacing around tbl(7) instances in man(7).

Groff forces the document author to manually request sufficient spacing
after .TE - that is, at least .sp 1v after a table with the "box" option
and at least .sp 2v after a table with the "doublebox" option - or else
it clobbers the box.  I consider that insane, so i'm not imitating groff
in that respect.  Instead, i add at least as much vertical space as groff,
or more where required to avoid clobbering the box.

Consequently, output will be identical for input that looks sane with
groff, and mandoc will make output look better for input that looks bad
with groff.

As a side effect, having identical output for portable input
makes it possible to set up the first regression tests for tbl(7).
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.12 2012/05/26 20:53:17 schwarze Exp $ */
d30 1
a30 1
static	void	tbl_data(struct termp *, const struct tbl *,
d37 1
a37 1
static	void	tbl_number(struct termp *, const struct tbl *, 
d95 1
a95 1
		if (TBL_OPT_DBOX & sp->tbl->opts)
d97 2
a98 2
		if (TBL_OPT_DBOX & sp->tbl->opts ||
		    TBL_OPT_BOX  & sp->tbl->opts)
d104 1
a104 1
	if (TBL_OPT_BOX & sp->tbl->opts || TBL_OPT_DBOX & sp->tbl->opts)
d141 1
a141 1
			tbl_data(tp, sp->tbl, dp, col);
d158 1
a158 1
	if (TBL_OPT_BOX & sp->tbl->opts || TBL_OPT_DBOX & sp->tbl->opts)
d169 2
a170 2
		if (TBL_OPT_DBOX & sp->tbl->opts ||
		    TBL_OPT_BOX  & sp->tbl->opts) {
d174 1
a174 1
		if (TBL_OPT_DBOX & sp->tbl->opts) {
d253 1
a253 1
tbl_data(struct termp *tp, const struct tbl *tbl,
d299 1
a299 1
		tbl_number(tp, tbl, dp, col);
d380 1
a380 1
tbl_number(struct termp *tp, const struct tbl *tbl,
d398 1
a398 1
	buf[0] = tbl->decimal;
d403 1
a403 1
	if (NULL != (cp = strrchr(dp->string, tbl->decimal))) {
@


1.12
log
@Correct width of horizontal spans; relevant in case of centered or
flush right text, for boxes, and when more columns follow the span.

Issue found by sthen@@ in the net/arp-scan(1) port manual.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.11 2012/05/26 20:03:34 schwarze Exp $ */
d170 1
a170 1
		    TBL_OPT_BOX  & sp->tbl->opts)
d172 3
a174 1
		if (TBL_OPT_DBOX & sp->tbl->opts)
d176 2
@


1.11
log
@Do not handle vertical lines as additional tbl(7) columns,
instead save their properties with the following column.
This simplifies layout parsing and saves a lot of code
related to column handling.

At output time, print all white space and vertical lines
separating columns before printing the following column,
and none after printing the preceding column, considerably
simplifying white space handling and width calculations.

No functional change, but it saves 150 lines of code,
and it allows the next patch to tbl_term.c, tbl_literal().
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.10 2011/09/20 23:05:46 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
d336 3
a338 1
	size_t		 len, padl, padr;
d342 7
a348 1
	padr = col->width > len ? col->width - len : 0;
@


1.10
log
@Major rewrite of the horizontal spacing of tables
to work both with and without frames and rulers.
Started during BSDCan 2011 in Ottawa, finished during s2k11 in Ljubljana.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.9 2011/09/18 15:54:48 schwarze Exp $ */
d125 1
a130 10
			switch (hp->pos) {
			case (TBL_HEAD_VERT):
				/* FALLTHROUGH */
			case (TBL_HEAD_DVERT):
				if (spans <= 0)
					tbl_vrule(tp, hp);
				continue;
			case (TBL_HEAD_DATA):
				break;
			}
d135 1
a135 4
			/*
			 * All cells get a leading blank, except the
			 * first one and those after double rulers.
			 */
d137 2
a138 2
			if (hp->prev && TBL_HEAD_DVERT != hp->prev->pos)
				tbl_char(tp, ASCII_NBRSP, 1);
a142 14
			/* No trailing blanks. */

			if (NULL == hp->next)
				break;

			/*
			 * Add another blank between cells,
			 * or two when there is no vertical ruler.
			 */

			tbl_char(tp, ASCII_NBRSP,
			    TBL_HEAD_VERT  == hp->next->pos ||
			    TBL_HEAD_DVERT == hp->next->pos ? 1 : 2);

d195 8
a202 11
	if (TBL_HEAD_DATA == hp->pos) {
		/* Account for leading blanks. */
		if (hp->prev && TBL_HEAD_DVERT != hp->prev->pos)
			width++;
		/* Account for trailing blanks. */
		width++;
		if (hp->next &&
		    TBL_HEAD_VERT  != hp->next->pos &&
		    TBL_HEAD_DVERT != hp->next->pos)
			width++;
	}
d220 5
a224 4
	for (hp = sp->head; hp; hp = hp->next)
		tbl_char(tp,
		    TBL_HEAD_DATA == hp->pos ? c : '+',
		    tbl_rulewidth(tp, hp));
d239 5
a243 4
	for (hp = sp->head; hp; hp = hp->next)
		tbl_char(tp,
		    outer || TBL_HEAD_DATA == hp->pos ? '-' : '+',
		    tbl_rulewidth(tp, hp));
d310 5
a314 10
	switch (hp->pos) {
	case (TBL_HEAD_VERT):
		term_word(tp, "|");
		break;
	case (TBL_HEAD_DVERT):
		term_word(tp, "||");
		break;
	default:
		break;
	}
@


1.9
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.8 2011/01/25 12:07:26 schwarze Exp $ */
d33 2
a34 1
static	void	tbl_hframe(struct termp *, const struct tbl_span *);
a40 1
static	void	tbl_vframe(struct termp *, const struct tbl *);
d94 7
a100 2
	if (TBL_SPAN_FIRST & sp->flags)
		tbl_hframe(tp, sp);
d104 3
a106 1
	tbl_vframe(tp, sp->tbl);
d144 8
d155 14
d182 5
a186 1
	tbl_vframe(tp, sp->tbl);
d195 5
a199 1
		tbl_hframe(tp, sp);
d211 28
a243 7
	size_t		 width;

	/*
	 * An hrule extends across the entire table and is demarked by a
	 * standalone `_' or whatnot in lieu of a table row.  Spanning
	 * headers are marked by a `+', as are table boundaries.
	 */
d249 4
a252 21
	/* FIXME: don't use `+' between data and a spanner! */

	for (hp = sp->head; hp; hp = hp->next) {
		width = tp->tbl.cols[hp->ident].width;
		switch (hp->pos) {
		case (TBL_HEAD_DATA):
			if (hp->next)
				width += 2;
			tbl_char(tp, c, width);
			break;
		case (TBL_HEAD_DVERT):
			tbl_char(tp, '+', width);
			/* FALLTHROUGH */
		case (TBL_HEAD_VERT):
			tbl_char(tp, '+', width);
			break;
		default:
			abort();
			/* NOTREACHED */
		}
	}
d255 6
d262 1
a262 1
tbl_hframe(struct termp *tp, const struct tbl_span *sp)
a264 23
	size_t		 width;

	if ( ! (TBL_OPT_BOX & sp->tbl->opts || 
			TBL_OPT_DBOX & sp->tbl->opts))
		return;

	/* 
	 * Print out the horizontal part of a frame or double frame.  A
	 * double frame has an unbroken `-' outer line the width of the
	 * table, bordered by `+'.  The frame (or inner frame, in the
	 * case of the double frame) is a `-' bordered by `+' and broken
	 * by `+' whenever a span is encountered.
	 */

	if (TBL_OPT_DBOX & sp->tbl->opts) {
		term_word(tp, "+");
		for (hp = sp->head; hp; hp = hp->next) {
			width = tp->tbl.cols[hp->ident].width;
			tbl_char(tp, '-', width);
		}
		term_word(tp, "+");
		term_flushln(tp);
	}
d267 4
a270 11
	for (hp = sp->head; hp; hp = hp->next) {
		width = tp->tbl.cols[hp->ident].width;
		switch (hp->pos) {
		case (TBL_HEAD_DATA):
			tbl_char(tp, '-', width);
			break;
		default:
			tbl_char(tp, '+', width);
			break;
		}
	}
a349 8
tbl_vframe(struct termp *tp, const struct tbl *tbl)
{

	if (TBL_OPT_BOX & tbl->opts || TBL_OPT_DBOX & tbl->opts)
		term_word(tp, "|");
}

static void
d368 1
a368 3
	size_t		 padl, padr, ssz;

	padl = padr = 0;
d371 3
a373 2

	ssz = term_len(tp, 1);
d377 2
a378 2
		padl = ssz;
		padr = col->width - term_strlen(tp, dp->string) - ssz;
d381 1
a381 2
		padr = col->width - term_strlen(tp, dp->string);
		if (3 > padr)
d383 1
a383 1
		padl = (padr - 1) / 2;
d387 2
a388 1
		padl = col->width - term_strlen(tp, dp->string);
a390 1
		padr = col->width - term_strlen(tp, dp->string);
d396 1
a396 1
	tbl_char(tp, ASCII_NBRSP, padr + 2);
a432 3
	sz += term_len(tp, 2);
	d += term_len(tp, 1);

d437 2
a438 1
	tbl_char(tp, ASCII_NBRSP, col->width - sz - padl);
@


1.8
log
@correct horizontal spacing of data cells
correct alignment of centered cells
adjust horizontal rule width to the new spacing
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.7 2011/01/16 01:11:50 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2009, 2011 Kristaps Dzonsons <kristaps@@kth.se>
@


1.7
log
@Various tbl improvements from kristaps@@:
* horizontal lines do not consume layout lines
* skip excessive data cells
* prepare rendering of spanned cells
* support vertical spans
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.6 2011/01/09 14:30:48 schwarze Exp $ */
d4 1
d197 2
d373 5
a377 5
		padl = col->width - term_strlen(tp, dp->string);
		if (padl % 2)
			padr++;
		padl /= 2;
		padr += padl;
d389 1
a389 1
	tbl_char(tp, ASCII_NBRSP, padr);
@


1.6
log
@Sync tbl handling to bsd.lv release 1.10.9:
* .T} can be followed by a delimiter, then more data.
* Do not limit table column widths (improves terminfo(5)).
* Let numerical cells respect explicitly specified minimum cell widths.
* Let terminal output survive missing data cells.
* Parse and ignore arguments in parentheses on layout cell specifications.
* Move tbl_calc() into out.c such that it can be used by all frontends.
* Give tables an HTML class.
* Some cleanup in tbl -Thtml code.
All code by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.5 2011/01/04 22:28:17 schwarze Exp $ */
d63 1
d115 1
d117 5
d126 2
a127 1
				tbl_vrule(tp, hp);
d133 3
d139 7
a145 2
			/* Go to the next data cell. */
			if (dp)
d147 1
a259 1
	enum tbl_cellt	 pos;
d265 1
d285 1
a285 3
	pos = dp && dp->layout ? dp->layout->pos : TBL_CELL_LEFT;

	switch (pos) {
d304 3
a356 2
	enum tbl_cellt	 pos;
	const char	*str;
d360 1
a360 2
	pos = dp && dp->layout ? dp->layout->pos : TBL_CELL_LEFT;
	str = dp && dp->string ? dp->string : "";
d364 1
a364 1
	switch (pos) {
d367 1
a367 1
		padr = col->width - term_strlen(tp, str) - ssz;
d370 1
a370 1
		padl = col->width - term_strlen(tp, str);
d377 1
a377 1
		padl = col->width - term_strlen(tp, str);
d380 1
a380 1
		padr = col->width - term_strlen(tp, str);
d385 1
a385 1
	term_word(tp, str);
a395 1
	const char	*str;
d404 1
a404 1
	str = dp && dp->string ? dp->string : "";
d406 1
a406 1
	sz = term_strlen(tp, str);
d413 1
a413 1
	if (NULL != (cp = strrchr(str, tbl->decimal))) {
d415 2
a416 2
		for (ssz = 0, i = 0; cp != &str[i]; i++) {
			buf[0] = str[i];
d429 1
a429 1
	term_word(tp, str);
@


1.5
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.1 2011/01/02 12:21:07 kristaps Exp $ */
d26 15
a40 2
/* FIXME: `n' modifier doesn't always do the right thing. */
/* FIXME: `n' modifier doesn't use the cell-spacing buffer. */
d42 14
a55 32
static	inline void	 tbl_char(struct termp *, char, int);
static	void		 tbl_hframe(struct termp *, 
				const struct tbl_span *);
static	void		 tbl_data_number(struct termp *, 
				const struct tbl *, 
				const struct tbl_dat *, 
				const struct termp_tbl *);
static	void		 tbl_data_literal(struct termp *, 
				const struct tbl_dat *, 
				const struct termp_tbl *);
static	void		 tbl_data(struct termp *, const struct tbl *,
				const struct tbl_dat *, 
				const struct termp_tbl *);
static	void		 tbl_spanner(struct termp *, 
				const struct tbl_head *);
static	void		 tbl_hrule(struct termp *, 
				const struct tbl_span *);
static	void		 tbl_vframe(struct termp *, 
				const struct tbl *);
static	void	 	 tbl_calc(struct termp *,
				const struct tbl_span *);
static	void	 	 tbl_calc_data(struct termp *,
				const struct tbl *, 
				const struct tbl_dat *,
				struct termp_tbl *);
static	void	 	 tbl_calc_data_literal(struct termp *,
				const struct tbl_dat *,
				struct termp_tbl *);
static	void	 	 tbl_calc_data_number(struct termp *,
				const struct tbl *, 
				const struct tbl_dat *,
				struct termp_tbl *);
d60 9
a68 2
	const struct tbl_head *hp;
	const struct tbl_dat *dp;
d76 2
a77 4
	 * The first time we're invoked for a given table block, create
	 * the termp_tbl structure.  This contains the column
	 * configuration for the entire table, e.g., table-wide column
	 * width, decimal point, etc.
d81 5
a85 8
		assert(NULL == tp->tbl);
		tp->tbl = calloc
			(sp->tbl->cols, sizeof(struct termp_tbl));
		if (NULL == tp->tbl) {
			perror(NULL);
			exit(EXIT_FAILURE);
		}
		tbl_calc(tp, sp);
d87 1
a87 2
		/* Flush out any preceding data. */
		term_flushln(tp);
d119 1
a119 1
				tbl_spanner(tp, hp);
d124 3
a126 2
			tbl_data(tp, sp->tbl, dp, 
				&tp->tbl[hp->ident]);
d145 3
a147 3
		assert(tp->tbl);
		free(tp->tbl);
		tp->tbl = NULL;
d151 2
d161 1
a161 1
	int		 width;
d176 1
a176 1
		width = tp->tbl[hp->ident].width;
d198 1
a198 1
	int		 width;
d215 1
a215 1
			width = tp->tbl[hp->ident].width;
d224 1
a224 1
		width = tp->tbl[hp->ident].width;
d241 1
a241 1
		const struct termp_tbl *tbp)
d246 1
a246 1
		tbl_char(tp, ASCII_NBRSP, tbp->width);
d252 1
a252 1
		tbl_char(tp, ASCII_NBRSP, tbp->width);
d257 1
a257 1
		tbl_char(tp, '-', tbp->width);
d262 1
a262 1
		tbl_char(tp, '=', tbp->width);
d268 1
a268 1
	pos = dp->layout ? dp->layout->pos : TBL_CELL_LEFT;
d272 1
a272 1
		tbl_char(tp, '-', tbp->width);
d275 1
a275 1
		tbl_char(tp, '=', tbp->width);
d284 1
a284 1
		tbl_data_literal(tp, dp, tbp);
d287 1
a287 1
		tbl_data_number(tp, tbl, dp, tbp);
d294 1
d296 1
a296 1
tbl_spanner(struct termp *tp, const struct tbl_head *hp)
a313 1
	/* Always just a single vertical line. */
d319 2
a320 2
static inline void
tbl_char(struct termp *tp, char c, int len)
d322 1
a322 1
	int		i, sz;
d335 2
a336 3
tbl_data_literal(struct termp *tp, 
		const struct tbl_dat *dp, 
		const struct termp_tbl *tblp)
d338 1
a338 1
	int		 padl, padr, ssz;
d340 1
d344 3
a346 1
	pos = dp->layout ? dp->layout->pos : TBL_CELL_LEFT;
d352 1
a352 1
		padr = tblp->width - term_strlen(tp, dp->string) - ssz;
d355 1
a355 1
		padl = tblp->width - term_strlen(tp, dp->string);
d362 1
a362 1
		padl = tblp->width - term_strlen(tp, dp->string);
d365 1
a365 1
		padr = tblp->width - term_strlen(tp, dp->string);
d370 1
a370 1
	term_word(tp, dp->string);
d375 1
a375 1
tbl_data_number(struct termp *tp, const struct tbl *tbl,
d377 1
a377 1
		const struct termp_tbl *tblp)
d379 5
a383 2
	char		*decp, buf[2];
	int		 d, padl, sz, psz, ssz, i;
d390 1
a390 102
	sz = term_strlen(tp, dp->string);
	psz = term_strlen(tp, ".");

	if (NULL != (decp = strchr(dp->string, tbl->decimal))) {
		buf[1] = '\0';
		for (ssz = i = 0; decp != &dp->string[i]; i++) {
			buf[0] = dp->string[i];
			ssz += term_strlen(tp, buf);
		}
		d = ssz + psz;
	} else
		d = sz + psz;

	assert(d <= tblp->decimal);
	assert(sz - d <= tblp->width - tblp->decimal);

	padl = tblp->decimal - d + term_len(tp, 1);
	assert(tblp->width - sz - padl);

	tbl_char(tp, ASCII_NBRSP, padl);
	term_word(tp, dp->string);
	tbl_char(tp, ASCII_NBRSP, tblp->width - sz - padl);
}

static void
tbl_calc(struct termp *tp, const struct tbl_span *sp)
{
	const struct tbl_dat *dp;
	const struct tbl_head *hp;
	struct termp_tbl *p;

	/* Calculate width as the max of column cells' widths. */

	hp = sp->head;

	for ( ; sp; sp = sp->next) {
		if (TBL_SPAN_DATA != sp->pos)
			continue;

		for (dp = sp->first; dp; dp = dp->next) {
			if (NULL == dp->layout)
				continue;
			p = &tp->tbl[dp->layout->head->ident];
			tbl_calc_data(tp, sp->tbl, dp, p);
		}
	}

	/* Calculate width as the simple spanner value. */

	for ( ; hp; hp = hp->next) 
		switch (hp->pos) {
		case (TBL_HEAD_VERT):
			tp->tbl[hp->ident].width = term_len(tp, 1);
			break;
		case (TBL_HEAD_DVERT):
			tp->tbl[hp->ident].width = term_len(tp, 2);
			break;
		default:
			break;
		}
}

static void
tbl_calc_data(struct termp *tp, const struct tbl *tbl, 
		const struct tbl_dat *dp, struct termp_tbl *tblp)
{
	int		 sz;

	/* Branch down into data sub-types. */

	switch (dp->layout->pos) {
	case (TBL_CELL_HORIZ):
		/* FALLTHROUGH */
	case (TBL_CELL_DHORIZ):
		sz = term_len(tp, 1);
		if (tblp->width < sz)
			tblp->width = sz;
		break;
	case (TBL_CELL_LONG):
		/* FALLTHROUGH */
	case (TBL_CELL_CENTRE):
		/* FALLTHROUGH */
	case (TBL_CELL_LEFT):
		/* FALLTHROUGH */
	case (TBL_CELL_RIGHT):
		tbl_calc_data_literal(tp, dp, tblp);
		break;
	case (TBL_CELL_NUMBER):
		tbl_calc_data_number(tp, tbl, dp, tblp);
		break;
	default:
		abort();
		/* NOTREACHED */
	}
}

static void
tbl_calc_data_number(struct termp *tp, const struct tbl *tbl, 
		const struct tbl_dat *dp, struct termp_tbl *tblp)
{
	int 		 sz, d, psz, i, ssz;
	char		*cp, buf[2];
d392 1
a392 8
	/*
	 * First calculate number width and decimal place (last + 1 for
	 * no-decimal numbers).  If the stored decimal is subsequent
	 * ours, make our size longer by that difference
	 * (right-"shifting"); similarly, if ours is subsequent the
	 * stored, then extend the stored size by the difference.
	 * Finally, re-assign the stored values.
	 */
d394 2
a395 1
	/* TODO: use spacing modifier. */
d397 1
a397 3
	assert(dp->string);
	sz = term_strlen(tp, dp->string);
	psz = term_strlen(tp, ".");
d399 1
a399 1
	if (NULL != (cp = strchr(dp->string, tbl->decimal))) {
d401 2
a402 2
		for (ssz = i = 0; cp != &dp->string[i]; i++) {
			buf[0] = dp->string[i];
d410 1
d412 1
a412 5
	if (tblp->decimal > d) {
		sz += tblp->decimal - d;
		d = tblp->decimal;
	} else
		tblp->width += d - tblp->decimal;
d414 3
a416 4
	if (sz > tblp->width)
		tblp->width = sz;
	if (d > tblp->decimal)
		tblp->decimal = d;
a418 38
static void
tbl_calc_data_literal(struct termp *tp, 
		const struct tbl_dat *dp, 
		struct termp_tbl *tblp)
{
	int		 sz, bufsz, spsz;

	/* 
	 * Calculate our width and use the spacing, with a minimum
	 * spacing dictated by position (centre, e.g,. gets a space on
	 * either side, while right/left get a single adjacent space).
	 */

	assert(dp->string);
	sz = term_strlen(tp, dp->string);

	switch (dp->layout->pos) {
	case (TBL_CELL_LONG):
		/* FALLTHROUGH */
	case (TBL_CELL_CENTRE):
		bufsz = term_len(tp, 2);
		break;
	default:
		bufsz = term_len(tp, 1);
		break;
	}

	spsz = 0;
	if (dp->layout->spacing)
		spsz = term_len(tp, dp->layout->spacing);

	if (spsz)
		bufsz = bufsz > spsz ?  bufsz : spsz;

	sz += bufsz;
	if (tblp->width < sz)
		tblp->width = sz;
}
@


1.4
log
@Do not crash on spanned headings.
This doesn't give us nice column widths yet with spanned headings, but
it helps mkhybrid(8) to survive the build and produce complete output.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.3 2010/10/15 22:07:12 schwarze Exp $ */
d3 1
a3 2
 * Copyright (c) 2009 Kristaps Dzonsons <kristaps@@kth.se>
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
a16 2
#include <sys/queue.h>

d22 1
a24 1
#include "tbl_extern.h"
d29 43
a71 25
static	void		 calc_data(struct termp *, struct tbl_data *);
static	void		 calc_data_literal(struct termp *, struct tbl_data *);
static	void		 calc_data_number(struct termp *, struct tbl_data *);
static	void		 calc_data_spanner(struct termp *, struct tbl_data *);
static	inline void	 write_char(struct termp *, char, int);
static	void		 write_data(struct termp *,
				const struct tbl_data *, int);
static	void		 write_data_literal(struct termp *,
				const struct tbl_data *, int);
static	void		 write_data_number(struct termp *,
				const struct tbl_data *, int);
static	void		 write_data_spanner(struct termp *,
				const struct tbl_data *, int);
static	void		 write_hframe(struct termp *, const struct tbl *);
static	void		 write_hrule(struct termp *, const struct tbl_span *);
static	void		 write_spanner(struct termp *, const struct tbl_head *);
static	void		 write_vframe(struct termp *, const struct tbl *);


int
tbl_write_term(struct termp *p, const struct tbl *tbl)
{
	const struct tbl_span	*span;
	const struct tbl_data	*data;
	const struct tbl_head	*head;
d74 4
a77 2
	 * Note that the absolute widths and decimal places for headers
	 * were set when tbl_calc_term was called.
d80 13
a92 2
	term_newln(p);
	p->flags |= TERMP_NOSPACE | TERMP_NONOSPACE;
d94 1
a94 1
	/* First, write out our head horizontal frame. */
d96 6
a101 1
	write_hframe(p, tbl);
d104 3
a106 4
	 * Iterate through each span, and inside, through the global
	 * headers.  If the global header's a spanner, print it
	 * directly; if it's data, use the corresponding data in the
	 * span as the object to print.
d109 11
a119 15
	TAILQ_FOREACH(span, &tbl->span, entries) {
		write_vframe(p, tbl);

		/* Accomodate for the horizontal rule. */
		if (TBL_DATA_DHORIZ & span->flags || 
				TBL_DATA_HORIZ & span->flags) {
			write_hrule(p, span);
			write_vframe(p, tbl);
			term_flushln(p);
			continue;
		}

		data = TAILQ_FIRST(&span->data);
		TAILQ_FOREACH(head, &tbl->head, entries) {
			switch (head->pos) {
d123 2
a124 2
				write_spanner(p, head);
				break;
a125 3
				write_data(p, data, head->width);
				if (data)
					data = TAILQ_NEXT(data, entries);
a126 3
			default:
				abort();
				/* NOTREACHED */
d128 6
d135 1
a135 2
		write_vframe(p, tbl);
		term_flushln(p);
d138 2
a139 1
	/* Last, write out our tail horizontal frame. */
d141 4
a144 14
	write_hframe(p, tbl);

	p->flags &= ~TERMP_NONOSPACE;

	return(1);
}


int
tbl_calc_term(struct termp *p, struct tbl *tbl)
{
	struct tbl_span	*span;
	struct tbl_data	*data;
	struct tbl_head	*head;
d146 5
a150 13
	/* Calculate width as the max of column cells' widths. */

	TAILQ_FOREACH(span, &tbl->span, entries) {
		if (TBL_DATA_HORIZ & span->flags)
			continue;
		if (TBL_DATA_DHORIZ & span->flags)
			continue;
		if (TBL_DATA_NHORIZ & span->flags)
			continue;
		if (TBL_DATA_NDHORIZ & span->flags)
			continue;
		TAILQ_FOREACH(data, &span->data, entries)
			calc_data(p, data);
d153 1
a153 1
	/* Calculate width as the simple spanner value. */
a154 13
	TAILQ_FOREACH(head, &tbl->head, entries) 
		switch (head->pos) {
		case (TBL_HEAD_VERT):
			head->width = term_len(p, 1);
			break;
		case (TBL_HEAD_DVERT):
			head->width = term_len(p, 2);
			break;
		default:
			break;
		}

	return(1);
a156 1

d158 1
a158 1
write_hrule(struct termp *p, const struct tbl_span *span)
d160 3
a162 2
	const struct tbl_head	*head;
	char			 c;
d171 1
a171 1
	if (TBL_SPAN_DHORIZ & span->flags)
d176 3
a178 2
	TAILQ_FOREACH(head, &span->tbl->head, entries) {
		switch (head->pos) {
d180 1
a180 1
			write_char(p, c, head->width);
d183 1
a183 1
			write_char(p, '+', head->width);
d186 1
a186 1
			write_char(p, '+', head->width);
a194 1

d196 1
a196 1
write_hframe(struct termp *p, const struct tbl *tbl)
d198 2
a199 1
	const struct tbl_head	*head;
d201 2
a202 1
	if ( ! (TBL_OPT_BOX & tbl->opts || TBL_OPT_DBOX & tbl->opts))
d213 8
a220 6
	if (TBL_OPT_DBOX & tbl->opts) {
		term_word(p, "+");
		TAILQ_FOREACH(head, &tbl->head, entries)
			write_char(p, '-', head->width);
		term_word(p, "+");
		term_flushln(p);
d223 4
a226 3
	term_word(p, "+");
	TAILQ_FOREACH(head, &tbl->head, entries) {
		switch (head->pos) {
d228 1
a228 1
			write_char(p, '-', head->width);
d231 1
a231 1
			write_char(p, '+', head->width);
d235 2
a236 2
	term_word(p, "+");
	term_flushln(p);
a238 1

d240 3
a242 1
write_vframe(struct termp *p, const struct tbl *tbl)
d244 1
a244 1
	/* Always just a single vertical line. */
d246 2
a247 1
	if ( ! (TBL_OPT_BOX & tbl->opts || TBL_OPT_DBOX & tbl->opts))
d249 1
a249 2
	term_word(p, "|");
}
d251 10
a260 67

static void
calc_data_spanner(struct termp *p, struct tbl_data *data)
{

	/* N.B., these are horiz spanners (not vert) so always 1. */
	data->cell->head->width = term_len(p, 1);
}


static void
calc_data_number(struct termp *p, struct tbl_data *data)
{
	int 		 sz, d;
	char		*dp, pnt;

	/*
	 * First calculate number width and decimal place (last + 1 for
	 * no-decimal numbers).  If the stored decimal is subsequent
	 * ours, make our size longer by that difference
	 * (right-"shifting"); similarly, if ours is subsequent the
	 * stored, then extend the stored size by the difference.
	 * Finally, re-assign the stored values.
	 */

	/* TODO: use spacing modifier. */

	assert(data->string);
	sz = (int)term_strlen(p, data->string);
	pnt = data->span->tbl->decimal;

	dp = strchr(data->string, pnt);
	d = dp ? sz - (int)term_strlen(p, dp) : sz;
	d += term_len(p, 1);

	sz += term_len(p, 2);

	if (data->cell->head->decimal > d) {
		sz += data->cell->head->decimal - d;
		d = data->cell->head->decimal;
	} else
		data->cell->head->width += 
			d - data->cell->head->decimal;

	if (sz > data->cell->head->width)
		data->cell->head->width = sz;
	if (d > data->cell->head->decimal)
		data->cell->head->decimal = d;
}


static void
calc_data_literal(struct termp *p, struct tbl_data *data)
{
	int		 sz, bufsz;

	/* 
	 * Calculate our width and use the spacing, with a minimum
	 * spacing dictated by position (centre, e.g,. gets a space on
	 * either side, while right/left get a single adjacent space).
	 */

	assert(data->string);
	sz = (int)term_strlen(p, data->string);

	switch (data->cell->pos) {
	case (TBL_CELL_LONG):
d262 3
a264 3
	case (TBL_CELL_CENTRE):
		bufsz = 2;
		break;
a265 1
		bufsz = 1;
d268 2
d271 1
a271 15
	if (data->cell->spacing)
		bufsz = bufsz > data->cell->spacing ? 
			bufsz : data->cell->spacing;

	sz += term_len(p, bufsz);
	if (data->cell->head->width < sz)
		data->cell->head->width = sz;
}


static void
calc_data(struct termp *p, struct tbl_data *data)
{

	switch (data->cell->pos) {
d273 2
a274 1
		/* FALLTHROUGH */
d276 1
a276 1
		calc_data_spanner(p, data);
d285 1
a285 1
		calc_data_literal(p, data);
d288 1
a288 4
		calc_data_number(p, data);
		break;
	case (TBL_CELL_SPAN):
		data->cell->head->width = 0;
a294 2


d296 1
a296 1
write_data_spanner(struct termp *p, const struct tbl_data *data, int width)
d299 10
a308 12
	/*
	 * Write spanners dictated by both our cell designation (in the
	 * layout) or as data.
	 */
	if (TBL_DATA_HORIZ & data->flags)
		write_char(p, '-', width);
	else if (TBL_DATA_DHORIZ & data->flags)
		write_char(p, '=', width);
	else if (TBL_CELL_HORIZ == data->cell->pos)
		write_char(p, '-', width);
	else if (TBL_CELL_DHORIZ == data->cell->pos)
		write_char(p, '=', width);
a310 1

d312 1
a312 1
write_data_number(struct termp *p, const struct tbl_data *data, int width)
d314 1
a314 2
	char		*dp, pnt;
	int		 d, padl, sz;
d316 3
a318 4
	/*
	 * See calc_data_number().  Left-pad by taking the offset of our
	 * and the maximum decimal; right-pad by the remaining amount.
	 */
d320 5
a324 2
	sz = (int)term_strlen(p, data->string);
	pnt = data->span->tbl->decimal;
d326 2
a327 9
	if (NULL == (dp = strchr(data->string, pnt))) {
		d = sz + 1;
	} else {
		d = (int)(dp - data->string) + 1;
	}

	assert(d <= data->cell->head->decimal);
	assert(sz - d <= data->cell->head->width -
			data->cell->head->decimal);
d329 1
a329 2
	padl = data->cell->head->decimal - d + 1;
	assert(width - sz - padl);
d331 2
a332 3
	write_char(p, ' ', padl);
	term_word(p, data->string);
	write_char(p, ' ', width - sz - padl);
a334 1

d336 3
a338 1
write_data_literal(struct termp *p, const struct tbl_data *data, int width)
d340 2
a341 1
	int		 padl, padr;
d345 4
a348 1
	switch (data->cell->pos) {
d350 2
a351 2
		padl = 1;
		padr = width - (int)term_strlen(p, data->string) - 1;
d354 1
a354 1
		padl = width - (int)term_strlen(p, data->string);
d361 1
a361 1
		padl = width - (int)term_strlen(p, data->string);
d364 1
a364 1
		padr = width - (int)term_strlen(p, data->string);
d368 3
a370 3
	write_char(p, ' ', padl);
	term_word(p, data->string);
	write_char(p, ' ', padr);
d373 36
d411 1
a411 1
write_data(struct termp *p, const struct tbl_data *data, int width)
d413 3
d417 14
a430 3
	if (NULL == data) {
		write_char(p, ' ', width);
		return;
d433 22
a454 5
	if (TBL_DATA_HORIZ & data->flags || 
			TBL_DATA_DHORIZ & data->flags) {
		write_data_spanner(p, data, width);
		return;
	}
d456 1
a456 1
	switch (data->cell->pos) {
d460 3
a462 1
		write_data_spanner(p, data, width);
d471 1
a471 1
		write_data_literal(p, data, width);
d474 1
a474 3
		write_data_number(p, data, width);
		break;
	case (TBL_CELL_SPAN):
d482 45
d529 3
a531 1
write_spanner(struct termp *p, const struct tbl_head *head)
d533 1
a533 1
	char		*w;
d535 14
a548 7
	w = NULL;
	switch (head->pos) {
	case (TBL_HEAD_VERT):
		w = "|";
		break;
	case (TBL_HEAD_DVERT):
		w = "||";
d551 1
d555 3
a557 4
	assert(p);
	term_word(p, w);
}

d559 2
a560 5
static inline void
write_char(struct termp *p, char c, int len)
{
	int		 i;
	static char	 w[2];
d562 3
a564 3
	w[0] = c;
	for (i = 0; i < len; i++)
		term_word(p, w);
@


1.3
log
@Move tbl width calculation from plain strlen to mandoc terminal width
calculation routines.  This gives us mostly sane table column widths.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.2 2010/10/15 21:33:47 schwarze Exp $ */
d356 3
d483 2
@


1.2
log
@Move tbl output from plain stdio to mandoc terminal output routines.
This fixes (1) all escape sequences and (2) some aspects of indentation.
Table column widths are still way off, though.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.13 2009/09/14 09:06:40 kristaps Exp $ */
d32 4
a35 4
static	void		 calc_data(struct tbl_data *);
static	void		 calc_data_literal(struct tbl_data *);
static	void		 calc_data_number(struct tbl_data *);
static	void		 calc_data_spanner(struct tbl_data *);
d122 1
a122 1
tbl_calc_term(struct tbl *tbl)
d140 1
a140 1
			calc_data(data);
d148 1
a148 1
			head->width = 1;
d151 1
a151 1
			head->width = 2;
d250 1
a250 1
calc_data_spanner(struct tbl_data *data)
d254 1
a254 1
	data->cell->head->width = 1;
d259 1
a259 1
calc_data_number(struct tbl_data *data)
d276 1
a276 1
	sz = (int)strlen(data->string);
d279 3
a281 4
	if (NULL == (dp = strchr(data->string, pnt)))
		d = sz + 1;
	else
		d = (int)(dp - data->string) + 1;
d283 1
a283 1
	sz += 2;
d300 1
a300 1
calc_data_literal(struct tbl_data *data)
d311 1
a311 1
	sz = (int)strlen(data->string);
d328 1
a328 1
	sz += bufsz;
d335 1
a335 1
calc_data(struct tbl_data *data)
d342 1
a342 1
		calc_data_spanner(data);
d351 1
a351 1
		calc_data_literal(data);
d354 1
a354 1
		calc_data_number(data);
d393 1
a393 1
	sz = (int)strlen(data->string);
@


1.1
log
@Import tbl parser and renderer written by kristaps@@.
Unchanged code from bsd.lv release 0.1.5, but without the main program.
Not yet linked to the build; next commit will integrate it into mandoc.
@
text
@d4 1
d25 2
d36 13
a48 9
static	inline void	 write_char(char, int);
static	void		 write_data(const struct tbl_data *, int);
static	void		 write_data_literal(const struct tbl_data *, int);
static	void		 write_data_number(const struct tbl_data *, int);
static	void		 write_data_spanner(const struct tbl_data *, int);
static	void		 write_hframe(const struct tbl *);
static	void		 write_hrule(const struct tbl_span *);
static	void		 write_spanner(const struct tbl_head *);
static	void		 write_vframe(const struct tbl *);
d52 1
a52 1
tbl_write_term(const struct tbl *tbl)
d63 3
d68 1
a68 1
	write_hframe(tbl);
d78 1
a78 1
		write_vframe(tbl);
d83 3
a85 3
			write_hrule(span);
			write_vframe(tbl);
			printf("\n");
d95 1
a95 1
				write_spanner(head);
d98 1
a98 1
				write_data(data, head->width);
d107 2
a108 2
		write_vframe(tbl);
		printf("\n");
d113 3
a115 1
	write_hframe(tbl);
d162 1
a162 1
write_hrule(const struct tbl_span *span)
d182 1
a182 1
			write_char(c, head->width);
d185 1
a185 1
			write_char('+', head->width);
d188 1
a188 1
			write_char('+', head->width);
d199 1
a199 1
write_hframe(const struct tbl *tbl)
d215 1
a215 1
		printf("+");
d217 3
a219 2
			write_char('-', head->width);
		printf("+\n");
d222 1
a222 1
	printf("+");
d226 1
a226 1
			write_char('-', head->width);
d229 1
a229 1
			write_char('+', head->width);
d233 2
a234 1
	printf("+\n");
d239 1
a239 1
write_vframe(const struct tbl *tbl)
d245 1
a245 1
	printf("|");
d365 1
a365 1
write_data_spanner(const struct tbl_data *data, int width)
d373 1
a373 1
		write_char('-', width);
d375 1
a375 1
		write_char('=', width);
d377 1
a377 1
		write_char('-', width);
d379 1
a379 1
		write_char('=', width);
d384 1
a384 1
write_data_number(const struct tbl_data *data, int width)
d410 3
a412 3
	write_char(' ', padl);
	(void)printf("%s", data->string);
	write_char(' ', width - sz - padl);
d417 1
a417 1
write_data_literal(const struct tbl_data *data, int width)
d426 1
a426 1
		padr = width - (int)strlen(data->string) - 1;
d429 1
a429 1
		padl = width - (int)strlen(data->string);
d436 1
a436 1
		padl = width - (int)strlen(data->string);
d439 1
a439 1
		padr = width - (int)strlen(data->string);
d443 3
a445 3
	write_char(' ', padl);
	(void)printf("%s", data->string);
	write_char(' ', padr);
d450 1
a450 1
write_data(const struct tbl_data *data, int width)
d454 1
a454 1
		write_char(' ', width);
d460 1
a460 1
		write_data_spanner(data, width);
d468 1
a468 1
		write_data_spanner(data, width);
d477 1
a477 1
		write_data_literal(data, width);
d480 1
a480 1
		write_data_number(data, width);
d490 1
a490 1
write_spanner(const struct tbl_head *head)
d492 1
a492 1
	char		*p;
d494 1
a494 1
	p = NULL;
d497 1
a497 1
		p = "|";
d500 1
a500 1
		p = "||";
d507 1
a507 1
	printf("%s", p);
d512 1
a512 1
write_char(char c, int len)
d515 1
d517 1
d519 1
a519 1
		printf("%c", c);
@

