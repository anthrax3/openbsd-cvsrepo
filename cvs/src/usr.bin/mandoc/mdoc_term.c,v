head	1.252;
access;
symbols
	OPENBSD_6_1:1.245.0.4
	OPENBSD_6_1_BASE:1.245
	OPENBSD_6_0:1.230.0.4
	OPENBSD_6_0_BASE:1.230
	OPENBSD_5_9:1.230.0.2
	OPENBSD_5_9_BASE:1.230
	OPENBSD_5_8:1.223.0.4
	OPENBSD_5_8_BASE:1.223
	OPENBSD_5_7:1.210.0.2
	OPENBSD_5_7_BASE:1.210
	OPENBSD_5_6:1.173.0.4
	OPENBSD_5_6_BASE:1.173
	OPENBSD_5_5:1.161.0.4
	OPENBSD_5_5_BASE:1.161
	OPENBSD_5_4:1.151.0.2
	OPENBSD_5_4_BASE:1.151
	OPENBSD_5_3:1.147.0.2
	OPENBSD_5_3_BASE:1.147
	OPENBSD_5_2:1.145.0.2
	OPENBSD_5_2_BASE:1.145
	OPENBSD_5_1_BASE:1.140
	OPENBSD_5_1:1.140.0.2
	OPENBSD_5_0:1.134.0.2
	OPENBSD_5_0_BASE:1.134
	OPENBSD_4_9:1.129.0.2
	OPENBSD_4_9_BASE:1.129
	OPENBSD_4_8:1.100.0.2
	OPENBSD_4_8_BASE:1.100
	OPENBSD_4_7:1.70.0.2
	OPENBSD_4_7_BASE:1.70
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19;
locks; strict;
comment	@ * @;


1.252
date	2017.05.05.02.06.17;	author schwarze;	state Exp;
branches;
next	1.251;
commitid	JMX1RJlA2uFuu13l;

1.251
date	2017.05.04.22.07.44;	author schwarze;	state Exp;
branches;
next	1.250;
commitid	hU9bJPcS66QLg54n;

1.250
date	2017.05.04.17.48.24;	author schwarze;	state Exp;
branches;
next	1.249;
commitid	RHQLdCAdHKxKe8Eu;

1.249
date	2017.04.24.23.06.09;	author schwarze;	state Exp;
branches;
next	1.248;
commitid	2CfzvK3gmiJH7vY0;

1.248
date	2017.04.17.12.52.00;	author schwarze;	state Exp;
branches;
next	1.247;
commitid	kcFZlUR2Kn46gi6m;

1.247
date	2017.04.14.19.34.54;	author schwarze;	state Exp;
branches;
next	1.246;
commitid	zNSh1cIOe4xTMBna;

1.246
date	2017.04.14.18.23.29;	author schwarze;	state Exp;
branches;
next	1.245;
commitid	m7GDbMkZlOrL6lmk;

1.245
date	2017.02.17.19.14.39;	author schwarze;	state Exp;
branches;
next	1.244;
commitid	mtapDp67bcDPAAPY;

1.244
date	2017.02.16.14.38.07;	author schwarze;	state Exp;
branches;
next	1.243;
commitid	VDwQSHD2LSGvueh5;

1.243
date	2017.02.16.02.59.42;	author schwarze;	state Exp;
branches;
next	1.242;
commitid	Qmey25xun8rVuoB9;

1.242
date	2017.02.06.03.41.44;	author schwarze;	state Exp;
branches;
next	1.241;
commitid	FiEZU00RcX3pLlUS;

1.241
date	2017.02.04.11.56.48;	author schwarze;	state Exp;
branches;
next	1.240;
commitid	MXtX3fFtqob7upHI;

1.240
date	2017.01.11.17.39.45;	author schwarze;	state Exp;
branches;
next	1.239;
commitid	2X81lVBLl8eAHRVh;

1.239
date	2017.01.10.23.36.24;	author schwarze;	state Exp;
branches;
next	1.238;
commitid	1NsxjVXtIEKZm6T7;

1.238
date	2017.01.10.21.54.34;	author schwarze;	state Exp;
branches;
next	1.237;
commitid	iaEy6J4gJ8kh18cm;

1.237
date	2017.01.10.13.46.53;	author schwarze;	state Exp;
branches;
next	1.236;
commitid	aFt8sLe7F06PjFYh;

1.236
date	2017.01.10.12.54.27;	author schwarze;	state Exp;
branches;
next	1.235;
commitid	vzXxeQWxUqXTMW9w;

1.235
date	2016.11.08.16.37.42;	author schwarze;	state Exp;
branches;
next	1.234;
commitid	93rqDSFqpyUj08VA;

1.234
date	2016.11.08.16.29.19;	author schwarze;	state Exp;
branches;
next	1.233;
commitid	d7hIz7c4zUkUjgmm;

1.233
date	2016.11.08.16.23.37;	author schwarze;	state Exp;
branches;
next	1.232;
commitid	dMU1kd0O5LDcrfX8;

1.232
date	2016.11.08.16.04.40;	author schwarze;	state Exp;
branches;
next	1.231;
commitid	VqSNNzttmOiJI90o;

1.231
date	2016.10.09.18.16.46;	author schwarze;	state Exp;
branches;
next	1.230;
commitid	naY2DgYOKonEJYdH;

1.230
date	2016.01.08.17.48.04;	author schwarze;	state Exp;
branches;
next	1.229;
commitid	DoGoemryKYV644MI;

1.229
date	2015.10.12.15.27.53;	author schwarze;	state Exp;
branches;
next	1.228;
commitid	VfpZTgiLsGboNvp1;

1.228
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.227;
commitid	Ql2ha5NS80pwfGNT;

1.227
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.226;
commitid	hxQV8O1pNUaef4ir;

1.226
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.225;
commitid	191tWtskbsgcpQqV;

1.225
date	2015.09.21.13.24.32;	author schwarze;	state Exp;
branches;
next	1.224;
commitid	hh1XsHF4k03QJZSt;

1.224
date	2015.09.14.12.57.30;	author schwarze;	state Exp;
branches;
next	1.223;
commitid	RrAi3d4Ty61Edhk2;

1.223
date	2015.07.25.14.28.40;	author schwarze;	state Exp;
branches;
next	1.222;
commitid	a9T6R454FMso2EzW;

1.222
date	2015.07.25.14.22.40;	author schwarze;	state Exp;
branches;
next	1.221;
commitid	gPLcqqkrpoju1DF0;

1.221
date	2015.07.25.14.17.47;	author schwarze;	state Exp;
branches;
next	1.220;
commitid	RL9K3i9K4ueL7Dd9;

1.220
date	2015.07.25.14.01.39;	author schwarze;	state Exp;
branches;
next	1.219;
commitid	lD6FFKt12knszHBX;

1.219
date	2015.07.17.22.35.36;	author schwarze;	state Exp;
branches;
next	1.218;
commitid	Ik50obX3Gy0LFoMQ;

1.218
date	2015.04.18.17.50.02;	author schwarze;	state Exp;
branches;
next	1.217;
commitid	sjmmdLSx1e3Vat0h;

1.217
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.216;
commitid	6MYJ7cd8mhJ77AGH;

1.216
date	2015.04.04.17.46.58;	author schwarze;	state Exp;
branches;
next	1.215;
commitid	exqqP0KNSHrSyO21;

1.215
date	2015.04.02.23.47.43;	author schwarze;	state Exp;
branches;
next	1.214;
commitid	RJFkOLiS9gBqEEDl;

1.214
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.213;
commitid	Rfx1oTaH3hZ7Zcyf;

1.213
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.212;
commitid	lmErjWY2O9ooA6RY;

1.212
date	2015.03.09.17.41.36;	author schwarze;	state Exp;
branches;
next	1.211;
commitid	EhhvqT5WwS4ZT2a7;

1.211
date	2015.03.09.17.37.45;	author schwarze;	state Exp;
branches;
next	1.210;
commitid	NQanOVncM7VG6RuU;

1.210
date	2015.02.17.20.33.44;	author schwarze;	state Exp;
branches;
next	1.209;
commitid	bzSwTm9b9VF7LbRZ;

1.209
date	2015.02.12.12.20.47;	author schwarze;	state Exp;
branches;
next	1.208;
commitid	SViaEKzwzmf0o0kW;

1.208
date	2015.02.11.14.14.53;	author schwarze;	state Exp;
branches;
next	1.207;
commitid	2V8eDQf8fVyAwXBZ;

1.207
date	2015.02.05.01.46.38;	author schwarze;	state Exp;
branches;
next	1.206;
commitid	Whyrd7T544leDR65;

1.206
date	2015.02.05.00.13.34;	author schwarze;	state Exp;
branches;
next	1.205;
commitid	yNql0K85SrSgftGW;

1.205
date	2015.02.01.23.10.15;	author schwarze;	state Exp;
branches;
next	1.204;
commitid	d1ys3bKakrrT671d;

1.204
date	2015.01.31.00.11.52;	author schwarze;	state Exp;
branches;
next	1.203;
commitid	qr0IBCEkFSkiYkBc;

1.203
date	2015.01.30.22.04.15;	author schwarze;	state Exp;
branches;
next	1.202;
commitid	EStyTVNpkesjWq58;

1.202
date	2015.01.23.14.19.52;	author schwarze;	state Exp;
branches;
next	1.201;
commitid	XkcvCG1NCY9WGWyO;

1.201
date	2014.12.24.23.31.59;	author schwarze;	state Exp;
branches;
next	1.200;
commitid	TfSx49MGGpeWF6md;

1.200
date	2014.12.23.13.48.15;	author schwarze;	state Exp;
branches;
next	1.199;
commitid	gQAVpbNdyny1vBnL;

1.199
date	2014.12.23.09.31.17;	author schwarze;	state Exp;
branches;
next	1.198;
commitid	SXZbldG8wiiZaqvE;

1.198
date	2014.12.02.10.07.17;	author schwarze;	state Exp;
branches;
next	1.197;
commitid	G1dK13T4nePhhgx3;

1.197
date	2014.11.30.05.28.00;	author schwarze;	state Exp;
branches;
next	1.196;
commitid	4gOj8tbqcpkeLVbt;

1.196
date	2014.11.28.16.53.38;	author schwarze;	state Exp;
branches;
next	1.195;
commitid	xVKXgoGGbfIvhQn6;

1.195
date	2014.11.28.16.02.23;	author schwarze;	state Exp;
branches;
next	1.194;
commitid	MgJh1gX7ILgZcIyR;

1.194
date	2014.11.27.22.27.40;	author schwarze;	state Exp;
branches;
next	1.193;
commitid	5z09nX8VCSvBpGIv;

1.193
date	2014.11.27.16.20.27;	author schwarze;	state Exp;
branches;
next	1.192;
commitid	snF2JxsotuPud6ts;

1.192
date	2014.11.25.03.04.32;	author schwarze;	state Exp;
branches;
next	1.191;
commitid	dDYiiilKcyMGuvD5;

1.191
date	2014.11.21.01.52.44;	author schwarze;	state Exp;
branches;
next	1.190;
commitid	hm1luQGz9X3OaZNV;

1.190
date	2014.11.19.21.59.19;	author schwarze;	state Exp;
branches;
next	1.189;
commitid	im0MTOZhKZYRJTHJ;

1.189
date	2014.11.17.06.44.35;	author schwarze;	state Exp;
branches;
next	1.188;
commitid	eO1CUhWjZNit4m47;

1.188
date	2014.11.10.21.54.29;	author schwarze;	state Exp;
branches;
next	1.187;
commitid	rgh5oUCZECxGjmVa;

1.187
date	2014.10.30.20.05.33;	author schwarze;	state Exp;
branches;
next	1.186;
commitid	0MyCvIn2JIoyqJkI;

1.186
date	2014.10.28.17.35.42;	author schwarze;	state Exp;
branches;
next	1.185;
commitid	pNwmOla3ZQwLgu2f;

1.185
date	2014.10.20.15.49.45;	author schwarze;	state Exp;
branches;
next	1.184;
commitid	xAL9AbgdIC6Bgc5x;

1.184
date	2014.10.20.02.46.00;	author schwarze;	state Exp;
branches;
next	1.183;
commitid	42BxgTg8wZRAL7i6;

1.183
date	2014.10.20.02.31.44;	author schwarze;	state Exp;
branches;
next	1.182;
commitid	jVScYQL5VkcOk52z;

1.182
date	2014.10.13.22.00.42;	author schwarze;	state Exp;
branches;
next	1.181;
commitid	CHL7ydIorSL96TIh;

1.181
date	2014.09.17.20.17.55;	author schwarze;	state Exp;
branches;
next	1.180;
commitid	5cyqfhVs69W4jFo5;

1.180
date	2014.09.03.05.17.08;	author schwarze;	state Exp;
branches;
next	1.179;
commitid	D4HCUw9YYVx6NSQl;

1.179
date	2014.08.21.12.56.24;	author schwarze;	state Exp;
branches;
next	1.178;
commitid	Y0pln4y7V0yebwer;

1.178
date	2014.08.17.18.42.07;	author schwarze;	state Exp;
branches;
next	1.177;
commitid	sx8BHByh8NPOG90r;

1.177
date	2014.08.08.16.17.09;	author schwarze;	state Exp;
branches;
next	1.176;
commitid	TLMAnDXVMoqLltgG;

1.176
date	2014.08.08.15.26.28;	author schwarze;	state Exp;
branches;
next	1.175;
commitid	p7GwHxeS0xJRdvMp;

1.175
date	2014.08.08.15.10.15;	author schwarze;	state Exp;
branches;
next	1.174;
commitid	V6V8vpTM0RQ4gS7I;

1.174
date	2014.08.08.15.03.24;	author schwarze;	state Exp;
branches;
next	1.173;
commitid	IC4m7PBMv8EruQl8;

1.173
date	2014.07.07.15.03.24;	author schwarze;	state Exp;
branches;
next	1.172;
commitid	LD7wx5yJuIhKJiro;

1.172
date	2014.07.03.23.23.45;	author schwarze;	state Exp;
branches;
next	1.171;
commitid	r0fsz0DrjbQnVa67;

1.171
date	2014.07.02.19.54.39;	author schwarze;	state Exp;
branches;
next	1.170;
commitid	Yt0K01y5ZeXGGSxs;

1.170
date	2014.07.02.03.47.07;	author schwarze;	state Exp;
branches;
next	1.169;
commitid	p4pNII1v0bYCswy0;

1.169
date	2014.04.23.16.07.06;	author schwarze;	state Exp;
branches;
next	1.168;

1.168
date	2014.04.20.20.17.36;	author schwarze;	state Exp;
branches;
next	1.167;

1.167
date	2014.04.20.19.39.35;	author schwarze;	state Exp;
branches;
next	1.166;

1.166
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.165;

1.165
date	2014.04.08.07.13.01;	author schwarze;	state Exp;
branches;
next	1.164;

1.164
date	2014.04.08.04.40.29;	author schwarze;	state Exp;
branches;
next	1.163;

1.163
date	2014.03.30.21.27.59;	author schwarze;	state Exp;
branches;
next	1.162;

1.162
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.161;

1.161
date	2014.02.16.12.30.51;	author schwarze;	state Exp;
branches;
next	1.160;

1.160
date	2013.12.25.21.24.03;	author schwarze;	state Exp;
branches;
next	1.159;

1.159
date	2013.12.25.15.12.39;	author schwarze;	state Exp;
branches;
next	1.158;

1.158
date	2013.12.25.14.40.29;	author schwarze;	state Exp;
branches;
next	1.157;

1.157
date	2013.12.25.00.39.13;	author schwarze;	state Exp;
branches;
next	1.156;

1.156
date	2013.12.24.23.04.29;	author schwarze;	state Exp;
branches;
next	1.155;

1.155
date	2013.12.24.20.45.21;	author schwarze;	state Exp;
branches;
next	1.154;

1.154
date	2013.12.24.19.10.34;	author schwarze;	state Exp;
branches;
next	1.153;

1.153
date	2013.12.23.02.19.57;	author schwarze;	state Exp;
branches;
next	1.152;

1.152
date	2013.12.22.23.33.52;	author schwarze;	state Exp;
branches;
next	1.151;

1.151
date	2013.06.02.18.16.51;	author schwarze;	state Exp;
branches;
next	1.150;

1.150
date	2013.05.29.16.11.32;	author schwarze;	state Exp;
branches;
next	1.149;

1.149
date	2013.05.29.15.40.14;	author schwarze;	state Exp;
branches;
next	1.148;

1.148
date	2013.05.18.17.47.17;	author schwarze;	state Exp;
branches;
next	1.147;

1.147
date	2012.11.17.00.25.20;	author schwarze;	state Exp;
branches;
next	1.146;

1.146
date	2012.11.16.17.16.29;	author schwarze;	state Exp;
branches;
next	1.145;

1.145
date	2012.07.11.16.55.29;	author schwarze;	state Exp;
branches;
next	1.144;

1.144
date	2012.07.10.14.35.57;	author schwarze;	state Exp;
branches;
next	1.143;

1.143
date	2012.07.09.23.52.47;	author schwarze;	state Exp;
branches;
next	1.142;

1.142
date	2012.07.08.22.48.38;	author schwarze;	state Exp;
branches;
next	1.141;

1.141
date	2012.07.08.16.50.36;	author schwarze;	state Exp;
branches;
next	1.140;

1.140
date	2011.11.13.13.05.23;	author schwarze;	state Exp;
branches;
next	1.139;

1.139
date	2011.11.03.20.32.33;	author schwarze;	state Exp;
branches;
next	1.138;

1.138
date	2011.10.16.12.18.32;	author schwarze;	state Exp;
branches;
next	1.137;

1.137
date	2011.09.20.09.02.18;	author schwarze;	state Exp;
branches;
next	1.136;

1.136
date	2011.09.19.22.36.11;	author schwarze;	state Exp;
branches;
next	1.135;

1.135
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.134;

1.134
date	2011.07.05.04.12.41;	author schwarze;	state Exp;
branches;
next	1.133;

1.133
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.132;

1.132
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.131;

1.131
date	2011.03.20.23.36.42;	author schwarze;	state Exp;
branches;
next	1.130;

1.130
date	2011.03.07.01.35.33;	author schwarze;	state Exp;
branches;
next	1.129;

1.129
date	2011.02.06.22.56.45;	author schwarze;	state Exp;
branches;
next	1.128;

1.128
date	2011.02.06.22.25.36;	author schwarze;	state Exp;
branches;
next	1.127;

1.127
date	2011.02.06.17.33.20;	author schwarze;	state Exp;
branches;
next	1.126;

1.126
date	2011.01.30.18.28.01;	author schwarze;	state Exp;
branches;
next	1.125;

1.125
date	2011.01.30.17.41.59;	author schwarze;	state Exp;
branches;
next	1.124;

1.124
date	2011.01.16.02.56.47;	author schwarze;	state Exp;
branches;
next	1.123;

1.123
date	2011.01.09.16.09.41;	author schwarze;	state Exp;
branches;
next	1.122;

1.122
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.121;

1.121
date	2010.12.29.00.47.31;	author schwarze;	state Exp;
branches;
next	1.120;

1.120
date	2010.12.26.21.04.19;	author schwarze;	state Exp;
branches;
next	1.119;

1.119
date	2010.12.21.23.57.31;	author schwarze;	state Exp;
branches;
next	1.118;

1.118
date	2010.12.21.23.46.18;	author schwarze;	state Exp;
branches;
next	1.117;

1.117
date	2010.12.19.12.10.33;	author schwarze;	state Exp;
branches;
next	1.116;

1.116
date	2010.12.11.14.29.56;	author schwarze;	state Exp;
branches;
next	1.115;

1.115
date	2010.12.06.22.10.13;	author schwarze;	state Exp;
branches;
next	1.114;

1.114
date	2010.12.01.22.02.29;	author schwarze;	state Exp;
branches;
next	1.113;

1.113
date	2010.10.23.23.30.41;	author schwarze;	state Exp;
branches;
next	1.112;

1.112
date	2010.10.23.16.08.36;	author schwarze;	state Exp;
branches;
next	1.111;

1.111
date	2010.10.16.20.49.37;	author schwarze;	state Exp;
branches;
next	1.110;

1.110
date	2010.10.16.13.38.29;	author schwarze;	state Exp;
branches;
next	1.109;

1.109
date	2010.10.01.21.38.26;	author schwarze;	state Exp;
branches;
next	1.108;

1.108
date	2010.09.27.21.25.28;	author schwarze;	state Exp;
branches;
next	1.107;

1.107
date	2010.09.26.18.55.22;	author schwarze;	state Exp;
branches;
next	1.106;

1.106
date	2010.09.26.18.23.54;	author schwarze;	state Exp;
branches;
next	1.105;

1.105
date	2010.09.23.20.39.13;	author schwarze;	state Exp;
branches;
next	1.104;

1.104
date	2010.09.20.20.02.27;	author schwarze;	state Exp;
branches;
next	1.103;

1.103
date	2010.08.21.14.00.59;	author schwarze;	state Exp;
branches;
next	1.102;

1.102
date	2010.08.20.22.51.24;	author schwarze;	state Exp;
branches;
next	1.101;

1.101
date	2010.08.18.01.45.22;	author schwarze;	state Exp;
branches;
next	1.100;

1.100
date	2010.08.04.18.52.55;	author schwarze;	state Exp;
branches;
next	1.99;

1.99
date	2010.07.31.21.43.07;	author schwarze;	state Exp;
branches;
next	1.98;

1.98
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.97;

1.97
date	2010.07.21.21.44.28;	author schwarze;	state Exp;
branches;
next	1.96;

1.96
date	2010.07.16.00.03.29;	author schwarze;	state Exp;
branches;
next	1.95;

1.95
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.94;

1.94
date	2010.07.01.15.36.59;	author schwarze;	state Exp;
branches;
next	1.93;

1.93
date	2010.06.29.17.10.30;	author schwarze;	state Exp;
branches;
next	1.92;

1.92
date	2010.06.27.21.54.42;	author schwarze;	state Exp;
branches;
next	1.91;

1.91
date	2010.06.27.17.49.58;	author schwarze;	state Exp;
branches;
next	1.90;

1.90
date	2010.06.27.01.24.02;	author schwarze;	state Exp;
branches;
next	1.89;

1.89
date	2010.06.26.19.08.00;	author schwarze;	state Exp;
branches;
next	1.88;

1.88
date	2010.06.26.17.56.43;	author schwarze;	state Exp;
branches;
next	1.87;

1.87
date	2010.06.10.22.50.10;	author schwarze;	state Exp;
branches;
next	1.86;

1.86
date	2010.06.08.00.11.47;	author schwarze;	state Exp;
branches;
next	1.85;

1.85
date	2010.06.06.20.30.08;	author schwarze;	state Exp;
branches;
next	1.84;

1.84
date	2010.06.06.18.08.41;	author schwarze;	state Exp;
branches;
next	1.83;

1.83
date	2010.05.24.00.37.01;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2010.05.24.00.00.10;	author schwarze;	state Exp;
branches;
next	1.81;

1.81
date	2010.05.23.22.45.01;	author schwarze;	state Exp;
branches;
next	1.80;

1.80
date	2010.05.15.21.09.53;	author schwarze;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.15.18.25.51;	author schwarze;	state Exp;
branches;
next	1.78;

1.78
date	2010.05.14.19.52.43;	author schwarze;	state Exp;
branches;
next	1.77;

1.77
date	2010.05.14.14.47.44;	author schwarze;	state Exp;
branches;
next	1.76;

1.76
date	2010.05.08.02.10.09;	author schwarze;	state Exp;
branches;
next	1.75;

1.75
date	2010.04.23.00.23.46;	author schwarze;	state Exp;
branches;
next	1.74;

1.74
date	2010.04.12.22.52.19;	author schwarze;	state Exp;
branches;
next	1.73;

1.73
date	2010.04.07.23.15.05;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2010.04.03.17.06.19;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2010.03.26.01.22.05;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2010.03.02.00.38.59;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2010.02.18.02.11.26;	author schwarze;	state Exp;
branches;
next	1.68;

1.68
date	2010.01.02.02.42.06;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2010.01.01.23.28.03;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2010.01.01.21.37.52;	author schwarze;	state Exp;
branches;
next	1.65;

1.65
date	2009.12.24.02.08.14;	author schwarze;	state Exp;
branches;
next	1.64;

1.64
date	2009.12.23.22.30.17;	author schwarze;	state Exp;
branches;
next	1.63;

1.63
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2009.10.21.19.13.50;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2009.10.19.21.35.43;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2009.10.19.16.51.08;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2009.10.19.16.27.52;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2009.10.19.13.29.56;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2009.10.19.09.41.22;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2009.09.21.20.57.57;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2009.09.21.20.28.43;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2009.08.22.22.50.17;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2009.08.22.18.40.00;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2009.08.22.18.10.02;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2009.08.22.15.36.58;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2009.08.09.21.59.41;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2009.08.09.21.38.25;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2009.08.09.20.37.32;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2009.08.09.20.11.30;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2009.08.09.19.28.21;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2009.08.09.19.15.14;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2009.08.09.19.01.24;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2009.08.09.18.43.28;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2009.08.09.17.38.24;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2009.07.26.23.39.54;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2009.07.26.23.32.26;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.26.01.59.46;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2009.07.26.00.49.19;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.25.23.29.15;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2009.07.18.22.07.09;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2009.07.18.21.16.49;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2009.07.18.20.50.38;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2009.07.18.19.44.38;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2009.07.18.19.13.44;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2009.07.18.19.00.30;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.18.18.46.42;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.18.17.26.21;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.18.17.11.44;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.18.16.38.10;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.18.15.34.27;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.13.00.26.24;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.12.23.19.48;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.07.00.42.04;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.06.23.37.27;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.06.22.55.33;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.27.13.03.51;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.27.12.43.11;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.27.12.04.45;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.27.11.56.05;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.27.11.49.37;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.27.10.59.07;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.21.20.49.33;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.21.19.53.47;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.18.23.34.53;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.18.21.50.45;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.18.21.45.31;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.18.21.34.54;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.18.20.16.05;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.18.01.19.02;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.17.22.27.34;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.15.02.53.35;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.15.01.07.46;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.14.23.00.57;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.20.30.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.252
log
@Move handling of the roff(7) .ft request from the man(7)
modules to the new roff(7) modules.  As a side effect,
mdoc(7) now handles .ft, too.  Of course, do not use that.
@
text
@/*	$OpenBSD: mdoc_term.c,v 1.251 2017/05/04 22:07:44 schwarze Exp $ */
/*
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010, 2012-2017 Ingo Schwarze <schwarze@@openbsd.org>
 * Copyright (c) 2013 Franco Fichtner <franco@@lastsummer.de>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "out.h"
#include "term.h"
#include "tag.h"
#include "main.h"

struct	termpair {
	struct termpair	 *ppair;
	int		  count;
};

#define	DECL_ARGS struct termp *p, \
		  struct termpair *pair, \
		  const struct roff_meta *meta, \
		  struct roff_node *n

struct	termact {
	int	(*pre)(DECL_ARGS);
	void	(*post)(DECL_ARGS);
};

static	int	  a2width(const struct termp *, const char *);

static	void	  print_bvspace(struct termp *,
			const struct roff_node *,
			const struct roff_node *);
static	void	  print_mdoc_node(DECL_ARGS);
static	void	  print_mdoc_nodelist(DECL_ARGS);
static	void	  print_mdoc_head(struct termp *, const struct roff_meta *);
static	void	  print_mdoc_foot(struct termp *, const struct roff_meta *);
static	void	  synopsis_pre(struct termp *,
			const struct roff_node *);

static	void	  termp____post(DECL_ARGS);
static	void	  termp__t_post(DECL_ARGS);
static	void	  termp_bd_post(DECL_ARGS);
static	void	  termp_bk_post(DECL_ARGS);
static	void	  termp_bl_post(DECL_ARGS);
static	void	  termp_eo_post(DECL_ARGS);
static	void	  termp_fd_post(DECL_ARGS);
static	void	  termp_fo_post(DECL_ARGS);
static	void	  termp_in_post(DECL_ARGS);
static	void	  termp_it_post(DECL_ARGS);
static	void	  termp_lb_post(DECL_ARGS);
static	void	  termp_nm_post(DECL_ARGS);
static	void	  termp_pf_post(DECL_ARGS);
static	void	  termp_quote_post(DECL_ARGS);
static	void	  termp_sh_post(DECL_ARGS);
static	void	  termp_ss_post(DECL_ARGS);
static	void	  termp_xx_post(DECL_ARGS);

static	int	  termp__a_pre(DECL_ARGS);
static	int	  termp__t_pre(DECL_ARGS);
static	int	  termp_an_pre(DECL_ARGS);
static	int	  termp_ap_pre(DECL_ARGS);
static	int	  termp_bd_pre(DECL_ARGS);
static	int	  termp_bf_pre(DECL_ARGS);
static	int	  termp_bk_pre(DECL_ARGS);
static	int	  termp_bl_pre(DECL_ARGS);
static	int	  termp_bold_pre(DECL_ARGS);
static	int	  termp_cd_pre(DECL_ARGS);
static	int	  termp_d1_pre(DECL_ARGS);
static	int	  termp_eo_pre(DECL_ARGS);
static	int	  termp_em_pre(DECL_ARGS);
static	int	  termp_er_pre(DECL_ARGS);
static	int	  termp_ex_pre(DECL_ARGS);
static	int	  termp_fa_pre(DECL_ARGS);
static	int	  termp_fd_pre(DECL_ARGS);
static	int	  termp_fl_pre(DECL_ARGS);
static	int	  termp_fn_pre(DECL_ARGS);
static	int	  termp_fo_pre(DECL_ARGS);
static	int	  termp_ft_pre(DECL_ARGS);
static	int	  termp_in_pre(DECL_ARGS);
static	int	  termp_it_pre(DECL_ARGS);
static	int	  termp_li_pre(DECL_ARGS);
static	int	  termp_ll_pre(DECL_ARGS);
static	int	  termp_lk_pre(DECL_ARGS);
static	int	  termp_nd_pre(DECL_ARGS);
static	int	  termp_nm_pre(DECL_ARGS);
static	int	  termp_ns_pre(DECL_ARGS);
static	int	  termp_quote_pre(DECL_ARGS);
static	int	  termp_rs_pre(DECL_ARGS);
static	int	  termp_sh_pre(DECL_ARGS);
static	int	  termp_skip_pre(DECL_ARGS);
static	int	  termp_sm_pre(DECL_ARGS);
static	int	  termp_sp_pre(DECL_ARGS);
static	int	  termp_ss_pre(DECL_ARGS);
static	int	  termp_sy_pre(DECL_ARGS);
static	int	  termp_tag_pre(DECL_ARGS);
static	int	  termp_under_pre(DECL_ARGS);
static	int	  termp_vt_pre(DECL_ARGS);
static	int	  termp_xr_pre(DECL_ARGS);
static	int	  termp_xx_pre(DECL_ARGS);

static	const struct termact __termacts[MDOC_MAX - MDOC_Dd] = {
	{ NULL, NULL }, /* Dd */
	{ NULL, NULL }, /* Dt */
	{ NULL, NULL }, /* Os */
	{ termp_sh_pre, termp_sh_post }, /* Sh */
	{ termp_ss_pre, termp_ss_post }, /* Ss */
	{ termp_sp_pre, NULL }, /* Pp */
	{ termp_d1_pre, termp_bl_post }, /* D1 */
	{ termp_d1_pre, termp_bl_post }, /* Dl */
	{ termp_bd_pre, termp_bd_post }, /* Bd */
	{ NULL, NULL }, /* Ed */
	{ termp_bl_pre, termp_bl_post }, /* Bl */
	{ NULL, NULL }, /* El */
	{ termp_it_pre, termp_it_post }, /* It */
	{ termp_under_pre, NULL }, /* Ad */
	{ termp_an_pre, NULL }, /* An */
	{ termp_ap_pre, NULL }, /* Ap */
	{ termp_under_pre, NULL }, /* Ar */
	{ termp_cd_pre, NULL }, /* Cd */
	{ termp_bold_pre, NULL }, /* Cm */
	{ termp_li_pre, NULL }, /* Dv */
	{ termp_er_pre, NULL }, /* Er */
	{ termp_tag_pre, NULL }, /* Ev */
	{ termp_ex_pre, NULL }, /* Ex */
	{ termp_fa_pre, NULL }, /* Fa */
	{ termp_fd_pre, termp_fd_post }, /* Fd */
	{ termp_fl_pre, NULL }, /* Fl */
	{ termp_fn_pre, NULL }, /* Fn */
	{ termp_ft_pre, NULL }, /* Ft */
	{ termp_bold_pre, NULL }, /* Ic */
	{ termp_in_pre, termp_in_post }, /* In */
	{ termp_li_pre, NULL }, /* Li */
	{ termp_nd_pre, NULL }, /* Nd */
	{ termp_nm_pre, termp_nm_post }, /* Nm */
	{ termp_quote_pre, termp_quote_post }, /* Op */
	{ termp_ft_pre, NULL }, /* Ot */
	{ termp_under_pre, NULL }, /* Pa */
	{ termp_ex_pre, NULL }, /* Rv */
	{ NULL, NULL }, /* St */
	{ termp_under_pre, NULL }, /* Va */
	{ termp_vt_pre, NULL }, /* Vt */
	{ termp_xr_pre, NULL }, /* Xr */
	{ termp__a_pre, termp____post }, /* %A */
	{ termp_under_pre, termp____post }, /* %B */
	{ NULL, termp____post }, /* %D */
	{ termp_under_pre, termp____post }, /* %I */
	{ termp_under_pre, termp____post }, /* %J */
	{ NULL, termp____post }, /* %N */
	{ NULL, termp____post }, /* %O */
	{ NULL, termp____post }, /* %P */
	{ NULL, termp____post }, /* %R */
	{ termp__t_pre, termp__t_post }, /* %T */
	{ NULL, termp____post }, /* %V */
	{ NULL, NULL }, /* Ac */
	{ termp_quote_pre, termp_quote_post }, /* Ao */
	{ termp_quote_pre, termp_quote_post }, /* Aq */
	{ NULL, NULL }, /* At */
	{ NULL, NULL }, /* Bc */
	{ termp_bf_pre, NULL }, /* Bf */
	{ termp_quote_pre, termp_quote_post }, /* Bo */
	{ termp_quote_pre, termp_quote_post }, /* Bq */
	{ termp_xx_pre, termp_xx_post }, /* Bsx */
	{ NULL, NULL }, /* Bx */
	{ termp_skip_pre, NULL }, /* Db */
	{ NULL, NULL }, /* Dc */
	{ termp_quote_pre, termp_quote_post }, /* Do */
	{ termp_quote_pre, termp_quote_post }, /* Dq */
	{ NULL, NULL }, /* Ec */ /* FIXME: no space */
	{ NULL, NULL }, /* Ef */
	{ termp_em_pre, NULL }, /* Em */
	{ termp_eo_pre, termp_eo_post }, /* Eo */
	{ termp_xx_pre, termp_xx_post }, /* Fx */
	{ termp_bold_pre, NULL }, /* Ms */
	{ termp_li_pre, NULL }, /* No */
	{ termp_ns_pre, NULL }, /* Ns */
	{ termp_xx_pre, termp_xx_post }, /* Nx */
	{ termp_xx_pre, termp_xx_post }, /* Ox */
	{ NULL, NULL }, /* Pc */
	{ NULL, termp_pf_post }, /* Pf */
	{ termp_quote_pre, termp_quote_post }, /* Po */
	{ termp_quote_pre, termp_quote_post }, /* Pq */
	{ NULL, NULL }, /* Qc */
	{ termp_quote_pre, termp_quote_post }, /* Ql */
	{ termp_quote_pre, termp_quote_post }, /* Qo */
	{ termp_quote_pre, termp_quote_post }, /* Qq */
	{ NULL, NULL }, /* Re */
	{ termp_rs_pre, NULL }, /* Rs */
	{ NULL, NULL }, /* Sc */
	{ termp_quote_pre, termp_quote_post }, /* So */
	{ termp_quote_pre, termp_quote_post }, /* Sq */
	{ termp_sm_pre, NULL }, /* Sm */
	{ termp_under_pre, NULL }, /* Sx */
	{ termp_sy_pre, NULL }, /* Sy */
	{ NULL, NULL }, /* Tn */
	{ termp_xx_pre, termp_xx_post }, /* Ux */
	{ NULL, NULL }, /* Xc */
	{ NULL, NULL }, /* Xo */
	{ termp_fo_pre, termp_fo_post }, /* Fo */
	{ NULL, NULL }, /* Fc */
	{ termp_quote_pre, termp_quote_post }, /* Oo */
	{ NULL, NULL }, /* Oc */
	{ termp_bk_pre, termp_bk_post }, /* Bk */
	{ NULL, NULL }, /* Ek */
	{ NULL, NULL }, /* Bt */
	{ NULL, NULL }, /* Hf */
	{ termp_under_pre, NULL }, /* Fr */
	{ NULL, NULL }, /* Ud */
	{ NULL, termp_lb_post }, /* Lb */
	{ termp_sp_pre, NULL }, /* Lp */
	{ termp_lk_pre, NULL }, /* Lk */
	{ termp_under_pre, NULL }, /* Mt */
	{ termp_quote_pre, termp_quote_post }, /* Brq */
	{ termp_quote_pre, termp_quote_post }, /* Bro */
	{ NULL, NULL }, /* Brc */
	{ NULL, termp____post }, /* %C */
	{ termp_skip_pre, NULL }, /* Es */
	{ termp_quote_pre, termp_quote_post }, /* En */
	{ termp_xx_pre, termp_xx_post }, /* Dx */
	{ NULL, termp____post }, /* %Q */
	{ termp_sp_pre, NULL }, /* sp */
	{ NULL, termp____post }, /* %U */
	{ NULL, NULL }, /* Ta */
	{ termp_ll_pre, NULL }, /* ll */
};
static	const struct termact *const termacts = __termacts - MDOC_Dd;

static	int	 fn_prio;


void
terminal_mdoc(void *arg, const struct roff_man *mdoc)
{
	struct roff_node	*n;
	struct termp		*p;
	size_t			 save_defindent;

	p = (struct termp *)arg;
	p->overstep = 0;
	p->rmargin = p->maxrmargin = p->defrmargin;
	p->tabwidth = term_len(p, 5);

	n = mdoc->first->child;
	if (p->synopsisonly) {
		while (n != NULL) {
			if (n->tok == MDOC_Sh && n->sec == SEC_SYNOPSIS) {
				if (n->child->next->child != NULL)
					print_mdoc_nodelist(p, NULL,
					    &mdoc->meta,
					    n->child->next->child);
				term_newln(p);
				break;
			}
			n = n->next;
		}
	} else {
		save_defindent = p->defindent;
		if (p->defindent == 0)
			p->defindent = 5;
		term_begin(p, print_mdoc_head, print_mdoc_foot,
		    &mdoc->meta);
		while (n != NULL && n->flags & NODE_NOPRT)
			n = n->next;
		if (n != NULL) {
			if (n->tok != MDOC_Sh)
				term_vspace(p);
			print_mdoc_nodelist(p, NULL, &mdoc->meta, n);
		}
		term_end(p);
		p->defindent = save_defindent;
	}
}

static void
print_mdoc_nodelist(DECL_ARGS)
{

	while (n != NULL) {
		print_mdoc_node(p, pair, meta, n);
		n = n->next;
	}
}

static void
print_mdoc_node(DECL_ARGS)
{
	int		 chld;
	struct termpair	 npair;
	size_t		 offset, rmargin;

	if (n->flags & NODE_NOPRT)
		return;

	chld = 1;
	offset = p->offset;
	rmargin = p->rmargin;
	n->flags &= ~NODE_ENDED;
	n->prev_font = p->fonti;

	memset(&npair, 0, sizeof(struct termpair));
	npair.ppair = pair;

	/*
	 * Keeps only work until the end of a line.  If a keep was
	 * invoked in a prior line, revert it to PREKEEP.
	 */

	if (p->flags & TERMP_KEEP && n->flags & NODE_LINE) {
		p->flags &= ~TERMP_KEEP;
		p->flags |= TERMP_PREKEEP;
	}

	/*
	 * After the keep flags have been set up, we may now
	 * produce output.  Note that some pre-handlers do so.
	 */

	switch (n->type) {
	case ROFFT_TEXT:
		if (' ' == *n->string && NODE_LINE & n->flags)
			term_newln(p);
		if (NODE_DELIMC & n->flags)
			p->flags |= TERMP_NOSPACE;
		term_word(p, n->string);
		if (NODE_DELIMO & n->flags)
			p->flags |= TERMP_NOSPACE;
		break;
	case ROFFT_EQN:
		if ( ! (n->flags & NODE_LINE))
			p->flags |= TERMP_NOSPACE;
		term_eqn(p, n->eqn);
		if (n->next != NULL && ! (n->next->flags & NODE_LINE))
			p->flags |= TERMP_NOSPACE;
		break;
	case ROFFT_TBL:
		if (p->tbl.cols == NULL)
			term_newln(p);
		term_tbl(p, n->span);
		break;
	default:
		if (n->tok < ROFF_MAX) {
			roff_term_pre(p, n);
			chld = 0;
			break;
		}
		assert(n->tok >= MDOC_Dd && n->tok < MDOC_MAX);
		if (termacts[n->tok].pre != NULL &&
		    (n->end == ENDBODY_NOT || n->child != NULL))
			chld = (*termacts[n->tok].pre)
				(p, &npair, meta, n);
		break;
	}

	if (chld && n->child)
		print_mdoc_nodelist(p, &npair, meta, n->child);

	term_fontpopq(p,
	    (ENDBODY_NOT == n->end ? n : n->body)->prev_font);

	switch (n->type) {
	case ROFFT_TEXT:
		break;
	case ROFFT_TBL:
		break;
	case ROFFT_EQN:
		break;
	default:
		if (n->tok < ROFF_MAX ||
		    termacts[n->tok].post == NULL ||
		    n->flags & NODE_ENDED)
			break;
		(void)(*termacts[n->tok].post)(p, &npair, meta, n);

		/*
		 * Explicit end tokens not only call the post
		 * handler, but also tell the respective block
		 * that it must not call the post handler again.
		 */
		if (ENDBODY_NOT != n->end)
			n->body->flags |= NODE_ENDED;
		break;
	}

	if (NODE_EOS & n->flags)
		p->flags |= TERMP_SENTENCE;

	if (MDOC_ll != n->tok) {
		p->offset = offset;
		p->rmargin = rmargin;
	}
}

static void
print_mdoc_foot(struct termp *p, const struct roff_meta *meta)
{
	size_t sz;

	term_fontrepl(p, TERMFONT_NONE);

	/*
	 * Output the footer in new-groff style, that is, three columns
	 * with the middle being the manual date and flanking columns
	 * being the operating system:
	 *
	 * SYSTEM                  DATE                    SYSTEM
	 */

	term_vspace(p);

	p->offset = 0;
	sz = term_strlen(p, meta->date);
	p->rmargin = p->maxrmargin > sz ?
	    (p->maxrmargin + term_len(p, 1) - sz) / 2 : 0;
	p->trailspace = 1;
	p->flags |= TERMP_NOSPACE | TERMP_NOBREAK;

	term_word(p, meta->os);
	term_flushln(p);

	p->offset = p->rmargin;
	sz = term_strlen(p, meta->os);
	p->rmargin = p->maxrmargin > sz ? p->maxrmargin - sz : 0;
	p->flags |= TERMP_NOSPACE;

	term_word(p, meta->date);
	term_flushln(p);

	p->offset = p->rmargin;
	p->rmargin = p->maxrmargin;
	p->trailspace = 0;
	p->flags &= ~TERMP_NOBREAK;
	p->flags |= TERMP_NOSPACE;

	term_word(p, meta->os);
	term_flushln(p);

	p->offset = 0;
	p->rmargin = p->maxrmargin;
	p->flags = 0;
}

static void
print_mdoc_head(struct termp *p, const struct roff_meta *meta)
{
	char			*volume, *title;
	size_t			 vollen, titlen;

	/*
	 * The header is strange.  It has three components, which are
	 * really two with the first duplicated.  It goes like this:
	 *
	 * IDENTIFIER              TITLE                   IDENTIFIER
	 *
	 * The IDENTIFIER is NAME(SECTION), which is the command-name
	 * (if given, or "unknown" if not) followed by the manual page
	 * section.  These are given in `Dt'.  The TITLE is a free-form
	 * string depending on the manual volume.  If not specified, it
	 * switches on the manual section.
	 */

	assert(meta->vol);
	if (NULL == meta->arch)
		volume = mandoc_strdup(meta->vol);
	else
		mandoc_asprintf(&volume, "%s (%s)",
		    meta->vol, meta->arch);
	vollen = term_strlen(p, volume);

	if (NULL == meta->msec)
		title = mandoc_strdup(meta->title);
	else
		mandoc_asprintf(&title, "%s(%s)",
		    meta->title, meta->msec);
	titlen = term_strlen(p, title);

	p->flags |= TERMP_NOBREAK | TERMP_NOSPACE;
	p->trailspace = 1;
	p->offset = 0;
	p->rmargin = 2 * (titlen+1) + vollen < p->maxrmargin ?
	    (p->maxrmargin - vollen + term_len(p, 1)) / 2 :
	    vollen < p->maxrmargin ?  p->maxrmargin - vollen : 0;

	term_word(p, title);
	term_flushln(p);

	p->flags |= TERMP_NOSPACE;
	p->offset = p->rmargin;
	p->rmargin = p->offset + vollen + titlen < p->maxrmargin ?
	    p->maxrmargin - titlen : p->maxrmargin;

	term_word(p, volume);
	term_flushln(p);

	p->flags &= ~TERMP_NOBREAK;
	p->trailspace = 0;
	if (p->rmargin + titlen <= p->maxrmargin) {
		p->flags |= TERMP_NOSPACE;
		p->offset = p->rmargin;
		p->rmargin = p->maxrmargin;
		term_word(p, title);
		term_flushln(p);
	}

	p->flags &= ~TERMP_NOSPACE;
	p->offset = 0;
	p->rmargin = p->maxrmargin;
	free(title);
	free(volume);
}

static int
a2width(const struct termp *p, const char *v)
{
	struct roffsu	 su;

	if (a2roffsu(v, &su, SCALE_MAX) < 2) {
		SCALE_HS_INIT(&su, term_strlen(p, v));
		su.scale /= term_strlen(p, "0");
	}
	return term_hspan(p, &su) / 24;
}

/*
 * Determine how much space to print out before block elements of `It'
 * (and thus `Bl') and `Bd'.  And then go ahead and print that space,
 * too.
 */
static void
print_bvspace(struct termp *p,
	const struct roff_node *bl,
	const struct roff_node *n)
{
	const struct roff_node	*nn;

	assert(n);

	term_newln(p);

	if (MDOC_Bd == bl->tok && bl->norm->Bd.comp)
		return;
	if (MDOC_Bl == bl->tok && bl->norm->Bl.comp)
		return;

	/* Do not vspace directly after Ss/Sh. */

	nn = n;
	while (nn->prev != NULL && nn->prev->flags & NODE_NOPRT)
		nn = nn->prev;
	while (nn->prev == NULL) {
		do {
			nn = nn->parent;
			if (nn->type == ROFFT_ROOT)
				return;
		} while (nn->type != ROFFT_BLOCK);
		if (nn->tok == MDOC_Sh || nn->tok == MDOC_Ss)
			return;
		if (nn->tok == MDOC_It &&
		    nn->parent->parent->norm->Bl.type != LIST_item)
			break;
	}

	/* A `-column' does not assert vspace within the list. */

	if (MDOC_Bl == bl->tok && LIST_column == bl->norm->Bl.type)
		if (n->prev && MDOC_It == n->prev->tok)
			return;

	/* A `-diag' without body does not vspace. */

	if (MDOC_Bl == bl->tok && LIST_diag == bl->norm->Bl.type)
		if (n->prev && MDOC_It == n->prev->tok) {
			assert(n->prev->body);
			if (NULL == n->prev->body->child)
				return;
		}

	term_vspace(p);
}


static int
termp_ll_pre(DECL_ARGS)
{

	term_setwidth(p, n->child != NULL ? n->child->string : NULL);
	return 0;
}

static int
termp_it_pre(DECL_ARGS)
{
	struct roffsu		su;
	char			buf[24];
	const struct roff_node *bl, *nn;
	size_t			ncols, dcol;
	int			i, offset, width;
	enum mdoc_list		type;

	if (n->type == ROFFT_BLOCK) {
		print_bvspace(p, n->parent->parent, n);
		return 1;
	}

	bl = n->parent->parent->parent;
	type = bl->norm->Bl.type;

	/*
	 * Defaults for specific list types.
	 */

	switch (type) {
	case LIST_bullet:
	case LIST_dash:
	case LIST_hyphen:
	case LIST_enum:
		width = term_len(p, 2);
		break;
	case LIST_hang:
	case LIST_tag:
		width = term_len(p, 8);
		break;
	case LIST_column:
		width = term_len(p, 10);
		break;
	default:
		width = 0;
		break;
	}
	offset = 0;

	/*
	 * First calculate width and offset.  This is pretty easy unless
	 * we're a -column list, in which case all prior columns must
	 * be accounted for.
	 */

	if (bl->norm->Bl.offs != NULL) {
		offset = a2width(p, bl->norm->Bl.offs);
		if (offset < 0 && (size_t)(-offset) > p->offset)
			offset = -p->offset;
		else if (offset > SHRT_MAX)
			offset = 0;
	}

	switch (type) {
	case LIST_column:
		if (n->type == ROFFT_HEAD)
			break;

		/*
		 * Imitate groff's column handling:
		 * - For each earlier column, add its width.
		 * - For less than 5 columns, add four more blanks per
		 *   column.
		 * - For exactly 5 columns, add three more blank per
		 *   column.
		 * - For more than 5 columns, add only one column.
		 */
		ncols = bl->norm->Bl.ncols;
		dcol = ncols < 5 ? term_len(p, 4) :
		    ncols == 5 ? term_len(p, 3) : term_len(p, 1);

		/*
		 * Calculate the offset by applying all prior ROFFT_BODY,
		 * so we stop at the ROFFT_HEAD (nn->prev == NULL).
		 */

		for (i = 0, nn = n->prev;
		    nn->prev && i < (int)ncols;
		    nn = nn->prev, i++) {
			SCALE_HS_INIT(&su,
			    term_strlen(p, bl->norm->Bl.cols[i]));
			su.scale /= term_strlen(p, "0");
			offset += term_hspan(p, &su) / 24 + dcol;
		}

		/*
		 * When exceeding the declared number of columns, leave
		 * the remaining widths at 0.  This will later be
		 * adjusted to the default width of 10, or, for the last
		 * column, stretched to the right margin.
		 */
		if (i >= (int)ncols)
			break;

		/*
		 * Use the declared column widths, extended as explained
		 * in the preceding paragraph.
		 */
		SCALE_HS_INIT(&su, term_strlen(p, bl->norm->Bl.cols[i]));
		su.scale /= term_strlen(p, "0");
		width = term_hspan(p, &su) / 24 + dcol;
		break;
	default:
		if (NULL == bl->norm->Bl.width)
			break;

		/*
		 * Note: buffer the width by 2, which is groff's magic
		 * number for buffering single arguments.  See the above
		 * handling for column for how this changes.
		 */
		width = a2width(p, bl->norm->Bl.width) + term_len(p, 2);
		if (width < 0 && (size_t)(-width) > p->offset)
			width = -p->offset;
		else if (width > SHRT_MAX)
			width = 0;
		break;
	}

	/*
	 * Whitespace control.  Inset bodies need an initial space,
	 * while diagonal bodies need two.
	 */

	p->flags |= TERMP_NOSPACE;

	switch (type) {
	case LIST_diag:
		if (n->type == ROFFT_BODY)
			term_word(p, "\\ \\ ");
		break;
	case LIST_inset:
		if (n->type == ROFFT_BODY && n->parent->head->child != NULL)
			term_word(p, "\\ ");
		break;
	default:
		break;
	}

	p->flags |= TERMP_NOSPACE;

	switch (type) {
	case LIST_diag:
		if (n->type == ROFFT_HEAD)
			term_fontpush(p, TERMFONT_BOLD);
		break;
	default:
		break;
	}

	/*
	 * Pad and break control.  This is the tricky part.  These flags
	 * are documented in term_flushln() in term.c.  Note that we're
	 * going to unset all of these flags in termp_it_post() when we
	 * exit.
	 */

	switch (type) {
	case LIST_enum:
	case LIST_bullet:
	case LIST_dash:
	case LIST_hyphen:
		/*
		 * Weird special case.
		 * Some very narrow lists actually hang.
		 */
		if (width <= (int)term_len(p, 2))
			p->flags |= TERMP_HANG;
		if (n->type != ROFFT_HEAD)
			break;
		p->flags |= TERMP_NOBREAK;
		p->trailspace = 1;
		break;
	case LIST_hang:
		if (n->type != ROFFT_HEAD)
			break;

		/*
		 * This is ugly.  If `-hang' is specified and the body
		 * is a `Bl' or `Bd', then we want basically to nullify
		 * the "overstep" effect in term_flushln() and treat
		 * this as a `-ohang' list instead.
		 */
		if (NULL != n->next &&
		    NULL != n->next->child &&
		    (MDOC_Bl == n->next->child->tok ||
		     MDOC_Bd == n->next->child->tok))
			break;

		p->flags |= TERMP_NOBREAK | TERMP_BRIND | TERMP_HANG;
		p->trailspace = 1;
		break;
	case LIST_tag:
		if (n->type != ROFFT_HEAD)
			break;

		p->flags |= TERMP_NOBREAK | TERMP_BRTRSP | TERMP_BRIND;
		p->trailspace = 2;

		if (NULL == n->next || NULL == n->next->child)
			p->flags |= TERMP_DANGLE;
		break;
	case LIST_column:
		if (n->type == ROFFT_HEAD)
			break;

		if (NULL == n->next) {
			p->flags &= ~TERMP_NOBREAK;
			p->trailspace = 0;
		} else {
			p->flags |= TERMP_NOBREAK;
			p->trailspace = 1;
		}

		break;
	case LIST_diag:
		if (n->type != ROFFT_HEAD)
			break;
		p->flags |= TERMP_NOBREAK | TERMP_BRIND;
		p->trailspace = 1;
		break;
	default:
		break;
	}

	/*
	 * Margin control.  Set-head-width lists have their right
	 * margins shortened.  The body for these lists has the offset
	 * necessarily lengthened.  Everybody gets the offset.
	 */

	p->offset += offset;

	switch (type) {
	case LIST_hang:
		/*
		 * Same stipulation as above, regarding `-hang'.  We
		 * don't want to recalculate rmargin and offsets when
		 * using `Bd' or `Bl' within `-hang' overstep lists.
		 */
		if (n->type == ROFFT_HEAD &&
		    NULL != n->next &&
		    NULL != n->next->child &&
		    (MDOC_Bl == n->next->child->tok ||
		     MDOC_Bd == n->next->child->tok))
			break;
		/* FALLTHROUGH */
	case LIST_bullet:
	case LIST_dash:
	case LIST_enum:
	case LIST_hyphen:
	case LIST_tag:
		if (n->type == ROFFT_HEAD)
			p->rmargin = p->offset + width;
		else
			p->offset += width;
		break;
	case LIST_column:
		assert(width);
		p->rmargin = p->offset + width;
		/*
		 * XXX - this behaviour is not documented: the
		 * right-most column is filled to the right margin.
		 */
		if (n->type == ROFFT_HEAD)
			break;
		if (NULL == n->next && p->rmargin < p->maxrmargin)
			p->rmargin = p->maxrmargin;
		break;
	default:
		break;
	}

	/*
	 * The dash, hyphen, bullet and enum lists all have a special
	 * HEAD character (temporarily bold, in some cases).
	 */

	if (n->type == ROFFT_HEAD)
		switch (type) {
		case LIST_bullet:
			term_fontpush(p, TERMFONT_BOLD);
			term_word(p, "\\[bu]");
			term_fontpop(p);
			break;
		case LIST_dash:
		case LIST_hyphen:
			term_fontpush(p, TERMFONT_BOLD);
			term_word(p, "-");
			term_fontpop(p);
			break;
		case LIST_enum:
			(pair->ppair->ppair->count)++;
			(void)snprintf(buf, sizeof(buf), "%d.",
			    pair->ppair->ppair->count);
			term_word(p, buf);
			break;
		default:
			break;
		}

	/*
	 * If we're not going to process our children, indicate so here.
	 */

	switch (type) {
	case LIST_bullet:
	case LIST_item:
	case LIST_dash:
	case LIST_hyphen:
	case LIST_enum:
		if (n->type == ROFFT_HEAD)
			return 0;
		break;
	case LIST_column:
		if (n->type == ROFFT_HEAD)
			return 0;
		break;
	default:
		break;
	}

	return 1;
}

static void
termp_it_post(DECL_ARGS)
{
	enum mdoc_list	   type;

	if (n->type == ROFFT_BLOCK)
		return;

	type = n->parent->parent->parent->norm->Bl.type;

	switch (type) {
	case LIST_item:
	case LIST_diag:
	case LIST_inset:
		if (n->type == ROFFT_BODY)
			term_newln(p);
		break;
	case LIST_column:
		if (n->type == ROFFT_BODY)
			term_flushln(p);
		break;
	default:
		term_newln(p);
		break;
	}

	/*
	 * Now that our output is flushed, we can reset our tags.  Since
	 * only `It' sets these flags, we're free to assume that nobody
	 * has munged them in the meanwhile.
	 */

	p->flags &= ~(TERMP_NOBREAK | TERMP_BRTRSP | TERMP_BRIND |
			TERMP_DANGLE | TERMP_HANG);
	p->trailspace = 0;
}

static int
termp_nm_pre(DECL_ARGS)
{
	const char	*cp;

	if (n->type == ROFFT_BLOCK) {
		p->flags |= TERMP_PREKEEP;
		return 1;
	}

	if (n->type == ROFFT_BODY) {
		if (NULL == n->child)
			return 0;
		p->flags |= TERMP_NOSPACE;
		cp = NULL;
		if (n->prev->child != NULL)
		    cp = n->prev->child->string;
		if (cp == NULL)
			cp = meta->name;
		if (cp == NULL)
			p->offset += term_len(p, 6);
		else
			p->offset += term_len(p, 1) + term_strlen(p, cp);
		return 1;
	}

	if (n->child == NULL)
		return 0;

	if (n->type == ROFFT_HEAD)
		synopsis_pre(p, n->parent);

	if (n->type == ROFFT_HEAD &&
	    NULL != n->next && NULL != n->next->child) {
		p->flags |= TERMP_NOSPACE | TERMP_NOBREAK | TERMP_BRIND;
		p->trailspace = 1;
		p->rmargin = p->offset + term_len(p, 1);
		if (NULL == n->child) {
			p->rmargin += term_strlen(p, meta->name);
		} else if (n->child->type == ROFFT_TEXT) {
			p->rmargin += term_strlen(p, n->child->string);
			if (n->child->next)
				p->flags |= TERMP_HANG;
		} else {
			p->rmargin += term_len(p, 5);
			p->flags |= TERMP_HANG;
		}
	}

	term_fontpush(p, TERMFONT_BOLD);
	return 1;
}

static void
termp_nm_post(DECL_ARGS)
{

	if (n->type == ROFFT_BLOCK) {
		p->flags &= ~(TERMP_KEEP | TERMP_PREKEEP);
	} else if (n->type == ROFFT_HEAD &&
	    NULL != n->next && NULL != n->next->child) {
		term_flushln(p);
		p->flags &= ~(TERMP_NOBREAK | TERMP_BRIND | TERMP_HANG);
		p->trailspace = 0;
	} else if (n->type == ROFFT_BODY && n->child != NULL)
		term_flushln(p);
}

static int
termp_fl_pre(DECL_ARGS)
{

	termp_tag_pre(p, pair, meta, n);
	term_fontpush(p, TERMFONT_BOLD);
	term_word(p, "\\-");

	if (!(n->child == NULL &&
	    (n->next == NULL ||
	     n->next->type == ROFFT_TEXT ||
	     n->next->flags & NODE_LINE)))
		p->flags |= TERMP_NOSPACE;

	return 1;
}

static int
termp__a_pre(DECL_ARGS)
{

	if (n->prev && MDOC__A == n->prev->tok)
		if (NULL == n->next || MDOC__A != n->next->tok)
			term_word(p, "and");

	return 1;
}

static int
termp_an_pre(DECL_ARGS)
{

	if (n->norm->An.auth == AUTH_split) {
		p->flags &= ~TERMP_NOSPLIT;
		p->flags |= TERMP_SPLIT;
		return 0;
	}
	if (n->norm->An.auth == AUTH_nosplit) {
		p->flags &= ~TERMP_SPLIT;
		p->flags |= TERMP_NOSPLIT;
		return 0;
	}

	if (p->flags & TERMP_SPLIT)
		term_newln(p);

	if (n->sec == SEC_AUTHORS && ! (p->flags & TERMP_NOSPLIT))
		p->flags |= TERMP_SPLIT;

	return 1;
}

static int
termp_ns_pre(DECL_ARGS)
{

	if ( ! (NODE_LINE & n->flags))
		p->flags |= TERMP_NOSPACE;
	return 1;
}

static int
termp_rs_pre(DECL_ARGS)
{

	if (SEC_SEE_ALSO != n->sec)
		return 1;
	if (n->type == ROFFT_BLOCK && n->prev != NULL)
		term_vspace(p);
	return 1;
}

static int
termp_ex_pre(DECL_ARGS)
{
	term_newln(p);
	return 1;
}

static int
termp_nd_pre(DECL_ARGS)
{

	if (n->type == ROFFT_BODY)
		term_word(p, "\\(en");
	return 1;
}

static int
termp_bl_pre(DECL_ARGS)
{

	return n->type != ROFFT_HEAD;
}

static void
termp_bl_post(DECL_ARGS)
{

	if (n->type == ROFFT_BLOCK)
		term_newln(p);
}

static int
termp_xr_pre(DECL_ARGS)
{

	if (NULL == (n = n->child))
		return 0;

	assert(n->type == ROFFT_TEXT);
	term_word(p, n->string);

	if (NULL == (n = n->next))
		return 0;

	p->flags |= TERMP_NOSPACE;
	term_word(p, "(");
	p->flags |= TERMP_NOSPACE;

	assert(n->type == ROFFT_TEXT);
	term_word(p, n->string);

	p->flags |= TERMP_NOSPACE;
	term_word(p, ")");

	return 0;
}

/*
 * This decides how to assert whitespace before any of the SYNOPSIS set
 * of macros (which, as in the case of Ft/Fo and Ft/Fn, may contain
 * macro combos).
 */
static void
synopsis_pre(struct termp *p, const struct roff_node *n)
{
	/*
	 * Obviously, if we're not in a SYNOPSIS or no prior macros
	 * exist, do nothing.
	 */
	if (NULL == n->prev || ! (NODE_SYNPRETTY & n->flags))
		return;

	/*
	 * If we're the second in a pair of like elements, emit our
	 * newline and return.  UNLESS we're `Fo', `Fn', `Fn', in which
	 * case we soldier on.
	 */
	if (n->prev->tok == n->tok &&
	    MDOC_Ft != n->tok &&
	    MDOC_Fo != n->tok &&
	    MDOC_Fn != n->tok) {
		term_newln(p);
		return;
	}

	/*
	 * If we're one of the SYNOPSIS set and non-like pair-wise after
	 * another (or Fn/Fo, which we've let slip through) then assert
	 * vertical space, else only newline and move on.
	 */
	switch (n->prev->tok) {
	case MDOC_Fd:
	case MDOC_Fn:
	case MDOC_Fo:
	case MDOC_In:
	case MDOC_Vt:
		term_vspace(p);
		break;
	case MDOC_Ft:
		if (MDOC_Fn != n->tok && MDOC_Fo != n->tok) {
			term_vspace(p);
			break;
		}
		/* FALLTHROUGH */
	default:
		term_newln(p);
		break;
	}
}

static int
termp_vt_pre(DECL_ARGS)
{

	if (n->type == ROFFT_ELEM) {
		synopsis_pre(p, n);
		return termp_under_pre(p, pair, meta, n);
	} else if (n->type == ROFFT_BLOCK) {
		synopsis_pre(p, n);
		return 1;
	} else if (n->type == ROFFT_HEAD)
		return 0;

	return termp_under_pre(p, pair, meta, n);
}

static int
termp_bold_pre(DECL_ARGS)
{

	termp_tag_pre(p, pair, meta, n);
	term_fontpush(p, TERMFONT_BOLD);
	return 1;
}

static int
termp_fd_pre(DECL_ARGS)
{

	synopsis_pre(p, n);
	return termp_bold_pre(p, pair, meta, n);
}

static void
termp_fd_post(DECL_ARGS)
{

	term_newln(p);
}

static int
termp_sh_pre(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		/*
		 * Vertical space before sections, except
		 * when the previous section was empty.
		 */
		if (n->prev == NULL ||
		    n->prev->tok != MDOC_Sh ||
		    (n->prev->body != NULL &&
		     n->prev->body->child != NULL))
			term_vspace(p);
		break;
	case ROFFT_HEAD:
		term_fontpush(p, TERMFONT_BOLD);
		break;
	case ROFFT_BODY:
		p->offset = term_len(p, p->defindent);
		switch (n->sec) {
		case SEC_DESCRIPTION:
			fn_prio = 0;
			break;
		case SEC_AUTHORS:
			p->flags &= ~(TERMP_SPLIT|TERMP_NOSPLIT);
			break;
		default:
			break;
		}
		break;
	default:
		break;
	}
	return 1;
}

static void
termp_sh_post(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_HEAD:
		term_newln(p);
		break;
	case ROFFT_BODY:
		term_newln(p);
		p->offset = 0;
		break;
	default:
		break;
	}
}

static void
termp_lb_post(DECL_ARGS)
{

	if (SEC_LIBRARY == n->sec && NODE_LINE & n->flags)
		term_newln(p);
}

static int
termp_d1_pre(DECL_ARGS)
{

	if (n->type != ROFFT_BLOCK)
		return 1;
	term_newln(p);
	p->offset += term_len(p, p->defindent + 1);
	return 1;
}

static int
termp_ft_pre(DECL_ARGS)
{

	/* NB: NODE_LINE does not effect this! */
	synopsis_pre(p, n);
	term_fontpush(p, TERMFONT_UNDER);
	return 1;
}

static int
termp_fn_pre(DECL_ARGS)
{
	size_t		 rmargin = 0;
	int		 pretty;

	pretty = NODE_SYNPRETTY & n->flags;

	synopsis_pre(p, n);

	if (NULL == (n = n->child))
		return 0;

	if (pretty) {
		rmargin = p->rmargin;
		p->rmargin = p->offset + term_len(p, 4);
		p->flags |= TERMP_NOBREAK | TERMP_BRIND | TERMP_HANG;
	}

	assert(n->type == ROFFT_TEXT);
	term_fontpush(p, TERMFONT_BOLD);
	term_word(p, n->string);
	term_fontpop(p);

	if (n->sec == SEC_DESCRIPTION || n->sec == SEC_CUSTOM)
		tag_put(n->string, ++fn_prio, p->line);

	if (pretty) {
		term_flushln(p);
		p->flags &= ~(TERMP_NOBREAK | TERMP_BRIND | TERMP_HANG);
		p->offset = p->rmargin;
		p->rmargin = rmargin;
	}

	p->flags |= TERMP_NOSPACE;
	term_word(p, "(");
	p->flags |= TERMP_NOSPACE;

	for (n = n->next; n; n = n->next) {
		assert(n->type == ROFFT_TEXT);
		term_fontpush(p, TERMFONT_UNDER);
		if (pretty)
			p->flags |= TERMP_NBRWORD;
		term_word(p, n->string);
		term_fontpop(p);

		if (n->next) {
			p->flags |= TERMP_NOSPACE;
			term_word(p, ",");
		}
	}

	p->flags |= TERMP_NOSPACE;
	term_word(p, ")");

	if (pretty) {
		p->flags |= TERMP_NOSPACE;
		term_word(p, ";");
		term_flushln(p);
	}

	return 0;
}

static int
termp_fa_pre(DECL_ARGS)
{
	const struct roff_node	*nn;

	if (n->parent->tok != MDOC_Fo) {
		term_fontpush(p, TERMFONT_UNDER);
		return 1;
	}

	for (nn = n->child; nn; nn = nn->next) {
		term_fontpush(p, TERMFONT_UNDER);
		p->flags |= TERMP_NBRWORD;
		term_word(p, nn->string);
		term_fontpop(p);

		if (nn->next || (n->next && n->next->tok == MDOC_Fa)) {
			p->flags |= TERMP_NOSPACE;
			term_word(p, ",");
		}
	}

	return 0;
}

static int
termp_bd_pre(DECL_ARGS)
{
	size_t			 tabwidth, lm, len, rm, rmax;
	struct roff_node	*nn;
	int			 offset;

	if (n->type == ROFFT_BLOCK) {
		print_bvspace(p, n, n);
		return 1;
	} else if (n->type == ROFFT_HEAD)
		return 0;

	/* Handle the -offset argument. */

	if (n->norm->Bd.offs == NULL ||
	    ! strcmp(n->norm->Bd.offs, "left"))
		/* nothing */;
	else if ( ! strcmp(n->norm->Bd.offs, "indent"))
		p->offset += term_len(p, p->defindent + 1);
	else if ( ! strcmp(n->norm->Bd.offs, "indent-two"))
		p->offset += term_len(p, (p->defindent + 1) * 2);
	else {
		offset = a2width(p, n->norm->Bd.offs);
		if (offset < 0 && (size_t)(-offset) > p->offset)
			p->offset = 0;
		else if (offset < SHRT_MAX)
			p->offset += offset;
	}

	/*
	 * If -ragged or -filled are specified, the block does nothing
	 * but change the indentation.  If -unfilled or -literal are
	 * specified, text is printed exactly as entered in the display:
	 * for macro lines, a newline is appended to the line.  Blank
	 * lines are allowed.
	 */

	if (DISP_literal != n->norm->Bd.type &&
	    DISP_unfilled != n->norm->Bd.type &&
	    DISP_centered != n->norm->Bd.type)
		return 1;

	tabwidth = p->tabwidth;
	if (DISP_literal == n->norm->Bd.type)
		p->tabwidth = term_len(p, 8);

	lm = p->offset;
	rm = p->rmargin;
	rmax = p->maxrmargin;
	p->rmargin = p->maxrmargin = TERM_MAXMARGIN;

	for (nn = n->child; nn; nn = nn->next) {
		if (DISP_centered == n->norm->Bd.type) {
			if (nn->type == ROFFT_TEXT) {
				len = term_strlen(p, nn->string);
				p->offset = len >= rm ? 0 :
				    lm + len >= rm ? rm - len :
				    (lm + rm - len) / 2;
			} else
				p->offset = lm;
		}
		print_mdoc_node(p, pair, meta, nn);
		/*
		 * If the printed node flushes its own line, then we
		 * needn't do it here as well.  This is hacky, but the
		 * notion of selective eoln whitespace is pretty dumb
		 * anyway, so don't sweat it.
		 */
		switch (nn->tok) {
		case MDOC_Sm:
		case ROFF_br:
		case MDOC_sp:
		case MDOC_Bl:
		case MDOC_D1:
		case MDOC_Dl:
		case MDOC_Lp:
		case MDOC_Pp:
			continue;
		default:
			break;
		}
		if (p->flags & TERMP_NONEWLINE ||
		    (nn->next && ! (nn->next->flags & NODE_LINE)))
			continue;
		term_flushln(p);
		p->flags |= TERMP_NOSPACE;
	}

	p->tabwidth = tabwidth;
	p->rmargin = rm;
	p->maxrmargin = rmax;
	return 0;
}

static void
termp_bd_post(DECL_ARGS)
{
	size_t		 rm, rmax;

	if (n->type != ROFFT_BODY)
		return;

	rm = p->rmargin;
	rmax = p->maxrmargin;

	if (DISP_literal == n->norm->Bd.type ||
	    DISP_unfilled == n->norm->Bd.type)
		p->rmargin = p->maxrmargin = TERM_MAXMARGIN;

	p->flags |= TERMP_NOSPACE;
	term_newln(p);

	p->rmargin = rm;
	p->maxrmargin = rmax;
}

static int
termp_xx_pre(DECL_ARGS)
{
	if ((n->aux = p->flags & TERMP_PREKEEP) == 0)
		p->flags |= TERMP_PREKEEP;
	return 1;
}

static void
termp_xx_post(DECL_ARGS)
{
	if (n->aux == 0)
		p->flags &= ~(TERMP_KEEP | TERMP_PREKEEP);
}

static void
termp_pf_post(DECL_ARGS)
{

	if ( ! (n->next == NULL || n->next->flags & NODE_LINE))
		p->flags |= TERMP_NOSPACE;
}

static int
termp_ss_pre(DECL_ARGS)
{
	struct roff_node *nn;

	switch (n->type) {
	case ROFFT_BLOCK:
		term_newln(p);
		for (nn = n->prev; nn != NULL; nn = nn->prev)
			if ((nn->flags & NODE_NOPRT) == 0)
				break;
		if (nn != NULL)
			term_vspace(p);
		break;
	case ROFFT_HEAD:
		term_fontpush(p, TERMFONT_BOLD);
		p->offset = term_len(p, (p->defindent+1)/2);
		break;
	case ROFFT_BODY:
		p->offset = term_len(p, p->defindent);
		break;
	default:
		break;
	}

	return 1;
}

static void
termp_ss_post(DECL_ARGS)
{

	if (n->type == ROFFT_HEAD || n->type == ROFFT_BODY)
		term_newln(p);
}

static int
termp_cd_pre(DECL_ARGS)
{

	synopsis_pre(p, n);
	term_fontpush(p, TERMFONT_BOLD);
	return 1;
}

static int
termp_in_pre(DECL_ARGS)
{

	synopsis_pre(p, n);

	if (NODE_SYNPRETTY & n->flags && NODE_LINE & n->flags) {
		term_fontpush(p, TERMFONT_BOLD);
		term_word(p, "#include");
		term_word(p, "<");
	} else {
		term_word(p, "<");
		term_fontpush(p, TERMFONT_UNDER);
	}

	p->flags |= TERMP_NOSPACE;
	return 1;
}

static void
termp_in_post(DECL_ARGS)
{

	if (NODE_SYNPRETTY & n->flags)
		term_fontpush(p, TERMFONT_BOLD);

	p->flags |= TERMP_NOSPACE;
	term_word(p, ">");

	if (NODE_SYNPRETTY & n->flags)
		term_fontpop(p);
}

static int
termp_sp_pre(DECL_ARGS)
{
	struct roffsu	 su;
	int		 i, len;

	switch (n->tok) {
	case MDOC_sp:
		if (n->child) {
			if ( ! a2roffsu(n->child->string, &su, SCALE_VS))
				su.scale = 1.0;
			len = term_vspan(p, &su);
		} else
			len = 1;
		break;
	case ROFF_br:
		len = 0;
		break;
	default:
		len = 1;
		fn_prio = 0;
		break;
	}

	if (0 == len)
		term_newln(p);
	else if (len < 0)
		p->skipvsp -= len;
	else
		for (i = 0; i < len; i++)
			term_vspace(p);

	return 0;
}

static int
termp_skip_pre(DECL_ARGS)
{

	return 0;
}

static int
termp_quote_pre(DECL_ARGS)
{

	if (n->type != ROFFT_BODY && n->type != ROFFT_ELEM)
		return 1;

	switch (n->tok) {
	case MDOC_Ao:
	case MDOC_Aq:
		term_word(p, n->child != NULL && n->child->next == NULL &&
		    n->child->tok == MDOC_Mt ? "<" : "\\(la");
		break;
	case MDOC_Bro:
	case MDOC_Brq:
		term_word(p, "{");
		break;
	case MDOC_Oo:
	case MDOC_Op:
	case MDOC_Bo:
	case MDOC_Bq:
		term_word(p, "[");
		break;
	case MDOC__T:
		/* FALLTHROUGH */
	case MDOC_Do:
	case MDOC_Dq:
		term_word(p, "\\(Lq");
		break;
	case MDOC_En:
		if (NULL == n->norm->Es ||
		    NULL == n->norm->Es->child)
			return 1;
		term_word(p, n->norm->Es->child->string);
		break;
	case MDOC_Po:
	case MDOC_Pq:
		term_word(p, "(");
		break;
	case MDOC_Qo:
	case MDOC_Qq:
		term_word(p, "\"");
		break;
	case MDOC_Ql:
	case MDOC_So:
	case MDOC_Sq:
		term_word(p, "\\(oq");
		break;
	default:
		abort();
	}

	p->flags |= TERMP_NOSPACE;
	return 1;
}

static void
termp_quote_post(DECL_ARGS)
{

	if (n->type != ROFFT_BODY && n->type != ROFFT_ELEM)
		return;

	p->flags |= TERMP_NOSPACE;

	switch (n->tok) {
	case MDOC_Ao:
	case MDOC_Aq:
		term_word(p, n->child != NULL && n->child->next == NULL &&
		    n->child->tok == MDOC_Mt ? ">" : "\\(ra");
		break;
	case MDOC_Bro:
	case MDOC_Brq:
		term_word(p, "}");
		break;
	case MDOC_Oo:
	case MDOC_Op:
	case MDOC_Bo:
	case MDOC_Bq:
		term_word(p, "]");
		break;
	case MDOC__T:
		/* FALLTHROUGH */
	case MDOC_Do:
	case MDOC_Dq:
		term_word(p, "\\(Rq");
		break;
	case MDOC_En:
		if (n->norm->Es == NULL ||
		    n->norm->Es->child == NULL ||
		    n->norm->Es->child->next == NULL)
			p->flags &= ~TERMP_NOSPACE;
		else
			term_word(p, n->norm->Es->child->next->string);
		break;
	case MDOC_Po:
	case MDOC_Pq:
		term_word(p, ")");
		break;
	case MDOC_Qo:
	case MDOC_Qq:
		term_word(p, "\"");
		break;
	case MDOC_Ql:
	case MDOC_So:
	case MDOC_Sq:
		term_word(p, "\\(cq");
		break;
	default:
		abort();
	}
}

static int
termp_eo_pre(DECL_ARGS)
{

	if (n->type != ROFFT_BODY)
		return 1;

	if (n->end == ENDBODY_NOT &&
	    n->parent->head->child == NULL &&
	    n->child != NULL &&
	    n->child->end != ENDBODY_NOT)
		term_word(p, "\\&");
	else if (n->end != ENDBODY_NOT ? n->child != NULL :
	     n->parent->head->child != NULL && (n->child != NULL ||
	     (n->parent->tail != NULL && n->parent->tail->child != NULL)))
		p->flags |= TERMP_NOSPACE;

	return 1;
}

static void
termp_eo_post(DECL_ARGS)
{
	int	 body, tail;

	if (n->type != ROFFT_BODY)
		return;

	if (n->end != ENDBODY_NOT) {
		p->flags &= ~TERMP_NOSPACE;
		return;
	}

	body = n->child != NULL || n->parent->head->child != NULL;
	tail = n->parent->tail != NULL && n->parent->tail->child != NULL;

	if (body && tail)
		p->flags |= TERMP_NOSPACE;
	else if ( ! (body || tail))
		term_word(p, "\\&");
	else if ( ! tail)
		p->flags &= ~TERMP_NOSPACE;
}

static int
termp_fo_pre(DECL_ARGS)
{
	size_t		 rmargin = 0;
	int		 pretty;

	pretty = NODE_SYNPRETTY & n->flags;

	if (n->type == ROFFT_BLOCK) {
		synopsis_pre(p, n);
		return 1;
	} else if (n->type == ROFFT_BODY) {
		if (pretty) {
			rmargin = p->rmargin;
			p->rmargin = p->offset + term_len(p, 4);
			p->flags |= TERMP_NOBREAK | TERMP_BRIND |
					TERMP_HANG;
		}
		p->flags |= TERMP_NOSPACE;
		term_word(p, "(");
		p->flags |= TERMP_NOSPACE;
		if (pretty) {
			term_flushln(p);
			p->flags &= ~(TERMP_NOBREAK | TERMP_BRIND |
					TERMP_HANG);
			p->offset = p->rmargin;
			p->rmargin = rmargin;
		}
		return 1;
	}

	if (NULL == n->child)
		return 0;

	/* XXX: we drop non-initial arguments as per groff. */

	assert(n->child->string);
	term_fontpush(p, TERMFONT_BOLD);
	term_word(p, n->child->string);
	return 0;
}

static void
termp_fo_post(DECL_ARGS)
{

	if (n->type != ROFFT_BODY)
		return;

	p->flags |= TERMP_NOSPACE;
	term_word(p, ")");

	if (NODE_SYNPRETTY & n->flags) {
		p->flags |= TERMP_NOSPACE;
		term_word(p, ";");
		term_flushln(p);
	}
}

static int
termp_bf_pre(DECL_ARGS)
{

	if (n->type == ROFFT_HEAD)
		return 0;
	else if (n->type != ROFFT_BODY)
		return 1;

	if (FONT_Em == n->norm->Bf.font)
		term_fontpush(p, TERMFONT_UNDER);
	else if (FONT_Sy == n->norm->Bf.font)
		term_fontpush(p, TERMFONT_BOLD);
	else
		term_fontpush(p, TERMFONT_NONE);

	return 1;
}

static int
termp_sm_pre(DECL_ARGS)
{

	if (NULL == n->child)
		p->flags ^= TERMP_NONOSPACE;
	else if (0 == strcmp("on", n->child->string))
		p->flags &= ~TERMP_NONOSPACE;
	else
		p->flags |= TERMP_NONOSPACE;

	if (p->col && ! (TERMP_NONOSPACE & p->flags))
		p->flags &= ~TERMP_NOSPACE;

	return 0;
}

static int
termp_ap_pre(DECL_ARGS)
{

	p->flags |= TERMP_NOSPACE;
	term_word(p, "'");
	p->flags |= TERMP_NOSPACE;
	return 1;
}

static void
termp____post(DECL_ARGS)
{

	/*
	 * Handle lists of authors.  In general, print each followed by
	 * a comma.  Don't print the comma if there are only two
	 * authors.
	 */
	if (MDOC__A == n->tok && n->next && MDOC__A == n->next->tok)
		if (NULL == n->next->next || MDOC__A != n->next->next->tok)
			if (NULL == n->prev || MDOC__A != n->prev->tok)
				return;

	/* TODO: %U. */

	if (NULL == n->parent || MDOC_Rs != n->parent->tok)
		return;

	p->flags |= TERMP_NOSPACE;
	if (NULL == n->next) {
		term_word(p, ".");
		p->flags |= TERMP_SENTENCE;
	} else
		term_word(p, ",");
}

static int
termp_li_pre(DECL_ARGS)
{

	termp_tag_pre(p, pair, meta, n);
	term_fontpush(p, TERMFONT_NONE);
	return 1;
}

static int
termp_lk_pre(DECL_ARGS)
{
	const struct roff_node *link, *descr;
	int display;

	if ((link = n->child) == NULL)
		return 0;

	/* Link text. */
	if ((descr = link->next) != NULL && !(descr->flags & NODE_DELIMC)) {
		term_fontpush(p, TERMFONT_UNDER);
		while (descr != NULL && !(descr->flags & NODE_DELIMC)) {
			term_word(p, descr->string);
			descr = descr->next;
		}
		term_fontpop(p);
		p->flags |= TERMP_NOSPACE;
		term_word(p, ":");
	}

	/* Link target. */
	display = term_strlen(p, link->string) >= 26;
	if (display) {
		term_newln(p);
		p->offset += term_len(p, p->defindent + 1);
	}
	term_fontpush(p, TERMFONT_BOLD);
	term_word(p, link->string);
	term_fontpop(p);

	/* Trailing punctuation. */
	while (descr != NULL) {
		p->flags |= TERMP_NOSPACE;
		term_word(p, descr->string);
		descr = descr->next;
	}
	if (display)
		term_newln(p);
	return 0;
}

static int
termp_bk_pre(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		break;
	case ROFFT_HEAD:
		return 0;
	case ROFFT_BODY:
		if (n->parent->args != NULL || n->prev->child == NULL)
			p->flags |= TERMP_PREKEEP;
		break;
	default:
		abort();
	}

	return 1;
}

static void
termp_bk_post(DECL_ARGS)
{

	if (n->type == ROFFT_BODY)
		p->flags &= ~(TERMP_KEEP | TERMP_PREKEEP);
}

static void
termp__t_post(DECL_ARGS)
{

	/*
	 * If we're in an `Rs' and there's a journal present, then quote
	 * us instead of underlining us (for disambiguation).
	 */
	if (n->parent && MDOC_Rs == n->parent->tok &&
	    n->parent->norm->Rs.quote_T)
		termp_quote_post(p, pair, meta, n);

	termp____post(p, pair, meta, n);
}

static int
termp__t_pre(DECL_ARGS)
{

	/*
	 * If we're in an `Rs' and there's a journal present, then quote
	 * us instead of underlining us (for disambiguation).
	 */
	if (n->parent && MDOC_Rs == n->parent->tok &&
	    n->parent->norm->Rs.quote_T)
		return termp_quote_pre(p, pair, meta, n);

	term_fontpush(p, TERMFONT_UNDER);
	return 1;
}

static int
termp_under_pre(DECL_ARGS)
{

	term_fontpush(p, TERMFONT_UNDER);
	return 1;
}

static int
termp_em_pre(DECL_ARGS)
{
	if (n->child != NULL &&
	    n->child->type == ROFFT_TEXT)
		tag_put(n->child->string, 0, p->line);
	term_fontpush(p, TERMFONT_UNDER);
	return 1;
}

static int
termp_sy_pre(DECL_ARGS)
{
	if (n->child != NULL &&
	    n->child->type == ROFFT_TEXT)
		tag_put(n->child->string, 0, p->line);
	term_fontpush(p, TERMFONT_BOLD);
	return 1;
}

static int
termp_er_pre(DECL_ARGS)
{

	if (n->sec == SEC_ERRORS &&
	    (n->parent->tok == MDOC_It ||
	     (n->parent->tok == MDOC_Bq &&
	      n->parent->parent->parent->tok == MDOC_It)))
		tag_put(n->child->string, 1, p->line);
	return 1;
}

static int
termp_tag_pre(DECL_ARGS)
{

	if (n->child != NULL &&
	    n->child->type == ROFFT_TEXT &&
	    (n->prev == NULL ||
	     (n->prev->type == ROFFT_TEXT &&
	      strcmp(n->prev->string, "|") == 0)) &&
	    (n->parent->tok == MDOC_It ||
	     (n->parent->tok == MDOC_Xo &&
	      n->parent->parent->prev == NULL &&
	      n->parent->parent->parent->tok == MDOC_It)))
		tag_put(n->child->string, 1, p->line);
	return 1;
}
@


1.251
log
@Start roff formatter modules for HTML and termininal output,
used by both the mdoc and man formatters, with the ultimate
goal of reducing code duplication between the two macro formatters.
Made possible by the parser unification.
Add the first formatting function (for the .br request).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.250 2017/05/04 17:48:24 schwarze Exp $ */
d367 1
@


1.250
log
@Parser reorg:
Generate the first node on the roff level: .br
Fix some column numbers in diagnostic messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.249 2017/04/24 23:06:09 schwarze Exp $ */
d366 1
a366 7
			switch (n->tok) {
			case ROFF_br:
				termp_sp_pre(p, &npair, meta, n);
				break;
			default:
				abort();
			}
@


1.249
log
@Continue parser unification:
* Make enum rofft an internal interface as enum roff_tok in "roff.h".
* Represent mdoc and man macros in enum roff_tok.
* Make TOKEN_NONE a proper enum value and use it throughout.
* Put the prologue macros first in the macro tables.
* Unify mdoc_macroname[] and man_macroname[] into roff_name[].
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.248 2017/04/17 12:52:00 schwarze Exp $ */
a244 1
	{ termp_sp_pre, NULL }, /* br */
d365 11
d397 3
a399 1
		if (termacts[n->tok].post == NULL || n->flags & NODE_ENDED)
d1517 1
a1517 1
		case MDOC_br:
d1679 1
a1679 1
	case MDOC_br:
@


1.248
log
@Fix handling of trailing punctuation in .Lk.
This macro is unusual in so far as trailing punction needs to remain
inside the scope because it must be inside, not after the display
of long URIs in terminal output mode.
Improves formatting of fw_update(1), help(1), less(1), sendbug(1),
acx(4), inet6(4), ipsec(4), oce(4), isakmpd.conf(5), afterboot(8),
release(8), traceroute(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.247 2017/04/14 19:34:54 schwarze Exp $ */
d126 1
a126 2
static	const struct termact termacts[MDOC_MAX] = {
	{ termp_ap_pre, NULL }, /* Ap */
d142 1
d251 1
d255 1
d366 1
a366 1
		if (termacts[n->tok].pre &&
d387 1
a387 1
		if ( ! termacts[n->tok].post || NODE_ENDED & n->flags)
@


1.247
log
@Show long .Lk URIs in like an indented display, similar to groff.
Suggested by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.246 2017/04/14 18:23:29 schwarze Exp $ */
d1996 1
a1996 1
	if (NULL == (link = n->child))
d1999 2
a2000 1
	if (NULL != (descr = link->next)) {
d2002 1
a2002 1
		while (NULL != descr) {
d2011 1
a2016 1

d2021 6
a2028 1

@


1.246
log
@Do not make the colon after the .Lk link text italic.
I just pushed the same change to GNU troff.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.245 2017/02/17 19:14:39 schwarze Exp $ */
d1994 1
d2010 6
d2019 3
@


1.245
log
@Use typographic quotes rather than '"' for .Rs %T (no change for -Tascii
output, of course).  Patch from bentley@@ in November 2014.  This can be
committed now because groff merged Anthony's patch yesterday.

Simply committing myself because asking Anthony to go search for
his two-year-old patch and have him discover that it had accumulated
an average of (felt) two or three conflicts per line by now would
have been mean, even if hilarious.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.244 2017/02/16 14:38:07 schwarze Exp $ */
d2004 1
a2006 1
		term_fontpop(p);
@


1.244
log
@Surprisingly, groff does not support scaling units in .Bl -column
column width specifiers, so stop supporting them, too.
As a side effect, this fixes an assertion failure that tb@@ found
with afl(1), triggered by: .Bl -column -4n
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.243 2017/02/16 02:59:42 schwarze Exp $ */
d1715 2
a1730 1
	case MDOC__T:
d1773 2
a1790 1
	case MDOC__T:
@


1.243
log
@Remove the ENDBODY_NOSPACE flag, simplifying the code.

Comparing to groff output, it appears that all cases where it was used
and made a difference actually require the opposite, ENDBODY_SPACE.

I have no idea why i added it back in 2010; maybe to compensate for
some other bug that has long been fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.242 2017/02/06 03:41:44 schwarze Exp $ */
d607 1
d685 6
a690 3
		    nn = nn->prev, i++)
			offset += dcol + a2width(p,
			    bl->norm->Bl.cols[i]);
d705 3
a707 1
		width = a2width(p, bl->norm->Bl.cols[i]) + dcol;
@


1.242
log
@The .Nm macro does not only use the default name when it has no
argument, but also when the first argument is a child macro.
Arcane issue found in the FreeBSD cxgbetool(8) manual that Baptiste
Daroussin <bapt at FreeBSD> sent me long ago for a different reason.

While solving this, switch to the new technique of doing text
production in the validator, reducing code duplication in the
formatters, which also makes -Ttree output clearer.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.241 2017/02/04 11:56:48 schwarze Exp $ */
a395 8

		/*
		 * End of line terminating an implicit block
		 * while an explicit block is still open.
		 * Continue the explicit block without spacing.
		 */
		if (ENDBODY_NOSPACE == n->end)
			p->flags |= TERMP_NOSPACE;
@


1.241
log
@Do not fix the default indent for all subsequent files; some may use
a different macro language and hence require a different indent.
You can see the effect with "man -a 1 host hostname".
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.240 2017/01/11 17:39:45 schwarze Exp $ */
d997 1
a997 1
	if (NULL == n->child && NULL == meta->name)
a1020 2
	if (NULL == n->child)
		term_word(p, meta->name);
@


1.240
log
@Do text production for .Bt, .Ex, .Rv, .Ud at the validation stage
rather than in the formatters.  Use NODE_NOSRC flag for .Lb and
NODE_NOSRC and NODE_NOPRT for .St.  Results in a more rigorous
syntax tree and in 135 lines less code.

This work was triggered by a question from Abhinav Upadhyay <er dot
abhinav dot upadhyay at gmail dot com> (NetBSD) on discuss@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.239 2017/01/10 23:36:24 schwarze Exp $ */
d259 1
d280 1
d293 1
@


1.239
log
@Use new NODE_NOSRC and NODE_NOPRT flags for .Bx and .At.
More rigorous AST and 40 lines less code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.238 2017/01/10 21:54:34 schwarze Exp $ */
a91 1
static	int	  termp_bt_pre(DECL_ARGS);
a113 1
static	int	  termp_rv_pre(DECL_ARGS);
a121 1
static	int	  termp_ud_pre(DECL_ARGS);
d163 1
a163 1
	{ termp_rv_pre, NULL }, /* Rv */
d229 1
a229 1
	{ termp_bt_pre, NULL }, /* Bt */
d232 1
a232 1
	{ termp_ud_pre, NULL }, /* Ud */
a1110 52
termp_rv_pre(DECL_ARGS)
{
	struct roff_node *nch;

	term_newln(p);

	if (n->child != NULL) {
		term_word(p, "The");

		for (nch = n->child; nch != NULL; nch = nch->next) {
			term_fontpush(p, TERMFONT_BOLD);
			term_word(p, nch->string);
			term_fontpop(p);

			p->flags |= TERMP_NOSPACE;
			term_word(p, "()");

			if (nch->next == NULL)
				continue;

			if (nch->prev != NULL || nch->next->next != NULL) {
				p->flags |= TERMP_NOSPACE;
				term_word(p, ",");
			}
			if (nch->next->next == NULL)
				term_word(p, "and");
		}

		if (n->child != NULL && n->child->next != NULL)
			term_word(p, "functions return");
		else
			term_word(p, "function returns");

		term_word(p, "the value\\~0 if successful;");
	} else
		term_word(p, "Upon successful completion,"
		    " the value\\~0 is returned;");

	term_word(p, "otherwise the value\\~\\-1 is returned"
	    " and the global variable");

	term_fontpush(p, TERMFONT_UNDER);
	term_word(p, "errno");
	term_fontpop(p);

	term_word(p, "is set to indicate the error.");
	p->flags |= TERMP_SENTENCE;

	return 0;
}

static int
a1112 2
	struct roff_node *nch;

d1114 1
a1114 28
	term_word(p, "The");

	for (nch = n->child; nch != NULL; nch = nch->next) {
		term_fontpush(p, TERMFONT_BOLD);
		term_word(p, nch->string);
		term_fontpop(p);

		if (nch->next == NULL)
			continue;

		if (nch->prev != NULL || nch->next->next != NULL) {
			p->flags |= TERMP_NOSPACE;
			term_word(p, ",");
		}

		if (nch->next->next == NULL)
			term_word(p, "and");
	}

	if (n->child != NULL && n->child->next != NULL)
		term_word(p, "utilities exit\\~0");
	else
		term_word(p, "utility exits\\~0");

	term_word(p, "on success, and\\~>0 if an error occurs.");

	p->flags |= TERMP_SENTENCE;
	return 0;
a1314 9
static int
termp_bt_pre(DECL_ARGS)
{

	term_word(p, "is currently in beta test.");
	p->flags |= TERMP_SENTENCE;
	return 0;
}

a1320 9
}

static int
termp_ud_pre(DECL_ARGS)
{

	term_word(p, "currently under development.");
	p->flags |= TERMP_SENTENCE;
	return 0;
@


1.238
log
@For the .Ux/.Ox family of macros, do text production at the validation
stage rather than in each and every individual formatter, using the
new NODE_NOSRC flag.  More rigorous and also ten lines less code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.237 2017/01/10 13:46:53 schwarze Exp $ */
a92 1
static	int	  termp_bx_pre(DECL_ARGS);
d191 1
a191 1
	{ termp_bx_pre, NULL }, /* Bx */
a1649 23
}

static int
termp_bx_pre(DECL_ARGS)
{

	if (NULL != (n = n->child)) {
		term_word(p, n->string);
		p->flags |= TERMP_NOSPACE;
		term_word(p, "BSD");
	} else {
		term_word(p, "BSD");
		return 0;
	}

	if (NULL != (n = n->next)) {
		p->flags |= TERMP_NOSPACE;
		term_word(p, "-");
		p->flags |= TERMP_NOSPACE;
		term_word(p, n->string);
	}

	return 0;
@


1.237
log
@unify names of AST node flags; no change of cpp output
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.236 2017/01/10 12:54:27 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012-2016 Ingo Schwarze <schwarze@@openbsd.org>
d81 1
d191 1
a191 1
	{ termp_xx_pre, NULL }, /* Bsx */
d201 1
a201 1
	{ termp_xx_pre, NULL }, /* Fx */
d205 2
a206 2
	{ termp_xx_pre, NULL }, /* Nx */
	{ termp_xx_pre, NULL }, /* Ox */
d224 1
a224 1
	{ termp_xx_pre, NULL }, /* Ux */
d247 1
a247 1
	{ termp_xx_pre, NULL }, /* Dx */
d1679 4
a1682 2
	const char	*pp;
	int		 flags;
d1684 5
a1688 32
	pp = NULL;
	switch (n->tok) {
	case MDOC_Bsx:
		pp = "BSD/OS";
		break;
	case MDOC_Dx:
		pp = "DragonFly";
		break;
	case MDOC_Fx:
		pp = "FreeBSD";
		break;
	case MDOC_Nx:
		pp = "NetBSD";
		break;
	case MDOC_Ox:
		pp = "OpenBSD";
		break;
	case MDOC_Ux:
		pp = "UNIX";
		break;
	default:
		abort();
	}

	term_word(p, pp);
	if (n->child) {
		flags = p->flags;
		p->flags |= TERMP_KEEP;
		term_word(p, n->child->string);
		p->flags = flags;
	}
	return 0;
@


1.236
log
@Introduce flags NODE_NOSRC and NODE_NOPRT for AST nodes.
Use them to mark generated nodes and nodes that shall not produce output.
Let -Ttree output mode display these new flags.
Use NODE_NOSRC for .Ar, .Mt, and .Pa default arguments.
Use NODE_NOPRT for .Dd, .Dt, and .Os.

These will help to make handling of text production macros more rigorous.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.235 2016/11/08 16:37:42 schwarze Exp $ */
d320 1
a320 1
	n->flags &= ~MDOC_ENDED;
d331 1
a331 1
	if (p->flags & TERMP_KEEP && n->flags & MDOC_LINE) {
d343 1
a343 1
		if (' ' == *n->string && MDOC_LINE & n->flags)
d345 1
a345 1
		if (MDOC_DELIMC & n->flags)
d348 1
a348 1
		if (MDOC_DELIMO & n->flags)
d352 1
a352 1
		if ( ! (n->flags & MDOC_LINE))
d355 1
a355 1
		if (n->next != NULL && ! (n->next->flags & MDOC_LINE))
d385 1
a385 1
		if ( ! termacts[n->tok].post || MDOC_ENDED & n->flags)
d395 1
a395 1
			n->body->flags |= MDOC_ENDED;
d407 1
a407 1
	if (MDOC_EOS & n->flags)
d1052 1
a1052 1
	     n->next->flags & MDOC_LINE)))
d1097 1
a1097 1
	if ( ! (MDOC_LINE & n->flags))
d1263 1
a1263 1
	if (NULL == n->prev || ! (MDOC_SYNPRETTY & n->flags))
d1412 1
a1412 1
	if (SEC_LIBRARY == n->sec && MDOC_LINE & n->flags)
d1440 1
a1440 1
	/* NB: MDOC_LINE does not effect this! */
d1452 1
a1452 1
	pretty = MDOC_SYNPRETTY & n->flags;
d1618 1
a1618 1
		    (nn->next && ! (nn->next->flags & MDOC_LINE)))
d1719 1
a1719 1
	if ( ! (n->next == NULL || n->next->flags & MDOC_LINE))
d1774 1
a1774 1
	if (MDOC_SYNPRETTY & n->flags && MDOC_LINE & n->flags) {
d1791 1
a1791 1
	if (MDOC_SYNPRETTY & n->flags)
d1797 1
a1797 1
	if (MDOC_SYNPRETTY & n->flags)
d2004 1
a2004 1
	pretty = MDOC_SYNPRETTY & n->flags;
d2050 1
a2050 1
	if (MDOC_SYNPRETTY & n->flags) {
@


1.235
log
@use .Fn in custom sections for tagging, in addition to in DESCRIPTION;
written on the TGV Paris-Strassbourg
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.234 2016/11/08 16:29:19 schwarze Exp $ */
d286 2
d314 3
d570 2
d1726 1
d1731 4
a1734 1
		if (n->prev)
@


1.234
log
@tag leading .Dv, .Li, and .No in .It;
written on the TGV Paris-Strassbourg
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.233 2016/11/08 16:23:37 schwarze Exp $ */
d1463 1
a1463 1
	if (n->sec == SEC_DESCRIPTION)
@


1.233
log
@implement tag priority 0, which will tag only keys that appear as
tag candidates exactly once, and use it for .Em and .Sy;
written on the TGV Toulouse-Paris
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.232 2016/11/08 16:04:40 schwarze Exp $ */
d2123 1
@


1.232
log
@generate two tag entries from list entries of the form
.It Macro tag1 ... | Macro tag2 ...
written on the TGV Toulouse-Paris
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.231 2016/10/09 18:16:46 schwarze Exp $ */
d96 1
d121 1
d198 1
a198 1
	{ termp_under_pre, NULL }, /* Em */
d221 1
a221 1
	{ termp_bold_pre, NULL }, /* Sy */
d2217 20
@


1.231
log
@Delete complicated code dealing with .Bl -tag without -width,
and just let it default to -width 6n, which agrees with the
traditional -width Ds that is still in widespread use.

I just pushed a patch upstream to GNU roff that does the same for
groff_mdoc(7).  Before, groff contained code that was even more
complicated than mandoc, but both resulted in quite different
user-visible output.  Now, both agree, and output is nicer for both.

Useless complication noticed by Carsten Kunze (Heirloom roff).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.230 2016/01/08 17:48:04 schwarze Exp $ */
d2236 3
a2238 1
	    n->prev == NULL &&
@


1.230
log
@Delete the redundant "nchild" member of struct roff_node, replacing
most uses by one, a few by two pointer checks, and only one by a
tiny loop - not only making data smaller, but code shorter as well.

This gets rid of an implicit invariant that confused both static
analysis tools and human auditors.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.229 2015/10/12 15:27:53 schwarze Exp $ */
d632 1
a635 1
	case LIST_tag:
@


1.229
log
@Use "-" rather than "\(hy" for the heads of .Bl -dash and -hyphen lists.
In UTF-8 output, that renders as ASCII HYPHEN-MINUS (U+002D)
rather than HYPHEN (U+2010), which looks better and matches groff.
In ASCII output, it makes no difference.
Suggested by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.228 2015/10/12 00:07:27 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012-2015 Ingo Schwarze <schwarze@@openbsd.org>
d358 1
a358 1
		    (n->end == ENDBODY_NOT || n->nchild))
d599 1
a599 1
	term_setwidth(p, n->nchild ? n->child->string : NULL);
d732 1
a732 1
		if (n->type == ROFFT_BODY && n->parent->head->nchild)
d1040 1
a1040 1
	if ( ! (n->nchild == 0 &&
d1107 1
a1107 1
	int		 nchild;
d1111 1
a1111 2
	nchild = n->nchild;
	if (nchild > 0) {
d1114 1
a1114 1
		for (n = n->child; n; n = n->next) {
d1116 1
a1116 1
			term_word(p, n->string);
d1122 1
a1122 1
			if (n->next == NULL)
d1125 1
a1125 1
			if (nchild > 2) {
d1129 1
a1129 1
			if (n->next->next == NULL)
d1133 1
a1133 1
		if (nchild > 1)
d1159 1
a1159 1
	int		 nchild;
d1164 1
a1164 2
	nchild = n->nchild;
	for (n = n->child; n; n = n->next) {
d1166 1
a1166 1
		term_word(p, n->string);
d1169 4
a1172 1
		if (nchild > 2 && n->next) {
d1177 1
a1177 1
		if (n->next && NULL == n->next->next)
d1181 1
a1181 1
	if (nchild > 1)
d1840 1
a1840 1
		term_word(p, n->nchild == 1 &&
d1897 1
a1897 1
		term_word(p, n->nchild == 1 &&
d2161 1
a2161 1
		if (n->parent->args || 0 == n->prev->nchild)
@


1.228
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.227 2015/10/06 18:30:44 schwarze Exp $ */
d888 1
a888 1
			term_word(p, "\\(hy");
@


1.227
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.226 2015/09/26 00:53:15 schwarze Exp $ */
a625 1
		/* FALLTHROUGH */
a626 1
		/* FALLTHROUGH */
a627 1
		/* FALLTHROUGH */
a634 1
		/* FALLTHROUGH */
d759 3
a765 6
		/* FALLTHROUGH */
	case LIST_bullet:
		/* FALLTHROUGH */
	case LIST_dash:
		/* FALLTHROUGH */
	case LIST_hyphen:
a847 1
		/* FALLTHROUGH */
a848 1
		/* FALLTHROUGH */
a849 1
		/* FALLTHROUGH */
a850 1
		/* FALLTHROUGH */
a885 1
			/* FALLTHROUGH */
a906 1
		/* FALLTHROUGH */
a907 1
		/* FALLTHROUGH */
a908 1
		/* FALLTHROUGH */
a909 1
		/* FALLTHROUGH */
a936 1
		/* FALLTHROUGH */
a937 1
		/* FALLTHROUGH */
a1275 1
		/* FALLTHROUGH */
a1276 1
		/* FALLTHROUGH */
a1277 1
		/* FALLTHROUGH */
a1278 1
		/* FALLTHROUGH */
a1595 1
			/* FALLTHROUGH */
a1596 1
			/* FALLTHROUGH */
a1597 1
			/* FALLTHROUGH */
a1598 1
			/* FALLTHROUGH */
a1599 1
			/* FALLTHROUGH */
a1600 1
			/* FALLTHROUGH */
a1601 1
			/* FALLTHROUGH */
a1837 1
		/* FALLTHROUGH */
a1842 1
		/* FALLTHROUGH */
a1846 1
		/* FALLTHROUGH */
a1847 1
		/* FALLTHROUGH */
a1848 1
		/* FALLTHROUGH */
a1852 1
		/* FALLTHROUGH */
a1862 1
		/* FALLTHROUGH */
a1866 1
		/* FALLTHROUGH */
a1867 1
		/* FALLTHROUGH */
a1871 1
		/* FALLTHROUGH */
a1872 1
		/* FALLTHROUGH */
a1894 1
		/* FALLTHROUGH */
a1899 1
		/* FALLTHROUGH */
a1903 1
		/* FALLTHROUGH */
a1904 1
		/* FALLTHROUGH */
a1905 1
		/* FALLTHROUGH */
a1909 1
		/* FALLTHROUGH */
a1921 1
		/* FALLTHROUGH */
a1925 1
		/* FALLTHROUGH */
a1926 1
		/* FALLTHROUGH */
a1930 1
		/* FALLTHROUGH */
a1931 1
		/* FALLTHROUGH */
@


1.226
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.225 2015/09/21 13:24:32 schwarze Exp $ */
d536 1
a536 1
	return(term_hspan(p, &su) / 24);
d600 1
a600 1
	return(0);
d614 1
a614 1
		return(1);
d928 1
a928 1
			return(0);
d932 1
a932 1
			return(0);
d938 1
a938 1
	return(1);
d987 1
a987 1
		return(1);
d992 1
a992 1
			return(0);
d1003 1
a1003 1
		return(1);
d1007 1
a1007 1
		return(0);
d1032 1
a1032 1
	return(1);
d1064 1
a1064 1
	return(1);
d1075 1
a1075 1
	return(1);
d1085 1
a1085 1
		return(0);
d1090 1
a1090 1
		return(0);
d1099 1
a1099 1
	return(1);
d1108 1
a1108 1
	return(1);
d1116 1
a1116 1
		return(1);
d1119 1
a1119 1
	return(1);
d1172 1
a1172 1
	return(0);
d1206 1
a1206 1
	return(0);
d1215 1
a1215 1
	return(1);
d1222 1
a1222 1
	return(n->type != ROFFT_HEAD);
d1238 1
a1238 1
		return(0);
d1244 1
a1244 1
		return(0);
d1256 1
a1256 1
	return(0);
d1322 1
a1322 1
		return(termp_under_pre(p, pair, meta, n));
d1325 1
a1325 1
		return(1);
d1327 1
a1327 1
		return(0);
d1329 1
a1329 1
	return(termp_under_pre(p, pair, meta, n));
d1338 1
a1338 1
	return(1);
d1346 1
a1346 1
	return(termp_bold_pre(p, pair, meta, n));
d1391 1
a1391 1
	return(1);
d1417 1
a1417 1
	return(0);
d1434 1
a1434 1
	return(0);
d1442 1
a1442 1
		return(1);
d1445 1
a1445 1
	return(1);
d1455 1
a1455 1
	return(1);
d1469 1
a1469 1
		return(0);
d1519 1
a1519 1
	return(0);
d1529 1
a1529 1
		return(1);
d1544 1
a1544 1
	return(0);
d1556 1
a1556 1
		return(1);
d1558 1
a1558 1
		return(0);
d1588 1
a1588 1
		return(1);
d1646 1
a1646 1
	return(0);
d1681 1
a1681 1
		return(0);
d1691 1
a1691 1
	return(0);
d1731 1
a1731 1
	return(0);
d1763 1
a1763 1
	return(1);
d1780 1
a1780 1
	return(1);
d1799 1
a1799 1
	return(1);
d1848 1
a1848 1
	return(0);
d1855 1
a1855 1
	return(0);
d1863 1
a1863 1
		return(1);
d1894 1
a1894 1
			return(1);
d1921 1
a1921 1
	return(1);
d1996 1
a1996 1
		return(1);
d2008 1
a2008 1
	return(1);
d2045 1
a2045 1
		return(1);
d2063 1
a2063 1
		return(1);
d2067 1
a2067 1
		return(0);
d2074 1
a2074 1
	return(0);
d2099 1
a2099 1
		return(0);
d2101 1
a2101 1
		return(1);
d2110 1
a2110 1
	return(1);
d2127 1
a2127 1
	return(0);
d2137 1
a2137 1
	return(1);
d2172 1
a2172 1
	return(1);
d2181 1
a2181 1
		return(0);
d2198 1
a2198 1
	return(0);
d2209 1
a2209 1
		return(0);
d2218 1
a2218 1
	return(1);
d2254 1
a2254 1
		return(termp_quote_pre(p, pair, meta, n));
d2257 1
a2257 1
	return(1);
d2265 1
a2265 1
	return(1);
d2277 1
a2277 1
	return(1);
d2292 1
a2292 1
	return(1);
@


1.225
log
@Trailing whitespace is significant when determining the width of a tag
in mdoc(7) .Bl -tag and man(7) .TP, but not in man(7) .IP.
Quirk reported by Jan Stary <hans at stare dot cz> on ports@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.224 2015/09/14 12:57:30 schwarze Exp $ */
a1721 1
		/* NOTREACHED */
a1917 1
		/* NOTREACHED */
a1987 1
		/* NOTREACHED */
a2215 1
		/* NOTREACHED */
@


1.224
log
@The .Dv macro actually forces normal font.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.223 2015/07/25 14:28:40 schwarze Exp $ */
d803 1
a803 1
		p->flags |= TERMP_NOBREAK | TERMP_BRIND;
d975 1
a975 1
	p->flags &= ~(TERMP_NOBREAK | TERMP_BRIND |
@


1.223
log
@Simplify and make tag_put() more efficient by integrating tag_get()
into it and by only handling NUL-terminated strings.
Minus 25 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.222 2015/07/25 14:22:40 schwarze Exp $ */
d147 1
a147 1
	{ NULL, NULL }, /* Dv */
@


1.222
log
@implement tagging for .Er
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.221 2015/07/25 14:17:47 schwarze Exp $ */
d1482 2
a1483 4
	if (n->sec == SEC_DESCRIPTION) {
		if ( ! tag_get(n->string, 0, ++fn_prio))
			tag_put(n->string, 0, fn_prio, p->line);
	}
d2279 2
a2280 3
	      n->parent->parent->parent->tok == MDOC_It)) &&
	    ! tag_get(n->child->string, 0, 1))
		tag_put(n->child->string, 0, 1, p->line);
d2294 2
a2295 3
	      n->parent->parent->parent->tok == MDOC_It)) &&
	    ! tag_get(n->child->string, 0, 1))
		tag_put(n->child->string, 0, 1, p->line);
@


1.221
log
@basic tag support for function names; written at YYC
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.220 2015/07/25 14:01:39 schwarze Exp $ */
d96 1
d148 1
a148 1
	{ NULL, NULL }, /* Er */
d2271 13
@


1.220
log
@basic support for tag priorities; written at YYC
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.219 2015/07/17 22:35:36 schwarze Exp $ */
d252 1
d1366 1
a1366 1
		    MDOC_Sh != n->prev->tok ||
d1376 5
a1380 1
		if (SEC_AUTHORS == n->sec)
d1382 4
d1481 5
d1838 1
@


1.219
log
@Initial, still somewhat experimental implementation to leverage
less(1) -T and :t ctags(1)-like functionality to jump to the
definitions of various terms inside manual pages.
To be polished in the tree, so bear with me and report issues.

Technically, if less(1) is used as a pager, information is collected
by the mdoc(7) terminal formatter, first stored using the ohash
library, then ultimately written to a temporary file which is passed
to less via -T.  No change intended for other output formatters or
when running without a pager.

Based on an idea from Kristaps using feedback from many, in particular
phessler@@ nicm@@ millert@@ halex@@ doug@@ kspillner@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.218 2015/04/18 17:50:02 schwarze Exp $ */
d2269 2
a2270 2
	    ! tag_get(n->child->string, 0))
		tag_put(n->child->string, 0, p->line);
@


1.218
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.217 2015/04/18 16:04:40 schwarze Exp $ */
d35 1
d119 1
d148 1
a148 1
	{ NULL, NULL }, /* Ev */
d1052 1
d1334 1
d2255 16
@


1.217
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.216 2015/04/04 17:46:58 schwarze Exp $ */
a253 1
	const struct roff_meta	*meta;
a257 1

d262 1
a262 3
	n = mdoc_node(mdoc)->child;
	meta = mdoc_meta(mdoc);

d268 2
a269 1
					    meta, n->child->next->child);
d278 2
a279 1
		term_begin(p, print_mdoc_head, print_mdoc_foot, meta);
d283 1
a283 1
			print_mdoc_nodelist(p, NULL, meta, n);
@


1.216
log
@Rounding rules for horizontal scaling widths are more complicated.
There is a first rounding to basic units on the input side.
After that, rounding rules differ between requests and macros.
Requests round to the nearest possible character position.
Macros round to the next character position to the left.

Implement that by changing the return value of term_hspan()
to basic units and leaving the second scaling and rounding stage
to the formatters instead of doing it in the terminal handler.

Improves for example argtable2(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.215 2015/04/02 23:47:43 schwarze Exp $ */
d252 1
a252 1
terminal_mdoc(void *arg, const struct mdoc *mdoc)
@


1.215
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.214 2015/04/02 22:06:17 schwarze Exp $ */
d534 1
a534 1
	return(term_hspan(p, &su));
@


1.214
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.213 2015/04/02 21:03:18 schwarze Exp $ */
d44 1
a44 1
		  const struct mdoc_meta *meta, \
d59 2
a60 2
static	void	  print_mdoc_head(struct termp *, const void *);
static	void	  print_mdoc_foot(struct termp *, const void *);
d254 1
a254 1
	const struct mdoc_meta	*meta;
d408 1
a408 1
print_mdoc_foot(struct termp *p, const void *arg)
a409 1
	const struct mdoc_meta *meta;
a411 2
	meta = (const struct mdoc_meta *)arg;

d457 1
a457 1
print_mdoc_head(struct termp *p, const void *arg)
a458 1
	const struct mdoc_meta	*meta;
a460 2

	meta = (const struct mdoc_meta *)arg;
@


1.213
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.212 2015/03/09 17:41:36 schwarze Exp $ */
d45 1
a45 1
		  struct mdoc_node *n
d55 2
a56 2
			const struct mdoc_node *,
			const struct mdoc_node *);
d62 1
a62 1
			const struct mdoc_node *);
d255 1
a255 1
	struct mdoc_node	*n;
d550 2
a551 2
	const struct mdoc_node *bl,
	const struct mdoc_node *n)
d553 1
a553 1
	const struct mdoc_node	*nn;
d611 1
a611 1
	const struct mdoc_node *bl, *nn;
d1268 1
a1268 1
synopsis_pre(struct termp *p, const struct mdoc_node *n)
d1516 1
a1516 1
	const struct mdoc_node	*nn;
d1542 1
a1542 1
	struct mdoc_node	*nn;
d2171 1
a2171 1
	const struct mdoc_node *link, *descr;
@


1.212
log
@Fix vertical spacing at the beginning of tables.
man(7) always prints a blank line, mdoc(7) doesn't.
Problem in mdoc(7) reported by kristaps@@.
mdoc(7) part of the patch tested by kristaps@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.211 2015/03/09 17:37:45 schwarze Exp $ */
d11 1
a11 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d13 1
a13 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d29 1
d31 2
a32 1
#include "mandoc_aux.h"
a34 1
#include "mdoc.h"
d333 1
a333 1
	case MDOC_TEXT:
d342 1
a342 1
	case MDOC_EQN:
d349 1
a349 1
	case MDOC_TBL:
d369 1
a369 1
	case MDOC_TEXT:
d371 1
a371 1
	case MDOC_TBL:
d373 1
a373 1
	case MDOC_EQN:
d570 1
a570 1
			if (nn->type == MDOC_ROOT)
d572 1
a572 1
		} while (nn->type != MDOC_BLOCK);
d616 1
a616 1
	if (MDOC_BLOCK == n->type) {
d668 1
a668 1
		if (MDOC_HEAD == n->type)
d685 2
a686 2
		 * Calculate the offset by applying all prior MDOC_BODY,
		 * so we stop at the MDOC_HEAD (NULL == nn->prev).
d736 1
a736 1
		if (MDOC_BODY == n->type)
d740 1
a740 1
		if (MDOC_BODY == n->type && n->parent->head->nchild)
d751 1
a751 1
		if (MDOC_HEAD == n->type)
d779 1
a779 1
		if (MDOC_HEAD != n->type)
d785 1
a785 1
		if (MDOC_HEAD != n->type)
d804 1
a804 1
		if (MDOC_HEAD != n->type)
d814 1
a814 1
		if (MDOC_HEAD == n->type)
d827 1
a827 1
		if (MDOC_HEAD != n->type)
d851 1
a851 1
		if (MDOC_HEAD == n->type &&
d867 1
a867 1
		if (MDOC_HEAD == n->type)
d879 1
a879 1
		if (MDOC_HEAD == n->type)
d893 1
a893 1
	if (MDOC_HEAD == n->type)
d931 1
a931 1
		if (MDOC_HEAD == n->type)
d935 1
a935 1
		if (MDOC_HEAD == n->type)
d950 1
a950 1
	if (MDOC_BLOCK == n->type)
d961 1
a961 1
		if (MDOC_BODY == n->type)
d965 1
a965 1
		if (MDOC_BODY == n->type)
d989 1
a989 1
	if (MDOC_BLOCK == n->type) {
d994 1
a994 1
	if (MDOC_BODY == n->type) {
d1013 1
a1013 1
	if (MDOC_HEAD == n->type)
d1016 1
a1016 1
	if (MDOC_HEAD == n->type &&
d1023 1
a1023 1
		} else if (MDOC_TEXT == n->child->type) {
d1043 1
a1043 1
	if (MDOC_BLOCK == n->type) {
d1045 1
a1045 1
	} else if (MDOC_HEAD == n->type &&
d1050 1
a1050 1
	} else if (MDOC_BODY == n->type && n->child)
d1063 1
a1063 1
	     n->next->type == MDOC_TEXT ||
d1120 1
a1120 1
	if (MDOC_BLOCK == n->type && n->prev)
d1216 1
a1216 1
	if (n->type == MDOC_BODY)
d1225 1
a1225 1
	return(MDOC_HEAD != n->type);
d1232 1
a1232 1
	if (MDOC_BLOCK == n->type)
d1243 1
a1243 1
	assert(MDOC_TEXT == n->type);
d1253 1
a1253 1
	assert(MDOC_TEXT == n->type);
d1323 1
a1323 1
	if (MDOC_ELEM == n->type) {
d1326 1
a1326 1
	} else if (MDOC_BLOCK == n->type) {
d1329 1
a1329 1
	} else if (MDOC_HEAD == n->type)
d1363 1
a1363 1
	case MDOC_BLOCK:
d1374 1
a1374 1
	case MDOC_HEAD:
d1377 1
a1377 1
	case MDOC_BODY:
d1393 1
a1393 1
	case MDOC_HEAD:
d1396 1
a1396 1
	case MDOC_BODY:
d1435 1
a1435 1
	if (MDOC_BLOCK != n->type)
d1471 1
a1471 1
	assert(MDOC_TEXT == n->type);
d1488 1
a1488 1
		assert(MDOC_TEXT == n->type);
d1545 1
a1545 1
	if (MDOC_BLOCK == n->type) {
d1548 1
a1548 1
	} else if (MDOC_HEAD == n->type)
d1592 1
a1592 1
			if (MDOC_TEXT == nn->type) {
d1645 1
a1645 1
	if (MDOC_BODY != n->type)
d1739 1
a1739 1
	case MDOC_BLOCK:
d1744 1
a1744 1
	case MDOC_HEAD:
d1748 1
a1748 1
	case MDOC_BODY:
d1762 1
a1762 1
	if (n->type == MDOC_HEAD || n->type == MDOC_BODY)
d1853 1
a1853 1
	if (MDOC_BODY != n->type && MDOC_ELEM != n->type)
d1920 1
a1920 1
	if (n->type != MDOC_BODY && n->type != MDOC_ELEM)
d1988 1
a1988 1
	if (n->type != MDOC_BODY)
d2009 1
a2009 1
	if (n->type != MDOC_BODY)
d2036 1
a2036 1
	if (MDOC_BLOCK == n->type) {
d2039 1
a2039 1
	} else if (MDOC_BODY == n->type) {
d2074 1
a2074 1
	if (MDOC_BODY != n->type)
d2091 1
a2091 1
	if (MDOC_HEAD == n->type)
d2093 1
a2093 1
	else if (MDOC_BODY != n->type)
d2199 1
a2199 1
	case MDOC_BLOCK:
d2201 1
a2201 1
	case MDOC_HEAD:
d2203 1
a2203 1
	case MDOC_BODY:
d2219 1
a2219 1
	if (MDOC_BODY == n->type)
@


1.211
log
@In mdoc(7), don't mistreat negative .sp arguments as large positive ones.
Instead, use the same logic as for man(7).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.210 2015/02/17 20:33:44 schwarze Exp $ */
d349 2
@


1.210
log
@Render \(lq and \(rq as '"' in -Tascii mode but leave the rendering
of .Do/.Dc, .Dq, .Lb, and .St untouched.
Reduces groff-mandoc differences in base by about 7%.
Reminded of the issue by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.209 2015/02/12 12:20:47 schwarze Exp $ */
d1809 1
a1809 1
	size_t		 i, len;
d1830 5
a1834 2
	for (i = 0; i < len; i++)
		term_vspace(p);
@


1.209
log
@Delete the mdoc_node.pending pointer and the function calculating
it, make_pending(), which was the most difficult function of the
whole mdoc(7) parser.  After almost five years of maintaining this
hellhole, i just noticed the pointer isn't needed after all.

Blocks are always rewound in the reverse order they were opened;
that even holds for broken blocks.  Consequently, it is sufficient
to just mark broken blogs with the flag MDOC_BROKEN and breaking
blocks with the flag MDOC_ENDED.  When rewinding, instead of iterating
the pending pointers, just iterate from each broken block to its
parents, rewinding all that are MDOC_ENDED and stopping after
processing the first ancestor that it not MDOC_BROKEN.  For ENDBODY
markers, use the mdoc_node.body pointer in place of the former
mdoc_node.pending.

This also fixes an assertion failure found by jsg@@ with afl,
test case #467 (Bo Bl It Bd Bc It), where (surprise surprise)
the pending pointer got corrupted.

Improved functionality, minus one function, minus one struct field,
minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.208 2015/02/11 14:14:53 schwarze Exp $ */
d1874 1
a1874 1
		term_word(p, "\\(lq");
d1943 1
a1943 1
		term_word(p, "\\(rq");
@


1.208
log
@do not access a NULL pointer if an .Eo block lacks a tail;
found by jsg@@ with afl, test case #16
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.207 2015/02/05 01:46:38 schwarze Exp $ */
d310 1
d363 1
a363 1
	    (ENDBODY_NOT == n->end ? n : n->pending)->prev_font);
d383 1
a383 1
			n->pending->flags |= MDOC_ENDED;
@


1.207
log
@fix handling of empty .An macros
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.206 2015/02/05 00:13:34 schwarze Exp $ */
d1990 2
a1991 3
	     n->parent->head->child != NULL &&
	     (n->parent->body->child != NULL ||
	      n->parent->tail->child != NULL))
@


1.206
log
@Simplify by deleting the "lastline" member of struct mdoc_node.
Minus one struct member, minus 17 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.205 2015/02/01 23:10:15 schwarze Exp $ */
a1090 3

	if (n->child == NULL)
		return(0);
@


1.205
log
@fix .Eo/.Ec spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.204 2015/01/31 00:11:52 schwarze Exp $ */
d320 3
a322 6
	if (TERMP_KEEP & p->flags) {
		if (n->prev ? (n->prev->lastline != n->line) :
		    (n->parent && n->parent->line != n->line)) {
			p->flags &= ~TERMP_KEEP;
			p->flags |= TERMP_PREKEEP;
		}
@


1.204
log
@Use relative offsets instead of absolute pointers for the terminal
font stack.  The latter fail after the stack is grown with realloc().
Fixing an assertion failure found by jsg@@ with afl some time ago
(test case number 51).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.203 2015/01/30 22:04:15 schwarze Exp $ */
d68 1
d93 1
d193 1
a193 1
	{ termp_quote_pre, termp_quote_post }, /* Eo */
a1886 2
	case MDOC_Eo:
		break;
d1922 1
a1922 3
	if ( ! (n->tok == MDOC_En ||
	    (n->tok == MDOC_Eo && n->end == ENDBODY_SPACE)))
		p->flags |= TERMP_NOSPACE;
d1951 5
a1955 4
		if (NULL != n->norm->Es &&
		    NULL != n->norm->Es->child &&
		    NULL != n->norm->Es->child->next) {
			p->flags |= TERMP_NOSPACE;
a1956 3
		}
		break;
	case MDOC_Eo:
d1981 45
@


1.203
log
@Have pity on the poor stack.
Replace tail recursion by iteration when walking the syntax trees.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.202 2015/01/23 14:19:52 schwarze Exp $ */
d308 1
a308 1
	n->prev_font = term_fontq(p);
@


1.202
log
@Let .Aq/.Ao/.Ac print "<>" instead of the normal "\(la\(ra"
when the only child is .Mt, not when the preceding node is .An,
to improve robustness.  Triggered by a question from Svyatoslav
Mishyn <juef at openmailbox dot org> (Crux Linux).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.201 2014/12/24 23:31:59 schwarze Exp $ */
d292 4
a295 3
	print_mdoc_node(p, pair, meta, n);
	if (n->next)
		print_mdoc_nodelist(p, pair, meta, n->next);
@


1.201
log
@Support negative indentations for mdoc(7) displays and lists.
Not exactly recommended for use, rather for groff compatibility.
While here, introduce similar SHRT_MAX limits as in man(7),
fixing a few cases of infinite output found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.200 2014/12/23 13:48:15 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d1856 2
a1857 2
		term_word(p, n->parent->prev != NULL &&
		    n->parent->prev->tok == MDOC_An ?  "<" : "\\(la");
d1929 2
a1930 2
		term_word(p, n->parent->prev != NULL &&
		    n->parent->prev->tok == MDOC_An ?  ">" : "\\(ra");
@


1.200
log
@support negative horizontal widths in man(7);
minus twenty lines of code in spite of enhanced functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.199 2014/12/23 09:31:17 schwarze Exp $ */
d23 1
d51 1
a51 1
static	size_t	  a2width(const struct termp *, const char *);
d527 1
a527 1
static size_t
d535 1
a535 3
	} else if (su.scale < 0.0)
		su.scale = 0.0;

d606 1
d608 2
a609 3
	char			buf[24];
	int			i;
	size_t			width, offset, ncols, dcol;
d621 28
d654 1
a654 3
	width = offset = 0;

	if (bl->norm->Bl.offs)
d656 5
a714 1
		assert(bl->norm->Bl.width);
d716 4
a719 31
		break;
	}

	/*
	 * List-type can override the width in the case of fixed-head
	 * values (bullet, dash/hyphen, enum).  Tags need a non-zero
	 * offset.
	 */

	switch (type) {
	case LIST_bullet:
		/* FALLTHROUGH */
	case LIST_dash:
		/* FALLTHROUGH */
	case LIST_hyphen:
		/* FALLTHROUGH */
	case LIST_enum:
		if (width < term_len(p, 2))
			width = term_len(p, 2);
		break;
	case LIST_hang:
		if (0 == width)
			width = term_len(p, 8);
		break;
	case LIST_column:
		/* FALLTHROUGH */
	case LIST_tag:
		if (0 == width)
			width = term_len(p, 10);
		break;
	default:
d765 1
a765 1
		 * Very narrow enum lists actually hang.
a766 2
		if (width == term_len(p, 2))
			p->flags |= TERMP_HANG;
d773 2
a862 1
		assert(width);
d1542 1
d1559 7
a1565 2
	else
		p->offset += a2width(p, n->norm->Bd.offs);
@


1.199
log
@some scaling unit fixes:
- .sp with an invalid argument is .sp 1v, not .sp 0v
- in man(1), trailing garbage doesn't make scaling units invalid
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.198 2014/12/02 10:07:17 schwarze Exp $ */
d534 2
a535 1
	}
@


1.198
log
@Fix the implementation and documentation of \c (continue text input line).
In particular, make it work in no-fill mode, too.
Reminded by Carsten dot Kunze at arcor dot de (Heirloom roff).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.197 2014/11/30 05:28:00 schwarze Exp $ */
a50 1
static	size_t	  a2height(const struct termp *, const char *);
a526 13
a2height(const struct termp *p, const char *v)
{
	struct roffsu	 su;


	assert(v);
	if ( ! a2roffsu(v, &su, SCALE_VS))
		SCALE_VS_INIT(&su, atoi(v));

	return(term_vspan(p, &su));
}

static size_t
d531 1
a531 2
	assert(v);
	if ( ! a2roffsu(v, &su, SCALE_MAX)) {
d1802 1
d1807 6
a1812 1
		len = n->child ? a2height(p, n->child->string) : 1;
@


1.197
log
@Multiple fixes with respect to .Pf:
* The first argument of .Pf is not parsed.
* Normal delimiter handling does not apply to the first argument of .Pf.
* Warn if nothing follows a prefix (inspired by groff_mdoc(7)).
* In that case, do not suppress spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.196 2014/11/28 16:53:38 schwarze Exp $ */
d1633 2
a1634 1
		if (nn->next && nn->next->line == nn->line)
@


1.196
log
@mop up and #ifdef turd deraadt@@ stepped into
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.195 2014/11/28 16:02:23 schwarze Exp $ */
d1735 2
a1736 1
	p->flags |= TERMP_NOSPACE;
@


1.195
log
@Be more careful about meta->name.  For weird input, it can be NULL.
Fixing a NULL access jsg@@ found with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.194 2014/11/27 22:27:40 schwarze Exp $ */
d1228 2
a1229 8
	if (MDOC_BODY != n->type)
		return(1);

#if defined(__OpenBSD__) || defined(__linux__)
	term_word(p, "\\(en");
#else
	term_word(p, "\\(em");
#endif
@


1.194
log
@Multiple fixes with respect to .Eo:
1. Correctly parse stray .Ec without preceding .Eo,
avoiding an assertion violation found by jsg@@ with afl.
2. Correctly parse .Ec arguments when breaking another block.
3. Correct spacing around closing delimiter when breaking another block.
4. Sync some related formatting control from -Tascii to -Thtml.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.193 2014/11/27 16:20:27 schwarze Exp $ */
d996 1
d1007 9
a1015 6
		p->offset += term_len(p, 1) +
		    (NULL == n->prev->child ?
		     term_strlen(p, meta->name) :
		     MDOC_TEXT == n->prev->child->type ?
		     term_strlen(p, n->prev->child->string) :
		     term_len(p, 5));
@


1.193
log
@Fix the obsolete .Db (toggle debug mode) macro to ignore its arguments
and not trigger an assertion when there is more than one argument;
the latter found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.192 2014/11/25 03:04:32 schwarze Exp $ */
d351 2
a352 1
		if (termacts[n->tok].pre && ENDBODY_NOT == n->end)
d1919 1
a1919 1
	if (MDOC_BODY != n->type && MDOC_ELEM != n->type)
d1922 2
a1923 1
	if (MDOC_En != n->tok)
@


1.192
log
@Do not access a NULL pointer when a section has no body,
which can for example happen for .Sh Xo .Sh without .Xc.
Crash found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.191 2014/11/21 01:52:44 schwarze Exp $ */
a91 1
static	int	  termp_es_pre(DECL_ARGS);
d111 1
d184 1
a184 1
	{ NULL, NULL }, /* Db */
d236 1
a236 1
	{ termp_es_pre, NULL }, /* Es */
d1839 1
a1839 1
termp_es_pre(DECL_ARGS)
@


1.191
log
@We repeatedly observed assertion crashes in the low-level terminal
output handler because the high level terminal formatters could be
tricked into setting the left margin further to the right than the
right margin.  Today, jsg@@ found more of these with afl.

Change the internal interface between both levels, aiming for
simplicity and robustness of the code.  Treat both margins as
*independent* settings:  Now, termp.offset is the requested left
margin, and termp.rmargin is the available space.  Let the lower
level cope with that case of insufficient space.

Obviously, high level code that does centering or flush right
still has to do careful checks, so i did a full audit of margin
settings in the terminal formatters.

Fixes crashes caused by excessively long title or date strings in
the man(7) footer, operating system or date strings in the mdoc(7)
footer, volume strings in the man(7) or mdoc(7) header, and a few
cases related to some non-prologue macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.190 2014/11/19 21:59:19 schwarze Exp $ */
a1374 2
	/* No vspace between consecutive `Sh' calls. */

d1377 9
a1385 4
		if (n->prev && MDOC_Sh == n->prev->tok)
			if (NULL == n->prev->body->child)
				break;
		term_vspace(p);
@


1.190
log
@Let .Ao and .Aq render as "<>" after .An and as "\(la\(ra" elsewhere,
just like groff; minibug noticed by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.189 2014/11/17 06:44:35 schwarze Exp $ */
d406 1
d423 3
a425 2
	p->rmargin = (p->maxrmargin -
	    term_strlen(p, meta->date) + term_len(p, 1)) / 2;
d433 2
a434 1
	p->rmargin = p->maxrmargin - term_strlen(p, meta->os);
d496 1
a496 1
	    p->maxrmargin - vollen;
d877 1
a877 1
		else {
a878 3
			if (p->rmargin < p->offset)
				p->rmargin = p->offset;
		}
a1010 2
		if (p->rmargin < p->offset)
			p->rmargin = p->offset;
@


1.189
log
@Multiple fixes with respect to in-line macros:
* .No selects the default font; relevant e.g. in .Bf blocks
* no need to force empty .Li elements
* closing delimiters as leading macro arguments do not suppress space
* opening delimiters at the end of a macro line do not suppress space
* correctly handle delimiter spacing in -Tman
As a side effect, these fixes let mandoc warn about empty .No macros
as requested by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.188 2014/11/10 21:54:29 schwarze Exp $ */
d1855 2
a1856 1
		term_word(p, "<");
d1927 2
a1928 1
		term_word(p, ">");
@


1.188
log
@add required vertical spacing before lists that begin
at the beginning of the first item of an enclosing list
right at the beginning of a new section or subsection;
minibug reported by Steffen Nurpmeso <sdaoden at yandex dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.187 2014/10/30 20:05:33 schwarze Exp $ */
d194 1
a194 1
	{ NULL, NULL }, /* No */
@


1.187
log
@Major bugsquashing with respect to -offset and -width:
1. Support specifying the .Bd and .Bl -offset as a macro default width;
while here, simplify the code handling the same for .Bl -width.
2. Correct handling of .Bl -offset arguments:  unlike .Bd -offset, the
arguments "left", "indent", and "indent-two" have no special meaning.
3. Fix the scaling of string length -offset and -width arguments in -Thtml.
Triggered by an incomplete documentation patch from bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.186 2014/10/28 17:35:42 schwarze Exp $ */
d573 8
a580 4
	for (nn = n; nn; nn = nn->parent) {
		if (MDOC_BLOCK != nn->type)
			continue;
		if (MDOC_Ss == nn->tok)
d582 3
a584 5
		if (MDOC_Sh == nn->tok)
			return;
		if (NULL == nn->prev)
			continue;
		break;
@


1.186
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.185 2014/10/20 15:49:45 schwarze Exp $ */
a51 1
static	size_t	  a2offs(const struct termp *, const char *);
a549 21
static size_t
a2offs(const struct termp *p, const char *v)
{
	struct roffsu	 su;

	if ('\0' == *v)
		return(0);
	else if (0 == strcmp(v, "left"))
		return(0);
	else if (0 == strcmp(v, "indent"))
		return(term_len(p, p->defindent + 1));
	else if (0 == strcmp(v, "indent-two"))
		return(term_len(p, (p->defindent + 1) * 2));
	else if ( ! a2roffsu(v, &su, SCALE_MAX)) {
		SCALE_HS_INIT(&su, term_strlen(p, v));
		su.scale /= term_strlen(p, "0");
	}

	return(term_hspan(p, &su));
}

d638 1
a638 1
		offset = a2offs(p, bl->norm->Bl.offs);
d1560 11
a1570 2
	if (n->norm->Bd.offs)
		p->offset += a2offs(p, n->norm->Bd.offs);
@


1.185
log
@correct the spacing after in-line equations
that start at the beginning of an input line
but end before the end of an input line
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.184 2014/10/20 02:46:00 schwarze Exp $ */
a260 3

	if (NULL == p->symtab)
		p->symtab = mchars_alloc();
@


1.184
log
@correct spacing *after* inline equations (much simpler than expected)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.183 2014/10/20 02:31:44 schwarze Exp $ */
d348 1
a348 1
		if ( ! (n->flags & MDOC_LINE))
@


1.183
log
@correct spacing before inline equations
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.182 2014/10/13 22:00:42 schwarze Exp $ */
d348 2
@


1.182
log
@Properly scale string length measurements for PostScript and PDF output;
this doesn't change anything for ASCII and UTF-8.
Problem reported by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.181 2014/09/17 20:17:55 schwarze Exp $ */
d345 2
@


1.181
log
@simplify handling of .An -[no]split for terminal output:
delete one static function, one flag #define, and 25 lines of code;
no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_term.c,v 1.180 2014/09/03 05:17:08 schwarze Exp $ */
d542 1
a542 1
	if ( ! a2roffsu(v, &su, SCALE_MAX))
d544 2
d563 1
a563 1
	else if ( ! a2roffsu(v, &su, SCALE_MAX))
d565 2
@


1.180
log
@Implement the traditional -h option for man(1): show the SYNOPSIS only.
As usual, we get mandoc -h and apropos -h for free.
Try stuff like "apropos -h In=dirent" or "apropos -h Fa=timespec".

Only useful for terminal output, so -Tps, -Tpdf, -Thtml ignore -h for now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a65 1
static	void	  termp_an_post(DECL_ARGS);
d138 1
a138 1
	{ termp_an_pre, termp_an_post }, /* An */
d1106 10
a1115 2
	if (NULL == n->child)
		return(1);
d1117 2
a1118 8
	/*
	 * If not in the AUTHORS section, `An -split' will cause
	 * newlines to occur before the author name.  If in the AUTHORS
	 * section, by default, the first `An' invocation is nosplit,
	 * then all subsequent ones, regardless of whether interspersed
	 * with other macros/text, are split.  -split, in this case,
	 * will override the condition of the implied first -nosplit.
	 */
d1120 1
a1120 8
	if (n->sec == SEC_AUTHORS) {
		if ( ! (TERMP_ANPREC & p->flags)) {
			if (TERMP_SPLIT & p->flags)
				term_newln(p);
			return(1);
		}
		if (TERMP_NOSPLIT & p->flags)
			return(1);
a1121 2
		return(1);
	}
d1123 2
a1124 2
	if (TERMP_SPLIT & p->flags)
		term_newln(p);
a1126 20
}

static void
termp_an_post(DECL_ARGS)
{

	if (n->child) {
		if (SEC_AUTHORS == n->sec)
			p->flags |= TERMP_ANPREC;
		return;
	}

	if (AUTH_split == n->norm->An.auth) {
		p->flags &= ~TERMP_NOSPLIT;
		p->flags |= TERMP_SPLIT;
	} else if (AUTH_nosplit == n->norm->An.auth) {
		p->flags &= ~TERMP_SPLIT;
		p->flags |= TERMP_NOSPLIT;
	}

@


1.179
log
@Right after .Fl, a middle delimiter triggers an empty scope,
just like a closing delimiter.  This didn't work in groff-1.15,
but it now works in groff-1.22.

After being closed by delimiters, .Nm scopes do not reopen.

Do not suppress white space after .Fl if the next node is a text node
on the same input line; that can happen for middle delimiters.

Fixing an issue reported by jmc@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.178 2014/08/17 18:42:07 schwarze Exp $ */
a252 1
	const struct mdoc_node	*n;
d254 1
a258 3
	if (0 == p->defindent)
		p->defindent = 5;

d260 1
a260 1
	p->maxrmargin = p->defrmargin;
d266 1
a266 1
	n = mdoc_node(mdoc);
d269 21
a289 6
	term_begin(p, print_mdoc_head, print_mdoc_foot, meta);

	if (n->child) {
		if (MDOC_Sh != n->child->tok)
			term_vspace(p);
		print_mdoc_nodelist(p, NULL, meta, n->child);
a290 2

	term_end(p);
a472 3

	p->offset = 0;
	p->rmargin = p->maxrmargin;
@


1.178
log
@Segfault fixes from kristaps@@.
Note that .It and .Nm blocks without bodies cannot be generated by
valid mdoc(7) syntax but are a adequate representations of invalid
mdoc(7) constructs like Bl -hang It Bo Sh and Sh SYNOPSIS Nm Bo Sh.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.177 2014/08/08 16:17:09 schwarze Exp $ */
d1076 4
a1079 3
	if (n->child)
		p->flags |= TERMP_NOSPACE;
	else if (n->next && n->next->line == n->line)
@


1.177
log
@Bring the handling of defective prologues even closer to groff,
in particular relaxing the distinction between prologue and body
and further improving messages.
* The last .Dd wins and the last .Os wins, even in the body.
* The last .Dt before the first body macro wins.
* Missing title in .Dt defaults to UNTITLED.  Warn about it.
* Missing section in .Dt does not default to 1.  But warn about it.
* Do not warn multiple times about the same mdoc(7) prologue macro.
* Warn about missing .Os.
* Incomplete .TH defaults to empty strings.  Warn about it.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.176 2014/08/08 15:26:28 schwarze Exp $ */
d807 2
a808 1
		if (n->next->child &&
d864 3
a866 1
		if (MDOC_HEAD == n->type && n->next->child &&
d1031 2
a1032 1
	if (MDOC_HEAD == n->type && n->next->child) {
d1060 2
a1061 1
	} else if (MDOC_HEAD == n->type && n->next->child) {
@


1.176
log
@Get rid of the useless FATAL error "child violates parent syntax".
When finding items outside lists, simply skip them and throw an ERROR.
Handle subsections before the first section instead of bailing out.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.175 2014/08/08 15:10:15 schwarze Exp $ */
d475 5
a479 1
	mandoc_asprintf(&title, "%s(%s)", meta->title, meta->msec);
@


1.175
log
@Various improvements related to .Ex and .Rv:
* let .Nm fall back to the empty string, not to UNKNOWN
* never let .Rv copy an argument from .Nm
* avoid spurious \fR after empty .Nm in -Tman
* correct handling of .Ex and .Rv in -Tman
* correct the wording of the output for .Rv without arguments
* use non-breaking spaces in .Ex and .Rv output where required
* split MANDOCERR_NONAME into a warning for .Ex and an error for .Nm
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.174 2014/08/08 15:03:24 schwarze Exp $ */
d1769 3
d1783 1
a1783 1
	if (MDOC_HEAD == n->type)
@


1.174
log
@Partial implementation of .Bd -centered.

In groff, .Bd -centered operates in fill mode, which is relatively
hard to implement, while this implementation operates in non-fill
mode so far.  As long as you pay attention that your lines do not
overflow, it works.  To make sure that rendering is the same for
mandoc and groff, it is recommended to insert .br between lines
for now.  This implementation will need improvement later.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.173 2014/07/07 15:03:24 schwarze Exp $ */
a1165 1
	term_word(p, "The");
d1168 2
a1169 4
	for (n = n->child; n; n = n->next) {
		term_fontpush(p, TERMFONT_BOLD);
		term_word(p, n->string);
		term_fontpop(p);
d1171 4
a1174 2
		p->flags |= TERMP_NOSPACE;
		term_word(p, "()");
a1175 1
		if (nchild > 2 && n->next) {
d1177 11
a1187 1
			term_word(p, ",");
d1190 9
a1198 8
		if (n->next && NULL == n->next->next)
			term_word(p, "and");
	}

	if (nchild > 1)
		term_word(p, "functions return");
	else
		term_word(p, "function returns");
d1200 2
a1201 2
	term_word(p, "the value 0 if successful; otherwise the "
	    "value -1 is returned and the global variable");
d1237 1
a1237 1
		term_word(p, "utilities exit");
d1239 1
a1239 1
		term_word(p, "utility exits");
d1241 1
a1241 1
	term_word(p, "0 on success, and >0 if an error occurs.");
@


1.173
log
@no need to skip content before first section header
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.172 2014/07/03 23:23:45 schwarze Exp $ */
d1570 1
a1570 1
	size_t			 tabwidth, rm, rmax;
d1591 2
a1592 1
	    DISP_unfilled != n->norm->Bd.type)
d1599 1
d1605 9
@


1.172
log
@Fix formatting of empty .Bl -inset item heads.
Downgrade empty item heads from ERROR to WARNING.
Show the list type in the error message.
Choose better variable names for nodes in post_it().
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.171 2014/07/02 19:54:39 schwarze Exp $ */
d274 3
a276 1
	if (n->child)
d278 1
@


1.171
log
@When .Sm is called without an argument, groff toggles the spacing mode,
so let us do the same for compatibility.  Using this feature is of
course not recommended except in manual page obfuscation contests.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.170 2014/07/02 03:47:07 schwarze Exp $ */
d746 1
a746 1
		if (MDOC_BODY == n->type)
@


1.170
log
@Implement the obsolete macros .En .Es .Fr .Ot for backward compatibility,
since this is hardly more complicated than explicitly ignoring them
as we did in the past.  Of course, do not use them!
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.169 2014/04/23 16:07:06 schwarze Exp $ */
d2055 3
a2057 4
	assert(n->child && MDOC_TEXT == n->child->type);
	if (0 == strcmp("on", n->child->string)) {
		if (p->col)
			p->flags &= ~TERMP_NOSPACE;
d2059 1
a2059 1
	} else
d2061 3
@


1.169
log
@Audit strlcpy(3)/strlcat(3) usage.

* Repair three instances of silent truncation, use asprintf(3).
* Change two instances of strlen(3)+malloc(3)+strlcpy(3)+strlcat(3)+...
to use asprintf(3) instead to make them less error prone.
* Cast the return value of four instances where the destination
buffer is known to be large enough to (void).
* Completely remove three useless instances of strlcpy(3)/strlcat(3).
* Mark two places in -Thtml with XXX that can cause information loss
and crashes but are not easy to fix, requiring design changes of
some internal interfaces.
* The file mandocdb.c remains to be audited.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.168 2014/04/20 20:17:36 schwarze Exp $ */
d94 1
d158 1
a158 1
	{ NULL, NULL }, /* Ot */
d228 1
a228 1
	{ NULL, NULL }, /* Fr */
d238 2
a239 2
	{ NULL, NULL }, /* Es */ /* TODO */
	{ NULL, NULL }, /* En */ /* TODO */
d1829 7
d1867 6
d1910 2
a1911 1
	p->flags |= TERMP_NOSPACE;
d1937 8
@


1.168
log
@fix unchecked snprintf(3) in page header printing:
the length of the title is unknown, and speed doesn't matter here,
so use asprintf/free rather than a static buffer
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.167 2014/04/20 19:39:35 schwarze Exp $ */
a440 1
	char			 buf[BUFSIZ];
d442 2
a443 2
	char			*title;
	size_t			 buflen, titlen;
d464 6
a469 8
	strlcpy(buf, meta->vol, BUFSIZ);
	buflen = term_strlen(p, buf);

	if (meta->arch) {
		strlcat(buf, " (", BUFSIZ);
		strlcat(buf, meta->arch, BUFSIZ);
		strlcat(buf, ")", BUFSIZ);
	}
d477 3
a479 4
	p->rmargin = 2 * (titlen+1) + buflen < p->maxrmargin ?
	    (p->maxrmargin -
	     term_strlen(p, buf) + term_len(p, 1)) / 2 :
	    p->maxrmargin - buflen;
d486 1
a486 1
	p->rmargin = p->offset + buflen + titlen < p->maxrmargin ?
d489 1
a489 1
	term_word(p, buf);
d506 1
@


1.167
log
@make sure static buffers for snprintf(3) are large enough
and cast snprintf return value to (void) where they are
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.166 2014/04/20 16:44:44 schwarze Exp $ */
d29 1
d441 4
a444 3
	char		buf[BUFSIZ], title[BUFSIZ];
	size_t		buflen, titlen;
	const struct mdoc_meta *meta;
d474 1
a474 1
	snprintf(title, BUFSIZ, "%s(%s)", meta->title, meta->msec);
d509 1
@


1.166
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.165 2014/04/08 07:13:01 schwarze Exp $ */
d619 1
a619 1
	char			buf[7];
d915 1
a915 1
			snprintf(buf, sizeof(buf), "%d.",
@


1.165
log
@Add a new term_flushln() flag TERMP_BRIND (if break, then indent)
to control indentation of continuation lines in TERMP_NOBREAK mode.
In the past, this was always on; continue using it
for .Bl, .Nm, .Fn, .Fo, and .HP, but no longer for .IP and .TP.

I looked at this because sthen@@ reported the issue in a manual
of a Perl module from ports, but it affects base, too: This patch
reduces groff-mandoc differences in base by more than 15%.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.164 2014/04/08 04:40:29 schwarze Exp $ */
d41 1
a41 1
	  	  const struct mdoc_meta *meta, \
d56 1
a56 1
static	void  	  print_mdoc_node(DECL_ARGS);
d60 1
a60 1
static	void	  synopsis_pre(struct termp *, 
d127 2
a128 2
	{ termp_ss_pre, termp_ss_post }, /* Ss */ 
	{ termp_sp_pre, NULL }, /* Pp */ 
d136 1
a136 1
	{ termp_under_pre, NULL }, /* Ad */ 
d141 3
a143 3
	{ NULL, NULL }, /* Dv */ 
	{ NULL, NULL }, /* Er */ 
	{ NULL, NULL }, /* Ev */ 
d145 2
a146 2
	{ termp_fa_pre, NULL }, /* Fa */ 
	{ termp_fd_pre, termp_fd_post }, /* Fd */ 
d148 4
a151 4
	{ termp_fn_pre, NULL }, /* Fn */ 
	{ termp_ft_pre, NULL }, /* Ft */ 
	{ termp_bold_pre, NULL }, /* Ic */ 
	{ termp_in_pre, termp_in_post }, /* In */ 
d153 2
a154 2
	{ termp_nd_pre, NULL }, /* Nd */ 
	{ termp_nm_pre, termp_nm_post }, /* Nm */ 
d159 1
a159 1
	{ NULL, NULL }, /* St */ 
d179 1
a179 1
	{ termp_bf_pre, NULL }, /* Bf */ 
d190 1
a190 1
	{ termp_under_pre, NULL }, /* Em */ 
d218 2
a219 2
	{ termp_fo_pre, termp_fo_post }, /* Fo */ 
	{ NULL, NULL }, /* Fc */ 
d229 7
a235 7
	{ termp_sp_pre, NULL }, /* Lp */ 
	{ termp_lk_pre, NULL }, /* Lk */ 
	{ termp_under_pre, NULL }, /* Mt */ 
	{ termp_quote_pre, termp_quote_post }, /* Brq */ 
	{ termp_quote_pre, termp_quote_post }, /* Bro */ 
	{ NULL, NULL }, /* Brc */ 
	{ NULL, termp____post }, /* %C */ 
d238 2
a239 2
	{ termp_xx_pre, NULL }, /* Dx */ 
	{ NULL, termp____post }, /* %Q */ 
d241 3
a243 3
	{ termp_sp_pre, NULL }, /* sp */ 
	{ NULL, termp____post }, /* %U */ 
	{ NULL, NULL }, /* Ta */ 
a277 1

a286 2

/* ARGSUSED */
d321 1
a321 1
	case (MDOC_TEXT):
d330 1
a330 1
	case (MDOC_EQN):
d333 1
a333 1
	case (MDOC_TBL):
d350 1
a350 1
	case (MDOC_TEXT):
d352 1
a352 1
	case (MDOC_TBL):
d354 1
a354 1
	case (MDOC_EQN):
a387 1

d397 1
a397 1
	/* 
d408 2
a409 2
	p->rmargin = (p->maxrmargin - 
			term_strlen(p, meta->date) + term_len(p, 1)) / 2;
a436 1

a508 1

a521 1

a533 1

a552 1

d559 3
a561 3
print_bvspace(struct termp *p, 
		const struct mdoc_node *bl, 
		const struct mdoc_node *n)
a606 1
/* ARGSUSED */
a614 2

/* ARGSUSED */
d619 3
a621 3
	char		        buf[7];
	int		        i;
	size_t		        width, offset, ncols, dcol;
d632 1
a632 1
	/* 
d644 1
a644 1
	case (LIST_column):
d658 2
a659 4

		/* LINTED */
		dcol = ncols < 5 ? term_len(p, 4) : 
			ncols == 5 ? term_len(p, 3) : term_len(p, 1);
d666 5
a670 5
		for (i = 0, nn = n->prev; 
				nn->prev && i < (int)ncols; 
				nn = nn->prev, i++)
			offset += dcol + a2width
				(p, bl->norm->Bl.cols[i]);
d691 1
a691 1
		/* 
d701 1
a701 1
	/* 
d708 1
a708 1
	case (LIST_bullet):
d710 1
a710 1
	case (LIST_dash):
d712 1
a712 1
	case (LIST_hyphen):
d714 1
a714 1
	case (LIST_enum):
d718 1
a718 1
	case (LIST_hang):
d722 1
a722 1
	case (LIST_column):
d724 1
a724 1
	case (LIST_tag):
d732 1
a732 1
	/* 
d740 1
a740 1
	case (LIST_diag):
d744 2
a745 2
	case (LIST_inset):
		if (MDOC_BODY == n->type) 
d755 1
a755 1
	case (LIST_diag):
d771 1
a771 1
	case (LIST_enum):
d779 1
a779 1
	case (LIST_bullet):
d781 1
a781 1
	case (LIST_dash):
d783 1
a783 1
	case (LIST_hyphen):
d789 1
a789 1
	case (LIST_hang):
d799 3
a801 3
		if (n->next->child && 
				(MDOC_Bl == n->next->child->tok ||
				 MDOC_Bd == n->next->child->tok))
d807 1
a807 1
	case (LIST_tag):
d817 1
a817 1
	case (LIST_column):
d830 1
a830 1
	case (LIST_diag):
d840 1
a840 1
	/* 
d849 1
a849 1
	case (LIST_hang):
d856 2
a857 2
				(MDOC_Bl == n->next->child->tok || 
				 MDOC_Bd == n->next->child->tok))
d860 1
a860 1
	case (LIST_bullet):
d862 1
a862 1
	case (LIST_dash):
d864 1
a864 1
	case (LIST_enum):
d866 1
a866 1
	case (LIST_hyphen):
d868 1
a868 1
	case (LIST_tag):
d878 1
a878 1
	case (LIST_column):
d881 1
a881 1
		/* 
d894 1
a894 1
	/* 
d896 1
a896 1
	 * HEAD character (temporarily bold, in some cases).  
d901 1
a901 1
		case (LIST_bullet):
d906 1
a906 1
		case (LIST_dash):
d908 1
a908 1
		case (LIST_hyphen):
d913 1
a913 1
		case (LIST_enum):
d915 2
a916 2
			snprintf(buf, sizeof(buf), "%d.", 
					pair->ppair->ppair->count);
d923 1
a923 1
	/* 
d928 1
a928 1
	case (LIST_bullet):
d930 1
a930 1
	case (LIST_item):
d932 1
a932 1
	case (LIST_dash):
d934 1
a934 1
	case (LIST_hyphen):
d936 1
a936 1
	case (LIST_enum):
d940 1
a940 1
	case (LIST_column):
a950 2

/* ARGSUSED */
d962 1
a962 1
	case (LIST_item):
d964 1
a964 1
	case (LIST_diag):
d966 1
a966 1
	case (LIST_inset):
d970 1
a970 1
	case (LIST_column):
d979 1
a979 1
	/* 
a989 2

/* ARGSUSED */
a1041 2

/* ARGSUSED */
a1055 2
		
/* ARGSUSED */
a1070 2

/* ARGSUSED */
a1081 2

/* ARGSUSED */
d1097 1
a1097 1
	
a1115 2

/* ARGSUSED */
a1135 2

/* ARGSUSED */
a1144 2

/* ARGSUSED */
a1155 2

/* ARGSUSED */
d1187 2
a1188 2
       	term_word(p, "the value 0 if successful; otherwise the value "
			"-1 is returned and the global variable");
d1194 1
a1194 1
       	term_word(p, "is set to indicate the error.");
a1199 2

/* ARGSUSED */
d1228 1
a1228 1
       	term_word(p, "0 on success, and >0 if an error occurs.");
a1233 2

/* ARGSUSED */
a1248 2

/* ARGSUSED */
a1255 2

/* ARGSUSED */
a1263 1
/* ARGSUSED */
d1274 1
a1274 1
	if (NULL == (n = n->next)) 
d1298 1
a1298 1
	/* 
d1310 4
a1313 4
	if (n->prev->tok == n->tok && 
			MDOC_Ft != n->tok && 
			MDOC_Fo != n->tok && 
			MDOC_Fn != n->tok) {
d1324 1
a1324 1
	case (MDOC_Fd):
d1326 1
a1326 1
	case (MDOC_Fn):
d1328 1
a1328 1
	case (MDOC_Fo):
d1330 1
a1330 1
	case (MDOC_In):
d1332 1
a1332 1
	case (MDOC_Vt):
d1335 1
a1335 1
	case (MDOC_Ft):
a1346 1

a1362 2

/* ARGSUSED */
a1370 2

/* ARGSUSED */
a1378 2

/* ARGSUSED */
a1385 2

/* ARGSUSED */
d1393 1
a1393 1
	case (MDOC_BLOCK):
d1399 1
a1399 1
	case (MDOC_HEAD):
d1402 1
a1402 1
	case (MDOC_BODY):
a1412 2

/* ARGSUSED */
d1418 1
a1418 1
	case (MDOC_HEAD):
d1421 1
a1421 1
	case (MDOC_BODY):
a1429 2

/* ARGSUSED */
a1438 2

/* ARGSUSED */
a1446 2

/* ARGSUSED */
a1455 2

/* ARGSUSED */
a1466 2

/* ARGSUSED */
a1476 2

/* ARGSUSED */
a1537 2

/* ARGSUSED */
a1562 2

/* ARGSUSED */
d1585 3
a1587 3
	
	if (DISP_literal != n->norm->Bd.type && 
			DISP_unfilled != n->norm->Bd.type)
d1607 1
a1607 1
		case (MDOC_Sm):
d1609 1
a1609 1
		case (MDOC_br):
d1611 1
a1611 1
		case (MDOC_sp):
d1613 1
a1613 1
		case (MDOC_Bl):
d1615 1
a1615 1
		case (MDOC_D1):
d1617 1
a1617 1
		case (MDOC_Dl):
d1619 1
a1619 1
		case (MDOC_Lp):
d1621 1
a1621 1
		case (MDOC_Pp):
a1637 2

/* ARGSUSED */
d1643 1
a1643 1
	if (MDOC_BODY != n->type) 
d1649 2
a1650 2
	if (DISP_literal == n->norm->Bd.type || 
			DISP_unfilled == n->norm->Bd.type)
a1659 2

/* ARGSUSED */
a1682 2

/* ARGSUSED */
d1691 1
a1691 1
	case (MDOC_Bsx):
d1694 1
a1694 1
	case (MDOC_Dx):
d1697 1
a1697 1
	case (MDOC_Fx):
d1700 1
a1700 1
	case (MDOC_Nx):
d1703 1
a1703 1
	case (MDOC_Ox):
d1706 1
a1706 1
	case (MDOC_Ux):
a1723 2

/* ARGSUSED */
a1730 2

/* ARGSUSED */
d1736 1
a1736 1
	case (MDOC_BLOCK):
d1741 1
a1741 1
	case (MDOC_HEAD):
a1751 2

/* ARGSUSED */
a1759 2

/* ARGSUSED */
a1768 2

/* ARGSUSED */
a1787 2

/* ARGSUSED */
a1801 2

/* ARGSUSED */
d1808 1
a1808 1
	case (MDOC_sp):
d1811 1
a1811 1
	case (MDOC_br):
a1826 2

/* ARGSUSED */
d1835 1
a1835 1
	case (MDOC_Ao):
d1837 1
a1837 1
	case (MDOC_Aq):
d1840 1
a1840 1
	case (MDOC_Bro):
d1842 1
a1842 1
	case (MDOC_Brq):
d1845 1
a1845 1
	case (MDOC_Oo):
d1847 1
a1847 1
	case (MDOC_Op):
d1849 1
a1849 1
	case (MDOC_Bo):
d1851 1
a1851 1
	case (MDOC_Bq):
d1854 1
a1854 1
	case (MDOC_Do):
d1856 1
a1856 1
	case (MDOC_Dq):
d1859 1
a1859 1
	case (MDOC_Eo):
d1861 1
a1861 1
	case (MDOC_Po):
d1863 1
a1863 1
	case (MDOC_Pq):
d1866 1
a1866 1
	case (MDOC__T):
d1868 1
a1868 1
	case (MDOC_Qo):
d1870 1
a1870 1
	case (MDOC_Qq):
d1873 1
a1873 1
	case (MDOC_Ql):
d1875 1
a1875 1
	case (MDOC_So):
d1877 1
a1877 1
	case (MDOC_Sq):
a1888 2

/* ARGSUSED */
d1899 1
a1899 1
	case (MDOC_Ao):
d1901 1
a1901 1
	case (MDOC_Aq):
d1904 1
a1904 1
	case (MDOC_Bro):
d1906 1
a1906 1
	case (MDOC_Brq):
d1909 1
a1909 1
	case (MDOC_Oo):
d1911 1
a1911 1
	case (MDOC_Op):
d1913 1
a1913 1
	case (MDOC_Bo):
d1915 1
a1915 1
	case (MDOC_Bq):
d1918 1
a1918 1
	case (MDOC_Do):
d1920 1
a1920 1
	case (MDOC_Dq):
d1923 1
a1923 1
	case (MDOC_Eo):
d1925 1
a1925 1
	case (MDOC_Po):
d1927 1
a1927 1
	case (MDOC_Pq):
d1930 1
a1930 1
	case (MDOC__T):
d1932 1
a1932 1
	case (MDOC_Qo):
d1934 1
a1934 1
	case (MDOC_Qq):
d1937 1
a1937 1
	case (MDOC_Ql):
d1939 1
a1939 1
	case (MDOC_So):
d1941 1
a1941 1
	case (MDOC_Sq):
a1949 2

/* ARGSUSED */
a1991 2

/* ARGSUSED */
d1996 1
a1996 1
	if (MDOC_BODY != n->type) 
a2008 2

/* ARGSUSED */
d2018 1
a2018 1
	if (FONT_Em == n->norm->Bf.font) 
d2020 1
a2020 1
	else if (FONT_Sy == n->norm->Bf.font) 
d2022 1
a2022 1
	else 
a2027 2

/* ARGSUSED */
a2042 2

/* ARGSUSED */
a2052 2

/* ARGSUSED */
a2079 2

/* ARGSUSED */
a2087 2

/* ARGSUSED */
a2113 2

/* ARGSUSED */
d2119 1
a2119 1
	case (MDOC_BLOCK):
d2121 1
a2121 1
	case (MDOC_HEAD):
d2123 1
a2123 1
	case (MDOC_BODY):
a2134 2

/* ARGSUSED */
a2142 1
/* ARGSUSED */
d2152 1
a2152 1
			n->parent->norm->Rs.quote_T)
a2157 1
/* ARGSUSED */
d2167 1
a2167 1
			n->parent->norm->Rs.quote_T)
a2173 1
/* ARGSUSED */
@


1.164
log
@If the SYNOPSIS section contains an excessively long .Nm,
adjust the right margin to avoid running into an assertion;
output in that case now agrees with groff, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.163 2014/03/30 21:27:59 schwarze Exp $ */
d818 1
a818 1
		p->flags |= TERMP_NOBREAK | TERMP_HANG;
d825 1
a825 1
		p->flags |= TERMP_NOBREAK;
d847 1
a847 1
		p->flags |= TERMP_NOBREAK;
d1001 2
a1002 3
	p->flags &= ~TERMP_DANGLE;
	p->flags &= ~TERMP_NOBREAK;
	p->flags &= ~TERMP_HANG;
d1039 1
a1039 1
		p->flags |= TERMP_NOSPACE | TERMP_NOBREAK;
d1070 1
a1070 1
		p->flags &= ~(TERMP_NOBREAK | TERMP_HANG);
d1559 1
a1559 1
		p->flags |= TERMP_NOBREAK | TERMP_HANG;
d1569 1
a1569 1
		p->flags &= ~(TERMP_NOBREAK | TERMP_HANG);
d2061 2
a2062 1
			p->flags |= TERMP_NOBREAK | TERMP_HANG;
d2069 2
a2070 1
			p->flags &= ~(TERMP_NOBREAK | TERMP_HANG);
@


1.163
log
@Support relative arguments to .ll (increase or decrease line length).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.162 2014/03/30 19:47:32 schwarze Exp $ */
d1028 2
@


1.162
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.161 2014/02/16 12:30:51 schwarze Exp $ */
d621 1
a621 1
	(*p->setwidth)(p, n->nchild ? a2width(p, n->child->string) : 0);
@


1.161
log
@when indenting, extend the right margin accordingly, when needed;
fixes a crash reported by blambert@@ and a few other, similar ones
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.160 2013/12/25 21:24:03 schwarze Exp $ */
d103 1
d244 1
d385 4
a388 2
	p->offset = offset;
	p->rmargin = rmargin;
d613 10
@


1.160
log
@Oops, .Fa never breaks the output line in the middle of any of its
arguments, not even outside SYNOPSIS mode.  Quite surprising as .Fn
does break the line in the middle of its arguments outside SYNOPSIS
mode, and only doesn't do that in SYNOPSIS mode.  Wonders of groff...
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.159 2013/12/25 15:12:39 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d872 1
a872 1
		else 
d874 3
@


1.159
log
@Garbage collect two local variables each used only one single time.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.158 2013/12/25 14:40:29 schwarze Exp $ */
d1600 1
a1600 2
		if (MDOC_SYNPRETTY & n->flags)
			p->flags |= TERMP_NBRWORD;
@


1.158
log
@In the SYNOPSIS, implement hanging indentation for .Fo
and avoid output line breaks inside .Fa arguments.
This reduces groff-mandoc differences in base by more than 8%.
Patch from Franco Fichtner <franco at lastsummer dot de> (DragonFly).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.157 2013/12/25 00:39:13 schwarze Exp $ */
d1528 1
a1528 1
	size_t		 width, rmargin = 0;
a1538 1
		width = term_len(p, 4);
d1540 1
a1540 1
		p->rmargin = p->offset + width;
d2032 1
a2032 1
	size_t		 width, rmargin = 0;
a2041 1
			width = term_len(p, 4);
d2043 1
a2043 1
			p->rmargin = p->offset + width;
@


1.157
log
@Do not break output lines in .Fn function arguments in SYNOPSIS mode.
Following an idea from Franco Fichtner, but implemented more cleanly.
This reduces groff-mandoc-differences in base by a fantastic 7.5%.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.156 2013/12/24 23:04:29 schwarze Exp $ */
d5 1
d1601 2
d1606 1
a1606 1
		if (nn->next) {
a1611 5
	if (n->child && n->next && n->next->tok == MDOC_Fa) {
		p->flags |= TERMP_NOSPACE;
		term_word(p, ",");
	}

d2033 4
d2042 6
d2051 6
d2058 1
a2058 1
	} 
d2086 1
@


1.156
log
@Delete the unused flag TERMP_IGNDELIM
and the empty callback termp_igndelim_pre().
Sort the remaining termp flags.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.155 2013/12/24 20:45:21 schwarze Exp $ */
d1563 2
@


1.155
log
@It turns out SYNOPSIS mode does not imply .Bk in general,
but only within .Nm blocks.  Simplify the code accordingly.
This reduces groff-mandoc differences in base by about 2%.

Triggered by research done by Franco Fichtner.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.154 2013/12/24 19:10:34 schwarze Exp $ */
a98 1
static	int	  termp_igndelim_pre(DECL_ARGS);
d192 1
a192 1
	{ termp_igndelim_pre, NULL }, /* No */
d197 1
a197 1
	{ termp_igndelim_pre, termp_pf_post }, /* Pf */
a1781 10
}


/* ARGSUSED */
static int
termp_igndelim_pre(DECL_ARGS)
{

	p->flags |= TERMP_IGNDELIM;
	return(1);
@


1.154
log
@When deciding whether two consecutive macros are on the same input line,
we have to compare the line where the first one *ends* (not where it begins)
to the line where the second one starts.
This fixes the bug that .Bk allowed output line breaks right after block
macros spanning more than one input line, even when the next macro follows
on the same line.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.153 2013/12/23 02:19:57 schwarze Exp $ */
a305 3
	 *
	 * Also let SYNPRETTY sections behave as if they were wrapped
	 * in a `Bk' block.
d308 1
a308 1
	if (TERMP_KEEP & p->flags || MDOC_SYNPRETTY & n->flags) {
a316 10
	 * Since SYNPRETTY sections aren't "turned off" with `Ek',
	 * we have to intuit whether we should disable formatting.
	 */

	if ( ! (MDOC_SYNPRETTY & n->flags) &&
	    ((n->prev   && MDOC_SYNPRETTY & n->prev->flags) ||
	     (n->parent && MDOC_SYNPRETTY & n->parent->flags)))
		p->flags &= ~(TERMP_KEEP | TERMP_PREKEEP);

	/*
d996 2
a997 1
	if (MDOC_BLOCK == n->type)
d999 1
d1048 3
a1050 1
	if (MDOC_HEAD == n->type && n->next->child) {
d2230 1
a2230 1
	if (MDOC_BODY == n->type && ! (MDOC_SYNPRETTY & n->flags))
@


1.153
log
@Implement a long-standing desideratum,
hanging indentation for .Fn in SYNOPSIS mode,
exploiting the new trailspace feature
by deliberately *NOT* using it.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.152 2013/12/22 23:33:52 schwarze Exp $ */
d312 1
a312 1
		if (n->prev ? (n->prev->line != n->line) :
@


1.152
log
@Polishing the worms in my favourite can, term_flushln().

The TERMP_TWOSPACE flag i introduced in August 2009 was idiosyncratic
and served only a very narrow purpose.  Replace it by a more intuitive
and more general termp attribute "trailspace", to be used together
with TERMP_NOBREAK, to request a minimum amount of whitespace at
the end of the current column.  Adapt all code to the new interface.

No functional change intended;
code reviews to confirm that are welcome *eg*.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.151 2013/06/02 18:16:51 schwarze Exp $ */
d1537 1
d1547 7
d1559 7
d1588 1
@


1.151
log
@Let .Do .Dq .Ql .So .Sq generate the correct roff(7) character escape
sequences such that output modes like -Tutf8 have a chance to select
nice glyphs.  This doesn't change anything for -Tascii, and, for now,
it doesn't affect -Tps and -Tpdf either.
OK matthew@@ bentley@@; like the idea tedu@@; no opinion jmc@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.150 2013/05/29 16:11:32 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d423 1
d438 1
d490 1
d509 1
d797 4
a800 2
		if (MDOC_HEAD == n->type)
			p->flags |= TERMP_NOBREAK;
d803 1
a803 3
		if (MDOC_HEAD == n->type)
			p->flags |= TERMP_NOBREAK;
		else
d815 4
a818 3
			p->flags &= ~TERMP_NOBREAK;
		else
			p->flags |= TERMP_HANG;
a820 3
		if (MDOC_HEAD == n->type)
			p->flags |= TERMP_NOBREAK | TERMP_TWOSPACE;

d823 4
d834 1
a834 1
		if (NULL == n->next)
d836 2
a837 1
		else
d839 2
d844 4
a847 2
		if (MDOC_HEAD == n->type)
			p->flags |= TERMP_NOBREAK;
a998 1
	p->flags &= ~TERMP_TWOSPACE;
d1000 1
d1033 1
d1062 1
@


1.150
log
@Simplify condition, avoid duplicate code; no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.149 2013/05/29 15:40:14 schwarze Exp $ */
d1924 1
a1924 1
		term_word(p, "``");
d1945 1
a1945 1
		term_word(p, "`");
d1990 1
a1990 1
		term_word(p, "''");
d2011 1
a2011 1
		term_word(p, "'");
@


1.149
log
@In SYNOPSIS mode, .Ek doesn't end a keep.
Found and fixed on the plane to the OpenBSD t2k13 hackathon in Toronto.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.148 2013/05/18 17:47:17 schwarze Exp $ */
d312 2
a313 1
		if (n->prev && n->prev->line != n->line) {
a315 5
		} else if (NULL == n->prev) {
			if (n->parent && n->parent->line != n->line) {
				p->flags &= ~TERMP_KEEP;
				p->flags |= TERMP_PREKEEP;
			}
@


1.148
log
@Should termp_xx_pre() ever get called for a macro it cannot handle,
use abort(3), just like in the three other comparable cases in this file,
instead of ignoring the problem and causing a null pointer access.
Cosmetical issue reported by Ulrich Spoerlein <uqs@@spoerlein.net>
found by Coverity Scan CID 976115.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.147 2012/11/17 00:25:20 schwarze Exp $ */
d2214 1
a2214 1
	if (MDOC_BODY == n->type)
@


1.147
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.146 2012/11/16 17:16:29 schwarze Exp $ */
d1755 2
a1756 1
		break;
@


1.146
log
@Improve formatting of badly nested font blocks.
The basic idea is to already pop the font at the end marker
instead of allowing it to linger until the final end of the block.

This requires a few preliminaries:
* For each block, save a pointer to the previous font
  to be used in case the block breaks another and gets extended.
* That requires making node information writable during rendering.
* Now fonts may get popped in the wrong order; hence, after the stack
  has already been rewound further by some block that began earlier,
  ignore popping a font that was put on the stack later.
* To be able to exploit all this for font blocks, tie processing
  to their body, not their block, which is more logical anyway.

Triggered by florian@@ reporting vaguely similar issues with list blocks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.145 2012/07/11 16:55:29 schwarze Exp $ */
d40 1
a40 1
	  	  const struct mdoc_meta *m, \
d250 1
a250 1
	const struct mdoc_meta	*m;
d266 1
a266 1
	m = mdoc_meta(mdoc);
d268 1
a268 1
	term_begin(p, print_mdoc_head, print_mdoc_foot, m);
d271 1
a271 1
		print_mdoc_nodelist(p, NULL, m, n->child);
d281 1
a281 1
	print_mdoc_node(p, pair, m, n);
d283 1
a283 1
		print_mdoc_nodelist(p, pair, m, n->next);
d357 1
a357 1
				(p, &npair, m, n);
d362 1
a362 1
		print_mdoc_nodelist(p, &npair, m, n->child);
d377 1
a377 1
		(void)(*termacts[n->tok].post)(p, &npair, m, n);
d408 1
a408 1
	const struct mdoc_meta *m;
d410 1
a410 1
	m = (const struct mdoc_meta *)arg;
d426 1
a426 1
			term_strlen(p, m->date) + term_len(p, 1)) / 2;
d429 1
a429 1
	term_word(p, m->os);
d433 1
a433 1
	p->rmargin = p->maxrmargin - term_strlen(p, m->os);
d436 1
a436 1
	term_word(p, m->date);
d444 1
a444 1
	term_word(p, m->os);
d458 1
a458 1
	const struct mdoc_meta *m;
d460 1
a460 1
	m = (const struct mdoc_meta *)arg;
d478 2
a479 2
	assert(m->vol);
	strlcpy(buf, m->vol, BUFSIZ);
d482 1
a482 1
	if (m->arch) {
d484 1
a484 1
		strlcat(buf, m->arch, BUFSIZ);
d488 1
a488 1
	snprintf(title, BUFSIZ, "%s(%s)", m->title, m->msec);
d1010 2
a1011 1
		    (NULL == n->prev->child ? term_strlen(p, m->name) :
d1013 1
a1013 1
			term_strlen(p, n->prev->child->string) :
d1018 1
a1018 1
	if (NULL == n->child && NULL == m->name)
d1028 1
a1028 1
			p->rmargin += term_strlen(p, m->name);
d1041 1
a1041 1
		term_word(p, m->name);
d1379 1
a1379 1
		return(termp_under_pre(p, pair, m, n));
d1386 1
a1386 1
	return(termp_under_pre(p, pair, m, n));
d1406 1
a1406 1
	return(termp_bold_pre(p, pair, m, n));
d1638 1
a1638 1
		print_mdoc_node(p, pair, m, nn);
d2228 1
a2228 1
		termp_quote_post(p, pair, m, n);
d2230 1
a2230 1
	termp____post(p, pair, m, n);
d2244 1
a2244 1
		return(termp_quote_pre(p, pair, m, n));
@


1.145
log
@fix position and formatting of %U
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.144 2012/07/10 14:35:57 schwarze Exp $ */
d41 1
a41 1
		  const struct mdoc_node *n
a291 1
	const void	*font;
d298 1
a298 1
	font = term_fontq(p);
d364 2
a365 1
	term_fontpopq(p, font);
d1605 1
a1605 1
	const struct mdoc_node	*nn;
d2074 1
a2074 1
	else if (MDOC_BLOCK != n->type)
@


1.144
log
@* implement -Tman .Bl -item -inset -diag -ohang -dash -hyphen -enum .It
* fix -Tman .Bl -bullet .It
* adjust the -Tascii .Bl -bullet -dash -hyphen .It
default and minimum width to new groff standards,
it changed from 4n (in groff 1.15) to 2n (in groff 1.21)
* same for -Tascii -enum, it changed from 5n to 2n
* use -hang formatting for -Tascii -enum -width 2n
* for -Tascii -enum, the default is -width 3n
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.143 2012/07/09 23:52:47 schwarze Exp $ */
d241 1
a241 1
	{ termp_under_pre, termp____post }, /* %U */ 
@


1.143
log
@fix -Tascii .Fd line breaking
and implement -Tman .Fd
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.142 2012/07/08 22:48:38 schwarze Exp $ */
d726 1
a726 3
		if (width < term_len(p, 4))
			width = term_len(p, 4);
		break;
d728 2
a729 2
		if (width < term_len(p, 5))
			width = term_len(p, 5);
d784 8
a794 2
		/* FALLTHROUGH */
	case (LIST_enum):
@


1.142
log
@fix .Lk for -Tascii and implement it for -Tman
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.141 2012/07/08 16:50:36 schwarze Exp $ */
d68 1
a68 1
static	void	  termp_d1_post(DECL_ARGS);
d128 2
a129 2
	{ termp_d1_pre, termp_d1_post }, /* D1 */
	{ termp_d1_pre, termp_d1_post }, /* Dl */
d145 1
a145 1
	{ termp_fd_pre, NULL }, /* Fd */ 
d1406 9
a1503 11
}


/* ARGSUSED */
static void
termp_d1_post(DECL_ARGS)
{

	if (MDOC_BLOCK != n->type) 
		return;
	term_newln(p);
@


1.141
log
@implement -Tman .An
also reset -[no]split mode at .Sh AUTHORS in -Tascii
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.140 2011/11/13 13:05:23 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d2158 1
a2158 1
	const struct mdoc_node *nn, *sv;
d2160 2
a2161 1
	term_fontpush(p, TERMFONT_UNDER);
d2163 10
a2172 12
	nn = sv = n->child;

	if (NULL == nn || NULL == nn->next)
		return(1);

	for (nn = nn->next; nn; nn = nn->next) 
		term_word(p, nn->string);

	term_fontpop(p);

	p->flags |= TERMP_NOSPACE;
	term_word(p, ":");
d2175 1
a2175 1
	term_word(p, sv->string);
@


1.140
log
@Make the default left text margin configurable from the command line,
just like the default right margin already is.  This may be useful for
people with expensive screen real estate.  Besides, it helps automated
man(7) to mdoc(7) output comparisons to validate -Tman output.
ok kristaps@@ on an earlier version
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.139 2011/11/03 20:32:33 schwarze Exp $ */
d1424 2
@


1.139
log
@Correct .Eo spacing:
no space between the delimiters and the enclosed text.
The mdoc_html.c part was added by kristaps; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.138 2011/10/16 12:18:32 schwarze Exp $ */
a32 3
#define	INDENT		  5
#define	HALFINDENT	  3

d255 3
d561 1
a561 1
		return(term_len(p, INDENT + 1));
d563 1
a563 1
		return(term_len(p, (INDENT + 1) * 2));
d1423 1
a1423 1
		p->offset = term_len(p, INDENT);
d1491 1
a1491 1
	p->offset += term_len(p, (INDENT + 1));
d1796 1
a1796 1
		p->offset = term_len(p, HALFINDENT);
@


1.138
log
@Remove a bunch of useless assignments,
and assert that print_bvspace cannot be called on NULL pointers.
No change in behaviour, none of these were bugs,
but the code becomes easier to understand.
Based on a clang report posted by joerg@@; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.137 2011/09/20 09:02:18 schwarze Exp $ */
d193 1
a193 1
	{ NULL, NULL }, /* Eo */
d1924 2
d1989 2
@


1.137
log
@Sync print_mdoc_head to print_man_head;
this was forgotten after man_term.c rev. 1.25 on March 2, 2010.
The benefit is a sane page header line when .Dt is very long.
Reminded by Thomas Klausner <wiz at NetBSD>, thanks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.136 2011/09/19 22:36:11 schwarze Exp $ */
d582 2
@


1.136
log
@Remove the terminal frontend flag TERMP_NOLPAD.

In columnated contexts (.Bl -column, .Bl -tag, .IP, .TP, .HP etc.), do not
pad after writing a column.  Instead, always pad before writing content.

In itself, this change avoids:
 - writing trailing whitespace in some situations
 - with .fi/.nf in .HP, breaking lines that were already padded

It allows several bugfixes included in this patch:
 - Do not count backspace as a character with positive width.
 - Set up proper indentation when encountering .fi/.nf in .HP.
 - Adjust the .HP indentation width to what groff does.
 - Never unlimit the right margin unless in the final column.

This reduces the groff/mandoc-differences in base by nearly 20%,
from 89k to 72k lines of diffs.

ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.135 2011/09/18 10:25:28 schwarze Exp $ */
d457 1
a461 3
	p->rmargin = p->maxrmargin;
	p->offset = 0;

d475 3
d480 1
d489 1
d491 1
d493 4
a496 3
	p->rmargin = (p->maxrmargin - 
			term_strlen(p, buf) + term_len(p, 1)) / 2;
	p->flags |= TERMP_NOBREAK | TERMP_NOSPACE;
d501 1
d503 2
a504 2
	p->rmargin = p->maxrmargin - term_strlen(p, title);
	p->flags |= TERMP_NOSPACE;
a508 2
	p->offset = p->rmargin;
	p->rmargin = p->maxrmargin;
d510 7
a516 4
	p->flags |= TERMP_NOSPACE;

	term_word(p, title);
	term_flushln(p);
d518 1
a520 1
	p->flags &= ~TERMP_NOSPACE;
@


1.135
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.134 2011/07/05 04:12:41 schwarze Exp $ */
d434 1
a434 1
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
d442 1
a442 1
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
d498 1
a498 1
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
d506 1
a506 1
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
a785 2
		else
			p->flags |= TERMP_NOLPAD;
a790 3
			p->flags |= TERMP_NOLPAD;

		if (MDOC_HEAD != n->type)
d801 1
a801 1
				 MDOC_Bd == n->next->child->tok)) {
d803 1
a803 2
			p->flags &= ~TERMP_NOLPAD;
		} else
a808 2
		else
			p->flags |= TERMP_NOLPAD;
a823 4
		assert(n->prev);
		if (MDOC_BODY == n->prev->type) 
			p->flags |= TERMP_NOLPAD;

a979 1
	p->flags &= ~TERMP_NOLPAD;
d995 1
a995 1
		p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
d1040 1
a1040 1
	} else if (MDOC_BODY == n->type && n->child) {
a1041 2
		p->flags &= ~TERMP_NOLPAD;
	}
@


1.134
log
@Sync to bsd.lv (all coded by kristaps@@):
 - mdoc(7): fix an assertion if the first line after .Bd -column
   starts with a blank, and some simplifications in mdoc_argv.c
 - man(7): literal mode ends at .SH and .SS (bug reported by naddy@@)
 - allow .RS/.RE blocks to nest (bug reported by dcoppa@@ and gsoares@@)
 - improve vertical spacing of man(7) blocks
 - roff(7): clear user-defined strings when starting a new file
 - correct ID tags in -T[x]html
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.133 2011/05/29 21:22:18 schwarze Exp $ */
d350 1
a350 1
		term_word(p, n->eqn->data);
@


1.133
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.132 2011/04/24 16:22:02 schwarze Exp $ */
d522 1
d525 1
a525 1
		SCALE_VS_INIT(&su, term_len(p, 1));
@


1.132
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.131 2011/03/20 23:36:42 schwarze Exp $ */
d263 1
a263 8
		switch (p->enc) {
		case (TERMENC_ASCII):
			p->symtab = chars_init(CHARS_ASCII);
			break;
		default:
			abort();
			/* NOTREACHED */
		}
@


1.131
log
@Import the foundation for eqn(7) support.
Written by kristaps@@.

For now, i'm adding one line to each of the four frontends
to just pass the input text through to the output,
not yet interpreting any of then eqn keywords.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.130 2011/03/07 01:35:33 schwarze Exp $ */
a30 1
#include "chars.h"
d350 2
d353 2
d1182 1
a1182 1
	const struct mdoc_node	*nn;
d1187 2
a1188 1
	for (nn = n->child; nn; nn = nn->next) {
d1190 1
a1190 1
		term_word(p, nn->string);
d1192 1
d1194 9
a1202 6
		if (nn->next && NULL == nn->next->next)
			term_word(p, "(), and");
		else if (nn->next)
			term_word(p, "(),");
		else
			term_word(p, "()");
d1205 1
a1205 1
	if (n->child && n->child->next)
d1228 1
a1228 1
	const struct mdoc_node	*nn;
d1230 1
d1233 2
a1234 1
	for (nn = n->child; nn; nn = nn->next) {
d1236 1
a1236 1
		term_word(p, nn->string);
d1238 3
a1240 4
		p->flags |= TERMP_NOSPACE;
		if (nn->next && NULL == nn->next->next)
			term_word(p, ", and");
		else if (nn->next)
d1242 4
a1245 2
		else
			p->flags &= ~TERMP_NOSPACE;
d1248 1
a1248 1
	if (n->child && n->child->next)
d1254 1
a1255 1

a1294 1

a1298 1
	const struct mdoc_node *nn;
d1300 1
a1300 1
	if (NULL == n->child)
d1303 2
a1304 2
	assert(MDOC_TEXT == n->child->type);
	nn = n->child;
d1306 1
a1306 2
	term_word(p, nn->string);
	if (NULL == (nn = nn->next)) 
d1308 1
d1311 6
a1316 1
	term_word(p, nn->string);
a1321 1

d1535 3
a1537 1
	const struct mdoc_node	*nn;
d1541 4
d1546 1
a1546 1
	term_word(p, n->child->string);
d1551 1
d1553 2
a1554 1
	for (nn = n->child->next; nn; nn = nn->next) {
d1556 1
a1556 1
		term_word(p, nn->string);
d1559 2
a1560 1
		if (nn->next)
d1562 1
d1565 1
d1568 2
a1569 1
	if (MDOC_SYNPRETTY & n->flags)
d1571 1
d1593 2
a1594 1
		if (nn->next)
d1596 1
d1599 2
a1600 1
	if (n->child && n->next && n->next->tok == MDOC_Fa)
d1602 1
d2037 1
d2061 1
d2064 2
a2065 1
	if (MDOC_SYNPRETTY & n->flags)
d2067 1
d2141 1
d2178 1
@


1.130
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.129 2011/02/06 22:56:45 schwarze Exp $ */
d353 3
d375 2
@


1.129
log
@Do not break the line between the arguments of .Bsx .Dx .Fx .Nx .Ox .Ux.
Original patch from kristaps@@, but i fixed a regression regarding .Bk.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.128 2011/02/06 22:25:36 schwarze Exp $ */
a406 1
	char		buf[DATESIZ], os[BUFSIZ];
a420 3
	time2a(m->date, buf, DATESIZ);
	strlcpy(os, m->os, BUFSIZ);

d425 1
a425 1
			term_strlen(p, buf) + term_len(p, 1)) / 2;
d428 1
a428 1
	term_word(p, os);
d432 1
a432 1
	p->rmargin = p->maxrmargin - term_strlen(p, os);
d435 1
a435 1
	term_word(p, buf);
d443 1
a443 1
	term_word(p, os);
@


1.128
log
@Some pre-handlers produce output, so reorder the code to set up
keep flags before they are called.
Without this bugfix, .Bk was ineffective in some cases.
"looks reasonable" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.127 2011/02/06 17:33:20 schwarze Exp $ */
d1708 1
a1733 1
	assert(pp);
d1735 7
a1741 1
	return(1);
@


1.127
log
@If .Ns is specified on its own line, ignore it, like groff does;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.126 2011/01/30 18:28:01 schwarze Exp $ */
a310 16
	
	switch (n->type) {
	case (MDOC_TEXT):
		if (' ' == *n->string && MDOC_LINE & n->flags)
			term_newln(p);
		term_word(p, n->string);
		break;
	case (MDOC_TBL):
		term_tbl(p, n->span);
		break;
	default:
		if (termacts[n->tok].pre && ENDBODY_NOT == n->end)
			chld = (*termacts[n->tok].pre)
				(p, &npair, m, n);
		break;
	}
d341 21
@


1.126
log
@Make .Bx accept not more than two arguments.
Convert the first character of the second argument to uppercase.
Append the second argument with a hyphen.
Improves chpass(1), column(1), fstat(1), ...
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.125 2011/01/30 17:41:59 schwarze Exp $ */
d1150 2
a1151 1
	p->flags |= TERMP_NOSPACE;
@


1.125
log
@Like in groff, if .%B is specified, quote .%T; from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.124 2011/01/16 02:56:47 schwarze Exp $ */
a71 1
static	void	  termp_bx_post(DECL_ARGS);
d93 1
d186 1
a186 1
	{ NULL, termp_bx_post }, /* Bx */
d1673 2
a1674 2
static void
termp_bx_post(DECL_ARGS)
d1677 12
a1688 1
	if (n->child)
d1690 4
a1693 1
	term_word(p, "BSD");
@


1.124
log
@If the first character of a free-form text input line is whitespace,
then it will start a new output line;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.123 2011/01/09 16:09:41 schwarze Exp $ */
d2168 1
a2168 1
			n->parent->norm->Rs.child_J)
d2184 1
a2184 1
			n->parent->norm->Rs.child_J)
@


1.123
log
@Only .Bd -literal has 8-character tabs,
while .Bd -unfilled has 5-character tabs just like normal text;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.122 2011/01/04 22:28:17 schwarze Exp $ */
d314 2
@


1.122
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.121 2010/12/29 00:47:31 schwarze Exp $ */
d1598 3
a1600 1
	p->tabwidth = term_len(p, 8);
@


1.121
log
@Reorg by Kristaps:  In libmdoc, replace the union of pointers to structs
of macro-specific data by a pointer to a union of structs, which makes the
code simpler and more robust at the expense of a small memory overhead.
Merging was somewhat difficult because we mustn't break tbl(1) support
which the bsd.lv version does not yet have.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.120 2010/12/26 21:04:19 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
a32 1
#include "tbl.h"
a117 1
static	int	  termp_ts_pre(DECL_ARGS);
a246 2
	{ termp_ts_pre, NULL }, /* TS */ 
	{ NULL, NULL }, /* TE */ 
d311 14
a324 5

	if (MDOC_TEXT == n->type)
		term_word(p, n->string); 
	else if (termacts[n->tok].pre && ENDBODY_NOT == n->end)
		chld = (*termacts[n->tok].pre)(p, &npair, m, n);
d361 8
a368 2
	if (MDOC_TEXT != n->type && termacts[n->tok].post && 
			! (MDOC_ENDED & n->flags)) {
d386 1
a2116 15

	return(0);
}


/* ARGSUSED */
static int
termp_ts_pre(DECL_ARGS)
{

	if (MDOC_BLOCK != n->type)
		return(0);

	if (tbl_close(p, n->norm->TS, "mdoc tbl postprocess", n->line))
		tbl_write(p, n->norm->TS);
@


1.120
log
@Behave more like groff (both old and new): Specifying both .%T and .%J in
an .Rs block causes the title to be quoted instead of underlined, such
that journal title and article title appear visually different.
Original diff from kristaps@@, simplified by me, tweaked again by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.119 2010/12/21 23:57:31 schwarze Exp $ */
d561 1
a561 1
	if (MDOC_Bd == bl->tok && bl->data.Bd->comp)
d563 1
a563 1
	if (MDOC_Bl == bl->tok && bl->data.Bl->comp)
d582 1
a582 1
	if (MDOC_Bl == bl->tok && LIST_column == bl->data.Bl->type)
d588 1
a588 1
	if (MDOC_Bl == bl->tok && LIST_diag == bl->data.Bl->type)
d615 1
a615 2
	assert(bl->data.Bl);
	type = bl->data.Bl->type;
d625 2
a626 2
	if (bl->data.Bl->offs)
		offset = a2offs(p, bl->data.Bl->offs);
d642 1
a642 1
		ncols = bl->data.Bl->ncols;
d657 1
a657 1
				(p, bl->data.Bl->cols[i]);
d672 1
a672 1
		width = a2width(p, bl->data.Bl->cols[i]) + dcol;
d675 1
a675 1
		if (NULL == bl->data.Bl->width)
d683 2
a684 2
		assert(bl->data.Bl->width);
		width = a2width(p, bl->data.Bl->width) + term_len(p, 2);
d946 1
a946 1
	type = n->parent->parent->parent->data.Bl->type;
d1120 1
a1120 1
	if (AUTH_split == n->data.An->auth) {
d1123 1
a1123 1
	} else if (AUTH_nosplit == n->data.An->auth) {
d1570 2
a1571 3
	assert(n->data.Bd);
	if (n->data.Bd->offs)
		p->offset += a2offs(p, n->data.Bd->offs);
d1581 2
a1582 2
	if (DISP_literal != n->data.Bd->type && 
			DISP_unfilled != n->data.Bd->type)
d1644 2
a1645 3
	assert(n->data.Bd);
	if (DISP_literal == n->data.Bd->type || 
			DISP_unfilled == n->data.Bd->type)
d2004 1
a2004 3
	assert(n->data.Bf);

	if (FONT_Em == n->data.Bf->font) 
d2006 1
a2006 1
	else if (FONT_Sy == n->data.Bf->font) 
d2118 2
a2119 2
	if (tbl_close(p, n->data.TS, "mdoc tbl postprocess", n->line))
		tbl_write(p, n->data.TS);
a2160 1
	struct mdoc_node *nn;
d2166 2
a2167 2
	nn = n->parent->parent;
	if (nn && MDOC_Rs == nn->tok && nn->data.Rs->child_J)
a2176 1
	struct mdoc_node *nn;
d2182 2
a2183 2
	nn = n->parent->parent;
	if (nn && MDOC_Rs == nn->tok && nn->data.Rs->child_J)
d2188 1
a2188 1
 }
@


1.119
log
@Migrate .An to use a pointer to its data, like everybody else.
In preparation for a simpler ref-counted system for node data.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.118 2010/12/21 23:46:18 schwarze Exp $ */
d68 1
d86 1
d177 1
a177 1
	{ termp_under_pre, termp____post }, /* %T */
d1838 1
a1838 1
	if (MDOC_BODY != n->type)
d1871 2
d1900 1
a1900 1
	if (MDOC_BODY != n->type)
d1935 2
d2161 35
@


1.118
log
@Vertical spacing improvements from kristaps@@, small tweaks by me:
Add a "last child" member to struct mdoc_node.
Remove .Pp or .Lp if it is the first or last child of an .Sh or .Ss body.
Thus, no need to do the same in the front-ends any longer.
Tolerate some cases of .Pp inside .Bl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.117 2010/12/19 12:10:33 schwarze Exp $ */
d1119 1
a1119 1
	if (AUTH_split == n->data.An.auth) {
d1122 1
a1122 1
	} else if (AUTH_nosplit == n->data.An.auth) {
@


1.117
log
@Handle .Bk the same way as groff 1.20.1:
.Bk without arguments defaults to -words.
.Bk with invalid arguments (including -lines) has no effect.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.116 2010/12/11 14:29:56 schwarze Exp $ */
a1817 5
		assert(n->parent);
		if ((NULL == n->next || NULL == n->prev) &&
				(MDOC_Ss == n->parent->tok ||
				 MDOC_Sh == n->parent->tok))
			return(0);
@


1.116
log
@Make SYNOPSIS sections and code having .nr nS enabled
behave as if the whole code were wrapped in .Bk/.Ek,
i.e. keeping input lines together on output lines.
This is compatible with new groff behaviour and deviates
from historical groff.
Tweaked version of a patch sent by kristaps@@ on July 16, 2010.
ok kristaps@@ jmc@@ sobrado@@ millert@@
@
text
@d1 1
a1 1
/*	$Id$ */
d2140 2
a2141 1
		p->flags |= TERMP_PREKEEP;
@


1.115
log
@Do not follow .D1 and .Dl inside .Bd with a blank line.
Kristaps@@ came up with this improvement when he merged
my patch introducing support for nested displays.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.114 2010/12/01 22:02:29 schwarze Exp $ */
d322 3
d327 1
a327 1
	if (TERMP_KEEP & p->flags) {
d338 10
@


1.114
log
@Merge mdoc_action.c into mdoc_validate.c, because having two places to do
basically the same things just causes code duplication and confusion.
Work by kristaps@@, including a few bugfixes he found during the merge,
and reapplying OpenBSD changes on top.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.113 2010/10/23 23:30:41 schwarze Exp $ */
d1594 4
@


1.113
log
@let .Bsx print just "BSD/OS" like in modern groff
from Ulrich Spoerlein <uqs at spoerlein dot net>
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.112 2010/10/23 16:08:36 schwarze Exp $ */
d2079 1
a2079 1
	if (NULL == nn->next)
@


1.112
log
@.Sm no longer produces a linebreak when used in .Bd
also avoid an extra space after the opening bracket in .Op in -Thtml
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.111 2010/10/16 20:49:37 schwarze Exp $ */
d1660 1
a1660 1
		pp = "BSDI BSD/OS";
@


1.111
log
@Do not abort() on tbl errors, reduce the risk that tbl stuff kills a build,
and provide more useful tbl error messages in a non-intrusive way.
@
text
@d1 1
a1 1
/*	$Id$ */
d1587 2
@


1.110
log
@Support tbl(1) code embedded into mdoc(7) input files.
Very similar to what i have done in man(7) yesterday.
Allows to build cpu(4) on HPPA, wi(4), and phantasia(6).
Now we are able to build all tbl code in base.
@
text
@d2103 2
a2104 4
	if ( ! tbl_close(p, n->data.TS, "<mdoc>", n->line))
		return(0);

	tbl_write(p, n->data.TS);
@


1.109
log
@* need a space before .No even if it starts with a closing delimiter
* slightly simplify .Pf *_IGNDELIM code, and share part of it with .No
* do not let opening delimiters fall out of the front of .Ns (from kristaps@@)
This fixes a few spacing issues in csh(1) and ksh(1).
OK kristaps@@
@
text
@d33 1
d117 1
d247 2
d2090 17
@


1.108
log
@Merge the last bits of 1.10.6 (released today), most were already in:
* ignore double-.Pp
* ignore .Pp before .Bd and .Bl (unless -compact in specified)
* avoid double blank line upon .Pp, .br and friends in literal context
* cast enums to int when passing them to exit(3) to please lint(1)
While merging, fix a regression introduced by kristaps@@:
Outside literal mode, double blank lines must both be printed.
To achieve this again after kristaps@@ improvements in 1.10.6,
treat such blank lines as .sp (instead of .Pp as in 1.10.5)
and drop .Pp before .sp just like dropping .Pp before .Pp.
@
text
@d101 1
a108 1
static	int	  termp_pf_pre(DECL_ARGS);
d195 1
a195 1
	{ NULL, NULL }, /* No */
d200 1
a200 1
	{ termp_pf_pre, termp_pf_post }, /* Pf */
d1683 1
a1683 1
termp_pf_pre(DECL_ARGS)
a1695 1
	p->flags &= ~TERMP_IGNDELIM;
@


1.107
log
@consolidate all enclosure opening and closing functions
to help code comprehension and reduce code size
also remove redundant TERMP_NOSPACE here and there
from kristaps@@
@
text
@d1576 20
@


1.106
log
@no punctuation after .%* outside .Rs
in .Rs, mark full stops after .%* as end of a sentence
from kristaps@@
@
text
@a67 1
static	void	  termp_aq_post(DECL_ARGS);
a70 2
static	void	  termp_bq_post(DECL_ARGS);
static	void	  termp_brq_post(DECL_ARGS);
a72 2
static	void	  termp_dq_post(DECL_ARGS);
static	int	  termp_fd_pre(DECL_ARGS);
a77 1
static	void	  termp_op_post(DECL_ARGS);
d79 1
a79 2
static	void	  termp_pq_post(DECL_ARGS);
static	void	  termp_qq_post(DECL_ARGS);
a80 1
static	void	  termp_sq_post(DECL_ARGS);
a85 1
static	int	  termp_aq_pre(DECL_ARGS);
a90 2
static	int	  termp_bq_pre(DECL_ARGS);
static	int	  termp_brq_pre(DECL_ARGS);
a93 1
static	int	  termp_dq_pre(DECL_ARGS);
d96 1
a107 1
static	int	  termp_op_pre(DECL_ARGS);
d109 1
a109 2
static	int	  termp_pq_pre(DECL_ARGS);
static	int	  termp_qq_pre(DECL_ARGS);
a114 1
static	int	  termp_sq_pre(DECL_ARGS);
d156 1
a156 1
	{ termp_op_pre, termp_op_post }, /* Op */
d176 2
a177 2
	{ termp_aq_pre, termp_aq_post }, /* Ao */
	{ termp_aq_pre, termp_aq_post }, /* Aq */
d181 2
a182 2
	{ termp_bq_pre, termp_bq_post }, /* Bo */
	{ termp_bq_pre, termp_bq_post }, /* Bq */
d187 2
a188 2
	{ termp_dq_pre, termp_dq_post }, /* Do */
	{ termp_dq_pre, termp_dq_post }, /* Dq */
d201 2
a202 2
	{ termp_pq_pre, termp_pq_post }, /* Po */
	{ termp_pq_pre, termp_pq_post }, /* Pq */
d204 3
a206 3
	{ termp_sq_pre, termp_sq_post }, /* Ql */
	{ termp_qq_pre, termp_qq_post }, /* Qo */
	{ termp_qq_pre, termp_qq_post }, /* Qq */
d210 2
a211 2
	{ termp_sq_pre, termp_sq_post }, /* So */
	{ termp_sq_pre, termp_sq_post }, /* Sq */
d221 1
a221 1
	{ termp_op_pre, termp_op_post }, /* Oo */
d233 2
a234 2
	{ termp_brq_pre, termp_brq_post }, /* Brq */ 
	{ termp_brq_pre, termp_brq_post }, /* Bro */ 
a581 27
termp_dq_pre(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);

	term_word(p, "\\(lq");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_dq_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return;

	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(rq");
}


/* ARGSUSED */
static int
a1246 12
static void
termp_op_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type) 
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(rB");
}


/* ARGSUSED */
a1262 1
	p->flags |= TERMP_NOSPACE;
a1263 1
	p->flags |= TERMP_NOSPACE;
a1412 17
termp_op_pre(DECL_ARGS)
{

	switch (n->type) {
	case (MDOC_BODY):
		term_word(p, "\\(lB");
		p->flags |= TERMP_NOSPACE;
		break;
	default:
		break;
	}
	return(1);
}


/* ARGSUSED */
static int
a1468 25
termp_aq_pre(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	term_word(p, "\\(la");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_aq_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(ra");
}


/* ARGSUSED */
static int
a1614 25
static int
termp_qq_pre(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	term_word(p, "\"");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_qq_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\"");
}


/* ARGSUSED */
a1662 25
termp_sq_pre(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	term_word(p, "\\(oq");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_sq_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(aq");
}


/* ARGSUSED */
static int
d1796 1
a1796 1
termp_brq_pre(DECL_ARGS)
a1800 4
	term_word(p, "\\(lC");
	p->flags |= TERMP_NOSPACE;
	return(1);
}
d1802 46
a1848 20
/* ARGSUSED */
static void
termp_brq_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(rC");
}


/* ARGSUSED */
static int
termp_bq_pre(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	term_word(p, "\\(lB");
d1856 1
a1856 1
termp_bq_post(DECL_ARGS)
a1860 3
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(rB");
}
a1861 9

/* ARGSUSED */
static int
termp_pq_pre(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	term_word(p, "\\&(");
a1862 2
	return(1);
}
d1864 46
a1909 9

/* ARGSUSED */
static void
termp_pq_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	term_word(p, ")");
a1923 1
		p->flags |= TERMP_NOSPACE;
a1946 1
	p->flags |= TERMP_NOSPACE;
d1949 1
a1949 2
	if (MDOC_SYNPRETTY & n->flags) {
		p->flags |= TERMP_NOSPACE;
a1950 1
	}
d2000 1
a2000 1
	term_word(p, "\\(aq");
a2061 1
	p->flags |= TERMP_NOSPACE;
@


1.105
log
@When the HEAD of an .Nm block in the SYNOPSIS might be wider
than the column containing it, the TERMP_HANG flag is required,
but avoid the flag when we know that the HEAD is shorter,
because in that case, the flag might ruin the alignment.

Problem originally reported by jmc@@, who also spotted a regression
in an earlier version of this patch.

"feel free to commit" kristaps@@
@
text
@d2129 8
a2136 2
	p->flags |= TERMP_NOSPACE;
	term_word(p, n->next ? "," : ".");
@


1.104
log
@Format multiple authors (.%A) in the same way as groff:
Two authors with "and", but without a comma.
Three or more with commata, and an "and" before the last one.
From kristaps@@.
@
text
@d1030 12
a1041 6
		p->flags |= TERMP_NOSPACE | TERMP_NOBREAK | TERMP_HANG;
		p->rmargin = p->offset + term_len(p, 1) +
		    (NULL == n->child ? term_strlen(p, m->name) :
		     MDOC_TEXT == n->child->type ?
			term_strlen(p, n->child->string) :
		     term_len(p, 5));
@


1.103
log
@Backout previous.
As Kristaps found out, i was wrong: .Bl -column phrases do not ignore
spacing rules for trailing punctuation in general.  In particular,
- the rightmost column of a column list is unaffected
- columns terminated by the .Ta macro instead of a tab are unaffected
- columns ending in a blank are unaffected
Spacing rules for trailing punctuation are only ignored when the tab
follows the punctuation immediately, without a blank in between,
because then the combination of punctuation and tab is treated by roff
as a word, and the punctuation is not recognized as isolated.
The reason this doesn't work in mandoc is that in the special case
of .Bl -column (not in general!), mandoc treats tabs as word delimiters.
We either need to solve this differently, or call it a bug in roff.
@
text
@d91 1
d178 1
a178 1
	{ NULL, termp____post }, /* %A */
d1079 13
d2110 10
@


1.102
log
@.Bl -column phrases ignore spacing rules for trailing punctuation
and render it just like normal text.
Minimal fix of a formatting bug in operator(7) reported by ray@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.101 2010/08/18 01:45:22 schwarze Exp $ */
a840 2
		p->flags |= TERMP_IGNDELIM;

a998 7

	/*
	 * TERMP_IGNDELIM is also set by `Pf', but it is safe
	 * to clear it here because `Pf' cannot contain `It'.
	 */

	p->flags &= ~TERMP_IGNDELIM;
a1802 4
	/*
	 * XXX Resetting TERMP_IGNDELIM here is not safe
	 * because `Pf' can be used inside `Bl -column'.
	 */
@


1.101
log
@Correctly print .Lk arguments in -Tascii.
Issue reported by Aldis Berzoja, fix by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.100 2010/08/04 18:52:55 schwarze Exp $ */
d841 2
d1001 7
d1812 4
@


1.100
log
@In .Bd -literal, break the output line after the last element of each
input line, not after the first element.  Since free-form text lines
only have a single element in literal mode, this is only relevant for
macro lines inside literal displays, and only for those containing
more than one macro.  Fixes e.g. awk(1) and boot_config(8).
Note this fix differs from what kristaps@@ committed to bsd.lv because
those changes introduce regressions with respect to blank lines in
literal mode.
With permission from deraadt@@ to still fix bugs in mandoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.99 2010/07/31 21:43:07 schwarze Exp $ */
d2118 1
a2118 1
	const struct mdoc_node *nn;
d2121 2
a2122 1
	nn = n->child;
d2127 3
a2129 1
	term_word(p, nn->string);
d2136 1
a2136 2
	for (nn = nn->next; nn; nn = nn->next) 
		term_word(p, nn->string);
@


1.99
log
@Merge bsd.lv version 1.10.5: last larger batch of bug fixes before release.
NOT including Kristaps' .Bd -literal changes which cause regressions.
Features:
* -Tpdf now fully working
Bugfixes:
* proper handling of quoted strings by .ds in roff(7)
* allow empty .Dd
* make .Sm start no-spacing after the first output word
* underline .Ad
* minor fixes in -Thtml
and some optimisations in terminal output.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.98 2010/07/25 18:05:54 schwarze Exp $ */
d1652 4
a1656 5
		print_mdoc_node(p, pair, m, nn);
		if (NULL == nn->prev ||
		    nn->prev->line < nn->line ||
		    NULL == nn->next)
			term_flushln(p);
@


1.98
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.97 2010/07/21 21:44:28 schwarze Exp $ */
d150 1
a150 1
	{ NULL, NULL }, /* Ad */ 
d1620 1
a1620 2
	size_t			 tabwidth;
	size_t			 rm, rmax;
@


1.97
log
@In the SYNOPSIS, .Nm at the beginning of an input line starts
an .Nm block, and gets special handling (new line, indentation).
But .Nm in the middle of a line is just a normal in-line element,
so make sure it does NOT get the special handling.
Partly fixes the test(1) SYNOPSIS; indentation after "[" is still
excessive, which is an unrelated and more difficult issue.
Reminded of the problem by jmc@@;
OK kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.96 2010/07/16 00:03:29 schwarze Exp $ */
d207 1
a207 1
	{ termp_bold_pre, NULL }, /* Ms */ /* FIXME: convert to symbol? */
d1905 5
@


1.96
log
@After .Sm on, spacing ought to restart right away, before the next token,
and not with a delay, after the next token.  But be careful not to cause
leading white space at the beginning of a line or column.
Improves chmod(1), ksh(1), tar(1), ps(1) and probably many more.
ok kristaps@@ jmc@@ sobrado@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.95 2010/07/13 01:09:13 schwarze Exp $ */
d1025 2
a1026 1
	synopsis_pre(p, n);
@


1.95
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.94 2010/07/01 15:36:59 schwarze Exp $ */
d2065 3
a2067 1
	if (0 == strcmp("on", n->child->string))
d2069 1
a2069 1
	else
@


1.94
log
@Improve .Nm indentation in the SYNOPSIS;
kristaps@@ will do the missing HTML part soon.
"looks nicer" jmc@@
"seems perfect to me" sobrado@@
"slap it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.93 2010/06/29 17:10:30 schwarze Exp $ */
d3 2
a4 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
a29 1
#include "regs.h"
a55 2
static	int	  arg_hasattr(int, const struct mdoc_node *);
static	int	  arg_getattr(int, const struct mdoc_node *);
d325 1
a325 1
	else if (termacts[n->tok].pre && !n->end)
d328 17
d350 3
a352 4
	if (MDOC_TEXT != n->type &&
	    termacts[n->tok].post &&
	    ! (MDOC_ENDED & n->flags)) {
		(*termacts[n->tok].post)(p, &npair, m, n);
d359 1
a359 1
		if (n->end)
a541 32
 * Return 1 if an argument has a particular argument value or 0 if it
 * does not.  See arg_getattr().
 */
static int
arg_hasattr(int arg, const struct mdoc_node *n)
{

	return(-1 != arg_getattr(arg, n));
}


/*
 * Get the index of an argument in a node's argument list or -1 if it
 * does not exist.
 */
static int
arg_getattr(int v, const struct mdoc_node *n)
{
	int		 i;

	if (NULL == n->args)
		return(0);

	for (i = 0; i < (int)n->args->argc; i++) 
		if (n->args->argv[i].arg == v)
			return(i);

	return(-1);
}


/*
d555 1
a555 1
	if (MDOC_Bd == bl->tok && bl->data.Bd.comp)
d557 1
a557 1
	if (MDOC_Bl == bl->tok && bl->data.Bl.comp)
d576 1
a576 1
	if (MDOC_Bl == bl->tok && LIST_column == bl->data.Bl.type)
d582 1
a582 1
	if (MDOC_Bl == bl->tok && LIST_diag == bl->data.Bl.type)
d626 1
a626 1
	int		        i, col;
d636 2
a637 1
	type = bl->data.Bl.type;
d647 2
a648 2
	if (bl->data.Bl.offs)
		offset = a2offs(p, bl->data.Bl.offs);
a654 2
		col = arg_getattr(MDOC_Column, bl);

d664 2
a665 1
		ncols = bl->args->argv[col].sz;
d679 1
a679 1
				(p, bl->args->argv[col].value[i]);
d694 1
a694 1
		width = a2width(p, bl->args->argv[col].value[i]) + dcol;
d697 1
a697 1
		if (NULL == bl->data.Bl.width)
d705 2
a706 2
		assert(bl->data.Bl.width);
		width = a2width(p, bl->data.Bl.width) + term_len(p, 2);
d968 1
a968 1
	type = n->parent->parent->parent->data.Bl.type;
d1122 1
a1122 1
	if (arg_hasattr(MDOC_Split, n)) {
d1125 1
a1125 1
	} else {
d1629 3
a1631 2
	if (n->data.Bd.offs)
		p->offset += a2offs(p, n->data.Bd.offs);
d1641 2
a1642 2
	if (DISP_literal != n->data.Bd.type && 
			DISP_unfilled != n->data.Bd.type)
d1679 3
a1681 2
	if (DISP_literal == n->data.Bd.type || 
			DISP_unfilled == n->data.Bd.type)
d2006 3
a2010 1
	assert(n->child);
a2039 1
	const struct mdoc_node	*nn;
d2046 1
a2046 10
	if (NULL == (nn = n->head->child)) {
		if (arg_hasattr(MDOC_Emphasis, n))
			term_fontpush(p, TERMFONT_UNDER);
		else if (arg_hasattr(MDOC_Symbolic, n))
			term_fontpush(p, TERMFONT_BOLD);
		else
			term_fontpush(p, TERMFONT_NONE);

		return(1);
	} 
d2048 1
a2048 2
	assert(MDOC_TEXT == nn->type);
	if (0 == strcmp("Em", nn->string))
d2050 1
a2050 1
	else if (0 == strcmp("Sy", nn->string))
d2052 1
a2052 1
	else
d2142 1
a2142 1
		return(1);
d2147 1
a2147 1
		return(1);
d2150 1
d2152 2
@


1.93
log
@Support for badly nested blocks, written around the time of
the Rostock mandoc hackathon and tested and polished since,
supporting constructs like:

.Ao Bo    Ac    Bc        (exp breaking exp)
.Aq Bo    eol   Bc        (imp breaking exp)
.Ao Bq    Ac    eol       (exp breaking imp)
.Ao Bo So Bc    Ac  Sc    (double break, inner before outer)
.Ao Bo So Ac    Bc  Sc    (double break, outer before inner)
.Ao Bo    Ac So Bc  Sc    (broken breaker)
.Ao Bo So Bc Do Ac  Sc Dc (broken double breaker)

There are still two known issues which are tricky:

1) Breaking two identical explicit blocks (Ao Bo Bo Ac or Aq Bo Bo eol)
fails outright, triggering a bogus syntax error.
2) Breaking a block by two identical explicit blocks (Ao Ao Bo Ac Ac Bc
or Ao Ao Bq Ac Ac eol) still has a minor rendering error left:
"<ao1 <ao2 [bo ac2> ac1> bc]>" should not have the final ">".

We can fix these later in the tree, let's not grow this diff too large.

"get it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.92 2010/06/27 21:54:42 schwarze Exp $ */
d84 1
d170 1
a170 1
	{ termp_nm_pre, NULL }, /* Nm */ 
d1025 15
d1041 1
a1041 1
		return(1);
d1045 9
d1061 15
@


1.92
log
@Full .nr nS support, unbreaking the kernel manuals.

Kristaps coded this from scratch after reading my .nr patch;
it is simpler and more powerful.

Registers live in struct regset in regs.h, struct man and struct mdoc
contain pointers to it.  The nS register is cleared when parsing .Sh.
Frontends respect the MDOC_SYNPRETTY flag set in mdoc node_alloc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.91 2010/06/27 17:49:58 schwarze Exp $ */
d324 1
a324 4
	if (MDOC_TEXT != n->type) {
		if (termacts[n->tok].pre)
			chld = (*termacts[n->tok].pre)(p, &npair, m, n);
	} else 
d326 2
d334 21
a354 3
	if (MDOC_TEXT != n->type)
		if (termacts[n->tok].post)
			(*termacts[n->tok].post)(p, &npair, m, n);
@


1.91
log
@minor .Bk fixes:
* do not print invalid arguments verbatim (no groffs prints them, either)
* do not trigger TERMP_PREKEEP twice
* do not die from invlid arguments (groff won't die, either)
* continue to ignore even valid arguments (just like groff)
ok kristaps@@ on the previous version, before removing my last bug ;)
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.90 2010/06/27 01:24:02 schwarze Exp $ */
d29 1
d1277 1
a1277 1
	if (NULL == n->prev || SEC_SYNOPSIS != n->sec)
d1542 1
a1542 1
	if (SEC_SYNOPSIS == n->sec)
d1819 1
a1819 1
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags) {
d1838 1
a1838 1
	if (SEC_SYNOPSIS == n->sec)
d1844 1
a1844 1
	if (SEC_SYNOPSIS == n->sec)
d1986 1
a1986 1
	if (SEC_SYNOPSIS == n->sec) {
@


1.90
log
@Basic implementation of .Bk/.Ek.
OK and one stylistic tweak by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.89 2010/06/26 19:08:00 schwarze Exp $ */
d2107 11
a2117 2
	p->flags |= TERMP_PREKEEP;
	return(1);
d2126 2
a2127 1
	p->flags &= ~(TERMP_KEEP | TERMP_PREKEEP);
@


1.89
log
@As a first step towards variable-width font support,
move all width calculations in term_*.c, *_width().
From kristaps.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.88 2010/06/26 17:56:43 schwarze Exp $ */
d71 1
d96 1
d236 1
a236 1
	{ NULL, NULL }, /* Bk */
d2101 18
@


1.88
log
@merge release 1.10.2
* bug fixes:
- interaction of ASCII_HYPH with special chars (found by Ulrich Spoerlein)
- handling of roff conditionals (found by Ulrich Spoerlein)
- .Bd -offset will no more default to 6n
* maintenance:
- more caching of .Bd and .Bl arguments for efficiency
- deconstify man(7) validation routines
- add FreeBSD library names (provided by Ulrich Spoerlein)
* start PostScript font-switching
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.87 2010/06/10 22:50:10 schwarze Exp $ */
d51 3
a53 3
static	size_t	  a2width(const char *);
static	size_t	  a2height(const struct mdoc_node *);
static	size_t	  a2offs(const char *);
d270 1
a270 1
	p->tabwidth = 5;
d368 2
a369 1
	p->rmargin = (p->maxrmargin - strlen(buf) + 1) / 2;
d376 1
a376 1
	p->rmargin = p->maxrmargin - strlen(os);
d432 2
a433 1
	p->rmargin = (p->maxrmargin - strlen(buf) + 1) / 2;
d440 1
a440 1
	p->rmargin = p->maxrmargin - strlen(title);
d461 1
a461 1
a2height(const struct mdoc_node *n)
d465 3
a467 4
	assert(MDOC_TEXT == n->type);
	assert(n->string);
	if ( ! a2roffsu(n->string, &su, SCALE_VS))
		SCALE_VS_INIT(&su, strlen(n->string));
d469 1
a469 1
	return(term_vspan(&su));
d474 1
a474 1
a2width(const char *v)
d480 1
a480 1
		SCALE_HS_INIT(&su, strlen(v));
d482 1
a482 1
	return(term_hspan(&su));
d487 1
a487 1
a2offs(const char *v)
d496 1
a496 1
		return(INDENT + 1);
d498 1
a498 1
		return((INDENT + 1) * 2);
d500 1
a500 1
		SCALE_HS_INIT(&su, strlen(v));
d502 1
a502 1
	return(term_hspan(&su));
d644 1
a644 1
		offset = a2offs(bl->data.Bl.offs);
d664 2
a665 1
		dcol = ncols < 5 ? 4 : ncols == 5 ? 3 : 1;
d676 1
a676 1
				(bl->args->argv[col].value[i]);
d691 1
a691 1
		width = a2width(bl->args->argv[col].value[i]) + dcol;
d703 1
a703 1
		width = a2width(bl->data.Bl.width) + 2;
d719 2
a720 2
		if (width < 4)
			width = 4;
d723 2
a724 2
		if (width < 5)
			width = 5;
d728 1
a728 1
			width = 8;
d734 1
a734 1
			width = 10;
d1375 1
a1375 1
		p->offset = INDENT;
d1460 1
a1460 1
	p->offset += (INDENT + 1);
d1588 1
a1588 1
		p->offset += a2offs(n->data.Bd.offs);
d1603 1
a1603 1
	p->tabwidth = 8;
d1778 1
a1778 1
		p->offset = HALFINDENT;
d1854 1
a1854 1
		len = n->child ? a2height(n->child) : 1;
@


1.87
log
@minimal initial -Tps support, from kristaps@@ GSOC
so far, monospace without font decoration,
but it already has page headers and footers
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.86 2010/06/08 00:11:47 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d51 1
a51 1
static	size_t	  a2width(const struct mdoc_argv *, int);
d53 1
a53 1
static	size_t	  a2offs(const struct mdoc_argv *);
a55 2
static	int	  arg_getattrs(const int *, int *, size_t,
			const struct mdoc_node *);
a56 1
static	int	  arg_disptype(const struct mdoc_node *);
d473 1
a473 1
a2width(const struct mdoc_argv *arg, int pos)
d477 3
a479 3
	assert(arg->value[pos]);
	if ( ! a2roffsu(arg->value[pos], &su, SCALE_MAX))
		SCALE_HS_INIT(&su, strlen(arg->value[pos]));
a484 29
static int
arg_disptype(const struct mdoc_node *n)
{
	int		 i, len;

	assert(MDOC_BLOCK == n->type);

	len = (int)(n->args ? n->args->argc : 0);

	for (i = 0; i < len; i++)
		switch (n->args->argv[i].arg) {
		case (MDOC_Centred):
			/* FALLTHROUGH */
		case (MDOC_Ragged):
			/* FALLTHROUGH */
		case (MDOC_Filled):
			/* FALLTHROUGH */
		case (MDOC_Unfilled):
			/* FALLTHROUGH */
		case (MDOC_Literal):
			return(n->args->argv[i].arg);
		default:
			break;
		}

	return(-1);
}


d486 1
a486 1
a2offs(const struct mdoc_argv *arg)
d490 1
a490 1
	if ('\0' == arg->value[0][0])
d492 1
a492 1
	else if (0 == strcmp(arg->value[0], "left"))
d494 1
a494 1
	else if (0 == strcmp(arg->value[0], "indent"))
d496 1
a496 1
	else if (0 == strcmp(arg->value[0], "indent-two"))
d498 2
a499 2
	else if ( ! a2roffsu(arg->value[0], &su, SCALE_MAX))
		SCALE_HS_INIT(&su, strlen(arg->value[0]));
d519 1
a519 1
 * does not exist.  See arg_getattrs().
d524 1
a524 17
	int		 val;

	return(arg_getattrs(&v, &val, 1, n) ? val : -1);
}


/*
 * Walk through the argument list for a node and fill an array "vals"
 * with the positions of the argument structures listed in "keys".
 * Return the number of elements that were written into "vals", which
 * can be zero.
 */
static int
arg_getattrs(const int *keys, int *vals, 
		size_t sz, const struct mdoc_node *n)
{
	int		 i, j, k;
d529 5
a533 7
	for (k = i = 0; i < (int)n->args->argc; i++) 
		for (j = 0; j < (int)sz; j++)
			if (n->args->argv[i].arg == keys[j]) {
				vals[j] = i;
				k++;
			}
	return(k);
d550 4
a553 1
	if (arg_hasattr(MDOC_Compact, bl))
d572 1
a572 1
	if (MDOC_Bl == bl->tok && LIST_column == bl->data.list)
d578 1
a578 1
	if (MDOC_Bl == bl->tok && LIST_diag == bl->data.list)
d622 1
a622 1
	int		        i, keys[3], vals[3];
d632 1
a632 12

	/* Get list width, offset, and list type from argument list. */

	keys[0] = MDOC_Width;
	keys[1] = MDOC_Offset;
	keys[2] = MDOC_Column;

	vals[0] = vals[1] = vals[2] = -1;

	arg_getattrs(keys, vals, 3, bl);

	type = bl->data.list;
d642 2
a643 2
	if (vals[1] >= 0) 
		offset = a2offs(&bl->args->argv[vals[1]]);
d649 3
d661 1
a661 1
		ncols = bl->args->argv[vals[2]].sz;
d674 1
a674 2
				(&bl->args->argv[vals[2]], i);

d689 1
a689 1
		width = a2width(&bl->args->argv[vals[2]], i) + dcol;
d692 1
a692 1
		if (vals[0] < 0) 
d700 2
a701 1
		width = a2width(&bl->args->argv[vals[0]], 0) + 2;
d963 1
a963 1
	type = n->parent->parent->parent->data.list;
a1575 1
	int	         	 i, type;
d1585 2
a1586 7
	nn = n->parent;

	type = arg_disptype(nn);
	assert(-1 != type);

	if (-1 != (i = arg_getattr(MDOC_Offset, nn)))
		p->offset += a2offs(&nn->args->argv[i]);
d1596 2
a1597 1
	if (MDOC_Literal != type && MDOC_Unfilled != type)
d1614 1
a1615 1

a1625 1
	int		 type;
a1630 3
	type = arg_disptype(n->parent);
	assert(-1 != type);

d1634 2
a1635 1
	if (MDOC_Literal == type || MDOC_Unfilled == type)
@


1.86
log
@Merge more bits that will be going into 1.10.1:

Clean up vertical spacing in the SYNOPSIS, making the code much more
systematic; this doesn't solve all SYNOPSIS problems yet, in particular
not those related to keeps, indentation and the low-level .nr roff
instruction, but it's a nice step forward and i couldn't find relevant
regressions.  (from kristaps)

Besides,
* make the output width configurable (default: -Owidth=80) (kristaps)
* use mmap with MAP_SHARED (from Joerg Sonnenberger)
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.85 2010/06/06 20:30:08 schwarze Exp $ */
a63 1
static	void	  print_mdoc_head(DECL_ARGS);
d65 2
a66 1
static	void	  print_foot(DECL_ARGS);
d288 2
a289 1
	print_mdoc_head(p, NULL, m, n);
d292 2
a293 1
	print_foot(p, NULL, m, n);
a346 1
/* ARGSUSED */
d348 1
a348 1
print_foot(DECL_ARGS)
d351 3
a397 1
/* ARGSUSED */
d399 1
a399 1
print_mdoc_head(DECL_ARGS)
d402 3
@


1.85
log
@Merge bsd.lv version 1.10.1 (to be released soon).

The main step forward is that this now has *much* better .Bl -column
support, now supporting many manuals that previously errored out
without producing any output.

Other fixes include:
* do not die from multiple list types, use the first and warn
* in .Bl without a type, default to -item
* various tweaks to .Dt
* fix .In, .Fd, .Ft, .Fn and .Fo formatting
* some documentation fixes and additions
* and fix a couple of bugs reported by Ulrich Spoerlein:
* better support for roff block-end "\}" without a preceding dot
* .In must not break the line outside SYNOPSIS
* spelling in some error messages

While merging, fix one regression in .In spacing
that needs to go to bsd.lv, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.84 2010/06/06 18:08:41 schwarze Exp $ */
d67 2
d80 1
a80 2
static	void	  termp_fd_post(DECL_ARGS);
static	void	  termp_fn_post(DECL_ARGS);
a91 1
static	void	  termp_vt_post(DECL_ARGS);
d161 1
a161 1
	{ termp_bold_pre, termp_fd_post }, /* Fd */ 
d163 1
a163 1
	{ termp_fn_pre, termp_fn_post }, /* Fn */ 
d176 1
a176 1
	{ termp_vt_pre, termp_vt_post }, /* Vt */
d1054 1
a1054 2
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags)
		term_newln(p);
a1056 1

a1058 1

d1309 58
d1371 2
a1372 1
	if (MDOC_ELEM == n->type)
d1374 4
a1377 1
	else if (MDOC_HEAD == n->type)
a1378 2
	else if (MDOC_BLOCK == n->type)
		return(1);
a1384 14
static void
termp_vt_post(DECL_ARGS)
{

	if (MDOC_BLOCK != n->type)
		return;
	if (n->next && MDOC_Vt == n->next->tok)
		term_newln(p);
	else if (n->next)
		term_vspace(p);
}


/* ARGSUSED */
d1395 2
a1396 2
static void
termp_fd_post(DECL_ARGS)
d1399 2
a1400 1
	term_newln(p);
d1554 1
a1554 3
	if (SEC_SYNOPSIS == n->sec && n->prev)
		term_vspace(p);

d1566 1
a1566 7
	/* NB: MDOC_LINE has no effect on this macro! */
	if (SEC_SYNOPSIS == n->sec) {
		if (n->prev && MDOC_Ft == n->prev->tok)
			term_newln(p);
		else if (n->prev)
			term_vspace(p);
	}
a1593 11
static void
termp_fn_post(DECL_ARGS)
{

	/* NB: MDOC_LINE has no effect on this macro! */
	if (SEC_SYNOPSIS == n->sec)
		term_newln(p);
}


/* ARGSUSED */
d1858 1
a1859 1
	term_newln(p);
d1869 1
a1869 2
	if (SEC_SYNOPSIS == n->sec && n->prev && MDOC_In != n->prev->tok)
		term_vspace(p);
d1890 1
a1890 1
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags)
d1896 1
a1896 1
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags) {
a1897 2
		term_newln(p);
	}
d2008 1
a2008 7
		/* NB: MDOC_LINE has no effect on this macro! */
		if (SEC_SYNOPSIS != n->sec)
			return(1);
		if (n->prev && MDOC_Ft == n->prev->tok)
			term_newln(p);
		else if (n->prev)
			term_vspace(p);
d2032 7
a2038 5
	if (MDOC_BLOCK == n->type) {
		/* NB: MDOC_LINE has no effect on this macro! */
		if (SEC_SYNOPSIS == n->sec)
			term_newln(p);
	} else if (MDOC_BODY == n->type) {
d2040 1
a2040 5
		term_word(p, ")");
		if (SEC_SYNOPSIS == n->sec) {
			p->flags |= TERMP_NOSPACE;
			term_word(p, ";");
		}
@


1.84
log
@Merge bsd.lv release 1.10.0,
which is mostly the post-hackathon release,
bringing in the OpenBSD changes to bsd.lv,
but which also has a few additional minor fixes:

* .Lb is an in-line macro, not in_line_eoln
* .Bt, .Ud now warn when discarding arguments
* allow bad -man dates to flow verbatim into the front-ends
- so far all reported by Ulrich Spoerlein
* .Ar, .Fl and .Li starting with closing punctuation emit an empty element
* empty .Li macros print nothing, but may cause spacing
* proper EOS handling for .Bt, .Ex, .Rv, and .Ud.
* cleanup: collapse posts_xr into posts_wtext (which is the same)
* efficiency: very simple table lookup for roff.c
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.83 2010/05/24 00:37:01 schwarze Exp $ */
a80 1
static	void	  termp_ft_post(DECL_ARGS);
d164 1
a164 1
	{ termp_ft_pre, termp_ft_post }, /* Ft */ 
d258 1
d699 1
a699 1
		if (MDOC_BODY == n->type)
d714 5
d720 1
a720 1
				nn && i < (int)ncols; 
d873 12
a884 9
		if (MDOC_HEAD == n->type) {
			assert(n->next);
			if (MDOC_BODY == n->next->type)
				p->flags &= ~TERMP_NOBREAK;
			else
				p->flags |= TERMP_NOBREAK;
			if (n->prev) 
				p->flags |= TERMP_NOLPAD;
		}
d936 3
a938 3
		if (MDOC_HEAD == n->type &&
				MDOC_BODY == n->next->type &&
				p->rmargin < p->maxrmargin)
d992 1
a992 1
		if (MDOC_BODY == n->type)
d1024 1
a1024 1
		if (MDOC_HEAD == n->type)
a1355 3
	if (n->sec != SEC_SYNOPSIS || ! (MDOC_LINE & n->flags))
		return;

a1356 2
	if (n->next && MDOC_Fd != n->next->tok)
		term_vspace(p);
d1509 3
a1511 3
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags)
		if (n->prev && MDOC_Fo == n->prev->tok)
			term_vspace(p);
a1518 10
static void
termp_ft_post(DECL_ARGS)
{

	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags)
		term_newln(p);
}


/* ARGSUSED */
d1524 8
d1562 3
a1564 2
	if (n->sec == SEC_SYNOPSIS && n->next && MDOC_LINE & n->flags)
		term_vspace(p);
d1844 5
a1848 2
	term_fontpush(p, TERMFONT_BOLD);
	if (SEC_SYNOPSIS == n->sec)
d1850 5
a1855 1
	term_word(p, "<");
d1866 3
a1868 1
	term_fontpush(p, TERMFONT_BOLD);
a1870 1
	term_fontpop(p);
d1872 4
a1875 12
	if (SEC_SYNOPSIS != n->sec && ! (MDOC_LINE & n->flags))
		return;

	term_newln(p);
	/* 
	 * XXX Not entirely correct.  If `.In foo bar' is specified in
	 * the SYNOPSIS section, then it produces a single break after
	 * the <foo>; mandoc asserts a vertical space.  Since this
	 * construction is rarely used, I think it's fine.
	 */
	if (n->next && MDOC_In != n->next->tok)
		term_vspace(p);
a1983 1
	const struct mdoc_node *nn;
d1985 10
a1994 1
	if (MDOC_BODY == n->type) {
d1999 3
a2001 2
	} else if (MDOC_HEAD != n->type) 
		return(1);
d2003 2
d2006 1
a2006 6
	for (nn = n->child; nn; nn = nn->next) {
		assert(MDOC_TEXT == nn->type);
		term_word(p, nn->string);
	}
	term_fontpop(p);

d2016 12
a2027 7
	if (MDOC_BODY != n->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, ")");
	p->flags |= TERMP_NOSPACE;
	term_word(p, ";");
	term_newln(p);
@


1.83
log
@Fix the code to add a line break before .Nm in the SYNOPSIS;
patch from Joerg Sonnenberger;
this finally fixes the test(1) SYNOPSIS.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.82 2010/05/24 00:00:10 schwarze Exp $ */
d1191 1
d1224 1
d1426 1
d1447 1
@


1.82
log
@Increase performance by saving the list type in struct mdoc_node.
This will eventually be used so that mdoc_macro can know whether to
dump list line arguments into the body (`Bl -column' overflowing).
Remove a2list() and arg_listtype() because of this.

From kristaps@@.

While merging, fix a regression in mdoc_term.c, print_bvspace():
The bsd.lv version of this broke vertical spacing in .Bl -column.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.81 2010/05/23 22:45:01 schwarze Exp $ */
d1044 1
@


1.81
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.80 2010/05/15 21:09:53 schwarze Exp $ */
a59 1
static	int	  arg_listtype(const struct mdoc_node *);
a510 41
static int
arg_listtype(const struct mdoc_node *n)
{
	int		 i, len;

	assert(MDOC_BLOCK == n->type);

	len = (int)(n->args ? n->args->argc : 0);

	for (i = 0; i < len; i++) 
		switch (n->args->argv[i].arg) {
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Item):
			/* FALLTHROUGH */
		case (MDOC_Column):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			return(n->args->argv[i].arg);
		default:
			break;
		}

	return(-1);
}


d613 1
a613 1
	if (MDOC_Bl == bl->tok && arg_hasattr(MDOC_Column, bl))
d619 1
a619 1
	if (MDOC_Bl == bl->tok && arg_hasattr(MDOC_Diag, bl)) 
d663 1
a663 1
	int		        i, type, keys[3], vals[3];
d665 1
d684 1
a684 2
	type = arg_listtype(bl);
	assert(-1 != type);
d698 1
a698 1
	case (MDOC_Column):
d756 1
a756 1
	case (MDOC_Bullet):
d758 1
a758 1
	case (MDOC_Dash):
d760 1
a760 1
	case (MDOC_Hyphen):
d764 1
a764 1
	case (MDOC_Enum):
d768 1
a768 1
	case (MDOC_Hang):
d772 1
a772 1
	case (MDOC_Column):
d774 1
a774 1
	case (MDOC_Tag):
d790 1
a790 1
	case (MDOC_Diag):
d794 1
a794 1
	case (MDOC_Inset):
d805 1
a805 1
	case (MDOC_Diag):
d821 1
a821 1
	case (MDOC_Bullet):
d823 1
a823 1
	case (MDOC_Dash):
d825 1
a825 1
	case (MDOC_Enum):
d827 1
a827 1
	case (MDOC_Hyphen):
d833 1
a833 1
	case (MDOC_Hang):
d856 1
a856 1
	case (MDOC_Tag):
d867 1
a867 1
	case (MDOC_Column):
d878 1
a878 1
	case (MDOC_Diag):
d895 1
a895 1
	case (MDOC_Hang):
d906 1
a906 1
	case (MDOC_Bullet):
d908 1
a908 1
	case (MDOC_Dash):
d910 1
a910 1
	case (MDOC_Enum):
d912 1
a912 1
	case (MDOC_Hyphen):
d914 1
a914 1
	case (MDOC_Tag):
d921 1
a921 1
	case (MDOC_Column):
d944 1
a944 1
		case (MDOC_Bullet):
d949 1
a949 1
		case (MDOC_Dash):
d951 1
a951 1
		case (MDOC_Hyphen):
d956 1
a956 1
		case (MDOC_Enum):
d971 1
a971 1
	case (MDOC_Bullet):
d973 1
a973 1
	case (MDOC_Item):
d975 1
a975 1
	case (MDOC_Dash):
d977 1
a977 1
	case (MDOC_Hyphen):
d979 1
a979 1
	case (MDOC_Enum):
d983 1
a983 1
	case (MDOC_Column):
d999 1
a999 1
	int		   type;
d1004 1
a1004 2
	type = arg_listtype(n->parent->parent->parent);
	assert(-1 != type);
d1007 1
a1007 1
	case (MDOC_Item):
d1009 1
a1009 1
	case (MDOC_Diag):
d1011 1
a1011 1
	case (MDOC_Inset):
d1015 1
a1015 1
	case (MDOC_Column):
@


1.80
log
@More systematic output width handling by Joerg Sonnenberger:
* save and restore the output width when switching to MANT_LITERAL
* add an argument to ascii_alloc to specify the output width
* set the default output width to 80 minus 2 characters
* OpenBSD local: set the output width to 65 characters for -man
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.79 2010/05/15 18:25:51 schwarze Exp $ */
d26 1
d1086 2
d1095 1
d1220 1
a1220 1
	if (n->child->next)
d1259 1
a1259 1
	if (n->child->next)
@


1.79
log
@allow non-numeric manual sections in -mdoc;
while here, allow LIBRARY in section 9;
by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.78 2010/05/14 19:52:43 schwarze Exp $ */
d272 1
a272 1
	p->maxrmargin = 78;
@


1.78
log
@Integrate kristaps@@' end-of-sentence (EOS) framework
which is simpler and more powerful than mine, and remove mine.

* man(7) now has EOS handling, too
* put EOS detection into its own function in libmandoc
* use node and termp flags to communicate the EOS condition
* no more EOS pseudo-macro
* no more non-printable EOS marker character on the formatter level

This slightly breaks EOS detection after trailing punctuation
in mdoc(7) macros, but that will be restored soon.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.77 2010/05/14 14:47:44 schwarze Exp $ */
d425 1
a425 1
	snprintf(title, BUFSIZ, "%s(%d)", m->title, m->msec);
@


1.77
log
@Merge 1.9.25, keeping local patches;
this does not merge kristaps' end-of-sentences handling yet,
i will check that separately.  This one includes:
* handle \*(Ba as a delimiter
* introduce ARGS_PEND for .Bl -column .It end-of-line special casing
* section ordering: expect EXIT STATUS at the right place
* line break fixes in SYNOPSIS
* allow literal contexts to have arbitrary line lengths
* the input file column number can not be used to identify the beginning
  of a line because white space is allowed after the initial '.'
* proper leading spaces in -man -Tascii mode
* do not let Lb break lines in -mdoc -Thtml LIBRARY
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.76 2010/05/08 02:10:09 schwarze Exp $ */
a135 1
static	int	  termp_eos_pre(DECL_ARGS);
a258 1
	{ termp_eos_pre, NULL }, /* eos */
d337 3
a2167 12
	return(1);
}


/* ARGSUSED */
static int
termp_eos_pre(DECL_ARGS)
{
	const char ascii_eos[2] = { ASCII_EOS, 0 };

	term_word(p, ascii_eos);
	p->flags |= TERMP_NOSPACE;
@


1.76
log
@sync to bsd.lv mdoc_term.c 1.117, mdoc_html.c 1.61:
fixed %T: it now correctly underlines, instead of quoting;
noted by jmc@@, fixed by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.75 2010/04/23 00:23:46 schwarze Exp $ */
d21 1
d58 1
d482 29
d1084 1
a1084 1
	if (SEC_SYNOPSIS == n->sec)
d1159 1
a1159 1
	if (arg_getattr(MDOC_Split, n) > -1) {
d1383 1
a1383 1
	if (n->sec != SEC_SYNOPSIS)
d1470 1
a1470 1
	if (SEC_LIBRARY == n->sec)
d1539 1
a1539 1
	if (SEC_SYNOPSIS == n->sec)
d1553 1
a1553 1
	if (SEC_SYNOPSIS == n->sec)
d1594 1
a1594 1
	if (n->sec == SEC_SYNOPSIS && n->next)
d1632 1
d1643 5
a1647 20
	for (type = -1, i = 0; i < (int)nn->args->argc; i++) {
		switch (nn->args->argv[i].arg) {
		case (MDOC_Centred):
			/* FALLTHROUGH */
		case (MDOC_Ragged):
			/* FALLTHROUGH */
		case (MDOC_Filled):
			/* FALLTHROUGH */
		case (MDOC_Unfilled):
			/* FALLTHROUGH */
		case (MDOC_Literal):
			type = nn->args->argv[i].arg;
			break;
		case (MDOC_Offset):
			p->offset += a2offs(&nn->args->argv[i]);
			break;
		default:
			break;
		}
	}
a1656 1
	assert(type > -1);
d1662 4
d1676 2
d1686 2
d1691 10
d1703 3
d1895 1
a1895 1
	if (SEC_SYNOPSIS != n->sec)
@


1.75
log
@Handle literal tab characters both in literal context (.Bd -literal)
and outside.  In literal context, tab stops are at each eigth column;
outside, they are at each fifth column.

Use tabwidth = 5 as the default and temporarily switch to 8 in termp_bd_pre().
This requires to move the term_flushln() of the final line of a display from
termp_bd_post() to termp_bd_pre(); the former still needs term_newln()
to handle the final lines of non-literal displays.

Handling inside term_flushln() is tricky because a tab collapses with
inter-word spacing, but not with another tab.

Missing feature reported independently by jmc@@ and deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.74 2010/04/12 22:52:19 schwarze Exp $ */
a91 1
static	int	  termp__t_pre(DECL_ARGS);
d187 1
a187 1
	{ termp__t_pre, termp____post }, /* %T */
a2082 8
	switch (n->tok) {
	case (MDOC__T):
		term_word(p, "\\(rq");
		p->flags |= TERMP_NOSPACE;
		break;
	default:
		break;
	}
a2129 11
	return(1);
}


/* ARGSUSED */
static int
termp__t_pre(DECL_ARGS)
{

	term_word(p, "\\(lq");
	p->flags |= TERMP_NOSPACE;
@


1.74
log
@Partial revert of term.c rev. 1.23
because jmc@@ noticed that it broke blank lines in literal displays.

The original idea was to suppress stray blank lines.
But we don't want to suppress *all* blank lines,
instead just those caused by nested lists.
So do the check whether there was any output on this line,
i.e. whether or not to break the line,
at the right place, which is after processing the .It body.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.73 2010/04/07 23:15:05 schwarze Exp $ */
d274 1
d1600 1
d1645 2
d1650 3
a1652 5
		if (NULL == nn->next)
			continue;
		if (nn->prev && nn->prev->line < nn->line)
			term_flushln(p);
		else if (NULL == nn->prev)
d1655 1
d1669 1
a1669 1
	term_flushln(p);
@


1.73
log
@Merge the good parts of 1.9.23,
avoid the bad parts of 1.9.23, and keep local patches.

Input in general:
 * Basic handling of roff-style font escapes \f, \F.
 * Quoted punctuation does not count as punctuation.

mdoc(7) parser:
 * Make .Pf callable; noted by Claus Assmann.
 * Let .Bd and .Bl ignore unknown arguments; noted by deraadt@@.
 * Do not warn when .Er is used outside certain sections.
 * Replace mdoc_node_free[list] by mdoc_node_delete.
 * Replace #define by enum for rew*() return values.

man(7) parser:
 * When .TH is missing, use default section and date.

Output in general:
 * Curly braces do not count as punctuation.
 * No space after .Fl w/o args when a macro follows on the same line.

HTML output:
 * Unify PAIR_*_INIT macros, introduce new PAIR_ID_INIT().
 * Print whitespace after, not before .Vt .Fn .Ft .Fo.

Checked that all manuals in base still build.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.72 2010/04/03 17:06:19 schwarze Exp $ */
d1023 1
a1023 1
			term_flushln(p);
d1030 1
a1030 1
		term_flushln(p);
@


1.72
log
@no need to die from .Xr without arguments, we can just ignore it

ok deraadt@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.71 2010/03/26 01:22:05 schwarze Exp $ */
d98 1
d149 1
a149 1
	{ NULL, termp_bl_post }, /* Bl */
d204 1
a204 1
	{ NULL, NULL }, /* Ec */
a1071 2
	/* A blank `Fl' should incur a subsequent space. */

d1074 2
d1252 9
d1605 2
a1606 2
	} else if (MDOC_BODY != n->type)
		return(1);
@


1.71
log
@merge 1.9.17, keeping local patches

* much improved pod2man support and low-level roff robustness
* have -Tlint imply -Wall and -fstrict
* use fewer macros and more enum in libman
* and various bug fixes
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.70 2010/03/02 00:38:59 schwarze Exp $ */
d1278 4
a1281 1
	assert(n->child && MDOC_TEXT == n->child->type);
@


1.70
log
@Proper inter-sentence spacing for mdoc(7).
When a text line or a non-block macro line in the source code ends
in any of ".!?", consider that an end of sentence (EOS).
This makes Jason's rule "new sentence, new line" even more important.
Let the parser detect the EOS and insert a token into the AST.
Let the -Tascii frontend render the EOS token as a double space before
the next word.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.69 2010/02/18 02:11:26 schwarze Exp $ */
d270 3
@


1.69
log
@sync to release 1.9.15:
 * corrected .Vt handling (spotted by Joerg Sonnenberger)
 * corrected .Xr argument handling (based on my patch)
 * removed \\ escape sequence (because it is for low-level roff only)
 * warn about trailing whitespace (suggested by jmc@@)
 * -Txhtml support
 * and some general cleanup and doc improvements
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.68 2010/01/02 02:42:06 schwarze Exp $ */
d134 1
d258 1
d2130 12
@


1.68
log
@complete the sync to 1.9.15-pre2: mostly minor fixes
 * bugfix: do not restore TERMP flags when leaving lists, just reset them
 * and a few HTML fixes
 * clarity: return width from a2width, not width+2, and adapt to it
 * manual: document .Bl and .Fl
 * portability: no need to escape '%' in macro names
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.67 2010/01/01 23:28:03 schwarze Exp $ */
d131 1
d175 1
a175 1
	{ termp_under_pre, termp_vt_post }, /* Vt */
d1290 15
d1310 1
a1310 1
	if (n->sec != SEC_SYNOPSIS)
@


1.67
log
@When a .Fl macro without an argument is followed by text,
we need a space in between;
patch by kristaps@@, rev. 1.103 and 1.104;
fixes regress/usr.bin/mandoc/mdoc/Fl/noarg.in.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.104 2010/01/01 13:35:30 kristaps Exp $ */
a35 1
	int	  	  flag;	
d468 1
a468 6
	/*
	 * This is a bit if a magic number on groff's part.  Be careful
	 * in changing it, as the MDOC_Column handler will subtract one
	 * from this for >5 columns (don't go below zero!).
	 */
	return(term_hspan(&su) + 2);
d533 4
d545 4
d558 6
d583 5
d666 1
a666 2
	size_t		        width, offset, ncols;
	int			dcol;
d675 1
a675 5
	/* Save parent attributes. */

	pair->flag = p->flags;

	/* Get list width and offset. */
d683 1
a683 3
	width = offset = 0;

	(void)arg_getattrs(keys, vals, 3, bl);
d688 8
a698 2
	/* Calculate real width and offset. */

a702 1

d704 7
a710 6
		 * Imitate groff's column handling.
		 * For each earlier column, add its width.
		 * For less than 5 columns, add two more blanks per column.
		 * For exactly 5 columns, add only one more blank per column.
		 * For more than 5 columns, SUBTRACT one column.  We can
		 * do this because a2width() pads exactly 2 spaces.
d713 9
a721 4
		dcol = ncols < 5 ? 2 : ncols == 5 ? 1 : -1;
		for (i=0, nn=n->prev; nn && i < (int)ncols; nn=nn->prev, i++)
			offset += a2width(&bl->args->argv[vals[2]], i) + 
				(size_t)dcol;
d724 4
a727 2
		 * Use the declared column widths,
		 * extended as explained in the preceding paragraph.
d729 2
a730 3
		if (i < (int)ncols)
			width = a2width(&bl->args->argv[vals[2]], i) + 
				(size_t)dcol;
d733 2
a734 4
		 * When exceeding the declared number of columns,
		 * leave the remaining widths at 0.
		 * This will later be adjusted to the default width of 10,
		 * or, for the last column, stretched to the right margin.
d736 1
d739 9
a747 2
		if (vals[0] >= 0) 
			width = a2width(&bl->args->argv[vals[0]], 0);
d816 4
a819 5
	 * Pad and break control.  This is the tricker part.  Lists with
	 * set right-margins for the head get TERMP_NOBREAK because, if
	 * they overrun the margin, they wrap to the new margin.
	 * Correspondingly, the body for these types don't left-pad, as
	 * the head will pad out to to the right.
d960 1
a960 1
			(void)snprintf(buf, sizeof(buf), "%d.", 
d1003 1
a1003 1
	if (MDOC_BODY != n->type && MDOC_HEAD != n->type)
d1027 11
a1037 1
	p->flags = pair->flag;
d2018 1
a2018 1
	if (0 == strcmp("on", n->child->string)) {
d2020 1
a2020 2
		p->flags &= ~TERMP_NOSPACE;
	} else
@


1.66
log
@Fix .Bl -column horizontal spacing to agree with groff.
My original patch nicely improved by and OK kristaps@@;
merged upstream as rev. 1.105, 1.106.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.106 2010/01/01 14:32:52 kristaps Exp $ */
d1031 6
a1036 1
	p->flags |= TERMP_NOSPACE;
@


1.65
log
@sync to 1.9.14: rewrite escape sequence handling:
- new function a2roffdeco
- font modes (\f) only affect the current stack point
- implement scaling (\s)
- implement space suppression (\c)
- implement non-breaking space (\~) in -Tascii
- many manual improvements
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.64 2009/12/23 22:30:17 schwarze Exp $ */
d469 5
a473 1
	/* XXX: pachemu? */
d653 2
a654 1
	size_t		        width, offset;
d682 3
d691 18
a708 8
		/* 
		 * Work around groff's column handling.  The offset is
		 * equal to the sum of all widths leading to the current
		 * column (plus the -offset value).  If this column
		 * exceeds the stated number of columns, the width is
		 * set as 0, else it's the stated column width (later
		 * the 0 will be adjusted to default 10 or, if in the
		 * last column case, set to stretch to the margin).
d710 3
a712 11
		for (i = 0, nn = n->prev; nn && 
				i < (int)bl->args->argv[vals[2]].sz; 
				nn = nn->prev, i++)
			offset += a2width 
				(&bl->args->argv[vals[2]], i);

		/* Whether exceeds maximum column. */
		if (i < (int)bl->args->argv[vals[2]].sz)
			width = a2width(&bl->args->argv[vals[2]], i);
		else
			width = 0;
d714 6
a719 2
		if (vals[1] >= 0) 
			offset += a2offs(&bl->args->argv[vals[1]]);
a723 2
		if (vals[1] >= 0) 
			offset += a2offs(&bl->args->argv[vals[1]]);
d908 2
a909 1
				MDOC_BODY == n->next->type)
@


1.64
log
@sync to 1.9.13: minor fixes:

correctness/functionality:
 - bugfix: properly ignore lines with only a dot in -man
 - bugfix: .Bl -ohang doesn't allow -width, warn about this
 - improve date string handling by new function mandoc_a2time
 - some HTML improvements
 - significant documentation additions in man.7 and mdoc.7

portability:
 - replace __dead by __attribute__((noreturn))
 - bugfix: correct .Dx rendering
 - some more library names for NetBSD

simplicity:
 - replace hand-rolled putchar(3)-loops by fwrite(3)
 - replace single-character printf(3) by putchar(3)
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.63 2009/12/22 23:58:00 schwarze Exp $ */
d62 3
a64 3
static	void  	  print_node(DECL_ARGS);
static	void	  print_head(DECL_ARGS);
static	void	  print_body(DECL_ARGS);
d114 1
d166 1
a166 1
	{ NULL, NULL }, /* Li */
d282 1
a282 1
	print_head(p, NULL, m, n);
d284 1
a284 1
		print_body(p, NULL, m, n->child);
d290 1
a290 1
print_body(DECL_ARGS)
d293 1
a293 1
	print_node(p, pair, m, n);
d295 1
a295 1
		print_body(p, pair, m, n->next);
d301 1
a301 1
print_node(DECL_ARGS)
d303 2
a304 1
	int		 chld, bold, under;
d311 1
a311 2
	bold = p->bold;
	under = p->under;
d321 1
d323 1
a323 1
		print_body(p, &npair, m, n->child);
d325 1
a325 8
	/*
	 * XXX - if bold/under were to span scopes, this wouldn't be
	 * possible, but because decoration is always in-scope, we can
	 * get away with this.
	 */

	p->bold = bold;
	p->under = under;
d342 2
a384 1
/* FIXME: put in utility library. */
d387 1
a387 1
print_head(DECL_ARGS)
d773 1
a773 1
			p->bold++;
d911 1
a911 1
			p->bold++;
d913 1
a913 1
			p->bold--;
d918 1
a918 1
			p->bold++;
d920 1
a920 1
			p->bold--;
d1002 3
a1004 1
	p->bold++;
d1016 1
a1016 1
	p->bold++;
d1114 1
a1114 1
		p->bold++;
d1116 1
a1116 1
		p->bold--;
d1134 1
a1134 1
	p->under++;
d1136 1
a1136 1
	p->under--;
d1153 1
a1153 1
		p->bold++;
d1155 1
a1155 1
		p->bold--;
d1257 1
a1257 1
	p->bold++;
d1291 1
a1291 1
		p->bold++;
d1426 2
a1427 1
	p->under++;
d1448 1
a1448 1
	p->bold++;
d1450 1
a1450 1
	p->bold--;
d1456 1
a1456 1
		p->under++;
d1458 2
a1459 1
		p->under--;
d1490 1
a1490 1
		p->under++;
d1495 1
a1495 1
		p->under++;
d1497 2
a1498 1
		p->under--;
d1560 1
a1560 1
		print_node(p, pair, m, nn);
d1714 1
a1714 1
		p->bold++;
d1740 1
a1740 1
	p->bold++;
d1751 1
a1751 1
	p->bold++;
d1766 1
a1766 1
	p->bold++;
d1769 1
a1769 1
	p->bold--;
d1901 1
a1901 1
	p->bold++;
d1906 1
a1906 1
	p->bold--;
d1940 1
a1940 1
			p->under++;
d1942 3
a1944 1
			p->bold++;
d1951 1
a1951 1
		p->under++;
d1953 3
a1955 1
		p->bold++;
d2011 10
d2025 1
a2025 1
	p->under++;
d2032 1
a2032 1
	p->under--;
d2037 1
a2037 1
	p->bold++;
d2040 1
a2040 1
	p->bold--;
d2051 1
a2051 1
	p->under++;
@


1.63
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.62 2009/10/27 21:40:07 schwarze Exp $ */
d1632 1
a1632 1
		pp = "DragonFlyBSD";
@


1.62
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.61 2009/10/21 19:13:50 schwarze Exp $ */
a20 1
#include <err.h>
d312 1
a312 1
	bzero(&npair, sizeof(struct termpair));
d345 1
a345 2
	char		 buf[DATESIZ];
	char		*os;
a354 3
	if (NULL == (os = malloc(p->rmargin)))
		err(EXIT_FAILURE, "malloc");

d356 1
a356 2

	(void)strlcpy(os, m->os, p->rmargin);
a384 2

	free(os);
d393 1
a393 1
	char		*buf, *title;
a397 5
	if (NULL == (buf = malloc(p->rmargin)))
		err(EXIT_FAILURE, "malloc");
	if (NULL == (title = malloc(p->rmargin)))
		err(EXIT_FAILURE, "malloc");

d412 1
a412 1
	(void)strlcpy(buf, m->vol, p->rmargin);
d415 3
a417 3
		(void)strlcat(buf, " (", p->rmargin);
		(void)strlcat(buf, m->arch, p->rmargin);
		(void)strlcat(buf, ")", p->rmargin);
d420 1
a420 1
	snprintf(title, p->rmargin, "%s(%d)", m->title, m->msec);
a446 3

	free(title);
	free(buf);
@


1.61
log
@sync to 1.9.9, featuring:
 * -Thtml output mode
 * roff scaling units
 * and some minor fixes
for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.60 2009/10/19 21:35:43 schwarze Exp $ */
d51 17
d256 1
a258 17
static	size_t	  arg2width(const struct mdoc_argv *, int);
static	size_t	  arg2height(const struct mdoc_node *);
static	size_t	  arg2offs(const struct mdoc_argv *);

static	int	  arg_hasattr(int, const struct mdoc_node *);
static	int	  arg_getattrs(const int *, int *, size_t,
			const struct mdoc_node *);
static	int	  arg_getattr(int, const struct mdoc_node *);
static	int	  arg_listtype(const struct mdoc_node *);
static	void	  print_bvspace(struct termp *,
			const struct mdoc_node *,
			const struct mdoc_node *);
static	void  	  print_node(DECL_ARGS);
static	void	  print_head(DECL_ARGS);
static	void	  print_body(DECL_ARGS);
static	void	  print_foot(DECL_ARGS);

d346 2
a347 2
	struct tm	*tm;
	char		*buf, *os;
a356 2
	if (NULL == (buf = malloc(p->rmargin)))
		err(EXIT_FAILURE, "malloc");
d360 1
a360 4
	tm = localtime(&m->date);

	if (0 == strftime(buf, p->rmargin, "%B %e, %Y", tm))
		err(EXIT_FAILURE, "strftime");
a391 1
	free(buf);
d467 1
a467 1
arg2height(const struct mdoc_node *n)
d481 1
a481 1
arg2width(const struct mdoc_argv *arg, int pos)
d536 1
a536 1
arg2offs(const struct mdoc_argv *arg)
d715 1
a715 1
			offset += arg2width 
d720 1
a720 1
			width = arg2width(&bl->args->argv[vals[2]], i);
d725 1
a725 1
			offset += arg2offs(&bl->args->argv[vals[1]]);
d729 1
a729 1
			width = arg2width(&bl->args->argv[vals[0]], 0);
d731 1
a731 1
			offset += arg2offs(&bl->args->argv[vals[1]]);
d1554 1
a1554 1
			p->offset += arg2offs(&nn->args->argv[i]);
d1809 1
a1809 1
		len = n->child ? arg2height(n->child) : 1;
d2005 2
d2026 4
a2029 2
	if (NULL == (nn = n->child->next)) {
		p->under++;
a2030 1
	}
a2031 1
	p->under++;
d2033 2
a2036 1
	p->under--;
@


1.60
log
@sync to 1.9.7: kristaps@@ renamed part of the DECL_ARGS :-(
intricately mixed with three minor .Bd fixes
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.59 2009/10/19 16:51:08 schwarze Exp $ */
d26 1
d29 2
a30 35

/* FIXME: check HANG lists: they seem to be broken... :
 * .Bl -hang -width Ds
 * .It a
 * b
 * .It Fl f Ns Ar option...
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * .
 * .It a sasd fasd as afsd sfad sfds sadfs sd sfd ssfad asfd
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * .El
 *
 */
d241 4
a248 2
static	size_t	  arg_offset(const struct mdoc_argv *);
static	size_t	  arg_width(const struct mdoc_argv *, int);
d250 1
a250 1
static	void	  fmt_block_vspace(struct termp *,
d260 1
a260 1
mdoc_run(struct termp *p, const struct mdoc *mdoc)
d264 13
a470 1
/* FIXME: put in utility file for front-ends. */
d472 1
a472 1
arg_width(const struct mdoc_argv *arg, int pos)
d474 1
a474 2
	int		 i, len;
	const char	*p;
d476 4
a479 2
	assert(pos < (int)arg->sz && pos >= 0);
	assert(arg->value[pos]);
d481 2
a482 1
	p = arg->value[pos];
a483 2
	if (0 == (len = (int)strlen(p)))
		return(0);
d485 4
a488 3
	for (i = 0; i < len - 1; i++) 
		if ( ! isdigit((u_char)p[i]))
			break;
d490 3
a492 3
	if (i == len - 1) 
		if ('n' == p[len - 1] || 'm' == p[len - 1])
			return((size_t)atoi(p) + 2);
d494 2
a495 1
	return((size_t)len + 2);
a498 1
/* FIXME: put in utility file for front-ends. */
a539 1
/* FIXME: put in utility file for front-ends. */
d541 1
a541 1
arg_offset(const struct mdoc_argv *arg)
d543 1
a543 2
	int		 len, i;
	const char	*p;
d545 3
a547 4
	assert(*arg->value);
	p = *arg->value;

	if (0 == strcmp(p, "left"))
d549 1
a549 1
	if (0 == strcmp(p, "indent"))
d551 1
a551 1
	if (0 == strcmp(p, "indent-two"))
d553 2
d556 1
a556 12
	if (0 == (len = (int)strlen(p)))
		return(0);

	for (i = 0; i < len - 1; i++) 
		if ( ! isdigit((u_char)p[i]))
			break;

	if (i == len - 1) 
		if ('n' == p[len - 1] || 'm' == p[len - 1])
			return((size_t)atoi(p));

	return((size_t)len);
a595 1
/* ARGSUSED */
d597 1
a597 1
fmt_block_vspace(struct termp *p, 
d677 1
a677 1
		fmt_block_vspace(p, n->parent->parent, n);
d720 1
a720 1
			offset += arg_width 
d725 1
a725 1
			width = arg_width(&bl->args->argv[vals[2]], i);
d730 1
a730 1
			offset += arg_offset(&bl->args->argv[vals[1]]);
d734 1
a734 1
			width = arg_width(&bl->args->argv[vals[0]], 0);
d736 1
a736 1
			offset += arg_offset(&bl->args->argv[vals[1]]);
d1538 1
a1538 1
		fmt_block_vspace(p, n, n);
d1547 2
d1559 1
a1559 1
			p->offset += arg_offset(&nn->args->argv[i]);
d1810 1
a1810 1
	int		 i, len;
d1814 1
a1814 1
		len = n->child ? atoi(n->child->string) : 1;
@


1.59
log
@sync to 1.9.6: minor fixes:
 * avoid blank character before the closing ">" of .In
 * .Bt can not have children
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.58 2009/10/19 16:27:52 schwarze Exp $ */
d75 2
a76 2
	  	  const struct mdoc_meta *meta, \
		  const struct mdoc_node *node
d309 3
a311 3
	print_node(p, pair, meta, node);
	if (node->next)
		print_body(p, pair, meta, node->next);
d332 3
a334 4
	if (MDOC_TEXT != node->type) {
		if (termacts[node->tok].pre)
			chld = (*termacts[node->tok].pre)
				(p, &npair, meta, node);
d336 3
a338 4
		term_word(p, node->string);

	if (chld && node->child)
		print_body(p, &npair, meta, node->child);
d349 3
a351 4
	if (MDOC_TEXT != node->type)
		if (termacts[node->tok].post)
			(*termacts[node->tok].post)
				(p, &npair, meta, node);
d378 1
a378 1
	tm = localtime(&meta->date);
d383 1
a383 1
	(void)strlcpy(os, meta->os, p->rmargin);
d446 2
a447 2
	assert(meta->vol);
	(void)strlcpy(buf, meta->vol, p->rmargin);
d449 1
a449 1
	if (meta->arch) {
d451 1
a451 1
		(void)strlcat(buf, meta->arch, p->rmargin);
d455 1
a455 1
	snprintf(title, p->rmargin, "%s(%d)", meta->title, meta->msec);
d629 1
a629 1
		const struct mdoc_node *node)
d631 1
a631 1
	const struct mdoc_node *n;
d634 1
a634 2

	if (MDOC_Bl == bl->tok && arg_hasattr(MDOC_Compact, bl))
a635 1
	assert(node);
d637 1
a637 4
	/*
	 * Search through our prior nodes.  If we follow a `Ss' or `Sh',
	 * then don't vspace.
	 */
d639 2
a640 2
	for (n = node; n; n = n->parent) {
		if (MDOC_BLOCK != n->type)
d642 1
a642 1
		if (MDOC_Ss == n->tok)
d644 1
a644 1
		if (MDOC_Sh == n->tok)
d646 1
a646 1
		if (NULL == n->prev)
d651 1
a651 4
	/* 
	 * XXX - not documented: a `-column' does not ever assert vspace
	 * within the list.
	 */
d654 1
a654 1
		if (node->prev && MDOC_It == node->prev->tok)
d657 2
a658 4
	/*
	 * XXX - not documented: a `-diag' without a body does not
	 * assert a vspace prior to the next element. 
	 */
d660 3
a662 3
		if (node->prev && MDOC_It == node->prev->tok) {
			assert(node->prev->body);
			if (NULL == node->prev->body->child)
d675 1
a675 1
	if (MDOC_BODY != node->type)
d689 1
a689 1
	if (MDOC_BODY != node->type)
d701 1
a701 1
	const struct mdoc_node *bl, *n;
d706 2
a707 2
	if (MDOC_BLOCK == node->type) {
		fmt_block_vspace(p, node->parent->parent, node);
d711 1
a711 1
	bl = node->parent->parent->parent;
d736 1
a736 1
		if (MDOC_BODY == node->type)
d747 1
a747 1
		for (i = 0, n = node->prev; n && 
d749 1
a749 1
				n = n->prev, i++)
d812 1
a812 1
		if (MDOC_BODY == node->type)
d816 1
a816 1
		if (MDOC_BODY == node->type) 
d827 1
a827 1
		if (MDOC_HEAD == node->type)
d850 1
a850 1
		if (MDOC_HEAD == node->type)
d856 1
a856 1
		if (MDOC_HEAD == node->type)
d861 1
a861 1
		if (MDOC_HEAD != node->type)
d870 3
a872 3
		if (node->next->child && 
				(MDOC_Bl == node->next->child->tok ||
				 MDOC_Bd == node->next->child->tok)) {
d879 1
a879 1
		if (MDOC_HEAD == node->type)
d884 1
a884 1
		if (MDOC_HEAD != node->type)
d886 1
a886 1
		if (NULL == node->next || NULL == node->next->child)
d890 3
a892 3
		if (MDOC_HEAD == node->type) {
			assert(node->next);
			if (MDOC_BODY == node->next->type)
d896 1
a896 1
			if (node->prev) 
d901 1
a901 1
		if (MDOC_HEAD == node->type)
d923 3
a925 3
		if (MDOC_HEAD == node->type && node->next->child &&
				(MDOC_Bl == node->next->child->tok || 
				 MDOC_Bd == node->next->child->tok))
d938 1
a938 1
		if (MDOC_HEAD == node->type)
d950 2
a951 2
		if (MDOC_HEAD == node->type &&
				MDOC_BODY == node->next->type)
d963 1
a963 1
	if (MDOC_HEAD == node->type)
d1001 1
a1001 1
		if (MDOC_HEAD == node->type)
d1005 1
a1005 1
		if (MDOC_BODY == node->type)
d1022 1
a1022 1
	if (MDOC_BODY != node->type && MDOC_HEAD != node->type)
d1025 1
a1025 1
	type = arg_listtype(node->parent->parent->parent);
d1034 1
a1034 1
		if (MDOC_BODY == node->type)
d1038 1
a1038 1
		if (MDOC_HEAD == node->type)
d1055 1
a1055 1
	if (SEC_SYNOPSIS == node->sec)
d1058 2
a1059 2
	if (NULL == node->child)
		term_word(p, meta->name);
d1081 1
a1081 1
	if (NULL == node->child)
d1085 6
a1090 7
	 * XXX: this is poorly documented.  If not in the AUTHORS
	 * section, `An -split' will cause newlines to occur before the
	 * author name.  If in the AUTHORS section, by default, the
	 * first `An' invocation is nosplit, then all subsequent ones,
	 * regardless of whether interspersed with other macros/text,
	 * are split.  -split, in this case, will override the condition
	 * of the implied first -nosplit.
d1093 1
a1093 1
	if (node->sec == SEC_AUTHORS) {
d1117 2
a1118 2
	if (node->child) {
		if (SEC_AUTHORS == node->sec)
d1123 1
a1123 1
	if (arg_getattr(MDOC_Split, node) > -1) {
d1149 1
a1149 1
	if (SEC_SEE_ALSO != node->sec)
d1151 1
a1151 1
	if (MDOC_BLOCK == node->type && node->prev)
d1166 1
a1166 3
	nn = node->child;
	assert(nn);
	for ( ; nn; nn = nn->next) {
d1179 1
a1179 1
	if (node->child->next)
d1205 1
a1205 3
	nn = node->child;
	assert(nn);
	for ( ; nn; nn = nn->next) {
d1218 1
a1218 1
	if (node->child->next)
d1234 1
a1234 1
	if (MDOC_BODY != node->type)
d1251 1
a1251 1
	if (MDOC_BLOCK == node->type)
d1261 1
a1261 1
	if (MDOC_BODY != node->type) 
d1272 1
a1272 1
	const struct mdoc_node *n;
d1274 2
a1275 2
	assert(node->child && MDOC_TEXT == node->child->type);
	n = node->child;
d1277 2
a1278 2
	term_word(p, n->string);
	if (NULL == (n = n->next)) 
d1283 1
a1283 1
	term_word(p, n->string);
d1286 1
d1296 1
a1296 1
	if (node->sec != SEC_SYNOPSIS)
d1298 1
a1298 1
	if (node->next && MDOC_Vt == node->next->tok)
d1300 1
a1300 1
	else if (node->next)
d1320 1
a1320 1
	if (node->sec != SEC_SYNOPSIS)
d1324 1
a1324 1
	if (node->next && MDOC_Fd != node->next->tok)
d1333 4
a1336 5
	/* 
	 * XXX: undocumented: using two `Sh' macros in sequence has no
	 * vspace between calls, only a newline.
	 */
	switch (node->type) {
d1338 2
a1339 2
		if (node->prev && MDOC_Sh == node->prev->tok)
			if (NULL == node->prev->body->child)
d1361 1
a1361 1
	switch (node->type) {
d1380 1
a1380 1
	switch (node->type) {
d1407 1
a1407 1
	if (SEC_LIBRARY == node->sec)
d1418 1
a1418 1
	return(1);
d1427 1
a1427 1
	if (MDOC_BLOCK != node->type)
d1440 1
a1440 1
	if (MDOC_BLOCK != node->type) 
d1451 1
a1451 1
	if (MDOC_BODY != node->type)
d1464 1
a1464 1
	if (MDOC_BODY != node->type)
d1476 2
a1477 2
	if (SEC_SYNOPSIS == node->sec)
		if (node->prev && MDOC_Fo == node->prev->tok)
d1489 1
a1489 1
	if (SEC_SYNOPSIS == node->sec)
d1498 1
a1498 1
	const struct mdoc_node *n;
d1501 1
a1501 1
	term_word(p, node->child->string);
d1507 1
a1507 1
	for (n = node->child->next; n; n = n->next) {
d1509 1
a1509 1
		term_word(p, n->string);
d1511 1
a1511 1
		if (n->next)
d1517 1
a1517 1
	if (SEC_SYNOPSIS == node->sec)
d1529 1
a1529 1
	if (node->sec == SEC_SYNOPSIS && node->next)
d1538 1
a1538 1
	struct mdoc_node *n;
d1540 1
a1540 1
	if (node->parent->tok != MDOC_Fo) {
d1545 1
a1545 1
	for (n = node->child; n; n = n->next) {
d1547 1
a1547 1
		term_word(p, n->string);
d1549 1
a1549 1
		if (n->next)
d1553 1
a1553 1
	if (node->child && node->next && node->next->tok == MDOC_Fa)
d1564 2
a1565 1
	int	         i, type;
d1567 2
a1568 13
	/*
	 * This is fairly tricky due primarily to crappy documentation.
	 * If -ragged or -filled are specified, the block does nothing
	 * but change the indentation.
	 *
	 * If, on the other hand, -unfilled or -literal are specified,
	 * then the game changes.  Text is printed exactly as entered in
	 * the display: if a macro line, a newline is appended to the
	 * line.  Blank lines are allowed.
	 */

	if (MDOC_BLOCK == node->type) {
		fmt_block_vspace(p, node, node);
d1570 1
a1570 1
	} else if (MDOC_BODY != node->type)
d1573 1
a1573 1
	assert(node->parent->args);
d1575 2
a1576 3
	for (type = -1, i = 0; -1 == type && 
			i < (int)node->parent->args->argc; i++) {
		switch (node->parent->args->argv[i].arg) {
d1584 4
a1587 1
			type = node->parent->args->argv[i].arg;
d1593 8
d1603 1
a1603 11

	i = arg_getattr(MDOC_Offset, node->parent);
	if (-1 != i)
		p->offset += arg_offset(&node->parent->args->argv[i]);

	switch (type) {
	case (MDOC_Literal):
		/* FALLTHROUGH */
	case (MDOC_Unfilled):
		break;
	default:
a1604 1
	}
d1606 1
a1606 1
	for (node = node->child; node; node = node->next) {
d1608 6
a1613 2
		print_node(p, pair, meta, node);
		if (node->next)
d1626 1
a1626 1
	if (MDOC_BODY != node->type) 
d1638 1
a1638 1
	if (MDOC_BODY != node->type)
d1651 1
a1651 1
	if (MDOC_BODY != node->type)
d1663 1
a1663 1
	if (node->child)
d1676 1
a1676 1
	switch (node->tok) {
d1710 1
a1710 1
	if (MDOC_BODY != node->type)
d1723 1
a1723 1
	if (MDOC_BODY != node->type)
d1755 1
a1755 1
	switch (node->type) {
d1758 1
a1758 1
		if (node->prev)
d1778 1
a1778 1
	if (MDOC_HEAD == node->type)
d1800 1
a1800 1
	if (SEC_SYNOPSIS == node->sec)
d1819 1
a1819 1
	if (SEC_SYNOPSIS != node->sec)
d1829 1
a1829 1
	if (node->next && MDOC_In != node->next->tok)
d1840 1
a1840 1
	switch (node->tok) {
d1842 1
a1842 1
		len = node->child ? atoi(node->child->string) : 1;
d1866 1
a1866 1
	if (MDOC_BODY != node->type)
d1879 1
a1879 1
	if (MDOC_BODY != node->type)
d1891 1
a1891 1
	if (MDOC_BODY != node->type)
d1904 1
a1904 1
	if (MDOC_BODY != node->type)
d1916 1
a1916 1
	if (MDOC_BODY != node->type)
d1929 1
a1929 1
	if (MDOC_BODY != node->type)
d1939 1
a1939 1
	const struct mdoc_node *n;
d1941 1
a1941 1
	if (MDOC_BODY == node->type) {
d1946 1
a1946 1
	} else if (MDOC_HEAD != node->type) 
d1950 3
a1952 3
	for (n = node->child; n; n = n->next) {
		assert(MDOC_TEXT == n->type);
		term_word(p, n->string);
d1965 1
a1965 1
	if (MDOC_BODY != node->type)
d1979 1
a1979 1
	const struct mdoc_node	*n;
d1981 1
a1981 1
	if (MDOC_HEAD == node->type)
d1983 1
a1983 1
	else if (MDOC_BLOCK != node->type)
d1986 2
a1987 2
	if (NULL == (n = node->head->child)) {
		if (arg_hasattr(MDOC_Emphasis, node))
d1989 1
a1989 1
		else if (arg_hasattr(MDOC_Symbolic, node))
d1995 2
a1996 2
	assert(MDOC_TEXT == n->type);
	if (0 == strcmp("Em", n->string))
d1998 1
a1998 1
	else if (0 == strcmp("Sy", n->string))
d2010 2
a2011 2
	assert(node->child && MDOC_TEXT == node->child->type);
	if (0 == strcmp("on", node->child->string)) {
d2039 1
a2039 1
	switch (node->tok) {
d2047 1
a2047 1
	term_word(p, node->next ? "," : ".");
d2055 1
a2055 1
	const struct mdoc_node *n;
d2057 1
a2057 4
	assert(node->child);
	n = node->child;

	if (NULL == n->next) {
d2063 1
a2063 1
	term_word(p, n->string);
d2069 2
a2070 2
	for (n = n->next; n; n = n->next) 
		term_word(p, n->string);
@


1.58
log
@sync to 1.9.6: multiple improvements to references (.Rs)
 * validate and order .Rs child nodes
 * underline book title (.%B) and issuer (.%I)
 * enclose title of article (.%T) in quotes
 * avoid calling mdoc_verr directly, use a proper error code instead
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.57 2009/10/19 13:29:56 schwarze Exp $ */
d1416 1
a1416 1
	return(1);
a1517 4
	assert(node->child && MDOC_TEXT == node->child->type);

	/* FIXME: can be "type funcname" "type varname"... */

d1840 1
@


1.57
log
@sync to 1.9.6: two newline fixes:
 * newline before .Rs  only below SEE ALSO
 * newline after  .Lb  only below LIBRARY
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.56 2009/10/19 09:41:22 schwarze Exp $ */
d109 1
d193 1
a193 1
	{ NULL, termp____post }, /* %B */
d195 1
a195 1
	{ NULL, termp____post }, /* %I */
d201 1
a201 1
	{ termp_under_pre, termp____post }, /* %T */
d222 1
a222 1
	{ termp_bold_pre, NULL }, /* Ms */
d264 3
a266 3
	{ NULL, NULL }, /* %C */ 
	{ NULL, NULL }, /* Es */ 
	{ NULL, NULL }, /* En */ 
d268 1
a268 1
	{ NULL, NULL }, /* %Q */ 
d2067 8
d2114 11
@


1.56
log
@sync to 1.9.6: fix segfault in .Bl -column
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.55 2009/09/21 20:57:57 schwarze Exp $ */
d1162 2
d1424 2
a1425 1
	term_newln(p);
@


1.55
log
@sync to 1.9.5: make terminal_*, tree_* and out_* functions return void,
making the code simpler
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.54 2009/09/21 20:28:43 schwarze Exp $ */
d760 1
a760 1
				i < (int)bl->args[vals[2]].argv->sz; 
d766 1
a766 1
		if (i < (int)bl->args[vals[2]].argv->sz)
@


1.54
log
@sync to 1.9.5: remove TERMP_STYLE bit field in favour of recursion-friendly
integer flags, simplifying and shortening the code
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.53 2009/08/22 22:50:17 schwarze Exp $ */
d283 1
a283 2
static	void	  print_head(struct termp *, 
			const struct mdoc_meta *);
d285 1
a285 2
static	void	  print_foot(struct termp *, 
			const struct mdoc_meta *);
d288 2
a289 2
int
mdoc_run(struct termp *p, const struct mdoc *m)
d291 10
a300 11
	/*
	 * Main output function.  When this is called, assume that the
	 * tree is properly formed.
	 */
	print_head(p, mdoc_meta(m));
	assert(mdoc_node(m));
	assert(MDOC_ROOT == mdoc_node(m)->type);
	if (mdoc_node(m)->child)
		print_body(p, NULL, mdoc_meta(m), mdoc_node(m)->child);
	print_foot(p, mdoc_meta(m));
	return(1);
d360 1
d362 1
a362 1
print_foot(struct termp *p, const struct mdoc_meta *meta)
d376 1
a376 1
		err(1, "malloc");
d378 1
a378 1
		err(1, "malloc");
d383 1
a383 1
		err(1, "strftime");
d420 2
d423 1
a423 1
print_head(struct termp *p, const struct mdoc_meta *meta)
d431 1
a431 1
		err(1, "malloc");
d433 1
a433 1
		err(1, "malloc");
d457 1
a457 2
	(void)snprintf(title, p->rmargin, "%s(%d)", 
			meta->title, meta->msec);
d490 1
d517 1
d559 1
d759 1
a759 1
		for (i = 0, n = node->prev; n && n && 
@


1.53
log
@sync to 1.9.1: .Rv and .Ex accept multiple arguments
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.52 2009/08/22 18:40:00 schwarze Exp $ */
d29 35
a66 51
#define	TTYPE_PROG	  0
#define	TTYPE_CMD_FLAG	  1
#define	TTYPE_CMD_ARG	  2
#define	TTYPE_SECTION	  3
#define	TTYPE_FUNC_DECL	  4
#define	TTYPE_VAR_DECL	  5
#define	TTYPE_FUNC_TYPE	  6
#define	TTYPE_FUNC_NAME	  7
#define	TTYPE_FUNC_ARG	  8
#define	TTYPE_LINK	  9
#define	TTYPE_SSECTION	  10
#define	TTYPE_FILE	  11
#define	TTYPE_EMPH	  12
#define	TTYPE_CONFIG	  13
#define	TTYPE_CMD	  14
#define	TTYPE_INCLUDE	  15
#define	TTYPE_SYMB	  16
#define	TTYPE_SYMBOL	  17
#define	TTYPE_DIAG	  18
#define	TTYPE_LINK_ANCHOR 19
#define	TTYPE_LINK_TEXT	  20
#define	TTYPE_REF_JOURNAL 21
#define	TTYPE_LIST	  22
#define	TTYPE_NMAX	  23

const	int ttypes[TTYPE_NMAX] = {
	TERMP_BOLD, 		/* TTYPE_PROG */
	TERMP_BOLD,		/* TTYPE_CMD_FLAG */
	TERMP_UNDER, 		/* TTYPE_CMD_ARG */
	TERMP_BOLD, 		/* TTYPE_SECTION */
	TERMP_BOLD,		/* TTYPE_FUNC_DECL */
	TERMP_UNDER,		/* TTYPE_VAR_DECL */
	TERMP_UNDER,		/* TTYPE_FUNC_TYPE */
	TERMP_BOLD, 		/* TTYPE_FUNC_NAME */
	TERMP_UNDER, 		/* TTYPE_FUNC_ARG */
	TERMP_UNDER, 		/* TTYPE_LINK */
	TERMP_BOLD,	 	/* TTYPE_SSECTION */
	TERMP_UNDER,		/* TTYPE_FILE */
	TERMP_UNDER, 		/* TTYPE_EMPH */
	TERMP_BOLD,	 	/* TTYPE_CONFIG */
	TERMP_BOLD,	 	/* TTYPE_CMD */
	TERMP_BOLD,	 	/* TTYPE_INCLUDE */
	TERMP_BOLD,	 	/* TTYPE_SYMB */
	TERMP_BOLD,	 	/* TTYPE_SYMBOL */
	TERMP_BOLD,	 	/* TTYPE_DIAG */
	TERMP_UNDER, 		/* TTYPE_LINK_ANCHOR */
	TERMP_BOLD,	 	/* TTYPE_LINK_TEXT */
	TERMP_UNDER,	 	/* TTYPE_REF_JOURNAL */
	TERMP_BOLD		/* TTYPE_LIST */
};

a83 1
static	void	  termp__t_post(DECL_ARGS);
a108 2
static	int	  termp__j_pre(DECL_ARGS);
static	int	  termp__t_pre(DECL_ARGS);
a111 1
static	int	  termp_ar_pre(DECL_ARGS);
d114 1
a115 1
static	int	  termp_br_pre(DECL_ARGS);
a118 1
static	int	  termp_cm_pre(DECL_ARGS);
a120 1
static	int	  termp_em_pre(DECL_ARGS);
a122 1
static	int	  termp_fd_pre(DECL_ARGS);
a126 1
static	int	  termp_ic_pre(DECL_ARGS);
a129 2
static	int	  termp_ms_pre(DECL_ARGS);
static	int	  termp_mt_pre(DECL_ARGS);
a133 1
static	int	  termp_pa_pre(DECL_ARGS);
a134 1
static	int	  termp_pp_pre(DECL_ARGS);
d144 1
a144 2
static	int	  termp_sx_pre(DECL_ARGS);
static	int	  termp_sy_pre(DECL_ARGS);
a145 2
static	int	  termp_va_pre(DECL_ARGS);
static	int	  termp_vt_pre(DECL_ARGS);
d149 1
a149 1
static const struct termact termacts[MDOC_MAX] = {
d156 1
a156 1
	{ termp_pp_pre, NULL }, /* Pp */ 
d166 1
a166 1
	{ termp_ar_pre, NULL }, /* Ar */
d168 1
a168 1
	{ termp_cm_pre, NULL }, /* Cm */
d174 1
a174 1
	{ termp_fd_pre, termp_fd_post }, /* Fd */ 
d178 1
a178 1
	{ termp_ic_pre, NULL }, /* Ic */ 
d185 1
a185 1
	{ termp_pa_pre, NULL }, /* Pa */
d188 2
a189 2
	{ termp_va_pre, NULL }, /* Va */
	{ termp_vt_pre, termp_vt_post }, /* Vt */ 
d195 1
a195 1
	{ termp__j_pre, termp____post }, /* %J */
d200 1
a200 1
	{ termp__t_pre, termp__t_post }, /* %T */
d218 1
a218 1
	{ termp_em_pre, NULL }, /* Em */ 
d221 1
a221 1
	{ termp_ms_pre, NULL }, /* Ms */
d240 2
a241 2
	{ termp_sx_pre, NULL }, /* Sx */
	{ termp_sy_pre, NULL }, /* Sy */
d257 1
a257 1
	{ termp_pp_pre, NULL }, /* Lp */ 
d259 1
a259 1
	{ termp_mt_pre, NULL }, /* Mt */ 
d268 1
a268 1
	{ termp_br_pre, NULL }, /* br */
d312 2
a313 3
	if ( ! node->next)
		return;
	print_body(p, pair, meta, node->next);
d317 1
d321 1
a321 1
	int		 dochild;
d325 1
a325 1
	dochild = 1;
d328 2
d331 1
a332 9
	npair.flag = 0;
	npair.count = 0;

	/*
	 * Note on termpair.  This allows a pre function to set a termp
	 * flag that is automatically unset after the body, but before
	 * the post function.  Thus, if a pre uses a termpair flag, it
	 * must be reapplied in the post for use.
	 */
d336 3
a338 3
			if ( ! (*termacts[node->tok].pre)(p, &npair, meta, node))
				dochild = 0;
	} else /* MDOC_TEXT == node->type */
d341 1
a341 5
	/* Children. */

	p->flags |= npair.flag;

	if (dochild && node->child)
d344 5
a348 1
	p->flags &= ~npair.flag;
d350 2
a351 1
	/* Post-processing. */
d355 2
a356 1
			(*termacts[node->tok].post)(p, &npair, meta, node);
a834 4
	/*
	 * Style flags.  Diagnostic heads need TTYPE_DIAG.
	 */

d838 1
a838 1
			p->flags |= ttypes[TTYPE_DIAG];
d976 1
a976 1
			p->flags |= TERMP_BOLD;
d978 1
a978 1
			p->flags &= ~TERMP_BOLD;
d983 1
a983 1
			p->flags |= TERMP_BOLD;
d985 1
a985 1
			p->flags &= ~TERMP_BOLD;
d1067 1
a1067 4

	pair->flag |= ttypes[TTYPE_PROG];
	p->flags |= ttypes[TTYPE_PROG];

a1069 1

d1079 1
a1079 2
	pair->flag |= ttypes[TTYPE_CMD_FLAG];
	p->flags |= ttypes[TTYPE_CMD_FLAG];
a1146 10
termp_ar_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_CMD_ARG];
	return(1);
}


/* ARGSUSED */
static int
a1156 10
termp_pp_pre(DECL_ARGS)
{

	term_vspace(p);
	return(1);
}


/* ARGSUSED */
static int
d1178 1
a1178 1
		p->flags |= ttypes[TTYPE_FUNC_NAME];
d1180 1
a1180 1
		p->flags &= ~ttypes[TTYPE_FUNC_NAME];
d1198 1
a1198 1
	p->flags |= ttypes[TTYPE_VAR_DECL];
d1200 1
a1200 1
	p->flags &= ~ttypes[TTYPE_VAR_DECL];
d1219 1
a1219 1
		p->flags |= ttypes[TTYPE_PROG];
d1221 1
a1221 1
		p->flags &= ~ttypes[TTYPE_PROG];
a1303 11
static int
termp_vt_pre(DECL_ARGS)
{

	/* FIXME: this can be "type name". */
	pair->flag |= ttypes[TTYPE_VAR_DECL];
	return(1);
}


/* ARGSUSED */
d1319 1
a1319 1
termp_fd_pre(DECL_ARGS)
d1322 1
a1322 1
	pair->flag |= ttypes[TTYPE_FUNC_DECL];
d1357 1
a1357 1
		pair->flag |= ttypes[TTYPE_SECTION];
d1491 1
a1491 1
	pair->flag |= ttypes[TTYPE_FUNC_TYPE];
d1516 1
a1516 1
	p->flags |= ttypes[TTYPE_FUNC_NAME];
d1518 1
a1518 1
	p->flags &= ~ttypes[TTYPE_FUNC_NAME];
d1524 1
a1524 1
		p->flags |= ttypes[TTYPE_FUNC_ARG];
d1526 1
a1526 1
		p->flags &= ~ttypes[TTYPE_FUNC_ARG];
a1551 10
termp_sx_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_LINK];
	return(1);
}


/* ARGSUSED */
static int
d1557 1
a1557 1
		pair->flag |= ttypes[TTYPE_FUNC_ARG];
d1562 1
a1562 1
		p->flags |= ttypes[TTYPE_FUNC_ARG];
d1564 1
a1564 1
		p->flags &= ~ttypes[TTYPE_FUNC_ARG];
a1577 10
termp_va_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_VAR_DECL];
	return(1);
}


/* ARGSUSED */
static int
a1754 10
termp_pa_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_FILE];
	return(1);
}


/* ARGSUSED */
static int
d1785 1
a1785 1
		pair->flag |= ttypes[TTYPE_SSECTION];
a1807 10
termp_em_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_EMPH];
	return(1);
}


/* ARGSUSED */
static int
d1811 1
a1811 1
	pair->flag |= ttypes[TTYPE_CONFIG];
a1818 20
termp_cm_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_CMD_FLAG];
	return(1);
}


/* ARGSUSED */
static int
termp_ic_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_CMD];
	return(1);
}


/* ARGSUSED */
static int
d1822 1
a1822 3
	pair->flag |= ttypes[TTYPE_INCLUDE];
	p->flags |= ttypes[TTYPE_INCLUDE];

d1837 1
a1837 1
	p->flags |= TERMP_NOSPACE | ttypes[TTYPE_INCLUDE];
d1839 1
a1839 1
	p->flags &= ~ttypes[TTYPE_INCLUDE];
d1862 10
a1871 3
	if (NULL == node->child) {
		term_vspace(p);
		return(0);
a1873 1
	len = atoi(node->child->string);
a1884 10
termp_br_pre(DECL_ARGS)
{

	term_newln(p);
	return(1);
}


/* ARGSUSED */
static int
d1971 1
a1971 1
	p->flags |= ttypes[TTYPE_FUNC_NAME];
d1976 1
a1976 1
	p->flags &= ~ttypes[TTYPE_FUNC_NAME];
d2010 1
a2010 1
			pair->flag |= ttypes[TTYPE_EMPH];
d2012 1
a2012 1
			pair->flag |= ttypes[TTYPE_SYMB];
d2019 1
a2019 1
		pair->flag |= ttypes[TTYPE_EMPH];
d2021 1
a2021 15
		pair->flag |= ttypes[TTYPE_SYMB];

	return(1);
}


/* ARGSUSED */
static int
termp_sy_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_SYMB];
	return(1);
}

a2022 6
/* ARGSUSED */
static int
termp_ms_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_SYMBOL];
a2026 1

a2055 32
static int
termp__j_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_REF_JOURNAL];
	return(1);
}


/* ARGSUSED */
static int
termp__t_pre(DECL_ARGS)
{

	term_word(p, "\"");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp__t_post(DECL_ARGS)
{

	p->flags |= TERMP_NOSPACE;
	term_word(p, "\"");
	termp____post(p, pair, meta, node);
}


/* ARGSUSED */
d2075 1
a2075 1
		pair->flag |= ttypes[TTYPE_LINK_ANCHOR];
d2079 1
a2079 1
	p->flags |= ttypes[TTYPE_LINK_ANCHOR];
d2083 1
a2083 1
	p->flags &= ~ttypes[TTYPE_LINK_ANCHOR];
d2085 1
a2085 1
	p->flags |= ttypes[TTYPE_LINK_TEXT];
d2088 1
a2089 1
	p->flags &= ~ttypes[TTYPE_LINK_TEXT];
d2096 1
a2096 1
termp_mt_pre(DECL_ARGS)
d2099 1
a2099 1
	pair->flag |= ttypes[TTYPE_LINK_ANCHOR];
a2101 2


@


1.52
log
@sync to 1.9.0: like in groff, do not assert vspace between two .Sh macros
in case the first one has no body
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.51 2009/08/22 18:10:02 schwarze Exp $ */
a31 2
/* FIXME: macro arguments can be escaped. */

d818 1
a818 1
	 * offset.  FIXME: double-check that correct.
d1234 1
a1234 5
	int		 i;

	i = arg_getattr(MDOC_Std, node);
	assert(-1 != i);
	assert(node->args->argv[i].sz);
d1239 19
a1257 4
	p->flags |= ttypes[TTYPE_FUNC_NAME];
	term_word(p, *node->args->argv[i].value);
	p->flags &= ~ttypes[TTYPE_FUNC_NAME];
	p->flags |= TERMP_NOSPACE;
d1259 2
a1260 3
       	term_word(p, "() function returns the value 0 if successful;");
       	term_word(p, "otherwise the value -1 is returned and the");
       	term_word(p, "global variable");
d1268 1
a1268 1
	return(1);
d1276 1
a1276 1
	int		 i;
d1278 1
a1278 3
	i = arg_getattr(MDOC_Std, node);
	assert(-1 != i);
	assert(node->args->argv[i].sz);
d1280 21
a1300 5
	term_word(p, "The");
	p->flags |= ttypes[TTYPE_PROG];
	term_word(p, *node->args->argv[i].value);
	p->flags &= ~ttypes[TTYPE_PROG];
       	term_word(p, "utility exits 0 on success, and >0 if an error occurs.");
d1302 1
a1302 1
	return(1);
@


1.51
log
@sync to 1.9.0: move indentation size into *term.c files,
improving -man indentation
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.50 2009/08/22 15:36:58 schwarze Exp $ */
d1398 4
a1401 1

d1403 6
a1409 1
		term_vspace(p);
@


1.50
log
@sync to 1.8.4: LLVM findings from <uqs at spoerlein dot net>
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.49 2009/08/09 21:59:41 schwarze Exp $ */
d28 3
@


1.49
log
@sync to 1.8.4: full .An -[no]split support
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.48 2009/08/09 21:38:25 schwarze Exp $ */
d1642 1
a1642 1
	int	         i, type, ln;
@


1.48
log
@sync to 1.8.4: now that leading blanks in literal text are preserved,
.Bd printing can be simplified (and must be fixed)
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.47 2009/08/09 20:37:32 schwarze Exp $ */
d100 1
d127 1
d195 1
a195 1
	{ NULL, NULL }, /* An */
d1126 59
@


1.47
log
@sync to 1.8.3: ugly fix for .Bl or .Bd when nested in .Bl -hang
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.46 2009/08/09 20:11:30 schwarze Exp $ */
d669 1
d854 2
a855 1
		term_word(p, "\\ \\ ");
d1600 1
a1600 4
	/* FIXME: display type should be mandated by parser. */

	if (NULL == node->parent->args)
		errx(1, "missing display type");
d1602 1
a1602 1
	for (type = -1, i = 0; 
a1612 1
			i = (int)node->parent->args->argc;
d1618 2
a1619 3

	if (NULL == node->parent->args)
		errx(1, "missing display type");
d1622 1
a1622 3
	if (-1 != i) {
		if (1 != node->parent->args->argv[i].sz)
			errx(1, "expected single value");
a1623 1
	}
a1633 8
	/*
	 * Tricky.  Iterate through all children.  If we're on a
	 * different parse line, append a newline and then the contents.
	 * Ew.
	 */

	ln = node->child ? node->child->line : 0;

d1635 3
a1637 1
		if (ln < node->line) {
a1638 4
			p->flags |= TERMP_NOSPACE;
		}
		ln = node->line;
		print_node(p, pair, meta, node);
d1652 1
@


1.46
log
@sync to 1.8.3: In .Bl -column, handle one column in excess,
but still issue a warning
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.45 2009/08/09 19:28:21 schwarze Exp $ */
a29 1
/* FIXME: support more offset/width tokens. */
d68 1
a68 1
	TERMP_UNDER, 		/* TTYPE_FILE */
d905 15
a919 1
		if (MDOC_HEAD == node->type)
d961 11
a978 2
		/* FALLTHROUGH */
	case (MDOC_Hang):
@


1.45
log
@sync to 1.8.3: bring vspace handling in .Bl -column and -diag closer to groff
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.44 2009/08/09 19:15:14 schwarze Exp $ */
d780 12
a791 1
		for (i = 0, n = node->prev; n; n = n->prev, i++)
d794 7
a800 2
		assert(i < (int)bl->args->argv[vals[2]].sz);
		width = arg_width(&bl->args->argv[vals[2]], i);
@


1.44
log
@sync to 1.8.3: remove doubled .Bl -diag whitespace
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.43 2009/08/09 19:01:24 schwarze Exp $ */
d308 1
a308 1
static	int	  fmt_block_vspace(struct termp *,
d659 1
a659 1
static int
d668 7
a674 5
	if (arg_hasattr(MDOC_Compact, bl))
		return(1);
	/* XXX - not documented! */
	else if (arg_hasattr(MDOC_Column, bl))
		return(1);
d680 1
a680 1
			break;
d682 1
a682 1
			break;
a684 1
		term_vspace(p);
d688 21
a708 1
	return(1);
d748 4
a751 2
	if (MDOC_BLOCK == node->type)
		return(fmt_block_vspace(p, node->parent->parent, node));
d1554 4
a1557 3
	if (MDOC_BLOCK == node->type)
		return(fmt_block_vspace(p, node, node));
	else if (MDOC_BODY != node->type)
d1733 10
a1790 10
}


/* ARGSUSED */
static int
termp_pa_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_FILE];
	return(1);
@


1.43
log
@sync to 1.8.3: right-most column now fills to the right margin
(undocumented groff behaviour)
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.42 2009/08/09 18:43:28 schwarze Exp $ */
d1012 2
a1014 3
		term_word(p, "\\ ");
		/* FALLTHROUGH */
	case (MDOC_Item):
@


1.42
log
@multiple spacing fixes for .Bl -hang, -tag, -inset and -diag
ok kristaps@@ and included in 1.8.3
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.41 2009/08/09 17:38:24 schwarze Exp $ */
d929 7
@


1.41
log
@sync to 1.8.2: more .Bl -column fixes, in particular:
1) -column implies -compact
2) do not die from fewer columns than specified (more are still fatal)
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.40 2009/07/26 23:39:54 schwarze Exp $ */
d811 2
d814 3
d819 1
a819 3
			p->flags &= ~TERMP_NOSPACE;
		else
			p->flags |= TERMP_NOSPACE;
a821 1
		p->flags |= TERMP_NOSPACE;
d825 2
d872 1
a872 1
			p->flags |= TERMP_NOBREAK;
@


1.40
log
@sync to 1.8.1: remove superfluous NOSPACE in bd post,
and remove unused TERMP_LITERAL
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.39 2009/07/26 23:32:26 schwarze Exp $ */
d670 3
d796 2
d916 1
d923 1
d1823 1
a1823 1
	p->flags |= TERMP_NOSPACE;
d1825 1
@


1.39
log
@sync to 1.8.1: add a comment explaining the non-trivial termpair semantics;
a bug in this very respect was contained in the upstream equivalent
of rev. 1.28, but was squashed while merging into OpenBSD
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.38 2009/07/26 01:59:46 schwarze Exp $ */
a1566 1
	p->flags |= TERMP_LITERAL;
a1588 1

a1589 2
	p->flags &= ~TERMP_LITERAL;
	p->flags |= TERMP_NOSPACE;
@


1.38
log
@sync to 1.8.1: support .br and .sp
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.37 2009/07/26 00:49:19 schwarze Exp $ */
d361 7
@


1.37
log
@sync to 1.8.1: .Bl -diag lacked the second blank after the tag
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.36 2009/07/25 23:29:15 schwarze Exp $ */
d133 1
d167 1
d297 2
d1828 31
@


1.36
log
@sync to 1.8.1: fix date in footer; from Ulrich Sporlein
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.35 2009/07/18 22:07:09 schwarze Exp $ */
a795 3
	case (MDOC_Diag):
		term_word(p, "\\ ");
		/* FALLTHROUGH */
d984 1
@


1.35
log
@sync to 1.8.0: a couple of cosmetic fixes:
1) use \(hy instead of \- for .Bl -hyphen (renders the same in -Tascii)
2) clear bold flag after printing the -bullet or -hyphen in .Bl
   (actually, the flags will be reinitialized in termp_it_post, anyway)
3) do not redo the work of the parser in termp_rv_pre and termp_ex_pre
   (instead, just assert() validity of the parse tree)
4) do not bother assigning to the offset in termp_ss_post
   (it will soon be reinitialized in print_node, anyway)
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.34 2009/07/18 21:16:49 schwarze Exp $ */
d406 1
a406 1
	if (0 == strftime(buf, p->rmargin, "%B %d, %Y", tm))
@


1.34
log
@sync to 1.8.0: support -offset [0-9]+n and -offset [0-9]+m
(not documented in mdoc.samples, but used in mdoc.samples)
while here, do some cleanup in arg_offset and arg_width
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.33 2009/07/18 20:50:38 schwarze Exp $ */
d925 1
d931 2
a932 1
			term_word(p, "\\-");
d1085 3
a1087 6
	/* FIXME: mandated by parser. */

	if (-1 == (i = arg_getattr(MDOC_Std, node)))
		errx(1, "expected -std argument");
	if (1 != node->args->argv[i].sz)
		errx(1, "expected -std argument");
d1117 3
a1119 6
	/* FIXME: mandated by parser? */

	if (-1 == (i = arg_getattr(MDOC_Std, node)))
		errx(1, "expected -std argument");
	if (1 != node->args->argv[i].sz)
		errx(1, "expected -std argument");
d1733 1
a1733 2
	switch (node->type) {
	case (MDOC_HEAD):
a1734 5
		p->offset = INDENT;
		break;
	default:
		break;
	}
@


1.33
log
@sync to 1.8.0: support .Bl -hang
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.32 2009/07/18 19:44:38 schwarze Exp $ */
a515 1
	size_t		 v;
d517 1
d522 3
a524 1
	if (0 == (len = (int)strlen(arg->value[pos])))
d528 1
a528 1
		if ( ! isdigit((u_char)arg->value[pos][i]))
d531 3
a533 6
	if (i == len - 1) {
		if ('n' == arg->value[pos][len - 1] ||
				'm' == arg->value[pos][len - 1]) {
			v = (size_t)atoi(arg->value[pos]);
			return(v + 2);
		}
d535 1
a535 2
	}
	return(strlen(arg->value[pos]) + 2);
d583 2
d587 3
a589 1
	if (0 == strcmp(*arg->value, "left"))
d591 1
a591 1
	if (0 == strcmp(*arg->value, "indent"))
d593 1
a593 1
	if (0 == strcmp(*arg->value, "indent-two"))
d596 10
a605 1
	/* FIXME: needs to support field-widths (10n, etc.). */
d607 1
a607 1
	return(strlen(*arg->value));
@


1.32
log
@sync to 1.8.0: move mdoc_a2att, mdoc_a2st, and mdoc_a2lib to libmdoc
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.31 2009/07/18 19:13:44 schwarze Exp $ */
d570 2
d578 1
a578 4
	/* FIXME: mandated by parser. */

	errx(1, "list type not supported");
	/* NOTREACHED */
d724 1
d751 1
a751 1
	 * offset.
d767 4
d828 14
a841 1
		/* FALLTHROUGH */
d847 5
a851 4
		if (MDOC_HEAD == node->type && MDOC_Tag == type)
			if (NULL == node->next ||
					NULL == node->next->child)
				p->flags |= TERMP_NONOBREAK;
d889 2
d970 1
@


1.31
log
@sync to 1.8.0: for .Fo, do not print a blank before '('
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.30 2009/07/18 19:00:30 schwarze Exp $ */
a129 1
static	int	  termp_at_pre(DECL_ARGS);
a149 1
static	int	  termp_lb_pre(DECL_ARGS);
a167 1
static	int	  termp_st_pre(DECL_ARGS);
d214 1
a214 1
	{ termp_st_pre, NULL }, /* St */ 
d232 1
a232 1
	{ termp_at_pre, NULL }, /* At */
d283 1
a283 1
	{ termp_lb_pre, termp_lb_post }, /* Lb */
a321 1

a1035 12
termp_st_pre(DECL_ARGS)
{
	const char	*cp;

	if (node->child && (cp = mdoc_a2st(node->child->string)))
		term_word(p, cp);
	return(0);
}


/* ARGSUSED */
static int
a1279 17
static int
termp_lb_pre(DECL_ARGS)
{
	const char	*lb;

	assert(node->child && MDOC_TEXT == node->child->type);
	lb = mdoc_a2lib(node->child->string);
	if (lb) {
		term_word(p, lb);
		return(0);
	}
	term_word(p, "library");
	return(1);
}


/* ARGSUSED */
a1803 18
}


/* ARGSUSED */
static int
termp_at_pre(DECL_ARGS)
{
	const char	*att;

	att = NULL;

	if (node->child)
		att = mdoc_a2att(node->child->string);
	if (NULL == att)
		att = "AT&T UNIX";

	term_word(p, att);
	return(0);
@


1.30
log
@sync to 1.8.0: two .Vd in SYNOPSIS get a line break in between,
but not a blank line; as before, the last .Vd in SYNOPSIS is still
followed by a blank line, and .Vd outside SYNOPSIS breaks no lines
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.29 2009/07/18 18:46:42 schwarze Exp $ */
d1939 1
a1944 2

	/* XXX - groff shows only first parameter */
@


1.29
log
@sync to 1.8.0: replace macro function declarations by real ones, and sort them
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.28 2009/07/18 17:26:21 schwarze Exp $ */
d1196 5
a1200 1
	if (node->sec == SEC_SYNOPSIS)
@


1.28
log
@sync to 1.8.0: cleanup: remove offset and rmargin from termpair
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.27 2009/07/18 17:11:44 schwarze Exp $ */
d89 4
a92 72

#define	DECL_ARGS \
	struct termp *p, struct termpair *pair, \
	const struct mdoc_meta *meta, \
	const struct mdoc_node *node

#define	DECL_PRE(name) \
static	int	 	  name##_pre(DECL_ARGS)
#define	DECL_POST(name) \
static	void	 	  name##_post(DECL_ARGS)
#define	DECL_PREPOST(name) \
DECL_PRE(name); \
DECL_POST(name);

DECL_PREPOST(termp__t);
DECL_PREPOST(termp_aq);
DECL_PREPOST(termp_bd);
DECL_PREPOST(termp_bq);
DECL_PREPOST(termp_brq);
DECL_PREPOST(termp_d1);
DECL_PREPOST(termp_dq);
DECL_PREPOST(termp_fd);
DECL_PREPOST(termp_fn);
DECL_PREPOST(termp_fo);
DECL_PREPOST(termp_ft);
DECL_PREPOST(termp_in);
DECL_PREPOST(termp_it);
DECL_PREPOST(termp_lb);
DECL_PREPOST(termp_op);
DECL_PREPOST(termp_pf);
DECL_PREPOST(termp_pq);
DECL_PREPOST(termp_qq);
DECL_PREPOST(termp_sh);
DECL_PREPOST(termp_ss);
DECL_PREPOST(termp_sq);
DECL_PREPOST(termp_vt);

DECL_PRE(termp__j);
DECL_PRE(termp_ap);
DECL_PRE(termp_ar);
DECL_PRE(termp_at);
DECL_PRE(termp_bf);
DECL_PRE(termp_bt);
DECL_PRE(termp_cd);
DECL_PRE(termp_cm);
DECL_PRE(termp_em);
DECL_PRE(termp_ex);
DECL_PRE(termp_fa);
DECL_PRE(termp_fl);
DECL_PRE(termp_ic);
DECL_PRE(termp_lk);
DECL_PRE(termp_ms);
DECL_PRE(termp_mt);
DECL_PRE(termp_nd);
DECL_PRE(termp_nm);
DECL_PRE(termp_ns);
DECL_PRE(termp_pa);
DECL_PRE(termp_pp);
DECL_PRE(termp_rs);
DECL_PRE(termp_rv);
DECL_PRE(termp_sm);
DECL_PRE(termp_st);
DECL_PRE(termp_sx);
DECL_PRE(termp_sy);
DECL_PRE(termp_ud);
DECL_PRE(termp_va);
DECL_PRE(termp_xr);
DECL_PRE(termp_xx);

DECL_POST(termp___);
DECL_POST(termp_bl);
DECL_POST(termp_bx);
d98 80
@


1.27
log
@sync to 1.8.0: remove ambiguous TERMPAIR_SETFLAG macro and set flags manually
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.26 2009/07/18 16:38:10 schwarze Exp $ */
d85 1
a85 3
	int	  	  flag;
	size_t	  	  offset;	/* Left margin. */
	size_t	  	  rmargin;	/* Right margin. */
d340 1
d342 3
a344 1
	/* Pre-processing. */
a345 1
	dochild = 1;
a346 1
	npair.offset = npair.rmargin = 0;
d371 3
d692 1
a692 1
	int		        i, type, keys[3], vals[3], sv;
a701 2
	pair->offset = p->offset;
	pair->rmargin = p->rmargin;
a880 1
	sv = p->flags;
a902 2
	p->flags = sv; /* Restore saved flags. */

a960 2
	p->offset = pair->offset;
	p->rmargin = pair->rmargin;
d1323 1
a1323 2
	pair->offset = INDENT + 1;
	p->offset += pair->offset;
a1335 1
	p->offset -= pair->offset;
a1503 2
	pair->offset = p->offset;

a1572 1
	p->offset = pair->offset;
@


1.26
log
@sync to 1.8.0: consolidated Bsx, Dx, Fx, Nx, Ox, Ux into one common function
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.25 2009/07/18 15:34:27 schwarze Exp $ */
a82 2
/* XXX - clean this up. */

d85 1
a85 3
	int		  type;
#define	TERMPAIR_FLAG	 (1 << 0)
	int	  	  flag;		/* Whether being used. */
d88 1
a88 1
	int		  count;	/* Enum count. */
a90 7
#define	TERMPAIR_SETFLAG(termp, p, fl) \
	do { \
		assert(! (TERMPAIR_FLAG & (p)->type)); \
		(termp)->flags |= (fl); \
		(p)->flag = (fl); \
		(p)->type |= TERMPAIR_FLAG; \
	} while ( /* CONSTCOND */ 0)
a346 1
	npair.type = 0;
d360 1
a360 2
	if (TERMPAIR_FLAG & npair.type)
		p->flags |= npair.flag;
d365 1
a365 2
	if (TERMPAIR_FLAG & npair.type)
		p->flags &= ~npair.flag;
d978 3
a980 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_PROG]);
d993 2
a994 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CMD_FLAG]);
d1006 1
a1006 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CMD_ARG]);
d1179 1
a1179 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_VAR_DECL]);
d1199 1
a1199 5
	/* 
	 * FIXME: this naming is bad.  This value is used, in general,
	 * for the #include header or other preprocessor statement.
	 */
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_FUNC_DECL]);
d1211 1
d1226 1
a1226 1
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SECTION]);
d1379 1
a1379 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_FUNC_TYPE]);
a1434 1

d1443 1
a1443 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_LINK]);
d1455 1
a1455 1
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_FUNC_ARG]);
d1479 1
a1479 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_VAR_DECL]);
d1716 1
a1716 1
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SSECTION]);
d1748 1
a1748 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_FILE]);
d1758 1
a1758 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_EMPH]);
d1768 1
a1768 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CONFIG]);
d1779 1
a1779 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CMD_FLAG]);
d1789 1
a1789 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CMD]);
d1799 2
a1800 2
	/* XXX This conforms to new-groff style. */
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_INCLUDE]);
d1973 1
a1973 1
	if (MDOC_HEAD == node->type) {
d1975 1
a1975 1
	} else if (MDOC_BLOCK != node->type)
d1980 1
a1980 1
			TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_EMPH]);
d1982 1
a1982 1
			TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SYMB]);
d1989 1
a1989 1
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_EMPH]);
d1991 1
a1991 1
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_EMPH]);
d2002 1
a2002 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SYMB]);
d2012 1
a2012 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SYMBOL]);
d2051 1
a2051 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_REF_JOURNAL]);
d2098 1
a2098 1
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_LINK_ANCHOR]);
d2122 1
a2122 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_LINK_ANCHOR]);
@


1.25
log
@sync to 1.8.0: .Nd is now a BFI, was an ELEM,
and use \(en instead of \- for .Nd
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.24 2009/07/13 00:26:24 schwarze Exp $ */
a143 1
DECL_PRE(termp_bsx);
a146 1
DECL_PRE(termp_dx);
a150 1
DECL_PRE(termp_fx);
a157 2
DECL_PRE(termp_nx);
DECL_PRE(termp_ox);
a166 1
DECL_PRE(termp_ux);
d169 1
d241 1
a241 1
	{ termp_bsx_pre, NULL }, /* Bsx */
d251 1
a251 1
	{ termp_fx_pre, NULL }, /* Fx */
d255 2
a256 2
	{ termp_nx_pre, NULL }, /* Nx */
	{ termp_ox_pre, NULL }, /* Ox */
d274 1
a274 1
	{ termp_ux_pre, NULL }, /* Ux */
d297 1
a297 1
	{ termp_dx_pre, NULL }, /* Dx */ 
a1627 10
static int
termp_bsx_pre(DECL_ARGS)
{

	term_word(p, "BSDI BSD/OS");
	return(1);
}


/* ARGSUSED */
d1640 1
a1640 1
termp_ox_pre(DECL_ARGS)
d1642 1
d1644 23
a1666 39
	term_word(p, "OpenBSD");
	return(1);
}


/* ARGSUSED */
static int
termp_dx_pre(DECL_ARGS)
{

	term_word(p, "DragonFly");
	return(1);
}


/* ARGSUSED */
static int
termp_ux_pre(DECL_ARGS)
{

	term_word(p, "UNIX");
	return(1);
}


/* ARGSUSED */
static int
termp_fx_pre(DECL_ARGS)
{

	term_word(p, "FreeBSD");
	return(1);
}


/* ARGSUSED */
static int
termp_nx_pre(DECL_ARGS)
{
d1668 2
a1669 1
	term_word(p, "NetBSD");
@


1.24
log
@sync to 1.7.24: In the .Nd line, \(em is typographically more sound than \- ,
so that's what e.g. NetBSD and FreeBSD do.  However, for *now*, we want to
stick with the exact behaviour of the in-tree groff in OpenBSD.
ok jmc@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.23 2009/07/12 23:19:48 schwarze Exp $ */
d1132 6
a1137 7
	/* 
	 * XXX: signed off by jmc@@openbsd.org.  This technically
	 * produces a minus sign after the Nd, which is wrong, but is
	 * consistent with the historic OpenBSD tmac file.
	 */
#ifdef __OpenBSD__
	term_word(p, "\\-");
@


1.23
log
@sync to 1.7.24: make .In handling more similar to new groff
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.22 2009/07/07 00:42:04 schwarze Exp $ */
d1132 6
a1137 1

d1139 3
@


1.22
log
@The word "indent" has a special meaning in ".Bd -tag -offset indent",
but *not* in ".Bd -tag -width indent", so in the latter case, it should
not be handled specially.
ok kristaps@@ and jmc@@  and contained in 1.7.22
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.21 2009/07/06 23:37:27 schwarze Exp $ */
d1836 1
d1838 4
a1841 1
	term_word(p, "#include");
a1855 1
	term_newln(p);
d1858 8
@


1.21
log
@sync to 1.7.21: increment offset by the value of .Bd -offset
instead of resetting it to the value;
no functional change, as currently offset is always 0 at this point,
but perhaps it's safer with respect to possible future changes
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.20 2009/07/06 22:55:33 schwarze Exp $ */
a529 4
	if (0 == strcmp(arg->value[pos], "indent"))
		return(INDENT);
	if (0 == strcmp(arg->value[pos], "indent-two"))
		return(INDENT * 2);
@


1.20
log
@.Bd -offset indent-two is two times 6, not two times 5 spaces
ok kristaps@@  and contained in 1.7.21
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.19 2009/06/27 13:03:51 schwarze Exp $ */
d759 1
a759 1
			offset = arg_offset(&bl->args->argv[vals[1]]);
@


1.19
log
@sync to 1.7.20: minimum offset for .Bl -enum is 5 spaces, not 4
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.18 2009/06/27 12:43:11 schwarze Exp $ */
d606 1
a606 1
		return(INDENT * 2);
@


1.18
log
@sync to 1.7.20: (1) -width Ds is 6 spaces, not 8, see the manual.
(2) When determining the offset, add two more spaces to the width.
For -width Ds, these two bugs cancelled each other,
but for -width [01-9]+n, they did not, leaving the offset to narrow.
(3) When determining the width using strlen,
we need to add two spaces instead of one, just like in the case (2).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.17 2009/06/27 12:04:45 schwarze Exp $ */
a773 2
	case (MDOC_Enum):
		/* FALLTHROUGH */
d777 4
@


1.17
log
@sync to 1.7.20: .Bd -indent uses 6-space, not 5-space indent
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.16 2009/06/27 11:56:05 schwarze Exp $ */
d546 1
a546 1
			return(v);
d550 1
a550 1
	return(strlen(arg->value[pos]) + 1);
@


1.16
log
@sync to 1.7.20: .Bl -diag get two spaces after the tag
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.15 2009/06/27 11:49:37 schwarze Exp $ */
d604 1
a604 1
		return(INDENT);
@


1.15
log
@sync to 1.7.20: handle [01-9]+m -width specifiers
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.14 2009/06/27 10:59:07 schwarze Exp $ */
d789 2
a790 1
	 * Whitespace control.  Inset bodies need an initial space.
d795 1
@


1.14
log
@sync to 1.7.20: .D1 and .Dl use 6-space, not 5-space indent;
while here, a lint fix n lb_pre
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.13 2009/06/21 20:49:33 schwarze Exp $ */
d543 2
a544 1
		if ('n' == arg->value[pos][len - 1]) {
@


1.13
log
@sync to 1.7.19: do not try to print_body() when there is none
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.12 2009/06/21 19:53:47 schwarze Exp $ */
d1302 2
a1303 1
	if ((lb = mdoc_a2lib(node->child->string))) {
d1339 2
a1340 1
	p->offset += (pair->offset = INDENT);
@


1.12
log
@sync to 1.7.19: proper font decorations for special and .It characters
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.11 2009/06/18 23:34:53 schwarze Exp $ */
d293 1
a293 1
	{ termp_pp_pre, NULL }, /* Pp */ 
d333 4
a336 1
	print_body(p, NULL, mdoc_meta(m), mdoc_node(m));
@


1.11
log
@sync to 1.7.19: improved comment handling
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.10 2009/06/18 21:50:45 schwarze Exp $ */
d709 1
a709 1
	int		        i, type, keys[3], vals[3];
d893 1
a893 1
	 * HEAD character.  Print it now.
d896 1
d900 1
d906 1
d918 2
@


1.10
log
@sync to 1.7.16: Moved MDOC_TEXT type checks into assertions (should be
caught by parser).  Added some FIXME notes in mdoc output (largely that
things should be asserted, not caught).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.9 2009/06/18 21:45:31 schwarze Exp $ */
d186 1
a186 1
	{ NULL, NULL }, /* \" */
a292 1
	{ termp_ap_pre, NULL }, /* Lb */
@


1.9
log
@sync to 1.7.16: support .Bd -offset left
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.8 2009/06/18 21:34:54 schwarze Exp $ */
d586 2
d604 3
d1068 2
d1103 2
d1158 3
a1160 2
	if (NULL == (n = node->child))
		errx(1, "expected text line argument");
d1294 1
a1294 2
	if (NULL == node->child)
		errx(1, "expected text line argument");
d1402 1
a1402 2
	if (NULL == node->child)
		errx(1, "expected text line arguments");
d1509 2
a1635 3
/* FIXME: consolidate the following into termp_system. */


d1959 1
a1959 2
		if (MDOC_TEXT != n->type)
			errx(1, "expected text line argument");
d2003 1
a2003 3
	if (MDOC_TEXT != n->type)
		errx(1, "expected text line arguments");

d2039 1
a2039 3
	if (NULL == node->child || MDOC_TEXT != node->child->type)
		errx(1, "expected boolean line argument");

@


1.8
log
@sync to 1.7.16: adjust centering of header lines to groff conventions
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.7 2009/06/18 20:16:05 schwarze Exp $ */
d596 2
@


1.7
log
@sync to 1.7.16: footer in new groff style
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.6 2009/06/18 01:19:02 schwarze Exp $ */
d490 1
a490 1
	p->rmargin = (p->maxrmargin - strlen(buf)) / 2;
a495 1
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
d498 1
d511 1
a512 1
	p->offset = 0;
@


1.6
log
@sync to 1.7.16: make a couple of macros callable, reserve "|",
and some tweaks to .Lk
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.5 2009/06/17 22:27:34 schwarze Exp $ */
d398 8
a417 7
	/*
	 * This is /slightly/ different from regular groff output
	 * because we don't have page numbers.  Print the following:
	 *
	 * OS                                            MDOCDATE
	 */

d420 2
a422 2
	p->rmargin = p->maxrmargin - strlen(buf);
	p->offset = 0;
d427 2
d430 4
d437 1
d439 1
a439 1
	term_word(p, buf);
d441 4
@


1.5
log
@strftime returns size_t, not a pointer; no functional change
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.4 2009/06/15 02:53:35 schwarze Exp $ */
d2094 7
a2100 2
	if (NULL == (n = node->child))
		errx(1, "expected line argument");
a2103 1
	p->flags &= ~ttypes[TTYPE_LINK_ANCHOR];
d2106 1
d2109 1
a2109 1
	for ( ; n; n = n->next) {
d2111 1
a2111 1
	}
a2112 1

@


1.4
log
@sync to 1.7.16: an output function is the wrong place for validation code
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.3 2009/06/15 01:07:46 schwarze Exp $ */
d405 1
a405 1
	if (NULL == strftime(buf, p->rmargin, "%B %d, %Y", tm))
@


1.3
log
@sync to 1.7.16: adapt INDENT to groff conventions
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.2 2009/06/14 23:00:57 schwarze Exp $ */
a322 1
static	void	  sanity(const struct mdoc_node *);
d328 4
a356 4
	/* Some quick sanity-checking. */

	sanity(node);

a504 113
}


static void
sanity(const struct mdoc_node *n)
{
	char		*p;

	p = "regular form violated";

	switch (n->type) {
	case (MDOC_TEXT):
		if (n->child) 
			errx(1, p);
		if (NULL == n->parent) 
			errx(1, p);
		if (NULL == n->string)
			errx(1, p);
		switch (n->parent->type) {
		case (MDOC_TEXT):
			/* FALLTHROUGH */
		case (MDOC_ROOT):
			errx(1, p);
			/* NOTREACHED */
		default:
			break;
		}
		break;
	case (MDOC_ELEM):
		if (NULL == n->parent)
			errx(1, p);
		switch (n->parent->type) {
		case (MDOC_TAIL):
			/* FALLTHROUGH */
		case (MDOC_BODY):
			/* FALLTHROUGH */
		case (MDOC_HEAD):
			break;
		default:
			errx(1, p);
			/* NOTREACHED */
		}
		if (n->child) switch (n->child->type) {
		case (MDOC_TEXT):
			break;
		default:
			errx(1, p);
			/* NOTREACHED */
		}
		break;
	case (MDOC_HEAD):
		/* FALLTHROUGH */
	case (MDOC_BODY):
		/* FALLTHROUGH */
	case (MDOC_TAIL):
		if (NULL == n->parent)
			errx(1, p);
		if (MDOC_BLOCK != n->parent->type)
			errx(1, p);
		if (n->child) switch (n->child->type) {
		case (MDOC_BLOCK):
			/* FALLTHROUGH */
		case (MDOC_ELEM):
			/* FALLTHROUGH */
		case (MDOC_TEXT):
			break;
		default:
			errx(1, p);
			/* NOTREACHED */
		}
		break;
	case (MDOC_BLOCK):
		if (NULL == n->parent)
			errx(1, p);
		if (NULL == n->child)
			errx(1, p);
		switch (n->parent->type) {
		case (MDOC_ROOT):
			/* FALLTHROUGH */
		case (MDOC_HEAD):
			/* FALLTHROUGH */
		case (MDOC_BODY):
			/* FALLTHROUGH */
		case (MDOC_TAIL):
			break;
		default:
			errx(1, p);
			/* NOTREACHED */
		}
		switch (n->child->type) {
		case (MDOC_ROOT):
			/* FALLTHROUGH */
		case (MDOC_ELEM):
			errx(1, p);
			/* NOTREACHED */
		default:
			break;
		}
		break;
	case (MDOC_ROOT):
		if (n->parent)
			errx(1, p);
		if (NULL == n->child)
			errx(1, p);
		switch (n->child->type) {
		case (MDOC_BLOCK):
			break;
		default:
			errx(1, p);
			/* NOTREACHED */
		}
		break;
	}
@


1.2
log
@sync to 1.7.16: comments, whitespace and spelling fixes; no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.12 2009/06/12 09:18:00 kristaps Exp $ */
d1837 1
a1837 1
		p->offset = INDENT / 2;
@


1.1
log
@Initial check-in of mandoc for formatting manuals. ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: mdoc_term.c,v 1.4 2009/04/03 13:17:26 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d89 4
a92 4
	int	  	  flag;
	size_t	  	  offset;
	size_t	  	  rmargin;
	int		  count;
@

