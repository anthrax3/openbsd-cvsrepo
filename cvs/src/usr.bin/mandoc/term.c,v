head	1.119;
access;
symbols
	OPENBSD_6_0:1.117.0.2
	OPENBSD_6_0_BASE:1.117
	OPENBSD_5_9:1.116.0.2
	OPENBSD_5_9_BASE:1.116
	OPENBSD_5_8:1.108.0.4
	OPENBSD_5_8_BASE:1.108
	OPENBSD_5_7:1.104.0.2
	OPENBSD_5_7_BASE:1.104
	OPENBSD_5_6:1.85.0.4
	OPENBSD_5_6_BASE:1.85
	OPENBSD_5_5:1.77.0.4
	OPENBSD_5_5_BASE:1.77
	OPENBSD_5_4:1.68.0.2
	OPENBSD_5_4_BASE:1.68
	OPENBSD_5_3:1.67.0.2
	OPENBSD_5_3_BASE:1.67
	OPENBSD_5_2:1.66.0.2
	OPENBSD_5_2_BASE:1.66
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.2
	OPENBSD_5_0:1.59.0.2
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.56.0.2
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.46.0.2
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.119
date	2017.01.08.18.08.44;	author schwarze;	state Exp;
branches;
next	1.118;
commitid	XTQibZyr1IsvRxnx;

1.118
date	2016.08.10.11.02.30;	author schwarze;	state Exp;
branches;
next	1.117;
commitid	sL5KtBzF91hfUeVx;

1.117
date	2016.03.20.16.50.30;	author krw;	state Exp;
branches;
next	1.116;
commitid	uggNb1ponNWeI9Go;

1.116
date	2016.01.07.21.03.23;	author schwarze;	state Exp;
branches;
next	1.115;
commitid	0V6lUcmK8Ni6ISl7;

1.115
date	2015.10.23.14.49.13;	author schwarze;	state Exp;
branches;
next	1.114;
commitid	FVpUUzllPq9rhjrl;

1.114
date	2015.10.13.22.57.49;	author schwarze;	state Exp;
branches;
next	1.113;
commitid	jXIG8UzKLXm2Z9i6;

1.113
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.112;
commitid	Ql2ha5NS80pwfGNT;

1.112
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.111;
commitid	hxQV8O1pNUaef4ir;

1.111
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.110;
commitid	191tWtskbsgcpQqV;

1.110
date	2015.09.21.13.24.32;	author schwarze;	state Exp;
branches;
next	1.109;
commitid	hh1XsHF4k03QJZSt;

1.109
date	2015.08.30.21.10.40;	author schwarze;	state Exp;
branches;
next	1.108;
commitid	DnbNsfXZ80irkOz3;

1.108
date	2015.04.29.18.32.57;	author schwarze;	state Exp;
branches;
next	1.107;
commitid	Jraw3F5Czk5tAif5;

1.107
date	2015.04.04.17.46.58;	author schwarze;	state Exp;
branches;
next	1.106;
commitid	exqqP0KNSHrSyO21;

1.106
date	2015.04.02.23.47.43;	author schwarze;	state Exp;
branches;
next	1.105;
commitid	RJFkOLiS9gBqEEDl;

1.105
date	2015.03.09.17.35.13;	author schwarze;	state Exp;
branches;
next	1.104;
commitid	lIgxHwqoo1VmDcri;

1.104
date	2015.01.31.00.11.52;	author schwarze;	state Exp;
branches;
next	1.103;
commitid	qr0IBCEkFSkiYkBc;

1.103
date	2015.01.21.20.20.49;	author schwarze;	state Exp;
branches;
next	1.102;
commitid	oPCJQka1zVKJ04b2;

1.102
date	2014.12.24.23.31.59;	author schwarze;	state Exp;
branches;
next	1.101;
commitid	TfSx49MGGpeWF6md;

1.101
date	2014.12.24.09.57.41;	author schwarze;	state Exp;
branches;
next	1.100;
commitid	4KdFONMNDcZ3Fih8;

1.100
date	2014.12.23.13.48.15;	author schwarze;	state Exp;
branches;
next	1.99;
commitid	gQAVpbNdyny1vBnL;

1.99
date	2014.12.23.06.16.21;	author schwarze;	state Exp;
branches;
next	1.98;
commitid	GAXTq1cIP6hJILrE;

1.98
date	2014.12.19.17.10.42;	author schwarze;	state Exp;
branches;
next	1.97;
commitid	VKTVyFrMsLBbKLQJ;

1.97
date	2014.12.02.10.07.17;	author schwarze;	state Exp;
branches;
next	1.96;
commitid	G1dK13T4nePhhgx3;

1.96
date	2014.11.21.01.52.45;	author schwarze;	state Exp;
branches;
next	1.95;
commitid	hm1luQGz9X3OaZNV;

1.95
date	2014.11.16.21.29.27;	author schwarze;	state Exp;
branches;
next	1.94;
commitid	pN9PFZfnMTqAcBP6;

1.94
date	2014.11.01.04.03.22;	author schwarze;	state Exp;
branches;
next	1.93;
commitid	1IvWJvaS9eRhPVVd;

1.93
date	2014.10.29.00.17.01;	author schwarze;	state Exp;
branches;
next	1.92;
commitid	DT3doJsSOKw5l7CZ;

1.92
date	2014.10.28.18.48.56;	author schwarze;	state Exp;
branches;
next	1.91;
commitid	eWY0jZFHDE9PlMUQ;

1.91
date	2014.10.28.17.35.42;	author schwarze;	state Exp;
branches;
next	1.90;
commitid	pNwmOla3ZQwLgu2f;

1.90
date	2014.10.27.13.29.30;	author schwarze;	state Exp;
branches;
next	1.89;
commitid	rqEyu52UjJCimBJX;

1.89
date	2014.10.26.17.11.18;	author schwarze;	state Exp;
branches;
next	1.88;
commitid	d5isKf7CwbLlT0IO;

1.88
date	2014.08.18.22.21.52;	author schwarze;	state Exp;
branches;
next	1.87;
commitid	ABCB4r2MIVxldzWH;

1.87
date	2014.08.08.16.02.55;	author schwarze;	state Exp;
branches;
next	1.86;
commitid	vzFTgBJwsdUdMklQ;

1.86
date	2014.08.08.16.00.23;	author schwarze;	state Exp;
branches;
next	1.85;
commitid	m0QaUWeqjuHsvBSO;

1.85
date	2014.07.06.18.51.08;	author schwarze;	state Exp;
branches;
next	1.84;
commitid	UB7NsIc8hRrYukld;

1.84
date	2014.04.23.21.06.33;	author schwarze;	state Exp;
branches;
next	1.83;

1.83
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2014.04.08.07.13.01;	author schwarze;	state Exp;
branches;
next	1.81;

1.81
date	2014.04.05.21.17.48;	author schwarze;	state Exp;
branches;
next	1.80;

1.80
date	2014.03.30.21.27.59;	author schwarze;	state Exp;
branches;
next	1.79;

1.79
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.78;

1.78
date	2014.03.13.19.23.11;	author schwarze;	state Exp;
branches;
next	1.77;

1.77
date	2014.01.22.20.58.35;	author schwarze;	state Exp;
branches;
next	1.76;

1.76
date	2013.12.31.18.07.06;	author schwarze;	state Exp;
branches;
next	1.75;

1.75
date	2013.12.25.00.39.13;	author schwarze;	state Exp;
branches;
next	1.74;

1.74
date	2013.12.24.23.04.29;	author schwarze;	state Exp;
branches;
next	1.73;

1.73
date	2013.12.23.02.19.57;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2013.12.22.23.33.52;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2013.08.21.21.19.47;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2013.08.08.20.07.24;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2013.08.05.23.35.02;	author schwarze;	state Exp;
branches;
next	1.68;

1.68
date	2013.05.29.15.15.49;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2012.11.16.17.16.29;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2012.07.16.21.28.12;	author schwarze;	state Exp;
branches;
next	1.65;

1.65
date	2012.07.10.15.33.40;	author schwarze;	state Exp;
branches;
next	1.64;

1.64
date	2012.05.28.13.00.51;	author schwarze;	state Exp;
branches;
next	1.63;

1.63
date	2012.05.27.01.01.24;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2011.09.21.09.57.11;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2011.09.19.22.36.11;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2011.09.18.20.38.02;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2011.01.30.16.05.29;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2010.10.27.19.27.30;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2010.10.02.15.11.54;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2010.10.01.21.38.26;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2010.09.23.20.22.31;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2010.09.21.22.33.41;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2010.08.20.23.34.00;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2010.08.20.23.22.07;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2010.08.20.00.53.35;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2010.07.31.21.43.07;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.03.15.59.05;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.29.14.41.28;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.27.21.54.42;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.27.01.24.02;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.26.19.08.00;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2010.06.26.17.56.43;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.10.22.50.10;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2010.06.08.00.11.47;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.26.02.39.58;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.23.22.45.01;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.17.02.25.42;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2010.05.15.21.09.53;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.14.19.52.43;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.23.00.23.47;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.13.22.41.48;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.12.22.52.19;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2010.04.07.23.15.05;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2010.03.26.01.22.07;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2010.03.22.23.16.21;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2010.03.20.20.07.18;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2010.03.06.11.27.55;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2010.03.05.20.46.48;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2010.03.02.00.38.59;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.24.02.08.14;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.24.13.13.20;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.21.19.13.51;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.19.09.16.58;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.18.21.03.31;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.21.20.57.57;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.21.20.28.43;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.22.17.04.48;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.09.21.28.57;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2009.08.09.18.43.29;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.26.00.40.28;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.26.00.28.50;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.18.20.50.38;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.23.23.53.43;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.21.19.53.47;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.15.00.57.06;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.14.23.00.57;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.20.30.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.119
log
@Fix an assertion failure caused by \z\[u00FF] with -Tps/-Tpdf.
Reported by jsg@@ after an afl(1) run long ago.
@
text
@/*	$OpenBSD: term.c,v 1.118 2016/08/10 11:02:30 schwarze Exp $ */
/*
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010-2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc.h"
#include "mandoc_aux.h"
#include "out.h"
#include "term.h"
#include "main.h"

static	size_t		 cond_width(const struct termp *, int, int *);
static	void		 adjbuf(struct termp *p, size_t);
static	void		 bufferc(struct termp *, char);
static	void		 encode(struct termp *, const char *, size_t);
static	void		 encode1(struct termp *, int);


void
term_free(struct termp *p)
{

	free(p->buf);
	free(p->fontq);
	free(p);
}

void
term_begin(struct termp *p, term_margin head,
		term_margin foot, const struct roff_meta *arg)
{

	p->headf = head;
	p->footf = foot;
	p->argf = arg;
	(*p->begin)(p);
}

void
term_end(struct termp *p)
{

	(*p->end)(p);
}

/*
 * Flush a chunk of text.  By default, break the output line each time
 * the right margin is reached, and continue output on the next line
 * at the same offset as the chunk itself.  By default, also break the
 * output line at the end of the chunk.
 * The following flags may be specified:
 *
 *  - TERMP_NOBREAK: Do not break the output line at the right margin,
 *    but only at the max right margin.  Also, do not break the output
 *    line at the end of the chunk, such that the next call can pad to
 *    the next column.  However, if less than p->trailspace blanks,
 *    which can be 0, 1, or 2, remain to the right margin, the line
 *    will be broken.
 *  - TERMP_BRTRSP: Consider trailing whitespace significant
 *    when deciding whether the chunk fits or not.
 *  - TERMP_BRIND: If the chunk does not fit and the output line has
 *    to be broken, start the next line at the right margin instead
 *    of at the offset.  Used together with TERMP_NOBREAK for the tags
 *    in various kinds of tagged lists.
 *  - TERMP_DANGLE: Do not break the output line at the right margin,
 *    append the next chunk after it even if this one is too long.
 *    To be used together with TERMP_NOBREAK.
 *  - TERMP_HANG: Like TERMP_DANGLE, and also suppress padding before
 *    the next chunk if this column is not full.
 */
void
term_flushln(struct termp *p)
{
	size_t		 i;     /* current input position in p->buf */
	int		 ntab;	/* number of tabs to prepend */
	size_t		 vis;   /* current visual position on output */
	size_t		 vbl;   /* number of blanks to prepend to output */
	size_t		 vend;	/* end of word visual position on output */
	size_t		 bp;    /* visual right border position */
	size_t		 dv;    /* temporary for visual pos calculations */
	size_t		 j;     /* temporary loop index for p->buf */
	size_t		 jhy;	/* last hyph before overflow w/r/t j */
	size_t		 maxvis; /* output position of visible boundary */

	/*
	 * First, establish the maximum columns of "visible" content.
	 * This is usually the difference between the right-margin and
	 * an indentation, but can be, for tagged lists or columns, a
	 * small set of values.
	 *
	 * The following unsigned-signed subtractions look strange,
	 * but they are actually correct.  If the int p->overstep
	 * is negative, it gets sign extended.  Subtracting that
	 * very large size_t effectively adds a small number to dv.
	 */
	dv = p->rmargin > p->offset ? p->rmargin - p->offset : 0;
	maxvis = (int)dv > p->overstep ? dv - (size_t)p->overstep : 0;

	if (p->flags & TERMP_NOBREAK) {
		dv = p->maxrmargin > p->offset ?
		     p->maxrmargin - p->offset : 0;
		bp = (int)dv > p->overstep ?
		     dv - (size_t)p->overstep : 0;
	} else
		bp = maxvis;

	/*
	 * Calculate the required amount of padding.
	 */
	vbl = p->offset + p->overstep > p->viscol ?
	      p->offset + p->overstep - p->viscol : 0;

	vis = vend = 0;
	i = 0;

	while (i < p->col) {
		/*
		 * Handle literal tab characters: collapse all
		 * subsequent tabs into a single huge set of spaces.
		 */
		ntab = 0;
		while (i < p->col && '\t' == p->buf[i]) {
			vend = (vis / p->tabwidth + 1) * p->tabwidth;
			vbl += vend - vis;
			vis = vend;
			ntab++;
			i++;
		}

		/*
		 * Count up visible word characters.  Control sequences
		 * (starting with the CSI) aren't counted.  A space
		 * generates a non-printing word, which is valid (the
		 * space is printed according to regular spacing rules).
		 */

		for (j = i, jhy = 0; j < p->col; j++) {
			if (' ' == p->buf[j] || '\t' == p->buf[j])
				break;

			/* Back over the last printed character. */
			if (8 == p->buf[j]) {
				assert(j);
				vend -= (*p->width)(p, p->buf[j - 1]);
				continue;
			}

			/* Regular word. */
			/* Break at the hyphen point if we overrun. */
			if (vend > vis && vend < bp &&
			    (ASCII_HYPH == p->buf[j] ||
			     ASCII_BREAK == p->buf[j]))
				jhy = j;

			/*
			 * Hyphenation now decided, put back a real
			 * hyphen such that we get the correct width.
			 */
			if (ASCII_HYPH == p->buf[j])
				p->buf[j] = '-';

			vend += (*p->width)(p, p->buf[j]);
		}

		/*
		 * Find out whether we would exceed the right margin.
		 * If so, break to the next line.
		 */
		if (vend > bp && 0 == jhy && vis > 0) {
			vend -= vis;
			(*p->endline)(p);
			p->viscol = 0;
			if (TERMP_BRIND & p->flags) {
				vbl = p->rmargin;
				vend += p->rmargin;
				vend -= p->offset;
			} else
				vbl = p->offset;

			/* use pending tabs on the new line */

			if (0 < ntab)
				vbl += ntab * p->tabwidth;

			/*
			 * Remove the p->overstep width.
			 * Again, if p->overstep is negative,
			 * sign extension does the right thing.
			 */

			bp += (size_t)p->overstep;
			p->overstep = 0;
		}

		/* Write out the [remaining] word. */
		for ( ; i < p->col; i++) {
			if (vend > bp && jhy > 0 && i > jhy)
				break;
			if ('\t' == p->buf[i])
				break;
			if (' ' == p->buf[i]) {
				j = i;
				while (i < p->col && ' ' == p->buf[i])
					i++;
				dv = (i - j) * (*p->width)(p, ' ');
				vbl += dv;
				vend += dv;
				break;
			}
			if (ASCII_NBRSP == p->buf[i]) {
				vbl += (*p->width)(p, ' ');
				continue;
			}
			if (ASCII_BREAK == p->buf[i])
				continue;

			/*
			 * Now we definitely know there will be
			 * printable characters to output,
			 * so write preceding white space now.
			 */
			if (vbl) {
				(*p->advance)(p, vbl);
				p->viscol += vbl;
				vbl = 0;
			}

			(*p->letter)(p, p->buf[i]);
			if (8 == p->buf[i])
				p->viscol -= (*p->width)(p, p->buf[i-1]);
			else
				p->viscol += (*p->width)(p, p->buf[i]);
		}
		vis = vend;
	}

	/*
	 * If there was trailing white space, it was not printed;
	 * so reset the cursor position accordingly.
	 */
	if (vis > vbl)
		vis -= vbl;
	else
		vis = 0;

	p->col = 0;
	p->overstep = 0;
	p->flags &= ~(TERMP_BACKAFTER | TERMP_BACKBEFORE);

	if ( ! (TERMP_NOBREAK & p->flags)) {
		p->viscol = 0;
		(*p->endline)(p);
		return;
	}

	if (TERMP_HANG & p->flags) {
		p->overstep += (int)(p->offset + vis - p->rmargin +
		    p->trailspace * (*p->width)(p, ' '));

		/*
		 * If we have overstepped the margin, temporarily move
		 * it to the right and flag the rest of the line to be
		 * shorter.
		 * If there is a request to keep the columns together,
		 * allow negative overstep when the column is not full.
		 */
		if (p->trailspace && p->overstep < 0)
			p->overstep = 0;
		return;

	} else if (TERMP_DANGLE & p->flags)
		return;

	/* Trailing whitespace is significant in some columns. */
	if (vis && vbl && (TERMP_BRTRSP & p->flags))
		vis += vbl;

	/* If the column was overrun, break the line. */
	if (maxvis < vis + p->trailspace * (*p->width)(p, ' ')) {
		(*p->endline)(p);
		p->viscol = 0;
	}
}

/*
 * A newline only breaks an existing line; it won't assert vertical
 * space.  All data in the output buffer is flushed prior to the newline
 * assertion.
 */
void
term_newln(struct termp *p)
{

	p->flags |= TERMP_NOSPACE;
	if (p->col || p->viscol)
		term_flushln(p);
}

/*
 * Asserts a vertical space (a full, empty line-break between lines).
 * Note that if used twice, this will cause two blank spaces and so on.
 * All data in the output buffer is flushed prior to the newline
 * assertion.
 */
void
term_vspace(struct termp *p)
{

	term_newln(p);
	p->viscol = 0;
	if (0 < p->skipvsp)
		p->skipvsp--;
	else
		(*p->endline)(p);
}

/* Swap current and previous font; for \fP and .ft P */
void
term_fontlast(struct termp *p)
{
	enum termfont	 f;

	f = p->fontl;
	p->fontl = p->fontq[p->fonti];
	p->fontq[p->fonti] = f;
}

/* Set font, save current, discard previous; for \f, .ft, .B etc. */
void
term_fontrepl(struct termp *p, enum termfont f)
{

	p->fontl = p->fontq[p->fonti];
	p->fontq[p->fonti] = f;
}

/* Set font, save previous. */
void
term_fontpush(struct termp *p, enum termfont f)
{

	p->fontl = p->fontq[p->fonti];
	if (++p->fonti == p->fontsz) {
		p->fontsz += 8;
		p->fontq = mandoc_reallocarray(p->fontq,
		    p->fontsz, sizeof(*p->fontq));
	}
	p->fontq[p->fonti] = f;
}

/* Flush to make the saved pointer current again. */
void
term_fontpopq(struct termp *p, int i)
{

	assert(i >= 0);
	if (p->fonti > i)
		p->fonti = i;
}

/* Pop one font off the stack. */
void
term_fontpop(struct termp *p)
{

	assert(p->fonti);
	p->fonti--;
}

/*
 * Handle pwords, partial words, which may be either a single word or a
 * phrase that cannot be broken down (such as a literal string).  This
 * handles word styling.
 */
void
term_word(struct termp *p, const char *word)
{
	const char	 nbrsp[2] = { ASCII_NBRSP, 0 };
	const char	*seq, *cp;
	int		 sz, uc;
	size_t		 ssz;
	enum mandoc_esc	 esc;

	if ( ! (TERMP_NOSPACE & p->flags)) {
		if ( ! (TERMP_KEEP & p->flags)) {
			bufferc(p, ' ');
			if (TERMP_SENTENCE & p->flags)
				bufferc(p, ' ');
		} else
			bufferc(p, ASCII_NBRSP);
	}
	if (TERMP_PREKEEP & p->flags)
		p->flags |= TERMP_KEEP;

	if ( ! (p->flags & TERMP_NONOSPACE))
		p->flags &= ~TERMP_NOSPACE;
	else
		p->flags |= TERMP_NOSPACE;

	p->flags &= ~(TERMP_SENTENCE | TERMP_NONEWLINE);
	p->skipvsp = 0;

	while ('\0' != *word) {
		if ('\\' != *word) {
			if (TERMP_NBRWORD & p->flags) {
				if (' ' == *word) {
					encode(p, nbrsp, 1);
					word++;
					continue;
				}
				ssz = strcspn(word, "\\ ");
			} else
				ssz = strcspn(word, "\\");
			encode(p, word, ssz);
			word += (int)ssz;
			continue;
		}

		word++;
		esc = mandoc_escape(&word, &seq, &sz);
		if (ESCAPE_ERROR == esc)
			continue;

		switch (esc) {
		case ESCAPE_UNICODE:
			uc = mchars_num2uc(seq + 1, sz - 1);
			break;
		case ESCAPE_NUMBERED:
			uc = mchars_num2char(seq, sz);
			if (uc < 0)
				continue;
			break;
		case ESCAPE_SPECIAL:
			if (p->enc == TERMENC_ASCII) {
				cp = mchars_spec2str(seq, sz, &ssz);
				if (cp != NULL)
					encode(p, cp, ssz);
			} else {
				uc = mchars_spec2cp(seq, sz);
				if (uc > 0)
					encode1(p, uc);
			}
			continue;
		case ESCAPE_FONTBOLD:
			term_fontrepl(p, TERMFONT_BOLD);
			continue;
		case ESCAPE_FONTITALIC:
			term_fontrepl(p, TERMFONT_UNDER);
			continue;
		case ESCAPE_FONTBI:
			term_fontrepl(p, TERMFONT_BI);
			continue;
		case ESCAPE_FONT:
		case ESCAPE_FONTROMAN:
			term_fontrepl(p, TERMFONT_NONE);
			continue;
		case ESCAPE_FONTPREV:
			term_fontlast(p);
			continue;
		case ESCAPE_NOSPACE:
			if (p->flags & TERMP_BACKAFTER)
				p->flags &= ~TERMP_BACKAFTER;
			else if (*word == '\0')
				p->flags |= (TERMP_NOSPACE | TERMP_NONEWLINE);
			continue;
		case ESCAPE_SKIPCHAR:
			p->flags |= TERMP_BACKAFTER;
			continue;
		case ESCAPE_OVERSTRIKE:
			cp = seq + sz;
			while (seq < cp) {
				if (*seq == '\\') {
					mandoc_escape(&seq, NULL, NULL);
					continue;
				}
				encode1(p, *seq++);
				if (seq < cp) {
					if (p->flags & TERMP_BACKBEFORE)
						p->flags |= TERMP_BACKAFTER;
					else
						p->flags |= TERMP_BACKBEFORE;
				}
			}
			/* Trim trailing backspace/blank pair. */
			if (p->col > 2 &&
			    (p->buf[p->col - 1] == ' ' ||
			     p->buf[p->col - 1] == '\t'))
				p->col -= 2;
			continue;
		default:
			continue;
		}

		/*
		 * Common handling for Unicode and numbered
		 * character escape sequences.
		 */

		if (p->enc == TERMENC_ASCII) {
			cp = ascii_uc2str(uc);
			encode(p, cp, strlen(cp));
		} else {
			if ((uc < 0x20 && uc != 0x09) ||
			    (uc > 0x7E && uc < 0xA0))
				uc = 0xFFFD;
			encode1(p, uc);
		}
	}
	p->flags &= ~TERMP_NBRWORD;
}

static void
adjbuf(struct termp *p, size_t sz)
{

	if (0 == p->maxcols)
		p->maxcols = 1024;
	while (sz >= p->maxcols)
		p->maxcols <<= 2;

	p->buf = mandoc_reallocarray(p->buf, p->maxcols, sizeof(int));
}

static void
bufferc(struct termp *p, char c)
{

	if (p->col + 1 >= p->maxcols)
		adjbuf(p, p->col + 1);

	p->buf[p->col++] = c;
}

/*
 * See encode().
 * Do this for a single (probably unicode) value.
 * Does not check for non-decorated glyphs.
 */
static void
encode1(struct termp *p, int c)
{
	enum termfont	  f;

	if (p->col + 7 >= p->maxcols)
		adjbuf(p, p->col + 7);

	f = (c == ASCII_HYPH || c > 127 || isgraph(c)) ?
	    p->fontq[p->fonti] : TERMFONT_NONE;

	if (p->flags & TERMP_BACKBEFORE) {
		if (p->buf[p->col - 1] == ' ' || p->buf[p->col - 1] == '\t')
			p->col--;
		else
			p->buf[p->col++] = 8;
		p->flags &= ~TERMP_BACKBEFORE;
	}
	if (TERMFONT_UNDER == f || TERMFONT_BI == f) {
		p->buf[p->col++] = '_';
		p->buf[p->col++] = 8;
	}
	if (TERMFONT_BOLD == f || TERMFONT_BI == f) {
		if (ASCII_HYPH == c)
			p->buf[p->col++] = '-';
		else
			p->buf[p->col++] = c;
		p->buf[p->col++] = 8;
	}
	p->buf[p->col++] = c;
	if (p->flags & TERMP_BACKAFTER) {
		p->flags |= TERMP_BACKBEFORE;
		p->flags &= ~TERMP_BACKAFTER;
	}
}

static void
encode(struct termp *p, const char *word, size_t sz)
{
	size_t		  i;

	if (p->col + 2 + (sz * 5) >= p->maxcols)
		adjbuf(p, p->col + 2 + (sz * 5));

	for (i = 0; i < sz; i++) {
		if (ASCII_HYPH == word[i] ||
		    isgraph((unsigned char)word[i]))
			encode1(p, word[i]);
		else {
			p->buf[p->col++] = word[i];

			/*
			 * Postpone the effect of \z while handling
			 * an overstrike sequence from ascii_uc2str().
			 */

			if (word[i] == '\b' &&
			    (p->flags & TERMP_BACKBEFORE)) {
				p->flags &= ~TERMP_BACKBEFORE;
				p->flags |= TERMP_BACKAFTER;
			}
		}
	}
}

void
term_setwidth(struct termp *p, const char *wstr)
{
	struct roffsu	 su;
	int		 iop, width;

	iop = 0;
	width = 0;
	if (NULL != wstr) {
		switch (*wstr) {
		case '+':
			iop = 1;
			wstr++;
			break;
		case '-':
			iop = -1;
			wstr++;
			break;
		default:
			break;
		}
		if (a2roffsu(wstr, &su, SCALE_MAX))
			width = term_hspan(p, &su);
		else
			iop = 0;
	}
	(*p->setwidth)(p, iop, width);
}

size_t
term_len(const struct termp *p, size_t sz)
{

	return (*p->width)(p, ' ') * sz;
}

static size_t
cond_width(const struct termp *p, int c, int *skip)
{

	if (*skip) {
		(*skip) = 0;
		return 0;
	} else
		return (*p->width)(p, c);
}

size_t
term_strlen(const struct termp *p, const char *cp)
{
	size_t		 sz, rsz, i;
	int		 ssz, skip, uc;
	const char	*seq, *rhs;
	enum mandoc_esc	 esc;
	static const char rej[] = { '\\', ASCII_NBRSP, ASCII_HYPH,
			ASCII_BREAK, '\0' };

	/*
	 * Account for escaped sequences within string length
	 * calculations.  This follows the logic in term_word() as we
	 * must calculate the width of produced strings.
	 */

	sz = 0;
	skip = 0;
	while ('\0' != *cp) {
		rsz = strcspn(cp, rej);
		for (i = 0; i < rsz; i++)
			sz += cond_width(p, *cp++, &skip);

		switch (*cp) {
		case '\\':
			cp++;
			esc = mandoc_escape(&cp, &seq, &ssz);
			if (ESCAPE_ERROR == esc)
				continue;

			rhs = NULL;

			switch (esc) {
			case ESCAPE_UNICODE:
				uc = mchars_num2uc(seq + 1, ssz - 1);
				break;
			case ESCAPE_NUMBERED:
				uc = mchars_num2char(seq, ssz);
				if (uc < 0)
					continue;
				break;
			case ESCAPE_SPECIAL:
				if (p->enc == TERMENC_ASCII) {
					rhs = mchars_spec2str(seq, ssz, &rsz);
					if (rhs != NULL)
						break;
				} else {
					uc = mchars_spec2cp(seq, ssz);
					if (uc > 0)
						sz += cond_width(p, uc, &skip);
				}
				continue;
			case ESCAPE_SKIPCHAR:
				skip = 1;
				continue;
			case ESCAPE_OVERSTRIKE:
				rsz = 0;
				rhs = seq + ssz;
				while (seq < rhs) {
					if (*seq == '\\') {
						mandoc_escape(&seq, NULL, NULL);
						continue;
					}
					i = (*p->width)(p, *seq++);
					if (rsz < i)
						rsz = i;
				}
				sz += rsz;
				continue;
			default:
				continue;
			}

			/*
			 * Common handling for Unicode and numbered
			 * character escape sequences.
			 */

			if (rhs == NULL) {
				if (p->enc == TERMENC_ASCII) {
					rhs = ascii_uc2str(uc);
					rsz = strlen(rhs);
				} else {
					if ((uc < 0x20 && uc != 0x09) ||
					    (uc > 0x7E && uc < 0xA0))
						uc = 0xFFFD;
					sz += cond_width(p, uc, &skip);
					continue;
				}
			}

			if (skip) {
				skip = 0;
				break;
			}

			/*
			 * Common handling for all escape sequences
			 * printing more than one character.
			 */

			for (i = 0; i < rsz; i++)
				sz += (*p->width)(p, *rhs++);
			break;
		case ASCII_NBRSP:
			sz += cond_width(p, ' ', &skip);
			cp++;
			break;
		case ASCII_HYPH:
			sz += cond_width(p, '-', &skip);
			cp++;
			break;
		default:
			break;
		}
	}

	return sz;
}

int
term_vspan(const struct termp *p, const struct roffsu *su)
{
	double		 r;
	int		 ri;

	switch (su->unit) {
	case SCALE_BU:
		r = su->scale / 40.0;
		break;
	case SCALE_CM:
		r = su->scale * 6.0 / 2.54;
		break;
	case SCALE_FS:
		r = su->scale * 65536.0 / 40.0;
		break;
	case SCALE_IN:
		r = su->scale * 6.0;
		break;
	case SCALE_MM:
		r = su->scale * 0.006;
		break;
	case SCALE_PC:
		r = su->scale;
		break;
	case SCALE_PT:
		r = su->scale / 12.0;
		break;
	case SCALE_EN:
	case SCALE_EM:
		r = su->scale * 0.6;
		break;
	case SCALE_VS:
		r = su->scale;
		break;
	default:
		abort();
	}
	ri = r > 0.0 ? r + 0.4995 : r - 0.4995;
	return ri < 66 ? ri : 1;
}

/*
 * Convert a scaling width to basic units, rounding down.
 */
int
term_hspan(const struct termp *p, const struct roffsu *su)
{

	return (*p->hspan)(p, su);
}
@


1.118
log
@Fix assertion failures caused by whitespace inside \o'' (overstrike)
sequences that jsg@@ found with afl(1):
* Avoid writing \t\b in term.c.
* Handle trailing \b in term_ps.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.117 2016/03/20 16:50:30 krw Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2016 Ingo Schwarze <schwarze@@openbsd.org>
d607 1
a607 1
		else
d609 12
@


1.117
log
@" the the " -> " the ", or in a couple of cases replace the superfluous
"the" with the obviously intended word.

Started with a "the the" spotted by Mihal Mazurek.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.116 2016/01/07 21:03:23 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2015 Ingo Schwarze <schwarze@@openbsd.org>
d505 3
a507 1
			if (p->col > 2 && p->buf[p->col - 1] == ' ')
d571 1
a571 1
		if (p->buf[p->col - 1] == ' ')
@


1.116
log
@This code wasted memory by allocating sizeof(enum termfont *)
where only sizeof(enum termfont) is needed.
Fixes CID 1288941.  From christos@@ via wiz@@, both at NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.115 2015/10/23 14:49:13 schwarze Exp $ */
d161 1
a161 1
			/* Back over the the last printed character. */
@


1.115
log
@apply bold and italic to all non-ASCII Unicode codepoints,
fixing input like \fB\('e; issue reported by bentley@@
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.114 2015/10/13 22:57:49 schwarze Exp $ */
d366 1
a366 1
		    p->fontsz, sizeof(enum termfont *));
@


1.114
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.113 2015/10/12 00:07:27 schwarze Exp $ */
d565 1
a565 1
	f = (c == ASCII_HYPH || isgraph(c)) ?
@


1.113
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.112 2015/10/06 18:30:44 schwarze Exp $ */
d455 1
a455 2
				cp = mchars_spec2str(p->symtab,
				    seq, sz, &ssz);
d459 1
a459 1
				uc = mchars_spec2cp(p->symtab, seq, sz);
d700 1
a700 2
					rhs = mchars_spec2str(p->symtab,
					    seq, ssz, &rsz);
d704 1
a704 2
					uc = mchars_spec2cp(p->symtab,
					    seq, ssz);
@


1.112
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.111 2015/09/26 00:53:15 schwarze Exp $ */
a474 1
			/* FALLTHROUGH */
a770 2
			/* FALLTHROUGH */
		case ASCII_BREAK:
a808 1
		/* FALLTHROUGH */
@


1.111
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.110 2015/09/21 13:24:32 schwarze Exp $ */
d645 1
a645 1
	return((*p->width)(p, ' ') * sz);
d654 1
a654 1
		return(0);
d656 1
a656 1
		return((*p->width)(p, c));
d780 1
a780 1
	return(sz);
d823 1
a823 1
	return(ri < 66 ? ri : 1);
d833 1
a833 1
	return((*p->hspan)(p, su));
@


1.110
log
@Trailing whitespace is significant when determining the width of a tag
in mdoc(7) .Bl -tag and man(7) .TP, but not in man(7) .IP.
Quirk reported by Jan Stary <hans at stare dot cz> on ports@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.109 2015/08/30 21:10:40 schwarze Exp $ */
a820 1
		/* NOTREACHED */
@


1.109
log
@Drop leading, internal, and trailing blank characters in \o (overstrike)
escape sequences; that's cleaner for all output modes, and it's required
to prevent the PostScript/PDF formatter from dying on assertions.
Bug found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.108 2015/04/29 18:32:57 schwarze Exp $ */
d79 2
d293 4
@


1.108
log
@Replace the kludge for the \z escape sequence by an actual
implementation.  As a side effect, minus ten lines of code.

As another side effect, this also fixes the assertion failure that
used to be triggered by "\z\o'ab'c" at the beginning of an output
line, found by jsg@@ with afl (test case 022/Apr27).
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.107 2015/04/04 17:46:58 schwarze Exp $ */
d500 3
d565 4
a568 1
		p->buf[p->col++] = 8;
@


1.107
log
@Rounding rules for horizontal scaling widths are more complicated.
There is a first rounding to basic units on the input side.
After that, rounding rules differ between requests and macros.
Requests round to the nearest possible character position.
Macros round to the next character position to the left.

Implement that by changing the return value of term_hspan()
to basic units and leaving the second scaling and rounding stage
to the formatters instead of doing it in the terminal handler.

Improves for example argtable2(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.106 2015/04/02 23:47:43 schwarze Exp $ */
d266 1
a418 5
			if (TERMP_SKIPCHAR & p->flags) {
				p->flags &= ~TERMP_SKIPCHAR;
				word++;
				continue;
			}
d477 3
a479 3
			if (TERMP_SKIPCHAR & p->flags)
				p->flags &= ~TERMP_SKIPCHAR;
			else if ('\0' == *word)
d483 1
a483 1
			p->flags |= TERMP_SKIPCHAR;
d493 6
a498 2
				if (seq < cp)
					encode(p, "\b", 1);
d500 1
d555 2
a556 7
	if (TERMP_SKIPCHAR & p->flags) {
		p->flags &= ~TERMP_SKIPCHAR;
		return;
	}

	if (p->col + 6 >= p->maxcols)
		adjbuf(p, p->col + 6);
d558 2
a559 1
	f = p->fontq[p->fonti];
d561 4
d577 4
d588 2
a589 23
	if (TERMP_SKIPCHAR & p->flags) {
		p->flags &= ~TERMP_SKIPCHAR;
		return;
	}

	/*
	 * Encode and buffer a string of characters.  If the current
	 * font mode is unset, buffer directly, else encode then buffer
	 * character by character.
	 */

	if (p->fontq[p->fonti] == TERMFONT_NONE) {
		if (p->col + sz >= p->maxcols)
			adjbuf(p, p->col + sz);
		for (i = 0; i < sz; i++)
			p->buf[p->col++] = word[i];
		return;
	}

	/* Pre-buffer, assuming worst-case. */

	if (p->col + 1 + (sz * 5) >= p->maxcols)
		adjbuf(p, p->col + 1 + (sz * 5));
@


1.106
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.105 2015/03/09 17:35:13 schwarze Exp $ */
d620 1
a620 2
	size_t		 width;
	int		 iop;
d831 3
a836 1
	double		 v;
d838 1
a838 2
	v = (*p->hspan)(p, su);
	return(v > 0.0 ? v + 0.0005 : v - 0.0005);
@


1.105
log
@prevent the skipvsp flag from creeping past actual text
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.104 2015/01/31 00:11:52 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d50 1
a50 1
		term_margin foot, const void *arg)
@


1.104
log
@Use relative offsets instead of absolute pointers for the terminal
font stack.  The latter fail after the stack is grown with realloc().
Fixing an assertion failure found by jsg@@ with afl some time ago
(test case number 51).
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.103 2015/01/21 20:20:49 schwarze Exp $ */
d414 1
@


1.103
log
@Rudimentary implementation of the roff(7) \o escape sequence (overstrike).
This is of some relevance because the pod2man(1) preamble abuses it
for the icelandic letter Thorn, instead of simply using \(TP and \(Tp.
Missing feature found by sthen@@ in DateTime::Locale::is_IS(3p).
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.102 2014/12/24 23:31:59 schwarze Exp $ */
a363 8
/* Retrieve pointer to current font. */
const enum termfont *
term_fontq(struct termp *p)
{

	return(&p->fontq[p->fonti]);
}

d366 1
a366 1
term_fontpopq(struct termp *p, const enum termfont *key)
d369 3
a371 3
	while (p->fonti >= 0 && key < p->fontq + p->fonti)
		p->fonti--;
	assert(p->fonti >= 0);
d561 1
a561 1
	f = *term_fontq(p);
d593 1
a593 1
	if (*term_fontq(p) == TERMFONT_NONE) {
@


1.102
log
@Support negative indentations for mdoc(7) displays and lists.
Not exactly recommended for use, rather for groff compatibility.
While here, introduce similar SHRT_MAX limits as in man(7),
fixing a few cases of infinite output found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.101 2014/12/24 09:57:41 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2014 Ingo Schwarze <schwarze@@openbsd.org>
d496 11
d727 14
@


1.101
log
@When a man(7) document contains unreasonably large numbers for
indentations or paragraph distances, large output may be generated,
which is practically the same as an endless loop; found by jsg@@
with afl.
Reject such unreasonably large numbers beyond arbitrary limits
similar to those used by groff (max. 65 blank lines between paragraphs
and max. SHRT_MAX characters per output line) and fall back to
defaults when exceeded.  Having the limits behave in exactly the
same way is not relevant.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.100 2014/12/23 13:48:15 schwarze Exp $ */
d274 1
a274 1
		p->overstep = (int)(vis - maxvis +
@


1.100
log
@support negative horizontal widths in man(7);
minus twenty lines of code in spite of enhanced functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.99 2014/12/23 06:16:21 schwarze Exp $ */
d774 1
d810 2
a811 1
	return(r > 0.0 ? r + 0.4995 : r - 0.4995);
@


1.99
log
@Fix vertical scaling.  Obviously, nobody ever had a serious look at this.
Basic units, centimeters, points, ens, ems, and the rounding algorithm
were all wrong, only inches, pica, and the default vertical span worked.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.98 2014/12/19 17:10:42 schwarze Exp $ */
a101 1
	size_t		 rmargin; /* the rightmost of the two margins */
d114 1
a114 2
	rmargin = p->rmargin > p->offset ? p->rmargin : p->offset;
	dv = p->rmargin - p->offset;
d192 3
a194 2
				vbl = rmargin;
				vend += rmargin - p->offset;
d770 1
a770 1
size_t
d809 1
a809 4

	if (r < 0.0)
		r = 0.0;
	return((size_t)(r + 0.4995));
d812 1
a812 1
size_t
d818 1
a818 3
	if (v < 0.0)
		v = 0.0;
	return((size_t)(v + 0.0005));
@


1.98
log
@Enforcing an arbitrary, implementation dependent, undocumented limit
by calling assert() when valid user input exceeds it is a bad idea.
Allocate the terminal font stack dynamically instead of crashing
above 10 entries.  Issue found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.97 2014/12/02 10:07:17 schwarze Exp $ */
d777 3
d781 4
a784 1
		r = su->scale * 2.0;
d789 3
d796 1
a796 1
		r = su->scale / 8.0;
d798 4
a801 2
	case SCALE_MM:
		r = su->scale / 1000.0;
d807 2
a808 2
		r = su->scale - 1.0;
		break;
d813 1
a813 1
	return((size_t)(r + 0.0005));
@


1.97
log
@Fix the implementation and documentation of \c (continue text input line).
In particular, make it work in no-fill mode, too.
Reminded by Carsten dot Kunze at arcor dot de (Heirloom roff).
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.96 2014/11/21 01:52:45 schwarze Exp $ */
d44 1
d331 1
d342 1
d351 1
a355 1
	assert(p->fonti + 1 < 10);
d357 6
a362 1
	p->fontq[++p->fonti] = f;
d365 2
a366 1
const void *
d373 1
a373 7
enum termfont
term_fonttop(struct termp *p)
{

	return(p->fontq[p->fonti]);
}

d375 1
a375 1
term_fontpopq(struct termp *p, const void *key)
d378 1
a378 1
	while (p->fonti >= 0 && key < (void *)(p->fontq + p->fonti))
d383 1
d559 1
a559 1
	f = term_fonttop(p);
d591 1
a591 1
	if (TERMFONT_NONE == term_fonttop(p)) {
@


1.96
log
@We repeatedly observed assertion crashes in the low-level terminal
output handler because the high level terminal formatters could be
tricked into setting the left margin further to the right than the
right margin.  Today, jsg@@ found more of these with afl.

Change the internal interface between both levels, aiming for
simplicity and robustness of the code.  Treat both margins as
*independent* settings:  Now, termp.offset is the requested left
margin, and termp.rmargin is the available space.  Let the lower
level cope with that case of insufficient space.

Obviously, high level code that does centering or flush right
still has to do careful checks, so i did a full audit of margin
settings in the terminal formatters.

Fixes crashes caused by excessively long title or date strings in
the man(7) footer, operating system or date strings in the mdoc(7)
footer, volume strings in the man(7) or mdoc(7) header, and a few
cases related to some non-prologue macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.95 2014/11/16 21:29:27 schwarze Exp $ */
d418 1
a418 1
	p->flags &= ~TERMP_SENTENCE;
d488 1
a488 1
				p->flags |= TERMP_NOSPACE;
@


1.95
log
@When a line (in the sense of term_flushln()) contains white space only,
the `vbl' variable includes the left margin, but `vis' does not.
Prevent a `vis' underflow that caused a bogus blank line.
Bug reported by Carsten Kunze, found in less(1): .Bl -tag ... .It " "
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.94 2014/11/01 04:03:22 schwarze Exp $ */
d101 1
a101 1
	size_t		 mmax; /* used in calculating bp */
d114 2
a115 2
	assert  (p->rmargin >= p->offset);
	dv     = p->rmargin - p->offset;
a116 2
	dv     = p->maxrmargin - p->offset;
	mmax   = (int)dv > p->overstep ? dv - (size_t)p->overstep : 0;
d118 7
a124 1
	bp = TERMP_NOBREAK & p->flags ? mmax : maxvis;
d193 2
a194 2
				vbl = p->rmargin;
				vend += p->rmargin - p->offset;
@


1.94
log
@fix a typo causing crashes in Unicode string length measurement
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.93 2014/10/29 00:17:01 schwarze Exp $ */
d255 1
a255 1
	if (vis)
d257 2
@


1.93
log
@In terminal output, unify handling of Unicode and numbered character
escape sequences just like it was earlier implemented for -Thtml.
Do not let control characters other than ASCII 9 (horizontal tab)
propagate to the output, even though groff allows them; but that
really doesn't look like a great idea.

Let mchars_num2char() return int such that we can distinguish invalid \N
syntax from \N'0'.  This also reduces the danger of signed char issues
popping up.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.92 2014/10/28 18:48:56 schwarze Exp $ */
d685 1
a685 1
				uc = mchars_num2uc(seq + 1, sz - 1);
@


1.92
log
@In -Tascii mode, print "<?>" only for Unicode escapes of unknown
representation, not for character escapes with unknown names.
According to groff, the latter produce no output, and we now warn
about them.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.91 2014/10/28 17:35:42 schwarze Exp $ */
a391 1
	char		 c;
a442 5
			if (p->enc == TERMENC_ASCII) {
				cp = ascii_uc2str(uc);
				encode(p, cp, strlen(cp));
			} else
				encode1(p, uc);
d445 3
a447 3
			c = mchars_num2char(seq, sz);
			if ('\0' != c)
				encode(p, &c, 1);
d460 1
a460 1
			break;
d463 1
a463 1
			break;
d466 1
a466 1
			break;
d469 1
a469 1
			break;
d474 1
a474 1
			break;
d477 1
a477 1
			break;
d483 1
a483 1
			break;
d486 1
a486 1
			break;
d488 16
a503 1
			break;
d655 1
a655 1
	int		 ssz, skip, c;
d685 1
a685 6
				c = mchars_num2uc(seq + 1, sz - 1);
				if (p->enc == TERMENC_ASCII) {
					rhs = ascii_uc2str(c);
					rsz = strlen(rhs);
				} else
					sz += cond_width(p, c, &skip);
d688 3
a690 3
				c = mchars_num2char(seq, ssz);
				if ('\0' != c)
					sz += cond_width(p, c, &skip);
d693 1
a693 1
				if (p->enc == TERMENC_ASCII)
d696 4
a699 2
				else {
					c = mchars_spec2cp(p->symtab,
d701 2
a702 2
					if (c > 0)
						sz += cond_width(p, c, &skip);
d704 1
a704 1
				break;
d707 1
a707 1
				break;
d709 1
a709 1
				break;
d712 17
a728 2
			if (NULL == rhs)
				break;
d734 5
@


1.91
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.90 2014/10/27 13:29:30 schwarze Exp $ */
d459 1
a459 3
				if (cp == NULL)
					encode(p, "<?>", 3);
				else
d689 1
a689 1
				if (p->enc == TERMENC_ASCII) {
d692 1
a692 5
					if (rhs == NULL) {
						rhs = "<?>";
						rsz = 3;
					}
				} else {
@


1.90
log
@Fix a regression in term.c rev. 1.89 reported by bentley@@:
In UTF-8 output, do not print anything if mchars_spec2cp() returns 0.
In particular, this repairs handling of zero-width spaces (\&).

While here, let mchars_spec2cp() return 0xFFFD instead of -1
if the character is not found, simplifying the using code.
In HTML output, do not print obfuscated ASCII characters and
do not test for one-char escapes, mchars_spec2cp() already does that.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.89 2014/10/26 17:11:18 schwarze Exp $ */
d43 1
a43 5
	if (p->buf)
		free(p->buf);
	if (p->symtab)
		mchars_free(p->symtab);

@


1.89
log
@Improve -Tascii output for Unicode escape sequences: For the first 512
code points, provide ASCII approximations.  This is already much better
than what groff does, which prints nothing for most code points.

A few minor fixes while here:
* Handle Unicode escape sequences in the ASCII range.
* In case of errors, use the REPLACEMENT CHARACTER U+FFFD for -Tutf8
and the string "<?>" for -Tascii output.
* Handle all one-character escape sequences in mchars_spec2{cp,str}()
and remove the workarounds on the higher level.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d469 2
a470 3
				if (uc <= 0)
					uc = 0xFFFD;
				encode1(p, uc);
d705 2
a706 3
					if (c <= 0)
						c = 0xFFFD;
					sz += cond_width(p, c, &skip);
@


1.88
log
@Fix read access to uninitialized memory found by kristaps@@ with valgrind,
patch from kristaps@@.
Theoretically, this could lead to a buffer overrun and segfault,
but only for very long output lines (about 1000 charecters) of
exactly the right length or if by ill chance, the complete unused,
uninitialized tail of the line output buffer (at least 1000 characters
total length) would contain all blank characters.  Anyway, the
uninitialized data read wasn't used for anything.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.87 2014/08/08 16:02:55 schwarze Exp $ */
a444 18
		if (TERMENC_ASCII != p->enc)
			switch (esc) {
			case ESCAPE_UNICODE:
				uc = mchars_num2uc(seq + 1, sz - 1);
				if ('\0' == uc)
					break;
				encode1(p, uc);
				continue;
			case ESCAPE_SPECIAL:
				uc = mchars_spec2cp(p->symtab, seq, sz);
				if (uc <= 0)
					break;
				encode1(p, uc);
				continue;
			default:
				break;
			}

d447 6
a452 1
			encode1(p, '?');
d460 13
a472 5
			cp = mchars_spec2str(p->symtab, seq, sz, &ssz);
			if (NULL != cp)
				encode(p, cp, ssz);
			else if (1 == ssz)
				encode(p, seq, sz);
a678 20
			if (TERMENC_ASCII != p->enc)
				switch (esc) {
				case ESCAPE_UNICODE:
					c = mchars_num2uc(seq + 1,
					    ssz - 1);
					if ('\0' == c)
						break;
					sz += cond_width(p, c, &skip);
					continue;
				case ESCAPE_SPECIAL:
					c = mchars_spec2cp(p->symtab,
					    seq, ssz);
					if (c <= 0)
						break;
					sz += cond_width(p, c, &skip);
					continue;
				default:
					break;
				}

d683 6
a688 1
				sz += cond_width(p, '?', &skip);
d696 14
a709 8
				rhs = mchars_spec2str(p->symtab,
				    seq, ssz, &rsz);

				if (ssz != 1 || rhs)
					break;

				rhs = seq;
				rsz = ssz;
@


1.87
log
@Fix floating point handling: When converting double to size_t,
properly round to the nearest M (=0.001m), which is the smallest
available unit.

This avoids weirdness like (size_t)(0.6 * 10.0) == 5
by instead calculating (size_t)(0.6 * 10.0 + 0.0005) == 6,
and so it fixes the indentation of the readline(3) manual.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.86 2014/08/08 16:00:23 schwarze Exp $ */
d221 1
a221 1
				while (' ' == p->buf[i])
@


1.86
log
@Clarity with respect to floating point handling:
Write double constants as double rather than integer literals.
Remove useless explicit (double) cast done at one place and nowhere else.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.85 2014/07/06 18:51:08 schwarze Exp $ */
d792 1
a792 1
	return((size_t)r);
d803 1
a803 1
	return((size_t)v);
@


1.85
log
@After skipping an escape sequence with incomplete arguments,
do not throw away the rest of the string to be rendered.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.84 2014/04/23 21:06:33 schwarze Exp $ */
d768 1
a768 1
		r = su->scale * 2;
d771 1
a771 1
		r = su->scale * 6;
d777 1
a777 1
		r = su->scale / 8;
d780 1
a780 1
		r = su->scale / 1000;
d786 1
a786 1
		r = su->scale - 1;
d800 1
a800 1
	v = ((*p->hspan)(p, su));
@


1.84
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
* Change eight reallocs to reallocarray to be safe from overflows.
* Change one malloc to reallocarray to be safe from overflows.
* Change one calloc to reallocarray, no zeroing needed.
* Change the order of arguments of three callocs (aesthetical).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.83 2014/04/20 16:44:44 schwarze Exp $ */
d443 1
a443 1
			break;
d682 1
a682 1
				return(sz);
@


1.83
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.82 2014/04/08 07:13:01 schwarze Exp $ */
d521 1
a521 1
	p->buf = mandoc_realloc(p->buf, sizeof(int) * p->maxcols);
@


1.82
log
@Add a new term_flushln() flag TERMP_BRIND (if break, then indent)
to control indentation of continuation lines in TERMP_NOBREAK mode.
In the past, this was always on; continue using it
for .Bl, .Nm, .Fn, .Fo, and .HP, but no longer for .IP and .TP.

I looked at this because sthen@@ reported the issue in a manual
of a Perl module from ports, but it affects base, too: This patch
reduces groff-mandoc differences in base by more than 15%.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.81 2014/04/05 21:17:48 schwarze Exp $ */
d38 1
a50 1

d52 1
a52 1
term_begin(struct termp *p, term_margin head, 
a61 1

d169 1
a169 1
			if (vend > vis && vend < bp && 
d249 1
a249 1
			else 
d273 1
a273 1
				p->trailspace * (*p->width)(p, ' '));
d296 1
a296 2

/* 
a309 1

a337 1

a345 1

a354 1

a361 1

a368 1

a377 1

d447 1
a447 1
			case (ESCAPE_UNICODE):
d453 1
a453 1
			case (ESCAPE_SPECIAL):
d464 1
a464 1
		case (ESCAPE_UNICODE):
d467 1
a467 1
		case (ESCAPE_NUMBERED):
d472 1
a472 1
		case (ESCAPE_SPECIAL):
d474 1
a474 1
			if (NULL != cp) 
d479 1
a479 1
		case (ESCAPE_FONTBOLD):
d482 1
a482 1
		case (ESCAPE_FONTITALIC):
d485 1
a485 1
		case (ESCAPE_FONTBI):
d488 1
a488 1
		case (ESCAPE_FONT):
d490 1
a490 1
		case (ESCAPE_FONTROMAN):
d493 1
a493 1
		case (ESCAPE_FONTPREV):
d496 1
a496 1
		case (ESCAPE_NOSPACE):
d502 1
a502 1
		case (ESCAPE_SKIPCHAR):
d585 1
a585 1
		if (p->col + sz >= p->maxcols) 
d617 1
a617 1
		case ('+'):
d621 1
a621 1
		case ('-'):
d678 1
a678 1
		case ('\\'):
d686 3
a688 3
				case (ESCAPE_UNICODE):
					c = mchars_num2uc
						(seq + 1, ssz - 1);
d693 3
a695 3
				case (ESCAPE_SPECIAL):
					c = mchars_spec2cp
						(p->symtab, seq, ssz);
d707 1
a707 1
			case (ESCAPE_UNICODE):
d710 1
a710 1
			case (ESCAPE_NUMBERED):
d715 3
a717 3
			case (ESCAPE_SPECIAL):
				rhs = mchars_spec2str
					(p->symtab, seq, ssz, &rsz);
d725 1
a725 1
			case (ESCAPE_SKIPCHAR):
d743 1
a743 1
		case (ASCII_NBRSP):
d747 1
a747 1
		case (ASCII_HYPH):
d751 1
a751 1
		case (ASCII_BREAK):
a760 1
/* ARGSUSED */
d767 1
a767 1
	case (SCALE_CM):
d770 1
a770 1
	case (SCALE_IN):
d773 1
a773 1
	case (SCALE_PC):
d776 1
a776 1
	case (SCALE_PT):
d779 1
a779 1
	case (SCALE_MM):
d782 1
a782 1
	case (SCALE_VS):
d792 1
a792 2
	return(/* LINTED */(size_t)
			r);
d803 1
a803 2
	return((size_t) /* LINTED */
			v);
@


1.81
log
@bugfix: make sure all variables are properly initialized
when rendering .ll (line length) requests.  oops.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.80 2014/03/30 21:27:59 schwarze Exp $ */
d71 4
a74 6
 * Flush a line of text.  A "line" is loosely defined as being something
 * that should be followed by a newline, regardless of whether it's
 * broken apart by newlines getting there.  A line can also be a
 * fragment of a columnar list (`Bl -tag' or `Bl -column'), which does
 * not have a trailing newline.
 *
d77 15
a91 20
 *  - TERMP_NOBREAK: this is the most important and is used when making
 *    columns.  In short: don't print a newline and instead expect the
 *    next call to do the padding up to the start of the next column.
 *    p->trailspace may be set to 0, 1, or 2, depending on how many
 *    space characters are required at the end of the column.
 *
 *  - TERMP_DANGLE: don't newline when TERMP_NOBREAK is specified and
 *    the line is overrun, and don't pad-right if it's underrun.
 *
 *  - TERMP_HANG: like TERMP_DANGLE, but doesn't newline when
 *    overrunning, instead save the position and continue at that point
 *    when the next invocation.
 *
 *  In-line line breaking:
 *
 *  If TERMP_NOBREAK is specified and the line overruns the right
 *  margin, it will break and pad-right to the right margin after
 *  writing.  If maxrmargin is violated, it will break and continue
 *  writing from the right-margin, which will lead to the above scenario
 *  upon exit.  Otherwise, the line will break at the right margin.
d193 1
a193 1
			if (TERMP_NOBREAK & p->flags) {
@


1.80
log
@Support relative arguments to .ll (increase or decrease line length).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.79 2014/03/21 22:17:01 schwarze Exp $ */
d629 2
a641 1
			iop = 0;
d644 3
a646 2
		if ( ! a2roffsu(wstr, &su, SCALE_MAX)) {
			wstr = NULL;
a647 1
		}
a648 1
	width = (NULL != wstr) ? term_hspan(p, &su) : 0;
@


1.79
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.78 2014/03/13 19:23:11 schwarze Exp $ */
d620 30
@


1.78
log
@In -Tutf8 mode, make sure that hyphens get counted against the output line
length even when they are breakable.  Before this, a line containing N
breakable hyphens could get up to N characters wider than the right margin
in -Tutf8 output mode.
Issue reported by tedu@@ on bugs@@.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.77 2014/01/22 20:58:35 schwarze Exp $ */
a21 1
#include <stdint.h>
d27 1
@


1.77
log
@Implement the \: (optional line break) escape sequence,
documented in the Ossanna-Kernighan-Ritter troff manual
and also supported by groff.

Missing feature reported by Steffen Nurpmeso <sdaoden at gmail dot com>.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.76 2013/12/31 18:07:06 schwarze Exp $ */
d182 7
a251 6
			}

			if (ASCII_HYPH == p->buf[i]) {
				(*p->letter)(p, '-');
				p->viscol += (*p->width)(p, '-');
				continue;
@


1.76
log
@remove assignments that will be overwritten right afterwards,
and remove pointless local variables;
found in a clang output from Ulrich Spoerlein <uqs at FreeBSD>
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.75 2013/12/25 00:39:13 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d178 2
a179 1
					ASCII_HYPH == p->buf[j])
d233 2
d646 2
a647 1
	static const char rej[] = { '\\', ASCII_HYPH, ASCII_NBRSP, '\0' };
d735 2
@


1.75
log
@Do not break output lines in .Fn function arguments in SYNOPSIS mode.
Following an idea from Franco Fichtner, but implemented more cleanly.
This reduces groff-mandoc-differences in base by a fantastic 7.5%.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.74 2013/12/24 23:04:29 schwarze Exp $ */
a657 1
		c = 0;
@


1.74
log
@Delete the unused flag TERMP_IGNDELIM
and the empty callback termp_igndelim_pre().
Sort the remaining termp flags.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.73 2013/12/23 02:19:57 schwarze Exp $ */
d406 1
d438 9
a446 1
			ssz = strcspn(word, "\\");
d521 1
@


1.73
log
@Implement a long-standing desideratum,
hanging indentation for .Fn in SYNOPSIS mode,
exploiting the new trailspace feature
by deliberately *NOT* using it.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.72 2013/12/22 23:33:52 schwarze Exp $ */
d428 1
a428 1
	p->flags &= ~(TERMP_SENTENCE | TERMP_IGNDELIM);
@


1.72
log
@Polishing the worms in my favourite can, term_flushln().

The TERMP_TWOSPACE flag i introduced in August 2009 was idiosyncratic
and served only a very narrow purpose.  Replace it by a more intuitive
and more general termp attribute "trailspace", to be used together
with TERMP_NOBREAK, to request a minimum amount of whitespace at
the end of the current column.  Adapt all code to the new interface.

No functional change intended;
code reviews to confirm that are welcome *eg*.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.71 2013/08/21 21:19:47 schwarze Exp $ */
d119 6
a124 1
	 * small set of values. 
d203 5
a207 1
			/* Remove the p->overstep width. */
d283 2
d286 1
a286 1
		if (p->overstep < 0)
@


1.71
log
@Move the last column-counting members of struct termp (col and maxcols)
from int to size_t, to match some existing ones (offset, *rmargin, viscol).
Move some related local variables from int to size_t as well.

Needed as a preparation to make a generalized adjbuf() function available
beyond the file term.c, i.e. in mandoc.c.
Also saves a couple of ugly casts.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.70 2013/08/08 20:07:24 schwarze Exp $ */
d82 2
a83 3
 *
 *  - TERMP_TWOSPACE: make sure there is room for at least two space
 *    characters of padding.  Otherwise, rather break the line.
d267 2
a268 2
		/* We need one blank after the tag. */
		p->overstep = (int)(vis - maxvis + (*p->width)(p, ' '));
d283 1
a283 2
	if (maxvis <= vis +
	    ((TERMP_TWOSPACE & p->flags) ? (*p->width)(p, ' ') : 0)) {
@


1.70
log
@Implement the roff(7) font-escape sequence \f(BI "bold+italic".
This improves the formatting of about 40 base manuals
and reduces groff-mandoc formatting differences in base by about 5%.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.69 2013/08/05 23:35:02 schwarze Exp $ */
d33 1
a33 1
static	void		 adjbuf(struct termp *p, int);
d104 1
a104 1
	int		 i;     /* current input position in p->buf */
d111 2
a112 2
	int		 j;     /* temporary loop index for p->buf */
	int		 jhy;	/* last hyph before overflow w/r/t j */
d215 1
a215 1
				dv = (size_t)(i - j) * (*p->width)(p, ' ');
d506 1
a506 1
adjbuf(struct termp *p, int sz)
d514 1
a514 2
	p->buf = mandoc_realloc
		(p->buf, sizeof(int) * (size_t)p->maxcols);
d564 1
a564 1
	int		  i, len;
a570 3
	/* LINTED */
	len = sz;

d578 3
a580 3
		if (p->col + len >= p->maxcols) 
			adjbuf(p, p->col + len);
		for (i = 0; i < len; i++)
d587 2
a588 2
	if (p->col + 1 + (len * 5) >= p->maxcols)
		adjbuf(p, p->col + 1 + (len * 5));
d590 1
a590 1
	for (i = 0; i < len; i++) {
@


1.69
log
@After a leading blank on an output line, the first word was counted twice
against vend, causing a premature line break.  Fix that bug by reverting
revision 1.10 which Kristaps committed four years ago.  Kristaps patch is no
longer needed because the code below  /* Write out the [remaining] word. */
now handles leading blanks correctly, probably already for a long time.

This avoids premature line breaks in about a dozen base system manuals,
for example as(1) and gdb(1), and alignment issues in another twenty,
for example mount(2), ip6(4), pfctl(8), and crypto(9).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.68 2013/05/29 15:15:49 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d479 3
d543 2
a544 2
	if (p->col + 4 >= p->maxcols)
		adjbuf(p, p->col + 4);
d548 1
a548 4
	if (TERMFONT_NONE == f) {
		p->buf[p->col++] = c;
		return;
	} else if (TERMFONT_UNDER == f) {
d550 9
a558 4
	} else
		p->buf[p->col++] = c;

	p->buf[p->col++] = 8;
a564 1
	enum termfont	  f;
d581 1
a581 1
	if (TERMFONT_NONE == (f = term_fonttop(p))) {
d591 2
a592 2
	if (p->col + 1 + (len * 3) >= p->maxcols)
		adjbuf(p, p->col + 1 + (len * 3));
d595 3
a597 10
		if (ASCII_HYPH != word[i] &&
		    ! isgraph((unsigned char)word[i])) {
			p->buf[p->col++] = word[i];
			continue;
		}

		if (TERMFONT_UNDER == f)
			p->buf[p->col++] = '_';
		else if (ASCII_HYPH == word[i])
			p->buf[p->col++] = '-';
a599 3

		p->buf[p->col++] = 8;
		p->buf[p->col++] = word[i];
@


1.68
log
@In keep mode, if any text is printed (even in NOSPACE mode),
any text that follows must be kept on the same line.

I already found the issue and wrote the patch in April 2011,
but didn't come round to do proper testing and forgot about it.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.67 2012/11/16 17:16:29 schwarze Exp $ */
d161 1
a161 1
			if ((j && ' ' == p->buf[j]) || '\t' == p->buf[j])
@


1.67
log
@Improve formatting of badly nested font blocks.
The basic idea is to already pop the font at the end marker
instead of allowing it to linger until the final end of the block.

This requires a few preliminaries:
* For each block, save a pointer to the previous font
  to be used in case the block breaks another and gets extended.
* That requires making node information writable during rendering.
* Now fonts may get popped in the wrong order; hence, after the stack
  has already been rewound further by some block that began earlier,
  ignore popping a font that was put on the stack later.
* To be able to exploit all this for font blocks, tie processing
  to their body, not their block, which is more logical anyway.

Triggered by florian@@ reporting vaguely similar issues with list blocks.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.66 2012/07/16 21:28:12 schwarze Exp $ */
a404 2
			if (TERMP_PREKEEP & p->flags)
				p->flags |= TERMP_KEEP;
d411 2
@


1.66
log
@Release polishing: finally fix the perl(1) SYNOPSIS.
In flush-left mode of both man(7) and mdoc(7), when an output line is broken
at the position of a literal tab, the tab indents the following line.
Reminded by deraadt@@ in Pest, Ujlipotvaros, Csanady utza.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.65 2012/07/10 15:33:40 schwarze Exp $ */
d375 1
a375 1
	while (p->fonti >= 0 && key != &p->fontq[p->fonti])
@


1.65
log
@Remove a hack that was intended for groff-1.15 bug compatibility:
When the width of a tag in .Bl -hang was exactly one character
shorter than the maximum length that would fit, the following text
would have a negative hang of one character (i.e., hang to the left).
That bug is no longer present in groff-1.21, so relax mandoc, too.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.64 2012/05/28 13:00:51 schwarze Exp $ */
d105 1
d144 1
d149 1
d193 5
@


1.64
log
@Implement the roff \z escape sequence, intended to output the next
character without advancing the cursor position; implement it to
simply skip the next character, as it will usually be overwritten.

With this change, the pod2man(1) preamble user-defined string \*:,
intended to render as a diaeresis or umlaut diacritic above the
preceding character, is rendered in a slightly less ugly way,
though still not correctly.  It was rendered as "z.." and is now
rendered as ".".

Given that the definition of \*: uses elaborate manual \h positioning,
there is little chance for mandoc(1) to ever render it correctly,
but at least we can refrain from printing out a spurious "z", and
we can make the \z do something semi-reasonable for easier cases.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.63 2012/05/27 01:01:24 schwarze Exp $ */
a263 1
		 * Behave exactly the same way as groff:
a266 4
		 * If we landed right at the margin, be happy.
		 * If we are one step before the margin, temporarily
		 * move it one step LEFT and flag the rest of the line
		 * to be longer.
d268 1
a268 1
		if (p->overstep < -1)
@


1.63
log
@Fix the vertical spacing around tbl(7) instances in man(7).

Groff forces the document author to manually request sufficient spacing
after .TE - that is, at least .sp 1v after a table with the "box" option
and at least .sp 2v after a table with the "doublebox" option - or else
it clobbers the box.  I consider that insane, so i'm not imitating groff
in that respect.  Instead, i add at least as much vertical space as groff,
or more where required to avoid clobbering the box.

Consequently, output will be identical for input that looks sane with
groff, and mandoc will make output look better for input that looks bad
with groff.

As a side effect, having identical output for portable input
makes it possible to set up the first regression tests for tbl(7).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.62 2011/09/21 09:57:11 schwarze Exp $ */
d32 1
d419 7
a425 1
		if ((ssz = strcspn(word, "\\")) > 0)
d427 1
a427 3

		word += (int)ssz;
		if ('\\' != *word)
d429 1
d485 3
a487 1
			if ('\0' == *word)
d490 3
d532 5
d560 5
d613 10
d628 1
a628 1
	int		 ssz, c;
d640 1
d644 1
a644 1
			sz += (*p->width)(p, *cp++);
d661 1
a661 1
					sz += (*p->width)(p, c);
d668 1
a668 1
					sz += (*p->width)(p, c);
d678 1
a678 1
				sz += (*p->width)(p, '?');
d683 1
a683 1
					sz += (*p->width)(p, c);
d695 3
d705 5
d714 1
a714 1
			sz += (*p->width)(p, ' ');
d718 1
a718 1
			sz += (*p->width)(p, '-');
@


1.62
log
@As noticed by kristaps@@, when breaking an overflowing line,
forget about pending whitespace (vbl), or the next line would
be misaligned and potentially too long; but i'm fixing this
in a simpler way than he proposed.
Also remove the kludges in .HP that compensated for this bug.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.61 2011/09/19 22:36:11 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011 Ingo Schwarze <schwarze@@openbsd.org>
d315 4
a318 1
	(*p->endline)(p);
@


1.61
log
@Remove the terminal frontend flag TERMP_NOLPAD.

In columnated contexts (.Bl -column, .Bl -tag, .IP, .TP, .HP etc.), do not
pad after writing a column.  Instead, always pad before writing content.

In itself, this change avoids:
 - writing trailing whitespace in some situations
 - with .fi/.nf in .HP, breaking lines that were already padded

It allows several bugfixes included in this patch:
 - Do not count backspace as a character with positive width.
 - Set up proper indentation when encountering .fi/.nf in .HP.
 - Adjust the .HP indentation width to what groff does.
 - Never unlimit the right margin unless in the final column.

This reduces the groff/mandoc-differences in base by nearly 20%,
from 89k to 72k lines of diffs.

ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.60 2011/09/18 20:38:02 schwarze Exp $ */
d183 1
d185 1
a185 2
				p->viscol = p->rmargin;
				(*p->advance)(p, p->rmargin);
d187 1
a187 2
			} else {
				p->viscol = 0;
a188 1
			}
@


1.60
log
@fix a regression introduced in 1.11.7:
even a breakable hyphen may be bold or underlined

With this fix, 1.11.7 reduces the groff/mandoc differences in
base by about 10% (100k -> 90k lines of diffs) with respect to 1.11.5.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.59 2011/05/29 21:22:18 schwarze Exp $ */
a77 4
 *  - TERMP_NOLPAD: when beginning to write the line, don't left-pad the
 *    offset value.  This is useful when doing columnar lists where the
 *    prior column has right-padded.
 *
d79 2
a80 2
 *    columns.  In short: don't print a newline and instead pad to the
 *    right margin.  Used in conjunction with TERMP_NOLPAD.
d82 2
a83 2
 *  - TERMP_TWOSPACE: when padding, make sure there are at least two
 *    space characters of padding.  Otherwise, rather break the line.
d89 1
a89 1
 *    overruning, instead save the position and continue at that point
d129 1
a129 1
	 * Indent the first line of a paragraph.
d131 2
a132 1
	vbl = p->flags & TERMP_NOLPAD ? (size_t)0 : p->offset;
d232 7
a238 2
			} else {
				(*p->letter)(p, p->buf[i]);
a239 1
			}
d248 2
a249 1
	vis -= vbl;
d274 1
a274 4
		if (p->overstep >= -1) {
			assert((int)maxvis + p->overstep >= 0);
			maxvis += (size_t)p->overstep;
		} else
d276 1
d281 2
a282 2
	/* Right-pad. */
	if (maxvis > vis +
a283 4
		p->viscol += maxvis - vis;
		(*p->advance)(p, maxvis - vis);
		vis += (maxvis - vis);
	} else {	/* ...or newline break. */
d285 1
a285 2
		p->viscol = p->rmargin;
		(*p->advance)(p, p->rmargin);
d300 2
a301 6
	if (0 == p->col && 0 == p->viscol) {
		p->flags &= ~TERMP_NOLPAD;
		return;
	}
	term_flushln(p);
	p->flags &= ~TERMP_NOLPAD;
@


1.59
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.58 2011/04/24 16:22:02 schwarze Exp $ */
d575 2
a576 1
		if ( ! isgraph((unsigned char)word[i])) {
d583 2
@


1.58
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.57 2011/04/21 22:59:54 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d32 4
a35 7
static	void		  spec(struct termp *, enum roffdeco,
				const char *, size_t);
static	void		  res(struct termp *, const char *, size_t);
static	void		  bufferc(struct termp *, char);
static	void		  adjbuf(struct termp *p, size_t);
static	void		  encode(struct termp *, const char *, size_t);

d44 1
a44 1
		chars_free(p->symtab);
a68 12

struct termp *
term_alloc(enum termenc enc)
{
	struct termp	*p;

	p = mandoc_calloc(1, sizeof(struct termp));
	p->enc = enc;
	return(p);
}


d140 1
a140 1
	while (i < (int)p->col) {
d145 1
a145 1
		while (i < (int)p->col && '\t' == p->buf[i]) {
d159 1
a159 1
		for (j = i, jhy = 0; j < (int)p->col; j++) {
d202 1
a202 1
		for ( ; i < (int)p->col; i++) {
a328 38

static void
numbered(struct termp *p, const char *word, size_t len)
{
	const char	*rhs;

	rhs = chars_num2char(word, len);
	if (rhs) 
		encode(p, rhs, 1);
}


static void
spec(struct termp *p, enum roffdeco d, const char *word, size_t len)
{
	const char	*rhs;
	size_t		 sz;

	rhs = chars_spec2str(p->symtab, word, len, &sz);
	if (rhs) 
		encode(p, rhs, sz);
	else if (DECO_SSPECIAL == d)
		encode(p, word, len);
}


static void
res(struct termp *p, const char *word, size_t len)
{
	const char	*rhs;
	size_t		 sz;

	rhs = chars_res2str(p->symtab, word, len, &sz);
	if (rhs)
		encode(p, rhs, sz);
}


a392 1

d401 3
a403 1
	const char	*seq;
d405 1
a405 1
	enum roffdeco	 deco;
d425 1
a425 1
	while (*word) {
d433 22
a454 2
		seq = ++word;
		word += a2roffdeco(&deco, &seq, &ssz);
d456 3
a458 3
		switch (deco) {
		case (DECO_NUMBERED):
			numbered(p, seq, ssz);
d460 4
a463 2
		case (DECO_RESERVED):
			res(p, seq, ssz);
d465 6
a470 4
		case (DECO_SPECIAL):
			/* FALLTHROUGH */
		case (DECO_SSPECIAL):
			spec(p, deco, seq, ssz);
d472 1
a472 1
		case (DECO_BOLD):
d475 1
a475 1
		case (DECO_ITALIC):
d478 3
a480 1
		case (DECO_ROMAN):
d483 1
a483 1
		case (DECO_PREVIOUS):
d486 4
a492 3

		if (DECO_NOSPACE == deco && '\0' == *word)
			p->flags |= TERMP_NOSPACE;
a495 1

d497 1
a497 1
adjbuf(struct termp *p, size_t sz)
d505 2
a506 1
	p->buf = mandoc_realloc(p->buf, p->maxcols);
a508 1

d516 1
a516 1
	p->buf[(int)p->col++] = c;
d519 26
d550 4
a553 1
	int		  i;
d562 4
a565 4
		if (p->col + sz >= p->maxcols) 
			adjbuf(p, p->col + sz);
		memcpy(&p->buf[(int)p->col], word, sz);
		p->col += sz;
d571 2
a572 2
	if (p->col + 1 + (sz * 3) >= p->maxcols)
		adjbuf(p, p->col + 1 + (sz * 3));
d574 3
a576 3
	for (i = 0; i < (int)sz; i++) {
		if ( ! isgraph((u_char)word[i])) {
			p->buf[(int)p->col++] = word[i];
d581 1
a581 1
			p->buf[(int)p->col++] = '_';
d583 1
a583 1
			p->buf[(int)p->col++] = word[i];
d585 2
a586 2
		p->buf[(int)p->col++] = 8;
		p->buf[(int)p->col++] = word[i];
a589 1

d601 2
a602 2
	size_t		 sz, ssz, rsz, i;
	enum roffdeco	 d;
d604 44
d649 8
a656 14
	for (sz = 0; '\0' != *cp; )
		/*
		 * Account for escaped sequences within string length
		 * calculations.  This follows the logic in term_word()
		 * as we must calculate the width of produced strings.
		 */
		if ('\\' == *cp) {
			seq = ++cp;
			cp += a2roffdeco(&d, &seq, &ssz);

			switch (d) {
			case (DECO_RESERVED):
				rhs = chars_res2str
					(p->symtab, seq, ssz, &rsz);
d658 2
a659 4
			case (DECO_SPECIAL):
				/* FALLTHROUGH */
			case (DECO_SSPECIAL):
				rhs = chars_spec2str
d662 1
a662 2
				/* Allow for one-char escapes. */
				if (DECO_SSPECIAL != d || rhs)
a668 1
				rhs = NULL;
d672 7
a678 4
			if (rhs)
				for (i = 0; i < rsz; i++)
					sz += (*p->width)(p, *rhs++);
		} else if (ASCII_NBRSP == *cp) {
d681 2
a682 1
		} else if (ASCII_HYPH == *cp) {
d685 5
a689 2
		} else
			sz += (*p->width)(p, *cp++);
a693 1

a728 1

@


1.57
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.56 2011/01/30 16:05:29 schwarze Exp $ */
a27 1
#include "chars.h"
d455 1
a455 1
	const char	*sv, *seq;
a458 6
	sv = word;

	if (DELIM_CLOSE == mandoc_isdelim(word))
		if ( ! (TERMP_IGNDELIM & p->flags))
			p->flags |= TERMP_NOSPACE;

a518 3

	if (DELIM_OPEN == mandoc_isdelim(sv))
		p->flags |= TERMP_NOSPACE;
@


1.56
log
@Implement the \N'number' (numbered character) roff escape sequence.
Don't use it in new manuals, it is inherently non-portable, but we
need it for backward-compatibility with existing manuals, for example
in Xenocara driver pages.
ok kristaps@@ matthieu@@ jmc@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.55 2011/01/04 22:28:17 schwarze Exp $ */
d79 1
a79 6
	p = calloc(1, sizeof(struct termp));
	if (NULL == p) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}

d462 3
a464 23
	if (word[0] && '\0' == word[1])
		switch (word[0]) {
		case('.'):
			/* FALLTHROUGH */
		case(','):
			/* FALLTHROUGH */
		case(';'):
			/* FALLTHROUGH */
		case(':'):
			/* FALLTHROUGH */
		case('?'):
			/* FALLTHROUGH */
		case('!'):
			/* FALLTHROUGH */
		case(')'):
			/* FALLTHROUGH */
		case(']'):
			if ( ! (TERMP_IGNDELIM & p->flags))
				p->flags |= TERMP_NOSPACE;
			break;
		default:
			break;
		}
d488 1
a488 1
		word += ssz;
d527 2
a528 14
	/* 
	 * Note that we don't process the pipe: the parser sees it as
	 * punctuation, but we don't in terms of typography.
	 */
	if (sv[0] && '\0' == sv[1])
		switch (sv[0]) {
		case('('):
			/* FALLTHROUGH */
		case('['):
			p->flags |= TERMP_NOSPACE;
			break;
		default:
			break;
		}
d541 1
a541 5
	p->buf = realloc(p->buf, p->maxcols);
	if (NULL == p->buf) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
@


1.55
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.54 2010/10/27 19:27:30 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d352 11
d521 3
@


1.54
log
@Fix an off-by-one in an assertion, crashing the renderer on ".Os \&".
This bug was a living fossil, introduced on Feb 21, 2009.
Reported by joachimschipper dot nl, thanks.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.53 2010/10/02 15:11:54 schwarze Exp $ */
d676 6
@


1.53
log
@style cleanup, no functional change:
* make the initial maxvis/mmax calculation easier to understand
* where real, non-indexing casts happen, make them explicit
* avoid a few lint warnings that can easily be fixed
* remove one needless LINTED comment
"I like this" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.52 2010/10/01 21:38:26 schwarze Exp $ */
d145 1
a145 1
	assert  (p->rmargin > p->offset);
@


1.52
log
@* need a space before .No even if it starts with a closing delimiter
* slightly simplify .Pf *_IGNDELIM code, and share part of it with .No
* do not let opening delimiters fall out of the front of .Ns (from kristaps@@)
This fixes a few spacing issues in csh(1) and ksh(1).
OK kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.51 2010/09/23 20:22:31 schwarze Exp $ */
d145 5
a149 9

	assert(p->offset < p->rmargin);

	maxvis = (int)(p->rmargin - p->offset) - p->overstep < 0 ?
		/* LINTED */ 
		0 : p->rmargin - p->offset - p->overstep;
	mmax = (int)(p->maxrmargin - p->offset) - p->overstep < 0 ?
		/* LINTED */
		0 : p->maxrmargin - p->offset - p->overstep;
d156 1
a156 1
	vbl = p->flags & TERMP_NOLPAD ? 0 : p->offset;
d158 2
a159 1
	vis = vend = i = 0;
a179 1
		/* LINTED */
d218 1
a218 2
			bp += (int)/* LINTED */
				p->overstep;
d232 1
a232 1
				dv = (i - j) * (*p->width)(p, ' ');
d281 1
a281 2
		p->overstep = /* LINTED */
			vis - maxvis + (*p->width)(p, ' ');
d295 1
a295 2
			/* LINTED */
			maxvis += p->overstep;
d303 2
a304 3
	if (maxvis > vis + /* LINTED */
			((TERMP_TWOSPACE & p->flags) ? 
			 (*p->width)(p, ' ') : 0)) {
@


1.51
log
@Count trailing escaped blanks correctly;
those ruined the alignment of columns.
Tested by jmc@@, and kristaps@@ agrees with the direction.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.49 2010/08/20 23:34:00 schwarze Exp $ */
d504 1
a504 1
	p->flags &= ~TERMP_SENTENCE;
@


1.50
log
@When calculating string lengths, resolve escape sequences and use
their actual lengths.  Will improve vertical alignment in some
uncommon situations, for example when escape sequences occur in
list or column width strings or in .Nm block arguments in the SYNOPSIS.
From kristaps@@.
@
text
@d133 1
d237 3
a239 1
				vbl += (i - j) * (*p->width)(p, ' ');
a265 1
		vend += vbl;
@


1.49
log
@Centralize handling of literal tabs in term_flushln() in one place,
making the code simpler and easier to understand.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.48 2010/08/20 23:22:07 schwarze Exp $ */
d82 1
a82 1
		exit(MANDOCLEVEL_SYSERR);
a456 1
	int		 sz;
d513 1
a513 1
		sz = a2roffdeco(&deco, &seq, &ssz);
a539 1
		word += sz;
d573 1
a573 1
		exit(MANDOCLEVEL_SYSERR);
d642 36
a677 1
	size_t		 sz;
d679 5
a683 2
	for (sz = 0; *cp; cp++)
		sz += (*p->width)(p, *cp);
@


1.48
log
@When a column contains trailing spaces, calculate the padding
to the start of the next column correctly.
Fixing a problem found by jmc@@ in sysctl(3), reminded by kettenis@@.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.47 2010/08/20 00:53:35 schwarze Exp $ */
d168 1
a168 3
		for (j = i; j < (int)p->col; j++) {
			if ('\t' != p->buf[j])
				break;
d172 1
d183 1
a183 1
		for (jhy = 0; j < (int)p->col; j++) {
a224 6

		/*
		 * Skip leading tabs, they were handled above.
		 */
		while (i < (int)p->col && '\t' == p->buf[i])
			i++;
@


1.47
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.46 2010/07/31 21:43:07 schwarze Exp $ */
d273 6
@


1.46
log
@Merge bsd.lv version 1.10.5: last larger batch of bug fixes before release.
NOT including Kristaps' .Bd -literal changes which cause regressions.
Features:
* -Tpdf now fully working
Bugfixes:
* proper handling of quoted strings by .ds in roff(7)
* allow empty .Dd
* make .Sm start no-spacing after the first output word
* underline .Ad
* minor fixes in -Thtml
and some optimisations in terminal output.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.45 2010/07/25 18:05:54 schwarze Exp $ */
d82 1
a82 1
		exit(EXIT_FAILURE);
d576 1
a576 1
		exit(EXIT_FAILURE);
@


1.45
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.44 2010/07/13 01:09:13 schwarze Exp $ */
a35 1
static	void		  buffera(struct termp *, const char *, size_t);
d240 2
a241 2
				while (' ' == p->buf[i]) {
					vbl += (*p->width)(p, p->buf[i]);
d243 1
a243 1
				}
d501 2
a581 12
buffera(struct termp *p, const char *word, size_t sz)
{

	if (p->col + sz >= p->maxcols) 
		adjbuf(p, p->col + sz);

	memcpy(&p->buf[(int)p->col], word, sz);
	p->col += sz;
}


static void
d605 4
a608 1
		buffera(p, word, sz);
d612 5
d619 1
a619 1
			bufferc(p, word[i]);
d624 1
a624 1
			bufferc(p, '_');
d626 1
a626 1
			bufferc(p, word[i]);
d628 2
a629 2
		bufferc(p, 8);
		bufferc(p, word[i]);
@


1.44
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.43 2010/07/03 15:59:05 schwarze Exp $ */
d33 2
a34 1
static	void		  spec(struct termp *, const char *, size_t);
d360 1
a360 1
spec(struct termp *p, const char *word, size_t len)
d365 1
a365 1
	rhs = chars_a2ascii(p->symtab, word, len, &sz);
d368 2
d379 1
a379 1
	rhs = chars_a2res(p->symtab, word, len, &sz);
d505 3
a507 1
	/* FIXME: use strcspn. */
d509 2
a510 4
	while (*word) {
		if ('\\' != *word) {
			encode(p, word, 1);
			word++;
a511 1
		}
d521 3
a523 1
			spec(p, seq, ssz);
d550 1
a550 1
	if (sv[0] && 0 == sv[1])
@


1.43
log
@Rudimentary implementation of user-defined strings;
no time for more refinement right now.
In particular, fixes terminfo(3) and mdoc.samples(7).
ok kristaps@@, who will add the HTML frontend bits
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.42 2010/06/29 14:41:28 schwarze Exp $ */
d3 2
a4 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
a29 1
#include "regs.h"
a376 5
	if (NULL == rhs) {
		rhs = roff_getstrn(word, len);
		if (rhs)
			sz = strlen(rhs);
	}
d653 1
d693 1
a693 28
	double		 r;

	/* XXX: CM, IN, and PT are approximations. */

	switch (su->unit) {
	case (SCALE_CM):
		r = 4 * su->scale;
		break;
	case (SCALE_IN):
		/* XXX: this is an approximation. */
		r = 10 * su->scale;
		break;
	case (SCALE_PC):
		r = (10 * su->scale) / 6;
		break;
	case (SCALE_PT):
		r = (10 * su->scale) / 72;
		break;
	case (SCALE_MM):
		r = su->scale / 1000; /* FIXME: double-check. */
		break;
	case (SCALE_VS):
		r = su->scale * 2 - 1; /* FIXME: double-check. */
		break;
	default:
		r = su->scale;
		break;
	}
d695 5
a699 4
	if (r < 0.0)
		r = 0.0;
	return((size_t)/* LINTED */
			r);
a700 2


@


1.42
log
@framework for glyph width encoding; from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.41 2010/06/27 21:54:42 schwarze Exp $ */
d29 1
d377 5
@


1.41
log
@Full .nr nS support, unbreaking the kernel manuals.

Kristaps coded this from scratch after reading my .nr patch;
it is simpler and more powerful.

Registers live in struct regset in regs.h, struct man and struct mdoc
contain pointers to it.  The nS register is cleared when parsing .Sh.
Frontends respect the MDOC_SYNPRETTY flag set in mdoc node_alloc.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.40 2010/06/27 01:24:02 schwarze Exp $ */
d132 4
a135 3
	int		 j;     /* temporary loop index */
	int		 jhy;	/* last hyphen before line overflow */
	size_t		 maxvis, mmax;
d160 1
a160 4
	/* 
	 * FIXME: if bp is zero, we still output the first word before
	 * breaking the line.
	 */
a161 1
	vis = vend = i = 0;
a162 1

d164 2
a165 1
		 * Handle literal tab characters.
d170 1
a170 1
			vend = (vis/p->tabwidth+1)*p->tabwidth;
d186 15
a200 7
			if (8 != p->buf[j]) {
				if (vend > vis && vend < bp &&
				    ASCII_HYPH == p->buf[j])
					jhy = j;
				vend++;
			} else
				vend--;
d240 1
a240 1
					vbl++;
d246 1
a246 1
				vbl++;
d261 1
a261 1
			if (ASCII_HYPH == p->buf[i])
d263 2
a264 1
			else
d266 2
a267 2

			p->viscol += 1;
d285 1
a285 1
			vis - maxvis + 1;
d309 2
a310 1
			((TERMP_TWOSPACE & p->flags) ? 1 : 0)) {
@


1.40
log
@Basic implementation of .Bk/.Ek.
OK and one stylistic tweak by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.39 2010/06/26 19:08:00 schwarze Exp $ */
a29 2
#include "man.h"
#include "mdoc.h"
@


1.39
log
@As a first step towards variable-width font support,
move all width calculations in term_*.c, *_width().
From kristaps.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.38 2010/06/26 17:56:43 schwarze Exp $ */
d481 3
a483 2
		bufferc(p, ' ');
		if (TERMP_SENTENCE & p->flags)
d485 4
@


1.38
log
@merge release 1.10.2
* bug fixes:
- interaction of ASCII_HYPH with special chars (found by Ulrich Spoerlein)
- handling of roff conditionals (found by Ulrich Spoerlein)
- .Bd -offset will no more default to 6n
* maintenance:
- more caching of .Bd and .Bl arguments for efficiency
- deconstify man(7) validation routines
- add FreeBSD library names (provided by Ulrich Spoerlein)
* start PostScript font-switching
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.37 2010/06/10 22:50:10 schwarze Exp $ */
a85 1
	p->tabwidth = 5;
a86 1
	p->defrmargin = 78;
d623 21
a643 1
term_vspan(const struct roffsu *su)
d679 1
a679 1
term_hspan(const struct roffsu *su)
@


1.37
log
@minimal initial -Tps support, from kristaps@@ GSOC
so far, monospace without font decoration,
but it already has page headers and footers
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.36 2010/06/08 00:11:47 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d602 1
a602 4
	if (TERMTYPE_PS == p->type) {
		buffera(p, word, sz);
		return;
	} else if (TERMFONT_NONE == (f = term_fonttop(p))) {
@


1.36
log
@Merge more bits that will be going into 1.10.1:

Clean up vertical spacing in the SYNOPSIS, making the code much more
systematic; this doesn't solve all SYNOPSIS problems yet, in particular
not those related to keeps, indentation and the low-level .nr roff
instruction, but it's a nice step forward and i couldn't find relevant
regressions.  (from kristaps)

Besides,
* make the output width configurable (default: -Owidth=80) (kristaps)
* use mmap with MAP_SHARED (from Joerg Sonnenberger)
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.35 2010/05/26 02:39:58 schwarze Exp $ */
a24 1
#include <time.h>
a33 2
static	struct termp	 *term_alloc(char *, enum termenc);
static	void		  term_free(struct termp *);
d42 2
a43 2
void *
ascii_alloc(char *outopts)
d46 6
a51 1
	return(term_alloc(outopts, TERMENC_ASCII));
d56 2
a57 1
terminal_free(void *arg)
d60 4
a63 1
	term_free((struct termp *)arg);
d67 2
a68 2
static void
term_free(struct termp *p)
d71 1
a71 6
	if (p->buf)
		free(p->buf);
	if (p->symtab)
		chars_free(p->symtab);

	free(p);
d75 2
a76 2
static struct termp *
term_alloc(char *outopts, enum termenc enc)
a78 6
	const char	*toks[2];
	char		*v;
	size_t		 width;

	toks[0] = "width";
	toks[1] = NULL;
d88 1
a88 15
	width = 80;

	while (outopts && *outopts)
		switch (getsubopt(&outopts, UNCONST(toks), &v)) {
		case (0):
			width = (size_t)atoi(v);
			break;
		default:
			break;
		}

	/* Enforce some lower boundary. */
	if (width < 60)
		width = 60;
	p->defrmargin = width - 2;
d208 1
a208 1
			putchar('\n');
d211 1
a211 2
				for (j = 0; j < (int)p->rmargin; j++)
					putchar(' ');
d255 1
a255 2
				for (j = 0; j < (int)vbl; j++)
					putchar(' ');
d261 1
a261 1
				putchar('-');
d263 1
a263 1
				putchar(p->buf[i]);
d276 1
a276 1
		putchar('\n');
d309 2
a310 2
		for ( ; vis < maxvis; vis++)
			putchar(' ');
d312 1
a312 1
		putchar('\n');
d314 1
a314 2
		for (i = 0; i < (int)p->rmargin; i++)
			putchar(' ');
d350 1
a350 1
	putchar('\n');
d602 4
a605 1
	if (TERMFONT_NONE == (f = term_fonttop(p))) {
@


1.35
log
@When a word does not fully fit onto the output line, but it contains
at least one hyphen, we already had support for breaking the line a the
last fitting hyphen.  This patch improves this functionality by only
breaking at hyphens in free-form text, and by not breaking at hyphens
* at the beginning or end of a word   or
* immediately preceded or followed by another hyphen   or
* escaped by a preceding backslash.

Before this patch, differences in break-at-hyphen support were one
of the major sources of noise in automatic comparisons to mdoc(7)
groff output.  Now, the remaining differences are hard to find among
the noise coming from other sources.

Where there are still differences, what we do seems to be better than
what groff does, see e.g. the chio(1) exchange and position commands
for one of the now rare examples.

idea and coding by kristaps@@

Besides, this was the last substantial code difference left
between bsd.lv and openbsd.org.  We are now in full sync.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.34 2010/05/23 22:45:01 schwarze Exp $ */
d21 1
d35 1
a35 1
static	struct termp	 *term_alloc(enum termenc, size_t);
d46 1
a46 1
ascii_alloc(size_t width)
d49 1
a49 1
	return(term_alloc(TERMENC_ASCII, width));
d75 1
a75 1
term_alloc(enum termenc enc, size_t width)
d77 7
a83 1
	struct termp *p;
d90 1
d93 11
@


1.34
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.33 2010/05/17 02:25:42 schwarze Exp $ */
d193 1
a193 3
			if (8 == p->buf[j])
				vend--;
			else {
d195 1
a195 1
				    '-' == p->buf[j])
d198 2
a199 1
			}
d261 6
a266 1
			putchar(p->buf[i]);
@


1.33
log
@The function term_flushln() had effectively forked wrt to bsd.lv.
This is the OpenBSD part of the main step to bring it back in sync.
At the same time, this prevents trailing whitespace in the output:
We delay writing blanks until we are sure printable characters follow.

This is achieved by
* not using vbl any longer for the control of line breaking
* such that vbl can sum up all kinds of white space
* before writing a word, printing all the blanks collected in vbl
* within the word, adding NBSP chars to vbl, then continuing with the word
* after the word, adding blanks to vbl, then starting the next word
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.32 2010/05/15 21:09:53 schwarze Exp $ */
d26 1
@


1.32
log
@More systematic output width handling by Joerg Sonnenberger:
* save and restore the output width when switching to MANT_LITERAL
* add an argument to ascii_alloc to specify the output width
* set the default output width to 80 minus 2 characters
* OpenBSD local: set the output width to 65 characters for -man
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.31 2010/05/14 19:52:43 schwarze Exp $ */
d133 1
a133 1
	size_t		 vend;  /* end of word visual position on output */
d157 5
d167 1
a167 1
	vis = i = 0;
a170 9
		 * Choose the number of blanks to prepend: no blank at the
		 * beginning of a line, one between words -- but do not
		 * actually write them yet.
		 */
		vbl = (size_t)(0 == vis ? 0 : 1);
		vis += vbl;
		vend = vis;

		/*
d176 1
a176 4
			/* Collapse tab with inter-word spacing. */
			if (vis > 0 && j == i)
				vend = vis - 1;
			vend = (vend/p->tabwidth+1)*p->tabwidth;
d192 1
a192 1
			else if (8 == p->buf[j])
a202 10
		 * Usually, indent the first line of each paragraph.
		 */
		if (0 == i && ! (p->flags & TERMP_NOLPAD)) {
			p->viscol += p->offset;
			/* LINTED */
			for (j = 0; j < (int)p->offset; j++)
				putchar(' ');
		}

		/*
d204 1
a204 2
		 * If so, break to the next line.  (TODO: hyphenate)
		 * Otherwise, write the chosen number of blanks now.
d206 1
a206 1
		if (vend > bp && 0 == jhy && vis > vbl) {
d215 2
a216 3
				p->viscol = p->offset;
				for (j = 0; j < (int)p->offset; j++)
					putchar(' ');
d218 1
d220 1
a223 4
		} else {
			p->viscol += vbl;
			for (j = 0; j < (int)vbl; j++)
				putchar(' ');
d232 1
a232 3
		/*
		 * Finally, write out the word.
		 */
d239 4
a242 1
				i++;
d245 18
a262 4
			if (ASCII_NBRSP == p->buf[i])
				putchar(' ');
			else
				putchar(p->buf[i]);
d264 1
a264 1
		p->viscol += vend - vis;
@


1.31
log
@Integrate kristaps@@' end-of-sentence (EOS) framework
which is simpler and more powerful than mine, and remove mine.

* man(7) now has EOS handling, too
* put EOS detection into its own function in libmandoc
* use node and termp flags to communicate the EOS condition
* no more EOS pseudo-macro
* no more non-printable EOS marker character on the formatter level

This slightly breaks EOS detection after trailing punctuation
in mdoc(7) macros, but that will be restored soon.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.30 2010/04/23 00:23:47 schwarze Exp $ */
d33 1
a33 1
static	struct termp	 *term_alloc(enum termenc);
d44 1
a44 1
ascii_alloc(void)
d47 1
a47 1
	return(term_alloc(TERMENC_ASCII));
d73 1
a73 1
term_alloc(enum termenc enc)
d84 4
@


1.30
log
@Handle literal tab characters both in literal context (.Bd -literal)
and outside.  In literal context, tab stops are at each eigth column;
outside, they are at each fifth column.

Use tabwidth = 5 as the default and temporarily switch to 8 in termp_bd_pre().
This requires to move the term_flushln() of the final line of a display from
termp_bd_post() to termp_bd_pre(); the former still needs term_newln()
to handle the final lines of non-literal displays.

Handling inside term_flushln() is tricky because a tab collapses with
inter-word spacing, but not with another tab.

Missing feature reported independently by jmc@@ and deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.29 2010/04/13 22:41:48 schwarze Exp $ */
d166 1
a166 2
		vbl = (size_t)(ASCII_EOS == p->buf[i] ? 2 :
				(0 == vis ? 0 : 1));
d197 1
a197 1
			else if (ASCII_EOS != p->buf[j]) {
a205 7
		 * Skip empty words.  This happens due to the ASCII_EOS
		 * after the end of the final sentence of a paragraph.
		 */
		if (vend == vis && j == (int)p->col)
			break;

		/*
d263 1
a263 1
			else if (ASCII_EOS != p->buf[i])
d482 1
a482 1
	if ( ! (TERMP_NOSPACE & p->flags))
d484 3
d491 2
d533 4
@


1.29
log
@Fix rendering of multiple successive .It macros without intervening text;
another problem reported by jmc@@.

The physical output line may contain output from more than one buffer.
Thus, to decide whether a line break is needed, it's insufficient to
only look at the number of bytes in the current output buffer.
Keep track of the number of characters already written, too.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.28 2010/04/12 22:52:19 schwarze Exp $ */
d82 1
d158 1
a158 1
	vis = vend = i = 0;
d169 15
d193 2
a194 2
		for (j = i, jhy = 0, vend = vis; j < (int)p->col; j++) {
			if (j && ' ' == p->buf[j]) 
d252 6
d262 2
@


1.28
log
@Partial revert of term.c rev. 1.23
because jmc@@ noticed that it broke blank lines in literal displays.

The original idea was to suppress stray blank lines.
But we don't want to suppress *all* blank lines,
instead just those caused by nested lists.
So do the check whether there was any output on this line,
i.e. whether or not to break the line,
at the right place, which is after processing the .It body.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.27 2010/04/07 23:15:05 schwarze Exp $ */
d200 2
a201 1
		if (0 == i && ! (p->flags & TERMP_NOLPAD))
d205 1
d216 1
d221 1
d230 1
d250 1
d258 1
d290 2
a291 1
			((TERMP_TWOSPACE & p->flags) ? 1 : 0))  
d294 1
a294 1
	else {	/* ...or newline break. */
d296 1
d313 1
a313 1
	if (0 == p->col) {
d333 1
@


1.27
log
@Merge the good parts of 1.9.23,
avoid the bad parts of 1.9.23, and keep local patches.

Input in general:
 * Basic handling of roff-style font escapes \f, \F.
 * Quoted punctuation does not count as punctuation.

mdoc(7) parser:
 * Make .Pf callable; noted by Claus Assmann.
 * Let .Bd and .Bl ignore unknown arguments; noted by deraadt@@.
 * Do not warn when .Er is used outside certain sections.
 * Replace mdoc_node_free[list] by mdoc_node_delete.
 * Replace #define by enum for rew*() return values.

man(7) parser:
 * When .TH is missing, use default section and date.

Output in general:
 * Curly braces do not count as punctuation.
 * No space after .Fl w/o args when a macro follows on the same line.

HTML output:
 * Unify PAIR_*_INIT macros, introduce new PAIR_ID_INIT().
 * Print whitespace after, not before .Vt .Fn .Ft .Fo.

Checked that all manuals in base still build.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.26 2010/03/26 01:22:07 schwarze Exp $ */
a132 1
	static int	 line_started = 0;
a203 1
		line_started = 1;
d252 1
a252 4
		if (line_started) {
			putchar('\n');
			line_started = 0;
		}
@


1.26
log
@merge 1.9.17, keeping local patches

* much improved pod2man support and low-level roff robustness
* have -Tlint imply -Wall and -fstrict
* use fewer macros and more enum in libman
* and various bug fixes
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.25 2010/03/22 23:16:21 schwarze Exp $ */
d91 2
a92 1
 * fragment of a columnar list.
d94 1
a94 4
 * Specifically, a line is whatever's in p->buf of length p->col, which
 * is zeroed after this function returns.
 *
 * The usage of termp:flags is as follows:
a453 2
			/* FALLTHROUGH */
		case('}'):
a511 2
			/* FALLTHROUGH */
		case('{'):
@


1.25
log
@Only try to break the line at an existing hyphen
when there actually IS a hyphen.
Fixing an endless loop that broke the xenocara build.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.24 2010/03/20 20:07:18 schwarze Exp $ */
a81 1
	p->maxrmargin = 78;
a135 1
	static int	 overstep = 0;
d146 1
a146 1
	maxvis = (int)(p->rmargin - p->offset) - overstep < 0 ?
d148 2
a149 2
		0 : p->rmargin - p->offset - overstep;
	mmax = (int)(p->maxrmargin - p->offset) - overstep < 0 ?
d151 1
a151 1
		0 : p->maxrmargin - p->offset - overstep;
d225 1
a225 1
			/* Remove the overstep width. */
d227 2
a228 2
				overstep;
			overstep = 0;
d253 1
a253 1
	overstep = 0;
d265 1
a265 1
		overstep = /* LINTED */
d278 2
a279 2
		if (overstep >= -1) {
			assert((int)maxvis + overstep >= 0);
d281 1
a281 1
			maxvis += overstep;
d283 1
a283 1
			overstep = 0;
@


1.24
log
@When the length of a single words exceeds the maximum acceptable line
length, rather ignore the right margin than entering an endless loop.
Found the hard way in /usr/xenocara/app/fvwm/modules/FvwmM4/FvwmM4.1.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.23 2010/03/06 11:27:55 schwarze Exp $ */
d240 1
a240 1
			if (vend > bp && i > jhy)
@


1.23
log
@When the last field on an output line is empty, break the line
if and only if something was printed on that line.
This avoids double line breaks after nested lists
while still breaking lines after items with empty body.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.22 2010/03/05 20:46:48 schwarze Exp $ */
d216 1
a216 1
		if (vend > bp && 0 == jhy) {
@


1.22
log
@At the end of lines, split words at existing hyphens:
Making pages look better and helping comparisons with groff output.

Note that proper hyphenation is postponed for now because it doesn't
really help the switch.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.21 2010/03/02 00:38:59 schwarze Exp $ */
d136 1
a161 11
	/*
	 * If in the standard case (left-justified), then begin with our
	 * indentation, otherwise (columns, etc.) just start spitting
	 * out text.
	 */

	if ( ! (p->flags & TERMP_NOLPAD))
		/* LINTED */
		for (j = 0; j < (int)p->offset; j++)
			putchar(' ');

d203 9
d258 4
a261 1
		putchar('\n');
@


1.21
log
@Proper inter-sentence spacing for mdoc(7).
When a text line or a non-block macro line in the source code ends
in any of ".!?", consider that an end of sentence (EOS).
This makes Jason's rule "new sentence, new line" even more important.
Let the parser detect the EOS and insert a token into the AST.
Let the -Tascii frontend render the EOS token as a double space before
the next word.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.20 2009/12/24 02:08:14 schwarze Exp $ */
d131 1
a131 1
	size_t		 vsz;   /* visual characters to write to output */
d134 1
a160 2
	vis = 0;

d172 12
a183 1
	for (i = 0; i < (int)p->col; i++) {
d192 1
a192 1
		for (j = i, vsz = 0; j < (int)p->col; j++) {
d196 7
a202 3
				vsz--;
			else if (ASCII_EOS != p->buf[j])
				vsz++;
d209 1
a209 1
		if (vsz == 0 && j == (int)p->col)
a212 8
		 * Choose the number of blanks to prepend: no blank at the
		 * beginning of a line, one between words -- but do not
		 * actually write them yet.
		 */
		vbl = (size_t)(ASCII_EOS == p->buf[i] ? 2 :
				(0 == vis ? 0 : 1));

		/*
d217 2
a218 1
		if (vis && vis + vbl + vsz > bp) {
d223 1
a223 1
				vis = p->rmargin - p->offset;
a226 1
				vis = 0;
a234 1
			vis += vbl;
d241 1
a241 1
			if (' ' == p->buf[i])
d243 4
d252 1
a252 1
		vis += vsz;
@


1.20
log
@sync to 1.9.14: rewrite escape sequence handling:
- new function a2roffdeco
- font modes (\f) only affect the current stack point
- implement scaling (\s)
- implement space suppression (\c)
- implement non-breaking space (\~) in -Tascii
- many manual improvements
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.19 2009/12/22 23:58:00 schwarze Exp $ */
d187 1
a187 1
			else
d192 7
d203 2
a204 1
		vbl = (size_t)(0 == vis ? 0 : 1);
d238 1
a238 3

			/* The unit sep. is a non-breaking space. */
			if (31 == p->buf[i])
d240 1
a240 1
			else
@


1.19
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.18 2009/10/27 21:40:07 schwarze Exp $ */
d17 2
d20 1
a32 3
/* FIXME: accomodate non-breaking, non-collapsing white-space. */
/* FIXME: accomodate non-breaking, collapsing white-space. */

d35 6
a40 8

static	void		  do_escaped(struct termp *, const char **);
static	void		  do_special(struct termp *,
				const char *, size_t);
static	void		  do_reserved(struct termp *,
				const char *, size_t);
static	void		  buffer(struct termp *, char);
static	void		  encode(struct termp *, char);
d230 6
a235 1
			putchar(p->buf[i]);
d321 1
a321 1
do_special(struct termp *p, const char *word, size_t len)
a324 1
	int		 i;
d327 2
a328 12

	if (NULL == rhs) {
#if 0
		fputs("Unknown special character: ", stderr);
		for (i = 0; i < (int)len; i++)
			fputc(word[i], stderr);
		fputc('\n', stderr);
#endif
		return;
	}
	for (i = 0; i < (int)sz; i++) 
		encode(p, rhs[i]);
d333 1
a333 1
do_reserved(struct termp *p, const char *word, size_t len)
a336 1
	int		 i;
d339 9
d349 12
a360 11
	if (NULL == rhs) {
#if 0
		fputs("Unknown reserved word: ", stderr);
		for (i = 0; i < (int)len; i++)
			fputc(word[i], stderr);
		fputc('\n', stderr);
#endif
		return;
	}
	for (i = 0; i < (int)sz; i++) 
		encode(p, rhs[i]);
d364 2
a365 7
/*
 * Handle an escape sequence: determine its length and pass it to the
 * escape-symbol look table.  Note that we assume mdoc(3) has validated
 * the escape sequence (we assert upon badly-formed escape sequences).
 */
static void
do_escaped(struct termp *p, const char **word)
a366 2
	int		 j, type;
	const char	*wp;
d368 4
a371 2
	wp = *word;
	type = 1;
a372 4
	if (0 == *(++wp)) {
		*word = wp;
		return;
	}
d374 3
a376 6
	if ('(' == *wp) {
		wp++;
		if (0 == *wp || 0 == *(wp + 1)) {
			*word = 0 == *wp ? wp : wp + 1;
			return;
		}
d378 2
a379 3
		do_special(p, wp, 2);
		*word = ++wp;
		return;
a380 5
	} else if ('*' == *wp) {
		if (0 == *(++wp)) {
			*word = wp;
			return;
		}
d382 3
a384 7
		switch (*wp) {
		case ('('):
			wp++;
			if (0 == *wp || 0 == *(wp + 1)) {
				*word = 0 == *wp ? wp : wp + 1;
				return;
			}
d386 2
a387 17
			do_reserved(p, wp, 2);
			*word = ++wp;
			return;
		case ('['):
			type = 0;
			break;
		default:
			do_reserved(p, wp, 1);
			*word = wp;
			return;
		}
	
	} else if ('f' == *wp) {
		if (0 == *(++wp)) {
			*word = wp;
			return;
		}
a388 15
		switch (*wp) {
		case ('B'):
			p->bold++;
			break;
		case ('I'):
			p->under++;
			break;
		case ('P'):
			/* FALLTHROUGH */
		case ('R'):
			p->bold = p->under = 0;
			break;
		default:
			break;
		}
d390 3
a392 2
		*word = wp;
		return;
d394 4
a397 5
	} else if ('[' != *wp) {
		do_special(p, wp, 1);
		*word = wp;
		return;
	}
a398 3
	wp++;
	for (j = 0; *wp && ']' != *wp; wp++, j++)
		/* Loop... */ ;
d400 3
a402 4
	if (0 == *wp) {
		*word = wp;
		return;
	}
d404 2
a405 5
	if (type)
		do_special(p, wp - j, (size_t)j);
	else
		do_reserved(p, wp - j, (size_t)j);
	*word = wp;
d417 4
a420 1
	const char	 *sv;
d424 1
a424 1
	if (word[0] && 0 == word[1])
d451 1
a451 1
		buffer(p, ' ');
d456 39
a494 5
	for ( ; *word; word++)
		if ('\\' != *word)
			encode(p, *word);
		else
			do_escaped(p, &word);
a510 5
/*
 * Insert a single character into the line-buffer.  If the buffer's
 * space is exceeded, then allocate more space by doubling the buffer
 * size.
 */
d512 1
a512 1
buffer(struct termp *p, char c)
a513 1
	size_t		 s;
d515 9
a523 10
	if (p->col + 1 >= p->maxcols) {
		if (0 == p->maxcols)
			p->maxcols = 256;
		s = p->maxcols * 2;
		p->buf = realloc(p->buf, s);
		if (NULL == p->buf) {
			perror(NULL);
			exit(EXIT_FAILURE);
		}
		p->maxcols = s;
a524 1
	p->buf[(int)(p->col)++] = c;
d529 24
a552 1
encode(struct termp *p, char c)
d554 18
a571 9
	
	if (' ' != c) {
		if (p->under) {
			buffer(p, '_');
			buffer(p, 8);
		}
		if (p->bold) {
			buffer(p, c);
			buffer(p, 8);
d573 8
a581 1
	buffer(p, c);
@


1.18
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.17 2009/10/24 13:13:20 schwarze Exp $ */
a17 1
#include <err.h>
d21 1
d79 5
a83 3
	if (NULL == (p = malloc(sizeof(struct termp))))
		return(NULL);
	bzero(p, sizeof(struct termp));
d124 2
a125 6
 *  writing from the right-margin, which will lead to the above
 *  scenario upon exit.
 *
 *  Otherwise, the line will break at the right margin.  Extremely long
 *  lines will cause the system to emit a warning (TODO: hyphenate, if
 *  possible).
d130 7
a136 2
	int		 i, j;
	size_t		 vbl, vsz, vis, maxvis, mmax, bp;
d143 1
a143 1
	 * small set of values.
a146 1
	assert((int)(p->rmargin - p->offset) - overstep > 0);
d148 6
a153 4
	maxvis = /* LINTED */
		p->rmargin - p->offset - overstep;
	mmax = /* LINTED */
		p->maxrmargin - p->offset - overstep;
d156 6
d547 4
a550 2
		if (NULL == p->buf)
			err(1, "realloc"); /* FIXME: shouldn't be here! */
@


1.17
log
@simplify overstep handling, removing one local variable;
no functional change;
ok kristaps@@ and merged as rev. 1.110
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.110 2009/10/24 06:19:34 kristaps Exp $ */
d207 2
a208 1
			bp += overstep;
d226 1
d228 1
a234 1
	overstep = 0;
d550 4
a555 4
			buffer(p, 8);
		}
		if (p->under) {
			buffer(p, '_');
@


1.16
log
@sync to 1.9.9, featuring:
 * -Thtml output mode
 * roff scaling units
 * and some minor fixes
for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.15 2009/10/19 09:16:58 schwarze Exp $ */
d133 1
a133 1
	size_t		 vbl, vsz, vis, maxvis, mmax, bp, os;
a145 3
	/* Save the overstep. */
	os = (size_t)overstep;

a152 1
	overstep = 0;
d207 2
a208 2
			bp += os;
			os = 0;
d232 1
@


1.15
log
@sync to 1.9.5: partial rewrite of special character and predefined string
tables and the supporting infrastructure, mostly in preparation for
HTML output support
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.14 2009/10/18 21:03:31 schwarze Exp $ */
d24 1
d28 1
d30 2
a31 4
extern	void		  man_run(struct termp *, 
				const struct man *);
extern	void		  mdoc_run(struct termp *, 
				const struct mdoc *);
a53 26
terminal_man(void *arg, const struct man *man)
{
	struct termp	*p;

	p = (struct termp *)arg;
	if (NULL == p->symtab)
		p->symtab = chars_init(CHARS_ASCII);

	man_run(p, man);
}


void
terminal_mdoc(void *arg, const struct mdoc *mdoc)
{
	struct termp	*p;

	p = (struct termp *)arg;
	if (NULL == p->symtab)
		p->symtab = chars_init(CHARS_ASCII);

	mdoc_run(p, mdoc);
}


void
d133 1
a133 1
	size_t		 vbl, vsz, vis, maxvis, mmax, bp;
d146 3
d210 3
d562 77
@


1.14
log
@sync to 1.9.5: integrate closedelim() and opendelim() into term_word(),
removing unnecessary extra functions
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.13 2009/09/21 20:57:57 schwarze Exp $ */
d23 1
d60 1
a60 1
		p->symtab = term_ascii2htab();
d73 1
a73 1
		p->symtab = term_ascii2htab();
d93 2
a94 2
	if (TERMENC_ASCII == p->enc && p->symtab)
		term_asciifree(p->symtab);
d106 1
a106 1
		err(1, "malloc");
d335 1
a335 1
	rhs = term_a2ascii(p->symtab, word, len, &sz);
d358 1
a358 1
	rhs = term_a2res(p->symtab, word, len, &sz);
d559 1
a559 1
			err(1, "realloc");
@


1.13
log
@sync to 1.9.5: make terminal_*, tree_* and out_* functions return void,
making the code simpler
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.12 2009/09/21 20:28:43 schwarze Exp $ */
a41 2
static	int		  isopendelim(const char *);
static	int		  isclosedelim(const char *);
a112 56
static int
isclosedelim(const char *p)
{

	if ( ! (*p && 0 == *(p + 1)))
		return(0);

	switch (*p) {
	case('.'):
		/* FALLTHROUGH */
	case(','):
		/* FALLTHROUGH */
	case(';'):
		/* FALLTHROUGH */
	case(':'):
		/* FALLTHROUGH */
	case('?'):
		/* FALLTHROUGH */
	case('!'):
		/* FALLTHROUGH */
	case(')'):
		/* FALLTHROUGH */
	case(']'):
		/* FALLTHROUGH */
	case('}'):
		return(1);
	default:
		break;
	}

	return(0);
}


static int
isopendelim(const char *p)
{

	if ( ! (*p && 0 == *(p + 1)))
		return(0);

	switch (*p) {
	case('('):
		/* FALLTHROUGH */
	case('['):
		/* FALLTHROUGH */
	case('{'):
		return(1);
	default:
		break;
	}

	return(0);
}


d487 27
a513 3
	if (isclosedelim(word))
		if ( ! (TERMP_IGNDELIM & p->flags))
			p->flags |= TERMP_NOSPACE;
d521 1
a521 1
	for (sv = word; *word; word++)
d527 12
a538 2
	if (isopendelim(sv))
		p->flags |= TERMP_NOSPACE;
@


1.12
log
@sync to 1.9.5: remove TERMP_STYLE bit field in favour of recursion-friendly
integer flags, simplifying and shortening the code
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.11 2009/08/22 17:04:48 schwarze Exp $ */
d27 1
a27 1
extern	int		  man_run(struct termp *, 
d29 1
a29 1
extern	int		  mdoc_run(struct termp *, 
d54 1
a54 1
int
d63 1
a63 1
	return(man_run(p, man));
d67 1
a67 1
int
d76 1
a76 1
	return(mdoc_run(p, mdoc));
@


1.11
log
@sync to 1.8.5: partial rewrite of the handling of escape sequences:
distinguish special characters and predefined strings,
and add and fix several escape sequences
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.10 2009/08/09 21:28:57 schwarze Exp $ */
d495 1
a495 1
			p->flags |= TERMP_BOLD;
d498 1
a498 1
			p->flags |= TERMP_UNDER;
d503 1
a503 1
			p->flags &= ~TERMP_STYLE;
d593 2
a594 2
	if (' ' != c && TERMP_STYLE & p->flags) {
		if (TERMP_BOLD & p->flags) {
d598 1
a598 1
		if (TERMP_UNDER & p->flags) {
@


1.10
log
@sync to 1.8.4: preserve leading whitespace in literal text
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.9 2009/08/09 18:43:29 schwarze Exp $ */
d34 5
a38 2
static	void		  term_pescape(struct termp *, const char **);
static	void		  term_nescape(struct termp *,
d40 4
a43 4
static	void		  term_chara(struct termp *, char);
static	void		  term_encodea(struct termp *, char);
static	int		  term_isopendelim(const char *);
static	int		  term_isclosedelim(const char *);
d116 1
a116 1
term_isclosedelim(const char *p)
d150 1
a150 1
term_isopendelim(const char *p)
a210 6
 *
 *  FIXME: newline breaks occur (in groff) also occur when a single
 *  space follows a NOBREAK (try `Bl -tag')
 *
 *  FIXME: there's a newline error where a `Bl -diag' will have a
 *  trailing newline if the line is exactly 73 chars long.
a384 5
/*
 * Determine the symbol indicated by an escape sequences, that is, one
 * starting with a backslash.  Once done, we pass this value into the
 * output buffer by way of the symbol table.
 */
d386 1
a386 1
term_nescape(struct termp *p, const char *word, size_t len)
d394 34
a427 3
	if (rhs)
		for (i = 0; i < (int)sz; i++) 
			term_encodea(p, rhs[i]);
d437 1
a437 1
term_pescape(struct termp *p, const char **word)
d439 1
a439 1
	int		 j;
d443 1
d457 1
a457 1
		term_nescape(p, wp, 2);
d475 1
a475 1
			term_nescape(p, wp, 2);
d479 1
d482 1
a482 1
			term_nescape(p, wp, 1);
d513 1
a513 1
		term_nescape(p, wp, 1);
d527 4
a530 1
	term_nescape(p, wp - j, (size_t)j);
d545 1
a545 1
	if (term_isclosedelim(word))
d550 1
a550 1
		term_chara(p, ' ');
a554 5
	/* 
	 * If ANSI (word-length styling), then apply our style now,
	 * before the word.
	 */

d557 1
a557 1
			term_encodea(p, *word);
d559 1
a559 1
			term_pescape(p, &word);
d561 1
a561 1
	if (term_isopendelim(sv))
d572 1
a572 1
term_chara(struct termp *p, char c)
d590 1
a590 1
term_encodea(struct termp *p, char c)
d595 2
a596 2
			term_chara(p, c);
			term_chara(p, 8);
d599 2
a600 2
			term_chara(p, '_');
			term_chara(p, 8);
d603 1
a603 1
	term_chara(p, c);
@


1.9
log
@multiple spacing fixes for .Bl -hang, -tag, -inset and -diag
ok kristaps@@ and included in 1.8.3
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.8 2009/07/26 00:40:28 schwarze Exp $ */
d262 1
a262 1
			if (' ' == p->buf[j]) 
@


1.8
log
@sync to 1.8.1: correct vis count for erroneously-decorated whitespace;
while here, add a new FIXME wrt .Bl -diag
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.7 2009/07/26 00:28:50 schwarze Exp $ */
d187 3
d220 1
a220 1
	static int	 sv = -1;
d230 7
a236 2
	maxvis = p->rmargin - p->offset;
	mmax = p->maxrmargin - p->offset;
d239 1
a239 5

	if (sv >= 0) {
		vis = (size_t)sv;
		sv = -1;
	}
d309 1
d311 2
a312 15
	/*
	 * If we've overstepped our maximum visible no-break space, then
	 * cause a newline and offset at the right margin.
	 */

	if ((TERMP_NOBREAK & p->flags) && vis >= maxvis) {
		if ( ! (TERMP_DANGLE & p->flags) &&
				! (TERMP_HANG & p->flags)) {
			putchar('\n');
			for (i = 0; i < (int)p->rmargin; i++)
				putchar(' ');
		}
		if (TERMP_HANG & p->flags)
			sv = (int)(vis - maxvis);
		p->col = 0;
d316 24
a339 4
	/*
	 * If we're not to right-marginalise it (newline), then instead
	 * pad to the right margin and stay off.
	 */
d341 6
a346 5
	if (p->flags & TERMP_NOBREAK) {
		if ( ! (TERMP_DANGLE & p->flags))
			for ( ; vis < maxvis; vis++)
				putchar(' ');
	} else
d348 3
a350 2

	p->col = 0;
@


1.7
log
@sync to 1.8.1: word splitting now happens in libmdoc,
and remove costly, redundant calculations of string length
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.6 2009/07/18 20:50:38 schwarze Exp $ */
d207 4
a210 1
 *  space follows a NOBREAK!
d258 1
a258 1
			if (' ' == p->buf[j])
d261 1
a261 1
				j += 1;
@


1.6
log
@sync to 1.8.0: support .Bl -hang
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.5 2009/06/23 23:53:43 schwarze Exp $ */
d34 1
a34 3
static	void		  term_pword(struct termp *, const char *, int);
static	void		  term_pescape(struct termp *, 
				const char *, int *, int);
d39 2
a40 2
static	int		  term_isopendelim(const char *, int);
static	int		  term_isclosedelim(const char *, int);
d113 1
a113 1
term_isclosedelim(const char *p, int len)
d116 1
a116 1
	if (1 != len)
d147 1
a147 1
term_isopendelim(const char *p, int len)
d150 1
a150 1
	if (1 != len)
a371 44
 * Break apart a word into "pwords" (partial-words, usually from
 * breaking up a phrase into individual words) and, eventually, put them
 * into the output buffer.  If we're a literal word, then don't break up
 * the word and put it verbatim into the output buffer.
 */
void
term_word(struct termp *p, const char *word)
{
	int 		 i, j, len;

	len = (int)strlen(word);

	if (p->flags & TERMP_LITERAL) {
		term_pword(p, word, len);
		return;
	}

	/* LINTED */
	for (j = i = 0; i < len; i++) {
		if (' ' != word[i]) {
			j++;
			continue;
		} 
		
		/* Escaped spaces don't delimit... */
		if (i && ' ' == word[i] && '\\' == word[i - 1]) {
			j++;
			continue;
		}

		if (0 == j)
			continue;
		assert(i >= j);
		term_pword(p, &word[i - j], j);
		j = 0;
	}
	if (j > 0) {
		assert(i >= j);
		term_pword(p, &word[i - j], j);
	}
}


/*
d384 1
d397 1
a397 1
term_pescape(struct termp *p, const char *word, int *i, int len)
d400 3
d404 2
a405 1
	if (++(*i) >= len)
d407 1
d409 4
a412 3
	if ('(' == word[*i]) {
		(*i)++;
		if (*i + 1 >= len)
d414 1
d416 2
a417 2
		term_nescape(p, &word[*i], 2);
		(*i)++;
d420 3
a422 3
	} else if ('*' == word[*i]) { 
		(*i)++;
		if (*i >= len)
d424 1
d426 1
a426 1
		switch (word[*i]) {
d428 3
a430 2
			(*i)++;
			if (*i + 1 >= len)
d432 1
d434 2
a435 2
			term_nescape(p, &word[*i], 2);
			(*i)++;
d440 2
a441 1
			term_nescape(p, &word[*i], 1);
d445 3
a447 3
	} else if ('f' == word[*i]) {
		(*i)++;
		if (*i >= len)
d449 3
a451 1
		switch (word[*i]) {
d466 2
d470 3
a472 2
	} else if ('[' != word[*i]) {
		term_nescape(p, &word[*i], 1);
d476 2
a477 2
	(*i)++;
	for (j = 0; word[*i] && ']' != word[*i]; (*i)++, j++)
d480 2
a481 1
	if (0 == word[*i])
d483 1
d485 2
a486 1
	term_nescape(p, &word[*i - j], (size_t)j);
d495 2
a496 2
static void
term_pword(struct termp *p, const char *word, int len)
d498 1
a498 1
	int		 i;
d500 1
a500 1
	if (term_isclosedelim(word, len))
d515 3
a517 3
	for (i = 0; i < len; i++) 
		if ('\\' == word[i]) 
			term_pescape(p, word, &i, len);
d519 1
a519 1
			term_encodea(p, word[i]);
d521 1
a521 1
	if (term_isopendelim(word, len))
d552 2
a553 2

	if (TERMP_STYLE & p->flags) {
@


1.5
log
@fix three off-by-one errors in whitespace output
tweaked by and ok kristaps@@  and included in 1.7.20
@
text
@d1 1
a1 1
/*	$Id$ */
d179 1
a179 2
 * The variables TERMP_NOLPAD, TERMP_LITERAL and TERMP_NOBREAK are of
 * critical importance here.  Their behaviour follows:
d189 6
a194 1
 *  - TERMP_NONOBREAK: don't newline when TERMP_NOBREAK is specified.
d216 1
d231 5
d311 2
a312 1
		if ( ! (TERMP_NONOBREAK & p->flags)) {
d317 2
d329 1
a329 1
		if ( ! (TERMP_NONOBREAK & p->flags))
@


1.4
log
@sync to 1.7.19: proper font decorations for special and .It characters
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.3 2009/06/15 00:57:06 schwarze Exp $ */
d203 3
d211 1
a211 1
	size_t		 vsz, vis, maxvis, mmax, bp;
d256 3
a258 5
		 * Do line-breaking.  If we're greater than our
		 * break-point and already in-line, break to the next
		 * line and start writing.  If we're at the line start,
		 * then write out the word (TODO: hyphenate) and break
		 * in a subsequent loop invocation.
d260 1
d262 12
a273 3
		if ( ! (TERMP_NOBREAK & p->flags)) {
			if (vis && vis + vsz > bp) {
				putchar('\n');
d277 3
a279 4
			} 
		} else if (vis && vis + vsz > bp) {
			putchar('\n');
			for (j = 0; j < (int)p->rmargin; j++)
d281 1
a281 1
			vis = p->rmargin - p->offset;
d285 1
a285 2
		 * Prepend a space if we're not already at the beginning
		 * of the line, then the word.
a286 4

		if (0 < vis++)
			putchar(' ');

d300 1
a300 1
	if ((TERMP_NOBREAK & p->flags) && vis > maxvis) {
d317 1
a317 1
			for ( ; vis <= maxvis; vis++)
d416 2
a417 1
	if ((rhs = term_a2ascii(p->symtab, word, len, &sz))) 
@


1.3
log
@sync to 1.7.16: avoid trailing space in output
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.2 2009/06/14 23:00:57 schwarze Exp $ */
d40 1
a40 2
static	void		  term_stringa(struct termp *, 
				const char *, size_t);
d409 1
d411 3
a413 3
	if (NULL == (rhs = term_a2ascii(p->symtab, word, len, &sz))) 
		return;
	term_stringa(p, rhs, sz);
d522 2
a523 2
	for (i = 0; i < len; i++) {
		if ('\\' == word[i]) {
d525 2
a526 16
			continue;
		}

		if (TERMP_STYLE & p->flags) {
			if (TERMP_BOLD & p->flags) {
				term_chara(p, word[i]);
				term_chara(p, 8);
			}
			if (TERMP_UNDER & p->flags) {
				term_chara(p, '_');
				term_chara(p, 8);
			}
		}

		term_chara(p, word[i]);
	}
a533 29
 * Like term_chara() but for arbitrary-length buffers.  Resize the
 * buffer by a factor of two (if the buffer is less than that) or the
 * buffer's size.
 */
static void
term_stringa(struct termp *p, const char *c, size_t sz)
{
	size_t		 s;

	if (0 == sz)
		return;

	assert(c);
	if (p->col + sz >= p->maxcols) {
		if (0 == p->maxcols)
			p->maxcols = 256;
		s = sz > p->maxcols * 2 ? sz : p->maxcols * 2;
		p->buf = realloc(p->buf, s);
		if (NULL == p->buf)
			err(1, "realloc");
		p->maxcols = s;
	}

	(void)memcpy(&p->buf[(int)p->col], c, sz);
	p->col += sz;
}


/*
d555 17
@


1.2
log
@sync to 1.7.16: comments, whitespace and spelling fixes; no functional change
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.78 2009/06/11 10:34:32 kristaps Exp $ */
d275 3
a277 4
		/* 
		 * Write out the word and a trailing space.  Omit the
		 * space if we're the last word in the line or beyond
		 * our breakpoint.
d280 3
a288 4
		if (i < (int)p->col && vis <= bp) {
			putchar(' ');
			vis++;
		}
d296 1
a296 1
	if ((TERMP_NOBREAK & p->flags) && vis >= maxvis) {
d313 1
a313 1
			for ( ; vis < maxvis; vis++)
@


1.1
log
@Initial check-in of mandoc for formatting manuals. ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.73 2009/04/03 12:27:18 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@

