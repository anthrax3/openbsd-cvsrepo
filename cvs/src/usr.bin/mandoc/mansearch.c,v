head	1.60;
access;
symbols
	OPENBSD_6_2_BASE:1.60
	OPENBSD_6_1:1.52.0.4
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.50.0.2
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12;
locks; strict;
comment	@ * @;


1.60
date	2017.08.22.17.50.02;	author schwarze;	state Exp;
branches;
next	1.59;
commitid	BKTkj6kuJTgEVRwG;

1.59
date	2017.08.02.13.28.35;	author schwarze;	state Exp;
branches;
next	1.58;
commitid	0SxjN2fqsFtEMVZI;

1.58
date	2017.07.19.14.05.09;	author schwarze;	state Exp;
branches;
next	1.57;
commitid	xF4WtbyVbnUAeX4B;

1.57
date	2017.07.01.09.47.23;	author schwarze;	state Exp;
branches;
next	1.56;
commitid	bUWzoq61QcedQFz7;

1.56
date	2017.05.17.21.18.41;	author schwarze;	state Exp;
branches;
next	1.55;
commitid	KdD1CnjscREq89Ye;

1.55
date	2017.04.18.15.04.35;	author schwarze;	state Exp;
branches;
next	1.54;
commitid	kOXeYuPWU9xZWNf4;

1.54
date	2017.04.18.13.57.12;	author schwarze;	state Exp;
branches;
next	1.53;
commitid	sbxeKMXH6DmhLvg1;

1.53
date	2017.04.17.20.04.26;	author schwarze;	state Exp;
branches;
next	1.52;
commitid	yCGs8pvcdUj1tz04;

1.52
date	2017.03.03.13.10.55;	author schwarze;	state Exp;
branches;
next	1.51;
commitid	9MnXrcw1FHQkpZQd;

1.51
date	2016.08.01.10.32.39;	author schwarze;	state Exp;
branches;
next	1.50;
commitid	UE9YpFybzQeyHuWW;

1.50
date	2016.07.09.15.23.36;	author schwarze;	state Exp;
branches;
next	1.49;
commitid	5FriDOsLWQ0ekSzQ;

1.49
date	2016.01.08.15.01.58;	author schwarze;	state Exp;
branches;
next	1.48;
commitid	epbZyawFRPP0f3P8;

1.48
date	2015.11.26.07.41.38;	author schwarze;	state Exp;
branches;
next	1.47;
commitid	CbK5e6c1IcXgFqlr;

1.47
date	2015.10.13.15.50.15;	author schwarze;	state Exp;
branches;
next	1.46;
commitid	ZofM5WCqJbf4KjAB;

1.46
date	2015.10.11.21.06.59;	author schwarze;	state Exp;
branches;
next	1.45;
commitid	fBGuLyDivJdmK1wz;

1.45
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.44;
commitid	hxQV8O1pNUaef4ir;

1.44
date	2015.04.01.12.48.00;	author schwarze;	state Exp;
branches;
next	1.43;
commitid	nrllISDokfSY0q7O;

1.43
date	2015.03.27.17.36.56;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	3WUgQM2C53CGXRkK;

1.42
date	2015.03.11.13.10.25;	author schwarze;	state Exp;
branches;
next	1.41;
commitid	eXZEsdjjIuPt9DWy;

1.41
date	2015.02.27.16.00.54;	author schwarze;	state Exp;
branches;
next	1.40;
commitid	a66TRAvkCvQu6JzX;

1.40
date	2015.01.20.18.19.39;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	DWaXNoQAu1BIqPg9;

1.39
date	2014.12.06.01.22.28;	author schwarze;	state Exp;
branches;
next	1.38;
commitid	ZbvLOja4YQq8CUh1;

1.38
date	2014.11.27.01.57.42;	author schwarze;	state Exp;
branches;
next	1.37;
commitid	wP9kqR5Ru9zWkEeC;

1.37
date	2014.11.18.01.14.40;	author schwarze;	state Exp;
branches;
next	1.36;
commitid	IS3m5Tb4YSfoOsL8;

1.36
date	2014.11.11.19.03.10;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	D7uokBruncZXc8f1;

1.35
date	2014.09.03.18.08.26;	author schwarze;	state Exp;
branches;
next	1.34;
commitid	1DUpWacPgRNVWanP;

1.34
date	2014.09.01.22.45.11;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	N1uQZHrcgUZHkfAK;

1.33
date	2014.08.27.00.06.08;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	52PkSro00emV8qcw;

1.32
date	2014.08.21.20.27.03;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	mTaU3tNU6cyrwQEX;

1.31
date	2014.08.09.14.24.49;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	lGqu818Y2EeysuNp;

1.30
date	2014.08.08.17.36.21;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	yq0tYOJQc4lnOhVq;

1.29
date	2014.07.24.20.30.38;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	uytSUPmIkoEPLLy1;

1.28
date	2014.07.12.13.59.54;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	zBSKmDmrkqm51ap6;

1.27
date	2014.05.12.19.11.20;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.23.21.06.33;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.23.16.33.37;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.17.19.19.54;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.16.21.35.48;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.16.00.33.24;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.15.23.47.57;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.11.15.45.39;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.10.02.45.04;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.09.21.49.31;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2014.03.28.19.16.15;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2014.03.21.22.52.21;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2014.03.17.16.29.22;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2014.01.19.23.09.13;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2014.01.19.01.18.30;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2014.01.06.03.52.05;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2014.01.06.03.02.40;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2014.01.05.04.13.46;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2014.01.05.03.25.51;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2014.01.05.03.06.36;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2014.01.05.00.29.49;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2014.01.04.23.42.32;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2013.12.31.03.41.09;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2013.12.31.02.42.20;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2013.12.31.00.40.19;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.60
log
@When finding a bogus database entry,
print a meaningful warning and skip the entry.
Issue reported by espie@@.
@
text
@/*	$OpenBSD: mansearch.c,v 1.59 2017/08/02 13:28:35 schwarze Exp $ */
/*
 * Copyright (c) 2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2013-2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/mman.h>
#include <sys/types.h>

#include <assert.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <glob.h>
#include <limits.h>
#include <regex.h>
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "mandoc.h"
#include "mandoc_aux.h"
#include "mandoc_ohash.h"
#include "manconf.h"
#include "mansearch.h"
#include "dbm.h"

struct	expr {
	/* Used for terms: */
	struct dbm_match match;   /* Match type and expression. */
	uint64_t	 bits;    /* Type mask. */
	/* Used for OR and AND groups: */
	struct expr	*next;    /* Next child in the parent group. */
	struct expr	*child;   /* First child in this group. */
	enum { EXPR_TERM, EXPR_OR, EXPR_AND } type;
};

const char *const mansearch_keynames[KEY_MAX] = {
	"arch",	"sec",	"Xr",	"Ar",	"Fa",	"Fl",	"Dv",	"Fn",
	"Ic",	"Pa",	"Cm",	"Li",	"Em",	"Cd",	"Va",	"Ft",
	"Tn",	"Er",	"Ev",	"Sy",	"Sh",	"In",	"Ss",	"Ox",
	"An",	"Mt",	"St",	"Bx",	"At",	"Nx",	"Fx",	"Lk",
	"Ms",	"Bsx",	"Dx",	"Rs",	"Vt",	"Lb",	"Nm",	"Nd"
};


static	struct ohash	*manmerge(struct expr *, struct ohash *);
static	struct ohash	*manmerge_term(struct expr *, struct ohash *);
static	struct ohash	*manmerge_or(struct expr *, struct ohash *);
static	struct ohash	*manmerge_and(struct expr *, struct ohash *);
static	char		*buildnames(const struct dbm_page *);
static	char		*buildoutput(size_t, struct dbm_page *);
static	size_t		 lstlen(const char *, size_t);
static	void		 lstcat(char *, size_t *, const char *, const char *);
static	int		 lstmatch(const char *, const char *);
static	struct expr	*exprcomp(const struct mansearch *,
				int, char *[], int *);
static	struct expr	*expr_and(const struct mansearch *,
				int, char *[], int *);
static	struct expr	*exprterm(const struct mansearch *,
				int, char *[], int *);
static	void		 exprfree(struct expr *);
static	int		 manpage_compare(const void *, const void *);


int
mansearch(const struct mansearch *search,
		const struct manpaths *paths,
		int argc, char *argv[],
		struct manpage **res, size_t *sz)
{
	char		 buf[PATH_MAX];
	struct dbm_res	*rp;
	struct expr	*e;
	struct dbm_page	*page;
	struct manpage	*mpage;
	struct ohash	*htab;
	size_t		 cur, i, maxres, outkey;
	unsigned int	 slot;
	int		 argi, chdir_status, getcwd_status, im;

	argi = 0;
	if ((e = exprcomp(search, argc, argv, &argi)) == NULL) {
		*sz = 0;
		return 0;
	}

	cur = maxres = 0;
	if (res != NULL)
		*res = NULL;

	outkey = KEY_Nd;
	if (search->outkey != NULL)
		for (im = 0; im < KEY_MAX; im++)
			if (0 == strcasecmp(search->outkey,
			    mansearch_keynames[im])) {
				outkey = im;
				break;
			}

	/*
	 * Remember the original working directory, if possible.
	 * This will be needed if the second or a later directory
	 * is given as a relative path.
	 * Do not error out if the current directory is not
	 * searchable: Maybe it won't be needed after all.
	 */

	if (getcwd(buf, PATH_MAX) == NULL) {
		getcwd_status = 0;
		(void)strlcpy(buf, strerror(errno), sizeof(buf));
	} else
		getcwd_status = 1;

	/*
	 * Loop over the directories (containing databases) for us to
	 * search.
	 * Don't let missing/bad databases/directories phase us.
	 * In each, try to open the resident database and, if it opens,
	 * scan it for our match expression.
	 */

	chdir_status = 0;
	for (i = 0; i < paths->sz; i++) {
		if (chdir_status && paths->paths[i][0] != '/') {
			if ( ! getcwd_status) {
				warnx("%s: getcwd: %s", paths->paths[i], buf);
				continue;
			} else if (chdir(buf) == -1) {
				warn("%s", buf);
				continue;
			}
		}
		if (chdir(paths->paths[i]) == -1) {
			warn("%s", paths->paths[i]);
			continue;
		}
		chdir_status = 1;

		if (dbm_open(MANDOC_DB) == -1) {
			if (errno != ENOENT)
				warn("%s/%s", paths->paths[i], MANDOC_DB);
			continue;
		}

		if ((htab = manmerge(e, NULL)) == NULL) {
			dbm_close();
			continue;
		}

		for (rp = ohash_first(htab, &slot); rp != NULL;
		    rp = ohash_next(htab, &slot)) {
			page = dbm_page_get(rp->page);

			if (lstmatch(search->sec, page->sect) == 0 ||
			    lstmatch(search->arch, page->arch) == 0 ||
			    (search->argmode == ARG_NAME &&
			     rp->bits <= (int32_t)(NAME_SYN & NAME_MASK)))
				continue;

			if (res == NULL) {
				cur = 1;
				break;
			}
			if (cur + 1 > maxres) {
				maxres += 1024;
				*res = mandoc_reallocarray(*res,
				    maxres, sizeof(**res));
			}
			mpage = *res + cur;
			mandoc_asprintf(&mpage->file, "%s/%s",
			    paths->paths[i], page->file + 1);
			if (access(chdir_status ? page->file + 1 :
			    mpage->file, R_OK) == -1) {
				warn("%s", mpage->file);
				warnx("outdated mandoc.db contains "
				    "bogus %s entry, run makewhatis %s", 
				    page->file + 1, paths->paths[i]);
				free(mpage->file);
				free(rp);
				continue;
			}
			mpage->names = buildnames(page);
			mpage->output = buildoutput(outkey, page);
			mpage->ipath = i;
			mpage->bits = rp->bits;
			mpage->sec = *page->sect - '0';
			if (mpage->sec < 0 || mpage->sec > 9)
				mpage->sec = 10;
			mpage->form = *page->file;
			free(rp);
			cur++;
		}
		ohash_delete(htab);
		free(htab);
		dbm_close();

		/*
		 * In man(1) mode, prefer matches in earlier trees
		 * over matches in later trees.
		 */

		if (cur && search->firstmatch)
			break;
	}
	if (res != NULL)
		qsort(*res, cur, sizeof(struct manpage), manpage_compare);
	if (chdir_status && getcwd_status && chdir(buf) == -1)
		warn("%s", buf);
	exprfree(e);
	*sz = cur;
	return res != NULL || cur;
}

/*
 * Merge the results for the expression tree rooted at e
 * into the the result list htab.
 */
static struct ohash *
manmerge(struct expr *e, struct ohash *htab)
{
	switch (e->type) {
	case EXPR_TERM:
		return manmerge_term(e, htab);
	case EXPR_OR:
		return manmerge_or(e->child, htab);
	case EXPR_AND:
		return manmerge_and(e->child, htab);
	default:
		abort();
	}
}

static struct ohash *
manmerge_term(struct expr *e, struct ohash *htab)
{
	struct dbm_res	 res, *rp;
	uint64_t	 ib;
	unsigned int	 slot;
	int		 im;

	if (htab == NULL) {
		htab = mandoc_malloc(sizeof(*htab));
		mandoc_ohash_init(htab, 4, offsetof(struct dbm_res, page));
	}

	for (im = 0, ib = 1; im < KEY_MAX; im++, ib <<= 1) {
		if ((e->bits & ib) == 0)
			continue;

		switch (ib) {
		case TYPE_arch:
			dbm_page_byarch(&e->match);
			break;
		case TYPE_sec:
			dbm_page_bysect(&e->match);
			break;
		case TYPE_Nm:
			dbm_page_byname(&e->match);
			break;
		case TYPE_Nd:
			dbm_page_bydesc(&e->match);
			break;
		default:
			dbm_page_bymacro(im - 2, &e->match);
			break;
		}

		/*
		 * When hashing for deduplication, use the unique
		 * page ID itself instead of a hash function;
		 * that is quite efficient.
		 */

		for (;;) {
			res = dbm_page_next();
			if (res.page == -1)
				break;
			slot = ohash_lookup_memory(htab,
			    (char *)&res, sizeof(res.page), res.page);
			if ((rp = ohash_find(htab, slot)) != NULL) {
				rp->bits |= res.bits;
				continue;
			}
			rp = mandoc_malloc(sizeof(*rp));
			*rp = res;
			ohash_insert(htab, slot, rp);
		}
	}
	return htab;
}

static struct ohash *
manmerge_or(struct expr *e, struct ohash *htab)
{
	while (e != NULL) {
		htab = manmerge(e, htab);
		e = e->next;
	}
	return htab;
}

static struct ohash *
manmerge_and(struct expr *e, struct ohash *htab)
{
	struct ohash	*hand, *h1, *h2;
	struct dbm_res	*res;
	unsigned int	 slot1, slot2;

	/* Evaluate the first term of the AND clause. */

	hand = manmerge(e, NULL);

	while ((e = e->next) != NULL) {

		/* Evaluate the next term and prepare for ANDing. */

		h2 = manmerge(e, NULL);
		if (ohash_entries(h2) < ohash_entries(hand)) {
			h1 = h2;
			h2 = hand;
		} else
			h1 = hand;
		hand = mandoc_malloc(sizeof(*hand));
		mandoc_ohash_init(hand, 4, offsetof(struct dbm_res, page));

		/* Keep all pages that are in both result sets. */

		for (res = ohash_first(h1, &slot1); res != NULL;
		    res = ohash_next(h1, &slot1)) {
			if (ohash_find(h2, ohash_lookup_memory(h2,
			    (char *)res, sizeof(res->page),
			    res->page)) == NULL)
				free(res);
			else
				ohash_insert(hand, ohash_lookup_memory(hand,
				    (char *)res, sizeof(res->page),
				    res->page), res);
		}

		/* Discard the merged results. */

		for (res = ohash_first(h2, &slot2); res != NULL;
		    res = ohash_next(h2, &slot2))
			free(res);
		ohash_delete(h2);
		free(h2);
		ohash_delete(h1);
		free(h1);
	}

	/* Merge the result of the AND into htab. */

	if (htab == NULL)
		return hand;

	for (res = ohash_first(hand, &slot1); res != NULL;
	    res = ohash_next(hand, &slot1)) {
		slot2 = ohash_lookup_memory(htab,
		    (char *)res, sizeof(res->page), res->page);
		if (ohash_find(htab, slot2) == NULL)
			ohash_insert(htab, slot2, res);
		else
			free(res);
	}

	/* Discard the merged result. */

	ohash_delete(hand);
	free(hand);
	return htab;
}

void
mansearch_free(struct manpage *res, size_t sz)
{
	size_t	 i;

	for (i = 0; i < sz; i++) {
		free(res[i].file);
		free(res[i].names);
		free(res[i].output);
	}
	free(res);
}

static int
manpage_compare(const void *vp1, const void *vp2)
{
	const struct manpage	*mp1, *mp2;
	const char		*cp1, *cp2;
	size_t			 sz1, sz2;
	int			 diff;

	mp1 = vp1;
	mp2 = vp2;
	if ((diff = mp2->bits - mp1->bits) ||
	    (diff = mp1->sec - mp2->sec))
		return diff;

	/* Fall back to alphabetic ordering of names. */
	sz1 = strcspn(mp1->names, "(");
	sz2 = strcspn(mp2->names, "(");
	if (sz1 < sz2)
		sz1 = sz2;
	if ((diff = strncasecmp(mp1->names, mp2->names, sz1)))
		return diff;

	/* For identical names and sections, prefer arch-dependent. */
	cp1 = strchr(mp1->names + sz1, '/');
	cp2 = strchr(mp2->names + sz2, '/');
	return cp1 != NULL && cp2 != NULL ? strcasecmp(cp1, cp2) :
	    cp1 != NULL ? -1 : cp2 != NULL ? 1 : 0;
}

static char *
buildnames(const struct dbm_page *page)
{
	char	*buf;
	size_t	 i, sz;

	sz = lstlen(page->name, 2) + 1 + lstlen(page->sect, 2) +
	    (page->arch == NULL ? 0 : 1 + lstlen(page->arch, 2)) + 2;
	buf = mandoc_malloc(sz);
	i = 0;
	lstcat(buf, &i, page->name, ", ");
	buf[i++] = '(';
	lstcat(buf, &i, page->sect, ", ");
	if (page->arch != NULL) {
		buf[i++] = '/';
		lstcat(buf, &i, page->arch, ", ");
	}
	buf[i++] = ')';
	buf[i++] = '\0';
	assert(i == sz);
	return buf;
}

/*
 * Count the buffer space needed to print the NUL-terminated
 * list of NUL-terminated strings, when printing sep separator
 * characters between strings.
 */
static size_t
lstlen(const char *cp, size_t sep)
{
	size_t	 sz;

	for (sz = 0; *cp != '\0'; cp++) {

		/* Skip names appearing only in the SYNOPSIS. */
		if (*cp <= (char)(NAME_SYN & NAME_MASK)) {
			while (*cp != '\0')
				cp++;
			continue;
		}

		/* Skip name class markers. */
		if (*cp < ' ')
			cp++;

		/* Print a separator before each but the first string. */
		if (sz)
			sz += sep;

		/* Copy one string. */
		while (*cp != '\0') {
			sz++;
			cp++;
		}
	}
	return sz;
}

/*
 * Print the NUL-terminated list of NUL-terminated strings
 * into the buffer, seperating strings with sep.
 */
static void
lstcat(char *buf, size_t *i, const char *cp, const char *sep)
{
	const char	*s;
	size_t		 i_start;

	for (i_start = *i; *cp != '\0'; cp++) {

		/* Skip names appearing only in the SYNOPSIS. */
		if (*cp <= (char)(NAME_SYN & NAME_MASK)) {
			while (*cp != '\0')
				cp++;
			continue;
		}

		/* Skip name class markers. */
		if (*cp < ' ')
			cp++;

		/* Print a separator before each but the first string. */
		if (*i > i_start) {
			s = sep;
			while (*s != '\0')
				buf[(*i)++] = *s++;
		}

		/* Copy one string. */
		while (*cp != '\0')
			buf[(*i)++] = *cp++;
	}

}

/*
 * Return 1 if the string *want occurs in any of the strings
 * in the NUL-terminated string list *have, or 0 otherwise.
 * If either argument is NULL or empty, assume no filtering
 * is desired and return 1.
 */
static int
lstmatch(const char *want, const char *have)
{
        if (want == NULL || have == NULL || *have == '\0')
                return 1;
        while (*have != '\0') {
                if (strcasestr(have, want) != NULL)
                        return 1;
                have = strchr(have, '\0') + 1;
        }
        return 0;
}

/*
 * Build a list of values taken by the macro im in the manual page.
 */
static char *
buildoutput(size_t im, struct dbm_page *page)
{
	const char	*oldoutput, *sep, *input;
	char		*output, *newoutput, *value;
	size_t		 sz, i;

	switch (im) {
	case KEY_Nd:
		return mandoc_strdup(page->desc);
	case KEY_Nm:
		input = page->name;
		break;
	case KEY_sec:
		input = page->sect;
		break;
	case KEY_arch:
		input = page->arch;
		if (input == NULL)
			input = "all\0";
		break;
	default:
		input = NULL;
		break;
	}

	if (input != NULL) {
		sz = lstlen(input, 3) + 1;
		output = mandoc_malloc(sz);
		i = 0;
		lstcat(output, &i, input, " # ");
		output[i++] = '\0';
		assert(i == sz);
		return output;
	}

	output = NULL;
	dbm_macro_bypage(im - 2, page->addr);
	while ((value = dbm_macro_next()) != NULL) {
		if (output == NULL) {
			oldoutput = "";
			sep = "";
		} else {
			oldoutput = output;
			sep = " # ";
		}
		mandoc_asprintf(&newoutput, "%s%s%s", oldoutput, sep, value);
		free(output);
		output = newoutput;
	}
	return output;
}

/*
 * Compile a set of string tokens into an expression.
 * Tokens in "argv" are assumed to be individual expression atoms (e.g.,
 * "(", "foo=bar", etc.).
 */
static struct expr *
exprcomp(const struct mansearch *search, int argc, char *argv[], int *argi)
{
	struct expr	*parent, *child;
	int		 needterm, nested;

	if ((nested = *argi) == argc)
		return NULL;
	needterm = 1;
	parent = child = NULL;
	while (*argi < argc) {
		if (strcmp(")", argv[*argi]) == 0) {
			if (needterm)
				warnx("missing term "
				    "before closing parenthesis");
			needterm = 0;
			if (nested)
				break;
			warnx("ignoring unmatched right parenthesis");
			++*argi;
			continue;
		}
		if (strcmp("-o", argv[*argi]) == 0) {
			if (needterm) {
				if (*argi > 0)
					warnx("ignoring -o after %s",
					    argv[*argi - 1]);
				else
					warnx("ignoring initial -o");
			}
			needterm = 1;
			++*argi;
			continue;
		}
		needterm = 0;
		if (child == NULL) {
			child = expr_and(search, argc, argv, argi);
			continue;
		}
		if (parent == NULL) {
			parent = mandoc_calloc(1, sizeof(*parent));
			parent->type = EXPR_OR;
			parent->next = NULL;
			parent->child = child;
		}
		child->next = expr_and(search, argc, argv, argi);
		child = child->next;
	}
	if (needterm && *argi)
		warnx("ignoring trailing %s", argv[*argi - 1]);
	return parent == NULL ? child : parent;
}

static struct expr *
expr_and(const struct mansearch *search, int argc, char *argv[], int *argi)
{
	struct expr	*parent, *child;
	int		 needterm;

	needterm = 1;
	parent = child = NULL;
	while (*argi < argc) {
		if (strcmp(")", argv[*argi]) == 0) {
			if (needterm)
				warnx("missing term "
				    "before closing parenthesis");
			needterm = 0;
			break;
		}
		if (strcmp("-o", argv[*argi]) == 0)
			break;
		if (strcmp("-a", argv[*argi]) == 0) {
			if (needterm) {
				if (*argi > 0)
					warnx("ignoring -a after %s",
					    argv[*argi - 1]);
				else
					warnx("ignoring initial -a");
			}
			needterm = 1;
			++*argi;
			continue;
		}
		if (needterm == 0)
			break;
		if (child == NULL) {
			child = exprterm(search, argc, argv, argi);
			if (child != NULL)
				needterm = 0;
			continue;
		}
		needterm = 0;
		if (parent == NULL) {
			parent = mandoc_calloc(1, sizeof(*parent));
			parent->type = EXPR_AND;
			parent->next = NULL;
			parent->child = child;
		}
		child->next = exprterm(search, argc, argv, argi);
		if (child->next != NULL) {
			child = child->next;
			needterm = 0;
		}
	}
	if (needterm && *argi)
		warnx("ignoring trailing %s", argv[*argi - 1]);
	return parent == NULL ? child : parent;
}

static struct expr *
exprterm(const struct mansearch *search, int argc, char *argv[], int *argi)
{
	char		 errbuf[BUFSIZ];
	struct expr	*e;
	char		*key, *val;
	uint64_t	 iterbit;
	int		 cs, i, irc;

	if (strcmp("(", argv[*argi]) == 0) {
		++*argi;
		e = exprcomp(search, argc, argv, argi);
		if (*argi < argc) {
			assert(strcmp(")", argv[*argi]) == 0);
			++*argi;
		} else
			warnx("unclosed parenthesis");
		return e;
	}

	if (strcmp("-i", argv[*argi]) == 0 && *argi + 1 < argc) {
		cs = 0;
		++*argi;
	} else
		cs = 1;

	e = mandoc_calloc(1, sizeof(*e));
	e->type = EXPR_TERM;
	e->bits = 0;
	e->next = NULL;
	e->child = NULL;

	if (search->argmode == ARG_NAME) {
		e->bits = TYPE_Nm;
		e->match.type = DBM_EXACT;
		e->match.str = argv[(*argi)++];
		return e;
	}

	/*
	 * Separate macro keys from search string.
	 * If needed, request regular expression handling.
	 */

	if (search->argmode == ARG_WORD) {
		e->bits = TYPE_Nm;
		e->match.type = DBM_REGEX;
		mandoc_asprintf(&val, "[[:<:]]%s[[:>:]]", argv[*argi]);
		cs = 0;
	} else if ((val = strpbrk(argv[*argi], "=~")) == NULL) {
		e->bits = TYPE_Nm | TYPE_Nd;
		e->match.type = DBM_SUB;
		e->match.str = argv[*argi];
	} else {
		if (val == argv[*argi])
			e->bits = TYPE_Nm | TYPE_Nd;
		if (*val == '=') {
			e->match.type = DBM_SUB;
			e->match.str = val + 1;
		} else
			e->match.type = DBM_REGEX;
		*val++ = '\0';
		if (strstr(argv[*argi], "arch") != NULL)
			cs = 0;
	}

	/* Compile regular expressions. */

	if (e->match.type == DBM_REGEX) {
		e->match.re = mandoc_malloc(sizeof(*e->match.re));
		irc = regcomp(e->match.re, val,
		    REG_EXTENDED | REG_NOSUB | (cs ? 0 : REG_ICASE));
		if (irc) {
			regerror(irc, e->match.re, errbuf, sizeof(errbuf));
			warnx("regcomp /%s/: %s", val, errbuf);
		}
		if (search->argmode == ARG_WORD)
			free(val);
		if (irc) {
			free(e->match.re);
			free(e);
			++*argi;
			return NULL;
		}
	}

	if (e->bits) {
		++*argi;
		return e;
	}

	/*
	 * Parse out all possible fields.
	 * If the field doesn't resolve, bail.
	 */

	while (NULL != (key = strsep(&argv[*argi], ","))) {
		if ('\0' == *key)
			continue;
		for (i = 0, iterbit = 1; i < KEY_MAX; i++, iterbit <<= 1) {
			if (0 == strcasecmp(key, mansearch_keynames[i])) {
				e->bits |= iterbit;
				break;
			}
		}
		if (i == KEY_MAX) {
			if (strcasecmp(key, "any"))
				warnx("treating unknown key "
				    "\"%s\" as \"any\"", key);
			e->bits |= ~0ULL;
		}
	}

	++*argi;
	return e;
}

static void
exprfree(struct expr *e)
{
	if (e->next != NULL)
		exprfree(e->next);
	if (e->child != NULL)
		exprfree(e->child);
	free(e);
}
@


1.59
log
@No longer use names that only occur in the SYNOPSIS section as names
for man(1) lookup.  For OpenBSD base and Xenocara, that functionality
was never intended to be required, and i just fixed the last handful
of offenders using it - not counting the horribly ill-designed
interfaces engine(3) and lh_new(3) which are impossible to properly
document in the first place.

Of course, apropos(1) and whatis(1) continue to use SYNOPSIS .Nm,
.Fn, and .Fo macros, so "man -k ENGINE_get_load_privkey_function"
still works.

This change also gets rid of a few bogus warnings "cross reference
to self" which actually are *not* to self, like in yp(8).

This former functionality was intended to help third-party software
in the ports tree and on non-OpenBSD systems containing manual pages
with incomplete or corrupt NAME sections.  But it turned out it did
more harm than good, and caused more confusion than relief,
specifically for third party manuals and for maintainers of
mandoc-portable on other operating systems.  So kill it.
Problems reported, among others, by Yuri Pankov (illumos).

OK jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.58 2017/07/19 14:05:09 schwarze Exp $ */
d188 10
@


1.58
log
@Prefer arch-dependent over arch-independent pages if the name priority,
the section number, and all names match.  Changes little on installed
systems except the ordering of apropos(1) results, because we install
base and Xenocara manuals in different trees, but fixes lookup of pages
like apm(4) vs. apm(4/amd64) in man.cgi(8).
Issue discovered by martian67 on freenode and reported via tj@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.57 2017/07/01 09:47:23 schwarze Exp $ */
d171 3
a173 1
			    lstmatch(search->arch, page->arch) == 0)
d454 22
a475 8
	for (sz = 0;; sz++) {
		if (cp[0] == '\0') {
			if (cp[1] == '\0')
				break;
			sz += sep - 1;
		} else if (cp[0] < ' ')
			sz--;
		cp++;
d487 2
a488 1
	const char *s;
d490 15
a504 4
	for (;;) {
		if (cp[0] == '\0') {
			if (cp[1] == '\0')
				break;
d508 5
a512 3
		} else if (cp[0] >= ' ')
			buf[(*i)++] = cp[0];
		cp++;
d514 1
@


1.57
log
@Basic reporting of .Xrs to manual pages that don't exist
in the base system, inspired by mdoclint(1).

We are able to do this because (1) the -mdoc parser, the -Tlint validator,
and the man(1) manual page lookup code are all in the same program
and (2) the mandoc.db(5) database format allows fast lookup.

Feedback from, previous versions tested by, and OK jmc@@.

A few features will be added to this in the tree, step by step.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.56 2017/05/17 21:18:41 schwarze Exp $ */
d394 2
d400 17
a416 3
	return (diff = mp2->bits - mp1->bits) ? diff :
	    (diff = mp1->sec - mp2->sec) ? diff :
	    strcasecmp(mp1->names, mp2->names);
@


1.56
log
@Do not warn if a database file does not exist
because that is simply equivalent to an empty database.
Suggested by ajacoutot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.55 2017/04/18 15:04:35 schwarze Exp $ */
d104 2
a105 1
	*res = NULL;
d174 4
d209 2
a210 1
	qsort(*res, cur, sizeof(struct manpage), manpage_compare);
d215 1
a215 1
	return 1;
@


1.55
log
@The apropos(1) manual still documents the unary -i operator for
regular expression search terms, but it appears that somewhere
along the way, the implementation got lost, so restore it.
Bug found while investigating other reports from Gonzalo Tornaria.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.54 2017/04/18 13:57:12 schwarze Exp $ */
d155 2
a156 1
			warn("%s/%s", paths->paths[i], MANDOC_DB);
@


1.54
log
@Fix previous: i forgot explicit NUL termination;
noticed by Gonzalo <Tornaria at cmat dot edu dot uy>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.53 2017/04/17 20:04:26 schwarze Exp $ */
d672 6
a695 1
	cs = 1;
@


1.53
log
@Restore -kO Nd, -kO Nm, -kO sec, and -kO arch to working order.
They got broken in the SQLite removal.
As opposed to the rest of -kO, they are no longer very useful,
but they are certainly not supposed to fail assertions.
Issue reported by Gonzalo Tornaria <tornaria at cmat dot edu dot uy>.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.52 2017/03/03 13:10:55 schwarze Exp $ */
d516 2
@


1.52
log
@A missing initialization could randomly cause regular expression
searches to be case-insensitive that ought to be case sensitive.
Found by jsg@@ with scan-build.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.51 2016/08/01 10:32:39 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013, 2014, 2015, 2016 Ingo Schwarze <schwarze@@openbsd.org>
d67 3
a69 3
static	char		*buildoutput(size_t, int32_t);
static	size_t		 lstlen(const char *);
static	void		 lstcat(char *, size_t *, const char *);
d181 1
a181 3
			mpage->output = (int)outkey == KEY_Nd ?
			    mandoc_strdup(page->desc) :
			    buildoutput(outkey, page->addr);
d402 2
a403 2
	sz = lstlen(page->name) + 1 + lstlen(page->sect) +
	    (page->arch == NULL ? 0 : 1 + lstlen(page->arch)) + 2;
d406 1
a406 1
	lstcat(buf, &i, page->name);
d408 1
a408 1
	lstcat(buf, &i, page->sect);
d411 1
a411 1
		lstcat(buf, &i, page->arch);
d421 1
a421 1
 * list of NUL-terminated strings, when printing two separator
d425 1
a425 1
lstlen(const char *cp)
d433 1
a433 1
			sz++;
d443 1
a443 1
 * into the buffer, seperating strings with a comma and a blank.
d446 1
a446 1
lstcat(char *buf, size_t *i, const char *cp)
d448 2
d454 3
a456 2
			buf[(*i)++] = ',';
			buf[(*i)++] = ' ';
d483 1
a483 2
 * Build a list of values taken by the macro im
 * in the manual page with big-endian address addr.
d486 1
a486 1
buildoutput(size_t im, int32_t addr)
d488 1
a488 1
	const char	*oldoutput, *sep;
d490 28
d520 1
a520 1
	dbm_macro_bypage(im - 2, addr);
@


1.51
log
@Remove the dependency on SQLite without loss of functionality.
Drop the obsolete names_check() now that we deleted MLINKS.
Run "doas makewhatis" after compiling and installing this.

Earlier version tested by jmc@@ and jturner@@;
"commit it all" deraadt@@   "commit and dodge" krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.50 2016/07/09 15:23:36 schwarze Exp $ */
d660 1
@


1.50
log
@getopt(3) is declared in <unistd.h>, and <getopt.h> is not needed;
from Joerg Sonnenberger via Thomas Klausner, NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.49 2016/01/08 15:01:58 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
a35 2
#include <sqlite3.h>

d41 1
a41 19

extern int mansearch_keymax;
extern const char *const mansearch_keynames[];

#define	SQL_BIND_TEXT(_db, _s, _i, _v) \
	do { if (SQLITE_OK != sqlite3_bind_text \
		((_s), (_i)++, (_v), -1, SQLITE_STATIC)) \
		errx((int)MANDOCLEVEL_SYSERR, "%s", sqlite3_errmsg((_db))); \
	} while (0)
#define	SQL_BIND_INT64(_db, _s, _i, _v) \
	do { if (SQLITE_OK != sqlite3_bind_int64 \
		((_s), (_i)++, (_v))) \
		errx((int)MANDOCLEVEL_SYSERR, "%s", sqlite3_errmsg((_db))); \
	} while (0)
#define	SQL_BIND_BLOB(_db, _s, _i, _v) \
	do { if (SQLITE_OK != sqlite3_bind_blob \
		((_s), (_i)++, (&_v), sizeof(_v), SQLITE_STATIC)) \
		errx((int)MANDOCLEVEL_SYSERR, "%s", sqlite3_errmsg((_db))); \
	} while (0)
d44 7
a50 8
	regex_t		 regexp;  /* compiled regexp, if applicable */
	const char	*substr;  /* to search for, if applicable */
	struct expr	*next;    /* next in sequence */
	uint64_t	 bits;    /* type-mask */
	int		 equal;   /* equality, not subsring match */
	int		 open;    /* opening parentheses before */
	int		 and;	  /* logical AND before */
	int		 close;   /* closing parentheses after */
d53 6
a58 5
struct	match {
	uint64_t	 pageid; /* identifier in database */
	uint64_t	 bits; /* name type mask */
	char		*desc; /* manual page description */
	int		 form; /* bit field: formatted, zipped? */
d61 10
a70 6
static	void		 buildnames(const struct mansearch *,
				struct manpage *, sqlite3 *,
				sqlite3_stmt *, uint64_t,
				const char *, int form);
static	char		*buildoutput(sqlite3 *, sqlite3_stmt *,
				 uint64_t, uint64_t);
d72 5
a76 1
				int, char *[]);
a77 1
static	struct expr	*exprterm(const struct mansearch *, char *, int);
a78 7
static	void		 sql_append(char **sql, size_t *sz,
				const char *newstr, int count);
static	void		 sql_match(sqlite3_context *context,
				int argc, sqlite3_value **argv);
static	void		 sql_regexp(sqlite3_context *context,
				int argc, sqlite3_value **argv);
static	char		*sql_statement(const struct expr *);
a81 48
mansearch_setup(int start)
{
	static void	*pagecache;
	int		 c;

#define	PC_PAGESIZE	1280
#define	PC_NUMPAGES	256

	if (start) {
		if (NULL != pagecache) {
			warnx("pagecache already enabled");
			return (int)MANDOCLEVEL_BADARG;
		}

		pagecache = mmap(NULL, PC_PAGESIZE * PC_NUMPAGES,
		    PROT_READ | PROT_WRITE,
		    MAP_SHARED | MAP_ANON, -1, 0);

		if (MAP_FAILED == pagecache) {
			warn("mmap");
			pagecache = NULL;
			return (int)MANDOCLEVEL_SYSERR;
		}

		c = sqlite3_config(SQLITE_CONFIG_PAGECACHE,
		    pagecache, PC_PAGESIZE, PC_NUMPAGES);

		if (SQLITE_OK == c)
			return (int)MANDOCLEVEL_OK;

		warnx("pagecache: %s", sqlite3_errstr(c));

	} else if (NULL == pagecache) {
		warnx("pagecache missing");
		return (int)MANDOCLEVEL_BADARG;
	}

	if (-1 == munmap(pagecache, PC_PAGESIZE * PC_NUMPAGES)) {
		warn("munmap");
		pagecache = NULL;
		return (int)MANDOCLEVEL_SYSERR;
	}

	pagecache = NULL;
	return (int)MANDOCLEVEL_OK;
}

int
a86 2
	int64_t		 pageid;
	uint64_t	 outbit, iterbit;
d88 3
a90 1
	char		*sql;
d92 4
a95 8
	struct expr	*e, *ep;
	sqlite3		*db;
	sqlite3_stmt	*s, *s2;
	struct match	*mp;
	struct ohash	 htab;
	unsigned int	 idx;
	size_t		 i, j, cur, maxres;
	int		 c, chdir_status, getcwd_status, indexbit;
d97 2
a98 1
	if (argc == 0 || (e = exprcomp(search, argc, argv)) == NULL) {
d106 3
a108 5
	if (NULL != search->outkey) {
		outbit = TYPE_Nd;
		for (indexbit = 0, iterbit = 1;
		     indexbit < mansearch_keymax;
		     indexbit++, iterbit <<= 1) {
d110 2
a111 2
			    mansearch_keynames[indexbit])) {
				outbit = iterbit;
a113 3
		}
	} else
		outbit = 0;
a128 2
	sql = sql_statement(e);

d154 1
a154 4
		c = sqlite3_open_v2(MANDOC_DB, &db,
		    SQLITE_OPEN_READONLY, NULL);

		if (SQLITE_OK != c) {
a155 1
			sqlite3_close(db);
d159 3
a161 27
		/*
		 * Define the SQL functions for substring
		 * and regular expression matching.
		 */

		c = sqlite3_create_function(db, "match", 2,
		    SQLITE_UTF8 | SQLITE_DETERMINISTIC,
		    NULL, sql_match, NULL, NULL);
		assert(SQLITE_OK == c);
		c = sqlite3_create_function(db, "regexp", 2,
		    SQLITE_UTF8 | SQLITE_DETERMINISTIC,
		    NULL, sql_regexp, NULL, NULL);
		assert(SQLITE_OK == c);

		j = 1;
		c = sqlite3_prepare_v2(db, sql, -1, &s, NULL);
		if (SQLITE_OK != c)
			errx((int)MANDOCLEVEL_SYSERR,
			    "%s", sqlite3_errmsg(db));

		for (ep = e; NULL != ep; ep = ep->next) {
			if (NULL == ep->substr) {
				SQL_BIND_BLOB(db, s, j, ep->regexp);
			} else
				SQL_BIND_TEXT(db, s, j, ep->substr);
			if (0 == ((TYPE_Nd | TYPE_Nm) & ep->bits))
				SQL_BIND_INT64(db, s, j, ep->bits);
d164 3
a166 15
		mandoc_ohash_init(&htab, 4, offsetof(struct match, pageid));

		/*
		 * Hash each entry on its [unique] document identifier.
		 * This is a uint64_t.
		 * Instead of using a hash function, simply convert the
		 * uint64_t to a uint32_t, the hash value's type.
		 * This gives good performance and preserves the
		 * distribution of buckets in the table.
		 */
		while (SQLITE_ROW == (c = sqlite3_step(s))) {
			pageid = sqlite3_column_int64(s, 2);
			idx = ohash_lookup_memory(&htab,
			    (char *)&pageid, sizeof(uint64_t),
			    (uint32_t)pageid);
d168 2
a169 1
			if (NULL != ohash_find(&htab, idx))
a171 34
			mp = mandoc_calloc(1, sizeof(struct match));
			mp->pageid = pageid;
			mp->form = sqlite3_column_int(s, 1);
			mp->bits = sqlite3_column_int64(s, 3);
			if (TYPE_Nd == outbit)
				mp->desc = mandoc_strdup((const char *)
				    sqlite3_column_text(s, 0));
			ohash_insert(&htab, idx, mp);
		}

		if (SQLITE_DONE != c)
			warnx("%s", sqlite3_errmsg(db));

		sqlite3_finalize(s);

		c = sqlite3_prepare_v2(db,
		    "SELECT sec, arch, name, pageid FROM mlinks "
		    "WHERE pageid=? ORDER BY sec, arch, name",
		    -1, &s, NULL);
		if (SQLITE_OK != c)
			errx((int)MANDOCLEVEL_SYSERR,
			    "%s", sqlite3_errmsg(db));

		c = sqlite3_prepare_v2(db,
		    "SELECT bits, key, pageid FROM keys "
		    "WHERE pageid=? AND bits & ?",
		    -1, &s2, NULL);
		if (SQLITE_OK != c)
			errx((int)MANDOCLEVEL_SYSERR,
			    "%s", sqlite3_errmsg(db));

		for (mp = ohash_first(&htab, &idx);
				NULL != mp;
				mp = ohash_next(&htab, &idx)) {
d175 1
a175 1
				    maxres, sizeof(struct manpage));
d178 6
d185 11
a195 19
			mpage->bits = mp->bits;
			mpage->sec = 10;
			mpage->form = mp->form;
			buildnames(search, mpage, db, s, mp->pageid,
			    paths->paths[i], mp->form);
			if (mpage->names != NULL) {
				mpage->output = TYPE_Nd & outbit ?
				    mp->desc : outbit ?
				    buildoutput(db, s2, mp->pageid, outbit) :
				    NULL;
				cur++;
			}
			free(mp);
		}

		sqlite3_finalize(s);
		sqlite3_finalize(s2);
		sqlite3_close(db);
		ohash_delete(&htab);
a208 1
	free(sql);
d213 6
a218 2
void
mansearch_free(struct manpage *res, size_t sz)
d220 9
a228 6
	size_t	 i;

	for (i = 0; i < sz; i++) {
		free(res[i].file);
		free(res[i].names);
		free(res[i].output);
a229 1
	free(res);
d232 2
a233 2
static int
manpage_compare(const void *vp1, const void *vp2)
d235 37
a271 2
	const struct manpage	*mp1, *mp2;
	int			 diff;
d273 16
a288 5
	mp1 = vp1;
	mp2 = vp2;
	return (diff = mp2->bits - mp1->bits) ? diff :
	    (diff = mp1->sec - mp2->sec) ? diff :
	    strcasecmp(mp1->names, mp2->names);
d291 9
a299 27
static void
buildnames(const struct mansearch *search, struct manpage *mpage,
		sqlite3 *db, sqlite3_stmt *s,
		uint64_t pageid, const char *path, int form)
{
	glob_t		 globinfo;
	char		*firstname, *newnames, *prevsec, *prevarch;
	const char	*oldnames, *sep1, *name, *sec, *sep2, *arch, *fsec;
	size_t		 i;
	int		 c, globres;

	mpage->file = NULL;
	mpage->names = NULL;
	firstname = prevsec = prevarch = NULL;
	i = 1;
	SQL_BIND_INT64(db, s, i, pageid);
	while (SQLITE_ROW == (c = sqlite3_step(s))) {

		/* Decide whether we already have some names. */

		if (NULL == mpage->names) {
			oldnames = "";
			sep1 = "";
		} else {
			oldnames = mpage->names;
			sep1 = ", ";
		}
d301 6
a306 1
		/* Fetch the next name, rejecting sec/arch mismatches. */
d308 1
a308 8
		sec = (const char *)sqlite3_column_text(s, 0);
		if (search->sec != NULL && strcasecmp(sec, search->sec))
			continue;
		arch = (const char *)sqlite3_column_text(s, 1);
		if (search->arch != NULL && *arch != '\0' &&
		    strcasecmp(arch, search->arch))
			continue;
		name = (const char *)sqlite3_column_text(s, 2);
d310 1
a310 1
		/* Remember the first section found. */
d312 1
a312 2
		if (9 < mpage->sec && '1' <= *sec && '9' >= *sec)
			mpage->sec = (*sec - '1') + 1;
d314 1
a314 1
		/* If the section changed, append the old one. */
d316 8
a323 12
		if (NULL != prevsec &&
		    (strcmp(sec, prevsec) ||
		     strcmp(arch, prevarch))) {
			sep2 = '\0' == *prevarch ? "" : "/";
			mandoc_asprintf(&newnames, "%s(%s%s%s)",
			    oldnames, prevsec, sep2, prevarch);
			free(mpage->names);
			oldnames = mpage->names = newnames;
			free(prevsec);
			free(prevarch);
			prevsec = prevarch = NULL;
		}
d325 1
a325 1
		/* Save the new section, to append it later. */
d327 10
a336 3
		if (NULL == prevsec) {
			prevsec = mandoc_strdup(sec);
			prevarch = mandoc_strdup(arch);
d339 10
a348 1
		/* Append the new name. */
d350 1
a350 4
		mandoc_asprintf(&newnames, "%s%s%s",
		    oldnames, sep1, name);
		free(mpage->names);
		mpage->names = newnames;
d352 2
a353 1
		/* Also save the first file name encountered. */
d355 11
a365 2
		if (mpage->file != NULL)
			continue;
d367 4
a370 12
		if (form & FORM_SRC) {
			sep1 = "man";
			fsec = sec;
		} else {
			sep1 = "cat";
			fsec = "0";
		}
		sep2 = *arch == '\0' ? "" : "/";
		mandoc_asprintf(&mpage->file, "%s/%s%s%s%s/%s.%s",
		    path, sep1, sec, sep2, arch, name, fsec);
		if (access(mpage->file, R_OK) != -1)
			continue;
d372 4
a375 1
		/* Handle unusual file name extensions. */
d377 4
a380 33
		if (firstname == NULL)
			firstname = mpage->file;
		else
			free(mpage->file);
		mandoc_asprintf(&mpage->file, "%s/%s%s%s%s/%s.*",
		    path, sep1, sec, sep2, arch, name);
		globres = glob(mpage->file, 0, NULL, &globinfo);
		free(mpage->file);
		mpage->file = globres ? NULL :
		    mandoc_strdup(*globinfo.gl_pathv);
		globfree(&globinfo);
	}
	if (c != SQLITE_DONE)
		warnx("%s", sqlite3_errmsg(db));
	sqlite3_reset(s);

	/* If none of the files is usable, use the first name. */

	if (mpage->file == NULL)
		mpage->file = firstname;
	else if (mpage->file != firstname)
		free(firstname);

	/* Append one final section to the names. */

	if (prevsec != NULL) {
		sep2 = *prevarch == '\0' ? "" : "/";
		mandoc_asprintf(&newnames, "%s(%s%s%s)",
		    mpage->names, prevsec, sep2, prevarch);
		free(mpage->names);
		mpage->names = newnames;
		free(prevsec);
		free(prevarch);
d382 14
d399 1
a399 1
buildoutput(sqlite3 *db, sqlite3_stmt *s, uint64_t pageid, uint64_t outbit)
d401 2
a402 4
	char		*output, *newoutput;
	const char	*oldoutput, *sep1, *data;
	size_t		 i;
	int		 c;
d404 15
a418 22
	output = NULL;
	i = 1;
	SQL_BIND_INT64(db, s, i, pageid);
	SQL_BIND_INT64(db, s, i, outbit);
	while (SQLITE_ROW == (c = sqlite3_step(s))) {
		if (NULL == output) {
			oldoutput = "";
			sep1 = "";
		} else {
			oldoutput = output;
			sep1 = " # ";
		}
		data = (const char *)sqlite3_column_text(s, 1);
		mandoc_asprintf(&newoutput, "%s%s%s",
		    oldoutput, sep1, data);
		free(output);
		output = newoutput;
	}
	if (SQLITE_DONE != c)
		warnx("%s", sqlite3_errmsg(db));
	sqlite3_reset(s);
	return output;
d422 3
a424 4
 * Implement substring match as an application-defined SQL function.
 * Using the SQL LIKE or GLOB operators instead would be a bad idea
 * because that would require escaping metacharacters in the string
 * being searched for.
d426 2
a427 2
static void
sql_match(sqlite3_context *context, int argc, sqlite3_value **argv)
d429 1
d431 10
a440 4
	assert(2 == argc);
	sqlite3_result_int(context, NULL != strcasestr(
	    (const char *)sqlite3_value_text(argv[1]),
	    (const char *)sqlite3_value_text(argv[0])));
d444 2
a445 2
 * Implement regular expression match
 * as an application-defined SQL function.
d448 1
a448 1
sql_regexp(sqlite3_context *context, int argc, sqlite3_value **argv)
d450 10
a459 6

	assert(2 == argc);
	sqlite3_result_int(context, !regexec(
	    (regex_t *)sqlite3_value_blob(argv[0]),
	    (const char *)sqlite3_value_text(argv[1]),
	    0, NULL, 0));
d462 8
a469 2
static void
sql_append(char **sql, size_t *sz, const char *newstr, int count)
d471 8
a478 10
	size_t		 newsz;

	newsz = 1 < count ? (size_t)count : strlen(newstr);
	*sql = mandoc_realloc(*sql, *sz + newsz + 1);
	if (1 < count)
		memset(*sql + *sz, *newstr, (size_t)count);
	else
		memcpy(*sql + *sz, newstr, newsz);
	*sz += newsz;
	(*sql)[*sz] = '\0';
d482 2
a483 1
 * Prepare the search SQL statement.
d486 1
a486 1
sql_statement(const struct expr *e)
d488 16
a503 38
	char		*sql;
	size_t		 sz;
	int		 needop;

	sql = mandoc_strdup(e->equal ?
	    "SELECT desc, form, pageid, bits "
		"FROM mpages NATURAL JOIN names WHERE " :
	    "SELECT desc, form, pageid, 0 FROM mpages WHERE ");
	sz = strlen(sql);

	for (needop = 0; NULL != e; e = e->next) {
		if (e->and)
			sql_append(&sql, &sz, " AND ", 1);
		else if (needop)
			sql_append(&sql, &sz, " OR ", 1);
		if (e->open)
			sql_append(&sql, &sz, "(", e->open);
		sql_append(&sql, &sz,
		    TYPE_Nd & e->bits
		    ? (NULL == e->substr
			? "desc REGEXP ?"
			: "desc MATCH ?")
		    : TYPE_Nm == e->bits
		    ? (NULL == e->substr
			? "pageid IN (SELECT pageid FROM names "
			  "WHERE name REGEXP ?)"
			: e->equal
			? "name = ? "
			: "pageid IN (SELECT pageid FROM names "
			  "WHERE name MATCH ?)")
		    : (NULL == e->substr
			? "pageid IN (SELECT pageid FROM keys "
			  "WHERE key REGEXP ? AND bits & ?)"
			: "pageid IN (SELECT pageid FROM keys "
			  "WHERE key MATCH ? AND bits & ?)"), 1);
		if (e->close)
			sql_append(&sql, &sz, ")", e->close);
		needop = 1;
d505 1
a505 2

	return sql;
d514 1
a514 1
exprcomp(const struct mansearch *search, int argc, char *argv[])
d516 17
a532 13
	uint64_t	 mask;
	int		 i, toopen, logic, igncase, toclose;
	struct expr	*first, *prev, *cur, *next;

	first = cur = NULL;
	logic = igncase = toopen = toclose = 0;

	for (i = 0; i < argc; i++) {
		if (0 == strcmp("(", argv[i])) {
			if (igncase)
				goto fail;
			toopen++;
			toclose++;
d534 11
a544 6
		} else if (0 == strcmp(")", argv[i])) {
			if (toopen || logic || igncase || NULL == cur)
				goto fail;
			cur->close++;
			if (0 > --toclose)
				goto fail;
d546 4
a549 14
		} else if (0 == strcmp("-a", argv[i])) {
			if (toopen || logic || igncase || NULL == cur)
				goto fail;
			logic = 1;
			continue;
		} else if (0 == strcmp("-o", argv[i])) {
			if (toopen || logic || igncase || NULL == cur)
				goto fail;
			logic = 2;
			continue;
		} else if (0 == strcmp("-i", argv[i])) {
			if (igncase)
				goto fail;
			igncase = 1;
d552 13
a564 8
		next = exprterm(search, argv[i], !igncase);
		if (NULL == next)
			goto fail;
		if (NULL == first)
			first = next;
		else
			cur->next = next;
		prev = cur = next;
d566 5
a570 5
		/*
		 * Searching for descriptions must be split out
		 * because they are stored in the mpages table,
		 * not in the keys table.
		 */
d572 19
a590 10
		for (mask = TYPE_Nm; mask <= TYPE_Nd; mask <<= 1) {
			if (mask & cur->bits && ~mask & cur->bits) {
				next = mandoc_calloc(1,
				    sizeof(struct expr));
				memcpy(next, cur, sizeof(struct expr));
				prev->open = 1;
				cur->bits = mask;
				cur->next = next;
				cur = next;
				cur->bits &= ~mask;
d592 3
d596 24
a619 14
		prev->and = (1 == logic);
		prev->open += toopen;
		if (cur != prev)
			cur->close = 1;

		toopen = logic = igncase = 0;
	}
	if ( ! (toopen || logic || igncase || toclose))
		return first;

fail:
	if (NULL != first)
		exprfree(first);
	return NULL;
d623 1
a623 1
exprterm(const struct mansearch *search, char *buf, int cs)
d629 1
a629 1
	int		 i, irc;
d631 10
a640 2
	if ('\0' == *buf)
		return NULL;
d642 5
a646 1
	e = mandoc_calloc(1, sizeof(struct expr));
d650 2
a651 2
		e->substr = buf;
		e->equal = 1;
d657 1
a657 2
	 * If needed, request regular expression handling
	 * by setting e->substr to NULL.
d662 2
a663 2
		e->substr = NULL;
		mandoc_asprintf(&val, "[[:<:]]%s[[:>:]]", buf);
d665 1
a665 1
	} else if ((val = strpbrk(buf, "=~")) == NULL) {
d667 2
a668 1
		e->substr = buf;
d670 1
a670 1
		if (val == buf)
d672 5
a676 2
		if ('=' == *val)
			e->substr = val + 1;
d678 1
a678 1
		if (NULL != strstr(buf, "arch"))
d684 3
a686 2
	if (NULL == e->substr) {
		irc = regcomp(&e->regexp, val,
d688 4
d695 1
a695 2
			regerror(irc, &e->regexp, errbuf, sizeof(errbuf));
			warnx("regcomp: %s", errbuf);
d697 1
d702 2
a703 1
	if (e->bits)
d705 1
d712 1
a712 1
	while (NULL != (key = strsep(&buf, ","))) {
d715 2
a716 5
		for (i = 0, iterbit = 1;
		     i < mansearch_keymax;
		     i++, iterbit <<= 1) {
			if (0 == strcasecmp(key,
			    mansearch_keynames[i])) {
d721 4
a724 5
		if (i == mansearch_keymax) {
			if (strcasecmp(key, "any")) {
				free(e);
				return NULL;
			}
d729 1
d734 1
a734 1
exprfree(struct expr *p)
d736 5
a740 7
	struct expr	*pp;

	while (NULL != p) {
		pp = p->next;
		free(p);
		p = pp;
	}
@


1.49
log
@Prefer warn(3) over perror(3) at the few places where it was used.
It is useful to see the program name.
Suggested by Christos Zoulas (NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.48 2015/11/26 07:41:38 schwarze Exp $ */
a25 1
#include <getopt.h>
@


1.48
log
@No point in trying to go on when elementary database operations
like preparing queries or binding variables fail; that won't yield
useful results anyway but may generate huge pointless error messages.
Issue reported by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.47 2015/10/13 15:50:15 schwarze Exp $ */
d122 1
a122 1
			perror("mmap");
d141 1
a141 1
		perror("munmap");
d223 1
a223 1
				perror(buf);
d228 1
a228 1
			perror(paths->paths[i]);
d361 1
a361 1
		perror(buf);
@


1.47
log
@Reduce the amount of code by moving the three copies of the ohash
callback functions into one common place, preparing for the use of
ohash for some additional purposes.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.46 2015/10/11 21:06:59 schwarze Exp $ */
d51 1
a51 1
		warnx("%s", sqlite3_errmsg((_db))); \
d56 1
a56 1
		warnx("%s", sqlite3_errmsg((_db))); \
d61 1
a61 1
		warnx("%s", sqlite3_errmsg((_db))); \
d259 2
a260 1
			warnx("%s", sqlite3_errmsg(db));
d310 2
a311 1
			warnx("%s", sqlite3_errmsg(db));
d318 2
a319 1
			warnx("%s", sqlite3_errmsg(db));
@


1.46
log
@Finally use __progname, err(3) and warn(3).
That's more readable and less error-prone than fumbling around
with argv[0], fprintf(3), strerror(3), perror(3), and exit(3).
It also shortens the code by 50 lines.

It's a bad idea to boycott good interfaces merely because standards
committees ignore them.  Instead, it's the job of the portable
distribution to provide compatibility modules for archaic systems
(like commercial Solaris) that still don't have them.  Actually,
the compat code for the portable distribution already exists and
will be committed right after this.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.45 2015/10/06 18:30:44 schwarze Exp $ */
a36 1
#include <ohash.h>
d41 1
a87 3
static	void		*hash_alloc(size_t, void *);
static	void		 hash_free(void *, void *);
static	void		*hash_calloc(size_t, size_t, void *);
a164 1
	struct ohash_info info;
a174 5
	info.calloc = hash_calloc;
	info.alloc = hash_alloc;
	info.free = hash_free;
	info.key_offset = offsetof(struct match, pageid);

d270 1
a270 2
		memset(&htab, 0, sizeof(struct ohash));
		ohash_init(&htab, 4, &info);
a836 21
}

static void *
hash_calloc(size_t nmemb, size_t sz, void *arg)
{

	return mandoc_calloc(nmemb, sz);
}

static void *
hash_alloc(size_t sz, void *arg)
{

	return mandoc_malloc(sz);
}

static void
hash_free(void *p, void *arg)
{

	free(p);
@


1.45
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.44 2015/04/01 12:48:00 schwarze Exp $ */
d23 1
d51 1
a51 1
		fprintf(stderr, "%s\n", sqlite3_errmsg((_db))); \
d56 1
a56 1
		fprintf(stderr, "%s\n", sqlite3_errmsg((_db))); \
d61 1
a61 1
		fprintf(stderr, "%s\n", sqlite3_errmsg((_db))); \
d116 1
a116 1
			fprintf(stderr, "pagecache already enabled\n");
d136 1
a136 1
		fprintf(stderr, "pagecache: %s\n", sqlite3_errstr(c));
d139 1
a139 1
		fprintf(stderr, "pagecache missing\n");
d229 1
a229 2
				fprintf(stderr, "%s: getcwd: %s\n",
				    paths->paths[i], buf);
d246 1
a246 2
			fprintf(stderr, "%s/%s: %s\n",
			    paths->paths[i], MANDOC_DB, strerror(errno));
d268 1
a268 1
			fprintf(stderr, "%s\n", sqlite3_errmsg(db));
d310 1
a310 1
			fprintf(stderr, "%s\n", sqlite3_errmsg(db));
d319 1
a319 1
			fprintf(stderr, "%s\n", sqlite3_errmsg(db));
d326 1
a326 1
			fprintf(stderr, "%s\n", sqlite3_errmsg(db));
d507 1
a507 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db));
d557 1
a557 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db));
d799 1
a799 1
			fprintf(stderr, "regcomp: %s\n", errbuf);
@


1.44
log
@Let man(1) and apropos(1) work even when the current directory
is unusable: Only change back to the current directory when the
directory was changed before and the next path is relative.
This is now more similar to what makewhatis(8) does.
Issue reported by espie@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.43 2015/03/27 17:36:56 schwarze Exp $ */
d116 1
a116 1
			return((int)MANDOCLEVEL_BADARG);
d126 1
a126 1
			return((int)MANDOCLEVEL_SYSERR);
d133 1
a133 1
			return((int)MANDOCLEVEL_OK);
d139 1
a139 1
		return((int)MANDOCLEVEL_BADARG);
d145 1
a145 1
		return((int)MANDOCLEVEL_SYSERR);
d149 1
a149 1
	return((int)MANDOCLEVEL_OK);
d175 1
a175 1
		return(0);
d373 1
a373 1
	return(1);
d397 3
a399 3
	return(	(diff = mp2->bits - mp1->bits) ? diff :
		(diff = mp1->sec - mp2->sec) ? diff :
		strcasecmp(mp1->names, mp2->names));
d560 1
a560 1
	return(output);
d655 1
a655 1
	return(sql);
d738 1
a738 1
		return(first);
d743 1
a743 1
	return(NULL);
d756 1
a756 1
		return(NULL);
d764 1
a764 1
		return(e);
d802 1
a802 1
			return(NULL);
d807 1
a807 1
		return(e);
d829 1
a829 1
				return(NULL);
d835 1
a835 1
	return(e);
d854 1
a854 1
	return(mandoc_calloc(nmemb, sz));
d861 1
a861 1
	return(mandoc_malloc(sz));
@


1.43
log
@Parse the new man.conf(5) "output" directive.
The next step will be to actually use the parsed data.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.42 2015/03/11 13:10:25 schwarze Exp $ */
a157 1
	int		 fd, rc, c, indexbit;
d171 6
d183 1
a183 2
	*sz = cur = maxres = 0;
	sql = NULL;
a184 8
	fd = -1;
	e = NULL;
	rc = 0;

	if (0 == argc)
		goto out;
	if (NULL == (e = exprcomp(search, argc, argv)))
		goto out;
d201 5
a205 4
	 * Save a descriptor to the current working directory.
	 * Since pathnames in the "paths" variable might be relative,
	 * and we'll be chdir()ing into them, we need to keep a handle
	 * on our current directory from which to start the chdir().
d208 5
a212 7
	if (NULL == getcwd(buf, PATH_MAX)) {
		perror("getcwd");
		goto out;
	} else if (-1 == (fd = open(buf, O_RDONLY, 0))) {
		perror(buf);
		goto out;
	}
d224 1
d226 11
a236 5
		if (-1 == fchdir(fd)) {
			perror(buf);
			free(*res);
			break;
		} else if (-1 == chdir(paths->paths[i])) {
d240 1
d368 2
a369 7
	rc = 1;
out:
	if (-1 != fd) {
		if (-1 == fchdir(fd))
			perror(buf);
		close(fd);
	}
d373 1
a373 1
	return(rc);
@


1.42
log
@When interpreting the -O argument as a macro name fails,
fall back to showing Nd rather than not showing anything.
Issue reported by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.41 2015/02/27 16:00:54 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d41 1
a41 1
#include "manpath.h"
@


1.41
log
@When man(1) and apropos(1) look for a file man1/foo.1 but it's unavailable,
fall back to glob(man1/foo.*), which is more like what old man(1) did.
Do this both for file names from the database and for fs_lookup().
This is relevant because some ports install files like man1/xset.1x.
Regression reported by patrick keshishian <pkeshish at gmail dot com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.40 2015/01/20 18:19:39 schwarze Exp $ */
a189 1
	outbit = 0;
d191 1
d201 2
a202 1
	}
@


1.40
log
@Make the man(1) and apropos(1) options -s and -S much less expensive:
Do not append an SQL clause looking into the large "keys" table.
Instead, filter the result of the SQL query in buildnames() where
equivalent data from the much smaller "mlinks" table is already
available for free.

This is relevant because man(1) uses the equivalent of "-S ${MACHINE}"
by default since main.c rev. 1.122, to make sure that manuals for
the current architecture are shown.  With many ports installed, this
patch can speed up man(1) by a factor of more than a hundred.

Slowness reported by Theo Buehler <theo at math dot ethz dot ch>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.39 2014/12/06 01:22:28 schwarze Exp $ */
d26 1
d408 2
a409 1
	char		*newnames, *prevsec, *prevarch;
d412 1
a412 1
	int		 c;
d416 1
a416 1
	prevsec = prevarch = NULL;
d491 16
d511 7
@


1.39
log
@When opening mandoc.db fails, tell the user in which directory.
Improving an unhelpful error message reported by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.38 2014/11/27 01:57:42 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d80 2
a81 1
static	void		 buildnames(struct manpage *, sqlite3 *,
a91 2
static	struct expr	*exprspec(struct expr *, uint64_t,
				 const char *, const char *);
d337 1
a337 1
			buildnames(mpage, db, s, mp->pageid,
d339 7
a345 4
			mpage->output = TYPE_Nd & outbit ?
			    mp->desc : outbit ?
			    buildoutput(db, s2, mp->pageid, outbit) : NULL;

a346 1
			cur++;
d403 2
a404 1
buildnames(struct manpage *mpage, sqlite3 *db, sqlite3_stmt *s,
d429 1
a429 1
		/* Fetch the next name. */
d432 2
d435 3
d647 1
a647 2
	logic = igncase = toclose = 0;
	toopen = NULL != search->sec || NULL != search->arch;
d713 2
a714 11
	if (toopen || logic || igncase || toclose)
		goto fail;

	if (NULL != search->sec || NULL != search->arch)
		cur->close++;
	if (NULL != search->arch)
		cur = exprspec(cur, TYPE_arch, search->arch, "^(%s|any)$");
	if (NULL != search->sec)
		exprspec(cur, TYPE_sec, search->sec, "^%s$");

	return(first);
a719 23
}

static struct expr *
exprspec(struct expr *cur, uint64_t key, const char *value,
		const char *format)
{
	char	 errbuf[BUFSIZ];
	char	*cp;
	int	 irc;

	mandoc_asprintf(&cp, format, value);
	cur->next = mandoc_calloc(1, sizeof(struct expr));
	cur = cur->next;
	cur->and = 1;
	cur->bits = key;
	if (0 != (irc = regcomp(&cur->regexp, cp,
	    REG_EXTENDED | REG_NOSUB | REG_ICASE))) {
		regerror(irc, &cur->regexp, errbuf, sizeof(errbuf));
		fprintf(stderr, "regcomp: %s\n", errbuf);
		cur->substr = value;
	}
	free(cp);
	return(cur);
@


1.38
log
@Make makewhatis(8) understand .so links to .gz pages.
Drop the FORM_GZ annotation in the mpages table; it is conceptually wrong
because it ought to be in the mlinks table: An uncompressed .so link file
can point to a compressed manual page file and vice versa.
Besides, it is no longer needed because mparse_open() handles it all.
Sprinkle some KNF while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.37 2014/11/18 01:14:40 schwarze Exp $ */
d23 1
d242 2
a243 1
			perror(MANDOC_DB);
@


1.37
log
@In man(1) mode, prefer file name matches over .Dt name matches over
first .Nm entries over other NAME .Nm entries over SYNOPSIS .Nm entries.
For example, this makes sure "man ypbind" does not return yp(8).
Re-run "makewhatis" to profit from this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.36 2014/11/11 19:03:10 schwarze Exp $ */
a404 1
	const char	*gzip;
d467 1
a467 1
		if (NULL != mpage->file)
d477 3
a479 7
		if (form & FORM_GZ)
			gzip = ".gz";
		else
			gzip = "";
		sep2 = '\0' == *arch ? "" : "/";
		mandoc_asprintf(&mpage->file, "%s/%s%s%s%s/%s.%s%s",
		    path, sep1, sec, sep2, arch, name, fsec, gzip);
d481 1
a481 1
	if (SQLITE_DONE != c)
d487 2
a488 2
	if (NULL != prevsec) {
		sep2 = '\0' == *prevarch ? "" : "/";
@


1.36
log
@In man(1) mode without -a, stop searching after the first manual tree
that contained at least one match in order to not prefer mdoc(1) from
ports over mdoc(7).  As a bonus, this results in a speedup.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.35 2014/09/03 18:08:26 schwarze Exp $ */
d74 1
d297 1
d333 1
d394 3
a396 2
	diff = mp1->sec - mp2->sec;
	return(diff ? diff : strcasecmp(mp1->names, mp2->names));
d591 4
a594 2
	sql = mandoc_strdup(
	    "SELECT desc, form, pageid FROM mpages WHERE ");
d614 1
a614 2
			? "pageid IN (SELECT pageid FROM names "
			  "WHERE name = ?)"
@


1.35
log
@If a manual page is installed gzip(1)ed, let makewhatis(8) take
note in mandoc.db(5), such that man(1) -w and apropos(1) -w can
report the correct filename.
This is a prerequisite for letting apropos -a and man support
gzip'ed manuals in the future, which doesn't work yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.34 2014/09/01 22:45:11 schwarze Exp $ */
d347 8
@


1.34
log
@In man(1) mode, change to the right directory before starting the parser,
just like traditional man(1) does, such that .so links have a chance to
work.  After this point, we don't need the current directory for anything
else before exit, so we don't need to worry about getting back and we can
safely ignore failure.
This lets man(1) find more Xenocara manuals, but not all of them yet.
Other issues remain that need to be fixed, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: mansearch.c,v 1.33 2014/08/27 00:06:08 schwarze Exp $ */
d75 1
a75 1
	int		 form; /* 0 == catpage */
d393 1
d459 1
a459 1
		if (form) {
d466 4
d471 2
a472 2
		mandoc_asprintf(&mpage->file, "%s/%s%s%s%s/%s.%s",
		    path, sep1, sec, sep2, arch, name, fsec);
@


1.33
log
@Add an implementation of man(1) into the /usr/bin/mandoc binary and
provide a unified set of command line options for mandoc(1), man(1),
apropos(1), and whatis(1), each option doing the same for all four.
Not adding any completely new options, only extending exiting ones
from one tool to the others.  New options are:
* apropos & whatis -acfkw  (in the past, these were man(1) only)
* apropos & whatis -a -IOTW  (in the past, mandoc(1) only)
* mandoc -ac  (in the past, man(1) only)
* man -IOTW  (in the past, mandoc(1) only)

Before we can decide whether or not we want to replace src/usr.bin/man
with this implementation, considerable bugfixing, testing, and
performance measurements are needed, which i'd rather do in the tree
than outside.  Note that these bugs only affect the new man(1) mode,
existing mandoc(1), apropos(1), and whatis(1) is fine.

The new functionality in mandoc(1), apropos(1), and whatis(1)
is fully enabled.  To play with the new man(1), you can try:
# mv /usr/bin/man /usr/bin/oman
# ln -s /usr/bin/mandoc /usr/bin/man

Positive feedback about the general direction from sthen@@ and jmc@@,
and deraadt@@ is not against it.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d330 1
@


1.32
log
@Bugfix: make whatis(1) case-insensitive again.
The traditional whatis(1) was case-insensitve and it's still documented
that way, that but apparently got broken with or after the switch.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.31 2014/08/09 14:24:49 schwarze Exp $ */
d18 1
d20 2
a153 1
		const char *outkey,
d189 1
a189 1
	if (NULL != outkey) {
d193 1
a193 1
			if (0 == strcasecmp(outkey,
d361 13
d746 2
a747 2
	if (MANSEARCH_MAN & search->flags) {
		e->bits = search->deftype;
d754 3
a756 2
	 * Look for an '=' or '~' operator,
	 * unless forced to some fixed macro keys.
d759 7
a765 7
	if (MANSEARCH_WHATIS & search->flags)
		val = NULL;
	else
		val = strpbrk(buf, "=~");

	if (NULL == val) {
		e->bits = search->deftype;
a766 6

	/*
	 * Found an operator.
	 * Regexp search is requested by !e->substr.
	 */

d769 1
a769 1
			e->bits = search->deftype;
a778 6
	if (MANSEARCH_WHATIS & search->flags) {
		e->substr = NULL;
		mandoc_asprintf(&val, "[[:<:]]%s[[:>:]]", buf);
		cs = 0;
	}

d782 1
a782 1
		if (MANSEARCH_WHATIS & search->flags)
@


1.31
log
@mmap(2) requires MAP_PRIVATE ^ MAP_SHARED for flags;
found by kristaps@@ on Mac OS X
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.30 2014/08/08 17:36:21 schwarze Exp $ */
d772 1
@


1.30
log
@Absurdly, the return value of sqlite3_column_text()
is "const unsigned char *", which causes warnings with GCC on Linux.
Explicitly cast to "const char *" to avoid this.
Issue noticed by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.29 2014/07/24 20:30:38 schwarze Exp $ */
d115 2
a116 1
		    PROT_READ | PROT_WRITE, MAP_ANON, -1, 0);
@


1.29
log
@Sort result pages first by section number, then by name.
By moving the sort from cgi.c to mansearch.c, we get two advantages:
Easier access to the data needed for sorting, in particular the section
number, and the apropos(1) command line utility profits as well.

Feature requested by deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.28 2014/07/12 13:59:54 schwarze Exp $ */
d294 1
a294 1
				mp->desc = mandoc_strdup(
d398 3
a400 3
		sec = sqlite3_column_text(s, 0);
		arch = sqlite3_column_text(s, 1);
		name = sqlite3_column_text(s, 2);
d489 1
a489 1
		data = sqlite3_column_text(s, 1);
@


1.28
log
@Fix whatis(1) to correctly match words instead of any substrings.
While here, also provide an internal mode (MANSEARCH_MAN) to match
complete names, to be used by man.cgi(8).
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.27 2014/05/12 19:11:20 espie Exp $ */
d89 1
d327 1
d344 1
d358 12
d401 5
@


1.27
log
@adjust to ohash being in libutil now, and to the interface changes.
fix potential integer overflows in memory allocation (mostly for pedagogical
purposes, these are unlikely to overflow in practice)
move the rest of lst.lib stuff into its own directory.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.26 2014/04/23 21:06:33 schwarze Exp $ */
d59 3
d63 1
a63 2
	const char	*substr;  /* to search for, if applicable */
	regex_t		 regexp;  /* compiled regexp, if applicable */
a66 1
	struct expr	*next;    /* next in sequence */
d557 3
d701 1
a701 1
	char		*key, *v;
d710 2
a711 3
	/*"whatis" mode uses an opaque string and default fields. */

	if (MANSEARCH_WHATIS & search->flags) {
d713 1
a713 1
		e->bits = search->deftype;
d718 2
a719 3
	 * If no =~ is specified, search with equality over names and
	 * descriptions.
	 * If =~ begins the phrase, use name and description fields.
d722 7
a728 1
	if (NULL == (v = strpbrk(buf, "=~"))) {
a729 4
		e->bits = search->deftype;
		return(e);
	} else if (v == buf)
		e->bits = search->deftype;
d731 11
a741 1
	if ('~' == *v++) {
d744 15
a758 2
		if (0 != (irc = regcomp(&e->regexp, v,
		    REG_EXTENDED | REG_NOSUB | (cs ? 0 : REG_ICASE)))) {
d764 4
a767 3
	} else
		e->substr = v;
	v[-1] = '\0';
@


1.26
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
* Change eight reallocs to reallocarray to be safe from overflows.
* Change one malloc to reallocarray to be safe from overflows.
* Change one calloc to reallocarray, no zeroing needed.
* Change the order of arguments of three callocs (aesthetical).
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.25 2014/04/23 16:33:37 schwarze Exp $ */
d80 2
a81 2
static	void		 hash_free(void *, size_t, void *);
static	void		*hash_halloc(size_t, void *);
d166 1
a166 3
	memset(&info, 0, sizeof(struct ohash_info));

	info.halloc = hash_halloc;
d168 1
a168 1
	info.hfree = hash_free;
d783 1
a783 1
hash_halloc(size_t sz, void *arg)
d786 1
a786 1
	return(mandoc_calloc(1, sz));
d797 1
a797 1
hash_free(void *p, size_t sz, void *arg)
@


1.25
log
@improve SQL style: avoid "SELECT *", be explicit in what columns we want;
suggested by espie@@.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.24 2014/04/20 16:44:44 schwarze Exp $ */
d323 2
a324 2
				*res = mandoc_realloc(*res,
				    maxres * sizeof(struct manpage));
d788 1
a788 1
	return(mandoc_calloc(sz, 1));
@


1.24
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.23 2014/04/17 19:19:54 schwarze Exp $ */
d305 2
a306 2
		    "SELECT * FROM mlinks WHERE pageid=?"
		    " ORDER BY sec, arch, name",
d312 2
a313 1
		    "SELECT * FROM keys WHERE pageid=? AND bits & ?",
d538 2
a539 1
	sql = mandoc_strdup("SELECT * FROM mpages WHERE ");
@


1.23
log
@Garbage collect one pair of needless parentheses in SQL code generation;
note this doesn't affect performance, SQLite generates the same byte code.
While here, make the calls to exprspec() easier to understand.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.22 2014/04/16 21:35:48 schwarze Exp $ */
d59 1
a59 1
	uint64_t 	 bits;    /* type-mask */
d82 1
a82 1
static	struct expr	*exprcomp(const struct mansearch *, 
d96 1
d231 1
a231 1
		} 
d233 2
a234 3
		c =  sqlite3_open_v2
			(MANDOC_DB, &db, 
			 SQLITE_OPEN_READONLY, NULL);
d283 3
a285 3
			idx = ohash_lookup_memory
				(&htab, (char *)&pageid,
				 sizeof(uint64_t), (uint32_t)pageid);
d304 1
a304 1
		c = sqlite3_prepare_v2(db, 
d322 2
a323 2
				*res = mandoc_realloc
					(*res, maxres * sizeof(struct manpage));
@


1.22
log
@Rename the mpages.id column to mpages.pageid.  There is no good reason
to call this kid by a different name here than in all other tables.
Easier to polish this now than after enabling.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.21 2014/04/16 00:33:24 schwarze Exp $ */
d585 1
a585 1
	toopen = 1;
d654 6
a659 3
	cur->close++;
	cur = exprspec(cur, TYPE_arch, search->arch, "^(%s|any)$");
	exprspec(cur, TYPE_sec, search->sec, "^%s$");
a675 3

	if (NULL == value)
		return(cur);
@


1.21
log
@Pass the function flags SQLITE_UTF8 (because SQLITE_ANY is deprecated)
and SQLITE_DETERMINISTIC when creating deterministic functions;
best practice measure suggested by espie@@ and jeremy@@;
as expected by jeremy@@, no measurable effect on performance.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.20 2014/04/15 23:47:57 schwarze Exp $ */
d69 1
a69 1
	uint64_t	 id; /* identifier in database */
d151 1
a151 1
	int64_t		 id;
d170 1
a170 1
	info.key_offset = offsetof(struct match, id);
d282 1
a282 1
			id = sqlite3_column_int64(s, 2);
d284 2
a285 2
				(&htab, (char *)&id,
				 sizeof(uint64_t), (uint32_t)id);
d291 1
a291 1
			mp->id = id;
d327 1
a327 1
			buildnames(mpage, db, s, mp->id,
d331 1
a331 1
			    buildoutput(db, s2, mp->id, outbit) : NULL;
d357 1
a357 1
		uint64_t id, const char *path, int form)
d368 1
a368 1
	SQL_BIND_INT64(db, s, i, id);
d450 1
a450 1
buildoutput(sqlite3 *db, sqlite3_stmt *s, uint64_t id, uint64_t outbit)
d459 1
a459 1
	SQL_BIND_INT64(db, s, i, id);
d554 1
a554 1
			? "id IN (SELECT pageid FROM names "
d556 1
a556 1
			: "id IN (SELECT pageid FROM names "
d559 1
a559 1
			? "id IN (SELECT pageid FROM keys "
d561 1
a561 1
			: "id IN (SELECT pageid FROM keys "
@


1.20
log
@At the end of mansearch(), fchdir() back to where we started from;
this is cleaner and helps to not scatter gmon.out files all over
the place when profiling.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.19 2014/04/11 15:45:39 schwarze Exp $ */
d248 2
a249 1
		    SQLITE_ANY, NULL, sql_match, NULL, NULL);
d252 2
a253 1
		    SQLITE_ANY, NULL, sql_regexp, NULL, NULL);
@


1.19
log
@Further apropos(1) speed optimization was trickier than anticipated.
Contrary to what i initially thought, almost all time is now spent
inside sqlite3(3) routines, and i found no easy way calling less of them.
However, sqlite(3) spends substantial time in malloc(3), and even more
(twice that) in its immediate malloc wrapper, sqlite3MemMalloc(),
keeping track of all individual malloc chunk sizes.  Typically about
90% of the malloced memory is used for purposes of the pagecache.

By providing an mmap(3) MAP_ANON SQLITE_CONFIG_PAGECACHE, execution
time decreases by 20-25% for simple (Nd and/or Nm) queries, 10-20% for
non-NAME queries, and even apropos(1) resident memory size as reported
by top(1) decreases by 20% for simple and by 60% for non-NAME queries.
The new function, mansearch_setup(), spends no measurable time.

The pagesize chosen is optimal:
* Substantially smaller pages yield no gain at all.
* Larger pages provide no additional benefit and just waste memory.

The chosen number of pages in the cache is a compromise:
* For simple queries, a handful of pages would suffice to get the full
speed effect, at an apropos(1) resident memory size of about 2.0 MB.
* For non-NAME queries, a large pagecache with 2k pages (2.5 MB) might
gain a few more percent in speed, but at the expense of doubling the
apropos(1) resident memory size for *all* queries.
* The chosen number of 256 pages (330 kB) allows nearly full speed gain
for all queries at the price of a 15% resident memory size increase.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.18 2014/04/10 02:45:04 schwarze Exp $ */
d205 1
a205 1
		perror(NULL);
d342 5
a347 2
	if (-1 != fd)
		close(fd);
@


1.18
log
@Next speed optimization step for the new apropos(1).
Split manual names out of the common "keys" table into their
own "names" table.  This reduces standard apropos(1) search
times (i.e. searching for names and descriptions only) by
typically about 70% for the full /usr/share/man database.
(Yes, that multiplies with the previous optimization step,
so both together have reduced search times by a factor of
more than six.  I'm not done yet, expect more to come.)

Even with the minimal databases built with makewhatis(8) -Q,
this step still reduces search times by 15-20%.  For both cases,
database sizes and build times hardly change (+/-2%).
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.17 2014/04/09 21:49:31 schwarze Exp $ */
d18 1
d95 47
@


1.17
log
@After careful gprof(1)ing of the new apropos(1), move the descriptions
back from the keys table to the mpages table:  I found a good way
to still use them in searches, without complication of the code.

On my notebook, this reduces typical apropos(1) search times by about 40%,
it reduces /usr/share/man database size by 6% in makewhatis(8) -Q mode
and by 2% in standard mode (less overhead storing pointers to mpages),
and it doesn't measurably change database build times (may even be
going down by a percent or so because less data is being copied
around in ohashes).
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.16 2014/03/28 19:16:15 schwarze Exp $ */
d216 1
a216 1
			if (0 == (TYPE_Nd & ep->bits))
d499 6
d526 1
d528 1
a528 1
	struct expr	*first, *next, *cur;
d571 1
d579 15
a593 7
		if (TYPE_Nd & next->bits && ~TYPE_Nd & next->bits) {
			cur = mandoc_calloc(1, sizeof(struct expr));
			memcpy(cur, next, sizeof(struct expr));
			next->open = 1;
			next->bits = TYPE_Nd;
			next->next = cur;
			cur->bits &= ~TYPE_Nd;
d595 1
a595 4
		} else
			cur = next;
		next->and = (1 == logic);
		next->open += toopen;
@


1.16
log
@Properly initialize malloc(3)ed memory.
With this bug fix, partly unitialized memory could sometimes be
returned, sometimes causing crashes by bogus free(3)s in apropos(1).
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.15 2014/03/21 22:52:21 schwarze Exp $ */
d69 1
d216 2
a217 1
			SQL_BIND_INT64(db, s, j, ep->bits);
d232 1
a232 1
			id = sqlite3_column_int64(s, 1);
d234 1
a234 1
				(&htab, (char *)&id, 
d242 4
a245 1
			mp->form = sqlite3_column_int(s, 0);
d279 2
a280 1
			mpage->output = outbit ?
d494 10
a503 5
		sql_append(&sql, &sz, NULL == e->substr ?
		    "id IN (SELECT pageid FROM keys "
		    "WHERE key REGEXP ? AND bits & ?)" :
		    "id IN (SELECT pageid FROM keys "
		    "WHERE key MATCH ? AND bits & ?)", 1);
d560 3
a562 3
		next->open = toopen;
		next->and = (1 == logic);
		if (NULL != first) {
d564 16
d581 2
a582 2
		} else
			cur = first = next;
@


1.15
log
@avoid repetitive code for asprintf error handling
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.14 2014/03/21 22:17:01 schwarze Exp $ */
d305 1
@


1.14
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.13 2014/03/17 16:29:22 schwarze Exp $ */
d333 2
a334 5
			if (-1 == asprintf(&newnames, "%s(%s%s%s)",
			    oldnames, prevsec, sep2, prevarch)) {
				perror(0);
				exit((int)MANDOCLEVEL_SYSERR);
			}
d351 2
a352 5
		if (-1 == asprintf(&newnames, "%s%s%s",
		    oldnames, sep1, name)) {
			perror(0);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d369 2
a370 5
		if (-1 == asprintf(&mpage->file, "%s/%s%s%s%s/%s.%s",
		    path, sep1, sec, sep2, arch, name, fsec)) {
			perror(0);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d380 2
a381 5
		if (-1 == asprintf(&newnames, "%s(%s%s%s)",
		    mpage->names, prevsec, sep2, prevarch)) {
			perror(0);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d410 2
a411 5
		if (-1 == asprintf(&newoutput, "%s%s%s",
		    oldoutput, sep1, data)) {
			perror(0);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d583 1
a583 4
	if (-1 == asprintf(&cp, format, value)) {
		perror(0);
		exit((int)MANDOCLEVEL_SYSERR);
	}
@


1.13
log
@in apropos(1) output, sort names and avoid multiple section numbers
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.12 2014/01/19 23:09:13 schwarze Exp $ */
d34 1
@


1.12
log
@Always compare arch case-insensitively.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.11 2014/01/19 01:18:30 schwarze Exp $ */
d249 2
a250 1
		    "SELECT * FROM mlinks WHERE pageid=?",
d299 1
a299 1
	char		*newnames;
d305 1
d310 1
a310 1
		/* Assemble the list of names. */
d319 3
d325 30
a354 3
		sep2 = '\0' == *arch ? "" : "/";
		if (-1 == asprintf(&newnames, "%s%s%s(%s%s%s)",
		    oldnames, sep1, name, sec, sep2, arch)) {
d373 1
d383 15
@


1.11
log
@Get rid of the local keys table, use the new mansearch_const.c.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.10 2014/01/06 03:52:05 schwarze Exp $ */
d603 2
@


1.10
log
@Remove the redundant "file" column from the "mlinks" table.
The contents can easily be reconstructed from sec, arch, name, form.
Shrinks the database by another 3% in standard mode and 9% in -Q mode.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.9 2014/01/06 03:02:40 schwarze Exp $ */
d37 3
a70 51
struct	type {
	uint64_t	 bits;
	const char	*name;
};

static	const struct type types[] = {
	{ TYPE_An,  "An" },
	{ TYPE_Ar,  "Ar" },
	{ TYPE_At,  "At" },
	{ TYPE_Bsx, "Bsx" },
	{ TYPE_Bx,  "Bx" },
	{ TYPE_Cd,  "Cd" },
	{ TYPE_Cm,  "Cm" },
	{ TYPE_Dv,  "Dv" },
	{ TYPE_Dx,  "Dx" },
	{ TYPE_Em,  "Em" },
	{ TYPE_Er,  "Er" },
	{ TYPE_Ev,  "Ev" },
	{ TYPE_Fa,  "Fa" },
	{ TYPE_Fl,  "Fl" },
	{ TYPE_Fn,  "Fn" },
	{ TYPE_Fn,  "Fo" },
	{ TYPE_Ft,  "Ft" },
	{ TYPE_Fx,  "Fx" },
	{ TYPE_Ic,  "Ic" },
	{ TYPE_In,  "In" },
	{ TYPE_Lb,  "Lb" },
	{ TYPE_Li,  "Li" },
	{ TYPE_Lk,  "Lk" },
	{ TYPE_Ms,  "Ms" },
	{ TYPE_Mt,  "Mt" },
	{ TYPE_Nd,  "Nd" },
	{ TYPE_Nm,  "Nm" },
	{ TYPE_Nx,  "Nx" },
	{ TYPE_Ox,  "Ox" },
	{ TYPE_Pa,  "Pa" },
	{ TYPE_Rs,  "Rs" },
	{ TYPE_Sh,  "Sh" },
	{ TYPE_Ss,  "Ss" },
	{ TYPE_St,  "St" },
	{ TYPE_Sy,  "Sy" },
	{ TYPE_Tn,  "Tn" },
	{ TYPE_Va,  "Va" },
	{ TYPE_Va,  "Vt" },
	{ TYPE_Xr,  "Xr" },
	{ TYPE_sec, "sec" },
	{ TYPE_arch,"arch" },
	{ ~0ULL,    "any" },
	{ 0ULL, NULL }
};

d100 1
a100 1
	int		 fd, rc, c, ibit;
d102 1
a102 1
	uint64_t	 outbit;
d136 6
a141 3
		for (ibit = 0; types[ibit].bits; ibit++) {
			if (0 == strcasecmp(types[ibit].name, outkey)) {
				outbit = types[ibit].bits;
d573 2
a574 2
	size_t		 i;
	int		 irc;
d622 15
a636 7
		i = 0;
		while (types[i].bits && 
			strcasecmp(types[i].name, key))
			i++;
		if (0 == types[i].bits) {
			free(e);
			return(NULL);
a637 1
		e->bits |= types[i].bits;
@


1.9
log
@Drop Nd from the mpages table, it is still in the keys table.
This shrinks the database in standard mode by 3%, in -Q mode by 9%,
without loss of functionality.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.8 2014/01/05 04:13:46 schwarze Exp $ */
d120 2
a121 1
				sqlite3_stmt *, uint64_t, const char *);
d315 2
a316 1
			buildnames(mpage, db, s, mp->id, paths->paths[i]);
d341 1
a341 1
		uint64_t id, const char *path)
d344 1
a344 1
	const char	*oldnames, *sep1, *name, *sec, *sep2, *arch;
d362 3
a364 3
		sec = sqlite3_column_text(s, 1);
		arch = sqlite3_column_text(s, 2);
		name = sqlite3_column_text(s, 3);
d379 9
a387 2
		name = sqlite3_column_text(s, 0);
		if (-1 == asprintf(&mpage->file, "%s/%s", path, name)) {
@


1.8
log
@Remove the obsolete file name column from the mpages table.
This column wasn't helpful because one manpage can have multiple MLINKS.
Use the file name column in the mlinks table, instead.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.7 2014/01/05 03:25:51 schwarze Exp $ */
a64 1
	char		*desc; /* description of manpage */
d273 1
a273 1
			id = sqlite3_column_int64(s, 2);
d283 1
a283 3
			mp->desc = mandoc_strdup
				((char *)sqlite3_column_text(s, 0));
			mp->form = sqlite3_column_int(s, 1);
a312 1
			mpage->desc = mp->desc;
@


1.7
log
@Remove the obsolete sec and arch columns from the mpages table.
They were confusing because a manpage can have MLINKS in different
sections and architectures.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.6 2014/01/05 03:06:36 schwarze Exp $ */
a64 1
	char		*file; /* relative filepath of manpage */
d120 2
a121 1
static	char		*buildnames(sqlite3 *, sqlite3_stmt *, uint64_t);
d274 1
a274 1
			id = sqlite3_column_int64(s, 3);
d284 1
a284 1
			mp->file = mandoc_strdup
d286 1
a286 3
			mp->desc = mandoc_strdup
				((char *)sqlite3_column_text(s, 1));
			mp->form = sqlite3_column_int(s, 2);
a315 5
			if (-1 == asprintf(&mpage->file, "%s/%s",
			    paths->paths[i], mp->file)) {
				perror(0);
				exit((int)MANDOCLEVEL_SYSERR);
			}
d318 1
a318 1
			mpage->names = buildnames(db, s, mp->id);
a321 1
			free(mp->file);
d341 3
a343 2
static char *
buildnames(sqlite3 *db, sqlite3_stmt *s, uint64_t id)
d345 1
a345 1
	char		*names, *newnames;
d350 1
a350 1
	names = NULL;
d354 4
a357 1
		if (NULL == names) {
d361 1
a361 1
			oldnames = names;
d373 13
a385 2
		free(names);
		names = newnames;
a389 1
	return(names);
@


1.6
log
@Reimplement apropos -s NUM -S ARCH EXPR by internally converting it to
apropos \( EXPR \) -a 'sec~^NUM$' -a 'arch~^(ARCH|any)$'
in preparation for removal of sec and arch from the mpage table.

Almost no functional change except for the following bonus:
This also makes sure that for cross-section and cross-arch MLINKs,
all of the following work:
apropos -s 1 encrypt
apropos -s 8 encrypt
apropos -s 1 makekey
apropos -s 8 makekey
Before this commit, they don't, neither for the
old makewhatis(8)/apropos(1) combo nor for the new one.

While here, print error messages about invalid regexps to stderr.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.5 2014/01/05 00:29:49 schwarze Exp $ */
d274 1
a274 1
			id = sqlite3_column_int64(s, 5);
d287 2
a288 2
				((char *)sqlite3_column_text(s, 3));
			mp->form = sqlite3_column_int(s, 4);
@


1.5
log
@Put section and architecture info into the keys table,
in preparation for removing them from the mpages table,
aiming for cleaner and more uniform interfaces.
Database growth is below 4%, part of which will be reclaimed.

As a bonus, this allows searches like:
./obj/apropos An=kettenis -a arch=ppc
./obj/apropos An=kettenis -a sec~[^4]
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.4 2014/01/04 23:42:32 schwarze Exp $ */
d130 2
d139 1
a139 2
static	char		*sql_statement(const struct expr *,
				const char *, const char *);
d207 1
a207 1
	sql = sql_statement(e, search->arch, search->sec);
a253 5
		if (NULL != search->arch)
			SQL_BIND_TEXT(db, s, j, search->arch);
		if (NULL != search->sec)
			SQL_BIND_TEXT(db, s, j, search->sec);

d471 1
a471 1
sql_statement(const struct expr *e, const char *arch, const char *sec)
a479 6
	if (NULL != arch)
		sql_append(&sql, &sz, "arch = ? AND ", 1);
	if (NULL != sec)
		sql_append(&sql, &sz, "sec = ? AND ", 1);
	sql_append(&sql, &sz, "(", 1);

a495 1
	sql_append(&sql, &sz, ")", 1);
d512 2
a513 1
	toopen = logic = igncase = toclose = 0;
d557 9
a565 2
	if ( ! (toopen || logic || igncase || toclose))
		return(first);
d573 29
d604 1
d608 1
d637 4
a640 2
		if (regcomp(&e->regexp, v,
		    REG_EXTENDED | REG_NOSUB | (cs ? 0 : REG_ICASE))) {
@


1.4
log
@New implementation of complex search criteria using \(, \), -a because
the old implementation got lost in the Berkeley to SQLite switch.
Note that this is not just feature creep, but required for upcoming
database format cleanup and simplification.

The following takes less than half a second on my Z61m ThinkPad:
time ./obj/apropos An=kettenis -a \( Cd=vnet -o Xr=vbus \)
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.3 2013/12/31 03:41:09 schwarze Exp $ */
d115 2
@


1.3
log
@Experimental feature to let apropos(1) show different keys than .Nd.
This really takes us beyond what grep -R /usr/*/man/ can do
because now you can search for pages by *one* criterion and then
display the contents of *another* macro from those pages, like in
$ apropos -O Ox Fa~wchar
to get an impression how long wide character handling is available.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.2 2013/12/31 02:42:20 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013 Ingo Schwarze <schwarze@@openbsd.org>
d57 3
d129 2
d276 1
a276 1
			id = sqlite3_column_int64(s, 0);
d287 2
d290 1
a290 3
			mp->desc = mandoc_strdup
				((char *)sqlite3_column_text(s, 4));
			mp->form = sqlite3_column_int(s, 5);
d454 15
a470 2
 * We search for any of the words specified in our match expression.
 * We filter the per-doc AND expressions when collecting results.
a475 6
	const char	*substr = "(key MATCH ? AND bits & ?)";
	const char	*regexp = "(key REGEXP ? AND bits & ?)";
	const char	*andarch = "arch = ? AND ";
	const char	*andsec = "sec = ? AND ";
	size_t	 	 substrsz;
	size_t	 	 regexpsz;
d477 1
d479 1
a479 5
	sql = mandoc_strdup
		("SELECT pageid,bits,key,file,desc,form,sec,arch "
		 "FROM keys "
		 "INNER JOIN mpages ON mpages.id=keys.pageid "
		 "WHERE ");
a480 8
	substrsz = strlen(substr);
	regexpsz = strlen(regexp);

	if (NULL != arch) {
		sz += strlen(andarch) + 1;
		sql = mandoc_realloc(sql, sz);
		strlcat(sql, andarch, sz);
	}
d482 21
a502 16
	if (NULL != sec) {
		sz += strlen(andsec) + 1;
		sql = mandoc_realloc(sql, sz);
		strlcat(sql, andsec, sz);
	}

	sz += 2;
	sql = mandoc_realloc(sql, sz);
	strlcat(sql, "(", sz);

	for ( ; NULL != e; e = e->next) {
		sz += (NULL == e->substr ? regexpsz : substrsz) + 
			(NULL == e->next ? 3 : 5);
		sql = mandoc_realloc(sql, sz);
		strlcat(sql, NULL == e->substr ? regexp : substr, sz);
		strlcat(sql, NULL == e->next ? ");" : " OR ", sz);
d504 1
d517 1
a517 1
	int		 i, cs;
d521 1
d524 28
a551 10
		if (0 == strcmp("-i", argv[i])) {
			if (++i >= argc)
				return(NULL);
			cs = 0;
		} else
			cs = 1;
		next = exprterm(search, argv[i], cs);
		if (NULL == next) {
			exprfree(first);
			return(NULL);
d553 5
d563 1
d565 6
a570 2

	return(first);
@


1.2
log
@Split buildnames() out of mansearch(); the latter function is getting
too long and unwieldy, but will grow more code soon.  No functional change.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.1 2013/12/31 00:40:19 schwarze Exp $ */
d117 2
d135 3
a137 2
		const struct manpaths *paths, 
		int argc, char *argv[], 
d140 1
a140 1
	int		 fd, rc, c;
d142 1
d148 1
a148 1
	sqlite3_stmt	*s;
d174 10
d300 6
d323 2
d332 1
d381 35
@


1.1
log
@Replace the Berkeley-DB based mandocdb(8) by an SQLite3-based version,
aiming for more flexible development and optimization options.
Kristaps started this during the summer 2012, i did some very heavy
bugfixing during t2k13 and finally, during the last few days,
got it to a state where it is ripe for in-tree development.
Beware, neither the user interfaces nor the database formats
are expected to be stable just yet.

Will not be installed or activated until further discussion.
No functional change to mandoc(1).

"As long as it remains off until we decide the cost, fine." deraadt@@
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.10 2013/12/27 18:51:25 schwarze Exp $ */
d116 1
d140 1
a140 2
	char		*sql, *newnames;
	const char	*oldnames, *sep1, *name, *sec, *sep2, *arch;
a299 1
			mpage->names = NULL;
d302 1
a302 27

			j = 1;
			SQL_BIND_INT64(db, s, j, mp->id);
			while (SQLITE_ROW == (c = sqlite3_step(s))) {
				if (NULL == mpage->names) {
					oldnames = "";
					sep1 = "";
				} else {
					oldnames = mpage->names;
					sep1 = ", ";
				}
				sec = sqlite3_column_text(s, 1);
				arch = sqlite3_column_text(s, 2);
				name = sqlite3_column_text(s, 3);
				sep2 = '\0' == *arch ? "" : "/";
				if (-1 == asprintf(&newnames,
				    "%s%s%s(%s%s%s)", oldnames, sep1,
				    name, sec, sep2, arch)) {
					perror(0);
					exit((int)MANDOCLEVEL_SYSERR);
				}
				free(mpage->names);
				mpage->names = newnames;
			}
			if (SQLITE_DONE != c)
				fprintf(stderr, "%s\n", sqlite3_errmsg(db));
			sqlite3_reset(s);
d321 37
@

