head	1.90;
access;
symbols
	OPENBSD_6_2_BASE:1.90
	OPENBSD_6_1:1.80.0.4
	OPENBSD_6_1_BASE:1.80
	OPENBSD_6_0:1.62.0.4
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.62.0.2
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.56.0.4
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.30.0.6
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.4
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.2
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.2
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.90
date	2017.09.06.16.24.11;	author schwarze;	state Exp;
branches;
next	1.89;
commitid	INfpebtx0uXNbSPP;

1.89
date	2017.07.15.17.57.46;	author schwarze;	state Exp;
branches;
next	1.88;
commitid	pVQs3ry0qLj0qWQi;

1.88
date	2017.07.14.16.28.35;	author schwarze;	state Exp;
branches;
next	1.87;
commitid	mrXxy7r1ITGCaIEE;

1.87
date	2017.07.14.16.05.52;	author schwarze;	state Exp;
branches;
next	1.86;
commitid	BXXuHFAlziWIFxdV;

1.86
date	2017.07.14.15.26.14;	author bentley;	state Exp;
branches;
next	1.85;
commitid	fNCQhqgD9cwkWhHd;

1.85
date	2017.06.23.02.31.39;	author schwarze;	state Exp;
branches;
next	1.84;
commitid	5Ey5XxywubUI8LwI;

1.84
date	2017.06.14.01.31.19;	author schwarze;	state Exp;
branches;
next	1.83;
commitid	PPUZg39EU736tntb;

1.83
date	2017.06.08.12.54.40;	author schwarze;	state Exp;
branches;
next	1.82;
commitid	XZ3BGDIHuY6bbJk8;

1.82
date	2017.05.14.12.26.59;	author schwarze;	state Exp;
branches;
next	1.81;
commitid	niRClZsEdgK3r7nE;

1.81
date	2017.05.12.17.56.39;	author schwarze;	state Exp;
branches;
next	1.80;
commitid	2jQy7OGiwTB74dOa;

1.80
date	2017.03.15.11.29.50;	author schwarze;	state Exp;
branches;
next	1.79;
commitid	0AJYQsnYnWohs8XM;

1.79
date	2017.03.14.01.34.57;	author schwarze;	state Exp;
branches;
next	1.78;
commitid	ki0xXqZ5DvGDd2YD;

1.78
date	2017.03.13.19.01.14;	author schwarze;	state Exp;
branches;
next	1.77;
commitid	HxogisTBPpNML57P;

1.77
date	2017.02.05.20.21.17;	author schwarze;	state Exp;
branches;
next	1.76;
commitid	k3leX1WuwjRY1lpC;

1.76
date	2017.02.05.19.29.03;	author schwarze;	state Exp;
branches;
next	1.75;
commitid	b6Pprk9VRxuYIyVr;

1.75
date	2017.02.05.18.13.28;	author schwarze;	state Exp;
branches;
next	1.74;
commitid	LLN2XeSKb4BTOEt6;

1.74
date	2017.01.29.14.02.19;	author schwarze;	state Exp;
branches;
next	1.73;
commitid	kwoDToz7gzAquXDa;

1.73
date	2017.01.28.22.36.17;	author schwarze;	state Exp;
branches;
next	1.72;
commitid	468TGMIlZyF2dLh1;

1.72
date	2017.01.26.18.28.04;	author schwarze;	state Exp;
branches;
next	1.71;
commitid	Yxdf4tUMRu7gtmiH;

1.71
date	2017.01.25.02.14.41;	author schwarze;	state Exp;
branches;
next	1.70;
commitid	t5qXBiFCvZnIxlr1;

1.70
date	2017.01.21.02.28.42;	author schwarze;	state Exp;
branches;
next	1.69;
commitid	RbNw6eFHohuBAfiW;

1.69
date	2017.01.19.16.56.53;	author schwarze;	state Exp;
branches;
next	1.68;
commitid	jvwd5JdpRKFkEWTt;

1.68
date	2017.01.19.15.27.26;	author schwarze;	state Exp;
branches;
next	1.67;
commitid	t4IwDKuwDsVdECRx;

1.67
date	2017.01.19.01.00.11;	author schwarze;	state Exp;
branches;
next	1.66;
commitid	JaaPsBMnLuMI8auG;

1.66
date	2017.01.18.19.22.18;	author schwarze;	state Exp;
branches;
next	1.65;
commitid	rkOTHV44amzifb9Y;

1.65
date	2017.01.17.15.32.39;	author schwarze;	state Exp;
branches;
next	1.64;
commitid	bt3XYYmdm9H0zf44;

1.64
date	2017.01.17.01.47.46;	author schwarze;	state Exp;
branches;
next	1.63;
commitid	Nv06v3QGWa6dYYKr;

1.63
date	2017.01.08.16.38.04;	author schwarze;	state Exp;
branches;
next	1.62;
commitid	NLj1SUtSMCCFT7wB;

1.62
date	2015.12.25.20.43.04;	author bentley;	state Exp;
branches;
next	1.61;
commitid	oXOV1HleA5uLxibU;

1.61
date	2015.10.13.22.57.49;	author schwarze;	state Exp;
branches;
next	1.60;
commitid	jXIG8UzKLXm2Z9i6;

1.60
date	2015.10.12.00.14.41;	author schwarze;	state Exp;
branches;
next	1.59;
commitid	1Kuv8x0k6YsKeLg2;

1.59
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.58;
commitid	Ql2ha5NS80pwfGNT;

1.58
date	2015.10.06.18.30.43;	author schwarze;	state Exp;
branches;
next	1.57;
commitid	hxQV8O1pNUaef4ir;

1.57
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.56;
commitid	191tWtskbsgcpQqV;

1.56
date	2015.03.27.21.17.16;	author schwarze;	state Exp;
branches;
next	1.55;
commitid	r1NPkDobCJs0RcWM;

1.55
date	2015.01.21.20.20.49;	author schwarze;	state Exp;
branches;
next	1.54;
commitid	oPCJQka1zVKJ04b2;

1.54
date	2014.12.20.00.19.54;	author schwarze;	state Exp;
branches;
next	1.53;
commitid	znKWh4B5a5dEJcoZ;

1.53
date	2014.12.02.10.07.17;	author schwarze;	state Exp;
branches;
next	1.52;
commitid	G1dK13T4nePhhgx3;

1.52
date	2014.12.01.04.32.34;	author schwarze;	state Exp;
branches;
next	1.51;
commitid	7PyfuXUFPggwJZ4C;

1.51
date	2014.10.29.00.17.01;	author schwarze;	state Exp;
branches;
next	1.50;
commitid	DT3doJsSOKw5l7CZ;

1.50
date	2014.10.28.17.35.42;	author schwarze;	state Exp;
branches;
next	1.49;
commitid	pNwmOla3ZQwLgu2f;

1.49
date	2014.10.27.16.28.30;	author schwarze;	state Exp;
branches;
next	1.48;
commitid	lfSva9GS8a53mUmG;

1.48
date	2014.10.27.13.29.30;	author schwarze;	state Exp;
branches;
next	1.47;
commitid	rqEyu52UjJCimBJX;

1.47
date	2014.10.26.17.11.18;	author schwarze;	state Exp;
branches;
next	1.46;
commitid	d5isKf7CwbLlT0IO;

1.46
date	2014.10.13.21.05.59;	author chl;	state Exp;
branches;
next	1.45;
commitid	fJm0qpZP8XFQmz67;

1.45
date	2014.10.10.15.25.06;	author schwarze;	state Exp;
branches;
next	1.44;
commitid	MpqXOG3dhTX11YQI;

1.44
date	2014.10.09.15.59.08;	author schwarze;	state Exp;
branches;
next	1.43;
commitid	Wy6YFSKH1ddfqJiG;

1.43
date	2014.10.09.15.49.09;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	iJNkkDSk2T9uwIBd;

1.42
date	2014.10.07.18.17.05;	author schwarze;	state Exp;
branches;
next	1.41;
commitid	ovhOTvwzuIxZwsAn;

1.41
date	2014.08.14.00.29.12;	author schwarze;	state Exp;
branches;
next	1.40;
commitid	uJL3CbZ4GrgMUhuu;

1.40
date	2014.08.13.22.09.28;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	HYRKgiWZb4BQrCNL;

1.39
date	2014.08.13.15.19.24;	author schwarze;	state Exp;
branches;
next	1.38;
commitid	BUSBmHGCSGSyXokp;

1.38
date	2014.07.23.15.00.00;	author schwarze;	state Exp;
branches;
next	1.37;
commitid	SvLJOe7wZSQdJYIG;

1.37
date	2014.07.22.22.41.29;	author schwarze;	state Exp;
branches;
next	1.36;
commitid	rbzDsyd6BpU0zoj9;

1.36
date	2014.04.23.16.07.06;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2014.01.22.20.58.35;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2014.01.05.21.21.08;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2013.08.08.20.07.24;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2012.05.28.13.00.51;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2011.10.09.17.59.56;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.08.17.47.54;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2011.07.05.04.12.41;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2011.01.30.16.05.29;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2011.01.16.19.41.16;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2010.12.27.21.44.30;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2010.12.25.13.23.03;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.22.00.33.25;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.19.09.22.35;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.01.21.38.26;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.27.21.25.28;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2010.08.20.00.53.35;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2010.07.31.21.43.07;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2010.07.13.01.09.12;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.27.20.28.56;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.08.00.11.47;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.26.02.39.58;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.14.01.54.37;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.07.23.15.05;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.18.02.11.25;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.24.02.08.14;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.23.22.30.17;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.10.21.19.13.50;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.90
log
@fix a NULL pointer access on deroff() failure;
could be triggered with '.SS ""';
reported by Michael <Stapelberg at debian>
@
text
@/*	$OpenBSD: html.c,v 1.89 2017/07/15 17:57:46 schwarze Exp $ */
/*
 * Copyright (c) 2008-2011, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011-2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "out.h"
#include "html.h"
#include "manconf.h"
#include "main.h"

struct	htmldata {
	const char	 *name;
	int		  flags;
#define	HTML_NOSTACK	 (1 << 0)
#define	HTML_AUTOCLOSE	 (1 << 1)
#define	HTML_NLBEFORE	 (1 << 2)
#define	HTML_NLBEGIN	 (1 << 3)
#define	HTML_NLEND	 (1 << 4)
#define	HTML_NLAFTER	 (1 << 5)
#define	HTML_NLAROUND	 (HTML_NLBEFORE | HTML_NLAFTER)
#define	HTML_NLINSIDE	 (HTML_NLBEGIN | HTML_NLEND)
#define	HTML_NLALL	 (HTML_NLAROUND | HTML_NLINSIDE)
#define	HTML_INDENT	 (1 << 6)
#define	HTML_NOINDENT	 (1 << 7)
};

static	const struct htmldata htmltags[TAG_MAX] = {
	{"html",	HTML_NLALL},
	{"head",	HTML_NLALL | HTML_INDENT},
	{"body",	HTML_NLALL},
	{"meta",	HTML_NOSTACK | HTML_AUTOCLOSE | HTML_NLALL},
	{"title",	HTML_NLAROUND},
	{"div",		HTML_NLAROUND},
	{"h1",		HTML_NLAROUND},
	{"h2",		HTML_NLAROUND},
	{"span",	0},
	{"link",	HTML_NOSTACK | HTML_AUTOCLOSE | HTML_NLALL},
	{"br",		HTML_NOSTACK | HTML_AUTOCLOSE | HTML_NLALL},
	{"a",		0},
	{"table",	HTML_NLALL | HTML_INDENT},
	{"colgroup",	HTML_NLALL | HTML_INDENT},
	{"col",		HTML_NOSTACK | HTML_AUTOCLOSE | HTML_NLALL},
	{"tr",		HTML_NLALL | HTML_INDENT},
	{"td",		HTML_NLAROUND},
	{"li",		HTML_NLAROUND | HTML_INDENT},
	{"ul",		HTML_NLALL | HTML_INDENT},
	{"ol",		HTML_NLALL | HTML_INDENT},
	{"dl",		HTML_NLALL | HTML_INDENT},
	{"dt",		HTML_NLAROUND},
	{"dd",		HTML_NLAROUND | HTML_INDENT},
	{"pre",		HTML_NLALL | HTML_NOINDENT},
	{"var",		0},
	{"cite",	0},
	{"b",		0},
	{"i",		0},
	{"code",	0},
	{"small",	0},
	{"style",	HTML_NLALL | HTML_INDENT},
	{"math",	HTML_NLALL | HTML_INDENT},
	{"mrow",	0},
	{"mi",		0},
	{"mn",		0},
	{"mo",		0},
	{"msup",	0},
	{"msub",	0},
	{"msubsup",	0},
	{"mfrac",	0},
	{"msqrt",	0},
	{"mfenced",	0},
	{"mtable",	0},
	{"mtr",		0},
	{"mtd",		0},
	{"munderover",	0},
	{"munder",	0},
	{"mover",	0},
};

static	const char	*const roffscales[SCALE_MAX] = {
	"cm", /* SCALE_CM */
	"in", /* SCALE_IN */
	"pc", /* SCALE_PC */
	"pt", /* SCALE_PT */
	"em", /* SCALE_EM */
	"em", /* SCALE_MM */
	"ex", /* SCALE_EN */
	"ex", /* SCALE_BU */
	"em", /* SCALE_VS */
	"ex", /* SCALE_FS */
};

static	void	 a2width(const char *, struct roffsu *);
static	void	 print_byte(struct html *, char);
static	void	 print_endword(struct html *);
static	void	 print_indent(struct html *);
static	void	 print_word(struct html *, const char *);

static	void	 print_ctag(struct html *, struct tag *);
static	int	 print_escape(struct html *, char);
static	int	 print_encode(struct html *, const char *, const char *, int);
static	void	 print_href(struct html *, const char *, const char *, int);
static	void	 print_metaf(struct html *, enum mandoc_esc);


void *
html_alloc(const struct manoutput *outopts)
{
	struct html	*h;

	h = mandoc_calloc(1, sizeof(struct html));

	h->tag = NULL;
	h->style = outopts->style;
	h->base_man = outopts->man;
	h->base_includes = outopts->includes;
	if (outopts->fragment)
		h->oflags |= HTML_FRAGMENT;

	return h;
}

void
html_free(void *p)
{
	struct tag	*tag;
	struct html	*h;

	h = (struct html *)p;

	while ((tag = h->tag) != NULL) {
		h->tag = tag->next;
		free(tag);
	}

	free(h);
}

void
print_gen_head(struct html *h)
{
	struct tag	*t;

	print_otag(h, TAG_META, "?", "charset", "utf-8");

	/*
	 * Print a default style-sheet.
	 */

	t = print_otag(h, TAG_STYLE, "");
	print_text(h, "table.head, table.foot { width: 100%; }");
	print_endline(h);
	print_text(h, "td.head-rtitle, td.foot-os { text-align: right; }");
	print_endline(h);
	print_text(h, "td.head-vol { text-align: center; }");
	print_endline(h);
	print_text(h, "div.Pp { margin: 1ex 0ex; }");
	print_tagq(h, t);

	if (h->style)
		print_otag(h, TAG_LINK, "?h??", "rel", "stylesheet",
		    h->style, "type", "text/css", "media", "all");
}

static void
print_metaf(struct html *h, enum mandoc_esc deco)
{
	enum htmlfont	 font;

	switch (deco) {
	case ESCAPE_FONTPREV:
		font = h->metal;
		break;
	case ESCAPE_FONTITALIC:
		font = HTMLFONT_ITALIC;
		break;
	case ESCAPE_FONTBOLD:
		font = HTMLFONT_BOLD;
		break;
	case ESCAPE_FONTBI:
		font = HTMLFONT_BI;
		break;
	case ESCAPE_FONT:
	case ESCAPE_FONTROMAN:
		font = HTMLFONT_NONE;
		break;
	default:
		abort();
	}

	if (h->metaf) {
		print_tagq(h, h->metaf);
		h->metaf = NULL;
	}

	h->metal = h->metac;
	h->metac = font;

	switch (font) {
	case HTMLFONT_ITALIC:
		h->metaf = print_otag(h, TAG_I, "");
		break;
	case HTMLFONT_BOLD:
		h->metaf = print_otag(h, TAG_B, "");
		break;
	case HTMLFONT_BI:
		h->metaf = print_otag(h, TAG_B, "");
		print_otag(h, TAG_I, "");
		break;
	default:
		break;
	}
}

char *
html_make_id(const struct roff_node *n)
{
	const struct roff_node	*nch;
	char			*buf, *cp;

	for (nch = n->child; nch != NULL; nch = nch->next)
		if (nch->type != ROFFT_TEXT)
			return NULL;

	buf = NULL;
	deroff(&buf, n);
	if (buf == NULL)
		return NULL;

	/* http://www.w3.org/TR/html5/dom.html#the-id-attribute */

	for (cp = buf; *cp != '\0'; cp++)
		if (*cp == ' ')
			*cp = '_';

	return buf;
}

int
html_strlen(const char *cp)
{
	size_t		 rsz;
	int		 skip, sz;

	/*
	 * Account for escaped sequences within string length
	 * calculations.  This follows the logic in term_strlen() as we
	 * must calculate the width of produced strings.
	 * Assume that characters are always width of "1".  This is
	 * hacky, but it gets the job done for approximation of widths.
	 */

	sz = 0;
	skip = 0;
	while (1) {
		rsz = strcspn(cp, "\\");
		if (rsz) {
			cp += rsz;
			if (skip) {
				skip = 0;
				rsz--;
			}
			sz += rsz;
		}
		if ('\0' == *cp)
			break;
		cp++;
		switch (mandoc_escape(&cp, NULL, NULL)) {
		case ESCAPE_ERROR:
			return sz;
		case ESCAPE_UNICODE:
		case ESCAPE_NUMBERED:
		case ESCAPE_SPECIAL:
		case ESCAPE_OVERSTRIKE:
			if (skip)
				skip = 0;
			else
				sz++;
			break;
		case ESCAPE_SKIPCHAR:
			skip = 1;
			break;
		default:
			break;
		}
	}
	return sz;
}

static int
print_escape(struct html *h, char c)
{

	switch (c) {
	case '<':
		print_word(h, "&lt;");
		break;
	case '>':
		print_word(h, "&gt;");
		break;
	case '&':
		print_word(h, "&amp;");
		break;
	case '"':
		print_word(h, "&quot;");
		break;
	case ASCII_NBRSP:
		print_word(h, "&nbsp;");
		break;
	case ASCII_HYPH:
		print_byte(h, '-');
		break;
	case ASCII_BREAK:
		break;
	default:
		return 0;
	}
	return 1;
}

static int
print_encode(struct html *h, const char *p, const char *pend, int norecurse)
{
	char		 numbuf[16];
	struct tag	*t;
	const char	*seq;
	size_t		 sz;
	int		 c, len, breakline, nospace;
	enum mandoc_esc	 esc;
	static const char rejs[10] = { ' ', '\\', '<', '>', '&', '"',
		ASCII_NBRSP, ASCII_HYPH, ASCII_BREAK, '\0' };

	if (pend == NULL)
		pend = strchr(p, '\0');

	breakline = 0;
	nospace = 0;

	while (p < pend) {
		if (HTML_SKIPCHAR & h->flags && '\\' != *p) {
			h->flags &= ~HTML_SKIPCHAR;
			p++;
			continue;
		}

		for (sz = strcspn(p, rejs); sz-- && p < pend; p++)
			print_byte(h, *p);

		if (breakline &&
		    (p >= pend || *p == ' ' || *p == ASCII_NBRSP)) {
			t = print_otag(h, TAG_DIV, "");
			print_text(h, "\\~");
			print_tagq(h, t);
			breakline = 0;
			while (p < pend && (*p == ' ' || *p == ASCII_NBRSP))
				p++;
			continue;
		}

		if (p >= pend)
			break;

		if (*p == ' ') {
			print_endword(h);
			p++;
			continue;
		}

		if (print_escape(h, *p++))
			continue;

		esc = mandoc_escape(&p, &seq, &len);
		if (ESCAPE_ERROR == esc)
			break;

		switch (esc) {
		case ESCAPE_FONT:
		case ESCAPE_FONTPREV:
		case ESCAPE_FONTBOLD:
		case ESCAPE_FONTITALIC:
		case ESCAPE_FONTBI:
		case ESCAPE_FONTROMAN:
			if (0 == norecurse)
				print_metaf(h, esc);
			continue;
		case ESCAPE_SKIPCHAR:
			h->flags |= HTML_SKIPCHAR;
			continue;
		default:
			break;
		}

		if (h->flags & HTML_SKIPCHAR) {
			h->flags &= ~HTML_SKIPCHAR;
			continue;
		}

		switch (esc) {
		case ESCAPE_UNICODE:
			/* Skip past "u" header. */
			c = mchars_num2uc(seq + 1, len - 1);
			break;
		case ESCAPE_NUMBERED:
			c = mchars_num2char(seq, len);
			if (c < 0)
				continue;
			break;
		case ESCAPE_SPECIAL:
			c = mchars_spec2cp(seq, len);
			if (c <= 0)
				continue;
			break;
		case ESCAPE_BREAK:
			breakline = 1;
			continue;
		case ESCAPE_NOSPACE:
			if ('\0' == *p)
				nospace = 1;
			continue;
		case ESCAPE_OVERSTRIKE:
			if (len == 0)
				continue;
			c = seq[len - 1];
			break;
		default:
			continue;
		}
		if ((c < 0x20 && c != 0x09) ||
		    (c > 0x7E && c < 0xA0))
			c = 0xFFFD;
		if (c > 0x7E) {
			(void)snprintf(numbuf, sizeof(numbuf), "&#x%.4X;", c);
			print_word(h, numbuf);
		} else if (print_escape(h, c) == 0)
			print_byte(h, c);
	}

	return nospace;
}

static void
print_href(struct html *h, const char *name, const char *sec, int man)
{
	const char	*p, *pp;

	pp = man ? h->base_man : h->base_includes;
	while ((p = strchr(pp, '%')) != NULL) {
		print_encode(h, pp, p, 1);
		if (man && p[1] == 'S') {
			if (sec == NULL)
				print_byte(h, '1');
			else
				print_encode(h, sec, NULL, 1);
		} else if ((man && p[1] == 'N') ||
		    (man == 0 && p[1] == 'I'))
			print_encode(h, name, NULL, 1);
		else
			print_encode(h, p, p + 2, 1);
		pp = p + 2;
	}
	if (*pp != '\0')
		print_encode(h, pp, NULL, 1);
}

struct tag *
print_otag(struct html *h, enum htmltag tag, const char *fmt, ...)
{
	va_list		 ap;
	struct roffsu	 mysu, *su;
	char		 numbuf[16];
	struct tag	*t;
	const char	*attr;
	char		*arg1, *arg2;
	double		 v;
	int		 i, have_style, tflags;

	tflags = htmltags[tag].flags;

	/* Push this tag onto the stack of open scopes. */

	if ((tflags & HTML_NOSTACK) == 0) {
		t = mandoc_malloc(sizeof(struct tag));
		t->tag = tag;
		t->next = h->tag;
		h->tag = t;
	} else
		t = NULL;

	if (tflags & HTML_NLBEFORE)
		print_endline(h);
	if (h->col == 0)
		print_indent(h);
	else if ((h->flags & HTML_NOSPACE) == 0) {
		if (h->flags & HTML_KEEP)
			print_word(h, "&#x00A0;");
		else {
			if (h->flags & HTML_PREKEEP)
				h->flags |= HTML_KEEP;
			print_endword(h);
		}
	}

	if ( ! (h->flags & HTML_NONOSPACE))
		h->flags &= ~HTML_NOSPACE;
	else
		h->flags |= HTML_NOSPACE;

	/* Print out the tag name and attributes. */

	print_byte(h, '<');
	print_word(h, htmltags[tag].name);

	va_start(ap, fmt);

	have_style = 0;
	while (*fmt != '\0') {
		if (*fmt == 's') {
			have_style = 1;
			fmt++;
			break;
		}

		/* Parse a non-style attribute and its arguments. */

		arg1 = va_arg(ap, char *);
		switch (*fmt++) {
		case 'c':
			attr = "class";
			break;
		case 'h':
			attr = "href";
			break;
		case 'i':
			attr = "id";
			break;
		case '?':
			attr = arg1;
			arg1 = va_arg(ap, char *);
			break;
		default:
			abort();
		}
		arg2 = NULL;
		if (*fmt == 'M')
			arg2 = va_arg(ap, char *);
		if (arg1 == NULL)
			continue;

		/* Print the non-style attributes. */

		print_byte(h, ' ');
		print_word(h, attr);
		print_byte(h, '=');
		print_byte(h, '"');
		switch (*fmt) {
		case 'I':
			print_href(h, arg1, NULL, 0);
			fmt++;
			break;
		case 'M':
			print_href(h, arg1, arg2, 1);
			fmt++;
			break;
		case 'R':
			print_byte(h, '#');
			print_encode(h, arg1, NULL, 1);
			fmt++;
			break;
		case 'T':
			print_encode(h, arg1, NULL, 1);
			print_word(h, "\" title=\"");
			print_encode(h, arg1, NULL, 1);
			fmt++;
			break;
		default:
			print_encode(h, arg1, NULL, 1);
			break;
		}
		print_byte(h, '"');
	}

	/* Print out styles. */

	while (*fmt != '\0') {
		arg1 = NULL;
		su = NULL;

		/* First letter: input argument type. */

		switch (*fmt++) {
		case 'h':
			i = va_arg(ap, int);
			su = &mysu;
			SCALE_HS_INIT(su, i);
			break;
		case 's':
			arg1 = va_arg(ap, char *);
			break;
		case 'u':
			su = va_arg(ap, struct roffsu *);
			break;
		case 'w':
			if ((arg2 = va_arg(ap, char *)) != NULL) {
				su = &mysu;
				a2width(arg2, su);
			}
			if (*fmt == '*') {
				if (su != NULL && su->unit == SCALE_EN &&
				    su->scale > 5.9 && su->scale < 6.1)
					su = NULL;
				fmt++;
			}
			if (*fmt == '+') {
				if (su != NULL) {
					/* Make even bold text fit. */
					su->scale *= 1.2;
					/* Add padding. */
					su->scale += 3.0;
				}
				fmt++;
			}
			if (*fmt == '-') {
				if (su != NULL)
					su->scale *= -1.0;
				fmt++;
			}
			break;
		default:
			abort();
		}

		/* Second letter: style name. */

		switch (*fmt++) {
		case 'h':
			attr = "height";
			break;
		case 'i':
			attr = "text-indent";
			break;
		case 'l':
			attr = "margin-left";
			break;
		case 'w':
			attr = "width";
			break;
		case 'W':
			attr = "min-width";
			break;
		case '?':
			attr = arg1;
			arg1 = va_arg(ap, char *);
			break;
		default:
			abort();
		}
		if (su == NULL && arg1 == NULL)
			continue;

		if (have_style == 1)
			print_word(h, " style=\"");
		else
			print_byte(h, ' ');
		print_word(h, attr);
		print_byte(h, ':');
		print_byte(h, ' ');
		if (su != NULL) {
			v = su->scale;
			if (su->unit == SCALE_MM && (v /= 100.0) == 0.0)
				v = 1.0;
			else if (su->unit == SCALE_BU)
				v /= 24.0;
			(void)snprintf(numbuf, sizeof(numbuf), "%.2f", v);
			print_word(h, numbuf);
			print_word(h, roffscales[su->unit]);
		} else
			print_word(h, arg1);
		print_byte(h, ';');
		have_style = 2;
	}
	if (have_style == 2)
		print_byte(h, '"');

	va_end(ap);

	/* Accommodate for "well-formed" singleton escaping. */

	if (HTML_AUTOCLOSE & htmltags[tag].flags)
		print_byte(h, '/');

	print_byte(h, '>');

	if (tflags & HTML_NLBEGIN)
		print_endline(h);
	else
		h->flags |= HTML_NOSPACE;

	if (tflags & HTML_INDENT)
		h->indent++;
	if (tflags & HTML_NOINDENT)
		h->noindent++;

	return t;
}

static void
print_ctag(struct html *h, struct tag *tag)
{
	int	 tflags;

	/*
	 * Remember to close out and nullify the current
	 * meta-font and table, if applicable.
	 */
	if (tag == h->metaf)
		h->metaf = NULL;
	if (tag == h->tblt)
		h->tblt = NULL;

	tflags = htmltags[tag->tag].flags;

	if (tflags & HTML_INDENT)
		h->indent--;
	if (tflags & HTML_NOINDENT)
		h->noindent--;
	if (tflags & HTML_NLEND)
		print_endline(h);
	print_indent(h);
	print_byte(h, '<');
	print_byte(h, '/');
	print_word(h, htmltags[tag->tag].name);
	print_byte(h, '>');
	if (tflags & HTML_NLAFTER)
		print_endline(h);

	h->tag = tag->next;
	free(tag);
}

void
print_gen_decls(struct html *h)
{
	print_word(h, "<!DOCTYPE html>");
	print_endline(h);
}

void
print_text(struct html *h, const char *word)
{
	if (h->col && (h->flags & HTML_NOSPACE) == 0) {
		if ( ! (HTML_KEEP & h->flags)) {
			if (HTML_PREKEEP & h->flags)
				h->flags |= HTML_KEEP;
			print_endword(h);
		} else
			print_word(h, "&#x00A0;");
	}

	assert(NULL == h->metaf);
	switch (h->metac) {
	case HTMLFONT_ITALIC:
		h->metaf = print_otag(h, TAG_I, "");
		break;
	case HTMLFONT_BOLD:
		h->metaf = print_otag(h, TAG_B, "");
		break;
	case HTMLFONT_BI:
		h->metaf = print_otag(h, TAG_B, "");
		print_otag(h, TAG_I, "");
		break;
	default:
		print_indent(h);
		break;
	}

	assert(word);
	if ( ! print_encode(h, word, NULL, 0)) {
		if ( ! (h->flags & HTML_NONOSPACE))
			h->flags &= ~HTML_NOSPACE;
		h->flags &= ~HTML_NONEWLINE;
	} else
		h->flags |= HTML_NOSPACE | HTML_NONEWLINE;

	if (h->metaf) {
		print_tagq(h, h->metaf);
		h->metaf = NULL;
	}

	h->flags &= ~HTML_IGNDELIM;
}

void
print_tagq(struct html *h, const struct tag *until)
{
	struct tag	*tag;

	while ((tag = h->tag) != NULL) {
		print_ctag(h, tag);
		if (until && tag == until)
			return;
	}
}

void
print_stagq(struct html *h, const struct tag *suntil)
{
	struct tag	*tag;

	while ((tag = h->tag) != NULL) {
		if (suntil && tag == suntil)
			return;
		print_ctag(h, tag);
	}
}

void
print_paragraph(struct html *h)
{
	struct tag	*t;

	t = print_otag(h, TAG_DIV, "c", "Pp");
	print_tagq(h, t);
}


/***********************************************************************
 * Low level output functions.
 * They implement line breaking using a short static buffer.
 ***********************************************************************/

/*
 * Buffer one HTML output byte.
 * If the buffer is full, flush and deactivate it and start a new line.
 * If the buffer is inactive, print directly.
 */
static void
print_byte(struct html *h, char c)
{
	if ((h->flags & HTML_BUFFER) == 0) {
		putchar(c);
		h->col++;
		return;
	}

	if (h->col + h->bufcol < sizeof(h->buf)) {
		h->buf[h->bufcol++] = c;
		return;
	}

	putchar('\n');
	h->col = 0;
	print_indent(h);
	putchar(' ');
	putchar(' ');
	fwrite(h->buf, h->bufcol, 1, stdout);
	putchar(c);
	h->col = (h->indent + 1) * 2 + h->bufcol + 1;
	h->bufcol = 0;
	h->flags &= ~HTML_BUFFER;
}

/*
 * If something was printed on the current output line, end it.
 * Not to be called right after print_indent().
 */
void
print_endline(struct html *h)
{
	if (h->col == 0)
		return;

	if (h->bufcol) {
		putchar(' ');
		fwrite(h->buf, h->bufcol, 1, stdout);
		h->bufcol = 0;
	}
	putchar('\n');
	h->col = 0;
	h->flags |= HTML_NOSPACE;
	h->flags &= ~HTML_BUFFER;
}

/*
 * Flush the HTML output buffer.
 * If it is inactive, activate it.
 */
static void
print_endword(struct html *h)
{
	if (h->noindent) {
		print_byte(h, ' ');
		return;
	}

	if ((h->flags & HTML_BUFFER) == 0) {
		h->col++;
		h->flags |= HTML_BUFFER;
	} else if (h->bufcol) {
		putchar(' ');
		fwrite(h->buf, h->bufcol, 1, stdout);
		h->col += h->bufcol + 1;
	}
	h->bufcol = 0;
}

/*
 * If at the beginning of a new output line,
 * perform indentation and mark the line as containing output.
 * Make sure to really produce some output right afterwards,
 * but do not use print_otag() for producing it.
 */
static void
print_indent(struct html *h)
{
	size_t	 i;

	if (h->col)
		return;

	if (h->noindent == 0) {
		h->col = h->indent * 2;
		for (i = 0; i < h->col; i++)
			putchar(' ');
	}
	h->flags &= ~HTML_NOSPACE;
}

/*
 * Print or buffer some characters
 * depending on the current HTML output buffer state.
 */
static void
print_word(struct html *h, const char *cp)
{
	while (*cp != '\0')
		print_byte(h, *cp++);
}

/*
 * Calculate the scaling unit passed in a `-width' argument.  This uses
 * either a native scaling unit (e.g., 1i, 2m) or the string length of
 * the value.
 */
static void
a2width(const char *p, struct roffsu *su)
{
	const char	*end;

	end = a2roffsu(p, su, SCALE_MAX);
	if (end == NULL || *end != '\0') {
		su->unit = SCALE_EN;
		su->scale = html_strlen(p);
	} else if (su->scale < 0.0)
		su->scale = 0.0;
}
@


1.89
log
@In .Bl -tag and -hang, do not print a margin-left style attribute
for each individual item if the -width argument matches the default
of 6n.  Suggested by Steffen Nurpmeso <steffen at sdaoden dot eu>
on <groff at GNU dot org> in April 2017.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.88 2017/07/14 16:28:35 schwarze Exp $ */
d251 2
@


1.88
log
@Fix an assertion failure triggered by print_otag("sw+-l", NULL).
Even though we skip the style when the argument is NULL,
we must still consume the options.
Not found with afl(1), but during manual testing of the previous patch...
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.87 2017/07/14 16:05:52 schwarze Exp $ */
d625 9
a633 6
			if ((arg2 = va_arg(ap, char *)) == NULL) {
				if (*fmt == '+')
					fmt++;
				if (*fmt == '-')
					fmt++;
				break;
a634 2
			su = &mysu;
			a2width(arg2, su);
d636 6
a641 4
				/* Increase to make even bold text fit. */
				su->scale *= 1.2;
				/* Add padding. */
				su->scale += 3.0;
d645 2
a646 1
				su->scale *= -1.0;
@


1.87
log
@Handle .Bl -compact via CSS rather than writing individual style
attributes into .It blocks; suggested by Steffen Nurpmeso <steffen
at sdaoden dot eu> on <groff at GNU dot org> in April 2017.

Delete margin-bottom and margin-top style names and the 'v' argument
letter from print_otag() because they are no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.86 2017/07/14 15:26:14 bentley Exp $ */
d625 5
a629 1
			if ((arg2 = va_arg(ap, char *)) == NULL)
d631 1
@


1.86
log
@Print HTML character references as 4+ digits hexadecimal, like Unicode.

tweaks + ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.85 2017/06/23 02:31:39 schwarze Exp $ */
a623 5
		case 'v':
			i = va_arg(ap, int);
			su = &mysu;
			SCALE_VS_INIT(su, i);
			break;
a647 3
		case 'b':
			attr = "margin-bottom";
			break;
a655 3
			break;
		case 't':
			attr = "margin-top";
@


1.85
log
@Write text boxes as <mi>, <mn>, or <mo> as appropriate,
and write fontstyle or fontweight attributes where required.
Missing features reported by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.84 2017/06/14 01:31:19 schwarze Exp $ */
d454 1
a454 1
			(void)snprintf(numbuf, sizeof(numbuf), "&#%d;", c);
d517 1
a517 1
			print_word(h, "&#160;");
d780 1
a780 1
			print_word(h, "&#160;");
@


1.84
log
@implement the roff(7) \p (break output line) escape sequence
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.83 2017/06/08 12:54:40 schwarze Exp $ */
d88 1
@


1.83
log
@make the internal a2roffsu() interface more powerful by returning
a pointer to the end of the parsed data, making it easier to
parse subsequent bytes
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.82 2017/05/14 12:26:59 schwarze Exp $ */
d346 2
d349 1
a349 2
	int		 c, len, nospace;
	const char	*seq;
d351 1
a351 1
	static const char rejs[9] = { '\\', '<', '>', '&', '"',
d357 1
d368 12
a379 4
			if (*p == ' ')
				print_endword(h);
			else
				print_byte(h, *p);
d384 6
d434 3
@


1.82
log
@Tweak previous: tb@@ noticed that some browser/font combinations
have so amazingly wide bold fonts (for the same nominal font size)
that adding 15% to the column width still isn't sufficient to make
text reliably fit, so go for 20%.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.81 2017/05/12 17:56:39 schwarze Exp $ */
d951 4
a954 1
	if (a2roffsu(p, su, SCALE_MAX) < 2) {
@


1.81
log
@Make the tag column in .Bl -tag lists wider:
1. I forgot about the 2n padding between tag and body.
2. The factor 1.1 was too small for bold fold, make it *1.15 + 1n.
Ugliness spotted by tb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.80 2017/03/15 11:29:50 schwarze Exp $ */
d616 1
a616 1
				su->scale *= 1.15;
@


1.80
log
@Minimal support for deep linking into man(7) pages.
As the man(7) language does not provide semantic markup,
only .SH, .SS, and .UR become anchors for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.79 2017/03/14 01:34:57 schwarze Exp $ */
a609 1
		case 'W':
d614 8
a621 3
			/* Increase width to make even bold text fit. */
			su->scale *= 1.1;
			if (fmt[-1] == 'W')
d623 2
@


1.79
log
@Slightly increase widths calculated from string lengths (mainly
for .Bl -tag lists and SYNOPSIS .Nm blocks), such that the text
still fits even if it is printed in bold font.
This is an ugly band aid - but implementing font-dependent width
measurements would be a major project and even more difficult
for HTML than for PostScript.

Issue reported by Jan Stary <hans at stare dot cz>.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.78 2017/03/13 19:01:14 schwarze Exp $ */
d29 1
d31 1
a31 1
#include "mandoc_aux.h"
d236 22
@


1.78
log
@Print title="..." in addition to id="..." attributes for macro keys
that can be searched for by apropos(1), such that you see the
semantic function in a tooltip when hovering with the mouse.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.77 2017/02/05 20:21:17 schwarze Exp $ */
d592 2
@


1.77
log
@mark up .Ar, .Fa, .Va, .Ft, and .Vt with <var> rather than <i>;
suggested by bentley@@ long ago, but needed lots of cleanup first
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.76 2017/02/05 19:29:03 schwarze Exp $ */
d535 4
d543 3
a545 2
		case 'I':
			print_href(h, arg1, NULL, 0);
d548 4
a551 2
		case 'R':
			print_byte(h, '#');
d553 1
a553 1
			/* FALLTHROUGH */
@


1.76
log
@for .Rs, use <cite>
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.75 2017/02/05 18:13:28 schwarze Exp $ */
d77 1
@


1.75
log
@Improve <table> syntax:
The <col> element can only appear inside <colgroup>, so use <colgroup>.
The <tbody> element is optional and useless, so don't use it.
Even if we would ever need <thead> or <tfoot>, <tbody> would still be
optional and useless; besides, we will likely never need <thead> or <tfoot>,
simply because our languages don't support such functionality.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.74 2017/01/29 14:02:19 schwarze Exp $ */
d77 1
@


1.74
log
@eliminate one useless struct and one level of indirection;
no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.73 2017/01/28 22:36:17 schwarze Exp $ */
d66 1
a66 1
	{"tbody",	HTML_NLALL | HTML_INDENT},
@


1.73
log
@Simplify usage of print_otag() even more:
accept NULL to skip the attribute or format.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.72 2017/01/26 18:28:04 schwarze Exp $ */
d133 1
a133 1
	h->tags.head = NULL;
d151 2
a152 2
	while ((tag = h->tags.head) != NULL) {
		h->tags.head = tag->next;
d456 1
a456 1
	/* Push this tags onto the stack of open scopes. */
d461 2
a462 2
		t->next = h->tags.head;
		h->tags.head = t;
d700 1
a700 1
	h->tags.head = tag->next;
d761 1
a761 1
	while ((tag = h->tags.head) != NULL) {
d773 1
a773 1
	while ((tag = h->tags.head) != NULL) {
@


1.72
log
@Fix -man -Thtml formatting after .nf (which has nothing to do
with "literal", by the way, it means "no fill"):

* Use <pre> such that whitespace is preserved.
* Preserve lines breaks.
* For font alternating macros, avoid node recursion which required
scary juggling with the fill state.  Instead, simply print the text
children directly.

Missing feature first noticed by kristaps@@ in 2011,
the again reported by afresh1@@ in 2016,
and finally reported here: https://github.com/Debian/debiman/issues/21 ,
which i only found because of Shane Kerr's comment here:
https://plus.google.com/110314300533310775053/posts/H1eaw9Yskoc
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.71 2017/01/25 02:14:41 schwarze Exp $ */
d450 1
a450 1
	char		*s;
a494 1
			print_word(h, " style=\"");
d499 4
a502 1
		s = va_arg(ap, char *);
d514 2
a515 2
			attr = s;
			s = va_arg(ap, char *);
d520 8
d534 1
a534 1
			print_href(h, s, va_arg(ap, char *), 1);
d538 1
a538 1
			print_href(h, s, NULL, 0);
d546 1
a546 1
			print_encode(h, s, NULL, 1);
a553 2
	s = NULL;
	su = &mysu;
d555 2
d563 1
d567 1
a567 1
			s = va_arg(ap, char *);
d574 1
d579 4
a582 2
			s = va_arg(ap, char *);
			a2width(s, su);
d615 3
a617 8
			print_word(h, s);
			print_byte(h, ':');
			print_byte(h, ' ');
			print_word(h, va_arg(ap, char *));
			print_byte(h, ';');
			if (*fmt != '\0')
				print_byte(h, ' ');
			continue;
d621 7
a627 5
		v = su->scale;
		if (su->unit == SCALE_MM && (v /= 100.0) == 0.0)
			v = 1.0;
		else if (su->unit == SCALE_BU)
			v /= 24.0;
d631 11
a641 3
		(void)snprintf(numbuf, sizeof(numbuf), "%.2f", v);
		print_word(h, numbuf);
		print_word(h, roffscales[su->unit]);
d643 1
a643 2
		if (*fmt != '\0')
			print_byte(h, ' ');
d645 1
a645 1
	if (have_style)
@


1.71
log
@Improve HTML formatting of .Bl -tag.

In particular, when using the style sheet, put the body on the same
line as the head for short heads, or on the next line for long
heads, in a way that preserves both correct indentation and correct
vertical spacing with and without -compact, and with one or more
heads per body (hi, Zaphod) - eight use cases so far - and with and
without -tag, and with and without -offset, 32 use cases grand total.

Using many ideas from zhuk@@, from <David dot Dahlberg at fkie dot
fraunhofer dot de>, and from Benny Lofgren <bl dash lists at lofgren
dot biz>, and a few of my own.

This is an excellent demonstration that CSS is an extremely hostile
language, much more trapful and much harder to use than, say, C.
When matthew@@ reported this in July 2014 (!), it was already a known
issue, and i no longer remember for how long.  My first serious
attempt at fixing it (in November 2015) failed miserably.  I'd love
to see simplifications of both the generated HTML code and of the
style sheet, but without breaking any of the 32 use cases, please.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.70 2017/01/21 02:28:42 schwarze Exp $ */
a114 1
static	void	 print_endline(struct html *);
d812 1
a812 1
static void
@


1.70
log
@slightly simplify header and footer styles
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.69 2017/01/19 16:56:53 schwarze Exp $ */
d567 1
d570 2
@


1.69
log
@clean up markup of .Bd, .D1, .Dl, .Li, and .Ql;
in particular, stop abuse of <blockquote>
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.68 2017/01/19 15:27:26 schwarze Exp $ */
a176 4
	print_endline(h);
	print_text(h, "table.foot td { width: 50%; }");
	print_endline(h);
	print_text(h, "table.head td { width: 33%; }");
@


1.68
log
@Clean up CSS rules for sections and paragraphs.
Start using real macro names for CSS classes.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.67 2017/01/19 01:00:11 schwarze Exp $ */
a75 1
	{"blockquote",	HTML_NLALL | HTML_INDENT},
@


1.67
log
@Implement line breaking of the generated HTML code at space characters
in filled text.  This does not affect HTML semantics, but makes the
HTML code even more humanly readable.

While here,
- collapse multiple consecutive space characters in filled text
- and insert a blank between style entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.66 2017/01/18 19:22:18 schwarze Exp $ */
d183 1
a183 1
	print_text(h, "div.spacer { margin: 1em 0; }");
d770 1
a770 1
	t = print_otag(h, TAG_DIV, "c", "spacer");
@


1.66
log
@Make HTML output more human readable by overhauling line break logic
around tags and by introducing some simple indentation.
No change of HTML semantics intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.65 2017/01/17 15:32:39 schwarze Exp $ */
d115 6
a120 2
static	void	 html_endline(struct html *);
static	void	 html_indent(struct html *);
d122 1
a122 1
static	int	 print_escape(char);
d174 1
a174 1
	html_endline(h);
d176 1
a176 1
	html_endline(h);
d178 1
a178 1
	html_endline(h);
d180 1
a180 1
	html_endline(h);
d182 1
a182 1
	html_endline(h);
d293 1
a293 1
print_escape(char c)
d298 1
a298 1
		printf("&lt;");
d301 1
a301 1
		printf("&gt;");
d304 1
a304 1
		printf("&amp;");
d307 1
a307 1
		printf("&quot;");
d310 1
a310 1
		printf("&nbsp;");
d313 1
a313 1
		putchar('-');
d326 1
d346 5
a350 6
		sz = strcspn(p, rejs);
		if (p + sz > pend)
			sz = pend - p;

		fwrite(p, 1, sz, stdout);
		p += (int)sz;
d355 1
a355 1
		if (print_escape(*p++))
d414 5
a418 4
		if (c > 0x7E)
			printf("&#%d;", c);
		else if ( ! print_escape(c))
			putchar(c);
d434 1
a434 1
				putchar('1');
d453 1
d473 3
a475 3
		html_endline(h);
	if (h->flags & HTML_NLDONE)
		html_indent(h);
d478 1
a478 1
			printf("&#160;");
d482 1
a482 1
			putchar(' ');
d493 2
a494 1
	printf("<%s", htmltags[tag].name);
d501 1
a501 1
			printf(" style=\"");
d524 4
a527 1
		printf(" %s=\"", attr);
d538 1
a538 1
			putchar('#');
d545 1
a545 1
		putchar('"');
d604 7
a610 1
			printf("%s: %s;", s, va_arg(ap, char *));
d620 9
a628 1
		printf("%s: %.2f%s;", attr, v, roffscales[su->unit]);
d631 1
a631 1
		putchar('"');
d638 1
a638 1
		putchar('/');
d640 1
a640 1
	putchar('>');
d643 1
a643 1
		html_endline(h);
d676 6
a681 3
		html_endline(h);
	html_indent(h);
	printf("</%s>", htmltags[tag->tag].name);
d683 1
a683 1
		html_endline(h);
d692 2
a693 3

	puts("<!DOCTYPE html>");
	h->flags |= HTML_NLDONE;
d699 1
a699 1
	if ((h->flags & (HTML_NLDONE | HTML_NOSPACE)) == 0) {
d703 1
a703 1
			putchar(' ');
d705 1
a705 1
			printf("&#160;");
d721 1
a721 1
		html_indent(h);
d774 37
d813 1
a813 1
 * Not to be called right after html_indent().
d816 1
a816 1
html_endline(struct html *h)
d818 1
a818 1
	if (h->flags & HTML_NLDONE)
d821 5
d827 26
a852 1
	h->flags |= HTML_NLDONE | HTML_NOSPACE;
d862 1
a862 1
html_indent(struct html *h)
d864 1
a864 1
	int	 i;
d866 1
a866 1
	if ((h->flags & HTML_NLDONE) == 0)
d869 3
a871 2
	if (h->noindent == 0)
		for (i = 0; i < h->indent * 2; i++)
d873 13
a885 1
	h->flags &= ~(HTML_NLDONE | HTML_NOSPACE);
@


1.65
log
@Completely delete the buf field of struct html and all the buf*()
interfaces.  Such a static buffer was a bad idea in the first place,
causing unfixable truncation that was only prevented by triggering
an assertion failure.  Instead, let the small number of remaining
users allocate and free their own, temporary dynamic buffers,
or for the case of .Xr and .In, pass the original data to be
assembled in print_otag().
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.64 2017/01/17 01:47:46 schwarze Exp $ */
d39 11
a49 3
#define	HTML_CLRLINE	 (1 << 0)
#define	HTML_NOSTACK	 (1 << 1)
#define	HTML_AUTOCLOSE	 (1 << 2) /* Tag has auto-closure. */
d53 46
a98 46
	{"html",	HTML_CLRLINE}, /* TAG_HTML */
	{"head",	HTML_CLRLINE}, /* TAG_HEAD */
	{"body",	HTML_CLRLINE}, /* TAG_BODY */
	{"meta",	HTML_CLRLINE | HTML_NOSTACK | HTML_AUTOCLOSE}, /* TAG_META */
	{"title",	HTML_CLRLINE}, /* TAG_TITLE */
	{"div",		HTML_CLRLINE}, /* TAG_DIV */
	{"h1",		0}, /* TAG_H1 */
	{"h2",		0}, /* TAG_H2 */
	{"span",	0}, /* TAG_SPAN */
	{"link",	HTML_CLRLINE | HTML_NOSTACK | HTML_AUTOCLOSE}, /* TAG_LINK */
	{"br",		HTML_CLRLINE | HTML_NOSTACK | HTML_AUTOCLOSE}, /* TAG_BR */
	{"a",		0}, /* TAG_A */
	{"table",	HTML_CLRLINE}, /* TAG_TABLE */
	{"tbody",	HTML_CLRLINE}, /* TAG_TBODY */
	{"col",		HTML_CLRLINE | HTML_NOSTACK | HTML_AUTOCLOSE}, /* TAG_COL */
	{"tr",		HTML_CLRLINE}, /* TAG_TR */
	{"td",		HTML_CLRLINE}, /* TAG_TD */
	{"li",		HTML_CLRLINE}, /* TAG_LI */
	{"ul",		HTML_CLRLINE}, /* TAG_UL */
	{"ol",		HTML_CLRLINE}, /* TAG_OL */
	{"dl",		HTML_CLRLINE}, /* TAG_DL */
	{"dt",		HTML_CLRLINE}, /* TAG_DT */
	{"dd",		HTML_CLRLINE}, /* TAG_DD */
	{"blockquote",	HTML_CLRLINE}, /* TAG_BLOCKQUOTE */
	{"pre",		HTML_CLRLINE }, /* TAG_PRE */
	{"b",		0 }, /* TAG_B */
	{"i",		0 }, /* TAG_I */
	{"code",	0 }, /* TAG_CODE */
	{"small",	0 }, /* TAG_SMALL */
	{"style",	HTML_CLRLINE}, /* TAG_STYLE */
	{"math",	HTML_CLRLINE}, /* TAG_MATH */
	{"mrow",	0}, /* TAG_MROW */
	{"mi",		0}, /* TAG_MI */
	{"mo",		0}, /* TAG_MO */
	{"msup",	0}, /* TAG_MSUP */
	{"msub",	0}, /* TAG_MSUB */
	{"msubsup",	0}, /* TAG_MSUBSUP */
	{"mfrac",	0}, /* TAG_MFRAC */
	{"msqrt",	0}, /* TAG_MSQRT */
	{"mfenced",	0}, /* TAG_MFENCED */
	{"mtable",	0}, /* TAG_MTABLE */
	{"mtr",		0}, /* TAG_MTR */
	{"mtd",		0}, /* TAG_MTD */
	{"munderover",	0}, /* TAG_MUNDEROVER */
	{"munder",	0}, /* TAG_MUNDER*/
	{"mover",	0}, /* TAG_MOVER*/
d115 2
d167 1
d169 11
a179 6
	print_text(h, "table.head, table.foot { width: 100%; }\n"
	      "td.head-rtitle, td.foot-os { text-align: right; }\n"
	      "td.head-vol { text-align: center; }\n"
	      "table.foot td { width: 50%; }\n"
	      "table.head td { width: 33%; }\n"
	      "div.spacer { margin: 1em 0; }\n");
d452 3
a454 1
	int		 i, have_style;
d458 1
a458 1
	if ( ! (HTML_NOSTACK & htmltags[tag].flags)) {
d466 11
a476 9
	if ( ! (HTML_NOSPACE & h->flags))
		if ( ! (HTML_CLRLINE & htmltags[tag].flags)) {
			/* Manage keeps! */
			if ( ! (HTML_KEEP & h->flags)) {
				if (HTML_PREKEEP & h->flags)
					h->flags |= HTML_KEEP;
				putchar(' ');
			} else
				printf("&#160;");
d478 1
d618 4
a621 1
	h->flags |= HTML_NOSPACE;
d623 4
a626 2
	if ((HTML_AUTOCLOSE | HTML_CLRLINE) & htmltags[tag].flags)
		putchar('\n');
d634 1
d645 9
d655 2
a656 4
	if (HTML_CLRLINE & htmltags[tag->tag].flags) {
		h->flags |= HTML_NOSPACE;
		putchar('\n');
	}
d667 1
d673 1
a673 3

	if ( ! (HTML_NOSPACE & h->flags)) {
		/* Manage keeps! */
d695 1
d748 33
@


1.64
log
@Simplify the usage of print_otag() by making it accept a variable
number of arguments.

Delete struct htmlpair and all the PAIR_*() macros.
Delete enum htmlattr, handle that in print_otag() instead.

Minus 190 lines of code; no functional change except better ordering
of attributes (class before style) in three cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.63 2017/01/08 16:38:04 schwarze Exp $ */
a106 1
static	void	 bufncat(struct html *, const char *, size_t);
d109 2
a110 1
static	int	 print_encode(struct html *, const char *, int);
a111 1
static	void	 print_attr(struct html *, const char *, const char *);
d304 1
a304 1
print_encode(struct html *h, const char *p, int norecurse)
d313 3
d318 1
a318 1
	while ('\0' != *p) {
d326 2
d332 1
a332 1
		if ('\0' == *p)
d404 1
a404 1
print_attr(struct html *h, const char *key, const char *val)
d406 19
a424 3
	printf(" %s=\"", key);
	(void)print_encode(h, val, 1);
	putchar('\"');
d433 1
d435 1
d481 1
a481 1
			print_attr(h, "class", s);
d484 1
a484 1
			print_attr(h, "href", s);
d487 1
a487 1
			print_attr(h, "id", s);
d490 2
a491 1
			print_attr(h, s, va_arg(ap, char *));
d496 19
a549 1
		bufinit(h);
d552 1
a552 1
			bufcat_su(h, "margin-bottom", su);
d555 1
a555 1
			bufcat_su(h, "height", su);
d558 1
a558 1
			bufcat_su(h, "text-indent", su);
d561 1
a561 1
			bufcat_su(h, "margin-left", su);
d564 1
a564 1
			bufcat_su(h, "margin-top", su);
d567 1
a567 1
			bufcat_su(h, "width", su);
d570 1
a570 1
			bufcat_su(h, "min-width", su);
d573 2
a574 2
			bufcat_style(h, s, va_arg(ap, char *));
			break;
d578 6
a583 1
		printf("%s", h->buf);
d666 1
a666 1
	if ( ! print_encode(h, word, 0)) {
a727 128
}

void
bufinit(struct html *h)
{

	h->buf[0] = '\0';
	h->buflen = 0;
}

void
bufcat_style(struct html *h, const char *key, const char *val)
{

	bufcat(h, key);
	bufcat(h, ":");
	bufcat(h, val);
	bufcat(h, ";");
}

void
bufcat(struct html *h, const char *p)
{

	/*
	 * XXX This is broken and not easy to fix.
	 * When using the -Oincludes option, buffmt_includes()
	 * may pass in strings overrunning BUFSIZ, causing a crash.
	 */

	h->buflen = strlcat(h->buf, p, BUFSIZ);
	assert(h->buflen < BUFSIZ);
}

void
bufcat_fmt(struct html *h, const char *fmt, ...)
{
	va_list		 ap;

	va_start(ap, fmt);
	(void)vsnprintf(h->buf + (int)h->buflen,
	    BUFSIZ - h->buflen - 1, fmt, ap);
	va_end(ap);
	h->buflen = strlen(h->buf);
}

static void
bufncat(struct html *h, const char *p, size_t sz)
{

	assert(h->buflen + sz + 1 < BUFSIZ);
	strncat(h->buf, p, sz);
	h->buflen += sz;
}

void
buffmt_includes(struct html *h, const char *name)
{
	const char	*p, *pp;

	pp = h->base_includes;

	bufinit(h);
	while (NULL != (p = strchr(pp, '%'))) {
		bufncat(h, pp, (size_t)(p - pp));
		switch (*(p + 1)) {
		case 'I':
			bufcat(h, name);
			break;
		default:
			bufncat(h, p, 2);
			break;
		}
		pp = p + 2;
	}
	if (pp)
		bufcat(h, pp);
}

void
buffmt_man(struct html *h, const char *name, const char *sec)
{
	const char	*p, *pp;

	pp = h->base_man;

	bufinit(h);
	while (NULL != (p = strchr(pp, '%'))) {
		bufncat(h, pp, (size_t)(p - pp));
		switch (*(p + 1)) {
		case 'S':
			bufcat(h, sec ? sec : "1");
			break;
		case 'N':
			bufcat_fmt(h, "%s", name);
			break;
		default:
			bufncat(h, p, 2);
			break;
		}
		pp = p + 2;
	}
	if (pp)
		bufcat(h, pp);
}

void
bufcat_su(struct html *h, const char *p, const struct roffsu *su)
{
	double		 v;

	v = su->scale;
	if (SCALE_MM == su->unit && 0.0 == (v /= 100.0))
		v = 1.0;
	else if (SCALE_BU == su->unit)
		v /= 24.0;

	bufcat_fmt(h, "%s: %.2f%s;", p, v, roffscales[su->unit]);
}

void
bufcat_id(struct html *h, const char *src)
{

	/* Cf. <http://www.w3.org/TR/html5/dom.html#the-id-attribute>. */

	for (; '\0' != *src; src++)
		bufncat(h, *src == ' ' ? "_" : src, 1);
@


1.63
log
@style: missing blank between case statement and label;
from Tiago Silva <tiagofilipesilva at icloud dot com> long ago
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.62 2015/12/25 20:43:04 bentley Exp $ */
d4 1
a4 1
 * Copyright (c) 2011-2015 Ingo Schwarze <schwarze@@openbsd.org>
a92 16
static	const char	*const htmlattrs[ATTR_MAX] = {
	"name", /* ATTR_NAME */
	"rel", /* ATTR_REL */
	"href", /* ATTR_HREF */
	"type", /* ATTR_TYPE */
	"media", /* ATTR_MEDIA */
	"class", /* ATTR_CLASS */
	"style", /* ATTR_STYLE */
	"id", /* ATTR_ID */
	"colspan", /* ATTR_COLSPAN */
	"charset", /* ATTR_CHARSET */
	"open", /* ATTR_OPEN */
	"close", /* ATTR_CLOSE */
	"mathvariant", /* ATTR_MATHVARIANT */
};

d106 1
a150 1
	struct htmlpair	 tag[4];
d153 1
a153 3
	tag[0].key = ATTR_CHARSET;
	tag[0].val = "utf-8";
	print_otag(h, TAG_META, 1, tag);
d158 1
a158 1
	t = print_otag(h, TAG_STYLE, 0, NULL);
d167 3
a169 11
	if (h->style) {
		tag[0].key = ATTR_REL;
		tag[0].val = "stylesheet";
		tag[1].key = ATTR_HREF;
		tag[1].val = h->style;
		tag[2].key = ATTR_TYPE;
		tag[2].val = "text/css";
		tag[3].key = ATTR_MEDIA;
		tag[3].val = "all";
		print_otag(h, TAG_LINK, 4, tag);
	}
d208 1
a208 1
		h->metaf = print_otag(h, TAG_I, 0, NULL);
d211 1
a211 1
		h->metaf = print_otag(h, TAG_B, 0, NULL);
d214 2
a215 2
		h->metaf = print_otag(h, TAG_B, 0, NULL);
		print_otag(h, TAG_I, 0, NULL);
d408 1
a408 2
print_otag(struct html *h, enum htmltag tag,
		int sz, const struct htmlpair *p)
d410 2
a411 1
	int		 i;
d413 2
d445 98
a542 2
	for (i = 0; i < sz; i++)
		print_attr(h, htmlattrs[p[i].key], p[i].val);
d606 1
a606 1
		h->metaf = print_otag(h, TAG_I, 0, NULL);
d609 1
a609 1
		h->metaf = print_otag(h, TAG_B, 0, NULL);
d612 2
a613 2
		h->metaf = print_otag(h, TAG_B, 0, NULL);
		print_otag(h, TAG_I, 0, NULL);
a662 1
	struct htmlpair	 tag;
d664 1
a664 2
	PAIR_CLASS_INIT(&tag, "spacer");
	t = print_otag(h, TAG_DIV, 1, &tag);
d668 15
@


1.62
log
@Generate simpler in-page links: just replace spaces with underscores.

So
http://example.com/OpenBSD-current/man1/ls.1#x546865204c6f6e6720466f726d6174
becomes
http://example.com/OpenBSD-current/man1/ls.1#The_Long_Format

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.61 2015/10/13 22:57:49 schwarze Exp $ */
d663 1
a663 1
		case'I':
@


1.61
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.60 2015/10/12 00:14:41 schwarze Exp $ */
d721 1
a721 1
	/* Cf. <http://www.w3.org/TR/html4/types.html#h-6.2>. */
d723 2
a724 2
	while ('\0' != *src)
		bufcat_fmt(h, "%.2x", *src++);
@


1.60
log
@Fix an obvious bug found during the /* FALLTHROUGH */ cleanup:
ASCII_NBRSP has to be rendered as "&nbsp;", not "-".
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.59 2015/10/12 00:07:27 schwarze Exp $ */
d131 1
a131 1
html_alloc(const struct mchars *mchars, const struct manoutput *outopts)
a137 2
	h->symtab = mchars;

d397 1
a397 1
			c = mchars_spec2cp(h->symtab, seq, len);
@


1.59
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.58 2015/10/06 18:30:43 schwarze Exp $ */
d319 1
a319 1
		putchar('-');
@


1.58
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.57 2015/09/26 00:53:15 schwarze Exp $ */
a218 1
		/* FALLTHROUGH */
a282 1
			/* FALLTHROUGH */
a283 1
			/* FALLTHROUGH */
a284 1
			/* FALLTHROUGH */
d323 1
a323 1
		/* FALLTHROUGH */
a367 1
			/* FALLTHROUGH */
a368 1
			/* FALLTHROUGH */
a369 1
			/* FALLTHROUGH */
a370 1
			/* FALLTHROUGH */
a371 1
			/* FALLTHROUGH */
@


1.57
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.56 2015/03/27 21:17:16 schwarze Exp $ */
d146 1
a146 1
	return(h);
d282 1
a282 1
			return(sz);
d302 1
a302 1
	return(sz);
d331 1
a331 1
		return(0);
d333 1
a333 1
	return(1);
d433 1
a433 1
	return(nospace);
d495 1
a495 1
	return(t);
@


1.56
log
@Actually use the new man.conf(5) "output" directive.
Additional functionality, yet minus 45 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.55 2015/01/21 20:20:49 schwarze Exp $ */
a224 1
		/* NOTREACHED */
@


1.55
log
@Rudimentary implementation of the roff(7) \o escape sequence (overstrike).
This is of some relevance because the pod2man(1) preamble abuses it
for the icelandic letter Thorn, instead of simply using \(TP and \(Tp.
Missing feature found by sthen@@ in DateTime::Locale::is_IS(3p).
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.54 2014/12/20 00:19:54 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d33 1
d131 1
a131 1
html_alloc(const struct mchars *mchars, char *outopts)
a133 8
	const char	*toks[5];
	char		*v;

	toks[0] = "style";
	toks[1] = "man";
	toks[2] = "includes";
	toks[3] = "fragment";
	toks[4] = NULL;
d140 5
a144 17
	while (outopts && *outopts)
		switch (getsubopt(&outopts, UNCONST(toks), &v)) {
		case 0:
			h->style = v;
			break;
		case 1:
			h->base_man = v;
			break;
		case 2:
			h->base_includes = v;
			break;
		case 3:
			h->oflags |= HTML_FRAGMENT;
			break;
		default:
			break;
		}
@


1.54
log
@resolve some code duplication; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.53 2014/12/02 10:07:17 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d308 2
d436 5
@


1.53
log
@Fix the implementation and documentation of \c (continue text input line).
In particular, make it work in no-fill mode, too.
Reminded by Carsten dot Kunze at arcor dot de (Heirloom roff).
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.52 2014/12/01 04:32:34 schwarze Exp $ */
d122 1
a122 1
static	void	 print_ctag(struct html *, enum htmltag);
d512 1
a512 1
print_ctag(struct html *h, enum htmltag tag)
d515 11
a525 2
	printf("</%s>", htmltags[tag].name);
	if (HTML_CLRLINE & htmltags[tag].flags) {
d529 3
d593 1
a593 11
		/*
		 * Remember to close out and nullify the current
		 * meta-font and table, if applicable.
		 */
		if (tag == h->metaf)
			h->metaf = NULL;
		if (tag == h->tblt)
			h->tblt = NULL;
		print_ctag(h, tag->tag);
		h->tags.head = tag->next;
		free(tag);
d607 1
a607 11
		/*
		 * Remember to close out and nullify the current
		 * meta-font and table, if applicable.
		 */
		if (tag == h->metaf)
			h->metaf = NULL;
		if (tag == h->tblt)
			h->tblt = NULL;
		print_ctag(h, tag->tag);
		h->tags.head = tag->next;
		free(tag);
@


1.52
log
@The header libmandoc.h is part of the internal parser interface,
but html.c is not part of the parser at all, so it cannot include
that header, and actually, it doesn't need it.
Found while auditing includes after Theo's recent *.h commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.51 2014/10/29 00:17:01 schwarze Exp $ */
d563 1
d565 1
a565 1
		h->flags |= HTML_NOSPACE;
@


1.51
log
@In terminal output, unify handling of Unicode and numbered character
escape sequences just like it was earlier implemented for -Thtml.
Do not let control characters other than ASCII 9 (horizontal tab)
propagate to the output, even though groff allows them; but that
really doesn't look like a great idea.

Let mchars_num2char() return int such that we can distinguish invalid \N
syntax from \N'0'.  This also reduces the danger of signed char issues
popping up.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.50 2014/10/28 17:35:42 schwarze Exp $ */
a30 1
#include "libmandoc.h"
@


1.50
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.49 2014/10/27 16:28:30 schwarze Exp $ */
d423 2
d428 2
d438 2
a439 3
		if (c <= 0)
			continue;
		if (c < 0x20 || (c > 0x7E && c < 0xA0))
@


1.49
log
@Handle output encoding for unicode, numbered and named escape sequences
in one common, safe way instead of three different ways.  In particular,
* skip NUL, it is used to mean "no output desired"
* deny 0x01-0x1F and 0x7F-0x9F, print REPLACEMENT CHARACTER instead
* print 0x20-0x7E literally or name-encoded, as required
* print characters above 0x9F numerically
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.48 2014/10/27 13:29:30 schwarze Exp $ */
a127 1
static	void	 *ml_alloc(char *);
d130 2
a131 2
static void *
ml_alloc(char *outopts)
d146 1
a146 1
	h->symtab = mchars_alloc();
a168 14
void *
html_alloc(char *outopts)
{

	return(ml_alloc(outopts));
}

void *
xhtml_alloc(char *outopts)
{

	return(ml_alloc(outopts));
}

a180 3

	if (h->symtab)
		mchars_free(h->symtab);
@


1.48
log
@Fix a regression in term.c rev. 1.89 reported by bentley@@:
In UTF-8 output, do not print anything if mchars_spec2cp() returns 0.
In particular, this repairs handling of zero-width spaces (\&).

While here, let mchars_spec2cp() return 0xFFFD instead of -1
if the character is not found, simplifying the using code.
In HTML output, do not print obfuscated ASCII characters and
do not test for one-char escapes, mchars_spec2cp() already does that.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.47 2014/10/26 17:11:18 schwarze Exp $ */
a437 12

			/*
			 * XXX Security warning:
			 * For now, forbid Unicode obfuscation of ASCII
			 * characters.  An audit of the callers is
			 * required before this can be removed.
			 */

			if (c < 0x80)
				c = 0xFFFD;

			printf("&#x%x;", c);
a440 2
			if ( ! ('\0' == c || print_escape(c)))
				putchar(c);
a443 6
			if (c <= 0)
				break;
			if (c < 0x20 || c > 0x7e)
				printf("&#%d;", c);
			else if ( ! print_escape(c))
				putchar(c);
d448 1
a448 1
			break;
d450 1
a450 1
			break;
d452 8
@


1.47
log
@Improve -Tascii output for Unicode escape sequences: For the first 512
code points, provide ASCII approximations.  This is already much better
than what groff does, which prints nothing for most code points.

A few minor fixes while here:
* Handle Unicode escape sequences in the ASCII range.
* In case of errors, use the REPLACEMENT CHARACTER U+FFFD for -Tutf8
and the string "<?>" for -Tascii output.
* Handle all one-character escape sequences in mchars_spec2{cp,str}()
and remove the workarounds on the higher level.
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.46 2014/10/13 21:05:59 chl Exp $ */
d458 3
a460 1
			if (c > 0)
d462 2
a463 3
			else if (-1 == c && 1 == len &&
			    !print_escape(*seq))
				putchar((int)*seq);
@


1.46
log
@Add missing */ after $OpenBSD$ tag

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: html.c,v 1.45 2014/10/10 15:25:06 schwarze Exp $ */
d438 12
a449 2
			if ('\0' != c)
				printf("&#x%x;", c);
@


1.45
log
@Partial eqn(7) rewrite by kristaps@@ in order to get operator precedence right.
@
text
@d1 1
a1 1
/*	$OpenBSD$
@


1.44
log
@parse and render "from" and "to" clauses in eqn, and render matrices;
written by kristaps@@ during EuroBSDCon
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.43 2014/10/09 15:49:09 schwarze Exp $ */
d106 1
@


1.43
log
@initial bits of MathML rendering for eqn(7) -Thtml;
written by kristaps@@ during EuroBSDCon
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.42 2014/10/07 18:17:05 schwarze Exp $ */
d88 3
@


1.42
log
@Switch HTML output to polyglot HTML5; have only one single -Thml mode.
Replace hard-coded widths and alignments with a minimal embedded stylesheet.
Do not use <p> because it cannot appear inside block macros.
Remove the "summary" attribute because it is not HTML5.

Written by kristaps@@ some months ago, finished during EuroBSDCon.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.41 2014/08/14 00:29:12 schwarze Exp $ */
d75 13
d101 2
@


1.41
log
@Revert previous, as requested by kristaps@@.
The .Bf block can contain subblocks, so it has to render as an
element that can contain flow content.  But <em> cannot contain
flow content, only phrasing content.  Rendering .Em and .Bf differently
would by unfortunate, and closing out .Bf before subblocks and
re-opening it afterwards would merely complicate both the C code
of the program and the generated HTML code.  Besides, converting
.Em to semantic HTML markup would require some content to be put
into <em> and some into <i>, but we cannot automatically distinguish
which is which, so strictly speaking, we can't use semantic HTML
here but have to fall back to physical markup.  Wonders of HTML...
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.40 2014/08/13 22:09:28 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
a68 1
	{"p",		HTML_CLRLINE | HTML_NOSTACK | HTML_AUTOCLOSE}, /* TAG_P */
d74 1
a77 2
	"http-equiv", /* ATTR_HTTPEQUIV */
	"content", /* ATTR_CONTENT */
a84 1
	"width", /* ATTR_WIDTH */
a85 2
	"summary", /* ATTR_SUMMARY */
	"align", /* ATTR_ALIGN */
d87 1
d109 1
a109 1
static	void	 *ml_alloc(char *, enum htmltype);
d113 1
a113 1
ml_alloc(char *outopts, enum htmltype type)
a126 1
	h->type = type;
d155 1
a155 1
	return(ml_alloc(outopts, HTML_HTML_4_01_STRICT));
d162 1
a162 1
	return(ml_alloc(outopts, HTML_XHTML_1_0_STRICT));
d188 5
d194 11
a204 11
	tag[0].key = ATTR_HTTPEQUIV;
	tag[0].val = "Content-Type";
	tag[1].key = ATTR_CONTENT;
	tag[1].val = "text/html; charset=utf-8";
	print_otag(h, TAG_META, 2, tag);

	tag[0].key = ATTR_NAME;
	tag[0].val = "resource-type";
	tag[1].key = ATTR_CONTENT;
	tag[1].val = "document";
	print_otag(h, TAG_META, 2, tag);
d494 1
a494 9
	/* Add non-overridable attributes. */

	if (TAG_HTML == tag && HTML_XHTML_1_0_STRICT == h->type) {
		print_attr(h, "xmlns", "http://www.w3.org/1999/xhtml");
		print_attr(h, "xml:lang", "en");
		print_attr(h, "lang", "en");
	}

	/* Accommodate for XML "well-formed" singleton escaping. */
d497 1
a497 7
		switch (h->type) {
		case HTML_XHTML_1_0_STRICT:
			putchar('/');
			break;
		default:
			break;
		}
a522 17
	const char	*doctype;
	const char	*dtd;
	const char	*name;

	switch (h->type) {
	case HTML_HTML_4_01_STRICT:
		name = "HTML";
		doctype = "-//W3C//DTD HTML 4.01//EN";
		dtd = "http://www.w3.org/TR/html4/strict.dtd";
		break;
	default:
		puts("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
		name = "html";
		doctype = "-//W3C//DTD XHTML 1.0 Strict//EN";
		dtd = "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd";
		break;
	}
d524 1
a524 2
	printf("<!DOCTYPE %s PUBLIC \"%s\" \"%s\">\n",
	    name, doctype, dtd);
d615 12
@


1.40
log
@Begin cleanup of scaling units.
Note that we use 240u := 1i for all devices, even -Tps and -Tpdf.
Big fix of -Tascii rendering of f, m, and u.
Small fix of -Tascii rendering of c.
Big fix of -Thtml rendering of u.
Big fix of -Tps rendering of m, p, and u.
Clarify -Tps rendering of c.
Correct documentation of scaling units, in particular with respect to u.
This for example improves rendering of the OpenGL manuals.
Joint work with kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.162 2014/08/13 20:34:29 kristaps Exp $ */
a74 1
	{"em",		0 }, /* TAG_EM */
@


1.39
log
@Use <em> for .Em and .Bf -emphasis.

The vast majority of .Em in real-world manuals is stress emphasis,
for which <em> is the correct markup.  Admittedly, there are some
instances of .Em usage for alternate quality, for which <i> would
be a better match.  Most of these are technical terms that neither
allow semantic markup nor are keywords - for the latter, .Sy would
be preferable.  A typical example is that the shell breaks input into
.Em words .
Alternate voice or mood, which would also require <i>, is almost
absent from manuals.
We cannot satisfy both stress emphasis and alternate quality, so
pick the one that fits more often and looks less wrong when off.

Patch from Guy Harris <guy at alum dot mit dot edu>.
ok bentley@@ joerg@@NetBSD
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.38 2014/07/23 15:00:00 schwarze Exp $ */
d761 2
@


1.38
log
@Security fix:
After decoding numeric (\N) and one-character (\<, \> etc.)
character escape sequences, do not forget to HTML-encode the
resulting ASCII character.  Malicious manuals were able to smuggle
XSS content by roff-escaping the HTML-special characters they need.
That's a classic bug type in many web applications, actually...  :-(

Found myself while auditing the HTML formatter for safe output handling.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.37 2014/07/22 22:41:29 schwarze Exp $ */
d75 1
@


1.37
log
@Security fix:
The function print_encode() is used both for plain text
and for quoted attribute values.
Escape the '"' character such that malicious manuals cannot pull off
XSS attacks using malformed .Lk, .Mt, .%U, and .UR macros (and maybe
others) to trigger the latter case.
In the former case, escaping does no harm.
Issue found by Sebastien Marie <semarie-openbsd at latrappe dot fr>.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.36 2014/04/23 16:07:06 schwarze Exp $ */
d109 1
d324 31
d381 1
a381 15
		switch (*p++) {
		case '<':
			printf("&lt;");
			continue;
		case '>':
			printf("&gt;");
			continue;
		case '&':
			printf("&amp;");
			continue;
		case '"':
			printf("&quot;");
			continue;
		case ASCII_NBRSP:
			putchar('-');
a382 8
		case ASCII_HYPH:
			putchar('-');
			/* FALLTHROUGH */
		case ASCII_BREAK:
			continue;
		default:
			break;
		}
d417 1
a417 1
			/* Skip passed "u" header. */
d424 1
a424 1
			if ('\0' != c)
d431 2
a432 1
			else if (-1 == c && 1 == len)
@


1.36
log
@Audit strlcpy(3)/strlcat(3) usage.

* Repair three instances of silent truncation, use asprintf(3).
* Change two instances of strlen(3)+malloc(3)+strlcpy(3)+strlcat(3)+...
to use asprintf(3) instead to make them less error prone.
* Cast the return value of four instances where the destination
buffer is known to be large enough to (void).
* Completely remove three useless instances of strlcpy(3)/strlcat(3).
* Mark two places in -Thtml with XXX that can cause information loss
and crashes but are not easy to fix, requiring design changes of
some internal interfaces.
* The file mandocdb.c remains to be audited.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.35 2014/04/20 16:44:44 schwarze Exp $ */
d329 1
a329 1
	static const char rejs[8] = { '\\', '<', '>', '&',
d358 3
@


1.35
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.34 2014/03/21 22:17:01 schwarze Exp $ */
d655 6
@


1.34
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.33 2014/01/22 20:58:35 schwarze Exp $ */
d114 1
d136 1
a136 1
		case (0):
d139 1
a139 1
		case (1):
d142 1
a142 1
		case (2):
d145 1
a145 1
		case (3):
a161 1

a168 1

d178 1
a178 1
		h->tags.head = tag->next;	
d181 1
a181 1
	
a187 1

d224 1
a224 1
	case (ESCAPE_FONTPREV):
d227 1
a227 1
	case (ESCAPE_FONTITALIC):
d230 1
a230 1
	case (ESCAPE_FONTBOLD):
d233 1
a233 1
	case (ESCAPE_FONTBI):
d236 1
a236 1
	case (ESCAPE_FONT):
d238 1
a238 1
	case (ESCAPE_FONTROMAN):
d255 1
a255 1
	case (HTMLFONT_ITALIC):
d258 1
a258 1
	case (HTMLFONT_BOLD):
d261 1
a261 1
	case (HTMLFONT_BI):
d300 1
a300 1
		case (ESCAPE_ERROR):
d302 1
a302 1
		case (ESCAPE_UNICODE):
d304 1
a304 1
		case (ESCAPE_NUMBERED):
d306 1
a306 1
		case (ESCAPE_SPECIAL):
d312 1
a312 1
		case (ESCAPE_SKIPCHAR):
d350 1
a350 1
		case ('<'):
d353 1
a353 1
		case ('>'):
d356 1
a356 1
		case ('&'):
d359 1
a359 1
		case (ASCII_NBRSP):
d362 1
a362 1
		case (ASCII_HYPH):
d365 1
a365 1
		case (ASCII_BREAK):
d376 1
a376 1
		case (ESCAPE_FONT):
d378 1
a378 1
		case (ESCAPE_FONTPREV):
d380 1
a380 1
		case (ESCAPE_FONTBOLD):
d382 1
a382 1
		case (ESCAPE_FONTITALIC):
d384 1
a384 1
		case (ESCAPE_FONTBI):
d386 1
a386 1
		case (ESCAPE_FONTROMAN):
d390 1
a390 1
		case (ESCAPE_SKIPCHAR):
d403 1
a403 1
		case (ESCAPE_UNICODE):
d409 1
a409 1
		case (ESCAPE_NUMBERED):
d414 1
a414 1
		case (ESCAPE_SPECIAL):
d421 1
a421 1
		case (ESCAPE_NOSPACE):
a432 1

a440 1

d442 1
a442 1
print_otag(struct html *h, enum htmltag tag, 
d492 1
a492 1
		case (HTML_XHTML_1_0_STRICT):
a508 1

d512 1
a512 1
	
d517 1
a517 1
	} 
d528 1
a528 1
	case (HTML_HTML_4_01_STRICT):
d541 2
a542 2
	printf("<!DOCTYPE %s PUBLIC \"%s\" \"%s\">\n", 
			name, doctype, dtd);
d561 1
a561 1
	case (HTMLFONT_ITALIC):
d564 1
a564 1
	case (HTMLFONT_BOLD):
d567 1
a567 1
	case (HTMLFONT_BI):
a589 1

d596 1
a596 1
		/* 
a611 1

d620 1
a620 1
		/* 
d666 2
a667 2
	(void)vsnprintf(h->buf + (int)h->buflen, 
			BUFSIZ - h->buflen - 1, fmt, ap);
d687 1
a687 1
	
d692 1
a692 1
		case('I'):
d706 1
a706 2
buffmt_man(struct html *h, 
		const char *name, const char *sec)
d711 1
a711 1
	
d716 1
a716 1
		case('S'):
d719 1
a719 1
		case('N'):
@


1.33
log
@Implement the \: (optional line break) escape sequence,
documented in the Ossanna-Kernighan-Ritter troff manual
and also supported by groff.

Missing feature reported by Steffen Nurpmeso <sdaoden at gmail dot com>.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.32 2014/01/05 21:21:08 schwarze Exp $ */
d30 1
@


1.32
log
@Fix one case where a non-literal is used as format string.
Fix another case where a variable is formatted using the wrong type.
Patch from Joerg Sonnenberger <joerg@@NetBSD>.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.31 2013/08/08 20:07:24 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d330 2
a331 1
	static const char rejs[6] = { '\\', '<', '>', '&', ASCII_HYPH, '\0' };
d360 3
d365 2
@


1.31
log
@Implement the roff(7) font-escape sequence \f(BI "bold+italic".
This improves the formatting of about 40 base manuals
and reduces groff-mandoc formatting differences in base by about 5%.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.30 2012/05/28 13:00:51 schwarze Exp $ */
d721 1
a721 1
			bufcat_fmt(h, name);
@


1.30
log
@Implement the roff \z escape sequence, intended to output the next
character without advancing the cursor position; implement it to
simply skip the next character, as it will usually be overwritten.

With this change, the pod2man(1) preamble user-defined string \*:,
intended to render as a diaeresis or umlaut diacritic above the
preceding character, is rendered in a slightly less ugly way,
though still not correctly.  It was rendered as "z.." and is now
rendered as ".".

Given that the definition of \*: uses elaborate manual \h positioning,
there is little chance for mandoc(1) to ever render it correctly,
but at least we can refrain from printing out a spurious "z", and
we can make the \z do something semi-reasonable for easier cases.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.29 2011/10/09 17:59:56 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d234 3
d255 14
a268 4
	if (HTMLFONT_NONE != font)
		h->metaf = HTMLFONT_BOLD == font ?
			print_otag(h, TAG_B, 0, NULL) :
			print_otag(h, TAG_I, 0, NULL);
d379 2
d558 14
a571 4
	if (HTMLFONT_NONE != h->metac)
		h->metaf = HTMLFONT_BOLD == h->metac ?
			print_otag(h, TAG_B, 0, NULL) :
			print_otag(h, TAG_I, 0, NULL);
@


1.29
log
@Sync to version 1.12.0; all code by kristaps@@:
Implement .Rv in -Tman.
Let -man -Tman work a bit like cat(1).
Add the -Ofragment option to -T[x]html.
Minor fixes in -T[x]html.
Lots of apropos(1) and -Tman code cleanup.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.28 2011/07/08 17:47:54 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
d261 2
a262 2
	int		 ssz, sz;
	const char	*seq, *p;
d273 15
a287 4
	while (NULL != (p = strchr(cp, '\\'))) {
		sz += (int)(p - cp);
		++cp;
		switch (mandoc_escape(&cp, &seq, &ssz)) {
d295 7
a301 1
			sz++;
d307 1
a307 3

	assert(sz >= 0);
	return(sz + strlen(cp));
d322 6
d358 25
a399 13
			break;
		case (ESCAPE_FONT):
			/* FALLTHROUGH */
		case (ESCAPE_FONTPREV):
			/* FALLTHROUGH */
		case (ESCAPE_FONTBOLD):
			/* FALLTHROUGH */
		case (ESCAPE_FONTITALIC):
			/* FALLTHROUGH */
		case (ESCAPE_FONTROMAN):
			if (norecurse)
				break;
			print_metaf(h, esc);
@


1.28
log
@clean up .HP, .IP, .TP, .nf, and \c handling in -T[x]html;
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.27 2011/07/05 04:12:41 schwarze Exp $ */
d117 1
a117 1
	const char	*toks[4];
d123 2
a124 1
	toks[3] = NULL;
d142 3
@


1.27
log
@Sync to bsd.lv (all coded by kristaps@@):
 - mdoc(7): fix an assertion if the first line after .Bd -column
   starts with a blank, and some simplifications in mdoc_argv.c
 - man(7): literal mode ends at .SH and .SS (bug reported by naddy@@)
 - allow .RS/.RE blocks to nest (bug reported by dcoppa@@ and gsoares@@)
 - improve vertical spacing of man(7) blocks
 - roff(7): clear user-defined strings when starting a new file
 - correct ID tags in -T[x]html
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.26 2011/05/29 21:22:18 schwarze Exp $ */
d512 1
a512 1
	if ( ! print_encode(h, word, 0))
d515 2
@


1.26
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.25 2011/04/24 16:22:02 schwarze Exp $ */
a593 1
	h->buflen--;
@


1.25
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.24 2011/04/21 22:59:54 schwarze Exp $ */
d30 1
d93 12
a104 12
static	void		  print_num(struct html *, const char *, size_t);
static	void		  print_spec(struct html *, enum roffdeco,
				const char *, size_t);
static	void		  print_res(struct html *, const char *, size_t);
static	void		  print_ctag(struct html *, enum htmltag);
static	void		  print_doctype(struct html *);
static	void		  print_xmltype(struct html *);
static	int		  print_encode(struct html *, const char *, int);
static	void		  print_metaf(struct html *, enum roffdeco);
static	void		  print_attr(struct html *, 
				const char *, const char *);
static	void		 *ml_alloc(char *, enum htmltype);
d106 6
d129 1
a129 1
	h->symtab = chars_init(CHARS_HTML);
d179 1
a179 1
		chars_free(h->symtab);
a214 50
/* ARGSUSED */
static void
print_num(struct html *h, const char *p, size_t len)
{
	const char	*rhs;

	rhs = chars_num2char(p, len);
	if (rhs)
		putchar((int)*rhs);
}

static void
print_spec(struct html *h, enum roffdeco d, const char *p, size_t len)
{
	int		 cp;
	const char	*rhs;
	size_t		 sz;

	if ((cp = chars_spec2cp(h->symtab, p, len)) > 0) {
		printf("&#%d;", cp);
		return;
	} else if (-1 == cp && DECO_SSPECIAL == d) {
		fwrite(p, 1, len, stdout);
		return;
	} else if (-1 == cp)
		return;

	if (NULL != (rhs = chars_spec2str(h->symtab, p, len, &sz)))
		fwrite(rhs, 1, sz, stdout);
}


static void
print_res(struct html *h, const char *p, size_t len)
{
	int		 cp;
	const char	*rhs;
	size_t		 sz;

	if ((cp = chars_res2cp(h->symtab, p, len)) > 0) {
		printf("&#%d;", cp);
		return;
	} else if (-1 == cp)
		return;

	if (NULL != (rhs = chars_res2str(h->symtab, p, len, &sz)))
		fwrite(rhs, 1, sz, stdout);
}


d216 1
a216 1
print_metaf(struct html *h, enum roffdeco deco)
d221 1
a221 1
	case (DECO_PREVIOUS):
d224 1
a224 1
	case (DECO_ITALIC):
d227 1
a227 1
	case (DECO_BOLD):
d230 3
a232 1
	case (DECO_ROMAN):
d254 36
d295 1
a295 1
	int		 len, nospace;
d297 1
a297 1
	enum roffdeco	 deco;
d302 1
a302 1
	for (; *p; p++) {
d306 1
a306 2
		p += /* LINTED */
			sz;
d308 5
a312 1
		if ('<' == *p) {
d315 1
a315 1
		} else if ('>' == *p) {
d318 1
a318 1
		} else if ('&' == *p) {
d321 1
a321 7
		} else if (ASCII_HYPH == *p) {
			/*
			 * Note: "soft hyphens" aren't graphically
			 * displayed when not breaking the text; we want
			 * them to be displayed.
			 */
			/*printf("&#173;");*/
d324 1
a324 1
		} else if ('\0' == *p)
d326 1
d328 3
a330 2
		seq = ++p;
		len = a2roffdeco(&deco, &seq, &sz);
d332 18
a349 6
		switch (deco) {
		case (DECO_NUMBERED):
			print_num(h, seq, sz);
			break;
		case (DECO_RESERVED):
			print_res(h, seq, sz);
d351 1
a351 1
		case (DECO_SSPECIAL):
d353 1
a353 4
		case (DECO_SPECIAL):
			print_spec(h, deco, seq, sz);
			break;
		case (DECO_PREVIOUS):
d355 1
a355 1
		case (DECO_BOLD):
d357 1
a357 1
		case (DECO_ITALIC):
d359 1
a359 1
		case (DECO_ROMAN):
d362 5
a366 1
			print_metaf(h, deco);
a370 5

		p += len - 1;

		if (DECO_NOSPACE == deco && '\0' == *(p + 1))
			nospace = 1;
d433 1
a433 1
	/* Accomodate for XML "well-formed" singleton escaping. */
a465 1

a468 18

	print_xmltype(h);
	print_doctype(h);
}


static void
print_xmltype(struct html *h)
{

	if (HTML_XHTML_1_0_STRICT == h->type)
		puts("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
}


static void
print_doctype(struct html *h)
{
d480 1
a569 1

a577 1

d583 1
a583 1
	bufncat(h, ":", 1);
d585 1
a585 1
	bufncat(h, ";", 1);
a587 1

d592 3
a594 1
	bufncat(h, p, strlen(p));
a596 1

d598 1
a598 1
buffmt(struct html *h, const char *fmt, ...)
d609 1
a609 2

void
d613 2
a614 4
	if (h->buflen + sz > BUFSIZ - 1)
		sz = BUFSIZ - 1 - h->buflen;

	(void)strncat(h->buf, p, sz);
a617 1

d625 1
a641 1

d650 1
a650 1
	/* LINTED */
d658 1
a658 1
			buffmt(h, name);
a669 1

a673 1
	const char	*u;
d676 2
d679 1
a679 40
	switch (su->unit) {
	case (SCALE_CM):
		u = "cm";
		break;
	case (SCALE_IN):
		u = "in";
		break;
	case (SCALE_PC):
		u = "pc";
		break;
	case (SCALE_PT):
		u = "pt";
		break;
	case (SCALE_EM):
		u = "em";
		break;
	case (SCALE_MM):
		if (0 == (v /= 100))
			v = 1;
		u = "em";
		break;
	case (SCALE_EN):
		u = "ex";
		break;
	case (SCALE_BU):
		u = "ex";
		break;
	case (SCALE_VS):
		u = "em";
		break;
	default:
		u = "ex";
		break;
	}

	/* 
	 * XXX: the CSS spec isn't clear as to which types accept
	 * integer or real numbers, so we just make them all decimals.
	 */
	buffmt(h, "%s: %.2f%s;", p, v, u);
a681 1

d683 1
a683 1
html_idcat(char *dst, const char *src, int sz)
a684 3
	int		 ssz;

	assert(sz > 2);
d688 2
a689 20
	/* We can't start with a number (bah). */

	if ('#' == *dst) {
		dst++;
		sz--;
	}
	if ('\0' == *dst) {
		*dst++ = 'x';
		*dst = '\0';
		sz--;
	}

	for ( ; *dst != '\0' && sz; dst++, sz--)
		/* Jump to end. */ ;

	for ( ; *src != '\0' && sz > 1; src++) {
		ssz = snprintf(dst, (size_t)sz, "%.2x", *src);
		sz -= ssz;
		dst += ssz;
	}
@


1.24
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.23 2011/01/30 16:05:29 schwarze Exp $ */
a30 1
#include "chars.h"
a506 1

a510 4
	if (DELIM_CLOSE == mandoc_isdelim(word))
		if ( ! (HTML_IGNDELIM & h->flags))
			h->flags |= HTML_NOSPACE;

a537 3

	if (DELIM_OPEN == mandoc_isdelim(word))
		h->flags |= HTML_NOSPACE;
@


1.23
log
@Implement the \N'number' (numbered character) roff escape sequence.
Don't use it in new manuals, it is inherently non-portable, but we
need it for backward-compatibility with existing manuals, for example
in Xenocara driver pages.
ok kristaps@@ matthieu@@ jmc@@
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.22 2011/01/16 19:41:16 schwarze Exp $ */
d119 1
a119 5
	h = calloc(1, sizeof(struct html));
	if (NULL == h) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
d209 1
a209 1

a219 1

d395 1
a395 5
		t = malloc(sizeof(struct tag));
		if (NULL == t) {
			perror(NULL);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d513 3
a515 23
	if (word[0] && '\0' == word[1])
		switch (word[0]) {
		case('.'):
			/* FALLTHROUGH */
		case(','):
			/* FALLTHROUGH */
		case(';'):
			/* FALLTHROUGH */
		case(':'):
			/* FALLTHROUGH */
		case('?'):
			/* FALLTHROUGH */
		case('!'):
			/* FALLTHROUGH */
		case(')'):
			/* FALLTHROUGH */
		case(']'):
			if ( ! (HTML_IGNDELIM & h->flags))
				h->flags |= HTML_NOSPACE;
			break;
		default:
			break;
		}
d545 2
a546 14
	/* 
	 * Note that we don't process the pipe: the parser sees it as
	 * punctuation, but we don't in terms of typography.
	 */
	if (word[0] && '\0' == word[1])
		switch (word[0]) {
		case('('):
			/* FALLTHROUGH */
		case('['):
			h->flags |= HTML_NOSPACE;
			break;
		default:
			break;
		}
@


1.22
log
@Merge from bsd.lv, original commit message by kristaps@@:
Change how -Thtml behaves with tables: use multiple rows, with widths
set by COL, until an external macro is encountered.  At this point in
time, close out the table and process the macro.  When the first table
row is again re-encountered, re-start the table.  This requires a bit of
tracking added to "struct html", but the change is very small and
follows the logic of meta-fonts.  This all follows a bug-report by
joerg@@.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.21 2010/12/27 21:44:30 schwarze Exp $ */
d4 1
d93 1
d215 11
d345 3
@


1.21
log
@In case an ID attribute is written in pieces, only protect the first
piece with a prepended 'x', not each piece, such that quoted and
unquoted .Sh, .Ss, and .Sx arguments are compatible with each other.
Fixing a bug reported by Nicolas Joly <njoly at NetBSD dot org>,
avoiding a regression in my first patch as pointed out by njoly as well.
"feel free to do so" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.20 2010/12/25 13:23:03 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d89 1
d581 4
d587 2
d606 4
d612 2
@


1.20
log
@Yet another batch of -Thtml polishing from kristaps@@:
In particular, use <SMALL> for .SM and <CODE> for .Dl.
Use <B> for bold and <I> for italic in general.
Also call this mandoc 1.10.8 now, as it is functionally equivalent,
even though one one set of refactoring patches has not been merged
yet because it conflicts with our tbl(1) handling.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.19 2010/12/22 00:33:25 schwarze Exp $ */
d770 1
a770 1
	assert(sz);
d774 12
a787 8

	assert(sz > 2);

	/* We can't start with a number (bah). */

	*dst++ = 'x';
	*dst = '\0';
	sz--;
@


1.19
log
@More small -Thtml improvements by kristaps@@,
in particular, use <B>, <I> and <U> where appropriate.
Provide relative widths for header and footer lines.
Manuals: More concise short descriptions of output modes.
Correct a few places still talking about CSS2 to say CSS1.
Code examples should use .Dl, not .D1.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.18 2010/12/19 09:22:35 schwarze Exp $ */
d71 2
a72 7
	{"u",		0 }, /* TAG_U */
};

static	const char	*const htmlfonts[HTMLFONT_MAX] = {
	"roman",
	"bold",
	"italic"
a249 19
struct tag *
print_ofont(struct html *h, enum htmlfont font)
{
	struct htmlpair	 tag;

	h->metal = h->metac;
	h->metac = font;

	/* FIXME: DECO_ROMAN should just close out preexisting. */

	if (h->metaf && h->tags.head == h->metaf)
		print_tagq(h, h->metaf);

	PAIR_CLASS_INIT(&tag, htmlfonts[font]);
	h->metaf = print_otag(h, TAG_SPAN, 1, &tag);
	return(h->metaf);
}


d273 12
a284 1
	(void)print_ofont(h, font);
d472 1
a472 1
		printf("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
d539 6
d549 5
@


1.18
log
@Significant improvements to -Thtml by kristaps@@:
Use less <DIV>, use more <H1>, <H2>, <P>, <BR>, <PRE>, <UL>, <OL>, <DL> etc.
Triggered by input from Will Backman.
Remove CSS2 note in mandoc.1, which is no longer true.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.17 2010/10/01 21:38:26 schwarze Exp $ */
d69 3
d81 13
a93 14
	"http-equiv",
	"content",
	"name",
	"rel",
	"href",
	"type",
	"media",
	"class",
	"style",
	"width",
	"valign",
	"target",
	"id",
	"summary",
@


1.17
log
@* need a space before .No even if it starts with a closing delimiter
* slightly simplify .Pf *_IGNDELIM code, and share part of it with .No
* do not let opening delimiters fall out of the front of .Ns (from kristaps@@)
This fixes a few spacing issues in csh(1) and ksh(1).
OK kristaps@@
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.16 2010/09/27 21:25:28 schwarze Exp $ */
d56 1
d63 6
a126 1
	h->ords.head = NULL;
a166 1
	struct ord	*ord;
a170 5
	while ((ord = h->ords.head) != NULL) { 
		h->ords.head = ord->next;
		free(ord);
	}

d449 4
@


1.16
log
@Merge the last bits of 1.10.6 (released today), most were already in:
* ignore double-.Pp
* ignore .Pp before .Bd and .Bl (unless -compact in specified)
* avoid double blank line upon .Pp, .br and friends in literal context
* cast enums to int when passing them to exit(3) to please lint(1)
While merging, fix a regression introduced by kristaps@@:
Outside literal mode, double blank lines must both be printed.
To achieve this again after kristaps@@ improvements in 1.10.6,
treat such blank lines as .sp (instead of .Pp as in 1.10.5)
and drop .Pp before .sp just like dropping .Pp before .Pp.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.15 2010/08/20 00:53:35 schwarze Exp $ */
d550 2
@


1.15
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.14 2010/07/31 21:43:07 schwarze Exp $ */
d115 1
a115 1
		exit(MANDOCLEVEL_SYSERR);
d397 1
a397 1
			exit(MANDOCLEVEL_SYSERR);
@


1.14
log
@Merge bsd.lv version 1.10.5: last larger batch of bug fixes before release.
NOT including Kristaps' .Bd -literal changes which cause regressions.
Features:
* -Tpdf now fully working
Bugfixes:
* proper handling of quoted strings by .ds in roff(7)
* allow empty .Dd
* make .Sm start no-spacing after the first output word
* underline .Ad
* minor fixes in -Thtml
and some optimisations in terminal output.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.13 2010/07/25 18:05:54 schwarze Exp $ */
d115 1
a115 1
		exit(EXIT_FAILURE);
d397 1
a397 1
			exit(EXIT_FAILURE);
@


1.13
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.12 2010/07/13 01:09:12 schwarze Exp $ */
d418 2
@


1.12
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.11 2010/06/27 20:28:56 schwarze Exp $ */
d87 2
a88 1
static	void		  print_spec(struct html *, const char *, size_t);
d215 1
a215 1
print_spec(struct html *h, const char *p, size_t len)
d217 1
d221 8
a228 1
	rhs = chars_a2ascii(h->symtab, p, len, &sz);
d230 2
a231 3
	if (NULL == rhs) 
		return;
	fwrite(rhs, 1, sz, stdout);
d238 1
d242 5
a246 1
	rhs = chars_a2res(h->symtab, p, len, &sz);
d248 2
a249 3
	if (NULL == rhs)
		return;
	fwrite(rhs, 1, sz, stdout);
d345 2
d348 1
a348 1
			print_spec(h, seq, sz);
d416 3
d546 2
a547 1
		h->flags &= ~HTML_NOSPACE;
@


1.11
log
@Remove "pt" from struct roffsu, as CSS (the only reason it was there) is
unclear about which units accept floats/integers, which leads me to
assume that it handles either and rounds as appropriate.
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.10 2010/06/08 00:11:47 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d392 9
a400 2
		if ( ! (HTML_CLRLINE & htmltags[tag].flags))
			putchar(' ');
d490 1
a490 1
print_text(struct html *h, const char *p)
d493 2
a494 2
	if (*p && 0 == *(p + 1))
		switch (*p) {
d517 9
a525 2
	if ( ! (h->flags & HTML_NOSPACE))
		putchar(' ');
d527 2
a528 2
	assert(p);
	if ( ! print_encode(h, p, 0))
d535 2
a536 2
	if (*p && 0 == *(p + 1))
		switch (*p) {
@


1.10
log
@Merge more bits that will be going into 1.10.1:

Clean up vertical spacing in the SYNOPSIS, making the code much more
systematic; this doesn't solve all SYNOPSIS problems yet, in particular
not those related to keeps, indentation and the low-level .nr roff
instruction, but it's a nice step forward and i couldn't find relevant
regressions.  (from kristaps)

Besides,
* make the output width configurable (default: -Owidth=80) (kristaps)
* use mmap with MAP_SHARED (from Joerg Sonnenberger)
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.9 2010/05/26 02:39:58 schwarze Exp $ */
d717 5
a721 5
	if (su->pt)
		buffmt(h, "%s: %f%s;", p, v, u);
	else
		/* LINTED */
		buffmt(h, "%s: %d%s;", p, (int)v, u);
@


1.9
log
@When a word does not fully fit onto the output line, but it contains
at least one hyphen, we already had support for breaking the line a the
last fitting hyphen.  This patch improves this functionality by only
breaking at hyphens in free-form text, and by not breaking at hyphens
* at the beginning or end of a word   or
* immediately preceded or followed by another hyphen   or
* escaped by a preceding backslash.

Before this patch, differences in break-at-hyphen support were one
of the major sources of noise in automatic comparisons to mdoc(7)
groff output.  Now, the remaining differences are hard to find among
the noise coming from other sources.

Where there are still differences, what we do seems to be better than
what groff does, see e.g. the chio(1) exchange and position commands
for one of the now rare examples.

idea and coding by kristaps@@

Besides, this was the last substantial code difference left
between bsd.lv and openbsd.org.  We are now in full sync.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.8 2010/05/14 01:54:37 schwarze Exp $ */
a32 2

#define	UNCONST(a)	((void *)(uintptr_t)(const void *)(a))
@


1.8
log
@merge 1.9.24, keeping local patches; some changes:
* preserve multiple consecutive space characters in input
* do not restrict .Cd and .Rv to certain sections (requested by Joerg)
* do not run lookup() on quoted words
* enum return types for mdoc_args and mdoc_argv
* fix auto-closing of LINK tag in -Txhtml (from Daniel Friesel)
* various lint and manual fixes
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.7 2010/04/07 23:15:05 schwarze Exp $ */
d28 1
d296 1
d301 1
a301 1
		sz = strcspn(p, "\\<>&");
d316 9
a452 13
	const char	*decl;

	switch (h->type) {
	case (HTML_XHTML_1_0_STRICT):
		decl = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
		break;
	default:
		decl = NULL;
		break;
	}

	if (NULL == decl)
		return;
d454 2
a455 1
	printf("%s\n", decl);
@


1.7
log
@Merge the good parts of 1.9.23,
avoid the bad parts of 1.9.23, and keep local patches.

Input in general:
 * Basic handling of roff-style font escapes \f, \F.
 * Quoted punctuation does not count as punctuation.

mdoc(7) parser:
 * Make .Pf callable; noted by Claus Assmann.
 * Let .Bd and .Bl ignore unknown arguments; noted by deraadt@@.
 * Do not warn when .Er is used outside certain sections.
 * Replace mdoc_node_free[list] by mdoc_node_delete.
 * Replace #define by enum for rew*() return values.

man(7) parser:
 * When .TH is missing, use default section and date.

Output in general:
 * Curly braces do not count as punctuation.
 * No space after .Fl w/o args when a macro follows on the same line.

HTML output:
 * Unify PAIR_*_INIT macros, introduce new PAIR_ID_INIT().
 * Print whitespace after, not before .Vt .Fn .Ft .Fo.

Checked that all manuals in base still build.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.6 2010/02/18 02:11:25 schwarze Exp $ */
d53 1
a53 1
	{"link",	HTML_CLRLINE | HTML_NOSTACK}, /* TAG_LINK */
d520 4
@


1.6
log
@sync to release 1.9.15:
 * corrected .Vt handling (spotted by Joerg Sonnenberger)
 * corrected .Xr argument handling (based on my patch)
 * removed \\ escape sequence (because it is for low-level roff only)
 * warn about trailing whitespace (suggested by jmc@@)
 * -Txhtml support
 * and some general cleanup and doc improvements
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.5 2009/12/24 02:08:14 schwarze Exp $ */
a87 1

a505 2
			/* FALLTHROUGH */
		case('}'):
a524 2
			/* FALLTHROUGH */
		case('{'):
@


1.5
log
@sync to 1.9.14: rewrite escape sequence handling:
- new function a2roffdeco
- font modes (\f) only affect the current stack point
- implement scaling (\s)
- implement space suppression (\c)
- implement non-breaking space (\~) in -Tascii
- many manual improvements
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.4 2009/12/23 22:30:17 schwarze Exp $ */
a34 3
#define	DOCTYPE		"-//W3C//DTD HTML 4.01//EN"
#define	DTD		"http://www.w3.org/TR/html4/strict.dtd"

d40 1
d47 1
a47 1
	{"meta",	HTML_CLRLINE | HTML_NOSTACK}, /* TAG_META */
a51 1
	{"p",		HTML_CLRLINE}, /* TAG_P */
d54 1
a54 1
	{"br",		HTML_CLRLINE | HTML_NOSTACK}, /* TAG_LINK */
d57 1
a57 1
	{"col",		HTML_CLRLINE | HTML_NOSTACK}, /* TAG_COL */
a62 1
	{"base",	HTML_CLRLINE | HTML_NOSTACK}, /* TAG_BASE */
d92 2
d96 3
d101 2
a102 2
void *
html_alloc(char *outopts)
d119 1
d142 15
d353 9
d369 2
d387 2
d390 9
a398 5
	for (i = 0; i < sz; i++) {
		printf(" %s=\"", htmlattrs[p[i].key]);
		assert(p->val);
		(void)print_encode(h, p[i].val, 1);
		putchar('\"');
d400 12
a430 1
/* ARGSUSED */
d432 31
a462 1
print_gen_doctype(struct html *h)
d464 19
a482 2
	
	printf("<!DOCTYPE HTML PUBLIC \"%s\" \"%s\">", DOCTYPE, DTD);
@


1.4
log
@sync to 1.9.13: minor fixes:

correctness/functionality:
 - bugfix: properly ignore lines with only a dot in -man
 - bugfix: .Bl -ohang doesn't allow -width, warn about this
 - improve date string handling by new function mandoc_a2time
 - some HTML improvements
 - significant documentation additions in man.7 and mdoc.7

portability:
 - replace __dead by __attribute__((noreturn))
 - bugfix: correct .Dx rendering
 - some more library names for NetBSD

simplicity:
 - replace hand-rolled putchar(3)-loops by fwrite(3)
 - replace single-character printf(3) by putchar(3)
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.3 2009/12/22 23:58:00 schwarze Exp $ */
d69 7
a75 1
static	const char	 *const htmlattrs[ATTR_MAX] = {
d92 8
d199 1
a199 1
print_spec(struct html *h, const char *p, int len)
d204 1
a204 1
	rhs = chars_a2ascii(h->symtab, p, (size_t)len, &sz);
d213 1
a213 1
print_res(struct html *h, const char *p, int len)
d218 1
a218 1
	rhs = chars_a2res(h->symtab, p, (size_t)len, &sz);
d226 2
a227 2
static void
print_escape(struct html *h, const char **p)
d229 1
a229 2
	int		 j, type;
	const char	*wp;
d231 2
a232 2
	wp = *p;
	type = 1;
d234 1
a234 4
	if (0 == *(++wp)) {
		*p = wp;
		return;
	}
d236 2
a237 6
	if ('(' == *wp) {
		wp++;
		if (0 == *wp || 0 == *(wp + 1)) {
			*p = 0 == *wp ? wp : wp + 1;
			return;
		}
d239 4
a242 3
		print_spec(h, wp, 2);
		*p = ++wp;
		return;
a243 5
	} else if ('*' == *wp) {
		if (0 == *(++wp)) {
			*p = wp;
			return;
		}
d245 4
a248 7
		switch (*wp) {
		case ('('):
			wp++;
			if (0 == *wp || 0 == *(wp + 1)) {
				*p = 0 == *wp ? wp : wp + 1;
				return;
			}
d250 16
a265 41
			print_res(h, wp, 2);
			*p = ++wp;
			return;
		case ('['):
			type = 0;
			break;
		default:
			print_res(h, wp, 1);
			*p = wp;
			return;
		}
	
	} else if ('f' == *wp) {
		if (0 == *(++wp)) {
			*p = wp;
			return;
		}

		switch (*wp) {
		case ('B'):
			/* TODO */
			break;
		case ('I'):
			/* TODO */
			break;
		case ('P'):
			/* FALLTHROUGH */
		case ('R'):
			/* TODO */
			break;
		default:
			break;
		}

		*p = wp;
		return;

	} else if ('[' != *wp) {
		print_spec(h, wp, 1);
		*p = wp;
		return;
d268 1
a268 15
	wp++;
	for (j = 0; *wp && ']' != *wp; wp++, j++)
		/* Loop... */ ;

	if (0 == *wp) {
		*p = wp;
		return;
	}

	if (type)
		print_spec(h, wp - j, j);
	else
		print_res(h, wp - j, j);

	*p = wp;
d272 2
a273 2
static void
print_encode(struct html *h, const char *p)
d276 5
d289 8
a296 2
		if ('\\' == *p) {
			print_escape(h, &p);
d301 29
a329 6
		if ('<' == *p)
			printf("&lt;");
		else if ('>' == *p)
			printf("&gt;");
		else if ('&' == *p)
			printf("&amp;");
d331 2
d363 1
a363 1
		print_encode(h, p[i].val);
a368 5
	if (HTML_CLRLINE & htmltags[tag].flags)
		h->flags |= HTML_NEWLINE;
	else
		h->flags &= ~HTML_NEWLINE;

a372 1
/* ARGSUSED */
a379 1
		h->flags |= HTML_NEWLINE;
d381 1
a381 2
	} else
		h->flags &= ~HTML_NEWLINE;
d427 3
a429 5
	h->flags &= ~HTML_NOSPACE;
	h->flags &= ~HTML_NEWLINE;

	if (p)
		print_encode(h, p);
d452 2
d471 2
@


1.3
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.2 2009/10/27 21:40:07 schwarze Exp $ */
d21 1
a22 1
#include <stdarg.h>
a187 1
	int		 i;
d194 1
a194 2
	for (i = 0; i < (int)sz; i++) 
		putchar(rhs[i]);
a201 1
	int		 i;
d208 1
a208 2
	for (i = 0; i < (int)sz; i++) 
		putchar(rhs[i]);
d315 1
d318 6
d327 4
a330 3
		}
		switch (*p) {
		case ('<'):
d332 1
a332 2
			break;
		case ('>'):
d334 1
a334 2
			break;
		case ('&'):
a335 5
			break;
		default:
			putchar(*p);
			break;
		}
d361 1
a361 1
			printf(" ");
d368 1
a368 1
		printf("\"");
d370 1
a370 1
	printf(">");
d391 1
a391 1
		printf("\n");
d437 1
a437 1
		printf(" ");
@


1.2
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.1 2009/10/21 19:13:50 schwarze Exp $ */
d20 1
a20 1
#include <err.h>
d83 1
d98 5
a102 2
	if (NULL == (h = calloc(1, sizeof(struct html))))
		return(NULL);
d106 1
a106 5

	if (NULL == (h->symtab = chars_init(CHARS_HTML))) {
		free(h);
		return(NULL);
	}
d351 5
a355 2
		if (NULL == (t = malloc(sizeof(struct tag))))
			err(EXIT_FAILURE, "malloc");
d391 1
a391 1
	if (HTML_CLRLINE & htmltags[tag].flags)
a392 1
	if (HTML_CLRLINE & htmltags[tag].flags)
d394 2
a395 1
	else
d649 27
@


1.1
log
@sync to 1.9.9, featuring:
 * -Thtml output mode
 * roff scaling units
 * and some minor fixes
for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.65 2009/10/20 05:45:21 kristaps Exp $ */
a17 1
#include <sys/queue.h>
d100 2
a101 2
	SLIST_INIT(&h->tags);
	SLIST_INIT(&h->ords);
d136 2
a137 3
	while ( ! SLIST_EMPTY(&h->ords)) {
		ord = SLIST_FIRST(&h->ords);
		SLIST_REMOVE_HEAD(&h->ords, entry);
d141 2
a142 3
	while ( ! SLIST_EMPTY(&h->tags)) {
		tag = SLIST_FIRST(&h->tags);
		SLIST_REMOVE_HEAD(&h->tags, entry);
d354 2
a355 1
		SLIST_INSERT_HEAD(&h->tags, t, entry);
d465 1
a465 2
	while ( ! SLIST_EMPTY(&h->tags)) {
		tag = SLIST_FIRST(&h->tags);
d467 1
a467 1
		SLIST_REMOVE_HEAD(&h->tags, entry);
d480 1
a480 2
	while ( ! SLIST_EMPTY(&h->tags)) {
		tag = SLIST_FIRST(&h->tags);
d484 1
a484 1
		SLIST_REMOVE_HEAD(&h->tags, entry);
@

