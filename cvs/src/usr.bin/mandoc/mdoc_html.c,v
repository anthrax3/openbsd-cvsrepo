head	1.165;
access;
symbols
	OPENBSD_6_1:1.153.0.4
	OPENBSD_6_1_BASE:1.153
	OPENBSD_6_0:1.115.0.4
	OPENBSD_6_0_BASE:1.115
	OPENBSD_5_9:1.115.0.2
	OPENBSD_5_9_BASE:1.115
	OPENBSD_5_8:1.107.0.4
	OPENBSD_5_8_BASE:1.107
	OPENBSD_5_7:1.101.0.2
	OPENBSD_5_7_BASE:1.101
	OPENBSD_5_6:1.75.0.4
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.69.0.4
	OPENBSD_5_5_BASE:1.69
	OPENBSD_5_4:1.67.0.4
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.67.0.2
	OPENBSD_5_3_BASE:1.67
	OPENBSD_5_2:1.65.0.4
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.65
	OPENBSD_5_1:1.65.0.2
	OPENBSD_5_0:1.59.0.2
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.52.0.2
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8;
locks; strict;
comment	@ * @;


1.165
date	2017.06.19.12.53.50;	author schwarze;	state Exp;
branches;
next	1.164;
commitid	oIynhxnvb749uZCP;

1.164
date	2017.05.30.16.31.25;	author schwarze;	state Exp;
branches;
next	1.163;
commitid	Z47iu6szjBeacLe1;

1.163
date	2017.05.17.17.53.48;	author schwarze;	state Exp;
branches;
next	1.162;
commitid	a179nI3c3GP4KuZb;

1.162
date	2017.05.12.17.56.39;	author schwarze;	state Exp;
branches;
next	1.161;
commitid	2jQy7OGiwTB74dOa;

1.161
date	2017.05.09.14.09.37;	author schwarze;	state Exp;
branches;
next	1.160;
commitid	lMrRruJRFJONCC2s;

1.160
date	2017.05.05.15.16.25;	author schwarze;	state Exp;
branches;
next	1.159;
commitid	sNJdFUhzoVfGBx2p;

1.159
date	2017.05.05.13.17.04;	author schwarze;	state Exp;
branches;
next	1.158;
commitid	GvSRKa33jIoa4JAJ;

1.158
date	2017.05.05.02.06.17;	author schwarze;	state Exp;
branches;
next	1.157;
commitid	JMX1RJlA2uFuu13l;

1.157
date	2017.05.04.22.07.44;	author schwarze;	state Exp;
branches;
next	1.156;
commitid	hU9bJPcS66QLg54n;

1.156
date	2017.05.04.17.48.24;	author schwarze;	state Exp;
branches;
next	1.155;
commitid	RHQLdCAdHKxKe8Eu;

1.155
date	2017.04.24.23.06.09;	author schwarze;	state Exp;
branches;
next	1.154;
commitid	2CfzvK3gmiJH7vY0;

1.154
date	2017.04.17.12.52.00;	author schwarze;	state Exp;
branches;
next	1.153;
commitid	kcFZlUR2Kn46gi6m;

1.153
date	2017.03.17.12.06.02;	author schwarze;	state Exp;
branches;
next	1.152;
commitid	7zoCzbhQdxe8xmSR;

1.152
date	2017.03.15.11.29.50;	author schwarze;	state Exp;
branches;
next	1.151;
commitid	0AJYQsnYnWohs8XM;

1.151
date	2017.03.14.01.34.57;	author schwarze;	state Exp;
branches;
next	1.150;
commitid	ki0xXqZ5DvGDd2YD;

1.150
date	2017.03.13.20.22.11;	author schwarze;	state Exp;
branches;
next	1.149;
commitid	62dom41MVdP8QJat;

1.149
date	2017.03.13.19.01.14;	author schwarze;	state Exp;
branches;
next	1.148;
commitid	HxogisTBPpNML57P;

1.148
date	2017.03.03.13.55.06;	author schwarze;	state Exp;
branches;
next	1.147;
commitid	ebZHhO3JQ20kqPTN;

1.147
date	2017.02.22.08.52.24;	author schwarze;	state Exp;
branches;
next	1.146;
commitid	Jgv9Djg3T26pVVjM;

1.146
date	2017.02.16.02.59.42;	author schwarze;	state Exp;
branches;
next	1.145;
commitid	Qmey25xun8rVuoB9;

1.145
date	2017.02.06.03.41.44;	author schwarze;	state Exp;
branches;
next	1.144;
commitid	FiEZU00RcX3pLlUS;

1.144
date	2017.02.05.21.00.18;	author schwarze;	state Exp;
branches;
next	1.143;
commitid	gmO6c5sNtRj7lBvY;

1.143
date	2017.02.05.20.34.47;	author schwarze;	state Exp;
branches;
next	1.142;
commitid	mnyRXE8dwwBT41XR;

1.142
date	2017.02.05.20.21.17;	author schwarze;	state Exp;
branches;
next	1.141;
commitid	k3leX1WuwjRY1lpC;

1.141
date	2017.02.05.19.29.03;	author schwarze;	state Exp;
branches;
next	1.140;
commitid	b6Pprk9VRxuYIyVr;

1.140
date	2017.02.05.18.13.28;	author schwarze;	state Exp;
branches;
next	1.139;
commitid	LLN2XeSKb4BTOEt6;

1.139
date	2017.01.29.14.02.19;	author schwarze;	state Exp;
branches;
next	1.138;
commitid	kwoDToz7gzAquXDa;

1.138
date	2017.01.28.22.36.17;	author schwarze;	state Exp;
branches;
next	1.137;
commitid	468TGMIlZyF2dLh1;

1.137
date	2017.01.28.18.42.10;	author schwarze;	state Exp;
branches;
next	1.136;
commitid	Xym8tAETLGhe1Dd2;

1.136
date	2017.01.25.02.14.41;	author schwarze;	state Exp;
branches;
next	1.135;
commitid	t5qXBiFCvZnIxlr1;

1.135
date	2017.01.21.02.09.49;	author schwarze;	state Exp;
branches;
next	1.134;
commitid	5oT95Ypcyb9YajzC;

1.134
date	2017.01.21.01.20.29;	author schwarze;	state Exp;
branches;
next	1.133;
commitid	t1CIT40aRIdTYb2t;

1.133
date	2017.01.20.23.50.59;	author schwarze;	state Exp;
branches;
next	1.132;
commitid	28q3y1yOo9OK4SqA;

1.132
date	2017.01.20.21.37.52;	author schwarze;	state Exp;
branches;
next	1.131;
commitid	AZj7WIV6cqyDaui9;

1.131
date	2017.01.20.19.58.00;	author schwarze;	state Exp;
branches;
next	1.130;
commitid	wlAS1rvF5OLfubQS;

1.130
date	2017.01.19.16.56.53;	author schwarze;	state Exp;
branches;
next	1.129;
commitid	jvwd5JdpRKFkEWTt;

1.129
date	2017.01.19.15.48.34;	author schwarze;	state Exp;
branches;
next	1.128;
commitid	55lrah2DGrMZhkus;

1.128
date	2017.01.19.15.27.26;	author schwarze;	state Exp;
branches;
next	1.127;
commitid	t4IwDKuwDsVdECRx;

1.127
date	2017.01.19.13.34.59;	author schwarze;	state Exp;
branches;
next	1.126;
commitid	kkzxtGlbuEtTMCNs;

1.126
date	2017.01.19.01.00.11;	author schwarze;	state Exp;
branches;
next	1.125;
commitid	JaaPsBMnLuMI8auG;

1.125
date	2017.01.18.19.22.18;	author schwarze;	state Exp;
branches;
next	1.124;
commitid	rkOTHV44amzifb9Y;

1.124
date	2017.01.17.15.32.39;	author schwarze;	state Exp;
branches;
next	1.123;
commitid	bt3XYYmdm9H0zf44;

1.123
date	2017.01.17.01.47.46;	author schwarze;	state Exp;
branches;
next	1.122;
commitid	Nv06v3QGWa6dYYKr;

1.122
date	2017.01.11.17.39.45;	author schwarze;	state Exp;
branches;
next	1.121;
commitid	2X81lVBLl8eAHRVh;

1.121
date	2017.01.10.23.36.24;	author schwarze;	state Exp;
branches;
next	1.120;
commitid	1NsxjVXtIEKZm6T7;

1.120
date	2017.01.10.21.54.34;	author schwarze;	state Exp;
branches;
next	1.119;
commitid	iaEy6J4gJ8kh18cm;

1.119
date	2017.01.10.13.46.53;	author schwarze;	state Exp;
branches;
next	1.118;
commitid	aFt8sLe7F06PjFYh;

1.118
date	2017.01.10.12.54.27;	author schwarze;	state Exp;
branches;
next	1.117;
commitid	vzXxeQWxUqXTMW9w;

1.117
date	2017.01.09.12.48.52;	author schwarze;	state Exp;
branches;
next	1.116;
commitid	o9wwy4GDTotjNHIR;

1.116
date	2017.01.08.22.51.53;	author schwarze;	state Exp;
branches;
next	1.115;
commitid	YpQrBWqKHL1Gmy9P;

1.115
date	2016.01.08.17.48.04;	author schwarze;	state Exp;
branches;
next	1.114;
commitid	DoGoemryKYV644MI;

1.114
date	2015.12.25.20.43.04;	author bentley;	state Exp;
branches;
next	1.113;
commitid	oXOV1HleA5uLxibU;

1.113
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.112;
commitid	Ql2ha5NS80pwfGNT;

1.112
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.111;
commitid	hxQV8O1pNUaef4ir;

1.111
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.110;
commitid	191tWtskbsgcpQqV;

1.110
date	2015.09.26.00.32.17;	author schwarze;	state Exp;
branches;
next	1.109;
commitid	5epv1szKAX89Qfyx;

1.109
date	2015.09.26.00.18.04;	author schwarze;	state Exp;
branches;
next	1.108;
commitid	OIzCXWKxlmIB6MzW;

1.108
date	2015.08.30.18.59.44;	author schwarze;	state Exp;
branches;
next	1.107;
commitid	bY93y4SZstAjApJT;

1.107
date	2015.04.18.17.50.02;	author schwarze;	state Exp;
branches;
next	1.106;
commitid	sjmmdLSx1e3Vat0h;

1.106
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.105;
commitid	6MYJ7cd8mhJ77AGH;

1.105
date	2015.04.16.20.21.08;	author schwarze;	state Exp;
branches;
next	1.104;
commitid	Jb3Wcu2p9qsmylcG;

1.104
date	2015.04.02.23.47.43;	author schwarze;	state Exp;
branches;
next	1.103;
commitid	RJFkOLiS9gBqEEDl;

1.103
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.102;
commitid	Rfx1oTaH3hZ7Zcyf;

1.102
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.101;
commitid	lmErjWY2O9ooA6RY;

1.101
date	2015.03.03.21.09.25;	author schwarze;	state Exp;
branches;
next	1.100;
commitid	izwoW6RxyHdvv5wj;

1.100
date	2015.02.12.12.20.47;	author schwarze;	state Exp;
branches;
next	1.99;
commitid	SViaEKzwzmf0o0kW;

1.99
date	2015.02.11.14.14.53;	author schwarze;	state Exp;
branches;
next	1.98;
commitid	2V8eDQf8fVyAwXBZ;

1.98
date	2015.02.05.01.46.38;	author schwarze;	state Exp;
branches;
next	1.97;
commitid	Whyrd7T544leDR65;

1.97
date	2015.02.05.00.13.34;	author schwarze;	state Exp;
branches;
next	1.96;
commitid	yNql0K85SrSgftGW;

1.96
date	2015.02.01.23.10.15;	author schwarze;	state Exp;
branches;
next	1.95;
commitid	d1ys3bKakrrT671d;

1.95
date	2015.01.30.22.04.15;	author schwarze;	state Exp;
branches;
next	1.94;
commitid	EStyTVNpkesjWq58;

1.94
date	2015.01.23.14.19.52;	author schwarze;	state Exp;
branches;
next	1.93;
commitid	XkcvCG1NCY9WGWyO;

1.93
date	2014.12.23.13.48.15;	author schwarze;	state Exp;
branches;
next	1.92;
commitid	gQAVpbNdyny1vBnL;

1.92
date	2014.12.23.09.31.17;	author schwarze;	state Exp;
branches;
next	1.91;
commitid	SXZbldG8wiiZaqvE;

1.91
date	2014.12.02.10.07.17;	author schwarze;	state Exp;
branches;
next	1.90;
commitid	G1dK13T4nePhhgx3;

1.90
date	2014.12.01.08.05.02;	author schwarze;	state Exp;
branches;
next	1.89;
commitid	dkxNPoJe0koFMMLd;

1.89
date	2014.11.30.05.28.00;	author schwarze;	state Exp;
branches;
next	1.88;
commitid	4gOj8tbqcpkeLVbt;

1.88
date	2014.11.27.22.27.40;	author schwarze;	state Exp;
branches;
next	1.87;
commitid	5z09nX8VCSvBpGIv;

1.87
date	2014.11.27.16.20.27;	author schwarze;	state Exp;
branches;
next	1.86;
commitid	snF2JxsotuPud6ts;

1.86
date	2014.11.19.21.59.19;	author schwarze;	state Exp;
branches;
next	1.85;
commitid	im0MTOZhKZYRJTHJ;

1.85
date	2014.11.17.06.44.35;	author schwarze;	state Exp;
branches;
next	1.84;
commitid	eO1CUhWjZNit4m47;

1.84
date	2014.10.30.20.05.33;	author schwarze;	state Exp;
branches;
next	1.83;
commitid	0MyCvIn2JIoyqJkI;

1.83
date	2014.10.07.18.17.05;	author schwarze;	state Exp;
branches;
next	1.82;
commitid	ovhOTvwzuIxZwsAn;

1.82
date	2014.09.17.19.53.35;	author schwarze;	state Exp;
branches;
next	1.81;
commitid	yu4CTBzbPSexzENm;

1.81
date	2014.08.21.12.56.24;	author schwarze;	state Exp;
branches;
next	1.80;
commitid	Y0pln4y7V0yebwer;

1.80
date	2014.08.14.00.29.12;	author schwarze;	state Exp;
branches;
next	1.79;
commitid	uJL3CbZ4GrgMUhuu;

1.79
date	2014.08.13.15.19.24;	author schwarze;	state Exp;
branches;
next	1.78;
commitid	BUSBmHGCSGSyXokp;

1.78
date	2014.08.08.16.17.09;	author schwarze;	state Exp;
branches;
next	1.77;
commitid	TLMAnDXVMoqLltgG;

1.77
date	2014.08.08.16.00.23;	author schwarze;	state Exp;
branches;
next	1.76;
commitid	m0QaUWeqjuHsvBSO;

1.76
date	2014.08.08.15.10.14;	author schwarze;	state Exp;
branches;
next	1.75;
commitid	V6V8vpTM0RQ4gS7I;

1.75
date	2014.07.02.19.54.39;	author schwarze;	state Exp;
branches;
next	1.74;
commitid	Yt0K01y5ZeXGGSxs;

1.74
date	2014.07.02.03.47.07;	author schwarze;	state Exp;
branches;
next	1.73;
commitid	p4pNII1v0bYCswy0;

1.73
date	2014.04.23.16.07.06;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2014.04.20.20.17.36;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2013.12.24.20.45.21;	author schwarze;	state Exp;
branches;
next	1.68;

1.68
date	2013.12.24.19.10.34;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2012.11.17.00.25.20;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2012.08.12.06.04.09;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	2011.11.03.20.32.33;	author schwarze;	state Exp;
branches;
next	1.64;

1.64
date	2011.10.16.12.18.32;	author schwarze;	state Exp;
branches;
next	1.63;

1.63
date	2011.10.09.22.10.51;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2011.10.09.17.59.56;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2011.07.05.04.12.41;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2011.06.18.12.40.57;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2011.03.20.23.36.42;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2011.03.07.01.35.33;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2011.02.06.22.56.45;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2011.02.06.17.33.20;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2011.01.31.03.04.26;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2011.01.30.18.28.01;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2011.01.16.19.41.16;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.16.02.56.47;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2011.01.09.16.31.46;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2010.12.29.00.47.31;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2010.12.25.13.23.03;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2010.12.22.00.33.25;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2010.12.19.12.18.15;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2010.12.19.09.22.35;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2010.12.06.22.10.13;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2010.12.01.22.02.29;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2010.10.23.23.30.41;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2010.10.23.16.08.36;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2010.10.16.13.38.29;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2010.10.01.21.38.26;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.27.21.25.28;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2010.09.26.18.55.22;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.26.18.23.54;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.20.20.02.27;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2010.08.20.00.53.35;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.07.17.26.11;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.31.21.43.07;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.29.17.10.29;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.27.21.54.42;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.26.17.56.43;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.08.00.11.47;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.06.20.30.08;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.24.12.33.06;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.24.00.00.10;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.23.22.45.00;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2010.05.23.20.05.43;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2010.05.15.18.25.51;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.14.19.52.43;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.14.14.47.44;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.08.02.10.09;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2010.04.07.23.15.05;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.04.00.00.12;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.03.17.06.19;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.02.00.38.59;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.18.02.11.26;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2010.01.02.02.42.06;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.24.02.08.14;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.23.22.30.17;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.10.21.19.13.50;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.165
log
@Fix a regression in the previous revision:
When there is no link description, reuse the URI.
Reported by tj@@ and bentley@@.
@
text
@/*	$OpenBSD: mdoc_html.c,v 1.164 2017/05/30 16:31:25 schwarze Exp $ */
/*
 * Copyright (c) 2008-2011, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2014, 2015, 2016, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "mandoc_aux.h"
#include "roff.h"
#include "mdoc.h"
#include "out.h"
#include "html.h"
#include "main.h"

#define	INDENT		 5

#define	MDOC_ARGS	  const struct roff_meta *meta, \
			  struct roff_node *n, \
			  struct html *h

#ifndef MIN
#define	MIN(a,b)	((/*CONSTCOND*/(a)<(b))?(a):(b))
#endif

struct	htmlmdoc {
	int		(*pre)(MDOC_ARGS);
	void		(*post)(MDOC_ARGS);
};

static	char		 *cond_id(const struct roff_node *);
static	void		  print_mdoc_head(MDOC_ARGS);
static	void		  print_mdoc_node(MDOC_ARGS);
static	void		  print_mdoc_nodelist(MDOC_ARGS);
static	void		  synopsis_pre(struct html *,
				const struct roff_node *);

static	void		  mdoc_root_post(MDOC_ARGS);
static	int		  mdoc_root_pre(MDOC_ARGS);

static	void		  mdoc__x_post(MDOC_ARGS);
static	int		  mdoc__x_pre(MDOC_ARGS);
static	int		  mdoc_ad_pre(MDOC_ARGS);
static	int		  mdoc_an_pre(MDOC_ARGS);
static	int		  mdoc_ap_pre(MDOC_ARGS);
static	int		  mdoc_ar_pre(MDOC_ARGS);
static	int		  mdoc_bd_pre(MDOC_ARGS);
static	int		  mdoc_bf_pre(MDOC_ARGS);
static	void		  mdoc_bk_post(MDOC_ARGS);
static	int		  mdoc_bk_pre(MDOC_ARGS);
static	int		  mdoc_bl_pre(MDOC_ARGS);
static	int		  mdoc_cd_pre(MDOC_ARGS);
static	int		  mdoc_cm_pre(MDOC_ARGS);
static	int		  mdoc_d1_pre(MDOC_ARGS);
static	int		  mdoc_dv_pre(MDOC_ARGS);
static	int		  mdoc_fa_pre(MDOC_ARGS);
static	int		  mdoc_fd_pre(MDOC_ARGS);
static	int		  mdoc_fl_pre(MDOC_ARGS);
static	int		  mdoc_fn_pre(MDOC_ARGS);
static	int		  mdoc_ft_pre(MDOC_ARGS);
static	int		  mdoc_em_pre(MDOC_ARGS);
static	void		  mdoc_eo_post(MDOC_ARGS);
static	int		  mdoc_eo_pre(MDOC_ARGS);
static	int		  mdoc_er_pre(MDOC_ARGS);
static	int		  mdoc_ev_pre(MDOC_ARGS);
static	int		  mdoc_ex_pre(MDOC_ARGS);
static	void		  mdoc_fo_post(MDOC_ARGS);
static	int		  mdoc_fo_pre(MDOC_ARGS);
static	int		  mdoc_ic_pre(MDOC_ARGS);
static	int		  mdoc_igndelim_pre(MDOC_ARGS);
static	int		  mdoc_in_pre(MDOC_ARGS);
static	int		  mdoc_it_pre(MDOC_ARGS);
static	int		  mdoc_lb_pre(MDOC_ARGS);
static	int		  mdoc_li_pre(MDOC_ARGS);
static	int		  mdoc_lk_pre(MDOC_ARGS);
static	int		  mdoc_mt_pre(MDOC_ARGS);
static	int		  mdoc_ms_pre(MDOC_ARGS);
static	int		  mdoc_nd_pre(MDOC_ARGS);
static	int		  mdoc_nm_pre(MDOC_ARGS);
static	int		  mdoc_no_pre(MDOC_ARGS);
static	int		  mdoc_ns_pre(MDOC_ARGS);
static	int		  mdoc_pa_pre(MDOC_ARGS);
static	void		  mdoc_pf_post(MDOC_ARGS);
static	int		  mdoc_pp_pre(MDOC_ARGS);
static	void		  mdoc_quote_post(MDOC_ARGS);
static	int		  mdoc_quote_pre(MDOC_ARGS);
static	int		  mdoc_rs_pre(MDOC_ARGS);
static	int		  mdoc_sh_pre(MDOC_ARGS);
static	int		  mdoc_skip_pre(MDOC_ARGS);
static	int		  mdoc_sm_pre(MDOC_ARGS);
static	int		  mdoc_ss_pre(MDOC_ARGS);
static	int		  mdoc_st_pre(MDOC_ARGS);
static	int		  mdoc_sx_pre(MDOC_ARGS);
static	int		  mdoc_sy_pre(MDOC_ARGS);
static	int		  mdoc_va_pre(MDOC_ARGS);
static	int		  mdoc_vt_pre(MDOC_ARGS);
static	int		  mdoc_xr_pre(MDOC_ARGS);
static	int		  mdoc_xx_pre(MDOC_ARGS);

static	const struct htmlmdoc __mdocs[MDOC_MAX - MDOC_Dd] = {
	{NULL, NULL}, /* Dd */
	{NULL, NULL}, /* Dt */
	{NULL, NULL}, /* Os */
	{mdoc_sh_pre, NULL }, /* Sh */
	{mdoc_ss_pre, NULL }, /* Ss */
	{mdoc_pp_pre, NULL}, /* Pp */
	{mdoc_d1_pre, NULL}, /* D1 */
	{mdoc_d1_pre, NULL}, /* Dl */
	{mdoc_bd_pre, NULL}, /* Bd */
	{NULL, NULL}, /* Ed */
	{mdoc_bl_pre, NULL}, /* Bl */
	{NULL, NULL}, /* El */
	{mdoc_it_pre, NULL}, /* It */
	{mdoc_ad_pre, NULL}, /* Ad */
	{mdoc_an_pre, NULL}, /* An */
	{mdoc_ap_pre, NULL}, /* Ap */
	{mdoc_ar_pre, NULL}, /* Ar */
	{mdoc_cd_pre, NULL}, /* Cd */
	{mdoc_cm_pre, NULL}, /* Cm */
	{mdoc_dv_pre, NULL}, /* Dv */
	{mdoc_er_pre, NULL}, /* Er */
	{mdoc_ev_pre, NULL}, /* Ev */
	{mdoc_ex_pre, NULL}, /* Ex */
	{mdoc_fa_pre, NULL}, /* Fa */
	{mdoc_fd_pre, NULL}, /* Fd */
	{mdoc_fl_pre, NULL}, /* Fl */
	{mdoc_fn_pre, NULL}, /* Fn */
	{mdoc_ft_pre, NULL}, /* Ft */
	{mdoc_ic_pre, NULL}, /* Ic */
	{mdoc_in_pre, NULL}, /* In */
	{mdoc_li_pre, NULL}, /* Li */
	{mdoc_nd_pre, NULL}, /* Nd */
	{mdoc_nm_pre, NULL}, /* Nm */
	{mdoc_quote_pre, mdoc_quote_post}, /* Op */
	{mdoc_ft_pre, NULL}, /* Ot */
	{mdoc_pa_pre, NULL}, /* Pa */
	{mdoc_ex_pre, NULL}, /* Rv */
	{mdoc_st_pre, NULL}, /* St */
	{mdoc_va_pre, NULL}, /* Va */
	{mdoc_vt_pre, NULL}, /* Vt */
	{mdoc_xr_pre, NULL}, /* Xr */
	{mdoc__x_pre, mdoc__x_post}, /* %A */
	{mdoc__x_pre, mdoc__x_post}, /* %B */
	{mdoc__x_pre, mdoc__x_post}, /* %D */
	{mdoc__x_pre, mdoc__x_post}, /* %I */
	{mdoc__x_pre, mdoc__x_post}, /* %J */
	{mdoc__x_pre, mdoc__x_post}, /* %N */
	{mdoc__x_pre, mdoc__x_post}, /* %O */
	{mdoc__x_pre, mdoc__x_post}, /* %P */
	{mdoc__x_pre, mdoc__x_post}, /* %R */
	{mdoc__x_pre, mdoc__x_post}, /* %T */
	{mdoc__x_pre, mdoc__x_post}, /* %V */
	{NULL, NULL}, /* Ac */
	{mdoc_quote_pre, mdoc_quote_post}, /* Ao */
	{mdoc_quote_pre, mdoc_quote_post}, /* Aq */
	{mdoc_xx_pre, NULL}, /* At */
	{NULL, NULL}, /* Bc */
	{mdoc_bf_pre, NULL}, /* Bf */
	{mdoc_quote_pre, mdoc_quote_post}, /* Bo */
	{mdoc_quote_pre, mdoc_quote_post}, /* Bq */
	{mdoc_xx_pre, NULL}, /* Bsx */
	{mdoc_xx_pre, NULL}, /* Bx */
	{mdoc_skip_pre, NULL}, /* Db */
	{NULL, NULL}, /* Dc */
	{mdoc_quote_pre, mdoc_quote_post}, /* Do */
	{mdoc_quote_pre, mdoc_quote_post}, /* Dq */
	{NULL, NULL}, /* Ec */ /* FIXME: no space */
	{NULL, NULL}, /* Ef */
	{mdoc_em_pre, NULL}, /* Em */
	{mdoc_eo_pre, mdoc_eo_post}, /* Eo */
	{mdoc_xx_pre, NULL}, /* Fx */
	{mdoc_ms_pre, NULL}, /* Ms */
	{mdoc_no_pre, NULL}, /* No */
	{mdoc_ns_pre, NULL}, /* Ns */
	{mdoc_xx_pre, NULL}, /* Nx */
	{mdoc_xx_pre, NULL}, /* Ox */
	{NULL, NULL}, /* Pc */
	{mdoc_igndelim_pre, mdoc_pf_post}, /* Pf */
	{mdoc_quote_pre, mdoc_quote_post}, /* Po */
	{mdoc_quote_pre, mdoc_quote_post}, /* Pq */
	{NULL, NULL}, /* Qc */
	{mdoc_quote_pre, mdoc_quote_post}, /* Ql */
	{mdoc_quote_pre, mdoc_quote_post}, /* Qo */
	{mdoc_quote_pre, mdoc_quote_post}, /* Qq */
	{NULL, NULL}, /* Re */
	{mdoc_rs_pre, NULL}, /* Rs */
	{NULL, NULL}, /* Sc */
	{mdoc_quote_pre, mdoc_quote_post}, /* So */
	{mdoc_quote_pre, mdoc_quote_post}, /* Sq */
	{mdoc_sm_pre, NULL}, /* Sm */
	{mdoc_sx_pre, NULL}, /* Sx */
	{mdoc_sy_pre, NULL}, /* Sy */
	{NULL, NULL}, /* Tn */
	{mdoc_xx_pre, NULL}, /* Ux */
	{NULL, NULL}, /* Xc */
	{NULL, NULL}, /* Xo */
	{mdoc_fo_pre, mdoc_fo_post}, /* Fo */
	{NULL, NULL}, /* Fc */
	{mdoc_quote_pre, mdoc_quote_post}, /* Oo */
	{NULL, NULL}, /* Oc */
	{mdoc_bk_pre, mdoc_bk_post}, /* Bk */
	{NULL, NULL}, /* Ek */
	{NULL, NULL}, /* Bt */
	{NULL, NULL}, /* Hf */
	{mdoc_em_pre, NULL}, /* Fr */
	{NULL, NULL}, /* Ud */
	{mdoc_lb_pre, NULL}, /* Lb */
	{mdoc_pp_pre, NULL}, /* Lp */
	{mdoc_lk_pre, NULL}, /* Lk */
	{mdoc_mt_pre, NULL}, /* Mt */
	{mdoc_quote_pre, mdoc_quote_post}, /* Brq */
	{mdoc_quote_pre, mdoc_quote_post}, /* Bro */
	{NULL, NULL}, /* Brc */
	{mdoc__x_pre, mdoc__x_post}, /* %C */
	{mdoc_skip_pre, NULL}, /* Es */
	{mdoc_quote_pre, mdoc_quote_post}, /* En */
	{mdoc_xx_pre, NULL}, /* Dx */
	{mdoc__x_pre, mdoc__x_post}, /* %Q */
	{mdoc__x_pre, mdoc__x_post}, /* %U */
	{NULL, NULL}, /* Ta */
};
static	const struct htmlmdoc *const mdocs = __mdocs - MDOC_Dd;


/*
 * See the same function in mdoc_term.c for documentation.
 */
static void
synopsis_pre(struct html *h, const struct roff_node *n)
{

	if (NULL == n->prev || ! (NODE_SYNPRETTY & n->flags))
		return;

	if (n->prev->tok == n->tok &&
	    MDOC_Fo != n->tok &&
	    MDOC_Ft != n->tok &&
	    MDOC_Fn != n->tok) {
		print_otag(h, TAG_BR, "");
		return;
	}

	switch (n->prev->tok) {
	case MDOC_Fd:
	case MDOC_Fn:
	case MDOC_Fo:
	case MDOC_In:
	case MDOC_Vt:
		print_paragraph(h);
		break;
	case MDOC_Ft:
		if (MDOC_Fn != n->tok && MDOC_Fo != n->tok) {
			print_paragraph(h);
			break;
		}
		/* FALLTHROUGH */
	default:
		print_otag(h, TAG_BR, "");
		break;
	}
}

void
html_mdoc(void *arg, const struct roff_man *mdoc)
{
	struct html	*h;
	struct tag	*t;

	h = (struct html *)arg;

	if ((h->oflags & HTML_FRAGMENT) == 0) {
		print_gen_decls(h);
		print_otag(h, TAG_HTML, "");
		t = print_otag(h, TAG_HEAD, "");
		print_mdoc_head(&mdoc->meta, mdoc->first->child, h);
		print_tagq(h, t);
		print_otag(h, TAG_BODY, "");
	}

	mdoc_root_pre(&mdoc->meta, mdoc->first->child, h);
	t = print_otag(h, TAG_DIV, "c", "manual-text");
	print_mdoc_nodelist(&mdoc->meta, mdoc->first->child, h);
	print_tagq(h, t);
	mdoc_root_post(&mdoc->meta, mdoc->first->child, h);
	print_tagq(h, NULL);
}

static void
print_mdoc_head(MDOC_ARGS)
{
	char	*cp;

	print_gen_head(h);

	if (meta->arch != NULL && meta->msec != NULL)
		mandoc_asprintf(&cp, "%s(%s) (%s)", meta->title,
		    meta->msec, meta->arch);
	else if (meta->msec != NULL)
		mandoc_asprintf(&cp, "%s(%s)", meta->title, meta->msec);
	else if (meta->arch != NULL)
		mandoc_asprintf(&cp, "%s (%s)", meta->title, meta->arch);
	else
		cp = mandoc_strdup(meta->title);

	print_otag(h, TAG_TITLE, "");
	print_text(h, cp);
	free(cp);
}

static void
print_mdoc_nodelist(MDOC_ARGS)
{

	while (n != NULL) {
		print_mdoc_node(meta, n, h);
		n = n->next;
	}
}

static void
print_mdoc_node(MDOC_ARGS)
{
	int		 child;
	struct tag	*t;

	if (n->flags & NODE_NOPRT)
		return;

	child = 1;
	t = h->tag;
	n->flags &= ~NODE_ENDED;

	switch (n->type) {
	case ROFFT_TEXT:
		/* No tables in this mode... */
		assert(NULL == h->tblt);

		/*
		 * Make sure that if we're in a literal mode already
		 * (i.e., within a <PRE>) don't print the newline.
		 */
		if (*n->string == ' ' && n->flags & NODE_LINE &&
		    (h->flags & (HTML_LITERAL | HTML_NONEWLINE)) == 0)
			print_otag(h, TAG_BR, "");
		if (NODE_DELIMC & n->flags)
			h->flags |= HTML_NOSPACE;
		print_text(h, n->string);
		if (NODE_DELIMO & n->flags)
			h->flags |= HTML_NOSPACE;
		return;
	case ROFFT_EQN:
		print_eqn(h, n->eqn);
		break;
	case ROFFT_TBL:
		/*
		 * This will take care of initialising all of the table
		 * state data for the first table, then tearing it down
		 * for the last one.
		 */
		print_tbl(h, n->span);
		return;
	default:
		/*
		 * Close out the current table, if it's open, and unset
		 * the "meta" table state.  This will be reopened on the
		 * next table element.
		 */
		if (h->tblt != NULL) {
			print_tblclose(h);
			t = h->tag;
		}
		assert(h->tblt == NULL);
		if (n->tok < ROFF_MAX) {
			roff_html_pre(h, n);
			child = 0;
			break;
		}
		assert(n->tok >= MDOC_Dd && n->tok < MDOC_MAX);
		if (mdocs[n->tok].pre != NULL &&
		    (n->end == ENDBODY_NOT || n->child != NULL))
			child = (*mdocs[n->tok].pre)(meta, n, h);
		break;
	}

	if (h->flags & HTML_KEEP && n->flags & NODE_LINE) {
		h->flags &= ~HTML_KEEP;
		h->flags |= HTML_PREKEEP;
	}

	if (child && n->child)
		print_mdoc_nodelist(meta, n->child, h);

	print_stagq(h, t);

	switch (n->type) {
	case ROFFT_EQN:
		break;
	default:
		if (n->tok < ROFF_MAX ||
		    mdocs[n->tok].post == NULL ||
		    n->flags & NODE_ENDED)
			break;
		(*mdocs[n->tok].post)(meta, n, h);
		if (n->end != ENDBODY_NOT)
			n->body->flags |= NODE_ENDED;
		break;
	}
}

static void
mdoc_root_post(MDOC_ARGS)
{
	struct tag	*t, *tt;

	t = print_otag(h, TAG_TABLE, "c", "foot");
	tt = print_otag(h, TAG_TR, "");

	print_otag(h, TAG_TD, "c", "foot-date");
	print_text(h, meta->date);
	print_stagq(h, tt);

	print_otag(h, TAG_TD, "c", "foot-os");
	print_text(h, meta->os);
	print_tagq(h, t);
}

static int
mdoc_root_pre(MDOC_ARGS)
{
	struct tag	*t, *tt;
	char		*volume, *title;

	if (NULL == meta->arch)
		volume = mandoc_strdup(meta->vol);
	else
		mandoc_asprintf(&volume, "%s (%s)",
		    meta->vol, meta->arch);

	if (NULL == meta->msec)
		title = mandoc_strdup(meta->title);
	else
		mandoc_asprintf(&title, "%s(%s)",
		    meta->title, meta->msec);

	t = print_otag(h, TAG_TABLE, "c", "head");
	tt = print_otag(h, TAG_TR, "");

	print_otag(h, TAG_TD, "c", "head-ltitle");
	print_text(h, title);
	print_stagq(h, tt);

	print_otag(h, TAG_TD, "c", "head-vol");
	print_text(h, volume);
	print_stagq(h, tt);

	print_otag(h, TAG_TD, "c", "head-rtitle");
	print_text(h, title);
	print_tagq(h, t);

	free(title);
	free(volume);
	return 1;
}

static char *
cond_id(const struct roff_node *n)
{
	if (n->child != NULL &&
	    n->child->type == ROFFT_TEXT &&
	    (n->prev == NULL ||
	     (n->prev->type == ROFFT_TEXT &&
	      strcmp(n->prev->string, "|") == 0)) &&
	    (n->parent->tok == MDOC_It ||
	     (n->parent->tok == MDOC_Xo &&
	      n->parent->parent->prev == NULL &&
	      n->parent->parent->parent->tok == MDOC_It)))
		return html_make_id(n);
	return NULL;
}

static int
mdoc_sh_pre(MDOC_ARGS)
{
	char	*id;

	switch (n->type) {
	case ROFFT_HEAD:
		id = html_make_id(n);
		print_otag(h, TAG_H1, "cTi", "Sh", id);
		if (id != NULL)
			print_otag(h, TAG_A, "chR", "selflink", id);
		free(id);
		break;
	case ROFFT_BODY:
		if (n->sec == SEC_AUTHORS)
			h->flags &= ~(HTML_SPLIT|HTML_NOSPLIT);
		break;
	default:
		break;
	}
	return 1;
}

static int
mdoc_ss_pre(MDOC_ARGS)
{
	char	*id;

	if (n->type != ROFFT_HEAD)
		return 1;

	id = html_make_id(n);
	print_otag(h, TAG_H2, "cTi", "Ss", id);
	if (id != NULL)
		print_otag(h, TAG_A, "chR", "selflink", id);
	free(id);
	return 1;
}

static int
mdoc_fl_pre(MDOC_ARGS)
{
	char	*id;

	if ((id = cond_id(n)) != NULL)
		print_otag(h, TAG_A, "chR", "selflink", id);
	print_otag(h, TAG_B, "cTi", "Fl", id);
	free(id);

	print_text(h, "\\-");
	if (!(n->child == NULL &&
	    (n->next == NULL ||
	     n->next->type == ROFFT_TEXT ||
	     n->next->flags & NODE_LINE)))
		h->flags |= HTML_NOSPACE;

	return 1;
}

static int
mdoc_cm_pre(MDOC_ARGS)
{
	char	*id;

	if ((id = cond_id(n)) != NULL)
		print_otag(h, TAG_A, "chR", "selflink", id);
	print_otag(h, TAG_B, "cTi", "Cm", id);
	free(id);
	return 1;
}

static int
mdoc_nd_pre(MDOC_ARGS)
{
	if (n->type != ROFFT_BODY)
		return 1;

	/* XXX: this tag in theory can contain block elements. */

	print_text(h, "\\(em");
	print_otag(h, TAG_SPAN, "cT", "Nd");
	return 1;
}

static int
mdoc_nm_pre(MDOC_ARGS)
{
	switch (n->type) {
	case ROFFT_HEAD:
		print_otag(h, TAG_TD, "");
		/* FALLTHROUGH */
	case ROFFT_ELEM:
		print_otag(h, TAG_B, "cT", "Nm");
		return 1;
	case ROFFT_BODY:
		print_otag(h, TAG_TD, "");
		return 1;
	default:
		break;
	}
	synopsis_pre(h, n);
	print_otag(h, TAG_TABLE, "c", "Nm");
	print_otag(h, TAG_TR, "");
	return 1;
}

static int
mdoc_xr_pre(MDOC_ARGS)
{
	if (NULL == n->child)
		return 0;

	if (h->base_man)
		print_otag(h, TAG_A, "cThM", "Xr",
		    n->child->string, n->child->next == NULL ?
		    NULL : n->child->next->string);
	else
		print_otag(h, TAG_A, "cT", "Xr");

	n = n->child;
	print_text(h, n->string);

	if (NULL == (n = n->next))
		return 0;

	h->flags |= HTML_NOSPACE;
	print_text(h, "(");
	h->flags |= HTML_NOSPACE;
	print_text(h, n->string);
	h->flags |= HTML_NOSPACE;
	print_text(h, ")");
	return 0;
}

static int
mdoc_ns_pre(MDOC_ARGS)
{

	if ( ! (NODE_LINE & n->flags))
		h->flags |= HTML_NOSPACE;
	return 1;
}

static int
mdoc_ar_pre(MDOC_ARGS)
{
	print_otag(h, TAG_VAR, "cT", "Ar");
	return 1;
}

static int
mdoc_xx_pre(MDOC_ARGS)
{
	print_otag(h, TAG_SPAN, "c", "Ux");
	return 1;
}

static int
mdoc_it_pre(MDOC_ARGS)
{
	const struct roff_node	*bl;
	struct tag		*t;
	const char		*cattr;
	enum mdoc_list		 type;

	bl = n->parent;
	while (bl->tok != MDOC_Bl)
		bl = bl->parent;
	type = bl->norm->Bl.type;

	switch (type) {
	case LIST_bullet:
		cattr = "It-bullet";
		break;
	case LIST_dash:
	case LIST_hyphen:
		cattr = "It-dash";
		break;
	case LIST_item:
		cattr = "It-item";
		break;
	case LIST_enum:
		cattr = "It-enum";
		break;
	case LIST_diag:
		cattr = "It-diag";
		break;
	case LIST_hang:
		cattr = "It-hang";
		break;
	case LIST_inset:
		cattr = "It-inset";
		break;
	case LIST_ohang:
		cattr = "It-ohang";
		break;
	case LIST_tag:
		cattr = "It-tag";
		break;
	case LIST_column:
		cattr = "It-column";
		break;
	default:
		break;
	}

	switch (type) {
	case LIST_bullet:
	case LIST_dash:
	case LIST_hyphen:
	case LIST_item:
	case LIST_enum:
		switch (n->type) {
		case ROFFT_HEAD:
			return 0;
		case ROFFT_BODY:
			if (bl->norm->Bl.comp)
				print_otag(h, TAG_LI, "csvt", cattr, 0);
			else
				print_otag(h, TAG_LI, "c", cattr);
			break;
		default:
			break;
		}
		break;
	case LIST_diag:
	case LIST_hang:
	case LIST_inset:
	case LIST_ohang:
		switch (n->type) {
		case ROFFT_HEAD:
			if (bl->norm->Bl.comp)
				print_otag(h, TAG_DT, "csvt", cattr, 0);
			else
				print_otag(h, TAG_DT, "c", cattr);
			if (type == LIST_diag)
				print_otag(h, TAG_B, "c", cattr);
			break;
		case ROFFT_BODY:
			print_otag(h, TAG_DD, "cswl", cattr,
			    bl->norm->Bl.width);
			break;
		default:
			break;
		}
		break;
	case LIST_tag:
		switch (n->type) {
		case ROFFT_HEAD:
			if (h->style != NULL && !bl->norm->Bl.comp &&
			    (n->parent->prev == NULL ||
			     n->parent->prev->body == NULL ||
			     n->parent->prev->body->child != NULL)) {
				t = print_otag(h, TAG_DT, "csw+-l",
				    cattr, bl->norm->Bl.width);
				print_text(h, "\\ ");
				print_tagq(h, t);
				t = print_otag(h, TAG_DD, "c", cattr);
				print_text(h, "\\ ");
				print_tagq(h, t);
			}
			print_otag(h, TAG_DT, "csw+-l", cattr,
			    bl->norm->Bl.width);
			break;
		case ROFFT_BODY:
			if (n->child == NULL) {
				print_otag(h, TAG_DD, "css?", cattr,
				    "width", "auto");
				print_text(h, "\\ ");
			} else
				print_otag(h, TAG_DD, "c", cattr);
			break;
		default:
			break;
		}
		break;
	case LIST_column:
		switch (n->type) {
		case ROFFT_HEAD:
			break;
		case ROFFT_BODY:
			if (bl->norm->Bl.comp)
				print_otag(h, TAG_TD, "csvt", cattr, 0);
			else
				print_otag(h, TAG_TD, "c", cattr);
			break;
		default:
			print_otag(h, TAG_TR, "c", cattr);
		}
	default:
		break;
	}

	return 1;
}

static int
mdoc_bl_pre(MDOC_ARGS)
{
	struct tag	*t;
	struct mdoc_bl	*bl;
	const char	*cattr;
	size_t		 i;
	enum htmltag	 elemtype;

	bl = &n->norm->Bl;

	switch (n->type) {
	case ROFFT_BODY:
		return 1;

	case ROFFT_HEAD:
		if (bl->type != LIST_column || bl->ncols == 0)
			return 0;

		/*
		 * For each column, print out the <COL> tag with our
		 * suggested width.  The last column gets min-width, as
		 * in terminal mode it auto-sizes to the width of the
		 * screen and we want to preserve that behaviour.
		 */

		t = print_otag(h, TAG_COLGROUP, "");
		for (i = 0; i < bl->ncols - 1; i++)
			print_otag(h, TAG_COL, "sw+w", bl->cols[i]);
		print_otag(h, TAG_COL, "swW", bl->cols[i]);
		print_tagq(h, t);
		return 0;

	default:
		break;
	}

	switch (bl->type) {
	case LIST_bullet:
		elemtype = TAG_UL;
		cattr = "Bl-bullet";
		break;
	case LIST_dash:
	case LIST_hyphen:
		elemtype = TAG_UL;
		cattr = "Bl-dash";
		break;
	case LIST_item:
		elemtype = TAG_UL;
		cattr = "Bl-item";
		break;
	case LIST_enum:
		elemtype = TAG_OL;
		cattr = "Bl-enum";
		break;
	case LIST_diag:
		elemtype = TAG_DL;
		cattr = "Bl-diag";
		break;
	case LIST_hang:
		elemtype = TAG_DL;
		cattr = "Bl-hang";
		break;
	case LIST_inset:
		elemtype = TAG_DL;
		cattr = "Bl-inset";
		break;
	case LIST_ohang:
		elemtype = TAG_DL;
		cattr = "Bl-ohang";
		break;
	case LIST_tag:
		cattr = "Bl-tag";
		if (bl->offs)
			print_otag(h, TAG_DIV, "cswl", cattr, bl->offs);
		print_otag(h, TAG_DL, "csw+l", cattr, bl->width);
		return 1;
	case LIST_column:
		elemtype = TAG_TABLE;
		cattr = "Bl-column";
		break;
	default:
		abort();
	}
	print_otag(h, elemtype, "cswl", cattr, bl->offs);
	return 1;
}

static int
mdoc_ex_pre(MDOC_ARGS)
{
	if (n->prev)
		print_otag(h, TAG_BR, "");
	return 1;
}

static int
mdoc_st_pre(MDOC_ARGS)
{
	print_otag(h, TAG_SPAN, "cT", "St");
	return 1;
}

static int
mdoc_em_pre(MDOC_ARGS)
{
	print_otag(h, TAG_I, "cT", "Em");
	return 1;
}

static int
mdoc_d1_pre(MDOC_ARGS)
{
	if (n->type != ROFFT_BLOCK)
		return 1;

	print_otag(h, TAG_DIV, "c", "D1");

	if (n->tok == MDOC_Dl)
		print_otag(h, TAG_CODE, "c", "Li");

	return 1;
}

static int
mdoc_sx_pre(MDOC_ARGS)
{
	char	*id;

	id = html_make_id(n);
	print_otag(h, TAG_A, "cThR", "Sx", id);
	free(id);
	return 1;
}

static int
mdoc_bd_pre(MDOC_ARGS)
{
	int			 comp, offs, sv;
	struct roff_node	*nn;

	if (n->type == ROFFT_HEAD)
		return 0;

	if (n->type == ROFFT_BLOCK) {
		comp = n->norm->Bd.comp;
		for (nn = n; nn && ! comp; nn = nn->parent) {
			if (nn->type != ROFFT_BLOCK)
				continue;
			if (MDOC_Ss == nn->tok || MDOC_Sh == nn->tok)
				comp = 1;
			if (nn->prev)
				break;
		}
		if ( ! comp)
			print_paragraph(h);
		return 1;
	}

	/* Handle the -offset argument. */

	if (n->norm->Bd.offs == NULL ||
	    ! strcmp(n->norm->Bd.offs, "left"))
		offs = 0;
	else if ( ! strcmp(n->norm->Bd.offs, "indent"))
		offs = INDENT;
	else if ( ! strcmp(n->norm->Bd.offs, "indent-two"))
		offs = INDENT * 2;
	else
		offs = -1;

	if (offs == -1)
		print_otag(h, TAG_DIV, "cswl", "Bd", n->norm->Bd.offs);
	else
		print_otag(h, TAG_DIV, "cshl", "Bd", offs);

	if (n->norm->Bd.type != DISP_unfilled &&
	    n->norm->Bd.type != DISP_literal)
		return 1;

	print_otag(h, TAG_PRE, "c", "Li");

	/* This can be recursive: save & set our literal state. */

	sv = h->flags & HTML_LITERAL;
	h->flags |= HTML_LITERAL;

	for (nn = n->child; nn; nn = nn->next) {
		print_mdoc_node(meta, nn, h);
		/*
		 * If the printed node flushes its own line, then we
		 * needn't do it here as well.  This is hacky, but the
		 * notion of selective eoln whitespace is pretty dumb
		 * anyway, so don't sweat it.
		 */
		switch (nn->tok) {
		case ROFF_br:
		case ROFF_sp:
		case MDOC_Sm:
		case MDOC_Bl:
		case MDOC_D1:
		case MDOC_Dl:
		case MDOC_Lp:
		case MDOC_Pp:
			continue;
		default:
			break;
		}
		if (h->flags & HTML_NONEWLINE ||
		    (nn->next && ! (nn->next->flags & NODE_LINE)))
			continue;
		else if (nn->next)
			print_text(h, "\n");

		h->flags |= HTML_NOSPACE;
	}

	if (0 == sv)
		h->flags &= ~HTML_LITERAL;

	return 0;
}

static int
mdoc_pa_pre(MDOC_ARGS)
{
	print_otag(h, TAG_I, "cT", "Pa");
	return 1;
}

static int
mdoc_ad_pre(MDOC_ARGS)
{
	print_otag(h, TAG_I, "c", "Ad");
	return 1;
}

static int
mdoc_an_pre(MDOC_ARGS)
{
	if (n->norm->An.auth == AUTH_split) {
		h->flags &= ~HTML_NOSPLIT;
		h->flags |= HTML_SPLIT;
		return 0;
	}
	if (n->norm->An.auth == AUTH_nosplit) {
		h->flags &= ~HTML_SPLIT;
		h->flags |= HTML_NOSPLIT;
		return 0;
	}

	if (h->flags & HTML_SPLIT)
		print_otag(h, TAG_BR, "");

	if (n->sec == SEC_AUTHORS && ! (h->flags & HTML_NOSPLIT))
		h->flags |= HTML_SPLIT;

	print_otag(h, TAG_SPAN, "cT", "An");
	return 1;
}

static int
mdoc_cd_pre(MDOC_ARGS)
{
	synopsis_pre(h, n);
	print_otag(h, TAG_B, "cT", "Cd");
	return 1;
}

static int
mdoc_dv_pre(MDOC_ARGS)
{
	char	*id;

	if ((id = cond_id(n)) != NULL)
		print_otag(h, TAG_A, "chR", "selflink", id);
	print_otag(h, TAG_CODE, "cTi", "Dv", id);
	free(id);
	return 1;
}

static int
mdoc_ev_pre(MDOC_ARGS)
{
	char	*id;

	if ((id = cond_id(n)) != NULL)
		print_otag(h, TAG_A, "chR", "selflink", id);
	print_otag(h, TAG_CODE, "cTi", "Ev", id);
	free(id);
	return 1;
}

static int
mdoc_er_pre(MDOC_ARGS)
{
	char	*id;

	id = n->sec == SEC_ERRORS &&
	    (n->parent->tok == MDOC_It ||
	     (n->parent->tok == MDOC_Bq &&
	      n->parent->parent->parent->tok == MDOC_It)) ?
	    html_make_id(n) : NULL;

	if (id != NULL)
		print_otag(h, TAG_A, "chR", "selflink", id);
	print_otag(h, TAG_CODE, "cTi", "Er", id);
	free(id);
	return 1;
}

static int
mdoc_fa_pre(MDOC_ARGS)
{
	const struct roff_node	*nn;
	struct tag		*t;

	if (n->parent->tok != MDOC_Fo) {
		print_otag(h, TAG_VAR, "cT", "Fa");
		return 1;
	}

	for (nn = n->child; nn; nn = nn->next) {
		t = print_otag(h, TAG_VAR, "cT", "Fa");
		print_text(h, nn->string);
		print_tagq(h, t);
		if (nn->next) {
			h->flags |= HTML_NOSPACE;
			print_text(h, ",");
		}
	}

	if (n->child && n->next && n->next->tok == MDOC_Fa) {
		h->flags |= HTML_NOSPACE;
		print_text(h, ",");
	}

	return 0;
}

static int
mdoc_fd_pre(MDOC_ARGS)
{
	struct tag	*t;
	char		*buf, *cp;

	synopsis_pre(h, n);

	if (NULL == (n = n->child))
		return 0;

	assert(n->type == ROFFT_TEXT);

	if (strcmp(n->string, "#include")) {
		print_otag(h, TAG_B, "cT", "Fd");
		return 1;
	}

	print_otag(h, TAG_B, "cT", "In");
	print_text(h, n->string);

	if (NULL != (n = n->next)) {
		assert(n->type == ROFFT_TEXT);

		if (h->base_includes) {
			cp = n->string;
			if (*cp == '<' || *cp == '"')
				cp++;
			buf = mandoc_strdup(cp);
			cp = strchr(buf, '\0') - 1;
			if (cp >= buf && (*cp == '>' || *cp == '"'))
				*cp = '\0';
			t = print_otag(h, TAG_A, "cThI", "In", buf);
			free(buf);
		} else
			t = print_otag(h, TAG_A, "cT", "In");

		print_text(h, n->string);
		print_tagq(h, t);

		n = n->next;
	}

	for ( ; n; n = n->next) {
		assert(n->type == ROFFT_TEXT);
		print_text(h, n->string);
	}

	return 0;
}

static int
mdoc_vt_pre(MDOC_ARGS)
{
	if (n->type == ROFFT_BLOCK) {
		synopsis_pre(h, n);
		return 1;
	} else if (n->type == ROFFT_ELEM) {
		synopsis_pre(h, n);
	} else if (n->type == ROFFT_HEAD)
		return 0;

	print_otag(h, TAG_VAR, "cT", "Vt");
	return 1;
}

static int
mdoc_ft_pre(MDOC_ARGS)
{
	synopsis_pre(h, n);
	print_otag(h, TAG_VAR, "cT", "Ft");
	return 1;
}

static int
mdoc_fn_pre(MDOC_ARGS)
{
	struct tag	*t;
	char		 nbuf[BUFSIZ];
	const char	*sp, *ep;
	int		 sz, pretty;

	pretty = NODE_SYNPRETTY & n->flags;
	synopsis_pre(h, n);

	/* Split apart into type and name. */
	assert(n->child->string);
	sp = n->child->string;

	ep = strchr(sp, ' ');
	if (NULL != ep) {
		t = print_otag(h, TAG_VAR, "cT", "Ft");

		while (ep) {
			sz = MIN((int)(ep - sp), BUFSIZ - 1);
			(void)memcpy(nbuf, sp, (size_t)sz);
			nbuf[sz] = '\0';
			print_text(h, nbuf);
			sp = ++ep;
			ep = strchr(sp, ' ');
		}
		print_tagq(h, t);
	}

	t = print_otag(h, TAG_B, "cT", "Fn");

	if (sp)
		print_text(h, sp);

	print_tagq(h, t);

	h->flags |= HTML_NOSPACE;
	print_text(h, "(");
	h->flags |= HTML_NOSPACE;

	for (n = n->child->next; n; n = n->next) {
		if (NODE_SYNPRETTY & n->flags)
			t = print_otag(h, TAG_VAR, "cTss?", "Fa",
			    "white-space", "nowrap");
		else
			t = print_otag(h, TAG_VAR, "cT", "Fa");
		print_text(h, n->string);
		print_tagq(h, t);
		if (n->next) {
			h->flags |= HTML_NOSPACE;
			print_text(h, ",");
		}
	}

	h->flags |= HTML_NOSPACE;
	print_text(h, ")");

	if (pretty) {
		h->flags |= HTML_NOSPACE;
		print_text(h, ";");
	}

	return 0;
}

static int
mdoc_sm_pre(MDOC_ARGS)
{

	if (NULL == n->child)
		h->flags ^= HTML_NONOSPACE;
	else if (0 == strcmp("on", n->child->string))
		h->flags &= ~HTML_NONOSPACE;
	else
		h->flags |= HTML_NONOSPACE;

	if ( ! (HTML_NONOSPACE & h->flags))
		h->flags &= ~HTML_NOSPACE;

	return 0;
}

static int
mdoc_skip_pre(MDOC_ARGS)
{

	return 0;
}

static int
mdoc_pp_pre(MDOC_ARGS)
{

	print_paragraph(h);
	return 0;
}

static int
mdoc_lk_pre(MDOC_ARGS)
{
	const struct roff_node *link, *descr, *punct;
	struct tag	*t;

	if ((link = n->child) == NULL)
		return 0;

	/* Find beginning of trailing punctuation. */
	punct = n->last;
	while (punct != link && punct->flags & NODE_DELIMC)
		punct = punct->prev;
	punct = punct->next;

	/* Link target and link text. */
	descr = link->next;
	if (descr == punct)
		descr = link;  /* no text */
	t = print_otag(h, TAG_A, "cTh", "Lk", link->string);
	do {
		if (descr->flags & (NODE_DELIMC | NODE_DELIMO))
			h->flags |= HTML_NOSPACE;
		print_text(h, descr->string);
		descr = descr->next;
	} while (descr != punct);
	print_tagq(h, t);

	/* Trailing punctuation. */
	while (punct != NULL) {
		h->flags |= HTML_NOSPACE;
		print_text(h, punct->string);
		punct = punct->next;
	}
	return 0;
}

static int
mdoc_mt_pre(MDOC_ARGS)
{
	struct tag	*t;
	char		*cp;

	for (n = n->child; n; n = n->next) {
		assert(n->type == ROFFT_TEXT);

		mandoc_asprintf(&cp, "mailto:%s", n->string);
		t = print_otag(h, TAG_A, "cTh", "Mt", cp);
		print_text(h, n->string);
		print_tagq(h, t);
		free(cp);
	}

	return 0;
}

static int
mdoc_fo_pre(MDOC_ARGS)
{
	struct tag	*t;

	if (n->type == ROFFT_BODY) {
		h->flags |= HTML_NOSPACE;
		print_text(h, "(");
		h->flags |= HTML_NOSPACE;
		return 1;
	} else if (n->type == ROFFT_BLOCK) {
		synopsis_pre(h, n);
		return 1;
	}

	if (n->child == NULL)
		return 0;

	assert(n->child->string);
	t = print_otag(h, TAG_B, "cT", "Fn");
	print_text(h, n->child->string);
	print_tagq(h, t);
	return 0;
}

static void
mdoc_fo_post(MDOC_ARGS)
{

	if (n->type != ROFFT_BODY)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, ")");
	h->flags |= HTML_NOSPACE;
	print_text(h, ";");
}

static int
mdoc_in_pre(MDOC_ARGS)
{
	struct tag	*t;

	synopsis_pre(h, n);
	print_otag(h, TAG_B, "cT", "In");

	/*
	 * The first argument of the `In' gets special treatment as
	 * being a linked value.  Subsequent values are printed
	 * afterward.  groff does similarly.  This also handles the case
	 * of no children.
	 */

	if (NODE_SYNPRETTY & n->flags && NODE_LINE & n->flags)
		print_text(h, "#include");

	print_text(h, "<");
	h->flags |= HTML_NOSPACE;

	if (NULL != (n = n->child)) {
		assert(n->type == ROFFT_TEXT);

		if (h->base_includes)
			t = print_otag(h, TAG_A, "cThI", "In", n->string);
		else
			t = print_otag(h, TAG_A, "cT", "In");
		print_text(h, n->string);
		print_tagq(h, t);

		n = n->next;
	}

	h->flags |= HTML_NOSPACE;
	print_text(h, ">");

	for ( ; n; n = n->next) {
		assert(n->type == ROFFT_TEXT);
		print_text(h, n->string);
	}

	return 0;
}

static int
mdoc_ic_pre(MDOC_ARGS)
{
	char	*id;

	if ((id = cond_id(n)) != NULL)
		print_otag(h, TAG_A, "chR", "selflink", id);
	print_otag(h, TAG_B, "cTi", "Ic", id);
	free(id);
	return 1;
}

static int
mdoc_va_pre(MDOC_ARGS)
{
	print_otag(h, TAG_VAR, "cT", "Va");
	return 1;
}

static int
mdoc_ap_pre(MDOC_ARGS)
{

	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(aq");
	h->flags |= HTML_NOSPACE;
	return 1;
}

static int
mdoc_bf_pre(MDOC_ARGS)
{
	const char	*cattr;

	if (n->type == ROFFT_HEAD)
		return 0;
	else if (n->type != ROFFT_BODY)
		return 1;

	if (FONT_Em == n->norm->Bf.font)
		cattr = "Em";
	else if (FONT_Sy == n->norm->Bf.font)
		cattr = "Sy";
	else if (FONT_Li == n->norm->Bf.font)
		cattr = "Li";
	else
		cattr = "No";

	/*
	 * We want this to be inline-formatted, but needs to be div to
	 * accept block children.
	 */

	print_otag(h, TAG_DIV, "css?hl", cattr, "display", "inline", 1);
	return 1;
}

static int
mdoc_ms_pre(MDOC_ARGS)
{
	char *id;

	if ((id = cond_id(n)) != NULL)
		print_otag(h, TAG_A, "chR", "selflink", id);
	print_otag(h, TAG_B, "cTi", "Ms", id);
	free(id);
	return 1;
}

static int
mdoc_igndelim_pre(MDOC_ARGS)
{

	h->flags |= HTML_IGNDELIM;
	return 1;
}

static void
mdoc_pf_post(MDOC_ARGS)
{

	if ( ! (n->next == NULL || n->next->flags & NODE_LINE))
		h->flags |= HTML_NOSPACE;
}

static int
mdoc_rs_pre(MDOC_ARGS)
{
	if (n->type != ROFFT_BLOCK)
		return 1;

	if (n->prev && SEC_SEE_ALSO == n->sec)
		print_paragraph(h);

	print_otag(h, TAG_CITE, "cT", "Rs");
	return 1;
}

static int
mdoc_no_pre(MDOC_ARGS)
{
	char *id;

	if ((id = cond_id(n)) != NULL)
		print_otag(h, TAG_A, "chR", "selflink", id);
	print_otag(h, TAG_SPAN, "ci", "No", id);
	free(id);
	return 1;
}

static int
mdoc_li_pre(MDOC_ARGS)
{
	char	*id;

	if ((id = cond_id(n)) != NULL)
		print_otag(h, TAG_A, "chR", "selflink", id);
	print_otag(h, TAG_CODE, "ci", "Li", id);
	free(id);
	return 1;
}

static int
mdoc_sy_pre(MDOC_ARGS)
{
	print_otag(h, TAG_B, "cT", "Sy");
	return 1;
}

static int
mdoc_lb_pre(MDOC_ARGS)
{
	if (SEC_LIBRARY == n->sec && NODE_LINE & n->flags && n->prev)
		print_otag(h, TAG_BR, "");

	print_otag(h, TAG_SPAN, "cT", "Lb");
	return 1;
}

static int
mdoc__x_pre(MDOC_ARGS)
{
	const char	*cattr;
	enum htmltag	 t;

	t = TAG_SPAN;

	switch (n->tok) {
	case MDOC__A:
		cattr = "RsA";
		if (n->prev && MDOC__A == n->prev->tok)
			if (NULL == n->next || MDOC__A != n->next->tok)
				print_text(h, "and");
		break;
	case MDOC__B:
		t = TAG_I;
		cattr = "RsB";
		break;
	case MDOC__C:
		cattr = "RsC";
		break;
	case MDOC__D:
		cattr = "RsD";
		break;
	case MDOC__I:
		t = TAG_I;
		cattr = "RsI";
		break;
	case MDOC__J:
		t = TAG_I;
		cattr = "RsJ";
		break;
	case MDOC__N:
		cattr = "RsN";
		break;
	case MDOC__O:
		cattr = "RsO";
		break;
	case MDOC__P:
		cattr = "RsP";
		break;
	case MDOC__Q:
		cattr = "RsQ";
		break;
	case MDOC__R:
		cattr = "RsR";
		break;
	case MDOC__T:
		cattr = "RsT";
		break;
	case MDOC__U:
		print_otag(h, TAG_A, "ch", "RsU", n->child->string);
		return 1;
	case MDOC__V:
		cattr = "RsV";
		break;
	default:
		abort();
	}

	print_otag(h, t, "c", cattr);
	return 1;
}

static void
mdoc__x_post(MDOC_ARGS)
{

	if (MDOC__A == n->tok && n->next && MDOC__A == n->next->tok)
		if (NULL == n->next->next || MDOC__A != n->next->next->tok)
			if (NULL == n->prev || MDOC__A != n->prev->tok)
				return;

	/* TODO: %U */

	if (NULL == n->parent || MDOC_Rs != n->parent->tok)
		return;

	h->flags |= HTML_NOSPACE;
	print_text(h, n->next ? "," : ".");
}

static int
mdoc_bk_pre(MDOC_ARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		break;
	case ROFFT_HEAD:
		return 0;
	case ROFFT_BODY:
		if (n->parent->args != NULL || n->prev->child == NULL)
			h->flags |= HTML_PREKEEP;
		break;
	default:
		abort();
	}

	return 1;
}

static void
mdoc_bk_post(MDOC_ARGS)
{

	if (n->type == ROFFT_BODY)
		h->flags &= ~(HTML_KEEP | HTML_PREKEEP);
}

static int
mdoc_quote_pre(MDOC_ARGS)
{
	if (n->type != ROFFT_BODY)
		return 1;

	switch (n->tok) {
	case MDOC_Ao:
	case MDOC_Aq:
		print_text(h, n->child != NULL && n->child->next == NULL &&
		    n->child->tok == MDOC_Mt ?  "<" : "\\(la");
		break;
	case MDOC_Bro:
	case MDOC_Brq:
		print_text(h, "\\(lC");
		break;
	case MDOC_Bo:
	case MDOC_Bq:
		print_text(h, "\\(lB");
		break;
	case MDOC_Oo:
	case MDOC_Op:
		print_text(h, "\\(lB");
		h->flags |= HTML_NOSPACE;
		print_otag(h, TAG_SPAN, "c", "Op");
		break;
	case MDOC_En:
		if (NULL == n->norm->Es ||
		    NULL == n->norm->Es->child)
			return 1;
		print_text(h, n->norm->Es->child->string);
		break;
	case MDOC_Do:
	case MDOC_Dq:
	case MDOC_Qo:
	case MDOC_Qq:
		print_text(h, "\\(lq");
		break;
	case MDOC_Po:
	case MDOC_Pq:
		print_text(h, "(");
		break;
	case MDOC_Ql:
		print_text(h, "\\(oq");
		h->flags |= HTML_NOSPACE;
		print_otag(h, TAG_CODE, "c", "Li");
		break;
	case MDOC_So:
	case MDOC_Sq:
		print_text(h, "\\(oq");
		break;
	default:
		abort();
	}

	h->flags |= HTML_NOSPACE;
	return 1;
}

static void
mdoc_quote_post(MDOC_ARGS)
{

	if (n->type != ROFFT_BODY && n->type != ROFFT_ELEM)
		return;

	h->flags |= HTML_NOSPACE;

	switch (n->tok) {
	case MDOC_Ao:
	case MDOC_Aq:
		print_text(h, n->child != NULL && n->child->next == NULL &&
		    n->child->tok == MDOC_Mt ?  ">" : "\\(ra");
		break;
	case MDOC_Bro:
	case MDOC_Brq:
		print_text(h, "\\(rC");
		break;
	case MDOC_Oo:
	case MDOC_Op:
	case MDOC_Bo:
	case MDOC_Bq:
		print_text(h, "\\(rB");
		break;
	case MDOC_En:
		if (n->norm->Es == NULL ||
		    n->norm->Es->child == NULL ||
		    n->norm->Es->child->next == NULL)
			h->flags &= ~HTML_NOSPACE;
		else
			print_text(h, n->norm->Es->child->next->string);
		break;
	case MDOC_Qo:
	case MDOC_Qq:
	case MDOC_Do:
	case MDOC_Dq:
		print_text(h, "\\(rq");
		break;
	case MDOC_Po:
	case MDOC_Pq:
		print_text(h, ")");
		break;
	case MDOC_Ql:
	case MDOC_So:
	case MDOC_Sq:
		print_text(h, "\\(cq");
		break;
	default:
		abort();
	}
}

static int
mdoc_eo_pre(MDOC_ARGS)
{

	if (n->type != ROFFT_BODY)
		return 1;

	if (n->end == ENDBODY_NOT &&
	    n->parent->head->child == NULL &&
	    n->child != NULL &&
	    n->child->end != ENDBODY_NOT)
		print_text(h, "\\&");
	else if (n->end != ENDBODY_NOT ? n->child != NULL :
	    n->parent->head->child != NULL && (n->child != NULL ||
	    (n->parent->tail != NULL && n->parent->tail->child != NULL)))
		h->flags |= HTML_NOSPACE;
	return 1;
}

static void
mdoc_eo_post(MDOC_ARGS)
{
	int	 body, tail;

	if (n->type != ROFFT_BODY)
		return;

	if (n->end != ENDBODY_NOT) {
		h->flags &= ~HTML_NOSPACE;
		return;
	}

	body = n->child != NULL || n->parent->head->child != NULL;
	tail = n->parent->tail != NULL && n->parent->tail->child != NULL;

	if (body && tail)
		h->flags |= HTML_NOSPACE;
	else if ( ! tail)
		h->flags &= ~HTML_NOSPACE;
}
@


1.164
log
@fix formatting of intermediate punctuation in .Lk
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.163 2017/05/17 17:53:48 schwarze Exp $ */
d1323 3
d1327 1
a1327 1
	for (descr = link->next; descr != punct; descr = descr->next) {
d1331 2
a1332 1
	}
@


1.163
log
@Delete pointless width calculation for SYNOPSIS .Nm block heads.
Just let HTML <table> do its work of selecting the needed width.
<Anton dot Lindqvist at gmail dot com> reported that the manually
calculated width was insufficient in some manual pages.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.162 2017/05/12 17:56:39 schwarze Exp $ */
d1310 1
d1313 1
a1313 1
	if ((n = n->child) == NULL)
d1316 6
d1323 6
a1328 5
	t = print_otag(h, TAG_A, "cTh", "Lk", n->string);
	if (n->next == NULL || n->next->flags & NODE_DELIMC)
		print_text(h, n->string);
	for (n = n->next; n != NULL && !(n->flags & NODE_DELIMC); n = n->next)
		print_text(h, n->string);
d1332 1
a1332 1
	while (n != NULL) {
d1334 2
a1335 2
		print_text(h, n->string);
		n = n->next;
@


1.162
log
@Make the tag column in .Bl -tag lists wider:
1. I forgot about the 2n padding between tag and body.
2. The factor 1.1 was too small for bold fold, make it *1.15 + 1n.
Ugliness spotted by tb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.161 2017/05/09 14:09:37 schwarze Exp $ */
a585 3
	struct tag	*t;
	int		 len;

a598 1

a600 13

	for (len = 0, n = n->head->child; n; n = n->next)
		if (n->type == ROFFT_TEXT)
			len += html_strlen(n->string);

	if (len == 0 && meta->name != NULL)
		len = html_strlen(meta->name);

	t = print_otag(h, TAG_COLGROUP, "");
	/* Increase width to make even bold text fit. */
	print_otag(h, TAG_COL, "shw", len + 2);
	print_otag(h, TAG_COL, "");
	print_tagq(h, t);
@


1.161
log
@Trailing \c suppresses the output line break even if
the next line is a text line starting with whitespace.
Quirk found in the sysutils/rancid port.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.160 2017/05/05 15:16:25 schwarze Exp $ */
d769 1
a769 1
				t = print_otag(h, TAG_DT, "csWl",
d777 1
a777 1
			print_otag(h, TAG_DT, "csWl", cattr,
d840 1
a840 1
			print_otag(h, TAG_COL, "sww", bl->cols[i]);
d887 1
a887 1
		print_otag(h, TAG_DL, "cswl", cattr, bl->width);
@


1.160
log
@Move .sp to the roff modules.  Enough infrastructure is in place
now that this actually saves code: -70 LOC.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.159 2017/05/05 13:17:04 schwarze Exp $ */
d360 3
a362 3
		if (' ' == *n->string && NODE_LINE & n->flags)
			if ( ! (HTML_LITERAL & h->flags))
				print_otag(h, TAG_BR, "");
@


1.159
log
@move .ll to the roff modules
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.158 2017/05/05 02:06:17 schwarze Exp $ */
a108 1
static	int		  mdoc_sp_pre(MDOC_ARGS);
a236 1
	{mdoc_sp_pre, NULL}, /* sp */
d1008 2
a1010 2
		case ROFF_br:
		case MDOC_sp:
a1321 22
}

static int
mdoc_sp_pre(MDOC_ARGS)
{
	struct roffsu	 su;

	SCALE_VS_INIT(&su, 1);
	if (NULL != (n = n->child)) {
		if ( ! a2roffsu(n->string, &su, SCALE_VS))
			su.scale = 1.0;
		else if (su.scale < 0.0)
			su.scale = 0.0;
	}

	print_otag(h, TAG_DIV, "suh", &su);

	/* So the div isn't empty: */
	print_text(h, "\\~");

	return 0;

@


1.158
log
@Move handling of the roff(7) .ft request from the man(7)
modules to the new roff(7) modules.  As a side effect,
mdoc(7) now handles .ft, too.  Of course, do not use that.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.157 2017/05/04 22:07:44 schwarze Exp $ */
a240 1
	{mdoc_skip_pre, NULL}, /* ll */
@


1.157
log
@Start roff formatter modules for HTML and termininal output,
used by both the mdoc and man formatters, with the ultimate
goal of reducing code duplication between the two macro formatters.
Made possible by the parser unification.
Add the first formatting function (for the .br request).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.156 2017/05/04 17:48:24 schwarze Exp $ */
d396 1
@


1.156
log
@Parser reorg:
Generate the first node on the roff level: .br
Fix some column numbers in diagnostic messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.155 2017/04/24 23:06:09 schwarze Exp $ */
d395 1
a395 7
			switch(n->tok) {
			case ROFF_br:
				mdoc_sp_pre(meta, n, h);
				break;
			default:
				abort();
			}
d1332 6
a1337 10

	if (MDOC_sp == n->tok) {
		if (NULL != (n = n->child)) {
			if ( ! a2roffsu(n->string, &su, SCALE_VS))
				su.scale = 1.0;
			else if (su.scale < 0.0)
				su.scale = 0.0;
		}
	} else
		su.scale = 0.0;
@


1.155
log
@Continue parser unification:
* Make enum rofft an internal interface as enum roff_tok in "roff.h".
* Represent mdoc and man macros in enum roff_tok.
* Make TOKEN_NONE a proper enum value and use it throughout.
* Put the prologue macros first in the macro tables.
* Unify mdoc_macroname[] and man_macroname[] into roff_name[].
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.154 2017/04/17 12:52:00 schwarze Exp $ */
a237 1
	{mdoc_sp_pre, NULL}, /* br */
d394 10
d425 3
a427 1
		if (mdocs[n->tok].post == NULL || n->flags & NODE_ENDED)
d1017 1
a1017 1
		case MDOC_br:
@


1.154
log
@Fix handling of trailing punctuation in .Lk.
This macro is unusual in so far as trailing punction needs to remain
inside the scope because it must be inside, not after the display
of long URIs in terminal output mode.
Improves formatting of fw_update(1), help(1), less(1), sendbug(1),
acx(4), inet6(4), ipsec(4), oce(4), isakmpd.conf(5), afterboot(8),
release(8), traceroute(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.153 2017/03/17 12:06:02 schwarze Exp $ */
d119 1
a119 2
static	const struct htmlmdoc mdocs[MDOC_MAX] = {
	{mdoc_ap_pre, NULL}, /* Ap */
d135 1
d244 1
d395 3
a397 1
		if (mdocs[n->tok].pre && (n->end == ENDBODY_NOT || n->child))
d416 1
a416 1
		if ( ! mdocs[n->tok].post || n->flags & NODE_ENDED)
@


1.153
log
@Fix regression in mdoc_html.c 1.150, man_html 1.87:
For .Sh, .Ss, .SH, .SS, only write selflink if an id could be constructed.
Crash reported by Raf Czlonka <rczlonka at gmail dot com>,
analysis of root cause by natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.152 2017/03/15 11:29:50 schwarze Exp $ */
d1347 3
a1349 1
	if (NULL == (n = n->child))
d1352 5
a1356 5
	assert(n->type == ROFFT_TEXT);

	print_otag(h, TAG_A, "cTh", "Lk", n->string);

	if (NULL == n->next)
d1358 1
d1360 3
a1362 1
	for (n = n->next; n; n = n->next)
d1364 2
a1365 1

@


1.152
log
@Minimal support for deep linking into man(7) pages.
As the man(7) language does not provide semantic markup,
only .SH, .SS, and .UR become anchors for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.151 2017/03/14 01:34:57 schwarze Exp $ */
d502 2
a503 1
		print_otag(h, TAG_A, "chR", "selflink", id);
d526 2
a527 1
	print_otag(h, TAG_A, "chR", "selflink", id);
@


1.151
log
@Slightly increase widths calculated from string lengths (mainly
for .Bl -tag lists and SYNOPSIS .Nm blocks), such that the text
still fits even if it is printed in bold font.
This is an ugly band aid - but implementing font-dependent width
measurements would be a major project and even more difficult
for HTML than for PostScript.

Issue reported by Jan Stary <hans at stare dot cz>.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.150 2017/03/13 20:22:11 schwarze Exp $ */
a49 1
static	char		 *make_id(const struct roff_node *);
a477 22
make_id(const struct roff_node *n)
{
	const struct roff_node	*nch;
	char			*buf, *cp;

	for (nch = n->child; nch != NULL; nch = nch->next)
		if (nch->type != ROFFT_TEXT)
			return NULL;

	buf = NULL;
	deroff(&buf, n);

	/* http://www.w3.org/TR/html5/dom.html#the-id-attribute */

	for (cp = buf; *cp != '\0'; cp++)
		if (*cp == ' ')
			*cp = '_';

	return buf;
}

static char *
d489 1
a489 1
		return make_id(n);
d500 1
a500 1
		id = make_id(n);
d523 1
a523 1
	id = make_id(n);
d933 1
a933 1
	id = make_id(n);
d1106 1
a1106 1
	    make_id(n) : NULL;
@


1.150
log
@Port ctags-style, less(1) :t internal searching from terminal output
to HTML output.  For certain macros appearing at the beginning of .It
heads, write HTML id="..." attributes such that deep linking works.
Write HTML <a> attributes such that you can easily copy out link
targets with the mouse.  Try: http://man.openbsd.org/vmctl.8#create

Feature suggested by <guettliml at Thomas dash Guettler dot de>,
some details of the design and implementation by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.149 2017/03/13 19:01:14 schwarze Exp $ */
d629 2
a630 1
	print_otag(h, TAG_COL, "shw", len);
@


1.149
log
@Print title="..." in addition to id="..." attributes for macro keys
that can be searched for by apropos(1), such that you see the
semantic function in a tooltip when hovering with the mouse.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.148 2017/03/03 13:55:06 schwarze Exp $ */
d49 1
d500 16
d525 1
d548 1
d556 7
a562 1
	print_otag(h, TAG_B, "cT", "Fl");
a563 1

d576 6
a581 1
	print_otag(h, TAG_B, "cT", "Cm");
d1098 6
a1103 1
	print_otag(h, TAG_CODE, "cT", "Dv");
d1110 6
a1115 1
	print_otag(h, TAG_CODE, "cT", "Ev");
d1122 12
a1133 1
	print_otag(h, TAG_CODE, "cT", "Er");
d1487 6
a1492 1
	print_otag(h, TAG_B, "cT", "Ic");
d1544 6
a1549 1
	print_otag(h, TAG_B, "cT", "Ms");
d1585 6
a1590 1
	print_otag(h, TAG_SPAN, "c", "No");
d1597 6
a1602 1
	print_otag(h, TAG_CODE, "c", "Li");
@


1.148
log
@remove a few redundant conditions that jsg@@ found with cppcheck
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.147 2017/02/22 08:52:24 schwarze Exp $ */
d507 1
a507 1
		print_otag(h, TAG_H1, "ci", "Sh", id);
d529 1
a529 1
	print_otag(h, TAG_H2, "ci", "Ss", id);
d537 1
a537 1
	print_otag(h, TAG_B, "c", "Fl");
d552 1
a552 1
	print_otag(h, TAG_B, "c", "Cm");
d565 1
a565 1
	print_otag(h, TAG_SPAN, "c", "Nd");
d580 1
a580 1
		print_otag(h, TAG_B, "c", "Nm");
d614 1
a614 1
		print_otag(h, TAG_A, "chM", "Xr",
d618 1
a618 1
		print_otag(h, TAG_A, "c", "Xr");
d647 1
a647 1
	print_otag(h, TAG_VAR, "c", "Ar");
d896 1
a896 1
	print_otag(h, TAG_SPAN, "c", "St");
d903 1
a903 1
	print_otag(h, TAG_I, "c", "Em");
d927 1
a927 1
	print_otag(h, TAG_A, "chR", "Sx", id);
d1023 1
a1023 1
	print_otag(h, TAG_I, "c", "Pa");
d1054 1
a1054 1
	print_otag(h, TAG_SPAN, "c", "An");
d1062 1
a1062 1
	print_otag(h, TAG_B, "c", "Cd");
d1069 1
a1069 1
	print_otag(h, TAG_CODE, "c", "Dv");
d1076 1
a1076 1
	print_otag(h, TAG_CODE, "c", "Ev");
d1083 1
a1083 1
	print_otag(h, TAG_CODE, "c", "Er");
d1094 1
a1094 1
		print_otag(h, TAG_VAR, "c", "Fa");
d1099 1
a1099 1
		t = print_otag(h, TAG_VAR, "c", "Fa");
d1130 1
a1130 1
		print_otag(h, TAG_B, "c", "Fd");
d1134 1
a1134 1
	print_otag(h, TAG_B, "c", "In");
d1148 1
a1148 1
			t = print_otag(h, TAG_A, "chI", "In", buf);
d1151 1
a1151 1
			t = print_otag(h, TAG_A, "c", "In");
d1178 1
a1178 1
	print_otag(h, TAG_VAR, "c", "Vt");
d1186 1
a1186 1
	print_otag(h, TAG_VAR, "c", "Ft");
d1207 1
a1207 1
		t = print_otag(h, TAG_VAR, "c", "Ft");
d1220 1
a1220 1
	t = print_otag(h, TAG_B, "c", "Fn");
d1233 1
a1233 1
			t = print_otag(h, TAG_VAR, "css?", "Fa",
d1236 1
a1236 1
			t = print_otag(h, TAG_VAR, "c", "Fa");
d1322 1
a1322 1
	print_otag(h, TAG_A, "ch", "Lk", n->string);
d1343 1
a1343 1
		t = print_otag(h, TAG_A, "ch", "Mt", cp);
d1371 1
a1371 1
	t = print_otag(h, TAG_B, "c", "Fn");
d1395 1
a1395 1
	print_otag(h, TAG_B, "c", "In");
d1414 1
a1414 1
			t = print_otag(h, TAG_A, "chI", "In", n->string);
d1416 1
a1416 1
			t = print_otag(h, TAG_A, "c", "In");
d1437 1
a1437 1
	print_otag(h, TAG_B, "c", "Ic");
d1444 1
a1444 1
	print_otag(h, TAG_VAR, "c", "Va");
d1489 1
a1489 1
	print_otag(h, TAG_B, "c", "Ms");
d1518 1
a1518 1
	print_otag(h, TAG_CITE, "c", "Rs");
d1539 1
a1539 1
	print_otag(h, TAG_B, "c", "Sy");
d1549 1
a1549 1
	print_otag(h, TAG_SPAN, "c", "Lb");
@


1.147
log
@Handle an odd edge case where .It is preceded by .Sm.
NULL dereference in man.cgi reported by Gabriel Guzman <gabe at
guzman dash nunez dot com> on misc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.146 2017/02/16 02:59:42 schwarze Exp $ */
d667 1
a667 1
	while (bl != NULL && bl->tok != MDOC_Bl)
@


1.146
log
@Remove the ENDBODY_NOSPACE flag, simplifying the code.

Comparing to groff output, it appears that all cases where it was used
and made a difference actually require the opposite, ENDBODY_SPACE.

I have no idea why i added it back in 2010; maybe to compensate for
some other bug that has long been fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.145 2017/02/06 03:41:44 schwarze Exp $ */
d752 1
@


1.145
log
@The .Nm macro does not only use the default name when it has no
argument, but also when the first argument is a child macro.
Arcane issue found in the FreeBSD cxgbetool(8) manual that Baptiste
Daroussin <bapt at FreeBSD> sent me long ago for a different reason.

While solving this, switch to the new technique of doing text
production in the validator, reducing code duplication in the
formatters, which also makes -Ttree output clearer.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.144 2017/02/05 21:00:18 schwarze Exp $ */
a417 2
		if (n->end == ENDBODY_NOSPACE)
			h->flags |= HTML_NOSPACE;
@


1.144
log
@Wrap .St content in a <span class="St">.
Also add forgotten <span class="Ux"> to .At rendering.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.143 2017/02/05 20:34:47 schwarze Exp $ */
a582 2
		if (n->child == NULL && meta->name != NULL)
			print_text(h, meta->name);
@


1.143
log
@fix font selection for .Bf without argument
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.142 2017/02/05 20:21:17 schwarze Exp $ */
d111 1
d157 1
a157 1
	{NULL, NULL}, /* St */
d175 1
a175 1
	{NULL, NULL}, /* At */
d893 7
@


1.142
log
@mark up .Ar, .Fa, .Va, .Ft, and .Vt with <var> rather than <i>;
suggested by bentley@@ long ago, but needed lots of cleanup first
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.141 2017/02/05 19:29:03 schwarze Exp $ */
d1470 1
a1470 1
		cattr = "none";
@


1.141
log
@for .Rs, use <cite>
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.140 2017/02/05 18:13:28 schwarze Exp $ */
d650 1
a650 1
	print_otag(h, TAG_I, "c", "Ar");
d1089 1
a1089 1
		print_otag(h, TAG_I, "c", "Fa");
d1094 1
a1094 1
		t = print_otag(h, TAG_I, "c", "Fa");
d1173 1
a1173 1
	print_otag(h, TAG_I, "c", "Vt");
d1181 1
a1181 1
	print_otag(h, TAG_I, "c", "Ft");
d1202 1
a1202 1
		t = print_otag(h, TAG_I, "c", "Ft");
d1228 1
a1228 1
			t = print_otag(h, TAG_I, "css?", "Fa",
d1231 1
a1231 1
			t = print_otag(h, TAG_I, "c", "Fa");
d1439 1
a1439 1
	print_otag(h, TAG_I, "c", "Va");
@


1.140
log
@Improve <table> syntax:
The <col> element can only appear inside <colgroup>, so use <colgroup>.
The <tbody> element is optional and useless, so don't use it.
Even if we would ever need <thead> or <tfoot>, <tbody> would still be
optional and useless; besides, we will likely never need <thead> or <tfoot>,
simply because our languages don't support such functionality.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.139 2017/01/29 14:02:19 schwarze Exp $ */
d1513 1
a1513 1
	print_otag(h, TAG_SPAN, "c", "Rs");
@


1.139
log
@eliminate one useless struct and one level of indirection;
no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.138 2017/01/28 22:36:17 schwarze Exp $ */
a428 1
	print_otag(h, TAG_TBODY, "");
a458 1
	print_otag(h, TAG_TBODY, "");
d573 1
d602 1
d605 1
a605 1
	print_otag(h, TAG_TBODY, "");
d802 1
d810 2
a811 3
	if (n->type == ROFFT_BODY) {
		if (bl->type == LIST_column)
			print_otag(h, TAG_TBODY, "");
a812 1
	}
d814 1
a814 1
	if (n->type == ROFFT_HEAD) {
d825 1
d829 1
d831 3
@


1.138
log
@Simplify usage of print_otag() even more:
accept NULL to skip the attribute or format.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.137 2017/01/28 18:42:10 schwarze Exp $ */
d350 1
a350 1
	t = h->tags.head;
d390 1
a390 1
			t = h->tags.head;
@


1.137
log
@.Bl -column with zero columns is legal, so don't segfalt on it.
Bug introduced in rev. 1.123 triggered for example in gssapi(3),
analyzed and reported by Michael <Stapelberg at debian dot org>.
Simplify the code a bit more while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.136 2017/01/25 02:14:41 schwarze Exp $ */
d508 5
a512 2
	case ROFFT_BLOCK:
		return 1;
d516 1
a516 1
		return 1;
a519 7

	if ((id = make_id(n)) != NULL) {
		print_otag(h, TAG_H1, "ci", "Sh", id);
		free(id);
	} else
		print_otag(h, TAG_H1, "c", "Sh");

d531 3
a533 6
	if ((id = make_id(n)) != NULL) {
		print_otag(h, TAG_H2, "ci", "Ss", id);
		free(id);
	} else
		print_otag(h, TAG_H2, "c", "Ss");

d743 2
a744 5
			if (bl->norm->Bl.width == NULL)
				print_otag(h, TAG_DD, "c", cattr);
			else
				print_otag(h, TAG_DD, "cswl", cattr,
				    bl->norm->Bl.width);
d756 2
a757 5
				if (bl->norm->Bl.width == NULL)
					t = print_otag(h, TAG_DT, "c", cattr);
				else
					t = print_otag(h, TAG_DT, "csWl",
					    cattr, bl->norm->Bl.width);
d764 2
a765 5
			if (bl->norm->Bl.width == NULL)
				print_otag(h, TAG_DT, "c", cattr);
			else
				print_otag(h, TAG_DT, "csWl", cattr,
				    bl->norm->Bl.width);
d870 1
a870 4
		if (bl->width == NULL)
			print_otag(h, TAG_DL, "c", cattr);
		else
			print_otag(h, TAG_DL, "cswl", cattr, bl->width);
d879 1
a879 6

	if (bl->offs)
		print_otag(h, elemtype, "cswl", cattr, bl->offs);
	else
		print_otag(h, elemtype, "c", cattr);

d917 3
a919 6
	if ((id = make_id(n)) != NULL) {
		print_otag(h, TAG_A, "chR", "Sx", id);
		free(id);
	} else
		print_otag(h, TAG_A, "c", "Sx");

@


1.136
log
@Improve HTML formatting of .Bl -tag.

In particular, when using the style sheet, put the body on the same
line as the head for short heads, or on the next line for long
heads, in a way that preserves both correct indentation and correct
vertical spacing with and without -compact, and with one or more
heads per body (hi, Zaphod) - eight use cases so far - and with and
without -tag, and with and without -offset, 32 use cases grand total.

Using many ideas from zhuk@@, from <David dot Dahlberg at fkie dot
fraunhofer dot de>, and from Benny Lofgren <bl dash lists at lofgren
dot biz>, and a few of my own.

This is an excellent demonstration that CSS is an extremely hostile
language, much more trapful and much harder to use than, say, C.
When matthew@@ reported this in July 2014 (!), it was already a known
issue, and i no longer remember for how long.  My first serious
attempt at fixing it (in November 2015) failed miserably.  I'd love
to see simplifications of both the generated HTML code and of the
style sheet, but without breaking any of the 32 use cases, please.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.135 2017/01/21 02:09:49 schwarze Exp $ */
d818 1
d820 1
a820 1
	int		 i;
d823 2
d826 1
a826 1
		if (LIST_column == n->norm->Bl.type)
d832 1
a832 1
		if (LIST_column != n->norm->Bl.type)
d842 3
a844 4
		for (i = 0; i < (int)n->norm->Bl.ncols - 1; i++)
			print_otag(h, TAG_COL, "sww", n->norm->Bl.cols[i]);
		print_otag(h, TAG_COL, "swW", n->norm->Bl.cols[i]);

d848 1
a848 1
	switch (n->norm->Bl.type) {
d884 3
a886 4
		if (n->norm->Bl.offs)
			print_otag(h, TAG_DIV, "cswl", cattr,
			    n->norm->Bl.offs);
		if (n->norm->Bl.width == NULL)
d889 1
a889 2
			print_otag(h, TAG_DL, "cswl", cattr,
			    n->norm->Bl.width);
d899 2
a900 2
	if (n->norm->Bl.offs)
		print_otag(h, elemtype, "cswl", cattr, n->norm->Bl.offs);
@


1.135
log
@Avoid writing constant style attributes over and over again.
Move them to the style sheet.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.134 2017/01/21 01:20:29 schwarze Exp $ */
d672 1
a739 1
	case LIST_tag:
d760 35
a880 1
		elemtype = TAG_DL;
d882 9
a890 1
		break;
@


1.134
log
@clean up the remaining class attributes
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.133 2017/01/20 23:50:59 schwarze Exp $ */
d726 4
a729 2
			print_otag(h, TAG_LI, "csvt", cattr,
			    !bl->norm->Bl.comp);
d742 4
a745 2
			print_otag(h, TAG_DT, "csvt", cattr,
			    !bl->norm->Bl.comp);
d765 4
a768 2
			print_otag(h, TAG_TD, "csvt", cattr,
			    !bl->norm->Bl.comp);
d858 1
a858 2
		print_otag(h, elemtype, "csvtvbwl", cattr, 0, 0,
		    n->norm->Bl.offs);
d860 1
a860 1
		print_otag(h, elemtype, "csvtvb", cattr, 0, 0);
@


1.133
log
@Standardize class attributes for semantic macros.
Correct markup for .Va and iprove markup for .Dv, .Er, .Ev while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.132 2017/01/20 21:37:52 schwarze Exp $ */
d575 1
a575 1
	print_otag(h, TAG_SPAN, "c", "desc");
d664 1
a664 1
	print_otag(h, TAG_SPAN, "c", "unix");
d871 1
a871 1
	print_otag(h, TAG_SPAN, "c", "emph");
d1440 1
a1440 1
		cattr = "emph";
d1442 1
a1442 1
		cattr = "symb";
d1496 1
a1496 1
	print_otag(h, TAG_SPAN, "c", "none");
d1510 1
a1510 1
	print_otag(h, TAG_SPAN, "c", "symb");
@


1.132
log
@standardize .Rs class attributes
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.131 2017/01/20 19:58:00 schwarze Exp $ */
d71 1
d137 1
a137 1
	{mdoc_fl_pre, NULL}, /* Cm */
d547 1
a547 7
	print_otag(h, TAG_B, "c", "flag");

	/* `Cm' has no leading hyphen. */

	if (MDOC_Cm == n->tok)
		return 1;

d560 7
d589 1
a589 1
		print_otag(h, TAG_B, "c", "name");
d601 1
a601 1
	print_otag(h, TAG_TABLE, "c", "synopsis");
d657 1
a657 1
	print_otag(h, TAG_I, "c", "arg");
d994 1
a994 1
	print_otag(h, TAG_I, "c", "file");
d1001 1
a1001 1
	print_otag(h, TAG_I, "c", "addr");
d1025 1
a1025 1
	print_otag(h, TAG_SPAN, "c", "author");
d1033 1
a1033 1
	print_otag(h, TAG_B, "c", "config");
d1040 1
a1040 1
	print_otag(h, TAG_SPAN, "c", "define");
d1047 1
a1047 1
	print_otag(h, TAG_SPAN, "c", "env");
d1054 1
a1054 1
	print_otag(h, TAG_SPAN, "c", "errno");
d1065 1
a1065 1
		print_otag(h, TAG_I, "c", "farg");
d1070 1
a1070 1
		t = print_otag(h, TAG_I, "c", "farg");
d1101 1
a1101 1
		print_otag(h, TAG_B, "c", "macro");
d1105 1
a1105 1
	print_otag(h, TAG_B, "c", "includes");
d1119 1
a1119 1
			t = print_otag(h, TAG_A, "chI", "link-includes", buf);
d1122 1
a1122 1
			t = print_otag(h, TAG_A, "c", "link-includes");
d1149 1
a1149 1
	print_otag(h, TAG_SPAN, "c", "type");
d1157 1
a1157 1
	print_otag(h, TAG_I, "c", "ftype");
d1178 1
a1178 1
		t = print_otag(h, TAG_I, "c", "ftype");
d1191 1
a1191 1
	t = print_otag(h, TAG_B, "c", "fname");
d1204 1
a1204 1
			t = print_otag(h, TAG_I, "css?", "farg",
d1207 1
a1207 1
			t = print_otag(h, TAG_I, "c", "farg");
d1293 1
a1293 1
	print_otag(h, TAG_A, "ch", "link-ext", n->string);
d1314 1
a1314 1
		t = print_otag(h, TAG_A, "ch", "link-mail", cp);
d1342 1
a1342 1
	t = print_otag(h, TAG_B, "c", "fname");
d1366 1
a1366 1
	print_otag(h, TAG_B, "c", "includes");
d1385 1
a1385 2
			t = print_otag(h, TAG_A, "chI", "link-includes",
			    n->string);
d1387 1
a1387 1
			t = print_otag(h, TAG_A, "c", "link-includes");
d1408 1
a1408 1
	print_otag(h, TAG_B, "c", "cmd");
d1415 1
a1415 1
	print_otag(h, TAG_B, "c", "var");
d1460 1
a1460 1
	print_otag(h, TAG_SPAN, "c", "symb");
d1520 1
a1520 1
	print_otag(h, TAG_SPAN, "c", "lib");
d1659 1
a1659 1
		print_otag(h, TAG_SPAN, "c", "opt");
@


1.131
log
@standardize .Bl and .It class attributes
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.130 2017/01/19 16:56:53 schwarze Exp $ */
d1488 1
a1488 1
	print_otag(h, TAG_SPAN, "c", "ref");
d1533 1
a1533 1
		cattr = "ref-auth";
a1538 1
		cattr = "ref-book";
d1540 1
d1543 1
a1543 1
		cattr = "ref-city";
d1546 1
a1546 1
		cattr = "ref-date";
a1548 1
		cattr = "ref-issue";
d1550 1
a1552 1
		cattr = "ref-jrnl";
d1554 1
d1557 1
a1557 1
		cattr = "ref-num";
d1560 1
a1560 1
		cattr = "ref-opt";
d1563 1
a1563 1
		cattr = "ref-page";
d1566 1
a1566 1
		cattr = "ref-corp";
d1569 1
a1569 1
		cattr = "ref-rep";
d1572 1
a1572 1
		cattr = "ref-title";
d1575 2
a1576 2
		cattr = "link-ref";
		break;
d1578 1
a1578 1
		cattr = "ref-vol";
d1584 1
a1584 7
	if (MDOC__U != n->tok) {
		print_otag(h, t, "c", cattr);
		return 1;
	}

	print_otag(h, TAG_A, "ch", cattr, n->child->string);

@


1.130
log
@clean up markup of .Bd, .D1, .Dl, .Li, and .Ql;
in particular, stop abuse of <blockquote>
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.129 2017/01/19 15:48:34 schwarze Exp $ */
a242 15
static	const char * const lists[LIST_MAX] = {
	NULL,
	"list-bul",
	"list-col",
	"list-dash",
	"list-diag",
	"list-enum",
	"list-hang",
	"list-hyph",
	"list-inset",
	"list-item",
	"list-ohang",
	"list-tag"
};

d669 3
a671 2
	enum mdoc_list	 type;
	const struct roff_node *bl;
d674 1
a674 1
	while (bl && MDOC_Bl != bl->tok)
d678 44
a721 7
	if (n->type == ROFFT_HEAD) {
		switch (type) {
		case LIST_bullet:
		case LIST_dash:
		case LIST_item:
		case LIST_hyphen:
		case LIST_enum:
d723 2
a724 6
		case LIST_diag:
		case LIST_hang:
		case LIST_inset:
		case LIST_ohang:
		case LIST_tag:
			print_otag(h, TAG_DT, "csvt", lists[type],
a725 5
			if (LIST_diag != type)
				break;
			print_otag(h, TAG_B, "c", "diag");
			break;
		case LIST_column:
d730 9
a738 8
	} else if (n->type == ROFFT_BODY) {
		switch (type) {
		case LIST_bullet:
		case LIST_hyphen:
		case LIST_dash:
		case LIST_enum:
		case LIST_item:
			print_otag(h, TAG_LI, "csvt", lists[type],
d740 2
d743 6
a748 15
		case LIST_diag:
		case LIST_hang:
		case LIST_inset:
		case LIST_ohang:
		case LIST_tag:
			if (NULL == bl->norm->Bl.width) {
				print_otag(h, TAG_DD, "c", lists[type]);
				break;
			}
			print_otag(h, TAG_DD, "cswl", lists[type],
			    bl->norm->Bl.width);
			break;
		case LIST_column:
			print_otag(h, TAG_TD, "csvt", lists[type],
			    !bl->norm->Bl.comp);
d753 8
a760 4
	} else {
		switch (type) {
		case LIST_column:
			print_otag(h, TAG_TR, "c", lists[type]);
d763 1
a763 1
			break;
d765 2
d775 1
a776 1
	char		 buf[BUFSIZ];
a802 4
	assert(lists[n->norm->Bl.type]);
	(void)strlcpy(buf, "list ", BUFSIZ);
	(void)strlcat(buf, lists[n->norm->Bl.type], BUFSIZ);

d805 3
d810 3
d815 1
d819 1
d822 3
d826 3
d830 3
d834 3
d839 1
d843 1
d850 1
a850 1
		print_otag(h, elemtype, "csvtvbwl", buf, 0, 0,
d853 1
a853 1
		print_otag(h, elemtype, "csvtvb", buf, 0, 0);
@


1.129
log
@clean up .Sx and .Xr HTML markup
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.128 2017/01/19 15:27:26 schwarze Exp $ */
d847 1
a847 1
	print_otag(h, TAG_BLOCKQUOTE, "svtvb", 0, 0);
d849 2
a850 6
	/* BLOCKQUOTE needs a block body. */

	print_otag(h, TAG_DIV, "c", "display");

	if (MDOC_Dl == n->tok)
		print_otag(h, TAG_CODE, "c", "lit");
d906 1
a906 1
		print_otag(h, TAG_DIV, "cswl", "display", n->norm->Bd.offs);
d908 1
a908 1
		print_otag(h, TAG_DIV, "cshl", "display", offs);
d914 1
a914 1
	print_otag(h, TAG_PRE, "c", "lit");
d1411 1
a1411 1
		cattr = "lit";
d1470 1
a1470 1
	print_otag(h, TAG_CODE, "c", "lit");
d1653 1
a1653 1
		print_otag(h, TAG_CODE, "c", "lit");
@


1.128
log
@Clean up CSS rules for sections and paragraphs.
Start using real macro names for CSS classes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.127 2017/01/19 13:34:59 schwarze Exp $ */
d49 1
d494 1
a494 1
char *
d637 1
a637 1
		print_otag(h, TAG_A, "chM", "link-man",
d641 1
a641 1
		print_otag(h, TAG_A, "c", "link-man");
a863 1
	print_otag(h, TAG_I, "c", "link-sec");
d865 1
a865 1
		print_otag(h, TAG_A, "chR", "link-sec", id);
d868 1
a868 1
		print_otag(h, TAG_A, "c", "link-sec");
@


1.127
log
@Start cleanup: trim useless HTML comments and <div> elements
on the <html> and <body> levels.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.126 2017/01/19 01:00:11 schwarze Exp $ */
d314 1
d316 1
a521 1
		print_otag(h, TAG_DIV, "c", "section");
d532 1
a532 1
		print_otag(h, TAG_H1, "i", id);
d535 1
a535 1
		print_otag(h, TAG_H1, "");
d545 1
a545 4
	if (n->type == ROFFT_BLOCK) {
		print_otag(h, TAG_DIV, "c", "subsection");
		return 1;
	} else if (n->type == ROFFT_BODY)
d549 1
a549 1
		print_otag(h, TAG_H2, "i", id);
d552 1
a552 1
		print_otag(h, TAG_H2, "");
@


1.126
log
@Implement line breaking of the generated HTML code at space characters
in filled text.  This does not affect HTML semantics, but makes the
HTML code even more humanly readable.

While here,
- collapse multiple consecutive space characters in filled text
- and insert a blank between style entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.125 2017/01/18 19:22:18 schwarze Exp $ */
d300 1
a300 1
	struct tag	*t, *tt;
d304 1
a304 1
	if ( ! (HTML_FRAGMENT & h->oflags)) {
d306 2
a307 2
		t = print_otag(h, TAG_HTML, "");
		tt = print_otag(h, TAG_HEAD, "");
d309 1
a309 1
		print_tagq(h, tt);
d311 1
a311 3
		print_otag(h, TAG_DIV, "c", "mandoc");
	} else
		t = print_otag(h, TAG_DIV, "c", "mandoc");
d316 1
a316 1
	print_tagq(h, t);
@


1.125
log
@Make HTML output more human readable by overhauling line break logic
around tags and by introducing some simple indentation.
No change of HTML semantics intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.124 2017/01/17 15:32:39 schwarze Exp $ */
a384 2
		if (n->flags & NODE_LINE)
			putchar('\n');
@


1.124
log
@Completely delete the buf field of struct html and all the buf*()
interfaces.  Such a static buffer was a bad idea in the first place,
causing unfixable truncation that was only prevented by triggering
an assertion failure.  Instead, let the small number of remaining
users allocate and free their own, temporary dynamic buffers,
or for the case of .Xr and .In, pass the original data to be
assembled in print_otag().
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.123 2017/01/17 01:47:46 schwarze Exp $ */
a318 1
	putchar('\n');
@


1.123
log
@Simplify the usage of print_otag() by making it accept a variable
number of arguments.

Delete struct htmlpair and all the PAIR_*() macros.
Delete enum htmlattr, handle that in print_otag() instead.

Minus 190 lines of code; no functional change except better ordering
of attributes (class before style) in three cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.122 2017/01/11 17:39:45 schwarze Exp $ */
d325 1
d328 10
a337 6
	bufinit(h);
	bufcat(h, meta->title);
	if (meta->msec)
		bufcat_fmt(h, "(%s)", meta->msec);
	if (meta->arch)
		bufcat_fmt(h, " (%s)", meta->arch);
d340 2
a341 1
	print_text(h, h->buf);
d496 22
d521 2
d535 4
a538 11
	bufinit(h);

	for (n = n->child; n != NULL && n->type == ROFFT_TEXT; ) {
		bufcat_id(h, n->string);
		if (NULL != (n = n->next))
			bufcat_id(h, " ");
	}

	if (NULL == n)
		print_otag(h, TAG_H1, "i", h->buf);
	else
d547 2
d555 4
a558 11
	bufinit(h);

	for (n = n->child; n != NULL && n->type == ROFFT_TEXT; ) {
		bufcat_id(h, n->string);
		if (NULL != (n = n->next))
			bufcat_id(h, " ");
	}

	if (NULL == n)
		print_otag(h, TAG_H2, "i", h->buf);
	else
d642 5
a646 6
	if (h->base_man) {
		buffmt_man(h, n->child->string,
		    n->child->next ?
		    n->child->next->string : NULL);
		print_otag(h, TAG_A, "ch", "link-man", h->buf);
	} else
d868 1
a868 2
	bufinit(h);
	bufcat(h, "#");
d870 6
a875 5
	for (n = n->child; n; ) {
		bufcat_id(h, n->string);
		if (NULL != (n = n->next))
			bufcat_id(h, " ");
	}
a876 2
	print_otag(h, TAG_I, "c", "link-sec");
	print_otag(h, TAG_A, "ch", "link-sec", h->buf);
a1066 2
	char		 buf[BUFSIZ];
	size_t		 sz;
d1068 1
a1087 15
		/*
		 * XXX This is broken and not easy to fix.
		 * When using -Oincludes, truncation may occur.
		 * Dynamic allocation wouldn't help because
		 * passing long strings to buffmt_includes()
		 * does not work either.
		 */

		strlcpy(buf, '<' == *n->string || '"' == *n->string ?
		    n->string + 1 : n->string, BUFSIZ);

		sz = strlen(buf);
		if (sz && ('>' == buf[sz - 1] || '"' == buf[sz - 1]))
			buf[sz - 1] = '\0';

d1089 9
a1097 3
			buffmt_includes(h, buf);
			t = print_otag(h, TAG_A, "ch", "link-includes",
			    h->buf);
d1285 1
d1290 2
a1291 4
		bufinit(h);
		bufcat(h, "mailto:");
		bufcat(h, n->string);
		t = print_otag(h, TAG_A, "ch", "link-mail", h->buf);
d1294 1
d1361 4
a1364 5
		if (h->base_includes) {
			buffmt_includes(h, n->string);
			t = print_otag(h, TAG_A, "ch", "link-includes",
			    h->buf);
		} else
@


1.122
log
@Do text production for .Bt, .Ex, .Rv, .Ud at the validation stage
rather than in the formatters.  Use NODE_NOSRC flag for .Lb and
NODE_NOSRC and NODE_NOPRT for .St.  Results in a more rigorous
syntax tree and in 135 lines less code.

This work was triggered by a question from Abhinav Upadhyay <er dot
abhinav dot upadhyay at gmail dot com> (NetBSD) on discuss@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.121 2017/01/10 23:36:24 schwarze Exp $ */
a54 2
static	void		  a2width(const char *, struct roffsu *);

a258 16
 * Calculate the scaling unit passed in a `-width' argument.  This uses
 * either a native scaling unit (e.g., 1i, 2m) or the string length of
 * the value.
 */
static void
a2width(const char *p, struct roffsu *su)
{

	if (a2roffsu(p, su, SCALE_MAX) < 2) {
		su->unit = SCALE_EN;
		su->scale = html_strlen(p);
	} else if (su->scale < 0.0)
		su->scale = 0.0;
}

/*
d272 1
a272 1
		print_otag(h, TAG_BR, 0, NULL);
d291 1
a291 1
		print_otag(h, TAG_BR, 0, NULL);
a298 1
	struct htmlpair	 tag;
a301 1
	PAIR_CLASS_INIT(&tag, "mandoc");
d306 2
a307 2
		t = print_otag(h, TAG_HTML, 0, NULL);
		tt = print_otag(h, TAG_HEAD, 0, NULL);
d310 2
a311 2
		print_otag(h, TAG_BODY, 0, NULL);
		print_otag(h, TAG_DIV, 1, &tag);
d313 1
a313 1
		t = print_otag(h, TAG_DIV, 1, &tag);
d334 1
a334 1
	print_otag(h, TAG_TITLE, 0, NULL);
d372 1
a372 1
				print_otag(h, TAG_BR, 0, NULL);
a435 1
	struct htmlpair	 tag;
d438 3
a440 4
	PAIR_CLASS_INIT(&tag, "foot");
	t = print_otag(h, TAG_TABLE, 1, &tag);

	print_otag(h, TAG_TBODY, 0, NULL);
d442 1
a442 4
	tt = print_otag(h, TAG_TR, 0, NULL);

	PAIR_CLASS_INIT(&tag, "foot-date");
	print_otag(h, TAG_TD, 1, &tag);
d446 1
a446 2
	PAIR_CLASS_INIT(&tag, "foot-os");
	print_otag(h, TAG_TD, 1, &tag);
a453 1
	struct htmlpair	 tag;
d469 3
a471 6
	PAIR_CLASS_INIT(&tag, "head");
	t = print_otag(h, TAG_TABLE, 1, &tag);

	print_otag(h, TAG_TBODY, 0, NULL);

	tt = print_otag(h, TAG_TR, 0, NULL);
d473 1
a473 2
	PAIR_CLASS_INIT(&tag, "head-ltitle");
	print_otag(h, TAG_TD, 1, &tag);
d477 1
a477 2
	PAIR_CLASS_INIT(&tag, "head-vol");
	print_otag(h, TAG_TD, 1, &tag);
d481 1
a481 2
	PAIR_CLASS_INIT(&tag, "head-rtitle");
	print_otag(h, TAG_TD, 1, &tag);
a492 2
	struct htmlpair	 tag;

d495 1
a495 2
		PAIR_CLASS_INIT(&tag, "section");
		print_otag(h, TAG_DIV, 1, &tag);
d513 4
a516 5
	if (NULL == n) {
		PAIR_ID_INIT(&tag, h->buf);
		print_otag(h, TAG_H1, 1, &tag);
	} else
		print_otag(h, TAG_H1, 0, NULL);
a523 2
	struct htmlpair	 tag;

d525 1
a525 2
		PAIR_CLASS_INIT(&tag, "subsection");
		print_otag(h, TAG_DIV, 1, &tag);
d538 4
a541 5
	if (NULL == n) {
		PAIR_ID_INIT(&tag, h->buf);
		print_otag(h, TAG_H2, 1, &tag);
	} else
		print_otag(h, TAG_H2, 0, NULL);
d549 1
a549 4
	struct htmlpair	 tag;

	PAIR_CLASS_INIT(&tag, "flag");
	print_otag(h, TAG_B, 1, &tag);
a569 2
	struct htmlpair	 tag;

d576 1
a576 2
	PAIR_CLASS_INIT(&tag, "desc");
	print_otag(h, TAG_SPAN, 1, &tag);
a582 2
	struct htmlpair	 tag;
	struct roffsu	 su;
d587 1
a587 1
		print_otag(h, TAG_TD, 0, NULL);
d590 1
a590 2
		PAIR_CLASS_INIT(&tag, "name");
		print_otag(h, TAG_B, 1, &tag);
d595 1
a595 1
		print_otag(h, TAG_TD, 0, NULL);
d602 1
a602 2
	PAIR_CLASS_INIT(&tag, "synopsis");
	print_otag(h, TAG_TABLE, 1, &tag);
d611 4
a614 8
	SCALE_HS_INIT(&su, len);
	bufinit(h);
	bufcat_su(h, "width", &su);
	PAIR_STYLE_INIT(&tag, h);
	print_otag(h, TAG_COL, 1, &tag);
	print_otag(h, TAG_COL, 0, NULL);
	print_otag(h, TAG_TBODY, 0, NULL);
	print_otag(h, TAG_TR, 0, NULL);
a620 2
	struct htmlpair	 tag[2];

a623 2
	PAIR_CLASS_INIT(&tag[0], "link-man");

d628 1
a628 2
		PAIR_HREF_INIT(&tag[1], h->buf);
		print_otag(h, TAG_A, 2, tag);
d630 1
a630 1
		print_otag(h, TAG_A, 1, tag);
d659 1
a659 4
	struct htmlpair tag;

	PAIR_CLASS_INIT(&tag, "arg");
	print_otag(h, TAG_I, 1, &tag);
d666 1
a666 4
	struct htmlpair	 tag;

	PAIR_CLASS_INIT(&tag, "unix");
	print_otag(h, TAG_SPAN, 1, &tag);
a672 1
	struct roffsu	 su;
a673 1
	struct htmlpair	 tag[2];
a678 3

	assert(bl);

a680 5
	assert(lists[type]);
	PAIR_CLASS_INIT(&tag[0], lists[type]);

	bufinit(h);

d694 2
a695 4
			SCALE_VS_INIT(&su, ! bl->norm->Bl.comp);
			bufcat_su(h, "margin-top", &su);
			PAIR_STYLE_INIT(&tag[1], h);
			print_otag(h, TAG_DT, 2, tag);
d698 1
a698 2
			PAIR_CLASS_INIT(&tag[0], "diag");
			print_otag(h, TAG_B, 1, tag);
d712 2
a713 4
			SCALE_VS_INIT(&su, ! bl->norm->Bl.comp);
			bufcat_su(h, "margin-top", &su);
			PAIR_STYLE_INIT(&tag[1], h);
			print_otag(h, TAG_LI, 2, tag);
d721 1
a721 1
				print_otag(h, TAG_DD, 1, tag);
d724 2
a725 4
			a2width(bl->norm->Bl.width, &su);
			bufcat_su(h, "margin-left", &su);
			PAIR_STYLE_INIT(&tag[1], h);
			print_otag(h, TAG_DD, 2, tag);
d728 2
a729 4
			SCALE_VS_INIT(&su, ! bl->norm->Bl.comp);
			bufcat_su(h, "margin-top", &su);
			PAIR_STYLE_INIT(&tag[1], h);
			print_otag(h, TAG_TD, 2, tag);
d737 1
a737 1
			print_otag(h, TAG_TR, 1, tag);
a750 2
	struct htmlpair	 tag[3];
	struct roffsu	 su;
d752 1
d756 1
a756 1
			print_otag(h, TAG_TBODY, 0, NULL);
d771 3
a773 10
		for (i = 0; i < (int)n->norm->Bl.ncols; i++) {
			bufinit(h);
			a2width(n->norm->Bl.cols[i], &su);
			if (i < (int)n->norm->Bl.ncols - 1)
				bufcat_su(h, "width", &su);
			else
				bufcat_su(h, "min-width", &su);
			PAIR_STYLE_INIT(&tag[0], h);
			print_otag(h, TAG_COL, 1, tag);
		}
a777 6
	SCALE_VS_INIT(&su, 0);
	bufinit(h);
	bufcat_su(h, "margin-top", &su);
	bufcat_su(h, "margin-bottom", &su);
	PAIR_STYLE_INIT(&tag[0], h);

a780 8
	PAIR_INIT(&tag[1], ATTR_CLASS, buf);

	/* Set the block's left-hand margin. */

	if (n->norm->Bl.offs) {
		a2width(n->norm->Bl.offs, &su);
		bufcat_su(h, "margin-left", &su);
	}
d787 1
a787 1
		print_otag(h, TAG_UL, 2, tag);
d790 1
a790 1
		print_otag(h, TAG_OL, 2, tag);
d797 1
a797 1
		print_otag(h, TAG_DL, 2, tag);
d800 1
a800 1
		print_otag(h, TAG_TABLE, 2, tag);
d806 6
d819 1
a819 1
		print_otag(h, TAG_BR, 0, NULL);
d826 1
a826 4
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "emph");
	print_otag(h, TAG_SPAN, 1, &tag);
a832 3
	struct htmlpair	 tag[2];
	struct roffsu	 su;

d836 1
a836 6
	SCALE_VS_INIT(&su, 0);
	bufinit(h);
	bufcat_su(h, "margin-top", &su);
	bufcat_su(h, "margin-bottom", &su);
	PAIR_STYLE_INIT(&tag[0], h);
	print_otag(h, TAG_BLOCKQUOTE, 1, tag);
d840 1
a840 2
	PAIR_CLASS_INIT(&tag[0], "display");
	print_otag(h, TAG_DIV, 1, tag);
d842 2
a843 4
	if (MDOC_Dl == n->tok) {
		PAIR_CLASS_INIT(&tag[0], "lit");
		print_otag(h, TAG_CODE, 1, tag);
	}
a850 2
	struct htmlpair	 tag[2];

d860 2
a861 5
	PAIR_CLASS_INIT(&tag[0], "link-sec");
	PAIR_HREF_INIT(&tag[1], h->buf);

	print_otag(h, TAG_I, 1, tag);
	print_otag(h, TAG_A, 2, tag);
d868 1
a868 2
	struct htmlpair		 tag[2];
	int			 comp, sv;
a869 1
	struct roffsu		 su;
d893 1
a893 1
		SCALE_HS_INIT(&su, 0);
d895 1
a895 1
		SCALE_HS_INIT(&su, INDENT);
d897 1
a897 1
		SCALE_HS_INIT(&su, INDENT * 2);
d899 1
a899 1
		a2width(n->norm->Bd.offs, &su);
d901 4
a904 6
	bufinit(h);
	bufcat_su(h, "margin-left", &su);
	PAIR_STYLE_INIT(&tag[0], h);

	PAIR_CLASS_INIT(&tag[1], "display");
	print_otag(h, TAG_DIV, 2, tag);
d910 1
a910 2
	PAIR_CLASS_INIT(&tag[0], "lit");
	print_otag(h, TAG_PRE, 1, tag);
d956 1
a956 4
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "file");
	print_otag(h, TAG_I, 1, &tag);
d963 1
a963 4
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "addr");
	print_otag(h, TAG_I, 1, &tag);
a969 2
	struct htmlpair	tag;

d982 1
a982 1
		print_otag(h, TAG_BR, 0, NULL);
d987 1
a987 2
	PAIR_CLASS_INIT(&tag, "author");
	print_otag(h, TAG_SPAN, 1, &tag);
a993 2
	struct htmlpair	tag;

d995 1
a995 2
	PAIR_CLASS_INIT(&tag, "config");
	print_otag(h, TAG_B, 1, &tag);
d1002 1
a1002 4
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "define");
	print_otag(h, TAG_SPAN, 1, &tag);
d1009 1
a1009 4
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "env");
	print_otag(h, TAG_SPAN, 1, &tag);
d1016 1
a1016 4
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "errno");
	print_otag(h, TAG_SPAN, 1, &tag);
a1023 1
	struct htmlpair		 tag;
a1025 1
	PAIR_CLASS_INIT(&tag, "farg");
d1027 1
a1027 1
		print_otag(h, TAG_I, 1, &tag);
d1032 1
a1032 1
		t = print_otag(h, TAG_I, 1, &tag);
a1051 1
	struct htmlpair	 tag[2];
a1053 1
	int		 i;
d1064 1
a1064 2
		PAIR_CLASS_INIT(&tag[0], "macro");
		print_otag(h, TAG_B, 1, tag);
d1068 1
a1068 2
	PAIR_CLASS_INIT(&tag[0], "includes");
	print_otag(h, TAG_B, 1, tag);
a1088 3
		PAIR_CLASS_INIT(&tag[0], "link-includes");

		i = 1;
d1091 4
a1094 3
			PAIR_HREF_INIT(&tag[i], h->buf);
			i++;
		}
a1095 1
		t = print_otag(h, TAG_A, i, tag);
a1112 2
	struct htmlpair	 tag;

d1121 1
a1121 2
	PAIR_CLASS_INIT(&tag, "type");
	print_otag(h, TAG_SPAN, 1, &tag);
a1127 2
	struct htmlpair	 tag;

d1129 1
a1129 2
	PAIR_CLASS_INIT(&tag, "ftype");
	print_otag(h, TAG_I, 1, &tag);
a1136 1
	struct htmlpair	 tag[2];
d1139 1
a1139 1
	int		 sz, i, pretty;
d1150 1
a1150 2
		PAIR_CLASS_INIT(&tag[0], "ftype");
		t = print_otag(h, TAG_I, 1, tag);
d1163 1
a1163 19
	PAIR_CLASS_INIT(&tag[0], "fname");

	/*
	 * FIXME: only refer to IDs that we know exist.
	 */

#if 0
	if (NODE_SYNPRETTY & n->flags) {
		nbuf[0] = '\0';
		html_idcat(nbuf, sp, BUFSIZ);
		PAIR_ID_INIT(&tag[1], nbuf);
	} else {
		strlcpy(nbuf, "#", BUFSIZ);
		html_idcat(nbuf, sp, BUFSIZ);
		PAIR_HREF_INIT(&tag[1], nbuf);
	}
#endif

	t = print_otag(h, TAG_B, 1, tag);
a1173 5
	PAIR_CLASS_INIT(&tag[0], "farg");
	bufinit(h);
	bufcat_style(h, "white-space", "nowrap");
	PAIR_STYLE_INIT(&tag[1], h);

a1174 1
		i = 1;
d1176 4
a1179 2
			i = 2;
		t = print_otag(h, TAG_I, i, tag);
a1234 1
	struct htmlpair	 tag;
d1248 1
a1248 4
	bufinit(h);
	bufcat_su(h, "height", &su);
	PAIR_STYLE_INIT(&tag, h);
	print_otag(h, TAG_DIV, 1, &tag);
a1259 2
	struct htmlpair	 tag[2];

d1265 1
a1265 4
	PAIR_CLASS_INIT(&tag[0], "link-ext");
	PAIR_HREF_INIT(&tag[1], n->string);

	print_otag(h, TAG_A, 2, tag);
a1278 1
	struct htmlpair	 tag[2];
a1280 2
	PAIR_CLASS_INIT(&tag[0], "link-mail");

d1287 1
a1287 3

		PAIR_HREF_INIT(&tag[1], h->buf);
		t = print_otag(h, TAG_A, 2, tag);
a1297 1
	struct htmlpair	 tag;
d1314 1
a1314 2
	PAIR_CLASS_INIT(&tag, "fname");
	t = print_otag(h, TAG_B, 1, &tag);
a1335 2
	struct htmlpair	 tag[2];
	int		 i;
d1338 1
a1338 3

	PAIR_CLASS_INIT(&tag[0], "includes");
	print_otag(h, TAG_B, 1, tag);
a1355 3
		PAIR_CLASS_INIT(&tag[0], "link-includes");

		i = 1;
d1358 4
a1361 5
			PAIR_HREF_INIT(&tag[i], h->buf);
			i++;
		}

		t = print_otag(h, TAG_A, i, tag);
d1382 1
a1382 4
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "cmd");
	print_otag(h, TAG_B, 1, &tag);
d1389 1
a1389 4
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "var");
	print_otag(h, TAG_B, 1, &tag);
d1406 1
a1406 2
	struct htmlpair	 tag[2];
	struct roffsu	 su;
d1414 1
a1414 1
		PAIR_CLASS_INIT(&tag[0], "emph");
d1416 1
a1416 1
		PAIR_CLASS_INIT(&tag[0], "symb");
d1418 1
a1418 1
		PAIR_CLASS_INIT(&tag[0], "lit");
d1420 1
a1420 1
		PAIR_CLASS_INIT(&tag[0], "none");
d1426 2
a1427 7
	bufinit(h);
	bufcat_style(h, "display", "inline");
	SCALE_HS_INIT(&su, 1);
	/* Needs a left-margin for spacing. */
	bufcat_su(h, "margin-left", &su);
	PAIR_STYLE_INIT(&tag[1], h);
	print_otag(h, TAG_DIV, 2, tag);
d1434 1
a1434 4
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "symb");
	print_otag(h, TAG_SPAN, 1, &tag);
a1456 2
	struct htmlpair	 tag;

d1463 1
a1463 2
	PAIR_CLASS_INIT(&tag, "ref");
	print_otag(h, TAG_SPAN, 1, &tag);
d1470 1
a1470 4
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "none");
	print_otag(h, TAG_SPAN, 1, &tag);
d1477 1
a1477 4
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "lit");
	print_otag(h, TAG_CODE, 1, &tag);
d1484 1
a1484 4
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "symb");
	print_otag(h, TAG_SPAN, 1, &tag);
a1490 2
	struct htmlpair	tag;

d1492 1
a1492 1
		print_otag(h, TAG_BR, 0, NULL);
d1494 1
a1494 2
	PAIR_CLASS_INIT(&tag, "lib");
	print_otag(h, TAG_SPAN, 1, &tag);
d1501 2
a1502 2
	struct htmlpair	tag[2];
	enum htmltag	t;
d1508 1
a1508 1
		PAIR_CLASS_INIT(&tag[0], "ref-auth");
d1514 1
a1514 1
		PAIR_CLASS_INIT(&tag[0], "ref-book");
d1518 1
a1518 1
		PAIR_CLASS_INIT(&tag[0], "ref-city");
d1521 1
a1521 1
		PAIR_CLASS_INIT(&tag[0], "ref-date");
d1524 1
a1524 1
		PAIR_CLASS_INIT(&tag[0], "ref-issue");
d1528 1
a1528 1
		PAIR_CLASS_INIT(&tag[0], "ref-jrnl");
d1532 1
a1532 1
		PAIR_CLASS_INIT(&tag[0], "ref-num");
d1535 1
a1535 1
		PAIR_CLASS_INIT(&tag[0], "ref-opt");
d1538 1
a1538 1
		PAIR_CLASS_INIT(&tag[0], "ref-page");
d1541 1
a1541 1
		PAIR_CLASS_INIT(&tag[0], "ref-corp");
d1544 1
a1544 1
		PAIR_CLASS_INIT(&tag[0], "ref-rep");
d1547 1
a1547 1
		PAIR_CLASS_INIT(&tag[0], "ref-title");
d1550 1
a1550 1
		PAIR_CLASS_INIT(&tag[0], "link-ref");
d1553 1
a1553 1
		PAIR_CLASS_INIT(&tag[0], "ref-vol");
d1560 1
a1560 1
		print_otag(h, t, 1, tag);
d1564 1
a1564 2
	PAIR_HREF_INIT(&tag[1], n->child->string);
	print_otag(h, TAG_A, 2, tag);
a1617 2
	struct htmlpair	tag;

d1639 1
a1639 2
		PAIR_CLASS_INIT(&tag, "opt");
		print_otag(h, TAG_SPAN, 1, &tag);
d1660 1
a1660 2
		PAIR_CLASS_INIT(&tag, "lit");
		print_otag(h, TAG_CODE, 1, &tag);
@


1.121
log
@Use new NODE_NOSRC and NODE_NOPRT flags for .Bx and .At.
More rigorous AST and 40 lines less code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.120 2017/01/10 21:54:34 schwarze Exp $ */
a70 1
static	int		  mdoc_bt_pre(MDOC_ARGS);
a105 1
static	int		  mdoc_rv_pre(MDOC_ARGS);
a112 1
static	int		  mdoc_ud_pre(MDOC_ARGS);
d155 1
a155 1
	{mdoc_rv_pre, NULL}, /* Rv */
d221 1
a221 1
	{mdoc_bt_pre, NULL}, /* Bt */
d224 1
a224 1
	{mdoc_ud_pre, NULL}, /* Ud */
a918 4
	struct htmlpair	  tag;
	struct tag	 *t;
	struct roff_node *nch;

d921 1
a921 31

	PAIR_CLASS_INIT(&tag, "utility");

	print_text(h, "The");

	for (nch = n->child; nch != NULL; nch = nch->next) {
		assert(nch->type == ROFFT_TEXT);

		t = print_otag(h, TAG_B, 1, &tag);
		print_text(h, nch->string);
		print_tagq(h, t);

		if (nch->next == NULL)
			continue;

		if (nch->prev != NULL || nch->next->next != NULL) {
			h->flags |= HTML_NOSPACE;
			print_text(h, ",");
		}

		if (nch->next->next == NULL)
			print_text(h, "and");
	}

	if (n->child != NULL && n->child->next != NULL)
		print_text(h, "utilities exit\\~0");
	else
		print_text(h, "utility exits\\~0");

	print_text(h, "on success, and\\~>0 if an error occurs.");
	return 0;
a1598 55
mdoc_rv_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;
	struct tag	*t;
	struct roff_node *nch;

	if (n->prev)
		print_otag(h, TAG_BR, 0, NULL);

	PAIR_CLASS_INIT(&tag, "fname");

	if (n->child != NULL) {
		print_text(h, "The");

		for (nch = n->child; nch != NULL; nch = nch->next) {
			t = print_otag(h, TAG_B, 1, &tag);
			print_text(h, nch->string);
			print_tagq(h, t);

			h->flags |= HTML_NOSPACE;
			print_text(h, "()");

			if (nch->next == NULL)
				continue;

			if (nch->prev != NULL || nch->next->next != NULL) {
				h->flags |= HTML_NOSPACE;
				print_text(h, ",");
			}
			if (nch->next->next == NULL)
				print_text(h, "and");
		}

		if (n->child != NULL && n->child->next != NULL)
			print_text(h, "functions return");
		else
			print_text(h, "function returns");

		print_text(h, "the value\\~0 if successful;");
	} else
		print_text(h, "Upon successful completion,"
                    " the value\\~0 is returned;");

	print_text(h, "otherwise the value\\~\\-1 is returned"
	   " and the global variable");

	PAIR_CLASS_INIT(&tag, "var");
	t = print_otag(h, TAG_B, 1, &tag);
	print_text(h, "errno");
	print_tagq(h, t);
	print_text(h, "is set to indicate the error.");
	return 0;
}

static int
a1721 16
}

static int
mdoc_bt_pre(MDOC_ARGS)
{

	print_text(h, "is currently in beta test.");
	return 0;
}

static int
mdoc_ud_pre(MDOC_ARGS)
{

	print_text(h, "currently under development.");
	return 0;
@


1.120
log
@For the .Ux/.Ox family of macros, do text production at the validation
stage rather than in each and every individual formatter, using the
new NODE_NOSRC flag.  More rigorous and also ten lines less code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.119 2017/01/10 13:46:53 schwarze Exp $ */
a71 1
static	int		  mdoc_bx_pre(MDOC_ARGS);
d183 1
a183 1
	{mdoc_bx_pre, NULL}, /* Bx */
a736 27
}

static int
mdoc_bx_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	PAIR_CLASS_INIT(&tag, "unix");
	print_otag(h, TAG_SPAN, 1, &tag);

	if (NULL != (n = n->child)) {
		print_text(h, n->string);
		h->flags |= HTML_NOSPACE;
		print_text(h, "BSD");
	} else {
		print_text(h, "BSD");
		return 0;
	}

	if (NULL != (n = n->next)) {
		h->flags |= HTML_NOSPACE;
		print_text(h, "-");
		h->flags |= HTML_NOSPACE;
		print_text(h, n->string);
	}

	return 0;
@


1.119
log
@unify names of AST node flags; no change of cpp output
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.118 2017/01/10 12:54:27 schwarze Exp $ */
a732 1
	const char	*pp;
a733 24
	int		 flags;

	switch (n->tok) {
	case MDOC_Bsx:
		pp = "BSD/OS";
		break;
	case MDOC_Dx:
		pp = "DragonFly";
		break;
	case MDOC_Fx:
		pp = "FreeBSD";
		break;
	case MDOC_Nx:
		pp = "NetBSD";
		break;
	case MDOC_Ox:
		pp = "OpenBSD";
		break;
	case MDOC_Ux:
		pp = "UNIX";
		break;
	default:
		return 1;
	}
d737 1
a737 9

	print_text(h, pp);
	if (n->child) {
		flags = h->flags;
		h->flags |= HTML_KEEP;
		print_text(h, n->child->string);
		h->flags = flags;
	}
	return 0;
@


1.118
log
@Introduce flags NODE_NOSRC and NODE_NOPRT for AST nodes.
Use them to mark generated nodes and nodes that shall not produce output.
Let -Ttree output mode display these new flags.
Use NODE_NOSRC for .Ar, .Mt, and .Pa default arguments.
Use NODE_NOPRT for .Dd, .Dt, and .Os.

These will help to make handling of text production macros more rigorous.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.117 2017/01/09 12:48:52 schwarze Exp $ */
d287 1
a287 1
	if (NULL == n->prev || ! (MDOC_SYNPRETTY & n->flags))
d383 1
a383 1
	n->flags &= ~MDOC_ENDED;
d394 1
a394 1
		if (' ' == *n->string && MDOC_LINE & n->flags)
d397 1
a397 1
		if (MDOC_DELIMC & n->flags)
d400 1
a400 1
		if (MDOC_DELIMO & n->flags)
d404 1
a404 1
		if (n->flags & MDOC_LINE)
d432 1
a432 1
	if (h->flags & HTML_KEEP && n->flags & MDOC_LINE) {
d446 1
a446 1
		if ( ! mdocs[n->tok].post || n->flags & MDOC_ENDED)
d450 1
a450 1
			n->body->flags |= MDOC_ENDED;
d609 1
a609 1
	     n->next->flags & MDOC_LINE)))
d715 1
a715 1
	if ( ! (MDOC_LINE & n->flags))
d1162 1
a1162 1
		    (nn->next && ! (nn->next->flags & MDOC_LINE)))
d1401 1
a1401 1
	pretty = MDOC_SYNPRETTY & n->flags;
d1431 1
a1431 1
	if (MDOC_SYNPRETTY & n->flags) {
d1460 1
a1460 1
		if (MDOC_SYNPRETTY & n->flags)
d1650 1
a1650 1
	if (MDOC_SYNPRETTY & n->flags && MDOC_LINE & n->flags)
d1827 1
a1827 1
	if ( ! (n->next == NULL || n->next->flags & MDOC_LINE))
d1898 1
a1898 1
	if (SEC_LIBRARY == n->sec && MDOC_LINE & n->flags && n->prev)
@


1.117
log
@The .No macro is not supposed to produce fixed-width font, it is not
the same as .Li, so don't use <code>.
Bug reported by <Anton dot Lindqvist at gmail dot com> on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.116 2017/01/08 22:51:53 schwarze Exp $ */
d377 3
@


1.116
log
@Indentation must be measured in units of the surrounding text,
not in units of the contained text.  Consequently, "display"
and "lit" class tags must not be on the same element:  First,
"display" must set up the indentation, still using the outer
units, and only after that, "lit" may change the font.

This fixes .Bd -literal which got the wrong indentation.
Bug reported by tb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.115 2016/01/08 17:48:04 schwarze Exp $ */
d1850 1
a1850 1
	print_otag(h, TAG_CODE, 1, &tag);
@


1.115
log
@Delete the redundant "nchild" member of struct roff_node, replacing
most uses by one, a few by two pointer checks, and only one by a
tiny loop - not only making data smaller, but code shorter as well.

This gets rid of an implicit invariant that confused both static
analysis tools and human auditors.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.114 2015/12/25 20:43:04 bentley Exp $ */
d4 1
a4 1
 * Copyright (c) 2014, 2015, 2016 Ingo Schwarze <schwarze@@openbsd.org>
d1122 5
a1126 4
	if (DISP_unfilled != n->norm->Bd.type &&
	    DISP_literal != n->norm->Bd.type) {
		PAIR_CLASS_INIT(&tag[1], "display");
		print_otag(h, TAG_DIV, 2, tag);
a1127 1
	}
d1129 2
a1130 2
	PAIR_CLASS_INIT(&tag[1], "lit display");
	print_otag(h, TAG_PRE, 2, tag);
@


1.114
log
@Generate simpler in-page links: just replace spaces with underscores.

So
http://example.com/OpenBSD-current/man1/ls.1#x546865204c6f6e6720466f726d6174
becomes
http://example.com/OpenBSD-current/man1/ls.1#The_Long_Format

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.113 2015/10/12 00:07:27 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
d603 1
a603 1
	if ( ! (n->nchild == 0 &&
d980 3
a982 3
	struct tag	*t;
	struct htmlpair	 tag;
	int		 nchild;
d991 2
a992 3
	nchild = n->nchild;
	for (n = n->child; n; n = n->next) {
		assert(n->type == ROFFT_TEXT);
d995 1
a995 1
		print_text(h, n->string);
d998 4
a1001 1
		if (nchild > 2 && n->next) {
d1006 1
a1006 1
		if (n->next && NULL == n->next->next)
d1010 1
a1010 1
	if (nchild > 1)
d1698 1
a1698 1
	int		 nchild;
d1705 1
a1705 2
	nchild = n->nchild;
	if (nchild > 0) {
d1708 1
a1708 1
		for (n = n->child; n; n = n->next) {
d1710 1
a1710 1
			print_text(h, n->string);
d1716 1
a1716 1
			if (n->next == NULL)
d1719 1
a1719 1
			if (nchild > 2) {
d1723 1
a1723 1
			if (n->next->next == NULL)
d1727 1
a1727 1
		if (nchild > 1)
d2003 1
a2003 1
		if (n->parent->args || 0 == n->prev->nchild)
d2032 1
a2032 1
		print_text(h, n->nchild == 1 &&
d2096 1
a2096 1
		print_text(h, n->nchild == 1 &&
@


1.113
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.112 2015/10/06 18:30:44 schwarze Exp $ */
a542 1
	bufcat(h, "x");
a571 1
	bufcat(h, "x");
d1062 1
a1062 1
	bufcat(h, "#x");
@


1.112
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.111 2015/09/26 00:53:15 schwarze Exp $ */
a299 1
		/* FALLTHROUGH */
a300 1
		/* FALLTHROUGH */
a301 1
		/* FALLTHROUGH */
a302 1
		/* FALLTHROUGH */
a822 1
			/* FALLTHROUGH */
a823 1
			/* FALLTHROUGH */
a824 1
			/* FALLTHROUGH */
a825 1
			/* FALLTHROUGH */
a828 1
			/* FALLTHROUGH */
a829 1
			/* FALLTHROUGH */
a830 1
			/* FALLTHROUGH */
a831 1
			/* FALLTHROUGH */
a849 1
			/* FALLTHROUGH */
a850 1
			/* FALLTHROUGH */
a851 1
			/* FALLTHROUGH */
a852 1
			/* FALLTHROUGH */
a859 1
			/* FALLTHROUGH */
a860 1
			/* FALLTHROUGH */
a861 1
			/* FALLTHROUGH */
a862 1
			/* FALLTHROUGH */
a953 1
		/* FALLTHROUGH */
a954 1
		/* FALLTHROUGH */
a955 1
		/* FALLTHROUGH */
a962 1
		/* FALLTHROUGH */
a963 1
		/* FALLTHROUGH */
a964 1
		/* FALLTHROUGH */
a965 1
		/* FALLTHROUGH */
a1146 1
			/* FALLTHROUGH */
a1147 1
			/* FALLTHROUGH */
a1148 1
			/* FALLTHROUGH */
a1149 1
			/* FALLTHROUGH */
a1150 1
			/* FALLTHROUGH */
a1151 1
			/* FALLTHROUGH */
a1152 1
			/* FALLTHROUGH */
a2031 1
		/* FALLTHROUGH */
a2036 1
		/* FALLTHROUGH */
a2040 1
		/* FALLTHROUGH */
a2044 1
		/* FALLTHROUGH */
a2057 1
		/* FALLTHROUGH */
a2058 1
		/* FALLTHROUGH */
a2059 1
		/* FALLTHROUGH */
a2063 1
		/* FALLTHROUGH */
a2073 1
		/* FALLTHROUGH */
a2095 1
		/* FALLTHROUGH */
a2100 1
		/* FALLTHROUGH */
a2104 1
		/* FALLTHROUGH */
a2105 1
		/* FALLTHROUGH */
a2106 1
		/* FALLTHROUGH */
a2118 1
		/* FALLTHROUGH */
a2119 1
		/* FALLTHROUGH */
a2120 1
		/* FALLTHROUGH */
a2124 1
		/* FALLTHROUGH */
a2128 1
		/* FALLTHROUGH */
a2129 1
		/* FALLTHROUGH */
@


1.111
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.110 2015/09/26 00:32:17 schwarze Exp $ */
d525 1
a525 1
	return(1);
d537 1
a537 1
		return(1);
d541 1
a541 1
		return(1);
d561 1
a561 1
	return(1);
d572 1
a572 1
		return(1);
d574 1
a574 1
		return(1);
d591 1
a591 1
	return(1);
d605 1
a605 1
		return(1);
d615 1
a615 1
	return(1);
d624 1
a624 1
		return(1);
d631 1
a631 1
	return(1);
d650 1
a650 1
		return(1);
d653 1
a653 1
		return(1);
d677 1
a677 1
	return(1);
d686 1
a686 1
		return(0);
d703 1
a703 1
		return(0);
d711 1
a711 1
	return(0);
d720 1
a720 1
	return(1);
d730 1
a730 1
	return(1);
d760 1
a760 1
		return(1);
d773 1
a773 1
	return(0);
d790 1
a790 1
		return(0);
d800 1
a800 1
	return(0);
d835 1
a835 1
			return(0);
d912 1
a912 1
	return(1);
d926 1
a926 1
		return(1);
d931 1
a931 1
			return(0);
d951 1
a951 1
		return(0);
d1003 1
a1003 1
	return(1);
d1043 1
a1043 1
	return(0);
d1053 1
a1053 1
	return(1);
d1063 1
a1063 1
		return(1);
d1082 1
a1082 1
	return(1);
d1104 1
a1104 1
	return(1);
d1116 1
a1116 1
		return(0);
d1130 1
a1130 1
		return(1);
d1153 1
a1153 1
		return(1);
d1204 1
a1204 1
	return(0);
d1214 1
a1214 1
	return(1);
d1224 1
a1224 1
	return(1);
d1235 1
a1235 1
		return(0);
d1240 1
a1240 1
		return(0);
d1251 1
a1251 1
	return(1);
d1262 1
a1262 1
	return(1);
d1272 1
a1272 1
	return(1);
d1282 1
a1282 1
	return(1);
d1292 1
a1292 1
	return(1);
d1305 1
a1305 1
		return(1);
d1323 1
a1323 1
	return(0);
d1338 1
a1338 1
		return(0);
d1345 1
a1345 1
		return(1);
d1391 1
a1391 1
	return(0);
d1401 1
a1401 1
		return(1);
d1405 1
a1405 1
		return(0);
d1409 1
a1409 1
	return(1);
d1420 1
a1420 1
	return(1);
d1510 1
a1510 1
	return(0);
d1527 1
a1527 1
	return(0);
d1534 1
a1534 1
	return(0);
d1542 1
a1542 1
	return(0);
d1571 1
a1571 1
	return(0);
d1581 1
a1581 1
		return(0);
d1596 1
a1596 1
	return(0);
d1620 1
a1620 1
	return(0);
d1633 1
a1633 1
		return(1);
d1636 1
a1636 1
		return(1);
d1640 1
a1640 1
		return(0);
d1647 1
a1647 1
	return(0);
d1714 1
a1714 1
	return(0);
d1724 1
a1724 1
	return(1);
d1780 1
a1780 1
	return(0);
d1790 1
a1790 1
	return(1);
d1800 1
a1800 1
	return(1);
d1810 1
a1810 1
		return(0);
d1812 1
a1812 1
		return(1);
d1834 1
a1834 1
	return(1);
d1844 1
a1844 1
	return(1);
d1852 1
a1852 1
	return(1);
d1869 1
a1869 1
		return(1);
d1876 1
a1876 1
	return(1);
d1886 1
a1886 1
	return(1);
d1896 1
a1896 1
	return(1);
d1906 1
a1906 1
	return(1);
d1914 1
a1914 1
	return(0);
d1922 1
a1922 1
	return(0);
d1935 1
a1935 1
	return(1);
d2001 1
a2001 1
		return(1);
d2007 1
a2007 1
	return(1);
d2036 1
a2036 1
		return(0);
d2045 1
a2045 1
	return(1);
d2062 1
a2062 1
		return(1);
d2092 1
a2092 1
			return(1);
d2125 1
a2125 1
	return(1);
d2197 1
a2197 1
		return(1);
d2208 1
a2208 1
	return(1);
@


1.110
log
@resolve code duplication and do style cleanup in mdoc_nm_pre(),
no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.109 2015/09/26 00:18:04 schwarze Exp $ */
a1000 1
		/* NOTREACHED */
a1996 1
		/* NOTREACHED */
a2042 1
		/* NOTREACHED */
a2121 1
		/* NOTREACHED */
a2188 1
		/* NOTREACHED */
@


1.109
log
@Fix multiple aspects of SYNOPSIS .Nm formatting:
* Don't break lines before non-block .Nm elements.
* Use proper <b> markup for the heads of .Nm blocks.
* Make the width measurements work by doing them on the head children.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.108 2015/08/30 18:59:44 schwarze Exp $ */
a641 6
	case ROFFT_ELEM:
		PAIR_CLASS_INIT(&tag, "name");
		print_otag(h, TAG_B, 1, &tag);
		if (NULL == n->child && meta->name)
			print_text(h, meta->name);
		return(1);
d644 2
d648 1
a648 1
		if (NULL == n->child && meta->name)
d666 1
a666 1
	if (0 == len && meta->name)
@


1.108
log
@If an .Fo macro lacks its mandatory argument, don't die on an assertion.
Bug found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.107 2015/04/18 17:50:02 schwarze Exp $ */
a642 1
		synopsis_pre(h, n);
d650 2
d666 1
a666 1
	for (len = 0, n = n->child; n; n = n->next)
@


1.107
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.106 2015/04/18 16:04:40 schwarze Exp $ */
d1643 2
a1644 1
	/* XXX: we drop non-initial arguments as per groff. */
a1645 1
	assert(n->child);
a1646 1

@


1.106
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.105 2015/04/16 20:21:08 schwarze Exp $ */
a48 1
static	void		  print_mdoc(MDOC_ARGS);
a263 9
void
html_mdoc(void *arg, const struct roff_man *mdoc)
{

	print_mdoc(mdoc_meta(mdoc), mdoc_node(mdoc)->child,
	    (struct html *)arg);
	putchar('\n');
}

d322 2
a323 2
static void
print_mdoc(MDOC_ARGS)
d325 2
a327 1
	struct htmlpair	 tag;
d330 1
d336 1
a336 1
		print_mdoc_head(meta, n, h);
d343 3
a345 3
	mdoc_root_pre(meta, n, h);
	print_mdoc_nodelist(meta, n, h);
	mdoc_root_post(meta, n, h);
d347 1
@


1.105
log
@Restore the page headers and page footers that accidentally got lost
in rev. 1.225.  Regression reported by florian@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.104 2015/04/02 23:47:43 schwarze Exp $ */
d266 1
a266 1
html_mdoc(void *arg, const struct mdoc *mdoc)
@


1.104
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.103 2015/04/02 22:06:17 schwarze Exp $ */
d351 1
d353 1
a393 3
	case ROFFT_ROOT:
		child = mdoc_root_pre(meta, n, h);
		break;
a450 3
	case ROFFT_ROOT:
		mdoc_root_post(meta, n, h);
		break;
@


1.103
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.102 2015/04/02 21:03:18 schwarze Exp $ */
d36 1
a36 1
#define	MDOC_ARGS	  const struct mdoc_meta *meta, \
@


1.102
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.101 2015/03/03 21:09:25 schwarze Exp $ */
d37 1
a37 1
			  struct mdoc_node *n, \
d54 1
a54 1
				const struct mdoc_node *);
d294 1
a294 1
synopsis_pre(struct html *h, const struct mdoc_node *n)
d823 1
a823 1
	const struct mdoc_node *bl;
d1127 1
a1127 1
	struct mdoc_node	*nn;
d1313 1
a1313 1
	const struct mdoc_node	*nn;
@


1.101
log
@If an eqn(7) starts on a new input line, be sure to output whitespace
in front of it.  Issue found by tedu@@ in glOrtho(3).

There are also cases of excessive whitespace before and after
equations.  This patch neither fixes them nor makes them worse.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.100 2015/02/12 12:20:47 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d28 1
d392 1
a392 1
	case MDOC_ROOT:
d395 1
a395 1
	case MDOC_TEXT:
d412 1
a412 1
	case MDOC_EQN:
d417 1
a417 1
	case MDOC_TBL:
d452 1
a452 1
	case MDOC_ROOT:
d455 1
a455 1
	case MDOC_EQN:
d545 1
a545 1
	case MDOC_BLOCK:
d549 1
a549 1
	case MDOC_BODY:
d560 1
a560 1
	for (n = n->child; n && MDOC_TEXT == n->type; ) {
d580 1
a580 1
	if (MDOC_BLOCK == n->type) {
d584 1
a584 1
	} else if (MDOC_BODY == n->type)
d590 1
a590 1
	for (n = n->child; n && MDOC_TEXT == n->type; ) {
d622 1
a622 1
	     n->next->type == MDOC_TEXT ||
d634 1
a634 1
	if (MDOC_BODY != n->type)
d653 1
a653 1
	case MDOC_ELEM:
d660 1
a660 1
	case MDOC_HEAD:
d665 1
a665 1
	case MDOC_BODY:
d677 1
a677 1
		if (MDOC_TEXT == n->type)
d838 1
a838 1
	if (MDOC_HEAD == n->type) {
d873 1
a873 1
	} else if (MDOC_BODY == n->type) {
d937 1
a937 1
	if (MDOC_BODY == n->type) {
d943 1
a943 1
	if (MDOC_HEAD == n->type) {
d1037 1
a1037 1
		assert(MDOC_TEXT == n->type);
d1077 1
a1077 1
	if (MDOC_BLOCK != n->type)
d1130 1
a1130 1
	if (MDOC_HEAD == n->type)
d1133 1
a1133 1
	if (MDOC_BLOCK == n->type) {
d1136 1
a1136 1
			if (MDOC_BLOCK != nn->type)
d1355 1
a1355 1
	assert(MDOC_TEXT == n->type);
d1368 1
a1368 1
		assert(MDOC_TEXT == n->type);
d1402 1
a1402 1
		assert(MDOC_TEXT == n->type);
d1414 1
a1414 1
	if (MDOC_BLOCK == n->type) {
d1417 1
a1417 1
	} else if (MDOC_ELEM == n->type) {
d1419 1
a1419 1
	} else if (MDOC_HEAD == n->type)
d1598 1
a1598 1
	assert(MDOC_TEXT == n->type);
d1623 1
a1623 1
		assert(MDOC_TEXT == n->type);
d1644 1
a1644 1
	if (MDOC_BODY == n->type) {
d1649 1
a1649 1
	} else if (MDOC_BLOCK == n->type) {
d1670 1
a1670 1
	if (MDOC_BODY != n->type)
d1704 1
a1704 1
		assert(MDOC_TEXT == n->type);
d1726 1
a1726 1
		assert(MDOC_TEXT == n->type);
d1825 1
a1825 1
	if (MDOC_HEAD == n->type)
d1827 1
a1827 1
	else if (MDOC_BODY != n->type)
d1884 1
a1884 1
	if (MDOC_BLOCK != n->type)
d2050 1
a2050 1
	case MDOC_BLOCK:
d2052 1
a2052 1
	case MDOC_HEAD:
d2054 1
a2054 1
	case MDOC_BODY:
d2070 1
a2070 1
	if (MDOC_BODY == n->type)
d2079 1
a2079 1
	if (MDOC_BODY != n->type)
d2151 1
a2151 1
	if (n->type != MDOC_BODY && n->type != MDOC_ELEM)
d2216 1
a2216 1
	if (n->type != MDOC_BODY)
d2236 1
a2236 1
	if (n->type != MDOC_BODY)
@


1.100
log
@Delete the mdoc_node.pending pointer and the function calculating
it, make_pending(), which was the most difficult function of the
whole mdoc(7) parser.  After almost five years of maintaining this
hellhole, i just noticed the pointer isn't needed after all.

Blocks are always rewound in the reverse order they were opened;
that even holds for broken blocks.  Consequently, it is sufficient
to just mark broken blogs with the flag MDOC_BROKEN and breaking
blocks with the flag MDOC_ENDED.  When rewinding, instead of iterating
the pending pointers, just iterate from each broken block to its
parents, rewinding all that are MDOC_ENDED and stopping after
processing the first ancestor that it not MDOC_BROKEN.  For ENDBODY
markers, use the mdoc_node.body pointer in place of the former
mdoc_node.pending.

This also fixes an assertion failure found by jsg@@ with afl,
test case #467 (Bo Bl It Bd Bc It), where (surprise surprise)
the pending pointer got corrupted.

Improved functionality, minus one function, minus one struct field,
minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.99 2015/02/11 14:14:53 schwarze Exp $ */
d412 2
@


1.99
log
@do not access a NULL pointer if an .Eo block lacks a tail;
found by jsg@@ with afl, test case #16
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.98 2015/02/05 01:46:38 schwarze Exp $ */
d36 1
a36 1
			  const struct mdoc_node *n, \
d268 1
a268 1
	print_mdoc(mdoc_meta(mdoc), mdoc_node(mdoc),
d388 1
d459 1
a459 1
			n->pending->flags |= MDOC_ENDED;
d1124 1
a1124 1
	const struct mdoc_node	*nn;
@


1.98
log
@fix handling of empty .An macros
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.97 2015/02/05 00:13:34 schwarze Exp $ */
d2221 2
a2222 3
	    n->parent->head->child != NULL &&
	    (n->parent->body->child != NULL ||
	     n->parent->tail->child != NULL))
@


1.97
log
@Simplify by deleting the "lastline" member of struct mdoc_node.
Minus one struct member, minus 17 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.96 2015/02/01 23:10:15 schwarze Exp $ */
a1252 3

	if (n->child == NULL)
		return(0);
@


1.96
log
@fix .Eo/.Ec spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.95 2015/01/30 22:04:15 schwarze Exp $ */
d437 3
a439 6
	if (HTML_KEEP & h->flags) {
		if (n->prev ? (n->prev->lastline != n->line) :
		    (n->parent && n->parent->line != n->line)) {
			h->flags &= ~HTML_KEEP;
			h->flags |= HTML_PREKEEP;
		}
@


1.95
log
@Have pity on the poor stack.
Replace tail recursion by iteration when walking the syntax trees.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.94 2015/01/23 14:19:52 schwarze Exp $ */
d82 2
d192 1
a192 1
	{mdoc_quote_pre, mdoc_quote_post}, /* Eo */
a2114 2
	case MDOC_Eo:
		break;
d2156 1
a2156 3
	if ( ! (n->tok == MDOC_En ||
	    (n->tok == MDOC_Eo && n->end == ENDBODY_SPACE)))
		h->flags |= HTML_NOSPACE;
d2180 5
a2184 4
		if (NULL != n->norm->Es &&
		    NULL != n->norm->Es->child &&
		    NULL != n->norm->Es->child->next) {
			h->flags |= HTML_NOSPACE;
a2185 3
		}
		break;
	case MDOC_Eo:
d2212 42
@


1.94
log
@Let .Aq/.Ao/.Ac print "<>" instead of the normal "\(la\(ra"
when the only child is .Mt, not when the preceding node is .An,
to improve robustness.  Triggered by a question from Svyatoslav
Mishyn <juef at openmailbox dot org> (Crux Linux).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.93 2014/12/23 13:48:15 schwarze Exp $ */
d372 4
a375 3
	print_mdoc_node(meta, n, h);
	if (n->next)
		print_mdoc_nodelist(meta, n->next, h);
@


1.93
log
@support negative horizontal widths in man(7);
minus twenty lines of code in spite of enhanced functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.92 2014/12/23 09:31:17 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014 Ingo Schwarze <schwarze@@openbsd.org>
d2085 2
a2086 2
		print_text(h, n->parent->prev != NULL &&
		    n->parent->prev->tok == MDOC_An ?  "<" : "\\(la");
d2163 2
a2164 2
		print_text(h, n->parent->prev != NULL &&
		    n->parent->prev->tok == MDOC_An ?  ">" : "\\(ra");
@


1.92
log
@some scaling unit fixes:
- .sp with an invalid argument is .sp 1v, not .sp 0v
- in man(1), trailing garbage doesn't make scaling units invalid
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.91 2014/12/02 10:07:17 schwarze Exp $ */
d283 2
a284 1
	}
d1568 1
a1568 1
		if (NULL != (n = n->child))
d1571 3
@


1.91
log
@Fix the implementation and documentation of \c (continue text input line).
In particular, make it work in no-fill mode, too.
Reminded by Carsten dot Kunze at arcor dot de (Heirloom roff).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.90 2014/12/01 08:05:02 schwarze Exp $ */
d280 1
a280 1
	if ( ! a2roffsu(p, su, SCALE_MAX)) {
d1569 1
a1569 1
				SCALE_VS_INIT(&su, atoi(n->string));
@


1.90
log
@header cleanup:
* add missing forward declarations
* remove needless header inclusions
* some style unification
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.89 2014/11/30 05:28:00 schwarze Exp $ */
d1202 2
a1203 1
		if (nn->next && nn->next->line == nn->line)
@


1.89
log
@Multiple fixes with respect to .Pf:
* The first argument of .Pf is not parsed.
* Normal delimiter handling does not apply to the first argument of .Pf.
* Warn if nothing follows a prefix (inspired by groff_mdoc(7)).
* In that case, do not suppress spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.88 2014/11/27 22:27:40 schwarze Exp $ */
a26 1
#include "mandoc.h"
d28 1
a30 1
#include "mdoc.h"
@


1.88
log
@Multiple fixes with respect to .Eo:
1. Correctly parse stray .Ec without preceding .Eo,
avoiding an assertion violation found by jsg@@ with afl.
2. Correctly parse .Ec arguments when breaking another block.
3. Correct spacing around closing delimiter when breaking another block.
4. Sync some related formatting control from -Tascii to -Thtml.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.87 2014/11/27 16:20:27 schwarze Exp $ */
d1870 2
a1871 1
	h->flags |= HTML_NOSPACE;
@


1.87
log
@Fix the obsolete .Db (toggle debug mode) macro to ignore its arguments
and not trigger an assertion when there is more than one argument;
the latter found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.86 2014/11/19 21:59:19 schwarze Exp $ */
d424 1
a424 1
		if (h->tblt) {
d428 2
a429 3

		assert(NULL == h->tblt);
		if (mdocs[n->tok].pre && ENDBODY_NOT == n->end)
d454 7
a460 2
		if (mdocs[n->tok].post && ENDBODY_NOT == n->end)
			(*mdocs[n->tok].post)(meta, n, h);
d2147 1
a2147 1
	if (MDOC_BODY != n->type)
d2150 2
a2151 1
	if (MDOC_En != n->tok)
@


1.86
log
@Let .Ao and .Aq render as "<>" after .An and as "\(la\(ra" elsewhere,
just like groff; minibug noticed by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.85 2014/11/17 06:44:35 schwarze Exp $ */
d184 1
a184 1
	{NULL, NULL}, /* Db */
@


1.85
log
@Multiple fixes with respect to in-line macros:
* .No selects the default font; relevant e.g. in .Bf blocks
* no need to force empty .Li elements
* closing delimiters as leading macro arguments do not suppress space
* opening delimiters at the end of a macro line do not suppress space
* correctly handle delimiter spacing in -Tman
As a side effect, these fixes let mandoc warn about empty .No macros
as requested by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.84 2014/10/30 20:05:33 schwarze Exp $ */
d2076 2
a2077 1
		print_text(h, "\\(la");
d2153 2
a2154 1
		print_text(h, "\\(ra");
@


1.84
log
@Major bugsquashing with respect to -offset and -width:
1. Support specifying the .Bd and .Bl -offset as a macro default width;
while here, simplify the code handling the same for .Bl -width.
2. Correct handling of .Bl -offset arguments:  unlike .Bd -offset, the
arguments "left", "indent", and "indent-two" have no special meaning.
3. Fix the scaling of string length -offset and -width arguments in -Thtml.
Triggered by an incomplete documentation patch from bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.83 2014/10/07 18:17:05 schwarze Exp $ */
d99 1
d194 1
a194 1
	{mdoc_igndelim_pre, NULL}, /* No */
d1882 10
@


1.83
log
@Switch HTML output to polyglot HTML5; have only one single -Thml mode.
Replace hard-coded widths and alignments with a minimal embedded stylesheet.
Do not use <p> because it cannot appear inside block macros.
Remove the "summary" attribute because it is not HTML5.

Written by kristaps@@ some months ago, finished during EuroBSDCon.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_html.c,v 1.82 2014/09/17 19:53:35 schwarze Exp $ */
a56 1
static	void		  a2offs(const char *, struct roffsu *);
d281 1
a281 1
		su->unit = SCALE_BU;
a327 21
/*
 * Calculate the scaling unit passed in an `-offset' argument.  This
 * uses either a native scaling unit (e.g., 1i, 2m), one of a set of
 * predefined strings (indent, etc.), or the string length of the value.
 */
static void
a2offs(const char *p, struct roffsu *su)
{

	/* FIXME: "right"? */

	if (0 == strcmp(p, "left"))
		SCALE_HS_INIT(su, 0);
	else if (0 == strcmp(p, "indent"))
		SCALE_HS_INIT(su, INDENT);
	else if (0 == strcmp(p, "indent-two"))
		SCALE_HS_INIT(su, INDENT * 2);
	else if ( ! a2roffsu(p, su, SCALE_MAX))
		SCALE_HS_INIT(su, html_strlen(p));
}

d973 1
a973 1
		a2offs(n->norm->Bl.offs, &su);
d1139 11
a1149 3
	SCALE_HS_INIT(&su, 0);
	if (n->norm->Bd.offs)
		a2offs(n->norm->Bd.offs, &su);
@


1.82
log
@implement .An -[no]split for -Thtml
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
d315 1
a315 1
		print_otag(h, TAG_P, 0, NULL);
d319 1
a319 1
			print_otag(h, TAG_P, 0, NULL);
d485 1
a485 1
	struct htmlpair	 tag[3];
d488 2
a489 7
	PAIR_SUMMARY_INIT(&tag[0], "Document Footer");
	PAIR_CLASS_INIT(&tag[1], "foot");
	PAIR_INIT(&tag[2], ATTR_WIDTH, "100%");
	t = print_otag(h, TAG_TABLE, 3, tag);
	PAIR_INIT(&tag[0], ATTR_WIDTH, "50%");
	print_otag(h, TAG_COL, 1, tag);
	print_otag(h, TAG_COL, 1, tag);
d495 2
a496 2
	PAIR_CLASS_INIT(&tag[0], "foot-date");
	print_otag(h, TAG_TD, 1, tag);
d500 2
a501 3
	PAIR_CLASS_INIT(&tag[0], "foot-os");
	PAIR_INIT(&tag[1], ATTR_ALIGN, "right");
	print_otag(h, TAG_TD, 2, tag);
d509 1
a509 1
	struct htmlpair	 tag[3];
d525 2
a526 8
	PAIR_SUMMARY_INIT(&tag[0], "Document Header");
	PAIR_CLASS_INIT(&tag[1], "head");
	PAIR_INIT(&tag[2], ATTR_WIDTH, "100%");
	t = print_otag(h, TAG_TABLE, 3, tag);
	PAIR_INIT(&tag[0], ATTR_WIDTH, "30%");
	print_otag(h, TAG_COL, 1, tag);
	print_otag(h, TAG_COL, 1, tag);
	print_otag(h, TAG_COL, 1, tag);
d532 2
a533 2
	PAIR_CLASS_INIT(&tag[0], "head-ltitle");
	print_otag(h, TAG_TD, 1, tag);
d537 2
a538 3
	PAIR_CLASS_INIT(&tag[0], "head-vol");
	PAIR_INIT(&tag[1], ATTR_ALIGN, "center");
	print_otag(h, TAG_TD, 2, tag);
d542 2
a543 3
	PAIR_CLASS_INIT(&tag[0], "head-rtitle");
	PAIR_INIT(&tag[1], ATTR_ALIGN, "right");
	print_otag(h, TAG_TD, 2, tag);
d1157 1
a1157 1
			print_otag(h, TAG_P, 0, NULL);
d1563 1
a1563 1
	print_otag(h, TAG_P, 0, NULL);
d1891 1
a1891 1
		print_otag(h, TAG_P, 0, NULL);
@


1.81
log
@Right after .Fl, a middle delimiter triggers an empty scope,
just like a closing delimiter.  This didn't work in groff-1.15,
but it now works in groff-1.22.

After being closed by delimiters, .Nm scopes do not reopen.

Do not suppress white space after .Fl if the next node is a text node
on the same input line; that can happen for middle delimiters.

Fixing an issue reported by jmc@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.80 2014/08/14 00:29:12 schwarze Exp $ */
d571 2
a572 1
	if (MDOC_BLOCK == n->type) {
d576 3
a578 1
	} else if (MDOC_BODY == n->type)
d580 3
d1265 19
a1283 1
	/* TODO: -split and -nosplit (see termp_an_pre()). */
@


1.80
log
@Revert previous, as requested by kristaps@@.
The .Bf block can contain subblocks, so it has to render as an
element that can contain flow content.  But <em> cannot contain
flow content, only phrasing content.  Rendering .Em and .Bf differently
would by unfortunate, and closing out .Bf before subblocks and
re-opening it afterwards would merely complicate both the C code
of the program and the generated HTML code.  Besides, converting
.Em to semantic HTML markup would require some content to be put
into <em> and some into <i>, but we cannot automatically distinguish
which is which, so strictly speaking, we can't use semantic HTML
here but have to fall back to physical markup.  Wonders of HTML...
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.79 2014/08/13 15:19:24 schwarze Exp $ */
d641 4
a644 3
	if (n->child)
		h->flags |= HTML_NOSPACE;
	else if (n->next && n->next->line == n->line)
@


1.79
log
@Use <em> for .Em and .Bf -emphasis.

The vast majority of .Em in real-world manuals is stress emphasis,
for which <em> is the correct markup.  Admittedly, there are some
instances of .Em usage for alternate quality, for which <i> would
be a better match.  Most of these are technical terms that neither
allow semantic markup nor are keywords - for the latter, .Sy would
be preferable.  A typical example is that the shell breaks input into
.Em words .
Alternate voice or mood, which would also require <i>, is almost
absent from manuals.
We cannot satisfy both stress emphasis and alternate quality, so
pick the one that fits more often and looks less wrong when off.

Patch from Guy Harris <guy at alum dot mit dot edu>.
ok bentley@@ joerg@@NetBSD
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.78 2014/08/08 16:17:09 schwarze Exp $ */
d1084 1
d1086 2
a1087 1
	print_otag(h, TAG_EM, 0, NULL);
d1823 3
a1825 1
	if (FONT_Sy == n->norm->Bf.font)
a1842 2
	if (FONT_Em == n->norm->Bf.font)
		print_otag(h, TAG_EM, 0, NULL);
@


1.78
log
@Bring the handling of defective prologues even closer to groff,
in particular relaxing the distinction between prologue and body
and further improving messages.
* The last .Dd wins and the last .Os wins, even in the body.
* The last .Dt before the first body macro wins.
* Missing title in .Dt defaults to UNTITLED.  Warn about it.
* Missing section in .Dt does not default to 1.  But warn about it.
* Do not warn multiple times about the same mdoc(7) prologue macro.
* Warn about missing .Os.
* Incomplete .TH defaults to empty strings.  Warn about it.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.77 2014/08/08 16:00:23 schwarze Exp $ */
a1083 1
	struct htmlpair	tag;
d1085 1
a1085 2
	PAIR_CLASS_INIT(&tag, "emph");
	print_otag(h, TAG_SPAN, 1, &tag);
d1821 1
a1821 3
	if (FONT_Em == n->norm->Bf.font)
		PAIR_CLASS_INIT(&tag[0], "emph");
	else if (FONT_Sy == n->norm->Bf.font)
d1839 2
@


1.77
log
@Clarity with respect to floating point handling:
Write double constants as double rather than integer literals.
Remove useless explicit (double) cast done at one place and nowhere else.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.76 2014/08/08 15:10:14 schwarze Exp $ */
d379 3
a381 2
	bufcat_fmt(h, "%s(%s)", meta->title, meta->msec);

d525 5
a529 1
	mandoc_asprintf(&title, "%s(%s)", meta->title, meta->msec);
@


1.76
log
@Various improvements related to .Ex and .Rv:
* let .Nm fall back to the empty string, not to UNKNOWN
* never let .Rv copy an argument from .Nm
* avoid spurious \fR after empty .Nm in -Tman
* correct handling of .Ex and .Rv in -Tman
* correct the wording of the output for .Rv without arguments
* use non-breaking spaces in .Ex and .Rv output where required
* split MANDOCERR_NONAME into a warning for .Ex and an error for .Nm
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.75 2014/07/02 19:54:39 schwarze Exp $ */
d698 1
a698 1
	SCALE_HS_INIT(&su, (double)len);
d1564 1
a1564 1
		su.scale = 0;
@


1.75
log
@When .Sm is called without an argument, groff toggles the spacing mode,
so let us do the same for compatibility.  Using this feature is of
course not recommended except in manual page obfuscation contests.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.74 2014/07/02 03:47:07 schwarze Exp $ */
d1068 1
a1068 1
		print_text(h, "utilities exit");
d1070 1
a1070 1
		print_text(h, "utility exits");
d1072 1
a1072 1
	print_text(h, "0 on success, and >0 if an error occurs.");
d1743 3
a1745 1
	print_text(h, "The");
d1747 4
a1750 3
	nchild = n->nchild;
	for (n = n->child; n; n = n->next) {
		assert(MDOC_TEXT == n->type);
d1752 2
a1753 3
		t = print_otag(h, TAG_B, 1, &tag);
		print_text(h, n->string);
		print_tagq(h, t);
d1755 2
a1756 2
		h->flags |= HTML_NOSPACE;
		print_text(h, "()");
d1758 6
a1763 3
		if (nchild > 2 && n->next) {
			h->flags |= HTML_NOSPACE;
			print_text(h, ",");
d1766 4
a1769 3
		if (n->next && NULL == n->next->next)
			print_text(h, "and");
	}
d1771 4
a1774 4
	if (nchild > 1)
		print_text(h, "functions return");
	else
		print_text(h, "function returns");
d1776 2
a1777 2
	print_text(h, "the value 0 if successful; otherwise the "
	    "value -1 is returned and the global variable");
@


1.74
log
@Implement the obsolete macros .En .Es .Fr .Ot for backward compatibility,
since this is hardly more complicated than explicitly ignoring them
as we did in the past.  Of course, do not use them!
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.73 2014/04/23 16:07:06 schwarze Exp $ */
d1523 3
a1525 13
	assert(n->child && MDOC_TEXT == n->child->type);
	if (0 == strcmp("on", n->child->string)) {
		/*
		 * FIXME: no p->col to check.  Thus, if we have
		 *  .Bd -literal
		 *  .Sm off
		 *  1 2
		 *  .Sm on
		 *  3
		 *  .Ed
		 * the "3" is preceded by a space.
		 */
		h->flags &= ~HTML_NOSPACE;
d1527 1
a1527 1
	} else
d1529 3
@


1.73
log
@Audit strlcpy(3)/strlcat(3) usage.

* Repair three instances of silent truncation, use asprintf(3).
* Change two instances of strlen(3)+malloc(3)+strlcpy(3)+strlcat(3)+...
to use asprintf(3) instead to make them less error prone.
* Cast the return value of four instances where the destination
buffer is known to be large enough to (void).
* Completely remove three useless instances of strlcpy(3)/strlcat(3).
* Mark two places in -Thtml with XXX that can cause information loss
and crashes but are not easy to fix, requiring design changes of
some internal interfaces.
* The file mandocdb.c remains to be audited.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.72 2014/04/20 20:17:36 schwarze Exp $ */
a95 1
static	int		  mdoc_ll_pre(MDOC_ARGS);
d109 1
d156 1
a156 1
	{NULL, NULL}, /* Ot */
d226 1
a226 1
	{NULL, NULL}, /* Fr */
d236 2
a237 2
	{NULL, NULL}, /* Es */  /* TODO */
	{NULL, NULL}, /* En */  /* TODO */
d244 1
a244 1
	{mdoc_ll_pre, NULL}, /* ll */
d1544 1
a1544 1
mdoc_ll_pre(MDOC_ARGS)
d2084 6
d2133 2
a2134 1
	h->flags |= HTML_NOSPACE;
d2155 8
@


1.72
log
@fix unchecked snprintf(3) in page header printing:
the length of the title is unknown, and speed doesn't matter here,
so use asprintf/free rather than a static buffer
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.71 2014/04/20 16:44:44 schwarze Exp $ */
a513 1
	char		 b[BUFSIZ];
d516 1
a516 1
	char		*title;
d518 5
a522 7
	strlcpy(b, meta->vol, BUFSIZ);

	if (meta->arch) {
		strlcat(b, " (", BUFSIZ);
		strlcat(b, meta->arch, BUFSIZ);
		strlcat(b, ")", BUFSIZ);
	}
d547 1
a547 1
	print_text(h, b);
d557 1
d990 2
a991 2
	strlcpy(buf, "list ", BUFSIZ);
	strlcat(buf, lists[n->norm->Bl.type], BUFSIZ);
d1360 9
d1481 2
a1482 4
	if (sp) {
		strlcpy(nbuf, sp, BUFSIZ);
		print_text(h, nbuf);
	}
@


1.71
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.70 2014/03/30 19:47:32 schwarze Exp $ */
d28 1
d514 1
d517 1
a517 1
	char		 b[BUFSIZ], title[BUFSIZ];
d527 1
a527 1
	snprintf(title, BUFSIZ - 1, "%s(%s)", meta->title, meta->msec);
d558 2
@


1.70
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.69 2013/12/24 20:45:21 schwarze Exp $ */
d52 1
a52 1
static	void	  	  synopsis_pre(struct html *, 
d126 2
a127 2
	{mdoc_ss_pre, NULL }, /* Ss */ 
	{mdoc_pp_pre, NULL}, /* Pp */ 
d135 1
a135 1
	{mdoc_ad_pre, NULL}, /* Ad */ 
d140 3
a142 3
	{mdoc_dv_pre, NULL}, /* Dv */ 
	{mdoc_er_pre, NULL}, /* Er */ 
	{mdoc_ev_pre, NULL}, /* Ev */ 
d144 2
a145 2
	{mdoc_fa_pre, NULL}, /* Fa */ 
	{mdoc_fd_pre, NULL}, /* Fd */ 
d147 4
a150 4
	{mdoc_fn_pre, NULL}, /* Fn */ 
	{mdoc_ft_pre, NULL}, /* Ft */ 
	{mdoc_ic_pre, NULL}, /* Ic */ 
	{mdoc_in_pre, NULL}, /* In */ 
d152 2
a153 2
	{mdoc_nd_pre, NULL}, /* Nd */ 
	{mdoc_nm_pre, NULL}, /* Nm */ 
d158 1
a158 1
	{NULL, NULL}, /* St */ 
d160 1
a160 1
	{mdoc_vt_pre, NULL}, /* Vt */ 
d178 1
a178 1
	{mdoc_bf_pre, NULL}, /* Bf */ 
d189 1
a189 1
	{mdoc_em_pre, NULL}, /* Em */ 
d210 1
a210 1
	{mdoc_sm_pre, NULL}, /* Sm */ 
d217 2
a218 2
	{mdoc_fo_pre, mdoc_fo_post}, /* Fo */ 
	{NULL, NULL}, /* Fc */ 
d228 7
a234 7
	{mdoc_pp_pre, NULL}, /* Lp */ 
	{mdoc_lk_pre, NULL}, /* Lk */ 
	{mdoc_mt_pre, NULL}, /* Mt */ 
	{mdoc_quote_pre, mdoc_quote_post}, /* Brq */ 
	{mdoc_quote_pre, mdoc_quote_post}, /* Bro */ 
	{NULL, NULL}, /* Brc */ 
	{mdoc__x_pre, mdoc__x_post}, /* %C */ 
d237 2
a238 2
	{mdoc_xx_pre, NULL}, /* Dx */ 
	{mdoc__x_pre, mdoc__x_post}, /* %Q */ 
d240 3
a242 3
	{mdoc_sp_pre, NULL}, /* sp */ 
	{mdoc__x_pre, mdoc__x_post}, /* %U */ 
	{NULL, NULL}, /* Ta */ 
d261 1
d267 1
a267 1
			(struct html *)arg);
a270 1

a285 1

d296 4
a299 4
	if (n->prev->tok == n->tok && 
			MDOC_Fo != n->tok && 
			MDOC_Ft != n->tok && 
			MDOC_Fn != n->tok) {
d305 1
a305 1
	case (MDOC_Fd):
d307 1
a307 1
	case (MDOC_Fn):
d309 1
a309 1
	case (MDOC_Fo):
d311 1
a311 1
	case (MDOC_In):
d313 1
a313 1
	case (MDOC_Vt):
d316 1
a316 1
	case (MDOC_Ft):
a327 1

a348 1

d365 1
a365 1
	} else 
a371 2

/* ARGSUSED */
a386 1

a395 1

d406 1
a406 1
	case (MDOC_ROOT):
d409 1
a409 1
	case (MDOC_TEXT):
d426 1
a426 1
	case (MDOC_EQN):
d429 1
a429 1
	case (MDOC_TBL):
d468 1
a468 1
	case (MDOC_ROOT):
d471 1
a471 1
	case (MDOC_EQN):
a479 1
/* ARGSUSED */
a509 2

/* ARGSUSED */
a558 2

/* ARGSUSED */
a588 1
/* ARGSUSED */
a618 2

/* ARGSUSED */
a641 2

/* ARGSUSED */
a657 1

d666 1
a666 1
	case (MDOC_ELEM):
d673 1
a673 1
	case (MDOC_HEAD):
d678 1
a678 1
	case (MDOC_BODY):
a706 2

/* ARGSUSED */
d718 3
a720 3
		buffmt_man(h, n->child->string, 
				n->child->next ? 
				n->child->next->string : NULL);
a740 2

/* ARGSUSED */
a749 2

/* ARGSUSED */
a759 2

/* ARGSUSED */
d768 1
a768 1
	case (MDOC_Bsx):
d771 1
a771 1
	case (MDOC_Dx):
d774 1
a774 1
	case (MDOC_Fx):
d777 1
a777 1
	case (MDOC_Nx):
d780 1
a780 1
	case (MDOC_Ox):
d783 1
a783 1
	case (MDOC_Ux):
a802 2

/* ARGSUSED */
a829 1
/* ARGSUSED */
d853 1
a853 1
		case(LIST_bullet):
d855 1
a855 1
		case(LIST_dash):
d857 1
a857 1
		case(LIST_item):
d859 1
a859 1
		case(LIST_hyphen):
d861 1
a861 1
		case(LIST_enum):
d863 1
a863 1
		case(LIST_diag):
d865 1
a865 1
		case(LIST_hang):
d867 1
a867 1
		case(LIST_inset):
d869 1
a869 1
		case(LIST_ohang):
d871 1
a871 1
		case(LIST_tag):
d881 1
a881 1
		case(LIST_column):
d888 1
a888 1
		case(LIST_bullet):
d890 1
a890 1
		case(LIST_hyphen):
d892 1
a892 1
		case(LIST_dash):
d894 1
a894 1
		case(LIST_enum):
d896 1
a896 1
		case(LIST_item):
d902 1
a902 1
		case(LIST_diag):
d904 1
a904 1
		case(LIST_hang):
d906 1
a906 1
		case(LIST_inset):
d908 1
a908 1
		case(LIST_ohang):
d910 1
a910 1
		case(LIST_tag):
d920 1
a920 1
		case(LIST_column):
d931 1
a931 1
		case (LIST_column):
a941 1
/* ARGSUSED */
d1000 1
a1000 1
	case(LIST_bullet):
d1002 1
a1002 1
	case(LIST_dash):
d1004 1
a1004 1
	case(LIST_hyphen):
d1006 1
a1006 1
	case(LIST_item):
d1009 1
a1009 1
	case(LIST_enum):
d1012 1
a1012 1
	case(LIST_diag):
d1014 1
a1014 1
	case(LIST_hang):
d1016 1
a1016 1
	case(LIST_inset):
d1018 1
a1018 1
	case(LIST_ohang):
d1020 1
a1020 1
	case(LIST_tag):
d1023 1
a1023 1
	case(LIST_column):
a1033 1
/* ARGSUSED */
d1070 1
a1070 1
       	print_text(h, "0 on success, and >0 if an error occurs.");
a1073 2

/* ARGSUSED */
a1083 2

/* ARGSUSED */
d1108 1
a1108 1
	} 
a1112 2

/* ARGSUSED */
a1134 2

/* ARGSUSED */
d1138 2
a1139 2
	struct htmlpair	 	 tag[2];
	int		 	 comp, sv;
d1164 1
a1164 1
	
d1169 2
a1170 2
	if (DISP_unfilled != n->norm->Bd.type && 
			DISP_literal != n->norm->Bd.type) {
d1193 1
a1193 1
		case (MDOC_Sm):
d1195 1
a1195 1
		case (MDOC_br):
d1197 1
a1197 1
		case (MDOC_sp):
d1199 1
a1199 1
		case (MDOC_Bl):
d1201 1
a1201 1
		case (MDOC_D1):
d1203 1
a1203 1
		case (MDOC_Dl):
d1205 1
a1205 1
		case (MDOC_Lp):
d1207 1
a1207 1
		case (MDOC_Pp):
a1225 2

/* ARGSUSED */
a1235 2

/* ARGSUSED */
a1245 2

/* ARGSUSED */
a1257 2

/* ARGSUSED */
a1268 2

/* ARGSUSED */
a1278 2

/* ARGSUSED */
a1288 2

/* ARGSUSED */
a1298 2

/* ARGSUSED */
a1329 2

/* ARGSUSED */
d1358 2
a1359 2
		strlcpy(buf, '<' == *n->string || '"' == *n->string ? 
				n->string + 1 : n->string, BUFSIZ);
d1366 1
a1366 1
		
d1372 1
a1372 1
		} 
a1388 2

/* ARGSUSED */
a1406 2

/* ARGSUSED */
a1417 2

/* ARGSUSED */
d1438 1
a1438 1
	
a1509 2

/* ARGSUSED */
d1516 1
a1516 1
		/* 
a1533 1
/* ARGSUSED */
a1540 1
/* ARGSUSED */
a1548 1
/* ARGSUSED */
a1575 1
/* ARGSUSED */
a1599 2

/* ARGSUSED */
d1620 1
a1620 1
	
a1623 2

/* ARGSUSED */
a1651 2

/* ARGSUSED */
a1663 2

/* ARGSUSED */
d1699 1
a1699 1
		} 
a1718 2

/* ARGSUSED */
a1728 2

/* ARGSUSED */
d1768 2
a1769 2
       	print_text(h, "the value 0 if successful; otherwise the value "
			"-1 is returned and the global variable");
d1775 1
a1775 1
       	print_text(h, "is set to indicate the error.");
a1778 2

/* ARGSUSED */
a1788 2

/* ARGSUSED */
d1792 1
a1792 1
	
a1798 2

/* ARGSUSED */
d1810 1
a1810 1
	if (FONT_Em == n->norm->Bf.font) 
d1812 1
a1812 1
	else if (FONT_Sy == n->norm->Bf.font) 
d1814 1
a1814 1
	else if (FONT_Li == n->norm->Bf.font) 
d1819 1
a1819 1
	/* 
d1821 1
a1821 1
	 * accept block children. 
a1832 2

/* ARGSUSED */
a1842 2

/* ARGSUSED */
a1850 2

/* ARGSUSED */
a1857 2

/* ARGSUSED */
a1873 3


/* ARGSUSED */
a1883 2

/* ARGSUSED */
a1893 2

/* ARGSUSED */
a1901 2

/* ARGSUSED */
a1909 2

/* ARGSUSED */
a1922 2

/* ARGSUSED */
d1932 1
a1932 1
	case(MDOC__A):
d1938 1
a1938 1
	case(MDOC__B):
d1942 1
a1942 1
	case(MDOC__C):
d1945 1
a1945 1
	case(MDOC__D):
d1948 1
a1948 1
	case(MDOC__I):
d1952 1
a1952 1
	case(MDOC__J):
d1956 1
a1956 1
	case(MDOC__N):
d1959 1
a1959 1
	case(MDOC__O):
d1962 1
a1962 1
	case(MDOC__P):
d1965 1
a1965 1
	case(MDOC__Q):
d1968 1
a1968 1
	case(MDOC__R):
d1971 1
a1971 1
	case(MDOC__T):
d1974 1
a1974 1
	case(MDOC__U):
d1977 1
a1977 1
	case(MDOC__V):
a1995 2

/* ARGSUSED */
a2013 2

/* ARGSUSED */
d2019 1
a2019 1
	case (MDOC_BLOCK):
d2021 1
a2021 1
	case (MDOC_HEAD):
d2023 1
a2023 1
	case (MDOC_BODY):
a2034 2

/* ARGSUSED */
a2042 2

/* ARGSUSED */
d2052 1
a2052 1
	case (MDOC_Ao):
d2054 1
a2054 1
	case (MDOC_Aq):
d2057 1
a2057 1
	case (MDOC_Bro):
d2059 1
a2059 1
	case (MDOC_Brq):
d2062 1
a2062 1
	case (MDOC_Bo):
d2064 1
a2064 1
	case (MDOC_Bq):
d2067 1
a2067 1
	case (MDOC_Oo):
d2069 1
a2069 1
	case (MDOC_Op):
d2075 1
a2075 1
	case (MDOC_Eo):
d2077 1
a2077 1
	case (MDOC_Do):
d2079 1
a2079 1
	case (MDOC_Dq):
d2081 1
a2081 1
	case (MDOC_Qo):
d2083 1
a2083 1
	case (MDOC_Qq):
d2086 1
a2086 1
	case (MDOC_Po):
d2088 1
a2088 1
	case (MDOC_Pq):
d2091 1
a2091 1
	case (MDOC_Ql):
d2097 1
a2097 1
	case (MDOC_So):
d2099 1
a2099 1
	case (MDOC_Sq):
a2110 2

/* ARGSUSED */
d2121 1
a2121 1
	case (MDOC_Ao):
d2123 1
a2123 1
	case (MDOC_Aq):
d2126 1
a2126 1
	case (MDOC_Bro):
d2128 1
a2128 1
	case (MDOC_Brq):
d2131 1
a2131 1
	case (MDOC_Oo):
d2133 1
a2133 1
	case (MDOC_Op):
d2135 1
a2135 1
	case (MDOC_Bo):
d2137 1
a2137 1
	case (MDOC_Bq):
d2140 1
a2140 1
	case (MDOC_Eo):
d2142 1
a2142 1
	case (MDOC_Qo):
d2144 1
a2144 1
	case (MDOC_Qq):
d2146 1
a2146 1
	case (MDOC_Do):
d2148 1
a2148 1
	case (MDOC_Dq):
d2151 1
a2151 1
	case (MDOC_Po):
d2153 1
a2153 1
	case (MDOC_Pq):
d2156 1
a2156 1
	case (MDOC_Ql):
d2158 1
a2158 1
	case (MDOC_So):
d2160 1
a2160 1
	case (MDOC_Sq):
a2167 2


@


1.69
log
@It turns out SYNOPSIS mode does not imply .Bk in general,
but only within .Nm blocks.  Simplify the code accordingly.
This reduces groff-mandoc differences in base by about 2%.

Triggered by research done by Franco Fichtner.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.68 2013/12/24 19:10:34 schwarze Exp $ */
d4 1
d95 1
d243 1
d1601 8
a1613 1

@


1.68
log
@When deciding whether two consecutive macros are on the same input line,
we have to compare the line where the first one *ends* (not where it begins)
to the line where the second one starts.
This fixes the bug that .Bk allowed output line breaks right after block
macros spanning more than one input line, even when the next macro follows
on the same line.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.67 2012/11/17 00:25:20 schwarze Exp $ */
d458 1
a458 1
	if (HTML_KEEP & h->flags || MDOC_SYNPRETTY & n->flags) {
@


1.67
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.66 2012/08/12 06:04:09 matthew Exp $ */
d458 3
a460 2
	if (HTML_KEEP & h->flags) {
		if (n->prev && n->prev->line != n->line) {
a462 5
		} else if (NULL == n->prev) {
			if (n->parent && n->parent->line != n->line) {
				h->flags &= ~HTML_KEEP;
				h->flags |= HTML_PREKEEP;
			}
@


1.66
log
@.Sq should use curly right quotes in HTML output to match its curly
left quotes.

Also, properly reinitialize the styles attribute string buffer for
each column in a table so that the attributes don't accumulate.

tweak and ok schwarze
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.65 2011/11/03 20:32:33 schwarze Exp $ */
d34 1
a34 1
#define	MDOC_ARGS	  const struct mdoc_meta *m, \
d259 1
a259 1
html_mdoc(void *arg, const struct mdoc *m)
d262 2
a263 1
	print_mdoc(mdoc_meta(m), mdoc_node(m), (struct html *)arg);
d361 1
a361 1
		print_mdoc_head(m, n, h);
d368 1
a368 1
	print_mdoc_nodelist(m, n, h);
d380 1
a380 1
	bufcat_fmt(h, "%s(%s)", m->title, m->msec);
d382 2
a383 2
	if (m->arch)
		bufcat_fmt(h, " (%s)", m->arch);
d394 1
a394 1
	print_mdoc_node(m, n, h);
d396 1
a396 1
		print_mdoc_nodelist(m, n->next, h);
d411 1
a411 1
		child = mdoc_root_pre(m, n, h);
d454 1
a454 1
			child = (*mdocs[n->tok].pre)(m, n, h);
d471 1
a471 1
		print_mdoc_nodelist(m, n->child, h);
d477 1
a477 1
		mdoc_root_post(m, n, h);
d483 1
a483 1
			(*mdocs[n->tok].post)(m, n, h);
d509 1
a509 1
	print_text(h, m->date);
d515 1
a515 1
	print_text(h, m->os);
d528 1
a528 1
	strlcpy(b, m->vol, BUFSIZ);
d530 1
a530 1
	if (m->arch) {
d532 1
a532 1
		strlcat(b, m->arch, BUFSIZ);
d536 1
a536 1
	snprintf(title, BUFSIZ - 1, "%s(%s)", m->title, m->msec);
d689 2
a690 2
		if (NULL == n->child && m->name)
			print_text(h, m->name);
d694 2
a695 2
		if (NULL == n->child && m->name)
			print_text(h, m->name);
d712 2
a713 2
	if (0 == len && m->name)
		len = html_strlen(m->name);
d1225 1
a1225 1
		print_mdoc_node(m, nn, h);
@


1.65
log
@Correct .Eo spacing:
no space between the delimiters and the enclosed text.
The mdoc_html.c part was added by kristaps; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.64 2011/10/16 12:18:32 schwarze Exp $ */
a979 2
	bufinit(h);

d998 1
d1012 1
d2272 1
a2272 1
		print_text(h, "\\(aq");
@


1.64
log
@Remove a bunch of useless assignments,
and assert that print_bvspace cannot be called on NULL pointers.
No change in behaviour, none of these were bugs,
but the code becomes easier to understand.
Based on a clang report posted by joerg@@; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.63 2011/10/09 22:10:51 schwarze Exp $ */
d188 1
a188 1
	{NULL, NULL}, /* Eo */
d2184 2
d2250 2
@


1.63
log
@Always print <table> column widths in -T[x]html;
if desired, they can be overridden in the CSS file.
Suggested by kristaps@@, and i always like to simplify code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.62 2011/10/09 17:59:56 schwarze Exp $ */
d502 1
a502 1
	t = print_otag(h, TAG_TBODY, 0, NULL);
@


1.62
log
@Sync to version 1.12.0; all code by kristaps@@:
Implement .Rv in -Tman.
Let -man -Tman work a bit like cat(1).
Add the -Ofragment option to -T[x]html.
Minor fixes in -T[x]html.
Lots of apropos(1) and -Tman code cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.61 2011/09/18 15:54:48 schwarze Exp $ */
d496 5
a500 8
	if (NULL == h->style) {
		PAIR_INIT(&tag[2], ATTR_WIDTH, "100%");
		t = print_otag(h, TAG_TABLE, 3, tag);
		PAIR_INIT(&tag[0], ATTR_WIDTH, "50%");
		print_otag(h, TAG_COL, 1, tag);
		print_otag(h, TAG_COL, 1, tag);
	} else
		t = print_otag(h, TAG_TABLE, 2, tag);
a507 1

d512 2
a513 6
	if (NULL == h->style) {
		PAIR_INIT(&tag[1], ATTR_ALIGN, "right");
		print_otag(h, TAG_TD, 2, tag);
	} else 
		print_otag(h, TAG_TD, 1, tag);

d539 6
a544 9
	if (NULL == h->style) {
		PAIR_INIT(&tag[2], ATTR_WIDTH, "100%");
		t = print_otag(h, TAG_TABLE, 3, tag);
		PAIR_INIT(&tag[0], ATTR_WIDTH, "30%");
		print_otag(h, TAG_COL, 1, tag);
		print_otag(h, TAG_COL, 1, tag);
		print_otag(h, TAG_COL, 1, tag);
	} else
		t = print_otag(h, TAG_TABLE, 2, tag);
a551 1

d556 2
a557 6
	if (NULL == h->style) {
		PAIR_INIT(&tag[1], ATTR_ALIGN, "center");
		print_otag(h, TAG_TD, 2, tag);
	} else 
		print_otag(h, TAG_TD, 1, tag);

d562 2
a563 6
	if (NULL == h->style) {
		PAIR_INIT(&tag[1], ATTR_ALIGN, "right");
		print_otag(h, TAG_TD, 2, tag);
	} else 
		print_otag(h, TAG_TD, 1, tag);

@


1.61
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.60 2011/09/18 10:25:28 schwarze Exp $ */
a260 2
	struct html 	*h;
	struct tag	*t;
d262 2
a263 8
	h = (struct html *)arg;

	print_gen_decls(h);
	t = print_otag(h, TAG_HTML, 0, NULL);
	print_mdoc(mdoc_meta(m), mdoc_node(m), h);
	print_tagq(h, t);

	printf("\n");
d351 4
a354 1
	struct tag	*t;
d356 10
a365 3
	t = print_otag(h, TAG_HEAD, 0, NULL);
	print_mdoc_head(m, n, h);
	print_tagq(h, t);
a366 1
	t = print_otag(h, TAG_BODY, 0, NULL);
@


1.60
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.59 2011/07/05 04:12:41 schwarze Exp $ */
a32 1
#define	HALFINDENT	 3
d351 2
a352 4
	else if ( ! a2roffsu(p, su, SCALE_MAX)) {
		su->unit = SCALE_BU;
		su->scale = html_strlen(p);
	}
d604 2
a605 1
	for (n = n->child; n; n = n->next) {
d607 1
a607 1
		if (n->next)
d611 6
a616 2
	PAIR_ID_INIT(&tag, h->buf);
	print_otag(h, TAG_H1, 1, &tag);
a619 1

d635 2
a636 1
	for (n = n->child; n; n = n->next) {
d638 1
a638 1
		if (n->next)
d642 6
a647 2
	PAIR_ID_INIT(&tag, h->buf);
	print_otag(h, TAG_H2, 1, &tag);
d1176 2
a1177 1
	for (n = n->child; n; n = n->next) {
d1179 1
a1179 1
		if (n->next)
d1990 1
a1990 1
	print_otag(h, TAG_SPAN, 1, &tag);
d2218 5
a2222 1
		/* FALLTHROUGH */
@


1.59
log
@Sync to bsd.lv (all coded by kristaps@@):
 - mdoc(7): fix an assertion if the first line after .Bd -column
   starts with a blank, and some simplifications in mdoc_argv.c
 - man(7): literal mode ends at .SH and .SS (bug reported by naddy@@)
 - allow .RS/.RE blocks to nest (bug reported by dcoppa@@ and gsoares@@)
 - improve vertical spacing of man(7) blocks
 - roff(7): clear user-defined strings when starting a new file
 - correct ID tags in -T[x]html
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.58 2011/06/18 12:40:57 schwarze Exp $ */
a405 1
	struct htmlpair	 tag;
d432 1
a432 3
		PAIR_CLASS_INIT(&tag, "eqn");
		print_otag(h, TAG_SPAN, 1, &tag);
		print_text(h, n->eqn->data);
@


1.58
log
@Have -T[x]html print out the link target for `Lk'
if no link title is provided.
Based on a patch by Tim van der Molen, tweaked by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.57 2011/05/29 21:22:18 schwarze Exp $ */
d609 1
d636 1
d1634 3
a1636 2
		if (n->child)
			a2roffsu(n->child->string, &su, SCALE_VS);
@


1.57
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.56 2011/04/24 16:22:02 schwarze Exp $ */
d1665 4
a1668 2
	for (n = n->next; n; n = n->next) {
		assert(MDOC_TEXT == n->type);
a1669 1
	}
@


1.56
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.55 2011/04/21 22:59:54 schwarze Exp $ */
d287 1
a287 1
		su->scale = (int)strlen(p);
d354 1
a354 1
		su->scale = (int)strlen(p);
d381 1
a381 1
	buffmt(h, "%s(%s)", m->title, m->msec);
d383 2
a384 5
	if (m->arch) {
		bufcat(h, " (");
		bufcat(h, m->arch);
		bufcat(h, ")");
	}
a410 1
	bufinit(h);
a478 1
	bufinit(h);
a599 1
	char		 buf[BUFSIZ];
d608 1
a608 1
	buf[0] = '\0';
d610 1
a610 1
		html_idcat(buf, n->string, BUFSIZ);
d612 1
a612 1
			html_idcat(buf, " ", BUFSIZ);
d615 1
a615 1
	PAIR_ID_INIT(&tag, buf);
a625 1
	char		 buf[BUFSIZ];
d634 1
a634 1
	buf[0] = '\0';
d636 1
a636 1
		html_idcat(buf, n->string, BUFSIZ);
d638 1
a638 1
			html_idcat(buf, " ", BUFSIZ);
d641 1
a641 1
	PAIR_ID_INIT(&tag, buf);
d695 1
a695 1
	size_t		 len;
d723 1
a723 1
			len += strlen(n->string);
d726 1
a726 1
		len = strlen(m->name);
d729 1
d892 2
d994 2
a1014 1
			bufinit(h);
d1143 1
a1167 1
	char		 buf[BUFSIZ];
d1169 2
a1170 1
	strlcpy(buf, "#", BUFSIZ);
d1172 1
a1172 1
		html_idcat(buf, n->string, BUFSIZ);
d1174 1
a1174 1
			html_idcat(buf, " ", BUFSIZ);
d1178 1
a1178 1
	PAIR_HREF_INIT(&tag[1], buf);
d1216 2
a1217 1

a1435 1
		bufinit(h);
d1557 1
a1558 1
	PAIR_CLASS_INIT(&tag[0], "farg");
d1637 1
a1773 1
		bufinit(h);
a1775 1

d1914 1
@


1.55
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.54 2011/03/20 23:36:42 schwarze Exp $ */
d430 2
d433 2
d750 1
a750 2
	struct htmlpair	 	 tag[2];
	const struct mdoc_node	*nn;
d766 2
a767 2
	nn = n->child;
	print_text(h, nn->string);
d769 1
a769 1
	if (NULL == (nn = nn->next))
d775 1
a775 1
	print_text(h, nn->string);
d1085 3
a1087 3
	const struct mdoc_node	*nn;
	struct tag		*t;
	struct htmlpair		 tag;
d1095 5
a1099 1
	for (nn = n->child; nn; nn = nn->next) {
d1101 1
a1101 1
		print_text(h, nn->string);
d1104 4
a1107 1
		h->flags |= HTML_NOSPACE;
d1109 2
a1110 6
		if (nn->next && NULL == nn->next->next)
			print_text(h, ", and");
		else if (nn->next)
			print_text(h, ",");
		else
			h->flags &= ~HTML_NOSPACE;
d1113 1
a1113 1
	if (n->child && n->child->next)
d1169 2
a1170 3
	struct htmlpair		 tag[2];
	const struct mdoc_node	*nn;
	char			 buf[BUFSIZ];
d1173 3
a1175 3
	for (nn = n->child; nn; nn = nn->next) {
		html_idcat(buf, nn->string, BUFSIZ);
		if (nn->next)
d1385 2
a1386 1
		if (nn->next)
d1388 1
d1391 2
a1392 1
	if (n->child && n->next && n->next->tok == MDOC_Fa)
d1394 1
d1404 5
a1408 1
	struct htmlpair	 tag;
d1412 47
a1458 3
	PAIR_CLASS_INIT(&tag, "macro");
	print_otag(h, TAG_B, 1, &tag);
	return(1);
d1499 5
a1503 6
	struct tag		*t;
	struct htmlpair	 	 tag[2];
	const struct mdoc_node	*nn;
	char			 nbuf[BUFSIZ];
	const char		*sp, *ep;
	int			 sz, i;
d1505 1
d1557 1
d1564 1
a1564 1
	for (nn = n->child->next; nn; nn = nn->next) {
d1569 1
a1569 1
		print_text(h, nn->string);
d1571 2
a1572 1
		if (nn->next)
d1574 1
d1577 1
d1579 3
a1581 1
	if (MDOC_SYNPRETTY & n->flags)
d1583 1
d1654 4
a1657 2
	const struct mdoc_node	*nn;
	struct htmlpair		 tag[2];
d1659 1
a1659 1
	nn = n->child;
d1662 2
a1663 1
	PAIR_HREF_INIT(&tag[1], nn->string);
d1666 4
a1669 5
	if (NULL == nn || NULL == nn->next) 
		return(1);

	for (nn = nn->next; nn; nn = nn->next) 
		print_text(h, nn->string);
d1679 2
a1680 3
	struct htmlpair	 	 tag[2];
	struct tag		*t;
	const struct mdoc_node	*nn;
d1684 3
a1686 1
	for (nn = n->child; nn; nn = nn->next) {
d1689 2
a1690 1
		bufcat(h, nn->string);
d1693 1
a1693 1
		print_text(h, nn->string);
d1738 1
d1740 1
d1749 3
a1751 4
	const struct mdoc_node	*nn;
	struct tag		*t;
	struct htmlpair		 tag[2];
	int			 i;
d1758 7
d1771 3
a1773 1
	for (nn = n->child; nn; nn = nn->next) {
d1775 2
d1778 1
a1778 1
		bufinit(h);
d1780 1
a1780 1
			buffmt_includes(h, nn->string);
d1783 2
a1784 1
		}
d1786 1
a1786 1
		print_mdoc_node(m, nn, h);
d1788 2
d1795 5
d1820 3
a1822 3
	const struct mdoc_node	*nn;
	struct htmlpair		 tag;
	struct tag		*t;
d1827 2
d1831 4
a1834 2
	for (nn = n->child; nn; nn = nn->next) {
		PAIR_CLASS_INIT(&tag, "fname");
d1836 1
a1836 1
		print_text(h, nn->string);
d1840 9
a1848 6
		if (nn->next && NULL == nn->next->next)
			print_text(h, "(), and");
		else if (nn->next)
			print_text(h, "(),");
		else
			print_text(h, "()");
d1851 1
a1851 1
	if (n->child && n->child->next)
d2126 1
@


1.54
log
@Import the foundation for eqn(7) support.
Written by kristaps@@.

For now, i'm adding one line to each of the four frontends
to just pass the input text through to the output,
not yet interpreting any of then eqn keywords.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.53 2011/03/07 01:35:33 schwarze Exp $ */
d409 1
d433 2
d436 1
a436 1
		return;
d483 2
@


1.53
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.52 2011/02/06 22:56:45 schwarze Exp $ */
d430 3
@


1.52
log
@Do not break the line between the arguments of .Bsx .Dx .Fx .Nx .Ox .Ux.
Original patch from kristaps@@, but i fixed a regression regarding .Bk.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.51 2011/02/06 17:33:20 schwarze Exp $ */
a490 3
	char		 b[DATESIZ];

	time2a(m->date, b, DATESIZ);
d510 1
a510 1
	print_text(h, b);
@


1.51
log
@If .Ns is specified on its own line, ignore it, like groff does;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.50 2011/01/31 03:04:26 schwarze Exp $ */
d803 1
d830 1
d832 7
a838 1
	return(1);
@


1.50
log
@When in a <PRE>, don't print out the <BR> before lines that have
leading whitespace; from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.49 2011/01/30 18:28:01 schwarze Exp $ */
d779 2
a780 1
	h->flags |= HTML_NOSPACE;
@


1.49
log
@Make .Bx accept not more than two arguments.
Convert the first character of the second argument to uppercase.
Append the second argument with a hyphen.
Improves chpass(1), column(1), fstat(1), ...
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.48 2011/01/16 19:41:16 schwarze Exp $ */
d421 5
d427 2
a428 1
			print_otag(h, TAG_BR, 0, NULL);
d1174 1
a1174 1
	int		 	 comp;
d1213 5
d1253 3
@


1.48
log
@Merge from bsd.lv, original commit message by kristaps@@:
Change how -Thtml behaves with tables: use multiple rows, with widths
set by COL, until an external macro is encountered.  At this point in
time, close out the table and process the macro.  When the first table
row is again re-encountered, re-start the table.  This requires a bit of
tracking added to "struct html", but the change is very small and
follows the logic of meta-fonts.  This all follows a bug-report by
joerg@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.47 2011/01/16 02:56:47 schwarze Exp $ */
d831 1
a831 2
	const struct mdoc_node	*nn;
	struct htmlpair		 tag;
d836 8
a843 2
	for (nn = n->child; nn; nn = nn->next)
		print_mdoc_node(m, nn, h);
d845 3
a847 1
	if (n->child)
d849 2
a851 1
	print_text(h, "BSD");
@


1.47
log
@If the first character of a free-form text input line is whitespace,
then it will start a new output line;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.46 2011/01/09 16:31:46 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d419 2
d426 5
d432 1
a432 1
		break;
d434 11
a470 2
		break;
	case (MDOC_TBL):
@


1.46
log
@Remove an unused variable, and use int for array indices (not size_t);
found by lint(1), fixed by kristaps@@, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.45 2011/01/04 22:28:17 schwarze Exp $ */
d419 2
@


1.45
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.44 2010/12/29 00:47:31 schwarze Exp $ */
d829 1
d944 1
a944 1
	size_t		 i;
d966 1
a966 1
		for (i = 0; i < n->norm->Bl.ncols; i++) {
d969 1
a969 1
			if (i < n->norm->Bl.ncols - 1)
@


1.44
log
@Reorg by Kristaps:  In libmdoc, replace the union of pointers to structs
of macro-specific data by a pointer to a union of structs, which makes the
code simpler and more robust at the expense of a small memory overhead.
Merging was somewhat difficult because we mustn't break tbl(1) support
which the bsd.lv version does not yet have.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.43 2010/12/25 13:23:03 schwarze Exp $ */
a241 2
	{NULL, NULL}, /* TS */ 
	{NULL, NULL}, /* TE */ 
d421 3
d451 2
@


1.43
log
@Yet another batch of -Thtml polishing from kristaps@@:
In particular, use <SMALL> for .SM and <CODE> for .Dl.
Use <B> for bold and <I> for italic in general.
Also call this mandoc 1.10.8 now, as it is functionally equivalent,
even though one one set of refactoring patches has not been merged
yet because it conflicts with our tbl(1) handling.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.42 2010/12/22 00:33:25 schwarze Exp $ */
d840 1
a840 1
	type = bl->data.Bl->type;
d866 1
a866 1
			SCALE_VS_INIT(&su, ! bl->data.Bl->comp);
d891 1
a891 1
			SCALE_VS_INIT(&su, ! bl->data.Bl->comp);
d905 1
a905 1
			if (NULL == bl->data.Bl->width) {
d909 1
a909 1
			a2width(bl->data.Bl->width, &su);
d915 1
a915 1
			SCALE_VS_INIT(&su, ! bl->data.Bl->comp);
d946 1
a946 1
		if (LIST_column == n->data.Bl->type)
d952 1
a952 1
		if (LIST_column != n->data.Bl->type)
d962 2
a963 2
		for (i = 0; i < n->data.Bl->ncols; i++) {
			a2width(n->data.Bl->cols[i], &su);
d965 1
a965 1
			if (i < n->data.Bl->ncols - 1)
d981 1
a981 1
	assert(lists[n->data.Bl->type]);
d983 1
a983 1
	strlcat(buf, lists[n->data.Bl->type], BUFSIZ);
d988 2
a989 2
	if (n->data.Bl->offs) {
		a2offs(n->data.Bl->offs, &su);
d993 1
a993 1
	switch (n->data.Bl->type) {
d1146 1
a1146 1
		comp = n->data.Bd->comp;
d1161 2
a1162 2
	if (n->data.Bd->offs)
		a2offs(n->data.Bd->offs, &su);
d1167 2
a1168 2
	if (DISP_unfilled != n->data.Bd->type && 
			DISP_literal != n->data.Bd->type) {
d1751 1
a1751 3
	assert(n->data.Bf);

	if (FONT_Em == n->data.Bf->font) 
d1753 1
a1753 1
	else if (FONT_Sy == n->data.Bf->font) 
d1755 1
a1755 1
	else if (FONT_Li == n->data.Bf->font) 
@


1.42
log
@More small -Thtml improvements by kristaps@@,
in particular, use <B>, <I> and <U> where appropriate.
Provide relative widths for header and footer lines.
Manuals: More concise short descriptions of output modes.
Correct a few places still talking about CSS2 to say CSS1.
Code examples should use .Dl, not .D1.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.41 2010/12/19 12:18:15 schwarze Exp $ */
d471 2
a472 2
		PAIR_INIT(&tag[1], ATTR_WIDTH, "100%");
		t = print_otag(h, TAG_TABLE, 2, tag);
d1097 7
a1103 4
	if (MDOC_Dl == n->tok)
		PAIR_CLASS_INIT(&tag[0], "lit display");
	else
		PAIR_CLASS_INIT(&tag[0], "display");
a1104 1
	print_otag(h, TAG_DIV, 1, tag);
d1598 1
a1598 1
	t = print_otag(h, TAG_SPAN, 1, &tag);
d1685 1
a1685 1
		t = print_otag(h, TAG_SPAN, 1, &tag);
a1935 1
		t = TAG_U;
@


1.41
log
@Handle .Bk in -Thmtl the same way as in -Tascii.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.40 2010/12/19 09:22:35 schwarze Exp $ */
d462 1
a462 1
	struct htmlpair	 tag[2];
d468 12
a479 3
	PAIR_CLASS_INIT(&tag[0], "foot");
	PAIR_SUMMARY_INIT(&tag[1], "Document Footer");
	t = print_otag(h, TAG_TABLE, 2, tag);
d490 5
a494 1
	print_otag(h, TAG_TD, 1, tag);
d519 13
a531 3
	PAIR_CLASS_INIT(&tag[0], "head");
	PAIR_SUMMARY_INIT(&tag[1], "Document Header");
	t = print_otag(h, TAG_TABLE, 2, tag);
d542 5
a546 1
	print_otag(h, TAG_TD, 1, tag);
d552 5
a556 1
	print_otag(h, TAG_TD, 1, tag);
d625 1
a625 1
	print_otag(h, TAG_SPAN, 1, &tag);
d672 1
a672 1
		print_otag(h, TAG_SPAN, 1, &tag);
d764 1
a764 1
	print_otag(h, TAG_SPAN, 1, &tag);
d870 4
d943 1
d982 3
a984 5
	bufinit(h);
	bufcat(h, "list ");
	bufcat(h, lists[n->data.Bl->type]);
	PAIR_INIT(&tag[1], ATTR_CLASS, h->buf);
	i = 2;
a990 2
		PAIR_STYLE_INIT(&tag[2], h);
		i = 3;
d1001 1
a1001 1
		print_otag(h, TAG_UL, i, tag);
d1004 1
a1004 1
		print_otag(h, TAG_OL, i, tag);
d1015 1
a1015 1
		print_otag(h, TAG_DL, i, tag);
d1018 1
a1018 1
		print_otag(h, TAG_TABLE, i, tag);
d1043 1
a1043 1
		t = print_otag(h, TAG_SPAN, 1, &tag);
d1125 1
d1222 1
a1222 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1234 1
a1234 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1261 1
a1261 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1312 1
a1312 1
		print_otag(h, TAG_SPAN, 1, &tag);
d1317 1
a1317 1
		t = print_otag(h, TAG_SPAN, 1, &tag);
d1340 1
a1340 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1373 1
a1373 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1398 1
a1398 1
		t = print_otag(h, TAG_SPAN, 1, tag);
d1429 1
a1429 1
	t = print_otag(h, TAG_SPAN, 1, tag);
d1450 1
a1450 1
		t = print_otag(h, TAG_SPAN, i, tag);
d1627 1
a1627 1
	print_otag(h, TAG_SPAN, 1, tag);
d1663 1
a1663 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1705 1
a1705 1
	t = print_otag(h, TAG_SPAN, 1, &tag);
d1720 1
a1720 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1888 3
d1901 1
d1911 1
d1915 1
d1934 1
d1948 1
a1948 1
		print_otag(h, TAG_SPAN, 1, tag);
@


1.40
log
@Significant improvements to -Thtml by kristaps@@:
Use less <DIV>, use more <H1>, <H2>, <P>, <BR>, <PRE>, <UL>, <OL>, <DL> etc.
Triggered by input from Will Backman.
Remove CSS2 note in mandoc.1, which is no longer true.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.39 2010/12/06 22:10:13 schwarze Exp $ */
d1949 2
a1950 1
		h->flags |= HTML_PREKEEP;
@


1.39
log
@Do not follow .D1 and .Dl inside .Bd with a blank line.
Kristaps@@ came up with this improvement when he merged
my patch introducing support for nested displays.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.38 2010/12/01 22:02:29 schwarze Exp $ */
a70 1
static	void		  mdoc_bl_post(MDOC_ARGS);
a90 6
static	int		  mdoc_it_block_pre(MDOC_ARGS, enum mdoc_list,
				int, struct roffsu *, struct roffsu *);
static	int		  mdoc_it_head_pre(MDOC_ARGS, enum mdoc_list, 
				struct roffsu *);
static	int		  mdoc_it_body_pre(MDOC_ARGS, enum mdoc_list,
				struct roffsu *);
d102 1
d126 1
a126 1
	{mdoc_sp_pre, NULL}, /* Pp */ 
d131 1
a131 1
	{mdoc_bl_pre, mdoc_bl_post}, /* Bl */
d227 1
a227 1
	{mdoc_sp_pre, NULL}, /* Lp */ 
d246 14
d288 1
a288 1
		su->unit = SCALE_EM;
a299 2
	struct roffsu	 su;
	struct htmlpair	 tag;
a303 4
	SCALE_VS_INIT(&su, 1);
	bufcat_su(h, "margin-top", &su);
	PAIR_STYLE_INIT(&tag, h);

d308 1
a308 1
		print_otag(h, TAG_DIV, 0, NULL);
d322 1
a322 1
		print_otag(h, TAG_DIV, 1, &tag);
d326 1
a326 1
			print_otag(h, TAG_DIV, 1, &tag);
d331 1
a331 1
		print_otag(h, TAG_DIV, 0, NULL);
d355 1
a355 1
		su->unit = SCALE_EM;
a364 1
	struct htmlpair	 tag;
a370 5

	tag.key = ATTR_CLASS;
	tag.val = "body";
	print_otag(h, TAG_DIV, 1, &tag);

a457 1

d462 1
a462 1
	struct htmlpair	 tag[3];
d468 3
a470 10
	/*
	 * XXX: this should use divs, but in Firefox, divs with nested
	 * divs for some reason puke when trying to put a border line
	 * below.  So I use tables, instead.
	 */

	PAIR_CLASS_INIT(&tag[0], "footer");
	bufcat_style(h, "width", "100%");
	PAIR_STYLE_INIT(&tag[1], h);
	PAIR_SUMMARY_INIT(&tag[2], "footer");
a471 1
	t = print_otag(h, TAG_TABLE, 3, tag);
d474 1
a474 3
	bufinit(h);
	bufcat_style(h, "width", "50%");
	PAIR_STYLE_INIT(&tag[0], h);
d476 1
d480 1
a480 4
	bufinit(h);
	bufcat_style(h, "width", "50%");
	bufcat_style(h, "text-align", "right");
	PAIR_STYLE_INIT(&tag[0], h);
d482 1
d496 1
a496 1
	(void)strlcpy(b, m->vol, BUFSIZ);
d499 3
a501 3
		(void)strlcat(b, " (", BUFSIZ);
		(void)strlcat(b, m->arch, BUFSIZ);
		(void)strlcat(b, ")", BUFSIZ);
d504 1
a504 2
	(void)snprintf(title, BUFSIZ - 1, 
			"%s(%s)", m->title, m->msec);
d506 3
a508 8
	/* XXX: see note in mdoc_root_post() about divs. */

	PAIR_CLASS_INIT(&tag[0], "header");
	bufcat_style(h, "width", "100%");
	PAIR_STYLE_INIT(&tag[1], h);
	PAIR_SUMMARY_INIT(&tag[2], "header");

	t = print_otag(h, TAG_TABLE, 3, tag);
d512 1
a512 3
	bufinit(h);
	bufcat_style(h, "width", "10%");
	PAIR_STYLE_INIT(&tag[0], h);
d514 1
d518 1
a518 5
	bufinit(h);
	bufcat_style(h, "text-align", "center");
	bufcat_style(h, "white-space", "nowrap");
	bufcat_style(h, "width", "80%");
	PAIR_STYLE_INIT(&tag[0], h);
d520 1
d524 1
a524 4
	bufinit(h);
	bufcat_style(h, "text-align", "right");
	bufcat_style(h, "width", "10%");
	PAIR_STYLE_INIT(&tag[0], h);
d526 1
d537 2
a538 4
	struct htmlpair		 tag[2];
	const struct mdoc_node	*nn;
	char			 buf[BUFSIZ];
	struct roffsu		 su;
d540 3
a542 6
	if (MDOC_BODY == n->type) {
		SCALE_HS_INIT(&su, INDENT);
		bufcat_su(h, "margin-left", &su);
		PAIR_CLASS_INIT(&tag[0], "sec-body");
		PAIR_STYLE_INIT(&tag[1], h);
		print_otag(h, TAG_DIV, 2, tag);
d544 1
a544 14
	} else if (MDOC_BLOCK == n->type) {
		PAIR_CLASS_INIT(&tag[0], "sec-block");
		if (n->prev && NULL == n->prev->body->child) {
			print_otag(h, TAG_DIV, 1, tag);
			return(1);
		}
		
		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "margin-top", &su);
		if (NULL == n->next)
			bufcat_su(h, "margin-bottom", &su);

		PAIR_STYLE_INIT(&tag[1], h);
		print_otag(h, TAG_DIV, 2, tag);
a545 1
	}
d548 3
a550 3
	for (nn = n->child; nn; nn = nn->next) {
		html_idcat(buf, nn->string, BUFSIZ);
		if (nn->next)
d554 2
a555 4
	PAIR_CLASS_INIT(&tag[0], "sec-head");
	PAIR_ID_INIT(&tag[1], buf);

	print_otag(h, TAG_DIV, 2, tag);
d564 2
a565 4
	struct htmlpair	 	 tag[3];
	const struct mdoc_node	*nn;
	char			 buf[BUFSIZ];
	struct roffsu		 su;
d567 3
a569 10
	SCALE_VS_INIT(&su, 1);

	if (MDOC_BODY == n->type) {
		PAIR_CLASS_INIT(&tag[0], "ssec-body");
		if (n->parent->next && n->child) {
			bufcat_su(h, "margin-bottom", &su);
			PAIR_STYLE_INIT(&tag[1], h);
			print_otag(h, TAG_DIV, 2, tag);
		} else
			print_otag(h, TAG_DIV, 1, tag);
d571 1
a571 8
	} else if (MDOC_BLOCK == n->type) {
		PAIR_CLASS_INIT(&tag[0], "ssec-block");
		if (n->prev) {
			bufcat_su(h, "margin-top", &su);
			PAIR_STYLE_INIT(&tag[1], h);
			print_otag(h, TAG_DIV, 2, tag);
		} else
			print_otag(h, TAG_DIV, 1, tag);
a572 3
	}

	/* TODO: see note in mdoc_sh_pre() about duplicates. */
d575 3
a577 3
	for (nn = n->child; nn; nn = nn->next) {
		html_idcat(buf, nn->string, BUFSIZ);
		if (nn->next)
d581 2
a582 9
	SCALE_HS_INIT(&su, INDENT - HALFINDENT);
	su.scale = -su.scale;
	bufcat_su(h, "margin-left", &su);

	PAIR_CLASS_INIT(&tag[0], "ssec-head");
	PAIR_STYLE_INIT(&tag[1], h);
	PAIR_ID_INIT(&tag[2], buf);

	print_otag(h, TAG_DIV, 3, tag);
d624 1
a624 1
	PAIR_CLASS_INIT(&tag, "desc-body");
d635 1
a635 1
	const char	*cp;
d637 2
a638 10
	/*
	 * Accomodate for `Nm' being both an element (which may have
	 * NULL children AND no m->name) and a block.
	 */

	cp = NULL;

	if (MDOC_ELEM == n->type) {
		if (NULL == n->child && NULL == m->name)
			return(1);
d642 1
a642 1
		if (NULL == n->child)
d644 12
a655 2
	} else if (MDOC_BLOCK == n->type) {
		synopsis_pre(h, n);
d657 3
a659 7
		bufcat_style(h, "clear", "both");
		if (n->head->child || m->name) {
			if (n->head->child && MDOC_TEXT == 
					n->head->child->type)
				cp = n->head->child->string;
			if (NULL == cp || '\0' == *cp)
				cp = m->name;
d661 3
a663 3
			SCALE_HS_INIT(&su, (double)strlen(cp));
			bufcat_su(h, "padding-left", &su);
		}
d665 2
a666 29
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
	} else if (MDOC_HEAD == n->type) { 
		if (NULL == n->child && NULL == m->name)
			return(1);

		if (n->child && MDOC_TEXT == n->child->type)
			cp = n->child->string;
		if (NULL == cp || '\0' == *cp)
			cp = m->name;

		SCALE_HS_INIT(&su, (double)strlen(cp));

		bufcat_style(h, "float", "left");
		bufcat_su(h, "min-width", &su);
		SCALE_INVERT(&su);
		bufcat_su(h, "margin-left", &su);

		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);

		if (NULL == n->child)
			print_text(h, m->name);
	} else if (MDOC_BODY == n->type) {
		SCALE_HS_INIT(&su, 2);
		bufcat_su(h, "margin-left", &su);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
	}
d668 7
a794 2

/* ARGSUSED */
d796 1
a796 2
mdoc_it_block_pre(MDOC_ARGS, enum mdoc_list type, int comp,
		struct roffsu *offs, struct roffsu *width)
d798 4
a801 3
	struct htmlpair	 	 tag;
	const struct mdoc_node	*nn;
	struct roffsu		 su;
d803 3
a805 1
	nn = n->parent->parent;
d807 1
a807 1
	/* XXX: see notes in mdoc_it_pre(). */
d809 1
a809 16
	if (LIST_column == type) {
		/* Don't width-pad on the left. */
		SCALE_HS_INIT(width, 0);
		/* Also disallow non-compact. */
		comp = 1;
	}
	if (LIST_diag == type)
		/* Mandate non-compact with empty prior. */
		if (n->prev && NULL == n->prev->body->child)
			comp = 1;

	bufcat_style(h, "clear", "both");
	if (offs->scale > 0)
		bufcat_su(h, "margin-left", offs);
	if (width->scale > 0)
		bufcat_su(h, "padding-left", width);
d811 2
a812 1
	PAIR_STYLE_INIT(&tag, h);
d814 80
a893 8
	/* Mandate compact following `Ss' and `Sh' starts. */

	for (nn = n; nn && ! comp; nn = nn->parent) {
		if (MDOC_BLOCK != nn->type)
			continue;
		if (MDOC_Ss == nn->tok || MDOC_Sh == nn->tok)
			comp = 1;
		if (nn->prev)
d895 1
a897 7
	if ( ! comp) {
		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "padding-top", &su);
	}

	PAIR_STYLE_INIT(&tag, h);
	print_otag(h, TAG_DIV, 1, &tag);
a900 1

d903 1
a903 1
mdoc_it_body_pre(MDOC_ARGS, enum mdoc_list type, struct roffsu *width)
d905 2
a906 1
	struct htmlpair	 tag;
d909 4
a912 23
	switch (type) {
	case (LIST_item):
		/* FALLTHROUGH */
	case (LIST_ohang):
		/* FALLTHROUGH */
	case (LIST_column):
		bufcat_su(h, "min-width", width);
		bufcat_style(h, "clear", "none");
		if (n->next)
			bufcat_style(h, "float", "left");
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
		break;
	default:
		/* 
		 * XXX: this tricks CSS into aligning the bodies with
		 * the right-padding in the head. 
		 */
		SCALE_HS_INIT(&su, 2);
		bufcat_su(h, "margin-left", &su);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
		break;
d915 3
a917 2
	return(1);
}
d919 6
d926 10
a935 7
/* ARGSUSED */
static int
mdoc_it_head_pre(MDOC_ARGS, enum mdoc_list type, struct roffsu *width)
{
	struct htmlpair	 tag;
	struct ord	*ord;
	char		 nbuf[BUFSIZ];
a936 2
	switch (type) {
	case (LIST_item):
a937 18
	case (LIST_ohang):
		print_otag(h, TAG_DIV, 0, &tag);
		return(1);
	case (LIST_column):
		break;
	default:
		bufcat_su(h, "min-width", width);
		SCALE_INVERT(width);
		bufcat_su(h, "margin-left", width);
		if (n->next && n->next->child)
			bufcat_style(h, "float", "left");

		/* XXX: buffer if we run into body. */
		SCALE_HS_INIT(width, 1);
		bufcat_su(h, "margin-right", width);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
		break;
d940 4
a943 24
	switch (type) {
	case (LIST_diag):
		PAIR_CLASS_INIT(&tag, "diag");
		print_otag(h, TAG_SPAN, 1, &tag);
		break;
	case (LIST_enum):
		ord = h->ords.head;
		assert(ord);
		nbuf[BUFSIZ - 1] = 0;
		(void)snprintf(nbuf, BUFSIZ - 1, "%d.", ord->pos++);
		print_text(h, nbuf);
		return(0);
	case (LIST_dash):
		print_text(h, "\\(en");
		return(0);
	case (LIST_hyphen):
		print_text(h, "\\(hy");
		return(0);
	case (LIST_bullet):
		print_text(h, "\\(bu");
		return(0);
	default:
		break;
	}
d945 6
a950 2
	return(1);
}
d952 1
d954 6
a959 17
static int
mdoc_it_pre(MDOC_ARGS)
{
	int			 i, comp;
	const struct mdoc_node	*bl, *nn;
	struct roffsu		 width, offs;
	enum mdoc_list		 type;

	/* 
	 * XXX: be very careful in changing anything, here.  Lists in
	 * mandoc have many peculiarities; furthermore, they don't
	 * translate well into HTML and require a bit of mangling.
	 */

	bl = n->parent->parent;
	if (MDOC_BLOCK != n->type)
		bl = bl->parent;
d961 2
a962 11
	SCALE_HS_INIT(&offs, 0);

	assert(bl->data.Bl);
	type = bl->data.Bl->type;
	comp = bl->data.Bl->comp;

	if (bl->data.Bl->offs)
		a2offs(bl->data.Bl->offs, &offs);

	switch (type) {
	case (LIST_enum):
d964 1
a964 1
	case (LIST_dash):
d966 1
a966 1
	case (LIST_hyphen):
d968 2
a969 2
	case (LIST_bullet):
		SCALE_HS_INIT(&width, 2);
d971 2
a972 2
	default:
		SCALE_HS_INIT(&width, INDENT);
d974 3
a976 9
	}

	if (bl->data.Bl->width)
		a2width(bl->data.Bl->width, &width);

	/* Override width in some cases. */

	switch (type) {
	case (LIST_ohang):
d978 1
a978 1
	case (LIST_item):
d980 1
a980 1
	case (LIST_inset):
d982 5
a986 2
	case (LIST_diag):
		SCALE_HS_INIT(&width, 0);
d989 2
a990 3
		if (0 == width.scale)
			SCALE_HS_INIT(&width, INDENT);
		break;
a992 41
	if (LIST_column == type && MDOC_BODY == n->type) {
		nn = n->parent->child;
		for (i = 0; nn && nn != n; nn = nn->next)
			if (MDOC_BODY == nn->type)
				i++;
		if (i < (int)bl->data.Bl->ncols)
			a2width(bl->data.Bl->cols[i], &width);
	}

	if (MDOC_HEAD == n->type)
		return(mdoc_it_head_pre(m, n, h, type, &width));
	else if (MDOC_BODY == n->type)
		return(mdoc_it_body_pre(m, n, h, type, &width));

	return(mdoc_it_block_pre(m, n, h, type, comp, &offs, &width));
}


/* ARGSUSED */
static int
mdoc_bl_pre(MDOC_ARGS)
{
	struct ord	*ord;

	if (MDOC_HEAD == n->type)
		return(0);
	if (MDOC_BLOCK != n->type)
		return(1);
	assert(n->data.Bl);
	if (LIST_enum != n->data.Bl->type)
		return(1);

	ord = malloc(sizeof(struct ord));
	if (NULL == ord) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
	ord->cookie = n;
	ord->pos = 1;
	ord->next = h->ords.head;
	h->ords.head = ord;
a995 19

/* ARGSUSED */
static void
mdoc_bl_post(MDOC_ARGS)
{
	struct ord	*ord;

	if (MDOC_BLOCK != n->type)
		return;
	if (LIST_enum != n->data.Bl->type)
		return;

	ord = h->ords.head;
	assert(ord);
	h->ords.head = ord->next;
	free(ord);
}


d1004 3
d1057 7
a1063 1
	/* FIXME: D1 shouldn't be literal. */
d1065 6
a1070 5
	SCALE_VS_INIT(&su, INDENT - 2);
	bufcat_su(h, "margin-left", &su);
	PAIR_CLASS_INIT(&tag[0], "lit");
	PAIR_STYLE_INIT(&tag[1], h);
	print_otag(h, TAG_DIV, 2, tag);
a1109 11
	SCALE_VS_INIT(&su, 0);

	assert(n->data.Bd);
	if (n->data.Bd->offs)
		a2offs(n->data.Bd->offs, &su);

	comp = n->data.Bd->comp;

	/* FIXME: -centered, etc. formatting. */
	/* FIXME: does not respect -offset ??? */

d1111 1
a1111 1
		bufcat_su(h, "margin-left", &su);
d1120 2
a1121 9
		if (comp) {
			PAIR_STYLE_INIT(&tag[0], h);
			print_otag(h, TAG_DIV, 1, tag);
			return(1);
		}
		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "margin-top", &su);
		PAIR_STYLE_INIT(&tag[0], h);
		print_otag(h, TAG_DIV, 1, tag);
d1125 7
d1133 3
a1135 1
			DISP_literal != n->data.Bd->type)
d1137 1
d1139 2
a1140 4
	PAIR_CLASS_INIT(&tag[0], "lit");
	bufcat_style(h, "white-space", "pre");
	PAIR_STYLE_INIT(&tag[1], h);
	print_otag(h, TAG_DIV, 2, tag);
d1172 3
a1174 1
		print_text(h, "\n");
d1457 9
d1471 1
a1471 1
	int		 len;
a1472 1
	struct roffsu	 su;
d1474 7
a1480 17
	switch (n->tok) {
	case (MDOC_sp):
		/* FIXME: can this have a scaling indicator? */
		len = n->child ? atoi(n->child->string) : 1;
		break;
	case (MDOC_br):
		len = 0;
		break;
	default:
		assert(n->parent);
		if ((NULL == n->next || NULL == n->prev) &&
				(MDOC_Ss == n->parent->tok ||
				 MDOC_Sh == n->parent->tok))
			return(0);
		len = 1;
		break;
	}
a1481 1
	SCALE_VS_INIT(&su, len);
d1485 1
a1492 1

d1643 3
a1645 1
	print_otag(h, TAG_DIV, 0, NULL);
d1781 2
a1782 4
	if (n->prev && SEC_SEE_ALSO == n->sec) {
		print_otag(h, TAG_BR, 0, NULL);
		print_otag(h, TAG_BR, 0, NULL);
	} 
d1841 3
a1843 2
	if (SEC_LIBRARY == n->sec && MDOC_LINE & n->flags)
		print_otag(h, TAG_DIV, 0, NULL);
@


1.38
log
@Merge mdoc_action.c into mdoc_validate.c, because having two places to do
basically the same things just causes code duplication and confusion.
Work by kristaps@@, including a few bugfixes he found during the merge,
and reapplying OpenBSD changes on top.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.37 2010/10/23 23:30:41 schwarze Exp $ */
d1331 4
@


1.37
log
@let .Bsx print just "BSD/OS" like in modern groff
from Ulrich Spoerlein <uqs at spoerlein dot net>
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.36 2010/10/23 16:08:36 schwarze Exp $ */
d1676 1
a1676 1
	if (NULL == nn->next) 
@


1.36
log
@.Sm no longer produces a linebreak when used in .Bd
also avoid an extra space after the opening bracket in .Op in -Thtml
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.35 2010/10/16 13:38:29 schwarze Exp $ */
d844 1
a844 1
		pp = "BSDI BSD/OS";
@


1.35
log
@Support tbl(1) code embedded into mdoc(7) input files.
Very similar to what i have done in man(7) yesterday.
Allows to build cpu(4) on HPPA, wi(4), and phantasia(6).
Now we are able to build all tbl code in base.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.34 2010/10/01 21:38:26 schwarze Exp $ */
d1324 2
d1606 10
a1615 1
		/* FIXME: no p->col to check... */
d2168 1
@


1.34
log
@* need a space before .No even if it starts with a closing delimiter
* slightly simplify .Pf *_IGNDELIM code, and share part of it with .No
* do not let opening delimiters fall out of the front of .Ns (from kristaps@@)
This fixes a few spacing issues in csh(1) and ksh(1).
OK kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.33 2010/09/27 21:25:28 schwarze Exp $ */
d248 2
@


1.33
log
@Merge the last bits of 1.10.6 (released today), most were already in:
* ignore double-.Pp
* ignore .Pp before .Bd and .Bl (unless -compact in specified)
* avoid double blank line upon .Pp, .br and friends in literal context
* cast enums to int when passing them to exit(3) to please lint(1)
While merging, fix a regression introduced by kristaps@@:
Outside literal mode, double blank lines must both be printed.
To achieve this again after kristaps@@ improvements in 1.10.6,
treat such blank lines as .sp (instead of .Pp as in 1.10.5)
and drop .Pp before .sp just like dropping .Pp before .Pp.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.32 2010/09/26 18:55:22 schwarze Exp $ */
d90 1
a108 1
static	int		  mdoc_pf_pre(MDOC_ARGS);
d198 1
a198 1
	{NULL, NULL}, /* No */
d203 1
a203 1
	{mdoc_pf_pre, mdoc_pf_post}, /* Pf */
d1910 1
a1910 1
mdoc_pf_pre(MDOC_ARGS)
a1922 1
	h->flags &= ~HTML_IGNDELIM;
@


1.32
log
@consolidate all enclosure opening and closing functions
to help code comprehension and reduce code size
also remove redundant TERMP_NOSPACE here and there
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.31 2010/09/26 18:23:54 schwarze Exp $ */
d1315 20
@


1.31
log
@no punctuation after .%* outside .Rs
in .Rs, mark full stops after .%* as end of a sentence
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.30 2010/09/20 20:02:27 schwarze Exp $ */
a65 2
static	void		  mdoc_aq_post(MDOC_ARGS);
static	int		  mdoc_aq_pre(MDOC_ARGS);
a72 4
static	void		  mdoc_bq_post(MDOC_ARGS);
static	int		  mdoc_bq_pre(MDOC_ARGS);
static	void		  mdoc_brq_post(MDOC_ARGS);
static	int		  mdoc_brq_pre(MDOC_ARGS);
a76 2
static	void		  mdoc_dq_post(MDOC_ARGS);
static	int		  mdoc_dq_pre(MDOC_ARGS);
a105 2
static	void		  mdoc_op_post(MDOC_ARGS);
static	int		  mdoc_op_pre(MDOC_ARGS);
d109 2
a110 2
static	void		  mdoc_pq_post(MDOC_ARGS);
static	int		  mdoc_pq_pre(MDOC_ARGS);
a115 2
static	void		  mdoc_sq_post(MDOC_ARGS);
static	int		  mdoc_sq_pre(MDOC_ARGS);
d159 1
a159 1
	{mdoc_op_pre, mdoc_op_post}, /* Op */
d179 2
a180 2
	{mdoc_aq_pre, mdoc_aq_post}, /* Ao */
	{mdoc_aq_pre, mdoc_aq_post}, /* Aq */
d184 2
a185 2
	{mdoc_bq_pre, mdoc_bq_post}, /* Bo */
	{mdoc_bq_pre, mdoc_bq_post}, /* Bq */
d190 2
a191 2
	{mdoc_dq_pre, mdoc_dq_post}, /* Do */
	{mdoc_dq_pre, mdoc_dq_post}, /* Dq */
d204 2
a205 2
	{mdoc_pq_pre, mdoc_pq_post}, /* Po */
	{mdoc_pq_pre, mdoc_pq_post}, /* Pq */
d207 3
a209 3
	{mdoc_sq_pre, mdoc_sq_post}, /* Ql */
	{mdoc_dq_pre, mdoc_dq_post}, /* Qo */
	{mdoc_dq_pre, mdoc_dq_post}, /* Qq */
d213 2
a214 2
	{mdoc_sq_pre, mdoc_sq_post}, /* So */
	{mdoc_sq_pre, mdoc_sq_post}, /* Sq */
d224 1
a224 1
	{mdoc_op_pre, mdoc_op_post}, /* Oo */
d236 2
a237 2
	{mdoc_brq_pre, mdoc_brq_post}, /* Brq */ 
	{mdoc_brq_pre, mdoc_brq_post}, /* Bro */ 
a702 31
/* ARGSUSED */
static int
mdoc_op_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	if (MDOC_BODY != n->type)
		return(1);

	/* XXX: this tag in theory can contain block elements. */

	print_text(h, "\\(lB");
	h->flags |= HTML_NOSPACE;
	PAIR_CLASS_INIT(&tag, "opt");
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static void
mdoc_op_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type) 
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(rB");
}


d1139 1
a1139 1
		exit(MANDOCLEVEL_SYSERR);
a1204 74
mdoc_dq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\(lq");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_dq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(rq");
}


/* ARGSUSED */
static int
mdoc_pq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\&(");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_pq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	print_text(h, ")");
}


/* ARGSUSED */
static int
mdoc_sq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\(oq");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_sq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(aq");
}


/* ARGSUSED */
static int
a1260 25
mdoc_aq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\(la");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_aq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(ra");
}


/* ARGSUSED */
static int
a1631 25
mdoc_brq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\(lC");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_brq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(rC");
}


/* ARGSUSED */
static int
a1713 1
	h->flags |= HTML_NOSPACE;
a1714 1
	h->flags |= HTML_NOSPACE;
a1828 25
mdoc_bq_pre(MDOC_ARGS)
{
	
	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\(lB");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_bq_post(MDOC_ARGS)
{
	
	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(rB");
}


/* ARGSUSED */
static int
d2105 123
@


1.30
log
@Format multiple authors (.%A) in the same way as groff:
Two authors with "and", but without a comma.
Three or more with commata, and an "and" before the last one.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.29 2010/08/20 00:53:35 schwarze Exp $ */
a2106 1
	struct roffsu	 su;
d2112 3
a2114 5
		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "margin-top", &su);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
	}
d2262 3
a2264 1
	h->flags |= HTML_NOSPACE;
@


1.29
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.28 2010/08/07 17:26:11 schwarze Exp $ */
d2193 3
d2248 1
d2257 5
@


1.28
log
@In -Thtml output, preserve blank lines at the end of .Bd -literal.
Patch from kristaps@@, analoguous to mdoc_term.c rev. 1.100.
With permission from deraadt@@ to still fix bugs in mandoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.27 2010/07/31 21:43:07 schwarze Exp $ */
d1182 1
a1182 1
		exit(EXIT_FAILURE);
@


1.27
log
@Merge bsd.lv version 1.10.5: last larger batch of bug fixes before release.
NOT including Kristaps' .Bd -literal changes which cause regressions.
Features:
* -Tpdf now fully working
Bugfixes:
* proper handling of quoted strings by .ds in roff(7)
* allow empty .Dd
* make .Sm start no-spacing after the first output word
* underline .Ad
* minor fixes in -Thtml
and some optimisations in terminal output.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.26 2010/07/25 18:05:54 schwarze Exp $ */
a1455 4
		if (nn->prev && nn->prev->line < nn->line) {
			print_text(h, "\n");
			h->flags |= HTML_NOSPACE;
		}
d1457 4
@


1.26
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.25 2010/07/13 01:09:13 schwarze Exp $ */
d1456 4
a1459 1
		h->flags |= HTML_NOSPACE;
a1460 6
		if (NULL == nn->next)
			continue;
		if (nn->prev && nn->prev->line < nn->line)
			print_text(h, "\n");
		else if (NULL == nn->prev)
			print_text(h, "\n");
@


1.25
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.24 2010/06/29 17:10:29 schwarze Exp $ */
d124 1
d209 1
a209 1
	{mdoc_ms_pre, NULL}, /* Ms */ /* FIXME: convert to symbol? */
d227 1
a227 1
	{NULL, NULL}, /* Sm */ /* FIXME - no idea. */
d1722 17
d1754 5
@


1.24
log
@Support for badly nested blocks, written around the time of
the Rostock mandoc hackathon and tested and polished since,
supporting constructs like:

.Ao Bo    Ac    Bc        (exp breaking exp)
.Aq Bo    eol   Bc        (imp breaking exp)
.Ao Bq    Ac    eol       (exp breaking imp)
.Ao Bo So Bc    Ac  Sc    (double break, inner before outer)
.Ao Bo So Ac    Bc  Sc    (double break, outer before inner)
.Ao Bo    Ac So Bc  Sc    (broken breaker)
.Ao Bo So Bc Do Ac  Sc Dc (broken double breaker)

There are still two known issues which are tricky:

1) Breaking two identical explicit blocks (Ao Bo Bo Ac or Aq Bo Bo eol)
fails outright, triggering a bogus syntax error.
2) Breaking a block by two identical explicit blocks (Ao Ao Bo Ac Ac Bc
or Ao Ao Bq Ac Ac eol) still has a minor rendering error left:
"<ao1 <ao2 [bo ac2> ac1> bc]>" should not have the final ">".

We can fix these later in the tree, let's not grow this diff too large.

"get it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.23 2010/06/27 21:54:42 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
a28 1
#include "regs.h"
d71 2
d237 1
a237 1
	{NULL, NULL}, /* Bk */
d437 1
a437 1
		if (mdocs[n->tok].pre && !n->end)
d442 12
d465 1
a465 1
		if (mdocs[n->tok].post && !n->end)
d748 51
a798 1
	struct htmlpair	tag;
d800 2
a801 2
	if (NULL == n->child && NULL == m->name)
		return(1);
d803 8
a810 1
	synopsis_pre(h, n);
a811 4
	PAIR_CLASS_INIT(&tag, "name");
	print_otag(h, TAG_SPAN, 1, &tag);
	if (NULL == n->child)
		print_text(h, m->name);
d1086 1
a1086 1
	int			 i, wp, comp;
d1103 3
a1105 2
	type = bl->data.Bl.type;
	comp = bl->data.Bl.comp;
d1107 2
a1108 2
	if (bl->data.Bl.offs)
		a2offs(bl->data.Bl.offs, &offs);
d1125 2
a1126 12
	if (bl->data.Bl.width)
		a2width(bl->data.Bl.width, &width);

	wp = -1;
	for (i = 0; bl->args && i < (int)bl->args->argc; i++) 
		switch (bl->args->argv[i].arg) {
		case (MDOC_Column):
			wp = i; /* Save for later. */
			break;
		default:
			break;
		}
d1151 2
a1152 2
		if (i < (int)bl->args->argv[wp].sz)
			a2width(bl->args->argv[wp].value[i], &width);
d1174 2
a1175 1
	if (LIST_enum != n->data.Bl.type)
d1199 1
a1199 1
	if (LIST_enum != n->data.Bl.type)
d1414 3
a1416 2
	if (n->data.Bd.offs)
		a2offs(n->data.Bd.offs, &su);
d1418 1
a1418 1
	comp = n->data.Bd.comp;
d1445 2
a1446 2
	if (DISP_unfilled != n->data.Bd.type && 
			DISP_literal != n->data.Bd.type)
a2016 1
	int		 i;
d2022 1
a2022 1
	else if (MDOC_BLOCK != n->type)
d2025 1
a2025 1
	PAIR_CLASS_INIT(&tag[0], "lit");
d2027 8
a2034 25
	if (n->head->child) {
		if ( ! strcmp("Em", n->head->child->string))
			PAIR_CLASS_INIT(&tag[0], "emph");
		else if ( ! strcmp("Sy", n->head->child->string))
			PAIR_CLASS_INIT(&tag[0], "symb");
		else if ( ! strcmp("Li", n->head->child->string))
			PAIR_CLASS_INIT(&tag[0], "lit");
	} else {
		for (i = 0; n->args && i < (int)n->args->argc; i++) 
			switch (n->args->argv[i].arg) {
			case (MDOC_Symbolic):
				PAIR_CLASS_INIT(&tag[0], "symb");
				break;
			case (MDOC_Literal):
				PAIR_CLASS_INIT(&tag[0], "lit");
				break;
			case (MDOC_Emphasis):
				PAIR_CLASS_INIT(&tag[0], "emph");
				break;
			default:
				break;
			}
	}

	/* FIXME: div's have spaces stripped--we want them. */
d2036 4
d2042 2
a2043 1
	bufcat_su(h, "margin-right", &su);
d2238 32
@


1.23
log
@Full .nr nS support, unbreaking the kernel manuals.

Kristaps coded this from scratch after reading my .nr patch;
it is simpler and more powerful.

Registers live in struct regset in regs.h, struct man and struct mdoc
contain pointers to it.  The nS register is cleared when parsing .Sh.
Frontends respect the MDOC_SYNPRETTY flag set in mdoc node_alloc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.22 2010/06/26 17:56:43 schwarze Exp $ */
d436 1
a436 1
		if (mdocs[n->tok].pre)
d452 1
a452 1
		if (mdocs[n->tok].post)
@


1.22
log
@merge release 1.10.2
* bug fixes:
- interaction of ASCII_HYPH with special chars (found by Ulrich Spoerlein)
- handling of roff conditionals (found by Ulrich Spoerlein)
- .Bd -offset will no more default to 6n
* maintenance:
- more caching of .Bd and .Bl arguments for efficiency
- deconstify man(7) validation routines
- add FreeBSD library names (provided by Ulrich Spoerlein)
* start PostScript font-switching
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.21 2010/06/08 00:11:47 schwarze Exp $ */
d29 1
d303 1
a303 1
	if (NULL == n->prev || SEC_SYNOPSIS != n->sec)
d1613 1
a1613 1
	if (SEC_SYNOPSIS == n->sec) {
d1643 1
a1643 1
		if (SEC_SYNOPSIS == n->sec)
d1653 1
a1653 1
	if (SEC_SYNOPSIS == n->sec)
d1823 1
a1823 1
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags)
@


1.21
log
@Merge more bits that will be going into 1.10.1:

Clean up vertical spacing in the SYNOPSIS, making the code much more
systematic; this doesn't solve all SYNOPSIS problems yet, in particular
not those related to keeps, indentation and the low-level .nr roff
instruction, but it's a nice step forward and i couldn't find relevant
regressions.  (from kristaps)

Besides,
* make the output width configurable (default: -Owidth=80) (kristaps)
* use mmap with MAP_SHARED (from Joerg Sonnenberger)
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.20 2010/06/06 20:30:08 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d1034 1
a1034 1
	type = bl->data.list;
d1036 2
a1037 1
	/* Set default width and offset. */
d1039 2
a1040 1
	SCALE_HS_INIT(&offs, 0);
d1057 2
a1058 1
	/* Get width, offset, and compact arguments. */
d1061 1
a1061 1
	for (comp = i = 0; bl->args && i < (int)bl->args->argc; i++) 
a1065 9
		case (MDOC_Width):
			a2width(bl->args->argv[i].value[0], &width);
			break;
		case (MDOC_Offset):
			a2offs(bl->args->argv[i].value[0], &offs);
			break;
		case (MDOC_Compact):
			comp = 1;
			break;
d1116 1
a1116 1
	if (LIST_enum != n->data.list)
d1140 1
a1140 1
	if (LIST_enum != n->data.list)
d1346 2
a1347 2
	int		 	 type, comp, i;
	const struct mdoc_node	*bl, *nn;
d1350 1
a1350 3
	if (MDOC_BLOCK == n->type)
		bl = n;
	else if (MDOC_HEAD == n->type)
a1351 2
	else
		bl = n->parent;
d1355 4
a1358 23
	type = comp = 0;
	for (i = 0; bl->args && i < (int)bl->args->argc; i++) 
		switch (bl->args->argv[i].arg) {
		case (MDOC_Offset):
			a2offs(bl->args->argv[i].value[0], &su);
			break;
		case (MDOC_Compact):
			comp = 1;
			break;
		case (MDOC_Centred):
			/* FALLTHROUGH */
		case (MDOC_Ragged):
			/* FALLTHROUGH */
		case (MDOC_Filled):
			/* FALLTHROUGH */
		case (MDOC_Unfilled):
			/* FALLTHROUGH */
		case (MDOC_Literal):
			type = bl->args->argv[i].arg;
			break;
		default:
			break;
		}
d1385 2
a1386 1
	if (MDOC_Unfilled != type && MDOC_Literal != type)
@


1.20
log
@Merge bsd.lv version 1.10.1 (to be released soon).

The main step forward is that this now has *much* better .Bl -column
support, now supporting many manuals that previously errored out
without producing any output.

Other fixes include:
* do not die from multiple list types, use the first and warn
* in .Bl without a type, default to -item
* various tweaks to .Dt
* fix .In, .Fd, .Ft, .Fn and .Fo formatting
* some documentation fixes and additions
* and fix a couple of bugs reported by Ulrich Spoerlein:
* better support for roff block-end "\}" without a preceding dot
* .In must not break the line outside SYNOPSIS
* spelling in some error messages

While merging, fix one regression in .In spacing
that needs to go to bsd.lv, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.19 2010/05/24 12:33:06 schwarze Exp $ */
d52 2
a84 1
static	void		  mdoc_fd_post(MDOC_ARGS);
d159 1
a159 1
	{mdoc_fd_pre, mdoc_fd_post}, /* Fd */ 
d294 49
d739 1
a739 6
	if (SEC_SYNOPSIS == n->sec && 
			n->prev && MDOC_LINE & n->flags) {
		bufcat_style(h, "clear", "both");
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_BR, 1, &tag);
	}
a744 1

d1481 1
a1481 1
	print_otag(h, TAG_DIV, 0, NULL);
a1553 9
static void
mdoc_fd_post(MDOC_ARGS)
{

	print_otag(h, TAG_BR, 0, NULL);
}


/* ARGSUSED */
d1559 2
a1571 1
	struct roffsu	 su;
d1573 2
a1574 9
	if (SEC_SYNOPSIS == n->sec && MDOC_BLOCK == n->type) {
		if (n->next && MDOC_Vt != n->next->tok) {
			SCALE_VS_INIT(&su, 1);
			bufcat_su(h, "margin-bottom", &su);
			PAIR_STYLE_INIT(&tag, h);
			print_otag(h, TAG_DIV, 1, &tag);
		} else
			print_otag(h, TAG_DIV, 0, NULL);
		
d1576 2
d1593 1
a1593 3
	if (SEC_SYNOPSIS == n->sec && n->prev)
		print_otag(h, TAG_BR, 0, NULL);

a1609 1
	struct roffsu		 su;
d1611 1
a1611 13
	/* NB: MDOC_LINE has no effect on this macro! */
	if (SEC_SYNOPSIS == n->sec) {
		SCALE_HS_INIT(&su, INDENT);
		bufcat_su(h, "margin-left", &su);
		su.scale = -su.scale;
		bufcat_su(h, "text-indent", &su);
		if (n->prev && MDOC_Ft != n->prev->tok) {
			SCALE_VS_INIT(&su, 1);
			bufcat_su(h, "margin-top", &su);
		} 
		PAIR_STYLE_INIT(&tag[0], h);
		print_otag(h, TAG_DIV, 1, tag);
	}
a1796 1
	struct roffsu	 su;
d1805 1
a1805 10
		if (SEC_SYNOPSIS != n->sec)
			return(1);
		if (NULL == n->prev || MDOC_Ft == n->prev->tok) {
			print_otag(h, TAG_DIV, 0, NULL);
			return(1);
		}
		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "margin-top", &su);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
d1826 1
d1845 2
a1871 3

	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags) 
		print_otag(h, TAG_BR, 0, NULL);
@


1.19
log
@Fix segfault in mixing old enum types for -Thtml -mdoc; from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.18 2010/05/24 00:00:10 schwarze Exp $ */
d83 1
d100 2
a101 1
static	int		  mdoc_it_body_pre(MDOC_ARGS, enum mdoc_list);
d158 1
a158 1
	{mdoc_fd_pre, NULL}, /* Fd */ 
d255 1
a831 1
	assert(nn->args);
d878 1
a878 1
mdoc_it_body_pre(MDOC_ARGS, enum mdoc_list type)
d889 6
a926 6
		bufcat_su(h, "min-width", width);
		bufcat_style(h, "clear", "none");
		if (n->next && MDOC_HEAD == n->next->type)
			bufcat_style(h, "float", "left");
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
d1013 2
a1014 1
	for (wp = -1, comp = i = 0; i < (int)bl->args->argc; i++) 
d1050 1
a1050 11
	/* Flip to body/block processing. */

	if (MDOC_BODY == n->type)
		return(mdoc_it_body_pre(m, n, h, type));
	if (MDOC_BLOCK == n->type)
		return(mdoc_it_block_pre(m, n, h, type, comp,
					&offs, &width));

	/* Override column widths. */

	if (LIST_column == type) {
d1052 3
a1054 2
		for (i = 0; nn && nn != n; nn = nn->next, i++)
			/* Counter... */ ;
d1059 6
a1064 1
	return(mdoc_it_head_pre(m, n, h, type, &width));
d1246 1
a1246 1
	SCALE_VS_INIT(&su, INDENT - 1);
d1322 1
a1322 1
	for (i = 0; i < (int)bl->args->argc; i++) 
d1510 9
a1522 11
	struct roffsu	 su;

	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags) {
		if (n->next && MDOC_Fd != n->next->tok) {
			SCALE_VS_INIT(&su, 1);
			bufcat_su(h, "margin-bottom", &su);
			PAIR_STYLE_INIT(&tag, h);
			print_otag(h, TAG_DIV, 1, &tag);
		} else
			print_otag(h, TAG_DIV, 0, NULL);
	}
d1562 2
a1563 2
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags)
		print_otag(h, TAG_DIV, 0, NULL);
d1583 2
a1584 1
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags) {
d1589 1
a1589 1
		if (n->next) {
d1591 2
a1592 2
			bufcat_su(h, "margin-bottom", &su);
		}
d1780 3
a1782 2
	struct htmlpair	tag;
	struct roffsu	su;
d1789 7
a1795 1
	} else if (MDOC_BLOCK == n->type && n->next) {
d1797 1
a1797 1
		bufcat_su(h, "margin-bottom", &su);
d1803 5
d1809 4
a1812 2
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
a1836 13
	struct roffsu		 su;

	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags) {
		if (n->next && MDOC_In != n->next->tok) {
			SCALE_VS_INIT(&su, 1);
			bufcat_su(h, "margin-bottom", &su);
			PAIR_STYLE_INIT(&tag[0], h);
			print_otag(h, TAG_DIV, 1, tag);
		} else
			print_otag(h, TAG_DIV, 0, NULL);
	}

	/* FIXME: there's a buffer bug in here somewhere. */
d1841 1
a1841 1
	if (SEC_SYNOPSIS == n->sec)
a1846 2
	/* XXX -- see warning in termp_in_post(). */

d1864 3
d1998 1
a1998 2
		assert(n->args);
		for (i = 0; i < (int)n->args->argc; i++) 
@


1.18
log
@Increase performance by saving the list type in struct mdoc_node.
This will eventually be used so that mdoc_macro can know whether to
dump list line arguments into the body (`Bl -column' overflowing).
Remove a2list() and arg_listtype() because of this.

From kristaps@@.

While merging, fix a regression in mdoc_term.c, print_bvspace():
The bsd.lv version of this broke vertical spacing in .Bl -column.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.17 2010/05/23 22:45:00 schwarze Exp $ */
d1079 1
a1079 1
	if (MDOC_Enum != n->data.list)
d1103 1
a1103 1
	if (MDOC_Enum != n->data.list)
@


1.17
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.16 2010/05/23 20:05:43 schwarze Exp $ */
a55 2
static	int		  a2list(const struct mdoc_node *);

d95 3
a97 3
static	int		  mdoc_it_block_pre(MDOC_ARGS, int, int,
				struct roffsu *, struct roffsu *);
static	int		  mdoc_it_head_pre(MDOC_ARGS, int, 
d99 1
a99 1
static	int		  mdoc_it_body_pre(MDOC_ARGS, int);
a273 44
 * Return the list type for `Bl', e.g., `Bl -column' returns 
 * MDOC_Column.  This can ONLY be run for lists; it will abort() if no
 * list type is found. 
 */
static int
a2list(const struct mdoc_node *n)
{
	int		 i;

	assert(n->args);
	for (i = 0; i < (int)n->args->argc; i++) 
		switch (n->args->argv[i].arg) {
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Item):
			/* FALLTHROUGH */
		case (MDOC_Column):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			return(n->args->argv[i].arg);
		default:
			break;
		}

	abort();
	/* NOTREACHED */
}


/*
d821 1
a821 1
mdoc_it_block_pre(MDOC_ARGS, int type, int comp,
d833 1
a833 1
	if (MDOC_Column == type) {
d839 1
a839 1
	if (MDOC_Diag == type)
d876 1
a876 1
mdoc_it_body_pre(MDOC_ARGS, int type)
d882 1
a882 1
	case (MDOC_Item):
d884 1
a884 1
	case (MDOC_Ohang):
d886 1
a886 1
	case (MDOC_Column):
d906 1
a906 1
mdoc_it_head_pre(MDOC_ARGS, int type, struct roffsu *width)
d913 1
a913 1
	case (MDOC_Item):
d915 1
a915 1
	case (MDOC_Ohang):
d918 1
a918 1
	case (MDOC_Column):
d942 1
a942 1
	case (MDOC_Diag):
d946 1
a946 1
	case (MDOC_Enum):
d953 1
a953 1
	case (MDOC_Dash):
d956 1
a956 1
	case (MDOC_Hyphen):
d959 1
a959 1
	case (MDOC_Bullet):
d973 1
a973 1
	int			 i, type, wp, comp;
d976 1
d988 1
a988 1
	type = a2list(bl);
d995 1
a995 1
	case (MDOC_Enum):
d997 1
a997 1
	case (MDOC_Dash):
d999 1
a999 1
	case (MDOC_Hyphen):
d1001 1
a1001 1
	case (MDOC_Bullet):
d1032 1
a1032 1
	case (MDOC_Ohang):
d1034 1
a1034 1
	case (MDOC_Item):
d1036 1
a1036 1
	case (MDOC_Inset):
d1038 1
a1038 1
	case (MDOC_Diag):
d1057 1
a1057 1
	if (MDOC_Column == type) {
d1079 1
a1079 1
	if (MDOC_Enum != a2list(n))
d1103 1
a1103 1
	if (MDOC_Enum != a2list(n))
@


1.16
log
@Small fix for `D1' and `Bd' in -Thtml; from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.15 2010/05/15 18:25:51 schwarze Exp $ */
d26 1
d729 3
d1184 1
a1184 1
	if (n->child->next)
d1954 1
a1954 1
	if (n->child->next)
@


1.15
log
@allow non-numeric manual sections in -mdoc;
while here, allow LIBRARY in section 9;
by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.14 2010/05/14 19:52:43 schwarze Exp $ */
d1288 1
a1288 1
	SCALE_VS_INIT(&su, INDENT - 2);
d1401 2
a1402 1
			print_otag(h, TAG_DIV, 0, tag);
@


1.14
log
@Integrate kristaps@@' end-of-sentence (EOS) framework
which is simpler and more powerful than mine, and remove mine.

* man(7) now has EOS handling, too
* put EOS detection into its own function in libmandoc
* use node and termp flags to communicate the EOS condition
* no more EOS pseudo-macro
* no more non-printable EOS marker character on the formatter level

This slightly breaks EOS detection after trailing punctuation
in mdoc(7) macros, but that will be restored soon.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.13 2010/05/14 14:47:44 schwarze Exp $ */
d386 1
a386 1
	buffmt(h, "%s(%d)", m->title, m->msec);
d508 1
a508 1
			"%s(%d)", m->title, m->msec);
@


1.13
log
@Merge 1.9.25, keeping local patches;
this does not merge kristaps' end-of-sentences handling yet,
i will check that separately.  This one includes:
* handle \*(Ba as a delimiter
* introduce ARGS_PEND for .Bl -column .It end-of-line special casing
* section ordering: expect EXIT STATUS at the right place
* line break fixes in SYNOPSIS
* allow literal contexts to have arbitrary line lengths
* the input file column number can not be used to identify the beginning
  of a line because white space is allowed after the initial '.'
* proper leading spaces in -man -Tascii mode
* do not let Lb break lines in -mdoc -Thtml LIBRARY
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.12 2010/05/08 02:10:09 schwarze Exp $ */
a253 1
	{NULL, NULL}, /* eos */
@


1.12
log
@sync to bsd.lv mdoc_term.c 1.117, mdoc_html.c 1.61:
fixed %T: it now correctly underlines, instead of quoting;
noted by jmc@@, fixed by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.11 2010/04/07 23:15:05 schwarze Exp $ */
d729 2
a730 1
	if (SEC_SYNOPSIS == n->sec && n->prev) {
d1558 1
a1558 1
	if (SEC_SYNOPSIS == n->sec) {
d1606 1
a1606 1
	if (SEC_SYNOPSIS == n->sec)
d1627 1
a1627 1
	if (SEC_SYNOPSIS == n->sec) {
d1868 1
a1868 1
	if (SEC_SYNOPSIS == n->sec) {
d2173 1
a2173 1
	if (SEC_SYNOPSIS == n->sec)
@


1.11
log
@Merge the good parts of 1.9.23,
avoid the bad parts of 1.9.23, and keep local patches.

Input in general:
 * Basic handling of roff-style font escapes \f, \F.
 * Quoted punctuation does not count as punctuation.

mdoc(7) parser:
 * Make .Pf callable; noted by Claus Assmann.
 * Let .Bd and .Bl ignore unknown arguments; noted by deraadt@@.
 * Do not warn when .Er is used outside certain sections.
 * Replace mdoc_node_free[list] by mdoc_node_delete.
 * Replace #define by enum for rew*() return values.

man(7) parser:
 * When .TH is missing, use default section and date.

Output in general:
 * Curly braces do not count as punctuation.
 * No space after .Fl w/o args when a macro follows on the same line.

HTML output:
 * Unify PAIR_*_INIT macros, introduce new PAIR_ID_INIT().
 * Print whitespace after, not before .Vt .Fn .Ft .Fo.

Checked that all manuals in base still build.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.10 2010/04/04 00:00:12 schwarze Exp $ */
a2221 2
		print_text(h, "\\(lq");
		h->flags |= HTML_NOSPACE;
d2250 2
a2252 8
	switch (n->tok) {
	case (MDOC__T):
		print_text(h, "\\(rq");
		h->flags |= HTML_NOSPACE;
		break;
	default:
		break;
	}
@


1.10
log
@Better write 'href="mailto:' instead of 'style="mailto:'.
Diff from Tim van der Molen <tbvdm at xs4all dot nl>, thanks!

ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.9 2010/04/03 17:06:19 schwarze Exp $ */
d199 1
a199 1
	{NULL, NULL}, /* Ec */
d589 2
a590 4
	/* 
	 * TODO: make sure there are no duplicates, as HTML does not
	 * allow for multiple `id' tags of the same name.
	 */
a591 3
	PAIR_CLASS_INIT(&tag[0], "sec-head");
	tag[1].key = ATTR_ID;
	tag[1].val = buf;
d643 2
a644 2
	tag[2].key = ATTR_ID;
	tag[2].val = buf;
a665 2
	/* A blank `Fl' should incur a subsequent space. */

d668 2
d760 1
a760 2
		tag[1].key = ATTR_HREF;
		tag[1].val = h->buf;
d1116 2
a1304 2
	/* FIXME: duplicates? */

d1313 1
a1313 2
	tag[1].key = ATTR_HREF;
	tag[1].val = buf;
d1388 1
d1580 2
a1581 2
	if (MDOC_BLOCK == n->type) {
		if (n->prev && MDOC_Vt != n->prev->tok) {
d1583 1
a1583 1
			bufcat_su(h, "margin-top", &su);
d1588 1
a1588 1

a1603 1
	struct roffsu	 su;
d1605 2
a1606 9
	if (SEC_SYNOPSIS == n->sec) {
		if (n->prev && MDOC_Fo == n->prev->tok) {
			SCALE_VS_INIT(&su, 1);
			bufcat_su(h, "margin-top", &su);
			PAIR_STYLE_INIT(&tag, h);
			print_otag(h, TAG_DIV, 1, &tag);
		} else
			print_otag(h, TAG_DIV, 0, NULL);
	}
d1660 17
d1680 1
a1680 1
		(void)strlcpy(nbuf, sp, BUFSIZ);
d1781 1
a1781 2
	tag[1].key = ATTR_HREF;
	tag[1].val = nn->string;
d1823 1
d1830 5
a1834 1
	} else if (MDOC_BLOCK == n->type)
d1836 1
d1896 2
a1897 2
			tag[i].key = ATTR_HREF;
			tag[i++].val = h->buf;
@


1.9
log
@no need to die from .Xr without arguments, we can just ignore it

ok deraadt@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.8 2010/03/02 00:38:59 schwarze Exp $ */
d1806 1
a1806 1
		PAIR_STYLE_INIT(&tag[1], h);
@


1.8
log
@Proper inter-sentence spacing for mdoc(7).
When a text line or a non-block macro line in the source code ends
in any of ".!?", consider that an end of sentence (EOS).
This makes Jason's rule "new sentence, new line" even more important.
Let the parser detect the EOS and insert a token into the AST.
Let the -Tascii frontend render the EOS token as a double space before
the next word.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.7 2010/02/18 02:11:26 schwarze Exp $ */
d755 3
@


1.7
log
@sync to release 1.9.15:
 * corrected .Vt handling (spotted by Joerg Sonnenberger)
 * corrected .Xr argument handling (based on my patch)
 * removed \\ escape sequence (because it is for low-level roff only)
 * warn about trailing whitespace (suggested by jmc@@)
 * -Txhtml support
 * and some general cleanup and doc improvements
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.6 2010/01/02 02:42:06 schwarze Exp $ */
d254 1
@


1.6
log
@complete the sync to 1.9.15-pre2: mostly minor fixes
 * bugfix: do not restore TERMP flags when leaving lists, just reset them
 * and a few HTML fixes
 * clarity: return width from a2width, not width+2, and adapt to it
 * manual: document .Bl and .Fl
 * portability: no need to escape '%' in macro names
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.5 2009/12/24 02:08:14 schwarze Exp $ */
d265 1
a265 1
	print_gen_doctype(h);
d1582 1
a1582 1
	if (SEC_SYNOPSIS == n->sec) {
d1590 4
a1593 1
	}
@


1.5
log
@sync to 1.9.14: rewrite escape sequence handling:
- new function a2roffdeco
- font modes (\f) only affect the current stack point
- implement scaling (\s)
- implement space suppression (\c)
- implement non-breaking space (\~) in -Tascii
- many manual improvements
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.4 2009/12/23 22:30:17 schwarze Exp $ */
a17 1
#include <sys/param.h>
d38 4
d662 11
a672 2
	if (MDOC_Fl == n->tok) {
		print_text(h, "\\-");
d674 1
a674 1
	}
d1583 1
a1583 1
		if (n->next && MDOC_Vt != n->next->tok) {
d1585 1
a1585 1
			bufcat_su(h, "margin-bottom", &su);
@


1.4
log
@sync to 1.9.13: minor fixes:

correctness/functionality:
 - bugfix: properly ignore lines with only a dot in -man
 - bugfix: .Bl -ohang doesn't allow -width, warn about this
 - improve date string handling by new function mandoc_a2time
 - some HTML improvements
 - significant documentation additions in man.7 and mdoc.7

portability:
 - replace __dead by __attribute__((noreturn))
 - bugfix: correct .Dx rendering
 - some more library names for NetBSD

simplicity:
 - replace hand-rolled putchar(3)-loops by fwrite(3)
 - replace single-character printf(3) by putchar(3)
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.3 2009/12/22 23:58:00 schwarze Exp $ */
d422 1
a422 1
		break;
a438 2
	case (MDOC_TEXT):
		break;
d721 5
a725 6
	if ( ! (HTML_NEWLINE & h->flags))
		if (SEC_SYNOPSIS == n->sec) {
			bufcat_style(h, "clear", "both");
			PAIR_STYLE_INIT(&tag, h);
			print_otag(h, TAG_BR, 1, &tag);
		}
@


1.3
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.2 2009/10/27 21:40:07 schwarze Exp $ */
d808 1
a808 1
		pp = "DragonFlyBSD";
d949 1
a949 1
		/* FALLTHROUGH */
d951 2
a952 1
		return(0);
d1066 2
@


1.2
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.1 2009/10/21 19:13:50 schwarze Exp $ */
a21 1
#include <err.h>
d453 1
a453 1
	struct htmlpair	 tag[2];
d468 3
a470 1
	t = print_otag(h, TAG_TABLE, 2, tag);
d494 1
a494 1
	struct htmlpair	 tag[2];
d514 4
a517 1
	t = print_otag(h, TAG_TABLE, 2, tag);
d553 1
a553 1
	char			 lbuf[BUFSIZ];
d580 1
a580 1
	lbuf[0] = 0;
d582 1
a582 1
		(void)strlcat(lbuf, nn->string, BUFSIZ);
d584 1
a584 1
			(void)strlcat(lbuf, "_", BUFSIZ);
d594 1
a594 1
	tag[1].val = lbuf;
d606 1
a606 1
	char			 lbuf[BUFSIZ];
d633 1
a633 1
	lbuf[0] = 0;
d635 1
a635 1
		(void)strlcat(lbuf, nn->string, BUFSIZ);
d637 1
a637 1
			(void)strlcat(lbuf, "_", BUFSIZ);
d647 1
a647 1
	tag[2].val = lbuf;
d951 1
a951 2
		print_otag(h, TAG_DIV, 0, NULL);
		break;
d1112 4
a1115 2
	if (NULL == ord)
		err(EXIT_FAILURE, "malloc");
d1295 1
a1295 1
	(void)strlcpy(buf, "#", BUFSIZ);
d1297 1
a1297 1
		(void)strlcat(buf, nn->string, BUFSIZ);
d1299 1
a1299 1
			(void)strlcat(buf, "_", BUFSIZ);
d1716 4
a1719 1
	return(1);
d1866 1
@


1.1
log
@sync to 1.9.9, featuring:
 * -Thtml output mode
 * roff scaling units
 * and some minor fixes
for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.35 2009/10/20 05:45:21 kristaps Exp $ */
a18 1
#include <sys/queue.h>
d251 1
d414 1
a414 1
	t = SLIST_FIRST(&h->tags);
a453 1
	struct tm	 tm;
d456 3
a458 1
	char		 b[BUFSIZ];
a465 5
	(void)localtime_r(&m->date, &tm);

	if (0 == strftime(b, BUFSIZ - 1, "%B %e, %Y", &tm))
		err(EXIT_FAILURE, "strftime");

d978 1
a978 1
		ord = SLIST_FIRST(&h->ords);
d1113 2
a1114 1
	SLIST_INSERT_HEAD(&h->ords, ord, entry);
d1130 1
a1130 1
	ord = SLIST_FIRST(&h->ords);
d1132 1
a1132 1
	SLIST_REMOVE_HEAD(&h->ords, entry);
d1755 3
d2148 1
a2148 1
	struct htmlpair	tag;
d2152 1
a2152 1
		PAIR_CLASS_INIT(&tag, "ref-auth");
d2155 1
a2155 1
		PAIR_CLASS_INIT(&tag, "ref-book");
d2158 1
a2158 1
		PAIR_CLASS_INIT(&tag, "ref-city");
d2161 1
a2161 1
		PAIR_CLASS_INIT(&tag, "ref-date");
d2164 1
a2164 1
		PAIR_CLASS_INIT(&tag, "ref-issue");
d2167 1
a2167 1
		PAIR_CLASS_INIT(&tag, "ref-jrnl");
d2170 1
a2170 1
		PAIR_CLASS_INIT(&tag, "ref-num");
d2173 1
a2173 1
		PAIR_CLASS_INIT(&tag, "ref-opt");
d2176 1
a2176 1
		PAIR_CLASS_INIT(&tag, "ref-page");
d2179 1
a2179 1
		PAIR_CLASS_INIT(&tag, "ref-corp");
d2182 1
a2182 1
		PAIR_CLASS_INIT(&tag, "ref-rep");
d2185 1
a2185 1
		PAIR_CLASS_INIT(&tag, "ref-title");
d2189 3
d2193 1
a2193 1
		PAIR_CLASS_INIT(&tag, "ref-vol");
d2200 7
a2206 1
	print_otag(h, TAG_SPAN, 1, &tag);
@

