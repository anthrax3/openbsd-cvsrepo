head	1.42;
access;
symbols
	OPENBSD_6_1:1.39.0.6
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.2
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.33.0.4
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.6
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.4
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.42
date	2017.06.07.17.38.08;	author schwarze;	state Exp;
branches;
next	1.41;
commitid	Lq4DRasN5AQvZkGt;

1.41
date	2017.05.08.15.33.43;	author schwarze;	state Exp;
branches;
next	1.40;
commitid	wam7mxa5wtd9m7Af;

1.40
date	2017.05.07.17.30.58;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	pfMPALNhm77dpGFF;

1.39
date	2016.07.08.22.27.58;	author schwarze;	state Exp;
branches;
next	1.38;
commitid	bqbNrcG3yxfhXOgx;

1.38
date	2015.11.12.21.49.29;	author schwarze;	state Exp;
branches;
next	1.37;
commitid	EO1SO8fBFbRq3xsV;

1.37
date	2015.10.13.22.57.49;	author schwarze;	state Exp;
branches;
next	1.36;
commitid	jXIG8UzKLXm2Z9i6;

1.36
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	Ql2ha5NS80pwfGNT;

1.35
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.34;
commitid	hxQV8O1pNUaef4ir;

1.34
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	191tWtskbsgcpQqV;

1.33
date	2015.07.17.22.35.36;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	Ik50obX3Gy0LFoMQ;

1.32
date	2015.04.04.17.46.58;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	exqqP0KNSHrSyO21;

1.31
date	2015.03.27.21.17.16;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	r1NPkDobCJs0RcWM;

1.30
date	2015.02.16.13.58.32;	author tedu;	state Exp;
branches;
next	1.29;
commitid	sOfyLWIgYOuCcKGM;

1.29
date	2014.12.31.16.50.54;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	d4vqwNunQKF1TkjN;

1.28
date	2014.12.19.17.10.42;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	VKTVyFrMsLBbKLQJ;

1.27
date	2014.11.20.13.55.23;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	qQSbPatDu3BAPGlr;

1.26
date	2014.10.28.18.48.56;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	eWY0jZFHDE9PlMUQ;

1.25
date	2014.10.28.17.35.42;	author schwarze;	state Exp;
branches;
next	1.24;
commitid	pNwmOla3ZQwLgu2f;

1.24
date	2014.10.28.02.43.05;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	vPfTytFn1lozCPsl;

1.23
date	2014.10.26.18.06.28;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	35r4kUpCbAKnK6uq;

1.22
date	2014.10.26.17.11.18;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	d5isKf7CwbLlT0IO;

1.21
date	2014.09.03.05.17.08;	author schwarze;	state Exp;
branches;
next	1.20;
commitid	D4HCUw9YYVx6NSQl;

1.20
date	2014.08.17.22.08.53;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	pXNMg3bfd1ALsv2B;

1.19
date	2014.08.17.22.06.49;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	XpVsbwk7yKTYoY5g;

1.18
date	2014.08.14.22.32.28;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	ZVFJuQBWMBpwyep5;

1.17
date	2014.08.13.22.09.28;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	HYRKgiWZb4BQrCNL;

1.16
date	2014.08.08.16.00.23;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	m0QaUWeqjuHsvBSO;

1.15
date	2014.07.27.21.51.53;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	ctWrUkeEqrWnbzAF;

1.14
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2014.03.30.21.27.59;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.01.14.27.13;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2011.12.05.00.28.12;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.13.13.30.42;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.13.13.05.23;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.01.31.02.36.55;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.26.19.08.00;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.10.22.50.10;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Prepare the terminal driver for filling multiple columns in parallel,
first step: split column data out of the terminal state struct into
a new column state struct and use an array of such column state
structs.  No functional change.
@
text
@/*	$OpenBSD: term_ascii.c,v 1.41 2017/05/08 15:33:43 schwarze Exp $ */
/*
 * Copyright (c) 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2014, 2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <locale.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <wchar.h>

#include "mandoc.h"
#include "mandoc_aux.h"
#include "out.h"
#include "term.h"
#include "manconf.h"
#include "main.h"

static	struct termp	 *ascii_init(enum termenc, const struct manoutput *);
static	int		  ascii_hspan(const struct termp *,
				const struct roffsu *);
static	size_t		  ascii_width(const struct termp *, int);
static	void		  ascii_advance(struct termp *, size_t);
static	void		  ascii_begin(struct termp *);
static	void		  ascii_end(struct termp *);
static	void		  ascii_endline(struct termp *);
static	void		  ascii_letter(struct termp *, int);
static	void		  ascii_setwidth(struct termp *, int, int);

static	void		  locale_advance(struct termp *, size_t);
static	void		  locale_endline(struct termp *);
static	void		  locale_letter(struct termp *, int);
static	size_t		  locale_width(const struct termp *, int);


static struct termp *
ascii_init(enum termenc enc, const struct manoutput *outopts)
{
	char		*v;
	struct termp	*p;

	p = mandoc_calloc(1, sizeof(*p));
	p->tcol = p->tcols = mandoc_calloc(1, sizeof(*p->tcol));
	p->maxtcol = 1;

	p->line = 1;
	p->defrmargin = p->lastrmargin = 78;
	p->fontq = mandoc_reallocarray(NULL,
	     (p->fontsz = 8), sizeof(*p->fontq));
	p->fontq[0] = p->fontl = TERMFONT_NONE;

	p->begin = ascii_begin;
	p->end = ascii_end;
	p->hspan = ascii_hspan;
	p->type = TERMTYPE_CHAR;

	p->enc = TERMENC_ASCII;
	p->advance = ascii_advance;
	p->endline = ascii_endline;
	p->letter = ascii_letter;
	p->setwidth = ascii_setwidth;
	p->width = ascii_width;

	if (TERMENC_ASCII != enc) {

		/*
		 * Do not change any of this to LC_ALL.  It might break
		 * the formatting by subtly changing the behaviour of
		 * various functions, for example strftime(3).  As a
		 * worst case, it might even cause buffer overflows.
		 */

		v = TERMENC_LOCALE == enc ?
		    setlocale(LC_CTYPE, "") :
		    setlocale(LC_CTYPE, "en_US.UTF-8");
		if (NULL != v && MB_CUR_MAX > 1) {
			p->enc = enc;
			p->advance = locale_advance;
			p->endline = locale_endline;
			p->letter = locale_letter;
			p->width = locale_width;
		}
	}

	if (outopts->mdoc) {
		p->mdocstyle = 1;
		p->defindent = 5;
	}
	if (outopts->indent)
		p->defindent = outopts->indent;
	if (outopts->width)
		p->defrmargin = outopts->width;
	if (outopts->synopsisonly)
		p->synopsisonly = 1;

	return p;
}

void *
ascii_alloc(const struct manoutput *outopts)
{

	return ascii_init(TERMENC_ASCII, outopts);
}

void *
utf8_alloc(const struct manoutput *outopts)
{

	return ascii_init(TERMENC_UTF8, outopts);
}

void *
locale_alloc(const struct manoutput *outopts)
{

	return ascii_init(TERMENC_LOCALE, outopts);
}

static void
ascii_setwidth(struct termp *p, int iop, int width)
{

	width /= 24;
	p->tcol->rmargin = p->defrmargin;
	if (iop > 0)
		p->defrmargin += width;
	else if (iop == 0)
		p->defrmargin = width ? (size_t)width : p->lastrmargin;
	else if (p->defrmargin > (size_t)width)
		p->defrmargin -= width;
	else
		p->defrmargin = 0;
	p->lastrmargin = p->tcol->rmargin;
	p->tcol->rmargin = p->maxrmargin = p->defrmargin;
}

void
terminal_sepline(void *arg)
{
	struct termp	*p;
	size_t		 i;

	p = (struct termp *)arg;
	(*p->endline)(p);
	for (i = 0; i < p->defrmargin; i++)
		(*p->letter)(p, '-');
	(*p->endline)(p);
	(*p->endline)(p);
}

static size_t
ascii_width(const struct termp *p, int c)
{

	return 1;
}

void
ascii_free(void *arg)
{

	term_free((struct termp *)arg);
}

static void
ascii_letter(struct termp *p, int c)
{

	putchar(c);
}

static void
ascii_begin(struct termp *p)
{

	(*p->headf)(p, p->argf);
}

static void
ascii_end(struct termp *p)
{

	(*p->footf)(p, p->argf);
}

static void
ascii_endline(struct termp *p)
{

	p->line++;
	p->tcol->offset -= p->ti;
	p->ti = 0;
	putchar('\n');
}

static void
ascii_advance(struct termp *p, size_t len)
{
	size_t		i;

	for (i = 0; i < len; i++)
		putchar(' ');
}

static int
ascii_hspan(const struct termp *p, const struct roffsu *su)
{
	double		 r;

	switch (su->unit) {
	case SCALE_BU:
		r = su->scale;
		break;
	case SCALE_CM:
		r = su->scale * 240.0 / 2.54;
		break;
	case SCALE_FS:
		r = su->scale * 65536.0;
		break;
	case SCALE_IN:
		r = su->scale * 240.0;
		break;
	case SCALE_MM:
		r = su->scale * 0.24;
		break;
	case SCALE_VS:
	case SCALE_PC:
		r = su->scale * 40.0;
		break;
	case SCALE_PT:
		r = su->scale * 10.0 / 3.0;
		break;
	case SCALE_EN:
	case SCALE_EM:
		r = su->scale * 24.0;
		break;
	default:
		abort();
	}
	return r > 0.0 ? r + 0.01 : r - 0.01;
}

const char *
ascii_uc2str(int uc)
{
	static const char nbrsp[2] = { ASCII_NBRSP, '\0' };
	static const char *tab[] = {
	"<NUL>","<SOH>","<STX>","<ETX>","<EOT>","<ENQ>","<ACK>","<BEL>",
	"<BS>",	"\t",	"<LF>",	"<VT>",	"<FF>",	"<CR>",	"<SO>",	"<SI>",
	"<DLE>","<DC1>","<DC2>","<DC3>","<DC4>","<NAK>","<SYN>","<ETB>",
	"<CAN>","<EM>",	"<SUB>","<ESC>","<FS>",	"<GS>",	"<RS>",	"<US>",
	" ",	"!",	"\"",	"#",	"$",	"%",	"&",	"'",
	"(",	")",	"*",	"+",	",",	"-",	".",	"/",
	"0",	"1",	"2",	"3",	"4",	"5",	"6",	"7",
	"8",	"9",	":",	";",	"<",	"=",	">",	"?",
	"@@",	"A",	"B",	"C",	"D",	"E",	"F",	"G",
	"H",	"I",	"J",	"K",	"L",	"M",	"N",	"O",
	"P",	"Q",	"R",	"S",	"T",	"U",	"V",	"W",
	"X",	"Y",	"Z",	"[",	"\\",	"]",	"^",	"_",
	"`",	"a",	"b",	"c",	"d",	"e",	"f",	"g",
	"h",	"i",	"j",	"k",	"l",	"m",	"n",	"o",
	"p",	"q",	"r",	"s",	"t",	"u",	"v",	"w",
	"x",	"y",	"z",	"{",	"|",	"}",	"~",	"<DEL>",
	"<80>",	"<81>",	"<82>",	"<83>",	"<84>",	"<85>",	"<86>",	"<87>",
	"<88>",	"<89>",	"<8A>",	"<8B>",	"<8C>",	"<8D>",	"<8E>",	"<8F>",
	"<90>",	"<91>",	"<92>",	"<93>",	"<94>",	"<95>",	"<96>",	"<97>",
	"<99>",	"<99>",	"<9A>",	"<9B>",	"<9C>",	"<9D>",	"<9E>",	"<9F>",
	nbrsp,	"!",	"/\bc",	"GBP",	"o\bx",	"=\bY",	"|",	"<sec>",
	"\"",	"(C)",	"_\ba",	"<<",	"~",	"",	"(R)",	"-",
	"<deg>","+-",	"2",	"3",	"'",	",\bu",	"<par>",".",
	",",	"1",	"_\bo",	">>",	"1/4",	"1/2",	"3/4",	"?",
	"`\bA",	"'\bA",	"^\bA",	"~\bA",	"\"\bA","o\bA",	"AE",	",\bC",
	"`\bE",	"'\bE",	"^\bE",	"\"\bE","`\bI",	"'\bI",	"^\bI",	"\"\bI",
	"-\bD",	"~\bN",	"`\bO",	"'\bO",	"^\bO",	"~\bO",	"\"\bO","x",
	"/\bO",	"`\bU",	"'\bU",	"^\bU",	"\"\bU","'\bY",	"Th",	"ss",
	"`\ba",	"'\ba",	"^\ba",	"~\ba",	"\"\ba","o\ba",	"ae",	",\bc",
	"`\be",	"'\be",	"^\be",	"\"\be","`\bi",	"'\bi",	"^\bi",	"\"\bi",
	"d",	"~\bn",	"`\bo",	"'\bo",	"^\bo",	"~\bo",	"\"\bo","-:-",
	"/\bo",	"`\bu",	"'\bu",	"^\bu",	"\"\bu","'\by",	"th",	"\"\by",
	"A",	"a",	"A",	"a",	"A",	"a",	"'\bC",	"'\bc",
	"^\bC",	"^\bc",	"C",	"c",	"C",	"c",	"D",	"d",
	"/\bD",	"/\bd",	"E",	"e",	"E",	"e",	"E",	"e",
	"E",	"e",	"E",	"e",	"^\bG",	"^\bg",	"G",	"g",
	"G",	"g",	",\bG",	",\bg",	"^\bH",	"^\bh",	"/\bH",	"/\bh",
	"~\bI",	"~\bi",	"I",	"i",	"I",	"i",	"I",	"i",
	"I",	"i",	"IJ",	"ij",	"^\bJ",	"^\bj",	",\bK",	",\bk",
	"q",	"'\bL",	"'\bl",	",\bL",	",\bl",	"L",	"l",	"L",
	"l",	"/\bL",	"/\bl",	"'\bN",	"'\bn",	",\bN",	",\bn",	"N",
	"n",	"'n",	"Ng",	"ng",	"O",	"o",	"O",	"o",
	"O",	"o",	"OE",	"oe",	"'\bR",	"'\br",	",\bR",	",\br",
	"R",	"r",	"'\bS",	"'\bs",	"^\bS",	"^\bs",	",\bS",	",\bs",
	"S",	"s",	",\bT",	",\bt",	"T",	"t",	"/\bT",	"/\bt",
	"~\bU",	"~\bu",	"U",	"u",	"U",	"u",	"U",	"u",
	"U",	"u",	"U",	"u",	"^\bW",	"^\bw",	"^\bY",	"^\by",
	"\"\bY","'\bZ",	"'\bz",	"Z",	"z",	"Z",	"z",	"s",
	"b",	"B",	"B",	"b",	"6",	"6",	"O",	"C",
	"c",	"D",	"D",	"D",	"d",	"d",	"3",	"@@",
	"E",	"F",	",\bf",	"G",	"G",	"hv",	"I",	"/\bI",
	"K",	"k",	"/\bl",	"l",	"W",	"N",	"n",	"~\bO",
	"O",	"o",	"OI",	"oi",	"P",	"p",	"YR",	"2",
	"2",	"SH",	"sh",	"t",	"T",	"t",	"T",	"U",
	"u",	"Y",	"V",	"Y",	"y",	"/\bZ",	"/\bz",	"ZH",
	"ZH",	"zh",	"zh",	"/\b2",	"5",	"5",	"ts",	"w",
	"|",	"||",	"|=",	"!",	"DZ",	"Dz",	"dz",	"LJ",
	"Lj",	"lj",	"NJ",	"Nj",	"nj",	"A",	"a",	"I",
	"i",	"O",	"o",	"U",	"u",	"U",	"u",	"U",
	"u",	"U",	"u",	"U",	"u",	"@@",	"A",	"a",
	"A",	"a",	"AE",	"ae",	"/\bG",	"/\bg",	"G",	"g",
	"K",	"k",	"O",	"o",	"O",	"o",	"ZH",	"zh",
	"j",	"DZ",	"Dz",	"dz",	"'\bG",	"'\bg",	"HV",	"W",
	"`\bN",	"`\bn",	"A",	"a",	"'\bAE","'\bae","O",	"o"};

	assert(uc >= 0);
	if ((size_t)uc < sizeof(tab)/sizeof(tab[0]))
		return tab[uc];
	return mchars_uc2str(uc);
}

static size_t
locale_width(const struct termp *p, int c)
{
	int		rc;

	if (c == ASCII_NBRSP)
		c = ' ';
	rc = wcwidth(c);
	if (rc < 0)
		rc = 0;
	return rc;
}

static void
locale_advance(struct termp *p, size_t len)
{
	size_t		i;

	for (i = 0; i < len; i++)
		putwchar(L' ');
}

static void
locale_endline(struct termp *p)
{

	p->line++;
	p->tcol->offset -= p->ti;
	p->ti = 0;
	putwchar(L'\n');
}

static void
locale_letter(struct termp *p, int c)
{

	putwchar(c);
}
@


1.41
log
@Basic implementation of the roff(7) .ti (temporary indent) request.
Needed by about four dozen ports (thanks to naddy@@ for the research).
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.40 2017/05/07 17:30:58 schwarze Exp $ */
d58 3
a60 1
	p = mandoc_calloc(1, sizeof(struct termp));
d65 1
a65 1
	     (p->fontsz = 8), sizeof(enum termfont));
d141 1
a141 1
	p->rmargin = p->defrmargin;
d150 2
a151 2
	p->lastrmargin = p->rmargin;
	p->rmargin = p->maxrmargin = p->defrmargin;
d208 1
a208 1
	p->offset -= p->ti;
d363 1
a363 1
	p->offset -= p->ti;
@


1.40
log
@Basic implementation of the roff(7) .ta (define tab stops) request.
This is the first feature made possible by the parser reorganization.
Improves the formatting of the SYNOPSIS in many Xenocara GL manuals.
Also important for ports, as reported by many, including naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.39 2016/07/08 22:27:58 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
d206 2
d361 2
@


1.39
log
@ISO C99 7.19.2.5 doesn't like mixing putchar(3) and putwchar(3) on
the same stream, and actually, it fails spectacularly on glibc.
Portability issue pointed out by Svyatoslav Mishyn <juef at openmailbox
dot org> after testing on Void Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.38 2015/11/12 21:49:29 schwarze Exp $ */
a60 1
	p->tabwidth = 5;
@


1.38
log
@Never use LC_ALL.  On the one hand, it can cause misformatting.
On the other hand, it is a security risk because it might cause
buffer overflows.  Use LC_CTYPE only, that's all we need.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.37 2015/10/13 22:57:49 schwarze Exp $ */
d154 1
a154 1
ascii_sepline(void *arg)
d160 1
a160 2
	p->line += 3;
	putchar('\n');
d162 3
a164 3
		putchar('-');
	putchar('\n');
	putchar('\n');
@


1.37
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.36 2015/10/12 00:07:27 schwarze Exp $ */
d80 8
d89 1
a89 1
		    setlocale(LC_ALL, "") :
@


1.36
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.35 2015/10/06 18:30:44 schwarze Exp $ */
d35 1
a35 2
static	struct termp	 *ascii_init(enum termenc, const struct mchars *,
				const struct manoutput *);
d53 1
a53 2
ascii_init(enum termenc enc, const struct mchars *mchars,
	const struct manoutput *outopts)
a59 1
	p->symtab = mchars;
d107 1
a107 1
ascii_alloc(const struct mchars *mchars, const struct manoutput *outopts)
d110 1
a110 1
	return ascii_init(TERMENC_ASCII, mchars, outopts);
d114 1
a114 1
utf8_alloc(const struct mchars *mchars, const struct manoutput *outopts)
d117 1
a117 1
	return ascii_init(TERMENC_UTF8, mchars, outopts);
d121 1
a121 1
locale_alloc(const struct mchars *mchars, const struct manoutput *outopts)
d124 1
a124 1
	return ascii_init(TERMENC_LOCALE, mchars, outopts);
@


1.35
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.34 2015/09/26 00:53:15 schwarze Exp $ */
a236 1
		/* FALLTHROUGH */
a243 1
		/* FALLTHROUGH */
@


1.34
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.33 2015/07/17 22:35:36 schwarze Exp $ */
d106 1
a106 1
	return(p);
d113 1
a113 1
	return(ascii_init(TERMENC_ASCII, mchars, outopts));
d120 1
a120 1
	return(ascii_init(TERMENC_UTF8, mchars, outopts));
d127 1
a127 1
	return(ascii_init(TERMENC_LOCALE, mchars, outopts));
d167 1
a167 1
	return(1);
d252 1
a252 1
	return(r > 0.0 ? r + 0.01 : r - 0.01);
d327 2
a328 2
		return(tab[uc]);
	return(mchars_uc2str(uc));
d341 1
a341 1
	return(rc);
@


1.33
log
@Initial, still somewhat experimental implementation to leverage
less(1) -T and :t ctags(1)-like functionality to jump to the
definitions of various terms inside manual pages.
To be polished in the tree, so bear with me and report issues.

Technically, if less(1) is used as a pager, information is collected
by the mdoc(7) terminal formatter, first stored using the ohash
library, then ultimately written to a temporary file which is passed
to less via -T.  No change intended for other output formatters or
when running without a pager.

Based on an idea from Kristaps using feedback from many, in particular
phessler@@ nicm@@ millert@@ halex@@ doug@@ kspillner@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.32 2015/04/04 17:46:58 schwarze Exp $ */
a250 1
		/* NOTREACHED */
@


1.32
log
@Rounding rules for horizontal scaling widths are more complicated.
There is a first rounding to basic units on the input side.
After that, rounding rules differ between requests and macros.
Requests round to the nearest possible character position.
Macros round to the next character position to the left.

Implement that by changing the return value of term_hspan()
to basic units and leaving the second scaling and rounding stage
to the formatters instead of doing it in the terminal handler.

Improves for example argtable2(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.31 2015/03/27 21:17:16 schwarze Exp $ */
d63 1
d155 1
d202 1
d358 1
@


1.31
log
@Actually use the new man.conf(5) "output" directive.
Additional functionality, yet minus 45 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.30 2015/02/16 13:58:32 tedu Exp $ */
d37 1
a37 1
static	double		  ascii_hspan(const struct termp *,
d45 1
a45 1
static	void		  ascii_setwidth(struct termp *, int, size_t);
d130 1
a130 1
ascii_setwidth(struct termp *p, int iop, size_t width)
d133 1
d138 2
a139 2
		p->defrmargin = width ? width : p->lastrmargin;
	else if (p->defrmargin > width)
d212 1
a212 1
static double
a216 5
	/*
	 * Approximate based on character width.
	 * None of these will be actually correct given that an inch on
	 * the screen depends on character size, terminal, etc., etc.
	 */
d219 1
a219 1
		r = su->scale * 10.0 / 240.0;
d222 1
a222 1
		r = su->scale * 10.0 / 2.54;
d225 1
a225 1
		r = su->scale * 2730.666;
d228 1
a228 1
		r = su->scale * 10.0;
d231 1
a231 1
		r = su->scale / 100.0;
d233 2
d236 1
a236 1
		r = su->scale * 10.0 / 6.0;
d239 1
a239 4
		r = su->scale * 10.0 / 72.0;
		break;
	case SCALE_VS:
		r = su->scale * 2.0 - 1.0;
d244 1
a244 1
		r = su->scale;
d250 1
a250 2

	return(r);
@


1.30
log
@Clamp width and indent settings to sensible values. Ignore errors for now.
ok schwarze
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.29 2014/12/31 16:50:54 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014 Ingo Schwarze <schwarze@@openbsd.org>
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d32 1
d35 2
a36 2
static	struct termp	 *ascii_init(enum termenc,
				const struct mchars *, char *);
d54 2
a55 1
ascii_init(enum termenc enc, const struct mchars *mchars, char *outopts)
a56 1
	const char	*toks[5];
a58 2
	const char	*errstr;
	int		num;
d94 10
a103 36
	toks[0] = "indent";
	toks[1] = "width";
	toks[2] = "mdoc";
	toks[3] = "synopsis";
	toks[4] = NULL;

	while (outopts && *outopts)
		switch (getsubopt(&outopts, UNCONST(toks), &v)) {
		case 0:
			num = strtonum(v, 0, 1000, &errstr);
			if (!errstr)
				p->defindent = num;
			break;
		case 1:
			num = strtonum(v, 0, 1000, &errstr);
			if (!errstr)
				p->defrmargin = num;
			break;
		case 2:
			/*
			 * Temporary, undocumented mode
			 * to imitate mdoc(7) output style.
			 */
			p->mdocstyle = 1;
			p->defindent = 5;
			break;
		case 3:
			p->synopsisonly = 1;
			break;
		default:
			break;
		}

	/* Enforce a lower boundary. */
	if (p->defrmargin < 58)
		p->defrmargin = 58;
d109 1
a109 1
ascii_alloc(const struct mchars *mchars, char *outopts)
d116 1
a116 1
utf8_alloc(const struct mchars *mchars, char *outopts)
d123 1
a123 1
locale_alloc(const struct mchars *mchars, char *outopts)
@


1.29
log
@When showing more than one formatted manual page, insert horizontal lines
between pages.  Suggested by Theo Buehler <theo at math dot ethz dot ch>.
Even in UTF-8 output mode, do not use fancy line drawing characters such
that you can easily use /^--- to skip to the next manual in your pager.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.28 2014/12/19 17:10:42 schwarze Exp $ */
d58 2
d104 3
a106 1
			p->defindent = (size_t)atoi(v);
d109 3
a111 1
			p->defrmargin = (size_t)atoi(v);
@


1.28
log
@Enforcing an arbitrary, implementation dependent, undocumented limit
by calling assert() when valid user input exceeds it is a bad idea.
Allocate the terminal font stack dynamically instead of crashing
above 10 entries.  Issue found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.27 2014/11/20 13:55:23 schwarze Exp $ */
d165 14
@


1.27
log
@Prevent negative arguments to the .ll request from causing integer
underflow.  Found while preparing an audit of termp.rmargin.

Overflow can also happen, but i see no sane way to deal with it,
so just let it happen.  It doesn't happen for any sane input anyway,
groff behaviour is undefined, and the resulting values are legal,
even though they are useless.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.26 2014/10/28 18:48:56 schwarze Exp $ */
d64 3
@


1.26
log
@In -Tascii mode, print "<?>" only for Unicode escapes of unknown
representation, not for character escapes with unknown names.
According to groff, the latter produce no output, and we now warn
about them.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.25 2014/10/28 17:35:42 schwarze Exp $ */
d152 1
a152 1
	if (0 < iop)
d154 3
a156 1
	else if (0 > iop)
d159 1
a159 1
		p->defrmargin = width ? width : p->lastrmargin;
@


1.25
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.24 2014/10/28 02:43:05 schwarze Exp $ */
d20 1
d331 1
a331 2
	if (uc < 0)
		return("<?>");
@


1.24
log
@Refine -Tascii rendering of Unicode characters, mostly to better agree
with groff, in particular in cases where groff uses backspace overstrike.
In two cases, agreement is impossible because groff clobbers the
previous line: \(*G \(*S
In a number of cases, groff rendering is so misleading that i chose
to render differently: \(Sd \(TP \(Tp \(Po \(ps \(sc \(r! \(r? \(de
While here, also correct the \(la and \(ra Unicode code points.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.23 2014/10/26 18:06:28 schwarze Exp $ */
d33 2
a34 1
static	struct termp	 *ascii_init(enum termenc, char *);
d52 1
a52 1
ascii_init(enum termenc enc, char *outopts)
d60 1
d126 1
a126 1
ascii_alloc(char *outopts)
d129 1
a129 1
	return(ascii_init(TERMENC_ASCII, outopts));
d133 1
a133 1
utf8_alloc(char *outopts)
d136 1
a136 1
	return(ascii_init(TERMENC_UTF8, outopts));
d140 1
a140 1
locale_alloc(char *outopts)
d143 1
a143 1
	return(ascii_init(TERMENC_LOCALE, outopts));
@


1.23
log
@In -Tascii mode, provide approximations even for some Unicode escape
sequences above codepoint 512 by doing a reverse lookup in the
existing mandoc_char(7) character table.

Again, groff isn't smart enough to do this and silently discards such
escape sequences without printing anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.22 2014/10/26 17:11:18 schwarze Exp $ */
d283 21
a303 21
	nbrsp,	"!",	"c",	"GBP",	"$?",	"Y=",	"|",	"<sec>",
	"\"",	"(C)",	"a.",	"<<",	"<not>","",	"(R)",	"-",
	"<deg>","+-",	"^2",	"^3",	"'",	"<my>",	"<par>","*",
	",",	"^1",	"o.",	">>",	"1/4",	"1/2",	"3/4",	"?",
	"A",	"A",	"A",	"A",	"Ae",	"Aa",	"AE",	"C",
	"E",	"E",	"E",	"E",	"I",	"I",	"I",	"I",
	"D",	"N",	"O",	"O",	"O",	"O",	"Oe",	"*",
	"Oe",	"U",	"U",	"U",	"Ue",	"Y",	"Th",	"ss",
	"a",	"a",	"a",	"a",	"ae",	"aa",	"ae",	"c",
	"e",	"e",	"e",	"e",	"i",	"i",	"i",	"i",
	"d",	"n",	"o",	"o",	"o",	"o",	"oe",	"/",
	"oe",	"u",	"u",	"u",	"ue",	"y",	"th",	"y",
	"A",	"a",	"A",	"a",	"A",	"a",	"C",	"c",
	"C",	"c",	"C",	"c",	"C",	"c",	"D",	"d",
	"D",	"d",	"E",	"e",	"E",	"e",	"E",	"e",
	"E",	"e",	"E",	"e",	"G",	"g",	"G",	"g",
	"G",	"g",	"G",	"g",	"H",	"h",	"H",	"h",
	"I",	"i",	"I",	"i",	"I",	"i",	"I",	"i",
	"I",	"i",	"IJ",	"ij",	"J",	"j",	"K",	"k",
	"q",	"L",	"l",	"L",	"l",	"L",	"l",	"L",
	"l",	"L",	"l",	"N",	"n",	"N",	"n",	"N",
d305 6
a310 6
	"O",	"o",	"OE",	"oe",	"R",	"r",	"R",	"r",
	"R",	"r",	"S",	"s",	"S",	"s",	"S",	"s",
	"S",	"s",	"T",	"t",	"T",	"t",	"T",	"t",
	"U",	"u",	"U",	"u",	"U",	"u",	"U",	"u",
	"U",	"u",	"U",	"u",	"W",	"w",	"Y",	"y",
	"Y",	"Z",	"z",	"Z",	"z",	"Z",	"z",	"s",
d313 2
a314 2
	"E",	"F",	"f",	"G",	"G",	"hv",	"I",	"I",
	"K",	"k",	"l",	"l",	"W",	"N",	"n",	"O",
d317 2
a318 2
	"u",	"Y",	"V",	"Y",	"y",	"Z",	"z",	"ZH",
	"ZH",	"zh",	"zh",	"2",	"5",	"5",	"ts",	"w",
d323 1
a323 1
	"A",	"a",	"AE",	"ae",	"G",	"g",	"G",	"g",
d325 2
a326 2
	"j",	"DZ",	"D",	"dz",	"G",	"g",	"HV",	"W",
	"N",	"n",	"A",	"a",	"AE",	"ae",	"O",	"o"};
@


1.22
log
@Improve -Tascii output for Unicode escape sequences: For the first 512
code points, provide ASCII approximations.  This is already much better
than what groff does, which prints nothing for most code points.

A few minor fixes while here:
* Handle Unicode escape sequences in the ASCII range.
* In case of errors, use the REPLACEMENT CHARACTER U+FFFD for -Tutf8
and the string "<?>" for -Tascii output.
* Handle all one-character escape sequences in mchars_spec2{cp,str}()
and remove the workarounds on the higher level.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ascii.c,v 1.21 2014/09/03 05:17:08 schwarze Exp $ */
d328 1
a328 1
	if (uc < 0 || (size_t)uc >= sizeof(tab)/sizeof(tab[0]))
d330 3
a332 1
	return(tab[uc]);
@


1.21
log
@Implement the traditional -h option for man(1): show the SYNOPSIS only.
As usual, we get mandoc -h and apropos -h for free.
Try stuff like "apropos -h In=dirent" or "apropos -h Fa=timespec".

Only useful for terminal output, so -Tps, -Tpdf, -Thtml ignore -h for now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d256 75
@


1.20
log
@typo, sorry
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.19 2014/08/17 22:06:49 schwarze Exp $ */
d53 1
a53 1
	const char	*toks[4];
d90 2
a91 1
	toks[3] = NULL;
d108 3
@


1.19
log
@While all current callers pass valid data to ascii_hspan() only,
it's safer to assume incoming enum data might be invalid
and catch it instead of happily returning an unitialized int.
No functional change right now.
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.18 2014/08/14 22:32:28 schwarze Exp $ */
d246 1
a246 1
	case default:
@


1.18
log
@Some compilers apparently worry that abort() might return
and then throw a "may be used uninitialized" warning, so
sprinkle some /* NOTREACHED */.  No functional change.
Noticed by Thomas Klausner <wiz at NetBSD dot org>.
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.17 2014/08/13 22:09:28 schwarze Exp $ */
d246 1
a246 1
	case SCALE_MAX:
@


1.17
log
@Begin cleanup of scaling units.
Note that we use 240u := 1i for all devices, even -Tps and -Tpdf.
Big fix of -Tascii rendering of f, m, and u.
Small fix of -Tascii rendering of c.
Big fix of -Thtml rendering of u.
Big fix of -Tps rendering of m, p, and u.
Clarify -Tps rendering of c.
Correct documentation of scaling units, in particular with respect to u.
This for example improves rendering of the OpenGL manuals.
Joint work with kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.29 2014/08/13 20:34:29 kristaps Exp $ */
d242 1
d248 1
a248 1
		break;
@


1.16
log
@Clarity with respect to floating point handling:
Write double constants as double rather than integer literals.
Remove useless explicit (double) cast done at one place and nowhere else.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.15 2014/07/27 21:51:53 schwarze Exp $ */
d212 3
a214 2
	 * Approximate based on character width.  These are generated
	 * entirely by eyeballing the screen, but appear to be correct.
a215 1

d217 3
d221 4
a224 1
		r = su->scale * 4.0;
d229 3
d233 1
a233 1
		r = (su->scale * 10.0) / 6.0;
d236 1
a236 4
		r = (su->scale * 10.0) / 72.0;
		break;
	case SCALE_MM:
		r = su->scale / 1000.0;
d241 2
a242 1
	default:
d244 3
@


1.15
log
@Even for UTF-8 output, a non-breaking space character has the same width
as a normal space character, and not width 0.  Bug reported by bentley@@.
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.14 2014/04/20 16:44:44 schwarze Exp $ */
d218 1
a218 1
		r = 4 * su->scale;
d221 1
a221 1
		r = 10 * su->scale;
d224 1
a224 1
		r = (10 * su->scale) / 6;
d227 1
a227 1
		r = (10 * su->scale) / 72;
d230 1
a230 1
		r = su->scale / 1000;
d233 1
a233 1
		r = su->scale * 2 - 1;
@


1.14
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.13 2014/03/30 21:27:59 schwarze Exp $ */
d248 6
a253 1
	return((rc = wcwidth(c)) < 0 ? 0 : rc);
@


1.13
log
@Support relative arguments to .ll (increase or decrease line length).
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.12 2014/03/30 19:47:32 schwarze Exp $ */
d49 1
d76 2
a77 2
			setlocale(LC_ALL, "") :
			setlocale(LC_CTYPE, "en_US.UTF-8");
d94 1
a94 1
		case (0):
d97 1
a97 1
		case (1):
d100 1
a100 1
		case (2):
a132 1

a154 1
/* ARGSUSED */
a168 1
/* ARGSUSED */
d172 1
a172 1
	
a189 1
/* ARGSUSED */
a196 1
/* ARGSUSED */
d200 1
a200 1
	size_t	 	i;
a205 1
/* ARGSUSED */
d217 1
a217 1
	case (SCALE_CM):
d220 1
a220 1
	case (SCALE_IN):
d223 1
a223 1
	case (SCALE_PC):
d226 1
a226 1
	case (SCALE_PT):
d229 1
a229 1
	case (SCALE_MM):
d232 1
a232 1
	case (SCALE_VS):
a242 1
/* ARGSUSED */
a250 1
/* ARGSUSED */
d254 1
a254 1
	size_t	 	i;
a259 1
/* ARGSUSED */
a266 1
/* ARGSUSED */
d270 1
a270 1
	
@


1.12
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.11 2014/03/21 22:17:01 schwarze Exp $ */
d42 1
a42 1
static	void		  ascii_setwidth(struct termp *, size_t);
d141 1
a141 1
ascii_setwidth(struct termp *p, size_t width)
a142 1
	size_t	 lastwidth;
d144 9
a152 4
	lastwidth = p->defrmargin;
	p->rmargin = p->maxrmargin = p->defrmargin =
	    width ? width : p->lastrmargin;
	p->lastrmargin = lastwidth;
@


1.11
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.10 2013/06/01 14:27:13 schwarze Exp $ */
d4 1
d42 1
d59 1
a59 1
	p->defrmargin = 78;
d70 1
d138 11
@


1.10
log
@Use a standard locale name, "UTF-8" is an ugly non-standard alias
that doesn't work on OpenBSD.
OK tedu@@ naddy@@
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.9 2011/12/05 00:28:12 schwarze Exp $ */
a18 1
#include <assert.h>
d27 1
@


1.9
log
@As requested by kristaps@@, add and improve comments related to -Omdoc;
while here, clean up some redundant initializations in print_man_head().
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.8 2011/11/13 13:30:42 schwarze Exp $ */
a54 1
	p->enc = enc;
d73 1
a73 1
			setlocale(LC_CTYPE, "UTF-8");
@


1.8
log
@Support -man -Omdoc to format man(7) manuals in mdoc(7) output style;
so far, this is only accepting the option,
i will commit the (few) formatting tweaks separately.

This is intentionally undocumented for two reasons:
(1) We dream of making it the default at some point, so the option
    will hopefully go away again.
(2) It is not needed for production, but mostly for automated man(7)
    to mdoc(7) output comparisons, to help -Tman development.
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.7 2011/11/13 13:05:23 schwarze Exp $ */
d98 4
@


1.7
log
@Make the default left text margin configurable from the command line,
just like the default right margin already is.  This may be useful for
people with expensive screen real estate.  Besides, it helps automated
man(7) to mdoc(7) output comparisons to validate -Tman output.
ok kristaps@@ on an earlier version
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.6 2011/05/29 21:22:18 schwarze Exp $ */
d50 1
a50 1
	const char	*toks[3];
d86 2
a87 1
	toks[2] = NULL;
d96 4
@


1.6
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.5 2011/01/31 02:36:55 schwarze Exp $ */
d50 1
a50 1
	const char	*toks[2];
d84 3
a86 2
	toks[0] = "width";
	toks[1] = NULL;
d91 3
@


1.5
log
@Remove unnecessary conditional: term_alloc() cannot return NULL;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.4 2011/01/04 22:28:17 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d20 1
d25 1
d32 1
d35 1
a35 1
static	size_t		  ascii_width(const struct termp *, char);
d40 1
a40 1
static	void		  ascii_letter(struct termp *, char);
d42 4
d47 2
a48 2
void *
ascii_alloc(char *outopts)
a49 1
	struct termp	*p;
d52 1
d54 2
a55 1
	p = term_alloc(TERMENC_ASCII);
a59 1
	p->advance = ascii_advance;
d62 5
a67 1
	p->hspan = ascii_hspan;
a68 1
	p->type = TERMTYPE_CHAR;
d71 13
d103 21
d127 1
a127 1
ascii_width(const struct termp *p, char c)
a132 1

a139 1

d142 1
a142 1
ascii_letter(struct termp *p, char c)
a147 1

a154 1

a161 1

a169 1

a175 1
	/* Just print whitespace on the terminal. */
a179 1

d218 34
@


1.4
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.3 2010/07/13 01:09:13 schwarze Exp $ */
d47 1
a47 2
	if (NULL == (p = term_alloc(TERMENC_ASCII)))
		return(NULL);
@


1.3
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.2 2010/06/26 19:08:00 schwarze Exp $ */
a16 4
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

d25 1
@


1.2
log
@As a first step towards variable-width font support,
move all width calculations in term_*.c, *_width().
From kristaps.
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.1 2010/06/10 22:50:10 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d33 6
a40 4
static	void		  ascii_begin(struct termp *);
static	void		  ascii_advance(struct termp *, size_t);
static	void		  ascii_end(struct termp *);
static	size_t		  ascii_width(const struct termp *, char);
d56 1
a56 2
	p->type = TERMTYPE_CHAR;
	p->letter = ascii_letter;
d60 3
a62 1
	p->advance = ascii_advance;
d85 1
d146 40
@


1.1
log
@minimal initial -Tps support, from kristaps@@ GSOC
so far, monospace without font decoration,
but it already has page headers and footers
@
text
@d1 1
a1 1
/*	$Id: term_ascii.c,v 1.1 2010/06/08 15:00:17 kristaps Exp $ */
d38 1
d51 3
d60 1
d79 8
@

