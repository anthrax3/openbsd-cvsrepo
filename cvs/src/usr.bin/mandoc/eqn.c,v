head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.2
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.5.0.12
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.25
date	2017.03.11.15.42.03;	author schwarze;	state Exp;
branches;
next	1.24;
commitid	0gYtsbJYnd0pkWWT;

1.24
date	2016.01.08.00.50.20;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	j7u5eUVL92qSR14e;

1.23
date	2016.01.07.20.18.34;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	LasTtIKiSnQiX82S;

1.22
date	2015.10.06.18.30.43;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	hxQV8O1pNUaef4ir;

1.21
date	2015.03.03.22.22.20;	author bentley;	state Exp;
branches;
next	1.20;
commitid	TfVR2PrsOygyg8f4;

1.20
date	2015.01.28.21.10.28;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	fvM2x3xHE0B4upcu;

1.19
date	2014.10.25.15.05.21;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	BCa9wYcViqQs3B67;

1.18
date	2014.10.25.14.32.07;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	0lmH8qIaoxl2FlKf;

1.17
date	2014.10.16.01.10.06;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	3N6FMKugsVoc1dko;

1.16
date	2014.10.12.20.08.43;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	mt56FCuqIouBcpkA;

1.15
date	2014.10.12.19.10.56;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	oFUg4cCWEgutyqUr;

1.14
date	2014.10.10.15.25.06;	author schwarze;	state Exp;
branches;
next	1.13;
commitid	MpqXOG3dhTX11YQI;

1.13
date	2014.10.09.15.59.08;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	Wy6YFSKH1ddfqJiG;

1.12
date	2014.10.09.15.21.46;	author schwarze;	state Exp;
branches;
next	1.11;
commitid	QH4xwyTeTm9ROYu8;

1.11
date	2014.07.06.19.08.56;	author schwarze;	state Exp;
branches;
next	1.10;
commitid	rolX8OitNNoUBJoD;

1.10
date	2014.07.04.16.11.41;	author schwarze;	state Exp;
branches;
next	1.9;
commitid	sgqZ9hnRM3L6yvgn;

1.9
date	2014.04.23.21.06.33;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.20.19.39.35;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2011.03.21.00.48.02;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Improve detection of recursive eqn(7) "define" statements:
Do not only catch "define key 'key other stuff'",
but also "define key 'other stuff key'".
Fixing infinite loop found by tb@@ with afl(1).
@
text
@/*	$OpenBSD: eqn.c,v 1.24 2016/01/08 00:50:20 schwarze Exp $ */
/*
 * Copyright (c) 2011, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mandoc.h"
#include "mandoc_aux.h"
#include "libmandoc.h"
#include "libroff.h"

#define	EQN_NEST_MAX	 128 /* maximum nesting of defines */
#define	STRNEQ(p1, sz1, p2, sz2) \
	((sz1) == (sz2) && 0 == strncmp((p1), (p2), (sz1)))

enum	eqn_tok {
	EQN_TOK_DYAD = 0,
	EQN_TOK_VEC,
	EQN_TOK_UNDER,
	EQN_TOK_BAR,
	EQN_TOK_TILDE,
	EQN_TOK_HAT,
	EQN_TOK_DOT,
	EQN_TOK_DOTDOT,
	EQN_TOK_FWD,
	EQN_TOK_BACK,
	EQN_TOK_DOWN,
	EQN_TOK_UP,
	EQN_TOK_FAT,
	EQN_TOK_ROMAN,
	EQN_TOK_ITALIC,
	EQN_TOK_BOLD,
	EQN_TOK_SIZE,
	EQN_TOK_SUB,
	EQN_TOK_SUP,
	EQN_TOK_SQRT,
	EQN_TOK_OVER,
	EQN_TOK_FROM,
	EQN_TOK_TO,
	EQN_TOK_BRACE_OPEN,
	EQN_TOK_BRACE_CLOSE,
	EQN_TOK_GSIZE,
	EQN_TOK_GFONT,
	EQN_TOK_MARK,
	EQN_TOK_LINEUP,
	EQN_TOK_LEFT,
	EQN_TOK_RIGHT,
	EQN_TOK_PILE,
	EQN_TOK_LPILE,
	EQN_TOK_RPILE,
	EQN_TOK_CPILE,
	EQN_TOK_MATRIX,
	EQN_TOK_CCOL,
	EQN_TOK_LCOL,
	EQN_TOK_RCOL,
	EQN_TOK_DELIM,
	EQN_TOK_DEFINE,
	EQN_TOK_TDEFINE,
	EQN_TOK_NDEFINE,
	EQN_TOK_UNDEF,
	EQN_TOK_EOF,
	EQN_TOK_ABOVE,
	EQN_TOK__MAX
};

static	const char *eqn_toks[EQN_TOK__MAX] = {
	"dyad", /* EQN_TOK_DYAD */
	"vec", /* EQN_TOK_VEC */
	"under", /* EQN_TOK_UNDER */
	"bar", /* EQN_TOK_BAR */
	"tilde", /* EQN_TOK_TILDE */
	"hat", /* EQN_TOK_HAT */
	"dot", /* EQN_TOK_DOT */
	"dotdot", /* EQN_TOK_DOTDOT */
	"fwd", /* EQN_TOK_FWD * */
	"back", /* EQN_TOK_BACK */
	"down", /* EQN_TOK_DOWN */
	"up", /* EQN_TOK_UP */
	"fat", /* EQN_TOK_FAT */
	"roman", /* EQN_TOK_ROMAN */
	"italic", /* EQN_TOK_ITALIC */
	"bold", /* EQN_TOK_BOLD */
	"size", /* EQN_TOK_SIZE */
	"sub", /* EQN_TOK_SUB */
	"sup", /* EQN_TOK_SUP */
	"sqrt", /* EQN_TOK_SQRT */
	"over", /* EQN_TOK_OVER */
	"from", /* EQN_TOK_FROM */
	"to", /* EQN_TOK_TO */
	"{", /* EQN_TOK_BRACE_OPEN */
	"}", /* EQN_TOK_BRACE_CLOSE */
	"gsize", /* EQN_TOK_GSIZE */
	"gfont", /* EQN_TOK_GFONT */
	"mark", /* EQN_TOK_MARK */
	"lineup", /* EQN_TOK_LINEUP */
	"left", /* EQN_TOK_LEFT */
	"right", /* EQN_TOK_RIGHT */
	"pile", /* EQN_TOK_PILE */
	"lpile", /* EQN_TOK_LPILE */
	"rpile", /* EQN_TOK_RPILE */
	"cpile", /* EQN_TOK_CPILE */
	"matrix", /* EQN_TOK_MATRIX */
	"ccol", /* EQN_TOK_CCOL */
	"lcol", /* EQN_TOK_LCOL */
	"rcol", /* EQN_TOK_RCOL */
	"delim", /* EQN_TOK_DELIM */
	"define", /* EQN_TOK_DEFINE */
	"tdefine", /* EQN_TOK_TDEFINE */
	"ndefine", /* EQN_TOK_NDEFINE */
	"undef", /* EQN_TOK_UNDEF */
	NULL, /* EQN_TOK_EOF */
	"above", /* EQN_TOK_ABOVE */
};

enum	eqn_symt {
	EQNSYM_alpha,
	EQNSYM_beta,
	EQNSYM_chi,
	EQNSYM_delta,
	EQNSYM_epsilon,
	EQNSYM_eta,
	EQNSYM_gamma,
	EQNSYM_iota,
	EQNSYM_kappa,
	EQNSYM_lambda,
	EQNSYM_mu,
	EQNSYM_nu,
	EQNSYM_omega,
	EQNSYM_omicron,
	EQNSYM_phi,
	EQNSYM_pi,
	EQNSYM_ps,
	EQNSYM_rho,
	EQNSYM_sigma,
	EQNSYM_tau,
	EQNSYM_theta,
	EQNSYM_upsilon,
	EQNSYM_xi,
	EQNSYM_zeta,
	EQNSYM_DELTA,
	EQNSYM_GAMMA,
	EQNSYM_LAMBDA,
	EQNSYM_OMEGA,
	EQNSYM_PHI,
	EQNSYM_PI,
	EQNSYM_PSI,
	EQNSYM_SIGMA,
	EQNSYM_THETA,
	EQNSYM_UPSILON,
	EQNSYM_XI,
	EQNSYM_inter,
	EQNSYM_union,
	EQNSYM_prod,
	EQNSYM_int,
	EQNSYM_sum,
	EQNSYM_grad,
	EQNSYM_del,
	EQNSYM_times,
	EQNSYM_cdot,
	EQNSYM_nothing,
	EQNSYM_approx,
	EQNSYM_prime,
	EQNSYM_half,
	EQNSYM_partial,
	EQNSYM_inf,
	EQNSYM_muchgreat,
	EQNSYM_muchless,
	EQNSYM_larrow,
	EQNSYM_rarrow,
	EQNSYM_pm,
	EQNSYM_nequal,
	EQNSYM_equiv,
	EQNSYM_lessequal,
	EQNSYM_moreequal,
	EQNSYM_minus,
	EQNSYM__MAX
};

struct	eqnsym {
	const char	*str;
	const char	*sym;
};

static	const struct eqnsym eqnsyms[EQNSYM__MAX] = {
	{ "alpha", "*a" }, /* EQNSYM_alpha */
	{ "beta", "*b" }, /* EQNSYM_beta */
	{ "chi", "*x" }, /* EQNSYM_chi */
	{ "delta", "*d" }, /* EQNSYM_delta */
	{ "epsilon", "*e" }, /* EQNSYM_epsilon */
	{ "eta", "*y" }, /* EQNSYM_eta */
	{ "gamma", "*g" }, /* EQNSYM_gamma */
	{ "iota", "*i" }, /* EQNSYM_iota */
	{ "kappa", "*k" }, /* EQNSYM_kappa */
	{ "lambda", "*l" }, /* EQNSYM_lambda */
	{ "mu", "*m" }, /* EQNSYM_mu */
	{ "nu", "*n" }, /* EQNSYM_nu */
	{ "omega", "*w" }, /* EQNSYM_omega */
	{ "omicron", "*o" }, /* EQNSYM_omicron */
	{ "phi", "*f" }, /* EQNSYM_phi */
	{ "pi", "*p" }, /* EQNSYM_pi */
	{ "psi", "*q" }, /* EQNSYM_psi */
	{ "rho", "*r" }, /* EQNSYM_rho */
	{ "sigma", "*s" }, /* EQNSYM_sigma */
	{ "tau", "*t" }, /* EQNSYM_tau */
	{ "theta", "*h" }, /* EQNSYM_theta */
	{ "upsilon", "*u" }, /* EQNSYM_upsilon */
	{ "xi", "*c" }, /* EQNSYM_xi */
	{ "zeta", "*z" }, /* EQNSYM_zeta */
	{ "DELTA", "*D" }, /* EQNSYM_DELTA */
	{ "GAMMA", "*G" }, /* EQNSYM_GAMMA */
	{ "LAMBDA", "*L" }, /* EQNSYM_LAMBDA */
	{ "OMEGA", "*W" }, /* EQNSYM_OMEGA */
	{ "PHI", "*F" }, /* EQNSYM_PHI */
	{ "PI", "*P" }, /* EQNSYM_PI */
	{ "PSI", "*Q" }, /* EQNSYM_PSI */
	{ "SIGMA", "*S" }, /* EQNSYM_SIGMA */
	{ "THETA", "*H" }, /* EQNSYM_THETA */
	{ "UPSILON", "*U" }, /* EQNSYM_UPSILON */
	{ "XI", "*C" }, /* EQNSYM_XI */
	{ "inter", "ca" }, /* EQNSYM_inter */
	{ "union", "cu" }, /* EQNSYM_union */
	{ "prod", "product" }, /* EQNSYM_prod */
	{ "int", "integral" }, /* EQNSYM_int */
	{ "sum", "sum" }, /* EQNSYM_sum */
	{ "grad", "gr" }, /* EQNSYM_grad */
	{ "del", "gr" }, /* EQNSYM_del */
	{ "times", "mu" }, /* EQNSYM_times */
	{ "cdot", "pc" }, /* EQNSYM_cdot */
	{ "nothing", "&" }, /* EQNSYM_nothing */
	{ "approx", "~~" }, /* EQNSYM_approx */
	{ "prime", "fm" }, /* EQNSYM_prime */
	{ "half", "12" }, /* EQNSYM_half */
	{ "partial", "pd" }, /* EQNSYM_partial */
	{ "inf", "if" }, /* EQNSYM_inf */
	{ ">>", ">>" }, /* EQNSYM_muchgreat */
	{ "<<", "<<" }, /* EQNSYM_muchless */
	{ "<-", "<-" }, /* EQNSYM_larrow */
	{ "->", "->" }, /* EQNSYM_rarrow */
	{ "+-", "+-" }, /* EQNSYM_pm */
	{ "!=", "!=" }, /* EQNSYM_nequal */
	{ "==", "==" }, /* EQNSYM_equiv */
	{ "<=", "<=" }, /* EQNSYM_lessequal */
	{ ">=", ">=" }, /* EQNSYM_moreequal */
	{ "-", "mi" }, /* EQNSYM_minus */
};

static	struct eqn_box	*eqn_box_alloc(struct eqn_node *, struct eqn_box *);
static	void		 eqn_box_free(struct eqn_box *);
static	struct eqn_box	*eqn_box_makebinary(struct eqn_node *,
				enum eqn_post, struct eqn_box *);
static	void		 eqn_def(struct eqn_node *);
static	struct eqn_def	*eqn_def_find(struct eqn_node *, const char *, size_t);
static	void		 eqn_delim(struct eqn_node *);
static	const char	*eqn_next(struct eqn_node *, char, size_t *, int);
static	const char	*eqn_nextrawtok(struct eqn_node *, size_t *);
static	const char	*eqn_nexttok(struct eqn_node *, size_t *);
static	enum rofferr	 eqn_parse(struct eqn_node *, struct eqn_box *);
static	enum eqn_tok	 eqn_tok_parse(struct eqn_node *, char **);
static	void		 eqn_undef(struct eqn_node *);


enum rofferr
eqn_read(struct eqn_node **epp, int ln,
		const char *p, int pos, int *offs)
{
	size_t		 sz;
	struct eqn_node	*ep;
	enum rofferr	 er;

	ep = *epp;

	/*
	 * If we're the terminating mark, unset our equation status and
	 * validate the full equation.
	 */

	if (0 == strncmp(p, ".EN", 3)) {
		er = eqn_end(epp);
		p += 3;
		while (' ' == *p || '\t' == *p)
			p++;
		if ('\0' == *p)
			return er;
		mandoc_vmsg(MANDOCERR_ARG_SKIP, ep->parse,
		    ln, pos, "EN %s", p);
		return er;
	}

	/*
	 * Build up the full string, replacing all newlines with regular
	 * whitespace.
	 */

	sz = strlen(p + pos) + 1;
	ep->data = mandoc_realloc(ep->data, ep->sz + sz + 1);

	/* First invocation: nil terminate the string. */

	if (0 == ep->sz)
		*ep->data = '\0';

	ep->sz += sz;
	strlcat(ep->data, p + pos, ep->sz + 1);
	strlcat(ep->data, " ", ep->sz + 1);
	return ROFF_IGN;
}

struct eqn_node *
eqn_alloc(int pos, int line, struct mparse *parse)
{
	struct eqn_node	*p;

	p = mandoc_calloc(1, sizeof(struct eqn_node));

	p->parse = parse;
	p->eqn.ln = line;
	p->eqn.pos = pos;
	p->gsize = EQN_DEFSIZE;

	return p;
}

/*
 * Find the key "key" of the give size within our eqn-defined values.
 */
static struct eqn_def *
eqn_def_find(struct eqn_node *ep, const char *key, size_t sz)
{
	int		 i;

	for (i = 0; i < (int)ep->defsz; i++)
		if (ep->defs[i].keysz && STRNEQ(ep->defs[i].key,
		    ep->defs[i].keysz, key, sz))
			return &ep->defs[i];

	return NULL;
}

/*
 * Get the next token from the input stream using the given quote
 * character.
 * Optionally make any replacements.
 */
static const char *
eqn_next(struct eqn_node *ep, char quote, size_t *sz, int repl)
{
	static size_t	 last_len;
	static int	 lim;

	char		*start, *next;
	int		 q, diff;
	size_t		 ssz, dummy;
	struct eqn_def	*def;

	if (NULL == sz)
		sz = &dummy;

	if (ep->cur >= last_len)
		lim = 0;
	ep->rew = ep->cur;
again:
	/* Prevent self-definitions. */

	if (lim >= EQN_NEST_MAX) {
		mandoc_msg(MANDOCERR_ROFFLOOP, ep->parse,
		    ep->eqn.ln, ep->eqn.pos, NULL);
		return NULL;
	}

	ep->cur = ep->rew;
	start = &ep->data[(int)ep->cur];
	q = 0;

	if ('\0' == *start)
		return NULL;

	if (quote == *start) {
		ep->cur++;
		q = 1;
	}

	start = &ep->data[(int)ep->cur];

	if ( ! q) {
		if ('{' == *start || '}' == *start)
			ssz = 1;
		else
			ssz = strcspn(start + 1, " ^~\"{}\t") + 1;
		next = start + (int)ssz;
		if ('\0' == *next)
			next = NULL;
	} else
		next = strchr(start, quote);

	if (NULL != next) {
		*sz = (size_t)(next - start);
		ep->cur += *sz;
		if (q)
			ep->cur++;
		while (' ' == ep->data[(int)ep->cur] ||
		    '\t' == ep->data[(int)ep->cur] ||
		    '^' == ep->data[(int)ep->cur] ||
		    '~' == ep->data[(int)ep->cur])
			ep->cur++;
	} else {
		if (q)
			mandoc_msg(MANDOCERR_ARG_QUOTE, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, NULL);
		next = strchr(start, '\0');
		*sz = (size_t)(next - start);
		ep->cur += *sz;
	}

	/* Quotes aren't expanded for values. */

	if (q || ! repl)
		return start;

	if (NULL != (def = eqn_def_find(ep, start, *sz))) {
		diff = def->valsz - *sz;

		if (def->valsz > *sz) {
			ep->sz += diff;
			ep->data = mandoc_realloc(ep->data, ep->sz + 1);
			ep->data[ep->sz] = '\0';
			start = &ep->data[(int)ep->rew];
		}

		diff = def->valsz - *sz;
		memmove(start + *sz + diff, start + *sz,
		    (strlen(start) - *sz) + 1);
		memcpy(start, def->val, def->valsz);
		last_len = start - ep->data + def->valsz;
		lim++;
		goto again;
	}

	return start;
}

/*
 * Get the next delimited token using the default current quote
 * character.
 */
static const char *
eqn_nexttok(struct eqn_node *ep, size_t *sz)
{

	return eqn_next(ep, '"', sz, 1);
}

/*
 * Get next token without replacement.
 */
static const char *
eqn_nextrawtok(struct eqn_node *ep, size_t *sz)
{

	return eqn_next(ep, '"', sz, 0);
}

/*
 * Parse a token from the stream of text.
 * A token consists of one of the recognised eqn(7) strings.
 * Strings are separated by delimiting marks.
 * This returns EQN_TOK_EOF when there are no more tokens.
 * If the token is an unrecognised string literal, then it returns
 * EQN_TOK__MAX and sets the "p" pointer to an allocated, nil-terminated
 * string.
 * This must be later freed with free(3).
 */
static enum eqn_tok
eqn_tok_parse(struct eqn_node *ep, char **p)
{
	const char	*start;
	size_t		 i, sz;
	int		 quoted;

	if (NULL != p)
		*p = NULL;

	quoted = ep->data[ep->cur] == '"';

	if (NULL == (start = eqn_nexttok(ep, &sz)))
		return EQN_TOK_EOF;

	if (quoted) {
		if (p != NULL)
			*p = mandoc_strndup(start, sz);
		return EQN_TOK__MAX;
	}

	for (i = 0; i < EQN_TOK__MAX; i++) {
		if (NULL == eqn_toks[i])
			continue;
		if (STRNEQ(start, sz, eqn_toks[i], strlen(eqn_toks[i])))
			break;
	}

	if (i == EQN_TOK__MAX && NULL != p)
		*p = mandoc_strndup(start, sz);

	return i;
}

static void
eqn_box_free(struct eqn_box *bp)
{

	if (bp->first)
		eqn_box_free(bp->first);
	if (bp->next)
		eqn_box_free(bp->next);

	free(bp->text);
	free(bp->left);
	free(bp->right);
	free(bp->top);
	free(bp->bottom);
	free(bp);
}

/*
 * Allocate a box as the last child of the parent node.
 */
static struct eqn_box *
eqn_box_alloc(struct eqn_node *ep, struct eqn_box *parent)
{
	struct eqn_box	*bp;

	bp = mandoc_calloc(1, sizeof(struct eqn_box));
	bp->parent = parent;
	bp->parent->args++;
	bp->expectargs = UINT_MAX;
	bp->size = ep->gsize;

	if (NULL != parent->first) {
		parent->last->next = bp;
		bp->prev = parent->last;
	} else
		parent->first = bp;

	parent->last = bp;
	return bp;
}

/*
 * Reparent the current last node (of the current parent) under a new
 * EQN_SUBEXPR as the first element.
 * Then return the new parent.
 * The new EQN_SUBEXPR will have a two-child limit.
 */
static struct eqn_box *
eqn_box_makebinary(struct eqn_node *ep,
	enum eqn_post pos, struct eqn_box *parent)
{
	struct eqn_box	*b, *newb;

	assert(NULL != parent->last);
	b = parent->last;
	if (parent->last == parent->first)
		parent->first = NULL;
	parent->args--;
	parent->last = b->prev;
	b->prev = NULL;
	newb = eqn_box_alloc(ep, parent);
	newb->pos = pos;
	newb->type = EQN_SUBEXPR;
	newb->expectargs = 2;
	newb->args = 1;
	newb->first = newb->last = b;
	newb->first->next = NULL;
	b->parent = newb;
	return newb;
}

/*
 * Parse the "delim" control statement.
 */
static void
eqn_delim(struct eqn_node *ep)
{
	const char	*start;
	size_t		 sz;

	if ((start = eqn_nextrawtok(ep, &sz)) == NULL)
		mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
		    ep->eqn.ln, ep->eqn.pos, "delim");
	else if (strncmp(start, "off", 3) == 0)
		ep->delim = 0;
	else if (strncmp(start, "on", 2) == 0) {
		if (ep->odelim && ep->cdelim)
			ep->delim = 1;
	} else if (start[1] != '\0') {
		ep->odelim = start[0];
		ep->cdelim = start[1];
		ep->delim = 1;
	}
}

/*
 * Undefine a previously-defined string.
 */
static void
eqn_undef(struct eqn_node *ep)
{
	const char	*start;
	struct eqn_def	*def;
	size_t		 sz;

	if ((start = eqn_nextrawtok(ep, &sz)) == NULL) {
		mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
		    ep->eqn.ln, ep->eqn.pos, "undef");
		return;
	}
	if ((def = eqn_def_find(ep, start, sz)) == NULL)
		return;
	free(def->key);
	free(def->val);
	def->key = def->val = NULL;
	def->keysz = def->valsz = 0;
}

static void
eqn_def(struct eqn_node *ep)
{
	const char	*start;
	size_t		 sz;
	struct eqn_def	*def;
	int		 i;

	if ((start = eqn_nextrawtok(ep, &sz)) == NULL) {
		mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
		    ep->eqn.ln, ep->eqn.pos, "define");
		return;
	}

	/*
	 * Search for a key that already exists.
	 * Create a new key if none is found.
	 */
	if (NULL == (def = eqn_def_find(ep, start, sz))) {
		/* Find holes in string array. */
		for (i = 0; i < (int)ep->defsz; i++)
			if (0 == ep->defs[i].keysz)
				break;

		if (i == (int)ep->defsz) {
			ep->defsz++;
			ep->defs = mandoc_reallocarray(ep->defs,
			    ep->defsz, sizeof(struct eqn_def));
			ep->defs[i].key = ep->defs[i].val = NULL;
		}

		def = ep->defs + i;
		free(def->key);
		def->key = mandoc_strndup(start, sz);
		def->keysz = sz;
	}

	start = eqn_next(ep, ep->data[(int)ep->cur], &sz, 0);
	if (start == NULL) {
		mandoc_vmsg(MANDOCERR_REQ_EMPTY, ep->parse,
		    ep->eqn.ln, ep->eqn.pos, "define %s", def->key);
		free(def->key);
		free(def->val);
		def->key = def->val = NULL;
		def->keysz = def->valsz = 0;
		return;
	}
	free(def->val);
	def->val = mandoc_strndup(start, sz);
	def->valsz = sz;
}

/*
 * Recursively parse an eqn(7) expression.
 */
static enum rofferr
eqn_parse(struct eqn_node *ep, struct eqn_box *parent)
{
	char		 sym[64];
	struct eqn_box	*cur;
	const char	*start;
	char		*p;
	size_t		 i, sz;
	enum eqn_tok	 tok, subtok;
	enum eqn_post	 pos;
	int		 size;

	assert(parent != NULL);

	/*
	 * Empty equation.
	 * Do not add it to the high-level syntax tree.
	 */

	if (ep->data == NULL)
		return ROFF_IGN;

next_tok:
	tok = eqn_tok_parse(ep, &p);

this_tok:
	switch (tok) {
	case (EQN_TOK_UNDEF):
		eqn_undef(ep);
		break;
	case (EQN_TOK_NDEFINE):
	case (EQN_TOK_DEFINE):
		eqn_def(ep);
		break;
	case (EQN_TOK_TDEFINE):
		if (eqn_nextrawtok(ep, NULL) == NULL ||
		    eqn_next(ep, ep->data[(int)ep->cur], NULL, 0) == NULL)
			mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, "tdefine");
		break;
	case (EQN_TOK_DELIM):
		eqn_delim(ep);
		break;
	case (EQN_TOK_GFONT):
		if (eqn_nextrawtok(ep, NULL) == NULL)
			mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
		break;
	case (EQN_TOK_MARK):
	case (EQN_TOK_LINEUP):
		/* Ignore these. */
		break;
	case (EQN_TOK_DYAD):
	case (EQN_TOK_VEC):
	case (EQN_TOK_UNDER):
	case (EQN_TOK_BAR):
	case (EQN_TOK_TILDE):
	case (EQN_TOK_HAT):
	case (EQN_TOK_DOT):
	case (EQN_TOK_DOTDOT):
		if (parent->last == NULL) {
			mandoc_msg(MANDOCERR_EQN_NOBOX, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			cur = eqn_box_alloc(ep, parent);
			cur->type = EQN_TEXT;
			cur->text = mandoc_strdup("");
		}
		parent = eqn_box_makebinary(ep, EQNPOS_NONE, parent);
		parent->type = EQN_LISTONE;
		parent->expectargs = 1;
		switch (tok) {
		case (EQN_TOK_DOTDOT):
			strlcpy(sym, "\\[ad]", sizeof(sym));
			break;
		case (EQN_TOK_VEC):
			strlcpy(sym, "\\[->]", sizeof(sym));
			break;
		case (EQN_TOK_DYAD):
			strlcpy(sym, "\\[<>]", sizeof(sym));
			break;
		case (EQN_TOK_TILDE):
			strlcpy(sym, "\\[a~]", sizeof(sym));
			break;
		case (EQN_TOK_UNDER):
			strlcpy(sym, "\\[ul]", sizeof(sym));
			break;
		case (EQN_TOK_BAR):
			strlcpy(sym, "\\[rl]", sizeof(sym));
			break;
		case (EQN_TOK_DOT):
			strlcpy(sym, "\\[a.]", sizeof(sym));
			break;
		case (EQN_TOK_HAT):
			strlcpy(sym, "\\[ha]", sizeof(sym));
			break;
		default:
			abort();
		}

		switch (tok) {
		case (EQN_TOK_DOTDOT):
		case (EQN_TOK_VEC):
		case (EQN_TOK_DYAD):
		case (EQN_TOK_TILDE):
		case (EQN_TOK_BAR):
		case (EQN_TOK_DOT):
		case (EQN_TOK_HAT):
			parent->top = mandoc_strdup(sym);
			break;
		case (EQN_TOK_UNDER):
			parent->bottom = mandoc_strdup(sym);
			break;
		default:
			abort();
		}
		parent = parent->parent;
		break;
	case (EQN_TOK_FWD):
	case (EQN_TOK_BACK):
	case (EQN_TOK_DOWN):
	case (EQN_TOK_UP):
		subtok = eqn_tok_parse(ep, NULL);
		if (subtok != EQN_TOK__MAX) {
			mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			tok = subtok;
			goto this_tok;
		}
		break;
	case (EQN_TOK_FAT):
	case (EQN_TOK_ROMAN):
	case (EQN_TOK_ITALIC):
	case (EQN_TOK_BOLD):
		while (parent->args == parent->expectargs)
			parent = parent->parent;
		/*
		 * These values apply to the next word or sequence of
		 * words; thus, we mark that we'll have a child with
		 * exactly one of those.
		 */
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_LISTONE;
		parent->expectargs = 1;
		switch (tok) {
		case (EQN_TOK_FAT):
			parent->font = EQNFONT_FAT;
			break;
		case (EQN_TOK_ROMAN):
			parent->font = EQNFONT_ROMAN;
			break;
		case (EQN_TOK_ITALIC):
			parent->font = EQNFONT_ITALIC;
			break;
		case (EQN_TOK_BOLD):
			parent->font = EQNFONT_BOLD;
			break;
		default:
			abort();
		}
		break;
	case (EQN_TOK_SIZE):
	case (EQN_TOK_GSIZE):
		/* Accept two values: integral size and a single. */
		if (NULL == (start = eqn_nexttok(ep, &sz))) {
			mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			break;
		}
		size = mandoc_strntoi(start, sz, 10);
		if (-1 == size) {
			mandoc_msg(MANDOCERR_IT_NONUM, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			break;
		}
		if (EQN_TOK_GSIZE == tok) {
			ep->gsize = size;
			break;
		}
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_LISTONE;
		parent->expectargs = 1;
		parent->size = size;
		break;
	case (EQN_TOK_FROM):
	case (EQN_TOK_TO):
	case (EQN_TOK_SUB):
	case (EQN_TOK_SUP):
		/*
		 * We have a left-right-associative expression.
		 * Repivot under a positional node, open a child scope
		 * and keep on reading.
		 */
		if (parent->last == NULL) {
			mandoc_msg(MANDOCERR_EQN_NOBOX, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			cur = eqn_box_alloc(ep, parent);
			cur->type = EQN_TEXT;
			cur->text = mandoc_strdup("");
		}
		/* Handle the "subsup" and "fromto" positions. */
		if (EQN_TOK_SUP == tok && parent->pos == EQNPOS_SUB) {
			parent->expectargs = 3;
			parent->pos = EQNPOS_SUBSUP;
			break;
		}
		if (EQN_TOK_TO == tok && parent->pos == EQNPOS_FROM) {
			parent->expectargs = 3;
			parent->pos = EQNPOS_FROMTO;
			break;
		}
		switch (tok) {
		case (EQN_TOK_FROM):
			pos = EQNPOS_FROM;
			break;
		case (EQN_TOK_TO):
			pos = EQNPOS_TO;
			break;
		case (EQN_TOK_SUP):
			pos = EQNPOS_SUP;
			break;
		case (EQN_TOK_SUB):
			pos = EQNPOS_SUB;
			break;
		default:
			abort();
		}
		parent = eqn_box_makebinary(ep, pos, parent);
		break;
	case (EQN_TOK_SQRT):
		while (parent->args == parent->expectargs)
			parent = parent->parent;
		/*
		 * Accept a left-right-associative set of arguments just
		 * like sub and sup and friends but without rebalancing
		 * under a pivot.
		 */
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_SUBEXPR;
		parent->pos = EQNPOS_SQRT;
		parent->expectargs = 1;
		break;
	case (EQN_TOK_OVER):
		/*
		 * We have a right-left-associative fraction.
		 * Close out anything that's currently open, then
		 * rebalance and continue reading.
		 */
		if (parent->last == NULL) {
			mandoc_msg(MANDOCERR_EQN_NOBOX, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			cur = eqn_box_alloc(ep, parent);
			cur->type = EQN_TEXT;
			cur->text = mandoc_strdup("");
		}
		while (EQN_SUBEXPR == parent->type)
			parent = parent->parent;
		parent = eqn_box_makebinary(ep, EQNPOS_OVER, parent);
		break;
	case (EQN_TOK_RIGHT):
	case (EQN_TOK_BRACE_CLOSE):
		/*
		 * Close out the existing brace.
		 * FIXME: this is a shitty sentinel: we should really
		 * have a native EQN_BRACE type or whatnot.
		 */
		for (cur = parent; cur != NULL; cur = cur->parent)
			if (cur->type == EQN_LIST &&
			    (tok == EQN_TOK_BRACE_CLOSE ||
			     cur->left != NULL))
				break;
		if (cur == NULL) {
			mandoc_msg(MANDOCERR_BLK_NOTOPEN, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			break;
		}
		parent = cur;
		if (EQN_TOK_RIGHT == tok) {
			if (NULL == (start = eqn_nexttok(ep, &sz))) {
				mandoc_msg(MANDOCERR_REQ_EMPTY,
				    ep->parse, ep->eqn.ln,
				    ep->eqn.pos, eqn_toks[tok]);
				break;
			}
			/* Handling depends on right/left. */
			if (STRNEQ(start, sz, "ceiling", 7)) {
				strlcpy(sym, "\\[rc]", sizeof(sym));
				parent->right = mandoc_strdup(sym);
			} else if (STRNEQ(start, sz, "floor", 5)) {
				strlcpy(sym, "\\[rf]", sizeof(sym));
				parent->right = mandoc_strdup(sym);
			} else
				parent->right = mandoc_strndup(start, sz);
		}
		parent = parent->parent;
		if (tok == EQN_TOK_BRACE_CLOSE &&
		    (parent->type == EQN_PILE ||
		     parent->type == EQN_MATRIX))
			parent = parent->parent;
		/* Close out any "singleton" lists. */
		while (parent->type == EQN_LISTONE &&
		    parent->args == parent->expectargs)
			parent = parent->parent;
		break;
	case (EQN_TOK_BRACE_OPEN):
	case (EQN_TOK_LEFT):
		/*
		 * If we already have something in the stack and we're
		 * in an expression, then rewind til we're not any more
		 * (just like with the text node).
		 */
		while (parent->args == parent->expectargs)
			parent = parent->parent;
		if (EQN_TOK_LEFT == tok &&
		    (start = eqn_nexttok(ep, &sz)) == NULL) {
			mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			break;
		}
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_LIST;
		if (EQN_TOK_LEFT == tok) {
			if (STRNEQ(start, sz, "ceiling", 7)) {
				strlcpy(sym, "\\[lc]", sizeof(sym));
				parent->left = mandoc_strdup(sym);
			} else if (STRNEQ(start, sz, "floor", 5)) {
				strlcpy(sym, "\\[lf]", sizeof(sym));
				parent->left = mandoc_strdup(sym);
			} else
				parent->left = mandoc_strndup(start, sz);
		}
		break;
	case (EQN_TOK_PILE):
	case (EQN_TOK_LPILE):
	case (EQN_TOK_RPILE):
	case (EQN_TOK_CPILE):
	case (EQN_TOK_CCOL):
	case (EQN_TOK_LCOL):
	case (EQN_TOK_RCOL):
		while (parent->args == parent->expectargs)
			parent = parent->parent;
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_PILE;
		parent->expectargs = 1;
		break;
	case (EQN_TOK_ABOVE):
		for (cur = parent; cur != NULL; cur = cur->parent)
			if (cur->type == EQN_PILE)
				break;
		if (cur == NULL) {
			mandoc_msg(MANDOCERR_IT_STRAY, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			break;
		}
		parent = eqn_box_alloc(ep, cur);
		parent->type = EQN_LIST;
		break;
	case (EQN_TOK_MATRIX):
		while (parent->args == parent->expectargs)
			parent = parent->parent;
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_MATRIX;
		parent->expectargs = 1;
		break;
	case (EQN_TOK_EOF):
		/*
		 * End of file!
		 * TODO: make sure we're not in an open subexpression.
		 */
		return ROFF_EQN;
	default:
		assert(tok == EQN_TOK__MAX);
		assert(NULL != p);
		/*
		 * If we already have something in the stack and we're
		 * in an expression, then rewind til we're not any more.
		 */
		while (parent->args == parent->expectargs)
			parent = parent->parent;
		cur = eqn_box_alloc(ep, parent);
		cur->type = EQN_TEXT;
		for (i = 0; i < EQNSYM__MAX; i++)
			if (0 == strcmp(eqnsyms[i].str, p)) {
				(void)snprintf(sym, sizeof(sym),
					"\\[%s]", eqnsyms[i].sym);
				cur->text = mandoc_strdup(sym);
				free(p);
				break;
			}

		if (i == EQNSYM__MAX)
			cur->text = p;
		/*
		 * Post-process list status.
		 */
		while (parent->type == EQN_LISTONE &&
		    parent->args == parent->expectargs)
			parent = parent->parent;
		break;
	}
	goto next_tok;
}

enum rofferr
eqn_end(struct eqn_node **epp)
{
	struct eqn_node	*ep;

	ep = *epp;
	*epp = NULL;

	ep->eqn.root = mandoc_calloc(1, sizeof(struct eqn_box));
	ep->eqn.root->expectargs = UINT_MAX;
	return eqn_parse(ep, ep->eqn.root);
}

void
eqn_free(struct eqn_node *p)
{
	int		 i;

	eqn_box_free(p->eqn.root);

	for (i = 0; i < (int)p->defsz; i++) {
		free(p->defs[i].key);
		free(p->defs[i].val);
	}

	free(p->data);
	free(p->defs);
	free(p);
}
@


1.24
log
@The root of an .EQ tree is always EQN_ROOT, never EQN_LIST,
so delete a redundant NULL check that confused Coverity in CID 1257471;
issue reported by wiz@@, patch differs from what christos@@ did in NetBSD.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.23 2016/01/07 20:18:34 schwarze Exp $ */
d367 3
d371 1
a371 1
	int		 q, diff, lim;
d378 2
a379 1
	lim = 0;
d453 1
@


1.23
log
@Recursive "define" was not detected because "lim" was never
incremented, causing infinite loops.
Fixing CID 1288962.  From christos@@ via wiz@@, both at NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.22 2015/10/06 18:30:43 schwarze Exp $ */
d988 1
a988 1
		if (EQN_TOK_BRACE_CLOSE == tok && parent &&
@


1.22
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.21 2015/03/03 22:22:20 bentley Exp $ */
d449 1
@


1.21
log
@In eqn, "prime" is equivalent to \(fm, and - is equivalent to \(mi.

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.20 2015/01/28 21:10:28 schwarze Exp $ */
d303 1
a303 1
			return(er);
d306 1
a306 1
		return(er);
d325 1
a325 1
	return(ROFF_IGN);
d340 1
a340 1
	return(p);
d354 1
a354 1
			return(&ep->defs[i]);
d356 1
a356 1
	return(NULL);
d383 1
a383 1
		return(NULL);
d391 1
a391 1
		return(NULL);
d433 1
a433 1
		return(start);
d452 1
a452 1
	return(start);
d463 1
a463 1
	return(eqn_next(ep, '"', sz, 1));
d473 1
a473 1
	return(eqn_next(ep, '"', sz, 0));
d499 1
a499 1
		return(EQN_TOK_EOF);
d504 1
a504 1
		return(EQN_TOK__MAX);
d517 1
a517 1
	return(i);
d558 1
a558 1
	return(bp);
d588 1
a588 1
	return(newb);
d713 1
a713 1
		return(ROFF_IGN);
d1061 1
a1061 1
		return(ROFF_EQN);
d1105 1
a1105 1
	return(eqn_parse(ep, ep->eqn.root));
@


1.20
log
@Clean up eqn(7) error handling:
* When "define" fails, do not drop the whole equation.
* Free memory after "undef".
* Use standard mandoc error types instead of rolling our own.
* Delete obfuscating EQN_MSG() macro.
* Add function prototypes while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.19 2014/10/25 15:05:21 schwarze Exp $ */
d195 1
d251 1
a251 1
	{ "prime", "aq" }, /* EQNSYM_prime */
d264 1
@


1.19
log
@Fix a NULL pointer dereference reported
by Theo Buehler <theo at math dot ethz dot ch> on tech@@:
Do not attempt to parse empty equations.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.18 2014/10/25 14:32:07 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014 Ingo Schwarze <schwarze@@openbsd.org>
a31 2
#define	EQN_MSG(t, x) \
	mandoc_msg((t), (x)->parse, (x)->eqn.ln, (x)->eqn.pos, NULL)
d265 15
d379 2
a380 1
		EQN_MSG(MANDOCERR_ROFFLOOP, ep);
d421 2
a422 1
			EQN_MSG(MANDOCERR_ARG_QUOTE, ep);
d616 1
a616 1
static int
d623 11
a633 7
	if (NULL == (start = eqn_nextrawtok(ep, &sz))) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(0);
	} else if (NULL != (def = eqn_def_find(ep, start, sz)))
		def->keysz = 0;

	return(1);
d636 1
a636 1
static int
d644 4
a647 3
	if (NULL == (start = eqn_nextrawtok(ep, &sz))) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(0);
d667 4
a670 7
		ep->defs[i].keysz = sz;
		ep->defs[i].key = mandoc_realloc(
		    ep->defs[i].key, sz + 1);

		memcpy(ep->defs[i].key, start, sz);
		ep->defs[i].key[(int)sz] = '\0';
		def = &ep->defs[i];
d674 8
a681 4

	if (NULL == start) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(-1);
d683 2
a684 1

a685 4
	def->val = mandoc_realloc(def->val, sz + 1);
	memcpy(def->val, start, sz);
	def->val[(int)sz] = '\0';
	return(1);
d691 1
a691 1
static int
d694 3
d698 1
d701 1
a701 5
	struct eqn_box	*cur;
	int		 rc, size;
	size_t		 i, sz;
	char		 sym[64];
	const char	*start;
d704 6
d711 1
a711 1
		return(-1);
d719 1
a719 2
		if ((rc = eqn_undef(ep)) <= 0)
			return(rc);
d723 1
a723 2
		if ((rc = eqn_def(ep)) <= 0)
			return(rc);
d726 4
a729 5
		if (NULL == eqn_nextrawtok(ep, NULL))
			EQN_MSG(MANDOCERR_EQNEOF, ep);
		else if (NULL == eqn_next(ep,
				ep->data[(int)ep->cur], NULL, 0))
			EQN_MSG(MANDOCERR_EQNEOF, ep);
d1059 1
a1059 1
		return(0);
d1103 1
a1103 1
	return(0 == eqn_parse(ep, ep->eqn.root) ? ROFF_EQN : ROFF_IGN);
@


1.18
log
@Report arguments to .EQ as an error, and simplify the code:
* drop trivial wrapper function roff_openeqn()
* drop unused first arg of function eqn_alloc()
* drop usused member "name" of struct eqn_node
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.17 2014/10/16 01:10:06 schwarze Exp $ */
d685 3
a687 1
	assert(NULL != parent);
@


1.17
log
@Implement in-line equations, much needed by Xenocara manuals.
Put the steering into the roff parser rather than into the mdoc
parser such that it works for all macro languages and on both text
and macro lines.
Line breaks and blank characters generated before and after in-line
equations are not perfect yet, but let's do one thing at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.16 2014/10/12 20:08:43 schwarze Exp $ */
a36 2
#define	EQNSTREQ(x, p, sz) \
	STRNEQ((x)->name, (x)->sz, (p), (sz))
d314 1
a314 1
eqn_alloc(const char *name, int pos, int line, struct mparse *parse)
a316 2
	size_t		 sz;
	const char	*end;
a319 10
	if (name && '\0' != *name) {
		sz = strlen(name);
		assert(sz);
		do {
			sz--;
			end = name + (int)sz;
		} while (' ' == *end || '\t' == *end);
		p->eqn.name = mandoc_strndup(name, sz + 1);
	}

a1094 1
	free(p->eqn.name);
@


1.16
log
@bugfix: do not parse quoted strings for tokens; fixes glFrustum(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.15 2014/10/12 19:10:56 schwarze Exp $ */
d589 24
d723 2
@


1.15
log
@Improve error handling in the eqn(7) parser.
Get rid of the first fatal error, MANDOCERR_EQNSYNT.
In eqn(7), there is no need to be bug-compatible with groff, so there
is no need to abondon the whole equation in case of a syntax error.

In particular:
* Skip "back", "delim", "down", "fwd", "gfont", "gsize", "left",
  "right", "size", and "up" without arguments.
* Skip "gsize" and "size" with a non-numeric argument.
* Skip closing delimiters that are not open.
* Skip "above" outside piles.
* For diacritic marks and binary operators without a left operand,
  default to an empty box.
* Let piles and matrices take one argument rather than insisting
  on a braced list.  Let HTML output handle that, too.
* When rewinding, if the root box is guaranteed to match
  the termination condition, no error handling is needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.14 2014/10/10 15:25:06 schwarze Exp $ */
d4 1
d488 1
d493 2
d497 6
@


1.14
log
@Partial eqn(7) rewrite by kristaps@@ in order to get operator precedence right.
@
text
@d1 1
a1 1
/*	$OpenBSD$
d657 1
a657 1
	enum eqn_tok	 tok;
a665 1
again:
d667 5
a671 1
	switch ((tok = eqn_tok_parse(ep, &p))) {
d690 3
a692 4
		if (NULL == eqn_nextrawtok(ep, NULL)) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
		}
d706 6
a711 3
		if (NULL == parent->last) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
d767 6
a772 4
		tok = eqn_tok_parse(ep, NULL);
		if (EQN_TOK__MAX != tok) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
d780 1
a780 4
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
d810 3
a812 2
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
d816 3
a818 2
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
d838 6
a843 3
		if (NULL == parent->last) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
d876 1
a876 4
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
d893 6
a898 3
		if (NULL == parent->last) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
d901 1
a901 4
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
d911 11
a921 5
		while (parent->type != EQN_LIST)
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
a922 4
			if (NULL == parent->left) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
d924 4
a927 2
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
d939 1
a939 4
		if (NULL == (parent = parent->parent)) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
		}
d947 1
a947 4
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
d957 7
a963 4
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
a966 5
			if (NULL == (start = eqn_nexttok(ep, &sz))) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
			/* Handling depends on right/left. */
d985 1
a985 8
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
		if (EQN_TOK_BRACE_OPEN != eqn_tok_parse(ep, NULL)) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
		}
d988 1
a988 2
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_LIST;
d991 9
a999 6
		while (parent->type != EQN_PILE)
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
		parent = eqn_box_alloc(ep, parent);
d1004 1
a1004 8
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
		if (EQN_TOK_BRACE_OPEN != eqn_tok_parse(ep, NULL)) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
		}
d1007 1
a1007 2
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_LIST;
d1023 1
a1023 5
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				free(p);
				return(-1);
			}
d1041 2
a1042 5
			parent->args == parent->expectargs)
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
d1045 1
a1045 1
	goto again;
@


1.13
log
@parse and render "from" and "to" clauses in eqn, and render matrices;
written by kristaps@@ during EuroBSDCon
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.12 2014/10/09 15:21:46 schwarze Exp $ */
d17 2
d31 2
d34 54
a87 1
#define	EQN_MSG(t, x)	 mandoc_msg((t), (x)->parse, (x)->eqn.ln, (x)->eqn.pos, NULL)
d89 47
a135 5
enum	eqn_rest {
	EQN_DESCOPE,
	EQN_ERR,
	EQN_OK,
	EQN_EOF
a200 30
enum	eqnpartt {
	EQN_DEFINE = 0,
	EQN_NDEFINE,
	EQN_TDEFINE,
	EQN_SET,
	EQN_UNDEF,
	EQN_GFONT,
	EQN_GSIZE,
	EQN_BACK,
	EQN_FWD,
	EQN_UP,
	EQN_DOWN,
	EQN__MAX
};

struct	eqnstr {
	const char	*name;
	size_t		 sz;
};

#define	STRNEQ(p1, sz1, p2, sz2) \
	((sz1) == (sz2) && 0 == strncmp((p1), (p2), (sz1)))
#define	EQNSTREQ(x, p, sz) \
	STRNEQ((x)->name, (x)->sz, (p), (sz))

struct	eqnpart {
	struct eqnstr	 str;
	int		(*fp)(struct eqn_node *);
};

d202 1
a202 1
	struct eqnstr	 str;
a205 78
static	enum eqn_rest	 eqn_box(struct eqn_node *, struct eqn_box *);
static	struct eqn_box	*eqn_box_alloc(struct eqn_node *,
				struct eqn_box *);
static	void		 eqn_box_free(struct eqn_box *);
static	struct eqn_def	*eqn_def_find(struct eqn_node *,
				const char *, size_t);
static	int		 eqn_do_gfont(struct eqn_node *);
static	int		 eqn_do_gsize(struct eqn_node *);
static	int		 eqn_do_define(struct eqn_node *);
static	int		 eqn_do_ign1(struct eqn_node *);
static	int		 eqn_do_ign2(struct eqn_node *);
static	int		 eqn_do_tdefine(struct eqn_node *);
static	int		 eqn_do_undef(struct eqn_node *);
static	enum eqn_rest	 eqn_eqn(struct eqn_node *, struct eqn_box *);
static	enum eqn_rest	 eqn_list(struct eqn_node *, struct eqn_box *);
static	enum eqn_rest	 eqn_matrix(struct eqn_node *, struct eqn_box *);
static	const char	*eqn_nexttok(struct eqn_node *, size_t *);
static	const char	*eqn_nextrawtok(struct eqn_node *, size_t *);
static	const char	*eqn_next(struct eqn_node *,
				char, size_t *, int);
static	void		 eqn_rewind(struct eqn_node *);

static	const struct eqnpart eqnparts[EQN__MAX] = {
	{ { "define", 6 }, eqn_do_define }, /* EQN_DEFINE */
	{ { "ndefine", 7 }, eqn_do_define }, /* EQN_NDEFINE */
	{ { "tdefine", 7 }, eqn_do_tdefine }, /* EQN_TDEFINE */
	{ { "set", 3 }, eqn_do_ign2 }, /* EQN_SET */
	{ { "undef", 5 }, eqn_do_undef }, /* EQN_UNDEF */
	{ { "gfont", 5 }, eqn_do_gfont }, /* EQN_GFONT */
	{ { "gsize", 5 }, eqn_do_gsize }, /* EQN_GSIZE */
	{ { "back", 4 }, eqn_do_ign1 }, /* EQN_BACK */
	{ { "fwd", 3 }, eqn_do_ign1 }, /* EQN_FWD */
	{ { "up", 2 }, eqn_do_ign1 }, /* EQN_UP */
	{ { "down", 4 }, eqn_do_ign1 }, /* EQN_DOWN */
};

static	const struct eqnstr eqnmarks[EQNMARK__MAX] = {
	{ "", 0 }, /* EQNMARK_NONE */
	{ "dot", 3 }, /* EQNMARK_DOT */
	{ "dotdot", 6 }, /* EQNMARK_DOTDOT */
	{ "hat", 3 }, /* EQNMARK_HAT */
	{ "tilde", 5 }, /* EQNMARK_TILDE */
	{ "vec", 3 }, /* EQNMARK_VEC */
	{ "dyad", 4 }, /* EQNMARK_DYAD */
	{ "bar", 3 }, /* EQNMARK_BAR */
	{ "under", 5 }, /* EQNMARK_UNDER */
};

static	const struct eqnstr eqnfonts[EQNFONT__MAX] = {
	{ "", 0 }, /* EQNFONT_NONE */
	{ "roman", 5 }, /* EQNFONT_ROMAN */
	{ "bold", 4 }, /* EQNFONT_BOLD */
	{ "fat", 3 }, /* EQNFONT_FAT */
	{ "italic", 6 }, /* EQNFONT_ITALIC */
};

static	const struct eqnstr eqnposs[EQNPOS__MAX] = {
	{ "", 0 }, /* EQNPOS_NONE */
	{ "over", 4 }, /* EQNPOS_OVER */
	{ "sup", 3 }, /* EQNPOS_SUP */
	{ NULL, 0 }, /* EQNPOS_SUBSUP */
	{ "sub", 3 }, /* EQNPOS_SUB */
	{ "to", 2 }, /* EQNPOS_TO */
	{ "from", 4 }, /* EQNPOS_FROM */
};

static	const struct eqnstr eqnpiles[EQNPILE__MAX] = {
	{ "", 0 }, /* EQNPILE_NONE */
	{ "pile", 4 }, /* EQNPILE_PILE */
	{ "cpile", 5 }, /* EQNPILE_CPILE */
	{ "rpile", 5 }, /* EQNPILE_RPILE */
	{ "lpile", 5 }, /* EQNPILE_LPILE */
	{ "col", 3 }, /* EQNPILE_COL */
	{ "ccol", 4 }, /* EQNPILE_CCOL */
	{ "rcol", 4 }, /* EQNPILE_RCOL */
	{ "lcol", 4 }, /* EQNPILE_LCOL */
};

d207 59
a265 59
	{ { "alpha", 5 }, "*a" }, /* EQNSYM_alpha */
	{ { "beta", 4 }, "*b" }, /* EQNSYM_beta */
	{ { "chi", 3 }, "*x" }, /* EQNSYM_chi */
	{ { "delta", 5 }, "*d" }, /* EQNSYM_delta */
	{ { "epsilon", 7 }, "*e" }, /* EQNSYM_epsilon */
	{ { "eta", 3 }, "*y" }, /* EQNSYM_eta */
	{ { "gamma", 5 }, "*g" }, /* EQNSYM_gamma */
	{ { "iota", 4 }, "*i" }, /* EQNSYM_iota */
	{ { "kappa", 5 }, "*k" }, /* EQNSYM_kappa */
	{ { "lambda", 6 }, "*l" }, /* EQNSYM_lambda */
	{ { "mu", 2 }, "*m" }, /* EQNSYM_mu */
	{ { "nu", 2 }, "*n" }, /* EQNSYM_nu */
	{ { "omega", 5 }, "*w" }, /* EQNSYM_omega */
	{ { "omicron", 7 }, "*o" }, /* EQNSYM_omicron */
	{ { "phi", 3 }, "*f" }, /* EQNSYM_phi */
	{ { "pi", 2 }, "*p" }, /* EQNSYM_pi */
	{ { "psi", 2 }, "*q" }, /* EQNSYM_psi */
	{ { "rho", 3 }, "*r" }, /* EQNSYM_rho */
	{ { "sigma", 5 }, "*s" }, /* EQNSYM_sigma */
	{ { "tau", 3 }, "*t" }, /* EQNSYM_tau */
	{ { "theta", 5 }, "*h" }, /* EQNSYM_theta */
	{ { "upsilon", 7 }, "*u" }, /* EQNSYM_upsilon */
	{ { "xi", 2 }, "*c" }, /* EQNSYM_xi */
	{ { "zeta", 4 }, "*z" }, /* EQNSYM_zeta */
	{ { "DELTA", 5 }, "*D" }, /* EQNSYM_DELTA */
	{ { "GAMMA", 5 }, "*G" }, /* EQNSYM_GAMMA */
	{ { "LAMBDA", 6 }, "*L" }, /* EQNSYM_LAMBDA */
	{ { "OMEGA", 5 }, "*W" }, /* EQNSYM_OMEGA */
	{ { "PHI", 3 }, "*F" }, /* EQNSYM_PHI */
	{ { "PI", 2 }, "*P" }, /* EQNSYM_PI */
	{ { "PSI", 3 }, "*Q" }, /* EQNSYM_PSI */
	{ { "SIGMA", 5 }, "*S" }, /* EQNSYM_SIGMA */
	{ { "THETA", 5 }, "*H" }, /* EQNSYM_THETA */
	{ { "UPSILON", 7 }, "*U" }, /* EQNSYM_UPSILON */
	{ { "XI", 2 }, "*C" }, /* EQNSYM_XI */
	{ { "inter", 5 }, "ca" }, /* EQNSYM_inter */
	{ { "union", 5 }, "cu" }, /* EQNSYM_union */
	{ { "prod", 4 }, "product" }, /* EQNSYM_prod */
	{ { "int", 3 }, "integral" }, /* EQNSYM_int */
	{ { "sum", 3 }, "sum" }, /* EQNSYM_sum */
	{ { "grad", 4 }, "gr" }, /* EQNSYM_grad */
	{ { "del", 3 }, "gr" }, /* EQNSYM_del */
	{ { "times", 5 }, "mu" }, /* EQNSYM_times */
	{ { "cdot", 4 }, "pc" }, /* EQNSYM_cdot */
	{ { "nothing", 7 }, "&" }, /* EQNSYM_nothing */
	{ { "approx", 6 }, "~~" }, /* EQNSYM_approx */
	{ { "prime", 5 }, "aq" }, /* EQNSYM_prime */
	{ { "half", 4 }, "12" }, /* EQNSYM_half */
	{ { "partial", 7 }, "pd" }, /* EQNSYM_partial */
	{ { "inf", 3 }, "if" }, /* EQNSYM_inf */
	{ { ">>", 2 }, ">>" }, /* EQNSYM_muchgreat */
	{ { "<<", 2 }, "<<" }, /* EQNSYM_muchless */
	{ { "<-", 2 }, "<-" }, /* EQNSYM_larrow */
	{ { "->", 2 }, "->" }, /* EQNSYM_rarrow */
	{ { "+-", 2 }, "+-" }, /* EQNSYM_pm */
	{ { "!=", 2 }, "!=" }, /* EQNSYM_nequal */
	{ { "==", 2 }, "==" }, /* EQNSYM_equiv */
	{ { "<=", 2 }, "<=" }, /* EQNSYM_lessequal */
	{ { ">=", 2 }, ">=" }, /* EQNSYM_moreequal */
a267 1

d341 5
a345 309
enum rofferr
eqn_end(struct eqn_node **epp)
{
	struct eqn_node	*ep;
	struct eqn_box	*root;
	enum eqn_rest	 c;

	ep = *epp;
	*epp = NULL;

	ep->eqn.root = mandoc_calloc(1, sizeof(struct eqn_box));

	root = ep->eqn.root;
	root->type = EQN_ROOT;

	if (0 == ep->sz)
		return(ROFF_IGN);

	if (EQN_DESCOPE == (c = eqn_eqn(ep, root))) {
		EQN_MSG(MANDOCERR_EQNNSCOPE, ep);
		c = EQN_ERR;
	}

	return(EQN_EOF == c ? ROFF_EQN : ROFF_IGN);
}

static enum eqn_rest
eqn_eqn(struct eqn_node *ep, struct eqn_box *last)
{
	struct eqn_box	*bp;
	enum eqn_rest	 c;

	bp = eqn_box_alloc(ep, last);
	bp->type = EQN_SUBEXPR;

	while (EQN_OK == (c = eqn_box(ep, bp)))
		/* Spin! */ ;

	return(c);
}

static enum eqn_rest
eqn_matrix(struct eqn_node *ep, struct eqn_box *last)
{
	struct eqn_box	*bp;
	const char	*start;
	size_t		 sz;
	enum eqn_rest	 c;

	bp = eqn_box_alloc(ep, last);
	bp->type = EQN_MATRIX;

	if (NULL == (start = eqn_nexttok(ep, &sz))) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(EQN_ERR);
	}
	if ( ! STRNEQ(start, sz, "{", 1)) {
		EQN_MSG(MANDOCERR_EQNSYNT, ep);
		return(EQN_ERR);
	}

	while (EQN_OK == (c = eqn_box(ep, bp)))
		switch (bp->last->pile) {
		case EQNPILE_LCOL:
			/* FALLTHROUGH */
		case EQNPILE_CCOL:
			/* FALLTHROUGH */
		case EQNPILE_RCOL:
			continue;
		default:
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(EQN_ERR);
		};

	if (EQN_DESCOPE != c) {
		if (EQN_EOF == c)
			EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(EQN_ERR);
	}

	eqn_rewind(ep);
	start = eqn_nexttok(ep, &sz);
	assert(start);
	if (STRNEQ(start, sz, "}", 1))
		return(EQN_OK);

	EQN_MSG(MANDOCERR_EQNBADSCOPE, ep);
	return(EQN_ERR);
}

static enum eqn_rest
eqn_list(struct eqn_node *ep, struct eqn_box *last)
{
	struct eqn_box	*bp;
	const char	*start;
	size_t		 sz;
	enum eqn_rest	 c;

	bp = eqn_box_alloc(ep, last);
	bp->type = EQN_LIST;

	if (NULL == (start = eqn_nexttok(ep, &sz))) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(EQN_ERR);
	}
	if ( ! STRNEQ(start, sz, "{", 1)) {
		EQN_MSG(MANDOCERR_EQNSYNT, ep);
		return(EQN_ERR);
	}

	while (EQN_DESCOPE == (c = eqn_eqn(ep, bp))) {
		eqn_rewind(ep);
		start = eqn_nexttok(ep, &sz);
		assert(start);
		if ( ! STRNEQ(start, sz, "above", 5))
			break;
	}

	if (EQN_DESCOPE != c) {
		if (EQN_ERR != c)
			EQN_MSG(MANDOCERR_EQNSCOPE, ep);
		return(EQN_ERR);
	}

	eqn_rewind(ep);
	start = eqn_nexttok(ep, &sz);
	assert(start);
	if (STRNEQ(start, sz, "}", 1))
		return(EQN_OK);

	EQN_MSG(MANDOCERR_EQNBADSCOPE, ep);
	return(EQN_ERR);
}

static enum eqn_rest
eqn_box(struct eqn_node *ep, struct eqn_box *last)
{
	size_t		 sz;
	const char	*start;
	char		*left;
	char		 sym[64];
	enum eqn_rest	 c;
	int		 i, size;
	struct eqn_box	*bp;

	if (NULL == (start = eqn_nexttok(ep, &sz)))
		return(EQN_EOF);

	if (STRNEQ(start, sz, "}", 1))
		return(EQN_DESCOPE);
	else if (STRNEQ(start, sz, "right", 5))
		return(EQN_DESCOPE);
	else if (STRNEQ(start, sz, "above", 5))
		return(EQN_DESCOPE);
	else if (STRNEQ(start, sz, "mark", 4))
		return(EQN_OK);
	else if (STRNEQ(start, sz, "lineup", 6))
		return(EQN_OK);

	for (i = 0; i < (int)EQN__MAX; i++) {
		if ( ! EQNSTREQ(&eqnparts[i].str, start, sz))
			continue;
		return((*eqnparts[i].fp)(ep) ? EQN_OK : EQN_ERR);
	}

	if (STRNEQ(start, sz, "{", 1)) {
		if (EQN_DESCOPE != (c = eqn_eqn(ep, last))) {
			if (EQN_ERR != c)
				EQN_MSG(MANDOCERR_EQNSCOPE, ep);
			return(EQN_ERR);
		}
		eqn_rewind(ep);
		start = eqn_nexttok(ep, &sz);
		assert(start);
		if (STRNEQ(start, sz, "}", 1))
			return(EQN_OK);
		EQN_MSG(MANDOCERR_EQNBADSCOPE, ep);
		return(EQN_ERR);
	}

	for (i = 0; i < (int)EQNPILE__MAX; i++) {
		if ( ! EQNSTREQ(&eqnpiles[i], start, sz))
			continue;
		if (EQN_OK == (c = eqn_list(ep, last)))
			last->last->pile = (enum eqn_pilet)i;
		return(c);
	}

	if (STRNEQ(start, sz, "matrix", 6))
		return(eqn_matrix(ep, last));

	if (STRNEQ(start, sz, "left", 4)) {
		if (NULL == (start = eqn_nexttok(ep, &sz))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		}
		left = mandoc_strndup(start, sz);
		c = eqn_eqn(ep, last);
		if (last->last)
			last->last->left = left;
		else
			free(left);
		if (EQN_DESCOPE != c)
			return(c);
		assert(last->last);
		eqn_rewind(ep);
		start = eqn_nexttok(ep, &sz);
		assert(start);
		if ( ! STRNEQ(start, sz, "right", 5))
			return(EQN_DESCOPE);
		if (NULL == (start = eqn_nexttok(ep, &sz))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		}
		last->last->right = mandoc_strndup(start, sz);
		return(EQN_OK);
	}

	/*
	 * Positional elements (e.g., over, sub, sup, ...).
	 */
	for (i = 0; i < (int)EQNPOS__MAX; i++) {
		/* Some elements don't have names (are virtual). */
		if (NULL == eqnposs[i].name)
			continue;
		else if ( ! EQNSTREQ(&eqnposs[i], start, sz))
			continue;
		if (NULL == last->last) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(EQN_ERR);
		}
		/*
		 * If we encounter x sub y sup z, then according to the
		 * eqn manual, we regard this as x subsup y z.
		 */
		if (EQNPOS_SUP == i &&
			NULL != last->last->prev &&
			EQNPOS_SUB == last->last->prev->pos)
			last->last->prev->pos = EQNPOS_SUBSUP;
		else if (EQNPOS_TO == i &&
			NULL != last->last->prev &&
			EQNPOS_FROM == last->last->prev->pos)
			last->last->prev->pos = EQNPOS_FROMTO;
		else
			last->last->pos = (enum eqn_post)i;

		if (EQN_EOF == (c = eqn_box(ep, last))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		}
		return(c);
	}

	for (i = 0; i < (int)EQNMARK__MAX; i++) {
		if ( ! EQNSTREQ(&eqnmarks[i], start, sz))
			continue;
		if (NULL == last->last) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(EQN_ERR);
		}
		last->last->mark = (enum eqn_markt)i;
		if (EQN_EOF == (c = eqn_box(ep, last))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		}
		return(c);
	}

	for (i = 0; i < (int)EQNFONT__MAX; i++) {
		if ( ! EQNSTREQ(&eqnfonts[i], start, sz))
			continue;
		if (EQN_EOF == (c = eqn_box(ep, last))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		} else if (EQN_OK == c)
			last->last->font = (enum eqn_fontt)i;
		return(c);
	}

	if (STRNEQ(start, sz, "size", 4)) {
		if (NULL == (start = eqn_nexttok(ep, &sz))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		}
		size = mandoc_strntoi(start, sz, 10);
		if (EQN_EOF == (c = eqn_box(ep, last))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		} else if (EQN_OK != c)
			return(c);
		last->last->size = size;
	}

	bp = eqn_box_alloc(ep, last);
	bp->type = EQN_TEXT;
	for (i = 0; i < (int)EQNSYM__MAX; i++)
		if (EQNSTREQ(&eqnsyms[i].str, start, sz)) {
			sym[63] = '\0';
			(void)snprintf(sym, 62, "\\[%s]", eqnsyms[i].sym);
			bp->text = mandoc_strdup(sym);
			return(EQN_OK);
		}

	bp->text = mandoc_strndup(start, sz);
	return(EQN_OK);
}

void
eqn_free(struct eqn_node *p)
d349 4
a352 1
	eqn_box_free(p->eqn.root);
d354 1
a354 64
	for (i = 0; i < (int)p->defsz; i++) {
		free(p->defs[i].key);
		free(p->defs[i].val);
	}

	free(p->eqn.name);
	free(p->data);
	free(p->defs);
	free(p);
}

static struct eqn_box *
eqn_box_alloc(struct eqn_node *ep, struct eqn_box *parent)
{
	struct eqn_box	*bp;

	bp = mandoc_calloc(1, sizeof(struct eqn_box));
	bp->parent = parent;
	bp->size = ep->gsize;

	if (NULL != parent->first) {
		parent->last->next = bp;
		bp->prev = parent->last;
	} else
		parent->first = bp;

	parent->last = bp;
	return(bp);
}

static void
eqn_box_free(struct eqn_box *bp)
{

	if (bp->first)
		eqn_box_free(bp->first);
	if (bp->next)
		eqn_box_free(bp->next);

	free(bp->text);
	free(bp->left);
	free(bp->right);
	free(bp);
}

static const char *
eqn_nextrawtok(struct eqn_node *ep, size_t *sz)
{

	return(eqn_next(ep, '"', sz, 0));
}

static const char *
eqn_nexttok(struct eqn_node *ep, size_t *sz)
{

	return(eqn_next(ep, '"', sz, 1));
}

static void
eqn_rewind(struct eqn_node *ep)
{

	ep->cur = ep->rew;
d357 5
d451 58
a508 2
static int
eqn_do_ign1(struct eqn_node *ep)
d511 4
a514 4
	if (NULL == eqn_nextrawtok(ep, NULL))
		EQN_MSG(MANDOCERR_EQNEOF, ep);
	else
		return(1);
d516 6
a521 1
	return(0);
d524 5
a528 2
static int
eqn_do_ign2(struct eqn_node *ep)
d530 17
d548 11
a558 6
	if (NULL == eqn_nextrawtok(ep, NULL))
		EQN_MSG(MANDOCERR_EQNEOF, ep);
	else if (NULL == eqn_nextrawtok(ep, NULL))
		EQN_MSG(MANDOCERR_EQNEOF, ep);
	else
		return(1);
d560 16
a575 1
	return(0);
d578 3
d582 1
a582 1
eqn_do_tdefine(struct eqn_node *ep)
d584 3
d588 1
a588 1
	if (NULL == eqn_nextrawtok(ep, NULL))
d590 3
a592 4
	else if (NULL == eqn_next(ep, ep->data[(int)ep->cur], NULL, 0))
		EQN_MSG(MANDOCERR_EQNEOF, ep);
	else
		return(1);
d594 1
a594 1
	return(0);
d598 1
a598 1
eqn_do_define(struct eqn_node *ep)
a613 1

d640 1
a640 1
		return(0);
d650 3
d654 1
a654 1
eqn_do_gfont(struct eqn_node *ep)
d656 8
d665 2
a666 6
	if (NULL == eqn_nextrawtok(ep, NULL)) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(0);
	}
	return(1);
}
d668 71
a738 5
static int
eqn_do_gsize(struct eqn_node *ep)
{
	const char	*start;
	size_t		 sz;
d740 285
a1024 2
	if (NULL == (start = eqn_nextrawtok(ep, &sz))) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
d1026 36
d1063 1
a1063 2
	ep->gsize = mandoc_strntoi(start, sz, 10);
	return(1);
d1066 2
a1067 2
static int
eqn_do_undef(struct eqn_node *ep)
d1069 1
a1069 3
	const char	*start;
	struct eqn_def	*def;
	size_t		 sz;
d1071 2
a1072 5
	if (NULL == (start = eqn_nextrawtok(ep, &sz))) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(0);
	} else if (NULL != (def = eqn_def_find(ep, start, sz)))
		def->keysz = 0;
d1074 3
a1076 1
	return(1);
d1079 2
a1080 2
static struct eqn_def *
eqn_def_find(struct eqn_node *ep, const char *key, size_t sz)
d1084 6
a1089 4
	for (i = 0; i < (int)ep->defsz; i++)
		if (ep->defs[i].keysz && STRNEQ(ep->defs[i].key,
		    ep->defs[i].keysz, key, sz))
			return(&ep->defs[i]);
d1091 4
a1094 1
	return(NULL);
@


1.12
log
@parse simultaneous sub- and superscripts
and make the eqn_box list doubly linked;
written by kristaps@@ during EuroBSDCon
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.11 2014/07/06 19:08:56 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
d590 4
@


1.11
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.10 2014/07/04 16:11:41 schwarze Exp $ */
d197 1
d569 3
d573 4
a576 1
		if ( ! EQNSTREQ(&eqnposs[i], start, sz))
d582 11
a592 1
		last->last->pos = (enum eqn_post)i;
d681 4
a684 1
	if (NULL == parent->first)
a685 2
	else
		parent->last->next = bp;
@


1.10
log
@Clean up messages regarding excess arguments:
* Downgrade ".Bf -emphasis Em" from FATAL to WARNING.
* Mention the macros, the arguments, and the fallbacks.
* Hierarchical naming.
Also fix the handling of excess .It head arguments in -Tman.
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.9 2014/04/23 21:06:33 schwarze Exp $ */
d767 1
a767 1
			EQN_MSG(MANDOCERR_BADQUOTE, ep);
@


1.9
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
* Change eight reallocs to reallocarray to be safe from overflows.
* Change one malloc to reallocarray to be safe from overflows.
* Change one calloc to reallocarray, no zeroing needed.
* Change the order of arguments of three callocs (aesthetical).
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.8 2014/04/20 19:39:35 schwarze Exp $ */
d299 2
a300 1
		mandoc_msg(MANDOCERR_ARGSLOST, ep->parse, ln, pos, NULL);
@


1.8
log
@make sure static buffers for snprintf(3) are large enough
and cast snprintf return value to (void) where they are
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.7 2014/04/20 16:44:44 schwarze Exp $ */
d863 2
a864 2
			ep->defs = mandoc_realloc(ep->defs,
			    ep->defsz * sizeof(struct eqn_def));
@


1.7
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.6 2014/03/21 22:17:01 schwarze Exp $ */
d627 1
a627 1
			snprintf(sym, 62, "\\[%s]", eqnsyms[i].sym);
@


1.6
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.5 2011/09/18 15:54:48 schwarze Exp $ */
a136 1

d138 1
a138 1
static	struct eqn_box	*eqn_box_alloc(struct eqn_node *, 
d141 1
a141 1
static	struct eqn_def	*eqn_def_find(struct eqn_node *, 
d155 1
a155 1
static	const char	*eqn_next(struct eqn_node *, 
d276 1
a276 1
/* ARGSUSED */
d278 1
a278 1
eqn_read(struct eqn_node **epp, int ln, 
d297 1
a297 1
		if ('\0' == *p) 
d412 1
a412 1
		case (EQNPILE_LCOL):
d414 1
a414 1
		case (EQNPILE_CCOL):
d416 1
a416 1
		case (EQNPILE_RCOL):
d511 2
a512 3
		return((*eqnparts[i].fp)(ep) ? 
				EQN_OK : EQN_ERR);
	} 
d527 1
a527 1
	} 
d573 1
a573 1
		} 
d588 1
a588 1
		} 
d760 3
a762 3
				'\t' == ep->data[(int)ep->cur] ||
				'^' == ep->data[(int)ep->cur] ||
				'~' == ep->data[(int)ep->cur])
d788 2
a789 2
		memmove(start + *sz + diff, start + *sz, 
				(strlen(start) - *sz) + 1);
d850 2
a851 2
	/* 
	 * Search for a key that already exists. 
d863 2
a864 3
			ep->defs = mandoc_realloc
				(ep->defs, ep->defsz * 
				 sizeof(struct eqn_def));
d869 2
a870 2
		ep->defs[i].key = mandoc_realloc
			(ep->defs[i].key, sz + 1);
d898 1
a898 1
	} 
d911 1
a911 1
	} 
d937 3
a939 3
	for (i = 0; i < (int)ep->defsz; i++) 
		if (ep->defs[i].keysz && STRNEQ(ep->defs[i].key, 
					ep->defs[i].keysz, key, sz))
@


1.5
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.4 2011/09/18 10:25:28 schwarze Exp $ */
a16 4
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

d25 1
@


1.4
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.3 2011/04/24 16:22:02 schwarze Exp $ */
d26 1
@


1.3
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.2 2011/04/21 22:59:54 schwarze Exp $ */
d22 2
d31 248
d281 2
a282 1
eqn_read(struct eqn_node **epp, int ln, const char *p, int offs)
d286 1
a286 5

	if (0 == strcmp(p, ".EN")) {
		*epp = NULL;
		return(ROFF_EQN);
	}
d290 15
a304 4
	sz = strlen(&p[offs]);
	ep->eqn.data = mandoc_realloc(ep->eqn.data, ep->eqn.sz + sz + 1);
	if (0 == ep->eqn.sz)
		*ep->eqn.data = '\0';
d306 16
a321 2
	ep->eqn.sz += sz;
	strlcat(ep->eqn.data, &p[offs], ep->eqn.sz + 1);
d326 1
a326 1
eqn_alloc(int pos, int line)
d329 2
d333 13
a345 1
	p->eqn.line = line;
d347 1
d352 136
a487 3
/* ARGSUSED */
void
eqn_end(struct eqn_node *e)
d489 122
d612 26
a637 1
	/* Nothing to do. */
d643 8
d652 3
a654 1
	free(p->eqn.data);
d656 292
@


1.2
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.1 2011/03/21 00:48:02 schwarze Exp $ */
a25 1
#include "roff.h"
@


1.1
log
@This file was forgotten when importing the foundation for eqn(7) support.
Written by kristaps@@.
Sorry, and thanks to jmc@@ for noticing so quickly.
@
text
@d1 1
a1 1
/*	$Id: tbl.c,v 1.22 2011/01/25 12:24:27 schwarze Exp $ */
d66 1
@

