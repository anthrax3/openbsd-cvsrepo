head	1.36;
access;
symbols
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.5.0.12
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.8
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.36
date	2017.07.05.15.03.20;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	zLikkELVVpcrsPcx;

1.35
date	2017.06.29.16.30.47;	author schwarze;	state Exp;
branches;
next	1.34;
commitid	xPQxEHKCTpsihGpE;

1.34
date	2017.06.26.19.53.00;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	QtF24OjU14jw9cWi;

1.33
date	2017.06.26.11.04.26;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	cWKGKoteOlGKKSN2;

1.32
date	2017.06.23.21.04.34;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	nbhFlrLRQ6B2a2B7;

1.31
date	2017.06.23.00.30.17;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	dq6RlT6lSy6aLY7r;

1.30
date	2017.06.22.00.30.06;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	pG4OPeWPwKS1lip6;

1.29
date	2017.06.21.20.47.46;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	mrKGnv0wZHtvAwXC;

1.28
date	2017.06.21.18.37.38;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	lIixG24cwnISrihx;

1.27
date	2017.06.21.18.03.50;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	ARPxRy5lb4dAMkwL;

1.26
date	2017.06.20.17.24.09;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	0zrcQOD2y2LNXh12;

1.25
date	2017.03.11.15.42.03;	author schwarze;	state Exp;
branches;
next	1.24;
commitid	0gYtsbJYnd0pkWWT;

1.24
date	2016.01.08.00.50.20;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	j7u5eUVL92qSR14e;

1.23
date	2016.01.07.20.18.34;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	LasTtIKiSnQiX82S;

1.22
date	2015.10.06.18.30.43;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	hxQV8O1pNUaef4ir;

1.21
date	2015.03.03.22.22.20;	author bentley;	state Exp;
branches;
next	1.20;
commitid	TfVR2PrsOygyg8f4;

1.20
date	2015.01.28.21.10.28;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	fvM2x3xHE0B4upcu;

1.19
date	2014.10.25.15.05.21;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	BCa9wYcViqQs3B67;

1.18
date	2014.10.25.14.32.07;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	0lmH8qIaoxl2FlKf;

1.17
date	2014.10.16.01.10.06;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	3N6FMKugsVoc1dko;

1.16
date	2014.10.12.20.08.43;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	mt56FCuqIouBcpkA;

1.15
date	2014.10.12.19.10.56;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	oFUg4cCWEgutyqUr;

1.14
date	2014.10.10.15.25.06;	author schwarze;	state Exp;
branches;
next	1.13;
commitid	MpqXOG3dhTX11YQI;

1.13
date	2014.10.09.15.59.08;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	Wy6YFSKH1ddfqJiG;

1.12
date	2014.10.09.15.21.46;	author schwarze;	state Exp;
branches;
next	1.11;
commitid	QH4xwyTeTm9ROYu8;

1.11
date	2014.07.06.19.08.56;	author schwarze;	state Exp;
branches;
next	1.10;
commitid	rolX8OitNNoUBJoD;

1.10
date	2014.07.04.16.11.41;	author schwarze;	state Exp;
branches;
next	1.9;
commitid	sgqZ9hnRM3L6yvgn;

1.9
date	2014.04.23.21.06.33;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.20.19.39.35;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2011.03.21.00.48.02;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.36
log
@The EQN_LISTONE box type is pointless.
Simplify by just using EQN_LIST with expectargs = 1.
Noticed while investigating a bug report from bentley@@.
No functional change.
@
text
@/*	$OpenBSD: eqn.c,v 1.35 2017/06/29 16:30:47 schwarze Exp $ */
/*
 * Copyright (c) 2011, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2014, 2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mandoc.h"
#include "mandoc_aux.h"
#include "libmandoc.h"
#include "libroff.h"

#define	EQN_NEST_MAX	 128 /* maximum nesting of defines */
#define	STRNEQ(p1, sz1, p2, sz2) \
	((sz1) == (sz2) && 0 == strncmp((p1), (p2), (sz1)))

enum	eqn_tok {
	EQN_TOK_DYAD = 0,
	EQN_TOK_VEC,
	EQN_TOK_UNDER,
	EQN_TOK_BAR,
	EQN_TOK_TILDE,
	EQN_TOK_HAT,
	EQN_TOK_DOT,
	EQN_TOK_DOTDOT,
	EQN_TOK_FWD,
	EQN_TOK_BACK,
	EQN_TOK_DOWN,
	EQN_TOK_UP,
	EQN_TOK_FAT,
	EQN_TOK_ROMAN,
	EQN_TOK_ITALIC,
	EQN_TOK_BOLD,
	EQN_TOK_SIZE,
	EQN_TOK_SUB,
	EQN_TOK_SUP,
	EQN_TOK_SQRT,
	EQN_TOK_OVER,
	EQN_TOK_FROM,
	EQN_TOK_TO,
	EQN_TOK_BRACE_OPEN,
	EQN_TOK_BRACE_CLOSE,
	EQN_TOK_GSIZE,
	EQN_TOK_GFONT,
	EQN_TOK_MARK,
	EQN_TOK_LINEUP,
	EQN_TOK_LEFT,
	EQN_TOK_RIGHT,
	EQN_TOK_PILE,
	EQN_TOK_LPILE,
	EQN_TOK_RPILE,
	EQN_TOK_CPILE,
	EQN_TOK_MATRIX,
	EQN_TOK_CCOL,
	EQN_TOK_LCOL,
	EQN_TOK_RCOL,
	EQN_TOK_DELIM,
	EQN_TOK_DEFINE,
	EQN_TOK_TDEFINE,
	EQN_TOK_NDEFINE,
	EQN_TOK_UNDEF,
	EQN_TOK_ABOVE,
	EQN_TOK__MAX,
	EQN_TOK_FUNC,
	EQN_TOK_QUOTED,
	EQN_TOK_SYM,
	EQN_TOK_EOF
};

static	const char *eqn_toks[EQN_TOK__MAX] = {
	"dyad", /* EQN_TOK_DYAD */
	"vec", /* EQN_TOK_VEC */
	"under", /* EQN_TOK_UNDER */
	"bar", /* EQN_TOK_BAR */
	"tilde", /* EQN_TOK_TILDE */
	"hat", /* EQN_TOK_HAT */
	"dot", /* EQN_TOK_DOT */
	"dotdot", /* EQN_TOK_DOTDOT */
	"fwd", /* EQN_TOK_FWD * */
	"back", /* EQN_TOK_BACK */
	"down", /* EQN_TOK_DOWN */
	"up", /* EQN_TOK_UP */
	"fat", /* EQN_TOK_FAT */
	"roman", /* EQN_TOK_ROMAN */
	"italic", /* EQN_TOK_ITALIC */
	"bold", /* EQN_TOK_BOLD */
	"size", /* EQN_TOK_SIZE */
	"sub", /* EQN_TOK_SUB */
	"sup", /* EQN_TOK_SUP */
	"sqrt", /* EQN_TOK_SQRT */
	"over", /* EQN_TOK_OVER */
	"from", /* EQN_TOK_FROM */
	"to", /* EQN_TOK_TO */
	"{", /* EQN_TOK_BRACE_OPEN */
	"}", /* EQN_TOK_BRACE_CLOSE */
	"gsize", /* EQN_TOK_GSIZE */
	"gfont", /* EQN_TOK_GFONT */
	"mark", /* EQN_TOK_MARK */
	"lineup", /* EQN_TOK_LINEUP */
	"left", /* EQN_TOK_LEFT */
	"right", /* EQN_TOK_RIGHT */
	"pile", /* EQN_TOK_PILE */
	"lpile", /* EQN_TOK_LPILE */
	"rpile", /* EQN_TOK_RPILE */
	"cpile", /* EQN_TOK_CPILE */
	"matrix", /* EQN_TOK_MATRIX */
	"ccol", /* EQN_TOK_CCOL */
	"lcol", /* EQN_TOK_LCOL */
	"rcol", /* EQN_TOK_RCOL */
	"delim", /* EQN_TOK_DELIM */
	"define", /* EQN_TOK_DEFINE */
	"tdefine", /* EQN_TOK_TDEFINE */
	"ndefine", /* EQN_TOK_NDEFINE */
	"undef", /* EQN_TOK_UNDEF */
	"above", /* EQN_TOK_ABOVE */
};

static	const char *const eqn_func[] = {
	"acos",	"acsc",	"and",	"arc",	"asec",	"asin", "atan",
	"cos",	"cosh", "coth",	"csc",	"det",	"exp",	"for",
	"if",	"lim",	"ln",	"log",	"max",	"min",
	"sec",	"sin",	"sinh",	"tan",	"tanh",	"Im",	"Re",
};

enum	eqn_symt {
	EQNSYM_alpha = 0,
	EQNSYM_beta,
	EQNSYM_chi,
	EQNSYM_delta,
	EQNSYM_epsilon,
	EQNSYM_eta,
	EQNSYM_gamma,
	EQNSYM_iota,
	EQNSYM_kappa,
	EQNSYM_lambda,
	EQNSYM_mu,
	EQNSYM_nu,
	EQNSYM_omega,
	EQNSYM_omicron,
	EQNSYM_phi,
	EQNSYM_pi,
	EQNSYM_ps,
	EQNSYM_rho,
	EQNSYM_sigma,
	EQNSYM_tau,
	EQNSYM_theta,
	EQNSYM_upsilon,
	EQNSYM_xi,
	EQNSYM_zeta,
	EQNSYM_DELTA,
	EQNSYM_GAMMA,
	EQNSYM_LAMBDA,
	EQNSYM_OMEGA,
	EQNSYM_PHI,
	EQNSYM_PI,
	EQNSYM_PSI,
	EQNSYM_SIGMA,
	EQNSYM_THETA,
	EQNSYM_UPSILON,
	EQNSYM_XI,
	EQNSYM_inter,
	EQNSYM_union,
	EQNSYM_prod,
	EQNSYM_int,
	EQNSYM_sum,
	EQNSYM_grad,
	EQNSYM_del,
	EQNSYM_times,
	EQNSYM_cdot,
	EQNSYM_nothing,
	EQNSYM_approx,
	EQNSYM_prime,
	EQNSYM_half,
	EQNSYM_partial,
	EQNSYM_inf,
	EQNSYM_muchgreat,
	EQNSYM_muchless,
	EQNSYM_larrow,
	EQNSYM_rarrow,
	EQNSYM_pm,
	EQNSYM_nequal,
	EQNSYM_equiv,
	EQNSYM_lessequal,
	EQNSYM_moreequal,
	EQNSYM_minus,
	EQNSYM__MAX
};

struct	eqnsym {
	const char	*str;
	const char	*sym;
};

static	const struct eqnsym eqnsyms[EQNSYM__MAX] = {
	{ "alpha", "*a" }, /* EQNSYM_alpha */
	{ "beta", "*b" }, /* EQNSYM_beta */
	{ "chi", "*x" }, /* EQNSYM_chi */
	{ "delta", "*d" }, /* EQNSYM_delta */
	{ "epsilon", "*e" }, /* EQNSYM_epsilon */
	{ "eta", "*y" }, /* EQNSYM_eta */
	{ "gamma", "*g" }, /* EQNSYM_gamma */
	{ "iota", "*i" }, /* EQNSYM_iota */
	{ "kappa", "*k" }, /* EQNSYM_kappa */
	{ "lambda", "*l" }, /* EQNSYM_lambda */
	{ "mu", "*m" }, /* EQNSYM_mu */
	{ "nu", "*n" }, /* EQNSYM_nu */
	{ "omega", "*w" }, /* EQNSYM_omega */
	{ "omicron", "*o" }, /* EQNSYM_omicron */
	{ "phi", "*f" }, /* EQNSYM_phi */
	{ "pi", "*p" }, /* EQNSYM_pi */
	{ "psi", "*q" }, /* EQNSYM_psi */
	{ "rho", "*r" }, /* EQNSYM_rho */
	{ "sigma", "*s" }, /* EQNSYM_sigma */
	{ "tau", "*t" }, /* EQNSYM_tau */
	{ "theta", "*h" }, /* EQNSYM_theta */
	{ "upsilon", "*u" }, /* EQNSYM_upsilon */
	{ "xi", "*c" }, /* EQNSYM_xi */
	{ "zeta", "*z" }, /* EQNSYM_zeta */
	{ "DELTA", "*D" }, /* EQNSYM_DELTA */
	{ "GAMMA", "*G" }, /* EQNSYM_GAMMA */
	{ "LAMBDA", "*L" }, /* EQNSYM_LAMBDA */
	{ "OMEGA", "*W" }, /* EQNSYM_OMEGA */
	{ "PHI", "*F" }, /* EQNSYM_PHI */
	{ "PI", "*P" }, /* EQNSYM_PI */
	{ "PSI", "*Q" }, /* EQNSYM_PSI */
	{ "SIGMA", "*S" }, /* EQNSYM_SIGMA */
	{ "THETA", "*H" }, /* EQNSYM_THETA */
	{ "UPSILON", "*U" }, /* EQNSYM_UPSILON */
	{ "XI", "*C" }, /* EQNSYM_XI */
	{ "inter", "ca" }, /* EQNSYM_inter */
	{ "union", "cu" }, /* EQNSYM_union */
	{ "prod", "product" }, /* EQNSYM_prod */
	{ "int", "integral" }, /* EQNSYM_int */
	{ "sum", "sum" }, /* EQNSYM_sum */
	{ "grad", "gr" }, /* EQNSYM_grad */
	{ "del", "gr" }, /* EQNSYM_del */
	{ "times", "mu" }, /* EQNSYM_times */
	{ "cdot", "pc" }, /* EQNSYM_cdot */
	{ "nothing", "&" }, /* EQNSYM_nothing */
	{ "approx", "~~" }, /* EQNSYM_approx */
	{ "prime", "fm" }, /* EQNSYM_prime */
	{ "half", "12" }, /* EQNSYM_half */
	{ "partial", "pd" }, /* EQNSYM_partial */
	{ "inf", "if" }, /* EQNSYM_inf */
	{ ">>", ">>" }, /* EQNSYM_muchgreat */
	{ "<<", "<<" }, /* EQNSYM_muchless */
	{ "<-", "<-" }, /* EQNSYM_larrow */
	{ "->", "->" }, /* EQNSYM_rarrow */
	{ "+-", "+-" }, /* EQNSYM_pm */
	{ "!=", "!=" }, /* EQNSYM_nequal */
	{ "==", "==" }, /* EQNSYM_equiv */
	{ "<=", "<=" }, /* EQNSYM_lessequal */
	{ ">=", ">=" }, /* EQNSYM_moreequal */
	{ "-", "mi" }, /* EQNSYM_minus */
};

enum	parse_mode {
	MODE_QUOTED,
	MODE_NOSUB,
	MODE_SUB,
	MODE_TOK
};

static	struct eqn_box	*eqn_box_alloc(struct eqn_node *, struct eqn_box *);
static	void		 eqn_box_free(struct eqn_box *);
static	struct eqn_box	*eqn_box_makebinary(struct eqn_node *,
				enum eqn_post, struct eqn_box *);
static	void		 eqn_def(struct eqn_node *);
static	struct eqn_def	*eqn_def_find(struct eqn_node *);
static	void		 eqn_delim(struct eqn_node *);
static	enum eqn_tok	 eqn_next(struct eqn_node *, enum parse_mode);
static	enum rofferr	 eqn_parse(struct eqn_node *, struct eqn_box *);
static	void		 eqn_undef(struct eqn_node *);


enum rofferr
eqn_read(struct eqn_node **epp, int ln,
		const char *p, int pos, int *offs)
{
	size_t		 sz;
	struct eqn_node	*ep;
	enum rofferr	 er;

	ep = *epp;

	/*
	 * If we're the terminating mark, unset our equation status and
	 * validate the full equation.
	 */

	if (0 == strncmp(p, ".EN", 3)) {
		er = eqn_end(epp);
		p += 3;
		while (' ' == *p || '\t' == *p)
			p++;
		if ('\0' == *p)
			return er;
		mandoc_vmsg(MANDOCERR_ARG_SKIP, ep->parse,
		    ln, pos, "EN %s", p);
		return er;
	}

	/*
	 * Build up the full string, replacing all newlines with regular
	 * whitespace.
	 */

	sz = strlen(p + pos) + 1;
	ep->data = mandoc_realloc(ep->data, ep->sz + sz + 1);

	/* First invocation: nil terminate the string. */

	if (0 == ep->sz)
		*ep->data = '\0';

	ep->sz += sz;
	strlcat(ep->data, p + pos, ep->sz + 1);
	strlcat(ep->data, " ", ep->sz + 1);
	return ROFF_IGN;
}

struct eqn_node *
eqn_alloc(int pos, int line, struct mparse *parse)
{
	struct eqn_node	*p;

	p = mandoc_calloc(1, sizeof(struct eqn_node));

	p->parse = parse;
	p->eqn.ln = line;
	p->eqn.pos = pos;
	p->gsize = EQN_DEFSIZE;

	return p;
}

/*
 * Find the key "key" of the give size within our eqn-defined values.
 */
static struct eqn_def *
eqn_def_find(struct eqn_node *ep)
{
	int		 i;

	for (i = 0; i < (int)ep->defsz; i++)
		if (ep->defs[i].keysz && STRNEQ(ep->defs[i].key,
		    ep->defs[i].keysz, ep->start, ep->toksz))
			return &ep->defs[i];

	return NULL;
}

/*
 * Parse a token from the input text.  The modes are:
 * MODE_QUOTED: Use *ep->start as the delimiter; the token ends
 *   before its next occurence.  Do not interpret the token in any
 *   way and return EQN_TOK_QUOTED.  All other modes behave like
 *   MODE_QUOTED when *ep->start is '"'.
 * MODE_NOSUB: If *ep->start is a curly brace, the token ends after it;
 *   otherwise, it ends before the next whitespace or brace.
 *   Do not interpret the token and return EQN_TOK__MAX.
 * MODE_SUB: Like MODE_NOSUB, but try to interpret the token as an
 *   alias created with define.  If it is an alias, replace it with
 *   its string value and reparse.
 * MODE_TOK: Like MODE_SUB, but also check the token against the list
 *   of tokens, and if there is a match, return that token.  Otherwise,
 *   if the token matches a symbol, return EQN_TOK_SYM; if it matches
 *   a function name, EQN_TOK_FUNC, or else EQN_TOK__MAX.  Except for
 *   a token match, *ep->start is set to an allocated string that the
 *   caller is expected to free.
 * All modes skip whitespace following the end of the token.
 */
static enum eqn_tok
eqn_next(struct eqn_node *ep, enum parse_mode mode)
{
	static int	 last_len, lim;

	struct eqn_def	*def;
	size_t		 start;
	int		 diff, i, quoted;
	enum eqn_tok	 tok;

	/*
	 * Reset the recursion counter after advancing
	 * beyond the end of the previous substitution.
	 */
	if (ep->end - ep->data >= last_len)
		lim = 0;

	ep->start = ep->end;
	quoted = mode == MODE_QUOTED;
	for (;;) {
		switch (*ep->start) {
		case '\0':
			ep->toksz = 0;
			return EQN_TOK_EOF;
		case '"':
			quoted = 1;
			break;
		default:
			break;
		}
		if (quoted) {
			ep->end = strchr(ep->start + 1, *ep->start);
			ep->start++;  /* Skip opening quote. */
			if (ep->end == NULL) {
				mandoc_msg(MANDOCERR_ARG_QUOTE, ep->parse,
				    ep->eqn.ln, ep->eqn.pos, NULL);
				ep->end = strchr(ep->start, '\0');
			}
		} else {
			ep->end = ep->start + 1;
			if (*ep->start != '{' && *ep->start != '}')
				ep->end += strcspn(ep->end, " ^~\"{}\t");
		}
		ep->toksz = ep->end - ep->start;
		if (quoted && *ep->end != '\0')
			ep->end++;  /* Skip closing quote. */
		while (*ep->end != '\0' && strchr(" \t^~", *ep->end) != NULL)
			ep->end++;
		if (quoted)  /* Cannot return, may have to strndup. */
			break;
		if (mode == MODE_NOSUB)
			return EQN_TOK__MAX;
		if ((def = eqn_def_find(ep)) == NULL)
			break;
		if (++lim > EQN_NEST_MAX) {
			mandoc_msg(MANDOCERR_ROFFLOOP, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, NULL);
			return EQN_TOK_EOF;
		}

		/* Replace a defined name with its string value. */
		if ((diff = def->valsz - ep->toksz) > 0) {
			start = ep->start - ep->data;
			ep->sz += diff;
			ep->data = mandoc_realloc(ep->data, ep->sz + 1);
			ep->start = ep->data + start;
		}
		if (diff)
			memmove(ep->start + def->valsz, ep->start + ep->toksz,
			    strlen(ep->start + ep->toksz) + 1);
		memcpy(ep->start, def->val, def->valsz);
		last_len = ep->start - ep->data + def->valsz;
	}
	if (mode != MODE_TOK)
		return quoted ? EQN_TOK_QUOTED : EQN_TOK__MAX;
	if (quoted) {
		ep->start = mandoc_strndup(ep->start, ep->toksz);
		return EQN_TOK_QUOTED;
	}
	for (tok = 0; tok < EQN_TOK__MAX; tok++)
		if (STRNEQ(ep->start, ep->toksz,
		    eqn_toks[tok], strlen(eqn_toks[tok])))
			return tok;

	for (i = 0; i < EQNSYM__MAX; i++) {
		if (STRNEQ(ep->start, ep->toksz,
		    eqnsyms[i].str, strlen(eqnsyms[i].str))) {
			mandoc_asprintf(&ep->start,
			    "\\[%s]", eqnsyms[i].sym);
			return EQN_TOK_SYM;
		}
	}
	ep->start = mandoc_strndup(ep->start, ep->toksz);
	for (i = 0; i < (int)(sizeof(eqn_func)/sizeof(*eqn_func)); i++)
		if (STRNEQ(ep->start, ep->toksz,
		    eqn_func[i], strlen(eqn_func[i])))
			return EQN_TOK_FUNC;
	return EQN_TOK__MAX;
}

static void
eqn_box_free(struct eqn_box *bp)
{

	if (bp->first)
		eqn_box_free(bp->first);
	if (bp->next)
		eqn_box_free(bp->next);

	free(bp->text);
	free(bp->left);
	free(bp->right);
	free(bp->top);
	free(bp->bottom);
	free(bp);
}

/*
 * Allocate a box as the last child of the parent node.
 */
static struct eqn_box *
eqn_box_alloc(struct eqn_node *ep, struct eqn_box *parent)
{
	struct eqn_box	*bp;

	bp = mandoc_calloc(1, sizeof(struct eqn_box));
	bp->parent = parent;
	bp->parent->args++;
	bp->expectargs = UINT_MAX;
	bp->font = bp->parent->font;
	bp->size = ep->gsize;

	if (NULL != parent->first) {
		parent->last->next = bp;
		bp->prev = parent->last;
	} else
		parent->first = bp;

	parent->last = bp;
	return bp;
}

/*
 * Reparent the current last node (of the current parent) under a new
 * EQN_SUBEXPR as the first element.
 * Then return the new parent.
 * The new EQN_SUBEXPR will have a two-child limit.
 */
static struct eqn_box *
eqn_box_makebinary(struct eqn_node *ep,
	enum eqn_post pos, struct eqn_box *parent)
{
	struct eqn_box	*b, *newb;

	assert(NULL != parent->last);
	b = parent->last;
	if (parent->last == parent->first)
		parent->first = NULL;
	parent->args--;
	parent->last = b->prev;
	b->prev = NULL;
	newb = eqn_box_alloc(ep, parent);
	newb->pos = pos;
	newb->type = EQN_SUBEXPR;
	newb->expectargs = 2;
	newb->args = 1;
	newb->first = newb->last = b;
	newb->first->next = NULL;
	b->parent = newb;
	return newb;
}

/*
 * Parse the "delim" control statement.
 */
static void
eqn_delim(struct eqn_node *ep)
{
	if (ep->end[0] == '\0' || ep->end[1] == '\0') {
		mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
		    ep->eqn.ln, ep->eqn.pos, "delim");
		if (ep->end[0] != '\0')
			ep->end++;
	} else if (strncmp(ep->end, "off", 3) == 0) {
		ep->delim = 0;
		ep->end += 3;
	} else if (strncmp(ep->end, "on", 2) == 0) {
		if (ep->odelim && ep->cdelim)
			ep->delim = 1;
		ep->end += 2;
	} else {
		ep->odelim = *ep->end++;
		ep->cdelim = *ep->end++;
		ep->delim = 1;
	}
}

/*
 * Undefine a previously-defined string.
 */
static void
eqn_undef(struct eqn_node *ep)
{
	struct eqn_def	*def;

	if (eqn_next(ep, MODE_NOSUB) == EQN_TOK_EOF) {
		mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
		    ep->eqn.ln, ep->eqn.pos, "undef");
		return;
	}
	if ((def = eqn_def_find(ep)) == NULL)
		return;
	free(def->key);
	free(def->val);
	def->key = def->val = NULL;
	def->keysz = def->valsz = 0;
}

static void
eqn_def(struct eqn_node *ep)
{
	struct eqn_def	*def;
	int		 i;

	if (eqn_next(ep, MODE_NOSUB) == EQN_TOK_EOF) {
		mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
		    ep->eqn.ln, ep->eqn.pos, "define");
		return;
	}

	/*
	 * Search for a key that already exists.
	 * Create a new key if none is found.
	 */
	if ((def = eqn_def_find(ep)) == NULL) {
		/* Find holes in string array. */
		for (i = 0; i < (int)ep->defsz; i++)
			if (0 == ep->defs[i].keysz)
				break;

		if (i == (int)ep->defsz) {
			ep->defsz++;
			ep->defs = mandoc_reallocarray(ep->defs,
			    ep->defsz, sizeof(struct eqn_def));
			ep->defs[i].key = ep->defs[i].val = NULL;
		}

		def = ep->defs + i;
		free(def->key);
		def->key = mandoc_strndup(ep->start, ep->toksz);
		def->keysz = ep->toksz;
	}

	if (eqn_next(ep, MODE_QUOTED) == EQN_TOK_EOF) {
		mandoc_vmsg(MANDOCERR_REQ_EMPTY, ep->parse,
		    ep->eqn.ln, ep->eqn.pos, "define %s", def->key);
		free(def->key);
		free(def->val);
		def->key = def->val = NULL;
		def->keysz = def->valsz = 0;
		return;
	}
	free(def->val);
	def->val = mandoc_strndup(ep->start, ep->toksz);
	def->valsz = ep->toksz;
}

/*
 * Recursively parse an eqn(7) expression.
 */
static enum rofferr
eqn_parse(struct eqn_node *ep, struct eqn_box *parent)
{
	struct eqn_box	*cur, *nbox, *split;
	const char	*cp, *cpn;
	char		*p;
	enum eqn_tok	 tok;
	enum eqn_post	 pos;
	enum { CCL_LET, CCL_DIG, CCL_PUN } ccl, ccln;
	int		 size;

	assert(parent != NULL);

	/*
	 * Empty equation.
	 * Do not add it to the high-level syntax tree.
	 */

	if (ep->data == NULL)
		return ROFF_IGN;

	ep->start = ep->end = ep->data + strspn(ep->data, " ^~");

next_tok:
	tok = eqn_next(ep, MODE_TOK);
	switch (tok) {
	case EQN_TOK_UNDEF:
		eqn_undef(ep);
		break;
	case EQN_TOK_NDEFINE:
	case EQN_TOK_DEFINE:
		eqn_def(ep);
		break;
	case EQN_TOK_TDEFINE:
		if (eqn_next(ep, MODE_NOSUB) == EQN_TOK_EOF ||
		    eqn_next(ep, MODE_QUOTED) == EQN_TOK_EOF)
			mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, "tdefine");
		break;
	case EQN_TOK_DELIM:
		eqn_delim(ep);
		break;
	case EQN_TOK_GFONT:
		if (eqn_next(ep, MODE_SUB) == EQN_TOK_EOF)
			mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
		break;
	case EQN_TOK_MARK:
	case EQN_TOK_LINEUP:
		/* Ignore these. */
		break;
	case EQN_TOK_DYAD:
	case EQN_TOK_VEC:
	case EQN_TOK_UNDER:
	case EQN_TOK_BAR:
	case EQN_TOK_TILDE:
	case EQN_TOK_HAT:
	case EQN_TOK_DOT:
	case EQN_TOK_DOTDOT:
		if (parent->last == NULL) {
			mandoc_msg(MANDOCERR_EQN_NOBOX, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			cur = eqn_box_alloc(ep, parent);
			cur->type = EQN_TEXT;
			cur->text = mandoc_strdup("");
		}
		parent = eqn_box_makebinary(ep, EQNPOS_NONE, parent);
		parent->type = EQN_LIST;
		parent->expectargs = 1;
		parent->font = EQNFONT_ROMAN;
		switch (tok) {
		case EQN_TOK_DOTDOT:
			parent->top = mandoc_strdup("\\[ad]");
			break;
		case EQN_TOK_VEC:
			parent->top = mandoc_strdup("\\[->]");
			break;
		case EQN_TOK_DYAD:
			parent->top = mandoc_strdup("\\[<>]");
			break;
		case EQN_TOK_TILDE:
			parent->top = mandoc_strdup("\\[a~]");
			break;
		case EQN_TOK_UNDER:
			parent->bottom = mandoc_strdup("\\[ul]");
			break;
		case EQN_TOK_BAR:
			parent->top = mandoc_strdup("\\[rl]");
			break;
		case EQN_TOK_DOT:
			parent->top = mandoc_strdup("\\[a.]");
			break;
		case EQN_TOK_HAT:
			parent->top = mandoc_strdup("\\[ha]");
			break;
		default:
			abort();
		}
		parent = parent->parent;
		break;
	case EQN_TOK_FWD:
	case EQN_TOK_BACK:
	case EQN_TOK_DOWN:
	case EQN_TOK_UP:
		if (eqn_next(ep, MODE_SUB) == EQN_TOK_EOF)
			mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
		break;
	case EQN_TOK_FAT:
	case EQN_TOK_ROMAN:
	case EQN_TOK_ITALIC:
	case EQN_TOK_BOLD:
		while (parent->args == parent->expectargs)
			parent = parent->parent;
		/*
		 * These values apply to the next word or sequence of
		 * words; thus, we mark that we'll have a child with
		 * exactly one of those.
		 */
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_LIST;
		parent->expectargs = 1;
		switch (tok) {
		case EQN_TOK_FAT:
			parent->font = EQNFONT_FAT;
			break;
		case EQN_TOK_ROMAN:
			parent->font = EQNFONT_ROMAN;
			break;
		case EQN_TOK_ITALIC:
			parent->font = EQNFONT_ITALIC;
			break;
		case EQN_TOK_BOLD:
			parent->font = EQNFONT_BOLD;
			break;
		default:
			abort();
		}
		break;
	case EQN_TOK_SIZE:
	case EQN_TOK_GSIZE:
		/* Accept two values: integral size and a single. */
		if (eqn_next(ep, MODE_SUB) == EQN_TOK_EOF) {
			mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			break;
		}
		size = mandoc_strntoi(ep->start, ep->toksz, 10);
		if (-1 == size) {
			mandoc_msg(MANDOCERR_IT_NONUM, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			break;
		}
		if (EQN_TOK_GSIZE == tok) {
			ep->gsize = size;
			break;
		}
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_LIST;
		parent->expectargs = 1;
		parent->size = size;
		break;
	case EQN_TOK_FROM:
	case EQN_TOK_TO:
	case EQN_TOK_SUB:
	case EQN_TOK_SUP:
		/*
		 * We have a left-right-associative expression.
		 * Repivot under a positional node, open a child scope
		 * and keep on reading.
		 */
		if (parent->last == NULL) {
			mandoc_msg(MANDOCERR_EQN_NOBOX, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			cur = eqn_box_alloc(ep, parent);
			cur->type = EQN_TEXT;
			cur->text = mandoc_strdup("");
		}
		/* Handle the "subsup" and "fromto" positions. */
		if (EQN_TOK_SUP == tok && parent->pos == EQNPOS_SUB) {
			parent->expectargs = 3;
			parent->pos = EQNPOS_SUBSUP;
			break;
		}
		if (EQN_TOK_TO == tok && parent->pos == EQNPOS_FROM) {
			parent->expectargs = 3;
			parent->pos = EQNPOS_FROMTO;
			break;
		}
		switch (tok) {
		case EQN_TOK_FROM:
			pos = EQNPOS_FROM;
			break;
		case EQN_TOK_TO:
			pos = EQNPOS_TO;
			break;
		case EQN_TOK_SUP:
			pos = EQNPOS_SUP;
			break;
		case EQN_TOK_SUB:
			pos = EQNPOS_SUB;
			break;
		default:
			abort();
		}
		parent = eqn_box_makebinary(ep, pos, parent);
		break;
	case EQN_TOK_SQRT:
		while (parent->args == parent->expectargs)
			parent = parent->parent;
		/*
		 * Accept a left-right-associative set of arguments just
		 * like sub and sup and friends but without rebalancing
		 * under a pivot.
		 */
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_SUBEXPR;
		parent->pos = EQNPOS_SQRT;
		parent->expectargs = 1;
		break;
	case EQN_TOK_OVER:
		/*
		 * We have a right-left-associative fraction.
		 * Close out anything that's currently open, then
		 * rebalance and continue reading.
		 */
		if (parent->last == NULL) {
			mandoc_msg(MANDOCERR_EQN_NOBOX, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			cur = eqn_box_alloc(ep, parent);
			cur->type = EQN_TEXT;
			cur->text = mandoc_strdup("");
		}
		while (EQN_SUBEXPR == parent->type)
			parent = parent->parent;
		parent = eqn_box_makebinary(ep, EQNPOS_OVER, parent);
		break;
	case EQN_TOK_RIGHT:
	case EQN_TOK_BRACE_CLOSE:
		/*
		 * Close out the existing brace.
		 * FIXME: this is a shitty sentinel: we should really
		 * have a native EQN_BRACE type or whatnot.
		 */
		for (cur = parent; cur != NULL; cur = cur->parent)
			if (cur->type == EQN_LIST &&
			    cur->expectargs > 1 &&
			    (tok == EQN_TOK_BRACE_CLOSE ||
			     cur->left != NULL))
				break;
		if (cur == NULL) {
			mandoc_msg(MANDOCERR_BLK_NOTOPEN, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			break;
		}
		parent = cur;
		if (EQN_TOK_RIGHT == tok) {
			if (eqn_next(ep, MODE_SUB) == EQN_TOK_EOF) {
				mandoc_msg(MANDOCERR_REQ_EMPTY,
				    ep->parse, ep->eqn.ln,
				    ep->eqn.pos, eqn_toks[tok]);
				break;
			}
			/* Handling depends on right/left. */
			if (STRNEQ(ep->start, ep->toksz, "ceiling", 7))
				parent->right = mandoc_strdup("\\[rc]");
			else if (STRNEQ(ep->start, ep->toksz, "floor", 5))
				parent->right = mandoc_strdup("\\[rf]");
			else
				parent->right =
				    mandoc_strndup(ep->start, ep->toksz);
		}
		parent = parent->parent;
		if (tok == EQN_TOK_BRACE_CLOSE &&
		    (parent->type == EQN_PILE ||
		     parent->type == EQN_MATRIX))
			parent = parent->parent;
		/* Close out any "singleton" lists. */
		while (parent->type == EQN_LIST &&
		    parent->expectargs == 1 &&
		    parent->args == 1)
			parent = parent->parent;
		break;
	case EQN_TOK_BRACE_OPEN:
	case EQN_TOK_LEFT:
		/*
		 * If we already have something in the stack and we're
		 * in an expression, then rewind til we're not any more
		 * (just like with the text node).
		 */
		while (parent->args == parent->expectargs)
			parent = parent->parent;
		if (EQN_TOK_LEFT == tok &&
		    eqn_next(ep, MODE_SUB) == EQN_TOK_EOF) {
			mandoc_msg(MANDOCERR_REQ_EMPTY, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			break;
		}
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_LIST;
		if (EQN_TOK_LEFT == tok) {
			if (STRNEQ(ep->start, ep->toksz, "ceiling", 7))
				parent->left = mandoc_strdup("\\[lc]");
			else if (STRNEQ(ep->start, ep->toksz, "floor", 5))
				parent->left = mandoc_strdup("\\[lf]");
			else
				parent->left =
				    mandoc_strndup(ep->start, ep->toksz);
		}
		break;
	case EQN_TOK_PILE:
	case EQN_TOK_LPILE:
	case EQN_TOK_RPILE:
	case EQN_TOK_CPILE:
	case EQN_TOK_CCOL:
	case EQN_TOK_LCOL:
	case EQN_TOK_RCOL:
		while (parent->args == parent->expectargs)
			parent = parent->parent;
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_PILE;
		parent->expectargs = 1;
		break;
	case EQN_TOK_ABOVE:
		for (cur = parent; cur != NULL; cur = cur->parent)
			if (cur->type == EQN_PILE)
				break;
		if (cur == NULL) {
			mandoc_msg(MANDOCERR_IT_STRAY, ep->parse,
			    ep->eqn.ln, ep->eqn.pos, eqn_toks[tok]);
			break;
		}
		parent = eqn_box_alloc(ep, cur);
		parent->type = EQN_LIST;
		break;
	case EQN_TOK_MATRIX:
		while (parent->args == parent->expectargs)
			parent = parent->parent;
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_MATRIX;
		parent->expectargs = 1;
		break;
	case EQN_TOK_EOF:
		/*
		 * End of file!
		 * TODO: make sure we're not in an open subexpression.
		 */
		return ROFF_EQN;
	case EQN_TOK__MAX:
	case EQN_TOK_FUNC:
	case EQN_TOK_QUOTED:
	case EQN_TOK_SYM:
		p = ep->start;
		assert(p != NULL);
		/*
		 * If we already have something in the stack and we're
		 * in an expression, then rewind til we're not any more.
		 */
		while (parent->args == parent->expectargs)
			parent = parent->parent;
		cur = eqn_box_alloc(ep, parent);
		cur->type = EQN_TEXT;
		cur->text = p;
		switch (tok) {
		case EQN_TOK_FUNC:
			cur->font = EQNFONT_ROMAN;
			break;
		case EQN_TOK_QUOTED:
			if (cur->font == EQNFONT_NONE)
				cur->font = EQNFONT_ITALIC;
			break;
		case EQN_TOK_SYM:
			break;
		default:
			if (cur->font != EQNFONT_NONE || *p == '\0')
				break;
			cpn = p - 1;
			ccln = CCL_LET;
			split = NULL;
			for (;;) {
				/* Advance to next character. */
				cp = cpn++;
				ccl = ccln;
				ccln = isalpha((unsigned char)*cpn) ? CCL_LET :
				    isdigit((unsigned char)*cpn) ||
				    (*cpn == '.' && (ccl == CCL_DIG ||
				     isdigit((unsigned char)cpn[1]))) ?
				    CCL_DIG : CCL_PUN;
				/* No boundary before first character. */
				if (cp < p)
					continue;
				cur->font = ccl == CCL_LET ?
				    EQNFONT_ITALIC : EQNFONT_ROMAN;
				if (*cp == '\\')
					mandoc_escape(&cpn, NULL, NULL);
				/* No boundary after last character. */
				if (*cpn == '\0')
					break;
				if (ccln == ccl)
					continue;
				/* Boundary found, split the text. */
				if (parent->args == parent->expectargs) {
					/* Remove the text from the tree. */
					if (cur->prev == NULL)
						parent->first = cur->next;
					else
						cur->prev->next = NULL;
					parent->last = cur->prev;
					parent->args--;
					/* Set up a list instead. */
					split = eqn_box_alloc(ep, parent);
					split->type = EQN_LIST;
					/* Insert the word into the list. */
					split->first = split->last = cur;
					cur->parent = split;
					cur->prev = NULL;
					parent = split;
				}
				/* Append a new text box. */
				nbox = eqn_box_alloc(ep, parent);
				nbox->type = EQN_TEXT;
				nbox->text = mandoc_strdup(cpn);
				/* Truncate the old box. */
				p = mandoc_strndup(cur->text,
				    cpn - cur->text);
				free(cur->text);
				cur->text = p;
				/* Setup to process the new box. */
				cur = nbox;
				p = nbox->text;
				cpn = p - 1;
				ccln = CCL_LET;
			}
			if (split != NULL)
				parent = split->parent;
			break;
		}
		/*
		 * Post-process list status.
		 */
		while (parent->type == EQN_LIST &&
		    parent->expectargs == 1 &&
		    parent->args == 1)
			parent = parent->parent;
		break;
	default:
		abort();
	}
	goto next_tok;
}

enum rofferr
eqn_end(struct eqn_node **epp)
{
	struct eqn_node	*ep;

	ep = *epp;
	*epp = NULL;

	ep->eqn.root = mandoc_calloc(1, sizeof(struct eqn_box));
	ep->eqn.root->expectargs = UINT_MAX;
	return eqn_parse(ep, ep->eqn.root);
}

void
eqn_free(struct eqn_node *p)
{
	int		 i;

	eqn_box_free(p->eqn.root);

	for (i = 0; i < (int)p->defsz; i++) {
		free(p->defs[i].key);
		free(p->defs[i].val);
	}

	free(p->data);
	free(p->defs);
	free(p);
}
@


1.35
log
@Skip whitespace at the beginning of eqn(7) nodes,
in particular ~ and ^ that misrendered;
found by bentley@@ in glCopyTexSubImage1D(3); also affected
glAccum(3), glClipPlane(3), glDrawPixels(3), glEvalMesh(3), and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.34 2017/06/26 19:53:00 schwarze Exp $ */
d730 1
a730 1
		parent->type = EQN_LISTONE;
d783 1
a783 1
		parent->type = EQN_LISTONE;
d821 1
a821 1
		parent->type = EQN_LISTONE;
d909 1
d941 3
a943 2
		while (parent->type == EQN_LISTONE &&
		    parent->args == parent->expectargs)
d1103 3
a1105 2
		while (parent->type == EQN_LISTONE &&
		    parent->args == parent->expectargs)
@


1.34
log
@Complete rewrite of the lexer in a single function with four operation
modes instead of four functions, resulting in considerable
simplification, fifty lines less of code, fifteen fewer automatic
variables, and several bug fixes, for example:

1. The delim control statement consumes exactly two bytes of input,
requires no whitespace after these two bytes, and does not treat
quotes in any special way.
2. If the argument of left, right, gfont, gsize, or size is defined
as an alias, only the first word of the value is used as the
delimiter, font name, or font size.
3. If a back, fwd, down, or up keyword is followed by another keyword
instead of the required number, GNU eqn does nothing useful, but
typically errors out.  So no need to have special handling (with
an ugly goto!) for it in mandoc.

Also getting rid of one pointless static buffer and twelve redundant
calls to strlcpy(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.33 2017/06/26 11:04:26 schwarze Exp $ */
d684 1
a684 1
	ep->start = ep->end = ep->data;
@


1.33
log
@when splitting a composite word,
do not forget to close the inserted list box
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.32 2017/06/23 21:04:34 schwarze Exp $ */
d146 1
a146 1
	EQNSYM_alpha,
d277 7
d289 1
a289 1
static	struct eqn_def	*eqn_def_find(struct eqn_node *, const char *, size_t);
d291 1
a291 3
static	const char	*eqn_next(struct eqn_node *, char, size_t *, int);
static	const char	*eqn_nextrawtok(struct eqn_node *, size_t *);
static	const char	*eqn_nexttok(struct eqn_node *, size_t *);
a292 1
static	enum eqn_tok	 eqn_tok_parse(struct eqn_node *, char **);
d361 1
a361 1
eqn_def_find(struct eqn_node *ep, const char *key, size_t sz)
d367 1
a367 1
		    ep->defs[i].keysz, key, sz))
d374 18
a391 3
 * Get the next token from the input stream using the given quote
 * character.
 * Optionally make any replacements.
d393 2
a394 2
static const char *
eqn_next(struct eqn_node *ep, char quote, size_t *sz, int repl)
d396 1
a396 2
	static size_t	 last_len;
	static int	 lim;
a397 3
	char		*start, *next;
	int		 q, diff;
	size_t		 ssz, dummy;
d399 3
d403 5
a407 4
	if (NULL == sz)
		sz = &dummy;

	if (ep->cur >= last_len)
a408 9
	ep->rew = ep->cur;
again:
	/* Prevent self-definitions. */

	if (lim >= EQN_NEST_MAX) {
		mandoc_msg(MANDOCERR_ROFFLOOP, ep->parse,
		    ep->eqn.ln, ep->eqn.pos, NULL);
		return NULL;
	}
d410 39
a448 38
	ep->cur = ep->rew;
	start = &ep->data[(int)ep->cur];
	q = 0;

	if ('\0' == *start)
		return NULL;

	if (quote == *start) {
		ep->cur++;
		q = 1;
	}

	start = &ep->data[(int)ep->cur];

	if ( ! q) {
		if ('{' == *start || '}' == *start)
			ssz = 1;
		else
			ssz = strcspn(start + 1, " ^~\"{}\t") + 1;
		next = start + (int)ssz;
		if ('\0' == *next)
			next = NULL;
	} else
		next = strchr(start, quote);

	if (NULL != next) {
		*sz = (size_t)(next - start);
		ep->cur += *sz;
		if (q)
			ep->cur++;
		while (' ' == ep->data[(int)ep->cur] ||
		    '\t' == ep->data[(int)ep->cur] ||
		    '^' == ep->data[(int)ep->cur] ||
		    '~' == ep->data[(int)ep->cur])
			ep->cur++;
	} else {
		if (q)
			mandoc_msg(MANDOCERR_ARG_QUOTE, ep->parse,
d450 2
a451 12
		next = strchr(start, '\0');
		*sz = (size_t)(next - start);
		ep->cur += *sz;
	}

	/* Quotes aren't expanded for values. */

	if (q || ! repl)
		return start;

	if (NULL != (def = eqn_def_find(ep, start, *sz))) {
		diff = def->valsz - *sz;
d453 3
a455 1
		if (def->valsz > *sz) {
d458 1
a458 2
			ep->data[ep->sz] = '\0';
			start = &ep->data[(int)ep->rew];
d460 5
a464 8

		diff = def->valsz - *sz;
		memmove(start + *sz + diff, start + *sz,
		    (strlen(start) - *sz) + 1);
		memcpy(start, def->val, def->valsz);
		last_len = start - ep->data + def->valsz;
		lim++;
		goto again;
d466 2
a467 50

	return start;
}

/*
 * Get the next delimited token using the default current quote
 * character.
 */
static const char *
eqn_nexttok(struct eqn_node *ep, size_t *sz)
{

	return eqn_next(ep, '"', sz, 1);
}

/*
 * Get next token without replacement.
 */
static const char *
eqn_nextrawtok(struct eqn_node *ep, size_t *sz)
{

	return eqn_next(ep, '"', sz, 0);
}

/*
 * Parse a token from the stream of text.
 * A token consists of one of the recognised eqn(7) strings.
 * Strings are separated by delimiting marks.
 * This returns EQN_TOK_EOF when there are no more tokens.
 * If the token is an unrecognised string literal, then it returns
 * EQN_TOK__MAX and sets the "p" pointer to an allocated, nil-terminated
 * string.
 * This must be later freed with free(3).
 */
static enum eqn_tok
eqn_tok_parse(struct eqn_node *ep, char **p)
{
	const char	*start;
	size_t		 i, sz;
	int		 quoted;

	if (p != NULL)
		*p = NULL;

	quoted = ep->data[ep->cur] == '"';

	if ((start = eqn_nexttok(ep, &sz)) == NULL)
		return EQN_TOK_EOF;

d469 1
a469 2
		if (p != NULL)
			*p = mandoc_strndup(start, sz);
d472 4
a475 4

	for (i = 0; i < EQN_TOK__MAX; i++)
		if (STRNEQ(start, sz, eqn_toks[i], strlen(eqn_toks[i])))
			return i;
d478 1
a478 1
		if (STRNEQ(start, sz,
d480 2
a481 1
			mandoc_asprintf(p, "\\[%s]", eqnsyms[i].sym);
d485 4
a488 6

	if (p != NULL)
		*p = mandoc_strndup(start, sz);

	for (i = 0; i < sizeof(eqn_func)/sizeof(*eqn_func); i++)
		if (STRNEQ(start, sz, eqn_func[i], strlen(eqn_func[i])))
a489 1

d571 1
a571 4
	const char	*start;
	size_t		 sz;

	if ((start = eqn_nextrawtok(ep, &sz)) == NULL)
d574 3
a576 1
	else if (strncmp(start, "off", 3) == 0)
d578 2
a579 1
	else if (strncmp(start, "on", 2) == 0) {
d582 4
a585 3
	} else if (start[1] != '\0') {
		ep->odelim = start[0];
		ep->cdelim = start[1];
a595 1
	const char	*start;
a596 1
	size_t		 sz;
d598 1
a598 1
	if ((start = eqn_nextrawtok(ep, &sz)) == NULL) {
d603 1
a603 1
	if ((def = eqn_def_find(ep, start, sz)) == NULL)
a613 2
	const char	*start;
	size_t		 sz;
d617 1
a617 1
	if ((start = eqn_nextrawtok(ep, &sz)) == NULL) {
d627 1
a627 1
	if (NULL == (def = eqn_def_find(ep, start, sz))) {
d642 2
a643 2
		def->key = mandoc_strndup(start, sz);
		def->keysz = sz;
d646 1
a646 2
	start = eqn_next(ep, ep->data[(int)ep->cur], &sz, 0);
	if (start == NULL) {
d656 2
a657 2
	def->val = mandoc_strndup(start, sz);
	def->valsz = sz;
a665 1
	char		 sym[64];
d667 1
a667 1
	const char	*cp, *cpn, *start;
d669 1
a669 2
	size_t		 sz;
	enum eqn_tok	 tok, subtok;
d684 2
d687 1
a687 3
	tok = eqn_tok_parse(ep, &p);

this_tok:
d697 2
a698 2
		if (eqn_nextrawtok(ep, NULL) == NULL ||
		    eqn_next(ep, ep->data[(int)ep->cur], NULL, 0) == NULL)
d706 1
a706 1
		if (eqn_nextrawtok(ep, NULL) == NULL)
d735 1
a735 1
			strlcpy(sym, "\\[ad]", sizeof(sym));
d738 1
a738 1
			strlcpy(sym, "\\[->]", sizeof(sym));
d741 1
a741 1
			strlcpy(sym, "\\[<>]", sizeof(sym));
d744 1
a744 1
			strlcpy(sym, "\\[a~]", sizeof(sym));
d747 1
a747 1
			strlcpy(sym, "\\[ul]", sizeof(sym));
d750 1
a750 1
			strlcpy(sym, "\\[rl]", sizeof(sym));
d753 1
a753 1
			strlcpy(sym, "\\[a.]", sizeof(sym));
d756 1
a756 18
			strlcpy(sym, "\\[ha]", sizeof(sym));
			break;
		default:
			abort();
		}

		switch (tok) {
		case EQN_TOK_DOTDOT:
		case EQN_TOK_VEC:
		case EQN_TOK_DYAD:
		case EQN_TOK_TILDE:
		case EQN_TOK_BAR:
		case EQN_TOK_DOT:
		case EQN_TOK_HAT:
			parent->top = mandoc_strdup(sym);
			break;
		case EQN_TOK_UNDER:
			parent->bottom = mandoc_strdup(sym);
d767 1
a767 2
		subtok = eqn_tok_parse(ep, NULL);
		if (subtok != EQN_TOK__MAX) {
a769 3
			tok = subtok;
			goto this_tok;
		}
d805 1
a805 1
		if (NULL == (start = eqn_nexttok(ep, &sz))) {
d810 1
a810 1
		size = mandoc_strntoi(start, sz, 10);
d919 1
a919 1
			if (NULL == (start = eqn_nexttok(ep, &sz))) {
d926 7
a932 8
			if (STRNEQ(start, sz, "ceiling", 7)) {
				strlcpy(sym, "\\[rc]", sizeof(sym));
				parent->right = mandoc_strdup(sym);
			} else if (STRNEQ(start, sz, "floor", 5)) {
				strlcpy(sym, "\\[rf]", sizeof(sym));
				parent->right = mandoc_strdup(sym);
			} else
				parent->right = mandoc_strndup(start, sz);
d954 1
a954 1
		    (start = eqn_nexttok(ep, &sz)) == NULL) {
d962 7
a968 8
			if (STRNEQ(start, sz, "ceiling", 7)) {
				strlcpy(sym, "\\[lc]", sizeof(sym));
				parent->left = mandoc_strdup(sym);
			} else if (STRNEQ(start, sz, "floor", 5)) {
				strlcpy(sym, "\\[lf]", sizeof(sym));
				parent->left = mandoc_strdup(sym);
			} else
				parent->left = mandoc_strndup(start, sz);
d1013 1
@


1.32
log
@splitting a text box sometimes requires wrapping it in a list
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.31 2017/06/23 00:30:17 schwarze Exp $ */
d723 1
a723 1
	struct eqn_box	*cur, *nbox;
d1119 1
d1151 2
a1152 2
					nbox = eqn_box_alloc(ep, parent);
					nbox->type = EQN_LIST;
d1154 2
a1155 2
					nbox->first = nbox->last = cur;
					cur->parent = nbox;
d1157 1
a1157 1
					parent = nbox;
d1174 2
@


1.31
log
@Simplify font handling:
1. Inherit the font attribute from the parent box, such that iteration
is no longer required to find the current font.
2. For well-known function name tokens, do not insert an EQN_LISTONE
box into the AST; simply set the font attribute of the text box
itself that contains the name.

Also improve word splitting of unquoted strings in default font mode:
3. Split between numbers and punctuation because both will soon get
different HTML markup.
4. Do not split between letters.  With the newly ubiquitious font
attributes, all formatters will be able to figure out what to do
without putting each letter into a separate box.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.30 2017/06/22 00:30:06 schwarze Exp $ */
d1140 19
a1158 1
				/* Boundary found, add a new box. */
@


1.30
log
@Fix font selection for text boxes in the terminal formatter.
Issue reported by bentley@@.

The AST data structure is powerful enough that all required
information can easily be provided in the parser, and no change
of the formatting code is needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.29 2017/06/21 20:47:46 schwarze Exp $ */
d574 1
d723 1
a723 1
	struct eqn_box	*cur, *fontp, *nbox;
d729 1
d790 1
a1100 14
		/*
		 * Wrap well-known function names in a roman box,
		 * unless they already are in roman context.
		 */
		for (fontp = parent; fontp != NULL; fontp = fontp->parent)
			if (fontp->font != EQNFONT_NONE)
				break;
		if (tok == EQN_TOK_FUNC &&
		    (fontp == NULL || fontp->font != EQNFONT_ROMAN)) {
			parent = fontp = eqn_box_alloc(ep, parent);
			parent->type = EQN_LISTONE;
			parent->font = EQNFONT_ROMAN;
			parent->expectargs = 1;
		}
d1104 6
a1109 10
		/*
		 * If not inside any explicit font context,
		 * quoted strings become italic, and every letter
		 * of a bare string gets its own italic box.
		 */
		do {
			if (fontp != NULL || *p == '\0' ||
			    tok == EQN_TOK_SYM)
				break;
			if (tok == EQN_TOK_QUOTED) {
d1111 5
d1117 2
a1118 2
			}
			cp = p;
d1120 13
a1132 3
				if (isalpha((unsigned char)*cp))
					cur->font = EQNFONT_ITALIC;
				cpn = cp + 1;
d1135 1
d1138 1
a1138 3
				if (cur->font != EQNFONT_ITALIC &&
				    isalpha((unsigned char)*cpn) == 0) {
					cp = cpn;
d1140 1
a1140 1
				}
d1144 1
d1149 1
d1151 3
a1153 1
				cp = nbox->text;
d1155 2
a1156 1
		} while (0);
@


1.29
log
@Outside explicit font context, give every letter its own box.
The formatters need this to correctly select fonts.
Missing feature reported by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.28 2017/06/21 18:37:38 schwarze Exp $ */
d85 2
d520 1
a520 1
		return EQN_TOK__MAX;
d531 1
a531 1
			return EQN_TOK__MAX;
d1087 1
d1089 2
a1090 1
	case EQN_TOK__MAX:
d1117 2
a1118 1
		 * give every letter its own box.
d1120 8
a1127 1
		if (fontp == NULL && *p != '\0') {
d1130 2
d1137 1
a1137 1
				if (isalpha((unsigned char)*cp) == 0 &&
d1152 1
a1152 1
		}
@


1.28
log
@quoted words are not parsed for defined keys
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.27 2017/06/21 18:03:50 schwarze Exp $ */
d21 1
d720 2
a721 2
	struct eqn_box	*cur;
	const char	*start;
d1094 13
a1106 10
		if (tok == EQN_TOK_FUNC) {
			for (cur = parent; cur != NULL; cur = cur->parent)
				if (cur->font != EQNFONT_NONE)
					break;
			if (cur == NULL || cur->font != EQNFONT_ROMAN) {
				parent = eqn_box_alloc(ep, parent);
				parent->type = EQN_LISTONE;
				parent->font = EQNFONT_ROMAN;
				parent->expectargs = 1;
			}
d1111 28
a1138 1

@


1.27
log
@Recognize well-known functions names (the same that Heirloom recognizes,
which includes those recognized by groff) and wrap them in a roman box
unless they already are in roman context.
Missing feature reported by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.26 2017/06/20 17:24:09 schwarze Exp $ */
d524 8
d722 1
a722 1
	size_t		 i, sz;
d1106 1
a1106 8
		for (i = 0; i < EQNSYM__MAX; i++)
			if (0 == strcmp(eqnsyms[i].str, p)) {
				(void)snprintf(sym, sizeof(sym),
					"\\[%s]", eqnsyms[i].sym);
				cur->text = mandoc_strdup(sym);
				free(p);
				break;
			}
a1107 2
		if (i == EQNSYM__MAX)
			cur->text = p;
@


1.26
log
@KNF: remove parentheses from switch case labels; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.25 2017/03/11 15:42:03 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
a80 1
	EQN_TOK_EOF,
d82 3
a84 1
	EQN_TOK__MAX
a131 1
	NULL, /* EQN_TOK_EOF */
d135 7
d506 1
a506 1
	if (NULL != p)
d511 1
a511 1
	if (NULL == (start = eqn_nexttok(ep, &sz)))
d520 1
a520 3
	for (i = 0; i < EQN_TOK__MAX; i++) {
		if (NULL == eqn_toks[i])
			continue;
d522 1
a522 2
			break;
	}
d524 1
a524 1
	if (i == EQN_TOK__MAX && NULL != p)
d527 5
a531 1
	return i;
d1076 3
a1078 3
	default:
		assert(tok == EQN_TOK__MAX);
		assert(NULL != p);
d1085 11
d1116 2
@


1.25
log
@Improve detection of recursive eqn(7) "define" statements:
Do not only catch "define key 'key other stuff'",
but also "define key 'other stuff key'".
Fixing infinite loop found by tb@@ with afl(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.24 2016/01/08 00:50:20 schwarze Exp $ */
d726 1
a726 1
	case (EQN_TOK_UNDEF):
d729 2
a730 2
	case (EQN_TOK_NDEFINE):
	case (EQN_TOK_DEFINE):
d733 1
a733 1
	case (EQN_TOK_TDEFINE):
d739 1
a739 1
	case (EQN_TOK_DELIM):
d742 1
a742 1
	case (EQN_TOK_GFONT):
d747 2
a748 2
	case (EQN_TOK_MARK):
	case (EQN_TOK_LINEUP):
d751 8
a758 8
	case (EQN_TOK_DYAD):
	case (EQN_TOK_VEC):
	case (EQN_TOK_UNDER):
	case (EQN_TOK_BAR):
	case (EQN_TOK_TILDE):
	case (EQN_TOK_HAT):
	case (EQN_TOK_DOT):
	case (EQN_TOK_DOTDOT):
d770 1
a770 1
		case (EQN_TOK_DOTDOT):
d773 1
a773 1
		case (EQN_TOK_VEC):
d776 1
a776 1
		case (EQN_TOK_DYAD):
d779 1
a779 1
		case (EQN_TOK_TILDE):
d782 1
a782 1
		case (EQN_TOK_UNDER):
d785 1
a785 1
		case (EQN_TOK_BAR):
d788 1
a788 1
		case (EQN_TOK_DOT):
d791 1
a791 1
		case (EQN_TOK_HAT):
d799 7
a805 7
		case (EQN_TOK_DOTDOT):
		case (EQN_TOK_VEC):
		case (EQN_TOK_DYAD):
		case (EQN_TOK_TILDE):
		case (EQN_TOK_BAR):
		case (EQN_TOK_DOT):
		case (EQN_TOK_HAT):
d808 1
a808 1
		case (EQN_TOK_UNDER):
d816 4
a819 4
	case (EQN_TOK_FWD):
	case (EQN_TOK_BACK):
	case (EQN_TOK_DOWN):
	case (EQN_TOK_UP):
d828 4
a831 4
	case (EQN_TOK_FAT):
	case (EQN_TOK_ROMAN):
	case (EQN_TOK_ITALIC):
	case (EQN_TOK_BOLD):
d843 1
a843 1
		case (EQN_TOK_FAT):
d846 1
a846 1
		case (EQN_TOK_ROMAN):
d849 1
a849 1
		case (EQN_TOK_ITALIC):
d852 1
a852 1
		case (EQN_TOK_BOLD):
d859 2
a860 2
	case (EQN_TOK_SIZE):
	case (EQN_TOK_GSIZE):
d882 4
a885 4
	case (EQN_TOK_FROM):
	case (EQN_TOK_TO):
	case (EQN_TOK_SUB):
	case (EQN_TOK_SUP):
d910 1
a910 1
		case (EQN_TOK_FROM):
d913 1
a913 1
		case (EQN_TOK_TO):
d916 1
a916 1
		case (EQN_TOK_SUP):
d919 1
a919 1
		case (EQN_TOK_SUB):
d927 1
a927 1
	case (EQN_TOK_SQRT):
d940 1
a940 1
	case (EQN_TOK_OVER):
d957 2
a958 2
	case (EQN_TOK_RIGHT):
	case (EQN_TOK_BRACE_CLOSE):
d1002 2
a1003 2
	case (EQN_TOK_BRACE_OPEN):
	case (EQN_TOK_LEFT):
d1030 7
a1036 7
	case (EQN_TOK_PILE):
	case (EQN_TOK_LPILE):
	case (EQN_TOK_RPILE):
	case (EQN_TOK_CPILE):
	case (EQN_TOK_CCOL):
	case (EQN_TOK_LCOL):
	case (EQN_TOK_RCOL):
d1043 1
a1043 1
	case (EQN_TOK_ABOVE):
d1055 1
a1055 1
	case (EQN_TOK_MATRIX):
d1062 1
a1062 1
	case (EQN_TOK_EOF):
@


1.24
log
@The root of an .EQ tree is always EQN_ROOT, never EQN_LIST,
so delete a redundant NULL check that confused Coverity in CID 1257471;
issue reported by wiz@@, patch differs from what christos@@ did in NetBSD.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.23 2016/01/07 20:18:34 schwarze Exp $ */
d367 3
d371 1
a371 1
	int		 q, diff, lim;
d378 2
a379 1
	lim = 0;
d453 1
@


1.23
log
@Recursive "define" was not detected because "lim" was never
incremented, causing infinite loops.
Fixing CID 1288962.  From christos@@ via wiz@@, both at NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.22 2015/10/06 18:30:43 schwarze Exp $ */
d988 1
a988 1
		if (EQN_TOK_BRACE_CLOSE == tok && parent &&
@


1.22
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.21 2015/03/03 22:22:20 bentley Exp $ */
d449 1
@


1.21
log
@In eqn, "prime" is equivalent to \(fm, and - is equivalent to \(mi.

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.20 2015/01/28 21:10:28 schwarze Exp $ */
d303 1
a303 1
			return(er);
d306 1
a306 1
		return(er);
d325 1
a325 1
	return(ROFF_IGN);
d340 1
a340 1
	return(p);
d354 1
a354 1
			return(&ep->defs[i]);
d356 1
a356 1
	return(NULL);
d383 1
a383 1
		return(NULL);
d391 1
a391 1
		return(NULL);
d433 1
a433 1
		return(start);
d452 1
a452 1
	return(start);
d463 1
a463 1
	return(eqn_next(ep, '"', sz, 1));
d473 1
a473 1
	return(eqn_next(ep, '"', sz, 0));
d499 1
a499 1
		return(EQN_TOK_EOF);
d504 1
a504 1
		return(EQN_TOK__MAX);
d517 1
a517 1
	return(i);
d558 1
a558 1
	return(bp);
d588 1
a588 1
	return(newb);
d713 1
a713 1
		return(ROFF_IGN);
d1061 1
a1061 1
		return(ROFF_EQN);
d1105 1
a1105 1
	return(eqn_parse(ep, ep->eqn.root));
@


1.20
log
@Clean up eqn(7) error handling:
* When "define" fails, do not drop the whole equation.
* Free memory after "undef".
* Use standard mandoc error types instead of rolling our own.
* Delete obfuscating EQN_MSG() macro.
* Add function prototypes while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.19 2014/10/25 15:05:21 schwarze Exp $ */
d195 1
d251 1
a251 1
	{ "prime", "aq" }, /* EQNSYM_prime */
d264 1
@


1.19
log
@Fix a NULL pointer dereference reported
by Theo Buehler <theo at math dot ethz dot ch> on tech@@:
Do not attempt to parse empty equations.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.18 2014/10/25 14:32:07 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014 Ingo Schwarze <schwarze@@openbsd.org>
a31 2
#define	EQN_MSG(t, x) \
	mandoc_msg((t), (x)->parse, (x)->eqn.ln, (x)->eqn.pos, NULL)
d265 15
d379 2
a380 1
		EQN_MSG(MANDOCERR_ROFFLOOP, ep);
d421 2
a422 1
			EQN_MSG(MANDOCERR_ARG_QUOTE, ep);
d616 1
a616 1
static int
d623 11
a633 7
	if (NULL == (start = eqn_nextrawtok(ep, &sz))) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(0);
	} else if (NULL != (def = eqn_def_find(ep, start, sz)))
		def->keysz = 0;

	return(1);
d636 1
a636 1
static int
d644 4
a647 3
	if (NULL == (start = eqn_nextrawtok(ep, &sz))) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(0);
d667 4
a670 7
		ep->defs[i].keysz = sz;
		ep->defs[i].key = mandoc_realloc(
		    ep->defs[i].key, sz + 1);

		memcpy(ep->defs[i].key, start, sz);
		ep->defs[i].key[(int)sz] = '\0';
		def = &ep->defs[i];
d674 8
a681 4

	if (NULL == start) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(-1);
d683 2
a684 1

a685 4
	def->val = mandoc_realloc(def->val, sz + 1);
	memcpy(def->val, start, sz);
	def->val[(int)sz] = '\0';
	return(1);
d691 1
a691 1
static int
d694 3
d698 1
d701 1
a701 5
	struct eqn_box	*cur;
	int		 rc, size;
	size_t		 i, sz;
	char		 sym[64];
	const char	*start;
d704 6
d711 1
a711 1
		return(-1);
d719 1
a719 2
		if ((rc = eqn_undef(ep)) <= 0)
			return(rc);
d723 1
a723 2
		if ((rc = eqn_def(ep)) <= 0)
			return(rc);
d726 4
a729 5
		if (NULL == eqn_nextrawtok(ep, NULL))
			EQN_MSG(MANDOCERR_EQNEOF, ep);
		else if (NULL == eqn_next(ep,
				ep->data[(int)ep->cur], NULL, 0))
			EQN_MSG(MANDOCERR_EQNEOF, ep);
d1059 1
a1059 1
		return(0);
d1103 1
a1103 1
	return(0 == eqn_parse(ep, ep->eqn.root) ? ROFF_EQN : ROFF_IGN);
@


1.18
log
@Report arguments to .EQ as an error, and simplify the code:
* drop trivial wrapper function roff_openeqn()
* drop unused first arg of function eqn_alloc()
* drop usused member "name" of struct eqn_node
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.17 2014/10/16 01:10:06 schwarze Exp $ */
d685 3
a687 1
	assert(NULL != parent);
@


1.17
log
@Implement in-line equations, much needed by Xenocara manuals.
Put the steering into the roff parser rather than into the mdoc
parser such that it works for all macro languages and on both text
and macro lines.
Line breaks and blank characters generated before and after in-line
equations are not perfect yet, but let's do one thing at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.16 2014/10/12 20:08:43 schwarze Exp $ */
a36 2
#define	EQNSTREQ(x, p, sz) \
	STRNEQ((x)->name, (x)->sz, (p), (sz))
d314 1
a314 1
eqn_alloc(const char *name, int pos, int line, struct mparse *parse)
a316 2
	size_t		 sz;
	const char	*end;
a319 10
	if (name && '\0' != *name) {
		sz = strlen(name);
		assert(sz);
		do {
			sz--;
			end = name + (int)sz;
		} while (' ' == *end || '\t' == *end);
		p->eqn.name = mandoc_strndup(name, sz + 1);
	}

a1094 1
	free(p->eqn.name);
@


1.16
log
@bugfix: do not parse quoted strings for tokens; fixes glFrustum(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.15 2014/10/12 19:10:56 schwarze Exp $ */
d589 24
d723 2
@


1.15
log
@Improve error handling in the eqn(7) parser.
Get rid of the first fatal error, MANDOCERR_EQNSYNT.
In eqn(7), there is no need to be bug-compatible with groff, so there
is no need to abondon the whole equation in case of a syntax error.

In particular:
* Skip "back", "delim", "down", "fwd", "gfont", "gsize", "left",
  "right", "size", and "up" without arguments.
* Skip "gsize" and "size" with a non-numeric argument.
* Skip closing delimiters that are not open.
* Skip "above" outside piles.
* For diacritic marks and binary operators without a left operand,
  default to an empty box.
* Let piles and matrices take one argument rather than insisting
  on a braced list.  Let HTML output handle that, too.
* When rewinding, if the root box is guaranteed to match
  the termination condition, no error handling is needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: eqn.c,v 1.14 2014/10/10 15:25:06 schwarze Exp $ */
d4 1
d488 1
d493 2
d497 6
@


1.14
log
@Partial eqn(7) rewrite by kristaps@@ in order to get operator precedence right.
@
text
@d1 1
a1 1
/*	$OpenBSD$
d657 1
a657 1
	enum eqn_tok	 tok;
a665 1
again:
d667 5
a671 1
	switch ((tok = eqn_tok_parse(ep, &p))) {
d690 3
a692 4
		if (NULL == eqn_nextrawtok(ep, NULL)) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
		}
d706 6
a711 3
		if (NULL == parent->last) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
d767 6
a772 4
		tok = eqn_tok_parse(ep, NULL);
		if (EQN_TOK__MAX != tok) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
d780 1
a780 4
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
d810 3
a812 2
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
d816 3
a818 2
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
d838 6
a843 3
		if (NULL == parent->last) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
d876 1
a876 4
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
d893 6
a898 3
		if (NULL == parent->last) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
d901 1
a901 4
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
d911 11
a921 5
		while (parent->type != EQN_LIST)
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
a922 4
			if (NULL == parent->left) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
d924 4
a927 2
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
d939 1
a939 4
		if (NULL == (parent = parent->parent)) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
		}
d947 1
a947 4
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
d957 7
a963 4
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
a966 5
			if (NULL == (start = eqn_nexttok(ep, &sz))) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
			/* Handling depends on right/left. */
d985 1
a985 8
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
		if (EQN_TOK_BRACE_OPEN != eqn_tok_parse(ep, NULL)) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
		}
d988 1
a988 2
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_LIST;
d991 9
a999 6
		while (parent->type != EQN_PILE)
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
		parent = eqn_box_alloc(ep, parent);
d1004 1
a1004 8
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
		if (EQN_TOK_BRACE_OPEN != eqn_tok_parse(ep, NULL)) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(-1);
		}
d1007 1
a1007 2
		parent = eqn_box_alloc(ep, parent);
		parent->type = EQN_LIST;
d1023 1
a1023 5
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				free(p);
				return(-1);
			}
d1041 2
a1042 5
			parent->args == parent->expectargs)
			if (NULL == (parent = parent->parent)) {
				EQN_MSG(MANDOCERR_EQNSYNT, ep);
				return(-1);
			}
d1045 1
a1045 1
	goto again;
@


1.13
log
@parse and render "from" and "to" clauses in eqn, and render matrices;
written by kristaps@@ during EuroBSDCon
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.12 2014/10/09 15:21:46 schwarze Exp $ */
d17 2
d31 2
d34 54
a87 1
#define	EQN_MSG(t, x)	 mandoc_msg((t), (x)->parse, (x)->eqn.ln, (x)->eqn.pos, NULL)
d89 47
a135 5
enum	eqn_rest {
	EQN_DESCOPE,
	EQN_ERR,
	EQN_OK,
	EQN_EOF
a200 30
enum	eqnpartt {
	EQN_DEFINE = 0,
	EQN_NDEFINE,
	EQN_TDEFINE,
	EQN_SET,
	EQN_UNDEF,
	EQN_GFONT,
	EQN_GSIZE,
	EQN_BACK,
	EQN_FWD,
	EQN_UP,
	EQN_DOWN,
	EQN__MAX
};

struct	eqnstr {
	const char	*name;
	size_t		 sz;
};

#define	STRNEQ(p1, sz1, p2, sz2) \
	((sz1) == (sz2) && 0 == strncmp((p1), (p2), (sz1)))
#define	EQNSTREQ(x, p, sz) \
	STRNEQ((x)->name, (x)->sz, (p), (sz))

struct	eqnpart {
	struct eqnstr	 str;
	int		(*fp)(struct eqn_node *);
};

d202 1
a202 1
	struct eqnstr	 str;
a205 78
static	enum eqn_rest	 eqn_box(struct eqn_node *, struct eqn_box *);
static	struct eqn_box	*eqn_box_alloc(struct eqn_node *,
				struct eqn_box *);
static	void		 eqn_box_free(struct eqn_box *);
static	struct eqn_def	*eqn_def_find(struct eqn_node *,
				const char *, size_t);
static	int		 eqn_do_gfont(struct eqn_node *);
static	int		 eqn_do_gsize(struct eqn_node *);
static	int		 eqn_do_define(struct eqn_node *);
static	int		 eqn_do_ign1(struct eqn_node *);
static	int		 eqn_do_ign2(struct eqn_node *);
static	int		 eqn_do_tdefine(struct eqn_node *);
static	int		 eqn_do_undef(struct eqn_node *);
static	enum eqn_rest	 eqn_eqn(struct eqn_node *, struct eqn_box *);
static	enum eqn_rest	 eqn_list(struct eqn_node *, struct eqn_box *);
static	enum eqn_rest	 eqn_matrix(struct eqn_node *, struct eqn_box *);
static	const char	*eqn_nexttok(struct eqn_node *, size_t *);
static	const char	*eqn_nextrawtok(struct eqn_node *, size_t *);
static	const char	*eqn_next(struct eqn_node *,
				char, size_t *, int);
static	void		 eqn_rewind(struct eqn_node *);

static	const struct eqnpart eqnparts[EQN__MAX] = {
	{ { "define", 6 }, eqn_do_define }, /* EQN_DEFINE */
	{ { "ndefine", 7 }, eqn_do_define }, /* EQN_NDEFINE */
	{ { "tdefine", 7 }, eqn_do_tdefine }, /* EQN_TDEFINE */
	{ { "set", 3 }, eqn_do_ign2 }, /* EQN_SET */
	{ { "undef", 5 }, eqn_do_undef }, /* EQN_UNDEF */
	{ { "gfont", 5 }, eqn_do_gfont }, /* EQN_GFONT */
	{ { "gsize", 5 }, eqn_do_gsize }, /* EQN_GSIZE */
	{ { "back", 4 }, eqn_do_ign1 }, /* EQN_BACK */
	{ { "fwd", 3 }, eqn_do_ign1 }, /* EQN_FWD */
	{ { "up", 2 }, eqn_do_ign1 }, /* EQN_UP */
	{ { "down", 4 }, eqn_do_ign1 }, /* EQN_DOWN */
};

static	const struct eqnstr eqnmarks[EQNMARK__MAX] = {
	{ "", 0 }, /* EQNMARK_NONE */
	{ "dot", 3 }, /* EQNMARK_DOT */
	{ "dotdot", 6 }, /* EQNMARK_DOTDOT */
	{ "hat", 3 }, /* EQNMARK_HAT */
	{ "tilde", 5 }, /* EQNMARK_TILDE */
	{ "vec", 3 }, /* EQNMARK_VEC */
	{ "dyad", 4 }, /* EQNMARK_DYAD */
	{ "bar", 3 }, /* EQNMARK_BAR */
	{ "under", 5 }, /* EQNMARK_UNDER */
};

static	const struct eqnstr eqnfonts[EQNFONT__MAX] = {
	{ "", 0 }, /* EQNFONT_NONE */
	{ "roman", 5 }, /* EQNFONT_ROMAN */
	{ "bold", 4 }, /* EQNFONT_BOLD */
	{ "fat", 3 }, /* EQNFONT_FAT */
	{ "italic", 6 }, /* EQNFONT_ITALIC */
};

static	const struct eqnstr eqnposs[EQNPOS__MAX] = {
	{ "", 0 }, /* EQNPOS_NONE */
	{ "over", 4 }, /* EQNPOS_OVER */
	{ "sup", 3 }, /* EQNPOS_SUP */
	{ NULL, 0 }, /* EQNPOS_SUBSUP */
	{ "sub", 3 }, /* EQNPOS_SUB */
	{ "to", 2 }, /* EQNPOS_TO */
	{ "from", 4 }, /* EQNPOS_FROM */
};

static	const struct eqnstr eqnpiles[EQNPILE__MAX] = {
	{ "", 0 }, /* EQNPILE_NONE */
	{ "pile", 4 }, /* EQNPILE_PILE */
	{ "cpile", 5 }, /* EQNPILE_CPILE */
	{ "rpile", 5 }, /* EQNPILE_RPILE */
	{ "lpile", 5 }, /* EQNPILE_LPILE */
	{ "col", 3 }, /* EQNPILE_COL */
	{ "ccol", 4 }, /* EQNPILE_CCOL */
	{ "rcol", 4 }, /* EQNPILE_RCOL */
	{ "lcol", 4 }, /* EQNPILE_LCOL */
};

d207 59
a265 59
	{ { "alpha", 5 }, "*a" }, /* EQNSYM_alpha */
	{ { "beta", 4 }, "*b" }, /* EQNSYM_beta */
	{ { "chi", 3 }, "*x" }, /* EQNSYM_chi */
	{ { "delta", 5 }, "*d" }, /* EQNSYM_delta */
	{ { "epsilon", 7 }, "*e" }, /* EQNSYM_epsilon */
	{ { "eta", 3 }, "*y" }, /* EQNSYM_eta */
	{ { "gamma", 5 }, "*g" }, /* EQNSYM_gamma */
	{ { "iota", 4 }, "*i" }, /* EQNSYM_iota */
	{ { "kappa", 5 }, "*k" }, /* EQNSYM_kappa */
	{ { "lambda", 6 }, "*l" }, /* EQNSYM_lambda */
	{ { "mu", 2 }, "*m" }, /* EQNSYM_mu */
	{ { "nu", 2 }, "*n" }, /* EQNSYM_nu */
	{ { "omega", 5 }, "*w" }, /* EQNSYM_omega */
	{ { "omicron", 7 }, "*o" }, /* EQNSYM_omicron */
	{ { "phi", 3 }, "*f" }, /* EQNSYM_phi */
	{ { "pi", 2 }, "*p" }, /* EQNSYM_pi */
	{ { "psi", 2 }, "*q" }, /* EQNSYM_psi */
	{ { "rho", 3 }, "*r" }, /* EQNSYM_rho */
	{ { "sigma", 5 }, "*s" }, /* EQNSYM_sigma */
	{ { "tau", 3 }, "*t" }, /* EQNSYM_tau */
	{ { "theta", 5 }, "*h" }, /* EQNSYM_theta */
	{ { "upsilon", 7 }, "*u" }, /* EQNSYM_upsilon */
	{ { "xi", 2 }, "*c" }, /* EQNSYM_xi */
	{ { "zeta", 4 }, "*z" }, /* EQNSYM_zeta */
	{ { "DELTA", 5 }, "*D" }, /* EQNSYM_DELTA */
	{ { "GAMMA", 5 }, "*G" }, /* EQNSYM_GAMMA */
	{ { "LAMBDA", 6 }, "*L" }, /* EQNSYM_LAMBDA */
	{ { "OMEGA", 5 }, "*W" }, /* EQNSYM_OMEGA */
	{ { "PHI", 3 }, "*F" }, /* EQNSYM_PHI */
	{ { "PI", 2 }, "*P" }, /* EQNSYM_PI */
	{ { "PSI", 3 }, "*Q" }, /* EQNSYM_PSI */
	{ { "SIGMA", 5 }, "*S" }, /* EQNSYM_SIGMA */
	{ { "THETA", 5 }, "*H" }, /* EQNSYM_THETA */
	{ { "UPSILON", 7 }, "*U" }, /* EQNSYM_UPSILON */
	{ { "XI", 2 }, "*C" }, /* EQNSYM_XI */
	{ { "inter", 5 }, "ca" }, /* EQNSYM_inter */
	{ { "union", 5 }, "cu" }, /* EQNSYM_union */
	{ { "prod", 4 }, "product" }, /* EQNSYM_prod */
	{ { "int", 3 }, "integral" }, /* EQNSYM_int */
	{ { "sum", 3 }, "sum" }, /* EQNSYM_sum */
	{ { "grad", 4 }, "gr" }, /* EQNSYM_grad */
	{ { "del", 3 }, "gr" }, /* EQNSYM_del */
	{ { "times", 5 }, "mu" }, /* EQNSYM_times */
	{ { "cdot", 4 }, "pc" }, /* EQNSYM_cdot */
	{ { "nothing", 7 }, "&" }, /* EQNSYM_nothing */
	{ { "approx", 6 }, "~~" }, /* EQNSYM_approx */
	{ { "prime", 5 }, "aq" }, /* EQNSYM_prime */
	{ { "half", 4 }, "12" }, /* EQNSYM_half */
	{ { "partial", 7 }, "pd" }, /* EQNSYM_partial */
	{ { "inf", 3 }, "if" }, /* EQNSYM_inf */
	{ { ">>", 2 }, ">>" }, /* EQNSYM_muchgreat */
	{ { "<<", 2 }, "<<" }, /* EQNSYM_muchless */
	{ { "<-", 2 }, "<-" }, /* EQNSYM_larrow */
	{ { "->", 2 }, "->" }, /* EQNSYM_rarrow */
	{ { "+-", 2 }, "+-" }, /* EQNSYM_pm */
	{ { "!=", 2 }, "!=" }, /* EQNSYM_nequal */
	{ { "==", 2 }, "==" }, /* EQNSYM_equiv */
	{ { "<=", 2 }, "<=" }, /* EQNSYM_lessequal */
	{ { ">=", 2 }, ">=" }, /* EQNSYM_moreequal */
a267 1

d341 5
a345 309
enum rofferr
eqn_end(struct eqn_node **epp)
{
	struct eqn_node	*ep;
	struct eqn_box	*root;
	enum eqn_rest	 c;

	ep = *epp;
	*epp = NULL;

	ep->eqn.root = mandoc_calloc(1, sizeof(struct eqn_box));

	root = ep->eqn.root;
	root->type = EQN_ROOT;

	if (0 == ep->sz)
		return(ROFF_IGN);

	if (EQN_DESCOPE == (c = eqn_eqn(ep, root))) {
		EQN_MSG(MANDOCERR_EQNNSCOPE, ep);
		c = EQN_ERR;
	}

	return(EQN_EOF == c ? ROFF_EQN : ROFF_IGN);
}

static enum eqn_rest
eqn_eqn(struct eqn_node *ep, struct eqn_box *last)
{
	struct eqn_box	*bp;
	enum eqn_rest	 c;

	bp = eqn_box_alloc(ep, last);
	bp->type = EQN_SUBEXPR;

	while (EQN_OK == (c = eqn_box(ep, bp)))
		/* Spin! */ ;

	return(c);
}

static enum eqn_rest
eqn_matrix(struct eqn_node *ep, struct eqn_box *last)
{
	struct eqn_box	*bp;
	const char	*start;
	size_t		 sz;
	enum eqn_rest	 c;

	bp = eqn_box_alloc(ep, last);
	bp->type = EQN_MATRIX;

	if (NULL == (start = eqn_nexttok(ep, &sz))) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(EQN_ERR);
	}
	if ( ! STRNEQ(start, sz, "{", 1)) {
		EQN_MSG(MANDOCERR_EQNSYNT, ep);
		return(EQN_ERR);
	}

	while (EQN_OK == (c = eqn_box(ep, bp)))
		switch (bp->last->pile) {
		case EQNPILE_LCOL:
			/* FALLTHROUGH */
		case EQNPILE_CCOL:
			/* FALLTHROUGH */
		case EQNPILE_RCOL:
			continue;
		default:
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(EQN_ERR);
		};

	if (EQN_DESCOPE != c) {
		if (EQN_EOF == c)
			EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(EQN_ERR);
	}

	eqn_rewind(ep);
	start = eqn_nexttok(ep, &sz);
	assert(start);
	if (STRNEQ(start, sz, "}", 1))
		return(EQN_OK);

	EQN_MSG(MANDOCERR_EQNBADSCOPE, ep);
	return(EQN_ERR);
}

static enum eqn_rest
eqn_list(struct eqn_node *ep, struct eqn_box *last)
{
	struct eqn_box	*bp;
	const char	*start;
	size_t		 sz;
	enum eqn_rest	 c;

	bp = eqn_box_alloc(ep, last);
	bp->type = EQN_LIST;

	if (NULL == (start = eqn_nexttok(ep, &sz))) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(EQN_ERR);
	}
	if ( ! STRNEQ(start, sz, "{", 1)) {
		EQN_MSG(MANDOCERR_EQNSYNT, ep);
		return(EQN_ERR);
	}

	while (EQN_DESCOPE == (c = eqn_eqn(ep, bp))) {
		eqn_rewind(ep);
		start = eqn_nexttok(ep, &sz);
		assert(start);
		if ( ! STRNEQ(start, sz, "above", 5))
			break;
	}

	if (EQN_DESCOPE != c) {
		if (EQN_ERR != c)
			EQN_MSG(MANDOCERR_EQNSCOPE, ep);
		return(EQN_ERR);
	}

	eqn_rewind(ep);
	start = eqn_nexttok(ep, &sz);
	assert(start);
	if (STRNEQ(start, sz, "}", 1))
		return(EQN_OK);

	EQN_MSG(MANDOCERR_EQNBADSCOPE, ep);
	return(EQN_ERR);
}

static enum eqn_rest
eqn_box(struct eqn_node *ep, struct eqn_box *last)
{
	size_t		 sz;
	const char	*start;
	char		*left;
	char		 sym[64];
	enum eqn_rest	 c;
	int		 i, size;
	struct eqn_box	*bp;

	if (NULL == (start = eqn_nexttok(ep, &sz)))
		return(EQN_EOF);

	if (STRNEQ(start, sz, "}", 1))
		return(EQN_DESCOPE);
	else if (STRNEQ(start, sz, "right", 5))
		return(EQN_DESCOPE);
	else if (STRNEQ(start, sz, "above", 5))
		return(EQN_DESCOPE);
	else if (STRNEQ(start, sz, "mark", 4))
		return(EQN_OK);
	else if (STRNEQ(start, sz, "lineup", 6))
		return(EQN_OK);

	for (i = 0; i < (int)EQN__MAX; i++) {
		if ( ! EQNSTREQ(&eqnparts[i].str, start, sz))
			continue;
		return((*eqnparts[i].fp)(ep) ? EQN_OK : EQN_ERR);
	}

	if (STRNEQ(start, sz, "{", 1)) {
		if (EQN_DESCOPE != (c = eqn_eqn(ep, last))) {
			if (EQN_ERR != c)
				EQN_MSG(MANDOCERR_EQNSCOPE, ep);
			return(EQN_ERR);
		}
		eqn_rewind(ep);
		start = eqn_nexttok(ep, &sz);
		assert(start);
		if (STRNEQ(start, sz, "}", 1))
			return(EQN_OK);
		EQN_MSG(MANDOCERR_EQNBADSCOPE, ep);
		return(EQN_ERR);
	}

	for (i = 0; i < (int)EQNPILE__MAX; i++) {
		if ( ! EQNSTREQ(&eqnpiles[i], start, sz))
			continue;
		if (EQN_OK == (c = eqn_list(ep, last)))
			last->last->pile = (enum eqn_pilet)i;
		return(c);
	}

	if (STRNEQ(start, sz, "matrix", 6))
		return(eqn_matrix(ep, last));

	if (STRNEQ(start, sz, "left", 4)) {
		if (NULL == (start = eqn_nexttok(ep, &sz))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		}
		left = mandoc_strndup(start, sz);
		c = eqn_eqn(ep, last);
		if (last->last)
			last->last->left = left;
		else
			free(left);
		if (EQN_DESCOPE != c)
			return(c);
		assert(last->last);
		eqn_rewind(ep);
		start = eqn_nexttok(ep, &sz);
		assert(start);
		if ( ! STRNEQ(start, sz, "right", 5))
			return(EQN_DESCOPE);
		if (NULL == (start = eqn_nexttok(ep, &sz))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		}
		last->last->right = mandoc_strndup(start, sz);
		return(EQN_OK);
	}

	/*
	 * Positional elements (e.g., over, sub, sup, ...).
	 */
	for (i = 0; i < (int)EQNPOS__MAX; i++) {
		/* Some elements don't have names (are virtual). */
		if (NULL == eqnposs[i].name)
			continue;
		else if ( ! EQNSTREQ(&eqnposs[i], start, sz))
			continue;
		if (NULL == last->last) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(EQN_ERR);
		}
		/*
		 * If we encounter x sub y sup z, then according to the
		 * eqn manual, we regard this as x subsup y z.
		 */
		if (EQNPOS_SUP == i &&
			NULL != last->last->prev &&
			EQNPOS_SUB == last->last->prev->pos)
			last->last->prev->pos = EQNPOS_SUBSUP;
		else if (EQNPOS_TO == i &&
			NULL != last->last->prev &&
			EQNPOS_FROM == last->last->prev->pos)
			last->last->prev->pos = EQNPOS_FROMTO;
		else
			last->last->pos = (enum eqn_post)i;

		if (EQN_EOF == (c = eqn_box(ep, last))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		}
		return(c);
	}

	for (i = 0; i < (int)EQNMARK__MAX; i++) {
		if ( ! EQNSTREQ(&eqnmarks[i], start, sz))
			continue;
		if (NULL == last->last) {
			EQN_MSG(MANDOCERR_EQNSYNT, ep);
			return(EQN_ERR);
		}
		last->last->mark = (enum eqn_markt)i;
		if (EQN_EOF == (c = eqn_box(ep, last))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		}
		return(c);
	}

	for (i = 0; i < (int)EQNFONT__MAX; i++) {
		if ( ! EQNSTREQ(&eqnfonts[i], start, sz))
			continue;
		if (EQN_EOF == (c = eqn_box(ep, last))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		} else if (EQN_OK == c)
			last->last->font = (enum eqn_fontt)i;
		return(c);
	}

	if (STRNEQ(start, sz, "size", 4)) {
		if (NULL == (start = eqn_nexttok(ep, &sz))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		}
		size = mandoc_strntoi(start, sz, 10);
		if (EQN_EOF == (c = eqn_box(ep, last))) {
			EQN_MSG(MANDOCERR_EQNEOF, ep);
			return(EQN_ERR);
		} else if (EQN_OK != c)
			return(c);
		last->last->size = size;
	}

	bp = eqn_box_alloc(ep, last);
	bp->type = EQN_TEXT;
	for (i = 0; i < (int)EQNSYM__MAX; i++)
		if (EQNSTREQ(&eqnsyms[i].str, start, sz)) {
			sym[63] = '\0';
			(void)snprintf(sym, 62, "\\[%s]", eqnsyms[i].sym);
			bp->text = mandoc_strdup(sym);
			return(EQN_OK);
		}

	bp->text = mandoc_strndup(start, sz);
	return(EQN_OK);
}

void
eqn_free(struct eqn_node *p)
d349 4
a352 1
	eqn_box_free(p->eqn.root);
d354 1
a354 64
	for (i = 0; i < (int)p->defsz; i++) {
		free(p->defs[i].key);
		free(p->defs[i].val);
	}

	free(p->eqn.name);
	free(p->data);
	free(p->defs);
	free(p);
}

static struct eqn_box *
eqn_box_alloc(struct eqn_node *ep, struct eqn_box *parent)
{
	struct eqn_box	*bp;

	bp = mandoc_calloc(1, sizeof(struct eqn_box));
	bp->parent = parent;
	bp->size = ep->gsize;

	if (NULL != parent->first) {
		parent->last->next = bp;
		bp->prev = parent->last;
	} else
		parent->first = bp;

	parent->last = bp;
	return(bp);
}

static void
eqn_box_free(struct eqn_box *bp)
{

	if (bp->first)
		eqn_box_free(bp->first);
	if (bp->next)
		eqn_box_free(bp->next);

	free(bp->text);
	free(bp->left);
	free(bp->right);
	free(bp);
}

static const char *
eqn_nextrawtok(struct eqn_node *ep, size_t *sz)
{

	return(eqn_next(ep, '"', sz, 0));
}

static const char *
eqn_nexttok(struct eqn_node *ep, size_t *sz)
{

	return(eqn_next(ep, '"', sz, 1));
}

static void
eqn_rewind(struct eqn_node *ep)
{

	ep->cur = ep->rew;
d357 5
d451 58
a508 2
static int
eqn_do_ign1(struct eqn_node *ep)
d511 4
a514 4
	if (NULL == eqn_nextrawtok(ep, NULL))
		EQN_MSG(MANDOCERR_EQNEOF, ep);
	else
		return(1);
d516 6
a521 1
	return(0);
d524 5
a528 2
static int
eqn_do_ign2(struct eqn_node *ep)
d530 17
d548 11
a558 6
	if (NULL == eqn_nextrawtok(ep, NULL))
		EQN_MSG(MANDOCERR_EQNEOF, ep);
	else if (NULL == eqn_nextrawtok(ep, NULL))
		EQN_MSG(MANDOCERR_EQNEOF, ep);
	else
		return(1);
d560 16
a575 1
	return(0);
d578 3
d582 1
a582 1
eqn_do_tdefine(struct eqn_node *ep)
d584 3
d588 1
a588 1
	if (NULL == eqn_nextrawtok(ep, NULL))
d590 3
a592 4
	else if (NULL == eqn_next(ep, ep->data[(int)ep->cur], NULL, 0))
		EQN_MSG(MANDOCERR_EQNEOF, ep);
	else
		return(1);
d594 1
a594 1
	return(0);
d598 1
a598 1
eqn_do_define(struct eqn_node *ep)
a613 1

d640 1
a640 1
		return(0);
d650 3
d654 1
a654 1
eqn_do_gfont(struct eqn_node *ep)
d656 8
d665 2
a666 6
	if (NULL == eqn_nextrawtok(ep, NULL)) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(0);
	}
	return(1);
}
d668 71
a738 5
static int
eqn_do_gsize(struct eqn_node *ep)
{
	const char	*start;
	size_t		 sz;
d740 285
a1024 2
	if (NULL == (start = eqn_nextrawtok(ep, &sz))) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
d1026 36
d1063 1
a1063 2
	ep->gsize = mandoc_strntoi(start, sz, 10);
	return(1);
d1066 2
a1067 2
static int
eqn_do_undef(struct eqn_node *ep)
d1069 1
a1069 3
	const char	*start;
	struct eqn_def	*def;
	size_t		 sz;
d1071 2
a1072 5
	if (NULL == (start = eqn_nextrawtok(ep, &sz))) {
		EQN_MSG(MANDOCERR_EQNEOF, ep);
		return(0);
	} else if (NULL != (def = eqn_def_find(ep, start, sz)))
		def->keysz = 0;
d1074 3
a1076 1
	return(1);
d1079 2
a1080 2
static struct eqn_def *
eqn_def_find(struct eqn_node *ep, const char *key, size_t sz)
d1084 6
a1089 4
	for (i = 0; i < (int)ep->defsz; i++)
		if (ep->defs[i].keysz && STRNEQ(ep->defs[i].key,
		    ep->defs[i].keysz, key, sz))
			return(&ep->defs[i]);
d1091 4
a1094 1
	return(NULL);
@


1.12
log
@parse simultaneous sub- and superscripts
and make the eqn_box list doubly linked;
written by kristaps@@ during EuroBSDCon
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.11 2014/07/06 19:08:56 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
d590 4
@


1.11
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.10 2014/07/04 16:11:41 schwarze Exp $ */
d197 1
d569 3
d573 4
a576 1
		if ( ! EQNSTREQ(&eqnposs[i], start, sz))
d582 11
a592 1
		last->last->pos = (enum eqn_post)i;
d681 4
a684 1
	if (NULL == parent->first)
a685 2
	else
		parent->last->next = bp;
@


1.10
log
@Clean up messages regarding excess arguments:
* Downgrade ".Bf -emphasis Em" from FATAL to WARNING.
* Mention the macros, the arguments, and the fallbacks.
* Hierarchical naming.
Also fix the handling of excess .It head arguments in -Tman.
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.9 2014/04/23 21:06:33 schwarze Exp $ */
d767 1
a767 1
			EQN_MSG(MANDOCERR_BADQUOTE, ep);
@


1.9
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
* Change eight reallocs to reallocarray to be safe from overflows.
* Change one malloc to reallocarray to be safe from overflows.
* Change one calloc to reallocarray, no zeroing needed.
* Change the order of arguments of three callocs (aesthetical).
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.8 2014/04/20 19:39:35 schwarze Exp $ */
d299 2
a300 1
		mandoc_msg(MANDOCERR_ARGSLOST, ep->parse, ln, pos, NULL);
@


1.8
log
@make sure static buffers for snprintf(3) are large enough
and cast snprintf return value to (void) where they are
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.7 2014/04/20 16:44:44 schwarze Exp $ */
d863 2
a864 2
			ep->defs = mandoc_realloc(ep->defs,
			    ep->defsz * sizeof(struct eqn_def));
@


1.7
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.6 2014/03/21 22:17:01 schwarze Exp $ */
d627 1
a627 1
			snprintf(sym, 62, "\\[%s]", eqnsyms[i].sym);
@


1.6
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.5 2011/09/18 15:54:48 schwarze Exp $ */
a136 1

d138 1
a138 1
static	struct eqn_box	*eqn_box_alloc(struct eqn_node *, 
d141 1
a141 1
static	struct eqn_def	*eqn_def_find(struct eqn_node *, 
d155 1
a155 1
static	const char	*eqn_next(struct eqn_node *, 
d276 1
a276 1
/* ARGSUSED */
d278 1
a278 1
eqn_read(struct eqn_node **epp, int ln, 
d297 1
a297 1
		if ('\0' == *p) 
d412 1
a412 1
		case (EQNPILE_LCOL):
d414 1
a414 1
		case (EQNPILE_CCOL):
d416 1
a416 1
		case (EQNPILE_RCOL):
d511 2
a512 3
		return((*eqnparts[i].fp)(ep) ? 
				EQN_OK : EQN_ERR);
	} 
d527 1
a527 1
	} 
d573 1
a573 1
		} 
d588 1
a588 1
		} 
d760 3
a762 3
				'\t' == ep->data[(int)ep->cur] ||
				'^' == ep->data[(int)ep->cur] ||
				'~' == ep->data[(int)ep->cur])
d788 2
a789 2
		memmove(start + *sz + diff, start + *sz, 
				(strlen(start) - *sz) + 1);
d850 2
a851 2
	/* 
	 * Search for a key that already exists. 
d863 2
a864 3
			ep->defs = mandoc_realloc
				(ep->defs, ep->defsz * 
				 sizeof(struct eqn_def));
d869 2
a870 2
		ep->defs[i].key = mandoc_realloc
			(ep->defs[i].key, sz + 1);
d898 1
a898 1
	} 
d911 1
a911 1
	} 
d937 3
a939 3
	for (i = 0; i < (int)ep->defsz; i++) 
		if (ep->defs[i].keysz && STRNEQ(ep->defs[i].key, 
					ep->defs[i].keysz, key, sz))
@


1.5
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.4 2011/09/18 10:25:28 schwarze Exp $ */
a16 4
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

d25 1
@


1.4
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.3 2011/04/24 16:22:02 schwarze Exp $ */
d26 1
@


1.3
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.2 2011/04/21 22:59:54 schwarze Exp $ */
d22 2
d31 248
d281 2
a282 1
eqn_read(struct eqn_node **epp, int ln, const char *p, int offs)
d286 1
a286 5

	if (0 == strcmp(p, ".EN")) {
		*epp = NULL;
		return(ROFF_EQN);
	}
d290 15
a304 4
	sz = strlen(&p[offs]);
	ep->eqn.data = mandoc_realloc(ep->eqn.data, ep->eqn.sz + sz + 1);
	if (0 == ep->eqn.sz)
		*ep->eqn.data = '\0';
d306 16
a321 2
	ep->eqn.sz += sz;
	strlcat(ep->eqn.data, &p[offs], ep->eqn.sz + 1);
d326 1
a326 1
eqn_alloc(int pos, int line)
d329 2
d333 13
a345 1
	p->eqn.line = line;
d347 1
d352 136
a487 3
/* ARGSUSED */
void
eqn_end(struct eqn_node *e)
d489 122
d612 26
a637 1
	/* Nothing to do. */
d643 8
d652 3
a654 1
	free(p->eqn.data);
d656 292
@


1.2
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: eqn.c,v 1.1 2011/03/21 00:48:02 schwarze Exp $ */
a25 1
#include "roff.h"
@


1.1
log
@This file was forgotten when importing the foundation for eqn(7) support.
Written by kristaps@@.
Sorry, and thanks to jmc@@ for noticing so quickly.
@
text
@d1 1
a1 1
/*	$Id: tbl.c,v 1.22 2011/01/25 12:24:27 schwarze Exp $ */
d66 1
@

