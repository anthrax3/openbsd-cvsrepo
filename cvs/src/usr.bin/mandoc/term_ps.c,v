head	1.47;
access;
symbols
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.45.0.2
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.8
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.6
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.4
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8;
locks; strict;
comment	@ * @;


1.47
date	2017.02.09.17.19.07;	author schwarze;	state Exp;
branches;
next	1.46;
commitid	M8rq0bbAM3ikHus0;

1.46
date	2016.08.10.11.02.30;	author schwarze;	state Exp;
branches;
next	1.45;
commitid	sL5KtBzF91hfUeVx;

1.45
date	2016.07.19.13.30.16;	author schwarze;	state Exp;
branches;
next	1.44;
commitid	vM0BMAmv88IMfvC0;

1.44
date	2015.12.23.20.31.17;	author mmcc;	state Exp;
branches;
next	1.43;
commitid	oFBXjZnc6s3CjmFB;

1.43
date	2015.10.13.22.57.49;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	jXIG8UzKLXm2Z9i6;

1.42
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.41;
commitid	Ql2ha5NS80pwfGNT;

1.41
date	2015.10.11.21.07.00;	author schwarze;	state Exp;
branches;
next	1.40;
commitid	fBGuLyDivJdmK1wz;

1.40
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	hxQV8O1pNUaef4ir;

1.39
date	2015.04.04.17.46.58;	author schwarze;	state Exp;
branches;
next	1.38;
commitid	exqqP0KNSHrSyO21;

1.38
date	2015.03.27.21.17.16;	author schwarze;	state Exp;
branches;
next	1.37;
commitid	r1NPkDobCJs0RcWM;

1.37
date	2015.01.21.19.40.22;	author schwarze;	state Exp;
branches;
next	1.36;
commitid	MOxfpclhY7KeK4KI;

1.36
date	2014.12.19.17.10.42;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	VKTVyFrMsLBbKLQJ;

1.35
date	2014.12.01.08.05.02;	author schwarze;	state Exp;
branches;
next	1.34;
commitid	dkxNPoJe0koFMMLd;

1.34
date	2014.11.20.13.55.23;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	qQSbPatDu3BAPGlr;

1.33
date	2014.10.28.17.35.42;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	pNwmOla3ZQwLgu2f;

1.32
date	2014.10.27.20.41.16;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	dNzHvfIx7To1JB37;

1.31
date	2014.08.28.01.36.10;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	AaaChPDUmI8YhReB;

1.30
date	2014.08.24.23.44.50;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	IESPjE39gk9ZgzlG;

1.29
date	2014.08.24.23.40.41;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	tc1UtLmknK68m0Au;

1.28
date	2014.08.13.22.09.28;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	HYRKgiWZb4BQrCNL;

1.27
date	2014.08.08.16.00.23;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	m0QaUWeqjuHsvBSO;

1.26
date	2014.07.27.21.53.04;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	EPc4lzWQC2YD7yrV;

1.25
date	2014.04.23.21.06.33;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2014.03.30.21.27.59;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2014.01.05.21.21.08;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2011.10.16.12.18.32;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.07.01.58.19;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.31.02.36.55;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.27.21.25.28;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.06.07.49.35;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.26.02.05.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2010.08.20.00.53.35;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.18.01.30.16;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2010.07.31.21.43.07;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.29.15.49.52;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.29.14.41.28;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.26.19.08.00;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.26.17.56.43;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.10.22.50.10;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Be consistent in protecting __attribute__ attributes with __;
from Christos Zoulas <christos @@ NetBSD>.
@
text
@/*	$OpenBSD: term_ps.c,v 1.46 2016/08/10 11:02:30 schwarze Exp $ */
/*
 * Copyright (c) 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2014, 2015, 2016 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <err.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "mandoc_aux.h"
#include "out.h"
#include "term.h"
#include "manconf.h"
#include "main.h"

/* These work the buffer used by the header and footer. */
#define	PS_BUFSLOP	  128

/* Convert PostScript point "x" to an AFM unit. */
#define	PNT2AFM(p, x) \
	(size_t)((double)(x) * (1000.0 / (double)(p)->ps->scale))

/* Convert an AFM unit "x" to a PostScript points */
#define	AFM2PNT(p, x) \
	((double)(x) / (1000.0 / (double)(p)->ps->scale))

struct	glyph {
	unsigned short	  wx; /* WX in AFM */
};

struct	font {
	const char	 *name; /* FontName in AFM */
#define	MAXCHAR		  95 /* total characters we can handle */
	struct glyph	  gly[MAXCHAR]; /* glyph metrics */
};

struct	termp_ps {
	int		  flags;
#define	PS_INLINE	 (1 << 0)	/* we're in a word */
#define	PS_MARGINS	 (1 << 1)	/* we're in the margins */
#define	PS_NEWPAGE	 (1 << 2)	/* new page, no words yet */
#define	PS_BACKSP	 (1 << 3)	/* last character was backspace */
	size_t		  pscol;	/* visible column (AFM units) */
	size_t		  pscolnext;	/* used for overstrike */
	size_t		  psrow;	/* visible row (AFM units) */
	char		 *psmarg;	/* margin buf */
	size_t		  psmargsz;	/* margin buf size */
	size_t		  psmargcur;	/* cur index in margin buf */
	char		  last;		/* last non-backspace seen */
	enum termfont	  lastf;	/* last set font */
	enum termfont	  nextf;	/* building next font here */
	size_t		  scale;	/* font scaling factor */
	size_t		  pages;	/* number of pages shown */
	size_t		  lineheight;	/* line height (AFM units) */
	size_t		  top;		/* body top (AFM units) */
	size_t		  bottom;	/* body bottom (AFM units) */
	size_t		  height;	/* page height (AFM units */
	size_t		  width;	/* page width (AFM units) */
	size_t		  lastwidth;	/* page width before last ll */
	size_t		  left;		/* body left (AFM units) */
	size_t		  header;	/* header pos (AFM units) */
	size_t		  footer;	/* footer pos (AFM units) */
	size_t		  pdfbytes;	/* current output byte */
	size_t		  pdflastpg;	/* byte of last page mark */
	size_t		  pdfbody;	/* start of body object */
	size_t		 *pdfobjs;	/* table of object offsets */
	size_t		  pdfobjsz;	/* size of pdfobjs */
};

static	int		  ps_hspan(const struct termp *,
				const struct roffsu *);
static	size_t		  ps_width(const struct termp *, int);
static	void		  ps_advance(struct termp *, size_t);
static	void		  ps_begin(struct termp *);
static	void		  ps_closepage(struct termp *);
static	void		  ps_end(struct termp *);
static	void		  ps_endline(struct termp *);
static	void		  ps_growbuf(struct termp *, size_t);
static	void		  ps_letter(struct termp *, int);
static	void		  ps_pclose(struct termp *);
static	void		  ps_plast(struct termp *);
static	void		  ps_pletter(struct termp *, int);
static	void		  ps_printf(struct termp *, const char *, ...)
				__attribute__((__format__ (__printf__, 2, 3)));
static	void		  ps_putchar(struct termp *, char);
static	void		  ps_setfont(struct termp *, enum termfont);
static	void		  ps_setwidth(struct termp *, int, int);
static	struct termp	 *pspdf_alloc(const struct manoutput *);
static	void		  pdf_obj(struct termp *, size_t);

/*
 * We define, for the time being, three fonts: bold, oblique/italic, and
 * normal (roman).  The following table hard-codes the font metrics for
 * ASCII, i.e., 32--127.
 */

static	const struct font fonts[TERMFONT__MAX] = {
	{ "Times-Roman", {
		{ 250 },
		{ 333 },
		{ 408 },
		{ 500 },
		{ 500 },
		{ 833 },
		{ 778 },
		{ 333 },
		{ 333 },
		{ 333 },
		{ 500 },
		{ 564 },
		{ 250 },
		{ 333 },
		{ 250 },
		{ 278 },
		{ 500 },
		{ 500 },
		{ 500 },
		{ 500 },
		{ 500 },
		{ 500 },
		{ 500 },
		{ 500 },
		{ 500 },
		{ 500 },
		{ 278 },
		{ 278 },
		{ 564 },
		{ 564 },
		{ 564 },
		{ 444 },
		{ 921 },
		{ 722 },
		{ 667 },
		{ 667 },
		{ 722 },
		{ 611 },
		{ 556 },
		{ 722 },
		{ 722 },
		{ 333 },
		{ 389 },
		{ 722 },
		{ 611 },
		{ 889 },
		{ 722 },
		{ 722 },
		{ 556 },
		{ 722 },
		{ 667 },
		{ 556 },
		{ 611 },
		{ 722 },
		{ 722 },
		{ 944 },
		{ 722 },
		{ 722 },
		{ 611 },
		{ 333 },
		{ 278 },
		{ 333 },
		{ 469 },
		{ 500 },
		{ 333 },
		{ 444 },
		{ 500 },
		{ 444 },
		{  500},
		{  444},
		{  333},
		{  500},
		{  500},
		{  278},
		{  278},
		{  500},
		{  278},
		{  778},
		{  500},
		{  500},
		{  500},
		{  500},
		{  333},
		{  389},
		{  278},
		{  500},
		{  500},
		{  722},
		{  500},
		{  500},
		{  444},
		{  480},
		{  200},
		{  480},
		{  541},
	} },
	{ "Times-Bold", {
		{ 250  },
		{ 333  },
		{ 555  },
		{ 500  },
		{ 500  },
		{ 1000 },
		{ 833  },
		{ 333  },
		{ 333  },
		{ 333  },
		{ 500  },
		{ 570  },
		{ 250  },
		{ 333  },
		{ 250  },
		{ 278  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 333  },
		{ 333  },
		{ 570  },
		{ 570  },
		{ 570  },
		{ 500  },
		{ 930  },
		{ 722  },
		{ 667  },
		{ 722  },
		{ 722  },
		{ 667  },
		{ 611  },
		{ 778  },
		{ 778  },
		{ 389  },
		{ 500  },
		{ 778  },
		{ 667  },
		{ 944  },
		{ 722  },
		{ 778  },
		{ 611  },
		{ 778  },
		{ 722  },
		{ 556  },
		{ 667  },
		{ 722  },
		{ 722  },
		{ 1000 },
		{ 722  },
		{ 722  },
		{ 667  },
		{ 333  },
		{ 278  },
		{ 333  },
		{ 581  },
		{ 500  },
		{ 333  },
		{ 500  },
		{ 556  },
		{ 444  },
		{  556 },
		{  444 },
		{  333 },
		{  500 },
		{  556 },
		{  278 },
		{  333 },
		{  556 },
		{  278 },
		{  833 },
		{  556 },
		{  500 },
		{  556 },
		{  556 },
		{  444 },
		{  389 },
		{  333 },
		{  556 },
		{  500 },
		{  722 },
		{  500 },
		{  500 },
		{  444 },
		{  394 },
		{  220 },
		{  394 },
		{  520 },
	} },
	{ "Times-Italic", {
		{ 250  },
		{ 333  },
		{ 420  },
		{ 500  },
		{ 500  },
		{ 833  },
		{ 778  },
		{ 333  },
		{ 333  },
		{ 333  },
		{ 500  },
		{ 675  },
		{ 250  },
		{ 333  },
		{ 250  },
		{ 278  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 500  },
		{ 333  },
		{ 333  },
		{ 675  },
		{ 675  },
		{ 675  },
		{ 500  },
		{ 920  },
		{ 611  },
		{ 611  },
		{ 667  },
		{ 722  },
		{ 611  },
		{ 611  },
		{ 722  },
		{ 722  },
		{ 333  },
		{ 444  },
		{ 667  },
		{ 556  },
		{ 833  },
		{ 667  },
		{ 722  },
		{ 611  },
		{ 722  },
		{ 611  },
		{ 500  },
		{ 556  },
		{ 722  },
		{ 611  },
		{ 833  },
		{ 611  },
		{ 556  },
		{ 556  },
		{ 389  },
		{ 278  },
		{ 389  },
		{ 422  },
		{ 500  },
		{ 333  },
		{ 500  },
		{ 500  },
		{ 444  },
		{  500 },
		{  444 },
		{  278 },
		{  500 },
		{  500 },
		{  278 },
		{  278 },
		{  444 },
		{  278 },
		{  722 },
		{  500 },
		{  500 },
		{  500 },
		{  500 },
		{  389 },
		{  389 },
		{  278 },
		{  500 },
		{  444 },
		{  667 },
		{  444 },
		{  444 },
		{  389 },
		{  400 },
		{  275 },
		{  400 },
		{  541 },
	} },
	{ "Times-BoldItalic", {
		{  250 },
		{  389 },
		{  555 },
		{  500 },
		{  500 },
		{  833 },
		{  778 },
		{  333 },
		{  333 },
		{  333 },
		{  500 },
		{  570 },
		{  250 },
		{  333 },
		{  250 },
		{  278 },
		{  500 },
		{  500 },
		{  500 },
		{  500 },
		{  500 },
		{  500 },
		{  500 },
		{  500 },
		{  500 },
		{  500 },
		{  333 },
		{  333 },
		{  570 },
		{  570 },
		{  570 },
		{  500 },
		{  832 },
		{  667 },
		{  667 },
		{  667 },
		{  722 },
		{  667 },
		{  667 },
		{  722 },
		{  778 },
		{  389 },
		{  500 },
		{  667 },
		{  611 },
		{  889 },
		{  722 },
		{  722 },
		{  611 },
		{  722 },
		{  667 },
		{  556 },
		{  611 },
		{  722 },
		{  667 },
		{  889 },
		{  667 },
		{  611 },
		{  611 },
		{  333 },
		{  278 },
		{  333 },
		{  570 },
		{  500 },
		{  333 },
		{  500 },
		{  500 },
		{  444 },
		{  500 },
		{  444 },
		{  333 },
		{  500 },
		{  556 },
		{  278 },
		{  278 },
		{  500 },
		{  278 },
		{  778 },
		{  556 },
		{  500 },
		{  500 },
		{  500 },
		{  389 },
		{  389 },
		{  278 },
		{  556 },
		{  444 },
		{  667 },
		{  500 },
		{  444 },
		{  389 },
		{  348 },
		{  220 },
		{  348 },
		{  570 },
	} },
};

void *
pdf_alloc(const struct manoutput *outopts)
{
	struct termp	*p;

	if (NULL != (p = pspdf_alloc(outopts)))
		p->type = TERMTYPE_PDF;

	return p;
}

void *
ps_alloc(const struct manoutput *outopts)
{
	struct termp	*p;

	if (NULL != (p = pspdf_alloc(outopts)))
		p->type = TERMTYPE_PS;

	return p;
}

static struct termp *
pspdf_alloc(const struct manoutput *outopts)
{
	struct termp	*p;
	unsigned int	 pagex, pagey;
	size_t		 marginx, marginy, lineheight;
	const char	*pp;

	p = mandoc_calloc(1, sizeof(struct termp));
	p->enc = TERMENC_ASCII;
	p->fontq = mandoc_reallocarray(NULL,
	    (p->fontsz = 8), sizeof(enum termfont));
	p->fontq[0] = p->fontl = TERMFONT_NONE;
	p->ps = mandoc_calloc(1, sizeof(struct termp_ps));

	p->advance = ps_advance;
	p->begin = ps_begin;
	p->end = ps_end;
	p->endline = ps_endline;
	p->hspan = ps_hspan;
	p->letter = ps_letter;
	p->setwidth = ps_setwidth;
	p->width = ps_width;

	/* Default to US letter (millimetres). */

	pagex = 216;
	pagey = 279;

	/*
	 * The ISO-269 paper sizes can be calculated automatically, but
	 * it would require bringing in -lm for pow() and I'd rather not
	 * do that.  So just do it the easy way for now.  Since this
	 * only happens once, I'm not terribly concerned.
	 */

	pp = outopts->paper;
	if (pp && strcasecmp(pp, "letter")) {
		if (0 == strcasecmp(pp, "a3")) {
			pagex = 297;
			pagey = 420;
		} else if (0 == strcasecmp(pp, "a4")) {
			pagex = 210;
			pagey = 297;
		} else if (0 == strcasecmp(pp, "a5")) {
			pagex = 148;
			pagey = 210;
		} else if (0 == strcasecmp(pp, "legal")) {
			pagex = 216;
			pagey = 356;
		} else if (2 != sscanf(pp, "%ux%u", &pagex, &pagey))
			warnx("%s: Unknown paper", pp);
	}

	/*
	 * This MUST be defined before any PNT2AFM or AFM2PNT
	 * calculations occur.
	 */

	p->ps->scale = 11;

	/* Remember millimetres -> AFM units. */

	pagex = PNT2AFM(p, ((double)pagex * 2.834));
	pagey = PNT2AFM(p, ((double)pagey * 2.834));

	/* Margins are 1/9 the page x and y. */

	marginx = (size_t)((double)pagex / 9.0);
	marginy = (size_t)((double)pagey / 9.0);

	/* Line-height is 1.4em. */

	lineheight = PNT2AFM(p, ((double)p->ps->scale * 1.4));

	p->ps->width = p->ps->lastwidth = (size_t)pagex;
	p->ps->height = (size_t)pagey;
	p->ps->header = pagey - (marginy / 2) - (lineheight / 2);
	p->ps->top = pagey - marginy;
	p->ps->footer = (marginy / 2) - (lineheight / 2);
	p->ps->bottom = marginy;
	p->ps->left = marginx;
	p->ps->lineheight = lineheight;

	p->defrmargin = pagex - (marginx * 2);
	return p;
}

static void
ps_setwidth(struct termp *p, int iop, int width)
{
	size_t	 lastwidth;

	lastwidth = p->ps->width;
	if (iop > 0)
		p->ps->width += width;
	else if (iop == 0)
		p->ps->width = width ? (size_t)width : p->ps->lastwidth;
	else if (p->ps->width > (size_t)width)
		p->ps->width -= width;
	else
		p->ps->width = 0;
	p->ps->lastwidth = lastwidth;
}

void
pspdf_free(void *arg)
{
	struct termp	*p;

	p = (struct termp *)arg;

	free(p->ps->psmarg);
	free(p->ps->pdfobjs);

	free(p->ps);
	term_free(p);
}

static void
ps_printf(struct termp *p, const char *fmt, ...)
{
	va_list		 ap;
	int		 pos, len;

	va_start(ap, fmt);

	/*
	 * If we're running in regular mode, then pipe directly into
	 * vprintf().  If we're processing margins, then push the data
	 * into our growable margin buffer.
	 */

	if ( ! (PS_MARGINS & p->ps->flags)) {
		len = vprintf(fmt, ap);
		va_end(ap);
		p->ps->pdfbytes += len < 0 ? 0 : (size_t)len;
		return;
	}

	/*
	 * XXX: I assume that the in-margin print won't exceed
	 * PS_BUFSLOP (128 bytes), which is reasonable but still an
	 * assumption that will cause pukeage if it's not the case.
	 */

	ps_growbuf(p, PS_BUFSLOP);

	pos = (int)p->ps->psmargcur;
	vsnprintf(&p->ps->psmarg[pos], PS_BUFSLOP, fmt, ap);

	va_end(ap);

	p->ps->psmargcur = strlen(p->ps->psmarg);
}

static void
ps_putchar(struct termp *p, char c)
{
	int		 pos;

	/* See ps_printf(). */

	if ( ! (PS_MARGINS & p->ps->flags)) {
		putchar(c);
		p->ps->pdfbytes++;
		return;
	}

	ps_growbuf(p, 2);

	pos = (int)p->ps->psmargcur++;
	p->ps->psmarg[pos++] = c;
	p->ps->psmarg[pos] = '\0';
}

static void
pdf_obj(struct termp *p, size_t obj)
{

	assert(obj > 0);

	if ((obj - 1) >= p->ps->pdfobjsz) {
		p->ps->pdfobjsz = obj + 128;
		p->ps->pdfobjs = mandoc_reallocarray(p->ps->pdfobjs,
		    p->ps->pdfobjsz, sizeof(size_t));
	}

	p->ps->pdfobjs[(int)obj - 1] = p->ps->pdfbytes;
	ps_printf(p, "%zu 0 obj\n", obj);
}

static void
ps_closepage(struct termp *p)
{
	int		 i;
	size_t		 len, base;

	/*
	 * Close out a page that we've already flushed to output.  In
	 * PostScript, we simply note that the page must be showed.  In
	 * PDF, we must now create the Length, Resource, and Page node
	 * for the page contents.
	 */

	assert(p->ps->psmarg && p->ps->psmarg[0]);
	ps_printf(p, "%s", p->ps->psmarg);

	if (TERMTYPE_PS != p->type) {
		ps_printf(p, "ET\n");

		len = p->ps->pdfbytes - p->ps->pdflastpg;
		base = p->ps->pages * 4 + p->ps->pdfbody;

		ps_printf(p, "endstream\nendobj\n");

		/* Length of content. */
		pdf_obj(p, base + 1);
		ps_printf(p, "%zu\nendobj\n", len);

		/* Resource for content. */
		pdf_obj(p, base + 2);
		ps_printf(p, "<<\n/ProcSet [/PDF /Text]\n");
		ps_printf(p, "/Font <<\n");
		for (i = 0; i < (int)TERMFONT__MAX; i++)
			ps_printf(p, "/F%d %d 0 R\n", i, 3 + i);
		ps_printf(p, ">>\n>>\n");

		/* Page node. */
		pdf_obj(p, base + 3);
		ps_printf(p, "<<\n");
		ps_printf(p, "/Type /Page\n");
		ps_printf(p, "/Parent 2 0 R\n");
		ps_printf(p, "/Resources %zu 0 R\n", base + 2);
		ps_printf(p, "/Contents %zu 0 R\n", base);
		ps_printf(p, ">>\nendobj\n");
	} else
		ps_printf(p, "showpage\n");

	p->ps->pages++;
	p->ps->psrow = p->ps->top;
	assert( ! (PS_NEWPAGE & p->ps->flags));
	p->ps->flags |= PS_NEWPAGE;
}

static void
ps_end(struct termp *p)
{
	size_t		 i, xref, base;

	ps_plast(p);
	ps_pclose(p);

	/*
	 * At the end of the file, do one last showpage.  This is the
	 * same behaviour as groff(1) and works for multiple pages as
	 * well as just one.
	 */

	if ( ! (PS_NEWPAGE & p->ps->flags)) {
		assert(0 == p->ps->flags);
		assert('\0' == p->ps->last);
		ps_closepage(p);
	}

	if (TERMTYPE_PS == p->type) {
		ps_printf(p, "%%%%Trailer\n");
		ps_printf(p, "%%%%Pages: %zu\n", p->ps->pages);
		ps_printf(p, "%%%%EOF\n");
		return;
	}

	pdf_obj(p, 2);
	ps_printf(p, "<<\n/Type /Pages\n");
	ps_printf(p, "/MediaBox [0 0 %zu %zu]\n",
			(size_t)AFM2PNT(p, p->ps->width),
			(size_t)AFM2PNT(p, p->ps->height));

	ps_printf(p, "/Count %zu\n", p->ps->pages);
	ps_printf(p, "/Kids [");

	for (i = 0; i < p->ps->pages; i++)
		ps_printf(p, " %zu 0 R", i * 4 + p->ps->pdfbody + 3);

	base = (p->ps->pages - 1) * 4 + p->ps->pdfbody + 4;

	ps_printf(p, "]\n>>\nendobj\n");
	pdf_obj(p, base);
	ps_printf(p, "<<\n");
	ps_printf(p, "/Type /Catalog\n");
	ps_printf(p, "/Pages 2 0 R\n");
	ps_printf(p, ">>\n");
	xref = p->ps->pdfbytes;
	ps_printf(p, "xref\n");
	ps_printf(p, "0 %zu\n", base + 1);
	ps_printf(p, "0000000000 65535 f \n");

	for (i = 0; i < base; i++)
		ps_printf(p, "%.10zu 00000 n \n",
		    p->ps->pdfobjs[(int)i]);

	ps_printf(p, "trailer\n");
	ps_printf(p, "<<\n");
	ps_printf(p, "/Size %zu\n", base + 1);
	ps_printf(p, "/Root %zu 0 R\n", base);
	ps_printf(p, "/Info 1 0 R\n");
	ps_printf(p, ">>\n");
	ps_printf(p, "startxref\n");
	ps_printf(p, "%zu\n", xref);
	ps_printf(p, "%%%%EOF\n");
}

static void
ps_begin(struct termp *p)
{
	int		 i;

	/*
	 * Print margins into margin buffer.  Nothing gets output to the
	 * screen yet, so we don't need to initialise the primary state.
	 */

	if (p->ps->psmarg) {
		assert(p->ps->psmargsz);
		p->ps->psmarg[0] = '\0';
	}

	/*p->ps->pdfbytes = 0;*/
	p->ps->psmargcur = 0;
	p->ps->flags = PS_MARGINS;
	p->ps->pscol = p->ps->left;
	p->ps->psrow = p->ps->header;

	ps_setfont(p, TERMFONT_NONE);

	(*p->headf)(p, p->argf);
	(*p->endline)(p);

	p->ps->pscol = p->ps->left;
	p->ps->psrow = p->ps->footer;

	(*p->footf)(p, p->argf);
	(*p->endline)(p);

	p->ps->flags &= ~PS_MARGINS;

	assert(0 == p->ps->flags);
	assert(p->ps->psmarg);
	assert('\0' != p->ps->psmarg[0]);

	/*
	 * Print header and initialise page state.  Following this,
	 * stuff gets printed to the screen, so make sure we're sane.
	 */

	if (TERMTYPE_PS == p->type) {
		ps_printf(p, "%%!PS-Adobe-3.0\n");
		ps_printf(p, "%%%%DocumentData: Clean7Bit\n");
		ps_printf(p, "%%%%Orientation: Portrait\n");
		ps_printf(p, "%%%%Pages: (atend)\n");
		ps_printf(p, "%%%%PageOrder: Ascend\n");
		ps_printf(p, "%%%%DocumentMedia: "
		    "Default %zu %zu 0 () ()\n",
		    (size_t)AFM2PNT(p, p->ps->width),
		    (size_t)AFM2PNT(p, p->ps->height));
		ps_printf(p, "%%%%DocumentNeededResources: font");

		for (i = 0; i < (int)TERMFONT__MAX; i++)
			ps_printf(p, " %s", fonts[i].name);

		ps_printf(p, "\n%%%%EndComments\n");
	} else {
		ps_printf(p, "%%PDF-1.1\n");
		pdf_obj(p, 1);
		ps_printf(p, "<<\n");
		ps_printf(p, ">>\n");
		ps_printf(p, "endobj\n");

		for (i = 0; i < (int)TERMFONT__MAX; i++) {
			pdf_obj(p, (size_t)i + 3);
			ps_printf(p, "<<\n");
			ps_printf(p, "/Type /Font\n");
			ps_printf(p, "/Subtype /Type1\n");
			ps_printf(p, "/Name /F%d\n", i);
			ps_printf(p, "/BaseFont /%s\n", fonts[i].name);
			ps_printf(p, ">>\n");
		}
	}

	p->ps->pdfbody = (size_t)TERMFONT__MAX + 3;
	p->ps->pscol = p->ps->left;
	p->ps->psrow = p->ps->top;
	p->ps->flags |= PS_NEWPAGE;
	ps_setfont(p, TERMFONT_NONE);
}

static void
ps_pletter(struct termp *p, int c)
{
	int		 f;

	/*
	 * If we haven't opened a page context, then output that we're
	 * in a new page and make sure the font is correctly set.
	 */

	if (PS_NEWPAGE & p->ps->flags) {
		if (TERMTYPE_PS == p->type) {
			ps_printf(p, "%%%%Page: %zu %zu\n",
			    p->ps->pages + 1, p->ps->pages + 1);
			ps_printf(p, "/%s %zu selectfont\n",
			    fonts[(int)p->ps->lastf].name,
			    p->ps->scale);
		} else {
			pdf_obj(p, p->ps->pdfbody +
			    p->ps->pages * 4);
			ps_printf(p, "<<\n");
			ps_printf(p, "/Length %zu 0 R\n",
			    p->ps->pdfbody + 1 + p->ps->pages * 4);
			ps_printf(p, ">>\nstream\n");
		}
		p->ps->pdflastpg = p->ps->pdfbytes;
		p->ps->flags &= ~PS_NEWPAGE;
	}

	/*
	 * If we're not in a PostScript "word" context, then open one
	 * now at the current cursor.
	 */

	if ( ! (PS_INLINE & p->ps->flags)) {
		if (TERMTYPE_PS != p->type) {
			ps_printf(p, "BT\n/F%d %zu Tf\n",
			    (int)p->ps->lastf, p->ps->scale);
			ps_printf(p, "%.3f %.3f Td\n(",
			    AFM2PNT(p, p->ps->pscol),
			    AFM2PNT(p, p->ps->psrow));
		} else
			ps_printf(p, "%.3f %.3f moveto\n(",
			    AFM2PNT(p, p->ps->pscol),
			    AFM2PNT(p, p->ps->psrow));
		p->ps->flags |= PS_INLINE;
	}

	assert( ! (PS_NEWPAGE & p->ps->flags));

	/*
	 * We need to escape these characters as per the PostScript
	 * specification.  We would also escape non-graphable characters
	 * (like tabs), but none of them would get to this point and
	 * it's superfluous to abort() on them.
	 */

	switch (c) {
	case '(':
	case ')':
	case '\\':
		ps_putchar(p, '\\');
		break;
	default:
		break;
	}

	/* Write the character and adjust where we are on the page. */

	f = (int)p->ps->lastf;

	if (c <= 32 || c - 32 >= MAXCHAR)
		c = 32;

	ps_putchar(p, (char)c);
	c -= 32;
	p->ps->pscol += (size_t)fonts[f].gly[c].wx;
}

static void
ps_pclose(struct termp *p)
{

	/*
	 * Spit out that we're exiting a word context (this is a
	 * "partial close" because we don't check the last-char buffer
	 * or anything).
	 */

	if ( ! (PS_INLINE & p->ps->flags))
		return;

	if (TERMTYPE_PS != p->type) {
		ps_printf(p, ") Tj\nET\n");
	} else
		ps_printf(p, ") show\n");

	p->ps->flags &= ~PS_INLINE;
}

/* If we have a `last' char that wasn't printed yet, print it now. */
static void
ps_plast(struct termp *p)
{
	size_t	 wx;

	if (p->ps->last == '\0')
		return;

	/* Check the font mode; open a new scope if it doesn't match. */

	if (p->ps->nextf != p->ps->lastf) {
		ps_pclose(p);
		ps_setfont(p, p->ps->nextf);
	}
	p->ps->nextf = TERMFONT_NONE;

	/*
	 * For an overstrike, if a previous character
	 * was wider, advance to center the new one.
	 */

	if (p->ps->pscolnext) {
		wx = fonts[p->ps->lastf].gly[(int)p->ps->last-32].wx;
		if (p->ps->pscol + wx < p->ps->pscolnext)
			p->ps->pscol = (p->ps->pscol +
			    p->ps->pscolnext - wx) / 2;
	}

	ps_pletter(p, p->ps->last);
	p->ps->last = '\0';

	/*
	 * For an overstrike, if a previous character
	 * was wider, advance to the end of the old one.
	 */

	if (p->ps->pscol < p->ps->pscolnext) {
		ps_pclose(p);
		p->ps->pscol = p->ps->pscolnext;
	}
}

static void
ps_letter(struct termp *p, int arg)
{
	size_t		savecol;
	char		c;

	c = arg >= 128 || arg <= 0 ? '?' : arg;

	/*
	 * When receiving a backspace, merely flag it.
	 * We don't know yet whether it is
	 * a font instruction or an overstrike.
	 */

	if (c == '\b') {
		assert(p->ps->last != '\0');
		assert( ! (p->ps->flags & PS_BACKSP));
		p->ps->flags |= PS_BACKSP;
		return;
	}

	/*
	 * Decode font instructions.
	 */

	if (p->ps->flags & PS_BACKSP) {
		if (p->ps->last == '_') {
			switch (p->ps->nextf) {
			case TERMFONT_BI:
				break;
			case TERMFONT_BOLD:
				p->ps->nextf = TERMFONT_BI;
				break;
			default:
				p->ps->nextf = TERMFONT_UNDER;
			}
			p->ps->last = c;
			p->ps->flags &= ~PS_BACKSP;
			return;
		}
		if (p->ps->last == c) {
			switch (p->ps->nextf) {
			case TERMFONT_BI:
				break;
			case TERMFONT_UNDER:
				p->ps->nextf = TERMFONT_BI;
				break;
			default:
				p->ps->nextf = TERMFONT_BOLD;
			}
			p->ps->flags &= ~PS_BACKSP;
			return;
		}

		/*
		 * This is not a font instruction, but rather
		 * the next character.  Prepare for overstrike.
		 */

		savecol = p->ps->pscol;
	} else
		savecol = SIZE_MAX;

	/*
	 * We found the next character, so the font instructions
	 * for the previous one are complete.
	 * Use them and print it.
	 */

	ps_plast(p);

	/*
	 * Do not print the current character yet because font
	 * instructions might follow; only remember the character.
	 * It will get printed later from ps_plast().
	 */

	p->ps->last = c;

	/*
	 * For an overstrike, back up to the previous position.
	 * If the previous character is wider than any it overstrikes,
	 * remember the current position, because it might also be
	 * wider than all that will overstrike it.
	 */

	if (savecol != SIZE_MAX) {
		if (p->ps->pscolnext < p->ps->pscol)
			p->ps->pscolnext = p->ps->pscol;
		ps_pclose(p);
		p->ps->pscol = savecol;
		p->ps->flags &= ~PS_BACKSP;
	} else
		p->ps->pscolnext = 0;
}

static void
ps_advance(struct termp *p, size_t len)
{

	/*
	 * Advance some spaces.  This can probably be made smarter,
	 * i.e., to have multiple space-separated words in the same
	 * scope, but this is easier:  just close out the current scope
	 * and readjust our column settings.
	 */

	ps_plast(p);
	ps_pclose(p);
	p->ps->pscol += len;
}

static void
ps_endline(struct termp *p)
{

	/* Close out any scopes we have open: we're at eoln. */

	ps_plast(p);
	ps_pclose(p);

	/*
	 * If we're in the margin, don't try to recalculate our current
	 * row.  XXX: if the column tries to be fancy with multiple
	 * lines, we'll do nasty stuff.
	 */

	if (PS_MARGINS & p->ps->flags)
		return;

	/* Left-justify. */

	p->ps->pscol = p->ps->left;

	/* If we haven't printed anything, return. */

	if (PS_NEWPAGE & p->ps->flags)
		return;

	/*
	 * Put us down a line.  If we're at the page bottom, spit out a
	 * showpage and restart our row.
	 */

	if (p->ps->psrow >= p->ps->lineheight + p->ps->bottom) {
		p->ps->psrow -= p->ps->lineheight;
		return;
	}

	ps_closepage(p);
}

static void
ps_setfont(struct termp *p, enum termfont f)
{

	assert(f < TERMFONT__MAX);
	p->ps->lastf = f;

	/*
	 * If we're still at the top of the page, let the font-setting
	 * be delayed until we actually have stuff to print.
	 */

	if (PS_NEWPAGE & p->ps->flags)
		return;

	if (TERMTYPE_PS == p->type)
		ps_printf(p, "/%s %zu selectfont\n",
		    fonts[(int)f].name, p->ps->scale);
	else
		ps_printf(p, "/F%d %zu Tf\n",
		    (int)f, p->ps->scale);
}

static size_t
ps_width(const struct termp *p, int c)
{

	if (c <= 32 || c - 32 >= MAXCHAR)
		c = 0;
	else
		c -= 32;

	return (size_t)fonts[(int)TERMFONT_NONE].gly[c].wx;
}

static int
ps_hspan(const struct termp *p, const struct roffsu *su)
{
	double		 r;

	/*
	 * All of these measurements are derived by converting from the
	 * native measurement to AFM units.
	 */
	switch (su->unit) {
	case SCALE_BU:
		/*
		 * Traditionally, the default unit is fixed to the
		 * output media.  So this would refer to the point.  In
		 * mandoc(1), however, we stick to the default terminal
		 * scaling unit so that output is the same regardless
		 * the media.
		 */
		r = PNT2AFM(p, su->scale * 72.0 / 240.0);
		break;
	case SCALE_CM:
		r = PNT2AFM(p, su->scale * 72.0 / 2.54);
		break;
	case SCALE_EM:
		r = su->scale *
		    fonts[(int)TERMFONT_NONE].gly[109 - 32].wx;
		break;
	case SCALE_EN:
		r = su->scale *
		    fonts[(int)TERMFONT_NONE].gly[110 - 32].wx;
		break;
	case SCALE_IN:
		r = PNT2AFM(p, su->scale * 72.0);
		break;
	case SCALE_MM:
		r = su->scale *
		    fonts[(int)TERMFONT_NONE].gly[109 - 32].wx / 100.0;
		break;
	case SCALE_PC:
		r = PNT2AFM(p, su->scale * 12.0);
		break;
	case SCALE_PT:
		r = PNT2AFM(p, su->scale * 1.0);
		break;
	case SCALE_VS:
		r = su->scale * p->ps->lineheight;
		break;
	default:
		r = su->scale;
		break;
	}

	return r * 24.0;
}

static void
ps_growbuf(struct termp *p, size_t sz)
{
	if (p->ps->psmargcur + sz <= p->ps->psmargsz)
		return;

	if (sz < PS_BUFSLOP)
		sz = PS_BUFSLOP;

	p->ps->psmargsz += sz;
	p->ps->psmarg = mandoc_realloc(p->ps->psmarg, p->ps->psmargsz);
}
@


1.46
log
@Fix assertion failures caused by whitespace inside \o'' (overstrike)
sequences that jsg@@ found with afl(1):
* Avoid writing \t\b in term.c.
* Handle trailing \b in term_ps.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.45 2016/07/19 13:30:16 schwarze Exp $ */
d103 1
a103 1
				__attribute__((__format__ (printf, 2, 3)));
@


1.45
log
@Use __attribute__((__format__ throughout.
Triggered by a smaller patch from Christos Zoulas.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.44 2015/12/23 20:31:17 mmcc Exp $ */
d4 1
a4 1
 * Copyright (c) 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
a96 1
static	void		  ps_fclose(struct termp *);
d100 1
d779 3
d1025 1
d1027 1
a1027 1
ps_fclose(struct termp *p)
d1029 12
d1043 2
a1044 5
	 * Strong closure: if we have a last-char, spit it out after
	 * checking that we're in the right font mode.  This will of
	 * course open a new scope, if applicable.
	 *
	 * Following this, close out any scope that's open.
d1047 5
a1051 9
	if (p->ps->last != '\0') {
		assert( ! (p->ps->flags & PS_BACKSP));
		if (p->ps->nextf != p->ps->lastf) {
			ps_pclose(p);
			ps_setfont(p, p->ps->nextf);
		}
		p->ps->nextf = TERMFONT_NONE;
		ps_pletter(p, p->ps->last);
		p->ps->last = '\0';
d1054 7
a1060 2
	if ( ! (PS_INLINE & p->ps->flags))
		return;
d1062 4
a1065 1
	ps_pclose(p);
d1071 1
a1071 1
	size_t		savecol, wx;
d1137 1
a1137 31
	if (p->ps->last != '\0') {
		if (p->ps->nextf != p->ps->lastf) {
			ps_pclose(p);
			ps_setfont(p, p->ps->nextf);
		}
		p->ps->nextf = TERMFONT_NONE;

		/*
		 * For an overstrike, if a previous character
		 * was wider, advance to center the new one.
		 */

		if (p->ps->pscolnext) {
			wx = fonts[p->ps->lastf].gly[(int)p->ps->last-32].wx;
			if (p->ps->pscol + wx < p->ps->pscolnext)
				p->ps->pscol = (p->ps->pscol +
				    p->ps->pscolnext - wx) / 2;
		}

		ps_pletter(p, p->ps->last);

		/*
		 * For an overstrike, if a previous character
		 * was wider, advance to the end of the old one.
		 */

		if (p->ps->pscol < p->ps->pscolnext) {
			ps_pclose(p);
			p->ps->pscol = p->ps->pscolnext;
		}
	}
d1141 2
a1142 3
	 * instructions might follow; only remember it.
	 * For the first character, nothing else is done.
	 * The final character will get printed from ps_fclose().
d1175 2
a1176 1
	ps_fclose(p);
d1186 2
a1187 1
	ps_fclose(p);
@


1.44
log
@remove NULL-checks before free()
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.43 2015/10/13 22:57:49 schwarze Exp $ */
d102 2
a103 1
static	void		  ps_printf(struct termp *, const char *, ...);
@


1.43
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.42 2015/10/12 00:07:27 schwarze Exp $ */
d640 2
a641 4
	if (p->ps->psmarg)
		free(p->ps->psmarg);
	if (p->ps->pdfobjs)
		free(p->ps->pdfobjs);
@


1.42
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.41 2015/10/11 21:07:00 schwarze Exp $ */
d106 1
a106 2
static	struct termp	 *pspdf_alloc(const struct mchars *,
				const struct manoutput *);
d507 1
a507 1
pdf_alloc(const struct mchars *mchars, const struct manoutput *outopts)
d511 1
a511 1
	if (NULL != (p = pspdf_alloc(mchars, outopts)))
d518 1
a518 1
ps_alloc(const struct mchars *mchars, const struct manoutput *outopts)
d522 1
a522 1
	if (NULL != (p = pspdf_alloc(mchars, outopts)))
d529 1
a529 1
pspdf_alloc(const struct mchars *mchars, const struct manoutput *outopts)
a536 1
	p->symtab = mchars;
@


1.41
log
@Finally use __progname, err(3) and warn(3).
That's more readable and less error-prone than fumbling around
with argv[0], fprintf(3), strerror(3), perror(3), and exit(3).
It also shortens the code by 50 lines.

It's a bad idea to boycott good interfaces merely because standards
committees ignore them.  Instead, it's the job of the portable
distribution to provide compatibility modules for archaic systems
(like commercial Solaris) that still don't have them.  Actually,
the compat code for the portable distribution already exists and
will be committed right after this.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.40 2015/10/06 18:30:44 schwarze Exp $ */
a983 1
		/* FALLTHROUGH */
a984 1
		/* FALLTHROUGH */
@


1.40
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.39 2015/04/04 17:46:58 schwarze Exp $ */
d21 1
d581 1
a581 1
			fprintf(stderr, "%s: Unknown paper\n", pp);
@


1.39
log
@Rounding rules for horizontal scaling widths are more complicated.
There is a first rounding to basic units on the input side.
After that, rounding rules differ between requests and macros.
Requests round to the nearest possible character position.
Macros round to the next character position to the left.

Implement that by changing the return value of term_hspan()
to basic units and leaving the second scaling and rounding stage
to the formatters instead of doing it in the terminal handler.

Improves for example argtable2(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.38 2015/03/27 21:17:16 schwarze Exp $ */
d514 1
a514 1
	return(p);
d525 1
a525 1
	return(p);
d614 1
a614 1
	return(p);
d1268 1
a1268 1
	return((size_t)fonts[(int)TERMFONT_NONE].gly[c].wx);
d1323 1
a1323 1
	return(r * 24.0);
@


1.38
log
@Actually use the new man.conf(5) "output" directive.
Additional functionality, yet minus 45 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.37 2015/01/21 19:40:22 schwarze Exp $ */
d88 1
a88 1
static	double		  ps_hspan(const struct termp *,
d104 1
a104 1
static	void		  ps_setwidth(struct termp *, int, size_t);
d618 1
a618 1
ps_setwidth(struct termp *p, int iop, size_t width)
d626 2
a627 2
		p->ps->width = width ? width : p->ps->lastwidth;
	else if (p->ps->width > width)
d1271 1
a1271 1
static double
d1323 1
a1323 1
	return(r);
@


1.37
log
@Improve overstriking.  When overstriking a wider character with a
narrower one, center the latter horizontally.  After a group of
characters printed in the same position, advance by the width of
the widest one among them.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.36 2014/12/19 17:10:42 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d31 1
d105 2
a106 1
static	struct termp	 *pspdf_alloc(const struct mchars *, char *);
d507 1
a507 1
pdf_alloc(const struct mchars *mchars, char *outopts)
d518 1
a518 1
ps_alloc(const struct mchars *mchars, char *outopts)
d529 1
a529 1
pspdf_alloc(const struct mchars *mchars, char *outopts)
a533 1
	const char	*toks[2];
a534 1
	char		*v;
a552 14
	toks[0] = "paper";
	toks[1] = NULL;

	pp = NULL;

	while (outopts && *outopts)
		switch (getsubopt(&outopts, UNCONST(toks), &v)) {
		case 0:
			pp = v;
			break;
		default:
			break;
		}

d565 1
@


1.36
log
@Enforcing an arbitrary, implementation dependent, undocumented limit
by calling assert() when valid user input exceeds it is a bad idea.
Allocate the terminal font stack dynamically instead of crashing
above 10 entries.  Issue found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.35 2014/12/01 08:05:02 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014 Ingo Schwarze <schwarze@@openbsd.org>
d61 1
d1071 1
a1071 1
	size_t		savecol;
d1143 13
d1157 10
d1180 3
d1186 2
d1191 2
a1192 1
	}
@


1.35
log
@header cleanup:
* add missing forward declarations
* remove needless header inclusions
* some style unification
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.34 2014/11/20 13:55:23 schwarze Exp $ */
d538 3
@


1.34
log
@Prevent negative arguments to the .ll request from causing integer
underflow.  Found while preparing an audit of termp.rmargin.

Overflow can also happen, but i see no sane way to deal with it,
so just let it happen.  It doesn't happen for any sane input anyway,
groff behaviour is undefined, and the resulting values are legal,
even though they are useless.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.33 2014/10/28 17:35:42 schwarze Exp $ */
a27 1
#include "mandoc.h"
d30 1
a31 1
#include "term.h"
@


1.33
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.32 2014/10/27 20:41:16 schwarze Exp $ */
d633 1
a633 1
	if (0 < iop)
d635 3
a637 1
	else if (0 > iop)
d640 1
a640 1
		p->ps->width = width ? width : p->ps->lastwidth;
@


1.32
log
@Support overstriking by backspace in PostScript and PDF output.
Of course, this is only a minor improvement; it would be much better
to support non-ASCII characters in these output modes, but that
would require major changes that i'm not going to work on right now.

The main reason for doing this is that it allows to get ASCII output
closer to groff.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.31 2014/08/28 01:36:10 schwarze Exp $ */
d104 1
a104 1
static	struct termp	 *pspdf_alloc(char *);
d505 1
a505 1
pdf_alloc(char *outopts)
d509 1
a509 1
	if (NULL != (p = pspdf_alloc(outopts)))
d516 1
a516 1
ps_alloc(char *outopts)
d520 1
a520 1
	if (NULL != (p = pspdf_alloc(outopts)))
d527 1
a527 1
pspdf_alloc(char *outopts)
d537 1
@


1.31
log
@I just noticed that -Tps writes "%%CreationDate:" headers.
That's an unwelcome leak of potentially private information.
Kill it with fire.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.30 2014/08/24 23:44:50 schwarze Exp $ */
d60 1
d66 1
a66 1
	char		  last;		/* character buffer */
d1046 1
a1046 1
		assert(p->ps->last != 8);
d1065 1
d1071 3
a1073 8
	 * When receiving an initial character, merely buffer it,
	 * because a backspace might follow to specify formatting.
	 * When receiving a backspace, use the buffered character
	 * to build the font instruction and clear the buffer.
	 * Only when there are two non-backspace characters in a row,
	 * activate the font built so far and print the first of them;
	 * the second, again, merely gets buffered.
	 * The final character will get printed from ps_fclose().
d1076 1
a1076 1
	if (c == 8) {
d1078 11
a1088 2
		assert(p->ps->last != 8);
		if ('_' == p->ps->last) {
d1098 5
a1102 1
		} else {
d1112 2
d1115 17
a1131 1
	} else if (p->ps->last != '\0' && p->ps->last != 8) {
d1139 8
d1148 10
@


1.30
log
@Oops.  Garbage collect unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: term_ps.c,v 1.29 2014/08/24 23:40:41 schwarze Exp $ */
a25 1
#include <time.h>
a848 1
	time_t		 t;
a888 2
	t = time(NULL);

a890 1
		ps_printf(p, "%%%%CreationDate: %s", ctime(&t));
@


1.29
log
@When support for bold italic font was added to the parsers and to the
generic parts of the formatters some time ago, the PostScript- and
PDF-specific part of the formatters was neglected.

Now pascal@@ reports that mandoc -Tps throws an assertion on perl(1),
apparently because that manual actually uses bold italic font.

So here is an overdue implementation of bold italic font support for
PostScript and PDF output.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1069 1
a1069 1
	char		cc, c;
@


1.28
log
@Begin cleanup of scaling units.
Note that we use 240u := 1i for all devices, even -Tps and -Tpdf.
Big fix of -Tascii rendering of f, m, and u.
Small fix of -Tascii rendering of c.
Big fix of -Thtml rendering of u.
Big fix of -Tps rendering of m, p, and u.
Clarify -Tps rendering of c.
Correct documentation of scaling units, in particular with respect to u.
This for example improves rendering of the OpenGL manuals.
Joint work with kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.64 2014/08/13 20:34:29 kristaps Exp $ */
d68 1
d405 97
d1049 3
a1051 2
	if ('\0' != p->ps->last) {
		if (p->ps->lastf != TERMFONT_NONE) {
d1053 1
a1053 1
			ps_setfont(p, TERMFONT_NONE);
d1055 1
d1074 8
a1081 6
	 * State machine dictates whether to buffer the last character
	 * or not.  Basically, encoded words are detected by checking if
	 * we're an "8" and switching on the buffer.  Then we put "8" in
	 * our buffer, and on the next charater, flush both character
	 * and buffer.  Thus, "regular" words are detected by having a
	 * regular character and a regular buffer character.
d1084 3
a1086 9
	if ('\0' == p->ps->last) {
		assert(8 != c);
		p->ps->last = c;
		return;
	} else if (8 == p->ps->last) {
		assert(8 != c);
		p->ps->last = '\0';
	} else if (8 == c) {
		assert(8 != p->ps->last);
d1088 18
a1105 3
			if (p->ps->lastf != TERMFONT_UNDER) {
				ps_pclose(p);
				ps_setfont(p, TERMFONT_UNDER);
a1106 3
		} else if (p->ps->lastf != TERMFONT_BOLD) {
			ps_pclose(p);
			ps_setfont(p, TERMFONT_BOLD);
d1108 2
a1109 4
		p->ps->last = c;
		return;
	} else {
		if (p->ps->lastf != TERMFONT_NONE) {
d1111 1
a1111 1
			ps_setfont(p, TERMFONT_NONE);
d1113 2
a1114 3
		cc = p->ps->last;
		p->ps->last = c;
		c = cc;
d1116 1
a1116 2

	ps_pletter(p, c);
@


1.27
log
@Clarity with respect to floating point handling:
Write double constants as double rather than integer literals.
Remove useless explicit (double) cast done at one place and nowhere else.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.26 2014/07/27 21:53:04 schwarze Exp $ */
a1112 1

d1114 10
d1125 9
a1133 1
		r = PNT2AFM(p, su->scale * 28.34);
d1138 4
d1146 1
a1146 12
		r = PNT2AFM(p, su->scale * 100.0);
		break;
	case SCALE_EM:
		r = su->scale *
		    fonts[(int)TERMFONT_NONE].gly[109 - 32].wx;
		break;
	case SCALE_MM:
		r = PNT2AFM(p, su->scale * 2.834);
		break;
	case SCALE_EN:
		r = su->scale *
		    fonts[(int)TERMFONT_NONE].gly[110 - 32].wx;
@


1.26
log
@code readability; no functional change
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.25 2014/04/23 21:06:33 schwarze Exp $ */
d1119 1
a1119 1
		r = PNT2AFM(p, su->scale * 72);
d1122 1
a1122 1
		r = PNT2AFM(p, su->scale * 12);
d1125 1
a1125 1
		r = PNT2AFM(p, su->scale * 100);
@


1.25
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
* Change eight reallocs to reallocarray to be safe from overflows.
* Change one malloc to reallocarray to be safe from overflows.
* Change one calloc to reallocarray, no zeroing needed.
* Change the order of arguments of three callocs (aesthetical).
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.24 2014/04/20 16:44:44 schwarze Exp $ */
d910 2
a911 5
	if (c <= 32 || (c - 32 >= MAXCHAR)) {
		ps_putchar(p, ' ');
		p->ps->pscol += (size_t)fonts[f].gly[0].wx;
		return;
	}
d1097 3
a1099 1
		return((size_t)fonts[(int)TERMFONT_NONE].gly[0].wx);
a1100 1
	c -= 32;
@


1.24
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.23 2014/03/30 21:27:59 schwarze Exp $ */
d624 2
a625 6
		p->ps->pdfobjs = realloc(p->ps->pdfobjs,
		    p->ps->pdfobjsz * sizeof(size_t));
		if (NULL == p->ps->pdfobjs) {
			perror(NULL);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d1161 1
a1161 3

	p->ps->psmarg = mandoc_realloc
		(p->ps->psmarg, p->ps->psmargsz);
@


1.23
log
@Support relative arguments to .ll (increase or decrease line length).
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.22 2014/03/30 19:47:32 schwarze Exp $ */
d39 1
a39 1
#define	PNT2AFM(p, x) /* LINTED */ \
d43 1
a43 1
#define	AFM2PNT(p, x) /* LINTED */ \
d79 1
a79 1
	size_t		  pdfbytes; 	/* current output byte */
d450 1
a450 1
	
d458 1
a458 1
		case (0):
d494 1
a494 1
	/* 
d508 2
a509 4
	marginx = /* LINTED */
		(size_t)((double)pagex / 9.0);
	marginy = /* LINTED */
		(size_t)((double)pagey / 9.0);
a527 1

a542 1

a558 1

d576 1
a576 2
		p->ps->pdfbytes += /* LINTED */
			len < 0 ? 0 : (size_t)len;
d580 1
a580 1
	/* 
a595 1

a603 1
		/* LINTED */
a615 1

d624 2
a625 3
		p->ps->pdfobjs = realloc
			(p->ps->pdfobjs, 
			 p->ps->pdfobjsz * sizeof(size_t));
a635 1

d668 1
a668 1
		for (i = 0; i < (int)TERMFONT__MAX; i++) 
a688 2

/* ARGSUSED */
d711 1
a711 1
	} 
d723 1
a723 2
		ps_printf(p, " %zu 0 R", i * 4 +
				p->ps->pdfbody + 3);
d725 1
a725 2
	base = (p->ps->pages - 1) * 4 + 
		p->ps->pdfbody + 4;
d739 2
a740 2
		ps_printf(p, "%.10zu 00000 n \n", 
				p->ps->pdfobjs[(int)i]);
a752 1

d759 1
a759 1
	/* 
d792 1
a792 1
	/* 
d807 3
a809 3
				"Default %zu %zu 0 () ()\n",
				(size_t)AFM2PNT(p, p->ps->width),
				(size_t)AFM2PNT(p, p->ps->height));
a840 1

d853 5
a857 6
			ps_printf(p, "%%%%Page: %zu %zu\n", 
					p->ps->pages + 1, 
					p->ps->pages + 1);
			ps_printf(p, "/%s %zu selectfont\n", 
					fonts[(int)p->ps->lastf].name, 
					p->ps->scale);
d859 2
a860 2
			pdf_obj(p, p->ps->pdfbody + 
					p->ps->pages * 4);
d862 2
a863 3
			ps_printf(p, "/Length %zu 0 R\n", 
					p->ps->pdfbody + 1 +
					p->ps->pages * 4);
d869 1
a869 1
	
d877 2
a878 3
			ps_printf(p, "BT\n/F%d %zu Tf\n", 
					(int)p->ps->lastf,
					p->ps->scale);
d880 2
a881 2
					AFM2PNT(p, p->ps->pscol),
					AFM2PNT(p, p->ps->psrow));
d883 3
a885 3
			ps_printf(p, "%.3f %.3f moveto\n(", 
					AFM2PNT(p, p->ps->pscol),
					AFM2PNT(p, p->ps->psrow));
d899 1
a899 1
	case ('('):
d901 1
a901 1
	case (')'):
d903 1
a903 1
	case ('\\'):
d918 1
a918 1
	} 
a924 1

d929 1
a929 1
	/* 
d937 1
a937 1
	
a945 1

a972 1

a977 1
	/* LINTED */
a1021 1

a1036 1

d1048 1
a1048 1
	 * lines, we'll do nasty stuff. 
d1068 1
a1068 2
	if (p->ps->psrow >= p->ps->lineheight + 
			p->ps->bottom) {
a1075 1

d1082 1
a1082 1
	
d1092 2
a1093 3
		ps_printf(p, "/%s %zu selectfont\n", 
				fonts[(int)f].name, 
				p->ps->scale);
d1095 2
a1096 3
		ps_printf(p, "/F%d %zu Tf\n", 
				(int)f, 
				p->ps->scale);
a1098 2

/* ARGSUSED */
a1109 1

d1114 1
a1114 1
	
d1121 1
a1121 1
	case (SCALE_CM):
d1124 1
a1124 1
	case (SCALE_IN):
d1127 1
a1127 1
	case (SCALE_PC):
d1130 1
a1130 1
	case (SCALE_PT):
d1133 1
a1133 1
	case (SCALE_EM):
d1135 1
a1135 1
			fonts[(int)TERMFONT_NONE].gly[109 - 32].wx;
d1137 1
a1137 1
	case (SCALE_MM):
d1140 1
a1140 1
	case (SCALE_EN):
d1142 1
a1142 1
			fonts[(int)TERMFONT_NONE].gly[110 - 32].wx;
d1144 1
a1144 1
	case (SCALE_VS):
a1168 1

@


1.22
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.21 2014/03/21 22:17:01 schwarze Exp $ */
d102 1
a102 1
static	void		  ps_setwidth(struct termp *, size_t);
d532 1
a532 1
ps_setwidth(struct termp *p, size_t width)
d537 6
a542 1
	p->ps->width = width ? width : p->ps->lastwidth;
@


1.21
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.20 2014/01/05 21:21:08 schwarze Exp $ */
d4 1
d75 1
d102 1
d448 1
d517 1
a517 1
	p->ps->width = (size_t)pagex;
d528 11
@


1.20
log
@Fix one case where a non-literal is used as format string.
Fix another case where a variable is formatted using the wrong type.
Patch from Joerg Sonnenberger <joerg@@NetBSD>.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.19 2011/10/16 12:18:32 schwarze Exp $ */
a16 4
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

d29 1
@


1.19
log
@Remove a bunch of useless assignments,
and assert that print_bvspace cannot be called on NULL pointers.
No change in behaviour, none of these were bugs,
but the code becomes easier to understand.
Based on a clang report posted by joerg@@; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.18 2011/09/18 15:54:48 schwarze Exp $ */
d827 1
a827 1
			ps_printf(p, "/Name /F%zu\n", i);
@


1.18
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.17 2011/05/29 21:22:18 schwarze Exp $ */
d491 1
a491 2
	} else if (NULL == pp)
		pp = "letter";
d578 1
a578 1
	len = vsnprintf(&p->ps->psmarg[pos], PS_BUFSLOP, fmt, ap);
@


1.17
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.16 2011/04/21 22:59:54 schwarze Exp $ */
d432 2
a433 1
	size_t		 pagex, pagey, marginx, marginy, lineheight;
d489 1
a489 1
		} else if (2 != sscanf(pp, "%zux%zu", &pagex, &pagey))
d517 2
a518 2
	p->ps->width = pagex;
	p->ps->height = pagey;
@


1.16
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.15 2011/03/07 01:58:19 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d37 3
d42 1
a42 1
	(size_t)((double)(x) * (1000.0 / (double)(p)->engine.ps.scale))
d46 1
a46 1
	((double)(x) / (1000.0 / (double)(p)->engine.ps.scale))
d58 48
a405 38
/* These work the buffer used by the header and footer. */
#define	PS_BUFSLOP	  128

static void
ps_growbuf(struct termp *p, size_t sz)
{
	if (p->engine.ps.psmargcur + sz <= p->engine.ps.psmargsz)
		return;

	if (sz < PS_BUFSLOP)
		sz = PS_BUFSLOP;

	p->engine.ps.psmargsz += sz;

	p->engine.ps.psmarg = mandoc_realloc
		(p->engine.ps.psmarg,
		 p->engine.ps.psmargsz);
}

static	double		  ps_hspan(const struct termp *,
				const struct roffsu *);
static	size_t		  ps_width(const struct termp *, char);
static	void		  ps_advance(struct termp *, size_t);
static	void		  ps_begin(struct termp *);
static	void		  ps_closepage(struct termp *);
static	void		  ps_end(struct termp *);
static	void		  ps_endline(struct termp *);
static	void		  ps_fclose(struct termp *);
static	void		  ps_letter(struct termp *, char);
static	void		  ps_pclose(struct termp *);
static	void		  ps_pletter(struct termp *, int);
static	void		  ps_printf(struct termp *, const char *, ...);
static	void		  ps_putchar(struct termp *, char);
static	void		  ps_setfont(struct termp *, enum termfont);
static	struct termp	 *pspdf_alloc(char *);
static	void		  pdf_obj(struct termp *, size_t);


a416 1

a427 1

d437 3
a439 1
	p = term_alloc(TERMENC_ASCII);
d498 1
a498 1
	p->engine.ps.scale = 11;
d514 1
a514 1
	lineheight = PNT2AFM(p, ((double)p->engine.ps.scale * 1.4));
d516 8
a523 8
	p->engine.ps.width = pagex;
	p->engine.ps.height = pagey;
	p->engine.ps.header = pagey - (marginy / 2) - (lineheight / 2);
	p->engine.ps.top = pagey - marginy;
	p->engine.ps.footer = (marginy / 2) - (lineheight / 2);
	p->engine.ps.bottom = marginy;
	p->engine.ps.left = marginx;
	p->engine.ps.lineheight = lineheight;
d537 4
a540 4
	if (p->engine.ps.psmarg)
		free(p->engine.ps.psmarg);
	if (p->engine.ps.pdfobjs)
		free(p->engine.ps.pdfobjs);
d542 1
d561 1
a561 1
	if ( ! (PS_MARGINS & p->engine.ps.flags)) {
d564 1
a564 1
		p->engine.ps.pdfbytes += /* LINTED */
d577 2
a578 2
	pos = (int)p->engine.ps.psmargcur;
	len = vsnprintf(&p->engine.ps.psmarg[pos], PS_BUFSLOP, fmt, ap);
d582 1
a582 1
	p->engine.ps.psmargcur = strlen(p->engine.ps.psmarg);
d593 1
a593 1
	if ( ! (PS_MARGINS & p->engine.ps.flags)) {
d596 1
a596 1
		p->engine.ps.pdfbytes++;
d602 3
a604 3
	pos = (int)p->engine.ps.psmargcur++;
	p->engine.ps.psmarg[pos++] = c;
	p->engine.ps.psmarg[pos] = '\0';
d614 6
a619 6
	if ((obj - 1) >= p->engine.ps.pdfobjsz) {
		p->engine.ps.pdfobjsz = obj + 128;
		p->engine.ps.pdfobjs = realloc
			(p->engine.ps.pdfobjs, 
			 p->engine.ps.pdfobjsz * sizeof(size_t));
		if (NULL == p->engine.ps.pdfobjs) {
d625 1
a625 1
	p->engine.ps.pdfobjs[(int)obj - 1] = p->engine.ps.pdfbytes;
d643 2
a644 2
	assert(p->engine.ps.psmarg && p->engine.ps.psmarg[0]);
	ps_printf(p, "%s", p->engine.ps.psmarg);
d649 2
a650 2
		len = p->engine.ps.pdfbytes - p->engine.ps.pdflastpg;
		base = p->engine.ps.pages * 4 + p->engine.ps.pdfbody;
d677 4
a680 4
	p->engine.ps.pages++;
	p->engine.ps.psrow = p->engine.ps.top;
	assert( ! (PS_NEWPAGE & p->engine.ps.flags));
	p->engine.ps.flags |= PS_NEWPAGE;
d696 3
a698 3
	if ( ! (PS_NEWPAGE & p->engine.ps.flags)) {
		assert(0 == p->engine.ps.flags);
		assert('\0' == p->engine.ps.last);
d704 1
a704 1
		ps_printf(p, "%%%%Pages: %zu\n", p->engine.ps.pages);
d712 2
a713 2
			(size_t)AFM2PNT(p, p->engine.ps.width),
			(size_t)AFM2PNT(p, p->engine.ps.height));
d715 1
a715 1
	ps_printf(p, "/Count %zu\n", p->engine.ps.pages);
d718 1
a718 1
	for (i = 0; i < p->engine.ps.pages; i++)
d720 1
a720 1
				p->engine.ps.pdfbody + 3);
d722 2
a723 2
	base = (p->engine.ps.pages - 1) * 4 + 
		p->engine.ps.pdfbody + 4;
d731 1
a731 1
	xref = p->engine.ps.pdfbytes;
d738 1
a738 1
				p->engine.ps.pdfobjs[(int)i]);
d763 3
a765 3
	if (p->engine.ps.psmarg) {
		assert(p->engine.ps.psmargsz);
		p->engine.ps.psmarg[0] = '\0';
d768 5
a772 5
	/*p->engine.ps.pdfbytes = 0;*/
	p->engine.ps.psmargcur = 0;
	p->engine.ps.flags = PS_MARGINS;
	p->engine.ps.pscol = p->engine.ps.left;
	p->engine.ps.psrow = p->engine.ps.header;
d779 2
a780 2
	p->engine.ps.pscol = p->engine.ps.left;
	p->engine.ps.psrow = p->engine.ps.footer;
d785 1
a785 1
	p->engine.ps.flags &= ~PS_MARGINS;
d787 3
a789 3
	assert(0 == p->engine.ps.flags);
	assert(p->engine.ps.psmarg);
	assert('\0' != p->engine.ps.psmarg[0]);
d807 2
a808 2
				(size_t)AFM2PNT(p, p->engine.ps.width),
				(size_t)AFM2PNT(p, p->engine.ps.height));
d833 4
a836 4
	p->engine.ps.pdfbody = (size_t)TERMFONT__MAX + 3;
	p->engine.ps.pscol = p->engine.ps.left;
	p->engine.ps.psrow = p->engine.ps.top;
	p->engine.ps.flags |= PS_NEWPAGE;
d851 1
a851 1
	if (PS_NEWPAGE & p->engine.ps.flags) {
d854 2
a855 2
					p->engine.ps.pages + 1, 
					p->engine.ps.pages + 1);
d857 2
a858 2
					fonts[(int)p->engine.ps.lastf].name, 
					p->engine.ps.scale);
d860 2
a861 2
			pdf_obj(p, p->engine.ps.pdfbody + 
					p->engine.ps.pages * 4);
d864 2
a865 2
					p->engine.ps.pdfbody + 1 +
					p->engine.ps.pages * 4);
d868 2
a869 2
		p->engine.ps.pdflastpg = p->engine.ps.pdfbytes;
		p->engine.ps.flags &= ~PS_NEWPAGE;
d877 1
a877 1
	if ( ! (PS_INLINE & p->engine.ps.flags)) {
d880 2
a881 2
					(int)p->engine.ps.lastf,
					p->engine.ps.scale);
d883 2
a884 2
					AFM2PNT(p, p->engine.ps.pscol),
					AFM2PNT(p, p->engine.ps.psrow));
d887 3
a889 3
					AFM2PNT(p, p->engine.ps.pscol),
					AFM2PNT(p, p->engine.ps.psrow));
		p->engine.ps.flags |= PS_INLINE;
d892 1
a892 1
	assert( ! (PS_NEWPAGE & p->engine.ps.flags));
d915 1
a915 1
	f = (int)p->engine.ps.lastf;
d919 1
a919 1
		p->engine.ps.pscol += (size_t)fonts[f].gly[0].wx;
d925 1
a925 1
	p->engine.ps.pscol += (size_t)fonts[f].gly[c].wx;
d939 1
a939 1
	if ( ! (PS_INLINE & p->engine.ps.flags))
d947 1
a947 1
	p->engine.ps.flags &= ~PS_INLINE;
d963 2
a964 2
	if ('\0' != p->engine.ps.last) {
		if (p->engine.ps.lastf != TERMFONT_NONE) {
d968 2
a969 2
		ps_pletter(p, p->engine.ps.last);
		p->engine.ps.last = '\0';
d972 1
a972 1
	if ( ! (PS_INLINE & p->engine.ps.flags))
d980 1
a980 1
ps_letter(struct termp *p, char c)
d982 4
a985 1
	char		cc;
d996 1
a996 1
	if ('\0' == p->engine.ps.last) {
d998 1
a998 1
		p->engine.ps.last = c;
d1000 1
a1000 1
	} else if (8 == p->engine.ps.last) {
d1002 1
a1002 1
		p->engine.ps.last = '\0';
d1004 3
a1006 3
		assert(8 != p->engine.ps.last);
		if ('_' == p->engine.ps.last) {
			if (p->engine.ps.lastf != TERMFONT_UNDER) {
d1010 1
a1010 1
		} else if (p->engine.ps.lastf != TERMFONT_BOLD) {
d1014 1
a1014 1
		p->engine.ps.last = c;
d1017 1
a1017 1
		if (p->engine.ps.lastf != TERMFONT_NONE) {
d1021 2
a1022 2
		cc = p->engine.ps.last;
		p->engine.ps.last = c;
d1042 1
a1042 1
	p->engine.ps.pscol += len;
d1060 1
a1060 1
	if (PS_MARGINS & p->engine.ps.flags)
d1065 1
a1065 1
	p->engine.ps.pscol = p->engine.ps.left;
d1069 1
a1069 1
	if (PS_NEWPAGE & p->engine.ps.flags)
d1077 3
a1079 3
	if (p->engine.ps.psrow >= p->engine.ps.lineheight + 
			p->engine.ps.bottom) {
		p->engine.ps.psrow -= p->engine.ps.lineheight;
d1092 1
a1092 1
	p->engine.ps.lastf = f;
d1099 1
a1099 1
	if (PS_NEWPAGE & p->engine.ps.flags)
d1105 1
a1105 1
				p->engine.ps.scale);
d1109 1
a1109 1
				p->engine.ps.scale);
d1115 1
a1115 1
ps_width(const struct termp *p, char c)
d1122 1
a1122 1
	return((size_t)fonts[(int)TERMFONT_NONE].gly[(int)c].wx);
d1161 1
a1161 1
		r = su->scale * p->engine.ps.lineheight;
d1169 15
@


1.15
log
@Do not leak information about the software used
into PostScript and PDF documents behind the user's back.
Joerg Sonnenberger pointed out that almost all software
creating PostScript and PDF documents does so, even on OpenBSD,
but that doesn't make the leakage much better in my book.
According to all standards i could find, this information is optional.
Issue originally reported by deraadt@@; "commit!" kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.14 2011/01/31 02:36:55 schwarze Exp $ */
d369 1
a369 1
	p->engine.ps.psmarg = realloc
a371 5
	
	if (NULL == p->engine.ps.psmarg) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
@


1.14
log
@Remove unnecessary conditional: term_alloc() cannot return NULL;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.13 2010/09/27 21:25:28 schwarze Exp $ */
a790 1
		ps_printf(p, "%%%%Creator: mandoc-%s\n", VERSION);
a809 1
		ps_printf(p, "/Creator mandoc-%s\n", VERSION);
@


1.13
log
@Merge the last bits of 1.10.6 (released today), most were already in:
* ignore double-.Pp
* ignore .Pp before .Bd and .Bl (unless -compact in specified)
* avoid double blank line upon .Pp, .br and friends in literal context
* cast enums to int when passing them to exit(3) to please lint(1)
While merging, fix a regression introduced by kristaps@@:
Outside literal mode, double blank lines must both be printed.
To achieve this again after kristaps@@ improvements in 1.10.6,
treat such blank lines as .sp (instead of .Pp as in 1.10.5)
and drop .Pp before .sp just like dropping .Pp before .Pp.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.12 2010/09/06 07:49:35 jsg Exp $ */
d431 1
a431 2
	if (NULL == (p = term_alloc(TERMENC_ASCII)))
		return(NULL);
@


1.12
log
@fix an off by one found by parfait
ok schwarze@@ and kristaps
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.11 2010/08/26 02:05:02 deraadt Exp $ */
d375 1
a375 1
		exit(MANDOCLEVEL_SYSERR);
d586 1
d613 1
a613 1
			exit(MANDOCLEVEL_SYSERR);
@


1.11
log
@sys/param.h is for kernel interface programs.
sys/types.h is the file you want to include.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.10 2010/08/20 00:53:35 schwarze Exp $ */
d910 1
a910 1
	if (c <= 32 || (c - 32 > MAXCHAR)) {
@


1.10
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.9 2010/08/18 01:30:16 schwarze Exp $ */
d21 1
a21 1
#include <sys/param.h>
@


1.9
log
@Turn the non-trivial PS_GROWBUF macro into a function.
Don't use MAX, it doesn't exist in the default namespace on Solaris.
From Joerg Sonnenberger, with a critical fix by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.8 2010/07/31 21:43:07 schwarze Exp $ */
d32 1
d375 1
a375 1
		exit(EXIT_FAILURE);
d612 1
a612 1
			exit(EXIT_FAILURE);
@


1.8
log
@Merge bsd.lv version 1.10.5: last larger batch of bug fixes before release.
NOT including Kristaps' .Bd -literal changes which cause regressions.
Features:
* -Tpdf now fully working
Bugfixes:
* proper handling of quoted strings by .ds in roff(7)
* allow empty .Dd
* make .Sm start no-spacing after the first output word
* underline .Ad
* minor fixes in -Thtml
and some optimisations in terminal output.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.7 2010/07/25 18:05:54 schwarze Exp $ */
a355 13
#define	PS_GROWBUF(p, sz) \
	do if ((p)->engine.ps.psmargcur + (sz) > \
			(p)->engine.ps.psmargsz) { \
		(p)->engine.ps.psmargsz += /* CONSTCOND */ \
			MAX(PS_BUFSLOP, (sz)); \
		(p)->engine.ps.psmarg = realloc \
			((p)->engine.ps.psmarg,  \
			 (p)->engine.ps.psmargsz); \
		if (NULL == (p)->engine.ps.psmarg) { \
			perror(NULL); \
			exit(EXIT_FAILURE); \
		} \
	} while (/* CONSTCOND */ 0)
d357 20
d566 1
a566 1
	PS_GROWBUF(p, PS_BUFSLOP);
d590 1
a590 1
	PS_GROWBUF(p, 2);
@


1.7
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.6 2010/07/13 01:09:13 schwarze Exp $ */
d387 1
d395 2
a396 2
	if (NULL == (p = pspdf_alloc(outopts)))
		return(p);
a397 1
	p->type = TERMTYPE_PDF;
d407 2
a408 2
	if (NULL == (p = pspdf_alloc(outopts)))
		return(p);
a409 1
	p->type = TERMTYPE_PS;
d524 2
a566 2
	p->engine.ps.pdfbytes += /* LINTED */
		len < 0 ? 0 : (size_t)len;
d592 22
d617 8
a624 1
	size_t		 len;
d629 1
a629 3
	if (TERMTYPE_PS == p->type) {
		ps_printf(p, "showpage\n");
	} else {
d631 1
d633 11
a643 12
		ps_printf(p, "endstream\n");
		ps_printf(p, "endobj\n");
		ps_printf(p, "%zu 0 obj\n", 
				p->engine.ps.pdfbody +
				(p->engine.ps.pages + 1) * 4 + 1);
		ps_printf(p, "%zu\n", len);
		ps_printf(p, "endobj\n");
		ps_printf(p, "%zu 0 obj\n", 
				p->engine.ps.pdfbody +
				(p->engine.ps.pages + 1) * 4 + 2);
		ps_printf(p, "<<\n");
		ps_printf(p, "/ProcSet [/PDF /Text]\n");
d647 4
a650 5
		ps_printf(p, ">>\n");
		ps_printf(p, ">>\n");
		ps_printf(p, "%zu 0 obj\n", 
				p->engine.ps.pdfbody +
				(p->engine.ps.pages + 1) * 4 + 3);
d654 5
a658 9
		ps_printf(p, "/Resources %zu 0 R\n",
				p->engine.ps.pdfbody +
				(p->engine.ps.pages + 1) * 4 + 2);
		ps_printf(p, "/Contents %zu 0 R\n",
				p->engine.ps.pdfbody +
				(p->engine.ps.pages + 1) * 4);
		ps_printf(p, ">>\n");
		ps_printf(p, "endobj\n");
	}
d671 1
a671 1
	size_t		 i, xref;
d692 2
a693 3
	ps_printf(p, "2 0 obj\n");
	ps_printf(p, "<<\n");
	ps_printf(p, "/Type /Pages\n");
d702 8
a709 9
		ps_printf(p, " %zu 0 R", 
				p->engine.ps.pdfbody +
				(i + 1) * 4 + 3);
	ps_printf(p, "]\n");
	ps_printf(p, ">>\n");
	ps_printf(p, "endobj\n");
	ps_printf(p, "%zu 0 obj\n",
			p->engine.ps.pdfbody +
			(p->engine.ps.pages * 4) + 4);
d716 7
a722 4
	ps_printf(p, "0 %zu\n",
			p->engine.ps.pdfbody +
			(p->engine.ps.pages * 4) + 5);
	ps_printf(p, "0000000000 65535 f\n");
d725 2
a726 6
	ps_printf(p, "/Size %zu\n", 
			p->engine.ps.pdfbody +
			(p->engine.ps.pages * 4) + 5);
	ps_printf(p, "/Root %zu 0 R\n", 
			p->engine.ps.pdfbody +
			(p->engine.ps.pages * 4) + 4);
d751 1
a751 1
	p->engine.ps.pdfbytes = 0;
d801 1
a801 1
		ps_printf(p, "1 0 obj\n");
d808 1
a808 1
			ps_printf(p, "%d 0 obj\n", i + 3);
d845 2
a846 3
			ps_printf(p, "%zu 0 obj\n", 
					p->engine.ps.pdfbody +
					(p->engine.ps.pages + 1) * 4);
d849 2
a850 2
					p->engine.ps.pdfbody +
					(p->engine.ps.pages + 1) * 4 + 1);
@


1.6
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.5 2010/06/29 15:49:52 schwarze Exp $ */
d42 1
a42 1
	(size_t)((double)(x) / (1000.0 / (double)(p)->engine.ps.scale))
d45 1
a45 1
	size_t		  wx; /* WX in AFM */
d376 1
d386 14
d406 13
a432 1
	p->type = TERMTYPE_PS;
d517 1
a517 1
ps_free(void *arg)
d534 1
a534 1
	int		 pos;
d545 1
a545 1
		vprintf(fmt, ap);
d547 2
d561 1
a561 2
	vsnprintf(&p->engine.ps.psmarg[pos], PS_BUFSLOP, fmt, ap);
	p->engine.ps.psmargcur = strlen(p->engine.ps.psmarg);
d564 4
d580 1
d592 54
d650 1
d661 1
a661 4
		assert(p->engine.ps.psmarg && p->engine.ps.psmarg[0]);
		printf("%s", p->engine.ps.psmarg);
		p->engine.ps.pages++;
		printf("showpage\n");
d664 50
a713 3
	printf("%%%%Trailer\n");
	printf("%%%%Pages: %zu\n", p->engine.ps.pages);
	printf("%%%%EOF\n");
d733 1
d763 13
a775 14
	printf("%%!PS-Adobe-3.0\n");
	printf("%%%%Creator: mandoc-%s\n", VERSION);
	printf("%%%%CreationDate: %s", ctime(&t));
	printf("%%%%DocumentData: Clean7Bit\n");
	printf("%%%%Orientation: Portrait\n");
	printf("%%%%Pages: (atend)\n");
	printf("%%%%PageOrder: Ascend\n");
	printf("%%%%DocumentMedia: Default %zu %zu 0 () ()\n",
			AFM2PNT(p, p->engine.ps.width),
			AFM2PNT(p, p->engine.ps.height));
	printf("%%%%DocumentNeededResources: font");
	for (i = 0; i < (int)TERMFONT__MAX; i++)
		printf(" %s", fonts[i].name);
	printf("\n%%%%EndComments\n");
d777 24
d819 18
a836 6
		printf("%%%%Page: %zu %zu\n", 
				p->engine.ps.pages + 1, 
				p->engine.ps.pages + 1);
		ps_printf(p, "/%s %zu selectfont\n", 
				fonts[(int)p->engine.ps.lastf].name, 
				p->engine.ps.scale);
d846 11
a856 3
		ps_printf(p, "%zu %zu moveto\n(", 
				AFM2PNT(p, p->engine.ps.pscol),
				AFM2PNT(p, p->engine.ps.psrow));
d887 1
a887 1
		p->engine.ps.pscol += fonts[f].gly[0].wx;
d893 1
a893 1
	p->engine.ps.pscol += fonts[f].gly[c].wx;
d910 5
a914 1
	ps_printf(p, ") show\n");
d1048 1
a1048 7
	assert(p->engine.ps.psmarg && p->engine.ps.psmarg[0]);
	printf("%s", p->engine.ps.psmarg);
	printf("showpage\n");
	p->engine.ps.pages++;
	p->engine.ps.psrow = p->engine.ps.top;
	assert( ! (PS_NEWPAGE & p->engine.ps.flags));
	p->engine.ps.flags |= PS_NEWPAGE;
d1067 8
a1074 2
	ps_printf(p, "/%s %zu selectfont\n", 
			fonts[(int)f].name, p->engine.ps.scale);
d1084 1
a1084 1
		return(fonts[(int)TERMFONT_NONE].gly[0].wx);
d1087 1
a1087 1
	return(fonts[(int)TERMFONT_NONE].gly[(int)c].wx);
d1115 1
a1115 1
		r = su->scale * 
d1122 1
a1122 1
		r = su->scale * 
@


1.5
log
@sync to bsd.lv version 1.10.3:
* support -Tps -Opaper=a4 and -Opaper=letter
* lots of mandoc.1 manual improvements
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.4 2010/06/29 14:41:28 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
d30 1
d36 8
d45 1
a45 1
	int		  wx; /* WX in AFM */
d61 96
a156 96
	{ "Courier", {
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
d158 96
a253 96
	{ "Courier-Bold", {
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
d255 96
a350 96
	{ "Courier-Oblique", {
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
		{ 600 },
d371 4
a374 1
static	void		  ps_letter(struct termp *, char);
a376 1
static	void		  ps_advance(struct termp *, size_t);
d379 1
a379 1
static	size_t		  ps_width(const struct termp *, char);
d391 1
a391 1
	size_t		 pagex, pagey, margin;
d393 1
d399 1
a399 7
	/* Default is USA letter. */
	pagex = 612;
	pagey = 792;
	margin = 72;

	p->type = TERMTYPE_PS;
	p->letter = ps_letter;
a401 1
	p->advance = ps_advance;
d403 3
d407 1
a407 1

d411 2
d416 1
a416 7
			if (0 == strcasecmp(v, "a4")) {
				pagex = 595;
				pagey = 842;
			} else if (0 == strcasecmp(v, "letter")) {
				pagex = 612;
				pagey = 792;
			}
d422 52
a473 2
	assert(margin * 2 < pagex);
	assert(margin * 2 < pagey);
d477 6
a482 6
	p->engine.ps.header = pagey - (margin / 2);
	p->engine.ps.top = pagey - margin;
	p->engine.ps.footer = (margin / 2);
	p->engine.ps.bottom = margin;
	p->engine.ps.left = margin;
	p->engine.ps.lineheight = 12;
d484 1
a484 1
	p->defrmargin = pagex - (margin * 2);
d517 1
a517 1
	if ( ! (PS_MARGINS & p->engine.ps.psstate)) {
d546 1
a546 1
	if ( ! (PS_MARGINS & p->engine.ps.psstate)) {
d570 8
a577 6
	assert(0 == p->engine.ps.psstate);
	assert('\0' == p->engine.ps.last);
	assert(p->engine.ps.psmarg && p->engine.ps.psmarg[0]);
	printf("%s", p->engine.ps.psmarg);
	p->engine.ps.pages++;
	printf("showpage\n");
d602 1
a602 1
	p->engine.ps.psstate = PS_MARGINS;
d617 1
a617 1
	p->engine.ps.psstate &= ~PS_MARGINS;
d619 1
a619 1
	assert(0 == p->engine.ps.psstate);
a636 1
	printf("%%%%Orientation: Portrait\n");
d638 2
a639 2
			p->engine.ps.width,
			p->engine.ps.height);
a644 5
	printf("%%%%Page: %zu %zu\n", 
			p->engine.ps.pages + 1, 
			p->engine.ps.pages + 1);

	ps_setfont(p, TERMFONT_NONE);
d647 2
d656 15
d677 1
a677 1
	if ( ! (PS_INLINE & p->engine.ps.psstate)) {
d679 3
a681 3
				p->engine.ps.pscol, 
				p->engine.ps.psrow);
		p->engine.ps.psstate |= PS_INLINE;
d684 2
d711 1
a711 1
		p->engine.ps.pscol += (fonts[f].gly[0].wx / 100);
d715 1
a715 1
	ps_putchar(p, c);
d717 1
a717 1
	p->engine.ps.pscol += (fonts[f].gly[c].wx / 100);
d731 1
a731 1
	if ( ! (PS_INLINE & p->engine.ps.psstate))
d735 1
a735 1
	p->engine.ps.psstate &= ~PS_INLINE;
d760 1
a760 1
	if ( ! (PS_INLINE & p->engine.ps.psstate))
d845 10
a854 1
	if (PS_MARGINS & p->engine.ps.psstate)
a861 1
	p->engine.ps.pscol = p->engine.ps.left;
a869 3
	printf("%%%%Page: %zu %zu\n", 
			p->engine.ps.pages + 1, 
			p->engine.ps.pages + 1);
d873 2
a882 1
	ps_printf(p, "/%s 10 selectfont\n", fonts[(int)f].name);
d884 11
d904 1
a904 1
		return(fonts[(int)TERMFONT_NONE].gly[0].wx / 100);
d907 47
a953 1
	return(fonts[(int)TERMFONT_NONE].gly[(int)c].wx / 100);
d955 1
@


1.4
log
@framework for glyph width encoding; from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.3 2010/06/26 19:08:00 schwarze Exp $ */
d25 1
d377 1
a377 1
ps_alloc(void)
d381 2
d387 1
d399 18
@


1.3
log
@As a first step towards variable-width font support,
move all width calculations in term_*.c, *_width().
From kristaps.
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.2 2010/06/26 17:56:43 schwarze Exp $ */
d28 1
d34 9
a42 7
#define	PS_CHAR_WIDTH	  6
#define	PS_CHAR_HEIGHT	  12
#define	PS_CHAR_TOPMARG	 (792 - 24)
#define	PS_CHAR_TOP	 (PS_CHAR_TOPMARG - 36)
#define	PS_CHAR_LEFT	  36
#define	PS_CHAR_BOTMARG	  24
#define	PS_CHAR_BOT	 (PS_CHAR_BOTMARG + 36)
d44 301
d369 1
a369 1
static	void		  ps_pletter(struct termp *, char);
d379 1
d384 3
a386 2
	p->defrmargin = 78;
	p->tabwidth = 5;
d395 14
d498 1
d500 4
a503 1
	printf("%s\n", "%%EOF");
d510 2
d525 2
a526 2
	p->engine.ps.pscol = PS_CHAR_LEFT;
	p->engine.ps.psrow = PS_CHAR_TOPMARG;
d533 2
a534 2
	p->engine.ps.pscol = PS_CHAR_LEFT;
	p->engine.ps.psrow = PS_CHAR_BOTMARG;
d550 22
a571 1
	printf("%s\n", "%!PS");
d573 2
a574 2
	p->engine.ps.pscol = PS_CHAR_LEFT;
	p->engine.ps.psrow = PS_CHAR_TOP;
d579 1
a579 1
ps_pletter(struct termp *p, char c)
d581 1
d616 8
d625 2
a626 1
	p->engine.ps.pscol += PS_CHAR_WIDTH;
d736 1
a736 1
	p->engine.ps.pscol += len ? len * PS_CHAR_WIDTH : 0;
d762 4
a765 3
	p->engine.ps.pscol = PS_CHAR_LEFT;
	if (p->engine.ps.psrow >= PS_CHAR_HEIGHT + PS_CHAR_BOT) {
		p->engine.ps.psrow -= PS_CHAR_HEIGHT;
d771 3
d775 2
a776 1
	p->engine.ps.psrow = PS_CHAR_TOP;
d784 2
a785 8
	if (TERMFONT_BOLD == f) 
		ps_printf(p, "/Courier-Bold\n");
	else if (TERMFONT_UNDER == f)
		ps_printf(p, "/Courier-Oblique\n");
	else
		ps_printf(p, "/Courier\n");

	ps_printf(p, "10 selectfont\n");
d790 1
d795 5
a799 1
	return(1);
@


1.2
log
@merge release 1.10.2
* bug fixes:
- interaction of ASCII_HYPH with special chars (found by Ulrich Spoerlein)
- handling of roff conditionals (found by Ulrich Spoerlein)
- .Bd -offset will no more default to 6n
* maintenance:
- more caching of .Bd and .Bl arguments for efficiency
- deconstify man(7) validation routines
- add FreeBSD library names (provided by Ulrich Spoerlein)
* start PostScript font-switching
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.1 2010/06/10 22:50:10 schwarze Exp $ */
d63 1
d79 3
d88 1
d433 7
@


1.1
log
@minimal initial -Tps support, from kristaps@@ GSOC
so far, monospace without font decoration,
but it already has page headers and footers
@
text
@d1 1
a1 1
/*	$Id: term_ps.c,v 1.1 2010/06/08 13:22:37 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d56 1
d62 3
d67 1
d169 2
d182 3
a184 3
	/*
	 * Emit the standard PostScript prologue, set our initial page
	 * position, then run pageopen() on the initial page.
a186 6
	printf("%s\n", "%!PS");
	printf("%s\n", "/Courier");
	printf("%s\n", "10 selectfont");

	p->engine.ps.psstate = 0;

d193 1
a193 7

	/*
	 * Now dump the margins into our margin buffer.  If we don't do
	 * this, we'd break any current state to run the header and
	 * footer with each and evern new page.
	 */

d197 1
a197 1
	p->engine.ps.psstate |= PS_MARGINS;
a201 3
	p->engine.ps.psstate &= ~PS_MARGINS;
	assert(0 == p->engine.ps.psstate);

a203 1
	p->engine.ps.psstate |= PS_MARGINS;
d209 1
d211 2
d214 7
a222 3

	assert(p->engine.ps.psmarg);
	assert('\0' != p->engine.ps.psmarg[0]);
d227 1
a227 1
ps_letter(struct termp *p, char c)
d230 5
a235 4
		/*
		 * If we're not in a PostScript "word" context, then
		 * open one now at the current cursor.
		 */
d262 1
d269 94
d366 6
a371 5
	if (PS_INLINE & p->engine.ps.psstate) {
		/* Dump out any existing line scope. */
		ps_printf(p, ") show\n");
		p->engine.ps.psstate &= ~PS_INLINE;
	}
d373 1
d382 9
a390 4
	if (PS_INLINE & p->engine.ps.psstate) {
		ps_printf(p, ") show\n");
		p->engine.ps.psstate &= ~PS_INLINE;
	} 
d395 5
d411 17
@

