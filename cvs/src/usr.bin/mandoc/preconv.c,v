head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.6
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.8
date	2017.02.18.13.43.34;	author schwarze;	state Exp;
branches;
next	1.7;
commitid	WXZP71GulY1lQoUX;

1.7
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.6;
commitid	hxQV8O1pNUaef4ir;

1.6
date	2015.03.09.21.30.27;	author schwarze;	state Exp;
branches;
next	1.5;
commitid	OIfy2YhnOvFteiXh;

1.5
date	2014.12.19.04.57.11;	author schwarze;	state Exp;
branches;
next	1.4;
commitid	bjUOzumNjzY2mijc;

1.4
date	2014.11.28.19.25.03;	author schwarze;	state Exp;
branches;
next	1.3;
commitid	1m1y3OocNVYDnyZE;

1.3
date	2014.11.14.04.23.08;	author schwarze;	state Exp;
branches;
next	1.2;
commitid	SxsslflsziqgH6kn;

1.2
date	2014.11.01.04.07.25;	author schwarze;	state Exp;
branches;
next	1.1;
commitid	dQ52Fm35XZoT76Y1;

1.1
date	2014.10.30.00.05.02;	author schwarze;	state Exp;
branches;
next	;
commitid	dxVoXRJjO1zZjAXI;


desc
@@


1.8
log
@preconv_encode() can take a const input buffer;
diff from <christos at NetBSD>
@
text
@/*	$OpenBSD: preconv.c,v 1.7 2015/10/06 18:30:44 schwarze Exp $ */
/*
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2014 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include "mandoc.h"
#include "libmandoc.h"

int
preconv_encode(const struct buf *ib, size_t *ii, struct buf *ob, size_t *oi,
    int *filenc)
{
	const unsigned char	*cu;
	int			 nby;
	unsigned int		 accum;

	cu = (const unsigned char *)ib->buf + *ii;
	assert(*cu & 0x80);

	if ( ! (*filenc & MPARSE_UTF8))
		goto latin;

	nby = 1;
	while (nby < 5 && *cu & (1 << (7 - nby)))
		nby++;

	switch (nby) {
	case 2:
		accum = *cu & 0x1f;
		if (accum < 0x02)  /* Obfuscated ASCII. */
			goto latin;
		break;
	case 3:
		accum = *cu & 0x0f;
		break;
	case 4:
		accum = *cu & 0x07;
		if (accum > 0x04) /* Beyond Unicode. */
			goto latin;
		break;
	default:  /* Bad sequence header. */
		goto latin;
	}

	cu++;
	switch (nby) {
	case 3:
		if ((accum == 0x00 && ! (*cu & 0x20)) ||  /* Use 2-byte. */
		    (accum == 0x0d && *cu & 0x20))  /* Surrogates. */
			goto latin;
		break;
	case 4:
		if ((accum == 0x00 && ! (*cu & 0x30)) ||  /* Use 3-byte. */
		    (accum == 0x04 && *cu & 0x30))  /* Beyond Unicode. */
			goto latin;
		break;
	default:
		break;
	}

	while (--nby) {
		if ((*cu & 0xc0) != 0x80)  /* Invalid continuation. */
			goto latin;
		accum <<= 6;
		accum += *cu & 0x3f;
		cu++;
	}

	assert(accum > 0x7f);
	assert(accum < 0x110000);
	assert(accum < 0xd800 || accum > 0xdfff);

	*oi += snprintf(ob->buf + *oi, 11, "\\[u%.4X]", accum);
	*ii = (const char *)cu - ib->buf;
	*filenc &= ~MPARSE_LATIN1;
	return 1;

latin:
	if ( ! (*filenc & MPARSE_LATIN1))
		return 0;

	*oi += snprintf(ob->buf + *oi, 11,
	    "\\[u%.4X]", (unsigned char)ib->buf[(*ii)++]);

	*filenc &= ~MPARSE_UTF8;
	return 1;
}

int
preconv_cue(const struct buf *b, size_t offset)
{
	const char	*ln, *eoln, *eoph;
	size_t		 sz, phsz;

	ln = b->buf + offset;
	sz = b->sz - offset;

	/* Look for the end-of-line. */

	if (NULL == (eoln = memchr(ln, '\n', sz)))
		eoln = ln + sz;

	/* Check if we have the correct header/trailer. */

	if ((sz = (size_t)(eoln - ln)) < 10 ||
	    memcmp(ln, ".\\\" -*-", 7) || memcmp(eoln - 3, "-*-", 3))
		return MPARSE_UTF8 | MPARSE_LATIN1;

	/* Move after the header and adjust for the trailer. */

	ln += 7;
	sz -= 10;

	while (sz > 0) {
		while (sz > 0 && ' ' == *ln) {
			ln++;
			sz--;
		}
		if (0 == sz)
			break;

		/* Find the end-of-phrase marker (or eoln). */

		if (NULL == (eoph = memchr(ln, ';', sz)))
			eoph = eoln - 3;
		else
			eoph++;

		/* Only account for the "coding" phrase. */

		if ((phsz = eoph - ln) < 7 ||
		    strncasecmp(ln, "coding:", 7)) {
			sz -= phsz;
			ln += phsz;
			continue;
		}

		sz -= 7;
		ln += 7;

		while (sz > 0 && ' ' == *ln) {
			ln++;
			sz--;
		}
		if (0 == sz)
			return 0;

		/* Check us against known encodings. */

		if (phsz > 4 && !strncasecmp(ln, "utf-8", 5))
			return MPARSE_UTF8;
		if (phsz > 10 && !strncasecmp(ln, "iso-latin-1", 11))
			return MPARSE_LATIN1;
		return 0;
	}
	return MPARSE_UTF8 | MPARSE_LATIN1;
}
@


1.7
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: preconv.c,v 1.6 2015/03/09 21:30:27 schwarze Exp $ */
d27 1
a27 1
preconv_encode(struct buf *ib, size_t *ii, struct buf *ob, size_t *oi,
d30 3
a32 3
	unsigned char	*cu;
	int		 nby;
	unsigned int	 accum;
d34 1
a34 1
	cu = (unsigned char *)ib->buf + *ii;
d91 1
a91 1
	*ii = (char *)cu - ib->buf;
@


1.6
log
@Explicitly cast when assigning from char * to unsigned char * and vice versa.
For example, gcc 4.7 wants this with -Wall.  Patch from kristaps@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: preconv.c,v 1.5 2014/12/19 04:57:11 schwarze Exp $ */
d93 1
a93 1
	return(1);
d97 1
a97 1
		return(0);
d103 1
a103 1
	return(1);
d124 1
a124 1
		return(MPARSE_UTF8 | MPARSE_LATIN1);
d163 1
a163 1
			return(0);
d168 1
a168 1
			return(MPARSE_UTF8);
d170 2
a171 2
			return(MPARSE_LATIN1);
		return(0);
d173 1
a173 1
	return(MPARSE_UTF8 | MPARSE_LATIN1);
@


1.5
log
@Rewrite the low-level UTF-8 parser from scratch.
It accepted invalid byte sequences like 0xc080-c1bf, 0xe08080-e09fbf,
0xeda080-edbfbf, and 0xf0808080-f08fbfbf, produced valid roff Unicode
escape sequences from them, and the algorithm contained strong
defenses against any attempt to fix it.

This cures an assertion failure in the terminal formatter caused
by sneaking in ASCII 0x08 (backspace) by "encoding" it as an (invalid)
multibyte UTF-8 sequence, found by jsg@@ with afl.

As a bonus, the new algorithm also reduces the code in the function
by about 20%.
@
text
@d1 1
a1 1
/*	$OpenBSD: preconv.c,v 1.4 2014/11/28 19:25:03 schwarze Exp $ */
d34 1
a34 1
	cu = ib->buf + *ii;
@


1.4
log
@Add some missing OpenBSD RCS markers
and a few missing <sys/types.h> inclusions; no code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: preconv.c,v 1.3 2014/11/14 04:23:08 schwarze Exp $ */
d20 1
d30 2
a31 2
	size_t		 i;
	int		 state;
d33 3
a35 1
	unsigned char	 cu;
d40 37
a76 2
	state = 0;
	accum = 0U;
d78 6
a83 68
	for (i = *ii; i < ib->sz; i++) {
		cu = ib->buf[i];
		if (state) {
			if ( ! (cu & 128) || (cu & 64)) {
				/* Bad sequence header. */
				break;
			}

			/* Accept only legitimate bit patterns. */

			if (cu > 191 || cu < 128) {
				/* Bad in-sequence bits. */
				break;
			}

			accum |= (cu & 63) << --state * 6;

			if (state)
				continue;

			if (accum < 0x80)
				ob->buf[(*oi)++] = accum;
			else
				*oi += snprintf(ob->buf + *oi,
				    11, "\\[u%.4X]", accum);
			*ii = i + 1;
			*filenc &= ~MPARSE_LATIN1;
			return(1);
		} else {
			/*
			 * Entering a UTF-8 state:  if we encounter a
			 * UTF-8 bitmask, calculate the expected UTF-8
			 * state from it.
			 */
			for (state = 0; state < 7; state++)
				if ( ! (cu & (1 << (7 - state))))
					break;

			/* Accept only legitimate bit patterns. */

			switch (state--) {
			case (4):
				if (cu <= 244 && cu >= 240) {
					accum = (cu & 7) << 18;
					continue;
				}
				/* Bad 4-sequence start bits. */
				break;
			case (3):
				if (cu <= 239 && cu >= 224) {
					accum = (cu & 15) << 12;
					continue;
				}
				/* Bad 3-sequence start bits. */
				break;
			case (2):
				if (cu <= 223 && cu >= 194) {
					accum = (cu & 31) << 6;
					continue;
				}
				/* Bad 2-sequence start bits. */
				break;
			default:
				/* Bad sequence bit mask. */
				break;
			}
			break;
		}
d86 8
a93 1
	/* FALLTHROUGH: Invalid or incomplete UTF-8 sequence. */
@


1.3
log
@Remove needless and harmful byte swapping on big endian architectures.
Problem found and patch provided by Martin Natano at bitrig, thanks!
Tested on macppc by natano@@ and on i386, amd64, and sparc64 myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: preconv.c,v 1.2 2014/11/01 04:07:25 schwarze Exp $ */
a17 1

@


1.2
log
@Refactor, no functional change: Remove the parse point from struct buf.
Some functions need multiple parse points, some none at all,
and it varies whether any of them need to be passed around.
So better pass them as a separate argument, and only when needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: preconv.c,v 1.1 2014/10/30 00:05:02 schwarze Exp $ */
d31 1
a31 2
	const long	 one = 1L;
	int		 state, be;
a39 6
	be = 0;

	/* Quick test for big-endian value. */

	if ( ! (*((const char *)(&one))))
		be = 1;
a59 13

			/*
			 * Accum is held in little-endian order as
			 * stipulated by the UTF-8 sequence coding.  We
			 * need to convert to a native big-endian if our
			 * architecture requires it.
			 */

			if (be)
				accum = (accum >> 24) |
					((accum << 8) & 0x00FF0000) |
					((accum >> 8) & 0x0000FF00) |
					(accum << 24);
@


1.1
log
@support UTF-8 and ISO-8859-1 input by integrating modified parts
of kristaps@@' version of the preconv(1) utility into mandoc(1);
positive feedback from bentley@@ and no concern raised when shown on tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d27 2
a28 1
preconv_encode(struct buf *ib, struct buf *ob, int *filenc)
d48 1
a48 1
	for (i = ib->offs; i < ib->sz; i++) {
d82 1
a82 1
				ob->buf[ob->offs++] = accum;
d84 1
a84 1
				ob->offs += snprintf(ob->buf + ob->offs,
d86 1
a86 1
			ib->offs = i + 1;
d137 2
a138 2
	ob->offs += snprintf(ob->buf + ob->offs, 11,
	    "\\[u%.4X]", (unsigned char)ib->buf[ib->offs++]);
d145 1
a145 1
preconv_cue(const struct buf *b)
d150 2
a151 2
	ln = b->buf + b->offs;
	sz = b->sz - b->offs;
@

