head	1.34;
access;
symbols
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.4
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.34
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	Ql2ha5NS80pwfGNT;

1.33
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	hxQV8O1pNUaef4ir;

1.32
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	191tWtskbsgcpQqV;

1.31
date	2015.01.30.04.08.37;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	KL58yWbJhw6UbgSB;

1.30
date	2015.01.28.02.23.33;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	QKksr5aww86aoBqp;

1.29
date	2014.12.23.13.48.15;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	gQAVpbNdyny1vBnL;

1.28
date	2014.12.23.09.31.17;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	SXZbldG8wiiZaqvE;

1.27
date	2014.12.23.03.27.36;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	EDWxaw4t7iE3MyXO;

1.26
date	2014.12.04.02.05.16;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	P8Z9Zeh4SkD71zxl;

1.25
date	2014.10.14.18.16.57;	author schwarze;	state Exp;
branches;
next	1.24;
commitid	9r7EpXDHQfmQjagd;

1.24
date	2014.10.14.02.16.02;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	CvxMGBcRTJn11Q3v;

1.23
date	2014.08.12.19.27.57;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	uzqd2l9lyTAkTsDr;

1.22
date	2014.08.08.16.00.23;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	m0QaUWeqjuHsvBSO;

1.21
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2013.10.05.21.17.29;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.31.21.37.09;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2012.05.26.20.03.34;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2011.09.20.23.05.46;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.30.16.05.29;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.25.12.07.26;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2011.01.16.01.11.50;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.09.14.30.48;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.13.22.04.01;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2010.08.18.02.38.40;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.27.20.28.56;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.07.23.15.05;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.24.02.08.14;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.10.21.19.13.51;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.34
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@/*	$OpenBSD: out.c,v 1.33 2015/10/06 18:30:44 schwarze Exp $ */
/*
 * Copyright (c) 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "out.h"

static	void	tblcalc_data(struct rofftbl *, struct roffcol *,
			const struct tbl_opts *, const struct tbl_dat *);
static	void	tblcalc_literal(struct rofftbl *, struct roffcol *,
			const struct tbl_dat *);
static	void	tblcalc_number(struct rofftbl *, struct roffcol *,
			const struct tbl_opts *, const struct tbl_dat *);


/*
 * Parse the *src string and store a scaling unit into *dst.
 * If the string doesn't specify the unit, use the default.
 * If no default is specified, fail.
 * Return 2 on complete success, 1 when a conversion was done,
 * but there was trailing garbage, and 0 on total failure.
 */
int
a2roffsu(const char *src, struct roffsu *dst, enum roffscale def)
{
	char		*endptr;

	dst->unit = def == SCALE_MAX ? SCALE_BU : def;
	dst->scale = strtod(src, &endptr);
	if (endptr == src)
		return 0;

	switch (*endptr++) {
	case 'c':
		dst->unit = SCALE_CM;
		break;
	case 'i':
		dst->unit = SCALE_IN;
		break;
	case 'f':
		dst->unit = SCALE_FS;
		break;
	case 'M':
		dst->unit = SCALE_MM;
		break;
	case 'm':
		dst->unit = SCALE_EM;
		break;
	case 'n':
		dst->unit = SCALE_EN;
		break;
	case 'P':
		dst->unit = SCALE_PC;
		break;
	case 'p':
		dst->unit = SCALE_PT;
		break;
	case 'u':
		dst->unit = SCALE_BU;
		break;
	case 'v':
		dst->unit = SCALE_VS;
		break;
	case '\0':
		endptr--;
		/* FALLTHROUGH */
	default:
		if (SCALE_MAX == def)
			return 0;
		dst->unit = def;
		break;
	}

	return *endptr == '\0' ? 2 : 1;
}

/*
 * Calculate the abstract widths and decimal positions of columns in a
 * table.  This routine allocates the columns structures then runs over
 * all rows and cells in the table.  The function pointers in "tbl" are
 * used for the actual width calculations.
 */
void
tblcalc(struct rofftbl *tbl, const struct tbl_span *sp,
	size_t totalwidth)
{
	const struct tbl_opts	*opts;
	const struct tbl_dat	*dp;
	struct roffcol		*col;
	size_t			 ewidth, xwidth;
	int			 spans;
	int			 icol, maxcol, necol, nxcol, quirkcol;

	/*
	 * Allocate the master column specifiers.  These will hold the
	 * widths and decimal positions for all cells in the column.  It
	 * must be freed and nullified by the caller.
	 */

	assert(NULL == tbl->cols);
	tbl->cols = mandoc_calloc((size_t)sp->opts->cols,
	    sizeof(struct roffcol));
	opts = sp->opts;

	for (maxcol = -1; sp; sp = sp->next) {
		if (TBL_SPAN_DATA != sp->pos)
			continue;
		spans = 1;
		/*
		 * Account for the data cells in the layout, matching it
		 * to data cells in the data section.
		 */
		for (dp = sp->first; dp; dp = dp->next) {
			/* Do not used spanned cells in the calculation. */
			if (0 < --spans)
				continue;
			spans = dp->spans;
			if (1 < spans)
				continue;
			icol = dp->layout->col;
			if (maxcol < icol)
				maxcol = icol;
			col = tbl->cols + icol;
			col->flags |= dp->layout->flags;
			if (dp->layout->flags & TBL_CELL_WIGN)
				continue;
			tblcalc_data(tbl, col, opts, dp);
		}
	}

	/*
	 * Count columns to equalize and columns to maximize.
	 * Find maximum width of the columns to equalize.
	 * Find total width of the columns *not* to maximize.
	 */

	necol = nxcol = 0;
	ewidth = xwidth = 0;
	for (icol = 0; icol <= maxcol; icol++) {
		col = tbl->cols + icol;
		if (col->flags & TBL_CELL_EQUAL) {
			necol++;
			if (ewidth < col->width)
				ewidth = col->width;
		}
		if (col->flags & TBL_CELL_WMAX)
			nxcol++;
		else
			xwidth += col->width;
	}

	/*
	 * Equalize columns, if requested for any of them.
	 * Update total width of the columns not to maximize.
	 */

	if (necol) {
		for (icol = 0; icol <= maxcol; icol++) {
			col = tbl->cols + icol;
			if ( ! (col->flags & TBL_CELL_EQUAL))
				continue;
			if (col->width == ewidth)
				continue;
			if (nxcol && totalwidth)
				xwidth += ewidth - col->width;
			col->width = ewidth;
		}
	}

	/*
	 * If there are any columns to maximize, find the total
	 * available width, deducting 3n margins between columns.
	 * Distribute the available width evenly.
	 */

	if (nxcol && totalwidth) {
		xwidth = totalwidth - xwidth - 3*maxcol -
		    (opts->opts & (TBL_OPT_BOX | TBL_OPT_DBOX) ?
		     2 : !!opts->lvert + !!opts->rvert);

		/*
		 * Emulate a bug in GNU tbl width calculation that
		 * manifests itself for large numbers of x-columns.
		 * Emulating it for 5 x-columns gives identical
		 * behaviour for up to 6 x-columns.
		 */

		if (nxcol == 5) {
			quirkcol = xwidth % nxcol + 2;
			if (quirkcol != 3 && quirkcol != 4)
				quirkcol = -1;
		} else
			quirkcol = -1;

		necol = 0;
		ewidth = 0;
		for (icol = 0; icol <= maxcol; icol++) {
			col = tbl->cols + icol;
			if ( ! (col->flags & TBL_CELL_WMAX))
				continue;
			col->width = (double)xwidth * ++necol / nxcol
			    - ewidth + 0.4995;
			if (necol == quirkcol)
				col->width--;
			ewidth += col->width;
		}
	}
}

static void
tblcalc_data(struct rofftbl *tbl, struct roffcol *col,
		const struct tbl_opts *opts, const struct tbl_dat *dp)
{
	size_t		 sz;

	/* Branch down into data sub-types. */

	switch (dp->layout->pos) {
	case TBL_CELL_HORIZ:
	case TBL_CELL_DHORIZ:
		sz = (*tbl->len)(1, tbl->arg);
		if (col->width < sz)
			col->width = sz;
		break;
	case TBL_CELL_LONG:
	case TBL_CELL_CENTRE:
	case TBL_CELL_LEFT:
	case TBL_CELL_RIGHT:
		tblcalc_literal(tbl, col, dp);
		break;
	case TBL_CELL_NUMBER:
		tblcalc_number(tbl, col, opts, dp);
		break;
	case TBL_CELL_DOWN:
		break;
	default:
		abort();
	}
}

static void
tblcalc_literal(struct rofftbl *tbl, struct roffcol *col,
		const struct tbl_dat *dp)
{
	size_t		 sz;
	const char	*str;

	str = dp->string ? dp->string : "";
	sz = (*tbl->slen)(str, tbl->arg);

	if (col->width < sz)
		col->width = sz;
}

static void
tblcalc_number(struct rofftbl *tbl, struct roffcol *col,
		const struct tbl_opts *opts, const struct tbl_dat *dp)
{
	int		 i;
	size_t		 sz, psz, ssz, d;
	const char	*str;
	char		*cp;
	char		 buf[2];

	/*
	 * First calculate number width and decimal place (last + 1 for
	 * non-decimal numbers).  If the stored decimal is subsequent to
	 * ours, make our size longer by that difference
	 * (right-"shifting"); similarly, if ours is subsequent the
	 * stored, then extend the stored size by the difference.
	 * Finally, re-assign the stored values.
	 */

	str = dp->string ? dp->string : "";
	sz = (*tbl->slen)(str, tbl->arg);

	/* FIXME: TBL_DATA_HORIZ et al.? */

	buf[0] = opts->decimal;
	buf[1] = '\0';

	psz = (*tbl->slen)(buf, tbl->arg);

	if (NULL != (cp = strrchr(str, opts->decimal))) {
		buf[1] = '\0';
		for (ssz = 0, i = 0; cp != &str[i]; i++) {
			buf[0] = str[i];
			ssz += (*tbl->slen)(buf, tbl->arg);
		}
		d = ssz + psz;
	} else
		d = sz + psz;

	/* Adjust the settings for this column. */

	if (col->decimal > d) {
		sz += col->decimal - d;
		d = col->decimal;
	} else
		col->width += d - col->decimal;

	if (sz > col->width)
		col->width = sz;
	if (d > col->decimal)
		col->decimal = d;
}
@


1.33
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: out.c,v 1.32 2015/09/26 00:53:15 schwarze Exp $ */
a240 1
		/* FALLTHROUGH */
a246 1
		/* FALLTHROUGH */
a247 1
		/* FALLTHROUGH */
a248 1
		/* FALLTHROUGH */
@


1.32
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$OpenBSD: out.c,v 1.31 2015/01/30 04:08:37 schwarze Exp $ */
d52 1
a52 1
		return(0);
d90 1
a90 1
			return(0);
d95 1
a95 1
	return(*endptr == '\0' ? 2 : 1);
@


1.31
log
@Abolish struct tbl_head and replace it by an "int col" member in
struct tbl_cell.  No functional change, minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: out.c,v 1.30 2015/01/28 02:23:33 schwarze Exp $ */
a262 1
		/* NOTREACHED */
@


1.30
log
@adjust formatting for the tbl(7) layout 'x' modifier (maximize column)
to match groff for up to six maximized columns
@
text
@d1 1
a1 1
/*	$OpenBSD: out.c,v 1.29 2014/12/23 13:48:15 schwarze Exp $ */
d141 1
a141 1
			icol = dp->layout->head->ident;
@


1.29
log
@support negative horizontal widths in man(7);
minus twenty lines of code in spite of enhanced functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: out.c,v 1.28 2014/12/23 09:31:17 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d108 1
d113 1
a113 1
	int			 icol, maxcol, necol, nxcol;
d124 1
d148 1
a148 1
			tblcalc_data(tbl, col, sp->opts, dp);
d198 20
a217 1
		xwidth = totalwidth - 3*maxcol - xwidth;
d222 5
a226 2
			col->width = xwidth / nxcol--;
			xwidth -= col->width;
@


1.28
log
@some scaling unit fixes:
- .sp with an invalid argument is .sp 1v, not .sp 0v
- in man(1), trailing garbage doesn't make scaling units invalid
@
text
@d1 1
a1 1
/*	$OpenBSD: out.c,v 1.27 2014/12/23 03:27:36 schwarze Exp $ */
a94 3
	/* FIXME: do this in the caller. */
	if (dst->scale < 0.0)
		dst->scale = 0.0;
@


1.27
log
@In a2roffsu(), do not parse the number twice.
Gets rid of 25 lines of code and one static buffer.
No functional change for numbers shorter than BUFSIZ characters.
@
text
@d1 1
a1 1
/*	$OpenBSD: out.c,v 1.26 2014/12/04 02:05:16 schwarze Exp $ */
d41 2
a42 1
 * Return 1 on success and 0 on failure.
a47 2
	double		 scale;
	enum roffscale	 unit;
d49 3
a51 2
	scale = strtod(src, &endptr);
	if (endptr == src || (endptr[0] != '\0' && endptr[1] != '\0'))
d54 1
a54 1
	switch (*endptr) {
d56 1
a56 1
		unit = SCALE_CM;
d59 13
a71 1
		unit = SCALE_IN;
d74 1
a74 1
		unit = SCALE_PC;
d77 1
a77 1
		unit = SCALE_PT;
d79 2
a80 2
	case 'f':
		unit = SCALE_FS;
d83 1
a83 4
		unit = SCALE_VS;
		break;
	case 'm':
		unit = SCALE_EM;
d86 3
d91 1
a91 10
		unit = def;
		break;
	case 'u':
		unit = SCALE_BU;
		break;
	case 'M':
		unit = SCALE_MM;
		break;
	case 'n':
		unit = SCALE_EN;
a92 2
	default:
		return(0);
d96 3
a98 5
	if (scale < 0.0)
		scale = 0.0;
	dst->scale = scale;
	dst->unit = unit;
	return(1);
@


1.26
log
@fix handling of roff requests having a default scale other than "n",
in particular .sp which uses "v", when the scale is not specified;
cures groff-mandoc differences in about a dozen Xenocara manuals
@
text
@d1 1
a1 1
/*	$OpenBSD: out.c,v 1.25 2014/10/14 18:16:57 schwarze Exp $ */
a20 2
#include <ctype.h>
#include <stdio.h>
d38 4
a41 2
 * Convert a `scaling unit' to a consistent form, or fail.  Scaling
 * units are documented in groff.7, mdoc.7, man.7.
d46 2
a47 2
	char		 buf[BUFSIZ], hasd;
	int		 i;
d50 2
a51 1
	if ('\0' == *src)
d54 1
a54 34
	i = hasd = 0;

	switch (*src) {
	case '+':
		src++;
		break;
	case '-':
		buf[i++] = *src++;
		break;
	default:
		break;
	}

	if ('\0' == *src)
		return(0);

	while (i < BUFSIZ) {
		if ( ! isdigit((unsigned char)*src)) {
			if ('.' != *src)
				break;
			else if (hasd)
				break;
			else
				hasd = 1;
		}
		buf[i++] = *src++;
	}

	if (BUFSIZ == i || (*src && *(src + 1)))
		return(0);

	buf[i] = '\0';

	switch (*src) {
d95 3
a97 2
	if ((dst->scale = atof(buf)) < 0.0)
		dst->scale = 0.0;
@


1.25
log
@even if a table has zero columns, do not segfault in the formatter;
bug reported by bentley@@
@
text
@d1 1
a1 1
/*	$OpenBSD: out.c,v 1.24 2014/10/14 02:16:02 schwarze Exp $ */
d111 1
a111 1
		unit = SCALE_EN;
@


1.24
log
@Rudimentary implementation of the e, x, and z table layout modifiers
to equalize, maximize, and ignore the width of columns.
Does not yet take vertical rulers into account,
and does not do line breaks within table cells.
Considerably improves the lftp(1) manual; issue noticed by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d159 1
a159 1
	for (maxcol = 0; sp; sp = sp->next) {
@


1.23
log
@In mdoc(7) and man(7), if a width is given as a bare number without
specifying a unit, the implied unit is 'n' (on the terminal, one
character position; in PostScript, half of the current font size
in points), not 'u' (roff output device basic unit).  No functional
change right now, but important for the upcoming scaling unit fixes.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.22 2014/08/08 16:00:23 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
d140 2
a141 1
tblcalc(struct rofftbl *tbl, const struct tbl_span *sp)
d145 1
d147 1
d159 1
a159 1
	for ( ; sp; sp = sp->next) {
d174 7
a180 2
			assert(dp->layout);
			col = &tbl->cols[dp->layout->head->ident];
d182 56
@


1.22
log
@Clarity with respect to floating point handling:
Write double constants as double rather than integer literals.
Remove useless explicit (double) cast done at one place and nowhere else.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.21 2014/04/20 16:44:44 schwarze Exp $ */
d111 1
a111 1
		unit = SCALE_BU;
@


1.21
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.20 2014/03/21 22:17:01 schwarze Exp $ */
d127 2
a128 2
	if ((dst->scale = atof(buf)) < 0)
		dst->scale = 0;
@


1.20
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.19 2013/10/05 21:17:29 schwarze Exp $ */
d38 2
a39 1
/* 
d56 1
a56 1
	case ('+'):
d59 1
a59 1
	case ('-'):
d87 1
a87 1
	case ('c'):
d90 1
a90 1
	case ('i'):
d93 1
a93 1
	case ('P'):
d96 1
a96 1
	case ('p'):
d99 1
a99 1
	case ('f'):
d102 1
a102 1
	case ('v'):
d105 1
a105 1
	case ('m'):
d108 1
a108 1
	case ('\0'):
d113 1
a113 1
	case ('u'):
d116 1
a116 1
	case ('M'):
d119 1
a119 1
	case ('n'):
d153 2
a154 2
	tbl->cols = mandoc_calloc
		((size_t)sp->opts->cols, sizeof(struct roffcol));
d187 1
a187 1
	case (TBL_CELL_HORIZ):
d189 1
a189 1
	case (TBL_CELL_DHORIZ):
d194 1
a194 1
	case (TBL_CELL_LONG):
d196 1
a196 1
	case (TBL_CELL_CENTRE):
d198 1
a198 1
	case (TBL_CELL_LEFT):
d200 1
a200 1
	case (TBL_CELL_RIGHT):
d203 1
a203 1
	case (TBL_CELL_NUMBER):
d206 1
a206 1
	case (TBL_CELL_DOWN):
d232 1
a232 1
	int 		 i;
@


1.19
log
@Cleanup suggested by gcc-4.8.1, following hints by Christos Zoulas:
- avoid bad qualifier casting in roff.c, roff_parsetext()
  by changing the mandoc_escape arguments to "const char const **"
- avoid bad qualifier casting in mandocdb.c, index_merge()
- garbage collect a few unused variables elsewhere
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.18 2013/05/31 21:37:09 schwarze Exp $ */
d27 1
@


1.18
log
@The name "struct tbl" was badly misleading for two reasons:
1) This struct almost exclusively contains the table options.
2) Information about the table as a whole is actually in "struct tbl_node".
Besides, "struct tbl" was almost impossible to search for.
So rename it to "struct tbl_opts".  No functional change.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.17 2012/05/26 20:03:34 schwarze Exp $ */
a140 1
	const struct tbl_head	*hp;
a152 2

	hp = sp->head;
@


1.17
log
@Do not handle vertical lines as additional tbl(7) columns,
instead save their properties with the following column.
This simplifies layout parsing and saves a lot of code
related to column handling.

At output time, print all white space and vertical lines
separating columns before printing the following column,
and none after printing the preceding column, considerably
simplifying white space handling and width calculations.

No functional change, but it saves 150 lines of code,
and it allows the next patch to tbl_term.c, tbl_literal().
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.16 2011/09/20 23:05:46 schwarze Exp $ */
d31 1
a31 1
			const struct tbl *, const struct tbl_dat *);
d35 1
a35 1
			const struct tbl *, const struct tbl_dat *);
d153 1
a153 1
		((size_t)sp->tbl->cols, sizeof(struct roffcol));
d174 1
a174 1
			tblcalc_data(tbl, col, sp->tbl, dp);
d181 1
a181 1
		const struct tbl *tp, const struct tbl_dat *dp)
d205 1
a205 1
		tblcalc_number(tbl, col, tp, dp);
d231 1
a231 1
		const struct tbl *tp, const struct tbl_dat *dp)
d253 1
a253 1
	buf[0] = tp->decimal;
d258 1
a258 1
	if (NULL != (cp = strrchr(str, tp->decimal))) {
@


1.16
log
@Major rewrite of the horizontal spacing of tables
to work both with and without frames and rulers.
Started during BSDCan 2011 in Ottawa, finished during s2k11 in Ljubljana.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.15 2011/09/18 15:54:48 schwarze Exp $ */
a174 19
		}
	}

	/* 
	 * Calculate width of the spanners.  These get one space for a
	 * vertical line, two for a double-vertical line. 
	 */

	for ( ; hp; hp = hp->next) {
		col = &tbl->cols[hp->ident];
		switch (hp->pos) {
		case (TBL_HEAD_VERT):
			col->width = (*tbl->len)(1, tbl->arg);
			break;
		case (TBL_HEAD_DVERT):
			col->width = (*tbl->len)(2, tbl->arg);
			break;
		default:
			break;
@


1.15
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.14 2011/05/29 21:22:18 schwarze Exp $ */
d143 1
d160 1
d166 6
d238 1
a238 1
	size_t		 sz, bufsz, spsz;
a240 7
	/* 
	 * Calculate our width and use the spacing, with a minimum
	 * spacing dictated by position (centre, e.g,. gets a space on
	 * either side, while right/left get a single adjacent space).
	 */

	bufsz = spsz = 0;
a243 20
	/* FIXME: TBL_DATA_HORIZ et al.? */

	assert(dp->layout);
	switch (dp->layout->pos) {
	case (TBL_CELL_LONG):
		/* FALLTHROUGH */
	case (TBL_CELL_CENTRE):
		bufsz = (*tbl->len)(1, tbl->arg);
		break;
	default:
		bufsz = (*tbl->len)(1, tbl->arg);
		break;
	}

	if (dp->layout->spacing) {
		spsz = (*tbl->len)(dp->layout->spacing, tbl->arg);
		bufsz = bufsz > spsz ? bufsz : spsz;
	}

	sz += bufsz;
d260 1
a260 1
	 * no-decimal numbers).  If the stored decimal is subsequent
a286 5
	/* Padding. */

	sz += (*tbl->len)(2, tbl->arg);
	d += (*tbl->len)(1, tbl->arg);

a298 5

	/* Adjust for stipulated width. */

	if (col->width < dp->layout->spacing)
		col->width = dp->layout->spacing;
a299 2


@


1.14
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.13 2011/04/21 22:59:54 schwarze Exp $ */
d68 1
a68 1
		if ( ! isdigit((u_char)*src)) {
a128 42
}


/*
 * Correctly writes the time in nroff form, which differs from standard
 * form in that a space isn't printed in lieu of the extra %e field for
 * single-digit dates.
 */
void
time2a(time_t t, char *dst, size_t sz)
{
	struct tm	 tm;
	char		 buf[5];
	char		*p;
	size_t		 nsz;

	assert(sz > 1);
	localtime_r(&t, &tm);

	p = dst;
	nsz = 0;

	dst[0] = '\0';

	if (0 == (nsz = strftime(p, sz, "%B ", &tm)))
		return;

	p += (int)nsz;
	sz -= nsz;

	if (0 == strftime(buf, sizeof(buf), "%e, ", &tm))
		return;

	nsz = strlcat(p, buf + (' ' == buf[0] ? 1 : 0), sz);

	if (nsz >= sz)
		return;

	p += (int)nsz;
	sz -= nsz;

	(void)strftime(p, sz, "%Y", &tm);
@


1.13
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.12 2011/01/30 16:05:29 schwarze Exp $ */
a170 237
}


int
a2roffdeco(enum roffdeco *d, const char **word, size_t *sz)
{
	int		 i, j, lim;
	char		 term, c;
	const char	*wp;
	enum roffdeco	 dd;

	*d = DECO_NONE;
	lim = i = 0;
	term = '\0';
	wp = *word;

	switch ((c = wp[i++])) {
	case ('('):
		*d = DECO_SPECIAL;
		lim = 2;
		break;
	case ('F'):
		/* FALLTHROUGH */
	case ('f'):
		*d = 'F' == c ? DECO_FFONT : DECO_FONT;

		switch (wp[i++]) {
		case ('('):
			lim = 2;
			break;
		case ('['):
			term = ']';
			break;
		case ('3'):
			/* FALLTHROUGH */
		case ('B'):
			*d = DECO_BOLD;
			return(i);
		case ('2'):
			/* FALLTHROUGH */
		case ('I'):
			*d = DECO_ITALIC;
			return(i);
		case ('P'):
			*d = DECO_PREVIOUS;
			return(i);
		case ('1'):
			/* FALLTHROUGH */
		case ('R'):
			*d = DECO_ROMAN;
			return(i);
		default:
			i--;
			lim = 1;
			break;
		}
		break;
	case ('k'):
		/* FALLTHROUGH */
	case ('M'):
		/* FALLTHROUGH */
	case ('m'):
		/* FALLTHROUGH */
	case ('*'):
		if ('*' == c)
			*d = DECO_RESERVED;

		switch (wp[i++]) {
		case ('('):
			lim = 2;
			break;
		case ('['):
			term = ']';
			break;
		default:
			i--;
			lim = 1;
			break;
		}
		break;

	case ('N'):

		/*
		 * Sequence of characters:  backslash,  'N' (i = 0),
		 * starting delimiter (i = 1), character number (i = 2).
		 */

		*word = wp + 2;
		*sz = 0;

		/*
		 * Cannot use a digit as a starting delimiter;
		 * but skip the digit anyway.
		 */

		if (isdigit((int)wp[1]))
			return(2);

		/*
		 * Any non-digit terminates the character number.
		 * That is, the terminating delimiter need not
		 * match the starting delimiter.
		 */

		for (i = 2; isdigit((int)wp[i]); i++)
			(*sz)++;

		/*
		 * This is only a numbered character
		 * if the character number has at least one digit.
		 */

		if (*sz)
			*d = DECO_NUMBERED;

		/*
		 * Skip the terminating delimiter, even if it does not
		 * match, and even if there is no character number.
		 */

		return(++i);

	case ('h'):
		/* FALLTHROUGH */
	case ('v'):
		/* FALLTHROUGH */
	case ('s'):
		j = 0;
		if ('+' == wp[i] || '-' == wp[i]) {
			i++;
			j = 1;
		}

		switch (wp[i++]) {
		case ('('):
			lim = 2;
			break;
		case ('['):
			term = ']';
			break;
		case ('\''):
			term = '\'';
			break;
		case ('0'):
			j = 1;
			/* FALLTHROUGH */
		default:
			i--;
			lim = 1;
			break;
		}

		if ('+' == wp[i] || '-' == wp[i]) {
			if (j)
				return(i);
			i++;
		} 

		/* Handle embedded numerical subexp or escape. */

		if ('(' == wp[i]) {
			while (wp[i] && ')' != wp[i])
				if ('\\' == wp[i++]) {
					/* Handle embedded escape. */
					*word = &wp[i];
					i += a2roffdeco(&dd, word, sz);
				}

			if (')' == wp[i++])
				break;

			*d = DECO_NONE;
			return(i - 1);
		} else if ('\\' == wp[i]) {
			*word = &wp[++i];
			i += a2roffdeco(&dd, word, sz);
		}

		break;
	case ('['):
		*d = DECO_SPECIAL;
		term = ']';
		break;
	case ('c'):
		*d = DECO_NOSPACE;
		return(i);
	case ('z'):
		*d = DECO_NONE;
		if ('\\' == wp[i]) {
			*word = &wp[++i];
			return(i + a2roffdeco(&dd, word, sz));
		} else
			lim = 1;
		break;
	case ('o'):
		/* FALLTHROUGH */
	case ('w'):
		if ('\'' == wp[i++]) {
			term = '\'';
			break;
		} 
		/* FALLTHROUGH */
	default:
		*d = DECO_SSPECIAL;
		i--;
		lim = 1;
		break;
	}

	assert(term || lim);
	*word = &wp[i];

	if (term) {
		j = i;
		while (wp[i] && wp[i] != term)
			i++;
		if ('\0' == wp[i]) {
			*d = DECO_NONE;
			return(i);
		}

		assert(i >= j);
		*sz = (size_t)(i - j);

		return(i + 1);
	}

	assert(lim > 0);
	*sz = (size_t)lim;

	for (j = 0; wp[i] && j < lim; j++)
		i++;
	if (j < lim)
		*d = DECO_NONE;

	return(i);
@


1.12
log
@Implement the \N'number' (numbered character) roff escape sequence.
Don't use it in new manuals, it is inherently non-portable, but we
need it for backward-compatibility with existing manuals, for example
in Xenocara driver pages.
ok kristaps@@ matthieu@@ jmc@@
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.11 2011/01/25 12:07:26 schwarze Exp $ */
d430 2
a431 1
	tbl->cols = calloc(sp->tbl->cols, sizeof(struct roffcol));
@


1.11
log
@correct horizontal spacing of data cells
correct alignment of centered cells
adjust horizontal rule width to the new spacing
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.10 2011/01/16 01:11:50 schwarze Exp $ */
d4 1
d251 43
@


1.10
log
@Various tbl improvements from kristaps@@:
* horizontal lines do not consume layout lines
* skip excessive data cells
* prepare rendering of spanned cells
* support vertical spans
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.9 2011/01/09 14:30:48 schwarze Exp $ */
d484 1
a484 1
		bufsz = (*tbl->len)(2, tbl->arg);
@


1.9
log
@Sync tbl handling to bsd.lv release 1.10.9:
* .T} can be followed by a delimiter, then more data.
* Do not limit table column widths (improves terminfo(5)).
* Let numerical cells respect explicitly specified minimum cell widths.
* Let terminal output survive missing data cells.
* Parse and ignore arguments in parentheses on layout cell specifications.
* Move tbl_calc() into out.c such that it can be used by all frontends.
* Give tables an HTML class.
* Some cleanup in tbl -Thtml code.
All code by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.8 2010/09/13 22:04:01 schwarze Exp $ */
d398 1
a398 2
			if (NULL == dp->layout)
				continue;
d452 2
d465 1
d473 5
a477 3
	sz = bufsz = spsz = 0;
	if (dp->string)
		sz = (*tbl->slen)(dp->string, tbl->arg);
d506 2
a507 1
	size_t		 sz, psz, ssz, d, max;
a508 1
	const char	*str;
d520 2
a521 2
	str = dp && dp->string ? dp->string : "";
	max = dp && dp->layout ? dp->layout->spacing : 0;
d523 1
a523 1
	sz = (*tbl->slen)(str, tbl->arg);
d560 2
a561 2
	if (col->width < max)
		col->width = max;
@


1.8
log
@Parse and ignore the \k, \o, \w, and \z roff escapes, and recursively
ignore embedded escapes and mathematical roff subexpressions.
In roff copy mode, resolve "\\" to '\'.
Allow ".xx\}" where xx is a macro to close roff conditional scope.
Mandoc now handles the special character definitions in the pod2man(1)
preamble, so remove the explicit redefinitions in chars.c/chars.in.
From kristaps@@.

I have checked that this causes no relevant change to the Perl manuals.
The only change introduced is that some non-ASCII characters rendered
incorrectly before are now rendered incorrectly in a different way.
For example, e accent aigu was "e", now is "e'"
and c cedille was "c", now is "c,".
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.7 2010/08/18 02:38:40 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d26 1
d29 7
d365 196
@


1.7
log
@Ignore \h (local horizontal motion) and \v (local vertical motion) escapes
just in the same way as \s (font size) escapes, and handle \s escapes
not having an explicit plus or minus sign.
This fixes the very ugly rendering of "C++" in gcc(1).
Reported by Thomas Jeunet, fixed by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.6 2010/07/25 18:05:54 schwarze Exp $ */
d171 1
d219 2
d277 21
a297 1
		
d306 16
@


1.6
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.5 2010/06/27 20:28:56 schwarze Exp $ */
d239 4
d244 2
a245 1
		if ('+' == wp[i] || '-' == wp[i])
d247 2
a248 2

		j = ('s' != wp[i - 1]);
d261 1
a261 1
			j++;
d270 1
a270 1
			if (j++)
a274 2
		if (0 == j)
			return(i);
@


1.5
log
@Remove "pt" from struct roffsu, as CSS (the only reason it was there) is
unclear about which units accept floats/integers, which leads me to
assume that it handles either and rounds as appropriate.
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.4 2010/04/07 23:15:05 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2009 Kristaps Dzonsons <kristaps@@kth.se>
a27 20
/* See a2roffdeco(). */
#define	C2LIM(c, l) do { \
	(l) = 1; \
	if ('[' == (c) || '\'' == (c)) \
		(l) = 0; \
	else if ('(' == (c)) \
		(l) = 2; } \
	while (/* CONSTCOND */ 0)

/* See a2roffdeco(). */
#define	C2TERM(c, t) do { \
	(t) = 0; \
	if ('\'' == (c)) \
		(t) = 1; \
	else if ('[' == (c)) \
		(t) = 2; \
	else if ('(' == (c)) \
		(t) = 3; } \
	while (/* CONSTCOND */ 0)

d115 1
a164 6
/* 
 * Returns length of parsed string (the leading "\" should NOT be
 * included).  This can be zero if the current character is the nil
 * terminator.  "d" is set to the type of parsed decorator, which may
 * have an adjoining "word" of size "sz" (e.g., "(ab" -> "ab", 2).
 */
d166 1
a166 2
a2roffdeco(enum roffdeco *d,
		const char **word, size_t *sz)
d168 3
a170 3
	int		 j, term, lim;
	char		 set;
	const char	*wp, *sp;
d173 2
d177 1
a177 4
	switch ((set = *wp)) {
	case ('\0'):
		return(0);

a178 5
		if ('\0' == *(++wp))
			return(1);
		if ('\0' == *(wp + 1))
			return(2);

d180 2
a181 4
		*sz = 2;
		*word = wp;
		return(3);

d185 9
a193 10
		/*
		 * FIXME: this needs work and consolidation (it should
		 * follow the sequence that special characters do, for
		 * one), but isn't a priority at the moment.  Note, for
		 * one, that in reality \fB != \FB, although here we let
		 * these slip by.
		 */
		switch (*(++wp)) {
		case ('\0'):
			return(1);
d198 1
a198 1
			return(2);
d203 1
a203 1
			return(2);
d206 1
a206 1
			return(2);
d211 1
a211 22
			return(2);
		case ('('):
			if ('\0' == *(++wp))
				return(2);
			if ('\0' == *(wp + 1))
				return(3);

			*d = 'F' == set ? DECO_FFONT : DECO_FONT;
			*sz = 2;
			*word = wp;
			return(4);
		case ('['):
			*word = ++wp;
			for (j = 0; *wp && ']' != *wp; wp++, j++)
				/* Loop... */ ;

			if ('\0' == *wp)
				return(j + 2);

			*d = 'F' == set ? DECO_FFONT : DECO_FONT;
			*sz = (size_t)j;
			return(j + 3);
d213 2
d217 5
a221 6

		*d = 'F' == set ? DECO_FFONT : DECO_FONT;
		*sz = 1;
		*word = wp;
		return(2);

d223 2
a224 3
		switch (*(++wp)) {
		case ('\0'):
			return(1);
d226 1
d228 2
a229 10
			if ('\0' == *(++wp))
				return(2);
			if ('\0' == *(wp + 1))
				return(3);

			*d = DECO_RESERVED;
			*sz = 2;
			*word = wp;
			return(4);

d231 2
a232 11
			*word = ++wp;
			for (j = 0; *wp && ']' != *wp; wp++, j++)
				/* Loop... */ ;

			if ('\0' == *wp)
				return(j + 2);

			*d = DECO_RESERVED;
			*sz = (size_t)j;
			return(j + 3);

d234 2
d238 1
a238 6

		*d = DECO_RESERVED;
		*sz = 1;
		*word = wp;
		return(2);

d240 2
a241 3
		sp = wp;
		if ('\0' == *(++wp))
			return(1);
d243 1
a243 2
		C2LIM(*wp, lim);
		C2TERM(*wp, term);
d245 7
a251 9
		if (term) 
			wp++;

		*word = wp;

		if (*wp == '+' || *wp == '-')
			++wp;

		switch (*wp) {
d253 4
a257 10
		case ('['):
			/* FALLTHROUGH */
		case ('('):
			if (term) 
				return((int)(wp - sp));

			C2LIM(*wp, lim);
			C2TERM(*wp, term);
			wp++;
			break;
d259 2
d264 22
a285 2
		if ( ! isdigit((u_char)*wp))
			return((int)(wp - sp));
d287 2
a288 5
		for (j = 0; isdigit((u_char)*wp); j++) {
			if (lim && j >= lim)
				break;
			++wp;
		}
d290 7
a296 6
		if (term && term < 3) {
			if (1 == term && *wp != '\'')
				return((int)(wp - sp));
			if (2 == term && *wp != ']')
				return((int)(wp - sp));
			++wp;
d299 2
a300 2
		*d = DECO_SIZE;
		return((int)(wp - sp));
d302 2
a303 5
	case ('['):
		*word = ++wp;

		for (j = 0; *wp && ']' != *wp; wp++, j++)
			/* Loop... */ ;
d305 2
a306 2
		if ('\0' == *wp)
			return(j + 1);
d308 4
a311 3
		*d = DECO_SPECIAL;
		*sz = (size_t)j;
		return(j + 2);
d313 1
a313 13
	case ('c'):
		*d = DECO_NOSPACE;
		*sz = 1;
		return(1);

	default:
		break;
	}

	*d = DECO_SPECIAL;
	*word = wp;
	*sz = 1;
	return(1);
@


1.4
log
@Merge the good parts of 1.9.23,
avoid the bad parts of 1.9.23, and keep local patches.

Input in general:
 * Basic handling of roff-style font escapes \f, \F.
 * Quoted punctuation does not count as punctuation.

mdoc(7) parser:
 * Make .Pf callable; noted by Claus Assmann.
 * Let .Bd and .Bl ignore unknown arguments; noted by deraadt@@.
 * Do not warn when .Er is used outside certain sections.
 * Replace mdoc_node_free[list] by mdoc_node_delete.
 * Replace #define by enum for rew*() return values.

man(7) parser:
 * When .TH is missing, use default section and date.

Output in general:
 * Curly braces do not count as punctuation.
 * No space after .Fl w/o args when a macro follows on the same line.

HTML output:
 * Unify PAIR_*_INIT macros, introduce new PAIR_ID_INIT().
 * Print whitespace after, not before .Vt .Fn .Ft .Fo.

Checked that all manuals in base still build.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.3 2009/12/24 02:08:14 schwarze Exp $ */
a137 2
	dst->pt = hasd;

@


1.3
log
@sync to 1.9.14: rewrite escape sequence handling:
- new function a2roffdeco
- font modes (\f) only affect the current stack point
- implement scaling (\s)
- implement space suppression (\c)
- implement non-breaking space (\~) in -Tascii
- many manual improvements
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.2 2009/10/27 21:40:07 schwarze Exp $ */
d196 2
a197 1
	int		 j, type, term, lim;
a201 1
	type = 1;
d203 1
a203 1
	switch (*wp) {
d218 61
d296 10
a305 2
			type = 0;
			break;
d308 1
a308 4
			*d = DECO_RESERVED;
			*sz = 1;
			*word = wp;
			return(2);
d310 5
a314 1
		break;
d369 5
a373 25
	case ('f'):
		switch (*(++wp)) {
		case ('\0'):
			return(1);
		case ('3'):
			/* FALLTHROUGH */
		case ('B'):
			*d = DECO_BOLD;
			break;
		case ('2'):
			/* FALLTHROUGH */
		case ('I'):
			*d = DECO_ITALIC;
			break;
		case ('P'):
			*d = DECO_PREVIOUS;
			break;
		case ('1'):
			/* FALLTHROUGH */
		case ('R'):
			*d = DECO_ROMAN;
			break;
		default:
			break;
		}
d375 2
a376 1
		return(2);
d378 3
a380 2
	case ('['):
		break;
d388 1
a388 4
		*d = DECO_SPECIAL;
		*word = wp;
		*sz = 1;
		return(1);
d391 4
a394 10
	*word = ++wp;
	for (j = 0; *wp && ']' != *wp; wp++, j++)
		/* Loop... */ ;

	if ('\0' == *wp)
		return(j + 1);

	*d = type ? DECO_SPECIAL : DECO_RESERVED;
	*sz = (size_t)j;
	return (j + 2);
@


1.2
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.1 2009/10/21 19:13:51 schwarze Exp $ */
d28 20
d185 168
@


1.1
log
@sync to 1.9.9, featuring:
 * -Thtml output mode
 * roff scaling units
 * and some minor fixes
for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.5 2009/10/18 19:02:10 kristaps Exp $ */
d19 1
d23 2
a27 1

d122 43
@

