head	1.190;
access;
symbols
	OPENBSD_6_1:1.190.0.4
	OPENBSD_6_1_BASE:1.190
	OPENBSD_6_0:1.176.0.2
	OPENBSD_6_0_BASE:1.176
	OPENBSD_5_9:1.170.0.2
	OPENBSD_5_9_BASE:1.170
	OPENBSD_5_8:1.149.0.4
	OPENBSD_5_8_BASE:1.149
	OPENBSD_5_7:1.127.0.2
	OPENBSD_5_7_BASE:1.127
	OPENBSD_5_6:1.94.0.4
	OPENBSD_5_6_BASE:1.94
	OPENBSD_5_5:1.86.0.4
	OPENBSD_5_5_BASE:1.86
	OPENBSD_5_4:1.84.0.4
	OPENBSD_5_4_BASE:1.84
	OPENBSD_5_3:1.84.0.2
	OPENBSD_5_3_BASE:1.84
	OPENBSD_5_2:1.83.0.2
	OPENBSD_5_2_BASE:1.83
	OPENBSD_5_1_BASE:1.82
	OPENBSD_5_1:1.82.0.2
	OPENBSD_5_0:1.77.0.2
	OPENBSD_5_0_BASE:1.77
	OPENBSD_4_9:1.72.0.2
	OPENBSD_4_9_BASE:1.72
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8;
locks; strict;
comment	@ * @;


1.190
date	2017.03.27.18.51.20;	author schwarze;	state Exp;
branches;
next	1.189;
commitid	JqFqgeIEdKKOK5xo;

1.189
date	2017.03.20.14.30.43;	author schwarze;	state Exp;
branches;
next	1.188;
commitid	lGiuKmlBSWhrnJ1c;

1.188
date	2017.03.03.14.21.41;	author schwarze;	state Exp;
branches;
next	1.187;
commitid	XiReG6k6LbJGRsK6;

1.187
date	2017.02.22.14.58.27;	author schwarze;	state Exp;
branches;
next	1.186;
commitid	ybuTwijEsGuQJUng;

1.186
date	2017.02.16.10.55.57;	author schwarze;	state Exp;
branches;
next	1.185;
commitid	L2Xyci4vouU9KLxp;

1.185
date	2017.02.10.15.44.31;	author schwarze;	state Exp;
branches;
next	1.184;
commitid	jWIgaURhUN1Qo7t2;

1.184
date	2017.02.09.17.19.07;	author schwarze;	state Exp;
branches;
next	1.183;
commitid	M8rq0bbAM3ikHus0;

1.183
date	2017.01.27.13.47.17;	author schwarze;	state Exp;
branches;
next	1.182;
commitid	MgmMgxX5WBbY1YFd;

1.182
date	2017.01.09.17.49.55;	author schwarze;	state Exp;
branches;
next	1.181;
commitid	8edGWa3bQBtupYYK;

1.181
date	2017.01.09.01.36.22;	author schwarze;	state Exp;
branches;
next	1.180;
commitid	h3vKZfLhTYNgTrav;

1.180
date	2016.09.18.15.45.50;	author schwarze;	state Exp;
branches;
next	1.179;
commitid	S7RUWBp8gsLUwZRq;

1.179
date	2016.09.18.15.21.00;	author schwarze;	state Exp;
branches;
next	1.178;
commitid	xlzs5fQHJfOhtV6D;

1.178
date	2016.08.09.15.08.15;	author schwarze;	state Exp;
branches;
next	1.177;
commitid	0tR13xy4fWg1d9V8;

1.177
date	2016.08.01.10.32.39;	author schwarze;	state Exp;
branches;
next	1.176;
commitid	UE9YpFybzQeyHuWW;

1.176
date	2016.07.15.19.31.53;	author schwarze;	state Exp;
branches;
next	1.175;
commitid	glSmVicTuUrr6wIu;

1.175
date	2016.07.15.18.49.53;	author schwarze;	state Exp;
branches;
next	1.174;
commitid	s2QOIZQWSCs01Dzb;

1.174
date	2016.07.15.18.02.32;	author schwarze;	state Exp;
branches;
next	1.173;
commitid	NgDdzKtKRT5DJZ6U;

1.173
date	2016.07.08.22.27.58;	author schwarze;	state Exp;
branches;
next	1.172;
commitid	bqbNrcG3yxfhXOgx;

1.172
date	2016.04.14.20.54.15;	author schwarze;	state Exp;
branches;
next	1.171;
commitid	ohl36omPcNVQhSdH;

1.171
date	2016.04.13.12.26.21;	author schwarze;	state Exp;
branches;
next	1.170;
commitid	PoXpOhYy87wZocqK;

1.170
date	2016.01.16.21.56.32;	author florian;	state Exp;
branches;
next	1.169;
commitid	RN8D9jN4YmT6PvCN;

1.169
date	2016.01.08.02.53.09;	author schwarze;	state Exp;
branches;
next	1.168;
commitid	HwNcDew1e7MZc0JI;

1.168
date	2016.01.08.02.13.35;	author schwarze;	state Exp;
branches;
next	1.167;
commitid	DCHIkxiiKvXaJZJp;

1.167
date	2015.12.15.17.36.19;	author schwarze;	state Exp;
branches;
next	1.166;
commitid	PXIma2wz20cyRFRu;

1.166
date	2015.11.20.21.58.32;	author schwarze;	state Exp;
branches;
next	1.165;
commitid	TwsVYiu2UT81vO9f;

1.165
date	2015.11.14.23.56.41;	author schwarze;	state Exp;
branches;
next	1.164;
commitid	iqL9elhUVYUztEVB;

1.164
date	2015.11.07.17.58.52;	author schwarze;	state Exp;
branches;
next	1.163;
commitid	9ZfFG7Q71jrU5djH;

1.163
date	2015.11.06.17.23.50;	author schwarze;	state Exp;
branches;
next	1.162;
commitid	fqbLrh9eGZV9BYJ5;

1.162
date	2015.11.06.16.27.13;	author schwarze;	state Exp;
branches;
next	1.161;
commitid	DFFVEgn8of3eIu5X;

1.161
date	2015.10.22.21.53.49;	author schwarze;	state Exp;
branches;
next	1.160;
commitid	b31415iHGGouYvkz;

1.160
date	2015.10.22.21.02.55;	author schwarze;	state Exp;
branches;
next	1.159;
commitid	wWppE2SL9vcDXWbn;

1.159
date	2015.10.20.02.00.49;	author schwarze;	state Exp;
branches;
next	1.158;
commitid	v6RrmxwM663z4mTF;

1.158
date	2015.10.19.19.51.06;	author schwarze;	state Exp;
branches;
next	1.157;
commitid	f13ntrY9RGtUe1Ga;

1.157
date	2015.10.16.21.35.16;	author schwarze;	state Exp;
branches;
next	1.156;
commitid	TbdvtL3wX3nxCzh0;

1.156
date	2015.10.16.13.37.44;	author millert;	state Exp;
branches;
next	1.155;
commitid	H99PcNtHGZMrNl2r;

1.155
date	2015.10.13.22.57.49;	author schwarze;	state Exp;
branches;
next	1.154;
commitid	jXIG8UzKLXm2Z9i6;

1.154
date	2015.10.12.22.41.18;	author schwarze;	state Exp;
branches;
next	1.153;
commitid	3b87Ac3AZfxbz7Fo;

1.153
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.152;
commitid	Ql2ha5NS80pwfGNT;

1.152
date	2015.10.11.21.06.59;	author schwarze;	state Exp;
branches;
next	1.151;
commitid	fBGuLyDivJdmK1wz;

1.151
date	2015.10.10.13.20.25;	author schwarze;	state Exp;
branches;
next	1.150;
commitid	RrB0TEjhX4bjh5gm;

1.150
date	2015.10.06.18.30.43;	author schwarze;	state Exp;
branches;
next	1.149;
commitid	hxQV8O1pNUaef4ir;

1.149
date	2015.07.28.18.38.05;	author schwarze;	state Exp;
branches;
next	1.148;
commitid	tPMQyF0qSW5rKa17;

1.148
date	2015.07.21.03.26.02;	author schwarze;	state Exp;
branches;
next	1.147;
commitid	YpvHQL0o4VwZB5CS;

1.147
date	2015.07.19.05.59.07;	author schwarze;	state Exp;
branches;
next	1.146;
commitid	X9sGdJbndRzfjdoG;

1.146
date	2015.07.19.00.06.33;	author schwarze;	state Exp;
branches;
next	1.145;
commitid	w8vGlCHgS9YtUo99;

1.145
date	2015.07.18.05.46.52;	author schwarze;	state Exp;
branches;
next	1.144;
commitid	1To9Q0kaBD6OO49B;

1.144
date	2015.07.17.22.35.36;	author schwarze;	state Exp;
branches;
next	1.143;
commitid	Ik50obX3Gy0LFoMQ;

1.143
date	2015.04.29.11.03.48;	author schwarze;	state Exp;
branches;
next	1.142;
commitid	OIPfgk7gHhOAS2gB;

1.142
date	2015.04.20.09.54.34;	author schwarze;	state Exp;
branches;
next	1.141;
commitid	wtLfcEgU1awfSxpc;

1.141
date	2015.04.19.15.10.04;	author schwarze;	state Exp;
branches;
next	1.140;
commitid	5C8xvgwQPSyJD0jw;

1.140
date	2015.04.18.16.34.03;	author schwarze;	state Exp;
branches;
next	1.139;
commitid	PxhkeHVIvdTMOTs6;

1.139
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.138;
commitid	6MYJ7cd8mhJ77AGH;

1.138
date	2015.04.16.16.35.02;	author schwarze;	state Exp;
branches;
next	1.137;
commitid	4vSBdUS7p686S9Ci;

1.137
date	2015.04.03.08.45.27;	author schwarze;	state Exp;
branches;
next	1.136;
commitid	kemTcQbhPNWTnazN;

1.136
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.135;
commitid	lmErjWY2O9ooA6RY;

1.135
date	2015.03.27.21.17.16;	author schwarze;	state Exp;
branches;
next	1.134;
commitid	r1NPkDobCJs0RcWM;

1.134
date	2015.03.27.17.36.56;	author schwarze;	state Exp;
branches;
next	1.133;
commitid	3WUgQM2C53CGXRkK;

1.133
date	2015.03.27.16.35.57;	author schwarze;	state Exp;
branches;
next	1.132;
commitid	zbinBoGMzcgILjo3;

1.132
date	2015.03.17.13.35.04;	author schwarze;	state Exp;
branches;
next	1.131;
commitid	oxTrLzSYTr759l4W;

1.131
date	2015.03.17.07.32.21;	author schwarze;	state Exp;
branches;
next	1.130;
commitid	8aec9pdQoYUAe3Rf;

1.130
date	2015.03.10.13.48.57;	author schwarze;	state Exp;
branches;
next	1.129;
commitid	zk8S70czkYyHtd1X;

1.129
date	2015.03.10.03.00.48;	author schwarze;	state Exp;
branches;
next	1.128;
commitid	y4cppSpaQpbAj4bf;

1.128
date	2015.03.09.21.30.27;	author schwarze;	state Exp;
branches;
next	1.127;
commitid	OIfy2YhnOvFteiXh;

1.127
date	2015.02.27.16.00.54;	author schwarze;	state Exp;
branches;
next	1.126;
commitid	a66TRAvkCvQu6JzX;

1.126
date	2015.02.16.16.18.02;	author schwarze;	state Exp;
branches;
next	1.125;
commitid	Za7hVfBo928Vx64a;

1.125
date	2015.02.10.08.05.07;	author schwarze;	state Exp;
branches;
next	1.124;
commitid	udnlyXKeRKvRFGfq;

1.124
date	2015.02.07.06.27.53;	author schwarze;	state Exp;
branches;
next	1.123;
commitid	y1DfBOybkFjAJQ6E;

1.123
date	2015.01.20.21.12.46;	author schwarze;	state Exp;
branches;
next	1.122;
commitid	yL1piccWr1moLOpy;

1.122
date	2015.01.16.21.12.01;	author schwarze;	state Exp;
branches;
next	1.121;
commitid	kkwQwqyjvZjvXeJ7;

1.121
date	2015.01.15.04.26.06;	author schwarze;	state Exp;
branches;
next	1.120;
commitid	TgtfgXU8Rz8XgmeH;

1.120
date	2015.01.14.21.27.01;	author schwarze;	state Exp;
branches;
next	1.119;
commitid	MOJ5XEn4fRdooRU5;

1.119
date	2015.01.13.23.16.12;	author schwarze;	state Exp;
branches;
next	1.118;
commitid	Ag3THq0j2txCEErl;

1.118
date	2015.01.13.13.22.13;	author schwarze;	state Exp;
branches;
next	1.117;
commitid	yY6FbevxKdMEKoIL;

1.117
date	2015.01.01.13.18.23;	author schwarze;	state Exp;
branches;
next	1.116;
commitid	pXtwnUDIL1Y4X7Lg;

1.116
date	2014.12.31.16.50.54;	author schwarze;	state Exp;
branches;
next	1.115;
commitid	d4vqwNunQKF1TkjN;

1.115
date	2014.12.21.14.49.00;	author schwarze;	state Exp;
branches;
next	1.114;
commitid	vuQc2DygbCWfCuiS;

1.114
date	2014.12.18.20.45.50;	author jmc;	state Exp;
branches;
next	1.113;
commitid	sE7M1HovWWYROKYi;

1.113
date	2014.12.17.18.45.00;	author schwarze;	state Exp;
branches;
next	1.112;
commitid	9LMuE7O1uDI94hwa;

1.112
date	2014.12.15.18.04.32;	author schwarze;	state Exp;
branches;
next	1.111;
commitid	tt6zApYlhcrzrxRR;

1.111
date	2014.12.11.19.50.04;	author schwarze;	state Exp;
branches;
next	1.110;
commitid	79oldjM807DWliVg;

1.110
date	2014.12.05.21.55.02;	author schwarze;	state Exp;
branches;
next	1.109;
commitid	dyW222XeQqKwX6ql;

1.109
date	2014.12.02.11.31.46;	author schwarze;	state Exp;
branches;
next	1.108;
commitid	GWuTZns9GGFzCuYv;

1.108
date	2014.11.26.21.40.11;	author schwarze;	state Exp;
branches;
next	1.107;
commitid	BFoJYar3mOvn9yB3;

1.107
date	2014.11.11.19.03.10;	author schwarze;	state Exp;
branches;
next	1.106;
commitid	D7uokBruncZXc8f1;

1.106
date	2014.11.11.02.43.11;	author schwarze;	state Exp;
branches;
next	1.105;
commitid	7h4OpsiyzbJtK17w;

1.105
date	2014.11.11.02.08.57;	author schwarze;	state Exp;
branches;
next	1.104;
commitid	BlgTU7cLLnT1msgx;

1.104
date	2014.10.30.15.05.05;	author jmc;	state Exp;
branches;
next	1.103;
commitid	BnKtSKVRiyDlS9Wn;

1.103
date	2014.10.30.00.05.02;	author schwarze;	state Exp;
branches;
next	1.102;
commitid	dxVoXRJjO1zZjAXI;

1.102
date	2014.10.28.17.35.42;	author schwarze;	state Exp;
branches;
next	1.101;
commitid	pNwmOla3ZQwLgu2f;

1.101
date	2014.10.18.15.46.16;	author schwarze;	state Exp;
branches;
next	1.100;
commitid	QXZTfMgoc4XBAEwx;

1.100
date	2014.09.03.23.20.33;	author schwarze;	state Exp;
branches;
next	1.99;
commitid	nPk0DzpqFSEanZEV;

1.99
date	2014.09.03.18.08.26;	author schwarze;	state Exp;
branches;
next	1.98;
commitid	1DUpWacPgRNVWanP;

1.98
date	2014.09.03.05.17.08;	author schwarze;	state Exp;
branches;
next	1.97;
commitid	D4HCUw9YYVx6NSQl;

1.97
date	2014.09.01.22.45.11;	author schwarze;	state Exp;
branches;
next	1.96;
commitid	N1uQZHrcgUZHkfAK;

1.96
date	2014.08.30.18.04.52;	author schwarze;	state Exp;
branches;
next	1.95;
commitid	YrTLlLm4kYlZaLCQ;

1.95
date	2014.08.27.00.06.08;	author schwarze;	state Exp;
branches;
next	1.94;
commitid	52PkSro00emV8qcw;

1.94
date	2014.06.21.22.23.44;	author schwarze;	state Exp;
branches;
next	1.93;
commitid	XF9RGPYLiBVL882J;

1.93
date	2014.06.21.16.17.56;	author schwarze;	state Exp;
branches;
next	1.92;
commitid	njZYmy3Y69FWaU2Z;

1.92
date	2014.06.20.22.58.41;	author schwarze;	state Exp;
branches;
next	1.91;
commitid	ktgkM223FL3EC6E8;

1.91
date	2014.06.20.16.11.03;	author schwarze;	state Exp;
branches;
next	1.90;
commitid	a0seo15vmrDAYK2N;

1.90
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.89;

1.89
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.88;

1.88
date	2014.03.19.22.20.36;	author schwarze;	state Exp;
branches;
next	1.87;

1.87
date	2014.03.19.21.50.59;	author schwarze;	state Exp;
branches;
next	1.86;

1.86
date	2014.01.06.00.53.14;	author schwarze;	state Exp;
branches;
next	1.85;

1.85
date	2014.01.05.20.26.27;	author schwarze;	state Exp;
branches;
next	1.84;

1.84
date	2012.11.19.08.46.24;	author jmc;	state Exp;
branches;
next	1.83;

1.83
date	2012.05.24.23.33.23;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2011.12.25.17.34.57;	author schwarze;	state Exp;
branches;
next	1.81;

1.81
date	2011.11.28.00.16.38;	author schwarze;	state Exp;
branches;
next	1.80;

1.80
date	2011.10.09.17.59.56;	author schwarze;	state Exp;
branches;
next	1.79;

1.79
date	2011.10.06.23.04.16;	author schwarze;	state Exp;
branches;
next	1.78;

1.78
date	2011.09.17.14.45.22;	author schwarze;	state Exp;
branches;
next	1.77;

1.77
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.76;

1.76
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.75;

1.75
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.74;

1.74
date	2011.03.20.23.36.42;	author schwarze;	state Exp;
branches;
next	1.73;

1.73
date	2011.03.07.01.35.33;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2011.02.06.17.33.20;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2011.01.25.12.24.26;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2011.01.24.23.40.12;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2011.01.20.21.33.11;	author schwarze;	state Exp;
branches;
next	1.68;

1.68
date	2011.01.16.19.27.25;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2011.01.16.01.11.50;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2011.01.10.23.53.32;	author schwarze;	state Exp;
branches;
next	1.65;

1.65
date	2011.01.09.13.16.48;	author schwarze;	state Exp;
branches;
next	1.64;

1.64
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.63;

1.63
date	2011.01.03.23.39.27;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2010.12.21.01.22.00;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2010.12.09.23.01.18;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2010.12.02.20.40.43;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2010.12.01.23.38.11;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2010.12.01.22.02.29;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2010.11.29.00.12.02;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2010.11.28.19.35.33;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2010.11.25.22.23.31;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2010.10.26.23.34.38;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2010.10.26.22.48.07;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2010.10.26.22.28.56;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2010.10.26.22.13.58;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2010.10.24.18.15.43;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2010.10.16.20.49.37;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2010.09.27.21.25.28;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2010.09.26.20.19.58;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2010.08.20.08.13.03;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2010.08.20.00.53.35;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2010.08.18.01.03.22;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.13.01.09.12;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2010.07.01.15.36.59;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.30.20.29.44;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.29.15.49.52;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2010.06.27.21.54.41;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.26.17.56.43;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2010.06.10.22.50.10;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.08.00.11.47;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.06.20.30.08;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.23.22.45.00;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2010.05.20.00.58.02;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.16.01.16.25;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.16.00.54.03;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.15.22.00.22;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.15.21.09.53;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.15.17.32.25;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2010.05.15.15.58.56;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.14.01.54.37;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2010.05.13.20.34.29;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.13.06.52.12;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2010.03.26.01.22.05;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2010.02.18.02.11.26;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.23.22.30.17;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.21.19.13.50;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.21.20.57.57;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.22.17.21.23;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.22.14.56.03;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.12.22.44.45;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.12.18.28.29;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.07.00.54.46;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.07.00.16.21;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.06.22.12.38;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.23.22.31.26;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.21.20.10.31;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.18.23.51.12;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.18.23.34.53;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.18.22.16.56;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.14.23.39.43;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.14.23.00.57;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.20.30.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.190
log
@simplify the SYNOPSIS as well, just like the option lists;
suggested by and OK jmc@@
@
text
@/*	$OpenBSD: main.c,v 1.189 2017/03/20 14:30:43 schwarze Exp $ */
/*
 * Copyright (c) 2008-2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010-2012, 2014-2017 Ingo Schwarze <schwarze@@openbsd.org>
 * Copyright (c) 2010 Joerg Sonnenberger <joerg@@netbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/param.h>	/* MACHINE */
#include <sys/wait.h>

#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <glob.h>
#include <signal.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "man.h"
#include "tag.h"
#include "main.h"
#include "manconf.h"
#include "mansearch.h"

enum	outmode {
	OUTMODE_DEF = 0,
	OUTMODE_FLN,
	OUTMODE_LST,
	OUTMODE_ALL,
	OUTMODE_INT,
	OUTMODE_ONE
};

enum	outt {
	OUTT_ASCII = 0,	/* -Tascii */
	OUTT_LOCALE,	/* -Tlocale */
	OUTT_UTF8,	/* -Tutf8 */
	OUTT_TREE,	/* -Ttree */
	OUTT_MAN,	/* -Tman */
	OUTT_HTML,	/* -Thtml */
	OUTT_MARKDOWN,	/* -Tmarkdown */
	OUTT_LINT,	/* -Tlint */
	OUTT_PS,	/* -Tps */
	OUTT_PDF	/* -Tpdf */
};

struct	curparse {
	struct mparse	 *mp;
	enum mandoclevel  wlevel;	/* ignore messages below this */
	int		  wstop;	/* stop after a file with a warning */
	enum outt	  outtype;	/* which output to use */
	void		 *outdata;	/* data for output */
	struct manoutput *outopts;	/* output options */
};


int			  mandocdb(int, char *[]);

static	int		  fs_lookup(const struct manpaths *,
				size_t ipath, const char *,
				const char *, const char *,
				struct manpage **, size_t *);
static	void		  fs_search(const struct mansearch *,
				const struct manpaths *, int, char**,
				struct manpage **, size_t *);
static	int		  koptions(int *, char *);
static	void		  moptions(int *, char *);
static	void		  mmsg(enum mandocerr, enum mandoclevel,
				const char *, int, int, const char *);
static	void		  outdata_alloc(struct curparse *);
static	void		  parse(struct curparse *, int, const char *);
static	void		  passthrough(const char *, int, int);
static	pid_t		  spawn_pager(struct tag_files *);
static	int		  toptions(struct curparse *, char *);
static	void		  usage(enum argmode) __attribute__((__noreturn__));
static	int		  woptions(struct curparse *, char *);

static	const int sec_prios[] = {1, 4, 5, 8, 6, 3, 7, 2, 9};
static	char		  help_arg[] = "help";
static	char		 *help_argv[] = {help_arg, NULL};
static	enum mandoclevel  rc;


int
main(int argc, char *argv[])
{
	struct manconf	 conf;
	struct mansearch search;
	struct curparse	 curp;
	struct tag_files *tag_files;
	struct manpage	*res, *resp;
	const char	*progname, *sec, *thisarg;
	char		*conf_file, *defpaths, *auxpaths;
	char		*defos, *oarg;
	unsigned char	*uc;
	size_t		 i, sz;
	int		 prio, best_prio;
	enum outmode	 outmode;
	int		 fd;
	int		 show_usage;
	int		 options;
	int		 use_pager;
	int		 status, signum;
	int		 c;
	pid_t		 pager_pid, tc_pgid, man_pgid, pid;

	progname = getprogname();
	if (strncmp(progname, "mandocdb", 8) == 0 ||
	    strncmp(progname, "makewhatis", 10) == 0)
		return mandocdb(argc, argv);

	if (pledge("stdio rpath tmppath tty proc exec", NULL) == -1)
		err((int)MANDOCLEVEL_SYSERR, "pledge");

	/* Search options. */

	memset(&conf, 0, sizeof(conf));
	conf_file = defpaths = NULL;
	auxpaths = NULL;

	memset(&search, 0, sizeof(struct mansearch));
	search.outkey = "Nd";
	oarg = NULL;

	if (strcmp(progname, "man") == 0)
		search.argmode = ARG_NAME;
	else if (strncmp(progname, "apropos", 7) == 0)
		search.argmode = ARG_EXPR;
	else if (strncmp(progname, "whatis", 6) == 0)
		search.argmode = ARG_WORD;
	else if (strncmp(progname, "help", 4) == 0)
		search.argmode = ARG_NAME;
	else
		search.argmode = ARG_FILE;

	/* Parser and formatter options. */

	memset(&curp, 0, sizeof(struct curparse));
	curp.outtype = OUTT_LOCALE;
	curp.wlevel  = MANDOCLEVEL_BADARG;
	curp.outopts = &conf.output;
	options = MPARSE_SO | MPARSE_UTF8 | MPARSE_LATIN1;
	defos = NULL;

	use_pager = 1;
	tag_files = NULL;
	show_usage = 0;
	outmode = OUTMODE_DEF;

	while (-1 != (c = getopt(argc, argv,
			"aC:cfhI:iK:klM:m:O:S:s:T:VW:w"))) {
		switch (c) {
		case 'a':
			outmode = OUTMODE_ALL;
			break;
		case 'C':
			conf_file = optarg;
			break;
		case 'c':
			use_pager = 0;
			break;
		case 'f':
			search.argmode = ARG_WORD;
			break;
		case 'h':
			conf.output.synopsisonly = 1;
			use_pager = 0;
			outmode = OUTMODE_ALL;
			break;
		case 'I':
			if (strncmp(optarg, "os=", 3)) {
				warnx("-I %s: Bad argument", optarg);
				return (int)MANDOCLEVEL_BADARG;
			}
			if (defos) {
				warnx("-I %s: Duplicate argument", optarg);
				return (int)MANDOCLEVEL_BADARG;
			}
			defos = mandoc_strdup(optarg + 3);
			break;
		case 'i':
			outmode = OUTMODE_INT;
			break;
		case 'K':
			if ( ! koptions(&options, optarg))
				return (int)MANDOCLEVEL_BADARG;
			break;
		case 'k':
			search.argmode = ARG_EXPR;
			break;
		case 'l':
			search.argmode = ARG_FILE;
			outmode = OUTMODE_ALL;
			break;
		case 'M':
			defpaths = optarg;
			break;
		case 'm':
			auxpaths = optarg;
			break;
		case 'O':
			oarg = optarg;
			break;
		case 'S':
			search.arch = optarg;
			break;
		case 's':
			search.sec = optarg;
			break;
		case 'T':
			if ( ! toptions(&curp, optarg))
				return (int)MANDOCLEVEL_BADARG;
			break;
		case 'W':
			if ( ! woptions(&curp, optarg))
				return (int)MANDOCLEVEL_BADARG;
			break;
		case 'w':
			outmode = OUTMODE_FLN;
			break;
		default:
			show_usage = 1;
			break;
		}
	}

	if (show_usage)
		usage(search.argmode);

	/* Postprocess options. */

	if (outmode == OUTMODE_DEF) {
		switch (search.argmode) {
		case ARG_FILE:
			outmode = OUTMODE_ALL;
			use_pager = 0;
			break;
		case ARG_NAME:
			outmode = OUTMODE_ONE;
			break;
		default:
			outmode = OUTMODE_LST;
			break;
		}
	}

	if (oarg != NULL) {
		if (outmode == OUTMODE_LST)
			search.outkey = oarg;
		else {
			while (oarg != NULL) {
				thisarg = oarg;
				if (manconf_output(&conf.output,
				    strsep(&oarg, ","), 0) == 0)
					continue;
				warnx("-O %s: Bad argument", thisarg);
				return (int)MANDOCLEVEL_BADARG;
			}
		}
	}

	if (outmode == OUTMODE_FLN ||
	    outmode == OUTMODE_LST ||
	    !isatty(STDOUT_FILENO))
		use_pager = 0;

	if (!use_pager)
		if (pledge("stdio rpath", NULL) == -1)
			err((int)MANDOCLEVEL_SYSERR, "pledge");

	/* Parse arguments. */

	if (argc > 0) {
		argc -= optind;
		argv += optind;
	}
	resp = NULL;

	/*
	 * Quirks for help(1)
	 * and for a man(1) section argument without -s.
	 */

	if (search.argmode == ARG_NAME) {
		if (*progname == 'h') {
			if (argc == 0) {
				argv = help_argv;
				argc = 1;
			}
		} else if (argc > 1 &&
		    ((uc = (unsigned char *)argv[0]) != NULL) &&
		    ((isdigit(uc[0]) && (uc[1] == '\0' ||
		      (isalpha(uc[1]) && uc[2] == '\0'))) ||
		     (uc[0] == 'n' && uc[1] == '\0'))) {
			search.sec = (char *)uc;
			argv++;
			argc--;
		}
		if (search.arch == NULL)
			search.arch = getenv("MACHINE");
		if (search.arch == NULL)
			search.arch = MACHINE;
	}

	rc = MANDOCLEVEL_OK;

	/* man(1), whatis(1), apropos(1) */

	if (search.argmode != ARG_FILE) {
		if (search.argmode == ARG_NAME &&
		    outmode == OUTMODE_ONE)
			search.firstmatch = 1;

		/* Access the mandoc database. */

		manconf_parse(&conf, conf_file, defpaths, auxpaths);
		if ( ! mansearch(&search, &conf.manpath,
		    argc, argv, &res, &sz))
			usage(search.argmode);

		if (sz == 0) {
			if (search.argmode == ARG_NAME)
				fs_search(&search, &conf.manpath,
				    argc, argv, &res, &sz);
			else
				warnx("nothing appropriate");
		}

		if (sz == 0) {
			rc = MANDOCLEVEL_BADARG;
			goto out;
		}

		/*
		 * For standard man(1) and -a output mode,
		 * prepare for copying filename pointers
		 * into the program parameter array.
		 */

		if (outmode == OUTMODE_ONE) {
			argc = 1;
			best_prio = 20;
		} else if (outmode == OUTMODE_ALL)
			argc = (int)sz;

		/* Iterate all matching manuals. */

		resp = res;
		for (i = 0; i < sz; i++) {
			if (outmode == OUTMODE_FLN)
				puts(res[i].file);
			else if (outmode == OUTMODE_LST)
				printf("%s - %s\n", res[i].names,
				    res[i].output == NULL ? "" :
				    res[i].output);
			else if (outmode == OUTMODE_ONE) {
				/* Search for the best section. */
				sec = res[i].file;
				sec += strcspn(sec, "123456789");
				if (sec[0] == '\0')
					continue;
				prio = sec_prios[sec[0] - '1'];
				if (sec[1] != '/')
					prio += 10;
				if (prio >= best_prio)
					continue;
				best_prio = prio;
				resp = res + i;
			}
		}

		/*
		 * For man(1), -a and -i output mode, fall through
		 * to the main mandoc(1) code iterating files
		 * and running the parsers on each of them.
		 */

		if (outmode == OUTMODE_FLN || outmode == OUTMODE_LST)
			goto out;
	}

	/* mandoc(1) */

	if (use_pager) {
		if (pledge("stdio rpath tmppath tty proc exec", NULL) == -1)
			err((int)MANDOCLEVEL_SYSERR, "pledge");
	} else {
		if (pledge("stdio rpath", NULL) == -1)
			err((int)MANDOCLEVEL_SYSERR, "pledge");
	}

	if (search.argmode == ARG_FILE)
		moptions(&options, auxpaths);

	mchars_alloc();
	curp.mp = mparse_alloc(options, curp.wlevel, mmsg, defos);

	/*
	 * Conditionally start up the lookaside buffer before parsing.
	 */
	if (OUTT_MAN == curp.outtype)
		mparse_keep(curp.mp);

	if (argc < 1) {
		if (use_pager)
			tag_files = tag_init();
		parse(&curp, STDIN_FILENO, "<stdin>");
	}

	while (argc > 0) {
		fd = mparse_open(curp.mp, resp != NULL ? resp->file : *argv);
		if (fd != -1) {
			if (use_pager) {
				tag_files = tag_init();
				use_pager = 0;
			}

			if (resp == NULL)
				parse(&curp, fd, *argv);
			else if (resp->form == FORM_SRC) {
				/* For .so only; ignore failure. */
				chdir(conf.manpath.paths[resp->ipath]);
				parse(&curp, fd, resp->file);
			} else
				passthrough(resp->file, fd,
				    conf.output.synopsisonly);

			if (argc > 1 && curp.outtype <= OUTT_UTF8) {
				if (curp.outdata == NULL)
					outdata_alloc(&curp);
				terminal_sepline(curp.outdata);
			}
		} else if (rc < MANDOCLEVEL_ERROR)
			rc = MANDOCLEVEL_ERROR;

		if (MANDOCLEVEL_OK != rc && curp.wstop)
			break;

		if (resp != NULL)
			resp++;
		else
			argv++;
		if (--argc)
			mparse_reset(curp.mp);
	}

	if (curp.outdata != NULL) {
		switch (curp.outtype) {
		case OUTT_HTML:
			html_free(curp.outdata);
			break;
		case OUTT_UTF8:
		case OUTT_LOCALE:
		case OUTT_ASCII:
			ascii_free(curp.outdata);
			break;
		case OUTT_PDF:
		case OUTT_PS:
			pspdf_free(curp.outdata);
			break;
		default:
			break;
		}
	}
	mparse_free(curp.mp);
	mchars_free();

out:
	if (search.argmode != ARG_FILE) {
		manconf_free(&conf);
		mansearch_free(res, sz);
	}

	free(defos);

	/*
	 * When using a pager, finish writing both temporary files,
	 * fork it, wait for the user to close it, and clean up.
	 */

	if (tag_files != NULL) {
		fclose(stdout);
		tag_write();
		man_pgid = getpgid(0);
		tag_files->tcpgid = man_pgid == getpid() ?
		    getpgid(getppid()) : man_pgid;
		pager_pid = 0;
		signum = SIGSTOP;
		for (;;) {

			/* Stop here until moved to the foreground. */

			tc_pgid = tcgetpgrp(tag_files->ofd);
			if (tc_pgid != man_pgid) {
				if (tc_pgid == pager_pid) {
					(void)tcsetpgrp(tag_files->ofd,
					    man_pgid);
					if (signum == SIGTTIN)
						continue;
				} else
					tag_files->tcpgid = tc_pgid;
				kill(0, signum);
				continue;
			}

			/* Once in the foreground, activate the pager. */

			if (pager_pid) {
				(void)tcsetpgrp(tag_files->ofd, pager_pid);
				kill(pager_pid, SIGCONT);
			} else
				pager_pid = spawn_pager(tag_files);

			/* Wait for the pager to stop or exit. */

			while ((pid = waitpid(pager_pid, &status,
			    WUNTRACED)) == -1 && errno == EINTR)
				continue;

			if (pid == -1) {
				warn("wait");
				rc = MANDOCLEVEL_SYSERR;
				break;
			}
			if (!WIFSTOPPED(status))
				break;

			signum = WSTOPSIG(status);
		}
		tag_unlink();
	}

	return (int)rc;
}

static void
usage(enum argmode argmode)
{

	switch (argmode) {
	case ARG_FILE:
		fputs("usage: mandoc [-ac] [-I os=name] "
		    "[-K encoding] [-mdoc | -man] [-O options]\n"
		    "\t      [-T output] [-W level] [file ...]\n", stderr);
		break;
	case ARG_NAME:
		fputs("usage: man [-acfhklw] [-C file] [-M path] "
		    "[-m path] [-S subsection]\n"
		    "\t   [[-s] section] name ...\n", stderr);
		break;
	case ARG_WORD:
		fputs("usage: whatis [-afk] [-C file] "
		    "[-M path] [-m path] [-O outkey] [-S arch]\n"
		    "\t      [-s section] name ...\n", stderr);
		break;
	case ARG_EXPR:
		fputs("usage: apropos [-afk] [-C file] "
		    "[-M path] [-m path] [-O outkey] [-S arch]\n"
		    "\t       [-s section] expression ...\n", stderr);
		break;
	}
	exit((int)MANDOCLEVEL_BADARG);
}

static int
fs_lookup(const struct manpaths *paths, size_t ipath,
	const char *sec, const char *arch, const char *name,
	struct manpage **res, size_t *ressz)
{
	glob_t		 globinfo;
	struct manpage	*page;
	char		*file;
	int		 globres;
	enum form	 form;

	form = FORM_SRC;
	mandoc_asprintf(&file, "%s/man%s/%s.%s",
	    paths->paths[ipath], sec, name, sec);
	if (access(file, R_OK) != -1)
		goto found;
	free(file);

	mandoc_asprintf(&file, "%s/cat%s/%s.0",
	    paths->paths[ipath], sec, name);
	if (access(file, R_OK) != -1) {
		form = FORM_CAT;
		goto found;
	}
	free(file);

	if (arch != NULL) {
		mandoc_asprintf(&file, "%s/man%s/%s/%s.%s",
		    paths->paths[ipath], sec, arch, name, sec);
		if (access(file, R_OK) != -1)
			goto found;
		free(file);
	}

	mandoc_asprintf(&file, "%s/man%s/%s.[01-9]*",
	    paths->paths[ipath], sec, name);
	globres = glob(file, 0, NULL, &globinfo);
	if (globres != 0 && globres != GLOB_NOMATCH)
		warn("%s: glob", file);
	free(file);
	if (globres == 0)
		file = mandoc_strdup(*globinfo.gl_pathv);
	globfree(&globinfo);
	if (globres != 0)
		return 0;

found:
	warnx("outdated mandoc.db lacks %s(%s) entry, run makewhatis %s",
	    name, sec, paths->paths[ipath]);
	*res = mandoc_reallocarray(*res, ++*ressz, sizeof(struct manpage));
	page = *res + (*ressz - 1);
	page->file = file;
	page->names = NULL;
	page->output = NULL;
	page->ipath = ipath;
	page->bits = NAME_FILE & NAME_MASK;
	page->sec = (*sec >= '1' && *sec <= '9') ? *sec - '1' + 1 : 10;
	page->form = form;
	return 1;
}

static void
fs_search(const struct mansearch *cfg, const struct manpaths *paths,
	int argc, char **argv, struct manpage **res, size_t *ressz)
{
	const char *const sections[] =
	    {"1", "8", "6", "2", "3", "5", "7", "4", "9", "3p"};
	const size_t nsec = sizeof(sections)/sizeof(sections[0]);

	size_t		 ipath, isec, lastsz;

	assert(cfg->argmode == ARG_NAME);

	*res = NULL;
	*ressz = lastsz = 0;
	while (argc) {
		for (ipath = 0; ipath < paths->sz; ipath++) {
			if (cfg->sec != NULL) {
				if (fs_lookup(paths, ipath, cfg->sec,
				    cfg->arch, *argv, res, ressz) &&
				    cfg->firstmatch)
					return;
			} else for (isec = 0; isec < nsec; isec++)
				if (fs_lookup(paths, ipath, sections[isec],
				    cfg->arch, *argv, res, ressz) &&
				    cfg->firstmatch)
					return;
		}
		if (*ressz == lastsz)
			warnx("No entry for %s in the manual.", *argv);
		lastsz = *ressz;
		argv++;
		argc--;
	}
}

static void
parse(struct curparse *curp, int fd, const char *file)
{
	enum mandoclevel  rctmp;
	struct roff_man	 *man;

	/* Begin by parsing the file itself. */

	assert(file);
	assert(fd >= 0);

	rctmp = mparse_readfd(curp->mp, fd, file);
	if (fd != STDIN_FILENO)
		close(fd);
	if (rc < rctmp)
		rc = rctmp;

	/*
	 * With -Wstop and warnings or errors of at least the requested
	 * level, do not produce output.
	 */

	if (rctmp != MANDOCLEVEL_OK && curp->wstop)
		return;

	if (curp->outdata == NULL)
		outdata_alloc(curp);

	mparse_result(curp->mp, &man, NULL);

	/* Execute the out device, if it exists. */

	if (man == NULL)
		return;
	if (man->macroset == MACROSET_MDOC) {
		if (curp->outtype != OUTT_TREE || !curp->outopts->noval)
			mdoc_validate(man);
		switch (curp->outtype) {
		case OUTT_HTML:
			html_mdoc(curp->outdata, man);
			break;
		case OUTT_TREE:
			tree_mdoc(curp->outdata, man);
			break;
		case OUTT_MAN:
			man_mdoc(curp->outdata, man);
			break;
		case OUTT_PDF:
		case OUTT_ASCII:
		case OUTT_UTF8:
		case OUTT_LOCALE:
		case OUTT_PS:
			terminal_mdoc(curp->outdata, man);
			break;
		case OUTT_MARKDOWN:
			markdown_mdoc(curp->outdata, man);
			break;
		default:
			break;
		}
	}
	if (man->macroset == MACROSET_MAN) {
		if (curp->outtype != OUTT_TREE || !curp->outopts->noval)
			man_validate(man);
		switch (curp->outtype) {
		case OUTT_HTML:
			html_man(curp->outdata, man);
			break;
		case OUTT_TREE:
			tree_man(curp->outdata, man);
			break;
		case OUTT_MAN:
			man_man(curp->outdata, man);
			break;
		case OUTT_PDF:
		case OUTT_ASCII:
		case OUTT_UTF8:
		case OUTT_LOCALE:
		case OUTT_PS:
			terminal_man(curp->outdata, man);
			break;
		default:
			break;
		}
	}
	mparse_updaterc(curp->mp, &rc);
}

static void
outdata_alloc(struct curparse *curp)
{
	switch (curp->outtype) {
	case OUTT_HTML:
		curp->outdata = html_alloc(curp->outopts);
		break;
	case OUTT_UTF8:
		curp->outdata = utf8_alloc(curp->outopts);
		break;
	case OUTT_LOCALE:
		curp->outdata = locale_alloc(curp->outopts);
		break;
	case OUTT_ASCII:
		curp->outdata = ascii_alloc(curp->outopts);
		break;
	case OUTT_PDF:
		curp->outdata = pdf_alloc(curp->outopts);
		break;
	case OUTT_PS:
		curp->outdata = ps_alloc(curp->outopts);
		break;
	default:
		break;
	}
}

static void
passthrough(const char *file, int fd, int synopsis_only)
{
	const char	 synb[] = "S\bSY\bYN\bNO\bOP\bPS\bSI\bIS\bS";
	const char	 synr[] = "SYNOPSIS";

	FILE		*stream;
	const char	*syscall;
	char		*line, *cp;
	size_t		 linesz;
	ssize_t		 len, written;
	int		 print;

	line = NULL;
	linesz = 0;

	if (fflush(stdout) == EOF) {
		syscall = "fflush";
		goto fail;
	}

	if ((stream = fdopen(fd, "r")) == NULL) {
		close(fd);
		syscall = "fdopen";
		goto fail;
	}

	print = 0;
	while ((len = getline(&line, &linesz, stream)) != -1) {
		cp = line;
		if (synopsis_only) {
			if (print) {
				if ( ! isspace((unsigned char)*cp))
					goto done;
				while (isspace((unsigned char)*cp)) {
					cp++;
					len--;
				}
			} else {
				if (strcmp(cp, synb) == 0 ||
				    strcmp(cp, synr) == 0)
					print = 1;
				continue;
			}
		}
		for (; len > 0; len -= written) {
			if ((written = write(STDOUT_FILENO, cp, len)) != -1)
				continue;
			fclose(stream);
			syscall = "write";
			goto fail;
		}
	}

	if (ferror(stream)) {
		fclose(stream);
		syscall = "getline";
		goto fail;
	}

done:
	free(line);
	fclose(stream);
	return;

fail:
	free(line);
	warn("%s: SYSERR: %s", file, syscall);
	if (rc < MANDOCLEVEL_SYSERR)
		rc = MANDOCLEVEL_SYSERR;
}

static int
koptions(int *options, char *arg)
{

	if ( ! strcmp(arg, "utf-8")) {
		*options |=  MPARSE_UTF8;
		*options &= ~MPARSE_LATIN1;
	} else if ( ! strcmp(arg, "iso-8859-1")) {
		*options |=  MPARSE_LATIN1;
		*options &= ~MPARSE_UTF8;
	} else if ( ! strcmp(arg, "us-ascii")) {
		*options &= ~(MPARSE_UTF8 | MPARSE_LATIN1);
	} else {
		warnx("-K %s: Bad argument", arg);
		return 0;
	}
	return 1;
}

static void
moptions(int *options, char *arg)
{

	if (arg == NULL)
		return;
	if (strcmp(arg, "doc") == 0)
		*options |= MPARSE_MDOC;
	else if (strcmp(arg, "an") == 0)
		*options |= MPARSE_MAN;
}

static int
toptions(struct curparse *curp, char *arg)
{

	if (0 == strcmp(arg, "ascii"))
		curp->outtype = OUTT_ASCII;
	else if (0 == strcmp(arg, "lint")) {
		curp->outtype = OUTT_LINT;
		curp->wlevel  = MANDOCLEVEL_WARNING;
	} else if (0 == strcmp(arg, "tree"))
		curp->outtype = OUTT_TREE;
	else if (0 == strcmp(arg, "man"))
		curp->outtype = OUTT_MAN;
	else if (0 == strcmp(arg, "html"))
		curp->outtype = OUTT_HTML;
	else if (0 == strcmp(arg, "markdown"))
		curp->outtype = OUTT_MARKDOWN;
	else if (0 == strcmp(arg, "utf8"))
		curp->outtype = OUTT_UTF8;
	else if (0 == strcmp(arg, "locale"))
		curp->outtype = OUTT_LOCALE;
	else if (0 == strcmp(arg, "xhtml"))
		curp->outtype = OUTT_HTML;
	else if (0 == strcmp(arg, "ps"))
		curp->outtype = OUTT_PS;
	else if (0 == strcmp(arg, "pdf"))
		curp->outtype = OUTT_PDF;
	else {
		warnx("-T %s: Bad argument", arg);
		return 0;
	}

	return 1;
}

static int
woptions(struct curparse *curp, char *arg)
{
	char		*v, *o;
	const char	*toks[7];

	toks[0] = "stop";
	toks[1] = "all";
	toks[2] = "warning";
	toks[3] = "error";
	toks[4] = "unsupp";
	toks[5] = "fatal";
	toks[6] = NULL;

	while (*arg) {
		o = arg;
		switch (getsubopt(&arg, (char * const *)toks, &v)) {
		case 0:
			curp->wstop = 1;
			break;
		case 1:
		case 2:
			curp->wlevel = MANDOCLEVEL_WARNING;
			break;
		case 3:
			curp->wlevel = MANDOCLEVEL_ERROR;
			break;
		case 4:
			curp->wlevel = MANDOCLEVEL_UNSUPP;
			break;
		case 5:
			curp->wlevel = MANDOCLEVEL_BADARG;
			break;
		default:
			warnx("-W %s: Bad argument", o);
			return 0;
		}
	}

	return 1;
}

static void
mmsg(enum mandocerr t, enum mandoclevel lvl,
		const char *file, int line, int col, const char *msg)
{
	const char	*mparse_msg;

	fprintf(stderr, "%s: %s:", getprogname(),
	    file == NULL ? "<stdin>" : file);

	if (line)
		fprintf(stderr, "%d:%d:", line, col + 1);

	fprintf(stderr, " %s", mparse_strlevel(lvl));

	if (NULL != (mparse_msg = mparse_strerror(t)))
		fprintf(stderr, ": %s", mparse_msg);

	if (msg)
		fprintf(stderr, ": %s", msg);

	fputc('\n', stderr);
}

static pid_t
spawn_pager(struct tag_files *tag_files)
{
	const struct timespec timeout = { 0, 100000000 };  /* 0.1s */
#define MAX_PAGER_ARGS 16
	char		*argv[MAX_PAGER_ARGS];
	const char	*pager;
	char		*cp;
	size_t		 cmdlen;
	int		 argc;
	pid_t		 pager_pid;

	pager = getenv("MANPAGER");
	if (pager == NULL || *pager == '\0')
		pager = getenv("PAGER");
	if (pager == NULL || *pager == '\0')
		pager = "more -s";
	cp = mandoc_strdup(pager);

	/*
	 * Parse the pager command into words.
	 * Intentionally do not do anything fancy here.
	 */

	argc = 0;
	while (argc + 4 < MAX_PAGER_ARGS) {
		argv[argc++] = cp;
		cp = strchr(cp, ' ');
		if (cp == NULL)
			break;
		*cp++ = '\0';
		while (*cp == ' ')
			cp++;
		if (*cp == '\0')
			break;
	}

	/* For more(1) and less(1), use the tag file. */

	if ((cmdlen = strlen(argv[0])) >= 4) {
		cp = argv[0] + cmdlen - 4;
		if (strcmp(cp, "less") == 0 || strcmp(cp, "more") == 0) {
			argv[argc++] = mandoc_strdup("-T");
			argv[argc++] = tag_files->tfn;
		}
	}
	argv[argc++] = tag_files->ofn;
	argv[argc] = NULL;

	switch (pager_pid = fork()) {
	case -1:
		err((int)MANDOCLEVEL_SYSERR, "fork");
	case 0:
		break;
	default:
		(void)setpgid(pager_pid, 0);
		(void)tcsetpgrp(tag_files->ofd, pager_pid);
		if (pledge("stdio rpath tmppath tty proc", NULL) == -1)
			err((int)MANDOCLEVEL_SYSERR, "pledge");
		tag_files->pager_pid = pager_pid;
		return pager_pid;
	}

	/* The child process becomes the pager. */

	if (dup2(tag_files->ofd, STDOUT_FILENO) == -1)
		err((int)MANDOCLEVEL_SYSERR, "pager stdout");
	close(tag_files->ofd);
	close(tag_files->tfd);

	/* Do not start the pager before controlling the terminal. */

	while (tcgetpgrp(STDOUT_FILENO) != getpid())
		nanosleep(&timeout, NULL);

	execvp(argv[0], argv);
	err((int)MANDOCLEVEL_SYSERR, "exec %s", argv[0]);
}
@


1.189
log
@Silently ignore invalid -m input formats rather than erroring out.
As observed by Jan Stary <hans at stare dot cz>, this is useful such
that after 'alias man="man -m $HOME/man"', 'man -l foo.1' still works.
Simplify and shorten the description of -m, and use .Ic for macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.188 2017/03/03 14:21:41 schwarze Exp $ */
d565 2
a566 2
		fputs("usage: mandoc [-acfhkl] [-I os=name] "
		    "[-K encoding] [-mformat] [-O option]\n"
d570 3
a572 5
		fputs("usage: man [-acfhklw] [-C file] [-I os=name] "
		    "[-K encoding] [-M path] [-m path]\n"
		    "\t   [-O option=value] [-S subsection] [-s section] "
		    "[-T output] [-W level]\n"
		    "\t   [section] name ...\n", stderr);
d575 1
a575 1
		fputs("usage: whatis [-acfhklw] [-C file] "
d580 1
a580 1
		fputs("usage: apropos [-acfhklw] [-C file] "
@


1.188
log
@new -mdoc -Tmarkdown output mode; OK millert@@ reyk@@ tb@@;
thanks to reyk@@ and to Vsevolod at FreeBSD for suggesting it
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.187 2017/02/22 14:58:27 schwarze Exp $ */
d90 1
a90 1
static	int		  moptions(int *, char *);
d415 2
a416 2
	if (search.argmode == ARG_FILE && ! moptions(&options, auxpaths))
		return (int)MANDOCLEVEL_BADARG;
d892 1
a892 1
static int
d897 2
a898 2
		/* nothing to do */;
	else if (0 == strcmp(arg, "doc"))
d900 1
a900 3
	else if (0 == strcmp(arg, "andoc"))
		/* nothing to do */;
	else if (0 == strcmp(arg, "an"))
a901 6
	else {
		warnx("-m %s: Bad argument", arg);
		return 0;
	}

	return 1;
@


1.187
log
@Since SQLite is gone, we no longer need the "flock" pledge.
Patch from semarie@@, OK tb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.186 2017/02/16 10:55:57 schwarze Exp $ */
d64 1
d740 3
d927 2
@


1.186
log
@Fix rev. 1.183: -O syntax is different in default apropos(1) output
mode and in other output modes, so do not error out prematurely.
Also sort local variables in main() while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.185 2017/02/10 15:44:31 schwarze Exp $ */
d134 1
a134 1
	if (pledge("stdio rpath tmppath tty proc exec flock", NULL) == -1)
d290 1
a290 1
		if (pledge("stdio rpath flock", NULL) == -1)
@


1.185
log
@In -Ttree output mode, show the BROKEN node flag and
provide a -Onoval output option to show the unvalidated tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.184 2017/02/09 17:19:07 schwarze Exp $ */
d110 1
a111 1
	struct mansearch search;
d113 4
a116 3
	const char	*progname;
	char		*auxpaths;
	char		*defos;
a117 4
	struct manpage	*res, *resp;
	char		*conf_file, *defpaths;
	const char	*sec;
	const char	*thisarg;
d145 1
d224 1
a224 9
			search.outkey = optarg;
			while (optarg != NULL) {
				thisarg = optarg;
				if (manconf_output(&conf.output,
				    strsep(&optarg, ","), 0) == 0)
					continue;
				warnx("-O %s: Bad argument", thisarg);
				return (int)MANDOCLEVEL_BADARG;
			}
d266 15
@


1.184
log
@Be consistent in protecting __attribute__ attributes with __;
from Christos Zoulas <christos @@ NetBSD>.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.183 2017/01/27 13:47:17 schwarze Exp $ */
d715 2
a716 1
		mdoc_validate(man);
d739 2
a740 1
		man_validate(man);
@


1.183
log
@warn about invalid output options
and error out if they occur on the command line;
missing feature found in the TODO file
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.182 2017/01/09 17:49:55 schwarze Exp $ */
d97 1
a97 1
static	void		  usage(enum argmode) __attribute__((noreturn));
@


1.182
log
@Use stdout rather than stdin for controlling the terminal
such that "cat foo.mdoc | man -l" works.
Issue reported by Christian Neukirchen <chneukirchen at gmail dot com>
and also tested by him on Void Linux with both glibc and musl.
The patch makes sense to millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.181 2017/01/09 01:36:22 schwarze Exp $ */
d120 1
d227 8
a234 3
			while (optarg != NULL)
				manconf_output(&conf.output,
				    strsep(&optarg, ","));
@


1.181
log
@Warnings and errors that occur during mdoc_validate()
or during man_validate() have to affect the mandoc(1) EXIT STATUS.
Many thanks to <Yuri dot Pankov at gmail dot com> (illumos developer)
for reporting this regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.180 2016/09/18 15:45:50 schwarze Exp $ */
d504 1
a504 1
			tc_pgid = tcgetpgrp(STDIN_FILENO);
d507 1
a507 1
					(void)tcsetpgrp(STDIN_FILENO,
d520 1
a520 1
				(void)tcsetpgrp(STDIN_FILENO, pager_pid);
d1049 1
a1049 1
		(void)tcsetpgrp(STDIN_FILENO, pager_pid);
d1065 1
a1065 1
	while (tcgetpgrp(STDIN_FILENO) != getpid())
@


1.180
log
@We cannot use fputs(3) in passthrough() because the stdout stream
might be in stdio wide orientation due to prior formatting of an
unformatted manual in man -aTutf8 mode.  So for now, use fflush(3)
followed by unbuffered write(2) instead.  Fixes output corruption
on glibc discovered on Linux while testing a diff to fix a loosely
related bug reported by <jmates at ee dot washington dot edu>.

I detest the concept of stdio stream orientation.  One day, i will
rewrite term_ascii.c to always use narrow streams, even in UTF-8
output mode.  But that's too much work for today.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.179 2016/09/18 15:21:00 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2012, 2014-2016 Ingo Schwarze <schwarze@@openbsd.org>
d754 1
@


1.179
log
@Make sure an output device is allocated before calling terminal_sepline(),
fixing a NULL pointer access that happened when the first of multiple pages
shown was preformatted, as in "man -a groff troff".
Crash reported by <jmates at ee dot washington dot edu> on bugs@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.178 2016/08/09 15:08:15 schwarze Exp $ */
d793 1
d799 5
d811 1
a811 1
	while (getline(&line, &linesz, stream) != -1) {
d817 1
a817 1
				while (isspace((unsigned char)*cp))
d819 2
d828 3
a830 1
		if (fputs(cp, stdout)) {
d832 1
a832 1
			syscall = "fputs";
@


1.178
log
@fix printf("%s", NULL);
found while investigating an unrelated bug report from jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.177 2016/08/01 10:32:39 schwarze Exp $ */
d92 1
d439 3
a441 1
			if (argc > 1 && curp.outtype <= OUTT_UTF8)
d443 1
d699 2
a700 26
	/* If unset, allocate output dev now (if applicable). */

	if (curp->outdata == NULL) {
		switch (curp->outtype) {
		case OUTT_HTML:
			curp->outdata = html_alloc(curp->outopts);
			break;
		case OUTT_UTF8:
			curp->outdata = utf8_alloc(curp->outopts);
			break;
		case OUTT_LOCALE:
			curp->outdata = locale_alloc(curp->outopts);
			break;
		case OUTT_ASCII:
			curp->outdata = ascii_alloc(curp->outopts);
			break;
		case OUTT_PDF:
			curp->outdata = pdf_alloc(curp->outopts);
			break;
		case OUTT_PS:
			curp->outdata = ps_alloc(curp->outopts);
			break;
		default:
			break;
		}
	}
d753 27
@


1.177
log
@Remove the dependency on SQLite without loss of functionality.
Drop the obsolete names_check() now that we deleted MLINKS.
Run "doas makewhatis" after compiling and installing this.

Earlier version tested by jmc@@ and jturner@@;
"commit it all" deraadt@@   "commit and dodge" krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.176 2016/07/15 19:31:53 schwarze Exp $ */
d958 2
a959 1
	fprintf(stderr, "%s: %s:", getprogname(), file);
@


1.176
log
@To remove the const qualifier from a pointer to an object - either
because we know it is actually mutable or because we are passing
it to a function that doesn't accept a const object but won't
actually attempt to modify it - simply casting from (const type *)
to (type *) is legal C and clearly expresses the intent.
So get rid of the obfuscating UNCONST macro.
Basic idea discussed with guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.175 2016/07/15 18:49:53 schwarze Exp $ */
a319 3
		if (argc == 0)
			usage(search.argmode);

a326 1
		mansearch_setup(1);
d430 1
a430 1
			else if (resp->form & FORM_SRC) {
a478 1
		mansearch_setup(0);
d582 2
a583 1
	int		 form, globres;
@


1.175
log
@Fix previous: the mandocdb() prototype was already there, it just
hid among static functions, as noticed by tedu@@ (my bad).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.174 2016/07/15 18:02:32 schwarze Exp $ */
d930 1
a930 1
		switch (getsubopt(&arg, UNCONST(toks), &v)) {
@


1.174
log
@add missing prototypes, no code change;
noticed by Christos Zoulas with -Wmissing-prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.173 2016/07/08 22:27:58 schwarze Exp $ */
a88 1
int			  mandocdb(int, char**);
@


1.173
log
@ISO C99 7.19.2.5 doesn't like mixing putchar(3) and putwchar(3) on
the same stream, and actually, it fails spectacularly on glibc.
Portability issue pointed out by Svyatoslav Mishyn <juef at openmailbox
dot org> after testing on Void Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.172 2016/04/14 20:54:15 schwarze Exp $ */
d77 3
@


1.172
log
@Fix a process group race.

It could occasionally happen that the child process spawned less(1)
before the parent process passed the control of the terminal to the
child, and in that case, less(1) sometimes complained "Stopped (tty
output)".  Issue reported by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.171 2016/04/13 12:26:21 schwarze Exp $ */
d441 1
a441 1
				ascii_sepline(curp.outdata);
@


1.171
log
@Give manuals in purely numerical sections priority over manuals of
the same name in sections with an alphabetical suffix (on OpenBSD,
mostly 3p), restoring behaviour of the traditional BSD man(1) that
got lost in the switch to the mandoc-based implementation.

Issue reported by jsg@@, using an idea by mikeb@@ for the solution,
and at least afresh1@@ and jasper@@ also seem in favour of the direction.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.170 2016/01/16 21:56:32 florian Exp $ */
d35 1
d979 1
a1028 2
		/* Set pgrp in both parent and child to avoid racing exec. */
		(void)setpgid(0, 0);
d1045 6
@


1.170
log
@Unbreak reading from stdin after recent parse() restructuring.
OK schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.169 2016/01/08 02:53:09 schwarze Exp $ */
d115 2
a116 1
	size_t		 isec, i, sz;
a117 1
	char		 sec;
d353 1
a353 1
			best_prio = 10;
d369 3
a371 3
				isec = strcspn(res[i].file, "123456789");
				sec = res[i].file[isec];
				if ('\0' == sec)
d373 3
a375 1
				prio = sec_prios[sec - '1'];
d641 1
a641 1
	    {"1", "8", "6", "2", "3", "3p", "5", "7", "4", "9"};
@


1.169
log
@Simplify the mparse_open() interface.
Just return the file descriptor or -1 on error;
there is just one kind of error anyway.
Suggested by Christos Zoulas (NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.168 2016/01/08 02:13:35 schwarze Exp $ */
d678 1
a678 1
	assert(fd > 0);
@


1.168
log
@It was very surprising that a function called mparse_readfd()
closed the file descriptor passed to it after completing its work,
in particular considering the fact that it required its callers
to call open(2) or mparse_open() beforehand.

Change mparse_readfd() to not call close(2) and change the callers
to call close(2) afterwards, more or less bringing open and close
to the same level of the code and making review easier.  Note that
man.cgi(8) already did that, even though it was wrong in the past.

Small restructuring suggested by Christos Zoulas (NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.167 2015/12/15 17:36:19 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2012, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
a117 1
	enum mandoclevel rctmp;
d420 1
a420 5
		rctmp = mparse_open(curp.mp, &fd,
		    resp != NULL ? resp->file : *argv);
		if (rc < rctmp)
			rc = rctmp;

d439 2
a440 1
		}
@


1.167
log
@pledge(2) style:
Make sure to always use the idiom 'if (pledge("'
such that it can easily be searched for.
No functional change.
Requested by deraadt@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.166 2015/11/20 21:58:32 schwarze Exp $ */
d682 1
a682 1
	assert(fd >= -1);
d685 2
@


1.166
log
@Fix multiple issues regarding process group and signal mask handling
found by tb@@ and millert@@; parts of the code, in particular in tag.c,
by millert@@; OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.165 2015/11/14 23:56:41 schwarze Exp $ */
d275 3
a277 2
	if (!use_pager && pledge("stdio rpath flock", NULL) == -1)
		err((int)MANDOCLEVEL_SYSERR, "pledge");
d394 7
a400 3
	if (pledge(use_pager ? "stdio rpath tmppath tty proc exec" :
	    "stdio rpath", NULL) == -1)
		err((int)MANDOCLEVEL_SYSERR, "pledge");
@


1.165
log
@Fix an issue reported by deraadt@@:  When hitting Ctrl-Backslash (= SIGQUIT)
in the less(1) spawned by man(1), man(1) died uncleanly, leaving behind
its temp files, and killed less(1) uncleanly as well with SIGPIPE,
leaving the terminal in the wrong state.

Fix this by giving less(1) its own process group and handing it
control of the terminal, but in such a way that Ctrl-z (= SIGSTOP)
still works: In that case, let man(1) stop itself, too, and let it
continue the pager when it continues itself.

Joint work with millert@@ who contributed most of the expertise
required, and also most parts of the code.
OK deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.164 2015/11/07 17:58:52 schwarze Exp $ */
d124 1
a124 1
	int		 status;
d126 1
a126 1
	pid_t		 pager_pid;
d490 5
a494 1
		pager_pid = spawn_pager(tag_files);
d496 31
a526 3
			if (waitpid(pager_pid, &status, WUNTRACED) == -1) {
				if (errno == EINTR)
					continue;
d534 1
a534 10
			(void)tcsetpgrp(STDIN_FILENO, getpgid(0));
			kill(0, WSTOPSIG(status));
	
			/*
			 * I'm now stopped.
			 * When getting SIGCONT, continue here:
			 */

			(void)tcsetpgrp(STDIN_FILENO, pager_pid);
			kill(pager_pid, SIGCONT);
d1027 1
a1027 2
		if (tcsetpgrp(STDIN_FILENO, pager_pid) == -1)
			err((int)MANDOCLEVEL_SYSERR, "tcsetpgrp");
d1030 1
@


1.164
log
@Modernization, no functional change intended:
Use the POSIX function getline(3) rather than the slightly
dangerous BSD function fgetln(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.163 2015/11/06 17:23:50 schwarze Exp $ */
d27 1
d124 1
d126 1
d133 1
a133 1
	if (pledge("stdio rpath tmppath proc exec flock", NULL) == -1)
d393 1
a393 1
	if (pledge(use_pager ? "stdio rpath tmppath proc exec" :
d490 23
a512 1
		waitpid(spawn_pager(tag_files), NULL, 0);
d999 2
d1003 4
a1006 1
		if (pledge("stdio rpath tmppath", NULL) == -1)
@


1.163
log
@correct exit status on pledge(2) errors
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.162 2015/11/06 16:27:13 schwarze Exp $ */
d732 2
a733 3
	char		*line;
	size_t		 len, off;
	ssize_t		 nw;
d736 2
a737 1
	fflush(stdout);
d746 2
a747 1
	while ((line = fgetln(stream, &len)) != NULL) {
d750 1
a750 1
				if ( ! isspace((unsigned char)*line))
d752 2
a753 5
				while (len &&
				    isspace((unsigned char)*line)) {
					line++;
					len--;
				}
d755 2
a756 4
				if ((len == sizeof(synb) &&
				     ! strncmp(line, synb, len - 1)) ||
				    (len == sizeof(synr) &&
				     ! strncmp(line, synr, len - 1)))
d761 5
a765 7
		for (off = 0; off < len; off += nw)
			if ((nw = write(STDOUT_FILENO, line + off,
			    len - off)) == -1 || nw == 0) {
				fclose(stream);
				syscall = "write";
				goto fail;
			}
d770 1
a770 1
		syscall = "fgetln";
d775 1
d780 1
@


1.162
log
@Use getprogname(3) rather than __progname.
Suggested by Joerg@@ Sonnenberger (NetBSD).
Last year, deraadt@@ confirmed on tech@@ that this "has the potential
to be more portable", and micro-optimizing for speed is not relevant
here.  Also gets rid of one global variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.161 2015/10/22 21:53:49 schwarze Exp $ */
d131 1
a131 1
		err(1, "pledge");
d273 1
a273 1
		err(1, "pledge");
d392 1
a392 1
		err(1, "pledge");
d981 1
a981 1
			err(1, "pledge");
@


1.161
log
@move man(7) validation into the dedicated validation phase, too
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.160 2015/10/22 21:02:55 schwarze Exp $ */
a94 2
extern	char		 *__progname;

d108 1
d125 3
a127 2
	if (0 == strncmp(__progname, "mandocdb", 8) ||
	    0 == strncmp(__progname, "makewhatis", 10))
d142 1
a142 1
	if (strcmp(__progname, "man") == 0)
d144 1
a144 1
	else if (strncmp(__progname, "apropos", 7) == 0)
d146 1
a146 1
	else if (strncmp(__progname, "whatis", 6) == 0)
d148 1
a148 1
	else if (strncmp(__progname, "help", 4) == 0)
d289 1
a289 1
		if (*__progname == 'h') {
d910 1
a910 1
	fprintf(stderr, "%s: %s:", __progname, file);
@


1.160
log
@If no output device was allocated because no file wanted to produce output,
refrain from dereferencing a NULL pointer during final deallocation.
Fixing a recent regression reported by czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.159 2015/10/20 02:00:49 schwarze Exp $ */
d700 1
@


1.159
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.158 2015/10/19 19:51:06 schwarze Exp $ */
d449 17
a465 15
	switch (curp.outtype) {
	case OUTT_HTML:
		html_free(curp.outdata);
		break;
	case OUTT_UTF8:
	case OUTT_LOCALE:
	case OUTT_ASCII:
		ascii_free(curp.outdata);
		break;
	case OUTT_PDF:
	case OUTT_PS:
		pspdf_free(curp.outdata);
		break;
	default:
		break;
@


1.158
log
@Simplify, no functional change:
Delete the outmdoc, outman, and outfree function pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.157 2015/10/16 21:35:16 schwarze Exp $ */
d675 1
@


1.157
log
@Once apropos(1) or man(1) are done with database access, or if the
program was called as mandoc(1) in the first place, remove "flock"
from our pledge(2) before entering the parsers and formatters.
OK millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.156 2015/10/16 13:37:44 millert Exp $ */
a54 4
typedef	void		(*out_mdoc)(void *, const struct roff_man *);
typedef	void		(*out_man)(void *, const struct roff_man *);
typedef	void		(*out_free)(void *);

a71 3
	out_mdoc	  outmdoc;	/* mdoc output ptr */
	out_man		  outman;	/* man output ptr */
	out_free	  outfree;	/* free output ptr */
d449 16
a464 2
	if (curp.outfree)
		(*curp.outfree)(curp.outdata);
d643 1
a643 1
	if ( ! (curp->outman && curp->outmdoc)) {
a646 1
			curp->outfree = html_free;
a649 1
			curp->outfree = ascii_free;
a652 1
			curp->outfree = ascii_free;
a655 1
			curp->outfree = ascii_free;
a658 1
			curp->outfree = pspdf_free;
a661 1
			curp->outfree = pspdf_free;
d666 1
d668 7
d677 1
a677 2
			curp->outman = html_man;
			curp->outmdoc = html_mdoc;
d680 1
a680 2
			curp->outman = tree_man;
			curp->outmdoc = tree_mdoc;
d683 1
a683 2
			curp->outmdoc = man_mdoc;
			curp->outman = man_man;
d690 23
a712 2
			curp->outman = terminal_man;
			curp->outmdoc = terminal_mdoc;
a717 11

	mparse_result(curp->mp, &man, NULL);

	/* Execute the out device, if it exists. */

	if (man == NULL)
		return;
	if (curp->outmdoc != NULL && man->macroset == MACROSET_MDOC)
		(*curp->outmdoc)(curp->outdata, man);
	if (curp->outman != NULL && man->macroset == MACROSET_MAN)
		(*curp->outman)(curp->outdata, man);
@


1.156
log
@Implement real "flock" request and add it to userland programs that
use pledge and file locking.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.155 2015/10/13 22:57:49 schwarze Exp $ */
d396 4
@


1.155
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.154 2015/10/12 22:41:18 schwarze Exp $ */
d137 1
a137 1
	if (pledge("stdio rpath tmppath proc exec", NULL) == -1)
d279 1
a279 1
	if (!use_pager && pledge("stdio rpath", NULL) == -1)
@


1.154
log
@plegde(2) for apropos(1), help(1), man(1), mandoc(1), and whatis(1):
Always needed: stdio rpath (to open multiple files and for .so)
In addition after starting the pager: tmppath (to clean up the temp files)
In addition before starting the pager: proc exec
Looks good to deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.153 2015/10/12 00:07:27 schwarze Exp $ */
a72 1
	struct mchars	 *mchars;	/* character table */
d400 2
a401 3
	curp.mchars = mchars_alloc();
	curp.mp = mparse_alloc(options, curp.wlevel, mmsg,
	    curp.mchars, defos);
d455 1
a455 1
	mchars_free(curp.mchars);
d635 1
a635 2
			curp->outdata = html_alloc(curp->mchars,
			    curp->outopts);
d639 1
a639 2
			curp->outdata = utf8_alloc(curp->mchars,
			    curp->outopts);
d643 1
a643 2
			curp->outdata = locale_alloc(curp->mchars,
			    curp->outopts);
d647 1
a647 2
			curp->outdata = ascii_alloc(curp->mchars,
			    curp->outopts);
d651 1
a651 2
			curp->outdata = pdf_alloc(curp->mchars,
			    curp->outopts);
d655 1
a655 2
			curp->outdata = ps_alloc(curp->mchars,
			    curp->outopts);
@


1.153
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.152 2015/10/11 21:06:59 schwarze Exp $ */
d138 3
d280 3
d964 2
@


1.152
log
@Finally use __progname, err(3) and warn(3).
That's more readable and less error-prone than fumbling around
with argv[0], fprintf(3), strerror(3), perror(3), and exit(3).
It also shortens the code by 50 lines.

It's a bad idea to boycott good interfaces merely because standards
committees ignore them.  Instead, it's the job of the portable
distribution to provide compatibility modules for archaic systems
(like commercial Solaris) that still don't have them.  Actually,
the compat code for the portable distribution already exists and
will be committed right after this.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.151 2015/10/10 13:20:25 schwarze Exp $ */
a677 1
			/* FALLTHROUGH */
a678 1
			/* FALLTHROUGH */
a679 1
			/* FALLTHROUGH */
a680 1
			/* FALLTHROUGH */
a860 1
			/* FALLTHROUGH */
@


1.151
log
@Decide whether to use_pager as early as possible,
in preparation for pledge(2); no functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.150 2015/10/06 18:30:43 schwarze Exp $ */
d26 1
a26 1
#include <errno.h>
d103 2
a107 1
static	const char	 *progname;
d134 2
a135 9
	if (argc < 1)
		progname = "mandoc";
	else if ((progname = strrchr(argv[0], '/')) == NULL)
		progname = argv[0];
	else
		++progname;

	if (0 == strncmp(progname, "mandocdb", 8) ||
	    0 == strncmp(progname, "makewhatis", 10))
d147 1
a147 1
	if (strcmp(progname, "man") == 0)
d149 1
a149 1
	else if (strncmp(progname, "apropos", 7) == 0)
d151 1
a151 1
	else if (strncmp(progname, "whatis", 6) == 0)
d153 1
a153 1
	else if (strncmp(progname, "help", 4) == 0)
d194 1
a194 3
				fprintf(stderr,
				    "%s: -I %s: Bad argument\n",
				    progname, optarg);
d198 1
a198 3
				fprintf(stderr,
				    "%s: -I %s: Duplicate argument\n",
				    progname, optarg);
d291 1
a291 1
		if (*progname == 'h') {
d336 1
a336 3
				fprintf(stderr,
				    "%s: nothing appropriate\n",
				    progname);
d545 1
a545 2
		fprintf(stderr, "%s: %s: glob: %s\n",
		    progname, file, strerror(errno));
d554 2
a555 2
	fprintf(stderr, "%s: outdated mandoc.db lacks %s(%s) entry, run "
	    "makewhatis %s\n", progname, name, sec, paths->paths[ipath]);
d596 1
a596 3
			fprintf(stderr,
			    "%s: No entry for %s in the manual.\n",
			    progname, *argv);
d767 1
a767 2
	fprintf(stderr, "%s: %s: SYSERR: %s: %s",
	    progname, file, syscall, strerror(errno));
d785 1
a785 2
		fprintf(stderr, "%s: -K %s: Bad argument\n",
		    progname, arg);
d804 1
a804 2
		fprintf(stderr, "%s: -m %s: Bad argument\n",
		    progname, arg);
d837 1
a837 2
		fprintf(stderr, "%s: -T %s: Bad argument\n",
		    progname, arg);
d879 1
a879 2
			fprintf(stderr, "%s: -W %s: Bad argument\n",
			    progname, o);
d893 1
a893 1
	fprintf(stderr, "%s: %s:", progname, file);
d959 1
a959 3
		fprintf(stderr, "%s: fork: %s\n",
		    progname, strerror(errno));
		exit((int)MANDOCLEVEL_SYSERR);
d968 2
a969 4
	if (dup2(tag_files->ofd, STDOUT_FILENO) == -1) {
		fprintf(stderr, "pager: stdout: %s\n", strerror(errno));
		exit((int)MANDOCLEVEL_SYSERR);
	}
d973 1
a973 3
	fprintf(stderr, "%s: exec %s: %s\n",
	    progname, argv[0], strerror(errno));
	exit((int)MANDOCLEVEL_SYSERR);
@


1.150
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.149 2015/07/28 18:38:05 schwarze Exp $ */
d282 5
a405 3

	if (use_pager && ! isatty(STDOUT_FILENO))
		use_pager = 0;
@


1.149
log
@Remove the hack of scrolling forward and backward with +G1G that
many (jmc@@, millert@@, espie@@, deraadt@@) considered revolting.
Instead, when using a pager, since we are using a temporary file
for tags anyway, use another temporary file for the formatted
page(s), as suggested by millert@@ and similar to what the traditional
BSD man(1) did, except that we use only one single temporary output
file rather than one for each formatted manual page, such that
searching (both with / and :t) works across all the displayed files.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.148 2015/07/21 03:26:02 schwarze Exp $ */
d142 1
a142 1
		return(mandocdb(argc, argv));
d203 1
a203 1
				return((int)MANDOCLEVEL_BADARG);
d209 1
a209 1
				return((int)MANDOCLEVEL_BADARG);
d218 1
a218 1
				return((int)MANDOCLEVEL_BADARG);
d247 1
a247 1
				return((int)MANDOCLEVEL_BADARG);
d251 1
a251 1
				return((int)MANDOCLEVEL_BADARG);
d400 1
a400 1
		return((int)MANDOCLEVEL_BADARG);
d484 1
a484 1
	return((int)rc);
d562 1
a562 1
		return(0);
d576 1
a576 1
	return(1);
d801 1
a801 1
		return(0);
d803 1
a803 1
	return(1);
d821 1
a821 1
		return(0);
d824 1
a824 1
	return(1);
d855 1
a855 1
		return(0);
d858 1
a858 1
	return(1);
d898 1
a898 1
			return(0);
d902 1
a902 1
	return(1);
d983 1
a983 1
		return(pager_pid);
@


1.148
log
@When creation of the temporary tags file fails, call the pager
without the -T option, because otherwise the pager won't even start.
Fixing a bug reported by jca@@.

While here, shorten the code by two lines
and delete one internal interface function.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.147 2015/07/19 05:59:07 schwarze Exp $ */
a90 1
static	void		  handle_sigpipe(int);
d98 1
a98 1
static	pid_t		  spawn_pager(void);
d116 1
d130 1
a131 1
	pid_t		 pager_pid;  /* 0: don't use; 1: not yet spawned. */
d173 2
a174 1
	pager_pid = 1;
d188 1
a188 1
			pager_pid = 0;
d195 1
a195 1
			pager_pid = 0;
d271 1
a271 1
			pager_pid = 0;
d402 2
a403 2
	if (pager_pid == 1 && isatty(STDOUT_FILENO) == 0)
		pager_pid = 0;
d416 2
a417 2
		if (pager_pid == 1)
			pager_pid = spawn_pager();
d428 4
a431 2
			if (pager_pid == 1)
				pager_pid = spawn_pager();
d473 2
a474 3
	 * If a pager is attached, flush the pipe leading to it
	 * and signal end of file such that the user can browse
	 * to the end.  Then wait for the user to close the pager.
d477 1
a477 1
	if (pager_pid != 0 && pager_pid != 1) {
d480 1
a480 1
		waitpid(pager_pid, NULL, 0);
a926 7
static void
handle_sigpipe(int signum)
{

	exit((int)rc);
}

d928 1
a928 1
spawn_pager(void)
a934 1
	int		 fildes[2];
d963 1
a963 1
	/* Read all text right away and use the tag file. */
d965 1
a965 3
	for (;;) {
		if ((cmdlen = strlen(argv[0])) < 4)
			break;
d967 4
a970 8
		if (strcmp(cp, "less") && strcmp(cp, "more"))
			break;
		if ((cp = tag_init()) == NULL)
			break;
		argv[argc++] = mandoc_strdup("+G1G");
		argv[argc++] = mandoc_strdup("-T");
		argv[argc++] = cp;
		break;
d972 1
a974 6
	if (pipe(fildes) == -1) {
		fprintf(stderr, "%s: pipe: %s\n",
		    progname, strerror(errno));
		return(0);
	}

a982 8
		close(fildes[0]);
		if (dup2(fildes[1], STDOUT_FILENO) == -1) {
			fprintf(stderr, "%s: dup output: %s\n",
			    progname, strerror(errno));
			exit((int)MANDOCLEVEL_SYSERR);
		}
		close(fildes[1]);
		signal(SIGPIPE, handle_sigpipe);
d988 2
a989 4
	close(fildes[1]);
	if (dup2(fildes[0], STDIN_FILENO) == -1) {
		fprintf(stderr, "%s: dup input: %s\n",
		    progname, strerror(errno));
d992 2
a993 4
	close(fildes[0]);

	/* Hand over to the pager. */

@


1.147
log
@Do not fork and exec gunzip(1), just link with libz instead.
As discussed with deraadt@@, that's cleaner and will help tame(2).
Something like this was also suggested earlier by bapt at FreeBSD.
Minus 50 lines of code, deleting one interface function (mparse_wait),
no functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.146 2015/07/19 00:06:33 schwarze Exp $ */
d971 3
a973 1
	if ((cmdlen = strlen(argv[0])) >= 4) {
d975 8
a982 7
		if (strcmp(cp, "less") == 0 ||
		    strcmp(cp, "more") == 0) {
			tag_init();
			argv[argc++] = mandoc_strdup("+G1G");
			argv[argc++] = mandoc_strdup("-T");
			argv[argc++] = tag_filename();
		}
@


1.146
log
@If we aren't on a tty, clear the pager flag up front.
Just to clean up code structure, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.145 2015/07/18 05:46:52 schwarze Exp $ */
a438 4

			rctmp = mparse_wait(curp.mp);
			if (rc < rctmp)
				rc = rctmp;
@


1.145
log
@Insist that manual page file name extensions must begin with a digit,
lest pkg.conf(5) be shown when pkg(5) is asked for;
issue reported by Michael Reed <m dot reed at mykolab dot com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.144 2015/07/17 22:35:36 schwarze Exp $ */
d401 3
d415 1
a415 1
		if (pager_pid == 1 && isatty(STDOUT_FILENO))
d427 1
a427 1
			if (pager_pid == 1 && isatty(STDOUT_FILENO))
@


1.144
log
@Initial, still somewhat experimental implementation to leverage
less(1) -T and :t ctags(1)-like functionality to jump to the
definitions of various terms inside manual pages.
To be polished in the tree, so bear with me and report issues.

Technically, if less(1) is used as a pager, information is collected
by the mdoc(7) terminal formatter, first stored using the ohash
library, then ultimately written to a temporary file which is passed
to less via -T.  No change intended for other output formatters or
when running without a pager.

Based on an idea from Kristaps using feedback from many, in particular
phessler@@ nicm@@ millert@@ halex@@ doug@@ kspillner@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.143 2015/04/29 11:03:48 schwarze Exp $ */
d550 1
a550 1
	mandoc_asprintf(&file, "%s/man%s/%s.*",
@


1.143
log
@Improve the error message in case somebody has configured an invalid PAGER.
Suggested by Lorenzo Beretta <lory dot fulgi at infinito dot it>.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.142 2015/04/20 09:54:34 schwarze Exp $ */
d41 1
d478 1
d480 1
d940 1
d945 39
a1017 26

	pager = getenv("MANPAGER");
	if (pager == NULL || *pager == '\0')
		pager = getenv("PAGER");
	if (pager == NULL || *pager == '\0')
		pager = "more -s";
	cp = mandoc_strdup(pager);

	/*
	 * Parse the pager command into words.
	 * Intentionally do not do anything fancy here.
	 */

	argc = 0;
	while (argc + 1 < MAX_PAGER_ARGS) {
		argv[argc++] = cp;
		cp = strchr(cp, ' ');
		if (cp == NULL)
			break;
		*cp++ = '\0';
		while (*cp == ' ')
			cp++;
		if (*cp == '\0')
			break;
	}
	argv[argc] = NULL;
@


1.142
log
@Fix previous:  Don't let man(1) warn twice about non-existant names.
Again noticed by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.141 2015/04/19 15:10:04 schwarze Exp $ */
d1005 2
a1006 2
	fprintf(stderr, "%s: exec: %s\n",
	    progname, strerror(errno));
@


1.141
log
@If apropos(1) finds no match, print "nothing appropriate" to stderr
similar to what the old apropos did.
Requested by and OK deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.140 2015/04/18 16:34:03 schwarze Exp $ */
d334 9
a342 3
		if (sz == 0 && search.argmode == ARG_NAME)
			fs_search(&search, &conf.manpath,
			    argc, argv, &res, &sz);
a344 2
			fprintf(stderr, "%s: nothing appropriate\n",
			    progname);
@


1.140
log
@Profit from the unified struct roff_man and reduce the number of
arguments of mparse_result() by one.  No functional change.
Written on the ICE Bruxelles-Koeln on the way back from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.139 2015/04/18 16:04:40 schwarze Exp $ */
d339 2
@


1.139
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.138 2015/04/16 16:35:02 schwarze Exp $ */
a609 1
	struct roff_man	 *mdoc;
d697 1
a697 1
	mparse_result(curp->mp, &mdoc, &man, NULL);
d701 5
a705 1
	if (man && curp->outman)
a706 2
	if (mdoc && curp->outmdoc)
		(*curp->outmdoc)(curp->outdata, mdoc);
@


1.138
log
@shorten "outdated mandoc.db" warning message; requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.137 2015/04/03 08:45:27 schwarze Exp $ */
d54 2
a55 2
typedef	void		(*out_mdoc)(void *, const struct mdoc *);
typedef	void		(*out_man)(void *, const struct man *);
d610 2
a611 2
	struct mdoc	 *mdoc;
	struct man	 *man;
@


1.137
log
@No need to hardcode /usr/bin/ as the path to more(1); helps portability.
We don't hardcode the paths to gunzip(1) and cmp(1) either.
Discussed with ajacoutot@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.136 2015/04/02 21:03:18 schwarze Exp $ */
d555 2
a556 4
	fprintf(stderr, "%s: outdated mandoc.db lacks %s(%s) entry,\n"
	    "     consider running  # makewhatis %s\n",
	    progname, name, sec, paths->paths[ipath]);

@


1.136
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.135 2015/03/27 21:17:16 schwarze Exp $ */
d975 1
a975 1
		pager = "/usr/bin/more -s";
@


1.135
log
@Actually use the new man.conf(5) "output" directive.
Additional functionality, yet minus 45 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.134 2015/03/27 17:36:56 schwarze Exp $ */
d36 1
d38 1
a38 2
#include "mandoc_aux.h"
#include "main.h"
d41 1
@


1.134
log
@Parse the new man.conf(5) "output" directive.
The next step will be to actually use the parsed data.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.133 2015/03/27 16:35:57 schwarze Exp $ */
d79 1
a79 1
	char		  outopts[BUFSIZ]; /* buf of output opts */
d121 1
a121 1
	int		 prio, best_prio, synopsis_only;
d167 1
a172 1
	synopsis_only = 0;
d191 1
a191 2
			(void)strlcat(curp.outopts, "synopsis,", BUFSIZ);
			synopsis_only = 1;
d232 3
a234 2
			(void)strlcat(curp.outopts, optarg, BUFSIZ);
			(void)strlcat(curp.outopts, ",", BUFSIZ);
d426 2
a427 1
				passthrough(resp->file, fd, synopsis_only);
@


1.133
log
@Modernize documentation by inserting blanks between option letters
and option arguments, except for -m because "-m an" and "-m andoc"
look just too weird.  Of course, the traditional form without the
blank will continue to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.132 2015/03/17 13:35:04 schwarze Exp $ */
d11 1
a11 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d13 1
a13 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d41 1
a41 1
#include "manpath.h"
d112 1
a114 1
	struct manpaths	 paths;
d144 1
a144 1
	memset(&paths, 0, sizeof(struct manpaths));
d327 1
a327 1
		manpath_parse(&paths, conf_file, defpaths, auxpaths);
d329 2
a330 1
		if( ! mansearch(&search, &paths, argc, argv, &res, &sz))
d334 2
a335 1
			fs_search(&search, &paths, argc, argv, &res, &sz);
d423 1
a423 1
				chdir(paths.paths[resp->ipath]);
d454 1
a454 1
		manpath_free(&paths);
@


1.132
log
@Simplify: Now that rc is global anyway, no need to pass it around
as an argument.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.131 2015/03/17 07:32:21 schwarze Exp $ */
d479 3
a481 3
		fputs("usage: mandoc [-acfhkl] [-Ios=name] "
		    "[-Kencoding] [-mformat] [-Ooption]\n"
		    "\t      [-Toutput] [-Wlevel] [file ...]\n", stderr);
@


1.131
log
@When the user exits the pager before the pager has drained all input
from man(1), man(1) dies from SIGPIPE.  Exiting man(1) is fine in this
case, generating more output would be pointless, but without handling
SIGPIPE, the exit code from man(1) was wrong and csh(1) printed an
ugly message "Broken pipe".  Fix this by handling SIGPIPE explicitly.
Issue noticed by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.130 2015/03/10 13:48:57 schwarze Exp $ */
d95 2
a96 3
static	void		  parse(struct curparse *, int,
				const char *, enum mandoclevel *);
static	enum mandoclevel  passthrough(const char *, int, int);
d404 1
a404 1
		parse(&curp, STDIN_FILENO, "<stdin>", &rc);
d418 1
a418 1
				parse(&curp, fd, *argv, &rc);
d422 3
a424 7
				parse(&curp, fd, resp->file, &rc);
			} else {
				rctmp = passthrough(resp->file, fd,
				    synopsis_only);
				if (rc < rctmp)
					rc = rctmp;
			}
d605 1
a605 2
parse(struct curparse *curp, int fd, const char *file,
	enum mandoclevel *level)
d607 1
a607 1
	enum mandoclevel  rc;
d616 3
a618 1
	rc = mparse_readfd(curp->mp, fd, file);
d625 2
a626 2
	if (MANDOCLEVEL_OK != rc && curp->wstop)
		goto cleanup;
a703 4

cleanup:
	if (*level < rc)
		*level = rc;
d706 1
a706 1
static enum mandoclevel
d764 1
a764 1
	return(MANDOCLEVEL_OK);
d769 2
a770 1
	return(MANDOCLEVEL_SYSERR);
d918 1
a918 1
	exit(rc);
@


1.130
log
@We can keep track of the pager PID without additional complexity.
No functional change for now, but more robust in case anybody should
ever add additional child processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.129 2015/03/10 03:00:48 schwarze Exp $ */
d29 1
d89 1
d107 1
d124 1
a124 1
	enum mandoclevel rc, rctmp;
d921 7
d960 1
@


1.129
log
@Fix a regression caused in rev. 1.118, reported by kristaps@@:

When using a pager and the first manual shown is gzip'ed,
the gunzip(1) process ended up as a child of the pager process
such that the man(1) process couldn't wait for it, preventing
proper display of the manual.

Solve this by making the pager a child of the man(1) process
(instead of the other way round), which requires being a bit
more careful about properly closing file descriptors after use
and waiting for the pager before exiting man(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.128 2015/03/09 21:30:27 schwarze Exp $ */
d96 1
a96 1
static	void		  spawn_pager(void);
a124 1
	int		 use_pager;
d127 1
d168 1
a168 1
	use_pager = 1;
d183 1
a183 1
			use_pager = 0;
d191 1
a191 1
			use_pager = 0;
d266 1
a266 1
			use_pager = 0;
d400 2
a401 2
		if (use_pager && isatty(STDOUT_FILENO))
			spawn_pager();
d412 2
a413 3
			if (use_pager && isatty(STDOUT_FILENO))
				spawn_pager();
			use_pager = 0;
d462 3
a464 3
	 * Flush the output and signal end of file.
	 * If a pager is attached, it allows browsing to the end.
	 * Otherwise, it does no harm, we are about to exit anyway.
d467 4
a470 8
	fclose(stdout);

	/*
	 * If we spawned a pager, wait for the user to close it.
	 * Otherwise, this call fails with no adverse effect.
	 */

	wait(NULL);
d918 1
a918 1
static void
d927 1
d932 1
a932 1
		return;
d935 1
a935 1
	switch (fork()) {
d950 1
a950 1
		return;
@


1.128
log
@Explicitly cast when assigning from char * to unsigned char * and vice versa.
For example, gcc 4.7 wants this with -Wall.  Patch from kristaps@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.127 2015/02/27 16:00:54 schwarze Exp $ */
d22 1
d462 15
d945 2
d953 1
a954 2
	default:
		break;
d957 1
a957 1
	/* The original process becomes the pager. */
d965 1
@


1.127
log
@When man(1) and apropos(1) look for a file man1/foo.1 but it's unavailable,
fall back to glob(man1/foo.*), which is more like what old man(1) did.
Do this both for file names from the database and for fs_lookup().
This is relevant because some ports install files like man1/xset.1x.
Regression reported by patrick keshishian <pkeshish at gmail dot com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.126 2015/02/16 16:18:02 schwarze Exp $ */
d296 1
a296 1
		    ((uc = argv[0]) != NULL) &&
d300 1
a300 1
			search.sec = uc;
@


1.126
log
@Delete the -V option.  It serves no purpose but keeps confusing people.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.125 2015/02/10 08:05:07 schwarze Exp $ */
d27 1
d500 1
d503 1
a503 1
	int		 form;
d505 1
d508 1
a508 2
	if (access(file, R_OK) != -1) {
		form = FORM_SRC;
a509 1
	}
d523 1
a523 2
		if (access(file, R_OK) != -1) {
			form = FORM_SRC;
a524 1
		}
d527 13
a539 1
	return(0);
@


1.125
log
@trim trailing white space, no code change;
from Svyatoslav Mishyn <juef at openmailboxd dot org>, Crux Linux
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.124 2015/02/07 06:27:53 schwarze Exp $ */
a96 1
static	void		  version(void) __attribute__((noreturn));
a248 3
		case 'V':
			version();
			/* NOTREACHED */
a463 8
version(void)
{

	printf("mandoc %s\n", VERSION);
	exit((int)MANDOCLEVEL_OK);
}

static void
d469 1
a469 1
		fputs("usage: mandoc [-acfhklV] [-Ios=name] "
d474 1
a474 1
		fputs("usage: man [-acfhklVw] [-C file] [-I os=name] "
d481 1
a481 1
		fputs("usage: whatis [-acfhklVw] [-C file] "
d486 1
a486 1
		fputs("usage: apropos [-acfhklVw] [-C file] "
@


1.124
log
@be more careful about argc == 0
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.123 2015/01/20 21:12:46 schwarze Exp $ */
d546 1
a546 1
	
@


1.123
log
@Split the -Werror message level into -Werror (broken manual, probably
using mandoc is better than using groff) and -Wunsupp (manual using
unsupported low-level roff(7) feature, probably using groff is better
than using mandoc).  Once this feature is complete, it is intended
to help porting, making the decision whether to USE_GROFF easier.

As a first step, distinguish four classes of roff(7) requests:
1. Supported (currently 24 requests)
2. Currently ignored because unimportant (120)  ->  no message
3. Ignored for good because insecure (14)  ->  -Werror
4. Currently unsupported (68)  ->  these trigger the new -Wunsupp messages
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.122 2015/01/16 21:12:01 schwarze Exp $ */
d128 3
a130 2
	progname = strrchr(argv[0], '/');
	if (progname == NULL)
d281 4
a284 2
	argc -= optind;
	argv += optind;
d401 1
a401 1
	if (argc == 0) {
d407 1
a407 1
	while (argc) {
@


1.122
log
@Let man(1) show manuals for the current architecture by default,
and support the MACHINE environment variable as documented in man(1).
Missing feature reported by pascal@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.121 2015/01/15 04:26:06 schwarze Exp $ */
d843 1
a843 1
	const char	*toks[6];
d849 3
a851 2
	toks[4] = "fatal";
	toks[5] = NULL;
d868 3
@


1.121
log
@Fatal errors no longer exist.
If a file can be opened, mandoc will produce some output;
at worst, the output may be almost empty.
Simplifies error handling and frees a message type for future use.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.120 2015/01/14 21:27:01 schwarze Exp $ */
d21 1
d304 4
@


1.120
log
@if earlier files set a non-zero exit status,
do not allow later files to reset it to zero
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.119 2015/01/13 23:16:12 schwarze Exp $ */
d161 1
a161 1
	curp.wlevel  = MANDOCLEVEL_FATAL;
a602 5
	/* Stop immediately if the parse has failed. */

	if (MANDOCLEVEL_FATAL <= rc)
		goto cleanup;

d862 1
a862 1
			curp->wlevel = MANDOCLEVEL_FATAL;
@


1.119
log
@Be developer-friendly, 'cause OpenBSD devs like to:
cd /usr/src/share/man/man4; vi newdev.4 Makefile; make install; man newdev

When a manual is missing from an outdated database, let man(1)
show it anyway, using a KISS file system lookup as a fallback.
Requested by deraadt@@.

87 new lines of code doesn't seem too much bloat to me.

Of course, keeping your mandoc.db(5) files up to date with makewhatis(8)
or weekly(8) is still required for apropos(1) to find your new pages.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.118 2015/01/13 13:22:13 schwarze Exp $ */
d119 1
a119 1
	enum mandoclevel rc;
d400 1
a400 1
		rc = mparse_open(curp.mp, &fd,
d402 2
d416 2
a417 2
			} else
				rc = passthrough(resp->file, fd,
d419 3
d423 3
a425 2
			if (mparse_wait(curp.mp) != MANDOCLEVEL_OK)
				rc = MANDOCLEVEL_SYSERR;
@


1.118
log
@do not spawn a pager when there is no output; issue pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.117 2015/01/01 13:18:23 schwarze Exp $ */
d78 7
d323 3
a325 1
		resp = res;
a327 3
			if (search.argmode == ARG_NAME)
				fprintf(stderr, "%s: No entry for %s "
				    "in the manual.\n", progname, argv[0]);
d346 1
d490 90
@


1.117
log
@If man(1) only has one single argument, always interpret it as a name,
never as a section.  Who would have thought that people call their
manual pages 7z(1), 9c(1), 9p(1), and 9p(3)...
Patch from Sebastien Marie <semarie dash openbsd at latrappe dot fr>.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.116 2014/12/31 16:50:54 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012, 2014 Ingo Schwarze <schwarze@@openbsd.org>
a375 3
	if (use_pager && isatty(STDOUT_FILENO))
		spawn_pager();

d386 3
a388 1
	if (argc == 0)
d390 1
d393 10
a402 4
		if (resp != NULL) {
			rc = mparse_open(curp.mp, &fd, resp->file);
			if (fd == -1)
				/* nothing */;
d410 6
a415 5
			resp++;
		} else {
			rc = mparse_open(curp.mp, &fd, *argv++);
			if (fd != -1)
				parse(&curp, fd, argv[-1], &rc);
a417 3
		if (mparse_wait(curp.mp) != MANDOCLEVEL_OK)
			rc = MANDOCLEVEL_SYSERR;

d421 6
a426 2
		if (--argc && curp.outtype <= OUTT_UTF8)
			ascii_sepline(curp.outdata);
d590 1
a590 4
 cleanup:

	mparse_reset(curp->mp);

@


1.116
log
@When showing more than one formatted manual page, insert horizontal lines
between pages.  Suggested by Theo Buehler <theo at math dot ethz dot ch>.
Even in UTF-8 output mode, do not use fancy line drawing characters such
that you can easily use /^--- to skip to the next manual in your pager.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.115 2014/12/21 14:49:00 schwarze Exp $ */
d287 2
a288 1
		} else if (((uc = argv[0]) != NULL) &&
@


1.115
log
@Use -m for macro set selection in mandoc(1) mode only, not in man(1)
and apropos(1) mode.  While here, put a space character between
options and option arguments in error messages.
Both reported by Alessandro DE LAURENZIS <just22 dot adl at gmail dot com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.114 2014/12/18 20:45:50 jmc Exp $ */
d415 3
a417 1
		argc--;
d601 2
@


1.114
log
@update usage() and the list of non-standard (i.e. non-posix) options;
ok schwarze
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.113 2014/12/17 18:45:00 schwarze Exp $ */
d187 1
a187 1
				    "%s: -I%s: Bad argument\n",
d193 1
a193 1
				    "%s: -I%s: Duplicate argument\n",
d372 1
a372 1
	if ( ! moptions(&options, auxpaths))
d664 1
a664 1
		fprintf(stderr, "%s: -K%s: Bad argument\n",
d684 1
a684 1
		fprintf(stderr, "%s: -m%s: Bad argument\n",
d718 1
a718 1
		fprintf(stderr, "%s: -T%s: Bad argument\n",
d757 1
a757 1
			fprintf(stderr, "%s: -W%s: Bad argument\n",
@


1.113
log
@Be a bit more lenient in what to accept for section names given
as the first man(1) command line argument without -s:
Accept digits like "1", "2"; digit+letter like "3p", "1X"; and "n".
Issue reported by Svyatoslav Mishyn <juef at openmailbox dot org> (Crux Linux).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.112 2014/12/15 18:04:32 schwarze Exp $ */
d454 4
a457 2
		fputs("usage: man [-acfhklVw] [-C file] "
		    "[-M path] [-m path] [-S arch] [-s section]\n"
@


1.112
log
@Let "man n open" do the same as "man -s n open" again, that is,
show the open(n) Tcl manual, as documented in man(1).  Issue reported
by Svyatoslav Mishyn <juef at openmailbox dot org> (Crux Linux).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.111 2014/12/11 19:50:04 schwarze Exp $ */
d106 1
d287 5
a291 5
		} else if (argv[0] != NULL && (
		    (isdigit((unsigned char)argv[0][0]) &&
		     (argv[0][1] == '\0' || !strcmp(argv[0], "3p"))) ||
		    (argv[0][0] == 'n' && argv[0][1] == '\0'))) {
			search.sec = argv[0];
@


1.111
log
@slightly reshuffle some code to reduce the diff with portable;
no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.110 2014/12/05 21:55:02 schwarze Exp $ */
d286 4
a289 3
		} else if (argv[0] != NULL &&
		    isdigit((unsigned char)argv[0][0]) &&
		    (argv[0][1] == '\0' || !strcmp(argv[0], "3p"))) {
@


1.110
log
@implement help(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.109 2014/12/02 11:31:46 schwarze Exp $ */
d104 1
a104 1
	char		*conf_file, *defpaths, *auxpaths;
d107 1
d109 1
a109 1
	int		 prio, best_prio;
a115 1
	int		 synopsis_only;
d132 2
a133 1
	conf_file = defpaths = auxpaths = NULL;
@


1.109
log
@Switch the default output mode from -Tascii to -Tlocale.
This doesn't change anything unless LC_CTYPE is set,
but it helps when running with LC_TYPE=something.UTF-8.

OK tedu@@  and earlier positive feedback from:
bentley@@ deraadt@@ naddy@@ stsp@@  uqs@@freebsd wiz@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.108 2014/11/26 21:40:11 schwarze Exp $ */
d93 2
d143 2
d274 18
a291 9
	/* Quirk for a man(1) section argument without -s. */

	if (search.argmode == ARG_NAME &&
	    argv[0] != NULL &&
	    isdigit((unsigned char)argv[0][0]) &&
	    (argv[0][1] == '\0' || !strcmp(argv[0], "3p"))) {
		search.sec = argv[0];
		argv++;
		argc--;
@


1.108
log
@Simplify the mparse_open()/mparse_wait() interface.
Don't bother the user with the PID of the child process,
store it inside the opaque mparse handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.107 2014/11/11 19:03:10 schwarze Exp $ */
d147 1
a147 1
	curp.outtype = OUTT_ASCII;
@


1.107
log
@In man(1) mode without -a, stop searching after the first manual tree
that contained at least one match in order to not prefer mdoc(1) from
ports over mdoc(7).  As a bonus, this results in a speedup.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.106 2014/11/11 02:43:11 schwarze Exp $ */
a109 1
	pid_t		 child_pid;
d377 1
a377 2
			rc = mparse_open(curp.mp, &fd, resp->file,
			    &child_pid);
d389 1
a389 2
			rc = mparse_open(curp.mp, &fd, *argv++,
			    &child_pid);
d394 1
a394 2
		if (child_pid &&
		    mparse_wait(curp.mp, child_pid) != MANDOCLEVEL_OK)
@


1.106
log
@Let -h imply -c (that is, not use the pager).
Usually, -h output is short, so the pager is just a nuisance.
Also, traditional man(1) does not use a pager for -h.
Triggered by a remark of deraadt@@ on ICB.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.105 2014/11/11 02:08:57 schwarze Exp $ */
d289 4
@


1.105
log
@implement -h (synopsis only) for preformatted (cat) pages;
requested by tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.104 2014/10/30 15:05:05 jmc Exp $ */
d176 1
@


1.104
log
@mandoc.1: fix a macro error in previous
main.c: add -K to usage() and wrap nicely

ok schwarze
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.103 2014/10/30 00:05:02 schwarze Exp $ */
d85 1
a85 1
static	enum mandoclevel  passthrough(const char *, int);
d114 1
d155 1
d175 1
d382 2
a383 1
				rc = passthrough(resp->file, fd);
d569 1
a569 1
passthrough(const char *file, int fd)
d571 4
a574 1
	char		 buf[BUFSIZ];
d576 10
a585 1
	ssize_t		 nr, nw, off;
d587 24
a610 5
	while ((nr = read(fd, buf, BUFSIZ)) != -1 && nr != 0)
		for (off = 0; off < nr; off += nw)
			if ((nw = write(STDOUT_FILENO, buf + off,
			    (size_t)(nr - off))) == -1 || nw == 0) {
				close(fd);
d614 1
d616 5
a620 1
	close(fd);
d622 3
a624 2
	if (nr == 0)
		return(MANDOCLEVEL_OK);
a625 1
	syscall = "read";
@


1.103
log
@support UTF-8 and ISO-8859-1 input by integrating modified parts
of kristaps@@' version of the preconv(1) utility into mandoc(1);
positive feedback from bentley@@ and no concern raised when shown on tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.102 2014/10/28 17:35:42 schwarze Exp $ */
d429 2
a430 2
		    "[-mformat] [-Ooption] [-Toutput] [-Wlevel]\n"
		    "\t      [file ...]\n", stderr);
@


1.102
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.101 2014/10/18 15:46:16 schwarze Exp $ */
d78 1
d149 1
a149 1
	options = MPARSE_SO;
d156 2
a157 1
	while (-1 != (c = getopt(argc, argv, "aC:cfhI:iklM:m:O:S:s:T:VW:w"))) {
d193 4
d590 20
@


1.101
log
@plug file descriptor leaks on read or write failure;
hinted at by Steffen Nurpmeso <sdaoden at yandex dot com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.100 2014/09/03 23:20:33 schwarze Exp $ */
a59 1
	OUTT_XHTML,	/* -Txhtml */
d67 1
d349 3
a351 1
	curp.mp = mparse_alloc(options, curp.wlevel, mmsg, defos);
d393 2
a394 2
	if (curp.mp)
		mparse_free(curp.mp);
a476 4
		case OUTT_XHTML:
			curp->outdata = xhtml_alloc(curp->outopts);
			curp->outfree = html_free;
			break;
d478 2
a479 1
			curp->outdata = html_alloc(curp->outopts);
d483 2
a484 1
			curp->outdata = utf8_alloc(curp->outopts);
d488 2
a489 1
			curp->outdata = locale_alloc(curp->outopts);
d493 2
a494 1
			curp->outdata = ascii_alloc(curp->outopts);
d498 2
a499 1
			curp->outdata = pdf_alloc(curp->outopts);
d503 2
a504 1
			curp->outdata = ps_alloc(curp->outopts);
a512 2
			/* FALLTHROUGH */
		case OUTT_XHTML:
d627 1
a627 1
		curp->outtype = OUTT_XHTML;
@


1.100
log
@Add *.gz support to apropos(1) -a, manm(1), and even mandoc(1).
Implemented by moving the zip code from makewhatis(8) to the parser lib.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.99 2014/09/03 18:08:26 schwarze Exp $ */
d567 1
d572 3
a574 2
        if (nr == 0) {
		close(fd);
a575 1
        }
@


1.99
log
@If a manual page is installed gzip(1)ed, let makewhatis(8) take
note in mandoc.db(5), such that man(1) -w and apropos(1) -w can
report the correct filename.
This is a prerequisite for letting apropos -a and man support
gzip'ed manuals in the future, which doesn't work yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.98 2014/09/03 05:17:08 schwarze Exp $ */
d84 1
a84 1
static	enum mandoclevel  passthrough(const char *);
d109 2
d362 5
a366 1
			if (resp->form & FORM_SRC) {
d369 1
a369 1
				parse(&curp, -1, resp->file, &rc);
d371 1
a371 1
				rc = passthrough(resp->file);
d373 11
a383 2
		} else
			parse(&curp, -1, *argv++, &rc);
d557 1
a557 1
passthrough(const char *file)
a561 7
	int		 fd;

	fd = open(file, O_RDONLY);
	if (fd == -1) {
		syscall = "open";
		goto fail;
	}
@


1.98
log
@Implement the traditional -h option for man(1): show the SYNOPSIS only.
As usual, we get mandoc -h and apropos -h for free.
Try stuff like "apropos -h In=dirent" or "apropos -h Fa=timespec".

Only useful for terminal output, so -Tps, -Tpdf, -Thtml ignore -h for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.97 2014/09/01 22:45:11 schwarze Exp $ */
d360 1
a360 1
			if (resp->form) {
@


1.97
log
@In man(1) mode, change to the right directory before starting the parser,
just like traditional man(1) does, such that .so links have a chance to
work.  After this point, we don't need the current directory for anything
else before exit, so we don't need to worry about getting back and we can
safely ignore failure.
This lets man(1) find more Xenocara manuals, but not all of them yet.
Other issues remain that need to be fixed, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.96 2014/08/30 18:04:52 schwarze Exp $ */
d153 1
a153 1
	while (-1 != (c = getopt(argc, argv, "aC:cfI:iklM:m:O:S:s:T:VW:w"))) {
d167 4
d405 1
a405 1
		fputs("usage: mandoc [-acfklV] [-Ios=name] "
d415 1
a415 1
		fputs("usage: whatis [-acfklVw] [-C file] "
d420 1
a420 1
		fputs("usage: apropos [-acfklVw] [-C file] "
@


1.96
log
@Introduce a man(1) -l option as an alias for mandoc -a.
Basically, this does the same as man -l in Linux man-db.
The point is that now all functionality of the combined tool
is reachable from the man(1) command name:
apropos = man -k, whatis = man -f, mandoc = man -cl.

Originally suggested by Carsten dot Kunze at arcor dot de,
current maintainer of the Heirloom Documentation Tools.

While here, add various missing information to the usage()
and to the manuals.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.95 2014/08/27 00:06:08 schwarze Exp $ */
a279 1
		manpath_free(&paths);
d356 3
a358 1
			if (resp->form)
d360 1
a360 1
			else
d377 1
@


1.95
log
@Add an implementation of man(1) into the /usr/bin/mandoc binary and
provide a unified set of command line options for mandoc(1), man(1),
apropos(1), and whatis(1), each option doing the same for all four.
Not adding any completely new options, only extending exiting ones
from one tool to the others.  New options are:
* apropos & whatis -acfkw  (in the past, these were man(1) only)
* apropos & whatis -a -IOTW  (in the past, mandoc(1) only)
* mandoc -ac  (in the past, man(1) only)
* man -IOTW  (in the past, mandoc(1) only)

Before we can decide whether or not we want to replace src/usr.bin/man
with this implementation, considerable bugfixing, testing, and
performance measurements are needed, which i'd rather do in the tree
than outside.  Note that these bugs only affect the new man(1) mode,
existing mandoc(1), apropos(1), and whatis(1) is fine.

The new functionality in mandoc(1), apropos(1), and whatis(1)
is fully enabled.  To play with the new man(1), you can try:
# mv /usr/bin/man /usr/bin/oman
# ln -s /usr/bin/mandoc /usr/bin/man

Positive feedback about the general direction from sthen@@ and jmc@@,
and deraadt@@ is not against it.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d153 1
a153 1
	while (-1 != (c = getopt(argc, argv, "aC:cfI:ikM:m:O:S:s:T:VW:w"))) {
d188 4
d399 2
a400 2
		fputs("usage: mandoc [-V] [-Ios=name] [-mformat]"
		    " [-Ooption] [-Toutput] [-Wlevel]\n"
d404 1
a404 1
		fputs("usage: man [-acfhkVw] [-C file] "
d409 3
a411 2
		fputs("usage: whatis [-V] [-C file] [-M path] [-m path] "
		    "[-S arch] [-s section] name ...\n", stderr);
d414 2
a415 2
		fputs("usage: apropos [-V] [-C file] [-M path] [-m path] "
		    "[-O outkey] [-S arch]\n"
@


1.94
log
@Reduce the verbosity of error messages caused by open(2) failures.
Suggested by and ok jmc@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.93 2014/06/21 16:17:56 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
d20 2
d23 3
d37 11
a77 1
int			  apropos(int, char**);
a78 1

d84 2
d87 1
a87 1
static	void		  usage(void) __attribute__((noreturn));
d91 1
a97 1
	int		 c;
d99 12
d112 1
a112 2
	enum mandoclevel rc;
	char		*defos;
a119 3
	if (0 == strncmp(progname, "apropos", 7) ||
	    0 == strncmp(progname, "whatis", 6))
		return(apropos(argc, argv));
d124 19
a143 2

	options = MPARSE_SO;
d146 1
d149 5
a153 1
	while (-1 != (c = getopt(argc, argv, "I:m:O:T:VW:")))
d155 12
d182 9
d192 1
a192 2
			if ( ! moptions(&options, optarg))
				return((int)MANDOCLEVEL_BADARG);
d195 1
d199 6
d213 3
d220 100
a319 2
			usage();
			/* NOTREACHED */
d322 18
d348 1
a348 6
	argc -= optind;
	argv += optind;

	rc = MANDOCLEVEL_OK;

	if (NULL == *argv)
d351 9
a359 2
	while (*argv) {
		parse(&curp, -1, *argv, &rc);
d362 1
a362 1
		++argv;
d369 7
d385 1
a385 1
	printf("%s %s\n", progname, VERSION);
d390 1
a390 1
usage(void)
d393 21
a413 10
	fprintf(stderr, "usage: %s "
			"[-V] "
			"[-Ios=name] "
			"[-mformat] "
			"[-Ooption] "
			"[-Toutput] "
			"[-Wlevel]\n"
			"\t      [file ...]\n",
			progname);

d530 34
d568 3
a570 1
	if (0 == strcmp(arg, "doc"))
d679 76
@


1.93
log
@Prefix messages about bad command line options and arguments
with "mandoc: " or "makewhatis: ", respectively,
similar to what we already do for other messages.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.92 2014/06/20 22:58:41 schwarze Exp $ */
d415 1
d422 4
a425 2
	fprintf(stderr, " %s: %s", mparse_strlevel(lvl),
	    mparse_strerror(t));
@


1.92
log
@As suggested by jmc@@, only include line and column numbers into messages
when they are meaningful, to avoid confusing stuff like this:
$ mandoc /dev/null
mandoc: /dev/null:0:1: FATAL: not a manual
Instead, just say:
mandoc: /dev/null: FATAL: not a manual

Another example this applies to is documents having a prologue,
but lacking a body.  Do not throw a FATAL error for these; instead,
issue a warning and show the empty document, in the man(7) case with
the same amount of blank lines as groff does.  Also downgrade mdoc(7)
documents having content before the first .Sh from FATAL to WARNING.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.91 2014/06/20 16:11:03 schwarze Exp $ */
d112 2
a113 1
				    "-I%s: Bad argument\n", optarg);
d118 2
a119 2
				    "-I%s: Duplicate argument\n",
				    optarg);
d329 2
a330 1
		fprintf(stderr, "%s: Bad argument\n", arg);
d363 2
a364 1
		fprintf(stderr, "%s: Bad argument\n", arg);
d402 2
a403 1
			fprintf(stderr, "-W%s: Bad argument\n", o);
@


1.91
log
@Prefix error messages from mandoc(1) with "mandoc: "
just like almost all other utility programs do.
Suggested by nick@@ who wondered where messages came from
when calling mandoc(1) from inside a Perl script.
ok jmc@@ nick@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.90 2014/04/20 16:44:44 schwarze Exp $ */
d412 7
a418 3
	fprintf(stderr, "%s: %s:%d:%d: %s: %s", progname,
	    file, line, col + 1,
	    mparse_strlevel(lvl), mparse_strerror(t));
@


1.90
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.89 2014/03/21 22:17:01 schwarze Exp $ */
d412 2
a413 1
	fprintf(stderr, "%s:%d:%d: %s: %s", file, line, col + 1,
@


1.89
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.88 2014/03/19 22:20:36 schwarze Exp $ */
d54 1
a54 1
	enum outt	  outtype; 	/* which output to use */
d56 1
a56 1
	out_man	  	  outman;	/* man output ptr */
d68 1
a68 1
static	void		  parse(struct curparse *, int, 
d77 1
a106 1
	/* LINTED */
d109 1
a109 1
		case ('I'):
d111 2
a112 2
				fprintf(stderr, "-I%s: Bad argument\n",
						optarg);
d116 3
a118 2
				fprintf(stderr, "-I%s: Duplicate argument\n",
						optarg);
d123 1
a123 1
		case ('m'):
d127 1
a127 1
		case ('O'):
d131 1
a131 1
		case ('T'):
d135 1
a135 1
		case ('W'):
d139 1
a139 1
		case ('V'):
d198 1
a198 1
			"\t      [file ...]\n", 
d205 2
a206 2
parse(struct curparse *curp, int fd, 
		const char *file, enum mandoclevel *level)
d236 1
a236 1
		case (OUTT_XHTML):
d240 1
a240 1
		case (OUTT_HTML):
d244 1
a244 1
		case (OUTT_UTF8):
d248 1
a248 1
		case (OUTT_LOCALE):
d252 1
a252 1
		case (OUTT_ASCII):
d256 1
a256 1
		case (OUTT_PDF):
d260 1
a260 1
		case (OUTT_PS):
d269 1
a269 1
		case (OUTT_HTML):
d271 1
a271 1
		case (OUTT_XHTML):
d275 1
a275 1
		case (OUTT_TREE):
d279 1
a279 1
		case (OUTT_MAN):
d283 1
a283 1
		case (OUTT_PDF):
d285 1
a285 1
		case (OUTT_ASCII):
d287 1
a287 1
		case (OUTT_UTF8):
d289 1
a289 1
		case (OUTT_LOCALE):
d291 1
a291 1
		case (OUTT_PS):
d372 1
a372 1
	const char	*toks[6]; 
d384 1
a384 1
		case (0):
d387 1
a387 1
		case (1):
d389 1
a389 1
		case (2):
d392 1
a392 1
		case (3):
d395 1
a395 1
		case (4):
d408 1
a408 1
mmsg(enum mandocerr t, enum mandoclevel lvl, 
d412 2
a413 4
	fprintf(stderr, "%s:%d:%d: %s: %s", 
			file, line, col + 1, 
			mparse_strlevel(lvl),
			mparse_strerror(t));
@


1.88
log
@Without the MPARSE_SO option, if the file contains nothing but a
single .so request, do not read the file pointed to, but instead
let mparse_result() provide the file name pointed to as a return
value.  To be used by makewhatis(8) in the future.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.87 2014/03/19 21:50:59 schwarze Exp $ */
d28 1
@


1.87
log
@Generalize the mparse_alloc() and roff_alloc() functions by giving
them an "options" argument, replacing the existing "inttype" and
"quick" arguments, preparing for a future MPARSE_SO option.
Store this argument in struct mparse and struct roff, replacing the
existing "inttype", "parsetype", and "quick" members.
No functional change except one tiny cosmetic fix in roff_TH().
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.86 2014/01/06 00:53:14 schwarze Exp $ */
d298 1
a298 1
	mparse_result(curp->mp, &mdoc, &man);
@


1.86
log
@Joerg Sonnenberger contributed copyrightable amounts of text to
some files.  To make it clear that he also put his contributions
under the ISC license, with his explicit permission, add his
Copyright notice to the relevant files.  No code change.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.85 2014/01/05 20:26:27 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d64 1
a64 1
static	int		  moptions(enum mparset *, char *);
d81 1
a81 1
	enum mparset	 type;
d100 1
a100 1
	type = MPARSE_AUTO;
d122 1
a122 1
			if ( ! moptions(&type, optarg))
d145 1
a145 1
	curp.mp = mparse_alloc(type, curp.wlevel, mmsg, defos, 0);
d316 1
a316 1
moptions(enum mparset *tflags, char *arg)
d320 1
a320 1
		*tflags = MPARSE_MDOC;
d322 1
a322 1
		*tflags = MPARSE_AUTO;
d324 1
a324 1
		*tflags = MPARSE_MAN;
@


1.85
log
@Add an option -Q (quick) to mandocdb(8)
for accelerated generation of reduced-size databases.

Implement this by allowing the parsers to optionally
abort the parse sequence after the NAME section.

While here, garbage collect the unused void *arg attribute
of struct mparse and mparse_alloc().

This reduces the processing time of mandocdb(8) on /usr/share/man
by a factor of 2 and the database size by a factor of 4.
However, it still takes 5 times the time and 6 times the space
of makewhatis(8), so more work is clearly needed.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.84 2012/11/19 08:46:24 jmc Exp $ */
d5 1
@


1.84
log
@sync usage(), and tidy up the output a little; ok schwarze
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.83 2012/05/24 23:33:23 schwarze Exp $ */
d144 1
a144 1
	curp.mp = mparse_alloc(type, curp.wlevel, mmsg, &curp, defos);
@


1.83
log
@Support -Ios='OpenBSD 5.1' to override uname(3) as the source of the
default value for the mdoc(7) .Os macro.
Needed for man.cgi on the OpenBSD website.

Problem with man.cgi first noticed by deraadt@@;
beck@@ and deraadt@@ agree with the way to solve the issue.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.82 2011/12/25 17:34:57 schwarze Exp $ */
d190 1
a190 1
			"[-foption] "
d194 2
a195 2
			"[-Wlevel] "
			"[file...]\n", 
@


1.82
log
@Accept "makewhatis" as an alias for "mandocdb".
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.81 2011/11/28 00:16:38 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011 Ingo Schwarze <schwarze@@openbsd.org>
d82 1
d102 1
d105 1
a105 1
	while (-1 != (c = getopt(argc, argv, "m:O:T:VW:")))
d107 13
d144 1
a144 1
	curp.mp = mparse_alloc(type, curp.wlevel, mmsg, &curp);
d171 1
@


1.81
log
@Implement whatis(1) as a special apropos(1) mode as a part of
the mandoc(1) binary; not yet enabled for the general public.
Intended to replace src/usr.bin/whatis at a later time.
Coded by kristaps@@, with a few tweaks by me.

To test this:
 $ mandocdb  # unless you have already done so earlier
 $ sudo ln -s /usr/bin/mandoc /usr/bin/whatis.m
 $ whatis.m mandoc apropos whatis
 $ whatis.m man
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.80 2011/10/09 17:59:56 schwarze Exp $ */
d92 2
a93 1
	if (0 == strncmp(progname, "mandocdb", 8))
@


1.80
log
@Sync to version 1.12.0; all code by kristaps@@:
Implement .Rv in -Tman.
Let -man -Tman work a bit like cat(1).
Add the -Ofragment option to -T[x]html.
Minor fixes in -T[x]html.
Lots of apropos(1) and -Tman code cleanup.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.79 2011/10/06 23:04:16 schwarze Exp $ */
d89 2
a90 1
	if (0 == strncmp(progname, "apropos", 7))
@


1.79
log
@1) Import the future apropos(1) replacement written by kristaps@@.
2) Link both that one and mandocdb(8) into the mandoc(1) binary.
3) Install a /usr/bin/mandocdb hardlink and the mandocdb(8) manual.

Do not replace /usr/bin/apropos by a hardlink yet because it is
not ready for production, and ports integration is still missing.
Development will be done in the tree, even the user interfaces
are still subject to change at this point.

Both jmc@@ and deraadt@@ agree with getting this in.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.78 2011/09/17 14:45:22 schwarze Exp $ */
d129 6
d260 1
@


1.78
log
@Initial, incomplete support for -Tman
to convert mdoc(7) documents to the man(7) language.
This is work in progress and will be developed in tree.
It does already handle the cat(1) manual,
but will hardly handle all your fancy manuals yet.
go ahead  kristaps@@ jmc@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.77 2011/05/29 21:22:18 schwarze Exp $ */
d60 3
d88 5
@


1.77
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.76 2011/04/24 16:22:02 schwarze Exp $ */
d40 1
d244 3
d310 2
@


1.76
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.75 2011/04/21 22:59:54 schwarze Exp $ */
d37 2
d202 1
d206 9
a237 1
			curp->outfree = html_free;
d247 4
d308 4
@


1.75
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.74 2011/03/20 23:36:42 schwarze Exp $ */
a17 3
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
a19 2
#include <ctype.h>
#include <fcntl.h>
a29 3
#include "roff.h"

#define	REPARSE_LIMIT	1000
a34 11
struct	buf {
	char	 	 *buf;
	size_t		  sz;
};

enum	intt {
	INTT_AUTO,
	INTT_MDOC,
	INTT_MAN
};

d36 7
a42 7
	OUTT_ASCII = 0,
	OUTT_TREE,
	OUTT_HTML,
	OUTT_XHTML,
	OUTT_LINT,
	OUTT_PS,
	OUTT_PDF
d46 1
a46 5
	enum mandoclevel  exit_status;	/* status of all file parses */
	const char	 *file;		/* current file-name */
	enum mandoclevel  file_status;	/* error status of current parse */
	int		  fd;		/* current file-descriptor */
	int		  line;		/* line number in the file */
a48 8
	enum intt	  inttype;	/* which parser to use */
	struct man	 *pman;		/* persistent man parser */
	struct mdoc	 *pmdoc;	/* persistent mdoc parser */
	struct man	 *man;		/* man parser */
	struct mdoc	 *mdoc;		/* mdoc parser */
	struct roff	 *roff;		/* roff parser (!NULL) */
	struct regset	  regs;		/* roff registers */
	int		  reparse_count; /* finite interpolation stack */
d57 5
a61 136
static	const char * const	mandoclevels[MANDOCLEVEL_MAX] = {
	"SUCCESS",
	"RESERVED",
	"WARNING",
	"ERROR",
	"FATAL",
	"BADARG",
	"SYSERR"
};

static	const enum mandocerr	mandoclimits[MANDOCLEVEL_MAX] = {
	MANDOCERR_OK,
	MANDOCERR_WARNING,
	MANDOCERR_WARNING,
	MANDOCERR_ERROR,
	MANDOCERR_FATAL,
	MANDOCERR_MAX,
	MANDOCERR_MAX
};

static	const char * const	mandocerrs[MANDOCERR_MAX] = {
	"ok",

	"generic warning",

	/* related to the prologue */
	"no title in document",
	"document title should be all caps",
	"unknown manual section",
	"date missing, using today's date",
	"cannot parse date, using it verbatim",
	"prologue macros out of order",
	"duplicate prologue macro",
	"macro not allowed in prologue",
	"macro not allowed in body",

	/* related to document structure */
	".so is fragile, better use ln(1)",
	"NAME section must come first",
	"bad NAME section contents",
	"manual name not yet set",
	"sections out of conventional order",
	"duplicate section name",
	"section not in conventional manual section",

	/* related to macros and nesting */
	"skipping obsolete macro",
	"skipping paragraph macro",
	"skipping no-space macro",
	"blocks badly nested",
	"child violates parent syntax",
	"nested displays are not portable",
	"already in literal mode",

	/* related to missing macro arguments */
	"skipping empty macro",
	"argument count wrong",
	"missing display type",
	"list type must come first",
	"tag lists require a width argument",
	"missing font type",
	"skipping end of block that is not open",

	/* related to bad macro arguments */
	"skipping argument",
	"duplicate argument",
	"duplicate display type",
	"duplicate list type",
	"unknown AT&T UNIX version",
	"bad Boolean value",
	"unknown font",
	"unknown standard specifier",
	"bad width argument",

	/* related to plain text */
	"blank line in non-literal context",
	"tab in non-literal context",
	"end of line whitespace",
	"bad comment style",
	"unknown escape sequence",
	"unterminated quoted string",
	
	"generic error",

	/* related to tables */
	"bad table syntax",
	"bad table option",
	"bad table layout",
	"no table layout cells specified",
	"no table data cells specified",
	"ignore data in cell",
	"data block still open",
	"ignoring extra data cells",

	"input stack limit exceeded, infinite loop?",
	"skipping bad character",
	"escaped character not allowed in a name",
	"skipping text before the first section header",
	"skipping unknown macro",
	"NOT IMPLEMENTED, please use groff: skipping request",
	"line scope broken",
	"argument count wrong",
	"skipping end of block that is not open",
	"missing end of block",
	"scope open on exit",
	"uname(3) system call failed",
	"macro requires line argument(s)",
	"macro requires body argument(s)",
	"macro requires argument(s)",
	"missing list type",
	"line argument(s) will be lost",
	"body argument(s) will be lost",

	"generic fatal error",

	"column syntax is inconsistent",
	"NOT IMPLEMENTED: .Bd -file",
	"line scope broken, syntax violated",
	"argument count wrong, violates syntax",
	"child violates parent syntax",
	"argument count wrong, violates syntax",
	"NOT IMPLEMENTED: .so with absolute path or \"..\"",
	"no document body",
	"no document prologue",
	"static buffer exhausted",
};

static	void		  parsebuf(struct curparse *, struct buf, int);
static	void		  pdesc(struct curparse *);
static	void		  fdesc(struct curparse *);
static	void		  ffile(const char *, struct curparse *);
static	int		  pfile(const char *, struct curparse *);
static	int		  moptions(enum intt *, char *);
static	void		  mmsg(enum mandocerr, void *, 
				int, int, const char *);
static	void		  pset(const char *, int, struct curparse *);
d74 2
d85 1
a85 1
	curp.inttype = INTT_AUTO;
a87 1
	curp.exit_status = MANDOCLEVEL_OK;
d93 1
a93 1
			if ( ! moptions(&curp.inttype, optarg))
d116 2
d121 1
a121 3
	if (NULL == *argv) {
		curp.file = "<stdin>";
		curp.fd = STDIN_FILENO;
d123 2
a124 2
		fdesc(&curp);
	}
d127 2
a128 2
		ffile(*argv, &curp);
		if (MANDOCLEVEL_OK != curp.exit_status && curp.wstop)
d135 2
a136 6
	if (curp.pmdoc)
		mdoc_free(curp.pmdoc);
	if (curp.pman)
		man_free(curp.pman);
	if (curp.roff)
		roff_free(curp.roff);
d138 1
a138 1
	return((int)curp.exit_status);
a140 1

d145 1
a145 1
	(void)printf("%s %s\n", progname, VERSION);
a148 1

d153 1
a153 1
	(void)fprintf(stderr, "usage: %s "
d159 1
a159 1
			"[-Werr] "
d167 2
a168 26
ffile(const char *file, struct curparse *curp)
{

	/*
	 * Called once per input file.  Get the file ready for reading,
	 * pass it through to the parser-driver, then close it out.
	 * XXX: don't do anything special as this is only called for
	 * files; stdin goes directly to fdesc().
	 */

	curp->file = file;

	if (-1 == (curp->fd = open(curp->file, O_RDONLY, 0))) {
		perror(curp->file);
		curp->exit_status = MANDOCLEVEL_SYSERR;
		return;
	}

	fdesc(curp);

	if (-1 == close(curp->fd))
		perror(curp->file);
}

static int
pfile(const char *file, struct curparse *curp)
d170 3
a172 8
	const char	*savefile;
	int		 fd, savefd;

	if (-1 == (fd = open(file, O_RDONLY, 0))) {
		perror(file);
		curp->file_status = MANDOCLEVEL_SYSERR;
		return(0);
	}
d174 1
a174 2
	savefile = curp->file;
	savefd = curp->fd;
d176 2
a177 2
	curp->file = file;
	curp->fd = fd;
d179 1
a179 19
	pdesc(curp);

	curp->file = savefile;
	curp->fd = savefd;

	if (-1 == close(fd))
		perror(file);

	return(MANDOCLEVEL_FATAL > curp->file_status ? 1 : 0);
}


static void
resize_buf(struct buf *buf, size_t initial)
{

	buf->sz = buf->sz > initial/2 ? 2 * buf->sz : initial;
	buf->buf = mandoc_realloc(buf->buf, buf->sz);
}
d181 1
d183 1
a183 101
static int
read_whole_file(struct curparse *curp, struct buf *fb, int *with_mmap)
{
	struct stat	 st;
	size_t		 off;
	ssize_t		 ssz;

	if (-1 == fstat(curp->fd, &st)) {
		perror(curp->file);
		return(0);
	}

	/*
	 * If we're a regular file, try just reading in the whole entry
	 * via mmap().  This is faster than reading it into blocks, and
	 * since each file is only a few bytes to begin with, I'm not
	 * concerned that this is going to tank any machines.
	 */

	if (S_ISREG(st.st_mode)) {
		if (st.st_size >= (1U << 31)) {
			fprintf(stderr, "%s: input too large\n", 
					curp->file);
			return(0);
		}
		*with_mmap = 1;
		fb->sz = (size_t)st.st_size;
		fb->buf = mmap(NULL, fb->sz, PROT_READ, 
				MAP_FILE|MAP_SHARED, curp->fd, 0);
		if (fb->buf != MAP_FAILED)
			return(1);
	}

	/*
	 * If this isn't a regular file (like, say, stdin), then we must
	 * go the old way and just read things in bit by bit.
	 */

	*with_mmap = 0;
	off = 0;
	fb->sz = 0;
	fb->buf = NULL;
	for (;;) {
		if (off == fb->sz) {
			if (fb->sz == (1U << 31)) {
				fprintf(stderr, "%s: input too large\n", 
						curp->file);
				break;
			}
			resize_buf(fb, 65536);
		}
		ssz = read(curp->fd, fb->buf + (int)off, fb->sz - off);
		if (ssz == 0) {
			fb->sz = off;
			return(1);
		}
		if (ssz == -1) {
			perror(curp->file);
			break;
		}
		off += (size_t)ssz;
	}

	free(fb->buf);
	fb->buf = NULL;
	return(0);
}


static void
fdesc(struct curparse *curp)
{

	/*
	 * Called once per file with an opened file descriptor.  All
	 * pre-file-parse operations (whether stdin or a file) should go
	 * here.
	 *
	 * This calls down into the nested parser, which drills down and
	 * fully parses a file and all its dependences (i.e., `so').  It
	 * then runs the cleanup validators and pushes to output.
	 */

	/* Zero the parse type. */

	curp->mdoc = NULL;
	curp->man = NULL;
	curp->file_status = MANDOCLEVEL_OK;

	/* Make sure the mandotory roff parser is initialised. */

	if (NULL == curp->roff) {
		curp->roff = roff_alloc(&curp->regs, curp, mmsg);
		assert(curp->roff);
	}

	/* Fully parse the file. */

	pdesc(curp);

	if (MANDOCLEVEL_FATAL <= curp->file_status)
a185 23
	/* NOTE a parser may not have been assigned, yet. */

	if ( ! (curp->man || curp->mdoc)) {
		fprintf(stderr, "%s: Not a manual\n", curp->file);
		curp->file_status = MANDOCLEVEL_FATAL;
		goto cleanup;
	}

	/* Clean up the parse routine ASTs. */

	if (curp->mdoc && ! mdoc_endparse(curp->mdoc)) {
		assert(MANDOCLEVEL_FATAL <= curp->file_status);
		goto cleanup;
	}

	if (curp->man && ! man_endparse(curp->man)) {
		assert(MANDOCLEVEL_FATAL <= curp->file_status);
		goto cleanup;
	}

	assert(curp->roff);
	roff_endparse(curp->roff);

d187 2
a188 2
	 * With -Wstop and warnings or errors of at least
	 * the requested level, do not produce output.
d191 1
a191 1
	if (MANDOCLEVEL_OK != curp->file_status && curp->wstop)
d245 2
d249 4
a252 4
	if (curp->man && curp->outman)
		(*curp->outman)(curp->outdata, curp->man);
	if (curp->mdoc && curp->outmdoc)
		(*curp->outmdoc)(curp->outdata, curp->mdoc);
d256 1
a256 278
	memset(&curp->regs, 0, sizeof(struct regset));

	/* Reset the current-parse compilers. */

	if (curp->mdoc)
		mdoc_reset(curp->mdoc);
	if (curp->man)
		man_reset(curp->man);

	assert(curp->roff);
	roff_reset(curp->roff);

	if (curp->exit_status < curp->file_status)
		curp->exit_status = curp->file_status;

	return;
}

static void
pdesc(struct curparse *curp)
{
	struct buf	 blk;
	int		 with_mmap;

	/*
	 * Run for each opened file; may be called more than once for
	 * each full parse sequence if the opened file is nested (i.e.,
	 * from `so').  Simply sucks in the whole file and moves into
	 * the parse phase for the file.
	 */

	if ( ! read_whole_file(curp, &blk, &with_mmap)) {
		curp->file_status = MANDOCLEVEL_SYSERR;
		return;
	}

	/* Line number is per-file. */

	curp->line = 1;

	parsebuf(curp, blk, 1);

	if (with_mmap)
		munmap(blk.buf, blk.sz);
	else
		free(blk.buf);
}

/*
 * Main parse routine for an opened file.  This is called for each
 * opened file and simply loops around the full input file, possibly
 * nesting (i.e., with `so').
 */
static void
parsebuf(struct curparse *curp, struct buf blk, int start)
{
	const struct tbl_span	*span;
	struct buf	 ln;
	enum rofferr	 rr;
	int		 i, of, rc;
	int		 pos; /* byte number in the ln buffer */
	int		 lnn; /* line number in the real file */
	unsigned char	 c;

	memset(&ln, 0, sizeof(struct buf));

	lnn = curp->line; 
	pos = 0; 

	for (i = 0; i < (int)blk.sz; ) {
		if (0 == pos && '\0' == blk.buf[i])
			break;

		if (start) {
			curp->line = lnn;
			curp->reparse_count = 0;
		}

		while (i < (int)blk.sz && (start || '\0' != blk.buf[i])) {

			/*
			 * When finding an unescaped newline character,
			 * leave the character loop to process the line.
			 * Skip a preceding carriage return, if any.
			 */

			if ('\r' == blk.buf[i] && i + 1 < (int)blk.sz &&
			    '\n' == blk.buf[i + 1])
				++i;
			if ('\n' == blk.buf[i]) {
				++i;
				++lnn;
				break;
			}

			/* 
			 * Warn about bogus characters.  If you're using
			 * non-ASCII encoding, you're screwing your
			 * readers.  Since I'd rather this not happen,
			 * I'll be helpful and drop these characters so
			 * we don't display gibberish.  Note to manual
			 * writers: use special characters.
			 */

			c = (unsigned char) blk.buf[i];

			if ( ! (isascii(c) && 
					(isgraph(c) || isblank(c)))) {
				mmsg(MANDOCERR_BADCHAR, curp, 
				    curp->line, pos, "ignoring byte");
				i++;
				continue;
			}

			/* Trailing backslash = a plain char. */

			if ('\\' != blk.buf[i] || i + 1 == (int)blk.sz) {
				if (pos >= (int)ln.sz)
					resize_buf(&ln, 256);
				ln.buf[pos++] = blk.buf[i++];
				continue;
			}

			/*
			 * Found escape and at least one other character.
			 * When it's a newline character, skip it.
			 * When there is a carriage return in between,
			 * skip that one as well.
			 */

			if ('\r' == blk.buf[i + 1] && i + 2 < (int)blk.sz &&
			    '\n' == blk.buf[i + 2])
				++i;
			if ('\n' == blk.buf[i + 1]) {
				i += 2;
				++lnn;
				continue;
			}

			if ('"' == blk.buf[i + 1]) {
				i += 2;
				/* Comment, skip to end of line */
				for (; i < (int)blk.sz; ++i) {
					if ('\n' == blk.buf[i]) {
						++i;
						++lnn;
						break;
					}
				}

				/* Backout trailing whitespaces */
				for (; pos > 0; --pos) {
					if (ln.buf[pos - 1] != ' ')
						break;
					if (pos > 2 && ln.buf[pos - 2] == '\\')
						break;
				}
				break;
			}

			/* Some other escape sequence, copy & cont. */

			if (pos + 1 >= (int)ln.sz)
				resize_buf(&ln, 256);

			ln.buf[pos++] = blk.buf[i++];
			ln.buf[pos++] = blk.buf[i++];
		}

 		if (pos >= (int)ln.sz)
			resize_buf(&ln, 256);

		ln.buf[pos] = '\0';

		/*
		 * A significant amount of complexity is contained by
		 * the roff preprocessor.  It's line-oriented but can be
		 * expressed on one line, so we need at times to
		 * readjust our starting point and re-run it.  The roff
		 * preprocessor can also readjust the buffers with new
		 * data, so we pass them in wholesale.
		 */

		of = 0;

rerun:
		rr = roff_parseln
			(curp->roff, curp->line, 
			 &ln.buf, &ln.sz, of, &of);

		switch (rr) {
		case (ROFF_REPARSE):
			if (REPARSE_LIMIT >= ++curp->reparse_count)
				parsebuf(curp, ln, 0);
			else
				mmsg(MANDOCERR_ROFFLOOP, curp, 
				    curp->line, pos, NULL);
			pos = 0;
			continue;
		case (ROFF_APPEND):
			pos = (int)strlen(ln.buf);
			continue;
		case (ROFF_RERUN):
			goto rerun;
		case (ROFF_IGN):
			pos = 0;
			continue;
		case (ROFF_ERR):
			assert(MANDOCLEVEL_FATAL <= curp->file_status);
			break;
		case (ROFF_SO):
			if (pfile(ln.buf + of, curp)) {
				pos = 0;
				continue;
			} else
				break;
		default:
			break;
		}

		/*
		 * If we encounter errors in the recursive parsebuf()
		 * call, make sure we don't continue parsing.
		 */

		if (MANDOCLEVEL_FATAL <= curp->file_status)
			break;

		/*
		 * If input parsers have not been allocated, do so now.
		 * We keep these instanced betwen parsers, but set them
		 * locally per parse routine since we can use different
		 * parsers with each one.
		 */

		if ( ! (curp->man || curp->mdoc))
			pset(ln.buf + of, pos - of, curp);

		/* 
		 * Lastly, push down into the parsers themselves.  One
		 * of these will have already been set in the pset()
		 * routine.
		 * If libroff returns ROFF_TBL, then add it to the
		 * currently open parse.  Since we only get here if
		 * there does exist data (see tbl_data.c), we're
		 * guaranteed that something's been allocated.
		 * Do the same for ROFF_EQN.
		 */

		rc = -1;

		if (ROFF_TBL == rr)
			while (NULL != (span = roff_span(curp->roff))) {
				rc = curp->man ?
					man_addspan(curp->man, span) :
					mdoc_addspan(curp->mdoc, span);
				if (0 == rc)
					break;
			}
		else if (ROFF_EQN == rr)
			rc = curp->mdoc ? 
				mdoc_addeqn(curp->mdoc, 
					roff_eqn(curp->roff)) :
				man_addeqn(curp->man,
					roff_eqn(curp->roff));
		else if (curp->man || curp->mdoc)
			rc = curp->man ?
				man_parseln(curp->man, 
					curp->line, ln.buf, of) :
				mdoc_parseln(curp->mdoc, 
					curp->line, ln.buf, of);

		if (0 == rc) {
			assert(MANDOCLEVEL_FATAL <= curp->file_status);
			break;
		}

		/* Temporary buffers typically are not full. */
d258 2
a259 67
		if (0 == start && '\0' == blk.buf[i])
			break;

		/* Start the next input line. */

		pos = 0;
	}

	free(ln.buf);
}

static void
pset(const char *buf, int pos, struct curparse *curp)
{
	int		 i;

	/*
	 * Try to intuit which kind of manual parser should be used.  If
	 * passed in by command-line (-man, -mdoc), then use that
	 * explicitly.  If passed as -mandoc, then try to guess from the
	 * line: either skip dot-lines, use -mdoc when finding `.Dt', or
	 * default to -man, which is more lenient.
	 *
	 * Separate out pmdoc/pman from mdoc/man: the first persists
	 * through all parsers, while the latter is used per-parse.
	 */

	if ('.' == buf[0] || '\'' == buf[0]) {
		for (i = 1; buf[i]; i++)
			if (' ' != buf[i] && '\t' != buf[i])
				break;
		if ('\0' == buf[i])
			return;
	}

	switch (curp->inttype) {
	case (INTT_MDOC):
		if (NULL == curp->pmdoc) 
			curp->pmdoc = mdoc_alloc
				(&curp->regs, curp, mmsg);
		assert(curp->pmdoc);
		curp->mdoc = curp->pmdoc;
		return;
	case (INTT_MAN):
		if (NULL == curp->pman) 
			curp->pman = man_alloc
				(&curp->regs, curp, mmsg);
		assert(curp->pman);
		curp->man = curp->pman;
		return;
	default:
		break;
	}

	if (pos >= 3 && 0 == memcmp(buf, ".Dd", 3))  {
		if (NULL == curp->pmdoc) 
			curp->pmdoc = mdoc_alloc
				(&curp->regs, curp, mmsg);
		assert(curp->pmdoc);
		curp->mdoc = curp->pmdoc;
		return;
	} 

	if (NULL == curp->pman) 
		curp->pman = man_alloc(&curp->regs, curp, mmsg);
	assert(curp->pman);
	curp->man = curp->pman;
d263 1
a263 1
moptions(enum intt *tflags, char *arg)
d267 1
a267 1
		*tflags = INTT_MDOC;
d269 1
a269 1
		*tflags = INTT_AUTO;
d271 1
a271 1
		*tflags = INTT_MAN;
d289 1
a289 2
	}
	else if (0 == strcmp(arg, "tree"))
d347 2
a348 1
mmsg(enum mandocerr t, void *arg, int ln, int col, const char *msg)
a349 2
	struct curparse *cp;
	enum mandoclevel level;
d351 4
a354 8
	level = MANDOCLEVEL_FATAL;
	while (t < mandoclimits[level])
		/* LINTED */
		level--;

	cp = (struct curparse *)arg;
	if (level < cp->wlevel)
		return;
a355 2
	fprintf(stderr, "%s:%d:%d: %s: %s",
	    cp->file, ln, col + 1, mandoclevels[level], mandocerrs[t]);
d358 1
a359 3

	if (cp->file_status < level)
		cp->file_status = level;
@


1.74
log
@Import the foundation for eqn(7) support.
Written by kristaps@@.

For now, i'm adding one line to each of the four frontends
to just pass the input text through to the output,
not yet interpreting any of then eqn keywords.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.73 2011/03/07 01:35:33 schwarze Exp $ */
a37 1
#define	UNCONST(a)	((void *)(uintptr_t)(const void *)(a))
d65 7
a71 5
	const char	 *file;		/* Current parse. */
	int		  fd;		/* Current parse. */
	int		  line;		/* Line number in the file. */
	enum mandoclevel  wlevel;	/* Ignore messages below this. */
	int		  wstop;	/* Stop after a file with a warning. */
d221 1
a221 1
static	int		  mmsg(enum mandocerr, void *, 
a229 2
static	enum mandoclevel  file_status = MANDOCLEVEL_OK;
static	enum mandoclevel  exit_status = MANDOCLEVEL_OK;
d248 1
d289 1
a289 1
		if (MANDOCLEVEL_OK != exit_status && curp.wstop)
d303 1
a303 1
	return((int)exit_status);
d348 1
a348 1
		exit_status = MANDOCLEVEL_SYSERR;
d366 1
a366 1
		file_status = MANDOCLEVEL_SYSERR;
d384 1
a384 1
	return(MANDOCLEVEL_FATAL > file_status ? 1 : 0);
d393 1
a393 5
	buf->buf = realloc(buf->buf, buf->sz);
	if (NULL == buf->buf) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
d484 1
a484 1
	file_status = MANDOCLEVEL_OK;
d497 1
a497 1
	if (MANDOCLEVEL_FATAL <= file_status)
d504 1
a504 1
		file_status = MANDOCLEVEL_FATAL;
d511 1
a511 1
		assert(MANDOCLEVEL_FATAL <= file_status);
d516 1
a516 1
		assert(MANDOCLEVEL_FATAL <= file_status);
d528 1
a528 1
	if (MANDOCLEVEL_OK != file_status && curp->wstop)
d603 2
a604 2
	if (exit_status < file_status)
		exit_status = file_status;
d623 1
a623 1
		file_status = MANDOCLEVEL_SYSERR;
d639 5
a654 6
	/*
	 * Main parse routine for an opened file.  This is called for
	 * each opened file and simply loops around the full input file,
	 * possibly nesting (i.e., with `so').
	 */

d791 1
a791 1
			pos = strlen(ln.buf);
d799 1
a799 1
			assert(MANDOCLEVEL_FATAL <= file_status);
d816 1
a816 1
		if (MANDOCLEVEL_FATAL <= file_status)
d864 1
a864 1
			assert(MANDOCLEVEL_FATAL <= file_status);
d1024 1
a1024 1
static int
d1037 1
a1037 1
		return(1);
d1045 2
a1046 4
	if (file_status < level)
		file_status = level;
	
	return(level < MANDOCLEVEL_FATAL);
@


1.73
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.72 2011/02/06 17:33:20 schwarze Exp $ */
d842 1
d845 3
a847 2
		if (ROFF_TBL == rr) {
			assert(curp->man || curp->mdoc);
d849 2
a850 3
				if (curp->man)
					man_addspan(curp->man, span);
				else
d852 2
d855 7
a861 1
		} else if (curp->man || curp->mdoc) {
d868 3
a870 4
			if ( ! rc) {
				assert(MANDOCLEVEL_FATAL <= file_status);
				break;
			}
@


1.72
log
@If .Ns is specified on its own line, ignore it, like groff does;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.71 2011/01/25 12:24:26 schwarze Exp $ */
d116 2
a117 1
	"cannot parse date argument",
@


1.71
log
@Since tbl_data() can now produce multiple spans, let parsebuf()
generate man(7) or mdoc(7) nodes for all these spans,
not only for the last one.
Restores the horizontal lines in the cpu(4/hppa) tables.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.70 2011/01/24 23:40:12 schwarze Exp $ */
d134 1
@


1.70
log
@Skip carriage return before newline, if any.
As pointed out by Joerg Sonnenberger, this is useful
because we use mmap(3) and look for '\n' by hand.
"check it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.69 2011/01/20 21:33:11 schwarze Exp $ */
d644 1
d844 6
a849 5
			if (curp->man)
				man_addspan(curp->man, roff_span(curp->roff));
			else
				mdoc_addspan(curp->mdoc, roff_span(curp->roff));

@


1.69
log
@When finding the roff .it request (line trap),
make it clear that you cannot use mandoc to format that page (yet).
Triggered by a report from brad@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.68 2011/01/16 19:27:25 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d672 10
d716 6
a721 1
			/* Found escape & at least one other char. */
d723 3
a727 1
				/* Escaped newlines are skipped over */
@


1.68
log
@Some improvements to error handling from kristaps@@:
* Make out-of-context .fi invocations not cause an error, but just a warning.
* Downgrade -man message about ignored empty paragraph to MANDOC_IGNPAR.
* Avoid syntax tree corruption when removing empty block macros.
Triggered by some reports from brad@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.67 2011/01/16 01:11:50 schwarze Exp $ */
d184 1
a184 1
	"NOT IMPLEMENTED: skipping request",
@


1.67
log
@Various tbl improvements from kristaps@@:
* horizontal lines do not consume layout lines
* skip excessive data cells
* prepare rendering of spanned cells
* support vertical spans
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.66 2011/01/10 23:53:32 schwarze Exp $ */
d146 1
@


1.66
log
@Refactoring in preparation for .rm support:
Unify parsing of names given as roff request arguments into a new
function roff_getname(), which is rather different from the parsing
function for normal arguments, mandoc_getarg(), because names cannot
be quoted and cannot contain whitespace or escaped characters.
The new function now throws an ERROR when finding escaped characters
in a name.
"I'm fine with this." kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.65 2011/01/09 13:16:48 schwarze Exp $ */
a165 3
	/* related to tables */
	"extra data cells",

d176 1
@


1.65
log
@Make sure coding errors cannot make us miss fatal parsing errors
by assert(3)ing valid parser state in the main parsing functions;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.64 2011/01/04 22:28:17 schwarze Exp $ */
d182 1
@


1.64
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.63 2011/01/03 23:39:27 schwarze Exp $ */
d795 8
@


1.63
log
@Partial cleanup of argument count validation in mdoc(7):

* Do not segfault on empty .Db, .Rs, .Sm, and .St.
* Let check_count() really throw the requested level, not always ERROR.
* Downgrade most bad argument counts from ERROR to WARNING.
* And some related internal cleanup.

Looks fine to kristaps@@.

Note that the macros using eerr_ge1() still need to be checked at a later
time; but as all the others are done, let's use what we already have.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.62 2010/12/21 01:22:00 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d165 3
d171 9
a196 1
	"tbl(1) error",
d523 1
a523 4
	if ( ! roff_endparse(curp->roff)) {
		assert(MANDOCLEVEL_FATAL <= file_status);
		goto cleanup;
	}
d792 1
a792 1
		case (ROFF_CONT):
d810 4
d816 8
a823 1
		if (curp->man || curp->mdoc) {
@


1.62
log
@Sane behaviour for the growing of very small buffers:
Always grow at least to the minimum requested size.
Before this, a buffer of 1 byte was grown to 2 bytes,
which was too small and sometimes caused segfaults.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.61 2010/12/09 23:01:18 schwarze Exp $ */
d141 1
@


1.61
log
@Abort endless loops during roff macro and string expansion.
For now, use the simplest conceivable approach, like groff does:
Just a fixed, ugly input stack limit.
Kristaps@@ agrees.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.60 2010/12/02 20:40:43 schwarze Exp $ */
d378 1
a378 1
	buf->sz = buf->sz ? 2 * buf->sz : initial;
@


1.60
log
@Track the parser status both per file (file_status), such that
we can for example skip rendering on FATAL parsing errors,
and globally (exit_status), such that we know what to return.
Without this, following files produced no rendered output
once a single file suffered from a FATAL error.
Bug reported by kristaps@@, fix by me.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.59 2010/12/01 23:38:11 schwarze Exp $ */
d37 1
d78 1
d167 1
d657 1
a657 1
		if (start)
d659 2
d759 5
a763 1
			parsebuf(curp, ln, 0);
@


1.59
log
@Cleanup by kristaps@@:
* When autodetecting the format, don't assume all files are the same.
* Add more comments and apply some whitespace beautifications.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.58 2010/12/01 22:02:29 schwarze Exp $ */
d212 1
d349 1
a349 1
		exit_status = MANDOCLEVEL_SYSERR;
d367 1
a367 1
	return(MANDOCLEVEL_FATAL > exit_status ? 1 : 0);
d471 1
d484 1
a484 1
	if (MANDOCLEVEL_FATAL <= exit_status)
d491 1
a491 1
		exit_status = MANDOCLEVEL_FATAL;
d498 1
a498 1
		assert(MANDOCLEVEL_FATAL <= exit_status);
d503 1
a503 1
		assert(MANDOCLEVEL_FATAL <= exit_status);
d509 1
a509 1
		assert(MANDOCLEVEL_FATAL <= exit_status);
d518 1
a518 1
	if (MANDOCLEVEL_OK != exit_status && curp->wstop)
d593 3
d613 1
a613 1
		exit_status = MANDOCLEVEL_SYSERR;
d766 1
a766 1
			assert(MANDOCLEVEL_FATAL <= exit_status);
d802 1
a802 1
				assert(MANDOCLEVEL_FATAL <= exit_status);
d984 2
a985 2
	if (exit_status < level)
		exit_status = level;
@


1.58
log
@Merge mdoc_action.c into mdoc_validate.c, because having two places to do
basically the same things just causes code duplication and confusion.
Work by kristaps@@, including a few bugfixes he found during the merge,
and reapplying OpenBSD changes on top.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.57 2010/11/29 00:12:02 schwarze Exp $ */
d71 2
d205 1
a205 2
static	void		  pset(const char *, int, struct curparse *,
				struct man **, struct mdoc **);
d278 4
a281 4
	if (curp.mdoc)
		mdoc_free(curp.mdoc);
	if (curp.man)
		man_free(curp.man);
d302 10
a311 3
	(void)fprintf(stderr, "usage: %s [-V] [-foption] "
			"[-mformat] [-Ooption] [-Toutput] "
			"[-Werr] [file...]\n", progname);
a314 1

d319 7
d327 1
d455 24
a478 3
	struct man	*man;
	struct mdoc	*mdoc;
	struct roff	*roff;
a481 4
	man  = curp->man;
	mdoc = curp->mdoc;
	roff = curp->roff;

d487 1
a487 1
	if ( ! (man || mdoc)) {
d495 1
a495 1
	if (mdoc && ! mdoc_endparse(mdoc)) {
d499 2
a500 1
	if (man && ! man_endparse(man)) {
d504 3
a506 1
	if (roff && ! roff_endparse(roff)) {
d572 4
a575 4
	if (man && curp->outman)
		(*curp->outman)(curp->outdata, man);
	if (mdoc && curp->outmdoc)
		(*curp->outmdoc)(curp->outdata, mdoc);
d578 1
d580 10
a589 6
	if (mdoc)
		mdoc_reset(mdoc);
	if (man)
		man_reset(man);
	if (roff)
		roff_reset(roff);
a593 1

d600 7
d612 1
a612 3
	if (NULL == curp->roff) 
		curp->roff = roff_alloc(&curp->regs, curp, mmsg);
	assert(curp->roff);
d615 1
d628 4
a631 1
	int		 i, pos, lnn, of;
d633 6
a638 7
	struct man	*man;
	struct mdoc	*mdoc;
	struct roff	*roff;

	man  = curp->man;
	mdoc = curp->mdoc;
	roff = curp->roff;
d642 2
a643 2
	lnn = curp->line;  /* line number in the real file */
	pos = 0;  /* byte number in the ln buffer */
d645 1
a645 1
	for (i = 0; i < (int)blk.sz;) {
d648 1
d669 3
a671 1
			if ( ! (isascii(c) && (isgraph(c) || isblank(c)))) {
d678 2
a679 1
			/* Trailing backslash is like a plain character. */
d686 3
a688 1
			/* Found an escape and at least one other character. */
d690 1
a691 1
				i += 2;
d695 1
d706 1
d716 3
a718 1
			/* Some other escape sequence, copy and continue. */
d728 1
d741 1
d743 5
a747 2
		switch (roff_parseln(roff, curp->line, &ln.buf, &ln.sz,
		    of, &of)) {
d780 2
a781 2
		if ( ! (man || mdoc))
			pset(ln.buf + of, pos - of, curp, &man, &mdoc);
d783 12
a794 1
		/* Lastly, push down into the parsers themselves. */
d796 4
a799 7
		if (man && ! man_parseln(man, curp->line, ln.buf, of)) {
			assert(MANDOCLEVEL_FATAL <= exit_status);
			break;
		}
		if (mdoc && ! mdoc_parseln(mdoc, curp->line, ln.buf, of)) {
			assert(MANDOCLEVEL_FATAL <= exit_status);
			break;
d803 1
d808 1
a814 1

d816 1
a816 2
pset(const char *buf, int pos, struct curparse *curp,
		struct man **man, struct mdoc **mdoc)
d826 3
d841 5
a845 4
		if (NULL == curp->mdoc) 
			curp->mdoc = mdoc_alloc(&curp->regs, curp, mmsg);
		assert(curp->mdoc);
		*mdoc = curp->mdoc;
d848 5
a852 4
		if (NULL == curp->man) 
			curp->man = man_alloc(&curp->regs, curp, mmsg);
		assert(curp->man);
		*man = curp->man;
d859 5
a863 4
		if (NULL == curp->mdoc) 
			curp->mdoc = mdoc_alloc(&curp->regs, curp, mmsg);
		assert(curp->mdoc);
		*mdoc = curp->mdoc;
d867 4
a870 4
	if (NULL == curp->man) 
		curp->man = man_alloc(&curp->regs, curp, mmsg);
	assert(curp->man);
	*man = curp->man;
a872 1

a890 1

a918 1

a956 1

@


1.57
log
@Implement the roff .ft (change font) request for man(7).
Of course, we don't want to encourage low-level physical markup,
but pod2man(1) writes such requests, so Perl manuals contain them,
and some Xenocara and lots and lots of ports manuals use them as well.
In base and Xenocara, this will reduce mandoc -Tlint ERROR noise;
in ports, it will improve rendering of many manuals.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.56 2010/11/28 19:35:33 schwarze Exp $ */
a149 1
	"unknown library specifier",
@


1.56
log
@To avoid FATAL errors, we have been parsing and ignoring the roff
requests .am, .ami, .am1, .dei, and .rm for a long time.
Since ignoring them can (rarely) cause information loss and serious
misformatting, throw an ERROR: NOT IMPLEMENTED when finding them.
Implementing them would not be too difficult, but they are so rare
in practice that i can find better use for my time right now.

In this context,
- Put the string "NOT IMPLEMENTED" into two other error messages
as well, to distinguish them from those caused by broken input.
- Print the string "unknown macro" once, not twice in the error message
associated with MANDOCERR_MACRO, and begin printing the buffer at the
point where the unknown macro really is, not at the start of line.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.55 2010/11/25 22:23:31 schwarze Exp $ */
d149 1
@


1.55
log
@Implement the .de (define macro) roff instruction.
This fixes various Xenocara manuals.
Do not define your own macros in new manuals, though:
this code exists purely to cope with existing and old stuff.

Like in both traditional and GNU roff, the .de and .ds (define string)
roff instructions share the same string table, so one can abuse strings
as macros and vice versa.  This implementation supports multi-line
user-defined macros and user-defined macros taking up to 9 arguments.

Project started near the end of p2k10, now mature for production,
but there is still room for future improvements in various respects.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.54 2010/10/26 23:34:38 schwarze Exp $ */
d166 1
d184 1
a184 1
	"unsupported display type",
d189 1
a189 1
	"invalid path in include directive",
@


1.54
log
@Warn developers that .so is fragile and suggest using ln(1) instead;
throwing a warning here was suggested by Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.53 2010/10/26 22:48:07 schwarze Exp $ */
d67 1
d194 1
d198 1
a198 1
static	int		  pfile(const char *, struct curparse *, int);
d325 1
a325 1
pfile(const char *file, struct curparse *curp, int ln)
d557 2
a558 14
	struct buf	 ln, blk;
	int		 i, pos, lnn, lnn_start, with_mmap, of;
	enum rofferr	 re;
	unsigned char	 c;
	struct man	*man;
	struct mdoc	*mdoc;
	struct roff	*roff;

	memset(&ln, 0, sizeof(struct buf));

	/*
	 * Two buffers: ln and buf.  buf is the input file and may be
	 * memory mapped.  ln is a line buffer and grows on-demand.
	 */
d568 22
a590 2
	mdoc = curp->mdoc;
	man  = curp->man;
d592 12
a603 4
	for (i = 0, lnn = 1; i < (int)blk.sz;) {
		pos = 0;
		lnn_start = lnn;
		while (i < (int)blk.sz) {
d622 1
a622 1
				    lnn_start, pos, "ignoring byte");
d682 14
a695 6
		do {
			re = roff_parseln(roff, lnn_start, 
					&ln.buf, &ln.sz, of, &of);
		} while (ROFF_RERUN == re);

		if (ROFF_IGN == re) {
d697 1
a697 1
		} else if (ROFF_ERR == re) {
d700 3
a702 2
		} else if (ROFF_SO == re) {
			if (pfile(ln.buf + of, curp, lnn_start))
d704 1
a704 1
			else
d706 2
d722 1
a722 1
		if (man && ! man_parseln(man, lnn_start, ln.buf, of)) {
d726 1
a726 1
		if (mdoc && ! mdoc_parseln(mdoc, lnn_start, ln.buf, of)) {
d730 7
a739 4
	if (with_mmap)
		munmap(blk.buf, blk.sz);
	else
		free(blk.buf);
@


1.53
log
@Downgrade nearly 20 ERRORS to WARNINGS.
All these indicate problems in the mdoc(7) or man(7) source code,
but they can't cause relevant information loss or clobbered formatting.
While here, error message improve wording and make it more uniform,
don't throw MANDOCERR_NOWIDTHARG twice when there is one single issue,
and consolidate MANDOCERR_WIDTHARG into MANDOCERR_IGNARGV.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.52 2010/10/26 22:28:56 schwarze Exp $ */
d118 1
@


1.52
log
@Support .so (low-level roff "switch source file"),
needed for Xenocara and various ports.
Accept only relative paths and no ascension to the parent directory
as suggested by Joerg Sonnenberger; code looked over by Joerg, too.
Useful discussions with various people, among others espie@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.51 2010/10/26 22:13:58 schwarze Exp $ */
d107 14
a120 1
	"text should be uppercase",
d122 14
a135 3
	"section name repeats",
	"out of order prologue",
	"repeated prologue entry",
d137 16
a152 2
	"bad standard",
	"bad library",
d154 3
a156 1
	"bad escape sequence",
a157 10
	"argument requires the width argument",
	"superfluous width argument",
	"ignoring argument",
	"bad date argument",
	"bad width argument",
	"unknown manual section",
	"nested displays are not portable",
	"section not in conventional manual section",
	"end of line whitespace",
	"blocks badly nested",
d161 3
a163 18
	"NAME section must come first",
	"bad Boolean value",
	"child violates parent syntax",
	"bad AT&T symbol",
	"list type repeated",
	"display type repeated",
	"argument repeated",
	"manual name not yet set",
	"obsolete macro ignored",
	"empty macro ignored",
	"macro not allowed in body",
	"macro not allowed in prologue",
	"bad character",
	"bad NAME section contents",
	"no blank lines",
	"no text in this context",
	"bad comment style",
	"unknown macro will be lost",
d166 1
a166 1
	"request scope close w/none open",
a167 1
	"scope already open",
a172 1
	"no title in document",
a173 2
	"missing display type",
	"missing font type",
a175 1
	"paragraph macro ignored",
@


1.51
log
@Refactoring, no functional change:
Seperate the code to read and parse a PART of a page (new function pdesc())
from the code to finish and output a FULL page (function fdesc());
in preparation for .so support.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.50 2010/10/24 18:15:43 schwarze Exp $ */
d176 1
d185 1
d311 29
d663 5
@


1.50
log
@Do not throw FATAL errors when there is no need to:
 - when encountering nested displays (.Bd containing .Bd, .D1, .D1)
 - when a block end macro was forgotten
 - when ending a block that was never started
 - when the uname(3) system call failed
along with a little related cleanup
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.49 2010/10/16 20:49:37 schwarze Exp $ */
d181 1
d395 118
a520 4
	man = NULL;
	mdoc = NULL;
	roff = NULL;

d537 2
d631 1
a631 1
			goto cleanup;
d648 1
a648 1
			goto cleanup;
a651 82
			goto cleanup;
		}
	}

	/* NOTE a parser may not have been assigned, yet. */

	if ( ! (man || mdoc)) {
		fprintf(stderr, "%s: Not a manual\n", curp->file);
		exit_status = MANDOCLEVEL_FATAL;
		goto cleanup;
	}

	/* Clean up the parse routine ASTs. */

	if (mdoc && ! mdoc_endparse(mdoc)) {
		assert(MANDOCLEVEL_FATAL <= exit_status);
		goto cleanup;
	}
	if (man && ! man_endparse(man)) {
		assert(MANDOCLEVEL_FATAL <= exit_status);
		goto cleanup;
	}
	if (roff && ! roff_endparse(roff)) {
		assert(MANDOCLEVEL_FATAL <= exit_status);
		goto cleanup;
	}

	/*
	 * With -Wstop and warnings or errors of at least
	 * the requested level, do not produce output.
	 */

	if (MANDOCLEVEL_OK != exit_status && curp->wstop)
		goto cleanup;

	/* If unset, allocate output dev now (if applicable). */

	if ( ! (curp->outman && curp->outmdoc)) {
		switch (curp->outtype) {
		case (OUTT_XHTML):
			curp->outdata = xhtml_alloc(curp->outopts);
			break;
		case (OUTT_HTML):
			curp->outdata = html_alloc(curp->outopts);
			break;
		case (OUTT_ASCII):
			curp->outdata = ascii_alloc(curp->outopts);
			curp->outfree = ascii_free;
			break;
		case (OUTT_PDF):
			curp->outdata = pdf_alloc(curp->outopts);
			curp->outfree = pspdf_free;
			break;
		case (OUTT_PS):
			curp->outdata = ps_alloc(curp->outopts);
			curp->outfree = pspdf_free;
			break;
		default:
			break;
		}

		switch (curp->outtype) {
		case (OUTT_HTML):
			/* FALLTHROUGH */
		case (OUTT_XHTML):
			curp->outman = html_man;
			curp->outmdoc = html_mdoc;
			curp->outfree = html_free;
			break;
		case (OUTT_TREE):
			curp->outman = tree_man;
			curp->outmdoc = tree_mdoc;
			break;
		case (OUTT_PDF):
			/* FALLTHROUGH */
		case (OUTT_ASCII):
			/* FALLTHROUGH */
		case (OUTT_PS):
			curp->outman = terminal_man;
			curp->outmdoc = terminal_mdoc;
			break;
		default:
d656 1
a656 17
	/* Execute the out device, if it exists. */

	if (man && curp->outman)
		(*curp->outman)(curp->outdata, man);
	if (mdoc && curp->outmdoc)
		(*curp->outmdoc)(curp->outdata, mdoc);

 cleanup:
	memset(&curp->regs, 0, sizeof(struct regset));
	if (mdoc)
		mdoc_reset(mdoc);
	if (man)
		man_reset(man);
	if (roff)
		roff_reset(roff);
	if (ln.buf)
		free(ln.buf);
a660 2

	return;
@


1.49
log
@Do not abort() on tbl errors, reduce the risk that tbl stuff kills a build,
and provide more useful tbl error messages in a non-intrusive way.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.48 2010/09/27 21:25:28 schwarze Exp $ */
d124 1
d152 1
d155 1
a170 1
	"displays may not be nested",
a171 2
	"blocks badly nested",
	"no such block is open",
a177 1
	"utsname system call failed",
@


1.48
log
@Merge the last bits of 1.10.6 (released today), most were already in:
* ignore double-.Pp
* ignore .Pp before .Bd and .Bl (unless -compact in specified)
* avoid double blank line upon .Pp, .br and friends in literal context
* cast enums to int when passing them to exit(3) to please lint(1)
While merging, fix a regression introduced by kristaps@@:
Outside literal mode, double blank lines must both be printed.
To achieve this again after kristaps@@ improvements in 1.10.6,
treat such blank lines as .sp (instead of .Pp as in 1.10.5)
and drop .Pp before .sp just like dropping .Pp before .Pp.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.47 2010/09/26 20:19:58 schwarze Exp $ */
d163 1
@


1.47
log
@If an explicit scope is still open at the end of an input file,
report an ERROR:  We can still render the page by just closing
the open scope, but it is likely that information will be missing
or document structure mangled.
Before, man(7) only reported a WARNING (which is dangerous because
we cannot be sure rendering is correct) and mdoc(7) ran into FATAL
(which is too drastic, there is no reason not to show what we have).
While here, add a few explicit casts to appease lint.
"looks good" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.46 2010/08/20 08:13:03 schwarze Exp $ */
d162 1
@


1.46
log
@fix previous: when bailing out due to -Wstop,
skip output functions, but not *_endparse;
problem reported by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.45 2010/08/20 00:53:35 schwarze Exp $ */
a126 1
	"scope open on exit",
d152 1
a169 1
	"scope broken, syntax violated",
d218 1
a218 1
				return(MANDOCLEVEL_BADARG);
d226 1
a226 1
				return(MANDOCLEVEL_BADARG);
d230 1
a230 1
				return(MANDOCLEVEL_BADARG);
d266 1
a266 1
	return(exit_status);
d275 1
a275 1
	exit(MANDOCLEVEL_OK);
d286 1
a286 1
	exit(MANDOCLEVEL_BADARG);
d316 1
a316 1
		exit(MANDOCLEVEL_SYSERR);
d796 1
@


1.45
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.44 2010/08/18 01:03:22 schwarze Exp $ */
a538 8
	/*
	 * With -Wstop and warnings or errors of at least
	 * the requested level, do not produce output.
	 */

	if (MANDOCLEVEL_OK != exit_status && curp->wstop)
		goto cleanup;

d561 8
@


1.44
log
@Use isascii(3) to make sure we really throw away non-ASCII characters,
because isgraph(3) returns true for some eight-bit characters.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.43 2010/07/25 18:05:54 schwarze Exp $ */
d67 2
a68 11
	int		  wflags;
	/* FIXME: set by max error */
#define	WARN_WALL	 (1 << 0)	/* All-warnings mask. */
#define	WARN_WERR	 (1 << 2)	/* Warnings->errors. */
	int		  fflags;
#define	FL_IGN_SCOPE	 (1 << 0) 	/* Ignore scope errors. */
#define	FL_NIGN_ESCAPE	 (1 << 1) 	/* Don't ignore bad escapes. */
#define	FL_NIGN_MACRO	 (1 << 2) 	/* Don't ignore bad macros. */
#define	FL_IGN_ERRORS	 (1 << 4)	/* Ignore failed parse. */
#define	FL_STRICT	  FL_NIGN_ESCAPE | \
			  FL_NIGN_MACRO /* ignore nothing */
d82 20
d178 1
a178 1
	"memory exhausted",
a182 4
static	int		  foptions(int *, char *);
static	struct man	 *man_init(struct curparse *);
static	struct mdoc	 *mdoc_init(struct curparse *);
static	struct roff	 *roff_init(struct curparse *);
d186 1
a186 1
static	int		  pset(const char *, int, struct curparse *,
d191 1
a191 1
static	int		  woptions(int *, char *);
d194 1
a194 2
static	int		  with_fatal;
static	int		  with_error;
d212 1
d215 1
a215 1
	while (-1 != (c = getopt(argc, argv, "f:m:O:T:VW:")))
a216 4
		case ('f'):
			if ( ! foptions(&curp.fflags, optarg))
				return(EXIT_FAILURE);
			break;
d219 1
a219 1
				return(EXIT_FAILURE);
d227 1
a227 1
				return(EXIT_FAILURE);
d230 2
a231 2
			if ( ! woptions(&curp.wflags, optarg))
				return(EXIT_FAILURE);
d253 1
a253 2

		if (with_fatal && !(curp.fflags & FL_IGN_ERRORS))
d267 1
a267 2
	return((with_fatal || with_error) ? 
			EXIT_FAILURE :  EXIT_SUCCESS);
d276 1
a276 1
	exit(EXIT_SUCCESS);
d287 1
a287 47
	exit(EXIT_FAILURE);
}


static struct man *
man_init(struct curparse *curp)
{
	int		 pflags;

	/* Defaults from mandoc.1. */

	pflags = MAN_IGN_MACRO | MAN_IGN_ESCAPE;

	if (curp->fflags & FL_NIGN_MACRO)
		pflags &= ~MAN_IGN_MACRO;
	if (curp->fflags & FL_NIGN_ESCAPE)
		pflags &= ~MAN_IGN_ESCAPE;

	return(man_alloc(&curp->regs, curp, pflags, mmsg));
}


static struct roff *
roff_init(struct curparse *curp)
{

	return(roff_alloc(&curp->regs, mmsg, curp));
}


static struct mdoc *
mdoc_init(struct curparse *curp)
{
	int		 pflags;

	/* Defaults from mandoc.1. */

	pflags = MDOC_IGN_MACRO | MDOC_IGN_ESCAPE;

	if (curp->fflags & FL_IGN_SCOPE)
		pflags |= MDOC_IGN_SCOPE;
	if (curp->fflags & FL_NIGN_ESCAPE)
		pflags &= ~MDOC_IGN_ESCAPE;
	if (curp->fflags & FL_NIGN_MACRO)
		pflags &= ~MDOC_IGN_MACRO;

	return(mdoc_alloc(&curp->regs, curp, pflags, mmsg));
d298 1
a298 1
		with_fatal = 1;
d309 1
a309 1
static int
a311 2
	void *tmp;
	size_t sz;
d313 3
a315 6
	if (buf->sz == 0)
		sz = initial;
	else
		sz = 2 * buf->sz;
	tmp = realloc(buf->buf, sz);
	if (NULL == tmp) {
d317 1
a317 1
		return(0);
a318 3
	buf->buf = tmp;
	buf->sz = sz;
	return(1);
a330 1
		with_fatal = 1;
a344 1
			with_fatal = 1;
d371 1
a371 2
			if (! resize_buf(fb, 65536))
				break;
a386 1
	with_fatal = 1;
d413 2
a414 1
	if ( ! read_whole_file(curp, &blk, &with_mmap))
d416 1
d419 3
a421 3
		curp->roff = roff_init(curp);
	if (NULL == (roff = curp->roff))
		goto bailout;
d444 2
a445 4
				if ( ! mmsg(MANDOCERR_BADCHAR, curp, 
						lnn_start, pos, 
						"ignoring byte"))
					goto bailout;
d453 1
a453 2
					if (! resize_buf(&ln, 256))
						goto bailout;
d485 1
a485 2
				if (! resize_buf(&ln, 256))
					goto bailout;
d492 1
a492 2
			if (! resize_buf(&ln, 256))
				goto bailout;
d510 1
a510 1
		if (ROFF_IGN == re)
d512 4
a515 2
		else if (ROFF_ERR == re)
			goto bailout;
d525 1
a525 2
			if ( ! pset(ln.buf + of, pos - of, curp, &man, &mdoc))
				goto bailout;
d529 8
a536 4
		if (man && ! man_parseln(man, lnn_start, ln.buf, of))
			goto bailout;
		if (mdoc && ! mdoc_parseln(mdoc, lnn_start, ln.buf, of))
			goto bailout;
d539 8
d551 2
a552 1
		goto bailout;
d557 12
a568 6
	if (mdoc && ! mdoc_endparse(mdoc))
		goto bailout;
	if (man && ! man_endparse(man))
		goto bailout;
	if (roff && ! roff_endparse(roff))
		goto bailout;
a643 4

 bailout:
	with_fatal = 1;
	goto cleanup;
d647 1
a647 1
static int
d665 2
a666 2
		if (0 == buf[i])
			return(1);
d672 4
a675 4
			curp->mdoc = mdoc_init(curp);
		if (NULL == (*mdoc = curp->mdoc))
			return(0);
		return(1);
d678 4
a681 4
			curp->man = man_init(curp);
		if (NULL == (*man = curp->man))
			return(0);
		return(1);
d688 4
a691 4
			curp->mdoc = mdoc_init(curp);
		if (NULL == (*mdoc = curp->mdoc))
			return(0);
		return(1);
d695 3
a697 4
		curp->man = man_init(curp);
	if (NULL == (*man = curp->man))
		return(0);
	return(1);
d728 1
a728 2
		curp->wflags |= WARN_WALL;
		curp->fflags |= FL_STRICT;
d750 1
a750 1
foptions(int *fflags, char *arg)
d753 1
a753 1
	const char	*toks[8];
d755 6
a760 7
	toks[0] = "ign-scope";
	toks[1] = "no-ign-escape";
	toks[2] = "no-ign-macro";
	toks[3] = "ign-errors";
	toks[4] = "strict";
	toks[5] = "ign-escape";
	toks[6] = NULL;
d766 1
a766 1
			*fflags |= FL_IGN_SCOPE;
d769 1
a769 2
			*fflags |= FL_NIGN_ESCAPE;
			break;
d771 1
a771 1
			*fflags |= FL_NIGN_MACRO;
d774 1
a774 1
			*fflags |= FL_IGN_ERRORS;
d777 1
a777 4
			*fflags |= FL_STRICT;
			break;
		case (5):
			*fflags &= ~FL_NIGN_ESCAPE;
d780 1
a780 30
			fprintf(stderr, "%s: Bad argument\n", o);
			return(0);
		}
	}

	return(1);
}


static int
woptions(int *wflags, char *arg)
{
	char		*v, *o;
	const char	*toks[3]; 

	toks[0] = "all";
	toks[1] = "error";
	toks[2] = NULL;

	while (*arg) {
		o = arg;
		switch (getsubopt(&arg, UNCONST(toks), &v)) {
		case (0):
			*wflags |= WARN_WALL;
			break;
		case (1):
			*wflags |= WARN_WERR;
			break;
		default:
			fprintf(stderr, "%s: Bad argument\n", o);
d793 5
a797 2
	const char *level;
	int rc;
d800 2
a801 19
	level = NULL;
	rc = 1;

	if (t >= MANDOCERR_FATAL) {
		with_fatal = 1;
		level = "FATAL";
		rc = 0;
	} else {
		if ( ! (WARN_WALL & cp->wflags))
			return(1);
		if (t >= MANDOCERR_ERROR) {
			with_error = 1;
			level = "ERROR";
		}
		if (WARN_WERR & cp->wflags) {
			with_fatal = 1;
			rc = 0;
		}
	}
d803 2
a804 4
	fprintf(stderr, "%s:%d:%d:", cp->file, ln, col + 1);
	if (level)
		fprintf(stderr, " %s:", level);
	fprintf(stderr, " %s", mandocerrs[t]);
d809 4
a812 1
	return(rc);
@


1.43
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.42 2010/07/13 01:09:12 schwarze Exp $ */
d454 1
d497 2
a498 2
			if ( ! isgraph((u_char)blk.buf[i]) &&
					! isblank((u_char)blk.buf[i])) {
@


1.42
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.41 2010/07/01 15:36:59 schwarze Exp $ */
d23 1
d60 2
a61 1
	OUTT_PS
d104 1
d486 20
d623 4
d629 1
a629 1
			curp->outfree = ps_free;
d647 2
d783 2
@


1.41
log
@Improve .Nm indentation in the SYNOPSIS;
kristaps@@ will do the missing HTML part soon.
"looks nicer" jmc@@
"seems perfect to me" sobrado@@
"slap it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.40 2010/06/30 20:29:44 schwarze Exp $ */
d3 2
a4 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
a30 1
#include "regs.h"
d145 1
a151 1
	"missing font type",
@


1.40
log
@improve error reporting:
* avoid error exit code after mere warnings
* add ERROR: and FATAL: to messages when appropriate
* sort the code in mmsg() to make it easier on the eye
* make the mandocerrs[] list easier to maintain
* update a few comments in mandoc.h
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.39 2010/06/29 15:49:52 schwarze Exp $ */
d112 1
a135 1
	"scope broken",
d154 2
a155 1
	"no scope to rewind: syntax violated",
@


1.39
log
@sync to bsd.lv version 1.10.3:
* support -Tps -Opaper=a4 and -Opaper=letter
* lots of mandoc.1 manual improvements
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.38 2010/06/27 21:54:41 schwarze Exp $ */
d91 3
d113 3
d147 3
d183 2
a184 2
static 	int		  with_error;
static	int		  with_warning;
d247 1
a247 1
		if (with_error && !(curp.fflags & FL_IGN_ERRORS))
d261 1
a261 1
	return((with_warning || with_error) ? 
d339 1
a339 1
		with_error = 1;
d380 1
a380 1
		with_error = 1;
d395 1
a395 1
			with_error = 1;
d439 1
a439 1
	with_error = 1;
d655 1
a655 1
	with_error = 1;
d840 2
d844 2
d847 6
a852 2
	if (t <= MANDOCERR_ERROR) {
		if ( ! (cp->wflags & WARN_WALL))
d854 9
a862 6
		with_warning = 1;
	} else
		with_error = 1;

	fprintf(stderr, "%s:%d:%d: %s", cp->file, 
			ln, col + 1, mandocerrs[t]);
d864 4
a869 1

d872 1
a872 8
	/* This is superfluous, but whatever. */
	if (t > MANDOCERR_ERROR)
		return(0);
	if (cp->wflags & WARN_WERR) {
		with_error = 1;
		return(0);
	}
	return(1);
@


1.38
log
@Full .nr nS support, unbreaking the kernel manuals.

Kristaps coded this from scratch after reading my .nr patch;
it is simpler and more powerful.

Registers live in struct regset in regs.h, struct man and struct mdoc
contain pointers to it.  The nS register is cleared when parsing .Sh.
Frontends respect the MDOC_SYNPRETTY flag set in mdoc node_alloc.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.37 2010/06/26 17:56:43 schwarze Exp $ */
d591 1
a591 1
			curp->outdata = ps_alloc();
@


1.37
log
@merge release 1.10.2
* bug fixes:
- interaction of ASCII_HYPH with special chars (found by Ulrich Spoerlein)
- handling of roff conditionals (found by Ulrich Spoerlein)
- .Bd -offset will no more default to 6n
* maintenance:
- more caching of .Bd and .Bl arguments for efficiency
- deconstify man(7) validation routines
- add FreeBSD library names (provided by Ulrich Spoerlein)
* start PostScript font-switching
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.36 2010/06/10 22:50:10 schwarze Exp $ */
d30 2
a34 1
#include "main.h"
d80 1
d291 1
a291 1
	return(man_alloc(curp, pflags, mmsg));
d299 1
a299 1
	return(roff_alloc(mmsg, curp));
d319 1
a319 1
	return(mdoc_alloc(curp, pflags, mmsg));
d448 1
d629 1
@


1.36
log
@minimal initial -Tps support, from kristaps@@ GSOC
so far, monospace without font decoration,
but it already has page headers and footers
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.35 2010/06/08 00:11:47 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d101 1
d136 1
a140 1
	"missing display type",
d142 1
@


1.35
log
@Merge more bits that will be going into 1.10.1:

Clean up vertical spacing in the SYNOPSIS, making the code much more
systematic; this doesn't solve all SYNOPSIS problems yet, in particular
not those related to keeps, indentation and the low-level .nr roff
instruction, but it's a nice step forward and i couldn't find relevant
regressions.  (from kristaps)

Besides,
* make the output width configurable (default: -Owidth=80) (kristaps)
* use mmap with MAP_SHARED (from Joerg Sonnenberger)
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.34 2010/06/06 20:30:08 schwarze Exp $ */
d57 2
a58 1
	OUTT_LINT
a576 3
			curp->outman = html_man;
			curp->outmdoc = html_mdoc;
			curp->outfree = html_free;
d580 17
d605 5
a609 1
		case (OUTT_LINT):
a611 4
			curp->outdata = ascii_alloc(curp->outopts);
			curp->outman = terminal_man;
			curp->outmdoc = terminal_mdoc;
			curp->outfree = terminal_free;
d736 2
@


1.34
log
@Merge bsd.lv version 1.10.1 (to be released soon).

The main step forward is that this now has *much* better .Bl -column
support, now supporting many manuals that previously errored out
without producing any output.

Other fixes include:
* do not die from multiple list types, use the first and warn
* in .Bl without a type, default to -item
* various tweaks to .Dt
* fix .In, .Fd, .Ft, .Fn and .Fo formatting
* some documentation fixes and additions
* and fix a couple of bugs reported by Ulrich Spoerlein:
* better support for roff block-end "\}" without a preceding dot
* .In must not break the line outside SYNOPSIS
* spelling in some error messages

While merging, fix one regression in .In spacing
that needs to go to bsd.lv, too.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.33 2010/05/23 22:45:00 schwarze Exp $ */
d387 1
a387 1
				MAP_FILE, curp->fd, 0);
d593 1
a593 1
			curp->outdata = ascii_alloc(80);
@


1.33
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.32 2010/05/20 00:58:02 schwarze Exp $ */
d89 1
a89 1
	"sections out of conentional order",
a93 1
	"column syntax is inconsistent",
d102 1
a102 1
	"unknown manual sction",
d133 1
d136 1
a138 1
	"missing list type",
@


1.32
log
@Support nested roff instructions:
* allow roff_parseln() to be re-run
* allow roff_parseln() to manipulate the line buffer offset
* support the offset in the man and mdoc libraries
* adapt .if, .ie, .el, .ig, .am* and .de* support
* interpret some instructions even in conditional-negative context
Coded by kristaps during the last day of the mandoc hackathon.

To avoid regressions in the OpenBSD tree, commit this together
with some small local additions:
* detect roff block end "\}" even on macro lines
* actually implement the ".if n" conditional
* ignore .ds, .rm and .tr in libroff

Also back my old .if/.ie/.el-handling out of libman, reverting:
man.h 1.15 man.c 1.25 man_macro.c 1.15 man_validate.c 1.19
man_action.c 1.15 man_term.c 1.28 man_html.c 1.9.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.31 2010/05/16 01:16:25 schwarze Exp $ */
d73 77
a149 11
			  FL_NIGN_MACRO
	enum intt	  inttype;	/* Input parsers... */
	struct man	 *man;
	struct mdoc	 *mdoc;
	struct roff	 *roff;
	enum outt	  outtype;	/* Output devices... */
	out_mdoc	  outmdoc;
	out_man	  	  outman;
	out_free	  outfree;
	void		 *outdata;
	char		  outopts[BUFSIZ];
a157 1
static	int		  merr(void *, int, int, const char *); /* DEPRECATED */
a158 1
static	int		  mwarn(void *, int, int, const char *); /* DEPRECATED */
a275 4
	struct man_cb	 mancb;

	mancb.man_err = merr;
	mancb.man_warn = mwarn;
d286 1
a286 1
	return(man_alloc(curp, pflags, &mancb));
a301 4
	struct mdoc_cb	 mdoccb;

	mdoccb.mdoc_err = merr;
	mdoccb.mdoc_warn = mwarn;
d314 1
a314 1
	return(mdoc_alloc(curp, pflags, &mdoccb));
a803 53
/* ARGSUSED */
static int
merr(void *arg, int line, int col, const char *msg)
{
	struct curparse *curp;

	curp = (struct curparse *)arg;

	(void)fprintf(stderr, "%s:%d:%d: error: %s\n", 
			curp->file, line, col + 1, msg);

	with_error = 1;

	return(0);
}


static int
mwarn(void *arg, int line, int col, const char *msg)
{
	struct curparse *curp;

	curp = (struct curparse *)arg;

	if ( ! (curp->wflags & WARN_WALL))
		return(1);

	(void)fprintf(stderr, "%s:%d:%d: warning: %s\n", 
			curp->file, line, col + 1, msg);

	with_warning = 1;
	if (curp->wflags & WARN_WERR) {
		with_error = 1;
		return(0);
	}

	return(1);
}

static	const char * const	mandocerrs[MANDOCERR_MAX] = {
	"ok",
	"multi-line scope open on exit",
	"request for scope closure when no matching scope is open: ignored",
	"macro requires line argument(s): ignored",
	"line arguments will be lost",
	"memory exhausted"
};

/*
 * XXX: this is experimental code that will eventually become the
 * generic means of covering all warnings and errors!
 */
/* ARGSUSED */
a806 1
#if 0
d811 7
d825 8
a832 1
#endif
@


1.31
log
@allow the single quote as a control character in place of the dot
at all relevant places;
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.30 2010/05/16 00:54:03 schwarze Exp $ */
d378 1
a378 1
	int		 i, pos, lnn, lnn_start, with_mmap;
d459 15
a473 1
		re = roff_parseln(roff, lnn_start, &ln.buf, &ln.sz);
d479 6
a484 1
		/* If unset, assign parser in pset(). */
d486 3
a488 2
		if ( ! (man || mdoc) && ! pset(ln.buf, pos, curp, &man, &mdoc))
			goto bailout;
d490 1
a490 1
		/* Pass down into parsers. */
d492 1
a492 1
		if (man && ! man_parseln(man, lnn_start, ln.buf))
d494 1
a494 1
		if (mdoc && ! mdoc_parseln(mdoc, lnn_start, ln.buf))
d505 2
d790 2
a791 1
	"request for scope closure when no matching scope is open",
@


1.30
log
@In theory, Kristaps never intended to write a roff parser,
but in practice, most real legacy man(7)uals are using so much
low level roff that we can't really get away without at least
partially handling some roff instructions.

As doing this in man(7) only has become messy and as even some
mdoc(7) pages need it, start a minimal partial roff preprocessor.
As a first step, move handling of .am[i], .de[i] and .ig there.
Do not use the roff preprocessor for new manuals!

Now that we have three main parser libraries - roff, man and mdoc -
each one having its own error handling is becoming messy, too.
Thus, start unifying message handling in one central place,
introducing a new generic function mmsg().

coded by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.29 2010/05/15 22:00:22 schwarze Exp $ */
d566 1
a566 1
	if (buf[0] == '.') {
@


1.29
log
@Joerg Sonnenberger rewrote the comment stripping and line merging
to be easier to follow and slightly faster.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.28 2010/05/15 21:09:53 schwarze Exp $ */
d29 1
d32 1
d64 1
d77 1
d91 2
a92 1
static	int		  merr(void *, int, int, const char *);
d94 3
a96 1
static	int		  mwarn(void *, int, int, const char *);
d176 6
d230 8
d329 1
a329 1
		fb->sz = st.st_size;
d355 1
a355 1
		ssz = read(curp->fd, fb->buf + off, fb->sz - off);
d364 1
a364 1
		off += ssz;
d379 1
d382 1
d386 1
d394 1
a394 1
	if (!read_whole_file(curp, &blk, &with_mmap))
d397 5
d457 7
a463 1
		ln.buf[pos] = 0;
d472 1
a472 1
		if (man && ! man_parseln(man, lnn, ln.buf))
d474 1
a474 1
		if (mdoc && ! mdoc_parseln(mdoc, lnn, ln.buf))
d489 2
d531 6
a536 8
	if (curp->mdoc) {
		mdoc_free(curp->mdoc);
		curp->mdoc = NULL;
	}
	if (curp->man) {
		man_free(curp->man);
		curp->man = NULL;
	}
d543 1
d765 31
@


1.28
log
@More systematic output width handling by Joerg Sonnenberger:
* save and restore the output width when switching to MANT_LITERAL
* add an argument to ascii_alloc to specify the output width
* set the default output width to 80 minus 2 characters
* OpenBSD local: set the output width to 65 characters for -man
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.27 2010/05/15 17:32:25 schwarze Exp $ */
d357 1
a357 1
	int		 j, i, pos, lnn, comment, with_mmap;
d366 2
a367 3
	 * Two buffers: ln and buf.  buf is the input buffer optimised
	 * here for each file's block size.  ln is a line buffer.  Both
	 * growable, hence passed in by ptr-ptr.
d373 15
a387 10
	/* Fill buf with file blocksize. */

	for (i = lnn = pos = comment = 0; i < (int)blk.sz; ++i) {
		if (pos >= (int)ln.sz) {
			if (! resize_buf(&ln, 256))
				goto bailout;
		}

		if ('\n' != blk.buf[i]) {
			if (comment)
d389 6
a394 5
			ln.buf[pos++] = blk.buf[i];

			/* Handle in-line `\"' comments. */

			if (1 == pos || '\"' != ln.buf[pos - 1])
a395 15

			for (j = pos - 2; j >= 0; j--)
				if ('\\' != ln.buf[j])
					break;

			if ( ! ((pos - 2 - j) % 2))
				continue;

			comment = 1;
			pos -= 2;
			for (; pos > 0; --pos) {
				if (ln.buf[pos - 1] != ' ')
					break;
				if (pos > 2 && ln.buf[pos - 2] == '\\')
					break;
d397 23
a419 4
			continue;
		} 

		/* Handle escaped `\\n' newlines. */
d421 2
a422 9
		if (pos > 0 && 0 == comment && '\\' == ln.buf[pos - 1]) {
			for (j = pos - 1; j >= 0; j--)
				if ('\\' != ln.buf[j])
					break;
			if ( ! ((pos - j) % 2)) {
				pos--;
				lnn++;
				continue;
			}
d425 3
a428 1
		lnn++;
a433 2

		pos = comment = 0;
@


1.27
log
@Bugfxing and cleanup by Joerg Sonnenberger, edited by kristaps@@:
* Flag errors and warnings in global variables.
* Exit with error code if either is not null on exit.
* Push down the buffers to the functions using them.
* Handle the stdin/file argument in one function.
* Use mmap when possible or else read the whole file into a single buffer.
* Push buffer resizing into its own function.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.26 2010/05/15 15:58:56 schwarze Exp $ */
d476 1
a476 1
			curp->outdata = ascii_alloc();
@


1.26
log
@merge bsd.lv 1.63:
fix stripping of whitespace before trailing comments;
by Joerg Sonnenberger
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.25 2010/05/14 01:54:37 schwarze Exp $ */
d17 2
d69 2
a72 1
	struct man	 *lastman;
a73 1
	struct mdoc	 *lastmdoc;
d82 2
a83 3
#define	FL_STRICT	  FL_NIGN_ESCAPE | \
			  FL_NIGN_MACRO

d85 3
a87 1
static	int		  toptions(struct curparse *, char *);
a88 2
static	int		  woptions(int *, char *);
static	int		  merr(void *, int, int, const char *);
a89 4
static	int		  ffile(struct buf *, struct buf *, 
				const char *, struct curparse *);
static	int		  fdesc(struct buf *, struct buf *,
				struct curparse *);
d92 2
a93 2
static	struct man	 *man_init(struct curparse *);
static	struct mdoc	 *mdoc_init(struct curparse *);
d95 1
a95 1
static	void		  usage(void) __attribute__((noreturn));
d98 2
a99 1

d104 1
a104 2
	int		 c, rc;
	struct buf	 ln, blk;
a151 5
	memset(&ln, 0, sizeof(struct buf));
	memset(&blk, 0, sizeof(struct buf));

	rc = 1;

d156 9
a164 23
		c = fdesc(&blk, &ln, &curp);
		if ( ! (FL_IGN_ERRORS & curp.fflags)) 
			rc = 1 == c ? 1 : 0;
		else
			rc = -1 == c ? 0 : 1;
	}

	while (rc && *argv) {
		c = ffile(&blk, &ln, *argv, &curp);
		if ( ! (FL_IGN_ERRORS & curp.fflags)) 
			rc = 1 == c ? 1 : 0;
		else
			rc = -1 == c ? 0 : 1;

		argv++;
		if (*argv && rc) {
			if (curp.lastman)
				man_reset(curp.lastman);
			if (curp.lastmdoc)
				mdoc_reset(curp.lastmdoc);
			curp.lastman = NULL;
			curp.lastmdoc = NULL;
		}
a166 4
	if (blk.buf)
		free(blk.buf);
	if (ln.buf)
		free(ln.buf);
a168 4
	if (curp.mdoc)
		mdoc_free(curp.mdoc);
	if (curp.man)
		man_free(curp.man);
d170 2
a171 1
	return(rc ? EXIT_SUCCESS : EXIT_FAILURE);
d241 2
a242 3
static int
ffile(struct buf *blk, struct buf *ln, 
		const char *file, struct curparse *curp)
a243 1
	int		 c;
d248 2
a249 1
		return(-1);
d252 1
a252 1
	c = fdesc(blk, ln, curp);
d256 1
d258 19
a276 1
	return(c);
d281 1
a281 1
fdesc(struct buf *blk, struct buf *ln, struct curparse *curp)
d283 2
a284 1
	size_t		 sz;
d286 72
a357 2
	struct stat	 st;
	int		 j, i, pos, lnn, comment;
a360 1
	sz = BUFSIZ;
d363 1
d371 4
a374 4
	if (-1 == fstat(curp->fd, &st))
		perror(curp->file);
	else if ((size_t)st.st_blksize > sz)
		sz = st.st_blksize;
d376 4
a379 5
	if (sz > blk->sz) {
		blk->buf = realloc(blk->buf, sz);
		if (NULL == blk->buf) {
			perror(NULL);
			exit(EXIT_FAILURE);
a380 2
		blk->sz = sz;
	}
d382 4
a385 1
	/* Fill buf with file blocksize. */
d387 1
a387 6
	for (lnn = pos = comment = 0; ; ) {
		if (-1 == (ssz = read(curp->fd, blk->buf, sz))) {
			perror(curp->file);
			return(-1);
		} else if (0 == ssz) 
			break;
d389 2
a390 1
		/* Parse the read block into partial or full lines. */
d392 3
a394 9
		for (i = 0; i < (int)ssz; i++) {
			if (pos >= (int)ln->sz) {
				ln->sz += 256; /* Step-size. */
				ln->buf = realloc(ln->buf, ln->sz);
				if (NULL == ln->buf) {
					perror(NULL);
					return(EXIT_FAILURE);
				}
			}
d396 1
a396 25
			if ('\n' != blk->buf[i]) {
				if (comment)
					continue;
				ln->buf[pos++] = blk->buf[i];

				/* Handle in-line `\"' comments. */

				if (1 == pos || '\"' != ln->buf[pos - 1])
					continue;

				for (j = pos - 2; j >= 0; j--)
					if ('\\' != ln->buf[j])
						break;

				if ( ! ((pos - 2 - j) % 2))
					continue;

				comment = 1;
				pos -= 2;
				for (; pos > 0; --pos) {
					if (ln->buf[pos - 1] != ' ')
						break;
					if (pos > 2 && ln->buf[pos - 2] == '\\')
						break;
				}
a397 1
			} 
d399 12
a410 1
			/* Handle escaped `\\n' newlines. */
d412 8
a419 10
			if (pos > 0 && 0 == comment && 
					'\\' == ln->buf[pos - 1]) {
				for (j = pos - 1; j >= 0; j--)
					if ('\\' != ln->buf[j])
						break;
				if ( ! ((pos - j) % 2)) {
					pos--;
					lnn++;
					continue;
				}
d421 1
d423 2
a424 2
			ln->buf[pos] = 0;
			lnn++;
d426 1
a426 1
			/* If unset, assign parser in pset(). */
d428 2
a429 3
			if ( ! (man || mdoc) && ! pset(ln->buf, 
						pos, curp, &man, &mdoc))
				return(-1);
d431 1
a431 1
			pos = comment = 0;
d433 1
a433 1
			/* Pass down into parsers. */
d435 4
a438 5
			if (man && ! man_parseln(man, lnn, ln->buf))
				return(0);
			if (mdoc && ! mdoc_parseln(mdoc, lnn, ln->buf))
				return(0);
		}
d445 1
a445 1
		return(0);
d449 1
a449 1
		return(0);
d451 1
a451 1
		return(0);
d491 20
a510 1
	return(1);
a541 1
		curp->lastmdoc = *mdoc;
a547 1
		curp->lastman = *man;
a557 1
		curp->lastmdoc = *mdoc;
a564 1
	curp->lastman = *man;
d699 2
d718 7
a724 4
	if ( ! (curp->wflags & WARN_WERR))
		return(1);
	
	return(0);
@


1.25
log
@merge 1.9.24, keeping local patches; some changes:
* preserve multiple consecutive space characters in input
* do not restrict .Cd and .Rv to certain sections (requested by Joerg)
* do not run lookup() on quoted words
* enum return types for mdoc_args and mdoc_argv
* fix auto-closing of LINK tag in -Txhtml (from Daniel Friesel)
* various lint and manual fixes
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.24 2010/05/13 20:34:29 schwarze Exp $ */
d366 1
a366 1
					if (ln->buf[pos] != ' ')
d368 1
a368 1
					if (ln->buf[pos - 1] == '\\')
@


1.24
log
@Remove the command line option -fno-ign-chars.
This option was not useful, you never want mandoc to die
just because there is an invalid character in the input file,
neither in production nor when linting: a warning is sufficient.
This was particularly annoying because it was part of -fstrict
and could not be switched off.
"less is more" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.23 2010/04/13 06:52:12 jmc Exp $ */
d365 6
@


1.23
log
@- sort everything
- prefer Cm to Ar for stuff like -Tascii
- fix wonky ellipsis
- standard $ prompt
- update usage()

kristaps has these diffs rolled in already
ok schwarze kristaps
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.22 2010/03/26 01:22:05 schwarze Exp $ */
a65 1
#define	FL_NIGN_CHARS	 (1 << 3)	/* Don't ignore bad chars. */
d81 1
a81 2
			  FL_NIGN_MACRO | \
 			  FL_NIGN_CHARS
d235 1
a235 1
	pflags = MAN_IGN_MACRO | MAN_IGN_ESCAPE | MAN_IGN_CHARS;
a238 2
	if (curp->fflags & FL_NIGN_CHARS)
		pflags &= ~MAN_IGN_CHARS;
d257 1
a257 1
	pflags = MDOC_IGN_MACRO | MDOC_IGN_ESCAPE | MDOC_IGN_CHARS;
a264 2
	if (curp->fflags & FL_NIGN_CHARS)
		pflags &= ~MDOC_IGN_CHARS;
d569 4
a572 5
	toks[3] = "no-ign-chars";
	toks[4] = "ign-errors";
	toks[5] = "strict";
	toks[6] = "ign-escape";
	toks[7] = NULL;
d587 1
a587 1
			*fflags |= FL_NIGN_CHARS;
d590 1
a590 1
			*fflags |= FL_IGN_ERRORS;
a592 3
			*fflags |= FL_STRICT;
			break;
		case (6):
@


1.22
log
@merge 1.9.17, keeping local patches

* much improved pod2man support and low-level roff robustness
* have -Tlint imply -Wall and -fstrict
* use fewer macros and more enum in libman
* and various bug fixes
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.21 2010/02/18 02:11:26 schwarze Exp $ */
d219 1
a219 1
	(void)fprintf(stderr, "usage: %s [-V] [-foption...] "
d221 1
a221 1
			"[-Werr...]\n", progname);
@


1.21
log
@sync to release 1.9.15:
 * corrected .Vt handling (spotted by Joerg Sonnenberger)
 * corrected .Xr argument handling (based on my patch)
 * removed \\ escape sequence (because it is for low-level roff only)
 * warn about trailing whitespace (suggested by jmc@@)
 * -Txhtml support
 * and some general cleanup and doc improvements
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.20 2009/12/23 22:30:17 schwarze Exp $ */
d63 5
a67 5
#define	IGN_SCOPE	 (1 << 0) 	/* Ignore scope errors. */
#define	NO_IGN_ESCAPE	 (1 << 1) 	/* Don't ignore bad escapes. */
#define	NO_IGN_MACRO	 (1 << 2) 	/* Don't ignore bad macros. */
#define	NO_IGN_CHARS	 (1 << 3)	/* Don't ignore bad chars. */
#define	IGN_ERRORS	 (1 << 4)	/* Ignore failed parse. */
d81 4
d86 1
a86 1
static	int		  toptions(enum outt *, char *);
d139 1
a139 1
			if ( ! toptions(&curp.outtype, optarg))
d167 1
a167 1
		if ( ! (IGN_ERRORS & curp.fflags)) 
d175 1
a175 1
		if ( ! (IGN_ERRORS & curp.fflags)) 
d239 1
a239 1
	if (curp->fflags & NO_IGN_MACRO)
d241 1
a241 1
	if (curp->fflags & NO_IGN_CHARS)
d243 1
a243 1
	if (curp->fflags & NO_IGN_ESCAPE)
d263 1
a263 1
	if (curp->fflags & IGN_SCOPE)
d265 1
a265 1
	if (curp->fflags & NO_IGN_ESCAPE)
d267 1
a267 1
	if (curp->fflags & NO_IGN_MACRO)
d269 1
a269 1
	if (curp->fflags & NO_IGN_CHARS)
d541 1
a541 1
toptions(enum outt *tflags, char *arg)
d545 6
a550 3
		*tflags = OUTT_ASCII;
	else if (0 == strcmp(arg, "lint"))
		*tflags = OUTT_LINT;
d552 1
a552 1
		*tflags = OUTT_TREE;
d554 1
a554 1
		*tflags = OUTT_HTML;
d556 1
a556 1
		*tflags = OUTT_XHTML;
d585 1
a585 1
			*fflags |= IGN_SCOPE;
d588 1
a588 1
			*fflags |= NO_IGN_ESCAPE;
d591 1
a591 1
			*fflags |= NO_IGN_MACRO;
d594 1
a594 1
			*fflags |= NO_IGN_CHARS;
d597 1
a597 1
			*fflags |= IGN_ERRORS;
d600 1
a600 2
			*fflags |= NO_IGN_ESCAPE | 
			 	   NO_IGN_MACRO | NO_IGN_CHARS;
d603 1
a603 1
			*fflags &= ~NO_IGN_ESCAPE;
@


1.20
log
@sync to 1.9.13: minor fixes:

correctness/functionality:
 - bugfix: properly ignore lines with only a dot in -man
 - bugfix: .Bl -ohang doesn't allow -width, warn about this
 - improve date string handling by new function mandoc_a2time
 - some HTML improvements
 - significant documentation additions in man.7 and mdoc.7

portability:
 - replace __dead by __attribute__((noreturn))
 - bugfix: correct .Dx rendering
 - some more library names for NetBSD

simplicity:
 - replace hand-rolled putchar(3)-loops by fwrite(3)
 - replace single-character printf(3) by putchar(3)
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.19 2009/12/22 23:58:00 schwarze Exp $ */
d52 1
d420 6
d548 2
@


1.19
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.18 2009/10/27 21:40:07 schwarze Exp $ */
d94 2
a95 2
__dead	static void	  version(void);
__dead	static void	  usage(void);
d201 1
a201 1
__dead static void
d210 1
a210 1
__dead static void
d521 1
a521 1
		fprintf(stderr, "%s: Bad argument", arg);
d542 1
a542 1
		fprintf(stderr, "%s: Bad argument", arg);
d591 1
a591 1
			fprintf(stderr, "%s: Bad argument", o);
d620 1
a620 1
			fprintf(stderr, "%s: Bad argument", o);
@


1.18
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.17 2009/10/21 19:13:50 schwarze Exp $ */
a19 1
#include <err.h>
d97 1
a97 1
extern	char		 *__progname;
d107 7
a113 1
	bzero(&curp, sizeof(struct curparse));
d152 2
a153 2
	bzero(&ln, sizeof(struct buf));
	bzero(&blk, sizeof(struct buf));
d178 1
a178 2
				if ( ! man_reset(curp.lastman))
					rc = 0;
d180 1
a180 2
				if ( ! mdoc_reset(curp.lastmdoc))
					rc = 0;
d205 1
a205 1
	(void)printf("%s %s\n", __progname, VERSION);
d216 1
a216 1
			"[-Werr...]\n", __progname);
a224 1
	struct man	*man;
d241 1
a241 4
	if (NULL == (man = man_alloc(curp, pflags, &mancb)))
		warnx("memory exhausted");

	return(man);
a248 1
	struct mdoc	*mdoc;
d267 1
a267 4
	if (NULL == (mdoc = mdoc_alloc(curp, pflags, &mdoccb)))
		warnx("memory exhausted");

	return(mdoc);
d279 1
a279 1
		warn("%s", curp->file);
d286 1
a286 1
		warn("%s", curp->file);
d313 1
a313 1
		warn("%s", curp->file);
d320 2
a321 2
			warn("realloc");
			return(-1);
d330 1
a330 1
			warn("%s", curp->file);
d342 2
a343 2
					warn("realloc");
					return(-1);
d406 1
a406 2
		(void)fprintf(stderr, "%s: not a manual\n", 
				curp->file);
d521 1
a521 1
		warnx("bad argument: -m%s", arg);
d542 1
a542 1
		warnx("bad argument: -T%s", arg);
d554 1
a554 1
	const char	*toks[7];
d562 2
a563 1
	toks[6] = NULL;
d587 3
d591 1
a591 1
			warnx("bad argument: -f%s", o);
d620 1
a620 1
			warnx("bad argument: -W%s", o);
@


1.17
log
@sync to 1.9.9, featuring:
 * -Thtml output mode
 * roff scaling units
 * and some minor fixes
for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.16 2009/09/21 20:57:57 schwarze Exp $ */
d78 1
a78 1
	char		 *outopts;
d114 1
a114 1
	while (-1 != (c = getopt(argc, argv, "f:m:o:T:VW:")))
d124 3
a126 2
		case ('o'):
			curp.outopts = optarg;
d212 2
a213 2
			"[-mformat] [-Toutput] [-Werr...]\n", 
			__progname);
@


1.16
log
@sync to 1.9.5: make terminal_*, tree_* and out_* functions return void,
making the code simpler
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.15 2009/08/22 17:21:23 schwarze Exp $ */
d23 1
d30 3
d52 1
d78 1
a80 7
extern	void		 *ascii_alloc(void);
extern	void		  tree_mdoc(void *, const struct mdoc *);
extern	void		  tree_man(void *, const struct man *);
extern	void		  terminal_mdoc(void *, const struct mdoc *);
extern	void		  terminal_man(void *, const struct man *);
extern	void		  terminal_free(void *);

d114 1
a114 1
	while (-1 != (c = getopt(argc, argv, "f:m:VW:T:")))
d124 3
d424 6
d544 2
d559 1
a559 1
	char		*toks[7];
d571 1
a571 1
		switch (getsubopt(&arg, toks, &v)) {
d605 1
a605 1
	char		*toks[3]; 
d613 1
a613 1
		switch (getsubopt(&arg, toks, &v)) {
@


1.15
log
@sync to 1.8.5: Error string is now file:line:col: message.
Fixed column reporting (off by one).
Use fprintf instead of warnx for parse errors (like cc).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.14 2009/08/22 14:56:03 schwarze Exp $ */
d30 2
a31 2
typedef	int		(*out_mdoc)(void *, const struct mdoc *);
typedef	int		(*out_man)(void *, const struct man *);
d76 4
a79 4
extern	int		  tree_mdoc(void *, const struct mdoc *);
extern	int		  tree_man(void *, const struct man *);
extern	int		  terminal_mdoc(void *, const struct mdoc *);
extern	int		  terminal_man(void *, const struct man *);
d440 1
a440 2
		if ( ! (*curp->outman)(curp->outdata, man))
			return(-1);
d442 1
a442 2
		if ( ! (*curp->outmdoc)(curp->outdata, mdoc))
			return(-1);
@


1.14
log
@sync to 1.8.4: add option -fign-errors to check several manual pages
without stopping at errors
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.13 2009/07/12 22:44:45 schwarze Exp $ */
d408 2
a409 1
		warnx("%s: not a manual", curp->file);
d630 2
a631 2
	warnx("%s:%d: error: %s (column %d)", 
			curp->file, line, msg, col);
d647 2
a648 2
	warnx("%s:%d: warning: %s (column %d)", 
			curp->file, line, msg, col);
a652 1
	warnx("considering warnings as errors");
@


1.13
log
@sync to 1.7.23: Fewer knobs: provide -Wall -Werror but not -Wsyntax -Wcompat.
The simplification of the internal code has already been done before,
this is just the user interface adjustment.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.12 2009/07/12 18:28:29 schwarze Exp $ */
d62 1
d152 6
a157 2
		if ( ! fdesc(&blk, &ln, &curp))
			rc = 0;
d161 6
a166 2
		if ( ! ffile(&blk, &ln, *argv, &curp))
			rc = 0;
d282 1
a282 1
		return(0);
d323 1
a323 1
			return(0);
d333 1
a333 1
			return(0);
d345 1
a345 1
					return(0);
d392 1
a392 1
				return(0);
d440 1
a440 1
			return(0);
d443 1
a443 1
			return(0);
d550 1
a550 1
	char		*toks[6];
d556 3
a558 2
	toks[4] = "strict";
	toks[5] = NULL;
d576 3
@


1.12
log
@sync to 1.7.23: first step to get rid of enum mdoc_warn:
unify manwarn() and mdocwarn() into mwarn()
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.11 2009/07/07 00:54:46 schwarze Exp $ */
d55 1
a55 3
#define	WARN_WALL	  0x03		/* All-warnings mask. */
#define	WARN_WCOMPAT	 (1 << 0)	/* Compatibility warnings. */
#define	WARN_WSYNTAX	 (1 << 1)	/* Syntax warnings. */
d583 1
a583 1
	char		*toks[5]; 
d586 2
a587 4
	toks[1] = "compat";
	toks[2] = "syntax";
	toks[3] = "error";
	toks[4] = NULL;
a595 6
			*wflags |= WARN_WCOMPAT;
			break;
		case (2):
			*wflags |= WARN_WSYNTAX;
			break;
		case (3):
d615 1
@


1.11
log
@sync to 1.7.21: provide WESCAPE and MAN_IGN_ESCAPE,
to be used soon in man_validate.c
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.10 2009/07/07 00:16:21 schwarze Exp $ */
d88 1
a88 3
static	int		  manwarn(void *, int, int, const char *);
static	int		  mdocwarn(void *, int, int, 
				enum mdoc_warn, const char *);
d216 1
a216 1
	mancb.man_warn = manwarn;
d244 1
a244 1
	mdoccb.mdoc_warn = mdocwarn;
d633 1
a633 2
mdocwarn(void *arg, int line, int col, 
		enum mdoc_warn type, const char *msg)
a635 1
	char		*wtype;
a637 1
	wtype = NULL;
d639 1
a639 10
	switch (type) {
	case (WARN_COMPAT):
		wtype = "compat";
		if (curp->wflags & WARN_WCOMPAT)
			break;
		return(1);
	case (WARN_SYNTAX):
		wtype = "syntax";
		if (curp->wflags & WARN_WSYNTAX)
			break;
a640 1
	}
d642 2
a643 3
	assert(wtype);
	warnx("%s:%d: %s warning: %s (column %d)", 
			curp->file, line, wtype, msg, col);
a651 20

static int
manwarn(void *arg, int line, int col, const char *msg)
{
	struct curparse *curp;

	curp = (struct curparse *)arg;

	if ( ! (curp->wflags & WARN_WSYNTAX))
		return(1);

	warnx("%s:%d: syntax warning: %s (column %d)", 
			curp->file, line, msg, col);

	if ( ! (curp->wflags & WARN_WERR))
		return(1);

	warnx("considering warnings as errors");
	return(0);
}
@


1.10
log
@sync to 1.7.21: suboptarg is not portable to Linux;
no functional change on OpenBSD
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.9 2009/07/06 22:12:38 schwarze Exp $ */
d222 1
a222 1
	pflags = MAN_IGN_MACRO | MAN_IGN_CHARS;
d228 2
@


1.9
log
@(1) exit with failure not success if options parsing fails;
(2) use warn not warnx if fstat fails;
(3) getsubopt modifies arg, so printing it on error will print
    the wrong thing: use suboptarg instead.
from nicm@@
ok kristaps@@   and contained in 1.7.21
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.8 2009/06/23 22:31:26 schwarze Exp $ */
d542 1
a542 1
	char		*v;
d552 2
a553 1
	while (*arg) 
d572 1
a572 1
			warnx("bad argument: -f%s", suboptarg);
d575 1
d584 1
a584 1
	char		*v;
d593 2
a594 1
	while (*arg) 
d609 1
a609 1
			warnx("bad argument: -W%s", suboptarg);
d612 1
@


1.8
log
@sync to 1.7.20: root and text validation for -man
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.7 2009/06/21 20:10:31 schwarze Exp $ */
d122 1
a122 1
				return(0);
d126 1
a126 1
				return(0);
d130 1
a130 1
				return(0);
d134 1
a134 1
				return(0);
d308 1
a308 1
		warnx("%s", curp->file);
d571 1
a571 1
			warnx("bad argument: -f%s", arg);
d606 1
a606 1
			warnx("bad argument: -W%s", arg);
@


1.7
log
@sync to 1.7.19: the static function fstdin was called from exactly one place
and did so little that it was better merged into main()
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.6 2009/06/18 23:51:12 schwarze Exp $ */
d222 1
a222 1
	pflags = MAN_IGN_MACRO;
d226 2
@


1.6
log
@sync to 1.7.19: comment cleanup; no functional change
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.5 2009/06/18 23:34:53 schwarze Exp $ */
a90 2
static	int		  fstdin(struct buf *, struct buf *, 
				struct curparse *);
d152 4
a155 2
	if (NULL == *argv)
		if ( ! fstdin(&blk, &ln, &curp))
d157 1
a260 10
}


static int
fstdin(struct buf *blk, struct buf *ln, struct curparse *curp)
{

	curp->file = "<stdin>";
	curp->fd = STDIN_FILENO;
	return(fdesc(blk, ln, curp));
@


1.5
log
@sync to 1.7.19: improved comment handling
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.4 2009/06/18 22:16:56 schwarze Exp $ */
d64 1
a64 1
	enum intt	  inttype;	/* Input parsers. */
d69 1
a69 1
	enum outt	  outtype;	/* Output devices. */
a148 2
	/* Configure buffers. */

a177 2

	/* TODO: have a curp_free routine. */
d219 1
a219 4
	/*
	 * Default behaviour is to ignore unknown macros.  This is
	 * specified in mandoc.1.
	 */
a222 2
	/* Override default behaviour... */

d243 1
a243 5
	/* 
	 * Default behaviour is to ignore unknown macros, escape
	 * sequences and characters (very liberal).  This is specified
	 * in mandoc.1.
	 */
a246 2
	/* Override default behaviour... */

a545 4
/*
 * Parse out the options for [-fopt...] setting compiler options.  These
 * can be comma-delimited or called again.
 */
a585 4
/* 
 * Parse out the options for [-Werr...], which sets warning modes.
 * These can be comma-delimited or called again.  
 */
a630 1
	/* Always exit on errors... */
d665 1
a665 7
	/*
	 * If the -Werror flag is passed in, as in gcc, then all
	 * warnings are considered as errors.
	 */

	warnx("%s: considering warnings as errors", 
			__progname);
d686 1
a686 7
	/* 
	 * If the -Werror flag is passed in, as in gcc, then all
	 * warnings are considered as errors.
	 */

	warnx("%s: considering warnings as errors", 
			__progname);
@


1.4
log
@complete sync to 1.7.17: garbage collect unused functions
mdoc_msg, mdoc_pmsg, mdoc_vmsg, and mdoc_nwarn
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.3 2009/06/14 23:39:43 schwarze Exp $ */
d315 1
a315 1
	int		 j, i, pos, lnn;
d345 1
a345 1
	for (lnn = 0, pos = 0; ; ) {
d365 2
d368 15
d384 1
a384 1
			}
d386 1
a386 1
			/* Check for CPP-escaped newline. */
d388 2
a389 1
			if (pos > 0 && '\\' == ln->buf[pos - 1]) {
a392 1

d402 2
a403 7
			
			/*
			 * If no manual parser has been assigned, then
			 * try to assign one in pset(), which may do
			 * nothing at all.  After this, parse the manual
			 * line accordingly.
			 */
d409 3
a411 1
			pos = 0;
d420 1
a420 1
	/* Note that a parser may not have been assigned, yet. */
d432 1
a432 6
	/*
	 * If an output device hasn't been allocated, see if we should
	 * do so now.  Note that not all outtypes have functions, so
	 * this switch statement may be superfluous, but it's
	 * low-overhead enough not to matter very much.
	 */
d468 1
d474 1
a474 1
	 * line: either skip comments, use -mdoc when finding `.Dt', or
d478 7
a484 2
	if (pos >= 3 && 0 == memcmp(buf, ".\\\"", 3))
		return(1);
@


1.3
log
@sync to 1.7.16: support -V command line option
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.2 2009/06/14 23:00:57 schwarze Exp $ */
a248 1
	mdoccb.mdoc_msg = NULL;
@


1.2
log
@sync to 1.7.16: comments, whitespace and spelling fixes; no functional change
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.27 2009/06/11 12:07:49 kristaps Exp $ */
d101 1
d120 1
a120 1
	while (-1 != (c = getopt(argc, argv, "f:m:W:T:")))
d138 3
d194 9
d206 1
a206 1
	(void)fprintf(stderr, "usage: %s [-foption...] "
@


1.1
log
@Initial check-in of mandoc for formatting manuals. ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.23 2009/04/03 12:27:18 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d176 2
d210 8
a217 1
	pflags = MAN_IGN_MACRO; 
d240 6
d248 2
d357 1
a357 1
			/* Check for CPP-escaped newline.  */
a623 1

d626 2
d661 5
d688 5
@

