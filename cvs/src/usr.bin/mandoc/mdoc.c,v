head	1.157;
access;
symbols
	OPENBSD_6_2_BASE:1.157
	OPENBSD_6_1:1.150.0.4
	OPENBSD_6_1_BASE:1.150
	OPENBSD_6_0:1.145.0.4
	OPENBSD_6_0_BASE:1.145
	OPENBSD_5_9:1.145.0.2
	OPENBSD_5_9_BASE:1.145
	OPENBSD_5_8:1.141.0.4
	OPENBSD_5_8_BASE:1.141
	OPENBSD_5_7:1.127.0.2
	OPENBSD_5_7_BASE:1.127
	OPENBSD_5_6:1.110.0.4
	OPENBSD_5_6_BASE:1.110
	OPENBSD_5_5:1.98.0.4
	OPENBSD_5_5_BASE:1.98
	OPENBSD_5_4:1.93.0.4
	OPENBSD_5_4_BASE:1.93
	OPENBSD_5_3:1.93.0.2
	OPENBSD_5_3_BASE:1.93
	OPENBSD_5_2:1.91.0.2
	OPENBSD_5_2_BASE:1.91
	OPENBSD_5_1_BASE:1.86
	OPENBSD_5_1:1.86.0.2
	OPENBSD_5_0:1.83.0.2
	OPENBSD_5_0_BASE:1.83
	OPENBSD_4_9:1.79.0.2
	OPENBSD_4_9_BASE:1.79
	OPENBSD_4_8:1.63.0.2
	OPENBSD_4_8_BASE:1.63
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10;
locks; strict;
comment	@ * @;


1.157
date	2017.08.11.16.55.10;	author schwarze;	state Exp;
branches;
next	1.156;
commitid	Amu3twqWdancYV4o;

1.156
date	2017.06.17.13.05.47;	author schwarze;	state Exp;
branches;
next	1.155;
commitid	Ex4Q2DsetOpdg5C3;

1.155
date	2017.06.07.20.58.36;	author schwarze;	state Exp;
branches;
next	1.154;
commitid	biLiHPe70cnepoqn;

1.154
date	2017.06.07.20.30.13;	author schwarze;	state Exp;
branches;
next	1.153;
commitid	g9LCUHMnMMqarmzd;

1.153
date	2017.05.05.15.16.25;	author schwarze;	state Exp;
branches;
next	1.152;
commitid	sNJdFUhzoVfGBx2p;

1.152
date	2017.04.29.12.43.55;	author schwarze;	state Exp;
branches;
next	1.151;
commitid	7BLUwozNEzUO8xfK;

1.151
date	2017.04.24.23.06.09;	author schwarze;	state Exp;
branches;
next	1.150;
commitid	2CfzvK3gmiJH7vY0;

1.150
date	2017.03.03.13.55.06;	author schwarze;	state Exp;
branches;
next	1.149;
commitid	ebZHhO3JQ20kqPTN;

1.149
date	2017.02.16.02.59.42;	author schwarze;	state Exp;
branches;
next	1.148;
commitid	Qmey25xun8rVuoB9;

1.148
date	2017.01.28.23.26.56;	author schwarze;	state Exp;
branches;
next	1.147;
commitid	7sT9Hxn0lUNOlacH;

1.147
date	2017.01.10.13.46.53;	author schwarze;	state Exp;
branches;
next	1.146;
commitid	aFt8sLe7F06PjFYh;

1.146
date	2016.08.20.14.43.39;	author schwarze;	state Exp;
branches;
next	1.145;
commitid	epkxu6NfanH6WQ2U;

1.145
date	2015.10.30.19.03.36;	author schwarze;	state Exp;
branches;
next	1.144;
commitid	B2ZxW3H5UgZIgEOi;

1.144
date	2015.10.20.02.00.49;	author schwarze;	state Exp;
branches;
next	1.143;
commitid	v6RrmxwM663z4mTF;

1.143
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.142;
commitid	Ql2ha5NS80pwfGNT;

1.142
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.141;
commitid	hxQV8O1pNUaef4ir;

1.141
date	2015.04.23.16.17.04;	author schwarze;	state Exp;
branches;
next	1.140;
commitid	DWHgiJTn6DvDpekX;

1.140
date	2015.04.23.15.35.39;	author schwarze;	state Exp;
branches;
next	1.139;
commitid	am2zU0fu81iRKMOO;

1.139
date	2015.04.19.14.57.16;	author schwarze;	state Exp;
branches;
next	1.138;
commitid	FaoA4UzPphKw0cyB;

1.138
date	2015.04.19.14.25.05;	author schwarze;	state Exp;
branches;
next	1.137;
commitid	E1gJfKuheBoo64Vb;

1.137
date	2015.04.19.13.59.37;	author schwarze;	state Exp;
branches;
next	1.136;
commitid	aS3h5dIgZk0f7675;

1.136
date	2015.04.19.13.50.10;	author schwarze;	state Exp;
branches;
next	1.135;
commitid	QSaLMe5iBgPB4hUe;

1.135
date	2015.04.18.17.50.02;	author schwarze;	state Exp;
branches;
next	1.134;
commitid	sjmmdLSx1e3Vat0h;

1.134
date	2015.04.18.17.28.08;	author schwarze;	state Exp;
branches;
next	1.133;
commitid	zD52rmYwzwgofy8v;

1.133
date	2015.04.18.17.01.28;	author schwarze;	state Exp;
branches;
next	1.132;
commitid	GslLZJxifCkaUipL;

1.132
date	2015.04.18.16.34.03;	author schwarze;	state Exp;
branches;
next	1.131;
commitid	PxhkeHVIvdTMOTs6;

1.131
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.130;
commitid	6MYJ7cd8mhJ77AGH;

1.130
date	2015.04.02.23.47.43;	author schwarze;	state Exp;
branches;
next	1.129;
commitid	RJFkOLiS9gBqEEDl;

1.129
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.128;
commitid	Rfx1oTaH3hZ7Zcyf;

1.128
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.127;
commitid	lmErjWY2O9ooA6RY;

1.127
date	2015.02.12.13.00.27;	author schwarze;	state Exp;
branches;
next	1.126;
commitid	iMgtO2LMSIEj6vCq;

1.126
date	2015.02.12.12.20.47;	author schwarze;	state Exp;
branches;
next	1.125;
commitid	SViaEKzwzmf0o0kW;

1.125
date	2015.02.05.00.13.34;	author schwarze;	state Exp;
branches;
next	1.124;
commitid	yNql0K85SrSgftGW;

1.124
date	2015.02.02.04.26.03;	author schwarze;	state Exp;
branches;
next	1.123;
commitid	aVQDMaIveEZUjjaV;

1.123
date	2015.01.15.04.26.06;	author schwarze;	state Exp;
branches;
next	1.122;
commitid	TgtfgXU8Rz8XgmeH;

1.122
date	2014.11.28.06.26.46;	author schwarze;	state Exp;
branches;
next	1.121;
commitid	M5K1YnX7vRaFkPkc;

1.121
date	2014.11.28.04.46.30;	author schwarze;	state Exp;
branches;
next	1.120;
commitid	epKhps1CyqFfkqD1;

1.120
date	2014.11.28.03.13.58;	author schwarze;	state Exp;
branches;
next	1.119;
commitid	ImMvSGeZONzvc96J;

1.119
date	2014.11.28.01.05.40;	author schwarze;	state Exp;
branches;
next	1.118;
commitid	AyxWGi7Dr0LL0dRV;

1.118
date	2014.11.19.03.07.43;	author schwarze;	state Exp;
branches;
next	1.117;
commitid	DMACP9kwk2BHECLD;

1.117
date	2014.10.20.15.49.45;	author schwarze;	state Exp;
branches;
next	1.116;
commitid	xAL9AbgdIC6Bgc5x;

1.116
date	2014.10.20.02.31.44;	author schwarze;	state Exp;
branches;
next	1.115;
commitid	jVScYQL5VkcOk52z;

1.115
date	2014.10.16.01.10.06;	author schwarze;	state Exp;
branches;
next	1.114;
commitid	3N6FMKugsVoc1dko;

1.114
date	2014.09.06.23.24.27;	author schwarze;	state Exp;
branches;
next	1.113;
commitid	cVS8Yl9euSk9Ay5F;

1.113
date	2014.08.08.16.17.09;	author schwarze;	state Exp;
branches;
next	1.112;
commitid	TLMAnDXVMoqLltgG;

1.112
date	2014.08.08.15.54.10;	author schwarze;	state Exp;
branches;
next	1.111;
commitid	yBKHNskikm52fHMo;

1.111
date	2014.08.08.15.32.17;	author schwarze;	state Exp;
branches;
next	1.110;
commitid	MxwVmw5souguneqK;

1.110
date	2014.07.09.11.30.07;	author schwarze;	state Exp;
branches;
next	1.109;
commitid	WErJgzRtDKBz19TC;

1.109
date	2014.07.07.15.03.24;	author schwarze;	state Exp;
branches;
next	1.108;
commitid	LD7wx5yJuIhKJiro;

1.108
date	2014.07.06.19.08.56;	author schwarze;	state Exp;
branches;
next	1.107;
commitid	rolX8OitNNoUBJoD;

1.107
date	2014.07.02.03.47.07;	author schwarze;	state Exp;
branches;
next	1.106;
commitid	p4pNII1v0bYCswy0;

1.106
date	2014.07.01.22.36.35;	author schwarze;	state Exp;
branches;
next	1.105;
commitid	6SNWblzmBTWk9YRA;

1.105
date	2014.06.20.17.23.09;	author schwarze;	state Exp;
branches;
next	1.104;
commitid	gTaF7NL9JpgvI2ni;

1.104
date	2014.04.25.14.10.59;	author schwarze;	state Exp;
branches;
next	1.103;

1.103
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.102;

1.102
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.101;

1.101
date	2014.03.23.12.44.18;	author schwarze;	state Exp;
branches;
next	1.100;

1.100
date	2014.03.21.22.52.21;	author schwarze;	state Exp;
branches;
next	1.99;

1.99
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.98;

1.98
date	2014.01.05.20.26.27;	author schwarze;	state Exp;
branches;
next	1.97;

1.97
date	2013.12.30.00.52.18;	author schwarze;	state Exp;
branches;
next	1.96;

1.96
date	2013.12.24.19.10.34;	author schwarze;	state Exp;
branches;
next	1.95;

1.95
date	2013.10.21.23.32.32;	author schwarze;	state Exp;
branches;
next	1.94;

1.94
date	2013.10.03.19.32.25;	author schwarze;	state Exp;
branches;
next	1.93;

1.93
date	2012.11.17.00.25.20;	author schwarze;	state Exp;
branches;
next	1.92;

1.92
date	2012.11.16.13.25.34;	author schwarze;	state Exp;
branches;
next	1.91;

1.91
date	2012.07.18.11.09.30;	author schwarze;	state Exp;
branches;
next	1.90;

1.90
date	2012.07.18.10.36.20;	author schwarze;	state Exp;
branches;
next	1.89;

1.89
date	2012.07.16.09.51.03;	author schwarze;	state Exp;
branches;
next	1.88;

1.88
date	2012.07.07.18.27.36;	author schwarze;	state Exp;
branches;
next	1.87;

1.87
date	2012.05.24.23.33.23;	author schwarze;	state Exp;
branches;
next	1.86;

1.86
date	2011.09.30.00.13.21;	author schwarze;	state Exp;
branches;
next	1.85;

1.85
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.84;

1.84
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.83;

1.83
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.81;

1.81
date	2011.03.20.23.36.42;	author schwarze;	state Exp;
branches;
next	1.80;

1.80
date	2011.03.07.01.35.33;	author schwarze;	state Exp;
branches;
next	1.79;

1.79
date	2011.02.10.00.06.30;	author schwarze;	state Exp;
branches;
next	1.78;

1.78
date	2011.01.09.13.16.48;	author schwarze;	state Exp;
branches;
next	1.77;

1.77
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.76;

1.76
date	2011.01.01.17.38.11;	author schwarze;	state Exp;
branches;
next	1.75;

1.75
date	2010.12.29.00.47.30;	author schwarze;	state Exp;
branches;
next	1.74;

1.74
date	2010.12.26.21.04.19;	author schwarze;	state Exp;
branches;
next	1.73;

1.73
date	2010.12.21.23.57.31;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2010.12.21.23.46.17;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2010.12.02.19.42.47;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2010.12.01.22.02.29;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2010.11.28.19.35.33;	author schwarze;	state Exp;
branches;
next	1.68;

1.68
date	2010.10.16.20.49.37;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2010.10.16.13.38.29;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2010.09.27.21.25.28;	author schwarze;	state Exp;
branches;
next	1.65;

1.65
date	2010.08.20.00.53.35;	author schwarze;	state Exp;
branches;
next	1.64;

1.64
date	2010.08.18.01.17.44;	author schwarze;	state Exp;
branches;
next	1.63;

1.63
date	2010.08.07.18.06.45;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2010.07.16.00.34.33;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2010.07.01.22.31.52;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.29.17.10.29;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2010.06.27.21.54.42;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2010.06.26.17.56.43;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2010.06.06.20.30.08;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2010.05.26.02.39.58;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2010.05.23.22.45.00;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2010.05.20.00.58.02;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2010.05.16.20.46.15;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2010.05.16.01.16.25;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2010.05.15.18.25.51;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2010.05.15.16.48.12;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2010.05.14.19.52.43;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2010.05.14.14.47.44;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.14.01.54.37;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.08.01.57.33;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2010.05.08.01.52.07;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2010.05.04.23.13.54;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2010.04.27.21.53.27;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.22.21.42.08;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2010.04.07.23.15.05;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2010.04.04.20.14.35;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.03.16.24.17;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2010.04.02.12.39.47;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2010.03.25.02.02.28;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2010.03.02.00.38.59;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2010.02.18.02.11.26;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2010.01.02.02.42.06;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.21.19.13.50;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.19.16.27.52;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.19.10.20.24;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2009.09.21.21.11.37;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.18.22.37.05;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.22.21.55.06;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.22.19.43.33;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.22.17.21.24;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.26.22.48.41;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.26.02.17.29;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.26.01.59.46;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.26.00.11.15;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.18.19.44.38;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.12.22.35.08;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.12.21.45.44;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.12.21.08.29;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.12.20.30.27;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.12.19.05.52;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.12.18.35.57;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.12.18.28.29;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.23.23.02.54;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.19.07.20.19;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.18.23.51.12;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.18.23.34.53;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.18.22.16.56;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.15.18.41.13;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.15.02.19.32;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.14.23.00.57;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.04.15.20.10.20;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.20.30.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.157
log
@Make the "new sentence, new line" check stricter, allowing digits
in the last two letters of the last word of the sentence.
No false positives in base or Xenocara.
Suggested by and OK jmc@@.
@
text
@/*	$OpenBSD: mdoc.c,v 1.156 2017/06/17 13:05:47 schwarze Exp $ */
/*
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010, 2012-2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "libmandoc.h"
#include "roff_int.h"
#include "libmdoc.h"

const	char *const __mdoc_argnames[MDOC_ARG_MAX] = {
	"split",		"nosplit",		"ragged",
	"unfilled",		"literal",		"file",
	"offset",		"bullet",		"dash",
	"hyphen",		"item",			"enum",
	"tag",			"diag",			"hang",
	"ohang",		"inset",		"column",
	"width",		"compact",		"std",
	"filled",		"words",		"emphasis",
	"symbolic",		"nested",		"centered"
};
const	char * const *mdoc_argnames = __mdoc_argnames;

static	int		  mdoc_ptext(struct roff_man *, int, char *, int);
static	int		  mdoc_pmacro(struct roff_man *, int, char *, int);


/*
 * Main parse routine.  Parses a single line -- really just hands off to
 * the macro (mdoc_pmacro()) or text parser (mdoc_ptext()).
 */
int
mdoc_parseln(struct roff_man *mdoc, int ln, char *buf, int offs)
{

	if (mdoc->last->type != ROFFT_EQN || ln > mdoc->last->line)
		mdoc->flags |= MDOC_NEWLINE;

	/*
	 * Let the roff nS register switch SYNOPSIS mode early,
	 * such that the parser knows at all times
	 * whether this mode is on or off.
	 * Note that this mode is also switched by the Sh macro.
	 */
	if (roff_getreg(mdoc->roff, "nS"))
		mdoc->flags |= MDOC_SYNOPSIS;
	else
		mdoc->flags &= ~MDOC_SYNOPSIS;

	return roff_getcontrol(mdoc->roff, buf, &offs) ?
	    mdoc_pmacro(mdoc, ln, buf, offs) :
	    mdoc_ptext(mdoc, ln, buf, offs);
}

void
mdoc_macro(MACRO_PROT_ARGS)
{
	assert(tok >= MDOC_Dd && tok < MDOC_MAX);
	(*mdoc_macros[tok].fp)(mdoc, tok, line, ppos, pos, buf);
}

void
mdoc_tail_alloc(struct roff_man *mdoc, int line, int pos, enum roff_tok tok)
{
	struct roff_node *p;

	p = roff_node_alloc(mdoc, line, pos, ROFFT_TAIL, tok);
	roff_node_append(mdoc, p);
	mdoc->next = ROFF_NEXT_CHILD;
}

struct roff_node *
mdoc_endbody_alloc(struct roff_man *mdoc, int line, int pos,
    enum roff_tok tok, struct roff_node *body)
{
	struct roff_node *p;

	body->flags |= NODE_ENDED;
	body->parent->flags |= NODE_ENDED;
	p = roff_node_alloc(mdoc, line, pos, ROFFT_BODY, tok);
	p->body = body;
	p->norm = body->norm;
	p->end = ENDBODY_SPACE;
	roff_node_append(mdoc, p);
	mdoc->next = ROFF_NEXT_SIBLING;
	return p;
}

struct roff_node *
mdoc_block_alloc(struct roff_man *mdoc, int line, int pos,
    enum roff_tok tok, struct mdoc_arg *args)
{
	struct roff_node *p;

	p = roff_node_alloc(mdoc, line, pos, ROFFT_BLOCK, tok);
	p->args = args;
	if (p->args)
		(args->refcnt)++;

	switch (tok) {
	case MDOC_Bd:
	case MDOC_Bf:
	case MDOC_Bl:
	case MDOC_En:
	case MDOC_Rs:
		p->norm = mandoc_calloc(1, sizeof(union mdoc_data));
		break;
	default:
		break;
	}
	roff_node_append(mdoc, p);
	mdoc->next = ROFF_NEXT_CHILD;
	return p;
}

void
mdoc_elem_alloc(struct roff_man *mdoc, int line, int pos,
     enum roff_tok tok, struct mdoc_arg *args)
{
	struct roff_node *p;

	p = roff_node_alloc(mdoc, line, pos, ROFFT_ELEM, tok);
	p->args = args;
	if (p->args)
		(args->refcnt)++;

	switch (tok) {
	case MDOC_An:
		p->norm = mandoc_calloc(1, sizeof(union mdoc_data));
		break;
	default:
		break;
	}
	roff_node_append(mdoc, p);
	mdoc->next = ROFF_NEXT_CHILD;
}

void
mdoc_node_relink(struct roff_man *mdoc, struct roff_node *p)
{

	roff_node_unlink(mdoc, p);
	p->prev = p->next = NULL;
	roff_node_append(mdoc, p);
}

/*
 * Parse free-form text, that is, a line that does not begin with the
 * control character.
 */
static int
mdoc_ptext(struct roff_man *mdoc, int line, char *buf, int offs)
{
	struct roff_node *n;
	const char	 *cp, *sp;
	char		 *c, *ws, *end;

	n = mdoc->last;

	/*
	 * If a column list contains plain text, assume an implicit item
	 * macro.  This can happen one or more times at the beginning
	 * of such a list, intermixed with non-It mdoc macros and with
	 * nodes generated on the roff level, for example by tbl.
	 */

	if ((n->tok == MDOC_Bl && n->type == ROFFT_BODY &&
	     n->end == ENDBODY_NOT && n->norm->Bl.type == LIST_column) ||
	    (n->parent != NULL && n->parent->tok == MDOC_Bl &&
	     n->parent->norm->Bl.type == LIST_column)) {
		mdoc->flags |= MDOC_FREECOL;
		mdoc_macro(mdoc, MDOC_It, line, offs, &offs, buf);
		return 1;
	}

	/*
	 * Search for the beginning of unescaped trailing whitespace (ws)
	 * and for the first character not to be output (end).
	 */

	/* FIXME: replace with strcspn(). */
	ws = NULL;
	for (c = end = buf + offs; *c; c++) {
		switch (*c) {
		case ' ':
			if (NULL == ws)
				ws = c;
			continue;
		case '\t':
			/*
			 * Always warn about trailing tabs,
			 * even outside literal context,
			 * where they should be put on the next line.
			 */
			if (NULL == ws)
				ws = c;
			/*
			 * Strip trailing tabs in literal context only;
			 * outside, they affect the next line.
			 */
			if (MDOC_LITERAL & mdoc->flags)
				continue;
			break;
		case '\\':
			/* Skip the escaped character, too, if any. */
			if (c[1])
				c++;
			/* FALLTHROUGH */
		default:
			ws = NULL;
			break;
		}
		end = c + 1;
	}
	*end = '\0';

	if (ws)
		mandoc_msg(MANDOCERR_SPACE_EOL, mdoc->parse,
		    line, (int)(ws-buf), NULL);

	/*
	 * Blank lines are allowed in no-fill mode
	 * and cancel preceding \c,
	 * but add a single vertical space elsewhere.
	 */

	if (buf[offs] == '\0' && ! (mdoc->flags & MDOC_LITERAL)) {
		switch (mdoc->last->type) {
		case ROFFT_TEXT:
			sp = mdoc->last->string;
			cp = end = strchr(sp, '\0') - 2;
			if (cp < sp || cp[0] != '\\' || cp[1] != 'c')
				break;
			while (cp > sp && cp[-1] == '\\')
				cp--;
			if ((end - cp) % 2)
				break;
			*end = '\0';
			return 1;
		default:
			break;
		}
		mandoc_msg(MANDOCERR_FI_BLANK, mdoc->parse,
		    line, (int)(c - buf), NULL);
		roff_elem_alloc(mdoc, line, offs, ROFF_sp);
		mdoc->last->flags |= NODE_VALID | NODE_ENDED;
		mdoc->next = ROFF_NEXT_SIBLING;
		return 1;
	}

	roff_word_alloc(mdoc, line, offs, buf+offs);

	if (mdoc->flags & MDOC_LITERAL)
		return 1;

	/*
	 * End-of-sentence check.  If the last character is an unescaped
	 * EOS character, then flag the node as being the end of a
	 * sentence.  The front-end will know how to interpret this.
	 */

	assert(buf < end);

	if (mandoc_eos(buf+offs, (size_t)(end-buf-offs)))
		mdoc->last->flags |= NODE_EOS;

	for (c = buf + offs; c != NULL; c = strchr(c + 1, '.')) {
		if (c - buf < offs + 2)
			continue;
		if (end - c < 3)
			break;
		if (c[1] != ' ' ||
		    isalnum((unsigned char)c[-2]) == 0 ||
		    isalnum((unsigned char)c[-1]) == 0 ||
		    (c[-2] == 'n' && c[-1] == 'c') ||
		    (c[-2] == 'v' && c[-1] == 's'))
			continue;
		c += 2;
		if (*c == ' ')
			c++;
		if (*c == ' ')
			c++;
		if (isupper((unsigned char)(*c)))
			mandoc_msg(MANDOCERR_EOS, mdoc->parse,
			    line, (int)(c - buf), NULL);
	}

	return 1;
}

/*
 * Parse a macro line, that is, a line beginning with the control
 * character.
 */
static int
mdoc_pmacro(struct roff_man *mdoc, int ln, char *buf, int offs)
{
	struct roff_node *n;
	const char	 *cp;
	size_t		  sz;
	enum roff_tok	  tok;
	int		  sv;

	/* Determine the line macro. */

	sv = offs;
	tok = TOKEN_NONE;
	for (sz = 0; sz < 4 && strchr(" \t\\", buf[offs]) == NULL; sz++)
		offs++;
	if (sz == 2 || sz == 3)
		tok = roffhash_find(mdoc->mdocmac, buf + sv, sz);
	if (tok == TOKEN_NONE) {
		mandoc_msg(MANDOCERR_MACRO, mdoc->parse,
		    ln, sv, buf + sv - 1);
		return 1;
	}

	/* Skip a leading escape sequence or tab. */

	switch (buf[offs]) {
	case '\\':
		cp = buf + offs + 1;
		mandoc_escape(&cp, NULL, NULL);
		offs = cp - buf;
		break;
	case '\t':
		offs++;
		break;
	default:
		break;
	}

	/* Jump to the next non-whitespace word. */

	while (buf[offs] == ' ')
		offs++;

	/*
	 * Trailing whitespace.  Note that tabs are allowed to be passed
	 * into the parser as "text", so we only warn about spaces here.
	 */

	if ('\0' == buf[offs] && ' ' == buf[offs - 1])
		mandoc_msg(MANDOCERR_SPACE_EOL, mdoc->parse,
		    ln, offs - 1, NULL);

	/*
	 * If an initial macro or a list invocation, divert directly
	 * into macro processing.
	 */

	n = mdoc->last;
	if (n == NULL || tok == MDOC_It || tok == MDOC_El) {
		mdoc_macro(mdoc, tok, ln, sv, &offs, buf);
		return 1;
	}

	/*
	 * If a column list contains a non-It macro, assume an implicit
	 * item macro.  This can happen one or more times at the
	 * beginning of such a list, intermixed with text lines and
	 * with nodes generated on the roff level, for example by tbl.
	 */

	if ((n->tok == MDOC_Bl && n->type == ROFFT_BODY &&
	     n->end == ENDBODY_NOT && n->norm->Bl.type == LIST_column) ||
	    (n->parent != NULL && n->parent->tok == MDOC_Bl &&
	     n->parent->norm->Bl.type == LIST_column)) {
		mdoc->flags |= MDOC_FREECOL;
		mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf);
		return 1;
	}

	/* Normal processing of a macro. */

	mdoc_macro(mdoc, tok, ln, sv, &offs, buf);

	/* In quick mode (for mandocdb), abort after the NAME section. */

	if (mdoc->quick && MDOC_Sh == tok &&
	    SEC_NAME != mdoc->last->sec)
		return 2;

	return 1;
}

enum mdelim
mdoc_isdelim(const char *p)
{

	if ('\0' == p[0])
		return DELIM_NONE;

	if ('\0' == p[1])
		switch (p[0]) {
		case '(':
		case '[':
			return DELIM_OPEN;
		case '|':
			return DELIM_MIDDLE;
		case '.':
		case ',':
		case ';':
		case ':':
		case '?':
		case '!':
		case ')':
		case ']':
			return DELIM_CLOSE;
		default:
			return DELIM_NONE;
		}

	if ('\\' != p[0])
		return DELIM_NONE;

	if (0 == strcmp(p + 1, "."))
		return DELIM_CLOSE;
	if (0 == strcmp(p + 1, "fR|\\fP"))
		return DELIM_MIDDLE;

	return DELIM_NONE;
}

void
mdoc_validate(struct roff_man *mdoc)
{

	mdoc->last = mdoc->first;
	mdoc_node_validate(mdoc);
	mdoc_state_reset(mdoc);
}
@


1.156
log
@correct handling of blank lines after \c
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.155 2017/06/07 20:58:36 schwarze Exp $ */
d298 2
a299 2
		    isalpha((unsigned char)c[-2]) == 0 ||
		    isalpha((unsigned char)c[-1]) == 0 ||
@


1.155
log
@Also catch "new sentence, new line" if there are three blanks
between the sentences.  Thomas Klausner says he has seen some
of these, and i don't see any false positives.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.154 2017/06/07 20:30:13 schwarze Exp $ */
d180 1
d246 6
d253 15
a269 6

		/*
		 * Insert a `sp' in the case of a blank line.  Technically,
		 * blank lines aren't allowed, but enough manuals assume this
		 * behaviour that we want to work around it.
		 */
@


1.154
log
@Make "new sentence, new line" detection stricter:
Also catch cases where the new sentence starts with a one-letter word
and the input line is broken right after that word.
Suggested by Thomas Klausner <wiz @@ NetBSD>.

It's merely a three-bit diff, changing one byte from 0x34 to 0x33,
so what can possibly go wrong...
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.153 2017/05/05 15:16:25 schwarze Exp $ */
d281 12
a292 6
		if (isalpha((unsigned char)c[-2]) &&
		    isalpha((unsigned char)c[-1]) &&
		    c[1] == ' ' &&
		    isupper((unsigned char)(c[2] == ' ' ? c[3] : c[2])) &&
		    (c[-2] != 'n' || c[-1] != 'c') &&
		    (c[-2] != 'v' || c[-1] != 's'))
@


1.153
log
@Move .sp to the roff modules.  Enough infrastructure is in place
now that this actually saves code: -70 LOC.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.152 2017/04/29 12:43:55 schwarze Exp $ */
d279 1
a279 1
		if (end - c < 4)
@


1.152
log
@Parser unification: use nice ohashes for all three request and macro tables;
no functional change, minus two source files, minus 200 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.151 2017/04/24 23:06:09 schwarze Exp $ */
d254 1
a254 1
		roff_elem_alloc(mdoc, line, offs, MDOC_sp);
@


1.151
log
@Continue parser unification:
* Make enum rofft an internal interface as enum roff_tok in "roff.h".
* Represent mdoc and man macros in enum roff_tok.
* Make TOKEN_NONE a proper enum value and use it throughout.
* Put the prologue macros first in the macro tables.
* Unify mdoc_macroname[] and man_macroname[] into roff_name[].
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.150 2017/03/03 13:55:06 schwarze Exp $ */
d303 1
d305 3
a307 2
	int		  i, sv;
	char		  mac[5];
d310 5
a314 14

	/*
	 * Copy the first word into a nil-terminated buffer.
	 * Stop when a space, tab, escape, or eoln is encountered.
	 */

	i = 0;
	while (i < 4 && strchr(" \t\\", buf[offs]) == NULL)
		mac[i++] = buf[offs++];

	mac[i] = '\0';

	tok = (i > 1 && i < 4) ? mdoc_hash_find(mac) : TOKEN_NONE;

@


1.150
log
@remove a few redundant conditions that jsg@@ found with cppcheck
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.149 2017/02/16 02:59:42 schwarze Exp $ */
a35 35
const	char *const __mdoc_macronames[MDOC_MAX + 1] = {
	"text",
	"Ap",		"Dd",		"Dt",		"Os",
	"Sh",		"Ss",		"Pp",		"D1",
	"Dl",		"Bd",		"Ed",		"Bl",
	"El",		"It",		"Ad",		"An",
	"Ar",		"Cd",		"Cm",		"Dv",
	"Er",		"Ev",		"Ex",		"Fa",
	"Fd",		"Fl",		"Fn",		"Ft",
	"Ic",		"In",		"Li",		"Nd",
	"Nm",		"Op",		"Ot",		"Pa",
	"Rv",		"St",		"Va",		"Vt",
	"Xr",		"%A",		"%B",		"%D",
	"%I",		"%J",		"%N",		"%O",
	"%P",		"%R",		"%T",		"%V",
	"Ac",		"Ao",		"Aq",		"At",
	"Bc",		"Bf",		"Bo",		"Bq",
	"Bsx",		"Bx",		"Db",		"Dc",
	"Do",		"Dq",		"Ec",		"Ef",
	"Em",		"Eo",		"Fx",		"Ms",
	"No",		"Ns",		"Nx",		"Ox",
	"Pc",		"Pf",		"Po",		"Pq",
	"Qc",		"Ql",		"Qo",		"Qq",
	"Re",		"Rs",		"Sc",		"So",
	"Sq",		"Sm",		"Sx",		"Sy",
	"Tn",		"Ux",		"Xc",		"Xo",
	"Fo",		"Fc",		"Oo",		"Oc",
	"Bk",		"Ek",		"Bt",		"Hf",
	"Fr",		"Ud",		"Lb",		"Lp",
	"Lk",		"Mt",		"Brq",		"Bro",
	"Brc",		"%C",		"Es",		"En",
	"Dx",		"%Q",		"br",		"sp",
	"%U",		"Ta",		"ll",
};

d46 1
a46 3
	};

const	char * const *mdoc_macronames = __mdoc_macronames + 1;
d83 1
a83 2
	assert(tok > TOKEN_NONE && tok < MDOC_MAX);

d88 1
a88 1
mdoc_tail_alloc(struct roff_man *mdoc, int line, int pos, int tok)
d98 2
a99 2
mdoc_endbody_alloc(struct roff_man *mdoc, int line, int pos, int tok,
		struct roff_node *body)
d116 1
a116 1
	int tok, struct mdoc_arg *args)
d143 1
a143 1
	int tok, struct mdoc_arg *args)
d303 1
a303 1
	int		  tok;
@


1.149
log
@Remove the ENDBODY_NOSPACE flag, simplifying the code.

Comparing to groff output, it appears that all cases where it was used
and made a difference actually require the opposite, ENDBODY_SPACE.

I have no idea why i added it back in 2010; maybe to compensate for
some other bug that has long been fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.148 2017/01/28 23:26:56 schwarze Exp $ */
d383 1
a383 1
	while (buf[offs] && ' ' == buf[offs])
@


1.148
log
@Add a warning "new sentence, new line".
This does not attempt to pinpoint each and every offender, but
instead tries very hard to avoid false positives: Currently, there
are only two false positives in the whole OpenBSD base system.
Only do this in mdoc(7), not in man(7), because manuals written
in man(7) typically have much worse problems than this.
OK jmc@@ on a previous version of the patch
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.147 2017/01/10 13:46:53 schwarze Exp $ */
d137 1
a137 1
		struct roff_node *body, enum mdoc_endbody end)
d146 1
a146 1
	p->end = end;
@


1.147
log
@unify names of AST node flags; no change of cpp output
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.146 2016/08/20 14:43:39 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012-2016 Ingo Schwarze <schwarze@@openbsd.org>
d313 16
@


1.146
log
@If a column list starts with implicit rows (that is, rows without .It)
and roff-level nodes (e.g. tbl or eqn) follow, don't run into an
assertion.  Instead, wrap the roff-level nodes in their own row.
Issue found by tb@@ with afl(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.145 2015/10/30 19:03:36 schwarze Exp $ */
d141 2
a142 2
	body->flags |= MDOC_ENDED;
	body->parent->flags |= MDOC_ENDED;
d293 1
a293 1
		mdoc->last->flags |= MDOC_VALID | MDOC_ENDED;
d312 1
a312 1
		mdoc->last->flags |= MDOC_EOS;
@


1.145
log
@If a .Bd block has no arguments at all, drop the block and only keep
its contents.  Removing a gratuitious difference to groff output
found after a related bug report from krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.144 2015/10/20 02:00:49 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012-2015 Ingo Schwarze <schwarze@@openbsd.org>
a219 1
	assert(mdoc->last);
d223 4
a226 4
	 * Divert directly to list processing if we're encountering a
	 * columnar ROFFT_BLOCK with or without a prior ROFFT_BLOCK entry
	 * (a ROFFT_BODY means it's already open, in which case we should
	 * process within its context in the normal way).
d229 4
a232 13
	if (n->tok == MDOC_Bl && n->type == ROFFT_BODY &&
	    n->end == ENDBODY_NOT && n->norm->Bl.type == LIST_column) {
		/* `Bl' is open without any children. */
		mdoc->flags |= MDOC_FREECOL;
		mdoc_macro(mdoc, MDOC_It, line, offs, &offs, buf);
		return 1;
	}

	if (n->tok == MDOC_It && n->type == ROFFT_BLOCK &&
	    NULL != n->parent &&
	    MDOC_Bl == n->parent->tok &&
	    LIST_column == n->parent->norm->Bl.type) {
		/* `Bl' has block-level `It' children. */
d384 2
a385 1
	if (NULL == mdoc->last || MDOC_It == tok || MDOC_El == tok) {
a389 15
	n = mdoc->last;
	assert(mdoc->last);

	/*
	 * If the first macro of a `Bl -column', open an `It' block
	 * context around the parsed macro.
	 */

	if (n->tok == MDOC_Bl && n->type == ROFFT_BODY &&
	    n->end == ENDBODY_NOT && n->norm->Bl.type == LIST_column) {
		mdoc->flags |= MDOC_FREECOL;
		mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf);
		return 1;
	}

d391 4
a394 3
	 * If we're following a block-level `It' within a `Bl -column'
	 * context (perhaps opened in the above block or in ptext()),
	 * then open an `It' block context around the parsed macro.
d397 4
a400 4
	if (n->tok == MDOC_It && n->type == ROFFT_BLOCK &&
	    NULL != n->parent &&
	    MDOC_Bl == n->parent->tok &&
	    LIST_column == n->parent->norm->Bl.type) {
@


1.144
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.143 2015/10/12 00:07:27 schwarze Exp $ */
d206 1
@


1.143
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.142 2015/10/06 18:30:44 schwarze Exp $ */
a121 18
	if (mdoc->flags & MDOC_PBODY) {
		if (tok == MDOC_Dt) {
			mandoc_vmsg(MANDOCERR_DT_LATE,
			    mdoc->parse, line, ppos,
			    "Dt %s", buf + *pos);
			return;
		}
	} else if ( ! (mdoc_macros[tok].flags & MDOC_PROLOGUE)) {
		if (mdoc->meta.title == NULL) {
			mandoc_vmsg(MANDOCERR_DT_NOTITLE,
			    mdoc->parse, line, ppos, "%s %s",
			    mdoc_macronames[tok], buf + *pos);
			mdoc->meta.title = mandoc_strdup("UNTITLED");
		}
		if (NULL == mdoc->meta.vol)
			mdoc->meta.vol = mandoc_strdup("LOCAL");
		mdoc->flags |= MDOC_PBODY;
	}
d302 1
a303 1
		mdoc_valid_post(mdoc);
d477 9
@


1.142
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.141 2015/04/23 16:17:04 schwarze Exp $ */
a182 1
		/* FALLTHROUGH */
a183 1
		/* FALLTHROUGH */
a184 1
		/* FALLTHROUGH */
a185 1
		/* FALLTHROUGH */
a468 1
			/* FALLTHROUGH */
a473 1
			/* FALLTHROUGH */
a474 1
			/* FALLTHROUGH */
a475 1
			/* FALLTHROUGH */
a476 1
			/* FALLTHROUGH */
a477 1
			/* FALLTHROUGH */
a478 1
			/* FALLTHROUGH */
a479 1
			/* FALLTHROUGH */
@


1.141
log
@Unify mdoc_deroff() and man_deroff() into a common function deroff().
No functional change except that for mdoc(7), it now skips leading
escape sequences just like it already did for man(7).
Escape sequences rarely occur in mdoc(7) code and if they do,
skipping them is an improvement in this context.
Minus 30 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.140 2015/04/23 15:35:39 schwarze Exp $ */
d112 1
a112 1
	return(roff_getcontrol(mdoc->roff, buf, &offs) ?
d114 1
a114 1
	    mdoc_ptext(mdoc, ln, buf, offs));
d167 1
a167 1
	return(p);
d198 1
a198 1
	return(p);
d256 1
a256 1
		return(1);
d266 1
a266 1
		return(1);
d326 1
a326 1
		return(1);
d332 1
a332 1
		return(1);
d344 1
a344 1
	return(1);
d378 1
a378 1
		return(1);
d417 1
a417 1
		return(1);
d432 1
a432 1
		return(1);
d447 1
a447 1
		return(1);
d458 1
a458 1
		return(2);
d460 1
a460 1
	return(1);
d468 1
a468 1
		return(DELIM_NONE);
d475 1
a475 1
			return(DELIM_OPEN);
d477 1
a477 1
			return(DELIM_MIDDLE);
d493 1
a493 1
			return(DELIM_CLOSE);
d495 1
a495 1
			return(DELIM_NONE);
d499 1
a499 1
		return(DELIM_NONE);
d502 1
a502 1
		return(DELIM_CLOSE);
d504 1
a504 1
		return(DELIM_MIDDLE);
d506 1
a506 1
	return(DELIM_NONE);
@


1.140
log
@Get rid of two empty wrapper functions.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.139 2015/04/19 14:57:16 schwarze Exp $ */
a506 39
}

void
mdoc_deroff(char **dest, const struct roff_node *n)
{
	char	*cp;
	size_t	 sz;

	if (n->type != ROFFT_TEXT) {
		for (n = n->child; n; n = n->next)
			mdoc_deroff(dest, n);
		return;
	}

	/* Skip leading whitespace. */

	for (cp = n->string; '\0' != *cp; cp++)
		if (0 == isspace((unsigned char)*cp))
			break;

	/* Skip trailing whitespace. */

	for (sz = strlen(cp); sz; sz--)
		if (0 == isspace((unsigned char)cp[sz-1]))
			break;

	/* Skip empty strings. */

	if (0 == sz)
		return;

	if (NULL == *dest) {
		*dest = mandoc_strndup(cp, sz);
		return;
	}

	mandoc_asprintf(&cp, "%s %*s", *dest, (int)sz, cp);
	free(*dest);
	*dest = cp;
@


1.139
log
@Unify trickier node handling functions.
* man_elem_alloc() -> roff_elem_alloc()
* man_block_alloc() -> roff_block_alloc()
The functions mdoc_elem_alloc() and mdoc_block_alloc() remain for
now because they need to do mdoc(7)-specific argument processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.138 2015/04/19 14:25:05 schwarze Exp $ */
a88 7

void
mdoc_endparse(struct roff_man *mdoc)
{

	mdoc_macroend(mdoc);
}
@


1.138
log
@Unify some node handling functions that use TOKEN_NONE.
* mdoc_word_alloc(), man_word_alloc() -> roff_word_alloc()
* mdoc_word_append(), man_word_append() -> roff_word_append()
* mdoc_addspan(), man_addspan() -> roff_addtbl()
* mdoc_addeqn(), man_addeqn() -> roff_addeqn()
Minus 50 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.137 2015/04/19 13:59:37 schwarze Exp $ */
d330 1
a330 1
		mdoc_elem_alloc(mdoc, line, offs, MDOC_sp, NULL);
@


1.137
log
@Decouple the token code for "no request or macro" from the individual
high-level parsers to allow further unification of functions that
only need to recognize this code, but that don't care about different
high-level macrosets beyond that.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.136 2015/04/19 13:50:10 schwarze Exp $ */
a96 25
void
mdoc_addeqn(struct roff_man *mdoc, const struct eqn *ep)
{
	struct roff_node *n;

	n = roff_node_alloc(mdoc, ep->ln, ep->pos, ROFFT_EQN, TOKEN_NONE);
	n->eqn = ep;
	if (ep->ln > mdoc->last->line)
		n->flags |= MDOC_LINE;
	roff_node_append(mdoc, n);
	mdoc->next = ROFF_NEXT_SIBLING;
}

void
mdoc_addspan(struct roff_man *mdoc, const struct tbl_span *sp)
{
	struct roff_node *n;

	n = roff_node_alloc(mdoc, sp->line, 0, ROFFT_TBL, TOKEN_NONE);
	n->span = sp;
	roff_node_append(mdoc, n);
	mdoc_valid_post(mdoc);
	mdoc->next = ROFF_NEXT_SIBLING;
}

a230 27
mdoc_word_alloc(struct roff_man *mdoc, int line, int pos, const char *p)
{
	struct roff_node *n;

	n = roff_node_alloc(mdoc, line, pos, ROFFT_TEXT, TOKEN_NONE);
	n->string = roff_strdup(mdoc->roff, p);
	roff_node_append(mdoc, n);
	mdoc_valid_post(mdoc);
	mdoc->next = ROFF_NEXT_SIBLING;
}

void
mdoc_word_append(struct roff_man *mdoc, const char *p)
{
	struct roff_node	*n;
	char			*addstr, *newstr;

	n = mdoc->last;
	addstr = roff_strdup(mdoc->roff, p);
	mandoc_asprintf(&newstr, "%s %s", n->string, addstr);
	free(addstr);
	free(n->string);
	n->string = newstr;
	mdoc->next = ROFF_NEXT_SIBLING;
}

void
d336 1
a336 1
	mdoc_word_alloc(mdoc, line, offs, buf+offs);
@


1.136
log
@Unify node handling functions:
* node_alloc() for mdoc and man_node_alloc() -> roff_node_alloc()
* node_append() for mdoc and man_node_append() -> roff_node_append()
* mdoc_head_alloc() and man_head_alloc() -> roff_head_alloc()
* mdoc_body_alloc() and man_body_alloc() -> roff_body_alloc()
* mdoc_node_unlink() and man_node_unlink() -> roff_node_unlink()
* mdoc_node_free() and man_node_free() -> roff_node_free()
* mdoc_node_delete() and man_node_delete() -> roff_node_delete()
Minus 130 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.135 2015/04/18 17:50:02 schwarze Exp $ */
d37 1
d68 2
a69 2
	"%U",		"Ta",		"ll",		"text",
	};
d83 1
a83 1
const	char * const *mdoc_macronames = __mdoc_macronames;
d102 1
a102 1
	n = roff_node_alloc(mdoc, ep->ln, ep->pos, ROFFT_EQN, MDOC_MAX);
d115 1
a115 1
	n = roff_node_alloc(mdoc, sp->line, 0, ROFFT_TBL, MDOC_MAX);
d152 1
a152 1
	assert(tok < MDOC_MAX);
d260 1
a260 1
	n = roff_node_alloc(mdoc, line, pos, ROFFT_TEXT, MDOC_MAX);
d432 1
a432 1
	tok = (i > 1 && i < 4) ? mdoc_hash_find(mac) : MDOC_MAX;
d434 1
a434 1
	if (tok == MDOC_MAX) {
@


1.135
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.134 2015/04/18 17:28:08 schwarze Exp $ */
d33 1
a84 6
static	void		  mdoc_node_free(struct roff_node *);
static	void		  mdoc_node_unlink(struct roff_man *,
				struct roff_node *);
static	struct roff_node *node_alloc(struct roff_man *, int, int,
				int, enum roff_type);
static	void		  node_append(struct roff_man *, struct roff_node *);
d101 1
a101 1
	n = node_alloc(mdoc, ep->ln, ep->pos, MDOC_MAX, ROFFT_EQN);
d105 1
a105 1
	node_append(mdoc, n);
d114 1
a114 1
	n = node_alloc(mdoc, sp->line, 0, MDOC_MAX, ROFFT_TBL);
d116 2
a117 1
	node_append(mdoc, n);
a173 105

static void
node_append(struct roff_man *mdoc, struct roff_node *p)
{

	assert(mdoc->last);
	assert(mdoc->first);
	assert(p->type != ROFFT_ROOT);

	switch (mdoc->next) {
	case ROFF_NEXT_SIBLING:
		mdoc->last->next = p;
		p->prev = mdoc->last;
		p->parent = mdoc->last->parent;
		break;
	case ROFF_NEXT_CHILD:
		mdoc->last->child = p;
		p->parent = mdoc->last;
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	p->parent->nchild++;

	/*
	 * Copy over the normalised-data pointer of our parent.  Not
	 * everybody has one, but copying a null pointer is fine.
	 */

	switch (p->type) {
	case ROFFT_BODY:
		if (ENDBODY_NOT != p->end)
			break;
		/* FALLTHROUGH */
	case ROFFT_TAIL:
		/* FALLTHROUGH */
	case ROFFT_HEAD:
		p->norm = p->parent->norm;
		break;
	default:
		break;
	}

	mdoc_valid_pre(mdoc, p);

	switch (p->type) {
	case ROFFT_HEAD:
		assert(p->parent->type == ROFFT_BLOCK);
		p->parent->head = p;
		break;
	case ROFFT_TAIL:
		assert(p->parent->type == ROFFT_BLOCK);
		p->parent->tail = p;
		break;
	case ROFFT_BODY:
		if (p->end)
			break;
		assert(p->parent->type == ROFFT_BLOCK);
		p->parent->body = p;
		break;
	default:
		break;
	}

	mdoc->last = p;

	switch (p->type) {
	case ROFFT_TBL:
		/* FALLTHROUGH */
	case ROFFT_TEXT:
		mdoc_valid_post(mdoc);
		break;
	default:
		break;
	}
}

static struct roff_node *
node_alloc(struct roff_man *mdoc, int line, int pos,
	int tok, enum roff_type type)
{
	struct roff_node *p;

	p = mandoc_calloc(1, sizeof(*p));
	p->sec = mdoc->lastsec;
	p->line = line;
	p->pos = pos;
	p->tok = tok;
	p->type = type;

	/* Flag analysis. */

	if (MDOC_SYNOPSIS & mdoc->flags)
		p->flags |= MDOC_SYNPRETTY;
	else
		p->flags &= ~MDOC_SYNPRETTY;
	if (MDOC_NEWLINE & mdoc->flags)
		p->flags |= MDOC_LINE;
	mdoc->flags &= ~MDOC_NEWLINE;

	return(p);
}

d179 2
a180 25
	p = node_alloc(mdoc, line, pos, tok, ROFFT_TAIL);
	node_append(mdoc, p);
	mdoc->next = ROFF_NEXT_CHILD;
}

struct roff_node *
mdoc_head_alloc(struct roff_man *mdoc, int line, int pos, int tok)
{
	struct roff_node *p;

	assert(mdoc->first);
	assert(mdoc->last);
	p = node_alloc(mdoc, line, pos, tok, ROFFT_HEAD);
	node_append(mdoc, p);
	mdoc->next = ROFF_NEXT_CHILD;
	return(p);
}

struct roff_node *
mdoc_body_alloc(struct roff_man *mdoc, int line, int pos, int tok)
{
	struct roff_node *p;

	p = node_alloc(mdoc, line, pos, tok, ROFFT_BODY);
	node_append(mdoc, p);
a181 1
	return(p);
d192 1
a192 1
	p = node_alloc(mdoc, line, pos, tok, ROFFT_BODY);
d196 1
a196 1
	node_append(mdoc, p);
d207 1
a207 1
	p = node_alloc(mdoc, line, pos, tok, ROFFT_BLOCK);
d227 1
a227 1
	node_append(mdoc, p);
d238 1
a238 1
	p = node_alloc(mdoc, line, pos, tok, ROFFT_ELEM);
d250 1
a250 1
	node_append(mdoc, p);
d259 1
a259 1
	n = node_alloc(mdoc, line, pos, MDOC_MAX, ROFFT_TEXT);
d261 2
a262 1
	node_append(mdoc, n);
a280 64
static void
mdoc_node_free(struct roff_node *p)
{

	if (p->type == ROFFT_BLOCK || p->type == ROFFT_ELEM)
		free(p->norm);
	if (p->string)
		free(p->string);
	if (p->args)
		mdoc_argv_free(p->args);
	free(p);
}

static void
mdoc_node_unlink(struct roff_man *mdoc, struct roff_node *n)
{

	/* Adjust siblings. */

	if (n->prev)
		n->prev->next = n->next;
	if (n->next)
		n->next->prev = n->prev;

	/* Adjust parent. */

	if (n->parent) {
		n->parent->nchild--;
		if (n->parent->child == n)
			n->parent->child = n->prev ? n->prev : n->next;
		if (n->parent->last == n)
			n->parent->last = n->prev ? n->prev : NULL;
	}

	/* Adjust parse point, if applicable. */

	if (mdoc && mdoc->last == n) {
		if (n->prev) {
			mdoc->last = n->prev;
			mdoc->next = ROFF_NEXT_SIBLING;
		} else {
			mdoc->last = n->parent;
			mdoc->next = ROFF_NEXT_CHILD;
		}
	}

	if (mdoc && mdoc->first == n)
		mdoc->first = NULL;
}

void
mdoc_node_delete(struct roff_man *mdoc, struct roff_node *p)
{

	while (p->child) {
		assert(p->nchild);
		mdoc_node_delete(mdoc, p->child);
	}
	assert(0 == p->nchild);

	mdoc_node_unlink(mdoc, p);
	mdoc_node_free(p);
}

d285 2
a286 2
	mdoc_node_unlink(mdoc, p);
	node_append(mdoc, p);
@


1.134
log
@Unify {mdoc,man}_{alloc,reset,free}() into roff_man_{alloc,reset,free}().
Minus 80 lines of code, no functional change.
Written on the train from Koeln to Wolfsburg returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.133 2015/04/18 17:01:28 schwarze Exp $ */
a92 14

const struct roff_node *
mdoc_node(const struct roff_man *mdoc)
{

	return(mdoc->first);
}

const struct roff_meta *
mdoc_meta(const struct roff_man *mdoc)
{

	return(&mdoc->meta);
}
@


1.133
log
@Move mdoc_hash_init() and man_hash_init() to libmandoc.h
and call them from mparse_alloc() and choose_parser(),
preparing unified allocation of struct roff_man.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.132 2015/04/18 16:34:03 schwarze Exp $ */
a86 2
static	void		  mdoc_free1(struct roff_man *);
static	void		  mdoc_alloc1(struct roff_man *);
a105 82
}

/*
 * Frees volatile resources (parse tree, meta-data, fields).
 */
static void
mdoc_free1(struct roff_man *mdoc)
{

	if (mdoc->first)
		mdoc_node_delete(mdoc, mdoc->first);
	free(mdoc->meta.msec);
	free(mdoc->meta.vol);
	free(mdoc->meta.arch);
	free(mdoc->meta.date);
	free(mdoc->meta.title);
	free(mdoc->meta.os);
	free(mdoc->meta.name);
}

/*
 * Allocate all volatile resources (parse tree, meta-data, fields).
 */
static void
mdoc_alloc1(struct roff_man *mdoc)
{

	memset(&mdoc->meta, 0, sizeof(mdoc->meta));
	mdoc->macroset = MACROSET_MDOC;
	mdoc->flags = 0;
	mdoc->lastnamed = mdoc->lastsec = SEC_NONE;
	mdoc->last = mandoc_calloc(1, sizeof(*mdoc->last));
	mdoc->first = mdoc->last;
	mdoc->last->type = ROFFT_ROOT;
	mdoc->last->tok = MDOC_MAX;
	mdoc->next = ROFF_NEXT_CHILD;
}

/*
 * Free up volatile resources (see mdoc_free1()) then re-initialises the
 * data with mdoc_alloc1().  After invocation, parse data has been reset
 * and the parser is ready for re-invocation on a new tree; however,
 * cross-parse non-volatile data is kept intact.
 */
void
mdoc_reset(struct roff_man *mdoc)
{

	mdoc_free1(mdoc);
	mdoc_alloc1(mdoc);
}

/*
 * Completely free up all volatile and non-volatile parse resources.
 * After invocation, the pointer is no longer usable.
 */
void
mdoc_free(struct roff_man *mdoc)
{

	mdoc_free1(mdoc);
	free(mdoc);
}

/*
 * Allocate volatile and non-volatile parse resources.
 */
struct roff_man *
mdoc_alloc(struct roff *roff, struct mparse *parse,
	const char *defos, int quick)
{
	struct roff_man	*p;

	p = mandoc_calloc(1, sizeof(*p));

	p->parse = parse;
	p->defos = defos;
	p->quick = quick;
	p->roff = roff;

	mdoc_alloc1(p);
	return(p);
@


1.132
log
@Profit from the unified struct roff_man and reduce the number of
arguments of mparse_result() by one.  No functional change.
Written on the ICE Bruxelles-Koeln on the way back from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.131 2015/04/18 16:04:40 schwarze Exp $ */
a187 1
	mdoc_hash_init();
@


1.131
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.130 2015/04/02 23:47:43 schwarze Exp $ */
d136 1
@


1.130
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.129 2015/04/02 22:06:17 schwarze Exp $ */
d85 1
a85 1
static	void		  mdoc_node_unlink(struct mdoc *,
d87 3
a89 3
static	void		  mdoc_free1(struct mdoc *);
static	void		  mdoc_alloc1(struct mdoc *);
static	struct roff_node *node_alloc(struct mdoc *, int, int,
d91 3
a93 3
static	void		  node_append(struct mdoc *, struct roff_node *);
static	int		  mdoc_ptext(struct mdoc *, int, char *, int);
static	int		  mdoc_pmacro(struct mdoc *, int, char *, int);
d97 1
a97 1
mdoc_node(const struct mdoc *mdoc)
d104 1
a104 1
mdoc_meta(const struct mdoc *mdoc)
d114 1
a114 1
mdoc_free1(struct mdoc *mdoc)
d132 1
a132 1
mdoc_alloc1(struct mdoc *mdoc)
d142 1
a142 1
	mdoc->next = MDOC_NEXT_CHILD;
d152 1
a152 1
mdoc_reset(struct mdoc *mdoc)
d164 1
a164 1
mdoc_free(struct mdoc *mdoc)
d174 1
a174 1
struct mdoc *
d178 1
a178 1
	struct mdoc	*p;
d180 1
a180 1
	p = mandoc_calloc(1, sizeof(struct mdoc));
d193 1
a193 1
mdoc_endparse(struct mdoc *mdoc)
d200 1
a200 1
mdoc_addeqn(struct mdoc *mdoc, const struct eqn *ep)
d209 1
a209 1
	mdoc->next = MDOC_NEXT_SIBLING;
d213 1
a213 1
mdoc_addspan(struct mdoc *mdoc, const struct tbl_span *sp)
d220 1
a220 1
	mdoc->next = MDOC_NEXT_SIBLING;
d228 1
a228 1
mdoc_parseln(struct mdoc *mdoc, int ln, char *buf, int offs)
d278 1
a278 1
node_append(struct mdoc *mdoc, struct roff_node *p)
d286 1
a286 1
	case MDOC_NEXT_SIBLING:
d291 1
a291 1
	case MDOC_NEXT_CHILD:
d356 1
a356 1
node_alloc(struct mdoc *mdoc, int line, int pos,
d382 1
a382 1
mdoc_tail_alloc(struct mdoc *mdoc, int line, int pos, int tok)
d388 1
a388 1
	mdoc->next = MDOC_NEXT_CHILD;
d392 1
a392 1
mdoc_head_alloc(struct mdoc *mdoc, int line, int pos, int tok)
d400 1
a400 1
	mdoc->next = MDOC_NEXT_CHILD;
d405 1
a405 1
mdoc_body_alloc(struct mdoc *mdoc, int line, int pos, int tok)
d411 1
a411 1
	mdoc->next = MDOC_NEXT_CHILD;
d416 1
a416 1
mdoc_endbody_alloc(struct mdoc *mdoc, int line, int pos, int tok,
d428 1
a428 1
	mdoc->next = MDOC_NEXT_SIBLING;
d433 1
a433 1
mdoc_block_alloc(struct mdoc *mdoc, int line, int pos,
d459 1
a459 1
	mdoc->next = MDOC_NEXT_CHILD;
d464 1
a464 1
mdoc_elem_alloc(struct mdoc *mdoc, int line, int pos,
d482 1
a482 1
	mdoc->next = MDOC_NEXT_CHILD;
d486 1
a486 1
mdoc_word_alloc(struct mdoc *mdoc, int line, int pos, const char *p)
d493 1
a493 1
	mdoc->next = MDOC_NEXT_SIBLING;
d497 1
a497 1
mdoc_word_append(struct mdoc *mdoc, const char *p)
d508 1
a508 1
	mdoc->next = MDOC_NEXT_SIBLING;
d525 1
a525 1
mdoc_node_unlink(struct mdoc *mdoc, struct roff_node *n)
d550 1
a550 1
			mdoc->next = MDOC_NEXT_SIBLING;
d553 1
a553 1
			mdoc->next = MDOC_NEXT_CHILD;
d562 1
a562 1
mdoc_node_delete(struct mdoc *mdoc, struct roff_node *p)
d576 1
a576 1
mdoc_node_relink(struct mdoc *mdoc, struct roff_node *p)
d588 1
a588 1
mdoc_ptext(struct mdoc *mdoc, int line, char *buf, int offs)
d676 1
a676 1
		mdoc->next = MDOC_NEXT_SIBLING;
d704 1
a704 1
mdoc_pmacro(struct mdoc *mdoc, int ln, char *buf, int offs)
@


1.129
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.128 2015/04/02 21:03:18 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d103 1
a103 1
const struct mdoc_meta *
d135 1
a135 1
	memset(&mdoc->meta, 0, sizeof(struct mdoc_meta));
@


1.128
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.127 2015/02/12 13:00:27 schwarze Exp $ */
d84 1
a84 1
static	void		  mdoc_node_free(struct mdoc_node *);
d86 1
a86 1
				struct mdoc_node *);
d89 3
a91 3
static	struct mdoc_node *node_alloc(struct mdoc *, int, int,
				enum mdoct, enum roff_type);
static	void		  node_append(struct mdoc *, struct mdoc_node *);
d96 1
a96 1
const struct mdoc_node *
d138 1
a138 1
	mdoc->last = mandoc_calloc(1, sizeof(struct mdoc_node));
d202 1
a202 1
	struct mdoc_node *n;
d215 1
a215 1
	struct mdoc_node *n;
d278 1
a278 1
node_append(struct mdoc *mdoc, struct mdoc_node *p)
d355 1
a355 1
static struct mdoc_node *
d357 1
a357 1
		enum mdoct tok, enum roff_type type)
d359 1
a359 1
	struct mdoc_node *p;
d361 1
a361 1
	p = mandoc_calloc(1, sizeof(struct mdoc_node));
d382 1
a382 1
mdoc_tail_alloc(struct mdoc *mdoc, int line, int pos, enum mdoct tok)
d384 1
a384 1
	struct mdoc_node *p;
d391 2
a392 2
struct mdoc_node *
mdoc_head_alloc(struct mdoc *mdoc, int line, int pos, enum mdoct tok)
d394 1
a394 1
	struct mdoc_node *p;
d404 2
a405 2
struct mdoc_node *
mdoc_body_alloc(struct mdoc *mdoc, int line, int pos, enum mdoct tok)
d407 1
a407 1
	struct mdoc_node *p;
d415 3
a417 3
struct mdoc_node *
mdoc_endbody_alloc(struct mdoc *mdoc, int line, int pos, enum mdoct tok,
		struct mdoc_node *body, enum mdoc_endbody end)
d419 1
a419 1
	struct mdoc_node *p;
d432 1
a432 1
struct mdoc_node *
d434 1
a434 1
		enum mdoct tok, struct mdoc_arg *args)
d436 1
a436 1
	struct mdoc_node *p;
d465 1
a465 1
		enum mdoct tok, struct mdoc_arg *args)
d467 1
a467 1
	struct mdoc_node *p;
d488 1
a488 1
	struct mdoc_node *n;
d499 1
a499 1
	struct mdoc_node	*n;
d512 1
a512 1
mdoc_node_free(struct mdoc_node *p)
d525 1
a525 1
mdoc_node_unlink(struct mdoc *mdoc, struct mdoc_node *n)
d562 1
a562 1
mdoc_node_delete(struct mdoc *mdoc, struct mdoc_node *p)
d576 1
a576 1
mdoc_node_relink(struct mdoc *mdoc, struct mdoc_node *p)
d590 1
a591 1
	struct mdoc_node *n;
d706 1
a706 1
	struct mdoc_node *n;
d708 1
a708 1
	enum mdoct	  tok;
d862 1
a862 1
mdoc_deroff(char **dest, const struct mdoc_node *n)
@


1.127
log
@Do not confuse .Bl -column lists that just broken another block
with newly opened .Bl -column lists;
fixing an assertion failure jsg@@ found with afl:
test case #481, Bl It Bl -column It Bd El text text El
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.126 2015/02/12 12:20:47 schwarze Exp $ */
d28 3
d32 1
a32 2
#include "mandoc.h"
#include "mandoc_aux.h"
a33 1
#include "libmandoc.h"
d90 1
a90 1
				enum mdoct, enum mdoc_type);
d140 1
a140 1
	mdoc->last->type = MDOC_ROOT;
d204 1
a204 1
	n = node_alloc(mdoc, ep->ln, ep->pos, MDOC_MAX, MDOC_EQN);
d217 1
a217 1
	n = node_alloc(mdoc, sp->line, 0, MDOC_MAX, MDOC_TBL);
d231 1
a231 1
	if (mdoc->last->type != MDOC_EQN || ln > mdoc->last->line)
d283 1
a283 1
	assert(MDOC_ROOT != p->type);
d308 1
a308 1
	case MDOC_BODY:
d312 1
a312 1
	case MDOC_TAIL:
d314 1
a314 1
	case MDOC_HEAD:
d324 2
a325 2
	case MDOC_HEAD:
		assert(MDOC_BLOCK == p->parent->type);
d328 2
a329 2
	case MDOC_TAIL:
		assert(MDOC_BLOCK == p->parent->type);
d332 1
a332 1
	case MDOC_BODY:
d335 1
a335 1
		assert(MDOC_BLOCK == p->parent->type);
d345 1
a345 1
	case MDOC_TBL:
d347 1
a347 1
	case MDOC_TEXT:
d357 1
a357 1
		enum mdoct tok, enum mdoc_type type)
d386 1
a386 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_TAIL);
d398 1
a398 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_HEAD);
d409 1
a409 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_BODY);
d423 1
a423 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_BODY);
d438 1
a438 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_BLOCK);
d469 1
a469 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_ELEM);
d490 1
a490 1
	n = node_alloc(mdoc, line, pos, MDOC_MAX, MDOC_TEXT);
d515 1
a515 1
	if (MDOC_BLOCK == p->type || MDOC_ELEM == p->type)
d598 2
a599 2
	 * columnar MDOC_BLOCK with or without a prior MDOC_BLOCK entry
	 * (a MDOC_BODY means it's already open, in which case we should
d603 1
a603 1
	if (n->tok == MDOC_Bl && n->type == MDOC_BODY &&
d611 1
a611 1
	if (MDOC_It == n->tok && MDOC_BLOCK == n->type &&
d780 1
a780 1
	if (n->tok == MDOC_Bl && n->type == MDOC_BODY &&
d793 1
a793 1
	if (MDOC_It == n->tok && MDOC_BLOCK == n->type &&
d867 1
a867 1
	if (MDOC_TEXT != n->type) {
@


1.126
log
@Delete the mdoc_node.pending pointer and the function calculating
it, make_pending(), which was the most difficult function of the
whole mdoc(7) parser.  After almost five years of maintaining this
hellhole, i just noticed the pointer isn't needed after all.

Blocks are always rewound in the reverse order they were opened;
that even holds for broken blocks.  Consequently, it is sufficient
to just mark broken blogs with the flag MDOC_BROKEN and breaking
blocks with the flag MDOC_ENDED.  When rewinding, instead of iterating
the pending pointers, just iterate from each broken block to its
parents, rewinding all that are MDOC_ENDED and stopping after
processing the first ancestor that it not MDOC_BROKEN.  For ENDBODY
markers, use the mdoc_node.body pointer in place of the former
mdoc_node.pending.

This also fixes an assertion failure found by jsg@@ with afl,
test case #467 (Bo Bl It Bd Bc It), where (surprise surprise)
the pending pointer got corrupted.

Improved functionality, minus one function, minus one struct field,
minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.125 2015/02/05 00:13:34 schwarze Exp $ */
d602 2
a603 2
	if (MDOC_Bl == n->tok && MDOC_BODY == n->type &&
	    LIST_column == n->norm->Bl.type) {
d779 2
a780 2
	if (MDOC_Bl == n->tok && MDOC_BODY == n->type &&
	    LIST_column == n->norm->Bl.type) {
@


1.125
log
@Simplify by deleting the "lastline" member of struct mdoc_node.
Minus one struct member, minus 17 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.124 2015/02/02 04:26:03 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d420 2
d423 1
a423 1
	p->pending = body;
@


1.124
log
@Get rid of all calls to rew_sub() in blk_exp_close(); only ten calls
remain in other functions.  As a bonus, this fixes an assertion failure
jsg@@ found some time ago with afl (test case 982) and improves minor
details in error reporting.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.123 2015/01/15 04:26:06 schwarze Exp $ */
a363 1
	p->lastline = line;
@


1.123
log
@Fatal errors no longer exist.
If a file can be opened, mandoc will produce some output;
at worst, the output may be almost empty.
Simplifies error handling and frees a message type for future use.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.122 2014/11/28 06:26:46 schwarze Exp $ */
d415 1
a415 1
void
d427 1
@


1.122
log
@Simplify by making the eqn and tbl steering functions void;
no functional change, minus 15 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.121 2014/11/28 04:46:30 schwarze Exp $ */
d191 1
a191 1
int
a195 1
	return(1);
@


1.121
log
@Simplify by making the mdoc parser callbacks void, and some cleanup;
no functional change, minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.120 2014/11/28 03:13:58 schwarze Exp $ */
d199 1
a199 1
int
a209 1
	return(1);
d212 1
a212 1
int
a220 1
	return(1);
@


1.120
log
@Simplify the code by making various mdoc parser helper functions void.
No functional change, minus 130 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.119 2014/11/28 01:05:40 schwarze Exp $ */
d195 2
a196 1
	return(mdoc_macroend(mdoc));
d252 1
a252 1
int
d262 1
a262 1
			return(1);
d275 1
a275 2

	return((*mdoc_macros[tok].fp)(mdoc, tok, line, ppos, pos, buf));
d607 2
a608 1
		return(mdoc_macro(mdoc, MDOC_It, line, offs, &offs, buf));
d617 2
a618 1
		return(mdoc_macro(mdoc, MDOC_It, line, offs, &offs, buf));
a695 1

d767 4
a770 2
	if (NULL == mdoc->last || MDOC_It == tok || MDOC_El == tok)
		return(mdoc_macro(mdoc, tok, ln, sv, &offs, buf));
d783 2
a784 1
		return(mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf));
d798 2
a799 1
		return(mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf));
d804 1
a804 2
	if ( ! mdoc_macro(mdoc, tok, ln, sv, &offs, buf))
		return(0);
@


1.119
log
@Simplify code by making mdoc validation handlers void.
No functional change, minus 90 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.118 2014/11/19 03:07:43 schwarze Exp $ */
d384 1
a384 1
int
a391 1
	return(1);
d394 1
a394 1
int
a400 1

d404 1
a404 1
	return(1);
d407 1
a407 1
int
d415 1
a415 1
	return(1);
d418 1
a418 1
int
a429 1
	return(1);
d432 1
a432 1
int
d460 1
a460 1
	return(1);
d463 1
a463 1
int
a482 1
	return(1);
d485 1
a485 1
int
a493 1
	return(1);
d575 1
a575 1
int
a580 1
	return(1);
d664 1
a664 1
	if ('\0' == buf[offs] && ! (MDOC_LITERAL & mdoc->flags)) {
d673 1
a673 3
		if ( ! mdoc_elem_alloc(mdoc, line, offs, MDOC_sp, NULL))
			return(0);

a674 1

d679 1
a679 2
	if ( ! mdoc_word_alloc(mdoc, line, offs, buf+offs))
		return(0);
d681 1
a681 1
	if (MDOC_LITERAL & mdoc->flags)
@


1.118
log
@Escape sequences terminate high-level macro names, and when doing so,
they are ignored, just in the same way as for request names
and for low-level macro names.
This also cures a warning in the pod2man(1) preamble.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.117 2014/10/20 15:49:45 schwarze Exp $ */
d90 1
a90 2
static	int		  node_append(struct mdoc *,
				struct mdoc_node *);
d207 1
a207 4

	if ( ! node_append(mdoc, n))
		return(0);

d219 1
a219 4

	if ( ! node_append(mdoc, n))
		return(0);

d279 1
a279 1
static int
d323 1
a323 2
	if ( ! mdoc_valid_pre(mdoc, p))
		return(0);
d350 1
a350 2
		if ( ! mdoc_valid_post(mdoc))
			return(0);
a354 2

	return(1);
d390 1
a390 2
	if ( ! node_append(mdoc, p))
		return(0);
d404 1
a404 2
	if ( ! node_append(mdoc, p))
		return(0);
d415 1
a415 2
	if ( ! node_append(mdoc, p))
		return(0);
d430 1
a430 2
	if ( ! node_append(mdoc, p))
		return(0);
d461 1
a461 3

	if ( ! node_append(mdoc, p))
		return(0);
d484 1
a484 3

	if ( ! node_append(mdoc, p))
		return(0);
d496 1
a496 4

	if ( ! node_append(mdoc, n))
		return(0);

d585 2
a586 1
	return(node_append(mdoc, p));
d684 2
a685 1
		return(mdoc_valid_post(mdoc));
@


1.117
log
@correct the spacing after in-line equations
that start at the beginning of an input line
but end before the end of an input line
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.116 2014/10/20 02:31:44 schwarze Exp $ */
d735 2
a739 1
	struct mdoc_node *n;
d745 1
a745 1
	 * Stop copying when a tab, space, or eoln is encountered.
d749 1
a749 2
	while (i < 4 && '\0' != buf[offs] && ' ' != buf[offs] &&
	    '\t' != buf[offs])
d756 1
a756 1
	if (MDOC_MAX == tok) {
d762 1
a762 1
	/* Disregard the first trailing tab, if applicable. */
d764 7
a770 1
	if ('\t' == buf[offs])
d772 4
@


1.116
log
@correct spacing before inline equations
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc.c,v 1.115 2014/10/16 01:10:06 schwarze Exp $ */
d239 2
a240 1
	mdoc->flags |= MDOC_NEWLINE;
@


1.115
log
@Implement in-line equations, much needed by Xenocara manuals.
Put the steering into the roff parser rather than into the mdoc
parser such that it works for all macro languages and on both text
and macro lines.
Line breaks and blank characters generated before and after in-line
equations are not perfect yet, but let's do one thing at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d206 2
@


1.114
log
@Simplify by handling empty request lines at the one logical place
in the roff parser instead of in three other places in other parsers.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.113 2014/08/08 16:17:09 schwarze Exp $ */
a91 3
#if 0
static	int		  mdoc_preptext(struct mdoc *, int, char *, int);
#endif
a605 54

#if 0
/*
 * Pre-treat a text line.
 * Text lines can consist of equations, which must be handled apart from
 * the regular text.
 * Thus, use this function to step through a line checking if it has any
 * equations embedded in it.
 * This must handle multiple equations AND equations that do not end at
 * the end-of-line, i.e., will re-enter in the next roff parse.
 */
static int
mdoc_preptext(struct mdoc *mdoc, int line, char *buf, int offs)
{
	char		*start, *end;
	char		 delim;

	while ('\0' != buf[offs]) {
		/* Mark starting position if eqn is set. */
		start = NULL;
		if ('\0' != (delim = roff_eqndelim(mdoc->roff)))
			if (NULL != (start = strchr(buf + offs, delim)))
				*start++ = '\0';

		/* Parse text as normal. */
		if ( ! mdoc_ptext(mdoc, line, buf, offs))
			return(0);

		/* Continue only if an equation exists. */
		if (NULL == start)
			break;

		/* Read past the end of the equation. */
		offs += start - (buf + offs);
		assert(start == &buf[offs]);
		if (NULL != (end = strchr(buf + offs, delim))) {
			*end++ = '\0';
			while (' ' == *end)
				end++;
		}

		/* Parse the equation itself. */
		roff_openeqn(mdoc->roff, NULL, line, offs, buf);

		/* Process a finished equation? */
		if (roff_closeeqn(mdoc->roff))
			if ( ! mdoc_addeqn(mdoc, roff_eqn(mdoc->roff)))
				return(0);
		offs += (end - (buf + offs));
	}

	return(1);
}
#endif
@


1.113
log
@Bring the handling of defective prologues even closer to groff,
in particular relaxing the distinction between prologue and body
and further improving messages.
* The last .Dd wins and the last .Os wins, even in the body.
* The last .Dt before the first body macro wins.
* Missing title in .Dt defaults to UNTITLED.  Warn about it.
* Missing section in .Dt does not default to 1.  But warn about it.
* Do not warn multiple times about the same mdoc(7) prologue macro.
* Warn about missing .Os.
* Incomplete .TH defaults to empty strings.  Warn about it.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.112 2014/08/08 15:54:10 schwarze Exp $ */
a792 9

	/* Empty post-control lines are ignored. */

	if ('"' == buf[offs]) {
		mandoc_msg(MANDOCERR_COMMENT_BAD, mdoc->parse,
		    ln, offs, NULL);
		return(1);
	} else if ('\0' == buf[offs])
		return(1);
@


1.112
log
@mention requests and macros in more messages
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.111 2014/08/08 15:32:17 schwarze Exp $ */
d122 7
a128 14
	if (mdoc->meta.title)
		free(mdoc->meta.title);
	if (mdoc->meta.os)
		free(mdoc->meta.os);
	if (mdoc->meta.name)
		free(mdoc->meta.name);
	if (mdoc->meta.arch)
		free(mdoc->meta.arch);
	if (mdoc->meta.vol)
		free(mdoc->meta.vol);
	if (mdoc->meta.msec)
		free(mdoc->meta.msec);
	if (mdoc->meta.date)
		free(mdoc->meta.date);
d263 14
a276 19
	/* If we're in the body, deny prologue calls. */

	if (MDOC_PROLOGUE & mdoc_macros[tok].flags &&
	    MDOC_PBODY & mdoc->flags) {
		mandoc_vmsg(MANDOCERR_PROLOG_ONLY, mdoc->parse,
		    line, ppos, "%s", mdoc_macronames[tok]);
		return(1);
	}

	/* If we're in the prologue, deny "body" macros.  */

	if ( ! (MDOC_PROLOGUE & mdoc_macros[tok].flags) &&
	     ! (MDOC_PBODY & mdoc->flags)) {
		mandoc_vmsg(MANDOCERR_PROLOG_BAD, mdoc->parse,
		    line, ppos, "%s", mdoc_macronames[tok]);
		if (NULL == mdoc->meta.msec)
			mdoc->meta.msec = mandoc_strdup("1");
		if (NULL == mdoc->meta.title)
			mdoc->meta.title = mandoc_strdup("UNKNOWN");
a278 5
		if (NULL == mdoc->meta.os)
			mdoc->meta.os = mandoc_strdup("LOCAL");
		if (NULL == mdoc->meta.date)
			mdoc->meta.date = mandoc_normdate
				(mdoc->parse, NULL, line, ppos);
@


1.111
log
@Simplify: replace one global flag by one local variable
and remove three unused global flags.  No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.110 2014/07/09 11:30:07 schwarze Exp $ */
d837 2
a838 2
		mandoc_vmsg(MANDOCERR_MACRO, mdoc->parse,
		    ln, sv, "%s", buf + sv - 1);
@


1.110
log
@mark defos as const; nobody needs to change it,
and it is occasionally useful to be able to pass literal strings
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.109 2014/07/07 15:03:24 schwarze Exp $ */
a102 1
	assert( ! (MDOC_HALT & mdoc->flags));
a109 1
	assert( ! (MDOC_HALT & mdoc->flags));
a201 4
/*
 * Climb back up the parse tree, validating open scopes.  Mostly calls
 * through to macro_end() in macro.c.
 */
d206 1
a206 5
	assert( ! (MDOC_HALT & mdoc->flags));
	if (mdoc_macroend(mdoc))
		return(1);
	mdoc->flags |= MDOC_HALT;
	return(0);
a213 2
	assert( ! (MDOC_HALT & mdoc->flags));

a228 2
	assert( ! (MDOC_HALT & mdoc->flags));

a246 2
	assert( ! (MDOC_HALT & mdoc->flags));

d866 2
a867 5
	if (NULL == mdoc->last || MDOC_It == tok || MDOC_El == tok) {
		if ( ! mdoc_macro(mdoc, tok, ln, sv, &offs, buf))
			goto err;
		return(1);
	}
d880 1
a880 3
		if ( ! mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf))
			goto err;
		return(1);
d894 1
a894 3
		if ( ! mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf))
			goto err;
		return(1);
d900 1
a900 1
		goto err;
a908 5

err:	/* Error out. */

	mdoc->flags |= MDOC_HALT;
	return(0);
@


1.109
log
@no need to skip content before first section header
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.108 2014/07/06 19:08:56 schwarze Exp $ */
d188 1
a188 1
	char *defos, int quick)
@


1.108
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.107 2014/07/02 03:47:07 schwarze Exp $ */
a225 7
	/* No text before an initial macro. */

	if (SEC_NONE == mdoc->lastnamed) {
		mdoc_pmsg(mdoc, ep->ln, ep->pos, MANDOCERR_NOTEXT);
		return(1);
	}

a242 7
	/* No text before an initial macro. */

	if (SEC_NONE == mdoc->lastnamed) {
		mdoc_pmsg(mdoc, sp->line, 0, MANDOCERR_NOTEXT);
		return(1);
	}

a705 7

	/* No text before an initial macro. */

	if (SEC_NONE == mdoc->lastnamed) {
		mdoc_pmsg(mdoc, line, offs, MANDOCERR_NOTEXT);
		return(1);
	}
@


1.107
log
@Implement the obsolete macros .En .Es .Fr .Ot for backward compatibility,
since this is hardly more complicated than explicitly ignoring them
as we did in the past.  Of course, do not use them!
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.106 2014/07/01 22:36:35 schwarze Exp $ */
d796 2
a797 1
		mdoc_pmsg(mdoc, line, (int)(ws-buf), MANDOCERR_EOLNSPACE);
d800 2
a801 1
		mdoc_pmsg(mdoc, line, (int)(c-buf), MANDOCERR_NOBLANKLN);
d851 2
a852 1
		mdoc_pmsg(mdoc, ln, offs, MANDOCERR_BADCOMMENT);
d895 2
a896 1
		mdoc_pmsg(mdoc, ln, offs - 1, MANDOCERR_EOLNSPACE);
@


1.106
log
@Clean up the warnings related to document structure.
* Hierarchical naming of the related enum mandocerr items.
* Mention the offending macro, section title, or string.
While here, improve some wordings:
* Descriptive instead of imperative style.
* Uniform style for "missing" and "skipping".
* Where applicable, mention the fallback used.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.105 2014/06/20 17:23:09 schwarze Exp $ */
d514 2
@


1.105
log
@Start systematic improvements of error reporting.
So far, this covers all WARNINGs related to the prologue.

1) hierarchical naming of MANDOCERR_* constants
2) mention the macro name in messages where that adds clarity
3) add one missing MANDOCERR_DATE_MISSING msg
4) fix the wording of one message related to the man(7) prologue

Started on the plane back from Ottawa.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.104 2014/04/25 14:10:59 schwarze Exp $ */
d34 1
a34 1
const	char *const __mdoc_macronames[MDOC_MAX] = {
d65 1
a65 1
	"%U",		"Ta",		"ll",
@


1.104
log
@Fix a minor optimization i broke in bsd.lv rev. 1.163 on August 20, 2010:
Do not bother looking into the hash table when the length of the macro
already tells us it's invalid.  No functional change.
Noticed by jsg@@, thanks!
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.103 2014/04/20 16:44:44 schwarze Exp $ */
d304 2
a305 1
		mdoc_pmsg(mdoc, line, ppos, MANDOCERR_BADBODY);
d313 2
a314 1
		mdoc_pmsg(mdoc, line, ppos, MANDOCERR_BADPROLOG);
@


1.103
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.102 2014/03/30 19:47:32 schwarze Exp $ */
d864 1
a864 1
	tok = (i > 1 || i < 4) ? mdoc_hash_find(mac) : MDOC_MAX;
@


1.102
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.101 2014/03/23 12:44:18 schwarze Exp $ */
d34 1
a34 1
const	char *const __mdoc_macronames[MDOC_MAX] = {		 
a44 1
	/* LINTED */
a45 1
	/* LINTED */
a46 1
	/* LINTED */
a62 1
	/* LINTED */
a63 1
	/* LINTED */
a64 1
	/* LINTED */
d68 1
a68 1
const	char *const __mdoc_argnames[MDOC_ARG_MAX] = {		 
d70 6
a75 6
	"unfilled",		"literal",		"file",		 
	"offset",		"bullet",		"dash",		 
	"hyphen",		"item",			"enum",		 
	"tag",			"diag",			"hang",		 
	"ohang",		"inset",		"column",	 
	"width",		"compact",		"std",	 
d84 1
a84 1
static	void		  mdoc_node_unlink(struct mdoc *, 
d88 1
a88 1
static	struct mdoc_node *node_alloc(struct mdoc *, int, int, 
d90 1
a90 1
static	int		  node_append(struct mdoc *, 
d98 1
a106 1

a114 1

a139 1

a156 1

a170 1

a182 1

d184 1
a184 1
 * Allocate volatile and non-volatile parse resources.  
a203 1

a266 1

d291 2
a292 2
			mdoc_pmacro(mdoc, ln, buf, offs) :
			mdoc_ptext(mdoc, ln, buf, offs));
d302 2
a303 2
	if (MDOC_PROLOGUE & mdoc_macros[tok].flags && 
			MDOC_PBODY & mdoc->flags) {
d310 2
a311 2
	if ( ! (MDOC_PROLOGUE & mdoc_macros[tok].flags) && 
			! (MDOC_PBODY & mdoc->flags)) {
d340 1
a340 1
	case (MDOC_NEXT_SIBLING):
d345 1
a345 1
	case (MDOC_NEXT_CHILD):
d362 1
a362 1
	case (MDOC_BODY):
d366 1
a366 1
	case (MDOC_TAIL):
d368 1
a368 1
	case (MDOC_HEAD):
d379 1
a379 1
	case (MDOC_HEAD):
d383 1
a383 1
	case (MDOC_TAIL):
d387 1
a387 1
	case (MDOC_BODY):
d400 1
a400 1
	case (MDOC_TBL):
d402 1
a402 1
	case (MDOC_TEXT):
a412 1

d414 1
a414 1
node_alloc(struct mdoc *mdoc, int line, int pos, 
a439 1

a451 1

a466 1

a478 1

a494 1

d496 1
a496 1
mdoc_block_alloc(struct mdoc *mdoc, int line, int pos, 
d507 1
a507 1
	case (MDOC_Bd):
d509 1
a509 1
	case (MDOC_Bf):
d511 1
a511 1
	case (MDOC_Bl):
d513 1
a513 1
	case (MDOC_Rs):
a525 1

d527 1
a527 1
mdoc_elem_alloc(struct mdoc *mdoc, int line, int pos, 
d538 1
a538 1
	case (MDOC_An):
a593 1

a630 1

d701 1
a701 1
	} 
d735 1
a735 1
			LIST_column == n->norm->Bl.type) {
d742 3
a744 3
			NULL != n->parent &&
			MDOC_Bl == n->parent->tok &&
			LIST_column == n->parent->norm->Bl.type) {
a829 1

d852 1
a852 1
	/* 
d858 2
a859 2
	while (i < 4 && '\0' != buf[offs] && 
			' ' != buf[offs] && '\t' != buf[offs])
d867 2
a868 2
		mandoc_vmsg(MANDOCERR_MACRO, mdoc->parse, 
				ln, sv, "%s", buf + sv - 1);
d882 1
a882 1
	/* 
d896 1
a896 1
		if ( ! mdoc_macro(mdoc, tok, ln, sv, &offs, buf)) 
d910 1
a910 1
			LIST_column == n->norm->Bl.type) {
d924 3
a926 3
			NULL != n->parent &&
			MDOC_Bl == n->parent->tok &&
			LIST_column == n->parent->norm->Bl.type) {
d928 1
a928 1
		if ( ! mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf)) 
d935 1
a935 1
	if ( ! mdoc_macro(mdoc, tok, ln, sv, &offs, buf)) 
d961 1
a961 1
		case('('):
d963 1
a963 1
		case('['):
d965 1
a965 1
		case('|'):
d967 1
a967 1
		case('.'):
d969 1
a969 1
		case(','):
d971 1
a971 1
		case(';'):
d973 1
a973 1
		case(':'):
d975 1
a975 1
		case('?'):
d977 1
a977 1
		case('!'):
d979 1
a979 1
		case(')'):
d981 1
a981 1
		case(']'):
@


1.101
log
@If an .Nd block contains macros, avoid fragmented entries in mandocdb(8),
instead use the .Nd content recursively.
Improves a couple of index entries in base.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.100 2014/03/21 22:52:21 schwarze Exp $ */
d71 1
a71 1
	"%U",		"Ta"
@


1.100
log
@avoid repetitive code for asprintf error handling
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.99 2014/03/21 22:17:01 schwarze Exp $ */
d21 1
d1019 39
@


1.99
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.98 2014/01/05 20:26:27 schwarze Exp $ */
d593 1
a593 4
	if (-1 == asprintf(&newstr, "%s %s", n->string, addstr)) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
@


1.98
log
@Add an option -Q (quick) to mandocdb(8)
for accelerated generation of reduced-size databases.

Implement this by allowing the parsers to optionally
abort the parse sequence after the NAME section.

While here, garbage collect the unused void *arg attribute
of struct mparse and mparse_alloc().

This reduces the processing time of mandocdb(8) on /usr/share/man
by a factor of 2 and the database size by a factor of 4.
However, it still takes 5 times the time and 6 times the space
of makewhatis(8), so more work is clearly needed.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.97 2013/12/30 00:52:18 schwarze Exp $ */
d29 1
@


1.97
log
@Simplify: Remove an unused argument from the mandoc_eos() function.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.96 2013/12/24 19:10:34 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d196 2
a197 1
mdoc_alloc(struct roff *roff, struct mparse *parse, char *defos)
d205 1
d961 6
@


1.96
log
@When deciding whether two consecutive macros are on the same input line,
we have to compare the line where the first one *ends* (not where it begins)
to the line where the second one starts.
This fixes the bug that .Bk allowed output line breaks right after block
macros spanning more than one input line, even when the next macro follows
on the same line.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.95 2013/10/21 23:32:32 schwarze Exp $ */
d845 1
a845 1
	if (mandoc_eos(buf+offs, (size_t)(end-buf-offs), 0))
@


1.95
log
@There are three kinds of input lines: text lines, macros taking
positional arguments (like Dt Fn Xr) and macros taking text as
arguments (like Nd Sh Em %T An).  In the past, even the latter put
each word of their arguments into its own MDOC_TEXT node; instead,
concatenate arguments unless delimiters, keeps or spacing mode
prevent that.  Regarding mandoc(1), this is internal refactoring,
no output change intended.

Once we will switch mandocdb(8) from DB to SQLite in the future,
this is going to be required to support search expressions crossing
word boundaries, and it will reduce both database sizes and build
times by a bit more than 5% each.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.94 2013/10/03 19:32:25 schwarze Exp $ */
d433 1
@


1.94
log
@Support setting arbitrary roff(7) number registers,
preserving read support for the ".nr nS" SYNOPSIS state register;
read support for arbitrary registers is still not available.

Inspired by NetBSD roff.c rev. 1.18 (Christos Zoulas, March 21, 2013),
but implemented differently.  I don't want to have yet another different
implementation of a hash table in mandoc - it would be the second one
in roff.c alone and the fifth one in mandoc grand total.
Instead, i designed and implemented roff_setreg() and roff_getreg()
to be similar to roff_setstrn() and roff_getstrn().

Once we feel the need to optimize, we can introduce one common
hash table implementation for everything in mandoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.93 2012/11/17 00:25:20 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d581 17
@


1.93
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.92 2012/11/16 13:25:34 schwarze Exp $ */
d294 4
a297 6
	if (roff_regisset(mdoc->roff, REG_nS)) {
		if (roff_regget(mdoc->roff, REG_nS))
			mdoc->flags |= MDOC_SYNOPSIS;
		else
			mdoc->flags &= ~MDOC_SYNOPSIS;
	}
@


1.92
log
@Fix a crash triggered by .Bl -tag .It Xo .El .Sh found by florian@@.

* When allocating a body end marker, copy the pointer to the normalized
block information from the body block, avoiding the risk of subsequent
null pointer derefence.
* When inserting the body end marker into the syntax tree, do not try to
copy that pointer from the parent block, because not being a direkt child
of the block it belongs to is the whole point of a body end marker.
* Even non-callable blocks (like Bd and Bl) can break other blocks;
when this happens, postpone closing them out in the usual way.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.91 2012/07/18 11:09:30 schwarze Exp $ */
d103 1
a103 1
mdoc_node(const struct mdoc *m)
d106 2
a107 2
	assert( ! (MDOC_HALT & m->flags));
	return(m->first);
d112 1
a112 1
mdoc_meta(const struct mdoc *m)
d115 2
a116 2
	assert( ! (MDOC_HALT & m->flags));
	return(&m->meta);
d217 1
a217 1
mdoc_endparse(struct mdoc *m)
d220 2
a221 2
	assert( ! (MDOC_HALT & m->flags));
	if (mdoc_macroend(m))
d223 1
a223 1
	m->flags |= MDOC_HALT;
d228 1
a228 1
mdoc_addeqn(struct mdoc *m, const struct eqn *ep)
d232 1
a232 1
	assert( ! (MDOC_HALT & m->flags));
d236 2
a237 2
	if (SEC_NONE == m->lastnamed) {
		mdoc_pmsg(m, ep->ln, ep->pos, MANDOCERR_NOTEXT);
d241 1
a241 1
	n = node_alloc(m, ep->ln, ep->pos, MDOC_MAX, MDOC_EQN);
d244 1
a244 1
	if ( ! node_append(m, n))
d247 1
a247 1
	m->next = MDOC_NEXT_SIBLING;
d252 1
a252 1
mdoc_addspan(struct mdoc *m, const struct tbl_span *sp)
d256 1
a256 1
	assert( ! (MDOC_HALT & m->flags));
d260 2
a261 2
	if (SEC_NONE == m->lastnamed) {
		mdoc_pmsg(m, sp->line, 0, MANDOCERR_NOTEXT);
d265 1
a265 1
	n = node_alloc(m, sp->line, 0, MDOC_MAX, MDOC_TBL);
d268 1
a268 1
	if ( ! node_append(m, n))
d271 1
a271 1
	m->next = MDOC_NEXT_SIBLING;
d281 1
a281 1
mdoc_parseln(struct mdoc *m, int ln, char *buf, int offs)
d284 1
a284 1
	assert( ! (MDOC_HALT & m->flags));
d286 1
a286 1
	m->flags |= MDOC_NEWLINE;
d294 3
a296 3
	if (roff_regisset(m->roff, REG_nS)) {
		if (roff_regget(m->roff, REG_nS))
			m->flags |= MDOC_SYNOPSIS;
d298 1
a298 1
			m->flags &= ~MDOC_SYNOPSIS;
d301 3
a303 3
	return(roff_getcontrol(m->roff, buf, &offs) ?
			mdoc_pmacro(m, ln, buf, offs) :
			mdoc_ptext(m, ln, buf, offs));
d314 2
a315 2
			MDOC_PBODY & m->flags) {
		mdoc_pmsg(m, line, ppos, MANDOCERR_BADBODY);
d322 14
a335 14
			! (MDOC_PBODY & m->flags)) {
		mdoc_pmsg(m, line, ppos, MANDOCERR_BADPROLOG);
		if (NULL == m->meta.msec)
			m->meta.msec = mandoc_strdup("1");
		if (NULL == m->meta.title)
			m->meta.title = mandoc_strdup("UNKNOWN");
		if (NULL == m->meta.vol)
			m->meta.vol = mandoc_strdup("LOCAL");
		if (NULL == m->meta.os)
			m->meta.os = mandoc_strdup("LOCAL");
		if (NULL == m->meta.date)
			m->meta.date = mandoc_normdate
				(m->parse, NULL, line, ppos);
		m->flags |= MDOC_PBODY;
d338 1
a338 1
	return((*mdoc_macros[tok].fp)(m, tok, line, ppos, pos, buf));
d426 1
a426 1
node_alloc(struct mdoc *m, int line, int pos, 
d432 1
a432 1
	p->sec = m->lastsec;
d440 1
a440 1
	if (MDOC_SYNOPSIS & m->flags)
d444 1
a444 1
	if (MDOC_NEWLINE & m->flags)
d446 1
a446 1
	m->flags &= ~MDOC_NEWLINE;
d453 1
a453 1
mdoc_tail_alloc(struct mdoc *m, int line, int pos, enum mdoct tok)
d457 2
a458 2
	p = node_alloc(m, line, pos, tok, MDOC_TAIL);
	if ( ! node_append(m, p))
d460 1
a460 1
	m->next = MDOC_NEXT_CHILD;
d466 1
a466 1
mdoc_head_alloc(struct mdoc *m, int line, int pos, enum mdoct tok)
d470 2
a471 2
	assert(m->first);
	assert(m->last);
d473 2
a474 2
	p = node_alloc(m, line, pos, tok, MDOC_HEAD);
	if ( ! node_append(m, p))
d476 1
a476 1
	m->next = MDOC_NEXT_CHILD;
d482 1
a482 1
mdoc_body_alloc(struct mdoc *m, int line, int pos, enum mdoct tok)
d486 2
a487 2
	p = node_alloc(m, line, pos, tok, MDOC_BODY);
	if ( ! node_append(m, p))
d489 1
a489 1
	m->next = MDOC_NEXT_CHILD;
d495 1
a495 1
mdoc_endbody_alloc(struct mdoc *m, int line, int pos, enum mdoct tok,
d500 1
a500 1
	p = node_alloc(m, line, pos, tok, MDOC_BODY);
d504 1
a504 1
	if ( ! node_append(m, p))
d506 1
a506 1
	m->next = MDOC_NEXT_SIBLING;
d512 1
a512 1
mdoc_block_alloc(struct mdoc *m, int line, int pos, 
d517 1
a517 1
	p = node_alloc(m, line, pos, tok, MDOC_BLOCK);
d536 1
a536 1
	if ( ! node_append(m, p))
d538 1
a538 1
	m->next = MDOC_NEXT_CHILD;
d544 1
a544 1
mdoc_elem_alloc(struct mdoc *m, int line, int pos, 
d549 1
a549 1
	p = node_alloc(m, line, pos, tok, MDOC_ELEM);
d562 1
a562 1
	if ( ! node_append(m, p))
d564 1
a564 1
	m->next = MDOC_NEXT_CHILD;
d569 1
a569 1
mdoc_word_alloc(struct mdoc *m, int line, int pos, const char *p)
d573 2
a574 2
	n = node_alloc(m, line, pos, MDOC_MAX, MDOC_TEXT);
	n->string = roff_strdup(m->roff, p);
d576 1
a576 1
	if ( ! node_append(m, n))
d579 1
a579 1
	m->next = MDOC_NEXT_SIBLING;
d599 1
a599 1
mdoc_node_unlink(struct mdoc *m, struct mdoc_node *n)
d621 1
a621 1
	if (m && m->last == n) {
d623 2
a624 2
			m->last = n->prev;
			m->next = MDOC_NEXT_SIBLING;
d626 2
a627 2
			m->last = n->parent;
			m->next = MDOC_NEXT_CHILD;
d631 2
a632 2
	if (m && m->first == n)
		m->first = NULL;
d637 1
a637 1
mdoc_node_delete(struct mdoc *m, struct mdoc_node *p)
d642 1
a642 1
		mdoc_node_delete(m, p->child);
d646 1
a646 1
	mdoc_node_unlink(m, p);
d651 1
a651 1
mdoc_node_relink(struct mdoc *m, struct mdoc_node *p)
d654 2
a655 2
	mdoc_node_unlink(m, p);
	return(node_append(m, p));
d669 1
a669 1
mdoc_preptext(struct mdoc *m, int line, char *buf, int offs)
d677 1
a677 1
		if ('\0' != (delim = roff_eqndelim(m->roff)))
d682 1
a682 1
		if ( ! mdoc_ptext(m, line, buf, offs))
d699 1
a699 1
		roff_openeqn(m->roff, NULL, line, offs, buf);
d702 2
a703 2
		if (roff_closeeqn(m->roff))
			if ( ! mdoc_addeqn(m, roff_eqn(m->roff)))
d717 1
a717 1
mdoc_ptext(struct mdoc *m, int line, char *buf, int offs)
d724 2
a725 2
	if (SEC_NONE == m->lastnamed) {
		mdoc_pmsg(m, line, offs, MANDOCERR_NOTEXT);
d729 2
a730 2
	assert(m->last);
	n = m->last;
d742 2
a743 2
		m->flags |= MDOC_FREECOL;
		return(mdoc_macro(m, MDOC_It, line, offs, &offs, buf));
d751 2
a752 2
		m->flags |= MDOC_FREECOL;
		return(mdoc_macro(m, MDOC_It, line, offs, &offs, buf));
d780 1
a780 1
			if (MDOC_LITERAL & m->flags)
d797 1
a797 1
		mdoc_pmsg(m, line, (int)(ws-buf), MANDOCERR_EOLNSPACE);
d799 2
a800 2
	if ('\0' == buf[offs] && ! (MDOC_LITERAL & m->flags)) {
		mdoc_pmsg(m, line, (int)(c-buf), MANDOCERR_NOBLANKLN);
d807 1
a807 1
		if ( ! mdoc_elem_alloc(m, line, offs, MDOC_sp, NULL))
d810 1
a810 1
		m->next = MDOC_NEXT_SIBLING;
d812 1
a812 1
		return(mdoc_valid_post(m));
d815 1
a815 1
	if ( ! mdoc_word_alloc(m, line, offs, buf+offs))
d818 1
a818 1
	if (MDOC_LITERAL & m->flags)
d830 1
a830 1
		m->last->flags |= MDOC_EOS;
d841 1
a841 1
mdoc_pmacro(struct mdoc *m, int ln, char *buf, int offs)
d851 1
a851 1
		mdoc_pmsg(m, ln, offs, MANDOCERR_BADCOMMENT);
d873 1
a873 1
		mandoc_vmsg(MANDOCERR_MACRO, m->parse, 
d894 1
a894 1
		mdoc_pmsg(m, ln, offs - 1, MANDOCERR_EOLNSPACE);
d901 2
a902 2
	if (NULL == m->last || MDOC_It == tok || MDOC_El == tok) {
		if ( ! mdoc_macro(m, tok, ln, sv, &offs, buf)) 
d907 2
a908 2
	n = m->last;
	assert(m->last);
d917 2
a918 2
		m->flags |= MDOC_FREECOL;
		if ( ! mdoc_macro(m, MDOC_It, ln, sv, &sv, buf))
d933 2
a934 2
		m->flags |= MDOC_FREECOL;
		if ( ! mdoc_macro(m, MDOC_It, ln, sv, &sv, buf)) 
d941 1
a941 1
	if ( ! mdoc_macro(m, tok, ln, sv, &offs, buf)) 
d948 1
a948 1
	m->flags |= MDOC_HALT;
@


1.91
log
@Fix handling of paragraph macros inside lists:
* When they are trailing the last item, move them outside the list.
* When they are trailing any other none-compact item, drop them.

Improves formatting of 40 pages, e.g. grep(1), ksh(1), netstat(1),
ath(4), bsd.port.mk(5), pf.conf(5), mount(8), crypto(9).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.90 2012/07/18 10:36:20 schwarze Exp $ */
d374 2
d502 1
@


1.90
log
@The mdoc(7) \*(Ba predefined string actually forces roman font;
that's stupid because it may break enclosing font changes,
but let's do the same for groff bug compatibility.

--> Never use \*(Ba, use just plain "|"! <--

Also, predefined strings are already expanded by the roff(7) parser,
so the mdoc(7) parser has to look for the expanded string.

Formatting improvements in ksh(1), less(1), atan2(3),
hostapd.conf(5), snmpd.conf(5), and mknod(8).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.89 2012/07/16 09:51:03 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d645 8
@


1.89
log
@Several -mdoc parser improvements related to vertical spacing:
* So far, .Pp and .Lp were removed before paragraph type blocks.
* Now also remove .br before paragraph type blocks.
* Treat .Lp as a paragraph like .Pp, so remove .Pp, .Lp, .br before it.
* Do not treat .sp as a paragraph, don't remove anything before it.
* After .Sh, .Ss, .Pp, and .Lp, remove .Pp, .Lp, .sp, .br, and blank lines.
* After .sp and .br, remove .br.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.88 2012/07/07 18:27:36 schwarze Exp $ */
d981 1
a981 1
	if (0 == strcmp(p + 1, "*(Ba"))
@


1.88
log
@Support the .cc request; code by kristaps@@, tests by me.
Needed for sqlite3(1) as reported by espie@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.87 2012/05/24 23:33:23 schwarze Exp $ */
d800 2
a801 1
		return(1);
@


1.87
log
@Support -Ios='OpenBSD 5.1' to override uname(3) as the source of the
default value for the mdoc(7) .Os macro.
Needed for man.cgi on the OpenBSD website.

Problem with man.cgi first noticed by deraadt@@;
beck@@ and deraadt@@ agree with the way to solve the issue.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.86 2011/09/30 00:13:21 schwarze Exp $ */
d301 1
a301 1
	return(mandoc_getcontrol(buf, &offs) ?
@


1.86
log
@implement .Ap .Bd .Bo .Bq .D1 .Ic .Lp .Oo .Pf .Po .Ss .Sx .Sy .br .sp
implement .Bl -bullet
add more information to the .TH line
escape dots at the beginnings of lines
add trailing newline character at the end of the file
do not misinterpret the ROOT block as .Ap
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.85 2011/09/18 15:54:48 schwarze Exp $ */
d196 1
a196 1
mdoc_alloc(struct roff *roff, struct mparse *parse)
d203 1
@


1.85
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.84 2011/09/18 10:25:28 schwarze Exp $ */
d159 1
@


1.84
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.83 2011/04/24 16:22:02 schwarze Exp $ */
a566 3
	size_t		  sv, len;

	len = strlen(p);
d569 1
a569 5
	n->string = mandoc_malloc(len + 1);
	sv = strlcpy(n->string, p, len + 1);

	/* Prohibit truncation. */
	assert(sv < len + 1);
a750 5
		case '-':
			if (mandoc_hyph(buf + offs, c))
				*c = ASCII_HYPH;
			ws = NULL;
			break;
@


1.83
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.82 2011/04/21 22:59:54 schwarze Exp $ */
d96 3
d195 1
a195 1
mdoc_alloc(struct regset *regs, struct mparse *parse)
d202 1
a202 1
	p->regs = regs;
d235 1
a235 1
		mdoc_pmsg(m, ep->line, ep->pos, MANDOCERR_NOTEXT);
d239 1
a239 1
	n = node_alloc(m, ep->line, ep->pos, MDOC_MAX, MDOC_EQN);
d292 2
a293 2
	if (m->regs->regs[(int)REG_nS].set) {
		if (m->regs->regs[(int)REG_nS].v.u)
d652 53
@


1.82
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.81 2011/03/20 23:36:42 schwarze Exp $ */
d27 1
d192 1
a192 1
mdoc_alloc(struct regset *regs, void *data, mandocmsg msg)
d198 1
a198 2
	p->msg = msg;
	p->data = data;
d296 1
a296 1
	return(('.' == buf[offs] || '\'' == buf[offs]) ? 
a300 16

void
mdoc_vmsg(struct mdoc *mdoc, enum mandocerr t, 
		int ln, int pos, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);

	(*mdoc->msg)(t, mdoc->data, ln, pos, buf);
}


d328 2
a329 2
			m->meta.date = mandoc_normdate(NULL,
			    m->msg, m->data, line, ppos);
a659 9
	/* Ignore bogus comments. */

	if ('\\' == buf[offs] && 
			'.' == buf[offs + 1] && 
			'"' == buf[offs + 2]) {
		mdoc_pmsg(m, line, offs, MANDOCERR_BADCOMMENT);
		return(1);
	}

d786 1
a786 1
	int		  i, j, sv;
d790 1
a790 1
	/* Empty lines are ignored. */
d792 4
a795 3
	offs++;

	if ('\0' == buf[offs])
d798 1
a798 13
	i = offs;

	/* Accept tabs/whitespace after the initial control char. */

	if (' ' == buf[i] || '\t' == buf[i]) {
		i++;
		while (buf[i] && (' ' == buf[i] || '\t' == buf[i]))
			i++;
		if ('\0' == buf[i])
			return(1);
	}

	sv = i;
d805 8
a812 4
	j = 0;
	while (j < 4 && '\0' != buf[i] && ' ' != buf[i] && '\t' != buf[i])
		mac[j++] = buf[i++];
	mac[j] = '\0';
a813 1
	tok = (j > 1 || j < 4) ? mdoc_hash_find(mac) : MDOC_MAX;
d815 2
a816 1
		mdoc_vmsg(m, MANDOCERR_MACRO, ln, sv, "%s", buf + sv - 1);
d822 2
a823 2
	if ('\t' == buf[i])
		i++;
d827 2
a828 2
	while (buf[i] && ' ' == buf[i])
		i++;
d835 2
a836 2
	if ('\0' == buf[i] && ' ' == buf[i - 1])
		mdoc_pmsg(m, ln, i - 1, MANDOCERR_EOLNSPACE);
d844 1
a844 1
		if ( ! mdoc_macro(m, tok, ln, sv, &i, buf)) 
d883 1
a883 1
	if ( ! mdoc_macro(m, tok, ln, sv, &i, buf)) 
d894 37
d932 7
@


1.81
log
@Import the foundation for eqn(7) support.
Written by kristaps@@.

For now, i'm adding one line to each of the four frontends
to just pass the input text through to the output,
not yet interpreting any of then eqn keywords.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.80 2011/03/07 01:35:33 schwarze Exp $ */
d137 2
d302 1
a302 1
int
d313 1
a313 1
	return((*mdoc->msg)(t, mdoc->data, ln, pos, buf));
@


1.80
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.79 2011/02/10 00:06:30 schwarze Exp $ */
d218 24
@


1.79
log
@Tbl code maintenance by kristaps@@.
- Remember the line-number of a tbl_span, and use it in messages.
- Put *_span_alloc() functions right into the *_addspan() ones,
  since these are the only places they are called from.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.78 2011/01/09 13:16:48 schwarze Exp $ */
d317 3
a319 2
		if (0 == m->meta.date)
			m->meta.date = time(NULL);
@


1.78
log
@Make sure coding errors cannot make us miss fatal parsing errors
by assert(3)ing valid parser state in the main parsing functions;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.77 2011/01/04 22:28:17 schwarze Exp $ */
a96 3
static	int		  mdoc_span_alloc(struct mdoc *, 
				const struct tbl_span *);

d223 1
d230 1
a230 2
		/* FIXME: grab from span. */
		mdoc_pmsg(m, 0, 0, MANDOCERR_NOTEXT);
d234 8
a241 1
	return(mdoc_span_alloc(m, sp));
a547 17

static int
mdoc_span_alloc(struct mdoc *m, const struct tbl_span *sp)
{
	struct mdoc_node *n;

	/* FIXME: grab from tbl_span. */
	n = node_alloc(m, 0, 0, MDOC_MAX, MDOC_TBL);
	n->span = sp;

	if ( ! node_append(m, n))
		return(0);

	m->next = MDOC_NEXT_SIBLING;
	return(1);
}

@


1.77
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.76 2011/01/01 17:38:11 schwarze Exp $ */
d105 2
a106 1
	return(MDOC_HALT & m->flags ? NULL : m->first);
d114 2
a115 1
	return(MDOC_HALT & m->flags ? NULL : &m->meta);
d216 2
a217 3
	if (MDOC_HALT & m->flags)
		return(0);
	else if (mdoc_macroend(m))
d227 1
a227 2
	if (MDOC_HALT & m->flags)
		return(0);
d249 1
a249 2
	if (MDOC_HALT & m->flags)
		return(0);
@


1.76
log
@Clean up {mdoc,man}_{p,v}msg invocations:
Ignore the return values, they are constant anyway.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.75 2010/12/29 00:47:30 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
a30 4
#include "out.h"
#include "term.h"
#include "tbl.h"

d68 1
a68 1
	"%U",		"Ta",		"TS",		"TE"
d97 2
d222 18
a247 1
	struct mdoc_node *n;
a253 11
	n = m->last;

	if (n && MDOC_TS == n->tok && MDOC_BODY == n->type &&
	    strncmp(buf+offs, ".TE", 3)) {
		n = n->parent;
		if ( ! tbl_read(n->norm->TS, "mdoc tbl parser",
		    ln, buf+offs, strlen(buf+offs)))
			mdoc_nmsg(m, n, MANDOCERR_TBL);
		return(1);
	}

d390 2
a507 2
		/* FALLTHROUGH */
	case (MDOC_TS):
d546 16
a588 4

	if (MDOC_TS == p->tok && MDOC_BLOCK == p->type)
		if (p->norm->TS)
			tbl_free(p->norm->TS);
@


1.75
log
@Reorg by Kristaps:  In libmdoc, replace the union of pointers to structs
of macro-specific data by a pointer to a union of structs, which makes the
code simpler and more robust at the expense of a small memory overhead.
Merging was somewhat difficult because we mustn't break tbl(1) support
which the bsd.lv version does not yet have.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.74 2010/12/26 21:04:19 schwarze Exp $ */
d292 4
a295 2
			MDOC_PBODY & m->flags)
		return(mdoc_pmsg(m, line, ppos, MANDOCERR_BADBODY));
d301 1
a301 2
		if ( ! mdoc_pmsg(m, line, ppos, MANDOCERR_BADPROLOG))
			return(0);
d651 4
a654 2
			'"' == buf[offs + 2])
		return(mdoc_pmsg(m, line, offs, MANDOCERR_BADCOMMENT));
d658 4
a661 2
	if (SEC_NONE == m->lastnamed)
		return(mdoc_pmsg(m, line, offs, MANDOCERR_NOTEXT));
d736 1
a736 2
		if ( ! mdoc_pmsg(m, line, (int)(ws-buf), MANDOCERR_EOLNSPACE))
			return(0);
d739 1
a739 2
		if ( ! mdoc_pmsg(m, line, (int)(c-buf), MANDOCERR_NOBLANKLN))
			return(0);
d839 1
a839 2
		if ( ! mdoc_pmsg(m, ln, i - 1, MANDOCERR_EOLNSPACE))
			goto err;
@


1.74
log
@Behave more like groff (both old and new): Specifying both .%T and .%J in
an .Rs block causes the title to be quoted instead of underlined, such
that journal title and article title appear visually different.
Original diff from kristaps@@, simplified by me, tweaked again by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.73 2010/12/21 23:57:31 schwarze Exp $ */
d244 1
a244 1
		if ( ! tbl_read(n->data.TS, "mdoc tbl parser",
d343 17
d492 17
d526 9
a568 21
	/*
	 * XXX: if these end up being problematic in terms of memory
	 * management and dereferencing freed blocks, then make them
	 * into reference-counted double-pointers.
	 */

	if (MDOC_Bd == p->tok && MDOC_BLOCK == p->type)
		if (p->data.Bd)
			free(p->data.Bd);
	if (MDOC_Bl == p->tok && MDOC_BLOCK == p->type)
		if (p->data.Bl)
			free(p->data.Bl);
	if (MDOC_Bf == p->tok && MDOC_HEAD == p->type)
		if (p->data.Bf)
			free(p->data.Bf);
	if (MDOC_An == p->tok)
		if (p->data.An)
			free(p->data.An);
	if (MDOC_Rs == p->tok && MDOC_BLOCK == p->type)
		if (p->data.Rs)
			free(p->data.Rs);
d570 2
a571 2
		if (p->data.TS)
			tbl_free(p->data.TS);
d573 2
d669 1
a669 1
			LIST_column == n->data.Bl->type) {
d678 1
a678 1
			LIST_column == n->parent->data.Bl->type) {
d859 1
a859 1
			LIST_column == n->data.Bl->type) {
d875 1
a875 1
			LIST_column == n->parent->data.Bl->type) {
@


1.73
log
@Migrate .An to use a pointer to its data, like everybody else.
In preparation for a simpler ref-counted system for node data.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.72 2010/12/21 23:46:17 schwarze Exp $ */
d544 3
@


1.72
log
@Vertical spacing improvements from kristaps@@, small tweaks by me:
Add a "last child" member to struct mdoc_node.
Remove .Pp or .Lp if it is the first or last child of an .Sh or .Ss body.
Thus, no need to do the same in the front-ends any longer.
Tolerate some cases of .Pp inside .Bl.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.71 2010/12/02 19:42:47 schwarze Exp $ */
d541 3
@


1.71
log
@Properly initialize the manual section to a default when .Dt is missing.
Without this, we died on an assertion.
Problem noted and patch provided by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.70 2010/12/01 22:02:29 schwarze Exp $ */
d570 2
@


1.70
log
@Merge mdoc_action.c into mdoc_validate.c, because having two places to do
basically the same things just causes code duplication and confusion.
Work by kristaps@@, including a few bugfixes he found during the merge,
and reapplying OpenBSD changes on top.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.69 2010/11/28 19:35:33 schwarze Exp $ */
d301 2
@


1.69
log
@To avoid FATAL errors, we have been parsing and ignoring the roff
requests .am, .ami, .am1, .dei, and .rm for a long time.
Since ignoring them can (rarely) cause information loss and serious
misformatting, throw an ERROR: NOT IMPLEMENTED when finding them.
Implementing them would not be too difficult, but they are so rare
in practice that i can find better use for my time right now.

In this context,
- Put the string "NOT IMPLEMENTED" into two other error messages
as well, to distinguish them from those caused by broken input.
- Print the string "unknown macro" once, not twice in the error message
associated with MANDOCERR_MACRO, and begin printing the buffer at the
point where the unknown macro really is, not at the start of line.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.68 2010/10/16 20:49:37 schwarze Exp $ */
a342 2
	if ( ! mdoc_action_pre(mdoc, p))
		return(0);
a367 2
			return(0);
		if ( ! mdoc_action_post(mdoc))
@


1.68
log
@Do not abort() on tbl errors, reduce the risk that tbl stuff kills a build,
and provide more useful tbl error messages in a non-intrusive way.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.67 2010/10/16 13:38:29 schwarze Exp $ */
d786 1
a786 3
		mdoc_vmsg(m, MANDOCERR_MACRO, ln, sv, 
		    "unknown macro: %s%s", 
		    buf, strlen(buf) > 3 ? "..." : "");
@


1.67
log
@Support tbl(1) code embedded into mdoc(7) input files.
Very similar to what i have done in man(7) yesterday.
Allows to build cpu(4) on HPPA, wi(4), and phantasia(6).
Now we are able to build all tbl code in base.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.66 2010/09/27 21:25:28 schwarze Exp $ */
d244 4
a247 2
		return(tbl_read(n->data.TS, "<mdoc>", ln, buf+offs,
		    strlen(buf+offs)) ? 1 : 0);
@


1.66
log
@Merge the last bits of 1.10.6 (released today), most were already in:
* ignore double-.Pp
* ignore .Pp before .Bd and .Bl (unless -compact in specified)
* avoid double blank line upon .Pp, .br and friends in literal context
* cast enums to int when passing them to exit(3) to please lint(1)
While merging, fix a regression introduced by kristaps@@:
Outside literal mode, double blank lines must both be printed.
To achieve this again after kristaps@@ improvements in 1.10.6,
treat such blank lines as .sp (instead of .Pp as in 1.10.5)
and drop .Pp before .sp just like dropping .Pp before .Pp.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.65 2010/08/20 00:53:35 schwarze Exp $ */
d31 4
d72 1
a72 1
	"%U",		"Ta"
d232 1
d239 9
d541 3
@


1.65
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.64 2010/08/18 01:17:44 schwarze Exp $ */
d690 1
a690 1
		 * Insert a `Pp' in the case of a blank line.  Technically,
d694 1
a694 1
		if ( ! mdoc_elem_alloc(m, line, offs, MDOC_Pp, NULL))
@


1.64
log
@Simplify and sync the code and comments for copying the macro name
in man_pmacro() and mdoc_pmacro().  In particular, no need to use
isgraph(3) here, that has already been done in main.c.
Joint work by Kristaps and myself, ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.63 2010/08/07 18:06:45 schwarze Exp $ */
a96 2
static	int		  macrowarn(struct mdoc *, int, 
				const char *, int);
d188 1
a188 2
mdoc_alloc(struct regset *regs, void *data, 
		int pflags, mandocmsg msg)
a195 1
	p->pflags = pflags;
a721 15
static int
macrowarn(struct mdoc *m, int ln, const char *buf, int offs)
{
	int		 rc;

	rc = mdoc_vmsg(m, MANDOCERR_MACRO, ln, offs, 
			"unknown macro: %s%s", 
			buf, strlen(buf) > 3 ? "..." : "");

	/* FIXME: logic should be in driver. */
	/* FIXME: broken, will error out and not omit a message. */
	return(MDOC_IGN_MACRO & m->pflags ? rc : 0);
}


d765 5
a769 9
	if (j == 4 || j < 2) {
		if ( ! macrowarn(m, ln, mac, sv))
			goto err;
		return(1);
	} 
	
	if (MDOC_MAX == (tok = mdoc_hash_find(mac))) {
		if ( ! macrowarn(m, ln, mac, sv))
			goto err;
@


1.63
log
@Groff allows the initial macro on a line to be delimited by a space
of by a tab; so allow the tab in mandoc, too.
Bug found by me, fix by kristaps@@, "sure" deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.62 2010/07/16 00:34:33 schwarze Exp $ */
a20 1
#include <ctype.h>
d775 2
a776 2
	 * Copy the first word into a nil-terminated buffer.  Stop
	 * copying when a tab, space, or eoln is encountered.
d779 3
a781 16
	for (j = 0; j < 4; j++, i++) {
		if ('\0' == (mac[j] = buf[i]))
			break;
		else if (' ' == buf[i] || '\t' == buf[i])
			break;

		/* Check for invalid characters. */
		/* TODO: remove me, already done in main.c. */

		if (isgraph((u_char)buf[i]))
			continue;
		if ( ! mdoc_pmsg(m, ln, i, MANDOCERR_BADCHAR))
			return(0);
		i--;
	}

@


1.62
log
@Text ending in a full stop, exclamation mark or question mark
should not flag the end of a sentence if:

1) The punctuation is followed by closing delimiters
and not preceded by alphanumeric characters, like in
"There is no full stop (.) in this sentence"

or

2) The punctuation is a child of a macro
and not preceded by alphanumeric characters, like in
"There is no full stop
.Pq \&.
in this sentence"

jmc@@ and sobrado@@ like this
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.61 2010/07/13 01:09:13 schwarze Exp $ */
d763 1
a763 1
	/* Accept whitespace after the initial control char. */
d765 1
a765 1
	if (' ' == buf[i]) {
d767 1
a767 1
		while (buf[i] && ' ' == buf[i])
d775 4
a778 1
	/* Copy the first word into a nil-terminated buffer. */
d783 1
a783 1
		else if (' ' == buf[i])
d787 1
d810 6
a815 1
	/* The macro is sane.  Jump to the next word. */
@


1.61
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.60 2010/07/01 22:31:52 schwarze Exp $ */
d720 1
a720 1
	if (mandoc_eos(buf+offs, (size_t)(end-buf-offs)))
@


1.60
log
@In the mdoc(7) parser, inspect roff registers early such that all parts
of the parser can use the resulting cues.  In particular, this allows
to use .nr nS to force SYNOPSIS-style .Nm indentation outside the
SYNOPSIS as needed by ifconfig(8).

To actually make this useable, .Pp must rewind .Nm, or the rest of the
section would end up indented.  Implement a quick hack for now,
a generic solution can be designed later.

ok kristaps@@ sobrado@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.59 2010/06/29 17:10:29 schwarze Exp $ */
d3 2
a4 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
a28 1
#include "regs.h"
d513 1
a513 1
void
d517 16
d625 1
a625 1
			LIST_column == n->data.Bl.type) {
d634 1
a634 1
			LIST_column == n->parent->data.Bl.type) {
d746 1
a746 1
int
d840 1
a840 1
			LIST_column == n->data.Bl.type) {
d856 1
a856 1
			LIST_column == n->parent->data.Bl.type) {
@


1.59
log
@Support for badly nested blocks, written around the time of
the Rostock mandoc hackathon and tested and polished since,
supporting constructs like:

.Ao Bo    Ac    Bc        (exp breaking exp)
.Aq Bo    eol   Bc        (imp breaking exp)
.Ao Bq    Ac    eol       (exp breaking imp)
.Ao Bo So Bc    Ac  Sc    (double break, inner before outer)
.Ao Bo So Ac    Bc  Sc    (double break, outer before inner)
.Ao Bo    Ac So Bc  Sc    (broken breaker)
.Ao Bo So Bc Do Ac  Sc Dc (broken double breaker)

There are still two known issues which are tricky:

1) Breaking two identical explicit blocks (Ao Bo Bo Ac or Aq Bo Bo eol)
fails outright, triggering a bogus syntax error.
2) Breaking a block by two identical explicit blocks (Ao Ao Bo Ac Ac Bc
or Ao Ao Bq Ac Ac eol) still has a minor rendering error left:
"<ao1 <ao2 [bo ac2> ac1> bc]>" should not have the final ">".

We can fix these later in the tree, let's not grow this diff too large.

"get it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.58 2010/06/27 21:54:42 schwarze Exp $ */
d238 14
d386 4
a392 14

	/* Section analysis. */

	if (SEC_SYNOPSIS == p->sec)
		p->flags |= MDOC_SYNPRETTY;

	/* Register analysis. */

	if (m->regs->regs[(int)REG_nS].set) {
		if (m->regs->regs[(int)REG_nS].v.u)
			p->flags |= MDOC_SYNPRETTY;
		else
			p->flags &= ~MDOC_SYNPRETTY;
	}
@


1.58
log
@Full .nr nS support, unbreaking the kernel manuals.

Kristaps coded this from scratch after reading my .nr patch;
it is simpler and more powerful.

Registers live in struct regset in regs.h, struct man and struct mdoc
contain pointers to it.  The nS register is cleared when parsing .Sh.
Frontends respect the MDOC_SYNPRETTY flag set in mdoc node_alloc.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.57 2010/06/26 17:56:43 schwarze Exp $ */
d331 2
d432 16
@


1.57
log
@merge release 1.10.2
* bug fixes:
- interaction of ASCII_HYPH with special chars (found by Ulrich Spoerlein)
- handling of roff conditionals (found by Ulrich Spoerlein)
- .Bd -offset will no more default to 6n
* maintenance:
- more caching of .Bd and .Bl arguments for efficiency
- deconstify man(7) validation routines
- add FreeBSD library names (provided by Ulrich Spoerlein)
* start PostScript font-switching
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.56 2010/06/06 20:30:08 schwarze Exp $ */
d28 1
d191 2
a192 1
mdoc_alloc(void *data, int pflags, mandocmsg msg)
d201 1
d260 1
a260 2
mdoc_macro(struct mdoc *m, enum mdoct tok, 
		int ln, int pp, int *pos, char *buf)
d268 1
a268 1
		return(mdoc_pmsg(m, ln, pp, MANDOCERR_BADBODY));
d274 1
a274 1
		if ( ! mdoc_pmsg(m, ln, pp, MANDOCERR_BADPROLOG))
d287 1
a287 1
	return((*mdoc_macros[tok].fp)(m, tok, ln, pp, pos, buf));
d367 3
d373 15
d804 1
a804 1
		if ( ! mdoc_macro(m, MDOC_It, ln, sv, &sv, buf)) 
@


1.56
log
@Merge bsd.lv version 1.10.1 (to be released soon).

The main step forward is that this now has *much* better .Bl -column
support, now supporting many manuals that previously errored out
without producing any output.

Other fixes include:
* do not die from multiple list types, use the first and warn
* in .Bl without a type, default to -item
* various tweaks to .Dt
* fix .In, .Fd, .Ft, .Fn and .Fo formatting
* some documentation fixes and additions
* and fix a couple of bugs reported by Ulrich Spoerlein:
* better support for roff block-end "\}" without a preceding dot
* .In must not break the line outside SYNOPSIS
* spelling in some error messages

While merging, fix one regression in .In spacing
that needs to go to bsd.lv, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.55 2010/05/26 02:39:58 schwarze Exp $ */
d567 1
a567 1
			LIST_column == n->data.list) {
d576 1
a576 1
			LIST_column == n->parent->data.list) {
d782 1
a782 1
			LIST_column == n->data.list) {
d798 1
a798 1
			LIST_column == n->parent->data.list) {
@


1.55
log
@When a word does not fully fit onto the output line, but it contains
at least one hyphen, we already had support for breaking the line a the
last fitting hyphen.  This patch improves this functionality by only
breaking at hyphens in free-form text, and by not breaking at hyphens
* at the beginning or end of a word   or
* immediately preceded or followed by another hyphen   or
* escaped by a preceding backslash.

Before this patch, differences in break-at-hyphen support were one
of the major sources of noise in automatic comparisons to mdoc(7)
groff output.  Now, the remaining differences are hard to find among
the noise coming from other sources.

Where there are still differences, what we do seems to be better than
what groff does, see e.g. the chio(1) exchange and position commands
for one of the now rare examples.

idea and coding by kristaps@@

Besides, this was the last substantial code difference left
between bsd.lv and openbsd.org.  We are now in full sync.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.54 2010/05/23 22:45:00 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d68 1
a68 1
	"%U"
d275 1
a275 1
			m->meta.title = mandoc_strdup("unknown");
d277 1
a277 1
			m->meta.vol = mandoc_strdup("local");
d279 1
a279 1
			m->meta.os = mandoc_strdup("local");
d541 2
a542 1
	char		*c, *ws, *end;
d556 26
d586 2
d594 1
d679 1
d691 4
a694 3
	enum mdoct	tok;
	int		i, j, sv;
	char		mac[5];
d762 31
a792 3
	/* 
	 * Begin recursive parse sequence.  Since we're at the start of
	 * the line, we don't need to do callable/parseable checks.
d794 13
@


1.54
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.53 2010/05/20 00:58:02 schwarze Exp $ */
d562 4
@


1.53
log
@Support nested roff instructions:
* allow roff_parseln() to be re-run
* allow roff_parseln() to manipulate the line buffer offset
* support the offset in the man and mdoc libraries
* adapt .if, .ie, .el, .ig, .am* and .de* support
* interpret some instructions even in conditional-negative context
Coded by kristaps during the last day of the mandoc hackathon.

To avoid regressions in the OpenBSD tree, commit this together
with some small local additions:
* detect roff block end "\}" even on macro lines
* actually implement the ".if n" conditional
* ignore .ds, .rm and .tr in libroff

Also back my old .if/.ie/.el-handling out of libman, reverting:
man.h 1.15 man.c 1.25 man_macro.c 1.15 man_validate.c 1.19
man_action.c 1.15 man_term.c 1.28 man_html.c 1.9.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.52 2010/05/16 20:46:15 schwarze Exp $ */
d27 1
a30 55
const	char *const __mdoc_merrnames[MERRMAX] = {		 
	"trailing whitespace", /* ETAILWS */
	"unexpected quoted parameter", /* EQUOTPARM */
	"unterminated quoted parameter", /* EQUOTTERM */
	"argument parameter suggested", /* EARGVAL */
	"macro disallowed in prologue", /* EBODYPROL */
	"macro disallowed in body", /* EPROLBODY */
	"text disallowed in prologue", /* ETEXTPROL */
	"blank line disallowed", /* ENOBLANK */
	"text parameter too long", /* ETOOLONG */
	"invalid escape sequence", /* EESCAPE */
	"invalid character", /* EPRINT */
	"document has no body", /* ENODAT */
	"document has no prologue", /* ENOPROLOGUE */
	"expected line arguments", /* ELINE */
	"invalid AT&T argument", /* EATT */
	"default name not yet set", /* ENAME */
	"missing list type", /* ELISTTYPE */
	"missing display type", /* EDISPTYPE */
	"too many display types", /* EMULTIDISP */
	"too many list types", /* EMULTILIST */
	"NAME section must be first", /* ESECNAME */
	"badly-formed NAME section", /* ENAMESECINC */
	"argument repeated", /* EARGREP */
	"expected boolean parameter", /* EBOOL */
	"inconsistent column syntax", /* ECOLMIS */
	"nested display invalid", /* ENESTDISP */
	"width argument missing", /* EMISSWIDTH */
	"invalid section for this manual section", /* EWRONGMSEC */
	"section out of conventional order", /* ESECOOO */
	"section repeated", /* ESECREP */
	"invalid standard argument", /* EBADSTAND */
	"multi-line arguments discouraged", /* ENOMULTILINE */
	"multi-line arguments suggested", /* EMULTILINE */
	"line arguments discouraged", /* ENOLINE */
	"prologue macro out of conventional order", /* EPROLOOO */
	"prologue macro repeated", /* EPROLREP */
	"invalid manual section", /* EBADMSEC */
	"invalid font mode", /* EFONT */
	"invalid date syntax", /* EBADDATE */
	"invalid number format", /* ENUMFMT */
	"superfluous width argument", /* ENOWIDTH */
	"system: utsname error", /* EUTSNAME */
	"obsolete macro", /* EOBS */
	"end-of-line scope violation", /* EIMPBRK */
	"empty macro ignored", /* EIGNE */
	"unclosed explicit scope", /* EOPEN */
	"unterminated quoted phrase", /* EQUOTPHR */
	"closure macro without prior context", /* ENOCTX */
	"no description found for library", /* ELIB */
	"bad child for parent context", /* EBADCHILD */
	"list arguments preceding type", /* ENOTYPE */
	"deprecated comment style", /* EBADCOMMENT */
};

d190 1
a190 1
mdoc_alloc(void *data, int pflags, const struct mdoc_cb *cb)
d196 1
a196 3
	if (cb)
		memcpy(&p->cb, cb, sizeof(struct mdoc_cb));

d242 2
a243 19
mdoc_verr(struct mdoc *mdoc, int ln, int pos, 
		const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_err)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);

	return((*mdoc->cb.mdoc_err)(mdoc->data, ln, pos, buf));
}


int
mdoc_vwarn(struct mdoc *mdoc, int ln, int pos, const char *fmt, ...)
a247 3
	if (NULL == mdoc->cb.mdoc_warn)
		return(0);

d249 1
a249 1
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
d252 1
a252 16
	return((*mdoc->cb.mdoc_warn)(mdoc->data, ln, pos, buf));
}


int
mdoc_err(struct mdoc *m, int line, int pos, int iserr, enum merr type)
{
	const char	*p;

	p = __mdoc_merrnames[(int)type];
	assert(p);

	if (iserr)
		return(mdoc_verr(m, line, pos, p));

	return(mdoc_vwarn(m, line, pos, p));
d266 1
a266 1
		return(mdoc_perr(m, ln, pp, EPROLBODY));
d272 1
a272 1
		if ( ! mdoc_pwarn(m, ln, pp, EBODYPROL))
d548 1
a548 1
		return(mdoc_pwarn(m, line, offs, EBADCOMMENT));
d553 1
a553 1
		return(mdoc_perr(m, line, offs, ETEXTPROL));
d595 1
a595 1
		if ( ! mdoc_pwarn(m, line, (int)(ws-buf), ETAILWS))
d599 1
a599 1
		if ( ! mdoc_pwarn(m, line, (int)(c-buf), ENOBLANK))
d638 8
a645 5
	if ( ! (MDOC_IGN_MACRO & m->pflags))
		return(mdoc_verr(m, ln, offs, "unknown macro: %s%s", 
				buf, strlen(buf) > 3 ? "..." : ""));
	return(mdoc_vwarn(m, ln, offs, "unknown macro: %s%s",
				buf, strlen(buf) > 3 ? "..." : ""));
d693 3
a695 1
		return(mdoc_perr(m, ln, i, EPRINT));
d723 1
a723 1
		if ( ! mdoc_pwarn(m, ln, i - 1, ETAILWS))
@


1.52
log
@Rewrite the main mdoc text parser, mdoc_ptext()
to make it easier to understand and to fix various bugs:
* strip white space from the end MDOC_TEXT elements in literal mode
* in literal mode, a line may be blank even when containing tabs
* escaped backslashes do not escape following characters
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.51 2010/05/16 01:16:25 schwarze Exp $ */
d149 4
a152 3
static	int		  mdoc_ptext(struct mdoc *, int, char *);
static	int		  mdoc_pmacro(struct mdoc *, int, char *);
static	int		  macrowarn(struct mdoc *, int, const char *);
d284 1
a284 1
mdoc_parseln(struct mdoc *m, int ln, char *buf)
d291 3
a293 3
	return(('.' == *buf || '\'' == *buf) ? 
			mdoc_pmacro(m, ln, buf) :
			mdoc_ptext(m, ln, buf));
d630 1
a630 1
mdoc_ptext(struct mdoc *m, int line, char *buf)
d636 4
a639 2
	if ('\\' == buf[0] && '.' == buf[1] && '\"' == buf[2])
		return(mdoc_pwarn(m, line, 0, EBADCOMMENT));
d644 1
a644 1
		return(mdoc_perr(m, line, 0, ETEXTPROL));
d651 1
a651 1
	for (c = end = buf; *c; c++) {
d689 1
a689 1
	if ('\0' == *buf && ! (MDOC_LITERAL & m->flags)) {
d698 1
a698 1
		if ( ! mdoc_elem_alloc(m, line, 0, MDOC_Pp, NULL))
d705 1
a705 1
	if ( ! mdoc_word_alloc(m, line, 0, buf))
d719 1
a719 1
	if (mandoc_eos(buf, (size_t)(end-buf)))
d727 1
a727 1
macrowarn(struct mdoc *m, int ln, const char *buf)
d730 1
a730 1
		return(mdoc_verr(m, ln, 0, "unknown macro: %s%s", 
d732 1
a732 1
	return(mdoc_vwarn(m, ln, 0, "unknown macro: %s%s",
d742 1
a742 1
mdoc_pmacro(struct mdoc *m, int ln, char *buf)
d750 3
a752 1
	if ('\0' == buf[1])
d755 1
a755 1
	i = 1;
d784 1
a784 1
	mac[j] = 0;
d787 1
a787 1
		if ( ! macrowarn(m, ln, mac))
d793 1
a793 1
		if ( ! macrowarn(m, ln, mac))
@


1.51
log
@allow the single quote as a control character in place of the dot
at all relevant places;
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.50 2010/05/15 18:25:51 schwarze Exp $ */
d631 1
a631 1
	int		 i;
d643 38
a680 4
	/* Literal just gets pulled in as-is. */
	
	if (MDOC_LITERAL & m->flags)
		return(mdoc_word_alloc(m, line, 0, buf));
d682 3
a684 4
	/* Check for a blank line, which may also consist of spaces. */

	for (i = 0; ' ' == buf[i]; i++)
		/* Skip to first non-space. */ ;
d686 2
a687 2
	if ('\0' == buf[i]) {
		if ( ! mdoc_pwarn(m, line, 0, ENOBLANK))
a701 24
	/* 
	 * Warn if the last un-escaped character is whitespace. Then
	 * strip away the remaining spaces (tabs stay!).   
	 */

	i = (int)strlen(buf);
	assert(i);

	if (' ' == buf[i - 1] || '\t' == buf[i - 1]) {
		if (i > 1 && '\\' != buf[i - 2])
			if ( ! mdoc_pwarn(m, line, i - 1, ETAILWS))
				return(0);

		for (--i; i && ' ' == buf[i]; i--)
			/* Spin back to non-space. */ ;

		/* Jump ahead of escaped whitespace. */
		i += '\\' == buf[i] ? 2 : 1;

		buf[i] = '\0';
	}

	/* Allocate the whole word. */

d705 3
d714 1
a714 1
	assert(i);
d716 1
a716 1
	if (mandoc_eos(buf, (size_t)i))
@


1.50
log
@allow non-numeric manual sections in -mdoc;
while here, allow LIBRARY in section 9;
by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.49 2010/05/15 16:48:12 schwarze Exp $ */
d290 1
a290 1
	return('.' == *buf ? 
@


1.49
log
@various improvements regarding errors and warnings Joerg Sonnenberger:
* If the last -column .Bl isn't specified, it is auto-sized.
* An invalid .St argument should be a warning, not an error.
  Just put the argument into the output.
* An invalid .At argument should be a warning, not an error.
  Just print the argument, like new groff does.
* Remove warnings concerning manual section (like 1, 6, 8).
  It was only used for .Ex and not really useful.
* Remove warnings concerning page section (like SYNOPSIS).
  These were only used for .Fd and .Lb and not really useful.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.48 2010/05/14 19:52:43 schwarze Exp $ */
d67 1
a67 1
	"invalid section", /* EBADSEC */
d189 2
@


1.48
log
@Integrate kristaps@@' end-of-sentence (EOS) framework
which is simpler and more powerful than mine, and remove mine.

* man(7) now has EOS handling, too
* put EOS detection into its own function in libmandoc
* use node and termp flags to communicate the EOS condition
* no more EOS pseudo-macro
* no more non-printable EOS marker character on the formatter level

This slightly breaks EOS detection after trailing punctuation
in mdoc(7) macros, but that will be restored soon.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.47 2010/05/14 14:47:44 schwarze Exp $ */
a66 1
	"invalid manual section", /* EBADMSEC */
@


1.47
log
@Merge 1.9.25, keeping local patches;
this does not merge kristaps' end-of-sentences handling yet,
i will check that separately.  This one includes:
* handle \*(Ba as a delimiter
* introduce ARGS_PEND for .Bl -column .It end-of-line special casing
* section ordering: expect EXIT STATUS at the right place
* line break fixes in SYNOPSIS
* allow literal contexts to have arbitrary line lengths
* the input file column number can not be used to identify the beginning
  of a line because white space is allowed after the initial '.'
* proper leading spaces in -man -Tascii mode
* do not let Lb break lines in -mdoc -Thtml LIBRARY
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.46 2010/05/14 01:54:37 schwarze Exp $ */
d123 1
a123 1
	"%U",		"eos"
d691 1
d696 3
a698 2
	 * Mark the end of a sentence.  Only works when you respect
	 * Jason's rule: "new sentence, new line".
a699 5
	if ('.' == buf[i-1] || '!' == buf[i-1] || '?' == buf[i-1]) {
		m->next = MDOC_NEXT_SIBLING;
		if ( ! mdoc_elem_alloc(m, line, i, MDOC_eos, NULL))
			return(0);
	}
d701 5
a705 1
	m->next = MDOC_NEXT_SIBLING;
a730 2
	struct mdoc_node *n;
	char		 *t;
a799 23

	/*
	 * Mark the end of a sentence, but be careful not to insert
	 * markers into reference blocks and after ellipses in
	 * function definitions.
	 */
	n = m->last;
	if (n->child)
		n = n->child;
	while (n->next)
		n = n->next;
	if (MDOC_TEXT == n->type &&
	    MDOC_Fn != n->parent->tok &&
	    MDOC_Rs != m->last->parent->tok) {
		t = n->string;
		while (t[0] && t[1])
			t++;
		if ('.' == *t || '!' == *t || '?' == *t) {
			if ( ! mdoc_elem_alloc(m, ln, i, MDOC_eos, NULL))
				return(0);
			m->next = MDOC_NEXT_SIBLING;
		}
	}
@


1.46
log
@merge 1.9.24, keeping local patches; some changes:
* preserve multiple consecutive space characters in input
* do not restrict .Cd and .Rv to certain sections (requested by Joerg)
* do not run lookup() on quoted words
* enum return types for mdoc_args and mdoc_argv
* fix auto-closing of LINK tag in -Txhtml (from Daniel Friesel)
* various lint and manual fixes
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.45 2010/05/08 01:57:33 schwarze Exp $ */
d288 3
a290 1
	return('.' == *buf ? mdoc_pmacro(m, ln, buf) :
d454 3
a456 1

d728 1
a728 1
	int		i, j;
d750 2
d799 1
a799 1
	if ( ! mdoc_macro(m, tok, ln, 1, &i, buf)) 
@


1.45
log
@merge bsd.lv rev 1.123:
sync mdoc.c's static function names with man.c
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.44 2010/05/08 01:52:07 schwarze Exp $ */
d153 1
a153 2
static	int		  pstring(struct mdoc *, int, int, 
				const char *, size_t);
d347 3
a350 5
	assert(tok < MDOC_MAX);
	/*
	 * If we're in the prologue, deny "body" macros.  Similarly, if
	 * we're in the body, deny prologue calls.
	 */
d354 3
d533 2
a534 2
static int
pstring(struct mdoc *m, int line, int pos, const char *p, size_t len)
d537 3
a539 1
	size_t		  sv;
d541 1
a541 1
	n = node_alloc(m, line, pos, -1, MDOC_TEXT);
d550 1
a555 8
int
mdoc_word_alloc(struct mdoc *m, int line, int pos, const char *p)
{

	return(pstring(m, line, pos, p, strlen(p)));
}


d626 1
a626 2
	int		 i, j;
	char		 sv;
d633 2
d637 2
a639 5
	/*
	 * If in literal mode, then pass the buffer directly to the
	 * back-end, as it should be preserved as a single term.
	 */

d643 1
a643 1
	/* Disallow blank/white-space lines in non-literal mode. */
d646 1
a646 1
		/* Skip leading whitespace. */ ;
d651 1
d653 3
a655 4
		 * Assume that a `Pp' should be inserted in the case of
		 * a blank line.  Technically, blank lines aren't
		 * allowed, but enough manuals assume this behaviour
		 * that we want to work around it.
d659 1
d664 3
a666 3
	/*
	 * Break apart a free-form line into tokens.  Spaces are
	 * stripped out of the input.
d669 2
a670 15
	for (j = i; buf[i]; i++) {
		if (' ' != buf[i])
			continue;

		/* Escaped whitespace. */
		if (i && ' ' == buf[i] && '\\' == buf[i - 1])
			continue;

		sv = buf[i];
		buf[i++] = '\0';

		if ( ! pstring(m, line, j, &buf[j], (size_t)(i - j)))
			return(0);

		/* Trailing whitespace?  Check at overwritten byte. */
d672 2
a673 1
		if (' ' == sv && '\0' == buf[i])
d677 2
a678 4
		for ( ; ' ' == buf[i]; i++)
			/* Skip trailing whitespace. */ ;

		j = i;
d680 2
a681 5
		/* Trailing whitespace? */

		if (' ' == buf[i - 1] && '\0' == buf[i])
			if ( ! mdoc_pwarn(m, line, i - 1, ETAILWS))
				return(0);
d683 1
a683 2
		if ('\0' == buf[i])
			break;
d686 2
a687 1
	if (j != i && ! pstring(m, line, j, &buf[j], (size_t)(i - j)))
a704 1

d709 1
a709 2
		return(mdoc_verr(m, ln, 0, 
				"unknown macro: %s%s", 
d723 3
a725 2
	int		  i, j, c;
	char		  mac[5];
d769 1
a769 1
	if (MDOC_MAX == (c = mdoc_hash_find(mac))) {
d780 4
a783 1
	/* Trailing whitespace? */
d793 1
a793 1
	if ( ! mdoc_macro(m, c, ln, 1, &i, buf)) 
@


1.44
log
@handle text lines beginning with \." as comments, like groff does,
even though this is not correct comment syntax (so warn, too)
reported by Claus Assmann on misc@@, fix by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.43 2010/05/04 23:13:54 schwarze Exp $ */
d150 2
a151 2
static	int		  parsetext(struct mdoc *, int, char *);
static	int		  parsemacro(struct mdoc *, int, char *);
d280 1
a280 1
 * the macro (parsemacro()) or text parser (parsetext()).
d289 2
a290 2
	return('.' == *buf ? parsemacro(m, ln, buf) :
			parsetext(m, ln, buf));
d629 1
a629 1
parsetext(struct mdoc *m, int line, char *buf)
d746 1
a746 1
parsemacro(struct mdoc *m, int ln, char *buf)
@


1.43
log
@end-of-sentence markers at the end of .Fn argument lists
ruin indentation of the next line in the SYNOPSIS section;
bug found by jacekm@@ in err(3)
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.42 2010/04/27 21:53:27 schwarze Exp $ */
d83 1
d633 5
@


1.42
log
@Fix a subtle bug noticed by naddy@@ in pftop(8), thanks!

When converting blank lines to .Pp outside literal context,
it could happen that the following node ended up as a child
of the .Pp element, but it must always be a sibling.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.41 2010/04/22 21:42:08 schwarze Exp $ */
d813 2
a814 1
	 * markers into reference blocks.
d821 3
a823 1
	if (MDOC_TEXT == n->type && m->last->parent->tok != MDOC_Rs) {
@


1.41
log
@Fix a segfault reported by nicm@@, introduced in rev. 1.38.
When finding a blank line, trying to parse it is a bad idea.
Instead, after adding .Pp to the AST, just return from parsetext().
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.40 2010/04/07 23:15:05 schwarze Exp $ */
d658 4
a661 1
		return(mdoc_elem_alloc(m, line, 0, MDOC_Pp, NULL));
@


1.40
log
@Merge the good parts of 1.9.23,
avoid the bad parts of 1.9.23, and keep local patches.

Input in general:
 * Basic handling of roff-style font escapes \f, \F.
 * Quoted punctuation does not count as punctuation.

mdoc(7) parser:
 * Make .Pf callable; noted by Claus Assmann.
 * Let .Bd and .Bl ignore unknown arguments; noted by deraadt@@.
 * Do not warn when .Er is used outside certain sections.
 * Replace mdoc_node_free[list] by mdoc_node_delete.
 * Replace #define by enum for rew*() return values.

man(7) parser:
 * When .TH is missing, use default section and date.

Output in general:
 * Curly braces do not count as punctuation.
 * No space after .Fl w/o args when a macro follows on the same line.

HTML output:
 * Unify PAIR_*_INIT macros, introduce new PAIR_ID_INIT().
 * Print whitespace after, not before .Vt .Fn .Ft .Fo.

Checked that all manuals in base still build.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.39 2010/04/04 20:14:35 schwarze Exp $ */
d658 1
a658 2
		if ( ! mdoc_elem_alloc(m, line, 0, MDOC_Pp, NULL))
			return(0);
@


1.39
log
@When the prologue lacks required information, do not error out,
but warn, set up some default values, and prod on.
Unbreaking the ports build for textproc/sgmlformat;
reported by naddy@@, thanks.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.38 2010/04/03 16:24:17 schwarze Exp $ */
d140 3
d179 1
a179 1
		mdoc_node_freelist(mdoc->first);
a563 2
	if (p->parent)
		p->parent->nchild--;
d572 36
d609 1
a609 1
mdoc_node_freelist(struct mdoc_node *p)
d612 5
a616 4
	if (p->child)
		mdoc_node_freelist(p->child);
	if (p->next)
		mdoc_node_freelist(p->next);
d618 1
a618 1
	assert(0 == p->nchild);
d652 6
@


1.38
log
@* outside literal context in mdoc(7), handle blank lines like .Pp
* a missing NAME section in mdoc(7) need not be fatal

ok deraadt@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.37 2010/04/02 12:39:47 schwarze Exp $ */
d25 1
d354 13
a366 2
			! (MDOC_PBODY & m->flags))
		return(mdoc_perr(m, ln, pp, EBODYPROL));
@


1.37
log
@merge 1.9.22, keeping local patches
* convert mdoc tokens from #define to enum
* fix a segfault with .Xo/.Xc in explicit blocks
* Thorn is \*(Th, not \*(TH; noticed by Joerg Sonnenberger
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.36 2010/03/25 02:02:28 schwarze Exp $ */
d599 6
a604 2
	if ('\0' == buf[i])
		return(mdoc_perr(m, line, 0, ENOBLANK));
@


1.36
log
@fix a stupid out-of-bounds read access introduced in the previous
revision, in the code searching for the end of a sentence
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.35 2010/03/02 00:38:59 schwarze Exp $ */
d142 1
a142 1
				int, enum mdoc_type);
d340 1
a340 1
mdoc_macro(struct mdoc *m, int tok, 
d343 2
d425 2
a426 2
node_alloc(struct mdoc *m, int line, 
		int pos, int tok, enum mdoc_type type)
d435 1
a435 2
	if (MDOC_TEXT != (p->type = type))
		assert(p->tok >= 0);
d442 1
a442 1
mdoc_tail_alloc(struct mdoc *m, int line, int pos, int tok)
d455 1
a455 1
mdoc_head_alloc(struct mdoc *m, int line, int pos, int tok)
d471 1
a471 1
mdoc_body_alloc(struct mdoc *m, int line, int pos, int tok)
d485 1
a485 1
		int tok, struct mdoc_arg *args)
d502 1
a502 1
		int tok, struct mdoc_arg *args)
@


1.35
log
@Proper inter-sentence spacing for mdoc(7).
When a text line or a non-block macro line in the source code ends
in any of ".!?", consider that an end of sentence (EOS).
This makes Jason's rule "new sentence, new line" even more important.
Let the parser detect the EOS and insert a token into the AST.
Let the -Tascii frontend render the EOS token as a double space before
the next word.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.34 2010/02/18 02:11:26 schwarze Exp $ */
d759 1
a759 1
		while (t && t[1])
@


1.34
log
@sync to release 1.9.15:
 * corrected .Vt handling (spotted by Joerg Sonnenberger)
 * corrected .Xr argument handling (based on my patch)
 * removed \\ escape sequence (because it is for low-level roff only)
 * warn about trailing whitespace (suggested by jmc@@)
 * -Txhtml support
 * and some general cleanup and doc improvements
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.33 2010/01/02 02:42:06 schwarze Exp $ */
d121 1
a121 1
	"%U"
d644 10
d681 2
d747 20
@


1.33
log
@complete the sync to 1.9.15-pre2: mostly minor fixes
 * bugfix: do not restore TERMP flags when leaving lists, just reset them
 * and a few HTML fixes
 * clarity: return width from a2width, not width+2, and adapt to it
 * manual: document .Bl and .Fl
 * portability: no need to escape '%' in macro names
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.32 2009/12/22 23:58:00 schwarze Exp $ */
d580 1
d597 2
a598 1
	if (0 == buf[i])
d614 3
a616 1
		buf[i++] = 0;
d620 6
d630 8
a637 1
		if (0 == buf[i])
d674 1
a674 1
	if (0 == buf[1])
d685 1
a685 1
		if (0 == buf[i])
d692 1
a692 1
		if (0 == (mac[j] = buf[i]))
d722 6
@


1.32
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.31 2009/10/27 21:40:07 schwarze Exp $ */
d96 1
a96 1
	"Xr",		"\%A",		"\%B",		"\%D",
d98 1
a98 1
	"\%I",		"\%J",		"\%N",		"\%O",
d100 1
a100 1
	"\%P",		"\%R",		"\%T",		"\%V",
d117 1
a117 1
	"Brc",		"\%C",		"Es",		"En",
d119 1
a119 1
	"Dx",		"\%Q",		"br",		"sp",
d121 1
a121 1
	"\%U"
a149 1

@


1.31
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.30 2009/10/21 19:13:50 schwarze Exp $ */
d27 1
a32 1
	"system: malloc error", /* EMALLOC */
d140 1
a140 1
static	int		  mdoc_alloc1(struct mdoc *);
d193 1
a193 1
static int
d197 1
a197 1
	bzero(&mdoc->meta, sizeof(struct mdoc_meta));
d200 1
a200 4
	mdoc->last = calloc(1, sizeof(struct mdoc_node));
	if (NULL == mdoc->last)
		return(0);

a203 1
	return(1);
d213 1
a213 1
int
d218 1
a218 1
	return(mdoc_alloc1(mdoc));
d243 2
a244 2
	if (NULL == (p = calloc(1, sizeof(struct mdoc))))
		return(NULL);
d246 1
a246 3
		(void)memcpy(&p->cb, cb, sizeof(struct mdoc_cb));

	mdoc_hash_init();
d251 3
a253 5
	if (mdoc_alloc1(p))
		return(p);

	free(p);
	return(NULL);
d429 1
a429 5
	if (NULL == (p = calloc(1, sizeof(struct mdoc_node)))) {
		(void)mdoc_nerr(m, m->last, EMALLOC);
		return(NULL);
	}

a446 2
	if (NULL == p)
		return(0);
a462 2
	if (NULL == p)
		return(0);
a475 2
	if (NULL == p)
		return(0);
a489 2
	if (NULL == p)
		return(0);
a506 2
	if (NULL == p)
		return(0);
d524 1
a524 9
	if (NULL == n)
		return(mdoc_nerr(m, m->last, EMALLOC));

	n->string = malloc(len + 1);
	if (NULL == n->string) {
		free(n);
		return(mdoc_nerr(m, m->last, EMALLOC));
	}

@


1.30
log
@sync to 1.9.9, featuring:
 * -Thtml output mode
 * roff scaling units
 * and some minor fixes
for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.29 2009/10/19 16:27:52 schwarze Exp $ */
d119 3
a121 1
	"Dx",		"\%Q",		"br",		"sp"
a660 1

@


1.29
log
@sync to 1.9.6: multiple improvements to references (.Rs)
 * validate and order .Rs child nodes
 * underline book title (.%B) and issuer (.%I)
 * enclose title of article (.%T) in quotes
 * avoid calling mdoc_verr directly, use a proper error code instead
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.28 2009/10/19 10:20:24 schwarze Exp $ */
d81 1
d131 1
a131 1
	"symbolic",		"nested"
@


1.28
log
@sync to 1.9.6: u_char lives in <sys/types.h>
noticed by uqs at spoerlein dot net on FreeBSD,
where <stdlib.h> does not include <sys/types.h>
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.27 2009/09/21 21:11:37 schwarze Exp $ */
d79 2
a80 1
	"no description found for library" /* ELIB */
@


1.27
log
@sync to 1.9.5: lookup hashes are now static tables
shortening the code, and, according to kristaps@@, speeding it up
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.26 2009/09/18 22:37:05 schwarze Exp $ */
d17 2
@


1.26
log
@sync to 1.9.2: non-printable characters in macro names are errors;
from joerg at netbsd dot org
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.25 2009/08/22 21:55:06 schwarze Exp $ */
a228 2
	if (mdoc->htab)
		mdoc_hash_free(mdoc->htab);
d246 2
d251 1
a251 4
	if (NULL == (p->htab = mdoc_hash_alloc())) {
		free(p);
		return(NULL);
	} else if (mdoc_alloc1(p))
d721 1
a721 1
	if (MDOC_MAX == (c = mdoc_hash_find(m->htab, mac))) {
@


1.25
log
@sync to 1.9.1: set mdoc_next flags in mdoc_*_alloc routines, where they belong
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.24 2009/08/22 19:43:33 schwarze Exp $ */
d708 6
@


1.24
log
@sync to 1.9.0: polishing the core code of mdoc macro handling
1) If a macro is not parsed, do not parse it.  Of course, without
parsing it, we cannot produce "macro-like parameter" warnings,
but these were useless anyway.
2) If a macro is not callable, do not print a useless warning when
it occurs as a parameter, just display the raw characters.
3) Below .Bl -column, check whether macros are callable.
4) Like groff, allow whitespace after the initial dot on macro lines.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.23 2009/08/22 17:21:24 schwarze Exp $ */
d458 4
a461 1
	return(node_append(m, p));
d476 4
a479 1
	return(node_append(m, p));
d491 4
a494 1
	return(node_append(m, p));
d510 4
a513 1
	return(node_append(m, p));
d529 4
a532 1
	return(node_append(m, p));
d557 4
a560 1
	return(node_append(m, n));
d617 2
a618 6
	if (MDOC_LITERAL & m->flags) {
		if ( ! mdoc_word_alloc(m, line, 0, buf))
			return(0);
		m->next = MDOC_NEXT_SIBLING;
		return(1);
	}
a642 1
		m->next = MDOC_NEXT_SIBLING;
d681 1
a681 1
	int		  i, j, c, ppos;
a700 2
	ppos = i;

d733 1
a733 1
	if ( ! mdoc_macro(m, c, ln, ppos, &i, buf)) 
@


1.23
log
@sync to 1.8.5: Error string is now file:line:col: message.
Fixed column reporting (off by one).
Use fprintf instead of warnx for parse errors (like cc).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.22 2009/07/26 22:48:41 schwarze Exp $ */
a31 1
	"macro not callable", /* ENOCALL */
a71 1
	"macro-like parameter", /* EMACPARM */
a76 1
	"invalid whitespace after control character", /* ESPACE */
d349 4
a352 1

a359 3
	if (1 != pp && ! (MDOC_CALLABLE & mdoc_macros[tok].flags))
		return(mdoc_perr(m, ln, pp, ENOCALL));

d668 1
a668 1
	int		  i, c;
d676 6
a681 2
	if (' ' == buf[1]) {
		i = 2;
a685 1
		return(mdoc_perr(m, ln, 1, ESPACE));
d688 2
d692 2
a693 2
	for (i = 1; i < 5; i++) {
		if (0 == (mac[i - 1] = buf[i]))
d699 1
a699 1
	mac[i - 1] = 0;
d701 1
a701 1
	if (i == 5 || i <= 2) {
d718 5
a722 3
	/* Begin recursive parse sequence. */

	if ( ! mdoc_macro(m, c, ln, 1, &i, buf)) 
d732 2
@


1.22
log
@sync to 1.8.1: rewrite quoted literal handling correctly,
rewrite TABSEP handling in a simpler way,
and retire ECOLEMPTY, ARGS_QUOTED and ARGS_ARGVLIKE
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.21 2009/07/26 02:17:29 schwarze Exp $ */
d656 1
a656 1
		return(mdoc_verr(m, ln, 1, 
d659 1
a659 1
	return(mdoc_vwarn(m, ln, 1, "unknown macro: %s%s",
@


1.21
log
@sync to 1.8.1: removed excessively verbose EARGVPARM warning
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.20 2009/07/26 01:59:46 schwarze Exp $ */
a27 1
	"empty last list column", /* ECOLEMPTY */
@


1.20
log
@sync to 1.8.1: support .br and .sp
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.19 2009/07/26 00:11:15 schwarze Exp $ */
a28 1
	"argument-like parameter", /* EARGVPARM */
@


1.19
log
@sync to 1.8.1: libmdoc now breaks up free-form lines into tokens;
will simplify LITERAL mode in front-end
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.18 2009/07/18 19:44:38 schwarze Exp $ */
d120 1
a120 1
	"Dx",		"\%Q"
@


1.18
log
@sync to 1.8.0: move mdoc_a2att, mdoc_a2st, and mdoc_a2lib to libmdoc
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.17 2009/07/12 22:35:08 schwarze Exp $ */
d147 2
d434 1
a434 1
node_alloc(struct mdoc *mdoc, int line, 
d440 1
a440 1
		(void)mdoc_nerr(mdoc, mdoc->last, EMALLOC);
d444 1
a444 1
	p->sec = mdoc->lastsec;
d456 1
a456 1
mdoc_tail_alloc(struct mdoc *mdoc, int line, int pos, int tok)
d460 1
a460 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_TAIL);
d463 1
a463 1
	return(node_append(mdoc, p));
d468 1
a468 1
mdoc_head_alloc(struct mdoc *mdoc, int line, int pos, int tok)
d472 2
a473 2
	assert(mdoc->first);
	assert(mdoc->last);
d475 1
a475 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_HEAD);
d478 1
a478 1
	return(node_append(mdoc, p));
d483 1
a483 1
mdoc_body_alloc(struct mdoc *mdoc, int line, int pos, int tok)
d487 1
a487 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_BODY);
d490 1
a490 1
	return(node_append(mdoc, p));
d495 1
a495 1
mdoc_block_alloc(struct mdoc *mdoc, int line, int pos, 
d500 1
a500 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_BLOCK);
d506 1
a506 1
	return(node_append(mdoc, p));
d511 1
a511 1
mdoc_elem_alloc(struct mdoc *mdoc, int line, int pos, 
d516 1
a516 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_ELEM);
d522 1
a522 1
	return(node_append(mdoc, p));
d526 2
a527 3
int
mdoc_word_alloc(struct mdoc *mdoc, 
		int line, int pos, const char *word)
d529 2
a530 1
	struct mdoc_node *p;
d532 8
a539 6
	p = node_alloc(mdoc, line, pos, -1, MDOC_TEXT);
	if (NULL == p)
		return(0);
	if (NULL == (p->string = strdup(word))) {
		(void)mdoc_nerr(mdoc, mdoc->last, EMALLOC);
		return(0);
d542 14
a555 1
	return(node_append(mdoc, p));
d594 1
d598 5
d604 12
a615 1
	if (0 == buf[0] && ! (MDOC_LITERAL & m->flags))
d618 27
a644 1
	if ( ! mdoc_word_alloc(m, line, 0, buf))
d650 2
@


1.17
log
@sync to 1.7.23: pass warning code to mdoc_pwarn() instead of warning message
define additional warning macro mdoc_nwarn()
remove obsolete warning functions mdoc_warn(), pwarn(), vwarn(), nwarn()
remove various now unused "enum mdoc_warn" and "enum mwarn"
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.16 2009/07/12 21:45:44 schwarze Exp $ */
d82 1
@


1.16
log
@sync to 1.7.23: pass error code to mdoc_perr() instead of error string
and use the so improved mdoc_nerr() at many places;
get rid of now unused static functions perr()
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.15 2009/07/12 21:08:29 schwarze Exp $ */
d327 1
a332 18
mdoc_warn(struct mdoc *mdoc, enum mdoc_warn type, 
		const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_warn)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_warn)(mdoc->data, mdoc->last->line,
				mdoc->last->pos, buf));
}


int
a345 16

int
mdoc_pwarn(struct mdoc *mdoc, int line, int pos, enum mdoc_warn type,
		const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_warn)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_warn)(mdoc->data, line, pos, buf));
}
@


1.15
log
@sync to 1.7.23: pass error code to mdoc_nerr() instead of error string
and use the so improved mdoc_nerr() at many places
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.14 2009/07/12 20:30:27 schwarze Exp $ */
d146 1
a146 1
static	int		  perr(struct mdoc *, int, int, enum merr);
d359 1
a380 16
mdoc_perr(struct mdoc *mdoc, int line, int pos, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_err)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_err)(mdoc->data, line, pos, buf));
}


int
d387 1
a387 1
		return(perr(m, ln, pp, EPROLBODY));
d390 1
a390 1
		return(perr(m, ln, pp, EBODYPROL));
d393 1
a393 1
		return(perr(m, ln, pp, ENOCALL));
a399 34
perr(struct mdoc *m, int line, int pos, enum merr type)
{
	char		*p;

	p = NULL;
	switch (type) {
	case (ENOCALL):
		p = "not callable";
		break;
	case (EPROLBODY):
		p = "macro disallowed in document body";
		break;
	case (EBODYPROL):
		p = "macro disallowed in document prologue";
		break;
	case (EMALLOC):
		p = "memory exhausted";
		break;
	case (ETEXTPROL):
		p = "text disallowed in document prologue";
		break;
	case (ENOBLANK):
		p = "blank lines disallowed in non-literal contexts";
		break;
	case (ESPACE):
		p = "whitespace disallowed after delimiter";
		break;
	}
	assert(p);
	return(mdoc_perr(m, line, pos, p));
}


static int
d611 1
a611 1
		return(perr(m, line, 0, ETEXTPROL));
d614 1
a614 1
		return(perr(m, line, 0, ENOBLANK));
d657 1
a657 1
		return(perr(m, ln, 1, ESPACE));
@


1.14
log
@sync to 1.7.23: unify the various "enum merr" into libman.h and libmdoc.h,
use it as a new argument to mdoc_err(), the same way as for for man_err(),
and use string tables instead of switch statements to select error messages
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.13 2009/07/12 19:05:52 schwarze Exp $ */
a331 18
mdoc_nerr(struct mdoc *mdoc, const struct mdoc_node *node, 
		const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_err)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_err)(mdoc->data, 
				node->line, node->pos, buf));
}


int
d519 1
a519 2
		(void)perr(mdoc, (mdoc)->last->line, 
				(mdoc)->last->pos, EMALLOC);
d615 1
a615 2
		(void)perr(mdoc, (mdoc)->last->line, 
				(mdoc)->last->pos, EMALLOC);
d618 1
@


1.13
log
@sync to 1.7.23: third step to get rid of enum mdoc_warn:
mdoc_verr is not using enum mdoc_warn, so use it at a few more places
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.12 2009/07/12 18:35:57 schwarze Exp $ */
d26 56
a81 8
enum	merr {
	ENOCALL,
	EBODYPROL,
	EPROLBODY,
	ESPACE,
	ETEXTPROL,
	ENOBLANK,
	EMALLOC
d368 1
a368 1
mdoc_err(struct mdoc *mdoc, const char *fmt, ...)
d370 1
a370 2
	char		 buf[256];
	va_list		 ap;
d372 2
a373 2
	if (NULL == mdoc->cb.mdoc_err)
		return(0);
d375 3
a377 5
	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_err)(mdoc->data, mdoc->last->line,
				mdoc->last->pos, buf));
@


1.12
log
@sync to 1.7.23: second step to get rid of enum mdoc_warn:
remove type from mdoc_vwarn arguments, and use this function where apropriate
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.11 2009/07/12 18:28:29 schwarze Exp $ */
d651 1
a651 1
		return(mdoc_perr(m, ln, 1, 
@


1.11
log
@sync to 1.7.23: first step to get rid of enum mdoc_warn:
unify manwarn() and mdocwarn() into mwarn()
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.10 2009/06/23 23:02:54 schwarze Exp $ */
d262 1
d268 1
a268 2
mdoc_vwarn(struct mdoc *mdoc, int ln, int pos, 
		enum mdoc_warn type, const char *fmt, ...)
d654 1
a654 2
	return(mdoc_pwarn(m, ln, 1, WARN_SYNTAX,
				"unknown macro: %s%s",
@


1.10
log
@sync to 1.7.20: like for the -man case, add an nchild counter to the -mdoc
nodes, simplifying the validation code; no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.9 2009/06/19 07:20:19 schwarze Exp $ */
d279 1
a279 1
	return((*mdoc->cb.mdoc_warn)(mdoc->data, ln, pos, type, buf));
d315 1
a315 1
				mdoc->last->pos, type, buf));
d349 1
a349 2
	return((*mdoc->cb.mdoc_warn)(mdoc->data, 
				line, pos, type, buf));
@


1.9
log
@sync to 1.7.19: more elegant section handling
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.8 2009/06/18 23:51:12 schwarze Exp $ */
d445 2
d602 2
d621 1
@


1.8
log
@sync to 1.7.19: comment cleanup; no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.7 2009/06/18 23:34:53 schwarze Exp $ */
d147 1
a147 1
	mdoc->lastnamed = mdoc->lastsec = 0;
a373 2
	/* FIXME - these should happen during validation. */

d375 1
a375 1
			SEC_PROLOGUE != m->lastnamed)
a376 1

d378 1
a378 1
			SEC_PROLOGUE == m->lastnamed)
d629 1
a629 1
	if (SEC_PROLOGUE == m->lastnamed)
@


1.7
log
@sync to 1.7.19: improved comment handling
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.6 2009/06/18 22:16:56 schwarze Exp $ */
a99 5
#define verr(m, t) perr((m), (m)->last->line, (m)->last->pos, (t))

/*
 * Get the first (root) node of the parse tree.
 */
d116 3
d138 3
d160 4
a163 3
 * Free up all resources contributed by a parse:  the node tree,
 * meta-data and so on.  Then reallocate the root node for another
 * parse.
d175 2
a176 1
 * Completely free up all resources.
d189 3
d218 1
a218 1
 * through to macro_end in macro.c.
d235 1
a235 1
 * the macro or text parser.
a240 2
	/* If in error-mode, then we parse no more. */

d284 2
a285 1
mdoc_nerr(struct mdoc *mdoc, const struct mdoc_node *node, const char *fmt, ...)
d296 2
a297 1
	return((*mdoc->cb.mdoc_err)(mdoc->data, node->line, node->pos, buf));
d302 2
a303 1
mdoc_warn(struct mdoc *mdoc, enum mdoc_warn type, const char *fmt, ...)
d315 1
a315 1
	    mdoc->last->pos, type, buf));
d332 1
a332 1
	    mdoc->last->pos, buf));
d349 2
a350 1
	return((*mdoc->cb.mdoc_warn)(mdoc->data, line, pos, type, buf));
d494 2
a495 1
		(void)verr(mdoc, EMALLOC);
d591 2
a592 1
		(void)verr(mdoc, EMALLOC);
a656 1

@


1.6
log
@complete sync to 1.7.17: garbage collect unused functions
mdoc_msg, mdoc_pmsg, mdoc_vmsg, and mdoc_nwarn
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.5 2009/06/15 18:41:13 schwarze Exp $ */
d37 1
a37 1
	"\\\"",		"Dd",		"Dt",		"Os",
d66 2
a67 2
	"Fr",		"Ud",		"Lb",		"Ap",
	"Lp",		"Lk",		"Mt",		"Brq",
d69 1
a69 1
	"Bro",		"Brc",		"\%C",		"Es",
d71 1
a71 1
	"En",		"Dx",		"\%Q"
d660 1
a660 1
	/* Comments and empties are quickly ignored. */
a672 4

	if (buf[1] && '\\' == buf[1])
		if (buf[2] && '\"' == buf[2])
			return(1);
@


1.5
log
@bring back miod@@'s "real functions" patch (rev. 1.2)
which was erroneously backed out in rev. 1.4, sorry;
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.4 2009/06/15 02:19:32 schwarze Exp $ */
a244 16
void
mdoc_vmsg(struct mdoc *mdoc, int ln, int pos, const char *fmt, ...)
{
	char		  buf[256];
	va_list		  ap;

	if (NULL == mdoc->cb.mdoc_msg)
		return;

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	(*mdoc->cb.mdoc_msg)(mdoc->data, ln, pos, buf);
}


a279 17
mdoc_nwarn(struct mdoc *mdoc, const struct mdoc_node *node, enum mdoc_warn type,
		const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_warn)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_warn)(mdoc->data, node->line, node->pos, type,
	    buf));
}

int
a325 33
}


void
mdoc_msg(struct mdoc *mdoc, const char *fmt, ...)
{
	char		  buf[256];
	va_list		  ap;

	if (NULL == mdoc->cb.mdoc_msg)
		return;

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	(*mdoc->cb.mdoc_msg)(mdoc->data, mdoc->last->line, mdoc->last->pos,
	    buf);
}


void
mdoc_pmsg(struct mdoc *mdoc, int line, int pos, const char *fmt, ...)
{
	char		  buf[256];
	va_list		  ap;

	if (NULL == mdoc->cb.mdoc_msg)
		return;

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	(*mdoc->cb.mdoc_msg)(mdoc->data, line, pos, buf);
@


1.4
log
@sync to 1.7.16:
reduce code duplication in warning and error reporting functions
while here, garbage collect three unused function prototypes
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.3 2009/06/14 23:00:57 schwarze Exp $ */
d292 132
@


1.3
log
@sync to 1.7.16: comments, whitespace and spelling fixes; no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.77 2009/06/12 12:52:51 kristaps Exp $ */
d262 2
a263 1
mdoc_verr(struct mdoc *mdoc, int ln, int pos, const char *fmt, ...)
a295 132
mdoc_nwarn(struct mdoc *mdoc, const struct mdoc_node *node, enum mdoc_warn type,
		const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_warn)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_warn)(mdoc->data, node->line, node->pos, type,
	    buf));
}

int
mdoc_nerr(struct mdoc *mdoc, const struct mdoc_node *node, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_err)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_err)(mdoc->data, node->line, node->pos, buf));
}


int
mdoc_warn(struct mdoc *mdoc, enum mdoc_warn type, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_warn)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_warn)(mdoc->data, mdoc->last->line,
	    mdoc->last->pos, type, buf));
}


int
mdoc_err(struct mdoc *mdoc, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_err)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_err)(mdoc->data, mdoc->last->line,
	    mdoc->last->pos, buf));
}


void
mdoc_msg(struct mdoc *mdoc, const char *fmt, ...)
{
	char		  buf[256];
	va_list		  ap;

	if (NULL == mdoc->cb.mdoc_msg)
		return;

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	(*mdoc->cb.mdoc_msg)(mdoc->data, mdoc->last->line, mdoc->last->pos,
	    buf);
}


void
mdoc_pmsg(struct mdoc *mdoc, int line, int pos, const char *fmt, ...)
{
	char		  buf[256];
	va_list		  ap;

	if (NULL == mdoc->cb.mdoc_msg)
		return;

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	(*mdoc->cb.mdoc_msg)(mdoc->data, line, pos, buf);
}


int
mdoc_pwarn(struct mdoc *mdoc, int line, int pos, enum mdoc_warn type,
		const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_warn)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_warn)(mdoc->data, line, pos, type, buf));
}

int
mdoc_perr(struct mdoc *mdoc, int line, int pos, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_err)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_err)(mdoc->data, line, pos, buf));
}


int
d483 2
a484 1
	if ((p->args = args))
d499 2
a500 1
	if ((p->args = args))
@


1.2
log
@Replace variadic macros with real functions, so that this compiles on
platforms still using gcc 2.
ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.1 2009/04/06 20:30:40 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@


1.1
log
@Initial check-in of mandoc for formatting manuals. ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.74 2009/04/02 06:51:44 kristaps Exp $ */
d264 1
a264 2
mdoc_verr(struct mdoc *mdoc, int ln, int pos, 
		const char *fmt, ...)
d293 132
@

