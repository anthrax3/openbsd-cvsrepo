head	1.30;
access;
symbols
	OPENBSD_6_1:1.28.0.8
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.11.0.10
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.6
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7;
locks; strict;
comment	@ * @;


1.30
date	2017.06.13.16.11.58;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	m7Kku6bvc8vybOTH;

1.29
date	2017.06.08.18.11.15;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	iJqHiCg2x8ufqICJ;

1.28
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	Ql2ha5NS80pwfGNT;

1.27
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	hxQV8O1pNUaef4ir;

1.26
date	2015.04.29.12.44.10;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	52f6jH6PnIvcvJbY;

1.25
date	2015.02.10.11.02.19;	author schwarze;	state Exp;
branches;
next	1.24;
commitid	hGY7n6Yi9hW0eo23;

1.24
date	2015.01.30.04.08.37;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	KL58yWbJhw6UbgSB;

1.23
date	2015.01.30.02.08.37;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	vvSu12hfLARx94BX;

1.22
date	2015.01.30.00.27.09;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	RtPDxdA3HpjlkQCb;

1.21
date	2015.01.28.15.02.25;	author schwarze;	state Exp;
branches;
next	1.20;
commitid	Um2gz4HrZv1IOy6F;

1.20
date	2015.01.27.05.20.30;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	x93gRIdSgdjntkaE;

1.19
date	2015.01.26.18.41.45;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	mmVgjPEivVGaZY4u;

1.18
date	2015.01.14.22.44.51;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	7qvZiyLLUmJiYfWk;

1.17
date	2014.11.25.05.39.00;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	TkqmtcWs1yXom01B;

1.16
date	2014.10.14.02.16.02;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	CvxMGBcRTJn11Q3v;

1.15
date	2014.10.07.14.06.14;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	4TXkcp1JD6jt9J0h;

1.14
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2014.03.28.23.25.54;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2012.05.26.20.03.34;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.16.01.11.50;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.09.14.30.48;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.01.04.23.44.20;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.15.22.50.28;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.15.21.33.47;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.15.19.20.03;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.30
log
@If the layout is empty except for requesting a left vertical frame,
record that detail in struct tbl_opts, such that term_tbl() can do
correct column calculations and doesn't prematurely break lines.
Fixes the tbl/layout/empty regression test that got broken when
line breaking in text block cells was implemented.
@
text
@/*	$OpenBSD: tbl_layout.c,v 1.29 2017/06/08 18:11:15 schwarze Exp $ */
/*
 * Copyright (c) 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2012, 2014, 2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mandoc.h"
#include "mandoc_aux.h"
#include "libmandoc.h"
#include "libroff.h"

struct	tbl_phrase {
	char		 name;
	enum tbl_cellt	 key;
};

static	const struct tbl_phrase keys[] = {
	{ 'c',		 TBL_CELL_CENTRE },
	{ 'r',		 TBL_CELL_RIGHT },
	{ 'l',		 TBL_CELL_LEFT },
	{ 'n',		 TBL_CELL_NUMBER },
	{ 's',		 TBL_CELL_SPAN },
	{ 'a',		 TBL_CELL_LONG },
	{ '^',		 TBL_CELL_DOWN },
	{ '-',		 TBL_CELL_HORIZ },
	{ '_',		 TBL_CELL_HORIZ },
	{ '=',		 TBL_CELL_DHORIZ }
};

#define KEYS_MAX ((int)(sizeof(keys)/sizeof(keys[0])))

static	void		 mods(struct tbl_node *, struct tbl_cell *,
				int, const char *, int *);
static	void		 cell(struct tbl_node *, struct tbl_row *,
				int, const char *, int *);
static	struct tbl_cell *cell_alloc(struct tbl_node *, struct tbl_row *,
				enum tbl_cellt);


static void
mods(struct tbl_node *tbl, struct tbl_cell *cp,
		int ln, const char *p, int *pos)
{
	char		*endptr;
	size_t		 sz;

mod:
	while (p[*pos] == ' ' || p[*pos] == '\t')
		(*pos)++;

	/* Row delimiters and cell specifiers end modifier lists. */

	if (strchr(".,-=^_ACLNRSaclnrs", p[*pos]) != NULL)
		return;

	/* Throw away parenthesised expression. */

	if ('(' == p[*pos]) {
		(*pos)++;
		while (p[*pos] && ')' != p[*pos])
			(*pos)++;
		if (')' == p[*pos]) {
			(*pos)++;
			goto mod;
		}
		mandoc_msg(MANDOCERR_TBLLAYOUT_PAR, tbl->parse,
		    ln, *pos, NULL);
		return;
	}

	/* Parse numerical spacing from modifier string. */

	if (isdigit((unsigned char)p[*pos])) {
		cp->spacing = strtoull(p + *pos, &endptr, 10);
		*pos = endptr - p;
		goto mod;
	}

	switch (tolower((unsigned char)p[(*pos)++])) {
	case 'b':
		cp->flags |= TBL_CELL_BOLD;
		goto mod;
	case 'd':
		cp->flags |= TBL_CELL_BALIGN;
		goto mod;
	case 'e':
		cp->flags |= TBL_CELL_EQUAL;
		goto mod;
	case 'f':
		break;
	case 'i':
		cp->flags |= TBL_CELL_ITALIC;
		goto mod;
	case 'm':
		mandoc_msg(MANDOCERR_TBLLAYOUT_MOD, tbl->parse,
		    ln, *pos, "m");
		goto mod;
	case 'p':
	case 'v':
		if (p[*pos] == '-' || p[*pos] == '+')
			(*pos)++;
		while (isdigit((unsigned char)p[*pos]))
			(*pos)++;
		goto mod;
	case 't':
		cp->flags |= TBL_CELL_TALIGN;
		goto mod;
	case 'u':
		cp->flags |= TBL_CELL_UP;
		goto mod;
	case 'w':
		sz = 0;
		if (p[*pos] == '(') {
			(*pos)++;
			while (p[*pos + sz] != '\0' && p[*pos + sz] != ')')
				sz++;
		} else
			while (isdigit((unsigned char)p[*pos + sz]))
				sz++;
		if (sz) {
			free(cp->wstr);
			cp->wstr = mandoc_strndup(p + *pos, sz);
			*pos += sz;
			if (p[*pos] == ')')
				(*pos)++;
		}
		goto mod;
	case 'x':
		cp->flags |= TBL_CELL_WMAX;
		goto mod;
	case 'z':
		cp->flags |= TBL_CELL_WIGN;
		goto mod;
	case '|':
		if (cp->vert < 2)
			cp->vert++;
		else
			mandoc_msg(MANDOCERR_TBLLAYOUT_VERT,
			    tbl->parse, ln, *pos - 1, NULL);
		goto mod;
	default:
		mandoc_vmsg(MANDOCERR_TBLLAYOUT_CHAR, tbl->parse,
		    ln, *pos - 1, "%c", p[*pos - 1]);
		goto mod;
	}

	/* Ignore parenthised font names for now. */

	if (p[*pos] == '(')
		goto mod;

	/* Support only one-character font-names for now. */

	if (p[*pos] == '\0' || (p[*pos + 1] != ' ' && p[*pos + 1] != '.')) {
		mandoc_vmsg(MANDOCERR_FT_BAD, tbl->parse,
		    ln, *pos, "TS %s", p + *pos - 1);
		if (p[*pos] != '\0')
			(*pos)++;
		if (p[*pos] != '\0')
			(*pos)++;
		goto mod;
	}

	switch (p[(*pos)++]) {
	case '3':
	case 'B':
		cp->flags |= TBL_CELL_BOLD;
		goto mod;
	case '2':
	case 'I':
		cp->flags |= TBL_CELL_ITALIC;
		goto mod;
	case '1':
	case 'R':
		goto mod;
	default:
		mandoc_vmsg(MANDOCERR_FT_BAD, tbl->parse,
		    ln, *pos - 1, "TS f%c", p[*pos - 1]);
		goto mod;
	}
}

static void
cell(struct tbl_node *tbl, struct tbl_row *rp,
		int ln, const char *p, int *pos)
{
	int		 i;
	enum tbl_cellt	 c;

	/* Handle leading vertical lines */

	while (p[*pos] == ' ' || p[*pos] == '\t' || p[*pos] == '|') {
		if (p[*pos] == '|') {
			if (rp->vert < 2)
				rp->vert++;
			else
				mandoc_msg(MANDOCERR_TBLLAYOUT_VERT,
				    tbl->parse, ln, *pos, NULL);
		}
		(*pos)++;
	}

again:
	while (p[*pos] == ' ' || p[*pos] == '\t')
		(*pos)++;

	if (p[*pos] == '.' || p[*pos] == '\0')
		return;

	/* Parse the column position (`c', `l', `r', ...). */

	for (i = 0; i < KEYS_MAX; i++)
		if (tolower((unsigned char)p[*pos]) == keys[i].name)
			break;

	if (i == KEYS_MAX) {
		mandoc_vmsg(MANDOCERR_TBLLAYOUT_CHAR, tbl->parse,
		    ln, *pos, "%c", p[*pos]);
		(*pos)++;
		goto again;
	}
	c = keys[i].key;

	/* Special cases of spanners. */

	if (c == TBL_CELL_SPAN) {
		if (rp->last == NULL)
			mandoc_msg(MANDOCERR_TBLLAYOUT_SPAN,
			    tbl->parse, ln, *pos, NULL);
		else if (rp->last->pos == TBL_CELL_HORIZ ||
		    rp->last->pos == TBL_CELL_DHORIZ)
			c = rp->last->pos;
	} else if (c == TBL_CELL_DOWN && rp == tbl->first_row)
		mandoc_msg(MANDOCERR_TBLLAYOUT_DOWN,
		    tbl->parse, ln, *pos, NULL);

	(*pos)++;

	/* Allocate cell then parse its modifiers. */

	mods(tbl, cell_alloc(tbl, rp, c), ln, p, pos);
}

void
tbl_layout(struct tbl_node *tbl, int ln, const char *p, int pos)
{
	struct tbl_row	*rp;

	rp = NULL;
	for (;;) {
		/* Skip whitespace before and after each cell. */

		while (p[pos] == ' ' || p[pos] == '\t')
			pos++;

		switch (p[pos]) {
		case ',':  /* Next row on this input line. */
			pos++;
			rp = NULL;
			continue;
		case '\0':  /* Next row on next input line. */
			return;
		case '.':  /* End of layout. */
			pos++;
			tbl->part = TBL_PART_DATA;

			/*
			 * When the layout is completely empty,
			 * default to one left-justified column.
			 */

			if (tbl->first_row == NULL) {
				tbl->first_row = tbl->last_row =
				    mandoc_calloc(1, sizeof(*rp));
			}
			if (tbl->first_row->first == NULL) {
				mandoc_msg(MANDOCERR_TBLLAYOUT_NONE,
				    tbl->parse, ln, pos, NULL);
				cell_alloc(tbl, tbl->first_row,
				    TBL_CELL_LEFT);
				if (tbl->opts.lvert < tbl->first_row->vert)
					tbl->opts.lvert = tbl->first_row->vert;
				return;
			}

			/*
			 * Search for the widest line
			 * along the left and right margins.
			 */

			for (rp = tbl->first_row; rp; rp = rp->next) {
				if (tbl->opts.lvert < rp->vert)
					tbl->opts.lvert = rp->vert;
				if (rp->last != NULL &&
				    rp->last->col + 1 == tbl->opts.cols &&
				    tbl->opts.rvert < rp->last->vert)
					tbl->opts.rvert = rp->last->vert;

				/* If the last line is empty, drop it. */

				if (rp->next != NULL &&
				    rp->next->first == NULL) {
					free(rp->next);
					rp->next = NULL;
					tbl->last_row = rp;
				}
			}
			return;
		default:  /* Cell. */
			break;
		}

		/*
		 * If the last line had at least one cell,
		 * start a new one; otherwise, continue it.
		 */

		if (rp == NULL) {
			if (tbl->last_row == NULL ||
			    tbl->last_row->first != NULL) {
				rp = mandoc_calloc(1, sizeof(*rp));
				if (tbl->last_row)
					tbl->last_row->next = rp;
				else
					tbl->first_row = rp;
				tbl->last_row = rp;
			} else
				rp = tbl->last_row;
		}
		cell(tbl, rp, ln, p, &pos);
	}
}

static struct tbl_cell *
cell_alloc(struct tbl_node *tbl, struct tbl_row *rp, enum tbl_cellt pos)
{
	struct tbl_cell	*p, *pp;

	p = mandoc_calloc(1, sizeof(*p));
	p->pos = pos;

	if ((pp = rp->last) != NULL) {
		pp->next = p;
		p->col = pp->col + 1;
	} else
		rp->first = p;
	rp->last = p;

	if (tbl->opts.cols <= p->col)
		tbl->opts.cols = p->col + 1;

	return p;
}
@


1.29
log
@Implement w layout specifier (minimum column width).
Improve width calculation of text blocks.
Reduces the groff/mandoc diff in Base+Xenocara by about 800 lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_layout.c,v 1.28 2015/10/12 00:07:27 schwarze Exp $ */
d299 2
@


1.28
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_layout.c,v 1.27 2015/10/06 18:30:44 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2012, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
d63 1
d129 16
a144 1
	case 'w':  /* XXX for now, ignore minimal column width */
@


1.27
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_layout.c,v 1.26 2015/04/29 12:44:10 schwarze Exp $ */
a115 1
		/* FALLTHROUGH */
a167 1
		/* FALLTHROUGH */
a171 1
		/* FALLTHROUGH */
a175 1
		/* FALLTHROUGH */
@


1.26
log
@When the last line of a table layout turns out to be empty, it is deleted.
Do not just free the struct tbl_row but also make sure that no pointer
to it remains.  Fixing a use after free found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_layout.c,v 1.25 2015/02/10 11:02:19 schwarze Exp $ */
d356 1
a356 1
	return(p);
@


1.25
log
@Do not read past the end of the buffer if an "f" layout font modifier
is followed by the end of the input line instead of a font specifier.
Found by jsg@@ with afl, test case #591.

While here, improve functionality as well:
* There is no "r" font modifier.
* Font specifiers (as opposed to font modifiers) are case sensitive.
* One-character font specifiers require trailing whitespace.
* Ignore parenthised and two-letter font specifiers.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_layout.c,v 1.24 2015/01/30 04:08:37 schwarze Exp $ */
d309 1
@


1.24
log
@Abolish struct tbl_head and replace it by an "int col" member in
struct tbl_cell.  No functional change, minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_layout.c,v 1.23 2015/01/30 02:08:37 schwarze Exp $ */
d98 2
a99 6
		/* FALLTHROUGH */
	case 'i':
		/* FALLTHROUGH */
	case 'r':
		(*pos)--;
		break;
d108 3
d150 18
a167 1
	switch (tolower((unsigned char)p[(*pos)++])) {
d170 1
a170 1
	case 'b':
d175 1
a175 1
	case 'i':
d180 1
a180 1
	case 'r':
@


1.23
log
@Auditing the tbl(7) code for more NULL pointer accesses, i came out
empty-handed; so this is just KNF and some code simplifications,
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_layout.c,v 1.22 2015/01/30 00:27:09 schwarze Exp $ */
d283 1
a283 1
				    rp->last->head == tbl->last_head &&
a324 1
	struct tbl_head	*h, *hp;
d327 1
d331 2
a332 2
		h = pp->head->next;
	} else {
a333 2
		h = tbl->first_head;
	}
d336 2
a337 18
	p->pos = pos;

	/* Re-use header. */

	if (h != NULL) {
		p->head = h;
		return(p);
	}

	hp = mandoc_calloc(1, sizeof(*hp));
	hp->ident = tbl->opts.cols++;

	if (tbl->last_head != NULL) {
		hp->prev = tbl->last_head;
		tbl->last_head->next = hp;
	} else
		tbl->first_head = hp;
	tbl->last_head = hp;
a338 1
	p->head = hp;
@


1.22
log
@Make sure every layout line contains at least one cell;
fixing a NULL pointer access in term_tbl() that jsg@@ found with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_layout.c,v 1.21 2015/01/28 15:02:25 schwarze Exp $ */
d327 1
a327 1
	p = mandoc_calloc(1, sizeof(struct tbl_cell));
d329 1
a329 1
	if (NULL != (pp = rp->last)) {
d342 1
a342 1
	if (h) {
d347 1
a347 1
	hp = mandoc_calloc(1, sizeof(struct tbl_head));
d350 1
a350 1
	if (tbl->last_head) {
@


1.21
log
@For now, it can't be helped that mandoc tbl(7) ignores high-level macros,
but stop throwing away their arguments.  This fixes information loss in a
handful of Xenocara manuals, at the price of a small amount of formatting
noise creeping through.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_layout.c,v 1.20 2015/01/27 05:20:30 schwarze Exp $ */
d263 4
d269 2
a270 3
				rp = mandoc_calloc(1, sizeof(*rp));
				cell_alloc(tbl, rp, TBL_CELL_LEFT);
				tbl->first_row = tbl->last_row = rp;
d286 8
d300 16
a315 7
		if (rp == NULL) {  /* First cell on this line. */
			rp = mandoc_calloc(1, sizeof(*rp));
			if (tbl->last_row)
				tbl->last_row->next = rp;
			else
				tbl->first_row = rp;
			tbl->last_row = rp;
@


1.20
log
@Multiple parser and formatter fixes for line drawing in tbl(7).
* Allow mixing vertical line bars with the layout options
of the preceding layout cell.
* Correctly combine box options with layout lines.
* Correctly print vertical lines in data rows, with the right spacing.
* Correctly print cross markers and left and right ends of
horizontal lines even if vertical lines differ above and below.
* Avoid the bogus error message "no table data cells"
when a table data section starts with a horizontal line.
No increase in code size.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_layout.c,v 1.19 2015/01/26 18:41:45 schwarze Exp $ */
d235 1
a235 1
tbl_layout(struct tbl_node *tbl, int ln, const char *p)
a237 1
	int		 pos;
a238 1
	pos = 0;
a239 1

@


1.19
log
@Rework tbl(7) layout parsing:
* Continue parsing even if part of the input is invalid.
* Do not require whitespace between cell specifications.
* Allow tabs as well as blanks between modifiers.
* Mark the 'm' modifier as unsupported.
* Parse and ignore the 'p' and 'v' modifiers.
* Better warning and error messages.
* Get rid of a static buffer.
Improved functionality but minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_layout.c,v 1.18 2015/01/14 22:44:51 schwarze Exp $ */
d55 1
a55 1
				enum tbl_cellt, int vert);
d70 1
a70 1
	if (strchr(".,-=^_ACLNRSaclnrs|", p[*pos]) != NULL)
d138 7
d177 1
a177 1
	int		 vert, i;
d180 1
a180 1
	/* Handle vertical lines. */
a181 2
	vert = 0;
again:
d184 2
a185 2
			if (vert < 2)
				vert++;
d193 3
a195 1
	/* Handle trailing vertical lines */
d197 1
a197 2
	if ('.' == p[*pos] || '\0' == p[*pos]) {
		rp->vert = vert;
a198 1
	}
d231 1
a231 1
	mods(tbl, cell_alloc(tbl, rp, c, vert), ln, p, pos);
d259 12
a270 1
			if (tbl->first_row != NULL)
d272 15
a286 5
			mandoc_msg(MANDOCERR_TBLLAYOUT_NONE,
			    tbl->parse, ln, pos, NULL);
			rp = mandoc_calloc(1, sizeof(*rp));
			cell_alloc(tbl, rp, TBL_CELL_LEFT, 0);
			tbl->first_row = tbl->last_row = rp;
d305 1
a305 2
cell_alloc(struct tbl_node *tbl, struct tbl_row *rp, enum tbl_cellt pos,
		int vert)
a321 1
	p->vert = vert;
a331 1
	hp->vert = vert;
@


1.18
log
@simplify by getting rid of ROFF_ERR in tbl(7) parsing; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_layout.c,v 1.17 2014/11/25 05:39:00 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2012, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d35 1
a35 9
/*
 * FIXME: we can make this parse a lot nicer by, when an error is
 * encountered in a layout key, bailing to the next key (i.e. to the
 * next whitespace then continuing).
 */

#define	KEYS_MAX	 11

static	const struct tbl_phrase keys[KEYS_MAX] = {
d48 3
a50 1
static	int		 mods(struct tbl_node *, struct tbl_cell *,
d52 1
a52 1
static	int		 cell(struct tbl_node *, struct tbl_row *,
d58 1
a58 1
static int
d62 1
a62 2
	char		 buf[5];
	int		 i;
d64 3
a66 1
	/* Not all types accept modifiers. */
d68 1
a68 10
	switch (cp->pos) {
	case TBL_CELL_DOWN:
		/* FALLTHROUGH */
	case TBL_CELL_HORIZ:
		/* FALLTHROUGH */
	case TBL_CELL_DHORIZ:
		return(1);
	default:
		break;
	}
d70 2
a71 23
mod:
	/*
	 * XXX: since, at least for now, modifiers are non-conflicting
	 * (are separable by value, regardless of position), we let
	 * modifiers come in any order.  The existing tbl doesn't let
	 * this happen.
	 */
	switch (p[*pos]) {
	case '\0':
		/* FALLTHROUGH */
	case ' ':
		/* FALLTHROUGH */
	case '\t':
		/* FALLTHROUGH */
	case ',':
		/* FALLTHROUGH */
	case '.':
		/* FALLTHROUGH */
	case '|':
		return(1);
	default:
		break;
	}
d83 1
a83 1
		mandoc_msg(MANDOCERR_TBLLAYOUT, tbl->parse,
d85 1
a85 1
		return(0);
d91 2
a92 18
		for (i = 0; i < 4; i++) {
			if ( ! isdigit((unsigned char)p[*pos + i]))
				break;
			buf[i] = p[*pos + i];
		}
		buf[i] = '\0';

		/* No greater than 4 digits. */

		if (4 == i) {
			mandoc_msg(MANDOCERR_TBLLAYOUT,
			    tbl->parse, ln, *pos, NULL);
			return(0);
		}

		*pos += i;
		cp->spacing = (size_t)atoi(buf);

a93 1
		/* NOTREACHED */
a95 2
	/* TODO: GNU has many more extensions. */

d97 9
a105 5
	case 'z':
		cp->flags |= TBL_CELL_WIGN;
		goto mod;
	case 'u':
		cp->flags |= TBL_CELL_UP;
d110 14
d127 2
a128 2
	case 'd':
		cp->flags |= TBL_CELL_BALIGN;
d135 3
a137 9
	case 'f':
		break;
	case 'r':
		/* FALLTHROUGH */
	case 'b':
		/* FALLTHROUGH */
	case 'i':
		(*pos)--;
		break;
d139 3
a141 3
		mandoc_msg(MANDOCERR_TBLLAYOUT, tbl->parse,
		    ln, *pos - 1, NULL);
		return(0);
a159 3
		break;
	}
	if (isalnum((unsigned char)p[*pos - 1])) {
a163 4

	mandoc_msg(MANDOCERR_TBLLAYOUT, tbl->parse,
	    ln, *pos - 1, NULL);
	return(0);
d166 1
a166 1
static int
d175 10
a184 3
	for (vert = 0; '|' == p[*pos]; ++*pos)
		vert++;
	while (' ' == p[*pos])
d186 1
d192 1
a192 1
		return(1);
d201 5
a205 4
	if (KEYS_MAX == i) {
		mandoc_msg(MANDOCERR_TBLLAYOUT, tbl->parse,
		    ln, *pos, NULL);
		return(0);
a206 1

d209 1
a209 25
	/*
	 * If a span cell is found first, raise a warning and abort the
	 * parse.  If a span cell is found and the last layout element
	 * isn't a "normal" layout, bail.
	 *
	 * FIXME: recover from this somehow?
	 */

	if (TBL_CELL_SPAN == c) {
		if (NULL == rp->first) {
			mandoc_msg(MANDOCERR_TBLLAYOUT, tbl->parse,
			    ln, *pos, NULL);
			return(0);
		} else if (rp->last)
			switch (rp->last->pos) {
			case TBL_CELL_HORIZ:
				/* FALLTHROUGH */
			case TBL_CELL_DHORIZ:
				mandoc_msg(MANDOCERR_TBLLAYOUT,
				    tbl->parse, ln, *pos, NULL);
				return(0);
			default:
				break;
			}
	}
d211 10
a220 9
	/*
	 * If a vertical spanner is found, we may not be in the first
	 * row.
	 */

	if (TBL_CELL_DOWN == c && rp == tbl->first_row) {
		mandoc_msg(MANDOCERR_TBLLAYOUT, tbl->parse, ln, *pos, NULL);
		return(0);
	}
a223 7
	/* Disallow adjacent spacers. */

	if (vert > 2) {
		mandoc_msg(MANDOCERR_TBLLAYOUT, tbl->parse, ln, *pos - 1, NULL);
		return(0);
	}

d226 1
a226 1
	return(mods(tbl, cell_alloc(tbl, rp, c, vert), ln, p, pos));
d241 1
a241 1
		while (isspace((unsigned char)p[pos]))
d256 1
a256 1
			mandoc_msg(MANDOCERR_TBLNOLAYOUT,
d274 1
a274 2
		if ( ! cell(tbl, rp, ln, p, &pos))
			return;
@


1.17
log
@Completely rewrite the top level of the layout parser.
* Do not allocate lines unless there are cells.
* Make the MANDOCERR_TBLNOLAYOUT message actually work.
Also get rid of one static function and two goto statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_layout.c,v 1.16 2014/10/14 02:16:02 schwarze Exp $ */
d300 1
a300 1
int
d321 1
a321 1
			return(1);
d326 1
a326 1
				return(1);
d332 1
a332 1
			return(1);
d346 1
a346 1
			return(1);
@


1.16
log
@Rudimentary implementation of the e, x, and z table layout modifiers
to equalize, maximize, and ignore the width of columns.
Does not yet take vertical rulers into account,
and does not do line breaks within table cells.
Considerably improves the lftp(1) manual; issue noticed by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a59 1
static	void		 row(struct tbl_node *, int, const char *, int *);
d300 2
a301 2
static void
row(struct tbl_node *tbl, int ln, const char *p, int *pos)
d304 1
d306 2
a307 16
row:	/*
	 * EBNF describing this section:
	 *
	 * row		::= row_list [:space:]* [.]?[\n]
	 * row_list	::= [:space:]* row_elem row_tail
	 * row_tail	::= [:space:]*[,] row_list |
	 *                  epsilon
	 * row_elem	::= [\t\ ]*[:alpha:]+
	 */

	rp = mandoc_calloc(1, sizeof(struct tbl_row));
	if (tbl->last_row)
		tbl->last_row->next = rp;
	else
		tbl->first_row = rp;
	tbl->last_row = rp;
d309 2
a310 3
cell:
	while (isspace((unsigned char)p[*pos]))
		(*pos)++;
d312 2
a313 1
	/* Safely exit layout context. */
d315 12
a326 3
	if ('.' == p[*pos]) {
		tbl->part = TBL_PART_DATA;
		if (NULL == tbl->first_row)
d328 19
a346 3
			    tbl->parse, ln, *pos, NULL);
		(*pos)++;
		return;
a347 26

	/* End (and possibly restart) a row. */

	if (',' == p[*pos]) {
		(*pos)++;
		goto row;
	} else if ('\0' == p[*pos])
		return;

	if ( ! cell(tbl, rp, ln, p, pos))
		return;

	goto cell;
	/* NOTREACHED */
}

int
tbl_layout(struct tbl_node *tbl, int ln, const char *p)
{
	int		 pos;

	pos = 0;
	row(tbl, ln, p, &pos);

	/* Always succeed. */
	return(1);
@


1.15
log
@If a tbl(7) layout contains unknown font modifiers, fall back to the
default font rather than failing the whole table.
Needed by some pages in books/man-pages-posix.
Written on the plane back from EuroBSDCon in Sofia.
@
text
@d1 1
a1 1
/*	$Id: tbl_layout.c,v 1.14 2014/04/20 16:44:44 schwarze Exp $ */
d18 2
d168 3
@


1.14
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: tbl_layout.c,v 1.13 2014/03/28 23:25:54 schwarze Exp $ */
d199 5
@


1.13
log
@Allow leading and trailing vertical lines,
and format them in the same way as groff.
While here, do not require whitespace before vertical lines
in layout specifications.
Issues found by bentley@@ in mpv(1).
@
text
@d1 1
a1 1
/*	$Id: tbl_layout.c,v 1.12 2014/03/21 22:17:01 schwarze Exp $ */
d54 1
a54 1
static	int		 mods(struct tbl_node *, struct tbl_cell *, 
d56 1
a56 1
static	int		 cell(struct tbl_node *, struct tbl_row *, 
d62 1
d64 1
a64 1
mods(struct tbl_node *tbl, struct tbl_cell *cp, 
d73 1
a73 1
	case (TBL_CELL_DOWN):
d75 1
a75 1
	case (TBL_CELL_HORIZ):
d77 1
a77 1
	case (TBL_CELL_DHORIZ):
d84 1
a84 1
	/* 
d91 1
a91 1
	case ('\0'):
d93 1
a93 1
	case (' '):
d95 1
a95 1
	case ('\t'):
d97 1
a97 1
	case (','):
d99 1
a99 1
	case ('.'):
d101 1
a101 1
	case ('|'):
d117 2
a118 2
		mandoc_msg(MANDOCERR_TBLLAYOUT, 
				tbl->parse, ln, *pos, NULL);
d135 2
a136 2
			mandoc_msg(MANDOCERR_TBLLAYOUT, tbl->parse,
					ln, *pos, NULL);
d145 1
a145 1
	} 
d150 1
a150 1
	case ('z'):
d153 1
a153 1
	case ('u'):
d156 1
a156 1
	case ('e'):
d159 1
a159 1
	case ('t'):
d162 1
a162 1
	case ('d'):
d165 1
a165 1
	case ('w'):  /* XXX for now, ignore minimal column width */
d167 1
a167 1
	case ('f'):
d169 1
a169 1
	case ('r'):
d171 1
a171 1
	case ('b'):
d173 1
a173 1
	case ('i'):
d178 1
a178 1
				ln, *pos - 1, NULL);
d183 1
a183 1
	case ('3'):
d185 1
a185 1
	case ('b'):
d188 1
a188 1
	case ('2'):
d190 1
a190 1
	case ('i'):
d193 1
a193 1
	case ('1'):
d195 1
a195 1
	case ('r'):
d202 1
a202 1
			ln, *pos - 1, NULL);
d207 1
a207 1
cell(struct tbl_node *tbl, struct tbl_row *rp, 
d234 2
a235 2
		mandoc_msg(MANDOCERR_TBLLAYOUT, tbl->parse, 
				ln, *pos, NULL);
d252 1
a252 1
					ln, *pos, NULL);
d256 5
a260 4
			case (TBL_CELL_HORIZ):
			case (TBL_CELL_DHORIZ):
				mandoc_msg(MANDOCERR_TBLLAYOUT, tbl->parse,
						ln, *pos, NULL);
a290 1

d321 3
a323 3
		if (NULL == tbl->first_row) 
			mandoc_msg(MANDOCERR_TBLNOLAYOUT, tbl->parse, 
					ln, *pos, NULL);
@


1.12
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: tbl_layout.c,v 1.11 2012/05/26 20:03:34 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2012 Ingo Schwarze <schwarze@@openbsd.org>
d99 2
d218 7
@


1.11
log
@Do not handle vertical lines as additional tbl(7) columns,
instead save their properties with the following column.
This simplifies layout parsing and saves a lot of code
related to column handling.

At output time, print all white space and vertical lines
separating columns before printing the following column,
and none after printing the preceding column, considerably
simplifying white space handling and width calculations.

No functional change, but it saves 150 lines of code,
and it allows the next patch to tbl_term.c, tbl_literal().
@
text
@d1 1
a1 1
/*	$Id: tbl_layout.c,v 1.10 2011/09/18 15:54:48 schwarze Exp $ */
a17 1
#include <assert.h>
d24 1
@


1.10
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: tbl_layout.c,v 1.9 2011/05/29 21:22:18 schwarze Exp $ */
d4 1
d51 1
a51 2
	{ '=',		 TBL_CELL_DHORIZ },
	{ '|',		 TBL_CELL_VERT }
d59 2
a60 4
static	struct tbl_cell *cell_alloc(struct tbl_node *, 
				struct tbl_row *, enum tbl_cellt);
static	void		 head_adjust(const struct tbl_cell *, 
				struct tbl_head *);
a76 4
		/* FALLTHROUGH */
	case (TBL_CELL_VERT):
		/* FALLTHROUGH */
	case (TBL_CELL_DVERT):
d207 1
a207 1
	int		 i;
d210 8
a217 1
	/* Parse the column position (`r', `R', `|', ...). */
a245 2
			case (TBL_CELL_VERT):
			case (TBL_CELL_DVERT):
a267 7
	/* Extra check for the double-vertical. */

	if (TBL_CELL_VERT == c && '|' == p[*pos]) {
		(*pos)++;
		c = TBL_CELL_DVERT;
	} 
	
d270 1
a270 3
	if (rp->last && (TBL_CELL_VERT == c || TBL_CELL_DVERT == c) &&
			(TBL_CELL_VERT == rp->last->pos || 
			 TBL_CELL_DVERT == rp->last->pos)) {
d277 1
a277 1
	return(mods(tbl, cell_alloc(tbl, rp, c), ln, p, pos));
d297 1
a297 1
	if (tbl->last_row) {
d299 3
a301 3
		tbl->last_row = rp;
	} else
		tbl->last_row = tbl->first_row = rp;
d346 2
a347 1
cell_alloc(struct tbl_node *tbl, struct tbl_row *rp, enum tbl_cellt pos)
d355 7
a361 4
		rp->last->next = p;
		rp->last = p;
	} else
		rp->last = rp->first = p;
d364 1
d366 1
a366 20
	/*
	 * This is a little bit complicated.  Here we determine the
	 * header the corresponds to a cell.  We add headers dynamically
	 * when need be or re-use them, otherwise.  As an example, given
	 * the following:
	 *
	 * 	1  c || l 
	 * 	2  | c | l
	 * 	3  l l
	 * 	3  || c | l |.
	 *
	 * We first add the new headers (as there are none) in (1); then
	 * in (2) we insert the first spanner (as it doesn't match up
	 * with the header); then we re-use the prior data headers,
	 * skipping over the spanners; then we re-use everything and add
	 * a last spanner.  Note that VERT headers are made into DVERT
	 * ones.
	 */

	h = pp ? pp->head->next : tbl->first_head;
d369 2
a370 42
		/* Re-use data header. */
		if (TBL_HEAD_DATA == h->pos && 
				(TBL_CELL_VERT != p->pos &&
				 TBL_CELL_DVERT != p->pos)) {
			p->head = h;
			return(p);
		}

		/* Re-use spanner header. */
		if (TBL_HEAD_DATA != h->pos && 
				(TBL_CELL_VERT == p->pos ||
				 TBL_CELL_DVERT == p->pos)) {
			head_adjust(p, h);
			p->head = h;
			return(p);
		}

		/* Right-shift headers with a new spanner. */
		if (TBL_HEAD_DATA == h->pos && 
				(TBL_CELL_VERT == p->pos ||
				 TBL_CELL_DVERT == p->pos)) {
			hp = mandoc_calloc(1, sizeof(struct tbl_head));
			hp->ident = tbl->opts.cols++;
			hp->prev = h->prev;
			if (h->prev)
				h->prev->next = hp;
			if (h == tbl->first_head)
				tbl->first_head = hp;
			h->prev = hp;
			hp->next = h;
			head_adjust(p, hp);
			p->head = hp;
			return(p);
		}

		if (NULL != (h = h->next)) {
			head_adjust(p, h);
			p->head = h;
			return(p);
		}

		/* Fall through to default case... */
d375 1
a379 1
		tbl->last_head = hp;
d381 2
a382 1
		tbl->last_head = tbl->first_head = hp;
a383 1
	head_adjust(p, hp);
a386 18

static void
head_adjust(const struct tbl_cell *cellp, struct tbl_head *head)
{
	if (TBL_CELL_VERT != cellp->pos &&
			TBL_CELL_DVERT != cellp->pos) {
		head->pos = TBL_HEAD_DATA;
		return;
	}

	if (TBL_CELL_VERT == cellp->pos)
		if (TBL_HEAD_DVERT != head->pos)
			head->pos = TBL_HEAD_VERT;

	if (TBL_CELL_DVERT == cellp->pos)
		head->pos = TBL_HEAD_DVERT;
}

@


1.9
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: tbl_layout.c,v 1.8 2011/04/24 16:22:02 schwarze Exp $ */
d172 2
d186 2
d191 2
d195 4
@


1.8
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: tbl_layout.c,v 1.7 2011/01/16 01:11:50 schwarze Exp $ */
d71 17
d443 1
a443 1
head_adjust(const struct tbl_cell *cell, struct tbl_head *head)
d445 2
a446 2
	if (TBL_CELL_VERT != cell->pos &&
			TBL_CELL_DVERT != cell->pos) {
d451 1
a451 1
	if (TBL_CELL_VERT == cell->pos)
d455 1
a455 1
	if (TBL_CELL_DVERT == cell->pos)
@


1.7
log
@Various tbl improvements from kristaps@@:
* horizontal lines do not consume layout lines
* skip excessive data cells
* prepare rendering of spanned cells
* support vertical spans
@
text
@d1 1
a1 1
/*	$Id: tbl_layout.c,v 1.6 2011/01/09 14:30:48 schwarze Exp $ */
d103 2
a104 1
		TBL_MSG(tbl, MANDOCERR_TBLLAYOUT, ln, *pos);
d121 2
a122 1
			TBL_MSG(tbl, MANDOCERR_TBLLAYOUT, ln, *pos);
d161 2
a162 1
		TBL_MSG(tbl, MANDOCERR_TBLLAYOUT, ln, *pos - 1);
d177 2
a178 1
	TBL_MSG(tbl, MANDOCERR_TBLLAYOUT, ln, *pos - 1);
d196 2
a197 1
		TBL_MSG(tbl, MANDOCERR_TBLLAYOUT, ln, *pos);
d213 2
a214 1
			TBL_MSG(tbl, MANDOCERR_TBLLAYOUT, ln, *pos);
d222 2
a223 1
				TBL_MSG(tbl, MANDOCERR_TBLLAYOUT, ln, *pos);
d236 1
a236 1
		TBL_MSG(tbl, MANDOCERR_TBLLAYOUT, ln, *pos);
d254 1
a254 1
		TBL_MSG(tbl, MANDOCERR_TBLLAYOUT, ln, *pos - 1);
d295 2
a296 1
			TBL_MSG(tbl, MANDOCERR_TBLNOLAYOUT, ln, *pos);
@


1.6
log
@Sync tbl handling to bsd.lv release 1.10.9:
* .T} can be followed by a delimiter, then more data.
* Do not limit table column widths (improves terminfo(5)).
* Let numerical cells respect explicitly specified minimum cell widths.
* Let terminal output survive missing data cells.
* Parse and ignore arguments in parentheses on layout cell specifications.
* Move tbl_calc() into out.c such that it can be used by all frontends.
* Give tables an HTML class.
* Some cleanup in tbl -Thtml code.
All code by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: tbl_layout.c,v 1.5 2011/01/04 23:44:20 schwarze Exp $ */
d125 1
a125 1
		cp->spacing = atoi(buf);
d200 4
a203 1
	 * parse.  FIXME: recover from this somehow?
d206 23
a228 1
	if (NULL == rp->first && TBL_CELL_SPAN == c) {
@


1.5
log
@Bring back my fix from -r 1.3 (Oct 15, 2010) after the merge.
Original commit message:

For now, parse and ignore minimal column width specifications.
First step to get terminfo(5) to build.
@
text
@d1 1
a1 1
/*	$Id: tbl_layout.c,v 1.4 2011/01/04 22:28:17 schwarze Exp $ */
d32 6
d93 14
d133 1
a133 1
	switch (tolower(p[(*pos)++])) {
d163 1
a163 1
	switch (tolower(p[(*pos)++])) {
d188 1
a188 1
		if (tolower(p[*pos]) == keys[i].name)
d196 12
a208 1
	c = keys[i].key;
@


1.4
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: tbl_layout.c,v 1.1 2010/12/29 14:38:14 kristaps Exp $ */
d128 2
@


1.3
log
@For now, parse and ignore minimal column width specifications.
First step to get terminfo(5) to build.
@
text
@d1 1
a1 1
/*	$Id: tbl_layout.c,v 1.2 2010/10/15 21:33:47 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2009 Kristaps Dzonsons <kristaps@@kth.se>
a16 3
#include <sys/queue.h>
#include <sys/types.h>

d21 1
d23 3
a25 3
#include "out.h"
#include "term.h"
#include "tbl_extern.h"
d32 1
a32 1
#define	KEYS_MAX	 17
a35 1
	{ 'C',		 TBL_CELL_CENTRE },
a36 1
	{ 'R',		 TBL_CELL_RIGHT },
a37 1
	{ 'L',		 TBL_CELL_LEFT },
a38 1
	{ 'N',		 TBL_CELL_NUMBER },
a39 1
	{ 'S',		 TBL_CELL_SPAN },
a40 1
	{ 'A',		 TBL_CELL_LONG },
d48 3
a50 6
static	int		mods(struct tbl *, struct tbl_cell *, 
				const char *, int, 
				const char *, int, int);
static	int		cell(struct tbl *, struct tbl_row *, 
				const char *, int, int);
static	int		row(struct tbl *, const char *,
d52 5
a56 1

d59 2
a60 2
mods(struct tbl *tbl, struct tbl_cell *cp, const char *p, 
		int pp, const char *f, int ln, int pos)
d65 1
d72 10
a81 2

	if (0 == p[pp])
d83 3
d89 1
a89 1
	if (isdigit((u_char)p[pp])) {
d91 1
a91 1
			if ( ! isdigit((u_char)p[pp + i]))
d93 1
a93 1
			buf[i] = p[pp + i];
d95 1
a95 1
		buf[i] = 0;
d99 4
a102 2
		if (4 == i)
			return(tbl_errx(tbl, ERR_SYNTAX, f, ln, pos + pp));
d104 2
a105 13
		/* 
		 * We can't change the spacing in any subsequent layout
		 * definitions.  FIXME: I don't think we can change the
		 * spacing for a column at all, after it's already been
		 * initialised.
		 */

		if (TBL_PART_CLAYOUT != tbl->part)
			cp->spacing = atoi(buf);
		else if ( ! tbl_warnx(tbl, ERR_SYNTAX, f, ln, pos + pp))
			return(0);
		
		/* Continue parsing modifiers. */
d107 2
a108 1
		return(mods(tbl, cp, p, pp + i, f, ln, pos));
d113 1
a113 1
	switch (p[pp]) {
a114 2
		/* FALLTHROUGH */
	case ('Z'):
d116 1
a116 6
		return(mods(tbl, cp, p, pp + 1, f, ln, pos));
	case ('w'):
		/* FALLTHROUGH */
	case ('W'):  /* XXX for now, ignore minimal column width */
		while (isdigit((u_char)p[++pp]));
		return(mods(tbl, cp, p, pp, f, ln, pos));
a117 2
		/* FALLTHROUGH */
	case ('U'):
d119 1
a119 1
		return(mods(tbl, cp, p, pp + 1, f, ln, pos));
a120 2
		/* FALLTHROUGH */
	case ('E'):
d122 1
a122 1
		return(mods(tbl, cp, p, pp + 1, f, ln, pos));
a123 2
		/* FALLTHROUGH */
	case ('T'):
d125 1
a125 1
		return(mods(tbl, cp, p, pp + 1, f, ln, pos));
a126 2
		/* FALLTHROUGH */
	case ('D'):
d128 1
a128 1
		return(mods(tbl, cp, p, pp + 1, f, ln, pos));
d130 1
a130 6
		pp++;
		/* FALLTHROUGH */
	case ('B'):
		/* FALLTHROUGH */
	case ('I'):
		/* FALLTHROUGH */
d134 1
d137 2
a138 1
		return(tbl_errx(tbl, ERR_SYNTAX, f, ln, pos + pp));
d141 1
a141 1
	switch (p[pp]) {
a142 2
		/* FALLTHROUGH */
	case ('B'):
d144 1
a144 1
		return(mods(tbl, cp, p, pp + 1, f, ln, pos));
a145 2
		/* FALLTHROUGH */
	case ('I'):
d147 1
a147 1
		return(mods(tbl, cp, p, pp + 1, f, ln, pos));
d152 2
a153 1
	return(tbl_errx(tbl, ERR_SYNTAX, f, ln, pos + pp));
a155 1

d157 2
a158 2
cell(struct tbl *tbl, struct tbl_row *rp, 
		const char *f, int ln, int pos)
d160 1
a160 3
	struct tbl_cell	*cp;
	const char	*p;
	int		 j, i;
d165 7
a171 6
	c = TBL_CELL_MAX;
	for (p = tbl_last(), i = 0; i < KEYS_MAX; i++) {
		if (keys[i].name != p[0])
			continue;
		c = keys[i].key;
		break;
d174 2
a175 2
	if (i == KEYS_MAX)
		return(tbl_errx(tbl, ERR_SYNTAX, f, ln, pos));
d179 2
a180 2
	if (TBL_CELL_VERT == c && '|' == p[1]) {
		j = 2;
d182 1
a182 2
	} else
		j = 1;
d184 1
a184 1
	/* Disallow subsequent spacers. */
d186 6
a191 7
	/* LINTED */
	cp = TAILQ_LAST(&rp->cell, tbl_cellh);

	if (cp && (TBL_CELL_VERT == c || TBL_CELL_DVERT == c) && 
			(TBL_CELL_VERT == cp->pos || 
			 TBL_CELL_DVERT == cp->pos))
		return(tbl_errx(tbl, ERR_SYNTAX, f, ln, pos));
d195 1
a195 3
	if (NULL == (cp = tbl_cell_alloc(rp, c)))
		return(0);
	return(mods(tbl, cp, p, j, f, ln, pos));
d199 2
a200 3
static int
row(struct tbl *tbl, const char *f, int ln,
		const char *p, int *pos)
a202 5
	int		 sv;

	rp = tbl_row_alloc(tbl);
again:
	sv = *pos;
d204 1
a204 1
	/*
d214 14
a227 16
	switch (tbl_next(p, pos)) {
	case (TBL_TOK_TAB):
		/* FALLTHROUGH */
	case (TBL_TOK_SPACE):
		goto again;
	case (TBL_TOK_WORD):
		if ( ! cell(tbl, rp, f, ln, sv))
			return(0);
		goto again;
	case (TBL_TOK_COMMA):
		if (NULL == TAILQ_FIRST(&rp->cell))
			return(tbl_errx(tbl, ERR_SYNTAX, f, ln, sv));
		return(row(tbl, f, ln, p, pos));
	case (TBL_TOK_PERIOD):
		if (NULL == TAILQ_FIRST(&rp->cell))
			return(tbl_errx(tbl, ERR_SYNTAX, f, ln, sv));
d229 4
a232 7
		break;
	case (TBL_TOK_NIL):
		if (NULL == TAILQ_FIRST(&rp->cell))
			return(tbl_errx(tbl, ERR_SYNTAX, f, ln, sv));
		break;
	default:
		return(tbl_errx(tbl, ERR_SYNTAX, f, ln, sv));
d235 13
a247 1
	return(1);
a249 1

d251 1
a251 1
tbl_layout(struct tbl *tbl, const char *f, int ln, const char *p)
d256 4
a259 1
	return(row(tbl, f, ln, p, &pos));
d261 115
@


1.2
log
@Move tbl output from plain stdio to mandoc terminal output routines.
This fixes (1) all escape sequences and (2) some aspects of indentation.
Table column widths are still way off, though.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$Id: layout.c,v 1.7 2009/09/11 13:24:04 kristaps Exp $ */
d122 5
@


1.1
log
@Import tbl parser and renderer written by kristaps@@.
Unchanged code from bsd.lv release 0.1.5, but without the main program.
Not yet linked to the build; next commit will integrate it into mandoc.
@
text
@d25 2
@

