head	1.32;
access;
symbols
	OPENBSD_6_2:1.32.0.2
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.28.0.8
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.12.0.4
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9;
locks; strict;
comment	@ * @;


1.32
date	2017.07.08.17.52.42;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	1RJz61Tw2T8cTX39;

1.31
date	2017.07.04.20.59.17;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	wdkNgRM2PdmoSbhv;

1.30
date	2017.06.16.20.00.41;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	Ws0YHuIypb6sve4L;

1.29
date	2017.06.08.18.11.15;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	iJqHiCg2x8ufqICJ;

1.28
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	hxQV8O1pNUaef4ir;

1.27
date	2015.04.19.20.34.56;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	hyIZbPUCYxBhW1pN;

1.26
date	2015.01.30.17.31.20;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	8uPgte1HahL1XRHj;

1.25
date	2015.01.30.04.08.37;	author schwarze;	state Exp;
branches;
next	1.24;
commitid	KL58yWbJhw6UbgSB;

1.24
date	2015.01.30.02.08.37;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	vvSu12hfLARx94BX;

1.23
date	2015.01.28.17.30.37;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	B9i4oMLogJsiyrd5;

1.22
date	2015.01.28.15.02.25;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	Um2gz4HrZv1IOy6F;

1.21
date	2015.01.27.05.20.30;	author schwarze;	state Exp;
branches;
next	1.20;
commitid	x93gRIdSgdjntkaE;

1.20
date	2015.01.21.00.45.16;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	luBZukwvZIctwZsD;

1.19
date	2014.11.28.19.25.03;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	1m1y3OocNVYDnyZE;

1.18
date	2014.04.23.16.07.06;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2014.01.05.21.02.43;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2013.06.01.04.56.41;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.31.21.37.09;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2012.05.26.20.03.34;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2011.02.10.00.06.30;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.25.12.24.26;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.25.12.16.19;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.16.01.11.50;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.01.09.14.30.48;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.15.23.19.40;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.15.21.33.47;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.15.19.20.03;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Simplify by creating struct roff_node syntax tree nodes for tbl(7)
right from roff_parseln() rather than delegating to read.c,
similar to what i just did for eqn(7).

The interface function roff_span() becomes obsolete and is deleted,
the former interface function roff_addtbl() becomes static,
the interface functions tbl_read() and tbl_cdata() become void,
and minus twelve linus of code.

No functional change.
@
text
@/*	$OpenBSD: tbl_data.c,v 1.31 2017/07/04 20:59:17 schwarze Exp $ */
/*
 * Copyright (c) 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011, 2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mandoc.h"
#include "mandoc_aux.h"
#include "libmandoc.h"
#include "libroff.h"

static	void		 getdata(struct tbl_node *, struct tbl_span *,
				int, const char *, int *);
static	struct tbl_span	*newspan(struct tbl_node *, int,
				struct tbl_row *);


static void
getdata(struct tbl_node *tbl, struct tbl_span *dp,
		int ln, const char *p, int *pos)
{
	struct tbl_dat	*dat;
	struct tbl_cell	*cp;
	int		 sv;

	/* Advance to the next layout cell, skipping spanners. */

	cp = dp->last == NULL ? dp->layout->first : dp->last->layout->next;
	while (cp != NULL && cp->pos == TBL_CELL_SPAN)
		cp = cp->next;

	/*
	 * If the current layout row is out of cells, allocate
	 * a new cell if another row of the table has at least
	 * this number of columns, or discard the input if we
	 * are beyond the last column of the table as a whole.
	 */

	if (cp == NULL) {
		if (dp->layout->last->col + 1 < dp->opts->cols) {
			cp = mandoc_calloc(1, sizeof(*cp));
			cp->pos = TBL_CELL_LEFT;
			dp->layout->last->next = cp;
			cp->col = dp->layout->last->col + 1;
			dp->layout->last = cp;
		} else {
			mandoc_msg(MANDOCERR_TBLDATA_EXTRA, tbl->parse,
			    ln, *pos, p + *pos);
			while (p[*pos])
				(*pos)++;
			return;
		}
	}

	dat = mandoc_calloc(1, sizeof(*dat));
	dat->layout = cp;
	dat->pos = TBL_DATA_NONE;
	dat->spans = 0;
	for (cp = cp->next; cp != NULL; cp = cp->next)
		if (cp->pos == TBL_CELL_SPAN)
			dat->spans++;
		else
			break;

	if (dp->last == NULL)
		dp->first = dat;
	else
		dp->last->next = dat;
	dp->last = dat;

	sv = *pos;
	while (p[*pos] && p[*pos] != tbl->opts.tab)
		(*pos)++;

	/*
	 * Check for a continued-data scope opening.  This consists of a
	 * trailing `T{' at the end of the line.  Subsequent lines,
	 * until a standalone `T}', are included in our cell.
	 */

	if (*pos - sv == 2 && p[sv] == 'T' && p[sv + 1] == '{') {
		tbl->part = TBL_PART_CDATA;
		return;
	}

	dat->string = mandoc_strndup(p + sv, *pos - sv);

	if (p[*pos])
		(*pos)++;

	if ( ! strcmp(dat->string, "_"))
		dat->pos = TBL_DATA_HORIZ;
	else if ( ! strcmp(dat->string, "="))
		dat->pos = TBL_DATA_DHORIZ;
	else if ( ! strcmp(dat->string, "\\_"))
		dat->pos = TBL_DATA_NHORIZ;
	else if ( ! strcmp(dat->string, "\\="))
		dat->pos = TBL_DATA_NDHORIZ;
	else
		dat->pos = TBL_DATA_DATA;

	if ((dat->layout->pos == TBL_CELL_HORIZ ||
	    dat->layout->pos == TBL_CELL_DHORIZ ||
	    dat->layout->pos == TBL_CELL_DOWN) &&
	    dat->pos == TBL_DATA_DATA && *dat->string != '\0')
		mandoc_msg(MANDOCERR_TBLDATA_SPAN,
		    tbl->parse, ln, sv, dat->string);
}

void
tbl_cdata(struct tbl_node *tbl, int ln, const char *p, int pos)
{
	struct tbl_dat	*dat;
	size_t		 sz;

	dat = tbl->last_span->last;

	if (p[pos] == 'T' && p[pos + 1] == '}') {
		pos += 2;
		if (p[pos] == tbl->opts.tab) {
			tbl->part = TBL_PART_DATA;
			pos++;
			while (p[pos] != '\0')
				getdata(tbl, tbl->last_span, ln, p, &pos);
			return;
		} else if (p[pos] == '\0') {
			tbl->part = TBL_PART_DATA;
			return;
		}

		/* Fallthrough: T} is part of a word. */
	}

	dat->pos = TBL_DATA_DATA;
	dat->block = 1;

	if (dat->string != NULL) {
		sz = strlen(p + pos) + strlen(dat->string) + 2;
		dat->string = mandoc_realloc(dat->string, sz);
		(void)strlcat(dat->string, " ", sz);
		(void)strlcat(dat->string, p + pos, sz);
	} else
		dat->string = mandoc_strdup(p + pos);

	if (dat->layout->pos == TBL_CELL_DOWN)
		mandoc_msg(MANDOCERR_TBLDATA_SPAN, tbl->parse,
		    ln, pos, dat->string);
}

static struct tbl_span *
newspan(struct tbl_node *tbl, int line, struct tbl_row *rp)
{
	struct tbl_span	*dp;

	dp = mandoc_calloc(1, sizeof(*dp));
	dp->line = line;
	dp->opts = &tbl->opts;
	dp->layout = rp;
	dp->prev = tbl->last_span;

	if (dp->prev == NULL) {
		tbl->first_span = dp;
		tbl->current_span = NULL;
	} else
		dp->prev->next = dp;
	tbl->last_span = dp;

	return dp;
}

void
tbl_data(struct tbl_node *tbl, int ln, const char *p, int pos)
{
	struct tbl_row	*rp;
	struct tbl_cell	*cp;
	struct tbl_span	*sp;

	rp = (sp = tbl->last_span) == NULL ? tbl->first_row :
	    sp->pos == TBL_SPAN_DATA && sp->layout->next != NULL ?
	    sp->layout->next : sp->layout;

	assert(rp != NULL);

	if ( ! strcmp(p, "_")) {
		sp = newspan(tbl, ln, rp);
		sp->pos = TBL_SPAN_HORIZ;
		return;
	} else if ( ! strcmp(p, "=")) {
		sp = newspan(tbl, ln, rp);
		sp->pos = TBL_SPAN_DHORIZ;
		return;
	}

	/*
	 * If the layout row contains nothing but horizontal lines,
	 * allocate an empty span for it and assign the current span
	 * to the next layout row accepting data.
	 */

	while (rp->next != NULL) {
		if (rp->last->col + 1 < tbl->opts.cols)
			break;
		for (cp = rp->first; cp != NULL; cp = cp->next)
			if (cp->pos != TBL_CELL_HORIZ &&
			    cp->pos != TBL_CELL_DHORIZ)
				break;
		if (cp != NULL)
			break;
		sp = newspan(tbl, ln, rp);
		sp->pos = TBL_SPAN_DATA;
		rp = rp->next;
	}

	/* Process a real data row. */

	sp = newspan(tbl, ln, rp);
	sp->pos = TBL_SPAN_DATA;
	while (p[pos] != '\0')
		getdata(tbl, sp, ln, p, &pos);
}
@


1.31
log
@It turns out association of tbl spans with layout rows is simpler than
i thought.  Fixing a bug in curs_addch(3) and minus 25 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_data.c,v 1.30 2017/06/16 20:00:41 schwarze Exp $ */
d129 1
a129 1
int
d144 1
a144 1
			return 1;
d147 1
a147 1
			return 1;
a166 2

	return 0;
@


1.30
log
@Multiple tbl(7) improvements:
* Do not discard data that lacks a matching layout cell but remains
within the number of columns of the table as a whole.
* Do not insert dummy data rows for any layout row starting with a
horizontal line, but only for layout rows that would discard all
the data on a matching non-empty data row.
* Print horizontal lines specified in the layout even if there is
no matching data cell.
* Improve the logic for extending vertical lines to adjacent rows,
for choosing cross marks versus line segments, and some related details.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_data.c,v 1.29 2017/06/08 18:11:15 schwarze Exp $ */
d197 1
a197 3
	struct tbl_span	*sp, *spi;
	struct tbl_dat	*dp;
	int		 have_data, spans;
a204 2
	sp = newspan(tbl, ln, rp);

d206 1
d210 1
a213 4
	sp->pos = TBL_SPAN_DATA;

	while (p[pos] != '\0')
		getdata(tbl, sp, ln, p, &pos);
d216 3
a218 2
	 * If this span contains some data,
	 * make sure at least part of it gets printed.
d221 12
a232 15
	have_data = 0;
	cp = rp->first;
	for (dp = sp->first; dp != NULL; dp = dp->next) {
		if (dp->pos == TBL_DATA_DATA && *dp->string != '\0') {
			if (cp == NULL ||
			    (cp->pos != TBL_CELL_HORIZ &&
			     cp->pos != TBL_CELL_DHORIZ))
				return;
			have_data = 1;
		}
		spans = dp->spans;
		while (spans-- >= 0) {
			if (cp != NULL)
				cp = cp->next;
		}
a233 2
	if (have_data == 0 || rp->next == NULL)
		return;
d235 1
a235 5
	/*
	 * There is some data, but it would all get lost
	 * due to horizontal lines in the layout.
	 * Insert an empty span to consume the layout row.
	 */
d237 4
a240 18
	tbl->last_span = sp->prev;
	spi = newspan(tbl, ln, rp);
	spi->pos = TBL_SPAN_DATA;
	spi->next = sp;
	tbl->last_span = sp;
	sp->prev = spi;
	sp->layout = rp->next;
	cp = sp->layout->first;
	for (dp = sp->first; dp != NULL; dp = dp->next) {
		dp->layout = cp;
		dp->spans = 0;
		if (cp != NULL)
			cp = cp->next;
		while (cp != NULL && cp->pos == TBL_CELL_SPAN) {
			dp->spans++;
			cp = cp->next;
		}
	}
@


1.29
log
@Implement w layout specifier (minimum column width).
Improve width calculation of text blocks.
Reduces the groff/mandoc diff in Base+Xenocara by about 800 lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_data.c,v 1.28 2015/10/06 18:30:44 schwarze Exp $ */
d52 4
a55 2
	 * Stop processing when we reach the end of the available layout
	 * cells.  This means that we have extra input.
d59 13
a71 6
		mandoc_msg(MANDOCERR_TBLDATA_EXTRA, tbl->parse,
		    ln, *pos, p + *pos);
		/* Skip to the end... */
		while (p[*pos])
			(*pos)++;
		return;
a194 1
	struct tbl_span	*dp;
d196 4
d201 3
a203 34
	/*
	 * Choose a layout row: take the one following the last parsed
	 * span's.  If that doesn't exist, use the last parsed span's.
	 * If there's no last parsed span, use the first row.  Lastly,
	 * if the last span was a horizontal line, use the same layout
	 * (it doesn't "consume" the layout).
	 */

	if (tbl->last_span != NULL) {
		if (tbl->last_span->pos == TBL_SPAN_DATA) {
			for (rp = tbl->last_span->layout->next;
			     rp != NULL && rp->first != NULL;
			     rp = rp->next) {
				switch (rp->first->pos) {
				case TBL_CELL_HORIZ:
					dp = newspan(tbl, ln, rp);
					dp->pos = TBL_SPAN_HORIZ;
					continue;
				case TBL_CELL_DHORIZ:
					dp = newspan(tbl, ln, rp);
					dp->pos = TBL_SPAN_DHORIZ;
					continue;
				default:
					break;
				}
				break;
			}
		} else
			rp = tbl->last_span->layout;

		if (rp == NULL)
			rp = tbl->last_span->layout;
	} else
		rp = tbl->first_row;
d205 1
a205 1
	assert(rp);
d207 1
a207 1
	dp = newspan(tbl, ln, rp);
d210 1
a210 1
		dp->pos = TBL_SPAN_HORIZ;
d213 1
a213 1
		dp->pos = TBL_SPAN_DHORIZ;
d216 28
d245 5
a249 1
	dp->pos = TBL_SPAN_DATA;
d251 18
a268 2
	while (p[pos] != '\0')
		getdata(tbl, dp, ln, p, &pos);
@


1.28
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_data.c,v 1.27 2015/04/19 20:34:56 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2015 Ingo Schwarze <schwarze@@openbsd.org>
d145 1
@


1.27
log
@More than one data field may follow T} on the same input line.
Issue found by Christian Neukirchen <chneukirchen at gmail dot com>
in the socket(2) manual on Linux.
Also fixes major rendering bugs (including partial loss of content)
in XkbChangeControls(3), XkbFreeClientMap(3), XkbGetMap(3),
XkbKeyNumGroups(3), and XkbSetMap(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_data.c,v 1.26 2015/01/30 17:31:20 schwarze Exp $ */
d135 1
a135 1
			return(1);
d138 1
a138 1
			return(1);
d158 1
a158 1
	return(0);
d179 1
a179 1
	return(dp);
@


1.26
log
@Delete the redundant tbl span flags, just inspect the actual data
where needed, which is less fragile.
This fixes a subtle NULL pointer access to tp->tbl.cols:
Due to a bug in the man(7) parser, the first span of a table can
end up in a .TP head, in which case tblcalc() was never called.
Found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_data.c,v 1.25 2015/01/30 04:08:37 schwarze Exp $ */
d133 2
a134 1
			getdata(tbl, tbl->last_span, ln, p, &pos);
@


1.25
log
@Abolish struct tbl_head and replace it by an "int col" member in
struct tbl_cell.  No functional change, minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_data.c,v 1.24 2015/01/30 02:08:37 schwarze Exp $ */
a173 1
		dp->flags |= TBL_SPAN_FIRST;
@


1.24
log
@Auditing the tbl(7) code for more NULL pointer accesses, i came out
empty-handed; so this is just KNF and some code simplifications,
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_data.c,v 1.23 2015/01/28 17:30:37 schwarze Exp $ */
d45 2
a47 6

	/*
	 * Skip over spanners, since
	 * we want to match data with data layout cells in the header.
	 */

a168 1
	dp->head = tbl->first_head;
@


1.23
log
@* Polish tbl(7) error reporting.
* Do not print out macro names in tbl(7) data blocks.
* Like with GNU tbl, let empty tables cause a blank line.
* Avoid producing empty tables in -Tman.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_data.c,v 1.22 2015/01/28 15:02:25 schwarze Exp $ */
d43 1
a43 1
	int		 sv, spans;
d45 1
a45 5
	cp = NULL;
	if (dp->last && dp->last->layout)
		cp = dp->last->layout->next;
	else if (NULL == dp->last)
		cp = dp->layout->first;
d52 1
a52 1
	while (cp && TBL_CELL_SPAN == cp->pos)
d60 1
a60 1
	if (NULL == cp) {
d69 1
a69 1
	dat = mandoc_calloc(1, sizeof(struct tbl_dat));
d72 4
a75 6

	assert(TBL_CELL_SPAN != cp->pos);

	for (spans = 0, cp = cp->next; cp; cp = cp->next)
		if (TBL_CELL_SPAN == cp->pos)
			spans++;
d79 3
a81 3
	dat->spans = spans;

	if (dp->last) {
d83 1
a83 3
		dp->last = dat;
	} else
		dp->last = dp->first = dat;
d95 1
a95 1
	if (*pos - sv == 2 && 'T' == p[sv] && '{' == p[sv + 1]) {
d100 1
a100 5
	assert(*pos - sv >= 0);

	dat->string = mandoc_malloc((size_t)(*pos - sv + 1));
	memcpy(dat->string, &p[sv], (size_t)(*pos - sv));
	dat->string[*pos - sv] = '\0';
d116 6
a121 8
	if (TBL_CELL_HORIZ == dat->layout->pos ||
	    TBL_CELL_DHORIZ == dat->layout->pos ||
	    TBL_CELL_DOWN == dat->layout->pos)
		if (TBL_DATA_DATA == dat->pos && '\0' != *dat->string)
			mandoc_msg(MANDOCERR_TBLDATA_SPAN,
			    tbl->parse, ln, sv, dat->string);

	return;
d139 1
a139 1
		} else if ('\0' == p[pos]) {
d149 1
a149 1
	if (dat->string) {
d157 1
a157 1
	if (TBL_CELL_DOWN == dat->layout->pos)
d169 1
a169 1
	dp = mandoc_calloc(1, sizeof(struct tbl_span));
d201 1
a201 2
	if (tbl->last_span) {
		assert(tbl->last_span->layout);
d204 2
a205 1
					rp && rp->first; rp = rp->next) {
d223 1
a223 1
		if (NULL == rp)
d242 1
a242 1
	while ('\0' != p[pos])
@


1.22
log
@For now, it can't be helped that mandoc tbl(7) ignores high-level macros,
but stop throwing away their arguments.  This fixes information loss in a
handful of Xenocara manuals, at the price of a small amount of formatting
noise creeping through.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_data.c,v 1.21 2015/01/27 05:20:30 schwarze Exp $ */
d65 2
a66 2
		mandoc_msg(MANDOCERR_TBLEXTRADAT, tbl->parse,
		    ln, *pos, NULL);
d132 2
a133 2
			mandoc_msg(MANDOCERR_TBLIGNDATA,
			    tbl->parse, ln, sv, NULL);
d164 1
a164 1
		sz = strlen(p) + strlen(dat->string) + 2;
d167 1
a167 1
		(void)strlcat(dat->string, p, sz);
d169 1
a169 1
		dat->string = mandoc_strdup(p);
d172 2
a173 2
		mandoc_msg(MANDOCERR_TBLIGNDATA, tbl->parse,
		    ln, pos, NULL);
@


1.21
log
@Multiple parser and formatter fixes for line drawing in tbl(7).
* Allow mixing vertical line bars with the layout options
of the preceding layout cell.
* Correctly combine box options with layout lines.
* Correctly print vertical lines in data rows, with the right spacing.
* Correctly print cross markers and left and right ends of
horizontal lines even if vertical lines differ above and below.
* Avoid the bogus error message "no table data cells"
when a table data section starts with a horizontal line.
No increase in code size.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_data.c,v 1.20 2015/01/21 00:45:16 schwarze Exp $ */
d139 1
a139 1
tbl_cdata(struct tbl_node *tbl, int ln, const char *p)
a142 3
	int		 pos;

	pos = 0;
d202 1
a202 1
tbl_data(struct tbl_node *tbl, int ln, const char *p)
a205 1
	int		 pos;
a255 1
	pos = 0;
@


1.20
log
@blank lines in tables do not need special handling; simplifies code
and reduces groff/mandoc differences in base by about 1%
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_data.c,v 1.19 2014/11/28 19:25:03 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
d191 1
d193 2
a194 5
	if (tbl->last_span) {
		tbl->last_span->next = dp;
		tbl->last_span = dp;
	} else {
		tbl->last_span = tbl->first_span = dp;
d197 3
a199 1
	}
@


1.19
log
@Add some missing OpenBSD RCS markers
and a few missing <sys/types.h> inclusions; no code change.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d31 1
a31 1
static	int		 getdata(struct tbl_node *, struct tbl_span *,
d37 1
a37 1
static int
d70 1
a70 1
		return(1);
d105 1
a105 1
		return(1);
d135 1
a135 1
	return(1);
d154 2
a155 1
			return(getdata(tbl, tbl->last_span, ln, p, &pos));
d204 1
a204 1
int
a210 7
	pos = 0;

	if ('\0' == p[pos]) {
		mandoc_msg(MANDOCERR_TBL, tbl->parse, ln, pos, NULL);
		return(0);
	}

d252 1
a252 1
		return(1);
d255 1
a255 1
		return(1);
d260 1
a260 2
	/* This returns 0 when TBL_PART_CDATA is entered. */

d262 1
a262 4
		if ( ! getdata(tbl, dp, ln, p, &pos))
			return(0);

	return(1);
@


1.18
log
@Audit strlcpy(3)/strlcat(3) usage.

* Repair three instances of silent truncation, use asprintf(3).
* Change two instances of strlen(3)+malloc(3)+strlcpy(3)+strlcat(3)+...
to use asprintf(3) instead to make them less error prone.
* Cast the return value of four instances where the destination
buffer is known to be large enough to (void).
* Completely remove three useless instances of strlcpy(3)/strlcat(3).
* Mark two places in -Thtml with XXX that can cause information loss
and crashes but are not easy to fix, requiring design changes of
some internal interfaces.
* The file mandocdb.c remains to be audited.
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.17 2014/04/20 16:44:44 schwarze Exp $ */
d18 2
@


1.17
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.16 2014/03/21 22:17:01 schwarze Exp $ */
d166 2
a167 2
		strlcat(dat->string, " ", sz);
		strlcat(dat->string, p, sz);
@


1.16
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.15 2014/01/05 21:02:43 schwarze Exp $ */
d29 1
a29 1
static	int		 getdata(struct tbl_node *, struct tbl_span *, 
d31 1
a31 1
static	struct tbl_span	*newspan(struct tbl_node *, int, 
d34 1
d36 1
a36 1
getdata(struct tbl_node *tbl, struct tbl_span *dp, 
d49 1
a49 1
	/* 
d63 2
a64 2
		mandoc_msg(MANDOCERR_TBLEXTRADAT, 
				tbl->parse, ln, *pos, NULL);
d82 1
a82 1
	
d127 2
a128 2
			TBL_CELL_DHORIZ == dat->layout->pos ||
			TBL_CELL_DOWN == dat->layout->pos)
d130 2
a131 2
			mandoc_msg(MANDOCERR_TBLIGNDATA, 
					tbl->parse, ln, sv, NULL);
a135 1
/* ARGSUSED */
d140 1
a140 1
	size_t	 	 sz;
d171 3
a173 3
	if (TBL_CELL_DOWN == dat->layout->pos) 
		mandoc_msg(MANDOCERR_TBLIGNDATA, 
				tbl->parse, ln, pos, NULL);
d215 1
a215 1
	/* 
d229 1
a229 1
				case (TBL_CELL_HORIZ):
d233 1
a233 1
				case (TBL_CELL_DHORIZ):
@


1.15
log
@Merge NetBSD rev. 1.4:
Rename static function data() to getdata()
to work around bugs in the NetBSD PPC64 toolchain.
Original author of the patch: Christos Zoulas <christos@@NetBSD>.
Received via Joerg Sonnenberger <joerg@@NetBSD>.
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.14 2013/06/01 04:56:41 schwarze Exp $ */
d25 1
@


1.14
log
@If a table contained at least one complete line
and on its last line, the first T{ remained unclosed,
roff_parseln() never returned ROFF_TBL for that last line,
so {man,mdoc}_addspan() never got called for that last line,
so we ended up with a table
where no line associated with a node had TBL_SPAN_LAST set,
so tbl_term() never free()'d the cols in struct roffcol,
so tblcalc() crashed on the NULL == tbl->cols assertion
when starting the *next* table in the same file.

Fix this by returning ROFF_TBL as soon as we open a data cell,
not only when finishing it - as explained above, it may never
get properly closed but instead be interrupted by .TE.

Problem reported by bentley@@ in latex2man.1.

I love it when bugs take half a day to debug but
the fix turns out to be flipping one single bit in the source code.
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.13 2013/05/31 21:37:09 schwarze Exp $ */
d28 1
a28 1
static	int		 data(struct tbl_node *, struct tbl_span *, 
d34 1
a34 1
data(struct tbl_node *tbl, struct tbl_span *dp, 
d151 1
a151 1
			return(data(tbl, tbl->last_span, ln, p, &pos));
d266 1
a266 1
		if ( ! data(tbl, dp, ln, p, &pos))
@


1.13
log
@The name "struct tbl" was badly misleading for two reasons:
1) This struct almost exclusively contains the table options.
2) Information about the table as a whole is actually in "struct tbl_node".
Besides, "struct tbl" was almost impossible to search for.
So rename it to "struct tbl_opts".  No functional change.
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.12 2012/05/26 20:03:34 schwarze Exp $ */
d101 1
a101 1
		return(0);
@


1.12
log
@Do not handle vertical lines as additional tbl(7) columns,
instead save their properties with the following column.
This simplifies layout parsing and saves a lot of code
related to column handling.

At output time, print all white space and vertical lines
separating columns before printing the following column,
and none after printing the preceding column, considerably
simplifying white space handling and width calculations.

No functional change, but it saves 150 lines of code,
and it allows the next patch to tbl_term.c, tbl_literal().
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.11 2011/04/24 16:22:02 schwarze Exp $ */
d184 1
a184 1
	dp->tbl = &tbl->opts;
@


1.11
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.10 2011/04/21 22:59:54 schwarze Exp $ */
d48 1
a48 1
	 * Skip over spanners and vertical lines to data formats, since
d52 1
a52 3
	while (cp && (TBL_CELL_VERT == cp->pos || 
				TBL_CELL_DVERT == cp->pos ||
				TBL_CELL_SPAN == cp->pos))
@


1.10
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.9 2011/02/10 00:06:30 schwarze Exp $ */
d63 2
a64 1
		TBL_MSG(tbl, MANDOCERR_TBLEXTRADAT, ln, *pos);
d130 2
a131 1
			TBL_MSG(tbl, MANDOCERR_TBLIGNDATA, ln, sv);
d173 2
a174 1
		TBL_MSG(tbl, MANDOCERR_TBLIGNDATA, ln, pos);
d212 1
a212 1
		TBL_MSG(tbl, MANDOCERR_TBL, ln, pos);
@


1.9
log
@Tbl code maintenance by kristaps@@.
- Remember the line-number of a tbl_span, and use it in messages.
- Put *_span_alloc() functions right into the *_addspan() ones,
  since these are the only places they are called from.
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.8 2011/01/25 12:24:26 schwarze Exp $ */
d105 4
a108 2
	dat->string = mandoc_malloc(*pos - sv + 1);
	memcpy(dat->string, &p[sv], *pos - sv);
@


1.8
log
@Since tbl_data() can now produce multiple spans, let parsebuf()
generate man(7) or mdoc(7) nodes for all these spans,
not only for the last one.
Restores the horizontal lines in the cpu(4/hppa) tables.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.7 2011/01/25 12:16:19 schwarze Exp $ */
d28 4
a31 4
static	int	data(struct tbl_node *, struct tbl_span *, 
			int, const char *, int *);
static	struct tbl_span	*newspan(struct tbl_node *, struct tbl_row *);

d175 1
a175 1
newspan(struct tbl_node *tbl, struct tbl_row *rp)
d180 1
d226 1
a226 1
					dp = newspan(tbl, rp);
d230 1
a230 1
					dp = newspan(tbl, rp);
d248 1
a248 1
	dp = newspan(tbl, rp);
@


1.7
log
@Do not skip data after horizontal lines in the layout.
Instead, let one line of input data add two new spans
to the tbl tree during one single call of tbl_data().
Note that this causes the horizontal line to get parsed
into the tbl tree, but not yet used in the output,
which will be fixed next.
Avoids data loss in cpu(4/hppa).
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.6 2011/01/16 01:11:50 schwarze Exp $ */
d189 1
@


1.6
log
@Various tbl improvements from kristaps@@:
* horizontal lines do not consume layout lines
* skip excessive data cells
* prepare rendering of spanned cells
* support vertical spans
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.5 2011/01/09 14:30:48 schwarze Exp $ */
d4 1
d30 2
d174 21
d219 18
a236 3
		if (tbl->last_span->pos == TBL_SPAN_DATA)
			rp = tbl->last_span->layout->next;
		else
d246 1
a246 12
	dp = mandoc_calloc(1, sizeof(struct tbl_span));
	dp->tbl = &tbl->opts;
	dp->layout = rp;
	dp->head = tbl->first_head;

	if (tbl->last_span) {
		tbl->last_span->next = dp;
		tbl->last_span = dp;
	} else {
		tbl->last_span = tbl->first_span = dp;
		dp->flags |= TBL_SPAN_FIRST;
	}
@


1.5
log
@Sync tbl handling to bsd.lv release 1.10.9:
* .T} can be followed by a delimiter, then more data.
* Do not limit table column widths (improves terminfo(5)).
* Let numerical cells respect explicitly specified minimum cell widths.
* Let terminal output survive missing data cells.
* Parse and ignore arguments in parentheses on layout cell specifications.
* Move tbl_calc() into out.c such that it can be used by all frontends.
* Give tables an HTML class.
* Some cleanup in tbl -Thtml code.
All code by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.4 2011/01/04 22:28:17 schwarze Exp $ */
d36 1
a36 1
	int		 sv;
d54 13
d71 9
a79 2
	if (NULL == dat->layout)
		TBL_MSG(tbl, MANDOCERR_TBLEXTRADAT, ln, *pos);
a119 3
	if (NULL == dat->layout)
		return(1);

d121 2
a122 1
			TBL_CELL_DHORIZ == dat->layout->pos)
a139 1
	dat->pos = TBL_DATA_DATA;
d155 2
d165 3
d188 3
a190 2
	 * If there's no last parsed span, use the first row.  This can
	 * be NULL!
d195 5
a199 1
		rp = tbl->last_span->layout->next;
d204 2
@


1.4
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.1 2010/12/29 16:44:23 kristaps Exp $ */
d44 4
a47 1
	/* Skip over spanners to data formats. */
d50 2
a51 1
				TBL_CELL_DVERT == cp->pos))
d111 1
d117 1
d119 1
a119 4
	if (0 == strcmp(p, "T}")) {
		tbl->part = TBL_PART_DATA;
		return(1);
	}
d123 14
@


1.3
log
@Allow blank lines and ignore comments in tbl data.
This finally allows terminfo(5) to build.
Now we can build all man(7)-tbl(1) in base without loss of information,
though some still look ugly.
@
text
@d1 1
a1 1
/*	$Id: tbl_data.c,v 1.2 2010/10/15 21:33:47 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2009 Kristaps Dzonsons <kristaps@@kth.se>
a16 3
#include <sys/queue.h>
#include <sys/types.h>

d21 1
d23 10
a32 15
#include "out.h"
#include "term.h"
#include "tbl_extern.h"

/* FIXME: warn about losing data contents if cell is HORIZ. */

static	int		data(struct tbl *, struct tbl_span *, 
				const char *, int, int, 
				const char *, int, int);


int
data(struct tbl *tbl, struct tbl_span *dp, 
		const char *f, int ln, int pos, 
		const char *p, int start, int end)
d34 38
a71 1
	struct tbl_data	*dat;
d73 2
a74 1
	if (NULL == (dat = tbl_data_alloc(dp)))
d76 1
d78 3
a80 10
	if (NULL == dat->cell)
		if ( ! tbl_warnx(tbl, ERR_SYNTAX, f, ln, pos))
			return(0);

	assert(end >= start);
	if (NULL == (dat->string = malloc((size_t)(end - start + 1))))
		return(tbl_err(tbl));

	(void)memcpy(dat->string, &p[start], (size_t)(end - start));
	dat->string[end - start] = 0;
d82 2
a83 1
	/* XXX: do the strcmps, then malloc(). */
d86 1
a86 1
		dat->flags |= TBL_DATA_HORIZ;
d88 1
a88 1
		dat->flags |= TBL_DATA_DHORIZ;
d90 1
a90 1
		dat->flags |= TBL_DATA_NHORIZ;
d92 1
a92 1
		dat->flags |= TBL_DATA_NDHORIZ;
d94 3
d99 5
a103 2
	free(dat->string);
	dat->string = NULL;
d107 24
d133 1
a133 1
tbl_data(struct tbl *tbl, const char *f, int ln, const char *p)
d136 4
a139 1
	int		 i, j;
d141 3
a143 11
	if ('.' == p[0] && ! isdigit((u_char)p[1])) {
		/* Comment lines end up here with just a dot. */
		if ('\0' == p[1])
			return(1);
		/*
		 * XXX: departs from tbl convention in that we disallow
		 * macros in the data body.
		 */
		if (strncasecmp(p, ".T&", 3)) 
			return(tbl_errx(tbl, ERR_SYNTAX, f, ln, 0));
		return(tbl_data_close(tbl, f, ln));
d146 27
a172 2
	if (NULL == (dp = tbl_span_alloc(tbl)))
		return(0);
d175 1
a175 1
		dp->flags |= TBL_SPAN_HORIZ;
d178 1
a178 1
		dp->flags |= TBL_SPAN_DHORIZ;
d182 1
a182 10
	for (j = i = 0; p[i]; i++) {
		if (p[i] != tbl->tab)
			continue;
		if ( ! data(tbl, dp, f, ln, i, p, j, i))
			return(0);
		j = i + 1;
	}

	return(data(tbl, dp, f, ln, i, p, j, i));
}
d184 1
d186 3
a188 11
int
tbl_data_close(struct tbl *tbl, const char *f, int ln)
{
	struct tbl_span	*span;

	/* LINTED */
	span = TAILQ_LAST(&tbl->span, tbl_spanh);
	if (NULL == span)
		return(tbl_errx(tbl, ERR_SYNTAX, f, ln, 0));
	if (TAILQ_NEXT(span->row, entries))
		return(tbl_errx(tbl, ERR_SYNTAX, f, ln, 0));
a189 1
	tbl->part = TBL_PART_LAYOUT;
@


1.2
log
@Move tbl output from plain stdio to mandoc terminal output routines.
This fixes (1) all escape sequences and (2) some aspects of indentation.
Table column widths are still way off, though.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$Id: data.c,v 1.11 2009/09/12 16:05:34 kristaps Exp $ */
a81 3
	if (0 == p[0])
		return(tbl_errx(tbl, ERR_SYNTAX, f, ln, 0));

d83 3
@


1.1
log
@Import tbl parser and renderer written by kristaps@@.
Unchanged code from bsd.lv release 0.1.5, but without the main program.
Not yet linked to the build; next commit will integrate it into mandoc.
@
text
@d25 2
@

