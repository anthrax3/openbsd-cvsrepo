head	1.124;
access;
symbols
	OPENBSD_6_2_BASE:1.124
	OPENBSD_6_1:1.116.0.4
	OPENBSD_6_1_BASE:1.116
	OPENBSD_6_0:1.114.0.4
	OPENBSD_6_0_BASE:1.114
	OPENBSD_5_9:1.114.0.2
	OPENBSD_5_9_BASE:1.114
	OPENBSD_5_8:1.111.0.4
	OPENBSD_5_8_BASE:1.111
	OPENBSD_5_7:1.97.0.2
	OPENBSD_5_7_BASE:1.97
	OPENBSD_5_6:1.83.0.4
	OPENBSD_5_6_BASE:1.83
	OPENBSD_5_5:1.74.0.4
	OPENBSD_5_5_BASE:1.74
	OPENBSD_5_4:1.69.0.4
	OPENBSD_5_4_BASE:1.69
	OPENBSD_5_3:1.69.0.2
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.68.0.2
	OPENBSD_5_2_BASE:1.68
	OPENBSD_5_1_BASE:1.64
	OPENBSD_5_1:1.64.0.2
	OPENBSD_5_0:1.59.0.2
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.55.0.2
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.124
date	2017.06.28.12.52.27;	author schwarze;	state Exp;
branches;
next	1.123;
commitid	tNKg4aNsFbU9Kz0q;

1.123
date	2017.06.17.13.05.47;	author schwarze;	state Exp;
branches;
next	1.122;
commitid	Ex4Q2DsetOpdg5C3;

1.122
date	2017.06.03.15.54.09;	author schwarze;	state Exp;
branches;
next	1.121;
commitid	iOor4zVcyUusVswq;

1.121
date	2017.05.08.20.33.40;	author schwarze;	state Exp;
branches;
next	1.120;
commitid	W079BW3GQUdhvqNr;

1.120
date	2017.05.05.15.16.25;	author schwarze;	state Exp;
branches;
next	1.119;
commitid	sNJdFUhzoVfGBx2p;

1.119
date	2017.05.01.23.27.23;	author schwarze;	state Exp;
branches;
next	1.118;
commitid	rlVFodbMWqF96jF6;

1.118
date	2017.04.29.12.43.55;	author schwarze;	state Exp;
branches;
next	1.117;
commitid	7BLUwozNEzUO8xfK;

1.117
date	2017.04.24.23.06.09;	author schwarze;	state Exp;
branches;
next	1.116;
commitid	2CfzvK3gmiJH7vY0;

1.116
date	2017.03.03.13.55.06;	author schwarze;	state Exp;
branches;
next	1.115;
commitid	ebZHhO3JQ20kqPTN;

1.115
date	2017.01.10.13.46.53;	author schwarze;	state Exp;
branches;
next	1.114;
commitid	aFt8sLe7F06PjFYh;

1.114
date	2015.10.22.21.53.49;	author schwarze;	state Exp;
branches;
next	1.113;
commitid	b31415iHGGouYvkz;

1.113
date	2015.10.06.18.30.43;	author schwarze;	state Exp;
branches;
next	1.112;
commitid	hxQV8O1pNUaef4ir;

1.112
date	2015.09.04.21.24.26;	author schwarze;	state Exp;
branches;
next	1.111;
commitid	5A7G7hHFPv2H6xHL;

1.111
date	2015.04.23.16.17.04;	author schwarze;	state Exp;
branches;
next	1.110;
commitid	DWHgiJTn6DvDpekX;

1.110
date	2015.04.23.15.35.39;	author schwarze;	state Exp;
branches;
next	1.109;
commitid	am2zU0fu81iRKMOO;

1.109
date	2015.04.19.14.57.16;	author schwarze;	state Exp;
branches;
next	1.108;
commitid	FaoA4UzPphKw0cyB;

1.108
date	2015.04.19.14.25.05;	author schwarze;	state Exp;
branches;
next	1.107;
commitid	E1gJfKuheBoo64Vb;

1.107
date	2015.04.19.13.59.37;	author schwarze;	state Exp;
branches;
next	1.106;
commitid	aS3h5dIgZk0f7675;

1.106
date	2015.04.19.13.50.10;	author schwarze;	state Exp;
branches;
next	1.105;
commitid	QSaLMe5iBgPB4hUe;

1.105
date	2015.04.18.17.50.02;	author schwarze;	state Exp;
branches;
next	1.104;
commitid	sjmmdLSx1e3Vat0h;

1.104
date	2015.04.18.17.28.08;	author schwarze;	state Exp;
branches;
next	1.103;
commitid	zD52rmYwzwgofy8v;

1.103
date	2015.04.18.17.01.28;	author schwarze;	state Exp;
branches;
next	1.102;
commitid	GslLZJxifCkaUipL;

1.102
date	2015.04.18.16.34.03;	author schwarze;	state Exp;
branches;
next	1.101;
commitid	PxhkeHVIvdTMOTs6;

1.101
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.100;
commitid	6MYJ7cd8mhJ77AGH;

1.100
date	2015.04.02.23.47.43;	author schwarze;	state Exp;
branches;
next	1.99;
commitid	RJFkOLiS9gBqEEDl;

1.99
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.98;
commitid	Rfx1oTaH3hZ7Zcyf;

1.98
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.97;
commitid	lmErjWY2O9ooA6RY;

1.97
date	2015.01.30.21.28.21;	author schwarze;	state Exp;
branches;
next	1.96;
commitid	klhLXGjLVr5oVTkR;

1.96
date	2015.01.24.02.41.32;	author schwarze;	state Exp;
branches;
next	1.95;
commitid	TIJT04XdY4be3Or5;

1.95
date	2015.01.15.04.26.06;	author schwarze;	state Exp;
branches;
next	1.94;
commitid	TgtfgXU8Rz8XgmeH;

1.94
date	2014.12.28.14.39.08;	author schwarze;	state Exp;
branches;
next	1.93;
commitid	6ZLiZAxCS3hyLbh4;

1.93
date	2014.11.28.06.26.46;	author schwarze;	state Exp;
branches;
next	1.92;
commitid	M5K1YnX7vRaFkPkc;

1.92
date	2014.11.28.05.51.29;	author schwarze;	state Exp;
branches;
next	1.91;
commitid	9LYX9vvoCC2fp5xR;

1.91
date	2014.11.19.03.07.43;	author schwarze;	state Exp;
branches;
next	1.90;
commitid	DMACP9kwk2BHECLD;

1.90
date	2014.11.03.23.17.21;	author schwarze;	state Exp;
branches;
next	1.89;
commitid	GfJl4B0PeEJVZTrN;

1.89
date	2014.10.20.15.49.45;	author schwarze;	state Exp;
branches;
next	1.88;
commitid	xAL9AbgdIC6Bgc5x;

1.88
date	2014.10.20.02.31.44;	author schwarze;	state Exp;
branches;
next	1.87;
commitid	jVScYQL5VkcOk52z;

1.87
date	2014.09.06.23.24.27;	author schwarze;	state Exp;
branches;
next	1.86;
commitid	cVS8Yl9euSk9Ay5F;

1.86
date	2014.08.08.16.05.42;	author schwarze;	state Exp;
branches;
next	1.85;
commitid	2htU5KIJbrO78Dan;

1.85
date	2014.08.08.15.54.10;	author schwarze;	state Exp;
branches;
next	1.84;
commitid	yBKHNskikm52fHMo;

1.84
date	2014.08.08.15.32.17;	author schwarze;	state Exp;
branches;
next	1.83;
commitid	MxwVmw5souguneqK;

1.83
date	2014.07.07.21.35.42;	author schwarze;	state Exp;
branches;
next	1.82;
commitid	O2S43bw50KTGcriR;

1.82
date	2014.07.07.19.17.39;	author schwarze;	state Exp;
branches;
next	1.81;
commitid	6LLMrl8zsEJSgCUt;

1.81
date	2014.07.06.19.08.56;	author schwarze;	state Exp;
branches;
next	1.80;
commitid	rolX8OitNNoUBJoD;

1.80
date	2014.05.07.14.11.24;	author schwarze;	state Exp;
branches;
next	1.79;

1.79
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.78;

1.78
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.77;

1.77
date	2014.03.23.20.57.23;	author schwarze;	state Exp;
branches;
next	1.76;

1.76
date	2014.03.22.00.56.07;	author schwarze;	state Exp;
branches;
next	1.75;

1.75
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.74;

1.74
date	2014.01.06.00.53.14;	author schwarze;	state Exp;
branches;
next	1.73;

1.73
date	2014.01.05.20.26.27;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2013.12.30.00.52.18;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2013.11.10.22.53.58;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2013.10.17.20.51.28;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2012.11.17.00.25.20;	author schwarze;	state Exp;
branches;
next	1.68;

1.68
date	2012.07.14.10.43.48;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2012.07.07.18.27.36;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2012.06.02.20.07.09;	author schwarze;	state Exp;
branches;
next	1.65;

1.65
date	2012.02.26.19.41.27;	author schwarze;	state Exp;
branches;
next	1.64;

1.64
date	2011.11.16.17.21.15;	author schwarze;	state Exp;
branches;
next	1.63;

1.63
date	2011.11.05.16.02.18;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2011.10.09.17.59.56;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2011.03.20.23.36.42;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2011.03.07.01.35.33;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2011.02.10.00.06.30;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2011.01.16.02.56.47;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2011.01.09.13.16.48;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2011.01.01.17.38.11;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2010.12.19.07.53.12;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2010.12.07.00.08.52;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2010.12.01.23.02.59;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2010.11.29.02.26.45;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2010.11.29.01.44.41;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2010.11.29.00.12.02;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2010.11.28.19.35.33;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2010.10.16.20.49.37;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2010.10.15.21.33.47;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2010.10.15.20.45.03;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2010.08.20.00.53.35;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2010.08.18.01.17.44;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.16.00.34.33;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.27.21.54.42;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.06.18.08.41;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.23.22.45.00;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2010.05.23.20.57.16;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.20.00.58.02;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.16.00.54.03;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.15.18.06.02;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.14.19.52.43;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.14.01.54.37;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2010.05.08.01.52.07;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2010.04.25.16.32.19;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.02.11.37.07;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2010.03.29.22.56.52;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2010.03.26.01.22.05;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2010.03.25.23.23.01;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2010.03.02.01.00.39;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2010.02.26.12.42.29;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2010.02.18.02.11.26;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.23.22.30.17;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.19.10.20.24;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.21.21.11.37;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.18.22.46.14;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.18.22.37.05;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.22.23.17.39;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2009.08.22.20.14.37;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.22.15.15.37;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.12.20.30.27;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.07.00.54.46;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.23.22.31.26;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.23.22.05.42;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.18.23.34.53;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.14.23.00.57;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.20.30.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.124
log
@fix incomplete handling of roff(7) nodes in man(7) block next-line scope;
assertion failure in tclsh(1) reported by deraadt@@ via bentley@@
@
text
@/*	$OpenBSD: man.c,v 1.123 2017/06/17 13:05:47 schwarze Exp $ */
/*
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2013, 2014, 2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 * Copyright (c) 2011 Joerg Sonnenberger <joerg@@netbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "man.h"
#include "libmandoc.h"
#include "roff_int.h"
#include "libman.h"

static	void		 man_descope(struct roff_man *, int, int);
static	int		 man_ptext(struct roff_man *, int, char *, int);
static	int		 man_pmacro(struct roff_man *, int, char *, int);


int
man_parseln(struct roff_man *man, int ln, char *buf, int offs)
{

	if (man->last->type != ROFFT_EQN || ln > man->last->line)
		man->flags |= MAN_NEWLINE;

	return roff_getcontrol(man->roff, buf, &offs) ?
	    man_pmacro(man, ln, buf, offs) :
	    man_ptext(man, ln, buf, offs);
}

static void
man_descope(struct roff_man *man, int line, int offs)
{
	/*
	 * Co-ordinate what happens with having a next-line scope open:
	 * first close out the element scope (if applicable), then close
	 * out the block scope (also if applicable).
	 */

	if (man->flags & MAN_ELINE) {
		man->flags &= ~MAN_ELINE;
		man_unscope(man, man->last->parent);
	}
	if ( ! (man->flags & MAN_BLINE))
		return;
	man->flags &= ~MAN_BLINE;
	man_unscope(man, man->last->parent);
	roff_body_alloc(man, line, offs, man->last->tok);
}

static int
man_ptext(struct roff_man *man, int line, char *buf, int offs)
{
	int		 i;
	const char 	*cp, *sp;
	char		*ep;

	/* Literal free-form text whitespace is preserved. */

	if (man->flags & MAN_LITERAL) {
		roff_word_alloc(man, line, offs, buf + offs);
		man_descope(man, line, offs);
		return 1;
	}

	for (i = offs; buf[i] == ' '; i++)
		/* Skip leading whitespace. */ ;

	/*
	 * Blank lines are ignored in next line scope
	 * and right after headings and cancel preceding \c,
	 * but add a single vertical space elsewhere.
	 */

	if (buf[i] == '\0') {
		if (man->flags & (MAN_ELINE | MAN_BLINE)) {
			mandoc_msg(MANDOCERR_BLK_BLANK, man->parse,
			    line, 0, NULL);
			return 1;
		}
		if (man->last->tok == MAN_SH || man->last->tok == MAN_SS)
			return 1;
		switch (man->last->type) {
		case ROFFT_TEXT:
			sp = man->last->string;
			cp = ep = strchr(sp, '\0') - 2;
			if (cp < sp || cp[0] != '\\' || cp[1] != 'c')
				break;
			while (cp > sp && cp[-1] == '\\')
				cp--;
			if ((ep - cp) % 2)
				break;
			*ep = '\0';
			return 1;
		default:
			break;
		}
		roff_elem_alloc(man, line, offs, ROFF_sp);
		man->next = ROFF_NEXT_SIBLING;
		return 1;
	}

	/*
	 * Warn if the last un-escaped character is whitespace. Then
	 * strip away the remaining spaces (tabs stay!).
	 */

	i = (int)strlen(buf);
	assert(i);

	if (' ' == buf[i - 1] || '\t' == buf[i - 1]) {
		if (i > 1 && '\\' != buf[i - 2])
			mandoc_msg(MANDOCERR_SPACE_EOL, man->parse,
			    line, i - 1, NULL);

		for (--i; i && ' ' == buf[i]; i--)
			/* Spin back to non-space. */ ;

		/* Jump ahead of escaped whitespace. */
		i += '\\' == buf[i] ? 2 : 1;

		buf[i] = '\0';
	}
	roff_word_alloc(man, line, offs, buf + offs);

	/*
	 * End-of-sentence check.  If the last character is an unescaped
	 * EOS character, then flag the node as being the end of a
	 * sentence.  The front-end will know how to interpret this.
	 */

	assert(i);
	if (mandoc_eos(buf, (size_t)i))
		man->last->flags |= NODE_EOS;

	man_descope(man, line, offs);
	return 1;
}

static int
man_pmacro(struct roff_man *man, int ln, char *buf, int offs)
{
	struct roff_node *n;
	const char	*cp;
	size_t		 sz;
	enum roff_tok	 tok;
	int		 ppos;
	int		 bline;

	/* Determine the line macro. */

	ppos = offs;
	tok = TOKEN_NONE;
	for (sz = 0; sz < 4 && strchr(" \t\\", buf[offs]) == NULL; sz++)
		offs++;
	if (sz > 0 && sz < 4)
		tok = roffhash_find(man->manmac, buf + ppos, sz);
	if (tok == TOKEN_NONE) {
		mandoc_msg(MANDOCERR_MACRO, man->parse,
		    ln, ppos, buf + ppos - 1);
		return 1;
	}

	/* Skip a leading escape sequence or tab. */

	switch (buf[offs]) {
	case '\\':
		cp = buf + offs + 1;
		mandoc_escape(&cp, NULL, NULL);
		offs = cp - buf;
		break;
	case '\t':
		offs++;
		break;
	default:
		break;
	}

	/* Jump to the next non-whitespace word. */

	while (buf[offs] == ' ')
		offs++;

	/*
	 * Trailing whitespace.  Note that tabs are allowed to be passed
	 * into the parser as "text", so we only warn about spaces here.
	 */

	if (buf[offs] == '\0' && buf[offs - 1] == ' ')
		mandoc_msg(MANDOCERR_SPACE_EOL, man->parse,
		    ln, offs - 1, NULL);

	/*
	 * Some macros break next-line scopes; otherwise, remember
	 * whether we are in next-line scope for a block head.
	 */

	man_breakscope(man, tok);
	bline = man->flags & MAN_BLINE;

	/*
	 * If the line in next-line scope ends with \c, keep the
	 * next-line scope open for the subsequent input line.
	 * That is not at all portable, only groff >= 1.22.4
	 * does it, but *if* this weird idiom occurs in a manual
	 * page, that's very likely what the author intended.
	 */

	if (bline) {
		cp = strchr(buf + offs, '\0') - 2;
		if (cp >= buf && cp[0] == '\\' && cp[1] == 'c')
			bline = 0;
	}

	/* Call to handler... */

	assert(man_macros[tok].fp);
	(*man_macros[tok].fp)(man, tok, ln, ppos, &offs, buf);

	/* In quick mode (for mandocdb), abort after the NAME section. */

	if (man->quick && tok == MAN_SH) {
		n = man->last;
		if (n->type == ROFFT_BODY &&
		    strcmp(n->prev->child->string, "NAME"))
			return 2;
	}

	/*
	 * If we are in a next-line scope for a block head,
	 * close it out now and switch to the body,
	 * unless the next-line scope is allowed to continue.
	 */

	if ( ! bline || man->flags & MAN_ELINE ||
	    man_macros[tok].flags & MAN_NSCOPED)
		return 1;

	assert(man->flags & MAN_BLINE);
	man->flags &= ~MAN_BLINE;

	man_unscope(man, man->last->parent);
	roff_body_alloc(man, ln, ppos, man->last->tok);
	return 1;
}

void
man_breakscope(struct roff_man *man, int tok)
{
	struct roff_node *n;

	/*
	 * An element next line scope is open,
	 * and the new macro is not allowed inside elements.
	 * Delete the element that is being broken.
	 */

	if (man->flags & MAN_ELINE && (tok < MAN_TH ||
	    ! (man_macros[tok].flags & MAN_NSCOPED))) {
		n = man->last;
		if (n->type == ROFFT_TEXT)
			n = n->parent;
		if (n->tok < MAN_TH ||
		    man_macros[n->tok].flags & MAN_NSCOPED)
			n = n->parent;

		mandoc_vmsg(MANDOCERR_BLK_LINE, man->parse,
		    n->line, n->pos, "%s breaks %s",
		    roff_name[tok], roff_name[n->tok]);

		roff_node_delete(man, n);
		man->flags &= ~MAN_ELINE;
	}

	/*
	 * Weird special case:
	 * Switching fill mode closes section headers.
	 */

	if (man->flags & MAN_BLINE &&
	    (tok == MAN_nf || tok == MAN_fi) &&
	    (man->last->tok == MAN_SH || man->last->tok == MAN_SS)) {
		n = man->last;
		man_unscope(man, n);
		roff_body_alloc(man, n->line, n->pos, n->tok);
		man->flags &= ~MAN_BLINE;
	}

	/*
	 * A block header next line scope is open,
	 * and the new macro is not allowed inside block headers.
	 * Delete the block that is being broken.
	 */

	if (man->flags & MAN_BLINE && (tok < MAN_TH ||
	    man_macros[tok].flags & MAN_BSCOPE)) {
		n = man->last;
		if (n->type == ROFFT_TEXT)
			n = n->parent;
		if (n->tok < MAN_TH ||
		    (man_macros[n->tok].flags & MAN_BSCOPE) == 0)
			n = n->parent;

		assert(n->type == ROFFT_HEAD);
		n = n->parent;
		assert(n->type == ROFFT_BLOCK);
		assert(man_macros[n->tok].flags & MAN_SCOPED);

		mandoc_vmsg(MANDOCERR_BLK_LINE, man->parse,
		    n->line, n->pos, "%s breaks %s",
		    roff_name[tok], roff_name[n->tok]);

		roff_node_delete(man, n);
		man->flags &= ~MAN_BLINE;
	}
}

const struct mparse *
man_mparse(const struct roff_man *man)
{

	assert(man && man->parse);
	return man->parse;
}

void
man_state(struct roff_man *man, struct roff_node *n)
{

	switch(n->tok) {
	case MAN_nf:
	case MAN_EX:
		if (man->flags & MAN_LITERAL && ! (n->flags & NODE_VALID))
			mandoc_msg(MANDOCERR_NF_SKIP, man->parse,
			    n->line, n->pos, "nf");
		man->flags |= MAN_LITERAL;
		break;
	case MAN_fi:
	case MAN_EE:
		if ( ! (man->flags & MAN_LITERAL) &&
		     ! (n->flags & NODE_VALID))
			mandoc_msg(MANDOCERR_FI_SKIP, man->parse,
			    n->line, n->pos, "fi");
		man->flags &= ~MAN_LITERAL;
		break;
	default:
		break;
	}
	man->last->flags |= NODE_VALID;
}

void
man_validate(struct roff_man *man)
{

	man->last = man->first;
	man_node_validate(man);
	man->flags &= ~MAN_LITERAL;
}
@


1.123
log
@correct handling of blank lines after \c
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.122 2017/06/03 15:54:09 schwarze Exp $ */
d283 4
a286 2
		assert(n->type != ROFFT_TEXT);
		if (man_macros[n->tok].flags & MAN_NSCOPED)
d322 2
a323 1
		if ( ! (man_macros[n->tok].flags & MAN_BSCOPE))
@


1.122
log
@ignore blank lines in man(7) next line scope;
strange groff edge case behaviour found in multimedia/mjpegtools
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.121 2017/05/08 20:33:40 schwarze Exp $ */
d77 2
d92 3
a94 2
	 * Blank lines are ignored in next line scope and right
	 * after headings but add a single vertical space elsewhere.
d98 1
a98 1
		if (man->flags & (MAN_ELINE | MAN_BLINE))
d101 1
a101 4
		else if (man->last->tok != MAN_SH &&
		    man->last->tok != MAN_SS) {
			roff_elem_alloc(man, line, offs, ROFF_sp);
			man->next = ROFF_NEXT_SIBLING;
d103 19
@


1.121
log
@Line-breaking roff(7) requests also break man(7) next-line scope.
Considering that real roff implements next-line scope using input
line traps, that isn't all that surprising.
Issue found in the games/xbattle port.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.120 2017/05/05 15:16:25 schwarze Exp $ */
d90 2
a91 2
	 * Blank lines are ignored right after headings
	 * but add a single vertical space elsewhere.
d95 4
a98 3
		man_breakscope(man, ROFF_sp);
		/* Allocate a blank entry. */
		if (man->last->tok != MAN_SH &&
@


1.120
log
@Move .sp to the roff modules.  Enough infrastructure is in place
now that this actually saves code: -70 LOC.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.119 2017/05/01 23:27:23 schwarze Exp $ */
d95 1
d260 1
a260 1
	if (man->flags & MAN_ELINE && (tok == TOKEN_NONE ||
d269 1
a269 2
		    tok == TOKEN_NONE ? "TS" : roff_name[tok],
		    roff_name[n->tok]);
d295 1
a295 1
	if (man->flags & MAN_BLINE && (tok == TOKEN_NONE ||
d310 1
a310 2
		    tok == TOKEN_NONE ? "TS" : roff_name[tok],
		    roff_name[n->tok]);
@


1.119
log
@A few days ago, a patch from <G dot Branden dot Robinson at gmail dot com>
got committed to groff which changed .TP from using .it to using .itc,
such that groff now supports more than one man(7) macro line in the .TP
head if all but the last line in the head end with \c.

Of course, relying on that behaviour is utterly non-portable, but if
authors are reckless enough to use that idiom, let's do what they want.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.118 2017/04/29 12:43:55 schwarze Exp $ */
d98 1
a98 1
			roff_elem_alloc(man, line, offs, MAN_sp);
@


1.118
log
@Parser unification: use nice ohashes for all three request and macro tables;
no functional change, minus two source files, minus 200 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.117 2017/04/24 23:06:09 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
d201 14
@


1.117
log
@Continue parser unification:
* Make enum rofft an internal interface as enum roff_tok in "roff.h".
* Represent mdoc and man macros in enum roff_tok.
* Make TOKEN_NONE a proper enum value and use it throughout.
* Put the prologue macros first in the macro tables.
* Unify mdoc_macroname[] and man_macroname[] into roff_name[].
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.116 2017/03/03 13:55:06 schwarze Exp $ */
d146 3
a148 2
	int		 tok;
	int		 i, ppos;
d150 2
a151 1
	char		 mac[5];
d154 5
a158 14

	/*
	 * Copy the first word into a nil-terminated buffer.
	 * Stop when a space, tab, escape, or eoln is encountered.
	 */

	i = 0;
	while (i < 4 && strchr(" \t\\", buf[offs]) == NULL)
		mac[i++] = buf[offs++];

	mac[i] = '\0';

	tok = (i > 0 && i < 4) ? man_hash_find(mac) : TOKEN_NONE;

@


1.116
log
@remove a few redundant conditions that jsg@@ found with cppcheck
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.115 2017/01/10 13:46:53 schwarze Exp $ */
a35 15
const	char *const __man_macronames[MAN_MAX] = {
	"br",		"TH",		"SH",		"SS",
	"TP",		"LP",		"PP",		"P",
	"IP",		"HP",		"SM",		"SB",
	"BI",		"IB",		"BR",		"RB",
	"R",		"B",		"I",		"IR",
	"RI",		"sp",		"nf",
	"fi",		"RE",		"RS",		"DT",
	"UC",		"PD",		"AT",		"in",
	"ft",		"OP",		"EX",		"EE",
	"UR",		"UE",		"ll"
	};

const	char * const *man_macronames = __man_macronames;

d261 2
a262 2
		    tok == TOKEN_NONE ? "TS" : man_macronames[tok],
		    man_macronames[n->tok]);
d303 2
a304 2
		    tok == TOKEN_NONE ? "TS" : man_macronames[tok],
		    man_macronames[n->tok]);
@


1.115
log
@unify names of AST node flags; no change of cpp output
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.114 2015/10/22 21:53:49 schwarze Exp $ */
d204 1
a204 1
	while (buf[offs] && buf[offs] == ' ')
@


1.114
log
@move man(7) validation into the dedicated validation phase, too
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.113 2015/10/06 18:30:43 schwarze Exp $ */
d150 1
a150 1
		man->last->flags |= MAN_EOS;
d341 1
a341 1
		if (man->flags & MAN_LITERAL && ! (n->flags & MAN_VALID))
d349 1
a349 1
		     ! (n->flags & MAN_VALID))
d357 1
a357 1
	man->last->flags |= MAN_VALID;
@


1.113
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.112 2015/09/04 21:24:26 schwarze Exp $ */
d332 35
@


1.112
log
@Fill mode changes don't break next-line scope in all cases,
in particular not for tagged paragraphs.
Issue found by Christian Neukirchen <chneukirchen at gmail dot com>
in the exiv2(1) manual page.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.111 2015/04/23 16:17:04 schwarze Exp $ */
d63 1
a63 1
	return (roff_getcontrol(man->roff, buf, &offs) ?
d65 1
a65 1
	    man_ptext(man, ln, buf, offs));
d98 1
a98 1
		return(1);
d116 1
a116 1
		return(1);
d153 1
a153 1
	return(1);
d184 1
a184 1
		return(1);
d235 1
a235 1
			return(2);
d246 1
a246 1
		return(1);
d253 1
a253 1
	return(1);
d331 1
a331 1
	return(man->parse);
@


1.111
log
@Unify mdoc_deroff() and man_deroff() into a common function deroff().
No functional change except that for mdoc(7), it now skips leading
escape sequences just like it already did for man(7).
Escape sequences rarely occur in mdoc(7) code and if they do,
skipping them is an improvement in this context.
Minus 30 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.110 2015/04/23 15:35:39 schwarze Exp $ */
d281 14
@


1.110
log
@Get rid of two empty wrapper functions.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.109 2015/04/19 14:57:16 schwarze Exp $ */
a317 46
}

void
man_deroff(char **dest, const struct roff_node *n)
{
	char	*cp;
	size_t	 sz;

	if (n->type != ROFFT_TEXT) {
		for (n = n->child; n; n = n->next)
			man_deroff(dest, n);
		return;
	}

	/* Skip leading whitespace and escape sequences. */

	cp = n->string;
	while ('\0' != *cp) {
		if ('\\' == *cp) {
			cp++;
			mandoc_escape((const char **)&cp, NULL, NULL);
		} else if (isspace((unsigned char)*cp))
			cp++;
		else
			break;
	}

	/* Skip trailing whitespace. */

	for (sz = strlen(cp); sz; sz--)
		if (0 == isspace((unsigned char)cp[sz-1]))
			break;

	/* Skip empty strings. */

	if (0 == sz)
		return;

	if (NULL == *dest) {
		*dest = mandoc_strndup(cp, sz);
		return;
	}

	mandoc_asprintf(&cp, "%s %*s", *dest, (int)sz, cp);
	free(*dest);
	*dest = cp;
@


1.109
log
@Unify trickier node handling functions.
* man_elem_alloc() -> roff_elem_alloc()
* man_block_alloc() -> roff_block_alloc()
The functions mdoc_elem_alloc() and mdoc_block_alloc() remain for
now because they need to do mdoc(7)-specific argument processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.108 2015/04/19 14:25:05 schwarze Exp $ */
a54 7

void
man_endparse(struct roff_man *man)
{

	man_macroend(man);
}
@


1.108
log
@Unify some node handling functions that use TOKEN_NONE.
* mdoc_word_alloc(), man_word_alloc() -> roff_word_alloc()
* mdoc_word_append(), man_word_append() -> roff_word_append()
* mdoc_addspan(), man_addspan() -> roff_addtbl()
* mdoc_addeqn(), man_addeqn() -> roff_addeqn()
Minus 50 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.107 2015/04/19 13:59:37 schwarze Exp $ */
a74 20
void
man_elem_alloc(struct roff_man *man, int line, int pos, int tok)
{
	struct roff_node *p;

	p = roff_node_alloc(man, line, pos, ROFFT_ELEM, tok);
	roff_node_append(man, p);
	man->next = ROFF_NEXT_CHILD;
}

void
man_block_alloc(struct roff_man *man, int line, int pos, int tok)
{
	struct roff_node *p;

	p = roff_node_alloc(man, line, pos, ROFFT_BLOCK, tok);
	roff_node_append(man, p);
	man->next = ROFF_NEXT_CHILD;
}

d120 1
a120 1
			man_elem_alloc(man, line, offs, MAN_sp);
@


1.107
log
@Decouple the token code for "no request or macro" from the individual
high-level parsers to allow further unification of functions that
only need to recognize this code, but that don't care about different
high-level macrosets beyond that.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.106 2015/04/19 13:50:10 schwarze Exp $ */
a50 1
static	void		 man_breakscope(struct roff_man *, int);
a94 55
void
man_word_alloc(struct roff_man *man, int line, int pos, const char *word)
{
	struct roff_node *n;

	n = roff_node_alloc(man, line, pos, ROFFT_TEXT, TOKEN_NONE);
	n->string = roff_strdup(man->roff, word);
	roff_node_append(man, n);
	man_valid_post(man);
	man->next = ROFF_NEXT_SIBLING;
}

void
man_word_append(struct roff_man *man, const char *word)
{
	struct roff_node *n;
	char		*addstr, *newstr;

	n = man->last;
	addstr = roff_strdup(man->roff, word);
	mandoc_asprintf(&newstr, "%s %s", n->string, addstr);
	free(addstr);
	free(n->string);
	n->string = newstr;
	man->next = ROFF_NEXT_SIBLING;
}

void
man_addeqn(struct roff_man *man, const struct eqn *ep)
{
	struct roff_node *n;

	n = roff_node_alloc(man, ep->ln, ep->pos, ROFFT_EQN, TOKEN_NONE);
	n->eqn = ep;
	if (ep->ln > man->last->line)
		n->flags |= MAN_LINE;
	roff_node_append(man, n);
	man->next = ROFF_NEXT_SIBLING;
	man_descope(man, ep->ln, ep->pos);
}

void
man_addspan(struct roff_man *man, const struct tbl_span *sp)
{
	struct roff_node *n;

	man_breakscope(man, TOKEN_NONE);
	n = roff_node_alloc(man, sp->line, 0, ROFFT_TBL, TOKEN_NONE);
	n->span = sp;
	roff_node_append(man, n);
	man_valid_post(man);
	man->next = ROFF_NEXT_SIBLING;
	man_descope(man, sp->line, 0);
}

d123 1
a123 1
		man_word_alloc(man, line, offs, buf + offs);
d167 1
a167 1
	man_word_alloc(man, line, offs, buf + offs);
@


1.106
log
@Unify node handling functions:
* node_alloc() for mdoc and man_node_alloc() -> roff_node_alloc()
* node_append() for mdoc and man_node_append() -> roff_node_append()
* mdoc_head_alloc() and man_head_alloc() -> roff_head_alloc()
* mdoc_body_alloc() and man_body_alloc() -> roff_body_alloc()
* mdoc_node_unlink() and man_node_unlink() -> roff_node_unlink()
* mdoc_node_free() and man_node_free() -> roff_node_free()
* mdoc_node_delete() and man_node_delete() -> roff_node_delete()
Minus 130 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.105 2015/04/18 17:50:02 schwarze Exp $ */
d101 1
a101 1
	n = roff_node_alloc(man, line, pos, ROFFT_TEXT, MAN_MAX);
d128 1
a128 1
	n = roff_node_alloc(man, ep->ln, ep->pos, ROFFT_EQN, MAN_MAX);
d142 2
a143 2
	man_breakscope(man, MAN_MAX);
	n = roff_node_alloc(man, sp->line, 0, ROFFT_TBL, MAN_MAX);
d262 1
a262 1
	tok = (i > 0 && i < 4) ? man_hash_find(mac) : MAN_MAX;
d264 1
a264 1
	if (tok == MAN_MAX) {
d350 1
a350 1
	if (man->flags & MAN_ELINE && (tok == MAN_MAX ||
d359 1
a359 1
		    tok == MAN_MAX ? "TS" : man_macronames[tok],
d372 1
a372 1
	if (man->flags & MAN_BLINE && (tok == MAN_MAX ||
d387 1
a387 1
		    tok == MAN_MAX ? "TS" : man_macronames[tok],
@


1.105
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.104 2015/04/18 17:28:08 schwarze Exp $ */
d33 1
a52 7
static	struct roff_node *man_node_alloc(struct roff_man *, int, int,
				enum roff_type, int);
static	void		 man_node_append(struct roff_man *,
				struct roff_node *);
static	void		 man_node_free(struct roff_node *);
static	void		 man_node_unlink(struct roff_man *,
				struct roff_node *);
a75 74
static void
man_node_append(struct roff_man *man, struct roff_node *p)
{

	assert(man->last);
	assert(man->first);
	assert(p->type != ROFFT_ROOT);

	switch (man->next) {
	case ROFF_NEXT_SIBLING:
		man->last->next = p;
		p->prev = man->last;
		p->parent = man->last->parent;
		break;
	case ROFF_NEXT_CHILD:
		man->last->child = p;
		p->parent = man->last;
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	assert(p->parent);
	p->parent->nchild++;

	switch (p->type) {
	case ROFFT_BLOCK:
		if (p->tok == MAN_SH || p->tok == MAN_SS)
			man->flags &= ~MAN_LITERAL;
		break;
	case ROFFT_HEAD:
		assert(p->parent->type == ROFFT_BLOCK);
		p->parent->head = p;
		break;
	case ROFFT_BODY:
		assert(p->parent->type == ROFFT_BLOCK);
		p->parent->body = p;
		break;
	default:
		break;
	}

	man->last = p;

	switch (p->type) {
	case ROFFT_TBL:
		/* FALLTHROUGH */
	case ROFFT_TEXT:
		man_valid_post(man);
		break;
	default:
		break;
	}
}

static struct roff_node *
man_node_alloc(struct roff_man *man, int line, int pos,
		enum roff_type type, int tok)
{
	struct roff_node *p;

	p = mandoc_calloc(1, sizeof(*p));
	p->line = line;
	p->pos = pos;
	p->type = type;
	p->tok = tok;

	if (man->flags & MAN_NEWLINE)
		p->flags |= MAN_LINE;
	man->flags &= ~MAN_NEWLINE;
	return(p);
}

d81 2
a82 22
	p = man_node_alloc(man, line, pos, ROFFT_ELEM, tok);
	man_node_append(man, p);
	man->next = ROFF_NEXT_CHILD;
}

void
man_head_alloc(struct roff_man *man, int line, int pos, int tok)
{
	struct roff_node *p;

	p = man_node_alloc(man, line, pos, ROFFT_HEAD, tok);
	man_node_append(man, p);
	man->next = ROFF_NEXT_CHILD;
}

void
man_body_alloc(struct roff_man *man, int line, int pos, int tok)
{
	struct roff_node *p;

	p = man_node_alloc(man, line, pos, ROFFT_BODY, tok);
	man_node_append(man, p);
d91 2
a92 2
	p = man_node_alloc(man, line, pos, ROFFT_BLOCK, tok);
	man_node_append(man, p);
d101 1
a101 1
	n = man_node_alloc(man, line, pos, ROFFT_TEXT, MAN_MAX);
d103 2
a104 1
	man_node_append(man, n);
a122 23
/*
 * Free all of the resources held by a node.  This does NOT unlink a
 * node from its context; for that, see man_node_unlink().
 */
static void
man_node_free(struct roff_node *p)
{

	free(p->string);
	free(p);
}

void
man_node_delete(struct roff_man *man, struct roff_node *p)
{

	while (p->child)
		man_node_delete(man, p->child);

	man_node_unlink(man, p);
	man_node_free(p);
}

d128 1
a128 1
	n = man_node_alloc(man, ep->ln, ep->pos, ROFFT_EQN, MAN_MAX);
d132 1
a132 1
	man_node_append(man, n);
d143 1
a143 1
	n = man_node_alloc(man, sp->line, 0, ROFFT_TBL, MAN_MAX);
d145 2
a146 1
	man_node_append(man, n);
d168 1
a168 1
	man_body_alloc(man, line, offs, man->last->tok);
d335 1
a335 1
	man_body_alloc(man, ln, ppos, man->last->tok);
d362 1
a362 1
		man_node_delete(man, n);
d390 1
a390 1
		man_node_delete(man, n);
a392 41
}

/*
 * Unlink a node from its context.  If "man" is provided, the last parse
 * point will also be adjusted accordingly.
 */
static void
man_node_unlink(struct roff_man *man, struct roff_node *n)
{

	/* Adjust siblings. */

	if (n->prev)
		n->prev->next = n->next;
	if (n->next)
		n->next->prev = n->prev;

	/* Adjust parent. */

	if (n->parent) {
		n->parent->nchild--;
		if (n->parent->child == n)
			n->parent->child = n->prev ? n->prev : n->next;
	}

	/* Adjust parse point, if applicable. */

	if (man && man->last == n) {
		/*XXX: this can occur when bailing from validation. */
		/*assert(NULL == n->next);*/
		if (n->prev) {
			man->last = n->prev;
			man->next = ROFF_NEXT_SIBLING;
		} else {
			man->last = n->parent;
			man->next = ROFF_NEXT_CHILD;
		}
	}

	if (man && man->first == n)
		man->first = NULL;
@


1.104
log
@Unify {mdoc,man}_{alloc,reset,free}() into roff_man_{alloc,reset,free}().
Minus 80 lines of code, no functional change.
Written on the train from Koeln to Wolfsburg returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.103 2015/04/18 17:01:28 schwarze Exp $ */
a61 14

const struct roff_node *
man_node(const struct roff_man *man)
{

	return(man->first);
}

const struct roff_meta *
man_meta(const struct roff_man *man)
{

	return(&man->meta);
}
@


1.103
log
@Move mdoc_hash_init() and man_hash_init() to libmandoc.h
and call them from mparse_alloc() and choose_parser(),
preparing unified allocation of struct roff_man.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.102 2015/04/18 16:34:03 schwarze Exp $ */
a49 1
static	void		 man_alloc1(struct roff_man *);
a51 1
static	void		 man_free1(struct roff_man *);
a77 32
man_reset(struct roff_man *man)
{

	man_free1(man);
	man_alloc1(man);
}

void
man_free(struct roff_man *man)
{

	man_free1(man);
	free(man);
}

struct roff_man *
man_alloc(struct roff *roff, struct mparse *parse,
	const char *defos, int quick)
{
	struct roff_man	*p;

	p = mandoc_calloc(1, sizeof(*p));
	p->parse = parse;
	p->defos = defos;
	p->quick = quick;
	p->roff = roff;

	man_alloc1(p);
	return(p);
}

void
a94 28

static void
man_free1(struct roff_man *man)
{

	if (man->first)
		man_node_delete(man, man->first);
	free(man->meta.title);
	free(man->meta.os);
	free(man->meta.date);
	free(man->meta.vol);
	free(man->meta.msec);
}

static void
man_alloc1(struct roff_man *man)
{

	memset(&man->meta, 0, sizeof(man->meta));
	man->macroset = MACROSET_MAN;
	man->flags = 0;
	man->last = mandoc_calloc(1, sizeof(*man->last));
	man->first = man->last;
	man->last->type = ROFFT_ROOT;
	man->last->tok = MAN_MAX;
	man->next = ROFF_NEXT_CHILD;
}

@


1.102
log
@Profit from the unified struct roff_man and reduce the number of
arguments of mparse_result() by one.  No functional change.
Written on the ICE Bruxelles-Koeln on the way back from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.101 2015/04/18 16:04:40 schwarze Exp $ */
a101 2

	man_hash_init();
@


1.101
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.100 2015/04/02 23:47:43 schwarze Exp $ */
d150 1
@


1.100
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.99 2015/04/02 22:06:17 schwarze Exp $ */
d50 5
a54 5
static	void		 man_alloc1(struct man *);
static	void		 man_breakscope(struct man *, int);
static	void		 man_descope(struct man *, int, int);
static	void		 man_free1(struct man *);
static	struct roff_node *man_node_alloc(struct man *, int, int,
d56 2
a57 1
static	void		 man_node_append(struct man *, struct roff_node *);
d59 4
a62 3
static	void		 man_node_unlink(struct man *, struct roff_node *);
static	int		 man_ptext(struct man *, int, char *, int);
static	int		 man_pmacro(struct man *, int, char *, int);
d66 1
a66 1
man_node(const struct man *man)
d73 1
a73 1
man_meta(const struct man *man)
d80 1
a80 1
man_reset(struct man *man)
d88 1
a88 1
man_free(struct man *man)
d95 1
a95 1
struct man *
d99 1
a99 1
	struct man	*p;
d101 1
a101 1
	p = mandoc_calloc(1, sizeof(struct man));
d114 1
a114 1
man_endparse(struct man *man)
d121 1
a121 1
man_parseln(struct man *man, int ln, char *buf, int offs)
d133 1
a133 1
man_free1(struct man *man)
d146 1
a146 1
man_alloc1(struct man *man)
d155 1
a155 1
	man->next = MAN_NEXT_CHILD;
d160 1
a160 1
man_node_append(struct man *man, struct roff_node *p)
d168 1
a168 1
	case MAN_NEXT_SIBLING:
d173 1
a173 1
	case MAN_NEXT_CHILD:
d216 1
a216 1
man_node_alloc(struct man *man, int line, int pos,
d234 1
a234 1
man_elem_alloc(struct man *man, int line, int pos, int tok)
d240 1
a240 1
	man->next = MAN_NEXT_CHILD;
d244 1
a244 1
man_head_alloc(struct man *man, int line, int pos, int tok)
d250 1
a250 1
	man->next = MAN_NEXT_CHILD;
d254 1
a254 1
man_body_alloc(struct man *man, int line, int pos, int tok)
d260 1
a260 1
	man->next = MAN_NEXT_CHILD;
d264 1
a264 1
man_block_alloc(struct man *man, int line, int pos, int tok)
d270 1
a270 1
	man->next = MAN_NEXT_CHILD;
d274 1
a274 1
man_word_alloc(struct man *man, int line, int pos, const char *word)
d281 1
a281 1
	man->next = MAN_NEXT_SIBLING;
d285 1
a285 1
man_word_append(struct man *man, const char *word)
d296 1
a296 1
	man->next = MAN_NEXT_SIBLING;
d312 1
a312 1
man_node_delete(struct man *man, struct roff_node *p)
d323 1
a323 1
man_addeqn(struct man *man, const struct eqn *ep)
d332 1
a332 1
	man->next = MAN_NEXT_SIBLING;
d337 1
a337 1
man_addspan(struct man *man, const struct tbl_span *sp)
d345 1
a345 1
	man->next = MAN_NEXT_SIBLING;
d350 1
a350 1
man_descope(struct man *man, int line, int offs)
d370 1
a370 1
man_ptext(struct man *man, int line, char *buf, int offs)
d395 1
a395 1
			man->next = MAN_NEXT_SIBLING;
d438 1
a438 1
man_pmacro(struct man *man, int ln, char *buf, int offs)
d538 1
a538 1
man_breakscope(struct man *man, int tok)
d598 1
a598 1
man_node_unlink(struct man *man, struct roff_node *n)
d623 1
a623 1
			man->next = MAN_NEXT_SIBLING;
d626 1
a626 1
			man->next = MAN_NEXT_CHILD;
d635 1
a635 1
man_mparse(const struct man *man)
@


1.99
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.98 2015/04/02 21:03:18 schwarze Exp $ */
d70 1
a70 1
const struct man_meta *
d137 1
a137 1
	free(man->meta.source);
d147 1
a147 1
	memset(&man->meta, 0, sizeof(struct man_meta));
@


1.98
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.97 2015/01/30 21:28:21 schwarze Exp $ */
d51 1
a51 1
static	void		 man_breakscope(struct man *, enum mant);
d54 5
a58 6
static	struct man_node	*man_node_alloc(struct man *, int, int,
				enum roff_type, enum mant);
static	void		 man_node_append(struct man *, struct man_node *);
static	void		 man_node_free(struct man_node *);
static	void		 man_node_unlink(struct man *,
				struct man_node *);
d63 1
a63 1
const struct man_node *
d149 1
a149 1
	man->last = mandoc_calloc(1, sizeof(struct man_node));
d158 1
a158 1
man_node_append(struct man *man, struct man_node *p)
d213 1
a213 1
static struct man_node *
d215 1
a215 1
		enum roff_type type, enum mant tok)
d217 1
a217 1
	struct man_node *p;
d219 1
a219 1
	p = mandoc_calloc(1, sizeof(struct man_node));
d232 1
a232 1
man_elem_alloc(struct man *man, int line, int pos, enum mant tok)
d234 1
a234 1
	struct man_node *p;
d242 1
a242 1
man_head_alloc(struct man *man, int line, int pos, enum mant tok)
d244 1
a244 1
	struct man_node *p;
d252 1
a252 1
man_body_alloc(struct man *man, int line, int pos, enum mant tok)
d254 1
a254 1
	struct man_node *p;
d262 1
a262 1
man_block_alloc(struct man *man, int line, int pos, enum mant tok)
d264 1
a264 1
	struct man_node *p;
d274 1
a274 1
	struct man_node	*n;
d285 1
a285 1
	struct man_node	*n;
d302 1
a302 1
man_node_free(struct man_node *p)
d310 1
a310 1
man_node_delete(struct man *man, struct man_node *p)
d323 1
a323 1
	struct man_node	*n;
d337 1
a337 1
	struct man_node	*n;
d438 1
a438 1
	struct man_node	*n;
d440 1
a440 1
	enum mant	 tok;
d536 1
a536 1
man_breakscope(struct man *man, enum mant tok)
d538 1
a538 1
	struct man_node	*n;
d596 1
a596 1
man_node_unlink(struct man *man, struct man_node *n)
d641 1
a641 1
man_deroff(char **dest, const struct man_node *n)
@


1.97
log
@starting a tbl(7) breaks man(7) next-line scope;
triggered by a bug report from jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.96 2015/01/24 02:41:32 schwarze Exp $ */
d11 1
a11 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d13 1
a13 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d28 3
d32 1
a32 2
#include "mandoc.h"
#include "mandoc_aux.h"
a33 1
#include "libmandoc.h"
d55 1
a55 1
				enum man_type, enum mant);
d123 1
a123 1
	if (man->last->type != MAN_EQN || ln > man->last->line)
d152 1
a152 1
	man->last->type = MAN_ROOT;
d164 1
a164 1
	assert(p->type != MAN_ROOT);
d185 1
a185 1
	case MAN_BLOCK:
d189 2
a190 2
	case MAN_HEAD:
		assert(p->parent->type == MAN_BLOCK);
d193 2
a194 2
	case MAN_BODY:
		assert(p->parent->type == MAN_BLOCK);
d204 1
a204 1
	case MAN_TBL:
d206 1
a206 1
	case MAN_TEXT:
d216 1
a216 1
		enum man_type type, enum mant tok)
d237 1
a237 1
	p = man_node_alloc(man, line, pos, MAN_ELEM, tok);
d247 1
a247 1
	p = man_node_alloc(man, line, pos, MAN_HEAD, tok);
d257 1
a257 1
	p = man_node_alloc(man, line, pos, MAN_BODY, tok);
d267 1
a267 1
	p = man_node_alloc(man, line, pos, MAN_BLOCK, tok);
d277 1
a277 1
	n = man_node_alloc(man, line, pos, MAN_TEXT, MAN_MAX);
d326 1
a326 1
	n = man_node_alloc(man, ep->ln, ep->pos, MAN_EQN, MAN_MAX);
d341 1
a341 1
	n = man_node_alloc(man, sp->line, 0, MAN_TBL, MAN_MAX);
d513 1
a513 1
		if (n->type == MAN_BODY &&
d550 1
a550 1
		assert(n->type != MAN_TEXT);
d572 1
a572 1
		if (n->type == MAN_TEXT)
d577 1
a577 1
		assert(n->type == MAN_HEAD);
d579 1
a579 1
		assert(n->type == MAN_BLOCK);
d647 1
a647 1
	if (n->type != MAN_TEXT) {
@


1.96
log
@Strangely, ignoring the roff(7) .na request was implemented in the man(7)
parser.  Simplify the code by moving it into the roff(7) parser, also
making it work for mdoc(7).
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.95 2015/01/15 04:26:06 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d49 4
a60 3
static	void		 man_free1(struct man *);
static	void		 man_alloc1(struct man *);
static	void		 man_descope(struct man *, int, int);
d339 1
d496 2
a497 3
	 * Remove prior ELINE macro, as it's being clobbered by a new
	 * macro.  Note that NSCOPED macros do not close out ELINE
	 * macros---they don't print text---so we let those slip by.
d500 1
a500 51
	if ( ! (man_macros[tok].flags & MAN_NSCOPED) &&
			man->flags & MAN_ELINE) {
		n = man->last;
		assert(MAN_TEXT != n->type);

		/* Remove repeated NSCOPED macros causing ELINE. */

		if (man_macros[n->tok].flags & MAN_NSCOPED)
			n = n->parent;

		mandoc_vmsg(MANDOCERR_BLK_LINE, man->parse, n->line,
		    n->pos, "%s breaks %s", man_macronames[tok],
		    man_macronames[n->tok]);

		man_node_delete(man, n);
		man->flags &= ~MAN_ELINE;
	}

	/*
	 * Remove prior BLINE macro that is being clobbered.
	 */
	if ((man->flags & MAN_BLINE) &&
	    (man_macros[tok].flags & MAN_BSCOPE)) {
		n = man->last;

		/* Might be a text node like 8 in
		 * .TP 8
		 * .SH foo
		 */
		if (n->type == MAN_TEXT)
			n = n->parent;

		/* Remove element that didn't end BLINE, if any. */
		if ( ! (man_macros[n->tok].flags & MAN_BSCOPE))
			n = n->parent;

		assert(n->type == MAN_HEAD);
		n = n->parent;
		assert(n->type == MAN_BLOCK);
		assert(man_macros[n->tok].flags & MAN_SCOPED);

		mandoc_vmsg(MANDOCERR_BLK_LINE, man->parse, n->line,
		    n->pos, "%s breaks %s", man_macronames[tok],
		    man_macronames[n->tok]);

		man_node_delete(man, n);
		man->flags &= ~MAN_BLINE;
	}

	/* Remember whether we are in next-line scope for a block head. */

d533 56
@


1.95
log
@Fatal errors no longer exist.
If a file can be opened, mandoc will produce some output;
at worst, the output may be almost empty.
Simplifies error handling and frees a message type for future use.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.94 2014/12/28 14:39:08 schwarze Exp $ */
d40 1
a40 1
	"RI",		"na",		"sp",		"nf",
@


1.94
log
@mdoc(7) already uses the mandoc(1) -Ios argument in the footer line
when .Os has no argument, so do the same for man(7) when .TH has less
than four arguments; there is no reason to treat both differently.
Issue found following a question from Thomas Klausner <wiz at NetBSD>.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.93 2014/11/28 06:26:46 schwarze Exp $ */
d110 1
a110 1
int
a114 1
	return(1);
@


1.93
log
@Simplify by making the eqn and tbl steering functions void;
no functional change, minus 15 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.92 2014/11/28 05:51:29 schwarze Exp $ */
d93 2
a94 1
man_alloc(struct roff *roff, struct mparse *parse, int quick)
d102 1
@


1.92
log
@Simplify by making many functions in the man(7) parser void,
and some cleanup; no functional change, minus 70 lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.91 2014/11/19 03:07:43 schwarze Exp $ */
d318 1
a318 1
int
a329 1
	return(1);
d332 1
a332 1
int
a341 1
	return(1);
@


1.91
log
@Escape sequences terminate high-level macro names, and when doing so,
they are ignored, just in the same way as for request names
and for low-level macro names.
This also cures a warning in the pod2man(1) preamble.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.90 2014/11/03 23:17:21 schwarze Exp $ */
d51 1
a51 2
static	int		 man_node_append(struct man *,
				struct man_node *);
d59 1
a59 1
static	int		 man_descope(struct man *, int, int);
d112 2
a113 1
	return(man_macroend(man));
d134 5
a138 10
	if (man->meta.title)
		free(man->meta.title);
	if (man->meta.source)
		free(man->meta.source);
	if (man->meta.date)
		free(man->meta.date);
	if (man->meta.vol)
		free(man->meta.vol);
	if (man->meta.msec)
		free(man->meta.msec);
d155 1
a155 1
static int
d161 1
a161 1
	assert(MAN_ROOT != p->type);
d187 1
a187 1
		assert(MAN_BLOCK == p->parent->type);
a189 4
	case MAN_TAIL:
		assert(MAN_BLOCK == p->parent->type);
		p->parent->tail = p;
		break;
d191 1
a191 1
		assert(MAN_BLOCK == p->parent->type);
d204 1
a204 2
		if ( ! man_valid_post(man))
			return(0);
a208 2

	return(1);
d223 1
a223 1
	if (MAN_NEWLINE & man->flags)
d229 1
a229 1
int
d235 1
a235 2
	if ( ! man_node_append(man, p))
		return(0);
a236 1
	return(1);
d239 1
a239 13
int
man_tail_alloc(struct man *man, int line, int pos, enum mant tok)
{
	struct man_node *p;

	p = man_node_alloc(man, line, pos, MAN_TAIL, tok);
	if ( ! man_node_append(man, p))
		return(0);
	man->next = MAN_NEXT_CHILD;
	return(1);
}

int
d245 1
a245 2
	if ( ! man_node_append(man, p))
		return(0);
a246 1
	return(1);
d249 1
a249 1
int
d255 1
a255 2
	if ( ! man_node_append(man, p))
		return(0);
a256 1
	return(1);
d259 1
a259 1
int
d265 1
a265 2
	if ( ! man_node_append(man, p))
		return(0);
a266 1
	return(1);
d269 1
a269 1
int
d276 1
a276 4

	if ( ! man_node_append(man, n))
		return(0);

a277 1
	return(1);
d303 1
a303 2
	if (p->string)
		free(p->string);
d327 1
a327 4

	if ( ! man_node_append(man, n))
		return(0);

d329 2
a330 1
	return(man_descope(man, ep->ln, ep->pos));
d340 1
a340 4

	if ( ! man_node_append(man, n))
		return(0);

d342 2
a343 1
	return(man_descope(man, sp->line, 0));
d346 1
a346 1
static int
d355 1
a355 1
	if (MAN_ELINE & man->flags) {
d357 1
a357 2
		if ( ! man_unscope(man, man->last->parent))
			return(0);
d359 2
a360 3

	if ( ! (MAN_BLINE & man->flags))
		return(1);
d362 2
a363 4

	if ( ! man_unscope(man, man->last->parent))
		return(0);
	return(man_body_alloc(man, line, offs, man->last->tok));
d373 4
a376 4
	if (MAN_LITERAL & man->flags) {
		if ( ! man_word_alloc(man, line, offs, buf + offs))
			return(0);
		return(man_descope(man, line, offs));
d379 1
a379 1
	for (i = offs; ' ' == buf[i]; i++)
d387 1
a387 1
	if ('\0' == buf[i]) {
d389 3
a391 4
		if (MAN_SH != man->last->tok &&
		    MAN_SS != man->last->tok) {
			if ( ! man_elem_alloc(man, line, offs, MAN_sp))
				return(0);
d418 1
a418 3

	if ( ! man_word_alloc(man, line, offs, buf + offs))
		return(0);
d430 2
a431 1
	return(man_descope(man, line, offs));
d482 1
a482 1
	while (buf[offs] && ' ' == buf[offs])
d490 1
a490 1
	if ('\0' == buf[offs] && ' ' == buf[offs - 1])
d500 1
a500 1
	if ( ! (MAN_NSCOPED & man_macros[tok].flags) &&
d507 1
a507 1
		if (MAN_NSCOPED & man_macros[n->tok].flags)
d522 1
a522 1
	    (MAN_BSCOPE & man_macros[tok].flags)) {
d529 1
a529 1
		if (MAN_TEXT == n->type)
d533 1
a533 1
		if ( ! (MAN_BSCOPE & man_macros[n->tok].flags))
d536 1
a536 1
		assert(MAN_HEAD == n->type);
d538 2
a539 2
		assert(MAN_BLOCK == n->type);
		assert(MAN_SCOPED & man_macros[n->tok].flags);
d556 1
a556 2
	if ( ! (*man_macros[tok].fp)(man, tok, ln, ppos, &offs, buf))
		return(0);
d560 1
a560 1
	if (man->quick && MAN_SH == tok) {
d562 1
a562 1
		if (MAN_BODY == n->type &&
d577 1
a577 1
	assert(MAN_BLINE & man->flags);
d580 3
a582 3
	if ( ! man_unscope(man, man->last->parent))
		return(0);
	return(man_body_alloc(man, ln, ppos, man->last->tok));
d640 1
a640 1
	if (MAN_TEXT != n->type) {
@


1.90
log
@Allow the five man(7) font macros to concatenate their line arguments,
the same way the mdoc(7) macros marked MDOC_JOIN do it.
In -Thtml, this removes bogus <br/> when the font macros are used
in no-fill mode; issue found by jsg@@ in the Xcursor(3) SYNOPSIS.
As a bonus, this slightly reduces the size of the syntax tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.89 2014/10/20 15:49:45 schwarze Exp $ */
a483 1
	char		 mac[5];
d485 1
d489 1
d495 1
a495 1
	 * Stop copying when a tab, space, or eoln is encountered.
d499 1
a499 2
	while (i < 4 && '\0' != buf[offs] && ' ' != buf[offs] &&
	    '\t' != buf[offs])
d506 1
a506 1
	if (MAN_MAX == tok) {
d512 16
a527 1
	/* The macro is sane.  Jump to the next word. */
@


1.89
log
@correct the spacing after in-line equations
that start at the beginning of an input line
but end before the end of an input line
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.88 2014/10/20 02:31:44 schwarze Exp $ */
d314 15
@


1.88
log
@correct spacing before inline equations
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.87 2014/09/06 23:24:27 schwarze Exp $ */
d120 2
a121 1
	man->flags |= MAN_NEWLINE;
@


1.87
log
@Simplify by handling empty request lines at the one logical place
in the roff parser instead of in three other places in other parsers.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d346 2
@


1.86
log
@Simplify man(7) validation:
Drop pre-handlers, they were almost unused.
Drop the needless complexity of allowing more than one post-handler.

This saves one internal interface function, one static function, one
private struct definition, sixteen static arrays, and 45 lines of code.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.85 2014/08/08 15:54:10 schwarze Exp $ */
a470 7

	if ('"' == buf[offs]) {
		mandoc_msg(MANDOCERR_COMMENT_BAD, man->parse,
		    ln, offs, NULL);
		return(1);
	} else if ('\0' == buf[offs])
		return(1);
@


1.85
log
@mention requests and macros in more messages
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.84 2014/08/08 15:32:17 schwarze Exp $ */
a184 3
	if ( ! man_valid_pre(man, p))
		return(0);

d186 4
@


1.84
log
@Simplify: replace one global flag by one local variable
and remove three unused global flags.  No functional change.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.83 2014/07/07 21:35:42 schwarze Exp $ */
d495 2
a496 2
		mandoc_vmsg(MANDOCERR_MACRO, man->parse, ln, ppos,
		    "%s", buf + ppos - 1);
@


1.83
log
@Clean up ERROR messages related to document structure and macros:
Hierarchical naming and mention macro names in messages.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.82 2014/07/07 19:17:39 schwarze Exp $ */
a66 1
	assert( ! (MAN_HALT & man->flags));
a73 1
	assert( ! (MAN_HALT & man->flags));
d113 1
a113 5
	assert( ! (MAN_HALT & man->flags));
	if (man_macroend(man))
		return(1);
	man->flags |= MAN_HALT;
	return(0);
a121 2
	assert( ! (MAN_HALT & man->flags));

a342 2
	assert( ! (MAN_HALT & man->flags));

a357 2
	assert( ! (MAN_HALT & man->flags));

a464 2
	int		 i, ppos;
	enum mant	 tok;
d467 3
d569 1
a569 5
	/*
	 * Save the fact that we're in the next-line for a block.  In
	 * this way, embedded roff instructions can "remember" state
	 * when they exit.
	 */
d571 1
a571 2
	if (MAN_BLINE & man->flags)
		man->flags |= MAN_BPLINE;
d577 1
a577 1
		goto err;
d589 3
a591 13
	 * We weren't in a block-line scope when entering the
	 * above-parsed macro, so return.
	 */

	if ( ! (MAN_BPLINE & man->flags)) {
		man->flags &= ~MAN_ILINE;
		return(1);
	}
	man->flags &= ~MAN_BPLINE;

	/*
	 * If we're in a block scope, then allow this macro to slip by
	 * without closing scope around it.
d594 2
a595 2
	if (MAN_ILINE & man->flags) {
		man->flags &= ~MAN_ILINE;
a596 11
	}

	/*
	 * If we've opened a new next-line element scope, then return
	 * now, as the next line will close out the block scope.
	 */

	if (MAN_ELINE & man->flags)
		return(1);

	/* Close out the block scope opened in the prior line.  */
a603 5

err:	/* Error out. */

	man->flags |= MAN_HALT;
	return(0);
@


1.82
log
@Simplify man_unscope(), removing 18 lines of code, that is,
removing one function argument, one function definition,
three function invocations and two pointless assert()s.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.81 2014/07/06 19:08:56 schwarze Exp $ */
d541 1
a541 1
		mandoc_vmsg(MANDOCERR_LINESCOPE, man->parse, n->line,
d572 1
a572 1
		mandoc_vmsg(MANDOCERR_LINESCOPE, man->parse, n->line,
@


1.81
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.80 2014/05/07 14:11:24 schwarze Exp $ */
d391 1
a391 1
		if ( ! man_unscope(man, man->last->parent, MANDOCERR_MAX))
d399 1
a399 1
	if ( ! man_unscope(man, man->last->parent, MANDOCERR_MAX))
d638 1
a638 1
	if ( ! man_unscope(man, man->last->parent, MANDOCERR_MAX))
@


1.80
log
@Do not segfault in makewhatis -Q if the next .SH after .SH NAME
does not have any arguments.  Crash found by nigel@@ in kermit(1).
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.79 2014/04/20 16:44:44 schwarze Exp $ */
d446 2
a447 1
			man_pmsg(man, line, i - 1, MANDOCERR_EOLNSPACE);
d483 2
a484 1
		man_pmsg(man, ln, offs, MANDOCERR_BADCOMMENT);
d522 2
a523 1
		man_pmsg(man, ln, offs - 1, MANDOCERR_EOLNSPACE);
@


1.79
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.78 2014/03/30 19:47:32 schwarze Exp $ */
d594 6
a599 3
	if (man->quick && MAN_SH == tok &&
	    strcmp(man->last->prev->child->string, "NAME"))
		return(2);
@


1.78
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.77 2014/03/23 20:57:23 schwarze Exp $ */
d34 1
a34 1
const	char *const __man_macronames[MAN_MAX] = {		 
d36 1
a36 1
	"TP", 		"LP",		"PP",		"P",
d49 1
a49 1
static	struct man_node	*man_node_alloc(struct man *, int, int, 
d51 1
a51 1
static	int		 man_node_append(struct man *, 
d54 1
a54 1
static	void		 man_node_unlink(struct man *, 
a70 1

a78 1

a86 1

a94 1

a110 1

a121 1

d131 2
a132 2
			man_pmacro(man, ln, buf, offs) : 
			man_ptext(man, ln, buf, offs));
a134 1

a152 1

d176 1
a176 1
	case (MAN_NEXT_SIBLING):
d181 1
a181 1
	case (MAN_NEXT_CHILD):
d189 1
a189 1
	
d197 1
a197 1
	case (MAN_HEAD):
d201 1
a201 1
	case (MAN_TAIL):
d205 1
a205 1
	case (MAN_BODY):
d216 1
a216 1
	case (MAN_TBL):
d218 1
a218 1
	case (MAN_TEXT):
a228 1

d230 1
a230 1
man_node_alloc(struct man *man, int line, int pos, 
a246 1

a258 1

a270 1

a282 1

a294 1

a321 1

a334 1

d436 1
a436 1
	/* 
d438 1
a438 1
	 * strip away the remaining spaces (tabs stay!).   
d495 2
a496 2
	while (i < 4 && '\0' != buf[offs] && 
			' ' != buf[offs] && '\t' != buf[offs])
d504 2
a505 2
		mandoc_vmsg(MANDOCERR_MACRO, man->parse, ln, 
				ppos, "%s", buf + ppos - 1);
d514 1
a514 1
	/* 
d522 1
a522 1
	/* 
d538 1
a538 1
		mandoc_vmsg(MANDOCERR_LINESCOPE, man->parse, n->line, 
d569 1
a569 1
		mandoc_vmsg(MANDOCERR_LINESCOPE, man->parse, n->line, 
d598 1
a598 1
	/* 
d604 1
a604 1
		man->flags &= ~MAN_ILINE; 
d619 1
a619 1
	/* 
@


1.77
log
@Skip leading escape sequences in man_deroff().  Helps indexing of
some manuals containing overzealous escaping in their NAME section.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.76 2014/03/22 00:56:07 schwarze Exp $ */
d44 1
a44 1
	"UR",		"UE"
@


1.76
log
@If a man(7) NAME section contains macros, avoid truncated or empty
entries for .Nd in mandocdb(8), instead use the macro content
recursively.  This improves indexing of more than 200 manuals
in Xenocara, i.e. more than 15%, in particular GL and some Xkb.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.75 2014/03/21 22:17:01 schwarze Exp $ */
d719 1
a719 1
	/* Skip leading whitespace. */
d721 8
a728 2
	for (cp = n->string; '\0' != *cp; cp++)
		if (0 == isspace((unsigned char)*cp))
d730 1
@


1.75
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.74 2014/01/06 00:53:14 schwarze Exp $ */
d22 1
d705 39
@


1.74
log
@Joerg Sonnenberger contributed copyrightable amounts of text to
some files.  To make it clear that he also put his contributions
under the ISC license, with his explicit permission, add his
Copyright notice to the relevant files.  No code change.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.73 2014/01/05 20:26:27 schwarze Exp $ */
d29 1
@


1.73
log
@Add an option -Q (quick) to mandocdb(8)
for accelerated generation of reduced-size databases.

Implement this by allowing the parsers to optionally
abort the parse sequence after the NAME section.

While here, garbage collect the unused void *arg attribute
of struct mparse and mparse_alloc().

This reduces the processing time of mandocdb(8) on /usr/share/man
by a factor of 2 and the database size by a factor of 4.
However, it still takes 5 times the time and 6 times the space
of makewhatis(8), so more work is clearly needed.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.72 2013/12/30 00:52:18 schwarze Exp $ */
d5 1
@


1.72
log
@Simplify: Remove an unused argument from the mandoc_eos() function.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.71 2013/11/10 22:53:58 schwarze Exp $ */
d4 1
d97 1
a97 1
man_alloc(struct roff *roff, struct mparse *parse)
d105 1
d604 6
@


1.71
log
@Ignore blank lines right after .SH and .SS.
Improves the rendering of gpg(1); issue reported by jca on ports.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.70 2013/10/17 20:51:28 schwarze Exp $ */
d478 1
a478 1
	if (mandoc_eos(buf, (size_t)i, 0))
@


1.70
log
@Implement the .UR/.UE block (uniform resource identifier) introduced in the
man-ext macros by Eric S. Raymond, enabled by default in groff_man(7).
Usual disclaimer: You don't write new man(7) code, so you are not going
to use these, either.
Improves e.g. the bzr(1) and etherape(1) manuals.
Thanks to naddy@@ for bringing these to my attention.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.69 2012/11/17 00:25:20 schwarze Exp $ */
a427 2
	/* Pump blank lines directly into the backend. */

d431 5
d438 6
a443 3
		if ( ! man_elem_alloc(man, line, offs, MAN_sp))
			return(0);
		man->next = MAN_NEXT_SIBLING;
@


1.69
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.68 2012/07/14 10:43:48 schwarze Exp $ */
d39 2
a40 1
	"ft",		"OP",		"EX",		"EE"
@


1.68
log
@Translate blank input lines to .sp just like in mdoc(7),
and ignore .sp after .PP.  This fixes vertical spacing
for blank lines after .PP and for .sp after .PP.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.67 2012/07/07 18:27:36 schwarze Exp $ */
d59 1
a59 1
man_node(const struct man *m)
d62 2
a63 2
	assert( ! (MAN_HALT & m->flags));
	return(m->first);
d68 1
a68 1
man_meta(const struct man *m)
d71 2
a72 2
	assert( ! (MAN_HALT & m->flags));
	return(&m->meta);
d111 1
a111 1
man_endparse(struct man *m)
d114 2
a115 2
	assert( ! (MAN_HALT & m->flags));
	if (man_macroend(m))
d117 1
a117 1
	m->flags |= MAN_HALT;
d123 1
a123 1
man_parseln(struct man *m, int ln, char *buf, int offs)
d126 1
a126 1
	m->flags |= MAN_NEWLINE;
d128 1
a128 1
	assert( ! (MAN_HALT & m->flags));
d130 3
a132 3
	return (roff_getcontrol(m->roff, buf, &offs) ?
			man_pmacro(m, ln, buf, offs) : 
			man_ptext(m, ln, buf, offs));
d156 1
a156 1
man_alloc1(struct man *m)
d159 7
a165 7
	memset(&m->meta, 0, sizeof(struct man_meta));
	m->flags = 0;
	m->last = mandoc_calloc(1, sizeof(struct man_node));
	m->first = m->last;
	m->last->type = MAN_ROOT;
	m->last->tok = MAN_MAX;
	m->next = MAN_NEXT_CHILD;
d233 1
a233 1
man_node_alloc(struct man *m, int line, int pos, 
d244 1
a244 1
	if (MAN_NEWLINE & m->flags)
d246 1
a246 1
	m->flags &= ~MAN_NEWLINE;
d252 1
a252 1
man_elem_alloc(struct man *m, int line, int pos, enum mant tok)
d256 2
a257 2
	p = man_node_alloc(m, line, pos, MAN_ELEM, tok);
	if ( ! man_node_append(m, p))
d259 1
a259 1
	m->next = MAN_NEXT_CHILD;
d265 1
a265 1
man_tail_alloc(struct man *m, int line, int pos, enum mant tok)
d269 2
a270 2
	p = man_node_alloc(m, line, pos, MAN_TAIL, tok);
	if ( ! man_node_append(m, p))
d272 1
a272 1
	m->next = MAN_NEXT_CHILD;
d278 1
a278 1
man_head_alloc(struct man *m, int line, int pos, enum mant tok)
d282 2
a283 2
	p = man_node_alloc(m, line, pos, MAN_HEAD, tok);
	if ( ! man_node_append(m, p))
d285 1
a285 1
	m->next = MAN_NEXT_CHILD;
d291 1
a291 1
man_body_alloc(struct man *m, int line, int pos, enum mant tok)
d295 2
a296 2
	p = man_node_alloc(m, line, pos, MAN_BODY, tok);
	if ( ! man_node_append(m, p))
d298 1
a298 1
	m->next = MAN_NEXT_CHILD;
d304 1
a304 1
man_block_alloc(struct man *m, int line, int pos, enum mant tok)
d308 2
a309 2
	p = man_node_alloc(m, line, pos, MAN_BLOCK, tok);
	if ( ! man_node_append(m, p))
d311 1
a311 1
	m->next = MAN_NEXT_CHILD;
d316 1
a316 1
man_word_alloc(struct man *m, int line, int pos, const char *word)
d320 2
a321 2
	n = man_node_alloc(m, line, pos, MAN_TEXT, MAN_MAX);
	n->string = roff_strdup(m->roff, word);
d323 1
a323 1
	if ( ! man_node_append(m, n))
d326 1
a326 1
	m->next = MAN_NEXT_SIBLING;
d346 1
a346 1
man_node_delete(struct man *m, struct man_node *p)
d350 1
a350 1
		man_node_delete(m, p->child);
d352 1
a352 1
	man_node_unlink(m, p);
d357 1
a357 1
man_addeqn(struct man *m, const struct eqn *ep)
d361 1
a361 1
	assert( ! (MAN_HALT & m->flags));
d363 1
a363 1
	n = man_node_alloc(m, ep->ln, ep->pos, MAN_EQN, MAN_MAX);
d366 1
a366 1
	if ( ! man_node_append(m, n))
d369 2
a370 2
	m->next = MAN_NEXT_SIBLING;
	return(man_descope(m, ep->ln, ep->pos));
d374 1
a374 1
man_addspan(struct man *m, const struct tbl_span *sp)
d378 1
a378 1
	assert( ! (MAN_HALT & m->flags));
d380 1
a380 1
	n = man_node_alloc(m, sp->line, 0, MAN_TBL, MAN_MAX);
d383 1
a383 1
	if ( ! man_node_append(m, n))
d386 2
a387 2
	m->next = MAN_NEXT_SIBLING;
	return(man_descope(m, sp->line, 0));
d391 1
a391 1
man_descope(struct man *m, int line, int offs)
d399 3
a401 3
	if (MAN_ELINE & m->flags) {
		m->flags &= ~MAN_ELINE;
		if ( ! man_unscope(m, m->last->parent, MANDOCERR_MAX))
d405 1
a405 1
	if ( ! (MAN_BLINE & m->flags))
d407 1
a407 1
	m->flags &= ~MAN_BLINE;
d409 1
a409 1
	if ( ! man_unscope(m, m->last->parent, MANDOCERR_MAX))
d411 1
a411 1
	return(man_body_alloc(m, line, offs, m->last->tok));
d415 1
a415 1
man_ptext(struct man *m, int line, char *buf, int offs)
d421 2
a422 2
	if (MAN_LITERAL & m->flags) {
		if ( ! man_word_alloc(m, line, offs, buf + offs))
d424 1
a424 1
		return(man_descope(m, line, offs));
d434 1
a434 1
		if ( ! man_elem_alloc(m, line, offs, MAN_sp))
d436 1
a436 1
		m->next = MAN_NEXT_SIBLING;
d450 1
a450 1
			man_pmsg(m, line, i - 1, MANDOCERR_EOLNSPACE);
d461 1
a461 1
	if ( ! man_word_alloc(m, line, offs, buf + offs))
d472 1
a472 1
		m->last->flags |= MAN_EOS;
d474 1
a474 1
	return(man_descope(m, line, offs));
d478 1
a478 1
man_pmacro(struct man *m, int ln, char *buf, int offs)
d486 1
a486 1
		man_pmsg(m, ln, offs, MANDOCERR_BADCOMMENT);
d508 1
a508 1
		mandoc_vmsg(MANDOCERR_MACRO, m->parse, ln, 
d524 1
a524 1
		man_pmsg(m, ln, offs - 1, MANDOCERR_EOLNSPACE);
d533 2
a534 2
			m->flags & MAN_ELINE) {
		n = m->last;
d542 1
a542 1
		mandoc_vmsg(MANDOCERR_LINESCOPE, m->parse, n->line, 
d546 2
a547 2
		man_node_delete(m, n);
		m->flags &= ~MAN_ELINE;
d553 1
a553 1
	if ((m->flags & MAN_BLINE) &&
d555 1
a555 1
		n = m->last;
d573 1
a573 1
		mandoc_vmsg(MANDOCERR_LINESCOPE, m->parse, n->line, 
d577 2
a578 2
		man_node_delete(m, n);
		m->flags &= ~MAN_BLINE;
d587 2
a588 2
	if (MAN_BLINE & m->flags)
		m->flags |= MAN_BPLINE;
d593 1
a593 1
	if ( ! (*man_macros[tok].fp)(m, tok, ln, ppos, &offs, buf))
d601 2
a602 2
	if ( ! (MAN_BPLINE & m->flags)) {
		m->flags &= ~MAN_ILINE; 
d605 1
a605 1
	m->flags &= ~MAN_BPLINE;
d612 2
a613 2
	if (MAN_ILINE & m->flags) {
		m->flags &= ~MAN_ILINE;
d622 1
a622 1
	if (MAN_ELINE & m->flags)
d627 2
a628 2
	assert(MAN_BLINE & m->flags);
	m->flags &= ~MAN_BLINE;
d630 1
a630 1
	if ( ! man_unscope(m, m->last->parent, MANDOCERR_MAX))
d632 1
a632 1
	return(man_body_alloc(m, ln, ppos, m->last->tok));
d636 1
a636 1
	m->flags |= MAN_HALT;
d641 1
a641 1
 * Unlink a node from its context.  If "m" is provided, the last parse
d645 1
a645 1
man_node_unlink(struct man *m, struct man_node *n)
d665 1
a665 1
	if (m && m->last == n) {
d669 2
a670 2
			m->last = n->prev;
			m->next = MAN_NEXT_SIBLING;
d672 2
a673 2
			m->last = n->parent;
			m->next = MAN_NEXT_CHILD;
d677 2
a678 2
	if (m && m->first == n)
		m->first = NULL;
d682 1
a682 1
man_mparse(const struct man *m)
d685 2
a686 2
	assert(m && m->parse);
	return(m->parse);
@


1.67
log
@Support the .cc request; code by kristaps@@, tests by me.
Needed for sqlite3(1) as reported by espie@@.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.66 2012/06/02 20:07:09 schwarze Exp $ */
d434 1
a434 1
		if ( ! man_word_alloc(m, line, offs, ""))
d436 2
a437 1
		return(man_descope(m, line, offs));
@


1.66
log
@Minimal implementation of .EX and .EE for GNU compatibility.
Do not use this, it is not portable and only defined in esr's man-ext.
For example, sox(1) wants these macros.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.65 2012/02/26 19:41:27 schwarze Exp $ */
d130 1
a130 1
	return (mandoc_getcontrol(buf, &offs) ?
@


1.65
log
@Support .OP, one of the extended man macros; from kristaps@@.
Do not use this GNU extension, we take it for compatibility only.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.64 2011/11/16 17:21:15 schwarze Exp $ */
d39 1
a39 1
	"ft",		"OP"
@


1.64
log
@When a .TP block is broken but already contains a head element,
do not abort(), but delete the head together with the block itself.
Problem found and patch provided by joerg@@, thanks!
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.63 2011/11/05 16:02:18 schwarze Exp $ */
d39 1
a39 1
	"ft"
@


1.63
log
@When the HEAD scope of .TP is broken by another block macro,
do not abort with a FATAL error, but report a regular ERROR,
remove the broken .TP from the syntax tree, and prod on.
Reported repeatedly by ports people, at least by brad@@ and jeremy@@.
Also fixes rendition(4) in Xenocara.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.62 2011/10/09 17:59:56 schwarze Exp $ */
d555 7
a561 1
		assert(MAN_TEXT != n->type);
a563 1

@


1.62
log
@Sync to version 1.12.0; all code by kristaps@@:
Implement .Rv in -Tman.
Let -man -Tman work a bit like cat(1).
Add the -Ofragment option to -T[x]html.
Minor fixes in -T[x]html.
Lots of apropos(1) and -Tman code cleanup.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.61 2011/09/18 15:54:48 schwarze Exp $ */
d542 2
a543 1
				n->pos, "%s", man_macronames[n->tok]);
d547 26
@


1.61
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.60 2011/09/18 10:25:28 schwarze Exp $ */
d646 8
@


1.60
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.59 2011/04/24 16:22:02 schwarze Exp $ */
a318 3
	size_t		 sv, len;

	len = strlen(word);
d321 1
a321 5
	n->string = mandoc_malloc(len + 1);
	sv = strlcpy(n->string, word, len + 1);

	/* Prohibit truncation. */
	assert(sv < len + 1);
@


1.59
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.58 2011/04/21 22:59:54 schwarze Exp $ */
d95 1
a95 1
man_alloc(struct regset *regs, struct mparse *parse)
d103 1
a103 1
	p->regs = regs;
d370 1
a370 1
	n = man_node_alloc(m, ep->line, ep->pos, MAN_EQN, MAN_MAX);
d377 1
a377 1
	return(man_descope(m, ep->line, ep->pos));
@


1.58
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.57 2011/03/20 23:36:42 schwarze Exp $ */
d25 1
d95 1
a95 1
man_alloc(struct regset *regs, void *data, mandocmsg msg)
d102 1
a102 2
	p->data = data;
	p->msg = msg;
d129 2
a130 1
	return(('.' == buf[offs] || '\'' == buf[offs]) ? 
d203 4
d265 13
a420 1

a425 9
	/* Ignore bogus comments. */

	if ('\\' == buf[offs] && 
			'.' == buf[offs + 1] && 
			'"' == buf[offs + 2]) {
		man_pmsg(m, line, offs, MANDOCERR_BADCOMMENT);
		return(1);
	}

a482 1

d486 1
a486 1
	int		 i, j, ppos;
d491 4
a494 5
	/* Comments and empties are quickly ignored. */

	offs++;

	if ('\0' == buf[offs])
d497 1
a497 1
	i = offs;
d500 2
a501 2
	 * Skip whitespace between the control character and initial
	 * text.  "Whitespace" is both spaces and tabs.
d504 4
a507 7
	if (' ' == buf[i] || '\t' == buf[i]) {
		i++;
		while (buf[i] && (' ' == buf[i] || '\t' == buf[i]))
			i++;
		if ('\0' == buf[i])
			goto out;
	}
d509 1
a509 1
	ppos = i;
d511 1
a511 9
	/*
	 * Copy the first word into a nil-terminated buffer.
	 * Stop copying when a tab, space, or eoln is encountered.
	 */

	j = 0;
	while (j < 4 && '\0' != buf[i] && ' ' != buf[i] && '\t' != buf[i])
		mac[j++] = buf[i++];
	mac[j] = '\0';
a512 1
	tok = (j > 0 && j < 4) ? man_hash_find(mac) : MAN_MAX;
d514 2
a515 1
		man_vmsg(m, MANDOCERR_MACRO, ln, ppos, "%s", buf + ppos - 1);
d521 2
a522 2
	while (buf[i] && ' ' == buf[i])
		i++;
d529 2
a530 2
	if ('\0' == buf[i] && ' ' == buf[i - 1])
		man_pmsg(m, ln, i - 1, MANDOCERR_EOLNSPACE);
d548 2
a549 2
		man_vmsg(m, MANDOCERR_LINESCOPE, n->line, n->pos,
				"%s", man_macronames[n->tok]);
d567 1
a567 1
	if ( ! (*man_macros[tok].fp)(m, tok, ln, ppos, &i, buf))
a569 1
out:
d606 1
a606 1
	return(man_body_alloc(m, ln, offs, m->last->tok));
a612 15


void
man_vmsg(struct man *man, enum mandocerr t, 
		int ln, int pos, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	(*man->msg)(t, man->data, ln, pos, buf);
}

@


1.57
log
@Import the foundation for eqn(7) support.
Written by kristaps@@.

For now, i'm adding one line to each of the four frontends
to just pass the input text through to the output,
not yet interpreting any of then eqn keywords.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.56 2011/03/07 01:35:33 schwarze Exp $ */
d621 1
a621 1
int
d631 1
a631 1
	return((*man->msg)(t, man->data, ln, pos, buf));
@


1.56
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.55 2011/02/10 00:06:30 schwarze Exp $ */
d345 16
@


1.55
log
@Tbl code maintenance by kristaps@@.
- Remember the line-number of a tbl_span, and use it in messages.
- Put *_span_alloc() functions right into the *_addspan() ones,
  since these are the only places they are called from.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.54 2011/01/16 02:56:47 schwarze Exp $ */
d145 2
a146 2
	if (man->meta.rawdate)
		free(man->meta.rawdate);
@


1.54
log
@If the first character of a free-form text input line is whitespace,
then it will start a new output line;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.53 2011/01/09 13:16:48 schwarze Exp $ */
a46 2
static	int		 man_span_alloc(struct man *, 
				const struct tbl_span *);
a296 16
static int
man_span_alloc(struct man *m, const struct tbl_span *span)
{
	struct man_node	*n;

	/* FIXME: grab from span */
	n = man_node_alloc(m, 0, 0, MAN_TBL, MAN_MAX);
	n->span = span;

	if ( ! man_node_append(m, n))
		return(0);

	m->next = MAN_NEXT_SIBLING;
	return(1);
}

d349 1
d352 5
a356 1
	if ( ! man_span_alloc(m, sp))
d358 3
a360 1
	return(man_descope(m, 0, 0));
@


1.53
log
@Make sure coding errors cannot make us miss fatal parsing errors
by assert(3)ing valid parser state in the main parsing functions;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.52 2011/01/04 22:28:17 schwarze Exp $ */
d43 1
a43 1
static	struct man_node	*man_node_alloc(int, int, 
d128 2
d230 2
a231 1
man_node_alloc(int line, int pos, enum man_type type, enum mant tok)
d240 4
d253 1
a253 1
	p = man_node_alloc(line, pos, MAN_ELEM, tok);
d266 1
a266 1
	p = man_node_alloc(line, pos, MAN_HEAD, tok);
d279 1
a279 1
	p = man_node_alloc(line, pos, MAN_BODY, tok);
d292 1
a292 1
	p = man_node_alloc(line, pos, MAN_BLOCK, tok);
d305 1
a305 1
	n = man_node_alloc(0, 0, MAN_TBL, MAN_MAX);
d323 1
a323 1
	n = man_node_alloc(line, pos, MAN_TEXT, MAN_MAX);
@


1.52
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.51 2011/01/01 17:38:11 schwarze Exp $ */
d63 2
a64 1
	return(MAN_HALT & m->flags ? NULL : m->first);
d72 2
a73 1
	return(MAN_HALT & m->flags ? NULL : &m->meta);
d116 2
a117 3
	if (MAN_HALT & m->flags)
		return(0);
	else if (man_macroend(m))
d128 1
a128 3
	if (MAN_HALT & m->flags)
		return(0);

d361 1
d464 1
a464 1
int
@


1.51
log
@Clean up {mdoc,man}_{p,v}msg invocations:
Ignore the return values, they are constant anyway.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.50 2010/12/19 07:53:12 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
a28 4
#include "out.h"
#include "term.h"
#include "tbl.h"

d38 1
a38 1
	"TS",		"TE",		"ft",
d47 2
d56 1
a125 1
	struct man_node *n;
a129 11
	n = m->last;

	if (n && MAN_TS == n->tok && MAN_BODY == n->type &&
	    strncmp(buf+offs, ".TE", 3)) {
		n = n->parent;
		if ( ! tbl_read(n->data.TS, "man tbl parser",
		    ln, buf+offs, strlen(buf+offs)))
			man_nmsg(m, n, MANDOCERR_TBL);
		return(1);
	}

d214 2
d293 15
a341 2
	if (p->data.TS)
		tbl_free(p->data.TS);
d358 34
d411 1
a411 1
		goto descope;
d423 1
a423 1
		goto descope;
d460 1
a460 20
descope:
	/*
	 * Co-ordinate what happens with having a next-line scope open:
	 * first close out the element scope (if applicable), then close
	 * out the block scope (also if applicable).
	 */

	if (MAN_ELINE & m->flags) {
		m->flags &= ~MAN_ELINE;
		if ( ! man_unscope(m, m->last->parent, MANDOCERR_MAX))
			return(0);
	}

	if ( ! (MAN_BLINE & m->flags))
		return(1);
	m->flags &= ~MAN_BLINE;

	if ( ! man_unscope(m, m->last->parent, MANDOCERR_MAX))
		return(0);
	return(man_body_alloc(m, line, offs, m->last->tok));
@


1.50
log
@Remove `i' and `r' macro handlers.  These macros, originally part of the
me package, aren't recognised by "groff -mandoc" so we don't need to do
so either.  Besides, they are not used in base or Xenocara, and only at
two or three places in one single port, which are probably typos.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.49 2010/12/07 00:08:52 schwarze Exp $ */
d365 4
a368 2
			'"' == buf[offs + 2])
		return(man_pmsg(m, line, offs, MANDOCERR_BADCOMMENT));
d400 1
a400 2
			if ( ! man_pmsg(m, line, i - 1, MANDOCERR_EOLNSPACE))
				return(0);
d506 1
a506 2
		if ( ! man_pmsg(m, ln, i - 1, MANDOCERR_EOLNSPACE))
			goto err;
@


1.49
log
@Complete the merge of bsd.lv version 1.10.7:
No more functional changes, just sync ordering, comments and white space.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.48 2010/12/01 23:02:59 schwarze Exp $ */
d39 4
a42 5
	"RI",		"na",		"i",		"sp",
	"nf",		"fi",		"r",		"RE",
	"RS",		"DT",		"UC",		"PD",
	"AT",
	"in",		"TS",		"TE",		"ft",
@


1.48
log
@Merge man_action.c into man_validate.c.
Same as for mdoc_action.c, but much simpler.
Work by kristaps@@, re-applying OpenBSD changes on top.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.47 2010/11/29 02:26:45 schwarze Exp $ */
d520 2
a521 1
		/* .B .br .br .B: remove prior including children */
d526 1
a526 1
		    "%s", man_macronames[n->tok]);
@


1.47
log
@Now that we have proper .de support in the roff(7) library,
it is time to remove the .Sp, .Vb, and .Ve kludge
that was added to the man(7) library to build Perl manuals.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.46 2010/11/29 01:44:41 schwarze Exp $ */
a229 2
			return(0);
		if ( ! man_action_post(man))
@


1.46
log
@Downgrade the easier of the two cases of MANDOCERR_SYNTLINESCOPE
to MANDOCERR_LINESCOPE, i.e. from FATAL to ERROR.

That is, when an element next line scope is empty except for one
or more NSCOPED macros (like in .B .br .br .B), throw away the
empty element including its NSCOPED children such that the parser
can prod on.

While here, improve the error message and tell the user which element
has been thrown away.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.45 2010/11/29 00:12:02 schwarze Exp $ */
d42 1
a42 1
	"Sp",		"Vb",		"Ve",		"AT",
@


1.45
log
@Implement the roff .ft (change font) request for man(7).
Of course, we don't want to encourage low-level physical markup,
but pod2man(1) writes such requests, so Perl manuals contain them,
and some Xenocara and lots and lots of ports manuals use them as well.
In base and Xenocara, this will reduce mandoc -Tlint ERROR noise;
in ports, it will improve rendering of many manuals.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.44 2010/11/28 19:35:33 schwarze Exp $ */
d512 1
a512 1
	 * Remove prior ELINE macro, as it's being clobbering by a new
a518 16
		assert(MAN_TEXT != m->last->type);

		/*
		 * This occurs in the following construction:
		 *   .B
		 *   .br
		 *   .B
		 *   .br
		 *   I hate man macros.
		 * Flat-out disallow this madness.
		 */
		if (MAN_NSCOPED & man_macros[m->last->tok].flags) {
			man_pmsg(m, ln, ppos, MANDOCERR_SYNTLINESCOPE);
			return(0);
		}

d520 1
d522 3
a524 3
		assert(n);
		assert(NULL == n->child);
		assert(0 == n->nchild);
d526 2
a527 2
		if ( ! man_nmsg(m, n, MANDOCERR_LINESCOPE))
			return(0);
@


1.44
log
@To avoid FATAL errors, we have been parsing and ignoring the roff
requests .am, .ami, .am1, .dei, and .rm for a long time.
Since ignoring them can (rarely) cause information loss and serious
misformatting, throw an ERROR: NOT IMPLEMENTED when finding them.
Implementing them would not be too difficult, but they are so rare
in practice that i can find better use for my time right now.

In this context,
- Put the string "NOT IMPLEMENTED" into two other error messages
as well, to distinguish them from those caused by broken input.
- Print the string "unknown macro" once, not twice in the error message
associated with MANDOCERR_MACRO, and begin printing the buffer at the
point where the unknown macro really is, not at the start of line.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.43 2010/10/16 20:49:37 schwarze Exp $ */
d43 1
a43 1
	"in",		"TS",		"TE"
@


1.43
log
@Do not abort() on tbl errors, reduce the risk that tbl stuff kills a build,
and provide more useful tbl error messages in a non-intrusive way.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.42 2010/10/15 21:33:47 schwarze Exp $ */
d493 1
a493 3
		man_vmsg(m, MANDOCERR_MACRO, ln, ppos, 
		    "unknown macro: %s%s",
		    buf, strlen(buf) > 3 ? "..." : "");
@


1.42
log
@Move tbl output from plain stdio to mandoc terminal output routines.
This fixes (1) all escape sequences and (2) some aspects of indentation.
Table column widths are still way off, though.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.41 2010/10/15 20:45:03 schwarze Exp $ */
d138 4
a141 2
		return(tbl_read(n->data.TS, "<man>", ln, buf+offs,
		    strlen(buf+offs)) ? 1 : 0);
@


1.41
log
@Minimal glue to integrate tbl into the mandoc man(7) parser and formatter.
The output dosn't look nice yet, escape handling is still missing,
but will follow soon.
"move forward aggressively :-)" deraadt@@
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.40 2010/08/20 00:53:35 schwarze Exp $ */
d29 2
@


1.40
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.39 2010/08/18 01:17:44 schwarze Exp $ */
d29 2
d41 1
a41 1
	"in"
d126 1
d131 9
d337 2
@


1.39
log
@Simplify and sync the code and comments for copying the macro name
in man_pmacro() and mdoc_pmacro().  In particular, no need to use
isgraph(3) here, that has already been done in main.c.
Joint work by Kristaps and myself, ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.38 2010/07/25 18:05:54 schwarze Exp $ */
a54 1
static	int		 macrowarn(struct man *, int, const char *, int);
d92 1
a92 2
man_alloc(struct regset *regs, void *data, 
		int pflags, mandocmsg msg)
a99 1
	p->pflags = pflags;
a430 13
static int
macrowarn(struct man *m, int ln, const char *buf, int offs)
{
	int		 rc;

	rc = man_vmsg(m, MANDOCERR_MACRO, ln, offs, 
			"unknown macro: %s%s",
			buf, strlen(buf) > 3 ? "..." : "");

	return(MAN_IGN_MACRO & m->pflags ? rc : 0);
}


d473 5
a477 9
	if (j == 4 || j < 1) {
		if ( ! macrowarn(m, ln, mac, ppos))
			goto err;
		return(1);
	}
	
	if (MAN_MAX == (tok = man_hash_find(mac))) {
		if ( ! macrowarn(m, ln, mac, ppos))
			goto err;
@


1.38
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.37 2010/07/16 00:34:33 schwarze Exp $ */
a19 1
#include <ctype.h>
d479 4
a482 16
	/* Copy the first word into a nil-terminated buffer. */

	for (j = 0; j < 4; j++, i++) {
		if ('\0' == (mac[j] = buf[i]))
			break;
		else if (' ' == buf[i])
			break;

		/* Check for invalid characters. */

		if (isgraph((u_char)buf[i]))
			continue;
		if ( ! man_pmsg(m, ln, i, MANDOCERR_BADCHAR))
			return(0);
		i--;
	}
d484 3
@


1.37
log
@Text ending in a full stop, exclamation mark or question mark
should not flag the end of a sentence if:

1) The punctuation is followed by closing delimiters
and not preceded by alphanumeric characters, like in
"There is no full stop (.) in this sentence"

or

2) The punctuation is a child of a macro
and not preceded by alphanumeric characters, like in
"There is no full stop
.Pq \&.
in this sentence"

jmc@@ and sobrado@@ like this
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.36 2010/07/13 01:09:13 schwarze Exp $ */
d40 1
@


1.36
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.35 2010/06/27 21:54:42 schwarze Exp $ */
d408 1
a408 1
	if (mandoc_eos(buf, (size_t)i))
@


1.35
log
@Full .nr nS support, unbreaking the kernel manuals.

Kristaps coded this from scratch after reading my .nr patch;
it is simpler and more powerful.

Registers live in struct regset in regs.h, struct man and struct mdoc
contain pointers to it.  The nS register is cleared when parsing .Sh.
Frontends respect the MDOC_SYNPRETTY flag set in mdoc node_alloc.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.34 2010/06/06 18:08:41 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
a26 1
#include "regs.h"
@


1.34
log
@Merge bsd.lv release 1.10.0,
which is mostly the post-hackathon release,
bringing in the OpenBSD changes to bsd.lv,
but which also has a few additional minor fixes:

* .Lb is an in-line macro, not in_line_eoln
* .Bt, .Ud now warn when discarding arguments
* allow bad -man dates to flow verbatim into the front-ends
- so far all reported by Ulrich Spoerlein
* .Ar, .Fl and .Li starting with closing punctuation emit an empty element
* empty .Li macros print nothing, but may cause spacing
* proper EOS handling for .Bt, .Ex, .Rv, and .Ud.
* cleanup: collapse posts_xr into posts_wtext (which is the same)
* efficiency: very simple table lookup for roff.c
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.33 2010/05/23 22:45:00 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d27 1
d94 2
a95 1
man_alloc(void *data, int pflags, mandocmsg msg)
d105 1
@


1.33
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.32 2010/05/23 20:57:16 schwarze Exp $ */
d145 2
@


1.32
log
@implement .AT and .UC; from Joerg Sonnenberger
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.31 2010/05/20 00:58:02 schwarze Exp $ */
d26 1
a29 23
const	char *const __man_merrnames[WERRMAX] = {		 
	"invalid character", /* WNPRINT */
	"invalid date format", /* WDATE */
	"scope of prior line violated", /* WLNSCOPE */
	"over-zealous prior line scope violation", /* WLNSCOPE2 */
	"trailing whitespace", /* WTSPACE */
	"unterminated quoted parameter", /* WTQUOTE */
	"document has no body", /* WNODATA */
	"document has no title/section", /* WNOTITLE */
	"invalid escape sequence", /* WESCAPE */
	"invalid number format", /* WNUMFMT */
	"expected block head arguments", /* WHEADARGS */
	"expected block body arguments", /* WBODYARGS */
	"expected empty block head", /* WNHEADARGS */
	"ill-formed macro", /* WMACROFORM */
	"scope open on exit", /* WEXITSCOPE */
	"no scope context", /* WNOSCOPE */
	"literal context already open", /* WOLITERAL */
	"no literal context open", /* WNLITERAL */
	"document title should be uppercase", /* WTITLECASE */
	"deprecated comment style", /* WBADCOMMENT */
};

d93 1
a93 1
man_alloc(void *data, int pflags, const struct man_cb *cb)
a98 3
	if (cb)
		memcpy(&p->cb, cb, sizeof(struct man_cb));

d102 1
d350 1
a350 1
		return(man_pwarn(m, line, offs, WBADCOMMENT));
d382 1
a382 1
			if ( ! man_pwarn(m, line, i - 1, WTSPACE))
d416 1
a416 1
		if ( ! man_unscope(m, m->last->parent, WERRMAX))
d424 1
a424 1
	if ( ! man_unscope(m, m->last->parent, WERRMAX))
d433 7
a439 5
	if ( ! (MAN_IGN_MACRO & m->pflags))
		return(man_verr(m, ln, offs, "unknown macro: %s%s", 
				buf, strlen(buf) > 3 ? "..." : ""));
	return(man_vwarn(m, ln, offs, "unknown macro: %s%s",
				buf, strlen(buf) > 3 ? "..." : ""));
d487 3
a489 1
		return(man_perr(m, ln, i, WNPRINT));
d495 1
a495 5
		if ( ! (MAN_IGN_MACRO & m->pflags)) {
			(void)man_perr(m, ln, ppos, WMACROFORM);
			goto err;
		} 
		if ( ! man_pwarn(m, ln, ppos, WMACROFORM))
d517 1
a517 1
		if ( ! man_pwarn(m, ln, i - 1, WTSPACE))
d539 4
a542 2
		if (MAN_NSCOPED & man_macros[m->last->tok].flags)
			return(man_perr(m, ln, ppos, WLNSCOPE));
d550 1
a550 1
		if ( ! man_nwarn(m, n, WLNSCOPE))
d607 1
a607 1
	if ( ! man_unscope(m, m->last->parent, WERRMAX))
d619 2
a620 17
man_verr(struct man *man, int ln, int pos, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == man->cb.man_err)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*man->cb.man_err)(man->data, ln, pos, buf));
}


int
man_vwarn(struct man *man, int ln, int pos, const char *fmt, ...)
a624 3
	if (NULL == man->cb.man_warn)
		return(0);

d626 1
a626 1
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
d628 1
a628 16
	return((*man->cb.man_warn)(man->data, ln, pos, buf));
}


int
man_err(struct man *m, int line, int pos, int iserr, enum merr type)
{
	const char	 *p;
	
	p = __man_merrnames[(int)type];
	assert(p);

	if (iserr)
		return(man_verr(m, line, pos, p));

	return(man_vwarn(m, line, pos, p));
@


1.31
log
@Support nested roff instructions:
* allow roff_parseln() to be re-run
* allow roff_parseln() to manipulate the line buffer offset
* support the offset in the man and mdoc libraries
* adapt .if, .ie, .el, .ig, .am* and .de* support
* interpret some instructions even in conditional-negative context
Coded by kristaps during the last day of the mandoc hackathon.

To avoid regressions in the OpenBSD tree, commit this together
with some small local additions:
* detect roff block end "\}" even on macro lines
* actually implement the ".if n" conditional
* ignore .ds, .rm and .tr in libroff

Also back my old .if/.ie/.el-handling out of libman, reverting:
man.h 1.15 man.c 1.25 man_macro.c 1.15 man_validate.c 1.19
man_action.c 1.15 man_term.c 1.28 man_html.c 1.9.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.30 2010/05/16 00:54:03 schwarze Exp $ */
d61 1
a61 1
	"Sp",		"Vb",		"Ve",
@


1.30
log
@In theory, Kristaps never intended to write a roff parser,
but in practice, most real legacy man(7)uals are using so much
low level roff that we can't really get away without at least
partially handling some roff instructions.

As doing this in man(7) only has become messy and as even some
mdoc(7) pages need it, start a minimal partial roff preprocessor.
As a first step, move handling of .am[i], .de[i] and .ig there.
Do not use the roff preprocessor for new manuals!

Now that we have three main parser libraries - roff, man and mdoc -
each one having its own error handling is becoming messy, too.
Thus, start unifying message handling in one central place,
introducing a new generic function mmsg().

coded by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.29 2010/05/15 18:06:02 schwarze Exp $ */
a61 1
	"if",		"ie",		"el",
d73 2
a74 2
static	int		 man_ptext(struct man *, int, char *);
static	int		 man_pmacro(struct man *, int, char *);
d77 1
a77 1
static	int		 macrowarn(struct man *, int, const char *);
d147 1
a147 1
man_parseln(struct man *m, int ln, char *buf)
a148 11
	char		*p;
	size_t		 len;
	int		 brace_close = 0;

	if ((len = strlen(buf)) > 1) {
		p = buf + (len - 2);
		if (p[0] == '\\' && p[1] == '}') {
			brace_close = 1;
			*p = '\0';
		}
	}
d150 2
a151 7
	if ('.' == *buf || '\'' == *buf) {
		if ( ! man_pmacro(m, ln, buf))
			return(0);
	} else {
		if ( ! man_ptext(m, ln, buf))
			return(0);
	}
d153 3
a155 1
	return(brace_close ? man_brace_close(m, ln, len-2) : 1);
d365 1
a365 1
man_ptext(struct man *m, int line, char *buf)
d371 4
a374 2
	if ('\\' == buf[0] && '.' == buf[1] && '\"' == buf[2])
		return(man_pwarn(m, line, 0, WBADCOMMENT));
d379 1
a379 1
		if ( ! man_word_alloc(m, line, 0, buf))
d386 1
a386 1
	for (i = 0; ' ' == buf[i]; i++)
d391 1
a391 1
		if ( ! man_word_alloc(m, line, 0, ""))
d418 1
a418 1
	if ( ! man_word_alloc(m, line, 0, buf))
a427 1

d450 1
a450 1
	return(man_body_alloc(m, line, 0, m->last->tok));
d455 1
a455 1
macrowarn(struct man *m, int ln, const char *buf)
d458 1
a458 1
		return(man_verr(m, ln, 0, "unknown macro: %s%s", 
d460 1
a460 1
	return(man_vwarn(m, ln, 0, "unknown macro: %s%s",
d466 1
a466 1
man_pmacro(struct man *m, int ln, char *buf)
d475 3
a477 1
	if ('\0' == buf[1])
d480 1
a480 1
	i = 1;
d525 1
a525 1
		if ( ! macrowarn(m, ln, mac))
d631 1
a631 1
	return(man_body_alloc(m, ln, 0, m->last->tok));
@


1.29
log
@removed restriction on integer manual sections in -man;
by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.28 2010/05/14 19:52:43 schwarze Exp $ */
a47 2
	"invalid nesting of roff declarations", /* WROFFNEST */
	"scope in roff instructions broken", /* WROFFSCOPE */
d61 2
a62 3
	"Sp",		"Vb",		"Ve",		"de",
	"dei",		"am",		"ami",		"ig",
	".",		"if",		"ie",		"el",
a559 3
	 * NOTE: we don't allow roff blocks (NOCLOSE) to be embedded
	 * here because that would stipulate blocks as children of
	 * elements!
@


1.28
log
@Integrate kristaps@@' end-of-sentence (EOS) framework
which is simpler and more powerful than mine, and remove mine.

* man(7) now has EOS handling, too
* put EOS detection into its own function in libmandoc
* use node and termp flags to communicate the EOS condition
* no more EOS pseudo-macro
* no more non-printable EOS marker character on the formatter level

This slightly breaks EOS detection after trailing punctuation
in mdoc(7) macros, but that will be restored soon.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.27 2010/05/14 01:54:37 schwarze Exp $ */
a30 1
	"invalid manual section", /* WMSEC */
d189 2
@


1.27
log
@merge 1.9.24, keeping local patches; some changes:
* preserve multiple consecutive space characters in input
* do not restrict .Cd and .Rv to certain sections (requested by Joerg)
* do not run lookup() on quoted words
* enum return types for mdoc_args and mdoc_argv
* fix auto-closing of LINK tag in -Txhtml (from Daniel Friesel)
* various lint and manual fixes
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.26 2010/05/08 01:52:07 schwarze Exp $ */
d435 11
@


1.26
log
@handle text lines beginning with \." as comments, like groff does,
even though this is not correct comment syntax (so warn, too)
reported by Claus Assmann on misc@@, fix by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.25 2010/04/25 16:32:19 schwarze Exp $ */
a81 2
static	int		 pstring(struct man *, int, int, 
				const char *, size_t);
d332 2
a333 3
static int
pstring(struct man *m, int line, int pos, 
		const char *p, size_t len)
d336 3
a338 1
	size_t		 sv;
d342 1
a342 1
	sv = strlcpy(n->string, p, len + 1);
d349 1
a354 8
int
man_word_alloc(struct man *m, int line, int pos, const char *word)
{

	return(pstring(m, line, pos, word, strlen(word)));
}


d384 1
a384 2
	int		 i, j;
	char		 sv;
d399 1
a399 1
	/* First de-chunk and allocate words. */
d405 2
a406 5
		/* Trailing whitespace? */
		if (i && ' ' == buf[i - 1])
			if ( ! man_pwarn(m, line, i - 1, WTSPACE))
				return(0);
		if ( ! pstring(m, line, 0, &buf[i], 0))
d411 4
a414 10
	for (j = i; buf[i]; i++) {
		if (' ' != buf[i])
			continue;

		/* Escaped whitespace. */
		if (i && ' ' == buf[i] && '\\' == buf[i - 1])
			continue;

		sv = buf[i];
		buf[i++] = '\0';
d416 2
a417 4
		if ( ! pstring(m, line, j, &buf[j], (size_t)(i - j)))
			return(0);

		/* Trailing whitespace?  Check at overwritten byte. */
d419 2
a420 1
		if (' ' == sv && '\0' == buf[i])
d424 2
a425 2
		for ( ; ' ' == buf[i]; i++)
			/* Skip trailing whitespace. */ ;
d427 2
a428 1
		j = i;
d430 1
a430 8
		/* Trailing whitespace? */

		if (' ' == buf[i - 1] && '\0' == buf[i])
			if ( ! man_pwarn(m, line, i - 1, WTSPACE))
				return(0);

		if ('\0' == buf[i])
			break;
d433 1
a433 1
	if (j != i && ! pstring(m, line, j, &buf[j], (size_t)(i - j)))
a436 1

d463 1
a463 2
		return(man_verr(m, ln, 0, 
				"unknown macro: %s%s", 
d489 1
d538 4
a541 1
	/* Trailing whitespace? */
@


1.25
log
@Implement roff conditional instructions .if .ie .el, in man(7) only for now;
fixing OpenBSD::PackageName(3p) and friends for espie@@.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.24 2010/04/02 11:37:07 schwarze Exp $ */
d52 1
d394 5
@


1.24
log
@merge 1.9.20, keeping local patches
* prevent roff instructions in man(7) from clobbering scopes and line modes
  (noted by Sascha Wildner)
* handle leading punctuation in mdoc(7) blocks and line macros
  (looks good in principle, but is causing some fallout in OpenBSD,
   so i will disable it locally for now with the next commit)
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.23 2010/03/29 22:56:52 schwarze Exp $ */
d65 1
a65 1
	".",
d155 19
d175 1
a175 3
	return('.' == *buf || '\'' == *buf ? 
			man_pmacro(m, ln, buf) : 
			man_ptext(m, ln, buf));
@


1.23
log
@merge 1.9.19, keeping local patches
 * scoping fixes for roff instructions
 * accept apostroph in place of dot as a macro control character
 * accept tabs between the control character and the macro name
 * check that man(7) .TH titles use capital letters
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.22 2010/03/26 01:22:05 schwarze Exp $ */
d477 1
a477 1
	int		 i, j, ppos, fl;
a483 2
	fl = m->flags;

d551 3
d585 10
a594 1
	/* Begin recursive parse sequence. */
a596 1

a603 3
	 *
	 * FIXME: this prohibits the nesting of blocks (e.g., `de' and
	 * family) within BLINE or ELINE systems.  This is annoying.
d606 1
a606 1
	if ( ! (MAN_BLINE & fl)) {
d610 1
@


1.22
log
@merge 1.9.17, keeping local patches

* much improved pod2man support and low-level roff robustness
* have -Tlint imply -Wall and -fstrict
* use fewer macros and more enum in libman
* and various bug fixes
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.21 2010/03/25 23:23:01 schwarze Exp $ */
d50 2
d156 1
a156 1
	return('.' == *buf ? 
d448 1
a448 1
		if ( ! man_unscope(m, m->last->parent))
d456 1
a456 1
	if ( ! man_unscope(m, m->last->parent))
d491 5
a495 1
	if (' ' == buf[i]) {
d497 1
a497 1
		while (buf[i] && ' ' == buf[i])
d628 1
a628 1
	if ( ! man_unscope(m, m->last->parent))
@


1.21
log
@merge 1.9.16, keeping local patches

This is mostly cleanup by kristaps@@ after my rather hackish patch
to tolerate the non-text macros .na, .sp, .br in next-line scope;
plus some nesting issues fixed by him, all in man(7).
This survived a full  cd /usr/src; make man.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.20 2010/03/02 01:00:39 schwarze Exp $ */
d48 2
a49 1
	"no literal context open" /* WNLITERAL */
d61 3
a63 1
	"Sp",		"Vb",		"Ve",
d69 1
a69 1
				enum man_type, int);
d72 3
d165 1
a165 1
		man_node_freelist(man->first);
d184 1
d212 1
d249 1
a249 1
man_node_alloc(int line, int pos, enum man_type type, int tok)
d263 1
a263 1
man_elem_alloc(struct man *m, int line, int pos, int tok)
d276 1
a276 1
man_head_alloc(struct man *m, int line, int pos, int tok)
d289 1
a289 1
man_body_alloc(struct man *m, int line, int pos, int tok)
d302 1
a302 1
man_block_alloc(struct man *m, int line, int pos, int tok)
d321 1
a321 1
	n = man_node_alloc(line, pos, MAN_TEXT, -1);
d343 5
a347 1
void
a352 2
	if (p->parent)
		p->parent->nchild--;
d358 1
a358 1
man_node_freelist(struct man_node *p)
a359 1
	struct man_node	*n;
d361 4
a364 4
	if (p->child)
		man_node_freelist(p->child);
	assert(0 == p->nchild);
	n = p->next;
a365 2
	if (n)
		man_node_freelist(n);
d475 2
a476 1
	int		 i, j, c, ppos, fl;
d526 1
a526 1
	if (MAN_MAX == (c = man_hash_find(mac))) {
d549 1
a549 1
	if ( ! (MAN_NSCOPED & man_macros[c].flags) &&
d574 1
a574 2
		man_node_unlink(m, n);
		man_node_free(n);
d580 1
a580 1
	assert(man_macros[c].fp);
d582 1
a582 1
	if ( ! (*man_macros[c].fp)(m, c, ln, ppos, &i, buf))
d589 3
d680 5
a684 1
void
d688 3
a690 1
	if (n->prev) {
d692 17
a708 2
		if (m->last == n) {
			assert(NULL == n->next);
d711 1
a711 5
		}
	} else {
		n->parent->child = n->next;
		if (m->last == n) {
			assert(NULL == n->next);
d717 2
a718 2
	if (n->next)
		n->next->prev = n->prev;
@


1.20
log
@Accept the non-standard macros .Sp (similar to .sp)
and .Vb/.Ve (similar to .nf/.fi) in man(7) mode.
These are not intended to be used manually, but they allow us to
properly render man(7) code autogenerated by pod2man(1),
making Perl and OpenSSL happy in our tree.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.19 2010/02/26 12:42:29 schwarze Exp $ */
d34 1
d535 21
a555 1
	/* Remove prior ELINE macro, if applicable. */
a556 1
	if (m->flags & MAN_ELINE) {
d558 2
d562 1
d566 1
a566 13
		if (n->prev) {
			assert(n != n->parent->child);
			assert(n == n->prev->next);
			n->prev->next = NULL;
			m->last = n->prev;
			m->next = MAN_NEXT_SIBLING;
		} else {
			assert(n == n->parent->child);
			n->parent->child = NULL;
			m->last = n->parent;
			m->next = MAN_NEXT_CHILD;
		}

d579 7
a585 2
	if ( ! (MAN_BLINE & fl) || (MAN_TEXT != m->last->type &&
	    (NULL == m->last->child || MAN_TEXT != m->last->child->type)))
d587 11
d667 25
@


1.19
log
@The groff_man(7) manual says "the first line of text following" .TP is
used as a label, not "the first line following", so allow (some kinds of)
intervening macros - some people actually put macros in between.

On the other hand, when there is no text line before the next block macro,
that is, when the .TP block ends without any text line, then something *is*
broken, so still error out in that case.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.18 2010/02/18 02:11:26 schwarze Exp $ */
d58 2
a59 1
	"RS",		"DT",		"UC",		"PD"
@


1.18
log
@sync to release 1.9.15:
 * corrected .Vt handling (spotted by Joerg Sonnenberger)
 * corrected .Xr argument handling (based on my patch)
 * removed \\ escape sequence (because it is for low-level roff only)
 * warn about trailing whitespace (suggested by jmc@@)
 * -Txhtml support
 * and some general cleanup and doc improvements
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.17 2009/12/23 22:30:17 schwarze Exp $ */
d567 2
a568 1
	if ( ! (MAN_BLINE & fl))
@


1.17
log
@sync to 1.9.13: minor fixes:

correctness/functionality:
 - bugfix: properly ignore lines with only a dot in -man
 - bugfix: .Bl -ohang doesn't allow -width, warn about this
 - improve date string handling by new function mandoc_a2time
 - some HTML improvements
 - significant documentation additions in man.7 and mdoc.7

portability:
 - replace __dead by __attribute__((noreturn))
 - bugfix: correct .Dx rendering
 - some more library names for NetBSD

simplicity:
 - replace hand-rolled putchar(3)-loops by fwrite(3)
 - replace single-character printf(3) by putchar(3)
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.16 2009/12/22 23:58:00 schwarze Exp $ */
d364 1
d378 6
a383 1
	if (0 == buf[i]) {
d397 3
a399 1
		buf[i++] = 0;
d403 6
d413 8
a420 1
		if (0 == buf[i])
d483 1
a483 1
		if (0 == buf[i])
d492 1
a492 1
		if (0 == (mac[j] = buf[i]))
d526 6
@


1.16
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.15 2009/10/27 21:40:07 schwarze Exp $ */
d453 2
a454 2
	if (0 == buf[1])
		goto out;
d483 1
a483 1
	mac[j] = 0;
@


1.15
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.14 2009/10/19 10:20:24 schwarze Exp $ */
d27 1
a30 1
	"system: malloc error", /* WNMEM */
d70 1
a70 1
static	int		 man_alloc1(struct man *);
d92 1
a92 1
int
d97 1
a97 1
	return(man_alloc1(man));
d115 1
a115 2
	if (NULL == (p = calloc(1, sizeof(struct man))))
		return(NULL);
d117 2
a118 4
	if ( ! man_alloc1(p)) {
		free(p);
		return(NULL);
	}
a120 1

d123 2
a124 1
	(void)memcpy(&p->cb, cb, sizeof(struct man_cb));
d167 1
a167 1
static int
d171 1
a171 1
	bzero(&m->meta, sizeof(struct man_meta));
d173 1
a173 3
	m->last = calloc(1, sizeof(struct man_node));
	if (NULL == m->last)
		return(0);
a176 1
	return(1);
d243 1
a243 4
	p = calloc(1, sizeof(struct man_node));
	if (NULL == p)
		return(NULL);

a257 2
	if (NULL == p)
		return(0);
a270 2
	if (NULL == p)
		return(0);
a283 2
	if (NULL == p)
		return(0);
a296 2
	if (NULL == p)
		return(0);
d312 1
a312 9
	if (NULL == n)
		return(0);

	n->string = malloc(len + 1);
	if (NULL == n->string) {
		free(n);
		return(0);
	}

@


1.14
log
@sync to 1.9.6: u_char lives in <sys/types.h>
noticed by uqs at spoerlein dot net on FreeBSD,
where <stdlib.h> does not include <sys/types.h>
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.13 2009/09/21 21:11:37 schwarze Exp $ */
a42 1
	"unknown macro", /* WMACRO */
d58 1
a58 1
	"RS",		"DT",		"UC"
d73 1
d455 12
d521 1
a521 5
		if ( ! (MAN_IGN_MACRO & m->pflags)) {
			(void)man_perr(m, ln, ppos, WMACRO);
			goto err;
		} 
		if ( ! man_pwarn(m, ln, ppos, WMACRO))
@


1.13
log
@sync to 1.9.5: lookup hashes are now static tables
shortening the code, and, according to kristaps@@, speeding it up
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.12 2009/09/18 22:46:14 schwarze Exp $ */
d17 2
@


1.12
log
@sync to 1.9.2: Add .UC libman macro for compatibility, has no effect.
Correct .UC and .DT to not print their arguments.
Document that .UC and .DT should not be used.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.11 2009/09/18 22:37:05 schwarze Exp $ */
a103 3

	if (man->htab)
		man_hash_free(man->htab);
d121 2
a125 5

	if (NULL == (p->htab = man_hash_alloc())) {
		free(p);
		return(NULL);
	}
d506 1
a506 1
	if (MAN_MAX == (c = man_hash_find(m->htab, mac))) {
@


1.11
log
@sync to 1.9.2: non-printable characters in macro names are errors;
from joerg at netbsd dot org
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.10 2009/08/22 23:17:39 schwarze Exp $ */
d57 1
a57 1
	"RS",		"DT"
@


1.10
log
@another large chunk of -man updates,
among others regarding .DT, .HP, .RS, .RE, .SH, .SS, and scoping,
now in sync vith release 1.9.1
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.9 2009/08/22 20:14:37 schwarze Exp $ */
d492 6
@


1.9
log
@Kristaps@@ significantly overhauled libman.
I'm committing this in one large chunk because in contrast to -mdoc, -man
is mostly untested in OpenBSD anyway, so any fallout can be fixed in-tree.
Among others, improved support for .IP, .HP, and .TP.
Now in sync with release 1.9.0.
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.8 2009/08/22 15:15:37 schwarze Exp $ */
d43 4
a46 1
	"scope open on exit" /* WEXITSCOPE */
d56 2
a57 1
	"nf",		"fi",		"r"
d70 2
d266 1
a266 1
man_elem_alloc(struct man *man, int line, int pos, int tok)
d273 4
a276 1
	return(man_node_append(man, p));
d325 3
a327 3
int
man_word_alloc(struct man *man, 
		int line, int pos, const char *word)
d329 2
a330 1
	struct man_node	*p;
d332 7
a338 2
	p = man_node_alloc(line, pos, MAN_TEXT, -1);
	if (NULL == p)
d340 8
a347 1
	if (NULL == (p->string = strdup(word)))
d349 10
a358 1
	return(man_node_append(man, p));
d377 1
a380 3
	if (p->next)
		man_node_freelist(p->next);

d382 1
d384 2
d392 19
d412 19
a430 1
	/* First allocate word. */
d432 1
a432 1
	if ( ! man_word_alloc(m, line, 0, buf))
d434 2
a435 1
	m->next = MAN_NEXT_SIBLING;
a442 2
	/* XXX - this should be in man_action.c. */

d462 3
a464 2
	int		  i, j, c, ppos, fl;
	char		  mac[5];
d521 26
a566 2

	/* XXX - this should be in man_action.c. */
@


1.8
log
@sync to 1.8.4: support .sp in -man
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.7 2009/07/12 20:30:27 schwarze Exp $ */
d38 6
d52 2
a53 1
	"RI",		"na",		"i",		"sp"
d209 16
d272 45
d361 2
d368 3
a370 3
	 * If this is one of the zany NLINE macros that consumes the
	 * next line of input as being influenced, then close out the
	 * existing macro "scope" and continue processing.
d373 9
a381 1
	if ( ! (MAN_NLINE & m->flags))
d383 1
d385 1
a385 5
	m->flags &= ~MAN_NLINE;
	m->last = m->last->parent;

	assert(MAN_ROOT != m->last->type);
	if ( ! man_valid_post(m))
d387 1
a387 4
	if ( ! man_action_post(m))
		return(0);

	return(1);
a395 1
	struct man_node	 *n;
d399 1
a399 2
	n = m->last;
	fl = MAN_NLINE & m->flags;
d429 1
a429 2
			(void)man_verr(m, ln, ppos, 
				"ill-formed macro: %s", mac);
d432 1
a432 2
		if ( ! man_vwarn(m, ln, ppos, 
				"ill-formed macro: %s", mac))
d439 1
a439 2
			(void)man_verr(m, ln, ppos, 
				"unknown macro: %s", mac);
d442 1
a442 2
		if ( ! man_vwarn(m, ln, ppos, 
				"unknown macro: %s", mac))
d454 3
a456 1
	if ( ! man_macro(m, c, ln, ppos, &i, buf))
d460 12
a471 9
	if (fl) {
		/*
		 * A NLINE macro has been immediately followed with
		 * another.  Close out the preceding macro's scope, and
		 * continue.
		 */
		assert(MAN_ROOT != m->last->type);
		assert(m->last->parent);
		assert(MAN_ROOT != m->last->parent->type);
d473 1
a473 2
		if (n != m->last)
			m->last = m->last->parent;
d475 2
a476 7
		if ( ! man_valid_post(m))
			return(0);
		if ( ! man_action_post(m))
			return(0);
		m->next = MAN_NEXT_SIBLING;
		m->flags &= ~MAN_NLINE;
	} 
d478 3
a480 1
	return(1);
@


1.7
log
@sync to 1.7.23: unify the various "enum merr" into libman.h and libmdoc.h,
use it as a new argument to mdoc_err(), the same way as for for man_err(),
and use string tables instead of switch statements to select error messages
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.6 2009/07/07 00:54:46 schwarze Exp $ */
d37 1
d46 1
a46 1
	"RI",		"na",		"i"
@


1.6
log
@sync to 1.7.21: provide WESCAPE and MAN_IGN_ESCAPE,
to be used soon in man_validate.c
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.5 2009/06/23 22:31:26 schwarze Exp $ */
d26 13
d454 1
a454 2
man_err(struct man *m, int line, int pos, 
		int iserr, enum merr type)
d458 1
a458 33
	p = NULL;
	switch (type) {
	case (WNPRINT):
		p = "invalid character";
		break;
	case (WNMEM):
		p = "memory exhausted";
		break;
	case (WMSEC):
		p = "invalid manual section";
		break;
	case (WDATE):
		p = "invalid date format";
		break;
	case (WLNSCOPE):
		p = "scope of prior line violated";
		break;
	case (WTSPACE):
		p = "trailing whitespace at end of line";
		break;
	case (WTQUOTE):
		p = "unterminated quotation";
		break;
	case (WNODATA):
		p = "document has no data";
		break;
	case (WNOTITLE):
		p = "document has no title/section";
		break;
	case (WESCAPE):
		p = "invalid escape sequence";
		break;
	}
@


1.5
log
@sync to 1.7.20: root and text validation for -man
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.4 2009/06/23 22:05:42 schwarze Exp $ */
d474 3
@


1.4
log
@sync to 1.7.20: error reporting functions for -man
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.3 2009/06/18 23:34:53 schwarze Exp $ */
d185 2
d255 2
d270 1
@


1.3
log
@sync to 1.7.19: improved comment handling
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.2 2009/06/14 23:00:57 schwarze Exp $ */
d435 43
@


1.2
log
@sync to 1.7.16: comments, whitespace and spelling fixes; no functional change
@
text
@d1 1
a1 1
/*	$Id: man.c,v 1.19 2009/06/10 20:18:43 kristaps Exp $ */
d27 1
a27 1
	"\\\"",		"TH",		"SH",		"SS",
d32 1
a32 1
	"RI",		"br",		"na",		"i"
a325 4

	if (buf[i] && '\\' == buf[i])
		if (buf[i + 1] && '\"' == buf[i + 1])
			goto out;
@


1.1
log
@Initial check-in of mandoc for formatting manuals. ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: man.c,v 1.16 2009/04/05 16:34:22 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d380 1
a380 1
		 * another.  Close out the preceeding macro's scope, and
@

