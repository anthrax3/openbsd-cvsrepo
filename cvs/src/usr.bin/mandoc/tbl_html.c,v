head	1.15;
access;
symbols
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.10
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4;
locks; strict;
comment	@ * @;


1.15
date	2017.02.05.18.13.28;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	LLN2XeSKb4BTOEt6;

1.14
date	2017.01.17.01.47.46;	author schwarze;	state Exp;
branches;
next	1.13;
commitid	Nv06v3QGWa6dYYKr;

1.13
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	Ql2ha5NS80pwfGNT;

1.12
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.11;
commitid	hxQV8O1pNUaef4ir;

1.11
date	2015.01.30.17.31.20;	author schwarze;	state Exp;
branches;
next	1.10;
commitid	8uPgte1HahL1XRHj;

1.10
date	2015.01.30.04.08.37;	author schwarze;	state Exp;
branches;
next	1.9;
commitid	KL58yWbJhw6UbgSB;

1.9
date	2015.01.30.02.08.37;	author schwarze;	state Exp;
branches;
next	1.8;
commitid	vvSu12hfLARx94BX;

1.8
date	2014.10.14.02.16.02;	author schwarze;	state Exp;
branches;
next	1.7;
commitid	CvxMGBcRTJn11Q3v;

1.7
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2012.05.26.20.03.34;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.16.19.41.16;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2011.01.16.01.11.50;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2011.01.09.14.30.48;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Improve <table> syntax:
The <col> element can only appear inside <colgroup>, so use <colgroup>.
The <tbody> element is optional and useless, so don't use it.
Even if we would ever need <thead> or <tfoot>, <tbody> would still be
optional and useless; besides, we will likely never need <thead> or <tfoot>,
simply because our languages don't support such functionality.
@
text
@/*	$OpenBSD: tbl_html.c,v 1.14 2017/01/17 01:47:46 schwarze Exp $ */
/*
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2014, 2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc.h"
#include "out.h"
#include "html.h"

static	void	 html_tblopen(struct html *, const struct tbl_span *);
static	size_t	 html_tbl_len(size_t, void *);
static	size_t	 html_tbl_strlen(const char *, void *);


static size_t
html_tbl_len(size_t sz, void *arg)
{

	return sz;
}

static size_t
html_tbl_strlen(const char *p, void *arg)
{

	return strlen(p);
}

static void
html_tblopen(struct html *h, const struct tbl_span *sp)
{
	struct tag	*t;
	int		 ic;

	if (h->tbl.cols == NULL) {
		h->tbl.len = html_tbl_len;
		h->tbl.slen = html_tbl_strlen;
		tblcalc(&h->tbl, sp, 0);
	}

	assert(NULL == h->tblt);
	h->tblt = print_otag(h, TAG_TABLE, "c", "tbl");

	t = print_otag(h, TAG_COLGROUP, "");
	for (ic = 0; ic < sp->opts->cols; ic++)
		print_otag(h, TAG_COL, "shw", h->tbl.cols[ic].width);
	print_tagq(h, t);
}

void
print_tblclose(struct html *h)
{

	assert(h->tblt);
	print_tagq(h, h->tblt);
	h->tblt = NULL;
}

void
print_tbl(struct html *h, const struct tbl_span *sp)
{
	const struct tbl_dat *dp;
	struct tag	*tt;
	int		 ic;

	/* Inhibit printing of spaces: we do padding ourselves. */

	if (h->tblt == NULL)
		html_tblopen(h, sp);

	assert(h->tblt);

	h->flags |= HTML_NONOSPACE;
	h->flags |= HTML_NOSPACE;

	tt = print_otag(h, TAG_TR, "");

	switch (sp->pos) {
	case TBL_SPAN_HORIZ:
	case TBL_SPAN_DHORIZ:
		print_otag(h, TAG_TD, "?", "colspan", "0");
		break;
	default:
		dp = sp->first;
		for (ic = 0; ic < sp->opts->cols; ic++) {
			print_stagq(h, tt);
			print_otag(h, TAG_TD, "");

			if (dp == NULL || dp->layout->col > ic)
				continue;
			if (dp->layout->pos != TBL_CELL_DOWN)
				if (dp->string != NULL)
					print_text(h, dp->string);
			dp = dp->next;
		}
		break;
	}

	print_tagq(h, tt);

	h->flags &= ~HTML_NONOSPACE;

	if (sp->next == NULL) {
		assert(h->tbl.cols);
		free(h->tbl.cols);
		h->tbl.cols = NULL;
		print_tblclose(h);
	}

}
@


1.14
log
@Simplify the usage of print_otag() by making it accept a variable
number of arguments.

Delete struct htmlpair and all the PAIR_*() macros.
Delete enum htmlattr, handle that in print_otag() instead.

Minus 190 lines of code; no functional change except better ordering
of attributes (class before style) in three cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_html.c,v 1.13 2015/10/12 00:07:27 schwarze Exp $ */
d51 1
d63 1
d66 1
a66 2

	print_otag(h, TAG_TBODY, "");
@


1.13
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_html.c,v 1.12 2015/10/06 18:30:44 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
a50 3
	struct htmlpair	 tag;
	struct roffsu	 su;
	struct roffcol	*col;
d60 1
a60 2
	PAIR_CLASS_INIT(&tag, "tbl");
	h->tblt = print_otag(h, TAG_TABLE, 1, &tag);
d62 2
a63 8
	for (ic = 0; ic < sp->opts->cols; ic++) {
		bufinit(h);
		col = h->tbl.cols + ic;
		SCALE_HS_INIT(&su, col->width);
		bufcat_su(h, "width", &su);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_COL, 1, &tag);
	}
d65 1
a65 1
	print_otag(h, TAG_TBODY, 0, NULL);
a80 1
	struct htmlpair	 tag;
d94 1
a94 1
	tt = print_otag(h, TAG_TR, 0, NULL);
d99 1
a99 2
		PAIR_INIT(&tag, ATTR_COLSPAN, "0");
		print_otag(h, TAG_TD, 1, &tag);
d105 1
a105 1
			print_otag(h, TAG_TD, 0, NULL);
@


1.12
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_html.c,v 1.11 2015/01/30 17:31:20 schwarze Exp $ */
a108 1
		/* FALLTHROUGH */
@


1.11
log
@Delete the redundant tbl span flags, just inspect the actual data
where needed, which is less fragile.
This fixes a subtle NULL pointer access to tp->tbl.cols:
Due to a bug in the man(7) parser, the first span of a table can
end up in a .TP head, in which case tblcalc() was never called.
Found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_html.c,v 1.10 2015/01/30 04:08:37 schwarze Exp $ */
d4 1
d38 1
a38 1
	return(sz);
d45 1
a45 1
	return(strlen(p));
@


1.10
log
@Abolish struct tbl_head and replace it by an "int col" member in
struct tbl_cell.  No functional change, minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_html.c,v 1.9 2015/01/30 02:08:37 schwarze Exp $ */
d55 1
a55 1
	if (sp->flags & TBL_SPAN_FIRST) {
d133 1
a133 1
	if (sp->flags & TBL_SPAN_LAST) {
@


1.9
log
@Auditing the tbl(7) code for more NULL pointer accesses, i came out
empty-handed; so this is just KNF and some code simplifications,
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tbl_html.c,v 1.8 2014/10/14 02:16:02 schwarze Exp $ */
a49 1
	const struct tbl_head *hp;
d53 1
d65 1
a65 1
	for (hp = sp->head; hp; hp = hp->next) {
d67 1
a67 1
		col = &h->tbl.cols[hp->ident];
a88 1
	const struct tbl_head *hp;
d92 1
d115 1
a115 1
		for (hp = sp->head; hp; hp = hp->next) {
d119 2
a120 2
			if (dp == NULL)
				break;
@


1.8
log
@Rudimentary implementation of the e, x, and z table layout modifiers
to equalize, maximize, and ignore the width of columns.
Does not yet take vertical rulers into account,
and does not do line breaks within table cells.
Considerably improves the lftp(1) manual; issue noticed by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d55 1
a55 1
	if (TBL_SPAN_FIRST & sp->flags) {
d96 1
a96 1
	if (NULL == h->tblt)
d119 1
a119 1
			if (NULL == dp)
d121 2
a122 2
			if (TBL_CELL_DOWN != dp->layout->pos)
				if (dp->string)
d133 1
a133 1
	if (TBL_SPAN_LAST & sp->flags) {
@


1.7
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: tbl_html.c,v 1.6 2012/05/26 20:03:34 schwarze Exp $ */
d17 2
d58 1
a58 1
		tblcalc(&h->tbl, sp);
@


1.6
log
@Do not handle vertical lines as additional tbl(7) columns,
instead save their properties with the following column.
This simplifies layout parsing and saves a lot of code
related to column handling.

At output time, print all white space and vertical lines
separating columns before printing the following column,
and none after printing the preceding column, considerably
simplifying white space handling and width calculations.

No functional change, but it saves 150 lines of code,
and it allows the next patch to tbl_term.c, tbl_literal().
@
text
@d1 1
a1 1
/*	$Id: tbl_html.c,v 1.5 2011/09/18 15:54:48 schwarze Exp $ */
a16 4
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

d30 1
a30 1
/* ARGSUSED */
d34 1
a34 1
	
a37 1
/* ARGSUSED */
d105 1
a105 1
	case (TBL_SPAN_HORIZ):
d107 1
a107 1
	case (TBL_SPAN_DHORIZ):
@


1.5
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: tbl_html.c,v 1.4 2011/01/16 19:41:16 schwarze Exp $ */
d122 1
a122 12
			switch (hp->pos) {
			case (TBL_HEAD_VERT):
				/* FALLTHROUGH */
			case (TBL_HEAD_DVERT):
				continue;
			case (TBL_HEAD_DATA):
				if (NULL == dp)
					break;
				if (TBL_CELL_DOWN != dp->layout->pos)
					if (dp->string)
						print_text(h, dp->string);
				dp = dp->next;
d124 4
a127 1
			}
@


1.4
log
@Merge from bsd.lv, original commit message by kristaps@@:
Change how -Thtml behaves with tables: use multiple rows, with widths
set by COL, until an external macro is encountered.  At this point in
time, close out the table and process the macro.  When the first table
row is again re-encountered, re-start the table.  This requires a bit of
tracking added to "struct html", but the change is very small and
follows the logic of meta-fonts.  This all follows a bug-report by
joerg@@.
@
text
@d1 1
a1 1
/*	$Id: tbl_html.c,v 1.3 2011/01/16 01:11:50 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@kth.se>
@


1.3
log
@Various tbl improvements from kristaps@@:
* horizontal lines do not consume layout lines
* skip excessive data cells
* prepare rendering of spanned cells
* support vertical spans
@
text
@d1 1
a1 1
/*	$Id: tbl_html.c,v 1.2 2011/01/09 14:30:48 schwarze Exp $ */
d30 1
d50 39
d94 1
a95 3
	struct htmlpair	 tag;
	struct roffsu	 su;
	struct roffcol	*col;
d99 5
d107 1
a107 7
	/* First pass: calculate widths. */

	if (TBL_SPAN_FIRST & sp->flags) {
		h->tbl.len = html_tbl_len;
		h->tbl.slen = html_tbl_strlen;
		tblcalc(&h->tbl, sp);
	}
d113 2
a116 6
		PAIR_CLASS_INIT(&tag, "tbl");
		print_otag(h, TAG_TABLE, 1, &tag);
		print_otag(h, TAG_TR, 0, NULL);

		/* Iterate over template headers. */

d119 3
d128 1
a128 23
				break;
			}

			/*
			 * For the time being, use the simplest possible
			 * table styling: setting the widths of data
			 * columns.
			 */

			col = &h->tbl.cols[hp->ident];
			SCALE_HS_INIT(&su, col->width);
			bufcat_su(h, "width", &su);
			PAIR_STYLE_INIT(&tag, h);
			tt = print_otag(h, TAG_TD, 1, &tag);

			if (dp) {
				switch (dp->layout->pos) {
				case (TBL_CELL_DOWN):
					break;
				default:
					if (NULL == dp->string)
						break;
					print_text(h, dp->string);
d130 3
a132 1
				}
d134 1
a135 2

			print_tagq(h, tt);
d140 2
a143 2
	/* Close out column specifiers on the last span. */

d148 1
d150 1
@


1.2
log
@Sync tbl handling to bsd.lv release 1.10.9:
* .T} can be followed by a delimiter, then more data.
* Do not limit table column widths (improves terminfo(5)).
* Let numerical cells respect explicitly specified minimum cell widths.
* Let terminal output survive missing data cells.
* Parse and ignore arguments in parentheses on layout cell specifications.
* Move tbl_calc() into out.c such that it can be used by all frontends.
* Give tables an HTML class.
* Some cleanup in tbl -Thtml code.
All code by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: tbl_html.c,v 1.1 2011/01/04 22:28:17 schwarze Exp $ */
d107 10
a116 3
			if (dp && dp->string) 
				print_text(h, dp->string);
			if (dp)
d118 1
@


1.1
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: tbl_html.c,v 1.1 2011/01/04 10:29:41 kristaps Exp $ */
d30 19
d54 17
a70 1
	struct tag	 *tt;
d76 1
a76 1
		return;
d78 36
d117 1
a117 1
	/* Inhibit printing of spaces: we do padding ourselves. */
d119 1
a119 5
	h->flags |= HTML_NONOSPACE;
	h->flags |= HTML_NOSPACE;

	print_otag(h, TAG_TABLE, 0, NULL);
	print_otag(h, TAG_TR, 0, NULL);
d121 4
a124 17
	dp = sp->first;
	for (hp = sp->head; hp; hp = hp->next) {
		switch (hp->pos) {
		case (TBL_HEAD_VERT):
			/* FALLTHROUGH */
		case (TBL_HEAD_DVERT):
			continue;
		case (TBL_HEAD_DATA):
			break;
		}
		tt = print_otag(h, TAG_TD, 0, NULL);
		if (dp) {
			if (dp->string)
				print_text(h, dp->string);
			dp = dp->next;
		}
		print_tagq(h, tt);
a125 1
	h->flags &= ~HTML_NONOSPACE;
@

