head	1.77;
access;
symbols
	OPENBSD_6_1_BASE:1.77
	OPENBSD_6_0:1.76.0.4
	OPENBSD_6_0_BASE:1.76
	OPENBSD_5_9:1.76.0.2
	OPENBSD_5_9_BASE:1.76
	OPENBSD_5_8:1.71.0.4
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.60.0.2
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.48.0.4
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.38.0.4
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.2
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.37.0.2
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.2
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.77
date	2017.01.10.13.46.53;	author schwarze;	state Exp;
branches;
next	1.76;
commitid	aFt8sLe7F06PjFYh;

1.76
date	2016.01.08.17.48.04;	author schwarze;	state Exp;
branches;
next	1.75;
commitid	DoGoemryKYV644MI;

1.75
date	2015.10.22.21.53.49;	author schwarze;	state Exp;
branches;
next	1.74;
commitid	b31415iHGGouYvkz;

1.74
date	2015.10.06.18.30.43;	author schwarze;	state Exp;
branches;
next	1.73;
commitid	hxQV8O1pNUaef4ir;

1.73
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.72;
commitid	191tWtskbsgcpQqV;

1.72
date	2015.09.04.21.24.26;	author schwarze;	state Exp;
branches;
next	1.71;
commitid	5A7G7hHFPv2H6xHL;

1.71
date	2015.04.23.15.35.39;	author schwarze;	state Exp;
branches;
next	1.70;
commitid	am2zU0fu81iRKMOO;

1.70
date	2015.04.19.14.57.16;	author schwarze;	state Exp;
branches;
next	1.69;
commitid	FaoA4UzPphKw0cyB;

1.69
date	2015.04.19.14.25.05;	author schwarze;	state Exp;
branches;
next	1.68;
commitid	E1gJfKuheBoo64Vb;

1.68
date	2015.04.19.13.50.10;	author schwarze;	state Exp;
branches;
next	1.67;
commitid	QSaLMe5iBgPB4hUe;

1.67
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.66;
commitid	6MYJ7cd8mhJ77AGH;

1.66
date	2015.04.03.23.17.09;	author schwarze;	state Exp;
branches;
next	1.65;
commitid	0KoRtu0jlNYmRH17;

1.65
date	2015.04.03.16.59.34;	author schwarze;	state Exp;
branches;
next	1.64;
commitid	dFu1OfxheluhziWb;

1.64
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.63;
commitid	Rfx1oTaH3hZ7Zcyf;

1.63
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.62;
commitid	lmErjWY2O9ooA6RY;

1.62
date	2015.03.20.14.47.20;	author schwarze;	state Exp;
branches;
next	1.61;
commitid	KWm2bEZgO2HV8Bhd;

1.61
date	2015.03.20.12.53.43;	author schwarze;	state Exp;
branches;
next	1.60;
commitid	CzYsL4bn7BxoEWtt;

1.60
date	2015.02.06.11.54.03;	author schwarze;	state Exp;
branches;
next	1.59;
commitid	Wgxy0y7jtcdh0XG7;

1.59
date	2015.02.06.09.38.22;	author schwarze;	state Exp;
branches;
next	1.58;
commitid	65G1InTyXwfiALBj;

1.58
date	2015.02.06.08.28.03;	author schwarze;	state Exp;
branches;
next	1.57;
commitid	2ZNpc6PO2F2KjxAt;

1.57
date	2015.01.24.10.07.58;	author schwarze;	state Exp;
branches;
next	1.56;
commitid	S11bl58eNymvqy0E;

1.56
date	2015.01.24.02.41.32;	author schwarze;	state Exp;
branches;
next	1.55;
commitid	TIJT04XdY4be3Or5;

1.55
date	2015.01.24.01.59.40;	author schwarze;	state Exp;
branches;
next	1.54;
commitid	pxeX1HXdNjYPBYKE;

1.54
date	2014.12.16.17.24.58;	author schwarze;	state Exp;
branches;
next	1.53;
commitid	xnJyQL2qrdT6c5qR;

1.53
date	2014.11.28.05.51.29;	author schwarze;	state Exp;
branches;
next	1.52;
commitid	9LYX9vvoCC2fp5xR;

1.52
date	2014.11.03.23.17.21;	author schwarze;	state Exp;
branches;
next	1.51;
commitid	GfJl4B0PeEJVZTrN;

1.51
date	2014.08.18.16.26.13;	author schwarze;	state Exp;
branches;
next	1.50;
commitid	ytc98H3JPc5RCcXi;

1.50
date	2014.08.08.15.35.31;	author schwarze;	state Exp;
branches;
next	1.49;
commitid	Xw77omN2gPvZJf21;

1.49
date	2014.08.08.15.32.17;	author schwarze;	state Exp;
branches;
next	1.48;
commitid	MxwVmw5souguneqK;

1.48
date	2014.07.09.11.27.20;	author schwarze;	state Exp;
branches;
next	1.47;
commitid	8VbkXCUKuf2jb6oy;

1.47
date	2014.07.07.21.35.42;	author schwarze;	state Exp;
branches;
next	1.46;
commitid	O2S43bw50KTGcriR;

1.46
date	2014.07.07.19.17.39;	author schwarze;	state Exp;
branches;
next	1.45;
commitid	6LLMrl8zsEJSgCUt;

1.45
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2013.12.30.00.52.18;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2013.12.25.00.50.03;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2013.12.22.13.24.00;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2013.11.11.00.35.51;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2013.10.17.20.51.30;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2012.11.17.00.25.20;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2012.07.07.17.39.05;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2012.06.03.09.47.26;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2012.06.02.20.07.09;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2012.02.26.19.41.27;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.04.00.44.18;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2011.11.05.16.02.18;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.07.04.08.01;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.05.04.12.41;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.16.19.27.25;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.19.07.53.12;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2010.12.01.23.02.59;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2010.11.29.02.26.45;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2010.11.29.00.12.02;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2010.10.15.20.45.03;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.23.22.45.00;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.23.20.57.16;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.20.00.58.02;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2010.05.16.00.54.03;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.25.16.32.19;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.02.11.37.07;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2010.03.29.22.56.52;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.26.01.22.05;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.25.23.23.01;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.02.01.00.39;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.18.22.46.14;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2009.08.22.23.17.40;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.22.20.14.37;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.22.15.15.37;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.23.22.05.42;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.18.23.34.53;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.14.23.00.57;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.20.30.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.77
log
@unify names of AST node flags; no change of cpp output
@
text
@/*	$OpenBSD: man_macro.c,v 1.76 2016/01/08 17:48:04 schwarze Exp $ */
/*
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2012, 2013, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
 * Copyright (c) 2013 Franco Fichtner <franco@@lastsummer.de>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc.h"
#include "roff.h"
#include "man.h"
#include "libmandoc.h"
#include "roff_int.h"
#include "libman.h"

static	void		 blk_close(MACRO_PROT_ARGS);
static	void		 blk_exp(MACRO_PROT_ARGS);
static	void		 blk_imp(MACRO_PROT_ARGS);
static	void		 in_line_eoln(MACRO_PROT_ARGS);
static	int		 man_args(struct roff_man *, int,
				int *, char *, char **);
static	void		 rew_scope(struct roff_man *, int);

const	struct man_macro __man_macros[MAN_MAX] = {
	{ in_line_eoln, MAN_NSCOPED }, /* br */
	{ in_line_eoln, MAN_BSCOPE }, /* TH */
	{ blk_imp, MAN_BSCOPE | MAN_SCOPED }, /* SH */
	{ blk_imp, MAN_BSCOPE | MAN_SCOPED }, /* SS */
	{ blk_imp, MAN_BSCOPE | MAN_SCOPED }, /* TP */
	{ blk_imp, MAN_BSCOPE }, /* LP */
	{ blk_imp, MAN_BSCOPE }, /* PP */
	{ blk_imp, MAN_BSCOPE }, /* P */
	{ blk_imp, MAN_BSCOPE }, /* IP */
	{ blk_imp, MAN_BSCOPE }, /* HP */
	{ in_line_eoln, MAN_SCOPED | MAN_JOIN }, /* SM */
	{ in_line_eoln, MAN_SCOPED | MAN_JOIN }, /* SB */
	{ in_line_eoln, 0 }, /* BI */
	{ in_line_eoln, 0 }, /* IB */
	{ in_line_eoln, 0 }, /* BR */
	{ in_line_eoln, 0 }, /* RB */
	{ in_line_eoln, MAN_SCOPED | MAN_JOIN }, /* R */
	{ in_line_eoln, MAN_SCOPED | MAN_JOIN }, /* B */
	{ in_line_eoln, MAN_SCOPED | MAN_JOIN }, /* I */
	{ in_line_eoln, 0 }, /* IR */
	{ in_line_eoln, 0 }, /* RI */
	{ in_line_eoln, MAN_NSCOPED }, /* sp */
	{ in_line_eoln, MAN_NSCOPED }, /* nf */
	{ in_line_eoln, MAN_NSCOPED }, /* fi */
	{ blk_close, MAN_BSCOPE }, /* RE */
	{ blk_exp, MAN_BSCOPE }, /* RS */
	{ in_line_eoln, 0 }, /* DT */
	{ in_line_eoln, 0 }, /* UC */
	{ in_line_eoln, MAN_NSCOPED }, /* PD */
	{ in_line_eoln, 0 }, /* AT */
	{ in_line_eoln, 0 }, /* in */
	{ in_line_eoln, 0 }, /* ft */
	{ in_line_eoln, 0 }, /* OP */
	{ in_line_eoln, MAN_BSCOPE }, /* EX */
	{ in_line_eoln, MAN_BSCOPE }, /* EE */
	{ blk_exp, MAN_BSCOPE }, /* UR */
	{ blk_close, MAN_BSCOPE }, /* UE */
	{ in_line_eoln, 0 }, /* ll */
};

const	struct man_macro * const man_macros = __man_macros;


void
man_unscope(struct roff_man *man, const struct roff_node *to)
{
	struct roff_node *n;

	to = to->parent;
	n = man->last;
	while (n != to) {

		/* Reached the end of the document? */

		if (to == NULL && ! (n->flags & NODE_VALID)) {
			if (man->flags & (MAN_BLINE | MAN_ELINE) &&
			    man_macros[n->tok].flags & MAN_SCOPED) {
				mandoc_vmsg(MANDOCERR_BLK_LINE,
				    man->parse, n->line, n->pos,
				    "EOF breaks %s",
				    man_macronames[n->tok]);
				if (man->flags & MAN_ELINE)
					man->flags &= ~MAN_ELINE;
				else {
					assert(n->type == ROFFT_HEAD);
					n = n->parent;
					man->flags &= ~MAN_BLINE;
				}
				man->last = n;
				n = n->parent;
				roff_node_delete(man, man->last);
				continue;
			}
			if (n->type == ROFFT_BLOCK &&
			    man_macros[n->tok].fp == blk_exp)
				mandoc_msg(MANDOCERR_BLK_NOEND,
				    man->parse, n->line, n->pos,
				    man_macronames[n->tok]);
		}

		/*
		 * We might delete the man->last node
		 * in the post-validation phase.
		 * Save a pointer to the parent such that
		 * we know where to continue the iteration.
		 */

		man->last = n;
		n = n->parent;
		man->last->flags |= NODE_VALID;
	}

	/*
	 * If we ended up at the parent of the node we were
	 * supposed to rewind to, that means the target node
	 * got deleted, so add the next node we parse as a child
	 * of the parent instead of as a sibling of the target.
	 */

	man->next = (man->last == to) ?
	    ROFF_NEXT_CHILD : ROFF_NEXT_SIBLING;
}

/*
 * Rewinding entails ascending the parse tree until a coherent point,
 * for example, the `SH' macro will close out any intervening `SS'
 * scopes.  When a scope is closed, it must be validated and actioned.
 */
static void
rew_scope(struct roff_man *man, int tok)
{
	struct roff_node *n;

	/* Preserve empty paragraphs before RS. */

	n = man->last;
	if (tok == MAN_RS && n->child == NULL &&
	    (n->tok == MAN_P || n->tok == MAN_PP || n->tok == MAN_LP))
		return;

	for (;;) {
		if (n->type == ROFFT_ROOT)
			return;
		if (n->flags & NODE_VALID) {
			n = n->parent;
			continue;
		}
		if (n->type != ROFFT_BLOCK) {
			if (n->parent->type == ROFFT_ROOT) {
				man_unscope(man, n);
				return;
			} else {
				n = n->parent;
				continue;
			}
		}
		if (tok != MAN_SH && (n->tok == MAN_SH ||
		    (tok != MAN_SS && (n->tok == MAN_SS ||
		     man_macros[n->tok].fp == blk_exp))))
			return;
		man_unscope(man, n);
		n = man->last;
	}
}


/*
 * Close out a generic explicit macro.
 */
void
blk_close(MACRO_PROT_ARGS)
{
	int			 ntok;
	const struct roff_node	*nn;
	char			*p;
	int			 nrew, target;

	nrew = 1;
	switch (tok) {
	case MAN_RE:
		ntok = MAN_RS;
		if ( ! man_args(man, line, pos, buf, &p))
			break;
		for (nn = man->last->parent; nn; nn = nn->parent)
			if (nn->tok == ntok && nn->type == ROFFT_BLOCK)
				nrew++;
		target = strtol(p, &p, 10);
		if (*p != '\0')
			mandoc_vmsg(MANDOCERR_ARG_EXCESS, man->parse,
			    line, p - buf, "RE ... %s", p);
		if (target == 0)
			target = 1;
		nrew -= target;
		if (nrew < 1) {
			mandoc_vmsg(MANDOCERR_RE_NOTOPEN, man->parse,
			    line, ppos, "RE %d", target);
			return;
		}
		break;
	case MAN_UE:
		ntok = MAN_UR;
		break;
	default:
		abort();
	}

	for (nn = man->last->parent; nn; nn = nn->parent)
		if (nn->tok == ntok && nn->type == ROFFT_BLOCK && ! --nrew)
			break;

	if (nn == NULL) {
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, man->parse,
		    line, ppos, man_macronames[tok]);
		rew_scope(man, MAN_PP);
	} else {
		line = man->last->line;
		ppos = man->last->pos;
		ntok = man->last->tok;
		man_unscope(man, nn);

		/* Move a trailing paragraph behind the block. */

		if (ntok == MAN_LP || ntok == MAN_PP || ntok == MAN_P) {
			*pos = strlen(buf);
			blk_imp(man, ntok, line, ppos, pos, buf);
		}
	}
}

void
blk_exp(MACRO_PROT_ARGS)
{
	struct roff_node *head;
	char		*p;
	int		 la;

	rew_scope(man, tok);
	roff_block_alloc(man, line, ppos, tok);
	head = roff_head_alloc(man, line, ppos, tok);

	la = *pos;
	if (man_args(man, line, pos, buf, &p))
		roff_word_alloc(man, line, la, p);

	if (buf[*pos] != '\0')
		mandoc_vmsg(MANDOCERR_ARG_EXCESS,
		    man->parse, line, *pos, "%s ... %s",
		    man_macronames[tok], buf + *pos);

	man_unscope(man, head);
	roff_body_alloc(man, line, ppos, tok);
}

/*
 * Parse an implicit-block macro.  These contain a ROFFT_HEAD and a
 * ROFFT_BODY contained within a ROFFT_BLOCK.  Rules for closing out other
 * scopes, such as `SH' closing out an `SS', are defined in the rew
 * routines.
 */
void
blk_imp(MACRO_PROT_ARGS)
{
	int		 la;
	char		*p;
	struct roff_node *n;

	rew_scope(man, tok);
	n = roff_block_alloc(man, line, ppos, tok);
	if (n->tok == MAN_SH || n->tok == MAN_SS)
		man->flags &= ~MAN_LITERAL;
	n = roff_head_alloc(man, line, ppos, tok);

	/* Add line arguments. */

	for (;;) {
		la = *pos;
		if ( ! man_args(man, line, pos, buf, &p))
			break;
		roff_word_alloc(man, line, la, p);
	}

	/*
	 * For macros having optional next-line scope,
	 * keep the head open if there were no arguments.
	 * For `TP', always keep the head open.
	 */

	if (man_macros[tok].flags & MAN_SCOPED &&
	    (tok == MAN_TP || n == man->last)) {
		man->flags |= MAN_BLINE;
		return;
	}

	/* Close out the head and open the body. */

	man_unscope(man, n);
	roff_body_alloc(man, line, ppos, tok);
}

void
in_line_eoln(MACRO_PROT_ARGS)
{
	int		 la;
	char		*p;
	struct roff_node *n;

	roff_elem_alloc(man, line, ppos, tok);
	n = man->last;

	for (;;) {
		if (buf[*pos] != '\0' && (tok == MAN_br ||
		    tok == MAN_fi || tok == MAN_nf)) {
			mandoc_vmsg(MANDOCERR_ARG_SKIP,
			    man->parse, line, *pos, "%s %s",
			    man_macronames[tok], buf + *pos);
			break;
		}
		if (buf[*pos] != '\0' && man->last != n &&
		    (tok == MAN_PD || tok == MAN_ft || tok == MAN_sp)) {
			mandoc_vmsg(MANDOCERR_ARG_EXCESS,
			    man->parse, line, *pos, "%s ... %s",
			    man_macronames[tok], buf + *pos);
			break;
		}
		la = *pos;
		if ( ! man_args(man, line, pos, buf, &p))
			break;
		if (man_macros[tok].flags & MAN_JOIN &&
		    man->last->type == ROFFT_TEXT)
			roff_word_append(man, p);
		else
			roff_word_alloc(man, line, la, p);
	}

	/*
	 * Append NODE_EOS in case the last snipped argument
	 * ends with a dot, e.g. `.IR syslog (3).'
	 */

	if (n != man->last &&
	    mandoc_eos(man->last->string, strlen(man->last->string)))
		man->last->flags |= NODE_EOS;

	/*
	 * If no arguments are specified and this is MAN_SCOPED (i.e.,
	 * next-line scoped), then set our mode to indicate that we're
	 * waiting for terms to load into our context.
	 */

	if (n == man->last && man_macros[tok].flags & MAN_SCOPED) {
		assert( ! (man_macros[tok].flags & MAN_NSCOPED));
		man->flags |= MAN_ELINE;
		return;
	}

	assert(man->last->type != ROFFT_ROOT);
	man->next = ROFF_NEXT_SIBLING;

	/* Rewind our element scope. */

	for ( ; man->last; man->last = man->last->parent) {
		man_state(man, man->last);
		if (man->last == n)
			break;
	}
}

void
man_endparse(struct roff_man *man)
{

	man_unscope(man, man->first);
	man->flags &= ~MAN_LITERAL;
}

static int
man_args(struct roff_man *man, int line, int *pos, char *buf, char **v)
{
	char	 *start;

	assert(*pos);
	*v = start = buf + *pos;
	assert(' ' != *start);

	if ('\0' == *start)
		return 0;

	*v = mandoc_getarg(man->parse, v, line, pos);
	return 1;
}
@


1.76
log
@Delete the redundant "nchild" member of struct roff_node, replacing
most uses by one, a few by two pointer checks, and only one by a
tiny loop - not only making data smaller, but code shorter as well.

This gets rid of an implicit invariant that confused both static
analysis tools and human auditors.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.75 2015/10/22 21:53:49 schwarze Exp $ */
d96 1
a96 1
		if (to == NULL && ! (n->flags & MAN_VALID)) {
d131 1
a131 1
		man->last->flags |= MAN_VALID;
d165 1
a165 1
		if (n->flags & MAN_VALID) {
d357 1
a357 1
	 * Append MAN_EOS in case the last snipped argument
d363 1
a363 1
		man->last->flags |= MAN_EOS;
@


1.75
log
@move man(7) validation into the dedicated validation phase, too
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.74 2015/10/06 18:30:43 schwarze Exp $ */
d158 1
a158 1
	if (tok == MAN_RS && n->nchild == 0 &&
@


1.74
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.73 2015/09/26 00:53:15 schwarze Exp $ */
d131 1
a131 1
		man_valid_post(man);
d380 1
a380 5
	/*
	 * Rewind our element scope.  Note that when TH is pruned, we'll
	 * be back at the root, so make sure that we don't clobber as
	 * its sibling.
	 */
d383 1
a385 3
		if (man->last->type == ROFFT_ROOT)
			break;
		man_valid_post(man);
a386 9

	assert(man->last);

	/*
	 * Same here regarding whether we're back at the root.
	 */

	if (man->last->type != ROFFT_ROOT)
		man_valid_post(man);
d394 1
@


1.73
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.72 2015/09/04 21:24:26 schwarze Exp $ */
d421 1
a421 1
		return(0);
d424 1
a424 1
	return(1);
@


1.72
log
@Fill mode changes don't break next-line scope in all cases,
in particular not for tagged paragraphs.
Issue found by Christian Neukirchen <chneukirchen at gmail dot com>
in the exiv2(1) manual page.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.71 2015/04/23 15:35:39 schwarze Exp $ */
a225 1
		/* NOTREACHED */
@


1.71
log
@Get rid of two empty wrapper functions.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.70 2015/04/19 14:57:16 schwarze Exp $ */
d64 2
a65 2
	{ in_line_eoln, MAN_BSCOPE }, /* nf */
	{ in_line_eoln, MAN_BSCOPE }, /* fi */
@


1.70
log
@Unify trickier node handling functions.
* man_elem_alloc() -> roff_elem_alloc()
* man_block_alloc() -> roff_block_alloc()
The functions mdoc_elem_alloc() and mdoc_block_alloc() remain for
now because they need to do mdoc(7)-specific argument processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.69 2015/04/19 14:25:05 schwarze Exp $ */
a404 1

d406 1
a406 1
man_macroend(struct roff_man *man)
@


1.69
log
@Unify some node handling functions that use TOKEN_NONE.
* mdoc_word_alloc(), man_word_alloc() -> roff_word_alloc()
* mdoc_word_append(), man_word_append() -> roff_word_append()
* mdoc_addspan(), man_addspan() -> roff_addtbl()
* mdoc_addeqn(), man_addeqn() -> roff_addeqn()
Minus 50 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.68 2015/04/19 13:50:10 schwarze Exp $ */
d260 1
a260 1
	man_block_alloc(man, line, ppos, tok);
d290 1
a290 2
	man_block_alloc(man, line, ppos, tok);
	n = man->last;
d329 1
a329 1
	man_elem_alloc(man, line, ppos, tok);
@


1.68
log
@Unify node handling functions:
* node_alloc() for mdoc and man_node_alloc() -> roff_node_alloc()
* node_append() for mdoc and man_node_append() -> roff_node_append()
* mdoc_head_alloc() and man_head_alloc() -> roff_head_alloc()
* mdoc_body_alloc() and man_body_alloc() -> roff_body_alloc()
* mdoc_node_unlink() and man_node_unlink() -> roff_node_unlink()
* mdoc_node_free() and man_node_free() -> roff_node_free()
* mdoc_node_delete() and man_node_delete() -> roff_node_delete()
Minus 130 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.67 2015/04/18 16:04:40 schwarze Exp $ */
d265 1
a265 1
		man_word_alloc(man, line, la, p);
d302 1
a302 1
		man_word_alloc(man, line, la, p);
d353 1
a353 1
			man_word_append(man, p);
d355 1
a355 1
			man_word_alloc(man, line, la, p);
@


1.67
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.66 2015/04/03 23:17:09 schwarze Exp $ */
d30 1
d112 1
a112 1
				man_node_delete(man, man->last);
d261 1
a261 2
	man_head_alloc(man, line, ppos, tok);
	head = man->last;
d273 1
a273 1
	man_body_alloc(man, line, ppos, tok);
a290 1
	man_head_alloc(man, line, ppos, tok);
d292 3
d320 1
a320 1
	man_body_alloc(man, line, ppos, tok);
@


1.66
log
@Vastly simplify man(7) block unwinding, similar to mdoc_macro.c 1.171.
Drop one enum type, two static functions, 70 lines of code.
Also fixes the mpeg_encode(1) manual reported broken by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.65 2015/04/03 16:59:34 schwarze Exp $ */
d36 1
a36 1
static	int		 man_args(struct man *, int,
d38 1
a38 1
static	void		 rew_scope(struct man *, int);
d85 1
a85 1
man_unscope(struct man *man, const struct roff_node *to)
d141 1
a141 1
	    MAN_NEXT_CHILD : MAN_NEXT_SIBLING;
d150 1
a150 1
rew_scope(struct man *man, int tok)
d378 1
a378 1
	man->next = MAN_NEXT_SIBLING;
d406 1
a406 1
man_macroend(struct man *man)
d413 1
a413 1
man_args(struct man *man, int line, int *pos, char *buf, char **v)
@


1.65
log
@It turns out the man(7) parser suffers from unintelligible handling
of block rewinding, just like then mdoc(7) parser did.
First step in getting rid of rew_scope():
Replace the only call where the target block is known.
This commit is analogous to mdoc_macro.c rev. 1.167.
One down, three to go.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.64 2015/04/02 22:06:17 schwarze Exp $ */
a31 6
enum	rew {
	REW_REWIND,
	REW_NOHALT,
	REW_HALT
};

d38 1
a38 6

static	void		 rew_scope(enum roff_type, struct man *, int);
static	enum rew	 rew_dohalt(int, enum roff_type,
				const struct roff_node *);
static	enum rew	 rew_block(int, enum roff_type,
				const struct roff_node *);
a143 83
static enum rew
rew_block(int ntok, enum roff_type type, const struct roff_node *n)
{

	if (type == ROFFT_BLOCK && n->parent->tok == ntok &&
	    n->parent->type == ROFFT_BODY)
		return(REW_REWIND);
	return(ntok == n->tok ? REW_HALT : REW_NOHALT);
}

/*
 * There are three scope levels: scoped to the root (all), scoped to the
 * section (all less sections), and scoped to subsections (all less
 * sections and subsections).
 */
static enum rew
rew_dohalt(int tok, enum roff_type type, const struct roff_node *n)
{
	enum rew	 c;

	/* We cannot progress beyond the root ever. */
	if (n->type == ROFFT_ROOT)
		return(REW_HALT);

	assert(n->parent);

	/* Normal nodes shouldn't go to the level of the root. */
	if (n->parent->type == ROFFT_ROOT)
		return(REW_REWIND);

	/* Already-validated nodes should be closed out. */
	if (MAN_VALID & n->flags)
		return(REW_NOHALT);

	/* First: rewind to ourselves. */
	if (type == n->type && tok == n->tok) {
		if (man_macros[n->tok].fp == blk_exp)
			return(REW_HALT);
		else
			return(REW_REWIND);
	}

	/*
	 * Next follow the implicit scope-smashings as defined by man.7:
	 * section, sub-section, etc.
	 */

	switch (tok) {
	case MAN_SH:
		break;
	case MAN_SS:
		/* Rewind to a section, if a block. */
		if (REW_NOHALT != (c = rew_block(MAN_SH, type, n)))
			return(c);
		break;
	case MAN_RS:
		/* Preserve empty paragraphs before RS. */
		if (0 == n->nchild && (MAN_P == n->tok ||
		    MAN_PP == n->tok || MAN_LP == n->tok))
			return(REW_HALT);
		/* Rewind to a subsection, if a block. */
		if (REW_NOHALT != (c = rew_block(MAN_SS, type, n)))
			return(c);
		/* Rewind to a section, if a block. */
		if (REW_NOHALT != (c = rew_block(MAN_SH, type, n)))
			return(c);
		break;
	default:
		/* Rewind to an offsetter, if a block. */
		if (REW_NOHALT != (c = rew_block(MAN_RS, type, n)))
			return(c);
		/* Rewind to a subsection, if a block. */
		if (REW_NOHALT != (c = rew_block(MAN_SS, type, n)))
			return(c);
		/* Rewind to a section, if a block. */
		if (REW_NOHALT != (c = rew_block(MAN_SH, type, n)))
			return(c);
		break;
	}

	return(REW_NOHALT);
}

d150 1
a150 1
rew_scope(enum roff_type type, struct man *man, int tok)
a152 1
	enum rew	 c;
d154 26
a179 8
	for (n = man->last; n; n = n->parent) {
		/*
		 * Whether we should stop immediately (REW_HALT), stop
		 * and rewind until this point (REW_REWIND), or keep
		 * rewinding (REW_NOHALT).
		 */
		c = rew_dohalt(tok, type, n);
		if (REW_HALT == c)
d181 2
a182 2
		if (REW_REWIND == c)
			break;
a183 7

	/*
	 * Rewind until the current point.  Warn if we're a roff
	 * instruction that's mowing over explicit scopes.
	 */

	man_unscope(man, n);
d235 1
a235 1
		rew_scope(ROFFT_BLOCK, man, MAN_PP);
d258 1
a258 1
	rew_scope(ROFFT_BLOCK, man, tok);
d289 1
a289 2
	rew_scope(ROFFT_BODY, man, tok);
	rew_scope(ROFFT_BLOCK, man, tok);
@


1.64
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.63 2015/04/02 21:03:18 schwarze Exp $ */
d402 1
a402 1
	rew_scope(ROFFT_HEAD, man, tok);
@


1.63
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.62 2015/03/20 14:47:20 schwarze Exp $ */
d45 5
a49 6
static	void		 rew_scope(enum roff_type,
				struct man *, enum mant);
static	enum rew	 rew_dohalt(enum mant, enum roff_type,
				const struct man_node *);
static	enum rew	 rew_block(enum mant, enum roff_type,
				const struct man_node *);
d96 1
a96 1
man_unscope(struct man *man, const struct man_node *to)
d98 1
a98 1
	struct man_node	*n;
d156 1
a156 1
rew_block(enum mant ntok, enum roff_type type, const struct man_node *n)
d171 1
a171 1
rew_dohalt(enum mant tok, enum roff_type type, const struct man_node *n)
d244 1
a244 1
rew_scope(enum roff_type type, struct man *man, enum mant tok)
d246 1
a246 1
	struct man_node	*n;
d277 2
a278 2
	enum mant		 ntok;
	const struct man_node	*nn;
d338 1
a338 1
	struct man_node	*head;
d371 1
a371 1
	struct man_node	*n;
d411 1
a411 1
	struct man_node	*n;
@


1.62
log
@The .PD macro can occur in next-line scope.  Fixes zshmisc(1).
Issue reported by Christian Neukirchen <chneukirchen at gmail dot com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.61 2015/03/20 12:53:43 schwarze Exp $ */
d11 1
a11 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d13 1
a13 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d26 2
a28 1
#include "mandoc.h"
d45 1
a45 1
static	void		 rew_scope(enum man_type,
d47 1
a47 1
static	enum rew	 rew_dohalt(enum mant, enum man_type,
d49 1
a49 1
static	enum rew	 rew_block(enum mant, enum man_type,
d117 1
a117 1
					assert(n->type == MAN_HEAD);
d126 1
a126 1
			if (n->type == MAN_BLOCK &&
d157 1
a157 1
rew_block(enum mant ntok, enum man_type type, const struct man_node *n)
d160 2
a161 2
	if (type == MAN_BLOCK && ntok == n->parent->tok &&
	    n->parent->type == MAN_BODY)
d172 1
a172 1
rew_dohalt(enum mant tok, enum man_type type, const struct man_node *n)
d177 1
a177 1
	if (MAN_ROOT == n->type)
d183 1
a183 1
	if (MAN_ROOT == n->parent->type)
d245 1
a245 1
rew_scope(enum man_type type, struct man *man, enum mant tok)
d290 1
a290 1
			if (nn->tok == ntok && nn->type == MAN_BLOCK)
d314 1
a314 1
		if (nn->tok == ntok && nn->type == MAN_BLOCK && ! --nrew)
d320 1
a320 1
		rew_scope(MAN_BLOCK, man, MAN_PP);
d343 1
a343 1
	rew_scope(MAN_BLOCK, man, tok);
d362 2
a363 2
 * Parse an implicit-block macro.  These contain a MAN_HEAD and a
 * MAN_BODY contained within a MAN_BLOCK.  Rules for closing out other
d374 2
a375 2
	rew_scope(MAN_BODY, man, tok);
	rew_scope(MAN_BLOCK, man, tok);
d403 1
a403 1
	rew_scope(MAN_HEAD, man, tok);
d436 1
a436 1
		    man->last->type == MAN_TEXT)
d463 1
a463 1
	assert(man->last->type != MAN_ROOT);
d475 1
a475 1
		if (man->last->type == MAN_ROOT)
d486 1
a486 1
	if (man->last->type != MAN_ROOT)
@


1.61
log
@Simplify by almost halving the number of macro flags:
1. MAN_EXPLICIT was used iff fp == blk_exp, so just test fp.
2. MAN_FSCOPED was used only for TP, so just test for TP.
3. MAN_NOCLOSE was completely unused.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.60 2015/02/06 11:54:03 schwarze Exp $ */
d80 1
a80 1
	{ in_line_eoln, 0 }, /* PD */
@


1.60
log
@better error reporting regarding .OP .RS .UR .TH arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.59 2015/02/06 09:38:22 schwarze Exp $ */
d56 1
a56 1
	{ blk_imp, MAN_BSCOPE | MAN_SCOPED | MAN_FSCOPED }, /* TP */
d77 1
a77 1
	{ blk_exp, MAN_BSCOPE | MAN_EXPLICIT }, /* RS */
d87 1
a87 1
	{ blk_exp, MAN_BSCOPE | MAN_EXPLICIT }, /* UR */
d126 1
a126 1
			    man_macros[n->tok].flags & MAN_EXPLICIT)
d191 1
a191 1
		if (MAN_EXPLICIT & man_macros[n->tok].flags)
d388 5
a392 1
	/* Close out head and open body (unless MAN_SCOPE). */
d394 4
a397 9
	if (man_macros[tok].flags & MAN_SCOPED) {
		/* If we're forcing scope (`TP'), keep it open. */
		if (man_macros[tok].flags & MAN_FSCOPED) {
			man->flags |= MAN_BLINE;
			return;
		} else if (n == man->last) {
			man->flags |= MAN_BLINE;
			return;
		}
d399 3
@


1.59
log
@better diagnostics about excess arguments to .PD .ft .sp
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.58 2015/02/06 08:28:03 schwarze Exp $ */
d338 2
a339 1
	struct man_node	*n;
a340 1
	char		*p;
d345 1
d347 2
a348 4
	for (;;) {
		la = *pos;
		if ( ! man_args(man, line, pos, buf, &p))
			break;
a349 4
	}

	assert(man);
	assert(tok != MAN_MAX);
d351 4
a354 6
	for (n = man->last; n; n = n->parent)
		if (n->tok == tok) {
			assert(n->type == MAN_HEAD);
			man_unscope(man, n);
			break;
		}
d356 1
@


1.58
log
@better error reporting for .br .fi .nf with arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.57 2015/01/24 10:07:58 schwarze Exp $ */
d425 7
@


1.57
log
@preserve .PP before .RE; effect found in audio/pms(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.56 2015/01/24 02:41:32 schwarze Exp $ */
d421 7
@


1.56
log
@Strangely, ignoring the roff(7) .na request was implemented in the man(7)
parser.  Simplify the code by moving it into the roff(7) parser, also
making it work for mdoc(7).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.55 2015/01/24 01:59:40 schwarze Exp $ */
d320 4
a323 1
	} else
d325 8
@


1.55
log
@Support .RE with an argument; needed for audio/pms(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.54 2014/12/16 17:24:58 schwarze Exp $ */
a72 1
	{ in_line_eoln, MAN_NSCOPED }, /* na */
@


1.54
log
@Explicit block closure macros clobber next-line block head scope,
just like explicit block macros themselves.
Fixing an assertion failure jsg@@ found with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.53 2014/11/28 05:51:29 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d280 2
d283 1
d287 17
d314 1
a314 1
		if (nn->tok == ntok && nn->type == MAN_BLOCK)
@


1.53
log
@Simplify by making many functions in the man(7) parser void,
and some cleanup; no functional change, minus 70 lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_macro.c,v 1.52 2014/11/03 23:17:21 schwarze Exp $ */
d77 1
a77 1
	{ blk_close, 0 }, /* RE */
d89 1
a89 1
	{ blk_close, 0 }, /* UE */
@


1.52
log
@Allow the five man(7) font macros to concatenate their line arguments,
the same way the mdoc(7) macros marked MDOC_JOIN do it.
In -Thtml, this removes bogus <br/> when the font macros are used
in no-fill mode; issue found by jsg@@ in the Xcursor(3) SYNOPSIS.
As a bonus, this slightly reduces the size of the syntax tree.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d37 4
a40 4
static	int		 blk_close(MACRO_PROT_ARGS);
static	int		 blk_exp(MACRO_PROT_ARGS);
static	int		 blk_imp(MACRO_PROT_ARGS);
static	int		 in_line_eoln(MACRO_PROT_ARGS);
d44 1
a44 1
static	int		 rew_scope(enum man_type,
d96 1
a96 1
int
d142 1
a142 2
		if ( ! man_valid_post(man))
			return(0);
a153 2

	return(1);
d160 2
a161 2
	if (MAN_BLOCK == type && ntok == n->parent->tok &&
	    MAN_BODY == n->parent->type)
d244 1
a244 1
static int
d258 1
a258 1
			return(1);
a266 1
	assert(n);
d268 1
a268 1
	return(man_unscope(man, n));
d275 1
a275 1
int
d294 1
a294 1
		if (ntok == nn->tok && MAN_BLOCK == nn->type)
d297 1
a297 1
	if (NULL == nn) {
d300 1
a300 2
		if ( ! rew_scope(MAN_BLOCK, man, MAN_PP))
			return(0);
a302 2

	return(1);
d305 1
a305 1
int
d312 3
a314 9
	/* Close out prior implicit scopes. */

	if ( ! rew_scope(MAN_BLOCK, man, tok))
		return(0);

	if ( ! man_block_alloc(man, line, ppos, tok))
		return(0);
	if ( ! man_head_alloc(man, line, ppos, tok))
		return(0);
d320 1
a320 2
		if ( ! man_word_alloc(man, line, la, p))
			return(0);
d326 6
a331 7
	for (n = man->last; n; n = n->parent) {
		if (n->tok != tok)
			continue;
		assert(MAN_HEAD == n->type);
		man_unscope(man, n);
		break;
	}
d333 1
a333 1
	return(man_body_alloc(man, line, ppos, tok));
d342 1
a342 1
int
d349 4
a352 14
	/* Close out prior scopes. */

	if ( ! rew_scope(MAN_BODY, man, tok))
		return(0);
	if ( ! rew_scope(MAN_BLOCK, man, tok))
		return(0);

	/* Allocate new block & head scope. */

	if ( ! man_block_alloc(man, line, ppos, tok))
		return(0);
	if ( ! man_head_alloc(man, line, ppos, tok))
		return(0);

d361 1
a361 2
		if ( ! man_word_alloc(man, line, la, p))
			return(0);
d366 1
a366 1
	if (MAN_SCOPED & man_macros[tok].flags) {
d368 1
a368 1
		if (MAN_FSCOPED & man_macros[tok].flags) {
d370 1
a370 1
			return(1);
d373 1
a373 1
			return(1);
d376 2
a377 4

	if ( ! rew_scope(MAN_HEAD, man, tok))
		return(0);
	return(man_body_alloc(man, line, ppos, tok));
d380 1
a380 1
int
d387 1
a387 3
	if ( ! man_elem_alloc(man, line, ppos, tok))
		return(0);

d397 2
a398 2
		else if ( ! man_word_alloc(man, line, la, p))
			return(0);
d416 2
a417 2
	if (n == man->last && MAN_SCOPED & man_macros[tok].flags) {
		assert( ! (MAN_NSCOPED & man_macros[tok].flags));
d419 1
a419 1
		return(1);
d422 1
a422 1
	assert(MAN_ROOT != man->last->type);
d436 1
a436 2
		if ( ! man_valid_post(man))
			return(0);
d445 2
a446 4
	if (man->last->type != MAN_ROOT && ! man_valid_post(man))
		return(0);

	return(1);
d450 1
a450 1
int
d454 1
a454 1
	return(man_unscope(man, man->first));
@


1.51
log
@When the first child of the node being validated gets deleted during
validation, man_node_unlink() switches to MAN_NEXT_CHILD.  After
that, we have to switch back to MAN_NEXT_SIBLING after completing
validation, or subsequent parsing would add content into an already
closed node, clobbering potentially existing children, causing
information loss and a memory leak.  Bug found by kristaps@@ with
valgrind in groff(7) on Mac OS X.

Note that the switch back must be conditional, for if the node being
validated itself gets deleted, we must *not* go to MAN_NEXT_SIBLING,
which would not only yield wrong results in general but also crash
in malformed manuals having an empty paragraph before the first .SH,
for example OpenBSD c++filt(1).

While here, add the missing <sys/types.h> as required before mandoc.h.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.50 2014/08/08 15:35:31 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
a18 1

d62 2
a63 2
	{ in_line_eoln, MAN_SCOPED }, /* SM */
	{ in_line_eoln, MAN_SCOPED }, /* SB */
d68 3
a70 3
	{ in_line_eoln, MAN_SCOPED }, /* R */
	{ in_line_eoln, MAN_SCOPED }, /* B */
	{ in_line_eoln, MAN_SCOPED }, /* I */
d424 4
a427 1
		if ( ! man_word_alloc(man, line, la, p))
@


1.50
log
@Improve handling of next-line scope broken by end of file.
Detect the condition earlier, report in the error message
which block is broken, and delete the broken block.
Consequently, empty section headers can no longer happen.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.49 2014/08/08 15:32:17 schwarze Exp $ */
d19 3
a101 1
	man->next = MAN_NEXT_SIBLING;
d140 1
d146 11
@


1.49
log
@Simplify: replace one global flag by one local variable
and remove three unused global flags.  No functional change.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.48 2014/07/09 11:27:20 schwarze Exp $ */
d103 29
a131 7
		if (NULL == to &&
		    MAN_BLOCK == n->type &&
		    0 == (MAN_VALID & n->flags) &&
		    MAN_EXPLICIT & man_macros[n->tok].flags)
			mandoc_msg(MANDOCERR_BLK_NOEND,
			    man->parse, n->line, n->pos,
			    man_macronames[n->tok]);
@


1.48
log
@delete forgotten, obsolete rew_warn() prototype
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.47 2014/07/07 21:35:42 schwarze Exp $ */
a411 7
	}

	/* Set ignorable context, if applicable. */

	if (MAN_NSCOPED & man_macros[tok].flags) {
		assert( ! (MAN_SCOPED & man_macros[tok].flags));
		man->flags |= MAN_ILINE;
@


1.47
log
@Clean up ERROR messages related to document structure and macros:
Hierarchical naming and mention macro names in messages.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.46 2014/07/07 19:17:39 schwarze Exp $ */
a47 2
static	void		 rew_warn(struct man *,
				struct man_node *, enum mandocerr);
@


1.46
log
@Simplify man_unscope(), removing 18 lines of code, that is,
removing one function argument, one function definition,
three function invocations and two pointless assert()s.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.45 2014/04/20 16:44:44 schwarze Exp $ */
d109 1
a109 1
			mandoc_msg(MANDOCERR_SCOPEEXIT,
d269 2
a270 1
		man_pmsg(man, line, ppos, MANDOCERR_NOSCOPE);
@


1.45
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.44 2014/03/30 19:47:32 schwarze Exp $ */
a95 22
/*
 * Warn when "n" is an explicit non-roff macro.
 */
static void
rew_warn(struct man *man, struct man_node *n, enum mandocerr er)
{

	if (er == MANDOCERR_MAX || MAN_BLOCK != n->type)
		return;
	if (MAN_VALID & n->flags)
		return;
	if ( ! (MAN_EXPLICIT & man_macros[n->tok].flags))
		return;

	assert(er < MANDOCERR_FATAL);
	man_nmsg(man, n, er);
}

/*
 * Rewind scope.  If a code "er" != MANDOCERR_MAX has been provided, it
 * will be used if an explicit block scope is being closed out.
 */
d97 1
a97 2
man_unscope(struct man *man, const struct man_node *to,
		enum mandocerr er)
a100 2
	assert(to);

d102 10
a111 2

	while (man->last != to) {
d113 4
a116 4
		 * Save the parent here, because we may delete the
		 * man->last node in the post-validation phase and reset
		 * it to man->last->parent, causing a step in the closing
		 * out to be lost.
d118 2
a119 2
		n = man->last->parent;
		rew_warn(man, man->last, er);
a121 2
		man->last = n;
		assert(man->last);
a122 5

	rew_warn(man, man->last, er);
	if ( ! man_valid_post(man))
		return(0);

d239 1
a239 1
	return(man_unscope(man, n, MANDOCERR_MAX));
d273 1
a273 1
		man_unscope(man, nn, MANDOCERR_MAX);
d310 1
a310 1
		man_unscope(man, n, MANDOCERR_MAX);
d457 1
a457 1
	return(man_unscope(man, man->first, MANDOCERR_SCOPEEXIT));
@


1.44
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.43 2013/12/30 00:52:18 schwarze Exp $ */
d39 1
a39 1
static	int		 man_args(struct man *, int, 
d42 1
a42 1
static	int		 rew_scope(enum man_type, 
d44 1
a44 1
static	enum rew	 rew_dohalt(enum mant, enum man_type, 
d46 1
a46 1
static	enum rew	 rew_block(enum mant, enum man_type, 
d48 1
a48 1
static	void		 rew_warn(struct man *, 
a113 1

d119 1
a119 1
man_unscope(struct man *man, const struct man_node *to, 
a127 1
	/* LINTED */
a149 1

d154 2
a155 2
	if (MAN_BLOCK == type && ntok == n->parent->tok && 
			MAN_BODY == n->parent->type)
a159 1

d165 1
a165 1
static enum rew 
d192 1
a192 1
	/* 
d198 1
a198 1
	case (MAN_SH):
d200 1
a200 1
	case (MAN_SS):
d205 1
a205 1
	case (MAN_RS):
a232 1

a243 1
	/* LINTED */
d245 1
a245 1
		/* 
d257 1
a257 1
	/* 
a269 1
/* ARGSUSED */
d273 1
a273 1
	enum mant	 	 ntok;
d277 1
a277 1
	case (MAN_RE):
d280 1
a280 1
	case (MAN_UE):
d296 1
a296 1
	} else 
a301 2

/* ARGSUSED */
a340 2


a346 1
/* ARGSUSED */
a397 2

/* ARGSUSED */
d437 1
a437 1
	} 
d448 1
a448 1
	
d467 1
a467 1
	 * Same here regarding whether we're back at the root. 
@


1.43
log
@Simplify: Remove an unused argument from the mandoc_eos() function.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.42 2013/12/25 00:50:03 schwarze Exp $ */
d90 1
@


1.42
log
@s/[Nn]ull/NUL/ in comments where appropriate;
suggested by Thomas Klausner <wiz @@ NetBSD dot org>.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.41 2013/12/22 13:24:00 schwarze Exp $ */
d437 1
a437 1
	    mandoc_eos(man->last->string, strlen(man->last->string), 0))
@


1.41
log
@Implement end-of-sentence spacing at the end of man(7) macro lines.

Improves cvs(1) pcap-filter(3) readline(3) termcap(5) cvsbug(8)
mkhybrid(8) nsd-zonec(8) in multiple places and c++filt(1) com_err(3)
nsd_conf(5) term(5) nsdc(8) in one place each.
Reduces overall groff-mandoc-differences in base by about 1.5%.

Patch from Franco Fichtner <franco at lastsummer dot de> (DragonFly).
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.40 2013/11/11 00:35:51 schwarze Exp $ */
d5 1
@


1.40
log
@In the parser, when closing an explicit block that is not open,
close below-subsection implicit scopes that may still be open.
In the formatter, make sure indentation is reset when leaving a scope,
not only when entering the next one.

Improves the formatting of gpg(1); issue reported by jca on ports.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.39 2013/10/17 20:51:30 schwarze Exp $ */
d429 9
@


1.39
log
@Implement the .UR/.UE block (uniform resource identifier) introduced in the
man-ext macros by Eric S. Raymond, enabled by default in groff_man(7).
Usual disclaimer: You don't write new man(7) code, so you are not going
to use these, either.
Improves e.g. the bzr(1) and etherape(1) manuals.
Thanks to naddy@@ for bringing these to my attention.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.38 2012/11/17 00:25:20 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2012 Ingo Schwarze <schwarze@@openbsd.org>
d297 5
a301 1
	if (NULL != nn)
a302 2
	else
		man_pmsg(man, line, ppos, MANDOCERR_NOSCOPE);
@


1.38
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.37 2012/07/07 17:39:05 schwarze Exp $ */
d87 2
d284 3
@


1.37
log
@Fix an assert() raised by `RS' when following `TP' without a tag.
The reason was that `RS' wasn't BSCOPE'd, so the next-line (BLINE) scope
opened by `TP' would still be in the macro HEAD.
This was from joerg@@'s archive of failures.
Fix by kristaps@@, bsd.lv rev. 1.74.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.36 2012/06/03 09:47:26 schwarze Exp $ */
d96 1
a96 1
rew_warn(struct man *m, struct man_node *n, enum mandocerr er)
d107 1
a107 1
	man_nmsg(m, n, er);
d116 1
a116 1
man_unscope(struct man *m, const struct man_node *to, 
d123 1
a123 1
	m->next = MAN_NEXT_SIBLING;
d126 1
a126 1
	while (m->last != to) {
d129 2
a130 2
		 * m->last node in the post-validation phase and reset
		 * it to m->last->parent, causing a step in the closing
d133 3
a135 3
		n = m->last->parent;
		rew_warn(m, m->last, er);
		if ( ! man_valid_post(m))
d137 2
a138 2
		m->last = n;
		assert(m->last);
d141 2
a142 2
	rew_warn(m, m->last, er);
	if ( ! man_valid_post(m))
d240 1
a240 1
rew_scope(enum man_type type, struct man *m, enum mant tok)
d246 1
a246 1
	for (n = m->last; n; n = n->parent) {
d265 1
a265 1
	return(man_unscope(m, n, MANDOCERR_MAX));
d288 1
a288 1
	for (nn = m->last->parent; nn; nn = nn->parent)
d293 1
a293 1
		man_unscope(m, nn, MANDOCERR_MAX);
d295 1
a295 1
		man_pmsg(m, line, ppos, MANDOCERR_NOSCOPE);
d311 1
a311 1
	if ( ! rew_scope(MAN_BLOCK, m, tok))
d314 1
a314 1
	if ( ! man_block_alloc(m, line, ppos, tok))
d316 1
a316 1
	if ( ! man_head_alloc(m, line, ppos, tok))
d321 1
a321 1
		if ( ! man_args(m, line, pos, buf, &p))
d323 1
a323 1
		if ( ! man_word_alloc(m, line, la, p))
d327 1
a327 1
	assert(m);
d330 1
a330 1
	for (n = m->last; n; n = n->parent) {
d334 1
a334 1
		man_unscope(m, n, MANDOCERR_MAX);
d338 1
a338 1
	return(man_body_alloc(m, line, ppos, tok));
d359 1
a359 1
	if ( ! rew_scope(MAN_BODY, m, tok))
d361 1
a361 1
	if ( ! rew_scope(MAN_BLOCK, m, tok))
d366 1
a366 1
	if ( ! man_block_alloc(m, line, ppos, tok))
d368 1
a368 1
	if ( ! man_head_alloc(m, line, ppos, tok))
d371 1
a371 1
	n = m->last;
d377 1
a377 1
		if ( ! man_args(m, line, pos, buf, &p))
d379 1
a379 1
		if ( ! man_word_alloc(m, line, la, p))
d388 1
a388 1
			m->flags |= MAN_BLINE;
d390 2
a391 2
		} else if (n == m->last) {
			m->flags |= MAN_BLINE;
d396 1
a396 1
	if ( ! rew_scope(MAN_HEAD, m, tok))
d398 1
a398 1
	return(man_body_alloc(m, line, ppos, tok));
d410 1
a410 1
	if ( ! man_elem_alloc(m, line, ppos, tok))
d413 1
a413 1
	n = m->last;
d417 1
a417 1
		if ( ! man_args(m, line, pos, buf, &p))
d419 1
a419 1
		if ( ! man_word_alloc(m, line, la, p))
d429 1
a429 1
	if (n == m->last && MAN_SCOPED & man_macros[tok].flags) {
d431 1
a431 1
		m->flags |= MAN_ELINE;
d439 1
a439 1
		m->flags |= MAN_ILINE;
d442 2
a443 2
	assert(MAN_ROOT != m->last->type);
	m->next = MAN_NEXT_SIBLING;
d451 2
a452 2
	for ( ; m->last; m->last = m->last->parent) {
		if (m->last == n)
d454 1
a454 1
		if (m->last->type == MAN_ROOT)
d456 1
a456 1
		if ( ! man_valid_post(m))
d460 1
a460 1
	assert(m->last);
d466 1
a466 1
	if (m->last->type != MAN_ROOT && ! man_valid_post(m))
d474 1
a474 1
man_macroend(struct man *m)
d477 1
a477 1
	return(man_unscope(m, m->first, MANDOCERR_SCOPEEXIT));
d481 1
a481 1
man_args(struct man *m, int line, int *pos, char *buf, char **v)
d492 1
a492 1
	*v = mandoc_getarg(m->parse, v, line, pos);
@


1.36
log
@Close a preceding implicit block before opening an explicit block.

To allow doing so, no longer abuse rew_scope() to unwind explicit blocks;
explicitly call man_unscope() instead.

Fixing the indentation of slapd.conf(5) in the OpenLDAP port;
thanks to guenther@@ for the report.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.35 2012/06/02 20:07:09 schwarze Exp $ */
d77 1
a77 1
	{ blk_exp, MAN_EXPLICIT }, /* RS */
@


1.35
log
@Minimal implementation of .EX and .EE for GNU compatibility.
Do not use this, it is not portable and only defined in esr's man-ext.
For example, sox(1) wants these macros.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.34 2012/02/26 19:41:27 schwarze Exp $ */
d4 1
d185 6
a190 2
	if (type == n->type && tok == n->tok)
		return(REW_REWIND);
d206 4
d289 1
a289 1
		if (ntok == nn->tok)
d292 3
a294 1
	if (NULL == nn)
a296 5
	if ( ! rew_scope(MAN_BODY, m, ntok))
		return(0);
	if ( ! rew_scope(MAN_BLOCK, m, ntok))
		return(0);

d305 1
d309 4
a312 5
	/* 
	 * Close out prior scopes.  "Regular" explicit macros cannot be
	 * nested, but we allow roff macros to be placed just about
	 * anywhere.
	 */
d330 8
a337 2
	if ( ! rew_scope(MAN_HEAD, m, tok))
		return(0);
@


1.34
log
@Support .OP, one of the extended man macros; from kristaps@@.
Do not use this GNU extension, we take it for compatibility only.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.33 2011/12/04 00:44:18 schwarze Exp $ */
d84 2
@


1.33
log
@When a man document contains nothing at all except one or more invalid
macros, do not die on an assertion, but show correct error messages.
Assertions of meta data validity suggested by joerg@@.
ok joerg@@
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.32 2011/11/05 16:02:18 schwarze Exp $ */
d83 1
@


1.32
log
@When the HEAD scope of .TP is broken by another block macro,
do not abort with a FATAL error, but report a regular ERROR,
remove the broken .TP from the syntax tree, and prod on.
Reported repeatedly by ports people, at least by brad@@ and jeremy@@.
Also fixes rendition(4) in Xenocara.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.31 2011/07/07 04:08:01 schwarze Exp $ */
a118 1
	assert(MAN_ROOT != m->last->type);
@


1.31
log
@Set the default way to append the next node (sibling) before, not after
calling the post handler, such that it doesn't clobber specific decisions
made in the post handler.

Fixes a regression related to vertical spacing in nsd-xfer(8).

Patch from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.30 2011/07/05 04:12:41 schwarze Exp $ */
d51 9
a59 9
	{ in_line_eoln, 0 }, /* TH */
	{ blk_imp, MAN_SCOPED }, /* SH */
	{ blk_imp, MAN_SCOPED }, /* SS */
	{ blk_imp, MAN_SCOPED | MAN_FSCOPED }, /* TP */
	{ blk_imp, 0 }, /* LP */
	{ blk_imp, 0 }, /* PP */
	{ blk_imp, 0 }, /* P */
	{ blk_imp, 0 }, /* IP */
	{ blk_imp, 0 }, /* HP */
d73 2
a74 2
	{ in_line_eoln, 0 }, /* nf */
	{ in_line_eoln, 0 }, /* fi */
@


1.30
log
@Sync to bsd.lv (all coded by kristaps@@):
 - mdoc(7): fix an assertion if the first line after .Bd -column
   starts with a blank, and some simplifications in mdoc_argv.c
 - man(7): literal mode ends at .SH and .SS (bug reported by naddy@@)
 - allow .RS/.RE blocks to nest (bug reported by dcoppa@@ and gsoares@@)
 - improve vertical spacing of man(7) blocks
 - roff(7): clear user-defined strings when starting a new file
 - correct ID tags in -T[x]html
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.29 2011/04/24 16:22:02 schwarze Exp $ */
d119 3
a141 3
	m->next = MAN_ROOT == m->last->type ? 
		MAN_NEXT_CHILD : MAN_NEXT_SIBLING;

d427 3
a453 3

	m->next = MAN_ROOT == m->last->type ?
		MAN_NEXT_CHILD : MAN_NEXT_SIBLING;
@


1.29
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.28 2011/04/21 22:59:54 schwarze Exp $ */
a304 5

	if ( ! rew_scope(MAN_BODY, m, tok))
		return(0);
	if ( ! rew_scope(MAN_BLOCK, m, tok))
		return(0);
@


1.28
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.27 2011/01/16 19:27:25 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d22 1
d24 1
d37 2
d297 1
a297 1
	int		 w, la;
d318 1
a318 5
		w = man_args(m, line, pos, buf, &p);

		if (-1 == w)
			return(0);
		if (0 == w)
a319 1

d344 1
a344 1
	int		 w, la;
d368 1
a368 5
		w = man_args(m, line, pos, buf, &p);

		if (-1 == w)
			return(0);
		if (0 == w)
a369 1

d397 1
a397 1
	int		 w, la;
d408 1
a408 5
		w = man_args(m, line, pos, buf, &p);

		if (-1 == w)
			return(0);
		if (0 == w)
d471 15
@


1.27
log
@Some improvements to error handling from kristaps@@:
* Make out-of-context .fi invocations not cause an error, but just a warning.
* Downgrade -man message about ignored empty paragraph to MANDOC_IGNPAR.
* Avoid syntax tree corruption when removing empty block macros.
Triggered by some reports from brad@@.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.26 2011/01/04 22:28:17 schwarze Exp $ */
d42 1
a42 1
static	int		 rew_warn(struct man *, 
d87 1
a87 1
static int
d92 1
a92 1
		return(1);
d94 1
a94 1
		return(1);
d96 4
a99 2
		return(1);
	return(man_nmsg(m, n, er));
d124 1
a124 2
		if ( ! rew_warn(m, m->last, er))
			return(0);
d131 1
a131 2
	if ( ! rew_warn(m, m->last, er))
		return(0);
d278 1
a278 2
		if ( ! man_pmsg(m, line, ppos, MANDOCERR_NOSCOPE))
			return(0);
@


1.26
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.25 2010/12/19 07:53:12 schwarze Exp $ */
d106 1
a106 1
man_unscope(struct man *m, const struct man_node *n, 
d109 1
d111 1
a111 1
	assert(n);
d114 8
a121 1
	while (m->last != n) {
d126 1
a126 1
		m->last = m->last->parent;
@


1.25
log
@Remove `i' and `r' macro handlers.  These macros, originally part of the
me package, aren't recognised by "groff -mandoc" so we don't need to do
so either.  Besides, they are not used in base or Xenocara, and only at
two or three places in one single port, which are probably typos.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.24 2010/12/01 23:02:59 schwarze Exp $ */
a77 2
	{ blk_exp, MAN_EXPLICIT }, /* TS */
	{ blk_close, 0 }, /* TE */
a258 3
		break;
	case (MAN_TE):
		ntok = MAN_TS;
@


1.24
log
@Merge man_action.c into man_validate.c.
Same as for mdoc_action.c, but much simpler.
Work by kristaps@@, re-applying OpenBSD changes on top.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.23 2010/11/29 02:26:45 schwarze Exp $ */
a67 1
	{ in_line_eoln, 0 }, /* i */
a70 1
	{ in_line_eoln, 0 }, /* r */
@


1.23
log
@Now that we have proper .de support in the roff(7) library,
it is time to remove the .Sp, .Vb, and .Ve kludge
that was added to the man(7) library to build Perl manuals.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.22 2010/11/29 00:12:02 schwarze Exp $ */
a121 2
		if ( ! man_action_post(m))
			return(0);
a129 2
	if ( ! man_action_post(m))
		return(0);
a455 2
		if ( ! man_action_post(m))
			return(0);
a464 2
		return(0);
	if (m->last->type != MAN_ROOT && ! man_action_post(m))
@


1.22
log
@Implement the roff .ft (change font) request for man(7).
Of course, we don't want to encourage low-level physical markup,
but pod2man(1) writes such requests, so Perl manuals contain them,
and some Xenocara and lots and lots of ports manuals use them as well.
In base and Xenocara, this will reduce mandoc -Tlint ERROR noise;
in ports, it will improve rendering of many manuals.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.21 2010/10/15 20:45:03 schwarze Exp $ */
a77 3
	{ in_line_eoln, MAN_NSCOPED }, /* Sp */
	{ in_line_eoln, 0 }, /* Vb */
	{ in_line_eoln, 0 }, /* Ve */
@


1.21
log
@Minimal glue to integrate tbl into the mandoc man(7) parser and formatter.
The output dosn't look nice yet, escape handling is still missing,
but will follow soon.
"move forward aggressively :-)" deraadt@@
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.20 2010/07/25 18:05:54 schwarze Exp $ */
d85 1
@


1.20
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.19 2010/05/23 22:45:00 schwarze Exp $ */
d83 2
d269 3
@


1.19
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.18 2010/05/23 20:57:16 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d82 1
d290 1
d342 1
d400 1
@


1.18
log
@implement .AT and .UC; from Joerg Sonnenberger
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.17 2010/05/20 00:58:02 schwarze Exp $ */
d22 1
d43 1
a43 1
				struct man_node *, enum merr);
d91 1
a91 1
rew_warn(struct man *m, struct man_node *n, enum merr er)
d94 1
a94 1
	if (er == WERRMAX || MAN_BLOCK != n->type)
d100 1
a100 1
	return(man_nwarn(m, n, er));
d105 2
a106 2
 * Rewind scope.  If a code "er" != WERRMAX has been provided, it will
 * be used if an explicit block scope is being closed out.
d109 2
a110 1
man_unscope(struct man *m, const struct man_node *n, enum merr er)
d249 1
a249 1
	return(man_unscope(m, n, WERRMAX));
d277 1
a277 1
		if ( ! man_pwarn(m, line, ppos, WNOSCOPE))
d479 1
a479 1
	return(man_unscope(m, m->first, WEXITSCOPE));
@


1.17
log
@Support nested roff instructions:
* allow roff_parseln() to be re-run
* allow roff_parseln() to manipulate the line buffer offset
* support the offset in the man and mdoc libraries
* adapt .if, .ie, .el, .ig, .am* and .de* support
* interpret some instructions even in conditional-negative context
Coded by kristaps during the last day of the mandoc hackathon.

To avoid regressions in the OpenBSD tree, commit this together
with some small local additions:
* detect roff block end "\}" even on macro lines
* actually implement the ".if n" conditional
* ignore .ds, .rm and .tr in libroff

Also back my old .if/.ie/.el-handling out of libman, reverting:
man.h 1.15 man.c 1.25 man_macro.c 1.15 man_validate.c 1.19
man_action.c 1.15 man_term.c 1.28 man_html.c 1.9.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.16 2010/05/16 00:54:03 schwarze Exp $ */
d80 1
@


1.16
log
@In theory, Kristaps never intended to write a roff parser,
but in practice, most real legacy man(7)uals are using so much
low level roff that we can't really get away without at least
partially handling some roff instructions.

As doing this in man(7) only has become messy and as even some
mdoc(7) pages need it, start a minimal partial roff preprocessor.
As a first step, move handling of .am[i], .de[i] and .ig there.
Do not use the roff preprocessor for new manuals!

Now that we have three main parser libraries - roff, man and mdoc -
each one having its own error handling is becoming messy, too.
Thus, start unifying message handling in one central place,
introducing a new generic function mmsg().

coded by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.15 2010/04/25 16:32:19 schwarze Exp $ */
a32 1
static	int		 blk_cond(MACRO_PROT_ARGS);
a79 3
	{ blk_cond, 0 }, /* if */
	{ blk_cond, 0 }, /* ie */
	{ blk_cond, 0 }, /* el */
a250 44
 * Closure for brace blocks (if, ie, el).
 */
int
man_brace_close(struct man *m, int line, int ppos)
{
	struct man_node	*nif;

	nif = m->last->parent;
	while (nif &&
	    MAN_if != nif->tok &&
	    MAN_ie != nif->tok &&
	    MAN_el != nif->tok)
		nif = nif->parent;

	if (NULL == nif)
		return(man_pwarn(m, line, ppos, WNOSCOPE));

	if (MAN_ie != nif->tok || MAN_USE & nif->flags)
		m->flags &= ~MAN_EL_USE;
	else
		m->flags |= MAN_EL_USE;

	if (MAN_USE & nif->flags) {
		if (nif->prev) {
			nif->prev->next = nif->child;
			nif->child->prev = nif->prev;
			nif->prev = NULL;
		} else {
			nif->parent->child = nif->child;
		}
		nif->parent->nchild += nif->nchild - 1;
		while (nif->child) {
			nif->child->parent = nif->parent;
			nif->child = nif->child->next;
		}
		nif->nchild = 0;
		nif->parent = NULL;
	}
	man_node_delete(m, nif);
	return(1);
}


/*
a390 44
}


/*
 * Parse a conditional roff instruction.
 */
int
blk_cond(MACRO_PROT_ARGS)
{ 
	char		*p = buf + *pos;
	int		 use;

	if (MAN_el == tok)
		use = m->flags & MAN_EL_USE;
	else {
		use = 'n' == *p++;
		/* XXX skip the rest of the condition for now */
		while (*p && !isblank(*p))
			p++;
	}
	m->flags &= ~MAN_EL_USE;

	/* advance to the code controlled by the condition */
	while (*p && isblank(*p))
		p++;
	if ('\0' == *p)
		return(1);

	/* single-line body */
	if (strncmp("\\{", p, 2)) {
		if (use && ! man_parseln(m, line, p))
			return(0);
	        if (MAN_ie == tok && !use)
                        m->flags |= MAN_EL_USE;
		return(1);
        }

	/* multi-line body */
	if ( ! man_block_alloc(m, line, ppos, tok))
		return(0);
	if (use)
		m->last->flags |= MAN_USE;
	p += 2;
	return(*p ? man_parseln(m, line, p) : 1);
@


1.15
log
@Implement roff conditional instructions .if .ie .el, in man(7) only for now;
fixing OpenBSD::PackageName(3p) and friends for espie@@.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.14 2010/04/02 11:37:07 schwarze Exp $ */
a30 1
static	int		 blk_dotted(MACRO_PROT_ARGS);
a80 6
	{ blk_exp, MAN_EXPLICIT | MAN_NOCLOSE}, /* de */
	{ blk_exp, MAN_EXPLICIT | MAN_NOCLOSE}, /* dei */
	{ blk_exp, MAN_EXPLICIT | MAN_NOCLOSE}, /* am */
	{ blk_exp, MAN_EXPLICIT | MAN_NOCLOSE}, /* ami */
	{ blk_exp, MAN_EXPLICIT | MAN_NOCLOSE}, /* ig */
	{ blk_dotted, 0 }, /* . */
a101 2
	if (MAN_NOCLOSE & man_macros[n->tok].flags)
		return(1);
a180 18
	/*
	 * If we're a roff macro, then we can close out anything that
	 * stands between us and our parent context.
	 */
	if (MAN_NOCLOSE & man_macros[tok].flags)
		return(REW_NOHALT);

	/* 
	 * Don't clobber roff macros: this is a bit complicated.  If the
	 * current macro is a roff macro, halt immediately and don't
	 * rewind.  If it's not, and the parent is, then close out the
	 * current scope and halt at the parent.
	 */
	if (MAN_NOCLOSE & man_macros[n->tok].flags)
		return(REW_HALT);
	if (MAN_NOCLOSE & man_macros[n->parent->tok].flags)
		return(REW_REWIND);

a248 2
	if (MAN_NOCLOSE & man_macros[tok].flags)
		return(man_unscope(m, n, WROFFSCOPE));
a298 46
 * Closure for dotted macros (de, dei, am, ami, ign).  This must handle
 * any of these as the parent node, so it needs special handling.
 * Beyond this, it's the same as blk_close().
 */
/* ARGSUSED */
int
blk_dotted(MACRO_PROT_ARGS)
{
	enum mant	 ntok;
	struct man_node	*nn;

	/* Check for any of the following parents... */

	for (nn = m->last->parent; nn; nn = nn->parent)
		if (nn->tok == MAN_de || nn->tok == MAN_dei ||
				nn->tok == MAN_am ||
				nn->tok == MAN_ami ||
				nn->tok == MAN_ig) {
			ntok = nn->tok;
			break;
		}

	if (NULL == nn) {
		if ( ! man_pwarn(m, line, ppos, WNOSCOPE))
			return(0);
		return(1);
	}

	if ( ! rew_scope(MAN_BODY, m, ntok))
		return(0);
	if ( ! rew_scope(MAN_BLOCK, m, ntok))
		return(0);

	/*
	 * Restore flags set when we got here and also stipulate that we
	 * don't post-process the line when exiting the macro op
	 * function in man_pmacro().  See blk_exp().
	 */

	m->flags = m->svflags | MAN_ILINE;
	m->next = m->svnext;
	return(1);
}


/*
d346 4
a349 17
	if ( ! (MAN_NOCLOSE & man_macros[tok].flags)) {
		if ( ! rew_scope(MAN_BODY, m, tok))
			return(0);
		if ( ! rew_scope(MAN_BLOCK, m, tok))
			return(0);
	} else {
		/*
		 * Save our state and next-scope indicator; we restore
		 * it when exiting from the roff instruction block.  See
		 * blk_dotted().
		 */
		m->svflags = m->flags;
		m->svnext = m->next;
		
		/* Make sure we drop any line modes. */
		m->flags = 0;
	}
@


1.14
log
@merge 1.9.20, keeping local patches
* prevent roff instructions in man(7) from clobbering scopes and line modes
  (noted by Sascha Wildner)
* handle leading punctuation in mdoc(7) blocks and line macros
  (looks good in principle, but is causing some fallout in OpenBSD,
   so i will disable it locally for now with the next commit)
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.13 2010/03/29 22:56:52 schwarze Exp $ */
d34 1
d88 3
d284 44
d527 44
@


1.13
log
@merge 1.9.19, keeping local patches
 * scoping fixes for roff instructions
 * accept apostroph in place of dot as a macro control character
 * accept tabs between the control character and the macro name
 * check that man(7) .TH titles use capital letters
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.12 2010/03/26 01:22:05 schwarze Exp $ */
d313 4
a316 4
	/* 
	 * XXX: manually adjust our next-line status.  roff macros are,
	 * for the moment, ignored, so we don't want to close out bodies
	 * and so on.
d319 2
a320 8
	switch (m->last->type) {
	case (MAN_BODY):
		m->next = MAN_NEXT_CHILD;
		break;
	default:
		break;
	}

d378 11
@


1.12
log
@merge 1.9.17, keeping local patches

* much improved pod2man support and low-level roff robustness
* have -Tlint imply -Wall and -fstrict
* use fewer macros and more enum in libman
* and various bug fixes
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.11 2010/03/25 23:23:01 schwarze Exp $ */
d27 1
a27 1
	REW_HALT,
d42 2
d92 23
d116 1
a116 1
man_unscope(struct man *m, const struct man_node *n)
d123 2
d133 2
d168 1
d171 1
d173 2
d177 2
d182 1
a182 1
	/* Rewind to ourselves, first. */
d186 23
d267 7
a273 1
	/* Rewind until the current point. */
d275 1
a275 2
	assert(n);
	return(man_unscope(m, n));
d291 2
d313 14
a557 13
	struct man_node	*n;

	n = MAN_VALID & m->last->flags ?
		m->last->parent : m->last;

	for ( ; n; n = n->parent) {
		if (MAN_BLOCK != n->type)
			continue;
		if ( ! (MAN_EXPLICIT & man_macros[n->tok].flags))
			continue;
		if ( ! man_nwarn(m, n, WEXITSCOPE))
			return(0);
	}
d559 1
a559 1
	return(man_unscope(m, m->first));
@


1.11
log
@merge 1.9.16, keeping local patches

This is mostly cleanup by kristaps@@ after my rather hackish patch
to tolerate the non-text macros .na, .sp, .br in next-line scope;
plus some nesting issues fixed by him, all in man(7).
This survived a full  cd /usr/src; make man.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.10 2010/03/02 01:00:39 schwarze Exp $ */
d24 5
a28 3
#define	REW_REWIND	(0)		/* See rew_scope(). */
#define	REW_NOHALT	(1)		/* See rew_scope(). */
#define	REW_HALT	(2)		/* See rew_scope(). */
d30 4
a34 2
static	int		 blk_imp(MACRO_PROT_ARGS);
static	int		 blk_close(MACRO_PROT_ARGS);
d36 3
a38 2
static	int		 rew_scope(enum man_type, struct man *, int);
static	int 		 rew_dohalt(int, enum man_type, 
d40 1
a40 1
static	int		 rew_block(int, enum man_type, 
d72 1
a72 1
	{ blk_imp, MAN_EXPLICIT }, /* RS */
d76 1
a76 1
	{ in_line_eoln, 0 }, /* Sp */
d79 6
a94 1
	m->next = MAN_NEXT_SIBLING;
d108 7
a114 1
	return(man_action_post(m));
d118 2
a119 2
static int
rew_block(int ntok, enum man_type type, const struct man_node *n)
d134 2
a135 2
static int 
rew_dohalt(int tok, enum man_type type, const struct man_node *n)
d137 1
a137 1
	int		 c;
d190 1
a190 1
rew_scope(enum man_type type, struct man *m, int tok)
d193 1
a193 1
	int		 c;
d216 39
d259 1
a259 1
	int 		 	 ntok;
d283 1
a283 1
	m->next = MAN_NEXT_SIBLING;
d288 47
a393 1

a417 5

		/* XXX ignore Vb arguments for now */
		if (MAN_Vb == tok)
			continue;

d468 3
a470 2
	if (m->last->type != MAN_ROOT)
		m->next = MAN_NEXT_SIBLING;
@


1.10
log
@Accept the non-standard macros .Sp (similar to .sp)
and .Vb/.Ve (similar to .nf/.fi) in man(7) mode.
These are not intended to be used manually, but they allow us to
properly render man(7) code autogenerated by pod2man(1),
making Perl and OpenSSL happy in our tree.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.9 2009/10/27 21:40:07 schwarze Exp $ */
d39 1
a39 1
	{ in_line_eoln, 0 }, /* br */
d60 1
a60 1
	{ in_line_eoln, 0 }, /* na */
d62 1
a62 1
	{ in_line_eoln, 0 }, /* sp */
d326 6
d333 1
d338 7
d346 3
a348 2
	 * Note that when TH is pruned, we'll be back at the root, so
	 * make sure that we don't clobber as its sibling.
@


1.9
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.8 2009/09/18 22:46:14 schwarze Exp $ */
d71 3
d317 4
@


1.8
log
@sync to 1.9.2: Add .UC libman macro for compatibility, has no effect.
Correct .UC and .DT to not print their arguments.
Document that .UC and .DT should not be used.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.7 2009/08/22 23:17:40 schwarze Exp $ */
d70 1
@


1.7
log
@another large chunk of -man updates,
among others regarding .DT, .HP, .RS, .RE, .SH, .SS, and scoping,
now in sync vith release 1.9.1
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.6 2009/08/22 20:14:37 schwarze Exp $ */
d69 1
@


1.6
log
@Kristaps@@ significantly overhauled libman.
I'm committing this in one large chunk because in contrast to -mdoc, -man
is mostly untested in OpenBSD anyway, so any fallout can be fixed in-tree.
Among others, improved support for .IP, .HP, and .TP.
Now in sync with release 1.9.0.
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.5 2009/08/22 15:15:37 schwarze Exp $ */
d30 1
d35 2
d41 3
a43 3
	{ blk_imp, 0 }, /* SH */
	{ blk_imp, 0 }, /* SS */
	{ blk_imp, MAN_SCOPED }, /* TP */
d66 3
d97 11
d116 1
d126 4
a131 3
		/* Rewind to ourselves. */
		if (type == n->type && tok == n->tok)
			return(REW_REWIND);
a133 3
		/* Rewind to ourselves. */
		if (type == n->type && tok == n->tok)
			return(REW_REWIND);
d135 10
a144 6
		if (MAN_BLOCK == type && MAN_SH == n->parent->tok && 
				MAN_BODY == n->parent->type)
			return(REW_REWIND);
		/* Don't go beyond a section. */
		if (MAN_SH == n->tok)
			return(REW_HALT);
d147 3
a149 3
		/* Rewind to ourselves. */
		if (type == n->type && tok == n->tok)
			return(REW_REWIND);
d151 2
a152 6
		if (MAN_BLOCK == type && MAN_SS == n->parent->tok && 
				MAN_BODY == n->parent->type)
			return(REW_REWIND);
		/* Don't go beyond a subsection. */
		if (MAN_SS == n->tok)
			return(REW_HALT);
d154 2
a155 6
		if (MAN_BLOCK == type && MAN_SH == n->parent->tok && 
				MAN_BODY == n->parent->type)
			return(REW_REWIND);
		/* Don't go beyond a section. */
		if (MAN_SH == n->tok)
			return(REW_HALT);
d195 33
d239 1
d255 2
a269 1
		m->next = MAN_NEXT_SIBLING;
d275 11
a285 3
		m->flags |= MAN_BLINE;
		return(1);
	} else if ( ! rew_scope(MAN_HEAD, m, tok))
a302 1
	m->next = MAN_NEXT_CHILD;
a314 1
		m->next = MAN_NEXT_SIBLING;
d317 1
a317 1
	if (n == m->last && (MAN_SCOPED & man_macros[tok].flags)) {
a326 2
	/* FIXME: clean this to use man_unscope(). */

d358 13
@


1.5
log
@sync to 1.8.4: support .sp in -man
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.4 2009/06/23 22:05:42 schwarze Exp $ */
d24 40
a63 2
#define	FL_NLINE	(1 << 0)
#define	FL_TLINE	(1 << 1)
d65 1
a65 2
static	int		 man_args(struct man *, int, 
				int *, char *, char **);
a66 26
static	int man_flags[MAN_MAX] = {
	0, /* br */
	0, /* TH */
	0, /* SH */
	0, /* SS */
	FL_TLINE, /* TP */
	0, /* LP */
	0, /* PP */
	0, /* P */
	0, /* IP */
	0, /* HP */
	FL_NLINE, /* SM */
	FL_NLINE, /* SB */
	FL_NLINE, /* BI */
	FL_NLINE, /* IB */
	FL_NLINE, /* BR */
	FL_NLINE, /* RB */
	FL_NLINE, /* R */
	FL_NLINE, /* B */
	FL_NLINE, /* I */
	FL_NLINE, /* IR */
	FL_NLINE, /* RI */
	0, /* na */
	FL_NLINE, /* i */
	0, /* sp */
};
d69 1
a69 2
man_macro(struct man *man, int tok, int line, 
		int ppos, int *pos, char *buf)
a70 3
	int		 w, la;
	char		*p;
	struct man_node	*n;
d72 14
a85 1
	if ( ! man_elem_alloc(man, line, ppos, tok))
d87 2
a88 2
	n = man->last;
	man->next = MAN_NEXT_CHILD;
a89 3
	for (;;) {
		la = *pos;
		w = man_args(man, line, pos, buf, &p);
d91 8
a98 4
		if (-1 == w)
			return(0);
		if (0 == w)
			break;
d100 45
a144 3
		if ( ! man_word_alloc(man, line, la, p))
			return(0);
		man->next = MAN_NEXT_SIBLING;
d147 2
a148 6
	if (n == man->last && (FL_NLINE & man_flags[tok])) {
		if (MAN_NLINE & man->flags) 
			return(man_perr(man, line, ppos, WLNSCOPE));
		man->flags |= MAN_NLINE;
		return(1);
	}
a149 6
	if (FL_TLINE & man_flags[tok]) {
		if (MAN_NLINE & man->flags) 
			return(man_perr(man, line, ppos, WLNSCOPE));
		man->flags |= MAN_NLINE;
		return(1);
	}
d151 10
a160 4
	/*
	 * Note that when TH is pruned, we'll be back at the root, so
	 * make sure that we don't clobber as its sibling.
	 */
d162 11
a172 2
	for ( ; man->last; man->last = man->last->parent) {
		if (man->last == n)
a173 6
		if (man->last->type == MAN_ROOT)
			break;
		if ( ! man_valid_post(man))
			return(0);
		if ( ! man_action_post(man))
			return(0);
d176 6
a181 1
	assert(man->last);
d183 13
a195 3
	/*
	 * Same here regarding whether we're back at the root. 
	 */
d197 1
a197 1
	if (man->last->type != MAN_ROOT && ! man_valid_post(man))
d199 1
a199 1
	if (man->last->type != MAN_ROOT && ! man_action_post(man))
a200 2
	if (man->last->type != MAN_ROOT)
		man->next = MAN_NEXT_SIBLING;
d202 6
a207 2
	return(1);
}
d209 1
d211 3
a213 3
int
man_macroend(struct man *m)
{
d215 1
a215 3
	for ( ; m->last && m->last != m->first; 
			m->last = m->last->parent) {
		if ( ! man_valid_post(m))
d217 4
a220 1
		if ( ! man_action_post(m))
d222 1
a223 1
	assert(m->last == m->first);
d225 6
a230 3
	if ( ! man_valid_post(m))
		return(0);
	if ( ! man_action_post(m))
d233 1
a233 1
	return(1);
d237 2
a238 4
/* ARGSUSED */
static int
man_args(struct man *m, int line, 
		int *pos, char *buf, char **v)
d240 3
d244 1
a244 1
	if (0 == buf[*pos])
d247 2
a248 1
	/* First parse non-quoted strings. */
d250 3
a252 2
	if ('\"' != buf[*pos]) {
		*v = &buf[*pos];
d254 4
a257 6
		while (buf[*pos]) {
			if (' ' == buf[*pos])
				if ('\\' != buf[*pos - 1])
					break;
			(*pos)++;
		}
d259 4
a262 2
		if (0 == buf[*pos])
			return(1);
d264 4
a267 1
		buf[(*pos)++] = 0;
d269 4
a272 2
		if (0 == buf[*pos])
			return(1);
d274 1
a274 2
		while (buf[*pos] && ' ' == buf[*pos])
			(*pos)++;
d276 10
a285 2
		if (buf[*pos])
			return(1);
d287 1
a287 5
		if ( ! man_pwarn(m, line, *pos, WTSPACE))
			return(-1);

		return(1);
	}
d290 1
a290 3
	 * If we're a quoted string (and quoted strings are allowed),
	 * then parse ahead to the next quote.  If none's found, it's an
	 * error.  After, parse to the next word.  
d293 6
a298 1
	*v = &buf[++(*pos)];
d300 2
a301 2
	while (buf[*pos] && '\"' != buf[*pos])
		(*pos)++;
a302 5
	if (0 == buf[*pos]) {
		if ( ! man_pwarn(m, line, *pos, WTQUOTE))
			return(-1);
		return(1);
	}
d304 3
a306 3
	buf[(*pos)++] = 0;
	if (0 == buf[*pos])
		return(1);
d308 2
a309 2
	while (buf[*pos] && ' ' == buf[*pos])
		(*pos)++;
a310 7
	if (buf[*pos])
		return(1);

	if ( ! man_pwarn(m, line, *pos, WTSPACE))
		return(-1);
	return(1);
}
@


1.4
log
@sync to 1.7.20: error reporting functions for -man
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.3 2009/06/18 23:34:53 schwarze Exp $ */
d54 1
@


1.3
log
@sync to 1.7.19: improved comment handling
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.2 2009/06/14 23:00:57 schwarze Exp $ */
d85 1
a85 2
			return(man_verr(man, line, ppos, 
				"next-line scope already open"));
d92 1
a92 2
			return(man_verr(man, line, ppos, 
				"next-line scope already open"));
d187 1
a187 1
		if ( ! man_vwarn(m, line, *pos, "trailing spaces"))
d205 1
a205 1
		if ( ! man_vwarn(m, line, *pos, "unterminated quote"))
d220 1
a220 1
	if ( ! man_vwarn(m, line, *pos, "trailing spaces"))
@


1.2
log
@sync to 1.7.16: comments, whitespace and spelling fixes; no functional change
@
text
@d1 1
a1 1
/*	$Id: man_macro.c,v 1.15 2009/06/10 20:18:43 kristaps Exp $ */
d31 1
a31 1
	0, /* __ */
a51 1
	0, /* br */
@


1.1
log
@Initial check-in of mandoc for formatting manuals. ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: man_macro.c,v 1.13 2009/04/05 16:34:22 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@

