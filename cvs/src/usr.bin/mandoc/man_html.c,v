head	1.96;
access;
symbols
	OPENBSD_6_1:1.88.0.4
	OPENBSD_6_1_BASE:1.88
	OPENBSD_6_0:1.73.0.4
	OPENBSD_6_0_BASE:1.73
	OPENBSD_5_9:1.73.0.2
	OPENBSD_5_9_BASE:1.73
	OPENBSD_5_8:1.70.0.4
	OPENBSD_5_8_BASE:1.70
	OPENBSD_5_7:1.65.0.2
	OPENBSD_5_7_BASE:1.65
	OPENBSD_5_6:1.54.0.4
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.49.0.4
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.48.0.4
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.48.0.2
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.47.0.2
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.2
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.96
date	2017.06.08.12.54.40;	author schwarze;	state Exp;
branches;
next	1.95;
commitid	XZ3BGDIHuY6bbJk8;

1.95
date	2017.05.09.14.09.37;	author schwarze;	state Exp;
branches;
next	1.94;
commitid	lMrRruJRFJONCC2s;

1.94
date	2017.05.05.15.16.25;	author schwarze;	state Exp;
branches;
next	1.93;
commitid	sNJdFUhzoVfGBx2p;

1.93
date	2017.05.05.13.17.04;	author schwarze;	state Exp;
branches;
next	1.92;
commitid	GvSRKa33jIoa4JAJ;

1.92
date	2017.05.05.02.06.17;	author schwarze;	state Exp;
branches;
next	1.91;
commitid	JMX1RJlA2uFuu13l;

1.91
date	2017.05.04.22.07.44;	author schwarze;	state Exp;
branches;
next	1.90;
commitid	hU9bJPcS66QLg54n;

1.90
date	2017.05.04.17.48.24;	author schwarze;	state Exp;
branches;
next	1.89;
commitid	RHQLdCAdHKxKe8Eu;

1.89
date	2017.04.24.23.06.09;	author schwarze;	state Exp;
branches;
next	1.88;
commitid	2CfzvK3gmiJH7vY0;

1.88
date	2017.03.17.12.06.02;	author schwarze;	state Exp;
branches;
next	1.87;
commitid	7zoCzbhQdxe8xmSR;

1.87
date	2017.03.15.11.29.50;	author schwarze;	state Exp;
branches;
next	1.86;
commitid	0AJYQsnYnWohs8XM;

1.86
date	2017.02.05.18.13.28;	author schwarze;	state Exp;
branches;
next	1.85;
commitid	LLN2XeSKb4BTOEt6;

1.85
date	2017.01.30.20.23.07;	author schwarze;	state Exp;
branches;
next	1.84;
commitid	m6iJOkLnHzDqqjNm;

1.84
date	2017.01.29.14.02.19;	author schwarze;	state Exp;
branches;
next	1.83;
commitid	kwoDToz7gzAquXDa;

1.83
date	2017.01.26.18.28.04;	author schwarze;	state Exp;
branches;
next	1.82;
commitid	Yxdf4tUMRu7gtmiH;

1.82
date	2017.01.21.01.20.29;	author schwarze;	state Exp;
branches;
next	1.81;
commitid	t1CIT40aRIdTYb2t;

1.81
date	2017.01.20.23.50.59;	author schwarze;	state Exp;
branches;
next	1.80;
commitid	28q3y1yOo9OK4SqA;

1.80
date	2017.01.19.15.27.26;	author schwarze;	state Exp;
branches;
next	1.79;
commitid	t4IwDKuwDsVdECRx;

1.79
date	2017.01.19.13.34.59;	author schwarze;	state Exp;
branches;
next	1.78;
commitid	kkzxtGlbuEtTMCNs;

1.78
date	2017.01.19.01.00.11;	author schwarze;	state Exp;
branches;
next	1.77;
commitid	JaaPsBMnLuMI8auG;

1.77
date	2017.01.18.19.22.18;	author schwarze;	state Exp;
branches;
next	1.76;
commitid	rkOTHV44amzifb9Y;

1.76
date	2017.01.17.15.32.39;	author schwarze;	state Exp;
branches;
next	1.75;
commitid	bt3XYYmdm9H0zf44;

1.75
date	2017.01.17.01.47.46;	author schwarze;	state Exp;
branches;
next	1.74;
commitid	Nv06v3QGWa6dYYKr;

1.74
date	2017.01.10.13.46.53;	author schwarze;	state Exp;
branches;
next	1.73;
commitid	aFt8sLe7F06PjFYh;

1.73
date	2016.01.08.17.48.04;	author schwarze;	state Exp;
branches;
next	1.72;
commitid	DoGoemryKYV644MI;

1.72
date	2015.10.06.18.30.43;	author schwarze;	state Exp;
branches;
next	1.71;
commitid	hxQV8O1pNUaef4ir;

1.71
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.70;
commitid	191tWtskbsgcpQqV;

1.70
date	2015.04.18.17.50.02;	author schwarze;	state Exp;
branches;
next	1.69;
commitid	sjmmdLSx1e3Vat0h;

1.69
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.68;
commitid	6MYJ7cd8mhJ77AGH;

1.68
date	2015.04.02.23.47.43;	author schwarze;	state Exp;
branches;
next	1.67;
commitid	RJFkOLiS9gBqEEDl;

1.67
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.66;
commitid	Rfx1oTaH3hZ7Zcyf;

1.66
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.65;
commitid	lmErjWY2O9ooA6RY;

1.65
date	2015.03.03.21.09.25;	author schwarze;	state Exp;
branches;
next	1.64;
commitid	izwoW6RxyHdvv5wj;

1.64
date	2015.02.10.08.05.07;	author schwarze;	state Exp;
branches;
next	1.63;
commitid	udnlyXKeRKvRFGfq;

1.63
date	2015.01.30.22.04.15;	author schwarze;	state Exp;
branches;
next	1.62;
commitid	EStyTVNpkesjWq58;

1.62
date	2015.01.24.02.41.32;	author schwarze;	state Exp;
branches;
next	1.61;
commitid	TIJT04XdY4be3Or5;

1.61
date	2014.12.23.09.31.17;	author schwarze;	state Exp;
branches;
next	1.60;
commitid	SXZbldG8wiiZaqvE;

1.60
date	2014.12.04.02.05.16;	author schwarze;	state Exp;
branches;
next	1.59;
commitid	P8Z9Zeh4SkD71zxl;

1.59
date	2014.12.02.10.07.17;	author schwarze;	state Exp;
branches;
next	1.58;
commitid	G1dK13T4nePhhgx3;

1.58
date	2014.12.01.08.05.02;	author schwarze;	state Exp;
branches;
next	1.57;
commitid	dkxNPoJe0koFMMLd;

1.57
date	2014.11.28.19.25.03;	author schwarze;	state Exp;
branches;
next	1.56;
commitid	1m1y3OocNVYDnyZE;

1.56
date	2014.10.07.18.17.05;	author schwarze;	state Exp;
branches;
next	1.55;
commitid	ovhOTvwzuIxZwsAn;

1.55
date	2014.08.08.16.00.23;	author schwarze;	state Exp;
branches;
next	1.54;
commitid	m0QaUWeqjuHsvBSO;

1.54
date	2014.04.23.16.07.06;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2014.04.20.20.17.36;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2014.03.08.15.50.21;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2013.10.17.20.51.29;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2012.11.17.00.25.20;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2012.06.02.20.07.09;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2012.02.26.19.41.27;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2011.12.04.00.44.18;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2011.10.09.22.10.51;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2011.10.09.17.59.56;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.08.17.47.54;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2011.07.05.04.12.41;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2011.03.20.23.36.42;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2011.03.07.01.35.33;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2011.01.17.00.15.19;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2011.01.16.19.41.16;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2011.01.16.03.46.21;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2011.01.16.02.56.47;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.09.16.31.45;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.04.01.15.39;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2010.12.25.13.23.03;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.22.22.35.05;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.19.09.22.35;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2010.12.19.07.53.12;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2010.12.07.00.06.24;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2010.12.06.22.43.54;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2010.11.29.02.26.45;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2010.11.29.00.12.02;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2010.10.15.20.45.03;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.27.21.54.42;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.06.18.08.41;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.23.22.45.00;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.23.20.57.16;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2010.05.20.00.58.02;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.16.00.54.03;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.15.18.06.02;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.25.16.32.19;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.26.01.22.05;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.25.23.23.01;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.02.01.00.39;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.18.02.11.26;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.24.02.08.14;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.10.21.19.13.50;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.96
log
@make the internal a2roffsu() interface more powerful by returning
a pointer to the end of the parsed data, making it easier to
parse subsequent bytes
@
text
@/*	$OpenBSD: man_html.c,v 1.95 2017/05/09 14:09:37 schwarze Exp $ */
/*
 * Copyright (c) 2008-2012, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2013, 2014, 2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc_aux.h"
#include "roff.h"
#include "man.h"
#include "out.h"
#include "html.h"
#include "main.h"

/* FIXME: have PD set the default vspace width. */

#define	INDENT		  5

#define	MAN_ARGS	  const struct roff_meta *man, \
			  const struct roff_node *n, \
			  struct html *h

struct	htmlman {
	int		(*pre)(MAN_ARGS);
	int		(*post)(MAN_ARGS);
};

static	void		  print_bvspace(struct html *,
				const struct roff_node *);
static	void		  print_man_head(MAN_ARGS);
static	void		  print_man_nodelist(MAN_ARGS);
static	void		  print_man_node(MAN_ARGS);
static	int		  fillmode(struct html *, int);
static	int		  a2width(const struct roff_node *,
				struct roffsu *);
static	int		  man_B_pre(MAN_ARGS);
static	int		  man_HP_pre(MAN_ARGS);
static	int		  man_IP_pre(MAN_ARGS);
static	int		  man_I_pre(MAN_ARGS);
static	int		  man_OP_pre(MAN_ARGS);
static	int		  man_PP_pre(MAN_ARGS);
static	int		  man_RS_pre(MAN_ARGS);
static	int		  man_SH_pre(MAN_ARGS);
static	int		  man_SM_pre(MAN_ARGS);
static	int		  man_SS_pre(MAN_ARGS);
static	int		  man_UR_pre(MAN_ARGS);
static	int		  man_alt_pre(MAN_ARGS);
static	int		  man_ign_pre(MAN_ARGS);
static	int		  man_in_pre(MAN_ARGS);
static	void		  man_root_post(MAN_ARGS);
static	void		  man_root_pre(MAN_ARGS);

static	const struct htmlman __mans[MAN_MAX - MAN_TH] = {
	{ NULL, NULL }, /* TH */
	{ man_SH_pre, NULL }, /* SH */
	{ man_SS_pre, NULL }, /* SS */
	{ man_IP_pre, NULL }, /* TP */
	{ man_PP_pre, NULL }, /* LP */
	{ man_PP_pre, NULL }, /* PP */
	{ man_PP_pre, NULL }, /* P */
	{ man_IP_pre, NULL }, /* IP */
	{ man_HP_pre, NULL }, /* HP */
	{ man_SM_pre, NULL }, /* SM */
	{ man_SM_pre, NULL }, /* SB */
	{ man_alt_pre, NULL }, /* BI */
	{ man_alt_pre, NULL }, /* IB */
	{ man_alt_pre, NULL }, /* BR */
	{ man_alt_pre, NULL }, /* RB */
	{ NULL, NULL }, /* R */
	{ man_B_pre, NULL }, /* B */
	{ man_I_pre, NULL }, /* I */
	{ man_alt_pre, NULL }, /* IR */
	{ man_alt_pre, NULL }, /* RI */
	{ NULL, NULL }, /* nf */
	{ NULL, NULL }, /* fi */
	{ NULL, NULL }, /* RE */
	{ man_RS_pre, NULL }, /* RS */
	{ man_ign_pre, NULL }, /* DT */
	{ man_ign_pre, NULL }, /* UC */
	{ man_ign_pre, NULL }, /* PD */
	{ man_ign_pre, NULL }, /* AT */
	{ man_in_pre, NULL }, /* in */
	{ man_OP_pre, NULL }, /* OP */
	{ NULL, NULL }, /* EX */
	{ NULL, NULL }, /* EE */
	{ man_UR_pre, NULL }, /* UR */
	{ NULL, NULL }, /* UE */
};
static	const struct htmlman *const mans = __mans - MAN_TH;


/*
 * Printing leading vertical space before a block.
 * This is used for the paragraph macros.
 * The rules are pretty simple, since there's very little nesting going
 * on here.  Basically, if we're the first within another block (SS/SH),
 * then don't emit vertical space.  If we are (RS), then do.  If not the
 * first, print it.
 */
static void
print_bvspace(struct html *h, const struct roff_node *n)
{

	if (n->body && n->body->child)
		if (n->body->child->type == ROFFT_TBL)
			return;

	if (n->parent->type == ROFFT_ROOT || n->parent->tok != MAN_RS)
		if (NULL == n->prev)
			return;

	print_paragraph(h);
}

void
html_man(void *arg, const struct roff_man *man)
{
	struct html	*h;
	struct tag	*t;

	h = (struct html *)arg;

	if ((h->oflags & HTML_FRAGMENT) == 0) {
		print_gen_decls(h);
		print_otag(h, TAG_HTML, "");
		t = print_otag(h, TAG_HEAD, "");
		print_man_head(&man->meta, man->first, h);
		print_tagq(h, t);
		print_otag(h, TAG_BODY, "");
	}

	man_root_pre(&man->meta, man->first, h);
	t = print_otag(h, TAG_DIV, "c", "manual-text");
	print_man_nodelist(&man->meta, man->first->child, h);
	print_tagq(h, t);
	man_root_post(&man->meta, man->first, h);
	print_tagq(h, NULL);
}

static void
print_man_head(MAN_ARGS)
{
	char	*cp;

	print_gen_head(h);
	mandoc_asprintf(&cp, "%s(%s)", man->title, man->msec);
	print_otag(h, TAG_TITLE, "");
	print_text(h, cp);
	free(cp);
}

static void
print_man_nodelist(MAN_ARGS)
{

	while (n != NULL) {
		print_man_node(man, n, h);
		n = n->next;
	}
}

static void
print_man_node(MAN_ARGS)
{
	static int	 want_fillmode = MAN_fi;
	static int	 save_fillmode;

	struct tag	*t;
	int		 child;

	/*
	 * Handle fill mode switch requests up front,
	 * they would just cause trouble in the subsequent code.
	 */

	switch (n->tok) {
	case MAN_nf:
	case MAN_EX:
		want_fillmode = MAN_nf;
		return;
	case MAN_fi:
	case MAN_EE:
		want_fillmode = MAN_fi;
		if (fillmode(h, 0) == MAN_fi)
			print_otag(h, TAG_BR, "");
		return;
	default:
		break;
	}

	/* Set up fill mode for the upcoming node. */

	switch (n->type) {
	case ROFFT_BLOCK:
		save_fillmode = 0;
		/* Some block macros suspend or cancel .nf. */
		switch (n->tok) {
		case MAN_TP:  /* Tagged paragraphs		*/
		case MAN_IP:  /* temporarily disable .nf	*/
		case MAN_HP:  /* for the head.			*/
			save_fillmode = want_fillmode;
			/* FALLTHROUGH */
		case MAN_SH:  /* Section headers		*/
		case MAN_SS:  /* permanently cancel .nf.	*/
			want_fillmode = MAN_fi;
			/* FALLTHROUGH */
		case MAN_PP:  /* These have no head.		*/
		case MAN_LP:  /* They will simply		*/
		case MAN_P:   /* reopen .nf in the body.	*/
		case MAN_RS:
		case MAN_UR:
			fillmode(h, MAN_fi);
			break;
		default:
			break;
		}
		break;
	case ROFFT_TBL:
		fillmode(h, MAN_fi);
		break;
	case ROFFT_ELEM:
		/*
		 * Some in-line macros produce tags and/or text
		 * in the handler, so they require fill mode to be
		 * configured up front just like for text nodes.
		 * For the others, keep the traditional approach
		 * of doing the same, for now.
		 */
		fillmode(h, want_fillmode);
		break;
	case ROFFT_TEXT:
		if (fillmode(h, want_fillmode) == MAN_fi &&
		    want_fillmode == MAN_fi &&
		    n->flags & NODE_LINE && *n->string == ' ' &&
		    (h->flags & HTML_NONEWLINE) == 0)
			print_otag(h, TAG_BR, "");
		if (*n->string != '\0')
			break;
		print_paragraph(h);
		return;
	default:
		break;
	}

	/* Produce output for this node. */

	child = 1;
	switch (n->type) {
	case ROFFT_TEXT:
		t = h->tag;
		print_text(h, n->string);
		break;
	case ROFFT_EQN:
		t = h->tag;
		print_eqn(h, n->eqn);
		break;
	case ROFFT_TBL:
		/*
		 * This will take care of initialising all of the table
		 * state data for the first table, then tearing it down
		 * for the last one.
		 */
		print_tbl(h, n->span);
		return;
	default:
		/*
		 * Close out scope of font prior to opening a macro
		 * scope.
		 */
		if (HTMLFONT_NONE != h->metac) {
			h->metal = h->metac;
			h->metac = HTMLFONT_NONE;
		}

		/*
		 * Close out the current table, if it's open, and unset
		 * the "meta" table state.  This will be reopened on the
		 * next table element.
		 */
		if (h->tblt)
			print_tblclose(h);

		t = h->tag;
		if (n->tok < ROFF_MAX) {
			roff_html_pre(h, n);
			child = 0;
			break;
		}

		assert(n->tok >= MAN_TH && n->tok < MAN_MAX);
		if (mans[n->tok].pre)
			child = (*mans[n->tok].pre)(man, n, h);

		/* Some block macros resume .nf in the body. */
		if (save_fillmode && n->type == ROFFT_BODY)
			want_fillmode = save_fillmode;

		break;
	}

	if (child && n->child)
		print_man_nodelist(man, n->child, h);

	/* This will automatically close out any font scope. */
	print_stagq(h, t);

	if (fillmode(h, 0) == MAN_nf &&
	    n->next != NULL && n->next->flags & NODE_LINE)
		print_endline(h);
}

/*
 * MAN_nf switches to no-fill mode, MAN_fi to fill mode.
 * Other arguments do not switch.
 * The old mode is returned.
 */
static int
fillmode(struct html *h, int want)
{
	struct tag	*pre;
	int		 had;

	for (pre = h->tag; pre != NULL; pre = pre->next)
		if (pre->tag == TAG_PRE)
			break;

	had = pre == NULL ? MAN_fi : MAN_nf;

	if (want && want != had) {
		if (want == MAN_nf)
			print_otag(h, TAG_PRE, "");
		else
			print_tagq(h, pre);
	}
	return had;
}

static int
a2width(const struct roff_node *n, struct roffsu *su)
{
	if (n->type != ROFFT_TEXT)
		return 0;
	return a2roffsu(n->string, su, SCALE_EN) != NULL;
}

static void
man_root_pre(MAN_ARGS)
{
	struct tag	*t, *tt;
	char		*title;

	assert(man->title);
	assert(man->msec);
	mandoc_asprintf(&title, "%s(%s)", man->title, man->msec);

	t = print_otag(h, TAG_TABLE, "c", "head");
	tt = print_otag(h, TAG_TR, "");

	print_otag(h, TAG_TD, "c", "head-ltitle");
	print_text(h, title);
	print_stagq(h, tt);

	print_otag(h, TAG_TD, "c", "head-vol");
	if (NULL != man->vol)
		print_text(h, man->vol);
	print_stagq(h, tt);

	print_otag(h, TAG_TD, "c", "head-rtitle");
	print_text(h, title);
	print_tagq(h, t);
	free(title);
}

static void
man_root_post(MAN_ARGS)
{
	struct tag	*t, *tt;

	t = print_otag(h, TAG_TABLE, "c", "foot");
	tt = print_otag(h, TAG_TR, "");

	print_otag(h, TAG_TD, "c", "foot-date");
	print_text(h, man->date);
	print_stagq(h, tt);

	print_otag(h, TAG_TD, "c", "foot-os");
	if (man->os)
		print_text(h, man->os);
	print_tagq(h, t);
}

static int
man_SH_pre(MAN_ARGS)
{
	char	*id;

	if (n->type == ROFFT_HEAD) {
		id = html_make_id(n);
		print_otag(h, TAG_H1, "cTi", "Sh", id);
		if (id != NULL)
			print_otag(h, TAG_A, "chR", "selflink", id);
		free(id);
	}
	return 1;
}

static int
man_alt_pre(MAN_ARGS)
{
	const struct roff_node	*nn;
	int		 i;
	enum htmltag	 fp;
	struct tag	*t;

	for (i = 0, nn = n->child; nn; nn = nn->next, i++) {
		switch (n->tok) {
		case MAN_BI:
			fp = i % 2 ? TAG_I : TAG_B;
			break;
		case MAN_IB:
			fp = i % 2 ? TAG_B : TAG_I;
			break;
		case MAN_RI:
			fp = i % 2 ? TAG_I : TAG_MAX;
			break;
		case MAN_IR:
			fp = i % 2 ? TAG_MAX : TAG_I;
			break;
		case MAN_BR:
			fp = i % 2 ? TAG_MAX : TAG_B;
			break;
		case MAN_RB:
			fp = i % 2 ? TAG_B : TAG_MAX;
			break;
		default:
			abort();
		}

		if (i)
			h->flags |= HTML_NOSPACE;

		if (fp != TAG_MAX)
			t = print_otag(h, fp, "");

		print_text(h, nn->string);

		if (fp != TAG_MAX)
			print_tagq(h, t);
	}
	return 0;
}

static int
man_SM_pre(MAN_ARGS)
{
	print_otag(h, TAG_SMALL, "");
	if (MAN_SB == n->tok)
		print_otag(h, TAG_B, "");
	return 1;
}

static int
man_SS_pre(MAN_ARGS)
{
	char	*id;

	if (n->type == ROFFT_HEAD) {
		id = html_make_id(n);
		print_otag(h, TAG_H2, "cTi", "Ss", id);
		if (id != NULL)
			print_otag(h, TAG_A, "chR", "selflink", id);
		free(id);
	}
	return 1;
}

static int
man_PP_pre(MAN_ARGS)
{

	if (n->type == ROFFT_HEAD)
		return 0;
	else if (n->type == ROFFT_BLOCK)
		print_bvspace(h, n);

	return 1;
}

static int
man_IP_pre(MAN_ARGS)
{
	const struct roff_node	*nn;

	if (n->type == ROFFT_BODY) {
		print_otag(h, TAG_DD, "c", "It-tag");
		return 1;
	} else if (n->type != ROFFT_HEAD) {
		print_otag(h, TAG_DL, "c", "Bl-tag");
		return 1;
	}

	/* FIXME: width specification. */

	print_otag(h, TAG_DT, "c", "It-tag");

	/* For IP, only print the first header element. */

	if (MAN_IP == n->tok && n->child)
		print_man_node(man, n->child, h);

	/* For TP, only print next-line header elements. */

	if (MAN_TP == n->tok) {
		nn = n->child;
		while (NULL != nn && 0 == (NODE_LINE & nn->flags))
			nn = nn->next;
		while (NULL != nn) {
			print_man_node(man, nn, h);
			nn = nn->next;
		}
	}

	return 0;
}

static int
man_HP_pre(MAN_ARGS)
{
	struct roffsu	 sum, sui;
	const struct roff_node *np;

	if (n->type == ROFFT_HEAD)
		return 0;
	else if (n->type != ROFFT_BLOCK)
		return 1;

	np = n->head->child;

	if (np == NULL || !a2width(np, &sum))
		SCALE_HS_INIT(&sum, INDENT);

	sui.unit = sum.unit;
	sui.scale = -sum.scale;

	print_bvspace(h, n);
	print_otag(h, TAG_DIV, "csului", "Pp", &sum, &sui);
	return 1;
}

static int
man_OP_pre(MAN_ARGS)
{
	struct tag	*tt;

	print_text(h, "[");
	h->flags |= HTML_NOSPACE;
	tt = print_otag(h, TAG_SPAN, "c", "Op");

	if (NULL != (n = n->child)) {
		print_otag(h, TAG_B, "");
		print_text(h, n->string);
	}

	print_stagq(h, tt);

	if (NULL != n && NULL != n->next) {
		print_otag(h, TAG_I, "");
		print_text(h, n->next->string);
	}

	print_stagq(h, tt);
	h->flags |= HTML_NOSPACE;
	print_text(h, "]");
	return 0;
}

static int
man_B_pre(MAN_ARGS)
{
	print_otag(h, TAG_B, "");
	return 1;
}

static int
man_I_pre(MAN_ARGS)
{
	print_otag(h, TAG_I, "");
	return 1;
}

static int
man_in_pre(MAN_ARGS)
{
	print_otag(h, TAG_BR, "");
	return 0;
}

static int
man_ign_pre(MAN_ARGS)
{

	return 0;
}

static int
man_RS_pre(MAN_ARGS)
{
	struct roffsu	 su;

	if (n->type == ROFFT_HEAD)
		return 0;
	else if (n->type == ROFFT_BODY)
		return 1;

	SCALE_HS_INIT(&su, INDENT);
	if (n->head->child)
		a2width(n->head->child, &su);

	print_otag(h, TAG_DIV, "sul", &su);
	return 1;
}

static int
man_UR_pre(MAN_ARGS)
{
	n = n->child;
	assert(n->type == ROFFT_HEAD);
	if (n->child != NULL) {
		assert(n->child->type == ROFFT_TEXT);
		print_otag(h, TAG_A, "cTh", "Lk", n->child->string);
	}

	assert(n->next->type == ROFFT_BODY);
	if (n->next->child != NULL)
		n = n->next;

	print_man_nodelist(man, n->child, h);

	return 0;
}
@


1.95
log
@Trailing \c suppresses the output line break even if
the next line is a text line starting with whitespace.
Quirk found in the sysutils/rancid port.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.94 2017/05/05 15:16:25 schwarze Exp $ */
a358 1

d361 1
a361 4
	if (a2roffsu(n->string, su, SCALE_EN))
		return 1;

	return 0;
@


1.94
log
@Move .sp to the roff modules.  Enough infrastructure is in place
now that this actually saves code: -70 LOC.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.93 2017/05/05 13:17:04 schwarze Exp $ */
d252 2
a253 1
		    n->flags & NODE_LINE && *n->string == ' ')
@


1.93
log
@move .ll to the roff modules
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.92 2017/05/05 02:06:17 schwarze Exp $ */
a69 1
static	int		  man_sp_pre(MAN_ARGS);
a91 1
	{ man_sp_pre, NULL }, /* sp */
d303 1
a410 19
}


static int
man_sp_pre(MAN_ARGS)
{
	struct roffsu	 su;

	SCALE_VS_INIT(&su, 1);
	if (NULL != (n = n->child))
		if ( ! a2roffsu(n->string, &su, SCALE_VS))
			su.scale = 1.0;

	print_otag(h, TAG_DIV, "suh", &su);

	/* So the div isn't empty: */
	print_text(h, "\\~");

	return 0;
@


1.92
log
@Move handling of the roff(7) .ft request from the man(7)
modules to the new roff(7) modules.  As a side effect,
mdoc(7) now handles .ft, too.  Of course, do not use that.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.91 2017/05/04 22:07:44 schwarze Exp $ */
a107 1
	{ man_ign_pre, NULL }, /* ll */
@


1.91
log
@Start roff formatter modules for HTML and termininal output,
used by both the mdoc and man formatters, with the ultimate
goal of reducing code duplication between the two macro formatters.
Made possible by the parser unification.
Add the first formatting function (for the .br request).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.90 2017/05/04 17:48:24 schwarze Exp $ */
a102 1
	{ man_ign_pre, NULL }, /* ft */
@


1.90
log
@Parser reorg:
Generate the first node on the roff level: .br
Fix some column numbers in diagnostic messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.89 2017/04/24 23:06:09 schwarze Exp $ */
a65 1
static	int		  man_br_pre(MAN_ARGS);
d70 1
d93 1
a93 1
	{ man_br_pre, NULL }, /* sp */
d306 1
a306 7
			switch(n->tok) {
			case ROFF_br:
				man_br_pre(man, n, h);
				break;
			default:
				abort();
			}
d418 1
a418 1
man_br_pre(MAN_ARGS)
d423 3
a425 7

	if (MAN_sp == n->tok) {
		if (NULL != (n = n->child))
			if ( ! a2roffsu(n->string, &su, SCALE_VS))
				su.scale = 1.0;
	} else
		su.scale = 0.0;
@


1.89
log
@Continue parser unification:
* Make enum rofft an internal interface as enum roff_tok in "roff.h".
* Represent mdoc and man macros in enum roff_tok.
* Make TOKEN_NONE a proper enum value and use it throughout.
* Put the prologue macros first in the macro tables.
* Unify mdoc_macroname[] and man_macroname[] into roff_name[].
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.88 2017/03/17 12:06:02 schwarze Exp $ */
a92 1
	{ man_br_pre, NULL }, /* br */
d305 12
@


1.88
log
@Fix regression in mdoc_html.c 1.150, man_html 1.87:
For .Sh, .Ss, .SH, .SS, only write selflink if an id could be constructed.
Crash reported by Raf Czlonka <rczlonka at gmail dot com>,
analysis of root cause by natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.87 2017/03/15 11:29:50 schwarze Exp $ */
d72 1
a72 2
static	const struct htmlman mans[MAN_MAX] = {
	{ man_br_pre, NULL }, /* br */
d93 1
d112 1
@


1.87
log
@Minimal support for deep linking into man(7) pages.
As the man(7) language does not provide semantic markup,
only .SH, .SS, and .UR become anchors for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.86 2017/02/05 18:13:28 schwarze Exp $ */
d441 2
a442 1
		print_otag(h, TAG_A, "chR", "selflink", id);
d511 2
a512 1
		print_otag(h, TAG_A, "chR", "selflink", id);
@


1.86
log
@Improve <table> syntax:
The <col> element can only appear inside <colgroup>, so use <colgroup>.
The <tbody> element is optional and useless, so don't use it.
Even if we would ever need <thead> or <tfoot>, <tbody> would still be
optional and useless; besides, we will likely never need <thead> or <tfoot>,
simply because our languages don't support such functionality.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.85 2017/01/30 20:23:07 schwarze Exp $ */
d436 8
a443 2
	if (n->type == ROFFT_HEAD)
		print_otag(h, TAG_H1, "c", "Sh");
d505 8
a512 2
	if (n->type == ROFFT_HEAD)
		print_otag(h, TAG_H2, "c", "Ss");
d669 1
a669 1
		print_otag(h, TAG_A, "ch", "Lk", n->child->string);
@


1.85
log
@Rework fill mode handling for -man -Thtml.

Basically, open <pre> whenever printing text in no-fill mode and it is
not already open, and close it whenever printing something that cannot
be inside <pre>.

This fixes a crash reported by Michael <Stapelberg at debian dot org>
in the French Linux chroot(2) manual and also improves rendering
for OpenBSD pages like DPMSGetTimeouts(3) and GLwDrawingArea(3).

These changes also permitted retiring struct mhtml.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.84 2017/01/29 14:02:19 schwarze Exp $ */
a374 1
	print_otag(h, TAG_TBODY, "");
@


1.84
log
@eliminate one useless struct and one level of indirection;
no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.83 2017/01/26 18:28:04 schwarze Exp $ */
a38 1
			  struct mhtml *mh, \
a40 4
struct	mhtml {
	struct tag	 *nofill;
};

d51 1
a66 1
static	int		  man_fill_pre(MAN_ARGS);
d95 2
a96 2
	{ man_fill_pre, NULL }, /* nf */
	{ man_fill_pre, NULL }, /* fi */
d106 2
a107 2
	{ man_fill_pre, NULL }, /* EX */
	{ man_fill_pre, NULL }, /* EE */
a139 1
	struct mhtml	 mh;
a142 1
	mh.nofill = NULL;
d149 1
a149 1
		print_man_head(&man->meta, man->first, &mh, h);
d154 1
a154 1
	man_root_pre(&man->meta, man->first, &mh, h);
d156 1
a156 1
	print_man_nodelist(&man->meta, man->first->child, &mh, h);
d158 1
a158 1
	man_root_post(&man->meta, man->first, &mh, h);
d179 1
a179 1
		print_man_node(man, n, mh, h);
d187 4
a191 1
	struct tag	*t;
d193 21
a213 4
	child = 1;
	t = h->tag;
	if (t == mh->nofill)
		t = t->next;
d216 37
d254 2
a255 5
		if ('\0' == *n->string) {
			print_paragraph(h);
			return;
		}
		if (mh->nofill == NULL &&
d258 14
d275 1
d301 1
a301 1
		if (h->tblt) {
d303 2
a304 2
			t = h->tag;
		}
d306 6
a311 1
			child = (*mans[n->tok].pre)(man, n, mh, h);
d316 1
a316 1
		print_man_nodelist(man, n->child, mh, h);
d319 17
a335 1
	print_stagq(h, mh->nofill == NULL ? t : mh->nofill);
d337 5
a341 3
	if (n->type != ROFFT_TEXT && n->type != ROFFT_EQN &&
	    mans[n->tok].post != NULL)
		(*mans[n->tok].post)(man, n, mh, h);
d343 7
a349 3
	if (mh->nofill != NULL &&
	    (n->next == NULL || n->next->flags & NODE_LINE))
		print_endline(h);
d437 1
a437 4
	if (n->type == ROFFT_BLOCK && mh->nofill != NULL) {
		print_tagq(h, mh->nofill);
		mh->nofill = NULL;
	} else if (n->type == ROFFT_HEAD)
d500 1
a500 4
	if (n->type == ROFFT_BLOCK && mh->nofill != NULL) {
		print_tagq(h, mh->nofill);
		mh->nofill = NULL;
	} else if (n->type == ROFFT_HEAD)
d537 1
a537 1
		print_man_node(man, n->child, mh, h);
d546 1
a546 1
			print_man_node(man, nn, mh, h);
a619 18
man_fill_pre(MAN_ARGS)
{
	if (MAN_fi == n->tok || MAN_EE == n->tok) {
		if (mh->nofill != NULL) {
			print_tagq(h, mh->nofill);
			mh->nofill = NULL;
		} else
			print_otag(h, TAG_BR, "");
	} else {
		if (mh->nofill == NULL)
			mh->nofill = print_otag(h, TAG_PRE, "");
		else
			print_otag(h, TAG_BR, "");
	}
	return 0;
}

static int
d665 1
a665 1
	print_man_nodelist(man, n->child, mh, h);
@


1.83
log
@Fix -man -Thtml formatting after .nf (which has nothing to do
with "literal", by the way, it means "no fill"):

* Use <pre> such that whitespace is preserved.
* Preserve lines breaks.
* For font alternating macros, avoid node recursion which required
scary juggling with the fill state.  Instead, simply print the text
children directly.

Missing feature first noticed by kristaps@@ in 2011,
the again reported by afresh1@@ in 2016,
and finally reported here: https://github.com/Debian/debiman/issues/21 ,
which i only found because of Shane Kerr's comment here:
https://plus.google.com/110314300533310775053/posts/H1eaw9Yskoc
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.82 2017/01/21 01:20:29 schwarze Exp $ */
d198 1
a198 1
	t = h->tags.head;
d241 1
a241 1
			t = h->tags.head;
@


1.82
log
@clean up the remaining class attributes
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.81 2017/01/20 23:50:59 schwarze Exp $ */
a32 1
/* TODO: preserve ident widths. */
d43 1
a43 2
	int		  fl;
#define	MANH_LITERAL	 (1 << 0) /* literal context */
d71 1
a73 1
static	int		  man_literal_pre(MAN_ARGS);
d100 2
a101 2
	{ man_literal_pre, NULL }, /* nf */
	{ man_literal_pre, NULL }, /* fi */
d111 2
a112 2
	{ man_literal_pre, NULL }, /* EX */
	{ man_literal_pre, NULL }, /* EE */
d149 1
a149 1
	memset(&mh, 0, sizeof(mh));
d199 2
d208 2
a209 3
		if (n->flags & NODE_LINE && (*n->string == ' ' ||
		    (n->prev != NULL && mh->fl & MANH_LITERAL &&
		     ! (h->flags & HTML_NONEWLINE))))
d212 1
a212 1
		return;
d252 1
a252 1
	print_stagq(h, t);
d254 7
a260 8
	switch (n->type) {
	case ROFFT_EQN:
		break;
	default:
		if (mans[n->tok].post)
			(*mans[n->tok].post)(man, n, mh, h);
		break;
	}
d348 5
a352 7
	if (n->type == ROFFT_BLOCK) {
		mh->fl &= ~MANH_LITERAL;
		return 1;
	} else if (n->type == ROFFT_BODY)
		return 1;

	print_otag(h, TAG_H1, "c", "Sh");
d360 1
a360 1
	int		 i, savelit;
a363 5
	if ((savelit = mh->fl & MANH_LITERAL))
		print_otag(h, TAG_BR, "");

	mh->fl &= ~MANH_LITERAL;

a364 1
		t = NULL;
d391 1
a391 1
		if (TAG_MAX != fp)
d394 1
a394 1
		print_man_node(man, nn, mh, h);
d396 1
a396 1
		if (t)
a398 4

	if (savelit)
		mh->fl |= MANH_LITERAL;

d414 5
a418 7
	if (n->type == ROFFT_BLOCK) {
		mh->fl &= ~MANH_LITERAL;
		return 1;
	} else if (n->type == ROFFT_BODY)
		return 1;

	print_otag(h, TAG_H2, "c", "Ss");
d537 1
a537 1
man_literal_pre(MAN_ARGS)
a538 1

d540 11
a550 5
		print_otag(h, TAG_BR, "");
		mh->fl &= ~MANH_LITERAL;
	} else
		mh->fl |= MANH_LITERAL;

@


1.81
log
@Standardize class attributes for semantic macros.
Correct markup for .Va and iprove markup for .Dv, .Er, .Ev while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.80 2017/01/19 15:27:26 schwarze Exp $ */
d456 1
a456 1
		print_otag(h, TAG_DD, "");
d459 1
a459 1
		print_otag(h, TAG_DL, "");
d465 1
a465 1
	print_otag(h, TAG_DT, "");
@


1.80
log
@Clean up CSS rules for sections and paragraphs.
Start using real macro names for CSS classes.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.79 2017/01/19 13:34:59 schwarze Exp $ */
d518 1
a518 1
	tt = print_otag(h, TAG_SPAN, "c", "opt");
d604 1
a604 1
		print_otag(h, TAG_A, "ch", "link-ext", n->child->string);
@


1.79
log
@Start cleanup: trim useless HTML comments and <div> elements
on the <html> and <body> levels.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.78 2017/01/19 01:00:11 schwarze Exp $ */
d163 5
a167 1
	print_man_nodelist(&man->meta, man->first, &mh, h);
a202 3
	case ROFFT_ROOT:
		man_root_pre(man, n, mh, h);
		break;
a255 3
	case ROFFT_ROOT:
		man_root_post(man, n, mh, h);
		break;
a351 1
		print_otag(h, TAG_DIV, "c", "section");
d356 1
a356 1
	print_otag(h, TAG_H1, "");
a429 1
		print_otag(h, TAG_DIV, "c", "subsection");
d434 1
a434 1
	print_otag(h, TAG_H2, "");
d507 1
a507 1
	print_otag(h, TAG_DIV, "csului", "spacer", &sum, &sui);
@


1.78
log
@Implement line breaking of the generated HTML code at space characters
in filled text.  This does not affect HTML semantics, but makes the
HTML code even more humanly readable.

While here,
- collapse multiple consecutive space characters in filled text
- and insert a blank between style entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.77 2017/01/18 19:22:18 schwarze Exp $ */
d149 1
a149 1
	struct tag	*t, *tt;
d154 1
a154 1
	if ( ! (HTML_FRAGMENT & h->oflags)) {
d156 2
a157 2
		t = print_otag(h, TAG_HTML, "");
		tt = print_otag(h, TAG_HEAD, "");
d159 1
a159 1
		print_tagq(h, tt);
d161 1
a161 3
		print_otag(h, TAG_DIV, "c", "mandoc");
	} else
		t = print_otag(h, TAG_DIV, "c", "mandoc");
d164 1
a164 1
	print_tagq(h, t);
@


1.77
log
@Make HTML output more human readable by overhauling line break logic
around tags and by introducing some simple indentation.
No change of HTML semantics intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.76 2017/01/17 15:32:39 schwarze Exp $ */
a215 2
		if (n->flags & NODE_LINE)
			putchar('\n');
@


1.76
log
@Completely delete the buf field of struct html and all the buf*()
interfaces.  Such a static buffer was a bad idea in the first place,
causing unfixable truncation that was only prevented by triggering
an assertion failure.  Instead, let the small number of remaining
users allocate and free their own, temporary dynamic buffers,
or for the case of .Xr and .In, pass the original data to be
assembled in print_otag().
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.75 2017/01/17 01:47:46 schwarze Exp $ */
a166 1
	putchar('\n');
@


1.75
log
@Simplify the usage of print_otag() by making it accept a variable
number of arguments.

Delete struct htmlpair and all the PAIR_*() macros.
Delete enum htmlattr, handle that in print_otag() instead.

Minus 190 lines of code; no functional change except better ordering
of attributes (class before style) in three cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.74 2017/01/10 13:46:53 schwarze Exp $ */
d173 1
d176 1
a176 4
	assert(man->title);
	assert(man->msec);
	bufinit(h);
	bufcat_fmt(h, "%s(%s)", man->title, man->msec);
d178 2
a179 1
	print_text(h, h->buf);
@


1.74
log
@unify names of AST node flags; no change of cpp output
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.73 2016/01/08 17:48:04 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
a147 1
	struct htmlpair	 tag;
a151 1
	PAIR_CLASS_INIT(&tag, "mandoc");
d156 2
a157 2
		t = print_otag(h, TAG_HTML, 0, NULL);
		tt = print_otag(h, TAG_HEAD, 0, NULL);
d160 2
a161 2
		print_otag(h, TAG_BODY, 0, NULL);
		print_otag(h, TAG_DIV, 1, &tag);
d163 1
a163 1
		t = print_otag(h, TAG_DIV, 1, &tag);
d177 1
d179 1
a179 1
	print_otag(h, TAG_TITLE, 0, NULL);
d214 1
a214 1
			print_otag(h, TAG_BR, 0, NULL);
a287 1
	struct htmlpair	 tag;
d295 3
a297 6
	PAIR_CLASS_INIT(&tag, "head");
	t = print_otag(h, TAG_TABLE, 1, &tag);

	print_otag(h, TAG_TBODY, 0, NULL);

	tt = print_otag(h, TAG_TR, 0, NULL);
d299 1
a299 2
	PAIR_CLASS_INIT(&tag, "head-ltitle");
	print_otag(h, TAG_TD, 1, &tag);
d303 1
a303 2
	PAIR_CLASS_INIT(&tag, "head-vol");
	print_otag(h, TAG_TD, 1, &tag);
d308 1
a308 2
	PAIR_CLASS_INIT(&tag, "head-rtitle");
	print_otag(h, TAG_TD, 1, &tag);
a316 1
	struct htmlpair	 tag;
d319 2
a320 7
	PAIR_CLASS_INIT(&tag, "foot");
	t = print_otag(h, TAG_TABLE, 1, &tag);

	tt = print_otag(h, TAG_TR, 0, NULL);

	PAIR_CLASS_INIT(&tag, "foot-date");
	print_otag(h, TAG_TD, 1, &tag);
d322 1
a322 1
	assert(man->date);
d326 1
a326 3
	PAIR_CLASS_INIT(&tag, "foot-os");
	print_otag(h, TAG_TD, 1, &tag);

a336 1
	struct htmlpair	 tag;
d347 1
a347 4
	bufinit(h);
	bufcat_su(h, "height", &su);
	PAIR_STYLE_INIT(&tag, h);
	print_otag(h, TAG_DIV, 1, &tag);
a357 2
	struct htmlpair	 tag;

d360 1
a360 2
		PAIR_CLASS_INIT(&tag, "section");
		print_otag(h, TAG_DIV, 1, &tag);
d365 1
a365 1
	print_otag(h, TAG_H1, 0, NULL);
d378 1
a378 1
		print_otag(h, TAG_BR, 0, NULL);
d411 1
a411 1
			t = print_otag(h, fp, 0, NULL);
d428 1
a428 2

	print_otag(h, TAG_SMALL, 0, NULL);
d430 1
a430 1
		print_otag(h, TAG_B, 0, NULL);
a436 2
	struct htmlpair	 tag;

d439 1
a439 2
		PAIR_CLASS_INIT(&tag, "subsection");
		print_otag(h, TAG_DIV, 1, &tag);
d444 1
a444 1
	print_otag(h, TAG_H2, 0, NULL);
d466 1
a466 1
		print_otag(h, TAG_DD, 0, NULL);
d469 1
a469 1
		print_otag(h, TAG_DL, 0, NULL);
d475 1
a475 1
	print_otag(h, TAG_DT, 0, NULL);
d500 1
a500 2
	struct htmlpair	 tag[2];
	struct roffsu	 su;
d510 2
a511 2
	if (NULL == np || ! a2width(np, &su))
		SCALE_HS_INIT(&su, INDENT);
d513 2
a514 1
	bufinit(h);
d517 1
a517 6
	bufcat_su(h, "margin-left", &su);
	su.scale = -su.scale;
	bufcat_su(h, "text-indent", &su);
	PAIR_STYLE_INIT(&tag[0], h);
	PAIR_CLASS_INIT(&tag[1], "spacer");
	print_otag(h, TAG_DIV, 2, tag);
a524 1
	struct htmlpair	 tag;
d528 1
a528 2
	PAIR_CLASS_INIT(&tag, "opt");
	tt = print_otag(h, TAG_SPAN, 1, &tag);
d531 1
a531 1
		print_otag(h, TAG_B, 0, NULL);
d538 1
a538 1
		print_otag(h, TAG_I, 0, NULL);
d551 1
a551 2

	print_otag(h, TAG_B, 0, NULL);
d558 1
a558 2

	print_otag(h, TAG_I, 0, NULL);
d567 1
a567 1
		print_otag(h, TAG_BR, 0, NULL);
d578 1
a578 2

	print_otag(h, TAG_BR, 0, NULL);
a591 1
	struct htmlpair	 tag;
d603 1
a603 4
	bufinit(h);
	bufcat_su(h, "margin-left", &su);
	PAIR_STYLE_INIT(&tag, h);
	print_otag(h, TAG_DIV, 1, &tag);
a609 2
	struct htmlpair		 tag[2];

d614 1
a614 3
		PAIR_CLASS_INIT(&tag[0], "link-ext");
		PAIR_HREF_INIT(&tag[1], n->child->string);
		print_otag(h, TAG_A, 2, tag);
@


1.73
log
@Delete the redundant "nchild" member of struct roff_node, replacing
most uses by one, a few by two pointer checks, and only one by a
tiny loop - not only making data smaller, but code shorter as well.

This gets rid of an implicit invariant that confused both static
analysis tools and human auditors.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.72 2015/10/06 18:30:43 schwarze Exp $ */
d212 1
a212 1
		if (n->flags & MAN_LINE && (*n->string == ' ' ||
d219 1
a219 1
		if (n->flags & MAN_LINE)
d513 1
a513 1
		while (NULL != nn && 0 == (MAN_LINE & nn->flags))
@


1.72
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.71 2015/09/26 00:53:15 schwarze Exp $ */
d655 1
a655 1
	if (n->nchild) {
d663 1
a663 1
	if (n->next->nchild)
@


1.71
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.70 2015/04/18 17:50:02 schwarze Exp $ */
d279 1
a279 1
		return(0);
d281 1
a281 1
		return(1);
d283 1
a283 1
	return(0);
d372 1
a372 1
	return(0);
d384 1
a384 1
		return(1);
d386 1
a386 1
		return(1);
d389 1
a389 1
	return(1);
d445 1
a445 1
	return(0);
d455 1
a455 1
	return(1);
d467 1
a467 1
		return(1);
d469 1
a469 1
		return(1);
d472 1
a472 1
	return(1);
d480 1
a480 1
		return(0);
d484 1
a484 1
	return(1);
d494 1
a494 1
		return(1);
d497 1
a497 1
		return(1);
d521 1
a521 1
	return(0);
d532 1
a532 1
		return(0);
d534 1
a534 1
		return(1);
d550 1
a550 1
	return(1);
d579 1
a579 1
	return(0);
d587 1
a587 1
	return(1);
d595 1
a595 1
	return(1);
d608 1
a608 1
	return(0);
d616 1
a616 1
	return(0);
d623 1
a623 1
	return(0);
d633 1
a633 1
		return(0);
d635 1
a635 1
		return(1);
d645 1
a645 1
	return(1);
d668 1
a668 1
	return(0);
@


1.70
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.69 2015/04/18 16:04:40 schwarze Exp $ */
a427 1
			/* NOTREACHED */
@


1.69
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.68 2015/04/02 23:47:43 schwarze Exp $ */
a54 1
static	void		  print_man(MAN_ARGS);
d148 2
a149 9

	memset(&mh, 0, sizeof(struct mhtml));
	print_man(man_meta(man), man_node(man), &mh, (struct html *)arg);
	putchar('\n');
}

static void
print_man(MAN_ARGS)
{
a150 1
	struct htmlpair	 tag;
d152 1
d154 1
d160 1
a160 1
		print_man_head(man, n, mh, h);
d167 1
a167 1
	print_man_nodelist(man, n, mh, h);
d169 1
@


1.68
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.67 2015/04/02 22:06:17 schwarze Exp $ */
d146 1
a146 1
html_man(void *arg, const struct man *man)
@


1.67
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.66 2015/04/02 21:03:18 schwarze Exp $ */
d38 1
a38 1
#define	MAN_ARGS	  const struct man_meta *man, \
d349 2
a350 2
	if (man->source)
		print_text(h, man->source);
@


1.66
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.65 2015/03/03 21:09:25 schwarze Exp $ */
d39 1
a39 1
			  const struct man_node *n, \
d54 1
a54 1
				const struct man_node *);
d59 1
a59 1
static	int		  a2width(const struct man_node *,
d131 1
a131 1
print_bvspace(struct html *h, const struct man_node *n)
d281 1
a281 1
a2width(const struct man_node *n, struct roffsu *su)
d401 1
a401 1
	const struct man_node	*nn;
d497 1
a497 1
	const struct man_node	*nn;
d536 1
a536 1
	const struct man_node *np;
@


1.65
log
@If an eqn(7) starts on a new input line, be sure to output whitespace
in front of it.  Issue found by tedu@@ in glOrtho(3).

There are also cases of excessive whitespace before and after
equations.  This patch neither fixes them nor makes them worse.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.64 2015/02/10 08:05:07 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d27 1
d135 1
a135 1
		if (MAN_TBL == n->body->child->type)
d138 1
a138 1
	if (MAN_ROOT == n->parent->type || MAN_RS != n->parent->tok)
d210 1
a210 1
	case MAN_ROOT:
d213 1
a213 1
	case MAN_TEXT:
d224 1
a224 1
	case MAN_EQN:
d229 1
a229 1
	case MAN_TBL:
d268 1
a268 1
	case MAN_ROOT:
d271 1
a271 1
	case MAN_EQN:
d284 1
a284 1
	if (MAN_TEXT != n->type)
d386 1
a386 1
	if (MAN_BLOCK == n->type) {
d391 1
a391 1
	} else if (MAN_BODY == n->type)
d470 1
a470 1
	if (MAN_BLOCK == n->type) {
d475 1
a475 1
	} else if (MAN_BODY == n->type)
d486 1
a486 1
	if (MAN_HEAD == n->type)
d488 1
a488 1
	else if (MAN_BLOCK == n->type)
d499 1
a499 1
	if (MAN_BODY == n->type) {
d502 1
a502 1
	} else if (MAN_HEAD != n->type) {
d538 1
a538 1
	if (MAN_HEAD == n->type)
d540 1
a540 1
	else if (MAN_BLOCK != n->type)
d639 1
a639 1
	if (MAN_HEAD == n->type)
d641 1
a641 1
	else if (MAN_BODY == n->type)
d661 1
a661 1
	assert(MAN_HEAD == n->type);
d663 1
a663 1
		assert(MAN_TEXT == n->child->type);
d669 1
a669 1
	assert(MAN_BODY == n->next->type);
@


1.64
log
@trim trailing white space, no code change;
from Svyatoslav Mishyn <juef at openmailboxd dot org>, Crux Linux
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.63 2015/01/30 22:04:15 schwarze Exp $ */
d224 2
@


1.63
log
@Have pity on the poor stack.
Replace tail recursion by iteration when walking the syntax trees.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.62 2015/01/24 02:41:32 schwarze Exp $ */
d217 1
a217 1
		if (n->flags & MAN_LINE && (*n->string == ' ' || 
@


1.62
log
@Strangely, ignoring the roff(7) .na request was implemented in the man(7)
parser.  Simplify the code by moving it into the roff(7) parser, also
making it work for mdoc(7).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.61 2014/12/23 09:31:17 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d193 4
a196 3
	print_man_node(man, n, mh, h);
	if (n->next)
		print_man_nodelist(man, n->next, mh, h);
@


1.61
log
@some scaling unit fixes:
- .sp with an invalid argument is .sp 1v, not .sp 0v
- in man(1), trailing garbage doesn't make scaling units invalid
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.60 2014/12/04 02:05:16 schwarze Exp $ */
a100 1
	{ man_ign_pre, NULL }, /* na */
@


1.60
log
@fix handling of roff requests having a default scale other than "n",
in particular .sp which uses "v", when the scale is not specified;
cures groff-mandoc differences in about a dozen Xenocara manuals
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.59 2014/12/02 10:07:17 schwarze Exp $ */
d363 1
a363 1
				SCALE_VS_INIT(&su, atoi(n->string));
@


1.59
log
@Fix the implementation and documentation of \c (continue text input line).
In particular, make it work in no-fill mode, too.
Reminded by Carsten dot Kunze at arcor dot de (Heirloom roff).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.58 2014/12/01 08:05:02 schwarze Exp $ */
d283 1
a283 1
	if (a2roffsu(n->string, su, SCALE_BU))
@


1.58
log
@header cleanup:
* add missing forward declarations
* remove needless header inclusions
* some style unification
@
text
@d1 1
a1 1
/*	$OpenBSD: man_html.c,v 1.57 2014/11/28 19:25:03 schwarze Exp $ */
a212 5
		/*
		 * If we have a blank line, output a vertical space.
		 * If we have a space as the first character, break
		 * before printing the line's data.
		 */
d217 3
a219 4

		if (' ' == *n->string && MAN_LINE & n->flags)
			print_otag(h, TAG_BR, 0, NULL);
		else if (MANH_LITERAL & mh->fl && n->prev)
a220 1

@


1.57
log
@Add some missing OpenBSD RCS markers
and a few missing <sys/types.h> inclusions; no code change.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a25 1
#include "mandoc.h"
d27 1
a29 1
#include "man.h"
@


1.56
log
@Switch HTML output to polyglot HTML5; have only one single -Thml mode.
Replace hard-coded widths and alignments with a minimal embedded stylesheet.
Do not use <p> because it cannot appear inside block macros.
Remove the "summary" attribute because it is not HTML5.

Written by kristaps@@ some months ago, finished during EuroBSDCon.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.55 2014/08/08 16:00:23 schwarze Exp $ */
@


1.55
log
@Clarity with respect to floating point handling:
Write double constants as double rather than integer literals.
Remove useless explicit (double) cast done at one place and nowhere else.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.54 2014/04/23 16:07:06 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008-2012 Kristaps Dzonsons <kristaps@@bsd.lv>
d143 1
a143 1
	print_otag(h, TAG_P, 0, NULL);
d220 1
a220 1
			print_otag(h, TAG_P, 0, NULL);
d300 1
a300 1
	struct htmlpair	 tag[3];
d308 2
a309 8
	PAIR_SUMMARY_INIT(&tag[0], "Document Header");
	PAIR_CLASS_INIT(&tag[1], "head");
	PAIR_INIT(&tag[2], ATTR_WIDTH, "100%");
	t = print_otag(h, TAG_TABLE, 3, tag);
	PAIR_INIT(&tag[0], ATTR_WIDTH, "30%");
	print_otag(h, TAG_COL, 1, tag);
	print_otag(h, TAG_COL, 1, tag);
	print_otag(h, TAG_COL, 1, tag);
d315 2
a316 2
	PAIR_CLASS_INIT(&tag[0], "head-ltitle");
	print_otag(h, TAG_TD, 1, tag);
d320 2
a321 3
	PAIR_CLASS_INIT(&tag[0], "head-vol");
	PAIR_INIT(&tag[1], ATTR_ALIGN, "center");
	print_otag(h, TAG_TD, 2, tag);
d326 2
a327 3
	PAIR_CLASS_INIT(&tag[0], "head-rtitle");
	PAIR_INIT(&tag[1], ATTR_ALIGN, "right");
	print_otag(h, TAG_TD, 2, tag);
d336 1
a336 1
	struct htmlpair	 tag[3];
d339 2
a340 7
	PAIR_SUMMARY_INIT(&tag[0], "Document Footer");
	PAIR_CLASS_INIT(&tag[1], "foot");
	PAIR_INIT(&tag[2], ATTR_WIDTH, "100%");
	t = print_otag(h, TAG_TABLE, 3, tag);
	PAIR_INIT(&tag[0], ATTR_WIDTH, "50%");
	print_otag(h, TAG_COL, 1, tag);
	print_otag(h, TAG_COL, 1, tag);
d344 2
a345 2
	PAIR_CLASS_INIT(&tag[0], "foot-date");
	print_otag(h, TAG_TD, 1, tag);
d351 2
a352 3
	PAIR_CLASS_INIT(&tag[0], "foot-os");
	PAIR_INIT(&tag[1], ATTR_ALIGN, "right");
	print_otag(h, TAG_TD, 2, tag);
d539 1
a539 1
	struct htmlpair	 tag;
d559 3
a561 2
	PAIR_STYLE_INIT(&tag, h);
	print_otag(h, TAG_P, 1, &tag);
@


1.54
log
@Audit strlcpy(3)/strlcat(3) usage.

* Repair three instances of silent truncation, use asprintf(3).
* Change two instances of strlen(3)+malloc(3)+strlcpy(3)+strlcat(3)+...
to use asprintf(3) instead to make them less error prone.
* Cast the return value of four instances where the destination
buffer is known to be large enough to (void).
* Completely remove three useless instances of strlcpy(3)/strlcat(3).
* Mark two places in -Thtml with XXX that can cause information loss
and crashes but are not easy to fix, requiring design changes of
some internal interfaces.
* The file mandocdb.c remains to be audited.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.53 2014/04/20 20:17:36 schwarze Exp $ */
d387 1
a387 1
		su.scale = 0;
@


1.53
log
@fix unchecked snprintf(3) in page header printing:
the length of the title is unknown, and speed doesn't matter here,
so use asprintf/free rather than a static buffer
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.52 2014/04/20 16:44:44 schwarze Exp $ */
a299 1
	char		 b[BUFSIZ];
a303 4
	b[0] = 0;
	if (man->vol)
		(void)strlcat(b, man->vol, BUFSIZ);

d329 2
a330 1
	print_text(h, b);
@


1.52
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.51 2014/03/30 19:47:32 schwarze Exp $ */
d27 1
d300 1
d303 1
a303 1
	char		 b[BUFSIZ], title[BUFSIZ];
d311 1
a311 1
	snprintf(title, BUFSIZ - 1, "%s(%s)", man->title, man->msec);
d342 1
@


1.51
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.50 2014/03/08 15:50:21 schwarze Exp $ */
d52 1
a52 1
static	void		  print_bvspace(struct html *, 
d89 1
a89 1
	{ man_HP_pre, NULL }, /* HP */ 
d121 1
d156 1
a156 1
print_man(MAN_ARGS) 
d171 1
a171 1
	} else 
a177 2

/* ARGSUSED */
a189 1

a198 1

d209 1
a209 1
	case (MAN_ROOT):
d212 1
a212 1
	case (MAN_TEXT):
d230 1
a230 1
	case (MAN_EQN):
d233 1
a233 1
	case (MAN_TBL):
d242 1
a242 1
		/* 
d272 1
a272 1
	case (MAN_ROOT):
d275 1
a275 1
	case (MAN_EQN):
a283 1

a295 2

/* ARGSUSED */
a341 2

/* ARGSUSED */
a374 1
/* ARGSUSED */
a400 1
/* ARGSUSED */
a417 1
/* ARGSUSED */
d426 1
a426 1
	if ((savelit = mh->fl & MANH_LITERAL)) 
d434 1
a434 1
		case (MAN_BI):
d437 1
a437 1
		case (MAN_IB):
d440 1
a440 1
		case (MAN_RI):
d443 1
a443 1
		case (MAN_IR):
d446 1
a446 1
		case (MAN_BR):
d449 1
a449 1
		case (MAN_RB):
a474 1
/* ARGSUSED */
d478 1
a478 1
	
a484 1
/* ARGSUSED */
a501 1
/* ARGSUSED */
a513 1
/* ARGSUSED */
d519 1
a519 1
	if (MAN_BODY == n->type) { 
a550 1
/* ARGSUSED */
a578 1
/* ARGSUSED */
a607 2

/* ARGSUSED */
a615 1
/* ARGSUSED */
d619 1
a619 1
	
a623 1
/* ARGSUSED */
a636 1
/* ARGSUSED */
a644 1
/* ARGSUSED */
a651 1
/* ARGSUSED */
a673 1
/* ARGSUSED */
@


1.50
log
@To find out whether .TP head arguments are same-line or next-line arguments,
use the MAN_LINE flag instead of the man_node line member.
This is required such that user-defined macros wrapping .TP work correctly.

Issue found by Havard Eidnes in Tcl_NewStringObj(3), reported via
the NetBSD bug tracking system and Thomas Klausner <wiz at NetBSD>.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.49 2013/10/17 20:51:29 schwarze Exp $ */
d118 1
@


1.49
log
@Implement the .UR/.UE block (uniform resource identifier) introduced in the
man-ext macros by Eric S. Raymond, enabled by default in groff_man(7).
Usual disclaimer: You don't write new man(7) code, so you are not going
to use these, either.
Improves e.g. the bzr(1) and etherape(1) manuals.
Thanks to naddy@@ for bringing these to my attention.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.48 2012/11/17 00:25:20 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013 Ingo Schwarze <schwarze@@openbsd.org>
d552 9
a560 4
	if (MAN_TP == n->tok)
		for (nn = n->child; nn; nn = nn->next)
			if (nn->line > n->line)
				print_man_node(man, nn, mh, h);
@


1.48
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.47 2012/06/02 20:07:09 schwarze Exp $ */
d3 2
a4 1
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
d70 1
d116 2
d690 24
@


1.47
log
@Minimal implementation of .EX and .EE for GNU compatibility.
Do not use this, it is not portable and only defined in esr's man-ext.
For example, sox(1) wants these macros.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.46 2012/02/26 19:41:27 schwarze Exp $ */
d36 1
a36 1
#define	MAN_ARGS	  const struct man_meta *m, \
d140 1
a140 1
html_man(void *arg, const struct man *m)
d145 1
a145 1
	print_man(man_meta(m), man_node(m), &mh, (struct html *)arg);
d161 1
a161 1
		print_man_head(m, n, mh, h);
d168 1
a168 1
	print_man_nodelist(m, n, mh, h);
d179 3
a181 3
	assert(m->title);
	assert(m->msec);
	bufcat_fmt(h, "%s(%s)", m->title, m->msec);
d191 1
a191 1
	print_man_node(m, n, mh, h);
d193 1
a193 1
		print_man_nodelist(m, n->next, mh, h);
d208 1
a208 1
		man_root_pre(m, n, mh, h);
d259 1
a259 1
			child = (*mans[n->tok].pre)(m, n, mh, h);
d264 1
a264 1
		print_man_nodelist(m, n->child, mh, h);
d271 1
a271 1
		man_root_post(m, n, mh, h);
d277 1
a277 1
			(*mans[n->tok].post)(m, n, mh, h);
d305 2
a306 2
	if (m->vol)
		(void)strlcat(b, m->vol, BUFSIZ);
d308 3
a310 3
	assert(m->title);
	assert(m->msec);
	snprintf(title, BUFSIZ - 1, "%s(%s)", m->title, m->msec);
d364 2
a365 2
	assert(m->date);
	print_text(h, m->date);
d372 2
a373 2
	if (m->source)
		print_text(h, m->source);
d469 1
a469 1
		print_man_node(m, nn, mh, h);
d544 1
a544 1
		print_man_node(m, n->child, mh, h);
d551 1
a551 1
				print_man_node(m, nn, mh, h);
@


1.46
log
@Support .OP, one of the extended man macros; from kristaps@@.
Do not use this GNU extension, we take it for compatibility only.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.45 2011/12/04 00:44:18 schwarze Exp $ */
d112 2
d639 1
a639 1
	if (MAN_nf != n->tok) {
@


1.45
log
@When a man document contains nothing at all except one or more invalid
macros, do not die on an assertion, but show correct error messages.
Assertions of meta data validity suggested by joerg@@.
ok joerg@@
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.44 2011/10/09 22:10:51 schwarze Exp $ */
a56 1

a58 8

static	int		  man_alt_pre(MAN_ARGS);
static	int		  man_br_pre(MAN_ARGS);
static	int		  man_ign_pre(MAN_ARGS);
static	int		  man_in_pre(MAN_ARGS);
static	int		  man_literal_pre(MAN_ARGS);
static	void		  man_root_post(MAN_ARGS);
static	void		  man_root_pre(MAN_ARGS);
d61 1
d63 1
a63 1
static	int		  man_IP_pre(MAN_ARGS);
d69 7
d111 1
d582 31
@


1.44
log
@Always print <table> column widths in -T[x]html;
if desired, they can be overridden in the CSS file.
Suggested by kristaps@@, and i always like to simplify code.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.43 2011/10/09 17:59:56 schwarze Exp $ */
d177 2
d306 2
d362 1
@


1.43
log
@Sync to version 1.12.0; all code by kristaps@@:
Implement .Rv in -Tman.
Let -man -Tman work a bit like cat(1).
Add the -Ofragment option to -T[x]html.
Minor fixes in -T[x]html.
Lots of apropos(1) and -Tman code cleanup.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.42 2011/09/18 15:54:48 schwarze Exp $ */
d308 6
a313 9
	if (NULL == h->style) {
		PAIR_INIT(&tag[2], ATTR_WIDTH, "100%");
		t = print_otag(h, TAG_TABLE, 3, tag);
		PAIR_INIT(&tag[0], ATTR_WIDTH, "30%");
		print_otag(h, TAG_COL, 1, tag);
		print_otag(h, TAG_COL, 1, tag);
		print_otag(h, TAG_COL, 1, tag);
	} else
		t = print_otag(h, TAG_TABLE, 2, tag);
a320 1

d325 2
a326 6
	if (NULL == h->style) {
		PAIR_INIT(&tag[1], ATTR_ALIGN, "center");
		print_otag(h, TAG_TD, 2, tag);
	} else 
		print_otag(h, TAG_TD, 1, tag);

d331 2
a332 6
	if (NULL == h->style) {
		PAIR_INIT(&tag[1], ATTR_ALIGN, "right");
		print_otag(h, TAG_TD, 2, tag);
	} else 
		print_otag(h, TAG_TD, 1, tag);

d347 5
a351 8
	if (NULL == h->style) {
		PAIR_INIT(&tag[2], ATTR_WIDTH, "100%");
		t = print_otag(h, TAG_TABLE, 3, tag);
		PAIR_INIT(&tag[0], ATTR_WIDTH, "50%");
		print_otag(h, TAG_COL, 1, tag);
		print_otag(h, TAG_COL, 1, tag);
	} else
		t = print_otag(h, TAG_TABLE, 2, tag);
d362 2
a363 5
	if (NULL == h->style) {
		PAIR_INIT(&tag[1], ATTR_ALIGN, "right");
		print_otag(h, TAG_TD, 2, tag);
	} else 
		print_otag(h, TAG_TD, 1, tag);
@


1.42
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.41 2011/09/18 10:25:28 schwarze Exp $ */
a139 2
	struct html	*h;
	struct tag	*t;
a141 4
	h = (struct html *)arg;

	print_gen_decls(h);

d143 2
a144 6

	t = print_otag(h, TAG_HTML, 0, NULL);
	print_man(man_meta(m), man_node(m), &mh, h);
	print_tagq(h, t);

	printf("\n");
d150 4
a153 1
	struct tag	*t;
d155 10
a164 3
	t = print_otag(h, TAG_HEAD, 0, NULL);
	print_man_head(m, n, mh, h);
	print_tagq(h, t);
a165 1
	t = print_otag(h, TAG_BODY, 0, NULL);
@


1.41
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.40 2011/07/08 17:47:54 schwarze Exp $ */
a34 1
#define	HALFINDENT	  3
@


1.40
log
@clean up .HP, .IP, .TP, .nf, and \c handling in -T[x]html;
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.39 2011/07/05 04:12:41 schwarze Exp $ */
a199 1
	struct htmlpair	 tag;
d227 1
a227 3
		PAIR_CLASS_INIT(&tag, "eqn");
		print_otag(h, TAG_SPAN, 1, &tag);
		print_text(h, n->eqn->data);
@


1.39
log
@Sync to bsd.lv (all coded by kristaps@@):
 - mdoc(7): fix an assertion if the first line after .Bd -column
   starts with a blank, and some simplifications in mdoc_argv.c
 - man(7): literal mode ends at .SH and .SS (bug reported by naddy@@)
 - allow .RS/.RE blocks to nest (bug reported by dcoppa@@ and gsoares@@)
 - improve vertical spacing of man(7) blocks
 - roff(7): clear user-defined strings when starting a new file
 - correct ID tags in -T[x]html
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.38 2011/05/29 21:22:18 schwarze Exp $ */
d218 5
a222 1
		} else if (' ' == *n->string && MAN_LINE & n->flags)
a225 12

		/*
		 * If we're in a literal context, make sure that words
		 * togehter on the same line stay together.  This is a
		 * POST-printing call, so we check the NEXT word.  Since
		 * -man doesn't have nested macros, we don't need to be
		 * more specific than this.
		 */
		if (MANH_LITERAL & mh->fl &&
				(NULL == n->next ||
				 n->next->line > n->line))
			print_otag(h, TAG_BR, 0, NULL);
a393 1

a420 1

a438 1

d444 1
a444 1
	int		 i;
d448 5
d491 3
a496 1

a507 1

a525 1

a538 1

a542 2
	struct roffsu		 su;
	struct htmlpair	 	 tag;
a544 7
	/*
	 * This scattering of 1-BU margins and pads is to make sure that
	 * when text overruns its box, the subsequent text isn't flush
	 * up against it.  However, the rest of the right-hand box must
	 * also be adjusted in consideration of this 1-BU space.
	 */

d546 4
a549 1
		print_otag(h, TAG_TD, 0, NULL);
d553 1
a553 6
	nn = MAN_BLOCK == n->type ? 
		n->head->child : n->parent->head->child;

	SCALE_HS_INIT(&su, INDENT);

	/* Width is the second token. */
d555 1
a555 28
	if (MAN_IP == n->tok && NULL != nn)
		if (NULL != (nn = nn->next))
			a2width(nn, &su);

	/* Width is the first token. */

	if (MAN_TP == n->tok && NULL != nn) {
		/* Skip past non-text children. */
		while (nn && MAN_TEXT != nn->type)
			nn = nn->next;
		if (nn)
			a2width(nn, &su);
	}

	if (MAN_BLOCK == n->type) {
		print_bvspace(h, n);
		print_otag(h, TAG_TABLE, 0, NULL);
		bufinit(h);
		bufcat_su(h, "width", &su);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_COL, 1, &tag);
		print_otag(h, TAG_COL, 0, NULL);
		print_otag(h, TAG_TBODY, 0, NULL);
		print_otag(h, TAG_TR, 0, NULL);
		return(1);
	} 

	print_otag(h, TAG_TD, 0, NULL);
a571 1

d580 4
a583 1
	bufinit(h);
d585 1
a585 3
	np = MAN_BLOCK == n->type ? 
		n->head->child : 
		n->parent->head->child;
d590 1
a590 14
	if (MAN_HEAD == n->type) {
		print_otag(h, TAG_TD, 0, NULL);
		return(0);
	} else if (MAN_BLOCK == n->type) {
		print_bvspace(h, n);
		print_otag(h, TAG_TABLE, 0, NULL);
		bufcat_su(h, "width", &su);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_COL, 1, &tag);
		print_otag(h, TAG_COL, 0, NULL);
		print_otag(h, TAG_TBODY, 0, NULL);
		print_otag(h, TAG_TR, 0, NULL);
		return(1);
	}
d592 2
d597 1
a597 1
	print_otag(h, TAG_TD, 1, &tag);
a600 1

a609 1

a618 1

d624 1
a624 1
	if (MAN_nf == n->tok) {
d626 2
a628 2
	} else
		mh->fl &= ~MANH_LITERAL;
a632 1

a641 1

a648 1

@


1.38
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.37 2011/04/21 22:59:54 schwarze Exp $ */
d52 2
d115 22
a157 1

d413 3
a415 2
		if (n->child)
			a2roffsu(n->child->string, &su, SCALE_VS);
d438 1
d520 1
d539 2
a540 2
	else if (MAN_BODY == n->type && n->prev)
		print_otag(h, TAG_P, 0, NULL);
d588 1
a588 1
		print_otag(h, TAG_P, 0, NULL);
d639 1
a639 1
		print_otag(h, TAG_P, 0, NULL);
@


1.37
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.36 2011/03/20 23:36:42 schwarze Exp $ */
d66 1
a66 1
static	int		  man_root_pre(MAN_ARGS);
d156 1
a156 3
	bufinit(h);
	buffmt(h, "%s(%s)", m->title, m->msec);

a181 2
	bufinit(h);

d184 1
a184 1
		child = man_root_pre(m, n, mh, h);
d187 5
d200 7
a254 2
	bufinit(h);

d283 1
a283 1
static int
a336 1
	return(1);
d395 1
d564 1
d600 2
d702 1
@


1.36
log
@Import the foundation for eqn(7) support.
Written by kristaps@@.

For now, i'm adding one line to each of the four frontends
to just pass the input text through to the output,
not yet interpreting any of then eqn keywords.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.35 2011/03/07 01:35:33 schwarze Exp $ */
d179 1
d205 2
d208 1
a208 1
		return;
d252 2
@


1.35
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.34 2011/01/17 00:15:19 schwarze Exp $ */
d202 3
@


1.34
log
@Refrain from throwing fatal errors for
* .br .sp .nf .fi .na with arguments - just skip the arguments
* .TH lacking arguments - use empty strings instead like groff
* .TH with excessive arguments - skip those
Reminded by Joerg Sonnenberger, ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.33 2011/01/16 19:41:16 schwarze Exp $ */
a332 6
	char		 b[DATESIZ];

	if (m->rawdate)
		strlcpy(b, m->rawdate, DATESIZ);
	else
		time2a(m->date, b, DATESIZ);
d350 1
a350 1
	print_text(h, b);
@


1.33
log
@Merge from bsd.lv, original commit message by kristaps@@:
Change how -Thtml behaves with tables: use multiple rows, with widths
set by COL, until an external macro is encountered.  At this point in
time, close out the table and process the macro.  When the first table
row is again re-encountered, re-start the table.  This requires a bit of
tracking added to "struct html", but the change is very small and
follows the logic of meta-fonts.  This all follows a bug-report by
joerg@@.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.32 2011/01/16 03:46:21 schwarze Exp $ */
d99 1
a99 1
	{ NULL, NULL }, /* na */
d652 1
a652 1
	return(1);
@


1.32
log
@In literal context, do not generate output line breaks between macro
arguments.  This fixes a long-standing bug reported repeatedly,
in particular by naddy@@ and brad@@.
Fix by kristaps@@, minus one regression caught by my test suite.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.31 2011/01/16 02:56:47 schwarze Exp $ */
d204 5
d214 1
a214 2
		 * scope.  Assert that the metafont is on the top of the
		 * stack (it's never nested).
d219 10
@


1.31
log
@If the first character of a free-form text input line is whitespace,
then it will start a new output line;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.30 2011/01/09 16:31:45 schwarze Exp $ */
a184 6
	/*
	 * FIXME: embedded elements within next-line scopes (e.g., `br'
	 * within an empty `B') will cause formatting to be forgotten
	 * due to scope closing out.
	 */

d193 1
a193 3
		}

		if (' ' == *n->string && MAN_LINE & n->flags)
d198 3
a200 1
		if (MANH_LITERAL & mh->fl)
d205 1
a205 1
		break;
a231 2
		break;
	case (MAN_TBL):
@


1.30
log
@Remove an unused variable, and use int for array indices (not size_t);
found by lint(1), fixed by kristaps@@, no functional change.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.29 2011/01/04 22:28:17 schwarze Exp $ */
d196 8
d205 1
@


1.29
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.28 2011/01/04 01:15:39 schwarze Exp $ */
a503 1
	int			 width;
a520 1
	width = 0;
d526 1
a526 1
			width = a2width(nn, &su);
d535 1
a535 1
			width = a2width(nn, &su);
@


1.28
log
@Multiple man(7) .IP and .TP fixes started during p2k10:

Affecting both -Tascii and -Thtml:
* The .IP HEAD uses the second argument as the width, not the last one.
* Only print the first .IP HEAD argument, not all but the last.

Affecting only -Tascii:
* The .IP and .TP HEADs must be printed without literal mode,
  but literal mode must be restored afterwards.
* After the .IP and .TP bodies, we only want term_newln(), not
  term_flushln(), or we would get two blank lines in literal mode.
* The .TP HEAD does not use TWOSPACE, just like .IP doesn't either.
* In literal mode, clear NOLPAD after each line, or subsequent lines
  would get no indentation whatsoever.

Affecting only -Thtml:
* Only print next-line .TP children, instead of all but the first.

OK kristaps@@ on the -Tascii part; and:
"Can you work this into man_html.c, too?"
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.27 2010/12/25 13:23:03 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
a109 2
	{ NULL, NULL }, /* TS */
	{ NULL, NULL }, /* TE */
a196 1

a198 1

d200 3
d230 1
a230 1
	case (MAN_TEXT):
@


1.27
log
@Yet another batch of -Thtml polishing from kristaps@@:
In particular, use <SMALL> for .SM and <CODE> for .Dl.
Use <B> for bold and <I> for italic in general.
Also call this mandoc 1.10.8 now, as it is functionally equivalent,
even though one one set of refactoring patches has not been merged
yet because it conflicts with our tbl(1) handling.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.26 2010/12/22 22:35:05 schwarze Exp $ */
d525 1
a525 1
	/* Width is the last token. */
d528 1
a528 3
		if (NULL != (nn = nn->next)) {
			for ( ; nn->next; nn = nn->next)
				/* Do nothing. */ ;
a529 1
		}
d555 1
a555 3
	/*
	 * Without a length string, we can print all of our children.
	 */
d557 2
a558 2
	if ( ! width)
		return(1);
d560 1
a560 6
	/*
	 * When a length has been specified, we need to carefully print
	 * our child context:  IP gets all children printed but the last
	 * (the width), while TP gets all children printed but the first
	 * (the width).
	 */
a561 3
	if (MAN_IP == n->tok)
		for (nn = n->child; nn->next; nn = nn->next)
			print_man_node(m, nn, mh, h);
d563 3
a565 2
		for (nn = n->child->next; nn; nn = nn->next)
			print_man_node(m, nn, mh, h);
@


1.26
log
@Use yet more standard HTML tags,
this time some more <P> and <TABLE> instead of <DIV>.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.25 2010/12/19 09:22:35 schwarze Exp $ */
d210 3
a212 5
		if (h->metaf) {
			assert(h->metaf == t);
			print_tagq(h, h->metaf);
			assert(NULL == h->metaf);
			t = h->tags.head;
d408 3
a410 3
	struct tag		*t;
	int			 i;
	enum htmlfont		 fp;
d413 1
d416 1
a416 1
			fp = i % 2 ? HTMLFONT_ITALIC : HTMLFONT_BOLD;
d419 1
a419 1
			fp = i % 2 ? HTMLFONT_BOLD : HTMLFONT_ITALIC;
d422 1
a422 1
			fp = i % 2 ? HTMLFONT_ITALIC : HTMLFONT_NONE;
d425 1
a425 1
			fp = i % 2 ? HTMLFONT_NONE : HTMLFONT_ITALIC;
d428 1
a428 1
			fp = i % 2 ? HTMLFONT_NONE : HTMLFONT_BOLD;
d431 1
a431 1
			fp = i % 2 ? HTMLFONT_BOLD : HTMLFONT_NONE;
d441 3
a443 6
		/* 
		 * Open and close the scope with each argument, so that
		 * internal \f escapes, which are common, are also
		 * closed out with the scope.
		 */
		t = print_ofont(h, fp);
d445 3
a447 1
		print_tagq(h, t);
a457 1
	struct htmlpair	 tag;
d459 1
a459 3
	/* FIXME: print_ofont(). */
	PAIR_CLASS_INIT(&tag, "small");
	print_otag(h, TAG_SPAN, 1, &tag);
d461 1
a461 1
		print_ofont(h, HTMLFONT_BOLD);
d626 1
a626 1
	print_ofont(h, HTMLFONT_BOLD);
d636 1
a636 1
	print_ofont(h, HTMLFONT_ITALIC);
@


1.25
log
@Significant improvements to -Thtml by kristaps@@:
Use less <DIV>, use more <H1>, <H2>, <P>, <BR>, <PRE>, <UL>, <OL>, <DL> etc.
Triggered by input from Will Backman.
Remove CSS2 note in mandoc.1, which is no longer true.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.24 2010/12/19 07:53:12 schwarze Exp $ */
a72 1
static	int		  man_SB_pre(MAN_ARGS);
d89 1
a89 1
	{ man_SB_pre, NULL }, /* SB */
d260 1
a260 1
	struct htmlpair	 tag[2];
d270 13
a282 3
	PAIR_CLASS_INIT(&tag[0], "head");
	PAIR_SUMMARY_INIT(&tag[1], "Document Header");
	t = print_otag(h, TAG_TABLE, 2, tag);
d293 5
a297 1
	print_otag(h, TAG_TD, 1, tag);
d303 5
a307 1
	print_otag(h, TAG_TD, 1, tag);
d319 1
a319 1
	struct htmlpair	 tag[2];
d328 10
a337 3
	PAIR_CLASS_INIT(&tag[0], "foot");
	PAIR_SUMMARY_INIT(&tag[1], "Document Footer");
	t = print_otag(h, TAG_TABLE, 2, tag);
d348 5
a352 1
	print_otag(h, TAG_TD, 1, tag);
d458 1
a458 1
man_SB_pre(MAN_ARGS)
a462 12
	PAIR_CLASS_INIT(&tag, "small bold");
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
man_SM_pre(MAN_ARGS)
{
	struct htmlpair	 tag;
	
d465 2
a492 3
	struct htmlpair	 tag;
	struct roffsu	 su;
	int		 i;
a493 2
	if (MAN_BODY == n->type)
		return(1);
d496 2
a497 16

	i = 0;

	if (MAN_ROOT == n->parent->type) {
		SCALE_HS_INIT(&su, INDENT);
		bufcat_su(h, "margin-left", &su);
		i = 1;
	}
	if (n->prev) {
		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "margin-top", &su);
		i = 1;
	}

	PAIR_STYLE_INIT(&tag, h);
	print_otag(h, TAG_DIV, i, &tag);
d520 1
a520 4
		SCALE_HS_INIT(&su, INDENT);
		bufcat_su(h, "margin-left", &su);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
d550 3
a552 4
		bufcat_su(h, "margin-left", &su);
		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "margin-top", &su);
		bufcat_style(h, "clear", "both");
d554 4
a557 1
		print_otag(h, TAG_DIV, 1, &tag);
d561 1
a561 12
	bufcat_su(h, "min-width", &su);
	SCALE_INVERT(&su);
	bufcat_su(h, "margin-left", &su);
	SCALE_HS_INIT(&su, 1);
	bufcat_su(h, "margin-right", &su);
	bufcat_style(h, "clear", "left");

	if (n->next && n->next->child)
		bufcat_style(h, "float", "left");

	PAIR_STYLE_INIT(&tag, h);
	print_otag(h, TAG_DIV, 1, &tag);
d592 3
a594 3
	const struct man_node	*nn;
	struct htmlpair	 	 tag;
	struct roffsu		 su;
d596 3
a598 2
	if (MAN_HEAD == n->type)
		return(0);
d600 2
a601 2
	nn = MAN_BLOCK == n->type ?
		n->head->child : n->parent->head->child;
d603 7
a609 10
	SCALE_HS_INIT(&su, INDENT);

	if (NULL != nn)
		(void)a2width(nn, &su);

	if (MAN_BLOCK == n->type) {
		bufcat_su(h, "margin-left", &su);
		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "margin-top", &su);
		bufcat_style(h, "clear", "both");
d611 4
a614 1
		print_otag(h, TAG_DIV, 1, &tag);
d618 1
a618 2
	bufcat_su(h, "margin-left", &su);
	SCALE_INVERT(&su);
a619 1

d621 1
a621 1
	print_otag(h, TAG_DIV, 1, &tag);
d693 1
a693 4
	bufcat_su(h, "margin-left", &su);

	if (n->head->child) {
		SCALE_VS_INIT(&su, 1);
a694 2
		bufcat_su(h, "margin-top", &su);
	}
d696 1
@


1.24
log
@Remove `i' and `r' macro handlers.  These macros, originally part of the
me package, aren't recognised by "groff -mandoc" so we don't need to do
so either.  Besides, they are not used in base or Xenocara, and only at
two or three places in one single port, which are probably typos.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.23 2010/12/07 00:06:24 schwarze Exp $ */
a141 1
	struct htmlpair	 tag;
a143 1

d146 1
a147 5

	tag.key = ATTR_CLASS;
	tag.val = "body";
	print_otag(h, TAG_DIV, 1, &tag);

a148 1

d261 1
a261 1
	struct htmlpair	 tag[3];
d271 3
a273 4
	PAIR_CLASS_INIT(&tag[0], "header");
	bufcat_style(h, "width", "100%");
	PAIR_STYLE_INIT(&tag[1], h);
	PAIR_SUMMARY_INIT(&tag[2], "header");
a274 1
	t = print_otag(h, TAG_TABLE, 3, tag);
d277 1
a277 3
	bufinit(h);
	bufcat_style(h, "width", "10%");
	PAIR_STYLE_INIT(&tag[0], h);
d279 1
d283 1
a283 5
	bufinit(h);
	bufcat_style(h, "width", "80%");
	bufcat_style(h, "white-space", "nowrap");
	bufcat_style(h, "text-align", "center");
	PAIR_STYLE_INIT(&tag[0], h);
d285 1
d289 1
a289 4
	bufinit(h);
	bufcat_style(h, "width", "10%");
	bufcat_style(h, "text-align", "right");
	PAIR_STYLE_INIT(&tag[0], h);
d291 1
d302 1
a302 1
	struct htmlpair	 tag[3];
d311 3
a313 4
	PAIR_CLASS_INIT(&tag[0], "footer");
	bufcat_style(h, "width", "100%");
	PAIR_STYLE_INIT(&tag[1], h);
	PAIR_SUMMARY_INIT(&tag[2], "footer");
a314 1
	t = print_otag(h, TAG_TABLE, 3, tag);
d317 1
a317 3
	bufinit(h);
	bufcat_style(h, "width", "50%");
	PAIR_STYLE_INIT(&tag[0], h);
d319 1
d323 1
a323 4
	bufinit(h);
	bufcat_style(h, "width", "50%");
	bufcat_style(h, "text-align", "right");
	PAIR_STYLE_INIT(&tag[0], h);
d325 1
d363 1
a363 2
	struct htmlpair	 tag[2];
	struct roffsu	 su;
d365 3
a367 6
	if (MAN_BODY == n->type) {
		SCALE_HS_INIT(&su, INDENT);
		bufcat_su(h, "margin-left", &su);
		PAIR_CLASS_INIT(&tag[0], "sec-body");
		PAIR_STYLE_INIT(&tag[1], h);
		print_otag(h, TAG_DIV, 2, tag);
d369 1
a369 14
	} else if (MAN_BLOCK == n->type) {
		PAIR_CLASS_INIT(&tag[0], "sec-block");
		if (n->prev && MAN_SH == n->prev->tok)
			if (NULL == n->prev->body->child) {
				print_otag(h, TAG_DIV, 1, tag);
				return(1);
			}

		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "margin-top", &su);
		if (NULL == n->next)
			bufcat_su(h, "margin-bottom", &su);
		PAIR_STYLE_INIT(&tag[1], h);
		print_otag(h, TAG_DIV, 2, tag);
a370 1
	}
d372 1
a372 2
	PAIR_CLASS_INIT(&tag[0], "sec-head");
	print_otag(h, TAG_DIV, 1, tag);
d457 1
a457 4
	struct htmlpair	 tag[3];
	struct roffsu	 su;

	SCALE_VS_INIT(&su, 1);
d459 3
a461 10
	if (MAN_BODY == n->type) {
		PAIR_CLASS_INIT(&tag[0], "ssec-body");
		if (n->parent->next && n->child) {
			bufcat_su(h, "margin-bottom", &su);
			PAIR_STYLE_INIT(&tag[1], h);
			print_otag(h, TAG_DIV, 2, tag);
			return(1);
		}

		print_otag(h, TAG_DIV, 1, tag);
d463 1
a463 11
	} else if (MAN_BLOCK == n->type) {
		PAIR_CLASS_INIT(&tag[0], "ssec-block");
		if (n->prev && MAN_SS == n->prev->tok) 
			if (n->prev->body->child) {
				bufcat_su(h, "margin-top", &su);
				PAIR_STYLE_INIT(&tag[1], h);
				print_otag(h, TAG_DIV, 2, tag);
				return(1);
			}

		print_otag(h, TAG_DIV, 1, tag);
a464 1
	}
d466 1
a466 5
	SCALE_HS_INIT(&su, INDENT - HALFINDENT);
	bufcat_su(h, "margin-left", &su);
	PAIR_CLASS_INIT(&tag[0], "ssec-head");
	PAIR_STYLE_INIT(&tag[1], h);
	print_otag(h, TAG_DIV, 2, tag);
@


1.23
log
@Back out my .ft implementation for -Thtml.
Kristaps says it is broken and cannot work,
because HTML needs a block structure which .ft does not provide.
Thus, let us just ignore .ft in HTML output.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.22 2010/12/06 22:43:54 schwarze Exp $ */
a100 1
	{ NULL, NULL }, /* i */
a103 1
	{ NULL, NULL }, /* r */
@


1.22
log
@Never print .P, .PP, and .LP header content.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.21 2010/11/29 02:26:45 schwarze Exp $ */
a3 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
a62 1
static	int		  man_ft_pre(MAN_ARGS);
d115 1
a115 1
	{ man_ft_pre, NULL }, /* ft */
a722 42
}


/* ARGSUSED */
static int
man_ft_pre(MAN_ARGS)
{
	const char	 *cp;

	if (NULL == n->child) {
		print_ofont(h, h->metal);
		return(0);
	}

	cp = n->child->string;
	switch (*cp) {
	case ('4'):
		/* FALLTHROUGH */
	case ('3'):
		/* FALLTHROUGH */
	case ('B'):
		print_ofont(h, HTMLFONT_BOLD);
		break;
	case ('2'):
		/* FALLTHROUGH */
	case ('I'):
		print_ofont(h, HTMLFONT_ITALIC);
		break;
	case ('P'):
		print_ofont(h, h->metal);
		break;
	case ('1'):
		/* FALLTHROUGH */
	case ('C'):
		/* FALLTHROUGH */
	case ('R'):
		print_ofont(h, HTMLFONT_NONE);
		break;
	default:
		break;
	}
	return(0);
@


1.21
log
@Now that we have proper .de support in the roff(7) library,
it is time to remove the .Sp, .Vb, and .Ve kludge
that was added to the man(7) library to build Perl manuals.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.20 2010/11/29 00:12:02 schwarze Exp $ */
d547 1
a547 1
	if (MAN_BLOCK != n->type)
d549 2
d567 1
@


1.20
log
@Implement the roff .ft (change font) request for man(7).
Of course, we don't want to encourage low-level physical markup,
but pod2man(1) writes such requests, so Perl manuals contain them,
and some Xenocara and lots and lots of ports manuals use them as well.
In base and Xenocara, this will reduce mandoc -Tlint ERROR noise;
in ports, it will improve rendering of many manuals.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.19 2010/10/15 20:45:03 schwarze Exp $ */
a112 3
	{ man_br_pre, NULL }, /* Sp */
	{ man_literal_pre, NULL }, /* Vb */
	{ man_literal_pre, NULL }, /* Ve */
d366 1
a366 5
	switch (n->tok) {
	case (MAN_Sp):
		SCALE_VS_INIT(&su, 0.5);
		break;
	case (MAN_sp):
d369 1
a369 2
		break;
	default:
a370 2
		break;
	}
d772 1
a772 4
	switch (n->tok) {
	case (MAN_nf):
		/* FALLTHROUGH */
	case (MAN_Vb):
d775 1
a775 2
		return(MAN_Vb != n->tok);
	default:
a776 2
		break;
	}
@


1.19
log
@Minimal glue to integrate tbl into the mandoc man(7) parser and formatter.
The output dosn't look nice yet, escape handling is still missing,
but will follow soon.
"move forward aggressively :-)" deraadt@@
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.18 2010/07/25 18:05:54 schwarze Exp $ */
d4 1
d64 1
d120 1
d732 42
@


1.18
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.17 2010/07/13 01:09:13 schwarze Exp $ */
d116 2
@


1.17
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.16 2010/06/27 21:54:42 schwarze Exp $ */
d39 1
d42 5
d63 2
d103 2
a104 2
	{ NULL, NULL }, /* nf */
	{ NULL, NULL }, /* fi */
d112 2
a113 2
	{ man_ign_pre, NULL }, /* Vb */
	{ NULL, NULL }, /* Ve */
d115 1
d124 1
d130 2
d133 1
a133 1
	print_man(man_meta(m), man_node(m), h);
d148 1
a148 1
	print_man_head(m, n, h);
d156 1
a156 1
	print_man_nodelist(m, n, h);
d180 1
a180 1
	print_man_node(m, n, h);
d182 1
a182 1
		print_man_nodelist(m, n->next, h);
d205 1
a205 1
		child = man_root_pre(m, n, h);
d209 4
d227 1
a227 1
			child = (*mans[n->tok].pre)(m, n, h);
d232 1
a232 1
		print_man_nodelist(m, n->child, h);
d241 1
a241 1
		man_root_post(m, n, h);
d247 1
a247 1
			(*mans[n->tok].post)(m, n, h);
d468 1
a468 1
		print_man_node(m, nn, h);
d662 1
a662 1
			print_man_node(m, nn, h);
d665 1
a665 1
			print_man_node(m, nn, h);
d727 31
@


1.16
log
@Full .nr nS support, unbreaking the kernel manuals.

Kristaps coded this from scratch after reading my .nr patch;
it is simpler and more powerful.

Registers live in struct regset in regs.h, struct man and struct mdoc
contain pointers to it.  The nS register is cleared when parsing .Sh.
Frontends respect the MDOC_SYNPRETTY flag set in mdoc node_alloc.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.15 2010/06/06 18:08:41 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
a27 1
#include "regs.h"
@


1.15
log
@Merge bsd.lv release 1.10.0,
which is mostly the post-hackathon release,
bringing in the OpenBSD changes to bsd.lv,
but which also has a few additional minor fixes:

* .Lb is an in-line macro, not in_line_eoln
* .Bt, .Ud now warn when discarding arguments
* allow bad -man dates to flow verbatim into the front-ends
- so far all reported by Ulrich Spoerlein
* .Ar, .Fl and .Li starting with closing punctuation emit an empty element
* empty .Li macros print nothing, but may cause spacing
* proper EOS handling for .Bt, .Ex, .Rv, and .Ud.
* cleanup: collapse posts_xr into posts_wtext (which is the same)
* efficiency: very simple table lookup for roff.c
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.14 2010/05/23 22:45:00 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d28 1
@


1.14
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.13 2010/05/23 20:57:16 schwarze Exp $ */
d307 4
a310 1
	time2a(m->date, b, DATESIZ);
@


1.13
log
@implement .AT and .UC; from Joerg Sonnenberger
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.12 2010/05/20 00:58:02 schwarze Exp $ */
d25 1
@


1.12
log
@Support nested roff instructions:
* allow roff_parseln() to be re-run
* allow roff_parseln() to manipulate the line buffer offset
* support the offset in the man and mdoc libraries
* adapt .if, .ie, .el, .ig, .am* and .de* support
* interpret some instructions even in conditional-negative context
Coded by kristaps during the last day of the mandoc hackathon.

To avoid regressions in the OpenBSD tree, commit this together
with some small local additions:
* detect roff block end "\}" even on macro lines
* actually implement the ".if n" conditional
* ignore .ds, .rm and .tr in libroff

Also back my old .if/.ie/.el-handling out of libman, reverting:
man.h 1.15 man.c 1.25 man_macro.c 1.15 man_validate.c 1.19
man_action.c 1.15 man_term.c 1.28 man_html.c 1.9.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.11 2010/05/16 00:54:03 schwarze Exp $ */
d105 1
@


1.11
log
@In theory, Kristaps never intended to write a roff parser,
but in practice, most real legacy man(7)uals are using so much
low level roff that we can't really get away without at least
partially handling some roff instructions.

As doing this in man(7) only has become messy and as even some
mdoc(7) pages need it, start a minimal partial roff preprocessor.
As a first step, move handling of .am[i], .de[i] and .ig there.
Do not use the roff preprocessor for new manuals!

Now that we have three main parser libraries - roff, man and mdoc -
each one having its own error handling is becoming messy, too.
Thus, start unifying message handling in one central place,
introducing a new generic function mmsg().

coded by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.10 2010/05/15 18:06:02 schwarze Exp $ */
a104 3
	{ NULL, NULL }, /* if */
	{ NULL, NULL }, /* ie */
	{ NULL, NULL }, /* el */
@


1.10
log
@removed restriction on integer manual sections in -man;
by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.9 2010/04/25 16:32:19 schwarze Exp $ */
a104 6
	{ man_ign_pre, NULL }, /* de */
	{ man_ign_pre, NULL }, /* dei */
	{ man_ign_pre, NULL }, /* am */
	{ man_ign_pre, NULL }, /* ami */
	{ man_ign_pre, NULL }, /* ig */
	{ NULL, NULL }, /* . */
@


1.9
log
@Implement roff conditional instructions .if .ie .el, in man(7) only for now;
fixing OpenBSD::PackageName(3p) and friends for espie@@.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.8 2010/03/26 01:22:05 schwarze Exp $ */
d164 1
a164 1
	buffmt(h, "%s(%d)", m->title, m->msec);
d269 1
a269 1
	snprintf(title, BUFSIZ - 1, "%s(%d)", m->title, m->msec);
@


1.8
log
@merge 1.9.17, keeping local patches

* much improved pod2man support and low-level roff robustness
* have -Tlint imply -Wall and -fstrict
* use fewer macros and more enum in libman
* and various bug fixes
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.7 2010/03/25 23:23:01 schwarze Exp $ */
d111 3
@


1.7
log
@merge 1.9.16, keeping local patches

This is mostly cleanup by kristaps@@ after my rather hackish patch
to tolerate the non-text macros .na, .sp, .br in next-line scope;
plus some nesting issues fixed by him, all in man(7).
This survived a full  cd /usr/src; make man.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.6 2010/03/02 01:00:39 schwarze Exp $ */
d103 8
a110 2
	{ NULL, NULL }, /* Vb */
	{ NULL, NULL }, /* Vi */
d349 9
a357 3
	if ((MAN_sp == n->tok || MAN_Sp == n->tok) && n->child)
		a2roffsu(n->child->string, &su, SCALE_VS);
	else if (MAN_br == n->tok)
d359 2
@


1.6
log
@Accept the non-standard macros .Sp (similar to .sp)
and .Vb/.Ve (similar to .nf/.fi) in man(7) mode.
These are not intended to be used manually, but they allow us to
properly render man(7) code autogenerated by pod2man(1),
making Perl and OpenSSL happy in our tree.
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.5 2010/02/18 02:11:26 schwarze Exp $ */
d183 6
d575 2
d584 9
a592 2
	if (MAN_TP == n->tok && NULL != nn)
		width = a2width(nn, &su);
d617 3
a619 1
	/* With a length string, manually omit the last child. */
d623 7
@


1.5
log
@sync to release 1.9.15:
 * corrected .Vt handling (spotted by Joerg Sonnenberger)
 * corrected .Xr argument handling (based on my patch)
 * removed \\ escape sequence (because it is for low-level roff only)
 * warn about trailing whitespace (suggested by jmc@@)
 * -Txhtml support
 * and some general cleanup and doc improvements
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.4 2009/12/24 02:08:14 schwarze Exp $ */
d102 3
d337 1
a337 1
	if (MAN_sp == n->tok && n->child)
@


1.4
log
@sync to 1.9.14: rewrite escape sequence handling:
- new function a2roffdeco
- font modes (\f) only affect the current stack point
- implement scaling (\s)
- implement space suppression (\c)
- implement non-breaking space (\~) in -Tascii
- many manual improvements
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.3 2009/12/22 23:58:00 schwarze Exp $ */
d113 1
a113 1
	print_gen_doctype(h);
@


1.3
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.2 2009/10/27 21:40:07 schwarze Exp $ */
d186 1
a186 1
		break;
d188 11
d207 1
d251 1
a251 2
	(void)snprintf(title, BUFSIZ - 1, 
			"%s(%d)", m->title, m->msec);
d342 1
d394 1
a394 4
	struct htmlpair		 tagi, tagb, *tagp;

	PAIR_CLASS_INIT(&tagi, "italic");
	PAIR_CLASS_INIT(&tagb, "bold");
d399 1
a399 1
			tagp = i % 2 ? &tagi : &tagb;
d402 1
a402 1
			tagp = i % 2 ? &tagb : &tagi;
d405 1
a405 1
			tagp = i % 2 ? &tagi : NULL;
d408 1
a408 1
			tagp = i % 2 ? NULL : &tagi;
d411 1
a411 1
			tagp = i % 2 ? NULL : &tagb;
d414 1
a414 1
			tagp = i % 2 ? &tagb : NULL;
d424 8
a431 6
		if (tagp) {
			t = print_otag(h, TAG_SPAN, 1, tagp);
			print_man_node(m, nn, h);
			print_tagq(h, t);
		} else
			print_man_node(m, nn, h);
d444 1
d519 1
a519 1
	if (MAN_ROOT == n->parent->tok) {
d522 1
a522 1
		i++;
d524 1
a524 1
	if (n->next && n->next->child) {
d526 2
a527 2
		bufcat_su(h, "margin-bottom", &su);
		i++;
d531 1
a531 1
	print_otag(h, TAG_DIV, i ? 1 : 0, &tag);
a657 1
	struct htmlpair	 tag;
d659 1
a659 2
	PAIR_CLASS_INIT(&tag, "bold");
	print_otag(h, TAG_SPAN, 1, &tag);
d668 2
a669 4
	struct htmlpair	 tag;

	PAIR_CLASS_INIT(&tag, "italic");
	print_otag(h, TAG_SPAN, 1, &tag);
@


1.2
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.1 2009/10/21 19:13:50 schwarze Exp $ */
a20 1
#include <err.h>
d231 1
a231 1
	struct htmlpair	 tag[2];
d245 3
a247 1
	t = print_otag(h, TAG_TABLE, 2, tag);
d281 1
a281 1
	struct htmlpair	 tag[2];
d290 3
a292 1
	t = print_otag(h, TAG_TABLE, 2, tag);
d331 3
@


1.1
log
@sync to 1.9.9, featuring:
 * -Thtml output mode
 * roff scaling units
 * and some minor fixes
for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: man_html.c,v 1.11 2009/10/18 19:03:36 kristaps Exp $ */
a17 1
#include <sys/queue.h>
d32 1
d102 1
d177 1
a177 1
	t = SLIST_FIRST(&h->tags);
a279 1
	struct tm	 tm;
d282 1
a282 1
	char		 b[BUFSIZ];
d284 1
a284 4
	(void)localtime_r(&m->date, &tm);

	if (0 == strftime(b, BUFSIZ - 1, "%B %e, %Y", &tm))
		err(EXIT_FAILURE, "strftime");
@

