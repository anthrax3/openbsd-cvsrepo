head	1.158;
access;
symbols
	OPENBSD_6_1:1.135.0.4
	OPENBSD_6_1_BASE:1.135
	OPENBSD_6_0:1.124.0.2
	OPENBSD_6_0_BASE:1.124
	OPENBSD_5_9:1.122.0.2
	OPENBSD_5_9_BASE:1.122
	OPENBSD_5_8:1.115.0.4
	OPENBSD_5_8_BASE:1.115
	OPENBSD_5_7:1.104.0.2
	OPENBSD_5_7_BASE:1.104
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.2.0.2
	OPENBSD_5_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.158
date	2017.07.03.13.40.00;	author schwarze;	state Exp;
branches;
next	1.157;
commitid	1dutikfSlALoEQie;

1.157
date	2017.07.02.15.31.48;	author schwarze;	state Exp;
branches;
next	1.156;
commitid	AHLDG8sc9gJmviax;

1.156
date	2017.07.01.09.47.23;	author schwarze;	state Exp;
branches;
next	1.155;
commitid	bUWzoq61QcedQFz7;

1.155
date	2017.06.29.15.21.46;	author schwarze;	state Exp;
branches;
next	1.154;
commitid	GIZSbEspTHFlNqWu;

1.154
date	2017.06.25.17.42.37;	author schwarze;	state Exp;
branches;
next	1.153;
commitid	lU4NKBZiOj5pFGLJ;

1.153
date	2017.06.24.18.58.09;	author schwarze;	state Exp;
branches;
next	1.152;
commitid	Ml3HiKmSwGhhly92;

1.152
date	2017.06.24.15.59.28;	author schwarze;	state Exp;
branches;
next	1.151;
commitid	k99BPjhy9T1oDPrY;

1.151
date	2017.06.24.14.38.28;	author schwarze;	state Exp;
branches;
next	1.150;
commitid	ebFpCjoYaInwxToS;

1.150
date	2017.06.17.23.06.43;	author schwarze;	state Exp;
branches;
next	1.149;
commitid	IbYSiNWSEwkdSFTZ;

1.149
date	2017.06.17.22.40.27;	author schwarze;	state Exp;
branches;
next	1.148;
commitid	eh9zSUWrW3gWUWkZ;

1.148
date	2017.06.11.19.36.31;	author schwarze;	state Exp;
branches;
next	1.147;
commitid	XRYVv5vPYVYMmfcL;

1.147
date	2017.06.11.17.16.36;	author schwarze;	state Exp;
branches;
next	1.146;
commitid	dPcvyya15rxVpblT;

1.146
date	2017.06.10.01.48.31;	author schwarze;	state Exp;
branches;
next	1.145;
commitid	GnqehULkzSOZe9a6;

1.145
date	2017.06.08.00.21.23;	author schwarze;	state Exp;
branches;
next	1.144;
commitid	deNJv5UgZ6ZWmFWt;

1.144
date	2017.06.07.23.29.31;	author schwarze;	state Exp;
branches;
next	1.143;
commitid	ZGR4ldkhpkbOKKrj;

1.143
date	2017.06.06.15.00.56;	author schwarze;	state Exp;
branches;
next	1.142;
commitid	LdhzICSunbnL2oyB;

1.142
date	2017.06.04.00.08.56;	author schwarze;	state Exp;
branches;
next	1.141;
commitid	utobDj41l6WSbX2y;

1.141
date	2017.06.03.15.54.09;	author schwarze;	state Exp;
branches;
next	1.140;
commitid	iOor4zVcyUusVswq;

1.140
date	2017.06.01.15.24.41;	author schwarze;	state Exp;
branches;
next	1.139;
commitid	HpKDtV1c60HwJeIE;

1.139
date	2017.05.31.15.30.12;	author schwarze;	state Exp;
branches;
next	1.138;
commitid	JVG7q5p4I1jfXSdC;

1.138
date	2017.05.30.19.29.31;	author schwarze;	state Exp;
branches;
next	1.137;
commitid	aKw7GZmlWwBhe2SM;

1.137
date	2017.05.16.19.05.36;	author schwarze;	state Exp;
branches;
next	1.136;
commitid	IIx55ETP0e3E42lv;

1.136
date	2017.04.29.12.43.55;	author schwarze;	state Exp;
branches;
next	1.135;
commitid	7BLUwozNEzUO8xfK;

1.135
date	2017.03.07.20.00.02;	author schwarze;	state Exp;
branches;
next	1.134;
commitid	nIuTuKCGxqHDocIn;

1.134
date	2017.03.06.17.25.24;	author schwarze;	state Exp;
branches;
next	1.133;
commitid	T3Lyz7zZ1p6Y3Qbz;

1.133
date	2017.02.03.18.18.08;	author schwarze;	state Exp;
branches;
next	1.132;
commitid	qc4bZKiJu8zYKwfN;

1.132
date	2017.02.03.17.55.36;	author schwarze;	state Exp;
branches;
next	1.131;
commitid	61ia2vii5vRILyu0;

1.131
date	2017.01.28.23.26.56;	author schwarze;	state Exp;
branches;
next	1.130;
commitid	7sT9Hxn0lUNOlacH;

1.130
date	2017.01.09.01.36.22;	author schwarze;	state Exp;
branches;
next	1.129;
commitid	h3vKZfLhTYNgTrav;

1.129
date	2017.01.08.00.10.22;	author schwarze;	state Exp;
branches;
next	1.128;
commitid	W4clzDItIfTolc66;

1.128
date	2016.12.28.17.21.17;	author schwarze;	state Exp;
branches;
next	1.127;
commitid	KjwyCoopqjkm90wM;

1.127
date	2016.12.07.22.57.35;	author schwarze;	state Exp;
branches;
next	1.126;
commitid	KuHaIDzkRVEr0sgy;

1.126
date	2016.11.10.12.47.05;	author schwarze;	state Exp;
branches;
next	1.125;
commitid	DqVhw18uek41TbqP;

1.125
date	2016.10.09.18.16.46;	author schwarze;	state Exp;
branches;
next	1.124;
commitid	naY2DgYOKonEJYdH;

1.124
date	2016.07.19.16.22.34;	author schwarze;	state Exp;
branches;
next	1.123;
commitid	W8oAmUl38SwfQdz6;

1.123
date	2016.07.10.13.33.50;	author schwarze;	state Exp;
branches;
next	1.122;
commitid	8fLgtOLHLePgtFfM;

1.122
date	2016.01.08.02.53.09;	author schwarze;	state Exp;
branches;
next	1.121;
commitid	HwNcDew1e7MZc0JI;

1.121
date	2016.01.08.02.13.35;	author schwarze;	state Exp;
branches;
next	1.120;
commitid	DCHIkxiiKvXaJZJp;

1.120
date	2015.10.30.19.03.36;	author schwarze;	state Exp;
branches;
next	1.119;
commitid	B2ZxW3H5UgZIgEOi;

1.119
date	2015.10.13.22.57.49;	author schwarze;	state Exp;
branches;
next	1.118;
commitid	jXIG8UzKLXm2Z9i6;

1.118
date	2015.10.11.21.06.59;	author schwarze;	state Exp;
branches;
next	1.117;
commitid	fBGuLyDivJdmK1wz;

1.117
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.116;
commitid	hxQV8O1pNUaef4ir;

1.116
date	2015.09.14.15.35.47;	author schwarze;	state Exp;
branches;
next	1.115;
commitid	rmmzXNvCXUtwzubE;

1.115
date	2015.07.19.05.59.07;	author schwarze;	state Exp;
branches;
next	1.114;
commitid	X9sGdJbndRzfjdoG;

1.114
date	2015.04.19.14.25.05;	author schwarze;	state Exp;
branches;
next	1.113;
commitid	E1gJfKuheBoo64Vb;

1.113
date	2015.04.19.13.59.37;	author schwarze;	state Exp;
branches;
next	1.112;
commitid	aS3h5dIgZk0f7675;

1.112
date	2015.04.18.17.28.08;	author schwarze;	state Exp;
branches;
next	1.111;
commitid	zD52rmYwzwgofy8v;

1.111
date	2015.04.18.17.01.28;	author schwarze;	state Exp;
branches;
next	1.110;
commitid	GslLZJxifCkaUipL;

1.110
date	2015.04.18.16.34.03;	author schwarze;	state Exp;
branches;
next	1.109;
commitid	PxhkeHVIvdTMOTs6;

1.109
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.108;
commitid	6MYJ7cd8mhJ77AGH;

1.108
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.107;
commitid	lmErjWY2O9ooA6RY;

1.107
date	2015.03.17.07.32.21;	author schwarze;	state Exp;
branches;
next	1.106;
commitid	8aec9pdQoYUAe3Rf;

1.106
date	2015.03.11.13.04.10;	author schwarze;	state Exp;
branches;
next	1.105;
commitid	18ZWwo2x2rC4EI9K;

1.105
date	2015.03.10.14.17.22;	author schwarze;	state Exp;
branches;
next	1.104;
commitid	g7diFHM5IcTwN5vc;

1.104
date	2015.03.02.14.48.31;	author schwarze;	state Exp;
branches;
next	1.103;
commitid	w8NmjT89btWwEjGQ;

1.103
date	2015.02.23.13.30.02;	author schwarze;	state Exp;
branches;
next	1.102;
commitid	0JG7TLVmNW4cori6;

1.102
date	2015.02.20.22.40.05;	author schwarze;	state Exp;
branches;
next	1.101;
commitid	YAJ1u5XIijTFtCAd;

1.101
date	2015.02.06.16.05.51;	author schwarze;	state Exp;
branches;
next	1.100;
commitid	Bj9alpGWXCQILmH9;

1.100
date	2015.02.06.11.54.03;	author schwarze;	state Exp;
branches;
next	1.99;
commitid	Wgxy0y7jtcdh0XG7;

1.99
date	2015.02.06.07.12.34;	author schwarze;	state Exp;
branches;
next	1.98;
commitid	QDbepmLqTNee3zgJ;

1.98
date	2015.02.06.03.31.11;	author schwarze;	state Exp;
branches;
next	1.97;
commitid	EGoCKP2gntS3HBlE;

1.97
date	2015.02.04.18.03.28;	author schwarze;	state Exp;
branches;
next	1.96;
commitid	voy6CFtu7t43ZgbA;

1.96
date	2015.02.04.16.38.31;	author schwarze;	state Exp;
branches;
next	1.95;
commitid	MoF7T4hAk1bvNz7U;

1.95
date	2015.01.28.21.10.28;	author schwarze;	state Exp;
branches;
next	1.94;
commitid	fvM2x3xHE0B4upcu;

1.94
date	2015.01.28.17.30.37;	author schwarze;	state Exp;
branches;
next	1.93;
commitid	B9i4oMLogJsiyrd5;

1.93
date	2015.01.26.18.41.45;	author schwarze;	state Exp;
branches;
next	1.92;
commitid	mmVgjPEivVGaZY4u;

1.92
date	2015.01.26.13.02.53;	author schwarze;	state Exp;
branches;
next	1.91;
commitid	TckXsclN2hfFrBFF;

1.91
date	2015.01.26.00.54.09;	author schwarze;	state Exp;
branches;
next	1.90;
commitid	vhh5zuNKcPCGcJgK;

1.90
date	2015.01.24.01.59.40;	author schwarze;	state Exp;
branches;
next	1.89;
commitid	pxeX1HXdNjYPBYKE;

1.89
date	2015.01.22.21.36.44;	author schwarze;	state Exp;
branches;
next	1.88;
commitid	feJuP9ph3mKvcaqr;

1.88
date	2015.01.22.19.26.16;	author schwarze;	state Exp;
branches;
next	1.87;
commitid	LjsFsmAiFEkOGnBF;

1.87
date	2015.01.20.21.12.46;	author schwarze;	state Exp;
branches;
next	1.86;
commitid	yL1piccWr1moLOpy;

1.86
date	2015.01.15.04.26.06;	author schwarze;	state Exp;
branches;
next	1.85;
commitid	TgtfgXU8Rz8XgmeH;

1.85
date	2015.01.15.02.29.07;	author schwarze;	state Exp;
branches;
next	1.84;
commitid	Vo5xG7mxv2w7gxZV;

1.84
date	2015.01.14.22.57.57;	author schwarze;	state Exp;
branches;
next	1.83;
commitid	pB8ZvBlUeO92L1BP;

1.83
date	2015.01.14.22.02.00;	author schwarze;	state Exp;
branches;
next	1.82;
commitid	3rgOerOpi4Q1Co7V;

1.82
date	2015.01.14.17.45.25;	author schwarze;	state Exp;
branches;
next	1.81;
commitid	5UxaFbklRRwvScbK;

1.81
date	2014.12.28.14.39.08;	author schwarze;	state Exp;
branches;
next	1.80;
commitid	6ZLiZAxCS3hyLbh4;

1.80
date	2014.12.16.23.44.16;	author schwarze;	state Exp;
branches;
next	1.79;
commitid	r7Pkn5lMmGIVLeBR;

1.79
date	2014.11.30.05.28.00;	author schwarze;	state Exp;
branches;
next	1.78;
commitid	4gOj8tbqcpkeLVbt;

1.78
date	2014.11.30.02.31.32;	author schwarze;	state Exp;
branches;
next	1.77;
commitid	2VPAWCQ5LDs66xdK;

1.77
date	2014.11.28.18.07.38;	author schwarze;	state Exp;
branches;
next	1.76;
commitid	FLjJT6vAqGK0xVjM;

1.76
date	2014.11.28.06.26.46;	author schwarze;	state Exp;
branches;
next	1.75;
commitid	M5K1YnX7vRaFkPkc;

1.75
date	2014.11.27.23.35.03;	author schwarze;	state Exp;
branches;
next	1.74;
commitid	h4lbTux1L5FzGMXy;

1.74
date	2014.11.26.23.27.13;	author schwarze;	state Exp;
branches;
next	1.73;
commitid	tAfgamG9qyikU9rQ;

1.73
date	2014.11.26.21.40.11;	author schwarze;	state Exp;
branches;
next	1.72;
commitid	BFoJYar3mOvn9yB3;

1.72
date	2014.11.01.06.02.43;	author schwarze;	state Exp;
branches;
next	1.71;
commitid	3fBnp5rg5xbTeWnZ;

1.71
date	2014.11.01.04.07.25;	author schwarze;	state Exp;
branches;
next	1.70;
commitid	dQ52Fm35XZoT76Y1;

1.70
date	2014.10.30.00.05.02;	author schwarze;	state Exp;
branches;
next	1.69;
commitid	dxVoXRJjO1zZjAXI;

1.69
date	2014.10.28.17.35.42;	author schwarze;	state Exp;
branches;
next	1.68;
commitid	pNwmOla3ZQwLgu2f;

1.68
date	2014.10.20.19.21.31;	author schwarze;	state Exp;
branches;
next	1.67;
commitid	7LDoViU00JgOAI7G;

1.67
date	2014.10.18.15.46.16;	author schwarze;	state Exp;
branches;
next	1.66;
commitid	QXZTfMgoc4XBAEwx;

1.66
date	2014.10.12.19.10.56;	author schwarze;	state Exp;
branches;
next	1.65;
commitid	oFUg4cCWEgutyqUr;

1.65
date	2014.10.11.21.14.11;	author schwarze;	state Exp;
branches;
next	1.64;
commitid	ArFLy7r4v7g9NTzH;

1.64
date	2014.09.12.00.53.21;	author schwarze;	state Exp;
branches;
next	1.63;
commitid	nVgiAqRo1hF16aAQ;

1.63
date	2014.09.11.23.52.47;	author schwarze;	state Exp;
branches;
next	1.62;
commitid	OL6L1tS4sl1FuVNA;

1.62
date	2014.09.07.23.24.33;	author schwarze;	state Exp;
branches;
next	1.61;
commitid	fhtI2THcHW6rewCo;

1.61
date	2014.09.07.02.17.36;	author schwarze;	state Exp;
branches;
next	1.60;
commitid	pzAshO321nCZ40MH;

1.60
date	2014.09.06.23.24.27;	author schwarze;	state Exp;
branches;
next	1.59;
commitid	cVS8Yl9euSk9Ay5F;

1.59
date	2014.09.06.22.38.35;	author schwarze;	state Exp;
branches;
next	1.58;
commitid	TDPFPNCkor60BTJO;

1.58
date	2014.09.03.23.20.33;	author schwarze;	state Exp;
branches;
next	1.57;
commitid	nPk0DzpqFSEanZEV;

1.57
date	2014.08.08.16.17.09;	author schwarze;	state Exp;
branches;
next	1.56;
commitid	TLMAnDXVMoqLltgG;

1.56
date	2014.08.08.15.54.10;	author schwarze;	state Exp;
branches;
next	1.55;
commitid	yBKHNskikm52fHMo;

1.55
date	2014.08.08.15.48.43;	author schwarze;	state Exp;
branches;
next	1.54;
commitid	G8BpeOpuFhU22sI2;

1.54
date	2014.08.08.15.45.58;	author schwarze;	state Exp;
branches;
next	1.53;
commitid	HtYC13kYxIr23M9f;

1.53
date	2014.08.08.15.42.39;	author schwarze;	state Exp;
branches;
next	1.52;
commitid	dIfosrluXZ6tTQFU;

1.52
date	2014.08.08.15.38.46;	author schwarze;	state Exp;
branches;
next	1.51;
commitid	0s9bQuCDRMV0Ke9L;

1.51
date	2014.08.08.15.26.28;	author schwarze;	state Exp;
branches;
next	1.50;
commitid	p7GwHxeS0xJRdvMp;

1.50
date	2014.08.08.15.21.17;	author schwarze;	state Exp;
branches;
next	1.49;
commitid	6Tv1eQzz4fj9QlUj;

1.49
date	2014.08.08.15.15.27;	author schwarze;	state Exp;
branches;
next	1.48;
commitid	fgZ1S3QYW6RU4QWI;

1.48
date	2014.08.08.15.10.15;	author schwarze;	state Exp;
branches;
next	1.47;
commitid	V6V8vpTM0RQ4gS7I;

1.47
date	2014.07.09.11.30.07;	author schwarze;	state Exp;
branches;
next	1.46;
commitid	WErJgzRtDKBz19TC;

1.46
date	2014.07.07.21.35.42;	author schwarze;	state Exp;
branches;
next	1.45;
commitid	O2S43bw50KTGcriR;

1.45
date	2014.07.07.16.12.06;	author schwarze;	state Exp;
branches;
next	1.44;
commitid	JkcWLt8pXBmAkPFj;

1.44
date	2014.07.07.15.03.24;	author schwarze;	state Exp;
branches;
next	1.43;
commitid	LD7wx5yJuIhKJiro;

1.43
date	2014.07.07.11.34.41;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	SxiKID1BRkm7SsXU;

1.42
date	2014.07.06.19.08.56;	author schwarze;	state Exp;
branches;
next	1.41;
commitid	rolX8OitNNoUBJoD;

1.41
date	2014.07.05.12.33.54;	author schwarze;	state Exp;
branches;
next	1.40;
commitid	IbTbYyU1XoSImvHA;

1.40
date	2014.07.05.01.11.33;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	xwzAVywNWdayFtqP;

1.39
date	2014.07.04.16.11.41;	author schwarze;	state Exp;
branches;
next	1.38;
commitid	sgqZ9hnRM3L6yvgn;

1.38
date	2014.07.04.01.50.03;	author schwarze;	state Exp;
branches;
next	1.37;
commitid	Y8kkUfI8kBY4R2Vw;

1.37
date	2014.07.03.23.23.45;	author schwarze;	state Exp;
branches;
next	1.36;
commitid	r0fsz0DrjbQnVa67;

1.36
date	2014.07.03.21.23.08;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	fILxF31MgcuaKrF8;

1.35
date	2014.07.02.13.10.15;	author schwarze;	state Exp;
branches;
next	1.34;
commitid	Ao0fphsjJ98jbj9D;

1.34
date	2014.07.02.11.42.56;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	aUdrdtDM8sKwymS7;

1.33
date	2014.07.02.03.47.07;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	p4pNII1v0bYCswy0;

1.32
date	2014.07.01.22.36.35;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	6SNWblzmBTWk9YRA;

1.31
date	2014.06.30.23.45.03;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	REPMRSo60FbInFiA;

1.30
date	2014.06.25.00.19.17;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	JeAYFU7kC8rIy3dQ;

1.29
date	2014.06.21.22.23.44;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	XF9RGPYLiBVL882J;

1.28
date	2014.06.20.22.58.41;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	ktgkM223FL3EC6E8;

1.27
date	2014.06.20.17.23.09;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	gTaF7NL9JpgvI2ni;

1.26
date	2014.04.20.22.03.40;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2014.03.19.22.20.36;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2014.03.19.21.50.59;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2014.01.06.21.33.00;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2014.01.06.00.53.14;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2014.01.05.20.26.27;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2014.01.02.16.29.46;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2013.09.16.00.25.06;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2013.07.13.12.51.38;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.02.03.35.21;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2013.06.01.22.57.30;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.30.03.51.59;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2012.11.19.22.28.35;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2012.11.16.22.20.40;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2012.07.18.11.09.30;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2012.07.12.15.09.50;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.02.23.18.30;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2012.05.24.23.33.23;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2012.02.26.21.01.43;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.16.02.18;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.09.17.59.56;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.158
log
@warn about time machines; suggested by Thomas Klausner <wiz @@ NetBSD>
@
text
@/*	$OpenBSD: read.c,v 1.157 2017/07/02 15:31:48 schwarze Exp $ */
/*
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010-2017 Ingo Schwarze <schwarze@@openbsd.org>
 * Copyright (c) 2010, 2012 Joerg Sonnenberger <joerg@@netbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <zlib.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "man.h"
#include "libmandoc.h"
#include "roff_int.h"

#define	REPARSE_LIMIT	1000

struct	mparse {
	struct roff	 *roff; /* roff parser (!NULL) */
	struct roff_man	 *man; /* man parser */
	char		 *sodest; /* filename pointed to by .so */
	const char	 *file; /* filename of current input file */
	struct buf	 *primary; /* buffer currently being parsed */
	struct buf	 *secondary; /* preprocessed copy of input */
	const char	 *os_s; /* default operating system */
	mandocmsg	  mmsg; /* warning/error message handler */
	enum mandoclevel  file_status; /* status of current parse */
	enum mandocerr	  mmin; /* ignore messages below this */
	int		  options; /* parser options */
	int		  gzip; /* current input file is gzipped */
	int		  filenc; /* encoding of the current file */
	int		  reparse_count; /* finite interp. stack */
	int		  line; /* line number in the file */
};

static	void	  choose_parser(struct mparse *);
static	void	  resize_buf(struct buf *, size_t);
static	int	  mparse_buf_r(struct mparse *, struct buf, size_t, int);
static	int	  read_whole_file(struct mparse *, const char *, int,
				struct buf *, int *);
static	void	  mparse_end(struct mparse *);
static	void	  mparse_parse_buffer(struct mparse *, struct buf,
			const char *);

static	const enum mandocerr	mandoclimits[MANDOCLEVEL_MAX] = {
	MANDOCERR_OK,
	MANDOCERR_STYLE,
	MANDOCERR_WARNING,
	MANDOCERR_ERROR,
	MANDOCERR_UNSUPP,
	MANDOCERR_MAX,
	MANDOCERR_MAX
};

static	const char * const	mandocerrs[MANDOCERR_MAX] = {
	"ok",

	"base system convention",

	"Mdocdate found",
	"Mdocdate missing",
	"unknown architecture",
	"operating system explicitly specified",
	"RCS id missing",
	"referenced manual not found",

	"generic style suggestion",

	"legacy man(7) date format",
	"duplicate RCS id",
	"typo in section name",
	"useless macro",
	"consider using OS macro",
	"errnos out of order",
	"duplicate errno",
	"description line ends with a full stop",
	"no blank before trailing delimiter",
	"function name without markup",

	"generic warning",

	/* related to the prologue */
	"missing manual title, using UNTITLED",
	"missing manual title, using \"\"",
	"lower case character in document title",
	"missing manual section, using \"\"",
	"unknown manual section",
	"missing date, using today's date",
	"cannot parse date, using it verbatim",
	"date in the future, using it anyway",
	"missing Os macro, using \"\"",
	"duplicate prologue macro",
	"late prologue macro",
	"skipping late title macro",
	"prologue macros out of order",

	/* related to document structure */
	".so is fragile, better use ln(1)",
	"no document body",
	"content before first section header",
	"first section is not \"NAME\"",
	"NAME section without Nm before Nd",
	"NAME section without description",
	"description not at the end of NAME",
	"bad NAME section content",
	"missing comma before name",
	"missing description line, using \"\"",
	"description line outside NAME section",
	"sections out of conventional order",
	"duplicate section title",
	"unexpected section",
	"cross reference to self",
	"unusual Xr order",
	"unusual Xr punctuation",
	"AUTHORS section without An macro",

	/* related to macros and nesting */
	"obsolete macro",
	"macro neither callable nor escaped",
	"skipping paragraph macro",
	"moving paragraph macro out of list",
	"skipping no-space macro",
	"blocks badly nested",
	"nested displays are not portable",
	"moving content out of list",
	"first macro on line",
	"fill mode already enabled, skipping",
	"fill mode already disabled, skipping",
	"line scope broken",
	"skipping blank line in line scope",

	/* related to missing macro arguments */
	"skipping empty request",
	"conditional request controls empty scope",
	"skipping empty macro",
	"empty block",
	"empty argument, using 0n",
	"missing display type, using -ragged",
	"list type is not the first argument",
	"missing -width in -tag list, using 6n",
	"missing utility name, using \"\"",
	"missing function name, using \"\"",
	"empty head in list item",
	"empty list item",
	"missing argument, using next line",
	"missing font type, using \\fR",
	"unknown font type, using \\fR",
	"nothing follows prefix",
	"empty reference block",
	"missing section argument",
	"missing -std argument, adding it",
	"missing option string, using \"\"",
	"missing resource identifier, using \"\"",
	"missing eqn box, using \"\"",

	/* related to bad macro arguments */
	"unterminated quoted argument",
	"duplicate argument",
	"skipping duplicate argument",
	"skipping duplicate display type",
	"skipping duplicate list type",
	"skipping -width argument",
	"wrong number of cells",
	"unknown AT&T UNIX version",
	"comma in function argument",
	"parenthesis in function name",
	"unknown library name",
	"invalid content in Rs block",
	"invalid Boolean argument",
	"unknown font, skipping request",
	"odd number of characters in request",

	/* related to plain text */
	"blank line in fill mode, using .sp",
	"tab in filled text",
	"whitespace at end of input line",
	"new sentence, new line",
	"bad comment style",
	"invalid escape sequence",
	"undefined string, using \"\"",

	/* related to tables */
	"tbl line starts with span",
	"tbl column starts with span",
	"skipping vertical bar in tbl layout",

	"generic error",

	/* related to tables */
	"non-alphabetic character in tbl options",
	"skipping unknown tbl option",
	"missing tbl option argument",
	"wrong tbl option argument size",
	"empty tbl layout",
	"invalid character in tbl layout",
	"unmatched parenthesis in tbl layout",
	"tbl without any data cells",
	"ignoring data in spanned tbl cell",
	"ignoring extra tbl data cells",
	"data block open at end of tbl",

	/* related to document structure and macros */
	NULL,
	"input stack limit exceeded, infinite loop?",
	"skipping bad character",
	"skipping unknown macro",
	"skipping insecure request",
	"skipping item outside list",
	"skipping column outside column list",
	"skipping end of block that is not open",
	"fewer RS blocks open, skipping",
	"inserting missing end of block",
	"appending missing end of block",

	/* related to request and macro arguments */
	"escaped character not allowed in a name",
	"NOT IMPLEMENTED: Bd -file",
	"skipping display without arguments",
	"missing list type, using -item",
	"argument is not numeric, using 1",
	"missing manual name, using \"\"",
	"uname(3) system call failed, using UNKNOWN",
	"unknown standard specifier",
	"skipping request without numeric argument",
	"NOT IMPLEMENTED: .so with absolute path or \"..\"",
	".so request failed",
	"skipping all arguments",
	"skipping excess arguments",
	"divide by zero",

	"unsupported feature",
	"input too large",
	"unsupported control character",
	"unsupported roff request",
	"eqn delim option in tbl",
	"unsupported tbl layout modifier",
	"ignoring macro in table",
};

static	const char * const	mandoclevels[MANDOCLEVEL_MAX] = {
	"SUCCESS",
	"STYLE",
	"WARNING",
	"ERROR",
	"UNSUPP",
	"BADARG",
	"SYSERR"
};


static void
resize_buf(struct buf *buf, size_t initial)
{

	buf->sz = buf->sz > initial/2 ? 2 * buf->sz : initial;
	buf->buf = mandoc_realloc(buf->buf, buf->sz);
}

static void
choose_parser(struct mparse *curp)
{
	char		*cp, *ep;
	int		 format;

	/*
	 * If neither command line arguments -mdoc or -man select
	 * a parser nor the roff parser found a .Dd or .TH macro
	 * yet, look ahead in the main input buffer.
	 */

	if ((format = roff_getformat(curp->roff)) == 0) {
		cp = curp->primary->buf;
		ep = cp + curp->primary->sz;
		while (cp < ep) {
			if (*cp == '.' || *cp == '\'') {
				cp++;
				if (cp[0] == 'D' && cp[1] == 'd') {
					format = MPARSE_MDOC;
					break;
				}
				if (cp[0] == 'T' && cp[1] == 'H') {
					format = MPARSE_MAN;
					break;
				}
			}
			cp = memchr(cp, '\n', ep - cp);
			if (cp == NULL)
				break;
			cp++;
		}
	}

	if (format == MPARSE_MDOC) {
		curp->man->macroset = MACROSET_MDOC;
		if (curp->man->mdocmac == NULL)
			curp->man->mdocmac = roffhash_alloc(MDOC_Dd, MDOC_MAX);
	} else {
		curp->man->macroset = MACROSET_MAN;
		if (curp->man->manmac == NULL)
			curp->man->manmac = roffhash_alloc(MAN_TH, MAN_MAX);
	}
	curp->man->first->tok = TOKEN_NONE;
}

/*
 * Main parse routine for a buffer.
 * It assumes encoding and line numbering are already set up.
 * It can recurse directly (for invocations of user-defined
 * macros, inline equations, and input line traps)
 * and indirectly (for .so file inclusion).
 */
static int
mparse_buf_r(struct mparse *curp, struct buf blk, size_t i, int start)
{
	const struct tbl_span	*span;
	struct buf	 ln;
	const char	*save_file;
	char		*cp;
	size_t		 pos; /* byte number in the ln buffer */
	enum rofferr	 rr;
	int		 of;
	int		 lnn; /* line number in the real file */
	int		 fd;
	unsigned char	 c;

	memset(&ln, 0, sizeof(ln));

	lnn = curp->line;
	pos = 0;

	while (i < blk.sz) {
		if (0 == pos && '\0' == blk.buf[i])
			break;

		if (start) {
			curp->line = lnn;
			curp->reparse_count = 0;

			if (lnn < 3 &&
			    curp->filenc & MPARSE_UTF8 &&
			    curp->filenc & MPARSE_LATIN1)
				curp->filenc = preconv_cue(&blk, i);
		}

		while (i < blk.sz && (start || blk.buf[i] != '\0')) {

			/*
			 * When finding an unescaped newline character,
			 * leave the character loop to process the line.
			 * Skip a preceding carriage return, if any.
			 */

			if ('\r' == blk.buf[i] && i + 1 < blk.sz &&
			    '\n' == blk.buf[i + 1])
				++i;
			if ('\n' == blk.buf[i]) {
				++i;
				++lnn;
				break;
			}

			/*
			 * Make sure we have space for the worst
			 * case of 11 bytes: "\\[u10ffff]\0"
			 */

			if (pos + 11 > ln.sz)
				resize_buf(&ln, 256);

			/*
			 * Encode 8-bit input.
			 */

			c = blk.buf[i];
			if (c & 0x80) {
				if ( ! (curp->filenc && preconv_encode(
				    &blk, &i, &ln, &pos, &curp->filenc))) {
					mandoc_vmsg(MANDOCERR_CHAR_BAD, curp,
					    curp->line, pos, "0x%x", c);
					ln.buf[pos++] = '?';
					i++;
				}
				continue;
			}

			/*
			 * Exclude control characters.
			 */

			if (c == 0x7f || (c < 0x20 && c != 0x09)) {
				mandoc_vmsg(c == 0x00 || c == 0x04 ||
				    c > 0x0a ? MANDOCERR_CHAR_BAD :
				    MANDOCERR_CHAR_UNSUPP,
				    curp, curp->line, pos, "0x%x", c);
				i++;
				if (c != '\r')
					ln.buf[pos++] = '?';
				continue;
			}

			ln.buf[pos++] = blk.buf[i++];
		}

		if (pos + 1 >= ln.sz)
			resize_buf(&ln, 256);

		if (i == blk.sz || blk.buf[i] == '\0')
			ln.buf[pos++] = '\n';
		ln.buf[pos] = '\0';

		/*
		 * A significant amount of complexity is contained by
		 * the roff preprocessor.  It's line-oriented but can be
		 * expressed on one line, so we need at times to
		 * readjust our starting point and re-run it.  The roff
		 * preprocessor can also readjust the buffers with new
		 * data, so we pass them in wholesale.
		 */

		of = 0;

		/*
		 * Maintain a lookaside buffer of all parsed lines.  We
		 * only do this if mparse_keep() has been invoked (the
		 * buffer may be accessed with mparse_getkeep()).
		 */

		if (curp->secondary) {
			curp->secondary->buf = mandoc_realloc(
			    curp->secondary->buf,
			    curp->secondary->sz + pos + 2);
			memcpy(curp->secondary->buf +
			    curp->secondary->sz,
			    ln.buf, pos);
			curp->secondary->sz += pos;
			curp->secondary->buf
				[curp->secondary->sz] = '\n';
			curp->secondary->sz++;
			curp->secondary->buf
				[curp->secondary->sz] = '\0';
		}
rerun:
		rr = roff_parseln(curp->roff, curp->line, &ln, &of);

		switch (rr) {
		case ROFF_REPARSE:
			if (++curp->reparse_count > REPARSE_LIMIT)
				mandoc_msg(MANDOCERR_ROFFLOOP, curp,
				    curp->line, pos, NULL);
			else if (mparse_buf_r(curp, ln, of, 0) == 1 ||
			    start == 1) {
				pos = 0;
				continue;
			}
			free(ln.buf);
			return 0;
		case ROFF_APPEND:
			pos = strlen(ln.buf);
			continue;
		case ROFF_RERUN:
			goto rerun;
		case ROFF_IGN:
			pos = 0;
			continue;
		case ROFF_SO:
			if ( ! (curp->options & MPARSE_SO) &&
			    (i >= blk.sz || blk.buf[i] == '\0')) {
				curp->sodest = mandoc_strdup(ln.buf + of);
				free(ln.buf);
				return 1;
			}
			/*
			 * We remove `so' clauses from our lookaside
			 * buffer because we're going to descend into
			 * the file recursively.
			 */
			if (curp->secondary)
				curp->secondary->sz -= pos + 1;
			save_file = curp->file;
			if ((fd = mparse_open(curp, ln.buf + of)) != -1) {
				mparse_readfd(curp, fd, ln.buf + of);
				close(fd);
				curp->file = save_file;
			} else {
				curp->file = save_file;
				mandoc_vmsg(MANDOCERR_SO_FAIL,
				    curp, curp->line, pos,
				    ".so %s", ln.buf + of);
				ln.sz = mandoc_asprintf(&cp,
				    ".sp\nSee the file %s.\n.sp",
				    ln.buf + of);
				free(ln.buf);
				ln.buf = cp;
				of = 0;
				mparse_buf_r(curp, ln, of, 0);
			}
			pos = 0;
			continue;
		default:
			break;
		}

		if (curp->man->macroset == MACROSET_NONE)
			choose_parser(curp);

		/*
		 * Lastly, push down into the parsers themselves.
		 * If libroff returns ROFF_TBL, then add it to the
		 * currently open parse.  Since we only get here if
		 * there does exist data (see tbl_data.c), we're
		 * guaranteed that something's been allocated.
		 * Do the same for ROFF_EQN.
		 */

		if (rr == ROFF_TBL)
			while ((span = roff_span(curp->roff)) != NULL)
				roff_addtbl(curp->man, span);
		else if (rr == ROFF_EQN)
			roff_addeqn(curp->man, roff_eqn(curp->roff));
		else if ((curp->man->macroset == MACROSET_MDOC ?
		    mdoc_parseln(curp->man, curp->line, ln.buf, of) :
		    man_parseln(curp->man, curp->line, ln.buf, of)) == 2)
				break;

		/* Temporary buffers typically are not full. */

		if (0 == start && '\0' == blk.buf[i])
			break;

		/* Start the next input line. */

		pos = 0;
	}

	free(ln.buf);
	return 1;
}

static int
read_whole_file(struct mparse *curp, const char *file, int fd,
		struct buf *fb, int *with_mmap)
{
	struct stat	 st;
	gzFile		 gz;
	size_t		 off;
	ssize_t		 ssz;

	if (fstat(fd, &st) == -1)
		err((int)MANDOCLEVEL_SYSERR, "%s", file);

	/*
	 * If we're a regular file, try just reading in the whole entry
	 * via mmap().  This is faster than reading it into blocks, and
	 * since each file is only a few bytes to begin with, I'm not
	 * concerned that this is going to tank any machines.
	 */

	if (curp->gzip == 0 && S_ISREG(st.st_mode)) {
		if (st.st_size > 0x7fffffff) {
			mandoc_msg(MANDOCERR_TOOLARGE, curp, 0, 0, NULL);
			return 0;
		}
		*with_mmap = 1;
		fb->sz = (size_t)st.st_size;
		fb->buf = mmap(NULL, fb->sz, PROT_READ, MAP_SHARED, fd, 0);
		if (fb->buf != MAP_FAILED)
			return 1;
	}

	if (curp->gzip) {
		if ((gz = gzdopen(fd, "rb")) == NULL)
			err((int)MANDOCLEVEL_SYSERR, "%s", file);
	} else
		gz = NULL;

	/*
	 * If this isn't a regular file (like, say, stdin), then we must
	 * go the old way and just read things in bit by bit.
	 */

	*with_mmap = 0;
	off = 0;
	fb->sz = 0;
	fb->buf = NULL;
	for (;;) {
		if (off == fb->sz) {
			if (fb->sz == (1U << 31)) {
				mandoc_msg(MANDOCERR_TOOLARGE, curp,
				    0, 0, NULL);
				break;
			}
			resize_buf(fb, 65536);
		}
		ssz = curp->gzip ?
		    gzread(gz, fb->buf + (int)off, fb->sz - off) :
		    read(fd, fb->buf + (int)off, fb->sz - off);
		if (ssz == 0) {
			fb->sz = off;
			return 1;
		}
		if (ssz == -1)
			err((int)MANDOCLEVEL_SYSERR, "%s", file);
		off += (size_t)ssz;
	}

	free(fb->buf);
	fb->buf = NULL;
	return 0;
}

static void
mparse_end(struct mparse *curp)
{
	if (curp->man->macroset == MACROSET_NONE)
		curp->man->macroset = MACROSET_MAN;
	if (curp->man->macroset == MACROSET_MDOC)
		mdoc_endparse(curp->man);
	else
		man_endparse(curp->man);
	roff_endparse(curp->roff);
}

static void
mparse_parse_buffer(struct mparse *curp, struct buf blk, const char *file)
{
	struct buf	*svprimary;
	const char	*svfile;
	size_t		 offset;
	static int	 recursion_depth;

	if (64 < recursion_depth) {
		mandoc_msg(MANDOCERR_ROFFLOOP, curp, curp->line, 0, NULL);
		return;
	}

	/* Line number is per-file. */
	svfile = curp->file;
	curp->file = file;
	svprimary = curp->primary;
	curp->primary = &blk;
	curp->line = 1;
	recursion_depth++;

	/* Skip an UTF-8 byte order mark. */
	if (curp->filenc & MPARSE_UTF8 && blk.sz > 2 &&
	    (unsigned char)blk.buf[0] == 0xef &&
	    (unsigned char)blk.buf[1] == 0xbb &&
	    (unsigned char)blk.buf[2] == 0xbf) {
		offset = 3;
		curp->filenc &= ~MPARSE_LATIN1;
	} else
		offset = 0;

	mparse_buf_r(curp, blk, offset, 1);

	if (--recursion_depth == 0)
		mparse_end(curp);

	curp->primary = svprimary;
	curp->file = svfile;
}

/*
 * Read the whole file into memory and call the parsers.
 * Called recursively when an .so request is encountered.
 */
enum mandoclevel
mparse_readfd(struct mparse *curp, int fd, const char *file)
{
	struct buf	 blk;
	int		 with_mmap;
	int		 save_filenc;

	if (read_whole_file(curp, file, fd, &blk, &with_mmap)) {
		save_filenc = curp->filenc;
		curp->filenc = curp->options &
		    (MPARSE_UTF8 | MPARSE_LATIN1);
		mparse_parse_buffer(curp, blk, file);
		curp->filenc = save_filenc;
		if (with_mmap)
			munmap(blk.buf, blk.sz);
		else
			free(blk.buf);
	}
	return curp->file_status;
}

int
mparse_open(struct mparse *curp, const char *file)
{
	char		 *cp;
	int		  fd;

	curp->file = file;
	cp = strrchr(file, '.');
	curp->gzip = (cp != NULL && ! strcmp(cp + 1, "gz"));

	/* First try to use the filename as it is. */

	if ((fd = open(file, O_RDONLY)) != -1)
		return fd;

	/*
	 * If that doesn't work and the filename doesn't
	 * already  end in .gz, try appending .gz.
	 */

	if ( ! curp->gzip) {
		mandoc_asprintf(&cp, "%s.gz", file);
		fd = open(cp, O_RDONLY);
		free(cp);
		if (fd != -1) {
			curp->gzip = 1;
			return fd;
		}
	}

	/* Neither worked, give up. */

	mandoc_msg(MANDOCERR_FILE, curp, 0, 0, strerror(errno));
	return -1;
}

struct mparse *
mparse_alloc(int options, enum mandocerr mmin, mandocmsg mmsg,
    enum mandoc_os os_e, const char *os_s)
{
	struct mparse	*curp;

	curp = mandoc_calloc(1, sizeof(struct mparse));

	curp->options = options;
	curp->mmin = mmin;
	curp->mmsg = mmsg;
	curp->os_s = os_s;

	curp->roff = roff_alloc(curp, options);
	curp->man = roff_man_alloc(curp->roff, curp, curp->os_s,
		curp->options & MPARSE_QUICK ? 1 : 0);
	if (curp->options & MPARSE_MDOC) {
		curp->man->macroset = MACROSET_MDOC;
		if (curp->man->mdocmac == NULL)
			curp->man->mdocmac = roffhash_alloc(MDOC_Dd, MDOC_MAX);
	} else if (curp->options & MPARSE_MAN) {
		curp->man->macroset = MACROSET_MAN;
		if (curp->man->manmac == NULL)
			curp->man->manmac = roffhash_alloc(MAN_TH, MAN_MAX);
	}
	curp->man->first->tok = TOKEN_NONE;
	curp->man->meta.os_e = os_e;
	return curp;
}

void
mparse_reset(struct mparse *curp)
{
	roff_reset(curp->roff);
	roff_man_reset(curp->man);

	free(curp->sodest);
	curp->sodest = NULL;

	if (curp->secondary)
		curp->secondary->sz = 0;

	curp->file_status = MANDOCLEVEL_OK;
	curp->gzip = 0;
}

void
mparse_free(struct mparse *curp)
{

	roffhash_free(curp->man->mdocmac);
	roffhash_free(curp->man->manmac);
	roff_man_free(curp->man);
	roff_free(curp->roff);
	if (curp->secondary)
		free(curp->secondary->buf);

	free(curp->secondary);
	free(curp->sodest);
	free(curp);
}

void
mparse_result(struct mparse *curp, struct roff_man **man,
	char **sodest)
{

	if (sodest && NULL != (*sodest = curp->sodest)) {
		*man = NULL;
		return;
	}
	if (man)
		*man = curp->man;
}

void
mparse_updaterc(struct mparse *curp, enum mandoclevel *rc)
{
	if (curp->file_status > *rc)
		*rc = curp->file_status;
}

void
mandoc_vmsg(enum mandocerr t, struct mparse *m,
		int ln, int pos, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);

	mandoc_msg(t, m, ln, pos, buf);
}

void
mandoc_msg(enum mandocerr er, struct mparse *m,
		int ln, int col, const char *msg)
{
	enum mandoclevel level;

	if (er < m->mmin && er != MANDOCERR_FILE)
		return;

	level = MANDOCLEVEL_UNSUPP;
	while (er < mandoclimits[level])
		level--;

	if (m->mmsg)
		(*m->mmsg)(er, level, m->file, ln, col, msg);

	if (m->file_status < level)
		m->file_status = level;
}

const char *
mparse_strerror(enum mandocerr er)
{

	return mandocerrs[er];
}

const char *
mparse_strlevel(enum mandoclevel lvl)
{
	return mandoclevels[lvl];
}

void
mparse_keep(struct mparse *p)
{

	assert(NULL == p->secondary);
	p->secondary = mandoc_calloc(1, sizeof(struct buf));
}

const char *
mparse_getkeep(const struct mparse *p)
{

	assert(p->secondary);
	return p->secondary->sz ? p->secondary->buf : NULL;
}
@


1.157
log
@add warning "cross reference to self"; inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.156 2017/07/01 09:47:23 schwarze Exp $ */
d117 1
@


1.156
log
@Basic reporting of .Xrs to manual pages that don't exist
in the base system, inspired by mdoclint(1).

We are able to do this because (1) the -mdoc parser, the -Tlint validator,
and the man(1) manual page lookup code are all in the same program
and (2) the mandoc.db(5) database format allows fast lookup.

Feedback from, previous versions tested by, and OK jmc@@.

A few features will be added to this in the tree, step by step.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.155 2017/06/29 15:21:46 schwarze Exp $ */
d138 1
@


1.155
log
@warn about some non-portable idioms in .Bl -column;
triggered by a question from Yuri Pankov (illumos)
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.154 2017/06/25 17:42:37 schwarze Exp $ */
d92 1
@


1.154
log
@Catch typos in .Sh names; suggested by jmc@@.

I'm using a very simple, linear time / zero space fuzzy string
matching heuristic rather than a full Levenshtein metric, to keep
the code both simple and fast.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.153 2017/06/24 18:58:09 schwarze Exp $ */
d150 1
d169 1
@


1.153
log
@operating system dependent message about unknown architecture;
inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.152 2017/06/24 15:59:28 schwarze Exp $ */
d97 1
@


1.152
log
@in the base system, suggest leaving .Os blank; inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.151 2017/06/24 14:38:28 schwarze Exp $ */
d89 1
@


1.151
log
@Split -Wstyle into -Wstyle and the even lower -Wbase, and add
-Wopenbsd and -Wnetbsd to check conventions for the base system of
a specific operating system.  Mark operating system specific messages
with "(OpenBSD)" at the end.

Please use just "-Tlint" to check base system manuals (defaulting
to -Wall, which is now -Wbase), but prefer "-Tlint -Wstyle" for the
manuals of portable software projects you maintain that are not
part of OpenBSD base, to avoid bogus recommendations about base
system conventions that do not apply.

Issue originally reported by semarie@@, solution using
an idea from tedu@@, discussed with jmc@@ and jca@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.150 2017/06/17 23:06:43 schwarze Exp $ */
d89 1
@


1.150
log
@style message about duplicate RCS ids; inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.149 2017/06/17 22:40:27 schwarze Exp $ */
d52 1
a52 1
	const char	 *defos; /* default operating system */
d55 1
a55 1
	enum mandoclevel  wlevel; /* ignore messages below this */
d85 1
a85 1
	"generic style suggestion",
d89 4
a93 1
	"RCS id missing",
d744 2
a745 2
mparse_alloc(int options, enum mandoclevel wlevel, mandocmsg mmsg,
    const char *defos)
d752 1
a752 1
	curp->wlevel = wlevel;
d754 1
a754 1
	curp->defos = defos;
d757 1
a757 1
	curp->man = roff_man_alloc( curp->roff, curp, curp->defos,
d769 1
d845 3
a850 3

	if (level < m->wlevel && er != MANDOCERR_FILE)
		return;
@


1.149
log
@style message about missing RCS ids; inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.148 2017/06/11 19:36:31 schwarze Exp $ */
d91 1
@


1.148
log
@Style message about legacy man(7) date format in mdoc(7) documents
and operating system dependent messages about missing or unexpected
Mdocdate; inspired by mdoclint(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.147 2017/06/11 17:16:36 schwarze Exp $ */
d90 1
@


1.147
log
@style message about missing .Fn markup; inspired by mdoclint
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.146 2017/06/10 01:48:31 schwarze Exp $ */
d87 3
@


1.146
log
@style message about missing blank before trailing delimiter;
inspired by mdoclint(1), and jmc@@ considers it useful
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.145 2017/06/08 00:21:23 schwarze Exp $ */
d93 1
@


1.145
log
@Portable mandoc just got a warning about unknown .Lb names
which we don't want in OpenBSD, but let's keep the message table
and the manual page in sync.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.144 2017/06/07 23:29:31 schwarze Exp $ */
d92 1
@


1.144
log
@style checks related to .Er; inspired by mdoclint(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.143 2017/06/06 15:00:56 schwarze Exp $ */
d176 1
@


1.143
log
@Minimal implementation of the roff(7) .ce request (center a number
of input lines without filling).
Contrary to groff, high-level macros abort .ce mode for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.142 2017/06/04 00:08:56 schwarze Exp $ */
d89 2
@


1.142
log
@Pure preprocessor implementation of the roff(7) .ec and .eo requests
(escape character control), touching nothing after the preprocessing
stage and keeping even the state variable local to the preprocessor.
Since the escape character is also used for line continuation, this
requires pulling the implementation of line continuation from the
input reader to the preprocessor, which also considerably shortens
the code required for that.

When the escape character is changed, simply let the preprocessor
replace bare by escaped backslashes and instances of the non-standard
escape character with bare backslashes - that's all we need.

Oh, and if anybody dares to use these requests in OpenBSD manuals,
sending a medium-sized pack of axe-murderes after them might be a
worthwhile part of the punishment, but probably insuffient on its own.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.141 2017/06/03 15:54:09 schwarze Exp $ */
d226 1
@


1.141
log
@ignore blank lines in man(7) next line scope;
strange groff edge case behaviour found in multimedia/mjpegtools
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.140 2017/06/01 15:24:41 schwarze Exp $ */
a324 1
	size_t		 j;  /* auxiliary byte number in the blk buffer */
a405 67
			/* Trailing backslash = a plain char. */

			if (blk.buf[i] != '\\' || i + 1 == blk.sz) {
				ln.buf[pos++] = blk.buf[i++];
				continue;
			}

			/*
			 * Found escape and at least one other character.
			 * When it's a newline character, skip it.
			 * When there is a carriage return in between,
			 * skip that one as well.
			 */

			if ('\r' == blk.buf[i + 1] && i + 2 < blk.sz &&
			    '\n' == blk.buf[i + 2])
				++i;
			if ('\n' == blk.buf[i + 1]) {
				i += 2;
				++lnn;
				continue;
			}

			if ('"' == blk.buf[i + 1] || '#' == blk.buf[i + 1]) {
				j = i;
				i += 2;
				/* Comment, skip to end of line */
				for (; i < blk.sz; ++i) {
					if (blk.buf[i] != '\n')
						continue;
					if (blk.buf[i - 1] == ' ' ||
					    blk.buf[i - 1] == '\t')
						mandoc_msg(
						    MANDOCERR_SPACE_EOL,
						    curp, curp->line,
						    pos + i-1 - j, NULL);
					++i;
					++lnn;
					break;
				}

				/* Backout trailing whitespaces */
				for (; pos > 0; --pos) {
					if (ln.buf[pos - 1] != ' ')
						break;
					if (pos > 2 && ln.buf[pos - 2] == '\\')
						break;
				}
				break;
			}

			/* Catch escaped bogus characters. */

			c = (unsigned char) blk.buf[i+1];

			if ( ! (isascii(c) &&
			    (isgraph(c) || isblank(c)))) {
				mandoc_vmsg(MANDOCERR_CHAR_BAD, curp,
				    curp->line, pos, "0x%x", c);
				i += 2;
				ln.buf[pos++] = '?';
				continue;
			}

			/* Some other escape sequence, copy & cont. */

			ln.buf[pos++] = blk.buf[i++];
d409 1
a409 1
		if (pos >= ln.sz)
d412 2
@


1.140
log
@STYLE message about full stop at the end of .Nd; inspired by mdoclint(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.139 2017/05/31 15:30:12 schwarze Exp $ */
d138 1
@


1.139
log
@STYLE message about missing use of Ox/Nx/Fx/Dx; OK jmc@@ wiz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.138 2017/05/30 19:29:31 schwarze Exp $ */
d89 1
@


1.138
log
@STYLE message about useless macros we don't want (Bt Tn Ud);
not a WARNING because they don't endanger portability
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.137 2017/05/16 19:05:36 schwarze Exp $ */
d88 1
@


1.137
log
@Introduce a new mandoc(1) message level, -W style, below -W warning.
Switch -W all from meaning -W warning to meaning -W style.
The meaning of -T lint does *not* change, it still implies -W warning.
No messages on the new level yet, but they will come.

Usually, i do not lightly make the user interface larger.
But this has been planned for years, and EXIT STATUS 1
was reserved for it all the time.  The message system
is now stable enough to finally implement it.

jmc@@ regarding the concept: "really good idea"
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.136 2017/04/29 12:43:55 schwarze Exp $ */
d86 3
@


1.136
log
@Parser unification: use nice ohashes for all three request and macro tables;
no functional change, minus two source files, minus 200 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.135 2017/03/07 20:00:02 schwarze Exp $ */
d74 1
a74 1
	MANDOCERR_WARNING,
d85 1
d241 1
a241 1
	"RESERVED",
@


1.135
log
@If a user-defined macro is aborted because it exceeds the stack
limit, usually due to infinite recursion, discard whatever remains
in all those open stack levels.  Otherwise, insane constructions
like the following could generate macros of enormous size, causing
mandoc(1) to die from memory exhaustion:

.de m  \" original macro definition
.m     \" recursion to blow up the stack
.de m  \" definition to be run during the call of .m marked (*)
very long plain text (some kilobytes)
.m     \" expand the above a thousand times while unwinding the stack
..     \" end of the original definition
.m     \" (*) recursively generate a ridiculously large macro
..     \" end of recursively generated definition
.m     \" execute the giant macro, exhausting memory

Very creative abuse found by tb@@ with afl(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.134 2017/03/06 17:25:24 schwarze Exp $ */
a291 1
		mdoc_hash_init();
d293 2
a294 1
		curp->man->first->tok = TOKEN_NONE;
a295 1
		man_hash_init();
d297 2
a298 1
		curp->man->first->tok = TOKEN_NONE;
d300 1
a804 1
		mdoc_hash_init();
d806 2
a808 1
		man_hash_init();
d810 2
d837 2
@


1.134
log
@Using .Nd only makes sense in the NAME section.
Warn if that macro occurs elsewhere.
Triggered by a question from Dag-Erling Smoergrav <des @@ FreeBSD>.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.133 2017/02/03 18:18:08 schwarze Exp $ */
d65 1
a65 1
static	void	  mparse_buf_r(struct mparse *, struct buf, size_t, int);
d309 1
a309 1
static void
d510 1
a510 3
			if (REPARSE_LIMIT >= ++curp->reparse_count)
				mparse_buf_r(curp, ln, of, 0);
			else
d513 7
a519 2
			pos = 0;
			continue;
d533 1
a533 1
				return;
d599 1
@


1.133
log
@Minor cleanup, no functional change:
We always have a roff parser, so mparse_free() does not need to check
for existence before freeing it.
Also arrange code in struct mparse, mparse_reset(), and mparse_free()
in the same order for readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.132 2017/02/03 17:55:36 schwarze Exp $ */
d112 1
@


1.132
log
@If an application parses multiple files with mparse_readfd(3) but
without using mparse_open(3) to open the files, and if one of the
files includes a gzip'ed file with .so, then the gzip flag remains
set and the next main file will be expected to be gzip'ed.
Fix this by clearing the gzip flag in mparse_reset(3).

Bug found and patch provided by Michael <Stapelberg at debian dot org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.131 2017/01/28 23:26:56 schwarze Exp $ */
d46 1
a47 1
	struct roff	 *roff; /* roff parser (!NULL) */
d814 4
a821 3

	free(curp->sodest);
	curp->sodest = NULL;
d830 1
a830 2
	if (curp->roff)
		roff_free(curp->roff);
@


1.131
log
@Add a warning "new sentence, new line".
This does not attempt to pinpoint each and every offender, but
instead tries very hard to avoid false positives: Currently, there
are only two false positives in the whole OpenBSD base system.
Only do this in mdoc(7), not in man(7), because manuals written
in man(7) typically have much worse problems than this.
OK jmc@@ on a previous version of the patch
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.130 2017/01/09 01:36:22 schwarze Exp $ */
d821 1
@


1.130
log
@Warnings and errors that occur during mdoc_validate()
or during man_validate() have to affect the mandoc(1) EXIT STATUS.
Many thanks to <Yuri dot Pankov at gmail dot com> (illumos developer)
for reporting this regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.129 2017/01/08 00:10:22 schwarze Exp $ */
d175 1
@


1.129
log
@Stricter validation of the NAME section, in particular:
- require a comma between names
- reject all other text nodes
- reject all empty Nm below NAME, not only in the leading position
- reject Nm after Nd
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.128 2016/12/28 17:21:17 schwarze Exp $ */
d848 7
@


1.128
log
@Make the second, section number argument of .Xr mandatory.
In fact, we have been requiring it for many years.
The only reason to not warn when it was missing
was excessive traditionalism - it was optional in 4.4BSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.127 2016/12/07 22:57:35 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2016 Ingo Schwarze <schwarze@@openbsd.org>
d106 1
a106 1
	"NAME section without name",
d110 1
@


1.127
log
@When reporting "whitespace at end of input line" on lines ending with
roff(7) comments, let the column number in the message point to the
end of the line rather than to the beginning of the comment.
Improvement suggested by bluhm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.126 2016/11/10 12:47:05 schwarze Exp $ */
d148 1
@


1.126
log
@warn about trailing whitespace at the end of comments;
missing feature noticed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.125 2016/10/09 18:16:46 schwarze Exp $ */
d313 1
d419 1
d430 1
a430 1
						    pos, NULL);
@


1.125
log
@Delete complicated code dealing with .Bl -tag without -width,
and just let it default to -width 6n, which agrees with the
traditional -width Ds that is still in widespread use.

I just pushed a patch upstream to GNU roff that does the same for
groff_mdoc(7).  Before, groff contained code that was even more
complicated than mandoc, but both resulted in quite different
user-visible output.  Now, both agree, and output is nicer for both.

Useless complication noticed by Carsten Kunze (Heirloom roff).
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.124 2016/07/19 16:22:34 schwarze Exp $ */
d421 11
a431 5
					if ('\n' == blk.buf[i]) {
						++i;
						++lnn;
						break;
					}
@


1.124
log
@Since the mdoc/man parser unification, the parser is always allocated
in mparse_alloc(), so delete all the curp->man == NULL checks.
Triggered by a patch from Christos Zoulas suggesting to add
yet another such check.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.123 2016/07/10 13:33:50 schwarze Exp $ */
d139 1
a139 1
	"missing -width in -tag list, using 8n",
@


1.123
log
@Fix a nasty typo that prevented .so links to gziped manuals
from working in the absence of a mandoc.db(5) database.
Found the hard way by Svyatoslav Mishyn on Crux Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.122 2016/01/08 02:53:09 schwarze Exp $ */
a286 7
	if (curp->man == NULL) {
		curp->man = roff_man_alloc(curp->roff, curp, curp->defos,
		    curp->options & MPARSE_QUICK ? 1 : 0);
		curp->man->macroset = MACROSET_MAN;
		curp->man->first->tok = TOKEN_NONE;
	}

d551 1
a551 9
		/*
		 * If input parsers have not been allocated, do so now.
		 * We keep these instanced between parsers, but set them
		 * locally per parse routine since we can use different
		 * parsers with each one.
		 */

		if (curp->man == NULL ||
		    curp->man->macroset == MACROSET_NONE)
a660 4

	if (curp->man == NULL && curp->sodest == NULL)
		curp->man = roff_man_alloc(curp->roff, curp, curp->defos,
		    curp->options & MPARSE_QUICK ? 1 : 0);
a800 1

d802 1
a802 3

	if (curp->man != NULL)
		roff_man_reset(curp->man);
@


1.122
log
@Simplify the mparse_open() interface.
Just return the file descriptor or -1 on error;
there is just one kind of error anyway.
Suggested by Christos Zoulas (NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.121 2016/01/08 02:13:35 schwarze Exp $ */
d776 1
a776 1
		fd = open(file, O_RDONLY);
@


1.121
log
@It was very surprising that a function called mparse_readfd()
closed the file descriptor passed to it after completing its work,
in particular considering the fact that it required its callers
to call open(2) or mparse_open() beforehand.

Change mparse_readfd() to not call close(2) and change the callers
to call close(2) afterwards, more or less bringing open and close
to the same level of the code and making review easier.  Note that
man.cgi(8) already did that, even though it was wrong in the past.

Small restructuring suggested by Christos Zoulas (NetBSD).
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.120 2015/10/30 19:03:36 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2015 Ingo Schwarze <schwarze@@openbsd.org>
d535 1
a535 2
			if (mparse_open(curp, &fd, ln.buf + of) ==
			    MANDOCLEVEL_OK) {
d754 2
a755 2
enum mandoclevel
mparse_open(struct mparse *curp, int *fd, const char *file)
d758 1
d766 2
a767 2
	if ((*fd = open(file, O_RDONLY)) != -1)
		return MANDOCLEVEL_OK;
d776 1
a776 1
		*fd = open(file, O_RDONLY);
d778 1
a778 1
		if (*fd != -1) {
d780 1
a780 1
			return MANDOCLEVEL_OK;
d787 1
a787 1
	return MANDOCLEVEL_ERROR;
@


1.120
log
@If a .Bd block has no arguments at all, drop the block and only keep
its contents.  Removing a gratuitious difference to groff output
found after a related bug report from krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.119 2015/10/13 22:57:49 schwarze Exp $ */
d538 1
a751 4

	if (fd != STDIN_FILENO && close(fd) == -1)
		perror(file);

@


1.119
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.118 2015/10/11 21:06:59 schwarze Exp $ */
d213 1
@


1.118
log
@Finally use __progname, err(3) and warn(3).
That's more readable and less error-prone than fumbling around
with argv[0], fprintf(3), strerror(3), perror(3), and exit(3).
It also shortens the code by 50 lines.

It's a bad idea to boycott good interfaces merely because standards
committees ignore them.  Instead, it's the job of the portable
distribution to provide compatibility modules for archaic systems
(like commercial Solaris) that still don't have them.  Actually,
the compat code for the portable distribution already exists and
will be committed right after this.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.117 2015/10/06 18:30:44 schwarze Exp $ */
a47 1
	const struct mchars *mchars; /* character table */
d794 1
a794 1
    const struct mchars *mchars, const char *defos)
d805 1
a805 2
	curp->mchars = mchars;
	curp->roff = roff_alloc(curp, curp->mchars, options);
@


1.117
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.116 2015/09/14 15:35:47 schwarze Exp $ */
d25 1
d610 2
a611 4
	if (-1 == fstat(fd, &st)) {
		perror(file);
		exit((int)MANDOCLEVEL_SYSERR);
	}
d633 2
a634 4
		if ((gz = gzdopen(fd, "rb")) == NULL) {
			perror(file);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d663 2
a664 4
		if (ssz == -1) {
			perror(file);
			exit((int)MANDOCLEVEL_SYSERR);
		}
@


1.116
log
@Remove the warning about children of .Vt blocks because actually,
.Vt type global_variable No = Dv defined_constant ;
is the best way to specify in the SYNOPSIS how a global variable
is initialized in the rare case where that matters.
Issue noticed by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.115 2015/07/19 05:59:07 schwarze Exp $ */
d624 1
a624 1
			return(0);
d630 1
a630 1
			return(1);
d664 1
a664 1
			return(1);
d675 1
a675 1
	return(0);
d760 1
a760 1
	return(curp->file_status);
d775 1
a775 1
		return(MANDOCLEVEL_OK);
d788 1
a788 1
			return(MANDOCLEVEL_OK);
d795 1
a795 1
	return(MANDOCLEVEL_ERROR);
d823 1
a823 1
	return(curp);
d909 1
a909 1
	return(mandocerrs[er]);
d915 1
a915 1
	return(mandoclevels[lvl]);
d931 1
a931 1
	return(p->secondary->sz ? p->secondary->buf : NULL);
@


1.115
log
@Do not fork and exec gunzip(1), just link with libz instead.
As discussed with deraadt@@, that's cleaner and will help tame(2).
Something like this was also suggested earlier by bapt at FreeBSD.
Minus 50 lines of code, deleting one interface function (mparse_wait),
no functional change intended.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.114 2015/04/19 14:25:05 schwarze Exp $ */
a126 1
	".Vt block has child macro",
@


1.114
log
@Unify some node handling functions that use TOKEN_NONE.
* mdoc_word_alloc(), man_word_alloc() -> roff_word_alloc()
* mdoc_word_append(), man_word_append() -> roff_word_append()
* mdoc_addspan(), man_addspan() -> roff_addtbl()
* mdoc_addeqn(), man_addeqn() -> roff_addeqn()
Minus 50 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.113 2015/04/19 13:59:37 schwarze Exp $ */
a21 1
#include <sys/wait.h>
a26 1
#include <signal.h>
d32 1
d57 1
a60 1
	pid_t		  child; /* the gunzip(1) process */
a323 1
	pid_t		 save_child;
a534 1
			save_child = curp->child;
a551 1
			curp->child = save_child;
d606 1
d622 1
a622 1
	if (S_ISREG(st.st_mode)) {
d634 8
d660 3
a662 1
		ssz = read(fd, fb->buf + (int)off, fb->sz - off);
a760 1
	mparse_wait(curp);
a766 2
	int		  pfd[2];
	int		  save_errno;
d770 2
d773 1
a773 1
	/* Unless zipped, try to just open the file. */
d775 2
a776 5
	if ((cp = strrchr(file, '.')) == NULL ||
	    strcmp(cp + 1, "gz")) {
		curp->child = 0;
		if ((*fd = open(file, O_RDONLY)) != -1)
			return(MANDOCLEVEL_OK);
d778 4
a781 1
		/* Open failed; try to append ".gz". */
d783 1
d785 1
a785 10
		file = cp;
	} else
		cp = NULL;

	/* Before forking, make sure the file can be read. */

	save_errno = errno;
	if (access(file, R_OK) == -1) {
		if (cp != NULL)
			errno = save_errno;
d787 3
a789 22
		*fd = -1;
		curp->child = 0;
		mandoc_msg(MANDOCERR_FILE, curp, 0, 0, strerror(errno));
		return(MANDOCLEVEL_ERROR);
	}

	/* Run gunzip(1). */

	if (pipe(pfd) == -1) {
		perror("pipe");
		exit((int)MANDOCLEVEL_SYSERR);
	}

	switch (curp->child = fork()) {
	case -1:
		perror("fork");
		exit((int)MANDOCLEVEL_SYSERR);
	case 0:
		close(pfd[0]);
		if (dup2(pfd[1], STDOUT_FILENO) == -1) {
			perror("dup");
			exit((int)MANDOCLEVEL_SYSERR);
a790 8
		signal(SIGPIPE, SIG_DFL);
		execlp("gunzip", "gunzip", "-c", file, NULL);
		perror("exec");
		exit((int)MANDOCLEVEL_SYSERR);
	default:
		close(pfd[1]);
		*fd = pfd[0];
		return(MANDOCLEVEL_OK);
a791 1
}
d793 1
a793 7
enum mandoclevel
mparse_wait(struct mparse *curp)
{
	int	  status;

	if (curp->child == 0)
		return(MANDOCLEVEL_OK);
d795 2
a796 16
	if (waitpid(curp->child, &status, 0) == -1) {
		perror("wait");
		exit((int)MANDOCLEVEL_SYSERR);
	}
	curp->child = 0;
	if (WIFSIGNALED(status)) {
		mandoc_vmsg(MANDOCERR_FILE, curp, 0, 0,
		    "gunzip died from signal %d", WTERMSIG(status));
		return(MANDOCLEVEL_ERROR);
	}
	if (WEXITSTATUS(status)) {
		mandoc_vmsg(MANDOCERR_FILE, curp, 0, 0,
		    "gunzip failed with code %d", WEXITSTATUS(status));
		return(MANDOCLEVEL_ERROR);
	}
	return(MANDOCLEVEL_OK);
@


1.113
log
@Decouple the token code for "no request or macro" from the individual
high-level parsers to allow further unification of functions that
only need to recognize this code, but that don't care about different
high-level macrosets beyond that.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.112 2015/04/18 17:28:08 schwarze Exp $ */
d41 1
d582 1
a582 1
		if (rr == ROFF_TBL) {
d584 4
a587 10
				if (curp->man->macroset == MACROSET_MDOC)
					mdoc_addspan(curp->man, span);
				else
					man_addspan(curp->man, span);
		} else if (rr == ROFF_EQN) {
			if (curp->man->macroset == MACROSET_MDOC)
				mdoc_addeqn(curp->man, roff_eqn(curp->roff));
			else
				man_addeqn(curp->man, roff_eqn(curp->roff));
		} else if ((curp->man->macroset == MACROSET_MDOC ?
@


1.112
log
@Unify {mdoc,man}_{alloc,reset,free}() into roff_man_{alloc,reset,free}().
Minus 80 lines of code, no functional change.
Written on the train from Koeln to Wolfsburg returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.111 2015/04/18 17:01:28 schwarze Exp $ */
d291 1
a291 1
		curp->man->first->tok = MDOC_MAX;
d297 1
a297 1
		curp->man->first->tok = MDOC_MAX;
d301 1
a301 1
		curp->man->first->tok = MAN_MAX;
a873 1
		curp->man->first->tok = MDOC_MAX;
a876 1
		curp->man->first->tok = MAN_MAX;
d878 1
@


1.111
log
@Move mdoc_hash_init() and man_hash_init() to libmandoc.h
and call them from mparse_alloc() and choose_parser(),
preparing unified allocation of struct roff_man.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.110 2015/04/18 16:34:03 schwarze Exp $ */
d287 7
a294 6
		if (curp->man == NULL)
			curp->man = mdoc_alloc(
			    curp->roff, curp, curp->defos,
			    MPARSE_QUICK & curp->options ? 1 : 0);
		else
			curp->man->macroset = MACROSET_MDOC;
d296 6
a301 1
		return;
a302 10

	/* Fall back to man(7) as a last resort. */

	if (curp->man == NULL)
		curp->man = man_alloc(
		    curp->roff, curp, curp->defos,
		    MPARSE_QUICK & curp->options ? 1 : 0);
	else
		curp->man->macroset = MACROSET_MAN;
	man_hash_init();
d682 1
a682 1
		curp->man = man_alloc(curp->roff, curp, curp->defos,
d869 2
a871 3
		curp->man = mdoc_alloc(
		    curp->roff, curp, curp->defos,
		    curp->options & MPARSE_QUICK ? 1 : 0);
d873 3
a875 5
	}
	if (curp->options & MPARSE_MAN) {
		curp->man = man_alloc(
		    curp->roff, curp, curp->defos,
		    curp->options & MPARSE_QUICK ? 1 : 0);
d877 2
a879 1

d889 2
a890 7
	if (curp->man != NULL) {
		if (curp->man->macroset == MACROSET_MDOC)
			mdoc_reset(curp->man);
		else
			man_reset(curp->man);
		curp->man->macroset = MACROSET_NONE;
	}
d904 1
a904 4
	if (curp->man->macroset == MACROSET_MDOC)
		mdoc_free(curp->man);
	if (curp->man->macroset == MACROSET_MAN)
		man_free(curp->man);
@


1.110
log
@Profit from the unified struct roff_man and reduce the number of
arguments of mparse_result() by one.  No functional change.
Written on the ICE Bruxelles-Koeln on the way back from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.109 2015/04/18 16:04:40 schwarze Exp $ */
d294 1
d306 1
d873 1
a873 1
	if (curp->options & MPARSE_MDOC)
d877 3
a879 1
	if (curp->options & MPARSE_MAN)
d883 2
@


1.109
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.108 2015/04/02 21:03:18 schwarze Exp $ */
a44 2
	struct roff_man	 *pman; /* persistent man parser */
	struct roff_man	 *pmdoc; /* persistent mdoc parser */
a45 1
	struct roff_man	 *mdoc; /* mdoc parser */
d288 2
a289 2
		if (NULL == curp->pmdoc)
			curp->pmdoc = mdoc_alloc(
d292 2
a293 2
		assert(curp->pmdoc);
		curp->mdoc = curp->pmdoc;
d299 2
a300 2
	if (NULL == curp->pman)
		curp->pman = man_alloc(
d303 2
a304 2
	assert(curp->pman);
	curp->man = curp->pman;
d570 2
a571 1
		if ( ! (curp->man || curp->mdoc))
d585 2
a586 2
				if (curp->man == NULL)
					mdoc_addspan(curp->mdoc, span);
d590 2
a591 2
			if (curp->man == NULL)
				mdoc_addeqn(curp->mdoc, roff_eqn(curp->roff));
d594 2
a595 2
		} else if ((curp->man == NULL ?
		    mdoc_parseln(curp->mdoc, curp->line, ln.buf, of) :
d683 8
a690 16
	if (curp->mdoc == NULL &&
	    curp->man == NULL &&
	    curp->sodest == NULL) {
		if (curp->options & MPARSE_MDOC)
			curp->mdoc = curp->pmdoc;
		else {
			if (curp->pman == NULL)
				curp->pman = man_alloc(
				    curp->roff, curp, curp->defos,
				    curp->options & MPARSE_QUICK ? 1 : 0);
			curp->man = curp->pman;
		}
	}
	if (curp->mdoc)
		mdoc_endparse(curp->mdoc);
	if (curp->man)
d872 1
a872 1
		curp->pmdoc = mdoc_alloc(
d876 1
a876 1
		curp->pman = man_alloc(
d889 7
a895 4
	if (curp->mdoc)
		mdoc_reset(curp->mdoc);
	if (curp->man)
		man_reset(curp->man);
a899 2
	curp->mdoc = NULL;
	curp->man = NULL;
d909 4
a912 4
	if (curp->pmdoc)
		mdoc_free(curp->pmdoc);
	if (curp->pman)
		man_free(curp->pman);
d924 2
a925 2
mparse_result(struct mparse *curp, struct roff_man **mdoc,
	struct roff_man **man, char **sodest)
a928 1
		*mdoc = NULL;
a931 2
	if (mdoc)
		*mdoc = curp->mdoc;
@


1.108
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.107 2015/03/17 07:32:21 schwarze Exp $ */
d45 4
a48 4
	struct man	 *pman; /* persistent man parser */
	struct mdoc	 *pmdoc; /* persistent mdoc parser */
	struct man	 *man; /* man parser */
	struct mdoc	 *mdoc; /* mdoc parser */
d933 2
a934 2
mparse_result(struct mparse *curp,
	struct mdoc **mdoc, struct man **man, char **sodest)
@


1.107
log
@When the user exits the pager before the pager has drained all input
from man(1), man(1) dies from SIGPIPE.  Exiting man(1) is fine in this
case, generating more output would be pointless, but without handling
SIGPIPE, the exit code from man(1) was wrong and csh(1) printed an
ugly message "Broken pipe".  Fix this by handling SIGPIPE explicitly.
Issue noticed by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.106 2015/03/11 13:04:10 schwarze Exp $ */
d11 1
a11 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d13 1
a13 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d35 1
d37 1
a37 2
#include "mandoc_aux.h"
#include "libmandoc.h"
d40 1
@


1.106
log
@Fix previous: size_t is often narrower than off_t.
Cluestick applied by joerg at NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.105 2015/03/10 14:17:22 schwarze Exp $ */
d28 1
d828 1
@


1.105
log
@The st_size member of struct stat is off_t, which is signed,
all required by POSIX.  So don't compare it against against
an unsigned constant.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.104 2015/03/02 14:48:31 schwarze Exp $ */
d633 1
a633 1
		if ((size_t)st.st_size >= (1U << 31)) {
@


1.104
log
@If a non-gz manual is read after a gzipped manual, refrain
from throwing a bogus error "wait: No child processes".
As reported by Baptiste Daroussin <bapt at FreeBSD dot org>,
clearing the state variable curp->child after use was forgotten.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.103 2015/02/23 13:30:02 schwarze Exp $ */
d633 1
a633 1
		if (st.st_size >= (1U << 31)) {
@


1.103
log
@improve NAME section diagnostics;
confusing messages reported by Jan Stary <hans at stare dot cz>
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.102 2015/02/20 22:40:05 schwarze Exp $ */
d849 1
@


1.102
log
@Completely delete all carriage return characters from the input.
No change to messages about them (ignore them right before line feeds,
report errors elsewhere).
naddy@@ found a manual in the wild containing lots of these (ysm(1)),
and i can't imagine a situation where dropping them could be problematic.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.101 2015/02/06 16:05:51 schwarze Exp $ */
d107 4
a110 1
	"bad NAME section contents",
@


1.101
log
@replace the last legacy generic message type, "argument count wrong",
by more specific messages, improving diagnostics for .cc .tr .Bl -column
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.100 2015/02/06 11:54:03 schwarze Exp $ */
d397 2
a398 1
				ln.buf[pos++] = '?';
@


1.100
log
@better error reporting regarding .OP .RS .UR .TH arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.99 2015/02/06 07:12:34 schwarze Exp $ */
d159 1
d166 1
a210 1
	"argument count wrong",
@


1.99
log
@Delete the legacy generic warning type MANDOCERR_ARGCWARN,
replacing the last instances by more specific warnings.
Improved functionality, minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.98 2015/02/06 03:31:11 schwarze Exp $ */
d148 2
@


1.98
log
@better handle .Fo and .Fd without argument
better handle .Fo with more than one argument
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.97 2015/02/04 18:03:28 schwarze Exp $ */
d134 1
a135 1
	"argument count wrong",
@


1.97
log
@discard .Rs head arguments and improve .Rs diagnostics
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.96 2015/02/04 16:38:31 schwarze Exp $ */
d140 1
@


1.96
log
@more specific .Nd diagnostics, allowing to get rid of enum check_lvl
and the respective argument of check_count()
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.95 2015/01/28 21:10:28 schwarze Exp $ */
d145 1
@


1.95
log
@Clean up eqn(7) error handling:
* When "define" fails, do not drop the whole equation.
* Free memory after "undef".
* Use standard mandoc error types instead of rolling our own.
* Delete obfuscating EQN_MSG() macro.
* Add function prototypes while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.94 2015/01/28 17:30:37 schwarze Exp $ */
d108 1
@


1.94
log
@* Polish tbl(7) error reporting.
* Do not print out macro names in tbl(7) data blocks.
* Like with GNU tbl, let empty tables cause a blank line.
* Avoid producing empty tables in -Tman.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.93 2015/01/26 18:41:45 schwarze Exp $ */
a174 6

	/* related to equations */
	"unexpected equation scope closure",
	"equation scope open on exit",
	"overlapping equation scopes",
	"unexpected end of equation",
@


1.93
log
@Rework tbl(7) layout parsing:
* Continue parsing even if part of the input is invalid.
* Do not require whitespace between cell specifications.
* Allow tabs as well as blanks between modifiers.
* Mark the 'm' modifier as unsupported.
* Parse and ignore the 'p' and 'v' modifiers.
* Better warning and error messages.
* Get rid of a static buffer.
Improved functionality but minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.92 2015/01/26 13:02:53 schwarze Exp $ */
d190 4
a193 4
	"no table data cells specified",
	"ignore data in cell",
	"data block still open",
	"ignoring extra data cells",
d227 1
a229 1
	"eqn in tbl",
@


1.92
log
@More improvements regarding tbl(7) options.
* Treat "allbox" as an alias for "box" for now.
* Parse and ignore the GNU tbl "nowarn" option.
* For separation, allow spaces, tabs, and commas only.
* Mark eqn(7) within tbl(7) as unsupported.
* Simplify the option table.
* Improve and sort documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.91 2015/01/26 00:54:09 schwarze Exp $ */
d169 5
d187 3
a189 1
	"no table layout cells specified",
d227 1
a227 1
	"unsupported table layout",
@


1.91
log
@Improve (or rather, rewrite) tbl(7) option parsing.
* Allow the layout to start after the semicolon on the options line.
* Ignore leading commas.
* Option arguments cannot contain closing parentheses.
* Avoid needless UNSUPP messages.
* Better ERROR reporting.
* Delete unused "linesize" field in struct tbl_opts.
* No need for static buffers.
* Garbage collect one almost empty wrapper function.
Improved functionality, but minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.90 2015/01/24 01:59:40 schwarze Exp $ */
d222 1
@


1.90
log
@Support .RE with an argument; needed for audio/pms(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.89 2015/01/22 21:36:44 schwarze Exp $ */
d178 4
a219 2
	"unsupported table syntax",
	"unsupported table option",
@


1.89
log
@Traditional roff(7) explicitly allows certain control characters
in the input stream (SOH, STX, ETX, ENQ, ACK, BEL, BS) for specific
purposes (leaders, backspace, delimiters, .tr), but making sure
these don't leak through to the output is tricky, so mark them as
unsupported for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.88 2015/01/22 19:26:16 schwarze Exp $ */
d193 1
@


1.88
log
@Don't let a failing mparse_open() clobber the filename pointer;
fixes error message content and a use after free
for .so with non-existent target when -Wall or -Tlint is given.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.87 2015/01/20 21:12:46 schwarze Exp $ */
d213 1
d368 2
a369 3
					mandoc_vmsg(MANDOCERR_BADCHAR,
					    curp, curp->line, pos,
					    "0x%x", c);
d381 4
a384 2
				mandoc_vmsg(MANDOCERR_BADCHAR, curp,
				    curp->line, pos, "0x%x", c);
d440 1
a440 1
				mandoc_vmsg(MANDOCERR_BADCHAR, curp,
@


1.87
log
@Split the -Werror message level into -Werror (broken manual, probably
using mandoc is better than using groff) and -Wunsupp (manual using
unsupported low-level roff(7) feature, probably using groff is better
than using mandoc).  Once this feature is complete, it is intended
to help porting, making the decision whether to USE_GROFF easier.

As a first step, distinguish four classes of roff(7) requests:
1. Supported (currently 24 requests)
2. Currently ignored because unimportant (120)  ->  no message
3. Ignored for good because insecure (14)  ->  -Werror
4. Currently unsupported (68)  ->  these trigger the new -Wunsupp messages
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.86 2015/01/15 04:26:06 schwarze Exp $ */
d305 1
d521 1
d524 1
a524 1
			    MANDOCLEVEL_OK)
d526 3
a528 1
			else {
@


1.86
log
@Fatal errors no longer exist.
If a file can be opened, mandoc will produce some output;
at worst, the output may be almost empty.
Simplifies error handling and frees a message type for future use.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.85 2015/01/15 02:29:07 schwarze Exp $ */
d78 1
a78 1
	MANDOCERR_MAX,
a177 3
	"bad table syntax",
	"bad table option",
	"bad table layout",
a182 1
	"ignoring macro in table",
a185 1
	"input too large",
d189 1
d210 8
d225 1
a225 1
	"FATAL",
d943 1
a943 1
	level = MANDOCLEVEL_ERROR;
@


1.85
log
@downgrade .so failure from FATAL to ERROR
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.84 2015/01/14 22:57:57 schwarze Exp $ */
d78 1
a78 1
	MANDOCERR_FATAL,
d190 1
a213 4

	"generic fatal error",

	"input too large",
a539 8
		 * If we encounter errors in the recursive parse, make
		 * sure we don't continue parsing.
		 */

		if (MANDOCLEVEL_FATAL <= curp->file_status)
			break;

		/*
d609 1
a609 4
			curp->file_status = MANDOCLEVEL_FATAL;
			if (curp->mmsg)
				(*curp->mmsg)(MANDOCERR_TOOLARGE,
				    curp->file_status, file, 0, 0, NULL);
d631 2
a632 5
				curp->file_status = MANDOCLEVEL_FATAL;
				if (curp->mmsg)
					(*curp->mmsg)(MANDOCERR_TOOLARGE,
					    curp->file_status,
					    file, 0, 0, NULL);
a657 3
	if (MANDOCLEVEL_FATAL <= curp->file_status)
		return;

d671 4
a674 11

	if (curp->mdoc && ! mdoc_endparse(curp->mdoc)) {
		assert(MANDOCLEVEL_FATAL <= curp->file_status);
		return;
	}

	if (curp->man && ! man_endparse(curp->man)) {
		assert(MANDOCLEVEL_FATAL <= curp->file_status);
		return;
	}

d711 1
a711 1
	if (0 == --recursion_depth && MANDOCLEVEL_FATAL > curp->file_status)
a842 2
	assert(wlevel <= MANDOCLEVEL_FATAL);

d939 1
a939 1
	level = MANDOCLEVEL_FATAL;
@


1.84
log
@downgrade ".so with absolute path" from FATAL to ERROR;
allows to get rid of ROFF_ERR
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.83 2015/01/14 22:02:00 schwarze Exp $ */
d209 1
a216 1
	".so request failed",
d304 1
d309 2
d519 5
a523 2
			mparse_readfd(curp, -1, ln.buf + of);
			if (MANDOCLEVEL_FATAL <= curp->file_status) {
d527 7
a533 1
				break;
d535 1
a745 2
 * If a file descriptor is given, use it and assume it points
 * to the named file.  Otherwise, open the named file.
a754 7
	pid_t		 save_child;

	save_child = curp->child;
	if (fd != -1)
		curp->child = 0;
	else if (mparse_open(curp, &fd, file) != MANDOCLEVEL_OK)
		goto out;
a771 2
out:
	curp->child = save_child;
@


1.83
log
@To get rid of SYSERR entries in enum mandocerr, downgrade problems with
missing and unreadable files from SYSERR to ERROR.
Needed for upcoming work.
As a bonus, this minimally simplifies code and documentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.82 2015/01/14 17:45:25 schwarze Exp $ */
d208 1
a215 1
	"NOT IMPLEMENTED: .so with absolute path or \"..\"",
a501 3
		case ROFF_ERR:
			assert(MANDOCLEVEL_FATAL <= curp->file_status);
			break;
@


1.82
log
@Simplify handling of system errors: just exit(3).
We already do the same for malloc(3) failure.
The is no virtue in trying to survive failure of fork(2) and the like.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.81 2014/12/28 14:39:08 schwarze Exp $ */
d189 1
a216 5

	/* system errors */
	"gunzip failed with code",
	NULL,
	"gunzip died from signal",
d752 1
a752 1
	else if (mparse_open(curp, &fd, file) >= MANDOCLEVEL_SYSERR)
a781 1
	enum mandocerr	  err;
a782 1
	pfd[1] = -1;
d806 5
a810 2
		err = MANDOCERR_SYSOPEN;
		goto out;
a837 12

out:
	free(cp);
	*fd = -1;
	curp->child = 0;
	curp->file_status = MANDOCLEVEL_SYSERR;
	if (curp->mmsg)
		(*curp->mmsg)(err, curp->file_status, curp->file,
		    0, 0, strerror(errno));
	if (pfd[1] != -1)
		exit(1);
	return(curp->file_status);
d853 3
a855 4
		mandoc_vmsg(MANDOCERR_SYSSIG, curp, 0, 0,
		    "%d", WTERMSIG(status));
		curp->file_status = MANDOCLEVEL_SYSERR;
		return(curp->file_status);
d858 3
a860 4
		mandoc_vmsg(MANDOCERR_SYSEXIT, curp, 0, 0,
		    "%d", WEXITSTATUS(status));
		curp->file_status = MANDOCLEVEL_SYSERR;
		return(curp->file_status);
d973 1
a973 1
	if (level < m->wlevel)
@


1.81
log
@mdoc(7) already uses the mandoc(1) -Ios argument in the footer line
when .Os has no argument, so do the same for man(7) when .TH has less
than four arguments; there is no reason to treat both differently.
Issue found following a question from Thomas Klausner <wiz at NetBSD>.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.80 2014/12/16 23:44:16 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2014 Ingo Schwarze <schwarze@@openbsd.org>
a217 2
	"cannot dup file descriptor",
	"cannot exec",
a218 1
	"cannot fork",
a219 2
	"cannot open pipe",
	"cannot read file",
a220 2
	"cannot stat file",
	"wait failed",
d601 2
a602 5
		curp->file_status = MANDOCLEVEL_SYSERR;
		if (curp->mmsg)
			(*curp->mmsg)(MANDOCERR_SYSSTAT, curp->file_status,
			    file, 0, 0, strerror(errno));
		return(0);
d654 2
a655 6
			curp->file_status = MANDOCLEVEL_SYSERR;
			if (curp->mmsg)
				(*curp->mmsg)(MANDOCERR_SYSREAD,
				    curp->file_status, file, 0, 0,
				    strerror(errno));
			break;
d819 2
a820 2
		err = MANDOCERR_SYSPIPE;
		goto out;
d825 2
a826 5
		err = MANDOCERR_SYSFORK;
		close(pfd[0]);
		close(pfd[1]);
		pfd[1] = -1;
		break;
d830 2
a831 2
			err = MANDOCERR_SYSDUP;
			break;
d834 2
a835 2
		err = MANDOCERR_SYSEXEC;
		break;
d864 2
a865 4
		mandoc_msg(MANDOCERR_SYSWAIT, curp, 0, 0,
		    strerror(errno));
		curp->file_status = MANDOCLEVEL_SYSERR;
		return(curp->file_status);
@


1.80
log
@Ignore mdoc(7) and man(7) macros inside tbl(7) code because they
would abort the table in an unclean way, causing assertion failures
found by jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.79 2014/11/30 05:28:00 schwarze Exp $ */
d296 2
a297 1
		curp->pman = man_alloc(curp->roff, curp,
d693 2
a694 1
				curp->pman = man_alloc(curp->roff, curp,
d923 2
a924 1
		curp->pman = man_alloc(curp->roff, curp,
@


1.79
log
@Multiple fixes with respect to .Pf:
* The first argument of .Pf is not parsed.
* Normal delimiter handling does not apply to the first argument of .Pf.
* Warn if nothing follows a prefix (inspired by groff_mdoc(7)).
* In that case, do not suppress spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.78 2014/11/30 02:31:32 schwarze Exp $ */
d186 1
@


1.78
log
@warn about attempts to call non-callable macros;
inspired by a similar warning in the groff_mdoc(7) macros
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.77 2014/11/28 18:07:38 schwarze Exp $ */
d143 1
@


1.77
log
@Drop useless architecture table.  Validating architecture names
is a job for makewhatis(8)/mandoc.db(5), not for the parser.
Removes 150 lines from source files and 4k (1%) from the binary.
Bloat found by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.76 2014/11/28 06:26:46 schwarze Exp $ */
d117 1
@


1.76
log
@Simplify by making the eqn and tbl steering functions void;
no functional change, minus 15 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.75 2014/11/27 23:35:03 schwarze Exp $ */
a93 1
	"unknown manual volume or arch",
@


1.75
log
@Downgrade .Bd -file from FATAL to ERROR.
Since this was the last remaining FATAL error in this area,
this change will allow major simplifications in the mdoc(7) parser.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.74 2014/11/26 23:27:13 schwarze Exp $ */
d314 1
a314 1
	int		 of, rc;
d567 15
a581 28
		rc = -1;

		if (ROFF_TBL == rr)
			while (NULL != (span = roff_span(curp->roff))) {
				rc = curp->man ?
				    man_addspan(curp->man, span) :
				    mdoc_addspan(curp->mdoc, span);
				if (0 == rc)
					break;
			}
		else if (ROFF_EQN == rr)
			rc = curp->mdoc ?
			    mdoc_addeqn(curp->mdoc,
				roff_eqn(curp->roff)) :
			    man_addeqn(curp->man,
				roff_eqn(curp->roff));
		else if (curp->man || curp->mdoc)
			rc = curp->man ?
			    man_parseln(curp->man,
				curp->line, ln.buf, of) :
			    mdoc_parseln(curp->mdoc,
				curp->line, ln.buf, of);

		if (0 == rc) {
			assert(MANDOCLEVEL_FATAL <= curp->file_status);
			break;
		} else if (2 == rc)
			break;
@


1.74
log
@Let mparse_readfd() use mparse_open() and mparse_wait()
and let mparse_open() fall back to .gz files
such that .so works even when the target is zipped,
requested by and in part using ideas from <bapt at FreeBSD>.
While here, make sure files are readable before forking,
both for efficiency and for better error reporting.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.73 2014/11/26 21:40:11 schwarze Exp $ */
d199 1
a211 1
	"NOT IMPLEMENTED: Bd -file",
@


1.73
log
@Simplify the mparse_open()/mparse_wait() interface.
Don't bother the user with the PID of the child process,
store it inside the opaque mparse handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.72 2014/11/01 06:02:43 schwarze Exp $ */
d762 6
d774 1
d776 5
a780 15
	if (-1 == fd && -1 == (fd = open(file, O_RDONLY, 0))) {
		curp->file_status = MANDOCLEVEL_SYSERR;
		if (curp->mmsg)
			(*curp->mmsg)(MANDOCERR_SYSOPEN,
			    curp->file_status,
			    file, 0, 0, strerror(errno));
		return(curp->file_status);
	}

	/*
	 * Run for each opened file; may be called more than once for
	 * each full parse sequence if the opened file is nested (i.e.,
	 * from `so').  Simply sucks in the whole file and moves into
	 * the parse phase for the file.
	 */
d794 1
a794 1
	if (STDIN_FILENO != fd && -1 == close(fd))
d797 3
d807 1
d813 3
d819 18
a836 5
		if ((*fd = open(file, O_RDONLY)) == -1) {
			err = MANDOCERR_SYSOPEN;
			goto out;
		}
		return(MANDOCLEVEL_OK);
d839 2
d869 1
d874 1
a874 1
		(*curp->mmsg)(err, curp->file_status, file,
@


1.72
log
@Use struct buf in libroff, it is very natural there
and reduces the number of arguments of many functions.
While here, sprinkle some KNF.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.71 2014/11/01 04:07:25 schwarze Exp $ */
d61 1
d804 1
a804 2
mparse_open(struct mparse *curp, int *fd, const char *file,
	pid_t *child_pid)
d814 1
a814 1
		*child_pid = 0;
d827 1
a827 1
	switch (*child_pid = fork()) {
d851 1
a851 1
	*child_pid = 0;
d862 1
a862 1
mparse_wait(struct mparse *curp, pid_t child_pid)
d866 4
a869 1
	if (waitpid(child_pid, &status, 0) == -1) {
@


1.71
log
@Refactor, no functional change: Remove the parse point from struct buf.
Some functions need multiple parse points, some none at all,
and it varies whether any of them need to be passed around.
So better pass them as a separate argument, and only when needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.70 2014/10/30 00:05:02 schwarze Exp $ */
d490 1
a490 2
		rr = roff_parseln(curp->roff, curp->line,
		    &ln.buf, &ln.sz, of, &of);
@


1.70
log
@support UTF-8 and ISO-8859-1 input by integrating modified parts
of kristaps@@' version of the preconv(1) utility into mandoc(1);
positive feedback from bentley@@ and no concern raised when shown on tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.69 2014/10/28 17:35:42 schwarze Exp $ */
d65 1
a65 1
static	void	  mparse_buf_r(struct mparse *, struct buf, int);
d300 5
a304 3
 * Main parse routine for an opened file.  This is called for each
 * opened file and simply loops around the full input file, possibly
 * nesting (i.e., with `so').
d307 1
a307 1
mparse_buf_r(struct mparse *curp, struct buf blk, int start)
d311 1
d313 1
a313 2
	int		 i, of, rc;
	int		 pos; /* byte number in the ln buffer */
d317 1
a317 1
	memset(&ln, 0, sizeof(struct buf));
d322 1
a322 1
	for (i = blk.offs; i < (int)blk.sz; ) {
d332 2
a333 4
			    curp->filenc & MPARSE_LATIN1) {
				blk.offs = i;
				curp->filenc = preconv_cue(&blk);
			}
d336 1
a336 1
		while (i < (int)blk.sz && (start || '\0' != blk.buf[i])) {
d344 1
a344 1
			if ('\r' == blk.buf[i] && i + 1 < (int)blk.sz &&
d358 1
a358 1
			if (pos + 11 > (int)ln.sz)
d367 2
a368 7
				blk.offs = i;
				ln.offs = pos;
				if (curp->filenc && preconv_encode(
				    &blk, &ln, &curp->filenc)) {
					pos = ln.offs;
					i = blk.offs;
				} else {
d392 1
a392 1
			if ('\\' != blk.buf[i] || i + 1 == (int)blk.sz) {
d404 1
a404 1
			if ('\r' == blk.buf[i + 1] && i + 2 < (int)blk.sz &&
d416 1
a416 1
				for (; i < (int)blk.sz; ++i) {
d453 1
a453 1
		if (pos >= (int)ln.sz)
d496 1
a496 1
				mparse_buf_r(curp, ln, 0);
d503 1
a503 1
			pos = (int)strlen(ln.buf);
d514 2
a515 2
			if (0 == (MPARSE_SO & curp->options) &&
			    (i >= (int)blk.sz || '\0' == blk.buf[i])) {
a640 1
		fb->offs = 0;
a670 1
			fb->offs = 0;
d727 1
d748 1
a748 1
		blk.offs = 3;
d750 2
a751 1
	}
d753 1
a753 1
	mparse_buf_r(curp, blk, 1);
@


1.69
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.68 2014/10/20 19:21:31 schwarze Exp $ */
a41 5
struct	buf {
	char		 *buf; /* binary input buffer */
	size_t		  sz; /* size of binary buffer */
};

d58 1
d320 1
a320 1
	for (i = 0; i < (int)blk.sz; ) {
d327 7
d354 2
a355 3
			 * Make sure we have space for at least
			 * one backslash and one other character
			 * and the trailing NUL byte.
d358 1
a358 1
			if (pos + 2 >= (int)ln.sz)
d362 1
a362 6
			 * Warn about bogus characters.  If you're using
			 * non-ASCII encoding, you're screwing your
			 * readers.  Since I'd rather this not happen,
			 * I'll be helpful and replace these characters
			 * with "?", so we don't display gibberish.
			 * Note to manual writers: use special characters.
d365 21
a385 1
			c = (unsigned char) blk.buf[i];
d387 1
a387 2
			if ( ! (isascii(c) &&
			    (isgraph(c) || isblank(c)))) {
d646 1
d677 1
d749 9
d772 1
d791 3
d795 1
@


1.68
log
@protect the roff parser from dividing by zero;
issue found and patch written by kristaps@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.67 2014/10/18 15:46:16 schwarze Exp $ */
d53 1
d862 2
a863 2
mparse_alloc(int options, enum mandoclevel wlevel,
		mandocmsg mmsg, const char *defos)
d876 2
a877 1
	curp->roff = roff_alloc(curp, options);
@


1.67
log
@plug file descriptor leaks on read or write failure;
hinted at by Steffen Nurpmeso <sdaoden at yandex dot com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.66 2014/10/12 19:10:56 schwarze Exp $ */
d208 1
@


1.66
log
@Improve error handling in the eqn(7) parser.
Get rid of the first fatal error, MANDOCERR_EQNSYNT.
In eqn(7), there is no need to be bug-compatible with groff, so there
is no need to abondon the whole equation in case of a syntax error.

In particular:
* Skip "back", "delim", "down", "fwd", "gfont", "gsize", "left",
  "right", "size", and "up" without arguments.
* Skip "gsize" and "size" with a non-numeric argument.
* Skip closing delimiters that are not open.
* Skip "above" outside piles.
* For diacritic marks and binary operators without a left operand,
  default to an empty box.
* Let piles and matrices take one argument rather than insisting
  on a braced list.  Let HTML output handle that, too.
* When rewinding, if the root box is guaranteed to match
  the termination condition, no error handling is needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.65 2014/10/11 21:14:11 schwarze Exp $ */
d750 1
a750 1
		goto out;
d760 7
a766 9
	if ( ! read_whole_file(curp, file, fd, &blk, &with_mmap))
		goto out;

	mparse_parse_buffer(curp, blk, file);

	if (with_mmap)
		munmap(blk.buf, blk.sz);
	else
		free(blk.buf);
d770 1
a770 1
out:
@


1.65
log
@warn about parentheses in function names after .Fn and .Fo;
particularly useful when converting from other languages to mdoc(7);
feature suggested by bentley@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.64 2014/09/12 00:53:21 schwarze Exp $ */
d146 1
a176 1
	"equation syntax error",
@


1.64
log
@warn about commas in function arguments; inspired by mdoclint(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.63 2014/09/11 23:52:47 schwarze Exp $ */
d156 1
@


1.63
log
@warn about botched .Xr ordering and punctuation below SEE ALSO;
inspired by mdoclint(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.62 2014/09/07 23:24:33 schwarze Exp $ */
d155 1
@


1.62
log
@warn about AUTHORS sections without .An macros, inspired by mdoclint(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.61 2014/09/07 02:17:36 schwarze Exp $ */
d114 2
@


1.61
log
@always use the right buffer, and fix one evil typo
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.60 2014/09/06 23:24:27 schwarze Exp $ */
d114 1
@


1.60
log
@Simplify by handling empty request lines at the one logical place
in the roff parser instead of in three other places in other parsers.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.59 2014/09/06 22:38:35 schwarze Exp $ */
d259 1
a259 1
			if (*cp == '.' || *cp != '\'') {
d707 1
d719 1
d729 1
@


1.59
log
@Move main format autodetection from the parser dispatcher to the
roff parser where .Dd and .TH are already detected, anyway.  This
improves robustness because it correctly handles whitespace or an
alternate control character before Dd.  In the parser dispatcher,
provide a fallback looking ahead in the input buffer instead of
always assuming man(7).  This corrects autodetection when Dd is
preceded by other macros or macro-like handled requests like .ll.

Triggered by reports from Daniel Levai about issues on Slackware Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.58 2014/09/03 23:20:33 schwarze Exp $ */
d66 1
a68 1
static	void	  pset(const char *, int, struct mparse *);
d244 1
a244 1
pset(const char *buf, int pos, struct mparse *curp)
a247 9
	int		 i;

	if ('.' == buf[0] || '\'' == buf[0]) {
		for (i = 1; buf[i]; i++)
			if (' ' != buf[i] && '\t' != buf[i])
				break;
		if ('\0' == buf[i])
			return;
	}
d538 1
a538 1
			pset(ln.buf + of, pos - of, curp);
d541 1
a541 3
		 * Lastly, push down into the parsers themselves.  One
		 * of these will have already been set in the pset()
		 * routine.
@


1.58
log
@Add *.gz support to apropos(1) -a, manm(1), and even mandoc(1).
Implemented by moving the zip code from makewhatis(8) to the parser lib.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a47 4
	enum mandoclevel  file_status; /* status of current parse */
	enum mandoclevel  wlevel; /* ignore messages below this */
	int		  line; /* line number in the file */
	int		  options; /* parser options */
d54 8
d63 1
a63 4
	mandocmsg	  mmsg; /* warning/error message handler */
	const char	 *file;
	struct buf	 *secondary;
	const char	 *defos; /* default operating system */
d246 2
a249 11
	/*
	 * Try to intuit which kind of manual parser should be used.  If
	 * passed in by command-line (-man, -mdoc), then use that
	 * explicitly.  If passed as -mandoc, then try to guess from the
	 * line: either skip dot-lines, use -mdoc when finding `.Dt', or
	 * default to -man, which is more lenient.
	 *
	 * Separate out pmdoc/pman from mdoc/man: the first persists
	 * through all parsers, while the latter is used per-parse.
	 */

d258 26
a283 6
	if (MPARSE_MDOC & curp->options) {
		curp->mdoc = curp->pmdoc;
		return;
	} else if (MPARSE_MAN & curp->options) {
		curp->man = curp->pman;
		return;
d286 1
a286 1
	if (pos >= 3 && 0 == memcmp(buf, ".Dd", 3))  {
d296 2
d729 1
@


1.57
log
@Bring the handling of defective prologues even closer to groff,
in particular relaxing the distinction between prologue and body
and further improving messages.
* The last .Dd wins and the last .Os wins, even in the body.
* The last .Dt before the first body macro wins.
* Missing title in .Dt defaults to UNTITLED.  Warn about it.
* Missing section in .Dt does not default to 1.  But warn about it.
* Do not warn multiple times about the same mdoc(7) prologue macro.
* Warn about missing .Os.
* Incomplete .TH defaults to empty strings.  Warn about it.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.56 2014/08/08 15:54:10 schwarze Exp $ */
d19 2
d22 1
a22 1
#include <sys/mman.h>
d211 4
d216 3
d220 1
a220 1
	"cannot read file",
d762 85
@


1.56
log
@mention requests and macros in more messages
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.55 2014/08/08 15:48:43 schwarze Exp $ */
d88 2
a89 1
	"missing .TH macro, using \"unknown 1\"",
d91 1
d96 4
a100 3
	"duplicate prologue macro",
	"incomplete prologue, terminated by",
	"skipping prologue macro in body",
@


1.55
log
@Dynamically allocate the stack of roff(7) .ie condition values
and thus get rid of the last useless fatal error.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.54 2014/08/08 15:45:58 schwarze Exp $ */
d118 2
a119 2
	"fill mode already enabled, skipping .fi",
	"fill mode already disabled, skipping .nf",
d131 1
a131 1
	"missing name for .Ex, using \"\"",
d201 1
a201 1
	"NOT IMPLEMENTED: .Bd -file",
d348 2
a349 2
				mandoc_msg(MANDOCERR_BADCHAR, curp,
				    curp->line, pos, NULL);
d405 2
a406 2
				mandoc_msg(MANDOCERR_BADCHAR, curp,
				    curp->line, pos, NULL);
@


1.54
log
@Split MANDOCERR_IGNARGV into one message for .An and one for .Bl
and report the macro name and argument.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.53 2014/08/08 15:42:39 schwarze Exp $ */
a203 1
	"static buffer exhausted",
@


1.53
log
@In .Bl -column, if some of the column width declarations are given
right after the -column argument and some at the very end of the
argument list, after some other arguments like -compact, concatenate
the column lists.
This gets rid of one of the last useless FATAL errors
and actually shortens the code by a few lines.

This fixes an issue introduced more than five years ago, at first
causing an assert() since bsd.lv mdoc_action.c rev. 1.14 (June 17, 2009),
then later a FATAL error since mdoc_validate rev. 1.130 (Nov. 30, 2010),
and marked as "TODO" ever since.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.52 2014/08/08 15:38:46 schwarze Exp $ */
a138 1
	"skipping argument",
d141 1
d144 1
@


1.52
log
@Remove the useless FATAL error "argument count wrong, violates syntax".
The last remaining instance was .It in .Bl -column with more than one
excessive .Ta.  However, simply downgrading from FATAL to ERROR, it just
works fine, almost the same way as in groff, without any other changes.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.51 2014/08/08 15:26:28 schwarze Exp $ */
a199 1
	"column syntax is inconsistent",
@


1.51
log
@Get rid of the useless FATAL error "child violates parent syntax".
When finding items outside lists, simply skip them and throw an ERROR.
Handle subsections before the first section instead of bailing out.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.50 2014/08/08 15:21:17 schwarze Exp $ */
a201 1
	"argument count wrong, violates syntax",
@


1.50
log
@Remove two useless FATAL errors.
When a file contains neither text nor macros, treat it as an empty document.
When the mdoc(7) document prologue is incomplete, use some default values.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.49 2014/08/08 15:15:27 schwarze Exp $ */
d180 1
a201 1
	"child violates parent syntax",
@


1.49
log
@better name and wording for the last two non-generic errors
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.48 2014/08/08 15:10:15 schwarze Exp $ */
a198 1
	"not a manual",
a204 1
	"no document prologue",
a256 5
		if (NULL == curp->pmdoc)
			curp->pmdoc = mdoc_alloc(
			    curp->roff, curp, curp->defos,
			    MPARSE_QUICK & curp->options ? 1 : 0);
		assert(curp->pmdoc);
a259 4
		if (NULL == curp->pman)
			curp->pman = man_alloc(curp->roff, curp,
			    MPARSE_QUICK & curp->options ? 1 : 0);
		assert(curp->pman);
d665 13
a687 6
	if ( ! (curp->mdoc || curp->man || curp->sodest)) {
		mandoc_msg(MANDOCERR_NOTMANUAL, curp, 0, 0, NULL);
		curp->file_status = MANDOCLEVEL_FATAL;
		return;
	}

d770 8
@


1.48
log
@Various improvements related to .Ex and .Rv:
* let .Nm fall back to the empty string, not to UNKNOWN
* never let .Rv copy an argument from .Nm
* avoid spurious \fR after empty .Nm in -Tman
* correct handling of .Ex and .Rv in -Tman
* correct the wording of the output for .Rv without arguments
* use non-breaking spaces in .Ex and .Rv output where required
* split MANDOCERR_NONAME into a warning for .Ex and an error for .Nm
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.47 2014/07/09 11:30:07 schwarze Exp $ */
d188 1
d190 1
d192 1
a192 3
	"uname(3) system call failed",
	"request requires a numeric argument",
	"missing list type, using -item",
@


1.47
log
@mark defos as const; nobody needs to change it,
and it is occasionally useful to be able to pass literal strings
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.46 2014/07/07 21:35:42 schwarze Exp $ */
d131 1
a186 1
	"manual name not yet set",
d188 1
@


1.46
log
@Clean up ERROR messages related to document structure and macros:
Hierarchical naming and mention macro names in messages.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.45 2014/07/07 16:12:06 schwarze Exp $ */
d60 1
a60 1
	char		 *defos; /* default operating system */
d759 1
a759 1
		mandocmsg mmsg, char *defos)
@


1.45
log
@no need to delete any content from .Rs blocks,
and downgrade the related message from ERROR to WARNING
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.44 2014/07/07 15:03:24 schwarze Exp $ */
d175 1
d178 7
a186 1
	"skipping unknown macro",
a188 4
	"skipping column outside column list",
	"skipping end of block that is not open",
	"missing end of block",
	"scope open on exit",
@


1.44
log
@no need to skip content before first section header
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.43 2014/07/07 11:34:41 schwarze Exp $ */
d144 1
a180 1
	"skipping invalid content in .Rs block",
@


1.43
log
@implement .dei and .ami
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.42 2014/07/06 19:08:56 schwarze Exp $ */
a177 1
	"skipping text before first section header",
@


1.42
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.41 2014/07/05 12:33:54 schwarze Exp $ */
a179 1
	"NOT IMPLEMENTED, please use groff: skipping request",
@


1.41
log
@Cleanup with respect to bad macro arguments.
* Fix .Sm with invalid arg: move arg out and toggle mode.
* Promote "unknown standard" from WARNING to ERROR, it loses information.
* Delete MANDOCERR_BADWIDTH, it would only indicate a mandoc(1) bug.
* Do not report MANDOCERR_BL_LATETYPE when there is no type at all.
* Mention macro names, arguments and fallbacks.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.40 2014/07/05 01:11:33 schwarze Exp $ */
d139 1
d148 3
a150 3
	"blank line in non-literal context",
	"tab in non-literal context",
	"end of line whitespace",
d152 2
a153 2
	"bad escape sequence",
	"unterminated quoted string",
@


1.40
log
@Cleanup regarding -offset and -width:
* Bugfix: Last one wins, not first one.
* Fix .Bl -width without argument: it means 0n, so do not ignore it.
* Report macro names, argument names and fallbacks in related messages.
* Simplify: Garbage collect auxiliary variables in pre_bd() and pre_bl().
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.39 2014/07/04 16:11:41 schwarze Exp $ */
d140 2
a141 2
	"duplicate display type",
	"duplicate list type",
d143 2
a144 4
	"bad Boolean value",
	"unknown font",
	"unknown standard specifier",
	"bad width argument",
d182 1
@


1.39
log
@Clean up messages regarding excess arguments:
* Downgrade ".Bf -emphasis Em" from FATAL to WARNING.
* Mention the macros, the arguments, and the fallbacks.
* Hierarchical naming.
Also fix the handling of excess .It head arguments in -Tman.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.38 2014/07/04 01:50:03 schwarze Exp $ */
d126 1
@


1.38
log
@Clean up messages related to missing arguments.
* Do not warn about empty -column cells, they seem valid to me.
* Downgrade empty item and missing -std from ERROR to WARNING.
* Hierarchical naming.
* Descriptive, not imperative style.
* Mention macro names, argument names, and fallbacks.
* Garbage collect some unreachable code in post_it().
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.37 2014/07/03 23:23:45 schwarze Exp $ */
d132 2
a133 1
	"missing font type",
d190 2
a191 1
	"line argument(s) will be lost",
a198 1
	"argument count wrong, violates syntax",
@


1.37
log
@Fix formatting of empty .Bl -inset item heads.
Downgrade empty item heads from ERROR to WARNING.
Show the list type in the error message.
Choose better variable names for nodes in post_it().
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.36 2014/07/03 21:23:08 schwarze Exp $ */
d127 5
a131 4
	"missing display type",
	"list type must come first",
	"tag lists require a width argument",
	"missing head in list item",
d133 1
a186 2
	"macro requires body argument(s)",
	"macro requires argument(s)",
d188 1
a188 1
	"missing list type",
@


1.36
log
@MANDOCERR_NOARGS reported three completely unrelated classes of problems.
Split the roff(7) parts out of it and report the request names for these cases.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.35 2014/07/02 13:10:15 schwarze Exp $ */
d130 1
a184 1
	"macro requires line argument(s)",
@


1.35
log
@Disentangle the MANDOCERR_CHILD message, which reported three
completely different things, into three distinct messages.
Also mention the macro names we are talking about.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.34 2014/07/02 11:42:56 schwarze Exp $ */
d123 2
@


1.34
log
@Clean up warnings related to macros and nesting.
* Hierarchical naming of enum mandocerr items.
* Improve the wording to make it comprehensible.
* Mention the offending macro.
* Garbage collect one chunk of ancient, long unreachable code.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.33 2014/07/02 03:47:07 schwarze Exp $ */
a114 1
	"child violates parent syntax",
d116 2
d176 1
@


1.33
log
@Implement the obsolete macros .En .Es .Fr .Ot for backward compatibility,
since this is hardly more complicated than explicitly ignoring them
as we did in the past.  Of course, do not use them!
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.32 2014/07/01 22:36:35 schwarze Exp $ */
d117 2
a118 1
	"already in literal mode",
a127 1
	"skipping end of block that is not open",
@


1.32
log
@Clean up the warnings related to document structure.
* Hierarchical naming of the related enum mandocerr items.
* Mention the offending macro, section title, or string.
While here, improve some wordings:
* Descriptive instead of imperative style.
* Uniform style for "missing" and "skipping".
* Where applicable, mention the fallback used.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.31 2014/06/30 23:45:03 schwarze Exp $ */
d110 1
a110 1
	"skipping obsolete macro",
@


1.31
log
@garbage collect two unused enum mandocerr items
and fix a couple of comments while here
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.30 2014/06/25 00:19:17 schwarze Exp $ */
d88 2
a89 2
	"no TH macro in document",
	"document title should be all caps",
d92 1
a92 1
	"date missing, using today's date",
d96 2
a97 2
	"macro not allowed in prologue",
	"macro not allowed in body",
d102 2
a103 2
	"content before the first section header",
	"NAME section must come first",
d106 2
a107 2
	"duplicate section name",
	"section header suited to sections 2, 3, and 9 only",
d171 1
a171 1
	"skipping text before the first section header",
@


1.30
log
@Improve messages related to the roff(7) .so request.

In all these messages, show the filename argument that was passed
to the .so request.

In case of failure, show an additional message reporting the file
and the line number where the failing request was found.
The existing message reporting the reason for the failure -
for example, "Permission denied" - is left in place, unchanged.

Inspired by a question asked by Nick@@ after he saw the
confusing old messages that used to be emitted in this area.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.29 2014/06/21 22:23:44 schwarze Exp $ */
a147 3
	/* related to equations */
	"unexpected literal in equation",

a185 1
	"body argument(s) will be lost",
@


1.29
log
@Reduce the verbosity of error messages caused by open(2) failures.
Suggested by and ok jmc@@.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.28 2014/06/20 22:58:41 schwarze Exp $ */
d201 1
d502 4
a505 1
			if (MANDOCLEVEL_FATAL <= curp->file_status)
d507 1
@


1.28
log
@As suggested by jmc@@, only include line and column numbers into messages
when they are meaningful, to avoid confusing stuff like this:
$ mandoc /dev/null
mandoc: /dev/null:0:1: FATAL: not a manual
Instead, just say:
mandoc: /dev/null: FATAL: not a manual

Another example this applies to is documents having a prologue,
but lacking a body.  Do not throw a FATAL error for these; instead,
issue a warning and show the empty document, in the man(7) case with
the same amount of blank lines as groff does.  Also downgrade mdoc(7)
documents having content before the first .Sh from FATAL to WARNING.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.27 2014/06/20 17:23:09 schwarze Exp $ */
d205 1
a205 1
	"cannot open file",
@


1.27
log
@Start systematic improvements of error reporting.
So far, this covers all WARNINGs related to the prologue.

1) hierarchical naming of MANDOCERR_* constants
2) mention the macro name in messages where that adds clarity
3) add one missing MANDOCERR_DATE_MISSING msg
4) fix the wording of one message related to the man(7) prologue

Started on the plane back from Ottawa.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.26 2014/04/20 22:03:40 schwarze Exp $ */
d101 2
a200 1
	"no document body",
d678 1
a678 1
		mandoc_msg(MANDOCERR_NOTMANUAL, curp, 1, 0, NULL);
@


1.26
log
@in debug messages, truncating strings of excessive lengths is actually
a good thing, so cast the return value from sprintf to (void);
this concludes the mandoc sprintf audit
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.25 2014/04/20 16:44:44 schwarze Exp $ */
d88 1
a88 1
	"no title in document",
@


1.25
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.24 2014/03/21 22:17:01 schwarze Exp $ */
d830 1
a830 1
	vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
@


1.24
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.23 2014/03/19 22:20:36 schwarze Exp $ */
d41 1
a41 1
	char	 	 *buf; /* binary input buffer */
d58 1
a58 1
	const char	 *file; 
d148 1
a148 1
	
d219 1
d253 1
a253 1
		if (NULL == curp->pmdoc) 
d261 1
a261 1
		if (NULL == curp->pman) 
d270 1
a270 1
		if (NULL == curp->pmdoc) 
d277 1
a277 1
	} 
d279 1
a279 1
	if (NULL == curp->pman) 
d304 2
a305 2
	lnn = curp->line; 
	pos = 0; 
d342 1
a342 1
			/* 
d353 2
a354 2
			if ( ! (isascii(c) && 
					(isgraph(c) || isblank(c)))) {
d356 1
a356 1
						curp->line, pos, NULL);
d410 2
a411 2
			if ( ! (isascii(c) && 
					(isgraph(c) || isblank(c)))) {
d413 1
a413 1
						curp->line, pos, NULL);
d425 1
a425 1
 		if (pos >= (int)ln.sz)
d448 6
a453 7
			curp->secondary->buf = 
				mandoc_realloc
				(curp->secondary->buf, 
				 curp->secondary->sz + pos + 2);
			memcpy(curp->secondary->buf + 
					curp->secondary->sz, 
					ln.buf, pos);
d462 2
a463 3
		rr = roff_parseln
			(curp->roff, curp->line, 
			 &ln.buf, &ln.sz, of, &of);
d466 1
a466 1
		case (ROFF_REPARSE):
d471 1
a471 1
					curp->line, pos, NULL);
d474 1
a474 1
		case (ROFF_APPEND):
d477 1
a477 1
		case (ROFF_RERUN):
d479 1
a479 1
		case (ROFF_IGN):
d482 1
a482 1
		case (ROFF_ERR):
d485 1
a485 1
		case (ROFF_SO):
d497 1
a497 1
			if (curp->secondary) 
d526 1
a526 1
		/* 
d542 2
a543 2
					man_addspan(curp->man, span) :
					mdoc_addspan(curp->mdoc, span);
d548 5
a552 5
			rc = curp->mdoc ? 
				mdoc_addeqn(curp->mdoc, 
					roff_eqn(curp->roff)) :
				man_addeqn(curp->man,
					roff_eqn(curp->roff));
d555 4
a558 4
				man_parseln(curp->man, 
					curp->line, ln.buf, of) :
				mdoc_parseln(curp->mdoc, 
					curp->line, ln.buf, of);
d837 1
a837 1
mandoc_msg(enum mandocerr er, struct mparse *m, 
@


1.23
log
@Without the MPARSE_SO option, if the file contains nothing but a
single .so request, do not read the file pointed to, but instead
let mparse_result() provide the file name pointed to as a return
value.  To be used by makewhatis(8) in the future.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.22 2014/03/19 21:50:59 schwarze Exp $ */
d33 1
@


1.22
log
@Generalize the mparse_alloc() and roff_alloc() functions by giving
them an "options" argument, replacing the existing "inttype" and
"quick" arguments, preparing for a future MPARSE_SO option.
Store this argument in struct mparse and struct roff, replacing the
existing "inttype", "parsetype", and "quick" members.
No functional change except one tiny cosmetic fix in roff_TH().
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.21 2014/01/06 21:33:00 schwarze Exp $ */
d54 1
d486 6
d676 1
a676 1
	if ( ! (curp->man || curp->mdoc)) {
d783 3
d802 1
d807 2
a808 1
mparse_result(struct mparse *curp, struct mdoc **mdoc, struct man **man)
d811 5
@


1.21
log
@Another 25% speedup for mandocdb(8) -Q mode, found with gprof(1).
For /usr/share/man, we only need 56% of the time of makewhatis(8) now.

In groff, user-defined macros clashing with mdoc(7) or man(7)
standard macros are cleared when parsing the .Dd or .TH macro,
respectively.  Of course, we continue doing that in standard mode
to assure full groff bug compatibility.

However, in -Q mode, full groff bug compatibility makes no sense
when it's unreasonably expensive, so skip this step in -Q mode.
Real-world manuals hardly ever redefine standard macros,
that's terrible style, and if they do, it's pointless to do so
before .Dd or .TH because it has no effect.  Even if someone does,
it's extremely unlikely to break mandocdb(8) -Q parsing because we
abort the parse sequence after the NAME section, anyway.

So if you manually redefine .Sh, .Nm, .Nd, or .SH in a way that doesn't
work at all and rely on .Dd or .TH to fix it up for you, your broken
manual will no longer get a perfect apropos(1) entry until you re-run
mandocdb(8) without -Q.  It think that consequence is acceptable
in order to get a 25% speedup for everyone else.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.20 2014/01/06 00:53:14 schwarze Exp $ */
d48 1
a48 1
	enum mparset	  inttype; /* which parser to use */
a58 1
	int		  quick; /* abort the parse early */
d249 1
a249 2
	switch (curp->inttype) {
	case (MPARSE_MDOC):
d251 3
a253 2
			curp->pmdoc = mdoc_alloc(curp->roff, curp,
					curp->defos, curp->quick);
d257 1
a257 1
	case (MPARSE_MAN):
d260 1
a260 1
					curp->quick);
a263 2
	default:
		break;
d268 3
a270 2
			curp->pmdoc = mdoc_alloc(curp->roff, curp,
					curp->defos, curp->quick);
d277 2
a278 1
		curp->pman = man_alloc(curp->roff, curp, curp->quick);
d742 2
a743 2
mparse_alloc(enum mparset inttype, enum mandoclevel wlevel,
		mandocmsg mmsg, char *defos, int quick)
d751 1
a753 1
	curp->inttype = inttype;
a754 1
	curp->quick = quick;
d756 1
a756 1
	curp->roff = roff_alloc(inttype, curp, curp->quick);
@


1.20
log
@Joerg Sonnenberger contributed copyrightable amounts of text to
some files.  To make it clear that he also put his contributions
under the ISC license, with his explicit permission, add his
Copyright notice to the relevant files.  No code change.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.19 2014/01/05 20:26:27 schwarze Exp $ */
d758 1
a758 1
	curp->roff = roff_alloc(inttype, curp);
@


1.19
log
@Add an option -Q (quick) to mandocdb(8)
for accelerated generation of reduced-size databases.

Implement this by allowing the parsers to optionally
abort the parse sequence after the NAME section.

While here, garbage collect the unused void *arg attribute
of struct mparse and mparse_alloc().

This reduces the processing time of mandocdb(8) on /usr/share/man
by a factor of 2 and the database size by a factor of 4.
However, it still takes 5 times the time and 6 times the space
of makewhatis(8), so more work is clearly needed.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.18 2014/01/02 16:29:46 schwarze Exp $ */
d5 1
@


1.18
log
@Since the functions in read.c are part of the mandoc(3) library,
do not print to stderr.  Instead, properly use the mmsg callback.
Issue noticed by Abhinav Upadhyay <er dot abhinav dot upadhyay
at gmail dot com> and Thomas Klausner <wiz at NetBSD>.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.17 2013/09/16 00:25:06 schwarze Exp $ */
a54 1
	void		 *arg; /* argument to mmsg */
d58 1
d253 1
a253 1
					curp->defos);
d259 2
a260 1
			curp->pman = man_alloc(curp->roff, curp);
d271 1
a271 1
					curp->defos);
d278 1
a278 1
		curp->pman = man_alloc(curp->roff, curp);
d556 2
a557 1
		}
d743 1
a743 1
		mandocmsg mmsg, void *arg, char *defos)
a752 1
	curp->arg = arg;
d755 1
@


1.17
log
@One of the WARNING messages has to use the word "section" twice in two
different meanings, that cannot be helped.  But we can make this less
confusing by stating that the second instance refers to stuff like (2),
(3), and (9), and by adding the sections header the first instance
refers to, for example ERRORS or RETURN VALUES.

Source for confusion noticed by Jan Stary <hans at stare dot cz>,
better wording suggested by jmc@@, tweaked by me.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.16 2013/07/13 12:51:38 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d23 1
d64 2
a65 1
static	int	  read_whole_file(const char *, int, struct buf *, int *);
d189 1
d200 5
d571 2
a572 1
read_whole_file(const char *file, int fd, struct buf *fb, int *with_mmap)
d579 4
a582 1
		perror(file);
d595 4
a598 1
			fprintf(stderr, "%s: input too large\n", file);
d620 5
a624 1
				fprintf(stderr, "%s: input too large\n", file);
d635 5
a639 1
			perror(file);
d707 9
a715 6
	if (-1 == fd)
		if (-1 == (fd = open(file, O_RDONLY, 0))) {
			perror(file);
			curp->file_status = MANDOCLEVEL_SYSERR;
			goto out;
		}
d723 1
a723 2
	if ( ! read_whole_file(file, fd, &blk, &with_mmap)) {
		curp->file_status = MANDOCLEVEL_SYSERR;
a724 1
	}
@


1.16
log
@Rudimentary implementation of the .it request (input line trap).
As with any low-level roff request involving subtle interactions
with macro internals, this implementation is not exact, but it
does handle the simplest cases.

This request occurs in man(7) code generated from DocBook,
for example mysql(1) and yasm_arch(7).
Thanks to brad@@ for reporting the issue back in January 2011.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.15 2013/06/02 03:35:21 schwarze Exp $ */
d101 1
a101 1
	"section not in conventional manual section",
@


1.15
log
@Sync with bsd.lv, reshuffling the code a bit among mparse_readfd() and
mparse_parse_buffer(), no functional change intended.

Exclude the following from the sync:
 - Skip the mparse_readmem() function, it's useless in OpenBSD.
 - Thus, UNCONST isn't used, so no need for "main.h" and <stdint.h>.
 - Skip HAVE_CONFIG_H (always off here) and HAVE_MMAP (always on here).
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.14 2013/06/01 22:57:30 schwarze Exp $ */
d180 1
@


1.14
log
@This file contains too much complexity.
Remove one layer of indirection by deleting mparse_readfd_r()
and doing its work in the public mparse_readfd().
As a bonus, catch recursive .so.
This is part of the preparations to resync to mdocml.bsd.lv.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.13 2013/05/30 03:51:59 schwarze Exp $ */
a62 1
static	void	  pdesc(struct mparse *, const char *, int);
d65 2
a560 30
static void
pdesc(struct mparse *curp, const char *file, int fd)
{
	struct buf	 blk;
	int		 with_mmap;

	/*
	 * Run for each opened file; may be called more than once for
	 * each full parse sequence if the opened file is nested (i.e.,
	 * from `so').  Simply sucks in the whole file and moves into
	 * the parse phase for the file.
	 */

	if ( ! read_whole_file(file, fd, &blk, &with_mmap)) {
		curp->file_status = MANDOCLEVEL_SYSERR;
		return;
	}

	/* Line number is per-file. */

	curp->line = 1;

	mparse_buf_r(curp, blk, 1);

	if (with_mmap)
		munmap(blk.buf, blk.sz);
	else
		free(blk.buf);
}

d587 1
a587 2
		fb->buf = mmap(NULL, fb->sz, PROT_READ, 
				MAP_FILE|MAP_SHARED, fd, 0);
d652 2
a653 2
enum mandoclevel
mparse_readfd(struct mparse *curp, int fd, const char *file)
d660 1
a660 1
		goto out;
d663 20
d689 6
d696 4
a699 3
	svfile = curp->file;
	curp->file = file;
	recursion_depth++;
d701 1
a701 1
	pdesc(curp, file, fd);
d703 4
a706 2
	if (0 == --recursion_depth && MANDOCLEVEL_FATAL > curp->file_status)
		mparse_end(curp);
a709 2

	curp->file = svfile;
@


1.13
log
@Reject non-printable characters found in the input stream even when
preceded by a backslash; otherwise, the escape sequence would later
be identified as invalid and the non-printable character would be
passed through to the output backends, sometimes triggering assertions.

Reported by Mike Small <smallm at panix dot com> on the mdocml discuss list.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.12 2012/11/19 22:28:35 schwarze Exp $ */
a61 1
static	void	  mparse_readfd_r(struct mparse *, int, const char *, int);
d481 1
a481 1
			mparse_readfd_r(curp, -1, ln.buf + of, 1);
d682 2
a683 2
static void
mparse_readfd_r(struct mparse *curp, int fd, const char *file, int re)
d686 6
d697 1
a697 1
			return;
d702 1
d706 1
a706 1
	if (0 == re && MANDOCLEVEL_FATAL > curp->file_status)
d713 1
a713 7
}

enum mandoclevel
mparse_readfd(struct mparse *curp, int fd, const char *file)
{

	mparse_readfd_r(curp, fd, file, 0);
@


1.12
log
@Do not crash on stray .Ta macros found outside column lists.
Problem reported by jmc@@, thanks.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.11 2012/11/16 22:20:40 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d320 9
a344 2
				if (pos >= (int)ln.sz)
					resize_buf(&ln, 256);
a351 2
				if (pos >= (int)ln.sz)
					resize_buf(&ln, 256);
d393 13
a406 3

			if (pos + 1 >= (int)ln.sz)
				resize_buf(&ln, 256);
@


1.11
log
@Warn about unknown volume or arch in Dt macro arguments;
patch written by Nicolas Joly <njoly at pasteur dot fr>.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.10 2012/07/18 11:09:30 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011 Ingo Schwarze <schwarze@@openbsd.org>
d172 1
@


1.10
log
@Fix handling of paragraph macros inside lists:
* When they are trailing the last item, move them outside the list.
* When they are trailing any other none-compact item, drop them.

Improves formatting of 40 pages, e.g. grep(1), ksh(1), netstat(1),
ath(4), bsd.port.mk(5), pf.conf(5), mount(8), crypto(9).
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.9 2012/07/12 15:09:50 schwarze Exp $ */
d87 1
@


1.9
log
@The post_nm() validation function crashed when the first .Nm child node
was a non-text node.  Fix this by rewriting post_nm() to always set
the meta name to UNKNOWN when the name is missing or unusable.
While here, make MANDOCERR_NONAME an ERROR, as it usually renders
the page content unintelligible.

Bug reported by Maxim <Belooussov at gmail dot com>, thanks.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.8 2012/06/02 23:18:30 schwarze Exp $ */
d105 1
@


1.8
log
@In groff, trying to redefine standard man(7) macros before .TH has no effect;
after .TH, it works.  Trying to redefine standard mdoc(7) macros before .Dd
works when calling groff with the -mdoc command line option, but does not
when calling groff with -mandoc; after .Dd, it always works.

Arguably, one might call that buggy behaviour in groff, but it is very
unlikely that anybody will change groff in this respect (certainly, i'm
not volunteering).  So let's be bug-compatible.

This fixes the vertical spacing in sox(1).
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.7 2012/05/24 23:33:23 schwarze Exp $ */
a97 1
	"manual name not yet set",
d165 1
@


1.7
log
@Support -Ios='OpenBSD 5.1' to override uname(3) as the source of the
default value for the mdoc(7) .Os macro.
Needed for man.cgi on the OpenBSD website.

Problem with man.cgi first noticed by deraadt@@;
beck@@ and deraadt@@ agree with the way to solve the issue.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.6 2012/02/26 21:01:43 schwarze Exp $ */
d715 1
a715 1
	curp->roff = roff_alloc(curp);
@


1.6
log
@Don't silently skip non-ASCII characters, but replace them with ``?''.
This is less likely to break the syntax of macros.
Patch provided by joerg@@.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.5 2011/11/05 16:02:18 schwarze Exp $ */
d57 1
d240 2
a241 1
			curp->pmdoc = mdoc_alloc(curp->roff, curp);
d257 2
a258 1
			curp->pmdoc = mdoc_alloc(curp->roff, curp);
d700 2
a701 1
mparse_alloc(enum mparset inttype, enum mandoclevel wlevel, mandocmsg mmsg, void *arg)
d713 1
@


1.5
log
@When the HEAD scope of .TP is broken by another block macro,
do not abort with a FATAL error, but report a regular ERROR,
remove the broken .TP from the syntax tree, and prod on.
Reported repeatedly by ports people, at least by brad@@ and jeremy@@.
Also fixes rendition(4) in Xenocara.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.4 2011/10/09 17:59:56 schwarze Exp $ */
d318 3
a320 3
			 * I'll be helpful and drop these characters so
			 * we don't display gibberish.  Note to manual
			 * writers: use special characters.
d328 1
a328 1
						curp->line, pos, "ignoring byte");
d330 3
@


1.4
log
@Sync to version 1.12.0; all code by kristaps@@:
Implement .Rv in -Tman.
Let -man -Tman work a bit like cat(1).
Add the -Ofragment option to -T[x]html.
Minor fixes in -T[x]html.
Lots of apropos(1) and -Tman code cleanup.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.3 2011/09/18 10:25:28 schwarze Exp $ */
a184 1
	"line scope broken, syntax violated",
@


1.3
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.2 2011/05/29 21:22:18 schwarze Exp $ */
d56 1
d405 21
d452 7
d722 2
d740 2
d743 1
d802 16
@


1.2
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.1 2011/04/24 16:22:02 schwarze Exp $ */
a51 1
	struct regset	  regs; /* roff registers */
d138 3
d144 7
d239 1
a239 1
			curp->pmdoc = mdoc_alloc(&curp->regs, curp);
d245 1
a245 1
			curp->pman = man_alloc(&curp->regs, curp);
d255 1
a255 1
			curp->pmdoc = mdoc_alloc(&curp->regs, curp);
d262 1
a262 1
		curp->pman = man_alloc(&curp->regs, curp);
d679 1
a679 1
	curp->roff = roff_alloc(&curp->regs, curp);
a685 2

	memset(&curp->regs, 0, sizeof(struct regset));
@


1.1
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.1 2011/03/20 11:41:24 kristaps Exp $ */
d137 1
a137 1
	"unknown escape sequence",
d440 1
a440 1
		 * We keep these instanced betwen parsers, but set them
@

