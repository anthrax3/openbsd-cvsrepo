head	1.69;
access;
symbols
	OPENBSD_6_1:1.66.0.4
	OPENBSD_6_1_BASE:1.66
	OPENBSD_6_0:1.64.0.2
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.60.0.4
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.56.0.2
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.46.0.4
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.43.0.4
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.2
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.40.0.2
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.4
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.35.0.2
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.69
date	2017.05.05.13.17.04;	author schwarze;	state Exp;
branches;
next	1.68;
commitid	GvSRKa33jIoa4JAJ;

1.68
date	2017.05.04.17.48.24;	author schwarze;	state Exp;
branches;
next	1.67;
commitid	RHQLdCAdHKxKe8Eu;

1.67
date	2017.04.24.23.06.09;	author schwarze;	state Exp;
branches;
next	1.66;
commitid	2CfzvK3gmiJH7vY0;

1.66
date	2017.03.03.15.04.51;	author schwarze;	state Exp;
branches;
next	1.65;
commitid	CIXe6UkLSadq8Q3z;

1.65
date	2016.08.28.16.13.51;	author schwarze;	state Exp;
branches;
next	1.64;
commitid	ruvFP22VN2KzOr91;

1.64
date	2016.07.15.18.02.32;	author schwarze;	state Exp;
branches;
next	1.63;
commitid	NgDdzKtKRT5DJZ6U;

1.63
date	2015.10.17.00.19.58;	author schwarze;	state Exp;
branches;
next	1.62;
commitid	67CJSTzbNGkiWCoU;

1.62
date	2015.10.15.22.45.07;	author schwarze;	state Exp;
branches;
next	1.61;
commitid	yRc3qKQhBWZEWiT0;

1.61
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.60;
commitid	hxQV8O1pNUaef4ir;

1.60
date	2015.04.19.13.59.37;	author schwarze;	state Exp;
branches;
next	1.59;
commitid	aS3h5dIgZk0f7675;

1.59
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.58;
commitid	6MYJ7cd8mhJ77AGH;

1.58
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.57;
commitid	Rfx1oTaH3hZ7Zcyf;

1.57
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.56;
commitid	lmErjWY2O9ooA6RY;

1.56
date	2015.02.04.18.58.09;	author schwarze;	state Exp;
branches;
next	1.55;
commitid	fjQt2d2WjsAKf1nR;

1.55
date	2014.11.29.03.37.28;	author schwarze;	state Exp;
branches;
next	1.54;
commitid	aqtIRSBVUjLd0Mqm;

1.54
date	2014.11.28.23.20.55;	author schwarze;	state Exp;
branches;
next	1.53;
commitid	t9mCLXjRHJDgC7uT;

1.53
date	2014.11.28.03.13.58;	author schwarze;	state Exp;
branches;
next	1.52;
commitid	ImMvSGeZONzvc96J;

1.52
date	2014.07.06.19.08.56;	author schwarze;	state Exp;
branches;
next	1.51;
commitid	rolX8OitNNoUBJoD;

1.51
date	2014.07.02.03.47.07;	author schwarze;	state Exp;
branches;
next	1.50;
commitid	p4pNII1v0bYCswy0;

1.50
date	2014.04.23.21.06.33;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2013.12.25.00.50.03;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2013.12.22.14.06.29;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2013.12.15.23.56.21;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2012.11.18.00.05.28;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2012.11.17.00.25.20;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2012.11.16.18.40.39;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2012.04.15.10.31.00;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2011.07.05.04.12.41;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2010.12.29.00.47.31;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2010.09.13.20.10.11;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2010.06.26.17.56.43;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.06.20.30.08;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.23.22.45.00;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.15.13.12.55;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.15.12.30.59;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2010.05.14.19.52.43;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.14.14.47.44;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2010.05.14.01.54.37;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.03.16.30.42;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2010.04.02.12.39.47;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2010.03.02.00.38.59;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2010.03.02.00.13.57;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.21.19.13.50;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.19.21.00.43;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.19.15.44.01;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.22.22.50.17;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.22.22.39.55;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.26.22.48.41;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.26.02.17.29;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.26.01.59.46;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.12.23.26.08;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.12.22.35.08;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.12.21.45.44;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.12.21.08.29;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.12.20.30.27;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.21.19.09.58;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.18.23.34.53;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.14.23.00.57;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.20.30.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.69
log
@move .ll to the roff modules
@
text
@/*	$OpenBSD: mdoc_argv.c,v 1.68 2017/05/04 17:48:24 schwarze Exp $ */
/*
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2012, 2014-2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "libmandoc.h"
#include "roff_int.h"
#include "libmdoc.h"

#define	MULTI_STEP	 5 /* pre-allocate argument values */
#define	DELIMSZ		 6 /* max possible size of a delimiter */

enum	argsflag {
	ARGSFL_NONE = 0,
	ARGSFL_DELIM, /* handle delimiters of [[::delim::][ ]+]+ */
	ARGSFL_TABSEP /* handle tab/`Ta' separated phrases */
};

enum	argvflag {
	ARGV_NONE, /* no args to flag (e.g., -split) */
	ARGV_SINGLE, /* one arg to flag (e.g., -file xxx)  */
	ARGV_MULTI /* multiple args (e.g., -column xxx yyy) */
};

struct	mdocarg {
	enum argsflag	 flags;
	const enum mdocargt *argvs;
};

static	void		 argn_free(struct mdoc_arg *, int);
static	enum margserr	 args(struct roff_man *, int, int *,
				char *, enum argsflag, char **);
static	int		 args_checkpunct(const char *, int);
static	void		 argv_multi(struct roff_man *, int,
				struct mdoc_argv *, int *, char *);
static	void		 argv_single(struct roff_man *, int,
				struct mdoc_argv *, int *, char *);

static	const enum argvflag argvflags[MDOC_ARG_MAX] = {
	ARGV_NONE,	/* MDOC_Split */
	ARGV_NONE,	/* MDOC_Nosplit */
	ARGV_NONE,	/* MDOC_Ragged */
	ARGV_NONE,	/* MDOC_Unfilled */
	ARGV_NONE,	/* MDOC_Literal */
	ARGV_SINGLE,	/* MDOC_File */
	ARGV_SINGLE,	/* MDOC_Offset */
	ARGV_NONE,	/* MDOC_Bullet */
	ARGV_NONE,	/* MDOC_Dash */
	ARGV_NONE,	/* MDOC_Hyphen */
	ARGV_NONE,	/* MDOC_Item */
	ARGV_NONE,	/* MDOC_Enum */
	ARGV_NONE,	/* MDOC_Tag */
	ARGV_NONE,	/* MDOC_Diag */
	ARGV_NONE,	/* MDOC_Hang */
	ARGV_NONE,	/* MDOC_Ohang */
	ARGV_NONE,	/* MDOC_Inset */
	ARGV_MULTI,	/* MDOC_Column */
	ARGV_SINGLE,	/* MDOC_Width */
	ARGV_NONE,	/* MDOC_Compact */
	ARGV_NONE,	/* MDOC_Std */
	ARGV_NONE,	/* MDOC_Filled */
	ARGV_NONE,	/* MDOC_Words */
	ARGV_NONE,	/* MDOC_Emphasis */
	ARGV_NONE,	/* MDOC_Symbolic */
	ARGV_NONE	/* MDOC_Symbolic */
};

static	const enum mdocargt args_Ex[] = {
	MDOC_Std,
	MDOC_ARG_MAX
};

static	const enum mdocargt args_An[] = {
	MDOC_Split,
	MDOC_Nosplit,
	MDOC_ARG_MAX
};

static	const enum mdocargt args_Bd[] = {
	MDOC_Ragged,
	MDOC_Unfilled,
	MDOC_Filled,
	MDOC_Literal,
	MDOC_File,
	MDOC_Offset,
	MDOC_Compact,
	MDOC_Centred,
	MDOC_ARG_MAX
};

static	const enum mdocargt args_Bf[] = {
	MDOC_Emphasis,
	MDOC_Literal,
	MDOC_Symbolic,
	MDOC_ARG_MAX
};

static	const enum mdocargt args_Bk[] = {
	MDOC_Words,
	MDOC_ARG_MAX
};

static	const enum mdocargt args_Bl[] = {
	MDOC_Bullet,
	MDOC_Dash,
	MDOC_Hyphen,
	MDOC_Item,
	MDOC_Enum,
	MDOC_Tag,
	MDOC_Diag,
	MDOC_Hang,
	MDOC_Ohang,
	MDOC_Inset,
	MDOC_Column,
	MDOC_Width,
	MDOC_Offset,
	MDOC_Compact,
	MDOC_Nested,
	MDOC_ARG_MAX
};

static	const struct mdocarg __mdocargs[MDOC_MAX - MDOC_Dd] = {
	{ ARGSFL_NONE, NULL }, /* Dd */
	{ ARGSFL_NONE, NULL }, /* Dt */
	{ ARGSFL_NONE, NULL }, /* Os */
	{ ARGSFL_NONE, NULL }, /* Sh */
	{ ARGSFL_NONE, NULL }, /* Ss */
	{ ARGSFL_NONE, NULL }, /* Pp */
	{ ARGSFL_DELIM, NULL }, /* D1 */
	{ ARGSFL_DELIM, NULL }, /* Dl */
	{ ARGSFL_NONE, args_Bd }, /* Bd */
	{ ARGSFL_NONE, NULL }, /* Ed */
	{ ARGSFL_NONE, args_Bl }, /* Bl */
	{ ARGSFL_NONE, NULL }, /* El */
	{ ARGSFL_NONE, NULL }, /* It */
	{ ARGSFL_DELIM, NULL }, /* Ad */
	{ ARGSFL_DELIM, args_An }, /* An */
	{ ARGSFL_DELIM, NULL }, /* Ap */
	{ ARGSFL_DELIM, NULL }, /* Ar */
	{ ARGSFL_DELIM, NULL }, /* Cd */
	{ ARGSFL_DELIM, NULL }, /* Cm */
	{ ARGSFL_DELIM, NULL }, /* Dv */
	{ ARGSFL_DELIM, NULL }, /* Er */
	{ ARGSFL_DELIM, NULL }, /* Ev */
	{ ARGSFL_NONE, args_Ex }, /* Ex */
	{ ARGSFL_DELIM, NULL }, /* Fa */
	{ ARGSFL_NONE, NULL }, /* Fd */
	{ ARGSFL_DELIM, NULL }, /* Fl */
	{ ARGSFL_DELIM, NULL }, /* Fn */
	{ ARGSFL_DELIM, NULL }, /* Ft */
	{ ARGSFL_DELIM, NULL }, /* Ic */
	{ ARGSFL_DELIM, NULL }, /* In */
	{ ARGSFL_DELIM, NULL }, /* Li */
	{ ARGSFL_NONE, NULL }, /* Nd */
	{ ARGSFL_DELIM, NULL }, /* Nm */
	{ ARGSFL_DELIM, NULL }, /* Op */
	{ ARGSFL_DELIM, NULL }, /* Ot */
	{ ARGSFL_DELIM, NULL }, /* Pa */
	{ ARGSFL_NONE, args_Ex }, /* Rv */
	{ ARGSFL_DELIM, NULL }, /* St */
	{ ARGSFL_DELIM, NULL }, /* Va */
	{ ARGSFL_DELIM, NULL }, /* Vt */
	{ ARGSFL_DELIM, NULL }, /* Xr */
	{ ARGSFL_NONE, NULL }, /* %A */
	{ ARGSFL_NONE, NULL }, /* %B */
	{ ARGSFL_NONE, NULL }, /* %D */
	{ ARGSFL_NONE, NULL }, /* %I */
	{ ARGSFL_NONE, NULL }, /* %J */
	{ ARGSFL_NONE, NULL }, /* %N */
	{ ARGSFL_NONE, NULL }, /* %O */
	{ ARGSFL_NONE, NULL }, /* %P */
	{ ARGSFL_NONE, NULL }, /* %R */
	{ ARGSFL_NONE, NULL }, /* %T */
	{ ARGSFL_NONE, NULL }, /* %V */
	{ ARGSFL_DELIM, NULL }, /* Ac */
	{ ARGSFL_NONE, NULL }, /* Ao */
	{ ARGSFL_DELIM, NULL }, /* Aq */
	{ ARGSFL_DELIM, NULL }, /* At */
	{ ARGSFL_DELIM, NULL }, /* Bc */
	{ ARGSFL_NONE, args_Bf }, /* Bf */
	{ ARGSFL_NONE, NULL }, /* Bo */
	{ ARGSFL_DELIM, NULL }, /* Bq */
	{ ARGSFL_DELIM, NULL }, /* Bsx */
	{ ARGSFL_DELIM, NULL }, /* Bx */
	{ ARGSFL_NONE, NULL }, /* Db */
	{ ARGSFL_DELIM, NULL }, /* Dc */
	{ ARGSFL_NONE, NULL }, /* Do */
	{ ARGSFL_DELIM, NULL }, /* Dq */
	{ ARGSFL_DELIM, NULL }, /* Ec */
	{ ARGSFL_NONE, NULL }, /* Ef */
	{ ARGSFL_DELIM, NULL }, /* Em */
	{ ARGSFL_NONE, NULL }, /* Eo */
	{ ARGSFL_DELIM, NULL }, /* Fx */
	{ ARGSFL_DELIM, NULL }, /* Ms */
	{ ARGSFL_DELIM, NULL }, /* No */
	{ ARGSFL_DELIM, NULL }, /* Ns */
	{ ARGSFL_DELIM, NULL }, /* Nx */
	{ ARGSFL_DELIM, NULL }, /* Ox */
	{ ARGSFL_DELIM, NULL }, /* Pc */
	{ ARGSFL_DELIM, NULL }, /* Pf */
	{ ARGSFL_NONE, NULL }, /* Po */
	{ ARGSFL_DELIM, NULL }, /* Pq */
	{ ARGSFL_DELIM, NULL }, /* Qc */
	{ ARGSFL_DELIM, NULL }, /* Ql */
	{ ARGSFL_NONE, NULL }, /* Qo */
	{ ARGSFL_DELIM, NULL }, /* Qq */
	{ ARGSFL_NONE, NULL }, /* Re */
	{ ARGSFL_NONE, NULL }, /* Rs */
	{ ARGSFL_DELIM, NULL }, /* Sc */
	{ ARGSFL_NONE, NULL }, /* So */
	{ ARGSFL_DELIM, NULL }, /* Sq */
	{ ARGSFL_NONE, NULL }, /* Sm */
	{ ARGSFL_DELIM, NULL }, /* Sx */
	{ ARGSFL_DELIM, NULL }, /* Sy */
	{ ARGSFL_DELIM, NULL }, /* Tn */
	{ ARGSFL_DELIM, NULL }, /* Ux */
	{ ARGSFL_DELIM, NULL }, /* Xc */
	{ ARGSFL_NONE, NULL }, /* Xo */
	{ ARGSFL_NONE, NULL }, /* Fo */
	{ ARGSFL_DELIM, NULL }, /* Fc */
	{ ARGSFL_NONE, NULL }, /* Oo */
	{ ARGSFL_DELIM, NULL }, /* Oc */
	{ ARGSFL_NONE, args_Bk }, /* Bk */
	{ ARGSFL_NONE, NULL }, /* Ek */
	{ ARGSFL_NONE, NULL }, /* Bt */
	{ ARGSFL_NONE, NULL }, /* Hf */
	{ ARGSFL_DELIM, NULL }, /* Fr */
	{ ARGSFL_NONE, NULL }, /* Ud */
	{ ARGSFL_DELIM, NULL }, /* Lb */
	{ ARGSFL_NONE, NULL }, /* Lp */
	{ ARGSFL_DELIM, NULL }, /* Lk */
	{ ARGSFL_DELIM, NULL }, /* Mt */
	{ ARGSFL_DELIM, NULL }, /* Brq */
	{ ARGSFL_NONE, NULL }, /* Bro */
	{ ARGSFL_DELIM, NULL }, /* Brc */
	{ ARGSFL_NONE, NULL }, /* %C */
	{ ARGSFL_NONE, NULL }, /* Es */
	{ ARGSFL_DELIM, NULL }, /* En */
	{ ARGSFL_DELIM, NULL }, /* Dx */
	{ ARGSFL_NONE, NULL }, /* %Q */
	{ ARGSFL_NONE, NULL }, /* sp */
	{ ARGSFL_NONE, NULL }, /* %U */
	{ ARGSFL_NONE, NULL }, /* Ta */
};
static	const struct mdocarg *const mdocargs = __mdocargs - MDOC_Dd;


/*
 * Parse flags and their arguments from the input line.
 * These come in the form -flag [argument ...].
 * Some flags take no argument, some one, some multiple.
 */
void
mdoc_argv(struct roff_man *mdoc, int line, enum roff_tok tok,
	struct mdoc_arg **reta, int *pos, char *buf)
{
	struct mdoc_argv	  tmpv;
	struct mdoc_argv	**retv;
	const enum mdocargt	 *argtable;
	char			 *argname;
	int			  ipos, retc;
	char			  savechar;

	*reta = NULL;

	/* Which flags does this macro support? */

	assert(tok >= MDOC_Dd && tok < MDOC_MAX);
	argtable = mdocargs[tok].argvs;
	if (argtable == NULL)
		return;

	/* Loop over the flags on the input line. */

	ipos = *pos;
	while (buf[ipos] == '-') {

		/* Seek to the first unescaped space. */

		for (argname = buf + ++ipos; buf[ipos] != '\0'; ipos++)
			if (buf[ipos] == ' ' && buf[ipos - 1] != '\\')
				break;

		/*
		 * We want to nil-terminate the word to look it up.
		 * But we may not have a flag, in which case we need
		 * to restore the line as-is.  So keep around the
		 * stray byte, which we'll reset upon exiting.
		 */

		if ((savechar = buf[ipos]) != '\0')
			buf[ipos++] = '\0';

		/*
		 * Now look up the word as a flag.  Use temporary
		 * storage that we'll copy into the node's flags.
		 */

		while ((tmpv.arg = *argtable++) != MDOC_ARG_MAX)
			if ( ! strcmp(argname, mdoc_argnames[tmpv.arg]))
				break;

		/* If it isn't a flag, restore the saved byte. */

		if (tmpv.arg == MDOC_ARG_MAX) {
			if (savechar != '\0')
				buf[ipos - 1] = savechar;
			break;
		}

		/* Read to the next word (the first argument). */

		while (buf[ipos] == ' ')
			ipos++;

		/* Parse the arguments of the flag. */

		tmpv.line  = line;
		tmpv.pos   = *pos;
		tmpv.sz    = 0;
		tmpv.value = NULL;

		switch (argvflags[tmpv.arg]) {
		case ARGV_SINGLE:
			argv_single(mdoc, line, &tmpv, &ipos, buf);
			break;
		case ARGV_MULTI:
			argv_multi(mdoc, line, &tmpv, &ipos, buf);
			break;
		case ARGV_NONE:
			break;
		}

		/* Append to the return values. */

		if (*reta == NULL)
			*reta = mandoc_calloc(1, sizeof(**reta));

		retc = ++(*reta)->argc;
		retv = &(*reta)->argv;
		*retv = mandoc_reallocarray(*retv, retc, sizeof(**retv));
		memcpy(*retv + retc - 1, &tmpv, sizeof(**retv));

		/* Prepare for parsing the next flag. */

		*pos = ipos;
		argtable = mdocargs[tok].argvs;
	}
}

void
mdoc_argv_free(struct mdoc_arg *p)
{
	int		 i;

	if (NULL == p)
		return;

	if (p->refcnt) {
		--(p->refcnt);
		if (p->refcnt)
			return;
	}
	assert(p->argc);

	for (i = (int)p->argc - 1; i >= 0; i--)
		argn_free(p, i);

	free(p->argv);
	free(p);
}

static void
argn_free(struct mdoc_arg *p, int iarg)
{
	struct mdoc_argv *arg;
	int		  j;

	arg = &p->argv[iarg];

	if (arg->sz && arg->value) {
		for (j = (int)arg->sz - 1; j >= 0; j--)
			free(arg->value[j]);
		free(arg->value);
	}

	for (--p->argc; iarg < (int)p->argc; iarg++)
		p->argv[iarg] = p->argv[iarg+1];
}

enum margserr
mdoc_args(struct roff_man *mdoc, int line, int *pos,
	char *buf, enum roff_tok tok, char **v)
{
	struct roff_node *n;
	char		 *v_local;
	enum argsflag	  fl;

	if (v == NULL)
		v = &v_local;
	fl = tok == TOKEN_NONE ? ARGSFL_NONE : mdocargs[tok].flags;

	/*
	 * We know that we're in an `It', so it's reasonable to expect
	 * us to be sitting in a `Bl'.  Someday this may not be the case
	 * (if we allow random `It's sitting out there), so provide a
	 * safe fall-back into the default behaviour.
	 */

	if (tok == MDOC_It) {
		for (n = mdoc->last; n != NULL; n = n->parent) {
			if (n->tok != MDOC_Bl)
				continue;
			if (n->norm->Bl.type == LIST_column)
				fl = ARGSFL_TABSEP;
			break;
		}
	}

	return args(mdoc, line, pos, buf, fl, v);
}

static enum margserr
args(struct roff_man *mdoc, int line, int *pos,
		char *buf, enum argsflag fl, char **v)
{
	char		*p;
	int		 pairs;

	if (buf[*pos] == '\0') {
		if (mdoc->flags & MDOC_PHRASELIT &&
		    ! (mdoc->flags & MDOC_PHRASE)) {
			mandoc_msg(MANDOCERR_ARG_QUOTE,
			    mdoc->parse, line, *pos, NULL);
			mdoc->flags &= ~MDOC_PHRASELIT;
		}
		return ARGS_EOLN;
	}

	*v = buf + *pos;

	if (fl == ARGSFL_DELIM && args_checkpunct(buf, *pos))
		return ARGS_PUNCT;

	/*
	 * Tabs in `It' lines in `Bl -column' can't be escaped.
	 * Phrases are reparsed for `Ta' and other macros later.
	 */

	if (fl == ARGSFL_TABSEP) {
		if ((p = strchr(*v, '\t')) != NULL) {

			/*
			 * Words right before and right after
			 * tab characters are not parsed,
			 * unless there is a blank in between.
			 */

			if (p > buf && p[-1] != ' ')
				mdoc->flags |= MDOC_PHRASEQL;
			if (p[1] != ' ')
				mdoc->flags |= MDOC_PHRASEQN;

			/*
			 * One or more blanks after a tab cause
			 * one leading blank in the next column.
			 * So skip all but one of them.
			 */

			*pos += (int)(p - *v) + 1;
			while (buf[*pos] == ' ' && buf[*pos + 1] == ' ')
				(*pos)++;

			/*
			 * A tab at the end of an input line
			 * switches to the next column.
			 */

			if (buf[*pos] == '\0' || buf[*pos + 1] == '\0')
				mdoc->flags |= MDOC_PHRASEQN;
		} else {
			p = strchr(*v, '\0');
			if (p[-1] == ' ')
				mandoc_msg(MANDOCERR_SPACE_EOL,
				    mdoc->parse, line, *pos, NULL);
			*pos += (int)(p - *v);
		}

		/* Skip any trailing blank characters. */
		while (p > *v && p[-1] == ' ' &&
		    (p - 1 == *v || p[-2] != '\\'))
			p--;
		*p = '\0';

		return ARGS_PHRASE;
	}

	/*
	 * Process a quoted literal.  A quote begins with a double-quote
	 * and ends with a double-quote NOT preceded by a double-quote.
	 * NUL-terminate the literal in place.
	 * Collapse pairs of quotes inside quoted literals.
	 * Whitespace is NOT involved in literal termination.
	 */

	if (mdoc->flags & MDOC_PHRASELIT || buf[*pos] == '\"') {
		if ( ! (mdoc->flags & MDOC_PHRASELIT))
			*v = &buf[++(*pos)];

		if (mdoc->flags & MDOC_PHRASE)
			mdoc->flags |= MDOC_PHRASELIT;

		pairs = 0;
		for ( ; buf[*pos]; (*pos)++) {
			/* Move following text left after quoted quotes. */
			if (pairs)
				buf[*pos - pairs] = buf[*pos];
			if ('\"' != buf[*pos])
				continue;
			/* Unquoted quotes end quoted args. */
			if ('\"' != buf[*pos + 1])
				break;
			/* Quoted quotes collapse. */
			pairs++;
			(*pos)++;
		}
		if (pairs)
			buf[*pos - pairs] = '\0';

		if (buf[*pos] == '\0') {
			if ( ! (mdoc->flags & MDOC_PHRASE))
				mandoc_msg(MANDOCERR_ARG_QUOTE,
				    mdoc->parse, line, *pos, NULL);
			return ARGS_QWORD;
		}

		mdoc->flags &= ~MDOC_PHRASELIT;
		buf[(*pos)++] = '\0';

		if ('\0' == buf[*pos])
			return ARGS_QWORD;

		while (' ' == buf[*pos])
			(*pos)++;

		if ('\0' == buf[*pos])
			mandoc_msg(MANDOCERR_SPACE_EOL, mdoc->parse,
			    line, *pos, NULL);

		return ARGS_QWORD;
	}

	p = &buf[*pos];
	*v = mandoc_getarg(mdoc->parse, &p, line, pos);

	/*
	 * After parsing the last word in this phrase,
	 * tell lookup() whether or not to interpret it.
	 */

	if (*p == '\0' && mdoc->flags & MDOC_PHRASEQL) {
		mdoc->flags &= ~MDOC_PHRASEQL;
		mdoc->flags |= MDOC_PHRASEQF;
	}
	return ARGS_WORD;
}

/*
 * Check if the string consists only of space-separated closing
 * delimiters.  This is a bit of a dance: the first must be a close
 * delimiter, but it may be followed by middle delimiters.  Arbitrary
 * whitespace may separate these tokens.
 */
static int
args_checkpunct(const char *buf, int i)
{
	int		 j;
	char		 dbuf[DELIMSZ];
	enum mdelim	 d;

	/* First token must be a close-delimiter. */

	for (j = 0; buf[i] && ' ' != buf[i] && j < DELIMSZ; j++, i++)
		dbuf[j] = buf[i];

	if (DELIMSZ == j)
		return 0;

	dbuf[j] = '\0';
	if (DELIM_CLOSE != mdoc_isdelim(dbuf))
		return 0;

	while (' ' == buf[i])
		i++;

	/* Remaining must NOT be open/none. */

	while (buf[i]) {
		j = 0;
		while (buf[i] && ' ' != buf[i] && j < DELIMSZ)
			dbuf[j++] = buf[i++];

		if (DELIMSZ == j)
			return 0;

		dbuf[j] = '\0';
		d = mdoc_isdelim(dbuf);
		if (DELIM_NONE == d || DELIM_OPEN == d)
			return 0;

		while (' ' == buf[i])
			i++;
	}

	return '\0' == buf[i];
}

static void
argv_multi(struct roff_man *mdoc, int line,
		struct mdoc_argv *v, int *pos, char *buf)
{
	enum margserr	 ac;
	char		*p;

	for (v->sz = 0; ; v->sz++) {
		if (buf[*pos] == '-')
			break;
		ac = args(mdoc, line, pos, buf, ARGSFL_NONE, &p);
		if (ac == ARGS_EOLN)
			break;

		if (v->sz % MULTI_STEP == 0)
			v->value = mandoc_reallocarray(v->value,
			    v->sz + MULTI_STEP, sizeof(char *));

		v->value[(int)v->sz] = mandoc_strdup(p);
	}
}

static void
argv_single(struct roff_man *mdoc, int line,
		struct mdoc_argv *v, int *pos, char *buf)
{
	enum margserr	 ac;
	char		*p;

	ac = args(mdoc, line, pos, buf, ARGSFL_NONE, &p);
	if (ac == ARGS_EOLN)
		return;

	v->sz = 1;
	v->value = mandoc_malloc(sizeof(char *));
	v->value[0] = mandoc_strdup(p);
}
@


1.68
log
@Parser reorg:
Generate the first node on the roff level: .br
Fix some column numbers in diagnostic messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.67 2017/04/24 23:06:09 schwarze Exp $ */
a266 1
	{ ARGSFL_NONE, NULL }, /* ll */
@


1.67
log
@Continue parser unification:
* Make enum rofft an internal interface as enum roff_tok in "roff.h".
* Represent mdoc and man macros in enum roff_tok.
* Make TOKEN_NONE a proper enum value and use it throughout.
* Put the prologue macros first in the macro tables.
* Unify mdoc_macroname[] and man_macroname[] into roff_name[].
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.66 2017/03/03 15:04:51 schwarze Exp $ */
a263 1
	{ ARGSFL_NONE, NULL }, /* br */
@


1.66
log
@Markdown output mode helped us to find the first parser bug (as such,
this bug could cause wrong output in other modes as well):
Do not misinterpret tab characters as .Ta macros when they appear
on non-column .It lines in non-column .Bl lists that are nested
inside a parent .Bl -column list.  (Admittedly, such constructions
are not very useful; don't use them!)
Found by tb@@ with afl(1) because the resulting tree corruption
triggered an assertion in the markdown output module.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.65 2016/08/28 16:13:51 schwarze Exp $ */
d145 1
a145 2
static	const struct mdocarg mdocargs[MDOC_MAX] = {
	{ ARGSFL_DELIM, NULL }, /* Ap */
d161 1
d270 1
d279 1
a279 1
mdoc_argv(struct roff_man *mdoc, int line, int tok,
d293 1
d418 1
a418 1
	char *buf, int tok, char **v)
@


1.65
log
@If a line inside .Bl -column starts with a tab character
and there was no preceding .It macro, do not read the byte
before the beginning of the line buffer.
Found by tb@@ with afl@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.64 2016/07/15 18:02:32 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2012, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
a424 2
	if (tok != MDOC_It)
		return args(mdoc, line, pos, buf, fl, v);
d433 5
a437 3
	for (n = mdoc->last; n; n = n->parent)
		if (MDOC_Bl == n->tok)
			if (LIST_column == n->norm->Bl.type) {
d439 3
a441 2
				break;
			}
@


1.64
log
@add missing prototypes, no code change;
noticed by Christos Zoulas with -Wmissing-prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.63 2015/10/17 00:19:58 schwarze Exp $ */
d481 1
a481 1
			if (p[-1] != ' ')
@


1.63
log
@Very tricky diff to fix macro interpretation and spacing around tabs
in .Bl -column; it took me more than a day to get this right.
Triggered by a loosely related bug report from tim@@.

The lesson for you is:  Use .Ta macros in .Bl -column, avoid tabs,
or you are in for surprises:  The last word before a tab is not
interpreted as a macro (unless there is a blank in between), the
first word after a tab isn't either (unless there is a blank in
between), and a blank after a tab causes a leading blank in the
respective output cell.  Yes, "blank", "tab", "blank tab" and "tab
blank" all have different semantics; if you write code relying on
that, good luck maintaining it afterwards...
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.62 2015/10/15 22:45:07 schwarze Exp $ */
d30 1
@


1.62
log
@Simplify the part of args() that is handling .Bl -column phrases:
Delete manual "Ta" handling because macro handling should
not be done in an argument parser but should be left to the
macro parsers, which exist anyway and work well.
No functional change, minus 40 lines of code.

Confusing and redundant code found while investigating
an old bug report from tim@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.61 2015/10/06 18:30:44 schwarze Exp $ */
a449 1
	enum margserr	 rc;
d453 1
a453 1
		    ! (mdoc->flags & MDOC_PPHRASE)) {
d473 18
a490 1
			/* Skip any blank characters after the tab. */
d492 1
a492 1
			while (buf[*pos] == ' ')
d494 8
a501 1
			rc = ARGS_PPHRASE;
a507 1
			rc = ARGS_PEND;
d516 1
a516 1
		return rc;
d527 2
a528 2
	if (MDOC_PHRASELIT & mdoc->flags || '\"' == buf[*pos]) {
		if ( ! (MDOC_PHRASELIT & mdoc->flags))
d531 1
a531 1
		if (MDOC_PPHRASE & mdoc->flags)
d551 4
a554 5
		if ('\0' == buf[*pos]) {
			if (MDOC_PPHRASE & mdoc->flags)
				return ARGS_QWORD;
			mandoc_msg(MANDOCERR_ARG_QUOTE,
			    mdoc->parse, line, *pos, NULL);
d577 9
@


1.61
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.60 2015/04/19 13:59:37 schwarze Exp $ */
d448 1
a448 1
	char		*p, *pp;
d452 3
a454 9
	if ('\0' == buf[*pos]) {
		if (MDOC_PPHRASE & mdoc->flags)
			return ARGS_EOLN;
		/*
		 * If we're not in a partial phrase and the flag for
		 * being a phrase literal is still set, the punctuation
		 * is unterminated.
		 */
		if (MDOC_PHRASELIT & mdoc->flags)
d457 2
a458 2

		mdoc->flags &= ~MDOC_PHRASELIT;
d462 1
a462 1
	*v = &buf[*pos];
d464 2
a465 3
	if (ARGSFL_DELIM == fl)
		if (args_checkpunct(buf, *pos))
			return ARGS_PUNCT;
d468 2
a469 4
	 * First handle TABSEP items, restricted to `Bl -column'.  This
	 * ignores conventional token parsing and instead uses tabs or
	 * `Ta' macros to separate phrases.  Phrases are parsed again
	 * for arguments at a later phase.
d472 6
a477 28
	if (ARGSFL_TABSEP == fl) {
		/* Scan ahead to tab (can't be escaped). */
		p = strchr(*v, '\t');
		pp = NULL;

		/* Scan ahead to unescaped `Ta'. */
		if ( ! (MDOC_PHRASELIT & mdoc->flags))
			for (pp = *v; ; pp++) {
				if (NULL == (pp = strstr(pp, "Ta")))
					break;
				if (pp > *v && ' ' != *(pp - 1))
					continue;
				if (' ' == *(pp + 2) || '\0' == *(pp + 2))
					break;
			}

		/* By default, assume a phrase. */
		rc = ARGS_PHRASE;

		/*
		 * Adjust new-buffer position to be beyond delimiter
		 * mark (e.g., Ta -> end + 2).
		 */
		if (p && pp) {
			*pos += pp < p ? 2 : 1;
			rc = pp < p ? ARGS_PHRASE : ARGS_PPHRASE;
			p = pp < p ? pp : p;
		} else if (p && ! pp) {
a478 4
			*pos += 1;
		} else if (pp && ! p) {
			p = pp;
			*pos += 2;
d480 5
a485 16
			p = strchr(*v, 0);
		}

		/* Whitespace check for eoln case... */
		if ('\0' == *p && ' ' == *(p - 1))
			mandoc_msg(MANDOCERR_SPACE_EOL, mdoc->parse,
			    line, *pos, NULL);

		*pos += (int)(p - *v);

		/* Strip delimiter's preceding whitespace. */
		pp = p - 1;
		while (pp > *v && ' ' == *pp) {
			if (pp > *v && '\\' == *(pp - 1))
				break;
			pp--;
a486 1
		*(pp + 1) = 0;
d488 5
a492 3
		/* Strip delimiter's proceeding whitespace. */
		for (pp = &buf[*pos]; ' ' == *pp; pp++, (*pos)++)
			/* Skip ahead. */ ;
@


1.60
log
@Decouple the token code for "no request or macro" from the individual
high-level parsers to allow further unification of functions that
only need to recognize this code, but that don't care about different
high-level macrosets beyond that.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.59 2015/04/18 16:04:40 schwarze Exp $ */
d425 1
a425 1
		return(args(mdoc, line, pos, buf, fl, v));
d441 1
a441 1
	return(args(mdoc, line, pos, buf, fl, v));
d454 1
a454 1
			return(ARGS_EOLN);
d465 1
a465 1
		return(ARGS_EOLN);
d472 1
a472 1
			return(ARGS_PUNCT);
d539 1
a539 1
		return(rc);
d576 1
a576 1
				return(ARGS_QWORD);
d579 1
a579 1
			return(ARGS_QWORD);
d586 1
a586 1
			return(ARGS_QWORD);
d595 1
a595 1
		return(ARGS_QWORD);
d601 1
a601 1
	return(ARGS_WORD);
d623 1
a623 1
		return(0);
d627 1
a627 1
		return(0);
d640 1
a640 1
			return(0);
d645 1
a645 1
			return(0);
d651 1
a651 1
	return('\0' == buf[i]);
@


1.59
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.58 2015/04/02 22:06:17 schwarze Exp $ */
d423 1
a423 1
	fl = tok == MDOC_MAX ? ARGSFL_NONE : mdocargs[tok].flags;
@


1.58
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.57 2015/04/02 21:03:18 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2012, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d53 1
a53 1
static	enum margserr	 args(struct mdoc *, int, int *,
d56 1
a56 1
static	void		 argv_multi(struct mdoc *, int,
d58 1
a58 1
static	void		 argv_single(struct mdoc *, int,
d277 1
a277 1
mdoc_argv(struct mdoc *mdoc, int line, int tok,
d414 1
a414 1
mdoc_args(struct mdoc *mdoc, int line, int *pos,
d445 1
a445 1
args(struct mdoc *mdoc, int line, int *pos,
d655 1
a655 1
argv_multi(struct mdoc *mdoc, int line,
d677 1
a677 1
argv_single(struct mdoc *mdoc, int line,
@


1.57
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.56 2015/02/04 18:58:09 schwarze Exp $ */
d277 1
a277 1
mdoc_argv(struct mdoc *mdoc, int line, enum mdoct tok,
d415 1
a415 1
		char *buf, enum mdoct tok, char **v)
d417 1
a417 1
	struct mdoc_node *n;
@


1.56
log
@fix column numbers of macro arguments in messages
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.55 2014/11/29 03:37:28 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d25 3
d29 1
a29 2
#include "mandoc.h"
#include "mandoc_aux.h"
a30 1
#include "libmandoc.h"
@


1.55
log
@Provide a helper function macro_or_word() and use it to prune the
same chunk of argument parsing code out of five of the eight callback
functions.  The other three have too much special handling to
participate.
As a bonus, let lookup() and mdoc_args() deal with line macros and
retire the lookup_raw() helper and the mdoc_zargs() internal interface
function.
No functional change, minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.54 2014/11/28 23:20:55 schwarze Exp $ */
d340 1
a340 1
		tmpv.pos   = ipos;
@


1.54
log
@Fold the loop around mdoc_argv() into the function itself,
it was the same in all four cases.  As a bonus, get rid
of one enum type that was used for internal communication.
No functional change, minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_argv.c,v 1.53 2014/11/28 03:13:58 schwarze Exp $ */
a412 7
mdoc_zargs(struct mdoc *mdoc, int line, int *pos, char *buf, char **v)
{

	return(args(mdoc, line, pos, buf, ARGSFL_NONE, v));
}

enum margserr
d416 2
a418 3
	struct mdoc_node *n;

	fl = mdocargs[tok].flags;
d420 4
a423 1
	if (MDOC_It != tok)
@


1.53
log
@Simplify the code by making various mdoc parser helper functions void.
No functional change, minus 130 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 2012 Ingo Schwarze <schwarze@@openbsd.org>
d271 3
a273 3
 * Parse an argument from line text.  This comes in the form of -key
 * [value0...], which may either have a single mandatory value, at least
 * one mandatory value, an optional single value, or no value.
d275 1
a275 1
enum margverr
d277 1
a277 1
		struct mdoc_arg **v, int *pos, char *buf)
d279 6
a284 11
	char		 *p, sv;
	struct mdoc_argv tmp;
	struct mdoc_arg	 *arg;
	const enum mdocargt *ap;

	if ('\0' == buf[*pos])
		return(ARGV_EOLN);
	else if (NULL == (ap = mdocargs[tok].argvs))
		return(ARGV_WORD);
	else if ('-' != buf[*pos])
		return(ARGV_WORD);
d286 1
a286 1
	/* Seek to the first unescaped space. */
d288 1
a288 1
	p = &buf[++(*pos)];
d290 3
a292 1
	assert(*pos > 0);
d294 6
a299 3
	for ( ; buf[*pos] ; (*pos)++)
		if (' ' == buf[*pos] && '\\' != buf[*pos - 1])
			break;
d301 3
a303 20
	/*
	 * We want to nil-terminate the word to look it up (it's easier
	 * that way).  But we may not have a flag, in which case we need
	 * to restore the line as-is.  So keep around the stray byte,
	 * which we'll reset upon exiting (if necessary).
	 */

	if ('\0' != (sv = buf[*pos]))
		buf[(*pos)++] = '\0';

	/*
	 * Now look up the word as a flag.  Use temporary storage that
	 * we'll copy into the node's flags, if necessary.
	 */

	memset(&tmp, 0, sizeof(struct mdoc_argv));

	tmp.line = line;
	tmp.pos = *pos;
	tmp.arg = MDOC_ARG_MAX;
d305 9
a313 3
	while (MDOC_ARG_MAX != (tmp.arg = *ap++))
		if (0 == strcmp(p, mdoc_argnames[tmp.arg]))
			break;
a314 1
	if (MDOC_ARG_MAX == tmp.arg) {
d316 2
a317 2
		 * The flag was not found.
		 * Restore saved zeroed byte and return as a word.
a318 4
		if (sv)
			buf[*pos - 1] = sv;
		return(ARGV_WORD);
	}
d320 18
a337 1
	/* Read to the next word (the argument). */
d339 4
a342 2
	while (buf[*pos] && ' ' == buf[*pos])
		(*pos)++;
d344 12
a355 10
	switch (argvflags[tmp.arg]) {
	case ARGV_SINGLE:
		argv_single(mdoc, line, &tmp, pos, buf);
		break;
	case ARGV_MULTI:
		argv_multi(mdoc, line, &tmp, pos, buf);
		break;
	case ARGV_NONE:
		break;
	}
d357 2
a358 2
	if (NULL == (arg = *v))
		arg = *v = mandoc_calloc(1, sizeof(struct mdoc_arg));
d360 4
a363 3
	arg->argc++;
	arg->argv = mandoc_reallocarray(arg->argv,
	    arg->argc, sizeof(struct mdoc_argv));
d365 1
a365 2
	memcpy(&arg->argv[(int)arg->argc - 1], &tmp,
	    sizeof(struct mdoc_argv));
d367 3
a369 1
	return(ARGV_ARG);
@


1.52
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.51 2014/07/02 03:47:07 schwarze Exp $ */
d55 1
a55 1
static	int		 argv_multi(struct mdoc *, int,
d57 1
a57 1
static	int		 argv_single(struct mdoc *, int,
d343 1
a343 2
		if ( ! argv_single(mdoc, line, &tmp, pos, buf))
			return(ARGV_ERROR);
d346 1
a346 2
		if ( ! argv_multi(mdoc, line, &tmp, pos, buf))
			return(ARGV_ERROR);
d651 1
a651 1
static int
d659 1
a659 1
		if ('-' == buf[*pos])
d662 1
a662 3
		if (ARGS_ERROR == ac)
			return(0);
		else if (ARGS_EOLN == ac)
d665 1
a665 1
		if (0 == v->sz % MULTI_STEP)
a670 2

	return(1);
d673 1
a673 1
static int
d681 2
a682 4
	if (ARGS_ERROR == ac)
		return(0);
	if (ARGS_EOLN == ac)
		return(1);
a686 2

	return(1);
@


1.51
log
@Implement the obsolete macros .En .Es .Fr .Ot for backward compatibility,
since this is hardly more complicated than explicitly ignoring them
as we did in the past.  Of course, do not use them!
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.50 2014/04/23 21:06:33 schwarze Exp $ */
d460 2
a461 1
			mdoc_pmsg(mdoc, line, *pos, MANDOCERR_BADQUOTE);
d520 2
a521 1
			mdoc_pmsg(mdoc, line, *pos, MANDOCERR_EOLNSPACE);
d576 2
a577 1
			mdoc_pmsg(mdoc, line, *pos, MANDOCERR_BADQUOTE);
d591 2
a592 1
			mdoc_pmsg(mdoc, line, *pos, MANDOCERR_EOLNSPACE);
@


1.50
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
* Change eight reallocs to reallocarray to be safe from overflows.
* Change one malloc to reallocarray to be safe from overflows.
* Change one calloc to reallocarray, no zeroing needed.
* Change the order of arguments of three callocs (aesthetical).
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.49 2014/04/20 16:44:44 schwarze Exp $ */
d178 1
a178 1
	{ ARGSFL_NONE, NULL }, /* Ot */
d248 1
a248 1
	{ ARGSFL_NONE, NULL }, /* Fr */
d259 1
a259 1
	{ ARGSFL_NONE, NULL }, /* En */
@


1.49
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.48 2014/03/30 19:47:32 schwarze Exp $ */
d358 2
a359 2
	arg->argv = mandoc_realloc(arg->argv,
	    arg->argc * sizeof(struct mdoc_argv));
d666 2
a667 2
			v->value = mandoc_realloc(v->value,
			    (v->sz + MULTI_STEP) * sizeof(char *));
@


1.48
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.47 2014/03/21 22:17:01 schwarze Exp $ */
d32 1
a32 1
#define	DELIMSZ	  	 6 /* max possible size of a delimiter */
d52 1
a52 1
static	enum margserr	 args(struct mdoc *, int, int *, 
d55 1
a55 1
static	int		 argv_multi(struct mdoc *, int, 
d57 1
a57 1
static	int		 argv_single(struct mdoc *, int, 
d149 2
a150 2
	{ ARGSFL_NONE, NULL }, /* Ss */ 
	{ ARGSFL_NONE, NULL }, /* Pp */ 
d158 1
a158 1
	{ ARGSFL_DELIM, NULL }, /* Ad */ 
d163 3
a165 3
	{ ARGSFL_DELIM, NULL }, /* Dv */ 
	{ ARGSFL_DELIM, NULL }, /* Er */ 
	{ ARGSFL_DELIM, NULL }, /* Ev */ 
d167 2
a168 2
	{ ARGSFL_DELIM, NULL }, /* Fa */ 
	{ ARGSFL_NONE, NULL }, /* Fd */ 
d170 4
a173 4
	{ ARGSFL_DELIM, NULL }, /* Fn */ 
	{ ARGSFL_DELIM, NULL }, /* Ft */ 
	{ ARGSFL_DELIM, NULL }, /* Ic */ 
	{ ARGSFL_DELIM, NULL }, /* In */ 
d175 2
a176 2
	{ ARGSFL_NONE, NULL }, /* Nd */ 
	{ ARGSFL_DELIM, NULL }, /* Nm */ 
d181 1
a181 1
	{ ARGSFL_DELIM, NULL }, /* St */ 
d183 1
a183 1
	{ ARGSFL_DELIM, NULL }, /* Vt */ 
d201 1
a201 1
	{ ARGSFL_NONE, args_Bf }, /* Bf */ 
d212 1
a212 1
	{ ARGSFL_DELIM, NULL }, /* Em */ 
d240 2
a241 2
	{ ARGSFL_NONE, NULL }, /* Fo */ 
	{ ARGSFL_DELIM, NULL }, /* Fc */ 
d301 1
a301 1
	/* 
d308 1
a308 1
	if ('\0' != (sv = buf[*pos])) 
d327 1
a327 1
		/* 
d342 1
a342 1
	case (ARGV_SINGLE):
d346 1
a346 1
	case (ARGV_MULTI):
d350 1
a350 1
	case (ARGV_NONE):
d358 2
a359 2
	arg->argv = mandoc_realloc
		(arg->argv, arg->argc * sizeof(struct mdoc_argv));
d361 2
a362 2
	memcpy(&arg->argv[(int)arg->argc - 1], 
			&tmp, sizeof(struct mdoc_argv));
d398 1
a398 1
		for (j = (int)arg->sz - 1; j >= 0; j--) 
d415 1
a415 1
mdoc_args(struct mdoc *mdoc, int line, int *pos, 
d444 1
a444 1
args(struct mdoc *mdoc, int line, int *pos, 
d485 1
a485 1
		if ( ! (MDOC_PHRASELIT & mdoc->flags)) 
d498 1
a498 1
		/* 
d599 1
a599 1
/* 
d628 1
a628 1
	
d650 1
a650 1
argv_multi(struct mdoc *mdoc, int line, 
d666 2
a667 2
			v->value = mandoc_realloc(v->value, 
				(v->sz + MULTI_STEP) * sizeof(char *));
d676 1
a676 1
argv_single(struct mdoc *mdoc, int line, 
@


1.47
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.46 2013/12/25 00:50:03 schwarze Exp $ */
d266 1
@


1.46
log
@s/[Nn]ull/NUL/ in comments where appropriate;
suggested by Thomas Klausner <wiz @@ NetBSD dot org>.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.45 2013/12/22 14:06:29 schwarze Exp $ */
d27 1
@


1.45
log
@Fix end-of-sentence spacing after the DragonFly text production macro.
Patch from Franco Fichtner <franco at lastsummer dot de>.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.44 2013/12/15 23:56:21 schwarze Exp $ */
d535 1
a535 1
	} 
d537 1
a537 1
	/* 
d540 1
a540 1
	 * Null-terminate the literal in place.
@


1.44
log
@In quoted macro arguments, double quotes can be quoted by doubling them.
For a long time, we handle this in roff(7) and man(7) macros.
Now add correct handling for the mdoc(7) case, too.

Closely based on a patch by Tsugutomo dot ENAMI at jp dot sony dot com,
see http://gnats.netbsd.org/cgi-bin/query-pr-single.pl?number=48438
received via Thomas Klausner (wiz@@), slightly tweaked by me.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.43 2012/11/18 00:05:28 schwarze Exp $ */
d259 1
a259 1
	{ ARGSFL_NONE, NULL }, /* Dx */
@


1.43
log
@Fix four small whitespace issues related to trailing punctuation
reported by Nicolas Joly <njoly at pasteur dot fr>:

- add EOS spacing after trailing punctuation after .Cd, .Fc, and .Lb
- suppress spacing before trailing punctuation after .Fd
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.42 2012/11/17 00:25:20 schwarze Exp $ */
d446 1
d540 2
d552 1
d554 3
d559 1
d562 2
d566 2
@


1.42
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.41 2012/11/16 18:40:39 schwarze Exp $ */
d160 1
a160 1
	{ ARGSFL_NONE, NULL }, /* Cd */
d240 1
a240 1
	{ ARGSFL_NONE, NULL }, /* Fc */ 
d249 1
a249 1
	{ ARGSFL_NONE, NULL }, /* Lb */
@


1.41
log
@Two more macros (.Ap and .In) do trailing delimiter handling.
This fixes the end of sentence spacing in open(2)
and in about 150 pages in the NetBSD base system.

Reported by Nicolas Joly <njoly a pasteur point fr>, merci!
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.40 2012/04/15 10:31:00 schwarze Exp $ */
d274 1
a274 1
mdoc_argv(struct mdoc *m, int line, enum mdoct tok,
d341 1
a341 1
		if ( ! argv_single(m, line, &tmp, pos, buf))
d345 1
a345 1
		if ( ! argv_multi(m, line, &tmp, pos, buf))
d406 1
a406 1
mdoc_zargs(struct mdoc *m, int line, int *pos, char *buf, char **v)
d409 1
a409 1
	return(args(m, line, pos, buf, ARGSFL_NONE, v));
d413 1
a413 1
mdoc_args(struct mdoc *m, int line, int *pos, 
d422 1
a422 1
		return(args(m, line, pos, buf, fl, v));
d431 1
a431 1
	for (n = m->last; n; n = n->parent)
d438 1
a438 1
	return(args(m, line, pos, buf, fl, v));
d442 1
a442 1
args(struct mdoc *m, int line, int *pos, 
d449 1
a449 1
		if (MDOC_PPHRASE & m->flags)
d456 2
a457 2
		if (MDOC_PHRASELIT & m->flags)
			mdoc_pmsg(m, line, *pos, MANDOCERR_BADQUOTE);
d459 1
a459 1
		m->flags &= ~MDOC_PHRASELIT;
d482 1
a482 1
		if ( ! (MDOC_PHRASELIT & m->flags)) 
d516 1
a516 1
			mdoc_pmsg(m, line, *pos, MANDOCERR_EOLNSPACE);
d542 2
a543 2
	if (MDOC_PHRASELIT & m->flags || '\"' == buf[*pos]) {
		if ( ! (MDOC_PHRASELIT & m->flags))
d546 2
a547 2
		if (MDOC_PPHRASE & m->flags)
			m->flags |= MDOC_PHRASELIT;
d558 1
a558 1
			if (MDOC_PPHRASE & m->flags)
d560 1
a560 1
			mdoc_pmsg(m, line, *pos, MANDOCERR_BADQUOTE);
d564 1
a564 1
		m->flags &= ~MDOC_PHRASELIT;
d574 1
a574 1
			mdoc_pmsg(m, line, *pos, MANDOCERR_EOLNSPACE);
d580 1
a580 1
	*v = mandoc_getarg(m->parse, &p, line, pos);
d636 1
a636 1
argv_multi(struct mdoc *m, int line, 
d645 1
a645 1
		ac = args(m, line, pos, buf, ARGSFL_NONE, &p);
d662 1
a662 1
argv_single(struct mdoc *m, int line, 
d668 1
a668 1
	ac = args(m, line, pos, buf, ARGSFL_NONE, &p);
@


1.40
log
@Two bugfixes regarding the -width and -offset macro arguments:
1) They consume the next argument even if it starts with a dash.
2) When -width is the last argument on the line such that the
actual width argument is missing, downgrade from a fatal to a
non-fatal error, just like for -offset.  The formatting still
doesn't agree with groff, but at least we don't die any longer.

Item 2 was observed and that part of the patch coded by kristaps@@,
who found lots of instances of this particular formatting error
in Mac OSX manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.39 2011/07/05 04:12:41 schwarze Exp $ */
d4 1
d143 1
a143 1
	{ ARGSFL_NONE, NULL }, /* Ap */
d172 1
a172 1
	{ ARGSFL_NONE, NULL }, /* In */ 
@


1.39
log
@Sync to bsd.lv (all coded by kristaps@@):
 - mdoc(7): fix an assertion if the first line after .Bd -column
   starts with a blank, and some simplifications in mdoc_argv.c
 - man(7): literal mode ends at .SH and .SS (bug reported by naddy@@)
 - allow .RS/.RE blocks to nest (bug reported by dcoppa@@ and gsoares@@)
 - improve vertical spacing of man(7) blocks
 - roff(7): clear user-defined strings when starting a new file
 - correct ID tags in -T[x]html
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.38 2011/05/29 21:22:18 schwarze Exp $ */
d41 1
a41 2
	ARGV_MULTI, /* multiple args (e.g., -column xxx yyy) */
	ARGV_OPT_SINGLE /* optional arg (e.g., -offset [xxx]) */
a54 2
static	int		 argv_opt_single(struct mdoc *, int, 
				struct mdoc_argv *, int *, char *);
d65 1
a65 1
	ARGV_OPT_SINGLE, /* MDOC_Offset */
a346 4
	case (ARGV_OPT_SINGLE):
		if ( ! argv_opt_single(m, line, &tmp, pos, buf))
			return(ARGV_ERROR);
		break;
d661 1
a661 1
argv_opt_single(struct mdoc *m, int line, 
a666 3
	if ('-' == buf[*pos])
		return(1);

a671 24

	v->sz = 1;
	v->value = mandoc_malloc(sizeof(char *));
	v->value[0] = mandoc_strdup(p);

	return(1);
}

static int
argv_single(struct mdoc *m, int line, 
		struct mdoc_argv *v, int *pos, char *buf)
{
	int		 ppos;
	enum margserr	 ac;
	char		*p;

	ppos = *pos;

	ac = args(m, line, pos, buf, ARGSFL_NONE, &p);
	if (ARGS_EOLN == ac) {
		mdoc_pmsg(m, line, ppos, MANDOCERR_SYNTARGVCOUNT);
		return(0);
	} else if (ARGS_ERROR == ac)
		return(0);
@


1.38
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.37 2011/04/24 16:22:02 schwarze Exp $ */
a19 1
#include <ctype.h>
d45 6
a50 1
static	enum mdocargt	 argv_a2arg(enum mdoct, const char *);
d54 1
a54 3
static	int		 argv(struct mdoc *, int, 
				struct mdoc_argv *, int *, char *);
static	int		 argv_single(struct mdoc *, int, 
d58 1
a58 1
static	int		 argv_multi(struct mdoc *, int, 
a59 1
static	void		 argn_free(struct mdoc_arg *, int);
a89 125
static	const enum argsflag argflags[MDOC_MAX] = {
	ARGSFL_NONE, /* Ap */
	ARGSFL_NONE, /* Dd */
	ARGSFL_NONE, /* Dt */
	ARGSFL_NONE, /* Os */
	ARGSFL_NONE, /* Sh */
	ARGSFL_NONE, /* Ss */ 
	ARGSFL_NONE, /* Pp */ 
	ARGSFL_DELIM, /* D1 */
	ARGSFL_DELIM, /* Dl */
	ARGSFL_NONE, /* Bd */
	ARGSFL_NONE, /* Ed */
	ARGSFL_NONE, /* Bl */
	ARGSFL_NONE, /* El */
	ARGSFL_NONE, /* It */
	ARGSFL_DELIM, /* Ad */ 
	ARGSFL_DELIM, /* An */
	ARGSFL_DELIM, /* Ar */
	ARGSFL_NONE, /* Cd */
	ARGSFL_DELIM, /* Cm */
	ARGSFL_DELIM, /* Dv */ 
	ARGSFL_DELIM, /* Er */ 
	ARGSFL_DELIM, /* Ev */ 
	ARGSFL_NONE, /* Ex */
	ARGSFL_DELIM, /* Fa */ 
	ARGSFL_NONE, /* Fd */ 
	ARGSFL_DELIM, /* Fl */
	ARGSFL_DELIM, /* Fn */ 
	ARGSFL_DELIM, /* Ft */ 
	ARGSFL_DELIM, /* Ic */ 
	ARGSFL_NONE, /* In */ 
	ARGSFL_DELIM, /* Li */
	ARGSFL_NONE, /* Nd */ 
	ARGSFL_DELIM, /* Nm */ 
	ARGSFL_DELIM, /* Op */
	ARGSFL_NONE, /* Ot */
	ARGSFL_DELIM, /* Pa */
	ARGSFL_NONE, /* Rv */
	ARGSFL_DELIM, /* St */ 
	ARGSFL_DELIM, /* Va */
	ARGSFL_DELIM, /* Vt */ 
	ARGSFL_DELIM, /* Xr */
	ARGSFL_NONE, /* %A */
	ARGSFL_NONE, /* %B */
	ARGSFL_NONE, /* %D */
	ARGSFL_NONE, /* %I */
	ARGSFL_NONE, /* %J */
	ARGSFL_NONE, /* %N */
	ARGSFL_NONE, /* %O */
	ARGSFL_NONE, /* %P */
	ARGSFL_NONE, /* %R */
	ARGSFL_NONE, /* %T */
	ARGSFL_NONE, /* %V */
	ARGSFL_DELIM, /* Ac */
	ARGSFL_NONE, /* Ao */
	ARGSFL_DELIM, /* Aq */
	ARGSFL_DELIM, /* At */
	ARGSFL_DELIM, /* Bc */
	ARGSFL_NONE, /* Bf */ 
	ARGSFL_NONE, /* Bo */
	ARGSFL_DELIM, /* Bq */
	ARGSFL_DELIM, /* Bsx */
	ARGSFL_DELIM, /* Bx */
	ARGSFL_NONE, /* Db */
	ARGSFL_DELIM, /* Dc */
	ARGSFL_NONE, /* Do */
	ARGSFL_DELIM, /* Dq */
	ARGSFL_DELIM, /* Ec */
	ARGSFL_NONE, /* Ef */
	ARGSFL_DELIM, /* Em */ 
	ARGSFL_NONE, /* Eo */
	ARGSFL_DELIM, /* Fx */
	ARGSFL_DELIM, /* Ms */
	ARGSFL_DELIM, /* No */
	ARGSFL_DELIM, /* Ns */
	ARGSFL_DELIM, /* Nx */
	ARGSFL_DELIM, /* Ox */
	ARGSFL_DELIM, /* Pc */
	ARGSFL_DELIM, /* Pf */
	ARGSFL_NONE, /* Po */
	ARGSFL_DELIM, /* Pq */
	ARGSFL_DELIM, /* Qc */
	ARGSFL_DELIM, /* Ql */
	ARGSFL_NONE, /* Qo */
	ARGSFL_DELIM, /* Qq */
	ARGSFL_NONE, /* Re */
	ARGSFL_NONE, /* Rs */
	ARGSFL_DELIM, /* Sc */
	ARGSFL_NONE, /* So */
	ARGSFL_DELIM, /* Sq */
	ARGSFL_NONE, /* Sm */
	ARGSFL_DELIM, /* Sx */
	ARGSFL_DELIM, /* Sy */
	ARGSFL_DELIM, /* Tn */
	ARGSFL_DELIM, /* Ux */
	ARGSFL_DELIM, /* Xc */
	ARGSFL_NONE, /* Xo */
	ARGSFL_NONE, /* Fo */ 
	ARGSFL_NONE, /* Fc */ 
	ARGSFL_NONE, /* Oo */
	ARGSFL_DELIM, /* Oc */
	ARGSFL_NONE, /* Bk */
	ARGSFL_NONE, /* Ek */
	ARGSFL_NONE, /* Bt */
	ARGSFL_NONE, /* Hf */
	ARGSFL_NONE, /* Fr */
	ARGSFL_NONE, /* Ud */
	ARGSFL_NONE, /* Lb */
	ARGSFL_NONE, /* Lp */
	ARGSFL_DELIM, /* Lk */
	ARGSFL_DELIM, /* Mt */
	ARGSFL_DELIM, /* Brq */
	ARGSFL_NONE, /* Bro */
	ARGSFL_DELIM, /* Brc */
	ARGSFL_NONE, /* %C */
	ARGSFL_NONE, /* Es */
	ARGSFL_NONE, /* En */
	ARGSFL_NONE, /* Dx */
	ARGSFL_NONE, /* %Q */
	ARGSFL_NONE, /* br */
	ARGSFL_NONE, /* sp */
	ARGSFL_NONE, /* %U */
	ARGSFL_NONE, /* Ta */
};

d144 126
d282 1
d286 4
d291 1
a291 3
	assert(' ' != buf[*pos]);

	/* Parse through to the first unescaped space. */
d297 3
a299 7
	/* LINTED */
	while (buf[*pos]) {
		if (' ' == buf[*pos])
			if ('\\' != buf[*pos - 1])
				break;
		(*pos)++;
	}
d301 6
a306 1
	/* XXX - save zeroed byte, if not an argument. */
d308 1
a308 3
	sv = '\0';
	if (buf[*pos]) {
		sv = buf[*pos];
d310 5
a314 1
	}
d317 1
d320 1
d322 3
a324 1
	/* See if our token accepts the argument. */
d326 5
a330 2
	if (MDOC_ARG_MAX == (tmp.arg = argv_a2arg(tok, p))) {
		/* XXX - restore saved zeroed byte. */
d336 2
d341 16
a356 2
	if ( ! argv(m, line, &tmp, pos, buf))
		return(ARGV_ERROR);
d425 1
a425 1
	fl = argflags[tok];
a453 2
	assert(' ' != buf[*pos]);

a640 46
/*
 * Match up an argument string (e.g., `-foo bar' having "foo") with the
 * correct identifier.  It must apply to the given macro.  If none was
 * found (including bad matches), return MDOC_ARG_MAX.
 */
static enum mdocargt
argv_a2arg(enum mdoct tok, const char *p)
{
	const enum mdocargt *argsp;

	argsp = NULL;

	switch (tok) {
	case (MDOC_An):
		argsp = args_An;
		break;
	case (MDOC_Bd):
		argsp = args_Bd;
		break;
	case (MDOC_Bf):
		argsp = args_Bf;
		break;
	case (MDOC_Bk):
		argsp = args_Bk;
		break;
	case (MDOC_Bl):
		argsp = args_Bl;
		break;
	case (MDOC_Rv):
		/* FALLTHROUGH */
	case (MDOC_Ex):
		argsp = args_Ex;
		break;
	default:
		return(MDOC_ARG_MAX);
	}

	assert(argsp);

	for ( ; MDOC_ARG_MAX != *argsp ; argsp++)
		if (0 == strcmp(p, mdoc_argnames[*argsp]))
			return(*argsp);

	return(MDOC_ARG_MAX);
}

a689 3
/*
 * Parse a single, mandatory value from the stream.
 */
a709 30

	return(1);
}

/*
 * Determine rules for parsing arguments.  Arguments can either accept
 * no parameters, an optional single parameter, one parameter, or
 * multiple parameters.
 */
static int
argv(struct mdoc *mdoc, int line, 
		struct mdoc_argv *v, int *pos, char *buf)
{

	v->sz = 0;
	v->value = NULL;

	switch (argvflags[v->arg]) {
	case (ARGV_SINGLE):
		return(argv_single(mdoc, line, v, pos, buf));
	case (ARGV_MULTI):
		return(argv_multi(mdoc, line, v, pos, buf));
	case (ARGV_OPT_SINGLE):
		return(argv_opt_single(mdoc, line, v, pos, buf));
	case (ARGV_NONE):
		break;
	default:
		abort();
		/* NOTREACHED */
	}
@


1.37
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.36 2011/04/21 22:59:54 schwarze Exp $ */
d31 14
d48 2
a49 2
				char *, int, char **);
static	int		 args_checkpunct(const char *);
a59 7
enum	argvflag {
	ARGV_NONE, /* no args to flag (e.g., -split) */
	ARGV_SINGLE, /* one arg to flag (e.g., -file xxx)  */
	ARGV_MULTI, /* multiple args (e.g., -column xxx yyy) */
	ARGV_OPT_SINGLE /* optional arg (e.g., -offset [xxx]) */
};

d89 123
a211 123
static	const int argflags[MDOC_MAX] = {
	0, /* Ap */
	0, /* Dd */
	0, /* Dt */
	0, /* Os */
	0, /* Sh */
	0, /* Ss */ 
	0, /* Pp */ 
	ARGS_DELIM, /* D1 */
	ARGS_DELIM, /* Dl */
	0, /* Bd */
	0, /* Ed */
	0, /* Bl */
	0, /* El */
	0, /* It */
	ARGS_DELIM, /* Ad */ 
	ARGS_DELIM, /* An */
	ARGS_DELIM, /* Ar */
	0, /* Cd */
	ARGS_DELIM, /* Cm */
	ARGS_DELIM, /* Dv */ 
	ARGS_DELIM, /* Er */ 
	ARGS_DELIM, /* Ev */ 
	0, /* Ex */
	ARGS_DELIM, /* Fa */ 
	0, /* Fd */ 
	ARGS_DELIM, /* Fl */
	ARGS_DELIM, /* Fn */ 
	ARGS_DELIM, /* Ft */ 
	ARGS_DELIM, /* Ic */ 
	0, /* In */ 
	ARGS_DELIM, /* Li */
	0, /* Nd */ 
	ARGS_DELIM, /* Nm */ 
	ARGS_DELIM, /* Op */
	0, /* Ot */
	ARGS_DELIM, /* Pa */
	0, /* Rv */
	ARGS_DELIM, /* St */ 
	ARGS_DELIM, /* Va */
	ARGS_DELIM, /* Vt */ 
	ARGS_DELIM, /* Xr */
	0, /* %A */
	0, /* %B */
	0, /* %D */
	0, /* %I */
	0, /* %J */
	0, /* %N */
	0, /* %O */
	0, /* %P */
	0, /* %R */
	0, /* %T */
	0, /* %V */
	ARGS_DELIM, /* Ac */
	0, /* Ao */
	ARGS_DELIM, /* Aq */
	ARGS_DELIM, /* At */
	ARGS_DELIM, /* Bc */
	0, /* Bf */ 
	0, /* Bo */
	ARGS_DELIM, /* Bq */
	ARGS_DELIM, /* Bsx */
	ARGS_DELIM, /* Bx */
	0, /* Db */
	ARGS_DELIM, /* Dc */
	0, /* Do */
	ARGS_DELIM, /* Dq */
	ARGS_DELIM, /* Ec */
	0, /* Ef */
	ARGS_DELIM, /* Em */ 
	0, /* Eo */
	ARGS_DELIM, /* Fx */
	ARGS_DELIM, /* Ms */
	ARGS_DELIM, /* No */
	ARGS_DELIM, /* Ns */
	ARGS_DELIM, /* Nx */
	ARGS_DELIM, /* Ox */
	ARGS_DELIM, /* Pc */
	ARGS_DELIM, /* Pf */
	0, /* Po */
	ARGS_DELIM, /* Pq */
	ARGS_DELIM, /* Qc */
	ARGS_DELIM, /* Ql */
	0, /* Qo */
	ARGS_DELIM, /* Qq */
	0, /* Re */
	0, /* Rs */
	ARGS_DELIM, /* Sc */
	0, /* So */
	ARGS_DELIM, /* Sq */
	0, /* Sm */
	ARGS_DELIM, /* Sx */
	ARGS_DELIM, /* Sy */
	ARGS_DELIM, /* Tn */
	ARGS_DELIM, /* Ux */
	ARGS_DELIM, /* Xc */
	0, /* Xo */
	0, /* Fo */ 
	0, /* Fc */ 
	0, /* Oo */
	ARGS_DELIM, /* Oc */
	0, /* Bk */
	0, /* Ek */
	0, /* Bt */
	0, /* Hf */
	0, /* Fr */
	0, /* Ud */
	0, /* Lb */
	0, /* Lp */
	ARGS_DELIM, /* Lk */
	ARGS_DELIM, /* Mt */
	ARGS_DELIM, /* Brq */
	0, /* Bro */
	ARGS_DELIM, /* Brc */
	0, /* %C */
	0, /* Es */
	0, /* En */
	0, /* Dx */
	0, /* %Q */
	0, /* br */
	0, /* sp */
	0, /* %U */
	0, /* Ta */
d381 1
a381 2
mdoc_zargs(struct mdoc *m, int line, int *pos, 
		char *buf, int flags, char **v)
d384 1
a384 1
	return(args(m, line, pos, buf, flags, v));
d391 1
a391 1
	int		  fl;
d408 4
a411 6
			break;

	if (n && LIST_column == n->norm->Bl.type) {
		fl |= ARGS_TABSEP;
		fl &= ~ARGS_DELIM;
	}
d418 1
a418 1
		char *buf, int fl, char **v)
a419 1
	int		 i;
a422 15
	/*
	 * Parse out the terms (like `val' in `.Xx -arg val' or simply
	 * `.Xx val'), which can have all sorts of properties:
	 *
	 *   ARGS_DELIM: use special handling if encountering trailing
	 *   delimiters in the form of [[::delim::][ ]+]+.
	 *
	 *   ARGS_NOWARN: don't post warnings.  This is only used when
	 *   re-parsing delimiters, as the warnings have already been
	 *   posted.
	 *
	 *   ARGS_TABSEP: use special handling for tab/`Ta' separated
	 *   phrases like in `Bl -column'.
	 */

d442 2
a443 3
	if (ARGS_DELIM & fl && args_checkpunct(&buf[*pos])) {
		i = strlen(&buf[*pos]) + *pos;
		if (i && ' ' != buf[i - 1])
a444 5
		if (ARGS_NOWARN & fl)
			return(ARGS_PUNCT);
		mdoc_pmsg(m, line, *pos, MANDOCERR_EOLNSPACE);
		return(ARGS_PUNCT);
	}
d453 1
a453 1
	if (ARGS_TABSEP & fl) {
d492 1
a492 1
		if ('\0' == *p && ' ' == *(p - 1) && ! (ARGS_NOWARN & fl))
d535 1
a535 1
			if (ARGS_NOWARN & fl || MDOC_PPHRASE & m->flags)
d550 1
a550 1
		if (0 == buf[*pos] && ! (ARGS_NOWARN & fl))
d556 2
a557 19
	/* 
	 * A non-quoted term progresses until either the end of line or
	 * a non-escaped whitespace.
	 */

	for ( ; buf[*pos]; (*pos)++)
		if (*pos && ' ' == buf[*pos] && '\\' != buf[*pos - 1])
			break;

	if ('\0' == buf[*pos])
		return(ARGS_WORD);

	buf[(*pos)++] = '\0';

	while (' ' == buf[*pos])
		(*pos)++;

	if ('\0' == buf[*pos] && ! (ARGS_NOWARN & fl))
		mdoc_pmsg(m, line, *pos, MANDOCERR_EOLNSPACE);
d569 1
a569 1
args_checkpunct(const char *p)
d571 2
a572 2
	int		 i, j;
	char		 buf[DELIMSZ];
a574 2
	i = 0;

d577 2
a578 2
	for (j = 0; p[i] && ' ' != p[i] && j < DELIMSZ; j++, i++)
		buf[j] = p[i];
d583 2
a584 2
	buf[j] = '\0';
	if (DELIM_CLOSE != mdoc_isdelim(buf))
d587 1
a587 1
	while (' ' == p[i])
d592 1
a592 1
	while (p[i]) {
d594 2
a595 2
		while (p[i] && ' ' != p[i] && j < DELIMSZ)
			buf[j++] = p[i++];
d600 2
a601 2
		buf[j] = '\0';
		d = mdoc_isdelim(buf);
d605 1
a605 1
		while (' ' == p[i])
d609 1
a609 1
	return('\0' == p[i]);
d620 1
a620 1
	const enum mdocargt *args;
d622 1
a622 1
	args = NULL;
d626 1
a626 1
		args = args_An;
d629 1
a629 1
		args = args_Bd;
d632 1
a632 1
		args = args_Bf;
d635 1
a635 1
		args = args_Bk;
d638 1
a638 1
		args = args_Bl;
d643 1
a643 1
		args = args_Ex;
d649 1
a649 1
	assert(args);
d651 3
a653 3
	for ( ; MDOC_ARG_MAX != *args ; args++)
		if (0 == strcmp(p, mdoc_argnames[*args]))
			return(*args);
d668 1
a668 1
		ac = args(m, line, pos, buf, 0, &p);
d694 1
a694 1
	ac = args(m, line, pos, buf, 0, &p);
d720 1
a720 1
	ac = args(m, line, pos, buf, 0, &p);
@


1.36
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.35 2010/12/29 00:47:31 schwarze Exp $ */
d25 1
d44 1
d207 54
d349 1
a349 1
		mdoc_argn_free(p, i);
d355 2
a356 2
void
mdoc_argn_free(struct mdoc_arg *p, int iarg)
d621 1
a621 1
	if (DELIM_CLOSE != mandoc_isdelim(buf))
d638 1
a638 1
		d = mandoc_isdelim(buf);
d651 1
a651 1
 * correrct identifier.  It must apply to the given macro.  If none was
d657 1
a657 2
	enum mdocargt	 args[MDOC_ARG_MAX];
	int		 i, len;
d659 1
a659 1
	len = 0;
d663 1
a663 2
		args[len++] = MDOC_Split;
		args[len++] = MDOC_Nosplit;
d666 1
a666 8
		args[len++] = MDOC_Ragged;
		args[len++] = MDOC_Unfilled;
		args[len++] = MDOC_Filled;
		args[len++] = MDOC_Literal;
		args[len++] = MDOC_File;
		args[len++] = MDOC_Offset;
		args[len++] = MDOC_Compact;
		args[len++] = MDOC_Centred;
d669 1
a669 3
		args[len++] = MDOC_Emphasis;
		args[len++] = MDOC_Literal;
		args[len++] = MDOC_Symbolic;
d672 1
a672 1
		args[len++] = MDOC_Words;
d675 1
a675 15
		args[len++] = MDOC_Bullet;
		args[len++] = MDOC_Dash;
		args[len++] = MDOC_Hyphen;
		args[len++] = MDOC_Item;
		args[len++] = MDOC_Enum;
		args[len++] = MDOC_Tag;
		args[len++] = MDOC_Diag;
		args[len++] = MDOC_Hang;
		args[len++] = MDOC_Ohang;
		args[len++] = MDOC_Inset;
		args[len++] = MDOC_Column;
		args[len++] = MDOC_Width;
		args[len++] = MDOC_Offset;
		args[len++] = MDOC_Compact;
		args[len++] = MDOC_Nested;
d680 1
a680 1
		args[len++] = MDOC_Std;
d683 1
a683 1
		break;
d686 5
a690 3
	for (i = 0; i < len; i++)
		if (0 == strcmp(p, mdoc_argnames[args[i]]))
			return(args[i]);
@


1.35
log
@Reorg by Kristaps:  In libmdoc, replace the union of pointers to structs
of macro-specific data by a pointer to a union of structs, which makes the
code simpler and more robust at the expense of a small memory overhead.
Merging was somewhat difficult because we mustn't break tbl(1) support
which the bsd.lv version does not yet have.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.34 2010/09/13 20:10:11 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d29 1
a29 14
/*
 * Routines to parse arguments of macros.  Arguments follow the syntax
 * of `-arg [val [valN...]]'.  Arguments come in all types:  quoted
 * arguments, multiple arguments per value, no-value arguments, etc.
 *
 * There's no limit to the number or arguments that may be allocated.
 */

#define	ARGV_NONE	(1 << 0)
#define	ARGV_SINGLE	(1 << 1)
#define	ARGV_MULTI	(1 << 2)
#define	ARGV_OPT_SINGLE	(1 << 3)

#define	MULTI_STEP	 5
d34 1
d44 6
a49 1
/* Per-argument flags. */
d51 1
a51 1
static	int mdoc_argvflags[MDOC_ARG_MAX] = {
d80 1
a80 1
static	int mdoc_argflags[MDOC_MAX] = {
a204 1

d245 1
a245 1
	(void)memset(&tmp, 0, sizeof(struct mdoc_argv));
d271 1
a271 1
	(void)memcpy(&arg->argv[(int)arg->argc - 1], 
a276 1

a298 1

a316 1

a324 1

d332 1
a332 1
	fl = mdoc_argflags[tok];
a355 1

a362 1
	enum mdelim	 d;
d390 1
a390 2
			if ( ! mdoc_pmsg(m, line, *pos, MANDOCERR_BADQUOTE))
				return(ARGS_ERROR);
d396 1
a396 6
	/* 
	 * If the first character is a closing delimiter and we're to
	 * look for delimited strings, then pass down the buffer seeing
	 * if it follows the pattern of [[::delim::][ ]+]+.  Note that
	 * we ONLY care about closing delimiters.
	 */
d398 5
a402 21
	if ((fl & ARGS_DELIM) && DELIM_CLOSE == mdoc_iscdelim(buf[*pos])) {
		for (i = *pos; buf[i]; ) {
			d = mdoc_iscdelim(buf[i]);
			if (DELIM_NONE == d || DELIM_OPEN == d)
				break;
			i++;
			if ('\0' == buf[i] || ' ' != buf[i])
				break;
			i++;
			while (buf[i] && ' ' == buf[i])
				i++;
		}

		if ('\0' == buf[i]) {
			*v = &buf[*pos];
			if (i && ' ' != buf[i - 1])
				return(ARGS_PUNCT);
			if (ARGS_NOWARN & fl)
				return(ARGS_PUNCT);
			if ( ! mdoc_pmsg(m, line, *pos, MANDOCERR_EOLNSPACE))
				return(ARGS_ERROR);
d404 2
a405 1
		}
a407 2
	*v = &buf[*pos];

d455 1
a455 2
			if ( ! mdoc_pmsg(m, line, *pos, MANDOCERR_EOLNSPACE))
				return(ARGS_ERROR);
d499 1
a499 2
			if ( ! mdoc_pmsg(m, line, *pos, MANDOCERR_BADQUOTE))
				return(ARGS_ERROR);
d513 1
a513 2
			if ( ! mdoc_pmsg(m, line, *pos, MANDOCERR_EOLNSPACE))
				return(ARGS_ERROR);
d536 1
a536 2
		if ( ! mdoc_pmsg(m, line, *pos, MANDOCERR_EOLNSPACE))
			return(ARGS_ERROR);
d541 19
d561 37
d601 2
d604 1
a604 7
	/*
	 * Parse an argument identifier from its text.  XXX - this
	 * should really be table-driven to clarify the code.
	 *
	 * If you add an argument to the list, make sure that you
	 * register it here with its one or more macros!
	 */
d608 2
a609 4
		if (0 == strcmp(p, "split"))
			return(MDOC_Split);
		else if (0 == strcmp(p, "nosplit"))
			return(MDOC_Nosplit);
a610 1

d612 8
a619 16
		if (0 == strcmp(p, "ragged"))
			return(MDOC_Ragged);
		else if (0 == strcmp(p, "unfilled"))
			return(MDOC_Unfilled);
		else if (0 == strcmp(p, "filled"))
			return(MDOC_Filled);
		else if (0 == strcmp(p, "literal"))
			return(MDOC_Literal);
		else if (0 == strcmp(p, "file"))
			return(MDOC_File);
		else if (0 == strcmp(p, "offset"))
			return(MDOC_Offset);
		else if (0 == strcmp(p, "compact"))
			return(MDOC_Compact);
		else if (0 == strcmp(p, "centered"))
			return(MDOC_Centred);
a620 1

d622 3
a624 6
		if (0 == strcmp(p, "emphasis"))
			return(MDOC_Emphasis);
		else if (0 == strcmp(p, "literal"))
			return(MDOC_Literal);
		else if (0 == strcmp(p, "symbolic"))
			return(MDOC_Symbolic);
a625 1

d627 1
a627 2
		if (0 == strcmp(p, "words"))
			return(MDOC_Words);
a628 1

d630 15
a644 30
		if (0 == strcmp(p, "bullet"))
			return(MDOC_Bullet);
		else if (0 == strcmp(p, "dash"))
			return(MDOC_Dash);
		else if (0 == strcmp(p, "hyphen"))
			return(MDOC_Hyphen);
		else if (0 == strcmp(p, "item"))
			return(MDOC_Item);
		else if (0 == strcmp(p, "enum"))
			return(MDOC_Enum);
		else if (0 == strcmp(p, "tag"))
			return(MDOC_Tag);
		else if (0 == strcmp(p, "diag"))
			return(MDOC_Diag);
		else if (0 == strcmp(p, "hang"))
			return(MDOC_Hang);
		else if (0 == strcmp(p, "ohang"))
			return(MDOC_Ohang);
		else if (0 == strcmp(p, "inset"))
			return(MDOC_Inset);
		else if (0 == strcmp(p, "column"))
			return(MDOC_Column);
		else if (0 == strcmp(p, "width"))
			return(MDOC_Width);
		else if (0 == strcmp(p, "offset"))
			return(MDOC_Offset);
		else if (0 == strcmp(p, "compact"))
			return(MDOC_Compact);
		else if (0 == strcmp(p, "nested"))
			return(MDOC_Nested);
a645 1
	
d649 1
a649 2
		if (0 == strcmp(p, "std"))
			return(MDOC_Std);
d655 4
a661 1

a687 1

a710 1

a737 1

d751 1
a751 1
	switch (mdoc_argvflags[v->arg]) {
d758 2
d761 2
a762 2
		/* ARGV_NONE */
		break;
@


1.34
log
@Prevent .Pp and .Lp from looping endlessly on punctuation.
Fix for .Pp from kristaps@@, i applied the same to .Lp.
Bug reported by espie@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.33 2010/07/25 18:05:54 schwarze Exp $ */
d360 1
a360 2
	assert(n->data.Bl);
	if (n && LIST_column == n->data.Bl->type) {
@


1.33
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.32 2010/07/13 01:09:13 schwarze Exp $ */
d94 1
a94 1
	ARGS_DELIM, /* Pp */ 
d195 1
a195 1
	ARGS_DELIM, /* Lp */
@


1.32
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.31 2010/06/26 17:56:43 schwarze Exp $ */
d44 1
a44 1
static	int		 argv_a2arg(enum mdoct, const char *);
d312 1
a312 1
	struct mdoc_argv *arg = &p->argv[iarg];
d315 2
d584 1
a584 1
static int
@


1.31
log
@merge release 1.10.2
* bug fixes:
- interaction of ASCII_HYPH with special chars (found by Ulrich Spoerlein)
- handling of roff conditionals (found by Ulrich Spoerlein)
- .Bd -offset will no more default to 6n
* maintenance:
- more caching of .Bd and .Bl arguments for efficiency
- deconstify man(7) validation routines
- add FreeBSD library names (provided by Ulrich Spoerlein)
* start PostScript font-switching
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.30 2010/06/06 20:30:08 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
d358 2
a359 1
	if (n && LIST_column == n->data.Bl.type) {
@


1.30
log
@Merge bsd.lv version 1.10.1 (to be released soon).

The main step forward is that this now has *much* better .Bl -column
support, now supporting many manuals that previously errored out
without producing any output.

Other fixes include:
* do not die from multiple list types, use the first and warn
* in .Bl without a type, default to -item
* various tweaks to .Dt
* fix .In, .Fd, .Ft, .Fn and .Fo formatting
* some documentation fixes and additions
* and fix a couple of bugs reported by Ulrich Spoerlein:
* better support for roff block-end "\}" without a preceding dot
* .In must not break the line outside SYNOPSIS
* spelling in some error messages

While merging, fix one regression in .In spacing
that needs to go to bsd.lv, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.29 2010/05/23 22:45:00 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d358 1
a358 1
	if (n && LIST_column == n->data.list) {
@


1.29
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.28 2010/05/15 13:12:55 schwarze Exp $ */
d209 1
d226 1
a226 1
	if (0 == buf[*pos])
d247 1
a247 1
	sv = 0;
d250 1
a250 1
		buf[(*pos)++] = 0;
d339 1
a339 1
	int		  fl, c, i;
d347 5
a351 3
	/* 
	 * The `It' macro is a special case, as it acquires parameters from its
	 * parent `Bl' context, specifically, we're concerned with -column.
d355 1
a355 1
		if (MDOC_BLOCK == n->type && MDOC_Bl == n->tok)
d358 1
a358 8
	assert(n);
	c = (int)(n->args ? n->args->argc : 0);
	assert(c > 0);

	/* LINTED */
	for (i = 0; i < c; i++) {
		if (MDOC_Column != n->args->argv[i].arg) 
			continue;
a360 1
		break;
d371 4
a374 3
	int		  i;
	char		 *p, *pp;
	enum margserr	  rc;
a390 1
	assert(*pos);
d418 1
a418 1
			enum mdelim d = mdoc_iscdelim(buf[i]);
d431 1
a431 1
			if (' ' != buf[i - 1])
d462 1
a462 1
				if (' ' == *(pp + 2) || 0 == *(pp + 2))
d489 1
a489 1
		if (0 == *p && ' ' == *(p - 1) && ! (ARGS_NOWARN & fl))
d562 1
a562 1
		if (' ' == buf[*pos] && '\\' != buf[*pos - 1])
@


1.28
log
@proper handling of quoted tab-separated column lists
by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.27 2010/05/15 12:30:59 schwarze Exp $ */
d25 1
d407 1
a407 1
			if ( ! mdoc_pwarn(m, line, *pos, EQUOTTERM))
d440 1
a440 1
			if ( ! mdoc_pwarn(m, line, *pos, ETAILWS))
d495 1
a495 1
			if ( ! mdoc_pwarn(m, line, *pos, ETAILWS))
d540 1
a540 1
			if ( ! mdoc_pwarn(m, line, *pos, EQUOTTERM))
d555 1
a555 1
			if ( ! mdoc_pwarn(m, line, *pos, ETAILWS))
d579 1
a579 1
		if ( ! mdoc_pwarn(m, line, *pos, ETAILWS))
d751 4
a754 1
	if (ARGS_ERROR == ac)
a755 2
	if (ARGS_EOLN == ac)
		return(mdoc_perr(m, line, ppos, EARGVAL));
@


1.27
log
@Distinguish OPEN, MIDDLE and CLOSE delimiters (using an enum).
Only OPEN are drawn before the beginning of a macro;
this is new, before this, MIDDLE ('|') were drawn in front, too.
Only CLOSE are pushed after the end of a macro (as before).
ok kristaps@@

This allows us to finally enable handling of leading punctuation
without regressions.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.26 2010/05/14 19:52:43 schwarze Exp $ */
d397 13
a409 1
	if ('\0' == buf[*pos])
d411 1
d457 1
d460 9
a468 8
		for (pp = *v; ; pp++) {
			if (NULL == (pp = strstr(pp, "Ta")))
				break;
			if (pp > *v && ' ' != *(pp - 1))
				continue;
			if (' ' == *(pp + 2) || 0 == *(pp + 2))
				break;
		}
d521 6
a526 2
	if ('\"' == buf[*pos]) {
		*v = &buf[++(*pos)];
d536 2
a537 2
		if (0 == buf[*pos]) {
			if (ARGS_NOWARN & fl)
d544 2
a545 1
		buf[(*pos)++] = 0;
d547 1
a547 1
		if (0 == buf[*pos])
d569 1
a569 1
	if (0 == buf[*pos])
d572 1
a572 1
	buf[(*pos)++] = 0;
d577 1
a577 1
	if (0 == buf[*pos] && ! (ARGS_NOWARN & fl))
@


1.26
log
@Integrate kristaps@@' end-of-sentence (EOS) framework
which is simpler and more powerful than mine, and remove mine.

* man(7) now has EOS handling, too
* put EOS detection into its own function in libmandoc
* use node and termp flags to communicate the EOS condition
* no more EOS pseudo-macro
* no more non-printable EOS marker character on the formatter level

This slightly breaks EOS detection after trailing punctuation
in mdoc(7) macros, but that will be restored soon.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.25 2010/05/14 14:47:44 schwarze Exp $ */
d407 1
a407 1
	if ((fl & ARGS_DELIM) && mdoc_iscdelim(buf[*pos]) > 1) {
d409 2
a410 1
			if ( mdoc_iscdelim(buf[i]) < 2)
@


1.25
log
@Merge 1.9.25, keeping local patches;
this does not merge kristaps' end-of-sentences handling yet,
i will check that separately.  This one includes:
* handle \*(Ba as a delimiter
* introduce ARGS_PEND for .Bl -column .It end-of-line special casing
* section ordering: expect EXIT STATUS at the right place
* line break fixes in SYNOPSIS
* allow literal contexts to have arbitrary line lengths
* the input file column number can not be used to identify the beginning
  of a line because white space is allowed after the initial '.'
* proper leading spaces in -man -Tascii mode
* do not let Lb break lines in -mdoc -Thtml LIBRARY
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.24 2010/05/14 01:54:37 schwarze Exp $ */
a207 1
	0, /* eos */
@


1.24
log
@merge 1.9.24, keeping local patches; some changes:
* preserve multiple consecutive space characters in input
* do not restrict .Cd and .Rv to certain sections (requested by Joerg)
* do not run lookup() on quoted words
* enum return types for mdoc_args and mdoc_argv
* fix auto-closing of LINK tag in -Txhtml (from Daniel Friesel)
* various lint and manual fixes
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.23 2010/04/03 16:30:42 schwarze Exp $ */
d402 4
a405 3
	 * If the first character is a delimiter and we're to look for
	 * delimited strings, then pass down the buffer seeing if it
	 * follows the pattern of [[::delim::][ ]+]+.
d413 1
a413 1
			if (0 == buf[i] || ' ' != buf[i])
d420 1
a420 1
		if (0 == buf[i]) {
d472 2
a473 1
		} else
d475 1
@


1.23
log
@When two conflicting list types are specified for the same list,
use the first, discard the second, and warn.  No need to bail out.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.22 2010/04/02 12:39:47 schwarze Exp $ */
d44 1
a44 1
static	int		 args(struct mdoc *, int, int *, 
d217 1
a217 1
int
d300 1
a300 1
	for (i = p->argc - 1; i >= 0; i--)
d315 1
a315 1
		for (j = arg->sz - 1; j >= 0; j--) 
d325 1
a325 1
int
d334 1
a334 1
int
d372 1
a372 1
static int
d378 1
d398 1
a398 1
	if (0 == buf[*pos])
d454 3
d463 1
d466 1
d494 1
a494 1
		return(ARGS_PHRASE);
d666 1
a666 1
	int		 c;
d672 2
a673 2
		c = args(m, line, pos, buf, 0, &p);
		if (ARGS_ERROR == c)
d675 1
a675 1
		else if (ARGS_EOLN == c)
d693 1
a693 1
	int		 c;
d699 2
a700 2
	c = args(m, line, pos, buf, 0, &p);
	if (ARGS_ERROR == c)
d702 1
a702 1
	if (ARGS_EOLN == c)
d720 2
a721 1
	int		 c, ppos;
d726 2
a727 2
	c = args(m, line, pos, buf, 0, &p);
	if (ARGS_ERROR == c)
d729 1
a729 1
	if (ARGS_EOLN == c)
@


1.22
log
@merge 1.9.22, keeping local patches
* convert mdoc tokens from #define to enum
* fix a segfault with .Xo/.Xc in explicit blocks
* Thorn is \*(Th, not \*(TH; noticed by Joerg Sonnenberger
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.21 2010/03/02 00:38:59 schwarze Exp $ */
d288 1
a288 1
	int		 i, j;
d300 13
a312 11
	/* LINTED */
	for (i = 0; i < (int)p->argc; i++) {
		if (0 == p->argv[i].sz)
			continue;
		if (NULL == p->argv[i].value)
			continue;

		/* LINTED */
		for (j = 0; j < (int)p->argv[i].sz; j++) 
			if (p->argv[i].value[j])
				free(p->argv[i].value[j]);
d314 4
a317 1
		free(p->argv[i].value);
d320 2
a321 2
	free(p->argv);
	free(p);
@


1.21
log
@Proper inter-sentence spacing for mdoc(7).
When a text line or a non-block macro line in the source code ends
in any of ".!?", consider that an end of sentence (EOS).
This makes Jason's rule "new sentence, new line" even more important.
Let the parser detect the EOS and insert a token into the AST.
Let the -Tascii frontend render the EOS token as a double space before
the next word.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.19 2009/12/22 23:58:00 schwarze Exp $ */
d43 1
a43 1
static	int		 argv_a2arg(int, const char *);
d218 1
a218 1
mdoc_argv(struct mdoc *m, int line, int tok,
d330 2
a331 2
mdoc_args(struct mdoc *m, int line, 
		int *pos, char *buf, int tok, char **v)
d336 1
a336 1
	fl = (0 == tok) ? 0 : mdoc_argflags[tok];
d552 1
a552 1
argv_a2arg(int tok, const char *p)
@


1.20
log
@Distinguish opening and closing delimiters, and close out block
macros after closing delimiters only, not after opening ones.  Besides,
neither roff nor old nor new groff consider braces { } as delimiters.

This fixes some frequent misrenderings by mandoc,
for example ".Ql (" being rendered as "`'(" instead of "`('".
@
text
@d208 1
@


1.19
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.18 2009/10/27 21:40:07 schwarze Exp $ */
d400 1
a400 1
	if ((fl & ARGS_DELIM) && mdoc_iscdelim(buf[*pos])) {
d402 1
a402 1
			if ( ! mdoc_iscdelim(buf[i]))
@


1.18
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.17 2009/10/21 19:13:50 schwarze Exp $ */
d26 1
d270 2
a271 8
	if (NULL == (arg = *v)) {
		*v = calloc(1, sizeof(struct mdoc_arg));
		if (NULL == *v) {
			(void)mdoc_nerr(m, m->last, EMALLOC);
			return(ARGV_ERROR);
		}
		arg = *v;
	} 
d274 2
a275 7
	arg->argv = realloc(arg->argv, arg->argc * 
			sizeof(struct mdoc_argv));

	if (NULL == arg->argv) {
		(void)mdoc_nerr(m, m->last, EMALLOC);
		return(ARGV_ERROR);
	}
d666 2
a667 2
		if (0 == v->sz % MULTI_STEP) {
			v->value = realloc(v->value, 
d669 2
a670 7
			if (NULL == v->value) {
				(void)mdoc_nerr(m, m->last, EMALLOC);
				return(ARGV_ERROR);
			}
		}
		if (NULL == (v->value[(int)v->sz] = strdup(p)))
			return(mdoc_nerr(m, m->last, EMALLOC));
d694 2
a695 4
	if (NULL == (v->value = calloc(1, sizeof(char *))))
		return(mdoc_nerr(m, m->last, EMALLOC));
	if (NULL == (v->value[0] = strdup(p)))
		return(mdoc_nerr(m, m->last, EMALLOC));
d720 2
a721 4
	if (NULL == (v->value = calloc(1, sizeof(char *))))
		return(mdoc_nerr(m, m->last, EMALLOC));
	if (NULL == (v->value[0] = strdup(p)))
		return(mdoc_nerr(m, m->last, EMALLOC));
@


1.17
log
@sync to 1.9.9, featuring:
 * -Thtml output mode
 * roff scaling units
 * and some minor fixes
for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.16 2009/10/19 21:00:43 schwarze Exp $ */
d206 1
@


1.16
log
@sync to 1.9.7: avoid using the same identifier for a static function
and for a local variable in another function in the same compilation unit;
suggested by Ulrich Spoerlein, uqs at spoerlein dot net
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.15 2009/10/19 15:44:01 schwarze Exp $ */
d62 1
a62 1
	ARGV_NONE,	/* MDOC_File */
d594 2
@


1.15
log
@sync to 1.9.6: do not die from .Bd -literal -offset w/o arg (and similar)
Actually, our ancient groff behaves slightly differently than this fix,
but not to die is already an improvement.  Needs a closer look later.
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.14 2009/08/22 22:50:17 schwarze Exp $ */
d560 1
a560 1
argv_a2arg(int tok, const char *argv)
d573 1
a573 1
		if (0 == strcmp(argv, "split"))
d575 1
a575 1
		else if (0 == strcmp(argv, "nosplit"))
d580 1
a580 1
		if (0 == strcmp(argv, "ragged"))
d582 1
a582 1
		else if (0 == strcmp(argv, "unfilled"))
d584 1
a584 1
		else if (0 == strcmp(argv, "filled"))
d586 1
a586 1
		else if (0 == strcmp(argv, "literal"))
d588 1
a588 1
		else if (0 == strcmp(argv, "file"))
d590 1
a590 1
		else if (0 == strcmp(argv, "offset"))
d592 1
a592 1
		else if (0 == strcmp(argv, "compact"))
d597 1
a597 1
		if (0 == strcmp(argv, "emphasis"))
d599 1
a599 1
		else if (0 == strcmp(argv, "literal"))
d601 1
a601 1
		else if (0 == strcmp(argv, "symbolic"))
d606 1
a606 1
		if (0 == strcmp(argv, "words"))
d611 1
a611 1
		if (0 == strcmp(argv, "bullet"))
d613 1
a613 1
		else if (0 == strcmp(argv, "dash"))
d615 1
a615 1
		else if (0 == strcmp(argv, "hyphen"))
d617 1
a617 1
		else if (0 == strcmp(argv, "item"))
d619 1
a619 1
		else if (0 == strcmp(argv, "enum"))
d621 1
a621 1
		else if (0 == strcmp(argv, "tag"))
d623 1
a623 1
		else if (0 == strcmp(argv, "diag"))
d625 1
a625 1
		else if (0 == strcmp(argv, "hang"))
d627 1
a627 1
		else if (0 == strcmp(argv, "ohang"))
d629 1
a629 1
		else if (0 == strcmp(argv, "inset"))
d631 1
a631 1
		else if (0 == strcmp(argv, "column"))
d633 1
a633 1
		else if (0 == strcmp(argv, "width"))
d635 1
a635 1
		else if (0 == strcmp(argv, "offset"))
d637 1
a637 1
		else if (0 == strcmp(argv, "compact"))
d639 1
a639 1
		else if (0 == strcmp(argv, "nested"))
d646 1
a646 1
		if (0 == strcmp(argv, "std"))
@


1.14
log
@sync to 1.9.1: .Rv and .Ex accept multiple arguments
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.13 2009/08/22 22:39:55 schwarze Exp $ */
d63 1
a63 1
	ARGV_SINGLE,	/* MDOC_Offset */
d312 3
d317 2
a318 1
			free(p->argv[i].value[j]);
@


1.13
log
@sync to 1.9.1: correctly flag delimiter whitespace
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.12 2009/07/26 22:48:41 schwarze Exp $ */
d77 1
a77 1
	ARGV_OPT_SINGLE, /* MDOC_Std */
@


1.12
log
@sync to 1.8.1: rewrite quoted literal handling correctly,
rewrite TABSEP handling in a simpler way,
and retire ECOLEMPTY, ARGS_QUOTED and ARGS_ARGVLIKE
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.11 2009/07/26 02:17:29 schwarze Exp $ */
a34 5
/* FIXME .Bf Li raises "macro-like parameter". */

#define	ARGS_DELIM	(1 << 1)
#define	ARGS_TABSEP	(1 << 2)

d325 2
a326 1
mdoc_zargs(struct mdoc *m, int line, int *pos, char *buf, char **v)
d329 1
a329 1
	return(args(m, line, pos, buf, 0, v));
d378 15
a416 2
		/* FIXME: warn about trailing whitespace. */

d419 6
d468 1
a468 1
		if (0 == *p && ' ' == *(p - 1))
d508 2
d523 1
a523 1
		if (0 == buf[*pos])
d547 1
a547 1
	if (0 == buf[*pos])
@


1.11
log
@sync to 1.8.1: removed excessively verbose EARGVPARM warning
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.10 2009/07/26 01:59:46 schwarze Exp $ */
a36 1
#define	ARGS_QUOTED	(1 << 0)
a38 1
#define	ARGS_ARGVLIKE	(1 << 3)
d95 2
a96 2
	ARGS_QUOTED, /* Sh */
	ARGS_QUOTED, /* Ss */ 
d99 1
a99 1
	ARGS_DELIM | ARGS_QUOTED, /* Dl */
d102 1
a102 1
	ARGS_QUOTED, /* Bl */
d107 2
a108 2
	ARGS_DELIM | ARGS_QUOTED, /* Ar */
	ARGS_QUOTED, /* Cd */
d114 1
a114 1
	ARGS_DELIM | ARGS_QUOTED, /* Fa */ 
d117 2
a118 2
	ARGS_DELIM | ARGS_QUOTED, /* Fn */ 
	ARGS_DELIM | ARGS_QUOTED, /* Ft */ 
d121 2
a122 2
	ARGS_DELIM | ARGS_QUOTED, /* Li */
	ARGS_QUOTED, /* Nd */ 
d128 1
a128 1
	ARGS_DELIM | ARGS_ARGVLIKE, /* St */ 
d132 11
a142 11
	ARGS_QUOTED, /* %A */
	ARGS_QUOTED, /* %B */
	ARGS_QUOTED, /* %D */
	ARGS_QUOTED, /* %I */
	ARGS_QUOTED, /* %J */
	ARGS_QUOTED, /* %N */
	ARGS_QUOTED, /* %O */
	ARGS_QUOTED, /* %P */
	ARGS_QUOTED, /* %R */
	ARGS_QUOTED, /* %T */
	ARGS_QUOTED, /* %V */
d182 1
a182 1
	ARGS_DELIM | ARGS_QUOTED, /* Sy */
d187 1
a187 1
	ARGS_QUOTED, /* Fo */ 
d199 2
a200 2
	ARGS_DELIM | ARGS_QUOTED, /* Lk */
	ARGS_DELIM | ARGS_QUOTED, /* Mt */
d204 1
a204 1
	ARGS_QUOTED, /* %C */
d208 1
a208 1
	ARGS_QUOTED, /* %Q */
a222 1
	int		  i;
a231 3
	if ('-' != buf[*pos] || ARGS_ARGVLIKE & mdoc_argflags[tok])
		return(ARGV_WORD);

a233 1
	i = *pos;
d330 8
d346 3
d350 2
a351 3
	 * Override per-macro argument flags with context-specific ones.
	 * As of now, this is only valid for `It' depending on its list
	 * context.
d354 3
a356 5
	switch (tok) {
	case (MDOC_It):
		for (n = m->last; n; n = n->parent)
			if (MDOC_BLOCK == n->type && MDOC_Bl == n->tok)
				break;
d358 3
a360 9
		assert(n);
		c = (int)(n->args ? n->args->argc : 0);
		assert(c > 0);

		/*
		 * Using `Bl -column' adds ARGS_TABSEP to the arguments
		 * and invalidates ARGS_DELIM.  Using `Bl -diag' allows
		 * for quoted arguments.
		 */
d362 6
a367 18
		/* LINTED */
		for (i = 0; i < c; i++) {
			switch (n->args->argv[i].arg) {
			case (MDOC_Column):
				fl |= ARGS_TABSEP;
				fl &= ~ARGS_DELIM;
				i = c;
				break;
			case (MDOC_Diag):
				fl |= ARGS_QUOTED;
				i = c;
				break;
			default:
				break;
			}
		}
		break;
	default:
d376 1
a376 1
args(struct mdoc *m, int line, int *pos,
d382 2
a383 1
	assert(*pos > 0);
a387 4
	if ('\"' == buf[*pos] && ! (fl & ARGS_QUOTED))
		if ( ! mdoc_pwarn(m, line, *pos, EQUOTPARM))
			return(ARGS_ERROR);

a398 1
			/* There must be at least one space... */
d405 3
d414 1
a414 1
	/* First parse non-quoted strings. */
d416 20
a435 2
	if ('\"' != buf[*pos] || ! (ARGS_QUOTED & fl)) {
		*v = &buf[*pos];
d438 2
a439 5
		 * Thar be dragons here!  If we're tab-separated, search
		 * ahead for either a tab or the `Ta' macro.  
		 * If a `Ta' is detected, it must be space-buffered before and
		 * after.  If either of these hold true, then prune out the
		 * extra spaces and call it an argument.
d441 10
d452 15
a466 2
		if (ARGS_TABSEP & fl) {
			/* Scan ahead to unescaped tab. */
d468 3
a470 1
			p = strchr(*v, '\t');
d472 2
a473 1
			/* Scan ahead to unescaped `Ta'. */
d475 5
a479 8
			for (pp = *v; ; pp++) {
				if (NULL == (pp = strstr(pp, "Ta")))
					break;
				if (pp > *v && ' ' != *(pp - 1))
					continue;
				if (' ' == *(pp + 2) || 0 == *(pp + 2))
					break;
			}
d481 2
a482 1
			/* Choose delimiter tab/Ta. */
d484 7
a490 16
			if (p && pp)
				p = (p < pp ? p : pp);
			else if ( ! p && pp)
				p = pp;

			/* Strip delimiter's preceding whitespace. */

			if (p && p > *v) {
				pp = p - 1;
				while (pp > *v && ' ' == *pp)
					pp--;
				if (pp == *v && ' ' == *pp) 
					*pp = 0;
				else if (' ' == *pp)
					*(pp + 1) = 0;
			}
d492 5
a496 1
			/* ...in- and proceding whitespace. */
d498 1
a498 46
			if (p && ('\t' != *p)) {
				*p++ = 0;
				*p++ = 0;
			} else if (p)
				*p++ = 0;

			if (p) {
				while (' ' == *p)
					p++;
				if (0 != *p)
					*(p - 1) = 0;
				*pos += (int)(p - *v);
			} 

			if (p && 0 == *p)
				if ( ! mdoc_pwarn(m, line, *pos, ECOLEMPTY))
					return(0);
			if (p && 0 == *p && p > *v && ' ' == *(p - 1))
				if ( ! mdoc_pwarn(m, line, *pos, ETAILWS))
					return(0);

			if (p)
				return(ARGS_PHRASE);

			/* Configure the eoln case, too. */

			p = strchr(*v, 0);
			assert(p);

			if (p > *v && ' ' == *(p - 1))
				if ( ! mdoc_pwarn(m, line, *pos, ETAILWS))
					return(0);
			*pos += (int)(p - *v);

			return(ARGS_PHRASE);
		} 
		
		/* Do non-tabsep look-ahead here. */
		
		if ( ! (ARGS_TABSEP & fl))
			while (buf[*pos]) {
				if (' ' == buf[*pos])
					if ('\\' != buf[*pos - 1])
						break;
				(*pos)++;
			}
d501 1
a501 1
			return(ARGS_WORD);
d503 2
a504 1
		buf[(*pos)++] = 0;
d507 2
a508 1
			return(ARGS_WORD);
d510 1
a510 11
		if ( ! (ARGS_TABSEP & fl))
			while (buf[*pos] && ' ' == buf[*pos])
				(*pos)++;

		if (buf[*pos])
			return(ARGS_WORD);

		if ( ! mdoc_pwarn(m, line, *pos, ETAILWS))
			return(ARGS_ERROR);

		return(ARGS_WORD);
d513 3
a515 4
	/*
	 * If we're a quoted string (and quoted strings are allowed),
	 * then parse ahead to the next quote.  If none's found, it's an
	 * error.  After, parse to the next word.  
d518 3
a520 1
	*v = &buf[++(*pos)];
d522 2
a523 7
	while (buf[*pos] && '\"' != buf[*pos])
		(*pos)++;

	if (0 == buf[*pos]) {
		(void)mdoc_perr(m, line, *pos, EQUOTTERM);
		return(ARGS_ERROR);
	}
a525 2
	if (0 == buf[*pos])
		return(ARGS_QWORD);
d527 1
a527 1
	while (buf[*pos] && ' ' == buf[*pos])
d530 3
a532 5
	if (buf[*pos])
		return(ARGS_QWORD);

	if ( ! mdoc_pwarn(m, line, *pos, ETAILWS))
		return(ARGS_ERROR);
d534 1
a534 1
	return(ARGS_QWORD);
d646 1
a646 1
		c = args(m, line, pos, buf, ARGS_QUOTED, &p);
d678 1
a678 1
	c = args(m, line, pos, buf, ARGS_QUOTED, &p);
d706 1
a706 1
	c = args(m, line, pos, buf, ARGS_QUOTED, &p);
@


1.10
log
@sync to 1.8.1: support .br and .sp
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.9 2009/07/12 23:26:08 schwarze Exp $ */
a270 2
		if ( ! mdoc_pwarn(m, line, i, EARGVPARM))
			return(ARGV_ERROR);
d393 2
a394 2
args(struct mdoc *m, int line, 
		int *pos, char *buf, int fl, char **v)
a405 4
			return(ARGS_ERROR);

	if ( ! (fl & ARGS_ARGVLIKE) && '-' == buf[*pos]) 
		if ( ! mdoc_pwarn(m, line, *pos, EARGVPARM))
@


1.9
log
@sync to 1.7.24: remove long-fixed FIXME
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.8 2009/07/12 22:35:08 schwarze Exp $ */
d211 2
@


1.8
log
@sync to 1.7.23: pass warning code to mdoc_pwarn() instead of warning message
define additional warning macro mdoc_nwarn()
remove obsolete warning functions mdoc_warn(), pwarn(), vwarn(), nwarn()
remove various now unused "enum mdoc_warn" and "enum mwarn"
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.7 2009/07/12 21:45:44 schwarze Exp $ */
a35 1
/* FIXME .Bl -column should deprecate old-groff syntax. */
@


1.7
log
@sync to 1.7.23: pass error code to mdoc_perr() instead of error string
and use the so improved mdoc_nerr() at many places;
get rid of now unused static functions perr()
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.6 2009/07/12 21:08:29 schwarze Exp $ */
a49 7
enum 	mwarn {
	WQUOTPARM,
	WARGVPARM,
	WCOLEMPTY,
	WTAILWS	
};

a60 1
static	int		 pwarn(struct mdoc *, int, int, enum mwarn);
d270 1
a270 1
		if ( ! pwarn(m, line, i, WARGVPARM))
a336 29
static int
pwarn(struct mdoc *mdoc, int line, int pos, enum mwarn code)
{
	char		*p;
	int		 c;

	p = NULL;
	c = WARN_SYNTAX;
	switch (code) {
	case (WQUOTPARM):
		p = "unexpected quoted parameter";
		break;
	case (WARGVPARM):
		p = "argument-like parameter";
		break;
	case (WCOLEMPTY):
		p = "last list column is empty";
		c = WARN_COMPAT;
		break;
	case (WTAILWS):
		p = "trailing whitespace";
		c = WARN_COMPAT;
		break;
	}
	assert(p);
	return(mdoc_pwarn(mdoc, line, pos, c, p));
}


d338 1
a338 1
mdoc_args(struct mdoc *mdoc, int line, 
d354 1
a354 1
		for (n = mdoc->last; n; n = n->parent)
d389 1
a389 1
	return(args(mdoc, line, pos, buf, fl, v));
d394 1
a394 1
args(struct mdoc *mdoc, int line, 
d406 1
a406 1
		if ( ! pwarn(mdoc, line, *pos, WQUOTPARM))
d410 1
a410 1
		if ( ! pwarn(mdoc, line, *pos, WARGVPARM))
d502 1
a502 1
				if ( ! pwarn(mdoc, line, *pos, WCOLEMPTY))
d505 1
a505 1
				if ( ! pwarn(mdoc, line, *pos, WTAILWS))
d517 1
a517 1
				if ( ! pwarn(mdoc, line, *pos, WTAILWS))
d549 1
a549 1
		if ( ! pwarn(mdoc, line, *pos, WTAILWS))
d567 1
a567 1
		(void)mdoc_perr(mdoc, line, *pos, EQUOTTERM);
d581 1
a581 1
	if ( ! pwarn(mdoc, line, *pos, WTAILWS))
@


1.6
log
@sync to 1.7.23: pass error code to mdoc_nerr() instead of error string
and use the so improved mdoc_nerr() at many places
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.5 2009/07/12 20:30:27 schwarze Exp $ */
a68 3
static	int		 perr(struct mdoc *, int, int, enum merr);

#define verr(m, t) perr((m), (m)->last->line, (m)->last->pos, (t))
a344 23

static int
perr(struct mdoc *mdoc, int line, int pos, enum merr code)
{
	char		*p;

	p = NULL;
	switch (code) {
	case (EMALLOC):
		p = "memory exhausted";
		break;
	case (EQUOTTERM):
		p = "unterminated quoted parameter";
		break;
	case (EARGVAL):
		p = "argument requires a value";
		break;
	}
	assert(p);
	return(mdoc_perr(mdoc, line, pos, p));
}


d604 1
a604 1
		(void)perr(mdoc, line, *pos, EQUOTTERM);
d797 1
a797 1
		return(perr(m, line, ppos, EARGVAL));
@


1.5
log
@sync to 1.7.23: unify the various "enum merr" into libman.h and libmdoc.h,
use it as a new argument to mdoc_err(), the same way as for for man_err(),
and use string tables instead of switch statements to select error messages
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.4 2009/06/21 19:09:58 schwarze Exp $ */
d232 1
a232 1
mdoc_argv(struct mdoc *mdoc, int line, int tok,
d281 1
a281 1
		if ( ! pwarn(mdoc, line, i, WARGVPARM))
d289 1
a289 1
	if ( ! argv(mdoc, line, &tmp, pos, buf))
d295 1
a295 1
			(void)verr(mdoc, EMALLOC);
d306 1
a306 1
		(void)verr(mdoc, EMALLOC);
d750 1
a750 1
argv_multi(struct mdoc *mdoc, int line, 
d759 1
a759 1
		c = args(mdoc, line, pos, buf, ARGS_QUOTED, &p);
d769 1
a769 1
				(void)verr(mdoc, EMALLOC);
d774 1
a774 1
			return(verr(mdoc, EMALLOC));
d782 1
a782 1
argv_opt_single(struct mdoc *mdoc, int line, 
d791 1
a791 1
	c = args(mdoc, line, pos, buf, ARGS_QUOTED, &p);
d799 1
a799 1
		return(verr(mdoc, EMALLOC));
d801 1
a801 1
		return(verr(mdoc, EMALLOC));
d811 1
a811 1
argv_single(struct mdoc *mdoc, int line, 
d819 1
a819 1
	c = args(mdoc, line, pos, buf, ARGS_QUOTED, &p);
d823 1
a823 1
		return(perr(mdoc, line, ppos, EARGVAL));
d827 1
a827 1
		return(verr(mdoc, EMALLOC));
d829 1
a829 1
		return(verr(mdoc, EMALLOC));
@


1.4
log
@sync to 1.7.19: .Bl -column  now correctly handles tail entries,
for example:  .Bl -column -compact -offset ... args ...
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.3 2009/06/18 23:34:53 schwarze Exp $ */
a54 6
};

enum	merr {
	EQUOTTERM,
	EMALLOC,
	EARGVAL	
@


1.3
log
@sync to 1.7.19: improved comment handling
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.2 2009/06/14 23:00:57 schwarze Exp $ */
d35 3
d122 1
a122 1
	0, /* Bl */
d759 1
a759 1
	int		 c, ppos;
a761 2
	ppos = *pos;

d783 1
a783 4
	if (v->sz)
		return(1);

	return(perr(mdoc, line, ppos, EARGVAL));
@


1.2
log
@sync to 1.7.16: comments, whitespace and spelling fixes; no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_argv.c,v 1.4 2009/06/10 20:18:43 kristaps Exp $ */
d108 1
a108 1
	0, /* \" */
a214 1
	0, /* Ap */
@


1.1
log
@Initial check-in of mandoc for formatting manuals. ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: mdoc_argv.c,v 1.2 2009/03/31 13:50:19 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@

