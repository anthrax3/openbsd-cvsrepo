head	1.152;
access;
symbols
	OPENBSD_6_1:1.144.0.4
	OPENBSD_6_1_BASE:1.144
	OPENBSD_6_0:1.140.0.4
	OPENBSD_6_0_BASE:1.140
	OPENBSD_5_9:1.140.0.2
	OPENBSD_5_9_BASE:1.140
	OPENBSD_5_8:1.136.0.4
	OPENBSD_5_8_BASE:1.136
	OPENBSD_5_7:1.121.0.2
	OPENBSD_5_7_BASE:1.121
	OPENBSD_5_6:1.103.0.4
	OPENBSD_5_6_BASE:1.103
	OPENBSD_5_5:1.94.0.4
	OPENBSD_5_5_BASE:1.94
	OPENBSD_5_4:1.90.0.4
	OPENBSD_5_4_BASE:1.90
	OPENBSD_5_3:1.90.0.2
	OPENBSD_5_3_BASE:1.90
	OPENBSD_5_2:1.87.0.2
	OPENBSD_5_2_BASE:1.87
	OPENBSD_5_1_BASE:1.81
	OPENBSD_5_1:1.81.0.2
	OPENBSD_5_0:1.70.0.2
	OPENBSD_5_0_BASE:1.70
	OPENBSD_4_9:1.64.0.2
	OPENBSD_4_9_BASE:1.64
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8;
locks; strict;
comment	@ * @;


1.152
date	2017.05.07.21.44.33;	author schwarze;	state Exp;
branches;
next	1.151;
commitid	704SAGGctSMqvomY;

1.151
date	2017.05.07.17.30.58;	author schwarze;	state Exp;
branches;
next	1.150;
commitid	pfMPALNhm77dpGFF;

1.150
date	2017.05.05.15.16.25;	author schwarze;	state Exp;
branches;
next	1.149;
commitid	sNJdFUhzoVfGBx2p;

1.149
date	2017.05.05.13.17.04;	author schwarze;	state Exp;
branches;
next	1.148;
commitid	GvSRKa33jIoa4JAJ;

1.148
date	2017.05.05.02.06.17;	author schwarze;	state Exp;
branches;
next	1.147;
commitid	JMX1RJlA2uFuu13l;

1.147
date	2017.05.04.22.07.44;	author schwarze;	state Exp;
branches;
next	1.146;
commitid	hU9bJPcS66QLg54n;

1.146
date	2017.05.04.17.48.24;	author schwarze;	state Exp;
branches;
next	1.145;
commitid	RHQLdCAdHKxKe8Eu;

1.145
date	2017.04.24.23.06.09;	author schwarze;	state Exp;
branches;
next	1.144;
commitid	2CfzvK3gmiJH7vY0;

1.144
date	2017.02.15.14.09.07;	author schwarze;	state Exp;
branches;
next	1.143;
commitid	GpMPhEq4hXEuHh9G;

1.143
date	2017.02.11.21.49.43;	author schwarze;	state Exp;
branches;
next	1.142;
commitid	Bk6b7d66Qe6mft5g;

1.142
date	2017.02.04.11.56.48;	author schwarze;	state Exp;
branches;
next	1.141;
commitid	MXtX3fFtqob7upHI;

1.141
date	2017.01.10.13.46.53;	author schwarze;	state Exp;
branches;
next	1.140;
commitid	aFt8sLe7F06PjFYh;

1.140
date	2016.01.08.17.48.04;	author schwarze;	state Exp;
branches;
next	1.139;
commitid	DoGoemryKYV644MI;

1.139
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.138;
commitid	Ql2ha5NS80pwfGNT;

1.138
date	2015.10.06.18.30.43;	author schwarze;	state Exp;
branches;
next	1.137;
commitid	hxQV8O1pNUaef4ir;

1.137
date	2015.09.21.13.24.32;	author schwarze;	state Exp;
branches;
next	1.136;
commitid	hh1XsHF4k03QJZSt;

1.136
date	2015.04.19.19.43.50;	author schwarze;	state Exp;
branches;
next	1.135;
commitid	ae3n60cZNyRvqcze;

1.135
date	2015.04.19.13.59.37;	author schwarze;	state Exp;
branches;
next	1.134;
commitid	aS3h5dIgZk0f7675;

1.134
date	2015.04.18.17.50.02;	author schwarze;	state Exp;
branches;
next	1.133;
commitid	sjmmdLSx1e3Vat0h;

1.133
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.132;
commitid	6MYJ7cd8mhJ77AGH;

1.132
date	2015.04.06.22.06.06;	author schwarze;	state Exp;
branches;
next	1.131;
commitid	bTwtLNU3ySfNeqfs;

1.131
date	2015.04.06.14.58.53;	author schwarze;	state Exp;
branches;
next	1.130;
commitid	FECI1IibUVyBJ9qg;

1.130
date	2015.04.06.13.34.54;	author schwarze;	state Exp;
branches;
next	1.129;
commitid	SwGL2xbaNtOipjxw;

1.129
date	2015.04.04.18.52.12;	author schwarze;	state Exp;
branches;
next	1.128;
commitid	csNVdhUO2aTx3zkn;

1.128
date	2015.04.04.17.46.58;	author schwarze;	state Exp;
branches;
next	1.127;
commitid	exqqP0KNSHrSyO21;

1.127
date	2015.04.04.11.43.53;	author schwarze;	state Exp;
branches;
next	1.126;
commitid	WUtfzlUFj2w5Upzq;

1.126
date	2015.04.02.23.47.43;	author schwarze;	state Exp;
branches;
next	1.125;
commitid	RJFkOLiS9gBqEEDl;

1.125
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.124;
commitid	Rfx1oTaH3hZ7Zcyf;

1.124
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.123;
commitid	lmErjWY2O9ooA6RY;

1.123
date	2015.03.15.16.51.34;	author schwarze;	state Exp;
branches;
next	1.122;
commitid	qDJr4MnPNBaLgBLo;

1.122
date	2015.03.09.17.41.36;	author schwarze;	state Exp;
branches;
next	1.121;
commitid	EhhvqT5WwS4ZT2a7;

1.121
date	2015.01.30.22.04.15;	author schwarze;	state Exp;
branches;
next	1.120;
commitid	EStyTVNpkesjWq58;

1.120
date	2015.01.30.17.31.20;	author schwarze;	state Exp;
branches;
next	1.119;
commitid	8uPgte1HahL1XRHj;

1.119
date	2015.01.24.02.41.32;	author schwarze;	state Exp;
branches;
next	1.118;
commitid	TIJT04XdY4be3Or5;

1.118
date	2014.12.24.18.03.34;	author schwarze;	state Exp;
branches;
next	1.117;
commitid	pA0fllLbjk8z3ZlT;

1.117
date	2014.12.24.09.57.41;	author schwarze;	state Exp;
branches;
next	1.116;
commitid	4KdFONMNDcZ3Fih8;

1.116
date	2014.12.23.13.48.15;	author schwarze;	state Exp;
branches;
next	1.115;
commitid	gQAVpbNdyny1vBnL;

1.115
date	2014.12.23.09.31.17;	author schwarze;	state Exp;
branches;
next	1.114;
commitid	SXZbldG8wiiZaqvE;

1.114
date	2014.12.23.08.15.37;	author schwarze;	state Exp;
branches;
next	1.113;
commitid	5hAia37CVisk2IYF;

1.113
date	2014.12.23.01.57.11;	author schwarze;	state Exp;
branches;
next	1.112;
commitid	ynW5AXFwld5oo7dM;

1.112
date	2014.12.04.02.05.16;	author schwarze;	state Exp;
branches;
next	1.111;
commitid	P8Z9Zeh4SkD71zxl;

1.111
date	2014.12.04.01.33.23;	author schwarze;	state Exp;
branches;
next	1.110;
commitid	7FwQQF5hZ18I720y;

1.110
date	2014.12.02.10.07.17;	author schwarze;	state Exp;
branches;
next	1.109;
commitid	G1dK13T4nePhhgx3;

1.109
date	2014.11.21.01.52.44;	author schwarze;	state Exp;
branches;
next	1.108;
commitid	hm1luQGz9X3OaZNV;

1.108
date	2014.10.28.17.35.42;	author schwarze;	state Exp;
branches;
next	1.107;
commitid	pNwmOla3ZQwLgu2f;

1.107
date	2014.10.20.15.49.45;	author schwarze;	state Exp;
branches;
next	1.106;
commitid	xAL9AbgdIC6Bgc5x;

1.106
date	2014.10.20.02.46.00;	author schwarze;	state Exp;
branches;
next	1.105;
commitid	42BxgTg8wZRAL7i6;

1.105
date	2014.10.20.02.31.44;	author schwarze;	state Exp;
branches;
next	1.104;
commitid	jVScYQL5VkcOk52z;

1.104
date	2014.09.03.05.17.08;	author schwarze;	state Exp;
branches;
next	1.103;
commitid	D4HCUw9YYVx6NSQl;

1.103
date	2014.06.20.22.58.41;	author schwarze;	state Exp;
branches;
next	1.102;
commitid	ktgkM223FL3EC6E8;

1.102
date	2014.04.23.16.07.06;	author schwarze;	state Exp;
branches;
next	1.101;

1.101
date	2014.04.20.20.17.36;	author schwarze;	state Exp;
branches;
next	1.100;

1.100
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.99;

1.99
date	2014.04.08.07.13.01;	author schwarze;	state Exp;
branches;
next	1.98;

1.98
date	2014.03.30.21.27.59;	author schwarze;	state Exp;
branches;
next	1.97;

1.97
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.96;

1.96
date	2014.03.08.16.19.59;	author schwarze;	state Exp;
branches;
next	1.95;

1.95
date	2014.03.08.15.50.21;	author schwarze;	state Exp;
branches;
next	1.94;

1.94
date	2014.02.16.12.30.51;	author schwarze;	state Exp;
branches;
next	1.93;

1.93
date	2013.12.22.23.33.52;	author schwarze;	state Exp;
branches;
next	1.92;

1.92
date	2013.11.11.00.35.51;	author schwarze;	state Exp;
branches;
next	1.91;

1.91
date	2013.10.17.20.51.30;	author schwarze;	state Exp;
branches;
next	1.90;

1.90
date	2013.01.05.22.18.59;	author schwarze;	state Exp;
branches;
next	1.89;

1.89
date	2012.11.17.00.25.20;	author schwarze;	state Exp;
branches;
next	1.88;

1.88
date	2012.07.29.12.35.05;	author schwarze;	state Exp;
branches;
next	1.87;

1.87
date	2012.07.16.21.58.39;	author schwarze;	state Exp;
branches;
next	1.86;

1.86
date	2012.07.14.10.43.48;	author schwarze;	state Exp;
branches;
next	1.85;

1.85
date	2012.07.13.14.15.50;	author schwarze;	state Exp;
branches;
next	1.84;

1.84
date	2012.07.10.19.53.11;	author schwarze;	state Exp;
branches;
next	1.83;

1.83
date	2012.06.02.20.07.09;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2012.02.26.19.41.27;	author schwarze;	state Exp;
branches;
next	1.81;

1.81
date	2011.12.05.00.28.12;	author schwarze;	state Exp;
branches;
next	1.80;

1.80
date	2011.12.04.00.44.18;	author schwarze;	state Exp;
branches;
next	1.79;

1.79
date	2011.11.13.15.46.04;	author schwarze;	state Exp;
branches;
next	1.78;

1.78
date	2011.11.13.15.29.44;	author schwarze;	state Exp;
branches;
next	1.77;

1.77
date	2011.11.13.13.05.23;	author schwarze;	state Exp;
branches;
next	1.76;

1.76
date	2011.09.21.09.57.11;	author schwarze;	state Exp;
branches;
next	1.75;

1.75
date	2011.09.20.14.20.47;	author schwarze;	state Exp;
branches;
next	1.74;

1.74
date	2011.09.20.13.13.21;	author schwarze;	state Exp;
branches;
next	1.73;

1.73
date	2011.09.20.09.02.18;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2011.09.19.22.36.11;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2011.07.07.21.10.48;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2011.07.05.04.12.41;	author schwarze;	state Exp;
branches;
next	1.68;

1.68
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2011.03.20.23.36.42;	author schwarze;	state Exp;
branches;
next	1.65;

1.65
date	2011.03.07.01.35.33;	author schwarze;	state Exp;
branches;
next	1.64;

1.64
date	2011.01.25.12.35.07;	author schwarze;	state Exp;
branches;
next	1.63;

1.63
date	2011.01.23.14.54.15;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2011.01.17.00.15.19;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2011.01.16.03.46.21;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2011.01.16.02.56.47;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2011.01.11.00.59.28;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2011.01.04.01.15.39;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2010.12.19.07.53.12;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2010.12.07.00.08.52;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2010.12.06.22.43.54;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2010.11.29.02.26.45;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2010.11.29.00.12.02;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2010.10.28.10.42.39;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2010.10.16.20.49.37;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2010.10.15.22.07.12;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2010.10.15.21.33.47;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2010.10.15.20.45.03;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2010.09.21.22.33.41;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2010.06.27.21.54.42;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.26.19.08.00;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.10.22.50.10;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.06.18.08.41;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.05.19.09.55;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.24.01.36.22;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.23.22.45.00;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.23.20.57.16;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.20.00.58.02;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.16.00.54.03;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.15.22.18.55;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2010.05.15.21.09.53;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.15.18.06.03;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.14.19.52.43;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.14.14.47.44;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.25.16.32.19;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2010.03.26.01.22.05;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2010.03.25.23.23.01;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2010.03.02.01.24.04;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2010.03.02.01.17.20;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2010.03.02.01.00.39;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2010.02.26.12.42.29;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2009.12.24.02.08.14;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.21.19.13.50;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.19.21.43.16;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.21.20.57.57;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.21.20.28.43;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.18.22.46.14;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.22.23.17.40;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.22.20.19.24;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.22.20.14.37;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.22.18.10.02;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2009.08.22.15.15.37;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.23.22.43.30;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.21.20.49.33;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.18.23.34.53;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.18.21.34.54;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.18.21.16.11;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.17.22.27.34;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.14.23.00.57;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.20.30.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.152
log
@implement .DT in terms of .ta; needed for print/ghostview, for example
@
text
@/*	$OpenBSD: man_term.c,v 1.151 2017/05/07 17:30:58 schwarze Exp $ */
/*
 * Copyright (c) 2008-2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010-2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "man.h"
#include "out.h"
#include "term.h"
#include "main.h"

#define	MAXMARGINS	  64 /* maximum number of indented scopes */

struct	mtermp {
	int		  fl;
#define	MANT_LITERAL	 (1 << 0)
	int		  lmargin[MAXMARGINS]; /* margins (incl. vis. page) */
	int		  lmargincur; /* index of current margin */
	int		  lmarginsz; /* actual number of nested margins */
	size_t		  offset; /* default offset to visible page */
	int		  pardist; /* vert. space before par., unit: [v] */
};

#define	DECL_ARGS	  struct termp *p, \
			  struct mtermp *mt, \
			  struct roff_node *n, \
			  const struct roff_meta *meta

struct	termact {
	int		(*pre)(DECL_ARGS);
	void		(*post)(DECL_ARGS);
	int		  flags;
#define	MAN_NOTEXT	 (1 << 0) /* Never has text children. */
};

static	void		  print_man_nodelist(DECL_ARGS);
static	void		  print_man_node(DECL_ARGS);
static	void		  print_man_head(struct termp *,
				const struct roff_meta *);
static	void		  print_man_foot(struct termp *,
				const struct roff_meta *);
static	void		  print_bvspace(struct termp *,
				const struct roff_node *, int);

static	int		  pre_B(DECL_ARGS);
static	int		  pre_DT(DECL_ARGS);
static	int		  pre_HP(DECL_ARGS);
static	int		  pre_I(DECL_ARGS);
static	int		  pre_IP(DECL_ARGS);
static	int		  pre_OP(DECL_ARGS);
static	int		  pre_PD(DECL_ARGS);
static	int		  pre_PP(DECL_ARGS);
static	int		  pre_RS(DECL_ARGS);
static	int		  pre_SH(DECL_ARGS);
static	int		  pre_SS(DECL_ARGS);
static	int		  pre_TP(DECL_ARGS);
static	int		  pre_UR(DECL_ARGS);
static	int		  pre_alternate(DECL_ARGS);
static	int		  pre_ign(DECL_ARGS);
static	int		  pre_in(DECL_ARGS);
static	int		  pre_literal(DECL_ARGS);

static	void		  post_IP(DECL_ARGS);
static	void		  post_HP(DECL_ARGS);
static	void		  post_RS(DECL_ARGS);
static	void		  post_SH(DECL_ARGS);
static	void		  post_SS(DECL_ARGS);
static	void		  post_TP(DECL_ARGS);
static	void		  post_UR(DECL_ARGS);

static	const struct termact __termacts[MAN_MAX - MAN_TH] = {
	{ NULL, NULL, 0 }, /* TH */
	{ pre_SH, post_SH, 0 }, /* SH */
	{ pre_SS, post_SS, 0 }, /* SS */
	{ pre_TP, post_TP, 0 }, /* TP */
	{ pre_PP, NULL, 0 }, /* LP */
	{ pre_PP, NULL, 0 }, /* PP */
	{ pre_PP, NULL, 0 }, /* P */
	{ pre_IP, post_IP, 0 }, /* IP */
	{ pre_HP, post_HP, 0 }, /* HP */
	{ NULL, NULL, 0 }, /* SM */
	{ pre_B, NULL, 0 }, /* SB */
	{ pre_alternate, NULL, 0 }, /* BI */
	{ pre_alternate, NULL, 0 }, /* IB */
	{ pre_alternate, NULL, 0 }, /* BR */
	{ pre_alternate, NULL, 0 }, /* RB */
	{ NULL, NULL, 0 }, /* R */
	{ pre_B, NULL, 0 }, /* B */
	{ pre_I, NULL, 0 }, /* I */
	{ pre_alternate, NULL, 0 }, /* IR */
	{ pre_alternate, NULL, 0 }, /* RI */
	{ pre_literal, NULL, 0 }, /* nf */
	{ pre_literal, NULL, 0 }, /* fi */
	{ NULL, NULL, 0 }, /* RE */
	{ pre_RS, post_RS, 0 }, /* RS */
	{ pre_DT, NULL, 0 }, /* DT */
	{ pre_ign, NULL, MAN_NOTEXT }, /* UC */
	{ pre_PD, NULL, MAN_NOTEXT }, /* PD */
	{ pre_ign, NULL, 0 }, /* AT */
	{ pre_in, NULL, MAN_NOTEXT }, /* in */
	{ pre_OP, NULL, 0 }, /* OP */
	{ pre_literal, NULL, 0 }, /* EX */
	{ pre_literal, NULL, 0 }, /* EE */
	{ pre_UR, post_UR, 0 }, /* UR */
	{ NULL, NULL, 0 }, /* UE */
};
static	const struct termact *termacts = __termacts - MAN_TH;


void
terminal_man(void *arg, const struct roff_man *man)
{
	struct termp		*p;
	struct roff_node	*n;
	struct mtermp		 mt;
	size_t			 save_defindent;

	p = (struct termp *)arg;
	p->overstep = 0;
	p->rmargin = p->maxrmargin = p->defrmargin;
	term_tab_set(p, NULL);
	term_tab_set(p, "T");
	term_tab_set(p, ".5i");

	memset(&mt, 0, sizeof(struct mtermp));
	mt.lmargin[mt.lmargincur] = term_len(p, p->defindent);
	mt.offset = term_len(p, p->defindent);
	mt.pardist = 1;

	n = man->first->child;
	if (p->synopsisonly) {
		while (n != NULL) {
			if (n->tok == MAN_SH &&
			    n->child->child->type == ROFFT_TEXT &&
			    !strcmp(n->child->child->string, "SYNOPSIS")) {
				if (n->child->next->child != NULL)
					print_man_nodelist(p, &mt,
					    n->child->next->child,
					    &man->meta);
				term_newln(p);
				break;
			}
			n = n->next;
		}
	} else {
		save_defindent = p->defindent;
		if (p->defindent == 0)
			p->defindent = 7;
		term_begin(p, print_man_head, print_man_foot, &man->meta);
		p->flags |= TERMP_NOSPACE;
		if (n != NULL)
			print_man_nodelist(p, &mt, n, &man->meta);
		term_end(p);
		p->defindent = save_defindent;
	}
}

/*
 * Printing leading vertical space before a block.
 * This is used for the paragraph macros.
 * The rules are pretty simple, since there's very little nesting going
 * on here.  Basically, if we're the first within another block (SS/SH),
 * then don't emit vertical space.  If we are (RS), then do.  If not the
 * first, print it.
 */
static void
print_bvspace(struct termp *p, const struct roff_node *n, int pardist)
{
	int	 i;

	term_newln(p);

	if (n->body && n->body->child)
		if (n->body->child->type == ROFFT_TBL)
			return;

	if (n->parent->type == ROFFT_ROOT || n->parent->tok != MAN_RS)
		if (NULL == n->prev)
			return;

	for (i = 0; i < pardist; i++)
		term_vspace(p);
}


static int
pre_ign(DECL_ARGS)
{

	return 0;
}

static int
pre_I(DECL_ARGS)
{

	term_fontrepl(p, TERMFONT_UNDER);
	return 1;
}

static int
pre_literal(DECL_ARGS)
{

	term_newln(p);

	if (MAN_nf == n->tok || MAN_EX == n->tok)
		mt->fl |= MANT_LITERAL;
	else
		mt->fl &= ~MANT_LITERAL;

	/*
	 * Unlike .IP and .TP, .HP does not have a HEAD.
	 * So in case a second call to term_flushln() is needed,
	 * indentation has to be set up explicitly.
	 */
	if (MAN_HP == n->parent->tok && p->rmargin < p->maxrmargin) {
		p->offset = p->rmargin;
		p->rmargin = p->maxrmargin;
		p->trailspace = 0;
		p->flags &= ~(TERMP_NOBREAK | TERMP_BRIND);
		p->flags |= TERMP_NOSPACE;
	}

	return 0;
}

static int
pre_PD(DECL_ARGS)
{
	struct roffsu	 su;

	n = n->child;
	if (n == NULL) {
		mt->pardist = 1;
		return 0;
	}
	assert(n->type == ROFFT_TEXT);
	if (a2roffsu(n->string, &su, SCALE_VS))
		mt->pardist = term_vspan(p, &su);
	return 0;
}

static int
pre_alternate(DECL_ARGS)
{
	enum termfont		 font[2];
	struct roff_node	*nn;
	int			 savelit, i;

	switch (n->tok) {
	case MAN_RB:
		font[0] = TERMFONT_NONE;
		font[1] = TERMFONT_BOLD;
		break;
	case MAN_RI:
		font[0] = TERMFONT_NONE;
		font[1] = TERMFONT_UNDER;
		break;
	case MAN_BR:
		font[0] = TERMFONT_BOLD;
		font[1] = TERMFONT_NONE;
		break;
	case MAN_BI:
		font[0] = TERMFONT_BOLD;
		font[1] = TERMFONT_UNDER;
		break;
	case MAN_IR:
		font[0] = TERMFONT_UNDER;
		font[1] = TERMFONT_NONE;
		break;
	case MAN_IB:
		font[0] = TERMFONT_UNDER;
		font[1] = TERMFONT_BOLD;
		break;
	default:
		abort();
	}

	savelit = MANT_LITERAL & mt->fl;
	mt->fl &= ~MANT_LITERAL;

	for (i = 0, nn = n->child; nn; nn = nn->next, i = 1 - i) {
		term_fontrepl(p, font[i]);
		if (savelit && NULL == nn->next)
			mt->fl |= MANT_LITERAL;
		assert(nn->type == ROFFT_TEXT);
		term_word(p, nn->string);
		if (nn->flags & NODE_EOS)
                	p->flags |= TERMP_SENTENCE;
		if (nn->next)
			p->flags |= TERMP_NOSPACE;
	}

	return 0;
}

static int
pre_B(DECL_ARGS)
{

	term_fontrepl(p, TERMFONT_BOLD);
	return 1;
}

static int
pre_OP(DECL_ARGS)
{

	term_word(p, "[");
	p->flags |= TERMP_NOSPACE;

	if (NULL != (n = n->child)) {
		term_fontrepl(p, TERMFONT_BOLD);
		term_word(p, n->string);
	}
	if (NULL != n && NULL != n->next) {
		term_fontrepl(p, TERMFONT_UNDER);
		term_word(p, n->next->string);
	}

	term_fontrepl(p, TERMFONT_NONE);
	p->flags |= TERMP_NOSPACE;
	term_word(p, "]");
	return 0;
}

static int
pre_in(DECL_ARGS)
{
	struct roffsu	 su;
	const char	*cp;
	size_t		 v;
	int		 less;

	term_newln(p);

	if (NULL == n->child) {
		p->offset = mt->offset;
		return 0;
	}

	cp = n->child->string;
	less = 0;

	if ('-' == *cp)
		less = -1;
	else if ('+' == *cp)
		less = 1;
	else
		cp--;

	if ( ! a2roffsu(++cp, &su, SCALE_EN))
		return 0;

	v = (term_hspan(p, &su) + 11) / 24;

	if (less < 0)
		p->offset -= p->offset > v ? v : p->offset;
	else if (less > 0)
		p->offset += v;
	else
		p->offset = v;
	if (p->offset > SHRT_MAX)
		p->offset = term_len(p, p->defindent);

	return 0;
}

static int
pre_DT(DECL_ARGS)
{
	term_tab_set(p, NULL);
	term_tab_set(p, "T");
	term_tab_set(p, ".5i");
	return 0;
}

static int
pre_HP(DECL_ARGS)
{
	struct roffsu		 su;
	const struct roff_node	*nn;
	int			 len;

	switch (n->type) {
	case ROFFT_BLOCK:
		print_bvspace(p, n, mt->pardist);
		return 1;
	case ROFFT_BODY:
		break;
	default:
		return 0;
	}

	if ( ! (MANT_LITERAL & mt->fl)) {
		p->flags |= TERMP_NOBREAK | TERMP_BRIND;
		p->trailspace = 2;
	}

	/* Calculate offset. */

	if ((nn = n->parent->head->child) != NULL &&
	    a2roffsu(nn->string, &su, SCALE_EN)) {
		len = term_hspan(p, &su) / 24;
		if (len < 0 && (size_t)(-len) > mt->offset)
			len = -mt->offset;
		else if (len > SHRT_MAX)
			len = term_len(p, p->defindent);
		mt->lmargin[mt->lmargincur] = len;
	} else
		len = mt->lmargin[mt->lmargincur];

	p->offset = mt->offset;
	p->rmargin = mt->offset + len;
	return 1;
}

static void
post_HP(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_BODY:
		term_newln(p);

		/*
		 * Compatibility with a groff bug.
		 * The .HP macro uses the undocumented .tag request
		 * which causes a line break and cancels no-space
		 * mode even if there isn't any output.
		 */

		if (n->child == NULL)
			term_vspace(p);

		p->flags &= ~(TERMP_NOBREAK | TERMP_BRIND);
		p->trailspace = 0;
		p->offset = mt->offset;
		p->rmargin = p->maxrmargin;
		break;
	default:
		break;
	}
}

static int
pre_PP(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		mt->lmargin[mt->lmargincur] = term_len(p, p->defindent);
		print_bvspace(p, n, mt->pardist);
		break;
	default:
		p->offset = mt->offset;
		break;
	}

	return n->type != ROFFT_HEAD;
}

static int
pre_IP(DECL_ARGS)
{
	struct roffsu		 su;
	const struct roff_node	*nn;
	int			 len, savelit;

	switch (n->type) {
	case ROFFT_BODY:
		p->flags |= TERMP_NOSPACE;
		break;
	case ROFFT_HEAD:
		p->flags |= TERMP_NOBREAK;
		p->trailspace = 1;
		break;
	case ROFFT_BLOCK:
		print_bvspace(p, n, mt->pardist);
		/* FALLTHROUGH */
	default:
		return 1;
	}

	/* Calculate the offset from the optional second argument. */
	if ((nn = n->parent->head->child) != NULL &&
	    (nn = nn->next) != NULL &&
	    a2roffsu(nn->string, &su, SCALE_EN)) {
		len = term_hspan(p, &su) / 24;
		if (len < 0 && (size_t)(-len) > mt->offset)
			len = -mt->offset;
		else if (len > SHRT_MAX)
			len = term_len(p, p->defindent);
		mt->lmargin[mt->lmargincur] = len;
	} else
		len = mt->lmargin[mt->lmargincur];

	switch (n->type) {
	case ROFFT_HEAD:
		p->offset = mt->offset;
		p->rmargin = mt->offset + len;

		savelit = MANT_LITERAL & mt->fl;
		mt->fl &= ~MANT_LITERAL;

		if (n->child)
			print_man_node(p, mt, n->child, meta);

		if (savelit)
			mt->fl |= MANT_LITERAL;

		return 0;
	case ROFFT_BODY:
		p->offset = mt->offset + len;
		p->rmargin = p->maxrmargin;
		break;
	default:
		break;
	}

	return 1;
}

static void
post_IP(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_HEAD:
		term_flushln(p);
		p->flags &= ~TERMP_NOBREAK;
		p->trailspace = 0;
		p->rmargin = p->maxrmargin;
		break;
	case ROFFT_BODY:
		term_newln(p);
		p->offset = mt->offset;
		break;
	default:
		break;
	}
}

static int
pre_TP(DECL_ARGS)
{
	struct roffsu		 su;
	struct roff_node	*nn;
	int			 len, savelit;

	switch (n->type) {
	case ROFFT_HEAD:
		p->flags |= TERMP_NOBREAK | TERMP_BRTRSP;
		p->trailspace = 1;
		break;
	case ROFFT_BODY:
		p->flags |= TERMP_NOSPACE;
		break;
	case ROFFT_BLOCK:
		print_bvspace(p, n, mt->pardist);
		/* FALLTHROUGH */
	default:
		return 1;
	}

	/* Calculate offset. */

	if ((nn = n->parent->head->child) != NULL &&
	    nn->string != NULL && ! (NODE_LINE & nn->flags) &&
	    a2roffsu(nn->string, &su, SCALE_EN)) {
		len = term_hspan(p, &su) / 24;
		if (len < 0 && (size_t)(-len) > mt->offset)
			len = -mt->offset;
		else if (len > SHRT_MAX)
			len = term_len(p, p->defindent);
		mt->lmargin[mt->lmargincur] = len;
	} else
		len = mt->lmargin[mt->lmargincur];

	switch (n->type) {
	case ROFFT_HEAD:
		p->offset = mt->offset;
		p->rmargin = mt->offset + len;

		savelit = MANT_LITERAL & mt->fl;
		mt->fl &= ~MANT_LITERAL;

		/* Don't print same-line elements. */
		nn = n->child;
		while (NULL != nn && 0 == (NODE_LINE & nn->flags))
			nn = nn->next;

		while (NULL != nn) {
			print_man_node(p, mt, nn, meta);
			nn = nn->next;
		}

		if (savelit)
			mt->fl |= MANT_LITERAL;
		return 0;
	case ROFFT_BODY:
		p->offset = mt->offset + len;
		p->rmargin = p->maxrmargin;
		p->trailspace = 0;
		p->flags &= ~(TERMP_NOBREAK | TERMP_BRTRSP);
		break;
	default:
		break;
	}

	return 1;
}

static void
post_TP(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_HEAD:
		term_flushln(p);
		break;
	case ROFFT_BODY:
		term_newln(p);
		p->offset = mt->offset;
		break;
	default:
		break;
	}
}

static int
pre_SS(DECL_ARGS)
{
	int	 i;

	switch (n->type) {
	case ROFFT_BLOCK:
		mt->fl &= ~MANT_LITERAL;
		mt->lmargin[mt->lmargincur] = term_len(p, p->defindent);
		mt->offset = term_len(p, p->defindent);

		/*
		 * No vertical space before the first subsection
		 * and after an empty subsection.
		 */

		do {
			n = n->prev;
		} while (n != NULL && n->tok != TOKEN_NONE &&
		    termacts[n->tok].flags & MAN_NOTEXT);
		if (n == NULL || (n->tok == MAN_SS && n->body->child == NULL))
			break;

		for (i = 0; i < mt->pardist; i++)
			term_vspace(p);
		break;
	case ROFFT_HEAD:
		term_fontrepl(p, TERMFONT_BOLD);
		p->offset = term_len(p, 3);
		p->rmargin = mt->offset;
		p->trailspace = mt->offset;
		p->flags |= TERMP_NOBREAK | TERMP_BRIND;
		break;
	case ROFFT_BODY:
		p->offset = mt->offset;
		p->rmargin = p->maxrmargin;
		p->trailspace = 0;
		p->flags &= ~(TERMP_NOBREAK | TERMP_BRIND);
		break;
	default:
		break;
	}

	return 1;
}

static void
post_SS(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_HEAD:
		term_newln(p);
		break;
	case ROFFT_BODY:
		term_newln(p);
		break;
	default:
		break;
	}
}

static int
pre_SH(DECL_ARGS)
{
	int	 i;

	switch (n->type) {
	case ROFFT_BLOCK:
		mt->fl &= ~MANT_LITERAL;
		mt->lmargin[mt->lmargincur] = term_len(p, p->defindent);
		mt->offset = term_len(p, p->defindent);

		/*
		 * No vertical space before the first section
		 * and after an empty section.
		 */

		do {
			n = n->prev;
		} while (n != NULL && n->tok != TOKEN_NONE &&
		    termacts[n->tok].flags & MAN_NOTEXT);
		if (n == NULL || (n->tok == MAN_SH && n->body->child == NULL))
			break;

		for (i = 0; i < mt->pardist; i++)
			term_vspace(p);
		break;
	case ROFFT_HEAD:
		term_fontrepl(p, TERMFONT_BOLD);
		p->offset = 0;
		p->rmargin = mt->offset;
		p->trailspace = mt->offset;
		p->flags |= TERMP_NOBREAK | TERMP_BRIND;
		break;
	case ROFFT_BODY:
		p->offset = mt->offset;
		p->rmargin = p->maxrmargin;
		p->trailspace = 0;
		p->flags &= ~(TERMP_NOBREAK | TERMP_BRIND);
		break;
	default:
		break;
	}

	return 1;
}

static void
post_SH(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_HEAD:
		term_newln(p);
		break;
	case ROFFT_BODY:
		term_newln(p);
		break;
	default:
		break;
	}
}

static int
pre_RS(DECL_ARGS)
{
	struct roffsu	 su;

	switch (n->type) {
	case ROFFT_BLOCK:
		term_newln(p);
		return 1;
	case ROFFT_HEAD:
		return 0;
	default:
		break;
	}

	n = n->parent->head;
	n->aux = SHRT_MAX + 1;
	if (n->child == NULL)
		n->aux = mt->lmargin[mt->lmargincur];
	else if (a2roffsu(n->child->string, &su, SCALE_EN))
		n->aux = term_hspan(p, &su) / 24;
	if (n->aux < 0 && (size_t)(-n->aux) > mt->offset)
		n->aux = -mt->offset;
	else if (n->aux > SHRT_MAX)
		n->aux = term_len(p, p->defindent);

	mt->offset += n->aux;
	p->offset = mt->offset;
	p->rmargin = p->maxrmargin;

	if (++mt->lmarginsz < MAXMARGINS)
		mt->lmargincur = mt->lmarginsz;

	mt->lmargin[mt->lmargincur] = term_len(p, p->defindent);
	return 1;
}

static void
post_RS(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		return;
	case ROFFT_HEAD:
		return;
	default:
		term_newln(p);
		break;
	}

	mt->offset -= n->parent->head->aux;
	p->offset = mt->offset;

	if (--mt->lmarginsz < MAXMARGINS)
		mt->lmargincur = mt->lmarginsz;
}

static int
pre_UR(DECL_ARGS)
{

	return n->type != ROFFT_HEAD;
}

static void
post_UR(DECL_ARGS)
{

	if (n->type != ROFFT_BLOCK)
		return;

	term_word(p, "<");
	p->flags |= TERMP_NOSPACE;

	if (NULL != n->child->child)
		print_man_node(p, mt, n->child->child, meta);

	p->flags |= TERMP_NOSPACE;
	term_word(p, ">");
}

static void
print_man_node(DECL_ARGS)
{
	size_t		 rm, rmax;
	int		 c;

	switch (n->type) {
	case ROFFT_TEXT:
		/*
		 * If we have a blank line, output a vertical space.
		 * If we have a space as the first character, break
		 * before printing the line's data.
		 */
		if ('\0' == *n->string) {
			term_vspace(p);
			return;
		} else if (' ' == *n->string && NODE_LINE & n->flags)
			term_newln(p);

		term_word(p, n->string);
		goto out;

	case ROFFT_EQN:
		if ( ! (n->flags & NODE_LINE))
			p->flags |= TERMP_NOSPACE;
		term_eqn(p, n->eqn);
		if (n->next != NULL && ! (n->next->flags & NODE_LINE))
			p->flags |= TERMP_NOSPACE;
		return;
	case ROFFT_TBL:
		if (p->tbl.cols == NULL)
			term_vspace(p);
		term_tbl(p, n->span);
		return;
	default:
		break;
	}

	if (n->tok < ROFF_MAX) {
		roff_term_pre(p, n);
		return;
	}

	assert(n->tok >= MAN_TH && n->tok <= MAN_MAX);
	if ( ! (MAN_NOTEXT & termacts[n->tok].flags))
		term_fontrepl(p, TERMFONT_NONE);

	c = 1;
	if (termacts[n->tok].pre)
		c = (*termacts[n->tok].pre)(p, mt, n, meta);

	if (c && n->child)
		print_man_nodelist(p, mt, n->child, meta);

	if (termacts[n->tok].post)
		(*termacts[n->tok].post)(p, mt, n, meta);
	if ( ! (MAN_NOTEXT & termacts[n->tok].flags))
		term_fontrepl(p, TERMFONT_NONE);

out:
	/*
	 * If we're in a literal context, make sure that words
	 * together on the same line stay together.  This is a
	 * POST-printing call, so we check the NEXT word.  Since
	 * -man doesn't have nested macros, we don't need to be
	 * more specific than this.
	 */
	if (mt->fl & MANT_LITERAL &&
	    ! (p->flags & (TERMP_NOBREAK | TERMP_NONEWLINE)) &&
	    (n->next == NULL || n->next->flags & NODE_LINE)) {
		rm = p->rmargin;
		rmax = p->maxrmargin;
		p->rmargin = p->maxrmargin = TERM_MAXMARGIN;
		p->flags |= TERMP_NOSPACE;
		if (n->string != NULL && *n->string != '\0')
			term_flushln(p);
		else
			term_newln(p);
		if (rm < rmax && n->parent->tok == MAN_HP) {
			p->offset = rm;
			p->rmargin = rmax;
		} else
			p->rmargin = rm;
		p->maxrmargin = rmax;
	}
	if (NODE_EOS & n->flags)
		p->flags |= TERMP_SENTENCE;
}


static void
print_man_nodelist(DECL_ARGS)
{

	while (n != NULL) {
		print_man_node(p, mt, n, meta);
		n = n->next;
	}
}

static void
print_man_foot(struct termp *p, const struct roff_meta *meta)
{
	char			*title;
	size_t			 datelen, titlen;

	assert(meta->title);
	assert(meta->msec);
	assert(meta->date);

	term_fontrepl(p, TERMFONT_NONE);

	if (meta->hasbody)
		term_vspace(p);

	/*
	 * Temporary, undocumented option to imitate mdoc(7) output.
	 * In the bottom right corner, use the operating system
	 * instead of the title.
	 */

	if ( ! p->mdocstyle) {
		if (meta->hasbody) {
			term_vspace(p);
			term_vspace(p);
		}
		mandoc_asprintf(&title, "%s(%s)",
		    meta->title, meta->msec);
	} else if (meta->os) {
		title = mandoc_strdup(meta->os);
	} else {
		title = mandoc_strdup("");
	}
	datelen = term_strlen(p, meta->date);

	/* Bottom left corner: operating system. */

	p->flags |= TERMP_NOSPACE | TERMP_NOBREAK;
	p->trailspace = 1;
	p->offset = 0;
	p->rmargin = p->maxrmargin > datelen ?
	    (p->maxrmargin + term_len(p, 1) - datelen) / 2 : 0;

	if (meta->os)
		term_word(p, meta->os);
	term_flushln(p);

	/* At the bottom in the middle: manual date. */

	p->offset = p->rmargin;
	titlen = term_strlen(p, title);
	p->rmargin = p->maxrmargin > titlen ? p->maxrmargin - titlen : 0;
	p->flags |= TERMP_NOSPACE;

	term_word(p, meta->date);
	term_flushln(p);

	/* Bottom right corner: manual title and section. */

	p->flags &= ~TERMP_NOBREAK;
	p->flags |= TERMP_NOSPACE;
	p->trailspace = 0;
	p->offset = p->rmargin;
	p->rmargin = p->maxrmargin;

	term_word(p, title);
	term_flushln(p);
	free(title);
}

static void
print_man_head(struct termp *p, const struct roff_meta *meta)
{
	const char		*volume;
	char			*title;
	size_t			 vollen, titlen;

	assert(meta->title);
	assert(meta->msec);

	volume = NULL == meta->vol ? "" : meta->vol;
	vollen = term_strlen(p, volume);

	/* Top left corner: manual title and section. */

	mandoc_asprintf(&title, "%s(%s)", meta->title, meta->msec);
	titlen = term_strlen(p, title);

	p->flags |= TERMP_NOBREAK | TERMP_NOSPACE;
	p->trailspace = 1;
	p->offset = 0;
	p->rmargin = 2 * (titlen+1) + vollen < p->maxrmargin ?
	    (p->maxrmargin - vollen + term_len(p, 1)) / 2 :
	    vollen < p->maxrmargin ? p->maxrmargin - vollen : 0;

	term_word(p, title);
	term_flushln(p);

	/* At the top in the middle: manual volume. */

	p->flags |= TERMP_NOSPACE;
	p->offset = p->rmargin;
	p->rmargin = p->offset + vollen + titlen < p->maxrmargin ?
	    p->maxrmargin - titlen : p->maxrmargin;

	term_word(p, volume);
	term_flushln(p);

	/* Top right corner: title and section, again. */

	p->flags &= ~TERMP_NOBREAK;
	p->trailspace = 0;
	if (p->rmargin + titlen <= p->maxrmargin) {
		p->flags |= TERMP_NOSPACE;
		p->offset = p->rmargin;
		p->rmargin = p->maxrmargin;
		term_word(p, title);
		term_flushln(p);
	}

	p->flags &= ~TERMP_NOSPACE;
	p->offset = 0;
	p->rmargin = p->maxrmargin;

	/*
	 * Groff prints three blank lines before the content.
	 * Do the same, except in the temporary, undocumented
	 * mode imitating mdoc(7) output.
	 */

	term_vspace(p);
	if ( ! p->mdocstyle) {
		term_vspace(p);
		term_vspace(p);
	}
	free(title);
}
@


1.151
log
@Basic implementation of the roff(7) .ta (define tab stops) request.
This is the first feature made possible by the parser reorganization.
Improves the formatting of the SYNOPSIS in many Xenocara GL manuals.
Also important for ports, as reported by many, including naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.150 2017/05/05 15:16:25 schwarze Exp $ */
d69 1
d119 1
a119 1
	{ pre_ign, NULL, 0 }, /* DT */
d390 9
@


1.150
log
@Move .sp to the roff modules.  Enough infrastructure is in place
now that this actually saves code: -70 LOC.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.149 2017/05/05 13:17:04 schwarze Exp $ */
d143 3
a145 1
	p->tabwidth = term_len(p, 5);
@


1.149
log
@move .ll to the roff modules
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.148 2017/05/05 02:06:17 schwarze Exp $ */
a83 1
static	int		  pre_sp(DECL_ARGS);
a113 1
	{ pre_sp, NULL, MAN_NOTEXT }, /* sp */
a385 49

	return 0;
}

static int
pre_sp(DECL_ARGS)
{
	struct roffsu	 su;
	int		 i, len;

	if ((NULL == n->prev && n->parent)) {
		switch (n->parent->tok) {
		case MAN_SH:
		case MAN_SS:
		case MAN_PP:
		case MAN_LP:
		case MAN_P:
			return 0;
		default:
			break;
		}
	}

	if (n->child == NULL)
		len = 1;
	else {
		if ( ! a2roffsu(n->child->string, &su, SCALE_VS))
			su.scale = 1.0;
		len = term_vspan(p, &su);
	}

	if (len == 0)
		term_newln(p);
	else if (len < 0)
		p->skipvsp -= len;
	else
		for (i = 0; i < len; i++)
			term_vspace(p);

	/*
	 * Handle an explicit break request in the same way
	 * as an overflowing line.
	 */

	if (p->flags & TERMP_BRIND) {
		p->offset = p->rmargin;
		p->rmargin = p->maxrmargin;
		p->flags &= ~(TERMP_NOBREAK | TERMP_BRIND);
	}
@


1.148
log
@Move handling of the roff(7) .ft request from the man(7)
modules to the new roff(7) modules.  As a side effect,
mdoc(7) now handles .ft, too.  Of course, do not use that.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.147 2017/05/04 22:07:44 schwarze Exp $ */
a83 1
static	int		  pre_ll(DECL_ARGS);
a129 1
	{ pre_ll, NULL, MAN_NOTEXT }, /* ll */
a211 8
	return 0;
}

static int
pre_ll(DECL_ARGS)
{

	term_setwidth(p, n->child != NULL ? n->child->string : NULL);
@


1.147
log
@Start roff formatter modules for HTML and termininal output,
used by both the mdoc and man formatters, with the ultimate
goal of reducing code duplication between the two macro formatters.
Made possible by the parser unification.
Add the first formatting function (for the .br request).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.146 2017/05/04 17:48:24 schwarze Exp $ */
a80 1
static	int		  pre_ft(DECL_ARGS);
a125 1
	{ pre_ft, NULL, MAN_NOTEXT }, /* ft */
a356 35
	return 0;
}

static int
pre_ft(DECL_ARGS)
{
	const char	*cp;

	if (NULL == n->child) {
		term_fontlast(p);
		return 0;
	}

	cp = n->child->string;
	switch (*cp) {
	case '4':
	case '3':
	case 'B':
		term_fontrepl(p, TERMFONT_BOLD);
		break;
	case '2':
	case 'I':
		term_fontrepl(p, TERMFONT_UNDER);
		break;
	case 'P':
		term_fontlast(p);
		break;
	case '1':
	case 'C':
	case 'R':
		term_fontrepl(p, TERMFONT_NONE);
		break;
	default:
		break;
	}
@


1.146
log
@Parser reorg:
Generate the first node on the roff level: .br
Fix some column numbers in diagnostic messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.145 2017/04/24 23:06:09 schwarze Exp $ */
d458 1
a458 3
	if (n->tok == ROFF_br)
		len = 0;
	else if (n->child == NULL)
d986 1
a986 7
		switch (n->tok) {
		case ROFF_br:
			pre_sp(p, mt, n, meta);
			break;
		default:
			abort();
		}
@


1.145
log
@Continue parser unification:
* Make enum rofft an internal interface as enum roff_tok in "roff.h".
* Represent mdoc and man macros in enum roff_tok.
* Make TOKEN_NONE a proper enum value and use it throughout.
* Put the prologue macros first in the macro tables.
* Unify mdoc_macroname[] and man_macroname[] into roff_name[].
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.144 2017/02/15 14:09:07 schwarze Exp $ */
a116 1
	{ pre_sp, NULL, MAN_NOTEXT }, /* br */
d458 1
a458 1
	if (n->tok == MAN_br)
d987 12
@


1.144
log
@Fix previous:  I forgot that i had to change the convention how
a node is marked as "not a macro" when unifying the parsers.
Confirmed to work by Sevan Janiyan.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.143 2017/02/11 21:49:43 schwarze Exp $ */
d96 1
a96 2
static	const struct termact termacts[MAN_MAX] = {
	{ pre_sp, NULL, MAN_NOTEXT }, /* br */
d117 1
d136 1
@


1.143
log
@Do not read one element past the end of the static const termacts array.
Bug found by Sevan Janiyan <venture37 at geeklan dot co dot uk>
who ran the OpenBSD mandoc test suite on Ubuntu on POWER8 (sic!)
and reported that mdoc/Sh/before.in failed in -Tman mode.
If that isn't power testing, i don't know...
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.142 2017/02/04 11:56:48 schwarze Exp $ */
d823 1
a823 1
		} while (n != NULL && n->tok < MAN_MAX &&
@


1.142
log
@Do not fix the default indent for all subsequent files; some may use
a different macro language and hence require a different indent.
You can see the effect with "man -a 1 host hostname".
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.141 2017/01/10 13:46:53 schwarze Exp $ */
d823 2
a824 1
		} while (n != NULL && termacts[n->tok].flags & MAN_NOTEXT);
@


1.141
log
@unify names of AST node flags; no change of cpp output
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.140 2016/01/08 17:48:04 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2015 Ingo Schwarze <schwarze@@openbsd.org>
d144 1
d172 1
d180 1
@


1.140
log
@Delete the redundant "nchild" member of struct roff_node, replacing
most uses by one, a few by two pointer checks, and only one by a
tiny loop - not only making data smaller, but code shorter as well.

This gets rid of an implicit invariant that confused both static
analysis tools and human auditors.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.139 2015/10/12 00:07:27 schwarze Exp $ */
d320 1
a320 1
		if (nn->flags & MAN_EOS)
d678 1
a678 1
	    nn->string != NULL && ! (MAN_LINE & nn->flags) &&
d699 1
a699 1
		while (NULL != nn && 0 == (MAN_LINE & nn->flags))
d961 1
a961 1
		} else if (' ' == *n->string && MAN_LINE & n->flags)
d968 1
a968 1
		if ( ! (n->flags & MAN_LINE))
d971 1
a971 1
		if (n->next != NULL && ! (n->next->flags & MAN_LINE))
d1008 1
a1008 1
	    (n->next == NULL || n->next->flags & MAN_LINE)) {
d1024 1
a1024 1
	if (MAN_EOS & n->flags)
@


1.139
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.138 2015/10/06 18:30:43 schwarze Exp $ */
d220 1
a220 1
	term_setwidth(p, n->nchild ? n->child->string : NULL);
@


1.138
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.137 2015/09/21 13:24:32 schwarze Exp $ */
a371 1
		/* FALLTHROUGH */
a372 1
		/* FALLTHROUGH */
a376 1
		/* FALLTHROUGH */
a383 1
		/* FALLTHROUGH */
a384 1
		/* FALLTHROUGH */
a444 1
			/* FALLTHROUGH */
a445 1
			/* FALLTHROUGH */
a446 1
			/* FALLTHROUGH */
a447 1
			/* FALLTHROUGH */
a448 1
			/* FALLTHROUGH */
@


1.137
log
@Trailing whitespace is significant when determining the width of a tag
in mdoc(7) .Bl -tag and man(7) .TP, but not in man(7) .IP.
Quirk reported by Jan Stary <hans at stare dot cz> on ports@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.136 2015/04/19 19:43:50 schwarze Exp $ */
d213 1
a213 1
	return(0);
d221 1
a221 1
	return(0);
d229 1
a229 1
	return(1);
d256 1
a256 1
	return(0);
d267 1
a267 1
		return(0);
d272 1
a272 1
	return(0);
d326 1
a326 1
	return(0);
d334 1
a334 1
	return(1);
d356 1
a356 1
	return(0);
d366 1
a366 1
		return(0);
d396 1
a396 1
	return(0);
d411 1
a411 1
		return(0);
d425 1
a425 1
		return(0);
d438 1
a438 1
	return(0);
d459 1
a459 1
			return(0);
d494 1
a494 1
	return(0);
d507 1
a507 1
		return(1);
d511 1
a511 1
		return(0);
d534 1
a534 1
	return(1);
d579 1
a579 1
	return(n->type != ROFFT_HEAD);
d601 1
a601 1
		return(1);
d631 1
a631 1
		return(0);
d640 1
a640 1
	return(1);
d682 1
a682 1
		return(1);
d719 1
a719 1
		return(0);
d730 1
a730 1
	return(1);
d793 1
a793 1
	return(1);
d854 1
a854 1
	return(1);
d881 1
a881 1
		return(1);
d883 1
a883 1
		return(0);
d907 1
a907 1
	return(1);
d935 1
a935 1
	return (n->type != ROFFT_HEAD);
@


1.136
log
@If an explicit line break request (.br or .sp) occurs within an .HP block,
the next line doesn't hang, but is simply indented.
Issue found by Christian Neukirchen <chneukirchen at gmail dot com>
in the dmsetup(8) manual on Linux.
This patch also improves the indentation of XDGA(3) and XrmGetResource(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.135 2015/04/19 13:59:37 schwarze Exp $ */
d672 1
a672 1
		p->flags |= TERMP_NOBREAK;
d724 1
a724 1
		p->flags &= ~TERMP_NOBREAK;
@


1.135
log
@Decouple the token code for "no request or macro" from the individual
high-level parsers to allow further unification of functions that
only need to recognize this code, but that don't care about different
high-level macrosets beyond that.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.134 2015/04/18 17:50:02 schwarze Exp $ */
d482 11
@


1.134
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.133 2015/04/18 16:04:40 schwarze Exp $ */
d757 1
a757 1
		} while (n != NULL && n->tok != MAN_MAX &&
@


1.133
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.132 2015/04/06 22:06:06 schwarze Exp $ */
a141 1
	const struct roff_meta	*meta;
a145 1

a149 3
	n = man_node(man)->child;
	meta = man_meta(man);

a150 1

d155 1
d163 2
a164 1
					    n->child->next->child, meta);
d173 1
a173 1
		term_begin(p, print_man_head, print_man_foot, meta);
d176 1
a176 1
			print_man_nodelist(p, &mt, n, meta);
@


1.132
log
@Do not mistreat empty arguments to font alternating macros
as vertical spacing requests.  Bug found with xmahjongg(6).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.131 2015/04/06 14:58:53 schwarze Exp $ */
d139 1
a139 1
terminal_man(void *arg, const struct man *man)
@


1.131
log
@On a new RS nesting level, the saved width starts from the default
width, not from the saved width of the previous level.
Improves xterm(1) and XSetEventQueueOwner(3); found in transcode_filter(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.130 2015/04/06 13:34:54 schwarze Exp $ */
d322 4
a325 1
		print_man_node(p, mt, nn, meta);
@


1.130
log
@Use the default width for .RS without arguments.
Reduces groff-mandoc differences in base and Xenocara by about 4%.
Found while looking at wpa_supplicant(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.129 2015/04/04 18:52:12 schwarze Exp $ */
d896 1
a896 1
	mt->lmargin[mt->lmargincur] = mt->lmargin[mt->lmargincur - 1];
@


1.129
log
@Give man(7) section and subsection headers heanging indentation.
Reduces groff-mandoc differences in base by about 2.5% due to
various Perl manuals having long section titles.
Quirk found in argtable2(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.128 2015/04/04 17:46:58 schwarze Exp $ */
d880 3
a882 1
	if (n->child != NULL && a2roffsu(n->child->string, &su, SCALE_EN))
@


1.128
log
@Rounding rules for horizontal scaling widths are more complicated.
There is a first rounding to basic units on the input side.
After that, rounding rules differ between requests and macros.
Requests round to the nearest possible character position.
Macros round to the next character position to the left.

Implement that by changing the return value of term_hspan()
to basic units and leaving the second scaling and rounding stage
to the formatters instead of doing it in the terminal handler.

Improves for example argtable2(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.127 2015/04/04 11:43:53 schwarze Exp $ */
d769 3
d775 3
d830 3
d836 3
@


1.127
log
@Fix a quirk with respect to empty .HP.
Found while writing a regression test for man_macro.c rev. 1.66.
Incidentally, this brings rendering of XFreeEventData(3) closer to groff.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.126 2015/04/02 23:47:43 schwarze Exp $ */
d428 1
a428 1
	v = term_hspan(p, &su);
d513 1
a513 1
		len = term_hspan(p, &su);
d598 1
a598 1
		len = term_hspan(p, &su);
d680 1
a680 1
		len = term_hspan(p, &su);
d869 1
a869 1
		n->aux = term_hspan(p, &su);
@


1.126
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.125 2015/04/02 22:06:17 schwarze Exp $ */
d534 11
@


1.125
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.124 2015/04/02 21:03:18 schwarze Exp $ */
d50 1
a50 1
			  const struct man_meta *meta
d61 4
a64 2
static	void		  print_man_head(struct termp *, const void *);
static	void		  print_man_foot(struct termp *, const void *);
d142 1
a142 1
	const struct man_meta	*meta;
d1015 1
a1015 1
print_man_foot(struct termp *p, const void *arg)
a1016 1
	const struct man_meta	*meta;
a1019 1
	meta = (const struct man_meta *)arg;
d1031 2
a1032 2
	 * In the bottom right corner, use the source instead of
	 * the title.
d1042 2
a1043 2
	} else if (meta->source) {
		title = mandoc_strdup(meta->source);
d1049 1
a1049 1
	/* Bottom left corner: manual source. */
d1057 2
a1058 2
	if (meta->source)
		term_word(p, meta->source);
d1085 1
a1085 1
print_man_head(struct termp *p, const void *arg)
a1086 1
	const struct man_meta	*meta;
a1090 1
	meta = (const struct man_meta *)arg;
@


1.124
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.123 2015/03/15 16:51:34 schwarze Exp $ */
d49 1
a49 1
			  struct man_node *n, \
d64 1
a64 1
				const struct man_node *, int);
d141 1
a141 1
	struct man_node		*n;
d192 1
a192 1
print_bvspace(struct termp *p, const struct man_node *n, int pardist)
d281 1
a281 1
	struct man_node		*nn;
d489 1
a489 1
	const struct man_node	*nn;
d563 1
a563 1
	const struct man_node	*nn;
d644 1
a644 1
	struct man_node		*nn;
@


1.123
log
@Avoid off-by-one read access to the termacts array, which could
sometimes result in missing line breaks before subsection headers.
Found by carsten dot kunze at arcor dot de on SuSE 13.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.122 2015/03/09 17:41:36 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d27 1
d29 2
a30 1
#include "mandoc_aux.h"
a31 1
#include "man.h"
d162 1
a162 1
			    n->child->child->type == MAN_TEXT &&
d199 1
a199 1
		if (MAN_TBL == n->body->child->type)
d202 1
a202 1
	if (MAN_ROOT == n->parent->type || MAN_RS != n->parent->tok)
d271 1
a271 1
	assert(MAN_TEXT == n->type);
d493 1
a493 1
	case MAN_BLOCK:
d496 1
a496 1
	case MAN_BODY:
d530 1
a530 1
	case MAN_BODY:
d547 1
a547 1
	case MAN_BLOCK:
d556 1
a556 1
	return(MAN_HEAD != n->type);
d567 1
a567 1
	case MAN_BODY:
d570 1
a570 1
	case MAN_HEAD:
d574 1
a574 1
	case MAN_BLOCK:
d595 1
a595 1
	case MAN_HEAD:
d609 1
a609 1
	case MAN_BODY:
d625 1
a625 1
	case MAN_HEAD:
d631 1
a631 1
	case MAN_BODY:
d648 1
a648 1
	case MAN_HEAD:
d652 1
a652 1
	case MAN_BODY:
d655 1
a655 1
	case MAN_BLOCK:
d677 1
a677 1
	case MAN_HEAD:
d697 1
a697 1
	case MAN_BODY:
d715 1
a715 1
	case MAN_HEAD:
d718 1
a718 1
	case MAN_BODY:
d733 1
a733 1
	case MAN_BLOCK:
d753 1
a753 1
	case MAN_HEAD:
d757 1
a757 1
	case MAN_BODY:
d772 1
a772 1
	case MAN_HEAD:
d775 1
a775 1
	case MAN_BODY:
d789 1
a789 1
	case MAN_BLOCK:
d808 1
a808 1
	case MAN_HEAD:
d812 1
a812 1
	case MAN_BODY:
d827 1
a827 1
	case MAN_HEAD:
d830 1
a830 1
	case MAN_BODY:
d844 1
a844 1
	case MAN_BLOCK:
d847 1
a847 1
	case MAN_HEAD:
d878 1
a878 1
	case MAN_BLOCK:
d880 1
a880 1
	case MAN_HEAD:
d898 1
a898 1
	return (MAN_HEAD != n->type);
d905 1
a905 1
	if (MAN_BLOCK != n->type)
d925 1
a925 1
	case MAN_TEXT:
d940 1
a940 1
	case MAN_EQN:
d947 1
a947 1
	case MAN_TBL:
@


1.122
log
@Fix vertical spacing at the beginning of tables.
man(7) always prints a blank line, mdoc(7) doesn't.
Problem in mdoc(7) reported by kristaps@@.
mdoc(7) part of the patch tested by kristaps@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.121 2015/01/30 22:04:15 schwarze Exp $ */
d744 2
a745 1
		} while (n != NULL && termacts[n->tok].flags & MAN_NOTEXT);
@


1.121
log
@Have pity on the poor stack.
Replace tail recursion by iteration when walking the syntax trees.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.120 2015/01/30 17:31:20 schwarze Exp $ */
d946 2
a947 6
		/*
		 * Tables are preceded by a newline.  Then process a
		 * table line, which will cause line termination,
		 */
		if (n->span->prev == NULL)
			term_newln(p);
@


1.120
log
@Delete the redundant tbl span flags, just inspect the actual data
where needed, which is less fragile.
This fixes a subtle NULL pointer access to tp->tbl.cols:
Due to a bug in the man(7) parser, the first span of a table can
end up in a .TP head, in which case tblcalc() was never called.
Found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.119 2015/01/24 02:41:32 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2014 Ingo Schwarze <schwarze@@openbsd.org>
d1008 4
a1011 4
	print_man_node(p, mt, n, meta);
	if ( ! n->next)
		return;
	print_man_nodelist(p, mt, n->next, meta);
@


1.119
log
@Strangely, ignoring the roff(7) .na request was implemented in the man(7)
parser.  Simplify the code by moving it into the roff(7) parser, also
making it work for mdoc(7).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.118 2014/12/24 18:03:34 schwarze Exp $ */
d950 1
a950 1
		if (TBL_SPAN_FIRST & n->span->flags)
@


1.118
log
@For .RS, we need to save the information how much we actually indented
because negative indents can get truncated, in which case we no longer
know how to restore the original indent at the end of the block.
This also solves another case of effectively infinite output found
by jsg@@ with afl, triggered by very large negative indents.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.117 2014/12/24 09:57:41 schwarze Exp $ */
a114 1
	{ pre_ign, NULL, MAN_NOTEXT }, /* na */
@


1.117
log
@When a man(7) document contains unreasonably large numbers for
indentations or paragraph distances, large output may be generated,
which is practically the same as an endless loop; found by jsg@@
with afl.
Reject such unreasonably large numbers beyond arbitrary limits
similar to those used by groff (max. 65 blank lines between paragraphs
and max. SHRT_MAX characters per output line) and fall back to
defaults when exceeded.  Having the limits behave in exactly the
same way is not relevant.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.116 2014/12/23 13:48:15 schwarze Exp $ */
d48 1
a48 1
			  const struct man_node *n, \
d281 1
a281 1
	const struct man_node	*nn;
d644 1
a644 1
	const struct man_node	*nn;
a840 1
	int		 len;
d852 8
a859 6
	len = SHRT_MAX + 1;
	if ((n = n->parent->head->child) != NULL &&
	    a2roffsu(n->string, &su, SCALE_EN))
		len = term_hspan(p, &su);
	if (len > SHRT_MAX)
		len = term_len(p, p->defindent);
d861 1
a861 4
	if (len > 0 || (size_t)(-len) < mt->offset)
		mt->offset += len;
	else
		mt->offset = 0;
a874 2
	struct roffsu	 su;
	int		 len;
d886 1
a886 11
	len = SHRT_MAX + 1;
	if ((n = n->parent->head->child) != NULL &&
	    a2roffsu(n->string, &su, SCALE_EN))
		len = term_hspan(p, &su);
	if (len > SHRT_MAX)
		len = term_len(p, p->defindent);

	if (len < 0 || (size_t)len < mt->offset)
		mt->offset -= len;
	else
		mt->offset = 0;
@


1.116
log
@support negative horizontal widths in man(7);
minus twenty lines of code in spite of enhanced functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.115 2014/12/23 09:31:17 schwarze Exp $ */
d22 1
d434 2
d512 4
d521 1
a521 5
	if (len > 0 || (size_t)(-len) < mt->offset)
		p->rmargin = mt->offset + len;
	else
		p->rmargin = 0;

a585 1
		mt->lmargin[mt->lmargincur] = len;
d588 3
a667 1
		mt->lmargin[mt->lmargincur] = len;
d670 3
d853 1
d857 1
a857 1
	else
d890 1
d894 1
a894 1
	else
@


1.115
log
@some scaling unit fixes:
- .sp with an invalid argument is .sp 1v, not .sp 0v
- in man(1), trailing garbage doesn't make scaling units invalid
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.114 2014/12/23 08:15:37 schwarze Exp $ */
d38 1
a38 1
	size_t		  lmargin[MAXMARGINS]; /* margins (incl. visible page) */
a56 2
static	int		  a2width(const struct termp *, const char *);

a181 11
static int
a2width(const struct termp *p, const char *cp)
{
	struct roffsu	 su;

	if ( ! a2roffsu(cp, &su, SCALE_EN))
		return(-1);

	return((int)term_hspan(p, &su));
}

d400 2
a401 1
	int		 len, less;
d403 1
a403 1
	const char	*cp;
d422 1
a422 1
	if ((len = a2width(p, ++cp)) < 0)
d425 1
a425 1
	v = (size_t)len;
d441 1
a441 3
	char		*s;
	size_t		 i, len;
	int		 neg;
d461 1
a461 3
	neg = 0;
	switch (n->tok) {
	case MAN_br:
d463 4
a466 12
		break;
	default:
		if (NULL == n->child) {
			len = 1;
			break;
		}
		s = n->child->string;
		if ('-' == *s) {
			neg = 1;
			s++;
		}
		if ( ! a2roffsu(s, &su, SCALE_VS))
a468 1
		break;
d471 1
a471 1
	if (0 == len)
d473 2
a474 2
	else if (neg)
		p->skipvsp += len;
d485 1
a485 2
	size_t			 len, one;
	int			 ival;
d487 1
a503 3
	len = mt->lmargin[mt->lmargincur];
	ival = -1;

d506 6
a511 7
	if (NULL != (nn = n->parent->head->child))
		if ((ival = a2width(p, nn->string)) >= 0)
			len = (size_t)ival;

	one = term_len(p, 1);
	if (len < one)
		len = one;
d514 4
a517 4
	p->rmargin = mt->offset + len;

	if (ival >= 0)
		mt->lmargin[mt->lmargincur] = (size_t)ival;
d559 1
d561 1
a561 2
	size_t			 len;
	int			 savelit, ival;
a577 3
	len = mt->lmargin[mt->lmargincur];
	ival = -1;

d579 9
a587 4
	if (NULL != (nn = n->parent->head->child))
		if (NULL != (nn = nn->next))
			if ((ival = a2width(p, nn->string)) >= 0)
				len = (size_t)ival;
a590 4
		/* Handle zero-width lengths. */
		if (0 == len)
			len = term_len(p, 1);

a593 4
		/* Set the saved left-margin. */
		if (ival >= 0)
			mt->lmargin[mt->lmargincur] = (size_t)ival;

d638 1
d640 1
a640 2
	size_t			 len;
	int			 savelit, ival;
a656 3
	len = (size_t)mt->lmargin[mt->lmargincur];
	ival = -1;

d659 9
a667 4
	if (NULL != (nn = n->parent->head->child))
		if (nn->string && 0 == (MAN_LINE & nn->flags))
			if ((ival = a2width(p, nn->string)) >= 0)
				len = (size_t)ival;
a670 4
		/* Handle zero-length properly. */
		if (0 == len)
			len = term_len(p, 1);

a688 3
		if (ival >= 0)
			mt->lmargin[mt->lmargincur] = (size_t)ival;

d833 2
a834 2
	int		 ival;
	size_t		 sz;
d846 5
a850 1
	sz = term_len(p, p->defindent);
d852 4
a855 5
	if (NULL != (n = n->parent->head->child))
		if ((ival = a2width(p, n->string)) >= 0)
			sz = (size_t)ival;

	mt->offset += sz;
d869 2
a870 2
	int		 ival;
	size_t		 sz;
d882 5
a886 1
	sz = term_len(p, p->defindent);
d888 4
a891 5
	if (NULL != (n = n->parent->head->child))
		if ((ival = a2width(p, n->string)) >= 0)
			sz = (size_t)ival;

	mt->offset = mt->offset < sz ?  0 : mt->offset - sz;
@


1.114
log
@even if the second argument to .IP is invalid, don't print it
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.113 2014/12/23 01:57:11 schwarze Exp $ */
a57 1
static	size_t		  a2height(const struct termp *, const char *);
a183 12

static size_t
a2height(const struct termp *p, const char *cp)
{
	struct roffsu	 su;

	if ( ! a2roffsu(cp, &su, SCALE_VS))
		SCALE_VS_INIT(&su, atoi(cp));

	return(term_vspan(p, &su));
}

d452 1
d490 3
a492 1
		len = a2height(p, s);
@


1.113
log
@correctly handle scaling units after .PD
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.112 2014/12/04 02:05:16 schwarze Exp $ */
a633 2
		if (ival < 0)
			break;
d636 2
a637 1
		mt->lmargin[mt->lmargincur] = (size_t)ival;
@


1.112
log
@fix handling of roff requests having a default scale other than "n",
in particular .sp which uses "v", when the scale is not specified;
cures groff-mandoc differences in about a dozen Xenocara manuals
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.111 2014/12/04 01:33:23 schwarze Exp $ */
d289 1
d292 1
a292 1
	if (0 == n) {
d297 2
a298 1
	mt->pardist = atoi(n->string);
@


1.111
log
@Ignore macros that never produce any text when deciding whether
vertical whitespace is needed before a section or subsection.
Cures groff-mandoc differences in more than 300 manuals,
mostly Xenocara, some curses, a few GNU.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.110 2014/12/02 10:07:17 schwarze Exp $ */
d202 1
a202 1
	if ( ! a2roffsu(cp, &su, SCALE_BU))
@


1.110
log
@Fix the implementation and documentation of \c (continue text input line).
In particular, make it work in no-fill mode, too.
Reminded by Carsten dot Kunze at arcor dot de (Heirloom roff).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.109 2014/11/21 01:52:44 schwarze Exp $ */
d124 1
a124 1
	{ pre_ign, NULL, 0 }, /* UC */
d779 10
a788 5
		/* If following a prior empty `SS', no vspace. */
		if (n->prev && MAN_SS == n->prev->tok)
			if (NULL == n->prev->body->child)
				break;
		if (NULL == n->prev)
d790 1
d834 10
a843 6
		/* If following a prior empty `SH', no vspace. */
		if (n->prev && MAN_SH == n->prev->tok)
			if (NULL == n->prev->body->child)
				break;
		/* If the first macro, no vspae. */
		if (NULL == n->prev)
d845 1
@


1.109
log
@We repeatedly observed assertion crashes in the low-level terminal
output handler because the high level terminal formatters could be
tricked into setting the left margin further to the right than the
right margin.  Today, jsg@@ found more of these with afl.

Change the internal interface between both levels, aiming for
simplicity and robustness of the code.  Treat both margins as
*independent* settings:  Now, termp.offset is the requested left
margin, and termp.rmargin is the available space.  Let the lower
level cope with that case of insufficient space.

Obviously, high level code that does centering or flush right
still has to do careful checks, so i did a full audit of margin
settings in the terminal formatters.

Fixes crashes caused by excessively long title or date strings in
the man(7) footer, operating system or date strings in the mdoc(7)
footer, volume strings in the man(7) or mdoc(7) header, and a few
cases related to some non-prologue macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.108 2014/10/28 17:35:42 schwarze Exp $ */
d1019 3
a1021 2
	if (MANT_LITERAL & mt->fl && ! (TERMP_NOBREAK & p->flags) &&
	    (NULL == n->next || MAN_LINE & n->next->flags)) {
d1026 1
a1026 1
		if (NULL != n->string && '\0' != *n->string)
@


1.108
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.107 2014/10/20 15:49:45 schwarze Exp $ */
a456 5
	/* Don't let this creep beyond the right margin. */

	if (p->offset > p->rmargin)
		p->offset = p->rmargin;

d650 1
a650 2
		p->rmargin = p->maxrmargin > p->offset ?
		    p->maxrmargin : p->offset;
d741 1
a741 2
		p->rmargin = p->maxrmargin > p->offset ?
		    p->maxrmargin : p->offset;
d892 1
a892 2
	p->rmargin = p->maxrmargin > p->offset ?
	    p->maxrmargin : p->offset;
d1056 1
a1056 1
	size_t			 datelen;
d1093 2
a1094 1
	p->rmargin = (p->maxrmargin - datelen + term_len(p, 1)) / 2;
d1102 3
a1105 4
	p->offset = p->rmargin;
	p->rmargin = p->maxrmargin - term_strlen(p, title);
	if (p->offset + datelen >= p->rmargin)
		p->rmargin = p->offset + datelen;
d1148 1
a1148 1
	    p->maxrmargin - vollen;
@


1.107
log
@correct the spacing after in-line equations
that start at the beginning of an input line
but end before the end of an input line
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.106 2014/10/20 02:46:00 schwarze Exp $ */
a150 3

	if (NULL == p->symtab)
		p->symtab = mchars_alloc();
@


1.106
log
@correct spacing *after* inline equations (much simpler than expected)
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.105 2014/10/20 02:31:44 schwarze Exp $ */
d991 1
a991 1
		if ( ! (n->flags & MAN_LINE))
@


1.105
log
@correct spacing before inline equations
@
text
@d1 1
a1 1
/*	$OpenBSD: man_term.c,v 1.104 2014/09/03 05:17:08 schwarze Exp $ */
d991 2
@


1.104
log
@Implement the traditional -h option for man(1): show the SYNOPSIS only.
As usual, we get mandoc -h and apropos -h for free.
Try stuff like "apropos -h In=dirent" or "apropos -h Fa=timespec".

Only useful for terminal output, so -Tps, -Tpdf, -Thtml ignore -h for now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d988 2
@


1.103
log
@As suggested by jmc@@, only include line and column numbers into messages
when they are meaningful, to avoid confusing stuff like this:
$ mandoc /dev/null
mandoc: /dev/null:0:1: FATAL: not a manual
Instead, just say:
mandoc: /dev/null: FATAL: not a manual

Another example this applies to is documents having a prologue,
but lacking a body.  Do not throw a FATAL error for these; instead,
issue a warning and show the empty document, in the man(7) case with
the same amount of blank lines as groff does.  Also downgrade mdoc(7)
documents having content before the first .Sh from FATAL to WARNING.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.102 2014/04/23 16:07:06 schwarze Exp $ */
a141 1
	const struct man_node	*n;
d143 1
a147 3
	if (0 == p->defindent)
		p->defindent = 7;

d149 1
a149 1
	p->maxrmargin = p->defrmargin;
d155 1
a155 1
	n = man_node(man);
a157 3
	term_begin(p, print_man_head, print_man_foot, meta);
	p->flags |= TERMP_NOSPACE;

d164 22
a185 4
	if (n->child)
		print_man_nodelist(p, &mt, n->child, meta);

	term_end(p);
@


1.102
log
@Audit strlcpy(3)/strlcat(3) usage.

* Repair three instances of silent truncation, use asprintf(3).
* Change two instances of strlen(3)+malloc(3)+strlcpy(3)+strlcat(3)+...
to use asprintf(3) instead to make them less error prone.
* Cast the return value of four instances where the destination
buffer is known to be large enough to (void).
* Completely remove three useless instances of strlcpy(3)/strlcat(3).
* Mark two places in -Thtml with XXX that can cause information loss
and crashes but are not easy to fix, requiring design changes of
some internal interfaces.
* The file mandocdb.c remains to be audited.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.101 2014/04/20 20:17:36 schwarze Exp $ */
d1060 2
a1061 1
	term_vspace(p);
d1070 4
a1073 2
		term_vspace(p);
		term_vspace(p);
@


1.101
log
@fix unchecked snprintf(3) in page header printing:
the length of the title is unknown, and speed doesn't matter here,
so use asprintf/free rather than a static buffer
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.100 2014/04/20 16:44:44 schwarze Exp $ */
a1117 1
	char			 buf[BUFSIZ];
d1119 1
d1121 1
a1121 1
	size_t			 buflen, titlen;
d1127 2
a1128 5
	if (meta->vol)
		strlcpy(buf, meta->vol, BUFSIZ);
	else
		buf[0] = '\0';
	buflen = term_strlen(p, buf);
d1138 3
a1140 4
	p->rmargin = 2 * (titlen+1) + buflen < p->maxrmargin ?
	    (p->maxrmargin -
	     term_strlen(p, buf) + term_len(p, 1)) / 2 :
	    p->maxrmargin - buflen;
d1149 1
a1149 1
	p->rmargin = p->offset + buflen + titlen < p->maxrmargin ?
d1152 1
a1152 1
	term_word(p, buf);
@


1.100
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.99 2014/04/08 07:13:01 schwarze Exp $ */
d27 1
d1049 3
a1051 3
	char		title[BUFSIZ];
	size_t		datelen;
	const struct man_meta *meta;
d1071 2
a1072 1
		snprintf(title, BUFSIZ, "%s(%s)", meta->title, meta->msec);
d1074 1
a1074 1
		strlcpy(title, meta->source, BUFSIZ);
d1076 1
a1076 1
		title[0] = '\0';
d1112 1
d1118 4
a1121 3
	char		buf[BUFSIZ], title[BUFSIZ];
	size_t		buflen, titlen;
	const struct man_meta *meta;
d1135 1
a1135 1
	snprintf(title, BUFSIZ, "%s(%s)", meta->title, meta->msec);
d1186 1
@


1.99
log
@Add a new term_flushln() flag TERMP_BRIND (if break, then indent)
to control indentation of continuation lines in TERMP_NOBREAK mode.
In the past, this was always on; continue using it
for .Bl, .Nm, .Fn, .Fo, and .HP, but no longer for .IP and .TP.

I looked at this because sthen@@ reported the issue in a manual
of a Perl module from ports, but it affects base, too: This patch
reduces groff-mandoc differences in base by more than 15%.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.98 2014/03/30 21:27:59 schwarze Exp $ */
d44 1
a44 1
#define	DECL_ARGS 	  struct termp *p, \
d63 1
a63 1
static	void		  print_bvspace(struct termp *, 
d104 1
a104 1
	{ pre_HP, post_HP, 0 }, /* HP */ 
a136 1

a186 1

d225 1
a225 1
/* ARGSUSED */
a232 2

/* ARGSUSED */
a240 2

/* ARGSUSED */
a248 2

/* ARGSUSED */
a275 1
/* ARGSUSED */
a289 1
/* ARGSUSED */
d298 1
a298 1
	case (MAN_RB):
d302 1
a302 1
	case (MAN_RI):
d306 1
a306 1
	case (MAN_BR):
d310 1
a310 1
	case (MAN_BI):
d314 1
a314 1
	case (MAN_IR):
d318 1
a318 1
	case (MAN_IB):
a340 1
/* ARGSUSED */
a348 1
/* ARGSUSED */
a370 1
/* ARGSUSED */
d383 1
a383 1
	case ('4'):
d385 1
a385 1
	case ('3'):
d387 1
a387 1
	case ('B'):
d390 1
a390 1
	case ('2'):
d392 1
a392 1
	case ('I'):
d395 1
a395 1
	case ('P'):
d398 1
a398 1
	case ('1'):
d400 1
a400 1
	case ('C'):
d402 1
a402 1
	case ('R'):
a410 1
/* ARGSUSED */
d444 1
a444 1
	else 
a454 2

/* ARGSUSED */
d464 1
a464 1
		case (MAN_SH):
d466 1
a466 1
		case (MAN_SS):
d468 1
a468 1
		case (MAN_PP):
d470 1
a470 1
		case (MAN_LP):
d472 1
a472 1
		case (MAN_P):
d482 1
a482 1
	case (MAN_br):
a509 2

/* ARGSUSED */
d518 1
a518 1
	case (MAN_BLOCK):
d521 1
a521 1
	case (MAN_BODY):
a553 2

/* ARGSUSED */
d559 1
a559 1
	case (MAN_BODY):
a570 2

/* ARGSUSED */
d576 1
a576 1
	case (MAN_BLOCK):
a587 2

/* ARGSUSED */
d596 1
a596 1
	case (MAN_BODY):
d599 1
a599 1
	case (MAN_HEAD):
d603 1
a603 1
	case (MAN_BLOCK):
d620 1
a620 1
	case (MAN_HEAD):
d643 1
a643 1
	case (MAN_BODY):
d646 1
a646 1
				p->maxrmargin : p->offset;
a654 2

/* ARGSUSED */
d660 1
a660 1
	case (MAN_HEAD):
d666 1
a666 1
	case (MAN_BODY):
a674 2

/* ARGSUSED */
d683 1
a683 1
	case (MAN_HEAD):
d687 1
a687 1
	case (MAN_BODY):
d690 1
a690 1
	case (MAN_BLOCK):
d708 1
a708 1
	case (MAN_HEAD):
d735 1
a735 1
	case (MAN_BODY):
d738 1
a738 1
				p->maxrmargin : p->offset;
a748 2

/* ARGSUSED */
d754 1
a754 1
	case (MAN_HEAD):
d757 1
a757 1
	case (MAN_BODY):
a765 2

/* ARGSUSED */
d772 1
a772 1
	case (MAN_BLOCK):
d785 1
a785 1
	case (MAN_HEAD):
d789 1
a789 1
	case (MAN_BODY):
a798 2

/* ARGSUSED */
d802 1
a802 1
	
d804 1
a804 1
	case (MAN_HEAD):
d807 1
a807 1
	case (MAN_BODY):
a814 2

/* ARGSUSED */
d821 1
a821 1
	case (MAN_BLOCK):
d835 1
a835 1
	case (MAN_HEAD):
d839 1
a839 1
	case (MAN_BODY):
a848 2

/* ARGSUSED */
d852 1
a852 1
	
d854 1
a854 1
	case (MAN_HEAD):
d857 1
a857 1
	case (MAN_BODY):
a864 1
/* ARGSUSED */
d872 1
a872 1
	case (MAN_BLOCK):
d875 1
a875 1
	case (MAN_HEAD):
d884 1
a884 1
		if ((ival = a2width(p, n->string)) >= 0) 
d890 1
a890 1
			p->maxrmargin : p->offset;
a898 1
/* ARGSUSED */
d906 1
a906 1
	case (MAN_BLOCK):
d908 1
a908 1
	case (MAN_HEAD):
d917 2
a918 2
	if (NULL != (n = n->parent->head->child)) 
		if ((ival = a2width(p, n->string)) >= 0) 
a927 1
/* ARGSUSED */
a934 1
/* ARGSUSED */
d959 1
a959 1
	case(MAN_TEXT):
d974 1
a974 1
	case (MAN_EQN):
d977 1
a977 1
	case (MAN_TBL):
d982 1
a982 1
		if (TBL_SPAN_FIRST & n->span->flags) 
a1044 1

a1111 1

d1138 1
a1138 1
	    (p->maxrmargin - 
d1171 1
a1171 1
	/* 
@


1.98
log
@Support relative arguments to .ll (increase or decrease line length).
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.97 2014/03/30 19:47:32 schwarze Exp $ */
d277 1
a277 1
		p->flags &= ~TERMP_NOBREAK;
d546 1
a546 1
		p->flags |= TERMP_NOBREAK;
d581 1
a581 1
		p->flags &= ~TERMP_NOBREAK;
@


1.97
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.96 2014/03/08 16:19:59 schwarze Exp $ */
d241 1
a241 1
	(*p->setwidth)(p, n->nchild ? a2width(p, n->child->string) : 0);
@


1.96
log
@In .nf mode, use the MAN_LINE flag to detect input line breaks
instead of the man_node line member.  This is required to preserve
line breaks contained in user-defined macros called in .nf mode.
Found in a code audit triggered by fixing a similar issue in .TP.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.95 2014/03/08 15:50:21 schwarze Exp $ */
d83 1
d133 1
d232 10
@


1.95
log
@To find out whether .TP head arguments are same-line or next-line arguments,
use the MAN_LINE flag instead of the man_node line member.
This is required such that user-defined macros wrapping .TP work correctly.

Issue found by Havard Eidnes in Tcl_NewStringObj(3), reported via
the NetBSD bug tracking system and Thomas Klausner <wiz at NetBSD>.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.94 2014/02/16 12:30:51 schwarze Exp $ */
d1044 1
a1044 1
	    (NULL == n->next || n->next->line > n->line)) {
@


1.94
log
@when indenting, extend the right margin accordingly, when needed;
fixes a crash reported by blambert@@ and a few other, similar ones
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.93 2013/12/22 23:33:52 schwarze Exp $ */
d719 1
a719 1
		if (nn->string && nn->parent->line == nn->line)
d736 8
a743 3
		for (nn = n->child; nn; nn = nn->next)
			if (nn->line > n->line)
				print_man_node(p, mt, nn, meta);
@


1.93
log
@Polishing the worms in my favourite can, term_flushln().

The TERMP_TWOSPACE flag i introduced in August 2009 was idiosyncratic
and served only a very narrow purpose.  Replace it by a more intuitive
and more general termp attribute "trailspace", to be used together
with TERMP_NOBREAK, to request a minimum amount of whitespace at
the end of the current column.  Adapt all code to the new interface.

No functional change intended;
code reviews to confirm that are welcome *eg*.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.92 2013/11/11 00:35:51 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d657 2
a658 1
		p->rmargin = p->maxrmargin;
d748 2
a749 1
		p->rmargin = p->maxrmargin;
d910 3
a912 2
	p->rmargin = p->maxrmargin;
	p->offset = mt->offset < p->rmargin ? mt->offset : p->rmargin;
@


1.92
log
@In the parser, when closing an explicit block that is not open,
close below-subsection implicit scopes that may still be open.
In the formatter, make sure indentation is reset when leaving a scope,
not only when entering the next one.

Improves the formatting of gpg(1); issue reported by jca on ports.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.91 2013/10/17 20:51:30 schwarze Exp $ */
d264 2
a265 1
		p->flags &= ~(TERMP_NOBREAK | TERMP_TWOSPACE);
d535 1
a535 1
		p->flags |= TERMP_TWOSPACE;
d570 1
a570 1
		p->flags &= ~TERMP_TWOSPACE;
d613 1
d676 1
d700 1
d748 1
a749 1
		p->flags &= ~TERMP_TWOSPACE;
d1104 1
d1127 1
d1159 1
d1182 1
@


1.91
log
@Implement the .UR/.UE block (uniform resource identifier) introduced in the
man-ext macros by Eric S. Raymond, enabled by default in groff_man(7).
Usual disclaimer: You don't write new man(7) code, so you are not going
to use these, either.
Improves e.g. the bzr(1) and etherape(1) manuals.
Thanks to naddy@@ for bringing these to my attention.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.90 2013/01/05 22:18:59 schwarze Exp $ */
d678 1
d766 1
@


1.90
log
@In literal mode (.nf), each input line must be kept together
on the same output line, even if it is longer than the output width.
This commit fixes a bug allowing an overly long last line of an
indented block (.RS) to be broken even in literal mode.

The bug was found using the sudo_plugin(4) manual provided by millert@@.

I introduced the bug in rev. 1.84 during the g2k12 Budapest hackathon.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.89 2012/11/17 00:25:20 schwarze Exp $ */
d77 1
d91 1
d130 2
d940 26
@


1.89
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.88 2012/07/29 12:35:05 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d563 1
a563 1
		term_flushln(p);
d1000 1
a1000 1
	    NULL != n->next && n->next->line > n->line) {
@


1.88
log
@Implement .PD for -Tascii.
Reminded about the missing feature by millert@@.
This reduces mandoc/groff differences in base by 25%.
ok millert@@
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.87 2012/07/16 21:58:39 schwarze Exp $ */
d47 1
a47 1
			  const struct man_meta *m
d137 1
a137 1
	const struct man_meta	*m;
d153 1
a153 1
	m = man_meta(man);
d155 1
a155 1
	term_begin(p, print_man_head, print_man_foot, m);
d165 1
a165 1
		print_man_nodelist(p, &mt, n->child, m);
d326 1
a326 1
		print_man_node(p, mt, nn, m);
d643 1
a643 1
			print_man_node(p, mt, n->child, m);
d728 1
a728 1
				print_man_node(p, mt, nn, m);
d981 1
a981 1
		c = (*termacts[n->tok].pre)(p, mt, n, m);
d984 1
a984 1
		print_man_nodelist(p, mt, n->child, m);
d987 1
a987 1
		(*termacts[n->tok].post)(p, mt, n, m);
d1025 1
a1025 1
	print_man_node(p, mt, n, m);
d1028 1
a1028 1
	print_man_nodelist(p, mt, n->next, m);
d1103 1
a1103 1
	const struct man_meta *m;
d1105 3
a1107 3
	m = (const struct man_meta *)arg;
	assert(m->title);
	assert(m->msec);
d1109 2
a1110 2
	if (m->vol)
		strlcpy(buf, m->vol, BUFSIZ);
d1117 1
a1117 1
	snprintf(title, BUFSIZ, "%s(%s)", m->title, m->msec);
@


1.87
log
@Always fix the man(7) subsection header (.SS) indent to 3n,
do not let it depend on the default indent provided by -Oindent.
By default, this doesn't change anything because 7 / 2 = 3;
in -Omdoc mode, it makes man(7) output the same as mdoc(7) output.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.86 2012/07/14 10:43:48 schwarze Exp $ */
a33 2
/* FIXME: have PD set the default vspace width. */

d41 1
d64 1
a64 1
				const struct man_node *);
d71 1
d121 1
a121 1
	{ pre_ign, NULL, 0 }, /* PD */
d162 1
d203 1
a203 1
print_bvspace(struct termp *p, const struct man_node *n)
d205 1
d217 2
a218 1
	term_vspace(p);
d269 15
d520 1
a520 1
		print_bvspace(p, n);
d583 1
a583 1
		print_bvspace(p, n);
d610 1
a610 1
		print_bvspace(p, n);
d697 1
a697 1
		print_bvspace(p, n);
d772 1
d785 2
a786 1
		term_vspace(p);
d825 1
d839 2
a840 1
		term_vspace(p);
@


1.86
log
@Translate blank input lines to .sp just like in mdoc(7),
and ignore .sp after .PP.  This fixes vertical spacing
for blank lines after .PP and for .sp after .PP.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.85 2012/07/13 14:15:50 schwarze Exp $ */
d770 1
a770 1
		p->offset = term_len(p, p->defindent/2);
@


1.85
log
@In -man -Tascii, support .sp with negative argument.
In -mdoc -Tman, improve the framework to control vertical spacing.
Use both to support .Bl -compact (surprisingly hard to get right).
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.84 2012/07/10 19:53:11 schwarze Exp $ */
d444 11
a454 3
		if (MAN_SS == n->parent->tok)
			return(0);
		if (MAN_SH == n->parent->tok)
d456 3
@


1.84
log
@multiple fixes to -Tascii .HP rendering:
* do not add an excessive blank line before the block
* in literal mode, start a new line after the tag

getting this to work requires some general (print_man_node) fixes:
* in literal mode, break the output line at the end of each
input line, not just after those input lines ending in text
* but don't break it when there was no output on the line
* and adjust the margins after the .HP tag

these general fixes require an adjustment to -Tascii .TP rendering:
* set up NOBREAK mode before the body, not after the head

finally, based on all this, implement -Tman .Bl -hang in terms of .HP
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.83 2012/06/02 20:07:09 schwarze Exp $ */
d439 1
d441 1
d450 1
d456 10
a465 1
		len = n->child ? a2height(p, n->child->string) : 1;
d471 5
a475 2
	for (i = 0; i < len; i++)
		term_vspace(p);
@


1.83
log
@Minimal implementation of .EX and .EE for GNU compatibility.
Do not use this, it is not portable and only defined in esr's man-ext.
For example, sox(1) wants these macros.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.82 2012/02/26 19:41:27 schwarze Exp $ */
d3 2
a4 2
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010, 2011 Ingo Schwarze <schwarze@@openbsd.org>
a478 2
		p->flags |= TERMP_NOBREAK;
		p->flags |= TERMP_TWOSPACE;
d484 5
a517 3
	case (MAN_BLOCK):
		term_flushln(p);
		break;
d695 2
a713 3
		p->flags &= ~TERMP_NOBREAK;
		p->flags &= ~TERMP_TWOSPACE;
		p->rmargin = p->maxrmargin;
d910 1
a911 22
		/*
		 * If we're in a literal context, make sure that words
		 * togehter on the same line stay together.  This is a
		 * POST-printing call, so we check the NEXT word.  Since
		 * -man doesn't have nested macros, we don't need to be
		 * more specific than this.
		 */
		if (MANT_LITERAL & mt->fl && ! (TERMP_NOBREAK & p->flags) &&
				(NULL == n->next || 
				 n->next->line > n->line)) {
			rm = p->rmargin;
			rmax = p->maxrmargin;
			p->rmargin = p->maxrmargin = TERM_MAXMARGIN;
			p->flags |= TERMP_NOSPACE;
			term_flushln(p);
			p->rmargin = rm;
			p->maxrmargin = rmax;
		}

		if (MAN_EOS & n->flags)
			p->flags |= TERMP_SENTENCE;
		return;
d943 25
@


1.82
log
@Support .OP, one of the extended man macros; from kristaps@@.
Do not use this GNU extension, we take it for compatibility only.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.81 2011/12/05 00:28:12 schwarze Exp $ */
d126 2
d244 1
a244 1
	if (MAN_nf == n->tok)
@


1.81
log
@As requested by kristaps@@, add and improve comments related to -Omdoc;
while here, clean up some redundant initializations in print_man_head().
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.80 2011/12/04 00:44:18 schwarze Exp $ */
a66 1
static	int		  pre_alternate(DECL_ARGS);
d71 1
d77 2
a82 1
static	int		  pre_ft(DECL_ARGS);
d125 1
d321 23
@


1.80
log
@When a man document contains nothing at all except one or more invalid
macros, do not die on an assertion, but show correct error messages.
Assertions of meta data validity suggested by joerg@@.
ok joerg@@
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.79 2011/11/13 15:46:04 schwarze Exp $ */
d969 7
d987 2
d997 2
d1008 2
a1030 11
	/*
	 * Note that old groff would spit out some spaces before the
	 * header.  We discontinue this strange behaviour, but at one
	 * point we did so here.
	 */

	p->offset = 0;
	p->rmargin = p->maxrmargin;

	buf[0] = title[0] = '\0';

d1033 2
d1037 2
d1052 2
d1062 2
d1078 3
a1080 2
	 * Groff likes to have some leading spaces before content.  Well
	 * that's fine by me.
@


1.79
log
@Implement mdoc(7)-like output style variant for man(7) documents:
* one instead of three blank lines after the page header;
* one instead of three blank lines before the page footer;
* source instead of title(section) in the lower right corner.
Select this style variant with the undocumented command line option -Omdoc.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.77 2011/11/13 13:05:23 schwarze Exp $ */
d962 3
d1015 2
@


1.78
log
@Make the man(7) page footer the same as in groff.
@
text
@d966 9
a974 3
	term_vspace(p);
	term_vspace(p);
	snprintf(title, BUFSIZ, "%s(%s)", meta->title, meta->msec);
d1068 4
a1071 2
	term_vspace(p);
	term_vspace(p);
@


1.77
log
@Make the default left text margin configurable from the command line,
just like the default right margin already is.  This may be useful for
people with expensive screen real estate.  Besides, it helps automated
man(7) to mdoc(7) output comparisons to validate -Tman output.
ok kristaps@@ on an earlier version
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.76 2011/09/21 09:57:11 schwarze Exp $ */
d957 2
d968 2
a971 1
	p->rmargin = p->maxrmargin - term_strlen(p, meta->date);
d973 1
a973 4

	/* term_strlen() can return zero. */
	if (p->rmargin == p->maxrmargin)
		p->rmargin--;
a976 2
	if (meta->source)
		term_word(p, "");
d981 10
a991 1
	p->flags &= ~TERMP_NOBREAK;
d993 1
a993 1
	term_word(p, meta->date);
@


1.76
log
@As noticed by kristaps@@, when breaking an overflowing line,
forget about pending whitespace (vbl), or the next line would
be misaligned and potentially too long; but i'm fixing this
in a simpler way than he proposed.
Also remove the kludges in .HP that compensated for this bug.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.75 2011/09/20 14:20:47 schwarze Exp $ */
a31 2
#define	INDENT		  7 /* fixed-width char full-indent */
#define	HALFINDENT	  3 /* fixed-width char half-indent */
d138 3
d156 2
a157 2
	mt.lmargin[mt.lmargincur] = term_len(p, INDENT);
	mt.offset = term_len(p, INDENT);
d511 1
a511 1
		mt->lmargin[mt->lmargincur] = term_len(p, INDENT);
d706 2
a707 2
		mt->lmargin[mt->lmargincur] = term_len(p, INDENT);
		mt->offset = term_len(p, INDENT);
d718 1
a718 1
		p->offset = term_len(p, HALFINDENT);
d757 2
a758 2
		mt->lmargin[mt->lmargincur] = term_len(p, INDENT);
		mt->offset = term_len(p, INDENT);
d817 1
a817 1
	sz = term_len(p, INDENT);
d851 1
a851 1
	sz = term_len(p, INDENT);
@


1.75
log
@Using user-defined macros, surprisingly, it is possible
to have *next*-line head arguments on the *same* input line.
So .TP must not assume that a head argument with a matching
input line number is a same-line argument (and access a NULL pointer).
Bug found and fix tested by kristaps@@ with groff_hdtbl(7).
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.74 2011/09/20 13:13:21 schwarze Exp $ */
d250 1
a250 1
		p->offset = p->rmargin + 1;
d468 1
a468 3
	if (len > one)
		len -= one;
	else
@


1.74
log
@When advancing the left margin, .RS also needs to reset the right margin
to the default and check that the left does not outgrow the right one.
Otherwise, the (rmargin >= offset) assertion fails in term_flushln().
Bug found and fix tested by kristaps@@ with NetBSD slapo-retcode(5).
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.73 2011/09/20 09:02:18 schwarze Exp $ */
d639 1
a639 1
		if (nn->parent->line == nn->line)
@


1.73
log
@Sync print_mdoc_head to print_man_head;
this was forgotten after man_term.c rev. 1.25 on March 2, 2010.
The benefit is a sane page header line when .Dt is very long.
Reminded by Thomas Klausner <wiz at NetBSD>, thanks.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.72 2011/09/19 22:36:11 schwarze Exp $ */
d825 2
a826 1
	p->offset = mt->offset;
@


1.72
log
@Remove the terminal frontend flag TERMP_NOLPAD.

In columnated contexts (.Bl -column, .Bl -tag, .IP, .TP, .HP etc.), do not
pad after writing a column.  Instead, always pad before writing content.

In itself, this change avoids:
 - writing trailing whitespace in some situations
 - with .fi/.nf in .HP, breaking lines that were already padded

It allows several bugfixes included in this patch:
 - Do not count backspace as a character with positive width.
 - Set up proper indentation when encountering .fi/.nf in .HP.
 - Adjust the .HP indentation width to what groff does.
 - Never unlimit the right margin unless in the final column.

This reduces the groff/mandoc-differences in base by nearly 20%,
from 89k to 72k lines of diffs.

ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.71 2011/09/18 10:25:28 schwarze Exp $ */
d1006 1
a1008 1
	p->offset = 0;
d1018 1
a1023 1
	p->flags |= TERMP_NOBREAK | TERMP_NOSPACE;
d1045 2
a1047 2
	p->offset = 0;
	p->flags &= ~TERMP_NOSPACE;
@


1.71
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.70 2011/07/07 21:10:48 schwarze Exp $ */
d244 12
d442 1
a442 1
	size_t			 len;
d467 5
a471 2
	if (0 == len)
		len = term_len(p, 1);
a533 1
		p->flags |= TERMP_NOLPAD;
a603 1
		p->flags &= ~TERMP_NOLPAD;
a623 1
		p->flags |= TERMP_NOLPAD;
a691 1
		p->flags &= ~TERMP_NOLPAD;
d892 1
a892 1
		if (MANT_LITERAL & mt->fl && 
a899 1
			p->flags &= ~TERMP_NOLPAD;
d981 1
a981 1
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
d1028 1
a1028 1
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
d1038 1
a1038 1
		p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
@


1.70
log
@As .RS may nest and may contain embedded paragraphs,
keep a stack of left margins; this fixes e.g. lynx(1).
While here, clean up some code in .TP HEAD;
it can only have text children, anyway.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.69 2011/07/05 04:12:41 schwarze Exp $ */
d898 1
a898 1
		term_word(p, n->eqn->data);
@


1.69
log
@Sync to bsd.lv (all coded by kristaps@@):
 - mdoc(7): fix an assertion if the first line after .Bd -column
   starts with a blank, and some simplifications in mdoc_argv.c
 - man(7): literal mode ends at .SH and .SS (bug reported by naddy@@)
 - allow .RS/.RE blocks to nest (bug reported by dcoppa@@ and gsoares@@)
 - improve vertical spacing of man(7) blocks
 - roff(7): clear user-defined strings when starting a new file
 - correct ID tags in -T[x]html
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.68 2011/05/29 21:22:18 schwarze Exp $ */
d32 3
a34 2
#define	INDENT		  7
#define	HALFINDENT	  3
d41 4
a44 15
	/* 
	 * Default amount to indent the left margin after leading text
	 * has been printed (e.g., `HP' left-indent, `TP' and `IP' body
	 * indent).  This needs to be saved because `HP' and so on, if
	 * not having a specified value, must default.
	 *
	 * Note that this is the indentation AFTER the left offset, so
	 * the total offset is usually offset + lmargin.
	 */
	size_t		  lmargin;
	/*
	 * The default offset, i.e., the amount between any text and the
	 * page boundary.
	 */
	size_t		  offset;
d153 3
a155 2
	mt.fl = 0;
	mt.lmargin = term_len(p, INDENT);
d446 1
a446 1
	len = mt->lmargin;
d462 1
a462 1
		mt->lmargin = (size_t)ival;
d497 1
a497 1
		mt->lmargin = term_len(p, INDENT);
d532 1
a532 1
	len = mt->lmargin;
d553 1
a553 1
		mt->lmargin = (size_t)ival;
d621 1
a621 1
	len = (size_t)mt->lmargin;
d626 2
a627 4
	if (NULL != (nn = n->parent->head->child)) {
		while (nn && MAN_TEXT != nn->type)
			nn = nn->next;
		if (nn && nn->next)
a629 1
	}
a649 1

d651 1
a651 1
			mt->lmargin = (size_t)ival;
d696 1
a696 1
		mt->lmargin = term_len(p, INDENT);
d747 1
a747 1
		mt->lmargin = term_len(p, INDENT);
d816 4
d848 3
@


1.68
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.67 2011/04/24 16:22:02 schwarze Exp $ */
d180 1
a180 1
		SCALE_VS_INIT(&su, term_strlen(p, cp));
d197 8
a204 1

d208 1
d211 3
a213 2
	if (n->body && n->body->child && MAN_TBL == n->body->child->type)
		return;
d215 3
a217 7
	if (NULL == n->prev)
		return;

	if (MAN_SS == n->prev->tok)
		return;
	if (MAN_SH == n->prev->tok)
		return;
a221 1

d410 7
d708 1
d759 1
a802 1

d807 2
a808 2
	const struct man_node	*nn;
	int			 ival;
d820 1
a820 5
	if (NULL == (nn = n->parent->head->child)) {
		mt->offset = mt->lmargin + term_len(p, INDENT);
		p->offset = mt->offset;
		return(1);
	}
d822 3
a824 2
	if ((ival = a2width(p, nn->string)) < 0)
		return(1);
d826 1
a826 1
	mt->offset = term_len(p, INDENT) + (size_t)ival;
a831 1

d836 2
d841 1
a841 2
		mt->offset = mt->lmargin = term_len(p, INDENT);
		break;
d843 1
a843 1
		break;
a845 1
		p->offset = term_len(p, INDENT);
d848 9
a857 1

@


1.67
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.66 2011/03/20 23:36:42 schwarze Exp $ */
d155 1
a155 8
		switch (p->enc) {
		case (TERMENC_ASCII):
			p->symtab = chars_init(CHARS_ASCII);
			break;
		default:
			abort();
			/* NOTREACHED */
		}
@


1.66
log
@Import the foundation for eqn(7) support.
Written by kristaps@@.

For now, i'm adding one line to each of the four frontends
to just pass the input text through to the output,
not yet interpreting any of then eqn keywords.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.65 2011/03/07 01:35:33 schwarze Exp $ */
a29 1
#include "chars.h"
@


1.65
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.64 2011/01/25 12:35:07 schwarze Exp $ */
d894 3
@


1.64
log
@Avoid double blank line before a table preceded by .PP.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.63 2011/01/23 14:54:15 schwarze Exp $ */
a941 1
	char		buf[DATESIZ];
a947 5
	if (meta->rawdate)
		strlcpy(buf, meta->rawdate, DATESIZ);
	else
		time2a(meta->date, buf, DATESIZ);

d953 1
a953 1
	p->rmargin = p->maxrmargin - term_strlen(p, buf);
d971 1
a971 1
	term_word(p, buf);
@


1.63
log
@Fix another regression caused by the reorg of print_man_node() in rev. 1.61:
End-of-sentence spacing got lost for man(7) after plain text lines.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.62 2011/01/17 00:15:19 schwarze Exp $ */
d210 3
@


1.62
log
@Refrain from throwing fatal errors for
* .br .sp .nf .fi .na with arguments - just skip the arguments
* .TH lacking arguments - use empty strings instead like groff
* .TH with excessive arguments - skip those
Reminded by Joerg Sonnenberger, ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.61 2011/01/16 03:46:21 schwarze Exp $ */
d888 3
@


1.61
log
@In literal context, do not generate output line breaks between macro
arguments.  This fixes a long-standing bug reported repeatedly,
in particular by naddy@@ and brad@@.
Fix by kristaps@@, minus one regression caught by my test suite.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.60 2011/01/16 02:56:47 schwarze Exp $ */
d125 1
a125 1
	{ NULL, NULL, MAN_NOTEXT }, /* na */
d254 1
a254 1
	return(1);
@


1.60
log
@If the first character of a free-form text input line is whitespace,
then it will start a new output line;
from kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.59 2011/01/11 00:59:28 schwarze Exp $ */
a853 2
	c = 1;

d856 5
d863 2
a864 4
			break;
		} 

		if (' ' == *n->string && MAN_LINE & n->flags)
d869 10
a878 3
		/* FIXME: this means that macro lines are munged!  */

		if (MANT_LITERAL & mt->fl) {
d888 1
a888 2

		break;
d890 4
d897 1
a897 1
		break;
a898 4
		if ( ! (MAN_NOTEXT & termacts[n->tok].flags))
			term_fontrepl(p, TERMFONT_NONE);
		if (termacts[n->tok].pre)
			c = (*termacts[n->tok].pre)(p, mt, n, m);
d902 7
d912 4
a915 12
	switch (n->type) {
	case (MAN_TEXT):
		/* FALLTHROUGH */
	case (MAN_TBL):
		break;
	default:
		if (termacts[n->tok].post)
			(*termacts[n->tok].post)(p, mt, n, m);
		if ( ! (MAN_NOTEXT & termacts[n->tok].flags))
			term_fontrepl(p, TERMFONT_NONE);
		break;
	}
@


1.59
log
@When (cumulative) indentation requested by .in exceeds the right
margin, do not run into an assert(3)ion.
Problem reported by brad@@ in gm(1), fix by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.58 2011/01/04 22:28:17 schwarze Exp $ */
d858 1
a858 1
		if (0 == *n->string) {
d861 4
a864 1
		}
d880 1
@


1.58
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.57 2011/01/04 01:15:39 schwarze Exp $ */
d395 5
@


1.57
log
@Multiple man(7) .IP and .TP fixes started during p2k10:

Affecting both -Tascii and -Thtml:
* The .IP HEAD uses the second argument as the width, not the last one.
* Only print the first .IP HEAD argument, not all but the last.

Affecting only -Tascii:
* The .IP and .TP HEADs must be printed without literal mode,
  but literal mode must be restored afterwards.
* After the .IP and .TP bodies, we only want term_newln(), not
  term_flushln(), or we would get two blank lines in literal mode.
* The .TP HEAD does not use TWOSPACE, just like .IP doesn't either.
* In literal mode, clear NOLPAD after each line, or subsequent lines
  would get no indentation whatsoever.

Affecting only -Thtml:
* Only print next-line .TP children, instead of all but the first.

OK kristaps@@ on the -Tascii part; and:
"Can you work this into man_html.c, too?"
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.56 2010/12/19 07:53:12 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
a31 1
#include "tbl.h"
a93 1
static	int		  pre_TS(DECL_ARGS);
a135 2
	{ pre_TS, NULL, 0 }, /* TS */
	{ NULL, NULL, 0 }, /* TE */
a842 15
/* ARGSUSED */
static int
pre_TS(DECL_ARGS)
{

	if (MAN_BLOCK != n->type)
		return(0);

	if (tbl_close(p, n->data.TS, "man tbl postprocess", n->line))
		tbl_write(p, n->data.TS);

	return(0);
}


d873 5
d889 6
a894 1
	if (MAN_TEXT != n->type) {
d899 1
@


1.56
log
@Remove `i' and `r' macro handlers.  These macros, originally part of the
me package, aren't recognised by "groff -mandoc" so we don't need to do
so either.  Besides, they are not used in base or Xenocara, and only at
two or three places in one single port, which are probably typos.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.55 2010/12/07 00:08:52 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d517 1
a517 1
	int			 ival;
d537 1
a537 2
	/* Calculate offset. */

d539 1
a539 3
		if (NULL != (nn = nn->next)) {
			for ( ; nn->next; nn = nn->next)
				/* Do nothing. */ ;
a541 1
		}
d557 9
a565 3
		/* Don't print the length value. */
		for (nn = n->child; nn->next; nn = nn->next)
			print_man_node(p, mt, nn, m);
d591 1
a591 1
		term_flushln(p);
d606 1
a606 1
	int			 ival;
a610 1
		p->flags |= TERMP_TWOSPACE;
d645 3
d649 1
a649 1
		for (nn = n->child; nn; nn = nn->next) 
d653 3
d685 1
a685 1
		term_flushln(p);
d887 1
@


1.55
log
@Complete the merge of bsd.lv version 1.10.7:
No more functional changes, just sync ordering, comments and white space.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.54 2010/12/06 22:43:54 schwarze Exp $ */
a127 1
	{ pre_I, NULL, 0 }, /* i */
a130 1
	{ NULL, NULL, 0 }, /* r */
@


1.54
log
@Never print .P, .PP, and .LP header content.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.53 2010/11/29 02:26:45 schwarze Exp $ */
a262 1

a314 1

a323 1

a363 1

@


1.53
log
@Now that we have proper .de support in the roff(7) library,
it is time to remove the .Sp, .Vb, and .Ve kludge
that was added to the man(7) library to build Perl manuals.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.52 2010/11/29 00:12:02 schwarze Exp $ */
d513 1
a513 1
	return(1);
@


1.52
log
@Implement the roff .ft (change font) request for man(7).
Of course, we don't want to encourage low-level physical markup,
but pod2man(1) writes such requests, so Perl manuals contain them,
and some Xenocara and lots and lots of ports manuals use them as well.
In base and Xenocara, this will reduce mandoc -Tlint ERROR noise;
in ports, it will improve rendering of many manuals.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.51 2010/10/28 10:42:39 schwarze Exp $ */
a137 3
 	{ pre_sp, NULL, MAN_NOTEXT }, /* Sp */
 	{ pre_literal, NULL, 0 }, /* Vb */
 	{ pre_literal, NULL, 0 }, /* Ve */
d254 2
a255 4
	switch (n->tok) {
	case (MAN_Vb):
		/* FALLTHROUGH */
	case (MAN_nf):
d257 1
a257 2
		return(MAN_Vb != n->tok);
	default:
a258 2
		break;
	}
@


1.51
log
@Font alternating blocks like .RB must not break the line between children
in literal mode.  Fixing a bug found by naddy@@ in the gettext(3) SYNOPSIS.
This required a bit of refactoring:
* consolidate pre_RB(), pre_RI(), and pre_BI() into pre_alternate()
* save the MANT_LITERAL mode before descending into children
* restore MANT_LITERAL mode before printing the last child
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.50 2010/10/16 20:49:37 schwarze Exp $ */
d4 1
d96 1
d145 1
d332 42
@


1.50
log
@Do not abort() on tbl errors, reduce the risk that tbl stuff kills a build,
and provide more useful tbl error messages in a non-intrusive way.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.49 2010/10/15 22:07:12 schwarze Exp $ */
d80 1
a81 1
static	int		  pre_BI(DECL_ARGS);
a85 2
static	int		  pre_RB(DECL_ARGS);
static	int		  pre_RI(DECL_ARGS);
d116 4
a119 4
	{ pre_BI, NULL, 0 }, /* BI */
	{ pre_BI, NULL, 0 }, /* IB */
	{ pre_RB, NULL, 0 }, /* BR */
	{ pre_RB, NULL, 0 }, /* RB */
d123 2
a124 2
	{ pre_RI, NULL, 0 }, /* IR */
	{ pre_RI, NULL, 0 }, /* RI */
a268 1

d271 1
a271 1
pre_RB(DECL_ARGS)
d273 3
a275 2
	const struct man_node *nn;
	int		 i;
d277 28
a304 7
	for (i = 0, nn = n->child; nn; nn = nn->next, i++) {
		if (i % 2 && MAN_RB == n->tok)
			term_fontrepl(p, TERMFONT_BOLD);
		else if ( ! (i % 2) && MAN_RB != n->tok)
			term_fontrepl(p, TERMFONT_BOLD);
		else
			term_fontrepl(p, TERMFONT_NONE);
d306 2
a307 2
		if (i > 0)
			p->flags |= TERMP_NOSPACE;
d309 4
d314 1
a314 21
	}
	return(0);
}


/* ARGSUSED */
static int
pre_RI(DECL_ARGS)
{
	const struct man_node *nn;
	int		 i;

	for (i = 0, nn = n->child; nn; nn = nn->next, i++) {
		if (i % 2 && MAN_RI == n->tok)
			term_fontrepl(p, TERMFONT_UNDER);
		else if ( ! (i % 2) && MAN_RI != n->tok)
			term_fontrepl(p, TERMFONT_UNDER);
		else
			term_fontrepl(p, TERMFONT_NONE);

		if (i > 0)
a315 2

		print_man_node(p, mt, nn, m);
a316 20
	return(0);
}


/* ARGSUSED */
static int
pre_BI(DECL_ARGS)
{
	const struct man_node	*nn;
	int			 i;

	for (i = 0, nn = n->child; nn; nn = nn->next, i++) {
		if (i % 2 && MAN_BI == n->tok)
			term_fontrepl(p, TERMFONT_UNDER);
		else if (i % 2)
			term_fontrepl(p, TERMFONT_BOLD);
		else if (MAN_BI == n->tok)
			term_fontrepl(p, TERMFONT_BOLD);
		else
			term_fontrepl(p, TERMFONT_UNDER);
a317 5
		if (i)
			p->flags |= TERMP_NOSPACE;

		print_man_node(p, mt, nn, m);
	}
@


1.49
log
@Move tbl width calculation from plain strlen to mandoc terminal width
calculation routines.  This gives us mostly sane table column widths.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.48 2010/10/15 21:33:47 schwarze Exp $ */
d841 2
a842 4
	if ( ! tbl_close(p, n->data.TS, "<man>", n->line))
		return(0);

	tbl_write(p, n->data.TS);
@


1.48
log
@Move tbl output from plain stdio to mandoc terminal output routines.
This fixes (1) all escape sequences and (2) some aspects of indentation.
Table column widths are still way off, though.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.47 2010/10/15 20:45:03 schwarze Exp $ */
d841 1
a841 1
	if ( ! tbl_close(n->data.TS, "<man>", n->line))
@


1.47
log
@Minimal glue to integrate tbl into the mandoc man(7) parser and formatter.
The output dosn't look nice yet, escape handling is still missing,
but will follow soon.
"move forward aggressively :-)" deraadt@@
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.46 2010/09/21 22:33:41 schwarze Exp $ */
d844 1
a844 1
	tbl_write(n->data.TS);
@


1.46
log
@When calculating string lengths, resolve escape sequences and use
their actual lengths.  Will improve vertical alignment in some
uncommon situations, for example when escape sequences occur in
list or column width strings or in .Nm block arguments in the SYNOPSIS.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.45 2010/07/25 18:05:54 schwarze Exp $ */
d31 1
d96 1
d143 2
d830 17
@


1.45
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.44 2010/07/13 01:09:13 schwarze Exp $ */
d914 4
@


1.44
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.43 2010/06/27 21:54:42 schwarze Exp $ */
a90 2
static	int		  pre_br(DECL_ARGS);
static	int		  pre_fi(DECL_ARGS);
d92 2
a93 1
static	int		  pre_nf(DECL_ARGS);
d104 1
a104 1
	{ pre_br, NULL, MAN_NOTEXT }, /* br */
d128 2
a129 2
	{ pre_nf, NULL, 0 }, /* nf */
	{ pre_fi, NULL, 0 }, /* fi */
d137 2
a138 2
 	{ pre_nf, NULL, 0 }, /* Vb */
 	{ pre_fi, NULL, 0 }, /* Ve */
d140 1
d248 1
a248 1
pre_fi(DECL_ARGS)
d251 12
a262 1
	mt->fl &= ~MANT_LITERAL;
a266 9
/* ARGSUSED */
static int
pre_nf(DECL_ARGS)
{

	mt->fl |= MANT_LITERAL;
	return(MAN_Vb != n->tok);
}

d354 1
a354 1
pre_sp(DECL_ARGS)
d356 10
a365 1
	size_t		 i, len;
d367 2
a368 2
	len = n->child ? 
		a2height(p, n->child->string) : term_len(p, 1);
d370 18
a387 4
	if (0 == len)
		term_newln(p);
	for (i = 0; i <= len; i++)
		term_vspace(p);
d395 1
a395 1
pre_br(DECL_ARGS)
d397 15
a412 1
	term_newln(p);
@


1.43
log
@Full .nr nS support, unbreaking the kernel manuals.

Kristaps coded this from scratch after reading my .nr patch;
it is simpler and more powerful.

Registers live in struct regset in regs.h, struct man and struct mdoc
contain pointers to it.  The nS register is cleared when parsing .Sh.
Frontends respect the MDOC_SYNPRETTY flag set in mdoc node_alloc.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.42 2010/06/26 19:08:00 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
a26 1
#include "regs.h"
@


1.42
log
@As a first step towards variable-width font support,
move all width calculations in term_*.c, *_width().
From kristaps.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.41 2010/06/10 22:50:10 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d27 1
@


1.41
log
@minimal initial -Tps support, from kristaps@@ GSOC
so far, monospace without font decoration,
but it already has page headers and footers
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.40 2010/06/06 18:08:41 schwarze Exp $ */
d69 2
a70 2
static	int		  a2width(const struct man_node *);
static	int		  a2height(const struct man_node *);
d157 1
a157 1
	p->tabwidth = 5;
d176 2
a177 2
	mt.lmargin = INDENT;
	mt.offset = INDENT;
d186 2
a187 2
static int
a2height(const struct man_node *n)
d191 2
a192 4
	assert(MAN_TEXT == n->type);
	assert(n->string);
	if ( ! a2roffsu(n->string, &su, SCALE_VS))
		SCALE_VS_INIT(&su, strlen(n->string));
d194 1
a194 1
	return((int)term_vspan(&su));
d199 1
a199 1
a2width(const struct man_node *n)
d203 1
a203 3
	assert(MAN_TEXT == n->type);
	assert(n->string);
	if ( ! a2roffsu(n->string, &su, SCALE_BU))
d206 1
a206 1
	return((int)term_hspan(&su));
d354 1
a354 1
	int		 i, len;
d356 2
a357 1
	len = n->child ? a2height(n->child) : 1;
d404 1
a404 1
		if ((ival = a2width(nn)) >= 0)
d408 1
a408 1
		len = 1;
d449 1
a449 1
		mt->lmargin = INDENT;
d493 1
a493 1
			if ((ival = a2width(nn)) >= 0)
d501 1
a501 1
			len = 1;
d581 1
a581 1
			if ((ival = a2width(nn)) >= 0)
d589 1
a589 1
			len = 1;
d644 2
a645 2
		mt->lmargin = INDENT;
		mt->offset = INDENT;
d656 1
a656 1
		p->offset = HALFINDENT;
d694 2
a695 2
		mt->lmargin = INDENT;
		mt->offset = INDENT;
d756 1
a756 1
		mt->offset = mt->lmargin + INDENT;
d761 1
a761 1
	if ((ival = a2width(nn)) < 0)
d764 1
a764 1
	mt->offset = INDENT + (size_t)ival;
d778 1
a778 1
		mt->offset = mt->lmargin = INDENT;
d784 1
a784 1
		p->offset = INDENT;
d873 1
a873 1
	p->rmargin = p->maxrmargin - strlen(buf);
d914 1
a914 1
	buflen = strlen(buf);
d917 1
a917 1
	titlen = strlen(title);
d921 2
a922 1
	    (p->maxrmargin - strlen(buf) + 1) / 2 :
@


1.40
log
@Merge bsd.lv release 1.10.0,
which is mostly the post-hackathon release,
bringing in the OpenBSD changes to bsd.lv,
but which also has a few additional minor fixes:

* .Lb is an in-line macro, not in_line_eoln
* .Bt, .Ud now warn when discarding arguments
* allow bad -man dates to flow verbatim into the front-ends
- so far all reported by Ulrich Spoerlein
* .Ar, .Fl and .Li starting with closing punctuation emit an empty element
* empty .Li macros print nothing, but may cause spacing
* proper EOS handling for .Bt, .Ex, .Rv, and .Ud.
* cleanup: collapse posts_xr into posts_wtext (which is the same)
* efficiency: very simple table lookup for roff.c
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.39 2010/06/05 19:09:55 schwarze Exp $ */
a71 2
static	void		  print_man_head(struct termp *, 
				const struct man_meta *);
d74 2
a75 2
static	void		  print_man_foot(struct termp *, 
				const struct man_meta *);
d172 1
a172 1
	print_man_head(p, m);
d181 2
a182 1
	print_man_foot(p, m);
d857 1
a857 1
print_man_foot(struct termp *p, const struct man_meta *meta)
d860 3
d896 1
a896 1
print_man_head(struct termp *p, const struct man_meta *m)
d900 3
@


1.39
log
@Increase the -man -Tascii text width from 65 to 78 characters
in both our old in-tree groff and in mandoc, because
1) It looks and reads better.
2) It agrees with both bsd.lv mandoc and with modern groff.
The tmac.an part was done by millert@@, with a minor fix by me.

While touching our old groff, switch off hyphenation, suggested a long
time ago by millert@@.  It helps searching and comparisons.

While touching mandoc terminal_man(), explicitely initialize the
tabwidth - not strictly required, but easier to understand
and more robust, also suggested by millert@@.

General mumbling of agreement by many,
including millert@@ deraadt@@ jmc@@ sobrado@@ ...

Remaining problem:
Setting the title length (.lt) has no effect for me,
but we can fix this in tree in case anybody figures it out.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.38 2010/05/24 01:36:22 schwarze Exp $ */
d864 4
a867 1
	time2a(meta->date, buf, DATESIZ);
@


1.38
log
@sync to bsd.lv:
modern groff produces three blank lines before the man(7) footer;
from Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.37 2010/05/23 22:45:00 schwarze Exp $ */
d157 1
a157 6
	/*
	 * XXX
	 * Hardcode the -man output width for now;
	 * it is not yet externally configurable, anyway.
	 */
	p->defrmargin = 65;
d159 1
a159 1
	p->overstep = 0;
@


1.37
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.36 2010/05/23 20:57:16 schwarze Exp $ */
d871 2
@


1.36
log
@implement .AT and .UC; from Joerg Sonnenberger
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.35 2010/05/20 00:58:02 schwarze Exp $ */
d25 1
@


1.35
log
@Support nested roff instructions:
* allow roff_parseln() to be re-run
* allow roff_parseln() to manipulate the line buffer offset
* support the offset in the man and mdoc libraries
* adapt .if, .ie, .el, .ig, .am* and .de* support
* interpret some instructions even in conditional-negative context
Coded by kristaps during the last day of the mandoc hackathon.

To avoid regressions in the OpenBSD tree, commit this together
with some small local additions:
* detect roff block end "\}" even on macro lines
* actually implement the ".if n" conditional
* ignore .ds, .rm and .tr in libroff

Also back my old .if/.ie/.el-handling out of libman, reverting:
man.h 1.15 man.c 1.25 man_macro.c 1.15 man_validate.c 1.19
man_action.c 1.15 man_term.c 1.28 man_html.c 1.9.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.34 2010/05/16 00:54:03 schwarze Exp $ */
d141 1
@


1.34
log
@In theory, Kristaps never intended to write a roff parser,
but in practice, most real legacy man(7)uals are using so much
low level roff that we can't really get away without at least
partially handling some roff instructions.

As doing this in man(7) only has become messy and as even some
mdoc(7) pages need it, start a minimal partial roff preprocessor.
As a first step, move handling of .am[i], .de[i] and .ig there.
Do not use the roff preprocessor for new manuals!

Now that we have three main parser libraries - roff, man and mdoc -
each one having its own error handling is becoming messy, too.
Thus, start unifying message handling in one central place,
introducing a new generic function mmsg().

coded by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.33 2010/05/15 22:18:55 schwarze Exp $ */
a140 3
 	{ NULL, NULL, 0 }, /* if */
 	{ NULL, NULL, 0 }, /* ie */
 	{ NULL, NULL, 0 }, /* el */
@


1.33
log
@For .IP, a single space after the head is sufficient;
by Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.32 2010/05/15 21:09:53 schwarze Exp $ */
a140 6
 	{ pre_ign, NULL, MAN_NOTEXT }, /* de */
 	{ pre_ign, NULL, MAN_NOTEXT }, /* dei */
 	{ pre_ign, NULL, MAN_NOTEXT }, /* am */
 	{ pre_ign, NULL, MAN_NOTEXT }, /* ami */
 	{ pre_ign, NULL, MAN_NOTEXT }, /* ig */
 	{ NULL, NULL, 0 }, /* . */
@


1.32
log
@More systematic output width handling by Joerg Sonnenberger:
* save and restore the output width when switching to MANT_LITERAL
* add an argument to ascii_alloc to specify the output width
* set the default output width to 80 minus 2 characters
* OpenBSD local: set the output width to 65 characters for -man
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.31 2010/05/15 18:06:03 schwarze Exp $ */
a491 1
		p->flags |= TERMP_TWOSPACE;
a551 1
		p->flags &= ~TERMP_TWOSPACE;
@


1.31
log
@removed restriction on integer manual sections in -man;
by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.30 2010/05/14 19:52:43 schwarze Exp $ */
d164 7
a171 1
	p->maxrmargin = 65;
d811 1
d828 2
d833 2
a834 1
			p->rmargin = p->maxrmargin = 65;
@


1.30
log
@Integrate kristaps@@' end-of-sentence (EOS) framework
which is simpler and more powerful than mine, and remove mine.

* man(7) now has EOS handling, too
* put EOS detection into its own function in libmandoc
* use node and termp flags to communicate the EOS condition
* no more EOS pseudo-macro
* no more non-printable EOS marker character on the formatter level

This slightly breaks EOS detection after trailing punctuation
in mdoc(7) macros, but that will be restored soon.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.29 2010/05/14 14:47:44 schwarze Exp $ */
d913 1
a913 1
	snprintf(title, BUFSIZ, "%s(%d)", m->title, m->msec);
@


1.29
log
@Merge 1.9.25, keeping local patches;
this does not merge kristaps' end-of-sentences handling yet,
i will check that separately.  This one includes:
* handle \*(Ba as a delimiter
* introduce ARGS_PEND for .Bl -column .It end-of-line special casing
* section ordering: expect EXIT STATUS at the right place
* line break fixes in SYNOPSIS
* allow literal contexts to have arbitrary line lengths
* the input file column number can not be used to identify the beginning
  of a line because white space is allowed after the initial '.'
* proper leading spaces in -man -Tascii mode
* do not let Lb break lines in -mdoc -Thtml LIBRARY
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.28 2010/04/25 16:32:19 schwarze Exp $ */
d844 3
@


1.28
log
@Implement roff conditional instructions .if .ie .el, in man(7) only for now;
fixing OpenBSD::PackageName(3p) and friends for espie@@.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.27 2010/03/26 01:22:05 schwarze Exp $ */
a261 1
	p->rmargin = p->maxrmargin = 65;
a271 2
	p->rmargin = p->maxrmargin = 78;
	term_newln(p);
a272 1

d371 1
a371 1
	for (i = 0; i < len; i++)
d712 3
d821 1
d824 1
d895 6
d942 9
@


1.27
log
@merge 1.9.17, keeping local patches

* much improved pod2man support and low-level roff robustness
* have -Tlint imply -Wall and -fstrict
* use fewer macros and more enum in libman
* and various bug fixes
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.26 2010/03/25 23:23:01 schwarze Exp $ */
d147 3
@


1.26
log
@merge 1.9.16, keeping local patches

This is mostly cleanup by kristaps@@ after my rather hackish patch
to tolerate the non-text macros .na, .sp, .br in next-line scope;
plus some nesting issues fixed by him, all in man(7).
This survived a full  cd /usr/src; make man.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.25 2010/03/02 01:24:04 schwarze Exp $ */
d138 9
a146 3
	{ pre_sp, NULL, MAN_NOTEXT }, /* Sp */
	{ pre_nf, NULL, 0 }, /* Vb */
	{ pre_fi, NULL, 0 }, /* Ve */
d161 3
a166 1
			p->maxrmargin = 65;
d270 1
a270 1
	p->rmargin = p->maxrmargin = 160;
d273 2
a274 1
	return(1);
d790 2
d892 1
@


1.25
log
@In man(7), do not crash on very long title lines,
and do not emulate groff's habit of printing garbage either,
but just print the wanted information even though the format
must be sacrificed because it won't fit.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.22 2010/02/26 12:42:29 schwarze Exp $ */
d64 2
d106 35
a140 35
	{ pre_br, NULL }, /* br */
	{ NULL, NULL }, /* TH */
	{ pre_SH, post_SH }, /* SH */
	{ pre_SS, post_SS }, /* SS */
	{ pre_TP, post_TP }, /* TP */
	{ pre_PP, NULL }, /* LP */
	{ pre_PP, NULL }, /* PP */
	{ pre_PP, NULL }, /* P */
	{ pre_IP, post_IP }, /* IP */
	{ pre_HP, post_HP }, /* HP */ 
	{ NULL, NULL }, /* SM */
	{ pre_B, NULL }, /* SB */
	{ pre_BI, NULL }, /* BI */
	{ pre_BI, NULL }, /* IB */
	{ pre_RB, NULL }, /* BR */
	{ pre_RB, NULL }, /* RB */
	{ NULL, NULL }, /* R */
	{ pre_B, NULL }, /* B */
	{ pre_I, NULL }, /* I */
	{ pre_RI, NULL }, /* IR */
	{ pre_RI, NULL }, /* RI */
	{ NULL, NULL }, /* na */
	{ pre_I, NULL }, /* i */
	{ pre_sp, NULL }, /* sp */
	{ pre_nf, NULL }, /* nf */
	{ pre_fi, NULL }, /* fi */
	{ NULL, NULL }, /* r */
	{ NULL, NULL }, /* RE */
	{ pre_RS, post_RS }, /* RS */
	{ pre_ign, NULL }, /* DT */
	{ pre_ign, NULL }, /* UC */
	{ pre_ign, NULL }, /* PD */
	{ pre_sp, NULL }, /* Sp */
	{ pre_nf, NULL }, /* Vb */
	{ pre_fi, NULL }, /* Ve */
d813 2
a814 1
		term_fontrepl(p, TERMFONT_NONE);
d826 2
a827 1
		term_fontrepl(p, TERMFONT_NONE);
@


1.24
log
@For -man -Tascii, limit the width of normal text to 65 characters,
and effectively unlimit the width of literal displays.
Following this traditional behaviour allows for automatic output
comparisons.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.23 2010/03/02 01:00:39 schwarze Exp $ */
d874 1
d882 1
d885 1
d888 3
a890 1
	p->rmargin = (p->maxrmargin - strlen(buf) + 1) / 2;
d898 2
a899 1
	p->rmargin = p->maxrmargin - strlen(title);
a903 2
	p->offset = p->rmargin;
	p->rmargin = p->maxrmargin;
d905 7
a911 4
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;

	term_word(p, title);
	term_flushln(p);
@


1.23
log
@Accept the non-standard macros .Sp (similar to .sp)
and .Vb/.Ve (similar to .nf/.fi) in man(7) mode.
These are not intended to be used manually, but they allow us to
properly render man(7) code autogenerated by pod2man(1),
making Perl and OpenSSL happy in our tree.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.22 2010/02/26 12:42:29 schwarze Exp $ */
d156 1
d249 1
d260 1
@


1.22
log
@The groff_man(7) manual says "the first line of text following" .TP is
used as a label, not "the first line following", so allow (some kinds of)
intervening macros - some people actually put macros in between.

On the other hand, when there is no text line before the next block macro,
that is, when the .TP block ends without any text line, then something *is*
broken, so still error out in that case.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.21 2009/12/24 02:08:14 schwarze Exp $ */
d136 3
@


1.21
log
@sync to 1.9.14: rewrite escape sequence handling:
- new function a2roffdeco
- font modes (\f) only affect the current stack point
- implement scaling (\s)
- implement space suppression (\c)
- implement non-breaking space (\~) in -Tascii
- many manual improvements
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.20 2009/12/22 23:58:00 schwarze Exp $ */
d573 4
a576 2
	if (NULL != (nn = n->parent->head->child))
		if (NULL != nn->next)
d579 1
@


1.20
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.19 2009/10/27 21:40:07 schwarze Exp $ */
d71 1
a71 1
static	void		  print_man_body(DECL_ARGS);
a82 1
static	int		  pre_IR(DECL_ARGS);
a93 1
static	int		  pre_r(DECL_ARGS);
a95 2
static	void		  post_B(DECL_ARGS);
static	void		  post_I(DECL_ARGS);
a101 1
static	void		  post_i(DECL_ARGS);
d115 1
a115 1
	{ pre_B, post_B }, /* SB */
d121 3
a123 3
	{ pre_B, post_B }, /* B */
	{ pre_I, post_I }, /* I */
	{ pre_IR, NULL }, /* IR */
d126 1
a126 1
	{ pre_I, post_i }, /* i */
d130 1
a130 1
	{ pre_r, NULL }, /* r */
d171 1
a171 1
		print_man_body(p, &mt, n->child, m);
d235 1
a235 1
	p->under++;
a241 29
pre_r(DECL_ARGS)
{

	p->bold = p->under = 0;
	return(1);
}


/* ARGSUSED */
static void
post_i(DECL_ARGS)
{

	if (n->nchild)
		p->under--;
}


/* ARGSUSED */
static void
post_I(DECL_ARGS)
{

	p->under--;
}


/* ARGSUSED */
static int
a262 20
pre_IR(DECL_ARGS)
{
	const struct man_node *nn;
	int		 i;

	for (i = 0, nn = n->child; nn; nn = nn->next, i++) {
		if ( ! (i % 2))
			p->under++;
		if (i > 0)
			p->flags |= TERMP_NOSPACE;
		print_man_node(p, mt, nn, m);
		if ( ! (i % 2))
			p->under--;
	}
	return(0);
}


/* ARGSUSED */
static int
d270 1
a270 1
			p->bold++;
d272 3
a274 1
			p->bold++;
a279 5

		if (i % 2 && MAN_RB == n->tok)
			p->bold--;
		else if ( ! (i % 2) && MAN_RB != n->tok)
			p->bold--;
d293 7
a299 2
		if ( ! (i % 2))
			p->under++;
d302 1
a303 2
		if ( ! (i % 2))
			p->under--;
d318 1
a318 1
			p->under++;
d320 1
a320 1
			p->bold++;
d322 1
a322 1
			p->bold++;
d324 1
a324 1
			p->under++;
d328 1
a329 9

		if (i % 2 && MAN_BI == n->tok)
			p->under--;
		else if (i % 2)
			p->bold--;
		else if (MAN_BI == n->tok)
			p->bold--;
		else
			p->under--;
d340 1
a340 1
	p->bold++;
a345 9
static void
post_B(DECL_ARGS)
{

	p->bold--;
}


/* ARGSUSED */
d648 1
a648 1
		p->bold++;
a669 1
		p->bold--;
d696 1
a696 1
		p->bold++;
a717 1
		p->bold--;
d781 1
a781 1
	int		 c, sz;
d791 1
a791 7
		/*
		 * Note!  This is hacky.  Here, we recognise the `\c'
		 * escape embedded in so many -man pages.  It's supposed
		 * to remove the subsequent space, so we mark NOSPACE if
		 * it's encountered in the string.
		 */
		sz = (int)strlen(n->string);
d793 1
a793 3
		if (sz >= 2 && n->string[sz - 1] == 'c' &&
				n->string[sz - 2] == '\\')
			p->flags |= TERMP_NOSPACE;
d795 1
d802 1
d809 1
a809 1
		print_man_body(p, mt, n->child, m);
d811 1
a811 1
	if (MAN_TEXT != n->type)
d814 2
d820 1
a820 1
print_man_body(DECL_ARGS)
d826 1
a826 1
	print_man_body(p, mt, n->next, m);
d834 2
@


1.19
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.18 2009/10/21 19:13:50 schwarze Exp $ */
a20 1
#include <err.h>
d936 1
a936 1
print_man_head(struct termp *p, const struct man_meta *meta)
d938 1
a938 1
	char		*buf, *title;
d942 1
d944 2
a945 9
	if (NULL == (buf = malloc(p->rmargin)))
		err(EXIT_FAILURE, "malloc");
	if (NULL == (title = malloc(p->rmargin)))
		err(EXIT_FAILURE, "malloc");

	if (meta->vol)
		(void)strlcpy(buf, meta->vol, p->rmargin);
	else
		*buf = 0;
d947 1
a947 2
	(void)snprintf(title, p->rmargin, "%s(%d)", 
			meta->title, meta->msec);
a973 3

	free(title);
	free(buf);
a974 1

@


1.18
log
@sync to 1.9.9, featuring:
 * -Thtml output mode
 * roff scaling units
 * and some minor fixes
for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.17 2009/10/19 21:43:16 schwarze Exp $ */
d35 2
d67 2
a68 2
static	int		  arg2width(const struct man_node *);
static	int		  arg2height(const struct man_node *);
d70 1
a70 1
static	void		  print_head(struct termp *, 
d72 3
a74 3
static	void		  print_body(DECL_ARGS);
static	void		  print_node(DECL_ARGS);
static	void		  print_foot(struct termp *, 
d141 1
d169 1
a169 1
	print_head(p, m);
d177 2
a178 2
		print_body(p, &mt, n->child, m);
	print_foot(p, m);
d183 1
a183 1
arg2height(const struct man_node *n)
d197 1
a197 1
arg2width(const struct man_node *n)
d308 1
a308 1
		print_node(p, mt, nn, m);
d332 1
a332 1
		print_node(p, mt, nn, m);
d355 1
a355 1
		print_node(p, mt, nn, m);
d382 1
a382 1
		print_node(p, mt, nn, m);
d422 1
a422 1
	len = n->child ? arg2height(n->child) : 1;
d469 1
a469 1
		if ((ival = arg2width(nn)) >= 0)
d559 1
a559 1
			if ((ival = arg2width(nn)) >= 0)
d579 1
a579 1
			print_node(p, mt, nn, m);
d646 1
a646 1
			if ((ival = arg2width(nn)) >= 0)
d661 1
a661 1
				print_node(p, mt, nn, m);
d824 1
a824 1
	if ((ival = arg2width(nn)) < 0)
d852 1
a852 1
print_node(DECL_ARGS)
d888 1
a888 1
		print_body(p, mt, n->child, m);
d897 1
a897 1
print_body(DECL_ARGS)
d900 1
a900 1
	print_node(p, mt, n, m);
d903 1
a903 1
	print_body(p, mt, n->next, m);
d908 1
a908 1
print_foot(struct termp *p, const struct man_meta *meta)
d910 1
a910 4
	struct tm	*tm;
	char		 buf[BUFSIZ];

	tm = localtime(&meta->date);
d912 1
a912 2
	if (0 == strftime(buf, p->rmargin, "%B %d, %Y", tm))
		(void)strlcpy(buf, "(invalid date)", BUFSIZ);
d937 1
a937 1
print_head(struct termp *p, const struct man_meta *meta)
@


1.17
log
@sync to 1.9.7: consolidate some -man -Tascii functions,
and use a static buffer for the footer
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.16 2009/09/21 20:57:57 schwarze Exp $ */
d26 2
d29 2
a30 1
#include "man.h"
d65 12
a140 9
static	void		  print_head(struct termp *, 
				const struct man_meta *);
static	void		  print_body(DECL_ARGS);
static	void		  print_node(DECL_ARGS);
static	void		  print_foot(struct termp *, 
				const struct man_meta *);
static	void		  fmt_block_vspace(struct termp *, 
				const struct man_node *);
static	int		  arg_width(const struct man_node *);
d144 1
a144 1
man_run(struct termp *p, const struct man *m)
d146 19
a164 1
	struct mtermp	 mt;
d166 1
a166 1
	print_head(p, man_meta(m));
d173 3
a175 3
	if (man_node(m)->child)
		print_body(p, &mt, man_node(m)->child, man_meta(m));
	print_foot(p, man_meta(m));
d179 2
a180 2
static void
fmt_block_vspace(struct termp *p, const struct man_node *n)
d182 1
a182 1
	term_newln(p);
d184 4
a187 2
	if (NULL == n->prev)
		return;
d189 1
a189 6
	if (MAN_SS == n->prev->tok)
		return;
	if (MAN_SH == n->prev->tok)
		return;

	term_vspace(p);
d194 1
a194 1
arg_width(const struct man_node *n)
d196 1
a196 2
	int		 i, len;
	const char	*p;
d200 5
a205 1
	p = n->string;
d207 4
a210 2
	if (0 == (len = (int)strlen(p)))
		return(-1);
d212 2
a213 3
	for (i = 0; i < len; i++) 
		if ( ! isdigit((u_char)p[i]))
			break;
d215 4
a218 5
	if (i == len - 1)  {
		if ('n' == p[len - 1] || 'm' == p[len - 1])
			return(atoi(p));
	} else if (i == len)
		return(atoi(p));
d220 1
a220 1
	return(-1);
d419 1
a419 4
	if (NULL == n->child) {
		term_vspace(p);
		return(0);
	}
a420 1
	len = atoi(n->child->string);
d450 1
a450 1
		fmt_block_vspace(p, n);
d466 1
a466 1
		if ((ival = arg_width(nn)) >= 0)
d512 1
a512 1
		fmt_block_vspace(p, n);
d541 1
a541 1
		fmt_block_vspace(p, n);
d556 1
a556 1
			if ((ival = arg_width(nn)) >= 0)
d630 1
a630 1
		fmt_block_vspace(p, n);
d643 1
a643 1
			if ((ival = arg_width(nn)) >= 0)
d821 1
a821 1
	if ((ival = arg_width(nn)) < 0)
@


1.16
log
@sync to 1.9.5: make terminal_*, tree_* and out_* functions return void,
making the code simpler
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.15 2009/09/21 20:28:43 schwarze Exp $ */
a63 1
static	int		  pre_BR(DECL_ARGS);
a65 1
static	int		  pre_IB(DECL_ARGS);
d92 1
a92 1
static const struct termact termacts[MAN_MAX] = {
d106 2
a107 2
	{ pre_IB, NULL }, /* IB */
	{ pre_BR, NULL }, /* BR */
d291 1
a291 1
pre_IB(DECL_ARGS)
d297 3
a299 1
		if (i % 2)
d301 1
a301 2
		else
			p->under++;
d304 1
d306 2
a307 1
		if (i % 2)
d309 1
a309 21
		else
			p->under--;
	}
	return(0);
}


/* ARGSUSED */
static int
pre_RB(DECL_ARGS)
{
	const struct man_node *nn;
	int		 i;

	for (i = 0, nn = n->child; nn; nn = nn->next, i++) {
		if (i % 2)
			p->bold++;
		if (i > 0)
			p->flags |= TERMP_NOSPACE;
		print_node(p, mt, nn, m);
		if (i % 2)
a337 20
pre_BR(DECL_ARGS)
{
	const struct man_node *nn;
	int		 i;

	for (i = 0, nn = n->child; nn; nn = nn->next, i++) {
		if ( ! (i % 2))
			p->bold++;
		if (i > 0)
			p->flags |= TERMP_NOSPACE;
		print_node(p, mt, nn, m);
		if ( ! (i % 2))
			p->bold--;
	}
	return(0);
}


/* ARGSUSED */
static int
d340 2
a341 2
	const struct man_node *nn;
	int		 i;
d344 1
a344 1
		if (i % 2)
d346 4
d351 3
a353 2
			p->bold++;
		if (i > 0)
d356 2
a357 1
		if (i % 2)
d359 4
d364 1
a364 1
			p->bold--;
d888 1
a888 4
	char		*buf;

	if (NULL == (buf = malloc(p->rmargin)))
		err(EXIT_FAILURE, "malloc");
d893 1
a893 1
		err(EXIT_FAILURE, "strftime");
a913 2

	free(buf);
@


1.15
log
@sync to 1.9.5: remove TERMP_STYLE bit field in favour of recursion-friendly
integer flags, simplifying and shortening the code
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.14 2009/09/18 22:46:14 schwarze Exp $ */
d139 1
a139 1
int
a145 2
	assert(man_node(m));
	assert(MAN_ROOT == man_node(m)->type);
a153 2

	return(1);
d920 1
a920 1
		err(1, "malloc");
d925 1
a925 1
		err(1, "strftime");
d960 1
a960 1
		err(1, "malloc");
d962 1
a962 1
		err(1, "malloc");
@


1.14
log
@sync to 1.9.2: Add .UC libman macro for compatibility, has no effect.
Correct .UC and .DT to not print their arguments.
Document that .UC and .DT should not be used.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.13 2009/08/22 23:17:40 schwarze Exp $ */
d220 1
a220 1
	p->flags |= TERMP_UNDER;
d230 1
a230 2
	p->flags &= ~TERMP_UNDER;
	p->flags &= ~TERMP_BOLD;
d241 1
a241 1
		p->flags &= ~TERMP_UNDER;
d250 1
a250 1
	p->flags &= ~TERMP_UNDER;
d284 1
a284 1
			p->flags |= TERMP_UNDER;
d289 1
a289 1
			p->flags &= ~TERMP_UNDER;
d303 4
a306 1
		p->flags |= i % 2 ? TERMP_BOLD : TERMP_UNDER;
d310 4
a313 1
		p->flags &= i % 2 ? ~TERMP_BOLD : ~TERMP_UNDER;
d328 1
a328 1
			p->flags |= TERMP_BOLD;
d333 1
a333 1
			p->flags &= ~TERMP_BOLD;
d348 1
a348 1
			p->flags |= TERMP_UNDER;
d353 1
a353 1
			p->flags &= ~TERMP_UNDER;
d368 1
a368 1
			p->flags |= TERMP_BOLD;
d373 1
a373 1
			p->flags &= ~TERMP_BOLD;
d387 4
a390 1
		p->flags |= i % 2 ? TERMP_UNDER : TERMP_BOLD;
d394 4
a397 1
		p->flags &= i % 2 ? ~TERMP_UNDER : ~TERMP_BOLD;
d408 1
a408 1
	p->flags |= TERMP_BOLD;
d418 1
a418 1
	p->flags &= ~TERMP_BOLD;
d729 1
a729 1
		p->flags |= TERMP_BOLD;
d751 1
a751 1
		p->flags &= ~TERMP_BOLD;
d778 1
a778 1
		p->flags |= TERMP_BOLD;
d800 1
a800 1
		p->flags &= ~TERMP_BOLD;
@


1.13
log
@another large chunk of -man updates,
among others regarding .DT, .HP, .RS, .RE, .SH, .SS, and scoping,
now in sync vith release 1.9.1
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.12 2009/08/22 20:19:24 schwarze Exp $ */
d79 1
d124 2
a125 1
	{ NULL, NULL }, /* DT */
d203 9
@


1.12
log
@Oops, kill an "#ifdef __linux__" that crept in with the previous commit.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.11 2009/08/22 20:14:37 schwarze Exp $ */
d17 2
d35 15
a49 1
	int		  lmargin;
d73 1
d87 1
d115 1
a115 1
	{ NULL, NULL }, /* na */ /* TODO: document that has no effect */
d121 3
d149 1
d451 1
a451 1
	len = (size_t)mt->lmargin;
d463 2
a464 2
	p->offset = INDENT;
	p->rmargin = INDENT + len;
d467 1
a467 1
		mt->lmargin = ival;
d486 1
a486 1
		p->offset = INDENT;
d506 1
a506 1
		p->offset = INDENT;
d538 1
a538 1
	len = (size_t)mt->lmargin;
d557 2
a558 2
		p->offset = INDENT;
		p->rmargin = INDENT + len;
d563 1
a563 1
		mt->lmargin = ival;
d570 1
a570 1
		p->offset = INDENT + len;
d643 2
a644 2
		p->offset = INDENT;
		p->rmargin = INDENT + len;
d652 1
a652 1
			mt->lmargin = ival;
d656 1
a656 1
		p->offset = INDENT + len;
d697 1
d711 1
a711 1
		p->offset = INDENT;
d748 1
d760 1
a760 1
		p->offset = INDENT;
d784 50
@


1.11
log
@Kristaps@@ significantly overhauled libman.
I'm committing this in one large chunk because in contrast to -mdoc, -man
is mostly untested in OpenBSD anyway, so any fallout can be fixed in-tree.
Among others, improved support for .IP, .HP, and .TP.
Now in sync with release 1.9.0.
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.10 2009/08/22 18:10:02 schwarze Exp $ */
a103 5

#ifdef __linux__
extern	size_t		  strlcpy(char *, const char *, size_t);
extern	size_t		  strlcat(char *, const char *, size_t);
#endif
@


1.10
log
@sync to 1.9.0: move indentation size into *term.c files,
improving -man indentation
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.9 2009/08/22 15:15:37 schwarze Exp $ */
d18 1
d30 6
d37 1
d49 1
a49 1
static	int		  pre_br(DECL_ARGS);
d60 5
d68 2
d72 2
d80 1
a80 1
	{ pre_TP, NULL }, /* TP */
d84 2
a85 2
	{ pre_IP, NULL }, /* IP */
	{ pre_PP, NULL }, /* HP */ /* FIXME */
d97 6
a102 3
	{ NULL, NULL }, /* na */
	{ pre_I, post_I }, /* i */
	{ NULL, NULL }, /* sp */
d105 5
d116 3
d124 1
d130 4
d135 1
a135 1
		print_body(p, man_node(m)->child, man_meta(m));
d142 45
d198 21
d229 21
d260 1
a260 1
		print_node(p, nn, m);
d279 1
a279 1
		print_node(p, nn, m);
d298 1
a298 1
		print_node(p, nn, m);
d318 1
a318 1
		print_node(p, nn, m);
d338 1
a338 1
		print_node(p, nn, m);
d357 1
a357 1
		print_node(p, nn, m);
d385 21
d416 64
d483 11
a493 3
	term_vspace(p);
	p->offset = INDENT;
	return(0);
d501 46
a546 4
#if 0
	const struct man_node *nn;
	size_t		 offs;
#endif
d548 11
a558 2
	term_vspace(p);
	p->offset = INDENT;
d560 2
a561 5
#if 0
	if (NULL == (nn = n->child))
		return(1);
	if (MAN_TEXT != nn->type)
		errx(1, "expected text line argument");
a562 6
	if (nn->next) {
		if (MAN_TEXT != nn->next->type)
			errx(1, "expected text line argument");
		offs = (size_t)atoi(nn->next->string);
	} else
		offs = strlen(nn->string);
d564 4
a567 5
	p->flags |= TERMP_NOSPACE;
	/* FIXME */
	if ((p->offset += offs) > p->rmargin)
		errx(1, "line too long");
#endif
d569 14
a582 1
	return(0);
d590 24
a613 2
	const struct man_node *nn;
	size_t		 offs;
d615 4
a618 1
	term_vspace(p);
d620 25
a644 1
	p->offset = INDENT;
d646 2
a647 2
	if (NULL == (nn = n->child))
		return(1);
a648 7
	if (nn->line == n->line) {
		if (MAN_TEXT != nn->type)
			errx(1, "expected text line argument");
		offs = (size_t)atoi(nn->string);
		nn = nn->next;
	} else
		offs = INDENT;
d650 4
a653 2
	for ( ; nn; nn = nn->next)
		print_node(p, nn, m);
d655 14
a668 4
	term_flushln(p);
	p->flags |= TERMP_NOSPACE;
	p->offset += offs;
	return(0);
d677 22
a698 2
	term_vspace(p);
	p->flags |= TERMP_BOLD;
d708 11
a718 3
	term_flushln(p);
	p->flags &= ~TERMP_BOLD;
	p->flags |= TERMP_NOSPACE;
d727 20
a746 3
	term_vspace(p);
	p->offset = 0;
	p->flags |= TERMP_BOLD;
d756 11
a766 4
	term_flushln(p);
	p->offset = INDENT;
	p->flags &= ~TERMP_BOLD;
	p->flags |= TERMP_NOSPACE;
a777 4
	case(MAN_ELEM):
		if (termacts[n->tok].pre)
			c = (*termacts[n->tok].pre)(p, n, m);
		break;
d794 5
d801 2
d807 1
a807 1
		print_body(p, n->child, m);
d809 1
a809 2
	switch (n->type) {
	case (MAN_ELEM):
d811 1
a811 5
			(*termacts[n->tok].post)(p, n, m);
		break;
	default:
		break;
	}
d818 2
a819 1
	print_node(p, n, m);
d822 1
a822 1
	print_body(p, n->next, m);
@


1.9
log
@sync to 1.8.4: support .sp in -man
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.8 2009/06/23 22:43:30 schwarze Exp $ */
d25 3
@


1.8
log
@sync to 1.7.20: fix .br support in -man
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.7 2009/06/21 20:49:33 schwarze Exp $ */
d79 1
@


1.7
log
@sync to 1.7.19: do not try to print_body() when there is none
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.6 2009/06/18 23:34:53 schwarze Exp $ */
d38 1
d56 1
a56 1
	{ pre_PP, NULL }, /* br */
d261 10
d323 1
@


1.6
log
@sync to 1.7.19: improved comment handling
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.5 2009/06/18 21:34:54 schwarze Exp $ */
d94 4
a97 1
	print_body(p, man_node(m), man_meta(m));
@


1.5
log
@sync to 1.7.16: adjust centering of header lines to groff conventions
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.4 2009/06/18 21:16:11 schwarze Exp $ */
d55 1
a55 1
	{ NULL, NULL }, /* __ */
a75 1
	{ pre_PP, NULL }, /* br */
@


1.4
log
@sync to 1.7.16: catch overflow of the right margin by the .IP macro
currently, this code is deactivated, anyway
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.3 2009/06/17 22:27:34 schwarze Exp $ */
d496 1
a496 1
	p->rmargin = (p->maxrmargin - strlen(buf)) / 2;
@


1.3
log
@strftime returns size_t, not a pointer; no functional change
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.2 2009/06/14 23:00:57 schwarze Exp $ */
d292 4
a295 1
	p->offset += offs;
d297 1
a297 1
	p->flags |= TERMP_NOSPACE;
@


1.2
log
@sync to 1.7.16: comments, whitespace and spelling fixes; no functional change
@
text
@d1 1
a1 1
/*	$Id: man_term.c,v 1.12 2009/06/11 13:18:42 kristaps Exp $ */
d444 1
a444 1
	if (NULL == strftime(buf, p->rmargin, "%B %d, %Y", tm))
@


1.1
log
@Initial check-in of mandoc for formatting manuals. ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: man_term.c,v 1.7 2009/04/05 16:34:22 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@

