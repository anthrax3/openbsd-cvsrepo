head	1.103;
access;
symbols
	OPENBSD_6_1:1.103.0.4
	OPENBSD_6_1_BASE:1.103
	OPENBSD_6_0:1.94.0.4
	OPENBSD_6_0_BASE:1.94
	OPENBSD_5_9:1.94.0.2
	OPENBSD_5_9_BASE:1.94
	OPENBSD_5_8:1.91.0.4
	OPENBSD_5_8_BASE:1.91
	OPENBSD_5_7:1.86.0.2
	OPENBSD_5_7_BASE:1.86
	OPENBSD_5_6:1.65.0.4
	OPENBSD_5_6_BASE:1.65
	OPENBSD_5_5:1.58.0.4
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.46.0.2
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.38.0.2
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2;
locks; strict;
comment	@ * @;


1.103
date	2017.03.04.21.41.13;	author schwarze;	state Exp;
branches;
next	1.102;
commitid	ddmmJCwQ9u1jNSoA;

1.102
date	2017.02.17.19.14.39;	author schwarze;	state Exp;
branches;
next	1.101;
commitid	mtapDp67bcDPAAPY;

1.101
date	2017.02.16.02.59.42;	author schwarze;	state Exp;
branches;
next	1.100;
commitid	Qmey25xun8rVuoB9;

1.100
date	2017.02.06.03.41.44;	author schwarze;	state Exp;
branches;
next	1.99;
commitid	FiEZU00RcX3pLlUS;

1.99
date	2017.01.11.17.39.45;	author schwarze;	state Exp;
branches;
next	1.98;
commitid	2X81lVBLl8eAHRVh;

1.98
date	2017.01.10.23.36.24;	author schwarze;	state Exp;
branches;
next	1.97;
commitid	1NsxjVXtIEKZm6T7;

1.97
date	2017.01.10.21.54.34;	author schwarze;	state Exp;
branches;
next	1.96;
commitid	iaEy6J4gJ8kh18cm;

1.96
date	2017.01.10.13.46.53;	author schwarze;	state Exp;
branches;
next	1.95;
commitid	aFt8sLe7F06PjFYh;

1.95
date	2017.01.10.12.54.27;	author schwarze;	state Exp;
branches;
next	1.94;
commitid	vzXxeQWxUqXTMW9w;

1.94
date	2016.01.08.17.48.04;	author schwarze;	state Exp;
branches;
next	1.93;
commitid	DoGoemryKYV644MI;

1.93
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.92;
commitid	Ql2ha5NS80pwfGNT;

1.92
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.91;
commitid	hxQV8O1pNUaef4ir;

1.91
date	2015.04.18.17.50.02;	author schwarze;	state Exp;
branches;
next	1.90;
commitid	sjmmdLSx1e3Vat0h;

1.90
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.89;
commitid	6MYJ7cd8mhJ77AGH;

1.89
date	2015.04.02.23.47.43;	author schwarze;	state Exp;
branches;
next	1.88;
commitid	RJFkOLiS9gBqEEDl;

1.88
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.87;
commitid	Rfx1oTaH3hZ7Zcyf;

1.87
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.86;
commitid	lmErjWY2O9ooA6RY;

1.86
date	2015.02.17.20.33.44;	author schwarze;	state Exp;
branches;
next	1.85;
commitid	bzSwTm9b9VF7LbRZ;

1.85
date	2015.02.12.12.20.47;	author schwarze;	state Exp;
branches;
next	1.84;
commitid	SViaEKzwzmf0o0kW;

1.84
date	2015.02.11.14.14.53;	author schwarze;	state Exp;
branches;
next	1.83;
commitid	2V8eDQf8fVyAwXBZ;

1.83
date	2015.02.06.03.31.11;	author schwarze;	state Exp;
branches;
next	1.82;
commitid	EGoCKP2gntS3HBlE;

1.82
date	2015.02.01.23.10.15;	author schwarze;	state Exp;
branches;
next	1.81;
commitid	d1ys3bKakrrT671d;

1.81
date	2015.01.28.17.30.37;	author schwarze;	state Exp;
branches;
next	1.80;
commitid	B9i4oMLogJsiyrd5;

1.80
date	2015.01.23.14.19.52;	author schwarze;	state Exp;
branches;
next	1.79;
commitid	XkcvCG1NCY9WGWyO;

1.79
date	2014.12.24.23.31.59;	author schwarze;	state Exp;
branches;
next	1.78;
commitid	TfSx49MGGpeWF6md;

1.78
date	2014.12.23.13.48.15;	author schwarze;	state Exp;
branches;
next	1.77;
commitid	gQAVpbNdyny1vBnL;

1.77
date	2014.12.23.10.09.23;	author schwarze;	state Exp;
branches;
next	1.76;
commitid	NXsRNvvlEYsozbQg;

1.76
date	2014.12.23.09.31.17;	author schwarze;	state Exp;
branches;
next	1.75;
commitid	SXZbldG8wiiZaqvE;

1.75
date	2014.11.30.05.28.00;	author schwarze;	state Exp;
branches;
next	1.74;
commitid	4gOj8tbqcpkeLVbt;

1.74
date	2014.11.27.22.27.40;	author schwarze;	state Exp;
branches;
next	1.73;
commitid	5z09nX8VCSvBpGIv;

1.73
date	2014.11.27.16.20.27;	author schwarze;	state Exp;
branches;
next	1.72;
commitid	snF2JxsotuPud6ts;

1.72
date	2014.11.19.21.59.19;	author schwarze;	state Exp;
branches;
next	1.71;
commitid	im0MTOZhKZYRJTHJ;

1.71
date	2014.11.17.06.44.35;	author schwarze;	state Exp;
branches;
next	1.70;
commitid	eO1CUhWjZNit4m47;

1.70
date	2014.11.06.22.27.52;	author schwarze;	state Exp;
branches;
next	1.69;
commitid	qwsIHj8nt3H0FddP;

1.69
date	2014.10.30.20.05.33;	author schwarze;	state Exp;
branches;
next	1.68;
commitid	0MyCvIn2JIoyqJkI;

1.68
date	2014.08.21.12.56.24;	author schwarze;	state Exp;
branches;
next	1.67;
commitid	Y0pln4y7V0yebwer;

1.67
date	2014.08.08.16.17.09;	author schwarze;	state Exp;
branches;
next	1.66;
commitid	TLMAnDXVMoqLltgG;

1.66
date	2014.08.08.15.10.15;	author schwarze;	state Exp;
branches;
next	1.65;
commitid	V6V8vpTM0RQ4gS7I;

1.65
date	2014.07.04.16.11.41;	author schwarze;	state Exp;
branches;
next	1.64;
commitid	sgqZ9hnRM3L6yvgn;

1.64
date	2014.07.02.19.54.39;	author schwarze;	state Exp;
branches;
next	1.63;
commitid	Yt0K01y5ZeXGGSxs;

1.63
date	2014.07.02.03.47.07;	author schwarze;	state Exp;
branches;
next	1.62;
commitid	p4pNII1v0bYCswy0;

1.62
date	2014.04.20.19.39.35;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2014.01.24.11.56.34;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2014.01.22.20.58.35;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2013.12.25.22.00.34;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2013.12.25.00.39.13;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2013.12.24.22.08.23;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2013.12.24.20.45.21;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2013.10.07.22.21.56;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2013.09.15.18.48.26;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2013.06.02.18.16.51;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2013.05.29.15.40.14;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2013.05.19.21.40.18;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2013.05.19.21.05.29;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2012.12.31.22.34.01;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2012.11.19.02.14.39;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2012.11.18.19.34.12;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2012.11.18.17.59.03;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2012.11.17.00.25.20;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2012.07.29.16.31.44;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2012.07.29.16.30.52;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2012.07.29.16.29.56;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2012.07.16.10.45.28;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2012.07.14.09.05.58;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2012.07.13.23.56.35;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2012.07.13.20.42.59;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2012.07.13.14.15.50;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2012.07.12.08.53.45;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2012.07.11.23.45.25;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2012.07.11.16.18.08;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2012.07.10.20.36.33;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2012.07.10.19.53.11;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2012.07.10.14.35.57;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2012.07.09.23.52.47;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2012.07.09.22.36.04;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2012.07.09.18.55.40;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2012.07.09.17.52.09;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2012.07.09.09.30.28;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2012.07.08.22.48.38;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2012.07.08.18.38.07;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2012.07.08.16.50.36;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2012.07.08.15.46.47;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2012.07.08.15.00.43;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2012.07.08.13.56.27;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2012.07.08.11.08.06;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2012.07.08.10.58.44;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2012.07.08.10.16.36;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2012.07.07.21.15.37;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2012.07.07.20.34.20;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2012.07.07.14.04.39;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2012.07.07.13.56.19;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2012.07.07.13.51.03;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2012.07.07.13.45.26;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2012.07.07.13.32.47;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2011.10.22.20.54.52;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.20.01.11.41;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.10.09.17.59.56;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2011.09.30.00.13.21;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2011.09.20.13.47.59;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2011.09.17.14.45.22;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.103
log
@Remove a redundant condition in .%T handling, no functional change.
Found by jsg@@ with scan-build.
@
text
@/*	$OpenBSD: mdoc_man.c,v 1.102 2017/02/17 19:14:39 schwarze Exp $ */
/*
 * Copyright (c) 2011-2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <stdio.h>
#include <string.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "man.h"
#include "out.h"
#include "main.h"

#define	DECL_ARGS const struct roff_meta *meta, struct roff_node *n

struct	manact {
	int		(*cond)(DECL_ARGS); /* DON'T run actions */
	int		(*pre)(DECL_ARGS); /* pre-node action */
	void		(*post)(DECL_ARGS); /* post-node action */
	const char	 *prefix; /* pre-node string constant */
	const char	 *suffix; /* post-node string constant */
};

static	int	  cond_body(DECL_ARGS);
static	int	  cond_head(DECL_ARGS);
static  void	  font_push(char);
static	void	  font_pop(void);
static	void	  mid_it(void);
static	void	  post__t(DECL_ARGS);
static	void	  post_aq(DECL_ARGS);
static	void	  post_bd(DECL_ARGS);
static	void	  post_bf(DECL_ARGS);
static	void	  post_bk(DECL_ARGS);
static	void	  post_bl(DECL_ARGS);
static	void	  post_dl(DECL_ARGS);
static	void	  post_en(DECL_ARGS);
static	void	  post_enc(DECL_ARGS);
static	void	  post_eo(DECL_ARGS);
static	void	  post_fa(DECL_ARGS);
static	void	  post_fd(DECL_ARGS);
static	void	  post_fl(DECL_ARGS);
static	void	  post_fn(DECL_ARGS);
static	void	  post_fo(DECL_ARGS);
static	void	  post_font(DECL_ARGS);
static	void	  post_in(DECL_ARGS);
static	void	  post_it(DECL_ARGS);
static	void	  post_lb(DECL_ARGS);
static	void	  post_nm(DECL_ARGS);
static	void	  post_percent(DECL_ARGS);
static	void	  post_pf(DECL_ARGS);
static	void	  post_sect(DECL_ARGS);
static	void	  post_sp(DECL_ARGS);
static	void	  post_vt(DECL_ARGS);
static	int	  pre__t(DECL_ARGS);
static	int	  pre_an(DECL_ARGS);
static	int	  pre_ap(DECL_ARGS);
static	int	  pre_aq(DECL_ARGS);
static	int	  pre_bd(DECL_ARGS);
static	int	  pre_bf(DECL_ARGS);
static	int	  pre_bk(DECL_ARGS);
static	int	  pre_bl(DECL_ARGS);
static	int	  pre_br(DECL_ARGS);
static	int	  pre_dl(DECL_ARGS);
static	int	  pre_en(DECL_ARGS);
static	int	  pre_enc(DECL_ARGS);
static	int	  pre_em(DECL_ARGS);
static	int	  pre_skip(DECL_ARGS);
static	int	  pre_eo(DECL_ARGS);
static	int	  pre_ex(DECL_ARGS);
static	int	  pre_fa(DECL_ARGS);
static	int	  pre_fd(DECL_ARGS);
static	int	  pre_fl(DECL_ARGS);
static	int	  pre_fn(DECL_ARGS);
static	int	  pre_fo(DECL_ARGS);
static	int	  pre_ft(DECL_ARGS);
static	int	  pre_in(DECL_ARGS);
static	int	  pre_it(DECL_ARGS);
static	int	  pre_lk(DECL_ARGS);
static	int	  pre_li(DECL_ARGS);
static	int	  pre_ll(DECL_ARGS);
static	int	  pre_nm(DECL_ARGS);
static	int	  pre_no(DECL_ARGS);
static	int	  pre_ns(DECL_ARGS);
static	int	  pre_pp(DECL_ARGS);
static	int	  pre_rs(DECL_ARGS);
static	int	  pre_sm(DECL_ARGS);
static	int	  pre_sp(DECL_ARGS);
static	int	  pre_sect(DECL_ARGS);
static	int	  pre_sy(DECL_ARGS);
static	void	  pre_syn(const struct roff_node *);
static	int	  pre_vt(DECL_ARGS);
static	int	  pre_xr(DECL_ARGS);
static	void	  print_word(const char *);
static	void	  print_line(const char *, int);
static	void	  print_block(const char *, int);
static	void	  print_offs(const char *, int);
static	void	  print_width(const struct mdoc_bl *,
			const struct roff_node *);
static	void	  print_count(int *);
static	void	  print_node(DECL_ARGS);

static	const struct manact manacts[MDOC_MAX + 1] = {
	{ NULL, pre_ap, NULL, NULL, NULL }, /* Ap */
	{ NULL, NULL, NULL, NULL, NULL }, /* Dd */
	{ NULL, NULL, NULL, NULL, NULL }, /* Dt */
	{ NULL, NULL, NULL, NULL, NULL }, /* Os */
	{ NULL, pre_sect, post_sect, ".SH", NULL }, /* Sh */
	{ NULL, pre_sect, post_sect, ".SS", NULL }, /* Ss */
	{ NULL, pre_pp, NULL, NULL, NULL }, /* Pp */
	{ cond_body, pre_dl, post_dl, NULL, NULL }, /* D1 */
	{ cond_body, pre_dl, post_dl, NULL, NULL }, /* Dl */
	{ cond_body, pre_bd, post_bd, NULL, NULL }, /* Bd */
	{ NULL, NULL, NULL, NULL, NULL }, /* Ed */
	{ cond_body, pre_bl, post_bl, NULL, NULL }, /* Bl */
	{ NULL, NULL, NULL, NULL, NULL }, /* El */
	{ NULL, pre_it, post_it, NULL, NULL }, /* It */
	{ NULL, pre_em, post_font, NULL, NULL }, /* Ad */
	{ NULL, pre_an, NULL, NULL, NULL }, /* An */
	{ NULL, pre_em, post_font, NULL, NULL }, /* Ar */
	{ NULL, pre_sy, post_font, NULL, NULL }, /* Cd */
	{ NULL, pre_sy, post_font, NULL, NULL }, /* Cm */
	{ NULL, pre_li, post_font, NULL, NULL }, /* Dv */
	{ NULL, pre_li, post_font, NULL, NULL }, /* Er */
	{ NULL, pre_li, post_font, NULL, NULL }, /* Ev */
	{ NULL, pre_ex, NULL, NULL, NULL }, /* Ex */
	{ NULL, pre_fa, post_fa, NULL, NULL }, /* Fa */
	{ NULL, pre_fd, post_fd, NULL, NULL }, /* Fd */
	{ NULL, pre_fl, post_fl, NULL, NULL }, /* Fl */
	{ NULL, pre_fn, post_fn, NULL, NULL }, /* Fn */
	{ NULL, pre_ft, post_font, NULL, NULL }, /* Ft */
	{ NULL, pre_sy, post_font, NULL, NULL }, /* Ic */
	{ NULL, pre_in, post_in, NULL, NULL }, /* In */
	{ NULL, pre_li, post_font, NULL, NULL }, /* Li */
	{ cond_head, pre_enc, NULL, "\\- ", NULL }, /* Nd */
	{ NULL, pre_nm, post_nm, NULL, NULL }, /* Nm */
	{ cond_body, pre_enc, post_enc, "[", "]" }, /* Op */
	{ NULL, pre_ft, post_font, NULL, NULL }, /* Ot */
	{ NULL, pre_em, post_font, NULL, NULL }, /* Pa */
	{ NULL, pre_ex, NULL, NULL, NULL }, /* Rv */
	{ NULL, NULL, NULL, NULL, NULL }, /* St */
	{ NULL, pre_em, post_font, NULL, NULL }, /* Va */
	{ NULL, pre_vt, post_vt, NULL, NULL }, /* Vt */
	{ NULL, pre_xr, NULL, NULL, NULL }, /* Xr */
	{ NULL, NULL, post_percent, NULL, NULL }, /* %A */
	{ NULL, pre_em, post_percent, NULL, NULL }, /* %B */
	{ NULL, NULL, post_percent, NULL, NULL }, /* %D */
	{ NULL, pre_em, post_percent, NULL, NULL }, /* %I */
	{ NULL, pre_em, post_percent, NULL, NULL }, /* %J */
	{ NULL, NULL, post_percent, NULL, NULL }, /* %N */
	{ NULL, NULL, post_percent, NULL, NULL }, /* %O */
	{ NULL, NULL, post_percent, NULL, NULL }, /* %P */
	{ NULL, NULL, post_percent, NULL, NULL }, /* %R */
	{ NULL, pre__t, post__t, NULL, NULL }, /* %T */
	{ NULL, NULL, post_percent, NULL, NULL }, /* %V */
	{ NULL, NULL, NULL, NULL, NULL }, /* Ac */
	{ cond_body, pre_aq, post_aq, NULL, NULL }, /* Ao */
	{ cond_body, pre_aq, post_aq, NULL, NULL }, /* Aq */
	{ NULL, NULL, NULL, NULL, NULL }, /* At */
	{ NULL, NULL, NULL, NULL, NULL }, /* Bc */
	{ NULL, pre_bf, post_bf, NULL, NULL }, /* Bf */
	{ cond_body, pre_enc, post_enc, "[", "]" }, /* Bo */
	{ cond_body, pre_enc, post_enc, "[", "]" }, /* Bq */
	{ NULL, NULL, NULL, NULL, NULL }, /* Bsx */
	{ NULL, NULL, NULL, NULL, NULL }, /* Bx */
	{ NULL, pre_skip, NULL, NULL, NULL }, /* Db */
	{ NULL, NULL, NULL, NULL, NULL }, /* Dc */
	{ cond_body, pre_enc, post_enc, "\\(Lq", "\\(Rq" }, /* Do */
	{ cond_body, pre_enc, post_enc, "\\(Lq", "\\(Rq" }, /* Dq */
	{ NULL, NULL, NULL, NULL, NULL }, /* Ec */
	{ NULL, NULL, NULL, NULL, NULL }, /* Ef */
	{ NULL, pre_em, post_font, NULL, NULL }, /* Em */
	{ cond_body, pre_eo, post_eo, NULL, NULL }, /* Eo */
	{ NULL, NULL, NULL, NULL, NULL }, /* Fx */
	{ NULL, pre_sy, post_font, NULL, NULL }, /* Ms */
	{ NULL, pre_no, NULL, NULL, NULL }, /* No */
	{ NULL, pre_ns, NULL, NULL, NULL }, /* Ns */
	{ NULL, NULL, NULL, NULL, NULL }, /* Nx */
	{ NULL, NULL, NULL, NULL, NULL }, /* Ox */
	{ NULL, NULL, NULL, NULL, NULL }, /* Pc */
	{ NULL, NULL, post_pf, NULL, NULL }, /* Pf */
	{ cond_body, pre_enc, post_enc, "(", ")" }, /* Po */
	{ cond_body, pre_enc, post_enc, "(", ")" }, /* Pq */
	{ NULL, NULL, NULL, NULL, NULL }, /* Qc */
	{ cond_body, pre_enc, post_enc, "\\(oq", "\\(cq" }, /* Ql */
	{ cond_body, pre_enc, post_enc, "\"", "\"" }, /* Qo */
	{ cond_body, pre_enc, post_enc, "\"", "\"" }, /* Qq */
	{ NULL, NULL, NULL, NULL, NULL }, /* Re */
	{ cond_body, pre_rs, NULL, NULL, NULL }, /* Rs */
	{ NULL, NULL, NULL, NULL, NULL }, /* Sc */
	{ cond_body, pre_enc, post_enc, "\\(oq", "\\(cq" }, /* So */
	{ cond_body, pre_enc, post_enc, "\\(oq", "\\(cq" }, /* Sq */
	{ NULL, pre_sm, NULL, NULL, NULL }, /* Sm */
	{ NULL, pre_em, post_font, NULL, NULL }, /* Sx */
	{ NULL, pre_sy, post_font, NULL, NULL }, /* Sy */
	{ NULL, pre_li, post_font, NULL, NULL }, /* Tn */
	{ NULL, NULL, NULL, NULL, NULL }, /* Ux */
	{ NULL, NULL, NULL, NULL, NULL }, /* Xc */
	{ NULL, NULL, NULL, NULL, NULL }, /* Xo */
	{ NULL, pre_fo, post_fo, NULL, NULL }, /* Fo */
	{ NULL, NULL, NULL, NULL, NULL }, /* Fc */
	{ cond_body, pre_enc, post_enc, "[", "]" }, /* Oo */
	{ NULL, NULL, NULL, NULL, NULL }, /* Oc */
	{ NULL, pre_bk, post_bk, NULL, NULL }, /* Bk */
	{ NULL, NULL, NULL, NULL, NULL }, /* Ek */
	{ NULL, NULL, NULL, NULL, NULL }, /* Bt */
	{ NULL, NULL, NULL, NULL, NULL }, /* Hf */
	{ NULL, pre_em, post_font, NULL, NULL }, /* Fr */
	{ NULL, NULL, NULL, NULL, NULL }, /* Ud */
	{ NULL, NULL, post_lb, NULL, NULL }, /* Lb */
	{ NULL, pre_pp, NULL, NULL, NULL }, /* Lp */
	{ NULL, pre_lk, NULL, NULL, NULL }, /* Lk */
	{ NULL, pre_em, post_font, NULL, NULL }, /* Mt */
	{ cond_body, pre_enc, post_enc, "{", "}" }, /* Brq */
	{ cond_body, pre_enc, post_enc, "{", "}" }, /* Bro */
	{ NULL, NULL, NULL, NULL, NULL }, /* Brc */
	{ NULL, NULL, post_percent, NULL, NULL }, /* %C */
	{ NULL, pre_skip, NULL, NULL, NULL }, /* Es */
	{ cond_body, pre_en, post_en, NULL, NULL }, /* En */
	{ NULL, NULL, NULL, NULL, NULL }, /* Dx */
	{ NULL, NULL, post_percent, NULL, NULL }, /* %Q */
	{ NULL, pre_br, NULL, NULL, NULL }, /* br */
	{ NULL, pre_sp, post_sp, NULL, NULL }, /* sp */
	{ NULL, NULL, post_percent, NULL, NULL }, /* %U */
	{ NULL, NULL, NULL, NULL, NULL }, /* Ta */
	{ NULL, pre_ll, post_sp, NULL, NULL }, /* ll */
	{ NULL, NULL, NULL, NULL, NULL }, /* ROOT */
};

static	int		outflags;
#define	MMAN_spc	(1 << 0)  /* blank character before next word */
#define	MMAN_spc_force	(1 << 1)  /* even before trailing punctuation */
#define	MMAN_nl		(1 << 2)  /* break man(7) code line */
#define	MMAN_br		(1 << 3)  /* break output line */
#define	MMAN_sp		(1 << 4)  /* insert a blank output line */
#define	MMAN_PP		(1 << 5)  /* reset indentation etc. */
#define	MMAN_Sm		(1 << 6)  /* horizontal spacing mode */
#define	MMAN_Bk		(1 << 7)  /* word keep mode */
#define	MMAN_Bk_susp	(1 << 8)  /* suspend this (after a macro) */
#define	MMAN_An_split	(1 << 9)  /* author mode is "split" */
#define	MMAN_An_nosplit	(1 << 10) /* author mode is "nosplit" */
#define	MMAN_PD		(1 << 11) /* inter-paragraph spacing disabled */
#define	MMAN_nbrword	(1 << 12) /* do not break the next word */

#define	BL_STACK_MAX	32

static	int		Bl_stack[BL_STACK_MAX];  /* offsets [chars] */
static	int		Bl_stack_post[BL_STACK_MAX];  /* add final .RE */
static	int		Bl_stack_len;  /* number of nested Bl blocks */
static	int		TPremain;  /* characters before tag is full */

static	struct {
	char	*head;
	char	*tail;
	size_t	 size;
}	fontqueue;


static void
font_push(char newfont)
{

	if (fontqueue.head + fontqueue.size <= ++fontqueue.tail) {
		fontqueue.size += 8;
		fontqueue.head = mandoc_realloc(fontqueue.head,
		    fontqueue.size);
	}
	*fontqueue.tail = newfont;
	print_word("");
	printf("\\f");
	putchar(newfont);
	outflags &= ~MMAN_spc;
}

static void
font_pop(void)
{

	if (fontqueue.tail > fontqueue.head)
		fontqueue.tail--;
	outflags &= ~MMAN_spc;
	print_word("");
	printf("\\f");
	putchar(*fontqueue.tail);
}

static void
print_word(const char *s)
{

	if ((MMAN_PP | MMAN_sp | MMAN_br | MMAN_nl) & outflags) {
		/*
		 * If we need a newline, print it now and start afresh.
		 */
		if (MMAN_PP & outflags) {
			if (MMAN_sp & outflags) {
				if (MMAN_PD & outflags) {
					printf("\n.PD");
					outflags &= ~MMAN_PD;
				}
			} else if ( ! (MMAN_PD & outflags)) {
				printf("\n.PD 0");
				outflags |= MMAN_PD;
			}
			printf("\n.PP\n");
		} else if (MMAN_sp & outflags)
			printf("\n.sp\n");
		else if (MMAN_br & outflags)
			printf("\n.br\n");
		else if (MMAN_nl & outflags)
			putchar('\n');
		outflags &= ~(MMAN_PP|MMAN_sp|MMAN_br|MMAN_nl|MMAN_spc);
		if (1 == TPremain)
			printf(".br\n");
		TPremain = 0;
	} else if (MMAN_spc & outflags) {
		/*
		 * If we need a space, only print it if
		 * (1) it is forced by `No' or
		 * (2) what follows is not terminating punctuation or
		 * (3) what follows is longer than one character.
		 */
		if (MMAN_spc_force & outflags || '\0' == s[0] ||
		    NULL == strchr(".,:;)]?!", s[0]) || '\0' != s[1]) {
			if (MMAN_Bk & outflags &&
			    ! (MMAN_Bk_susp & outflags))
				putchar('\\');
			putchar(' ');
			if (TPremain)
				TPremain--;
		}
	}

	/*
	 * Reassign needing space if we're not following opening
	 * punctuation.
	 */
	if (MMAN_Sm & outflags && ('\0' == s[0] ||
	    (('(' != s[0] && '[' != s[0]) || '\0' != s[1])))
		outflags |= MMAN_spc;
	else
		outflags &= ~MMAN_spc;
	outflags &= ~(MMAN_spc_force | MMAN_Bk_susp);

	for ( ; *s; s++) {
		switch (*s) {
		case ASCII_NBRSP:
			printf("\\ ");
			break;
		case ASCII_HYPH:
			putchar('-');
			break;
		case ASCII_BREAK:
			printf("\\:");
			break;
		case ' ':
			if (MMAN_nbrword & outflags) {
				printf("\\ ");
				break;
			}
			/* FALLTHROUGH */
		default:
			putchar((unsigned char)*s);
			break;
		}
		if (TPremain)
			TPremain--;
	}
	outflags &= ~MMAN_nbrword;
}

static void
print_line(const char *s, int newflags)
{

	outflags &= ~MMAN_br;
	outflags |= MMAN_nl;
	print_word(s);
	outflags |= newflags;
}

static void
print_block(const char *s, int newflags)
{

	outflags &= ~MMAN_PP;
	if (MMAN_sp & outflags) {
		outflags &= ~(MMAN_sp | MMAN_br);
		if (MMAN_PD & outflags) {
			print_line(".PD", 0);
			outflags &= ~MMAN_PD;
		}
	} else if (! (MMAN_PD & outflags))
		print_line(".PD 0", MMAN_PD);
	outflags |= MMAN_nl;
	print_word(s);
	outflags |= MMAN_Bk_susp | newflags;
}

static void
print_offs(const char *v, int keywords)
{
	char		  buf[24];
	struct roffsu	  su;
	int		  sz;

	print_line(".RS", MMAN_Bk_susp);

	/* Convert v into a number (of characters). */
	if (NULL == v || '\0' == *v || (keywords && !strcmp(v, "left")))
		sz = 0;
	else if (keywords && !strcmp(v, "indent"))
		sz = 6;
	else if (keywords && !strcmp(v, "indent-two"))
		sz = 12;
	else if (a2roffsu(v, &su, SCALE_EN) > 1) {
		if (SCALE_EN == su.unit)
			sz = su.scale;
		else {
			/*
			 * XXX
			 * If we are inside an enclosing list,
			 * there is no easy way to add the two
			 * indentations because they are provided
			 * in terms of different units.
			 */
			print_word(v);
			outflags |= MMAN_nl;
			return;
		}
	} else
		sz = strlen(v);

	/*
	 * We are inside an enclosing list.
	 * Add the two indentations.
	 */
	if (Bl_stack_len)
		sz += Bl_stack[Bl_stack_len - 1];

	(void)snprintf(buf, sizeof(buf), "%dn", sz);
	print_word(buf);
	outflags |= MMAN_nl;
}

/*
 * Set up the indentation for a list item; used from pre_it().
 */
static void
print_width(const struct mdoc_bl *bl, const struct roff_node *child)
{
	char		  buf[24];
	struct roffsu	  su;
	int		  numeric, remain, sz, chsz;

	numeric = 1;
	remain = 0;

	/* Convert the width into a number (of characters). */
	if (bl->width == NULL)
		sz = (bl->type == LIST_hang) ? 6 : 0;
	else if (a2roffsu(bl->width, &su, SCALE_MAX) > 1) {
		if (SCALE_EN == su.unit)
			sz = su.scale;
		else {
			sz = 0;
			numeric = 0;
		}
	} else
		sz = strlen(bl->width);

	/* XXX Rough estimation, might have multiple parts. */
	if (bl->type == LIST_enum)
		chsz = (bl->count > 8) + 1;
	else if (child != NULL && child->type == ROFFT_TEXT)
		chsz = strlen(child->string);
	else
		chsz = 0;

	/* Maybe we are inside an enclosing list? */
	mid_it();

	/*
	 * Save our own indentation,
	 * such that child lists can use it.
	 */
	Bl_stack[Bl_stack_len++] = sz + 2;

	/* Set up the current list. */
	if (chsz > sz && bl->type != LIST_tag)
		print_block(".HP", 0);
	else {
		print_block(".TP", 0);
		remain = sz + 2;
	}
	if (numeric) {
		(void)snprintf(buf, sizeof(buf), "%dn", sz + 2);
		print_word(buf);
	} else
		print_word(bl->width);
	TPremain = remain;
}

static void
print_count(int *count)
{
	char		  buf[24];

	(void)snprintf(buf, sizeof(buf), "%d.\\&", ++*count);
	print_word(buf);
}

void
man_man(void *arg, const struct roff_man *man)
{

	/*
	 * Dump the keep buffer.
	 * We're guaranteed by now that this exists (is non-NULL).
	 * Flush stdout afterward, just in case.
	 */
	fputs(mparse_getkeep(man_mparse(man)), stdout);
	fflush(stdout);
}

void
man_mdoc(void *arg, const struct roff_man *mdoc)
{
	struct roff_node *n;

	printf(".TH \"%s\" \"%s\" \"%s\" \"%s\" \"%s\"\n",
	    mdoc->meta.title,
	    (mdoc->meta.msec == NULL ? "" : mdoc->meta.msec),
	    mdoc->meta.date, mdoc->meta.os, mdoc->meta.vol);

	/* Disable hyphenation and if nroff, disable justification. */
	printf(".nh\n.if n .ad l");

	outflags = MMAN_nl | MMAN_Sm;
	if (0 == fontqueue.size) {
		fontqueue.size = 8;
		fontqueue.head = fontqueue.tail = mandoc_malloc(8);
		*fontqueue.tail = 'R';
	}
	for (n = mdoc->first->child; n != NULL; n = n->next)
		print_node(&mdoc->meta, n);
	putchar('\n');
}

static void
print_node(DECL_ARGS)
{
	const struct manact	*act;
	struct roff_node	*sub;
	int			 cond, do_sub;

	if (n->flags & NODE_NOPRT)
		return;

	/*
	 * Break the line if we were parsed subsequent the current node.
	 * This makes the page structure be more consistent.
	 */
	if (MMAN_spc & outflags && NODE_LINE & n->flags)
		outflags |= MMAN_nl;

	act = NULL;
	cond = 0;
	do_sub = 1;
	n->flags &= ~NODE_ENDED;

	if (n->type == ROFFT_TEXT) {
		/*
		 * Make sure that we don't happen to start with a
		 * control character at the start of a line.
		 */
		if (MMAN_nl & outflags &&
		    ('.' == *n->string || '\'' == *n->string)) {
			print_word("");
			printf("\\&");
			outflags &= ~MMAN_spc;
		}
		if (n->flags & NODE_DELIMC)
			outflags &= ~(MMAN_spc | MMAN_spc_force);
		else if (outflags & MMAN_Sm)
			outflags |= MMAN_spc_force;
		print_word(n->string);
		if (n->flags & NODE_DELIMO)
			outflags &= ~(MMAN_spc | MMAN_spc_force);
		else if (outflags & MMAN_Sm)
			outflags |= MMAN_spc;
	} else {
		/*
		 * Conditionally run the pre-node action handler for a
		 * node.
		 */
		act = manacts + n->tok;
		cond = act->cond == NULL || (*act->cond)(meta, n);
		if (cond && act->pre != NULL &&
		    (n->end == ENDBODY_NOT || n->child != NULL))
			do_sub = (*act->pre)(meta, n);
	}

	/*
	 * Conditionally run all child nodes.
	 * Note that this iterates over children instead of using
	 * recursion.  This prevents unnecessary depth in the stack.
	 */
	if (do_sub)
		for (sub = n->child; sub; sub = sub->next)
			print_node(meta, sub);

	/*
	 * Lastly, conditionally run the post-node handler.
	 */
	if (NODE_ENDED & n->flags)
		return;

	if (cond && act->post)
		(*act->post)(meta, n);

	if (ENDBODY_NOT != n->end)
		n->body->flags |= NODE_ENDED;
}

static int
cond_head(DECL_ARGS)
{

	return n->type == ROFFT_HEAD;
}

static int
cond_body(DECL_ARGS)
{

	return n->type == ROFFT_BODY;
}

static int
pre_enc(DECL_ARGS)
{
	const char	*prefix;

	prefix = manacts[n->tok].prefix;
	if (NULL == prefix)
		return 1;
	print_word(prefix);
	outflags &= ~MMAN_spc;
	return 1;
}

static void
post_enc(DECL_ARGS)
{
	const char *suffix;

	suffix = manacts[n->tok].suffix;
	if (NULL == suffix)
		return;
	outflags &= ~(MMAN_spc | MMAN_nl);
	print_word(suffix);
}

static int
pre_ex(DECL_ARGS)
{
	outflags |= MMAN_br | MMAN_nl;
	return 1;
}

static void
post_font(DECL_ARGS)
{

	font_pop();
}

static void
post_percent(DECL_ARGS)
{

	if (pre_em == manacts[n->tok].pre)
		font_pop();
	if (n->next) {
		print_word(",");
		if (n->prev &&	n->prev->tok == n->tok &&
				n->next->tok == n->tok)
			print_word("and");
	} else {
		print_word(".");
		outflags |= MMAN_nl;
	}
}

static int
pre__t(DECL_ARGS)
{

	if (n->parent->tok == MDOC_Rs && n->parent->norm->Rs.quote_T) {
		print_word("\\(lq");
		outflags &= ~MMAN_spc;
	} else
		font_push('I');
	return 1;
}

static void
post__t(DECL_ARGS)
{

	if (n->parent->tok  == MDOC_Rs && n->parent->norm->Rs.quote_T) {
		outflags &= ~MMAN_spc;
		print_word("\\(rq");
	} else
		font_pop();
	post_percent(meta, n);
}

/*
 * Print before a section header.
 */
static int
pre_sect(DECL_ARGS)
{

	if (n->type == ROFFT_HEAD) {
		outflags |= MMAN_sp;
		print_block(manacts[n->tok].prefix, 0);
		print_word("");
		putchar('\"');
		outflags &= ~MMAN_spc;
	}
	return 1;
}

/*
 * Print subsequent a section header.
 */
static void
post_sect(DECL_ARGS)
{

	if (n->type != ROFFT_HEAD)
		return;
	outflags &= ~MMAN_spc;
	print_word("");
	putchar('\"');
	outflags |= MMAN_nl;
	if (MDOC_Sh == n->tok && SEC_AUTHORS == n->sec)
		outflags &= ~(MMAN_An_split | MMAN_An_nosplit);
}

/* See mdoc_term.c, synopsis_pre() for comments. */
static void
pre_syn(const struct roff_node *n)
{

	if (NULL == n->prev || ! (NODE_SYNPRETTY & n->flags))
		return;

	if (n->prev->tok == n->tok &&
	    MDOC_Ft != n->tok &&
	    MDOC_Fo != n->tok &&
	    MDOC_Fn != n->tok) {
		outflags |= MMAN_br;
		return;
	}

	switch (n->prev->tok) {
	case MDOC_Fd:
	case MDOC_Fn:
	case MDOC_Fo:
	case MDOC_In:
	case MDOC_Vt:
		outflags |= MMAN_sp;
		break;
	case MDOC_Ft:
		if (MDOC_Fn != n->tok && MDOC_Fo != n->tok) {
			outflags |= MMAN_sp;
			break;
		}
		/* FALLTHROUGH */
	default:
		outflags |= MMAN_br;
		break;
	}
}

static int
pre_an(DECL_ARGS)
{

	switch (n->norm->An.auth) {
	case AUTH_split:
		outflags &= ~MMAN_An_nosplit;
		outflags |= MMAN_An_split;
		return 0;
	case AUTH_nosplit:
		outflags &= ~MMAN_An_split;
		outflags |= MMAN_An_nosplit;
		return 0;
	default:
		if (MMAN_An_split & outflags)
			outflags |= MMAN_br;
		else if (SEC_AUTHORS == n->sec &&
		    ! (MMAN_An_nosplit & outflags))
			outflags |= MMAN_An_split;
		return 1;
	}
}

static int
pre_ap(DECL_ARGS)
{

	outflags &= ~MMAN_spc;
	print_word("'");
	outflags &= ~MMAN_spc;
	return 0;
}

static int
pre_aq(DECL_ARGS)
{

	print_word(n->child != NULL && n->child->next == NULL &&
	    n->child->tok == MDOC_Mt ?  "<" : "\\(la");
	outflags &= ~MMAN_spc;
	return 1;
}

static void
post_aq(DECL_ARGS)
{

	outflags &= ~(MMAN_spc | MMAN_nl);
	print_word(n->child != NULL && n->child->next == NULL &&
	    n->child->tok == MDOC_Mt ?  ">" : "\\(ra");
}

static int
pre_bd(DECL_ARGS)
{

	outflags &= ~(MMAN_PP | MMAN_sp | MMAN_br);

	if (DISP_unfilled == n->norm->Bd.type ||
	    DISP_literal  == n->norm->Bd.type)
		print_line(".nf", 0);
	if (0 == n->norm->Bd.comp && NULL != n->parent->prev)
		outflags |= MMAN_sp;
	print_offs(n->norm->Bd.offs, 1);
	return 1;
}

static void
post_bd(DECL_ARGS)
{

	/* Close out this display. */
	print_line(".RE", MMAN_nl);
	if (DISP_unfilled == n->norm->Bd.type ||
	    DISP_literal  == n->norm->Bd.type)
		print_line(".fi", MMAN_nl);

	/* Maybe we are inside an enclosing list? */
	if (NULL != n->parent->next)
		mid_it();
}

static int
pre_bf(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		return 1;
	case ROFFT_BODY:
		break;
	default:
		return 0;
	}
	switch (n->norm->Bf.font) {
	case FONT_Em:
		font_push('I');
		break;
	case FONT_Sy:
		font_push('B');
		break;
	default:
		font_push('R');
		break;
	}
	return 1;
}

static void
post_bf(DECL_ARGS)
{

	if (n->type == ROFFT_BODY)
		font_pop();
}

static int
pre_bk(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		return 1;
	case ROFFT_BODY:
		outflags |= MMAN_Bk;
		return 1;
	default:
		return 0;
	}
}

static void
post_bk(DECL_ARGS)
{

	if (n->type == ROFFT_BODY)
		outflags &= ~MMAN_Bk;
}

static int
pre_bl(DECL_ARGS)
{
	size_t		 icol;

	/*
	 * print_offs() will increase the -offset to account for
	 * a possible enclosing .It, but any enclosed .It blocks
	 * just nest and do not add up their indentation.
	 */
	if (n->norm->Bl.offs) {
		print_offs(n->norm->Bl.offs, 0);
		Bl_stack[Bl_stack_len++] = 0;
	}

	switch (n->norm->Bl.type) {
	case LIST_enum:
		n->norm->Bl.count = 0;
		return 1;
	case LIST_column:
		break;
	default:
		return 1;
	}

	if (n->child != NULL) {
		print_line(".TS", MMAN_nl);
		for (icol = 0; icol < n->norm->Bl.ncols; icol++)
			print_word("l");
		print_word(".");
	}
	outflags |= MMAN_nl;
	return 1;
}

static void
post_bl(DECL_ARGS)
{

	switch (n->norm->Bl.type) {
	case LIST_column:
		if (n->child != NULL)
			print_line(".TE", 0);
		break;
	case LIST_enum:
		n->norm->Bl.count = 0;
		break;
	default:
		break;
	}

	if (n->norm->Bl.offs) {
		print_line(".RE", MMAN_nl);
		assert(Bl_stack_len);
		Bl_stack_len--;
		assert(0 == Bl_stack[Bl_stack_len]);
	} else {
		outflags |= MMAN_PP | MMAN_nl;
		outflags &= ~(MMAN_sp | MMAN_br);
	}

	/* Maybe we are inside an enclosing list? */
	if (NULL != n->parent->next)
		mid_it();

}

static int
pre_br(DECL_ARGS)
{

	outflags |= MMAN_br;
	return 0;
}

static int
pre_dl(DECL_ARGS)
{

	print_offs("6n", 0);
	return 1;
}

static void
post_dl(DECL_ARGS)
{

	print_line(".RE", MMAN_nl);

	/* Maybe we are inside an enclosing list? */
	if (NULL != n->parent->next)
		mid_it();
}

static int
pre_em(DECL_ARGS)
{

	font_push('I');
	return 1;
}

static int
pre_en(DECL_ARGS)
{

	if (NULL == n->norm->Es ||
	    NULL == n->norm->Es->child)
		return 1;

	print_word(n->norm->Es->child->string);
	outflags &= ~MMAN_spc;
	return 1;
}

static void
post_en(DECL_ARGS)
{

	if (NULL == n->norm->Es ||
	    NULL == n->norm->Es->child ||
	    NULL == n->norm->Es->child->next)
		return;

	outflags &= ~MMAN_spc;
	print_word(n->norm->Es->child->next->string);
	return;
}

static int
pre_eo(DECL_ARGS)
{

	if (n->end == ENDBODY_NOT &&
	    n->parent->head->child == NULL &&
	    n->child != NULL &&
	    n->child->end != ENDBODY_NOT)
		print_word("\\&");
	else if (n->end != ENDBODY_NOT ? n->child != NULL :
	    n->parent->head->child != NULL && (n->child != NULL ||
	    (n->parent->tail != NULL && n->parent->tail->child != NULL)))
		outflags &= ~(MMAN_spc | MMAN_nl);
	return 1;
}

static void
post_eo(DECL_ARGS)
{
	int	 body, tail;

	if (n->end != ENDBODY_NOT) {
		outflags |= MMAN_spc;
		return;
	}

	body = n->child != NULL || n->parent->head->child != NULL;
	tail = n->parent->tail != NULL && n->parent->tail->child != NULL;

	if (body && tail)
		outflags &= ~MMAN_spc;
	else if ( ! (body || tail))
		print_word("\\&");
	else if ( ! tail)
		outflags |= MMAN_spc;
}

static int
pre_fa(DECL_ARGS)
{
	int	 am_Fa;

	am_Fa = MDOC_Fa == n->tok;

	if (am_Fa)
		n = n->child;

	while (NULL != n) {
		font_push('I');
		if (am_Fa || NODE_SYNPRETTY & n->flags)
			outflags |= MMAN_nbrword;
		print_node(meta, n);
		font_pop();
		if (NULL != (n = n->next))
			print_word(",");
	}
	return 0;
}

static void
post_fa(DECL_ARGS)
{

	if (NULL != n->next && MDOC_Fa == n->next->tok)
		print_word(",");
}

static int
pre_fd(DECL_ARGS)
{

	pre_syn(n);
	font_push('B');
	return 1;
}

static void
post_fd(DECL_ARGS)
{

	font_pop();
	outflags |= MMAN_br;
}

static int
pre_fl(DECL_ARGS)
{

	font_push('B');
	print_word("\\-");
	if (n->child != NULL)
		outflags &= ~MMAN_spc;
	return 1;
}

static void
post_fl(DECL_ARGS)
{

	font_pop();
	if (!(n->child != NULL ||
	    n->next == NULL ||
	    n->next->type == ROFFT_TEXT ||
	    n->next->flags & NODE_LINE))
		outflags &= ~MMAN_spc;
}

static int
pre_fn(DECL_ARGS)
{

	pre_syn(n);

	n = n->child;
	if (NULL == n)
		return 0;

	if (NODE_SYNPRETTY & n->flags)
		print_block(".HP 4n", MMAN_nl);

	font_push('B');
	print_node(meta, n);
	font_pop();
	outflags &= ~MMAN_spc;
	print_word("(");
	outflags &= ~MMAN_spc;

	n = n->next;
	if (NULL != n)
		pre_fa(meta, n);
	return 0;
}

static void
post_fn(DECL_ARGS)
{

	print_word(")");
	if (NODE_SYNPRETTY & n->flags) {
		print_word(";");
		outflags |= MMAN_PP;
	}
}

static int
pre_fo(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		pre_syn(n);
		break;
	case ROFFT_HEAD:
		if (n->child == NULL)
			return 0;
		if (NODE_SYNPRETTY & n->flags)
			print_block(".HP 4n", MMAN_nl);
		font_push('B');
		break;
	case ROFFT_BODY:
		outflags &= ~(MMAN_spc | MMAN_nl);
		print_word("(");
		outflags &= ~MMAN_spc;
		break;
	default:
		break;
	}
	return 1;
}

static void
post_fo(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_HEAD:
		if (n->child != NULL)
			font_pop();
		break;
	case ROFFT_BODY:
		post_fn(meta, n);
		break;
	default:
		break;
	}
}

static int
pre_ft(DECL_ARGS)
{

	pre_syn(n);
	font_push('I');
	return 1;
}

static int
pre_in(DECL_ARGS)
{

	if (NODE_SYNPRETTY & n->flags) {
		pre_syn(n);
		font_push('B');
		print_word("#include <");
		outflags &= ~MMAN_spc;
	} else {
		print_word("<");
		outflags &= ~MMAN_spc;
		font_push('I');
	}
	return 1;
}

static void
post_in(DECL_ARGS)
{

	if (NODE_SYNPRETTY & n->flags) {
		outflags &= ~MMAN_spc;
		print_word(">");
		font_pop();
		outflags |= MMAN_br;
	} else {
		font_pop();
		outflags &= ~MMAN_spc;
		print_word(">");
	}
}

static int
pre_it(DECL_ARGS)
{
	const struct roff_node *bln;

	switch (n->type) {
	case ROFFT_HEAD:
		outflags |= MMAN_PP | MMAN_nl;
		bln = n->parent->parent;
		if (0 == bln->norm->Bl.comp ||
		    (NULL == n->parent->prev &&
		     NULL == bln->parent->prev))
			outflags |= MMAN_sp;
		outflags &= ~MMAN_br;
		switch (bln->norm->Bl.type) {
		case LIST_item:
			return 0;
		case LIST_inset:
		case LIST_diag:
		case LIST_ohang:
			if (bln->norm->Bl.type == LIST_diag)
				print_line(".B \"", 0);
			else
				print_line(".R \"", 0);
			outflags &= ~MMAN_spc;
			return 1;
		case LIST_bullet:
		case LIST_dash:
		case LIST_hyphen:
			print_width(&bln->norm->Bl, NULL);
			TPremain = 0;
			outflags |= MMAN_nl;
			font_push('B');
			if (LIST_bullet == bln->norm->Bl.type)
				print_word("\\(bu");
			else
				print_word("-");
			font_pop();
			outflags |= MMAN_nl;
			return 0;
		case LIST_enum:
			print_width(&bln->norm->Bl, NULL);
			TPremain = 0;
			outflags |= MMAN_nl;
			print_count(&bln->norm->Bl.count);
			outflags |= MMAN_nl;
			return 0;
		case LIST_hang:
			print_width(&bln->norm->Bl, n->child);
			TPremain = 0;
			outflags |= MMAN_nl;
			return 1;
		case LIST_tag:
			print_width(&bln->norm->Bl, n->child);
			putchar('\n');
			outflags &= ~MMAN_spc;
			return 1;
		default:
			return 1;
		}
	default:
		break;
	}
	return 1;
}

/*
 * This function is called after closing out an indented block.
 * If we are inside an enclosing list, restore its indentation.
 */
static void
mid_it(void)
{
	char		 buf[24];

	/* Nothing to do outside a list. */
	if (0 == Bl_stack_len || 0 == Bl_stack[Bl_stack_len - 1])
		return;

	/* The indentation has already been set up. */
	if (Bl_stack_post[Bl_stack_len - 1])
		return;

	/* Restore the indentation of the enclosing list. */
	print_line(".RS", MMAN_Bk_susp);
	(void)snprintf(buf, sizeof(buf), "%dn",
	    Bl_stack[Bl_stack_len - 1]);
	print_word(buf);

	/* Remeber to close out this .RS block later. */
	Bl_stack_post[Bl_stack_len - 1] = 1;
}

static void
post_it(DECL_ARGS)
{
	const struct roff_node *bln;

	bln = n->parent->parent;

	switch (n->type) {
	case ROFFT_HEAD:
		switch (bln->norm->Bl.type) {
		case LIST_diag:
			outflags &= ~MMAN_spc;
			print_word("\\ ");
			break;
		case LIST_ohang:
			outflags |= MMAN_br;
			break;
		default:
			break;
		}
		break;
	case ROFFT_BODY:
		switch (bln->norm->Bl.type) {
		case LIST_bullet:
		case LIST_dash:
		case LIST_hyphen:
		case LIST_enum:
		case LIST_hang:
		case LIST_tag:
			assert(Bl_stack_len);
			Bl_stack[--Bl_stack_len] = 0;

			/*
			 * Our indentation had to be restored
			 * after a child display or child list.
			 * Close out that indentation block now.
			 */
			if (Bl_stack_post[Bl_stack_len]) {
				print_line(".RE", MMAN_nl);
				Bl_stack_post[Bl_stack_len] = 0;
			}
			break;
		case LIST_column:
			if (NULL != n->next) {
				putchar('\t');
				outflags &= ~MMAN_spc;
			}
			break;
		default:
			break;
		}
		break;
	default:
		break;
	}
}

static void
post_lb(DECL_ARGS)
{

	if (SEC_LIBRARY == n->sec)
		outflags |= MMAN_br;
}

static int
pre_lk(DECL_ARGS)
{
	const struct roff_node *link, *descr;

	if (NULL == (link = n->child))
		return 0;

	if (NULL != (descr = link->next)) {
		font_push('I');
		while (NULL != descr) {
			print_word(descr->string);
			descr = descr->next;
		}
		print_word(":");
		font_pop();
	}

	font_push('B');
	print_word(link->string);
	font_pop();
	return 0;
}

static int
pre_ll(DECL_ARGS)
{

	print_line(".ll", 0);
	return 1;
}

static int
pre_li(DECL_ARGS)
{

	font_push('R');
	return 1;
}

static int
pre_nm(DECL_ARGS)
{
	char	*name;

	if (n->type == ROFFT_BLOCK) {
		outflags |= MMAN_Bk;
		pre_syn(n);
	}
	if (n->type != ROFFT_ELEM && n->type != ROFFT_HEAD)
		return 1;
	name = n->child == NULL ? NULL : n->child->string;
	if (NULL == name)
		return 0;
	if (n->type == ROFFT_HEAD) {
		if (NULL == n->parent->prev)
			outflags |= MMAN_sp;
		print_block(".HP", 0);
		printf(" %zun", strlen(name) + 1);
		outflags |= MMAN_nl;
	}
	font_push('B');
	return 1;
}

static void
post_nm(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		outflags &= ~MMAN_Bk;
		break;
	case ROFFT_HEAD:
	case ROFFT_ELEM:
		if (n->child != NULL && n->child->string != NULL)
			font_pop();
		break;
	default:
		break;
	}
}

static int
pre_no(DECL_ARGS)
{

	outflags |= MMAN_spc_force;
	return 1;
}

static int
pre_ns(DECL_ARGS)
{

	outflags &= ~MMAN_spc;
	return 0;
}

static void
post_pf(DECL_ARGS)
{

	if ( ! (n->next == NULL || n->next->flags & NODE_LINE))
		outflags &= ~MMAN_spc;
}

static int
pre_pp(DECL_ARGS)
{

	if (MDOC_It != n->parent->tok)
		outflags |= MMAN_PP;
	outflags |= MMAN_sp | MMAN_nl;
	outflags &= ~MMAN_br;
	return 0;
}

static int
pre_rs(DECL_ARGS)
{

	if (SEC_SEE_ALSO == n->sec) {
		outflags |= MMAN_PP | MMAN_sp | MMAN_nl;
		outflags &= ~MMAN_br;
	}
	return 1;
}

static int
pre_skip(DECL_ARGS)
{

	return 0;
}

static int
pre_sm(DECL_ARGS)
{

	if (NULL == n->child)
		outflags ^= MMAN_Sm;
	else if (0 == strcmp("on", n->child->string))
		outflags |= MMAN_Sm;
	else
		outflags &= ~MMAN_Sm;

	if (MMAN_Sm & outflags)
		outflags |= MMAN_spc;

	return 0;
}

static int
pre_sp(DECL_ARGS)
{

	if (MMAN_PP & outflags) {
		outflags &= ~MMAN_PP;
		print_line(".PP", 0);
	} else
		print_line(".sp", 0);
	return 1;
}

static void
post_sp(DECL_ARGS)
{

	outflags |= MMAN_nl;
}

static int
pre_sy(DECL_ARGS)
{

	font_push('B');
	return 1;
}

static int
pre_vt(DECL_ARGS)
{

	if (NODE_SYNPRETTY & n->flags) {
		switch (n->type) {
		case ROFFT_BLOCK:
			pre_syn(n);
			return 1;
		case ROFFT_BODY:
			break;
		default:
			return 0;
		}
	}
	font_push('I');
	return 1;
}

static void
post_vt(DECL_ARGS)
{

	if (n->flags & NODE_SYNPRETTY && n->type != ROFFT_BODY)
		return;
	font_pop();
}

static int
pre_xr(DECL_ARGS)
{

	n = n->child;
	if (NULL == n)
		return 0;
	print_node(meta, n);
	n = n->next;
	if (NULL == n)
		return 0;
	outflags &= ~MMAN_spc;
	print_word("(");
	print_node(meta, n);
	print_word(")");
	return 0;
}
@


1.102
log
@Use typographic quotes rather than '"' for .Rs %T (no change for -Tascii
output, of course).  Patch from bentley@@ in November 2014.  This can be
committed now because groff merged Anthony's patch yesterday.

Simply committing myself because asking Anthony to go search for
his two-year-old patch and have him discover that it had accumulated
an average of (felt) two or three conflicts per line by now would
have been mean, even if hilarious.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.101 2017/02/16 02:59:42 schwarze Exp $ */
d716 1
a716 2
	if (n->parent && MDOC_Rs == n->parent->tok &&
	    n->parent->norm->Rs.quote_T) {
d728 1
a728 2
	if (n->parent && MDOC_Rs == n->parent->tok &&
	    n->parent->norm->Rs.quote_T) {
@


1.101
log
@Remove the ENDBODY_NOSPACE flag, simplifying the code.

Comparing to groff output, it appears that all cases where it was used
and made a difference actually require the opposite, ENDBODY_SPACE.

I have no idea why i added it back in 2010; maybe to compensate for
some other bug that has long been fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.100 2017/02/06 03:41:44 schwarze Exp $ */
d718 1
a718 2
		print_word("");
		putchar('\"');
d732 1
a732 2
		print_word("");
		putchar('\"');
@


1.100
log
@The .Nm macro does not only use the default name when it has no
argument, but also when the first argument is a child macro.
Arcane issue found in the FreeBSD cxgbetool(8) manual that Baptiste
Daroussin <bapt at FreeBSD> sent me long ago for a different reason.

While solving this, switch to the new technique of doing text
production in the validator, reducing code duplication in the
formatters, which also makes -Ttree output clearer.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.99 2017/01/11 17:39:45 schwarze Exp $ */
a639 3

	if (ENDBODY_NOSPACE == n->end)
		outflags &= ~(MMAN_spc | MMAN_nl);
@


1.99
log
@Do text production for .Bt, .Ex, .Rv, .Ud at the validation stage
rather than in the formatters.  Use NODE_NOSRC flag for .Lb and
NODE_NOSRC and NODE_NOPRT for .St.  Results in a more rigorous
syntax tree and in 135 lines less code.

This work was triggered by a question from Abhinav Upadhyay <er dot
abhinav dot upadhyay at gmail dot com> (NetBSD) on discuss@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.98 2017/01/10 23:36:24 schwarze Exp $ */
d1519 1
a1519 1
	name = n->child ? n->child->string : meta->name;
a1529 2
	if (NULL == n->child)
		print_word(meta->name);
d1543 1
a1543 1
		if (n->child != NULL || meta->name != NULL)
@


1.98
log
@Use new NODE_NOSRC and NODE_NOPRT flags for .Bx and .At.
More rigorous AST and 40 lines less code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.97 2017/01/10 21:54:34 schwarze Exp $ */
a102 1
static	int	  pre_rv(DECL_ARGS);
a108 1
static	int	  pre_ux(DECL_ARGS);
d156 1
a156 1
	{ NULL, pre_rv, NULL, NULL, NULL }, /* Rv */
d222 1
a222 1
	{ NULL, pre_ux, NULL, "is currently in beta test.", NULL }, /* Bt */
d225 1
a225 1
	{ NULL, pre_ux, NULL, "currently under development.", NULL }, /* Ud */
d599 3
a601 1
		if (outflags & MMAN_Sm && ! (n->flags & NODE_DELIMC))
d604 3
a606 1
		if (outflags & MMAN_Sm && ! (n->flags & NODE_DELIMO))
a686 2
	struct roff_node *nch;

d688 1
a688 27

	print_word("The");

	for (nch = n->child; nch != NULL; nch = nch->next) {
		font_push('B');
		print_word(nch->string);
		font_pop();

		if (nch->next == NULL)
			continue;

		if (nch->prev != NULL || nch->next->next != NULL) {
			outflags &= ~MMAN_spc;
			print_word(",");
		}
		if (nch->next->next == NULL)
			print_word("and");
	}

	if (n->child != NULL && n->child->next != NULL)
		print_word("utilities exit\\~0");
	else
		print_word("utility exits\\~0");

	print_word("on success, and\\~>0 if an error occurs.");
	outflags |= MMAN_nl;
	return 0;
a1599 51
pre_rv(DECL_ARGS)
{
	struct roff_node *nch;

	outflags |= MMAN_br | MMAN_nl;

	if (n->child != NULL) {
		print_word("The");

		for (nch = n->child; nch != NULL; nch = nch->next) {
			font_push('B');
			print_word(nch->string);
			font_pop();

			outflags &= ~MMAN_spc;
			print_word("()");

			if (nch->next == NULL)
				continue;

			if (nch->prev != NULL || nch->next->next != NULL) {
				outflags &= ~MMAN_spc;
				print_word(",");
			}
			if (nch->next->next == NULL)
				print_word("and");
		}

		if (n->child != NULL && n->child->next != NULL)
			print_word("functions return");
		else
			print_word("function returns");

		print_word("the value\\~0 if successful;");
	} else
		print_word("Upon successful completion, "
		    "the value\\~0 is returned;");

	print_word("otherwise the value\\~\\-1 is returned"
	    " and the global variable");

	font_push('I');
	print_word("errno");
	font_pop();

	print_word("is set to indicate the error.");
	outflags |= MMAN_nl;
	return 0;
}

static int
a1693 13
}

static int
pre_ux(DECL_ARGS)
{

	print_word(manacts[n->tok].prefix);
	if (NULL == n->child)
		return 0;
	outflags &= ~MMAN_spc;
	print_word("\\ ");
	outflags &= ~MMAN_spc;
	return 1;
@


1.97
log
@For the .Ux/.Ox family of macros, do text production at the validation
stage rather than in each and every individual formatter, using the
new NODE_NOSRC flag.  More rigorous and also ten lines less code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.96 2017/01/10 13:46:53 schwarze Exp $ */
a79 1
static	int	  pre_bx(DECL_ARGS);
d183 1
a183 1
	{ NULL, pre_bx, NULL, NULL, NULL }, /* Bx */
a1049 20
	return 0;
}

static int
pre_bx(DECL_ARGS)
{

	n = n->child;
	if (n) {
		print_word(n->string);
		outflags &= ~MMAN_spc;
		n = n->next;
	}
	print_word("BSD");
	if (NULL == n)
		return 0;
	outflags &= ~MMAN_spc;
	print_word("-");
	outflags &= ~MMAN_spc;
	print_word(n->string);
@


1.96
log
@unify names of AST node flags; no change of cpp output
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.95 2017/01/10 12:54:27 schwarze Exp $ */
d183 1
a183 1
	{ NULL, pre_ux, NULL, "BSD/OS", NULL }, /* Bsx */
d193 1
a193 1
	{ NULL, pre_ux, NULL, "FreeBSD", NULL }, /* Fx */
d197 2
a198 2
	{ NULL, pre_ux, NULL, "NetBSD", NULL }, /* Nx */
	{ NULL, pre_ux, NULL, "OpenBSD", NULL }, /* Ox */
d216 1
a216 1
	{ NULL, pre_ux, NULL, "UNIX", NULL }, /* Ux */
d239 1
a239 1
	{ NULL, pre_ux, NULL, "DragonFly", NULL }, /* Dx */
@


1.95
log
@Introduce flags NODE_NOSRC and NODE_NOPRT for AST nodes.
Use them to mark generated nodes and nodes that shall not produce output.
Let -Ttree output mode display these new flags.
Use NODE_NOSRC for .Ar, .Mt, and .Pa default arguments.
Use NODE_NOPRT for .Dd, .Dt, and .Os.

These will help to make handling of text production macros more rigorous.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.94 2016/01/08 17:48:04 schwarze Exp $ */
d583 1
a583 1
	if (MMAN_spc & outflags && MDOC_LINE & n->flags)
d589 1
a589 1
	n->flags &= ~MDOC_ENDED;
d602 1
a602 1
		if (outflags & MMAN_Sm && ! (n->flags & MDOC_DELIMC))
d605 1
a605 1
		if (outflags & MMAN_Sm && ! (n->flags & MDOC_DELIMO))
d631 1
a631 1
	if (MDOC_ENDED & n->flags)
d638 1
a638 1
		n->body->flags |= MDOC_ENDED;
d809 1
a809 1
	if (NULL == n->prev || ! (MDOC_SYNPRETTY & n->flags))
d1177 1
a1177 1
		if (am_Fa || MDOC_SYNPRETTY & n->flags)
d1231 1
a1231 1
	    n->next->flags & MDOC_LINE))
d1245 1
a1245 1
	if (MDOC_SYNPRETTY & n->flags)
d1266 1
a1266 1
	if (MDOC_SYNPRETTY & n->flags) {
d1283 1
a1283 1
		if (MDOC_SYNPRETTY & n->flags)
d1328 1
a1328 1
	if (MDOC_SYNPRETTY & n->flags) {
d1345 1
a1345 1
	if (MDOC_SYNPRETTY & n->flags) {
d1620 1
a1620 1
	if ( ! (n->next == NULL || n->next->flags & MDOC_LINE))
d1752 1
a1752 1
	if (MDOC_SYNPRETTY & n->flags) {
d1771 1
a1771 1
	if (n->flags & MDOC_SYNPRETTY && n->type != ROFFT_BODY)
@


1.94
log
@Delete the redundant "nchild" member of struct roff_node, replacing
most uses by one, a few by two pointer checks, and only one by a
tiny loop - not only making data smaller, but code shorter as well.

This gets rid of an implicit invariant that confused both static
analysis tools and human auditors.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.93 2015/10/12 00:07:27 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2011-2016 Ingo Schwarze <schwarze@@openbsd.org>
d575 3
@


1.93
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.92 2015/10/06 18:30:44 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2011-2015 Ingo Schwarze <schwarze@@openbsd.org>
d611 2
a612 1
		if (cond && act->pre && (n->end == ENDBODY_NOT || n->nchild))
d683 1
a683 1
	int	 nchild;
d689 1
a689 2
	nchild = n->nchild;
	for (n = n->child; n; n = n->next) {
d691 1
a691 1
		print_word(n->string);
d694 1
a694 1
		if (n->next == NULL)
d697 1
a697 1
		if (nchild > 2) {
d701 1
a701 1
		if (n->next->next == NULL)
d705 1
a705 1
	if (nchild > 1)
d874 1
a874 1
	print_word(n->nchild == 1 &&
d885 1
a885 1
	print_word(n->nchild == 1 &&
d1001 1
a1001 1
	if (n->nchild) {
d1017 1
a1017 1
		if (n->nchild)
d1215 1
a1215 1
	if (n->nchild)
d1225 1
a1225 1
	if ( ! (n->nchild ||
d1646 1
a1646 1
	int	 nchild;
d1650 1
a1650 2
	nchild = n->nchild;
	if (nchild > 0) {
d1653 1
a1653 1
		for (n = n->child; n; n = n->next) {
d1655 1
a1655 1
			print_word(n->string);
d1661 1
a1661 1
			if (n->next == NULL)
d1664 1
a1664 1
			if (nchild > 2) {
d1668 1
a1668 1
			if (n->next->next == NULL)
d1672 1
a1672 1
		if (nchild > 1)
@


1.92
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.91 2015/04/18 17:50:02 schwarze Exp $ */
a818 1
		/* FALLTHROUGH */
a819 1
		/* FALLTHROUGH */
a820 1
		/* FALLTHROUGH */
a821 1
		/* FALLTHROUGH */
a1371 1
			/* FALLTHROUGH */
a1372 1
			/* FALLTHROUGH */
a1380 1
			/* FALLTHROUGH */
a1381 1
			/* FALLTHROUGH */
a1470 1
			/* FALLTHROUGH */
a1471 1
			/* FALLTHROUGH */
a1472 1
			/* FALLTHROUGH */
a1473 1
			/* FALLTHROUGH */
a1474 1
			/* FALLTHROUGH */
a1587 1
		/* FALLTHROUGH */
@


1.91
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.90 2015/04/18 16:04:40 schwarze Exp $ */
d644 1
a644 1
	return(n->type == ROFFT_HEAD);
d651 1
a651 1
	return(n->type == ROFFT_BODY);
d661 1
a661 1
		return(1);
d664 1
a664 1
	return(1);
d712 1
a712 1
	return(0);
d750 1
a750 1
	return(1);
d781 1
a781 1
	return(1);
d849 1
a849 1
		return(0);
d853 1
a853 1
		return(0);
d860 1
a860 1
		return(1);
d871 1
a871 1
	return(0);
d881 1
a881 1
	return(1);
d905 1
a905 1
	return(1);
d929 1
a929 1
		return(1);
d933 1
a933 1
		return(0);
d946 1
a946 1
	return(1);
d963 1
a963 1
		return(1);
d966 1
a966 1
		return(1);
d968 1
a968 1
		return(0);
d998 1
a998 1
		return(1);
d1002 1
a1002 1
		return(1);
d1012 1
a1012 1
	return(1);
d1052 1
a1052 1
	return(0);
d1067 1
a1067 1
		return(0);
d1072 1
a1072 1
	return(0);
d1080 1
a1080 1
	return(1);
d1099 1
a1099 1
	return(1);
d1108 1
a1108 1
		return(1);
d1112 1
a1112 1
	return(1);
d1142 1
a1142 1
	return(1);
d1185 1
a1185 1
	return(0);
d1202 1
a1202 1
	return(1);
d1221 1
a1221 1
	return(1);
d1244 1
a1244 1
		return(0);
d1259 1
a1259 1
	return(0);
d1283 1
a1283 1
			return(0);
d1296 1
a1296 1
	return(1);
d1322 1
a1322 1
	return(1);
d1339 1
a1339 1
	return(1);
d1374 1
a1374 1
			return(0);
d1385 1
a1385 1
			return(1);
d1401 1
a1401 1
			return(0);
d1408 1
a1408 1
			return(0);
d1413 1
a1413 1
			return(1);
d1418 1
a1418 1
			return(1);
d1420 1
a1420 1
			return(1);
d1425 1
a1425 1
	return(1);
d1531 1
a1531 1
		return(0);
d1546 1
a1546 1
	return(0);
d1554 1
a1554 1
	return(1);
d1562 1
a1562 1
	return(1);
d1575 1
a1575 1
		return(1);
d1578 1
a1578 1
		return(0);
d1589 1
a1589 1
	return(1);
d1616 1
a1616 1
	return(1);
d1624 1
a1624 1
	return(0);
d1643 1
a1643 1
	return(0);
d1654 1
a1654 1
	return(1);
d1706 1
a1706 1
	return(0);
d1713 1
a1713 1
	return(0);
d1730 1
a1730 1
	return(0);
d1742 1
a1742 1
	return(1);
d1757 1
a1757 1
	return(1);
d1768 1
a1768 1
			return(1);
d1772 1
a1772 1
			return(0);
d1776 1
a1776 1
	return(1);
d1794 1
a1794 1
		return(0);
d1798 1
a1798 1
		return(0);
d1803 1
a1803 1
	return(0);
d1812 1
a1812 1
		return(0);
d1816 1
a1816 1
	return(1);
@


1.90
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.89 2015/04/02 23:47:43 schwarze Exp $ */
a547 1
	const struct roff_meta *meta;
a549 3
	meta = mdoc_meta(mdoc);
	n = mdoc_node(mdoc)->child;

d551 3
a553 3
	    meta->title,
	    (meta->msec == NULL ? "" : meta->msec),
	    meta->date, meta->os, meta->vol);
d564 2
a565 4
	while (n != NULL) {
		print_node(meta, n);
		n = n->next;
	}
@


1.89
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.88 2015/04/02 22:06:17 schwarze Exp $ */
d533 1
a533 1
man_man(void *arg, const struct man *man)
d546 1
a546 1
man_mdoc(void *arg, const struct mdoc *mdoc)
@


1.88
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.87 2015/04/02 21:03:18 schwarze Exp $ */
d31 1
a31 1
#define	DECL_ARGS const struct mdoc_meta *meta, struct roff_node *n
d548 1
a548 1
	const struct mdoc_meta *meta;
@


1.87
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.86 2015/02/17 20:33:44 schwarze Exp $ */
d31 1
a31 1
#define	DECL_ARGS const struct mdoc_meta *meta, struct mdoc_node *n
d109 1
a109 1
static	void	  pre_syn(const struct mdoc_node *);
d118 1
a118 1
			const struct mdoc_node *);
d469 1
a469 1
print_width(const struct mdoc_bl *bl, const struct mdoc_node *child)
d549 1
a549 1
	struct mdoc_node *n;
d579 1
a579 1
	struct mdoc_node	*sub;
d809 1
a809 1
pre_syn(const struct mdoc_node *n)
d1367 1
a1367 1
	const struct mdoc_node *bln;
d1464 1
a1464 1
	const struct mdoc_node *bln;
d1534 1
a1534 1
	const struct mdoc_node *link, *descr;
@


1.86
log
@Render \(lq and \(rq as '"' in -Tascii mode but leave the rendering
of .Do/.Dc, .Dq, .Lb, and .St untouched.
Reduces groff-mandoc differences in base by about 7%.
Reminded of the issue by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.85 2015/02/12 12:20:47 schwarze Exp $ */
d23 1
d25 3
a27 1
#include "mandoc_aux.h"
a28 2
#include "man.h"
#include "mdoc.h"
d494 1
a494 1
	else if (child != NULL && child->type == MDOC_TEXT)
d594 1
a594 1
	if (MDOC_TEXT == n->type) {
d650 1
a650 1
	return(MDOC_HEAD == n->type);
d657 1
a657 1
	return(MDOC_BODY == n->type);
d780 1
a780 1
	if (MDOC_HEAD == n->type) {
d797 1
a797 1
	if (MDOC_HEAD != n->type)
d934 1
a934 1
	case MDOC_BLOCK:
d936 1
a936 1
	case MDOC_BODY:
d959 1
a959 1
	if (MDOC_BODY == n->type)
d968 1
a968 1
	case MDOC_BLOCK:
d970 1
a970 1
	case MDOC_BODY:
d982 1
a982 1
	if (MDOC_BODY == n->type)
d1237 1
a1237 1
	    n->next->type == MDOC_TEXT ||
d1284 1
a1284 1
	case MDOC_BLOCK:
d1287 1
a1287 1
	case MDOC_HEAD:
d1294 1
a1294 1
	case MDOC_BODY:
d1310 1
a1310 1
	case MDOC_HEAD:
d1314 1
a1314 1
	case MDOC_BODY:
d1370 1
a1370 1
	case MDOC_HEAD:
d1469 1
a1469 1
	case MDOC_HEAD:
d1482 1
a1482 1
	case MDOC_BODY:
d1576 1
a1576 1
	if (MDOC_BLOCK == n->type) {
d1580 1
a1580 1
	if (MDOC_ELEM != n->type && MDOC_HEAD != n->type)
d1585 1
a1585 1
	if (MDOC_HEAD == n->type) {
d1603 1
a1603 1
	case MDOC_BLOCK:
d1606 1
a1606 1
	case MDOC_HEAD:
d1608 1
a1608 1
	case MDOC_ELEM:
d1772 1
a1772 1
		case MDOC_BLOCK:
d1775 1
a1775 1
		case MDOC_BODY:
d1789 1
a1789 1
	if (MDOC_SYNPRETTY & n->flags && MDOC_BODY != n->type)
@


1.85
log
@Delete the mdoc_node.pending pointer and the function calculating
it, make_pending(), which was the most difficult function of the
whole mdoc(7) parser.  After almost five years of maintaining this
hellhole, i just noticed the pointer isn't needed after all.

Blocks are always rewound in the reverse order they were opened;
that even holds for broken blocks.  Consequently, it is sufficient
to just mark broken blogs with the flag MDOC_BROKEN and breaking
blocks with the flag MDOC_ENDED.  When rewinding, instead of iterating
the pending pointers, just iterate from each broken block to its
parents, rewinding all that are MDOC_ENDED and stopping after
processing the first ancestor that it not MDOC_BROKEN.  For ENDBODY
markers, use the mdoc_node.body pointer in place of the former
mdoc_node.pending.

This also fixes an assertion failure found by jsg@@ with afl,
test case #467 (Bo Bl It Bd Bc It), where (surprise surprise)
the pending pointer got corrupted.

Improved functionality, minus one function, minus one struct field,
minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.84 2015/02/11 14:14:53 schwarze Exp $ */
d186 2
a187 2
	{ cond_body, pre_enc, post_enc, "\\(lq", "\\(rq" }, /* Do */
	{ cond_body, pre_enc, post_enc, "\\(lq", "\\(rq" }, /* Dq */
@


1.84
log
@do not access a NULL pointer if an .Eo block lacks a tail;
found by jsg@@ with afl, test case #16
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.83 2015/02/06 03:31:11 schwarze Exp $ */
d30 1
a30 2
#define	DECL_ARGS const struct mdoc_meta *meta, \
		  const struct mdoc_node *n
d548 1
a548 1
	const struct mdoc_node *n;
d551 1
a551 1
	n = mdoc_node(mdoc);
d567 4
a570 1
	print_node(meta, n);
a576 1
	const struct mdoc_node	*sub;
d578 1
d591 1
d639 1
a639 1
		n->pending->flags |= MDOC_ENDED;
@


1.83
log
@better handle .Fo and .Fd without argument
better handle .Fo with more than one argument
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.82 2015/02/01 23:10:15 schwarze Exp $ */
d1141 2
a1142 3
	    n->parent->head->child != NULL &&
	    (n->parent->body->child != NULL ||
	     n->parent->tail->child != NULL))
@


1.82
log
@fix .Eo/.Ec spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.81 2015/01/28 17:30:37 schwarze Exp $ */
d1285 2
d1292 1
a1292 1
		outflags &= ~MMAN_spc;
d1308 2
a1309 1
		font_pop();
@


1.81
log
@* Polish tbl(7) error reporting.
* Do not print out macro names in tbl(7) data blocks.
* Like with GNU tbl, let empty tables cause a blank line.
* Avoid producing empty tables in -Tman.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.80 2015/01/23 14:19:52 schwarze Exp $ */
d1135 10
a1144 1
	outflags &= ~(MMAN_spc | MMAN_nl);
d1151 6
d1158 4
a1161 1
	if (n->end != ENDBODY_SPACE)
d1163 4
@


1.80
log
@Let .Aq/.Ao/.Ac print "<>" instead of the normal "\(la\(ra"
when the only child is .Mt, not when the preceding node is .An,
to improve robustness.  Triggered by a question from Svyatoslav
Mishyn <juef at openmailbox dot org> (Crux Linux).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.79 2014/12/24 23:31:59 schwarze Exp $ */
d1007 6
a1012 4
	print_line(".TS", MMAN_nl);
	for (icol = 0; icol < n->norm->Bl.ncols; icol++)
		print_word("l");
	print_word(".");
d1023 2
a1024 1
		print_line(".TE", 0);
@


1.79
log
@Support negative indentations for mdoc(7) displays and lists.
Not exactly recommended for use, rather for groff compatibility.
While here, introduce similar SHRT_MAX limits as in man(7),
fixing a few cases of infinite output found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.78 2014/12/23 13:48:15 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2011, 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d880 2
a881 2
	print_word(n->parent->prev != NULL &&
	    n->parent->prev->tok == MDOC_An ?  "<" : "\\(la");
d891 2
a892 2
	print_word(n->parent->prev != NULL &&
	    n->parent->prev->tok == MDOC_An ?  ">" : "\\(ra");
@


1.78
log
@support negative horizontal widths in man(7);
minus twenty lines of code in spite of enhanced functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.77 2014/12/23 10:09:23 schwarze Exp $ */
d117 2
a118 2
static	void	  print_width(const char *,
				const struct mdoc_node *, size_t);
d266 1
a266 1
static	size_t		Bl_stack[BL_STACK_MAX];  /* offsets [chars] */
d424 1
a424 1
	size_t		  sz;
a435 2
		if (su.scale < 0.0)
			su.scale = 0.0;
d460 1
a460 1
	(void)snprintf(buf, sizeof(buf), "%zun", sz);
d469 1
a469 1
print_width(const char *v, const struct mdoc_node *child, size_t defsz)
d473 1
a473 2
	size_t		  sz, chsz;
	int		  numeric, remain;
d478 4
a481 6
	/* Convert v into a number (of characters). */
	if (NULL == v)
		sz = defsz;
	else if (a2roffsu(v, &su, SCALE_MAX) > 1) {
		if (su.scale < 0.0)
			su.scale = 0.0;
d489 1
a489 1
		sz = strlen(v);
d492 6
a497 2
	chsz = (NULL != child && MDOC_TEXT == child->type) ?
	    strlen(child->string) : 0;
d509 1
a509 1
	if (defsz && chsz > sz)
d516 1
a516 1
		(void)snprintf(buf, sizeof(buf), "%zun", sz + 2);
d519 1
a519 1
		print_word(v);
d528 1
a528 1
	(void)snprintf(buf, sizeof(buf), "%d.", ++*count);
d1366 1
a1366 1
			print_width(bln->norm->Bl.width, NULL, 0);
d1378 1
a1378 1
			print_width(bln->norm->Bl.width, NULL, 0);
d1385 1
a1385 1
			print_width(bln->norm->Bl.width, n->child, 6);
d1390 1
a1390 1
			print_width(bln->norm->Bl.width, n->child, 0);
d1422 1
a1422 1
	(void)snprintf(buf, sizeof(buf), "%zun",
@


1.77
log
@fix typo in previous
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.76 2014/12/23 09:31:17 schwarze Exp $ */
d436 2
d485 2
@


1.76
log
@some scaling unit fixes:
- .sp with an invalid argument is .sp 1v, not .sp 0v
- in man(1), trailing garbage doesn't make scaling units invalid
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.75 2014/11/30 05:28:00 schwarze Exp $ */
d435 1
a435 1
	else if (a2roffsu(v, &su, SCALE_EN) < 2) {
d482 1
a482 1
	else if (a2roffsu(v, &su, SCALE_MAX) < 2) {
@


1.75
log
@Multiple fixes with respect to .Pf:
* The first argument of .Pf is not parsed.
* Normal delimiter handling does not apply to the first argument of .Pf.
* Warn if nothing follows a prefix (inspired by groff_mdoc(7)).
* In that case, do not suppress spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.74 2014/11/27 22:27:40 schwarze Exp $ */
d435 1
a435 1
	else if (a2roffsu(v, &su, SCALE_MAX)) {
d482 1
a482 1
	else if (a2roffsu(v, &su, SCALE_MAX)) {
@


1.74
log
@Multiple fixes with respect to .Eo:
1. Correctly parse stray .Ec without preceding .Eo,
avoiding an assertion violation found by jsg@@ with afl.
2. Correctly parse .Ec arguments when breaking another block.
3. Correct spacing around closing delimiter when breaking another block.
4. Sync some related formatting control from -Tascii to -Thtml.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.73 2014/11/27 16:20:27 schwarze Exp $ */
d1603 2
a1604 1
	outflags &= ~MMAN_spc;
@


1.73
log
@Fix the obsolete .Db (toggle debug mode) macro to ignore its arguments
and not trigger an assertion when there is more than one argument;
the latter found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.72 2014/11/19 21:59:19 schwarze Exp $ */
d86 1
d192 1
a192 1
	{ NULL, NULL, post_eo, NULL, NULL }, /* Eo */
d609 2
a610 2
		cond = NULL == act->cond || (*act->cond)(meta, n);
		if (cond && act->pre && ENDBODY_NOT == n->end)
d1125 8
d1137 1
a1137 1
	if (MDOC_HEAD == n->type || MDOC_BODY == n->type)
@


1.72
log
@Let .Ao and .Aq render as "<>" after .An and as "\(la\(ra" elsewhere,
just like groff; minibug noticed by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.71 2014/11/17 06:44:35 schwarze Exp $ */
d85 1
a85 1
static	int	  pre_es(DECL_ARGS);
d184 1
a184 1
	{ NULL, NULL, NULL, NULL, NULL }, /* Db */
d236 1
a236 1
	{ NULL, pre_es, NULL, NULL, NULL }, /* Es */
a1132 7
pre_es(DECL_ARGS)
{

	return(0);
}

static int
d1668 7
@


1.71
log
@Multiple fixes with respect to in-line macros:
* .No selects the default font; relevant e.g. in .Bf blocks
* no need to force empty .Li elements
* closing delimiters as leading macro arguments do not suppress space
* opening delimiters at the end of a macro line do not suppress space
* correctly handle delimiter spacing in -Tman
As a side effect, these fixes let mandoc warn about empty .No macros
as requested by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.70 2014/11/06 22:27:52 schwarze Exp $ */
d47 1
d74 1
d175 2
a176 2
	{ cond_body, pre_enc, post_enc, "<", ">" }, /* Ao */
	{ cond_body, pre_enc, post_enc, "<", ">" }, /* Aq */
d870 19
@


1.70
log
@Let -Tascii \(bu (bullet) output agree with groff;
this is now possible because -Tps now handles backspace overstriking.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_man.c,v 1.69 2014/10/30 20:05:33 schwarze Exp $ */
d595 2
d598 2
@


1.69
log
@Major bugsquashing with respect to -offset and -width:
1. Support specifying the .Bd and .Bl -offset as a macro default width;
while here, simplify the code handling the same for .Bl -width.
2. Correct handling of .Bl -offset arguments:  unlike .Bd -offset, the
arguments "left", "indent", and "indent-two" have no special meaning.
3. Fix the scaling of string length -offset and -width arguments in -Thtml.
Triggered by an incomplete documentation patch from bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1341 1
a1341 1
				print_word("o");
@


1.68
log
@Right after .Fl, a middle delimiter triggers an empty scope,
just like a closing delimiter.  This didn't work in groff-1.15,
but it now works in groff-1.22.

After being closed by delimiters, .Nm scopes do not reopen.

Do not suppress white space after .Fl if the next node is a text node
on the same input line; that can happen for middle delimiters.

Fixing an issue reported by jmc@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.67 2014/08/08 16:17:09 schwarze Exp $ */
d17 2
d113 1
a113 1
static	void	  print_offs(const char *);
d417 1
a417 1
print_offs(const char *v)
d426 1
a426 1
	if (NULL == v || '\0' == *v || 0 == strcmp(v, "left"))
d428 1
a428 1
	else if (0 == strcmp(v, "indent"))
d430 1
a430 1
	else if (0 == strcmp(v, "indent-two"))
d877 1
a877 1
	print_offs(n->norm->Bd.offs);
d964 1
a964 1
		print_offs(n->norm->Bl.offs);
d1049 1
a1049 1
	print_offs("6n");
@


1.67
log
@Bring the handling of defective prologues even closer to groff,
in particular relaxing the distinction between prologue and body
and further improving messages.
* The last .Dd wins and the last .Os wins, even in the body.
* The last .Dt before the first body macro wins.
* Missing title in .Dt defaults to UNTITLED.  Warn about it.
* Missing section in .Dt does not default to 1.  But warn about it.
* Do not warn multiple times about the same mdoc(7) prologue macro.
* Warn about missing .Os.
* Incomplete .TH defaults to empty strings.  Warn about it.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.66 2014/08/08 15:10:15 schwarze Exp $ */
d1165 2
a1166 1
	outflags &= ~MMAN_spc;
d1175 4
a1178 2
	if (0 == n->nchild && NULL != n->next &&
			n->next->line == n->line)
@


1.66
log
@Various improvements related to .Ex and .Rv:
* let .Nm fall back to the empty string, not to UNKNOWN
* never let .Rv copy an argument from .Nm
* avoid spurious \fR after empty .Nm in -Tman
* correct handling of .Ex and .Rv in -Tman
* correct the wording of the output for .Rv without arguments
* use non-breaking spaces in .Ex and .Rv output where required
* split MANDOCERR_NONAME into a warning for .Ex and an error for .Nm
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.65 2014/07/04 16:11:41 schwarze Exp $ */
d547 3
a549 2
	    meta->title, meta->msec, meta->date,
	    meta->os, meta->vol);
@


1.65
log
@Clean up messages regarding excess arguments:
* Downgrade ".Bf -emphasis Em" from FATAL to WARNING.
* Mention the macros, the arguments, and the fallbacks.
* Hierarchical naming.
Also fix the handling of excess .It head arguments in -Tman.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.64 2014/07/02 19:54:39 schwarze Exp $ */
d82 1
d99 1
d140 1
a140 3
	{ NULL, pre_enc, post_enc, "The \\fB",
	    "\\fP\nutility exits 0 on success, and >0 if an error occurs."
	    }, /* Ex */
d154 1
a154 5
	{ NULL, pre_enc, post_enc, "The \\fB",
		"\\fP\nfunction returns the value 0 if successful;\n"
		"otherwise the value -1 is returned and the global\n"
		"variable \\fIerrno\\fP is set to indicate the error."
		}, /* Rv */
d668 36
d1542 2
a1543 1
		font_pop();
d1593 52
@


1.64
log
@When .Sm is called without an argument, groff toggles the spacing mode,
so let us do the same for compatibility.  Using this feature is of
course not recommended except in manual page obfuscation contests.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.63 2014/07/02 03:47:07 schwarze Exp $ */
d1307 2
a1308 1
			break;
d1314 2
a1315 1
			break;
d1319 2
a1320 1
			break;
a1328 1
		outflags |= MMAN_nl;
@


1.63
log
@Implement the obsolete macros .En .Es .Fr .Ot for backward compatibility,
since this is hardly more complicated than explicitly ignoring them
as we did in the past.  Of course, do not use them!
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.62 2014/04/20 19:39:35 schwarze Exp $ */
d1564 4
a1567 3
	assert(n->child && MDOC_TEXT == n->child->type);
	if (0 == strcmp("on", n->child->string))
		outflags |= MMAN_Sm | MMAN_spc;
d1570 4
@


1.62
log
@make sure static buffers for snprintf(3) are large enough
and cast snprintf return value to (void) where they are
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.61 2014/04/20 16:44:44 schwarze Exp $ */
d50 1
d78 1
d81 1
d152 1
a152 1
	{ NULL, NULL, NULL, NULL, NULL }, /* Ot */
d226 1
a226 1
	{ NULL, NULL, NULL, NULL, NULL }, /* Fr */
d236 2
a237 2
	{ NULL, NULL, NULL, NULL, NULL }, /* Es */
	{ NULL, NULL, NULL, NULL, NULL }, /* En */
d1037 27
d1070 7
@


1.61
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.60 2014/03/30 19:47:32 schwarze Exp $ */
d456 1
a456 1
	snprintf(buf, sizeof(buf), "%zun", sz);
d509 1
a509 1
		snprintf(buf, sizeof(buf), "%zun", sz + 2);
d519 1
a519 1
	char		  buf[12];
d521 1
a521 1
	snprintf(buf, sizeof(buf), "%d.", ++*count);
d1315 2
a1316 1
	snprintf(buf, sizeof(buf), "%zun", Bl_stack[Bl_stack_len - 1]);
@


1.60
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.59 2014/03/21 22:17:01 schwarze Exp $ */
d273 1
d281 1
a281 1
				fontqueue.size);
d307 1
a307 1
		/* 
d362 1
a362 1
		case (ASCII_NBRSP):
d365 1
a365 1
		case (ASCII_HYPH):
d368 1
a368 1
		case (ASCII_BREAK):
d371 1
a371 1
		case (' '):
d490 1
a490 1
			strlen(child->string) : 0;
d548 2
a549 2
			meta->title, meta->msec, meta->date,
			meta->os, meta->vol);
d587 2
a588 2
		if (MMAN_nl & outflags && ('.' == *n->string || 
					'\'' == *n->string)) {
d605 1
a605 1
	/* 
d697 2
a698 2
        if (n->parent && MDOC_Rs == n->parent->tok &&
                        n->parent->norm->Rs.quote_T) {
d711 2
a712 2
        if (n->parent && MDOC_Rs == n->parent->tok &&
                        n->parent->norm->Rs.quote_T) {
d764 3
a766 3
			MDOC_Ft != n->tok &&
			MDOC_Fo != n->tok &&
			MDOC_Fn != n->tok) {
d772 1
a772 1
	case (MDOC_Fd):
d774 1
a774 1
	case (MDOC_Fn):
d776 1
a776 1
	case (MDOC_Fo):
d778 1
a778 1
	case (MDOC_In):
d780 1
a780 1
	case (MDOC_Vt):
d783 1
a783 1
	case (MDOC_Ft):
d800 1
a800 1
	case (AUTH_split):
d804 1
a804 1
	case (AUTH_nosplit):
d863 1
a863 1
	case (MDOC_BLOCK):
d865 1
a865 1
	case (MDOC_BODY):
d871 1
a871 1
	case (FONT_Em):
d874 1
a874 1
	case (FONT_Sy):
d897 1
a897 1
	case (MDOC_BLOCK):
d899 1
a899 1
	case (MDOC_BODY):
d931 1
a931 1
	case (LIST_enum):
d934 1
a934 1
	case (LIST_column):
d953 1
a953 1
	case (LIST_column):
d956 1
a956 1
	case (LIST_enum):
d1151 1
a1151 1
	case (MDOC_BLOCK):
d1154 1
a1154 1
	case (MDOC_HEAD):
d1159 1
a1159 1
	case (MDOC_BODY):
d1175 1
a1175 1
	case (MDOC_HEAD):
d1178 1
a1178 1
	case (MDOC_BODY):
d1234 1
a1234 1
	case (MDOC_HEAD):
d1243 1
a1243 1
		case (LIST_item):
d1245 1
a1245 1
		case (LIST_inset):
d1247 1
a1247 1
		case (LIST_diag):
d1249 1
a1249 1
		case (LIST_ohang):
d1256 1
a1256 1
		case (LIST_bullet):
d1258 1
a1258 1
		case (LIST_dash):
d1260 1
a1260 1
		case (LIST_hyphen):
d1271 1
a1271 1
		case (LIST_enum):
d1277 1
a1277 1
		case (LIST_hang):
d1281 1
a1281 1
		case (LIST_tag):
d1330 1
a1330 1
	case (MDOC_HEAD):
d1332 1
a1332 1
		case (LIST_diag):
d1336 1
a1336 1
		case (LIST_ohang):
d1343 1
a1343 1
	case (MDOC_BODY):
d1345 1
a1345 1
		case (LIST_bullet):
d1347 1
a1347 1
		case (LIST_dash):
d1349 1
a1349 1
		case (LIST_hyphen):
d1351 1
a1351 1
		case (LIST_enum):
d1353 1
a1353 1
		case (LIST_hang):
d1355 1
a1355 1
		case (LIST_tag):
d1369 1
a1369 1
		case (LIST_column):
d1464 1
a1464 1
	case (MDOC_BLOCK):
d1467 1
a1467 1
	case (MDOC_HEAD):
d1469 1
a1469 1
	case (MDOC_ELEM):
d1567 1
a1567 1
		case (MDOC_BLOCK):
d1570 1
a1570 1
		case (MDOC_BODY):
@


1.59
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.58 2014/01/24 11:56:34 schwarze Exp $ */
d89 1
d241 1
d1413 8
@


1.58
log
@Improve formatting of broken blocks in -Tman,
somewhat similar to what mdoc_term.c already does for -Tascii.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.57 2014/01/22 20:58:35 schwarze Exp $ */
d22 1
d461 1
a461 1
void
d513 1
a513 1
void
@


1.57
log
@Implement the \: (optional line break) escape sequence,
documented in the Ossanna-Kernighan-Ritter troff manual
and also supported by groff.

Missing feature reported by Steffen Nurpmeso <sdaoden at gmail dot com>.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.56 2013/12/25 22:00:34 schwarze Exp $ */
d597 1
a597 1
		if (cond && act->pre)
d613 3
d618 6
d661 1
a661 1
	outflags &= ~MMAN_spc;
@


1.56
log
@Implement .Fo/.Fa/.Fc indentation and break handling for -Tman.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.55 2013/12/25 00:39:13 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d363 3
@


1.55
log
@Do not break output lines in .Fn function arguments in SYNOPSIS mode.
Following an idea from Franco Fichtner, but implemented more cleanly.
This reduces groff-mandoc-differences in base by a fantastic 7.5%.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.54 2013/12/24 22:08:23 schwarze Exp $ */
d1029 1
d1031 3
a1033 1
	if (MDOC_Fa == n->tok)
d1038 1
a1038 1
		if (MDOC_SYNPRETTY & n->flags)
d1139 2
d1153 1
a1153 1
		
@


1.54
log
@Implement SYNOPSIS .Fn indentation for -Tman.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.53 2013/12/24 20:45:21 schwarze Exp $ */
d255 1
d364 6
d377 1
d1035 2
@


1.53
log
@It turns out SYNOPSIS mode does not imply .Bk in general,
but only within .Nm blocks.  Simplify the code accordingly.
This reduces groff-mandoc differences in base by about 2%.

Triggered by research done by Franco Fichtner.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.52 2013/10/07 22:21:56 schwarze Exp $ */
d1090 3
d1113 1
a1113 1
		outflags |= MMAN_br;
@


1.52
log
@Printf size_t vars with %zu, not %ld;
from Antonio Huete Jimenez <tuxillo at quantumachine dot net>
via Franco Fichtner (both DragonFly).
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.51 2013/09/15 18:48:26 schwarze Exp $ */
d704 1
a704 2
	switch (n->type) {
	case (MDOC_HEAD):
a709 11
		break;
	case (MDOC_BODY):
		if (MDOC_Sh == n->tok) {
			if (MDOC_SYNPRETTY & n->flags)
				outflags |= MMAN_Bk;
			else
				outflags &= ~MMAN_Bk;
		}
		break;
	default:
		break;
d887 1
a887 1
	if (MDOC_BODY == n->type && ! (MDOC_SYNPRETTY & n->flags))
d1395 2
a1396 1
	if (MDOC_BLOCK == n->type)
d1398 1
d1421 12
a1432 3
	if (MDOC_ELEM != n->type && MDOC_HEAD != n->type)
		return;
	font_pop();
@


1.51
log
@Use normal line macro recognition, do not attempt to roll your own.
This fixes horizontal spacing when an Ns macro follows a block-closing
macro and the corresponding block-opening macro is not on the same line.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.50 2013/06/02 18:16:51 schwarze Exp $ */
d441 1
a441 1
	snprintf(buf, sizeof(buf), "%ldn", sz);
d494 1
a494 1
		snprintf(buf, sizeof(buf), "%ldn", sz + 2);
d1293 1
a1293 1
	snprintf(buf, sizeof(buf), "%ldn", Bl_stack[Bl_stack_len - 1]);
d1418 1
a1418 1
		printf(" %ldn", strlen(name) + 1);
@


1.50
log
@Let .Do .Dq .Ql .So .Sq generate the correct roff(7) character escape
sequences such that output modes like -Tutf8 have a chance to select
nice glyphs.  This doesn't change anything for -Tascii, and, for now,
it doesn't affect -Tps and -Tpdf either.
OK matthew@@ bentley@@; like the idea tedu@@; no opinion jmc@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.49 2013/05/29 15:40:14 schwarze Exp $ */
d552 1
a552 1
	const struct mdoc_node	*prev, *sub;
d560 1
a560 2
	prev = n->prev ? n->prev : n->parent;
	if (MMAN_spc & outflags && prev && prev->line < n->line)
@


1.49
log
@In SYNOPSIS mode, .Ek doesn't end a keep.
Found and fixed on the plane to the OpenBSD t2k13 hackathon in Toronto.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.48 2013/05/19 21:40:18 schwarze Exp $ */
d181 2
a182 2
	{ cond_body, pre_enc, post_enc, "``", "''" }, /* Do */
	{ cond_body, pre_enc, post_enc, "``", "''" }, /* Dq */
d198 1
a198 1
	{ cond_body, pre_enc, post_enc, "`", "'" }, /* Ql */
d204 2
a205 2
	{ cond_body, pre_enc, post_enc, "`", "'" }, /* So */
	{ cond_body, pre_enc, post_enc, "`", "'" }, /* Sq */
@


1.48
log
@Support .Bl -offset in -mdoc -Tman.
Issue found when Thomas Klausner <wiz at NetBSD dot org> made me
look at the manuals of his http://www.nih.at/libzip library.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.47 2013/05/19 21:05:29 schwarze Exp $ */
d900 1
a900 1
	if (MDOC_BODY == n->type)
@


1.47
log
@Move printing of the .RS macro into print_offs() such that print_offs()
takes care of printing the whole line.  This reduces code duplication -
in particular after the upcoming commit to repair .Bl -offset -
and makes print_offs() more similar to what print_width() does.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.46 2012/12/31 22:34:01 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d909 10
d951 10
a960 2
	outflags |= MMAN_PP | MMAN_nl;
	outflags &= ~(MMAN_sp | MMAN_br);
@


1.46
log
@Rewrite indentation handling for nested lists in a more systematic way
to fix multiple issues reported by Todd Miller; thanks!

Specifically,
 - avoid double indentation after .Bd inside .Bl
 - set up correct indentation after .Bl inside .Bl
 - set up correct indentation after .Dl and .D1 inside .Bl

While here, also
 - set up correct indentation *inside* .Dl and .D1 inside .Bl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.45 2012/11/19 02:14:39 schwarze Exp $ */
d407 2
d428 1
d443 1
a827 1
	print_line(".RS", MMAN_Bk_susp);
a828 1
	outflags |= MMAN_nl;
a981 1
	print_line(".RS", MMAN_Bk_susp);
a982 1
	outflags |= MMAN_nl;
@


1.45
log
@In -Tman mode, support automatic word keeps in the SYNOPSIS
just like in -Tascii mode; requested by millert@@.

While here, do not escape the blank characters terminating man(7)
macros; this is becoming more important as we use more keeps now.

Note that -Tman still does not support .nr nS.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.44 2012/11/18 19:34:12 schwarze Exp $ */
d42 1
d442 3
d473 2
a474 10
	/*
	 * If we are inside an enclosing list,
	 * preserve its indentation.
	 */
	if (Bl_stack_len && Bl_stack[Bl_stack_len - 1]) {
		print_line(".RS", MMAN_Bk_susp);
		snprintf(buf, sizeof(buf), "%ldn",
				Bl_stack[Bl_stack_len - 1]);
		print_word(buf);
	}
a832 1
	char		 buf[24];
d840 3
a842 14
	/*
	 * If we are inside an enclosing list and the current
	 * list item is not yet finished, restore the correct
	 * indentation for what remains of that item.
	 */
	if (NULL != n->parent->next &&
	    Bl_stack_len && Bl_stack[Bl_stack_len - 1]) {
		print_line(".RS", MMAN_Bk_susp);
		snprintf(buf, sizeof(buf), "%ldn",
				Bl_stack[Bl_stack_len - 1]);
		print_word(buf);
		/* Remeber to close out this .RS block later. */
		Bl_stack_post[Bl_stack_len - 1] = 1;
	}
d941 5
d980 3
a982 1
	print_line(".RS 6n", MMAN_nl);
d991 4
d1257 26
d1322 1
a1322 1
			 * after a child display.
a1328 7

			/*
			 * We are inside an enclosing list.
			 * Restore the indentation of that list.
			 */
			if (Bl_stack_len && Bl_stack[Bl_stack_len - 1])
				print_line(".RE", MMAN_nl);
@


1.44
log
@Make the generated man(7) code more portable by using .PD
instead of .sp -1v, which for example Solaris nroff handles poorly.

Problem report and patch by millert@@,
with the print_word chunk tweaked by me.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.43 2012/11/18 17:59:03 schwarze Exp $ */
d250 4
a253 3
#define	MMAN_An_split	(1 << 8)  /* author mode is "split" */
#define	MMAN_An_nosplit	(1 << 9)  /* author mode is "nosplit" */
#define	MMAN_PD		(1 << 10) /* inter-paragraph spacing disabled */
d334 2
a335 1
			if (MMAN_Bk & outflags)
d352 1
a352 1
	outflags &= ~MMAN_spc_force;
d392 2
a393 4
	} else if (! (MMAN_PD & outflags)) {
		print_line(".PD 0", 0);
		outflags |= MMAN_PD;
	}
d396 1
a396 1
	outflags |= newflags;
d474 1
a474 1
		print_line(".RS", 0);
d555 1
a555 1
	
d705 19
a723 7
	if (MDOC_HEAD != n->type)
		return(1);
	outflags |= MMAN_sp;
	print_block(manacts[n->tok].prefix, 0);
	print_word("");
	putchar('\"');
	outflags &= ~MMAN_spc;
d828 1
a828 1
	print_line(".RS", 0);
d852 1
a852 1
		print_line(".RS", 0);
@


1.43
log
@Correct indentation for lists and displays inside lists.

Inspired by a diff from millert@@, but implemented rather
differently and with slightly better functionality.
In particular, this one respects -offset and -width
arguments found in the input file.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.42 2012/11/17 00:25:20 schwarze Exp $ */
d252 1
d304 9
a312 2
			if ( ! (MMAN_sp & outflags))
				printf("\n.sp -1v");
d384 1
a384 1
	if (MMAN_sp & outflags)
d386 8
a393 2
	else
		print_line(".sp -1v", 0);
@


1.42
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.41 2012/07/29 16:31:44 millert Exp $ */
d253 5
d392 1
d400 13
a412 2
		print_word(v);
		return;
d416 7
d437 2
d455 18
d811 1
d813 1
d818 15
d1258 40
a1297 4
		if (LIST_column == bln->norm->Bl.type &&
		    NULL != n->next) {
			putchar('\t');
			outflags &= ~MMAN_spc;
@


1.41
log
@Disable hyphenation and, for nroff, disable justification which is
consistent with how mdoc behaves (and produces more readable manuals).
OK schwarze@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.40 2012/07/29 16:30:52 millert Exp $ */
d27 1
a27 1
#define	DECL_ARGS const struct mdoc_meta *m, \
d468 1
a468 1
	const struct mdoc_meta *m;
d471 1
a471 1
	m = mdoc_meta(mdoc);
d475 2
a476 1
			m->title, m->msec, m->date, m->os, m->vol);
d487 1
a487 1
	print_node(m, n);
d528 1
a528 1
		cond = NULL == act->cond || (*act->cond)(m, n);
d530 1
a530 1
			do_sub = (*act->pre)(m, n);
d540 1
a540 1
			print_node(m, sub);
d546 1
a546 1
		(*act->post)(m, n);
d637 1
a637 1
	post_percent(m, n);
d940 1
a940 1
		print_node(m, n);
d1004 1
a1004 1
	print_node(m, n);
d1012 1
a1012 1
		pre_fa(m, n);
d1058 1
a1058 1
		post_fn(m, n);
d1257 1
a1257 1
	name = n->child ? n->child->string : m->name;
d1269 1
a1269 1
		print_word(m->name);
d1401 1
a1401 1
	print_node(m, n);
d1407 1
a1407 1
	print_node(m, n);
@


1.40
log
@The '-' before the flags needs to be quoted to prevent nroff
from putting a line break between the '-' and the flag character.
OK schwarze@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.39 2012/07/29 16:29:56 millert Exp $ */
d474 1
a474 1
	printf(".TH \"%s\" \"%s\" \"%s\" \"%s\" \"%s\"",
d476 3
@


1.39
log
@Use "\\ " not "\\~" as the non-breaking space as historic nroff
doesn't support the latter.  OK schwarze@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.38 2012/07/16 10:45:28 schwarze Exp $ */
d974 1
a974 1
	print_word("-");
@


1.38
log
@Two fixes regarding -Tman .sp:
* Keep height argument on the same line (it got printed to the output).
* For .El .sp, avoid the weird .sp -1v .PP .sp output sequence.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.37 2012/07/14 09:05:58 schwarze Exp $ */
d320 1
a320 1
			if (MMAN_Bk & outflags) {
d322 1
a322 3
				putchar('~');
			} else 
				putchar(' ');
d342 1
a342 1
			printf("\\~");
d1416 1
a1416 1
	print_word("\\~");
@


1.37
log
@In -Tman .Bl -compact, skip the blank line only before the first item
of the first list in a section, not before every item of the first list.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.36 2012/07/13 23:56:35 schwarze Exp $ */
d1341 5
a1345 1
	print_line(".sp", MMAN_nl);
@


1.36
log
@Adjust -Tman SYNOPSIS .Nm indentation using .HP; requested by millert@@.
There are still lots of ugly line breaks, to be fixed later.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.35 2012/07/13 20:42:59 schwarze Exp $ */
d1115 2
a1116 1
		    NULL == bln->parent->prev)
@


1.35
log
@If the tag in .Bl -tag .It would leave exactly one blank before the
body of the item, mdoc(7) breaks the line, whereas the .TP used to
translate this to man(7) does not.  Thus, insert an explicit roff(7)
line break in this place.
To be able to correctly count the characters, do not pass font escapes
an the like through print_word().
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.34 2012/07/13 14:15:50 schwarze Exp $ */
d1248 1
d1254 2
a1255 1
	if (NULL == n->child && NULL == m->name)
d1257 7
@


1.34
log
@In -man -Tascii, support .sp with negative argument.
In -mdoc -Tman, improve the framework to control vertical spacing.
Use both to support .Bl -compact (surprisingly hard to get right).
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.33 2012/07/12 08:53:45 schwarze Exp $ */
d253 2
d271 2
a272 1
	print_word("\\f");
d284 2
a285 1
	print_word("\\f");
d308 4
a311 1
	} else if (MMAN_spc & outflags && '\0' != s[0])
d318 1
a318 1
		if (MMAN_spc_force & outflags ||
d325 2
d328 1
d334 2
a335 2
	if (MMAN_Sm & outflags &&
	    (('(' != s[0] && '[' != s[0]) || '\0' != s[1]))
d353 2
d411 1
d413 2
a414 4
	/* XXX Rough estimation, might have multiple parts. */
	chsz = (NULL != child && MDOC_TEXT == child->type) ?
			strlen(child->string) : 0;

d421 2
a422 6
			if (chsz)
				print_block(".HP", 0);
			else
				print_block(".TP", 0);
			print_word(v);
			return;
d427 5
a431 1
	if (chsz > sz)
d433 1
a433 1
	else
d435 8
a442 2
	snprintf(buf, sizeof(buf), "%ldn", sz + 2);
	print_word(buf);
d515 2
a516 1
			print_word("\\&");
d616 2
a617 1
		print_word("\"");
d631 2
a632 1
		print_word("\"");
d649 2
a650 1
	print_word("\"");
d665 2
a666 1
	print_word("\"");
d1138 1
d1149 1
d1155 1
d1158 4
a1161 2
			print_width(bln->norm->Bl.width, NULL, 8);
			break;
@


1.33
log
@Do not crash in -Tman on:
* .Fn with exactly one argument
* .Bl -hang without a -width
Now all 3776 base manuals build without crashing.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.32 2012/07/11 23:45:25 schwarze Exp $ */
d101 2
d242 10
a251 9
#define	MMAN_spc	(1 << 0)
#define	MMAN_spc_force	(1 << 1)
#define	MMAN_nl		(1 << 2)
#define	MMAN_br		(1 << 3)
#define	MMAN_sp		(1 << 4)
#define	MMAN_Sm		(1 << 5)
#define	MMAN_Bk		(1 << 6)
#define	MMAN_An_split	(1 << 7)
#define	MMAN_An_nosplit	(1 << 8)
d289 1
a289 1
	if ((MMAN_sp | MMAN_br | MMAN_nl) & outflags) {
d293 5
a297 1
		if (MMAN_sp & outflags)
d303 1
a303 1
		outflags &= ~(MMAN_sp|MMAN_br|MMAN_nl|MMAN_spc);
d347 24
d411 1
a411 1
				print_word(".HP");
d413 1
a413 1
				print_word(".TP");
d421 1
a421 1
		print_word(".HP");
d423 1
a423 1
		print_word(".TP");
d627 2
a628 2
	outflags |= MMAN_nl;
	print_word(manacts[n->tok].prefix);
d727 6
a732 1
	if (0 == n->norm->Bd.comp)
d734 1
a734 7
	if (DISP_unfilled == n->norm->Bd.type ||
	    DISP_literal  == n->norm->Bd.type) {
		outflags |= MMAN_nl;
		print_word(".nf");
	}
	outflags |= MMAN_nl;
	print_word(".RS");
d744 1
a744 2
	outflags |= MMAN_nl;
	print_word(".RE");
d746 2
a747 5
	    DISP_literal  == n->norm->Bd.type) {
		outflags |= MMAN_nl;
		print_word(".fi");
	}
	outflags |= MMAN_nl;
d822 1
a822 3
	outflags |= MMAN_nl;
	print_word(".TS");
	outflags |= MMAN_nl;
d826 1
d835 3
a840 4
	case (LIST_column):
		outflags |= MMAN_nl;
		print_word(".TE");
		break;
d844 2
a845 1
	outflags |= MMAN_br;
d880 1
a880 3
	outflags |= MMAN_nl;
	print_word(".RS 6n");
	outflags |= MMAN_nl;
d888 1
a888 3
	outflags |= MMAN_nl;
	print_word(".RE");
	outflags |= MMAN_nl;
d1090 1
a1090 1
		outflags |= MMAN_nl;
d1092 4
a1097 4
			if (bln->norm->Bl.comp)
				outflags |= MMAN_br;
			else
				outflags |= MMAN_sp;
a1103 4
			if (bln->norm->Bl.comp)
				outflags |= MMAN_br;
			else
				outflags |= MMAN_sp;
d1105 1
a1105 1
				print_word(".B \"");
d1107 1
a1107 1
				print_word(".R \"");
d1270 4
a1273 6
	outflags |= MMAN_nl;
	if (MDOC_It == n->parent->tok)
		print_word(".sp");
	else
		print_word(".PP");
	outflags |= MMAN_nl;
d1282 2
a1283 3
		outflags |= MMAN_nl;
		print_word(".PP");
		outflags |= MMAN_nl;
d1304 1
a1304 2
	outflags |= MMAN_nl;
	print_word(".sp");
@


1.32
log
@Polish -Tman .Rs support.
All mdoc(7) macros are now supported by -Tman.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.31 2012/07/11 16:18:08 schwarze Exp $ */
d102 2
a103 1
static	void	  print_width(const char *, const struct mdoc_node *);
d363 1
a363 1
print_width(const char *v, const struct mdoc_node *child)
d373 3
a375 1
	if (a2roffsu(v, &su, SCALE_MAX)) {
d964 5
a968 1
	return(pre_fa(m, n->next));
d1098 1
a1098 1
			print_width(bln->norm->Bl.width, NULL);
d1108 1
a1108 1
			print_width(bln->norm->Bl.width, NULL);
d1113 1
a1113 1
			print_width(bln->norm->Bl.width, n->child);
d1116 1
a1116 1
			print_width(bln->norm->Bl.width, NULL);
@


1.31
log
@Basic implementation of -Tman .Bl -column using tbl(7).

In the end, this turned out to be surprisingly simple;
of course, getting identical output will be quite hard,
so there is no way to quickly set up unit tests.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.30 2012/07/10 20:36:33 schwarze Exp $ */
d42 1
d65 1
d91 1
d154 11
a164 11
	{ NULL, NULL, post_percent, NULL, NULL }, /* _%A */
	{ NULL, NULL, NULL, NULL, NULL }, /* _%B */
	{ NULL, NULL, post_percent, NULL, NULL }, /* _%D */
	{ NULL, NULL, NULL, NULL, NULL }, /* _%I */
	{ NULL, pre_enc, post_percent, "\\fI", "\\fP" }, /* %J */
	{ NULL, NULL, NULL, NULL, NULL }, /* _%N */
	{ NULL, NULL, NULL, NULL, NULL }, /* _%O */
	{ NULL, NULL, NULL, NULL, NULL }, /* _%P */
	{ NULL, NULL, NULL, NULL, NULL }, /* _%R */
	{ NULL, pre_enc, post_percent, "\"", "\"" }, /* %T */
	{ NULL, NULL, NULL, NULL, NULL }, /* _%V */
d198 1
a198 1
	{ cond_body, pre_pp, NULL, NULL, NULL }, /* Rs */
d207 2
a208 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Xc */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Xo */
d226 1
a226 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _%C */
d230 1
a230 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _%Q */
d233 2
a234 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _%U */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ta */
a540 5
/*
 * Used in listings (percent = %A, e.g.).
 * FIXME: this is incomplete. 
 * It doesn't print a nice ", and" for lists.
 */
d545 3
a547 2
	post_enc(m, n);
	if (n->next)
d549 4
a552 1
	else {
d558 26
d1252 13
a1264 1
	return(MDOC_Rs == n->tok);
@


1.30
log
@basic implementation of -Tman .Bl -tag
while here, do some minor outflags cleanup
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.29 2012/07/10 19:53:11 schwarze Exp $ */
d753 1
d755 2
a756 1
	if (LIST_enum == n->norm->Bl.type)
d758 13
d778 11
a789 2
	if (LIST_enum == n->norm->Bl.type)
		n->norm->Bl.count = 0;
d1098 4
a1101 2
	if (MDOC_HEAD == n->type) {
		bln = n->parent->parent;
d1113 10
@


1.29
log
@multiple fixes to -Tascii .HP rendering:
* do not add an excessive blank line before the block
* in literal mode, start a new line after the tag

getting this to work requires some general (print_man_node) fixes:
* in literal mode, break the output line at the end of each
input line, not just after those input lines ending in text
* but don't break it when there was no output on the line
* and adjust the margins after the .HP tag

these general fixes require an adjustment to -Tascii .TP rendering:
* set up NOBREAK mode before the body, not after the head

finally, based on all this, implement -Tman .Bl -hang in terms of .HP
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.28 2012/07/10 14:35:57 schwarze Exp $ */
d763 1
a1051 1
			outflags |= MMAN_nl;
d1055 3
a1057 1
			outflags |= MMAN_nl;
d1060 1
a1060 3
			if (bln->norm->Bl.width)
				print_width(bln->norm->Bl.width, n->child);
			break;
@


1.28
log
@* implement -Tman .Bl -item -inset -diag -ohang -dash -hyphen -enum .It
* fix -Tman .Bl -bullet .It
* adjust the -Tascii .Bl -bullet -dash -hyphen .It
default and minimum width to new groff standards,
it changed from 4n (in groff 1.15) to 2n (in groff 1.21)
* same for -Tascii -enum, it changed from 5n to 2n
* use -hang formatting for -Tascii -enum -width 2n
* for -Tascii -enum, the default is -width 3n
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.27 2012/07/09 23:52:47 schwarze Exp $ */
d99 1
a99 1
static	void	  print_width(const char *);
d359 1
a359 1
print_width(const char *v)
d363 5
a367 1
	size_t		  sz;
d373 4
d383 4
d1038 1
a1038 2
			print_word(".TP");
			print_width(bln->norm->Bl.width);
d1048 1
a1048 2
			print_word(".TP");
			print_width(bln->norm->Bl.width);
d1053 4
d1059 1
a1059 1
				print_width(bln->norm->Bl.width);
@


1.27
log
@fix -Tascii .Fd line breaking
and implement -Tman .Fd
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.26 2012/07/09 22:36:04 schwarze Exp $ */
d45 1
d56 1
d69 1
d99 2
d115 1
a115 1
	{ NULL, NULL, NULL, NULL, NULL }, /* Bl */
d117 1
a117 1
	{ NULL, pre_it, NULL, NULL, NULL }, /* _It */
d359 30
d739 17
d995 2
a996 1
	if (MDOC_HEAD == n->type) {
d998 1
a998 2
		print_word(".TP");
		bln = n->parent->parent->prev;
d1000 21
d1022 19
a1040 1
			print_word("4n");
a1041 1
			print_word("\\fBo\\fP");
d1045 1
a1045 1
				print_word(bln->norm->Bl.width);
d1049 2
d1053 21
@


1.26
log
@implement -Tman .Eo and .Ec
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.25 2012/07/09 18:55:40 schwarze Exp $ */
d49 1
d73 1
d125 1
a125 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Fd */
d219 2
a220 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Es */
	{ NULL, NULL, NULL, NULL, NULL }, /* _En */
d789 17
@


1.25
log
@Implement -Tman .Bf.
To get the spacing right,
* avoid man(7) code line breaks at places where no spacing is allowed
* allow spacing right after .Sm on
* allow spacing after empty .Fl at the end of an input line
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.24 2012/07/09 17:52:09 schwarze Exp $ */
d47 1
d169 2
a170 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ec */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ef */
d172 1
a172 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Eo */
d754 8
@


1.24
log
@fix -Tman font handling for:
.Ad .Ar .Cd .Cm .Dv .Em .Er .Ev .Fa .Fl .Fn .Fo .Ft
.Ic .In .Lk .Li .Ms .Mt .Nm .Pa .Sx .Sy .Tn .Va .Vt
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.23 2012/07/09 09:30:28 schwarze Exp $ */
d43 1
d63 1
d159 1
a159 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Bf */
d397 1
a397 2
	if (prev && prev->line < n->line &&
	    MDOC_Fo != prev->tok && MDOC_Ns != prev->tok)
d644 34
d795 2
a796 1
	if (0 == n->nchild)
d1042 1
a1042 1
		outflags |= MMAN_Sm;
@


1.23
log
@implement -Tman .No and .Mt
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.22 2012/07/08 22:48:38 schwarze Exp $ */
d40 2
d47 1
d50 1
d67 1
d69 1
d76 1
d84 1
d108 1
a108 1
	{ NULL, pre_enc, post_enc, "\\fI", "\\fP" }, /* Ad */
d110 6
a115 6
	{ NULL, pre_enc, post_enc, "\\fI", "\\fP" }, /* Ar */
	{ NULL, pre_enc, post_enc, "\\fB", "\\fP" }, /* Cd */
	{ NULL, pre_enc, post_enc, "\\fB", "\\fP" }, /* Cm */
	{ NULL, pre_enc, post_enc, "\\fR", "\\fP" }, /* Dv */
	{ NULL, pre_enc, post_enc, "\\fR", "\\fP" }, /* Er */
	{ NULL, pre_enc, post_enc, "\\fR", "\\fP" }, /* Ev */
d121 1
a121 1
	{ NULL, pre_enc, post_enc, "\\fB-", "\\fP" }, /* Fl */
d123 2
a124 2
	{ NULL, pre_ft, post_enc, NULL, "\\fP" }, /* Ft */
	{ NULL, pre_enc, post_enc, "\\fB", "\\fP" }, /* Ic */
d126 1
a126 1
	{ NULL, pre_enc, post_enc, "\\fR", "\\fP" }, /* Li */
d131 1
a131 1
	{ NULL, pre_enc, post_enc, "\\fI", "\\fP" }, /* Pa */
d138 1
a138 1
	{ NULL, pre_enc, post_enc, "\\fI", "\\fP" }, /* Va */
d168 1
a168 1
	{ NULL, pre_enc, post_enc, "\\fI", "\\fP" }, /* Em */
d171 1
a171 1
	{ NULL, pre_enc, post_enc, "\\fB", "\\fP" }, /* Ms */
d190 3
a192 3
	{ NULL, pre_enc, post_enc, "\\fI", "\\fP" }, /* Sx */
	{ NULL, pre_enc, post_enc, "\\fB", "\\fP" }, /* Sy */
	{ NULL, pre_enc, post_enc, "\\fR", "\\fP" }, /* Tn */
d209 1
a209 1
	{ NULL, pre_enc, post_enc, "\\fI", "\\fP" }, /* Mt */
d236 32
d374 5
a454 4
/*
 * Output a font encoding before a node, e.g., \fR.
 * This obviously has no trailing space.
 */
a467 3
/*
 * Output a font encoding subsequent a node, e.g., \fP.
 */
d478 7
a484 2
	if (MDOC_Fl == n->tok && 0 == n->nchild)
		outflags &= ~MMAN_spc;
d713 8
d728 1
a728 2
		print_word("\\fI");
		outflags &= ~MMAN_spc;
d730 1
a730 2
		outflags &= ~MMAN_spc;
		print_word("\\fP");
d746 19
d774 1
a774 2
	print_word("\\fB");
	outflags &= ~MMAN_spc;
d776 1
d778 1
a778 1
	print_word("\\fP(");
d803 1
a803 2
		print_word("\\fB");
		outflags &= ~MMAN_spc;
d822 1
a822 2
		outflags &= ~MMAN_spc;
		print_word("\\fP");
d837 1
a837 2
	print_word("\\fI");
	outflags &= ~MMAN_spc;
d847 8
a854 4
		print_word("\\fB#include <");
	} else
		print_word("<\\fI");
	outflags &= ~MMAN_spc;
a861 1
	outflags &= ~MMAN_spc;
d863 3
a865 1
		print_word(">\\fP");
d867 5
a871 2
	} else
		print_word("\\fP>");
d916 1
a916 2
		print_word("\\fI");
		outflags &= ~MMAN_spc;
d922 1
a922 2
		outflags &= ~MMAN_spc;
		print_word("\\fP");
d925 1
a925 2
	print_word("\\fB");
	outflags &= ~MMAN_spc;
d927 1
a927 2
	outflags &= ~MMAN_spc;
	print_word("\\fP");
d932 8
d949 1
a949 2
	print_word("\\fB");
	outflags &= ~MMAN_spc;
d961 1
a961 2
	outflags &= ~MMAN_spc;
	print_word("\\fP");
d1029 8
d1051 1
a1051 2
	print_word("\\fI");
	outflags &= ~MMAN_spc;
d1061 1
a1061 3

	outflags &= ~MMAN_spc;
	print_word("\\fP");
@


1.22
log
@fix .Lk for -Tascii and implement it for -Tman
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.21 2012/07/08 18:38:07 schwarze Exp $ */
d71 1
d164 1
a164 1
	{ NULL, NULL, NULL, NULL, NULL }, /* No */
d201 1
a201 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Mt */
d219 8
a226 7
#define	MMAN_nl		(1 << 1)
#define	MMAN_br		(1 << 2)
#define	MMAN_sp		(1 << 3)
#define	MMAN_Sm		(1 << 4)
#define	MMAN_Bk		(1 << 5)
#define	MMAN_An_split	(1 << 6)
#define	MMAN_An_nosplit	(1 << 7)
d245 4
a248 4
		 * If we need a space, only print it before
		 * (1) a nonzero length word;
		 * (2) a word that is non-punctuation; and
		 * (3) if punctuation, non-terminating puncutation.
d250 2
a251 1
		if (NULL == strchr(".,:;)]?!", s[0]) || '\0' != s[1]) {
d268 1
d887 8
@


1.21
log
@fix vertical spacing for -Tman SYNOPSIS .Fn .Fo .Ft .In .Nm .Va .Vt
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.20 2012/07/08 16:50:36 schwarze Exp $ */
d69 1
d199 1
a199 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Lk */
d828 28
@


1.20
log
@implement -Tman .An
also reset -[no]split mode at .Sh AUTHORS in -Tascii
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.19 2012/07/08 15:46:47 schwarze Exp $ */
d66 1
d75 1
d113 1
a113 1
	{ NULL, pre_enc, post_enc, "\\fI", "\\fP" }, /* Ft */
d489 40
d695 2
a700 2
	if (MDOC_SYNPRETTY & n->flags)
		outflags |= MMAN_br;
d726 3
a729 2
		if (MDOC_SYNPRETTY & n->flags)
			outflags |= MMAN_br;
d762 10
d776 1
a776 1
		outflags |= MMAN_br;
d833 2
d837 2
a838 2
	if (MDOC_SYNPRETTY & n->flags)
		outflags |= MMAN_br;
d919 1
a925 1
		outflags |= MMAN_br;
a940 2
	if (MDOC_SYNPRETTY & n->flags)
		outflags |= MMAN_br;
@


1.19
log
@Add flags to insert a .sp or .br request before the next output,
shortening some frequent idioms and preparing for better vertical
spacing in the SYNOPSIS; no functional change intended.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.18 2012/07/08 15:00:43 schwarze Exp $ */
d55 1
d97 1
a97 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _An */
d220 2
d483 25
@


1.18
log
@Instead of adding one integer variable for each global boolean output flag
and passing around a structure containing them into each and every function,
just use a single static bitfield.
In preparation for adding more output flags to support more features.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.17 2012/07/08 13:56:27 schwarze Exp $ */
d215 4
a218 2
#define	MMAN_Sm		(1 << 2)
#define	MMAN_Bk		(1 << 3)
d224 1
a224 1
	if (MMAN_nl & outflags) {
d228 7
a234 2
		putchar('\n');
		outflags &= ~(MMAN_nl|MMAN_spc);
d496 2
a497 4
	if (0 == n->norm->Bd.comp) {
		outflags |= MMAN_nl;
		print_word(".sp");
	}
d551 1
a551 3
	outflags |= MMAN_nl;
	print_word(".br");
	outflags |= MMAN_nl;
d629 2
a630 5
	if (MDOC_SYNPRETTY & n->flags) {
		outflags |= MMAN_nl;
		print_word(".br");
		outflags |= MMAN_nl;
	}
d647 1
a647 3
		outflags |= MMAN_nl;
		print_word(".br");
		outflags |= MMAN_nl;
d657 2
a658 5
		if (MDOC_SYNPRETTY & n->flags) {
			outflags |= MMAN_nl;
			print_word(".br");
			outflags |= MMAN_nl;
		}
d695 1
a695 3
		outflags |= MMAN_nl;
		print_word(".br");
		outflags |= MMAN_nl;
d710 1
a710 3
		outflags |= MMAN_nl;
		print_word(".br");
		outflags |= MMAN_nl;
d744 2
a745 5
	if (SEC_LIBRARY == n->sec) {
		outflags |= MMAN_nl;
		print_word(".br");
		outflags |= MMAN_nl;
	}
d754 2
a755 5
	if (MDOC_SYNPRETTY & n->flags) {
		outflags |= MMAN_nl;
		print_word(".br");
		outflags |= MMAN_nl;
	}
d842 1
a842 3
		outflags |= MMAN_nl;
		print_word(".br");
		outflags |= MMAN_nl;
d858 2
a859 5
	if (MDOC_SYNPRETTY & n->flags) {
		outflags |= MMAN_nl;
		print_word(".br");
		outflags |= MMAN_nl;
	}
@


1.17
log
@implement -Tman .Va
and fix -Tman .Vt for the non-SYNOPSIS case
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.16 2012/07/08 11:08:06 schwarze Exp $ */
d28 1
a28 9
		  const struct mdoc_node *n, \
		  struct mman *mm

struct	mman {
	int		  mode_space; /* spacing mode: 1 = on */
	int		  need_space; /* next word needs prior ws */
	int		  mode_keep; /* currently inside a keep */
	int		  need_nl; /* next word needs prior nl */
};
d76 2
a77 2
static	void	  print_word(struct mman *, const char *);
static	void	  print_offs(struct mman *, const char *);
d212 6
d219 1
a219 1
print_word(struct mman *mm, const char *s)
d222 1
a222 1
	if (mm->need_nl) {
d227 2
a228 3
		mm->need_space = 0;
		mm->need_nl = 0;
	} else if (mm->need_space && '\0' != s[0])
d236 1
a236 1
			if (mm->mode_keep) {
d247 5
a251 2
	mm->need_space = mm->mode_space &&
		(('(' != s[0] && '[' != s[0]) || '\0' != s[1]);
d269 1
a269 1
print_offs(struct mman *mm, const char *v)
d282 1
a282 1
		print_word(mm, v);
d288 1
a288 1
	print_word(mm, buf);
a308 1
	struct mman	        mm;
d316 2
a317 5
	memset(&mm, 0, sizeof(struct mman));

	mm.mode_space = 1;
	mm.need_nl = 1;
	print_node(m, n, &mm);
d335 1
a335 1
		mm->need_nl = 1;
d346 1
a346 1
		if (mm->need_nl && ('.' == *n->string || 
d348 2
a349 2
			print_word(mm, "\\&");
			mm->need_space = 0;
d351 1
a351 1
		print_word(mm, n->string);
d358 1
a358 1
		cond = NULL == act->cond || (*act->cond)(m, n, mm);
d360 1
a360 1
			do_sub = (*act->pre)(m, n, mm);
d370 1
a370 1
			print_node(m, sub, mm);
d376 1
a376 1
		(*act->post)(m, n, mm);
d405 2
a406 2
	print_word(mm, prefix);
	mm->need_space = 0;
d421 2
a422 2
	mm->need_space = 0;
	print_word(mm, suffix);
d424 1
a424 1
		mm->need_space = 0;
d436 1
a436 1
	post_enc(m, n, mm);
d438 1
a438 1
		print_word(mm, ",");
d440 2
a441 2
		print_word(mm, ".");
		mm->need_nl = 1;
d454 4
a457 4
	mm->need_nl = 1;
	print_word(mm, manacts[n->tok].prefix);
	print_word(mm, "\"");
	mm->need_space = 0;
d470 3
a472 3
	mm->need_space = 0;
	print_word(mm, "\"");
	mm->need_nl = 1;
d479 3
a481 3
	mm->need_space = 0;
	print_word(mm, "'");
	mm->need_space = 0;
d490 2
a491 2
		mm->need_nl = 1;
		print_word(mm, ".sp");
d495 2
a496 2
		mm->need_nl = 1;
		print_word(mm, ".nf");
d498 4
a501 4
	mm->need_nl = 1;
	print_word(mm, ".RS");
	print_offs(mm, n->norm->Bd.offs);
	mm->need_nl = 1;
d509 2
a510 2
	mm->need_nl = 1;
	print_word(mm, ".RE");
d513 2
a514 2
		mm->need_nl = 1;
		print_word(mm, ".fi");
d516 1
a516 1
	mm->need_nl = 1;
d527 1
a527 1
		mm->mode_keep = 1;
d539 1
a539 1
		mm->mode_keep = 0;
d546 3
a548 3
	mm->need_nl = 1;
	print_word(mm, ".br");
	mm->need_nl = 1;
d558 2
a559 2
		print_word(mm, n->string);
		mm->need_space = 0;
d562 1
a562 1
	print_word(mm, "BSD");
d565 4
a568 4
	mm->need_space = 0;
	print_word(mm, "-");
	mm->need_space = 0;
	print_word(mm, n->string);
d576 3
a578 3
	mm->need_nl = 1;
	print_word(mm, ".RS 6n");
	mm->need_nl = 1;
d586 3
a588 3
	mm->need_nl = 1;
	print_word(mm, ".RE");
	mm->need_nl = 1;
d599 5
a603 5
		print_word(mm, "\\fI");
		mm->need_space = 0;
		print_node(m, n, mm);
		mm->need_space = 0;
		print_word(mm, "\\fP");
d605 1
a605 1
			print_word(mm, ",");
d615 1
a615 1
		print_word(mm, ",");
d627 11
a637 11
		mm->need_nl = 1;
		print_word(mm, ".br");
		mm->need_nl = 1;
	}
	print_word(mm, "\\fB");
	mm->need_space = 0;
	print_node(m, n, mm);
	mm->need_space = 0;
	print_word(mm, "\\fP(");
	mm->need_space = 0;
	return(pre_fa(m, n->next, mm));
d644 1
a644 1
	print_word(mm, ")");
d646 4
a649 4
		print_word(mm, ";");
		mm->need_nl = 1;
		print_word(mm, ".br");
		mm->need_nl = 1;
d660 3
a662 3
			mm->need_nl = 1;
			print_word(mm, ".br");
			mm->need_nl = 1;
d664 2
a665 2
		print_word(mm, "\\fB");
		mm->need_space = 0;
d668 3
a670 3
		mm->need_space = 0;
		print_word(mm, "(");
		mm->need_space = 0;
d684 2
a685 2
		mm->need_space = 0;
		print_word(mm, "\\fP");
d688 1
a688 1
		post_fn(m, n, mm);
d700 4
a703 4
		mm->need_nl = 1;
		print_word(mm, ".br");
		mm->need_nl = 1;
		print_word(mm, "\\fB#include <");
d705 2
a706 2
		print_word(mm, "<\\fI");
	mm->need_space = 0;
d714 1
a714 1
	mm->need_space = 0;
d716 4
a719 4
		print_word(mm, ">\\fP");
		mm->need_nl = 1;
		print_word(mm, ".br");
		mm->need_nl = 1;
d721 1
a721 1
		print_word(mm, "\\fP>");
d730 2
a731 2
		mm->need_nl = 1;
		print_word(mm, ".TP");
d735 3
a737 3
			print_word(mm, "4n");
			mm->need_nl = 1;
			print_word(mm, "\\fBo\\fP");
d741 1
a741 1
				print_word(mm, bln->norm->Bl.width);
d744 1
a744 1
		mm->need_nl = 1;
d754 3
a756 3
		mm->need_nl = 1;
		print_word(mm, ".br");
		mm->need_nl = 1;
d767 3
a769 3
		mm->need_nl = 1;
		print_word(mm, ".br");
		mm->need_nl = 1;
d771 2
a772 2
	print_word(mm, "\\fB");
	mm->need_space = 0;
d774 1
a774 1
		print_word(mm, m->name);
d784 2
a785 2
	mm->need_space = 0;
	print_word(mm, "\\fP");
d792 1
a792 1
	mm->need_space = 0;
d800 1
a800 1
	mm->need_space = 0;
d807 1
a807 1
	mm->need_nl = 1;
d809 1
a809 1
		print_word(mm, ".sp");
d811 2
a812 2
		print_word(mm, ".PP");
	mm->need_nl = 1;
d822 1
a822 1
		mm->mode_space = 1;
d824 1
a824 1
		mm->mode_space = 0;
d832 2
a833 2
	mm->need_nl = 1;
	print_word(mm, ".sp");
d841 1
a841 1
	mm->need_nl = 1;
d857 3
a859 3
		mm->need_nl = 1;
		print_word(mm, ".br");
		mm->need_nl = 1;
d861 2
a862 2
	print_word(mm, "\\fI");
	mm->need_space = 0;
d873 2
a874 2
	mm->need_space = 0;
	print_word(mm, "\\fP");
d876 3
a878 3
		mm->need_nl = 1;
		print_word(mm, ".br");
		mm->need_nl = 1;
d889 1
a889 1
	print_node(m, n, mm);
d893 4
a896 4
	mm->need_space = 0;
	print_word(mm, "(");
	print_node(m, n, mm);
	print_word(mm, ")");
d904 1
a904 1
	print_word(mm, manacts[n->tok].prefix);
d907 3
a909 3
	mm->need_space = 0;
	print_word(mm, "\\~");
	mm->need_space = 0;
@


1.16
log
@ouch, in the SYNOPSIS, .Vt is a block,
so avoid printing pointless goo in -Tman
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.15 2012/07/08 10:58:44 schwarze Exp $ */
d133 1
a133 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Va */
d874 1
a874 1
	if (MDOC_BODY != n->type)
@


1.15
log
@implement -Tman .Vt
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.14 2012/07/08 10:16:36 schwarze Exp $ */
d853 8
d873 3
@


1.14
log
@Basic implementation of -Tman .Fo and .Fa;
again, some blank lines still missing from the output.
While here, remove the trailing semicolon
from .Fn when outside .Sh SYNOPSIS.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.13 2012/07/07 21:15:37 schwarze Exp $ */
d62 1
d81 1
d134 1
a134 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Vt */
d846 27
@


1.13
log
@rudimentary support for -Tman .Ft and .Fn;
some blank lines are still missing from the output
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.12 2012/07/07 20:34:20 schwarze Exp $ */
d52 1
d54 1
d69 1
d71 1
d112 1
a112 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Fa */
d189 2
a190 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Fo */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Fc */
d335 2
a336 1
	if (prev && prev->line < n->line && MDOC_Ns != prev->tok)
d594 27
d639 1
a639 10
	for (n = n->next; n; n = n->next) {
		print_word(mm, "\\fI");
		mm->need_space = 0;
		print_node(m, n, mm);
		mm->need_space = 0;
		print_word(mm, "\\fP");
		if (NULL != n->next)
			print_word(mm, ",");
	}
	return(0);
d646 1
a646 2
	mm->need_space = 0;
	print_word(mm, ");");
d648 1
d652 42
@


1.12
log
@basic support for -Tman .In
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.11 2012/07/07 14:04:39 schwarze Exp $ */
d52 1
d67 1
d111 2
a112 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Fn */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ft */
d586 44
@


1.11
log
@after .Lb in library section, break the line in the final output
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.10 2012/07/07 13:56:19 schwarze Exp $ */
d52 1
d66 1
d112 1
a112 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _In */
d584 29
@


1.10
log
@implement -Tman .Bk
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.9 2012/07/07 13:51:03 schwarze Exp $ */
d52 1
d191 1
a191 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Lb */
d607 11
@


1.9
log
@implement -Tman .Sm
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.8 2012/07/07 13:45:26 schwarze Exp $ */
d34 1
d49 1
d59 1
d184 2
a185 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Bk */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ek */
d227 7
a233 2
		if (NULL == strchr(".,:;)]?!", s[0]) || '\0' != s[1])
			putchar(' ');
d509 23
@


1.8
log
@implement -Tman .Bd -offset and -compact
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.7 2012/07/07 13:32:47 schwarze Exp $ */
d17 1
d32 1
d65 1
d170 1
a170 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Sm */
d231 2
a232 2
	mm->need_space = 
		('(' != s[0] && '[' != s[0]) || '\0' != s[1];
d300 1
d631 12
@


1.7
log
@minor -mdoc -Tman fixes
* right after .Ns, avoid breaking the line in man code
* after .Fl without arguments, do not insert a blank into man code
* before each .Nm in .Sh SYNOPSIS, insert a .br into man code
* skip .Pp arguments, don't copy them to man code
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.6 2011/10/22 20:54:52 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
d21 1
d68 1
d246 23
d469 4
d479 3
d489 2
@


1.6
log
@Implement missing enclosures (Ao Do Qo Qq So Bro Brq)
and enclosure-like in-line macros (Ad Cd Dv Er Ev Li Ms Tn).
The .No macro works without explicit implementation.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.5 2011/10/20 01:11:41 schwarze Exp $ */
d289 1
a289 1
	if (prev && prev->line < n->line)
d378 2
d545 5
d592 1
a592 1
	return(1);
@


1.5
log
@Implement the missing text production macros (Bsx Bx Dx Fx Nx Ox Ux Bt Ud).
Some macros work without explicit implementation (At Db Os St).
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.4 2011/10/09 17:59:56 schwarze Exp $ */
d84 1
a84 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ad */
d87 1
a87 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Cd */
d89 3
a91 3
	{ NULL, NULL, NULL, NULL, NULL }, /* _Dv */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Er */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ev */
d102 1
a102 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Li */
d128 2
a129 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ac */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ao */
d139 2
a140 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Dc */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Do */
d147 2
a148 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ms */
	{ NULL, NULL, NULL, NULL, NULL }, /* _No */
d156 1
a156 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Qc */
d158 3
a160 3
	{ NULL, NULL, NULL, NULL, NULL }, /* _Qo */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Qq */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Re */
d162 2
a163 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Sc */
	{ NULL, NULL, NULL, NULL, NULL }, /* _So */
d168 1
a168 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Tn */
d175 1
a175 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Oc */
d186 3
a188 3
	{ NULL, NULL, NULL, NULL, NULL }, /* _Brq */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Bro */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Brc */
@


1.4
log
@Sync to version 1.12.0; all code by kristaps@@:
Implement .Rv in -Tman.
Let -man -Tman work a bit like cat(1).
Add the -Ofragment option to -T[x]html.
Minor fixes in -T[x]html.
Lots of apropos(1) and -Tman code cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.3 2011/09/30 00:13:21 schwarze Exp $ */
d55 1
d64 1
d73 1
a73 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Os */
d106 2
a107 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ot */
	{ NULL, pre_enc, post_enc, "\\fI", "\\fP" }, /* _Pa */
d113 1
a113 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _St */
d116 1
a116 1
	{ NULL, pre_xr, NULL, NULL, NULL }, /* _Xr */
d131 1
a131 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _At */
d136 3
a138 3
	{ NULL, NULL, NULL, NULL, NULL }, /* _Bsx */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Bx */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Db */
d146 1
a146 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Fx */
d150 2
a151 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Nx */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ox */
d169 1
a169 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ux */
d178 4
a181 4
	{ NULL, NULL, NULL, NULL, NULL }, /* _Bt */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Hf */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Fr */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ud */
d192 1
a192 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Dx */
d474 20
d620 13
@


1.3
log
@implement .Ap .Bd .Bo .Bq .D1 .Ic .Lp .Oo .Pf .Po .Ss .Sx .Sy .br .sp
implement .Bl -bullet
add more information to the .TH line
escape dots at the beginnings of lines
add trailing newline character at the end of the file
do not misinterpret the ROOT block as .Ap
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.2 2011/09/20 13:47:59 schwarze Exp $ */
d21 1
d25 3
a27 2
static	int	  need_space = 0;
static	int	  need_nl = 0;
d29 4
a32 2
#define	DECL_ARGS const struct mdoc_meta *m, \
		  const struct mdoc_node *n
d35 5
a39 5
	int		(*cond)(DECL_ARGS);
	int		(*pre)(DECL_ARGS);
	void		(*post)(DECL_ARGS);
	const char	 *prefix;
	const char	 *suffix;
d42 1
a42 3
static	void	  print_word(const char *);
static	void	  print_node(DECL_ARGS);

d44 2
a45 2
static	int	  cond_body(DECL_ARGS);
static	int	  pre_enc(DECL_ARGS);
d47 1
d49 1
a49 1
static	int	  pre_sect(DECL_ARGS);
d51 1
a51 1

a53 1
static	void	  post_bd(DECL_ARGS);
d56 1
a56 1
static	void	  post_dl(DECL_ARGS);
a58 1
static	void	  post_nm(DECL_ARGS);
a59 1
static	void	  post_pf(DECL_ARGS);
d62 1
a62 1
static	void	  post_sp(DECL_ARGS);
d64 2
a65 1

d106 5
a110 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Rv */
a198 1

d200 1
a200 1
print_word(const char *s)
d202 5
a206 1
	if (need_nl) {
d208 19
a226 6
		need_space = 0;
		need_nl = 0;
	} else if (need_space &&
	    (NULL == strchr(".,:;)]?!", s[0]) || '\0' != s[1]))
		putchar(' ');
	need_space = ('(' != s[0] && '[' != s[0]) || '\0' != s[1];
d236 1
a236 1
			putchar(*s);
d243 13
d260 1
d266 1
a266 3
	    m->title, m->msec, m->date, m->os, m->vol);
	need_nl = 1;
	need_space = 0;
d268 4
a271 1
	print_node(m, n);
d279 1
a279 1
	const struct manact	*act = NULL;
d281 5
a285 1

d288 1
a288 1
		need_nl = 1;
d290 1
d293 1
d295 8
a302 3
		if (need_nl && ('.' == *n->string || '\'' == *n->string)) {
			print_word("\\&");
			need_space = 0;
d304 1
a304 1
		print_word(n->string);
d306 4
d311 1
a311 1
		cond = NULL == act->cond || (*act->cond)(m, n);
d313 1
a313 1
			do_sub = (*act->pre)(m, n);
d316 5
d323 1
a323 1
			print_node(m, sub);
d325 3
d329 1
a329 1
		(*act->post)(m, n);
d335 1
d342 1
d346 4
d353 1
a353 1
	const char *prefix;
d358 2
a359 2
	print_word(prefix);
	need_space = 0;
d363 3
d374 2
a375 2
	need_space = 0;
	print_word(suffix);
d378 5
d387 1
a387 1
	post_enc(m, n);
d389 1
a389 1
		print_word(",");
d391 2
a392 2
		print_word(".");
		need_nl = 1;
d396 3
d405 4
a408 4
	need_nl = 1;
	print_word(manacts[n->tok].prefix);
	print_word("\"");
	need_space = 0;
d412 3
d421 3
a423 3
	need_space = 0;
	print_word("\"");
	need_nl = 1;
d430 3
a432 3
	need_space = 0;
	print_word("'");
	need_space = 0;
d442 2
a443 2
		need_nl = 1;
		print_word(".nf");
d445 1
a445 1
	need_nl = 1;
d455 2
a456 2
		need_nl = 1;
		print_word(".fi");
d458 1
a458 1
	need_nl = 1;
d465 3
a467 3
	need_nl = 1;
	print_word(".br");
	need_nl = 1;
d475 3
a477 3
	need_nl = 1;
	print_word(".RS 6n");
	need_nl = 1;
d485 3
a487 3
	need_nl = 1;
	print_word(".RE");
	need_nl = 1;
d496 2
a497 2
		need_nl = 1;
		print_word(".TP");
d501 3
a503 3
			print_word("4n");
			need_nl = 1;
			print_word("\\fBo\\fP");
d507 1
a507 1
				print_word(bln->norm->Bl.width);
d510 1
a510 1
		need_nl = 1;
d521 2
a522 2
	print_word("\\fB");
	need_space = 0;
d524 1
a524 1
		print_word(m->name);
d534 2
a535 2
	need_space = 0;
	print_word("\\fP");
d542 1
a542 1
	need_space = 0;
d550 1
a550 1
	need_space = 0;
d557 1
a557 1
	need_nl = 1;
d559 1
a559 1
		print_word(".sp");
d561 2
a562 2
		print_word(".PP");
	need_nl = 1;
d570 2
a571 2
	need_nl = 1;
	print_word(".sp");
d579 1
a579 1
	need_nl = 1;
d589 1
a589 1
	print_node(m, n);
d593 4
a596 4
	need_space = 0;
	print_word("(");
	print_node(m, n);
	print_word(")");
@


1.2
log
@do not assign pointers to literal strings
to variables that might be changed;
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_man.c,v 1.1 2011/09/17 14:45:22 schwarze Exp $ */
d46 2
d49 4
d59 1
d61 2
a62 2
static	int	  pre_sh(DECL_ARGS);
static	void	  post_sh(DECL_ARGS);
d66 4
a69 4
static	const struct manact manacts[MDOC_MAX] = {
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ap */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Dd */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Dt */
d71 2
a72 2
	{ NULL, pre_sh, post_sh, NULL, NULL }, /* Sh */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ss */
d74 1
a74 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _D1 */
d76 4
a79 4
	{ NULL, NULL, NULL, NULL, NULL }, /* _Bd */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ed */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Bl */
	{ NULL, NULL, NULL, NULL, NULL }, /* _El */
d97 1
a97 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Ic */
d125 1
a125 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Bc */
d127 2
a128 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Bo */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Bq */
d137 1
a137 1
	{ NULL, pre_enc, post_enc, "\\fI", "\\fP" }, /* _Em */
d145 4
a148 4
	{ NULL, NULL, NULL, NULL, NULL }, /* _Pc */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Pf */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Po */
	{ cond_body, pre_enc, post_enc, "(", ")" }, /* _Pq */
d159 2
a160 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _Sx */
	{ NULL, NULL, NULL, NULL, NULL }, /* _Sy */
d167 1
a167 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Oo */
d176 1
a176 1
	{ NULL, NULL, NULL, NULL, NULL }, /* _Lp */
d187 2
a188 2
	{ NULL, NULL, NULL, NULL, NULL }, /* _br */
	{ NULL, NULL, NULL, NULL, NULL }, /* _sp */
d191 1
d230 2
a231 1
	printf(".TH \"%s\" \"%s\" \"%s\"", m->title, m->msec, m->date);
d236 1
d253 4
d324 69
d420 11
a430 1
		print_word(bln->norm->Bl.width);
d467 7
d488 1
a488 1
pre_sh(DECL_ARGS)
a490 2
	if (MDOC_HEAD != n->type)
		return(1);
d492 1
a492 2
	print_word(".SH \"");
	need_space = 0;
d497 1
a497 1
post_sh(DECL_ARGS)
a499 4
	if (MDOC_HEAD != n->type)
		return;
	need_space = 0;
	print_word("\"");
@


1.1
log
@Initial, incomplete support for -Tman
to convert mdoc(7) documents to the man(7) language.
This is work in progress and will be developed in tree.
It does already handle the cat(1) manual,
but will hardly handle all your fancy manuals yet.
go ahead  kristaps@@ jmc@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$Id$ */
d34 2
a35 2
	char		 *prefix;
	char		 *suffix;
@

