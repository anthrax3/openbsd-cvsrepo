head	1.174;
access;
symbols
	OPENBSD_6_1:1.174.0.4
	OPENBSD_6_1_BASE:1.174
	OPENBSD_6_0:1.162.0.4
	OPENBSD_6_0_BASE:1.162
	OPENBSD_5_9:1.162.0.2
	OPENBSD_5_9_BASE:1.162
	OPENBSD_5_8:1.156.0.4
	OPENBSD_5_8_BASE:1.156
	OPENBSD_5_7:1.139.0.2
	OPENBSD_5_7_BASE:1.139
	OPENBSD_5_6:1.94.0.4
	OPENBSD_5_6_BASE:1.94
	OPENBSD_5_5:1.86.0.4
	OPENBSD_5_5_BASE:1.86
	OPENBSD_5_4:1.78.0.4
	OPENBSD_5_4_BASE:1.78
	OPENBSD_5_3:1.78.0.2
	OPENBSD_5_3_BASE:1.78
	OPENBSD_5_2:1.74.0.2
	OPENBSD_5_2_BASE:1.74
	OPENBSD_5_1_BASE:1.73
	OPENBSD_5_1:1.73.0.2
	OPENBSD_5_0:1.68.0.2
	OPENBSD_5_0_BASE:1.68
	OPENBSD_4_9:1.64.0.2
	OPENBSD_4_9_BASE:1.64
	OPENBSD_4_8:1.55.0.2
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.174
date	2017.02.16.09.47.10;	author schwarze;	state Exp;
branches;
next	1.173;
commitid	CGH7SijTvfRoSBIL;

1.173
date	2017.02.16.02.59.42;	author schwarze;	state Exp;
branches;
next	1.172;
commitid	Qmey25xun8rVuoB9;

1.172
date	2017.02.11.15.44.11;	author schwarze;	state Exp;
branches;
next	1.171;
commitid	I93j2gVX5RYNPkBd;

1.171
date	2017.02.11.14.08.35;	author schwarze;	state Exp;
branches;
next	1.170;
commitid	uuwb9E8iUagwNkgE;

1.170
date	2017.02.11.13.23.11;	author schwarze;	state Exp;
branches;
next	1.169;
commitid	mfBbrjXVIBKnalMu;

1.169
date	2017.02.10.22.19.11;	author schwarze;	state Exp;
branches;
next	1.168;
commitid	EmgA9SdsaLlJ0OCc;

1.168
date	2017.02.10.16.20.58;	author schwarze;	state Exp;
branches;
next	1.167;
commitid	q6soTn2IHZ7D5vYC;

1.167
date	2017.02.10.15.44.31;	author schwarze;	state Exp;
branches;
next	1.166;
commitid	jWIgaURhUN1Qo7t2;

1.166
date	2017.01.10.13.46.53;	author schwarze;	state Exp;
branches;
next	1.165;
commitid	aFt8sLe7F06PjFYh;

1.165
date	2016.08.20.17.58.09;	author schwarze;	state Exp;
branches;
next	1.164;
commitid	ruds5O2o6F2jNWeX;

1.164
date	2016.08.20.15.58.16;	author schwarze;	state Exp;
branches;
next	1.163;
commitid	g44rlhr1yUH2kxKq;

1.163
date	2016.08.13.09.14.56;	author schwarze;	state Exp;
branches;
next	1.162;
commitid	wPmptYr6wU8sOXAp;

1.162
date	2015.10.20.02.00.49;	author schwarze;	state Exp;
branches;
next	1.161;
commitid	v6RrmxwM663z4mTF;

1.161
date	2015.10.17.00.19.58;	author schwarze;	state Exp;
branches;
next	1.160;
commitid	67CJSTzbNGkiWCoU;

1.160
date	2015.10.15.22.27.09;	author schwarze;	state Exp;
branches;
next	1.159;
commitid	Sg7CIcShTYTHlEiQ;

1.159
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.158;
commitid	Ql2ha5NS80pwfGNT;

1.158
date	2015.10.06.18.30.44;	author schwarze;	state Exp;
branches;
next	1.157;
commitid	hxQV8O1pNUaef4ir;

1.157
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.156;
commitid	191tWtskbsgcpQqV;

1.156
date	2015.05.01.16.56.36;	author schwarze;	state Exp;
branches;
next	1.155;
commitid	zG3zYzoKB1peGeEa;

1.155
date	2015.05.01.16.01.53;	author schwarze;	state Exp;
branches;
next	1.154;
commitid	Z9Pokbi3EU6dbOos;

1.154
date	2015.05.01.15.27.17;	author schwarze;	state Exp;
branches;
next	1.153;
commitid	oQzSwlFiGEczKE5z;

1.153
date	2015.04.29.21.57.50;	author schwarze;	state Exp;
branches;
next	1.152;
commitid	owhBdMCZKcBoxoKt;

1.152
date	2015.04.29.14.48.17;	author schwarze;	state Exp;
branches;
next	1.151;
commitid	OSAAzxHYc9j08hw5;

1.151
date	2015.04.23.15.35.39;	author schwarze;	state Exp;
branches;
next	1.150;
commitid	am2zU0fu81iRKMOO;

1.150
date	2015.04.21.16.13.54;	author schwarze;	state Exp;
branches;
next	1.149;
commitid	rJ7xt9mitvEO0hMf;

1.149
date	2015.04.19.14.57.16;	author schwarze;	state Exp;
branches;
next	1.148;
commitid	FaoA4UzPphKw0cyB;

1.148
date	2015.04.19.14.25.05;	author schwarze;	state Exp;
branches;
next	1.147;
commitid	E1gJfKuheBoo64Vb;

1.147
date	2015.04.19.13.59.37;	author schwarze;	state Exp;
branches;
next	1.146;
commitid	aS3h5dIgZk0f7675;

1.146
date	2015.04.19.13.50.10;	author schwarze;	state Exp;
branches;
next	1.145;
commitid	QSaLMe5iBgPB4hUe;

1.145
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.144;
commitid	6MYJ7cd8mhJ77AGH;

1.144
date	2015.04.05.23.04.22;	author schwarze;	state Exp;
branches;
next	1.143;
commitid	pTi5NMACH38DoB8s;

1.143
date	2015.04.05.22.43.40;	author schwarze;	state Exp;
branches;
next	1.142;
commitid	FKQ9pJ8jaBEy8FEc;

1.142
date	2015.04.05.14.43.10;	author schwarze;	state Exp;
branches;
next	1.141;
commitid	OILdzs9noIanocKo;

1.141
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.140;
commitid	Rfx1oTaH3hZ7Zcyf;

1.140
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.139;
commitid	lmErjWY2O9ooA6RY;

1.139
date	2015.02.12.12.20.47;	author schwarze;	state Exp;
branches;
next	1.138;
commitid	SViaEKzwzmf0o0kW;

1.138
date	2015.02.11.13.37.31;	author schwarze;	state Exp;
branches;
next	1.137;
commitid	VGYKVVAdlQgUdM8r;

1.137
date	2015.02.10.17.47.19;	author schwarze;	state Exp;
branches;
next	1.136;
commitid	myoCaafpofcJyStw;

1.136
date	2015.02.07.16.39.44;	author schwarze;	state Exp;
branches;
next	1.135;
commitid	Qzl2n2ulv8PNdpCW;

1.135
date	2015.02.06.07.12.34;	author schwarze;	state Exp;
branches;
next	1.134;
commitid	QDbepmLqTNee3zgJ;

1.134
date	2015.02.06.03.31.11;	author schwarze;	state Exp;
branches;
next	1.133;
commitid	EGoCKP2gntS3HBlE;

1.133
date	2015.02.06.01.07.07;	author schwarze;	state Exp;
branches;
next	1.132;
commitid	oDIjvdp0jkTBklvD;

1.132
date	2015.02.05.01.46.38;	author schwarze;	state Exp;
branches;
next	1.131;
commitid	Whyrd7T544leDR65;

1.131
date	2015.02.05.00.13.34;	author schwarze;	state Exp;
branches;
next	1.130;
commitid	yNql0K85SrSgftGW;

1.130
date	2015.02.04.22.29.27;	author schwarze;	state Exp;
branches;
next	1.129;
commitid	IbbLBZeVYih9Ehjm;

1.129
date	2015.02.04.18.03.28;	author schwarze;	state Exp;
branches;
next	1.128;
commitid	voy6CFtu7t43ZgbA;

1.128
date	2015.02.03.18.19.27;	author schwarze;	state Exp;
branches;
next	1.127;
commitid	b0gYEbo46Z2hVtHV;

1.127
date	2015.02.03.01.13.48;	author schwarze;	state Exp;
branches;
next	1.126;
commitid	s14aWOWk6kaFd6xV;

1.126
date	2015.02.03.00.48.27;	author schwarze;	state Exp;
branches;
next	1.125;
commitid	YfyANUxCvB10IMDY;

1.125
date	2015.02.02.19.22.46;	author schwarze;	state Exp;
branches;
next	1.124;
commitid	nRZ0i192CtxdrWIy;

1.124
date	2015.02.02.18.26.06;	author schwarze;	state Exp;
branches;
next	1.123;
commitid	JF1v3mbtU0RfAJKN;

1.123
date	2015.02.02.15.02.17;	author schwarze;	state Exp;
branches;
next	1.122;
commitid	7y9D6ETSp0yd76jK;

1.122
date	2015.02.02.04.26.03;	author schwarze;	state Exp;
branches;
next	1.121;
commitid	aVQDMaIveEZUjjaV;

1.121
date	2015.02.02.04.04.18;	author schwarze;	state Exp;
branches;
next	1.120;
commitid	kb4plLn1cByoPbSP;

1.120
date	2015.02.01.23.55.37;	author schwarze;	state Exp;
branches;
next	1.119;
commitid	pVWz5f1ZbuGANCvd;

1.119
date	2015.02.01.17.30.34;	author schwarze;	state Exp;
branches;
next	1.118;
commitid	nsfDe89Q61sbuWqJ;

1.118
date	2015.02.01.16.46.57;	author schwarze;	state Exp;
branches;
next	1.117;
commitid	TJjhBRE5uqgTlzuN;

1.117
date	2014.12.22.23.26.20;	author schwarze;	state Exp;
branches;
next	1.116;
commitid	7lnT7ht5X6HoJfAt;

1.116
date	2014.12.20.02.26.42;	author schwarze;	state Exp;
branches;
next	1.115;
commitid	uca6hEcrcxivtoqC;

1.115
date	2014.12.18.20.58.00;	author schwarze;	state Exp;
branches;
next	1.114;
commitid	VbkUbSHmf7t0IQVK;

1.114
date	2014.12.18.03.09.42;	author schwarze;	state Exp;
branches;
next	1.113;
commitid	gf4J2ZJoC3QosoVG;

1.113
date	2014.12.13.13.13.26;	author schwarze;	state Exp;
branches;
next	1.112;
commitid	RH8Jz9QDDr5L3VlD;

1.112
date	2014.11.30.05.28.00;	author schwarze;	state Exp;
branches;
next	1.111;
commitid	4gOj8tbqcpkeLVbt;

1.111
date	2014.11.30.02.31.32;	author schwarze;	state Exp;
branches;
next	1.110;
commitid	2VPAWCQ5LDs66xdK;

1.110
date	2014.11.29.04.31.33;	author schwarze;	state Exp;
branches;
next	1.109;
commitid	JvgkDn0m82P4Q46o;

1.109
date	2014.11.29.03.37.28;	author schwarze;	state Exp;
branches;
next	1.108;
commitid	aqtIRSBVUjLd0Mqm;

1.108
date	2014.11.28.23.20.55;	author schwarze;	state Exp;
branches;
next	1.107;
commitid	t9mCLXjRHJDgC7uT;

1.107
date	2014.11.28.04.46.30;	author schwarze;	state Exp;
branches;
next	1.106;
commitid	epKhps1CyqFfkqD1;

1.106
date	2014.11.28.03.13.58;	author schwarze;	state Exp;
branches;
next	1.105;
commitid	ImMvSGeZONzvc96J;

1.105
date	2014.11.28.01.05.40;	author schwarze;	state Exp;
branches;
next	1.104;
commitid	AyxWGi7Dr0LL0dRV;

1.104
date	2014.11.27.22.27.40;	author schwarze;	state Exp;
branches;
next	1.103;
commitid	5z09nX8VCSvBpGIv;

1.103
date	2014.11.26.19.22.44;	author schwarze;	state Exp;
branches;
next	1.102;
commitid	NqZgHgjv0CyQISN3;

1.102
date	2014.11.25.03.04.32;	author schwarze;	state Exp;
branches;
next	1.101;
commitid	dDYiiilKcyMGuvD5;

1.101
date	2014.11.20.00.30.34;	author schwarze;	state Exp;
branches;
next	1.100;
commitid	MCznpt0ynpsp3gtZ;

1.100
date	2014.11.17.06.44.35;	author schwarze;	state Exp;
branches;
next	1.99;
commitid	eO1CUhWjZNit4m47;

1.99
date	2014.09.07.00.04.47;	author schwarze;	state Exp;
branches;
next	1.98;
commitid	JW3D5jXuOqHC1Ka6;

1.98
date	2014.08.21.12.56.24;	author schwarze;	state Exp;
branches;
next	1.97;
commitid	Y0pln4y7V0yebwer;

1.97
date	2014.08.16.19.47.17;	author schwarze;	state Exp;
branches;
next	1.96;
commitid	Ni7c0brRFygBMuOz;

1.96
date	2014.08.08.15.54.10;	author schwarze;	state Exp;
branches;
next	1.95;
commitid	yBKHNskikm52fHMo;

1.95
date	2014.08.08.15.26.28;	author schwarze;	state Exp;
branches;
next	1.94;
commitid	p7GwHxeS0xJRdvMp;

1.94
date	2014.07.07.21.35.42;	author schwarze;	state Exp;
branches;
next	1.93;
commitid	O2S43bw50KTGcriR;

1.93
date	2014.07.04.16.11.41;	author schwarze;	state Exp;
branches;
next	1.92;
commitid	sgqZ9hnRM3L6yvgn;

1.92
date	2014.07.02.20.18.42;	author schwarze;	state Exp;
branches;
next	1.91;
commitid	9LBCQenwbyZCIKCe;

1.91
date	2014.07.02.11.42.56;	author schwarze;	state Exp;
branches;
next	1.90;
commitid	aUdrdtDM8sKwymS7;

1.90
date	2014.07.02.08.21.12;	author schwarze;	state Exp;
branches;
next	1.89;
commitid	ryh2gTG4EAE4Z4wD;

1.89
date	2014.07.02.03.47.07;	author schwarze;	state Exp;
branches;
next	1.88;
commitid	p4pNII1v0bYCswy0;

1.88
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.87;

1.87
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.86;

1.86
date	2014.01.21.10.26.49;	author schwarze;	state Exp;
branches;
next	1.85;

1.85
date	2014.01.20.11.27.53;	author schwarze;	state Exp;
branches;
next	1.84;

1.84
date	2013.12.30.00.52.18;	author schwarze;	state Exp;
branches;
next	1.83;

1.83
date	2013.12.30.00.20.18;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2013.12.24.20.45.21;	author schwarze;	state Exp;
branches;
next	1.81;

1.81
date	2013.12.24.19.10.34;	author schwarze;	state Exp;
branches;
next	1.80;

1.80
date	2013.10.21.23.32.32;	author schwarze;	state Exp;
branches;
next	1.79;

1.79
date	2013.09.15.18.26.39;	author schwarze;	state Exp;
branches;
next	1.78;

1.78
date	2012.11.19.22.28.35;	author schwarze;	state Exp;
branches;
next	1.77;

1.77
date	2012.11.18.00.05.28;	author schwarze;	state Exp;
branches;
next	1.76;

1.76
date	2012.11.17.00.25.20;	author schwarze;	state Exp;
branches;
next	1.75;

1.75
date	2012.11.16.13.25.34;	author schwarze;	state Exp;
branches;
next	1.74;

1.74
date	2012.07.18.16.20.14;	author schwarze;	state Exp;
branches;
next	1.73;

1.73
date	2012.01.04.02.17.42;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2011.12.03.23.01.21;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2011.12.03.22.47.27;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2011.10.16.12.18.32;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.68;

1.68
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2011.04.24.16.49.10;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.65;

1.65
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.64;

1.64
date	2011.01.30.18.28.01;	author schwarze;	state Exp;
branches;
next	1.63;

1.63
date	2011.01.16.19.27.25;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2010.12.21.23.46.18;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2010.12.01.22.02.29;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2010.10.24.18.15.43;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2010.10.16.13.38.29;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2010.10.01.21.38.26;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2010.09.26.20.19.58;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2010.07.16.00.34.33;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.01.22.31.52;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.01.21.08.50;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.01.15.36.59;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.30.03.57.49;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.29.19.42.03;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.29.18.01.10;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2010.06.29.17.10.29;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.06.20.30.08;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2010.06.06.18.08.41;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2010.05.23.22.45.00;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2010.05.15.15.53.29;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.15.15.37.53;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2010.05.15.13.12.55;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2010.05.15.12.30.59;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2010.05.15.09.20.01;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.14.19.52.43;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.14.14.47.44;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.14.01.54.37;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2010.04.07.23.15.05;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2010.04.02.12.39.47;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2010.04.02.11.39.00;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2010.04.02.11.37.07;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2010.03.02.00.38.59;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2010.03.02.00.13.57;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2010.02.26.12.12.24;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2010.02.18.02.11.26;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.01.19.24.07;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.21.21.11.37;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.22.22.39.55;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.22.21.55.06;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.22.19.43.33;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.22.15.36.58;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.09.21.59.41;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.09.19.59.13;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.09.17.13.00;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.09.17.02.46;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.09.16.36.45;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2009.07.26.23.48.01;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.26.01.59.46;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.18.15.34.27;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.12.23.19.48;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.12.22.35.08;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.12.21.45.44;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.12.21.08.29;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.12.20.30.27;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.12.19.05.52;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.12.18.35.57;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.18.23.34.53;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.18.01.19.02;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.14.23.00.57;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.20.30.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.174
log
@Fix block scoping error if an explicit block is broken by two
implicit blocks (.Aq Bq Po .Pc) that left the outer breaker open
and could in exceptional cases, like between .Bl and .It, cause
tree corruption leading to NULL dereference.
Found by tb@@ with afl(1).

While here, do not mark intermediate ENDBODY markers as broken.
@
text
@/*	$OpenBSD: mdoc_macro.c,v 1.173 2017/02/16 02:59:42 schwarze Exp $ */
/*
 * Copyright (c) 2008-2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010, 2012-2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "libmandoc.h"
#include "roff_int.h"
#include "libmdoc.h"

static	void		blk_full(MACRO_PROT_ARGS);
static	void		blk_exp_close(MACRO_PROT_ARGS);
static	void		blk_part_exp(MACRO_PROT_ARGS);
static	void		blk_part_imp(MACRO_PROT_ARGS);
static	void		ctx_synopsis(MACRO_PROT_ARGS);
static	void		in_line_eoln(MACRO_PROT_ARGS);
static	void		in_line_argn(MACRO_PROT_ARGS);
static	void		in_line(MACRO_PROT_ARGS);
static	void		phrase_ta(MACRO_PROT_ARGS);

static	void		append_delims(struct roff_man *, int, int *, char *);
static	void		dword(struct roff_man *, int, int, const char *,
				enum mdelim, int);
static	int		find_pending(struct roff_man *, int, int, int,
				struct roff_node *);
static	int		lookup(struct roff_man *, int, int, int, const char *);
static	int		macro_or_word(MACRO_PROT_ARGS, int);
static	void		break_intermediate(struct roff_node *,
			    struct roff_node *);
static	int		parse_rest(struct roff_man *, int, int, int *, char *);
static	int		rew_alt(int);
static	void		rew_elem(struct roff_man *, int);
static	void		rew_last(struct roff_man *, const struct roff_node *);
static	void		rew_pending(struct roff_man *,
				const struct roff_node *);

const	struct mdoc_macro __mdoc_macros[MDOC_MAX] = {
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Ap */
	{ in_line_eoln, MDOC_PROLOGUE }, /* Dd */
	{ in_line_eoln, MDOC_PROLOGUE }, /* Dt */
	{ in_line_eoln, MDOC_PROLOGUE }, /* Os */
	{ blk_full, MDOC_PARSED | MDOC_JOIN }, /* Sh */
	{ blk_full, MDOC_PARSED | MDOC_JOIN }, /* Ss */
	{ in_line_eoln, 0 }, /* Pp */
	{ blk_part_imp, MDOC_PARSED | MDOC_JOIN }, /* D1 */
	{ blk_part_imp, MDOC_PARSED | MDOC_JOIN }, /* Dl */
	{ blk_full, MDOC_EXPLICIT }, /* Bd */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_JOIN }, /* Ed */
	{ blk_full, MDOC_EXPLICIT }, /* Bl */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_JOIN }, /* El */
	{ blk_full, MDOC_PARSED | MDOC_JOIN }, /* It */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ad */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* An */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ar */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Cd */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Cm */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Dv */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Er */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ev */
	{ in_line_eoln, 0 }, /* Ex */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Fa */
	{ in_line_eoln, 0 }, /* Fd */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Fl */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Fn */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ft */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Ic */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* In */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Li */
	{ blk_full, MDOC_JOIN }, /* Nd */
	{ ctx_synopsis, MDOC_CALLABLE | MDOC_PARSED }, /* Nm */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Op */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ot */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Pa */
	{ in_line_eoln, 0 }, /* Rv */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* St */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Va */
	{ ctx_synopsis, MDOC_CALLABLE | MDOC_PARSED }, /* Vt */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Xr */
	{ in_line_eoln, MDOC_JOIN }, /* %A */
	{ in_line_eoln, MDOC_JOIN }, /* %B */
	{ in_line_eoln, MDOC_JOIN }, /* %D */
	{ in_line_eoln, MDOC_JOIN }, /* %I */
	{ in_line_eoln, MDOC_JOIN }, /* %J */
	{ in_line_eoln, 0 }, /* %N */
	{ in_line_eoln, MDOC_JOIN }, /* %O */
	{ in_line_eoln, 0 }, /* %P */
	{ in_line_eoln, MDOC_JOIN }, /* %R */
	{ in_line_eoln, MDOC_JOIN }, /* %T */
	{ in_line_eoln, 0 }, /* %V */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Ac */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Ao */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Aq */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* At */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Bc */
	{ blk_full, MDOC_EXPLICIT }, /* Bf */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Bo */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Bq */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Bsx */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Bx */
	{ in_line_eoln, 0 }, /* Db */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Dc */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Do */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Dq */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Ec */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_JOIN }, /* Ef */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Em */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Eo */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Fx */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ms */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* No */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_IGNDELIM | MDOC_JOIN }, /* Ns */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Nx */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Ox */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Pc */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED | MDOC_IGNDELIM }, /* Pf */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Po */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Pq */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Qc */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Ql */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Qo */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Qq */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_JOIN }, /* Re */
	{ blk_full, MDOC_EXPLICIT }, /* Rs */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Sc */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* So */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Sq */
	{ in_line_argn, 0 }, /* Sm */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Sx */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Sy */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Tn */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Ux */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Xc */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Xo */
	{ blk_full, MDOC_EXPLICIT | MDOC_CALLABLE }, /* Fo */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Fc */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Oo */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Oc */
	{ blk_full, MDOC_EXPLICIT }, /* Bk */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_JOIN }, /* Ek */
	{ in_line_eoln, 0 }, /* Bt */
	{ in_line_eoln, 0 }, /* Hf */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Fr */
	{ in_line_eoln, 0 }, /* Ud */
	{ in_line, 0 }, /* Lb */
	{ in_line_eoln, 0 }, /* Lp */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Lk */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Mt */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Brq */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Bro */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Brc */
	{ in_line_eoln, MDOC_JOIN }, /* %C */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Es */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* En */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Dx */
	{ in_line_eoln, MDOC_JOIN }, /* %Q */
	{ in_line_eoln, 0 }, /* br */
	{ in_line_eoln, 0 }, /* sp */
	{ in_line_eoln, 0 }, /* %U */
	{ phrase_ta, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Ta */
	{ in_line_eoln, MDOC_PROLOGUE }, /* ll */
};

const	struct mdoc_macro * const mdoc_macros = __mdoc_macros;


/*
 * This is called at the end of parsing.  It must traverse up the tree,
 * closing out open [implicit] scopes.  Obviously, open explicit scopes
 * are errors.
 */
void
mdoc_endparse(struct roff_man *mdoc)
{
	struct roff_node *n;

	/* Scan for open explicit scopes. */

	n = mdoc->last->flags & NODE_VALID ?
	    mdoc->last->parent : mdoc->last;

	for ( ; n; n = n->parent)
		if (n->type == ROFFT_BLOCK &&
		    mdoc_macros[n->tok].flags & MDOC_EXPLICIT)
			mandoc_msg(MANDOCERR_BLK_NOEND, mdoc->parse,
			    n->line, n->pos, mdoc_macronames[n->tok]);

	/* Rewind to the first. */

	rew_last(mdoc, mdoc->first);
	mdoc_state_reset(mdoc);
}

/*
 * Look up the macro at *p called by "from",
 * or as a line macro if from == TOKEN_NONE.
 */
static int
lookup(struct roff_man *mdoc, int from, int line, int ppos, const char *p)
{
	int	 res;

	if (mdoc->flags & MDOC_PHRASEQF) {
		mdoc->flags &= ~MDOC_PHRASEQF;
		return TOKEN_NONE;
	}
	if (from == TOKEN_NONE || mdoc_macros[from].flags & MDOC_PARSED) {
		res = mdoc_hash_find(p);
		if (res != TOKEN_NONE) {
			if (mdoc_macros[res].flags & MDOC_CALLABLE)
				return res;
			if (res != MDOC_br && res != MDOC_sp && res != MDOC_ll)
				mandoc_msg(MANDOCERR_MACRO_CALL,
				    mdoc->parse, line, ppos, p);
		}
	}
	return TOKEN_NONE;
}

/*
 * Rewind up to and including a specific node.
 */
static void
rew_last(struct roff_man *mdoc, const struct roff_node *to)
{

	if (to->flags & NODE_VALID)
		return;

	while (mdoc->last != to) {
		mdoc_state(mdoc, mdoc->last);
		mdoc->last->flags |= NODE_VALID | NODE_ENDED;
		mdoc->last = mdoc->last->parent;
	}
	mdoc_state(mdoc, mdoc->last);
	mdoc->last->flags |= NODE_VALID | NODE_ENDED;
	mdoc->next = ROFF_NEXT_SIBLING;
}

/*
 * Rewind up to a specific block, including all blocks that broke it.
 */
static void
rew_pending(struct roff_man *mdoc, const struct roff_node *n)
{

	for (;;) {
		rew_last(mdoc, n);

		if (mdoc->last == n) {
			switch (n->type) {
			case ROFFT_HEAD:
				roff_body_alloc(mdoc, n->line, n->pos,
				    n->tok);
				break;
			case ROFFT_BLOCK:
				break;
			default:
				return;
			}
			if ( ! (n->flags & NODE_BROKEN))
				return;
		} else
			n = mdoc->last;

		for (;;) {
			if ((n = n->parent) == NULL)
				return;

			if (n->type == ROFFT_BLOCK ||
			    n->type == ROFFT_HEAD) {
				if (n->flags & NODE_ENDED)
					break;
				else
					return;
			}
		}
	}
}

/*
 * For a block closing macro, return the corresponding opening one.
 * Otherwise, return the macro itself.
 */
static int
rew_alt(int tok)
{
	switch (tok) {
	case MDOC_Ac:
		return MDOC_Ao;
	case MDOC_Bc:
		return MDOC_Bo;
	case MDOC_Brc:
		return MDOC_Bro;
	case MDOC_Dc:
		return MDOC_Do;
	case MDOC_Ec:
		return MDOC_Eo;
	case MDOC_Ed:
		return MDOC_Bd;
	case MDOC_Ef:
		return MDOC_Bf;
	case MDOC_Ek:
		return MDOC_Bk;
	case MDOC_El:
		return MDOC_Bl;
	case MDOC_Fc:
		return MDOC_Fo;
	case MDOC_Oc:
		return MDOC_Oo;
	case MDOC_Pc:
		return MDOC_Po;
	case MDOC_Qc:
		return MDOC_Qo;
	case MDOC_Re:
		return MDOC_Rs;
	case MDOC_Sc:
		return MDOC_So;
	case MDOC_Xc:
		return MDOC_Xo;
	default:
		return tok;
	}
}

static void
rew_elem(struct roff_man *mdoc, int tok)
{
	struct roff_node *n;

	n = mdoc->last;
	if (n->type != ROFFT_ELEM)
		n = n->parent;
	assert(n->type == ROFFT_ELEM);
	assert(tok == n->tok);
	rew_last(mdoc, n);
}

static void
break_intermediate(struct roff_node *n, struct roff_node *breaker)
{
	if (n != breaker &&
	    n->type != ROFFT_BLOCK && n->type != ROFFT_HEAD &&
	    (n->type != ROFFT_BODY || n->end != ENDBODY_NOT))
		n = n->parent;
	while (n != breaker) {
		if ( ! (n->flags & NODE_VALID))
			n->flags |= NODE_BROKEN;
		n = n->parent;
	}
}

/*
 * If there is an open sub-block of the target requiring
 * explicit close-out, postpone closing out the target until
 * the rew_pending() call closing out the sub-block.
 */
static int
find_pending(struct roff_man *mdoc, int tok, int line, int ppos,
	struct roff_node *target)
{
	struct roff_node	*n;
	int			 irc;

	if (target->flags & NODE_VALID)
		return 0;

	irc = 0;
	for (n = mdoc->last; n != NULL && n != target; n = n->parent) {
		if (n->flags & NODE_ENDED)
			continue;
		if (n->type == ROFFT_BLOCK &&
		    mdoc_macros[n->tok].flags & MDOC_EXPLICIT) {
			irc = 1;
			break_intermediate(mdoc->last, target);
			if (target->type == ROFFT_HEAD)
				target->flags |= NODE_ENDED;
			else if ( ! (target->flags & NODE_ENDED)) {
				mandoc_vmsg(MANDOCERR_BLK_NEST,
				    mdoc->parse, line, ppos,
				    "%s breaks %s", mdoc_macronames[tok],
				    mdoc_macronames[n->tok]);
				mdoc_endbody_alloc(mdoc, line, ppos,
				    tok, target);
			}
		}
	}
	return irc;
}

/*
 * Allocate a word and check whether it's punctuation or not.
 * Punctuation consists of those tokens found in mdoc_isdelim().
 */
static void
dword(struct roff_man *mdoc, int line, int col, const char *p,
		enum mdelim d, int may_append)
{

	if (d == DELIM_MAX)
		d = mdoc_isdelim(p);

	if (may_append &&
	    ! (mdoc->flags & (MDOC_SYNOPSIS | MDOC_KEEP | MDOC_SMOFF)) &&
	    d == DELIM_NONE && mdoc->last->type == ROFFT_TEXT &&
	    mdoc_isdelim(mdoc->last->string) == DELIM_NONE) {
		roff_word_append(mdoc, p);
		return;
	}

	roff_word_alloc(mdoc, line, col, p);

	/*
	 * If the word consists of a bare delimiter,
	 * flag the new node accordingly,
	 * unless doing so was vetoed by the invoking macro.
	 * Always clear the veto, it is only valid for one word.
	 */

	if (d == DELIM_OPEN)
		mdoc->last->flags |= NODE_DELIMO;
	else if (d == DELIM_CLOSE &&
	    ! (mdoc->flags & MDOC_NODELIMC) &&
	    mdoc->last->parent->tok != MDOC_Fd)
		mdoc->last->flags |= NODE_DELIMC;
	mdoc->flags &= ~MDOC_NODELIMC;
}

static void
append_delims(struct roff_man *mdoc, int line, int *pos, char *buf)
{
	char		*p;
	int		 la;

	if (buf[*pos] == '\0')
		return;

	for (;;) {
		la = *pos;
		if (mdoc_args(mdoc, line, pos, buf, TOKEN_NONE, &p) ==
		    ARGS_EOLN)
			break;
		dword(mdoc, line, la, p, DELIM_MAX, 1);

		/*
		 * If we encounter end-of-sentence symbols, then trigger
		 * the double-space.
		 *
		 * XXX: it's easy to allow this to propagate outward to
		 * the last symbol, such that `. )' will cause the
		 * correct double-spacing.  However, (1) groff isn't
		 * smart enough to do this and (2) it would require
		 * knowing which symbols break this behaviour, for
		 * example, `.  ;' shouldn't propagate the double-space.
		 */

		if (mandoc_eos(p, strlen(p)))
			mdoc->last->flags |= NODE_EOS;
	}
}

/*
 * Parse one word.
 * If it is a macro, call it and return 1.
 * Otherwise, allocate it and return 0.
 */
static int
macro_or_word(MACRO_PROT_ARGS, int parsed)
{
	char		*p;
	int		 ntok;

	p = buf + ppos;
	ntok = TOKEN_NONE;
	if (*p == '"')
		p++;
	else if (parsed && ! (mdoc->flags & MDOC_PHRASELIT))
		ntok = lookup(mdoc, tok, line, ppos, p);

	if (ntok == TOKEN_NONE) {
		dword(mdoc, line, ppos, p, DELIM_MAX, tok == TOKEN_NONE ||
		    mdoc_macros[tok].flags & MDOC_JOIN);
		return 0;
	} else {
		if (mdoc_macros[tok].fp == in_line_eoln)
			rew_elem(mdoc, tok);
		mdoc_macro(mdoc, ntok, line, ppos, pos, buf);
		if (tok == TOKEN_NONE)
			append_delims(mdoc, line, pos, buf);
		return 1;
	}
}

/*
 * Close out block partial/full explicit.
 */
static void
blk_exp_close(MACRO_PROT_ARGS)
{
	struct roff_node *body;		/* Our own body. */
	struct roff_node *endbody;	/* Our own end marker. */
	struct roff_node *itblk;	/* An It block starting later. */
	struct roff_node *later;	/* A sub-block starting later. */
	struct roff_node *n;		/* Search back to our block. */
	struct roff_node *target;	/* For find_pending(). */

	int		 j, lastarg, maxargs, nl, pending;
	enum margserr	 ac;
	int		 atok, ntok;
	char		*p;

	nl = MDOC_NEWLINE & mdoc->flags;

	switch (tok) {
	case MDOC_Ec:
		maxargs = 1;
		break;
	case MDOC_Ek:
		mdoc->flags &= ~MDOC_KEEP;
		/* FALLTHROUGH */
	default:
		maxargs = 0;
		break;
	}

	/* Search backwards for the beginning of our own body. */

	atok = rew_alt(tok);
	body = NULL;
	for (n = mdoc->last; n; n = n->parent) {
		if (n->flags & NODE_ENDED || n->tok != atok ||
		    n->type != ROFFT_BODY || n->end != ENDBODY_NOT)
			continue;
		body = n;
		break;
	}

	/*
	 * Search backwards for beginnings of blocks,
	 * both of our own and of pending sub-blocks.
	 */

	endbody = itblk = later = NULL;
	for (n = mdoc->last; n; n = n->parent) {
		if (n->flags & NODE_ENDED)
			continue;

		/*
		 * Mismatching end macros can never break anything
		 * and we only care about the breaking of BLOCKs.
		 */

		if (body == NULL || n->type != ROFFT_BLOCK)
			continue;

		/*
		 * SYNOPSIS name blocks can not be broken themselves,
		 * but they do get broken together with a broken child.
		 */

		if (n->tok == MDOC_Nm) {
			if (later != NULL)
				n->flags |= NODE_BROKEN | NODE_ENDED;
			continue;
		}

		if (n->tok == MDOC_It) {
			itblk = n;
			continue;
		}

		if (atok == n->tok) {

			/*
			 * Found the start of our own block.
			 * When there is no pending sub block,
			 * just proceed to closing out.
			 */

			if (later == NULL ||
			    (tok == MDOC_El && itblk == NULL))
				break;

			/*
			 * When there is a pending sub block, postpone
			 * closing out the current block until the
			 * rew_pending() closing out the sub-block.
			 * Mark the place where the formatting - but not
			 * the scope - of the current block ends.
			 */

			mandoc_vmsg(MANDOCERR_BLK_NEST, mdoc->parse,
			    line, ppos, "%s breaks %s",
			    mdoc_macronames[atok],
			    mdoc_macronames[later->tok]);

			endbody = mdoc_endbody_alloc(mdoc, line, ppos,
			    atok, body);

			if (tok == MDOC_El)
				itblk->flags |= NODE_ENDED | NODE_BROKEN;

			/*
			 * If a block closing macro taking arguments
			 * breaks another block, put the arguments
			 * into the end marker.
			 */

			if (maxargs)
				mdoc->next = ROFF_NEXT_CHILD;
			break;
		}

		/*
		 * Explicit blocks close out description lines, but
		 * even those can get broken together with a child.
		 */

		if (n->tok == MDOC_Nd) {
			if (later != NULL)
				n->flags |= NODE_BROKEN | NODE_ENDED;
			else
				rew_last(mdoc, n);
			continue;
		}

		/* Breaking an open sub block. */

		break_intermediate(mdoc->last, body);
		n->flags |= NODE_BROKEN;
		if (later == NULL)
			later = n;
	}

	if (body == NULL) {
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, mdoc->parse,
		    line, ppos, mdoc_macronames[tok]);
		if (maxargs && endbody == NULL) {
			/*
			 * Stray .Ec without previous .Eo:
			 * Break the output line, keep the arguments.
			 */
			roff_elem_alloc(mdoc, line, ppos, MDOC_br);
			rew_elem(mdoc, MDOC_br);
		}
	} else if (endbody == NULL) {
		rew_last(mdoc, body);
		if (maxargs)
			mdoc_tail_alloc(mdoc, line, ppos, atok);
	}

	if ( ! (mdoc_macros[tok].flags & MDOC_PARSED)) {
		if (buf[*pos] != '\0')
			mandoc_vmsg(MANDOCERR_ARG_SKIP,
			    mdoc->parse, line, ppos,
			    "%s %s", mdoc_macronames[tok],
			    buf + *pos);
		if (endbody == NULL && n != NULL)
			rew_pending(mdoc, n);
		return;
	}

	if (endbody != NULL)
		n = endbody;

	ntok = TOKEN_NONE;
	for (j = 0; ; j++) {
		lastarg = *pos;

		if (j == maxargs && n != NULL)
			rew_last(mdoc, n);

		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);
		if (ac == ARGS_PUNCT || ac == ARGS_EOLN)
			break;

		ntok = ac == ARGS_QWORD ? TOKEN_NONE :
		    lookup(mdoc, tok, line, lastarg, p);

		if (ntok == TOKEN_NONE) {
			dword(mdoc, line, lastarg, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags);
			continue;
		}

		if (n != NULL)
			rew_last(mdoc, n);
		mdoc->flags &= ~MDOC_NEWLINE;
		mdoc_macro(mdoc, ntok, line, lastarg, pos, buf);
		break;
	}

	if (n != NULL) {
		pending = 0;
		if (ntok != TOKEN_NONE && n->flags & NODE_BROKEN) {
			target = n;
			do
				target = target->parent;
			while ( ! (target->flags & NODE_ENDED));
			pending = find_pending(mdoc, ntok, line, ppos, target);
		}
		if ( ! pending)
			rew_pending(mdoc, n);
	}
	if (nl)
		append_delims(mdoc, line, pos, buf);
}

static void
in_line(MACRO_PROT_ARGS)
{
	int		 la, scope, cnt, firstarg, mayopen, nc, nl;
	int		 ntok;
	enum margserr	 ac;
	enum mdelim	 d;
	struct mdoc_arg	*arg;
	char		*p;

	nl = MDOC_NEWLINE & mdoc->flags;

	/*
	 * Whether we allow ignored elements (those without content,
	 * usually because of reserved words) to squeak by.
	 */

	switch (tok) {
	case MDOC_An:
	case MDOC_Ar:
	case MDOC_Fl:
	case MDOC_Mt:
	case MDOC_Nm:
	case MDOC_Pa:
		nc = 1;
		break;
	default:
		nc = 0;
		break;
	}

	mdoc_argv(mdoc, line, tok, &arg, pos, buf);

	d = DELIM_NONE;
	firstarg = 1;
	mayopen = 1;
	for (cnt = scope = 0;; ) {
		la = *pos;
		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);

		/*
		 * At the end of a macro line,
		 * opening delimiters do not suppress spacing.
		 */

		if (ac == ARGS_EOLN) {
			if (d == DELIM_OPEN)
				mdoc->last->flags &= ~NODE_DELIMO;
			break;
		}

		/*
		 * The rest of the macro line is only punctuation,
		 * to be handled by append_delims().
		 * If there were no other arguments,
		 * do not allow the first one to suppress spacing,
		 * even if it turns out to be a closing one.
		 */

		if (ac == ARGS_PUNCT) {
			if (cnt == 0 && (nc == 0 || tok == MDOC_An))
				mdoc->flags |= MDOC_NODELIMC;
			break;
		}

		ntok = (ac == ARGS_QWORD || (tok == MDOC_Fn && !cnt)) ?
		    TOKEN_NONE : lookup(mdoc, tok, line, la, p);

		/*
		 * In this case, we've located a submacro and must
		 * execute it.  Close out scope, if open.  If no
		 * elements have been generated, either create one (nc)
		 * or raise a warning.
		 */

		if (ntok != TOKEN_NONE) {
			if (scope)
				rew_elem(mdoc, tok);
			if (nc && ! cnt) {
				mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
				rew_last(mdoc, mdoc->last);
			} else if ( ! nc && ! cnt) {
				mdoc_argv_free(arg);
				mandoc_msg(MANDOCERR_MACRO_EMPTY,
				    mdoc->parse, line, ppos,
				    mdoc_macronames[tok]);
			}
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
			if (nl)
				append_delims(mdoc, line, pos, buf);
			return;
		}

		/*
		 * Non-quote-enclosed punctuation.  Set up our scope, if
		 * a word; rewind the scope, if a delimiter; then append
		 * the word.
		 */

		d = ac == ARGS_QWORD ? DELIM_NONE : mdoc_isdelim(p);

		if (DELIM_NONE != d) {
			/*
			 * If we encounter closing punctuation, no word
			 * has been emitted, no scope is open, and we're
			 * allowed to have an empty element, then start
			 * a new scope.
			 */
			if ((d == DELIM_CLOSE ||
			     (d == DELIM_MIDDLE && tok == MDOC_Fl)) &&
			    !cnt && !scope && nc && mayopen) {
				mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
				scope = 1;
				cnt++;
				if (tok == MDOC_Nm)
					mayopen = 0;
			}
			/*
			 * Close out our scope, if one is open, before
			 * any punctuation.
			 */
			if (scope)
				rew_elem(mdoc, tok);
			scope = 0;
			if (tok == MDOC_Fn)
				mayopen = 0;
		} else if (mayopen && !scope) {
			mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
			scope = 1;
			cnt++;
		}

		dword(mdoc, line, la, p, d,
		    MDOC_JOIN & mdoc_macros[tok].flags);

		/*
		 * If the first argument is a closing delimiter,
		 * do not suppress spacing before it.
		 */

		if (firstarg && d == DELIM_CLOSE && !nc)
			mdoc->last->flags &= ~NODE_DELIMC;
		firstarg = 0;

		/*
		 * `Fl' macros have their scope re-opened with each new
		 * word so that the `-' can be added to each one without
		 * having to parse out spaces.
		 */
		if (scope && tok == MDOC_Fl) {
			rew_elem(mdoc, tok);
			scope = 0;
		}
	}

	if (scope)
		rew_elem(mdoc, tok);

	/*
	 * If no elements have been collected and we're allowed to have
	 * empties (nc), open a scope and close it out.  Otherwise,
	 * raise a warning.
	 */

	if ( ! cnt) {
		if (nc) {
			mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
			rew_last(mdoc, mdoc->last);
		} else {
			mdoc_argv_free(arg);
			mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
			    line, ppos, mdoc_macronames[tok]);
		}
	}
	if (nl)
		append_delims(mdoc, line, pos, buf);
}

static void
blk_full(MACRO_PROT_ARGS)
{
	int		  la, nl, parsed;
	struct mdoc_arg	 *arg;
	struct roff_node *blk; /* Our own or a broken block. */
	struct roff_node *head; /* Our own head. */
	struct roff_node *body; /* Our own body. */
	struct roff_node *n;
	enum margserr	  ac, lac;
	char		 *p;

	nl = MDOC_NEWLINE & mdoc->flags;

	if (buf[*pos] == '\0' && (tok == MDOC_Sh || tok == MDOC_Ss)) {
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
		    line, ppos, mdoc_macronames[tok]);
		return;
	}

	if ( ! (mdoc_macros[tok].flags & MDOC_EXPLICIT)) {

		/* Here, tok is one of Sh Ss Nm Nd It. */

		blk = NULL;
		for (n = mdoc->last; n != NULL; n = n->parent) {
			if (n->flags & NODE_ENDED) {
				if ( ! (n->flags & NODE_VALID))
					n->flags |= NODE_BROKEN;
				continue;
			}
			if (n->type != ROFFT_BLOCK)
				continue;

			if (tok == MDOC_It && n->tok == MDOC_Bl) {
				if (blk != NULL) {
					mandoc_vmsg(MANDOCERR_BLK_BROKEN,
					    mdoc->parse, line, ppos,
					    "It breaks %s",
					    mdoc_macronames[blk->tok]);
					rew_pending(mdoc, blk);
				}
				break;
			}

			if (mdoc_macros[n->tok].flags & MDOC_EXPLICIT) {
				switch (tok) {
				case MDOC_Sh:
				case MDOC_Ss:
					mandoc_vmsg(MANDOCERR_BLK_BROKEN,
					    mdoc->parse, line, ppos,
					    "%s breaks %s",
					    mdoc_macronames[tok],
					    mdoc_macronames[n->tok]);
					rew_pending(mdoc, n);
					n = mdoc->last;
					continue;
				case MDOC_It:
					/* Delay in case it's astray. */
					blk = n;
					continue;
				default:
					break;
				}
				break;
			}

			/* Here, n is one of Sh Ss Nm Nd It. */

			if (tok != MDOC_Sh && (n->tok == MDOC_Sh ||
			    (tok != MDOC_Ss && (n->tok == MDOC_Ss ||
			     (tok != MDOC_It && n->tok == MDOC_It)))))
				break;

			/* Item breaking an explicit block. */

			if (blk != NULL) {
				mandoc_vmsg(MANDOCERR_BLK_BROKEN,
				    mdoc->parse, line, ppos,
				    "It breaks %s",
				    mdoc_macronames[blk->tok]);
				rew_pending(mdoc, blk);
				blk = NULL;
			}

			/* Close out prior implicit scopes. */

			rew_pending(mdoc, n);
		}

		/* Skip items outside lists. */

		if (tok == MDOC_It && (n == NULL || n->tok != MDOC_Bl)) {
			mandoc_vmsg(MANDOCERR_IT_STRAY, mdoc->parse,
			    line, ppos, "It %s", buf + *pos);
			roff_elem_alloc(mdoc, line, ppos, MDOC_br);
			rew_elem(mdoc, MDOC_br);
			return;
		}
	}

	/*
	 * This routine accommodates implicitly- and explicitly-scoped
	 * macro openings.  Implicit ones first close out prior scope
	 * (seen above).  Delay opening the head until necessary to
	 * allow leading punctuation to print.  Special consideration
	 * for `It -column', which has phrase-part syntax instead of
	 * regular child nodes.
	 */

	mdoc_argv(mdoc, line, tok, &arg, pos, buf);
	blk = mdoc_block_alloc(mdoc, line, ppos, tok, arg);
	head = body = NULL;

	/*
	 * Exception: Heads of `It' macros in `-diag' lists are not
	 * parsed, even though `It' macros in general are parsed.
	 */

	parsed = tok != MDOC_It ||
	    mdoc->last->parent->tok != MDOC_Bl ||
	    mdoc->last->parent->norm->Bl.type != LIST_diag;

	/*
	 * The `Nd' macro has all arguments in its body: it's a hybrid
	 * of block partial-explicit and full-implicit.  Stupid.
	 */

	if (tok == MDOC_Nd) {
		head = roff_head_alloc(mdoc, line, ppos, tok);
		rew_last(mdoc, head);
		body = roff_body_alloc(mdoc, line, ppos, tok);
	}

	if (tok == MDOC_Bk)
		mdoc->flags |= MDOC_KEEP;

	ac = ARGS_EOLN;
	for (;;) {

		/*
		 * If we are right after a tab character,
		 * do not parse the first word for macros.
		 */

		if (mdoc->flags & MDOC_PHRASEQN) {
			mdoc->flags &= ~MDOC_PHRASEQN;
			mdoc->flags |= MDOC_PHRASEQF;
		}

		la = *pos;
		lac = ac;
		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);
		if (ac == ARGS_EOLN) {
			if (lac != ARGS_PHRASE ||
			    ! (mdoc->flags & MDOC_PHRASEQF))
				break;

			/*
			 * This line ends in a tab; start the next
			 * column now, with a leading blank.
			 */

			if (body != NULL)
				rew_last(mdoc, body);
			body = roff_body_alloc(mdoc, line, ppos, tok);
			roff_word_alloc(mdoc, line, ppos, "\\&");
			break;
		}

		if (tok == MDOC_Bd || tok == MDOC_Bk) {
			mandoc_vmsg(MANDOCERR_ARG_EXCESS,
			    mdoc->parse, line, la, "%s ... %s",
			    mdoc_macronames[tok], buf + la);
			break;
		}
		if (tok == MDOC_Rs) {
			mandoc_vmsg(MANDOCERR_ARG_SKIP, mdoc->parse,
			    line, la, "Rs %s", buf + la);
			break;
		}
		if (ac == ARGS_PUNCT)
			break;

		/*
		 * Emit leading punctuation (i.e., punctuation before
		 * the ROFFT_HEAD) for non-phrase types.
		 */

		if (head == NULL &&
		    ac != ARGS_PHRASE &&
		    ac != ARGS_QWORD &&
		    mdoc_isdelim(p) == DELIM_OPEN) {
			dword(mdoc, line, la, p, DELIM_OPEN, 0);
			continue;
		}

		/* Open a head if one hasn't been opened. */

		if (head == NULL)
			head = roff_head_alloc(mdoc, line, ppos, tok);

		if (ac == ARGS_PHRASE) {

			/*
			 * If we haven't opened a body yet, rewind the
			 * head; if we have, rewind that instead.
			 */

			rew_last(mdoc, body == NULL ? head : body);
			body = roff_body_alloc(mdoc, line, ppos, tok);

			/* Process to the tab or to the end of the line. */

			mdoc->flags |= MDOC_PHRASE;
			parse_rest(mdoc, TOKEN_NONE, line, &la, buf);
			mdoc->flags &= ~MDOC_PHRASE;

			/* There may have been `Ta' macros. */

			while (body->next != NULL)
				body = body->next;
			continue;
		}

		if (macro_or_word(mdoc, tok, line, la, pos, buf, parsed))
			break;
	}

	if (blk->flags & NODE_VALID)
		return;
	if (head == NULL)
		head = roff_head_alloc(mdoc, line, ppos, tok);
	if (nl && tok != MDOC_Bd && tok != MDOC_Bl && tok != MDOC_Rs)
		append_delims(mdoc, line, pos, buf);
	if (body != NULL)
		goto out;
	if (find_pending(mdoc, tok, line, ppos, head))
		return;

	/* Close out scopes to remain in a consistent state. */

	rew_last(mdoc, head);
	body = roff_body_alloc(mdoc, line, ppos, tok);
out:
	if (mdoc->flags & MDOC_FREECOL) {
		rew_last(mdoc, body);
		rew_last(mdoc, blk);
		mdoc->flags &= ~MDOC_FREECOL;
	}
}

static void
blk_part_imp(MACRO_PROT_ARGS)
{
	int		  la, nl;
	enum margserr	  ac;
	char		 *p;
	struct roff_node *blk; /* saved block context */
	struct roff_node *body; /* saved body context */
	struct roff_node *n;

	nl = MDOC_NEWLINE & mdoc->flags;

	/*
	 * A macro that spans to the end of the line.  This is generally
	 * (but not necessarily) called as the first macro.  The block
	 * has a head as the immediate child, which is always empty,
	 * followed by zero or more opening punctuation nodes, then the
	 * body (which may be empty, depending on the macro), then zero
	 * or more closing punctuation nodes.
	 */

	blk = mdoc_block_alloc(mdoc, line, ppos, tok, NULL);
	rew_last(mdoc, roff_head_alloc(mdoc, line, ppos, tok));

	/*
	 * Open the body scope "on-demand", that is, after we've
	 * processed all our the leading delimiters (open parenthesis,
	 * etc.).
	 */

	for (body = NULL; ; ) {
		la = *pos;
		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);
		if (ac == ARGS_EOLN || ac == ARGS_PUNCT)
			break;

		if (body == NULL && ac != ARGS_QWORD &&
		    mdoc_isdelim(p) == DELIM_OPEN) {
			dword(mdoc, line, la, p, DELIM_OPEN, 0);
			continue;
		}

		if (body == NULL)
			body = roff_body_alloc(mdoc, line, ppos, tok);

		if (macro_or_word(mdoc, tok, line, la, pos, buf, 1))
			break;
	}
	if (body == NULL)
		body = roff_body_alloc(mdoc, line, ppos, tok);

	if (find_pending(mdoc, tok, line, ppos, body))
		return;

	rew_last(mdoc, body);
	if (nl)
		append_delims(mdoc, line, pos, buf);
	rew_pending(mdoc, blk);

	/* Move trailing .Ns out of scope. */

	for (n = body->child; n && n->next; n = n->next)
		/* Do nothing. */ ;
	if (n && n->tok == MDOC_Ns)
		mdoc_node_relink(mdoc, n);
}

static void
blk_part_exp(MACRO_PROT_ARGS)
{
	int		  la, nl;
	enum margserr	  ac;
	struct roff_node *head; /* keep track of head */
	char		 *p;

	nl = MDOC_NEWLINE & mdoc->flags;

	/*
	 * The opening of an explicit macro having zero or more leading
	 * punctuation nodes; a head with optional single element (the
	 * case of `Eo'); and a body that may be empty.
	 */

	roff_block_alloc(mdoc, line, ppos, tok);
	head = NULL;
	for (;;) {
		la = *pos;
		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);
		if (ac == ARGS_PUNCT || ac == ARGS_EOLN)
			break;

		/* Flush out leading punctuation. */

		if (head == NULL && ac != ARGS_QWORD &&
		    mdoc_isdelim(p) == DELIM_OPEN) {
			dword(mdoc, line, la, p, DELIM_OPEN, 0);
			continue;
		}

		if (head == NULL) {
			head = roff_head_alloc(mdoc, line, ppos, tok);
			if (tok == MDOC_Eo)  /* Not parsed. */
				dword(mdoc, line, la, p, DELIM_MAX, 0);
			rew_last(mdoc, head);
			roff_body_alloc(mdoc, line, ppos, tok);
			if (tok == MDOC_Eo)
				continue;
		}

		if (macro_or_word(mdoc, tok, line, la, pos, buf, 1))
			break;
	}

	/* Clean-up to leave in a consistent state. */

	if (head == NULL) {
		rew_last(mdoc, roff_head_alloc(mdoc, line, ppos, tok));
		roff_body_alloc(mdoc, line, ppos, tok);
	}
	if (nl)
		append_delims(mdoc, line, pos, buf);
}

static void
in_line_argn(MACRO_PROT_ARGS)
{
	struct mdoc_arg	*arg;
	char		*p;
	enum margserr	 ac;
	int		 ntok;
	int		 state; /* arg#; -1: not yet open; -2: closed */
	int		 la, maxargs, nl;

	nl = mdoc->flags & MDOC_NEWLINE;

	/*
	 * A line macro that has a fixed number of arguments (maxargs).
	 * Only open the scope once the first non-leading-punctuation is
	 * found (unless MDOC_IGNDELIM is noted, like in `Pf'), then
	 * keep it open until the maximum number of arguments are
	 * exhausted.
	 */

	switch (tok) {
	case MDOC_Ap:
	case MDOC_Ns:
	case MDOC_Ux:
		maxargs = 0;
		break;
	case MDOC_Bx:
	case MDOC_Es:
	case MDOC_Xr:
		maxargs = 2;
		break;
	default:
		maxargs = 1;
		break;
	}

	mdoc_argv(mdoc, line, tok, &arg, pos, buf);

	state = -1;
	p = NULL;
	for (;;) {
		la = *pos;
		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);

		if (ac == ARGS_WORD && state == -1 &&
		    ! (mdoc_macros[tok].flags & MDOC_IGNDELIM) &&
		    mdoc_isdelim(p) == DELIM_OPEN) {
			dword(mdoc, line, la, p, DELIM_OPEN, 0);
			continue;
		}

		if (state == -1 && tok != MDOC_In &&
		    tok != MDOC_St && tok != MDOC_Xr) {
			mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
			state = 0;
		}

		if (ac == ARGS_PUNCT || ac == ARGS_EOLN) {
			if (abs(state) < 2 && tok == MDOC_Pf)
				mandoc_vmsg(MANDOCERR_PF_SKIP,
				    mdoc->parse, line, ppos, "Pf %s",
				    p == NULL ? "at eol" : p);
			break;
		}

		if (state == maxargs) {
			rew_elem(mdoc, tok);
			state = -2;
		}

		ntok = (ac == ARGS_QWORD || (tok == MDOC_Pf && state == 0)) ?
		    TOKEN_NONE : lookup(mdoc, tok, line, la, p);

		if (ntok != TOKEN_NONE) {
			if (state >= 0) {
				rew_elem(mdoc, tok);
				state = -2;
			}
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
			break;
		}

		if (ac == ARGS_QWORD ||
		    mdoc_macros[tok].flags & MDOC_IGNDELIM ||
		    mdoc_isdelim(p) == DELIM_NONE) {
			if (state == -1) {
				mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
				state = 1;
			} else if (state >= 0)
				state++;
		} else if (state >= 0) {
			rew_elem(mdoc, tok);
			state = -2;
		}

		dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags);
	}

	if (state == -1) {
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
		    line, ppos, mdoc_macronames[tok]);
		return;
	}

	if (state == 0 && tok == MDOC_Pf)
		append_delims(mdoc, line, pos, buf);
	if (state >= 0)
		rew_elem(mdoc, tok);
	if (nl)
		append_delims(mdoc, line, pos, buf);
}

static void
in_line_eoln(MACRO_PROT_ARGS)
{
	struct roff_node	*n;
	struct mdoc_arg		*arg;

	if ((tok == MDOC_Pp || tok == MDOC_Lp) &&
	    ! (mdoc->flags & MDOC_SYNOPSIS)) {
		n = mdoc->last;
		if (mdoc->next == ROFF_NEXT_SIBLING)
			n = n->parent;
		if (n->tok == MDOC_Nm)
			rew_last(mdoc, n->parent);
	}

	if (buf[*pos] == '\0' &&
	    (tok == MDOC_Fd || mdoc_macronames[tok][0] == '%')) {
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
		    line, ppos, mdoc_macronames[tok]);
		return;
	}

	mdoc_argv(mdoc, line, tok, &arg, pos, buf);
	mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
	if (parse_rest(mdoc, tok, line, pos, buf))
		return;
	rew_elem(mdoc, tok);
}

/*
 * The simplest argument parser available: Parse the remaining
 * words until the end of the phrase or line and return 0
 * or until the next macro, call that macro, and return 1.
 */
static int
parse_rest(struct roff_man *mdoc, int tok, int line, int *pos, char *buf)
{
	int		 la;

	for (;;) {
		la = *pos;
		if (mdoc_args(mdoc, line, pos, buf, tok, NULL) == ARGS_EOLN)
			return 0;
		if (macro_or_word(mdoc, tok, line, la, pos, buf, 1))
			return 1;
	}
}

static void
ctx_synopsis(MACRO_PROT_ARGS)
{

	if (~mdoc->flags & (MDOC_SYNOPSIS | MDOC_NEWLINE))
		in_line(mdoc, tok, line, ppos, pos, buf);
	else if (tok == MDOC_Nm)
		blk_full(mdoc, tok, line, ppos, pos, buf);
	else {
		assert(tok == MDOC_Vt);
		blk_part_imp(mdoc, tok, line, ppos, pos, buf);
	}
}

/*
 * Phrases occur within `Bl -column' entries, separated by `Ta' or tabs.
 * They're unusual because they're basically free-form text until a
 * macro is encountered.
 */
static void
phrase_ta(MACRO_PROT_ARGS)
{
	struct roff_node *body, *n;

	/* Make sure we are in a column list or ignore this macro. */

	body = NULL;
	for (n = mdoc->last; n != NULL; n = n->parent) {
		if (n->flags & NODE_ENDED)
			continue;
		if (n->tok == MDOC_It && n->type == ROFFT_BODY)
			body = n;
		if (n->tok == MDOC_Bl && n->end == ENDBODY_NOT)
			break;
	}

	if (n == NULL || n->norm->Bl.type != LIST_column) {
		mandoc_msg(MANDOCERR_TA_STRAY, mdoc->parse,
		    line, ppos, "Ta");
		return;
	}

	/* Advance to the next column. */

	rew_last(mdoc, body);
	roff_body_alloc(mdoc, line, ppos, MDOC_It);
	parse_rest(mdoc, TOKEN_NONE, line, pos, buf);
}
@


1.173
log
@Remove the ENDBODY_NOSPACE flag, simplifying the code.

Comparing to groff output, it appears that all cases where it was used
and made a difference actually require the opposite, ENDBODY_SPACE.

I have no idea why i added it back in 2010; maybe to compensate for
some other bug that has long been fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.172 2017/02/11 15:44:11 schwarze Exp $ */
d382 4
d415 1
a415 2
			break_intermediate(mdoc->last, n);
			n->flags |= NODE_BROKEN;
@


1.172
log
@Never look for broken blocks inside blocks that are already closed.
Fixes the last the of tree corruptions sometimes causing NULL dereference
reported by tb@@; this one triggered in cases like: .Bl -column .It Pq Ta
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.171 2017/02/11 14:08:35 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012-2016 Ingo Schwarze <schwarze@@openbsd.org>
d421 1
a421 1
				    tok, target, ENDBODY_NOSPACE);
d635 1
a635 1
			    atok, body, ENDBODY_SPACE);
@


1.171
log
@Do not prematurely close .Nd containing a broken child.
Fixes tree corruption leading to NULL dereference
in insane cases like .Oo Oo .Nd .Pq Oc .Oc Oc
found by tb@@ with afl(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.170 2017/02/11 13:23:11 schwarze Exp $ */
d401 3
d737 1
a737 3
			if ( ! (target->flags & NODE_VALID))
				pending = find_pending(mdoc, ntok,
				    line, ppos, target);
@


1.170
log
@Do not prematurely mark intermediate blocks as broken while scanning
backwards.  Only do so when a block is found that is actually broken.
Logic error found while investigating crashes reported by tb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.169 2017/02/10 22:19:11 schwarze Exp $ */
d648 4
a651 1
		/* Explicit blocks close out description lines. */
d654 4
a657 1
			rew_last(mdoc, n);
@


1.169
log
@For child macros of block-end macros, only scan backwards for pending
breakers unless the parent of the block is already closed.  While
the scanning is needed in cases like ".Ac Bo" for broken Ao, it is
useless and crashy in cases like ".Ac Bc" for non-broken Ao.

This fixes a NULL pointer dereference that tb@@ found with afl(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.168 2017/02/10 16:20:58 schwarze Exp $ */
d51 2
d379 10
d403 1
a403 3
		if (n->flags & NODE_ENDED) {
			if ( ! (n->flags & NODE_VALID))
				n->flags |= NODE_BROKEN;
a404 1
		}
d408 1
d579 1
a579 3
		if (n->flags & NODE_ENDED) {
			if ( ! (n->flags & NODE_VALID))
				n->flags |= NODE_BROKEN;
a580 1
		}
a606 1
			assert(body);
d657 1
@


1.168
log
@Oops, the previous commit unintentionally included this file.
The intended commit message for rev. 1.167 is:

In the SYNOPSIS, .Nm blocks can get broken if one of their children
gets broken.  In that case, mark them as BROKEN and ENDED and make
sure they get closed out together with the child.

Fixes tree corruption leeding to a NULL dereference found by tb@@
with afl(1) in: .Sh SYNOPSIS .Bl .Oo .Nm .Bk .Oc .It (where .Bk is
the child and .Oo is the breaker).
A simpler form of the same corruption (without crash) is visible in:
.Sh SYNOPSIS .Ao .Nm .Bo .Ac .Bc text
where the text ended up inside the .Nm (child .Bo, breaker .Ao).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.167 2017/02/10 15:44:31 schwarze Exp $ */
d399 1
a399 1
			n->flags = NODE_BROKEN;
d401 1
a401 1
				target->flags = NODE_ENDED;
d715 1
d721 4
a724 4
			pending = find_pending(mdoc, ntok, line, ppos,
			    target);
		} else
			pending = 0;
@


1.167
log
@In -Ttree output mode, show the BROKEN node flag and
provide a -Onoval output option to show the unvalidated tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.166 2017/01/10 13:46:53 schwarze Exp $ */
@


1.166
log
@unify names of AST node flags; no change of cpp output
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.165 2016/08/20 17:58:09 schwarze Exp $ */
d576 1
a576 2
		 * Mismatching end macros can never break anything,
		 * SYNOPSIS name blocks can never be broken,
d580 1
a580 3
		if (body == NULL ||
		    n->tok == MDOC_Nm ||
		    n->type != ROFFT_BLOCK)
d583 11
d996 1
a996 1
			rew_last(mdoc, n);
@


1.165
log
@When a mismatching end macro occurs while at least two nested blocks
are open, all except the innermost open block got a bogus MDOC_ENDED
marker, in some situations triggering segfaults down the road
which tb@@ found with afl(1).
Fix the logic error by figuring out up front whether an end macro
has a matching body, and if it hasn't, don't mark any blocks as broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.164 2016/08/20 15:58:16 schwarze Exp $ */
d217 1
a217 1
	n = mdoc->last->flags & MDOC_VALID ?
d265 1
a265 1
	if (to->flags & MDOC_VALID)
d270 1
a270 1
		mdoc->last->flags |= MDOC_VALID | MDOC_ENDED;
d274 1
a274 1
	mdoc->last->flags |= MDOC_VALID | MDOC_ENDED;
d299 1
a299 1
			if ( ! (n->flags & MDOC_BROKEN))
d310 1
a310 1
				if (n->flags & MDOC_ENDED)
d391 3
a393 3
		if (n->flags & MDOC_ENDED) {
			if ( ! (n->flags & MDOC_VALID))
				n->flags |= MDOC_BROKEN;
d399 1
a399 1
			n->flags = MDOC_BROKEN;
d401 2
a402 2
				target->flags = MDOC_ENDED;
			else if ( ! (target->flags & MDOC_ENDED)) {
d445 1
a445 1
		mdoc->last->flags |= MDOC_DELIMO;
d449 1
a449 1
		mdoc->last->flags |= MDOC_DELIMC;
d482 1
a482 1
			mdoc->last->flags |= MDOC_EOS;
d555 1
a555 1
		if (n->flags & MDOC_ENDED || n->tok != atok ||
d569 3
a571 3
		if (n->flags & MDOC_ENDED) {
			if ( ! (n->flags & MDOC_VALID))
				n->flags |= MDOC_BROKEN;
d621 1
a621 1
				itblk->flags |= MDOC_ENDED | MDOC_BROKEN;
d643 1
a643 1
		n->flags |= MDOC_BROKEN;
d707 1
a707 1
		if (ntok != TOKEN_NONE && n->flags & MDOC_BROKEN) {
d711 1
a711 1
			while ( ! (target->flags & MDOC_ENDED));
d770 1
a770 1
				mdoc->last->flags &= ~MDOC_DELIMO;
d864 1
a864 1
			mdoc->last->flags &= ~MDOC_DELIMC;
d927 3
a929 3
			if (n->flags & MDOC_ENDED) {
				if ( ! (n->flags & MDOC_VALID))
					n->flags |= MDOC_BROKEN;
d1130 1
a1130 1
	if (blk->flags & MDOC_VALID)
d1465 1
a1465 1
		if (n->flags & MDOC_ENDED)
@


1.164
log
@When scanning upwards for a column list to put a .Ta macro in,
ignore body end markers of lists breaking other blocks.
Fixing a logical error that caused a NULL deref found by tb@@ with afl(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.163 2016/08/13 09:14:56 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012-2015 Ingo Schwarze <schwarze@@openbsd.org>
d550 12
d567 1
a567 2
	atok = rew_alt(tok);
	body = endbody = itblk = later = NULL;
d575 5
a579 7
		/* Remember the start of our own body. */

		if (n->type == ROFFT_BODY && atok == n->tok) {
			if (n->end == ENDBODY_NOT)
				body = n;
			continue;
		}
d581 3
a583 1
		if (n->type != ROFFT_BLOCK || n->tok == MDOC_Nm)
a650 2
		if (later != NULL)
			later->flags &= ~MDOC_BROKEN;
@


1.163
log
@Even after switching from a pending head to the body, we have to
continue scanning upwards, because the enclosing block might already
be pending as well, e.g. .Bl .Bl .It Bo .El .It.
Tree corruption leading to a later NULL deref found by tb@@ with afl(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.162 2015/10/20 02:00:49 schwarze Exp $ */
d1460 1
a1460 1
		if (n->tok == MDOC_Bl)
@


1.162
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.161 2015/10/17 00:19:58 schwarze Exp $ */
d293 1
a293 1
				return;
@


1.161
log
@Very tricky diff to fix macro interpretation and spacing around tabs
in .Bl -column; it took me more than a day to get this right.
Triggered by a loosely related bug report from tim@@.

The lesson for you is:  Use .Ta macros in .Bl -column, avoid tabs,
or you are in for surprises:  The last word before a tab is not
interpreted as a macro (unless there is a blank in between), the
first word after a tab isn't either (unless there is a blank in
between), and a blank after a tab causes a leading blank in the
respective output cell.  Yes, "blank", "tab", "blank tab" and "tab
blank" all have different semantics; if you write code relying on
that, good luck maintaining it afterwards...
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.160 2015/10/15 22:27:09 schwarze Exp $ */
d229 1
a263 1
	struct roff_node	*np;
d269 3
a271 10
		/*
		 * Save the parent here, because we may delete the
		 * mdoc->last node in the post-validation phase and reset
		 * it to mdoc->last->parent, causing a step in the closing
		 * out to be lost.
		 */
		np = mdoc->last->parent;
		mdoc_valid_post(mdoc);
		mdoc->last = np;
		assert(mdoc->last);
d273 2
a275 1
	mdoc_valid_post(mdoc);
@


1.160
log
@When blk_full() handles an .It line in .Bl -column and indirectly
calls phrase_ta() to handle a .Ta child macro, advance the body
pointer accordingly, such that a subsequent tab character rewinds
the right body block and doesn't fail an assertion.  That happened
when there was nothing between the .Ta and the tab character.
Bug reported by tim@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.159 2015/10/12 00:07:27 schwarze Exp $ */
d240 4
d1035 1
a1035 1
	ac = ARGS_PEND;
d1037 11
d1052 2
a1053 1
			if (lac != ARGS_PPHRASE && lac != ARGS_PHRASE)
d1055 1
d1057 2
a1058 5
			 * This is necessary: if the last token on a
			 * line is a `Ta' or tab, then we'll get
			 * ARGS_EOLN, so we must be smart enough to
			 * reopen our scope if the last parse was a
			 * phrase or partial phrase.
d1060 1
d1064 1
d1067 1
a1087 1
		    ac != ARGS_PEND &&
a1088 1
		    ac != ARGS_PPHRASE &&
d1100 1
a1100 3
		if (ac == ARGS_PHRASE ||
		    ac == ARGS_PEND ||
		    ac == ARGS_PPHRASE) {
d1110 1
a1110 5
			/*
			 * Process phrases: set whether we're in a
			 * partial-phrase (this effects line handling)
			 * then call down into the phrase parser.
			 */
d1112 1
a1112 4
			if (ac == ARGS_PPHRASE)
				mdoc->flags |= MDOC_PPHRASE;
			if (ac == ARGS_PEND && lac == ARGS_PPHRASE)
				mdoc->flags |= MDOC_PPHRASE;
d1114 1
a1114 1
			mdoc->flags &= ~MDOC_PPHRASE;
@


1.159
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.158 2015/10/06 18:30:44 schwarze Exp $ */
d1109 5
@


1.158
log
@modernize style: "return" is not a function; ok cmp(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.157 2015/09/26 00:53:15 schwarze Exp $ */
a734 1
		/* FALLTHROUGH */
a735 1
		/* FALLTHROUGH */
a736 1
		/* FALLTHROUGH */
a737 1
		/* FALLTHROUGH */
a738 1
		/* FALLTHROUGH */
a941 1
					/* FALLTHROUGH */
a1283 1
		/* FALLTHROUGH */
a1284 1
		/* FALLTHROUGH */
a1288 1
		/* FALLTHROUGH */
a1289 1
		/* FALLTHROUGH */
@


1.157
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.156 2015/05/01 16:56:36 schwarze Exp $ */
d244 1
a244 1
				return(res);
d250 1
a250 1
	return(TOKEN_NONE);
d330 1
a330 1
		return(MDOC_Ao);
d332 1
a332 1
		return(MDOC_Bo);
d334 1
a334 1
		return(MDOC_Bro);
d336 1
a336 1
		return(MDOC_Do);
d338 1
a338 1
		return(MDOC_Eo);
d340 1
a340 1
		return(MDOC_Bd);
d342 1
a342 1
		return(MDOC_Bf);
d344 1
a344 1
		return(MDOC_Bk);
d346 1
a346 1
		return(MDOC_Bl);
d348 1
a348 1
		return(MDOC_Fo);
d350 1
a350 1
		return(MDOC_Oo);
d352 1
a352 1
		return(MDOC_Po);
d354 1
a354 1
		return(MDOC_Qo);
d356 1
a356 1
		return(MDOC_Rs);
d358 1
a358 1
		return(MDOC_So);
d360 1
a360 1
		return(MDOC_Xo);
d362 1
a362 1
		return(tok);
d414 1
a414 1
	return(irc);
d509 1
a509 1
		return(0);
d516 1
a516 1
		return(1);
d1427 1
a1427 1
			return(0);
d1429 1
a1429 1
			return(1);
@


1.156
log
@mdoc_valid_post() may indirectly call roff_node_unlink() which may
set ROFF_NEXT_CHILD, which is desirable for the final call to
mdoc_valid_post() - in case the target itself gets deleted, the
parse point may need this adjustment - but not for the intermediate
calls - if intermediate nodes get deleted, that mustn't clobber the
parse point.  So move setting ROFF_NEXT_SIBLING to the proper place
in rew_last().

This fixes the assertion failure in jsg@@'s afl test case 108/Apr27.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.155 2015/05/01 16:01:53 schwarze Exp $ */
a363 1
	/* NOTREACHED */
@


1.155
log
@Setting the "last" member of struct roff_node was done at an extremely
weird place.  Move it to the obviously correct place.
Surprisingly, this didn't cause any misformatting in the test suite
or in any base system manuals, but i cannot believe the code was
really correct for all conceivable input, and it would be very hard
to verify.  At the very least, it cannot have worked for man(7).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.154 2015/05/01 15:27:17 schwarze Exp $ */
a263 1
	mdoc->next = ROFF_NEXT_SIBLING;
d276 1
@


1.154
log
@Minor bug fix:  When .Pp rewinds .Nm, rewind the whole block,
not just the body.  In some unusual edge cases, this caused
the .Pp to become a sibling of the .Nm body inside the .Nm block.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.153 2015/04/29 21:57:50 schwarze Exp $ */
d259 1
a259 1
	struct roff_node *n, *np;
a273 1
		n = mdoc->last;
a275 1
		mdoc->last->last = n;
@


1.153
log
@If a block body gets broken, that's no good reason to extend the
scope of the end macro.  Instead, only keep the tail scope open if
the end macro macro calls an explicit macro and actually breaks
that.  This corrects syntax tree structure and fixes an assertion
found by jsg@@ with afl (test case 098/Apr27).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.152 2015/04/29 14:48:17 schwarze Exp $ */
d1400 1
a1400 1
			rew_last(mdoc, mdoc->last->parent);
@


1.152
log
@Do not mark a block with the MDOC_BROKEN flag if it merely contains
a mismatching explicit end macro without actually being broken.
Avoids a subsequent upward search for the non-existent breaker
ending up in a NULL pointer access; afl test case 005/Apr27 from jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.151 2015/04/23 15:35:39 schwarze Exp $ */
d674 2
d703 1
a703 1
		if (n != mdoc->last && n->flags & MDOC_BROKEN) {
@


1.151
log
@Get rid of two empty wrapper functions.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.150 2015/04/21 16:13:54 schwarze Exp $ */
d645 2
@


1.150
log
@Avoid a use after free when the target node is deleted during validation.
Bug reported by jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.149 2015/04/19 14:57:16 schwarze Exp $ */
d211 1
a211 1
mdoc_macroend(struct roff_man *mdoc)
@


1.149
log
@Unify trickier node handling functions.
* man_elem_alloc() -> roff_elem_alloc()
* man_block_alloc() -> roff_block_alloc()
The functions mdoc_elem_alloc() and mdoc_block_alloc() remain for
now because they need to do mdoc(7)-specific argument processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.148 2015/04/19 14:25:05 schwarze Exp $ */
d292 15
a306 12
		switch (n->type) {
		case ROFFT_HEAD:
			roff_body_alloc(mdoc, n->line, n->pos, n->tok);
			return;
		case ROFFT_BLOCK:
			break;
		default:
			return;
		}

		if ( ! (n->flags & MDOC_BROKEN))
			return;
@


1.148
log
@Unify some node handling functions that use TOKEN_NONE.
* mdoc_word_alloc(), man_word_alloc() -> roff_word_alloc()
* mdoc_word_append(), man_word_append() -> roff_word_append()
* mdoc_addspan(), man_addspan() -> roff_addtbl()
* mdoc_addeqn(), man_addeqn() -> roff_addeqn()
Minus 50 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.147 2015/04/19 13:59:37 schwarze Exp $ */
d647 1
a647 1
			mdoc_elem_alloc(mdoc, line, ppos, MDOC_br, NULL);
d991 1
a991 1
			mdoc_elem_alloc(mdoc, line, ppos, MDOC_br, NULL);
d1224 1
a1224 1
	mdoc_block_alloc(mdoc, line, ppos, tok, NULL);
@


1.147
log
@Decouple the token code for "no request or macro" from the individual
high-level parsers to allow further unification of functions that
only need to recognize this code, but that don't care about different
high-level macrosets beyond that.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.146 2015/04/19 13:50:10 schwarze Exp $ */
d433 1
a433 1
		mdoc_word_append(mdoc, p);
d437 1
a437 1
	mdoc_word_alloc(mdoc, line, col, p);
@


1.146
log
@Unify node handling functions:
* node_alloc() for mdoc and man_node_alloc() -> roff_node_alloc()
* node_append() for mdoc and man_node_append() -> roff_node_append()
* mdoc_head_alloc() and man_head_alloc() -> roff_head_alloc()
* mdoc_body_alloc() and man_body_alloc() -> roff_body_alloc()
* mdoc_node_unlink() and man_node_unlink() -> roff_node_unlink()
* mdoc_node_free() and man_node_free() -> roff_node_free()
* mdoc_node_delete() and man_node_delete() -> roff_node_delete()
Minus 130 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.145 2015/04/18 16:04:40 schwarze Exp $ */
d233 1
a233 1
 * or as a line macro if from == MDOC_MAX.
d240 1
a240 1
	if (from == MDOC_MAX || mdoc_macros[from].flags & MDOC_PARSED) {
d242 1
a242 1
		if (res != MDOC_MAX) {
d250 1
a250 1
	return(MDOC_MAX);
d466 2
a467 1
		if (mdoc_args(mdoc, line, pos, buf, MDOC_MAX, &p) == ARGS_EOLN)
d500 1
a500 1
	ntok = MDOC_MAX;
d506 2
a507 2
	if (ntok == MDOC_MAX) {
		dword(mdoc, line, ppos, p, DELIM_MAX, tok == MDOC_MAX ||
d514 1
a514 1
		if (tok == MDOC_MAX)
d679 1
a679 1
		ntok = ac == ARGS_QWORD ? MDOC_MAX :
d682 1
a682 1
		if (ntok == MDOC_MAX) {
d783 1
a783 1
		    MDOC_MAX : lookup(mdoc, tok, line, la, p);
d792 1
a792 1
		if (ntok != MDOC_MAX) {
d1109 1
a1109 1
			parse_rest(mdoc, MDOC_MAX, line, &la, buf);
d1339 1
a1339 1
		    MDOC_MAX : lookup(mdoc, tok, line, la, p);
d1341 1
a1341 1
		if (ntok != MDOC_MAX) {
d1475 1
a1475 1
	parse_rest(mdoc, MDOC_MAX, line, pos, buf);
@


1.145
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.144 2015/04/05 23:04:22 schwarze Exp $ */
d31 1
d294 1
a294 1
			mdoc_body_alloc(mdoc, n->line, n->pos, n->tok);
d1024 1
a1024 1
		head = mdoc_head_alloc(mdoc, line, ppos, tok);
d1026 1
a1026 1
		body = mdoc_body_alloc(mdoc, line, ppos, tok);
d1049 1
a1049 1
			body = mdoc_body_alloc(mdoc, line, ppos, tok);
d1084 1
a1084 1
			head = mdoc_head_alloc(mdoc, line, ppos, tok);
d1096 1
a1096 1
			body = mdoc_body_alloc(mdoc, line, ppos, tok);
d1120 1
a1120 1
		head = mdoc_head_alloc(mdoc, line, ppos, tok);
d1131 1
a1131 1
	body = mdoc_body_alloc(mdoc, line, ppos, tok);
d1162 1
a1162 1
	rew_last(mdoc, mdoc_head_alloc(mdoc, line, ppos, tok));
d1183 1
a1183 1
			body = mdoc_body_alloc(mdoc, line, ppos, tok);
d1189 1
a1189 1
		body = mdoc_body_alloc(mdoc, line, ppos, tok);
d1240 1
a1240 1
			head = mdoc_head_alloc(mdoc, line, ppos, tok);
d1244 1
a1244 1
			mdoc_body_alloc(mdoc, line, ppos, tok);
d1256 2
a1257 2
		rew_last(mdoc, mdoc_head_alloc(mdoc, line, ppos, tok));
		mdoc_body_alloc(mdoc, line, ppos, tok);
d1473 1
a1473 1
	mdoc_body_alloc(mdoc, line, ppos, MDOC_It);
@


1.144
log
@If a partial explicit block extending to the next input line follows
the end macro of a broken block, put all of it into the breaking block.
Needed for example by mutella(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.143 2015/04/05 22:43:40 schwarze Exp $ */
d43 2
a44 2
static	void		append_delims(struct mdoc *, int, int *, char *);
static	void		dword(struct mdoc *, int, int, const char *,
d46 1
a46 1
static	int		find_pending(struct mdoc *, int, int, int,
d48 1
a48 1
static	int		lookup(struct mdoc *, int, int, int, const char *);
d50 1
a50 1
static	int		parse_rest(struct mdoc *, int, int, int *, char *);
d52 4
a55 3
static	void		rew_elem(struct mdoc *, int);
static	void		rew_last(struct mdoc *, const struct roff_node *);
static	void		rew_pending(struct mdoc *, const struct roff_node *);
d210 1
a210 1
mdoc_macroend(struct mdoc *mdoc)
d235 1
a235 1
lookup(struct mdoc *mdoc, int from, int line, int ppos, const char *p)
d256 1
a256 1
rew_last(struct mdoc *mdoc, const struct roff_node *to)
d263 1
a263 1
	mdoc->next = MDOC_NEXT_SIBLING;
d285 1
a285 1
rew_pending(struct mdoc *mdoc, const struct roff_node *n)
d366 1
a366 1
rew_elem(struct mdoc *mdoc, int tok)
d384 1
a384 1
find_pending(struct mdoc *mdoc, int tok, int line, int ppos,
d421 1
a421 1
dword(struct mdoc *mdoc, int line, int col, const char *p,
d455 1
a455 1
append_delims(struct mdoc *mdoc, int line, int *pos, char *buf)
d619 1
a619 1
				mdoc->next = MDOC_NEXT_CHILD;
d1388 1
a1388 1
		if (mdoc->next == MDOC_NEXT_SIBLING)
d1414 1
a1414 1
parse_rest(struct mdoc *mdoc, int tok, int line, int *pos, char *buf)
@


1.143
log
@Reduce code duplication, no functional change:
Both partial and full implicit blocks can break explicit blocks.
Put the code to handle both cases into a common function.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.142 2015/04/05 14:43:10 schwarze Exp $ */
d528 1
d530 1
a530 1
	int		 j, lastarg, maxargs, nl;
d692 13
a704 2
	if (n != NULL)
		rew_pending(mdoc, n);
@


1.142
log
@Arguments to end macros of broken partial explicit blocks
must go inside the breaking block.  For example, in
.It Ic cmd Oo
.Ar optional_arg Oc Ar mandatory_arg
the mandatory_arg is still inside the .It block.
Used for example by mutella(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.141 2015/04/02 22:06:17 schwarze Exp $ */
d43 1
d45 3
a47 2
				 enum mdelim, int);
static	void		append_delims(struct mdoc *, int, int *, char *);
d378 38
d1111 1
a1111 20

	/*
	 * If there is an open (i.e., unvalidated) sub-block requiring
	 * explicit close-out, postpone switching the current block from
	 * head to body until the rew_pending() call closing out that
	 * sub-block.
	 */
	for (n = mdoc->last; n && n != head; n = n->parent) {
		if (n->flags & MDOC_ENDED) {
			if ( ! (n->flags & MDOC_VALID))
				n->flags |= MDOC_BROKEN;
			continue;
		}
		if (n->type == ROFFT_BLOCK &&
		    mdoc_macros[n->tok].flags & MDOC_EXPLICIT) {
			n->flags = MDOC_BROKEN;
			head->flags = MDOC_ENDED;
		}
	}
	if (head->flags & MDOC_ENDED)
d1177 1
a1177 28
	/*
	 * If there is an open sub-block requiring explicit close-out,
	 * postpone closing out the current block until the
	 * rew_pending() call closing out the sub-block.
	 */

	for (n = mdoc->last; n && n != body && n != blk->parent;
	     n = n->parent) {
		if (n->flags & MDOC_ENDED) {
			if ( ! (n->flags & MDOC_VALID))
				n->flags |= MDOC_BROKEN;
			continue;
		}
		if (n->type == ROFFT_BLOCK &&
		    mdoc_macros[n->tok].flags & MDOC_EXPLICIT) {
			n->flags |= MDOC_BROKEN;
			if ( ! (body->flags & MDOC_ENDED)) {
				mandoc_vmsg(MANDOCERR_BLK_NEST,
				    mdoc->parse, line, ppos,
				    "%s breaks %s", mdoc_macronames[tok],
				    mdoc_macronames[n->tok]);
				mdoc_endbody_alloc(mdoc, line, ppos,
				    tok, body, ENDBODY_NOSPACE);
			}
		}
	}
	assert(n == body);
	if (body->flags & MDOC_ENDED)
@


1.141
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.140 2015/04/02 21:03:18 schwarze Exp $ */
d257 3
a259 1
	assert(to);
d628 2
a629 4
		if (j == maxargs && n != NULL) {
			rew_pending(mdoc, n);
			n = NULL;
		}
d644 2
a645 4
		if (n != NULL) {
			rew_pending(mdoc, n);
			n = NULL;
		}
@


1.140
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.139 2015/02/12 12:20:47 schwarze Exp $ */
d46 1
a46 2
static	enum mdoct	lookup(struct mdoc *, enum mdoct,
				int, int, const char *);
d48 5
a52 6
static	int		parse_rest(struct mdoc *, enum mdoct,
				int, int *, char *);
static	enum mdoct	rew_alt(enum mdoct);
static	void		rew_elem(struct mdoc *, enum mdoct);
static	void		rew_last(struct mdoc *, const struct mdoc_node *);
static	void		rew_pending(struct mdoc *, const struct mdoc_node *);
d209 1
a209 1
	struct mdoc_node *n;
d231 2
a232 2
static enum mdoct
lookup(struct mdoc *mdoc, enum mdoct from, int line, int ppos, const char *p)
d234 1
a234 1
	enum mdoct	 res;
d253 1
a253 1
rew_last(struct mdoc *mdoc, const struct mdoc_node *to)
d255 1
a255 1
	struct mdoc_node *n, *np;
d280 1
a280 1
rew_pending(struct mdoc *mdoc, const struct mdoc_node *n)
d318 2
a319 2
static enum mdoct
rew_alt(enum mdoct tok)
d361 1
a361 1
rew_elem(struct mdoc *mdoc, enum mdoct tok)
d363 1
a363 1
	struct mdoc_node *n;
d452 1
a452 1
	enum mdoct	 ntok;
d481 5
a485 5
	struct mdoc_node *body;		/* Our own body. */
	struct mdoc_node *endbody;	/* Our own end marker. */
	struct mdoc_node *itblk;	/* An It block starting later. */
	struct mdoc_node *later;	/* A sub-block starting later. */
	struct mdoc_node *n;		/* Search back to our block. */
d489 1
a489 1
	enum mdoct	 atok, ntok;
d663 1
a663 1
	enum mdoct	 ntok;
d847 4
a850 4
	struct mdoc_node *blk; /* Our own or a broken block. */
	struct mdoc_node *head; /* Our own head. */
	struct mdoc_node *body; /* Our own body. */
	struct mdoc_node *n;
d1113 3
a1115 3
	struct mdoc_node *blk; /* saved block context */
	struct mdoc_node *body; /* saved body context */
	struct mdoc_node *n;
d1206 1
a1206 1
	struct mdoc_node *head; /* keep track of head */
d1263 1
a1263 1
	enum mdoct	 ntok;
d1377 1
a1377 1
	struct mdoc_node	*n;
d1409 1
a1409 1
parse_rest(struct mdoc *mdoc, enum mdoct tok, int line, int *pos, char *buf)
d1444 1
a1444 1
	struct mdoc_node *body, *n;
@


1.139
log
@Delete the mdoc_node.pending pointer and the function calculating
it, make_pending(), which was the most difficult function of the
whole mdoc(7) parser.  After almost five years of maintaining this
hellhole, i just noticed the pointer isn't needed after all.

Blocks are always rewound in the reverse order they were opened;
that even holds for broken blocks.  Consequently, it is sufficient
to just mark broken blogs with the flag MDOC_BROKEN and breaking
blocks with the flag MDOC_ENDED.  When rewinding, instead of iterating
the pending pointers, just iterate from each broken block to its
parents, rewinding all that are MDOC_ENDED and stopping after
processing the first ancestor that it not MDOC_BROKEN.  For ENDBODY
markers, use the mdoc_node.body pointer in place of the former
mdoc_node.pending.

This also fixes an assertion failure found by jsg@@ with afl,
test case #467 (Bo Bl It Bd Bc It), where (surprise surprise)
the pending pointer got corrupted.

Improved functionality, minus one function, minus one struct field,
minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.138 2015/02/11 13:37:31 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d27 2
d30 1
a30 1
#include "mandoc.h"
a31 1
#include "libmandoc.h"
d219 1
a219 1
		if (n->type == MDOC_BLOCK &&
d289 1
a289 1
		case MDOC_HEAD:
d292 1
a292 1
		case MDOC_BLOCK:
d305 2
a306 2
			if (n->type == MDOC_BLOCK ||
			    n->type == MDOC_HEAD) {
d368 1
a368 1
	if (MDOC_ELEM != n->type)
d370 1
a370 1
	assert(MDOC_ELEM == n->type);
d389 1
a389 1
	    d == DELIM_NONE && mdoc->last->type == MDOC_TEXT &&
d524 1
a524 1
		if (n->type == MDOC_BODY && atok == n->tok) {
d530 1
a530 1
		if (n->type != MDOC_BLOCK || n->tok == MDOC_Nm)
d875 1
a875 1
			if (n->type != MDOC_BLOCK)
d1018 1
a1018 1
		 * the MDOC_HEAD) for non-phrase types.
d1088 1
a1088 1
		if (n->type == MDOC_BLOCK &&
d1173 1
a1173 1
		if (n->type == MDOC_BLOCK &&
d1454 1
a1454 1
		if (n->tok == MDOC_It && n->type == MDOC_BODY)
@


1.138
log
@explicit blocks close out .Nd; fixing data structure corruption
eventually leading to NULL pointer access;
found by jsg@@ with afl, text case #455.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.137 2015/02/10 17:47:19 schwarze Exp $ */
a47 2
static	void		make_pending(struct mdoc *, struct mdoc_node *,
				struct mdoc_node *, int, int);
d284 12
a295 1
	rew_last(mdoc, n);
d297 2
a298 2
	if (n->type != MDOC_BLOCK)
		return;
d300 12
a311 4
	while ((n = n->pending) != NULL) {
		rew_last(mdoc, n);
		if (n->type == MDOC_HEAD)
			mdoc_body_alloc(mdoc, n->line, n->pos, n->tok);
a374 72
 * We are trying to close the block *breaker,
 * but the child block *broken is still open.
 * Thus, postpone closing the *breaker
 * until the rew_pending() call closing *broken.
 */
static void
make_pending(struct mdoc *mdoc, struct mdoc_node *breaker,
	struct mdoc_node *broken, int line, int ppos)
{
	struct mdoc_node *n;

	mandoc_vmsg(MANDOCERR_BLK_NEST, mdoc->parse, line, ppos,
	    "%s breaks %s", mdoc_macronames[breaker->tok],
	    mdoc_macronames[broken->tok]);

	/*
	 * If the *broken block (Z) is already broken by a block (B)
	 * contained in the breaker (A), make the breaker pending
	 * on that inner breaker (B).  Graphically,
	 *
	 * breaker=[A! broken=n=[B!->A (old broken=)[Z->B B] A] Z]
	 *
	 * In these graphics, "->" indicates the "pending" pointer and
	 * "!" indicates the MDOC_BREAK flag.  Each of the cases gets
	 * one additional pointer (B->A) and one additional flag (A!).
	 */

	for (n = broken->parent; ; n = n->parent)
		if (n == broken->pending)
			broken = n;
		else if (n == breaker)
			break;

	/*
	 * Found the breaker.
	 *
	 * If another, outer breaker (X) is already pending on
	 * the *broken block (B), we must not clobber the link
	 * to the outer breaker, but make it pending on the new,
	 * now inner breaker (A).  Graphically,
	 *
	 * [X! n=breaker=[A!->X broken=[B(->X)->A X] A] B].
	 */

	if (broken->pending != NULL) {
		n = breaker;

		/*
		 * If the inner breaker (A) is already broken, too,
		 * it cannot take on the outer breaker (X) but must
		 * hand it on to its own breakers (Y).  Graphically,
		 *
		 * [X! n=[Y!->X breaker=[A!->Y Y] broken=[B(->X)->A X] A] B]
		 */

		while (n->pending)
			n = n->pending;
		n->pending = broken->pending;
	}

	/*
	 * Now we have reduced the situation to the simplest case:
	 * breaker=[A! broken=[B->A A] B].
	 */

	broken->pending = breaker;
	breaker->flags |= MDOC_BREAK;
	if (breaker->body != NULL)
		breaker->body->flags |= MDOC_BREAK;
}

/*
d515 3
a517 1
		if (n->flags & (MDOC_VALID | MDOC_BREAK))
d519 1
a553 7
			 */

			make_pending(mdoc, n, later, line, ppos);
			if (tok == MDOC_El)
				itblk->flags |= MDOC_BREAK;

			/*
d558 5
d566 3
d587 1
a587 5
		/*
		 * When finding an open sub block, remember the last
		 * open explicit block, or, in case there are only
		 * implicit ones, the first open implicit block.
		 */
d589 2
a590 2
		if (later == NULL ||
		    ! (mdoc_macros[later->tok].flags & MDOC_EXPLICIT))
d869 6
a874 2
			if (n->flags & (MDOC_VALID | MDOC_BREAK) ||
			    n->type != MDOC_BLOCK)
d876 1
d1082 5
d1088 3
a1090 4
		    mdoc_macros[n->tok].flags & MDOC_EXPLICIT &&
		    ! (n->flags & MDOC_VALID)) {
			n->pending = head;
			return;
d1093 2
d1167 5
d1173 10
a1182 6
		    mdoc_macros[n->tok].flags & MDOC_EXPLICIT &&
		    ! (n->flags & MDOC_VALID)) {
			make_pending(mdoc, blk, n, line, ppos);
			mdoc_endbody_alloc(mdoc, line, ppos,
			    tok, body, ENDBODY_NOSPACE);
			return;
d1186 3
d1451 1
a1451 1
		if (n->flags & (MDOC_VALID | MDOC_BREAK))
@


1.137
log
@Be more careful to not generate empty .In, .St, and .Xr nodes.
That could happen when their first argument was another called macro,
causing a NULL pointer access in .St validation found by jsg@@ with afl.

Make in_line_argn() easier to understand by using one state
variable rather than two.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.136 2015/02/07 16:39:44 schwarze Exp $ */
d629 7
@


1.136
log
@Closing a block validates it, which may end up deleting it,
so if we are in a loop over blocks, cleanly restart the loop
rather than risking use after free; found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.135 2015/02/06 07:12:34 schwarze Exp $ */
a1285 2
	int		 la, flushed, j, maxargs, nl;
	enum margserr	 ac;
d1288 1
d1290 2
d1325 1
a1326 1
	flushed = j = 0;
d1330 14
d1345 1
a1345 1
			if (j < 2 && tok == MDOC_Pf)
d1352 1
a1352 9
		if ( ! (mdoc_macros[tok].flags & MDOC_IGNDELIM) &&
		    ac != ARGS_QWORD && j == 0 &&
		    mdoc_isdelim(p) == DELIM_OPEN) {
			dword(mdoc, line, la, p, DELIM_OPEN, 0);
			continue;
		} else if (j == 0)
		       mdoc_elem_alloc(mdoc, line, ppos, tok, arg);

		if (j == maxargs && ! flushed) {
d1354 1
a1354 1
			flushed = 1;
d1357 1
a1357 1
		ntok = (ac == ARGS_QWORD || (tok == MDOC_Pf && j == 0)) ?
d1361 1
a1361 1
			if ( ! flushed)
d1363 2
a1364 1
			flushed = 1;
a1365 1
			j++;
d1369 9
a1377 3
		if ( ! (mdoc_macros[tok].flags & MDOC_IGNDELIM) &&
		    ac != ARGS_QWORD && ! flushed &&
		    mdoc_isdelim(p) != DELIM_NONE) {
d1379 1
a1379 1
			flushed = 1;
a1383 1
		j++;
d1386 4
a1389 9
	if (j == 0) {
		if (tok == MDOC_In || tok == MDOC_St || tok == MDOC_Xr) {
			mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
			    line, ppos, mdoc_macronames[tok]);
			return;
		}
		mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
		if (ac == ARGS_PUNCT && tok == MDOC_Pf)
			append_delims(mdoc, line, pos, buf);
d1391 4
a1394 1
	if ( ! flushed)
@


1.135
log
@Delete the legacy generic warning type MANDOCERR_ARGCWARN,
replacing the last instances by more specific warnings.
Improved functionality, minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.134 2015/02/06 03:31:11 schwarze Exp $ */
d942 1
@


1.134
log
@better handle .Fo and .Fd without argument
better handle .Fo with more than one argument
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.133 2015/02/06 01:07:07 schwarze Exp $ */
d1404 2
a1405 1
	if (buf[*pos] == '\0' && tok == MDOC_Fd) {
d1407 1
a1407 1
		    line, ppos, "Fd");
@


1.133
log
@better handle .In .Sh .Ss .St .Xr without arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.132 2015/02/05 01:46:38 schwarze Exp $ */
d1402 6
@


1.132
log
@fix handling of empty .An macros
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.131 2015/02/05 00:13:34 schwarze Exp $ */
d905 6
d1374 5
@


1.131
log
@Simplify by deleting the "lastline" member of struct mdoc_node.
Minus one struct member, minus 17 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.130 2015/02/04 22:29:27 schwarze Exp $ */
d773 1
a773 1
			if (cnt == 0 && nc == 0)
@


1.130
log
@Discard excess head arguments for .Bd .Bl .Bk and delete hwarn_eq0().
Discard empty .Bk blocks.
Improve related diagnostics.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.129 2015/02/04 18:03:28 schwarze Exp $ */
a262 3
		if ( ! (mdoc->last->flags & MDOC_VALID))
			mdoc->last->lastline = to->lastline -
			    (mdoc->flags & MDOC_NEWLINE ? 1 : 0);
d576 1
a576 1
			if (n->end == ENDBODY_NOT) {
a577 2
				n->lastline = line;
			}
a589 1
			n->lastline = line;
@


1.129
log
@discard .Rs head arguments and improve .Rs diagnostics
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.128 2015/02/03 18:19:27 schwarze Exp $ */
d1043 6
d1112 1
a1112 1
	if (nl && tok != MDOC_Rs)
@


1.128
log
@Avoid closing out an explicit block twice when broken by .It
(assertion failure); regression found in jsg@@'s afl test case 847.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.127 2015/02/03 01:13:48 schwarze Exp $ */
a1027 2
		if (ac == ARGS_PUNCT)
			break;
d1043 7
d1106 1
a1106 1
	if (nl)
@


1.127
log
@Finally delete the kitchensink functions rew_sub() and rew_dohalt().
They were a maintenance and auditing nightmare because if you changed
one bit in there, stuff tended to break at seemingly unrelated places.
No functional change except getting rid of one bogus error message,
but minus 80 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.126 2015/02/03 00:48:27 schwarze Exp $ */
d968 1
@


1.126
log
@Bring .Pp/.Lp handling inside .Nm blocks closer to groff;
as a bonus, get rid of another call to rew_sub().
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.125 2015/02/02 19:22:46 schwarze Exp $ */
a31 7
enum	rew {	/* see rew_dohalt() */
	REWIND_NONE,
	REWIND_THIS,
	REWIND_MORE,
	REWIND_FORCE
};

a52 2
static	enum rew	rew_dohalt(enum mdoct, enum mdoc_type,
				const struct mdoc_node *);
a55 2
static	void		rew_sub(enum mdoc_type, struct mdoc *,
				enum mdoct, int, int);
a346 89
/*
 * Rewinding to tok, how do we have to handle *p?
 * REWIND_NONE: *p would delimit tok, but no tok scope is open
 *   inside *p, so there is no need to rewind anything at all.
 * REWIND_THIS: *p matches tok, so rewind *p and nothing else.
 * REWIND_MORE: *p is implicit, rewind it and keep searching for tok.
 * REWIND_FORCE: *p is explicit, but tok is full, force rewinding *p.
 */
static enum rew
rew_dohalt(enum mdoct tok, enum mdoc_type type,
		const struct mdoc_node *p)
{

	/*
	 * No matching token, no delimiting block, no broken block.
	 * This can happen when full implicit macros are called for
	 * the first time but try to rewind their previous
	 * instance anyway.
	 */
	if (MDOC_ROOT == p->type)
		return(REWIND_NONE);

	/*
	 * When starting to rewind, skip plain text
	 * and nodes that have already been rewound.
	 */
	if (p->type == MDOC_TEXT || p->flags & (MDOC_VALID | MDOC_BREAK))
		return(REWIND_MORE);

	/*
	 * The easiest case:  Found a matching token.
	 * This applies to both blocks and elements.
	 */
	tok = rew_alt(tok);
	if (tok == p->tok)
		return(type == p->type ? REWIND_THIS : REWIND_MORE);

	/*
	 * While elements do require rewinding for themselves,
	 * they never affect rewinding of other nodes.
	 */
	if (MDOC_ELEM == p->type)
		return(REWIND_MORE);

	/*
	 * Blocks delimited by our target token get REWIND_MORE.
	 * Blocks delimiting our target token get REWIND_NONE.
	 */
	switch (tok) {
	case MDOC_It:
		if (MDOC_BODY == p->type && MDOC_Bl == p->tok)
			return(REWIND_NONE);
		break;
	case MDOC_Nm:
		return(REWIND_NONE);
	case MDOC_Nd:
		/* FALLTHROUGH */
	case MDOC_Ss:
		if (MDOC_BODY == p->type && MDOC_Sh == p->tok)
			return(REWIND_NONE);
		/* FALLTHROUGH */
	case MDOC_Sh:
		if (MDOC_ROOT == p->parent->type)
			return(REWIND_THIS);
		if (MDOC_Nd == p->tok || MDOC_Ss == p->tok ||
		    MDOC_Sh == p->tok)
			return(REWIND_MORE);
		break;
	default:
		break;
	}

	/*
	 * Default block rewinding rules.
	 * In particular, let all blocks rewind Nm children.
	 * Do not warn again when closing a block,
	 * since closing the body already warned.
	 */
	if (MDOC_Nm == p->tok ||
	    MDOC_BLOCK == type || MDOC_BLOCK == p->type)
		return(REWIND_MORE);

	/*
	 * By default, closing out full blocks
	 * forces closing of broken explicit blocks.
	 */
	return (REWIND_FORCE);
}

a431 39
static void
rew_sub(enum mdoc_type t, struct mdoc *mdoc,
		enum mdoct tok, int line, int ppos)
{
	struct mdoc_node *n, *to;

	to = NULL;
	n = mdoc->last;
	while (n) {
		switch (rew_dohalt(tok, t, n)) {
		case REWIND_NONE:
			if (to == NULL)
				return;
			n = to;
			break;
		case REWIND_THIS:
			n->lastline = line -
			    (mdoc->flags & MDOC_NEWLINE &&
			     ! (mdoc_macros[tok].flags & MDOC_EXPLICIT));
			break;
		case REWIND_FORCE:
			mandoc_vmsg(MANDOCERR_BLK_BROKEN, mdoc->parse,
			    line, ppos, "%s breaks %s",
			    mdoc_macronames[tok],
			    mdoc_macronames[n->tok]);
			/* FALLTHROUGH */
		case REWIND_MORE:
			n->lastline = line -
			    (mdoc->flags & MDOC_NEWLINE ? 1 : 0);
			to = n;
			n = n->parent;
			continue;
		}
		break;
	}
	assert(n);
	rew_pending(mdoc, n);
}

d542 1
d546 1
a546 1
	int		 have_it, j, lastarg, maxargs, nl;
a569 1
	have_it = 0;
d571 1
a571 1
	body = endbody = later = NULL;
d590 1
a590 1
			have_it = 1;
d605 1
a605 1
			    (tok == MDOC_El && !have_it))
d615 2
d671 1
a671 1
		if (endbody == NULL)
d902 1
a902 1
	struct mdoc_node *blk; /* Our own block. */
d911 43
a953 1
	/* Skip items outside lists. */
d955 3
a957 4
	if (tok == MDOC_It) {
		for (n = mdoc->last; n; n = n->parent)
			if (n->tok == MDOC_Bl && n->type == MDOC_BLOCK &&
			    ! (n->flags & (MDOC_VALID | MDOC_BREAK)))
d959 19
a977 1
		if (n == NULL) {
a983 7
	}

	/* Close out prior implicit scope. */

	if ( ! (mdoc_macros[tok].flags & MDOC_EXPLICIT)) {
		rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
		rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
@


1.125
log
@Simplify and reindent make_pending().  No functional change
except that some error messages become less confusing.
Now the function is almost readable (but still requires
nineteen lines of comments for fourteen lines of code).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.124 2015/02/02 18:26:06 schwarze Exp $ */
d1460 2
a1461 1
	struct mdoc_arg	*arg;
d1463 8
a1470 2
	if (tok == MDOC_Pp)
		rew_sub(MDOC_BLOCK, mdoc, MDOC_Nm, line, ppos);
@


1.124
log
@Simplify: Do not call rew_dohalt() from make_pending(),
the calling macro handler already found the breaking block.
No functional change except tiny variations in error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.123 2015/02/02 15:02:17 schwarze Exp $ */
d472 3
a474 1
	/* Iterate backwards, searching for the breaker. */
d476 11
a486 1
	for (n = broken->parent; ; n = n->parent) {
d488 2
a489 13
		/*
		 * If the *broken block (Z) is already broken and we
		 * encounter its breaker (B), make the tok block (A)
		 * pending on that inner breaker (B).
		 * Graphically, [A n=[B! broken=[Z->B B] tok=A] Z]
		 * becomes [A broken=[B! [Z->B B] tok=A] Z]
		 * and finally [A! [B!->A [Z->B B] A] Z].
		 * In these graphics, "->" indicates the "pending"
		 * pointer and "!" indicates the MDOC_BREAK flag.
		 * Each of the cases gets one additional pointer (B->A)
		 * and one additional flag (A!).
		 */
		if (n == broken->pending) {
d491 13
a503 2
			continue;
		}
d505 2
a506 2
		if (n != breaker)
			continue;
d509 5
a513 8
		 * Found the breaker.
		 * If another, outer breaker (X) is already pending on
		 * the *broken block (B), we must not clobber the link
		 * to the outer breaker, but make it pending on the
		 * new, now inner breaker (A).
		 * Graphically, [X! breaker=[A broken=[B->X X] tok=A] B]
		 * becomes [X! breaker=[A->X broken=[B X] tok=A] B]
		 * and finally [X! [A!->X [B->A X] A] B].
a514 2
		if (broken->pending) {
			struct mdoc_node *taker;
d516 9
a524 13
			/*
			 * If the inner breaker (A) is already broken,
			 * too, it cannot take on the outer breaker (X)
			 * but must hand it on to its own breakers (Y):
			 * [X! [Y! breaker=[A->Y Y] broken=[B->X X] tok=A] B]
			 * [X! take=[Y!->X brea=[A->Y Y] brok=[B X] tok=A] B]
			 * and finally [X! [Y!->X [A!->Y Y] [B->A X] A] B].
			 */
			taker = breaker;
			while (taker->pending)
				taker = taker->pending;
			taker->pending = broken->pending;
		}
d526 4
a529 14
		/*
		 * Now we have reduced the situation to the simplest
		 * case, which is just breaker=[A broken=[B tok=A] B]
		 * and becomes [A! [B->A A] B].
		 */
		broken->pending = breaker;
		breaker->flags |= MDOC_BREAK;
		if (breaker->body != NULL)
			breaker->body->flags |= MDOC_BREAK;
		mandoc_vmsg(MANDOCERR_BLK_NEST, mdoc->parse, line, ppos,
		    "%s breaks %s", mdoc_macronames[breaker->tok],
		    mdoc_macronames[broken->tok]);
		return;
	}
@


1.123
log
@Get rid of all remaining calls to rew_sub() where the target block
is known.  This only leaves three that do actual searching.
No functional change, minus 30 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.122 2015/02/02 04:26:03 schwarze Exp $ */
d55 2
a56 2
static	int		make_pending(struct mdoc_node *, enum mdoct,
				struct mdoc *, int, int);
d461 1
a461 1
 * We are trying to close a block identified by tok,
d463 1
a463 1
 * Thus, postpone closing the tok block
d466 3
a468 3
static int
make_pending(struct mdoc_node *broken, enum mdoct tok,
		struct mdoc *mdoc, int line, int ppos)
d470 1
a470 1
	struct mdoc_node *breaker;
d472 3
a474 5
	/*
	 * Iterate backwards, searching for the block matching tok,
	 * that is, the block breaking the *broken block.
	 */
	for (breaker = broken->parent; breaker; breaker = breaker->parent) {
d480 2
a481 2
		 * Graphically, [A breaker=[B! broken=[Z->B B] tok=A] Z]
		 * becomes breaker=[A broken=[B! [Z->B B] tok=A] Z]
d488 2
a489 2
		if (breaker == broken->pending) {
			broken = breaker;
d493 1
a493 1
		if (REWIND_THIS != rew_dohalt(tok, MDOC_BLOCK, breaker))
a494 2
		if (MDOC_BODY == broken->type)
			broken = broken->parent;
d533 1
a533 1
		    "%s breaks %s", mdoc_macronames[tok],
d535 1
a535 1
		return(1);
a536 6

	/*
	 * Found no matching block for tok.
	 * Are you trying to close a block that is not open?
	 */
	return(0);
d760 1
a760 1
			make_pending(later, tok, mdoc, line, ppos);
d1286 1
a1286 1
			make_pending(n, tok, mdoc, line, ppos);
@


1.122
log
@Get rid of all calls to rew_sub() in blk_exp_close(); only ten calls
remain in other functions.  As a bonus, this fixes an assertion failure
jsg@@ found some time ago with afl (test case 982) and improves minor
details in error reporting.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.121 2015/02/02 04:04:18 schwarze Exp $ */
d36 1
a36 3
	REWIND_FORCE,
	REWIND_LATER,
	REWIND_ERROR
a364 2
 * REWIND_LATER: *p is explicit and still open, postpone rewinding.
 * REWIND_ERROR: No tok block is open at all.
d378 1
a378 3
		return(MDOC_BLOCK == type &&
		    MDOC_EXPLICIT & mdoc_macros[tok].flags ?
		    REWIND_ERROR : REWIND_NONE);
d393 1
a393 2
		return(p->end ? REWIND_NONE :
		    type == p->type ? REWIND_THIS : REWIND_MORE);
a406 4
	case MDOC_Bl:
		if (MDOC_It == p->tok)
			return(REWIND_MORE);
		break;
a410 10
	/*
	 * XXX Badly nested block handling still fails badly
	 * when one block is breaking two blocks of the same type.
	 * This is an incomplete and extremely ugly workaround,
	 * required to let the OpenBSD tree build.
	 */
	case MDOC_Oo:
		if (MDOC_Op == p->tok)
			return(REWIND_MORE);
		break;
d432 1
a432 2
	 * In particular, always skip block end markers,
	 * and let all blocks rewind Nm children.
d436 2
a437 3
	if (ENDBODY_NOT != p->end || MDOC_Nm == p->tok ||
	    MDOC_BLOCK == type || (MDOC_BLOCK == p->type &&
	    ! (MDOC_EXPLICIT & mdoc_macros[tok].flags)))
d442 1
a442 3
	 * forces closing of broken explicit blocks,
	 * while closing out partial blocks
	 * allows delayed rewinding by default.
d444 1
a444 2
	return (&blk_full == mdoc_macros[tok].fp ?
	    REWIND_FORCE : REWIND_LATER);
d464 1
a464 1
 * until the rew_sub call closing *broken.
a580 10
		case REWIND_LATER:
			if (make_pending(n, tok, mdoc, line, ppos) ||
			    t != MDOC_BLOCK)
				return;
			/* FALLTHROUGH */
		case REWIND_ERROR:
			mandoc_msg(MANDOCERR_BLK_NOTOPEN,
			    mdoc->parse, line, ppos,
			    mdoc_macronames[tok]);
			return;
d765 3
a767 3
			 * When there is a pending sub block,
			 * postpone closing out the current block
			 * until the rew_sub() closing out the sub-block.
d825 2
a826 1
		rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
d1141 2
a1142 1
			rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
d1176 1
a1176 2
			rew_sub(body ? MDOC_BODY : MDOC_HEAD,
			    mdoc, tok, line, ppos);
d1210 1
a1210 1
	 * head to body until the rew_sub() call closing out that
d1224 2
a1225 2
	rew_sub(MDOC_HEAD, mdoc, tok, line, ppos);
	mdoc_body_alloc(mdoc, line, ppos, tok);
d1228 2
a1229 2
		rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
		rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
d1287 2
a1288 2
	 * postpone closing out the current block
	 * until the rew_sub() call closing out the sub-block.
d1530 1
a1530 1
	struct mdoc_node *n;
d1534 10
a1543 4
	n = mdoc->last;
	while (n != NULL &&
	    (n->tok != MDOC_Bl || n->flags & (MDOC_VALID | MDOC_BREAK)))
		n = n->parent;
d1552 1
a1552 1
	rew_sub(MDOC_BODY, mdoc, MDOC_It, line, ppos);
@


1.121
log
@When a full block macro gets closed out by a mismatching
block closure macro it calls, do not attempt to open its body.
This can for example happen for (nonsensical) constructions like
.Fo
.Nm Fc
in the SYNOPSIS.  Fixing an assertion failure jsg@@ found with afl
some time ago (test case number 731).
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.120 2015/02/01 23:55:37 schwarze Exp $ */
d66 1
d265 3
d276 3
d296 19
d560 2
d621 1
a621 11
	rew_last(mdoc, n);

	/*
	 * The current block extends an enclosing block.
	 * Now that the current block ends, close the enclosing block, too.
	 */
	while ((n = n->pending) != NULL) {
		rew_last(mdoc, n);
		if (n->type == MDOC_HEAD)
			mdoc_body_alloc(mdoc, n->line, n->pos, n->tok);
	}
d735 1
a735 1
	struct mdoc_node *n;		/* For searching backwards. */
d737 1
a737 1
	int		 flushed, have_it, j, lastarg, maxargs, nl;
d771 1
a771 1
			if (n->end == ENDBODY_NOT)
d773 2
d787 1
d813 1
a813 1
			mdoc_endbody_alloc(mdoc, line, ppos,
d819 1
a819 2
			 * into the end marker and remeber the
			 * end marker in order to close it out.
d822 1
a822 2
			if (maxargs) {
				endbody = mdoc->last;
a823 1
			}
d837 17
a853 1
	rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
d865 2
a866 13
	if (maxargs && endbody == NULL) {
		if (n == NULL) {
			/*
			 * Stray .Ec without previous .Eo:
			 * Break the output line, ignore any arguments.
			 */
			mdoc_elem_alloc(mdoc, line, ppos, MDOC_br, NULL);
			rew_elem(mdoc, MDOC_br);
		} else
			mdoc_tail_alloc(mdoc, line, ppos, atok);
	}

	flushed = n == NULL;
d870 3
a872 6
		if (j == maxargs && ! flushed) {
			if (endbody == NULL)
				rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
			else
				rew_last(mdoc, endbody);
			flushed = 1;
d888 3
a890 6
		if ( ! flushed) {
			if (endbody == NULL)
				rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
			else
				rew_last(mdoc, endbody);
			flushed = 1;
d897 2
a898 6
	if ( ! flushed) {
		if (endbody == NULL)
			rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
		else
			rew_last(mdoc, endbody);
	}
d1341 1
a1341 12
	rew_last(mdoc, blk);

	/*
	 * The current block extends an enclosing block.
	 * Now that the current block ends, close the enclosing block, too.
	 */

	while ((blk = blk->pending) != NULL) {
		rew_last(mdoc, blk);
		if (blk->type == MDOC_HEAD)
			mdoc_body_alloc(mdoc, blk->line, blk->pos, blk->tok);
	}
@


1.120
log
@get rid of rew_sub() in blk_part_imp(); no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.119 2015/02/01 17:30:34 schwarze Exp $ */
d1078 3
a1080 2
	struct mdoc_node *head; /* save of head macro */
	struct mdoc_node *body; /* save of body macro */
d1120 1
a1120 1
	mdoc_block_alloc(mdoc, line, ppos, tok, arg);
d1220 2
@


1.119
log
@Simplify blk_part_exp(), no functional change.
* Replace calls to rew_sub() with rew_last() - two less out of 18.
* No need to keep track of the body, it's always opened right after
the head and never used for anything in this function.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.118 2015/02/01 16:46:57 schwarze Exp $ */
d1322 1
a1322 1
	rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
d1325 12
a1336 1
	rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
@


1.118
log
@The function rew_sub() tries to rewind any all all kinds of blocks
and elements under any and all circumstances, even handling some
bad block nesting now and then.  Little surprisingly, this ends up
in excessive complexity and has caused many bugs in the past.
Start to slowly disentangle this mess by replacing calls to rew_sub()
immediately following mdoc_head_alloc() by the much simpler rew_last().
Gets rid of the first two rew_sub() calls out of twenty.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.117 2014/12/22 23:26:20 schwarze Exp $ */
a1340 1
	struct mdoc_node *body; /* keep track of body */
d1352 2
a1353 1
	for (head = body = NULL; ; ) {
a1362 1
			assert(NULL == body);
a1367 1
			assert(body == NULL);
d1369 1
a1369 11
		}

		/*
		 * `Eo' gobbles any data into the head, but most other
		 * macros just immediately close out and begin the body.
		 */

		if (body == NULL) {
			assert(head);
			/* No check whether it's a macro! */
			if (tok == MDOC_Eo)
d1371 2
a1372 2
			rew_sub(MDOC_HEAD, mdoc, tok, line, ppos);
			body = mdoc_body_alloc(mdoc, line, ppos, tok);
a1375 1
		assert(head != NULL && body != NULL);
d1383 2
a1384 5
	if (head == NULL)
		mdoc_head_alloc(mdoc, line, ppos, tok);

	if (body == NULL) {
		rew_sub(MDOC_HEAD, mdoc, tok, line, ppos);
@


1.117
log
@The code already pays attention not to close the same block twice.
Similarly, avoid having the same block break two other blocks.
In some situations, this could lead to an endless loop in rew_sub()
found by jsg@@ with afl.
Minimal example:  .Po Ao Pc Bo Pc Ac Bc
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.116 2014/12/20 02:26:42 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d1138 1
a1138 1
		rew_sub(MDOC_HEAD, mdoc, tok, line, ppos);
d1275 1
a1275 2
	mdoc_head_alloc(mdoc, line, ppos, tok);
	rew_sub(MDOC_HEAD, mdoc, tok, line, ppos);
@


1.116
log
@Fix two issues causing a class of assertion failures found by jsg@@ with afl.
1) rew_sub(): Make sure REWIND_MORE is acted upon even when followed by
REWIND_NONE.  This prevents .It from ending up inside other children of .Bl.
2) blk_exp_close(): Only allow extension of .Bl when it has at least
one .It.  Otherwise, a broken child block could be moved in front of
the .Bl, effectively resulting in a .Bl that ended before it began.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.115 2014/12/18 20:58:00 schwarze Exp $ */
d364 1
a364 1
	if (MDOC_TEXT == p->type || MDOC_VALID & p->flags)
d747 1
a747 1
		if (n->flags & MDOC_VALID)
@


1.115
log
@Don't let .Ta creep into an already-closed list; same as for .It.
Fixes an assertion found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.114 2014/12/18 03:09:42 schwarze Exp $ */
d551 1
a551 1
	struct mdoc_node *n;
d553 1
d558 4
a561 1
			return;
d576 1
d719 1
a719 1
	int		 j, lastarg, maxargs, flushed, nl;
d743 1
d760 6
d775 2
a776 1
			if (later == NULL)
d815 2
a816 4
		if (later &&
		    mdoc_macros[later->tok].flags & MDOC_EXPLICIT)
			continue;
		if (n->tok != MDOC_It)
@


1.114
log
@The code is already careful to not add items to lists that were
already closed.  In this respect, also consider lists closed
that have broken another block, their closure pending until the
end of the broken block.  This avoids syntax tree corruption
leading to a NULL pointer access found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.113 2014/12/13 13:13:26 schwarze Exp $ */
d1560 2
a1561 1
	while (n != NULL && n->tok != MDOC_Bl)
@


1.113
log
@Fix a regression found by Carsten dot Kunze at arcor dot de:
Do not show bogus quotes when .Bl -column phrases are quoted.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.112 2014/11/30 05:28:00 schwarze Exp $ */
d479 10
a488 6
		 * If the *broken block had already been broken before
		 * and we encounter its breaker, make the tok block
		 * pending on the inner breaker.
		 * Graphically, "[A breaker=[B broken=[C->B B] tok=A] C]"
		 * becomes "[A broken=[B [C->B B] tok=A] C]"
		 * and finally "[A [B->A [C->B B] A] C]".
d502 2
a503 2
		 * If another, outer breaker is already pending on
		 * the *broken block, we must not clobber the link
d505 4
a508 4
		 * new, now inner breaker.
		 * Graphically, "[A breaker=[B broken=[C->A A] tok=B] C]"
		 * becomes "[A breaker=[B->A broken=[C A] tok=B] C]"
		 * and finally "[A [B->A [C->B A] B] C]".
d514 6
a519 6
			 * If the breaker had also been broken before,
			 * it cannot take on the outer breaker itself,
			 * but must hand it on to its own breakers.
			 * Graphically, this is the following situation:
			 * "[A [B breaker=[C->B B] broken=[D->A A] tok=C] D]"
			 * "[A taker=[B->A breaker=[C->B B] [D->C A] C] D]"
d526 6
d533 1
d1079 2
a1080 2
			if (n->tok == MDOC_Bl &&
			    ! (n->flags & MDOC_VALID))
@


1.112
log
@Multiple fixes with respect to .Pf:
* The first argument of .Pf is not parsed.
* Normal delimiter handling does not apply to the first argument of .Pf.
* Warn if nothing follows a prefix (inspired by groff_mdoc(7)).
* In that case, do not suppress spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.111 2014/11/30 02:31:32 schwarze Exp $ */
d673 1
a673 3
	if (mdoc->flags & MDOC_PHRASELIT)
		/* nothing */;
	else if (*p == '"')
d675 1
a675 1
	else if (parsed)
@


1.111
log
@warn about attempts to call non-callable macros;
inspired by a similar warning in the groff_mdoc(7) macros
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.110 2014/11/29 04:31:33 schwarze Exp $ */
d1397 1
a1397 1
	nl = MDOC_NEWLINE & mdoc->flags;
d1429 3
a1431 1
	for (flushed = j = 0; ; ) {
d1434 5
a1438 1
		if (ac == ARGS_PUNCT || ac == ARGS_EOLN)
d1440 1
d1455 2
a1456 2
		ntok = ac == ARGS_QWORD ? MDOC_MAX :
		    lookup(mdoc, tok, line, la, p);
d1479 1
a1479 1
	if (j == 0)
d1481 3
@


1.110
log
@Reduce code duplication by reusing the same argument parser
for in_line_eoln() macros and .Bl -column phrases.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.109 2014/11/29 03:37:28 schwarze Exp $ */
d54 2
a55 1
static	enum mdoct	lookup(enum mdoct, const char *);
d247 1
a247 1
lookup(enum mdoct from, const char *p)
d253 7
a259 2
		if (res != MDOC_MAX && mdoc_macros[res].flags & MDOC_CALLABLE)
			return(res);
d678 1
a678 1
		ntok = lookup(tok, p);
d839 2
a840 1
		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup(tok, p);
d941 1
a941 1
		    MDOC_MAX : lookup(tok, p);
d1448 2
a1449 1
		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup(tok, p);
@


1.109
log
@Provide a helper function macro_or_word() and use it to prune the
same chunk of argument parsing code out of five of the eight callback
functions.  The other three have too much special handling to
participate.
As a bonus, let lookup() and mdoc_args() deal with line macros and
retire the lookup_raw() helper and the mdoc_zargs() internal interface
function.
No functional change, minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.108 2014/11/28 23:20:55 schwarze Exp $ */
d58 2
a59 1
static	void		phrase(struct mdoc *, int, int *, char *);
d1183 1
a1183 1
			phrase(mdoc, line, &la, buf);
a1474 1
	int		 la;
d1482 14
d1500 1
a1500 1
			break;
d1502 1
a1502 1
			return;
a1503 1
	rew_elem(mdoc, tok);
a1525 11
phrase(struct mdoc *mdoc, int line, int *pos, char *buf)
{
	int		 la;

	do
		la = *pos;
	while (mdoc_args(mdoc, line, pos, buf, MDOC_MAX, NULL) != ARGS_EOLN &&
	    !macro_or_word(mdoc, MDOC_MAX, line, la, pos, buf, 1));
}

static void
d1545 1
a1545 1
	phrase(mdoc, line, pos, buf);
@


1.108
log
@Fold the loop around mdoc_argv() into the function itself,
it was the same in all four cases.  As a bonus, get rid
of one enum type that was used for internal communication.
No functional change, minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.107 2014/11/28 04:46:30 schwarze Exp $ */
d55 1
a55 1
static	enum mdoct	lookup_raw(const char *);
d58 1
a58 1
static	void		phrase(struct mdoc *, int, int, char *);
d241 2
a242 1
 * Look up a macro from within a subsequent context.
a246 12

	if ( ! (MDOC_PARSED & mdoc_macros[from].flags))
		return(MDOC_MAX);
	return(lookup_raw(p));
}

/*
 * Lookup a macro following the initial line macro.
 */
static enum mdoct
lookup_raw(const char *p)
{
d249 5
a253 4
	if (MDOC_MAX == (res = mdoc_hash_find(p)))
		return(MDOC_MAX);
	if (MDOC_CALLABLE & mdoc_macros[res].flags)
		return(res);
d624 1
a625 2
	enum margserr	 ac;
	char		*p;
d632 1
a632 2
		ac = mdoc_zargs(mdoc, line, pos, buf, &p);
		if (ac == ARGS_EOLN)
d654 34
d1048 1
a1048 1
	int		  la, nl, nparsed;
a1052 1
	enum mdoct	  ntok;
d1099 3
a1101 3
	nparsed = tok == MDOC_It &&
	    mdoc->last->parent->tok == MDOC_Bl &&
	    mdoc->last->parent->norm->Bl.type == LIST_diag;
d1182 1
a1182 1
			phrase(mdoc, line, la, buf);
d1187 1
a1187 5
		ntok = nparsed || ac == ARGS_QWORD ?
		    MDOC_MAX : lookup(tok, p);

		if (ntok != MDOC_MAX) {
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
a1188 3
		}
		dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags);
a1228 1
	enum mdoct	  ntok;
d1271 1
a1271 4
		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup(tok, p);

		if (ntok != MDOC_MAX) {
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
a1272 3
		}
		dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags);
a1315 1
	enum mdoct	  ntok;
d1363 1
a1363 3
		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup(tok, p);
		if (ntok != MDOC_MAX) {
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
a1364 3
		}
		dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags);
a1474 1
	enum margserr	 ac;
a1475 4
	char		*p;
	enum mdoct	 ntok;

	assert( ! (MDOC_PARSED & mdoc_macros[tok].flags));
a1482 2
	/* Parse argument terms. */

d1485 1
a1485 2
		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);
		if (ac == ARGS_EOLN)
d1487 1
a1487 6

		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup(tok, p);

		if (ntok != MDOC_MAX) {
			rew_elem(mdoc, tok);
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
a1488 3
		}
		dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags);
a1489 3

	/* Close out (no delimiters). */

d1513 1
a1513 1
phrase(struct mdoc *mdoc, int line, int ppos, char *buf)
d1515 1
a1515 4
	int		 la, pos;
	enum margserr	 ac;
	enum mdoct	 ntok;
	char		*p;
d1517 4
a1520 16
	for (pos = ppos; ; ) {
		la = pos;

		ac = mdoc_zargs(mdoc, line, &pos, buf, &p);
		if (ac == ARGS_EOLN)
			break;

		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup_raw(p);

		if (ntok != MDOC_MAX) {
			mdoc_macro(mdoc, ntok, line, la, &pos, buf);
			append_delims(mdoc, line, &pos, buf);
			return;
		}
		dword(mdoc, line, la, p, DELIM_MAX, 1);
	}
a1526 4
	int		  la;
	enum mdoct	  ntok;
	enum margserr	  ac;
	char		 *p;
d1543 1
a1543 17

	for (;;) {
		la = *pos;
		ac = mdoc_zargs(mdoc, line, pos, buf, &p);
		if (ac == ARGS_EOLN)
			break;

		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup_raw(p);

		if (ntok != MDOC_MAX) {
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
			append_delims(mdoc, line, pos, buf);
			return;
		}
		dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags);
	}
@


1.107
log
@Simplify by making the mdoc parser callbacks void, and some cleanup;
no functional change, minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.106 2014/11/28 03:13:58 schwarze Exp $ */
a843 1
	enum margverr	 av;
d876 1
a876 9
	for (arg = NULL;; ) {
		la = *pos;
		av = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
		if (av == ARGV_ARG)
			continue;
		if (av == ARGV_WORD)
			*pos = la;
		break;
	}
a1032 1
	enum margverr	  av;
d1069 1
a1069 10
	for (arg = NULL;; ) {
		la = *pos;
		av = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
		if (av == ARGV_ARG)
			continue;
		if (av == ARGV_WORD)
			*pos = la;
		break;
	}

a1383 1
	enum margverr	 av;
d1418 1
a1418 9
	for (arg = NULL; ; ) {
		la = *pos;
		av = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
		if (av == ARGV_ARG)
			continue;
		if (av == ARGV_WORD)
			*pos = la;
		break;
	}
a1474 1
	enum margverr	 av;
d1484 1
a1484 14
	/* Parse macro arguments. */

	for (arg = NULL; ; ) {
		la = *pos;
		av = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
		if (av == ARGV_ARG)
			continue;
		if (av == ARGV_WORD)
			*pos = la;
		break;
	}

	/* Open element scope. */

@


1.106
log
@Simplify the code by making various mdoc parser helper functions void.
No functional change, minus 130 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.105 2014/11/28 01:05:40 schwarze Exp $ */
d41 9
a49 9
static	int		blk_full(MACRO_PROT_ARGS);
static	int		blk_exp_close(MACRO_PROT_ARGS);
static	int		blk_part_exp(MACRO_PROT_ARGS);
static	int		blk_part_imp(MACRO_PROT_ARGS);
static	int		ctx_synopsis(MACRO_PROT_ARGS);
static	int		in_line_eoln(MACRO_PROT_ARGS);
static	int		in_line_argn(MACRO_PROT_ARGS);
static	int		in_line(MACRO_PROT_ARGS);
static	int		phrase_ta(MACRO_PROT_ARGS);
d58 1
a58 1
static	int		phrase(struct mdoc *, int, int, char *);
d219 1
a219 1
int
d226 1
a226 1
	n = MDOC_VALID & mdoc->last->flags ?
d230 2
a231 2
		if (MDOC_BLOCK == n->type &&
		    MDOC_EXPLICIT & mdoc_macros[n->tok].flags)
a237 1
	return(1);
d668 1
a668 1
static int
d689 1
d699 1
d707 1
d724 1
d733 1
d740 1
d743 8
d763 1
d770 1
a777 1
		rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
d779 1
a779 1
		return(1);
a780 1
	rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
a824 1

d826 1
a826 3

		if ( ! mdoc_macro(mdoc, ntok, line, lastarg, pos, buf))
			return(0);
a837 1
	return(1);
d840 1
a840 1
static int
d880 3
a882 2

		if (ARGV_WORD == av) {
d884 1
a884 9
			break;
		}
		if (ARGV_EOLN == av)
			break;
		if (ARGV_ARG == av)
			continue;

		mdoc_argv_free(arg);
		return(0);
d941 1
a941 3

			if ( ! mdoc_macro(mdoc, ntok, line, la, pos, buf))
				return(0);
d944 1
a944 1
			return(1);
a1029 1
	return(1);
d1032 1
a1032 1
static int
d1059 1
a1059 1
			return(1);
d1082 3
a1084 2

		if (ARGV_WORD == av) {
d1086 1
a1086 10
			break;
		}

		if (ARGV_EOLN == av)
			break;
		if (ARGV_ARG == av)
			continue;

		mdoc_argv_free(arg);
		return(0);
d1096 1
d1160 1
a1167 3

			/* Then allocate our body context. */

d1180 1
a1180 4

			if ( ! phrase(mdoc, line, la, buf))
				return(0);

d1188 3
a1190 4
		if (ntok == MDOC_MAX) {
			dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags);
			continue;
d1192 2
a1193 4

		if ( ! mdoc_macro(mdoc, ntok, line, la, pos, buf))
			return(0);
		break;
d1200 1
a1200 4

	/* If we've already opened our body, exit now. */

	if (NULL != body)
d1210 3
a1212 3
		if (MDOC_BLOCK == n->type &&
		    MDOC_EXPLICIT & mdoc_macros[n->tok].flags &&
		    ! (MDOC_VALID & n->flags)) {
d1214 1
a1214 1
			return(1);
a1221 1

a1227 1
	return(1);
d1230 1
a1230 1
static int
d1279 3
a1281 4
		if (ntok == MDOC_MAX) {
			dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags);
			continue;
d1283 2
a1284 4

		if ( ! mdoc_macro(mdoc, ntok, line, la, pos, buf))
			return(0);
		break;
a1285 3

	/* Clean-ups to leave in a consistent state. */

d1294 1
d1303 1
a1303 1
			return(1);
a1307 3

	/* Standard appending of delimiters. */

a1309 3

	/* Rewind scope, if applicable. */

a1317 2

	return(1);
d1320 1
a1320 1
static int
d1377 3
a1379 4
		if (ntok == MDOC_MAX) {
			dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags);
			continue;
d1381 2
a1382 3
		if ( ! mdoc_macro(mdoc, ntok, line, la, pos, buf))
			return(0);
		break;
a1393 3

	/* Standard appending of delimiters. */

a1395 1
	return(1);
d1398 1
a1398 1
static int
d1441 3
a1443 2

		if (ARGV_WORD == av) {
d1445 1
a1445 10
			break;
		}

		if (ARGV_EOLN == av)
			break;
		if (ARGV_ARG == av)
			continue;

		mdoc_argv_free(arg);
		return(0);
d1473 1
a1473 2
			if ( ! mdoc_macro(mdoc, ntok, line, la, pos, buf))
				return(0);
a1491 3

	/* Close out in a consistent state. */

a1495 1
	return(1);
d1498 1
a1498 1
static int
d1518 3
a1520 2

		if (ARGV_WORD == av) {
d1522 1
a1522 9
			break;
		}
		if (ARGV_EOLN == av)
			break;
		if (ARGV_ARG == av)
			continue;

		mdoc_argv_free(arg);
		return(0);
d1539 4
a1542 4
		if (ntok == MDOC_MAX) {
			dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags);
			continue;
d1544 2
a1545 2
		rew_elem(mdoc, tok);
		return(mdoc_macro(mdoc, ntok, line, la, pos, buf));
a1550 1
	return(1);
d1553 1
a1553 1
static int
a1555 1
	int		 nl;
d1557 8
a1564 19
	nl = MDOC_NEWLINE & mdoc->flags;

	/* If we're not in the SYNOPSIS, go straight to in-line. */
	if ( ! (MDOC_SYNOPSIS & mdoc->flags))
		return(in_line(mdoc, tok, line, ppos, pos, buf));

	/* If we're a nested call, same place. */
	if ( ! nl)
		return(in_line(mdoc, tok, line, ppos, pos, buf));

	/*
	 * XXX: this will open a block scope; however, if later we end
	 * up formatting the block scope, then child nodes will inherit
	 * the formatting.  Be careful.
	 */
	if (MDOC_Nm == tok)
		return(blk_full(mdoc, tok, line, ppos, pos, buf));
	assert(MDOC_Vt == tok);
	return(blk_part_imp(mdoc, tok, line, ppos, pos, buf));
d1572 1
a1572 1
static int
d1589 4
a1592 3
		if (ntok == MDOC_MAX) {
			dword(mdoc, line, la, p, DELIM_MAX, 1);
			continue;
d1594 1
a1594 5

		if ( ! mdoc_macro(mdoc, ntok, line, la, &pos, buf))
			return(0);
		append_delims(mdoc, line, &pos, buf);
		return(1);
a1595 2

	return(1);
d1598 1
a1598 1
static int
d1608 1
d1610 1
a1610 1
	while (NULL != n && MDOC_Bl != n->tok)
d1612 1
a1612 1
	if (NULL == n || LIST_column != n->norm->Bl.type) {
d1615 1
a1615 1
		return(1);
d1631 4
a1634 4
		if (ntok == MDOC_MAX) {
			dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags);
			continue;
d1636 2
a1637 5

		if ( ! mdoc_macro(mdoc, ntok, line, la, pos, buf))
			return(0);
		append_delims(mdoc, line, pos, buf);
		return(1);
a1638 2

	return(1);
@


1.105
log
@Simplify code by making mdoc validation handlers void.
No functional change, minus 90 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.104 2014/11/27 22:27:40 schwarze Exp $ */
d51 1
a51 1
static	int		dword(struct mdoc *, int, int, const char *,
d53 1
a53 2
static	int		append_delims(struct mdoc *,
				int, int *, char *);
d64 1
a64 1
static	int		rew_sub(enum mdoc_type, struct mdoc *,
d540 1
a540 1
static int
d550 1
a550 1
			return(1);
d553 2
a554 2
			    (MDOC_NEWLINE & mdoc->flags &&
			     ! (MDOC_EXPLICIT & mdoc_macros[tok].flags));
d564 1
a564 1
			    (MDOC_NEWLINE & mdoc->flags ? 1 : 0);
d569 2
a570 2
			    MDOC_BLOCK != t)
				return(1);
d576 1
a576 1
			return(1);
a579 1

d587 1
a587 1
	while (NULL != (n = n->pending)) {
d589 2
a590 3
		if (MDOC_HEAD == n->type &&
		    ! mdoc_body_alloc(mdoc, n->line, n->pos, n->tok))
			return(0);
a591 2

	return(1);
d598 1
a598 1
static int
d603 1
a603 1
	if (DELIM_MAX == d)
d607 3
a609 3
	    ! ((MDOC_SYNOPSIS | MDOC_KEEP | MDOC_SMOFF) & mdoc->flags) &&
	    DELIM_NONE == d && MDOC_TEXT == mdoc->last->type &&
	    DELIM_NONE == mdoc_isdelim(mdoc->last->string)) {
d611 1
a611 1
		return(1);
d614 1
a614 2
	if ( ! mdoc_word_alloc(mdoc, line, col, p))
		return(0);
a628 1

a629 2

	return(1);
d632 1
a632 1
static int
d639 2
a640 2
	if ('\0' == buf[*pos])
		return(1);
d645 1
a645 4

		if (ARGS_ERROR == ac)
			return(0);
		else if (ARGS_EOLN == ac)
a646 1

d660 1
a663 2

	return(1);
d702 1
a702 1
		if (MDOC_VALID & n->flags)
d706 2
a707 2
		if (MDOC_BODY == n->type && atok == n->tok) {
			if (ENDBODY_NOT == n->end)
d712 1
a712 1
		if (MDOC_BLOCK != n->type || MDOC_Nm == n->tok)
d722 1
a722 1
			if (NULL == later)
d736 2
a737 3
			if ( ! mdoc_endbody_alloc(mdoc, line, ppos,
			    atok, body, ENDBODY_SPACE))
				return(0);
d751 1
a751 1
		    MDOC_EXPLICIT & mdoc_macros[later->tok].flags)
d753 1
a753 1
		if (MDOC_It != n->tok)
d757 2
a758 2
	if ( ! (MDOC_PARSED & mdoc_macros[tok].flags)) {
		if ('\0' != buf[*pos])
d763 3
a765 3
		if ( ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
			return(0);
		return(rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos));
d767 1
a767 3

	if ( ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
		return(0);
d775 1
a775 3
			if ( ! mdoc_elem_alloc(mdoc, line, ppos,
			    MDOC_br, NULL))
				return(0);
d777 2
a778 2
		} else if ( ! mdoc_tail_alloc(mdoc, line, ppos, atok))
			return(0);
d786 3
a788 1
			if (endbody != NULL)
a789 2
			else if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
				return(0);
d794 1
a794 6

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_PUNCT == ac)
			break;
		if (ARGS_EOLN == ac)
d797 1
a797 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);
d799 3
a801 4
		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, lastarg, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags))
				return(0);
d806 3
a808 1
			if (endbody != NULL)
a809 2
			else if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
				return(0);
d821 3
a823 1
		if (endbody != NULL)
a824 2
		else if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
			return(0);
d826 3
a828 4

	if ( ! nl)
		return(1);
	return(append_delims(mdoc, line, pos, buf));
a891 3
		if (ac == ARGS_ERROR)
			return(0);

d927 1
a927 1
		if (MDOC_MAX != ntok) {
d930 2
a931 4
			if (nc && 0 == cnt) {
				if ( ! mdoc_elem_alloc(mdoc,
				    line, ppos, tok, arg))
					return(0);
d933 1
a933 1
			} else if ( ! nc && 0 == cnt) {
d942 3
a944 3
			if ( ! nl)
				return(1);
			return(append_delims(mdoc, line, pos, buf));
d953 1
a953 1
		d = ARGS_QWORD == ac ? DELIM_NONE : mdoc_isdelim(p);
d965 1
a965 3
				if ( ! mdoc_elem_alloc(mdoc,
				    line, ppos, tok, arg))
					return(0);
d968 1
a968 1
				if (MDOC_Nm == tok)
d981 1
a981 2
			if ( ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
				return(0);
d986 2
a987 3
		if ( ! dword(mdoc, line, la, p, d,
		    MDOC_JOIN & mdoc_macros[tok].flags))
			return(0);
d1003 1
a1003 1
		if (scope && MDOC_Fl == tok) {
d1018 9
a1026 8
	if (nc && 0 == cnt) {
		if ( ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
			return(0);
		rew_last(mdoc, mdoc->last);
	} else if ( ! nc && 0 == cnt) {
		mdoc_argv_free(arg);
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
		    line, ppos, mdoc_macronames[tok]);
d1028 3
a1030 4

	if ( ! nl)
		return(1);
	return(append_delims(mdoc, line, pos, buf));
a1040 1
	enum mdoc_type	  mtt;
d1058 1
a1058 3
			if ( ! mdoc_elem_alloc(mdoc, line, ppos,
			    MDOC_br, NULL))
				return(0);
d1066 3
a1068 5
	if ( ! (MDOC_EXPLICIT & mdoc_macros[tok].flags)) {
		if ( ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
			return(0);
		if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
			return(0);
d1098 1
a1098 3
	if ( ! mdoc_block_alloc(mdoc, line, ppos, tok, arg))
		return(0);

d1105 3
a1107 3
	nparsed = MDOC_It == tok &&
	    MDOC_Bl == mdoc->last->parent->tok &&
	    LIST_diag == mdoc->last->parent->norm->Bl.type;
d1114 4
a1117 9
	if (MDOC_Nd == tok) {
		if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
			return(0);
		head = mdoc->last;
		if ( ! rew_sub(MDOC_HEAD, mdoc, tok, line, ppos))
			return(0);
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
			return(0);
		body = mdoc->last;
d1120 1
a1120 1
	if (MDOC_Bk == tok)
d1123 2
a1124 3
	ac = ARGS_ERROR;

	for ( ; ; ) {
d1126 1
a1126 2
		/* Initialise last-phrase-type with ARGS_PEND. */
		lac = ARGS_ERROR == ac ? ARGS_PEND : ac;
d1128 1
a1128 2

		if (ARGS_PUNCT == ac)
d1130 2
a1131 6

		if (ARGS_ERROR == ac)
			return(0);

		if (ARGS_EOLN == ac) {
			if (ARGS_PPHRASE != lac && ARGS_PHRASE != lac)
d1140 2
a1141 5
			if ( ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
				return(0);
			if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
				return(0);
			body = mdoc->last;
d1150 7
a1156 8
		if (NULL == head &&
		    ARGS_PEND != ac &&
		    ARGS_PHRASE != ac &&
		    ARGS_PPHRASE != ac &&
		    ARGS_QWORD != ac &&
		    DELIM_OPEN == mdoc_isdelim(p)) {
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN, 0))
				return(0);
d1162 2
a1163 5
		if (NULL == head) {
			if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
				return(0);
			head = mdoc->last;
		}
d1165 3
a1167 3
		if (ARGS_PHRASE == ac ||
		    ARGS_PEND == ac ||
		    ARGS_PPHRASE == ac) {
d1173 2
a1174 3
			mtt = body ? MDOC_BODY : MDOC_HEAD;
			if ( ! rew_sub(mtt, mdoc, tok, line, ppos))
				return(0);
d1178 1
a1178 3
			if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
				return(0);
			body = mdoc->last;
d1186 1
a1186 1
			if (ARGS_PPHRASE == ac)
d1188 1
a1188 1
			if (ARGS_PEND == ac && ARGS_PPHRASE == lac)
d1198 1
a1198 1
		ntok = nparsed || ARGS_QWORD == ac ?
d1201 3
a1203 4
		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags))
				return(0);
d1212 4
a1215 8
	if (NULL == head) {
		if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
			return(0);
		head = mdoc->last;
	}

	if (nl && ! append_delims(mdoc, line, pos, buf))
		return(0);
d1239 2
a1240 4
	if ( ! rew_sub(MDOC_HEAD, mdoc, tok, line, ppos))
		return(0);
	if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
		return(0);
d1243 5
a1247 9
	if ( ! (MDOC_FREECOL & mdoc->flags))
		return(1);

	if ( ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
		return(0);
	if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
		return(0);

	mdoc->flags &= ~MDOC_FREECOL;
d1273 3
a1275 9
	if ( ! mdoc_block_alloc(mdoc, line, ppos, tok, NULL))
		return(0);

	blk = mdoc->last;

	if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
		return(0);
	if ( ! rew_sub(MDOC_HEAD, mdoc, tok, line, ppos))
		return(0);
d1286 1
a1286 6

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_EOLN == ac)
			break;
		if (ARGS_PUNCT == ac)
d1289 3
a1291 4
		if (NULL == body && ARGS_QWORD != ac &&
		    DELIM_OPEN == mdoc_isdelim(p)) {
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN, 0))
				return(0);
d1295 2
a1296 5
		if (NULL == body) {
		       if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
			       return(0);
			body = mdoc->last;
		}
d1298 1
a1298 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);
d1300 3
a1302 4
		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags))
				return(0);
d1313 2
a1314 5
	if (NULL == body) {
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
			return(0);
		body = mdoc->last;
	}
d1323 3
a1325 3
		if (MDOC_BLOCK == n->type &&
		    MDOC_EXPLICIT & mdoc_macros[n->tok].flags &&
		    ! (MDOC_VALID & n->flags)) {
d1327 2
a1328 3
			if ( ! mdoc_endbody_alloc(mdoc, line, ppos,
			    tok, body, ENDBODY_NOSPACE))
				return(0);
d1333 1
a1333 3

	if ( ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
		return(0);
d1337 2
a1338 2
	if (nl && ! append_delims(mdoc, line, pos, buf))
		return(0);
d1342 1
a1342 2
	if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
		return(0);
d1348 1
a1348 1
	if (n && MDOC_Ns == n->tok)
d1372 1
a1372 3
	if ( ! mdoc_block_alloc(mdoc, line, ppos, tok, NULL))
		return(0);

d1376 1
a1376 6

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_PUNCT == ac)
			break;
		if (ARGS_EOLN == ac)
d1381 2
a1382 2
		if (NULL == head && ARGS_QWORD != ac &&
		    DELIM_OPEN == mdoc_isdelim(p)) {
d1384 1
a1384 2
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN, 0))
				return(0);
d1388 3
a1390 5
		if (NULL == head) {
			assert(NULL == body);
			if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
				return(0);
			head = mdoc->last;
d1398 1
a1398 1
		if (NULL == body) {
d1401 5
a1405 11
			if (MDOC_Eo == tok)
				if ( ! dword(mdoc, line, la, p, DELIM_MAX, 0))
					return(0);

			if ( ! rew_sub(MDOC_HEAD, mdoc, tok, line, ppos))
				return(0);
			if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
				return(0);
			body = mdoc->last;

			if (MDOC_Eo == tok)
d1408 1
d1410 4
a1413 8
		assert(NULL != head && NULL != body);

		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);

		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags))
				return(0);
a1415 1

d1423 2
a1424 3
	if (NULL == head)
		if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
			return(0);
d1426 3
a1428 5
	if (NULL == body) {
		if ( ! rew_sub(MDOC_HEAD, mdoc, tok, line, ppos))
			return(0);
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
			return(0);
d1433 3
a1435 3
	if ( ! nl)
		return(1);
	return(append_delims(mdoc, line, pos, buf));
d1499 1
a1499 6

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_PUNCT == ac)
			break;
		if (ARGS_EOLN == ac)
d1502 4
a1505 5
		if ( ! (MDOC_IGNDELIM & mdoc_macros[tok].flags) &&
		    ARGS_QWORD != ac && 0 == j &&
		    DELIM_OPEN == mdoc_isdelim(p)) {
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN, 0))
				return(0);
d1507 2
a1508 3
		} else if (0 == j)
		       if ( ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
			       return(0);
d1515 1
a1515 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);
d1517 1
a1517 1
		if (MDOC_MAX != ntok) {
d1527 3
a1529 4
		if ( ! (MDOC_IGNDELIM & mdoc_macros[tok].flags) &&
		    ARGS_QWORD != ac &&
		    ! flushed &&
		    DELIM_NONE != mdoc_isdelim(p)) {
d1534 2
a1535 3
		if ( ! dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags))
			return(0);
d1539 2
a1540 2
	if (0 == j && ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
	       return(0);
d1546 3
a1548 3
	if ( ! nl)
		return(1);
	return(append_delims(mdoc, line, pos, buf));
d1587 1
a1587 2
	if ( ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
		return(0);
d1594 1
a1594 4

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_EOLN == ac)
d1597 1
a1597 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);
d1599 3
a1601 4
		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags))
				return(0);
d1657 1
a1657 4

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_EOLN == ac)
d1660 1
a1660 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup_raw(p);
d1662 2
a1663 3
		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, la, p, DELIM_MAX, 1))
				return(0);
d1669 2
a1670 1
		return(append_delims(mdoc, line, &pos, buf));
d1696 3
a1698 4
	if ( ! rew_sub(MDOC_BODY, mdoc, MDOC_It, line, ppos))
		return(0);
	if ( ! mdoc_body_alloc(mdoc, line, ppos, MDOC_It))
		return(0);
d1703 1
a1703 4

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_EOLN == ac)
d1706 1
a1706 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup_raw(p);
d1708 3
a1710 4
		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags))
				return(0);
d1716 2
a1717 1
		return(append_delims(mdoc, line, pos, buf));
@


1.104
log
@Multiple fixes with respect to .Eo:
1. Correctly parse stray .Ec without preceding .Eo,
avoiding an assertion violation found by jsg@@ with afl.
2. Correctly parse .Ec arguments when breaking another block.
3. Correct spacing around closing delimiter when breaking another block.
4. Sync some related formatting control from -Tascii to -Thtml.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.103 2014/11/26 19:22:44 schwarze Exp $ */
d63 2
a64 3
static	int		rew_elem(struct mdoc *, enum mdoct);
static	int		rew_last(struct mdoc *,
				const struct mdoc_node *);
d238 2
a239 1
	return(rew_last(mdoc, mdoc->first));
d269 1
a269 1
static int
a275 2


d284 1
a284 2
		if ( ! mdoc_valid_post(mdoc))
			return(0);
d290 1
a290 2

	return(mdoc_valid_post(mdoc));
d452 1
a452 1
static int
d462 1
a462 2

	return(rew_last(mdoc, n));
d583 1
a583 2
	if ( ! rew_last(mdoc, n))
		return(0);
d590 1
a590 2
		if ( ! rew_last(mdoc, n))
			return(0);
d795 1
a795 2
			if ( ! rew_elem(mdoc, MDOC_br))
				return(0);
d805 3
a807 2
			if ( ! (endbody != NULL ? rew_last(mdoc, endbody) :
			    rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos)))
d831 3
a833 2
			if ( ! (endbody != NULL ? rew_last(mdoc, endbody) :
			    rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos)))
d845 6
a850 3
	if ( ! flushed && ! (endbody != NULL ? rew_last(mdoc, endbody) :
	    rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos)))
		return(0);
d957 2
a958 2
			if (scope && ! rew_elem(mdoc, tok))
				return(0);
d963 1
a963 2
				if ( ! rew_last(mdoc, mdoc->last))
					return(0);
d1008 2
a1009 2
			if (scope && ! rew_elem(mdoc, tok))
				return(0);
d1039 1
a1039 2
			if ( ! rew_elem(mdoc, tok))
				return(0);
d1044 2
a1045 2
	if (scope && ! rew_elem(mdoc, tok))
		return(0);
d1056 1
a1056 2
		if ( ! rew_last(mdoc, mdoc->last))
			return(0);
d1097 2
a1098 1
			return(rew_elem(mdoc, MDOC_br));
d1639 1
a1639 2
			if ( ! rew_elem(mdoc, tok))
				return(0);
d1646 2
a1647 2
			if ( ! flushed && ! rew_elem(mdoc, tok))
				return(0);
d1659 1
a1659 2
			if ( ! rew_elem(mdoc, tok))
				return(0);
d1674 2
a1675 2
	if ( ! flushed && ! rew_elem(mdoc, tok))
		return(0);
d1739 1
a1739 3

		if ( ! rew_elem(mdoc, tok))
			return(0);
d1745 2
a1746 1
	return(rew_elem(mdoc, tok));
@


1.103
log
@The .Sm macro accepts at most one argument;
fixing an assertion failure found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.102 2014/11/25 03:04:32 schwarze Exp $ */
d694 1
d721 1
a721 1
	body = later = NULL;
d760 4
d793 12
a804 2
	if (NULL == later && maxargs > 0)
		if ( ! mdoc_tail_alloc(mdoc, line, ppos, rew_alt(tok)))
d806 1
d808 2
a809 1
	for (flushed = j = 0; ; j++) {
d813 2
a814 1
			if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
d838 2
a839 1
			if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
d851 2
a852 1
	if ( ! flushed && ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
@


1.102
log
@Do not access a NULL pointer when a section has no body,
which can for example happen for .Sh Xo .Sh without .Xc.
Crash found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.101 2014/11/20 00:30:34 schwarze Exp $ */
d172 1
a172 1
	{ in_line_eoln, 0 }, /* Sm */
@


1.101
log
@Fix two minibugs reported by Thomas Klausner <wiz at NetBSD>:
1. The first argument of .Fn is not supposed to be parsed.
2. The .Fn macro is not supposed to reopen its scope after punctuation.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.100 2014/11/17 06:44:35 schwarze Exp $ */
d438 2
d442 1
a442 1
	    (MDOC_BLOCK == p->type &&
@


1.100
log
@Multiple fixes with respect to in-line macros:
* .No selects the default font; relevant e.g. in .Bf blocks
* no need to force empty .Li elements
* closing delimiters as leading macro arguments do not suppress space
* opening delimiters at the end of a macro line do not suppress space
* correctly handle delimiter spacing in -Tman
As a side effect, these fixes let mandoc warn about empty .No macros
as requested by bentley@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mdoc_macro.c,v 1.99 2014/09/07 00:04:47 schwarze Exp $ */
d927 2
a928 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);
d993 2
@


1.99
log
@Allow .ll in the prologue; Daniel Levai reports Slackware Linux uses this.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d18 2
d148 1
a148 2
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_IGNDELIM | MDOC_JOIN }, /* No */
a626 3
	if (DELIM_OPEN == d)
		mdoc->last->flags |= MDOC_DELIMO;

d628 4
a631 7
	 * Closing delimiters only suppress the preceding space
	 * when they follow something, not when they start a new
	 * block or element, and not when they follow `No'.
	 *
	 * XXX	Explicitly special-casing MDOC_No here feels
	 *	like a layering violation.  Find a better way
	 *	and solve this in the code related to `No'!
d634 4
a637 2
	else if (DELIM_CLOSE == d && mdoc->last->prev &&
	    mdoc->last->prev->tok != MDOC_No &&
d641 2
d841 1
a841 1
	int		 la, scope, cnt, mayopen, nc, nl;
d892 2
d899 1
a899 1
		if (ARGS_ERROR == ac)
d901 9
a909 1
		if (ARGS_EOLN == ac)
d911 13
a923 1
		if (ARGS_PUNCT == ac)
d925 1
d970 1
a970 1
			 * has been omitted, no scope is open, and we're
d976 1
a976 2
			    (nc || tok == MDOC_Li) &&
			    !scope && !cnt && mayopen) {
d982 1
a982 1
				if (MDOC_Li == tok || MDOC_Nm == tok)
d1004 9
a1560 2
		/* FALLTHROUGH */
	case MDOC_No:
@


1.98
log
@Right after .Fl, a middle delimiter triggers an empty scope,
just like a closing delimiter.  This didn't work in groff-1.15,
but it now works in groff-1.22.

After being closed by delimiters, .Nm scopes do not reopen.

Do not suppress white space after .Fl if the next node is a text node
on the same input line; that can happen for middle delimiters.

Fixing an issue reported by jmc@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.97 2014/08/16 19:47:17 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d209 1
a209 1
	{ in_line_eoln, 0 }, /* ll */
@


1.97
log
@If a stray .It follows .El, we are no longer in the list,
even though the list is still the last processed macro.
This fixes a regression introduced in mdoc_macro.c rev. 1.95:
Ulrich Spoerlein <uqs at FreeBSD> reports that various of their
kernel manuals trigger assertions.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.96 2014/08/08 15:54:10 schwarze Exp $ */
d842 1
a842 1
	int		 la, scope, cnt, nc, nl;
d893 1
d950 1
a950 3
			 * a new scope.  `Ar', `Fl', and `Li', only do
			 * this once per invocation.  There may be more
			 * of these (all of them?).
d952 4
a955 2
			if (0 == cnt && (nc || MDOC_Li == tok) &&
			    DELIM_CLOSE == d && ! scope) {
a958 3
				if (MDOC_Ar == tok || MDOC_Li == tok ||
				    MDOC_Fl == tok)
					cnt++;
d960 3
d971 1
a971 1
		} else if ( ! scope) {
d975 1
a976 3

		if (DELIM_NONE == d)
			cnt++;
@


1.96
log
@mention requests and macros in more messages
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.95 2014/08/08 15:26:28 schwarze Exp $ */
d1040 2
a1041 1
			if (n->tok == MDOC_Bl)
@


1.95
log
@Get rid of the useless FATAL error "child violates parent syntax".
When finding items outside lists, simply skip them and throw an ERROR.
Handle subsections before the first section instead of bailing out.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.94 2014/07/07 21:35:42 schwarze Exp $ */
d1784 1
a1784 1
		    line, ppos, NULL);
@


1.94
log
@Clean up ERROR messages related to document structure and macros:
Hierarchical naming and mention macro names in messages.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.93 2014/07/04 16:11:41 schwarze Exp $ */
d423 2
d1035 16
@


1.93
log
@Clean up messages regarding excess arguments:
* Downgrade ".Bf -emphasis Em" from FATAL to WARNING.
* Mention the macros, the arguments, and the fallbacks.
* Hierarchical naming.
Also fix the handling of excess .It head arguments in -Tman.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.92 2014/07/02 20:18:42 schwarze Exp $ */
d233 2
a234 1
			mdoc_nmsg(mdoc, n, MANDOCERR_SCOPEEXIT);
d528 1
a528 1
		mandoc_vmsg(MANDOCERR_BLOCK_NEST, mdoc->parse, line, ppos,
d558 1
a558 1
			mandoc_vmsg(MANDOCERR_SCOPEBROKEN, mdoc->parse,
d574 3
a576 1
			mdoc_pmsg(mdoc, line, ppos, MANDOCERR_NOSCOPE);
d1765 2
a1766 1
		mdoc_pmsg(mdoc, line, ppos, MANDOCERR_STRAYTA);
@


1.92
log
@Improve and test the messages about empty macros,
in particular reporting the macro names involved.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.91 2014/07/02 11:42:56 schwarze Exp $ */
d768 6
a773 5
	if ( ! (MDOC_CALLABLE & mdoc_macros[tok].flags)) {
		/* FIXME: do this in validate */
		if (buf[*pos])
			mdoc_pmsg(mdoc, line, ppos, MANDOCERR_ARGSLOST);

@


1.91
log
@Clean up warnings related to macros and nesting.
* Hierarchical naming of enum mandocerr items.
* Improve the wording to make it comprehensible.
* Mention the offending macro.
* Garbage collect one chunk of ancient, long unreachable code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.90 2014/07/02 08:21:12 schwarze Exp $ */
d918 3
a920 2
				mdoc_pmsg(mdoc, line, ppos,
				    MANDOCERR_MACROEMPTY);
d1005 2
a1006 1
		mdoc_pmsg(mdoc, line, ppos, MANDOCERR_MACROEMPTY);
@


1.90
log
@Fix the column numbers associated with in_line_argn() macros;
this bug is more than four years old, introduced by kristaps@@
in mdocml.bsd.lv rev. 1.46, March 30, 2010.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.89 2014/07/02 03:47:07 schwarze Exp $ */
d527 1
a527 1
		mandoc_vmsg(MANDOCERR_SCOPENEST, mdoc->parse, line, ppos,
d1353 1
d1355 1
a1355 11
	/*
	 * If we can't rewind to our body, then our scope has already
	 * been closed by another macro (like `Oc' closing `Op').  This
	 * is ugly behaviour nodding its head to OpenBSD's overwhelming
	 * crufty use of `Op' breakage.
	 */
	if (n != body)
		mandoc_vmsg(MANDOCERR_SCOPENEST, mdoc->parse, line,
		    ppos, "%s broken", mdoc_macronames[tok]);

	if (n && ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
d1365 1
a1365 1
	if (n && ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
@


1.89
log
@Implement the obsolete macros .En .Es .Fr .Ot for backward compatibility,
since this is hardly more complicated than explicitly ignoring them
as we did in the past.  Of course, do not use them!
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.88 2014/04/20 16:44:44 schwarze Exp $ */
d1572 1
a1572 1
		       if ( ! mdoc_elem_alloc(mdoc, line, la, tok, arg))
d1608 1
a1608 1
	if (0 == j && ! mdoc_elem_alloc(mdoc, line, la, tok, arg))
@


1.88
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.87 2014/03/30 19:47:32 schwarze Exp $ */
a46 1
static	int		obsolete(MACRO_PROT_ARGS);
d102 1
a102 1
	{ obsolete, 0 }, /* Ot */
d189 1
a189 1
	{ obsolete, 0 }, /* Fr */
d201 2
a202 2
	{ obsolete, 0 }, /* Es */
	{ obsolete, 0 }, /* En */
d1526 2
a1712 8
}

static int
obsolete(MACRO_PROT_ARGS)
{

	mdoc_pmsg(mdoc, line, ppos, MANDOCERR_MACROOBS);
	return(1);
@


1.87
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.86 2014/01/21 10:26:49 schwarze Exp $ */
d39 10
a48 10
static	int	  	blk_full(MACRO_PROT_ARGS);
static	int	  	blk_exp_close(MACRO_PROT_ARGS);
static	int	  	blk_part_exp(MACRO_PROT_ARGS);
static	int	  	blk_part_imp(MACRO_PROT_ARGS);
static	int	  	ctx_synopsis(MACRO_PROT_ARGS);
static	int	  	in_line_eoln(MACRO_PROT_ARGS);
static	int	  	in_line_argn(MACRO_PROT_ARGS);
static	int	  	in_line(MACRO_PROT_ARGS);
static	int	  	obsolete(MACRO_PROT_ARGS);
static	int	  	phrase_ta(MACRO_PROT_ARGS);
d52 1
a52 1
static	int	  	append_delims(struct mdoc *, 
d58 3
a60 3
static	int	  	phrase(struct mdoc *, int, int, char *);
static	enum mdoct 	rew_alt(enum mdoct);
static	enum rew  	rew_dohalt(enum mdoct, enum mdoc_type, 
d62 2
a63 2
static	int	  	rew_elem(struct mdoc *, enum mdoct);
static	int	  	rew_last(struct mdoc *, 
d65 1
a65 1
static	int	  	rew_sub(enum mdoc_type, struct mdoc *, 
d229 1
a229 1
			mdoc->last->parent : mdoc->last;
a240 1

a252 1

a267 1

d276 1
a276 1
	/* LINTED */
a295 1

d304 1
a304 1
	case (MDOC_Ac):
d306 1
a306 1
	case (MDOC_Bc):
d308 1
a308 1
	case (MDOC_Brc):
d310 1
a310 1
	case (MDOC_Dc):
d312 1
a312 1
	case (MDOC_Ec):
d314 1
a314 1
	case (MDOC_Ed):
d316 1
a316 1
	case (MDOC_Ef):
d318 1
a318 1
	case (MDOC_Ek):
d320 1
a320 1
	case (MDOC_El):
d322 1
a322 1
	case (MDOC_Fc):
d324 1
a324 1
	case (MDOC_Oc):
d326 1
a326 1
	case (MDOC_Pc):
d328 1
a328 1
	case (MDOC_Qc):
d330 1
a330 1
	case (MDOC_Re):
d332 1
a332 1
	case (MDOC_Sc):
d334 1
a334 1
	case (MDOC_Xc):
a341 1

d353 1
a353 1
rew_dohalt(enum mdoct tok, enum mdoc_type type, 
d369 1
a369 1
	 * When starting to rewind, skip plain text 
d393 1
a393 1
	 * Blocks delimiting our target token get REWIND_NONE. 
d396 1
a396 1
	case (MDOC_Bl):
d400 1
a400 1
	case (MDOC_It):
d410 1
a410 1
	case (MDOC_Oo):
d414 1
a414 1
	case (MDOC_Nm):
d416 1
a416 1
	case (MDOC_Nd):
d418 1
a418 1
	case (MDOC_Ss):
d422 1
a422 1
	case (MDOC_Sh):
a450 1

a464 1

d529 2
a530 2
				"%s breaks %s", mdoc_macronames[tok],
				mdoc_macronames[broken->tok]);
a540 1

d542 1
a542 1
rew_sub(enum mdoc_type t, struct mdoc *mdoc, 
d550 1
a550 1
		case (REWIND_NONE):
d552 1
a552 1
		case (REWIND_THIS):
d557 5
a561 5
		case (REWIND_FORCE):
			mandoc_vmsg(MANDOCERR_SCOPEBROKEN, mdoc->parse, 
					line, ppos, "%s breaks %s", 
					mdoc_macronames[tok],
					mdoc_macronames[n->tok]);
d563 1
a563 1
		case (REWIND_MORE):
d568 1
a568 1
		case (REWIND_LATER):
d573 1
a573 1
		case (REWIND_ERROR):
d607 1
a607 1
	
d636 2
a637 2
			mdoc->last->prev->tok != MDOC_No &&
			mdoc->last->parent->tok != MDOC_Fd)
a681 1

d683 1
a683 1
 * Close out block partial/full explicit.  
d692 1
a692 1
	int	 	 j, lastarg, maxargs, flushed, nl;
d700 1
a700 1
	case (MDOC_Ec):
d703 1
a703 1
	case (MDOC_Ek):
d740 1
a740 1
			/* 
d771 1
a771 1
		if (buf[*pos]) 
d782 1
a782 1
	if (NULL == later && maxargs > 0) 
a833 1

d853 1
a853 1
	case (MDOC_An):
d855 1
a855 1
	case (MDOC_Ar):
d857 1
a857 1
	case (MDOC_Fl):
d859 1
a859 1
	case (MDOC_Mt):
d861 1
a861 1
	case (MDOC_Nm):
d863 1
a863 1
	case (MDOC_Pa):
d878 1
a878 1
		} 
d901 1
a901 1
		/* 
d912 2
a913 2
				if ( ! mdoc_elem_alloc(mdoc, line,
						ppos, tok, arg))
d920 1
a920 1
					MANDOCERR_MACROEMPTY);
d928 1
a928 1
		} 
d930 1
a930 1
		/* 
d933 1
a933 1
		 * the word. 
d947 4
a950 4
			if (0 == cnt && (nc || MDOC_Li == tok) && 
					DELIM_CLOSE == d && ! scope) {
				if ( ! mdoc_elem_alloc(mdoc, line,
						ppos, tok, arg))
d952 2
a953 2
				if (MDOC_Ar == tok || MDOC_Li == tok || 
						MDOC_Fl == tok)
a1012 1

d1054 1
a1054 1
		} 
d1075 2
a1076 2
		MDOC_Bl == mdoc->last->parent->tok &&
		LIST_diag == mdoc->last->parent->norm->Bl.type;
d1129 1
a1129 1
		/* 
d1134 6
a1139 6
		if (NULL == head && 
				ARGS_PEND != ac &&
				ARGS_PHRASE != ac &&
				ARGS_PPHRASE != ac &&
				ARGS_QWORD != ac &&
				DELIM_OPEN == mdoc_isdelim(p)) {
d1153 3
a1155 3
		if (ARGS_PHRASE == ac || 
				ARGS_PEND == ac ||
				ARGS_PPHRASE == ac) {
d1164 1
a1164 1
			
d1189 2
a1190 2
		ntok = nparsed || ARGS_QWORD == ac ? 
			MDOC_MAX : lookup(tok, p);
d1209 1
a1209 1
	
d1225 3
a1227 3
		if (MDOC_BLOCK == n->type && 
				MDOC_EXPLICIT & mdoc_macros[n->tok].flags &&
				! (MDOC_VALID & n->flags)) {
a1252 1

d1303 1
a1303 1
				DELIM_OPEN == mdoc_isdelim(p)) {
d1343 1
a1343 1
			n = n->parent) {
d1355 1
a1355 1
	/* 
d1362 2
a1363 2
		mandoc_vmsg(MANDOCERR_SCOPENEST, mdoc->parse, line, ppos, 
				"%s broken", mdoc_macronames[tok]);
a1387 1

d1407 1
a1407 1
		return(0); 
d1423 1
a1423 1
				DELIM_OPEN == mdoc_isdelim(p)) {
a1494 2

/* ARGSUSED */
d1516 1
a1516 1
	case (MDOC_Ap):
d1518 1
a1518 1
	case (MDOC_No):
d1520 1
a1520 1
	case (MDOC_Ns):
d1522 1
a1522 1
	case (MDOC_Ux):
d1525 1
a1525 1
	case (MDOC_Bx):
d1527 1
a1527 1
	case (MDOC_Xr):
d1542 1
a1542 1
		} 
d1564 3
a1566 3
		if ( ! (MDOC_IGNDELIM & mdoc_macros[tok].flags) && 
				ARGS_QWORD != ac && 0 == j && 
				DELIM_OPEN == mdoc_isdelim(p)) {
d1593 3
a1595 3
				ARGS_QWORD != ac &&
				! flushed &&
				DELIM_NONE != mdoc_isdelim(p)) {
a1618 1

d1644 1
a1644 1
		if (ARGV_EOLN == av) 
a1687 2

/* ARGSUSED */
a1713 2

/* ARGSUSED */
a1721 1

a1760 2

/* ARGSUSED */
@


1.86
log
@Treat the line after .Cd as a single argument.
This doesn't hurt normal manual display
and makes the mandocdb(8) database more useful.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.85 2014/01/20 11:27:53 schwarze Exp $ */
d210 1
@


1.85
log
@Keep words after .Ic together in a single argument.
This doesn't hurt normal manual display
and makes the mandocdb(8) database more useful.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.84 2013/12/30 00:52:18 schwarze Exp $ */
d86 1
a86 1
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Cd */
@


1.84
log
@Simplify: Remove an unused argument from the mandoc_eos() function.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.83 2013/12/30 00:20:18 schwarze Exp $ */
d97 1
a97 1
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ic */
@


1.83
log
@Do not trigger end-of-sentence spacing by trailing punctuation
at the end of partial implicit macros.  Prodded by jmc@@.

Actually, this is a revert of rev. 1.39 Sat May 15 09:20:01 2010 UTC,
which in turn is mdocml.bsd.lv rev. 1.64 Fri May 14 14:09:13 2010 UTC
by kristaps@@, with this original commit message:
"Block-implicit macros now up-propogate end-of-sentence spacing.
NOTE: GROFF IS NOT SMART ENOUGH TO DO THIS."
Please speak after me: Then why the hell should we?

We already weakened this in rev. 1.55 Fri Jul 16 00:34:33 2010 UTC,
but that weakening was insufficient.  Let's take it out completely.

Admittedly, there are two places in base where what Kristaps did
made the output nicer, in calloc(3) and in fish(6).  But both are
atypical.  There are 18 other places where this revert makes the
output nicer, the typical case being:
"Mail status is shown as ``No Mail.''  if there is no mail."
You do *not* want the EOS spacing after ``No Mail.'' in that sentence.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.82 2013/12/24 20:45:21 schwarze Exp $ */
d682 1
a682 1
		if (mandoc_eos(p, strlen(p), 0))
@


1.82
log
@It turns out SYNOPSIS mode does not imply .Bk in general,
but only within .Nm blocks.  Simplify the code accordingly.
This reduces groff-mandoc differences in base by about 2%.

Triggered by research done by Franco Fichtner.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.81 2013/12/24 19:10:34 schwarze Exp $ */
a1345 19
	}

	for (n = body->child; n && n->next; n = n->next)
		/* Do nothing. */ ;
	
	/* 
	 * End of sentence spacing: if the last node is a text node and
	 * has a trailing period, then mark it as being end-of-sentence.
	 */

	if (n && MDOC_TEXT == n->type && n->string)
		if (mandoc_eos(n->string, strlen(n->string), 1))
			n->flags |= MDOC_EOS;

	/* Up-propagate the end-of-space flag. */

	if (n && (MDOC_EOS & n->flags)) {
		body->flags |= MDOC_EOS;
		body->parent->flags |= MDOC_EOS;
@


1.81
log
@When deciding whether two consecutive macros are on the same input line,
we have to compare the line where the first one *ends* (not where it begins)
to the line where the second one starts.
This fixes the bug that .Bk allowed output line breaks right after block
macros spanning more than one input line, even when the next macro follows
on the same line.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.80 2013/10/21 23:32:32 schwarze Exp $ */
d712 1
a712 2
		if ( ! (MDOC_SYNOPSIS & mdoc->flags))
			mdoc->flags &= ~MDOC_KEEP;
@


1.80
log
@There are three kinds of input lines: text lines, macros taking
positional arguments (like Dt Fn Xr) and macros taking text as
arguments (like Nd Sh Em %T An).  In the past, even the latter put
each word of their arguments into its own MDOC_TEXT node; instead,
concatenate arguments unless delimiters, keeps or spacing mode
prevent that.  Regarding mandoc(1), this is internal refactoring,
no output change intended.

Once we will switch mandocdb(8) from DB to SQLite in the future,
this is going to be required to support search expressions crossing
word boundaries, and it will reduce both database sizes and build
times by a bit more than 5% each.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.79 2013/09/15 18:26:39 schwarze Exp $ */
d560 3
d571 2
@


1.79
log
@Block closing macros do not allocate a new node but finish an existing
one, so they miss the clearing of MDOC_NEWLINE in mdoc.c, node_alloc().
Consequently, MDOC_NEWLINE must be cleared before processing the next
macro on the same line.
This fixes horizontal spacing for input lines beginning like .Oc Ns ...

Issue found by Franco Fichtner <franco at lastsummer dot de>
while working on DragonFly mandoc integration.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.78 2012/11/19 22:28:35 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d50 2
a51 2
static	int		dword(struct mdoc *, int, int, 
				const char *, enum mdelim);
d69 1
a69 1
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Ap */
d73 5
a77 5
	{ blk_full, MDOC_PARSED }, /* Sh */
	{ blk_full, MDOC_PARSED }, /* Ss */ 
	{ in_line_eoln, 0 }, /* Pp */ 
	{ blk_part_imp, MDOC_PARSED }, /* D1 */
	{ blk_part_imp, MDOC_PARSED }, /* Dl */
d79 1
a79 1
	{ blk_exp_close, MDOC_EXPLICIT }, /* Ed */
d81 4
a84 4
	{ blk_exp_close, MDOC_EXPLICIT }, /* El */
	{ blk_full, MDOC_PARSED }, /* It */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ad */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* An */
d88 3
a90 3
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Dv */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Er */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ev */ 
d92 2
a93 2
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Fa */ 
	{ in_line_eoln, 0 }, /* Fd */ 
d95 3
a97 3
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Fn */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ft */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ic */ 
d99 3
a101 3
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Li */
	{ blk_full, 0 }, /* Nd */ 
	{ ctx_synopsis, MDOC_CALLABLE | MDOC_PARSED }, /* Nm */ 
d106 1
a106 1
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* St */ 
d108 1
a108 1
	{ ctx_synopsis, MDOC_CALLABLE | MDOC_PARSED }, /* Vt */ 
d110 5
a114 5
	{ in_line_eoln, 0 }, /* %A */
	{ in_line_eoln, 0 }, /* %B */
	{ in_line_eoln, 0 }, /* %D */
	{ in_line_eoln, 0 }, /* %I */
	{ in_line_eoln, 0 }, /* %J */
d116 1
a116 1
	{ in_line_eoln, 0 }, /* %O */
d118 2
a119 2
	{ in_line_eoln, 0 }, /* %R */
	{ in_line_eoln, 0 }, /* %T */
d121 5
a125 3
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Ac */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Ao */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Aq */
d127 6
a132 4
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Bc */
	{ blk_full, MDOC_EXPLICIT }, /* Bf */ 
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Bo */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Bq */
d136 8
a143 6
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Dc */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Do */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Dq */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Ec */
	{ blk_exp_close, MDOC_EXPLICIT }, /* Ef */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Em */ 
d147 4
a150 2
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED | MDOC_IGNDELIM }, /* No */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED | MDOC_IGNDELIM }, /* Ns */
d153 2
a154 1
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Pc */
d156 10
a165 7
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Po */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Pq */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Qc */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Ql */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Qo */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Qq */
	{ blk_exp_close, MDOC_EXPLICIT }, /* Re */
d167 5
a171 3
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Sc */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* So */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Sq */
d173 2
a174 2
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Sx */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Sy */
d176 1
a176 1
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Ux */
d179 7
a185 4
	{ blk_full, MDOC_EXPLICIT | MDOC_CALLABLE }, /* Fo */ 
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Fc */ 
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Oo */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Oc */
d187 1
a187 1
	{ blk_exp_close, MDOC_EXPLICIT }, /* Ek */
d193 9
a201 7
	{ in_line_eoln, 0 }, /* Lp */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Lk */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Mt */ 
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Brq */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Bro */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Brc */
	{ in_line_eoln, 0 }, /* %C */
d205 1
a205 1
	{ in_line_eoln, 0 }, /* %Q */
d209 1
a209 1
	{ phrase_ta, MDOC_CALLABLE | MDOC_PARSED }, /* Ta */
d606 2
a607 2
dword(struct mdoc *mdoc, int line, 
		int col, const char *p, enum mdelim d)
d613 8
d664 1
a664 1
		dword(mdoc, line, la, p, DELIM_MAX);
d706 3
d811 2
a812 1
			if ( ! dword(mdoc, line, lastarg, p, DELIM_MAX))
d978 2
a979 1
		if ( ! dword(mdoc, line, la, p, d))
d1098 4
a1101 1
	} 
d1146 1
a1146 1
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN))
d1199 2
a1200 1
			if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1311 1
a1311 1
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN))
d1314 1
a1314 1
		} 
d1325 2
a1326 1
			if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1452 1
a1452 1
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN))
d1455 1
a1455 1
		} 
d1473 1
a1473 1
				if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1491 2
a1492 1
			if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1596 1
a1596 1
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN))
d1630 2
a1631 1
		if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1702 2
a1703 1
			if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1783 1
a1783 1
			if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1834 2
a1835 1
			if ( ! dword(mdoc, line, la, p, DELIM_MAX))
@


1.78
log
@Do not crash on stray .Ta macros found outside column lists.
Problem reported by jmc@@, thanks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.77 2012/11/18 00:05:28 schwarze Exp $ */
d791 3
@


1.77
log
@Fix four small whitespace issues related to trailing punctuation
reported by Nicolas Joly <njoly at pasteur dot fr>:

- add EOS spacing after trailing punctuation after .Cd, .Fc, and .Lb
- suppress spacing before trailing punctuation after .Fd
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.76 2012/11/17 00:25:20 schwarze Exp $ */
d1758 1
d1764 8
a1771 4
	/*
	 * FIXME: this is overly restrictive: if the `Ta' is unexpected,
	 * it should simply error out with ARGSLOST.
	 */
d1773 1
@


1.76
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.75 2012/11/16 13:25:34 schwarze Exp $ */
d611 2
a612 1
			mdoc->last->prev->tok != MDOC_No)
@


1.75
log
@Fix a crash triggered by .Bl -tag .It Xo .El .Sh found by florian@@.

* When allocating a body end marker, copy the pointer to the normalized
block information from the body block, avoiding the risk of subsequent
null pointer derefence.
* When inserting the body end marker into the syntax tree, do not try to
copy that pointer from the parent block, because not being a direkt child
of the block it belongs to is the whole point of a body end marker.
* Even non-callable blocks (like Bd and Bl) can break other blocks;
when this happens, postpone closing them out in the usual way.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.74 2012/07/18 16:20:14 schwarze Exp $ */
d202 1
a202 1
mdoc_macroend(struct mdoc *m)
d208 2
a209 1
	n = MDOC_VALID & m->last->flags ?  m->last->parent : m->last;
d214 1
a214 1
			mdoc_nmsg(m, n, MANDOCERR_SCOPEEXIT);
d218 1
a218 1
	return(rew_last(m, m->first));
d263 2
a264 2
		 * m->last node in the post-validation phase and reset
		 * it to m->last->parent, causing a step in the closing
d460 1
a460 1
		struct mdoc *m, int line, int ppos)
d515 1
a515 1
		mandoc_vmsg(MANDOCERR_SCOPENEST, m->parse, line, ppos,
d530 1
a530 1
rew_sub(enum mdoc_type t, struct mdoc *m, 
d535 1
a535 1
	n = m->last;
d543 1
a543 1
			mandoc_vmsg(MANDOCERR_SCOPEBROKEN, m->parse, 
d552 1
a552 1
			if (make_pending(n, tok, m, line, ppos) ||
d557 1
a557 1
			mdoc_pmsg(m, line, ppos, MANDOCERR_NOSCOPE);
d564 1
a564 1
	if ( ! rew_last(m, n))
d572 1
a572 1
		if ( ! rew_last(m, n))
d575 1
a575 1
		    ! mdoc_body_alloc(m, n->line, n->pos, n->tok))
d587 1
a587 1
dword(struct mdoc *m, int line, 
d594 1
a594 1
	if ( ! mdoc_word_alloc(m, line, col, p))
d598 1
a598 1
		m->last->flags |= MDOC_DELIMO;
d610 3
a612 3
	else if (DELIM_CLOSE == d && m->last->prev &&
			m->last->prev->tok != MDOC_No)
		m->last->flags |= MDOC_DELIMC;
d618 1
a618 1
append_delims(struct mdoc *m, int line, int *pos, char *buf)
d629 1
a629 1
		ac = mdoc_zargs(m, line, pos, buf, &p);
d636 1
a636 1
		dword(m, line, la, p, DELIM_MAX);
d650 1
a650 1
			m->last->flags |= MDOC_EOS;
d672 1
a672 1
	nl = MDOC_NEWLINE & m->flags;
d689 1
a689 1
	for (n = m->last; n; n = n->parent) {
d718 1
a718 1
			make_pending(later, tok, m, line, ppos);
d724 1
a724 1
			if ( ! mdoc_endbody_alloc(m, line, ppos,
d745 1
a745 1
			mdoc_pmsg(m, line, ppos, MANDOCERR_ARGSLOST);
d747 1
a747 1
		if ( ! rew_sub(MDOC_BODY, m, tok, line, ppos))
d749 1
a749 1
		return(rew_sub(MDOC_BLOCK, m, tok, line, ppos));
d752 1
a752 1
	if ( ! rew_sub(MDOC_BODY, m, tok, line, ppos))
d756 1
a756 1
		if ( ! mdoc_tail_alloc(m, line, ppos, rew_alt(tok)))
d763 1
a763 1
			if ( ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
d768 1
a768 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d780 1
a780 1
			if ( ! dword(m, line, lastarg, p, DELIM_MAX))
d786 1
a786 1
			if ( ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
d790 1
a790 1
		if ( ! mdoc_macro(m, ntok, line, lastarg, pos, buf))
d795 1
a795 1
	if ( ! flushed && ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
d800 1
a800 1
	return(append_delims(m, line, pos, buf));
d815 1
a815 1
	nl = MDOC_NEWLINE & m->flags;
d843 1
a843 1
		av = mdoc_argv(m, line, tok, &arg, pos, buf);
d860 1
a860 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d879 1
a879 1
			if (scope && ! rew_elem(m, tok))
d882 2
a883 1
				if ( ! mdoc_elem_alloc(m, line, ppos, tok, arg))
d885 1
a885 1
				if ( ! rew_last(m, m->last))
d889 2
a890 1
				mdoc_pmsg(m, line, ppos, MANDOCERR_MACROEMPTY);
d893 1
a893 1
			if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d897 1
a897 1
			return(append_delims(m, line, pos, buf));
d919 2
a920 1
				if ( ! mdoc_elem_alloc(m, line, ppos, tok, arg))
d931 1
a931 1
			if (scope && ! rew_elem(m, tok))
d935 1
a935 1
			if ( ! mdoc_elem_alloc(m, line, ppos, tok, arg))
d943 1
a943 1
		if ( ! dword(m, line, la, p, d))
d952 1
a952 1
			if ( ! rew_elem(m, tok))
d958 1
a958 1
	if (scope && ! rew_elem(m, tok))
d968 1
a968 1
		if ( ! mdoc_elem_alloc(m, line, ppos, tok, arg))
d970 1
a970 1
		if ( ! rew_last(m, m->last))
d974 1
a974 1
		mdoc_pmsg(m, line, ppos, MANDOCERR_MACROEMPTY);
d979 1
a979 1
	return(append_delims(m, line, pos, buf));
d997 1
a997 1
	nl = MDOC_NEWLINE & m->flags;
d1002 1
a1002 1
		if ( ! rew_sub(MDOC_BODY, m, tok, line, ppos))
d1004 1
a1004 1
		if ( ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
d1019 1
a1019 1
		av = mdoc_argv(m, line, tok, &arg, pos, buf);
d1035 1
a1035 1
	if ( ! mdoc_block_alloc(m, line, ppos, tok, arg))
d1045 2
a1046 2
		MDOC_Bl == m->last->parent->tok &&
		LIST_diag == m->last->parent->norm->Bl.type;
d1054 1
a1054 1
		if ( ! mdoc_head_alloc(m, line, ppos, tok))
d1056 2
a1057 2
		head = m->last;
		if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
d1059 1
a1059 1
		if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1061 1
a1061 1
		body = m->last;
d1070 1
a1070 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d1088 1
a1088 1
			if ( ! rew_sub(MDOC_BODY, m, tok, line, ppos))
d1090 1
a1090 1
			if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1092 1
a1092 1
			body = m->last;
d1107 1
a1107 1
			if ( ! dword(m, line, la, p, DELIM_OPEN))
d1115 1
a1115 1
			if ( ! mdoc_head_alloc(m, line, ppos, tok))
d1117 1
a1117 1
			head = m->last;
d1129 1
a1129 1
			if ( ! rew_sub(mtt, m, tok, line, ppos))
d1134 1
a1134 1
			if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1136 1
a1136 1
			body = m->last;
d1145 1
a1145 1
				m->flags |= MDOC_PPHRASE;
d1147 1
a1147 1
				m->flags |= MDOC_PPHRASE;
d1149 1
a1149 1
			if ( ! phrase(m, line, la, buf))
d1152 1
a1152 1
			m->flags &= ~MDOC_PPHRASE;
d1160 1
a1160 1
			if ( ! dword(m, line, la, p, DELIM_MAX))
d1165 1
a1165 1
		if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1171 1
a1171 1
		if ( ! mdoc_head_alloc(m, line, ppos, tok))
d1173 1
a1173 1
		head = m->last;
d1176 1
a1176 1
	if (nl && ! append_delims(m, line, pos, buf))
d1190 1
a1190 1
	for (n = m->last; n && n != head; n = n->parent) {
d1201 1
a1201 1
	if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
d1203 1
a1203 1
	if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1207 1
a1207 1
	if ( ! (MDOC_FREECOL & m->flags))
d1210 1
a1210 1
	if ( ! rew_sub(MDOC_BODY, m, tok, line, ppos))
d1212 1
a1212 1
	if ( ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
d1215 1
a1215 1
	m->flags &= ~MDOC_FREECOL;
d1231 1
a1231 1
	nl = MDOC_NEWLINE & m->flags;
d1242 1
a1242 1
	if ( ! mdoc_block_alloc(m, line, ppos, tok, NULL))
d1245 1
a1245 1
	blk = m->last;
d1247 1
a1247 1
	if ( ! mdoc_head_alloc(m, line, ppos, tok))
d1249 1
a1249 1
	if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
d1260 1
a1260 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d1271 1
a1271 1
			if ( ! dword(m, line, la, p, DELIM_OPEN))
d1277 1
a1277 1
		       if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1279 1
a1279 1
			body = m->last;
d1285 1
a1285 1
			if ( ! dword(m, line, la, p, DELIM_MAX))
d1290 1
a1290 1
		if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1298 1
a1298 1
		if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1300 1
a1300 1
		body = m->last;
d1327 2
a1328 1
	for (n = m->last; n && n != body && n != blk->parent; n = n->parent) {
d1332 2
a1333 2
			make_pending(n, tok, m, line, ppos);
			if ( ! mdoc_endbody_alloc(m, line, ppos,
d1347 1
a1347 1
		mandoc_vmsg(MANDOCERR_SCOPENEST, m->parse, line, ppos, 
d1350 1
a1350 1
	if (n && ! rew_sub(MDOC_BODY, m, tok, line, ppos))
d1355 1
a1355 1
	if (nl && ! append_delims(m, line, pos, buf))
d1360 1
a1360 1
	if (n && ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
d1368 1
a1368 1
		mdoc_node_relink(m, n);
d1384 1
a1384 1
	nl = MDOC_NEWLINE & m->flags;
d1392 1
a1392 1
	if ( ! mdoc_block_alloc(m, line, ppos, tok, NULL))
d1397 1
a1397 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d1411 1
a1411 1
			if ( ! dword(m, line, la, p, DELIM_OPEN))
d1418 1
a1418 1
			if ( ! mdoc_head_alloc(m, line, ppos, tok))
d1420 1
a1420 1
			head = m->last;
d1432 1
a1432 1
				if ( ! dword(m, line, la, p, DELIM_MAX))
d1435 1
a1435 1
			if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
d1437 1
a1437 1
			if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1439 1
a1439 1
			body = m->last;
d1450 1
a1450 1
			if ( ! dword(m, line, la, p, DELIM_MAX))
d1455 1
a1455 1
		if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1463 1
a1463 1
		if ( ! mdoc_head_alloc(m, line, ppos, tok))
d1467 1
a1467 1
		if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
d1469 1
a1469 1
		if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1477 1
a1477 1
	return(append_delims(m, line, pos, buf));
d1492 1
a1492 1
	nl = MDOC_NEWLINE & m->flags;
d1524 1
a1524 1
		av = mdoc_argv(m, line, tok, &arg, pos, buf);
d1542 1
a1542 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d1554 1
a1554 1
			if ( ! dword(m, line, la, p, DELIM_OPEN))
d1558 1
a1558 1
		       if ( ! mdoc_elem_alloc(m, line, la, tok, arg))
d1562 1
a1562 1
			if ( ! rew_elem(m, tok))
d1570 1
a1570 1
			if ( ! flushed && ! rew_elem(m, tok))
d1573 1
a1573 1
			if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1583 1
a1583 1
			if ( ! rew_elem(m, tok))
d1588 1
a1588 1
		if ( ! dword(m, line, la, p, DELIM_MAX))
d1593 1
a1593 1
	if (0 == j && ! mdoc_elem_alloc(m, line, la, tok, arg))
d1598 1
a1598 1
	if ( ! flushed && ! rew_elem(m, tok))
d1602 1
a1602 1
	return(append_delims(m, line, pos, buf));
d1619 1
a1619 1
		rew_sub(MDOC_BLOCK, m, MDOC_Nm, line, ppos);
d1625 1
a1625 1
		av = mdoc_argv(m, line, tok, &arg, pos, buf);
d1642 1
a1642 1
	if ( ! mdoc_elem_alloc(m, line, ppos, tok, arg))
d1649 1
a1649 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d1659 1
a1659 1
			if ( ! dword(m, line, la, p, DELIM_MAX))
d1664 1
a1664 1
		if ( ! rew_elem(m, tok))
d1666 1
a1666 1
		return(mdoc_macro(m, ntok, line, la, pos, buf));
d1671 1
a1671 1
	return(rew_elem(m, tok));
d1681 1
a1681 1
	nl = MDOC_NEWLINE & m->flags;
d1684 2
a1685 2
	if ( ! (MDOC_SYNOPSIS & m->flags))
		return(in_line(m, tok, line, ppos, pos, buf));
d1689 1
a1689 1
		return(in_line(m, tok, line, ppos, pos, buf));
d1697 1
a1697 1
		return(blk_full(m, tok, line, ppos, pos, buf));
d1699 1
a1699 1
	return(blk_part_imp(m, tok, line, ppos, pos, buf));
d1708 1
a1708 1
	mdoc_pmsg(m, line, ppos, MANDOCERR_MACROOBS);
d1719 1
a1719 1
phrase(struct mdoc *m, int line, int ppos, char *buf)
d1729 1
a1729 1
		ac = mdoc_zargs(m, line, &pos, buf, &p);
d1739 1
a1739 1
			if ( ! dword(m, line, la, p, DELIM_MAX))
d1744 1
a1744 1
		if ( ! mdoc_macro(m, ntok, line, la, &pos, buf))
d1746 1
a1746 1
		return(append_delims(m, line, &pos, buf));
d1767 1
a1767 1
	if ( ! rew_sub(MDOC_BODY, m, MDOC_It, line, ppos))
d1769 1
a1769 1
	if ( ! mdoc_body_alloc(m, line, ppos, MDOC_It))
d1774 1
a1774 1
		ac = mdoc_zargs(m, line, pos, buf, &p);
d1784 1
a1784 1
			if ( ! dword(m, line, la, p, DELIM_MAX))
d1789 1
a1789 1
		if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1791 1
a1791 1
		return(append_delims(m, line, pos, buf));
@


1.74
log
@Let a trailing .Ns macro take effect
even on an input line containing a partial implicit macro.

Fixes horizontal spacing in vi(1), ddb(4), and ppp(8).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.73 2012/01/04 02:17:42 schwarze Exp $ */
d737 1
a737 1
		if (MDOC_CALLABLE & mdoc_macros[n->tok].flags)
@


1.73
log
@Heads of .It macros in -diag lists are not parsed,
even though .It macros in general are parsed.
Fixing a bug reported by deraadt@@,
based on an incomplete fix by kristaps@@,
and update the test suite to catch this issue.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.72 2011/12/03 23:01:21 schwarze Exp $ */
d3 2
a4 2
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d1357 7
@


1.72
log
@Remove an OpenBSD-specific tweak regarding .Xr spacing
and make it compatible with bsd.lv mandoc and with groff-1.21.
This tweak was originally added for compatibility with groff-1.15,
which is no longer needed.

ok jmc@@ kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.71 2011/12/03 22:47:27 schwarze Exp $ */
a226 1
	/* FIXME: make -diag lists be un-PARSED. */
d982 1
a982 1
	int		  la, nl;
d1037 8
d1152 2
a1153 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);
@


1.71
log
@remove useless "#ifdef __linux__" that crept in,
and trivial sync to bsd.lv (two new comments)
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.70 2011/10/16 12:18:32 schwarze Exp $ */
a1565 13
		}

		/* 
		 * XXX: this is a hack to work around groff's ugliness
		 * as regards `Xr' and extraneous arguments.  It should
		 * ideally be deprecated behaviour, but because this is
		 * code is no here, it's unlikely to be removed.
		 */
		if (MDOC_Xr == tok && j == maxargs) {
			if ( ! mdoc_elem_alloc(m, line, la, MDOC_Ns, NULL))
				return(0);
			if ( ! rew_elem(m, MDOC_Ns))
				return(0);
@


1.70
log
@Remove a bunch of useless assignments,
and assert that print_bvspace cannot be called on NULL pointers.
No change in behaviour, none of these were bugs,
but the code becomes easier to understand.
Based on a clang report posted by joerg@@; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.69 2011/09/18 15:54:48 schwarze Exp $ */
d599 11
@


1.69
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.68 2011/05/29 21:22:18 schwarze Exp $ */
d1431 1
a1431 1
	if (NULL == head) {
a1433 2
		head = m->last;
	}
a1439 1
		body = m->last;
@


1.68
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.67 2011/04/24 16:49:10 schwarze Exp $ */
d73 2
a74 2
	{ blk_full, 0 }, /* Sh */
	{ blk_full, 0 }, /* Ss */ 
@


1.67
log
@Closing delimiters only suppress spacing when they follow something.
Fixing a regression introduced in bsd.lv rev. 1.105.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.66 2011/04/24 16:22:02 schwarze Exp $ */
d618 1
a618 1
		ac = mdoc_zargs(m, line, pos, buf, ARGS_NOWARN, &p);
d631 1
a631 1
		 * XXX: it's easy to allow this to propogate outward to
d636 1
a636 1
		 * example, `.  ;' shouldn't propogate the double-space.
d995 1
a995 1
	 * This routine accomodates implicitly- and explicitly-scoped
d1292 1
a1292 1
	/* Up-propogate the end-of-space flag. */
d1714 1
a1714 1
		ac = mdoc_zargs(m, line, &pos, buf, 0, &p);
d1759 1
a1759 1
		ac = mdoc_zargs(m, line, pos, buf, 0, &p);
@


1.66
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.65 2011/04/21 22:59:54 schwarze Exp $ */
d599 2
a600 1
	else if (DELIM_CLOSE == d)
@


1.65
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.64 2011/01/30 18:28:01 schwarze Exp $ */
d25 1
d50 2
d515 3
a517 3
		mdoc_vmsg(m, MANDOCERR_SCOPENEST, line, ppos,
		    "%s breaks %s", mdoc_macronames[tok],
		    mdoc_macronames[broken->tok]);
d543 4
a546 3
			mdoc_vmsg(m, MANDOCERR_SCOPEBROKEN, line, ppos,
			    "%s breaks %s", mdoc_macronames[tok],
			    mdoc_macronames[n->tok]);
d582 22
d624 1
a624 3
		assert(DELIM_NONE != mandoc_isdelim(p));
		if ( ! mdoc_word_alloc(m, line, la, p))
			return(0);
d768 1
a768 1
			if ( ! mdoc_word_alloc(m, line, lastarg, p))
d892 1
a892 1
		d = ARGS_QWORD == ac ? DELIM_NONE : mandoc_isdelim(p);
d927 2
a928 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d1083 2
a1084 2
				DELIM_OPEN == mandoc_isdelim(p)) {
			if ( ! mdoc_word_alloc(m, line, la, p))
d1136 1
a1136 1
			if ( ! mdoc_word_alloc(m, line, la, p))
d1246 2
a1247 2
		    DELIM_OPEN == mandoc_isdelim(p)) {
			if ( ! mdoc_word_alloc(m, line, la, p))
d1261 1
a1261 1
			if ( ! mdoc_word_alloc(m, line, la, p))
d1322 1
a1322 1
		mdoc_vmsg(m, MANDOCERR_SCOPENEST, line, ppos, 
d1377 1
a1377 1
		    DELIM_OPEN == mandoc_isdelim(p)) {
d1379 1
a1379 1
			if ( ! mdoc_word_alloc(m, line, la, p))
d1400 1
a1400 1
				if ( ! mdoc_word_alloc(m, line, la, p))
d1418 1
a1418 1
			if ( ! mdoc_word_alloc(m, line, la, p))
d1523 3
a1525 3
				ARGS_QWORD != ac &&
				0 == j && DELIM_OPEN == mandoc_isdelim(p)) {
			if ( ! mdoc_word_alloc(m, line, la, p))
d1553 1
a1553 1
				DELIM_NONE != mandoc_isdelim(p)) {
d1572 1
a1572 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d1643 1
a1643 1
			if ( ! mdoc_word_alloc(m, line, la, p))
d1723 1
a1723 1
			if ( ! mdoc_word_alloc(m, line, la, p))
d1768 1
a1768 1
			if ( ! mdoc_word_alloc(m, line, la, p))
@


1.64
log
@Make .Bx accept not more than two arguments.
Convert the first character of the second argument to uppercase.
Append the second argument with a hyphen.
Improves chpass(1), column(1), fstat(1), ...
from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.63 2011/01/16 19:27:25 schwarze Exp $ */
d598 1
a598 1
		assert(DELIM_NONE != mdoc_isdelim(p));
d709 1
a709 2
			if ( ! mdoc_pmsg(m, line, ppos, MANDOCERR_ARGSLOST))
				return(0);
d852 1
a852 2
				if ( ! mdoc_pmsg(m, line, ppos, MANDOCERR_MACROEMPTY))
					return(0);
d854 1
d868 1
a868 1
		d = ARGS_QWORD == ac ? DELIM_NONE : mdoc_isdelim(p);
d934 1
a934 2
		if ( ! mdoc_pmsg(m, line, ppos, MANDOCERR_MACROEMPTY))
			return(0);
d1058 1
a1058 1
				DELIM_OPEN == mdoc_isdelim(p)) {
d1221 1
a1221 1
		    DELIM_OPEN == mdoc_isdelim(p)) {
d1296 3
a1298 3
	if (n != body && ! mdoc_vmsg(m, MANDOCERR_SCOPENEST,
	    line, ppos, "%s broken", mdoc_macronames[tok]))
		return(0);
d1352 1
a1352 1
		    DELIM_OPEN == mdoc_isdelim(p)) {
d1499 1
a1499 1
				0 == j && DELIM_OPEN == mdoc_isdelim(p)) {
d1528 1
a1528 1
				DELIM_NONE != mdoc_isdelim(p)) {
d1667 2
a1668 1
	return(mdoc_pmsg(m, line, ppos, MANDOCERR_MACROOBS));
@


1.63
log
@Some improvements to error handling from kristaps@@:
* Make out-of-context .fi invocations not cause an error, but just a warning.
* Downgrade -man message about ignored empty paragraph to MANDOC_IGNPAR.
* Avoid syntax tree corruption when removing empty block macros.
Triggered by some reports from brad@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.62 2011/01/04 22:28:17 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d1460 2
@


1.62
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.61 2010/12/21 23:46:18 schwarze Exp $ */
d251 1
a251 1
	struct mdoc_node *n;
d258 7
d268 1
a268 1
		mdoc->last = mdoc->last->parent;
@


1.61
log
@Vertical spacing improvements from kristaps@@, small tweaks by me:
Add a "last child" member to struct mdoc_node.
Remove .Pp or .Lp if it is the first or last child of an .Sh or .Ss body.
Thus, no need to do the same in the front-ends any longer.
Tolerate some cases of .Pp inside .Bl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.60 2010/12/01 22:02:29 schwarze Exp $ */
a187 2
	{ blk_part_exp, MDOC_EXPLICIT }, /* TS */
	{ blk_exp_close, MDOC_EXPLICIT }, /* TE */
a309 2
	case (MDOC_TE):
		return(MDOC_TS);
@


1.60
log
@Merge mdoc_action.c into mdoc_validate.c, because having two places to do
basically the same things just causes code duplication and confusion.
Work by kristaps@@, including a few bugfixes he found during the merge,
and reapplying OpenBSD changes on top.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.59 2010/10/24 18:15:43 schwarze Exp $ */
d253 1
d262 1
d265 1
@


1.59
log
@Do not throw FATAL errors when there is no need to:
 - when encountering nested displays (.Bd containing .Bd, .D1, .D1)
 - when a block end macro was forgotten
 - when ending a block that was never started
 - when the uname(3) system call failed
along with a little related cleanup
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.58 2010/10/16 13:38:29 schwarze Exp $ */
a260 2
		if ( ! mdoc_action_post(mdoc))
			return(0);
d265 1
a265 3
	if ( ! mdoc_valid_post(mdoc))
		return(0);
	return(mdoc_action_post(mdoc));
d696 1
a696 2
		if (MDOC_CALLABLE & mdoc_macros[n->tok].flags) {
			assert( ! (MDOC_ACTED & n->flags));
a697 1
		}
d788 1
a788 1
	case (MDOC_Lk):
a1140 1
			assert( ! (MDOC_ACTED & n->flags));
a1277 1
			assert( ! (MDOC_ACTED & n->flags));
@


1.58
log
@Support tbl(1) code embedded into mdoc(7) input files.
Very similar to what i have done in man(7) yesterday.
Allows to build cpu(4) on HPPA, wi(4), and phantasia(6).
Now we are able to build all tbl code in base.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.57 2010/10/01 21:38:26 schwarze Exp $ */
d33 1
d328 1
d422 4
a425 1
	 * Partial blocks allow delayed rewinding by default.
d427 2
a428 8
	if (&blk_full != mdoc_macros[tok].fp)
		return (REWIND_LATER);

	/*
	 * Full blocks can only be rewound when matching
	 * or when there is an explicit rule.
	 */
	return(REWIND_ERROR);
a518 1
	 * XXX Make this non-fatal.
a519 1
	mdoc_pmsg(m, line, ppos, MANDOCERR_SYNTNOSCOPE);
d537 5
d546 4
a549 1
			return(make_pending(n, tok, m, line, ppos));
d551 2
a552 5
			/* XXX Make this non-fatal. */
			mdoc_vmsg(m, MANDOCERR_SCOPEFATAL, line, ppos,
			    "%s cannot break %s", mdoc_macronames[tok],
			    mdoc_macronames[n->tok]);
			return 0;
d680 1
a680 2
			if ( ! make_pending(later, tok, m, line, ppos))
				return(0);
d1286 1
a1286 2
			if ( ! make_pending(n, tok, m, line, ppos))
				return(0);
@


1.57
log
@* need a space before .No even if it starts with a closing delimiter
* slightly simplify .Pf *_IGNDELIM code, and share part of it with .No
* do not let opening delimiters fall out of the front of .Ns (from kristaps@@)
This fixes a few spacing issues in csh(1) and ksh(1).
OK kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.56 2010/09/26 20:19:58 schwarze Exp $ */
d187 2
d312 2
@


1.56
log
@If an explicit scope is still open at the end of an input file,
report an ERROR:  We can still render the page by just closing
the open scope, but it is likely that information will be missing
or document structure mangled.
Before, man(7) only reported a WARNING (which is dangerous because
we cannot be sure rendering is correct) and mdoc(7) ran into FATAL
(which is too drastic, there is no reason not to show what we have).
While here, add a few explicit casts to appease lint.
"looks good" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.55 2010/07/16 00:34:33 schwarze Exp $ */
d137 2
a138 2
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* No */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Ns */
@


1.55
log
@Text ending in a full stop, exclamation mark or question mark
should not flag the end of a sentence if:

1) The punctuation is followed by closing delimiters
and not preceded by alphanumeric characters, like in
"There is no full stop (.) in this sentence"

or

2) The punctuation is a child of a macro
and not preceded by alphanumeric characters, like in
"There is no full stop
.Pq \&.
in this sentence"

jmc@@ and sobrado@@ like this
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.54 2010/07/13 01:09:13 schwarze Exp $ */
d206 4
a209 8
	for ( ; n; n = n->parent) {
		if (MDOC_BLOCK != n->type)
			continue;
		if ( ! (MDOC_EXPLICIT & mdoc_macros[n->tok].flags))
			continue;
		mdoc_nmsg(m, n, MANDOCERR_SYNTSCOPE);
		return(0);
	}
@


1.54
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.53 2010/07/01 22:31:52 schwarze Exp $ */
d609 1
a609 1
		if (mandoc_eos(p, strlen(p)))
d1265 1
a1265 1
		if (mandoc_eos(n->string, strlen(n->string)))
@


1.53
log
@In the mdoc(7) parser, inspect roff registers early such that all parts
of the parser can use the resulting cues.  In particular, this allows
to use .nr nS to force SYNOPSIS-style .Nm indentation outside the
SYNOPSIS as needed by ifconfig(8).

To actually make this useable, .Pp must rewind .Nm, or the rest of the
section would end up indented.  Implement a quick hack for now,
a generic solution can be designed later.

ok kristaps@@ sobrado@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.52 2010/07/01 21:08:50 schwarze Exp $ */
d3 2
a4 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d34 1
a34 1
	REWIND_ERROR,
d414 1
a414 1
	if (p->end || MDOC_Nm == p->tok ||
d570 1
d655 1
a655 1
			if ( ! n->end)
d1151 1
@


1.52
log
@Correct handling of trailing punctuation in MDOC_DELIM blk_full HEADs.
The bug was uncovered by SYNOPSIS .Nm as this happened to be the first
block with this particular combination of properties.
Found the hard way by kristaps@@ in NetBSD gcc-contrib(1),
fix by me.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.51 2010/07/01 15:36:59 schwarze Exp $ */
d1576 3
d1642 1
a1642 1
	if (SEC_SYNOPSIS != m->lastsec)
@


1.51
log
@Improve .Nm indentation in the SYNOPSIS;
kristaps@@ will do the missing HTML part soon.
"looks nicer" jmc@@
"seems perfect to me" sobrado@@
"slap it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.50 2010/06/30 03:57:49 schwarze Exp $ */
d1022 3
@


1.50
log
@Closing of full blocks (Bd Bf Bk Bl It Fo Nd Rs Sh Ss) may never be
delayed: It must either succeed right away or fail outright.
As noticed by Kristaps, neglecting to fail properly when required
could make invalid input screw up the syntax tree and ultimately
trigger assertions in other, unrelated parts of the program.
This fix tested by and OK by kristaps@@.
While here, comment the rather tricky function rew_dohalt().
This function will probably need more tweaks later on.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.49 2010/06/29 19:42:03 schwarze Exp $ */
d96 1
a96 1
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Nm */ 
d391 2
d410 2
a411 1
	 * In particular, always skip block end markers.
d413 2
a414 1
	if (p->end || (MDOC_BLOCK == p->type &&
d510 3
a512 2
		mdoc_vmsg(m, MANDOCERR_SCOPE, line, ppos, "%s breaks %s",
		    mdoc_macronames[tok], mdoc_macronames[broken->tok]);
d546 3
a548 1
			mdoc_pmsg(m, line, ppos, MANDOCERR_SYNTNOSCOPE);
d658 1
a658 1
		if (MDOC_BLOCK != n->type)
d1294 2
a1295 2
	if (n != body && ! mdoc_vmsg(m, MANDOCERR_SCOPE, line, ppos,
	    "%s broken", mdoc_macronames[tok]))
d1648 3
a1650 1

@


1.49
log
@fix a typo in the function declaration;
seems like gcc3 didn't catch it :-(
thanks to thib@@ and kristaps@@ for reporting
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.48 2010/06/29 18:01:10 schwarze Exp $ */
d334 6
d344 5
d352 4
d361 4
d368 4
d406 19
a424 3
	return(p->end || (MDOC_BLOCK == p->type &&
	    ! (MDOC_EXPLICIT & mdoc_macros[tok].flags)) ?
	    REWIND_MORE : REWIND_LATER);
@


1.48
log
@Considerably simplify block rewind rules; no functional change intended.
* Let rew_alt() always succeed, obsoleting tons of case statements.
* Merge rew_dobreak() into rew_dohalt().
* Encode all rewinding cases uniformly in terms of "enum rew".
Required because i'm too dumb to get SYNOPSIS .Nm rewinding right
without cleaning this up first.

"get it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.47 2010/06/29 17:10:29 schwarze Exp $ */
d51 1
a51 1
static	int		make_pending(struct mdoc_node *, enum mdoc_type,
@


1.47
log
@Support for badly nested blocks, written around the time of
the Rostock mandoc hackathon and tested and polished since,
supporting constructs like:

.Ao Bo    Ac    Bc        (exp breaking exp)
.Aq Bo    eol   Bc        (imp breaking exp)
.Ao Bq    Ac    eol       (exp breaking imp)
.Ao Bo So Bc    Ac  Sc    (double break, inner before outer)
.Ao Bo So Ac    Bc  Sc    (double break, outer before inner)
.Ao Bo    Ac So Bc  Sc    (broken breaker)
.Ao Bo So Bc Do Ac  Sc Dc (broken double breaker)

There are still two known issues which are tricky:

1) Breaking two identical explicit blocks (Ao Bo Bo Ac or Aq Bo Bo eol)
fails outright, triggering a bogus syntax error.
2) Breaking a block by two identical explicit blocks (Ao Ao Bo Ac Ac Bc
or Ao Ao Bq Ac Ac eol) still has a minor rendering error left:
"<ao1 <ao2 [bo ac2> ac1> bc]>" should not have the final ">".

We can fix these later in the tree, let's not grow this diff too large.

"get it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.46 2010/06/06 20:30:08 schwarze Exp $ */
d28 6
a33 4
enum	rew {
	REWIND_REWIND,
	REWIND_NOHALT,
	REWIND_HALT
a54 2
static	int	  	rew_dobreak(enum mdoct, 
				const struct mdoc_node *);
d274 2
a275 2
 * Return the opening macro of a closing one, e.g., `Ec' has `Eo' as its
 * matching pair.
d314 1
a314 1
		break;
a315 1
	abort();
d320 8
a327 5
/* 
 * Rewind rules.  This indicates whether to stop rewinding
 * (REWIND_HALT) without touching our current scope, stop rewinding and
 * close our current scope (REWIND_REWIND), or continue (REWIND_NOHALT).
 * The scope-closing and so on occurs in the various rew_* routines.
d335 13
a347 3
		return(REWIND_HALT);
	if (MDOC_VALID & p->flags)
		return(REWIND_NOHALT);
d350 3
a352 30
	case (MDOC_Aq):
		/* FALLTHROUGH */
	case (MDOC_Bq):
		/* FALLTHROUGH */
	case (MDOC_Brq):
		/* FALLTHROUGH */
	case (MDOC_D1):
		/* FALLTHROUGH */
	case (MDOC_Dl):
		/* FALLTHROUGH */
	case (MDOC_Dq):
		/* FALLTHROUGH */
	case (MDOC_Op):
		/* FALLTHROUGH */
	case (MDOC_Pq):
		/* FALLTHROUGH */
	case (MDOC_Ql):
		/* FALLTHROUGH */
	case (MDOC_Qq):
		/* FALLTHROUGH */
	case (MDOC_Sq):
		/* FALLTHROUGH */
	case (MDOC_Vt):
		assert(MDOC_TAIL != type);
		if (tok != p->tok)
			break;
		if (p->end)
			return(REWIND_HALT);
		if (type == p->type)
			return(REWIND_REWIND);
a354 3
		assert(MDOC_TAIL != type);
		if (type == p->type && tok == p->tok)
			return(REWIND_REWIND);
d356 1
a356 1
			return(REWIND_HALT);
d358 9
a366 3
	case (MDOC_Sh):
		if (type == p->type && tok == p->tok)
			return(REWIND_REWIND);
a370 3
		assert(MDOC_TAIL != type);
		if (type == p->type && tok == p->tok)
			return(REWIND_REWIND);
d372 1
a372 56
			return(REWIND_HALT);
		break;
	case (MDOC_Ao):
		/* FALLTHROUGH */
	case (MDOC_Bd):
		/* FALLTHROUGH */
	case (MDOC_Bf):
		/* FALLTHROUGH */
	case (MDOC_Bk):
		/* FALLTHROUGH */
	case (MDOC_Bl):
		/* FALLTHROUGH */
	case (MDOC_Bo):
		/* FALLTHROUGH */
	case (MDOC_Bro):
		/* FALLTHROUGH */
	case (MDOC_Do):
		/* FALLTHROUGH */
	case (MDOC_Eo):
		/* FALLTHROUGH */
	case (MDOC_Fo):
		/* FALLTHROUGH */
	case (MDOC_Oo):
		/* FALLTHROUGH */
	case (MDOC_Po):
		/* FALLTHROUGH */
	case (MDOC_Qo):
		/* FALLTHROUGH */
	case (MDOC_Rs):
		/* FALLTHROUGH */
	case (MDOC_So):
		/* FALLTHROUGH */
	case (MDOC_Xo):
		if (tok != p->tok)
			break;
		if (p->end)
			return(REWIND_HALT);
		if (type == p->type)
			return(REWIND_REWIND);
		break;
	/* Multi-line explicit scope close. */
	case (MDOC_Ac):
		/* FALLTHROUGH */
	case (MDOC_Bc):
		/* FALLTHROUGH */
	case (MDOC_Brc):
		/* FALLTHROUGH */
	case (MDOC_Dc):
		/* FALLTHROUGH */
	case (MDOC_Ec):
		/* FALLTHROUGH */
	case (MDOC_Ed):
		/* FALLTHROUGH */
	case (MDOC_Ek):
		/* FALLTHROUGH */
	case (MDOC_El):
a373 56
	case (MDOC_Fc):
		/* FALLTHROUGH */
	case (MDOC_Ef):
		/* FALLTHROUGH */
	case (MDOC_Oc):
		/* FALLTHROUGH */
	case (MDOC_Pc):
		/* FALLTHROUGH */
	case (MDOC_Qc):
		/* FALLTHROUGH */
	case (MDOC_Re):
		/* FALLTHROUGH */
	case (MDOC_Sc):
		/* FALLTHROUGH */
	case (MDOC_Xc):
		if (rew_alt(tok) != p->tok)
			break;
		if (p->end)
			return(REWIND_HALT);
		if (type == p->type)
			return(REWIND_REWIND);
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	return(REWIND_NOHALT);
}


/*
 * See if we can break an encountered scope (the rew_dohalt has returned
 * REWIND_NOHALT). 
 */
static int
rew_dobreak(enum mdoct tok, const struct mdoc_node *p)
{

	assert(MDOC_ROOT != p->type);
	if (MDOC_ELEM == p->type)
		return(1);
	if (MDOC_TEXT == p->type)
		return(1);
	if (MDOC_VALID & p->flags)
		return(1);
	if (MDOC_BODY == p->type && p->end)
		return(1);

	switch (tok) {
	case (MDOC_It):
		return(MDOC_It == p->tok);
	case (MDOC_Nd):
		return(MDOC_Nd == p->tok);
	case (MDOC_Ss):
		return(MDOC_Ss == p->tok);
d375 3
a377 12
		if (MDOC_Nd == p->tok)
			return(1);
		if (MDOC_Ss == p->tok)
			return(1);
		return(MDOC_Sh == p->tok);
	case (MDOC_El):
		if (MDOC_It == p->tok)
			return(1);
		break;
	case (MDOC_Oc):
		if (MDOC_Op == p->tok)
			return(1);
d383 3
a385 6
	if (MDOC_EXPLICIT & mdoc_macros[tok].flags) 
		return(p->tok == rew_alt(tok));
	else if (MDOC_BLOCK == p->type)
		return(1);

	return(tok == p->tok);
d435 1
a435 1
		if (REWIND_REWIND != rew_dohalt(tok, MDOC_BLOCK, breaker))
d475 1
a475 1
	 * Report failure and abort the parser.
d481 1
a486 1
	enum rew	  c;
d488 14
a501 9
	/* LINTED */
	for (n = m->last; n; n = n->parent) {
		c = rew_dohalt(tok, t, n);
		if (REWIND_HALT == c) {
			if (n->end || MDOC_BLOCK != t)
				return(1);
			if ( ! (MDOC_EXPLICIT & mdoc_macros[tok].flags))
				return(1);
			/* FIXME: shouldn't raise an error */
d503 1
a503 1
			return(0);
d505 1
a505 5
		if (REWIND_REWIND == c)
			break;
		else if (rew_dobreak(tok, n))
			continue;
		return(make_pending(n, tok, m, line, ppos));
@


1.46
log
@Merge bsd.lv version 1.10.1 (to be released soon).

The main step forward is that this now has *much* better .Bl -column
support, now supporting many manuals that previously errored out
without producing any output.

Other fixes include:
* do not die from multiple list types, use the first and warn
* in .Bl without a type, default to -item
* various tweaks to .Dt
* fix .In, .Fd, .Ft, .Fn and .Fo formatting
* some documentation fixes and additions
* and fix a couple of bugs reported by Ulrich Spoerlein:
* better support for roff block-end "\}" without a preceding dot
* .In must not break the line outside SYNOPSIS
* spelling in some error messages

While merging, fix one regression in .In spacing
that needs to go to bsd.lv, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.45 2010/06/06 18:08:41 schwarze Exp $ */
d49 2
a61 2
static	int	  	swarn(struct mdoc *, enum mdoc_type, int, 
				int, const struct mdoc_node *);
a190 47
static int
swarn(struct mdoc *mdoc, enum mdoc_type type, 
		int line, int pos, const struct mdoc_node *p)
{
	const char	*n, *t, *tt;
	enum mandocerr	 ec;

	n = t = "<root>";
	tt = "block";

	switch (type) {
	case (MDOC_BODY):
		tt = "multi-line";
		break;
	case (MDOC_HEAD):
		tt = "line";
		break;
	default:
		break;
	}

	switch (p->type) {
	case (MDOC_BLOCK):
		n = mdoc_macronames[p->tok];
		t = "block";
		break;
	case (MDOC_BODY):
		n = mdoc_macronames[p->tok];
		t = "multi-line";
		break;
	case (MDOC_HEAD):
		n = mdoc_macronames[p->tok];
		t = "line";
		break;
	default:
		break;
	}

	ec = (MDOC_IGN_SCOPE & mdoc->pflags) ?
		MANDOCERR_SCOPE : MANDOCERR_SYNTSCOPE;

	return(mdoc_vmsg(mdoc, ec, line, pos, 
				"%s scope breaks %s of %s", 
				tt, t, n));
}


d362 5
a366 1
		if (type == p->type && tok == p->tok)
d420 5
a424 1
		if (type == p->type && tok == p->tok)
d459 5
a463 1
		if (type == p->type && rew_alt(tok) == p->tok)
d490 2
d542 77
d630 1
a630 1
			if (MDOC_BLOCK != t)
d642 1
a642 2
		if ( ! swarn(m, t, line, ppos, n))
			return(0);
d650 2
a651 3
	 * The current block extends an enclosing block beyond a line
	 * break.  Now that the current block ends, close the enclosing
	 * block, too.
d653 1
a653 2
	if (NULL != (n = n->pending)) {
		assert(MDOC_HEAD == n->type);
d656 2
a657 1
		if ( ! mdoc_body_alloc(m, n->line, n->pos, n->tok))
d712 4
d718 1
a718 1
	enum mdoct	 ntok;
d732 62
d808 1
a808 1
	if (maxargs > 0) 
d1360 19
d1385 2
a1386 5
	for (n = m->last; n; n = n->parent)
		if (body == n)
			break;

	if (NULL == n && ! mdoc_nmsg(m, body, MANDOCERR_SCOPE))
d1389 1
a1389 1
	if (n && ! rew_last(m, body))
d1399 1
a1399 1
	if (n && ! rew_last(m, blk))
@


1.45
log
@Merge bsd.lv release 1.10.0,
which is mostly the post-hackathon release,
bringing in the OpenBSD changes to bsd.lv,
but which also has a few additional minor fixes:

* .Lb is an in-line macro, not in_line_eoln
* .Bt, .Ud now warn when discarding arguments
* allow bad -man dates to flow verbatim into the front-ends
- so far all reported by Ulrich Spoerlein
* .Ar, .Fl and .Li starting with closing punctuation emit an empty element
* empty .Li macros print nothing, but may cause spacing
* proper EOS handling for .Bt, .Ex, .Rv, and .Ud.
* cleanup: collapse posts_xr into posts_wtext (which is the same)
* efficiency: very simple table lookup for roff.c
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.44 2010/05/23 22:45:00 schwarze Exp $ */
d43 1
d49 1
a49 2
static	int	  	phrase(struct mdoc *, int, int, 
				char *, enum margserr);
d185 1
d196 1
a196 1
	int		 rc;
d229 2
a230 2
	rc = mdoc_vmsg(mdoc, MANDOCERR_SCOPE, line, pos,
			"%s scope breaks %s of %s", tt, t, n);
d232 3
a234 2
	/* FIXME: logic should be in driver. */
	return(MDOC_IGN_SCOPE & mdoc->pflags ? rc : 0);
d933 1
d1002 2
a1003 1
		lac = ac;
d1008 16
a1023 1
		if (ARGS_EOLN == ac)
a1024 6

		if (ARGS_PEND == ac) {
			if (ARGS_PPHRASE == lac)
				ac = ARGS_PPHRASE;
			else
				ac = ARGS_PHRASE;
d1027 4
a1030 1
		/* Don't emit leading punct. for phrases. */
d1033 1
d1043 1
a1043 1
		/* Always re-open head for phrases. */
d1045 1
a1045 3
		if (NULL == head || 
				ARGS_PHRASE == ac || 
				ARGS_PPHRASE == ac) {
d1051 24
a1074 1
		if (ARGS_PHRASE == ac || ARGS_PPHRASE == ac) {
d1077 4
a1080 1
			if ( ! phrase(m, line, la, buf, ac))
d1082 1
a1083 2
			if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
				return(0);
d1112 1
a1112 1
		return(1);
d1136 10
d1635 1
a1635 1
phrase(struct mdoc *m, int line, int ppos, char *buf, enum margserr ac)
d1638 1
a1638 1
	enum margserr	 aac;
a1641 2
	assert(ARGS_PHRASE == ac || ARGS_PPHRASE == ac);

d1645 1
a1645 1
		aac = mdoc_zargs(m, line, &pos, buf, 0, &p);
d1647 1
a1647 1
		if (ARGS_ERROR == aac)
d1649 1
a1649 1
		if (ARGS_EOLN == aac)
d1652 1
a1652 1
		ntok = ARGS_QWORD == aac ? MDOC_MAX : lookup_raw(p);
d1669 43
@


1.44
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.43 2010/05/15 15:53:29 schwarze Exp $ */
d170 1
a170 1
	{ in_line_eoln, 0 }, /* Lb */
d750 1
a750 1
	int		 la, lastpunct, cnt, nc, nl;
d801 1
a801 1
	for (cnt = 0, lastpunct = 1;; ) {
d822 1
a822 1
			if (0 == lastpunct && ! rew_elem(m, tok))
d849 23
a871 2
		if (ARGS_QWORD != ac && DELIM_NONE != d) {
			if (0 == lastpunct && ! rew_elem(m, tok))
d873 2
a874 2
			lastpunct = 1;
		} else if (lastpunct) {
d877 1
a877 1
			lastpunct = 0;
d890 1
a890 1
		if (0 == lastpunct && MDOC_Fl == tok) {
d893 1
a893 1
			lastpunct = 1;
d897 1
a897 1
	if (0 == lastpunct && ! rew_elem(m, tok))
@


1.43
log
@merge bsd.lv rev. 1.63:
remove "1 == ppos" conditions that remained after rev. 1.60
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.42 2010/05/15 15:37:53 schwarze Exp $ */
d24 1
d195 1
d228 5
a232 7
	if ( ! (MDOC_IGN_SCOPE & mdoc->pflags))
		return(mdoc_verr(mdoc, line, pos, 
				"%s scope breaks %s scope of %s", 
				tt, t, n));
	return(mdoc_vwarn(mdoc, line, pos, 
				"%s scope breaks %s scope of %s", 
				tt, t, n));
d255 2
a256 1
		return(mdoc_nerr(m, n, EOPEN));
d588 3
a590 1
			return(mdoc_perr(m, line, ppos, ENOCTX));
d685 1
d687 1
a687 1
			if ( ! mdoc_pwarn(m, line, ppos, ENOLINE))
d831 1
a831 1
				if ( ! mdoc_pwarn(m, line, ppos, EIGNE))
d892 1
a892 1
		if ( ! mdoc_pwarn(m, line, ppos, EIGNE))
d1191 1
a1191 1
	if (NULL == n && ! mdoc_nwarn(m, body, EIMPBRK))
d1554 1
a1554 1
	return(mdoc_pwarn(m, line, ppos, EOBS));
@


1.42
log
@more end-of-sentence (EOS) handling:
* recognize the end of quoted sentences, and of those in parantheses
* detect EOS in append_delims, so it works after all macros
by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.41 2010/05/15 13:12:55 schwarze Exp $ */
d639 1
d901 1
a901 1
	int		  la;
d911 2
d1041 1
a1041 1
	if (1 == ppos && ! append_delims(m, line, pos, buf))
d1078 1
a1078 1
	int		  la;
d1086 2
d1195 1
a1195 1
	if (1 == ppos && ! append_delims(m, line, pos, buf))
@


1.41
log
@proper handling of quoted tab-separated column lists
by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.40 2010/05/15 12:30:59 schwarze Exp $ */
d618 1
a618 1
append_delims(struct mdoc *mdoc, int line, int *pos, char *buf)
d620 1
a620 1
	int		 lastarg;
d624 1
a624 1
	if (0 == buf[*pos])
d628 2
a629 2
		lastarg = *pos;
		ac = mdoc_zargs(mdoc, line, pos, buf, ARGS_NOWARN, &p);
d635 1
d637 1
a637 1
		if ( ! mdoc_word_alloc(mdoc, line, lastarg, p))
d639 13
@


1.40
log
@Distinguish OPEN, MIDDLE and CLOSE delimiters (using an enum).
Only OPEN are drawn before the beginning of a macro;
this is new, before this, MIDDLE ('|') were drawn in front, too.
Only CLOSE are pushed after the end of a macro (as before).
ok kristaps@@

This allows us to finally enable handling of leading punctuation
without regressions.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.39 2010/05/15 09:20:01 schwarze Exp $ */
d48 1
a48 1
				char *, enum margserr, int);
d886 1
a886 1
	int		  la, pcnt;
d955 1
a955 1
	for (pcnt = 0; ; ) {
d965 7
a976 1
				ARGS_PEND != ac &&
a987 1
				ARGS_PEND == ac || 
d994 4
a997 15
		if (ARGS_PHRASE == ac || 
				ARGS_PEND == ac ||
				ARGS_PPHRASE == ac) {
			/*
			 * Special treatment for the last phrase.  A
			 * prior ARGS_PHRASE gets is handled as a
			 * regular ARGS_PHRASE, but a prior ARGS_PPHRASE
			 * has special handling.
			 */
			if (ARGS_PEND == ac && ARGS_ERROR == lac)
				ac = ARGS_PHRASE;
			else if (ARGS_PEND == ac && ARGS_PHRASE == lac)
				ac = ARGS_PHRASE;

			if ( ! phrase(m, line, la, buf, ac, pcnt++))
d999 1
d1541 1
a1541 2
phrase(struct mdoc *m, int line, int ppos, char *buf, 
		enum margserr ac, int count)
d1548 1
a1548 6
	assert(ARGS_PHRASE == ac || 
			ARGS_PEND == ac ||
			ARGS_PPHRASE == ac);

	if (count && ARGS_PPHRASE == ac)
		return(mdoc_word_alloc(m, line, ppos, &buf[ppos]));
a1552 1
		/* Note: no calling context! */
d1560 1
a1560 2
		ntok = ARGS_QWORD == aac || ARGS_PEND == ac ? 
			MDOC_MAX : lookup_raw(p);
@


1.39
log
@block-implicit macros now up-propogate end-of-sentence spacing;
from bsd.lv mandoc.c 1.13 and mdoc_macro.c 1.64
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.38 2010/05/14 19:52:43 schwarze Exp $ */
d635 1
a635 1
		assert(mdoc_isdelim(p));
d731 1
a731 1
	int		 la, lastpunct, cnt, d, nc, nl;
d735 1
d828 1
a828 1
		d = ARGS_QWORD == ac ? 0 : mdoc_isdelim(p);
d830 1
a830 1
		if (ARGS_QWORD != ac && d) {
d840 1
a840 1
		if ( ! d)
a964 5
/*
 * XXX Temporarily disable the handling of leading punctuation.
 *     We must investigate the fallout before enabling this.
 */
#if 0
d972 1
a972 1
				1 == mdoc_isdelim(p)) {
a976 1
#endif
a1109 5
/*
 * XXX Temporarily disable the handling of leading punctuation.
 *     We must investigate the fallout before enabling this.
 */
#if 0
d1111 1
a1111 1
				1 == mdoc_isdelim(p)) {
a1115 1
#endif
a1224 5
/*
 * XXX Temporarily disable the handling of leading punctuation.
 *     We must investigate the fallout before enabling this.
 */
#if 0
d1228 1
a1228 1
				1 == mdoc_isdelim(p)) {
a1233 1
#endif
a1370 5
/*
 * XXX Temporarily disable the handling of leading punctuation.
 *     We must investigate the fallout before enabling this.
 */
#if 0
d1373 1
a1373 1
				0 == j && 1 == mdoc_isdelim(p)) {
d1377 1
a1377 3
		} else
#endif
		if (0 == j)
d1401 2
a1402 1
				! flushed && mdoc_isdelim(p)) {
@


1.38
log
@Integrate kristaps@@' end-of-sentence (EOS) framework
which is simpler and more powerful than mine, and remove mine.

* man(7) now has EOS handling, too
* put EOS detection into its own function in libmandoc
* use node and termp flags to communicate the EOS condition
* no more EOS pseudo-macro
* no more non-printable EOS marker character on the formatter level

This slightly breaks EOS detection after trailing punctuation
in mdoc(7) macros, but that will be restored soon.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.37 2010/05/14 14:47:44 schwarze Exp $ */
d25 1
d1153 19
@


1.37
log
@Merge 1.9.25, keeping local patches;
this does not merge kristaps' end-of-sentences handling yet,
i will check that separately.  This one includes:
* handle \*(Ba as a delimiter
* introduce ARGS_PEND for .Bl -column .It end-of-line special casing
* section ordering: expect EXIT STATUS at the right place
* line break fixes in SYNOPSIS
* allow literal contexts to have arbitrary line lengths
* the input file column number can not be used to identify the beginning
  of a line because white space is allowed after the initial '.'
* proper leading spaces in -man -Tascii mode
* do not let Lb break lines in -mdoc -Thtml LIBRARY
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.36 2010/05/14 01:54:37 schwarze Exp $ */
a182 1
	{ NULL, 0 }, /* eos */
@


1.36
log
@merge 1.9.24, keeping local patches; some changes:
* preserve multiple consecutive space characters in input
* do not restrict .Cd and .Rv to certain sections (requested by Joerg)
* do not run lookup() on quoted words
* enum return types for mdoc_args and mdoc_argv
* fix auto-closing of LINK tag in -Txhtml (from Daniel Friesel)
* various lint and manual fixes
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.35 2010/04/07 23:15:05 schwarze Exp $ */
d46 2
a47 1
static	int	  	phrase(struct mdoc *, int, int, char *);
d650 1
a650 1
	int	 	 j, lastarg, maxargs, flushed;
d655 2
d722 1
a722 1
	if (ppos > 1)
d731 1
a731 1
	int		 la, lastpunct, cnt, d, nc;
d738 2
d816 1
a816 1
			if (ppos > 1)
d876 1
a876 1
	if (ppos > 1)
d885 1
a885 1
	int		  la;
d891 1
a891 1
	enum margserr	  ac;
d952 3
a954 1
	for (;;) {
d956 1
d971 2
a972 1
		if (NULL == head && ARGS_PHRASE != ac &&
d974 1
d985 3
a987 1
		if (NULL == head || ARGS_PHRASE == ac || 
d994 15
a1008 2
		if (ARGS_PHRASE == ac || ARGS_PPHRASE == ac) {
			if ( ! phrase(m, line, la, buf))
d1188 1
a1188 1
	int		  la;
d1195 2
d1295 1
a1295 1
	if (ppos > 1)
a1296 1

d1301 1
d1305 1
a1305 1
	int		 la, flushed, j, maxargs;
d1312 2
d1437 1
a1437 2

	if (ppos > 1)
d1513 3
d1522 1
a1522 1
	if (ppos > 1)
d1550 2
a1551 1
phrase(struct mdoc *m, int line, int ppos, char *buf)
d1554 1
a1554 1
	enum margserr	 ac;
d1558 7
d1569 1
a1569 1
		ac = mdoc_zargs(m, line, &pos, buf, 0, &p);
d1571 1
a1571 1
		if (ARGS_ERROR == ac)
d1573 1
a1573 1
		if (ARGS_EOLN == ac)
d1576 2
a1577 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup_raw(p);
@


1.35
log
@Merge the good parts of 1.9.23,
avoid the bad parts of 1.9.23, and keep local patches.

Input in general:
 * Basic handling of roff-style font escapes \f, \F.
 * Quoted punctuation does not count as punctuation.

mdoc(7) parser:
 * Make .Pf callable; noted by Claus Assmann.
 * Let .Bd and .Bl ignore unknown arguments; noted by deraadt@@.
 * Do not warn when .Er is used outside certain sections.
 * Replace mdoc_node_free[list] by mdoc_node_delete.
 * Replace #define by enum for rew*() return values.

man(7) parser:
 * When .TH is missing, use default section and date.

Output in general:
 * Curly braces do not count as punctuation.
 * No space after .Fl w/o args when a macro follows on the same line.

HTML output:
 * Unify PAIR_*_INIT macros, introduce new PAIR_ID_INIT().
 * Print whitespace after, not before .Vt .Fn .Ft .Fo.

Checked that all manuals in base still build.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.34 2010/04/02 12:39:47 schwarze Exp $ */
d32 27
a58 27
static	int	  ctx_synopsis(MACRO_PROT_ARGS);
static	int	  obsolete(MACRO_PROT_ARGS);
static	int	  blk_part_exp(MACRO_PROT_ARGS);
static	int	  in_line_eoln(MACRO_PROT_ARGS);
static	int	  in_line_argn(MACRO_PROT_ARGS);
static	int	  in_line(MACRO_PROT_ARGS);
static	int	  blk_full(MACRO_PROT_ARGS);
static	int	  blk_exp_close(MACRO_PROT_ARGS);
static	int	  blk_part_imp(MACRO_PROT_ARGS);

static	int	  phrase(struct mdoc *, int, int, char *);
static	enum rew  rew_dohalt(enum mdoct, enum mdoc_type, 
			const struct mdoc_node *);
static	enum mdoct rew_alt(enum mdoct);
static	int	  rew_dobreak(enum mdoct, const struct mdoc_node *);
static	int	  rew_elem(struct mdoc *, enum mdoct);
static	int	  rew_sub(enum mdoc_type, struct mdoc *, 
			enum mdoct, int, int);
static	int	  rew_last(struct mdoc *, 
			const struct mdoc_node *);
static	int	  append_delims(struct mdoc *, int, int *, char *);
static	int	  lookup(int, const char *);
static	int	  lookup_raw(const char *);
static	int	  swarn(struct mdoc *, enum mdoc_type, int, int, 
			const struct mdoc_node *);

/* Central table of library: who gets parsed how. */
d266 2
a267 2
static int
lookup(int from, const char *p)
d280 1
a280 1
static int
d283 1
a283 1
	int		 res;
d619 2
a620 1
	int		 c, lastarg;
d628 1
a628 2
		c = mdoc_zargs(mdoc, line, pos, buf, ARGS_NOWARN, &p);
		assert(ARGS_PHRASE != c);
d630 1
a630 1
		if (ARGS_ERROR == c)
d632 1
a632 1
		else if (ARGS_EOLN == c)
d649 3
a651 1
	int	 	 j, c, lastarg, maxargs, flushed;
d689 1
a689 1
		c = mdoc_args(m, line, pos, buf, tok, &p);
d691 1
a691 1
		if (ARGS_ERROR == c)
d693 1
a693 1
		if (ARGS_PUNCT == c)
d695 1
a695 1
		if (ARGS_EOLN == c)
d698 4
a701 7
		if (MDOC_MAX != (c = lookup(tok, p))) {
			if ( ! flushed) {
				if ( ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
					return(0);
				flushed = 1;
			}
			if ( ! mdoc_macro(m, c, line, lastarg, pos, buf))
d703 2
a704 2
			break;
		} 
d706 6
a711 1
		if ( ! mdoc_word_alloc(m, line, lastarg, p))
d713 1
d728 6
a733 3
	int		  la, lastpunct, c, w, cnt, d, nc;
	struct mdoc_arg	 *arg;
	char		 *p;
d761 1
a761 1
		c = mdoc_argv(m, line, tok, &arg, pos, buf);
d763 1
a763 1
		if (ARGV_WORD == c) {
d767 1
a767 1
		if (ARGV_EOLN == c)
d769 1
a769 1
		if (ARGV_ARG == c)
d778 1
a778 1
		w = mdoc_args(m, line, pos, buf, tok, &p);
d780 1
a780 1
		if (ARGS_ERROR == w)
d782 1
a782 1
		if (ARGS_EOLN == w)
d784 1
a784 1
		if (ARGS_PUNCT == w)
d787 1
a787 3
		/* Quoted words shouldn't be looked-up. */

		c = ARGS_QWORD == w ? MDOC_MAX : lookup(tok, p);
d796 1
a796 1
		if (MDOC_MAX != c) {
d809 1
a809 2
			c = mdoc_macro(m, c, line, la, pos, buf);
			if (0 == c)
d822 1
a822 1
		d = ARGS_QWORD == w ? 0 : mdoc_isdelim(p);
d824 1
a824 1
		if (ARGS_QWORD != w && d) {
d880 1
a880 1
	int		  c, la;
d885 3
d910 1
a910 1
		c = mdoc_argv(m, line, tok, &arg, pos, buf);
d912 1
a912 1
		if (ARGV_WORD == c) {
d917 1
a917 1
		if (ARGV_EOLN == c)
d919 1
a919 1
		if (ARGV_ARG == c)
d949 1
a949 1
		c = mdoc_args(m, line, pos, buf, tok, &p);
d951 1
a951 1
		if (ARGS_ERROR == c)
d953 1
a953 1
		if (ARGS_EOLN == c)
d963 3
a965 2
		if (NULL == head && ARGS_PHRASE != c &&
				ARGS_QWORD != c &&
d975 2
a976 1
		if (NULL == head || ARGS_PHRASE == c) {
d982 1
a982 1
		if (ARGS_PHRASE == c) {
d990 4
a993 3
		c = lookup(tok, p);
		if (MDOC_MAX != c) {
			if ( ! mdoc_macro(m, c, line, la, pos, buf))
d995 1
a995 1
			break;
d997 2
a998 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d1000 1
a1000 1

d1046 3
a1048 1
	int		  la, c;
d1081 1
a1081 1
		c = mdoc_args(m, line, pos, buf, tok, &p);
d1083 1
a1083 3
		assert(ARGS_PHRASE != c);

		if (ARGS_ERROR == c)
d1085 1
a1085 1
		if (ARGS_EOLN == c)
d1087 1
a1087 1
		if (ARGS_PUNCT == c)
d1095 1
a1095 1
		if (NULL == body && ARGS_QWORD != c &&
d1109 4
a1112 2
		if (MDOC_MAX != (c = lookup(tok, p))) {
			if ( ! mdoc_macro(m, c, line, la, pos, buf))
d1114 2
a1115 2
			break;
		} 
d1117 1
a1117 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d1119 1
d1163 2
a1164 1
	int		  la, c;
d1168 1
d1181 1
a1181 1
		c = mdoc_args(m, line, pos, buf, tok, &p);
d1183 1
a1183 1
		if (ARGS_ERROR == c)
d1185 1
a1185 1
		if (ARGS_PUNCT == c)
d1187 1
a1187 1
		if (ARGS_EOLN == c)
a1189 2
		assert(ARGS_PHRASE != c);

d1197 1
a1197 1
		if (NULL == head && ARGS_QWORD != c &&
d1237 4
a1240 2
		if (MDOC_MAX != (c = lookup(tok, p))) {
			if ( ! mdoc_macro(m, c, line, la, pos, buf))
d1242 1
a1242 1
			break;
d1245 1
a1245 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d1247 1
d1278 6
a1283 3
	int		  la, flushed, j, c, maxargs;
	struct mdoc_arg	 *arg;
	char		 *p;
d1313 1
a1313 1
		c = mdoc_argv(m, line, tok, &arg, pos, buf);
d1315 1
a1315 1
		if (ARGV_WORD == c) {
d1320 1
a1320 1
		if (ARGV_EOLN == c)
d1322 1
a1322 1
		if (ARGV_ARG == c)
d1331 1
a1331 1
		c = mdoc_args(m, line, pos, buf, tok, &p);
d1333 1
a1333 1
		if (ARGS_ERROR == c)
d1335 1
a1335 1
		if (ARGS_PUNCT == c)
d1337 1
a1337 1
		if (ARGS_EOLN == c)
d1346 1
a1346 1
				ARGS_QWORD != c &&
d1363 3
a1365 1
		if (MDOC_MAX != (c = lookup(tok, p))) {
d1369 1
a1369 1
			if ( ! mdoc_macro(m, c, line, la, pos, buf))
d1376 1
a1376 1
				ARGS_QWORD != c &&
d1418 6
a1423 3
	int		  c, w, la;
	struct mdoc_arg	 *arg;
	char		 *p;
d1431 1
a1431 1
		c = mdoc_argv(m, line, tok, &arg, pos, buf);
d1433 1
a1433 1
		if (ARGV_WORD == c) {
d1437 1
a1437 1
		if (ARGV_EOLN == c) 
d1439 1
a1439 1
		if (ARGV_ARG == c)
d1455 1
a1455 1
		w = mdoc_args(m, line, pos, buf, tok, &p);
d1457 1
a1457 1
		if (ARGS_ERROR == w)
d1459 1
a1459 1
		if (ARGS_EOLN == w)
d1462 1
a1462 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup(tok, p);
d1464 2
a1465 2
		if (MDOC_MAX != c) {
			if ( ! rew_elem(m, tok))
d1467 2
a1468 2
			return(mdoc_macro(m, c, line, la, pos, buf));
		} 
d1470 1
a1470 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d1472 1
d1521 4
a1524 2
	int		  c, w, la, pos;
	char		 *p;
d1530 1
a1530 1
		w = mdoc_zargs(m, line, &pos, buf, 0, &p);
d1532 1
a1532 1
		if (ARGS_ERROR == w)
d1534 1
a1534 1
		if (ARGS_EOLN == w)
d1537 1
a1537 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup_raw(p);
d1539 2
a1540 2
		if (MDOC_MAX != c) {
			if ( ! mdoc_macro(m, c, line, la, &pos, buf))
d1542 2
a1543 2
			return(append_delims(m, line, &pos, buf));
		} 
d1545 1
a1545 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d1547 1
@


1.34
log
@merge 1.9.22, keeping local patches
* convert mdoc tokens from #define to enum
* fix a segfault with .Xo/.Xc in explicit blocks
* Thorn is \*(Th, not \*(TH; noticed by Joerg Sonnenberger
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.33 2010/04/02 11:39:00 schwarze Exp $ */
d26 5
a30 3
#define	REWIND_REWIND	(1 << 0)
#define	REWIND_NOHALT	(1 << 1)
#define	REWIND_HALT	(1 << 2)
d43 1
a43 1
static	int	  rew_dohalt(enum mdoct, enum mdoc_type, 
d138 1
a138 1
	{ in_line_argn, MDOC_PARSED | MDOC_IGNDELIM }, /* Pf */
d370 1
a370 1
static int 
d576 1
a576 1
	int		  c;
d817 1
a817 1
		d = mdoc_isdelim(p);
d956 1
d1083 2
a1084 1
		if (NULL == body && 1 == mdoc_isdelim(p)) {
d1182 2
a1183 1
		if (NULL == head && 1 == mdoc_isdelim(p)) {
d1325 1
d1353 1
@


1.33
log
@Temporarily disable the handling of leading punctuation.
We must investigate the fallout before enabling this.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.31 2010/03/02 00:38:59 schwarze Exp $ */
d41 1
a41 1
static	int	  rew_dohalt(int, enum mdoc_type, 
d43 3
a45 3
static	int	  rew_alt(int);
static	int	  rew_dobreak(int, const struct mdoc_node *);
static	int	  rew_elem(struct mdoc *, int);
d47 1
a47 1
			int, int, int);
d318 2
a319 2
static int
rew_alt(int tok)
d369 2
a370 1
rew_dohalt(int tok, enum mdoc_type type, const struct mdoc_node *p)
d509 1
a509 1
rew_dobreak(int tok, const struct mdoc_node *p)
a537 1
		/* XXX - experimental! */
d555 1
a555 1
rew_elem(struct mdoc *mdoc, int tok)
d571 1
a571 1
		int tok, int line, int ppos)
d599 3
a601 2
	 * The current block extends an enclosing block beyond a line break.
	 * Now that the current block ends, close the enclosing block, too.
d603 1
a603 1
	if ((n = n->pending) != NULL) {
d876 1
d919 1
a919 1
	head = NULL;
d934 1
d997 1
a997 1
	/* See notes on `Nd' hybrid, above. */
d999 1
a999 1
	if (MDOC_Nd == tok)
d1003 4
a1006 3
	 * If there is an open sub-block requiring explicit close-out,
	 * postpone switching the current block from head to body
	 * until the rew_sub() call closing out that sub-block.
d1009 4
a1012 2
		if (MDOC_BLOCK == n->type &&
		    MDOC_EXPLICIT & mdoc_macros[n->tok].flags) {
d1115 1
a1115 1
	 * crufty use of `Op' breakage.  XXX: DEPRECATE.
a1116 1

@


1.32
log
@merge 1.9.20, keeping local patches
* prevent roff instructions in man(7) from clobbering scopes and line modes
  (noted by Sascha Wildner)
* handle leading punctuation in mdoc(7) blocks and line macros
  (looks good in principle, but is causing some fallout in OpenBSD,
   so i will disable it locally for now with the next commit)
@
text
@d943 5
d956 1
d1069 5
d1079 1
d1166 5
d1179 1
d1309 5
d1319 3
a1321 1
		} else if (0 == j)
@


1.31
log
@Proper inter-sentence spacing for mdoc(7).
When a text line or a non-block macro line in the source code ends
in any of ".!?", consider that an end of sentence (EOS).
This makes Jason's rule "new sentence, new line" even more important.
Let the parser detect the EOS and insert a token into the AST.
Let the -Tascii frontend render the EOS token as a double space before
the next word.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.29 2010/02/26 12:12:24 schwarze Exp $ */
d728 1
a849 1
	 *
d851 1
d872 1
a872 1
	int		  c, lastarg, reopen, dohead;
d874 2
a875 1
	struct mdoc_node *head, *n;
d878 1
a878 15
	/* 
	 * Whether to process a block-head section.  If this is
	 * non-zero, then a head will be opened for all line arguments.
	 * If not, then the head will always be empty and only a body
	 * will be opened, which will stay open at the eoln.
	 */

	switch (tok) {
	case (MDOC_Nd):
		dohead = 0;
		break;
	default:
		dohead = 1;
		break;
	}
d887 9
d897 1
a897 1
		lastarg = *pos;
d901 1
a901 1
			*pos = lastarg;
a915 3
	if ( ! mdoc_head_alloc(m, line, ppos, tok))
		return(0);
	head = m->last;
d917 1
a917 7
	if (0 == buf[*pos]) {
		if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
			return(0);
		if ( ! mdoc_body_alloc(m, line, ppos, tok))
			return(0);
		return(1);
	}
d919 4
a922 1
	/* Immediately close out head and enter body, if applicable. */
d924 4
a927 1
	if (0 == dohead) {
d934 2
a935 2
	for (reopen = 0;; ) {
		lastarg = *pos;
d942 14
a955 3
		if (ARGS_PHRASE == c) {
			assert(dohead);
			if (reopen && ! mdoc_head_alloc(m, line, ppos, tok))
d958 4
a961 6
			/*
			 * Phrases are self-contained macro phrases used
			 * in the columnar output of a macro. They need
			 * special handling.
			 */
			if ( ! phrase(m, line, lastarg, buf))
a964 2

			reopen = 1;
d968 3
a970 2
		if (MDOC_MAX == (c = lookup(tok, p))) {
			if ( ! mdoc_word_alloc(m, line, lastarg, p))
d972 6
a977 2
			continue;
		} 
d979 2
a980 1
		if ( ! mdoc_macro(m, c, line, lastarg, pos, buf))
d982 1
a982 1
		break;
d988 3
a990 2
	/* If the body's already open, then just return. */
	if (0 == dohead) 
d1005 1
d1021 3
a1023 1
	struct mdoc_node *blk, *body, *n;
d1025 8
a1032 1
	/* If applicable, close out prior scopes. */
d1036 1
a1036 1
	/* Saved for later close-out. */
d1038 1
a1042 4
	if ( ! mdoc_body_alloc(m, line, ppos, tok))
		return(0);
	/* Saved for later close-out. */
	body = m->last;
d1044 5
a1048 1
	/* Body argument processing. */
d1050 1
a1050 1
	for (;;) {
d1053 1
d1058 2
a1061 2
		if (ARGS_EOLN == c)
			break;
d1063 1
a1063 1
		if (MDOC_MAX == (c = lookup(tok, p))) {
d1069 20
a1088 1
		if ( ! mdoc_macro(m, c, line, la, pos, buf))
d1090 1
a1090 1
		break;
d1097 1
a1097 1
	 * crufty use of `Op' breakage--XXX, deprecate in time.
d1099 1
d1103 1
d1106 1
d1127 3
a1129 1
	int		  la, flushed, j, c, maxargs;
d1132 5
a1136 12
	/* Number of head arguments.  Only `Eo' has these, */

	switch (tok) {
	case (MDOC_Eo):
		maxargs = 1;
		break;
	default:
		maxargs = 0;
		break;
	}

	/* Begin the block scope. */
d1141 1
a1141 23
	/* 
	 * If no head arguments, open and then close out a head, noting
	 * that we've flushed our terms.  `flushed' means that we've
	 * flushed out the head and the body is open.
	 */

	if (0 == maxargs) {
		if ( ! mdoc_head_alloc(m, line, ppos, tok))
			return(0);
		if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
			return(0);
		if ( ! mdoc_body_alloc(m, line, ppos, tok))
			return(0);
		flushed = 1;
	} else {
		if ( ! mdoc_head_alloc(m, line, ppos, tok))
			return(0);
		flushed = 0;
	}

	/* Process the head/head+body line arguments. */

	for (j = 0; ; j++) {
a1142 8
		if (j == maxargs && ! flushed) {
			if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
				return(0);
			flushed = 1;
			if ( ! mdoc_body_alloc(m, line, ppos, tok))
				return(0);
		}

a1143 1
		assert(ARGS_PHRASE != c);
d1152 14
a1165 9
		if (MDOC_MAX != (c = lookup(tok, p))) {
			if ( ! flushed) {
				if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
					return(0);
				flushed = 1;
				if ( ! mdoc_body_alloc(m, line, ppos, tok))
					return(0);
			}
			if ( ! mdoc_macro(m, c, line, la, pos, buf))
d1167 1
a1167 1
			break;
d1170 12
a1181 1
		if ( ! flushed && mdoc_isdelim(p) > 1) {
a1183 1
			flushed = 1;
d1186 12
d1199 1
a1199 1
	
d1204 7
a1210 1
	/* Close the head and open the body, if applicable. */
d1212 1
a1212 1
	if ( ! flushed) {
d1217 1
d1224 1
d1236 7
a1242 1
	/* Fixed maximum arguments per macro, if applicable. */
d1262 1
a1262 3
	/* Macro argument processing. */

	for (arg = NULL;; ) {
d1280 1
a1280 8
	/* Open the element scope. */

	if ( ! mdoc_elem_alloc(m, line, ppos, tok, arg))
		return(0);

	/* Process element arguments. */

	for (flushed = j = 0; ; j++) {
a1281 7

		if (j == maxargs && ! flushed) {
			if ( ! rew_elem(m, tok))
				return(0);
			flushed = 1;
		}

d1291 15
d1312 1
d1330 1
a1330 1
			if ( ! mdoc_elem_alloc(m, line, ppos, MDOC_Ns, NULL))
d1338 1
d1341 4
a1344 1
	/* Close out and append delimiters. */
@


1.30
log
@Distinguish opening and closing delimiters, and close out block
macros after closing delimiters only, not after opening ones.  Besides,
neither roff nor old nor new groff consider braces { } as delimiters.

This fixes some frequent misrenderings by mandoc,
for example ".Ql (" being rendered as "`'(" instead of "`('".
@
text
@d180 1
@


1.29
log
@Support .It .Xo.
The trick is to not switch from the .It header to the body at EOL, but,
in case an explicit block macro follows, at the end of the block.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.28 2010/02/18 02:11:26 schwarze Exp $ */
d1158 1
a1158 1
		if ( ! flushed && mdoc_isdelim(p)) {
@


1.28
log
@sync to release 1.9.15:
 * corrected .Vt handling (spotted by Joerg Sonnenberger)
 * corrected .Xr argument handling (based on my patch)
 * removed \\ escape sequence (because it is for low-level roff only)
 * warn about trailing whitespace (suggested by jmc@@)
 * -Txhtml support
 * and some general cleanup and doc improvements
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.39 2010/01/01 13:17:58 kristaps Exp $ */
d594 15
a608 1
	return(rew_last(m, n));
d872 1
d918 3
a922 2
		if ( ! mdoc_head_alloc(m, line, ppos, tok))
			return(0);
a929 3
	if ( ! mdoc_head_alloc(m, line, ppos, tok))
		return(0);

d951 1
d983 13
@


1.27
log
@When multiple arguments are passed to .Fl,
each should be rendered with its own dash.

Fixes regress/usr.bin/mandoc/mdoc/Fl/multiarg.in;
ok kristaps@@ and merged upstream in rev. 1.39.
@
text
@d30 1
d98 2
a99 2
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Vt */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Xr */
d398 2
d1179 3
d1247 14
a1260 1
	
d1335 23
@


1.26
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.25 2009/10/27 21:40:07 schwarze Exp $ */
d811 11
@


1.25
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.24 2009/09/21 21:11:37 schwarze Exp $ */
d22 1
@


1.24
log
@sync to 1.9.5: lookup hashes are now static tables
shortening the code, and, according to kristaps@@, speeding it up
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.23 2009/08/22 22:39:55 schwarze Exp $ */
d177 1
@


1.23
log
@sync to 1.9.1: correctly flag delimiter whitespace
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.22 2009/08/22 21:55:06 schwarze Exp $ */
d49 2
a50 2
static	int	  lookup(struct mdoc *, int, const char *);
static	int	  lookup_raw(struct mdoc *, const char *);
d261 1
a261 1
lookup(struct mdoc *mdoc, int from, const char *p)
d263 1
d267 1
a267 1
	return(lookup_raw(mdoc, p));
d275 1
a275 1
lookup_raw(struct mdoc *mdoc, const char *p)
d279 1
a279 1
	if (MDOC_MAX == (res = mdoc_hash_find(mdoc->htab, p)))
d673 1
a673 1
		if (MDOC_MAX != (c = lookup(m, tok, p))) {
d757 1
a757 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup(m, tok, p);
d936 1
a936 1
		if (MDOC_MAX == (c = lookup(m, tok, p))) {
d999 1
a999 1
		if (MDOC_MAX == (c = lookup(m, tok, p))) {
d1102 1
a1102 1
		if (MDOC_MAX != (c = lookup(m, tok, p))) {
d1213 1
a1213 1
		if (MDOC_MAX != (c = lookup(m, tok, p))) {
d1288 1
a1288 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup(m, tok, p);
d1337 1
a1337 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup_raw(m, p);
@


1.22
log
@sync to 1.9.1: set mdoc_next flags in mdoc_*_alloc routines, where they belong
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.21 2009/08/22 19:43:33 schwarze Exp $ */
d603 1
a603 1
		c = mdoc_args(mdoc, line, pos, buf, 0, &p);
d1329 1
a1329 1
		w = mdoc_zargs(m, line, &pos, buf, &p);
@


1.21
log
@sync to 1.9.0: polishing the core code of mdoc macro handling
1) If a macro is not parsed, do not parse it.  Of course, without
parsing it, we cannot produce "macro-like parameter" warnings,
but these were useless anyway.
2) If a macro is not callable, do not print a useless warning when
it occurs as a parameter, just display the raw characters.
3) Below .Bl -column, check whether macros are callable.
4) Like groff, allow whitespace after the initial dot on macro lines.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.20 2009/08/22 15:36:58 schwarze Exp $ */
d44 4
a47 5
static	int	  rew_impblock(struct mdoc *, int, int, int);
static	int	  rew_expblock(struct mdoc *, int, int, int);
static	int	  rew_subblock(enum mdoc_type, 
			struct mdoc *, int, int, int);
static	int	  rew_last(struct mdoc *, struct mdoc_node *); /* FIXME: make const */
d235 1
a235 1
mdoc_macroend(struct mdoc *mdoc)
d241 1
a241 2
	n = MDOC_VALID & mdoc->last->flags ?
		mdoc->last->parent : mdoc->last;
d248 1
a248 1
		return(mdoc_nerr(mdoc, n, EOPEN));
d251 3
a253 1
	return(rew_last(mdoc, mdoc->first));
d256 4
d270 3
d287 1
a287 1
rew_last(struct mdoc *mdoc, struct mdoc_node *to)
d309 4
a393 1
		assert(MDOC_HEAD != type);
a451 1

d563 1
a563 1
rew_subblock(enum mdoc_type type, struct mdoc *mdoc, 
d570 9
a578 4
	for (n = mdoc->last; n; n = n->parent) {
		c = rew_dohalt(tok, type, n);
		if (REWIND_HALT == c)
			return(1);
d583 1
a583 1
		if ( ! swarn(mdoc, type, line, ppos, n))
d588 1
a588 50
	return(rew_last(mdoc, n));
}


static int
rew_expblock(struct mdoc *mdoc, int tok, int line, int ppos)
{
	struct mdoc_node *n;
	int		  c;

	/* LINTED */
	for (n = mdoc->last; n; n = n->parent) {
		c = rew_dohalt(tok, MDOC_BLOCK, n);
		if (REWIND_HALT == c)
			return(mdoc_perr(mdoc, line, ppos, ENOCTX));
		if (REWIND_REWIND == c)
			break;
		else if (rew_dobreak(tok, n))
			continue;
		if ( ! swarn(mdoc, MDOC_BLOCK, line, ppos, n))
			return(0);
	}

	assert(n);
	return(rew_last(mdoc, n));
}


/* FIXME: can this be merged with subblock? */
static int
rew_impblock(struct mdoc *mdoc, int tok, int line, int ppos)
{
	struct mdoc_node *n;
	int		  c;

	/* LINTED */
	for (n = mdoc->last; n; n = n->parent) {
		c = rew_dohalt(tok, MDOC_BLOCK, n);
		if (REWIND_HALT == c)
			return(1);
		else if (REWIND_REWIND == c)
			break;
		else if (rew_dobreak(tok, n))
			continue;
		if ( ! swarn(mdoc, MDOC_BLOCK, line, ppos, n))
			return(0);
	}

	assert(n);
	return(rew_last(mdoc, n));
a612 1
		mdoc->next = MDOC_NEXT_SIBLING;
d639 1
a639 1
			if ( ! mdoc_pwarn(mdoc, line, ppos, ENOLINE))
d642 1
a642 1
		if ( ! rew_subblock(MDOC_BODY, mdoc, tok, line, ppos))
d644 1
a644 1
		return(rew_expblock(mdoc, tok, line, ppos));
d647 1
a647 1
	if ( ! rew_subblock(MDOC_BODY, mdoc, tok, line, ppos))
d650 2
a651 3
	if (maxargs > 0) {
		if ( ! mdoc_tail_alloc(mdoc, line, 
					ppos, rew_alt(tok)))
a652 2
		mdoc->next = MDOC_NEXT_CHILD;
	}
d658 1
a658 1
			if ( ! rew_expblock(mdoc, tok, line, ppos))
d663 1
a663 1
		c = mdoc_args(mdoc, line, pos, buf, tok, &p);
d672 1
a672 1
		if (MDOC_MAX != (c = lookup(mdoc, tok, p))) {
d674 1
a674 2
				if ( ! rew_expblock(mdoc, tok, 
							line, ppos))
d678 1
a678 1
			if ( ! mdoc_macro(mdoc, c, line, lastarg, pos, buf))
d683 1
a683 1
		if ( ! mdoc_word_alloc(mdoc, line, lastarg, p))
a684 1
		mdoc->next = MDOC_NEXT_SIBLING;
d687 1
a687 1
	if ( ! flushed && ! rew_expblock(mdoc, tok, line, ppos))
d692 1
a692 1
	return(append_delims(mdoc, line, pos, buf));
a695 3
/*
 * In-line macros where reserved words cause scope close-reopen.
 */
d728 1
a728 1
		c = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
d745 1
a745 1
		w = mdoc_args(mdoc, line, pos, buf, tok, &p);
d756 1
a756 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup(mdoc, tok, p);
d766 1
a766 1
			if (0 == lastpunct && ! rew_elem(mdoc, tok))
d769 1
a769 2
				if ( ! mdoc_elem_alloc(mdoc, line, ppos, 
							tok, arg))
d771 1
a771 1
				if ( ! rew_last(mdoc, mdoc->last))
d775 1
a775 1
				if ( ! mdoc_pwarn(mdoc, line, ppos, EIGNE))
d778 1
a778 1
			c = mdoc_macro(mdoc, c, line, la, pos, buf);
d783 1
a783 1
			return(append_delims(mdoc, line, pos, buf));
d795 1
a795 1
			if (0 == lastpunct && ! rew_elem(mdoc, tok))
d799 1
a799 2
			c = mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
			if (0 == c)
a800 1
			mdoc->next = MDOC_NEXT_CHILD;
d806 1
a806 1
		if ( ! mdoc_word_alloc(mdoc, line, la, p))
a807 1
		mdoc->next = MDOC_NEXT_SIBLING;
d810 1
a810 1
	if (0 == lastpunct && ! rew_elem(mdoc, tok))
d820 1
a820 2
		c = mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
		if (0 == c)
d822 1
a822 1
		if ( ! rew_last(mdoc, mdoc->last))
d826 1
a826 1
		if ( ! mdoc_pwarn(mdoc, line, ppos, EIGNE))
d832 1
a832 1
	return(append_delims(mdoc, line, pos, buf));
a835 3
/*
 * Block full-explicit and full-implicit.
 */
d860 1
a860 2
		if ( ! rew_subblock(MDOC_BODY, mdoc, 
					tok, line, ppos))
d862 1
a862 1
		if ( ! rew_impblock(mdoc, tok, line, ppos))
d868 1
a868 1
		c = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
d884 1
a884 1
	if ( ! mdoc_block_alloc(mdoc, line, ppos, tok, arg))
a885 1
	mdoc->next = MDOC_NEXT_CHILD;
d888 1
a888 1
		if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
d890 1
a890 2
		if ( ! rew_subblock(MDOC_HEAD, mdoc, 
					tok, line, ppos))
d892 1
a892 1
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
a893 1
		mdoc->next = MDOC_NEXT_CHILD;
d897 1
a897 1
	if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
d903 1
a903 1
		if ( ! rew_subblock(MDOC_HEAD, mdoc, tok, line, ppos))
d905 1
a905 1
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
a908 2
	mdoc->next = MDOC_NEXT_CHILD;

d911 1
a911 1
		c = mdoc_args(mdoc, line, pos, buf, tok, &p);
d919 1
a919 2
			if (reopen && ! mdoc_head_alloc
					(mdoc, line, ppos, tok))
a920 1
			mdoc->next = MDOC_NEXT_CHILD;
d926 1
a926 1
			if ( ! phrase(mdoc, line, lastarg, buf))
d928 1
a928 2
			if ( ! rew_subblock(MDOC_HEAD, mdoc, 
						tok, line, ppos))
d935 2
a936 2
		if (MDOC_MAX == (c = lookup(mdoc, tok, p))) {
			if ( ! mdoc_word_alloc(mdoc, line, lastarg, p))
a937 1
			mdoc->next = MDOC_NEXT_SIBLING;
d941 1
a941 1
		if ( ! mdoc_macro(mdoc, c, line, lastarg, pos, buf))
d946 1
a946 1
	if (1 == ppos && ! append_delims(mdoc, line, pos, buf))
d953 1
a953 1
	if ( ! rew_subblock(MDOC_HEAD, mdoc, tok, line, ppos))
d955 1
a955 1
	if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
a956 1
	mdoc->next = MDOC_NEXT_CHILD;
a961 3
/*
 * Block partial-imnplicit scope.
 */
d965 1
a965 1
	int		  lastarg, c;
d969 7
a975 1
	if ( ! mdoc_block_alloc(mdoc, line, ppos, tok, NULL))
d977 1
a977 4
	mdoc->next = MDOC_NEXT_CHILD;
	blk = mdoc->last;

	if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
d979 1
a979 3
	mdoc->next = MDOC_NEXT_SIBLING;

	if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
d981 2
a982 2
	mdoc->next = MDOC_NEXT_CHILD;
	body = mdoc->last;
d984 1
a984 1
	/* XXX - no known argument macros. */
d987 2
a988 2
		lastarg = *pos;
		c = mdoc_args(mdoc, line, pos, buf, tok, &p);
d998 2
a999 2
		if (MDOC_MAX == (c = lookup(mdoc, tok, p))) {
			if ( ! mdoc_word_alloc(mdoc, line, lastarg, p))
a1000 1
			mdoc->next = MDOC_NEXT_SIBLING;
d1004 1
a1004 1
		if ( ! mdoc_macro(mdoc, c, line, lastarg, pos, buf))
d1009 5
a1013 4
	/*
	 * Since we know what our context is, we can rewind directly to
	 * it.  This allows us to accomodate for our scope being
	 * violated by another token.
d1015 1
a1015 2

	for (n = mdoc->last; n; n = n->parent)
d1018 4
d1023 1
a1023 2
	if (NULL == n && ! mdoc_nwarn(mdoc, body, EIMPBRK))
			return(0);
d1025 1
a1025 1
	if (n && ! rew_last(mdoc, body))
d1028 1
a1028 2
	if (1 == ppos && ! append_delims(mdoc, line, pos, buf))
		return(0);
d1030 1
a1030 1
	if (n && ! rew_last(mdoc, blk))
a1036 3
/*
 * Block partial-explicit macros.
 */
d1040 1
a1040 1
	int		  lastarg, flushed, j, c, maxargs;
d1043 1
a1043 5
	flushed = 0;

	/*
	 * Number of arguments (head arguments).  Only `Eo' has these,
	 */
d1054 3
a1056 1
	if ( ! mdoc_block_alloc(mdoc, line, ppos, tok, NULL))
d1058 6
a1063 1
	mdoc->next = MDOC_NEXT_CHILD;
d1066 1
a1066 1
		if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
d1068 1
a1068 2
		if ( ! rew_subblock(MDOC_HEAD, mdoc, 
					tok, line, ppos))
d1070 1
a1070 1
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
d1073 5
a1077 2
	} else if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
		return(0);
d1079 1
a1079 1
	mdoc->next = MDOC_NEXT_CHILD;
d1082 1
a1082 1
		lastarg = *pos;
d1084 1
a1084 2
			if ( ! rew_subblock(MDOC_HEAD, mdoc, 
						tok, line, ppos))
d1087 1
a1087 1
			if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
a1088 1
			mdoc->next = MDOC_NEXT_CHILD;
d1091 1
a1091 1
		c = mdoc_args(mdoc, line, pos, buf, tok, &p);
d1101 1
a1101 1
		if (MDOC_MAX != (c = lookup(mdoc, tok, p))) {
d1103 1
a1103 2
				if ( ! rew_subblock(MDOC_HEAD, mdoc, 
							tok, line, ppos))
d1106 1
a1106 2
				if ( ! mdoc_body_alloc(mdoc, line, 
							ppos, tok))
a1107 1
				mdoc->next = MDOC_NEXT_CHILD;
d1109 1
a1109 2
			if ( ! mdoc_macro(mdoc, c, line, lastarg, 
						pos, buf))
d1115 1
a1115 2
			if ( ! rew_subblock(MDOC_HEAD, mdoc, 
						tok, line, ppos))
d1118 1
a1118 1
			if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
a1119 1
			mdoc->next = MDOC_NEXT_CHILD;
d1122 1
a1122 1
		if ( ! mdoc_word_alloc(mdoc, line, lastarg, p))
a1123 1
		mdoc->next = MDOC_NEXT_SIBLING;
d1126 2
d1129 1
a1129 1
		if ( ! rew_subblock(MDOC_HEAD, mdoc, tok, line, ppos))
d1131 1
a1131 1
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
a1132 1
		mdoc->next = MDOC_NEXT_CHILD;
d1135 2
d1139 1
a1139 1
	return(append_delims(mdoc, line, pos, buf));
a1142 4
/*
 * In-line macros where reserved words signal closure of the macro.
 * Macros also have a fixed number of arguments.
 */
d1146 1
a1146 1
	int		  lastarg, flushed, j, c, maxargs;
d1150 1
a1150 5
	
	/* 
	 * Fixed maximum arguments per macro.  Some of these have none
	 * and close as soon as the invocation is parsed.
	 */
d1167 2
d1170 2
a1171 2
		lastarg = *pos;
		c = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
d1174 1
a1174 1
			*pos = lastarg;
d1187 3
a1189 1
	if ( ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
d1191 2
a1192 1
	mdoc->next = MDOC_NEXT_CHILD;
d1195 1
a1195 1
		lastarg = *pos;
d1198 1
a1198 1
			if ( ! rew_elem(mdoc, tok))
d1203 1
a1203 1
		c = mdoc_args(mdoc, line, pos, buf, tok, &p);
d1212 2
a1213 2
		if (MDOC_MAX != (c = lookup(mdoc, tok, p))) {
			if ( ! flushed && ! rew_elem(mdoc, tok))
d1216 1
a1216 1
			if ( ! mdoc_macro(mdoc, c, line, lastarg, pos, buf))
d1223 1
a1223 1
			if ( ! rew_elem(mdoc, tok))
d1228 1
a1228 1
		if ( ! mdoc_word_alloc(mdoc, line, lastarg, p))
a1229 1
		mdoc->next = MDOC_NEXT_SIBLING;
d1232 3
a1234 1
	if ( ! flushed && ! rew_elem(mdoc, tok))
d1239 1
a1239 1
	return(append_delims(mdoc, line, pos, buf));
a1242 4
/*
 * In-line macro that spans an entire line.  May be callable, but has no
 * subsequent parsed arguments.
 */
d1252 1
a1252 1
	arg = NULL;
d1254 1
a1254 1
	for (;;) {
d1256 1
a1256 1
		c = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
d1271 3
a1273 1
	if ( ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
d1276 1
a1276 1
	mdoc->next = MDOC_NEXT_CHILD;
d1280 1
a1280 1
		w = mdoc_args(mdoc, line, pos, buf, tok, &p);
d1287 1
a1287 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup(mdoc, tok, p);
d1290 1
a1290 1
			if ( ! rew_elem(mdoc, tok))
d1292 1
a1292 1
			return(mdoc_macro(mdoc, c, line, la, pos, buf));
d1295 1
a1295 1
		if ( ! mdoc_word_alloc(mdoc, line, la, p))
a1296 1
		mdoc->next = MDOC_NEXT_SIBLING;
d1299 3
a1301 1
	return(rew_elem(mdoc, tok));
d1310 1
a1310 1
	return(mdoc_pwarn(mdoc, line, ppos, EOBS));
d1320 1
a1320 1
phrase(struct mdoc *mdoc, int line, int ppos, char *buf)
d1329 1
a1329 1
		w = mdoc_zargs(mdoc, line, &pos, buf, &p);
d1336 1
a1336 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup_raw(mdoc, p);
d1339 1
a1339 1
			if ( ! mdoc_macro(mdoc, c, line, la, &pos, buf))
d1341 1
a1341 1
			return(append_delims(mdoc, line, &pos, buf));
d1344 1
a1344 1
		if ( ! mdoc_word_alloc(mdoc, line, la, p))
a1345 1
		mdoc->next = MDOC_NEXT_SIBLING;
@


1.20
log
@sync to 1.8.4: LLVM findings from <uqs at spoerlein dot net>
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.19 2009/08/09 21:59:41 schwarze Exp $ */
d48 1
a48 1
static	int	  rew_last(struct mdoc *, struct mdoc_node *);
d50 2
a51 1
static	int	  lookup(struct mdoc *, int, int, int, const char *);
d257 11
a267 1
lookup(struct mdoc *mdoc, int line, int pos, int from, const char *p)
d271 3
a273 4
	res = mdoc_hash_find(mdoc->htab, p);
	if (MDOC_PARSED & mdoc_macros[from].flags)
		return(res);
	if (MDOC_MAX == res)
a274 2
	if ( ! mdoc_pwarn(mdoc, line, pos, EMACPARM))
		return(-1);
d602 1
d711 1
a711 3
		if (-1 == (c = lookup(mdoc, line, lastarg, tok, p)))
			return(0);
		else if (MDOC_MAX != c) {
d800 1
a800 2
		c = ARGS_QWORD == w ? MDOC_MAX :
			lookup(mdoc, line, la, tok, p);
d809 1
a809 1
		if (MDOC_MAX != c && -1 != c) {
d829 1
a829 2
		} else if (-1 == c)
			return(0);
d996 1
a996 4
		if (-1 == (c = lookup(mdoc, line, lastarg, tok, p)))
			return(0);

		if (MDOC_MAX == c) {
d1063 1
a1063 3
		if (-1 == (c = lookup(mdoc, line, lastarg, tok, p)))
			return(0);
		else if (MDOC_MAX == c) {
d1165 1
a1165 3
		if (-1 == (c = lookup(mdoc, line, lastarg, tok, p)))
			return(0);
		else if (MDOC_MAX != c) {
d1283 1
a1283 3
		if (-1 == (c = lookup(mdoc, line, lastarg, tok, p)))
			return(0);
		else if (MDOC_MAX != c) {
d1359 1
a1359 2
		c = ARGS_QWORD == w ? MDOC_MAX :
			lookup(mdoc, line, la, tok, p);
d1361 1
a1361 1
		if (MDOC_MAX != c && -1 != c) {
d1365 1
a1365 2
		} else if (-1 == c)
			return(0);
d1407 1
a1407 2
		c = ARGS_QWORD == w ? MDOC_MAX :
			mdoc_hash_find(mdoc->htab, p);
d1409 1
a1409 1
		if (MDOC_MAX != c && -1 != c) {
d1413 1
a1413 2
		} else if (-1 == c)
			return(0);
@


1.19
log
@sync to 1.8.4: full .An -[no]split support
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.18 2009/08/09 19:59:13 schwarze Exp $ */
d684 1
a684 1
	for (lastarg = ppos, flushed = j = 0; ; j++) {
d763 1
a763 1
	for (la = ppos, arg = NULL;; ) {
d1049 1
a1049 1
	for (lastarg = ppos;; ) {
a1109 1
	lastarg = ppos;
d1245 1
a1245 1
	for (lastarg = ppos, arg = NULL;; ) {
@


1.18
log
@sync to 1.8.3: .Pa without arguments is a synonym for .Pa ~
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.17 2009/08/09 17:13:00 schwarze Exp $ */
d745 3
a747 1
	case (MDOC_Nm):
d753 2
a755 2
		/* FALLTHROUGH */
	case (MDOC_Ar):
@


1.17
log
@sync to 1.8.2: fix and cleanup .Bl -column phrase handling
by using the normal argument parsing from mdoc_argv.c
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.16 2009/08/09 17:02:46 schwarze Exp $ */
d750 2
@


1.16
log
@sync to 1.8.2: use in_line_eoln instead of in_line for .Pp and .Lp
no functional change, but shorter code
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.15 2009/08/09 16:36:45 schwarze Exp $ */
d1388 5
d1396 2
a1397 1
	int		 i, la, c, quoted;
d1399 2
a1400 7
	/*
	 * Parse over words in a phrase.  We have to handle this
	 * specially because we assume no calling context -- in normal
	 * circumstances, we switch argument parsing based on whether
	 * the parent macro accepts quotes, tabs, etc.  Here, anything
	 * goes.
	 */
d1402 2
a1403 4
	for (i = ppos; buf[i]; ) {
		assert(' ' != buf[i]);
		la = i;
		quoted = 0;
d1405 4
a1408 5
		/* 
		 * Read to next token.  If quoted (check not escaped),
		 * scan ahead to next unescaped quote.  If not quoted or
		 * escape-quoted, then scan ahead to next space.
		 */
d1410 2
a1411 19
		if ((i && '\"' == buf[i] && '\\' != buf[i - 1]) || 
				(0 == i && '\"' == buf[i])) {
			for (la = ++i; buf[i]; i++) 
				if ('\"' != buf[i])
					continue;
				else if ('\\' != buf[i - 1])
					break;
			if (0 == buf[i]) 
				return(mdoc_perr(mdoc, line, la, EQUOTPHR));
			quoted = 1;
		} else
			for ( ; buf[i]; i++)
				if (i && ' ' == buf[i]) {
					if ('\\' != buf[i - 1])
						break;
				} else if (' ' == buf[i])
					break;

		/* If not end-of-line, terminate argument. */
d1413 2
a1414 18
		if (buf[i])
			buf[i++] = 0;

		/* Read to next argument. */

		for ( ; buf[i] && ' ' == buf[i]; i++)
			/* Spin. */ ;

		/* 
		 * If we're a non-quoted string, try to look up the
		 * value as a macro and execute it, if found.
		 */

		c = quoted ? MDOC_MAX :
			mdoc_hash_find(mdoc->htab, &buf[la]);

		if (MDOC_MAX != c) {
			if ( ! mdoc_macro(mdoc, c, line, la, &i, buf))
d1416 3
a1418 2
			return(append_delims(mdoc, line, &i, buf));
		}
d1420 1
a1420 3
		/* A regular word or quoted string. */

		if ( ! mdoc_word_alloc(mdoc, line, la, &buf[la]))
d1427 2
@


1.15
log
@sync to 1.8.1: make .Cd parsed
kristaps@@ says many SYNOPSIS sections use this; my impression is
that's not in OpenBSD, but it won't do much harm here, either
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.14 2009/07/26 23:48:01 schwarze Exp $ */
d63 1
a63 1
	{ in_line, 0 }, /* Pp */ 
d164 1
a164 1
	{ in_line, 0 }, /* Lp */ 
a744 4
	case (MDOC_Lp):
		/* FALLTHROUGH */
	case (MDOC_Pp):
		/* FALLTHROUGH */
@


1.14
log
@sync to 1.8.1: explicit-close macros now only warn when encountering
trailing terms and do not error out any more, try:  .Ed foo
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.13 2009/07/26 01:59:46 schwarze Exp $ */
d74 1
a74 1
	{ in_line_eoln, MDOC_CALLABLE }, /* Cd */
@


1.13
log
@sync to 1.8.1: support .br and .sp
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.12 2009/07/18 15:34:27 schwarze Exp $ */
d665 2
a666 3
		if (0 == buf[*pos]) {
			if ( ! rew_subblock(MDOC_BODY, mdoc, 
						tok, line, ppos))
d668 4
a671 3
			return(rew_expblock(mdoc, tok, line, ppos));
		}
		return(mdoc_perr(mdoc, line, ppos, ENOLINE));
@


1.12
log
@sync to 1.8.0: .Nd is now a BFI, was an ELEM,
and use \(en instead of \- for .Nd
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.11 2009/07/12 23:19:48 schwarze Exp $ */
d175 2
@


1.11
log
@sync to 1.7.24: make .In handling more similar to new groff
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.10 2009/07/12 22:35:08 schwarze Exp $ */
d88 1
a88 1
	{ in_line_eoln, 0 }, /* Nd */ 
d389 2
d496 2
d501 2
d884 1
a884 1
	int		  c, lastarg, reopen;
d888 16
d948 10
d969 1
d1006 5
a1012 1

@


1.10
log
@sync to 1.7.23: pass warning code to mdoc_pwarn() instead of warning message
define additional warning macro mdoc_nwarn()
remove obsolete warning functions mdoc_warn(), pwarn(), vwarn(), nwarn()
remove various now unused "enum mdoc_warn" and "enum mwarn"
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.9 2009/07/12 21:45:44 schwarze Exp $ */
d86 1
a86 1
	{ in_line_eoln, 0 }, /* In */  /* FIXME: historic usage! */
@


1.9
log
@sync to 1.7.23: pass error code to mdoc_perr() instead of error string
and use the so improved mdoc_nerr() at many places;
get rid of now unused static functions perr()
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.8 2009/07/12 21:08:29 schwarze Exp $ */
a24 7
enum	mwarn {
	WIGNE,
	WIMPBRK,
	WMACPARM,
	WOBS
};

a50 1
static	int	  pwarn(struct mdoc *, int, int, enum mwarn);
a180 25
pwarn(struct mdoc *mdoc, int line, int pos, enum mwarn type)
{
	char		*p;

	p = NULL;
	switch (type) {
	case (WIGNE):
		p = "ignoring empty element";
		break;
	case (WIMPBRK):
		p = "crufty end-of-line scope violation";
		break;
	case (WMACPARM):
		p = "macro-like parameter";
		break;
	case (WOBS):
		p = "macro marked obsolete";
		break;
	}
	assert(p);
	return(mdoc_pwarn(mdoc, line, pos, WARN_SYNTAX, p));
}


static int
d263 1
a263 1
	if ( ! pwarn(mdoc, line, pos, WMACPARM))
d806 1
a806 1
				if ( ! pwarn(mdoc, line, ppos, WIGNE))
d862 1
a862 1
		if ( ! pwarn(mdoc, line, ppos, WIGNE))
d1046 1
a1046 1
	if (NULL == n && ! pwarn(mdoc, body->line, body->pos, WIMPBRK))
d1349 1
a1349 1
	return(pwarn(mdoc, line, ppos, WOBS));
@


1.8
log
@sync to 1.7.23: pass error code to mdoc_nerr() instead of error string
and use the so improved mdoc_nerr() at many places
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.7 2009/07/12 20:30:27 schwarze Exp $ */
a58 1
static	int	  perr(struct mdoc *, int, int, enum merr);
a61 2
#define	nerr(m, n, t) perr((m), (n)->line, (n)->pos, (t))

a188 25
perr(struct mdoc *mdoc, int line, int pos, enum merr type)
{
	char		*p;

	p = NULL;
	switch (type) {
	case (EOPEN):
		p = "explicit scope still open on exit";
		break;
	case (EQUOTPHR):
		p = "unterminated quotation";
		break;
	case (ENOCTX):
		p = "closure has no prior context";
		break;
	case (ENOLINE):
		p = "unexpect line arguments";
		break;
	}
	assert(p);
	return(mdoc_perr(mdoc, line, pos, p));
}


static int
d605 1
a605 1
			return(perr(mdoc, line, ppos, ENOCTX));
d696 1
a696 1
		return(perr(mdoc, line, ppos, ENOLINE));
d1418 1
a1418 1
				return(perr(mdoc, line, la, EQUOTPHR));
@


1.7
log
@sync to 1.7.23: unify the various "enum merr" into libman.h and libmdoc.h,
use it as a new argument to mdoc_err(), the same way as for for man_err(),
and use string tables instead of switch statements to select error messages
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.6 2009/07/12 19:05:52 schwarze Exp $ */
d308 1
a308 1
		return(nerr(mdoc, n, EOPEN));
@


1.6
log
@sync to 1.7.23: third step to get rid of enum mdoc_warn:
mdoc_verr is not using enum mdoc_warn, so use it at a few more places
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.5 2009/07/12 18:35:57 schwarze Exp $ */
a31 7
enum	merr {
	EOPEN,
	EQUOT,
	ENOCTX,
	ENOPARMS
};

d201 1
a201 1
	case (EQUOT):
d207 1
a207 1
	case (ENOPARMS):
d724 1
a724 1
		return(perr(mdoc, line, ppos, ENOPARMS));
d1446 1
a1446 1
				return(perr(mdoc, line, la, EQUOT));
@


1.5
log
@sync to 1.7.23: second step to get rid of enum mdoc_warn:
remove type from mdoc_vwarn arguments, and use this function where apropriate
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.4 2009/06/18 23:34:53 schwarze Exp $ */
d286 1
a286 1
		return(mdoc_perr(mdoc, line, pos, 
@


1.4
log
@sync to 1.7.19: improved comment handling
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.3 2009/06/18 01:19:02 schwarze Exp $ */
d289 1
a289 1
	return(mdoc_pwarn(mdoc, line, pos, WARN_SYNTAX,
@


1.3
log
@sync to 1.7.16: make a couple of macros callable, reserve "|",
and some tweaks to .Lk
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.2 2009/06/14 23:00:57 schwarze Exp $ */
a24 2
/* FIXME: .Fl, .Ar, .Cd handling of `|'. */

d75 1
a75 1
	{ NULL, 0 }, /* \" */
a181 1
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Ap */
@


1.2
log
@sync to 1.7.16: comments, whitespace and spelling fixes; no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.12 2009/06/12 09:18:00 kristaps Exp $ */
d92 1
a92 1
	{ in_line, MDOC_PARSED }, /* An */
d104 1
a104 1
	{ in_line, MDOC_PARSED }, /* Ft */ 
d106 1
a106 1
	{ in_line_eoln, 0 }, /* In */ 
d148 1
a148 1
	{ in_line, MDOC_PARSED }, /* Ms */
d186 2
a187 2
	{ in_line, MDOC_PARSED }, /* Lk */ 
	{ in_line, MDOC_PARSED }, /* Mt */ 
d816 2
d873 2
a874 1
				mdoc->next = MDOC_NEXT_SIBLING;
d929 3
a931 2
		mdoc->next = MDOC_NEXT_SIBLING;
	} else if ( ! nc && 0 == cnt)  {
@


1.1
log
@Initial check-in of mandoc for formatting manuals. ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: mdoc_macro.c,v 1.6 2009/04/02 06:51:44 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@

