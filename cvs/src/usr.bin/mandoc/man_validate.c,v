head	1.100;
access;
symbols
	OPENBSD_6_1:1.93.0.8
	OPENBSD_6_1_BASE:1.93
	OPENBSD_6_0:1.93.0.4
	OPENBSD_6_0_BASE:1.93
	OPENBSD_5_9:1.93.0.2
	OPENBSD_5_9_BASE:1.93
	OPENBSD_5_8:1.90.0.4
	OPENBSD_5_8_BASE:1.90
	OPENBSD_5_7:1.84.0.2
	OPENBSD_5_7_BASE:1.84
	OPENBSD_5_6:1.72.0.4
	OPENBSD_5_6_BASE:1.72
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.57.0.4
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.57.0.2
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.55.0.2
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.2
	OPENBSD_5_0:1.46.0.2
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.100
date	2017.06.17.16.47.29;	author schwarze;	state Exp;
branches;
next	1.99;
commitid	rtJwCLiPQFALK2LD;

1.99
date	2017.06.11.19.36.31;	author schwarze;	state Exp;
branches;
next	1.98;
commitid	XRYVv5vPYVYMmfcL;

1.98
date	2017.05.05.15.16.25;	author schwarze;	state Exp;
branches;
next	1.97;
commitid	sNJdFUhzoVfGBx2p;

1.97
date	2017.05.05.13.17.04;	author schwarze;	state Exp;
branches;
next	1.96;
commitid	GvSRKa33jIoa4JAJ;

1.96
date	2017.05.05.02.06.17;	author schwarze;	state Exp;
branches;
next	1.95;
commitid	JMX1RJlA2uFuu13l;

1.95
date	2017.05.04.17.48.24;	author schwarze;	state Exp;
branches;
next	1.94;
commitid	RHQLdCAdHKxKe8Eu;

1.94
date	2017.04.24.23.06.09;	author schwarze;	state Exp;
branches;
next	1.93;
commitid	2CfzvK3gmiJH7vY0;

1.93
date	2016.01.08.17.48.04;	author schwarze;	state Exp;
branches;
next	1.92;
commitid	DoGoemryKYV644MI;

1.92
date	2015.10.22.21.53.49;	author schwarze;	state Exp;
branches;
next	1.91;
commitid	b31415iHGGouYvkz;

1.91
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.90;
commitid	Ql2ha5NS80pwfGNT;

1.90
date	2015.04.19.13.59.37;	author schwarze;	state Exp;
branches;
next	1.89;
commitid	aS3h5dIgZk0f7675;

1.89
date	2015.04.19.13.50.10;	author schwarze;	state Exp;
branches;
next	1.88;
commitid	QSaLMe5iBgPB4hUe;

1.88
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.87;
commitid	6MYJ7cd8mhJ77AGH;

1.87
date	2015.04.02.23.47.43;	author schwarze;	state Exp;
branches;
next	1.86;
commitid	RJFkOLiS9gBqEEDl;

1.86
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.85;
commitid	Rfx1oTaH3hZ7Zcyf;

1.85
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.84;
commitid	lmErjWY2O9ooA6RY;

1.84
date	2015.02.06.11.54.03;	author schwarze;	state Exp;
branches;
next	1.83;
commitid	Wgxy0y7jtcdh0XG7;

1.83
date	2015.02.06.09.38.22;	author schwarze;	state Exp;
branches;
next	1.82;
commitid	65G1InTyXwfiALBj;

1.82
date	2015.02.06.08.28.03;	author schwarze;	state Exp;
branches;
next	1.81;
commitid	2ZNpc6PO2F2KjxAt;

1.81
date	2015.02.06.07.12.34;	author schwarze;	state Exp;
branches;
next	1.80;
commitid	QDbepmLqTNee3zgJ;

1.80
date	2015.01.24.02.41.32;	author schwarze;	state Exp;
branches;
next	1.79;
commitid	TIJT04XdY4be3Or5;

1.79
date	2014.12.28.14.39.08;	author schwarze;	state Exp;
branches;
next	1.78;
commitid	6ZLiZAxCS3hyLbh4;

1.78
date	2014.11.28.05.51.29;	author schwarze;	state Exp;
branches;
next	1.77;
commitid	9LYX9vvoCC2fp5xR;

1.77
date	2014.08.08.16.17.09;	author schwarze;	state Exp;
branches;
next	1.76;
commitid	TLMAnDXVMoqLltgG;

1.76
date	2014.08.08.16.05.42;	author schwarze;	state Exp;
branches;
next	1.75;
commitid	2htU5KIJbrO78Dan;

1.75
date	2014.08.08.15.57.05;	author schwarze;	state Exp;
branches;
next	1.74;
commitid	kusPy8TfXLTHQJo8;

1.74
date	2014.08.08.15.54.10;	author schwarze;	state Exp;
branches;
next	1.73;
commitid	yBKHNskikm52fHMo;

1.73
date	2014.08.08.15.35.31;	author schwarze;	state Exp;
branches;
next	1.72;
commitid	Xw77omN2gPvZJf21;

1.72
date	2014.07.07.21.35.42;	author schwarze;	state Exp;
branches;
next	1.71;
commitid	O2S43bw50KTGcriR;

1.71
date	2014.07.06.19.08.56;	author schwarze;	state Exp;
branches;
next	1.70;
commitid	rolX8OitNNoUBJoD;

1.70
date	2014.07.05.12.33.54;	author schwarze;	state Exp;
branches;
next	1.69;
commitid	IbTbYyU1XoSImvHA;

1.69
date	2014.07.04.16.11.41;	author schwarze;	state Exp;
branches;
next	1.68;
commitid	sgqZ9hnRM3L6yvgn;

1.68
date	2014.07.02.11.42.56;	author schwarze;	state Exp;
branches;
next	1.67;
commitid	aUdrdtDM8sKwymS7;

1.67
date	2014.07.02.05.51.49;	author schwarze;	state Exp;
branches;
next	1.66;
commitid	fKiFNFn6PyMDO56P;

1.66
date	2014.07.01.22.36.35;	author schwarze;	state Exp;
branches;
next	1.65;
commitid	6SNWblzmBTWk9YRA;

1.65
date	2014.06.20.22.58.41;	author schwarze;	state Exp;
branches;
next	1.64;
commitid	ktgkM223FL3EC6E8;

1.64
date	2014.06.20.17.23.09;	author schwarze;	state Exp;
branches;
next	1.63;
commitid	gTaF7NL9JpgvI2ni;

1.63
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2014.03.30.19.47.32;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2014.03.21.22.17.01;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2014.01.06.22.39.19;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2013.12.31.18.07.06;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2013.10.17.20.51.31;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2012.11.17.00.25.20;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2012.07.29.12.35.05;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2012.07.18.16.51.50;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2012.07.18.16.40.50;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2012.06.02.20.07.09;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2012.02.26.19.41.27;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2011.12.02.01.45.43;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2011.11.05.16.02.18;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2011.11.03.20.46.40;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2011.10.16.12.18.32;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2011.09.18.15.54.48;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2011.07.07.20.07.38;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2011.05.29.21.22.18;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2011.04.21.22.59.54;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2011.03.20.23.36.42;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2011.03.07.01.35.33;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2011.01.17.00.15.19;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2011.01.16.19.27.25;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2010.12.19.07.53.12;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2010.12.07.00.08.52;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2010.12.06.23.03.56;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2010.12.01.23.02.59;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2010.11.29.02.26.45;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2010.11.29.00.12.02;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2010.10.27.10.17.45;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2010.10.15.20.45.03;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2010.08.20.00.53.35;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2010.07.25.18.05.54;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.26.17.56.43;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2010.05.26.02.39.58;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.23.22.45.00;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2010.05.23.20.57.16;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2010.05.20.00.58.02;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.16.00.54.03;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.15.18.06.03;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2010.05.13.20.34.29;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.25.16.32.19;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.07.23.15.05;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.03.16.33.01;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.02.11.37.07;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2010.03.29.22.56.52;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2010.03.26.01.22.05;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2010.03.02.01.00.39;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.26.12.42.29;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.21.40.07;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.21.19.13.50;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.18.22.46.14;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.22.23.17.40;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2009.08.22.20.14.37;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.22.15.15.37;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.08.00.04.10;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.23.22.31.26;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.18.23.34.53;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.14.23.00.57;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.20.30.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.100
log
@if .in is used inside the .TP head, it's always relative
@
text
@/*	$OpenBSD: man_validate.c,v 1.99 2017/06/11 19:36:31 schwarze Exp $ */
/*
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010, 2012-2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "man.h"
#include "libmandoc.h"
#include "roff_int.h"
#include "libman.h"

#define	CHKARGS	  struct roff_man *man, struct roff_node *n

typedef	void	(*v_check)(CHKARGS);

static	void	  check_par(CHKARGS);
static	void	  check_part(CHKARGS);
static	void	  check_root(CHKARGS);
static	void	  check_text(CHKARGS);

static	void	  post_AT(CHKARGS);
static	void	  post_IP(CHKARGS);
static	void	  post_OP(CHKARGS);
static	void	  post_TH(CHKARGS);
static	void	  post_UC(CHKARGS);
static	void	  post_UR(CHKARGS);
static	void	  post_in(CHKARGS);
static	void	  post_vs(CHKARGS);

static	const v_check __man_valids[MAN_MAX - MAN_TH] = {
	post_TH,    /* TH */
	NULL,       /* SH */
	NULL,       /* SS */
	NULL,       /* TP */
	check_par,  /* LP */
	check_par,  /* PP */
	check_par,  /* P */
	post_IP,    /* IP */
	NULL,       /* HP */
	NULL,       /* SM */
	NULL,       /* SB */
	NULL,       /* BI */
	NULL,       /* IB */
	NULL,       /* BR */
	NULL,       /* RB */
	NULL,       /* R */
	NULL,       /* B */
	NULL,       /* I */
	NULL,       /* IR */
	NULL,       /* RI */
	NULL,       /* nf */
	NULL,       /* fi */
	NULL,       /* RE */
	check_part, /* RS */
	NULL,       /* DT */
	post_UC,    /* UC */
	NULL,       /* PD */
	post_AT,    /* AT */
	post_in,    /* in */
	post_OP,    /* OP */
	NULL,       /* EX */
	NULL,       /* EE */
	post_UR,    /* UR */
	NULL,       /* UE */
};
static	const v_check *man_valids = __man_valids - MAN_TH;


void
man_node_validate(struct roff_man *man)
{
	struct roff_node *n;
	const v_check	 *cp;

	n = man->last;
	man->last = man->last->child;
	while (man->last != NULL) {
		man_node_validate(man);
		if (man->last == n)
			man->last = man->last->child;
		else
			man->last = man->last->next;
	}

	man->last = n;
	man->next = ROFF_NEXT_SIBLING;
	switch (n->type) {
	case ROFFT_TEXT:
		check_text(man, n);
		break;
	case ROFFT_ROOT:
		check_root(man, n);
		break;
	case ROFFT_EQN:
	case ROFFT_TBL:
		break;
	default:
		if (n->tok < ROFF_MAX) {
			switch (n->tok) {
			case ROFF_br:
			case ROFF_sp:
				post_vs(man, n);
				break;
			default:
				roff_validate(man);
				break;
			}
			break;
		}
		assert(n->tok >= MAN_TH && n->tok < MAN_MAX);
		cp = man_valids + n->tok;
		if (*cp)
			(*cp)(man, n);
		if (man->last == n)
			man_state(man, n);
		break;
	}
}

static void
check_root(CHKARGS)
{

	assert((man->flags & (MAN_BLINE | MAN_ELINE)) == 0);

	if (NULL == man->first->child)
		mandoc_msg(MANDOCERR_DOC_EMPTY, man->parse,
		    n->line, n->pos, NULL);
	else
		man->meta.hasbody = 1;

	if (NULL == man->meta.title) {
		mandoc_msg(MANDOCERR_TH_NOTITLE, man->parse,
		    n->line, n->pos, NULL);

		/*
		 * If a title hasn't been set, do so now (by
		 * implication, date and section also aren't set).
		 */

		man->meta.title = mandoc_strdup("");
		man->meta.msec = mandoc_strdup("");
		man->meta.date = man->quick ? mandoc_strdup("") :
		    mandoc_normdate(man, NULL, n->line, n->pos);
	}
}

static void
check_text(CHKARGS)
{
	char		*cp, *p;

	if (MAN_LITERAL & man->flags)
		return;

	cp = n->string;
	for (p = cp; NULL != (p = strchr(p, '\t')); p++)
		mandoc_msg(MANDOCERR_FI_TAB, man->parse,
		    n->line, n->pos + (p - cp), NULL);
}

static void
post_OP(CHKARGS)
{

	if (n->child == NULL)
		mandoc_msg(MANDOCERR_OP_EMPTY, man->parse,
		    n->line, n->pos, "OP");
	else if (n->child->next != NULL && n->child->next->next != NULL) {
		n = n->child->next->next;
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, man->parse,
		    n->line, n->pos, "OP ... %s", n->string);
	}
}

static void
post_UR(CHKARGS)
{

	if (n->type == ROFFT_HEAD && n->child == NULL)
		mandoc_vmsg(MANDOCERR_UR_NOHEAD, man->parse,
		    n->line, n->pos, "UR");
	check_part(man, n);
}

static void
check_part(CHKARGS)
{

	if (n->type == ROFFT_BODY && n->child == NULL)
		mandoc_msg(MANDOCERR_BLK_EMPTY, man->parse,
		    n->line, n->pos, roff_name[n->tok]);
}

static void
check_par(CHKARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		if (n->body->child == NULL)
			roff_node_delete(man, n);
		break;
	case ROFFT_BODY:
		if (n->child == NULL)
			mandoc_vmsg(MANDOCERR_PAR_SKIP,
			    man->parse, n->line, n->pos,
			    "%s empty", roff_name[n->tok]);
		break;
	case ROFFT_HEAD:
		if (n->child != NULL)
			mandoc_vmsg(MANDOCERR_ARG_SKIP,
			    man->parse, n->line, n->pos, "%s %s%s",
			    roff_name[n->tok], n->child->string,
			    n->child->next != NULL ? " ..." : "");
		break;
	default:
		break;
	}
}

static void
post_IP(CHKARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		if (n->head->child == NULL && n->body->child == NULL)
			roff_node_delete(man, n);
		break;
	case ROFFT_BODY:
		if (n->parent->head->child == NULL && n->child == NULL)
			mandoc_vmsg(MANDOCERR_PAR_SKIP,
			    man->parse, n->line, n->pos,
			    "%s empty", roff_name[n->tok]);
		break;
	default:
		break;
	}
}

static void
post_TH(CHKARGS)
{
	struct roff_node *nb;
	const char	*p;

	free(man->meta.title);
	free(man->meta.vol);
	free(man->meta.os);
	free(man->meta.msec);
	free(man->meta.date);

	man->meta.title = man->meta.vol = man->meta.date =
	    man->meta.msec = man->meta.os = NULL;

	nb = n;

	/* ->TITLE<- MSEC DATE OS VOL */

	n = n->child;
	if (n && n->string) {
		for (p = n->string; '\0' != *p; p++) {
			/* Only warn about this once... */
			if (isalpha((unsigned char)*p) &&
			    ! isupper((unsigned char)*p)) {
				mandoc_vmsg(MANDOCERR_TITLE_CASE,
				    man->parse, n->line,
				    n->pos + (p - n->string),
				    "TH %s", n->string);
				break;
			}
		}
		man->meta.title = mandoc_strdup(n->string);
	} else {
		man->meta.title = mandoc_strdup("");
		mandoc_msg(MANDOCERR_TH_NOTITLE, man->parse,
		    nb->line, nb->pos, "TH");
	}

	/* TITLE ->MSEC<- DATE OS VOL */

	if (n)
		n = n->next;
	if (n && n->string)
		man->meta.msec = mandoc_strdup(n->string);
	else {
		man->meta.msec = mandoc_strdup("");
		mandoc_vmsg(MANDOCERR_MSEC_MISSING, man->parse,
		    nb->line, nb->pos, "TH %s", man->meta.title);
	}

	/* TITLE MSEC ->DATE<- OS VOL */

	if (n)
		n = n->next;
	if (n && n->string && '\0' != n->string[0]) {
		man->meta.date = man->quick ?
		    mandoc_strdup(n->string) :
		    mandoc_normdate(man, n->string, n->line, n->pos);
	} else {
		man->meta.date = mandoc_strdup("");
		mandoc_msg(MANDOCERR_DATE_MISSING, man->parse,
		    n ? n->line : nb->line,
		    n ? n->pos : nb->pos, "TH");
	}

	/* TITLE MSEC DATE ->OS<- VOL */

	if (n && (n = n->next))
		man->meta.os = mandoc_strdup(n->string);
	else if (man->defos != NULL)
		man->meta.os = mandoc_strdup(man->defos);

	/* TITLE MSEC DATE OS ->VOL<- */
	/* If missing, use the default VOL name for MSEC. */

	if (n && (n = n->next))
		man->meta.vol = mandoc_strdup(n->string);
	else if ('\0' != man->meta.msec[0] &&
	    (NULL != (p = mandoc_a2msec(man->meta.msec))))
		man->meta.vol = mandoc_strdup(p);

	if (n != NULL && (n = n->next) != NULL)
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, man->parse,
		    n->line, n->pos, "TH ... %s", n->string);

	/*
	 * Remove the `TH' node after we've processed it for our
	 * meta-data.
	 */
	roff_node_delete(man, man->last);
}

static void
post_UC(CHKARGS)
{
	static const char * const bsd_versions[] = {
	    "3rd Berkeley Distribution",
	    "4th Berkeley Distribution",
	    "4.2 Berkeley Distribution",
	    "4.3 Berkeley Distribution",
	    "4.4 Berkeley Distribution",
	};

	const char	*p, *s;

	n = n->child;

	if (n == NULL || n->type != ROFFT_TEXT)
		p = bsd_versions[0];
	else {
		s = n->string;
		if (0 == strcmp(s, "3"))
			p = bsd_versions[0];
		else if (0 == strcmp(s, "4"))
			p = bsd_versions[1];
		else if (0 == strcmp(s, "5"))
			p = bsd_versions[2];
		else if (0 == strcmp(s, "6"))
			p = bsd_versions[3];
		else if (0 == strcmp(s, "7"))
			p = bsd_versions[4];
		else
			p = bsd_versions[0];
	}

	free(man->meta.os);
	man->meta.os = mandoc_strdup(p);
}

static void
post_AT(CHKARGS)
{
	static const char * const unix_versions[] = {
	    "7th Edition",
	    "System III",
	    "System V",
	    "System V Release 2",
	};

	struct roff_node *nn;
	const char	*p, *s;

	n = n->child;

	if (n == NULL || n->type != ROFFT_TEXT)
		p = unix_versions[0];
	else {
		s = n->string;
		if (0 == strcmp(s, "3"))
			p = unix_versions[0];
		else if (0 == strcmp(s, "4"))
			p = unix_versions[1];
		else if (0 == strcmp(s, "5")) {
			nn = n->next;
			if (nn != NULL &&
			    nn->type == ROFFT_TEXT &&
			    nn->string[0] != '\0')
				p = unix_versions[3];
			else
				p = unix_versions[2];
		} else
			p = unix_versions[0];
	}

	free(man->meta.os);
	man->meta.os = mandoc_strdup(p);
}

static void
post_in(CHKARGS)
{
	char	*s;

	if (n->parent->tok != MAN_TP ||
	    n->parent->type != ROFFT_HEAD ||
	    n->child == NULL ||
	    *n->child->string == '+' ||
	    *n->child->string == '-')
		return;
	mandoc_asprintf(&s, "+%s", n->child->string);
	free(n->child->string);
	n->child->string = s;
}

static void
post_vs(CHKARGS)
{

	if (NULL != n->prev)
		return;

	switch (n->parent->tok) {
	case MAN_SH:
	case MAN_SS:
	case MAN_PP:
	case MAN_LP:
	case MAN_P:
		mandoc_vmsg(MANDOCERR_PAR_SKIP, man->parse, n->line, n->pos,
		    "%s after %s", roff_name[n->tok],
		    roff_name[n->parent->tok]);
		/* FALLTHROUGH */
	case TOKEN_NONE:
		/*
		 * Don't warn about this because it occurs in pod2man
		 * and would cause considerable (unfixable) warnage.
		 */
		roff_node_delete(man, n);
		break;
	default:
		break;
	}
}
@


1.99
log
@Style message about legacy man(7) date format in mdoc(7) documents
and operating system dependent messages about missing or unexpected
Mdocdate; inspired by mdoclint(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.98 2017/05/05 15:16:25 schwarze Exp $ */
a47 1
static	void	  post_vs(CHKARGS);
d52 2
d84 1
a84 1
	NULL,       /* in */
d434 16
@


1.98
log
@Move .sp to the roff modules.  Enough infrastructure is in place
now that this actually saves code: -70 LOC.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.97 2017/05/05 13:17:04 schwarze Exp $ */
d168 1
a168 1
		    mandoc_normdate(man->parse, NULL, n->line, n->pos);
d324 1
a324 2
		    mandoc_normdate(man->parse, n->string,
			n->line, n->pos);
@


1.97
log
@move .ll to the roff modules
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.96 2017/05/05 02:06:17 schwarze Exp $ */
a74 1
	post_vs,    /* sp */
d125 1
d446 3
@


1.96
log
@Move handling of the roff(7) .ft request from the man(7)
modules to the new roff(7) modules.  As a side effect,
mdoc(7) now handles .ft, too.  Of course, do not use that.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.95 2017/05/04 17:48:24 schwarze Exp $ */
a89 1
	NULL,       /* ll */
@


1.95
log
@Parser reorg:
Generate the first node on the roff level: .br
Fix some column numbers in diagnostic messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.94 2017/04/24 23:06:09 schwarze Exp $ */
a48 1
static	void	  post_ft(CHKARGS);
a84 1
	post_ft,    /* ft */
d130 2
a131 1
				abort();
a208 41
}

static void
post_ft(CHKARGS)
{
	char	*cp;
	int	 ok;

	if (n->child == NULL)
		return;

	ok = 0;
	cp = n->child->string;
	switch (*cp) {
	case '1':
	case '2':
	case '3':
	case '4':
	case 'I':
	case 'P':
	case 'R':
		if ('\0' == cp[1])
			ok = 1;
		break;
	case 'B':
		if ('\0' == cp[1] || ('I' == cp[1] && '\0' == cp[2]))
			ok = 1;
		break;
	case 'C':
		if ('W' == cp[1] && '\0' == cp[2])
			ok = 1;
		break;
	default:
		break;
	}

	if (0 == ok) {
		mandoc_vmsg(MANDOCERR_FT_BAD, man->parse,
		    n->line, n->pos, "ft %s", cp);
		*cp = '\0';
	}
@


1.94
log
@Continue parser unification:
* Make enum rofft an internal interface as enum roff_tok in "roff.h".
* Represent mdoc and man macros in enum roff_tok.
* Make TOKEN_NONE a proper enum value and use it throughout.
* Put the prologue macros first in the macro tables.
* Unify mdoc_macroname[] and man_macroname[] into roff_name[].
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.93 2016/01/08 17:48:04 schwarze Exp $ */
a75 1
	post_vs,    /* br */
d126 11
@


1.93
log
@Delete the redundant "nchild" member of struct roff_node, replacing
most uses by one, a few by two pointer checks, and only one by a
tiny loop - not only making data smaller, but code shorter as well.

This gets rid of an implicit invariant that confused both static
analysis tools and human auditors.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.92 2015/10/22 21:53:49 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012-2016 Ingo Schwarze <schwarze@@openbsd.org>
d55 1
a55 2
static	v_check man_valids[MAN_MAX] = {
	post_vs,    /* br */
d76 1
d95 1
d102 1
a102 1
	v_check		*cp;
d249 1
a249 1
		    n->line, n->pos, man_macronames[n->tok]);
d265 1
a265 1
			    "%s empty", man_macronames[n->tok]);
d270 2
a271 3
			    man->parse, n->line, n->pos,
			    "%s %s%s", man_macronames[n->tok],
			    n->child->string,
d292 1
a292 1
			    "%s empty", man_macronames[n->tok]);
d480 2
a481 2
		    "%s after %s", man_macronames[n->tok],
		    man_macronames[n->parent->tok]);
@


1.92
log
@move man(7) validation into the dedicated validation phase, too
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.91 2015/10/12 00:07:27 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012-2015 Ingo Schwarze <schwarze@@openbsd.org>
d181 1
a181 1
	if (n->nchild == 0)
d184 1
a184 1
	else if (n->nchild > 2) {
d207 1
a207 1
	if (0 == n->nchild)
d257 1
a257 1
		if (0 == n->body->nchild)
d261 1
a261 1
		if (0 == n->nchild)
d267 1
a267 1
		if (n->nchild)
d272 1
a272 1
			    n->nchild > 1 ? " ..." : "");
d285 1
a285 1
		if (0 == n->head->nchild && 0 == n->body->nchild)
d289 1
a289 1
		if (0 == n->parent->head->nchild && 0 == n->nchild)
@


1.91
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.90 2015/04/19 13:59:37 schwarze Exp $ */
a48 1
static	void	  post_fi(CHKARGS);
a49 1
static	void	  post_nf(CHKARGS);
d78 2
a79 2
	post_nf,    /* nf */
	post_fi,    /* fi */
d89 2
a90 2
	post_nf,    /* EX */
	post_fi,    /* EE */
d98 1
a98 1
man_valid_post(struct roff_man *man)
d104 8
a111 3
	if (n->flags & MAN_VALID)
		return;
	n->flags |= MAN_VALID;
d113 2
d129 2
a390 22
}

static void
post_nf(CHKARGS)
{

	if (man->flags & MAN_LITERAL)
		mandoc_msg(MANDOCERR_NF_SKIP, man->parse,
		    n->line, n->pos, "nf");

	man->flags |= MAN_LITERAL;
}

static void
post_fi(CHKARGS)
{

	if ( ! (MAN_LITERAL & man->flags))
		mandoc_msg(MANDOCERR_FI_SKIP, man->parse,
		    n->line, n->pos, "fi");

	man->flags &= ~MAN_LITERAL;
@


1.90
log
@Decouple the token code for "no request or macro" from the individual
high-level parsers to allow further unification of functions that
only need to recognize this code, but that don't care about different
high-level macrosets beyond that.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.89 2015/04/19 13:50:10 schwarze Exp $ */
a117 1
		/* FALLTHROUGH */
a206 1
		/* FALLTHROUGH */
a207 1
		/* FALLTHROUGH */
a208 1
		/* FALLTHROUGH */
a209 1
		/* FALLTHROUGH */
a210 1
		/* FALLTHROUGH */
a211 1
		/* FALLTHROUGH */
a492 1
		/* FALLTHROUGH */
@


1.89
log
@Unify node handling functions:
* node_alloc() for mdoc and man_node_alloc() -> roff_node_alloc()
* node_append() for mdoc and man_node_append() -> roff_node_append()
* mdoc_head_alloc() and man_head_alloc() -> roff_head_alloc()
* mdoc_body_alloc() and man_body_alloc() -> roff_body_alloc()
* mdoc_node_unlink() and man_node_unlink() -> roff_node_unlink()
* mdoc_node_free() and man_node_free() -> roff_node_free()
* mdoc_node_delete() and man_node_delete() -> roff_node_delete()
Minus 130 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.88 2015/04/18 16:04:40 schwarze Exp $ */
d506 1
a506 1
	case MAN_MAX:
@


1.88
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.87 2015/04/02 23:47:43 schwarze Exp $ */
d34 1
d258 1
a258 1
			man_node_delete(man, n);
d286 1
a286 1
			man_node_delete(man, n);
d390 1
a390 1
	man_node_delete(man, man->last);
d511 1
a511 1
		man_node_delete(man, n);
@


1.87
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.86 2015/04/02 22:06:17 schwarze Exp $ */
d36 1
a36 1
#define	CHKARGS	  struct man *man, struct roff_node *n
d99 1
a99 1
man_valid_post(struct man *man)
@


1.86
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.85 2015/04/02 21:03:18 schwarze Exp $ */
d306 1
a306 1
	free(man->meta.source);
d311 1
a311 1
	    man->meta.msec = man->meta.source = NULL;
d315 1
a315 1
	/* ->TITLE<- MSEC DATE SOURCE VOL */
d337 1
a337 1
	/* TITLE ->MSEC<- DATE SOURCE VOL */
d349 1
a349 1
	/* TITLE MSEC ->DATE<- SOURCE VOL */
d365 1
a365 1
	/* TITLE MSEC DATE ->SOURCE<- VOL */
d368 1
a368 1
		man->meta.source = mandoc_strdup(n->string);
d370 1
a370 1
		man->meta.source = mandoc_strdup(man->defos);
d372 1
a372 1
	/* TITLE MSEC DATE SOURCE ->VOL<- */
d447 2
a448 2
	free(man->meta.source);
	man->meta.source = mandoc_strdup(p);
d486 2
a487 2
	free(man->meta.source);
	man->meta.source = mandoc_strdup(p);
@


1.85
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.84 2015/02/06 11:54:03 schwarze Exp $ */
d36 1
a36 1
#define	CHKARGS	  struct man *man, struct man_node *n
d101 1
a101 1
	struct man_node	*n;
d301 1
a301 1
	struct man_node	*nb;
d461 1
a462 1
	struct man_node	*nn;
@


1.84
log
@better error reporting regarding .OP .RS .UR .TH arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.83 2015/02/06 09:38:22 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d29 3
d33 1
a33 2
#include "mandoc.h"
#include "mandoc_aux.h"
a34 1
#include "libmandoc.h"
d110 1
a110 1
	case MAN_TEXT:
d113 1
a113 1
	case MAN_ROOT:
d116 1
a116 1
	case MAN_EQN:
d118 1
a118 1
	case MAN_TBL:
d188 1
a188 1
	if (n->type == MAN_HEAD && n->child == NULL)
d245 1
a245 1
	if (n->type == MAN_BODY && n->child == NULL)
d255 1
a255 1
	case MAN_BLOCK:
d259 1
a259 1
	case MAN_BODY:
d265 1
a265 1
	case MAN_HEAD:
d283 1
a283 1
	case MAN_BLOCK:
d287 1
a287 1
	case MAN_BODY:
d429 1
a429 1
	if (NULL == n || MAN_TEXT != n->type)
d466 1
a466 1
	if (NULL == n || MAN_TEXT != n->type)
d476 3
a478 1
			if (nn && MAN_TEXT == nn->type && nn->string[0])
@


1.83
log
@better diagnostics about excess arguments to .PD .ft .sp
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.82 2015/02/06 08:28:03 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
a38 2
static	void	  check_eq2(CHKARGS);
static	void	  check_le5(CHKARGS);
d50 1
d88 1
a88 1
	check_eq2,  /* OP */
d169 12
a180 9
#define	INEQ_DEFINE(x, ineq, name) \
static void \
check_##name(CHKARGS) \
{ \
	if (n->nchild ineq (x)) \
		return; \
	mandoc_vmsg(MANDOCERR_ARGCOUNT, man->parse, n->line, n->pos, \
	    "line arguments %s %d (have %d)", \
	    #ineq, (x), n->nchild); \
a182 3
INEQ_DEFINE(2, ==, eq2)
INEQ_DEFINE(5, <=, le5)

d187 3
a189 3
	if (MAN_HEAD == n->type && 1 != n->nchild)
		mandoc_vmsg(MANDOCERR_ARGCOUNT, man->parse, n->line,
		    n->pos, "line arguments eq 1 (have %d)", n->nchild);
a302 2
	check_le5(man, n);

d379 4
@


1.82
log
@better error reporting for .br .fi .nf with arguments
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.81 2015/02/06 07:12:34 schwarze Exp $ */
a39 1
static	void	  check_le1(CHKARGS);
d85 1
a85 1
	check_le1,  /* PD */
a181 1
INEQ_DEFINE(1, <=, le1)
a238 4

	if (1 < n->nchild)
		mandoc_vmsg(MANDOCERR_ARGCOUNT, man->parse, n->line,
		    n->pos, "want one child (have %d)", n->nchild);
a488 3

	if (n->tok == MAN_sp)
		check_le1(man, n);
@


1.81
log
@Delete the legacy generic warning type MANDOCERR_ARGCWARN,
replacing the last instances by more specific warnings.
Improved functionality, minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.80 2015/01/24 02:41:32 schwarze Exp $ */
a38 1
static	void	  check_eq0(CHKARGS);
a181 1
INEQ_DEFINE(0, ==, eq0)
d400 1
a400 3
	check_eq0(man, n);

	if (MAN_LITERAL & man->flags)
a410 2
	check_eq0(man, n);

d496 1
a496 3
	if (n->tok == MAN_br)
		check_eq0(man, n);
	else
@


1.80
log
@Strangely, ignoring the roff(7) .na request was implemented in the man(7)
parser.  Simplify the code by moving it into the roff(7) parser, also
making it work for mdoc(7).
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.79 2014/12/28 14:39:08 schwarze Exp $ */
d253 3
a255 3
	if (MAN_BODY == n->type && 0 == n->nchild)
		mandoc_msg(MANDOCERR_ARGCWARN, man->parse, n->line,
		    n->pos, "want children (have none)");
@


1.79
log
@mdoc(7) already uses the mandoc(1) -Ios argument in the footer line
when .Os has no argument, so do the same for man(7) when .TH has less
than four arguments; there is no reason to treat both differently.
Issue found following a question from Thomas Klausner <wiz at NetBSD>.
@
text
@d1 1
a1 1
/*	$OpenBSD: man_validate.c,v 1.78 2014/11/28 05:51:29 schwarze Exp $ */
a79 1
	check_eq0,  /* na */
@


1.78
log
@Simplify by making many functions in the man(7) parser void,
and some cleanup; no functional change, minus 70 lines.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d380 2
@


1.77
log
@Bring the handling of defective prologues even closer to groff,
in particular relaxing the distinction between prologue and body
and further improving messages.
* The last .Dd wins and the last .Os wins, even in the body.
* The last .Dt before the first body macro wins.
* Missing title in .Dt defaults to UNTITLED.  Warn about it.
* Missing section in .Dt does not default to 1.  But warn about it.
* Do not warn multiple times about the same mdoc(7) prologue macro.
* Warn about missing .Os.
* Incomplete .TH defaults to empty strings.  Warn about it.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.76 2014/08/08 16:05:42 schwarze Exp $ */
d37 1
a37 1
typedef	int	(*v_check)(CHKARGS);
d39 18
a56 18
static	int	  check_eq0(CHKARGS);
static	int	  check_eq2(CHKARGS);
static	int	  check_le1(CHKARGS);
static	int	  check_le5(CHKARGS);
static	int	  check_par(CHKARGS);
static	int	  check_part(CHKARGS);
static	int	  check_root(CHKARGS);
static	int	  check_text(CHKARGS);

static	int	  post_AT(CHKARGS);
static	int	  post_IP(CHKARGS);
static	int	  post_vs(CHKARGS);
static	int	  post_fi(CHKARGS);
static	int	  post_ft(CHKARGS);
static	int	  post_nf(CHKARGS);
static	int	  post_TH(CHKARGS);
static	int	  post_UC(CHKARGS);
static	int	  post_UR(CHKARGS);
d101 1
a101 1
int
d109 1
a109 1
		return(1);
d114 2
a115 1
		return(check_text(man, n));
d117 2
a118 1
		return(check_root(man, n));
d122 1
a122 1
		return(1);
d125 3
a127 1
		return(*cp ? (*cp)(man, n) : 1);
d131 1
a131 1
static int
a156 2

	return(1);
d159 1
a159 1
static int
d165 1
a165 1
		return(1);
a170 1
	return(1);
d174 1
a174 1
static int \
d178 1
a178 1
		return(1); \
a181 1
	return(1); \
d189 1
a189 1
static int
d196 1
a196 2

	return(check_part(man, n));
d199 1
a199 1
static int
d206 1
a206 1
		return(1);
a247 2

	return(1);
d250 1
a250 1
static int
a256 2

	return(1);
d259 1
a259 1
static int
a284 2

	return(1);
d287 1
a287 1
static int
a304 1
	return(1);
d307 1
a307 1
static int
a394 1
	return(1);
d397 1
a397 1
static int
a407 1
	return(1);
d410 1
a410 1
static int
a420 1
	return(1);
d423 1
a423 1
static int
a457 1
	return(1);
d460 1
a460 1
static int
a494 1
	return(1);
d497 1
a497 1
static int
d507 1
a507 1
		return(1);
a526 2

	return(1);
@


1.76
log
@Simplify man(7) validation:
Drop pre-handlers, they were almost unused.
Drop the needless complexity of allowing more than one post-handler.

This saves one internal interface function, one static function, one
private struct definition, sixteen static arrays, and 45 lines of code.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.75 2014/08/08 15:57:05 schwarze Exp $ */
a41 1
static	int	  check_ge2(CHKARGS);
d140 1
a140 1
		mandoc_msg(MANDOCERR_TH_MISSING, man->parse,
d148 2
a149 2
		man->meta.title = mandoc_strdup("unknown");
		man->meta.msec = mandoc_strdup("1");
a186 1
INEQ_DEFINE(2, >=, ge2)
a320 1
	check_ge2(man, n);
d350 1
a350 1
	} else
d352 3
d362 1
a362 1
	else
d364 3
@


1.75
log
@demacrify: get rid of man_nmsg(), man_pmsg(), mdoc_nmsg(), mdoc_pmsg()
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.74 2014/08/08 15:54:10 schwarze Exp $ */
a38 5
struct	man_valid {
	v_check	 *pres;
	v_check	 *posts;
};

a43 1
static	int	  check_head1(CHKARGS);
d47 1
a47 1
static	void	  check_text(CHKARGS);
d57 1
a57 1
static	int	  pre_sec(CHKARGS);
d59 40
a98 57
static	v_check	  posts_at[] = { post_AT, NULL };
static	v_check	  posts_br[] = { post_vs, check_eq0, NULL };
static	v_check	  posts_eq0[] = { check_eq0, NULL };
static	v_check	  posts_eq2[] = { check_eq2, NULL };
static	v_check	  posts_fi[] = { check_eq0, post_fi, NULL };
static	v_check	  posts_ft[] = { post_ft, NULL };
static	v_check	  posts_ip[] = { post_IP, NULL };
static	v_check	  posts_le1[] = { check_le1, NULL };
static	v_check	  posts_nf[] = { check_eq0, post_nf, NULL };
static	v_check	  posts_par[] = { check_par, NULL };
static	v_check	  posts_part[] = { check_part, NULL };
static	v_check	  posts_sp[] = { post_vs, check_le1, NULL };
static	v_check	  posts_th[] = { check_ge2, check_le5, post_TH, NULL };
static	v_check	  posts_uc[] = { post_UC, NULL };
static	v_check	  posts_ur[] = { check_head1, check_part, NULL };
static	v_check	  pres_sec[] = { pre_sec, NULL };

static	const struct man_valid man_valids[MAN_MAX] = {
	{ NULL, posts_br }, /* br */
	{ NULL, posts_th }, /* TH */
	{ pres_sec, NULL }, /* SH */
	{ pres_sec, NULL }, /* SS */
	{ NULL, NULL }, /* TP */
	{ NULL, posts_par }, /* LP */
	{ NULL, posts_par }, /* PP */
	{ NULL, posts_par }, /* P */
	{ NULL, posts_ip }, /* IP */
	{ NULL, NULL }, /* HP */
	{ NULL, NULL }, /* SM */
	{ NULL, NULL }, /* SB */
	{ NULL, NULL }, /* BI */
	{ NULL, NULL }, /* IB */
	{ NULL, NULL }, /* BR */
	{ NULL, NULL }, /* RB */
	{ NULL, NULL }, /* R */
	{ NULL, NULL }, /* B */
	{ NULL, NULL }, /* I */
	{ NULL, NULL }, /* IR */
	{ NULL, NULL }, /* RI */
	{ NULL, posts_eq0 }, /* na */
	{ NULL, posts_sp }, /* sp */
	{ NULL, posts_nf }, /* nf */
	{ NULL, posts_fi }, /* fi */
	{ NULL, NULL }, /* RE */
	{ NULL, posts_part }, /* RS */
	{ NULL, NULL }, /* DT */
	{ NULL, posts_uc }, /* UC */
	{ NULL, posts_le1 }, /* PD */
	{ NULL, posts_at }, /* AT */
	{ NULL, NULL }, /* in */
	{ NULL, posts_ft }, /* ft */
	{ NULL, posts_eq2 }, /* OP */
	{ NULL, posts_nf }, /* EX */
	{ NULL, posts_fi }, /* EE */
	{ NULL, posts_ur }, /* UR */
	{ NULL, NULL }, /* UE */
	{ NULL, NULL }, /* ll */
a102 26
man_valid_pre(struct man *man, struct man_node *n)
{
	v_check		*cp;

	switch (n->type) {
	case MAN_TEXT:
		/* FALLTHROUGH */
	case MAN_ROOT:
		/* FALLTHROUGH */
	case MAN_EQN:
		/* FALLTHROUGH */
	case MAN_TBL:
		return(1);
	default:
		break;
	}

	if (NULL == (cp = man_valids[n->tok].pres))
		return(1);
	for ( ; *cp; cp++)
		if ( ! (*cp)(man, n))
			return(0);
	return(1);
}

int
d105 1
d108 2
a109 1
	if (MAN_VALID & man->last->flags)
d111 1
a111 1
	man->last->flags |= MAN_VALID;
d113 1
a113 1
	switch (man->last->type) {
d115 1
a115 2
		check_text(man, man->last);
		return(1);
d117 1
a117 1
		return(check_root(man, man->last));
d123 2
a124 1
		break;
a125 8

	if (NULL == (cp = man_valids[man->last->tok].posts))
		return(1);
	for ( ; *cp; cp++)
		if ( ! (*cp)(man, man->last))
			return(0);

	return(1);
d158 1
a158 1
static void
d164 1
a164 1
		return;
d170 1
d192 1
a192 1
check_head1(CHKARGS)
d199 1
a199 1
	return(1);
a255 9
pre_sec(CHKARGS)
{

	if (MAN_BLOCK == n->type)
		man->flags &= ~MAN_LITERAL;
	return(1);
}

static int
d323 3
d407 2
d421 2
d510 5
@


1.74
log
@mention requests and macros in more messages
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.73 2014/08/08 15:35:31 schwarze Exp $ */
d190 2
a191 1
		man_nmsg(man, n, MANDOCERR_DOC_EMPTY);
d196 2
a197 1
		man_nmsg(man, n, MANDOCERR_TH_MISSING);
@


1.73
log
@Improve handling of next-line scope broken by end of file.
Detect the condition earlier, report in the error message
which block is broken, and delete the broken block.
Consequently, empty section headers can no longer happen.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.72 2014/07/07 21:35:42 schwarze Exp $ */
d403 1
a403 1
				mandoc_msg(MANDOCERR_TITLE_CASE,
d406 1
a406 1
				    n->string);
d434 3
a436 1
		man_nmsg(man, n ? n : nb, MANDOCERR_DATE_MISSING);
d466 2
a467 1
		man_nmsg(man, n, MANDOCERR_NF_SKIP);
d478 2
a479 1
		man_nmsg(man, n, MANDOCERR_FI_SKIP);
@


1.72
log
@Clean up ERROR messages related to document structure and macros:
Hierarchical naming and mention macro names in messages.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.71 2014/07/06 19:08:56 schwarze Exp $ */
a60 1
static	int	  post_sec(CHKARGS);
a75 1
static	v_check	  posts_sec[] = { post_sec, NULL };
d85 2
a86 2
	{ pres_sec, posts_sec }, /* SH */
	{ pres_sec, posts_sec }, /* SS */
d187 1
a187 6
	if ((MAN_BLINE | MAN_ELINE) & man->flags)
		mandoc_msg(MANDOCERR_BLK_LINE, man->parse,
		    0, 0, "at end of file");

	man->flags &= ~MAN_BLINE;
	man->flags &= ~MAN_ELINE;
a313 11
}

static int
post_sec(CHKARGS)
{

	if ( ! (MAN_HEAD == n->type && 0 == n->nchild))
		return(1);

	man_nmsg(man, n, MANDOCERR_SYNTARGCOUNT);
	return(0);
@


1.71
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.70 2014/07/05 12:33:54 schwarze Exp $ */
d189 3
a191 4
	if (MAN_BLINE & man->flags)
		man_nmsg(man, n, MANDOCERR_SCOPEEXIT);
	else if (MAN_ELINE & man->flags)
		man_nmsg(man, n, MANDOCERR_SCOPEEXIT);
@


1.70
log
@Cleanup with respect to bad macro arguments.
* Fix .Sm with invalid arg: move arg out and toggle mode.
* Promote "unknown standard" from WARNING to ERROR, it loses information.
* Delete MANDOCERR_BADWIDTH, it would only indicate a mandoc(1) bug.
* Do not report MANDOCERR_BL_LATETYPE when there is no type at all.
* Mention macro names, arguments and fallbacks.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.69 2014/07/04 16:11:41 schwarze Exp $ */
d229 2
a230 1
		man_pmsg(man, n->line, (int)(p - cp), MANDOCERR_BADTAB);
@


1.69
log
@Clean up messages regarding excess arguments:
* Downgrade ".Bf -emphasis Em" from FATAL to WARNING.
* Mention the macros, the arguments, and the fallbacks.
* Hierarchical naming.
Also fix the handling of excess .It head arguments in -Tman.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.68 2014/07/02 11:42:56 schwarze Exp $ */
d302 2
a303 2
		mandoc_vmsg(MANDOCERR_BADFONT, man->parse, n->line,
		    n->pos, "%s", cp);
@


1.68
log
@Clean up warnings related to macros and nesting.
* Hierarchical naming of enum mandocerr items.
* Improve the wording to make it comprehensible.
* Mention the offending macro.
* Garbage collect one chunk of ancient, long unreachable code.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.67 2014/07/02 05:51:49 schwarze Exp $ */
d362 5
a366 1
			man_nmsg(man, n, MANDOCERR_ARGSLOST);
@


1.67
log
@Improve "skipping paragraph macro" messages,
showing which macro was skipped and before or after what.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.66 2014/07/01 22:36:35 schwarze Exp $ */
d478 1
a478 1
		man_nmsg(man, n, MANDOCERR_SCOPEREP);
d489 1
a489 1
		man_nmsg(man, n, MANDOCERR_WNOSCOPE);
@


1.66
log
@Clean up the warnings related to document structure.
* Hierarchical naming of the related enum mandocerr items.
* Mention the offending macro, section title, or string.
While here, improve some wordings:
* Descriptive instead of imperative style.
* Uniform style for "missing" and "skipping".
* Where applicable, mention the fallback used.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.65 2014/06/20 22:58:41 schwarze Exp $ */
d356 3
a358 1
			man_nmsg(man, n, MANDOCERR_IGNPAR);
d382 3
a384 1
			man_nmsg(man, n, MANDOCERR_IGNPAR);
d582 3
a584 1
		man_nmsg(man, n, MANDOCERR_IGNPAR);
@


1.65
log
@As suggested by jmc@@, only include line and column numbers into messages
when they are meaningful, to avoid confusing stuff like this:
$ mandoc /dev/null
mandoc: /dev/null:0:1: FATAL: not a manual
Instead, just say:
mandoc: /dev/null: FATAL: not a manual

Another example this applies to is documents having a prologue,
but lacking a body.  Do not throw a FATAL error for these; instead,
issue a warning and show the empty document, in the man(7) case with
the same amount of blank lines as groff does.  Also downgrade mdoc(7)
documents having content before the first .Sh from FATAL to WARNING.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.64 2014/06/20 17:23:09 schwarze Exp $ */
d413 4
a416 1
				man_nmsg(man, n, MANDOCERR_TITLE_CASE);
@


1.64
log
@Start systematic improvements of error reporting.
So far, this covers all WARNINGs related to the prologue.

1) hierarchical naming of MANDOCERR_* constants
2) mention the macro name in messages where that adds clarity
3) add one missing MANDOCERR_DATE_MISSING msg
4) fix the wording of one message related to the man(7) prologue

Started on the plane back from Ottawa.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.63 2014/04/20 16:44:44 schwarze Exp $ */
d197 6
a202 4
	if (NULL == man->first->child) {
		man_nmsg(man, n, MANDOCERR_NODOCBODY);
		return(0);
	} else if (NULL == man->meta.title) {
@


1.63
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.62 2014/03/30 19:47:32 schwarze Exp $ */
d201 1
a201 1
		man_nmsg(man, n, MANDOCERR_NOTITLE);
d389 1
d401 2
d411 1
a411 1
				man_nmsg(man, n, MANDOCERR_UPPERCASE);
d437 1
a437 1
	} else
d439 2
@


1.62
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.61 2014/03/21 22:17:01 schwarze Exp $ */
d133 1
a133 1
	case (MAN_TEXT):
d135 1
a135 1
	case (MAN_ROOT):
d137 1
a137 1
	case (MAN_EQN):
d139 1
a139 1
	case (MAN_TBL):
d148 1
a148 1
		if ( ! (*cp)(man, n)) 
a152 1

d163 1
a163 1
	case (MAN_TEXT): 
d166 1
a166 1
	case (MAN_ROOT):
d168 1
a168 1
	case (MAN_EQN):
d170 1
a170 1
	case (MAN_TBL):
a184 1

d186 1
a186 1
check_root(CHKARGS) 
d208 1
a208 1
	        man->meta.title = mandoc_strdup("unknown");
d237 2
a238 2
			"line arguments %s %d (have %d)", \
			#ineq, (x), n->nchild); \
d271 1
a271 1
	case ('1'):
d273 1
a273 1
	case ('2'):
d275 1
a275 1
	case ('3'):
d277 1
a277 1
	case ('4'):
d279 1
a279 1
	case ('I'):
d281 1
a281 1
	case ('P'):
d283 1
a283 1
	case ('R'):
d287 1
a287 1
	case ('B'):
d291 1
a291 1
	case ('C'):
d300 2
a301 3
		mandoc_vmsg
			(MANDOCERR_BADFONT, man->parse,
			 n->line, n->pos, "%s", cp);
d306 2
a307 4
		mandoc_vmsg
			(MANDOCERR_ARGCOUNT, man->parse, n->line, 
			 n->pos, "want one child (have %d)", 
			 n->nchild);
d325 1
a325 1
	if ( ! (MAN_HEAD == n->type && 0 == n->nchild)) 
d337 2
a338 2
		mandoc_msg(MANDOCERR_ARGCWARN, man->parse, n->line, 
				n->pos, "want children (have none)");
a342 1

d348 1
a348 1
	case (MAN_BLOCK):
d352 1
a352 1
	case (MAN_BODY):
d356 1
a356 1
	case (MAN_HEAD):
d372 1
a372 1
	case (MAN_BLOCK):
d376 1
a376 1
	case (MAN_BODY):
d398 1
a398 1
		man->meta.msec = man->meta.source = NULL;
d406 2
a407 2
			if (isalpha((unsigned char)*p) && 
					! isupper((unsigned char)*p)) {
d565 1
a565 1
	case (MAN_SH):
d567 1
a567 1
	case (MAN_SS):
d570 2
a571 2
	case (MAN_MAX):
		/* 
@


1.61
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.60 2014/01/06 22:39:19 schwarze Exp $ */
d123 1
@


1.60
log
@Another 18% speedup for mandocdb(8) -Q, found by gprof(1).
In -Q mode, refrain form validating and normalizing the format
of the date given in .Dd or .TH, as it won't be used anyway.

For /usr/share/man, mandocdb -Q now takes 45% of the time of makewhatis(8).
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.59 2013/12/31 18:07:06 schwarze Exp $ */
d31 1
@


1.59
log
@remove assignments that will be overwritten right afterwards,
and remove pointless local variables;
found in a clang output from Ulrich Spoerlein <uqs at FreeBSD>
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.58 2013/10/17 20:51:31 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d210 2
a211 2
		man->meta.date = mandoc_normdate
			(man->parse, NULL, n->line, n->pos);
d434 4
a437 2
		man->meta.date = mandoc_normdate
		    (man->parse, n->string, n->line, n->pos);
@


1.58
log
@Implement the .UR/.UE block (uniform resource identifier) introduced in the
man-ext macros by Eric S. Raymond, enabled by default in groff_man(7).
Usual disclaimer: You don't write new man(7) code, so you are not going
to use these, either.
Improves e.g. the bzr(1) and etherape(1) manuals.
Thanks to naddy@@ for bringing these to my attention.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.57 2012/11/17 00:25:20 schwarze Exp $ */
a393 1
	int		 line, pos;
a400 2
	line = n->line;
	pos = n->pos;
a433 1
		pos = n->pos;
d435 1
a435 1
		    (man->parse, n->string, line, pos);
@


1.57
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.56 2012/07/29 12:35:05 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d48 1
d80 1
d120 2
d247 11
@


1.56
log
@Implement .PD for -Tascii.
Reminded about the missing feature by millert@@.
This reduces mandoc/groff differences in base by 25%.
ok millert@@
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.55 2012/07/18 16:51:50 schwarze Exp $ */
d34 1
a34 1
#define	CHKARGS	  struct man *m, struct man_node *n
d122 1
a122 1
man_valid_pre(struct man *m, struct man_node *n)
d142 1
a142 1
		if ( ! (*cp)(m, n)) 
d149 1
a149 1
man_valid_post(struct man *m)
d153 1
a153 1
	if (MAN_VALID & m->last->flags)
d155 1
a155 1
	m->last->flags |= MAN_VALID;
d157 1
a157 1
	switch (m->last->type) {
d159 1
a159 1
		check_text(m, m->last);
d162 1
a162 1
		return(check_root(m, m->last));
d171 1
a171 1
	if (NULL == (cp = man_valids[m->last->tok].posts))
d174 1
a174 1
		if ( ! (*cp)(m, m->last))
d185 4
a188 4
	if (MAN_BLINE & m->flags)
		man_nmsg(m, n, MANDOCERR_SCOPEEXIT);
	else if (MAN_ELINE & m->flags)
		man_nmsg(m, n, MANDOCERR_SCOPEEXIT);
d190 2
a191 2
	m->flags &= ~MAN_BLINE;
	m->flags &= ~MAN_ELINE;
d193 2
a194 2
	if (NULL == m->first->child) {
		man_nmsg(m, n, MANDOCERR_NODOCBODY);
d196 2
a197 2
	} else if (NULL == m->meta.title) {
		man_nmsg(m, n, MANDOCERR_NOTITLE);
d204 4
a207 4
	        m->meta.title = mandoc_strdup("unknown");
		m->meta.msec = mandoc_strdup("1");
		m->meta.date = mandoc_normdate
			(m->parse, NULL, n->line, n->pos);
d218 1
a218 1
	if (MAN_LITERAL & m->flags)
d223 1
a223 1
		man_pmsg(m, n->line, (int)(p - cp), MANDOCERR_BADTAB);
d232 1
a232 1
	mandoc_vmsg(MANDOCERR_ARGCOUNT, m->parse, n->line, n->pos, \
d286 1
a286 1
			(MANDOCERR_BADFONT, m->parse,
d293 1
a293 1
			(MANDOCERR_ARGCOUNT, m->parse, n->line, 
d305 1
a305 1
		m->flags &= ~MAN_LITERAL;
d316 1
a316 1
	man_nmsg(m, n, MANDOCERR_SYNTARGCOUNT);
d325 1
a325 1
		mandoc_msg(MANDOCERR_ARGCWARN, m->parse, n->line, 
d339 1
a339 1
			man_node_delete(m, n);
d343 1
a343 1
			man_nmsg(m, n, MANDOCERR_IGNPAR);
d347 1
a347 1
			man_nmsg(m, n, MANDOCERR_ARGSLOST);
d363 1
a363 1
			man_node_delete(m, n);
d367 1
a367 1
			man_nmsg(m, n, MANDOCERR_IGNPAR);
d381 5
a385 10
	if (m->meta.title)
		free(m->meta.title);
	if (m->meta.vol)
		free(m->meta.vol);
	if (m->meta.source)
		free(m->meta.source);
	if (m->meta.msec)
		free(m->meta.msec);
	if (m->meta.date)
		free(m->meta.date);
d389 2
a390 2
	m->meta.title = m->meta.vol = m->meta.date =
		m->meta.msec = m->meta.source = NULL;
d400 1
a400 1
				man_nmsg(m, n, MANDOCERR_UPPERCASE);
d404 1
a404 1
		m->meta.title = mandoc_strdup(n->string);
d406 1
a406 1
		m->meta.title = mandoc_strdup("");
d413 1
a413 1
		m->meta.msec = mandoc_strdup(n->string);
d415 1
a415 1
		m->meta.msec = mandoc_strdup("");
d423 2
a424 2
		m->meta.date = mandoc_normdate
		    (m->parse, n->string, line, pos);
d426 1
a426 1
		m->meta.date = mandoc_strdup("");
d431 1
a431 1
		m->meta.source = mandoc_strdup(n->string);
d437 4
a440 4
		m->meta.vol = mandoc_strdup(n->string);
	else if ('\0' != m->meta.msec[0] &&
	    (NULL != (p = mandoc_a2msec(m->meta.msec))))
		m->meta.vol = mandoc_strdup(p);
d446 1
a446 1
	man_node_delete(m, m->last);
d454 2
a455 2
	if (MAN_LITERAL & m->flags)
		man_nmsg(m, n, MANDOCERR_SCOPEREP);
d457 1
a457 1
	m->flags |= MAN_LITERAL;
d465 2
a466 2
	if ( ! (MAN_LITERAL & m->flags))
		man_nmsg(m, n, MANDOCERR_WNOSCOPE);
d468 1
a468 1
	m->flags &= ~MAN_LITERAL;
d505 2
a506 4
	if (m->meta.source)
		free(m->meta.source);

	m->meta.source = mandoc_strdup(p);
d543 2
a544 4
	if (m->meta.source)
		free(m->meta.source);

	m->meta.source = mandoc_strdup(p);
d559 1
a559 1
		man_nmsg(m, n, MANDOCERR_IGNPAR);
d566 1
a566 1
		man_node_delete(m, n);
@


1.55
log
@Drop empty .IP such that is does not cause additional vertical spacing.
Issue first reported by naddy@@ in rsync(1).
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.54 2012/07/18 16:40:50 schwarze Exp $ */
d71 1
d111 1
a111 1
	{ NULL, NULL }, /* PD */
@


1.54
log
@Drop .sp and .br right after .SH and .SS.

Fixes vertical spacing after "OPTIONS" in gcc(1).
Issue first reported by naddy@@ in rsync(1).
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.53 2012/06/02 20:07:09 schwarze Exp $ */
d54 1
d70 1
d89 1
a89 1
	{ NULL, NULL }, /* IP */
d355 18
@


1.53
log
@Minimal implementation of .EX and .EE for GNU compatibility.
Do not use this, it is not portable and only defined in esr's man-ext.
For example, sox(1) wants these macros.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.52 2012/02/26 19:41:27 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d540 14
a553 5
	/* 
	 * Don't warn about this because it occurs in pod2man and would
	 * cause considerable (unfixable) warnage.
	 */
	if (NULL == n->prev && MAN_ROOT == n->parent->type)
d555 4
@


1.52
log
@Support .OP, one of the extended man macros; from kristaps@@.
Do not use this GNU extension, we take it for compatibility only.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.51 2011/12/02 01:45:43 schwarze Exp $ */
d113 2
@


1.51
log
@In man(7), when no explicit volume name is given, use the default
volume name for the respective manual section, just like in mdoc(7).
This gives us nicer page headers for cvs(1), lynx(1), tic(1),
mkhybrid(8), and many curses(3) manuals.

ok kristaps@@

To not break compatibility, i wrote a corresponding patch for GNU troff
which Werner Lemberg accepted upstream at rev. 1.65 of:
http://cvs.savannah.gnu.org/viewvc/groff/tmac/an-old.tmac?root=groff
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.50 2011/11/05 16:02:18 schwarze Exp $ */
d44 1
d66 1
d100 2
a101 2
	{ NULL, posts_eq0 }, /* na */ /* FIXME: should warn only. */
	{ NULL, posts_sp }, /* sp */ /* FIXME: should warn only. */
d112 1
d234 1
@


1.50
log
@When the HEAD scope of .TP is broken by another block macro,
do not abort with a FATAL error, but report a regular ERROR,
remove the broken .TP from the syntax tree, and prod on.
Reported repeatedly by ports people, at least by brad@@ and jeremy@@.
Also fixes rendition(4) in Xenocara.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.49 2011/11/03 20:46:40 schwarze Exp $ */
d412 1
d416 3
@


1.49
log
@When .TH sets no data, leave the date field in the page footer blank,
do not use the current date.  This removes a gratuitous output difference
with respect to groff.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.48 2011/10/16 12:18:32 schwarze Exp $ */
a42 1
static	int	  check_bline(CHKARGS);
d74 1
a74 2
static	v_check	  pres_bline[] = { check_bline, NULL };
static	v_check	  pres_sec[] = { check_bline, pre_sec, NULL};
d78 1
a78 1
	{ pres_bline, posts_th }, /* TH */
d81 6
a86 6
	{ pres_bline, NULL }, /* TP */
	{ pres_bline, posts_par }, /* LP */
	{ pres_bline, posts_par }, /* PP */
	{ pres_bline, posts_par }, /* P */
	{ pres_bline, NULL }, /* IP */
	{ pres_bline, NULL }, /* HP */
d100 2
a101 2
	{ pres_bline, posts_nf }, /* nf */
	{ pres_bline, posts_fi }, /* fi */
a346 13

static int
check_bline(CHKARGS)
{

	assert( ! (MAN_ELINE & m->flags));
	if (MAN_BLINE & m->flags) {
		man_nmsg(m, n, MANDOCERR_SYNTLINESCOPE);
		return(0);
	}

	return(1);
}
@


1.48
log
@Remove a bunch of useless assignments,
and assert that print_bvspace cannot be called on NULL pointers.
No change in behaviour, none of these were bugs,
but the code becomes easier to understand.
Based on a clang report posted by joerg@@; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.47 2011/09/18 15:54:48 schwarze Exp $ */
d414 1
a414 1
	if (n)
d416 4
a419 2
	m->meta.date = mandoc_normdate
		(m->parse, n ? n->string : NULL, line, pos);
@


1.47
log
@sync to version 1.11.7 from kristaps@@
main new feature: support the roff(7) .tr request
plus various bugfixes and some refactoring

regressions are so minor that it's better to get this in
and fix them in the tree
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.46 2011/07/07 20:07:38 schwarze Exp $ */
d212 5
a216 4
	cp = p = n->string;
	for (cp = p; NULL != (p = strchr(p, '\t')); p++) {
		if (MAN_LITERAL & m->flags)
			continue;
a217 1
	}
a472 1
	n = m->last->child;
@


1.46
log
@Fix a bogus "unknown macro" error reported in the pod2man(1) preamble:
- Actually let roff_parse() recognize ".\}" as a cond block end request.
- Do not rewrite "\}" to the zero-width space "\&" because that prevents
recognition of immediately preceding macros; use normal blanks instead.
- To avoid a vertical spacing regression in pod2man(1) manuals,
drop one vertical spacing request just before NAME.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.45 2011/05/29 21:22:18 schwarze Exp $ */
a44 1
static	int	  check_ft(CHKARGS);
a50 1
static	int	  check_sec(CHKARGS);
d56 1
d58 1
d61 1
d67 1
a67 1
static	v_check	  posts_ft[] = { check_ft, NULL };
d71 1
a71 1
static	v_check	  posts_sec[] = { check_sec, NULL };
d76 1
d81 2
a82 2
	{ pres_bline, posts_sec }, /* SH */
	{ pres_bline, posts_sec }, /* SS */
d208 1
a208 1
check_text(CHKARGS) 
d210 5
a214 18
	char		*p, *pp, *cpp;
	int		 pos;
	size_t		 sz;

	p = n->string;
	pos = n->pos + 1;

	while ('\0' != *p) {
		sz = strcspn(p, "\t\\");

		p += (int)sz;
		pos += (int)sz;

		if ('\t' == *p) {
			if ( ! (MAN_LITERAL & m->flags))
				man_pmsg(m, n->line, pos, MANDOCERR_BADTAB);
			p++;
			pos++;
d216 1
a216 18
		} else if ('\0' == *p)
			break;

		pos++;
		pp = ++p;

		if (ESCAPE_ERROR == mandoc_escape
				((const char **)&pp, NULL, NULL)) {
			man_pmsg(m, n->line, pos, MANDOCERR_BADESCAPE);
			break;
		}

		cpp = p;
		while (NULL != (cpp = memchr(cpp, ASCII_HYPH, pp - cpp)))
			*cpp = '-';

		pos += pp - p;
		p = pp;
d238 1
a238 1
check_ft(CHKARGS)
d294 10
a303 1
check_sec(CHKARGS)
a312 1

d391 2
a392 1
			if (isalpha((u_char)*p) && ! isupper((u_char)*p)) {
@


1.45
log
@Merge release 1.11.3, almost all code by kristaps@@:
* Unicode output support (no Unicode input yet, though).
* Refactoring: completely handle predefined strings in roff.c.
- New function mandoc_escape() replaces a2roffdeco() and mandoc_special().
- Start using mandoc_getarg() in mdoc_argv.c.
- Clean up parsing of delimiters in mdoc(7).
* And many minor fixes and lots of cleanup.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.44 2011/04/24 16:22:02 schwarze Exp $ */
d56 1
d63 1
a65 1
static	v_check	  posts_le1[] = { check_le1, NULL };
d71 1
a75 1

d77 1
a77 1
	{ NULL, posts_eq0 }, /* br */
d99 1
a99 1
	{ NULL, posts_le1 }, /* sp */ /* FIXME: should warn only. */
d556 14
@


1.44
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.43 2011/04/21 22:59:54 schwarze Exp $ */
d53 1
a53 1
static	int	  check_text(CHKARGS);
d150 2
a151 1
		return(check_text(m, m->last));
d204 1
a204 2

static int
d207 2
a208 2
	char		*p;
	int		 pos, c;
d211 4
a214 1
	for (p = n->string, pos = n->pos + 1; *p; p++, pos++) {
d216 1
d218 1
d220 7
a226 1
		if ('\0' == *p)
d229 2
a230 1
		pos += (int)sz;
d232 4
a235 5
		if ('\t' == *p) {
			if (MAN_LITERAL & m->flags)
				continue;
			man_pmsg(m, n->line, pos, MANDOCERR_BADTAB);
			continue;
d238 3
a240 1
		/* Check the special character. */
d242 2
a243 6
		c = mandoc_special(p);
		if (c) {
			p += c - 1;
			pos += c - 1;
		} else
			man_pmsg(m, n->line, pos, MANDOCERR_BADESCAPE);
a244 2

	return(1);
a245 1

@


1.43
log
@Merge version 1.10.10:
lots of cleanup and maintenance work by kristaps@@.
- move some main.c globals into struct curparse
- move mandoc_*alloc to mandoc.h such that all code can use them
- make mandoc_isdelim available to formatting frontends
- dissolve mdoc_strings.c, move the code where it is used
- make all error reporting functions void, their return values were useless
- and various minor cleanups and fixes
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.42 2011/03/20 23:36:42 schwarze Exp $ */
d29 1
d196 2
a197 2
		m->meta.date = mandoc_normdate(NULL,
		    m->msg, m->data, n->line, n->pos);
d247 1
a247 1
	man_vmsg(m, MANDOCERR_ARGCOUNT, n->line, n->pos, \
d299 3
a301 2
		man_vmsg(m, MANDOCERR_BADFONT,
				n->line, n->pos, "%s", cp);
d306 4
a309 2
		man_vmsg(m, MANDOCERR_ARGCOUNT, n->line, n->pos,
				"want one child (have %d)", n->nchild);
d318 2
a319 5
	if (MAN_HEAD == n->type && 0 == n->nchild) {
		man_nmsg(m, n, MANDOCERR_SYNTARGCOUNT);
		return(0);
	} else if (MAN_BODY == n->type && 0 == n->nchild)
		man_nmsg(m, n, MANDOCERR_NOBODY);
d321 2
a322 1
	return(1);
d331 2
a332 1
		man_nmsg(m, n, MANDOCERR_NOBODY);
d428 2
a429 2
	m->meta.date = mandoc_normdate(n ? n->string : NULL,
	    m->msg, m->data, line, pos);
@


1.42
log
@Import the foundation for eqn(7) support.
Written by kristaps@@.

For now, i'm adding one line to each of the four frontends
to just pass the input text through to the output,
not yet interpreting any of then eqn keywords.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.41 2011/03/07 01:35:33 schwarze Exp $ */
d222 2
a223 3
			if (man_pmsg(m, n->line, pos, MANDOCERR_BADTAB))
				continue;
			return(0);
@


1.41
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.40 2011/01/17 00:15:19 schwarze Exp $ */
d121 2
d152 2
@


1.40
log
@Refrain from throwing fatal errors for
* .br .sp .nf .fi .na with arguments - just skip the arguments
* .TH lacking arguments - use empty strings instead like groff
* .TH with excessive arguments - skip those
Reminded by Joerg Sonnenberger, ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.39 2011/01/16 19:27:25 schwarze Exp $ */
a189 1
		m->meta.date = time(NULL);
d191 2
d374 1
d384 2
a385 2
	if (m->meta.rawdate)
		free(m->meta.rawdate);
d387 3
a389 1
	m->meta.title = m->meta.vol = m->meta.rawdate =
a390 1
	m->meta.date = 0;
a417 7
	/*
	 * Try to parse the date.  If this works, stash the epoch (this
	 * is optimal because we can reformat it in the canonical form).
	 * If it doesn't parse, isn't specified at all, or is an empty
	 * string, then use the current date.
	 */

d420 4
a423 9
	if (n && n->string && *n->string) {
		m->meta.date = mandoc_a2time
			(MTIME_ISO_8601, n->string);
		if (0 == m->meta.date) {
			man_nmsg(m, n, MANDOCERR_BADDATE);
			m->meta.rawdate = mandoc_strdup(n->string);
		}
	} else
		m->meta.date = time(NULL);
@


1.39
log
@Some improvements to error handling from kristaps@@:
* Make out-of-context .fi invocations not cause an error, but just a warning.
* Downgrade -man message about ignored empty paragraph to MANDOC_IGNPAR.
* Avoid syntax tree corruption when removing empty block macros.
Triggered by some reports from brad@@.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.38 2011/01/04 22:28:17 schwarze Exp $ */
a52 1
static	int	  check_title(CHKARGS);
d69 1
a69 1
static	v_check	  posts_th[] = { check_ge2, check_le5, check_title, post_TH, NULL };
a198 23
check_title(CHKARGS) 
{
	const char	*p;

	assert(n->child);
	/* FIXME: is this sufficient? */
	if ('\0' == *n->child->string) {
		man_nmsg(m, n, MANDOCERR_SYNTARGCOUNT);
		return(0);
	}

	for (p = n->child->string; '\0' != *p; p++)
		/* Only warn about this once... */
		if (isalpha((u_char)*p) && ! isupper((u_char)*p)) {
			man_nmsg(m, n, MANDOCERR_UPPERCASE);
			break;
		}

	return(1);
}


static int
d242 1
a242 1
	man_vmsg(m, MANDOCERR_SYNTARGCOUNT, n->line, n->pos, \
d245 1
a245 1
	return(0); \
d372 1
d392 11
a402 2
	assert(n);
	m->meta.title = mandoc_strdup(n->string);
d406 6
a411 3
	n = n->next;
	assert(n);
	m->meta.msec = mandoc_strdup(n->string);
d422 2
a423 1
	n = n->next;
@


1.38
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.37 2010/12/19 07:53:12 schwarze Exp $ */
d80 1
a80 1
	{ pres_bline, posts_par }, /* TP */
d84 2
a85 2
	{ pres_bline, posts_par }, /* IP */
	{ pres_bline, posts_par }, /* HP */
d359 16
a374 27
	if (MAN_BODY == n->type) 
		switch (n->tok) {
		case (MAN_IP):
			/* FALLTHROUGH */
		case (MAN_HP):
			/* FALLTHROUGH */
		case (MAN_TP):
			/* Body-less lists are ok. */
			break;
		default:
			if (0 == n->nchild)
				man_nmsg(m, n, MANDOCERR_NOBODY);
			break;
		}
	if (MAN_HEAD == n->type)
		switch (n->tok) {
		case (MAN_PP):
			/* FALLTHROUGH */
		case (MAN_P):
			/* FALLTHROUGH */
		case (MAN_LP):
			if (n->nchild)
				man_nmsg(m, n, MANDOCERR_ARGSLOST);
			break;
		default:
			break;
		}
d478 1
a478 1
		man_nmsg(m, n, MANDOCERR_NOSCOPE);
@


1.37
log
@Remove `i' and `r' macro handlers.  These macros, originally part of the
me package, aren't recognised by "groff -mandoc" so we don't need to do
so either.  Besides, they are not used in base or Xenocara, and only at
two or three places in one single port, which are probably typos.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.36 2010/12/07 00:08:52 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
a32 4
#include "out.h"
#include "term.h"
#include "tbl.h"

a58 1
static	int	  post_TS(CHKARGS);
a70 1
static	v_check	  posts_ts[] = { post_TS, NULL };
a107 2
	{ NULL, posts_ts }, /* TS */
	{ NULL, NULL }, /* TE */
d117 6
a122 3
	if (MAN_TEXT == n->type)
		return(1);
	if (MAN_ROOT == n->type)
d124 3
d151 2
a572 10
	return(1);
}

static int
post_TS(CHKARGS)
{

	if (MAN_HEAD == n->type)
		n->parent->data.TS = tbl_alloc();

@


1.36
log
@Complete the merge of bsd.lv version 1.10.7:
No more functional changes, just sync ordering, comments and white space.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.35 2010/12/06 23:03:56 schwarze Exp $ */
a103 1
	{ NULL, NULL }, /* i */
a106 1
	{ NULL, NULL }, /* r */
@


1.35
log
@Do not report the same problems multiple times,
and do not bother checking the return values of calls
that always return 1.
From kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.34 2010/12/01 23:02:59 schwarze Exp $ */
d27 1
d48 1
a51 1
static	int	  check_ft(CHKARGS);
d70 1
a71 1
static	v_check	  posts_ft[] = { check_ft, NULL };
a278 1

d320 2
a321 1
		man_vmsg(m, MANDOCERR_BADFONT, n->line, n->pos, "%s", cp);
d327 1
a327 1
		    "want one child (have %d)", n->nchild);
a331 1

d356 50
a586 50

static int
check_par(CHKARGS)
{

	if (MAN_BODY == n->type) 
		switch (n->tok) {
		case (MAN_IP):
			/* FALLTHROUGH */
		case (MAN_HP):
			/* FALLTHROUGH */
		case (MAN_TP):
			/* Body-less lists are ok. */
			break;
		default:
			if (0 == n->nchild)
				man_nmsg(m, n, MANDOCERR_NOBODY);
			break;
		}
	if (MAN_HEAD == n->type)
		switch (n->tok) {
		case (MAN_PP):
			/* FALLTHROUGH */
		case (MAN_P):
			/* FALLTHROUGH */
		case (MAN_LP):
			if (n->nchild)
				man_nmsg(m, n, MANDOCERR_ARGSLOST);
			break;
		default:
			break;
		}

	return(1);
}


static int
check_bline(CHKARGS)
{

	assert( ! (MAN_ELINE & m->flags));
	if (MAN_BLINE & m->flags) {
		man_nmsg(m, n, MANDOCERR_SYNTLINESCOPE);
		return(0);
	}

	return(1);
}

@


1.34
log
@Merge man_action.c into man_validate.c.
Same as for mdoc_action.c, but much simpler.
Work by kristaps@@, re-applying OpenBSD changes on top.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.33 2010/11/29 02:26:45 schwarze Exp $ */
d173 3
a175 3
		return(man_nmsg(m, n, MANDOCERR_SCOPEEXIT));
	if (MAN_ELINE & m->flags)
		return(man_nmsg(m, n, MANDOCERR_SCOPEEXIT));
d184 2
a185 2
		if ( ! man_nmsg(m, n, MANDOCERR_NOTITLE))
			return(0);
a188 2
		 * 
		 * FIXME: this should be in man_action.c.
d190 1
d213 5
a217 3
		if (isalpha((u_char)*p) && ! isupper((u_char)*p))
			if ( ! man_nmsg(m, n, MANDOCERR_UPPERCASE))
				return(0);
d340 1
a340 1
		return(man_nmsg(m, n, MANDOCERR_NOBODY));
d351 2
a352 1
		return(man_nmsg(m, n, MANDOCERR_NOBODY));
d552 3
a554 3
			if (n->nchild)
				break;
			return(man_nmsg(m, n, MANDOCERR_NOBODY));
d563 3
a565 3
			if (0 == n->nchild)
				break;
			return(man_nmsg(m, n, MANDOCERR_ARGSLOST));
@


1.33
log
@Now that we have proper .de support in the roff(7) library,
it is time to remove the .Sp, .Vb, and .Ve kludge
that was added to the man(7) library to build Perl manuals.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.32 2010/11/29 00:12:02 schwarze Exp $ */
d32 4
d58 8
d67 3
a70 1
static	v_check	  posts_th[] = { check_ge2, check_le5, check_title, NULL };
d74 3
a76 1
static	v_check	  posts_le1[] = { check_le1, NULL };
d79 1
d105 2
a106 2
	{ pres_bline, posts_eq0 }, /* nf */
	{ pres_bline, posts_eq0 }, /* fi */
d111 1
a111 1
	{ NULL, NULL }, /* UC */
d113 1
a113 1
	{ NULL, NULL }, /* AT */
d115 1
a115 1
	{ NULL, NULL }, /* TS */
d354 181
@


1.32
log
@Implement the roff .ft (change font) request for man(7).
Of course, we don't want to encourage low-level physical markup,
but pod2man(1) writes such requests, so Perl manuals contain them,
and some Xenocara and lots and lots of ports manuals use them as well.
In base and Xenocara, this will reduce mandoc -Tlint ERROR noise;
in ports, it will improve rendering of many manuals.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.31 2010/10/27 10:17:45 schwarze Exp $ */
a95 3
	{ NULL, posts_le1 }, /* Sp */ /* FIXME: should warn only. */
	{ pres_bline, posts_le1 }, /* Vb */ /* FIXME: should warn only. */
	{ pres_bline, posts_eq0 }, /* Ve */
@


1.31
log
@The man(7) macros .HP .IP .RS .TP accept *optional* arguments,
so do not throw an ERROR when there are none.
Formatting is already correct:
With no arguments, use default widths and no tag.
Problem reported by naddy@@, thanks.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.30 2010/10/15 20:45:03 schwarze Exp $ */
d4 1
d46 1
d55 1
d103 1
d262 53
@


1.30
log
@Minimal glue to integrate tbl into the mandoc man(7) parser and formatter.
The output dosn't look nice yet, escape handling is still missing,
but will follow soon.
"move forward aggressively :-)" deraadt@@
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.29 2010/08/20 00:53:35 schwarze Exp $ */
d313 1
a313 3
			if (n->nchild)
				break;
			return(man_nmsg(m, n, MANDOCERR_NOARGS));
@


1.29
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.28 2010/07/25 18:05:54 schwarze Exp $ */
d98 2
@


1.28
log
@Sync to bsd.lv; in particular, pull in lots of bug fixes.
new features:
* support the .in macro in man(7)
* support minimal PDF output
* support .Sm in mdoc(7) HTML output
* support .Vb and .nf in man(7) HTML output
* complete the mdoc(7) manual
bug fixes:
* do not let mdoc(7) .Pp produce a newline before/after .Sh; reported by jmc@@
* avoid double blank lines related to man(7) .sp and .br
* let man(7) .nf and .fi flush the line; reported by jsg@@ and naddy@@
* let "\ " produce a non-breaking space; reported by deraadt@@
* discard \m colour escape sequences; reported by J.C. Roberts
* map undefined 1-character-escapes to the literal character itself
maintenance:
* express mdoc(7) arguments in terms of an enum for additional type-safety
* simplify mandoc_special() and a2roffdeco()
* use strcspn in term_word() in place of a manual loop
* minor optimisations in the -Tps and -Thtml formatting frontends
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.27 2010/06/26 17:56:43 schwarze Exp $ */
d232 2
a233 6
			continue;
		}

		c = man_pmsg(m, n->line, pos, MANDOCERR_BADESCAPE);
		if ( ! (MAN_IGN_ESCAPE & m->pflags) && ! c)
			return(c);
@


1.27
log
@merge release 1.10.2
* bug fixes:
- interaction of ASCII_HYPH with special chars (found by Ulrich Spoerlein)
- handling of roff conditionals (found by Ulrich Spoerlein)
- .Bd -offset will no more default to 6n
* maintenance:
- more caching of .Bd and .Bl arguments for efficiency
- deconstify man(7) validation routines
- add FreeBSD library names (provided by Ulrich Spoerlein)
* start PostScript font-switching
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.26 2010/05/26 02:39:58 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
d25 1
d82 1
a82 1
	{ NULL, posts_eq0 }, /* na */
d84 1
a84 1
	{ NULL, posts_le1 }, /* sp */
d93 2
a94 2
	{ NULL, posts_le1 }, /* Sp */
	{ pres_bline, posts_le1 }, /* Vb */
d97 1
d207 1
d209 8
a216 1
	assert(n->string);
d218 4
a221 6
	for (p = n->string, pos = n->pos + 1; *p; p++, pos++) {
		if ('\\' == *p) {
			c = mandoc_special(p);
			if (c) {
				p += c - 1;
				pos += c - 1;
d223 4
a226 1
			}
d228 5
a232 3
			c = man_pmsg(m, n->line, pos, MANDOCERR_BADESCAPE);
			if ( ! (MAN_IGN_ESCAPE & m->pflags) && ! c)
				return(c);
d235 3
a237 4
		if ('\t' == *p || isprint((u_char)*p) || ASCII_HYPH == *p) 
			continue;
		if ( ! man_pmsg(m, n->line, pos, MANDOCERR_BADCHAR))
			return(0);
@


1.26
log
@When a word does not fully fit onto the output line, but it contains
at least one hyphen, we already had support for breaking the line a the
last fitting hyphen.  This patch improves this functionality by only
breaking at hyphens in free-form text, and by not breaking at hyphens
* at the beginning or end of a word   or
* immediately preceded or followed by another hyphen   or
* escaped by a preceding backslash.

Before this patch, differences in break-at-hyphen support were one
of the major sources of noise in automatic comparisons to mdoc(7)
groff output.  Now, the remaining differences are hard to find among
the noise coming from other sources.

Where there are still differences, what we do seems to be better than
what groff does, see e.g. the chio(1) exchange and position commands
for one of the now rare examples.

idea and coding by kristaps@@

Besides, this was the last substantial code difference left
between bsd.lv and openbsd.org.  We are now in full sync.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.25 2010/05/23 22:45:00 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d30 1
a30 1
#define	CHKARGS	  struct man *m, const struct man_node *n
d100 1
a100 1
man_valid_pre(struct man *m, const struct man_node *n)
d203 1
a203 1
	const char	*p;
@


1.25
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.24 2010/05/23 20:57:16 schwarze Exp $ */
d222 1
a222 1
		if ('\t' == *p || isprint((u_char)*p)) 
@


1.24
log
@implement .AT and .UC; from Joerg Sonnenberger
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.23 2010/05/20 00:58:02 schwarze Exp $ */
d26 1
d151 1
a151 1
		return(man_nwarn(m, n, WEXITSCOPE));
d153 1
a153 1
		return(man_nwarn(m, n, WEXITSCOPE));
d158 5
a162 4
	if (NULL == m->first->child)
		return(man_nerr(m, n, WNODATA));
	if (NULL == m->meta.title) {
		if ( ! man_nwarn(m, n, WNOTITLE))
d185 5
a189 2
	if ('\0' == *n->child->string)
		return(man_nerr(m, n, WNOTITLE));
d193 1
a193 1
			if ( ! man_nwarn(m, n, WTITLECASE))
d216 4
a219 5
			if ( ! (MAN_IGN_ESCAPE & m->pflags))
				return(man_perr(m, n->line, pos, WESCAPE));
			if ( ! man_pwarn(m, n->line, pos, WESCAPE))
				return(0);
			continue;
d224 2
a225 2

		return(man_pwarn(m, n->line, pos, WNPRINT));
d238 4
a241 3
	return(man_verr(m, n->line, n->pos, \
			"expected line arguments %s %d, have %d", \
			#ineq, (x), n->nchild)); \
d254 6
a259 4
	if (MAN_BODY == n->type && 0 == n->nchild)
		return(man_nwarn(m, n, WBODYARGS));
	if (MAN_HEAD == n->type && 0 == n->nchild)
		return(man_nerr(m, n, WHEADARGS));
d269 1
a269 1
		return(man_nwarn(m, n, WBODYARGS));
d290 1
a290 1
			return(man_nwarn(m, n, WBODYARGS));
d301 1
a301 1
			return(man_nwarn(m, n, WNHEADARGS));
d305 1
a305 1
			return(man_nwarn(m, n, WHEADARGS));
d317 4
a320 2
	if (MAN_BLINE & m->flags)
		return(man_nerr(m, n, WLNSCOPE));
@


1.23
log
@Support nested roff instructions:
* allow roff_parseln() to be re-run
* allow roff_parseln() to manipulate the line buffer offset
* support the offset in the man and mdoc libraries
* adapt .if, .ie, .el, .ig, .am* and .de* support
* interpret some instructions even in conditional-negative context
Coded by kristaps during the last day of the mandoc hackathon.

To avoid regressions in the OpenBSD tree, commit this together
with some small local additions:
* detect roff block end "\}" even on macro lines
* actually implement the ".if n" conditional
* ignore .ds, .rm and .tr in libroff

Also back my old .if/.ie/.el-handling out of libman, reverting:
man.h 1.15 man.c 1.25 man_macro.c 1.15 man_validate.c 1.19
man_action.c 1.15 man_term.c 1.28 man_html.c 1.9.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.22 2010/05/16 00:54:03 schwarze Exp $ */
d94 1
@


1.22
log
@In theory, Kristaps never intended to write a roff parser,
but in practice, most real legacy man(7)uals are using so much
low level roff that we can't really get away without at least
partially handling some roff instructions.

As doing this in man(7) only has become messy and as even some
mdoc(7) pages need it, start a minimal partial roff preprocessor.
As a first step, move handling of .am[i], .de[i] and .ig there.
Do not use the roff preprocessor for new manuals!

Now that we have three main parser libraries - roff, man and mdoc -
each one having its own error handling is becoming messy, too.
Thus, start unifying message handling in one central place,
introducing a new generic function mmsg().

coded by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.21 2010/05/15 18:06:03 schwarze Exp $ */
a93 3
	{ NULL, NULL }, /* if */
	{ NULL, NULL }, /* ie */
	{ NULL, NULL }, /* el */
@


1.21
log
@removed restriction on integer manual sections in -man;
by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.20 2010/05/13 20:34:29 schwarze Exp $ */
a44 1
static	int	  check_roff(CHKARGS);
a56 1
static	v_check	  pres_roff[] = { check_roff, NULL };
a93 6
	{ pres_roff, NULL }, /* de */
	{ pres_roff, NULL }, /* dei */
	{ pres_roff, NULL }, /* am */
	{ pres_roff, NULL }, /* ami */
	{ pres_roff, NULL }, /* ig */
	{ NULL, NULL }, /* . */
a317 17

static int
check_roff(CHKARGS)
{

	if (MAN_BLOCK != n->type)
		return(1);

	for (n = n->parent; n; n = n->parent)
		if (MAN_de == n->tok || MAN_dei == n->tok ||
				MAN_am == n->tok || 
				MAN_ami == n->tok ||
				MAN_ig == n->tok)
			return(man_nerr(m, n, WROFFNEST));

	return(1);
}
@


1.20
log
@Remove the command line option -fno-ign-chars.
This option was not useful, you never want mandoc to die
just because there is an invalid character in the input file,
neither in production nor when linting: a warning is sufficient.
This was particularly annoying because it was part of -fstrict
and could not be switched off.
"less is more" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.19 2010/04/25 16:32:19 schwarze Exp $ */
d180 1
a180 1
		m->meta.msec = 1;
@


1.19
log
@Implement roff conditional instructions .if .ie .el, in man(7) only for now;
fixing OpenBSD::PackageName(3p) and friends for espie@@.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.18 2010/04/07 23:15:05 schwarze Exp $ */
d231 1
a231 3
		if (MAN_IGN_CHARS & m->pflags)
			return(man_pwarn(m, n->line, pos, WNPRINT));
		return(man_perr(m, n->line, pos, WNPRINT));
@


1.18
log
@Merge the good parts of 1.9.23,
avoid the bad parts of 1.9.23, and keep local patches.

Input in general:
 * Basic handling of roff-style font escapes \f, \F.
 * Quoted punctuation does not count as punctuation.

mdoc(7) parser:
 * Make .Pf callable; noted by Claus Assmann.
 * Let .Bd and .Bl ignore unknown arguments; noted by deraadt@@.
 * Do not warn when .Er is used outside certain sections.
 * Replace mdoc_node_free[list] by mdoc_node_delete.
 * Replace #define by enum for rew*() return values.

man(7) parser:
 * When .TH is missing, use default section and date.

Output in general:
 * Curly braces do not count as punctuation.
 * No space after .Fl w/o args when a macro follows on the same line.

HTML output:
 * Unify PAIR_*_INIT macros, introduce new PAIR_ID_INIT().
 * Print whitespace after, not before .Vt .Fn .Ft .Fo.

Checked that all manuals in base still build.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.17 2010/04/03 16:33:01 schwarze Exp $ */
d102 3
@


1.17
log
@When we have no title in man(7), just use "unknown".  No need to bail.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.16 2010/04/02 11:37:07 schwarze Exp $ */
d169 6
d176 2
@


1.16
log
@merge 1.9.20, keeping local patches
* prevent roff instructions in man(7) from clobbering scopes and line modes
  (noted by Sascha Wildner)
* handle leading punctuation in mdoc(7) blocks and line macros
  (looks good in principle, but is causing some fallout in OpenBSD,
   so i will disable it locally for now with the next commit)
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.15 2010/03/29 22:56:52 schwarze Exp $ */
d166 5
a170 2
	if (NULL == m->meta.title)
		return(man_nerr(m, n, WNOTITLE));
@


1.15
log
@merge 1.9.19, keeping local patches
 * scoping fixes for roff instructions
 * accept apostroph in place of dot as a macro control character
 * accept tabs between the control character and the macro name
 * check that man(7) .TH titles use capital letters
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.14 2010/03/26 01:22:05 schwarze Exp $ */
d58 1
a58 1
static	v_check	  pres_roff[] = { check_bline, check_roff, NULL };
@


1.14
log
@merge 1.9.17, keeping local patches

* much improved pod2man support and low-level roff robustness
* have -Tlint imply -Wall and -fstrict
* use fewer macros and more enum in libman
* and various bug fixes
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.13 2010/03/02 01:00:39 schwarze Exp $ */
d49 1
d52 1
a52 1
static	v_check	  posts_ge2_le5[] = { check_ge2, check_le5, NULL };
d62 1
a62 1
	{ pres_bline, posts_ge2_le5 }, /* TH */ /* FIXME: make sure capitalised. */
d168 18
@


1.13
log
@Accept the non-standard macros .Sp (similar to .sp)
and .Vb/.Ve (similar to .nf/.fi) in man(7) mode.
These are not intended to be used manually, but they allow us to
properly render man(7) code autogenerated by pod2man(1),
making Perl and OpenSSL happy in our tree.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.12 2010/02/26 12:42:29 schwarze Exp $ */
d45 1
d57 1
d61 1
a61 1
	{ pres_bline, posts_ge2_le5 }, /* TH */
d95 6
d291 1
d295 17
@


1.12
log
@The groff_man(7) manual says "the first line of text following" .TP is
used as a label, not "the first line following", so allow (some kinds of)
intervening macros - some people actually put macros in between.

On the other hand, when there is no text line before the next block macro,
that is, when the .TP block ends without any text line, then something *is*
broken, so still error out in that case.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.11 2009/10/27 21:40:07 schwarze Exp $ */
d54 1
a54 1
static	v_check	  posts_sp[] = { check_le1, NULL };
d81 1
a81 1
	{ NULL, posts_sp }, /* sp */
d90 3
@


1.11
log
@sync to 1.9.11: adapt printing of dates to groff conventions,
NetBSD portability fixes and some minor bugfixes and feature enhancements;
also checked that my hyphenation code still works on top of this
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.10 2009/10/21 19:13:50 schwarze Exp $ */
d58 1
a58 1
	{ pres_bline, posts_eq0 }, /* br */
d79 1
a79 1
	{ pres_bline, posts_eq0 }, /* na */
d81 1
a81 1
	{ pres_bline, posts_sp }, /* sp */
@


1.10
log
@sync to 1.9.9, featuring:
 * -Thtml output mode
 * roff scaling units
 * and some minor fixes
for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.9 2009/09/18 22:46:14 schwarze Exp $ */
d89 1
@


1.9
log
@sync to 1.9.2: Add .UC libman macro for compatibility, has no effect.
Correct .UC and .DT to not print their arguments.
Document that .UC and .DT should not be used.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.8 2009/08/22 23:17:40 schwarze Exp $ */
d40 1
a40 1
static	int	  check_eq1(CHKARGS);
a46 1
static	int	  check_sp(CHKARGS);
d54 1
a54 1
static	v_check	  posts_sp[] = { check_sp, NULL };
d207 1
a207 1
INEQ_DEFINE(1, ==, eq1)
a209 30


static int
check_sp(CHKARGS)
{
	long		 lval;
	char		*ep, *buf;

	if (NULL == n->child)
		return(1);
	else if ( ! check_eq1(m, n))
		return(0);

	assert(MAN_TEXT == n->child->type);
	buf = n->child->string;
	assert(buf);
	
	/* From OpenBSD's strtol(3). */

	errno = 0;
	lval = strtol(buf, &ep, 10);
	if (buf[0] == '\0' || *ep != '\0')
		return(man_nerr(m, n->child, WNUMFMT));

	if ((errno == ERANGE && (lval == LONG_MAX || lval == LONG_MIN)) ||
			(lval > INT_MAX || lval < 0))
		return(man_nerr(m, n->child, WNUMFMT));

	return(1);
}
@


1.8
log
@another large chunk of -man updates,
among others regarding .DT, .HP, .RS, .RE, .SH, .SS, and scoping,
now in sync vith release 1.9.1
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.7 2009/08/22 20:14:37 schwarze Exp $ */
d89 1
@


1.7
log
@Kristaps@@ significantly overhauled libman.
I'm committing this in one large chunk because in contrast to -mdoc, -man
is mostly untested in OpenBSD anyway, so any fallout can be fixed in-tree.
Among others, improved support for .IP, .HP, and .TP.
Now in sync with release 1.9.0.
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.6 2009/08/22 15:15:37 schwarze Exp $ */
a38 1
static	int	  check_eline(CHKARGS);
d44 1
d53 1
a55 1
static	v_check	  pres_eline[] = { check_eline, NULL };
d69 2
a70 2
	{ pres_eline, NULL }, /* SM */
	{ pres_eline, NULL }, /* SB */
d75 3
a77 3
	{ pres_eline, NULL }, /* R */
	{ pres_eline, NULL }, /* B */
	{ pres_eline, NULL }, /* I */
d86 3
a142 1
	/* XXX - make this into a warning? */
d144 1
a144 2
		return(man_nerr(m, n, WEXITSCOPE));
	/* XXX - make this into a warning? */
d146 4
a149 1
		return(man_nerr(m, n, WEXITSCOPE));
d255 10
a302 10
check_eline(CHKARGS)
{

	if (MAN_ELINE & m->flags)
		return(man_nerr(m, n, WLNSCOPE));
	return(1);
}


static int
d306 1
a307 2
		return(man_nerr(m, n, WLNSCOPE));
	if (MAN_ELINE & m->flags)
@


1.6
log
@sync to 1.8.4: support .sp in -man
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.5 2009/07/08 00:04:10 schwarze Exp $ */
d29 1
a29 1
#define	POSTARGS  struct man *m, const struct man_node *n
d31 1
a31 1
typedef	int	(*v_post)(POSTARGS);
d34 2
a35 1
	v_post	 *posts;
d38 19
a56 17
static	int	  check_eq0(POSTARGS);
static	int	  check_eq1(POSTARGS);
static	int	  check_ge1(POSTARGS);
static	int	  check_ge2(POSTARGS);
static	int	  check_le1(POSTARGS);
static	int	  check_le2(POSTARGS);
static	int	  check_le5(POSTARGS);
static	int	  check_root(POSTARGS);
static	int	  check_sp(POSTARGS);
static	int	  check_text(POSTARGS);

static	v_post	  posts_eq0[] = { check_eq0, NULL };
static	v_post	  posts_ge1[] = { check_ge1, NULL };
static	v_post	  posts_ge2_le5[] = { check_ge2, check_le5, NULL };
static	v_post	  posts_le1[] = { check_le1, NULL };
static	v_post	  posts_le2[] = { check_le2, NULL };
static	v_post	  posts_sp[] = { check_sp, NULL };
d59 27
a85 24
	{ posts_eq0 }, /* br */
	{ posts_ge2_le5 }, /* TH */
	{ posts_ge1 }, /* SH */
	{ posts_ge1 }, /* SS */
	{ NULL }, /* TP */
	{ posts_eq0 }, /* LP */
	{ posts_eq0 }, /* PP */
	{ posts_eq0 }, /* P */
	{ posts_le2 }, /* IP */
	{ posts_le1 }, /* HP */
	{ NULL }, /* SM */
	{ NULL }, /* SB */
	{ NULL }, /* BI */
	{ NULL }, /* IB */
	{ NULL }, /* BR */
	{ NULL }, /* RB */
	{ NULL }, /* R */
	{ NULL }, /* B */
	{ NULL }, /* I */
	{ NULL }, /* IR */
	{ NULL }, /* RI */
	{ posts_eq0 }, /* na */
	{ NULL }, /* i */
	{ posts_sp }, /* sp */
d90 19
d111 1
a111 1
	v_post		*cp;
d137 1
a137 1
check_root(POSTARGS) 
d139 8
a146 1
	
d157 1
a157 1
check_text(POSTARGS) 
d193 1
a193 1
check_##name(POSTARGS) \
a203 1
INEQ_DEFINE(1, >=, ge1)
a204 2
INEQ_DEFINE(1, <=, le1)
INEQ_DEFINE(2, <=, le2)
d209 1
a209 1
check_sp(POSTARGS)
d214 1
a214 1
	if (NULL == m->last->child)
d219 2
a220 2
	assert(MAN_TEXT == m->last->child->type);
	buf = m->last->child->string;
d224 1
d228 1
a228 1
		return(man_nerr(m, m->last->child, WNUMFMT));
d232 9
a240 1
		return(man_nerr(m, m->last->child, WNUMFMT));
d242 4
d248 61
@


1.5
log
@sync to 1.7.21: unified escape sequence validation for mdoc and man
checking is still incomplete, but a bit better, in particular for man
now in sync with 1.7.22: the only 1.7.22 diff was already in
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.4 2009/06/23 22:31:26 schwarze Exp $ */
d21 2
d38 1
d44 2
a46 1
static	int	  check_root(POSTARGS);
d48 3
d53 1
a53 3
static	v_post	  posts_ge1[] = { check_ge1, NULL };
static	v_post	  posts_eq0[] = { check_eq0, NULL };
static	v_post	  posts_ge2_le5[] = { check_ge2, check_le5, NULL };
d79 1
d171 1
d178 28
@


1.4
log
@sync to 1.7.20: root and text validation for -man
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.3 2009/06/18 23:34:53 schwarze Exp $ */
d25 1
d122 1
a122 1
	int		 pos;
d127 15
a141 1
		if ('\t' == *p || isprint((u_char)*p))
@


1.3
log
@sync to 1.7.19: improved comment handling
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.2 2009/06/14 23:00:57 schwarze Exp $ */
a25 2
/* FIXME: validate text. */

a33 1
static	int	  count(const struct man_node *);
d40 2
d87 1
a87 1
		/* FALLTHROUGH */
d89 1
a89 1
		return(1);
d104 31
a134 8
static inline int
count(const struct man_node *n)
{ 
	int		 i;

	for (i = 0; n; n = n->next, i++) 
		/* Loop. */ ;
	return(i);
d142 1
a142 2
	int		 c; \
	if ((c = count(n->child)) ineq (x)) \
d146 1
a146 1
			#ineq, (x), c)); \
@


1.2
log
@sync to 1.7.16: comments, whitespace and spelling fixes; no functional change
@
text
@d1 1
a1 1
/*	$Id: man_validate.c,v 1.9 2009/06/10 20:18:43 kristaps Exp $ */
d51 1
a51 1
	{ NULL }, /* __ */
a71 1
	{ posts_eq0 }, /* br */
@


1.1
log
@Initial check-in of mandoc for formatting manuals. ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: man_validate.c,v 1.7 2009/04/05 16:34:22 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@

