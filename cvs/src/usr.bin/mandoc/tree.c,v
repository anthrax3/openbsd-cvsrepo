head	1.41;
access;
symbols
	OPENBSD_6_1:1.40.0.4
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.36.0.4
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.33.0.4
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.6
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.41
date	2017.04.24.23.06.09;	author schwarze;	state Exp;
branches;
next	1.40;
commitid	2CfzvK3gmiJH7vY0;

1.40
date	2017.02.10.15.44.31;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	jWIgaURhUN1Qo7t2;

1.39
date	2017.01.12.17.29.34;	author schwarze;	state Exp;
branches;
next	1.38;
commitid	br53AOBoaygejdCJ;

1.38
date	2017.01.10.13.46.53;	author schwarze;	state Exp;
branches;
next	1.37;
commitid	aFt8sLe7F06PjFYh;

1.37
date	2017.01.10.12.54.28;	author schwarze;	state Exp;
branches;
next	1.36;
commitid	vzXxeQWxUqXTMW9w;

1.36
date	2015.10.12.00.07.27;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	Ql2ha5NS80pwfGNT;

1.35
date	2015.09.26.12.54.18;	author schwarze;	state Exp;
branches;
next	1.34;
commitid	qpHG1huIz9GDGO4c;

1.34
date	2015.09.26.00.53.15;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	191tWtskbsgcpQqV;

1.33
date	2015.04.18.17.50.02;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	sjmmdLSx1e3Vat0h;

1.32
date	2015.04.18.16.04.40;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	6MYJ7cd8mhJ77AGH;

1.31
date	2015.04.02.22.06.17;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	Rfx1oTaH3hZ7Zcyf;

1.30
date	2015.04.02.21.03.18;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	lmErjWY2O9ooA6RY;

1.29
date	2015.02.05.00.13.34;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	yNql0K85SrSgftGW;

1.28
date	2015.02.03.18.37.39;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	s48q7cVxviiIZfZ7;

1.27
date	2014.11.28.05.51.29;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	9LYX9vvoCC2fp5xR;

1.26
date	2014.10.20.01.43.06;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	PyUxUoAohRvdBqrn;

1.25
date	2014.10.13.21.05.59;	author chl;	state Exp;
branches;
next	1.24;
commitid	fJm0qpZP8XFQmz67;

1.24
date	2014.10.10.15.25.06;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	MpqXOG3dhTX11YQI;

1.23
date	2014.10.09.15.32.22;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	8T93cppf4UIYDPKl;

1.22
date	2014.07.02.07.10.17;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	zPkntUZW1pKIaIwi;

1.21
date	2014.04.20.16.44.44;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2014.03.08.15.50.21;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2013.12.24.19.10.34;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2013.09.15.17.33.47;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2013.05.18.17.08.09;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2011.09.18.10.25.28;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2011.04.24.16.22.02;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2011.03.20.23.36.42;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2011.02.10.00.06.30;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.16.01.11.50;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.04.22.28.17;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.13.01.09.13;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.29.17.10.30;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.27.21.54.42;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2010.05.23.22.45.01;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2009.12.22.23.58.00;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.21.19.13.51;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.21.20.57.57;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.22.20.14.37;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.14.23.00.57;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.06.20.30.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Continue parser unification:
* Make enum rofft an internal interface as enum roff_tok in "roff.h".
* Represent mdoc and man macros in enum roff_tok.
* Make TOKEN_NONE a proper enum value and use it throughout.
* Put the prologue macros first in the macro tables.
* Unify mdoc_macroname[] and man_macroname[] into roff_name[].
@
text
@/*	$OpenBSD: tree.c,v 1.40 2017/02/10 15:44:31 schwarze Exp $ */
/*
 * Copyright (c) 2008, 2009, 2011, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2013, 2014, 2015, 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "man.h"
#include "main.h"

static	void	print_box(const struct eqn_box *, int);
static	void	print_man(const struct roff_node *, int);
static	void	print_meta(const struct roff_meta *);
static	void	print_mdoc(const struct roff_node *, int);
static	void	print_span(const struct tbl_span *, int);


void
tree_mdoc(void *arg, const struct roff_man *mdoc)
{
	print_meta(&mdoc->meta);
	putchar('\n');
	print_mdoc(mdoc->first->child, 0);
}

void
tree_man(void *arg, const struct roff_man *man)
{
	print_meta(&man->meta);
	if (man->meta.hasbody == 0)
		puts("body  = empty");
	putchar('\n');
	print_man(man->first->child, 0);
}

static void
print_meta(const struct roff_meta *meta)
{
	if (meta->title != NULL)
		printf("title = \"%s\"\n", meta->title);
	if (meta->name != NULL)
		printf("name  = \"%s\"\n", meta->name);
	if (meta->msec != NULL)
		printf("sec   = \"%s\"\n", meta->msec);
	if (meta->vol != NULL)
		printf("vol   = \"%s\"\n", meta->vol);
	if (meta->arch != NULL)
		printf("arch  = \"%s\"\n", meta->arch);
	if (meta->os != NULL)
		printf("os    = \"%s\"\n", meta->os);
	if (meta->date != NULL)
		printf("date  = \"%s\"\n", meta->date);
}

static void
print_mdoc(const struct roff_node *n, int indent)
{
	const char	 *p, *t;
	int		  i, j;
	size_t		  argc;
	struct mdoc_argv *argv;

	if (n == NULL)
		return;

	argv = NULL;
	argc = 0;
	t = p = NULL;

	switch (n->type) {
	case ROFFT_ROOT:
		t = "root";
		break;
	case ROFFT_BLOCK:
		t = "block";
		break;
	case ROFFT_HEAD:
		t = "head";
		break;
	case ROFFT_BODY:
		if (n->end)
			t = "body-end";
		else
			t = "body";
		break;
	case ROFFT_TAIL:
		t = "tail";
		break;
	case ROFFT_ELEM:
		t = "elem";
		break;
	case ROFFT_TEXT:
		t = "text";
		break;
	case ROFFT_TBL:
		break;
	case ROFFT_EQN:
		t = "eqn";
		break;
	default:
		abort();
	}

	switch (n->type) {
	case ROFFT_TEXT:
		p = n->string;
		break;
	case ROFFT_BODY:
		p = roff_name[n->tok];
		break;
	case ROFFT_HEAD:
		p = roff_name[n->tok];
		break;
	case ROFFT_TAIL:
		p = roff_name[n->tok];
		break;
	case ROFFT_ELEM:
		p = roff_name[n->tok];
		if (n->args) {
			argv = n->args->argv;
			argc = n->args->argc;
		}
		break;
	case ROFFT_BLOCK:
		p = roff_name[n->tok];
		if (n->args) {
			argv = n->args->argv;
			argc = n->args->argc;
		}
		break;
	case ROFFT_TBL:
		break;
	case ROFFT_EQN:
		p = "EQ";
		break;
	case ROFFT_ROOT:
		p = "root";
		break;
	default:
		abort();
	}

	if (n->span) {
		assert(NULL == p && NULL == t);
		print_span(n->span, indent);
	} else {
		for (i = 0; i < indent; i++)
			putchar(' ');

		printf("%s (%s)", p, t);

		for (i = 0; i < (int)argc; i++) {
			printf(" -%s", mdoc_argnames[argv[i].arg]);
			if (argv[i].sz > 0)
				printf(" [");
			for (j = 0; j < (int)argv[i].sz; j++)
				printf(" [%s]", argv[i].value[j]);
			if (argv[i].sz > 0)
				printf(" ]");
		}

		putchar(' ');
		if (NODE_DELIMO & n->flags)
			putchar('(');
		if (NODE_LINE & n->flags)
			putchar('*');
		printf("%d:%d", n->line, n->pos + 1);
		if (NODE_DELIMC & n->flags)
			putchar(')');
		if (NODE_EOS & n->flags)
			putchar('.');
		if (NODE_BROKEN & n->flags)
			printf(" BROKEN");
		if (NODE_NOSRC & n->flags)
			printf(" NOSRC");
		if (NODE_NOPRT & n->flags)
			printf(" NOPRT");
		putchar('\n');
	}

	if (n->eqn)
		print_box(n->eqn->root->first, indent + 4);
	if (n->child)
		print_mdoc(n->child, indent +
		    (n->type == ROFFT_BLOCK ? 2 : 4));
	if (n->next)
		print_mdoc(n->next, indent);
}

static void
print_man(const struct roff_node *n, int indent)
{
	const char	 *p, *t;
	int		  i;

	if (n == NULL)
		return;

	t = p = NULL;

	switch (n->type) {
	case ROFFT_ROOT:
		t = "root";
		break;
	case ROFFT_ELEM:
		t = "elem";
		break;
	case ROFFT_TEXT:
		t = "text";
		break;
	case ROFFT_BLOCK:
		t = "block";
		break;
	case ROFFT_HEAD:
		t = "head";
		break;
	case ROFFT_BODY:
		t = "body";
		break;
	case ROFFT_TBL:
		break;
	case ROFFT_EQN:
		t = "eqn";
		break;
	default:
		abort();
	}

	switch (n->type) {
	case ROFFT_TEXT:
		p = n->string;
		break;
	case ROFFT_ELEM:
	case ROFFT_BLOCK:
	case ROFFT_HEAD:
	case ROFFT_BODY:
		p = roff_name[n->tok];
		break;
	case ROFFT_ROOT:
		p = "root";
		break;
	case ROFFT_TBL:
		break;
	case ROFFT_EQN:
		p = "EQ";
		break;
	default:
		abort();
	}

	if (n->span) {
		assert(NULL == p && NULL == t);
		print_span(n->span, indent);
	} else {
		for (i = 0; i < indent; i++)
			putchar(' ');
		printf("%s (%s) ", p, t);
		if (NODE_LINE & n->flags)
			putchar('*');
		printf("%d:%d", n->line, n->pos + 1);
		if (NODE_EOS & n->flags)
			putchar('.');
		putchar('\n');
	}

	if (n->eqn)
		print_box(n->eqn->root->first, indent + 4);
	if (n->child)
		print_man(n->child, indent +
		    (n->type == ROFFT_BLOCK ? 2 : 4));
	if (n->next)
		print_man(n->next, indent);
}

static void
print_box(const struct eqn_box *ep, int indent)
{
	int		 i;
	const char	*t;

	static const char *posnames[] = {
	    NULL, "sup", "subsup", "sub",
	    "to", "from", "fromto",
	    "over", "sqrt", NULL };

	if (NULL == ep)
		return;
	for (i = 0; i < indent; i++)
		putchar(' ');

	t = NULL;
	switch (ep->type) {
	case EQN_ROOT:
		t = "eqn-root";
		break;
	case EQN_LISTONE:
	case EQN_LIST:
		t = "eqn-list";
		break;
	case EQN_SUBEXPR:
		t = "eqn-expr";
		break;
	case EQN_TEXT:
		t = "eqn-text";
		break;
	case EQN_PILE:
		t = "eqn-pile";
		break;
	case EQN_MATRIX:
		t = "eqn-matrix";
		break;
	}

	fputs(t, stdout);
	if (ep->pos)
		printf(" pos=%s", posnames[ep->pos]);
	if (ep->left)
		printf(" left=\"%s\"", ep->left);
	if (ep->right)
		printf(" right=\"%s\"", ep->right);
	if (ep->top)
		printf(" top=\"%s\"", ep->top);
	if (ep->bottom)
		printf(" bottom=\"%s\"", ep->bottom);
	if (ep->text)
		printf(" text=\"%s\"", ep->text);
	if (ep->font)
		printf(" font=%d", ep->font);
	if (ep->size != EQN_DEFSIZE)
		printf(" size=%d", ep->size);
	if (ep->expectargs != UINT_MAX && ep->expectargs != ep->args)
		printf(" badargs=%zu(%zu)", ep->args, ep->expectargs);
	else if (ep->args)
		printf(" args=%zu", ep->args);
	putchar('\n');

	print_box(ep->first, indent + 4);
	print_box(ep->next, indent);
}

static void
print_span(const struct tbl_span *sp, int indent)
{
	const struct tbl_dat *dp;
	int		 i;

	for (i = 0; i < indent; i++)
		putchar(' ');

	switch (sp->pos) {
	case TBL_SPAN_HORIZ:
		putchar('-');
		return;
	case TBL_SPAN_DHORIZ:
		putchar('=');
		return;
	default:
		break;
	}

	for (dp = sp->first; dp; dp = dp->next) {
		switch (dp->pos) {
		case TBL_DATA_HORIZ:
		case TBL_DATA_NHORIZ:
			putchar('-');
			continue;
		case TBL_DATA_DHORIZ:
		case TBL_DATA_NDHORIZ:
			putchar('=');
			continue;
		default:
			break;
		}
		printf("[\"%s\"", dp->string ? dp->string : "");
		if (dp->spans)
			printf("(%d)", dp->spans);
		if (NULL == dp->layout)
			putchar('*');
		putchar(']');
		putchar(' ');
	}

	printf("(tbl) %d:1\n", sp->line);
}
@


1.40
log
@In -Ttree output mode, show the BROKEN node flag and
provide a -Onoval output option to show the unvalidated tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.39 2017/01/12 17:29:34 schwarze Exp $ */
d130 1
a130 1
		p = mdoc_macronames[n->tok];
d133 1
a133 1
		p = mdoc_macronames[n->tok];
d136 1
a136 1
		p = mdoc_macronames[n->tok];
d139 1
a139 1
		p = mdoc_macronames[n->tok];
d146 1
a146 1
		p = mdoc_macronames[n->tok];
d258 1
a258 1
		p = man_macronames[n->tok];
@


1.39
log
@show meta data for -Ttree output
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.38 2017/01/10 13:46:53 schwarze Exp $ */
d193 2
@


1.38
log
@unify names of AST node flags; no change of cpp output
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.37 2017/01/10 12:54:28 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
d34 1
d42 2
a43 1

d50 6
d57 17
a73 1
	print_man(man->first->child, 0);
@


1.37
log
@Introduce flags NODE_NOSRC and NODE_NOPRT for AST nodes.
Use them to mark generated nodes and nodes that shall not produce output.
Let -Ttree output mode display these new flags.
Use NODE_NOSRC for .Ar, .Mt, and .Pa default arguments.
Use NODE_NOPRT for .Dd, .Dt, and .Os.

These will help to make handling of text production macros more rigorous.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.36 2015/10/12 00:07:27 schwarze Exp $ */
d160 1
a160 1
		if (MDOC_DELIMO & n->flags)
d162 1
a162 1
		if (MDOC_LINE & n->flags)
d165 1
a165 1
		if (MDOC_DELIMC & n->flags)
d167 1
a167 1
		if (MDOC_EOS & n->flags)
d253 1
a253 1
		if (MAN_LINE & n->flags)
d256 1
a256 1
		if (MAN_EOS & n->flags)
@


1.36
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.35 2015/09/26 12:54:18 schwarze Exp $ */
d169 4
@


1.35
log
@Show the flags MDOC_DELIMO, MDOC_DELIMC, MDOC_EOS, and MAN_EOS.
Drop the "block-" prefixes from the node type names.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.34 2015/09/26 00:53:15 schwarze Exp $ */
a224 1
		/* FALLTHROUGH */
a225 1
		/* FALLTHROUGH */
a226 1
		/* FALLTHROUGH */
a354 1
			/* FALLTHROUGH */
a358 1
			/* FALLTHROUGH */
@


1.34
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.33 2015/04/18 17:50:02 schwarze Exp $ */
d75 1
a75 1
		t = "block-head";
d81 1
a81 1
			t = "block-body";
d84 1
a84 1
		t = "block-tail";
d160 2
d164 6
a169 1
		printf("%d:%d\n", n->line, n->pos + 1);
d206 1
a206 1
		t = "block-head";
d209 1
a209 1
		t = "block-body";
d254 4
a257 1
		printf("%d:%d\n", n->line, n->pos + 1);
@


1.33
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.32 2015/04/18 16:04:40 schwarze Exp $ */
a98 1
		/* NOTREACHED */
a137 1
		/* NOTREACHED */
a210 1
		/* NOTREACHED */
a235 1
		/* NOTREACHED */
@


1.32
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.31 2015/04/02 22:06:17 schwarze Exp $ */
d42 1
a42 1
	print_mdoc(mdoc_node(mdoc)->child, 0);
d49 1
a49 1
	print_man(man_node(man)->child, 0);
@


1.31
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.30 2015/04/02 21:03:18 schwarze Exp $ */
d39 1
a39 1
tree_mdoc(void *arg, const struct mdoc *mdoc)
d46 1
a46 1
tree_man(void *arg, const struct man *man)
@


1.30
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.29 2015/02/05 00:13:34 schwarze Exp $ */
d33 2
a34 2
static	void	print_man(const struct man_node *, int);
static	void	print_mdoc(const struct mdoc_node *, int);
d53 1
a53 1
print_mdoc(const struct mdoc_node *n, int indent)
d177 1
a177 1
print_man(const struct man_node *n, int indent)
@


1.29
log
@Simplify by deleting the "lastline" member of struct mdoc_node.
Minus one struct member, minus 17 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.28 2015/02/03 18:37:39 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d27 1
d68 1
a68 1
	case MDOC_ROOT:
d71 1
a71 1
	case MDOC_BLOCK:
d74 1
a74 1
	case MDOC_HEAD:
d77 1
a77 1
	case MDOC_BODY:
d83 1
a83 1
	case MDOC_TAIL:
d86 1
a86 1
	case MDOC_ELEM:
d89 1
a89 1
	case MDOC_TEXT:
d92 1
a92 1
	case MDOC_TBL:
d94 1
a94 1
	case MDOC_EQN:
d103 1
a103 1
	case MDOC_TEXT:
d106 1
a106 1
	case MDOC_BODY:
d109 1
a109 1
	case MDOC_HEAD:
d112 1
a112 1
	case MDOC_TAIL:
d115 1
a115 1
	case MDOC_ELEM:
d122 1
a122 1
	case MDOC_BLOCK:
d129 1
a129 1
	case MDOC_TBL:
d131 1
a131 1
	case MDOC_EQN:
d134 1
a134 1
	case MDOC_ROOT:
d171 1
a171 1
		    (n->type == MDOC_BLOCK ? 2 : 4));
d188 1
a188 1
	case MAN_ROOT:
d191 1
a191 1
	case MAN_ELEM:
d194 1
a194 1
	case MAN_TEXT:
d197 1
a197 1
	case MAN_BLOCK:
d200 1
a200 1
	case MAN_HEAD:
d203 1
a203 1
	case MAN_BODY:
d206 1
a206 1
	case MAN_TBL:
d208 1
a208 1
	case MAN_EQN:
d217 1
a217 1
	case MAN_TEXT:
d220 1
a220 1
	case MAN_ELEM:
d222 1
a222 1
	case MAN_BLOCK:
d224 1
a224 1
	case MAN_HEAD:
d226 1
a226 1
	case MAN_BODY:
d229 1
a229 1
	case MAN_ROOT:
d232 1
a232 1
	case MAN_TBL:
d234 1
a234 1
	case MAN_EQN:
d258 1
a258 1
		    (n->type == MAN_BLOCK ? 2 : 4));
@


1.28
log
@reduce indentation for better readability
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.27 2014/11/28 05:51:29 schwarze Exp $ */
d163 1
a163 4
		printf("%d:%d", n->line, n->pos + 1);
		if (n->lastline != n->line)
			printf("-%d", n->lastline);
		putchar('\n');
@


1.27
log
@Simplify by making many functions in the man(7) parser void,
and some cleanup; no functional change, minus 70 lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.26 2014/10/20 01:43:06 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d41 1
a41 1
	print_mdoc(mdoc_node(mdoc), 0);
d48 1
a48 1
	print_man(man_node(man), 0);
d59 3
d146 1
a146 1
			putchar('\t');
d170 1
a170 1
		print_box(n->eqn->root->first, indent + 1);
d172 2
a173 1
		print_mdoc(n->child, indent + 1);
d184 3
d249 1
a249 1
			putchar('\t');
d257 1
a257 1
		print_box(n->eqn->root->first, indent + 1);
d259 2
a260 1
		print_man(n->child, indent + 1);
d279 1
a279 1
		putchar('\t');
d327 1
a327 1
	print_box(ep->first, indent + 1);
d338 1
a338 1
		putchar('\t');
@


1.26
log
@show the {MDOC,MAN}_EQN node, it contains interesting information,
in particular line and column numbers and flags;
but hide the uninteresting EQN_ROOT box
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.25 2014/10/13 21:05:59 chl Exp $ */
a200 3
	case MAN_TAIL:
		t = "block-tail";
		break;
a219 2
		/* FALLTHROUGH */
	case MAN_TAIL:
@


1.25
log
@Add missing */ after $OpenBSD$ tag

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.24 2014/10/10 15:25:06 schwarze Exp $ */
d89 1
a89 1
		/* FALLTHROUGH */
d91 1
d126 1
a126 1
		/* FALLTHROUGH */
d128 1
a140 3
	} else if (n->eqn) {
		assert(NULL == p && NULL == t);
		print_box(n->eqn->root, indent);
d166 2
d205 1
a205 1
		/* FALLTHROUGH */
d207 1
d233 1
a233 1
		/* FALLTHROUGH */
d235 1
a244 3
	} else if (n->eqn) {
		assert(NULL == p && NULL == t);
		print_box(n->eqn->root, indent);
d254 2
@


1.24
log
@Partial eqn(7) rewrite by kristaps@@ in order to get operator precedence right.
@
text
@d1 1
a1 1
/*	$OpenBSD$
@


1.23
log
@more readable eqn(7) -Ttree output; from kristaps@@
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.22 2014/07/02 07:10:17 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
d18 2
d266 5
d281 1
d291 3
d299 22
a320 7
	assert(t);
	printf("%s(size=%d, pos=%d, font=%d, mark=%d, pile=%d, l=\"%s\", r=\"%s\") %s\n",
	    t, EQN_DEFSIZE == ep->size ? 0 : ep->size,
	    ep->pos, ep->font, ep->mark, ep->pile,
	    ep->left ? ep->left : "",
	    ep->right ? ep->right : "",
	    ep->text ? ep->text : "");
@


1.22
log
@Change column display in -Ttree to be 1-based instead of 0-based
such that column numbers agree between messages and -Ttree.
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.21 2014/04/20 16:44:44 schwarze Exp $ */
d289 1
a289 1
	printf("%s(%d, %d, %d, %d, %d, \"%s\", \"%s\") %s\n",
d291 1
a291 1
	    ep->pos + 1, ep->font, ep->mark, ep->pile,
@


1.21
log
@KNF: case (FOO):  ->  case FOO, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.20 2014/03/08 15:50:21 schwarze Exp $ */
d159 1
a159 1
		printf("%d:%d", n->line, n->pos);
d249 1
a249 1
		printf("%d:%d\n", n->line, n->pos);
d291 1
a291 1
	    ep->pos, ep->font, ep->mark, ep->pile,
@


1.20
log
@To find out whether .TP head arguments are same-line or next-line arguments,
use the MAN_LINE flag instead of the man_node line member.
This is required such that user-defined macros wrapping .TP work correctly.

Issue found by Havard Eidnes in Tcl_NewStringObj(3), reported via
the NetBSD bug tracking system and Thomas Klausner <wiz at NetBSD>.
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.19 2013/12/24 19:10:34 schwarze Exp $ */
a34 1
/* ARGSUSED */
a41 2

/* ARGSUSED */
a48 1

d62 1
a62 1
	case (MDOC_ROOT):
d65 1
a65 1
	case (MDOC_BLOCK):
d68 1
a68 1
	case (MDOC_HEAD):
d71 1
a71 1
	case (MDOC_BODY):
d77 1
a77 1
	case (MDOC_TAIL):
d80 1
a80 1
	case (MDOC_ELEM):
d83 1
a83 1
	case (MDOC_TEXT):
d86 1
a86 1
	case (MDOC_TBL):
d88 1
a88 1
	case (MDOC_EQN):
d96 1
a96 1
	case (MDOC_TEXT):
d99 1
a99 1
	case (MDOC_BODY):
d102 1
a102 1
	case (MDOC_HEAD):
d105 1
a105 1
	case (MDOC_TAIL):
d108 1
a108 1
	case (MDOC_ELEM):
d115 1
a115 1
	case (MDOC_BLOCK):
d122 1
a122 1
	case (MDOC_TBL):
d124 1
a124 1
	case (MDOC_EQN):
d126 1
a126 1
	case (MDOC_ROOT):
a170 1

d180 1
a180 1
	case (MAN_ROOT):
d183 1
a183 1
	case (MAN_ELEM):
d186 1
a186 1
	case (MAN_TEXT):
d189 1
a189 1
	case (MAN_BLOCK):
d192 1
a192 1
	case (MAN_HEAD):
d195 1
a195 1
	case (MAN_BODY):
d198 1
a198 1
	case (MAN_TAIL):
d201 1
a201 1
	case (MAN_TBL):
d203 1
a203 1
	case (MAN_EQN):
d211 1
a211 1
	case (MAN_TEXT):
d214 1
a214 1
	case (MAN_ELEM):
d216 1
a216 1
	case (MAN_BLOCK):
d218 1
a218 1
	case (MAN_HEAD):
d220 1
a220 1
	case (MAN_TAIL):
d222 1
a222 1
	case (MAN_BODY):
d225 1
a225 1
	case (MAN_ROOT):
d228 1
a228 1
	case (MAN_TBL):
d230 1
a230 1
	case (MAN_EQN):
d271 1
a271 1
	case (EQN_ROOT):
d274 1
a274 1
	case (EQN_LIST):
d277 1
a277 1
	case (EQN_SUBEXPR):
d280 1
a280 1
	case (EQN_TEXT):
d283 1
a283 1
	case (EQN_MATRIX):
d289 6
a294 6
	printf("%s(%d, %d, %d, %d, %d, \"%s\", \"%s\") %s\n", 
		t, EQN_DEFSIZE == ep->size ? 0 : ep->size,
		ep->pos, ep->font, ep->mark, ep->pile, 
		ep->left ? ep->left : "",
		ep->right ? ep->right : "",
		ep->text ? ep->text : "");
d310 1
a310 1
	case (TBL_SPAN_HORIZ):
d313 1
a313 1
	case (TBL_SPAN_DHORIZ):
d322 1
a322 1
		case (TBL_DATA_HORIZ):
d324 1
a324 1
		case (TBL_DATA_NHORIZ):
d327 1
a327 1
		case (TBL_DATA_DHORIZ):
d329 1
a329 1
		case (TBL_DATA_NDHORIZ):
@


1.19
log
@When deciding whether two consecutive macros are on the same input line,
we have to compare the line where the first one *ends* (not where it begins)
to the line where the second one starts.
This fixes the bug that .Bk allowed output line breaks right after block
macros spanning more than one input line, even when the next macro follows
on the same line.
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.18 2013/09/15 17:33:47 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013 Ingo Schwarze <schwarze@@openbsd.org>
d251 4
a254 1
		printf("%s (%s) %d:%d\n", p, t, n->line, n->pos);
@


1.18
log
@For some mdoc(7) macros, it is (unfortunately) semantically significant
whether they are the first macro on the line or called by another macro.
To help debugging, indicate this property "first macro on a new input line"
by prefixing an asterisk to the line number in -Ttree output.
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.17 2013/05/18 17:08:09 schwarze Exp $ */
d4 1
d163 4
a166 1
		printf("%d:%d\n", n->line, n->pos);
@


1.17
log
@Remove the variable sz because it's invariantly == 0,
along with the dead code testing whether it's positive.
Reported by Ulrich Spoerlein <uqs@@spoerlein.net>,
found by Coverity Scan CID 975717.

While here, remove the now unused **params array as well,
which Coverity apparently missed, at least it wasn't reported...
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.16 2011/09/18 10:25:28 schwarze Exp $ */
d158 5
a162 2
		
		printf(" %d:%d\n", n->line, n->pos);
@


1.16
log
@sync to version 1.11.5:
adding an implementation of the eqn(7) language
by kristaps@@

So far, only .EQ/.EN blocks are handled, in-line equations are not, and
rendering is not yet very pretty, but the parser is fairly complete.
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.15 2011/04/24 16:22:02 schwarze Exp $ */
d57 1
a57 2
	size_t		  argc, sz;
	char		**params;
d61 1
a61 2
	argc = sz = 0;
	params = NULL;
a158 3
		for (i = 0; i < (int)sz; i++)
			printf(" [%s]", params[i]);

@


1.15
log
@Merge version 1.11.1:
Again lots of cleanup and maintenance work by kristaps@@.
- simplify error reporting: less function pointers, more mandoc_[v]msg
- main: split document parsing out of main.c into read.c
- roff, mdoc, man: improved recognition of control characters
- roff: better handling of if/else stack overflows
- roff: add some predefined strings for backward compatibility
- mdoc, man: empty sections are not errors
- mdoc: move delimiter handling to libmdoc
- some header restructuring and some minor features and fixes
This merge causes two minor regressions
that i will fix in separate commits right afterwards.
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.14 2011/03/20 23:36:42 schwarze Exp $ */
d18 1
d28 2
a30 1
static	void	print_man(const struct man_node *, int);
d64 1
d92 1
a92 2
		t = "tbl";
		break;
a93 1
		t = "eqn";
a99 2
	p = NULL;

d128 1
a128 1
		break;
a129 1
		p = n->eqn->data;
d140 1
a140 1
		assert(NULL == p);
d142 3
d164 1
a164 1
		printf(" %d:%d", n->line, n->pos);
a166 2
	putchar('\n');

d180 2
d205 1
a205 2
		t = "tbl";
		break;
a206 1
		t = "eqn";
a212 2
	p = NULL;

d232 1
a232 1
		break;
a233 1
		p = n->eqn->data;
d241 1
a241 1
		assert(NULL == p);
d243 3
d249 1
a249 1
		printf("%s (%s) %d:%d", p, t, n->line, n->pos);
a251 2
	putchar('\n');

d259 42
d344 1
a344 1
	printf("(tbl) %d:1", sp->line);
@


1.14
log
@Import the foundation for eqn(7) support.
Written by kristaps@@.

For now, i'm adding one line to each of the four frontends
to just pass the input text through to the output,
not yet interpreting any of then eqn keywords.
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.13 2011/02/10 00:06:30 schwarze Exp $ */
d200 3
d225 2
@


1.13
log
@Tbl code maintenance by kristaps@@.
- Remember the line-number of a tbl_span, and use it in messages.
- Put *_span_alloc() functions right into the *_addspan() ones,
  since these are the only places they are called from.
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.12 2011/01/16 01:11:50 schwarze Exp $ */
d91 3
d130 3
d203 3
d230 3
@


1.12
log
@Various tbl improvements from kristaps@@:
* horizontal lines do not consume layout lines
* skip excessive data cells
* prepare rendering of spanned cells
* support vertical spans
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.11 2011/01/04 22:28:17 schwarze Exp $ */
a252 2
	printf("tbl: ");

d285 1
a285 2
		if (dp->next)
			putchar(' ');
d287 2
@


1.11
log
@Merge kristaps@@' cleaner tbl integration, removing mine;
there are still a few bugs, but fixing these will be easier in tree.
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.10 2010/07/13 01:09:13 schwarze Exp $ */
d281 6
a286 1
		printf("[%s%s]", dp->string, dp->layout ?  "" : "*");
@


1.10
log
@Merge release 1.10.4 (all code by kristaps@@), providing four new features:
1) Proper .Bk support: allow output line breaks at input line breaks,
but keep input lines together in the output, finally fixing
synopses like aucat(1), mail(1) and tmux(1).
2) Mostly finished -Tps (PostScript) output.
3) Implement -Thtml output for .Nm blocks and .Bk -words.
4) Allow iterative interpolation of user-defined roff(7) strings.
Also contains some minor bugfixes and some performance improvements.
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.9 2010/06/29 17:10:30 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
d29 1
d88 3
d96 2
d125 2
d135 21
a155 3
	for (i = 0; i < indent; i++)
		(void)printf("    ");
	(void)printf("%s (%s)", p, t);
d157 1
a157 8
	for (i = 0; i < (int)argc; i++) {
		(void)printf(" -%s", mdoc_argnames[argv[i].arg]);
		if (argv[i].sz > 0)
			(void)printf(" [");
		for (j = 0; j < (int)argv[i].sz; j++)
			(void)printf(" [%s]", argv[i].value[j]);
		if (argv[i].sz > 0)
			(void)printf(" ]");
d160 1
a160 4
	for (i = 0; i < (int)sz; i++)
		(void)printf(" [%s]", params[i]);

	(void)printf(" %d:%d\n", n->line, n->pos);
d194 3
d202 2
d220 2
d227 10
a236 3
	for (i = 0; i < indent; i++)
		(void)printf("    ");
	(void)printf("%s (%s) %d:%d\n", p, t, n->line, n->pos);
d242 43
@


1.9
log
@Support for badly nested blocks, written around the time of
the Rostock mandoc hackathon and tested and polished since,
supporting constructs like:

.Ao Bo    Ac    Bc        (exp breaking exp)
.Aq Bo    eol   Bc        (imp breaking exp)
.Ao Bq    Ac    eol       (exp breaking imp)
.Ao Bo So Bc    Ac  Sc    (double break, inner before outer)
.Ao Bo So Ac    Bc  Sc    (double break, outer before inner)
.Ao Bo    Ac So Bc  Sc    (broken breaker)
.Ao Bo So Bc Do Ac  Sc Dc (broken double breaker)

There are still two known issues which are tricky:

1) Breaking two identical explicit blocks (Ao Bo Bo Ac or Aq Bo Bo eol)
fails outright, triggering a bogus syntax error.
2) Breaking a block by two identical explicit blocks (Ao Ao Bo Ac Ac Bc
or Ao Ao Bq Ac Ac eol) still has a minor rendering error left:
"<ao1 <ao2 [bo ac2> ac1> bc]>" should not have the final ">".

We can fix these later in the tree, let's not grow this diff too large.

"get it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.8 2010/06/27 21:54:42 schwarze Exp $ */
a22 1
#include "regs.h"
@


1.8
log
@Full .nr nS support, unbreaking the kernel manuals.

Kristaps coded this from scratch after reading my .nr patch;
it is simpler and more powerful.

Registers live in struct regset in regs.h, struct man and struct mdoc
contain pointers to it.  The nS register is cleared when parsing .Sh.
Frontends respect the MDOC_SYNPRETTY flag set in mdoc node_alloc.
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.7 2010/05/23 22:45:01 schwarze Exp $ */
d74 4
a77 1
		t = "block-body";
@


1.7
log
@Unified error and warning message system for all of mandoc,
featuring three message levels, as agreed during the mandoc hackathon:
* FATAL parser failure, cannot produce any output from this input file:
  eventually, we hope to convert most of these to ERRORs.
* ERROR, meaning mandoc cannot cope fully with the input syntax and will
  probably lose information or produce structurally garbled output;
  it will try to produce output anyway but exit non-zero at the end,
  which is eventually intended to make the ports infrastructure happy.
* WARNING, meaning you should clean up the input file, but output
  is probably mostly OK, so this will not cause error-exit at the end.
This commit is mostly just converting the old system to the new one; before
the classification will become really reliable, we must check all messages.

In particular,
* set up a new central message string table in main.c
* drop the old message string tables from man.c and mdoc.c
* get rid of the piece-meal merr enums in libman and libmdoc
* reduce number of error/warning functions from 16 to 6 (still a lot...)

While here, handle a few problems more gracefully:
* allow .Rv and .Ex to work without a prior .Nm
* allow .An to ignore extra arguments
* allow undeclared columns in .Bl -column

Written by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.6 2009/12/22 23:58:00 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d23 1
@


1.6
log
@sync to 1.9.12, mostly portability and refactoring:

correctness/functionality:
- bugfix: do not die when overstep hits the right margin
- new option: -fign-escape
- and various HTML features

portability:
- replace bzero(3) by memset(3), which is ANSI C
- replace err(3)/warn(3) by perror(3)/exit(3), which is ANSI C
- iuse argv[0] instead of __progname
- add time.h to various files for FreeBSD compilation

simplicity:
- do not allocate header/footer data dynamically in *_term.c
- provide and use malloc frontends that error out on failure

for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.5 2009/10/21 19:13:51 schwarze Exp $ */
d22 1
@


1.5
log
@sync to 1.9.9, featuring:
 * -Thtml output mode
 * roff scaling units
 * and some minor fixes
for full changelogs, see http://bsd.lv/cgi-bin/cvsweb.cgi/
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.4 2009/09/21 20:57:57 schwarze Exp $ */
a17 1
#include <err.h>
d20 1
@


1.4
log
@sync to 1.9.5: make terminal_*, tree_* and out_* functions return void,
making the code simpler
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.3 2009/08/22 20:14:37 schwarze Exp $ */
d24 1
@


1.3
log
@Kristaps@@ significantly overhauled libman.
I'm committing this in one large chunk because in contrast to -mdoc, -man
is mostly untested in OpenBSD anyway, so any fallout can be fixed in-tree.
Among others, improved support for .IP, .HP, and .TP.
Now in sync with release 1.9.0.
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.2 2009/06/14 23:00:57 schwarze Exp $ */
d30 1
a30 1
int
a34 1
	return(1);
d39 1
a39 1
int
a43 1
	return(1);
@


1.2
log
@sync to 1.7.16: comments, whitespace and spelling fixes; no functional change
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.13 2009/06/10 20:18:44 kristaps Exp $ */
d166 9
d185 6
@


1.1
log
@Initial check-in of mandoc for formatting manuals. ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: tree.c,v 1.11 2009/04/03 11:08:39 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@

