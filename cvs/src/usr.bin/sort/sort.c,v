head	1.87;
access;
symbols
	OPENBSD_6_2:1.87.0.2
	OPENBSD_6_2_BASE:1.87
	OPENBSD_6_1:1.87.0.4
	OPENBSD_6_1_BASE:1.87
	OPENBSD_6_0:1.86.0.2
	OPENBSD_6_0_BASE:1.86
	OPENBSD_5_9:1.85.0.2
	OPENBSD_5_9_BASE:1.85
	OPENBSD_5_8:1.79.0.4
	OPENBSD_5_8_BASE:1.79
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.41.0.6
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.40.0.4
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.40.0.2
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.39.0.12
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.10
	OPENBSD_5_0:1.39.0.8
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.6
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.4
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.36.0.10
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.6
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.4
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.28.0.4
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.18.0.6
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.16.0.4
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.4
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.87
date	2017.01.04.15.30.58;	author millert;	state Exp;
branches;
next	1.86;
commitid	Dj95csFMflxZtQsE;

1.86
date	2016.07.14.08.31.18;	author semarie;	state Exp;
branches;
next	1.85;
commitid	X351wak6SvhlNPZD;

1.85
date	2015.10.24.15.19.01;	author millert;	state Exp;
branches;
next	1.84;
commitid	7pYljTK0mXYxvD8Q;

1.84
date	2015.10.18.17.02.03;	author millert;	state Exp;
branches;
next	1.83;
commitid	5Rld1oadeI77DqLR;

1.83
date	2015.10.17.14.33.01;	author tim;	state Exp;
branches;
next	1.82;
commitid	eBlpEurvUy9jcMnB;

1.82
date	2015.10.14.16.42.51;	author tobias;	state Exp;
branches;
next	1.81;
commitid	ulQkZqXKwmmzTDbv;

1.81
date	2015.10.13.16.55.03;	author tim;	state Exp;
branches;
next	1.80;
commitid	XlEjn3WeddO1l0gF;

1.80
date	2015.10.13.16.21.42;	author tim;	state Exp;
branches;
next	1.79;
commitid	vwwkJ9dIcssajRKX;

1.79
date	2015.04.05.13.56.04;	author millert;	state Exp;
branches;
next	1.78;
commitid	DXl00ApXT37Dgc6l;

1.78
date	2015.04.05.13.54.06;	author millert;	state Exp;
branches;
next	1.77;
commitid	sAAV09MVWRBezxxW;

1.77
date	2015.04.03.12.52.48;	author millert;	state Exp;
branches;
next	1.76;
commitid	FTdmA967qEQZIYWE;

1.76
date	2015.04.03.10.37.24;	author tobias;	state Exp;
branches;
next	1.75;
commitid	nXf2UNyH2xKwFRCp;

1.75
date	2015.04.03.10.07.25;	author tobias;	state Exp;
branches;
next	1.74;
commitid	MdfEZnT3gZsN2qHD;

1.74
date	2015.04.02.21.09.51;	author tobias;	state Exp;
branches;
next	1.73;
commitid	SkCxz1y7zT9d2Epy;

1.73
date	2015.04.02.21.04.06;	author tobias;	state Exp;
branches;
next	1.72;
commitid	4xhjGqOkKeWxcfx2;

1.72
date	2015.04.02.21.00.08;	author tobias;	state Exp;
branches;
next	1.71;
commitid	30Gc0vVu1521dWNU;

1.71
date	2015.04.02.20.57.34;	author tobias;	state Exp;
branches;
next	1.70;
commitid	ZP0nuYv9R0YBfa8r;

1.70
date	2015.04.02.20.56.00;	author tobias;	state Exp;
branches;
next	1.69;
commitid	qXZfLE2z2U8pEESY;

1.69
date	2015.04.02.12.43.08;	author millert;	state Exp;
branches;
next	1.68;
commitid	9ALNKELDr7MMsIiW;

1.68
date	2015.04.01.22.49.47;	author millert;	state Exp;
branches;
next	1.67;
commitid	2iqvysmqmuWQfS6y;

1.67
date	2015.04.01.22.24.02;	author millert;	state Exp;
branches;
next	1.66;
commitid	ColQstM88mDleyU6;

1.66
date	2015.04.01.21.45.50;	author millert;	state Exp;
branches;
next	1.65;
commitid	uRdUGVaxJFLtapFR;

1.65
date	2015.04.01.21.41.59;	author millert;	state Exp;
branches;
next	1.64;
commitid	6TJJUqWCiV2e601c;

1.64
date	2015.04.01.21.37.47;	author millert;	state Exp;
branches;
next	1.63;
commitid	vNZ48b8JU5AEQNJN;

1.63
date	2015.04.01.21.21.38;	author millert;	state Exp;
branches;
next	1.62;
commitid	P4p83PCQnpEcinpK;

1.62
date	2015.04.01.21.18.43;	author millert;	state Exp;
branches;
next	1.61;
commitid	WBK9OxkzvUVP5yE4;

1.61
date	2015.04.01.21.16.17;	author millert;	state Exp;
branches;
next	1.60;
commitid	oFpRon9UDUq6qmos;

1.60
date	2015.04.01.21.13.07;	author millert;	state Exp;
branches;
next	1.59;
commitid	pDUq2DCnreNBlenr;

1.59
date	2015.04.01.20.58.13;	author millert;	state Exp;
branches;
next	1.58;
commitid	OS48LOZcK83Cp0sj;

1.58
date	2015.04.01.20.28.04;	author millert;	state Exp;
branches;
next	1.57;
commitid	C1J0YsdhoPGqnOBg;

1.57
date	2015.04.01.20.24.12;	author millert;	state Exp;
branches;
next	1.56;
commitid	GuyeqcVgo0HEWEpM;

1.56
date	2015.04.01.20.20.22;	author millert;	state Exp;
branches;
next	1.55;
commitid	EiqDqmxrQZJMkibQ;

1.55
date	2015.04.01.20.10.19;	author millert;	state Exp;
branches;
next	1.54;
commitid	0R6B30eSPJJ8K1FT;

1.54
date	2015.04.01.19.56.01;	author millert;	state Exp;
branches;
next	1.53;
commitid	i1j3SkI4vpXKtHfr;

1.53
date	2015.03.31.16.40.16;	author millert;	state Exp;
branches;
next	1.52;
commitid	Lnrb4BtMehwhrRu1;

1.52
date	2015.03.31.12.16.02;	author millert;	state Exp;
branches;
next	1.51;
commitid	OmgX9EtmeUjXDm8H;

1.51
date	2015.03.31.11.46.26;	author millert;	state Exp;
branches;
next	1.50;
commitid	EAYJCZclsnzYWuWj;

1.50
date	2015.03.30.22.20.53;	author millert;	state Exp;
branches;
next	1.49;
commitid	CRclj4fmjIbkKBgZ;

1.49
date	2015.03.30.22.20.18;	author millert;	state Exp;
branches;
next	1.48;
commitid	FIe3GEYb8aIXufzf;

1.48
date	2015.03.20.23.04.07;	author millert;	state Exp;
branches;
next	1.47;
commitid	BzEjwG1TpdNW0jdh;

1.47
date	2015.03.20.00.26.38;	author millert;	state Exp;
branches;
next	1.46;
commitid	i16NLfKxN6YeVaWD;

1.46
date	2015.03.19.13.11.05;	author jmc;	state Exp;
branches;
next	1.45;
commitid	t7TgP8YwOYMXOk1z;

1.45
date	2015.03.19.11.38.12;	author jmc;	state Exp;
branches;
next	1.44;
commitid	FmWLmy14rBPoaP0G;

1.44
date	2015.03.17.17.45.13;	author millert;	state Exp;
branches;
next	1.43;
commitid	XCfT2rs68MOcwt0o;

1.43
date	2014.10.26.05.10.29;	author brad;	state Exp;
branches;
next	1.42;
commitid	CJ6GCOx3TKB5Bz6h;

1.42
date	2014.10.11.03.02.59;	author doug;	state Exp;
branches;
next	1.41;
commitid	nqF3Vhl7Dj07BiAr;

1.41
date	2013.11.13.15.07.27;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2012.10.30.20.03.16;	author gsoares;	state Exp;
branches;
next	1.39;

1.39
date	2009.12.22.19.47.02;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.28.20.41.39;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2009.10.27.23.59.43;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.08.22.06.56.40;	author jmc;	state Exp;
branches;
next	1.35;

1.35
date	2007.08.21.20.29.25;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.13.17.33.58;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2007.03.11.00.38.01;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.07.18.11.03;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2006.10.29.18.40.34;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2006.10.28.21.14.29;	author naddy;	state Exp;
branches;
next	1.29;

1.29
date	2006.10.18.23.30.43;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.04.15.10.27;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.28.10.10.16;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.27.23.40.07;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.11.21.04.48;	author moritz;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.14.22.57.21;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.17.18.24.49;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.26.00.12.39;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.10.22.20.51;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.03.02.56.16;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.30.23.11.41;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.16.21.27.52;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.17.19.51.34;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.04.21.27.01;	author ericj;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.19.17.58.18;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.30.16.00.23;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.11.30.16.41.41;	author espie;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	99.05.24.17.57.19;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.07.24.00.32.24;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.07.20.20.02.19;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	98.07.20.19.49.32;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.07.20.19.46.15;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.07.20.19.14.37;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.06.30.05.36.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.06.16.02.39.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.16.02.21.56;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.26.00.02.25;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.01.22.06.53.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.01.20.19.39.55;	author millert;	state Exp;
branches;
next	;

1.13.2.1
date	2000.10.06.21.16.17;	author jason;	state Exp;
branches;
next	;


desc
@@


1.87
log
@Fix a crash when "sort -m" is given no files.  From Julien Ramseier.
@
text
@/*	$OpenBSD: sort.c,v 1.86 2016/07/14 08:31:18 semarie Exp $	*/

/*-
 * Copyright (C) 2009 Gabor Kovesdan <gabor@@FreeBSD.org>
 * Copyright (C) 2012 Oleg Moskalenko <mom040267@@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/types.h>

#include <err.h>
#include <errno.h>
#include <getopt.h>
#include <limits.h>
#include <locale.h>
#include <md5.h>
#include <regex.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <wchar.h>
#include <wctype.h>

#include "coll.h"
#include "file.h"
#include "sort.h"

#ifdef GNUSORT_COMPATIBILITY
# define PERMUTE	""
#else
# define PERMUTE	"+"
#endif
#define	OPTIONS	PERMUTE"bCcdfgHhik:Mmno:RrS:st:T:uVz"

static bool need_random;
static const char *random_source;

MD5_CTX md5_ctx;

struct sort_opts sort_opts_vals;

bool debug_sort;
bool need_hint;

static bool gnusort_numeric_compatibility;

static struct sort_mods default_sort_mods_object;
struct sort_mods * const default_sort_mods = &default_sort_mods_object;

static bool print_symbols_on_debug;

/*
 * Arguments from file (when file0-from option is used:
 */
static size_t argc_from_file0 = (size_t)-1;
static char **argv_from_file0;

/*
 * Placeholder symbols for options which have no single-character equivalent
 */
enum {
	SORT_OPT = CHAR_MAX + 1,
	HELP_OPT,
	FF_OPT,
	BS_OPT,
	VERSION_OPT,
	DEBUG_OPT,
	RANDOMSOURCE_OPT,
	COMPRESSPROGRAM_OPT,
	QSORT_OPT,
	HEAPSORT_OPT,
	RADIXSORT_OPT,
	MMAP_OPT
};

#define	NUMBER_OF_MUTUALLY_EXCLUSIVE_FLAGS 6
static const char mutually_exclusive_flags[NUMBER_OF_MUTUALLY_EXCLUSIVE_FLAGS] = { 'M', 'n', 'g', 'R', 'h', 'V' };

static const struct option long_options[] = {
    { "batch-size", required_argument, NULL, BS_OPT },
    { "buffer-size", required_argument, NULL, 'S' },
    { "check", optional_argument, NULL, 'c' },
    { "check=silent|quiet", optional_argument, NULL, 'C' },
    { "compress-program", required_argument, NULL, COMPRESSPROGRAM_OPT },
    { "debug", no_argument, NULL, DEBUG_OPT },
    { "dictionary-order", no_argument, NULL, 'd' },
    { "field-separator", required_argument, NULL, 't' },
    { "files0-from", required_argument, NULL, FF_OPT },
    { "general-numeric-sort", no_argument, NULL, 'g' },
    { "heapsort", no_argument, NULL, HEAPSORT_OPT },
    { "help", no_argument, NULL, HELP_OPT },
    { "human-numeric-sort", no_argument, NULL, 'h' },
    { "ignore-leading-blanks", no_argument, NULL, 'b' },
    { "ignore-case", no_argument, NULL, 'f' },
    { "ignore-nonprinting", no_argument, NULL, 'i' },
    { "key", required_argument, NULL, 'k' },
    { "merge", no_argument, NULL, 'm' },
    { "mergesort", no_argument, NULL, 'H' },
    { "mmap", no_argument, NULL, MMAP_OPT },
    { "month-sort", no_argument, NULL, 'M' },
    { "numeric-sort", no_argument, NULL, 'n' },
    { "output", required_argument, NULL, 'o' },
    { "qsort", no_argument, NULL, QSORT_OPT },
    { "radixsort", no_argument, NULL, RADIXSORT_OPT },
    { "random-sort", no_argument, NULL, 'R' },
    { "random-source", required_argument, NULL, RANDOMSOURCE_OPT },
    { "reverse", no_argument, NULL, 'r' },
    { "sort", required_argument, NULL, SORT_OPT },
    { "stable", no_argument, NULL, 's' },
    { "temporary-directory", required_argument, NULL, 'T' },
    { "unique", no_argument, NULL, 'u' },
    { "version", no_argument, NULL, VERSION_OPT },
    { "version-sort", no_argument, NULL, 'V' },
    { "zero-terminated", no_argument, NULL, 'z' },
    { NULL, no_argument, NULL, 0 }
};

/*
 * Check where sort modifier is present
 */
static bool
sort_modifier_empty(struct sort_mods *sm)
{
	return !(sm->Mflag || sm->Vflag || sm->nflag || sm->gflag ||
	    sm->rflag || sm->Rflag || sm->hflag || sm->dflag || sm->fflag);
}

/*
 * Print out usage text.
 */
static __dead void
usage(int exit_val)
{
	fprintf(exit_val ? stderr : stdout,
	    "usage: %s [-bCcdfgHhiMmnRrsuVz] [-k field1[,field2]] [-o output] "
	    "[-S size]\n\t[-T dir] [-t char] [file ...]\n", getprogname());
	exit(exit_val);
}

/*
 * Read input file names from a file (file0-from option).
 */
static void
read_fns_from_file0(const char *fn)
{
	FILE *f;
	char *line = NULL;
	size_t linesize = 0;
	ssize_t linelen;

	f = fopen(fn, "r");
	if (f == NULL)
		err(2, "%s", fn);

	while ((linelen = getdelim(&line, &linesize, '\0', f)) != -1) {
		if (*line != '\0') {
			if (argc_from_file0 == (size_t)-1)
				argc_from_file0 = 0;
			++argc_from_file0;
			argv_from_file0 = sort_reallocarray(argv_from_file0,
			    argc_from_file0, sizeof(char *));
			argv_from_file0[argc_from_file0 - 1] = line;
		} else {
			free(line);
		}
		line = NULL;
		linesize = 0;
	}
	if (ferror(f))
		err(2, "%s: getdelim", fn);

	closefile(f, fn);
}

/*
 * Check how much RAM is available for the sort.
 */
static void
set_hw_params(void)
{
	unsigned long long free_memory;
	long long user_memory;
	struct rlimit rl;
	size_t len;
	int mib[] = { CTL_HW, HW_USERMEM64 };

	/* Get total user (non-kernel) memory. */
	len = sizeof(user_memory);
	if (sysctl(mib, 2, &user_memory, &len, NULL, 0) == -1)
	    user_memory = -1;

	/* Increase our data size to the max */
	if (getrlimit(RLIMIT_DATA, &rl) == 0) {
		free_memory = (unsigned long long)rl.rlim_cur;
		rl.rlim_cur = rl.rlim_max;
		if (setrlimit(RLIMIT_DATA, &rl) == 0) {
			free_memory = (unsigned long long)rl.rlim_max;
		} else {
			warn("Can't set resource limit to max data size");
		}
	} else {
		free_memory = 1000000;
		warn("Can't get resource limit for data size");
	}

	/* We prefer to use temp files rather than swap space. */
	if (user_memory != -1 && free_memory > user_memory)
		free_memory = user_memory;

	available_free_memory = free_memory / 2;
}

/*
 * Convert "plain" symbol to wide symbol, with default value.
 */
static void
conv_mbtowc(wchar_t *wc, const char *c, const wchar_t def)
{
	int res;

	res = mbtowc(wc, c, MB_CUR_MAX);
	if (res < 1)
		*wc = def;
}

/*
 * Set current locale symbols.
 */
static void
set_locale(void)
{
	struct lconv *lc;
	const char *locale;

	setlocale(LC_ALL, "");

	/* Obtain LC_NUMERIC info */
	lc = localeconv();

	/* Convert to wide char form */
	conv_mbtowc(&symbol_decimal_point, lc->decimal_point,
	    symbol_decimal_point);
	conv_mbtowc(&symbol_thousands_sep, lc->thousands_sep,
	    symbol_thousands_sep);
	conv_mbtowc(&symbol_positive_sign, lc->positive_sign,
	    symbol_positive_sign);
	conv_mbtowc(&symbol_negative_sign, lc->negative_sign,
	    symbol_negative_sign);

	if (getenv("GNUSORT_NUMERIC_COMPATIBILITY"))
		gnusort_numeric_compatibility = true;

	locale = setlocale(LC_COLLATE, NULL);
	if (locale != NULL) {
		char *tmpl;
		const char *byteclocale;

		tmpl = sort_strdup(locale);
		byteclocale = setlocale(LC_COLLATE, "C");
		if (byteclocale && strcmp(byteclocale, tmpl) == 0) {
			byte_sort = true;
		} else {
			byteclocale = setlocale(LC_COLLATE, "POSIX");
			if (byteclocale && strcmp(byteclocale, tmpl) == 0)
				byte_sort = true;
			else
				setlocale(LC_COLLATE, tmpl);
		}
		sort_free(tmpl);
	}
	if (!byte_sort)
		sort_mb_cur_max = MB_CUR_MAX;
}

/*
 * Set directory temporary files.
 */
static void
set_tmpdir(void)
{
	if (!issetugid()) {
		char *td;

		td = getenv("TMPDIR");
		if (td != NULL)
			tmpdir = td;
	}
}

/*
 * Parse -S option.
 */
static unsigned long long
parse_memory_buffer_value(const char *value)
{
	char *endptr;
	unsigned long long membuf;

	membuf = strtoll(value, &endptr, 10);
	if (endptr == value || (long long)membuf < 0 ||
	    (errno == ERANGE && membuf == LLONG_MAX))
		goto invalid;

	switch (*endptr) {
	case 'Y':
		if (membuf > ULLONG_MAX / 1024)
			goto invalid;
		membuf *= 1024;
		/* FALLTHROUGH */
	case 'Z':
		if (membuf > ULLONG_MAX / 1024)
			goto invalid;
		membuf *= 1024;
		/* FALLTHROUGH */
	case 'E':
		if (membuf > ULLONG_MAX / 1024)
			goto invalid;
		membuf *= 1024;
		/* FALLTHROUGH */
	case 'P':
		if (membuf > ULLONG_MAX / 1024)
			goto invalid;
		membuf *= 1024;
		/* FALLTHROUGH */
	case 'T':
		if (membuf > ULLONG_MAX / 1024)
			goto invalid;
		membuf *= 1024;
		/* FALLTHROUGH */
	case 'G':
		if (membuf > ULLONG_MAX / 1024)
			goto invalid;
		membuf *= 1024;
		/* FALLTHROUGH */
	case 'M':
		if (membuf > ULLONG_MAX / 1024)
			goto invalid;
		membuf *= 1024;
		/* FALLTHROUGH */
	case '\0':
	case 'K':
		if (membuf > ULLONG_MAX / 1024)
			goto invalid;
		membuf *= 1024;
		/* FALLTHROUGH */
	case 'b':
		break;
	case '%':
		if (available_free_memory != 0 &&
		    membuf > ULLONG_MAX / available_free_memory)
			goto invalid;
		membuf = (available_free_memory * membuf) /
		    100;
		break;
	default:
		warnc(EINVAL, "%s", optarg);
		membuf = available_free_memory;
	}
	if (membuf > SIZE_MAX)
		goto invalid;
	return membuf;
invalid:
	errx(2, "invalid memory buffer size: %s", value);
}

/*
 * Signal handler that clears the temporary files.
 */
static void
sig_handler(int sig __unused)
{
	clear_tmp_files();
	_exit(2);
}

/*
 * Set signal handler on panic signals.
 */
static void
set_signal_handler(void)
{
	struct sigaction sa;
	int i, signals[] = {SIGTERM, SIGHUP, SIGINT, SIGUSR1, SIGUSR2,
	    SIGPIPE, SIGXCPU, SIGXFSZ, 0};

	memset(&sa, 0, sizeof(sa));
	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = sig_handler;

	for (i = 0; signals[i] != 0; i++) {
		if (sigaction(signals[i], &sa, NULL) < 0) {
			warn("sigaction(%s)", strsignal(signals[i]));
			continue;
		}
	}
}

/*
 * Print "unknown" message and exit with status 2.
 */
static void
unknown(const char *what)
{
	errx(2, "Unknown feature: %s", what);
}

/*
 * Check whether contradictory input options are used.
 */
static void
check_mutually_exclusive_flags(char c, bool *mef_flags)
{
	int i, fo_index, mec;
	bool found_others, found_this;

	found_others = found_this = false;
	fo_index = 0;

	for (i = 0; i < NUMBER_OF_MUTUALLY_EXCLUSIVE_FLAGS; i++) {
		mec = mutually_exclusive_flags[i];

		if (mec != c) {
			if (mef_flags[i]) {
				if (found_this) {
					errx(2,
					    "%c:%c: mutually exclusive flags",
					    c, mec);
				}
				found_others = true;
				fo_index = i;
			}
		} else {
			if (found_others) {
				errx(2,
				    "%c:%c: mutually exclusive flags",
				    c, mutually_exclusive_flags[fo_index]);
			}
			mef_flags[i] = true;
			found_this = true;
		}
	}
}

/*
 * Initialise sort opts data.
 */
static void
set_sort_opts(void)
{
	memset(&default_sort_mods_object, 0,
	    sizeof(default_sort_mods_object));
	memset(&sort_opts_vals, 0, sizeof(sort_opts_vals));
	default_sort_mods_object.func =
	    get_sort_func(&default_sort_mods_object);
}

/*
 * Set a sort modifier on a sort modifiers object.
 */
static bool
set_sort_modifier(struct sort_mods *sm, int c)
{
	switch (c) {
	case 'b':
		sm->bflag = true;
		break;
	case 'd':
		sm->dflag = true;
		break;
	case 'f':
		sm->fflag = true;
		break;
	case 'g':
		sm->gflag = true;
		need_hint = true;
		break;
	case 'i':
		sm->iflag = true;
		break;
	case 'R':
		sm->Rflag = true;
		need_random = true;
		break;
	case 'M':
		initialise_months();
		sm->Mflag = true;
		need_hint = true;
		break;
	case 'n':
		sm->nflag = true;
		need_hint = true;
		print_symbols_on_debug = true;
		break;
	case 'r':
		sm->rflag = true;
		break;
	case 'V':
		sm->Vflag = true;
		break;
	case 'h':
		sm->hflag = true;
		need_hint = true;
		print_symbols_on_debug = true;
		break;
	default:
		return false;
	}
	sort_opts_vals.complex_sort = true;
	sm->func = get_sort_func(sm);

	return true;
}

/*
 * Parse POS in -k option.
 */
static int
parse_pos(const char *s, struct key_specs *ks, bool *mef_flags, bool second)
{
	regmatch_t pmatch[4];
	regex_t re;
	char *c, *f;
	const char *sregexp = "^([0-9]+)(\\.[0-9]+)?([bdfirMngRhV]+)?$";
	size_t len, nmatch;
	int ret;

	ret = -1;
	nmatch = 4;
	c = f = NULL;

	if (regcomp(&re, sregexp, REG_EXTENDED) != 0)
		return -1;

	if (regexec(&re, s, nmatch, pmatch, 0) != 0)
		goto end;

	if (pmatch[0].rm_eo <= pmatch[0].rm_so)
		goto end;

	if (pmatch[1].rm_eo <= pmatch[1].rm_so)
		goto end;

	len = pmatch[1].rm_eo - pmatch[1].rm_so;

	f = sort_malloc(len + 1);
	memcpy(f, s + pmatch[1].rm_so, len);
	f[len] = '\0';

	if (second) {
		errno = 0;
		ks->f2 = (size_t)strtoul(f, NULL, 10);
		if (errno != 0)
			goto end;
		if (ks->f2 == 0) {
			warn("0 field in key specs");
			goto end;
		}
	} else {
		errno = 0;
		ks->f1 = (size_t)strtoul(f, NULL, 10);
		if (errno != 0)
			goto end;
		if (ks->f1 == 0) {
			warn("0 field in key specs");
			goto end;
		}
	}

	if (pmatch[2].rm_eo > pmatch[2].rm_so) {
		len = pmatch[2].rm_eo - pmatch[2].rm_so - 1;

		c = sort_malloc(len + 1);
		memcpy(c, s + pmatch[2].rm_so + 1, len);
		c[len] = '\0';

		if (second) {
			errno = 0;
			ks->c2 = (size_t)strtoul(c, NULL, 10);
			if (errno != 0)
				goto end;
		} else {
			errno = 0;
			ks->c1 = (size_t)strtoul(c, NULL, 10);
			if (errno != 0)
				goto end;
			if (ks->c1 == 0) {
				warn("0 column in key specs");
				goto end;
			}
		}
	} else {
		if (second)
			ks->c2 = 0;
		else
			ks->c1 = 1;
	}

	if (pmatch[3].rm_eo > pmatch[3].rm_so) {
		regoff_t i = 0;

		for (i = pmatch[3].rm_so; i < pmatch[3].rm_eo; i++) {
			check_mutually_exclusive_flags(s[i], mef_flags);
			if (s[i] == 'b') {
				if (second)
					ks->pos2b = true;
				else
					ks->pos1b = true;
			} else if (!set_sort_modifier(&(ks->sm), s[i]))
				goto end;
		}
	}

	ret = 0;

end:
	sort_free(c);
	sort_free(f);
	regfree(&re);

	return ret;
}

/*
 * Parse -k option value.
 */
static int
parse_k(const char *s, struct key_specs *ks)
{
	int ret = -1;
	bool mef_flags[NUMBER_OF_MUTUALLY_EXCLUSIVE_FLAGS] =
	    { false, false, false, false, false, false };

	if (*s != '\0') {
		char *sptr;

		sptr = strchr(s, ',');
		if (sptr) {
			size_t size1;
			char *pos1, *pos2;

			size1 = sptr - s;

			if (size1 < 1)
				return -1;

			pos1 = sort_malloc(size1 + 1);
			memcpy(pos1, s, size1);
			pos1[size1] = '\0';

			ret = parse_pos(pos1, ks, mef_flags, false);

			sort_free(pos1);
			if (ret < 0)
				return ret;

			pos2 = sort_strdup(sptr + 1);
			ret = parse_pos(pos2, ks, mef_flags, true);
			sort_free(pos2);
		} else
			ret = parse_pos(s, ks, mef_flags, false);
	}

	return ret;
}

/*
 * Parse POS in +POS -POS option.
 */
static int
parse_pos_obs(const char *s, size_t *nf, size_t *nc, char *sopts, size_t sopts_size)
{
	regex_t re;
	regmatch_t pmatch[4];
	char *c, *f;
	const char *sregexp = "^([0-9]+)(\\.[0-9]+)?([A-Za-z]+)?$";
	int ret;
	size_t len, nmatch;

	ret = -1;
	nmatch = 4;
	c = f = NULL;
	*nc = *nf = 0;

	if (regcomp(&re, sregexp, REG_EXTENDED) != 0)
		return -1;

	if (regexec(&re, s, nmatch, pmatch, 0) != 0)
		goto end;

	if (pmatch[0].rm_eo <= pmatch[0].rm_so)
		goto end;

	if (pmatch[1].rm_eo <= pmatch[1].rm_so)
		goto end;

	len = pmatch[1].rm_eo - pmatch[1].rm_so;

	f = sort_malloc(len + 1);
	memcpy(f, s + pmatch[1].rm_so, len);
	f[len] = '\0';

	errno = 0;
	*nf = (size_t)strtoul(f, NULL, 10);
	if (errno != 0)
		errx(2, "Invalid key position");

	if (pmatch[2].rm_eo > pmatch[2].rm_so) {
		len = pmatch[2].rm_eo - pmatch[2].rm_so - 1;

		c = sort_malloc(len + 1);
		memcpy(c, s + pmatch[2].rm_so + 1, len);
		c[len] = '\0';

		errno = 0;
		*nc = (size_t)strtoul(c, NULL, 10);
		if (errno != 0)
			errx(2, "Invalid key position");
	}

	if (pmatch[3].rm_eo > pmatch[3].rm_so) {

		len = pmatch[3].rm_eo - pmatch[3].rm_so;

		if (len >= sopts_size)
			errx(2, "Invalid key position");
		memcpy(sopts, s + pmatch[3].rm_so, len);
		sopts[len] = '\0';
	}

	ret = 0;

end:
	sort_free(c);
	sort_free(f);
	regfree(&re);

	return ret;
}

/*
 * "Translate" obsolete +POS1 -POS2 syntax into new -kPOS1,POS2 syntax
 */
static void
fix_obsolete_keys(int *argc, char **argv)
{
	char sopt[129];
	int i;

	for (i = 1; i < *argc; i++) {
		const char *arg1 = argv[i];

		if (arg1[0] == '+') {
			size_t c1, f1;
			char sopts1[128];

			sopts1[0] = 0;
			c1 = f1 = 0;

			if (parse_pos_obs(arg1 + 1, &f1, &c1, sopts1,
			    sizeof(sopts1)) < 0)
				continue;

			f1 += 1;
			c1 += 1;
			if (i + 1 < *argc) {
				const char *arg2 = argv[i + 1];

				if (arg2[0] == '-') {
					size_t c2, f2;
					char sopts2[128];

					sopts2[0] = 0;
					c2 = f2 = 0;

					if (parse_pos_obs(arg2 + 1, &f2, &c2,
					    sopts2, sizeof(sopts2)) >= 0) {
						int j;
						if (c2 > 0)
							f2 += 1;
						snprintf(sopt, sizeof(sopt),
						    "-k%zu.%zu%s,%zu.%zu%s",
						    f1, c1, sopts1, f2,
						    c2, sopts2);
						argv[i] = sort_strdup(sopt);
						for (j = i + 1; j + 1 < *argc; j++)
							argv[j] = argv[j + 1];
						*argc -= 1;
						continue;
					}
				}
			}
			snprintf(sopt, sizeof(sopt), "-k%zu.%zu%s",
			    f1, c1, sopts1);
			argv[i] = sort_strdup(sopt);
		}
	}
}

/*
 * Set random seed
 */
static void
set_random_seed(void)
{
	if (!need_random)
		return;

	MD5Init(&md5_ctx);
	if (random_source != NULL) {
		unsigned char buf[BUFSIZ];
		size_t nr;
		FILE *fp;

		if ((fp = fopen(random_source, "r")) == NULL)
			err(2, "%s", random_source);
		while ((nr = fread(buf, 1, sizeof(buf), fp)) != 0)
			MD5Update(&md5_ctx, buf, nr);
		if (ferror(fp))
			err(2, "%s", random_source);
		fclose(fp);
	} else {
		unsigned char rsd[1024];

		arc4random_buf(rsd, sizeof(rsd));
		MD5Update(&md5_ctx, rsd, sizeof(rsd));
	}
}

/*
 * Main function.
 */
int
main(int argc, char *argv[])
{
	char *outfile, *real_outfile, *sflag;
	int c;
	size_t i;
	struct sort_mods *sm = &default_sort_mods_object;
	bool mef_flags[NUMBER_OF_MUTUALLY_EXCLUSIVE_FLAGS] =
	    { false, false, false, false, false, false };

	set_hw_params();

	if (pledge("stdio rpath wpath cpath fattr chown proc exec", NULL) == -1)
		err(2, "pledge");

	outfile = "-";
	real_outfile = NULL;
	sflag = NULL;

	init_tmp_files();

	set_signal_handler();

	atexit(clear_tmp_files);

	set_locale();
	set_tmpdir();
	set_sort_opts();

	fix_obsolete_keys(&argc, argv);

	while (((c = getopt_long(argc, argv, OPTIONS, long_options, NULL))
	    != -1)) {

		check_mutually_exclusive_flags(c, mef_flags);

		if (!set_sort_modifier(sm, c)) {
			switch (c) {
			case 'c':
				sort_opts_vals.cflag = true;
				if (optarg) {
					if (!strcmp(optarg, "diagnose-first"))
						;
					else if (!strcmp(optarg, "silent") ||
					    !strcmp(optarg, "quiet"))
						sort_opts_vals.csilentflag = true;
					else if (*optarg)
						unknown(optarg);
				}
				break;
			case 'C':
				sort_opts_vals.cflag = true;
				sort_opts_vals.csilentflag = true;
				break;
			case 'k':
			{
				sort_opts_vals.complex_sort = true;
				sort_opts_vals.kflag = true;

				keys = sort_reallocarray(keys, keys_num + 1,
				    sizeof(struct key_specs));
				memset(&(keys[keys_num]), 0,
				    sizeof(struct key_specs));
#ifndef GNUSORT_COMPATIBILITY
				keys[keys_num].pos1b = default_sort_mods->bflag;
				keys[keys_num].pos2b = default_sort_mods->bflag;
#endif

				if (parse_k(optarg, &(keys[keys_num++])) < 0)
					errc(2, EINVAL, "-k %s", optarg);

				break;
			}
			case 'm':
				sort_opts_vals.mflag = true;
				break;
			case 'o':
				outfile = optarg;
				break;
			case 's':
				sort_opts_vals.sflag = true;
				break;
			case 'S':
				sflag = optarg;
				break;
			case 'T':
				tmpdir = optarg;
				break;
			case 't':
				while (strlen(optarg) > 1) {
					if (optarg[0] != '\\') {
						errc(2, EINVAL, "%s", optarg);
					}
					optarg += 1;
					if (*optarg == '0') {
						*optarg = 0;
						break;
					}
				}
				sort_opts_vals.tflag = true;
				sort_opts_vals.field_sep = btowc(optarg[0]);
				if (sort_opts_vals.field_sep == WEOF) {
					errno = EINVAL;
					err(2, NULL);
				}
				if (!gnusort_numeric_compatibility) {
					if (symbol_decimal_point == sort_opts_vals.field_sep)
						symbol_decimal_point = WEOF;
					if (symbol_thousands_sep == sort_opts_vals.field_sep)
						symbol_thousands_sep = WEOF;
					if (symbol_negative_sign == sort_opts_vals.field_sep)
						symbol_negative_sign = WEOF;
					if (symbol_positive_sign == sort_opts_vals.field_sep)
						symbol_positive_sign = WEOF;
				}
				break;
			case 'u':
				sort_opts_vals.uflag = true;
				/* stable sort for the correct unique val */
				sort_opts_vals.sflag = true;
				break;
			case 'z':
				sort_opts_vals.zflag = true;
				break;
			case SORT_OPT:
				if (!strcmp(optarg, "general-numeric"))
					set_sort_modifier(sm, 'g');
				else if (!strcmp(optarg, "human-numeric"))
					set_sort_modifier(sm, 'h');
				else if (!strcmp(optarg, "numeric"))
					set_sort_modifier(sm, 'n');
				else if (!strcmp(optarg, "month"))
					set_sort_modifier(sm, 'M');
				else if (!strcmp(optarg, "random"))
					set_sort_modifier(sm, 'R');
				else
					unknown(optarg);
				break;
			case QSORT_OPT:
				sort_opts_vals.sort_method = SORT_QSORT;
				break;
			case 'H':
				sort_opts_vals.sort_method = SORT_MERGESORT;
				break;
			case MMAP_OPT:
				use_mmap = true;
				break;
			case HEAPSORT_OPT:
				sort_opts_vals.sort_method = SORT_HEAPSORT;
				break;
			case RADIXSORT_OPT:
				sort_opts_vals.sort_method = SORT_RADIXSORT;
				break;
			case RANDOMSOURCE_OPT:
				random_source = optarg;
				break;
			case COMPRESSPROGRAM_OPT:
				compress_program = optarg;
				break;
			case FF_OPT:
				read_fns_from_file0(optarg);
				break;
			case BS_OPT:
			{
				const char *errstr;

				max_open_files = strtonum(optarg, 2,
				    UINT_MAX - 1, &errstr) + 1;
				if (errstr != NULL)
					errx(2, "--batch-size argument is %s",
					    errstr);
				break;
			}
			case VERSION_OPT:
				printf("%s\n", VERSION);
				exit(EXIT_SUCCESS);
				/* NOTREACHED */
				break;
			case DEBUG_OPT:
				debug_sort = true;
				break;
			case HELP_OPT:
				usage(0);
				/* NOTREACHED */
				break;
			default:
				usage(2);
				/* NOTREACHED */
			}
		}
	}
	argc -= optind;
	argv += optind;

	if (compress_program == NULL) {
		if (pledge("stdio rpath wpath cpath fattr chown", NULL) == -1)
			err(2, "pledge");
	}

#ifndef GNUSORT_COMPATIBILITY
	if (argc > 2 && strcmp(argv[argc - 2], "-o") == 0) {
		outfile = argv[argc - 1];
		argc -= 2;
	}
#endif

	if (argv_from_file0) {
		argc = argc_from_file0;
		argv = argv_from_file0;
	}

	if (sort_opts_vals.cflag) {
		if (argc > 1)
			errx(2, "only one input file is allowed with the -%c flag",
			    sort_opts_vals.csilentflag ? 'C' : 'c');

		if (argc == 0 || strcmp(argv[0], "-") == 0) {
			if (compress_program) {
				if (pledge("stdio proc exec", NULL) == -1)
					err(2, "pledge");
			} else {
				if (pledge("stdio", NULL) == -1)
					err(2, "pledge");
			}
		} else {
			if (compress_program) {
				if (pledge("stdio rpath proc exec", NULL) == -1)
					err(2, "pledge");
			} else {
				if (pledge("stdio rpath", NULL) == -1)
					err(2, "pledge");
			}
		}
	} else {
		/* Case when the outfile equals one of the input files: */
		if (strcmp(outfile, "-") != 0) {
			struct stat sb;
			int fd, i;

			for (i = 0; i < argc; ++i) {
				if (strcmp(argv[i], outfile) == 0) {
					if (stat(outfile, &sb) == -1)
						err(2, "%s", outfile);
					if (access(outfile, W_OK) == -1)
						err(2, "%s", outfile);
					real_outfile = outfile;
					sort_asprintf(&outfile, "%s.XXXXXXXXXX",
					    real_outfile);
					if ((fd = mkstemp(outfile)) == -1)
						err(2, "%s", outfile);
					(void)fchown(fd, sb.st_uid, sb.st_gid);
					if (fchmod(fd, sb.st_mode & ACCESSPERMS) == -1)
						err(2, "%s", outfile);
					close(fd);
					tmp_file_atexit(outfile);
					break;
				}
			}
		}

		if (compress_program) {
			if (pledge("stdio rpath wpath cpath proc exec", NULL) == -1)
				err(2, "pledge");
		} else {
			if (pledge("stdio rpath wpath cpath", NULL) == -1)
				err(2, "pledge");
		}
	}

	if (sflag != NULL)
		available_free_memory = parse_memory_buffer_value(sflag);

	if (keys_num == 0) {
		keys_num = 1;
		keys = sort_reallocarray(keys, 1, sizeof(struct key_specs));
		memset(&(keys[0]), 0, sizeof(struct key_specs));
		keys[0].c1 = 1;
#ifdef GNUSORT_COMPATIBILITY
		keys[0].pos1b = sm->bflag;
		keys[0].pos2b = sm->bflag;
#endif
		memcpy(&(keys[0].sm), sm, sizeof(struct sort_mods));
	}

	for (i = 0; i < keys_num; i++) {
		struct key_specs *ks;

		ks = &(keys[i]);

		if (sort_modifier_empty(&(ks->sm))) {
#ifdef GNUSORT_COMPATIBILITY
			if (!(ks->pos1b) && !(ks->pos2b)) {
				ks->pos1b = sm->bflag;
				ks->pos2b = sm->bflag;
			}
#endif
			memcpy(&(ks->sm), sm, sizeof(struct sort_mods));
		}

		ks->sm.func = get_sort_func(&(ks->sm));
	}

	if (debug_sort) {
		printf("Memory to be used for sorting: %llu\n",
		    available_free_memory);
		printf("Using collate rules of %s locale\n",
		    setlocale(LC_COLLATE, NULL));
		if (byte_sort)
			printf("Byte sort is used\n");
		if (print_symbols_on_debug) {
			printf("Decimal Point: <%lc>\n", symbol_decimal_point);
			if (symbol_thousands_sep)
				printf("Thousands separator: <%lc>\n",
				    symbol_thousands_sep);
			printf("Positive sign: <%lc>\n", symbol_positive_sign);
			printf("Negative sign: <%lc>\n", symbol_negative_sign);
		}
	}

	if (sort_opts_vals.cflag)
		return check(argc ? *argv : "-");

	set_random_seed();

	if (!sort_opts_vals.mflag) {
		struct file_list fl;
		struct sort_list list;

		sort_list_init(&list);
		file_list_init(&fl, true);

		if (argc < 1)
			procfile("-", &list, &fl);
		else {
			while (argc > 0) {
				procfile(*argv, &list, &fl);
				--argc;
				++argv;
			}
		}

		if (fl.count < 1)
			sort_list_to_file(&list, outfile);
		else {
			if (list.count > 0) {
				char *flast = new_tmp_file_name();

				sort_list_to_file(&list, flast);
				file_list_add(&fl, flast, false);
			}
			merge_files(&fl, outfile);
		}

		file_list_clean(&fl);

		/*
		 * We are about to exit the program, so we can ignore
		 * the clean-up for speed
		 *
		 * sort_list_clean(&list);
		 */

	} else {
		struct file_list fl;

		file_list_init(&fl, false);
		if (argc < 1)
			file_list_add(&fl, "-", true);
		else
			file_list_populate(&fl, argc, argv, true);
		merge_files(&fl, outfile);
		file_list_clean(&fl);
	}

	if (real_outfile) {
		if (rename(outfile, real_outfile) < 0)
			err(2, "%s", real_outfile);
		sort_free(outfile);
	}

	return 0;
}
@


1.86
log
@make several program to use "chown" promise.

it allows chown(2) call to change the user or group on a file.

- usr.bin/compress : aka gzip
- usr.bin/mg : open a file for writing
- usr.bin/sed : inplace editing
- usr.bin/sort : if outfile equals one of the input files

ok deraadt@@ tb@@

(and a reminder from Remi Locherer)

warning: in order to use it, you must have a recent kernel with the new
promise.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.85 2015/10/24 15:19:01 millert Exp $	*/
d1227 4
a1230 1
		file_list_populate(&fl, argc, argv, true);
@


1.85
log
@The default modifier should be copied for empty keys even if -b is
specified.  From Cedric Krier.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.84 2015/10/18 17:02:03 millert Exp $	*/
d873 1
a873 1
	if (pledge("stdio rpath wpath cpath fattr proc exec", NULL) == -1)
d1056 1
a1056 1
		if (pledge("stdio rpath wpath cpath fattr", NULL) == -1)
@


1.84
log
@Do not warn for sort -o if we can't chown the output temporary file
to match the owner of the output file.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.83 2015/10/17 14:33:01 tim Exp $	*/
d1150 1
a1150 2
		if (sort_modifier_empty(&(ks->sm)) && !(ks->pos1b) &&
		    !(ks->pos2b)) {
d1152 4
a1155 2
			ks->pos1b = sm->bflag;
			ks->pos2b = sm->bflag;
@


1.83
log
@Pledge; OK millert@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.82 2015/10/14 16:42:51 tobias Exp $	*/
d1110 2
a1111 4
						err(2, "mkstemp: %s", outfile);
					if (fchown(fd, sb.st_uid, sb.st_gid) == -1)
						warn("unable to set ownership of %s",
						    outfile);
d1113 1
a1113 1
						err(2, "fchmod: %s", outfile);
@


1.82
log
@Copy permissions AND ownership when -o will override an input file.

with input by and ok deraadt@@, millert@@, tim@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.81 2015/10/13 16:55:03 tim Exp $	*/
d871 5
a885 1
	set_hw_params();
d1055 5
d1072 59
a1130 3
	if (sort_opts_vals.cflag && argc > 1)
		errx(2, "only one input file is allowed with the -%c flag",
		    sort_opts_vals.csilentflag ? 'C' : 'c');
a1184 28

	/* Case when the outfile equals one of the input files: */
	if (strcmp(outfile, "-") != 0) {
		struct stat sb;
		int fd, i;

		for (i = 0; i < argc; ++i) {
			if (strcmp(argv[i], outfile) == 0) {
				if (stat(outfile, &sb) == -1)
					err(2, "%s", outfile);
				if (access(outfile, W_OK) == -1)
					err(2, "%s", outfile);
				real_outfile = outfile;
				sort_asprintf(&outfile, "%s.XXXXXXXXXX",
				    real_outfile);
				if ((fd = mkstemp(outfile)) == -1)
					err(2, "mkstemp: %s", outfile);
				if (fchown(fd, sb.st_uid, sb.st_gid) == -1)
					warn("unable to set ownership of %s",
					    outfile);
				if (fchmod(fd, sb.st_mode & ACCESSPERMS) == -1)
					err(2, "fchmod: %s", outfile);
				close(fd);
				tmp_file_atexit(outfile);
				break;
			}
		}
	}
@


1.81
log
@Ignore the setuid/setgid/sticky bits when copying the permissions of an input
file to the new output file. In preparation for pledge(2).

Suggested by and OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.80 2015/10/13 16:21:42 tim Exp $	*/
d1135 7
a1141 3
				if ((fd = mkstemp(outfile)) == -1 ||
				    fchmod(fd, sb.st_mode & ACCESSPERMS) == -1)
					err(2, "%s", outfile);
@


1.80
log
@-C and -c allow at most one input file. Ensure this is the case when the
input files are specified through --files0-from.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.79 2015/04/05 13:56:04 millert Exp $	*/
d1136 1
a1136 1
				    fchmod(fd, sb.st_mode & ALLPERMS) == -1)
@


1.79
log
@The -b flag should only apply when key fields are specified.
If -b follows -k it has no effect.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.78 2015/04/05 13:54:06 millert Exp $	*/
d1058 5
a1096 5
	}

	if (argv_from_file0) {
		argc = argc_from_file0;
		argv = argv_from_file0;
@


1.78
log
@Do not permute command line arguments but still support the
obsolescent "-o outfile" after input files syntax.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.77 2015/04/03 12:52:48 millert Exp $	*/
d916 1
a916 2
				keys_num++;
				keys = sort_reallocarray(keys, keys_num,
d918 1
a918 1
				memset(&(keys[keys_num - 1]), 0,
d920 4
d925 1
a925 1
				if (parse_k(optarg, &(keys[keys_num - 1])) < 0)
d1070 5
a1074 4
		keys[0].pos1b = default_sort_mods->bflag;
		keys[0].pos2b = default_sort_mods->bflag;
		memcpy(&(keys[0].sm), default_sort_mods,
		    sizeof(struct sort_mods));
d1084 1
d1087 1
@


1.77
log
@Only one input file is allowed with the -c/-C flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.76 2015/04/03 10:37:24 tobias Exp $	*/
d56 6
a61 1
#define	OPTIONS	"bCcdfgHhik:Mmno:RrS:st:T:uVz"
d867 1
a874 2
	struct sort_mods *sm = &default_sort_mods_object;

a1044 1

d1047 7
@


1.76
log
@The combination of -c and -o is not specified by POSIX. In fact, the call
"sort -o file -c file" has unspecified behavior and would leave an empty
file behind if it was sorted, the original file it was not.

If -c (or -C) has been specified, only perform that action and ignore -o
among other arguments.

While at it, clean up check() internals.


with input by and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.75 2015/04/03 10:07:25 tobias Exp $	*/
d1044 4
@


1.75
log
@If -S has been supplied multiple times, only take last one into account.
Without this patch, multiple -S arguments influence each other.

spotted by and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.74 2015/04/02 21:09:51 tobias Exp $	*/
d860 1
a860 1
	int c, result;
a864 1
	result = 0;
d1096 3
d1125 1
a1125 1
	if (!sort_opts_vals.cflag && !sort_opts_vals.mflag) {
d1163 1
a1163 3
	} else if (sort_opts_vals.cflag) {
		result = (argc == 0) ? (check("-")) : (check(*argv));
	} else if (sort_opts_vals.mflag) {
d1178 1
a1178 1
	return result;
@


1.74
log
@Prevent integer overflow when parsing -S argument as percentage.
Also make sure that the parsed memory amount, stored in a long long,
won't be larger than SIZE_MAX to properly support 32 bit systems.

with input by and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.73 2015/04/02 21:04:06 tobias Exp $	*/
d859 1
a859 1
	char *outfile, *real_outfile;
d868 1
d934 1
a934 2
				available_free_memory =
				    parse_memory_buffer_value(optarg);
d1045 3
@


1.73
log
@Global variable free_memory is only used in sort.c's set_hw_params,
so turn it into a local one.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.72 2015/04/02 21:00:08 tobias Exp $	*/
d44 1
d372 3
d382 2
@


1.72
log
@Fixed whitespace issues.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.71 2015/04/02 20:57:34 tobias Exp $	*/
d203 1
d223 2
a224 1
	} else
d226 1
@


1.71
log
@No need to strdup environment variable or command line arguments here.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.70 2015/04/02 20:56:00 tobias Exp $	*/
d431 1
a431 1
	found_others = found_this =false;
@


1.70
log
@Add signal name instead of array index (which is not the signal number)
to sigaction error message.

with input by and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.69 2015/04/02 12:43:08 millert Exp $	*/
d305 1
a305 1
			tmpdir = sort_strdup(td);
d928 1
a928 1
				tmpdir = sort_strdup(optarg);
d996 1
a996 1
				random_source = strdup(optarg);
d999 1
a999 1
				compress_program = strdup(optarg);
@


1.69
log
@Don't install signal handlers for SIGQUIT, SIGVTALRM, SIGPROF.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.68 2015/04/01 22:49:47 millert Exp $	*/
d407 1
a407 1
			warn("sigaction(%d)", i);
@


1.68
log
@Check for overflow when handling buffer size suffixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.67 2015/04/01 22:24:02 millert Exp $	*/
d397 2
a398 2
	int i, signals[] = {SIGTERM, SIGHUP, SIGINT, SIGQUIT, SIGUSR1, SIGUSR2,
	    SIGPIPE, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGPROF, 0};
@


1.67
log
@Just use sort_reallocarray() everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.66 2015/04/01 21:45:50 millert Exp $	*/
d321 1
a321 1
		errx(2, "invalid memory buffer size: %s", value);
d325 2
d330 2
d335 2
d340 2
d345 2
d350 2
d355 2
d361 2
d376 2
@


1.66
log
@Remove some unneeded NULL checks that don't really help anything.
It is better to crash when given bad input rather than producing
a wrong result.  None of the checks can actually be triggered.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.65 2015/04/01 21:41:59 millert Exp $	*/
d1021 1
a1021 1
		keys = sort_realloc(keys, sizeof(struct key_specs));
@


1.65
log
@Use exit value 2 for mutually exclusive option errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.64 2015/04/01 21:37:47 millert Exp $	*/
a145 2
	if (sm == NULL)
		return true;
a172 3
	if (fn == NULL)
		return;

d238 1
a238 2
	if (wc && c) {
		int res;
d240 3
a242 4
		res = mbtowc(wc, c, MB_CUR_MAX);
		if (res < 1)
			*wc = def;
	}
d256 1
d259 9
a267 12
	if (lc) {
		/* obtain LC_NUMERIC info */
		/* Convert to wide char form */
		conv_mbtowc(&symbol_decimal_point, lc->decimal_point,
		    symbol_decimal_point);
		conv_mbtowc(&symbol_thousands_sep, lc->thousands_sep,
		    symbol_thousands_sep);
		conv_mbtowc(&symbol_positive_sign, lc->positive_sign,
		    symbol_positive_sign);
		conv_mbtowc(&symbol_negative_sign, lc->negative_sign,
		    symbol_negative_sign);
	}
d315 43
a357 48
	if (value == NULL)
		return available_free_memory;
	else {
		char *endptr;
		unsigned long long membuf;

		membuf = strtoll(value, &endptr, 10);
		if (endptr == value || (long long)membuf < 0 ||
		    (errno == ERANGE && membuf == LLONG_MAX))
			errx(2, "invalid memory buffer size: %s", value);

		switch (*endptr) {
		case 'Y':
			membuf *= 1024;
			/* FALLTHROUGH */
		case 'Z':
			membuf *= 1024;
			/* FALLTHROUGH */
		case 'E':
			membuf *= 1024;
			/* FALLTHROUGH */
		case 'P':
			membuf *= 1024;
			/* FALLTHROUGH */
		case 'T':
			membuf *= 1024;
			/* FALLTHROUGH */
		case 'G':
			membuf *= 1024;
			/* FALLTHROUGH */
		case 'M':
			membuf *= 1024;
			/* FALLTHROUGH */
		case '\0':
		case 'K':
			membuf *= 1024;
			/* FALLTHROUGH */
		case 'b':
			break;
		case '%':
			membuf = (available_free_memory * membuf) /
			    100;
			break;
		default:
			warnc(EINVAL, "%s", optarg);
			membuf = available_free_memory;
		}
		return membuf;
d359 1
d460 44
a503 48
	if (sm) {
		switch (c){
		case 'b':
			sm->bflag = true;
			break;
		case 'd':
			sm->dflag = true;
			break;
		case 'f':
			sm->fflag = true;
			break;
		case 'g':
			sm->gflag = true;
			need_hint = true;
			break;
		case 'i':
			sm->iflag = true;
			break;
		case 'R':
			sm->Rflag = true;
			need_random = true;
			break;
		case 'M':
			initialise_months();
			sm->Mflag = true;
			need_hint = true;
			break;
		case 'n':
			sm->nflag = true;
			need_hint = true;
			print_symbols_on_debug = true;
			break;
		case 'r':
			sm->rflag = true;
			break;
		case 'V':
			sm->Vflag = true;
			break;
		case 'h':
			sm->hflag = true;
			need_hint = true;
			print_symbols_on_debug = true;
			break;
		default:
			return false;
		}
		sort_opts_vals.complex_sort = true;
		sm->func = get_sort_func(sm);
d505 3
a612 1

d630 1
a630 1
	if (s && *s) {
d667 1
a667 2
parse_pos_obs(const char *s, size_t *nf, size_t *nc, char *sopts,
    size_t sopts_size)
d700 1
a700 1
	*nf = (size_t) strtoul(f, NULL, 10);
d712 1
a712 1
		*nc = (size_t) strtoul(c, NULL, 10);
a862 1

d891 1
a891 2
				if (parse_k(optarg, &(keys[keys_num - 1]))
				    < 0) {
a892 1
				}
@


1.64
log
@Fix typo in revision 1.55
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.63 2015/04/01 21:21:38 millert Exp $	*/
d434 5
a438 2
				if (found_this)
					errx(1, "%c:%c: mutually exclusive flags", c, mec);
d443 5
a447 2
			if (found_others)
				errx(1, "%c:%c: mutually exclusive flags", c, mutually_exclusive_flags[fo_index]);
@


1.63
log
@Fix last instance of malloc(n * sizeof(char)) idiom.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.62 2015/04/01 21:18:43 millert Exp $	*/
d332 1
a332 1
		    (errno == ERANGE && membuf == LONG_MAX))
@


1.62
log
@The argument to --sort is not optional so no need to check for NULL optarg.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.61 2015/04/01 21:16:17 millert Exp $	*/
d717 1
a717 1
		c = sort_malloc((len + 1) * sizeof(char));
@


1.61
log
@No need for if (x) free(x) style checks, this is not K&R.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.60 2015/04/01 21:13:07 millert Exp $	*/
d962 12
a973 14
				if (optarg) {
					if (!strcmp(optarg, "general-numeric"))
						set_sort_modifier(sm, 'g');
					else if (!strcmp(optarg, "human-numeric"))
						set_sort_modifier(sm, 'h');
					else if (!strcmp(optarg, "numeric"))
						set_sort_modifier(sm, 'n');
					else if (!strcmp(optarg, "month"))
						set_sort_modifier(sm, 'M');
					else if (!strcmp(optarg, "random"))
						set_sort_modifier(sm, 'R');
					else
						unknown(optarg);
				}
@


1.60
log
@No need for an else clause after a continue, it just makes the
code harder to read.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.59 2015/04/01 20:58:13 millert Exp $	*/
d622 2
a623 4
	if (c)
		sort_free(c);
	if (f)
		sort_free(f);
d740 2
a741 4
	if (c)
		sort_free(c);
	if (f)
		sort_free(f);
@


1.59
log
@Style nits, remove whitespace at the start of a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.58 2015/04/01 20:28:04 millert Exp $	*/
d761 1
a761 1
		char *arg1;
d763 1
a763 3
		arg1 = argv[i];

		if (strlen(arg1) > 1 && arg1[0] == '+') {
d773 27
a799 31
			else {
				f1 += 1;
				c1 += 1;
				if (i + 1 < *argc) {
					char *arg2 = argv[i + 1];

					if (strlen(arg2) > 1 &&
					    arg2[0] == '-') {
						size_t c2, f2;
						char sopts2[128];

						sopts2[0] = 0;
						c2 = f2 = 0;

						if (parse_pos_obs(arg2 + 1,
						    &f2, &c2, sopts2,
						    sizeof(sopts2)) >= 0) {
							int j;
							if (c2 > 0)
								f2 += 1;
							snprintf(sopt,
							    sizeof(sopt),
							    "-k%zu.%zu%s,%zu.%zu%s",
							    f1, c1, sopts1, f2,
							    c2, sopts2);
							argv[i] = sort_strdup(sopt);
							for (j = i + 1; j + 1 < *argc; j++)
								argv[j] = argv[j + 1];
							*argc -= 1;
							continue;
						}
a801 3
				snprintf(sopt, sizeof(sopt), "-k%zu.%zu%s",
				    f1, c1, sopts1);
				argv[i] = sort_strdup(sopt);
d803 3
@


1.58
log
@If strtoul() fails to parse the argument to -k, just pass the
error back to the caller instead of calling err() directly.
The user gets a more useful error message this way.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.57 2015/04/01 20:24:12 millert Exp $	*/
a145 1

a157 1

a242 1

a323 1

a380 1

a413 1

a453 1

a466 1

@


1.57
log
@Use memcpy() not strncpy() when dynamically allocating and copying
a substring.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.56 2015/04/01 20:20:22 millert Exp $	*/
d564 1
a564 1
		ks->f2 = (size_t) strtoul(f, NULL, 10);
d566 1
a566 1
			err(2, "-k");
d573 1
a573 1
		ks->f1 = (size_t) strtoul(f, NULL, 10);
d575 1
a575 1
			err(2, "-k");
d591 1
a591 1
			ks->c2 = (size_t) strtoul(c, NULL, 10);
d593 1
a593 1
				err(2, "-k");
d596 1
a596 1
			ks->c1 = (size_t) strtoul(c, NULL, 10);
d598 1
a598 1
				err(2, "-k");
@


1.56
log
@Pass size of sopts buffer in to parse_pos_obs() for a length check and
use size_t not int for column and field vars.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.55 2015/04/01 20:10:19 millert Exp $	*/
a556 1
	f = sort_malloc((len + 1) * sizeof(char));
d558 2
a559 1
	strncpy(f, s + pmatch[1].rm_so, len);
a583 1
		c = sort_malloc((len + 1) * sizeof(char));
d585 2
a586 1
		strncpy(c, s + pmatch[2].rm_so + 1, len);
a660 1
			pos1 = sort_malloc((size1 + 1) * sizeof(char));
d662 2
a663 1
			strncpy(pos1, s, size1);
a713 1
	f = sort_malloc((len + 1) * sizeof(char));
d715 2
a716 1
	strncpy(f, s + pmatch[1].rm_so, len);
d726 1
d728 1
a728 2

		strncpy(c, s + pmatch[2].rm_so + 1, len);
d743 1
a743 1
		strncpy(sopts, s + pmatch[3].rm_so, len);
@


1.55
log
@Better range checking for "sort -S" memory size.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.54 2015/04/01 19:56:01 millert Exp $	*/
d686 2
a687 1
parse_pos_obs(const char *s, int *nf, int *nc, char *sopts)
d741 2
d774 1
a774 1
			int c1, f1;
d780 2
a781 1
			if (parse_pos_obs(arg1 + 1, &f1, &c1, sopts1) < 0)
d791 1
a791 1
						int c2, f2;
d798 2
a799 1
						    &f2, &c2, sopts2) >= 0) {
d805 1
a805 1
							    "-k%d.%d%s,%d.%d%s",
d816 1
a816 1
				snprintf(sopt, sizeof(sopt), "-k%d.%d%s",
@


1.54
log
@Use strtonum() to parse argument to --batch-size and document the
minimum value in the manual.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.53 2015/03/31 16:40:16 millert Exp $	*/
a333 2
		endptr = NULL;
		errno = 0;
d335 38
a372 3

		if (errno != 0) {
			warn("Wrong memory buffer specification");
a373 37
		} else {
			switch (*endptr){
			case 'Y':
				membuf *= 1024;
				/* FALLTHROUGH */
			case 'Z':
				membuf *= 1024;
				/* FALLTHROUGH */
			case 'E':
				membuf *= 1024;
				/* FALLTHROUGH */
			case 'P':
				membuf *= 1024;
				/* FALLTHROUGH */
			case 'T':
				membuf *= 1024;
				/* FALLTHROUGH */
			case 'G':
				membuf *= 1024;
				/* FALLTHROUGH */
			case 'M':
				membuf *= 1024;
				/* FALLTHROUGH */
			case '\0':
			case 'K':
				membuf *= 1024;
				/* FALLTHROUGH */
			case 'b':
				break;
			case '%':
				membuf = (available_free_memory * membuf) /
				    100;
				break;
			default:
				warnc(EINVAL, "%s", optarg);
				membuf = available_free_memory;
			}
@


1.53
log
@Ignore TMPDIR environment variable if setuid or setgid.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.52 2015/03/31 12:16:02 millert Exp $	*/
d1020 8
a1027 6
				errno = 0;
				long mof = strtol(optarg, NULL, 10);
				if (errno != 0)
					err(2, "--batch-size");
				if (mof >= 2)
					max_open_files = (size_t) mof + 1;
a1028 1
				break;
@


1.52
log
@There's no good reason to make -m and -c mutually exclusive.
Other sorts don't care and our regress uses this.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.51 2015/03/31 11:46:26 millert Exp $	*/
d312 2
a313 1
	char *td;
d315 4
a318 3
	td = getenv("TMPDIR");
	if (td != NULL)
		tmpdir = sort_strdup(td);
@


1.51
log
@Add missing call to atexit() to clean up temp files on error.
Use mkstemp() to create the temp file when "sort -o" specifies
the same name as an input file and preserve the original file
mode on the temp file.  Check for write access on the original
file before creating the temporary.
Based on a diff from and OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.50 2015/03/30 22:20:53 millert Exp $	*/
a1046 3

	if (sort_opts_vals.cflag && sort_opts_vals.mflag)
		errx(1, "%c:%c: mutually exclusive flags", 'm', 'c');
@


1.50
log
@Use _exit() from signal handler so we don't call atexit handlers or
flush stdio.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.49 2015/03/30 22:20:18 millert Exp $	*/
d864 1
a864 1
	outfile = sort_strdup("-");
d873 2
d928 1
a928 2
				sort_free(outfile);
				outfile = sort_strdup(optarg);
d1102 3
a1104 2
	if (strcmp(outfile, "-")) {
		int i;
d1108 11
a1118 8
				real_outfile = sort_strdup(outfile);
				for (;;) {
					const size_t size = strlen(outfile) + strlen(".tmp") + 1;
					outfile = sort_realloc(outfile, size);
					strlcat(outfile, ".tmp", size);
					if (access(outfile, F_OK) < 0)
						break;
				}
d1120 1
a1174 1
		unlink(real_outfile);
d1177 1
a1177 1
		sort_free(real_outfile);
a1178 2

	sort_free(outfile);
@


1.49
log
@Do not install signal handlers for SIGABRT, SIGBUS or SIGSEGV.  Also
install signal handlers for SIGPIPE, SIGXCPU, SIGXFSZ, SIGVTALRM,
and SIGPROF to match the old sort.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.48 2015/03/20 23:04:07 millert Exp $	*/
d389 1
a389 1
	exit(2);
@


1.48
log
@Use the hw.usermem sysctl to determine the amount user (non-kernel)
memory instead of sysconf(_SC_PHYS_PAGES) (which also counts pages
wired by the kernel).  Don't try to use a memory buffer larger than
the datasize hard resource limit.  Adapted from a diff by Andre Smagin.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.47 2015/03/20 00:26:38 millert Exp $	*/
d385 1
a385 2
sig_handler(int sig __unused, siginfo_t *siginfo __unused,
    void *context __unused)
d399 2
d403 9
a411 38
	sa.sa_sigaction = &sig_handler;
	sa.sa_flags = SA_SIGINFO;

	if (sigaction(SIGTERM, &sa, NULL) < 0) {
		warn("sigaction(SIGTERM)");
		return;
	}
	if (sigaction(SIGHUP, &sa, NULL) < 0) {
		warn("sigaction(SIGHUP)");
		return;
	}
	if (sigaction(SIGINT, &sa, NULL) < 0) {
		warn("sigaction(SIGINT)");
		return;
	}
	if (sigaction(SIGQUIT, &sa, NULL) < 0) {
		warn("sigaction(SIGQUIT)");
		return;
	}
	if (sigaction(SIGABRT, &sa, NULL) < 0) {
		warn("sigaction(SIGABRT)");
		return;
	}
	if (sigaction(SIGBUS, &sa, NULL) < 0) {
		warn("sigaction(SIGBUS)");
		return;
	}
	if (sigaction(SIGSEGV, &sa, NULL) < 0) {
		warn("sigaction(SIGSEGV)");
		return;
	}
	if (sigaction(SIGUSR1, &sa, NULL) < 0) {
		warn("sigaction(SIGUSR1)");
		return;
	}
	if (sigaction(SIGUSR2, &sa, NULL) < 0) {
		warn("sigaction(SIGUSR2)");
		return;
@


1.47
log
@Remove custom getdelim(3) and fix a small memory leak.  From Andre Smagin.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.46 2015/03/19 13:11:05 jmc Exp $	*/
d30 1
d32 1
d210 21
a230 1
	long pages, psize;
d232 3
a234 10
	pages = sysconf(_SC_PHYS_PAGES);
	if (pages < 1) {
		warn("sysconf pages");
		pages = 1;
	}
	psize = sysconf(_SC_PAGESIZE);
	if (psize < 1) {
		warn("sysconf psize");
		psize = 4096;
	}
a235 1
	free_memory = (unsigned long long) pages * (unsigned long long) psize;
a236 3

	if (available_free_memory < 1024)
		available_free_memory = 1024;
@


1.46
log
@update the note in STANDARDS about which options are extensions; also add -m
to SYNOPSIS and usage(), which i missed in previous;
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.45 2015/03/19 11:38:12 jmc Exp $	*/
d170 22
a191 23
	if (fn) {
		struct file0_reader f0r;
		FILE *f;

		f = fopen(fn, "r");
		if (f == NULL)
			err(2, "%s", fn);

		memset(&f0r, 0, sizeof(f0r));
		f0r.f = f;

		while (!feof(f)) {
			char *line = read_file0_line(&f0r);

			if (line && *line) {
				if (argc_from_file0 == (size_t)-1)
					argc_from_file0 = 0;
				++argc_from_file0;
				argv_from_file0 = sort_reallocarray(argv_from_file0,
				    argc_from_file0, sizeof(char *));
				argv_from_file0[argc_from_file0 - 1] =
				    sort_strdup(line);
			}
d193 2
a194 1
		closefile(f, fn);
d196 4
@


1.45
log
@first run through this page. mainly getting SYNOPSIS and usage() orderly
(if perhaps not quite correct yet);
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.44 2015/03/17 17:45:13 millert Exp $	*/
d159 1
a159 1
	    "usage: %s [-bCcdfgHhiMnRrsuVz] [-k field1[,field2]] [-o output] "
@


1.44
log
@Initial import of FreeBSD sort.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d159 2
a160 2
	    "usage: %s [-bcCdfghiRMmnrsuVz] [-k field1[,field2]] [-o output] "
	    "[-S memsize]\n\t[-T dir] [-t char] [file ...]\n", getprogname());
@


1.43
log
@Add parentheses to suppress compiler warning.

sort.c:295:35: warning: '&&' within '||' [-Wlogical-op-parentheses]

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.42 2014/10/11 03:02:59 doug Exp $	*/
d4 3
a6 5
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Peter McIlroy.
a15 3
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d17 1
a17 1
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
d20 1
a20 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
d30 2
a31 5
/*
 * Sort sorts a file using an optional user-defined key.
 * Sort uses radix sort for internal sorting, and allows
 * a choice of merge sort and radix sort for external sorting.
 */
d33 4
a36 6
#include "sort.h"
#include "fsort.h"
#include "pathnames.h"

#include <sys/types.h>
#include <sys/stat.h>
d38 2
a39 1
#include <paths.h>
d41 2
d46 111
a156 1
#include <err.h>
d158 5
a162 2
int REC_D = '\n';
u_char d_mask[NBINS];		/* flags for rec_d, field_d, <blank> */
d165 1
a165 2
 * weight tables.  Gweights is one of ascii, Rascii..
 * modified to weight rec_d = 0 (or 255)
d167 30
a196 2
extern u_char gweights[NBINS];
u_char ascii[NBINS], Rascii[NBINS], RFtable[NBINS], Ftable[NBINS];
d199 1
a199 1
 * masks of ignored characters.  Alltable is 256 ones
d201 4
a204 5
u_char dtable[NBINS], itable[NBINS], alltable[NBINS];
int SINGL_FLD = 0, SEP_FLAG = 0, UNIQUE = 0, STABLE = 0;
struct coldesc *clist;
int ncols = 0;
int ND = 10;			/* limit on number of -k options. */
d206 24
a229 3
char *devstdin = _PATH_STDIN;
char *tmpdir = _PATH_VARTMP;
char toutpath[PATH_MAX];
d231 2
a232 3
static void cleanup(void);
static void onsig(int);
static void usage(char *);
d234 3
a236 8
#define CHECK_NFIELDS						\
	if (++nfields == ND) {					\
		ND += 10;					\
		if ((p = reallocarray(fldtab, ND,		\
		    sizeof(*fldtab))) == NULL)			\
			errx(2, "cannot allocate memory");	\
		ftpos = p + (ftpos - fldtab);			\
		fldtab = p;					\
d238 1
d240 5
a244 2
int
main(int argc, char *argv[])
d246 2
a247 8
	int (*get)(int, union f_handle, int, RECHEADER *, u_char *, struct field *);
	int ch, i, stdinflag = 0, tmp = 0;
	char nfields = 0, cflag = 0, c_warn = 0, mflag = 0;
	char *outfile, *outpath = 0;
	struct field *fldtab, *ftpos;
	union f_handle filelist;
	FILE *outfp = NULL;
	struct field *p;
d251 243
a493 12
	if ((clist = calloc((ND+1)*2, sizeof(struct coldesc))) == NULL ||
	    (ftpos = fldtab = calloc(ND+2, sizeof(struct field))) == NULL)
		errx(2, "cannot allocate memory");
	memset(d_mask, 0, NBINS);
	d_mask[REC_D = '\n'] = REC_D_F;
	d_mask['\t'] = d_mask[' '] = BLANK | FLD_D;
	fixit(&argc, argv);
	if (!issetugid() && (outfile = getenv("TMPDIR")))
		tmpdir = outfile;
	while ((ch = getopt(argc, argv, "bCcdfik:mHno:rR:t:T:uy:zs")) != -1) {
		switch (ch) {
		case 'b': fldtab->flags |= BI | BT;
d496 2
d499 6
d506 1
a506 26
		case 'n':
		case 'r': tmp |= optval(ch, 0);
			if (tmp & R && tmp & F)
				fldtab->weights = RFtable;
			else if (tmp & F)
				fldtab->weights = Ftable;
			else if (tmp & R)
				fldtab->weights = Rascii;
			fldtab->flags |= tmp;
			break;
		case 'o':
			outpath = optarg;
			break;
		case 'k':
			CHECK_NFIELDS;
			setfield(optarg, ++ftpos, fldtab->flags);
			break;
		case 't':
			if (SEP_FLAG)
				usage("multiple field delimiters");
			SEP_FLAG = 1;
			d_mask[' '] &= ~FLD_D;
			d_mask['\t'] &= ~FLD_D;
			d_mask[(int)*optarg] |= FLD_D;
			if (d_mask[(int)*optarg] & REC_D_F)
				err(2, "record/field delimiter clash");
d509 2
a510 6
			if (REC_D != '\n')
				usage("multiple record delimiters");
			if ('\n' == (REC_D = *optarg))
				break;
			d_mask['\n'] = d_mask[' '];
			d_mask[REC_D] = REC_D_F;
d512 4
a515 2
		case 'T':
			tmpdir = optarg;
d517 4
a520 10
		case 'u':
			UNIQUE = 1;
			break;
		case 'C':
			cflag = 1;
			c_warn = 0;
			break;
		case 'c':
			cflag = 1;
			c_warn = 1;
d522 2
a523 2
		case 'm':
			mflag = 1;
d525 2
a526 2
		case 'H':
			PANIC = 0;
d528 4
a531 2
		case 'y':
			/* accept -y for backwards compat. */
a532 11
		case 'z':
			if (REC_D != '\n')
				usage("multiple record delimiters");
			REC_D = '\0';
			d_mask['\n'] = d_mask[' '];
			d_mask[REC_D] = REC_D_F;
			break;
		case 's':
			STABLE = 1;
			break;
		case '?':
d534 1
a534 1
			usage(NULL);
d536 156
d694 60
a753 3
	if (cflag && argc > optind+1)
		errx(2, "too many input files for the -%c option",
		    c_warn ? 'c' : 'C');
d755 2
a756 3
	if (argc - 2 > optind && !strcmp(argv[argc-2], "-o")) {
		outpath = argv[argc-1];
		argc -= 2;
d759 1
a759 2
	if (mflag && argc - optind > (MAXFCT - (16+1))*16)
		errx(2, "too many input files for -m option");
d761 33
a793 6
	for (i = optind; i < argc; i++) {
		/* allow one occurrence of /dev/stdin */
		if (!strcmp(argv[i], "-") || !strcmp(argv[i], devstdin)) {
			if (stdinflag)
				warnx("ignoring extra \"%s\" in file list",
				    argv[i]);
d795 34
a828 2
				stdinflag = 1;
				argv[i] = devstdin;
d830 1
a830 2
		} else if ((ch = access(argv[i], R_OK)))
			err(2, "%s", argv[i]);
d832 10
d843 13
a855 3
	if (!(fldtab->flags & (I|D|N) || fldtab[1].icol.num)) {
		SINGL_FLD = 1;
		fldtab[0].icol.num = 1;
d857 255
a1111 48
		if (!fldtab[1].icol.num) {
			CHECK_NFIELDS;
			fldtab[0].flags &= ~(BI|BT);
			setfield("1", ++ftpos, fldtab->flags);
		}
		fldreset(fldtab);
		fldtab[0].flags &= ~F;
	}
	settables(fldtab[0].flags);
	num_init();
	fldtab->weights = gweights;

	if (optind == argc) {
		static char *names[2];

		names[0] = devstdin;
		names[1] = NULL;
		filelist.names = names;
		optind--;
	} else
		filelist.names = argv+optind;

	if (SINGL_FLD)
		get = makeline;
	else
		get = makekey;

	if (!SINGL_FLD) {
		if ((linebuf = malloc(linebuf_size)) == NULL)
			err(2, NULL);
	}

	if (cflag) {
		order(filelist, get, fldtab, c_warn);
		/* NOT REACHED */
	}

	if (!outpath) {
		(void)snprintf(toutpath,
		    sizeof(toutpath), "%sstdout", _PATH_DEV);
		outfile = outpath = toutpath;
	} else if (!(ch = access(outpath, 0)) &&
	    strncmp(_PATH_DEV, outpath, 5)) {
		struct sigaction oact, act;
		int sigtable[] = {SIGHUP, SIGINT, SIGPIPE, SIGXCPU, SIGXFSZ,
		    SIGVTALRM, SIGPROF, 0};
		int outfd;
		mode_t um;
d1113 76
a1188 1
		errno = 0;
d1190 1
a1190 69
		if (access(outpath, W_OK))
			err(2, "%s", outpath);
		(void)snprintf(toutpath, sizeof(toutpath), "%sXXXXXXXXXX",
		    outpath);
		um = umask(S_IWGRP|S_IWOTH);
		(void)umask(um);
		if ((outfd = mkstemp(toutpath)) == -1 ||
		    fchmod(outfd, DEFFILEMODE & ~um) == -1 ||
		    (outfp = fdopen(outfd, "w")) == NULL)
			err(2, "%s", toutpath);
		outfile = toutpath;

		(void)atexit(cleanup);
		sigfillset(&act.sa_mask);
		act.sa_flags = SA_RESTART;
		act.sa_handler = onsig;
		for (i = 0; sigtable[i]; ++i)	/* always unlink toutpath */
			if (sigaction(sigtable[i], NULL, &oact) < 0 ||
			    (oact.sa_handler != SIG_IGN &&
			    sigaction(sigtable[i], &act, NULL) < 0))
				err(2, "sigaction");
	} else
		outfile = outpath;
	if (outfp == NULL && (outfp = fopen(outfile, "w")) == NULL)
		err(2, "%s", outfile);
	if (mflag)
		fmerge(-1, filelist, argc-optind, get, outfp, putline, fldtab);
	else
		fsort(-1, 0, filelist, argc-optind, outfp, fldtab);
	if (outfile != outpath) {
		if (access(outfile, 0))
			err(2, "%s", outfile);
		(void)unlink(outpath);
		if (link(outfile, outpath))
			err(2, "cannot link %s: output left in %s",
			    outpath, outfile);
		(void)unlink(outfile);
	}
	exit(0);
}

/* ARGSUSED */
static void
onsig(int signo)
{

	cleanup();
	_exit(2);			/* return 2 on error/interrupt */
}

static void
cleanup(void)
{

	if (toutpath[0])
		(void)unlink(toutpath);
}

static void
usage(char *msg)
{
	extern char *__progname;

	if (msg != NULL)
		warnx("%s", msg);
	(void)fprintf(stderr, "usage: %s [-bCcdfHimnrsuz] "
	    "[-k field1[,field2]] [-o output] [-R char]\n"
	    "\t[-T dir] [-t char] [file ...]\n", __progname);
	exit(2);
@


1.42
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.41 2013/11/13 15:07:27 deraadt Exp $	*/
d295 2
a296 2
			    oact.sa_handler != SIG_IGN &&
			    sigaction(sigtable[i], &act, NULL) < 0)
@


1.41
log
@repair buffer resizing "undershoot", and some minor issues with
math on void *
assistance from guenther, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.40 2012/10/30 20:03:16 gsoares Exp $	*/
d85 2
a86 2
		if ((p = realloc(fldtab,			\
		    ND * sizeof(*fldtab))) == NULL)		\
@


1.40
log
@fdopen(3) return a FILE * not an int, so compare against NULL.
no functional change

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.39 2009/12/22 19:47:02 schwarze Exp $	*/
d85 2
a86 1
		if ((p = realloc(fldtab, ND)) == NULL)		\
d102 1
a102 1
	void *p;
@


1.39
log
@implement -C (silent -c), required by POSIX.1-2008;
patch from Daniel Dickman <didickman at gmail dot com> tweaked by me;
"looks ok" millert@@, manual help and ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.38 2009/10/28 20:41:39 guenther Exp $	*/
d284 1
a284 1
		    (outfp = fdopen(outfd, "w")) == 0)
@


1.38
log
@Don't catch a signal if we inherited it as ignored.  Instigated by
comments from Matt Fisher (mfisher_ix at maine.rr.com).

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.37 2009/10/27 23:59:43 deraadt Exp $	*/
d96 1
a96 1
	char nfields = 0, cflag = 0, mflag = 0;
d114 1
a114 1
	while ((ch = getopt(argc, argv, "bcdfik:mHno:rR:t:T:uy:zs")) != -1) {
d162 4
d168 1
d196 2
a197 1
		errx(2, "too many input files for -c option");
d258 1
a258 1
		order(filelist, get, fldtab);
d341 1
a341 1
	(void)fprintf(stderr, "usage: %s [-bcdfHimnrsuz] "
@


1.37
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.36 2007/08/22 06:56:40 jmc Exp $	*/
d262 1
a262 1
		struct sigaction act;
d287 4
a290 1
			sigaction(sigtable[i], &act, 0);
@


1.36
log
@sort usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.35 2007/08/21 20:29:25 millert Exp $	*/
a33 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)sort.c	8.1 (Berkeley) 6/6/93";
#else
static char rcsid[] = "$OpenBSD: sort.c,v 1.35 2007/08/21 20:29:25 millert Exp $";
#endif
#endif /* not lint */
@


1.35
log
@Add a -s option to make the radix sort be a stable sort.  Based on
a diff from Eric Gouyer.  Closes PR 5553.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.34 2007/03/13 17:33:58 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.34 2007/03/13 17:33:58 millert Exp $";
d346 1
a346 1
	(void)fprintf(stderr, "usage: %s [-bcdfHimnruzs] "
@


1.34
log
@Use separate buffers in fsort.c and msort.c.  Fixes a problem with
buffer corruptions for some very large files.  Also fixes some
TRECHEADER vs. RECHEADER mismatches.  Back in after unlock.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.32 2007/03/07 18:11:03 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.32 2007/03/07 18:11:03 millert Exp $";
d83 1
a83 1
int SINGL_FLD = 0, SEP_FLAG = 0, UNIQUE = 0;
d128 1
a128 1
	while ((ch = getopt(argc, argv, "bcdfik:mHno:rR:t:T:uy:z")) != -1) {
d195 3
d346 1
a346 1
	(void)fprintf(stderr, "usage: %s [-bcdfHimnruz] "
@


1.33
log
@some bug (in sort?  or compiler) gets hit too late in the release cycle.
please try again right after release.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.31 2006/10/29 18:40:34 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.31 2006/10/29 18:40:34 millert Exp $";
d257 1
a257 4
	if ((buffer = malloc(bufsize)) == NULL)
		err(2, NULL);
	 bufend = buffer + bufsize - 1;
	 if (!SINGL_FLD) {
@


1.32
log
@Use separate buffers in fsort.c and msort.c.  Fixes a problem with
buffer corruptions for some very large files.  Also fixes some
TRECHEADER vs. RECHEADER mismatches.  OK deraadt@@ otto@@ ray@@
@
text
@d257 4
a260 1
	if (!SINGL_FLD) {
@


1.31
log
@Remove useless code that can cause a SEGV if a buffer is realloc()ed.
Allocate buffers early and in one place instead of two.
Make bufend global so it can be updated along with buffer.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.29 2006/10/18 23:30:43 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.29 2006/10/18 23:30:43 millert Exp $";
d257 1
a257 4
	if ((buffer = malloc(bufsize)) == NULL)
		err(2, NULL);
	 bufend = buffer + bufsize - 1;
	 if (!SINGL_FLD) {
@


1.30
log
@revert previous change; causes segfault when called from
pkg_mklocatedb/locate.mklocatedb
@
text
@d257 8
@


1.29
log
@Remove useless code that can cause a SEGV if a buffer is realloc()ed.
Allocate buffers early and in one place instead of two.
Fixes PR 5252; OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.28 2005/10/04 15:10:27 jmc Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.28 2005/10/04 15:10:27 jmc Exp $";
a255 7

	if ((buffer = malloc(bufsize)) == NULL)
		err(2, NULL);
	 if (!SINGL_FLD) {
		if ((linebuf = malloc(linebuf_size)) == NULL)
			err(2, NULL);
	}
@


1.28
log
@remove ellipsis from -k in usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.27 2005/09/28 10:10:16 jmc Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.27 2005/09/28 10:10:16 jmc Exp $";
d256 7
@


1.27
log
@sort options and sync usage();
some help from dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.26 2005/09/27 23:40:07 dlg Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.26 2005/09/27 23:40:07 dlg Exp $";
d339 1
a339 1
	    "[-k field1[,field2] ...] [-o output] [-R char]\n"
@


1.26
log
@add a -z option that allows you to split records on the nul character
('\0'). useful in combination with things like "find . -print0" and
"xargs -0". for dewi, a chump.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.25 2005/04/11 21:04:48 moritz Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.25 2005/04/11 21:04:48 moritz Exp $";
d338 3
a340 2
	(void)fprintf(stderr, "usage: %s [-T dir] [-o output] [-cmubdfinrHz] "
	    "[-t char] [-R char] [-k keydef] ... [files]\n", __progname);
@


1.25
log
@remove silly optimization which should eventually save
a syscall, when it were not broken. ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.24 2004/09/14 22:57:21 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.24 2004/09/14 22:57:21 deraadt Exp $";
d128 1
a128 1
	while ((ch = getopt(argc, argv, "bcdfik:mHno:rR:t:T:uy:")) != -1) {
d188 7
d338 1
a338 1
	(void)fprintf(stderr, "usage: %s [-T dir] [-o output] [-cmubdfinrH] "
@


1.24
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.23 2004/03/17 18:24:49 mickey Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.23 2004/03/17 18:24:49 mickey Exp $";
a272 1
		/* use default umask to try and avoid one syscall */
d274 1
a274 2
		if (um != S_IWGRP|S_IWOTH)
			(void)umask(um);
@


1.23
log
@do not init SINGL_FLD, SEP_FLAG twice; from robert nagy
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.22 2003/06/26 00:12:39 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.22 2003/06/26 00:12:39 deraadt Exp $";
d309 1
@


1.22
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.21 2003/06/10 22:20:51 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.21 2003/06/10 22:20:51 deraadt Exp $";
a123 1
	SINGL_FLD = SEP_FLAG = 0;
@


1.21
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.20 2003/06/03 02:56:16 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.20 2003/06/03 02:56:16 millert Exp $";
d108 1
a108 1
	int (*get)();
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.19 2003/03/30 23:11:41 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.19 2003/03/30 23:11:41 millert Exp $";
d106 1
a106 3
main(argc, argv)
	int argc;
	char *argv[];
d311 1
a311 2
onsig(s)
	int s;
d319 1
a319 1
cleanup()
d327 1
a327 2
usage(msg)
	char *msg;
@


1.19
log
@Use PATH_MAX, not _POSIX_PATH_MAX for filename buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.18 2002/02/16 21:27:52 millert Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d45 1
a45 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.18 2002/02/16 21:27:52 millert Exp $";
@


1.18
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.17 2001/11/17 19:51:34 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.17 2001/11/17 19:51:34 millert Exp $";
d92 1
a92 2
char devstdin[] = _PATH_STDIN;
char toutpath[_POSIX_PATH_MAX];
d94 1
@


1.17
log
@Repair brain-damaged struct sigaction initialization.
Noticed by Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.16 2001/02/04 21:27:01 ericj Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.16 2001/02/04 21:27:01 ericj Exp $";
d96 3
a98 3
static void cleanup __P((void));
static void onsig __P((int));
static void usage __P((char *));
@


1.16
log
@
Bring in some recent fixup's from NetBSD. This allows lines longer than 65522
to be properly sorted. Many other cleanup's done, and depreciate register.
millert@@ and deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.15 2001/01/19 17:58:18 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.15 2001/01/19 17:58:18 deraadt Exp $";
d268 1
a268 1
		struct sigaction act = {0, SIG_BLOCK, 6};
a277 1
		act.sa_handler = onsig;
d291 3
@


1.15
log
@mark remaining signal races which are difficult to fix, and fix a few partially
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.14 2000/06/30 16:00:23 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.14 2000/06/30 16:00:23 millert Exp $";
d65 1
d123 2
d337 1
a337 1
	if (msg)
@


1.14
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.13 1999/11/30 16:41:41 espie Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.13 1999/11/30 16:41:41 espie Exp $";
d317 1
a317 1
	exit(2);			/* return 2 on error/interrupt */
@


1.13
log
@Using mkstemp to create permanent files is possible, but then
the file mode needs tweaking to look like normal file creation.

Approved by millert@@, noticed by my students at Epita. Thanks guys !
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.12 1999/05/24 17:57:19 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.12 1999/05/24 17:57:19 millert Exp $";
d220 1
a220 1
			err(2, argv[i]);
d274 1
a274 1
			err(2, outpath);
d285 1
a285 1
			err(2, toutpath);
d294 1
a294 1
		err(2, outfile);
d301 1
a301 1
			err(2, outfile);
d335 1
a335 1
		warnx(msg);
@


1.13.2.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.14 2000/06/30 16:00:23 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.14 2000/06/30 16:00:23 millert Exp $";
d220 1
a220 1
			err(2, "%s", argv[i]);
d274 1
a274 1
			err(2, "%s", outpath);
d285 1
a285 1
			err(2, "%s", toutpath);
d294 1
a294 1
		err(2, "%s", outfile);
d301 1
a301 1
			err(2, "%s", outfile);
d335 1
a335 1
		warnx("%s", msg);
@


1.12
log
@Dynamically allocate memory for structures whose sizes are based on the
number of keys given.  Closes PR #825.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.11 1998/07/24 00:32:24 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.11 1998/07/24 00:32:24 deraadt Exp $";
d63 2
d269 1
d278 6
a283 1
		if ((outfd = mkstemp(toutpath)) < 0 ||
@


1.11
log
@put -H in synopsis; aaron@@ug.cs.dal.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.10 1998/07/20 20:02:19 mickey Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.10 1998/07/20 20:02:19 mickey Exp $";
d85 1
a85 1
struct coldesc clist[(ND+1)*2];
d87 1
a87 2
extern struct coldesc clist[(ND+1)*2];
extern int ncols;
d97 9
d113 1
a113 1
	char cflag = 0, mflag = 0;
d115 1
a115 1
	struct field fldtab[ND+2], *ftpos;
d118 1
d120 3
a122 1
	memset(fldtab, 0, (ND+2)*sizeof(struct field));
a126 1
	ftpos = fldtab;
d151 1
d226 1
@


1.10
log
@use warnx()
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.9 1998/07/20 19:49:32 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.9 1998/07/20 19:49:32 deraadt Exp $";
d316 1
a316 1
	(void)fprintf(stderr, "usage: %s [-T dir] [-o output] [-cmubdfinr] "
@


1.9
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.8 1998/07/20 19:46:15 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.8 1998/07/20 19:46:15 deraadt Exp $";
d68 1
d315 1
a315 1
		(void)fprintf(stderr, "sort: %s\n", msg);
@


1.8
log
@fix usage correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.7 1998/07/20 19:14:37 mickey Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.7 1998/07/20 19:14:37 mickey Exp $";
d316 1
a316 1
	"[-t char] [-R char] [-k keydef] ... [files]\n", __progname);
@


1.7
log
@consolidate printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.6 1997/06/30 05:36:18 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.6 1997/06/30 05:36:18 millert Exp $";
d179 2
a180 1
		default: usage("");
d311 1
d315 2
a316 2
	(void)fprintf(stderr, "usage: [-T dir] [-o output] [-cmubdfinr] "
		              "[-t char] [-R char] [-k keydef] ... [files]\n");
@


1.6
log
@64bit fixes.  Some of these are a bit bogus as there were "long"s
meant to be file offsets for fseek(3).  However, those values
could never be > an int anyay so it is not a problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.5 1997/06/16 02:39:15 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.5 1997/06/16 02:39:15 millert Exp $";
d313 2
a314 2
	(void)fprintf(stderr, "usage: [-T dir] [-o output] [-cmubdfinr] ");
	(void)fprintf(stderr, "[-t char] [-R char] [-k keydef] ... [files]\n");
@


1.5
log
@Normalize treatment of -n option.  Don't know why it was ever special-cased
(since it was broken that way).  Fixes PR user/220.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.4 1997/06/16 02:21:56 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.4 1997/06/16 02:21:56 millert Exp $";
d104 1
a104 1
	char cflag = 0, mflag = 0, nflag = 0;
@


1.4
log
@Cosmetic cleanup, mostly KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.3 1997/01/26 00:02:25 deraadt Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.3 1997/01/26 00:02:25 deraadt Exp $";
d126 1
a138 5
		case 'n':
			/* XXX - this does not deal with -n in with -k */
			nflag = 1;
			setfield("1n", ++ftpos, fldtab->flags&(~R));
			break;
d140 1
a140 1
			 setfield(optarg, ++ftpos, fldtab->flags);
d208 1
a208 1
	if (!(fldtab->flags & (I|D) || fldtab[1].icol.num)) {
a215 2
		if (nflag)
			fldtab[1].flags |= fldtab->flags;
@


1.3
log
@for implied stdin, do not corrupt argv[0]
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.2 1997/01/22 06:53:16 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.2 1997/01/22 06:53:16 millert Exp $";
d53 2
a54 1
/* Sort sorts a file using an optional user-defined key.
d71 1
d78 1
a101 2
	extern int optind;
	extern char *optarg;
d109 1
d120 1
a120 1
	switch (ch) {
d124 1
a125 1
		case 'f':
d131 1
a131 1
			else if(tmp & R)
d139 1
d186 1
d189 1
d194 1
d197 1
d211 1
d228 1
d238 1
d243 1
d248 1
d259 1
d261 1
d265 2
a266 1
		(void)snprintf(toutpath, sizeof(toutpath), "%sXXXX", outpath);
d271 1
d299 1
d307 1
d316 1
@


1.2
log
@Fix some err(3) usage and usage string.
@
text
@d1 1
a1 1
/*	$OpenBSD: sort.c,v 1.1 1997/01/20 19:39:55 millert Exp $	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: sort.c,v 1.1 1997/01/20 19:39:55 millert Exp $";
d220 9
a228 3
	if (optind == argc)
		argv[--optind] = devstdin;
	filelist.names = argv+optind;
@


1.1
log
@sort(1) from 4.4BSD-lite2 with minor tweaks and bug fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
static char rcsid[] = "$OpenBSD: $";
d202 1
a202 1
			err(2, "%s", argv[i]);
d243 1
a243 1
			err(2, "%s", outpath);
d263 1
a263 1
			err(2, "%s", outfile);
d294 2
a295 2
	(void)fprintf(stderr, "usage: [-o output] [-cmubdfinr] [-t char] ");
	(void)fprintf(stderr, "[-T char] [-k keydef] ... [files]\n");
@
