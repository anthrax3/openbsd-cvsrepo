head	1.22;
access;
symbols
	OPENBSD_5_7:1.21.0.18
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.22
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.20
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.16
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.14
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.12
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.10
	OPENBSD_5_0:1.21.0.8
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.10
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.8
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.6
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.22
date	2015.03.17.17.45.13;	author millert;	state dead;
branches;
next	1.21;
commitid	XCfT2rs68MOcwt0o;

1.21
date	2009.10.27.23.59.43;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2008.11.20.12.14.16;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.21.20.29.25;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.13.17.33.58;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.11.00.38.01;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.07.18.11.03;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.29.18.40.34;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.28.21.14.29;	author naddy;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.18.23.30.43;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.14.22.57.58;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.20.03.50.27;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.15.13.35.36;	author sturm;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.02.56.16;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.04.21.27.00;	author ericj;	state Exp;
branches;
next	1.7;

1.7
date	99.05.24.17.57.18;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.05.02.02.41.56;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.06.30.05.36.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.16.02.21.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.22.06.43.52;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.22.05.49.19;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.01.20.19.39.51;	author millert;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Initial import of FreeBSD sort.
@
text
@/*	$OpenBSD: fsort.c,v 1.21 2009/10/27 23:59:43 deraadt Exp $	*/

/*-
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Peter McIlroy.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Read in the next bin.  If it fits in one segment sort it;
 * otherwise refine it by segment deeper by one character,
 * and try again on smaller bins.  Sort the final bin at this level
 * of recursion to keep the head of fstack at 0.
 * After PANIC passes, abort to merge sort.
 */
#include "sort.h"
#include "fsort.h"

#include <stdlib.h>
#include <string.h>

u_char *linebuf;
size_t linebuf_size = MAXLLEN;
struct tempfile fstack[MAXFCT];
#define FSORTMAX 4
int PANIC = FSORTMAX;

void
fsort(int binno, int depth, union f_handle infiles, int nfiles, FILE *outfp,
    struct field *ftbl)
{
	u_char *weights, **keypos, *bufend, *tmpbuf;
	static u_char *buffer, **keylist;
	static size_t bufsize;
	int ntfiles, mfct = 0, total, i, maxb, lastb, panic = 0;
	int c, nelem;
	long sizes[NBINS+1];
	union f_handle tfiles, mstart = {MAXFCT-16};
	int (*get)(int, union f_handle, int, RECHEADER *,
		u_char *, struct field *);
	RECHEADER *crec;
	struct field tfield[2];
	FILE *prevfp, *tailfp[FSORTMAX+1];

	memset(tailfp, 0, sizeof(tailfp));
	prevfp = outfp;
	memset(tfield, 0, sizeof(tfield));
	if (ftbl[0].flags & R)
		tfield[0].weights = Rascii;
	else
		tfield[0].weights = ascii;
	tfield[0].icol.num = 1;
	weights = ftbl[0].weights;
	if (buffer == NULL) {
		bufsize = BUFSIZE;
		if ((buffer = malloc(bufsize)) == NULL ||
		    (keylist = calloc(MAXNUM, sizeof(u_char *))) == NULL)
			err(2, NULL);
	}
	bufend = buffer + bufsize - 1;
	if (binno >= 0) {
		tfiles.top = infiles.top + nfiles;
		get = getnext;
	} else {
		tfiles.top = 0;
		if (SINGL_FLD)
			get = makeline;
		else
			get = makekey;
	}				
	for (;;) {
		memset(sizes, 0, sizeof(sizes));
		c = ntfiles = 0;
		if (binno == weights[REC_D] &&
		    !(SINGL_FLD && ftbl[0].flags & F)) {	/* pop */
			rd_append(weights[REC_D],
			    infiles, nfiles, prevfp, buffer, bufend);
			break;
		} else if (binno == weights[REC_D]) {
			depth = 0;		/* start over on flat weights */
			ftbl = tfield;
			weights = ftbl[0].weights;
		}
		while (c != EOF) {
			keypos = keylist;
			nelem = 0;
			crec = (RECHEADER *) buffer;
			while ((c = get(binno, infiles, nfiles, crec, bufend,
			    ftbl)) == 0) {
				*keypos++ = crec->data + depth;
				if (++nelem == MAXNUM) {
					c = BUFFEND;
					break;
				}
				crec = (RECHEADER *)((char *)crec +
				    SALIGN(crec->length) + sizeof(TRECHEADER));
			}
			/*
			 * buffer was too small for data, allocate
			 * a bigger buffer.
			 */
			if (c == BUFFEND && nelem == 0) {
				bufsize *= 2;
				tmpbuf = realloc(buffer, bufsize);
				if (!tmpbuf)
					err(2, "failed to realloc buffer");
				crec = (RECHEADER *)
				    (tmpbuf + ((u_char *)crec - buffer));
				buffer = tmpbuf;
				bufend = buffer + bufsize - 1;
				continue;
			}
			if (c == BUFFEND || ntfiles || mfct) {	/* push */
				if (panic >= PANIC) {
					fstack[MAXFCT-16+mfct].fp = ftmp();
					if (radixsort((const u_char **)keylist,
					    nelem, weights, REC_D))
						err(2, NULL);
					append(keylist, nelem, depth, fstack[
					 MAXFCT-16+mfct].fp, putrec, ftbl);
					mfct++;
					/* reduce number of open files */
					if (mfct == 16 ||(c == EOF && ntfiles)) {
						fstack[tfiles.top + ntfiles].fp
						    = ftmp();
						fmerge(0, mstart, mfct, geteasy,
						  fstack[tfiles.top+ntfiles].fp,
						  putrec, ftbl);
						ntfiles++;
						mfct = 0;
					}
				} else {
					fstack[tfiles.top + ntfiles].fp= ftmp();
					onepass(keylist, depth, nelem, sizes,
					weights, fstack[tfiles.top+ntfiles].fp);
					ntfiles++;
				}
			}
		}
		get = getnext;
		if (!ntfiles && !mfct) {	/* everything in memory--pop */
			if (nelem > 1) {
				if (STABLE) {
					i = sradixsort((const u_char **)keylist,
					    nelem, weights, REC_D);
				} else {
					i = radixsort((const u_char **)keylist,
					    nelem, weights, REC_D);
				}
				if (i)
					err(2, NULL);
			}
			append(keylist, nelem, depth, outfp, putline, ftbl);
			break;					/* pop */
		}
		if (panic >= PANIC) {
			if (!ntfiles)
				fmerge(0, mstart, mfct, geteasy,
				    outfp, putline, ftbl);
			else
				fmerge(0, tfiles, ntfiles, geteasy,
				    outfp, putline, ftbl);
			break;
		}
		total = maxb = lastb = 0;	/* find if one bin dominates */
		for (i = 0; i < NBINS; i++)
		  if (sizes[i]) {
			if (sizes[i] > sizes[maxb])
				maxb = i;
			lastb = i;
			total += sizes[i];
		}
		if (sizes[maxb] < max((total / 2) , BUFSIZE))
			maxb = lastb;	/* otherwise pop after last bin */
		fstack[tfiles.top].lastb = lastb;
		fstack[tfiles.top].maxb = maxb;

			/* start refining next level. */
		get(-1, tfiles, ntfiles, crec, bufend, 0);	/* rewind */
		for (i = 0; i < maxb; i++) {
			if (!sizes[i])	/* bin empty; step ahead file offset */
				get(i, tfiles, ntfiles, crec, bufend, 0);
			else
				fsort(i, depth+1, tfiles, ntfiles, outfp, ftbl);
		}
		if (lastb != maxb) {
			if (prevfp != outfp)
				tailfp[panic] = prevfp;
			prevfp = ftmp();
			for (i = maxb+1; i <= lastb; i++)
				if (!sizes[i])
					get(i, tfiles, ntfiles, crec, bufend,0);
				else
					fsort(i, depth+1, tfiles, ntfiles,
					    prevfp, ftbl);
		}

		/* sort biggest (or last) bin at this level */
		depth++;
		panic++;
		binno = maxb;
		infiles.top = tfiles.top;	/* getnext will free tfiles, */
		nfiles = ntfiles;		/* so overwrite them */
	}
	if (prevfp != outfp) {
		concat(outfp, prevfp);
		fclose(prevfp);
	}
	for (i = panic; i >= 0; --i)
		if (tailfp[i]) {
			concat(outfp, tailfp[i]);
			fclose(tailfp[i]);
		}
}

/*
 * This is one pass of radix exchange, dumping the bins to disk.
 */
#define swap(a, b, t) t = a, a = b, b = t
void
onepass(u_char **a, int depth, long n, long sizes[], u_char *tr, FILE *fp)
{
	size_t tsizes[NBINS+1];
	u_char **bin[257], **top[256], ***bp, ***bpmax, ***tp;
	static int histo[256];
	int *hp;
	int c;
	u_char **an, *t, **aj;
	u_char **ak, *r;

	memset(tsizes, 0, sizeof(tsizes));
	depth += sizeof(TRECHEADER);
	an = &a[n];
	for (ak = a; ak < an; ak++) {
		histo[c = tr[**ak]]++;
		tsizes[c] += ((RECHEADER *) (*ak -= depth))->length;
	}

	bin[0] = a;
	bpmax = bin + 256;
	tp = top, hp = histo;
	for (bp = bin; bp < bpmax; bp++) {
		*tp++ = *(bp + 1) = *bp + (c = *hp);
		*hp++ = 0;
		if (c <= 1)
			continue;
	}
	for (aj = a; aj < an; *aj = r, aj = bin[c + 1]) 
		for (r = *aj; aj < (ak = --top[c = tr[r[depth]]]); )
			swap(*ak, r, t);

	for (ak = a, c = 0; c < 256; c++) {
		an = bin[c + 1];
		n = an - ak;
		tsizes[c] += n * sizeof(TRECHEADER);
		/* tell getnext how many elements in this bin, this segment. */
		EWRITE(&tsizes[c], sizeof(size_t), 1, fp);
		sizes[c] += tsizes[c];
		for (; ak < an; ++ak)
			putrec((RECHEADER *) *ak, fp);
	}
}
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.20 2008/11/20 12:14:16 otto Exp $	*/
@


1.20
log
@KNF; only white space changes
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.19 2007/08/21 20:29:25 millert Exp $	*/
a33 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)fsort.c	8.1 (Berkeley) 6/6/93";
#else
static char rcsid[] = "$OpenBSD: fsort.c,v 1.19 2007/08/21 20:29:25 millert Exp $";
#endif
#endif /* not lint */
@


1.19
log
@Add a -s option to make the radix sort be a stable sort.  Based on
a diff from Eric Gouyer.  Closes PR 5553.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.18 2007/03/13 17:33:58 millert Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.18 2007/03/13 17:33:58 millert Exp $";
d122 1
a122 1
			while((c = get(binno, infiles, nfiles, crec, bufend,
d129 2
a130 2
				crec =(RECHEADER *)	((char *) crec +
				SALIGN(crec->length) + sizeof(TRECHEADER));
d277 1
a277 1
		*tp++ = *(bp+1) = *bp + (c = *hp);
d282 2
a283 2
	for (aj = a; aj < an; *aj = r, aj = bin[c+1]) 
		for(r = *aj; aj < (ak = --top[c = tr[r[depth]]]) ;)			
d287 1
a287 1
		an = bin[c+1];
@


1.18
log
@Use separate buffers in fsort.c and msort.c.  Fixes a problem with
buffer corruptions for some very large files.  Also fixes some
TRECHEADER vs. RECHEADER mismatches.  Back in after unlock.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.16 2007/03/07 18:11:03 millert Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.16 2007/03/07 18:11:03 millert Exp $";
d176 11
a186 3
			if (nelem > 1 && radixsort((const u_char **)keylist,
			    nelem, weights, REC_D))
				err(2, NULL);
@


1.17
log
@some bug (in sort?  or compiler) gets hit too late in the release cycle.
please try again right after release.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.15 2006/10/29 18:40:34 millert Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.15 2006/10/29 18:40:34 millert Exp $";
d56 2
a57 2
u_char *buffer = NULL, *bufend = NULL, *linebuf = NULL;
size_t bufsize = BUFSIZE, linebuf_size = MAXLLEN;
a58 1
extern char toutpath[];
d66 3
a68 2
	u_char *weights, **keypos, *tmpbuf;
	static u_char **keylist;
d88 4
a91 2
	if (keylist == NULL) {
		if ((keylist = calloc(MAXNUM, sizeof(u_char *))) == NULL)
d94 1
@


1.16
log
@Use separate buffers in fsort.c and msort.c.  Fixes a problem with
buffer corruptions for some very large files.  Also fixes some
TRECHEADER vs. RECHEADER mismatches.  OK deraadt@@ otto@@ ray@@
@
text
@d56 2
a57 2
u_char *linebuf;
size_t linebuf_size = MAXLLEN;
d59 1
d67 2
a68 3
	u_char *weights, **keypos, *bufend, *tmpbuf;
	static u_char *buffer, **keylist;
	static size_t bufsize;
d88 2
a89 4
	if (buffer == NULL) {
		bufsize = BUFSIZE;
		if ((buffer = malloc(bufsize)) == NULL ||
		    (keylist = calloc(MAXNUM, sizeof(u_char *))) == NULL)
a91 1
	bufend = buffer + bufsize - 1;
@


1.15
log
@Remove useless code that can cause a SEGV if a buffer is realloc()ed.
Allocate buffers early and in one place instead of two.
Make bufend global so it can be updated along with buffer.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.13 2006/10/18 23:30:43 millert Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.13 2006/10/18 23:30:43 millert Exp $";
d56 2
a57 2
u_char *buffer = NULL, *bufend = NULL, *linebuf = NULL;
size_t bufsize = BUFSIZE, linebuf_size = MAXLLEN;
a58 1
extern char toutpath[];
d66 3
a68 2
	u_char *weights, **keypos, *tmpbuf;
	static u_char **keylist;
d88 4
a91 2
	if (keylist == NULL) {
		if ((keylist = calloc(MAXNUM, sizeof(u_char *))) == NULL)
d94 1
@


1.14
log
@revert previous change; causes segfault when called from
pkg_mklocatedb/locate.mklocatedb
@
text
@d56 2
a57 2
u_char **keylist = 0, *buffer = 0, *linebuf = 0;
size_t bufsize, linebuf_size;
d67 2
a68 2
	u_char *bufend, **keypos, *tmpbuf;
	u_char *weights;
d88 3
a90 10
	if (!buffer) {
		bufsize = BUFSIZE;
		if ((buffer = malloc(bufsize + 1)) == NULL ||
		    (keylist = calloc(MAXNUM, sizeof(u_char *))) == NULL)
			errx(2, "cannot allocate memory");
		if (!SINGL_FLD) {
			linebuf_size = MAXLLEN;
			if ((linebuf = malloc(linebuf_size)) == NULL)
				errx(2, "cannot allocate memory");
		}
a91 1
	bufend = buffer + bufsize;
d135 2
a136 2
				buffer = realloc(buffer, bufsize);
				if (!buffer)
d138 4
a141 1
				bufend = buffer + bufsize;
a154 21
						/*
						 * Only copy extra incomplete
						 * crec data if there is any.
						 */
						int nodata = (bufend
						    >= (u_char *)crec
						    && bufend <= crec->data);
						size_t sz = 0;

						if (!nodata) {
							sz = bufend
							    - crec->data;
							tmpbuf = malloc(sz);
							if (tmpbuf == NULL)
								errx(2, "cannot"
								    " allocate"
								    " memory");
							memmove(tmpbuf,
							    crec->data, sz);
						}

a161 6

						if (!nodata) {
							memmove(crec->data,
							    tmpbuf, sz);
							free(tmpbuf);
						}
a186 1
				
@


1.13
log
@Remove useless code that can cause a SEGV if a buffer is realloc()ed.
Allocate buffers early and in one place instead of two.
Fixes PR 5252; OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.12 2004/09/14 22:57:58 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.12 2004/09/14 22:57:58 deraadt Exp $";
d56 2
a57 2
u_char *buffer = NULL, *linebuf = NULL;
size_t bufsize = BUFSIZE, linebuf_size = MAXLLEN;
d67 2
a68 2
	u_char *bufend, *weights, **keypos, *tmpbuf;
	static u_char **keylist;
d88 11
a99 4
	if (keylist == NULL) {
		if ((keylist = calloc(MAXNUM, sizeof(u_char *))) == NULL)
			err(2, NULL);
	}
d143 2
a144 2
				tmpbuf = realloc(buffer, bufsize);
				if (!tmpbuf)
a145 3
				crec = (RECHEADER *)
				    (tmpbuf + ((u_char *)crec - buffer));
				buffer = tmpbuf;
d160 21
d188 6
@


1.12
log
@match foo[] between files, instead of foo[] in one, and *foo in another
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.11 2004/07/20 03:50:27 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.11 2004/07/20 03:50:27 deraadt Exp $";
d56 2
a57 2
u_char **keylist = 0, *buffer = 0, *linebuf = 0;
size_t bufsize, linebuf_size;
d67 2
a68 2
	u_char *bufend, **keypos, *tmpbuf;
	u_char *weights;
d88 4
a91 10
	if (!buffer) {
		bufsize = BUFSIZE;
		if ((buffer = malloc(bufsize + 1)) == NULL ||
		    (keylist = calloc(MAXNUM, sizeof(u_char *))) == NULL)
			errx(2, "cannot allocate memory");
		if (!SINGL_FLD) {
			linebuf_size = MAXLLEN;
			if ((linebuf = malloc(linebuf_size)) == NULL)
				errx(2, "cannot allocate memory");
		}
a92 1
	bufend = buffer + bufsize;
d136 2
a137 2
				buffer = realloc(buffer, bufsize);
				if (!buffer)
d139 3
a155 21
						/*
						 * Only copy extra incomplete
						 * crec data if there is any.
						 */
						int nodata = (bufend
						    >= (u_char *)crec
						    && bufend <= crec->data);
						size_t sz = 0;

						if (!nodata) {
							sz = bufend
							    - crec->data;
							tmpbuf = malloc(sz);
							if (tmpbuf == NULL)
								errx(2, "cannot"
								    " allocate"
								    " memory");
							memmove(tmpbuf,
							    crec->data, sz);
						}

a162 6

						if (!nodata) {
							memmove(crec->data,
							    tmpbuf, sz);
							free(tmpbuf);
						}
@


1.11
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.10 2004/03/15 13:35:36 sturm Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.10 2004/03/15 13:35:36 sturm Exp $";
d59 1
a59 1
extern char *toutpath;
@


1.10
log
@only copy extra incomplete crec data if there is any, fixes occasional
failures of locate.updatedb

adapted from NetBSD, ok tedu@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.9 2003/06/03 02:56:16 millert Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.9 2003/06/03 02:56:16 millert Exp $";
d64 2
a65 6
fsort(binno, depth, infiles, nfiles, outfp, ftbl)
	int binno, depth;
	union f_handle infiles;
	int nfiles;
	FILE *outfp;
	struct field *ftbl;
d277 1
a277 7
onepass(a, depth, n, sizes, tr, fp)
	u_char **a;
	int depth;
	long n;
	long sizes[];
	u_char *tr;
	FILE *fp;
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.8 2001/02/04 21:27:00 ericj Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.8 2001/02/04 21:27:00 ericj Exp $";
d164 21
a184 7
						tmpbuf = malloc(bufend -
						    crec->data);
						if (tmpbuf == NULL)
							errx(2, "cannot "
							    "allocate memory");
						memmove(tmpbuf, crec->data,
						    bufend - crec->data);
d192 6
a197 3
						memmove(crec->data, tmpbuf,
						    bufend - crec->data);
						free(tmpbuf);
@


1.8
log
@
Bring in some recent fixup's from NetBSD. This allows lines longer than 65522
to be properly sorted. Many other cleanup's done, and depreciate register.
millert@@ and deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.7 1999/05/24 17:57:18 millert Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d39 1
a39 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.7 1999/05/24 17:57:18 millert Exp $";
@


1.7
log
@Dynamically allocate memory for structures whose sizes are based on the
number of keys given.  Closes PR #825.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.6 1998/05/02 02:41:56 mickey Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.6 1998/05/02 02:41:56 mickey Exp $";
d61 1
d69 3
a71 3
	register int binno, depth;
	register union f_handle infiles;
	register int nfiles;
d73 1
a73 1
	register struct field *ftbl;
d75 1
a75 1
	register u_char *bufend, **keypos, *tmpbuf;
d79 1
a79 1
	int sizes [NBINS+1];
d81 1
a81 1
	register int (*get)(int, union f_handle, int, RECHEADER *,
d83 1
a83 1
	register RECHEADER *crec;
d97 2
a98 1
		if ((buffer = malloc(BUFSIZE + 1)) == NULL ||
d102 2
a103 1
			if ((linebuf = malloc(MAXLLEN)) == NULL)
d107 1
a107 1
	bufend = buffer + BUFSIZE;
d145 12
d271 2
a272 2
	int n;
	int sizes[];
d276 1
a276 1
	int tsizes[NBINS+1];
d280 1
a280 1
	register int c;
d282 1
a282 1
	register u_char **ak, *r;
d286 1
a286 1
	an = a + n;
d310 1
a310 1
		EWRITE(tsizes+c, sizeof(int), 1, fp);
@


1.6
log
@fix yet another malloc problem.
malloc(2) states quite clear that "malloc() allocates uninitialized space"
just one malloc'ed memory is cleared by this fix.
do a 'sort -u /dev/null' w/ /etc/malloc.conf -> J> to reproduce.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.5 1997/06/30 05:36:16 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.5 1997/06/30 05:36:16 millert Exp $";
d96 7
a102 5
		buffer = malloc(BUFSIZE + 1);
		keylist = malloc(MAXNUM * sizeof(u_char *));
		memset(keylist, 0, MAXNUM * sizeof(u_char *));
		if (!SINGL_FLD)
			linebuf = malloc(MAXLLEN);
d155 3
d263 1
a263 1
	static histo[256];
@


1.5
log
@64bit fixes.  Some of these are a bit bogus as there were "long"s
meant to be file offsets for fseek(3).  However, those values
could never be > an int anyay so it is not a problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.4 1997/06/16 02:21:55 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.4 1997/06/16 02:21:55 millert Exp $";
d98 1
@


1.4
log
@Cosmetic cleanup, mostly KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.3 1997/01/22 06:43:52 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.3 1997/01/22 06:43:52 millert Exp $";
d68 1
a68 1
	register int binno, depth, nfiles;
d70 1
d77 2
a78 2
	register int c, nelem;
	long sizes [NBINS+1];
d82 1
a82 1
	register struct recheader *crec;
d250 2
a251 1
	long n, sizes[];
d255 1
a255 1
	long tsizes[NBINS+1];
d289 1
a289 1
		EWRITE(tsizes+c, sizeof(long), 1, fp);
@


1.3
log
@Fix off-by-one differently--add an extra byte to buffer (ick).
Don't dump core on empty file.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.2 1997/01/22 05:49:19 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.2 1997/01/22 05:49:19 millert Exp $";
d53 1
a53 1
*/
d158 1
a158 1
						++ntfiles;
d168 1
a168 1
					++ntfiles;
d242 1
a242 1
 This is one pass of radix exchange, dumping the bins to disk.
d278 1
a278 1
	for(aj = a; aj < an; *aj = r, aj = bin[c+1]) 
@


1.2
log
@Off by one error.  Fixes a core dump.
@
text
@d1 1
a1 1
/*	$OpenBSD: fsort.c,v 1.1 1997/01/20 19:39:51 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: fsort.c,v 1.1 1997/01/20 19:39:51 millert Exp $";
d95 1
a95 1
		buffer = malloc(BUFSIZE);
d100 1
a100 1
	bufend = buffer + BUFSIZE - 1;
@


1.1
log
@sort(1) from 4.4BSD-lite2 with minor tweaks and bug fixes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: $";
d100 1
a100 1
	bufend = buffer + BUFSIZE;
@
