head	1.14;
access;
symbols
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.10
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.6
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.3.0.16
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.14
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.12
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.10
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.03.17.17.45.13;	author millert;	state dead;
branches;
next	1.13;
commitid	XCfT2rs68MOcwt0o;

1.13
date	2013.11.28.18.24.55;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.43;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.01.18.13.58;	author kili;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.02.08.04.52;	author moritz;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.16.00.14.34;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.11.07.12.03;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.20.03.50.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.26.00.12.39;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.03.02.56.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.06.18.39.11;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.05.24.17.57.18;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.06.16.02.21.56;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.01.20.19.39.52;	author millert;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Initial import of FreeBSD sort.
@
text
@/*	$OpenBSD: init.c,v 1.13 2013/11/28 18:24:55 deraadt Exp $	*/

/*-
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Peter McIlroy.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "sort.h"

#include <ctype.h>
#include <string.h>

extern struct coldesc *clist;
extern int ncols;
u_char gweights[NBINS];

static void insertcol(struct field *);
char *setcolumn(char *, struct field *, int);

/*
 * clist (list of columns which correspond to one or more icol or tcol)
 * is in increasing order of columns.
 * Fields are kept in increasing order of fields.
 */

/* 
 * keep clist in order--inserts a column in a sorted array
 */
static void
insertcol(struct field *field)
{
	int i;
	for (i = 0; i < ncols; i++)
		if (field->icol.num <= clist[i].num)
			break;
	if (field->icol.num != clist[i].num) {
		memmove(clist+i+1, clist+i, sizeof(COLDESC)*(ncols-i));
		clist[i].num = field->icol.num;
		ncols++;
	}
	if (field->tcol.num && field->tcol.num != field->icol.num) {
		for (i = 0; i < ncols; i++)
			if (field->tcol.num <= clist[i].num)
				break;
		if (field->tcol.num != clist[i].num) {
			memmove(clist+i+1, clist+i,sizeof(COLDESC)*(ncols-i));
			clist[i].num = field->tcol.num;
			ncols++;
		}
	}
}

/*
 * matches fields with the appropriate columns--n^2 but who cares?
 */
void
fldreset(struct field *fldtab)
{
	int i;
	fldtab[0].tcol.p = clist+ncols-1;
	for (++fldtab; fldtab->icol.num; ++fldtab) {
		for (i = 0; fldtab->icol.num != clist[i].num; i++)
			;
		fldtab->icol.p = clist + i;
		if (!fldtab->tcol.num)
			continue;
		for (i = 0; fldtab->tcol.num != clist[i].num; i++)
			;
		fldtab->tcol.p = clist + i;
	}
}

/*
 * interprets a column in a -k field
 */
char *
setcolumn(char *pos, struct field *cur_fld, int gflag)
{
	struct column *col;
	int tmp;

	col = cur_fld->icol.num ? (&(*cur_fld).tcol) : (&(*cur_fld).icol);
	if (sscanf(pos, "%d", &(col->num)) != 1)
		errx(2, "missing field number");
	pos++;
	while (isdigit((u_char)*pos))
		pos++;
	if (col->num <= 0 && !(col->num == 0 && col == &(cur_fld->tcol)))
		errx(2, "field numbers must be positive");
	if (*pos == '.') {
		if (!col->num)
			errx(2, "cannot indent end of line");
		pos++;
		if (sscanf(pos, "%d", &(col->indent)) != 1)
			errx(2, "missing offset");
		pos++;
		while (isdigit((u_char)*pos))
			pos++;
		if (&cur_fld->icol == col)
			col->indent--;
		if (col->indent < 0)
			errx(2, "illegal offset");
	}
	if (optval(*pos, cur_fld->tcol.num))	
		while ((tmp = optval(*pos, cur_fld->tcol.num))) {
			cur_fld->flags |= tmp;
			pos++;
	}
	if (cur_fld->icol.num == 0)
		cur_fld->icol.num = 1;
	return (pos);
}

int
setfield(char *pos, struct field *cur_fld, int gflag)
{
	int tmp;
	cur_fld->weights = ascii;
	cur_fld->mask = alltable;
	pos = setcolumn(pos, cur_fld, gflag);
	if (*pos == '\0')			/* key extends to EOL. */
		cur_fld->tcol.num = 0;
	else {
		if (*pos != ',')
			errx(2, "illegal field descriptor");
		setcolumn((++pos), cur_fld, gflag);
	}
	if (!cur_fld->flags)
		cur_fld->flags = gflag;
	tmp = cur_fld->flags;

	/*
	 * Assign appropriate mask table and weight table.
	 * If the global weights are reversed, the local field
	 * must be "re-reversed".
	 */
	if (((tmp & R) ^ (gflag & R)) && tmp & F)
		cur_fld->weights = RFtable;
	else if (tmp & F)
		cur_fld->weights = Ftable;
	else if ((tmp & R) ^ (gflag & R))
		cur_fld->weights = Rascii;
	if (tmp & I)
		cur_fld->mask = itable;
	else if (tmp & D)
		cur_fld->mask = dtable;
	cur_fld->flags |= (gflag & (BI | BT));
	if (!cur_fld->tcol.indent)	/* BT has no meaning at end of field */
		cur_fld->flags &= (D|F|I|N|R|BI);
	if (cur_fld->tcol.num && !(!(cur_fld->flags & BI)
	    && cur_fld->flags & BT) && (cur_fld->tcol.num <= cur_fld->icol.num
	    && cur_fld->tcol.indent < cur_fld->icol.indent))
		errx(2, "fields out of order");
	insertcol(cur_fld);
	return (cur_fld->tcol.num);
}

int
optval(int desc, int tcolflag)
{
	switch(desc) {
		case 'b':
			if (!tcolflag)
				return (BI);
			else
				return (BT);
		case 'd': return (D);
		case 'f': return (F);
		case 'i': return (I);
		case 'n': return (N);
		case 'r': return (R);
		default:  return (0);
	}
}

/*
 * Convert obsolescent "+pos1 [-pos2]" format to POSIX -k form.
 * Note that the conversion is tricky, see the manual for details.
 */
void
fixit(int *argc, char **argv)
{
	int i, j, n;
	long v, w, x;
	char *p, *ep;
	char buf[128], *bufp, *bufend;

	bufend = buf + sizeof(buf);
	for (i = 1; i < *argc; i++) {
		if (argv[i][0] == '+') {
			bufp = buf;
			p = argv[i] + 1;
			v = strtol(p, &ep, 10);
			if (ep == p || v < 0 ||
			    (v == LONG_MAX && errno == ERANGE))
				errx(2, "invalid field number");
			p = ep;
			if (*p == '.') {
				x = strtol(++p, &ep, 10);
				if (ep == p || x < 0 ||
				    (x == LONG_MAX && errno == ERANGE))
					errx(2, "invalid field number");
				p = ep;
				n = snprintf(bufp, bufend - bufp, "-k%ld.%ld%s",
				    v+1, x+1, p);
			} else {
				n = snprintf(bufp, bufend - bufp, "-k%ld%s",
				    v+1, p);
			}
			if (n == -1 || n >= bufend - bufp)
				errx(2, "bad field specification");
			bufp += n;

			if (argv[i+1] && argv[i+1][0] == '-' &&
			    isdigit((u_char)argv[i+1][1])) {
				p = argv[i+1] + 1;
				w = strtol(p, &ep, 10);
				if (ep == p || w < 0 ||
				    (w == LONG_MAX && errno == ERANGE))
					errx(2, "invalid field number");
				p = ep;
				x = 0;
				if (*p == '.') {
					x = strtol(++p, &ep, 10);
					if (ep == p || x < 0 ||
					    (x == LONG_MAX && errno == ERANGE))
						errx(2, "invalid field number");
					p = ep;
				}
				if (x == 0) {
					n = snprintf(bufp, bufend - bufp,
					    ",%ld%s", w, p);
				} else {
					n = snprintf(bufp, bufend - bufp,
					    ",%ld.%ld%s", w+1, x, p);
				}
				if (n == -1 || n >= bufend - bufp)
					errx(2, "bad field specification");

				/* shift over argv */
				for (j = i+1; j < *argc; j++)
					argv[j] = argv[j+1];
				*argc -= 1;
			}
			if ((argv[i] = strdup(buf)) == NULL)
				err(2, NULL);
		}
	}
}

/*
 * ascii, Rascii, Ftable, and RFtable map
 * REC_D -> REC_D;  {not REC_D} -> {not REC_D}.
 * gweights maps REC_D -> (0 or 255); {not REC_D} -> {not gweights[REC_D]}.
 * Note: when sorting in forward order, to encode character zero in a key,
 * use \001\001; character 1 becomes \001\002.  In this case, character 0
 * is reserved for the field delimiter.  Analagously for -r (fld_d = 255).
 * Note: this is only good for ASCII sorting.  For different LC 's,
 * all bets are off.  See also num_init in number.c
 */
void
settables(int gflags)
{
	u_char *wts;
	int i, incr;
	for (i=0; i < 256; i++) {
		ascii[i] = i;
		if (i > REC_D && i < 255 - REC_D+1)
			Rascii[i] = 255 - i + 1;
		else
			Rascii[i] = 255 - i;
		if (islower((u_char)i)) {
			Ftable[i] = Ftable[i- ('a' -'A')];
			RFtable[i] = RFtable[i - ('a' - 'A')];
		} else if (REC_D>= 'A' && REC_D < 'Z' && i < 'a' && i > REC_D) {
			Ftable[i] = i + 1;
			RFtable[i] = Rascii[i] - 1;
		} else {
			Ftable[i] = i;
			RFtable[i] = Rascii[i];
		}
		alltable[i] = 1;
		if (i == '\n' || isprint((u_char)i))
			itable[i] = 1;
		else itable[i] = 0;
		if (i == '\n' || i == '\t' || i == ' ' || isalnum((u_char)i))
			dtable[i] = 1;
		else dtable[i] = 0;
	}
	Rascii[REC_D] = RFtable[REC_D] = REC_D;
	if (REC_D >= 'A' && REC_D < 'Z')
		Ftable[REC_D + ('a' - 'A')]++;
	if (gflags & R && (!(gflags & F) || !SINGL_FLD))
		wts = Rascii;
	else if (!(gflags & F) || !SINGL_FLD)
		wts = ascii;
	else if (gflags & R)
		wts = RFtable;
	else
		wts = Ftable;
	memmove(gweights, wts, sizeof(gweights));
	incr = (gflags & R) ? -1 : 1;
	for (i = 0; i < REC_D; i++)
		gweights[i] += incr;
	gweights[REC_D] = ((gflags & R) ? 255 : 0);
	if (SINGL_FLD && gflags & F) {
		for (i = 0; i < REC_D; i++) {
			ascii[i] += incr;
			Rascii[i] += incr;
		}
		ascii[REC_D] = Rascii[REC_D] = gweights[REC_D];
	}
}
@


1.13
log
@unsigned char for ctype
ok krw okan
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.12 2009/10/27 23:59:43 deraadt Exp $	*/
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.11 2007/09/01 18:13:58 kili Exp $	*/
d113 1
a113 1
	while (isdigit(*pos))
d124 1
a124 1
		while (isdigit(*pos))
d241 2
a242 2
			if (argv[i+1] &&
			    argv[i+1][0] == '-' && isdigit(argv[i+1][1])) {
d299 1
a299 1
		if (islower(i)) {
d310 1
a310 1
		if (i == '\n' || isprint(i))
d313 1
a313 1
		if (i == '\n' || i == '\t' || i == ' ' || isalnum(i))
@


1.11
log
@
Use an int, not a size_t, to store the return value of snprintf().
This gives the later tests against -1 a chance to actually do something.
Initially from Igor Zinovik <zinovik@@cs.karelia.ru>.

ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.10 2007/04/02 08:04:52 moritz Exp $	*/
a33 8

#ifndef lint
#if 0
static char sccsid[] = "@@(#)init.c	8.1 (Berkeley) 6/6/93";
#else
static char rcsid[] = "$OpenBSD: init.c,v 1.10 2007/04/02 08:04:52 moritz Exp $";
#endif
#endif /* not lint */
@


1.10
log
@The scanf(3) family of functions can return EOF (-1) if an input
failure occurs. So check it, before blindly adding it to some
pointer.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.9 2006/11/16 00:14:34 ray Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: init.c,v 1.9 2006/11/16 00:14:34 ray Exp $";
d218 1
a218 1
	int i, j;
a221 1
	size_t n;
@


1.9
log
@Fix undefined behavior (var = ++var).

From Alexey Dobriyan <adobriyan at gmail dot com>.

OK otto@@, moritz@@, and jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.8 2005/04/11 07:12:03 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: init.c,v 1.8 2005/04/11 07:12:03 deraadt Exp $";
d118 3
a120 1
	pos += sscanf(pos, "%d", &(col->num));
d129 3
a131 1
		pos += sscanf(pos, "%d", &(col->indent));
@


1.8
log
@also handle snprintf returning -1, trivial
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.7 2004/07/20 03:50:27 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: init.c,v 1.7 2004/07/20 03:50:27 deraadt Exp $";
d126 2
a127 1
		pos += sscanf(++pos, "%d", &(col->indent));
@


1.7
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.6 2003/06/26 00:12:39 deraadt Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: init.c,v 1.6 2003/06/26 00:12:39 deraadt Exp $";
d241 1
a241 1
			if (n >= bufend - bufp)
d268 1
a268 1
				if (n >= bufend - bufp)
@


1.6
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.5 2003/06/03 02:56:16 millert Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: init.c,v 1.5 2003/06/03 02:56:16 millert Exp $";
d65 1
a65 2
insertcol(field)
	struct field *field;
d92 1
a92 2
fldreset(fldtab)
	struct field *fldtab;
d112 1
a112 4
setcolumn(pos, cur_fld, gflag)
	char *pos;
	struct field *cur_fld;
	int gflag;
d145 1
a145 4
setfield(pos, cur_fld, gflag)
	char *pos;
	struct field *cur_fld;
	int gflag;
d189 1
a189 2
optval(desc, tcolflag)
	int desc, tcolflag;
d211 1
a211 3
fixit(argc, argv)
	int *argc;
	char **argv;
d293 1
a293 2
settables(gflags)
	int gflags;
@


1.5
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.4 2003/04/06 18:39:11 millert Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: init.c,v 1.4 2003/04/06 18:39:11 millert Exp $";
d52 3
a155 1
	char *setcolumn();
@


1.4
log
@Rewrite fixit() to use snprintf() and strtol() with bounds and error
checking done in each place.  This also removes the bogus limit on
the number of '+' and '-' args.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: init.c,v 1.3 1999/05/24 17:57:18 millert Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d39 1
a39 1
static char rcsid[] = "$OpenBSD: init.c,v 1.3 1999/05/24 17:57:18 millert Exp $";
@


1.3
log
@Dynamically allocate memory for structures whose sizes are based on the
number of keys given.  Closes PR #825.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: init.c,v 1.2 1997/06/16 02:21:56 millert Exp $";
d217 4
d226 5
a230 5
	int i, j, v, w, x;
	static char *vbuf, *vpos, *tpos;

	if ((vpos = vbuf = calloc(ND*20, sizeof(char))) == NULL)
		errx(2, "cannot allocate memory");
d232 1
d235 18
a252 10
			tpos = argv[i]+1;
			argv[i] = vpos;
			vpos += sprintf(vpos, "-k");
			tpos += sscanf(tpos, "%d", &v);
			while (isdigit(*tpos))
				tpos++;
			vpos += sprintf(vpos, "%d", v+1);
			if (*tpos == '.') {
				tpos += sscanf(++tpos, "%d", &x);
				vpos += sprintf(vpos, ".%d", x+1);
d254 4
a257 3
			while (*tpos)
				*vpos++ = *tpos++;
			vpos += sprintf(vpos, ",");
d260 6
a265 4
				tpos = argv[i+1] + 1;
				tpos += sscanf(tpos, "%d", &w);
				while (isdigit(*tpos))
					tpos++;
d267 13
a279 4
				if (*tpos == '.') {
					tpos += sscanf(++tpos, "%d", &x);
					while (isdigit(*tpos))
						tpos++;
d281 5
a285 8
				if (x) {
					vpos += sprintf(vpos, "%d", w+1);
					vpos += sprintf(vpos, ".%d", x);
				} else
					vpos += sprintf(vpos, "%d", w);
				while (*tpos)
					*vpos++ = *tpos++;
				for (j= i+1; j < *argc; j++)
d289 2
@


1.2
log
@Cosmetic cleanup, mostly KNF.
@
text
@d1 1
a1 1
/*	OpenBSD$	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: init.c,v 1.1 1997/01/20 19:39:52 millert Exp $";
d52 1
a52 1
extern struct coldesc clist[(ND+1)*2];
a155 1
	static int nfields = 0;
a157 2
	if (++nfields == ND)
		errx(2, "too many sort keys. (Limit is %d)", ND-1);
d223 4
a226 2
	static char vbuf[ND*20], *vpos, *tpos;
	vpos = vbuf;
@


1.1
log
@sort(1) from 4.4BSD-lite2 with minor tweaks and bug fixes by me.
@
text
@d43 1
a43 1
static char rcsid[] = "$OpenBSD: $";
d100 2
a101 1
		for (i = 0; fldtab->icol.num != clist[i].num; i++);
d105 2
a106 1
		for (i = 0; fldtab->tcol.num != clist[i].num; i++);
d122 1
d208 1
a208 1
				return(BI);
d210 7
a216 7
				return(BT);
		case 'd': return(D);
		case 'f': return(F);
		case 'i': return(I);
		case 'n': return(N);
		case 'r': return(R);
		default:  return(0);
d314 1
a314 1
		++Ftable[REC_D + ('a' - 'A')];
@
