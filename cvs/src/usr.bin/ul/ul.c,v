head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.15.0.22
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.20
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.10
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.6
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.14
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.12
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.10.16.11.28.54;	author jca;	state Exp;
branches;
next	1.22;
commitid	vH4sxxQCi8nA46Jn;

1.22
date	2016.09.26.05.32.35;	author otto;	state Exp;
branches;
next	1.21;
commitid	P0r7ZybjxlYNoPU5;

1.21
date	2016.03.26.08.59.29;	author natano;	state Exp;
branches;
next	1.20;
commitid	aHC2gPZgpee3p3uV;

1.20
date	2016.01.18.17.34.26;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	FsrqG8aKKZiWi6QR;

1.19
date	2015.10.10.16.15.03;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	DfInJOr9FamxGmOI;

1.18
date	2015.02.08.23.40.34;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	yGZX28AeTChVE8eY;

1.17
date	2015.02.06.09.19.16;	author tedu;	state Exp;
branches;
next	1.16;
commitid	2LyDu7Kbhosl8cZg;

1.16
date	2014.11.18.20.54.28;	author krw;	state Exp;
branches;
next	1.15;
commitid	yCis8OrOsfixbKpI;

1.15
date	2009.10.27.23.59.46;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.16.20.19.27;	author sobrado;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.06.14.37.59;	author jaredy;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.13.22.11.56;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.25.21.09.45;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.10.22.20.53;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.02.56.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.07.21.13.54;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.12.05.17.27;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.22.15.38.23;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.43.27;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.42.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.04.03.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Zap unused variable.
@
text
@/*	$OpenBSD: ul.c,v 1.22 2016/09/26 05:32:35 otto Exp $	*/
/*	$NetBSD: ul.c,v 1.3 1994/12/07 00:28:24 jtc Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <curses.h>
#include <err.h>
#include <errno.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <term.h>
#include <unistd.h>
#include <wchar.h>

#define	IESC	L'\033'
#define	SO	L'\016'
#define	SI	L'\017'
#define	HFWD	'9'
#define	HREV	'8'
#define	FREV	'7'
#define	MAXBUF	512

#define	NORMAL	000
#define	ALTSET	001	/* Reverse */
#define	SUPERSC	002	/* Dim */
#define	SUBSC	004	/* Dim | Ul */
#define	UNDERL	010	/* Ul */
#define	BOLD	020	/* Bold */
#define	INDET	040	/* Indeterminate: either Bold or Ul */

int	must_use_uc, must_overstrike;
char	*CURS_UP, *CURS_RIGHT, *CURS_LEFT,
	*ENTER_STANDOUT, *EXIT_STANDOUT, *ENTER_UNDERLINE, *EXIT_UNDERLINE,
	*ENTER_DIM, *ENTER_BOLD, *ENTER_REVERSE, *UNDER_CHAR, *EXIT_ATTRIBUTES;

struct	CHAR	{
	char	c_mode;
	wchar_t	c_char;
	int	c_width;
	int	c_pos;
} ;

struct	CHAR	obuf[MAXBUF];
int	col, maxcol;
int	mode;
int	halfpos;
int	upln;
int	iflag;

int	outchar(int);
void	initcap(void);
void	initbuf(void);
void	mfilter(FILE *);
void	reverse(void);
void	fwd(void);
void	flushln(void);
void	msetmode(int);
void	outc(wchar_t, int);
void	overstrike(void);
void	iattr(void);

#define	PRINT(s) \
	do { \
		if (s) \
			tputs(s, 1, outchar); \
	} while (0)

int
main(int argc, char *argv[])
{
	extern int optind;
	extern char *optarg;
	int c;
	char *termtype;
	FILE *f;
	char termcap[1024];

	setlocale(LC_CTYPE, "");

	if (pledge("stdio rpath tty", NULL) == -1)
		err(1, "pledge");

	termtype = getenv("TERM");
	if (termtype == NULL || (argv[0][0] == 'c' && !isatty(1)))
		termtype = "lpr";
	while ((c = getopt(argc, argv, "it:T:")) != -1)
		switch (c) {
		case 't':
		case 'T': /* for nroff compatibility */
			termtype = optarg;
			break;
		case 'i':
			iflag = 1;
			break;

		default:
			fprintf(stderr,
			    "usage: %s [-i] [-t terminal] [file ...]\n",
			    argv[0]);
			exit(1);
		}

	switch (tgetent(termcap, termtype)) {
	case 1:
		break;
	default:
		warnx("trouble reading termcap");
		/* FALLTHROUGH */
	case 0:
		/* No such terminal type - assume dumb */
		(void)strlcpy(termcap, "dumb:os:col#80:cr=^M:sf=^J:am:",
		    sizeof termcap);
		break;
	}
	initcap();
	if ((tgetflag("os") && ENTER_BOLD == NULL ) ||
	    (tgetflag("ul") && ENTER_UNDERLINE == NULL && UNDER_CHAR == NULL))
		must_overstrike = 1;
	initbuf();
	if (optind == argc)
		mfilter(stdin);
	else for (; optind<argc; optind++) {
		f = fopen(argv[optind],"r");
		if (f == NULL)
			err(1, "%s", argv[optind]);

		mfilter(f);
		fclose(f);
	}
	exit(0);
}

void
mfilter(FILE *f)
{
	struct CHAR	*cp;
	wint_t		 c;
	int		 skip_bs, w, wt;

	col = 1;
	skip_bs = 0;
	while (col < MAXBUF) {
		switch (c = fgetwc(f)) {
		case WEOF:
			/* Discard invalid bytes. */
			if (ferror(f)) {
				if (errno != EILSEQ)
					err(1, NULL);
				clearerr(f);
				break;
			}

			/* End of file. */
			if (maxcol)
				flushln();
			return;

		case L'\b':
			/*
			 * Back up one character position, not one
			 * display column, but ignore a second
			 * backspace after a double-width character.
			 */
			if (skip_bs > 0)
				skip_bs--;
			else if (col > 1)
				if (obuf[--col].c_width > 1)
					skip_bs = obuf[col].c_width - 1;
			continue;

		case L'\t':
			/* Calculate the target position. */
			wt = (obuf[col - 1].c_pos + 8) & ~7;

			/* Advance past known positions. */
			while ((w = obuf[col].c_pos) > 0 && w <= wt)
				col++;

			/* Advance beyond the end. */
			if (w == 0) {
				w = obuf[col - 1].c_pos;
				while (w < wt) {
					obuf[col].c_width = 1;
					obuf[col++].c_pos = ++w;
				}
			}
			if (col > maxcol)
				maxcol = col;
			break;

		case L'\r':
			col = 1;
			break;

		case SO:
			mode |= ALTSET;
			break;

		case SI:
			mode &= ~ALTSET;
			break;

		case IESC:
			switch (c = fgetwc(f)) {
			case HREV:
				if (halfpos == 0) {
					mode |= SUPERSC;
					halfpos--;
				} else if (halfpos > 0) {
					mode &= ~SUBSC;
					halfpos--;
				} else {
					halfpos = 0;
					reverse();
				}
				break;
			case HFWD:
				if (halfpos == 0) {
					mode |= SUBSC;
					halfpos++;
				} else if (halfpos < 0) {
					mode &= ~SUPERSC;
					halfpos++;
				} else {
					halfpos = 0;
					fwd();
				}
				break;
			case FREV:
				reverse();
				break;
			default:
				errx(1, "0%o: unknown escape sequence", c);
			}
			break;

		case L'_':
			if (obuf[col].c_char == L'\0') {
				obuf[col].c_char = L'_';
				obuf[col].c_width = 1;
			} else if (obuf[col].c_char == L'_') {
				if (obuf[col - 1].c_mode & UNDERL)
					obuf[col].c_mode |= UNDERL | mode;
				else if (obuf[col - 1].c_mode & BOLD)
					obuf[col].c_mode |= BOLD | mode;
				else
					obuf[col].c_mode |= INDET | mode;
			} else
				obuf[col].c_mode |= UNDERL | mode;
			/* FALLTHROUGH */

		case L' ':
			if (obuf[col].c_pos == 0) {
				obuf[col].c_width = 1;
				obuf[col].c_pos = obuf[col - 1].c_pos + 1;
			}
			col++;
			if (col > maxcol)
				maxcol = col;
			break;

		case L'\n':
			flushln();
			break;

		case L'\f':
			flushln();
			putwchar(L'\f');
			break;

		default:
			/* Discard valid, but non-printable characters. */
			if ((w = wcwidth(c)) == -1)
				break;

			if (obuf[col].c_char == L'\0') {
				obuf[col].c_char = c;
				obuf[col].c_mode = mode;
				obuf[col].c_width = w;
				obuf[col].c_pos = obuf[col - 1].c_pos + w;
			} else if (obuf[col].c_char == L'_') {
				obuf[col].c_char = c;
				obuf[col].c_mode |= UNDERL|mode;
				obuf[col].c_width = w;
				obuf[col].c_pos = obuf[col - 1].c_pos + w;
				for (cp = obuf + col; cp[1].c_pos > 0; cp++)
					cp[1].c_pos = cp[0].c_pos +
					    cp[1].c_width;
			} else if (obuf[col].c_char == c)
				obuf[col].c_mode |= BOLD|mode;
			else
				obuf[col].c_mode = mode;
			col++;
			if (col > maxcol)
				maxcol = col;
			break;
		}
		skip_bs = 0;
	}
}

void
flushln(void)
{
	int lastmode, i;
	int hadmodes = 0;

	for (i = maxcol; i > 0; i--) {
		if (obuf[i].c_mode & INDET) {
			obuf[i].c_mode &= ~INDET;
			if (i < maxcol && obuf[i + 1].c_mode & BOLD)
				obuf[i].c_mode |= BOLD;
			else
				obuf[i].c_mode |= UNDERL;
		}
	}

	lastmode = NORMAL;
	for (i = 1; i < maxcol; i++) {
		if (obuf[i].c_mode != lastmode) {
			hadmodes = 1;
			msetmode(obuf[i].c_mode);
			lastmode = obuf[i].c_mode;
		}
		if (obuf[i].c_char == L'\0') {
			if (upln)
				PRINT(CURS_RIGHT);
			else
				outc(L' ', 1);
		} else
			outc(obuf[i].c_char, obuf[i].c_width);
	}
	if (lastmode != NORMAL)
		msetmode(0);
	if (must_overstrike && hadmodes && !iflag)
		overstrike();
	putwchar(L'\n');
	if (iflag && hadmodes)
		iattr();
	(void)fflush(stdout);
	if (upln)
		upln--;
	initbuf();
}

/*
 * For terminals that can overstrike, overstrike underlines and bolds.
 * We don't do anything with halfline ups and downs, or Greek.
 */
void
overstrike(void)
{
	int i, j, needspace;

	putwchar(L'\r');
	needspace = 0;
	for (i = 1; i < maxcol; i++) {
		if (obuf[i].c_mode != UNDERL && obuf[i].c_mode != BOLD) {
			needspace += obuf[i].c_width;
			continue;
		}
		while (needspace > 0) {
			putwchar(L' ');
			needspace--;
		}
		if (obuf[i].c_mode == BOLD)
			putwchar(obuf[i].c_char);
		else
			for (j = 0; j < obuf[i].c_width; j++)
				putwchar(L'_');
	}
}

void
iattr(void)
{
	int i, j, needspace;
	char c;

	needspace = 0;
	for (i = 1; i < maxcol; i++) {
		switch (obuf[i].c_mode) {
		case NORMAL:
			needspace += obuf[i].c_width;
			continue;
		case ALTSET:
			c = 'g';
			break;
		case SUPERSC:
			c = '^';
			break;
		case SUBSC:
			c = 'v';
			break;
		case UNDERL:
			c = '_';
			break;
		case BOLD:
			c = '!';
			break;
		default:
			c = 'X';
			break;
		}
		while (needspace > 0) {
			putwchar(L' ');
			needspace--;
		}
		for (j = 0; j < obuf[i].c_width; j++)
			putwchar(c);
	}
	putwchar(L'\n');
}

void
initbuf(void)
{
	bzero(obuf, sizeof (obuf));	/* depends on NORMAL == 0 */
	col = 1;
	maxcol = 0;
	mode &= ALTSET;
}

void
fwd(void)
{
	int oldcol, oldmax;

	oldcol = col;
	oldmax = maxcol;
	flushln();
	col = oldcol;
	maxcol = oldmax;
}

void
reverse(void)
{
	upln++;
	fwd();
	PRINT(CURS_UP);
	PRINT(CURS_UP);
	upln++;
}

void
initcap(void)
{
	static char tcapbuf[512];
	char *bp = tcapbuf;

	/* This nonsense attempts to work with both old and new termcap */
	CURS_UP =		tgetstr("up", &bp);
	CURS_RIGHT =		tgetstr("ri", &bp);
	if (CURS_RIGHT == NULL)
		CURS_RIGHT =	tgetstr("nd", &bp);
	CURS_LEFT =		tgetstr("le", &bp);
	if (CURS_LEFT == NULL)
		CURS_LEFT =	tgetstr("bc", &bp);
	if (CURS_LEFT == NULL && tgetflag("bs"))
		CURS_LEFT =	"\b";

	ENTER_STANDOUT =	tgetstr("so", &bp);
	EXIT_STANDOUT =		tgetstr("se", &bp);
	ENTER_UNDERLINE =	tgetstr("us", &bp);
	EXIT_UNDERLINE =	tgetstr("ue", &bp);
	ENTER_DIM =		tgetstr("mh", &bp);
	ENTER_BOLD =		tgetstr("md", &bp);
	ENTER_REVERSE =		tgetstr("mr", &bp);
	EXIT_ATTRIBUTES =	tgetstr("me", &bp);

	if (!ENTER_BOLD && ENTER_REVERSE)
		ENTER_BOLD = ENTER_REVERSE;
	if (!ENTER_BOLD && ENTER_STANDOUT)
		ENTER_BOLD = ENTER_STANDOUT;
	if (!ENTER_UNDERLINE && ENTER_STANDOUT) {
		ENTER_UNDERLINE = ENTER_STANDOUT;
		EXIT_UNDERLINE = EXIT_STANDOUT;
	}
	if (!ENTER_DIM && ENTER_STANDOUT)
		ENTER_DIM = ENTER_STANDOUT;
	if (!ENTER_REVERSE && ENTER_STANDOUT)
		ENTER_REVERSE = ENTER_STANDOUT;
	if (!EXIT_ATTRIBUTES && EXIT_STANDOUT)
		EXIT_ATTRIBUTES = EXIT_STANDOUT;
	
	/*
	 * Note that we use REVERSE for the alternate character set,
	 * not the as/ae capabilities.  This is because we are modelling
	 * the model 37 teletype (since that's what nroff outputs) and
	 * the typical as/ae is more of a graphics set, not the greek
	 * letters the 37 has.
	 */

	UNDER_CHAR =		tgetstr("uc", &bp);
	must_use_uc = (UNDER_CHAR && !ENTER_UNDERLINE);
}

int
outchar(int c)
{
	return (putwchar(c) != WEOF ? c : EOF);
}

static int curmode = 0;

void
outc(wchar_t c, int width)
{
	int i;

	putwchar(c);
	if (must_use_uc && (curmode&UNDERL)) {
		for (i = 0; i < width; i++)
			PRINT(CURS_LEFT);
		for (i = 0; i < width; i++)
			PRINT(UNDER_CHAR);
	}
}

void
msetmode(int newmode)
{
	if (!iflag) {
		if (curmode != NORMAL && newmode != NORMAL)
			msetmode(NORMAL);
		switch (newmode) {
		case NORMAL:
			switch(curmode) {
			case NORMAL:
				break;
			case UNDERL:
				PRINT(EXIT_UNDERLINE);
				break;
			default:
				/* This includes standout */
				PRINT(EXIT_ATTRIBUTES);
				break;
			}
			break;
		case ALTSET:
			PRINT(ENTER_REVERSE);
			break;
		case SUPERSC:
			/*
			 * This only works on a few terminals.
			 * It should be fixed.
			 */
			PRINT(ENTER_UNDERLINE);
			PRINT(ENTER_DIM);
			break;
		case SUBSC:
			PRINT(ENTER_DIM);
			break;
		case UNDERL:
			PRINT(ENTER_UNDERLINE);
			break;
		case BOLD:
			PRINT(ENTER_BOLD);
			break;
		default:
			/*
			 * We should have some provision here for multiple modes
			 * on at once.  This will have to come later.
			 */
			PRINT(ENTER_STANDOUT);
			break;
		}
	}
	curmode = newmode;
}
@


1.22
log
@no overstrikes in -i mode; ok millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.21 2016/03/26 08:59:29 natano Exp $	*/
a381 1
	wchar_t wc;
@


1.21
log
@Improve handling of ambiguous overstrike sequences. A sequence of _\b_
can either mean an underlined underscore or a bold underscore. This
ambiguity can be 'resolved' by takeing the state of the surrounding text
into account. If surrounded by bold text, the result should probably be
bold and likewise for underlined. less(1) previously only looked at the
preceding text and ul(1) didn't examine the context at all.

tweaks and ok schwarze
ok tb (on a previous version of the diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.20 2016/01/18 17:34:26 schwarze Exp $	*/
d364 1
a364 1
	if (must_overstrike && hadmodes)
@


1.20
log
@UTF-8 support:
This is the first example of a program where doing the full char *
to wchar_t * to char * double conversion is actually simpler than
our usual approach of working with char * throughout.  In part
inspired by the FreeBSD version which is in turn based on Bruno
Haible's work in util-linux, but not sharing any code and avoiding
the almost half a dozen bugs that FreeBSD has.

As a bonus reimplement overstrike() and iattr() almost from scratch,
getting rid of useless malloc(3)ed local buffers.

Add lots of missing information to the manual.

No opposition when shown on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.19 2015/10/10 16:15:03 deraadt Exp $	*/
d58 1
d270 7
d336 10
@


1.19
log
@plege "stdio rpath tty".  "tty" is for the curses code lurking in the
background.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.18 2015/02/08 23:40:34 deraadt Exp $	*/
d35 2
d42 1
d44 3
a46 3
#define	IESC	'\033'
#define	SO	'\016'
#define	SI	'\017'
d66 3
a68 1
	char	c_char;
d86 1
a86 1
void	outc(int);
d106 2
d164 66
a229 1
	int c;
d231 27
a257 30
	while ((c = getc(f)) != EOF && col < MAXBUF) switch(c) {
	case '\b':
		if (col > 0)
			col--;
		continue;
	case '\t':
		col = (col+8) & ~07;
		if (col > maxcol)
			maxcol = col;
		continue;
	case '\r':
		col = 0;
		continue;
	case SO:
		mode |= ALTSET;
		continue;
	case SI:
		mode &= ~ALTSET;
		continue;
	case IESC:
		switch (c = getc(f)) {
		case HREV:
			if (halfpos == 0) {
				mode |= SUPERSC;
				halfpos--;
			} else if (halfpos > 0) {
				mode &= ~SUBSC;
				halfpos--;
			} else {
				halfpos = 0;
d259 3
d263 14
a276 11
			continue;
		case HFWD:
			if (halfpos == 0) {
				mode |= SUBSC;
				halfpos++;
			} else if (halfpos < 0) {
				mode &= ~SUPERSC;
				halfpos++;
			} else {
				halfpos = 0;
				fwd();
d278 14
a291 4
			continue;
		case FREV:
			reverse();
			continue;
d293 25
a317 2
			errx(1, "0%o: unknown escape sequence", c);
			/* NOTREACHED */
d319 1
a319 37
		continue;

	case '_':
		if (obuf[col].c_char)
			obuf[col].c_mode |= UNDERL | mode;
		else
			obuf[col].c_char = '_';
		/* FALLTHROUGH */
	case ' ':
		col++;
		if (col > maxcol)
			maxcol = col;
		continue;
	case '\n':
		flushln();
		continue;
	case '\f':
		flushln();
		putchar('\f');
		continue;
	default:
		if (c < ' ')	/* non printing */
			continue;
		if (obuf[col].c_char == '\0') {
			obuf[col].c_char = c;
			obuf[col].c_mode = mode;
		} else if (obuf[col].c_char == '_') {
			obuf[col].c_char = c;
			obuf[col].c_mode |= UNDERL|mode;
		} else if (obuf[col].c_char == c)
			obuf[col].c_mode |= BOLD|mode;
		else
			obuf[col].c_mode = mode;
		col++;
		if (col > maxcol)
			maxcol = col;
		continue;
a320 2
	if (maxcol)
		flushln();
d330 1
a330 1
	for (i=0; i < maxcol; i++) {
d332 1
a332 1
			hadmodes++;
d336 1
a336 1
		if (obuf[i].c_char == '\0') {
d340 1
a340 1
				outc(' ');
d342 1
a342 1
			outc(obuf[i].c_char);
d344 1
a344 1
	if (lastmode != NORMAL) {
a345 1
	}
d348 1
a348 1
	putchar('\n');
d364 21
a384 3
	int i;
	char *buf, *cp;
	int hadbold = 0;
d386 5
a390 3
	if ((buf = malloc(maxcol + 1)) == NULL)
		err(1, NULL);
	cp = buf;
d392 2
a393 2
	/* Set up overstrike buffer */
	for (i = 0; i < maxcol; i++)
d396 10
a405 2
		default:
			*cp++ = ' ';
d408 1
a408 1
			*cp++ = '_';
d411 4
a414 2
			*cp++ = obuf[i].c_char;
			hadbold=1;
d417 6
a422 13
	putchar('\r');
	while (cp > buf && *(cp - 1) == ' ')
		cp--;
	*cp = '\0';
	for (cp = buf; *cp != '\0'; cp++)
		putchar(*cp);
	if (hadbold) {
		putchar('\r');
		for (cp = buf; *cp != '\0'; cp++)
			putchar(*cp=='_' ? ' ' : *cp);
		putchar('\r');
		for (cp = buf; *cp != '\0'; cp++)
			putchar(*cp=='_' ? ' ' : *cp);
d424 1
a424 30
	free(buf);
}

void
iattr(void)
{
	int i;
	char *buf, *cp;

	if ((buf = malloc(maxcol + 1)) == NULL)
		err(1, NULL);
	cp = buf;

	for (i=0; i < maxcol; i++)
		switch (obuf[i].c_mode) {
		case NORMAL:	*cp++ = ' '; break;
		case ALTSET:	*cp++ = 'g'; break;
		case SUPERSC:	*cp++ = '^'; break;
		case SUBSC:	*cp++ = 'v'; break;
		case UNDERL:	*cp++ = '_'; break;
		case BOLD:	*cp++ = '!'; break;
		default:	*cp++ = 'X'; break;
		}
	while (cp > buf && *(cp - 1) == ' ')
		cp--;
	*cp = '\0';
	for (cp = buf; *cp != '\0'; cp++)
		putchar(*cp);
	free(buf);
	putchar('\n');
d431 1
a431 1
	col = 0;
d514 1
a514 2
	putchar(c & 0177);
	return (0);
d520 1
a520 1
outc(int c)
d522 3
a524 1
	putchar(c);
d526 4
a529 2
		PRINT(CURS_LEFT);
		PRINT(UNDER_CHAR);
@


1.18
log
@in getopt() blocks, stop incrementing flag variable which are supposed
to just be 0/1
ok miod florian
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.17 2015/02/06 09:19:16 tedu Exp $	*/
d100 3
@


1.17
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.16 2014/11/18 20:54:28 krw Exp $	*/
d108 1
a108 1
				termtype = optarg;
@


1.16
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.15 2009/10/27 23:59:46 deraadt Exp $	*/
d104 2
a105 3
	while ((c=getopt(argc, argv, "it:T:")) != -1)
		switch(c) {

d121 1
a121 2
	switch(tgetent(termcap, termtype)) {

a123 1

a126 1

d134 3
a136 3
	if (    (tgetflag("os") && ENTER_BOLD==NULL ) ||
		(tgetflag("ul") && ENTER_UNDERLINE==NULL && UNDER_CHAR==NULL))
			must_overstrike = 1;
a156 1

a160 1

a165 1

a168 1

a171 1

a174 1

a176 1

a188 1

a200 1

a203 1

a220 1

a223 1

a227 1

d257 1
a257 1
	for (i=0; i<maxcol; i++) {
d294 1
a294 1
	int hadbold=0;
d301 1
a301 1
	for (i=0; i<maxcol; i++)
d342 1
a342 1
	for (i=0; i<maxcol; i++)
d364 1
a364 2

	bzero((char *)obuf, sizeof (obuf));	/* depends on NORMAL == 0 */
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.14 2007/10/16 20:19:27 sobrado Exp $	*/
a35 1
#include <stdlib.h>
@


1.14
log
@sync the synopsis and usage of commands

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.13 2004/07/06 14:37:59 jaredy Exp $	*/
a31 13

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)ul.c	8.1 (Berkeley) 6/6/93";
#endif
static const char rcsid[] = "$OpenBSD: ul.c,v 1.13 2004/07/06 14:37:59 jaredy Exp $";
#endif /* not lint */
@


1.13
log
@various cleanup
- fix overruns in overstrike() and iattr()
- sort headers
- sync usage output
- some KNF
- use err()/warn() where applicable

ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.12 2004/03/13 22:11:56 tedu Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: ul.c,v 1.12 2004/03/13 22:11:56 tedu Exp $";
d131 2
a132 2
				"usage: %s [-i] [-t terminal] file...\n",
				argv[0]);
@


1.12
log
@use \0 for char.  Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.11 2003/06/25 21:09:45 deraadt Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: ul.c,v 1.11 2003/06/25 21:09:45 deraadt Exp $";
d46 2
d50 1
d52 1
a53 3
#include <stdlib.h>
#include <curses.h>
#include <term.h>
d131 1
a131 1
				"usage: %s [ -i ] [ -tTerm ] file...\n",
d142 2
a143 2
		fprintf(stderr,"trouble reading termcap");
		/* fall through to ... */
d160 2
a161 4
		if (f == NULL) {
			perror(argv[optind]);
			exit(1);
		}
d233 2
a234 4
			fprintf(stderr,
				"Unknown escape sequence in input: %o, %o\n",
				IESC, c);
			exit(1);
d243 1
d324 1
a324 2
	char lbuf[256];
	char *cp = lbuf;
d327 4
d347 4
a350 3
	for (*cp=' '; *cp==' '; cp--)
		*cp = '\0';
	for (cp=lbuf; *cp; cp++)
d354 1
a354 1
		for (cp=lbuf; *cp; cp++)
d357 1
a357 1
		for (cp=lbuf; *cp; cp++)
d360 1
d367 5
a371 2
	char lbuf[256];
	char *cp = lbuf;
d383 4
a386 3
	for (*cp=' '; *cp==' '; cp--)
		*cp = '\0';
	for (cp=lbuf; *cp; cp++)
d388 1
@


1.11
log
@delete junk protos
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.10 2003/06/10 22:20:53 deraadt Exp $	*/
d34 1
a34 1
static char copyright[] =
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ul.c,v 1.10 2003/06/10 22:20:53 deraadt Exp $";
d347 1
a347 1
		*cp = 0;
d378 1
a378 1
		*cp = 0;
@


1.10
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.9 2003/06/03 02:56:20 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ul.c,v 1.9 2003/06/03 02:56:20 millert Exp $";
a420 1
	char *getenv(), *tgetstr();
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.8 2003/04/07 21:13:54 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ul.c,v 1.8 2003/04/07 21:13:54 deraadt Exp $";
d105 1
a105 3
main(argc, argv)
	int argc;
	char **argv;
d171 1
a171 2
mfilter(f)
	FILE *f;
d284 1
a284 1
flushln()
d323 1
a323 1
overstrike()
d361 1
a361 1
iattr()
d385 1
a385 1
initbuf()
d395 1
a395 1
fwd()
d407 1
a407 1
reverse()
d417 1
a417 1
initcap()
d471 1
a471 2
outchar(c)
	int c;
d480 1
a480 2
outc(c)
	int c;
d490 1
a490 2
msetmode(newmode)
	int newmode;
@


1.8
log
@replace strcpy calls that got inlined by gcc; Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.7 2001/11/19 19:02:17 mpech Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: ul.c,v 1.7 2001/11/19 19:02:17 mpech Exp $";
@


1.7
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.6 2001/07/12 05:17:27 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ul.c,v 1.6 2001/07/12 05:17:27 deraadt Exp $";
d152 2
a153 1
		(void)strcpy(termcap, "dumb:os:col#80:cr=^M:sf=^J:am:");
@


1.6
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.5 2000/03/22 15:38:23 markus Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ul.c,v 1.5 2000/03/22 15:38:23 markus Exp $";
d331 1
a331 1
	register int i;
d333 1
a333 1
	register char *cp = lbuf;
d369 1
a369 1
	register int i;
d371 1
a371 1
	register char *cp = lbuf;
@


1.5
log
@fix overflows, ok aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.4 1997/01/15 23:43:27 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ul.c,v 1.4 1997/01/15 23:43:27 millert Exp $";
d53 4
d90 17
a106 2
int	outchar();
#define	PRINT(s)	if (s == NULL) /* void */; else tputs(s, 1, outchar)
d108 1
d161 1
a161 1
		filter(stdin);
d169 1
a169 1
		filter(f);
d175 2
a176 1
filter(f)
d179 1
a179 1
	register c;
d289 1
d292 1
a292 2
	register lastmode;
	register i;
d299 1
a299 1
			setmode(obuf[i].c_mode);
d311 1
a311 1
		setmode(0);
d328 1
d366 1
d390 1
d400 1
d403 1
a403 1
	register oldcol, oldmax;
d412 1
d422 1
d476 1
d481 1
d486 1
d497 2
a498 1
setmode(newmode)
d503 1
a503 1
			setmode(NORMAL);
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.3 1996/06/26 05:42:05 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ul.c,v 1.3 1996/06/26 05:42:05 deraadt Exp $";
d160 1
a160 1
	while ((c = getc(f)) != EOF) switch(c) {
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: ul.c,v 1.3 1994/12/07 00:28:24 jtc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: ul.c,v 1.3 1994/12/07 00:28:24 jtc Exp $";
d103 1
a103 1
	while ((c=getopt(argc, argv, "it:T:")) != EOF)
@


1.2
log
@from netbsd:
Fix file descriptor leak.
Include header files to bring prototypes into scope.  Remove explicit
declarations.
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: ul.c,v 1.3 1994/12/07 00:28:24 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d50 2
a97 1
	char *getenv(), *strcpy();
d146 4
a149 2
		} else
			filter(f);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
