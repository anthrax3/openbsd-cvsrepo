head	1.15;
access;
symbols
	OPENBSD_5_6:1.14.0.12
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.10
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.6
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.4
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.4.0.6
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.15
date	2015.01.21.08.43.55;	author ratchov;	state dead;
branches;
next	1.14;
commitid	SYQcoS9jhSKqSJDL;

1.14
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2012.03.29.20.08.22;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.27.17.58.43;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.10.21.47.41;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.27.11.51.20;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2009.07.25.10.52.19;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2009.02.04.20.35.14;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.23.17.38.15;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.29.17.59.08;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.26.08.49.44;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Simplify internals and rewrite file header parsing code:
- remove -M, -t, -w, -C, -x flags that don't make sense anymore
- make "-j off" the default (sndiod already does the job)
- don't limit the number of played/recorded files.
- add support for floating-point encoded files.
- add support for apple .aiff and sun/next .au files
@
text
@/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/time.h>
#include <sys/types.h>
#include <sys/signal.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "conf.h"
#include "pipe.h"
#ifdef DEBUG
#include "dbg.h"
#endif

struct fileops pipe_ops = {
	"pipe",
	sizeof(struct pipe),
	pipe_close,
	pipe_read,
	pipe_write,
	NULL, /* start */
	NULL, /* stop */
	pipe_nfds,
	pipe_pollfd,
	pipe_revents
};

struct pipe *
pipe_new(struct fileops *ops, int fd, char *name)
{
	struct pipe *f;

	f = (struct pipe *)file_new(ops, name, 1);
	if (f == NULL)
		return NULL;
	f->fd = fd;
	return f;
}

unsigned int
pipe_read(struct file *file, unsigned char *data, unsigned int count)
{
	struct pipe *f = (struct pipe *)file;
	int n;
	
	while ((n = read(f->fd, data, count)) < 0) {
		f->file.state &= ~FILE_ROK;
		if (errno == EAGAIN) {
#ifdef DEBUG
			if (debug_level >= 4) {
				file_dbg(&f->file);
				dbg_puts(": reading blocked\n");
			}
#endif
		} else {
			warn("%s", f->file.name);
			file_eof(&f->file);
		}
		return 0;
	}
	if (n == 0) {
		f->file.state &= ~FILE_ROK; /* XXX: already cleared in file_eof */
		file_eof(&f->file);
		return 0;
	}
	return n;
}


unsigned int
pipe_write(struct file *file, unsigned char *data, unsigned int count)
{
	struct pipe *f = (struct pipe *)file;
	int n;

	while ((n = write(f->fd, data, count)) < 0) {
		f->file.state &= ~FILE_WOK;
		if (errno == EAGAIN) {
#ifdef DEBUG
			if (debug_level >= 4) {
				file_dbg(&f->file);
				dbg_puts(": writing blocked\n");
			}
#endif
		} else {
			if (errno != EPIPE)
				warn("%s", f->file.name);
			file_hup(&f->file);
		}
		return 0;
	}
	return n;
}

int
pipe_nfds(struct file *file) {
	return 1;
}

int
pipe_pollfd(struct file *file, struct pollfd *pfd, int events)
{
	struct pipe *f = (struct pipe *)file;

	pfd->fd = f->fd;
	pfd->events = events;
	return (events != 0) ? 1 : 0;
}

int
pipe_revents(struct file *f, struct pollfd *pfd)
{
	return pfd->revents;
}

void
pipe_close(struct file *file)
{
	struct pipe *f = (struct pipe *)file;

	close(f->fd);
	file_slowaccept = 0;
}

off_t
pipe_endpos(struct file *file)
{
	struct pipe *f = (struct pipe *)file;
	off_t pos;

	pos = lseek(f->fd, 0, SEEK_END);
	if (pos < 0) {
#ifdef DEBUG
		file_dbg(&f->file);
		dbg_puts(": couldn't get file size\n");
#endif
		return 0;
	}
	return pos;
}

int
pipe_seek(struct file *file, off_t pos)
{
	struct pipe *f = (struct pipe *)file;
	off_t newpos;
	
	newpos = lseek(f->fd, pos, SEEK_SET);
	if (newpos < 0) {
#ifdef DEBUG
		file_dbg(&f->file);
		dbg_puts(": couldn't seek\n");
#endif
		/* XXX: call eof() */
		return 0;
	}
	return 1;
}

int
pipe_trunc(struct file *file, off_t pos)
{
	struct pipe *f = (struct pipe *)file;

	if (ftruncate(f->fd, pos) < 0) {
#ifdef DEBUG
		file_dbg(&f->file);
		dbg_puts(": couldn't truncate file\n");
#endif
		/* XXX: call hup() */
		return 0;
	}
	return 1;
}
@


1.14
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@@


1.13
log
@Don't spin if accept() fails because it is out of file descriptors,
instead set a flag that skips the listening socket from the poll()
event loop. The flag is cleared whenever a file descriptor is closed
allowing accept() to be retried.
Explained by deraadt@@
@
text
@d60 2
a61 2
unsigned
pipe_read(struct file *file, unsigned char *data, unsigned count)
d90 2
a91 2
unsigned
pipe_write(struct file *file, unsigned char *data, unsigned count)
@


1.12
log
@use more volatile sig_atomic_t in signal handlers
ok ratchov
@
text
@d142 1
@


1.11
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d19 1
@


1.10
log
@backout last change, committed by mistake, sorry...
@
text
@d142 51
@


1.9
log
@doc fixes from jmc
@
text
@a141 51

off_t
pipe_endpos(struct file *file)
{
	struct pipe *f = (struct pipe *)file;
	off_t pos;

	pos = lseek(f->fd, 0, SEEK_END);
	if (pos < 0) {
#ifdef DEBUG
		file_dbg(&f->file);
		dbg_puts(": couldn't get file size\n");
#endif
		return 0;
	}
	return pos;
}

int
pipe_seek(struct file *file, off_t pos)
{
	struct pipe *f = (struct pipe *)file;
	off_t newpos;
	
	newpos = lseek(f->fd, pos, SEEK_SET);
	if (newpos < 0) {
#ifdef DEBUG
		file_dbg(&f->file);
		dbg_puts(": couldn't seek\n");
#endif
		/* XXX: call eof() */
		return 0;
	}
	return 1;
}

int
pipe_trunc(struct file *file, off_t pos)
{
	struct pipe *f = (struct pipe *)file;

	if (ftruncate(f->fd, pos) < 0) {
#ifdef DEBUG
		file_dbg(&f->file);
		dbg_puts(": couldn't truncate file\n");
#endif
		/* XXX: call hup() */
		return 0;
	}
	return 1;
}
@


1.8
log
@Add traces to help tracking subtle timing bugs often causing
underuns and overruns; such bugs are hard to debug with ktrace
or a debugger. They are also handy to debug or monitor code
using aucat.

To enable traces, compile aucat with ``make DEBUG=-DDEBUG'' and
use the -d option multiple times.

ok jakemsr
@
text
@d142 51
@


1.7
log
@remove all debug traces
@
text
@d30 3
d68 6
d98 6
@


1.6
log
@fix comments, remove no longer needed declaration, reorder includes
from Thomas Pfaff
@
text
@d61 1
a61 10
#ifdef DEBUG
	struct timeval tv0, tv1, dtv;
	unsigned us;

	if (!(f->file.state & FILE_ROK)) {
		DPRINTF("pipe_read: %s: bad state\n", f->file.name);
		abort();
	}
	gettimeofday(&tv0, NULL);
#endif
a64 2
			DPRINTFN(3, "pipe_read: %s: blocking...\n",
			    f->file.name);
d72 1
a72 2
		DPRINTFN(2, "pipe_read: %s: eof\n", f->file.name);
		f->file.state &= ~FILE_ROK;
a75 8
#ifdef DEBUG
	gettimeofday(&tv1, NULL);
	timersub(&tv1, &tv0, &dtv);
	us = dtv.tv_sec * 1000000 + dtv.tv_usec;
	DPRINTFN(us < 5000 ? 4 : 2,
	    "pipe_read: %s: got %d bytes in %uus\n",
	    f->file.name, n, us);
#endif
a84 3
#ifdef DEBUG
	struct timeval tv0, tv1, dtv;
	unsigned us;
a85 6
	if (!(f->file.state & FILE_WOK)) {
		DPRINTF("pipe_write: %s: bad state\n", f->file.name);
		abort();
	}
	gettimeofday(&tv0, NULL);
#endif
a88 2
			DPRINTFN(3, "pipe_write: %s: blocking...\n",
			    f->file.name);
a95 8
#ifdef DEBUG
	gettimeofday(&tv1, NULL);
	timersub(&tv1, &tv0, &dtv);
	us = dtv.tv_sec * 1000000 + dtv.tv_usec;
	DPRINTFN(us < 5000 ? 4 : 2,
	    "pipe_write: %s: wrote %d bytes in %uus\n",
	    f->file.name, n, us);
#endif
@


1.5
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 16
d19 1
@


1.4
log
@if there are too many connections, stop acceping new ones rather
than exit()ing with ``too many open files'' fatal error
@
text
@d75 1
a75 1
	DPRINTFN(us < 5000 ? 4 : 1,
d114 1
a114 1
	DPRINTFN(us < 5000 ? 4 : 1,
@


1.3
log
@spacing + typo fix from Matt Jibson <matt.jibson(at)gmail.com>
@
text
@d33 2
@


1.2
log
@make the code "more correct": add reference counters to aproc
structures so we can keep a pointer to the device. Beside some
simplifications, this allows to easily handle the situation
where the audio device desappears. No change in the behaviour.
@
text
@d72 3
a74 3
	us = dtv.tv_sec * 1000000 + dtv.tv_usec; 
	DPRINTFN(us < 5000 ? 4 : 1, 
	    "pipe_read: %s: got %d bytes in %uus\n", 
d89 1
a89 1
	
d111 1
a111 1
	us = dtv.tv_sec * 1000000 + dtv.tv_usec; 
@


1.1
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d131 1
a131 1
	return (events != 0) ? 1  : 0;
@

