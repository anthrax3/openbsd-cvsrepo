head	1.75;
access;
symbols
	OPENBSD_5_6:1.74.0.6
	OPENBSD_5_6_BASE:1.74
	OPENBSD_5_5:1.74.0.4
	OPENBSD_5_5_BASE:1.74
	OPENBSD_5_4:1.73.0.6
	OPENBSD_5_4_BASE:1.73
	OPENBSD_5_3:1.73.0.4
	OPENBSD_5_3_BASE:1.73
	OPENBSD_5_2:1.73.0.2
	OPENBSD_5_2_BASE:1.73
	OPENBSD_5_1_BASE:1.69
	OPENBSD_5_1:1.69.0.2
	OPENBSD_5_0:1.66.0.2
	OPENBSD_5_0_BASE:1.66
	OPENBSD_4_9:1.63.0.2
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.59.0.2
	OPENBSD_4_8_BASE:1.59
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.31.0.6
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5;
locks; strict;
comment	@ * @;


1.75
date	2015.01.21.08.43.55;	author ratchov;	state dead;
branches;
next	1.74;
commitid	SYQcoS9jhSKqSJDL;

1.74
date	2013.11.18.17.37.45;	author ratchov;	state Exp;
branches;
next	1.73;

1.73
date	2012.05.23.19.12.44;	author ratchov;	state Exp;
branches;
next	1.72;

1.72
date	2012.04.11.21.12.55;	author ratchov;	state Exp;
branches;
next	1.71;

1.71
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.70;

1.70
date	2012.03.23.11.59.54;	author ratchov;	state Exp;
branches;
next	1.69;

1.69
date	2012.01.10.08.10.21;	author ratchov;	state Exp;
branches;
next	1.68;

1.68
date	2011.11.20.22.54.51;	author ratchov;	state Exp;
branches;
next	1.67;

1.67
date	2011.11.16.08.03.34;	author ratchov;	state Exp;
branches;
next	1.66;

1.66
date	2011.05.26.07.26.36;	author ratchov;	state Exp;
branches;
next	1.65;

1.65
date	2011.05.26.07.18.40;	author ratchov;	state Exp;
branches;
next	1.64;

1.64
date	2011.04.28.07.20.03;	author ratchov;	state Exp;
branches;
next	1.63;

1.63
date	2010.11.04.17.55.28;	author ratchov;	state Exp;
branches;
next	1.62;

1.62
date	2010.10.21.21.42.46;	author ratchov;	state Exp;
branches;
next	1.61;

1.61
date	2010.10.21.19.10.52;	author ratchov;	state Exp;
branches;
next	1.60;

1.60
date	2010.10.21.18.57.42;	author ratchov;	state Exp;
branches;
next	1.59;

1.59
date	2010.05.07.07.15.50;	author ratchov;	state Exp;
branches;
next	1.58;

1.58
date	2010.05.04.19.40.08;	author ratchov;	state Exp;
branches;
next	1.57;

1.57
date	2010.05.02.11.12.31;	author ratchov;	state Exp;
branches;
next	1.56;

1.56
date	2010.05.02.10.40.48;	author ratchov;	state Exp;
branches;
next	1.55;

1.55
date	2010.04.24.13.32.21;	author ratchov;	state Exp;
branches;
next	1.54;

1.54
date	2010.04.24.06.18.23;	author ratchov;	state Exp;
branches;
next	1.53;

1.53
date	2010.04.21.06.13.07;	author ratchov;	state Exp;
branches;
next	1.52;

1.52
date	2010.04.17.09.16.57;	author ratchov;	state Exp;
branches;
next	1.51;

1.51
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.50;

1.50
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.49;

1.49
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.48;

1.48
date	2010.01.17.19.17.23;	author ratchov;	state Exp;
branches;
next	1.47;

1.47
date	2010.01.17.16.09.30;	author ratchov;	state Exp;
branches;
next	1.46;

1.46
date	2010.01.15.22.17.10;	author ratchov;	state Exp;
branches;
next	1.45;

1.45
date	2010.01.14.17.57.47;	author ratchov;	state Exp;
branches;
next	1.44;

1.44
date	2010.01.12.21.42.59;	author ratchov;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.11.13.06.32;	author ratchov;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.10.21.47.41;	author ratchov;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.05.10.18.12;	author ratchov;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.15.21.44.09;	author ratchov;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.05.08.36.48;	author ratchov;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.03.21.31.37;	author ratchov;	state Exp;
branches;
next	1.37;

1.37
date	2009.10.10.09.54.05;	author ratchov;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.09.16.49.48;	author ratchov;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.06.18.06.55;	author ratchov;	state Exp;
branches;
next	1.34;

1.34
date	2009.09.27.11.51.20;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2009.07.25.10.52.18;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.23.17.38.15;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.29.17.59.08;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.27.17.02.13;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.27.16.10.39;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2008.12.19.08.01.06;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2008.12.07.17.10.41;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2008.11.16.17.08.32;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2008.11.16.16.30.22;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.10.23.25.37;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.09.16.26.07;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.07.21.01.15;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2008.11.06.17.47.52;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.04.22.18.12;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.04.18.24.06;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.04.17.51.46;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.04.15.22.40;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.04.14.16.09;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.03.22.55.34;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.03.22.25.13;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2008.10.26.08.49.43;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2008.08.20.14.22.50;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2008.08.14.09.58.55;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2008.08.14.09.47.51;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2008.08.14.09.45.23;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2008.08.14.09.44.15;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.14.09.39.16;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.02.17.06.36;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.02.17.05.12;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.02.17.03.25;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.25.21.16.37;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.23.07.15.46;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.75
log
@Simplify internals and rewrite file header parsing code:
- remove -M, -t, -w, -C, -x flags that don't make sense anymore
- make "-j off" the default (sndiod already does the job)
- don't limit the number of played/recorded files.
- add support for floating-point encoded files.
- add support for apple .aiff and sun/next .au files
@
text
@/*	$OpenBSD: aproc.c,v 1.74 2013/11/18 17:37:45 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * aproc structures are simple audio processing units. They are
 * interconnected by abuf structures and form a kind of circuit. aproc
 * structure have call-backs that do the actual processing.
 *
 * This module implements the following processing units:
 *
 *  - rpipe: read end of an unix file (pipe, socket, device...)
 *
 *  - wpipe: write end of an unix file (pipe, socket, device...)
 *
 *  - mix: mix N inputs -> 1 output
 *
 *  - sub: from 1 input -> extract/copy N outputs
 *
 *  - conv: converts/resamples/remaps a single stream
 *
 *  - resamp: resample streams in native format
 *
 */
#include <err.h>
#include <stdlib.h>
#include <string.h>

#include "abuf.h"
#include "aparams.h"
#include "aproc.h"
#include "conf.h"
#include "file.h"
#include "midi.h"
#ifdef DEBUG
#include "dbg.h"
#endif

/*
 * Same as ABUF_ROK(), but consider that a buffer is 
 * readable if there's silence pending to be inserted
 */
#define MIX_ROK(buf) (ABUF_ROK(buf) || (buf)->r.mix.drop < 0)

/*
 * Same as ABUF_WOK(), but consider that a buffer is 
 * writeable if there are samples to drop
 */
#define SUB_WOK(buf) (ABUF_WOK(buf) || (buf)->w.sub.silence < 0)

int zomb_in(struct aproc *, struct abuf *);
int zomb_out(struct aproc *, struct abuf *);
void zomb_eof(struct aproc *, struct abuf *);
void zomb_hup(struct aproc *, struct abuf *);
void zomb_newin(struct aproc *, struct abuf *);
void zomb_newout(struct aproc *, struct abuf *);
void zomb_ipos(struct aproc *, struct abuf *, int);
void zomb_opos(struct aproc *, struct abuf *, int);

int rfile_do(struct aproc *, unsigned int, unsigned int *);
int rfile_in(struct aproc *, struct abuf *);
int rfile_out(struct aproc *, struct abuf *);
void rfile_done(struct aproc *);
void rfile_eof(struct aproc *, struct abuf *);
void rfile_hup(struct aproc *, struct abuf *);

void wfile_done(struct aproc *);
int wfile_do(struct aproc *, unsigned int, unsigned int *);
int wfile_in(struct aproc *, struct abuf *);
int wfile_out(struct aproc *, struct abuf *);
void wfile_eof(struct aproc *, struct abuf *);
void wfile_hup(struct aproc *, struct abuf *);

void mix_drop(struct abuf *, int);
void mix_bzero(struct abuf *, unsigned int);
unsigned int mix_badd(struct abuf *, struct abuf *);
int mix_xrun(struct aproc *, struct abuf *);
int mix_in(struct aproc *, struct abuf *);
int mix_out(struct aproc *, struct abuf *);
void mix_eof(struct aproc *, struct abuf *);
void mix_hup(struct aproc *, struct abuf *);
void mix_newin(struct aproc *, struct abuf *);
void mix_newout(struct aproc *, struct abuf *);
void mix_opos(struct aproc *, struct abuf *, int);
void mix_setmaster(struct aproc *);
void mix_clear(struct aproc *);
void mix_quit(struct aproc *);

void sub_silence(struct abuf *, int);
void sub_bcopy(struct abuf *, struct abuf *);
int sub_xrun(struct aproc *, struct abuf *);
int sub_in(struct aproc *, struct abuf *);
int sub_out(struct aproc *, struct abuf *);
void sub_eof(struct aproc *, struct abuf *);
void sub_hup(struct aproc *, struct abuf *);
void sub_newout(struct aproc *, struct abuf *);
void sub_ipos(struct aproc *, struct abuf *, int);
void sub_clear(struct aproc *);

void resamp_bcopy(struct aproc *, struct abuf *, struct abuf *);
int resamp_in(struct aproc *, struct abuf *);
int resamp_out(struct aproc *, struct abuf *);
void resamp_eof(struct aproc *, struct abuf *);
void resamp_hup(struct aproc *, struct abuf *);
void resamp_ipos(struct aproc *, struct abuf *, int);
void resamp_opos(struct aproc *, struct abuf *, int);

void enc_bcopy(struct aproc *, struct abuf *, struct abuf *);
int enc_in(struct aproc *, struct abuf *);
int enc_out(struct aproc *, struct abuf *);
void enc_eof(struct aproc *, struct abuf *);
void enc_hup(struct aproc *, struct abuf *);

void dec_bcopy(struct aproc *, struct abuf *, struct abuf *);
int dec_in(struct aproc *, struct abuf *);
int dec_out(struct aproc *, struct abuf *);
void dec_eof(struct aproc *, struct abuf *);
void dec_hup(struct aproc *, struct abuf *);

void join_bcopy(struct aproc *, struct abuf *, struct abuf *);
int join_in(struct aproc *, struct abuf *);
int join_out(struct aproc *, struct abuf *);
void join_eof(struct aproc *, struct abuf *);
void join_hup(struct aproc *, struct abuf *);

void mon_flush(struct aproc *);
void mon_snoop(struct aproc *, struct abuf *, unsigned int, unsigned int);
int mon_in(struct aproc *, struct abuf *);
void mon_clear(struct aproc *);
int mon_out(struct aproc *, struct abuf *);
void mon_eof(struct aproc *, struct abuf *);
void mon_hup(struct aproc *, struct abuf *);
void mon_ipos(struct aproc *, struct abuf *, int);

#ifdef DEBUG
void
aproc_dbg(struct aproc *p)
{
	dbg_puts(p->ops->name);
	dbg_puts("(");
	dbg_puts(p->name);
	dbg_puts(")");
}

int
zomb_in(struct aproc *p, struct abuf *ibuf)
{
	aproc_dbg(p);
	dbg_puts(": in: terminated\n");
	dbg_panic();
	return 0;
}


int
zomb_out(struct aproc *p, struct abuf *obuf)
{
	aproc_dbg(p);
	dbg_puts(": out: terminated\n");
	dbg_panic();
	return 0;
}

void
zomb_eof(struct aproc *p, struct abuf *ibuf)
{
	aproc_dbg(p);
	dbg_puts(": eof: terminated\n");
	dbg_panic();
}

void
zomb_hup(struct aproc *p, struct abuf *obuf)
{
	aproc_dbg(p);
	dbg_puts(": hup: terminated\n");
	dbg_panic();
}

void
zomb_newin(struct aproc *p, struct abuf *ibuf)
{
	aproc_dbg(p);
	dbg_puts(": newin: terminated\n");
	dbg_panic();
}

void
zomb_newout(struct aproc *p, struct abuf *obuf)
{
	aproc_dbg(p);
	dbg_puts(": newout: terminated\n");
	dbg_panic();
}

void
zomb_ipos(struct aproc *p, struct abuf *ibuf, int delta)
{
	aproc_dbg(p);
	dbg_puts(": ipos: terminated\n");
	dbg_panic();
}

void
zomb_opos(struct aproc *p, struct abuf *obuf, int delta)
{
	aproc_dbg(p);
	dbg_puts(": opos: terminated\n");
	dbg_panic();
}

struct aproc_ops zomb_ops = {
	"zomb",
	zomb_in,
	zomb_out,
	zomb_eof,
	zomb_hup,
	zomb_newin,
	zomb_newout,
	zomb_ipos,
	zomb_opos,
	NULL
};
#endif

struct aproc *
aproc_new(struct aproc_ops *ops, char *name)
{
	struct aproc *p;

	p = malloc(sizeof(struct aproc));
	if (p == NULL)
		err(1, "%s", name);
	LIST_INIT(&p->ins);
	LIST_INIT(&p->outs);
	p->name = name;
	p->ops = ops;
	p->refs = 0;
	p->flags = 0;
	return p;
}

void
aproc_del(struct aproc *p)
{
	struct abuf *i;

#ifdef DEBUG
	if (!p) {
		dbg_puts("aproc_del: called with NULL argument\n");
		dbg_panic();
	}
#endif
	if (!(p->flags & APROC_ZOMB)) {
#ifdef DEBUG
		if (debug_level >= 3) {
			aproc_dbg(p);
			dbg_puts(": terminating...\n");
		}
#endif
		if (p->ops->done) {
#ifdef DEBUG
			if (debug_level >= 3) {
				aproc_dbg(p);
				dbg_puts(": done\n");
			}
#endif
			p->ops->done(p);
		}
		while (!LIST_EMPTY(&p->ins)) {
			i = LIST_FIRST(&p->ins);
			abuf_hup(i);
		}
		while (!LIST_EMPTY(&p->outs)) {
			i = LIST_FIRST(&p->outs);
			abuf_eof(i);
		}
		p->flags |= APROC_ZOMB;
	}
	if (p->refs > 0) {
#ifdef DEBUG
		if (debug_level >= 3) {
			aproc_dbg(p);
			dbg_puts(": free delayed\n");
			p->ops = &zomb_ops;
		}
#endif
		return;
	}
#ifdef DEBUG
	if (debug_level >= 3) {
		aproc_dbg(p);
		dbg_puts(": freed\n");
	}
#endif
	free(p);
}

void
aproc_setin(struct aproc *p, struct abuf *ibuf)
{
	LIST_INSERT_HEAD(&p->ins, ibuf, ient);
	ibuf->rproc = p;
	if (p->ops->newin)
		p->ops->newin(p, ibuf);
}

void
aproc_setout(struct aproc *p, struct abuf *obuf)
{
	LIST_INSERT_HEAD(&p->outs, obuf, oent);
	obuf->wproc = p;
	if (p->ops->newout)
		p->ops->newout(p, obuf);
}

void
aproc_ipos(struct aproc *p, struct abuf *ibuf, int delta)
{
	struct abuf *obuf;

	LIST_FOREACH(obuf, &p->outs, oent) {
		abuf_ipos(obuf, delta);
	}
}

void
aproc_opos(struct aproc *p, struct abuf *obuf, int delta)
{
	struct abuf *ibuf;

	LIST_FOREACH(ibuf, &p->ins, ient) {
		abuf_opos(ibuf, delta);
	}
}

int
aproc_inuse(struct aproc *p)
{
	struct abuf *i;

	LIST_FOREACH(i, &p->ins, ient) {
		if (i->inuse)
			return 1;
	}
	LIST_FOREACH(i, &p->outs, oent) {
		if (i->inuse)
			return 1;
	}
	return 0;
}

int
aproc_depend(struct aproc *p, struct aproc *dep)
{
	struct abuf *i;

	if (p == dep)
		return 1;
	if (p == NULL)
		return 0;
	LIST_FOREACH(i, &p->ins, ient) {
		if (i->wproc && aproc_depend(i->wproc, dep))
			return 1;
	}
	return 0;
}

int
rfile_do(struct aproc *p, unsigned int todo, unsigned int *done)
{
	struct abuf *obuf = LIST_FIRST(&p->outs);
	struct file *f = p->u.io.file;
	unsigned char *data;
	unsigned int n, count, off;

	off = p->u.io.partial;
	data = abuf_wgetblk(obuf, &count, 0);
	if (count > todo)
		count = todo;
	n = file_read(f, data + off, count * obuf->bpf - off);
	if (n == 0)
		return 0;
	n += off;
	p->u.io.partial = n % obuf->bpf;
	count = n / obuf->bpf;
	if (count > 0)
		abuf_wcommit(obuf, count);
	if (done)
		*done = count;
	return 1;
}

int
rfile_in(struct aproc *p, struct abuf *ibuf_dummy)
{
	struct abuf *obuf = LIST_FIRST(&p->outs);
	struct file *f = p->u.io.file;

	if (!ABUF_WOK(obuf) || !(f->state & FILE_ROK))
		return 0;
	if (!rfile_do(p, obuf->len, NULL))
		return 0;
	if (!abuf_flush(obuf))
		return 0;
	return 1;
}

int
rfile_out(struct aproc *p, struct abuf *obuf)
{
	struct file *f = p->u.io.file;

	if (f->state & FILE_RINUSE)
		return 0;
	if (!ABUF_WOK(obuf) || !(f->state & FILE_ROK))
		return 0;
	if (!rfile_do(p, obuf->len, NULL))
		return 0;
	return 1;
}

void
rfile_done(struct aproc *p)
{
	struct file *f = p->u.io.file;
	struct abuf *obuf;

	if (f == NULL)
		return;
	/*
	 * disconnect from file structure
	 */
	f->rproc = NULL;
	p->u.io.file = NULL;

	/*
	 * all buffers must be detached before deleting f->wproc,
	 * because otherwise it could trigger this code again
	 */
	obuf = LIST_FIRST(&p->outs);
	if (obuf)
		abuf_eof(obuf);
	if (f->wproc) {
		aproc_del(f->wproc);
	} else
		file_del(f);

#ifdef DEBUG
	if (debug_level >= 2 && p->u.io.partial > 0) {
		aproc_dbg(p);
		dbg_puts(": ");
		dbg_putu(p->u.io.partial);
		dbg_puts(" bytes lost in partial read\n");
	}
#endif
}

void
rfile_eof(struct aproc *p, struct abuf *ibuf_dummy)
{
	aproc_del(p);
}

void
rfile_hup(struct aproc *p, struct abuf *obuf)
{
	aproc_del(p);
}

struct aproc_ops rfile_ops = {
	"rfile",
	rfile_in,
	rfile_out,
	rfile_eof,
	rfile_hup,
	NULL, /* newin */
	NULL, /* newout */
	aproc_ipos,
	aproc_opos,
	rfile_done
};

struct aproc *
rfile_new(struct file *f)
{
	struct aproc *p;

	p = aproc_new(&rfile_ops, f->name);
	p->u.io.file = f;
	p->u.io.partial = 0;
	f->rproc = p;
	return p;
}

void
wfile_done(struct aproc *p)
{
	struct file *f = p->u.io.file;
	struct abuf *ibuf;

	if (f == NULL)
		return;
	/*
	 * disconnect from file structure
	 */
	f->wproc = NULL;
	p->u.io.file = NULL;

	/*
	 * all buffers must be detached before deleting f->rproc,
	 * because otherwise it could trigger this code again
	 */
	ibuf = LIST_FIRST(&p->ins);
	if (ibuf)
		abuf_hup(ibuf);
	if (f->rproc) {
		aproc_del(f->rproc);
	} else
		file_del(f);
#ifdef DEBUG
	if (debug_level >= 2 && p->u.io.partial > 0) {
		aproc_dbg(p);
		dbg_puts(": ");
		dbg_putu(p->u.io.partial);
		dbg_puts(" bytes lost in partial write\n");
	}
#endif
}

int
wfile_do(struct aproc *p, unsigned int todo, unsigned int *done)
{
	struct abuf *ibuf = LIST_FIRST(&p->ins);
	struct file *f = p->u.io.file;
	unsigned char *data;
	unsigned int n, count, off;

	off = p->u.io.partial;
	data = abuf_rgetblk(ibuf, &count, 0);
	if (count > todo)
		count = todo;
	n = file_write(f, data + off, count * ibuf->bpf - off);
	if (n == 0)
		return 0;
	n += off;
	p->u.io.partial = n % ibuf->bpf;
	count = n / ibuf->bpf;
	if (count > 0)
		abuf_rdiscard(ibuf, count);
	if (done)
		*done = count;
	return 1;
}
int
wfile_in(struct aproc *p, struct abuf *ibuf)
{
	struct file *f = p->u.io.file;

	if (f->state & FILE_WINUSE)
		return 0;
	if (!ABUF_ROK(ibuf) || !(f->state & FILE_WOK))
		return 0;
	if (!wfile_do(p, ibuf->len, NULL))
		return 0;
	return 1;
}

int
wfile_out(struct aproc *p, struct abuf *obuf_dummy)
{
	struct abuf *ibuf = LIST_FIRST(&p->ins);
	struct file *f = p->u.io.file;

	if (!abuf_fill(ibuf))
		return 0;
	if (!ABUF_ROK(ibuf) || !(f->state & FILE_WOK))
		return 0;
	if (!wfile_do(p, ibuf->len, NULL))
		return 0;
	return 1;
}

void
wfile_eof(struct aproc *p, struct abuf *ibuf)
{
	aproc_del(p);
}

void
wfile_hup(struct aproc *p, struct abuf *obuf_dummy)
{
	aproc_del(p);
}

struct aproc_ops wfile_ops = {
	"wfile",
	wfile_in,
	wfile_out,
	wfile_eof,
	wfile_hup,
	NULL, /* newin */
	NULL, /* newout */
	aproc_ipos,
	aproc_opos,
	wfile_done
};

struct aproc *
wfile_new(struct file *f)
{
	struct aproc *p;

	p = aproc_new(&wfile_ops, f->name);
	p->u.io.file = f;
	p->u.io.partial = 0;
	f->wproc = p;
	return p;
}

/*
 * Drop as much as possible samples from the reader end,
 * negative values mean ``insert silence''.
 */
void
mix_drop(struct abuf *buf, int extra)
{
	unsigned int count;

	buf->r.mix.drop += extra;
	while (buf->r.mix.drop > 0) {
		count = buf->r.mix.drop;
		if (count > buf->used)
			count = buf->used;
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 4) {
				abuf_dbg(buf);
				dbg_puts(": drop: no data\n");
			}
#endif
			return;
		}
		abuf_rdiscard(buf, count);
		buf->r.mix.drop -= count;
#ifdef DEBUG
		if (debug_level >= 4) {
			abuf_dbg(buf);
			dbg_puts(": dropped ");
			dbg_putu(count);
			dbg_puts(", to drop = ");
			dbg_putu(buf->r.mix.drop);
			dbg_puts("\n");
		}
#endif
	}
}

/*
 * Append the necessary amount of silence, in a way
 * obuf->w.mix.todo doesn't exceed the given value
 */
void
mix_bzero(struct abuf *obuf, unsigned int maxtodo)
{
	adata_t *odata;
	unsigned int ocount, todo;

	if (obuf->w.mix.todo >= maxtodo)
		return;
	todo = maxtodo - obuf->w.mix.todo;
	odata = (adata_t *)abuf_wgetblk(obuf, &ocount, obuf->w.mix.todo);
	if (ocount > todo)
		ocount = todo;
	if (ocount == 0)
		return;
	memset(odata, 0, ocount * obuf->bpf);
	obuf->w.mix.todo += ocount;
#ifdef DEBUG
	if (debug_level >= 4) {
		abuf_dbg(obuf);
		dbg_puts(": bzero(");
		dbg_putu(obuf->w.mix.todo);
		dbg_puts(")\n");
	}
#endif
}

/*
 * Mix an input block over an output block.
 */
unsigned int
mix_badd(struct abuf *ibuf, struct abuf *obuf)
{
	adata_t *idata, *odata;
	unsigned int i, scount, icount, ocount;
	int j, cc, cmin, cmax, istart, inext, onext, ostart, onch;
	int vol, s;

#ifdef DEBUG
	if (debug_level >= 4) {
		abuf_dbg(ibuf);
		dbg_puts(": badd: done = ");
		dbg_putu(ibuf->r.mix.done);
		dbg_puts("/");
		dbg_putu(obuf->w.mix.todo);
		dbg_puts(", drop = ");
		dbg_puti(ibuf->r.mix.drop);
		dbg_puts("\n");
	}
#endif
	/*
	 * Insert silence for xrun correction
	 */
	while (ibuf->r.mix.drop < 0) {
		icount = -ibuf->r.mix.drop;
		mix_bzero(obuf, ibuf->r.mix.done + icount);
		ocount = obuf->w.mix.todo - ibuf->r.mix.done;
		if (ocount == 0)
			return 0;
		scount = (icount < ocount) ? icount : ocount;
		ibuf->r.mix.done += scount;
		ibuf->r.mix.drop += scount;
	}

	/*
	 * Calculate the maximum we can read.
	 */
	idata = (adata_t *)abuf_rgetblk(ibuf, &icount, 0);
	if (icount == 0)
		return 0;

	/*
	 * Calculate the maximum we can write.
	 */
	odata = (adata_t *)abuf_wgetblk(obuf, &ocount, ibuf->r.mix.done);
	if (ocount == 0)
		return 0;

	scount = (icount < ocount) ? icount : ocount;
	mix_bzero(obuf, scount + ibuf->r.mix.done);

	vol = ADATA_MUL(ibuf->r.mix.weight, ibuf->r.mix.vol);
	cmin = obuf->cmin > ibuf->cmin ? obuf->cmin : ibuf->cmin;
	cmax = obuf->cmax < ibuf->cmax ? obuf->cmax : ibuf->cmax;
	onch = obuf->cmax - obuf->cmin + 1;
	ostart = cmin - obuf->cmin;
	if (ostart > onch)
		ostart = onch;
	onext = obuf->cmax - cmax;	
	if (onext > onch)
		onext = onch;
	istart = cmin - ibuf->cmin;
	inext = ibuf->cmax - cmax;
	cc = cmax - cmin + 1;
	for (i = scount; i > 0; i--) {
		odata += ostart;
		idata += istart;
		for (j = cc; j > 0; j--) {
			s = *odata + ADATA_MUL(*idata, vol);
			if (s >= ADATA_UNIT)
				s = ADATA_UNIT - 1;
			else if (s < -ADATA_UNIT)
				s = -ADATA_UNIT;
			*odata = s;
			idata++;
			odata++;
		}
		odata += onext;
		idata += inext;
	}
	abuf_rdiscard(ibuf, scount);
	ibuf->r.mix.done += scount;

#ifdef DEBUG
	if (debug_level >= 4) {
		abuf_dbg(ibuf);
		dbg_puts(": badd: done = ");
		dbg_putu(ibuf->r.mix.done);
		dbg_puts("/");
		dbg_putu(obuf->w.mix.todo);
		dbg_puts("\n");
	}
#endif
	return scount;
}

/*
 * Handle buffer underrun, return 0 if stream died.
 */
int
mix_xrun(struct aproc *p, struct abuf *i)
{
	struct abuf *obuf = LIST_FIRST(&p->outs);
	unsigned int fdrop, remain;

	if (i->r.mix.done > 0)
		return 1;
	if (i->r.mix.xrun == XRUN_ERROR) {
		abuf_hup(i);
		return 0;
	}
	fdrop = obuf->w.mix.todo;
#ifdef DEBUG
	if (debug_level >= 3) {
		abuf_dbg(i);
		dbg_puts(": underrun, dropping ");
		dbg_putu(fdrop);
		dbg_puts(" + ");
		dbg_putu(i->r.mix.drop);
		dbg_puts("\n");
	}
#endif
	i->r.mix.done += fdrop;
	if (i->r.mix.xrun == XRUN_SYNC)
		mix_drop(i, fdrop);
	else {
		remain = fdrop % p->u.mix.round;
		if (remain)
			remain = p->u.mix.round - remain;
		mix_drop(i, -(int)remain);
		fdrop += remain;
#ifdef DEBUG
		if (debug_level >= 3) {
			abuf_dbg(i);
			dbg_puts(": underrun, adding ");
			dbg_putu(remain);
			dbg_puts("\n");
		}
#endif
		abuf_opos(i, -(int)fdrop);
		if (i->duplex) {
#ifdef DEBUG
			if (debug_level >= 3) {
				abuf_dbg(i->duplex);
				dbg_puts(": full-duplex resync\n");
			}
#endif
			sub_silence(i->duplex, -(int)fdrop);
			abuf_ipos(i->duplex, -(int)fdrop);
		}
	}
	return 1;
}

int
mix_in(struct aproc *p, struct abuf *ibuf)
{
	struct abuf *i, *inext, *obuf = LIST_FIRST(&p->outs);
	unsigned int odone;
	unsigned int maxwrite;
	unsigned int scount;

#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": used = ");
		dbg_putu(ibuf->used);
		dbg_puts("/");
		dbg_putu(ibuf->len);
		dbg_puts(", done = ");
		dbg_putu(ibuf->r.mix.done);
		dbg_puts("/");
		dbg_putu(obuf->w.mix.todo);
		dbg_puts("\n");
	}
#endif
	if (!MIX_ROK(ibuf))
		return 0;
	scount = 0;
	odone = obuf->len;
	for (i = LIST_FIRST(&p->ins); i != NULL; i = inext) {
		inext = LIST_NEXT(i, ient);
		if (i->r.mix.drop >= 0 && !abuf_fill(i))
			continue; /* eof */
		mix_drop(i, 0);
		scount += mix_badd(i, obuf);
		if (odone > i->r.mix.done)
			odone = i->r.mix.done;
	}
	if (LIST_EMPTY(&p->ins) || scount == 0)
		return 0;
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": maxwrite = ");
		dbg_putu(p->u.mix.maxlat);
		dbg_puts(" - ");
		dbg_putu(p->u.mix.lat);
		dbg_puts(" = ");
		dbg_putu(p->u.mix.maxlat - p->u.mix.lat);
		dbg_puts("\n");
	}
#endif
	maxwrite = p->u.mix.maxlat - p->u.mix.lat;
	if (maxwrite > 0) {
		if (odone > maxwrite)
			odone = maxwrite;
		p->u.mix.lat += odone;
		LIST_FOREACH(i, &p->ins, ient) {
			i->r.mix.done -= odone;
		}
		abuf_wcommit(obuf, odone);
		obuf->w.mix.todo -= odone;
		if (APROC_OK(p->u.mix.mon))
			mon_snoop(p->u.mix.mon, obuf, obuf->used - odone, odone);
		if (!abuf_flush(obuf))
			return 0; /* hup */
	}
	return 1;
}

int
mix_out(struct aproc *p, struct abuf *obuf)
{
	struct abuf *i, *inext;
	unsigned int odone;
	unsigned int maxwrite;
	unsigned int scount;

#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": used = ");
		dbg_putu(obuf->used);
		dbg_puts("/");
		dbg_putu(obuf->len);
		dbg_puts(", todo = ");
		dbg_putu(obuf->w.mix.todo);
		dbg_puts("/");
		dbg_putu(obuf->len);
		dbg_puts("\n");
	}
#endif
	if (!ABUF_WOK(obuf))
		return 0;
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": maxwrite = ");
		dbg_putu(p->u.mix.maxlat);
		dbg_puts(" - ");
		dbg_putu(p->u.mix.lat);
		dbg_puts(" = ");
		dbg_putu(p->u.mix.maxlat - p->u.mix.lat);
		dbg_puts("\n");
	}
#endif
	maxwrite = p->u.mix.maxlat - p->u.mix.lat;
	if (maxwrite > obuf->w.mix.todo) {
		if ((p->flags & (APROC_QUIT | APROC_DROP)) == APROC_DROP)
			mix_bzero(obuf, maxwrite);
	}
	scount = 0;
	odone = obuf->len;
	for (i = LIST_FIRST(&p->ins); i != NULL; i = inext) {
		inext = LIST_NEXT(i, ient);
		if (i->r.mix.drop >= 0 && !abuf_fill(i))
			continue; /* eof */
		mix_drop(i, 0);
		if (maxwrite > 0 && !MIX_ROK(i)) {
			if (p->flags & APROC_DROP) {
				if (!mix_xrun(p, i))
					continue;
			}
		} else
			scount += mix_badd(i, obuf);
		if (odone > i->r.mix.done)
			odone = i->r.mix.done;
	}
	if (LIST_EMPTY(&p->ins) && obuf->w.mix.todo == 0) {
		if (p->flags & APROC_QUIT) {
			aproc_del(p);
			return 0;
		}
		if (!(p->flags & APROC_DROP))
			return 0;
	}
	if (odone > obuf->w.mix.todo)
		odone = obuf->w.mix.todo;
	if (odone > maxwrite)
		odone = maxwrite;
	if (odone > 0) {
		p->u.mix.lat += odone;
		LIST_FOREACH(i, &p->ins, ient) {
			i->r.mix.done -= odone;
		}
		abuf_wcommit(obuf, odone);
		obuf->w.mix.todo -= odone;
		if (APROC_OK(p->u.mix.mon))
			mon_snoop(p->u.mix.mon, obuf, obuf->used - odone, odone);
	}
	if (LIST_EMPTY(&p->ins))
		p->u.mix.idle += odone;
	if (scount == 0)
		return 0;
	return 1;
}

void
mix_eof(struct aproc *p, struct abuf *ibuf)
{
	struct abuf *i, *obuf = LIST_FIRST(&p->outs);
	unsigned int odone;

	mix_setmaster(p);

	if (!aproc_inuse(p)) {
#ifdef DEBUG
		if (debug_level >= 3) {
			aproc_dbg(p);
			dbg_puts(": running other streams\n");
		}
#endif
		/*
		 * Find a blocked input.
		 */
		odone = obuf->len;
		LIST_FOREACH(i, &p->ins, ient) {
			/*
			 * abuf_fill() may trigger mix_eof(), do the job
			 * and possibly reorder the list
			 */
			if (!abuf_fill(i))
				return;
			if (MIX_ROK(i) && i->r.mix.done < obuf->w.mix.todo) {
				abuf_run(i);
				return;
			}
			if (odone > i->r.mix.done)
				odone = i->r.mix.done;
		}
		/*
		 * No blocked inputs. Check if output is blocked.
		 */
		if (LIST_EMPTY(&p->ins) || odone == obuf->w.mix.todo)
			abuf_run(obuf);
	}
}

void
mix_hup(struct aproc *p, struct abuf *obuf)
{
	aproc_del(p);
}

void
mix_newin(struct aproc *p, struct abuf *ibuf)
{
	p->u.mix.idle = 0;
	ibuf->r.mix.done = 0;
	ibuf->r.mix.vol = ADATA_UNIT;
	ibuf->r.mix.weight = ADATA_UNIT;
	ibuf->r.mix.maxweight = ADATA_UNIT;
	ibuf->r.mix.xrun = XRUN_IGNORE;
	ibuf->r.mix.drop = 0;
}

void
mix_newout(struct aproc *p, struct abuf *obuf)
{
#ifdef DEBUG
	if (debug_level >= 3) {
		aproc_dbg(p);
		dbg_puts(": newout, will use ");
		dbg_putu(obuf->len);
		dbg_puts(" fr\n");
	}
#endif
	obuf->w.mix.todo = 0;
}

void
mix_opos(struct aproc *p, struct abuf *obuf, int delta)
{
	p->u.mix.lat -= delta;
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": opos: lat = ");
		dbg_puti(p->u.mix.lat);
		dbg_puts("/");
		dbg_puti(p->u.mix.maxlat);
		dbg_puts("\n");
	}
#endif
	aproc_opos(p, obuf, delta);
	if (APROC_OK(p->u.mix.mon))
		p->u.mix.mon->ops->ipos(p->u.mix.mon, NULL, delta);
}

struct aproc_ops mix_ops = {
	"mix",
	mix_in,
	mix_out,
	mix_eof,
	mix_hup,
	mix_newin,
	mix_newout,
	aproc_ipos,
	mix_opos,
	NULL
};

struct aproc *
mix_new(char *name, int maxlat, unsigned int round,
    unsigned int autovol, unsigned int master)
{
	struct aproc *p;

	p = aproc_new(&mix_ops, name);
	p->u.mix.idle = 0;
	p->u.mix.lat = 0;
	p->u.mix.round = round;
	p->u.mix.maxlat = maxlat;
	p->u.mix.mon = NULL;
	p->u.mix.autovol = autovol;
	p->u.mix.master = master;
	return p;
}

/*
 * Normalize input levels.
 */
void
mix_setmaster(struct aproc *p)
{
	unsigned int n;
	struct abuf *i, *j;
	int weight;

	LIST_FOREACH(i, &p->ins, ient) {
		weight = ADATA_UNIT;
		if (p->u.mix.autovol) {
			/*
			 * count the number of inputs that have
			 * overlapping channel sets
			 */
			n = 0;
			LIST_FOREACH(j, &p->ins, ient) {
				if (i->cmin <= j->cmax && i->cmax >= j->cmin)
					n++;
			}
			weight /= n;
		}
		if (weight > i->r.mix.maxweight)
			weight = i->r.mix.maxweight;
		i->r.mix.weight = ADATA_MUL(weight, p->u.mix.master);
#ifdef DEBUG
		if (debug_level >= 3) {
			abuf_dbg(i);
			dbg_puts(": setmaster: ");
			dbg_puti(i->r.mix.weight);
			dbg_puts("/");
			dbg_puti(i->r.mix.maxweight);
			dbg_puts("\n");
		}
#endif
	}
}

void
mix_clear(struct aproc *p)
{
	struct abuf *obuf = LIST_FIRST(&p->outs);

	p->u.mix.lat = 0;
	obuf->w.mix.todo = 0;
}

/*
 * Gracefully terminate the mixer: raise the APROC_QUIT flag
 * and let the rest of the code do the job. If there are neither
 * inputs nor uncommited data, then terminate right away
 */
void
mix_quit(struct aproc *p)
{
	struct abuf *obuf = LIST_FIRST(&p->outs);

	p->flags |= APROC_QUIT;

	/*
	 * eof the last input will trigger aproc_del()
	 */
	if (!LIST_EMPTY(&p->ins) || obuf->w.mix.todo > 0)
		return;
	aproc_del(p);	
}

/*
 * Append as much as possible silence on the writer end
 */
void
sub_silence(struct abuf *buf, int extra)
{
	unsigned char *data;
	unsigned int count;

	buf->w.sub.silence += extra;
	if (buf->w.sub.silence > 0) {
		data = abuf_wgetblk(buf, &count, 0);
		if (count >= buf->w.sub.silence)
			count = buf->w.sub.silence;
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 4) {
				abuf_dbg(buf);
				dbg_puts(": no space for silence\n");
			}
#endif
			return;
		}
		memset(data, 0, count * buf->bpf);
		abuf_wcommit(buf, count);
		buf->w.sub.silence -= count;
#ifdef DEBUG
		if (debug_level >= 4) {
			abuf_dbg(buf);
			dbg_puts(": appended ");
			dbg_putu(count);
			dbg_puts(", remaining silence = ");
			dbg_putu(buf->w.sub.silence);
			dbg_puts("\n");
		}
#endif
	}
}

/*
 * Copy data from ibuf to obuf.
 */
void
sub_bcopy(struct abuf *ibuf, struct abuf *obuf)
{
	adata_t *idata, *odata;
	unsigned int i, icount, ocount, scount;
	int j, cc, cmin, cmax, istart, inext, onext, ostart, onch;

	/*
	 * Drop samples for xrun correction
	 */
	if (obuf->w.sub.silence < 0) {
		scount = -obuf->w.sub.silence;
		if (scount > ibuf->used)
			scount = ibuf->used;
		obuf->w.sub.done += scount;
		obuf->w.sub.silence += scount;
	}

	idata = (adata_t *)abuf_rgetblk(ibuf, &icount, obuf->w.sub.done);
	if (icount == 0)
		return;
	odata = (adata_t *)abuf_wgetblk(obuf, &ocount, 0);
	if (ocount == 0)
		return;
	cmin = obuf->cmin > ibuf->cmin ? obuf->cmin : ibuf->cmin;
	cmax = obuf->cmax < ibuf->cmax ? obuf->cmax : ibuf->cmax;
	onch = obuf->cmax - obuf->cmin + 1;
	ostart = cmin - obuf->cmin;
	if (ostart > onch)
		ostart = onch;
	onext = obuf->cmax - cmax;
	if (onext > onch)
		onext = onch;
	istart = cmin - ibuf->cmin;
	inext = ibuf->cmax - cmax;
	cc = cmax - cmin + 1;
	scount = (icount < ocount) ? icount : ocount;
	for (i = scount; i > 0; i--) {
		idata += istart;
		for (j = ostart; j > 0; j--)
			*odata++ = 0x1111;
		for (j = cc; j > 0; j--) {
			*odata = *idata;
			odata++;
			idata++;
		}
		for (j = onext; j > 0; j--)
			*odata++ = 0x2222;
		idata += inext;
	}
	abuf_wcommit(obuf, scount);
	obuf->w.sub.done += scount;
#ifdef DEBUG
	if (debug_level >= 4) {
		abuf_dbg(obuf);
		dbg_puts(": bcopy ");
		dbg_putu(scount);
		dbg_puts("\n");
	}
#endif
}

/*
 * Handle buffer overruns. Return 0 if the stream died.
 */
int
sub_xrun(struct aproc *p, struct abuf *i)
{
	struct abuf *ibuf = LIST_FIRST(&p->ins);
	unsigned int fdrop, remain;

	if (i->w.sub.done > 0)
		return 1;
	if (i->w.sub.xrun == XRUN_ERROR) {
		abuf_eof(i);
		return 0;
	}
	fdrop = ibuf->used;
#ifdef DEBUG
	if (debug_level >= 3) {
		abuf_dbg(i);
		dbg_puts(": overrun, silence ");
		dbg_putu(fdrop);
		dbg_puts(" + ");
		dbg_putu(i->w.sub.silence);
		dbg_puts("\n");
	}
#endif
	i->w.sub.done += fdrop;
	if (i->w.sub.xrun == XRUN_SYNC)
		sub_silence(i, fdrop);
	else {
		remain = fdrop % p->u.sub.round;
		if (remain)
			remain = p->u.sub.round - remain;
		sub_silence(i, -(int)remain);
		fdrop += remain;
#ifdef DEBUG
		if (debug_level >= 3) {
			abuf_dbg(i);
			dbg_puts(": overrun, adding ");
			dbg_putu(remain);
			dbg_puts("\n");
		}
#endif

		abuf_ipos(i, -(int)fdrop);
		if (i->duplex) {
#ifdef DEBUG
			if (debug_level >= 3) {
				abuf_dbg(i->duplex);
				dbg_puts(": full-duplex resync\n");
			}
#endif
			mix_drop(i->duplex, -(int)fdrop);
			abuf_opos(i->duplex, -(int)fdrop);
		}
	}
	return 1;
}

int
sub_in(struct aproc *p, struct abuf *ibuf)
{
	struct abuf *i, *inext;
	unsigned int idone;

	if (!ABUF_ROK(ibuf))
		return 0;
	idone = ibuf->len;
	for (i = LIST_FIRST(&p->outs); i != NULL; i = inext) {
		inext = LIST_NEXT(i, oent);
		sub_silence(i, 0);
		if (!SUB_WOK(i)) {
			if (p->flags & APROC_DROP) {
				if (!sub_xrun(p, i))
					continue;
			}
		} else
			sub_bcopy(ibuf, i);
		if (idone > i->w.sub.done)
			idone = i->w.sub.done;
		if (!abuf_flush(i))
			continue;
	}
	if (LIST_EMPTY(&p->outs)) {
		if (p->flags & APROC_QUIT) {
			aproc_del(p);
			return 0;
		}
		if (!(p->flags & APROC_DROP))
			return 0;
		idone = ibuf->used;
		p->u.sub.idle += idone;
	}
	if (idone == 0)
		return 0;
	LIST_FOREACH(i, &p->outs, oent) {
		i->w.sub.done -= idone;
	}
	abuf_rdiscard(ibuf, idone);
	abuf_opos(ibuf, idone);
	p->u.sub.lat -= idone;
	return 1;
}

int
sub_out(struct aproc *p, struct abuf *obuf)
{
	struct abuf *ibuf = LIST_FIRST(&p->ins);
	struct abuf *i, *inext;
	unsigned int idone;

	if (!SUB_WOK(obuf))
		return 0;
	if (!abuf_fill(ibuf))
		return 0; /* eof */
	idone = ibuf->len;
	for (i = LIST_FIRST(&p->outs); i != NULL; i = inext) {
		inext = LIST_NEXT(i, oent);
		sub_silence(i, 0);
		sub_bcopy(ibuf, i);
		if (idone > i->w.sub.done)
			idone = i->w.sub.done;
		if (!abuf_flush(i))
			continue;
	}
	if (LIST_EMPTY(&p->outs) || idone == 0)
		return 0;
	LIST_FOREACH(i, &p->outs, oent) {
		i->w.sub.done -= idone;
	}
	abuf_rdiscard(ibuf, idone);
	abuf_opos(ibuf, idone);
	p->u.sub.lat -= idone;
	return 1;
}

void
sub_eof(struct aproc *p, struct abuf *ibuf)
{
	aproc_del(p);
}

void
sub_hup(struct aproc *p, struct abuf *obuf)
{
	struct abuf *i, *ibuf = LIST_FIRST(&p->ins);
	unsigned int idone;

	if (!aproc_inuse(p)) {
#ifdef DEBUG
		if (debug_level >= 3) {
			aproc_dbg(p);
			dbg_puts(": running other streams\n");
		}
#endif
		/*
		 * Find a blocked output.
		 */
		idone = ibuf->len;
		LIST_FOREACH(i, &p->outs, oent) {
			/*
			 * abuf_flush() may trigger sub_hup(), do the job
			 * and possibly reorder the list
			 */
			if (!abuf_flush(i))
				return;
			if (SUB_WOK(i) && i->w.sub.done < ibuf->used) {
				abuf_run(i);
				return;
			}
			if (idone > i->w.sub.done)
				idone = i->w.sub.done;
		}
		/*
		 * No blocked outputs. Check if input is blocked.
		 */
		if (LIST_EMPTY(&p->outs) || idone == ibuf->used)
			abuf_run(ibuf);
	}
}

void
sub_newout(struct aproc *p, struct abuf *obuf)
{
	p->u.sub.idle = 0;
	obuf->w.sub.done = 0;
	obuf->w.sub.xrun = XRUN_IGNORE;
	obuf->w.sub.silence = 0;
}

void
sub_ipos(struct aproc *p, struct abuf *ibuf, int delta)
{
	p->u.sub.lat += delta;
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": ipos: lat = ");
		dbg_puti(p->u.sub.lat);
		dbg_puts("/");
		dbg_puti(p->u.sub.maxlat);
		dbg_puts("\n");
	}
#endif
	aproc_ipos(p, ibuf, delta);
}

struct aproc_ops sub_ops = {
	"sub",
	sub_in,
	sub_out,
	sub_eof,
	sub_hup,
	NULL,
	sub_newout,
	sub_ipos,
	aproc_opos,
	NULL
};

struct aproc *
sub_new(char *name, int maxlat, unsigned int round)
{
	struct aproc *p;

	p = aproc_new(&sub_ops, name);
	p->u.sub.idle = 0;
	p->u.sub.lat = 0;
	p->u.sub.round = round;
	p->u.sub.maxlat = maxlat;
	return p;
}

void
sub_clear(struct aproc *p)
{
	p->u.sub.lat = 0;
}

/*
 * Convert one block.
 */
void
resamp_bcopy(struct aproc *p, struct abuf *ibuf, struct abuf *obuf)
{
	unsigned int inch;
	adata_t *idata;
	unsigned int oblksz;
	unsigned int ifr;
	unsigned int onch;
	int s, ds, diff;
	adata_t *odata;
	unsigned int iblksz;
	unsigned int ofr;
	unsigned int c;
	adata_t *ctxbuf, *ctx;
	unsigned int ctx_start;
	unsigned int icount, ocount;

	/*
	 * Calculate max frames readable at once from the input buffer.
	 */
	idata = (adata_t *)abuf_rgetblk(ibuf, &icount, 0);
	ifr = icount;

	odata = (adata_t *)abuf_wgetblk(obuf, &ocount, 0);
	ofr = ocount;

	/*
	 * Partially copy structures into local variables, to avoid
	 * unnecessary indirections; this also allows the compiler to
	 * order local variables more "cache-friendly".
	 */
	diff = p->u.resamp.diff;
	inch = ibuf->cmax - ibuf->cmin + 1;
	iblksz = p->u.resamp.iblksz;
	onch = obuf->cmax - obuf->cmin + 1;
	oblksz = p->u.resamp.oblksz;
	ctxbuf = p->u.resamp.ctx;
	ctx_start = p->u.resamp.ctx_start;

	/*
	 * Start conversion.
	 */
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": starting diff = ");
		dbg_puti(diff);
		dbg_puts(", ifr = ");
		dbg_putu(ifr);
		dbg_puts(", ofr = ");
		dbg_putu(ofr);
		dbg_puts(" fr\n");
	}
#endif
	for (;;) {
		if (diff < 0) {
			if (ifr == 0)
				break;
			ctx_start ^= 1;
			ctx = ctxbuf + ctx_start;
			for (c = inch; c > 0; c--) {
				*ctx = *idata++;
				ctx += RESAMP_NCTX;
			}
			diff += oblksz;
			ifr--;
		} else if (diff > 0) {
			if (ofr == 0)
				break;
			ctx = ctxbuf;
			for (c = onch; c > 0; c--) {
				s = ctx[ctx_start];
				ds = ctx[ctx_start ^ 1] - s;
				ctx += RESAMP_NCTX;
				*odata++ = s + ADATA_MULDIV(ds, diff, oblksz);
			}
			diff -= iblksz;
			ofr--;
		} else {
			if (ifr == 0 || ofr == 0)
				break;
			ctx = ctxbuf + ctx_start;
			for (c = onch; c > 0; c--) {
				*odata++ = *ctx;
				ctx += RESAMP_NCTX;
			}
			ctx_start ^= 1;
			ctx = ctxbuf + ctx_start;
			for (c = inch; c > 0; c--) {
				*ctx = *idata++;
				ctx += RESAMP_NCTX;
			}
			diff -= iblksz;
			diff += oblksz;
			ifr--;
			ofr--;
		}
	}
	p->u.resamp.diff = diff;
	p->u.resamp.ctx_start = ctx_start;
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": done delta = ");
		dbg_puti(diff);
		dbg_puts(", ifr = ");
		dbg_putu(ifr);
		dbg_puts(", ofr = ");
		dbg_putu(ofr);
		dbg_puts(" fr\n");
	}
#endif
	/*
	 * Update FIFO pointers.
	 */
	icount -= ifr;
	ocount -= ofr;
	abuf_rdiscard(ibuf, icount);
	abuf_wcommit(obuf, ocount);
}

int
resamp_in(struct aproc *p, struct abuf *ibuf)
{
	struct abuf *obuf = LIST_FIRST(&p->outs);

	if (!ABUF_WOK(obuf) || !ABUF_ROK(ibuf))
		return 0;
	resamp_bcopy(p, ibuf, obuf);
	if (!abuf_flush(obuf))
		return 0;
	return 1;
}

int
resamp_out(struct aproc *p, struct abuf *obuf)
{
	struct abuf *ibuf = LIST_FIRST(&p->ins);

	if (!abuf_fill(ibuf))
		return 0;
	if (!ABUF_WOK(obuf) || !ABUF_ROK(ibuf))
		return 0;
	resamp_bcopy(p, ibuf, obuf);
	return 1;
}

void
resamp_eof(struct aproc *p, struct abuf *ibuf)
{
	aproc_del(p);
}

void
resamp_hup(struct aproc *p, struct abuf *obuf)
{
	aproc_del(p);
}

void
resamp_ipos(struct aproc *p, struct abuf *ibuf, int delta)
{
	struct abuf *obuf = LIST_FIRST(&p->outs);
	long long ipos;
	
	ipos = (long long)delta * p->u.resamp.oblksz + p->u.resamp.idelta;
	p->u.resamp.idelta = ipos % p->u.resamp.iblksz;
	abuf_ipos(obuf, ipos / (int)p->u.resamp.iblksz);
}

void
resamp_opos(struct aproc *p, struct abuf *obuf, int delta)
{
	struct abuf *ibuf = LIST_FIRST(&p->ins);
	long long opos;

	opos = (long long)delta * p->u.resamp.iblksz + p->u.resamp.odelta;
	p->u.resamp.odelta = opos % p->u.resamp.oblksz;
	abuf_opos(ibuf, opos / p->u.resamp.oblksz);
}

struct aproc_ops resamp_ops = {
	"resamp",
	resamp_in,
	resamp_out,
	resamp_eof,
	resamp_hup,
	NULL,
	NULL,
	resamp_ipos,
	resamp_opos,
	NULL
};

struct aproc *
resamp_new(char *name, unsigned int iblksz, unsigned int oblksz)
{
	struct aproc *p;
	unsigned int i;

	p = aproc_new(&resamp_ops, name);
	p->u.resamp.iblksz = iblksz;
	p->u.resamp.oblksz = oblksz;
	p->u.resamp.diff = 0;
	p->u.resamp.idelta = 0;
	p->u.resamp.odelta = 0;
	p->u.resamp.ctx_start = 0;
	for (i = 0; i < NCHAN_MAX * RESAMP_NCTX; i++)
		p->u.resamp.ctx[i] = 0;
#ifdef DEBUG
	if (debug_level >= 3) {
		aproc_dbg(p);
		dbg_puts(": new ");
		dbg_putu(iblksz);
		dbg_puts("/");
		dbg_putu(oblksz);
		dbg_puts("\n");
	}
#endif
	return p;
}

/*
 * Convert one block.
 */
void
enc_bcopy(struct aproc *p, struct abuf *ibuf, struct abuf *obuf)
{
	unsigned int nch, scount, icount, ocount;
	unsigned int f;
	adata_t *idata;
	int s;
	unsigned int oshift;
	int osigbit;
	unsigned int obps;
	unsigned int i;
	unsigned char *odata;
	int obnext;
	int osnext;

	/*
	 * Calculate max frames readable at once from the input buffer.
	 */
	idata = (adata_t *)abuf_rgetblk(ibuf, &icount, 0);
	if (icount == 0)
		return;
	odata = abuf_wgetblk(obuf, &ocount, 0);
	if (ocount == 0)
		return;
	scount = (icount < ocount) ? icount : ocount;
	nch = ibuf->cmax - ibuf->cmin + 1;
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": bcopy ");
		dbg_putu(scount);
		dbg_puts(" fr / ");
		dbg_putu(nch);
		dbg_puts(" ch\n");
	}
#endif
	/*
	 * Partially copy structures into local variables, to avoid
	 * unnecessary indirections; this also allows the compiler to
	 * order local variables more "cache-friendly".
	 */
	oshift = p->u.conv.shift;
	osigbit = p->u.conv.sigbit;
	obps = p->u.conv.bps;
	obnext = p->u.conv.bnext;
	osnext = p->u.conv.snext;

	/*
	 * Start conversion.
	 */
	odata += p->u.conv.bfirst;
	for (f = scount * nch; f > 0; f--) {
		s = *idata++;
		s <<= 32 - ADATA_BITS;
		s >>= oshift;
		s ^= osigbit;
		for (i = obps; i > 0; i--) {
			*odata = (unsigned char)s;
			s >>= 8;
			odata += obnext;
		}
		odata += osnext;
	}

	/*
	 * Update FIFO pointers.
	 */
	abuf_rdiscard(ibuf, scount);
	abuf_wcommit(obuf, scount);
}

int
enc_in(struct aproc *p, struct abuf *ibuf)
{
	struct abuf *obuf = LIST_FIRST(&p->outs);

	if (!ABUF_WOK(obuf) || !ABUF_ROK(ibuf))
		return 0;
	enc_bcopy(p, ibuf, obuf);
	if (!abuf_flush(obuf))
		return 0;
	return 1;
}

int
enc_out(struct aproc *p, struct abuf *obuf)
{
	struct abuf *ibuf = LIST_FIRST(&p->ins);

	if (!abuf_fill(ibuf))
		return 0;
	if (!ABUF_WOK(obuf) || !ABUF_ROK(ibuf))
		return 0;
	enc_bcopy(p, ibuf, obuf);
	return 1;
}

void
enc_eof(struct aproc *p, struct abuf *ibuf)
{
	aproc_del(p);
}

void
enc_hup(struct aproc *p, struct abuf *obuf)
{
	aproc_del(p);
}

struct aproc_ops enc_ops = {
	"enc",
	enc_in,
	enc_out,
	enc_eof,
	enc_hup,
	NULL,
	NULL,
	aproc_ipos,
	aproc_opos,
	NULL
};

struct aproc *
enc_new(char *name, struct aparams *par)
{
	struct aproc *p;

	p = aproc_new(&enc_ops, name);
	p->u.conv.bps = par->bps;
	p->u.conv.sigbit = par->sig ? 0 : 1 << (par->bits - 1);
	if (par->msb) {
		p->u.conv.shift = 32 - par->bps * 8;
	} else {
		p->u.conv.shift = 32 - par->bits;
	}
	if (!par->le) {
		p->u.conv.bfirst = par->bps - 1;
		p->u.conv.bnext = -1;
		p->u.conv.snext = 2 * par->bps;
	} else {
		p->u.conv.bfirst = 0;
		p->u.conv.bnext = 1;
		p->u.conv.snext = 0;
	}
#ifdef DEBUG
	if (debug_level >= 3) {
		aproc_dbg(p);
		dbg_puts(": new ");
		aparams_dbg(par);
		dbg_puts("\n");
	}
#endif
	return p;
}

/*
 * Convert one block.
 */
void
dec_bcopy(struct aproc *p, struct abuf *ibuf, struct abuf *obuf)
{
	unsigned int nch, scount, icount, ocount;
	unsigned int f;
	unsigned int ibps;
	unsigned int i;
	int s = 0xdeadbeef;
	unsigned char *idata;
	int ibnext;
	int isnext;
	int isigbit;
	unsigned int ishift;
	adata_t *odata;

	/*
	 * Calculate max frames readable at once from the input buffer.
	 */
	idata = abuf_rgetblk(ibuf, &icount, 0);
	if (icount == 0)
		return;
	odata = (adata_t *)abuf_wgetblk(obuf, &ocount, 0);
	if (ocount == 0)
		return;
	scount = (icount < ocount) ? icount : ocount;
	nch = obuf->cmax - obuf->cmin + 1;
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": bcopy ");
		dbg_putu(scount);
		dbg_puts(" fr / ");
		dbg_putu(nch);
		dbg_puts(" ch\n");
	}
#endif
	/*
	 * Partially copy structures into local variables, to avoid
	 * unnecessary indirections; this also allows the compiler to
	 * order local variables more "cache-friendly".
	 */
	ibps = p->u.conv.bps;
	ibnext = p->u.conv.bnext;
	isigbit = p->u.conv.sigbit;
	ishift = p->u.conv.shift;
	isnext = p->u.conv.snext;

	/*
	 * Start conversion.
	 */
	idata += p->u.conv.bfirst;
	for (f = scount * nch; f > 0; f--) {
		for (i = ibps; i > 0; i--) {
			s <<= 8;
			s |= *idata;
			idata += ibnext;
		}
		idata += isnext;
		s ^= isigbit;
		s <<= ishift;
		s >>= 32 - ADATA_BITS;
		*odata++ = s;
	}

	/*
	 * Update FIFO pointers.
	 */
	abuf_rdiscard(ibuf, scount);
	abuf_wcommit(obuf, scount);
}

int
dec_in(struct aproc *p, struct abuf *ibuf)
{
	struct abuf *obuf = LIST_FIRST(&p->outs);

	if (!ABUF_WOK(obuf) || !ABUF_ROK(ibuf))
		return 0;
	dec_bcopy(p, ibuf, obuf);
	if (!abuf_flush(obuf))
		return 0;
	return 1;
}

int
dec_out(struct aproc *p, struct abuf *obuf)
{
	struct abuf *ibuf = LIST_FIRST(&p->ins);

	if (!abuf_fill(ibuf))
		return 0;
	if (!ABUF_WOK(obuf) || !ABUF_ROK(ibuf))
		return 0;
	dec_bcopy(p, ibuf, obuf);
	return 1;
}

void
dec_eof(struct aproc *p, struct abuf *ibuf)
{
	aproc_del(p);
}

void
dec_hup(struct aproc *p, struct abuf *obuf)
{
	aproc_del(p);
}

struct aproc_ops dec_ops = {
	"dec",
	dec_in,
	dec_out,
	dec_eof,
	dec_hup,
	NULL,
	NULL,
	aproc_ipos,
	aproc_opos,
	NULL
};

struct aproc *
dec_new(char *name, struct aparams *par)
{
	struct aproc *p;

	p = aproc_new(&dec_ops, name);
	p->u.conv.bps = par->bps;
	p->u.conv.sigbit = par->sig ? 0 : 1 << (par->bits - 1);
	if (par->msb) {
		p->u.conv.shift = 32 - par->bps * 8;
	} else {
		p->u.conv.shift = 32 - par->bits;
	}
	if (par->le) {
		p->u.conv.bfirst = par->bps - 1;
		p->u.conv.bnext = -1;
		p->u.conv.snext = 2 * par->bps;
	} else {
		p->u.conv.bfirst = 0;
		p->u.conv.bnext = 1;
		p->u.conv.snext = 0;
	}
#ifdef DEBUG
	if (debug_level >= 3) {
		aproc_dbg(p);
		dbg_puts(": new ");
		aparams_dbg(par);
		dbg_puts("\n");
	}
#endif
	return p;
}

/*
 * Convert one block.
 */
void
join_bcopy(struct aproc *p, struct abuf *ibuf, struct abuf *obuf)
{
	unsigned int h, hops;
	unsigned int inch, inext;
	adata_t *idata;
	unsigned int onch, onext;
	adata_t *odata;
	int scale;
	unsigned int c, f, scount, icount, ocount;

	/*
	 * Calculate max frames readable at once from the input buffer.
	 */
	idata = (adata_t *)abuf_rgetblk(ibuf, &icount, 0);
	if (icount == 0)
		return;
	odata = (adata_t *)abuf_wgetblk(obuf, &ocount, 0);
	if (ocount == 0)
		return;
	scount = icount < ocount ? icount : ocount;
	inch = ibuf->cmax - ibuf->cmin + 1;
	onch = obuf->cmax - obuf->cmin + 1;
	if (2 * inch <= onch) {
		hops = onch / inch;
		inext = inch * hops;
		onext = onch - inext;
		for (f = scount; f > 0; f--) {
			h = hops;
			for (;;) {
				for (c = inch; c > 0; c--)
					*odata++ = *idata++;
				if (--h == 0)
					break;
				idata -= inch;
			}
			for (c = onext; c > 0; c--)
				*odata++ = 0;
		}
	} else if (inch >= 2 * onch) {
		hops = inch / onch;
		inext = inch - onch * hops;
		scale = ADATA_UNIT / hops;
		inch -= onch + inext;
		hops--;
		for (f = scount; f > 0; f--) {
			for (c = onch; c > 0; c--)
				*odata++ = ADATA_MUL(*idata++, scale);
			for (h = hops; h > 0; h--) {
				odata -= onch;
				for (c = onch; c > 0; c--)
					*odata++ += ADATA_MUL(*idata++, scale);
			}
			idata += inext;
		}
	} else {
#ifdef DEBUG
		aproc_dbg(p);
		dbg_puts(": nothing to do\n");
		dbg_panic();
#endif
	}
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": bcopy ");
		dbg_putu(scount);
		dbg_puts(" fr\n");
	}
#endif
	abuf_rdiscard(ibuf, scount);
	abuf_wcommit(obuf, scount);
}

int
join_in(struct aproc *p, struct abuf *ibuf)
{
	struct abuf *obuf = LIST_FIRST(&p->outs);

	if (!ABUF_WOK(obuf) || !ABUF_ROK(ibuf))
		return 0;
	join_bcopy(p, ibuf, obuf);
	if (!abuf_flush(obuf))
		return 0;
	return 1;
}

int
join_out(struct aproc *p, struct abuf *obuf)
{
	struct abuf *ibuf = LIST_FIRST(&p->ins);

	if (!abuf_fill(ibuf))
		return 0;
	if (!ABUF_WOK(obuf) || !ABUF_ROK(ibuf))
		return 0;
	join_bcopy(p, ibuf, obuf);
	return 1;
}

void
join_eof(struct aproc *p, struct abuf *ibuf)
{
	aproc_del(p);
}

void
join_hup(struct aproc *p, struct abuf *obuf)
{
	aproc_del(p);
}

struct aproc_ops join_ops = {
	"join",
	join_in,
	join_out,
	join_eof,
	join_hup,
	NULL,
	NULL,
	aproc_ipos,
	aproc_opos,
	NULL
};

struct aproc *
join_new(char *name)
{
	struct aproc *p;

	p = aproc_new(&join_ops, name);
#ifdef DEBUG
	if (debug_level >= 3) {
		aproc_dbg(p);
		dbg_puts(": new\n");
	}
#endif
	return p;
}

/*
 * Commit and flush part of the output buffer
 */
void
mon_flush(struct aproc *p)
{
	struct abuf *obuf = LIST_FIRST(&p->outs);
	unsigned int count;

#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": delta = ");
		dbg_puti(p->u.mon.delta);
		dbg_puts("/");
		dbg_putu(p->u.mon.bufsz);
		dbg_puts(" pending = ");
		dbg_puti(p->u.mon.pending);
		dbg_puts("\n");
	}
#endif
	if (p->u.mon.delta <= 0 || p->u.mon.pending == 0)
		return;
	count = p->u.mon.delta;
	if (count > p->u.mon.pending)
		count = p->u.mon.pending;
	abuf_wcommit(obuf, count);
	p->u.mon.pending -= count;
	p->u.mon.delta -= count;
	abuf_flush(obuf);
}

/*
 * Copy one block.
 */
void
mon_snoop(struct aproc *p, struct abuf *ibuf,
    unsigned int pos, unsigned int todo)
{
	struct abuf *obuf = LIST_FIRST(&p->outs);
	unsigned int scount, icount, ocount;
	adata_t *idata, *odata;

#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": snooping ");
		dbg_putu(pos);
		dbg_puts("..");
		dbg_putu(todo);
		dbg_puts("\n");
	}
#endif
	if (!abuf_flush(obuf))
		return;

	while (todo > 0) {
		/*
		 * Calculate max frames readable at once from the input buffer.
		 */
		idata = (adata_t *)abuf_rgetblk(ibuf, &icount, pos);
		odata = (adata_t *)abuf_wgetblk(obuf, &ocount, p->u.mon.pending);
		scount = (icount < ocount) ? icount : ocount;
#ifdef DEBUG
		if (debug_level >= 4) {
			aproc_dbg(p);
			dbg_puts(": snooping ");
			dbg_putu(scount);
			dbg_puts(" fr\n");
		}
		if (scount == 0) {
			dbg_puts("monitor xrun, not allowed\n");
			dbg_panic();
		}
#endif
		memcpy(odata, idata, scount * obuf->bpf);
		p->u.mon.pending += scount;
		todo -= scount;
		pos += scount;
	}
	mon_flush(p);
}

int
mon_in(struct aproc *p, struct abuf *ibuf)
{
#ifdef DEBUG
	dbg_puts("monitor can't have inputs to read\n");
	dbg_panic();
#endif
	return 0;
}

/*
 * put the monitor into ``empty'' state
 */
void
mon_clear(struct aproc *p)
{
	p->u.mon.pending = 0;
	p->u.mon.delta = 0;
}

int
mon_out(struct aproc *p, struct abuf *obuf)
{
	/*
	 * can't trigger monitored stream to produce data
	 */
	return 0;
}

void
mon_eof(struct aproc *p, struct abuf *ibuf)
{
#ifdef DEBUG
	dbg_puts("monitor can't have inputs to eof\n");
	dbg_panic();
#endif
}

void
mon_hup(struct aproc *p, struct abuf *obuf)
{
	aproc_del(p);
}

void
mon_ipos(struct aproc *p, struct abuf *ibuf, int delta)
{
	aproc_ipos(p, ibuf, delta);
	p->u.mon.delta += delta;
	mon_flush(p);
}

struct aproc_ops mon_ops = {
	"mon",
	mon_in,
	mon_out,
	mon_eof,
	mon_hup,
	NULL,
	NULL,
	mon_ipos,
	aproc_opos,
	NULL
};

struct aproc *
mon_new(char *name, unsigned int bufsz)
{
	struct aproc *p;

	p = aproc_new(&mon_ops, name);
	p->u.mon.pending = 0;
	p->u.mon.delta = 0;
	p->u.mon.bufsz = bufsz;
#ifdef DEBUG
	if (debug_level >= 3) {
		aproc_dbg(p);
		dbg_puts(": new\n");
	}
#endif
	return p;
}
@


1.74
log
@add missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.73
log
@Fix wrong arithmetics in channel mapping causing crashes if all of
the recorded or played channels don't exist.
With help from Remco <remco at d-compu.dyndns.org>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.72 2012/04/11 21:12:55 ratchov Exp $	*/
d62 84
@


1.72
log
@flush the log and abort() if we try to destroy a NULL aproc
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.71 2012/04/11 06:05:43 ratchov Exp $	*/
d624 2
a625 3
	unsigned int cmin, cmax;
	unsigned int i, j, cc, istart, inext, onext, ostart;
	unsigned int scount, icount, ocount;
d674 1
d676 5
d682 1
a682 2
	onext = obuf->cmax - cmax + ostart;
	inext = ibuf->cmax - cmax + istart;
a683 2
	odata += ostart;
	idata += istart;
d685 2
d1165 2
a1166 3
	unsigned int cmin, cmax;
	unsigned int i, j, cc, istart, inext, onext, ostart;
	unsigned int icount, ocount, scount;
d1187 1
d1189 5
d1195 1
a1195 2
	onext = obuf->cmax - cmax;
	inext = ibuf->cmax - cmax + istart;
a1196 1
	idata += istart;
d1199 1
@


1.71
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.70 2012/03/23 11:59:54 ratchov Exp $	*/
d176 6
@


1.70
log
@add a MIDI-controlled master volume knob to adjust the mix of
all playback stream, discussed with armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.69 2012/01/10 08:10:21 ratchov Exp $	*/
d292 1
a292 1
rfile_do(struct aproc *p, unsigned todo, unsigned *done)
d297 1
a297 1
	unsigned n, count, off;
d454 1
a454 1
wfile_do(struct aproc *p, unsigned todo, unsigned *done)
d459 1
a459 1
	unsigned n, count, off;
d550 1
a550 1
	unsigned count;
d586 1
a586 1
mix_bzero(struct abuf *obuf, unsigned maxtodo)
d589 1
a589 1
	unsigned ocount, todo;
d614 1
a614 1
unsigned
d618 3
a620 3
	unsigned cmin, cmax;
	unsigned i, j, cc, istart, inext, onext, ostart;
	unsigned scount, icount, ocount;
d713 1
a713 1
	unsigned fdrop, remain;
d768 3
a770 3
	unsigned odone;
	unsigned maxwrite;
	unsigned scount;
d835 3
a837 3
	unsigned odone;
	unsigned maxwrite;
	unsigned scount;
d922 1
a922 1
	unsigned odone;
d1024 2
a1025 2
mix_new(char *name, int maxlat, unsigned round,
    unsigned autovol, unsigned master)
d1046 1
a1046 1
	unsigned n;
d1116 1
a1116 1
	unsigned count;
d1155 3
a1157 3
	unsigned cmin, cmax;
	unsigned i, j, cc, istart, inext, onext, ostart;
	unsigned icount, ocount, scount;
d1216 1
a1216 1
	unsigned fdrop, remain;
d1272 1
a1272 1
	unsigned idone;
d1318 1
a1318 1
	unsigned idone;
d1355 1
a1355 1
	unsigned idone;
d1430 1
a1430 1
sub_new(char *name, int maxlat, unsigned round)
d1454 1
a1454 1
	unsigned inch;
d1456 3
a1458 3
	unsigned oblksz;
	unsigned ifr;
	unsigned onch;
d1461 3
a1463 3
	unsigned iblksz;
	unsigned ofr;
	unsigned c;
d1465 2
a1466 2
	unsigned ctx_start;
	unsigned icount, ocount;
d1646 1
a1646 1
resamp_new(char *name, unsigned iblksz, unsigned oblksz)
d1649 1
a1649 1
	unsigned i;
d1679 2
a1680 2
	unsigned nch, scount, icount, ocount;
	unsigned f;
d1683 1
a1683 1
	unsigned oshift;
d1685 2
a1686 2
	unsigned obps;
	unsigned i;
d1837 4
a1840 4
	unsigned nch, scount, icount, ocount;
	unsigned f;
	unsigned ibps;
	unsigned i;
d1846 1
a1846 1
	unsigned ishift;
d1995 2
a1996 2
	unsigned h, hops;
	unsigned inch, inext;
d1998 1
a1998 1
	unsigned onch, onext;
d2001 1
a2001 1
	unsigned c, f, scount, icount, ocount;
d2139 1
a2139 1
	unsigned count;
d2168 2
a2169 1
mon_snoop(struct aproc *p, struct abuf *ibuf, unsigned pos, unsigned todo)
d2172 1
a2172 1
	unsigned scount, icount, ocount;
d2281 1
a2281 1
mon_new(char *name, unsigned bufsz)
@


1.69
log
@Fix the way the mixer figures out which groups of streams have
common channels and thus need to share their dynamic range. Fixes,
unnecessarily decreased volume in some theoretical cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.68 2011/11/20 22:54:51 ratchov Exp $	*/
d1024 2
a1025 1
mix_new(char *name, int maxlat, unsigned round, unsigned autovol)
d1036 1
d1066 1
a1066 1
		i->r.mix.weight = weight;
@


1.68
log
@Move mmc/mtc and volume control bits from struct aproc to struct
dev. Allows volume settings to be saved while the device is kept
closed. Besides that, no behabiour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.67 2011/11/16 08:03:34 ratchov Exp $	*/
a1047 14
	if (!p->u.mix.autovol)
		return;

	/*
	 * count the number of inputs. If a set of inputs
	 * uses channels that have no intersection, they are 
	 * counted only once because they don't need to 
	 * share their volume
	 *
	 * XXX: this is wrong, this is not optimal if we have two
	 *      buckets of N and N' clients, in which case we should
	 *	get 1/N and 1/N' respectively
	 */
	n = 0;
d1049 10
a1058 5
		j = LIST_NEXT(i, ient);
		for (;;) {
			if (j == NULL) {
				n++;
				break;
d1060 1
a1060 3
			if (i->cmin > j->cmax || i->cmax < j->cmin)
				break;
			j = LIST_NEXT(j, ient);
a1061 3
	}
	LIST_FOREACH(i, &p->ins, ient) {
		weight = ADATA_UNIT / n;
@


1.67
log
@consider there's no dependency between two aprocs, if
one of them is NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.66 2011/05/26 07:26:36 ratchov Exp $	*/
a1004 2
	if (APROC_OK(p->u.mix.ctl))
		ctl_ontick(p->u.mix.ctl, delta);
a1032 1
	p->u.mix.ctl = NULL;
a1424 2
	if (APROC_OK(p->u.sub.ctl))
		ctl_ontick(p->u.sub.ctl, delta);
a1450 1
	p->u.sub.ctl = NULL;
@


1.66
log
@make clipping less ugly, from Sviatoslav Chagaev
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.65 2011/05/26 07:18:40 ratchov Exp $	*/
d282 2
@


1.65
log
@add a new -w flag to control whether master volume is automatically
adjusted when new streams are connected and disconnected. Disabling
automatic volume adjustment makes sense if all streams are recorded
with properly lowered volumes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.64 2011/04/28 07:20:03 ratchov Exp $	*/
d619 1
a619 1
	int vol;
d676 6
a681 1
			*odata += ADATA_MUL(*idata, vol);
@


1.64
log
@remove deadcode, use err(1, "%s", str) instead of err(1, str)
from Michael W. Bombardieri <mb at ii.net>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.63 2010/11/04 17:55:28 ratchov Exp $	*/
d1019 1
a1019 1
mix_new(char *name, int maxlat, unsigned round)
d1030 1
d1043 3
@


1.63
log
@Replace ``short'' by a new ``adata_t'' typedef corresponding to
audio samples and cleanup ADATA_XXX macros. This allows easilly
switching to 24 bit fixed point arithmetic by simply redefining
the adata_t typedef to int and updating ADATA_XXX macros. No
object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.62 2010/10/21 21:42:46 ratchov Exp $	*/
d161 1
a161 1
		err(1, name);
@


1.62
log
@When the end of a stream is reached (ie mix_eof() called) other
possibly blocked streams are processed. If during this phase the end
of another stream is reached then stop the processing because the job
will be already finished by the second stream. Otherwise we may end up
running a destroyed stream.

help from Edward Wandasiewicz <w13ntd at googlemail.com>, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.61 2010/10/21 19:10:52 ratchov Exp $	*/
d586 1
a586 1
	short *odata;
d592 1
a592 1
	odata = (short *)abuf_wgetblk(obuf, &ocount, obuf->w.mix.todo);
d615 1
a615 1
	short *idata, *odata;
d650 1
a650 1
	idata = (short *)abuf_rgetblk(ibuf, &icount, 0);
d657 1
a657 1
	odata = (short *)abuf_wgetblk(obuf, &ocount, ibuf->r.mix.done);
d664 1
a664 1
	vol = (ibuf->r.mix.weight * ibuf->r.mix.vol) >> ADATA_SHIFT;
d676 1
a676 1
			*odata += (*idata * vol) >> ADATA_SHIFT;
d1158 1
a1158 1
	short *idata, *odata;
d1174 1
a1174 1
	idata = (short *)abuf_rgetblk(ibuf, &icount, obuf->w.sub.done);
d1177 1
a1177 1
	odata = (short *)abuf_wgetblk(obuf, &ocount, 0);
d1462 1
a1462 1
	short *idata;
d1466 2
a1467 2
	int s1, s2, diff;
	short *odata;
d1471 1
a1471 1
	short *ctxbuf, *ctx;
d1478 1
a1478 1
	idata = (short *)abuf_rgetblk(ibuf, &icount, 0);
d1481 1
a1481 1
	odata = (short *)abuf_wgetblk(obuf, &ocount, 0);
d1529 2
a1530 2
				s1 = ctx[ctx_start];
				s2 = ctx[ctx_start ^ 1];
d1532 1
a1532 1
				*odata++ = s1 + (s2 - s1) * diff / (int)oblksz;
d1688 1
a1688 1
	short *idata;
d1701 1
a1701 1
	idata = (short *)abuf_rgetblk(ibuf, &icount, 0);
d1736 1
a1736 1
		s <<= 16;
d1854 1
a1854 1
	short *odata;
d1862 1
a1862 1
	odata = (short *)abuf_wgetblk(obuf, &ocount, 0);
d1901 1
a1901 1
		s >>= 16;
d2004 1
a2004 1
	short *idata;
d2006 1
a2006 1
	short *odata;
d2013 1
a2013 1
	idata = (short *)abuf_rgetblk(ibuf, &icount, 0);
d2016 1
a2016 1
	odata = (short *)abuf_wgetblk(obuf, &ocount, 0);
d2046 1
a2046 2
				*odata++ = (*idata++ * scale)
				    >> ADATA_SHIFT;
d2050 1
a2050 2
					*odata++ += (*idata++ * scale)
					    >> ADATA_SHIFT;
d2179 1
a2179 1
	short *idata, *odata;
d2198 2
a2199 2
		idata = (short *)abuf_rgetblk(ibuf, &icount, pos);
		odata = (short *)abuf_wgetblk(obuf, &ocount, p->u.mon.pending);
@


1.61
log
@fix style and typos in messages and comments
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.60 2010/10/21 18:57:42 ratchov Exp $	*/
d914 1
a914 1
	struct abuf *i, *inext, *obuf = LIST_FIRST(&p->outs);
d930 5
a934 2
		for (i = LIST_FIRST(&p->ins); i != NULL; i = inext) {
			inext = LIST_NEXT(i, ient);
d936 1
a936 1
				continue;
d1358 1
a1358 1
	struct abuf *i, *inext, *ibuf = LIST_FIRST(&p->ins);
d1372 5
a1376 2
		for (i = LIST_FIRST(&p->outs); i != NULL; i = inext) {
			inext = LIST_NEXT(i, oent);
d1378 1
a1378 1
				continue;
@


1.60
log
@use MODE_xxx and XRUN_xxx macros everywhere, and zap corresponding
AMSG_xxx macros, which in turns simplifies the code
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.59 2010/05/07 07:15:50 ratchov Exp $	*/
d973 1
a973 1
		dbg_puts(": newin, will use ");
d975 1
a975 1
		dbg_puts("\n");
d1497 1
a1497 1
		dbg_puts(": resamp starting diff = ");
d1555 1
a1555 1
		dbg_puts(": resamp done delta = ");
d2129 1
a2129 1
		dbg_puts("\n");
d2180 1
a2180 1
		dbg_puts(": snoop ");
@


1.59
log
@remove ``abspos'' counters, from the pre-libsndio era. Since play and
rec direction use the same clock, there's no need to maintain their
absolute position.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.58 2010/05/04 19:40:08 ratchov Exp $	*/
d1045 4
a1087 35
}

void
mix_prime(struct aproc *p)
{
	struct abuf *obuf = LIST_FIRST(&p->outs);
	unsigned todo, count;

	for (;;) {
		if (!ABUF_WOK(obuf))
			break;
		todo = p->u.mix.maxlat - p->u.mix.lat;
		mix_bzero(obuf, todo);
		count = obuf->w.mix.todo;
		if (count > todo)
			count = todo;
		if (count == 0)
			break;
		obuf->w.mix.todo -= count;
		p->u.mix.lat += count;
		abuf_wcommit(obuf, count);
		if (APROC_OK(p->u.mix.mon))
			mon_snoop(p->u.mix.mon, obuf, 0, count);
		abuf_flush(obuf);
	}
#ifdef DEBUG
	if (debug_level >= 3) {
		aproc_dbg(p);
		dbg_puts(": prime: lat/maxlat=");
		dbg_puti(p->u.mix.lat);
		dbg_puts("/");
		dbg_puti(p->u.mix.maxlat);
		dbg_puts("\n");
	}
#endif
@


1.58
log
@make the mixer process data as soon as it's pushed by one of its
inputs, i.e. don't way that the output requests it.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.57 2010/05/02 11:12:31 ratchov Exp $	*/
a810 1
		p->u.mix.abspos += odone;
a895 1
		p->u.mix.abspos += odone;
a1024 1
	p->u.mix.abspos = 0;
a1082 1
	p->u.mix.abspos = 0;
a1103 1
		p->u.mix.abspos += count;
a1341 1
	p->u.sub.abspos += idone;
a1373 1
	p->u.sub.abspos += idone;
a1469 1
	p->u.sub.abspos = 0;
a1477 1
	p->u.sub.abspos = 0;
@


1.57
log
@Don't systematically fill with silence the mixer output. This
might result in extra samples being written to the device
when the mixer is closed.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.56 2010/05/02 10:40:48 ratchov Exp $	*/
d782 1
a782 1
	odone = obuf->w.mix.todo;
@


1.56
log
@in the resampling code, handle the case ``diff == 0'', to avoid producing
the first sample of the next block in advance.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.55 2010/04/24 13:32:21 ratchov Exp $	*/
d580 2
a581 2
 * Append the given amount of silence (or less if there's not enough
 * space), and crank w.mix.todo accordingly.
d584 1
a584 1
mix_bzero(struct abuf *obuf)
d587 1
a587 1
	unsigned ocount;
d589 3
d593 2
d636 1
a636 1
	if (ibuf->r.mix.drop < 0) {
d638 4
a641 3
		ocount = obuf->len - obuf->used;
		if (ocount > obuf->w.mix.todo)
			ocount = obuf->w.mix.todo;
d661 3
a673 1
	scount = (icount < ocount) ? icount : ocount;
a780 1
	mix_bzero(obuf);
d862 4
a865 1
	mix_bzero(obuf);
a866 1
	/* XXX: can obuf->len be larger than obuf->w.mix.todo ? */
d883 1
a883 1
	if (LIST_EMPTY(&p->ins)) {
d890 2
d893 3
a895 4
	}
	if (maxwrite > 0) {
		if (odone > maxwrite)
			odone = maxwrite;
d1018 1
a1018 1
mix_new(char *name, int maxlat, unsigned round, struct aproc *ctl)
d1028 2
a1029 1
	p->u.mix.ctl = ctl;
d1100 1
a1100 3
		if (todo == 0)
			break;
		mix_bzero(obuf);
d1104 2
d1127 20
d1468 1
a1468 1
sub_new(char *name, int maxlat, unsigned round, struct aproc *ctl)
d1478 1
a1478 1
	p->u.sub.ctl = ctl;
@


1.55
log
@don't increment mixer's ``idle'' counter before truncating the
amount of samples to commit to ``maxwrite''. Overwise uncommitted
samples are accounted as idle, in turn causing the device to be
stopped too early, possibly truncating few blocks at the end of
streams being drained.

subtle bug spotted and analysed by Thomas Pfaff, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.54 2010/04/24 06:18:23 ratchov Exp $	*/
d1527 1
a1527 1
		} else {
d1538 18
@


1.54
log
@rename ibuflist/obuflist -> ins/outs to cut long lines
from Thomas Pfaff, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.53 2010/04/21 06:13:07 ratchov Exp $	*/
d857 1
a881 1
		p->u.mix.idle += odone;
d896 2
@


1.53
log
@adds the necessary bits to join channels (ex stereo->mono) or
expand channels (ex mono->stereo).  It's switched on/off with
the ``-j'' option, (default is "on").
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.52 2010/04/17 09:16:57 ratchov Exp $	*/
d162 2
a163 2
	LIST_INIT(&p->ibuflist);
	LIST_INIT(&p->obuflist);
d192 2
a193 2
		while (!LIST_EMPTY(&p->ibuflist)) {
			i = LIST_FIRST(&p->ibuflist);
d196 2
a197 2
		while (!LIST_EMPTY(&p->obuflist)) {
			i = LIST_FIRST(&p->obuflist);
d224 1
a224 1
	LIST_INSERT_HEAD(&p->ibuflist, ibuf, ient);
d233 1
a233 1
	LIST_INSERT_HEAD(&p->obuflist, obuf, oent);
d244 1
a244 1
	LIST_FOREACH(obuf, &p->obuflist, oent) {
d254 1
a254 1
	LIST_FOREACH(ibuf, &p->ibuflist, ient) {
d264 1
a264 1
	LIST_FOREACH(i, &p->ibuflist, ient) {
d268 1
a268 1
	LIST_FOREACH(i, &p->obuflist, oent) {
d282 1
a282 1
	LIST_FOREACH(i, &p->ibuflist, ient) {
d292 1
a292 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
d317 1
a317 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
d361 1
a361 1
	obuf = LIST_FIRST(&p->obuflist);
d434 1
a434 1
	ibuf = LIST_FIRST(&p->ibuflist);
d454 1
a454 1
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
d492 1
a492 1
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
d697 1
a697 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
d752 1
a752 1
	struct abuf *i, *inext, *obuf = LIST_FIRST(&p->obuflist);
d776 1
a776 1
	for (i = LIST_FIRST(&p->ibuflist); i != NULL; i = inext) {
d785 1
a785 1
	if (LIST_EMPTY(&p->ibuflist) || scount == 0)
d805 1
a805 1
		LIST_FOREACH(i, &p->ibuflist, ient) {
d858 1
a858 1
	for (i = LIST_FIRST(&p->ibuflist); i != NULL; i = inext) {
d873 1
a873 1
	if (LIST_EMPTY(&p->ibuflist)) {
d888 1
a888 1
		LIST_FOREACH(i, &p->ibuflist, ient) {
d904 1
a904 1
	struct abuf *i, *inext, *obuf = LIST_FIRST(&p->obuflist);
d920 1
a920 1
		for (i = LIST_FIRST(&p->ibuflist); i != NULL; i = inext) {
d934 1
a934 1
		if (LIST_EMPTY(&p->ibuflist) || odone == obuf->w.mix.todo)
d1037 1
a1037 1
	LIST_FOREACH(i, &p->ibuflist, ient) {
d1049 1
a1049 1
	LIST_FOREACH(i, &p->ibuflist, ient) {
d1070 1
a1070 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
d1080 1
a1080 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
d1219 1
a1219 1
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
d1281 1
a1281 1
	for (i = LIST_FIRST(&p->obuflist); i != NULL; i = inext) {
d1296 1
a1296 1
	if (LIST_EMPTY(&p->obuflist)) {
d1308 1
a1308 1
	LIST_FOREACH(i, &p->obuflist, oent) {
d1321 1
a1321 1
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
d1330 1
a1330 1
	for (i = LIST_FIRST(&p->obuflist); i != NULL; i = inext) {
d1339 1
a1339 1
	if (LIST_EMPTY(&p->obuflist) || idone == 0)
d1341 1
a1341 1
	LIST_FOREACH(i, &p->obuflist, oent) {
d1360 1
a1360 1
	struct abuf *i, *inext, *ibuf = LIST_FIRST(&p->ibuflist);
d1374 1
a1374 1
		for (i = LIST_FIRST(&p->obuflist); i != NULL; i = inext) {
d1388 1
a1388 1
		if (LIST_EMPTY(&p->obuflist) || idone == ibuf->used)
d1565 1
a1565 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
d1578 1
a1578 1
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
d1603 1
a1603 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
d1614 1
a1614 1
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
d1740 1
a1740 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
d1753 1
a1753 1
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
d1898 1
a1898 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
d1911 1
a1911 1
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
d2061 1
a2061 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
d2074 1
a2074 1
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
d2130 1
a2130 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
d2162 1
a2162 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
@


1.52
log
@Allow the mixer to handle inputs with channel ranges outside
the device channel range. This makes the channel mapping code
no longer usefuli, so remove it. No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.51 2010/04/06 20:07:01 ratchov Exp $	*/
d1973 145
@


1.51
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.50 2010/04/03 17:59:17 ratchov Exp $	*/
d611 2
a612 1
	unsigned i, j, icnt, onext, ostart;
d656 7
a662 3
	ostart = ibuf->cmin - obuf->cmin;
	onext = obuf->cmax - ibuf->cmax + ostart;
	icnt = ibuf->cmax - ibuf->cmin + 1;
d664 1
d667 1
a667 1
		for (j = icnt; j > 0; j--) {
d673 1
a947 8
#ifdef DEBUG
	struct abuf *obuf = LIST_FIRST(&p->obuflist);

	if (!obuf || ibuf->cmin < obuf->cmin || ibuf->cmax > obuf->cmax) {
		dbg_puts("newin: channel ranges mismatch\n");
		dbg_panic();
	}
#endif
d1159 2
a1160 1
	unsigned i, j, ocnt, inext, istart;
d1180 8
a1187 3
	istart = obuf->cmin - ibuf->cmin;
	inext = ibuf->cmax - obuf->cmax + istart;
	ocnt = obuf->cmax - obuf->cmin + 1;
a1188 1
	idata += istart;
d1190 3
a1192 1
		for (j = ocnt; j > 0; j--) {
d1197 2
a1395 8
#ifdef DEBUG
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);

	if (!ibuf || obuf->cmin < ibuf->cmin || obuf->cmax > ibuf->cmax) {
		dbg_puts("newout: channel ranges mismatch\n");
		dbg_panic();
	}
#endif
a1656 127
		dbg_puts("\n");
	}
#endif
	return p;
}

/*
 * Convert one block.
 */
void
cmap_bcopy(struct aproc *p, struct abuf *ibuf, struct abuf *obuf)
{
	unsigned inch;
	short *idata;
	unsigned onch;
	short *odata;
	short *ctx, *ictx, *octx;
	unsigned c, f, scount, icount, ocount;

	/*
	 * Calculate max frames readable at once from the input buffer.
	 */
	idata = (short *)abuf_rgetblk(ibuf, &icount, 0);
	if (icount == 0)
		return;
	odata = (short *)abuf_wgetblk(obuf, &ocount, 0);
	if (ocount == 0)
		return;
	scount = icount < ocount ? icount : ocount;
	inch = ibuf->cmax - ibuf->cmin + 1;
	onch = obuf->cmax - obuf->cmin + 1;
	ictx = p->u.cmap.ctx + ibuf->cmin;
	octx = p->u.cmap.ctx + obuf->cmin;

	for (f = scount; f > 0; f--) {
		ctx = ictx;
		for (c = inch; c > 0; c--) {
			*ctx = *idata;
			idata++;
			ctx++;
		}
		ctx = octx;
		for (c = onch; c > 0; c--) {
			*odata = *ctx;
			odata++;
			ctx++;
		}
	}
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": bcopy ");
		dbg_putu(scount);
		dbg_puts(" fr\n");
	}
#endif
	abuf_rdiscard(ibuf, scount);
	abuf_wcommit(obuf, scount);
}

int
cmap_in(struct aproc *p, struct abuf *ibuf)
{
	struct abuf *obuf = LIST_FIRST(&p->obuflist);

	if (!ABUF_WOK(obuf) || !ABUF_ROK(ibuf))
		return 0;
	cmap_bcopy(p, ibuf, obuf);
	if (!abuf_flush(obuf))
		return 0;
	return 1;
}

int
cmap_out(struct aproc *p, struct abuf *obuf)
{
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);

	if (!abuf_fill(ibuf))
		return 0;
	if (!ABUF_WOK(obuf) || !ABUF_ROK(ibuf))
		return 0;
	cmap_bcopy(p, ibuf, obuf);
	return 1;
}

void
cmap_eof(struct aproc *p, struct abuf *ibuf)
{
	aproc_del(p);
}

void
cmap_hup(struct aproc *p, struct abuf *obuf)
{
	aproc_del(p);
}

struct aproc_ops cmap_ops = {
	"cmap",
	cmap_in,
	cmap_out,
	cmap_eof,
	cmap_hup,
	NULL,
	NULL,
	aproc_ipos,
	aproc_opos,
	NULL
};

struct aproc *
cmap_new(char *name, struct aparams *ipar, struct aparams *opar)
{
	struct aproc *p;
	unsigned i;

	p = aproc_new(&cmap_ops, name);
	for (i = 0; i < NCHAN_MAX; i++)
		p->u.cmap.ctx[i] = 0;
#ifdef DEBUG
	if (debug_level >= 3) {
		aproc_dbg(p);
		dbg_puts(": new ");
		aparams_dbg(ipar);
		dbg_puts(" -> ");
		aparams_dbg(opar);
@


1.50
log
@backout last change, committed by mistake, sorry...
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.48 2010/01/17 19:17:23 ratchov Exp $	*/
d51 12
d290 25
a318 2
	unsigned char *data;
	unsigned count;
d320 1
a320 1
	if (ABUF_FULL(obuf) || !(f->state & FILE_ROK))
d322 1
a322 3
	data = abuf_wgetblk(obuf, &count, 0);
	count = file_read(f, data, count);
	if (count == 0)
a323 1
	abuf_wcommit(obuf, count);
a332 2
	unsigned char *data;
	unsigned count;
d336 1
a336 1
	if (ABUF_FULL(obuf) || !(f->state & FILE_ROK))
d338 1
a338 3
	data = abuf_wgetblk(obuf, &count, 0);
	count = file_read(f, data, count);
	if (count == 0)
a339 1
	abuf_wcommit(obuf, count);
d352 6
a364 1
		f->rproc = NULL;
d368 9
a376 1
	p->u.io.file = NULL;
d411 1
d425 6
a437 1
		f->wproc = NULL;
d441 8
a448 1
	p->u.io.file = NULL;
d452 24
a478 2
	unsigned char *data;
	unsigned count;
d482 1
a482 1
	if (ABUF_EMPTY(ibuf) || !(f->state & FILE_WOK))
d484 1
a484 3
	data = abuf_rgetblk(ibuf, &count, 0);
	count = file_write(f, data, count);
	if (count == 0)
a485 1
	abuf_rdiscard(ibuf, count);
a493 2
	unsigned char *data;
	unsigned count;
d497 1
a497 5
	if (ABUF_EMPTY(ibuf) || !(f->state & FILE_WOK))
		return 0;
	data = abuf_rgetblk(ibuf, &count, 0);
	if (count == 0) {
		/* XXX: this can't happen, right ? */
d499 1
a499 3
	}
	count = file_write(f, data, count);
	if (count == 0)
a500 1
	abuf_rdiscard(ibuf, count);
d536 1
d542 38
d581 1
a581 1
 * space), and crank mixitodo accordingly.
d584 1
a584 1
mix_bzero(struct abuf *obuf, unsigned zcount)
d589 5
d598 1
a598 1
		dbg_putu(zcount);
a601 6
	odata = (short *)abuf_wgetblk(obuf, &ocount, obuf->w.mix.todo);
	ocount -= ocount % obuf->bpf;
	if (ocount > zcount)
		ocount = zcount;
	memset(odata, 0, ocount);
	obuf->w.mix.todo += ocount;
d607 1
a607 1
void
d612 1
a612 1
	unsigned scount, icount, ocount, zcount;
d622 2
d628 13
a643 1
	icount /= ibuf->bpf;
d645 1
a645 8
		return;

	/*
	 * Zero-fill if necessary.
	 */
	zcount = ibuf->r.mix.done + icount * obuf->bpf;
	if (zcount > obuf->w.mix.todo)
		mix_bzero(obuf, zcount - obuf->w.mix.todo);
a650 1
	ocount /= obuf->bpf;
d652 1
a652 1
		return;
d668 2
a669 2
	abuf_rdiscard(ibuf, scount * ibuf->bpf);
	ibuf->r.mix.done += scount * obuf->bpf;
a674 2
		dbg_putu(scount);
		dbg_puts(", todo = ");
d681 1
d688 1
a688 1
mix_xrun(struct abuf *i, struct abuf *obuf)
d690 2
a691 1
	unsigned fdrop;
d699 1
a699 2
	mix_bzero(obuf, obuf->len);
	fdrop = obuf->w.mix.todo / obuf->bpf;
d706 1
a706 1
		dbg_putu(i->drop / i->bpf);
d710 1
a710 1
	i->r.mix.done += fdrop * obuf->bpf;
d712 1
a712 1
		i->drop += fdrop * i->bpf;
d714 13
d735 1
a735 1
			i->duplex->drop += fdrop * i->duplex->bpf;
d747 2
d764 1
a764 1
	if (!ABUF_ROK(ibuf))
d766 3
a768 1
	odone = obuf->len;
d771 1
a771 1
		if (!abuf_fill(i))
d773 2
a774 1
		mix_badd(i, obuf);
d778 1
a778 1
	if (LIST_EMPTY(&p->ibuflist) || odone == 0)
d780 27
a806 3
	p->u.mix.lat += odone / obuf->bpf;
	LIST_FOREACH(i, &p->ibuflist, ient) {
		i->r.mix.done -= odone;
a807 4
	abuf_wcommit(obuf, odone);
	obuf->w.mix.todo -= odone;
	if (!abuf_flush(obuf))
		return 0; /* hup */
d816 2
d835 15
d853 1
a853 1
		if (!abuf_fill(i))
d855 2
a856 1
		if (!ABUF_ROK(i)) {
d858 1
a858 1
				if (!mix_xrun(i, obuf))
d862 1
a862 1
			mix_badd(i, obuf);
a872 1
		mix_bzero(obuf, obuf->len);
d874 14
a887 1
		p->u.mix.idle += odone / obuf->bpf;
d889 1
a889 1
	if (odone == 0)
a890 6
	p->u.mix.lat += odone / obuf->bpf;
	LIST_FOREACH(i, &p->ibuflist, ient) {
		i->r.mix.done -= odone;
	}
	abuf_wcommit(obuf, odone);
	obuf->w.mix.todo -= odone;
d897 1
a897 1
	struct abuf *i, *obuf = LIST_FIRST(&p->obuflist);
d913 5
a917 2
		LIST_FOREACH(i, &p->ibuflist, ient) {
			if (ABUF_ROK(i) && i->r.mix.done < obuf->w.mix.todo) {
d955 1
d965 2
a966 2
		dbg_putu(obuf->len / obuf->bpf);
		dbg_puts(" fr\n");
d975 1
d983 1
a983 1
		dbg_puts(" fr\n");
d986 1
a986 2
	p->u.mix.lat -= delta;
	if (p->u.mix.ctl)
d989 2
d1007 1
a1007 1
mix_new(char *name, int maxlat, struct aproc *ctl)
d1014 1
d1016 1
d1074 1
d1087 1
a1087 1
		todo = (p->u.mix.maxlat - p->u.mix.lat) * obuf->bpf;
d1090 1
a1090 1
		mix_bzero(obuf, obuf->len);
d1095 2
a1096 1
		p->u.mix.lat += count / obuf->bpf;
d1098 2
d1115 39
d1163 11
a1174 1
	icount /= ibuf->bpf;
a1177 1
	ocount /= obuf->bpf;
d1193 2
a1194 2
	abuf_wcommit(obuf, scount * obuf->bpf);
	obuf->w.sub.done += scount * ibuf->bpf;
d1200 1
a1200 1
		dbg_puts(" fr\n");
d1209 1
a1209 1
sub_xrun(struct abuf *ibuf, struct abuf *i)
d1211 2
a1212 1
	unsigned fdrop;
d1220 1
a1220 1
	fdrop = ibuf->used / ibuf->bpf;
d1227 1
a1227 1
		dbg_putu(i->silence / i->bpf);
d1231 1
d1233 1
a1233 1
		i->silence += fdrop * i->bpf;
d1235 14
d1257 1
a1257 1
			i->duplex->silence += fdrop * i->duplex->bpf;
a1260 1
	i->w.sub.done += fdrop * ibuf->bpf;
d1275 2
a1276 1
		if (!ABUF_WOK(i)) {
d1278 1
a1278 1
				if (!sub_xrun(ibuf, i))
d1296 1
a1296 1
		p->u.sub.idle += idone / ibuf->bpf;
d1304 3
a1306 1
	p->u.sub.lat -= idone / ibuf->bpf;
d1317 1
a1317 1
	if (!ABUF_WOK(obuf))
d1324 1
d1337 3
a1339 1
	p->u.sub.lat -= idone / ibuf->bpf;
d1352 1
a1352 1
	struct abuf *i, *ibuf = LIST_FIRST(&p->ibuflist);
d1366 5
a1370 2
		LIST_FOREACH(i, &p->obuflist, oent) {
			if (ABUF_WOK(i) && i->w.sub.done < ibuf->used) {
d1399 1
d1413 1
a1413 1
		dbg_puts(" fr\n");
d1416 1
a1416 1
	if (p->u.sub.ctl)
d1435 1
a1435 1
sub_new(char *name, int maxlat, struct aproc *ctl)
d1442 1
d1444 1
d1452 2
a1453 1
	p->u.mix.lat = 0;
d1480 1
a1480 2
	ifr = icount / ibuf->bpf;
	icount = ifr * ibuf->bpf;
d1483 1
a1483 2
	ofr = ocount / obuf->bpf;
	ocount = ofr * obuf->bpf;
d1515 2
d1524 3
a1526 1
			if (--ifr == 0)
a1527 1
		} else {
d1536 1
a1536 2
			if (--ofr == 0)
				break;
d1556 2
a1557 2
	icount -= ifr * ibuf->bpf;
	ocount -= ofr * obuf->bpf;
a1679 1
	icount /= ibuf->bpf;
a1682 1
	ocount /= obuf->bpf;
d1713 2
a1714 2
	abuf_rdiscard(ibuf, scount * ibuf->bpf);
	abuf_wcommit(obuf, scount * obuf->bpf);
a1811 1
	icount /= ibuf->bpf;
a1814 1
	ocount /= obuf->bpf;
d1824 1
a1824 1
		dbg_puts(" fr * ");
d1860 2
a1861 2
	abuf_rdiscard(ibuf, scount * ibuf->bpf);
	abuf_wcommit(obuf, scount * obuf->bpf);
a1969 1
	icount /= ibuf->bpf;
a1972 1
	ocount /= obuf->bpf;
d1982 1
a1982 1
		dbg_puts(" fr * ");
d2018 2
a2019 2
	abuf_rdiscard(ibuf, scount * ibuf->bpf);
	abuf_wcommit(obuf, scount * obuf->bpf);
d2101 165
@


1.49
log
@doc fixes from jmc
@
text
@a50 12
/*
 * Same as ABUF_ROK(), but consider that a buffer is 
 * readable if there's silence pending to be inserted
 */
#define MIX_ROK(buf) (ABUF_ROK(buf) || (buf)->r.mix.drop < 0)

/*
 * Same as ABUF_WOK(), but consider that a buffer is 
 * writeable if there are samples to drop
 */
#define SUB_WOK(buf) (ABUF_WOK(buf) || (buf)->w.sub.silence < 0)

d278 1
a278 1
rfile_do(struct aproc *p, unsigned todo, unsigned *done)
d283 1
a283 1
	unsigned n, count, off;
d285 2
a286 1
	off = p->u.io.partial;
d288 2
a289 24
	if (count > todo)
		count = todo;
	n = file_read(f, data + off, count * obuf->bpf - off);
	if (n == 0)
		return 0;
	n += off;
	p->u.io.partial = n % obuf->bpf;
	count = n / obuf->bpf;
	if (count > 0)
		abuf_wcommit(obuf, count);
	if (done)
		*done = count;
	return 1;
}

int
rfile_in(struct aproc *p, struct abuf *ibuf_dummy)
{
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
	struct file *f = p->u.io.file;

	if (!ABUF_WOK(obuf) || !(f->state & FILE_ROK))
		return 0;
	if (!rfile_do(p, obuf->len, NULL))
d291 1
d301 2
d306 1
a306 1
	if (!ABUF_WOK(obuf) || !(f->state & FILE_ROK))
d308 3
a310 1
	if (!rfile_do(p, obuf->len, NULL))
d312 1
a324 6
	 * disconnect from file structure
	 */
	f->rproc = NULL;
	p->u.io.file = NULL;

	/*
d332 1
d336 1
a336 9

#ifdef DEBUG
	if (debug_level >= 2 && p->u.io.partial > 0) {
		aproc_dbg(p);
		dbg_puts(": ");
		dbg_putu(p->u.io.partial);
		dbg_puts(" bytes lost in partial read\n");
	}
#endif
a370 1
	p->u.io.partial = 0;
a383 6
	 * disconnect from file structure
	 */
	f->wproc = NULL;
	p->u.io.file = NULL;

	/*
d391 1
d395 1
a395 8
#ifdef DEBUG
	if (debug_level >= 2 && p->u.io.partial > 0) {
		aproc_dbg(p);
		dbg_puts(": ");
		dbg_putu(p->u.io.partial);
		dbg_puts(" bytes lost in partial write\n");
	}
#endif
d399 1
a399 1
wfile_do(struct aproc *p, unsigned todo, unsigned *done)
a400 1
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
d403 1
a403 22
	unsigned n, count, off;

	off = p->u.io.partial;
	data = abuf_rgetblk(ibuf, &count, 0);
	if (count > todo)
		count = todo;
	n = file_write(f, data + off, count * ibuf->bpf - off);
	if (n == 0)
		return 0;
	n += off;
	p->u.io.partial = n % ibuf->bpf;
	count = n / ibuf->bpf;
	if (count > 0)
		abuf_rdiscard(ibuf, count);
	if (done)
		*done = count;
	return 1;
}
int
wfile_in(struct aproc *p, struct abuf *ibuf)
{
	struct file *f = p->u.io.file;
d407 1
a407 1
	if (!ABUF_ROK(ibuf) || !(f->state & FILE_WOK))
d409 3
a411 1
	if (!wfile_do(p, ibuf->len, NULL))
d413 1
d422 2
d427 5
a431 1
	if (!ABUF_ROK(ibuf) || !(f->state & FILE_WOK))
d433 3
a435 1
	if (!wfile_do(p, ibuf->len, NULL))
d437 1
a472 1
	p->u.io.partial = 0;
a477 38
 * Drop as much as possible samples from the reader end,
 * negative values mean ``insert silence''.
 */
void
mix_drop(struct abuf *buf, int extra)
{
	unsigned count;

	buf->r.mix.drop += extra;
	while (buf->r.mix.drop > 0) {
		count = buf->r.mix.drop;
		if (count > buf->used)
			count = buf->used;
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 4) {
				abuf_dbg(buf);
				dbg_puts(": drop: no data\n");
			}
#endif
			return;
		}
		abuf_rdiscard(buf, count);
		buf->r.mix.drop -= count;
#ifdef DEBUG
		if (debug_level >= 4) {
			abuf_dbg(buf);
			dbg_puts(": dropped ");
			dbg_putu(count);
			dbg_puts(", to drop = ");
			dbg_putu(buf->r.mix.drop);
			dbg_puts("\n");
		}
#endif
	}
}

/*
d479 1
a479 1
 * space), and crank w.mix.todo accordingly.
d482 1
a482 1
mix_bzero(struct abuf *obuf)
a486 5
	odata = (short *)abuf_wgetblk(obuf, &ocount, obuf->w.mix.todo);
	if (ocount == 0)
		return;
	memset(odata, 0, ocount * obuf->bpf);
	obuf->w.mix.todo += ocount;
d491 1
a491 1
		dbg_putu(obuf->w.mix.todo);
d495 6
d506 1
a506 1
unsigned
d511 1
a511 1
	unsigned scount, icount, ocount;
a520 2
		dbg_puts(", drop = ");
		dbg_puti(ibuf->r.mix.drop);
d525 1
a525 1
	 * Insert silence for xrun correction
d527 4
a530 9
	if (ibuf->r.mix.drop < 0) {
		icount = -ibuf->r.mix.drop;
		ocount = obuf->len - obuf->used;
		if (ocount > obuf->w.mix.todo)
			ocount = obuf->w.mix.todo;
		scount = (icount < ocount) ? icount : ocount;
		ibuf->r.mix.done += scount;
		ibuf->r.mix.drop += scount;
	}
d533 1
a533 1
	 * Calculate the maximum we can read.
d535 3
a537 3
	idata = (short *)abuf_rgetblk(ibuf, &icount, 0);
	if (icount == 0)
		return 0;
d543 1
d545 1
a545 1
		return 0;
d561 2
a562 2
	abuf_rdiscard(ibuf, scount);
	ibuf->r.mix.done += scount;
d568 2
a575 1
	return scount;
d582 1
a582 1
mix_xrun(struct aproc *p, struct abuf *i)
d584 1
a584 2
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
	unsigned fdrop, remain;
d592 2
a593 1
	fdrop = obuf->w.mix.todo;
d600 1
a600 1
		dbg_putu(i->r.mix.drop);
d604 1
a604 1
	i->r.mix.done += fdrop;
d606 1
a606 1
		mix_drop(i, fdrop);
a607 13
		remain = fdrop % p->u.mix.round;
		if (remain)
			remain = p->u.mix.round - remain;
		mix_drop(i, -(int)remain);
		fdrop += remain;
#ifdef DEBUG
		if (debug_level >= 3) {
			abuf_dbg(i);
			dbg_puts(": underrun, adding ");
			dbg_putu(remain);
			dbg_puts("\n");
		}
#endif
d616 1
a616 1
			sub_silence(i->duplex, -(int)fdrop);
a627 2
	unsigned maxwrite;
	unsigned scount;
d643 1
a643 1
	if (!MIX_ROK(ibuf))
d645 1
a645 3
	mix_bzero(obuf);
	scount = 0;
	odone = obuf->w.mix.todo;
d648 1
a648 1
		if (i->r.mix.drop >= 0 && !abuf_fill(i))
d650 1
a650 2
		mix_drop(i, 0);
		scount += mix_badd(i, obuf);
d654 1
a654 1
	if (LIST_EMPTY(&p->ibuflist) || scount == 0)
d656 3
a658 27
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": maxwrite = ");
		dbg_putu(p->u.mix.maxlat);
		dbg_puts(" - ");
		dbg_putu(p->u.mix.lat);
		dbg_puts(" = ");
		dbg_putu(p->u.mix.maxlat - p->u.mix.lat);
		dbg_puts("\n");
	}
#endif
	maxwrite = p->u.mix.maxlat - p->u.mix.lat;
	if (maxwrite > 0) {
		if (odone > maxwrite)
			odone = maxwrite;
		p->u.mix.lat += odone;
		p->u.mix.abspos += odone;
		LIST_FOREACH(i, &p->ibuflist, ient) {
			i->r.mix.done -= odone;
		}
		abuf_wcommit(obuf, odone);
		obuf->w.mix.todo -= odone;
		if (APROC_OK(p->u.mix.mon))
			mon_snoop(p->u.mix.mon, obuf, obuf->used - odone, odone);
		if (!abuf_flush(obuf))
			return 0; /* hup */
d660 4
a671 2
	unsigned maxwrite;
	unsigned scount;
a688 15
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": maxwrite = ");
		dbg_putu(p->u.mix.maxlat);
		dbg_puts(" - ");
		dbg_putu(p->u.mix.lat);
		dbg_puts(" = ");
		dbg_putu(p->u.mix.maxlat - p->u.mix.lat);
		dbg_puts("\n");
	}
#endif
	maxwrite = p->u.mix.maxlat - p->u.mix.lat;
	mix_bzero(obuf);
	scount = 0;
d692 1
a692 1
		if (i->r.mix.drop >= 0 && !abuf_fill(i))
d694 1
a694 2
		mix_drop(i, 0);
		if (maxwrite > 0 && !MIX_ROK(i)) {
d696 1
a696 1
				if (!mix_xrun(p, i))
d700 1
a700 1
			scount += mix_badd(i, obuf);
d711 1
d713 1
a713 1
		p->u.mix.idle += odone;
d715 5
a719 12
	if (maxwrite > 0) {
		if (odone > maxwrite)
			odone = maxwrite;
		p->u.mix.lat += odone;
		p->u.mix.abspos += odone;
		LIST_FOREACH(i, &p->ibuflist, ient) {
			i->r.mix.done -= odone;
		}
		abuf_wcommit(obuf, odone);
		obuf->w.mix.todo -= odone;
		if (APROC_OK(p->u.mix.mon))
			mon_snoop(p->u.mix.mon, obuf, obuf->used - odone, odone);
d721 2
a722 2
	if (scount == 0)
		return 0;
d729 1
a729 1
	struct abuf *i, *inext, *obuf = LIST_FIRST(&p->obuflist);
d745 2
a746 5
		for (i = LIST_FIRST(&p->ibuflist); i != NULL; i = inext) {
			inext = LIST_NEXT(i, ient);
			if (!abuf_fill(i))
				continue;
			if (MIX_ROK(i) && i->r.mix.done < obuf->w.mix.todo) {
a783 1
	ibuf->r.mix.drop = 0;
d793 2
a794 2
		dbg_putu(obuf->len);
		dbg_puts("\n");
a802 1
	p->u.mix.lat -= delta;
d810 1
a810 1
		dbg_puts("\n");
d813 2
a814 1
	if (APROC_OK(p->u.mix.ctl))
a816 2
	if (APROC_OK(p->u.mix.mon))
		p->u.mix.mon->ops->ipos(p->u.mix.mon, NULL, delta);
d833 1
a833 1
mix_new(char *name, int maxlat, unsigned round, struct aproc *ctl)
a839 1
	p->u.mix.round = round;
a840 1
	p->u.mix.abspos = 0;
a897 1
	p->u.mix.abspos = 0;
d910 1
a910 1
		todo = p->u.mix.maxlat - p->u.mix.lat;
d913 1
a913 1
		mix_bzero(obuf);
d918 1
a918 2
		p->u.mix.lat += count;
		p->u.mix.abspos += count;
a919 2
		if (APROC_OK(p->u.mix.mon))
			mon_snoop(p->u.mix.mon, obuf, 0, count);
a934 39
 * Append as much as possible silence on the writer end
 */
void
sub_silence(struct abuf *buf, int extra)
{
	unsigned char *data;
	unsigned count;

	buf->w.sub.silence += extra;
	if (buf->w.sub.silence > 0) {
		data = abuf_wgetblk(buf, &count, 0);
		if (count >= buf->w.sub.silence)
			count = buf->w.sub.silence;
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 4) {
				abuf_dbg(buf);
				dbg_puts(": no space for silence\n");
			}
#endif
			return;
		}
		memset(data, 0, count * buf->bpf);
		abuf_wcommit(buf, count);
		buf->w.sub.silence -= count;
#ifdef DEBUG
		if (debug_level >= 4) {
			abuf_dbg(buf);
			dbg_puts(": appended ");
			dbg_putu(count);
			dbg_puts(", remaining silence = ");
			dbg_putu(buf->w.sub.silence);
			dbg_puts("\n");
		}
#endif
	}
}

/*
a943 11
	/*
	 * Drop samples for xrun correction
	 */
	if (obuf->w.sub.silence < 0) {
		scount = -obuf->w.sub.silence;
		if (scount > ibuf->used)
			scount = ibuf->used;
		obuf->w.sub.done += scount;
		obuf->w.sub.silence += scount;
	}

d945 1
d949 1
d965 2
a966 2
	abuf_wcommit(obuf, scount);
	obuf->w.sub.done += scount;
d972 1
a972 1
		dbg_puts("\n");
d981 1
a981 1
sub_xrun(struct aproc *p, struct abuf *i)
d983 1
a983 2
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
	unsigned fdrop, remain;
d991 1
a991 1
	fdrop = ibuf->used;
d998 1
a998 1
		dbg_putu(i->w.sub.silence);
a1001 1
	i->w.sub.done += fdrop;
d1003 1
a1003 1
		sub_silence(i, fdrop);
a1004 14
		remain = fdrop % p->u.sub.round;
		if (remain)
			remain = p->u.sub.round - remain;
		sub_silence(i, -(int)remain);
		fdrop += remain;
#ifdef DEBUG
		if (debug_level >= 3) {
			abuf_dbg(i);
			dbg_puts(": overrun, adding ");
			dbg_putu(remain);
			dbg_puts("\n");
		}
#endif

d1013 1
a1013 1
			mix_drop(i->duplex, -(int)fdrop);
d1017 1
d1032 1
a1032 2
		sub_silence(i, 0);
		if (!SUB_WOK(i)) {
d1034 1
a1034 1
				if (!sub_xrun(p, i))
d1052 1
a1052 1
		p->u.sub.idle += idone;
d1060 1
a1060 3
	abuf_opos(ibuf, idone);
	p->u.sub.lat -= idone;
	p->u.sub.abspos += idone;
d1071 1
a1071 1
	if (!SUB_WOK(obuf))
a1077 1
		sub_silence(i, 0);
d1090 1
a1090 3
	abuf_opos(ibuf, idone);
	p->u.sub.lat -= idone;
	p->u.sub.abspos += idone;
d1103 1
a1103 1
	struct abuf *i, *inext, *ibuf = LIST_FIRST(&p->ibuflist);
d1117 2
a1118 5
		for (i = LIST_FIRST(&p->obuflist); i != NULL; i = inext) {
			inext = LIST_NEXT(i, oent);
			if (!abuf_flush(i))
				continue;
			if (SUB_WOK(i) && i->w.sub.done < ibuf->used) {
a1146 1
	obuf->w.sub.silence = 0;
d1160 1
a1160 1
		dbg_puts("\n");
d1163 1
a1163 1
	if (APROC_OK(p->u.sub.ctl))
d1182 1
a1182 1
sub_new(char *name, int maxlat, unsigned round, struct aproc *ctl)
a1188 1
	p->u.sub.round = round;
a1189 1
	p->u.sub.abspos = 0;
d1197 1
a1197 2
	p->u.sub.lat = 0;
	p->u.sub.abspos = 0;
d1224 2
a1225 1
	ifr = icount;
d1228 2
a1229 1
	ofr = ocount;
a1260 2
			if (ifr == 0)
				break;
d1268 2
a1269 1
			ifr--;
a1270 2
			if (ofr == 0)
				break;
d1279 2
a1280 1
			ofr--;
d1300 2
a1301 2
	icount -= ifr;
	ocount -= ofr;
d1424 1
d1428 1
d1459 2
a1460 2
	abuf_rdiscard(ibuf, scount);
	abuf_wcommit(obuf, scount);
d1558 1
d1562 1
d1572 1
a1572 1
		dbg_puts(" fr / ");
d1608 2
a1609 2
	abuf_rdiscard(ibuf, scount);
	abuf_wcommit(obuf, scount);
d1718 1
d1722 1
d1732 1
a1732 1
		dbg_puts(" fr / ");
d1768 2
a1769 2
	abuf_rdiscard(ibuf, scount);
	abuf_wcommit(obuf, scount);
a1850 165
	}
#endif
	return p;
}

/*
 * Commit and flush part of the output buffer
 */
void
mon_flush(struct aproc *p)
{
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
	unsigned count;

#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": delta = ");
		dbg_puti(p->u.mon.delta);
		dbg_puts("/");
		dbg_putu(p->u.mon.bufsz);
		dbg_puts(" pending = ");
		dbg_puti(p->u.mon.pending);
		dbg_puts("\n");
	}
#endif
	if (p->u.mon.delta <= 0 || p->u.mon.pending == 0)
		return;
	count = p->u.mon.delta;
	if (count > p->u.mon.pending)
		count = p->u.mon.pending;
	abuf_wcommit(obuf, count);
	p->u.mon.pending -= count;
	p->u.mon.delta -= count;
	abuf_flush(obuf);
}

/*
 * Copy one block.
 */
void
mon_snoop(struct aproc *p, struct abuf *ibuf, unsigned pos, unsigned todo)
{
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
	unsigned scount, icount, ocount;
	short *idata, *odata;

#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": snoop ");
		dbg_putu(pos);
		dbg_puts("..");
		dbg_putu(todo);
		dbg_puts("\n");
	}
#endif
	if (!abuf_flush(obuf))
		return;

	while (todo > 0) {
		/*
		 * Calculate max frames readable at once from the input buffer.
		 */
		idata = (short *)abuf_rgetblk(ibuf, &icount, pos);
		odata = (short *)abuf_wgetblk(obuf, &ocount, p->u.mon.pending);
		scount = (icount < ocount) ? icount : ocount;
#ifdef DEBUG
		if (debug_level >= 4) {
			aproc_dbg(p);
			dbg_puts(": snooping ");
			dbg_putu(scount);
			dbg_puts(" fr\n");
		}
		if (scount == 0) {
			dbg_puts("monitor xrun, not allowed\n");
			dbg_panic();
		}
#endif
		memcpy(odata, idata, scount * obuf->bpf);
		p->u.mon.pending += scount;
		todo -= scount;
		pos += scount;
	}
	mon_flush(p);
}

int
mon_in(struct aproc *p, struct abuf *ibuf)
{
#ifdef DEBUG
	dbg_puts("monitor can't have inputs to read\n");
	dbg_panic();
#endif
	return 0;
}

/*
 * put the monitor into ``empty'' state
 */
void
mon_clear(struct aproc *p)
{
	p->u.mon.pending = 0;
	p->u.mon.delta = 0;
}

int
mon_out(struct aproc *p, struct abuf *obuf)
{
	/*
	 * can't trigger monitored stream to produce data
	 */
	return 0;
}

void
mon_eof(struct aproc *p, struct abuf *ibuf)
{
#ifdef DEBUG
	dbg_puts("monitor can't have inputs to eof\n");
	dbg_panic();
#endif
}

void
mon_hup(struct aproc *p, struct abuf *obuf)
{
	aproc_del(p);
}

void
mon_ipos(struct aproc *p, struct abuf *ibuf, int delta)
{
	aproc_ipos(p, ibuf, delta);
	p->u.mon.delta += delta;
	mon_flush(p);
}

struct aproc_ops mon_ops = {
	"mon",
	mon_in,
	mon_out,
	mon_eof,
	mon_hup,
	NULL,
	NULL,
	mon_ipos,
	aproc_opos,
	NULL
};

struct aproc *
mon_new(char *name, unsigned bufsz)
{
	struct aproc *p;

	p = aproc_new(&mon_ops, name);
	p->u.mon.pending = 0;
	p->u.mon.delta = 0;
	p->u.mon.bufsz = bufsz;
#ifdef DEBUG
	if (debug_level >= 3) {
		aproc_dbg(p);
		dbg_puts(": new\n");
@


1.48
log
@While resampling, if input samples are available but output
is blocked don't start processing input. Similarly don't
produce output if input is blocked. This is to ensure that
to each output block corresponds exactly one input block.
This is necessary for full-duplex clients using block-based
i/o and very small buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.47 2010/01/17 16:09:30 ratchov Exp $	*/
d51 12
d290 25
a318 2
	unsigned char *data;
	unsigned count;
d320 1
a320 1
	if (ABUF_FULL(obuf) || !(f->state & FILE_ROK))
d322 1
a322 3
	data = abuf_wgetblk(obuf, &count, 0);
	count = file_read(f, data, count);
	if (count == 0)
a323 1
	abuf_wcommit(obuf, count);
a332 2
	unsigned char *data;
	unsigned count;
d336 1
a336 1
	if (ABUF_FULL(obuf) || !(f->state & FILE_ROK))
d338 1
a338 3
	data = abuf_wgetblk(obuf, &count, 0);
	count = file_read(f, data, count);
	if (count == 0)
a339 1
	abuf_wcommit(obuf, count);
d352 6
a364 1
		f->rproc = NULL;
d368 9
a376 1
	p->u.io.file = NULL;
d411 1
d425 6
a437 1
		f->wproc = NULL;
d441 8
a448 1
	p->u.io.file = NULL;
d452 24
a478 2
	unsigned char *data;
	unsigned count;
d482 1
a482 1
	if (ABUF_EMPTY(ibuf) || !(f->state & FILE_WOK))
d484 1
a484 3
	data = abuf_rgetblk(ibuf, &count, 0);
	count = file_write(f, data, count);
	if (count == 0)
a485 1
	abuf_rdiscard(ibuf, count);
a493 2
	unsigned char *data;
	unsigned count;
d497 1
a497 5
	if (ABUF_EMPTY(ibuf) || !(f->state & FILE_WOK))
		return 0;
	data = abuf_rgetblk(ibuf, &count, 0);
	if (count == 0) {
		/* XXX: this can't happen, right ? */
d499 1
a499 3
	}
	count = file_write(f, data, count);
	if (count == 0)
a500 1
	abuf_rdiscard(ibuf, count);
d536 1
d542 38
d581 1
a581 1
 * space), and crank mixitodo accordingly.
d584 1
a584 1
mix_bzero(struct abuf *obuf, unsigned zcount)
d589 5
d598 1
a598 1
		dbg_putu(zcount);
a601 6
	odata = (short *)abuf_wgetblk(obuf, &ocount, obuf->w.mix.todo);
	ocount -= ocount % obuf->bpf;
	if (ocount > zcount)
		ocount = zcount;
	memset(odata, 0, ocount);
	obuf->w.mix.todo += ocount;
d607 1
a607 1
void
d612 1
a612 1
	unsigned scount, icount, ocount, zcount;
d622 2
d628 13
a643 1
	icount /= ibuf->bpf;
d645 1
a645 8
		return;

	/*
	 * Zero-fill if necessary.
	 */
	zcount = ibuf->r.mix.done + icount * obuf->bpf;
	if (zcount > obuf->w.mix.todo)
		mix_bzero(obuf, zcount - obuf->w.mix.todo);
a650 1
	ocount /= obuf->bpf;
d652 1
a652 1
		return;
d668 2
a669 2
	abuf_rdiscard(ibuf, scount * ibuf->bpf);
	ibuf->r.mix.done += scount * obuf->bpf;
a674 2
		dbg_putu(scount);
		dbg_puts(", todo = ");
d681 1
d688 1
a688 1
mix_xrun(struct abuf *i, struct abuf *obuf)
d690 2
a691 1
	unsigned fdrop;
d699 1
a699 2
	mix_bzero(obuf, obuf->len);
	fdrop = obuf->w.mix.todo / obuf->bpf;
d706 1
a706 1
		dbg_putu(i->drop / i->bpf);
d710 1
a710 1
	i->r.mix.done += fdrop * obuf->bpf;
d712 1
a712 1
		i->drop += fdrop * i->bpf;
d714 13
d735 1
a735 1
			i->duplex->drop += fdrop * i->duplex->bpf;
d747 2
d764 1
a764 1
	if (!ABUF_ROK(ibuf))
d766 3
a768 1
	odone = obuf->len;
d771 1
a771 1
		if (!abuf_fill(i))
d773 2
a774 1
		mix_badd(i, obuf);
d778 1
a778 1
	if (LIST_EMPTY(&p->ibuflist) || odone == 0)
d780 27
a806 3
	p->u.mix.lat += odone / obuf->bpf;
	LIST_FOREACH(i, &p->ibuflist, ient) {
		i->r.mix.done -= odone;
a807 4
	abuf_wcommit(obuf, odone);
	obuf->w.mix.todo -= odone;
	if (!abuf_flush(obuf))
		return 0; /* hup */
d816 2
d835 15
d853 1
a853 1
		if (!abuf_fill(i))
d855 2
a856 1
		if (!ABUF_ROK(i)) {
d858 1
a858 1
				if (!mix_xrun(i, obuf))
d862 1
a862 1
			mix_badd(i, obuf);
a872 1
		mix_bzero(obuf, obuf->len);
d874 14
a887 1
		p->u.mix.idle += odone / obuf->bpf;
d889 1
a889 1
	if (odone == 0)
a890 6
	p->u.mix.lat += odone / obuf->bpf;
	LIST_FOREACH(i, &p->ibuflist, ient) {
		i->r.mix.done -= odone;
	}
	abuf_wcommit(obuf, odone);
	obuf->w.mix.todo -= odone;
d897 1
a897 1
	struct abuf *i, *obuf = LIST_FIRST(&p->obuflist);
d913 5
a917 2
		LIST_FOREACH(i, &p->ibuflist, ient) {
			if (ABUF_ROK(i) && i->r.mix.done < obuf->w.mix.todo) {
d955 1
d965 2
a966 2
		dbg_putu(obuf->len / obuf->bpf);
		dbg_puts(" fr\n");
d975 1
d983 1
a983 1
		dbg_puts(" fr\n");
d986 1
a986 2
	p->u.mix.lat -= delta;
	if (p->u.mix.ctl)
d989 2
d1007 1
a1007 1
mix_new(char *name, int maxlat, struct aproc *ctl)
d1014 1
d1016 1
d1074 1
d1087 1
a1087 1
		todo = (p->u.mix.maxlat - p->u.mix.lat) * obuf->bpf;
d1090 1
a1090 1
		mix_bzero(obuf, obuf->len);
d1095 2
a1096 1
		p->u.mix.lat += count / obuf->bpf;
d1098 2
d1115 39
d1163 11
a1174 1
	icount /= ibuf->bpf;
a1177 1
	ocount /= obuf->bpf;
d1193 2
a1194 2
	abuf_wcommit(obuf, scount * obuf->bpf);
	obuf->w.sub.done += scount * ibuf->bpf;
d1200 1
a1200 1
		dbg_puts(" fr\n");
d1209 1
a1209 1
sub_xrun(struct abuf *ibuf, struct abuf *i)
d1211 2
a1212 1
	unsigned fdrop;
d1220 1
a1220 1
	fdrop = ibuf->used / ibuf->bpf;
d1227 1
a1227 1
		dbg_putu(i->silence / i->bpf);
d1231 1
d1233 1
a1233 1
		i->silence += fdrop * i->bpf;
d1235 14
d1257 1
a1257 1
			i->duplex->silence += fdrop * i->duplex->bpf;
a1260 1
	i->w.sub.done += fdrop * ibuf->bpf;
d1275 2
a1276 1
		if (!ABUF_WOK(i)) {
d1278 1
a1278 1
				if (!sub_xrun(ibuf, i))
d1296 1
a1296 1
		p->u.sub.idle += idone / ibuf->bpf;
d1304 3
a1306 1
	p->u.sub.lat -= idone / ibuf->bpf;
d1317 1
a1317 1
	if (!ABUF_WOK(obuf))
d1324 1
d1337 3
a1339 1
	p->u.sub.lat -= idone / ibuf->bpf;
d1352 1
a1352 1
	struct abuf *i, *ibuf = LIST_FIRST(&p->ibuflist);
d1366 5
a1370 2
		LIST_FOREACH(i, &p->obuflist, oent) {
			if (ABUF_WOK(i) && i->w.sub.done < ibuf->used) {
d1399 1
d1413 1
a1413 1
		dbg_puts(" fr\n");
d1416 1
a1416 1
	if (p->u.sub.ctl)
d1435 1
a1435 1
sub_new(char *name, int maxlat, struct aproc *ctl)
d1442 1
d1444 1
d1452 2
a1453 1
	p->u.mix.lat = 0;
d1480 1
a1480 2
	ifr = icount / ibuf->bpf;
	icount = ifr * ibuf->bpf;
d1483 1
a1483 2
	ofr = ocount / obuf->bpf;
	ocount = ofr * obuf->bpf;
d1515 2
d1524 3
a1526 1
			if (--ifr == 0)
a1527 1
		} else {
d1536 1
a1536 2
			if (--ofr == 0)
				break;
d1556 2
a1557 2
	icount -= ifr * ibuf->bpf;
	ocount -= ofr * obuf->bpf;
a1679 1
	icount /= ibuf->bpf;
a1682 1
	ocount /= obuf->bpf;
d1713 2
a1714 2
	abuf_rdiscard(ibuf, scount * ibuf->bpf);
	abuf_wcommit(obuf, scount * obuf->bpf);
a1811 1
	icount /= ibuf->bpf;
a1814 1
	ocount /= obuf->bpf;
d1824 1
a1824 1
		dbg_puts(" fr * ");
d1860 2
a1861 2
	abuf_rdiscard(ibuf, scount * ibuf->bpf);
	abuf_wcommit(obuf, scount * obuf->bpf);
a1969 1
	icount /= ibuf->bpf;
a1972 1
	ocount /= obuf->bpf;
d1982 1
a1982 1
		dbg_puts(" fr * ");
d2018 2
a2019 2
	abuf_rdiscard(ibuf, scount * ibuf->bpf);
	abuf_wcommit(obuf, scount * obuf->bpf);
d2101 165
@


1.47
log
@fix quality degradation when resampling
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.46 2010/01/15 22:17:10 ratchov Exp $	*/
a1260 2
			if (ifr == 0)
				break;
d1268 2
a1269 1
			ifr--;
a1270 2
			if (ofr == 0)
				break;
d1279 2
a1280 1
			ofr--;
d1388 1
a1388 1
	p->u.resamp.diff = (iblksz >= oblksz) ? -oblksz : 0;
@


1.46
log
@Fix resampling algorithm to always produce integer block sizes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.45 2010/01/14 17:57:47 ratchov Exp $	*/
d1271 1
a1271 1
		} else if (diff > 0) {
a1282 12
		} else {
			if (ifr == 0 || ofr == 0)
				break;
			ctx_start ^= 1;
			ctx = ctxbuf + ctx_start;
			for (c = inch; c > 0; c--) {
				*ctx = *odata++ = *idata++;
				ctx += RESAMP_NCTX;
			}
			ifr--;
			ofr--;
			diff += oblksz - iblksz;
d1390 1
a1390 1
	p->u.resamp.diff = 0;
@


1.45
log
@Use a more accurate algorithm to calculate clock tick duration
when resampling is involved. Removes single sample jitter, which
could confuse programs expecting fixed block size.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.44 2010/01/12 21:42:59 ratchov Exp $	*/
d1250 3
a1252 1
		dbg_puts(": resamp starting ifr = ");
d1255 1
a1255 1
		dbg_puti(ofr);
d1271 1
a1271 1
		} else {
d1283 12
d1302 3
a1304 1
		dbg_puts(": resamp done ifr = ");
d1307 1
a1307 1
		dbg_puti(ofr);
@


1.44
log
@check for bogus clock ticks sent by the device; helps tracking
bugs in device drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.43 2010/01/11 13:06:32 ratchov Exp $	*/
d1347 4
a1350 8
	int ifac, ofac;

	ifac = p->u.resamp.iblksz;
	ofac = p->u.resamp.oblksz;
	ipos = p->u.resamp.idelta + (long long)delta * ofac;
	delta = (ipos + ifac - 1) / ifac;
	p->u.resamp.idelta = ipos - (long long)delta * ifac;
	abuf_ipos(obuf, delta);
a1357 1
	int ifac, ofac;
d1359 3
a1361 6
	ifac = p->u.resamp.iblksz;
	ofac = p->u.resamp.oblksz;
	opos = p->u.resamp.odelta + (long long)delta * ifac;
	delta = (opos + ofac - 1) / ofac;
	p->u.resamp.odelta = opos - (long long)delta * ofac;
	abuf_opos(ibuf, delta);
@


1.43
log
@When resuming from suspend, prime play buffers with silence,
otherwise the client would underrun by more than its own buffer
size, which currently is not allowed (causes the client to
deadlock).

Set the minimum client buffer size to two blocks. Single block
buffers don't work properly yet.

with help from jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.42 2010/01/10 21:47:41 ratchov Exp $	*/
a906 10
#ifdef DEBUG
	if (debug_level >= 3) {
		aproc_dbg(p);
		dbg_puts(": prime1: lat/maxlat=");
		dbg_puti(p->u.mix.lat);
		dbg_puts("/");
		dbg_puti(p->u.mix.maxlat);
		dbg_puts("\n");
	}
#endif
@


1.42
log
@Add traces to help tracking subtle timing bugs often causing
underuns and overruns; such bugs are hard to debug with ktrace
or a debugger. They are also handy to debug or monitor code
using aucat.

To enable traces, compile aucat with ``make DEBUG=-DDEBUG'' and
use the -d option multiple times.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.41 2010/01/05 10:18:12 ratchov Exp $	*/
d352 1
a352 1
	"rpipe",
d454 1
a454 1
	"wpipe",
d517 3
a519 1
		dbg_puts(": badd: todo = ");
a520 2
		dbg_puts("/");
		dbg_putu(ibuf->r.mix.done);
d636 3
a638 1
		dbg_puts(", todo = ");
a639 2
		dbg_puts("/");
		dbg_putu(ibuf->r.mix.done);
d899 43
@


1.41
log
@Make the way .wav files are handled closer to the way sockets are
handled, which is conceptually simpler. No behaviour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.40 2009/11/15 21:44:09 ratchov Exp $	*/
d47 23
d71 70
d165 6
d172 6
d191 7
d200 6
d487 8
d514 10
d564 12
d594 10
d610 6
d629 14
d673 14
d735 6
d770 8
d789 8
d803 10
d879 10
d934 8
d959 10
d974 6
d1074 6
d1103 8
d1120 10
d1214 10
d1252 10
d1367 10
d1424 8
d1496 10
d1540 10
d1658 8
d1700 10
d1818 8
@


1.40
log
@If two (or more) inputs use channel ranges having no intersection,
then don't reduce their dynamic range to ``share the volume''.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.39 2009/11/05 08:36:48 ratchov Exp $	*/
d160 1
a160 1
rpipe_in(struct aproc *p, struct abuf *ibuf_dummy)
d180 1
a180 1
rpipe_out(struct aproc *p, struct abuf *obuf)
d199 1
a199 1
rpipe_done(struct aproc *p)
d222 1
a222 1
rpipe_eof(struct aproc *p, struct abuf *ibuf_dummy)
d228 1
a228 1
rpipe_hup(struct aproc *p, struct abuf *obuf)
d233 1
a233 1
struct aproc_ops rpipe_ops = {
d235 4
a238 4
	rpipe_in,
	rpipe_out,
	rpipe_eof,
	rpipe_hup,
d243 1
a243 1
	rpipe_done
d247 1
a247 1
rpipe_new(struct file *f)
d251 1
a251 1
	p = aproc_new(&rpipe_ops, f->name);
d258 1
a258 1
wpipe_done(struct aproc *p)
d281 1
a281 1
wpipe_in(struct aproc *p, struct abuf *ibuf)
d300 1
a300 1
wpipe_out(struct aproc *p, struct abuf *obuf_dummy)
d324 1
a324 1
wpipe_eof(struct aproc *p, struct abuf *ibuf)
d330 1
a330 1
wpipe_hup(struct aproc *p, struct abuf *obuf_dummy)
d335 1
a335 1
struct aproc_ops wpipe_ops = {
d337 4
a340 4
	wpipe_in,
	wpipe_out,
	wpipe_eof,
	wpipe_hup,
d345 1
a345 1
	wpipe_done
d349 1
a349 1
wpipe_new(struct file *f)
d353 1
a353 1
	p = aproc_new(&wpipe_ops, f->name);
@


1.39
log
@in rpipe_done (wpipe_done), all buffers must be detached
before deleting the writer (reader) otherwise the later
could trigger rpipe_done again.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.38 2009/11/03 21:31:37 ratchov Exp $	*/
d628 1
a628 1
	struct abuf *buf;
d631 6
d638 11
a648 2
	LIST_FOREACH(buf, &p->ibuflist, ient) {
		n++;
d650 1
a650 1
	LIST_FOREACH(buf, &p->ibuflist, ient) {
d652 3
a654 3
		if (weight > buf->r.mix.maxweight)
			weight = buf->r.mix.maxweight;
		buf->r.mix.weight = weight;
@


1.38
log
@Allow any program using aucat to act as MMC slave and MTC master
transparently.  Multiple audio applications can be started
synchronously from external software/hardware supporting the
standard Start/Stop/Relocate messages. The server clock is exposed
through MTC, allowing non-audio software/hardware to be
synchronized to audio applications.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.37 2009/10/10 09:54:05 ratchov Exp $	*/
d202 1
d206 7
d261 1
d265 7
@


1.37
log
@We don't need independent file reader and writer anymore. So,
destroy reader when writer terminates and destroy writer when
reader terminates. This simplifies a lot the way we drain
audio devices and will help simplifying other parts.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.36 2009/10/09 16:49:48 ratchov Exp $	*/
d46 1
d62 1
a62 1
	p->zomb = 0;
d71 1
a71 1
	if (!p->zomb) {
d83 1
a83 1
		p->zomb = 1;
d487 1
a487 1
			if (p->u.mix.flags & MIX_DROP) {
d497 1
a497 1
		if (p->u.mix.flags & MIX_AUTOQUIT) {
d501 1
a501 1
		if (!(p->u.mix.flags & MIX_DROP))
d574 2
d593 1
a593 1
mix_new(char *name, int maxlat)
a597 1
	p->u.mix.flags = 0;
d601 1
d711 1
a711 1
			if (p->u.sub.flags & SUB_DROP) {
d723 1
a723 1
		if (p->u.sub.flags & SUB_AUTOQUIT) {
d727 1
a727 1
		if (!(p->u.sub.flags & SUB_DROP))
d817 2
d836 1
a836 1
sub_new(char *name, int maxlat)
a840 1
	p->u.sub.flags = 0;
d844 1
@


1.36
log
@Make abuf structure smaller:
 - put aproc-specific parameters into unions since they are never
   used together
 - remove constant ``data'' pointer always pointing the end of the
   abuf structure
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.35 2009/10/06 18:06:55 ratchov Exp $	*/
d204 4
a207 2
	f->rproc = NULL;
	if (f->wproc == NULL)
d255 4
a258 2
	f->wproc = NULL;
	if (f->rproc == NULL)
@


1.35
log
@prevent aproc structures to be deleted twice. Doesn't change anything
for now but will be used in future code.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.34 2009/09/27 11:51:20 ratchov Exp $	*/
d348 1
a348 1
	odata = (short *)abuf_wgetblk(obuf, &ocount, obuf->mixitodo);
d353 1
a353 1
	obuf->mixitodo += ocount;
d378 3
a380 3
	zcount = ibuf->mixodone + icount * obuf->bpf;
	if (zcount > obuf->mixitodo)
		mix_bzero(obuf, zcount - obuf->mixitodo);
d385 1
a385 1
	odata = (short *)abuf_wgetblk(obuf, &ocount, ibuf->mixodone);
d390 1
a390 1
	vol = (ibuf->mixweight * ibuf->mixvol) >> ADATA_SHIFT;
d405 1
a405 1
	ibuf->mixodone += scount * obuf->bpf;
d417 1
a417 1
	if (i->mixodone > 0)
d419 1
a419 1
	if (i->xrun == XRUN_ERROR) {
d424 3
a426 3
	fdrop = obuf->mixitodo / obuf->bpf;
	i->mixodone += fdrop * obuf->bpf;
	if (i->xrun == XRUN_SYNC)
d452 2
a453 2
		if (odone > i->mixodone)
			odone = i->mixodone;
d459 1
a459 1
		i->mixodone -= odone;
d462 1
a462 1
	obuf->mixitodo -= odone;
d488 2
a489 2
		if (odone > i->mixodone)
			odone = i->mixodone;
d499 1
a499 1
		odone = obuf->mixitodo;
d506 1
a506 1
		i->mixodone -= odone;
d509 1
a509 1
	obuf->mixitodo -= odone;
d527 1
a527 1
			if (ABUF_ROK(i) && i->mixodone < obuf->mixitodo) {
d531 2
a532 2
			if (odone > i->mixodone)
				odone = i->mixodone;
d537 1
a537 1
		if (LIST_EMPTY(&p->ibuflist) || odone == obuf->mixitodo)
d552 5
a556 5
	ibuf->mixodone = 0;
	ibuf->mixvol = ADATA_UNIT;
	ibuf->mixweight = ADATA_UNIT;
	ibuf->mixmaxweight = ADATA_UNIT;
	ibuf->xrun = XRUN_IGNORE;
d562 1
a562 1
	obuf->mixitodo = 0;
d614 3
a616 3
		if (weight > buf->mixmaxweight)
			weight = buf->mixmaxweight;
		buf->mixweight = weight;
d626 1
a626 1
	obuf->mixitodo = 0;
d639 1
a639 1
	idata = (short *)abuf_rgetblk(ibuf, &icount, obuf->subidone);
d661 1
a661 1
	obuf->subidone += scount * ibuf->bpf;
d672 1
a672 1
	if (i->subidone > 0)
d674 1
a674 1
	if (i->xrun == XRUN_ERROR) {
d679 1
a679 1
	if (i->xrun == XRUN_SYNC)
d688 1
a688 1
	i->subidone += fdrop * ibuf->bpf;
d710 2
a711 2
		if (idone > i->subidone)
			idone = i->subidone;
d728 1
a728 1
		i->subidone -= idone;
d750 2
a751 2
		if (idone > i->subidone)
			idone = i->subidone;
d758 1
a758 1
		i->subidone -= idone;
d783 1
a783 1
			if (ABUF_WOK(i) && i->subidone < ibuf->used) {
d787 2
a788 2
			if (idone > i->subidone)
				idone = i->subidone;
d802 2
a803 2
	obuf->subidone = 0;
	obuf->xrun = XRUN_IGNORE;
@


1.34
log
@remove all debug traces
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.33 2009/07/25 10:52:18 ratchov Exp $	*/
d61 1
d70 13
a82 7
	/*
	 * XXX: souldn't call ops->done() and friends twice
	 * use a ``zomb'' flag or whatever
	 */

	if (p->ops->done) {
		p->ops->done(p);
d84 2
a85 3
	while (!LIST_EMPTY(&p->ibuflist)) {
		i = LIST_FIRST(&p->ibuflist);
		abuf_hup(i);
a86 6
	while (!LIST_EMPTY(&p->obuflist)) {
		i = LIST_FIRST(&p->obuflist);
		abuf_eof(i);
	}
	if (p->refs > 0)
		return;
@


1.33
log
@fix comments, remove no longer needed declaration, reorder includes
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.32 2009/07/25 08:44:27 ratchov Exp $	*/
a35 9
 * TODO
 *
 * 	(easy) split the "conv" into 2 converters: one for input (that
 *	convers anything to 16bit signed) and one for the output (that
 *	converts 16bit signed to anything)
 *
 *	(hard) add a lowpass filter for the resampler. Quality is
 *	not acceptable as is.
 *
a37 2
#include <limits.h>
#include <stdio.h>
d47 1
d69 4
a72 1
	DPRINTF("aproc_del: %s(%s): terminating...\n", p->ops->name, p->name);
d74 1
a74 1
	if (p->ops->done)
d76 1
a76 1

d85 1
a85 2
	if (p->refs > 0) {
		DPRINTF("aproc_del: %s(%s): has refs\n", p->ops->name, p->name);
a86 2
	}
	DPRINTF("aproc_del: %s(%s): freed\n", p->ops->name, p->name);
a112 2
	DPRINTFN(3, "aproc_ipos: %s: delta = %d\n", p->name, delta);

a122 2
	DPRINTFN(3, "aproc_opos: %s: delta = %d\n", p->name, delta);

a140 1
	DPRINTFN(3, "aproc_inuse: %s: not inuse\n", p->name);
a165 2
	DPRINTFN(3, "rpipe_in: %s\n", p->name);

a186 2
	DPRINTFN(3, "rpipe_out: %s\n", p->name);

a212 1
	DPRINTFN(3, "rpipe_eof: %s\n", p->name);
a218 1
	DPRINTFN(3, "rpipe_hup: %s\n", p->name);
a267 2
	DPRINTFN(3, "wpipe_in: %s\n", p->name);

d286 1
a286 4
	DPRINTFN(3, "wpipe_out: %s\n", p->name);

	if (!abuf_fill(ibuf)) {
		DPRINTFN(3, "wpipe_out: fill failed\n");
a287 1
	}
d292 1
a292 1
		DPRINTF("wpipe_out: %s: underrun\n", p->name);
a304 1
	DPRINTFN(3, "wpipe_eof: %s\n", p->name);
a310 1
	DPRINTFN(3, "wpipe_hup: %s\n", p->name);
a347 1
	DPRINTFN(4, "mix_bzero: used = %u, zcount = %u\n", obuf->used, zcount);
a366 3
	DPRINTFN(4, "mix_badd: todo = %u, done = %u\n",
	    obuf->mixitodo, ibuf->mixodone);

a406 2
	DPRINTFN(4, "mix_badd: added %u, done = %u, todo = %u\n",
	    scount, ibuf->mixodone, obuf->mixitodo);
a430 1
			DPRINTF("mix_xrun: duplex %u\n", fdrop);
a434 1
	DPRINTF("mix_xrun: drop = %u\n", i->drop);
a443 3
	DPRINTFN(4, "mix_in: used/len = %u/%u, done/todo = %u/%u\n",
	    ibuf->used, ibuf->len, ibuf->mixodone, obuf->mixitodo);

a473 3
	DPRINTFN(4, "mix_out: used/len = %u/%u, todo/len = %u/%u\n",
	    obuf->used, obuf->len, obuf->mixitodo, obuf->len);

a492 1
			DPRINTF("mix_out: nothing more to do...\n");
a518 1
	DPRINTF("mix_eof: %s: detached\n", p->name);
a521 1
		DPRINTF("mix_eof: %s: from input\n", p->name);
a544 1
	DPRINTF("mix_hup: %s: done\n", p->name);
a550 6
	struct abuf *obuf = LIST_FIRST(&p->obuflist);

	if (!obuf || ibuf->cmin < obuf->cmin || ibuf->cmax > obuf->cmax) {
		fprintf(stderr, "mix_newin: channel ranges mismatch\n");
		abort();
	}
a561 1
	DPRINTF("mix_newout: using %u fpb\n", obuf->len / obuf->bpf);
a567 1
	DPRINTFN(3, "mix_opos: lat = %d/%d\n", p->u.mix.lat, p->u.mix.maxlat);
a616 2
		DPRINTF("mix_setmaster: %p: %d/%d -> %d\n", buf,
		    buf->mixweight, buf->mixmaxweight, weight);
a661 1
	DPRINTFN(4, "sub_bcopy: %u frames\n", scount);
a683 1
			DPRINTF("sub_xrun: duplex %u\n", fdrop);
a688 1
	DPRINTF("sub_xrun: silence = %u\n", i->silence);
a716 1
			DPRINTF("sub_in: nothing more to do...\n");
a767 1
	DPRINTF("sub_hup: %s: eof\n", p->name);
a776 2
	DPRINTF("sub_hup: %s: detached\n", p->name);

a777 1
		DPRINTF("sub_hup: %s: from input\n", p->name);
a800 6
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);

	if (!ibuf || obuf->cmin < ibuf->cmin || obuf->cmax > ibuf->cmax) {
		fprintf(stderr, "sub_newout: channel ranges mismatch\n");
		abort();
	}
a809 1
	DPRINTFN(3, "sub_ipos: lat = %d/%d\n", p->u.sub.lat, p->u.sub.maxlat);
a891 1
	DPRINTFN(4, "resamp_bcopy: ifr=%d ofr=%d\n", ifr, ofr);
a919 2
	DPRINTFN(4, "resamp_bcopy: done, ifr=%d ofr=%d\n", ifr, ofr);

a933 2
	DPRINTFN(4, "resamp_in: %s\n", p->name);

a946 2
	DPRINTFN(4, "resamp_out: %s\n", p->name);

a957 2
	DPRINTFN(4, "resamp_eof: %s\n", p->name);

a963 2
	DPRINTFN(4, "resamp_hup: %s\n", p->name);

a973 2
	DPRINTFN(3, "resamp_ipos: %d\n", delta);

a988 2
	DPRINTFN(3, "resamp_opos: %d\n", delta);

a1024 4
#ifdef DEBUG
	if (debug_level > 0)
		fprintf(stderr, "resamp_new: %u/%u\n", iblksz, oblksz);
#endif
a1071 1
	DPRINTFN(4, "cmap_bcopy: scount = %u\n", scount);
a1080 2
	DPRINTFN(4, "cmap_in: %s\n", p->name);

a1093 2
	DPRINTFN(4, "cmap_out: %s\n", p->name);

a1104 2
	DPRINTFN(4, "cmap_eof: %s\n", p->name);

a1110 2
	DPRINTFN(4, "cmap_hup: %s\n", p->name);

a1135 7
#ifdef DEBUG
	if (debug_level > 0) {
		fprintf(stderr, "cmap_new: %s: ", p->name);
		aparams_print2(ipar, opar);
		fprintf(stderr, "\n");
	}
#endif
a1169 2
	DPRINTFN(4, "enc_bcopy: scount = %u, nch = %u\n", scount, nch);

a1209 2
	DPRINTFN(4, "enc_in: %s\n", p->name);

a1222 2
	DPRINTFN(4, "enc_out: %s\n", p->name);

a1233 2
	DPRINTFN(4, "enc_eof: %s\n", p->name);

a1239 2
	DPRINTFN(4, "enc_hup: %s\n", p->name);

a1277 7
#ifdef DEBUG
	if (debug_level > 0) {
		fprintf(stderr, "enc_new: %s: ", p->name);
		aparams_print(par);
		fprintf(stderr, "\n");
	}
#endif
a1311 2
	DPRINTFN(4, "dec_bcopy: scount = %u, nch = %u\n", scount, nch);

a1351 2
	DPRINTFN(4, "dec_in: %s\n", p->name);

a1364 2
	DPRINTFN(4, "dec_out: %s\n", p->name);

a1375 2
	DPRINTFN(4, "dec_eof: %s\n", p->name);

a1381 2
	DPRINTFN(4, "dec_hup: %s\n", p->name);

a1419 7
#ifdef DEBUG
	if (debug_level > 0) {
		fprintf(stderr, "dec_new: %s: ", p->name);
		aparams_print(par);
		fprintf(stderr, "\n");
	}
#endif
@


1.32
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.31 2009/01/23 17:38:15 ratchov Exp $	*/
d52 1
a52 1
#include "conf.h"
a53 1
#include "abuf.h"
d55 1
d369 1
a369 1
 * space), and crank mixitodo accordingly
d401 1
a401 1
	 * calculate the maximum we can read
d409 1
a409 1
	 * zero-fill if necessary
d416 1
a416 1
	 * calculate the maximum we can write
d569 1
a569 1
		 * find a blocked input
d581 1
a581 1
		 * no blocked inputs, check if output is blocked
d654 1
a654 1
 * Normalize input levels
d723 1
a723 1
 * Handle buffer overruns, return 0 if the stream died
d844 1
a844 1
		 * find a blocked output
d856 1
a856 1
		 * no blocked outputs, check if input is blocked
@


1.31
log
@spacing + typo fix from Matt Jibson <matt.jibson(at)gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.30 2008/12/29 17:59:08 ratchov Exp $	*/
d160 14
d202 1
a202 1
	if (f->refs > 0)
d287 1
a287 1
	if (f->refs > 0)
@


1.30
log
@make the code "more correct": add reference counters to aproc
structures so we can keep a pointer to the device. Beside some
simplifications, this allows to easily handle the situation
where the audio device desappears. No change in the behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.29 2008/12/27 17:02:13 ratchov Exp $	*/
d191 1
a191 1
	
d249 1
a249 1
	f->rproc = p;	
d298 1
a298 1
		DPRINTFN(3, "wpipe_out: fill failed\n");       
d410 1
a410 1
	ostart = ibuf->cmin - obuf->cmin; 
d437 1
a437 1
	
d469 1
a469 1
		
d504 1
a504 1
		return 0;	
d703 1
a703 1
	abuf_wcommit(obuf, scount * obuf->bpf);	
d743 1
a743 1
	
d919 1
a919 1
	short *ctxbuf, *ctx;	
d1039 1
a1039 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);	
d1542 1
a1542 1
		fprintf(stderr, "dec_new: %s: ", p->name);		
@


1.29
log
@fix a bug in resampling code, resulting in joined stereo and/or
high frequency attenuation, intruduced in aproc.c rev 1.27.
Hints from Alf Schlichting <a.schlichting(at)lemarit.com>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.28 2008/12/27 16:10:39 ratchov Exp $	*/
d70 1
d92 4
d207 2
d212 1
d258 2
d263 1
@


1.28
log
@simplify the mixer and the demultiplexer code; no change in the
behaviour. This also, fixes incorrect constructs that are currently
harmless
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.27 2008/12/19 08:01:06 ratchov Exp $	*/
d947 1
a947 2
				*ctx = *idata;
				idata++;
d957 2
a958 2
				s1 = ctxbuf[ctx_start];
				s2 = ctxbuf[ctx_start ^ 1];
@


1.27
log
@use simple linear interpolation in the resampling code.
This partially removes the ``metallic'' noise audible
especially when upsampling 8k -> 44.1k.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.26 2008/12/07 17:10:41 ratchov Exp $	*/
d138 17
d343 2
a344 1
 * Fill an output block with silence.
d347 1
a347 1
mix_bzero(struct aproc *p)
a348 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
d352 1
a352 2
	DPRINTFN(4, "mix_bzero: used = %u, todo = %u\n",
	    obuf->used, obuf->mixitodo);
d355 2
a356 2
	if (ocount == 0)
		return;
a358 1
	DPRINTFN(4, "mix_bzero: ocount %u, todo %u\n", ocount, obuf->mixitodo);
d369 1
a369 1
	unsigned scount, icount, ocount;
d375 3
d383 10
d419 31
d454 1
a454 1
	unsigned ocount;
d456 2
a457 2
	DPRINTFN(4, "mix_in: used = %u, done = %u, todo = %u\n",
	    ibuf->used, ibuf->mixodone, obuf->mixitodo);
d459 1
a459 1
	if (!ABUF_ROK(ibuf) || ibuf->mixodone == obuf->mixitodo)
d461 12
a472 3

	mix_badd(ibuf, obuf);
	ocount = obuf->mixitodo;
d474 1
a474 2
		if (ocount > i->mixodone)
			ocount = i->mixodone;
d476 2
a477 6
	if (ocount == 0)
		return 0;

	abuf_wcommit(obuf, ocount);
	p->u.mix.lat += ocount / obuf->bpf;
	obuf->mixitodo -= ocount;
a479 11
	mix_bzero(p);
	for (i = LIST_FIRST(&p->ibuflist); i != NULL; i = inext) {
		inext = LIST_NEXT(i, ient);
		i->mixodone -= ocount;
		if (i->mixodone < obuf->mixitodo)
			mix_badd(i, obuf);
		if (!abuf_fill(i))
			continue;
	}
	if (LIST_EMPTY(&p->ibuflist))
		p->u.mix.idle += ocount / obuf->bpf;
d487 1
a487 1
	unsigned ocount, fdrop;
d489 2
a490 2
	DPRINTFN(4, "mix_out: used = %u, todo = %u\n",
	    obuf->used, obuf->mixitodo);
d493 2
a494 4
		return 0;

	mix_bzero(p);
	ocount = obuf->mixitodo;
d498 1
a498 1
			continue;
d500 2
a501 3
			if ((p->u.mix.flags & MIX_DROP) && i->mixodone == 0) {
				if (i->xrun == XRUN_ERROR) {
					abuf_hup(i);
a502 17
				}
				fdrop = obuf->mixitodo / obuf->bpf;
				i->mixodone += fdrop * obuf->bpf;
				if (i->xrun == XRUN_SYNC)
					i->drop += fdrop * i->bpf;
				else {
					abuf_opos(i, -(int)fdrop);
					if (i->duplex) {
						DPRINTF("mix_out: duplex %u\n",
						    fdrop);
						i->duplex->drop += fdrop * 
						    i->duplex->bpf;
						abuf_ipos(i->duplex,
						    -(int)fdrop);
					}
				}
				DPRINTF("mix_out: drop = %u\n", i->drop);
d506 14
a519 2
		if (ocount > i->mixodone)
			ocount = i->mixodone;
d521 1
a521 1
	if (ocount == 0)
d523 1
a523 8
	if (LIST_EMPTY(&p->ibuflist) && (p->u.mix.flags & MIX_AUTOQUIT)) {
		DPRINTF("mix_out: nothing more to do...\n");
		aproc_del(p);
		return 0;
	}
	abuf_wcommit(obuf, ocount);
	p->u.mix.lat += ocount / obuf->bpf;
	obuf->mixitodo -= ocount;
d525 1
a525 1
		i->mixodone -= ocount;
d527 2
a528 2
	if (LIST_EMPTY(&p->ibuflist))
		p->u.mix.idle += ocount / obuf->bpf;
d535 2
a536 1
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
d541 20
a560 6
	/*
	 * If there's no more inputs, abuf_run() will trigger the eof
	 * condition and propagate it, so no need to handle it here.
	 */
	abuf_run(obuf);
	DPRINTF("mix_eof: done\n");
a565 6
	struct abuf *ibuf;

	while (!LIST_EMPTY(&p->ibuflist)) {
		ibuf = LIST_FIRST(&p->ibuflist);
		abuf_hup(ibuf);
	}
a591 1
	mix_bzero(p);
a627 12
void
mix_pushzero(struct aproc *p)
{
	struct abuf *obuf = LIST_FIRST(&p->obuflist);

	abuf_wcommit(obuf, obuf->mixitodo);
	p->u.mix.lat += obuf->mixitodo / obuf->bpf;
	obuf->mixitodo = 0;
	abuf_run(obuf);
	mix_bzero(p);
}

a658 1
	mix_bzero(p);
d697 30
d731 1
a731 1
	unsigned done, fdrop;
d735 1
a735 1
	done = ibuf->used;
d739 2
a740 3
			if ((p->u.sub.flags & SUB_DROP) && i->subidone == 0) {
				if (i->xrun == XRUN_ERROR) {
					abuf_eof(i);
a741 17
				}
				fdrop = ibuf->used / ibuf->bpf;
				if (i->xrun == XRUN_SYNC)
					i->silence += fdrop * i->bpf;
				else {
					abuf_ipos(i, -(int)fdrop);
					if (i->duplex) {
						DPRINTF("sub_in: duplex %u\n",
						    fdrop);
						i->duplex->silence += fdrop *
						    i->duplex->bpf;
						abuf_opos(i->duplex, 
						    -(int)fdrop);
					}
				}
				i->subidone += fdrop * ibuf->bpf;
				DPRINTF("sub_in: silence = %u\n", i->silence);
d745 2
a746 2
		if (done > i->subidone)
			done = i->subidone;
d750 13
d764 1
a764 1
		i->subidone -= done;
d766 2
a767 4
	abuf_rdiscard(ibuf, done);
	p->u.sub.lat -= done / ibuf->bpf;
	if (LIST_EMPTY(&p->obuflist))
		p->u.sub.idle += done / ibuf->bpf;
d776 1
a776 1
	unsigned done;
d780 3
a782 7
	if (!abuf_fill(ibuf)) {
		return 0;
	}
	if (obuf->subidone == ibuf->used)
		return 0;

	done = ibuf->used;
d785 3
a789 3
		sub_bcopy(ibuf, i);
		if (done > i->subidone)
			done = i->subidone;
d791 2
d794 1
a794 1
		i->subidone -= done;
d796 2
a797 4
	abuf_rdiscard(ibuf, done);
	p->u.sub.lat -= done / ibuf->bpf;
	if (LIST_EMPTY(&p->obuflist))
		p->u.sub.idle += done / ibuf->bpf;
d804 1
a804 6
	struct abuf *obuf;

	while (!LIST_EMPTY(&p->obuflist)) {
		obuf = LIST_FIRST(&p->obuflist);
		abuf_eof(obuf);
	}
d811 2
a812 1
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
d815 21
a835 2
	abuf_run(ibuf);
	DPRINTF("sub_hup: done\n");
@


1.26
log
@When resampling, don't require the sample frequency to be an integer.
This removes the arithmetic constraint between the sample frequency
and the block size and all the associated code. Now aucat can work
in server mode with any block size.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.25 2008/11/16 17:08:32 ratchov Exp $	*/
d834 1
a834 1
	unsigned ipos, oblksz;
d837 1
d839 1
a839 1
	unsigned opos, iblksz;
d842 2
a843 1
	short *ctxbuf, *ctx;
d862 1
a863 1
	ipos = p->u.resamp.ipos;
a865 1
	opos = p->u.resamp.opos;
d868 1
d875 1
a875 12
		if ((int)(ipos - opos) > 0) {
			if (ofr == 0)
				break;
			ctx = ctxbuf;
			for (c = onch; c > 0; c--) {
				*odata = *ctx;
				odata++;
				ctx++;
			}
			opos += iblksz;
			ofr--;
		} else {
d878 2
a879 1
			ctx = ctxbuf;
d883 1
a883 1
				ctx++;
d885 1
a885 1
			ipos += oblksz;
d887 12
d901 2
a902 2
	p->u.resamp.ipos = ipos;
	p->u.resamp.opos = opos;
d1016 1
a1016 2
	p->u.resamp.ipos = 0;
	p->u.resamp.opos = 0;
d1019 2
a1020 1
	for (i = 0; i < NCHAN_MAX; i++)
@


1.25
log
@make aucat compile without DEBUG defined (still defined by default)
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.24 2008/11/16 16:30:22 ratchov Exp $	*/
d834 1
a834 1
	unsigned ipos, orate;
d838 1
a838 1
	unsigned opos, irate;
d862 1
a862 1
	irate = p->u.resamp.irate;
d865 1
a865 1
	orate = p->u.resamp.orate;
d882 1
a882 1
			opos += irate;
d893 1
a893 1
			ipos += orate;
d965 2
a966 2
	ifac = p->u.resamp.irate;
	ofac = p->u.resamp.orate;
d982 2
a983 2
	ifac = p->u.resamp.irate;
	ofac = p->u.resamp.orate;
d1004 1
a1004 1
resamp_new(char *name, struct aparams *ipar, struct aparams *opar)
d1010 2
a1011 2
	p->u.resamp.irate = ipar->rate;
	p->u.resamp.orate = opar->rate;
d1019 2
a1020 5
	if (debug_level > 0) {
		fprintf(stderr, "resamp_new: %s: ", p->name);
		aparams_print2(ipar, opar);
		fprintf(stderr, "\n");
	}
@


1.24
log
@Make clients inherit the volume parameter when the -v option is used in
server mode. It gives the maximum volume a client may have. This wastes
dynamic range, but allows volume to stay constant when other clients
connect or disconnect.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.23 2008/11/10 23:25:37 ratchov Exp $	*/
d1018 1
d1020 1
a1020 1
		DPRINTF("resamp_new: %s: ", p->name);
d1022 1
a1022 1
		DPRINTF("\n");
d1024 1
d1145 1
d1147 1
a1147 1
		DPRINTF("cmap_new: %s: ", p->name);
d1149 1
a1149 1
		DPRINTF("\n");
d1151 1
d1304 1
d1310 1
d1463 1
d1469 1
@


1.23
log
@add a per-stream ``soft volume'' knob and the corresponding -v option.
The code will be useful later for the volume knob in the sndio API.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.22 2008/11/09 16:26:07 ratchov Exp $	*/
d537 1
a538 1
	mix_setmaster(p);
d603 1
d606 11
a616 4
	LIST_FOREACH(buf, &p->ibuflist, ient)
	    n++;
	LIST_FOREACH(buf, &p->ibuflist, ient)
	    buf->mixweight = ADATA_UNIT / n;
@


1.22
log
@make aucat(1) stop automatically the audio(1) device if it's idle. This
way, when in server mode, it consumes no CPU if there are no clients.
Later, this will allow to start aucat(1) at session or system startup.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.21 2008/11/07 21:01:15 ratchov Exp $	*/
a352 1
	int vol = ibuf->mixivol;
d355 1
d370 1
d535 2
a536 1
	ibuf->mixivol = ADATA_UNIT;
d608 1
a608 1
	    buf->mixivol = ADATA_UNIT / n;
@


1.21
log
@expose the block size in the sndio API by making par->round writable
and thus remove the ugly rate <-> block-size table from
sio_setpar(3). Handle the block size negociation in aucat(1), since
it has few constrains the code is overally simpler.
ok jakemsr@@, major crank suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.20 2008/11/06 17:47:52 ratchov Exp $	*/
d425 2
d489 2
d532 1
d575 1
d609 10
d701 2
d735 2
d771 1
d804 1
d808 6
@


1.20
log
@drop/silence calculation is wrong when xrun occurs and client and
device number of channels are not the same. The bug was hidden until
now, because mixer and demux input and outputs used to have the same
frame size.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.19 2008/11/04 22:18:12 ratchov Exp $	*/
d537 1
@


1.19
log
@split code that converts any->any in two parts: one to encode
native->any and one to decode any->native. It is simpler and
faster this way.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.18 2008/11/04 18:24:06 ratchov Exp $	*/
d432 1
a432 1
	unsigned ocount, drop;
d452 2
a453 2
				drop = obuf->mixitodo;
				i->mixodone += drop;
d455 1
a455 1
					i->drop += drop;
d457 1
a457 1
					abuf_opos(i, -(int)(drop / i->bpf));
d460 3
a462 3
						    drop);
						i->duplex->drop += drop * 
						    i->duplex->bpf / i->bpf;
d464 1
a464 1
						    -(int)(drop / i->bpf));
d642 1
a642 1
	unsigned done, drop;
d655 1
a655 1
				drop = ibuf->used;
d657 1
a657 1
					i->silence += drop;
d659 1
a659 1
					abuf_ipos(i, -(int)(drop / i->bpf));
d662 3
a664 3
						    drop);
						i->duplex->silence += drop *
						    i->duplex->bpf / i->bpf;
d666 1
a666 1
						    -(int)(drop / i->bpf));
d669 1
a669 1
				i->subidone += drop;
@


1.18
log
@cleanup: remove channel mapping bits from encoding conversion code.
As a side effect, reduce CPU usage by ~10% on envy(4) devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.17 2008/11/04 17:51:46 ratchov Exp $	*/
a790 198
conv_bcopy(struct aconv *ist, struct aconv *ost,
    struct abuf *ibuf, struct abuf *obuf)
{
	unsigned nch, ibps;
	unsigned char *idata;
	int ibnext;
	unsigned i;
	int s;
	unsigned obps;
	unsigned char *odata;
	int obnext;
	int isigbit;
	unsigned ishift;
	unsigned oshift;
	int osigbit;
	int isnext;
	int osnext;
	unsigned f, scount, icount, ocount;

	/*
	 * It's ok to have s uninitialized, but we dont want the compiler to
	 * complain about it.
	 */
	s = (int)0xdeadbeef;

	/*
	 * Calculate max frames readable at once from the input buffer.
	 */
	idata = abuf_rgetblk(ibuf, &icount, 0);
	icount /= ibuf->bpf;
	if (icount == 0)
		return;
	odata = abuf_wgetblk(obuf, &ocount, 0);
	ocount /= obuf->bpf;
	if (ocount == 0)
		return;
	scount = (icount < ocount) ? icount : ocount;
	nch = ibuf->cmax - ibuf->cmin + 1;
	DPRINTFN(4, "conv_bcopy: scount = %u, nch = %u\n", scount, nch);

	/*
	 * Partially copy structures into local variables, to avoid
	 * unnecessary indirections; this also allows the compiler to
	 * order local variables more "cache-friendly".
	 */
	ibps = ist->bps;
	ibnext = ist->bnext;
	isigbit = ist->sigbit;
	ishift = ist->shift;
	isnext = ist->snext;
	oshift = ost->shift;
	osigbit = ost->sigbit;
	obps = ost->bps;
	obnext = ost->bnext;
	osnext = ost->snext;

	/*
	 * Start conversion.
	 */
	idata += ist->bfirst;
	odata += ost->bfirst;
	for (f = scount * nch; f > 0; f--) {
		for (i = ibps; i > 0; i--) {
			s <<= 8;
			s |= *idata;
			idata += ibnext;
		}
		s ^= isigbit;
		s <<= ishift;
		s >>= 16;

		/* XXX: don't simplify, useful to split conv */
		
		s <<= 16;
		s >>= oshift;
		s ^= osigbit;
		for (i = obps; i > 0; i--) {
			*odata = (unsigned char)s;
			s >>= 8;
			odata += obnext;
		}
		idata += isnext;
		odata += osnext;
	}

	/*
	 * Update FIFO pointers.
	 */
	abuf_rdiscard(ibuf, scount * ibuf->bpf);
	abuf_wcommit(obuf, scount * obuf->bpf);
}

int
conv_in(struct aproc *p, struct abuf *ibuf)
{
	struct abuf *obuf = LIST_FIRST(&p->obuflist);

	DPRINTFN(4, "conv_in: %s\n", p->name);

	if (!ABUF_WOK(obuf) || !ABUF_ROK(ibuf))
		return 0;
	conv_bcopy(&p->u.conv.ist, &p->u.conv.ost, ibuf, obuf);
	if (!abuf_flush(obuf))
		return 0;
	return 1;
}

int
conv_out(struct aproc *p, struct abuf *obuf)
{
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);

	DPRINTFN(4, "conv_out: %s\n", p->name);

	if (!abuf_fill(ibuf))
		return 0;
	if (!ABUF_WOK(obuf) || !ABUF_ROK(ibuf))
		return 0;
	conv_bcopy(&p->u.conv.ist, &p->u.conv.ost, ibuf, obuf);
	return 1;
}

void
conv_eof(struct aproc *p, struct abuf *ibuf)
{
	DPRINTFN(4, "conv_eof: %s\n", p->name);

	aproc_del(p);
}

void
conv_hup(struct aproc *p, struct abuf *obuf)
{
	DPRINTFN(4, "conv_hup: %s\n", p->name);

	aproc_del(p);
}

void
aconv_init(struct aconv *st, struct aparams *par, int input)
{
	st->bps = par->bps;
	st->sigbit = par->sig ? 0 : 1 << (par->bits - 1);
	if (par->msb) {
		st->shift = 32 - par->bps * 8;
	} else {
		st->shift = 32 - par->bits;
	}
	if ((par->le && input) || (!par->le && !input)) {
		st->bfirst = st->bps - 1;
		st->bnext = -1;
		st->snext = 2 * st->bps;
	} else {
		st->bfirst = 0;
		st->bnext = 1;
		st->snext = 0;
	}
}

struct aproc_ops conv_ops = {
	"conv",
	conv_in,
	conv_out,
	conv_eof,
	conv_hup,
	NULL,
	NULL,
	NULL, /* ipos */
	NULL, /* opos */
	NULL
};

struct aproc *
conv_new(char *name, struct aparams *ipar, struct aparams *opar)
{
	struct aproc *p;

	if (ipar->cmax - ipar->cmin != opar->cmax - opar->cmin) {
		fprintf(stderr, "conv_new: channel count mismatch\n");
		abort();
	}
	p = aproc_new(&conv_ops, name);
	aconv_init(&p->u.conv.ist, ipar, 1);
	aconv_init(&p->u.conv.ost, opar, 0);
	p->u.conv.idelta = 0;
	p->u.conv.odelta = 0;
	if (debug_level > 0) {
		DPRINTF("conv_new: %s: ", p->name);		
		aparams_print2(ipar, opar);
		DPRINTF("\n");
	}
	return p;
}

/*
 * Convert one block.
 */
void
d1090 2
a1091 2
	NULL,
	NULL,
d1108 314
@


1.17
log
@add "new" conversion code to map any channel range into any other
channel range (based on the encoding conversion code). Will allow to
unentangle channel mapping from encoding conversion. As a side effect,
greatly reduces CPU usage for channel mapping. No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.16 2008/11/04 15:22:40 ratchov Exp $	*/
d794 1
a794 1
	unsigned inch, ibps;
d796 7
a802 1
	int ibnext, isigbit;
d804 2
d807 2
a808 8
	unsigned onch, oshift;
	int osigbit;
	unsigned obps;
	unsigned char *odata;
	int obnext, osnext;
	unsigned c, i, f;
	int ctxbuf[NCHAN_MAX], *ctx, s;
	unsigned icount, ocount, scount;
d828 2
a829 1
	DPRINTFN(4, "conv_bcopy: scount=%u\n", scount);
a835 1
	inch = ist->nch;
a840 1
	onch = ost->nch;
d852 5
a856 12
	for (f = scount; f > 0; f--) {
		ctx = ctxbuf;
		for (c = inch; c > 0; c--) {
			for (i = ibps; i > 0; i--) {
				s <<= 8;
				s |= *idata;
				idata += ibnext;
			}
			s ^= isigbit;
			s <<= ishift;
			*ctx++ = (short)(s >> 16);
			idata += isnext;
d858 13
a870 11
		ctx = ctxbuf;
		for (c = onch; c > 0; c--) {
			s = *ctx++ << 16;
			s >>= oshift;
			s ^= osigbit;
			for (i = obps; i > 0; i--) {
				*odata = (unsigned char)s;
				s >>= 8;
				odata += obnext;
			}
			odata += osnext;
d872 2
a947 3
	st->cmin = par->cmin;
	st->nch = par->cmax - par->cmin + 1;
	st->bpf = st->nch * st->bps;
d968 4
@


1.16
log
@cleanup: resample stream while in native format and remove resampling
bits from the encoding conversion code. As a side effect this reduces
CPU usage by 30% on envy(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.15 2008/11/04 14:16:09 ratchov Exp $	*/
d1180 125
@


1.15
log
@optimization: add "new" resampling code (actually based on the existing
conversion bits) and use it when resampling only is required (ie for
clients using s16 encoding), this is the most common case. Reduces CPU
usage by ~50%. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.14 2008/11/03 22:55:34 ratchov Exp $	*/
a793 1
	int *ictx;
a798 3
	unsigned ipos, orate;
	unsigned ifr;
	int *octx;
d804 3
a806 5
	unsigned opos, irate;
	unsigned ofr;
	unsigned c, i;
	int s, *ctx;
	unsigned icount, ocount;
d818 3
a820 3
	ifr = icount / ibuf->bpf;
	icount = ifr * ibuf->bpf;

d822 5
a826 2
	ofr = ocount / obuf->bpf;
	ocount = ofr * obuf->bpf;
a832 2
	ictx = ist->ctx + ist->cmin;
	octx = ist->ctx + ost->cmin;
a838 2
	ipos = ist->pos;
	irate = ist->rate;
a844 2
	opos = ost->pos;
	orate = ost->rate;
d851 7
a857 16
	DPRINTFN(4, "conv_bcopy: ifr=%d ofr=%d\n", ifr, ofr);
	for (;;) {
		if ((int)(ipos - opos) > 0) {
			if (ofr == 0)
				break;
			ctx = octx;
			for (c = onch; c > 0; c--) {
				s = *ctx++ << 16;
				s >>= oshift;
				s ^= osigbit;
				for (i = obps; i > 0; i--) {
					*odata = (unsigned char)s;
					s >>= 8;
					odata += obnext;
				}
				odata += osnext;
d859 14
a872 16
			opos += irate;
			ofr--;
		} else {
			if (ifr == 0)
				break;
			ctx = ictx;
			for (c = inch; c > 0; c--) {
				for (i = ibps; i > 0; i--) {
					s <<= 8;
					s |= *idata;
					idata += ibnext;
				}
				s ^= isigbit;
				s <<= ishift;
				*ctx++ = (short)(s >> 16);
				idata += isnext;
d874 1
a874 2
			ipos += orate;
			ifr--;
a876 3
	ist->pos = ipos;
	ost->pos = opos;
	DPRINTFN(4, "conv_bcopy: done, ifr=%d ofr=%d\n", ifr, ofr);
d881 2
a882 4
	icount -= ifr * ist->bpf;
	ocount -= ofr * ost->bpf;
	abuf_rdiscard(ibuf, icount);
	abuf_wcommit(obuf, ocount);
a933 2
	unsigned i;

a952 39
	st->rate = par->rate;
	st->pos = 0;

	for (i = 0; i < NCHAN_MAX; i++)
		st->ctx[i] = 0;
}

void
conv_ipos(struct aproc *p, struct abuf *ibuf, int delta)
{
	struct abuf *obuf = LIST_FIRST(&p->obuflist);	
	long long ipos;
	int ifac, ofac;

	DPRINTFN(3, "conv_ipos: %d\n", delta);

	ifac = p->u.conv.ist.rate;
	ofac = p->u.conv.ost.rate;
	ipos = p->u.conv.idelta + (long long)delta * ofac;
	delta = (ipos + ifac - 1) / ifac;
	p->u.conv.idelta = ipos - (long long)delta * ifac;
	abuf_ipos(obuf, delta);
}

void
conv_opos(struct aproc *p, struct abuf *obuf, int delta)
{
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
	long long opos;
	int ifac, ofac;

	DPRINTFN(3, "conv_opos: %d\n", delta);

	ifac = p->u.conv.ist.rate;
	ofac = p->u.conv.ost.rate;
	opos = p->u.conv.odelta + (long long)delta * ifac;
	delta = (opos + ofac - 1) / ofac;
	p->u.conv.odelta = opos - (long long)delta * ofac;
	abuf_opos(ibuf, delta);
d963 2
a964 2
	conv_ipos,
	conv_opos,
d1167 1
d1176 2
@


1.14
log
@rename mixxxx and subxxx fields of struct abuf to avoid confusion:
Add ``i'' to offsets in the input buffer and ``o'' to offsets
in the output buffer. This is necessary because input and output
use no more the same frame size.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.13 2008/11/03 22:25:13 ratchov Exp $	*/
d34 2
d1047 197
@


1.13
log
@A small optimization: handle most N-channel <-> M-channel conversions
inside the mixer and the demultiplexer. This way, aucat will not
trigger the heavy conversion code when only channel conversions are
required. Cuts ~50% of the CPU usage on envy(4) devices, can improve
surround 4.0, 5.1 and 7.1 capable devices. No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.12 2008/10/26 08:49:43 ratchov Exp $	*/
d334 2
a335 2
	    obuf->used, obuf->mixtodo);
	odata = (short *)abuf_wgetblk(obuf, &ocount, obuf->mixtodo);
d340 2
a341 2
	obuf->mixtodo += ocount;
	DPRINTFN(4, "mix_bzero: ocount %u, todo %u\n", ocount, obuf->mixtodo);
d351 1
a351 1
	int vol = ibuf->mixvol;
d356 1
a356 1
	    obuf->mixtodo, ibuf->mixdone);
d363 1
a363 1
	odata = (short *)abuf_wgetblk(obuf, &ocount, ibuf->mixdone);
d382 1
a382 1
	ibuf->mixdone += scount * obuf->bpf;
d385 1
a385 1
	    scount, ibuf->mixdone, obuf->mixtodo);
d395 1
a395 1
	    ibuf->used, ibuf->mixdone, obuf->mixtodo);
d397 1
a397 1
	if (!ABUF_ROK(ibuf) || ibuf->mixdone == obuf->mixtodo)
d401 1
a401 1
	ocount = obuf->mixtodo;
d403 2
a404 2
		if (ocount > i->mixdone)
			ocount = i->mixdone;
d411 1
a411 1
	obuf->mixtodo -= ocount;
d417 2
a418 2
		i->mixdone -= ocount;
		if (i->mixdone < obuf->mixtodo)
d433 1
a433 1
	    obuf->used, obuf->mixtodo);
d439 1
a439 1
	ocount = obuf->mixtodo;
d445 1
a445 1
			if ((p->u.mix.flags & MIX_DROP) && i->mixdone == 0) {
d450 2
a451 2
				drop = obuf->mixtodo;
				i->mixdone += drop;
d469 2
a470 2
		if (ocount > i->mixdone)
			ocount = i->mixdone;
d481 1
a481 1
	obuf->mixtodo -= ocount;
d483 1
a483 1
		i->mixdone -= ocount;
d526 2
a527 2
	ibuf->mixdone = 0;
	ibuf->mixvol = ADATA_UNIT;
d535 1
a535 1
	obuf->mixtodo = 0;
d577 3
a579 3
	abuf_wcommit(obuf, obuf->mixtodo);
	p->u.mix.lat += obuf->mixtodo / obuf->bpf;
	obuf->mixtodo = 0;
d597 1
a597 1
	    buf->mixvol = ADATA_UNIT / n;
d610 1
a610 1
	idata = (short *)abuf_rgetblk(ibuf, &icount, obuf->subdone);
d632 1
a632 1
	obuf->subdone += scount * ibuf->bpf;
d648 1
a648 1
			if ((p->u.sub.flags & SUB_DROP) && i->subdone == 0) {
d667 1
a667 1
				i->subdone += drop;
d672 2
a673 2
		if (done > i->subdone)
			done = i->subdone;
d678 1
a678 1
		i->subdone -= done;
d697 1
a697 1
	if (obuf->subdone == ibuf->used)
d706 2
a707 2
		if (done > i->subdone)
			done = i->subdone;
d710 1
a710 1
		i->subdone -= done;
d748 1
a748 1
	obuf->subdone = 0;
@


1.12
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.10 2008/08/14 09:58:55 ratchov Exp $	*/
a350 1
	unsigned i, scount, icount, ocount;
d352 2
d359 1
a359 1
	icount -= icount % ibuf->bpf;
d364 1
a364 1
	ocount -= ocount % obuf->bpf;
d368 4
d373 10
a382 7
	for (i = scount / sizeof(short); i > 0; i--) {
		*odata += (*idata * vol) >> ADATA_SHIFT;
		idata++;
		odata++;
	}	
	abuf_rdiscard(ibuf, scount);
	ibuf->mixdone += scount;
d520 6
d606 2
a607 1
	unsigned char *idata, *odata;
d610 2
a611 2
	idata = abuf_rgetblk(ibuf, &icount, obuf->subdone);
	icount -= icount % ibuf->bpf;
d614 2
a615 2
	odata = abuf_wgetblk(obuf, &ocount, 0);
	ocount -= icount % obuf->bpf;
d618 3
d622 12
a633 4
	memcpy(odata, idata, scount);
	abuf_wcommit(obuf, scount);	
	obuf->subdone += scount;
	DPRINTFN(4, "sub_bcopy: %u bytes\n", scount);
d742 6
@


1.11
log
@abuf_flush() must be called only from the ``xxx_in()'' routines (ie
triggered by POLLIN condition).

mix_pushzero() is not called from the ``xxx_in()'' chain, but calls
abuf_flush() resulting in bad initialization of the mixer, which
will lead to a deadlock at some point.

ok jakemsr
@
text
@d42 1
d74 4
d80 10
a89 1
	DPRINTF("aproc_del: %s: %s: deleted\n", p->ops->name, p->name);
d111 24
d145 1
a145 1
	if (ABUF_FULL(obuf))
d149 2
d152 3
a154 2
	abuf_flush(obuf);
	return !ABUF_FULL(obuf);
d164 2
d167 2
a168 2

	if (!(f->state & FILE_ROK))
d172 2
d175 1
a175 1
	return f->state & FILE_ROK;
d184 2
a185 1
	f->events &= ~POLLIN;
a191 1
	abuf_eof(LIST_FIRST(&p->obuflist));
d203 10
a212 1
	"rpipe", rpipe_in, rpipe_out, rpipe_eof, rpipe_hup, NULL, NULL, rpipe_done
d222 1
a222 2
	f->rproc = p;
	f->events |= POLLIN;
d232 2
a233 1
	f->events &= ~POLLOUT;
d243 2
d247 1
a247 1
	if (!(f->state & FILE_WOK))
a248 1

d251 2
d254 1
a254 1
	return f->state & FILE_WOK;
d267 5
a271 1
	if (ABUF_EMPTY(ibuf))
d274 4
d279 2
a281 6
	if (ABUF_EOF(ibuf)) {
		abuf_hup(ibuf);
		aproc_del(p);
		return 0;
	}
	abuf_fill(ibuf);
a295 1
	abuf_hup(LIST_FIRST(&p->ibuflist));
d300 10
a309 1
	"wpipe", wpipe_in, wpipe_out, wpipe_eof, wpipe_hup, NULL, NULL, wpipe_done
a319 1
	f->events |= POLLOUT;
d336 1
d358 1
d363 1
a379 10
/*
 * Remove an input stream from the mixer.
 */
void
mix_rm(struct aproc *p, struct abuf *ibuf)
{
	LIST_REMOVE(ibuf, ient);
	DPRINTF("mix_rm: %s\n", p->name);
}

d389 1
a389 1
	if (ibuf->mixdone >= obuf->mixtodo)
d391 1
d402 1
d404 2
a405 1
	abuf_flush(obuf);
d407 1
a407 1
	for (i = LIST_FIRST(&p->ibuflist); i != LIST_END(&p->ibuflist); i = inext) {
d410 1
a410 6
		if (i != ibuf && i->mixdone < obuf->mixtodo) {
			if (ABUF_EOF(i)) {
				mix_rm(p, i);
				abuf_hup(i);
				continue;
			}
d412 2
a413 2
			abuf_fill(i);
		}
d427 3
d432 1
a432 1
	for (i = LIST_FIRST(&p->ibuflist); i != LIST_END(&p->ibuflist); i = inext) {
d434 2
a438 1
					mix_rm(p, i);
d446 11
a462 6
		if (ABUF_EOF(i)) {
			mix_rm(p, i);
			abuf_hup(i);
			continue;
		}
		abuf_fill(i);
a467 1
		obuf->wproc = NULL;
d472 1
d486 2
a487 1
	mix_rm(p, ibuf);
a502 1
		mix_rm(p, ibuf);
d515 1
d525 8
d534 10
a543 1
	"mix", mix_in, mix_out, mix_eof, mix_hup, mix_newin, mix_newout, NULL
d547 1
a547 1
mix_new(void)
d551 1
a551 1
	p = aproc_new(&mix_ops, "softmix");
d553 2
d564 1
d596 1
d600 1
d605 1
a605 1
	abuf_wcommit(obuf, scount);
a609 7
void
sub_rm(struct aproc *p, struct abuf *obuf)
{
	LIST_REMOVE(obuf, oent);
	DPRINTF("sub_rm: %s\n", p->name);
}

d615 3
a617 3
	int again;

	again = 1;
d619 1
a619 1
	for (i = LIST_FIRST(&p->obuflist); i != LIST_END(&p->obuflist); i = inext) {
a623 1
					sub_rm(p, i);
d630 11
d642 1
a642 1
				DPRINTF("sub_in: silence =  %u\n", i->silence);
d644 1
a644 1
		} else {
a645 4
			abuf_flush(i);
		}
		if (!ABUF_WOK(i))
			again = 0;
d648 2
d655 2
a656 1
	return again;
d666 6
a671 1
	if (obuf->subdone >= ibuf->used)
a673 2
	sub_bcopy(ibuf, obuf);

d675 5
a679 5
	LIST_FOREACH(i, &p->obuflist, oent) {
		if (i != obuf && ABUF_WOK(i)) {
			sub_bcopy(ibuf, i);
			abuf_flush(i);
		}
a682 2
	if (done == 0)
		return 0;
d687 1
a687 14
	if (ABUF_EOF(ibuf)) {
		abuf_hup(ibuf);
		for (i = LIST_FIRST(&p->obuflist);
		     i != LIST_END(&p->obuflist);
		     i = inext) {
			inext = LIST_NEXT(i, oent);
			if (i != ibuf)
				abuf_eof(i);
		}
		ibuf->wproc = NULL;
		aproc_del(p);
		return 0;
	}
	abuf_fill(ibuf);
a697 1
		sub_rm(p, obuf);
d709 1
a709 6
	sub_rm(p, obuf);
	if (LIST_EMPTY(&p->obuflist) && (p->u.sub.flags & SUB_AUTOQUIT)) {
		abuf_hup(ibuf);
		aproc_del(p);
	} else
		abuf_run(ibuf);
d720 8
d729 10
a738 1
	"sub", sub_in, sub_out, sub_eof, sub_hup, NULL, sub_newout, NULL
d742 1
a742 1
sub_new(void)
d746 1
a746 1
	p = aproc_new(&sub_ops, "copy");
d748 2
a752 1

d791 1
d795 1
d882 3
a884 1
	if (!ABUF_WOK(obuf))
d887 3
a889 2
	abuf_flush(obuf);
	return ABUF_WOK(obuf);
d897 5
a901 1
	if (!ABUF_ROK(ibuf))
a903 7
	if (ABUF_EOF(ibuf)) {
		obuf->wproc = NULL;
		abuf_hup(ibuf);
		aproc_del(p);
		return 0;
	}
	abuf_fill(ibuf);
d910 2
a911 1
	abuf_eof(LIST_FIRST(&p->obuflist));
d918 2
a919 1
	abuf_hup(LIST_FIRST(&p->ibuflist));
d950 1
a950 1
	for (i = 0; i < CHAN_MAX; i++)
d954 34
d989 10
a998 1
	"conv", conv_in, conv_out, conv_eof, conv_hup, NULL, NULL, NULL
d1009 7
@


1.10
log
@move all device related stuff from aucat.c to a new dev.c file.
The new dev_xxx() routines expose a "high level" self-contained
interface to the device. At initialization, the device is opened
and two chains of aproc structures are created:

 * a playback chain that exposes a (initially) empty mix
   aproc to which the rest of the code can attach new
   streams to be played

 * record chain that exposes a (initially) empty sub aproc
   to which the rest of the code can attach new stream to
   to record

The rest of the code, has just to use dev_attach() routine to
attach streams. While we're at it, add a ``devops'' structure
containing pointers to the device-specific routines. This will
allow later to add support for other type of device than the
Sun API.

Also, write the .wav headers in file_del(), so put all header
related data in the file strucuture. This allows to close() the
file, as soon as wpipe_xxx() aproc terminates. This will be
useful for the server, because it will need to close() descripts
of closed connections immediately.

add mix_pushzero() routine to fill the mixer with silence. It
will be used to avoid the mixer to underrun when there are no
input streams. Since we always have at least one input stream
there's no behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.9 2008/08/14 09:47:51 ratchov Exp $	*/
d477 1
a477 1
	abuf_flush(obuf);
@


1.9
log
@add an "AUTOQUIT" flag to mix and sub aprocs. If the flag is
set, the mix aproc will exit once there are no more input
streams, similarly the sub aproc will exit once there are no
more ouput streams. If the flag is not set, the mix aproc will
generate silence, and the sub aproc will drop samples. By
default this flag is set, so no behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.8 2008/08/14 09:45:23 ratchov Exp $	*/
d468 27
@


1.8
log
@add a xxx_done() method to aproc structures, that cleans up just
before free()ing the aproc structure, this is cleaner and will
allow to reuse wpipe_xxx() and rpipe_xxx() when defining new
aprocs. No behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.7 2008/08/14 09:44:15 ratchov Exp $	*/
d398 1
a398 1
	if (LIST_EMPTY(&p->ibuflist)) {
d603 1
a603 1
	if (LIST_EMPTY(&p->obuflist)) {
@


1.7
log
@move mix/sub underrun/overrun handling code and data in the
generic abuf structure, so it can reused. Required for an audio
server. No behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.6 2008/08/14 09:39:16 ratchov Exp $	*/
d73 2
d134 1
a134 1
rpipe_del(struct aproc *p)
a139 1
	aproc_del(p);
d147 1
a147 1
	rpipe_del(p);
d154 1
a154 1
	rpipe_del(p);
d158 1
a158 1
	"rpipe", rpipe_in, rpipe_out, rpipe_eof, rpipe_hup, NULL, NULL
d174 1
a174 1
wpipe_del(struct aproc *p)
a179 1
	aproc_del(p);
d217 1
a217 1
		wpipe_del(p);
d228 1
a228 1
	wpipe_del(p);
d236 1
a236 1
	wpipe_del(p);
d240 1
a240 1
	"wpipe", wpipe_in, wpipe_out, wpipe_eof, wpipe_hup, NULL, NULL
d457 1
a457 1
	"mix", mix_in, mix_out, mix_eof, mix_hup, mix_newin, mix_newout
a498 6
void
sub_del(struct aproc *p)
{
	aproc_del(p);
}

d576 1
a576 1
		sub_del(p);
d593 1
a593 1
	sub_del(p);
d605 1
a605 1
		sub_del(p);
d619 1
a619 1
	"sub", sub_in, sub_out, sub_eof, sub_hup, NULL, sub_newout
a754 6
void
conv_del(struct aproc *p)
{
	aproc_del(p);
}

d778 1
a778 1
		conv_del(p);
d789 1
a789 1
	conv_del(p);
d796 1
a796 1
	conv_del(p);
d831 1
a831 1
	"conv", conv_in, conv_out, conv_eof, conv_hup, NULL, NULL
@


1.6
log
@factor code that discards data from abuf strucure into a single
abuf_rdiscard() routine. Similarly add abuf_wcommit() routine for
writing. The purpose is to stop manupulating FIFO pointers in
various places outiside abuf.c, its too error prone.
No behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.5 2008/06/02 17:06:36 ratchov Exp $	*/
d323 1
a323 1
	unsigned icount, ocount;
d325 1
a325 1
	DPRINTFN(4, "mix_in: used = %u, done = %u, zero = %u\n",
a326 15

	/* 
	 * discard data already sent as silence
	 */
	if (ibuf->mixdrop > 0) {
		icount = ibuf->mixdrop;
		if (icount > ibuf->used)
			icount = ibuf->used;
		ibuf->used -= icount;
		ibuf->start += icount;
		if (ibuf->start >= ibuf->len)
			ibuf->start -= ibuf->len;
		ibuf->mixdrop -= icount;
		DPRINTF("mix_in: catched xruns, drop = %u\n", ibuf->mixdrop);
	}
d382 2
a383 3
					i->mixdrop += drop;
				DPRINTF("mix_out: xrun, drop = %u\n", 
				    i->mixdrop);
a444 1
	ibuf->mixdrop = 0;
d525 1
a525 1
					i->subdrop += drop;
d527 1
a527 2
				DPRINTF("sub_in: xrun, drop =  %u\n",
				    i->subdrop);
a549 2
	unsigned char *odata;
	unsigned ocount;
a551 15
	/*
	 * generate silence for dropped samples
	 */
	while (obuf->subdrop > 0) {
		odata = abuf_wgetblk(obuf, &ocount, 0);
		if (ocount >= obuf->subdrop)
			ocount = obuf->subdrop;
		if (ocount == 0)
			break;
		memset(odata, 0, ocount);
		obuf->used += ocount;
		obuf->subdrop -= ocount;
		DPRINTF("sub_out: catch, drop = %u\n", obuf->subdrop);
	}

a620 1
	obuf->subdrop = 0;
@


1.5
log
@allow the user to choose the aucat behaviour when underruns/overruns
occur on a per-stream basis, using -Xx flags.  There are 3 possible
policies:

 - ignore : ignores underruns/overruns, for instance, this mode
   could be used for creating simple pipes with utilities; like in
   your last cdio diff.

 - sync : insert/discard samples in order to keep all streams in
   sync, useful for multi-tracker-like apps and/or to sync
   midi/video/whatever on audio streams (this was the previous
   behaviour)

 - error : if overruns/underruns occur, consider it as fatal error
   and kill the corresponding stream (without disturbing others).
   Useful, for reliable recordings (and/or debugging aucat
   itself:).

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.4 2008/06/02 17:05:12 ratchov Exp $	*/
a39 4
 *	(hard) handle underruns in rpipe and mix
 *
 *	(hard) handle overruns in wpipe and sub
 *
d103 2
d108 2
a109 1
	obuf->used += file_read(f, data, count);
d121 2
d126 2
a127 1
	obuf->used += file_read(f, data, count);
d189 2
d196 1
a196 4
	ibuf->used -= count;
	ibuf->start += count;
	if (ibuf->start >= ibuf->len)
		ibuf->start -= ibuf->len;
d208 2
d214 1
a214 4
	ibuf->used -= count;
	ibuf->start += count;
	if (ibuf->start >= ibuf->len)
		ibuf->start -= ibuf->len;
d265 1
a265 1
	DPRINTFN(4, "mix_bzero: used = %u, zero = %u\n",
d285 1
a285 1
	DPRINTFN(4, "mix_badd: zero = %u, done = %u\n",
d301 2
a302 3
	}

	ibuf->used -= scount;
a303 3
	ibuf->start += scount;
	if (ibuf->start >= ibuf->len)
		ibuf->start -= ibuf->len;
d305 1
a305 1
	DPRINTFN(4, "mix_badd: added %u, done = %u, zero = %u\n",
d354 1
a354 1
	obuf->used += ocount;
d380 1
a380 1
	DPRINTFN(4, "mix_out: used = %u, zero = %u\n",
d420 1
a420 1
	obuf->used += ocount;
d504 1
a505 1
	obuf->used += scount;
d559 1
a559 4
	ibuf->used -= done;
	ibuf->start += done;
	if (ibuf->start >= ibuf->len)
		ibuf->start -= ibuf->len;
d606 1
a606 4
	ibuf->used -= done;
	ibuf->start += done;
	if (ibuf->start >= ibuf->len)
		ibuf->start -= ibuf->len;
a791 5
	ibuf->used -= icount;
	ibuf->start += icount;
	if (ibuf->start >= ibuf->len)
		ibuf->start -= ibuf->len;

d793 2
a794 1
	obuf->used += ocount;
@


1.4
log
@since underruns/overruns are handled outside devices, remove code that
check for xruns in devices.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.3 2008/06/02 17:03:25 ratchov Exp $	*/
d391 14
a404 5
		if (!ABUF_ROK(i) && i->mixdone == 0) {
			drop = obuf->mixtodo;
			i->mixdone += drop;
			i->mixdrop += drop;
			DPRINTF("mix_out: xrun, drop = %u\n", i->mixdrop);
d467 1
d487 1
d537 14
a550 5
		if (!ABUF_WOK(i) && i->subdone == 0) {
			drop = ibuf->used;
			i->subdrop += drop;
			i->subdone += drop;
			DPRINTF("sub_in: xrun, drop =  %u\n", i->subdrop);
a554 1
#ifdef sub_xrun_disabled		
a556 1
#endif
d591 1
a591 1
		DPRINTF("sub_out: catched, drop = %u\n", obuf->subdrop);
d667 1
d680 1
@


1.3
log
@Allows any input/output stream to underrun/overrun without disturbing
other streams. Beside making aucat usable with slow apps (eg. cdio),
this change will ease turning aucat into an audio server later

if one of the input buffers underruns, then silence is generated in
place of the missing samples. Later, as many samples are dropped in
order to maintain the stream in sync with the rest

if one of the output buffers overruns then newer samples are
discarded. Later silence is generated in order to maintain the
stream in sync with the rest.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.2 2008/05/25 21:16:37 ratchov Exp $	*/
a106 3
	if (!(f->state & FILE_RFLOW) && ABUF_FULL(obuf))
		errx(1, "%s: overrun, unimplemented", f->name);

a166 1
	f->state |= FILE_RFLOW;
a206 3
	if (!(f->state & FILE_WFLOW) && ABUF_EMPTY(ibuf))
		errx(1, "%s: underrun, unimplemented", f->name);

a251 1
	f->state |= FILE_WFLOW;
@


1.2
log
@give argument to LIST_END(), don't use variable lenght arrays as last
field of structures.

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.1 2008/05/23 07:15:46 ratchov Exp $	*/
d335 1
a335 1
	unsigned ocount;
d340 15
d390 1
a390 1
	unsigned ocount;
a394 4
	/*
	 * XXX: should handle underruns here, currently if one input is
	 * blocked, then the output block can underrun.
	 */
d399 7
a405 1
		mix_badd(i, obuf);
d464 1
d527 1
a527 1
	unsigned done;
d534 6
a539 1
		if (ABUF_WOK(i)) {
d543 1
d546 1
d565 2
d569 15
d656 1
@


1.1
log
@add support for:
 - recording, full-duplex operation
 - format conversions and resampling on the fly
 - mixing on the fly of multiple inputs of different formats
 - up to 16 channels, simplistic "routing" of channel ranges
 - more linear encodings (in raw and wav files)
the old behaviour is fully preserved if none of the new -i and -o
options are used.

code and fixes from jakemsr@@ and eric@@, suggestions by others.
ok "go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d355 1
a355 1
	for (i = LIST_FIRST(&p->ibuflist); i != LIST_END(); i = inext) {
d386 1
a386 1
	for (i = LIST_FIRST(&p->ibuflist); i != LIST_END(); i = inext) {
d514 1
a514 1
	for (i = LIST_FIRST(&p->obuflist); i != LIST_END(); i = inext) {
d568 1
a568 1
		     i != LIST_END();
@

