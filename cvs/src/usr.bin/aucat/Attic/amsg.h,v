head	1.22;
access;
symbols
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.22
date	2011.04.27.21.20.36;	author ratchov;	state dead;
branches;
next	1.21;

1.21
date	2011.04.27.20.33.40;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.16.11.24.18;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.16.10.52.22;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2010.10.21.18.57.42;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.05.12.45.48;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.06.20.19.42;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.22.21.41.30;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.17.10.55.43;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.28.06.37.06;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2009.07.25.10.52.18;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.16.12.20.31;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.16.11.15.26;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2009.02.13.20.48.49;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.23.17.38.15;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.17.07.19.27;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.11.19.21.20;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.26.08.49.43;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.22
log
@move amsg.h containing protocol defs from aucat side to libsndio side.

requested by deraadt
@
text
@/*	$OpenBSD: amsg.h,v 1.21 2011/04/27 20:33:40 deraadt Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifndef AMSG_H
#define AMSG_H

#include <stdint.h>
#include <sys/signal.h>
#include "conf.h"

/*
 * WARNING: since the protocol may be simultaneously used by static
 * binaries or by different versions of a shared library, we are not
 * allowed to change the packet binary representation in a backward
 * incompatible way.
 *
 * Especially, make sure the amsg_xxx structures are not larger
 * than 32 bytes.
 */
struct amsg {
#define AMSG_ACK	0	/* ack for START/STOP */
#define AMSG_GETPAR	1	/* get the current parameters */
#define AMSG_SETPAR	2	/* set the current parameters */
#define AMSG_START	3	/* request the server to start the stream */
#define AMSG_STOP	4	/* request the server to stop the stream */
#define AMSG_DATA	5	/* data block */
#define AMSG_POS	6	/* initial position */
#define AMSG_MOVE	7	/* position changed */
#define AMSG_SETVOL	9	/* set volume */
#define AMSG_HELLO	10	/* say hello, check versions and so ... */
#define AMSG_BYE	11	/* ask server to drop connection */
	uint32_t cmd;
	uint32_t __pad;
	union {
		struct amsg_par {
			uint8_t legacy_mode;	/* compat for old libs */
			uint8_t xrun;		/* one of above */
			uint8_t bps;		/* bytes per sample */
			uint8_t bits;		/* actually used bits */
			uint8_t msb;		/* 1 if MSB justified */
			uint8_t le;		/* 1 if little endian */
			uint8_t sig;		/* 1 if signed */
			uint8_t __pad1;
			uint16_t pchan;		/* play channels */
			uint16_t rchan;		/* record channels */
			uint32_t rate;		/* frames per second */
			uint32_t bufsz;		/* total buffered frames */
			uint32_t round;
			uint32_t appbufsz;	/* client side bufsz */
			uint32_t _reserved[1];	/* for future use */
		} par;
		struct amsg_data {
#define AMSG_DATAMAX	0x1000
			uint32_t size;
		} data;
		struct amsg_ts {
			int32_t delta;
		} ts;
		struct amsg_vol {
			uint32_t ctl;
		} vol;
		struct amsg_hello {
			uint16_t mode;		/* bitmap of MODE_XXX */
#define AMSG_VERSION	5
			uint8_t version;	/* protocol version */
			uint8_t reserved1[5];	/* for future use */
			char opt[12];		/* profile name */
			char who[12];		/* hint for leases */
		} hello;
	} u;
};

/*
 * Initialize an amsg structure: fill all fields with 0xff, so the read
 * can test which fields were set.
 */
#define AMSG_INIT(m) do { memset((m), 0xff, sizeof(struct amsg)); } while (0)

/*
 * Since the structure is memset to 0xff, the MSB can be used to check
 * if any field was set.
 */
#define AMSG_ISSET(x) (((x) & (1 << (8 * sizeof(x) - 1))) == 0)

#endif /* !defined(AMSG_H) */
@


1.21
log
@needs signal.h, too
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.20 2011/04/16 11:24:18 ratchov Exp $	*/
@


1.20
log
@Since aucat supports any parameter combination sio_getcap() doesn't
need to query the server for supported parameters. So stop using the
AMSG_GETCAP message, and remove it completely from the aucat protocol.
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.19 2011/04/16 10:52:22 ratchov Exp $	*/
d21 1
@


1.19
log
@Make aucat audio and midi backends share the same code to communicate
with the server. As we're at it use the same protocol for midi and
audio. Now, both audio and midi code use the same SNDIO_DEBUG environment
variable to turn on/off DPRINTF's.
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.18 2010/10/21 18:57:42 ratchov Exp $	*/
a40 1
#define AMSG_GETCAP	8	/* get capabilities */
a63 9
		struct amsg_cap {
			uint32_t rate;		/* native rate */
			uint32_t _reserved2[1];	/* for future use */
			uint16_t rchan;		/* native rec channels */
			uint16_t pchan;		/* native play channels */
			uint8_t bits;		/* native bits per sample */
			uint8_t bps;		/* native ytes per sample */
			uint8_t _reserved[10];	/* for future use */
		} cap;
d76 1
a76 1
#define AMSG_VERSION	4
@


1.18
log
@use MODE_xxx and XRUN_xxx macros everywhere, and zap corresponding
AMSG_xxx macros, which in turns simplifies the code
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.17 2010/06/05 12:45:48 ratchov Exp $	*/
d86 1
a86 1
#define AMSG_VERSION	3
@


1.17
log
@Don't send the initial position as a clock tick with a negative delta.
Add a new ``initial position'' message which is simpler. No bahaviour
change, except effects of the protocol version crank.
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.16 2010/04/06 20:19:42 ratchov Exp $	*/
d21 1
a49 3
#define AMSG_IGNORE	0			/* loose sync */
#define AMSG_SYNC	1			/* resync after xrun */
#define AMSG_ERROR	2			/* kill the stream */
d85 1
a85 7
#define AMSG_PLAY	0x1			/* audio playback */
#define AMSG_REC	0x2			/* audio recording */
#define AMSG_MIDIIN	0x4			/* MIDI thru input */
#define AMSG_MIDIOUT	0x8			/* MIDI thru output */
#define AMSG_MON	0x10			/* audio monitoring */
#define AMSG_RECMASK	(AMSG_REC | AMSG_MON)	/* can record ? */
			uint16_t proto;		/* protocol type */
@


1.16
log
@bump (private) protocol version number
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.15 2010/04/06 20:07:01 ratchov Exp $	*/
d38 6
a43 5
#define AMSG_MOVE	6	/* position changed */
#define AMSG_GETCAP	7	/* get capabilities */
#define AMSG_SETVOL	8	/* set volume */
#define AMSG_HELLO	9	/* say hello, check versions and so ... */
#define AMSG_BYE	10	/* ask server to drop connection */
d94 1
a94 1
#define AMSG_VERSION	2
@


1.15
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.14 2010/04/03 17:59:17 ratchov Exp $	*/
d93 1
a93 1
#define AMSG_VERSION	1
@


1.14
log
@backout last change, committed by mistake, sorry...
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.12 2009/10/22 21:41:30 ratchov Exp $	*/
d90 2
a91 1
#define AMSG_MIXER	0x10			/* MIDI mixer */
@


1.13
log
@doc fixes from jmc
@
text
@d90 1
a90 2
#define AMSG_MON	0x10			/* audio monitoring */
#define AMSG_RECMASK	(AMSG_REC | AMSG_MON)	/* can record ? */
@


1.12
log
@When starting playback, the client tries to write ``bufsz'' frames
instead of ``appbufsz'', which violates the flow control mechanism.
Fix this longstanding bug by enabling negative values in AMSG_MOVE
messages, this way the client is notified when its stream is
attached to the mixer, and can update its max transfer limit.

Since this fix changes the AMSG_MOVE message format, we crank the
protocol version, and thus remove code specific to the old protocol.
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.11 2009/10/17 10:55:43 ratchov Exp $	*/
d90 2
a91 1
#define AMSG_MIXER	0x10			/* MIDI mixer */
@


1.11
log
@Add version number to aucat protocol. It's not used yet,
but later, it will permit aucat to reject connections from
clients statically linked to a unsupported version of libsndio.

idea from kittenis, otto and sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.10 2009/08/28 06:37:06 ratchov Exp $	*/
d92 1
a92 1
#define AMSG_VERSION	0
@


1.10
log
@add a new AMSG_BYE, sent by the client to requst the server to
free resources and drop the connection. This allows the client
to ensuire that at any time it's using only one connection, thus
only one MIDI control channel.
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.9 2009/07/25 10:52:18 ratchov Exp $	*/
d92 3
a94 1
			uint8_t reserved1[6];	/* for future use */
@


1.9
log
@fix comments, remove no longer needed declaration, reorder includes
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.8 2009/07/25 08:44:27 ratchov Exp $	*/
d42 1
@


1.8
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.7 2009/05/16 12:20:31 ratchov Exp $	*/
d99 2
a100 2
 * initialize an amsg structure: fill all fields with 0xff, so the read
 * can test which fields were set
d105 2
a106 2
 * since the structure is memset to 0xff, the MSB can be used to check
 * if any filed was set
@


1.7
log
@use the ``hello'' message a to set the device mode, and thus make
it mandatory. Old legacy clients setting the mode with sio_setpar()
are still working thanks to small hack.
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.6 2009/05/16 11:15:26 ratchov Exp $	*/
d91 2
a92 1
			uint8_t reserved1[18];	/* for future use */
@


1.6
log
@add a new ``hello'' message to aucat protocol useful to work on
future aucat extentions. No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.5 2009/02/13 20:48:49 ratchov Exp $	*/
d46 1
a46 1
			uint8_t mode;		/* AMSG_PLAY or AMSG_REC */
@


1.5
log
@style and typos fixes from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.4 2009/01/23 17:38:15 ratchov Exp $	*/
d27 3
d41 1
d46 1
a46 3
#define AMSG_PLAY	1			/* will play */
#define AMSG_REC	2			/* will record */
			uint8_t mode;		/* a bitmap of above */
d84 10
@


1.4
log
@spacing + typo fix from Matt Jibson <matt.jibson(at)gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.3 2008/12/17 07:19:27 ratchov Exp $	*/
d17 2
a18 2
#ifndef SOCKET_H
#define SOCKET_H
d97 1
a97 1
#endif /* !defined(SOCKET_H) */
@


1.3
log
@add a writable ``appbufsz'' field to the sa_par structure, containing
the program-part of the buffer size, ie the part that is subject to
underruns. Useful for apps like cdio(1) that don't have their own
rings, or to apps that have a minimum ring size constraint. Setting
the ``bufsz'' parameter becomes deprecated.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.2 2008/11/11 19:21:20 ratchov Exp $	*/
d33 1
a33 1
#define AMSG_STOP	4	/* request the server to stop the stream */ 
@


1.2
log
@expose the volume knob in server mode too
@
text
@d1 1
a1 1
/*	$OpenBSD: amsg.h,v 1.1 2008/10/26 08:49:43 ratchov Exp $	*/
d58 1
a58 1
			uint32_t bufsz;		/* buffered frames */
d60 2
a61 1
			uint32_t _reserved[2];	/* for future use */
d65 1
a65 1
			uint32_t rate_div;	/* divisor of emul. rates */
@


1.1
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
d78 3
@

