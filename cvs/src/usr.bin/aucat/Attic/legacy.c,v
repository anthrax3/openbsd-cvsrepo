head	1.13;
access;
symbols
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2010.11.04.17.50.41;	author ratchov;	state dead;
branches;
next	1.12;

1.12
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2010.04.05.19.52.42;	author jakemsr;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.25.10.54.29;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.25.10.52.19;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.22.10.57.33;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.11.10.24.21;	author jakemsr;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.08.10.40.52;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.26.08.49.44;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.14.09.58.55;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.23.07.15.46;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.13
log
@legacy.c is not used any longer
@
text
@/*	$OpenBSD: legacy.c,v 1.12 2010/04/06 20:07:01 ratchov Exp $	*/
/*
 * Copyright (c) 1997 Kenneth Stailey.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Kenneth Stailey.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sndio.h>

#include <err.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "wav.h"

/*
 * Headerless data files.  Played at /dev/audio's defaults.
 */
#define FMT_RAW	0

/*
 * Sun/NeXT .au files.  Header is skipped and /dev/audio is configured
 * for monaural 8-bit ulaw @@ 8kHz, the de facto format for .au files,
 * as well as the historical default configuration for /dev/audio.
 */
#define FMT_AU	1

/*
 * RIFF WAV files.  Header is parsed for format details which are
 * applied to /dev/audio.
 */
#define FMT_WAV	2


int
legacy_play(char *dev, char *aufile)
{
	struct sio_hdl *hdl;
	struct sio_par spar, par;
	struct aparams apar;
	ssize_t rd;
	off_t datasz, dummy;
	char buf[5120];
	size_t readsz;
	int fd, fmt = FMT_RAW;
	u_int32_t pos = 0, snd_fmt = 1, rate = 8000, chan = 1;
	char magic[4];
	short *map;

	if ((fd = open(aufile, O_RDONLY)) < 0) {
		warn("cannot open %s", aufile);
		return(1);
	}

	if (read(fd, magic, sizeof(magic)) != sizeof(magic)) {
		/*
		 * read() error, or the file is smaller than sizeof(magic).
		 * treat as a raw file, like previous versions of aucat.
		 */
	} else if (!strncmp(magic, ".snd", 4)) {
		fmt = FMT_AU;
		if (read(fd, &pos, sizeof(pos)) == sizeof(pos))
			pos = ntohl(pos);
		/* data size */
		if (lseek(fd, 4, SEEK_CUR) == -1)
			warn("lseek hdr");
		if (read(fd, &snd_fmt, sizeof(snd_fmt)) == sizeof(snd_fmt))
			snd_fmt = ntohl(snd_fmt);
		if (read(fd, &rate, sizeof(rate)) == sizeof(rate))
			rate = ntohl(rate);
		if (read(fd, &chan, sizeof(chan)) == sizeof(chan))
			chan = ntohl(chan);
	} else if (!strncmp(magic, "RIFF", 4) &&
		    wav_readhdr(fd, &apar, &dummy, &datasz, &map)) {
			fmt = FMT_WAV;
	}

	/*
	 * Seek to start of audio data.  wav_readhdr already took care
	 * of this for FMT_WAV.
	 */
	if (fmt == FMT_RAW || fmt == FMT_AU)
		if (lseek(fd, (off_t)pos, SEEK_SET) == -1)
			warn("lseek");

	if ((hdl = sio_open(dev, SIO_PLAY, 0)) == NULL) {
		warnx("can't get sndio handle");
		return(1);
	}

	sio_initpar(&par);
	switch(fmt) {
	case FMT_WAV:
		par.rate = apar.rate;
		par.pchan = apar.cmax - apar.cmin + 1;
		par.sig = apar.sig;
		par.bits = apar.bits;
		par.le = apar.le;
		break;
	case FMT_AU:
		par.rate = rate;
		par.pchan = chan;
		par.sig = 1;
		par.bits = 16;
		par.le = SIO_LE_NATIVE;
		map = wav_ulawmap;
		if (snd_fmt == 27)
			map = wav_alawmap;
		break;
	case FMT_RAW:
	default:
		break;
	}
	spar = par;

	if (!sio_setpar(hdl, &par) || !sio_getpar(hdl, &par)) {
		warnx("can't set audio parameters");
		/*
		 * Only WAV could fail in previous aucat versions (unless
		 * the parameters returned by AUDIO_GETINFO would fail,
		 * which is unlikely).
		 */
		if (fmt == FMT_WAV)
			return(1);
	}

        /*
	 * Parameters may be silently modified.  See audio(9)'s
	 * description of set_params.  For compatability with previous
	 * aucat versions, continue running if something doesn't match.
	 */
	if (par.bits != spar.bits ||
	    par.sig != par.sig ||
	    par.le != spar.le ||
	    par.pchan != spar.pchan ||
	    /*
	     * Devices may return a very close rate, such as 44099 when
	     * 44100 was requested.  The difference is inaudible.  Allow
	     * 2% deviation as an example of how to cope.
	     */
	    (par.rate > spar.rate * 1.02 || par.rate < spar.rate * 0.98)) {
		warnx("format not supported");
	}
	if (!sio_start(hdl)) {
		warnx("could not start sndio");
		exit(1);
	}

	readsz = sizeof(buf);
	if (map)
		readsz /= 2;
	while ((rd = read(fd, buf, readsz)) > 0) {
		if (map) {
			wav_conv(buf, rd, map);
			rd *= 2;
		}
		if (sio_write(hdl, buf, rd) != rd)
			warnx("sio_write: short write");
	}
	if (rd == -1)
		warn("read");

	sio_close(hdl);
	close(fd);

	return(0);
}
@


1.12
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: legacy.c,v 1.11 2010/04/05 19:52:42 jakemsr Exp $	*/
@


1.11
log
@fix playback of .au files on big-endian machines
@
text
@d1 1
a1 1
/*	$OpenBSD: legacy.c,v 1.10 2010/04/03 17:59:17 ratchov Exp $	*/
d67 1
a67 1
	off_t datasz;
d99 1
a99 1
		    wav_readhdr(fd, &apar, &datasz, &map)) {
@


1.10
log
@backout last change, committed by mistake, sorry...
@
text
@d1 1
a1 1
/*	$OpenBSD: legacy.c,v 1.8 2009/07/25 10:54:29 ratchov Exp $	*/
d130 1
a130 1
		par.le = 1;
@


1.9
log
@doc fixes from jmc
@
text
@d67 1
a67 1
	off_t datasz, dummy;
d99 1
a99 1
		    wav_readhdr(fd, &apar, &dummy, &datasz, &map)) {
@


1.8
log
@sio_open returns a pointer so the < 0 comparison is wrong
from Thomas Pfaff, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: legacy.c,v 1.7 2009/07/25 10:52:19 ratchov Exp $	*/
d67 1
a67 1
	off_t datasz;
d99 1
a99 1
		    wav_readhdr(fd, &apar, &datasz, &map)) {
@


1.7
log
@fix comments, remove no longer needed declaration, reorder includes
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: legacy.c,v 1.6 2009/04/22 10:57:33 ratchov Exp $	*/
d111 1
a111 1
	if ((hdl = sio_open(dev, SIO_PLAY, 0)) < 0) {
@


1.6
log
@move support for ulaw/alaw encoding in .wav files from legacy mode
to normal mode.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: legacy.c,v 1.5 2009/04/11 10:24:21 jakemsr Exp $	*/
d33 2
a35 1
#include <fcntl.h>
a37 1
#include <err.h>
d41 2
a42 1
/* headerless data files.  played at /dev/audio's defaults.
d46 2
a47 1
/* Sun/NeXT .au files.  header is skipped and /dev/audio is configured
d53 2
a54 1
/* RIFF WAV files.  header is parsed for format details which are
d81 2
a82 1
		/* read() error, or the file is smaller than sizeof(magic).
d103 2
a104 1
	/* seek to start of audio data.  wav_readhdr already took care
d143 2
a144 1
		/* only WAV could fail in previous aucat versions (unless
d146 1
a146 1
		 * which is unlikely)
d152 3
a154 2
	/* parameters may be silently modified.  see audio(9)'s
	 * description of set_params.  for compatability with previous
d161 3
a163 2
	    /* devices may return a very close rate, such as 44099 when
	     * 44100 was requested.  the difference is inaudible.  allow
d189 1
a189 1
	(void) close(fd);
@


1.5
log
@- make legacy mode use sio_open(3) (sndio) API
- parse .au headers in legacy mode
- support playback of ulaw and alaw encoded .au and .wav files in
legacy mode

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: legacy.c,v 1.4 2008/11/08 10:40:52 ratchov Exp $	*/
a40 170
/*
 * This table converts a (8 bit) mu-law value two a 16 bit value.
 * The 16 bits are represented as an array of two bytes for easier access
 * to the individual bytes.
 */
const u_char mulawtolin16[256][2] = {
	{0x02,0x84}, {0x06,0x84}, {0x0a,0x84}, {0x0e,0x84},
	{0x12,0x84}, {0x16,0x84}, {0x1a,0x84}, {0x1e,0x84},
	{0x22,0x84}, {0x26,0x84}, {0x2a,0x84}, {0x2e,0x84},
	{0x32,0x84}, {0x36,0x84}, {0x3a,0x84}, {0x3e,0x84},
	{0x41,0x84}, {0x43,0x84}, {0x45,0x84}, {0x47,0x84},
	{0x49,0x84}, {0x4b,0x84}, {0x4d,0x84}, {0x4f,0x84},
	{0x51,0x84}, {0x53,0x84}, {0x55,0x84}, {0x57,0x84},
	{0x59,0x84}, {0x5b,0x84}, {0x5d,0x84}, {0x5f,0x84},
	{0x61,0x04}, {0x62,0x04}, {0x63,0x04}, {0x64,0x04},
	{0x65,0x04}, {0x66,0x04}, {0x67,0x04}, {0x68,0x04},
	{0x69,0x04}, {0x6a,0x04}, {0x6b,0x04}, {0x6c,0x04},
	{0x6d,0x04}, {0x6e,0x04}, {0x6f,0x04}, {0x70,0x04},
	{0x70,0xc4}, {0x71,0x44}, {0x71,0xc4}, {0x72,0x44},
	{0x72,0xc4}, {0x73,0x44}, {0x73,0xc4}, {0x74,0x44},
	{0x74,0xc4}, {0x75,0x44}, {0x75,0xc4}, {0x76,0x44},
	{0x76,0xc4}, {0x77,0x44}, {0x77,0xc4}, {0x78,0x44},
	{0x78,0xa4}, {0x78,0xe4}, {0x79,0x24}, {0x79,0x64},
	{0x79,0xa4}, {0x79,0xe4}, {0x7a,0x24}, {0x7a,0x64},
	{0x7a,0xa4}, {0x7a,0xe4}, {0x7b,0x24}, {0x7b,0x64},
	{0x7b,0xa4}, {0x7b,0xe4}, {0x7c,0x24}, {0x7c,0x64},
	{0x7c,0x94}, {0x7c,0xb4}, {0x7c,0xd4}, {0x7c,0xf4},
	{0x7d,0x14}, {0x7d,0x34}, {0x7d,0x54}, {0x7d,0x74},
	{0x7d,0x94}, {0x7d,0xb4}, {0x7d,0xd4}, {0x7d,0xf4},
	{0x7e,0x14}, {0x7e,0x34}, {0x7e,0x54}, {0x7e,0x74},
	{0x7e,0x8c}, {0x7e,0x9c}, {0x7e,0xac}, {0x7e,0xbc},
	{0x7e,0xcc}, {0x7e,0xdc}, {0x7e,0xec}, {0x7e,0xfc},
	{0x7f,0x0c}, {0x7f,0x1c}, {0x7f,0x2c}, {0x7f,0x3c},
	{0x7f,0x4c}, {0x7f,0x5c}, {0x7f,0x6c}, {0x7f,0x7c},
	{0x7f,0x88}, {0x7f,0x90}, {0x7f,0x98}, {0x7f,0xa0},
	{0x7f,0xa8}, {0x7f,0xb0}, {0x7f,0xb8}, {0x7f,0xc0},
	{0x7f,0xc8}, {0x7f,0xd0}, {0x7f,0xd8}, {0x7f,0xe0},
	{0x7f,0xe8}, {0x7f,0xf0}, {0x7f,0xf8}, {0x80,0x00},
	{0xfd,0x7c}, {0xf9,0x7c}, {0xf5,0x7c}, {0xf1,0x7c},
	{0xed,0x7c}, {0xe9,0x7c}, {0xe5,0x7c}, {0xe1,0x7c},
	{0xdd,0x7c}, {0xd9,0x7c}, {0xd5,0x7c}, {0xd1,0x7c},
	{0xcd,0x7c}, {0xc9,0x7c}, {0xc5,0x7c}, {0xc1,0x7c},
	{0xbe,0x7c}, {0xbc,0x7c}, {0xba,0x7c}, {0xb8,0x7c},
	{0xb6,0x7c}, {0xb4,0x7c}, {0xb2,0x7c}, {0xb0,0x7c},
	{0xae,0x7c}, {0xac,0x7c}, {0xaa,0x7c}, {0xa8,0x7c},
	{0xa6,0x7c}, {0xa4,0x7c}, {0xa2,0x7c}, {0xa0,0x7c},
	{0x9e,0xfc}, {0x9d,0xfc}, {0x9c,0xfc}, {0x9b,0xfc},
	{0x9a,0xfc}, {0x99,0xfc}, {0x98,0xfc}, {0x97,0xfc},
	{0x96,0xfc}, {0x95,0xfc}, {0x94,0xfc}, {0x93,0xfc},
	{0x92,0xfc}, {0x91,0xfc}, {0x90,0xfc}, {0x8f,0xfc},
	{0x8f,0x3c}, {0x8e,0xbc}, {0x8e,0x3c}, {0x8d,0xbc},
	{0x8d,0x3c}, {0x8c,0xbc}, {0x8c,0x3c}, {0x8b,0xbc},
	{0x8b,0x3c}, {0x8a,0xbc}, {0x8a,0x3c}, {0x89,0xbc},
	{0x89,0x3c}, {0x88,0xbc}, {0x88,0x3c}, {0x87,0xbc},
	{0x87,0x5c}, {0x87,0x1c}, {0x86,0xdc}, {0x86,0x9c},
	{0x86,0x5c}, {0x86,0x1c}, {0x85,0xdc}, {0x85,0x9c},
	{0x85,0x5c}, {0x85,0x1c}, {0x84,0xdc}, {0x84,0x9c},
	{0x84,0x5c}, {0x84,0x1c}, {0x83,0xdc}, {0x83,0x9c},
	{0x83,0x6c}, {0x83,0x4c}, {0x83,0x2c}, {0x83,0x0c},
	{0x82,0xec}, {0x82,0xcc}, {0x82,0xac}, {0x82,0x8c},
	{0x82,0x6c}, {0x82,0x4c}, {0x82,0x2c}, {0x82,0x0c},
	{0x81,0xec}, {0x81,0xcc}, {0x81,0xac}, {0x81,0x8c},
	{0x81,0x74}, {0x81,0x64}, {0x81,0x54}, {0x81,0x44},
	{0x81,0x34}, {0x81,0x24}, {0x81,0x14}, {0x81,0x04},
	{0x80,0xf4}, {0x80,0xe4}, {0x80,0xd4}, {0x80,0xc4},
	{0x80,0xb4}, {0x80,0xa4}, {0x80,0x94}, {0x80,0x84},
	{0x80,0x78}, {0x80,0x70}, {0x80,0x68}, {0x80,0x60},
	{0x80,0x58}, {0x80,0x50}, {0x80,0x48}, {0x80,0x40},
	{0x80,0x38}, {0x80,0x30}, {0x80,0x28}, {0x80,0x20},
	{0x80,0x18}, {0x80,0x10}, {0x80,0x08}, {0x80,0x00},
};

const u_char alawtolin16[256][2] = {
	{0x6a,0x80}, {0x6b,0x80}, {0x68,0x80}, {0x69,0x80},
	{0x6e,0x80}, {0x6f,0x80}, {0x6c,0x80}, {0x6d,0x80},
	{0x62,0x80}, {0x63,0x80}, {0x60,0x80}, {0x61,0x80},
	{0x66,0x80}, {0x67,0x80}, {0x64,0x80}, {0x65,0x80},
	{0x75,0x40}, {0x75,0xc0}, {0x74,0x40}, {0x74,0xc0},
	{0x77,0x40}, {0x77,0xc0}, {0x76,0x40}, {0x76,0xc0},
	{0x71,0x40}, {0x71,0xc0}, {0x70,0x40}, {0x70,0xc0},
	{0x73,0x40}, {0x73,0xc0}, {0x72,0x40}, {0x72,0xc0},
	{0x2a,0x00}, {0x2e,0x00}, {0x22,0x00}, {0x26,0x00},
	{0x3a,0x00}, {0x3e,0x00}, {0x32,0x00}, {0x36,0x00},
	{0x0a,0x00}, {0x0e,0x00}, {0x02,0x00}, {0x06,0x00},
	{0x1a,0x00}, {0x1e,0x00}, {0x12,0x00}, {0x16,0x00},
	{0x55,0x00}, {0x57,0x00}, {0x51,0x00}, {0x53,0x00},
	{0x5d,0x00}, {0x5f,0x00}, {0x59,0x00}, {0x5b,0x00},
	{0x45,0x00}, {0x47,0x00}, {0x41,0x00}, {0x43,0x00},
	{0x4d,0x00}, {0x4f,0x00}, {0x49,0x00}, {0x4b,0x00},
	{0x7e,0xa8}, {0x7e,0xb8}, {0x7e,0x88}, {0x7e,0x98},
	{0x7e,0xe8}, {0x7e,0xf8}, {0x7e,0xc8}, {0x7e,0xd8},
	{0x7e,0x28}, {0x7e,0x38}, {0x7e,0x08}, {0x7e,0x18},
	{0x7e,0x68}, {0x7e,0x78}, {0x7e,0x48}, {0x7e,0x58},
	{0x7f,0xa8}, {0x7f,0xb8}, {0x7f,0x88}, {0x7f,0x98},
	{0x7f,0xe8}, {0x7f,0xf8}, {0x7f,0xc8}, {0x7f,0xd8},
	{0x7f,0x28}, {0x7f,0x38}, {0x7f,0x08}, {0x7f,0x18},
	{0x7f,0x68}, {0x7f,0x78}, {0x7f,0x48}, {0x7f,0x58},
	{0x7a,0xa0}, {0x7a,0xe0}, {0x7a,0x20}, {0x7a,0x60},
	{0x7b,0xa0}, {0x7b,0xe0}, {0x7b,0x20}, {0x7b,0x60},
	{0x78,0xa0}, {0x78,0xe0}, {0x78,0x20}, {0x78,0x60},
	{0x79,0xa0}, {0x79,0xe0}, {0x79,0x20}, {0x79,0x60},
	{0x7d,0x50}, {0x7d,0x70}, {0x7d,0x10}, {0x7d,0x30},
	{0x7d,0xd0}, {0x7d,0xf0}, {0x7d,0x90}, {0x7d,0xb0},
	{0x7c,0x50}, {0x7c,0x70}, {0x7c,0x10}, {0x7c,0x30},
	{0x7c,0xd0}, {0x7c,0xf0}, {0x7c,0x90}, {0x7c,0xb0},
	{0x95,0x80}, {0x94,0x80}, {0x97,0x80}, {0x96,0x80},
	{0x91,0x80}, {0x90,0x80}, {0x93,0x80}, {0x92,0x80},
	{0x9d,0x80}, {0x9c,0x80}, {0x9f,0x80}, {0x9e,0x80},
	{0x99,0x80}, {0x98,0x80}, {0x9b,0x80}, {0x9a,0x80},
	{0x8a,0xc0}, {0x8a,0x40}, {0x8b,0xc0}, {0x8b,0x40},
	{0x88,0xc0}, {0x88,0x40}, {0x89,0xc0}, {0x89,0x40},
	{0x8e,0xc0}, {0x8e,0x40}, {0x8f,0xc0}, {0x8f,0x40},
	{0x8c,0xc0}, {0x8c,0x40}, {0x8d,0xc0}, {0x8d,0x40},
	{0xd6,0x00}, {0xd2,0x00}, {0xde,0x00}, {0xda,0x00},
	{0xc6,0x00}, {0xc2,0x00}, {0xce,0x00}, {0xca,0x00},
	{0xf6,0x00}, {0xf2,0x00}, {0xfe,0x00}, {0xfa,0x00},
	{0xe6,0x00}, {0xe2,0x00}, {0xee,0x00}, {0xea,0x00},
	{0xab,0x00}, {0xa9,0x00}, {0xaf,0x00}, {0xad,0x00},
	{0xa3,0x00}, {0xa1,0x00}, {0xa7,0x00}, {0xa5,0x00},
	{0xbb,0x00}, {0xb9,0x00}, {0xbf,0x00}, {0xbd,0x00},
	{0xb3,0x00}, {0xb1,0x00}, {0xb7,0x00}, {0xb5,0x00},
	{0x81,0x58}, {0x81,0x48}, {0x81,0x78}, {0x81,0x68},
	{0x81,0x18}, {0x81,0x08}, {0x81,0x38}, {0x81,0x28},
	{0x81,0xd8}, {0x81,0xc8}, {0x81,0xf8}, {0x81,0xe8},
	{0x81,0x98}, {0x81,0x88}, {0x81,0xb8}, {0x81,0xa8},
	{0x80,0x58}, {0x80,0x48}, {0x80,0x78}, {0x80,0x68},
	{0x80,0x18}, {0x80,0x08}, {0x80,0x38}, {0x80,0x28},
	{0x80,0xd8}, {0x80,0xc8}, {0x80,0xf8}, {0x80,0xe8},
	{0x80,0x98}, {0x80,0x88}, {0x80,0xb8}, {0x80,0xa8},
	{0x85,0x60}, {0x85,0x20}, {0x85,0xe0}, {0x85,0xa0},
	{0x84,0x60}, {0x84,0x20}, {0x84,0xe0}, {0x84,0xa0},
	{0x87,0x60}, {0x87,0x20}, {0x87,0xe0}, {0x87,0xa0},
	{0x86,0x60}, {0x86,0x20}, {0x86,0xe0}, {0x86,0xa0},
	{0x82,0xb0}, {0x82,0x90}, {0x82,0xf0}, {0x82,0xd0},
	{0x82,0x30}, {0x82,0x10}, {0x82,0x70}, {0x82,0x50},
	{0x83,0xb0}, {0x83,0x90}, {0x83,0xf0}, {0x83,0xd0},
	{0x83,0x30}, {0x83,0x10}, {0x83,0x70}, {0x83,0x50},
};

void
mulaw_to_slinear16_le(u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[1] = mulawtolin16[*p][0] ^ 0x80;
		q[0] = mulawtolin16[*p][1];
	}
}

void
alaw_to_slinear16_le(u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[1] = alawtolin16[*p][0] ^ 0x80;
		q[0] = alawtolin16[*p][1];
	}
}


d70 1
a70 1
	int is_ulaw, is_alaw, wav_fmt;
d95 1
a95 1
		    wav_readhdr(fd, &apar, &datasz, &wav_fmt)) {
a111 1
	is_ulaw = is_alaw = 0;
a118 10
		if (wav_fmt == 6 || wav_fmt == 7) {
			if (wav_fmt == 6)
				is_alaw = 1;
			else if (wav_fmt == 7)
				is_ulaw = 1;
			par.sig = 1;
			par.bits = 16;
			par.le = 1;
		} else if (wav_fmt != 1)
			warnx("format not supported");
d126 1
a126 1
		is_ulaw = 1;
d128 1
a128 1
			is_alaw = 1;
d167 1
a167 1
	if (is_ulaw || is_alaw)
d170 2
a171 5
		if (is_ulaw) {
			mulaw_to_slinear16_le(buf, rd);
			rd *= 2;
		} else if (is_alaw) {
			alaw_to_slinear16_le(buf, rd);
@


1.4
log
@set the default device to /dev/audio for legacy mode.
From Thomas Pfaff <tpfaff _at_ agderlink.no> and tweaks from me
@
text
@d1 1
a1 1
/*	$OpenBSD: legacy.c,v 1.3 2008/10/26 08:49:44 ratchov Exp $	*/
d31 1
a31 3
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/audioio.h>
d41 169
a226 68
/*
 * Convert sun device parameters to struct aparams
 */
int
sun_infotopar(struct audio_prinfo *ai, struct aparams *par)
{
	par->rate = ai->sample_rate;
	par->bps = ai->precision / 8;
	par->bits = ai->precision;
	par->cmax = par->cmin + ai->channels - 1;
	if (par->cmax > NCHAN_MAX - 1) {
		warnx("%u:%u: channel range out of bounds",
		    par->cmin, par->cmax);
		return 0;
	}
	par->msb = 1;
	switch (ai->encoding) {
	case AUDIO_ENCODING_SLINEAR_LE:
		par->le = 1;
		par->sig = 1;
		break;
	case AUDIO_ENCODING_SLINEAR_BE:
		par->le = 0;
		par->sig = 1;
		break;
	case AUDIO_ENCODING_ULINEAR_LE:
		par->le = 1;
		par->sig = 0;
		break;
	case AUDIO_ENCODING_ULINEAR_BE:
		par->le = 0;
		par->sig = 0;
		break;
	case AUDIO_ENCODING_SLINEAR:
		par->le = NATIVE_LE;
		par->sig = 1;
		break;
	case AUDIO_ENCODING_ULINEAR:
		par->le = NATIVE_LE;
		par->sig = 0;
		break;
	default:
		warnx("only linear encodings are supported for audio devices");
		return 0;
	}
	return 1;
}

/*
 * Convert struct aparams to sun device parameters.
 */
void
sun_partoinfo(struct audio_prinfo *ai, struct aparams *par)
{
	ai->sample_rate = par->rate;
	ai->precision = par->bps * 8;
	ai->channels = par->cmax - par->cmin + 1;
	if (par->le && par->sig) {
		ai->encoding = AUDIO_ENCODING_SLINEAR_LE;
	} else if (!par->le && par->sig) {
		ai->encoding = AUDIO_ENCODING_SLINEAR_BE;
	} else if (par->le && !par->sig) {
		ai->encoding = AUDIO_ENCODING_ULINEAR_LE;
	} else {
		ai->encoding = AUDIO_ENCODING_ULINEAR_BE;
	}
}

d230 3
a232 3
	struct audio_prinfo ai;
	struct audio_info info;
	struct aparams par;
d236 3
a238 2
	int afd, fd, fmt = FMT_RAW;
	u_int32_t pos = 0;
d240 1
d255 9
d265 1
a265 1
		    wav_readhdr(fd, &par, &datasz)) {
d275 3
a277 7
	if (dev == NULL) {
		dev = getenv("AUDIODEVICE");
		if (dev == NULL)
			dev = "/dev/audio";
	}
	if ((afd = open(dev, O_WRONLY)) < 0) {
		warn("can't open %s", dev);
d281 2
a282 3
	AUDIO_INITINFO(&info);
	ai = info.play;

d285 15
a299 1
		sun_partoinfo(&ai, &par);
d302 8
a309 4
		ai.encoding = AUDIO_ENCODING_ULAW;
		ai.precision = 8;
		ai.sample_rate = 8000;
		ai.channels = 1;
d315 1
d317 2
a318 3
	info.play = ai;
	if (ioctl(afd, AUDIO_SETINFO, &info) < 0) {
		warn("%s", dev);
d331 4
a334 4
	(void) ioctl(afd, AUDIO_GETINFO, &info);
	if (info.play.encoding != ai.encoding ||
	    info.play.precision != ai.precision ||
	    info.play.channels != ai.channels ||
d339 6
a344 3
	    (info.play.sample_rate > ai.sample_rate * 1.02 ||
	    info.play.sample_rate < ai.sample_rate * 0.98)) {
		warnx("format not supported by %s", dev);
d347 14
a360 3
	while ((rd = read(fd, buf, sizeof(buf))) > 0)
		if (write(afd, buf, rd) != rd)
			warn("write");
d364 1
a364 1
	(void) close(afd);
@


1.3
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: legacy.c,v 1.2 2008/08/14 09:58:55 ratchov Exp $	*/
d35 1
d165 5
a169 1

@


1.2
log
@move all device related stuff from aucat.c to a new dev.c file.
The new dev_xxx() routines expose a "high level" self-contained
interface to the device. At initialization, the device is opened
and two chains of aproc structures are created:

 * a playback chain that exposes a (initially) empty mix
   aproc to which the rest of the code can attach new
   streams to be played

 * record chain that exposes a (initially) empty sub aproc
   to which the rest of the code can attach new stream to
   to record

The rest of the code, has just to use dev_attach() routine to
attach streams. While we're at it, add a ``devops'' structure
containing pointers to the device-specific routines. This will
allow later to add support for other type of device than the
Sun API.

Also, write the .wav headers in file_del(), so put all header
related data in the file strucuture. This allows to close() the
file, as soon as wpipe_xxx() aproc terminates. This will be
useful for the server, because it will need to close() descripts
of closed connections immediately.

add mix_pushzero() routine to fill the mixer with silence. It
will be used to avoid the mixer to underrun when there are no
input streams. Since we always have at least one input stream
there's no behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: legacy.c,v 1.1 2008/05/23 07:15:46 ratchov Exp $	*/
d40 1
a40 3
#include "file.h"
#include "aparams.h"
#include "dev.h"
d58 68
@


1.1
log
@add support for:
 - recording, full-duplex operation
 - format conversions and resampling on the fly
 - mixing on the fly of multiple inputs of different formats
 - up to 16 channels, simplistic "routing" of channel ranges
 - more linear encodings (in raw and wav files)
the old behaviour is fully preserved if none of the new -i and -o
options are used.

code and fixes from jakemsr@@ and eric@@, suggestions by others.
ok "go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 4
d36 1
@

