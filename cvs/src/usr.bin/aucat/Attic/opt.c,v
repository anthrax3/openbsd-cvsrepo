head	1.15;
access;
symbols
	OPENBSD_5_4:1.14.0.6
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.4
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.10.0.6
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.4
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.15
date	2013.11.12.06.47.34;	author ratchov;	state dead;
branches;
next	1.14;

1.14
date	2012.06.27.06.53.13;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2011.11.15.08.05.22;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2011.10.12.07.20.04;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.06.01.12.45;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.04.06.15.28;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.21.06.13.07;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.10.21.47.41;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.03.21.31.37;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.27.11.51.20;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.15
log
@remove bogus legacy server-specific bits that cause confusion
@
text
@/*	$OpenBSD: opt.c,v 1.14 2012/06/27 06:53:13 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "dev.h"
#include "conf.h"
#include "opt.h"
#ifdef DEBUG
#include "dbg.h"
#endif

struct opt *opt_list = NULL;

struct opt *
opt_new(char *name, struct dev *dev,
    struct aparams *wpar, struct aparams *rpar,
    int maxweight, int mmc, int join, unsigned int mode)
{
	struct opt *o, **po;
	unsigned int len;
	char c;

	for (len = 0; name[len] != '\0'; len++) {
		if (len == OPT_NAMEMAX)
		    errx(1, "%s: name too long", name);
		c = name[len];
		if ((c < 'a' || c > 'z') &&
		    (c < 'A' || c > 'Z'))
			errx(1, "%s: '%c' not allowed", name, c);
	}
	o = malloc(sizeof(struct opt));
	if (o == NULL)
		err(1, "opt_new: malloc");
	if (mode & MODE_RECMASK)
		o->wpar = (mode & MODE_MON) ? *rpar : *wpar;
	if (mode & MODE_PLAY)
		o->rpar = *rpar;
	o->maxweight = maxweight;
	o->mmc = mmc;
	o->join = join;
	o->mode = mode;
	o->dev = dev;
	memcpy(o->name, name, len + 1);
	for (po = &opt_list; *po != NULL; po = &(*po)->next) {
		if (o->dev->num == (*po)->dev->num &&
		    strcmp(o->name, (*po)->name) == 0)
			errx(1, "%s: already defined", o->name);
	}
	o->next = NULL;
	*po = o;
#ifdef DEBUG
	if (debug_level >= 2) {
		dev_dbg(o->dev);
		dbg_puts(".");
		dbg_puts(o->name);
		dbg_puts(":");
		if (o->mode & MODE_REC) {
			dbg_puts(" rec=");
			dbg_putu(o->wpar.cmin);
			dbg_puts(":");
			dbg_putu(o->wpar.cmax);
		}
		if (o->mode & MODE_PLAY) {
			dbg_puts(" play=");
			dbg_putu(o->rpar.cmin);
			dbg_puts(":");
			dbg_putu(o->rpar.cmax);
			dbg_puts(" vol=");
			dbg_putu(o->maxweight);
		}
		if (o->mode & MODE_MON) {
			dbg_puts(" mon=");
			dbg_putu(o->wpar.cmin);
			dbg_puts(":");
			dbg_putu(o->wpar.cmax);
		}
		if (o->mode & (MODE_RECMASK | MODE_PLAY)) {
			if (o->mmc)
				dbg_puts(" mmc");
			if (o->join)
				dbg_puts(" join");
		}
		if (o->mode & MODE_MIDIIN)
			dbg_puts(" midi/in");
		if (o->mode & MODE_MIDIOUT)
			dbg_puts(" midi/out");
		dbg_puts("\n");
	}
#endif
	return o;
}

struct opt *
opt_byname(char *name, unsigned int num)
{
	struct opt *o;

	for (o = opt_list; o != NULL; o = o->next) {
		if (o->dev->num != num)
			continue;
		if (strcmp(name, o->name) == 0)
			return o;
	}
	return NULL;
}

@


1.14
log
@Uniformize error messages printing, use err() instead of fprintf()
when appropriate. From Michael W. Bombardieri <mb at ii.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: opt.c,v 1.13 2012/04/11 06:05:43 ratchov Exp $	*/
@


1.13
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opt.c,v 1.12 2011/11/15 08:05:22 ratchov Exp $	*/
d17 1
d41 2
a42 4
		if (len == OPT_NAMEMAX) {
			fprintf(stderr, "%s: name too long\n", name);
			exit(1);
		}
d45 2
a46 4
		    (c < 'A' || c > 'Z')) {
			fprintf(stderr, "%s: '%c' not allowed\n", name, c);
			exit(1);
		}
d49 2
a50 4
	if (o == NULL) {
		perror("opt_new: malloc");
		exit(1);
	}
d63 2
a64 4
		    strcmp(o->name, (*po)->name) == 0) {
			fprintf(stderr, "%s: already defined\n", o->name);
			exit(1);
		}
@


1.12
log
@Add a "device number" component in sndio(7) device names, allowing a
single aucat instance to handle all audio and MIDI services. Since
this partially breaks compatibility, this is a opportunitiy to fix few
other design mistakes (eg ':' being used by inet6, type name vs api
name confusion, etc..). This leads to the following names:

        type[@@hostname][,unit]/devnum[.option]

The device number is the minor device number for direct hardware
access (ie the 'N' in /dev/audioN). For aucat, this is the occurence
number of the -f (or -M) option.

There's a compatibility hook to keep old names working if only one
aucat server is running.
@
text
@d1 1
a1 1
/*	$OpenBSD: opt.c,v 1.11 2011/10/12 07:20:04 ratchov Exp $	*/
d33 1
a33 1
    int maxweight, int mmc, int join, unsigned mode)
d36 1
a36 1
	unsigned len;
d118 1
a118 1
opt_byname(char *name, unsigned num)
@


1.11
log
@Simplify and improve the way options are parsed and remove ~300 lines
of code that becomes unused. Few command line arguments changes are
required though:

  - stream definitions (-ios) now must follow devices definitions they
    are attached to (-fMn)

  - the -n option is now a special "loopback" device and is thus used
    like -f, eg it must precede streams

  - in midicat, midi thru boxes are not created automatically anymore,
    the new "-M" option must be used for that

  - channel numbers (-Cc options) correspond always to channel numbers
    of the hardware.

  - the -u option isn't needed anymore

  - increase the log verbosity so user errors are logged
    without using -d

tested by many, help from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: opt.c,v 1.10 2010/07/06 01:12:45 ratchov Exp $	*/
d31 2
a32 1
opt_new(char *name, struct dev *dev, struct aparams *wpar, struct aparams *rpar,
d45 2
a46 4
		if (c < 'a' && c > 'z' &&
		    c < 'A' && c > 'Z' &&
		    c < '0' && c > '9' && 
		    c != '_') {
a55 1
	memcpy(o->name, name, len + 1);
d65 1
d67 2
a68 1
		if (strcmp(o->name, (*po)->name) == 0) {
d77 2
a79 2
		dbg_puts("@@");
		dbg_puts(o->dev->path);
d118 1
a118 1
opt_byname(char *name)
d123 3
a125 7
		if (strcmp(name, o->name) == 0) {
#ifdef DEBUG
			if (debug_level >= 3) {
				dbg_puts(o->name);
				dbg_puts(": option found\n");
			}
#endif
a126 6
		}
	}
#ifdef DEBUG
	if (debug_level >= 3) {
		dbg_puts(name);
		dbg_puts(": option not found\n");
a127 1
#endif
@


1.10
log
@Handle all streams the same way because there's no actual
difference between audio files and client connections. Clean up
the way command line options are handled and clarify this in the
manual page: stream parameters (-Ccehjmrtvx) must precede stream
definitions (-ios) and per-device parameters (-abz) and stream
definitions (-ios) must precede device definitions (-f). Since
there's no ``server'' and ``non-server'' modes anymore, make the
-l option just detach the process.

ok and help from jakemsr and jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: opt.c,v 1.9 2010/06/04 06:15:28 ratchov Exp $	*/
d28 1
a28 1
struct optlist opt_list = SLIST_HEAD_INITIALIZER(&opt_list);
d30 2
a31 2
void
opt_new(char *name, struct dev *d, struct aparams *wpar, struct aparams *rpar,
d34 1
a34 1
	struct opt *o;
a51 6
	SLIST_FOREACH(o, &opt_list, entry) {
		if (strcmp(name, o->name) == 0) {
			fprintf(stderr, "%s: already defined\n", name);
			exit(1);
		}
	}
d66 9
a74 1
	o->dev = d;
d81 1
a81 1
		if (mode & MODE_REC) {
d87 1
a87 1
		if (mode & MODE_PLAY) {
d95 1
a95 1
		if (mode & MODE_MON) {
d101 10
a110 2
		if (o->mmc)
			dbg_puts(" mmc");
d114 1
a114 1
	SLIST_INSERT_HEAD(&opt_list, o, entry);
d122 1
a122 1
	SLIST_FOREACH(o, &opt_list, entry) {
@


1.9
log
@Allow the audio device to be opened only while it's actually used.
This is necessary for uaudio devices, for instance to start aucat
before the device is plugged. Or to unplug a device whithout
having to restart aucat when another device is plugged.  This is
controlled with the new -a option.

Allow multiple audio devices to be used concurently, i.e.
multiple ``-f devname'' options to be used; -f options must follow
per-device options, which is what we do for other options.
@
text
@d1 1
a1 1
/*	$OpenBSD: opt.c,v 1.8 2010/04/21 06:13:07 ratchov Exp $	*/
d21 1
d76 2
@


1.8
log
@adds the necessary bits to join channels (ex stereo->mono) or
expand channels (ex mono->stereo).  It's switched on/off with
the ``-j'' option, (default is "on").
@
text
@d1 1
a1 1
/*	$OpenBSD: opt.c,v 1.7 2010/04/06 20:07:01 ratchov Exp $	*/
d30 1
a30 1
opt_new(char *name, struct aparams *wpar, struct aparams *rpar,
d51 6
d71 1
@


1.7
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opt.c,v 1.6 2010/04/03 17:59:17 ratchov Exp $	*/
d31 1
a31 1
    int maxweight, int mmc, unsigned mode)
d63 1
@


1.6
log
@backout last change, committed by mistake, sorry...
@
text
@d1 1
a1 1
/*	$OpenBSD: opt.c,v 1.4 2010/01/10 21:47:41 ratchov Exp $	*/
d30 2
a31 2
opt_new(char *name,
    struct aparams *wpar, struct aparams *rpar, int maxweight, int mmc)
d57 4
a60 2
	o->wpar = *wpar;
	o->rpar = *rpar;
d63 1
d67 21
a87 6
		dbg_puts(": rec ");
		aparams_dbg(&o->wpar);
		dbg_puts(", play ");
		aparams_dbg(&o->rpar);
		dbg_puts(", vol ");
		dbg_putu(o->maxweight);
d89 1
a89 1
			dbg_puts(", mmc");
@


1.5
log
@doc fixes from jmc
@
text
@d30 2
a31 2
opt_new(char *name, struct aparams *wpar, struct aparams *rpar,
    int maxweight, int mmc, unsigned mode)
d57 2
a58 4
	if (mode & MODE_RECMASK)
		o->wpar = (mode & MODE_MON) ? *rpar : *wpar;
	if (mode & MODE_PLAY)
		o->rpar = *rpar;
a60 1
	o->mode = mode;
d64 6
a69 21
		dbg_puts(":");
		if (mode & MODE_REC) {
			dbg_puts(" rec=");
			dbg_putu(o->wpar.cmin);
			dbg_puts(":");
			dbg_putu(o->wpar.cmax);
		}
		if (mode & MODE_PLAY) {
			dbg_puts(" play=");
			dbg_putu(o->rpar.cmin);
			dbg_puts(":");
			dbg_putu(o->rpar.cmax);
			dbg_puts(" vol=");
			dbg_putu(o->maxweight);
		}
		if (mode & MODE_MON) {
			dbg_puts(" mon=");
			dbg_putu(o->wpar.cmin);
			dbg_puts(":");
			dbg_putu(o->wpar.cmax);
		}
d71 1
a71 1
			dbg_puts(" mmc");
@


1.4
log
@Add traces to help tracking subtle timing bugs often causing
underuns and overruns; such bugs are hard to debug with ktrace
or a debugger. They are also handy to debug or monitor code
using aucat.

To enable traces, compile aucat with ``make DEBUG=-DDEBUG'' and
use the -d option multiple times.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: opt.c,v 1.3 2009/11/03 21:31:37 ratchov Exp $	*/
d30 2
a31 2
opt_new(char *name,
    struct aparams *wpar, struct aparams *rpar, int maxweight, int mmc)
d57 4
a60 2
	o->wpar = *wpar;
	o->rpar = *rpar;
d63 1
d67 21
a87 6
		dbg_puts(": rec ");
		aparams_dbg(&o->wpar);
		dbg_puts(", play ");
		aparams_dbg(&o->rpar);
		dbg_puts(", vol ");
		dbg_putu(o->maxweight);
d89 1
a89 1
			dbg_puts(", mmc");
@


1.3
log
@Allow any program using aucat to act as MMC slave and MTC master
transparently.  Multiple audio applications can be started
synchronously from external software/hardware supporting the
standard Start/Stop/Relocate messages. The server clock is exposed
through MTC, allowing non-audio software/hardware to be
synchronized to audio applications.
@
text
@d1 1
a1 1
/*	$OpenBSD: opt.c,v 1.2 2009/09/27 11:51:20 ratchov Exp $	*/
d23 3
d61 14
d85 6
d94 6
@


1.2
log
@remove all debug traces
@
text
@d1 1
a1 1
/*	$OpenBSD: opt.c,v 1.1 2009/07/25 08:44:27 ratchov Exp $	*/
d27 2
a28 1
opt_new(char *name, struct aparams *wpar, struct aparams *rpar, int maxweight)
d57 1
@


1.1
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: listen.c,v 1.8 2009/02/04 20:35:14 ratchov Exp $	*/
a55 9
#ifdef DEBUG
	if (debug_level > 0) {
		fprintf(stderr, "opt_new: %s: wpar=", o->name);
		aparams_print(&o->wpar);
		fprintf(stderr, ", rpar=");
		aparams_print(&o->rpar);
		fprintf(stderr, ", vol=%u\n", o->maxweight);
	}
#endif
a65 1
			DPRINTF("opt_byname: %s found\n", o->name);
a68 1
	DPRINTF("opt_byname: %s not found\n", name);
@

