head	1.47;
access;
symbols
	OPENBSD_5_6:1.46.0.6
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.46.0.4
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.45.0.4
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.43.0.2
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.2
	OPENBSD_5_0:1.36.0.2
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.32.0.2
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16;
locks; strict;
comment	@ * @;


1.47
date	2015.01.21.08.43.55;	author ratchov;	state dead;
branches;
next	1.46;
commitid	SYQcoS9jhSKqSJDL;

1.46
date	2013.11.18.17.37.45;	author ratchov;	state Exp;
branches;
next	1.45;

1.45
date	2012.10.27.08.31.59;	author ratchov;	state Exp;
branches;
next	1.44;

1.44
date	2012.09.25.20.12.34;	author ratchov;	state Exp;
branches;
next	1.43;

1.43
date	2012.04.25.07.21.41;	author ratchov;	state Exp;
branches;
next	1.42;

1.42
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.41;

1.41
date	2012.03.23.11.59.54;	author ratchov;	state Exp;
branches;
next	1.40;

1.40
date	2011.12.02.10.34.50;	author ratchov;	state Exp;
branches;
next	1.39;

1.39
date	2011.11.20.22.54.51;	author ratchov;	state Exp;
branches;
next	1.38;

1.38
date	2011.11.15.20.41.54;	author ratchov;	state Exp;
branches;
next	1.37;

1.37
date	2011.10.12.07.20.04;	author ratchov;	state Exp;
branches;
next	1.36;

1.36
date	2011.06.27.07.57.38;	author ratchov;	state Exp;
branches;
next	1.35;

1.35
date	2011.06.27.07.17.44;	author ratchov;	state Exp;
branches;
next	1.34;

1.34
date	2011.06.02.18.50.39;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2011.05.09.18.03.08;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2010.11.20.05.12.38;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2010.11.14.13.51.27;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2010.10.21.19.10.52;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2010.10.21.18.57.42;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2010.07.06.01.12.45;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.05.16.05.17;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.04.07.02.59;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.04.06.15.28;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2010.05.08.15.35.45;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2010.05.07.07.07.51;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.06.06.18.37;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.02.11.54.26;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.24.06.18.23;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.16.23.21.56;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.16.23.18.31;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.10.21.47.41;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.03.21.31.37;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.22.41.03;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.10.12.43.09;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.09.16.49.48;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.27.11.51.20;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.29.14.46.44;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2009.08.27.06.31.13;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2009.08.26.08.28.21;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2009.08.26.06.10.15;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2009.08.23.13.40.45;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.21.16.48.03;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.19.05.54.15;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Simplify internals and rewrite file header parsing code:
- remove -M, -t, -w, -C, -x flags that don't make sense anymore
- make "-j off" the default (sndiod already does the job)
- don't limit the number of played/recorded files.
- add support for floating-point encoded files.
- add support for apple .aiff and sun/next .au files
@
text
@/*	$OpenBSD: midi.c,v 1.46 2013/11/18 17:37:45 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * TODO
 *
 * use shadow variables (to save NRPNs, LSB of controller) 
 * in the midi merger
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "abuf.h"
#include "aproc.h"
#include "conf.h"
#include "dev.h"
#include "midi.h"
#include "sysex.h"
#ifdef DEBUG
#include "dbg.h"
#endif

/*
 * input data rate is XFER / TIMO (in bytes per microsecond),
 * it must be slightly larger than the MIDI standard 3125 bytes/s
 */ 
#define MIDITHRU_XFER 340
#define MIDITHRU_TIMO 100000

/*
 * masks to extract command and channel of status byte
 */
#define MIDI_CMDMASK	0xf0
#define MIDI_CHANMASK	0x0f

/*
 * MIDI status bytes of voice messages
 */
#define MIDI_NOFF	0x80		/* note off */
#define MIDI_NON	0x90		/* note on */
#define MIDI_KAT	0xa0		/* key after touch */
#define MIDI_CTL	0xb0		/* controller */
#define MIDI_PC		0xc0		/* program change */
#define MIDI_CAT	0xd0		/* channel after touch */
#define MIDI_BEND	0xe0		/* pitch bend */
#define MIDI_ACK	0xfe		/* active sensing message */

/*
 * MIDI controller numbers
 */
#define MIDI_CTLVOL	7		/* volume */
#define MIDI_CTLPAN	11		/* pan */

void midi_cb(void *);
void midi_msg_info(struct aproc *, int, unsigned char *);
void midi_msg_vol(struct aproc *, int, unsigned char *);
void midi_msg_master(struct aproc *, unsigned char *);
void midi_copy(struct abuf *, struct abuf *, unsigned char *, unsigned int);
void midi_send(struct aproc *, struct abuf *, unsigned char *, unsigned int);
void midi_copy_dump(struct aproc *, struct abuf *);
void midi_onvoice(struct aproc *, struct abuf *);
void midi_onsysex(struct aproc *, struct abuf *);
int midi_in(struct aproc *, struct abuf *);
int midi_out(struct aproc *, struct abuf *);
void midi_eof(struct aproc *, struct abuf *);
void midi_hup(struct aproc *, struct abuf *);
void midi_newin(struct aproc *, struct abuf *);
void midi_done(struct aproc *);

/*
 * length of voice and common messages (status byte included)
 */
unsigned int voice_len[] = { 3, 3, 3, 3, 2, 2, 3 };
unsigned int common_len[] = { 0, 2, 3, 2, 0, 0, 1, 1 };

/*
 * call-back invoked periodically to implement throttling; at each invocation
 * gain more ``tickets'' for processing.  If one of the buffer was blocked by
 * the throttling mechanism, then run it
 */
void
midi_cb(void *addr)
{
	struct aproc *p = (struct aproc *)addr;
	struct abuf *i, *inext;
	unsigned int tickets;

	timo_add(&p->u.midi.timo, MIDITHRU_TIMO);
	
	for (i = LIST_FIRST(&p->ins); i != NULL; i = inext) {
		inext = LIST_NEXT(i, ient);
		tickets = i->tickets;
		i->tickets = MIDITHRU_XFER;
		if (tickets == 0)
			abuf_run(i);
	}
}

void
midi_msg_info(struct aproc *p, int slot, unsigned char *msg)
{
	struct ctl_slot *s;
	struct sysex *x = (struct sysex *)msg;

	s = p->u.midi.dev->slot + slot;
	memset(x, 0, sizeof(struct sysex));
	x->start = SYSEX_START;
	x->type = SYSEX_TYPE_EDU;
	x->id0 = SYSEX_AUCAT;
	x->id1 = SYSEX_AUCAT_MIXINFO;
	if (*s->name != '\0') {
		snprintf((char *)x->u.mixinfo.name,
		    SYSEX_NAMELEN, "%s%u", s->name, s->unit);
	}
	x->u.mixinfo.chan = slot;
	x->u.mixinfo.end = SYSEX_END;
}

void
midi_msg_vol(struct aproc *p, int slot, unsigned char *msg)
{
	struct ctl_slot *s;

	s = p->u.midi.dev->slot + slot;	
	msg[0] = MIDI_CTL | slot;
	msg[1] = MIDI_CTLVOL;
	msg[2] = s->vol;
}

void
midi_msg_master(struct aproc *p, unsigned char *msg)
{
	struct sysex *x = (struct sysex *)msg;

	memset(x, 0, sizeof(struct sysex));
	x->start = SYSEX_START;
	x->type = SYSEX_TYPE_RT;
	x->id0 = SYSEX_CONTROL;
	x->id1 = SYSEX_MASTER;
	x->u.master.fine = 0;
	x->u.master.coarse = p->u.midi.dev->master;
	x->u.master.end = SYSEX_END;
}

/*
 * send a message to the given output
 */
void
midi_copy(struct abuf *ibuf, struct abuf *obuf, unsigned char *msg,
    unsigned int len)
{
	unsigned int ocount;
	unsigned char *odata;

	if (msg[0] == SYSEX_START)
		obuf->w.midi.owner = ibuf;
	while (len > 0) {
		if (!ABUF_WOK(obuf)) {
#ifdef DEBUG
			if (debug_level >= 3) {
				abuf_dbg(obuf);
				dbg_puts(": overrun, discarding ");
				dbg_putu(obuf->used);
				dbg_puts(" bytes\n");
			}
#endif
			abuf_rdiscard(obuf, obuf->used);
			if (obuf->w.midi.owner == ibuf)
				obuf->w.midi.owner = NULL;
			return;
		}
		odata = abuf_wgetblk(obuf, &ocount, 0);
		if (ocount > len)
			ocount = len;
#ifdef DEBUG
		if (debug_level >= 4) {
			abuf_dbg(obuf);
			dbg_puts(": stored ");
			dbg_putu(ocount);
			dbg_puts(" bytes\n");
		}
#endif
		memcpy(odata, msg, ocount);
		abuf_wcommit(obuf, ocount);
		len -= ocount;
		msg += ocount;
	}
}

/*
 * flush all buffers. Since most of the MIDI traffic is broadcasted to
 * all outputs, the flush is delayed to avoid flushing all outputs for
 * each message.
 */
void
midi_flush(struct aproc *p)
{
	struct abuf *i, *inext;

	for (i = LIST_FIRST(&p->outs); i != NULL; i = inext) {
		inext = LIST_NEXT(i, oent);
		if (ABUF_ROK(i))
			(void)abuf_flush(i);
	}
}

/*
 * broadcast a message to all output buffers on the behalf of ibuf.
 * ie. don't sent back the message to the sender
 */
void
midi_send(struct aproc *p, struct abuf *ibuf, unsigned char *msg,
    unsigned int len)
{
	struct abuf *i, *inext;

	for (i = LIST_FIRST(&p->outs); i != NULL; i = inext) {
		inext = LIST_NEXT(i, oent);
		if (i->duplex && i->duplex == ibuf)
			continue;
		midi_copy(ibuf, i, msg, len);
	}
}

/*
 * send a quarter frame MTC message
 */
void
midi_send_qfr(struct aproc *p, unsigned int rate, int delta)
{
	unsigned char buf[2];
	unsigned int data;
	int qfrlen;

	p->u.midi.delta += delta * MTC_SEC;
	qfrlen = rate * (MTC_SEC / (4 * p->u.midi.fps));
	while (p->u.midi.delta >= qfrlen) {
		switch (p->u.midi.qfr) {
		case 0:
			data = p->u.midi.fr & 0xf;
			break;
		case 1:
			data = p->u.midi.fr >> 4;
			break;
		case 2:
			data = p->u.midi.sec & 0xf;
			break;
		case 3:
			data = p->u.midi.sec >> 4;
			break;
		case 4:
			data = p->u.midi.min & 0xf;
			break;
		case 5:
			data = p->u.midi.min >> 4;
			break;
		case 6:
			data = p->u.midi.hr & 0xf;
			break;
		case 7:
			data = (p->u.midi.hr >> 4) | (p->u.midi.fps_id << 1);
			/*
			 * tick messages are sent 2 frames ahead
			 */
			p->u.midi.fr += 2;
			if (p->u.midi.fr < p->u.midi.fps)
				break;
			p->u.midi.fr -= p->u.midi.fps;
			p->u.midi.sec++;
			if (p->u.midi.sec < 60)
				break;
			p->u.midi.sec = 0;
			p->u.midi.min++;
			if (p->u.midi.min < 60)
				break;
			p->u.midi.min = 0;
			p->u.midi.hr++;
			if (p->u.midi.hr < 24)
				break;
			p->u.midi.hr = 0;
			break;
		default:
			/* NOTREACHED */
			data = 0;
		}
		buf[0] = 0xf1;
		buf[1] = (p->u.midi.qfr << 4) | data;
		p->u.midi.qfr++;
		p->u.midi.qfr &= 7;
		midi_send(p, NULL, buf, 2);
		p->u.midi.delta -= qfrlen;
	}
}

/*
 * send a full frame MTC message
 */
void
midi_send_full(struct aproc *p, unsigned int origin, unsigned int rate,
    unsigned int round, unsigned int pos)
{
	unsigned char buf[10];
	unsigned int fps;

	p->u.midi.delta = MTC_SEC * pos;
	if (rate % (30 * 4 * round) == 0) {
		p->u.midi.fps_id = MTC_FPS_30;
		p->u.midi.fps = 30;
	} else if (rate % (25 * 4 * round) == 0) {
		p->u.midi.fps_id = MTC_FPS_25;
		p->u.midi.fps = 25;
	} else {
		p->u.midi.fps_id = MTC_FPS_24;
		p->u.midi.fps = 24;
	}
#ifdef DEBUG
	if (debug_level >= 3) {
		aproc_dbg(p);
		dbg_puts(": mtc full frame at ");
		dbg_puti(p->u.midi.delta);
		dbg_puts(", ");
		dbg_puti(p->u.midi.fps);
		dbg_puts(" fps\n");
	}
#endif
	fps = p->u.midi.fps;
	p->u.midi.hr =  (origin / (3600 * MTC_SEC)) % 24;
	p->u.midi.min = (origin / (60 * MTC_SEC))   % 60;
	p->u.midi.sec = (origin / MTC_SEC)          % 60;
	p->u.midi.fr =  (origin / (MTC_SEC / fps))  % fps;

	buf[0] = 0xf0;
	buf[1] = 0x7f;
	buf[2] = 0x7f;
	buf[3] = 0x01;
	buf[4] = 0x01;
	buf[5] = p->u.midi.hr | (p->u.midi.fps_id << 5);
	buf[6] = p->u.midi.min;
	buf[7] = p->u.midi.sec;
	buf[8] = p->u.midi.fr;
	buf[9] = 0xf7;
	p->u.midi.qfr = 0;
	midi_send(p, NULL, buf, 10);
}

void
midi_copy_dump(struct aproc *p, struct abuf *obuf)
{
	unsigned int i;
	unsigned char msg[sizeof(struct sysex)];
	struct ctl_slot *s;

	midi_msg_master(p, msg);
	midi_copy(NULL, obuf, msg, SYSEX_SIZE(master));
	for (i = 0, s = p->u.midi.dev->slot; i < CTL_NSLOT; i++, s++) {
		midi_msg_info(p, i, msg);
		midi_copy(NULL, obuf, msg, SYSEX_SIZE(mixinfo));
		midi_msg_vol(p, i, msg);
		midi_copy(NULL, obuf, msg, 3);
	}
	msg[0] = SYSEX_START;
	msg[1] = SYSEX_TYPE_EDU;
	msg[2] = 0;
	msg[3] = SYSEX_AUCAT;
	msg[4] = SYSEX_AUCAT_DUMPEND;
	msg[5] = SYSEX_END;
	midi_copy(NULL, obuf, msg, 6);
}

/*
 * notifty the mixer that volume changed, called by whom allocated the slot using
 * ctl_slotnew(). Note: it doesn't make sense to call this from within the
 * call-back.
 */
void
midi_send_vol(struct aproc *p, int slot, unsigned int vol)
{
	unsigned char msg[3];

	midi_msg_vol(p, slot, msg);
	midi_send(p, NULL, msg, 3);
}

void
midi_send_master(struct aproc *p)
{
	unsigned char msg[sizeof(struct sysex)];
	
	midi_msg_master(p, msg);
	midi_send(p, NULL, msg, SYSEX_SIZE(master));
}

void
midi_send_slot(struct aproc *p, int slot)
{
	unsigned char msg[sizeof(struct sysex)];

	midi_msg_info(p, slot, msg);
	midi_send(p, NULL, msg, SYSEX_SIZE(mixinfo));
}

/*
 * handle a MIDI voice event received from ibuf
 */
void
midi_onvoice(struct aproc *p, struct abuf *ibuf)
{
	struct ctl_slot *slot;
	unsigned int chan;
#ifdef DEBUG
	unsigned int i;

	if (debug_level >= 3) {
		abuf_dbg(ibuf);
		dbg_puts(": got voice event:");
		for (i = 0; i < ibuf->r.midi.idx; i++) {
			dbg_puts(" ");
			dbg_putx(ibuf->r.midi.msg[i]);
		}
		dbg_puts("\n");
	}
#endif
	if ((ibuf->r.midi.msg[0] & MIDI_CMDMASK) == MIDI_CTL &&
	    (ibuf->r.midi.msg[1] == MIDI_CTLVOL)) {
		midi_send(p, ibuf, ibuf->r.midi.msg, 3);
		chan = ibuf->r.midi.msg[0] & MIDI_CHANMASK;
		if (chan >= CTL_NSLOT)
			return;
		slot = p->u.midi.dev->slot + chan;
		slot->vol = ibuf->r.midi.msg[2];
		if (slot->ops == NULL)
			return;
		slot->ops->vol(slot->arg, slot->vol);
	}
}

/*
 * handle a MIDI sysex received from ibuf
 */
void
midi_onsysex(struct aproc *p, struct abuf *ibuf)
{
	struct sysex *x;
	unsigned int fps, len;
#ifdef DEBUG
	unsigned int i;

	if (debug_level >= 3) {
		abuf_dbg(ibuf);
		dbg_puts(": got sysex:");
		for (i = 0; i < ibuf->r.midi.idx; i++) {
			dbg_puts(" ");
			dbg_putx(ibuf->r.midi.msg[i]);
		}
		dbg_puts("\n");
	}
#endif
	x = (struct sysex *)ibuf->r.midi.msg;
	len = ibuf->r.midi.idx;
	if (x->start != SYSEX_START)
		return;
	if (len < SYSEX_SIZE(empty))
		return;
	switch (x->type) {
	case SYSEX_TYPE_RT:
		if (x->id0 == SYSEX_CONTROL && x->id1 == SYSEX_MASTER) {
			if (len == SYSEX_SIZE(master)) {
				dev_master(p->u.midi.dev, x->u.master.coarse);
				midi_send(p, ibuf, (unsigned char *)x, len);
			}
			return;
		}
		if (x->id0 != SYSEX_MMC)
			return;
		switch (x->id1) {
		case SYSEX_MMC_STOP:
			if (len != SYSEX_SIZE(stop))
				return;
#ifdef DEBUG
			if (debug_level >= 3) {
				abuf_dbg(ibuf);
				dbg_puts(": mmc stop\n");
			}
#endif
			dev_mmcstop(p->u.midi.dev);
			break;
		case SYSEX_MMC_START:
			if (len != SYSEX_SIZE(start))
				return;
#ifdef DEBUG
			if (debug_level >= 3) {
				abuf_dbg(ibuf);
				dbg_puts(": mmc start\n");
			}
#endif
			dev_mmcstart(p->u.midi.dev);
			break;
		case SYSEX_MMC_LOC:
			if (len != SYSEX_SIZE(loc) ||
			    x->u.loc.len != SYSEX_MMC_LOC_LEN ||
			    x->u.loc.cmd != SYSEX_MMC_LOC_CMD)
				return;
			switch (x->u.loc.hr >> 5) {
			case MTC_FPS_24:
				fps = 24;
				break;
			case MTC_FPS_25:
				fps = 25;
				break;
			case MTC_FPS_30:
				fps = 30;
				break;
			default:
				/* XXX: should dev_mmcstop() here */
				return;
			}
			dev_loc(p->u.midi.dev,
			    (x->u.loc.hr & 0x1f) * 3600 * MTC_SEC +
			     x->u.loc.min * 60 * MTC_SEC +
			     x->u.loc.sec * MTC_SEC +
			     x->u.loc.fr * (MTC_SEC / fps) +
			     x->u.loc.cent * (MTC_SEC / 100 / fps));
			break;
		}
		break;
	case SYSEX_TYPE_EDU:
		if (x->id0 != SYSEX_AUCAT || x->id1 != SYSEX_AUCAT_DUMPREQ)
			return;
		if (len != SYSEX_SIZE(dumpreq))
			return;
		if (ibuf->duplex)
			midi_copy_dump(p, ibuf->duplex);
		break;
	}
}

int
midi_in(struct aproc *p, struct abuf *ibuf)
{
	unsigned char c, *idata;
	unsigned int i, icount;

	if (!ABUF_ROK(ibuf))
		return 0;
	if (ibuf->tickets == 0) {
#ifdef DEBUG
		if (debug_level >= 4) {
			abuf_dbg(ibuf);
			dbg_puts(": out of tickets, blocking\n");
		}
#endif
		return 0;
	}
	idata = abuf_rgetblk(ibuf, &icount, 0);
	if (icount > ibuf->tickets)
		icount = ibuf->tickets;
	ibuf->tickets -= icount;
	for (i = 0; i < icount; i++) {
		c = *idata++;
		if (c >= 0xf8) {
			if (!p->u.midi.dev && c != MIDI_ACK)
				midi_send(p, ibuf, &c, 1);
		} else if (c == SYSEX_END) {
			if (ibuf->r.midi.st == SYSEX_START) {
				ibuf->r.midi.msg[ibuf->r.midi.idx++] = c;
				if (!p->u.midi.dev) {
					midi_send(p, ibuf,
					    ibuf->r.midi.msg, ibuf->r.midi.idx);
				} else
					midi_onsysex(p, ibuf);
			}
			ibuf->r.midi.st = 0;
			ibuf->r.midi.idx = 0;
		} else if (c >= 0xf0) {
			ibuf->r.midi.msg[0] = c;
			ibuf->r.midi.len = common_len[c & 7];
			ibuf->r.midi.st = c;
			ibuf->r.midi.idx = 1;
		} else if (c >= 0x80) {
			ibuf->r.midi.msg[0] = c;
			ibuf->r.midi.len = voice_len[(c >> 4) & 7];
			ibuf->r.midi.st = c;
			ibuf->r.midi.idx = 1;
		} else if (ibuf->r.midi.st) {
			if (ibuf->r.midi.idx == 0 &&
			    ibuf->r.midi.st != SYSEX_START) {
				ibuf->r.midi.msg[ibuf->r.midi.idx++] =
				    ibuf->r.midi.st;
			}
			ibuf->r.midi.msg[ibuf->r.midi.idx++] = c;
			if (ibuf->r.midi.idx == ibuf->r.midi.len) {
				if (!p->u.midi.dev) {
					midi_send(p, ibuf,
					    ibuf->r.midi.msg, ibuf->r.midi.idx);
				} else
					midi_onvoice(p, ibuf);
				if (ibuf->r.midi.st >= 0xf0)
					ibuf->r.midi.st = 0;
				ibuf->r.midi.idx = 0;
			} else if (ibuf->r.midi.idx == MIDI_MSGMAX) {
				if (!p->u.midi.dev) {
					midi_send(p, ibuf,
					    ibuf->r.midi.msg, ibuf->r.midi.idx);
				}
				ibuf->r.midi.idx = 0;
			}
		}
	}
	/*
	 * XXX: if the sysex is received byte by byte, partial messages
	 * won't be sent until the end byte is received. On the other
	 * hand we can't flush it here, since we would lose messages
	 * we parse
	 */
	abuf_rdiscard(ibuf, icount);
	midi_flush(p);
	return 1;
}

int
midi_out(struct aproc *p, struct abuf *obuf)
{
	return 0;
}

void
midi_eof(struct aproc *p, struct abuf *ibuf)
{
	if ((p->flags & APROC_QUIT) && LIST_EMPTY(&p->ins))
		aproc_del(p);
}

void
midi_hup(struct aproc *p, struct abuf *obuf)
{
	if ((p->flags & APROC_QUIT) && LIST_EMPTY(&p->ins))
		aproc_del(p);
}

void
midi_newin(struct aproc *p, struct abuf *ibuf)
{
	ibuf->r.midi.used = 0;
	ibuf->r.midi.len = 0;
	ibuf->r.midi.idx = 0;
	ibuf->r.midi.st = 0;
	ibuf->tickets = MIDITHRU_XFER;
}

void
midi_done(struct aproc *p)
{
	timo_del(&p->u.midi.timo);
}

struct aproc_ops midi_ops = {
	"midi",
	midi_in,
	midi_out,
	midi_eof,
	midi_hup,
	midi_newin,
	NULL, /* newout */
	NULL, /* ipos */
	NULL, /* opos */
	midi_done,
};

struct aproc *
midi_new(char *name, struct dev *dev)
{
	struct aproc *p;

	p = aproc_new(&midi_ops, name);
	timo_set(&p->u.midi.timo, midi_cb, p);
	timo_add(&p->u.midi.timo, MIDITHRU_TIMO);
	p->u.midi.dev = dev;
	return p;
}
@


1.46
log
@add missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.45
log
@use unsigned chars for midi messages (to avoid gcc warning)
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.44 2012/09/25 20:12:34 ratchov Exp $	*/
d67 16
@


1.44
log
@Upon "master volume change" message, send feedback to other clients
only. Fixes the master volume slider stuttering in MIDI programs. Found
by armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.43 2012/04/25 07:21:41 ratchov Exp $	*/
d98 1
a98 1
midi_msg_info(struct aproc *p, int slot, char *msg)
d110 1
a110 1
		snprintf(x->u.mixinfo.name,
d118 1
a118 1
midi_msg_vol(struct aproc *p, int slot, char *msg)
d129 1
a129 1
midi_msg_master(struct aproc *p, char *msg)
@


1.43
log
@Fix typos, from Michael W. Bombardieri <mb at ii.net>, Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.42 2012/04/11 06:05:43 ratchov Exp $	*/
d423 1
d465 1
a465 1
			if (len == SYSEX_SIZE(master))
d467 2
@


1.42
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.41 2012/03/23 11:59:54 ratchov Exp $	*/
d77 1
a77 1
 * the throttelling mechanism, then run it
d369 2
a370 2
 * notifty the mixer that volume changed, called by whom allocad the slot using
 * ctl_slotnew(). Note: it doesn't make sens to call this from within the
d607 1
a607 1
	 * hand we can't flush it here, since we would loose messages
@


1.41
log
@add a MIDI-controlled master volume knob to adjust the mix of
all playback stream, discussed with armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.40 2011/12/02 10:34:50 ratchov Exp $	*/
d71 2
a72 2
unsigned voice_len[] = { 3, 3, 3, 3, 2, 2, 3 };
unsigned common_len[] = { 0, 2, 3, 2, 0, 0, 1, 1 };
d84 1
a84 1
	unsigned tickets;
d147 2
a148 1
midi_copy(struct abuf *ibuf, struct abuf *obuf, unsigned char *msg, unsigned len)
d150 1
a150 1
	unsigned ocount;
d210 2
a211 1
midi_send(struct aproc *p, struct abuf *ibuf, unsigned char *msg, unsigned len)
d227 1
a227 1
midi_send_qfr(struct aproc *p, unsigned rate, int delta)
d230 1
a230 1
	unsigned data;
d297 2
a298 1
midi_send_full(struct aproc *p, unsigned origin, unsigned rate, unsigned round, unsigned pos)
d301 1
a301 1
	unsigned fps;
d347 1
a347 1
	unsigned i;
d374 1
a374 1
midi_send_vol(struct aproc *p, int slot, unsigned vol)
d407 1
a407 1
	unsigned chan;
d409 1
a409 1
	unsigned i;
d441 1
a441 1
	unsigned fps, len;
d443 1
a443 1
	unsigned i;
d536 1
a536 1
	unsigned i, icount;
@


1.40
log
@reuse midi-control code to implement midi thru boxes and remove
the old midithru implementation; less code, less bugs. As a side
effect, midi output doesn't implement running status "compression"
any more.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.39 2011/11/20 22:54:51 ratchov Exp $	*/
d128 15
d348 2
d380 9
d460 5
@


1.39
log
@Move mmc/mtc and volume control bits from struct aproc to struct
dev. Allows volume settings to be saved while the device is kept
closed. Besides that, no behabiour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.38 2011/11/15 20:41:54 ratchov Exp $	*/
a21 3
 *
 * make output and input identical when only one
 * input is used (fix running status)
d75 1
a75 247
 * send the message stored in of ibuf->r.midi.msg to obuf
 */
void
thru_flush(struct abuf *ibuf, struct abuf *obuf)
{
	unsigned ocount, itodo;
	unsigned char *odata, *idata;

	itodo = ibuf->r.midi.used;
	idata = ibuf->r.midi.msg;
#ifdef DEBUG
	if (debug_level >= 4) {
		abuf_dbg(obuf);
		dbg_puts(": flushing ");
		dbg_putu(itodo);
		dbg_puts(" byte message\n");
	}
#endif
	while (itodo > 0) {
		if (!ABUF_WOK(obuf)) {
#ifdef DEBUG
			if (debug_level >= 3) {
				abuf_dbg(obuf);
				dbg_puts(": overrun, discarding ");
				dbg_putu(obuf->used);
				dbg_puts(" bytes\n");
			}
#endif
			abuf_rdiscard(obuf, obuf->used);
			if (obuf->w.midi.owner == ibuf)
				obuf->w.midi.owner = NULL;
			return;
		}
		odata = abuf_wgetblk(obuf, &ocount, 0);
		if (ocount > itodo)
			ocount = itodo;
		memcpy(odata, idata, ocount);
		abuf_wcommit(obuf, ocount);
		itodo -= ocount;
		idata += ocount;
	}
	ibuf->r.midi.used = 0;
	obuf->w.midi.owner = ibuf;
}

/*
 * send the real-time message (one byte) to obuf, similar to thru_flush()
 */
void
thru_rt(struct abuf *ibuf, struct abuf *obuf, unsigned c)
{
	unsigned ocount;
	unsigned char *odata;

#ifdef DEBUG
	if (debug_level >= 4) {
		abuf_dbg(obuf);
		dbg_puts(": ");
		dbg_putx(c);
		dbg_puts(": flushing realtime message\n");
	}
#endif
	if (c == MIDI_ACK)
		return;
	if (!ABUF_WOK(obuf)) {
#ifdef DEBUG
		if (debug_level >= 3) {
			abuf_dbg(obuf);
			dbg_puts(": overrun, discarding ");
			dbg_putu(obuf->used);
			dbg_puts(" bytes\n");
		}
#endif
		abuf_rdiscard(obuf, obuf->used);
		if (obuf->w.midi.owner == ibuf)
			obuf->w.midi.owner = NULL;
	}
	odata = abuf_wgetblk(obuf, &ocount, 0);
	odata[0] = c;
	abuf_wcommit(obuf, 1);
}

/*
 * parse ibuf contents and store each message into obuf,
 * use at most ``todo'' bytes (for throttling)
 */
void
thru_bcopy(struct abuf *ibuf, struct abuf *obuf, unsigned todo)
{
	unsigned char *idata;
	unsigned c, icount, ioffs;

	idata = NULL;
	icount = ioffs = 0;
	for (;;) {
		if (icount == 0) {
			if (todo == 0)
				break;
			idata = abuf_rgetblk(ibuf, &icount, ioffs);
			if (icount > todo)
				icount = todo;
			if (icount == 0)
				break;
			todo -= icount;
			ioffs += icount;
		}
		c = *idata++;
		icount--;
		if (c < 0x80) {
			if (ibuf->r.midi.idx == 0 && ibuf->r.midi.st) {
				ibuf->r.midi.msg[ibuf->r.midi.used++] = ibuf->r.midi.st;
				ibuf->r.midi.idx++;
			}
			ibuf->r.midi.msg[ibuf->r.midi.used++] = c;
			ibuf->r.midi.idx++;
			if (ibuf->r.midi.idx == ibuf->r.midi.len) {
				thru_flush(ibuf, obuf);
				if (ibuf->r.midi.st >= 0xf0)
					ibuf->r.midi.st = 0;
				ibuf->r.midi.idx = 0;
			}
			if (ibuf->r.midi.used == MIDI_MSGMAX) {
				if (ibuf->r.midi.used == ibuf->r.midi.idx ||
				    obuf->w.midi.owner == ibuf)
					thru_flush(ibuf, obuf);
				else
					ibuf->r.midi.used = 0;
			}
		} else if (c < 0xf8) {
			if (ibuf->r.midi.used == ibuf->r.midi.idx ||
			    obuf->w.midi.owner == ibuf) {
				thru_flush(ibuf, obuf);
			} else
				ibuf->r.midi.used = 0;
			ibuf->r.midi.msg[0] = c;
			ibuf->r.midi.used = 1;
			ibuf->r.midi.len = (c >= 0xf0) ? 
			    common_len[c & 7] :
			    voice_len[(c >> 4) & 7];
			if (ibuf->r.midi.len == 1) {
				thru_flush(ibuf, obuf);
				ibuf->r.midi.idx = 0;
				ibuf->r.midi.st = 0;
				ibuf->r.midi.len = 0;
			} else { 
				ibuf->r.midi.st = c;
				ibuf->r.midi.idx = 1;
			}
		} else {
			thru_rt(ibuf, obuf, c);
		}
	}
}

int
thru_in(struct aproc *p, struct abuf *ibuf)
{
	struct abuf *i, *inext;
	unsigned todo;

	if (!ABUF_ROK(ibuf))
		return 0;
	if (ibuf->tickets == 0) {
#ifdef DEBUG
		if (debug_level >= 4) {
			abuf_dbg(ibuf);
			dbg_puts(": out of tickets, blocking\n");
		}
#endif
		return 0;
	}
	todo = ibuf->used;
	if (todo > ibuf->tickets)
		todo = ibuf->tickets;
	ibuf->tickets -= todo;
	for (i = LIST_FIRST(&p->outs); i != NULL; i = inext) {
		inext = LIST_NEXT(i, oent);
		if (ibuf->duplex == i)
			continue;
		thru_bcopy(ibuf, i, todo);
		(void)abuf_flush(i);
	}
	abuf_rdiscard(ibuf, todo);
	return 1;
}

int
thru_out(struct aproc *p, struct abuf *obuf)
{
	return 0;
}

void
thru_eof(struct aproc *p, struct abuf *ibuf)
{
	if (!(p->flags & APROC_QUIT))
		return;
	if (LIST_EMPTY(&p->ins))
		aproc_del(p);
}

void
thru_hup(struct aproc *p, struct abuf *obuf)
{
	if (!(p->flags & APROC_QUIT))
		return;
	if (LIST_EMPTY(&p->ins))
		aproc_del(p);
}

void
thru_newin(struct aproc *p, struct abuf *ibuf)
{
	ibuf->r.midi.used = 0;
	ibuf->r.midi.len = 0;
	ibuf->r.midi.idx = 0;
	ibuf->r.midi.st = 0;
	ibuf->tickets = MIDITHRU_XFER;
}

void
thru_newout(struct aproc *p, struct abuf *obuf)
{
	obuf->w.midi.owner = NULL;
}

void
thru_done(struct aproc *p)
{
	timo_del(&p->u.thru.timo);
}

struct aproc_ops thru_ops = {
	"thru",
	thru_in,
	thru_out,
	thru_eof,
	thru_hup,
	thru_newin,
	thru_newout,
	NULL, /* ipos */
	NULL, /* opos */
	thru_done
};

/*
 * call-back invoked periodically to implement throttling at each invocation
d80 1
a80 1
thru_cb(void *addr)
d86 1
a86 1
	timo_add(&p->u.thru.timo, MIDITHRU_TIMO);
d97 22
a118 2
struct aproc *
thru_new(char *name)
d120 1
a120 1
	struct aproc *p;
d122 4
a125 4
	p = aproc_new(&thru_ops, name);
	timo_set(&p->u.thru.timo, thru_cb, p);
	timo_add(&p->u.thru.timo, MIDITHRU_TIMO);
	return p;
d132 1
a132 1
ctl_copymsg(struct abuf *obuf, unsigned char *msg, unsigned len)
d134 2
a135 2
	unsigned ocount, itodo;
	unsigned char *odata, *idata;
d137 3
a139 3
	itodo = len;
	idata = msg;
	while (itodo > 0) {
d150 3
d155 2
a156 2
		if (ocount > itodo)
			ocount = itodo;
d165 1
a165 1
		memcpy(odata, idata, ocount);
d167 19
a185 2
		itodo -= ocount;
		idata += ocount;
d194 1
a194 1
ctl_sendmsg(struct aproc *p, struct abuf *ibuf, unsigned char *msg, unsigned len)
d202 1
a202 2
		ctl_copymsg(i, msg, len);
		(void)abuf_flush(i);
d210 1
a210 1
ctl_qfr(struct aproc *p, unsigned rate, int delta)
d216 4
a219 12
	p->u.ctl.delta += delta * MTC_SEC;

	/*
	 * don't send ticks during the count-down
	 * XXX: test not useful, given while() condition
	 */
	if (p->u.ctl.delta < 0)
		return;

	qfrlen = rate * (MTC_SEC / (4 * p->u.ctl.fps));
	while (p->u.ctl.delta >= qfrlen) {
		switch (p->u.ctl.qfr) {
d221 1
a221 1
			data = p->u.ctl.fr & 0xf;
d224 1
a224 1
			data = p->u.ctl.fr >> 4;
d227 1
a227 1
			data = p->u.ctl.sec & 0xf;
d230 1
a230 1
			data = p->u.ctl.sec >> 4;
d233 1
a233 1
			data = p->u.ctl.min & 0xf;
d236 1
a236 1
			data = p->u.ctl.min >> 4;
d239 1
a239 1
			data = p->u.ctl.hr & 0xf;
d242 1
a242 1
			data = (p->u.ctl.hr >> 4) | (p->u.ctl.fps_id << 1);
d246 2
a247 2
			p->u.ctl.fr += 2;
			if (p->u.ctl.fr < p->u.ctl.fps)
d249 3
a251 3
			p->u.ctl.fr -= p->u.ctl.fps;
			p->u.ctl.sec++;
			if (p->u.ctl.sec < 60)
d253 3
a255 3
			p->u.ctl.sec = 0;
			p->u.ctl.min++;
			if (p->u.ctl.min < 60)
d257 3
a259 3
			p->u.ctl.min = 0;
			p->u.ctl.hr++;
			if (p->u.ctl.hr < 24)
d261 1
a261 1
			p->u.ctl.hr = 0;
d268 5
a272 5
		buf[1] = (p->u.ctl.qfr << 4) | data;
		p->u.ctl.qfr++;
		p->u.ctl.qfr &= 7;
		ctl_sendmsg(p, NULL, buf, 2);
		p->u.ctl.delta -= qfrlen;
d280 1
a280 1
ctl_full(struct aproc *p, unsigned origin, unsigned rate, unsigned round, unsigned pos)
d285 1
a285 1
	p->u.ctl.delta = MTC_SEC * pos;
d287 2
a288 2
		p->u.ctl.fps_id = MTC_FPS_30;
		p->u.ctl.fps = 30;
d290 2
a291 2
		p->u.ctl.fps_id = MTC_FPS_25;
		p->u.ctl.fps = 25;
d293 2
a294 2
		p->u.ctl.fps_id = MTC_FPS_24;
		p->u.ctl.fps = 24;
d300 1
a300 1
		dbg_puti(p->u.ctl.delta);
d302 1
a302 1
		dbg_puti(p->u.ctl.fps);
d306 5
a310 5
	fps = p->u.ctl.fps;
	p->u.ctl.hr =  (origin / (3600 * MTC_SEC)) % 24;
	p->u.ctl.min = (origin / (60 * MTC_SEC))   % 60;
	p->u.ctl.sec = (origin / MTC_SEC)          % 60;
	p->u.ctl.fr =  (origin / (MTC_SEC / fps))  % fps;
d317 4
a320 4
	buf[5] = p->u.ctl.hr | (p->u.ctl.fps_id << 5);
	buf[6] = p->u.ctl.min;
	buf[7] = p->u.ctl.sec;
	buf[8] = p->u.ctl.fr;
d322 2
a323 2
	p->u.ctl.qfr = 0;
	ctl_sendmsg(p, NULL, buf, 10);
d327 1
a327 32
ctl_msg_info(struct aproc *p, int slot, char *msg)
{
	struct ctl_slot *s;
	struct sysex *x = (struct sysex *)msg;

	s = p->u.ctl.dev->slot + slot;
	memset(x, 0, sizeof(struct sysex));
	x->start = SYSEX_START;
	x->type = SYSEX_TYPE_EDU;
	x->id0 = SYSEX_AUCAT;
	x->id1 = SYSEX_AUCAT_MIXINFO;
	if (*s->name != '\0') {
		snprintf(x->u.mixinfo.name,
		    SYSEX_NAMELEN, "%s%u", s->name, s->unit);
	}
	x->u.mixinfo.chan = slot;
	x->u.mixinfo.end = SYSEX_END;
}

void
ctl_msg_vol(struct aproc *p, int slot, char *msg)
{
	struct ctl_slot *s;

	s = p->u.ctl.dev->slot + slot;	
	msg[0] = MIDI_CTL | slot;
	msg[1] = MIDI_CTLVOL;
	msg[2] = s->vol;
}

void
ctl_dump(struct aproc *p, struct abuf *obuf)
d333 5
a337 5
	for (i = 0, s = p->u.ctl.dev->slot; i < CTL_NSLOT; i++, s++) {
		ctl_msg_info(p, i, msg);
		ctl_copymsg(obuf, msg, SYSEX_SIZE(mixinfo));
		ctl_msg_vol(p, i, msg);
		ctl_copymsg(obuf, msg, 3);
d345 1
a345 2
	ctl_copymsg(obuf, msg, 6);
	abuf_flush(obuf);
d354 1
a354 1
ctl_vol(struct aproc *p, int slot, unsigned vol)
d358 2
a359 2
	ctl_msg_vol(p, slot, msg);
	ctl_sendmsg(p, NULL, msg, 3);
d363 1
a363 1
ctl_slot(struct aproc *p, int slot)
d367 2
a368 2
	ctl_msg_info(p, slot, msg);
	ctl_sendmsg(p, NULL, msg, SYSEX_SIZE(mixinfo));
d372 1
a372 1
 * handle a MIDI event received from ibuf
d375 1
a375 1
ctl_ev(struct aproc *p, struct abuf *ibuf)
d377 1
a378 3
	struct ctl_slot *slot;
	struct sysex *x;
	unsigned fps, len;
d384 1
a384 1
		dbg_puts(": got event:");
d397 1
a397 1
		slot = p->u.ctl.dev->slot + chan;
a401 1
		ctl_sendmsg(p, ibuf, ibuf->r.midi.msg, ibuf->r.midi.len);
d403 23
d446 1
a446 1
			dev_mmcstop(p->u.ctl.dev);
d457 1
a457 1
			dev_mmcstart(p->u.ctl.dev);
d478 1
a478 1
			dev_loc(p->u.ctl.dev,
d493 1
a493 1
			ctl_dump(p, ibuf->duplex);
d499 1
a499 1
ctl_in(struct aproc *p, struct abuf *ibuf)
d501 2
a502 2
	unsigned char *idata;
	unsigned c, i, icount;
d506 9
d516 3
d522 4
a525 4
			/* clock events not used yet */
		} else if (c >= 0xf0) {
			if (ibuf->r.midi.st == 0xf0 && c == 0xf7 &&
			    ibuf->r.midi.idx < MIDI_MSGMAX) {
d527 5
a531 2
				ctl_ev(p, ibuf);
				continue;
d533 3
d546 5
a550 4
			if (ibuf->r.midi.idx == MIDI_MSGMAX)
				continue;		
			if (ibuf->r.midi.idx == 0)
				ibuf->r.midi.msg[ibuf->r.midi.idx++] = ibuf->r.midi.st;
d553 13
a565 1
				ctl_ev(p, ibuf);
d570 6
d577 1
d582 1
a582 1
ctl_out(struct aproc *p, struct abuf *obuf)
d588 1
a588 1
ctl_eof(struct aproc *p, struct abuf *ibuf)
d595 1
a595 1
ctl_hup(struct aproc *p, struct abuf *obuf)
d602 1
a602 1
ctl_newin(struct aproc *p, struct abuf *ibuf)
d608 7
d617 7
a623 7
struct aproc_ops ctl_ops = {
	"ctl",
	ctl_in,
	ctl_out,
	ctl_eof,
	ctl_hup,
	ctl_newin,
d627 1
a627 1
	NULL,
d631 1
a631 1
ctl_new(char *name, struct dev *dev)
d635 4
a638 2
	p = aproc_new(&ctl_ops, name);
	p->u.ctl.dev = dev;
@


1.38
log
@make midi 'owner' pointer per-output
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.37 2011/10/12 07:20:04 ratchov Exp $	*/
a356 36
#ifdef DEBUG
void
ctl_slotdbg(struct aproc *p, int slot)
{
	struct ctl_slot *s;

	if (slot < 0) {
		dbg_puts("none");
	} else {
		s = p->u.ctl.slot + slot;
		dbg_puts(s->name);
		dbg_putu(s->unit);
		dbg_puts("(");
		dbg_putu(s->vol);
		dbg_puts(")/");
		switch (s->tstate) {
		case CTL_OFF:
			dbg_puts("off");
			break;
		case CTL_RUN:
			dbg_puts("run");
			break;
		case CTL_START:
			dbg_puts("sta");
			break;
		case CTL_STOP:
			dbg_puts("stp");
			break;
		default:
			dbg_puts("unk");
			break;
		}
	}
}
#endif

d420 1
a420 1
ctl_qfr(struct aproc *p)
d424 3
d428 52
a479 29
	switch (p->u.ctl.qfr) {
	case 0:
		data = p->u.ctl.fr & 0xf;
		break;
	case 1:
		data = p->u.ctl.fr >> 4;
		break;
	case 2:
		data = p->u.ctl.sec & 0xf;
		break;
	case 3:
		data = p->u.ctl.sec >> 4;
		break;
	case 4:
		data = p->u.ctl.min & 0xf;
		break;
	case 5:
		data = p->u.ctl.min >> 4;
		break;
	case 6:
		data = p->u.ctl.hr & 0xf;
		break;
	case 7:
		data = (p->u.ctl.hr >> 4) | (p->u.ctl.fps_id << 1);
		/*
		 * tick messages are sent 2 frames ahead
		 */
		p->u.ctl.fr += 2;
		if (p->u.ctl.fr < p->u.ctl.fps)
d481 10
a490 17
		p->u.ctl.fr -= p->u.ctl.fps;
		p->u.ctl.sec++;
		if (p->u.ctl.sec < 60)
			break;
		p->u.ctl.sec = 0;
		p->u.ctl.min++;
		if (p->u.ctl.min < 60)
			break;
		p->u.ctl.min = 0;
		p->u.ctl.hr++;
		if (p->u.ctl.hr < 24)
			break;
		p->u.ctl.hr = 0;
		break;
	default:
		/* NOTREACHED */
		data = 0;
a491 5
	buf[0] = 0xf1;
	buf[1] = (p->u.ctl.qfr << 4) | data;
	p->u.ctl.qfr++;
	p->u.ctl.qfr &= 7;
	ctl_sendmsg(p, NULL, buf, 2);
d498 1
a498 1
ctl_full(struct aproc *p)
d501 1
a501 2
	unsigned origin = p->u.ctl.origin;
	unsigned fps = p->u.ctl.fps;
d503 22
d550 1
a550 1
	s = p->u.ctl.slot + slot;
d569 1
a569 1
	s = p->u.ctl.slot + slot;	
d582 1
a582 1
	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
a598 276
 * find the best matching free slot index (ie midi channel).
 * return -1, if there are no free slots anymore
 */
int
ctl_getidx(struct aproc *p, char *who)
{
	char *s;
	struct ctl_slot *slot;
	char name[CTL_NAMEMAX];
	unsigned i, unit, umap = 0;
	unsigned ser, bestser, bestidx;

	/*
	 * create a ``valid'' control name (lowcase, remove [^a-z], trucate)
	 */
	for (i = 0, s = who; ; s++) {
		if (i == CTL_NAMEMAX - 1 || *s == '\0') {
			name[i] = '\0';
			break;
		} else if (*s >= 'A' && *s <= 'Z') {
			name[i++] = *s + 'a' - 'A';
		} else if (*s >= 'a' && *s <= 'z')
			name[i++] = *s;
	}
	if (i == 0)
		strlcpy(name, "noname", CTL_NAMEMAX);

	/*
	 * find the instance number of the control name
	 */
	for (i = 0, slot = p->u.ctl.slot; i < CTL_NSLOT; i++, slot++) {
		if (slot->ops == NULL)
			continue;
		if (strcmp(slot->name, name) == 0)
			umap |= (1 << i);
	} 
	for (unit = 0; ; unit++) {
		if (unit == CTL_NSLOT) {
#ifdef DEBUG
			if (debug_level >= 1) {
				dbg_puts(name);
				dbg_puts(": too many instances\n");
			}
#endif
			return -1;
		}
		if ((umap & (1 << unit)) == 0)
			break;
	}

	/*
	 * find a free controller slot with the same name/unit
	 */
	for (i = 0, slot = p->u.ctl.slot; i < CTL_NSLOT; i++, slot++) {
		if (slot->ops == NULL &&
		    strcmp(slot->name, name) == 0 &&
		    slot->unit == unit) {
#ifdef DEBUG
			if (debug_level >= 3) {
				dbg_puts(name);
				dbg_putu(unit);
				dbg_puts(": found slot ");
				dbg_putu(i);
				dbg_puts("\n");
			}
#endif
			return i;
		}
	}

	/*
	 * couldn't find a matching slot, pick oldest free slot
	 * and set its name/unit
	 */
	bestser = 0;
	bestidx = CTL_NSLOT;
	for (i = 0, slot = p->u.ctl.slot; i < CTL_NSLOT; i++, slot++) {
		if (slot->ops != NULL)
			continue;
		ser = p->u.ctl.serial - slot->serial;
		if (ser > bestser) {
			bestser = ser;
			bestidx = i;
		}
	}
	if (bestidx == CTL_NSLOT) {
#ifdef DEBUG
		if (debug_level >= 1) {
			dbg_puts(name);
			dbg_putu(unit);
			dbg_puts(": out of mixer slots\n");
		}
#endif
		return -1;
	}
	slot = p->u.ctl.slot + bestidx;
	if (slot->name[0] != '\0')
		slot->vol = MIDI_MAXCTL;
	strlcpy(slot->name, name, CTL_NAMEMAX);
	slot->serial = p->u.ctl.serial++;
	slot->unit = unit;
#ifdef DEBUG
	if (debug_level >= 3) {
		dbg_puts(name);
		dbg_putu(unit);
		dbg_puts(": overwritten slot ");
		dbg_putu(bestidx);
		dbg_puts("\n");
	}
#endif
	return bestidx;
}

/*
 * check that all clients controlled by MMC are ready to start,
 * if so, start them all but the caller
 */
int
ctl_trystart(struct aproc *p, int caller)
{
	unsigned i;
	struct ctl_slot *s;

	if (p->u.ctl.tstate != CTL_START) {
#ifdef DEBUG
		if (debug_level >= 3) {
			ctl_slotdbg(p, caller);
			dbg_puts(": server not started, delayd\n");
		}
#endif
		return 0;
	}
	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		if (!s->ops || i == caller)
			continue;
		if (s->tstate != CTL_OFF && s->tstate != CTL_START) {
#ifdef DEBUG
			if (debug_level >= 3) {
				ctl_slotdbg(p, i);
				dbg_puts(": not ready, server delayed\n");
			}
#endif
			return 0;
		}
	}
	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		if (!s->ops || i == caller)
			continue;
		if (s->tstate == CTL_START) {
#ifdef DEBUG
			if (debug_level >= 3) {
				ctl_slotdbg(p, i);
				dbg_puts(": started\n");
			}
#endif
			s->tstate = CTL_RUN;
			s->ops->start(s->arg);
		}
	}
	if (caller >= 0)
		p->u.ctl.slot[caller].tstate = CTL_RUN;
	p->u.ctl.tstate = CTL_RUN;
	p->u.ctl.delta = MTC_SEC * dev_getpos(p->u.ctl.dev);
	if (p->u.ctl.dev->rate % (30 * 4 * p->u.ctl.dev->round) == 0) {
		p->u.ctl.fps_id = MTC_FPS_30;
		p->u.ctl.fps = 30;
	} else if (p->u.ctl.dev->rate % (25 * 4 * p->u.ctl.dev->round) == 0) {
		p->u.ctl.fps_id = MTC_FPS_25;
		p->u.ctl.fps = 25;
	} else {
		p->u.ctl.fps_id = MTC_FPS_24;
		p->u.ctl.fps = 24;
	} 
#ifdef DEBUG
	if (debug_level >= 3) {
		ctl_slotdbg(p, caller);
		dbg_puts(": started server at ");
		dbg_puti(p->u.ctl.delta);
		dbg_puts(", ");
		dbg_puti(p->u.ctl.fps);
		dbg_puts(" mtc fps\n");
	}
#endif
	dev_wakeup(p->u.ctl.dev);
	ctl_full(p);
	return 1;
}

/*
 * allocate a new slot and register the given call-backs
 */
int
ctl_slotnew(struct aproc *p, char *who, struct ctl_ops *ops, void *arg, int mmc)
{
	int idx;
	struct ctl_slot *s;
	unsigned char msg[sizeof(struct sysex)];

	if (!APROC_OK(p)) {
#ifdef DEBUG
		if (debug_level >= 2) {
			dbg_puts(who);
			dbg_puts(": MIDI control not available\n");
		}
#endif
		return -1;
	}
	idx = ctl_getidx(p, who);
	if (idx < 0)
		return -1;

	s = p->u.ctl.slot + idx;
	s->ops = ops;
	s->arg = arg;
	s->tstate = mmc ? CTL_STOP : CTL_OFF;
	s->ops->vol(s->arg, s->vol);
	ctl_msg_info(p, idx, msg);
	ctl_sendmsg(p, NULL, msg, SYSEX_SIZE(mixinfo));
	ctl_msg_vol(p, idx, msg);
	ctl_sendmsg(p, NULL, msg, 3);
	return idx;
}

/*
 * release the given slot
 */
void
ctl_slotdel(struct aproc *p, int index)
{
	unsigned i;
	struct ctl_slot *s;

	if (!APROC_OK(p))
		return;
	p->u.ctl.slot[index].ops = NULL;
	if (!(p->flags & APROC_QUIT))
		return;
	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		if (s->ops)
			return;
	}
	if (LIST_EMPTY(&p->ins))
		aproc_del(p);
}

/*
 * called at every clock tick by the mixer, delta is positive, unless
 * there's an overrun/underrun
 */
void
ctl_ontick(struct aproc *p, int delta)
{
	int qfrlen;

	/*
	 * don't send ticks before the start signal
	 */
	if (p->u.ctl.tstate != CTL_RUN)
		return;
	
	p->u.ctl.delta += delta * MTC_SEC;

	/*
	 * don't send ticks during the count-down
	 */
	if (p->u.ctl.delta < 0)
		return;

	qfrlen = p->u.ctl.dev->rate * (MTC_SEC / (4 * p->u.ctl.fps));
	while (p->u.ctl.delta >= qfrlen) {
		ctl_qfr(p);
		p->u.ctl.delta -= qfrlen;
	}
}

/*
d604 1
a604 1
ctl_slotvol(struct aproc *p, int slot, unsigned vol)
a607 11
	if (!APROC_OK(p))
		return;
#ifdef DEBUG
	if (debug_level >= 3) {
		ctl_slotdbg(p, slot);
		dbg_puts(": changing volume to ");
		dbg_putu(vol);
		dbg_puts("\n");
	}
#endif
	p->u.ctl.slot[slot].vol = vol;
a611 30
/*
 * notify the MMC layer that the stream is attempting
 * to start. If other streams are not ready, 0 is returned meaning 
 * that the stream should wait. If other streams are ready, they
 * are started, and the caller should start immediately.
 */
int
ctl_slotstart(struct aproc *p, int slot)
{
	struct ctl_slot *s = p->u.ctl.slot + slot;

	if (!APROC_OK(p))
		return 1;
	if (s->tstate == CTL_OFF || p->u.ctl.tstate == CTL_OFF)
		return 1;

	/*
	 * if the server already started (the client missed the
	 * start rendez-vous) or the server is stopped, then
	 * tag the client as ``wanting to start''
	 */
	s->tstate = CTL_START;
	return ctl_trystart(p, slot);
}

/*
 * notify the MMC layer that the stream no longer is trying to
 * start (or that it just stopped), meaning that its ``start'' call-back
 * shouldn't be called anymore
 */
d613 1
a613 1
ctl_slotstop(struct aproc *p, int slot)
d615 1
a615 1
	struct ctl_slot *s = p->u.ctl.slot + slot;
d617 2
a618 120
	if (!APROC_OK(p))
		return;
	/*
	 * tag the stream as not trying to start,
	 * unless MMC is turned off
	 */
	if (s->tstate != CTL_OFF)
		s->tstate = CTL_STOP;
}

/*
 * start all slots simultaneously
 */
void
ctl_start(struct aproc *p)
{
	if (!APROC_OK(p))
		return;
	if (p->u.ctl.tstate == CTL_STOP) {
		p->u.ctl.tstate = CTL_START;
		(void)ctl_trystart(p, -1);
#ifdef DEBUG
	} else {
		if (debug_level >= 3) {
			aproc_dbg(p);
			dbg_puts(": ignoring mmc start\n");
		}
#endif
	}
}

/*
 * stop all slots simultaneously
 */
void
ctl_stop(struct aproc *p)
{
	unsigned i;
	struct ctl_slot *s;

	if (!APROC_OK(p))
		return;
	switch (p->u.ctl.tstate) {
	case CTL_START:
		p->u.ctl.tstate = CTL_STOP;
		return;
	case CTL_RUN:
		p->u.ctl.tstate = CTL_STOP;
		break;
	default:
#ifdef DEBUG
		if (debug_level >= 3) {
			aproc_dbg(p);
			dbg_puts(": ignored mmc stop\n");
		}
#endif
		return;
	}
	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		if (!s->ops)
			continue;
		if (s->tstate == CTL_RUN) {
#ifdef DEBUG
			if (debug_level >= 3) {
				ctl_slotdbg(p, i);
				dbg_puts(": requested to stop\n");
			}
#endif
			s->ops->stop(s->arg);
		}
	}
}

/*
 * relocate all slots simultaneously
 */
void
ctl_loc(struct aproc *p, unsigned origin)
{
	unsigned i, tstate;
	struct ctl_slot *s;

	if (!APROC_OK(p))
		return;
#ifdef DEBUG
	if (debug_level >= 2) {
		dbg_puts("server relocated to ");
		dbg_putu(origin);
		dbg_puts("\n");
	}
#endif
	tstate = p->u.ctl.tstate;
	if (tstate == CTL_RUN)
		ctl_stop(p);
	p->u.ctl.origin = origin;
	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		if (!s->ops)
			continue;
		s->ops->loc(s->arg, p->u.ctl.origin);
	}
	if (tstate == CTL_RUN)
		ctl_start(p);
}

/*
 * check if there are controlled streams
 */
int
ctl_idle(struct aproc *p)
{
	unsigned i;
	struct ctl_slot *s;

	if (!APROC_OK(p))
		return 1;
	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		if (s->ops)
			return 0;
	}
	return 1;
d649 1
a649 1
		slot = p->u.ctl.slot + chan;
d676 1
a676 1
			ctl_stop(p);
d687 1
a687 1
			ctl_start(p);
d705 1
a705 1
				p->u.ctl.origin = 0;
d708 1
a708 1
			ctl_loc(p,
d782 1
a782 10
	unsigned i;
	struct ctl_slot *s;

	if (!(p->flags & APROC_QUIT))
		return;
	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		if (s->ops != NULL)
			s->ops->quit(s->arg);
	}
	if (LIST_EMPTY(&p->ins))
d789 1
a789 10
	unsigned i;
	struct ctl_slot *s;

	if (!(p->flags & APROC_QUIT))
		return;
	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		if (s->ops)
			return;
	}
	if (LIST_EMPTY(&p->ins))
a801 12
void
ctl_done(struct aproc *p)
{
	unsigned i;
	struct ctl_slot *s;

	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		if (s->ops != NULL)
			s->ops->quit(s->arg);
	}
}

d812 1
a812 1
	ctl_done
a818 2
	struct ctl_slot *s;
	unsigned i;
a821 10
	p->u.ctl.serial = 0;
	p->u.ctl.tstate = CTL_STOP;
	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		p->u.ctl.slot[i].unit = i;
		p->u.ctl.slot[i].ops = NULL;
		p->u.ctl.slot[i].vol = MIDI_MAXCTL;
		p->u.ctl.slot[i].tstate = CTL_OFF;
		p->u.ctl.slot[i].serial = p->u.ctl.serial++;
		p->u.ctl.slot[i].name[0] = '\0';
	}
@


1.37
log
@Simplify and improve the way options are parsed and remove ~300 lines
of code that becomes unused. Few command line arguments changes are
required though:

  - stream definitions (-ios) now must follow devices definitions they
    are attached to (-fMn)

  - the -n option is now a special "loopback" device and is thus used
    like -f, eg it must precede streams

  - in midicat, midi thru boxes are not created automatically anymore,
    the new "-M" option must be used for that

  - channel numbers (-Cc options) correspond always to channel numbers
    of the hardware.

  - the -u option isn't needed anymore

  - increase the log verbosity so user errors are logged
    without using -d

tested by many, help from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.36 2011/06/27 07:57:38 ratchov Exp $	*/
d81 1
a81 1
thru_flush(struct aproc *p, struct abuf *ibuf, struct abuf *obuf)
d90 1
a90 1
		aproc_dbg(p);
d100 1
a100 1
				aproc_dbg(p);
d107 2
a108 2
			if (p->u.thru.owner == ibuf)
				p->u.thru.owner = NULL;
d120 1
a120 1
	p->u.thru.owner = ibuf;
d124 1
a124 1
 * send the real-time message (one byte) to obuf, similar to thrui_flush()
d127 1
a127 1
thru_rt(struct aproc *p, struct abuf *ibuf, struct abuf *obuf, unsigned c)
d134 1
a134 1
		aproc_dbg(p);
d145 1
a145 1
			aproc_dbg(p);
d152 2
a153 2
		if (p->u.thru.owner == ibuf)
			p->u.thru.owner = NULL;
d165 1
a165 1
thru_bcopy(struct aproc *p, struct abuf *ibuf, struct abuf *obuf, unsigned todo)
d194 1
a194 1
				thru_flush(p, ibuf, obuf);
d201 2
a202 2
				    p->u.thru.owner == ibuf)
					thru_flush(p, ibuf, obuf);
d208 2
a209 2
			    p->u.thru.owner == ibuf) {
				thru_flush(p, ibuf, obuf);
d218 1
a218 1
				thru_flush(p, ibuf, obuf);
d227 1
a227 1
			thru_rt(p, ibuf, obuf, c);
d257 1
a257 1
		thru_bcopy(p, ibuf, i, todo);
d299 6
d317 1
a317 1
	NULL, /* newout */
a351 1
	p->u.thru.owner = NULL;
@


1.36
log
@remove two forgotten debug printf()s
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.35 2011/06/27 07:17:44 ratchov Exp $	*/
d787 1
a787 1
ctl_slotnew(struct aproc *p, char *who, struct ctl_ops *ops, void *arg, int tr)
d795 1
a795 1
		if (debug_level >= 1) {
d809 1
a809 1
	s->tstate = tr ? CTL_STOP : CTL_OFF;
@


1.35
log
@expose audio client names through sysex messages, this way any
midi client could determine which volume knob corresponds to which
client. Such sysex messages are ignored by hardware or software
that don't understand them
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.34 2011/06/02 18:50:39 ratchov Exp $	*/
a590 1
	dbg_puts("end dump\n");
a1152 1
		dbg_puts("dump request\n");
@


1.34
log
@close midi control ports and thru boxes only when there are no
inputs anymore, to ensure data is drained
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.33 2011/05/09 18:03:08 ratchov Exp $	*/
d541 20
d571 24
d812 2
d1148 9
@


1.33
log
@move all hardcoded offsets and constants relative to midi system
exclusive messages in a nice sysex.h file. No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.32 2010/11/20 05:12:38 deraadt Exp $	*/
d275 1
a275 1
	if (LIST_EMPTY(&p->ins) || LIST_EMPTY(&p->outs))
d284 1
a284 1
	if (LIST_EMPTY(&p->outs))
d791 1
a791 1
	if (!LIST_EMPTY(&p->outs) || !LIST_EMPTY(&p->ins))
d1169 1
a1169 1
	if (!LIST_EMPTY(&p->outs) || !LIST_EMPTY(&p->ins))
d1185 1
a1185 1
	if (!LIST_EMPTY(&p->outs) || !LIST_EMPTY(&p->ins))
@


1.32
log
@clean up cases of ;;
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.31 2010/11/14 13:51:27 ratchov Exp $	*/
d35 1
d389 41
a435 2
	unsigned ocount, itodo;
	unsigned char *odata, *idata;
d442 1
a442 30
		itodo = len;
		idata = msg;
		while (itodo > 0) {
			if (!ABUF_WOK(i)) {
#ifdef DEBUG
				if (debug_level >= 3) {
					abuf_dbg(i);
					dbg_puts(": overrun, discarding ");
					dbg_putu(i->used);
					dbg_puts(" bytes\n");
				}
#endif
				abuf_rdiscard(i, i->used);
			}
			odata = abuf_wgetblk(i, &ocount, 0);
			if (ocount > itodo)
				ocount = itodo;
#ifdef DEBUG
			if (debug_level >= 4) {
				abuf_dbg(i);
				dbg_puts(": stored ");
				dbg_putu(ocount);
				dbg_puts(" bytes\n");
			}
#endif
			memcpy(odata, idata, ocount);
			abuf_wcommit(i, ocount);
			itodo -= ocount;
			idata += ocount;
		}
d540 11
d748 1
d768 2
a769 1
	ctl_slotvol(p, idx, s->vol);
d846 1
a846 3
	msg[0] = MIDI_CTL | slot;
	msg[1] = MIDI_CTLVOL;
	msg[2] = vol;
d1015 2
a1016 1
	unsigned fps;
d1031 1
a1031 1
	    ibuf->r.midi.msg[1] == MIDI_CTLVOL) {
d1042 14
a1055 7
	if (ibuf->r.midi.idx == 6 &&
	    ibuf->r.midi.msg[0] == 0xf0 &&
	    ibuf->r.midi.msg[1] == 0x7f &&	/* type is realtime */
	    ibuf->r.midi.msg[3] == 0x06	&&	/* subtype is mmc */
	    ibuf->r.midi.msg[5] == 0xf7) {	/* subtype is mmc */
		switch (ibuf->r.midi.msg[4]) {
		case 0x01:	/* mmc stop */
d1064 3
a1066 1
		case 0x02:	/* mmc start */
d1075 25
a1099 16
		}
	}
	if (ibuf->r.midi.idx == 13 &&
	    ibuf->r.midi.msg[0] == 0xf0 &&
	    ibuf->r.midi.msg[1] == 0x7f &&
	    ibuf->r.midi.msg[3] == 0x06 &&
	    ibuf->r.midi.msg[4] == 0x44 &&
	    ibuf->r.midi.msg[5] == 0x06 &&
	    ibuf->r.midi.msg[6] == 0x01 &&
	    ibuf->r.midi.msg[12] == 0xf7) {
		switch (ibuf->r.midi.msg[7] >> 5) {
		case MTC_FPS_24:
			fps = 24;
			break;
		case MTC_FPS_25:
			fps = 25;
a1100 6
		case MTC_FPS_30:
			fps = 30;
			break;
		default:
			p->u.ctl.origin = 0;
			return;
d1102 1
a1102 6
		ctl_loc(p,
		    (ibuf->r.midi.msg[7] & 0x1f) * 3600 * MTC_SEC +
		    ibuf->r.midi.msg[8] * 60 * MTC_SEC +
		    ibuf->r.midi.msg[9] * MTC_SEC +
		    ibuf->r.midi.msg[10] * (MTC_SEC / fps) +
		    ibuf->r.midi.msg[11] * (MTC_SEC / 100 / fps));
@


1.31
log
@Terminate midi thru boxes trying to drain but that have no
outputs anymore, otherwise they can't be cleaned up by dev_close()
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.30 2010/10/21 19:10:52 ratchov Exp $	*/
d478 1
a478 1
			break;;
@


1.30
log
@fix style and typos in messages and comments
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.29 2010/10/21 18:57:42 ratchov Exp $	*/
d274 1
a274 1
	if (LIST_EMPTY(&p->ins))
d281 4
@


1.29
log
@use MODE_xxx and XRUN_xxx macros everywhere, and zap corresponding
AMSG_xxx macros, which in turns simplifies the code
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.28 2010/07/06 01:12:45 ratchov Exp $	*/
d567 1
a567 1
				dbg_puts(": too many instances");
@


1.28
log
@Handle all streams the same way because there's no actual
difference between audio files and client connections. Clean up
the way command line options are handled and clarify this in the
manual page: stream parameters (-Ccehjmrtvx) must precede stream
definitions (-ios) and per-device parameters (-abz) and stream
definitions (-ios) must precede device definitions (-f). Since
there's no ``server'' and ``non-server'' modes anymore, make the
-l option just detach the process.

ok and help from jakemsr and jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.27 2010/06/05 16:05:17 ratchov Exp $	*/
d563 7
a569 1
		if (unit == CTL_NSLOT)
d571 1
d575 1
a575 9
#ifdef DEBUG
	if (debug_level >= 3) {
		aproc_dbg(p);
		dbg_puts(": new control name is ");
		dbg_puts(name);
		dbg_putu(unit);
		dbg_puts("\n");
	}
#endif
d585 2
a586 1
				aproc_dbg(p);
d611 8
a618 1
	if (bestidx == CTL_NSLOT)
d620 1
d629 2
a630 1
		aproc_dbg(p);
@


1.27
log
@When closing the device, request clients using a midi control slot
to quit. Otherwise streams that are not attached to the device are
not closed.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.26 2010/06/04 07:02:59 ratchov Exp $	*/
d98 1
a98 1
			if (debug_level >= 4) {
d143 1
a143 1
		if (debug_level >= 4) {
d403 1
a403 1
				if (debug_level >= 4) {
@


1.26
log
@midi control aproc structure is can be destroyed before any stream
referencing it (for instance while a recording stream drains buffers
of a closed device). So, don't abort() if this happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.25 2010/06/04 06:15:28 ratchov Exp $	*/
d1123 2
a1124 2
		if (s->ops)
			return;
@


1.25
log
@Allow the audio device to be opened only while it's actually used.
This is necessary for uaudio devices, for instance to start aucat
before the device is plugged. Or to unplug a device whithout
having to restart aucat when another device is plugged.  This is
controlled with the new -a option.

Allow multiple audio devices to be used concurently, i.e.
multiple ``-f devname'' options to be used; -f options must follow
per-device options, which is what we do for other options.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.24 2010/05/08 15:35:45 ratchov Exp $	*/
a1163 7
#ifdef DEBUG
		if (s->ops != NULL) {
			ctl_slotdbg(p, i);
			dbg_puts(": still in use\n");
			dbg_panic();
		}
#endif
@


1.24
log
@prime play buffers as soon as the device is opened, otherwise a
midi client could start it with empty buffers, in turn hurting
audio clients.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.23 2010/05/07 07:07:51 ratchov Exp $	*/
d679 2
a680 2
	p->u.ctl.delta = MTC_SEC * dev_getpos();
	if (dev_rate % (30 * 4 * dev_round) == 0) {
d683 1
a683 1
	} else if (dev_rate % (25 * 4 * dev_round) == 0) {
d700 1
a700 1
	dev_wakeup();
d781 1
a781 1
	qfrlen = dev_rate * (MTC_SEC / (4 * p->u.ctl.fps));
a1157 1
#ifdef DEBUG
d1162 3
a1164 3
		/*
		 * XXX: shouldn't we abord() here ?
		 */
d1168 1
d1170 1
a1171 1
#endif
d1188 1
a1188 1
ctl_new(char *name)
d1195 1
@


1.23
log
@don't prime audio buffers if the device is only started to serve
as clock source for MIDI clients.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.22 2010/05/06 06:18:37 ratchov Exp $	*/
d700 1
a700 1
	dev_wakeup(0);
@


1.22
log
@allow volumes of uninitialized slots to be set
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.21 2010/05/02 11:54:26 ratchov Exp $	*/
d700 1
a700 1
	dev_wakeup(1);
@


1.21
log
@Clean up device handling code to clarify different initialization phases
and different device states. Split initialization in two phases:
first global variables are initialized then the audio hardware is opened.
Allow devices that don't support full-duplex to work in play-only or
record-only mode, even if ``-m play'' or ``-m rec'' are not specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.20 2010/04/24 06:18:23 ratchov Exp $	*/
d614 2
a618 1
	slot->vol = MIDI_MAXCTL;
d1000 1
a1002 1
		slot->vol = ibuf->r.midi.msg[2];
d1203 1
a1203 1
		strlcpy(p->u.ctl.slot[i].name, "unknown", CTL_NAMEMAX);
@


1.20
log
@rename ibuflist/obuflist -> ins/outs to cut long lines
from Thomas Pfaff, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.19 2010/04/06 20:07:01 ratchov Exp $	*/
d699 1
a699 2
	if (dev_pstate == DEV_INIT)
		dev_pstate = DEV_START;
@


1.19
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.18 2010/04/03 17:59:17 ratchov Exp $	*/
d252 1
a252 1
	for (i = LIST_FIRST(&p->obuflist); i != NULL; i = inext) {
d274 1
a274 1
	if (LIST_EMPTY(&p->ibuflist))
d326 1
a326 1
	for (i = LIST_FIRST(&p->ibuflist); i != NULL; i = inext) {
d394 1
a394 1
	for (i = LIST_FIRST(&p->obuflist); i != NULL; i = inext) {
d754 1
a754 1
	if (!LIST_EMPTY(&p->obuflist) || !LIST_EMPTY(&p->ibuflist))
d1126 1
a1126 1
	if (!LIST_EMPTY(&p->obuflist) || !LIST_EMPTY(&p->ibuflist))
d1142 1
a1142 1
	if (!LIST_EMPTY(&p->obuflist) || !LIST_EMPTY(&p->ibuflist))
@


1.18
log
@backout last change, committed by mistake, sorry...
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.16 2010/01/16 23:21:56 ratchov Exp $	*/
d135 1
a135 1
		dbg_putu(c);
a352 1
	aproc_dbg(p);
d354 1
a354 1
		dbg_puts("/none");
d359 1
a359 1
		dbg_puts("=");
d361 1
a361 1
		dbg_puts("/");
d396 1
a396 1
		if (i->duplex == ibuf)
d641 4
a644 2
		aproc_dbg(p);
		dbg_puts(": not in starting state\n");
d653 4
a656 2
			ctl_slotdbg(p, i);
			dbg_puts(": not ready to start, start delayed\n");
d666 4
a669 2
			ctl_slotdbg(p, i);
			dbg_puts(": started\n");
d679 1
a679 1
	if (dev_rate % (30 * 4 * dev_round)) {
d682 1
a682 1
	} else if (dev_rate % (25 * 4 * dev_round)) {
d690 8
a697 6
	ctl_slotdbg(p, caller);
	dbg_puts(": started server at ");
	dbg_puti(p->u.ctl.delta);
	dbg_puts(", ");
	dbg_puti(p->u.ctl.fps);
	dbg_puts(" mtc fps\n");
d699 2
d714 7
a720 1
	if (p == NULL)
d722 1
d745 1
a745 1
	if (p == NULL)
d798 1
a798 1
	if (p == NULL)
d826 1
a826 1
	if (p == NULL)
d850 1
a850 1
	if (p == NULL)
d861 112
d1014 1
a1014 1
			if (debug_level >= 1) {
d1019 1
a1019 11
			if (p->u.ctl.tstate == CTL_RUN ||
		            p->u.ctl.tstate == CTL_START) 
				p->u.ctl.tstate = CTL_STOP;
#ifdef DEBUG
			else {
				if (debug_level >= 1) {
					aproc_dbg(p);
					dbg_puts(": ignored mmc stop\n");
				}
			}
#endif
d1023 1
a1023 1
			if (debug_level >= 1) {
d1028 1
a1028 11
			if (p->u.ctl.tstate == CTL_STOP) {
				p->u.ctl.tstate = CTL_START;
				(void)ctl_trystart(p, -1);
#ifdef DEBUG
			} else {
				if (debug_level >= 1) {
					abuf_dbg(ibuf);
					dbg_puts(": ignoring mmc start\n");
				}
#endif
			}
d1054 1
a1054 1
		p->u.ctl.origin =
d1059 1
a1059 9
		    ibuf->r.midi.msg[11] * (MTC_SEC / 100 / fps);
#ifdef DEBUG
		if (debug_level >= 1) {
			aproc_dbg(p);
			dbg_puts(": relocated to ");
			dbg_putu(p->u.ctl.origin);
			dbg_puts("\n");
		}
#endif
@


1.17
log
@doc fixes from jmc
@
text
@d135 1
a135 1
		dbg_putx(c);
d353 1
d355 1
a355 1
		dbg_puts("none");
d360 1
a360 1
		dbg_puts("(");
d362 1
a362 1
		dbg_puts(")/");
d397 1
a397 1
		if (i->duplex && i->duplex == ibuf)
d642 2
a643 4
		if (debug_level >= 3) {
			ctl_slotdbg(p, caller);
			dbg_puts(": server not started, delayd\n");
		}
d652 2
a653 4
			if (debug_level >= 3) {
				ctl_slotdbg(p, i);
				dbg_puts(": not ready, server delayed\n");
			}
d663 2
a664 4
			if (debug_level >= 3) {
				ctl_slotdbg(p, i);
				dbg_puts(": started\n");
			}
d674 1
a674 1
	if (dev_rate % (30 * 4 * dev_round) == 0) {
d677 1
a677 1
	} else if (dev_rate % (25 * 4 * dev_round) == 0) {
d685 6
a690 8
	if (debug_level >= 3) {
		ctl_slotdbg(p, caller);
		dbg_puts(": started server at ");
		dbg_puti(p->u.ctl.delta);
		dbg_puts(", ");
		dbg_puti(p->u.ctl.fps);
		dbg_puts(" mtc fps\n");
	}
a691 2
	if (dev_pstate == DEV_INIT)
		dev_pstate = DEV_START;
d705 1
a705 7
	if (!APROC_OK(p)) {
#ifdef DEBUG
		if (debug_level >= 1) {
			dbg_puts(who);
			dbg_puts(": MIDI control not available\n");
		}
#endif
a706 1
	}
d729 1
a729 1
	if (!APROC_OK(p))
d782 1
a782 1
	if (!APROC_OK(p))
d810 1
a810 1
	if (!APROC_OK(p))
d834 1
a834 1
	if (!APROC_OK(p))
a844 112
 * start all slots simultaneously
 */
void
ctl_start(struct aproc *p)
{
	if (!APROC_OK(p))
		return;
	if (p->u.ctl.tstate == CTL_STOP) {
		p->u.ctl.tstate = CTL_START;
		(void)ctl_trystart(p, -1);
#ifdef DEBUG
	} else {
		if (debug_level >= 3) {
			aproc_dbg(p);
			dbg_puts(": ignoring mmc start\n");
		}
#endif
	}
}

/*
 * stop all slots simultaneously
 */
void
ctl_stop(struct aproc *p)
{
	unsigned i;
	struct ctl_slot *s;

	if (!APROC_OK(p))
		return;
	switch (p->u.ctl.tstate) {
	case CTL_START:
		p->u.ctl.tstate = CTL_STOP;
		return;
	case CTL_RUN:
		p->u.ctl.tstate = CTL_STOP;
		break;
	default:
#ifdef DEBUG
		if (debug_level >= 3) {
			aproc_dbg(p);
			dbg_puts(": ignored mmc stop\n");
		}
#endif
		return;
	}
	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		if (!s->ops)
			continue;
		if (s->tstate == CTL_RUN) {
#ifdef DEBUG
			if (debug_level >= 3) {
				ctl_slotdbg(p, i);
				dbg_puts(": requested to stop\n");
			}
#endif
			s->ops->stop(s->arg);
		}
	}
}

/*
 * relocate all slots simultaneously
 */
void
ctl_loc(struct aproc *p, unsigned origin)
{
	unsigned i, tstate;
	struct ctl_slot *s;

	if (!APROC_OK(p))
		return;
#ifdef DEBUG
	if (debug_level >= 2) {
		dbg_puts("server relocated to ");
		dbg_putu(origin);
		dbg_puts("\n");
	}
#endif
	tstate = p->u.ctl.tstate;
	if (tstate == CTL_RUN)
		ctl_stop(p);
	p->u.ctl.origin = origin;
	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		if (!s->ops)
			continue;
		s->ops->loc(s->arg, p->u.ctl.origin);
	}
	if (tstate == CTL_RUN)
		ctl_start(p);
}

/*
 * check if there are controlled streams
 */
int
ctl_idle(struct aproc *p)
{
	unsigned i;
	struct ctl_slot *s;

	if (!APROC_OK(p))
		return 1;
	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		if (s->ops)
			return 0;
	}
	return 1;
}

/*
d886 1
a886 1
			if (debug_level >= 3) {
d891 11
a901 1
			ctl_stop(p);
d905 1
a905 1
			if (debug_level >= 3) {
d910 11
a920 1
			ctl_start(p);
d946 1
a946 1
		ctl_loc(p,
d951 9
a959 1
		    ibuf->r.midi.msg[11] * (MTC_SEC / 100 / fps));
@


1.16
log
@don't transmit MIDI active sensing messages, because they
cannot be merged.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.15 2010/01/16 23:18:31 ratchov Exp $	*/
d135 1
a135 1
		dbg_putu(c);
a352 1
	aproc_dbg(p);
d354 1
a354 1
		dbg_puts("/none");
d359 1
a359 1
		dbg_puts("=");
d361 1
a361 1
		dbg_puts("/");
d396 1
a396 1
		if (i->duplex == ibuf)
d641 4
a644 2
		aproc_dbg(p);
		dbg_puts(": not in starting state\n");
d653 4
a656 2
			ctl_slotdbg(p, i);
			dbg_puts(": not ready to start, start delayed\n");
d666 4
a669 2
			ctl_slotdbg(p, i);
			dbg_puts(": started\n");
d679 1
a679 1
	if (dev_rate % (30 * 4 * dev_round)) {
d682 1
a682 1
	} else if (dev_rate % (25 * 4 * dev_round)) {
d690 8
a697 6
	ctl_slotdbg(p, caller);
	dbg_puts(": started server at ");
	dbg_puti(p->u.ctl.delta);
	dbg_puts(", ");
	dbg_puti(p->u.ctl.fps);
	dbg_puts(" mtc fps\n");
d699 2
d714 7
a720 1
	if (p == NULL)
d722 1
d745 1
a745 1
	if (p == NULL)
d798 1
a798 1
	if (p == NULL)
d826 1
a826 1
	if (p == NULL)
d850 1
a850 1
	if (p == NULL)
d861 112
d1014 1
a1014 1
			if (debug_level >= 1) {
d1019 1
a1019 11
			if (p->u.ctl.tstate == CTL_RUN ||
		            p->u.ctl.tstate == CTL_START) 
				p->u.ctl.tstate = CTL_STOP;
#ifdef DEBUG
			else {
				if (debug_level >= 1) {
					aproc_dbg(p);
					dbg_puts(": ignored mmc stop\n");
				}
			}
#endif
d1023 1
a1023 1
			if (debug_level >= 1) {
d1028 1
a1028 11
			if (p->u.ctl.tstate == CTL_STOP) {
				p->u.ctl.tstate = CTL_START;
				(void)ctl_trystart(p, -1);
#ifdef DEBUG
			} else {
				if (debug_level >= 1) {
					abuf_dbg(ibuf);
					dbg_puts(": ignoring mmc start\n");
				}
#endif
			}
d1054 1
a1054 1
		p->u.ctl.origin =
d1059 1
a1059 9
		    ibuf->r.midi.msg[11] * (MTC_SEC / 100 / fps);
#ifdef DEBUG
		if (debug_level >= 1) {
			aproc_dbg(p);
			dbg_puts(": relocated to ");
			dbg_putu(p->u.ctl.origin);
			dbg_puts("\n");
		}
#endif
@


1.15
log
@when closing the device, delete its MIDI end, if it has no writers.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.14 2010/01/10 21:47:41 ratchov Exp $	*/
d62 1
d139 2
@


1.14
log
@Add traces to help tracking subtle timing bugs often causing
underuns and overruns; such bugs are hard to debug with ktrace
or a debugger. They are also handy to debug or monitor code
using aucat.

To enable traces, compile aucat with ``make DEBUG=-DDEBUG'' and
use the -d option multiple times.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.13 2009/11/03 21:31:37 ratchov Exp $	*/
d271 1
a271 1
	if (LIST_EMPTY(&p->obuflist) || LIST_EMPTY(&p->ibuflist))
a277 4
	if (!(p->flags & APROC_QUIT))
		return;
	if (LIST_EMPTY(&p->obuflist) || LIST_EMPTY(&p->ibuflist))
		aproc_del(p);
@


1.13
log
@Allow any program using aucat to act as MMC slave and MTC master
transparently.  Multiple audio applications can be started
synchronously from external software/hardware supporting the
standard Start/Stop/Relocate messages. The server clock is exposed
through MTC, allowing non-audio software/hardware to be
synchronized to audio applications.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.12 2009/10/27 22:41:03 ratchov Exp $	*/
d35 3
d86 8
d96 8
d130 8
d139 8
d237 6
d348 36
d404 8
d417 8
d570 9
d586 8
d620 8
d642 4
d652 4
d663 4
d685 8
d785 8
d854 13
d886 6
d895 8
d905 6
d914 7
d953 8
d1059 14
@


1.12
log
@slightly cleanup the socket and control bits:
- reject bogus clients ignoring flow control during the start phase
- don't check if dev_midi is NULL, it can't be NULL anymore
- use ``struct ctl_ops'' instead of a simple call-backs
- don't try to flush play buffer if it's not attached yet
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.11 2009/10/10 12:43:09 ratchov Exp $	*/
d228 1
a228 1
	if (!(p->u.thru.flags & THRU_AUTOQUIT))
d237 1
a237 1
	if (!(p->u.thru.flags & THRU_AUTOQUIT))
d342 93
d514 46
d563 1
a563 1
ctl_slotnew(struct aproc *p, char *who, struct ctl_ops *ops, void *arg)
d568 2
d577 1
d589 5
d595 38
d645 2
d655 45
d707 1
d720 48
d824 11
d840 11
d889 1
d894 1
a899 1

@


1.11
log
@make dev_done() common to audio and MIDI, and drop dev_thrudone()
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.10 2009/10/09 16:49:48 ratchov Exp $	*/
d307 1
d342 2
a343 3
 * allocate a new slot (ie midi channel), register the given call-back
 * to be called volume is changed by MIDI. The call-back is invoked at
 * initialization to restore the saved volume.
d346 1
a346 1
ctl_slotnew(struct aproc *p, char *who, void (*cb)(void *, unsigned), void *arg)
d373 1
a373 1
		if (slot->cb == NULL)
d378 1
a378 1
	for (unit = 0; unit < CTL_NSLOT; unit++) {
d381 1
a381 1
		if ((umap & (1 << i)) == 0)
d388 1
a388 1
		if (slot->cb == NULL &&
a390 4
			slot->cb = cb;
			slot->arg = arg;
			slot->cb(slot->arg, slot->vol);
			ctl_slotvol(p, i, slot->vol);
d397 1
d402 1
a402 1
		if (slot->cb != NULL)
a416 4
	slot->cb = cb;
	slot->arg = arg;
	slot->cb(slot->arg, slot->vol);
	ctl_slotvol(p, bestidx, slot->vol);
d421 21
d447 1
a447 1
	p->u.ctl.slot[index].cb = NULL;
d481 1
a481 1
		if (slot->cb == NULL)
d484 1
a484 1
		slot->cb(slot->arg, slot->vol);
d588 1
a588 1
		p->u.ctl.slot[i].cb = NULL;
@


1.10
log
@Make abuf structure smaller:
 - put aproc-specific parameters into unions since they are never
   used together
 - remove constant ``data'' pointer always pointing the end of the
   abuf structure
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.9 2009/09/27 11:51:20 ratchov Exp $	*/
d228 4
d237 4
@


1.9
log
@remove all debug traces
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.8 2009/08/29 14:46:44 ratchov Exp $	*/
d73 1
a73 1
 * send the message stored in of ibuf->mdata to obuf
d81 2
a82 2
	itodo = ibuf->mused;
	idata = ibuf->mdata;
d98 1
a98 1
	ibuf->mused = 0;
d148 3
a150 3
			if (ibuf->mindex == 0 && ibuf->mstatus) {
				ibuf->mdata[ibuf->mused++] = ibuf->mstatus;
				ibuf->mindex++;
d152 3
a154 3
			ibuf->mdata[ibuf->mused++] = c;
			ibuf->mindex++;
			if (ibuf->mindex == ibuf->mlen) {
d156 3
a158 3
				if (ibuf->mstatus >= 0xf0)
					ibuf->mstatus = 0;
				ibuf->mindex = 0;
d160 2
a161 2
			if (ibuf->mused == MDATA_NMAX) {
				if (ibuf->mused == ibuf->mindex ||
d165 1
a165 1
					ibuf->mused = 0;
d168 1
a168 1
			if (ibuf->mused == ibuf->mindex ||
d172 4
a175 4
				ibuf->mused = 0;
			ibuf->mdata[0] = c;
			ibuf->mused = 1;
			ibuf->mlen = (c >= 0xf0) ? 
d178 1
a178 1
			if (ibuf->mlen == 1) {
d180 3
a182 3
				ibuf->mindex = 0;
				ibuf->mstatus = 0;
				ibuf->mlen = 0;
d184 2
a185 2
				ibuf->mstatus = c;
				ibuf->mindex = 1;
d201 1
a201 1
	if (ibuf->mtickets == 0) {
d205 3
a207 3
	if (todo > ibuf->mtickets)
		todo = ibuf->mtickets;
	ibuf->mtickets -= todo;
d238 5
a242 5
	ibuf->mused = 0;
	ibuf->mlen = 0;
	ibuf->mindex = 0;
	ibuf->mstatus = 0;
	ibuf->mtickets = MIDITHRU_XFER;
d280 2
a281 2
		tickets = i->mtickets;
		i->mtickets = MIDITHRU_XFER;
d453 3
a455 3
	if ((ibuf->mdata[0] & MIDI_CMDMASK) == MIDI_CTL &&
	    ibuf->mdata[1] == MIDI_CTLVOL) {
		chan = ibuf->mdata[0] & MIDI_CHANMASK;
d461 1
a461 1
		slot->vol = ibuf->mdata[2];
d463 1
a463 1
		ctl_sendmsg(p, ibuf, ibuf->mdata, ibuf->mlen);
d481 3
a483 3
			if (ibuf->mstatus == 0xf0 && c == 0xf7 &&
			    ibuf->mindex < MDATA_NMAX) {
				ibuf->mdata[ibuf->mindex++] = c;
d487 4
a490 4
			ibuf->mdata[0] = c;
			ibuf->mlen = common_len[c & 7];
			ibuf->mstatus = c;
			ibuf->mindex = 1;
d492 6
a497 6
			ibuf->mdata[0] = c;
			ibuf->mlen = voice_len[(c >> 4) & 7];
			ibuf->mstatus = c;
			ibuf->mindex = 1;
		} else if (ibuf->mstatus) {
			if (ibuf->mindex == MDATA_NMAX)
d499 4
a502 4
			if (ibuf->mindex == 0)
				ibuf->mdata[ibuf->mindex++] = ibuf->mstatus;
			ibuf->mdata[ibuf->mindex++] = c;
			if (ibuf->mindex == ibuf->mlen) {
d504 1
a504 1
				ibuf->mindex = 0;
d531 4
a534 4
	ibuf->mused = 0;
	ibuf->mlen = 0;
	ibuf->mindex = 0;
	ibuf->mstatus = 0;
@


1.8
log
@accept ``common'' messages (including system explusive) on the
control MIDI port.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.7 2009/08/27 06:31:13 ratchov Exp $	*/
a82 1
	DPRINTFN(4, "thru_flush: mused = %u\n", itodo);
a85 1
			DPRINTFN(2, "thru_flush: discarded %u\n", obuf->used);
a110 1
	DPRINTFN(4, "thru_rt:\n");
a111 1
		DPRINTFN(2, "thru_rt: discarded %u\n", obuf->used);
a198 2
	DPRINTFN(3, "thru_in: %s\n", p->name);

a201 1
		DPRINTFN(2, "thru_in: out of tickets\n");
a227 1
	DPRINTF("thru_eof: %s: eof\n", p->name);
a232 1
	DPRINTF("thru_hup: %s: detached\n", p->name);
a317 1
				DPRINTFN(2, "ctl_sendmsg: lost %u\n", i->used);
a322 1
			DPRINTFN(2, "ctl_sendmsg: xfer %u\n", ocount);
a375 3

	DPRINTF("ctl_newslot: using %s%u as control name\n", name, unit);

a382 1
			DPRINTFN(1, "ctl_newslot: reusing %u\n", i);
a411 1
	DPRINTFN(1, "ctl_newslot: %u overwritten)\n", bestidx);
a437 1
	DPRINTFN(1, "ctl_slotvol: [%u] -> %u\n", slot, vol);
a450 1
	unsigned i;
a452 9

#ifdef DEBUG
	if (debug_level > 0) {
		fprintf(stderr, "ctl_ev:");
		for (i = 0; i < ibuf->mindex; i++)
			fprintf(stderr, " %02x", ibuf->mdata[i]);
		fprintf(stderr, "\n");
	}
#endif
a520 1
	DPRINTF("ctl_eof: %s: eof\n", p->name);
a525 1
	DPRINTF("ctl_hup: %s: detached\n", p->name);
a539 10
	unsigned i;
	struct ctl_slot *s;

	for (i = 0, s = p->u.ctl.slot; i < CTL_NSLOT; i++, s++) {
		/*
		 * XXX: shouldn't we abord() here ?
		 */
		if (s->cb != NULL)
			DPRINTF("ctl_done: %s%u in use\n", s->name, s->unit);
	}
@


1.7
log
@when an audio program connects to aucat, restore the volume it
had the last time. For instance, this fixes the problem of programs
reopenning the connection to aucat very often and thus resetting
the volume setting all the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.6 2009/08/26 08:28:21 ratchov Exp $	*/
d475 1
a475 1
		for (i = 0; i < ibuf->mlen; i++)
d505 13
a517 2
		if (c >= 0xf0) {
			/* clock and common events not used yet */
d524 2
@


1.6
log
@when allocating the midi channel for the volume control of a new
client, pick the oldest unused channel rather than the first found.
This way new clients don't reuse channels of recently used applications,
thus improving a lot the client<->channel affinity.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.5 2009/08/26 06:10:15 ratchov Exp $	*/
d20 2
a21 4
 * use abuf->duplex to implement bidirectionnal sockets
 * that don't receive what they send
 *
 * use shadow variables in the midi merger
d72 3
d104 3
d125 4
a128 1

d273 5
d308 4
d343 5
d397 1
d400 2
a401 1
			DPRINTFN(1, "ctl_newslot: reusing %u\n", i);
d426 2
d430 2
a431 1
	DPRINTFN(1, "ctl_newslot: %u overwritten)\n", bestidx);
d435 3
d444 5
d455 1
d462 3
d488 2
a489 1
		slot->cb(slot->arg, ibuf->mdata[2]);
d560 3
d593 1
@


1.5
log
@don't mess with audio internals from within the midi bits. Instead
use a call-back interface. This allows easily sending volume changes
feedback to audio applications.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.4 2009/08/23 13:40:45 ratchov Exp $	*/
d334 1
d384 1
a384 1
	 * couldn't find a matching slot, pick the first free one
d386 10
a395 5
	for (i = 0, slot = p->u.ctl.slot; ; i++, slot++) {
		if (i == CTL_NSLOT)
			return -1;
		if (slot->cb == NULL)
			break;
d397 3
a399 1
	DPRINTFN(1, "ctl_newslot: overwritten %u\n", i);
d401 1
d405 2
a406 1
	return i;
d522 1
a522 1
			DPRINTF("ctl_done: %s%u not freed\n", s->name, s->unit);
d547 1
d551 1
@


1.4
log
@Make aucat remember the control channel number a client is using. When the
client connects again later, assign the same channel to it. This way
applications always get the same fader on MIDI control surfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.3 2009/08/21 16:48:03 ratchov Exp $	*/
d328 1
a328 1
ctl_slotnew(struct aproc *p, char *reqname, struct aproc *owner)
d338 1
a338 1
	for (i = 0, s = reqname; ; s++) {
d354 1
a354 1
		if (slot->owner == NULL)
d372 1
a372 1
		if (slot->owner == NULL &&
d375 2
a376 1
			slot->owner = owner;
d388 1
a388 1
		if (slot->owner == NULL)
d394 2
a395 1
	slot->owner = owner;
d402 1
a402 1
	p->u.ctl.slot[index].owner = NULL;
d422 1
a422 1
	struct aproc *owner;
d437 2
a438 2
		owner = p->u.ctl.slot[chan].owner;
		if (owner == NULL || LIST_EMPTY(&owner->obuflist))
d440 1
a440 3
		dev_setvol(
		    LIST_FIRST(&owner->obuflist),
		    MIDI_TO_ADATA(ibuf->mdata[2]));
d511 1
a511 1
		if (s->owner)
d533 1
d537 1
a537 1
	for (i = 0; i < CTL_NSLOT; i++) {
d539 1
a539 1
		p->u.ctl.slot[i].owner = NULL;
@


1.3
log
@make aucat(1) expose a MIDI device to control server behaviour in
realtime.  For now only the playback volume of individual streams can be
changed/monitored. To each stream is assigned a MIDI channel; the volume
is changed/monitored using the standard controller number 7.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.2 2009/08/19 05:54:15 ratchov Exp $	*/
d328 1
a328 1
ctl_slotnew(struct aproc *p, char *name, struct aproc *owner)
a330 1
	int index, i;
d332 2
d335 26
a360 3
	DPRINTF("ctl_newslot: called by %s \"%s\"\n", owner->name, name);
	for (index = 0, slot = p->u.ctl.slot; ; index++, slot++) {
		if (index == CTL_NSLOT)
d362 1
a362 1
		if (slot->owner == NULL)
d365 23
a387 2
	for (i = 0, s = name; ; s++) {
		if (i == CTL_NAMEMAX - 1 || *s == '\0') {
a388 4
		} else if (*s >= 'A' && *s <= 'Z') {
			slot->name[i++] = *s + 'a' - 'A';
		} else if (*s >= 'a' || *s <= 'z')
			slot->name[i++] = *s;
d390 3
a392 4
	if (i == 0)
		strlcpy(slot->name, "noname", CTL_NAMEMAX);
	else
		slot->name[i] = '\0';
d394 1
a394 3
	slot->unit = index;
	DPRINTFN(1, "ctl_newslot: %s%u\n", slot->name, slot->unit);
	return index;
@


1.2
log
@organize midi code like audio code, no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.1 2009/07/25 08:44:27 ratchov Exp $	*/
a31 1
#include "conf.h"
d34 2
d45 26
d293 210
@


1.1
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.c,v 1.31 2009/01/23 17:38:15 ratchov Exp $	*/
a42 2

struct aproc *thrubox = NULL;
@

