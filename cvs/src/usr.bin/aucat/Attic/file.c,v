head	1.32;
access;
symbols
	OPENBSD_5_6:1.31.0.6
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.6
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.4
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.2
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.2
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.32
date	2015.01.21.08.43.55;	author ratchov;	state dead;
branches;
next	1.31;
commitid	SYQcoS9jhSKqSJDL;

1.31
date	2013.11.18.17.37.45;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2012.03.29.20.08.22;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2011.10.12.07.20.04;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2011.06.27.07.22.00;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2011.06.02.19.03.58;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2011.06.02.16.58.02;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2011.03.15.10.31.31;	author okan;	state Exp;
branches;
next	1.23;

1.23
date	2010.11.05.16.09.50;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.20.06.56.54;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.10.12.32.45;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2010.07.06.20.06.35;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.02.10.43.30;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.10.21.47.41;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.27.11.51.20;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.25.10.52.19;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2009.02.04.20.35.14;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.23.17.38.15;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.29.17.59.08;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.27.14.23.40;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.16.21.16.08;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.16.17.08.32;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.16.17.01.58;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.26.08.49.44;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.14.09.58.55;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.14.09.48.50;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.23.07.15.46;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Simplify internals and rewrite file header parsing code:
- remove -M, -t, -w, -C, -x flags that don't make sense anymore
- make "-j off" the default (sndiod already does the job)
- don't limit the number of played/recorded files.
- add support for floating-point encoded files.
- add support for apple .aiff and sun/next .au files
@
text
@/*	$OpenBSD: file.c,v 1.31 2013/11/18 17:37:45 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * non-blocking file i/o module: each file can be read or written (or
 * both). To achieve non-blocking io, we simply use the poll() syscall
 * in an event loop. If a read() or write() syscall return EAGAIN
 * (operation will block), then the file is marked as "for polling", else
 * the file is not polled again.
 *
 * the module also provides trivial timeout implementation,
 * derived from:
 *
 * 	anoncvs@@moule.caoua.org:/midish
 *
 *		midish/timo.c rev 1.18
 * 		midish/mdep.c rev 1.71
 *
 * A timeout is used to schedule the call of a routine (the callback)
 * there is a global list of timeouts that is processed inside the
 * event loop. Timeouts work as follows:
 *
 *	first the timo structure must be initialized with timo_set()
 *
 *	then the timeout is scheduled (only once) with timo_add()
 *
 *	if the timeout expires, the call-back is called; then it can
 *	be scheduled again if needed. It's OK to reschedule it again
 *	from the callback
 *
 *	the timeout can be aborted with timo_del(), it is OK to try to
 *	abort a timout that has expired
 *
 */

#include <sys/time.h>
#include <sys/types.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "abuf.h"
#include "aproc.h"
#include "conf.h"
#include "file.h"
#ifdef DEBUG
#include "dbg.h"
#endif

#define MAXFDS 100
#define TIMER_USEC 10000

void timo_update(unsigned int);
void timo_init(void);
void timo_done(void);
void file_sigalrm(int);

struct timespec file_ts;
struct filelist file_list;
struct timo *timo_queue;
unsigned int timo_abstime;
int file_slowaccept = 0;
#ifdef DEBUG
long long file_wtime, file_utime;
#endif

/*
 * initialise a timeout structure, arguments are callback and argument
 * that will be passed to the callback
 */
void
timo_set(struct timo *o, void (*cb)(void *), void *arg)
{
	o->cb = cb;
	o->arg = arg;
	o->set = 0;
}

/*
 * schedule the callback in 'delta' 24-th of microseconds. The timeout
 * must not be already scheduled
 */
void
timo_add(struct timo *o, unsigned int delta)
{
	struct timo **i;
	unsigned int val;
	int diff;

#ifdef DEBUG
	if (o->set) {
		dbg_puts("timo_add: already set\n");
		dbg_panic();
	}
	if (delta == 0) {
		dbg_puts("timo_add: zero timeout is evil\n");
		dbg_panic();
	}
#endif
	val = timo_abstime + delta;
	for (i = &timo_queue; *i != NULL; i = &(*i)->next) {
		diff = (*i)->val - val;
		if (diff > 0) {
			break;
		}
	}
	o->set = 1;
	o->val = val;
	o->next = *i;
	*i = o;
}

/*
 * abort a scheduled timeout
 */
void
timo_del(struct timo *o)
{
	struct timo **i;

	for (i = &timo_queue; *i != NULL; i = &(*i)->next) {
		if (*i == o) {
			*i = o->next;
			o->set = 0;
			return;
		}
	}
#ifdef DEBUG
	if (debug_level >= 4)
		dbg_puts("timo_del: not found\n");
#endif
}

/*
 * routine to be called by the timer when 'delta' 24-th of microsecond
 * elapsed. This routine updates time referece used by timeouts and
 * calls expired timeouts
 */
void
timo_update(unsigned int delta)
{
	struct timo *to;
	int diff;

	/*
	 * update time reference
	 */
	timo_abstime += delta;

	/*
	 * remove from the queue and run expired timeouts
	 */
	while (timo_queue != NULL) {
		/*
		 * there is no overflow here because + and - are
		 * modulo 2^32, they are the same for both signed and
		 * unsigned integers
		 */
		diff = timo_queue->val - timo_abstime;
		if (diff > 0)
			break;
		to = timo_queue;
		timo_queue = to->next;
		to->set = 0;
		to->cb(to->arg);
	}
}

/*
 * initialize timeout queue
 */
void
timo_init(void)
{
	timo_queue = NULL;
	timo_abstime = 0;
}

/*
 * destroy timeout queue
 */
void
timo_done(void)
{
#ifdef DEBUG
	if (timo_queue != NULL) {
		dbg_puts("timo_done: timo_queue not empty!\n");
		dbg_panic();
	}
#endif
	timo_queue = (struct timo *)0xdeadbeef;
}

#ifdef DEBUG
void
file_dbg(struct file *f)
{
	dbg_puts(f->ops->name);
	dbg_puts("(");
	dbg_puts(f->name);
	dbg_puts("|");
	if (f->state & FILE_ROK)
		dbg_puts("r");
	if (f->state & FILE_RINUSE)
		dbg_puts("R");
	if (f->state & FILE_WOK)
		dbg_puts("w");
	if (f->state & FILE_WINUSE)
		dbg_puts("W");
	if (f->state & FILE_EOF)
		dbg_puts("e");
	if (f->state & FILE_HUP)
		dbg_puts("h");
	if (f->state & FILE_ZOMB)
		dbg_puts("Z");
	dbg_puts(")");
}
#endif

struct file *
file_new(struct fileops *ops, char *name, unsigned int nfds)
{
	struct file *f;

	LIST_FOREACH(f, &file_list, entry)
		nfds += f->ops->nfds(f);
	if (nfds > MAXFDS) {
#ifdef DEBUG
		if (debug_level >= 1) {
			dbg_puts(name);
			dbg_puts(": too many polled files\n");
		}
#endif
		return NULL;
	}
	f = malloc(ops->size);
	if (f == NULL)
		err(1, "file_new: %s", ops->name);
	f->ops = ops;
	f->name = name;
	f->state = 0;
#ifdef DEBUG
	f->cycles = 0;
#endif
	f->rproc = NULL;
	f->wproc = NULL;
	LIST_INSERT_HEAD(&file_list, f, entry);
#ifdef DEBUG
	if (debug_level >= 3) {
		file_dbg(f);
		dbg_puts(": created\n");
	}
#endif
	return f;
}

void
file_del(struct file *f)
{
#ifdef DEBUG
	if (debug_level >= 3) {
		file_dbg(f);
		dbg_puts(": terminating...\n");
	}
#endif
	if (f->state & (FILE_RINUSE | FILE_WINUSE)) {
		f->state |= FILE_ZOMB;
	} else {
		LIST_REMOVE(f, entry);
#ifdef DEBUG
		if (debug_level >= 3) {
			file_dbg(f);
			dbg_puts(": destroyed\n");
		}
#endif
		f->ops->close(f);
		free(f);
	}
}

int
file_poll(void)
{
	nfds_t nfds, n;
	short events, revents;
	struct pollfd pfds[MAXFDS];
	struct file *f, *fnext;
	struct aproc *p;
	struct timespec ts;
#ifdef DEBUG
	struct timespec sleepts;
#endif
	long long delta_nsec;
	int res;

	if (LIST_EMPTY(&file_list) && timo_queue == NULL) {
#ifdef DEBUG
		if (debug_level >= 3)
			dbg_puts("nothing to do...\n");
#endif
		return 0;
	}
	/*
	 * Fill the pfds[] array with files that are blocked on reading
	 * and/or writing, skipping those that are just waiting.
	 */
#ifdef DEBUG
	dbg_flush();
	if (debug_level >= 4) 
		dbg_puts("poll:");
#endif
	nfds = 0;
	LIST_FOREACH(f, &file_list, entry) {
		events = 0;
		if (f->rproc && !(f->state & FILE_ROK))
			events |= POLLIN;
		if (f->wproc && !(f->state & FILE_WOK))
			events |= POLLOUT;
#ifdef DEBUG
		if (debug_level >= 4) {
			dbg_puts(" ");
			file_dbg(f);
		}
#endif
		n = f->ops->pollfd(f, pfds + nfds, events);
		if (n == 0) {
			f->pfd = NULL;
			continue;
		}
		f->pfd = pfds + nfds;
		nfds += n;
	}
#ifdef DEBUG
	if (debug_level >= 4) {
		dbg_puts("\npfds[] =");
		for (n = 0; n < nfds; n++) {
			dbg_puts(" ");
			dbg_putx(pfds[n].events);
		}
		dbg_puts("\n");
	}
#endif
#ifdef DEBUG
	clock_gettime(CLOCK_MONOTONIC, &sleepts);
	file_utime += 1000000000LL * (sleepts.tv_sec - file_ts.tv_sec);
	file_utime += sleepts.tv_nsec - file_ts.tv_nsec;
#endif
	res = poll(pfds, nfds, -1);
	if (res < 0 && errno != EINTR)
		err(1, "poll");
	clock_gettime(CLOCK_MONOTONIC, &ts);
#ifdef DEBUG
	file_wtime += 1000000000LL * (ts.tv_sec - sleepts.tv_sec);
	file_wtime += ts.tv_nsec - sleepts.tv_nsec;
#endif
	delta_nsec = 1000000000LL * (ts.tv_sec - file_ts.tv_sec);
	delta_nsec += ts.tv_nsec - file_ts.tv_nsec;
#ifdef DEBUG
	if (delta_nsec < 0)
		dbg_puts("file_poll: negative time interval\n");
#endif
	file_ts = ts;
	if (delta_nsec >= 0 && delta_nsec < 1000000000LL)
		timo_update(delta_nsec / 1000);
	else {
#ifdef DEBUG
		if (debug_level >= 1)
			dbg_puts("ignored huge clock delta\n");
#endif
	}
	if (res <= 0)
		return 1;

	f = LIST_FIRST(&file_list);
	while (f != NULL) {
		if (f->pfd == NULL) {
			f = LIST_NEXT(f, entry);
			continue;
		}
		revents = f->ops->revents(f, f->pfd);
#ifdef DEBUG
		if (revents) {
			f->cycles++;
			if (f->cycles > FILE_MAXCYCLES) {
				file_dbg(f);
				dbg_puts(": busy loop, disconnecting\n");
				revents = POLLHUP;
			}
		}
#endif
		if (!(f->state & FILE_ZOMB) && (revents & POLLIN)) {
			revents &= ~POLLIN;
#ifdef DEBUG
			if (debug_level >= 4) {
				file_dbg(f);
				dbg_puts(": rok\n");
			}
#endif
			f->state |= FILE_ROK;
			f->state |= FILE_RINUSE;
			for (;;) {
				p = f->rproc;
				if (!p)
					break;
#ifdef DEBUG
				if (debug_level >= 4) {
					aproc_dbg(p);
					dbg_puts(": in\n");
				}
#endif
				if (!p->ops->in(p, NULL))
					break;
			}
			f->state &= ~FILE_RINUSE;
		}
		if (!(f->state & FILE_ZOMB) && (revents & POLLOUT)) {
			revents &= ~POLLOUT;
#ifdef DEBUG
			if (debug_level >= 4) {
				file_dbg(f);
				dbg_puts(": wok\n");
			}
#endif
			f->state |= FILE_WOK;
			f->state |= FILE_WINUSE;
			for (;;) {
				p = f->wproc;
				if (!p)
					break;
#ifdef DEBUG
				if (debug_level >= 4) {
					aproc_dbg(p);
					dbg_puts(": out\n");
				}
#endif
				if (!p->ops->out(p, NULL))
					break;
			}
			f->state &= ~FILE_WINUSE;
		}
		if (!(f->state & FILE_ZOMB) && (revents & POLLHUP)) {
#ifdef DEBUG
			if (debug_level >= 3) {
				file_dbg(f);
				dbg_puts(": disconnected\n");
			}
#endif
			f->state |= (FILE_EOF | FILE_HUP);
		}
		if (!(f->state & FILE_ZOMB) && (f->state & FILE_EOF)) {
#ifdef DEBUG
			if (debug_level >= 3) {
				file_dbg(f);
				dbg_puts(": eof\n");
			}
#endif
			p = f->rproc;
			if (p) {
				f->state |= FILE_RINUSE;
#ifdef DEBUG
				if (debug_level >= 3) {
					aproc_dbg(p);
					dbg_puts(": eof\n");
				}
#endif
				p->ops->eof(p, NULL);
				f->state &= ~FILE_RINUSE;
			}
			f->state &= ~FILE_EOF;
		}
		if (!(f->state & FILE_ZOMB) && (f->state & FILE_HUP)) {
#ifdef DEBUG
			if (debug_level >= 3) {
				file_dbg(f);
				dbg_puts(": hup\n");
			}
#endif
			p = f->wproc;
			if (p) {
				f->state |= FILE_WINUSE;
#ifdef DEBUG
				if (debug_level >= 3) {
					aproc_dbg(p);
					dbg_puts(": hup\n");
				}
#endif
				p->ops->hup(p, NULL);
				f->state &= ~FILE_WINUSE;
			}
			f->state &= ~FILE_HUP;
		}
		fnext = LIST_NEXT(f, entry);
		if (f->state & FILE_ZOMB)
			file_del(f);
		f = fnext;
	}
	if (LIST_EMPTY(&file_list) && timo_queue == NULL) {
#ifdef DEBUG
		if (debug_level >= 3)
			dbg_puts("no files anymore...\n");
#endif
		return 0;
	}
	return 1;
}

/*
 * handler for SIGALRM, invoked periodically
 */
void
file_sigalrm(int i)
{
	/* nothing to do, we only want poll() to return EINTR */
}


void
filelist_init(void)
{
	static struct sigaction sa;
	struct itimerval it;
	sigset_t set;

	sigemptyset(&set);
	(void)sigaddset(&set, SIGPIPE);
	if (sigprocmask(SIG_BLOCK, &set, NULL))
		err(1, "sigprocmask");
	LIST_INIT(&file_list);
	if (clock_gettime(CLOCK_MONOTONIC, &file_ts) < 0) {
		perror("clock_gettime");
		exit(1);
	}
        sa.sa_flags = SA_RESTART;
        sa.sa_handler = file_sigalrm;
        sigfillset(&sa.sa_mask);
        if (sigaction(SIGALRM, &sa, NULL) < 0) {
		perror("sigaction");
		exit(1);
	}
	it.it_interval.tv_sec = 0;
	it.it_interval.tv_usec = TIMER_USEC;
	it.it_value.tv_sec = 0;
	it.it_value.tv_usec = TIMER_USEC;
	if (setitimer(ITIMER_REAL, &it, NULL) < 0) {
		perror("setitimer");
		exit(1);
	}
	timo_init();
#ifdef DEBUG
	dbg_sync = 0;
#endif
}

void
filelist_done(void)
{
	struct itimerval it;
#ifdef DEBUG
	struct file *f;

	if (!LIST_EMPTY(&file_list)) {
		LIST_FOREACH(f, &file_list, entry) {
			file_dbg(f);
			dbg_puts(" not closed\n");
		}
		dbg_panic();
	}
	dbg_sync = 1;
	dbg_flush();
#endif
	timerclear(&it.it_value);
	timerclear(&it.it_interval);
	if (setitimer(ITIMER_REAL, &it, NULL) < 0) {
		perror("setitimer");
		exit(1);
	}
	timo_done();
}

unsigned int
file_read(struct file *f, unsigned char *data, unsigned int count)
{
	unsigned int n;
#ifdef DEBUG
	struct timespec ts0, ts1;
	long us;

	if (!(f->state & FILE_ROK)) {
		file_dbg(f);
		dbg_puts(": read: bad state\n");
		dbg_panic();
	}
	clock_gettime(CLOCK_MONOTONIC, &ts0);
#endif
	n = f->ops->read(f, data, count);
#ifdef DEBUG
	if (n > 0)
		f->cycles = 0;
	clock_gettime(CLOCK_MONOTONIC, &ts1);
	us = 1000000L * (ts1.tv_sec - ts0.tv_sec);
	us += (ts1.tv_nsec - ts0.tv_nsec) / 1000;
	if (debug_level >= 4 || (debug_level >= 2 && us >= 5000)) {
		dbg_puts(f->name);
		dbg_puts(": read ");
		dbg_putu(n);
		dbg_puts(" bytes in ");
		dbg_putu(us);
		dbg_puts("us\n");
	}
#endif
	return n;
}

unsigned int
file_write(struct file *f, unsigned char *data, unsigned int count)
{
	unsigned int n;
#ifdef DEBUG
	struct timespec ts0, ts1;
	long us;

	if (!(f->state & FILE_WOK)) {
		file_dbg(f);
		dbg_puts(": write: bad state\n");
		dbg_panic();
	}
	clock_gettime(CLOCK_MONOTONIC, &ts0);
#endif
	n = f->ops->write(f, data, count);
#ifdef DEBUG
	if (n > 0)
		f->cycles = 0;
	clock_gettime(CLOCK_MONOTONIC, &ts1);
	us = 1000000L * (ts1.tv_sec - ts0.tv_sec);
	us += (ts1.tv_nsec - ts0.tv_nsec) / 1000;
	if (debug_level >= 4 || (debug_level >= 2 && us >= 5000)) {
		dbg_puts(f->name);
		dbg_puts(": wrote ");
		dbg_putu(n);
		dbg_puts(" bytes in ");
		dbg_putu(us);
		dbg_puts("us\n");
	}
#endif
	return n;
}

void
file_eof(struct file *f)
{
	struct aproc *p;

#ifdef DEBUG
	if (debug_level >= 3) {
		file_dbg(f);
		dbg_puts(": eof requested\n");
	}
#endif
	if (!(f->state & (FILE_RINUSE | FILE_WINUSE))) {
		p = f->rproc;
		if (p) {
			f->state |= FILE_RINUSE;
#ifdef DEBUG
			if (debug_level >= 3) {
				aproc_dbg(p);
				dbg_puts(": eof\n");
			}
#endif
			p->ops->eof(p, NULL);
			f->state &= ~FILE_RINUSE;
		}
		if (f->state & FILE_ZOMB)
			file_del(f);
	} else {
		f->state &= ~FILE_ROK;
		f->state |= FILE_EOF;
	}
}

void
file_hup(struct file *f)
{
	struct aproc *p;

#ifdef DEBUG
	if (debug_level >= 3) {
		file_dbg(f);
		dbg_puts(": hup requested\n");
	}
#endif
	if (!(f->state & (FILE_RINUSE | FILE_WINUSE))) {
		p = f->wproc;
		if (p) {
			f->state |= FILE_WINUSE;
#ifdef DEBUG
			if (debug_level >= 3) {
				aproc_dbg(p);
				dbg_puts(": hup\n");
			}
#endif
			p->ops->hup(p, NULL);
			f->state &= ~FILE_WINUSE;
		}
		if (f->state & FILE_ZOMB)
			file_del(f);
	} else {
		f->state &= ~FILE_WOK;
		f->state |= FILE_HUP;
	}
}

void
file_close(struct file *f)
{
	struct aproc *p;

#ifdef DEBUG
	if (debug_level >= 3) {
		file_dbg(f);
		dbg_puts(": closing\n");
	}
#endif
	if (f->wproc == NULL && f->rproc == NULL)
		f->state |= FILE_ZOMB;
	if (!(f->state & (FILE_RINUSE | FILE_WINUSE))) {
		p = f->rproc;
		if (p) {
			f->state |= FILE_RINUSE;
#ifdef DEBUG
			if (debug_level >= 3) {
				aproc_dbg(p);
				dbg_puts(": eof\n");
			}
#endif
			p->ops->eof(p, NULL);
			f->state &= ~FILE_RINUSE;
		}
		p = f->wproc;
		if (p) {
			f->state |= FILE_WINUSE;
#ifdef DEBUG
			if (debug_level >= 3) {
				aproc_dbg(p);
				dbg_puts(": hup\n");
			}
#endif
			p->ops->hup(p, NULL);
			f->state &= ~FILE_WINUSE;
		}
		if (f->state & FILE_ZOMB)
			file_del(f);
	} else {
		f->state &= ~(FILE_ROK | FILE_WOK);
		f->state |= (FILE_EOF | FILE_HUP);
	}
}
@


1.31
log
@add missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.30
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.29 2012/03/29 20:08:22 ratchov Exp $	*/
d71 5
@


1.29
log
@Don't spin if accept() fails because it is out of file descriptors,
instead set a flag that skips the listening socket from the poll()
event loop. The flag is cleared whenever a file descriptor is closed
allowing accept() to be retried.
Explained by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.28 2011/10/12 07:20:04 ratchov Exp $	*/
d75 1
a75 1
unsigned timo_abstime;
d98 1
a98 1
timo_add(struct timo *o, unsigned delta)
d101 1
a101 1
	unsigned val;
d154 1
a154 1
timo_update(unsigned delta)
d235 1
a235 1
file_new(struct fileops *ops, char *name, unsigned nfds)
d594 2
a595 2
unsigned
file_read(struct file *f, unsigned char *data, unsigned count)
d597 1
a597 1
	unsigned n;
d628 2
a629 2
unsigned
file_write(struct file *f, unsigned char *data, unsigned count)
d631 1
a631 1
	unsigned n;
@


1.28
log
@Simplify and improve the way options are parsed and remove ~300 lines
of code that becomes unused. Few command line arguments changes are
required though:

  - stream definitions (-ios) now must follow devices definitions they
    are attached to (-fMn)

  - the -n option is now a special "loopback" device and is thus used
    like -f, eg it must precede streams

  - in midicat, midi thru boxes are not created automatically anymore,
    the new "-M" option must be used for that

  - channel numbers (-Cc options) correspond always to channel numbers
    of the hardware.

  - the -u option isn't needed anymore

  - increase the log verbosity so user errors are logged
    without using -d

tested by many, help from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.27 2011/06/27 07:22:00 ratchov Exp $	*/
d76 1
@


1.27
log
@Display the CPU usage when -ddddd is used, ie the time spent on
calculations compared to the time spend on sleeping in poll().
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.26 2011/06/02 19:03:58 ratchov Exp $	*/
d372 1
a372 1
	if (delta_nsec < 0) {
a373 2
		dbg_panic();
	}
d376 1
a376 1
	if (delta_nsec < 1000000000LL)
d380 2
a381 1
		dbg_puts("ignored huge clock delta\n");
@


1.26
log
@If there are no descriptors to poll, just sleep until SIGALRM
is posted and then update all timers and restart the event loop.
Fixes throtteling while midi inputs are drained.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.25 2011/06/02 16:58:02 ratchov Exp $	*/
d76 3
d303 3
d356 5
d365 4
a370 5
	if (delta_nsec > 0) {
		file_ts = ts;
		if (delta_nsec < 1000000000LL)
			timo_update(delta_nsec / 1000);
		else {
d372 11
a382 1
			dbg_puts("ignored huge clock delta\n");
a383 1
		}
@


1.25
log
@don't exit from the main loop if there are pending time outs.
Fixes midi inputs not being properly drained when they are
temporarily blocked to limit input data rate
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.24 2011/03/15 10:31:31 okan Exp $	*/
d27 1
a27 1
 * 	anoncvs@@moule.caoua.org:/cvs
d29 2
a30 2
 *		midish/timo.c rev 1.16
 * 		midish/mdep.c rev 1.69
d300 2
a301 1
	long delta_nsec;
d350 9
a358 11
	if (nfds > 0) {
		if (poll(pfds, nfds, -1) < 0) {
			if (errno == EINTR)
				return 1;
			err(1, "file_poll: poll failed");
		}
		clock_gettime(CLOCK_MONOTONIC, &ts);
		delta_nsec = 1000000000L * (ts.tv_sec - file_ts.tv_sec);
		delta_nsec += ts.tv_nsec - file_ts.tv_nsec;
		if (delta_nsec > 0) {
			file_ts = ts;
d360 4
d366 3
@


1.24
log
@use timerclear macro

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.23 2010/11/05 16:09:50 ratchov Exp $	*/
d302 1
a302 1
	if (LIST_EMPTY(&file_list)) {
d486 1
a486 1
	if (LIST_EMPTY(&file_list)) {
@


1.23
log
@unbreak compilation without DEBUG defined
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.22 2010/08/20 06:56:54 ratchov Exp $	*/
d560 2
a561 4
	it.it_value.tv_sec = 0;
	it.it_value.tv_usec = 0;
	it.it_interval.tv_sec = 0;
	it.it_interval.tv_usec = 0;
@


1.22
log
@polish the code: remove few unused #includes, add missing ones,
fix NULL vs 0, etc. No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.21 2010/07/10 12:32:45 ratchov Exp $	*/
d252 1
d254 1
@


1.21
log
@When a file is created, initialize its ``busy cycles'' counter to zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.20 2010/07/06 20:06:35 ratchov Exp $	*/
d49 1
d59 1
d362 1
a362 1
	while (f != LIST_END(&file_list)) {
@


1.20
log
@Try to detect busy loops caused by misbehaving audio drivers
or hardware. If a busy loop is found, then close the device that
caused the loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.19 2010/05/02 10:43:30 ratchov Exp $	*/
d250 1
@


1.19
log
@use clock_gettime() and interval timers instead of gettimeofday()
and poll()'s timeout. Simpler and more accurate, from midish
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.18 2010/04/06 20:07:01 ratchov Exp $	*/
d365 10
d583 2
d617 2
@


1.18
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.17 2010/04/03 17:59:17 ratchov Exp $	*/
d27 4
a30 1
 * 	anoncvs@@moule.caoua.org:/cvs/midish/timo.c rev 1.16
d68 1
d70 1
a70 1
struct timeval file_tv;
d100 1
a100 1
		dbg_puts("timo_set: already set\n");
d104 1
a104 1
		dbg_puts("timo_set: zero timeout is evil\n");
d294 2
a295 3
	struct timeval tv;
	long delta_usec;
	int timo;
d297 7
a343 7
	if (LIST_EMPTY(&file_list)) {
#ifdef DEBUG
		if (debug_level >= 3)
			dbg_puts("nothing to do...\n");
#endif
		return 0;
	}
d345 1
a345 7
		if (timo_queue) {
			timo = (timo_queue->val - timo_abstime) / (2 * 1000);
			if (timo == 0)
				timo = 1;
		} else
			timo = -1;
		if (poll(pfds, nfds, timo) < 0) {
d350 6
a355 6
		gettimeofday(&tv, NULL);
		delta_usec = 1000000L * (tv.tv_sec - file_tv.tv_sec);
		delta_usec += tv.tv_usec - file_tv.tv_usec;
		if (delta_usec > 0) {
			file_tv = tv;
			timo_update(delta_usec);
d481 10
d494 2
d503 19
a522 1
	gettimeofday(&file_tv, NULL);
d531 1
a536 1
			dbg_puts("\t");
d538 1
a538 1
			dbg_puts("\n");
d545 8
d561 2
a562 2
	struct timeval tv0, tv1, dtv;
	unsigned us;
a563 1
	gettimeofday(&tv0, NULL);
d569 1
d573 4
a576 4
	gettimeofday(&tv1, NULL);
	timersub(&tv1, &tv0, &dtv);
	us = dtv.tv_sec * 1000000 + dtv.tv_usec;
	if (debug_level >= 4 || (debug_level >= 1 && us >= 5000)) {
d593 2
a594 2
	struct timeval tv0, tv1, dtv;
	unsigned us;
d601 1
a601 1
	gettimeofday(&tv0, NULL);
d605 4
a608 4
	gettimeofday(&tv1, NULL);
	timersub(&tv1, &tv0, &dtv);
	us = dtv.tv_sec * 1000000 + dtv.tv_usec;
	if (debug_level >= 4 || (debug_level >= 1 && us >= 5000)) {
@


1.17
log
@backout last change, committed by mistake, sorry...
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.15 2010/01/10 21:47:41 ratchov Exp $	*/
a65 2
extern struct fileops listen_ops, pipe_ops;

a520 17
/*
 * Close all listening sockets.
 *
 * XXX: remove this
 */
void
filelist_unlisten(void)
{
	struct file *f, *fnext;

	for (f = LIST_FIRST(&file_list); f != NULL; f = fnext) {
		fnext = LIST_NEXT(f, entry);
		if (f->ops == &listen_ops)
			file_del(f);
	}
}

d660 2
@


1.16
log
@doc fixes from jmc
@
text
@d66 2
d523 17
a678 2
	if (f->wproc == NULL && f->rproc == NULL)
		f->state |= FILE_ZOMB;
@


1.15
log
@Add traces to help tracking subtle timing bugs often causing
underuns and overruns; such bugs are hard to debug with ktrace
or a debugger. They are also handy to debug or monitor code
using aucat.

To enable traces, compile aucat with ``make DEBUG=-DDEBUG'' and
use the -d option multiple times.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.14 2009/09/27 11:51:20 ratchov Exp $	*/
a65 2
extern struct fileops listen_ops, pipe_ops;

a520 17
/*
 * Close all listening sockets.
 *
 * XXX: remove this
 */
void
filelist_unlisten(void)
{
	struct file *f, *fnext;

	for (f = LIST_FIRST(&file_list); f != NULL; f = fnext) {
		fnext = LIST_NEXT(f, entry);
		if (f->ops == &listen_ops)
			file_del(f);
	}
}

d660 2
@


1.14
log
@remove all debug traces
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.13 2009/07/25 10:52:19 ratchov Exp $	*/
d60 3
d96 10
d134 4
d191 6
d200 25
d234 6
d251 6
d263 6
d273 6
d300 5
d312 6
d326 10
d337 4
d372 6
d384 6
d397 6
d409 6
d421 6
d430 6
d439 6
d451 6
d460 6
d477 4
d498 3
d506 14
d544 11
d556 13
d576 11
d588 13
d609 6
d619 6
d641 6
d651 6
d673 6
d683 6
d695 6
@


1.13
log
@fix comments, remove no longer needed declaration, reorder includes
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.12 2009/07/25 08:44:27 ratchov Exp $	*/
a92 10
#ifdef DEBUG
	if (o->set) {
		fprintf(stderr, "timo_set: already set\n");
		abort();
	}
	if (delta == 0) {
		fprintf(stderr, "timo_set: zero timeout is evil\n");
		abort();
	}
#endif
a120 1
	DPRINTF("timo_del: not found\n");
a173 4
	if (timo_queue != NULL) {
		fprintf(stderr, "timo_done: timo_queue not empty!\n");
		abort();
	}
a176 18
void
file_dprint(int n, struct file *f)
{
#ifdef DEBUG
	if (debug_level < n)
		return;
	fprintf(stderr, "%s:%s <", f->ops->name, f->name);
	if (f->state & FILE_ROK)
		fprintf(stderr, "ROK");
	if (f->state & FILE_WOK)
		fprintf(stderr, "WOK");
	if (f->state & FILE_EOF)
		fprintf(stderr, "EOF");
	if (f->state & FILE_HUP)
		fprintf(stderr, "HUP");
	fprintf(stderr, ">");
#endif
}
a185 1
		DPRINTF("file_new: %s: too many polled files\n", name);
a196 1
	DPRINTF("file_new: %s:%s\n", ops->name, f->name);
a202 2
	DPRINTF("file_del: ");
	file_dprint(1, f);
a203 1
		DPRINTF(": delayed\n");
a204 1
		return;
a205 1
		DPRINTF(": immediate\n");
a227 1
	DPRINTFN(4, "file_poll:");
a234 1
		DPRINTFN(4, " %s(%x)", f->name, events);
a242 7
	DPRINTFN(4, "\n");
	if (debug_level >= 4) {
		DPRINTF("file_poll: pfds[] =");
		for (n = 0; n < nfds; n++)
			DPRINTF(" %x", pfds[n].events);
		DPRINTF("\n");
	}
a243 1
		DPRINTF("file_poll: nothing to do...\n");
a275 1
			DPRINTFN(3, "file_poll: %s rok\n", f->name);
d279 3
a281 1
				if (!p || !p->ops->in(p, NULL))
a288 1
			DPRINTFN(3, "file_poll: %s wok\n", f->name);
d292 3
a294 1
				if (!p || !p->ops->out(p, NULL))
a299 1
			DPRINTFN(2, "file_poll: %s: disconnected\n", f->name);
a302 1
			DPRINTFN(2, "file_poll: %s: eof\n", f->name);
a311 1
			DPRINTFN(2, "file_poll: %s hup\n", f->name);
a325 1
		DPRINTFN(2, "file_poll: terminated\n");
a347 2
	struct file *f;

a348 9
	if (!LIST_EMPTY(&file_list)) {
		fprintf(stderr, "filelist_done: list not empty:\n");
		LIST_FOREACH(f, &file_list, entry) {
			fprintf(stderr, "\t");
			file_dprint(0, f);
			fprintf(stderr, "\n");
		}
		abort();
	}
d369 1
a369 1
file_read(struct file *file, unsigned char *data, unsigned count)
d371 3
a373 1
	return file->ops->read(file, data, count);
d377 1
a377 1
file_write(struct file *file, unsigned char *data, unsigned count)
d379 3
a381 1
	return file->ops->write(file, data, count);
a389 1
		DPRINTFN(2, "file_eof: %s: immediate\n", f->name);
a398 1
		DPRINTFN(2, "file_eof: %s: delayed\n", f->name);
a409 1
		DPRINTFN(2, "file_hup: %s immediate\n", f->name);
a418 1
		DPRINTFN(2, "file_hup: %s: delayed\n", f->name);
a429 1
		DPRINTFN(2, "file_close: %s: immediate\n", f->name);
a444 1
		DPRINTFN(2, "file_close: %s: delayed\n", f->name);
@


1.12
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.11 2009/02/04 20:35:14 ratchov Exp $	*/
d56 2
a59 2
#include "aproc.h"
#include "abuf.h"
d265 2
a266 2
	 * fill the pfds[] array with files that are blocked on reading
	 * and/or writing, skipping those that're just waiting
d415 1
a415 1
 * close all listening sockets
@


1.11
log
@if there are too many connections, stop acceping new ones rather
than exit()ing with ``too many open files'' fatal error
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.10 2009/01/23 17:38:15 ratchov Exp $	*/
d24 20
d45 1
d64 2
d67 124
a229 1
	f->refs = 0;
d240 1
a240 1
	if (f->refs > 0) {
d260 3
a262 3
#ifdef DEBUG
	unsigned nused, nfound;
#endif
a269 4
#ifdef DEBUG
	nused = 0;
	nfound = 0;
#endif
a275 6
#ifdef DEBUG
		if (events)
			nused++;
		if (f->rproc || f->wproc)
			nfound++;
#endif
d286 5
a290 5

#ifdef DEBUG
	if (nused == 0 && nfound > 0) {
		fprintf(stderr, "file_poll: deadlock\n");
		abort();
a291 1
#endif
d297 7
a303 1
		if (poll(pfds, nfds, -1) < 0) {
d308 7
a321 1
		f->refs++;
d327 1
d333 1
d339 1
d345 1
d354 2
a355 1
			if (p)
d357 2
d364 2
a365 1
			if (p)
d367 2
a370 1
		f->refs--;
a391 1

d393 2
d402 1
d448 1
a448 1
	if (f->refs == 0) {
a449 1
		f->refs++;
d451 2
a452 1
		if (p)
d454 2
a455 1
		f->refs--;
d470 1
a470 1
	if (f->refs == 0) {
a471 1
		f->refs++;
d473 2
a474 1
		if (p)
d476 2
a477 1
		f->refs--;
d492 1
a492 1
	if (f->refs == 0) {
a493 1
		f->refs++;
d495 2
a496 1
		if (p)
d498 2
d501 2
a502 1
		if (p)
d504 2
a505 1
		f->refs--;
@


1.10
log
@spacing + typo fix from Matt Jibson <matt.jibson(at)gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.9 2008/12/29 17:59:08 ratchov Exp $	*/
d71 4
a74 3
	if (nfds > MAXFDS)
		err(1, "%s: too many polled files", name);

@


1.9
log
@make the code "more correct": add reference counters to aproc
structures so we can keep a pointer to the device. Beside some
simplifications, this allows to easily handle the situation
where the audio device desappears. No change in the behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.8 2008/12/27 14:23:40 ratchov Exp $	*/
d264 1
a264 1
	
@


1.8
log
@complain about a deadlock only if there are descriptors waiting
for i/o and none of them is polled. This avoids false positives
caused by listening sockets in server mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.7 2008/11/16 21:16:08 ratchov Exp $	*/
d160 6
a165 4
	if (poll(pfds, nfds, -1) < 0) {
		if (errno == EINTR)
			return 1;
		err(1, "file_poll: poll failed");
d323 24
@


1.7
log
@trigger rproc->eof() and and wproc->hup() if POLLHUP event is set.
Fixes aucat sleeping forever when the devices disappears
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.6 2008/11/16 17:08:32 ratchov Exp $	*/
d114 1
a114 1
	unsigned nused;
d125 1
d136 2
d151 1
a151 1
	if (nused == 0 && !LIST_EMPTY(&file_list)) {
@


1.6
log
@make aucat compile without DEBUG defined (still defined by default)
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.5 2008/11/16 17:01:58 ratchov Exp $	*/
d189 4
@


1.5
log
@in file_poll() the number of polled file structures is not equal to the
number of polled descriptors. Count the number of polled structrues to
detect deadlocks rather than the number of descriptors, avoinding false
positives.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.4 2008/10/26 08:49:44 ratchov Exp $	*/
d48 1
d61 1
@


1.4
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.3 2008/08/14 09:58:55 ratchov Exp $	*/
d111 3
d121 3
d130 4
d146 1
a146 1
	if (nfds == 0 && !LIST_EMPTY(&file_list)) {
@


1.3
log
@move all device related stuff from aucat.c to a new dev.c file.
The new dev_xxx() routines expose a "high level" self-contained
interface to the device. At initialization, the device is opened
and two chains of aproc structures are created:

 * a playback chain that exposes a (initially) empty mix
   aproc to which the rest of the code can attach new
   streams to be played

 * record chain that exposes a (initially) empty sub aproc
   to which the rest of the code can attach new stream to
   to record

The rest of the code, has just to use dev_attach() routine to
attach streams. While we're at it, add a ``devops'' structure
containing pointers to the device-specific routines. This will
allow later to add support for other type of device than the
Sun API.

Also, write the .wav headers in file_del(), so put all header
related data in the file strucuture. This allows to close() the
file, as soon as wpipe_xxx() aproc terminates. This will be
useful for the server, because it will need to close() descripts
of closed connections immediately.

add mix_pushzero() routine to fill the mixer with silence. It
will be used to avoid the mixer to underrun when there are no
input streams. Since we always have at least one input stream
there's no behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.2 2008/08/14 09:48:50 ratchov Exp $	*/
a33 2
#include <string.h>
#include <unistd.h>
a38 1
#include "dev.h"
d42 1
d48 12
a59 12
	if (debug_level >= n) {
		fprintf(stderr, "%s <", f->name);
		if (f->state & FILE_ROK)
			fprintf(stderr, "ROK");
		if (f->state & FILE_WOK)
			fprintf(stderr, "WOK");
		if (f->state & FILE_EOF)
			fprintf(stderr, "EOF");
		if (f->state & FILE_HUP)
			fprintf(stderr, "HUP");
		fprintf(stderr, ">");
	}
d63 1
a63 1
file_new(int fd, char *name)
a64 1
	unsigned i;
a66 1
	i = 0;
d68 2
a69 2
		i++;		
	if (i >= MAXFDS)
d72 1
a72 1
	f = malloc(sizeof(struct file));
d74 2
a75 6
		err(1, "%s", name);

	f->fd = fd;
	f->events = 0;
	f->rbytes = -1;
	f->wbytes = -1;
d80 1
d82 1
a82 1
	DPRINTF("file_new: %s\n", f->name);
d91 10
a100 6
	DPRINTF("\n");

	if (f->hdr == HDR_WAV)
		wav_writehdr(f->fd, &f->hpar);
	close(f->fd);
	free(f);
d106 2
a107 4
#ifdef DEBUG
	int ndead;
#endif
	nfds_t nfds;
a108 1
	struct pollfd *pfd;
d112 5
a117 3
#ifdef DEBUG
	ndead = 0;
#endif
d119 8
a126 5
		if (!f->events) {
#ifdef DEBUG
			if (f->state & (FILE_EOF | FILE_HUP))
				ndead++;
#endif
d130 2
a131 4
		pfd = &pfds[nfds++];
		f->pfd = pfd;
		pfd->fd = f->fd;
		pfd->events = f->events;
d133 1
d136 1
a136 8
	if (debug_level >= 4) {
		fprintf(stderr, "file_poll:");
		LIST_FOREACH(f, &file_list, entry) {
			fprintf(stderr, " %s(%x)", f->name, f->events);
		}
		fprintf(stderr, "\n");
	}
	if (nfds == 0 && ndead == 0 && !LIST_EMPTY(&file_list)) {
d145 4
a148 5
	if (nfds) {
		while (poll(pfds, nfds, -1) < 0) {
			if (errno != EINTR)
				err(1, "file_poll: poll failed");
		}
d150 4
a153 3
	LIST_FOREACH(f, &file_list, entry) {
		pfd = f->pfd;
		if (pfd == NULL)
d155 5
a159 2
		if ((f->events & POLLIN) && (pfd->revents & POLLIN)) {
			f->events &= ~POLLIN;
d162 1
a162 1
			while (f->state & FILE_ROK) {
d168 2
a169 2
		if ((f->events & POLLOUT) && (pfd->revents & POLLOUT)) {
			f->events &= ~POLLOUT;
d172 1
a172 1
			while (f->state & FILE_WOK) {
d178 1
a178 3
	}
	LIST_FOREACH(f, &file_list, entry) {
		if (f->state & FILE_EOF) {
d185 1
a185 1
		if (f->state & FILE_HUP) {
d192 1
a192 2
	}
	for (f = LIST_FIRST(&file_list); f != NULL; f = fnext) {
d194 1
a194 3
		if (f->rproc == NULL && f->wproc == NULL) {
			LIST_REMOVE(f, entry);
			DPRINTF("file_poll: %s: removed\n", f->name);
d196 1
a196 1
		}
d206 1
a206 1
file_start(void)
d219 1
a219 1
file_stop(void)
d224 1
a224 1
		fprintf(stderr, "file_stop:");
d226 3
a228 1
			fprintf(stderr, " %s(%x)", f->name, f->events);
d230 1
a230 2
		fprintf(stderr, "\nfile_stop: list not empty\n");
		exit(1);
d234 7
a240 2
unsigned
file_read(struct file *file, unsigned char *data, unsigned count)
d242 1
a242 1
	int n;
d244 4
a247 22
	if (file->rbytes >= 0 && count > file->rbytes) {
		count = file->rbytes; /* file->rbytes fits in count */
		if (count == 0) {
			DPRINTFN(2, "file_read: %s: complete\n", file->name);
			file->state &= ~FILE_ROK;
			file->state |= FILE_EOF;
			return 0;
		}
	}
	while ((n = read(file->fd, data, count)) < 0) {
		if (errno == EINTR)
			continue;
		file->state &= ~FILE_ROK;
		if (errno == EAGAIN) {
			DPRINTFN(3, "file_read: %s: blocking...\n",
			    file->name);
			file->events |= POLLIN;
		} else {
			warn("%s", file->name);
			file->state |= FILE_EOF;
		}
		return 0;
a248 10
	if (n == 0) {
		DPRINTFN(2, "file_read: %s: eof\n", file->name);
		file->state &= ~FILE_ROK;
		file->state |= FILE_EOF;
		return 0;
	}
	if (file->rbytes >= 0)
		file->rbytes -= n;
	DPRINTFN(4, "file_read: %s: got %d bytes\n", file->name, n);
	return n;
d251 5
d260 1
a260 29
	int n;
	
	if (file->wbytes >= 0 && count > file->wbytes) {
		count = file->wbytes; /* file->wbytes fits in count */
		if (count == 0) {
			DPRINTFN(2, "file_write: %s: complete\n", file->name);
			file->state &= ~FILE_WOK;
			file->state |= FILE_HUP;
			return 0;
		}
	}
	while ((n = write(file->fd, data, count)) < 0) {
		if (errno == EINTR)
			continue;
		file->state &= ~FILE_WOK;
		if (errno == EAGAIN) {
			DPRINTFN(3, "file_write: %s: blocking...\n",
			    file->name);
			file->events |= POLLOUT;
		} else {
			warn("%s", file->name);
			file->state |= FILE_HUP;
		}
		return 0;
	}
	if (file->wbytes >= 0)
		file->wbytes -= n;
	DPRINTFN(4, "file_write: %s: wrote %d bytes\n", file->name, n);
	return n;
d266 16
a281 4
	DPRINTFN(2, "file_eof: %s: scheduled for eof\n", f->name);
	f->events &= ~POLLIN;
	f->state &= ~FILE_ROK;
	f->state |= FILE_EOF;
d287 16
a302 4
	DPRINTFN(2, "file_hup: %s: scheduled for hup\n", f->name);
	f->events &= ~POLLOUT;
	f->state &= ~FILE_WOK;
	f->state |= FILE_HUP;
@


1.2
log
@in file.c, before dereferencing pointers to in(), out(), eof(),
hup() routines of the aproc strucure check that the aproc
structure has not desappeared. This never happens currently, but
will be allowed later. No behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.1 2008/05/23 07:15:46 ratchov Exp $	*/
d34 1
d41 1
d47 17
d96 8
a103 1
	DPRINTF("file_del: %s|%x\n", f->name, f->state);
d205 2
a206 2
			DPRINTF("file_poll: %s: deleted\n", f->name);
			free(f);
@


1.1
log
@add support for:
 - recording, full-duplex operation
 - format conversions and resampling on the fly
 - mixing on the fly of multiple inputs of different formats
 - up to 16 channels, simplistic "routing" of channel ranges
 - more linear encodings (in raw and wav files)
the old behaviour is fully preserved if none of the new -i and -o
options are used.

code and fixes from jakemsr@@ and eric@@, suggestions by others.
ok "go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
d143 2
a144 1
				if (!f->rproc->ops->in(f->rproc, NULL))
d153 2
a154 1
				if (!f->wproc->ops->out(f->wproc, NULL))
d162 3
a164 1
			f->rproc->ops->eof(f->rproc, NULL);
d169 3
a171 1
			f->wproc->ops->hup(f->wproc, NULL);
@

