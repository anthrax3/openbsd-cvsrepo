head	1.15;
access;
symbols
	OPENBSD_5_6:1.14.0.12
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.10
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.6
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.4
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.4
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.15
date	2015.01.21.08.43.55;	author ratchov;	state dead;
branches;
next	1.14;
commitid	SYQcoS9jhSKqSJDL;

1.14
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2012.03.29.20.08.22;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2011.11.20.22.54.51;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.27.07.22.00;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.06.20.06.35;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.27.11.51.20;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2009.07.25.10.52.19;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.23.17.38.15;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.29.17.59.08;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.26.08.49.44;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.14.09.58.55;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.02.17.05.12;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.23.07.15.46;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Simplify internals and rewrite file header parsing code:
- remove -M, -t, -w, -C, -x flags that don't make sense anymore
- make "-j off" the default (sndiod already does the job)
- don't limit the number of played/recorded files.
- add support for floating-point encoded files.
- add support for apple .aiff and sun/next .au files
@
text
@/*	$OpenBSD: file.h,v 1.14 2012/04/11 06:05:43 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifndef FILE_H
#define FILE_H

#include <sys/queue.h>
#include <sys/types.h>

struct file;
struct aproc;
struct pollfd;

struct timo {
	struct timo *next;
	unsigned int val;		/* time to wait before the callback */
	unsigned int set;		/* true if the timeout is set */
	void (*cb)(void *arg);		/* routine to call on expiration */
	void *arg;			/* argument to give to 'cb' */
};

struct fileops {
	char *name;
	size_t size;
	void (*close)(struct file *);
	unsigned int (*read)(struct file *, unsigned char *, unsigned int);
	unsigned int (*write)(struct file *, unsigned char *, unsigned int);
	void (*start)(struct file *, void (*)(void *, int), void *);
	void (*stop)(struct file *);
	int (*nfds)(struct file *);
	int (*pollfd)(struct file *, struct pollfd *, int);
	int (*revents)(struct file *, struct pollfd *);
};

struct file {
	struct fileops *ops;
	struct pollfd *pfd;		/* arg to poll(2) syscall */
#define FILE_ROK	0x1		/* file readable */
#define FILE_WOK	0x2		/* file writable */
#define FILE_EOF	0x4		/* eof on the read end */
#define FILE_HUP	0x8		/* hang-up on the write end */
#define FILE_ZOMB	0x10		/* closed, but struct not freed */
#define FILE_RINUSE	0x20		/* inside rproc->ops->in() */
#define FILE_WINUSE	0x40		/* inside wproc->ops->out() */
	unsigned int state;		/* one of above */
#ifdef DEBUG
#define FILE_MAXCYCLES	20
	unsigned int cycles;		/* number of POLLIN/POLLOUT events */
#endif
	char *name;			/* for debug purposes */
	struct aproc *rproc, *wproc;	/* reader and/or writer */
	LIST_ENTRY(file) entry;
};

LIST_HEAD(filelist,file);

extern struct filelist file_list;
extern int file_slowaccept;

#ifdef DEBUG
extern long long file_wtime, file_utime;
#endif

void timo_set(struct timo *, void (*)(void *), void *);
void timo_add(struct timo *, unsigned int);
void timo_del(struct timo *);

void filelist_init(void);
void filelist_done(void);
void filelist_unlisten(void);

struct file *file_new(struct fileops *, char *, unsigned int);
void file_del(struct file *);
void file_dbg(struct file *);

void file_attach(struct file *, struct aproc *, struct aproc *);
unsigned int file_read(struct file *, unsigned char *, unsigned int);
unsigned int file_write(struct file *, unsigned char *, unsigned int);
int file_poll(void);
void file_eof(struct file *);
void file_hup(struct file *);
void file_close(struct file *);

#endif /* !defined(FILE_H) */
@


1.14
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.13 2012/03/29 20:08:22 ratchov Exp $	*/
@


1.13
log
@Don't spin if accept() fails because it is out of file descriptors,
instead set a flag that skips the listening socket from the poll()
event loop. The flag is cleared whenever a file descriptor is closed
allowing accept() to be retried.
Explained by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.12 2011/11/20 22:54:51 ratchov Exp $	*/
d29 2
a30 2
	unsigned val;			/* time to wait before the callback */
	unsigned set;			/* true if the timeout is set */
d39 2
a40 2
	unsigned (*read)(struct file *, unsigned char *, unsigned);
	unsigned (*write)(struct file *, unsigned char *, unsigned);
d58 1
a58 1
	unsigned state;			/* one of above */
d61 1
a61 1
	unsigned cycles;		/* number of POLLIN/POLLOUT events */
d78 1
a78 1
void timo_add(struct timo *, unsigned);
d85 1
a85 1
struct file *file_new(struct fileops *, char *, unsigned);
d90 2
a91 2
unsigned file_read(struct file *, unsigned char *, unsigned);
unsigned file_write(struct file *, unsigned char *, unsigned);
@


1.12
log
@Move mmc/mtc and volume control bits from struct aproc to struct
dev. Allows volume settings to be saved while the device is kept
closed. Besides that, no behabiour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.11 2011/06/27 07:22:00 ratchov Exp $	*/
d71 1
@


1.11
log
@Display the CPU usage when -ddddd is used, ie the time spent on
calculations compared to the time spend on sleeping in poll().
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.10 2010/07/06 20:06:35 ratchov Exp $	*/
d41 1
a41 1
	void (*start)(struct file *);
@


1.10
log
@Try to detect busy loops caused by misbehaving audio drivers
or hardware. If a busy loop is found, then close the device that
caused the loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.9 2009/09/27 11:51:20 ratchov Exp $	*/
d71 4
@


1.9
log
@remove all debug traces
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.8 2009/07/25 10:52:19 ratchov Exp $	*/
d59 4
@


1.8
log
@fix comments, remove no longer needed declaration, reorder includes
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.7 2009/07/25 08:44:27 ratchov Exp $	*/
d78 1
@


1.7
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.6 2009/01/23 17:38:15 ratchov Exp $	*/
a23 1
struct aparams;
a24 1
struct abuf;
@


1.6
log
@spacing + typo fix from Matt Jibson <matt.jibson(at)gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.5 2008/12/29 17:59:08 ratchov Exp $	*/
d29 8
d58 2
a60 1
	unsigned refs;			/* reference counter */
d69 4
@


1.5
log
@make the code "more correct": add reference counters to aproc
structures so we can keep a pointer to the device. Beside some
simplifications, this allows to easily handle the situation
where the audio device desappears. No change in the behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.4 2008/10/26 08:49:44 ratchov Exp $	*/
d34 1
a34 1
	unsigned (*write)(struct file *, unsigned char *, unsigned);	
@


1.4
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.3 2008/08/14 09:58:55 ratchov Exp $	*/
d74 1
@


1.3
log
@move all device related stuff from aucat.c to a new dev.c file.
The new dev_xxx() routines expose a "high level" self-contained
interface to the device. At initialization, the device is opened
and two chains of aproc structures are created:

 * a playback chain that exposes a (initially) empty mix
   aproc to which the rest of the code can attach new
   streams to be played

 * record chain that exposes a (initially) empty sub aproc
   to which the rest of the code can attach new stream to
   to record

The rest of the code, has just to use dev_attach() routine to
attach streams. While we're at it, add a ``devops'' structure
containing pointers to the device-specific routines. This will
allow later to add support for other type of device than the
Sun API.

Also, write the .wav headers in file_del(), so put all header
related data in the file strucuture. This allows to close() the
file, as soon as wpipe_xxx() aproc terminates. This will be
useful for the server, because it will need to close() descripts
of closed connections immediately.

add mix_pushzero() routine to fill the mixer with silence. It
will be used to avoid the mixer to underrun when there are no
input streams. Since we always have at least one input stream
there's no behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.2 2008/06/02 17:05:12 ratchov Exp $	*/
a21 2
#include <poll.h>
#include "aparams.h"
d23 1
d27 14
d43 1
a43 1
	int fd;				/* file descriptor */
a44 3
	off_t rbytes;			/* bytes to read, -1 if no limit */
	off_t wbytes;			/* bytes to write, -1 if no limit */
	int events;			/* events for poll(2) */
d48 4
a51 2
#define FILE_HUP	0x8		/* eof on the write end */
	int state;			/* one of above */
a54 9

	/*
	 * disk-file specific stuff
	 */
#define HDR_AUTO	0	/* guess by looking at the file name */
#define HDR_RAW		1	/* no headers, ie openbsd native ;-) */
#define HDR_WAV		2	/* microsoft riff wave */
	unsigned hdr;		/* HDR_RAW or HDR_WAV */
	struct aparams hpar;	/* parameters to write on the header */
d61 5
a65 3
void file_start(void);
void file_stop(void);
struct file *file_new(int, char *);
d67 1
a73 13

/*
 * max data of a .wav file. The total file size must be smaller than
 * 2^31, and we also have to leave some space for the headers (around 40
 * bytes)
 */ 
#define WAV_DATAMAX	(0x7fff0000)

int wav_readhdr(int, struct aparams *, off_t *);
int wav_writehdr(int, struct aparams *);

/* legacy */
int legacy_play(char *, char *);
@


1.2
log
@since underruns/overruns are handled outside devices, remove code that
check for xruns in devices.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.1 2008/05/23 07:15:46 ratchov Exp $	*/
a21 1

d23 1
d43 9
@


1.1
log
@add support for:
 - recording, full-duplex operation
 - format conversions and resampling on the fly
 - mixing on the fly of multiple inputs of different formats
 - up to 16 channels, simplistic "routing" of channel ranges
 - more linear encodings (in raw and wav files)
the old behaviour is fully preserved if none of the new -i and -o
options are used.

code and fixes from jakemsr@@ and eric@@, suggestions by others.
ok "go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a38 2
#define FILE_RFLOW	0x10		/* has flow control on read() */
#define FILE_WFLOW	0x20		/* has flow control on write() */
@

