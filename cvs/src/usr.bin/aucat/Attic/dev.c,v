head	1.86;
access;
symbols
	OPENBSD_5_6:1.84.0.6
	OPENBSD_5_6_BASE:1.84
	OPENBSD_5_5:1.84.0.4
	OPENBSD_5_5_BASE:1.84
	OPENBSD_5_4:1.82.0.4
	OPENBSD_5_4_BASE:1.82
	OPENBSD_5_3:1.82.0.2
	OPENBSD_5_3_BASE:1.82
	OPENBSD_5_2:1.80.0.2
	OPENBSD_5_2_BASE:1.80
	OPENBSD_5_1_BASE:1.76
	OPENBSD_5_1:1.76.0.2
	OPENBSD_5_0:1.66.0.2
	OPENBSD_5_0_BASE:1.66
	OPENBSD_4_9:1.64.0.2
	OPENBSD_4_9_BASE:1.64
	OPENBSD_4_8:1.63.0.2
	OPENBSD_4_8_BASE:1.63
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.26.0.6
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26;
locks; strict;
comment	@ * @;


1.86
date	2015.01.21.08.43.55;	author ratchov;	state dead;
branches;
next	1.85;
commitid	SYQcoS9jhSKqSJDL;

1.85
date	2014.08.10.10.25.35;	author ratchov;	state Exp;
branches;
next	1.84;
commitid	EkL2OpedrCEgUw5x;

1.84
date	2013.11.18.17.37.45;	author ratchov;	state Exp;
branches;
next	1.83;

1.83
date	2013.11.12.06.47.34;	author ratchov;	state Exp;
branches;
next	1.82;

1.82
date	2012.09.25.20.12.34;	author ratchov;	state Exp;
branches;
next	1.81;

1.81
date	2012.08.30.07.48.01;	author ratchov;	state Exp;
branches;
next	1.80;

1.80
date	2012.05.23.19.14.02;	author ratchov;	state Exp;
branches;
next	1.79;

1.79
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.78;

1.78
date	2012.04.04.11.16.24;	author ratchov;	state Exp;
branches;
next	1.77;

1.77
date	2012.03.23.11.59.54;	author ratchov;	state Exp;
branches;
next	1.76;

1.76
date	2012.01.26.09.07.03;	author ratchov;	state Exp;
branches;
next	1.75;

1.75
date	2012.01.14.13.15.57;	author ratchov;	state Exp;
branches;
next	1.74;

1.74
date	2012.01.10.08.06.28;	author ratchov;	state Exp;
branches;
next	1.73;

1.73
date	2011.12.02.10.34.50;	author ratchov;	state Exp;
branches;
next	1.72;

1.72
date	2011.12.02.10.30.12;	author ratchov;	state Exp;
branches;
next	1.71;

1.71
date	2011.11.20.22.54.51;	author ratchov;	state Exp;
branches;
next	1.70;

1.70
date	2011.11.16.21.26.55;	author ratchov;	state Exp;
branches;
next	1.69;

1.69
date	2011.11.16.21.22.17;	author ratchov;	state Exp;
branches;
next	1.68;

1.68
date	2011.11.15.08.05.22;	author ratchov;	state Exp;
branches;
next	1.67;

1.67
date	2011.10.12.07.20.04;	author ratchov;	state Exp;
branches;
next	1.66;

1.66
date	2011.06.20.20.18.44;	author ratchov;	state Exp;
branches;
next	1.65;

1.65
date	2011.05.26.07.18.40;	author ratchov;	state Exp;
branches;
next	1.64;

1.64
date	2010.10.21.18.57.42;	author ratchov;	state Exp;
branches;
next	1.63;

1.63
date	2010.07.31.08.46.56;	author ratchov;	state Exp;
branches;
next	1.62;

1.62
date	2010.07.06.01.12.45;	author ratchov;	state Exp;
branches;
next	1.61;

1.61
date	2010.06.29.06.57.00;	author jakemsr;	state Exp;
branches;
next	1.60;

1.60
date	2010.06.25.07.32.05;	author ratchov;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.05.16.14.44;	author ratchov;	state Exp;
branches;
next	1.58;

1.58
date	2010.06.05.16.00.52;	author ratchov;	state Exp;
branches;
next	1.57;

1.57
date	2010.06.04.06.15.28;	author ratchov;	state Exp;
branches;
next	1.56;

1.56
date	2010.05.08.15.35.45;	author ratchov;	state Exp;
branches;
next	1.55;

1.55
date	2010.05.08.13.08.24;	author ratchov;	state Exp;
branches;
next	1.54;

1.54
date	2010.05.08.12.29.08;	author ratchov;	state Exp;
branches;
next	1.53;

1.53
date	2010.05.07.07.13.21;	author ratchov;	state Exp;
branches;
next	1.52;

1.52
date	2010.05.04.19.35.20;	author ratchov;	state Exp;
branches;
next	1.51;

1.51
date	2010.05.02.11.54.26;	author ratchov;	state Exp;
branches;
next	1.50;

1.50
date	2010.05.02.11.12.31;	author ratchov;	state Exp;
branches;
next	1.49;

1.49
date	2010.04.24.06.18.23;	author ratchov;	state Exp;
branches;
next	1.48;

1.48
date	2010.04.21.06.13.07;	author ratchov;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.17.09.16.57;	author ratchov;	state Exp;
branches;
next	1.46;

1.46
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.45;

1.45
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.16.23.18.31;	author ratchov;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.13.10.02.52;	author ratchov;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.12.21.39.39;	author ratchov;	state Exp;
branches;
next	1.40;

1.40
date	2010.01.11.13.06.32;	author ratchov;	state Exp;
branches;
next	1.39;

1.39
date	2010.01.10.21.47.41;	author ratchov;	state Exp;
branches;
next	1.38;

1.38
date	2010.01.05.10.18.12;	author ratchov;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.08.00.08.41;	author ratchov;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.03.21.31.37;	author ratchov;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.27.22.24.27;	author ratchov;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.10.12.43.09;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.10.11.58.41;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.10.09.54.06;	author ratchov;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.09.16.49.48;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2009.09.27.11.51.20;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2009.08.21.16.48.03;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2009.08.19.05.54.15;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.25.10.52.18;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2009.02.06.08.26.34;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2009.01.23.17.38.15;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.10.20.02.28;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.06.19.27.22;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.29.17.59.08;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.16.22.11.12;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.07.17.10.41;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.16.17.08.32;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.16.16.30.22;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.12.19.36.39;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.11.19.21.20;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.11.12.56.02;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.10.23.25.37;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.09.16.26.07;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.08.10.01.43;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.07.21.01.15;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.07.00.21.02;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.04.22.18.12;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.04.18.24.06;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.04.17.51.46;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.04.15.22.40;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.04.14.16.09;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.03.22.25.13;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.26.08.49.43;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.14.15.25.16;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.08.14.09.58.55;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.86
log
@Simplify internals and rewrite file header parsing code:
- remove -M, -t, -w, -C, -x flags that don't make sense anymore
- make "-j off" the default (sndiod already does the job)
- don't limit the number of played/recorded files.
- add support for floating-point encoded files.
- add support for apple .aiff and sun/next .au files
@
text
@/*	$OpenBSD: dev.c,v 1.85 2014/08/10 10:25:35 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Device abstraction module
 *
 * This module exposes a ``enhanced device'' that uses aproc
 * structures framework; it does conversions on the fly and can
 * handle multiple streams.  The enhanced device starts and stops
 * automatically, when streams are attached, and provides
 * primitives for MIDI control
 *
 * From the main loop, the device is used as follows:
 *
 *   1. create the device using dev_new_xxx()
 *   2. call dev_run() in the event loop
 *   3. destroy the device using dev_del()
 *   4. continue running the event loop to drain
 *
 * The device is used as follows from aproc context:
 *
 *   1. open the device with dev_ref()
 *   2. negociate parameters (mode, rate, ...)
 *   3. create your stream (ie allocate and fill abufs)
 *   4. attach your stream atomically:
 * 	  - first call dev_wakeup() to ensure device is not suspended
 *	  - possibly fetch dynamic parameters (eg. dev_getpos())
 *	  - attach your buffers with dev_attach()
 *   5. close your stream, ie abuf_eof() or abuf_hup()
 *   6. close the device with dev_unref()
 *
 * The device has the following states:
 *
 * CLOSED	sio_open() is not called, it's not ready and
 *		no streams can be attached; dev_ref() must
 *		be called to open the device
 *
 * INIT		device is opened, processing chain is ready, but
 *		DMA is not started yet. Streams can attach,
 *		in which case device will automatically switch
 *		to the START state
 *
 * START	at least one stream is attached, play buffers
 *		are primed (if necessary) DMA is ready and
 *		will start immeadiately (next cycle)
 *
 * RUN		DMA is started. New streams can attach. If the
 *		device is idle (all streams are closed and
 *		finished draining), then the device
 *		automatically switches to INIT or CLOSED
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "abuf.h"
#include "aproc.h"
#include "conf.h"
#include "dev.h"
#include "pipe.h"
#include "miofile.h"
#include "siofile.h"
#include "midi.h"
#ifdef DEBUG
#include "dbg.h"
#endif

int  dev_open(struct dev *);
void dev_close(struct dev *);
void dev_start(struct dev *);
void dev_stop(struct dev *);
void dev_clear(struct dev *);
void dev_onmove(void *, int);
int  devctl_open(struct dev *, struct devctl *);
int  dev_getep(struct dev *, unsigned int, struct abuf **, struct abuf **);
void dev_sync(struct dev *, unsigned int, struct abuf *, struct abuf *);
int  dev_mkslot(struct dev *, char *);
int  dev_try(struct dev *, int);


struct dev *dev_list = NULL;
unsigned int dev_sndnum = 0, dev_thrnum = 0;

#ifdef DEBUG
void
dev_dbg(struct dev *d)
{
	if (d->num >= DEV_NMAX) {
		dbg_puts("thr");
		dbg_putu(d->num - DEV_NMAX);
	} else {
		dbg_puts("snd");
		dbg_putu(d->num);
	}
}
#endif

/*
 * Create a sndio device
 */
struct dev *
dev_new(char *path, unsigned int mode, unsigned int bufsz, unsigned int round,
    unsigned int hold, unsigned int autovol)
{
	struct dev *d;
	unsigned int *pnum, i;

	pnum = (mode & MODE_THRU) ? &dev_thrnum : &dev_sndnum;
	if (*pnum == DEV_NMAX) {
#ifdef DEBUG
		if (debug_level >= 1)
			dbg_puts("too many devices\n");
#endif
		return NULL;
	}
	d = malloc(sizeof(struct dev));
	if (d == NULL) {
		perror("malloc");
		exit(1);
	}
	d->num = (*pnum)++;
	if (mode & MODE_THRU)
		d->num += DEV_NMAX;
	d->ctl_list = NULL;
	d->path = path;
	d->reqmode = mode;
	aparams_init(&d->reqopar, NCHAN_MAX, 0, 0);
	aparams_init(&d->reqipar, NCHAN_MAX, 0, 0);
	d->reqbufsz = bufsz;
	d->reqround = round;
	d->hold = hold;
	d->autovol = autovol;
	d->autostart = 0;
	d->refcnt = 0;
	d->pstate = DEV_CLOSED;
	d->serial = 0;
	for (i = 0; i < CTL_NSLOT; i++) {
		d->slot[i].unit = i;
		d->slot[i].ops = NULL;
		d->slot[i].vol = MIDI_MAXCTL;
		d->slot[i].tstate = CTL_OFF;
		d->slot[i].serial = d->serial++;
		d->slot[i].name[0] = '\0';
	}
	d->master = MIDI_MAXCTL;
	d->origin = 0;
	d->tstate = CTL_STOP;
	d->next = dev_list;
	dev_list = d;      
	return d;
}

/*
 * adjust device parameters and mode
 */
void
dev_adjpar(struct dev *d, unsigned int mode,
    struct aparams *ipar, struct aparams *opar)
{
	d->reqmode |= (mode | MODE_MIDIMASK);
	if (mode & MODE_REC)
		aparams_grow(&d->reqipar, ipar);
	if (mode & MODE_PLAY)
		aparams_grow(&d->reqopar, opar);
}

/*
 * Initialize the device with the current parameters
 */
int
dev_init(struct dev *d)
{
	if ((d->reqmode & (MODE_AUDIOMASK | MODE_MIDIMASK)) == 0) {
#ifdef DEBUG
		    dev_dbg(d);
		    dbg_puts(": has no streams, skipped\n");
#endif		    		    
		    return 1;
	}
	if (d->hold && d->pstate == DEV_CLOSED && !dev_open(d)) {
		dev_del(d);
		return 0;
	}
	return 1;
}

/*
 * Add a MIDI port to the device
 */
int
devctl_add(struct dev *d, char *path, unsigned int mode)
{
	struct devctl *c;

	c = malloc(sizeof(struct devctl));
	if (c == NULL) {
		perror("malloc");
		exit(1);
	}
	c->path = path;
	c->mode = mode;
	c->next = d->ctl_list;
	d->ctl_list = c;
	if (d->pstate != DEV_CLOSED && !devctl_open(d, c))
		return 0;
	return 1;
}

/*
 * Open a MIDI device and connect it to the thru box
 */
int
devctl_open(struct dev *d, struct devctl *c)
{
	struct file *f;
	struct abuf *rbuf = NULL, *wbuf = NULL;
	struct aproc *rproc, *wproc;

	f = (struct file *)miofile_new(&miofile_ops, c->path, c->mode);
	if (f == NULL)
		return 0;
	if (c->mode & MODE_MIDIIN) {
		rproc = rfile_new(f);
		rbuf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setout(rproc, rbuf);
	}
	if (c->mode & MODE_MIDIOUT) {
		wproc = wfile_new(f);
		wbuf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setin(wproc, wbuf);
	}
	dev_midiattach(d, rbuf, wbuf);
	return 1;
}

/*
 * Open the device with the dev_reqxxx capabilities. Setup a mixer, demuxer,
 * monitor, midi control, and any necessary conversions.
 */
int
dev_open(struct dev *d)
{
	struct file *f;
	struct devctl *c;
	struct aparams par;
	struct aproc *conv;
	struct abuf *buf;
	unsigned int siomode, cmin, cmax, rate;
	
	d->mode = d->reqmode;
	d->round = d->reqround;
	d->bufsz = d->reqbufsz;
	d->ipar = d->reqipar;
	d->opar = d->reqopar;
	d->rec = NULL;
	d->play = NULL;
	d->mon = NULL;
	d->mix = NULL;
	d->sub = NULL;
	d->submon = NULL;
	d->midi = NULL;
	d->rate = 0;

	if (d->opar.cmin > d->opar.cmax) {
		d->opar.cmin = 0;
		d->opar.cmax = 1;
	}
	if (d->ipar.cmin > d->ipar.cmax) {
		d->ipar.cmin = 0;
		d->ipar.cmax = 1;
	}
	if (d->opar.rate > d->ipar.rate)
		d->ipar.rate = d->opar.rate;
	else
		d->opar.rate = d->ipar.rate;
	if (d->opar.rate == 0)
		d->opar.rate = d->ipar.rate = 48000; /* XXX */

	if (d->mode & MODE_THRU)
		d->mode &= ~MODE_AUDIOMASK;

	/*
	 * If needed, open the device (ie create dev_rec and dev_play)
	 */
	if ((d->mode & (MODE_PLAY | MODE_REC)) && !(d->mode & MODE_LOOP)) {
		siomode = d->mode & (MODE_PLAY | MODE_REC);
		f = (struct file *)siofile_new(&siofile_ops,
		    d->path,
		    &siomode,
		    &d->ipar,
		    &d->opar,
		    &d->bufsz,
		    &d->round);
		if (f == NULL) {
#ifdef DEBUG
			if (debug_level >= 1) {
				dev_dbg(d);
				dbg_puts(": ");
				dbg_puts(d->path);
				dbg_puts(": failed to open audio device\n");
			}
#endif
			return 0;
		}
		if (!(siomode & MODE_PLAY))
			d->mode &= ~(MODE_PLAY | MODE_MON);
		if (!(siomode & MODE_REC))
			d->mode &= ~MODE_REC;
		if ((d->mode & (MODE_PLAY | MODE_REC)) == 0) {
#ifdef DEBUG
			if (debug_level >= 1) {
				dev_dbg(d);
				dbg_puts(": mode not supported by device\n");
			}
#endif
			return 0;
		}
		d->rate = d->mode & MODE_REC ? d->ipar.rate : d->opar.rate;
		if (d->mode & MODE_REC) {
			d->rec = rsio_new(f);
			d->rec->refs++;
		}
		if (d->mode & MODE_PLAY) {
			d->play = wsio_new(f);
			d->play->refs++;
		}
	}
	if (d->mode & MODE_LOOP) {
		if (d->mode & MODE_MON) {
#ifdef DEBUG
			if (debug_level >= 1) {
				dbg_puts("monitoring not allowed "
				    "in loopback mode\n");
			}
#endif
			return 0;
		}
		if ((d->mode & MODE_PLAYREC) != MODE_PLAYREC) {
#ifdef DEBUG
			if (debug_level >= 1) {
				dbg_puts("both play and record streams "
				    "required in loopback mode\n");
			}
#endif
			return 0;
		}
		if (d->ctl_list) {
#ifdef DEBUG
			if (debug_level >= 1) {
				dbg_puts("MIDI control not allowed "
				    "in loopback mode\n");
			}
#endif
			return 0;
		}
		cmin = (d->ipar.cmin < d->opar.cmin) ?
		    d->ipar.cmin : d->opar.cmin;
		cmax = (d->ipar.cmax > d->opar.cmax) ?
		    d->ipar.cmax : d->opar.cmax;
		rate = (d->ipar.rate > d->opar.rate) ?
		    d->ipar.rate : d->opar.rate;
		aparams_init(&par, cmin, cmax, rate);
		d->ipar = par;
		d->opar = par;
		d->rate = rate;
		/* 
		 * block sizes in the resampling code are limited to
		 * 2^15, so use 1/15 of the rate, since all standard
		 * sample rates are multiple of 15
		 */
		d->round = rate / 15;
		d->bufsz = 2 * d->round;
	}
#ifdef DEBUG
	if (debug_level >= 2) {
		if (d->mode & MODE_REC) {
			dev_dbg(d);
			dbg_puts(": recording ");
			aparams_dbg(&d->ipar);
			dbg_puts("\n");
		}
		if (d->mode & MODE_PLAY) {
			dev_dbg(d);
			dbg_puts(": playing ");
			aparams_dbg(&d->opar);
			dbg_puts("\n");
		}
	}
#endif
	/*
	 * Create the midi control end, or a simple thru box
	 * if there's no device
	 */
	if (d->mode & MODE_MIDIMASK) {
		d->midi = midi_new("midi", (d->mode & MODE_THRU) ? NULL : d);
		d->midi->refs++;
	}

	/*
	 * Create mixer, demuxer and monitor
	 */
	if (d->mode & MODE_PLAY) {
		d->mix = mix_new("play", d->bufsz, d->round,
		    d->autovol, MIDI_TO_ADATA(d->master));
		d->mix->refs++;
	}
	if (d->mode & MODE_REC) {
		d->sub = sub_new("rec", d->bufsz, d->round);
		d->sub->refs++;
	}
	if (d->mode & MODE_LOOP) {
		/*
		 * connect mixer out to demuxer in
		 */
		buf = abuf_new(d->bufsz, &d->opar);
		aproc_setout(d->mix, buf);
		aproc_setin(d->sub, buf);

		d->mix->flags |= APROC_QUIT;
		d->sub->flags |= APROC_QUIT;
	}
	if (d->rec) {
		aparams_init(&par, d->ipar.cmin, d->ipar.cmax, d->rate);

		/*
		 * Create device <-> demuxer buffer
		 */
		buf = abuf_new(d->bufsz, &d->ipar);
		aproc_setout(d->rec, buf);

		/*
		 * Insert a converter, if needed.
		 */
		if (!aparams_eqenc(&d->ipar, &par)) {
			conv = dec_new("rec", &d->ipar);
			aproc_setin(conv, buf);
			buf = abuf_new(d->round, &par);
			aproc_setout(conv, buf);
		}
		d->ipar = par;
		aproc_setin(d->sub, buf);
	}
	if (d->play) {
		aparams_init(&par, d->opar.cmin, d->opar.cmax, d->rate);

		/*
		 * Create device <-> mixer buffer
		 */
		buf = abuf_new(d->bufsz, &d->opar);
		aproc_setin(d->play, buf);

		/*
		 * Append a converter, if needed.
		 */
		if (!aparams_eqenc(&par, &d->opar)) {
			conv = enc_new("play", &d->opar);
			aproc_setout(conv, buf);
			buf = abuf_new(d->round, &par);
			aproc_setin(conv, buf);
		}
		d->opar = par;
		aproc_setout(d->mix, buf);
	}
	if (d->mode & MODE_MON) {
		d->mon = mon_new("mon", d->bufsz);
		d->mon->refs++;
		buf = abuf_new(d->bufsz, &d->opar);
		aproc_setout(d->mon, buf);

		/*
		 * Append a "sub" to which clients will connect.
		 */
		d->submon = sub_new("mon", d->bufsz, d->round);
		d->submon->refs++;
		aproc_setin(d->submon, buf);

		/*
		 * Attach to the mixer
		 */
		d->mix->u.mix.mon = d->mon;
		d->mon->refs++;
	}
#ifdef DEBUG
	if (debug_level >= 2) { 
		if (d->mode & (MODE_PLAY | MODE_RECMASK)) {
			dev_dbg(d);
			dbg_puts(": block size is ");
			dbg_putu(d->round);
			dbg_puts(" frames, using ");
			dbg_putu(d->bufsz / d->round);
			dbg_puts(" blocks\n");
		}
	}
#endif
	d->pstate = DEV_INIT;
	for (c = d->ctl_list; c != NULL; c = c->next) {
		if (!devctl_open(d, c)) {
#ifdef DEBUG
			if (debug_level >= 1) {
				dbg_puts(c->path);
				dbg_puts(": couldn't open MIDI port\n");
			}
#endif
			dev_close(d);
			return 0;
		}
	}
	return 1;
}

/*
 * Cleanly stop and drain everything and close the device
 * once both play chain and record chain are gone.
 */
void
dev_close(struct dev *d)
{
	struct file *f;

	/*
	 * if the device is starting, ensure it actually starts
	 * so buffers are drained, else clear any buffers
	 */
	switch (d->pstate) {
	case DEV_START:
#ifdef DEBUG
		if (debug_level >= 3) {
			dev_dbg(d);
			dbg_puts(": draining device\n");
		}
#endif
		dev_start(d);
		break;
	case DEV_INIT:
#ifdef DEBUG
		if (debug_level >= 3) {
			dev_dbg(d);
			dbg_puts(": flushing device\n");
		}
#endif
		dev_clear(d);
		break;
	}
#ifdef DEBUG
	if (debug_level >= 2) {
		dev_dbg(d);
		dbg_puts(": closing device\n");
	}
#endif
	d->pstate = DEV_CLOSED;
	if (d->mix) {
		/*
		 * Put the mixer in ``autoquit'' state and generate
		 * EOF on all inputs connected it. Once buffers are
		 * drained the mixer will terminate and shutdown the
		 * device.
		 *
		 * NOTE: since file_eof() can destroy the file and
		 * reorder the file_list, we have to restart the loop
		 * after each call to file_eof().
		 */
		if (APROC_OK(d->mix))
			mix_quit(d->mix);

		/*
		 * XXX: handle this in mix_done()
		 */
		if (APROC_OK(d->mix->u.mix.mon)) {
			d->mix->u.mix.mon->refs--;
			aproc_del(d->mix->u.mix.mon);
			d->mix->u.mix.mon = NULL;
		}
	restart_mix:
		LIST_FOREACH(f, &file_list, entry) {
			if (f->rproc != NULL &&
			    aproc_depend(d->mix, f->rproc)) {
				file_eof(f);
				goto restart_mix;
			}
		}
	} else if (d->sub) {
		/*
		 * Same as above, but since there's no mixer, 
		 * we generate EOF on the record-end of the
		 * device.
		 */	
	restart_sub:
		LIST_FOREACH(f, &file_list, entry) {
			if (f->rproc != NULL &&
			    aproc_depend(d->sub, f->rproc)) {
				file_eof(f);
				goto restart_sub;
			}
		}
	} else if (d->submon) {
		/*
		 * Same as above
		 */	
	restart_submon:
		LIST_FOREACH(f, &file_list, entry) {
			if (f->rproc != NULL &&
			    aproc_depend(d->submon, f->rproc)) {
				file_eof(f);
				goto restart_submon;
			}
		}
	}
	if (d->midi) {
		d->midi->flags |= APROC_QUIT;
		if (LIST_EMPTY(&d->midi->ins))
			aproc_del(d->midi);
 	restart_midi:
		LIST_FOREACH(f, &file_list, entry) {
			if (f->rproc &&
			    aproc_depend(d->midi, f->rproc)) {
				file_eof(f);
				goto restart_midi;
			}
		}
	}
	if (d->mix) {
		if (--d->mix->refs == 0 && (d->mix->flags & APROC_ZOMB))
			aproc_del(d->mix);
		d->mix = NULL;
	}
	if (d->play) {
		if (--d->play->refs == 0 && (d->play->flags & APROC_ZOMB))
			aproc_del(d->play);
		d->play = NULL;
	}
	if (d->sub) {
		if (--d->sub->refs == 0 && (d->sub->flags & APROC_ZOMB))
			aproc_del(d->sub);
		d->sub = NULL;
	}
	if (d->rec) {
		if (--d->rec->refs == 0 && (d->rec->flags & APROC_ZOMB))
			aproc_del(d->rec);
		d->rec = NULL;
	}
	if (d->submon) {
		if (--d->submon->refs == 0 && (d->submon->flags & APROC_ZOMB))
			aproc_del(d->submon);
		d->submon = NULL;
	}
	if (d->mon) {
		if (--d->mon->refs == 0 && (d->mon->flags & APROC_ZOMB))
			aproc_del(d->mon);
		d->mon = NULL;
	}
	if (d->midi) {
		if (--d->midi->refs == 0 && (d->midi->flags & APROC_ZOMB))
			aproc_del(d->midi);
		d->midi = NULL;
	}
}

/*
 * Unless the device is already in process of closing, request it to close
 */
void
dev_drain(struct dev *d)
{
	unsigned int i;
	struct ctl_slot *s;

	for (i = 0, s = d->slot; i < CTL_NSLOT; i++, s++) {
		if (s->ops)
			s->ops->quit(s->arg);
	}
	if (d->pstate != DEV_CLOSED)
		dev_close(d);
}

/*
 * Free the device
 */
void
dev_del(struct dev *d)
{
	struct dev **p;

	dev_drain(d);
	for (p = &dev_list; *p != d; p = &(*p)->next) {
#ifdef DEBUG
		if (*p == NULL) {
			dbg_puts("device to delete not on the list\n");
			dbg_panic();
		}
#endif
	}
	*p = d->next;
	free(d);
}

/*
 * Attach a bi-directional MIDI stream to the MIDI device
 */
void
dev_midiattach(struct dev *d, struct abuf *ibuf, struct abuf *obuf)
{
	if (ibuf)
		aproc_setin(d->midi, ibuf);
	if (obuf) {
		aproc_setout(d->midi, obuf);
		if (ibuf) {
			ibuf->duplex = obuf;
			obuf->duplex = ibuf;
		}
	}
}

unsigned int
dev_roundof(struct dev *d, unsigned int newrate)
{
	return (d->round * newrate + d->rate / 2) / d->rate;
}

/*
 * Start the (paused) device. By default it's paused.
 */
void
dev_start(struct dev *d)
{
	struct file *f;

#ifdef DEBUG
	if (debug_level >= 2)
		dbg_puts("starting device\n");
#endif
	d->pstate = DEV_RUN;
	if (d->mode & MODE_LOOP)
		return;
	if (APROC_OK(d->mix))
		d->mix->flags |= APROC_DROP;
	if (APROC_OK(d->sub))
		d->sub->flags |= APROC_DROP;
	if (APROC_OK(d->submon))
		d->submon->flags |= APROC_DROP;
	if (APROC_OK(d->play) && d->play->u.io.file) {
		f = d->play->u.io.file;
		f->ops->start(f, dev_onmove, d);
	} else if (APROC_OK(d->rec) && d->rec->u.io.file) {
		f = d->rec->u.io.file;
		f->ops->start(f, dev_onmove, d);
	}
}

/*
 * Pause the device. This may trigger context switches,
 * so it shouldn't be called from aproc methods
 */
void
dev_stop(struct dev *d)
{
	struct file *f;

#ifdef DEBUG
	if (debug_level >= 2) {
		dev_dbg(d);
		dbg_puts(": device stopped\n");
	}
#endif
	d->pstate = DEV_INIT;
	if (d->mode & MODE_LOOP)
		return;
	if (APROC_OK(d->play) && d->play->u.io.file) {
		f = d->play->u.io.file;
		f->ops->stop(f);
	} else if (APROC_OK(d->rec) && d->rec->u.io.file) {
		f = d->rec->u.io.file;
		f->ops->stop(f);
	}
	if (APROC_OK(d->mix))
		d->mix->flags &= ~APROC_DROP;
	if (APROC_OK(d->sub))
		d->sub->flags &= ~APROC_DROP;
	if (APROC_OK(d->submon))
		d->submon->flags &= ~APROC_DROP;
}

int
dev_ref(struct dev *d)
{
#ifdef DEBUG
	if (debug_level >= 3) {
		dev_dbg(d);
		dbg_puts(": device requested\n");
	}
#endif
	if (d->pstate == DEV_CLOSED && !dev_open(d)) {
		if (d->hold)
			dev_del(d);
		return 0;
	}
	d->refcnt++;
	return 1;
}

void
dev_unref(struct dev *d)
{
#ifdef DEBUG
	if (debug_level >= 3) {
		dev_dbg(d);
		dbg_puts(": device released\n");
	}
#endif
	d->refcnt--;
	if (d->refcnt == 0 && d->pstate == DEV_INIT && !d->hold)
		dev_close(d);
}

/*
 * There are actions (like start/stop/close ... ) that may trigger aproc
 * operations, a thus cannot be started from aproc context.
 * To avoid problems, aprocs only change the s!tate of the device,
 * and actual operations are triggered from the main loop,
 * outside the aproc code path.
 *
 * The following routine invokes pending actions, returns 0
 * on fatal error
 */
int
dev_run(struct dev *d)
{
	if (d->pstate == DEV_CLOSED)
		return 1;
	/*
	 * check if device isn't gone
	 */
	if (((d->mode & MODE_PLAY) && !APROC_OK(d->mix)) ||
	    ((d->mode & MODE_REC)  && !APROC_OK(d->sub)) ||
	    ((d->mode & MODE_MON)  && !APROC_OK(d->submon))) {
#ifdef DEBUG
		if (debug_level >= 2) {
			dev_dbg(d);
			dbg_puts(": device disappeared\n");
		}
#endif
		if (d->hold) {
			dev_del(d);
			return 0;
		}
		dev_close(d);
		return 1;
	}
	switch (d->pstate) {
	case DEV_INIT:
		/* nothing */
		break;
	case DEV_START:
		dev_start(d);
		/* PASSTHROUGH */
	case DEV_RUN:
		/*
		 * if the device is not used, then stop it
		 */
		if ((!APROC_OK(d->mix) ||
			d->mix->u.mix.idle > 2 * d->bufsz) &&
		    (!APROC_OK(d->sub) ||
			d->sub->u.sub.idle > 2 * d->bufsz) &&
		    (!APROC_OK(d->submon) ||
			d->submon->u.sub.idle > 2 * d->bufsz) &&
		    (!APROC_OK(d->midi) ||
			d->tstate != CTL_RUN)) {
#ifdef DEBUG
			if (debug_level >= 3) {
				dev_dbg(d);
				dbg_puts(": device idle, suspending\n");
			}
#endif
			dev_stop(d);
			if (d->refcnt == 0 && !d->hold)
				dev_close(d);
			else
				dev_clear(d);
		}
		break;
	}
	return 1;
}

/*
 * If the device is paused, then resume it.
 * This routine can be called from aproc context.
 */
void
dev_wakeup(struct dev *d)
{
	if (d->pstate == DEV_INIT)
		d->pstate = DEV_START;
}

/*
 * Find the end points connected to the mix/sub.
 */
int
dev_getep(struct dev *d,
    unsigned int mode, struct abuf **sibuf, struct abuf **sobuf)
{
	struct abuf *ibuf, *obuf;

	if (mode & MODE_PLAY) {
		if (!APROC_OK(d->mix))
			return 0;
		ibuf = *sibuf;
		for (;;) {
			if (!ibuf || !ibuf->rproc) {
#ifdef DEBUG
				if (debug_level >= 3) {
					abuf_dbg(*sibuf);
					dbg_puts(": not connected to device\n");
				}
#endif
				return 0;
			}
			if (ibuf->rproc == d->mix)
				break;
			ibuf = LIST_FIRST(&ibuf->rproc->outs);
		}
		*sibuf = ibuf;
	}
	if (mode & MODE_REC) {
		if (!APROC_OK(d->sub))
			return 0;
		obuf = *sobuf;
		for (;;) {
			if (!obuf || !obuf->wproc) {
#ifdef DEBUG
				if (debug_level >= 3) {
					abuf_dbg(*sobuf);
					dbg_puts(": not connected to device\n");
				}
#endif
				return 0;
			}
			if (obuf->wproc == d->sub)
				break;
			obuf = LIST_FIRST(&obuf->wproc->ins);
		}
		*sobuf = obuf;
	}
	if (mode & MODE_MON) {
		if (!APROC_OK(d->submon))
			return 0;
		obuf = *sobuf;
		for (;;) {
			if (!obuf || !obuf->wproc) {
#ifdef DEBUG
				if (debug_level >= 3) {
					abuf_dbg(*sobuf);
					dbg_puts(": not connected to device\n");
				}
#endif
				return 0;
			}
			if (obuf->wproc == d->submon)
				break;
			obuf = LIST_FIRST(&obuf->wproc->ins);
		}
		*sobuf = obuf;
	}
	return 1;
}

/*
 * Sync play buffer to rec buffer (for instance when one of
 * them underruns/overruns).
 */
void
dev_sync(struct dev *d, unsigned int mode,
    struct abuf *ibuf, struct abuf *obuf)
{
	int delta, offs;
	struct abuf *mbuf = NULL;

	if (!dev_getep(d, mode, &ibuf, &obuf))
		return;
	/*
	 * Calculate delta, the number of frames the play chain is ahead
	 * of the record chain. It's necessary to schedule silences (or
	 * drops) in order to start playback and record in sync.
	 */
	offs = 0;
	delta = 0;
	if (APROC_OK(d->mix)) {
		mbuf = LIST_FIRST(&d->mix->outs);
		offs += mbuf->w.mix.todo;
		delta += d->mix->u.mix.lat;
	}
	if (APROC_OK(d->sub))
		delta += d->sub->u.sub.lat;
#ifdef DEBUG
	if (debug_level >= 3) {
		dev_dbg(d);
		dbg_puts(": syncing device");
		if (APROC_OK(d->mix)) {
			dbg_puts(", ");
			aproc_dbg(d->mix);
			dbg_puts(": todo = ");
			dbg_putu(mbuf->w.mix.todo);
			dbg_puts(": lat = ");
			dbg_putu(d->mix->u.mix.lat);
		}
		if (APROC_OK(d->sub)) {
			dbg_puts(", ");
			aproc_dbg(d->sub);
			dbg_puts(": lat = ");
			dbg_putu(d->sub->u.sub.lat);
		}
		dbg_puts("\n");
	}
#endif
	if (mode & MODE_PLAY)
	 	mix_drop(ibuf, -offs);
	if (mode & MODE_RECMASK)
		sub_silence(obuf, -(offs + delta));
}

/*
 * return the current latency (in frames), ie the latency that
 * a stream would have if dev_attach() is called on it.
 *
 * XXX: return a "unsigned int", since result is always positive, isn't it?
 */
int
dev_getpos(struct dev *d)
{
	struct abuf *mbuf = NULL;

	if (APROC_OK(d->mix)) {
		mbuf = LIST_FIRST(&d->mix->outs);
		return -(mbuf->w.mix.todo + d->mix->u.mix.lat);
	} else
		return 0;
}

/*
 * Attach the given input and output buffers to the mixer and the
 * multiplexer respectively. The operation is done synchronously, so
 * both buffers enter in sync. If buffers do not match play
 * and rec.
 */
void
dev_attach(struct dev *d, char *name, unsigned int mode,
    struct abuf *ibuf, struct aparams *sipar, unsigned int inch,
    struct abuf *obuf, struct aparams *sopar, unsigned int onch,
    unsigned int xrun, int vol)
{
	struct aparams ipar, opar;
	struct aproc *conv;
	unsigned int round, nblk, nch;

#ifdef DEBUG
	if ((!APROC_OK(d->mix)    && (mode & MODE_PLAY)) ||
	    (!APROC_OK(d->sub)    && (mode & MODE_REC)) ||
	    (!APROC_OK(d->submon) && (mode & MODE_MON))) {
		dev_dbg(d);
	    	dbg_puts(": mode beyond device mode, not attaching\n");
		return;
	}
#endif
	if (mode & MODE_PLAY) {
		ipar = *sipar;
		nblk = (d->bufsz / d->round + 3) / 4;
		round = dev_roundof(d, ipar.rate);
		nch = ipar.cmax - ipar.cmin + 1;
		if (!aparams_eqenc(&ipar, &d->opar)) {
			conv = dec_new(name, &ipar);
			ipar.bps = d->opar.bps;
			ipar.bits = d->opar.bits;
			ipar.sig = d->opar.sig;
			ipar.le = d->opar.le;
			ipar.msb = d->opar.msb;
			aproc_setin(conv, ibuf);
			ibuf = abuf_new(nblk * round, &ipar);
			aproc_setout(conv, ibuf);
		}
		if (inch > 0 && nch >= inch * 2) {
			conv = join_new(name);
			aproc_setin(conv, ibuf);
			ipar.cmax = ipar.cmin + inch - 1;
			ibuf = abuf_new(nblk * round, &ipar);
			aproc_setout(conv, ibuf);
		}
		if (!aparams_eqrate(&ipar, &d->opar)) {
			conv = resamp_new(name, round, d->round);
			ipar.rate = d->opar.rate;
			round = d->round;
			aproc_setin(conv, ibuf);
			ibuf = abuf_new(nblk * round, &ipar);
			aproc_setout(conv, ibuf);
		}
		if (inch > 0 && nch * 2 <= inch) {
			conv = join_new(name);
			aproc_setin(conv, ibuf);
			ipar.cmax = ipar.cmin + inch - 1;
			ibuf = abuf_new(nblk * round, &ipar);
			aproc_setout(conv, ibuf);
		}
		aproc_setin(d->mix, ibuf);
		ibuf->r.mix.xrun = xrun;
		ibuf->r.mix.maxweight = vol;
		mix_setmaster(d->mix);
	}
	if (mode & MODE_REC) {
		opar = *sopar;
		round = dev_roundof(d, opar.rate);
		nblk = (d->bufsz / d->round + 3) / 4;
		nch = opar.cmax - opar.cmin + 1;
		if (!aparams_eqenc(&opar, &d->ipar)) {
			conv = enc_new(name, &opar);
			opar.bps = d->ipar.bps;
			opar.bits = d->ipar.bits;
			opar.sig = d->ipar.sig;
			opar.le = d->ipar.le;
			opar.msb = d->ipar.msb;
			aproc_setout(conv, obuf);
			obuf = abuf_new(nblk * round, &opar);
			aproc_setin(conv, obuf);
		}
		if (onch > 0 && nch >= onch * 2) {
			conv = join_new(name);
			aproc_setout(conv, obuf);
			opar.cmax = opar.cmin + onch - 1;
			obuf = abuf_new(nblk * round, &opar);
			aproc_setin(conv, obuf);
		}
		if (!aparams_eqrate(&opar, &d->ipar)) {
			conv = resamp_new(name, d->round, round);
			opar.rate = d->ipar.rate;
			round = d->round;
			aproc_setout(conv, obuf);
			obuf = abuf_new(nblk * round, &opar);
			aproc_setin(conv, obuf);
		}
		if (onch > 0 && nch * 2 <= onch) {
			conv = join_new(name);
			aproc_setout(conv, obuf);
			opar.cmax = opar.cmin + onch - 1;
			obuf = abuf_new(nblk * round, &opar);
			aproc_setin(conv, obuf);
		}
		aproc_setout(d->sub, obuf);
		obuf->w.sub.xrun = xrun;
	}
	if (mode & MODE_MON) {
		opar = *sopar;
		round = dev_roundof(d, opar.rate);
		nblk = (d->bufsz / d->round + 3) / 4;
		nch = opar.cmax - opar.cmin + 1;
		if (!aparams_eqenc(&opar, &d->opar)) {
			conv = enc_new(name, &opar);
			opar.bps = d->opar.bps;
			opar.bits = d->opar.bits;
			opar.sig = d->opar.sig;
			opar.le = d->opar.le;
			opar.msb = d->opar.msb;
			aproc_setout(conv, obuf);
			obuf = abuf_new(nblk * round, &opar);
			aproc_setin(conv, obuf);
		}
		if (onch > 0 && nch >= onch * 2) {
			conv = join_new(name);
			aproc_setout(conv, obuf);
			opar.cmax = opar.cmin + onch - 1;
			obuf = abuf_new(nblk * round, &opar);
			aproc_setin(conv, obuf);
		}
		if (!aparams_eqrate(&opar, &d->opar)) {
			conv = resamp_new(name, d->round, round);
			opar.rate = d->opar.rate;
			round = d->round;
			aproc_setout(conv, obuf);
			obuf = abuf_new(nblk * round, &opar);
			aproc_setin(conv, obuf);
		}
		if (onch > 0 && nch * 2 <= onch) {
			conv = join_new(name);
			aproc_setout(conv, obuf);
			opar.cmax = opar.cmin + onch - 1;
			obuf = abuf_new(nblk * round, &opar);
			aproc_setin(conv, obuf);
		}
		aproc_setout(d->submon, obuf);
		obuf->w.sub.xrun = xrun;
	}

	/*
	 * Sync play to record.
	 */
	if ((mode & MODE_PLAY) && (mode & MODE_RECMASK)) {
		ibuf->duplex = obuf;
		obuf->duplex = ibuf;
	}
	dev_sync(d, mode, ibuf, obuf);
}

/*
 * Change the playback volume of the given stream.
 */
void
dev_setvol(struct dev *d, struct abuf *ibuf, int vol)
{
#ifdef DEBUG
	if (debug_level >= 3) {
		abuf_dbg(ibuf);
		dbg_puts(": setting volume to ");
		dbg_putu(vol);
		dbg_puts("\n");
	}
#endif
	if (!dev_getep(d, MODE_PLAY, &ibuf, NULL)) {
		return;
	}
	ibuf->r.mix.vol = vol;
}

/*
 * Clear buffers of the play and record chains so that when the device
 * is started, playback and record start in sync.
 */
void
dev_clear(struct dev *d)
{
	struct abuf *buf;

	if (APROC_OK(d->mix)) {
#ifdef DEBUG
		if (!LIST_EMPTY(&d->mix->ins)) {
			dev_dbg(d);
			dbg_puts(": play end not idle, can't clear device\n");
			dbg_panic();	
		}
#endif
		buf = LIST_FIRST(&d->mix->outs);
		while (buf) {
			abuf_clear(buf);
			buf = LIST_FIRST(&buf->rproc->outs);
		}
		mix_clear(d->mix);
	}
	if (APROC_OK(d->sub)) {
#ifdef DEBUG
		if (!LIST_EMPTY(&d->sub->outs)) {
			dev_dbg(d);
			dbg_puts(": record end not idle, can't clear device\n");
			dbg_panic();	
		}
#endif
		buf = LIST_FIRST(&d->sub->ins);
		while (buf) {
			abuf_clear(buf);
			buf = LIST_FIRST(&buf->wproc->ins);
		}
		sub_clear(d->sub);
	}
	if (APROC_OK(d->submon)) {
#ifdef DEBUG
		if (!LIST_EMPTY(&d->submon->outs)) {
			dev_dbg(d);
			dbg_puts(": monitoring end not idle, can't clear device\n");
			dbg_panic();
		}
#endif
		buf = LIST_FIRST(&d->submon->ins);
		while (buf) {
			abuf_clear(buf);
			buf = LIST_FIRST(&buf->wproc->ins);
		}
		sub_clear(d->submon);
		mon_clear(d->mon);
	}
}

#ifdef DEBUG
void
dev_slotdbg(struct dev *d, int slot)
{
	struct ctl_slot *s;

	if (slot < 0) {
		dbg_puts("none");
	} else {
		s = d->slot + slot;
		dbg_puts(s->name);
		dbg_putu(s->unit);
		dbg_puts("(");
		dbg_putu(s->vol);
		dbg_puts(")/");
		switch (s->tstate) {
		case CTL_OFF:
			dbg_puts("off");
			break;
		case CTL_RUN:
			dbg_puts("run");
			break;
		case CTL_START:
			dbg_puts("sta");
			break;
		case CTL_STOP:
			dbg_puts("stp");
			break;
		default:
			dbg_puts("unk");
			break;
		}
	}
}
#endif

/*
 * find the best matching free slot index (ie midi channel).
 * return -1, if there are no free slots anymore
 */
int
dev_mkslot(struct dev *d, char *who)
{
	char *s;
	struct ctl_slot *slot;
	char name[CTL_NAMEMAX];
	unsigned int i, unit, umap = 0;
	unsigned int ser, bestser, bestidx;

	/*
	 * create a ``valid'' control name (lowcase, remove [^a-z], trucate)
	 */
	for (i = 0, s = who; ; s++) {
		if (i == CTL_NAMEMAX - 1 || *s == '\0') {
			name[i] = '\0';
			break;
		} else if (*s >= 'A' && *s <= 'Z') {
			name[i++] = *s + 'a' - 'A';
		} else if (*s >= 'a' && *s <= 'z')
			name[i++] = *s;
	}
	if (i == 0)
		strlcpy(name, "noname", CTL_NAMEMAX);

	/*
	 * find the instance number of the control name
	 */
	for (i = 0, slot = d->slot; i < CTL_NSLOT; i++, slot++) {
		if (slot->ops == NULL)
			continue;
		if (strcmp(slot->name, name) == 0)
			umap |= (1 << slot->unit);
	} 
	for (unit = 0; ; unit++) {
		if (unit == CTL_NSLOT) {
#ifdef DEBUG
			if (debug_level >= 1) {
				dbg_puts(name);
				dbg_puts(": too many instances\n");
			}
#endif
			return -1;
		}
		if ((umap & (1 << unit)) == 0)
			break;
	}

	/*
	 * find a free controller slot with the same name/unit
	 */
	for (i = 0, slot = d->slot; i < CTL_NSLOT; i++, slot++) {
		if (slot->ops == NULL &&
		    strcmp(slot->name, name) == 0 &&
		    slot->unit == unit) {
#ifdef DEBUG
			if (debug_level >= 3) {
				dbg_puts(name);
				dbg_putu(unit);
				dbg_puts(": found slot ");
				dbg_putu(i);
				dbg_puts("\n");
			}
#endif
			return i;
		}
	}

	/*
	 * couldn't find a matching slot, pick oldest free slot
	 * and set its name/unit
	 */
	bestser = 0;
	bestidx = CTL_NSLOT;
	for (i = 0, slot = d->slot; i < CTL_NSLOT; i++, slot++) {
		if (slot->ops != NULL)
			continue;
		ser = d->serial - slot->serial;
		if (ser > bestser) {
			bestser = ser;
			bestidx = i;
		}
	}
	if (bestidx == CTL_NSLOT) {
#ifdef DEBUG
		if (debug_level >= 1) {
			dbg_puts(name);
			dbg_putu(unit);
			dbg_puts(": out of mixer slots\n");
		}
#endif
		return -1;
	}
	slot = d->slot + bestidx;
	if (slot->name[0] != '\0')
		slot->vol = MIDI_MAXCTL;
	strlcpy(slot->name, name, CTL_NAMEMAX);
	slot->serial = d->serial++;
	slot->unit = unit;
#ifdef DEBUG
	if (debug_level >= 3) {
		dbg_puts(name);
		dbg_putu(unit);
		dbg_puts(": overwritten slot ");
		dbg_putu(bestidx);
		dbg_puts("\n");
	}
#endif
	return bestidx;
}

/*
 * allocate a new slot and register the given call-backs
 */
int
dev_slotnew(struct dev *d, char *who, struct ctl_ops *ops, void *arg, int mmc)
{
	int slot;
	struct ctl_slot *s;

	slot = dev_mkslot(d, who);
	if (slot < 0)
		return -1;

	s = d->slot + slot;
	s->ops = ops;
	s->arg = arg;
	s->tstate = mmc ? CTL_STOP : CTL_OFF;
	s->ops->vol(s->arg, s->vol);

	if (APROC_OK(d->midi)) {
		midi_send_slot(d->midi, slot);
		midi_send_vol(d->midi, slot, s->vol);
		midi_flush(d->midi);
	} else {
#ifdef DEBUG
		if (debug_level >= 2) {
			dev_slotdbg(d, slot);
			dbg_puts(": MIDI control not available\n");
		}
#endif
	}
	return slot;
}

/*
 * release the given slot
 */
void
dev_slotdel(struct dev *d, int slot)
{
	struct ctl_slot *s;

	s = d->slot + slot;
	s->ops = NULL;
}

/*
 * notifty the mixer that volume changed, called by whom allocad the slot using
 * ctl_slotnew(). Note: it doesn't make sens to call this from within the
 * call-back.
 *
 * XXX: set actual volume here and use only this interface. Now, this
 *	can work because all streams have a slot
 */
void
dev_slotvol(struct dev *d, int slot, unsigned int vol)
{
#ifdef DEBUG
	if (debug_level >= 3) {
		dev_slotdbg(d, slot);
		dbg_puts(": changing volume to ");
		dbg_putu(vol);
		dbg_puts("\n");
	}
#endif
	d->slot[slot].vol = vol;
	if (APROC_OK(d->midi)) {
		midi_send_vol(d->midi, slot, vol);
		midi_flush(d->midi);
	}
}

/*
 * check that all clients controlled by MMC are ready to start,
 * if so, start them all but the caller
 */
int
dev_try(struct dev *d, int slot)
{
	unsigned int i;
	struct ctl_slot *s;

	if (d->tstate != CTL_START) {
#ifdef DEBUG
		if (debug_level >= 3) {
			dev_slotdbg(d, slot);
			dbg_puts(": server not started, delayed\n");
		}
#endif
		return 0;
	}
	for (i = 0, s = d->slot; i < CTL_NSLOT; i++, s++) {
		if (!s->ops || i == slot)
			continue;
		if (s->tstate != CTL_OFF && s->tstate != CTL_START) {
#ifdef DEBUG
			if (debug_level >= 3) {
				dev_slotdbg(d, i);
				dbg_puts(": not ready, server delayed\n");
			}
#endif
			return 0;
		}
	}
	for (i = 0, s = d->slot; i < CTL_NSLOT; i++, s++) {
		if (!s->ops || i == slot)
			continue;
		if (s->tstate == CTL_START) {
#ifdef DEBUG
			if (debug_level >= 3) {
				dev_slotdbg(d, i);
				dbg_puts(": started\n");
			}
#endif
			s->tstate = CTL_RUN;
			s->ops->start(s->arg);
		}
	}
	if (slot >= 0)
		d->slot[slot].tstate = CTL_RUN;
	d->tstate = CTL_RUN;
	if (APROC_OK(d->midi)) {
		midi_send_full(d->midi,
		    d->origin, d->rate, d->round, dev_getpos(d));
		midi_flush(d->midi);
	}
	dev_wakeup(d);
	return 1;
}

/*
 * notify the MMC layer that the stream is attempting
 * to start. If other streams are not ready, 0 is returned meaning 
 * that the stream should wait. If other streams are ready, they
 * are started, and the caller should start immediately.
 */
int
dev_slotstart(struct dev *d, int slot)
{
	struct ctl_slot *s = d->slot + slot;

	if (s->tstate == CTL_OFF || d->tstate == CTL_OFF)
		return 1;

	/*
	 * if the server already started (the client missed the
	 * start rendez-vous) or the server is stopped, then
	 * tag the client as ``wanting to start''
	 */
	s->tstate = CTL_START;
	return dev_try(d, slot);
}

/*
 * notify the MMC layer that the stream no longer is trying to
 * start (or that it just stopped), meaning that its ``start'' call-back
 * shouldn't be called anymore
 */
void
dev_slotstop(struct dev *d, int slot)
{
	struct ctl_slot *s = d->slot + slot;

	/*
	 * tag the stream as not trying to start,
	 * unless MMC is turned off
	 */
	if (s->tstate != CTL_OFF)
		s->tstate = CTL_STOP;
}

/*
 * start all slots simultaneously
 */
void
dev_mmcstart(struct dev *d)
{
	if (d->tstate == CTL_STOP) {
		d->tstate = CTL_START;
		(void)dev_try(d, -1);
#ifdef DEBUG
	} else {
		if (debug_level >= 3) {
			dev_dbg(d);
			dbg_puts(": ignoring mmc start\n");
		}
#endif
	}
}

/*
 * stop all slots simultaneously
 */
void
dev_mmcstop(struct dev *d)
{
	unsigned int i;
	struct ctl_slot *s;

	switch (d->tstate) {
	case CTL_START:
		d->tstate = CTL_STOP;
		return;
	case CTL_RUN:
		d->tstate = CTL_STOP;
		break;
	default:
#ifdef DEBUG
		if (debug_level >= 3) {
			dev_dbg(d);
			dbg_puts(": ignored mmc stop\n");
		}
#endif
		return;
	}
	for (i = 0, s = d->slot; i < CTL_NSLOT; i++, s++) {
		if (!s->ops)
			continue;
		if (s->tstate == CTL_RUN) {
#ifdef DEBUG
			if (debug_level >= 3) {
				dev_slotdbg(d, i);
				dbg_puts(": requested to stop\n");
			}
#endif
			s->ops->stop(s->arg);
		}
	}
}

/*
 * relocate all slots simultaneously
 */
void
dev_loc(struct dev *d, unsigned int origin)
{
	unsigned int i;
	struct ctl_slot *s;

#ifdef DEBUG
	if (debug_level >= 2) {
		dbg_puts("server relocated to ");
		dbg_putu(origin);
		dbg_puts("\n");
	}
#endif
	if (d->tstate == CTL_RUN)
		dev_mmcstop(d);
	d->origin = origin;
	for (i = 0, s = d->slot; i < CTL_NSLOT; i++, s++) {
		if (!s->ops)
			continue;
		s->ops->loc(s->arg, d->origin);
	}
	if (d->tstate == CTL_RUN)
		dev_mmcstart(d);
}

/*
 * called at every clock tick by the mixer, delta is positive, unless
 * there's an overrun/underrun
 */
void
dev_onmove(void *arg, int delta)
{
	struct dev *d = (struct dev *)arg;

	/*
	 * don't send ticks before the start signal
	 */
	if (d->tstate != CTL_RUN)
		return;
	if (APROC_OK(d->midi)) {
		midi_send_qfr(d->midi, d->rate, delta);
		midi_flush(d->midi);
	}
}

void
dev_master(struct dev *d, unsigned int master)
{
#ifdef DEBUG
	if (debug_level >= 3) {
		dev_dbg(d);
		dbg_puts(": changing master volume to ");
		dbg_putu(master);
		dbg_puts("\n");
	}
#endif
	d->master = master;
	if (APROC_OK(d->mix)) {
		d->mix->u.mix.master = MIDI_TO_ADATA(master);
		mix_setmaster(d->mix);
	}
}
@


1.85
log
@typo in debug message
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.84 2013/11/18 17:37:45 ratchov Exp $	*/
@


1.84
log
@add missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1527 1
a1527 1
			dbg_puts(": server not started, delayd\n");
@


1.83
log
@remove bogus legacy server-specific bits that cause confusion
@
text
@d89 5
@


1.82
log
@Upon "master volume change" message, send feedback to other clients
only. Fixes the master volume slider stuttering in MIDI programs. Found
by armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.81 2012/08/30 07:48:01 ratchov Exp $	*/
a77 1
#include "opt.h"
@


1.81
log
@Use (rate / 15) as block size in off-line mode to ensure the
block size stays below SHORT_MAX. Found by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.80 2012/05/23 19:14:02 ratchov Exp $	*/
a1729 4
	}
	if (APROC_OK(d->midi)) {
		midi_send_master(d->midi);
		midi_flush(d->midi);
@


1.80
log
@Fix duplicate mixer knob names
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.79 2012/04/11 06:05:43 ratchov Exp $	*/
d376 6
a381 1
		d->round = rate;
@


1.79
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.78 2012/04/04 11:16:24 ratchov Exp $	*/
d1353 1
a1353 1
			umap |= (1 << i);
@


1.78
log
@Fix memory leak in the error handling code path of failed device
creation. From jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.77 2012/03/23 11:59:54 ratchov Exp $	*/
d92 1
a92 1
unsigned dev_sndnum = 0, dev_thrnum = 0;
d112 2
a113 2
dev_new(char *path, unsigned mode,
    unsigned bufsz, unsigned round, unsigned hold, unsigned autovol)
d116 1
a116 1
	unsigned *pnum, i;
d167 1
a167 1
dev_adjpar(struct dev *d, unsigned mode,
d201 1
a201 1
devctl_add(struct dev *d, char *path, unsigned mode)
d258 1
a258 1
	unsigned siomode, cmin, cmax, rate;
d669 1
a669 1
	unsigned i;
d718 2
a719 2
unsigned
dev_roundof(struct dev *d, unsigned newrate)
d905 1
a905 1
    unsigned mode, struct abuf **sibuf, struct abuf **sobuf)
d977 2
a978 1
dev_sync(struct dev *d, unsigned mode, struct abuf *ibuf, struct abuf *obuf)
d1030 1
a1030 1
 * XXX: return a "unsigned", since result is always positive, isn't it?
d1051 4
a1054 4
dev_attach(struct dev *d, char *name, unsigned mode,
    struct abuf *ibuf, struct aparams *sipar, unsigned inch,
    struct abuf *obuf, struct aparams *sopar, unsigned onch,
    unsigned xrun, int vol)
d1058 1
a1058 1
	unsigned round, nblk, nch;
d1328 2
a1329 2
	unsigned i, unit, umap = 0;
	unsigned ser, bestser, bestidx;
d1487 1
a1487 1
dev_slotvol(struct dev *d, int slot, unsigned vol)
d1511 1
a1511 1
	unsigned i;
d1628 1
a1628 1
	unsigned i;
d1666 1
a1666 1
dev_loc(struct dev *d, unsigned origin)
d1668 1
a1668 1
	unsigned i;
d1711 1
a1711 1
dev_master(struct dev *d, unsigned master)
@


1.77
log
@add a MIDI-controlled master volume knob to adjust the mix of
all playback stream, discussed with armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.76 2012/01/26 09:07:03 ratchov Exp $	*/
a117 5
	d = malloc(sizeof(struct dev));
	if (d == NULL) {
		perror("malloc");
		exit(1);
	}
d125 5
@


1.76
log
@Make the default rate 48kHz and the default block size 10ms. These
settings ensure video players and programs using MTC are smooth by
default. Thanks to all who tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.75 2012/01/14 13:15:57 ratchov Exp $	*/
d155 1
d408 2
a409 1
		d->mix = mix_new("play", d->bufsz, d->round, d->autovol);
d1705 22
@


1.75
log
@remove unused variables, from Michael W. Bombardieri, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.74 2012/01/10 08:06:28 ratchov Exp $	*/
d286 1
a286 1
		d->opar.rate = d->ipar.rate = 44100; /* XXX */
@


1.74
log
@hide "device disappeared" messages unless -d is used
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.73 2011/12/02 10:34:50 ratchov Exp $	*/
a1052 1
	struct abuf *pbuf = NULL, *rbuf = NULL;
a1067 1
		pbuf = LIST_FIRST(&d->mix->outs);
a1110 1
		rbuf = LIST_FIRST(&d->sub->ins);
a1151 1
		rbuf = LIST_FIRST(&d->submon->ins);
@


1.73
log
@reuse midi-control code to implement midi thru boxes and remove
the old midithru implementation; less code, less bugs. As a side
effect, midi output doesn't implement running status "compression"
any more.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.72 2011/12/02 10:30:12 ratchov Exp $	*/
d839 1
a839 1
		if (debug_level >= 1) {
@


1.72
log
@initialize device reference counter, unbreaks -aoff
with MALLOC_OPTIONS=J
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.71 2011/11/20 22:54:51 ratchov Exp $	*/
d399 1
a399 2
		d->midi = (d->mode & MODE_THRU) ?
		    thru_new("thru") : ctl_new("ctl", d);
d1453 3
a1455 2
		ctl_slot(d->midi, slot);
		ctl_vol(d->midi, slot, s->vol);
d1499 3
a1501 30
	if (APROC_OK(d->midi))
		ctl_vol(d->midi, slot, vol);
}


/*
 * check if there are controlled streams
 */
int
dev_idle(struct dev *d)
{
	unsigned i;
	struct ctl_slot *s;

	/*
	 * XXX: this conditions breaks -aoff for thru boxes
	 */
	if (d->mode & MODE_THRU)
		return 0;

	if (d->pstate != DEV_CLOSED)
		return 0;

	/*
	 * XXX: if the device is closed, we're sure there are no
	 *	slots in use, so the following test is useless
	 */
	for (i = 0, s = d->slot; i < CTL_NSLOT; i++, s++) {
		if (s->ops)
			return 0;
a1502 1
	return 1;
d1554 5
a1558 2
	if (APROC_OK(d->midi))
		ctl_full(d->midi, d->origin, d->rate, d->round, dev_getpos(d));
d1705 4
a1708 2
	if (APROC_OK(d->midi))
		ctl_qfr(d->midi, d->rate, delta);
@


1.71
log
@Move mmc/mtc and volume control bits from struct aproc to struct
dev. Allows volume settings to be saved while the device is kept
closed. Besides that, no behabiour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.70 2011/11/16 21:26:55 ratchov Exp $	*/
d144 1
@


1.70
log
@mark the device as closed before closing streams attached to it.
otherwise a stream may try to close the device a second time.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.69 2011/11/16 21:22:17 ratchov Exp $	*/
d67 1
d88 1
d116 1
a116 1
	unsigned *pnum;
d145 11
a408 1
		d->mix->u.mix.ctl = d->midi;
a412 5
		/*
		 * If not playing, use the record end as clock source
		 */
		if (!(d->mode & MODE_PLAY))
			d->sub->u.sub.ctl = d->midi;
d667 7
d745 1
a745 1
		f->ops->start(f);
d748 1
a748 1
		f->ops->start(f);
d869 1
a869 1
			d->midi->u.ctl.tstate != CTL_RUN)) {
d1026 2
d1281 450
@


1.69
log
@prefix device-specific messages by the device name, since we
support multiple devices
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.68 2011/11/15 08:05:22 ratchov Exp $	*/
d546 1
a546 1

a651 1
	d->pstate = DEV_CLOSED;
@


1.68
log
@Add a "device number" component in sndio(7) device names, allowing a
single aucat instance to handle all audio and MIDI services. Since
this partially breaks compatibility, this is a opportunitiy to fix few
other design mistakes (eg ':' being used by inet6, type name vs api
name confusion, etc..). This leads to the following names:

        type[@@hostname][,unit]/devnum[.option]

The device number is the minor device number for direct hardware
access (ie the 'N' in /dev/audioN). For aucat, this is the occurence
number of the -f (or -M) option.

There's a compatibility hook to keep old names working if only one
aucat server is running.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.67 2011/10/12 07:20:04 ratchov Exp $	*/
d523 4
a526 2
		if (debug_level >= 3) 
			dbg_puts("draining device\n");
d532 4
a535 2
		if (debug_level >= 3) 
			dbg_puts("flushing device\n");
d541 4
a544 2
	if (debug_level >= 2) 
		dbg_puts("closing device\n");
d749 4
a752 2
	if (debug_level >= 2)
		dbg_puts("device stopped\n");
d776 4
a779 2
	if (debug_level >= 3)
		dbg_puts("device requested\n");
d794 4
a797 2
	if (debug_level >= 3)
		dbg_puts("device released\n");
d826 4
a829 2
		if (debug_level >= 1)
			dbg_puts("device disappeared\n");
d858 4
a861 2
			if (debug_level >= 3)
				dbg_puts("device idle, suspending\n");
d985 2
a986 1
		dbg_puts("syncing device");
d1047 2
a1048 1
	    	dbg_puts("mode beyond device mode, not attaching\n");
d1223 2
a1224 1
			dbg_puts("play end not idle, can't clear device\n");
d1238 2
a1239 1
			dbg_puts("record end not idle, can't clear device\n");
d1253 2
a1254 1
			dbg_puts("monitoring end not idle, can't clear device\n");
@


1.67
log
@Simplify and improve the way options are parsed and remove ~300 lines
of code that becomes unused. Few command line arguments changes are
required though:

  - stream definitions (-ios) now must follow devices definitions they
    are attached to (-fMn)

  - the -n option is now a special "loopback" device and is thus used
    like -f, eg it must precede streams

  - in midicat, midi thru boxes are not created automatically anymore,
    the new "-M" option must be used for that

  - channel numbers (-Cc options) correspond always to channel numbers
    of the hardware.

  - the -u option isn't needed anymore

  - increase the log verbosity so user errors are logged
    without using -d

tested by many, help from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.66 2011/06/20 20:18:44 ratchov Exp $	*/
a64 21
/*
 * TODO:
 *
 * priming buffer is not ok, because it will insert silence and
 * break synchronization to other programs.
 *
 * priming buffer in server mode is required, because f->bufsz may
 * be smaller than the server buffer and may cause underrun in the
 * dev_bufsz part of the buffer, in turn causing apps to break. It
 * doesn't hurt because we care only in synchronization between
 * clients.
 *
 * Priming is not required in non-server mode, because streams
 * actually start when they are in the READY state, and their
 * buffer is large enough to never cause underruns of dev_bufsz.
 *
 * Fix sock.c to allocate dev_bufsz, but to use only appbufsz --
 * or whatever -- but to avoid underruns in dev_bufsz. Then remove
 * this ugly hack.
 *
 */
d90 15
d114 1
d121 11
d144 1
a144 1
	dev_list = d;
d170 1
a170 1
		    dbg_puts(d->path);
d186 1
a186 1
devctl_add(struct dev *d, char *name, unsigned mode)
d195 1
a195 1
	c->path = name;
d292 2
d307 1
a307 1
				dbg_puts(d->path);
d367 1
a367 1
			dbg_puts(d->path);
d373 1
a373 1
			dbg_puts(d->path);
d482 1
a482 1
			dbg_puts(d->path);
@


1.66
log
@Make -aoff option apply to MIDI ports (-q) as well, ensuring the device
stays closed also if -q is used. As we're at it, add -a to midicat so
it behaves like aucat.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.65 2011/05/26 07:18:40 ratchov Exp $	*/
d116 1
a116 2
dev_new_sio(char *path,
    unsigned mode, struct aparams *dipar, struct aparams *dopar,
d129 2
a130 4
	if (mode & MODE_PLAY)
		d->reqopar = *dopar;
	if (mode & MODE_RECMASK)
		d->reqipar = *dipar;
d135 1
a138 4
	if (d->hold && !dev_open(d)) {
		dev_del(d);
		return NULL;
	}
d143 1
a143 1
 * Create a loopback synchronous device
d145 3
a147 2
struct dev *
dev_new_loop(struct aparams *dipar, struct aparams *dopar, unsigned bufsz)
d149 5
a153 26
	struct aparams par;
	unsigned cmin, cmax, rate;
	struct dev *d;

	d = malloc(sizeof(struct dev));
	if (d == NULL) {
		perror("malloc");
		exit(1);
	}
	d->ctl_list = NULL;
	cmin = (dipar->cmin < dopar->cmin) ? dipar->cmin : dopar->cmin;
	cmax = (dipar->cmax > dopar->cmax) ? dipar->cmax : dopar->cmax;
	rate = (dipar->rate > dopar->rate) ? dipar->rate : dopar->rate;
	aparams_init(&par, cmin, cmax, rate);
	d->reqipar = par;
	d->reqopar = par;
	d->rate = rate;
	d->reqround = (bufsz + 1) / 2;
	d->reqbufsz = d->reqround * 2;
	d->reqmode = MODE_PLAY | MODE_REC | MODE_LOOP | MODE_MIDIMASK;
	d->pstate = DEV_CLOSED;
	d->hold = 0;
	d->path = "loop";
	d->next = dev_list;
	dev_list = d;
	return d;
d157 1
a157 1
 * Create a MIDI thru box device
d159 2
a160 2
struct dev *
dev_new_thru(int hold)
d162 10
a171 6
	struct dev *d;

	d = malloc(sizeof(struct dev));
	if (d == NULL) {
		perror("malloc");
		exit(1);
d173 1
a173 8
	d->ctl_list = NULL;
	d->reqmode = MODE_MIDIMASK;
	d->pstate = DEV_CLOSED;
	d->hold = hold;
	d->path = "midithru";
	d->next = dev_list;
	dev_list = d;
	return d;
d193 2
a194 4
	if (d->pstate != DEV_CLOSED) {
		if (!devctl_open(d, c))
			return 0;
	}
d237 1
a237 1
	unsigned siomode;
d253 18
d306 11
d318 3
a320 6
		if (debug_level >= 2) {
			if (d->mode & MODE_REC) {
				dbg_puts(d->path);
				dbg_puts(": recording ");
				aparams_dbg(&d->ipar);
				dbg_puts("\n");
d322 8
a329 5
			if (d->mode & MODE_PLAY) {
				dbg_puts(d->path);
				dbg_puts(": playing ");
				aparams_dbg(&d->opar);
				dbg_puts("\n");
d331 2
d334 6
d341 17
d359 4
a362 2
			d->rec = rsio_new(f);
			d->rec->refs++;
d365 4
a368 2
			d->play = wsio_new(f);
			d->play->refs++;
d371 1
a371 1

d377 2
a378 2
		d->midi = (d->mode & (MODE_PLAY | MODE_RECMASK)) ?
		    ctl_new("ctl", d) : thru_new("thru");
a408 1
		d->rate = d->opar.rate;
@


1.65
log
@add a new -w flag to control whether master volume is automatically
adjusted when new streams are connected and disconnected. Disabling
automatic volume adjustment makes sense if all streams are recorded
with properly lowered volumes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.64 2010/10/21 18:57:42 ratchov Exp $	*/
d108 1
d127 1
d163 1
d186 1
a186 1
dev_new_thru(void)
d195 1
d198 1
a198 1
	d->hold = 0;
d206 51
d264 1
d458 12
a643 29
}

/*
 * Open a MIDI device and connect it to the thru box
 */
int
dev_thruadd(struct dev *d, char *name, int in, int out)
{
	struct file *f;
	struct abuf *rbuf = NULL, *wbuf = NULL;
	struct aproc *rproc, *wproc;

	if (!dev_ref(d))
		return 0;
	f = (struct file *)miofile_new(&miofile_ops, name, in, out);
	if (f == NULL)
		return 0;
	if (in) {
		rproc = rfile_new(f);
		rbuf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setout(rproc, rbuf);
	}
	if (out) {
		wproc = wfile_new(f);
		wbuf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setin(wproc, wbuf);
	}
	dev_midiattach(d, rbuf, wbuf);
	return 1;
@


1.64
log
@use MODE_xxx and XRUN_xxx macros everywhere, and zap corresponding
AMSG_xxx macros, which in turns simplifies the code
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.63 2010/07/31 08:46:56 ratchov Exp $	*/
d117 1
a117 1
    unsigned bufsz, unsigned round, unsigned hold)
d135 1
d303 1
a303 1
		d->mix = mix_new("play", d->bufsz, d->round);
@


1.63
log
@remove forgotten debug message
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.62 2010/07/06 01:12:45 ratchov Exp $	*/
d169 1
a169 1
	d->reqmode = MODE_PLAY | MODE_REC | MODE_LOOP;
d191 1
a191 1
	d->reqmode = 0;
d292 5
a296 2
	d->midi = (d->mode == 0) ? thru_new("thru") : ctl_new("ctl", d);
	d->midi->refs++;
@


1.62
log
@Handle all streams the same way because there's no actual
difference between audio files and client connections. Clean up
the way command line options are handled and clarify this in the
manual page: stream parameters (-Ccehjmrtvx) must precede stream
definitions (-ios) and per-device parameters (-abz) and stream
definitions (-ios) must precede device definitions (-f). Since
there's no ``server'' and ``non-server'' modes anymore, make the
-l option just detach the process.

ok and help from jakemsr and jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.61 2010/06/29 06:57:00 jakemsr Exp $	*/
a1154 1
		dbg_puts("clearing monitor\n");
@


1.61
log
@explicitely initialize members of struct dev in dev_open()
fixes crash found by nicm
ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.60 2010/06/25 07:32:05 ratchov Exp $	*/
d172 1
d194 1
d242 1
a242 1
				dbg_puts(d->path ? d->path : "default");
d255 1
a255 1
				dbg_puts(d->path ? d->path : "default");
d265 2
a266 1
				dbg_puts("hw recording ");
d271 2
a272 1
				dbg_puts("hw playing ");
d388 2
a389 1
			dbg_puts("device block size is ");
@


1.60
log
@don't attempt to drain devices after they are destroyed, which
results in a use after free(). Catched by jakemsr@@ with MALLOC_OPTIONS=J
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.59 2010/06/05 16:14:44 ratchov Exp $	*/
d219 2
d222 1
@


1.59
log
@in dev_close(), first terminate streams recording from the hardware,
then terminate streams recording from the monitor (if any). Otherwise,
dev_close() would try to check if a stream is recording from the
hardware or the monitor, and, if there's no monitor, would dereference
a NULL pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.58 2010/06/05 16:00:52 ratchov Exp $	*/
d536 10
d553 1
a553 2
	if (d->pstate != DEV_CLOSED)
		dev_close(d);
@


1.58
log
@don't prime server buffers, because it's ugly and conceptually
complicated. Instead, request clients to provide enough samples
and start with buffers full.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.57 2010/06/04 06:15:28 ratchov Exp $	*/
d457 1
a457 1
	} else if (d->sub || d->submon) {
d466 1
a466 2
			    (aproc_depend(d->sub, f->rproc) ||
			     aproc_depend(d->submon, f->rproc))) {
d469 12
@


1.57
log
@Allow the audio device to be opened only while it's actually used.
This is necessary for uaudio devices, for instance to start aucat
before the device is plugged. Or to unplug a device whithout
having to restart aucat when another device is plugged.  This is
controlled with the new -a option.

Allow multiple audio devices to be used concurently, i.e.
multiple ``-f devname'' options to be used; -f options must follow
per-device options, which is what we do for other options.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.56 2010/05/08 15:35:45 ratchov Exp $	*/
a107 1
void dev_prime(struct dev *);
d117 1
a117 1
    unsigned bufsz, unsigned round, unsigned hold, unsigned prime)
a133 1
	d->prime = prime;
a171 1
	d->prime = 0;
a192 1
	d->prime = 0;
a389 2
	if (d->prime)
		dev_prime(d);
d745 1
a745 1
			else {
a746 3
				if (d->prime)
					dev_prime(d);
			}
d754 1
a754 4
 * If the device is paused, then resume it. If the caller is using
 * full-duplex and its buffers are small, the ``prime'' flag
 * could be set to initialize device buffers with silence
 *
a1139 23
	}
}

/*
 * Fill with silence play buffers and schedule the same amount of recorded
 * samples to drop
 */
void
dev_prime(struct dev *d)
{

#ifdef DEBUG
	if (debug_level >= 3)
		dbg_puts("priming device\n");
#endif
	if (APROC_OK(d->mix)) {
#ifdef DEBUG
		if (!LIST_EMPTY(&d->mix->ins)) {
			dbg_puts("play end not idle, can't prime device\n");
			dbg_panic();	
		}
#endif
		mix_prime(d->mix);
@


1.56
log
@prime play buffers as soon as the device is opened, otherwise a
midi client could start it with empty buffers, in turn hurting
audio clients.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.55 2010/05/08 13:08:24 ratchov Exp $	*/
d28 1
a28 1
 *   1. create the device using dev_init_xxx()
d30 1
a30 1
 *   3. destroy the device using dev_done()
d103 8
a110 33
/*
 * state of the device
 */
#define DEV_CLOSED	0		/* closed */
#define DEV_INIT	1		/* stopped */
#define DEV_START	2		/* ready to start */
#define DEV_RUN		3		/* started */

/*
 * desired parameters
 */
unsigned dev_reqmode;				/* mode */
struct aparams dev_reqipar, dev_reqopar;	/* parameters */
unsigned dev_reqbufsz;				/* buffer size */
unsigned dev_reqround;				/* block size */
unsigned dev_reqprime;				/* prime play buffer? */

/*
 * actual parameters and runtime state
 */
char *dev_path;					/* sio path */
unsigned dev_refcnt = 0;			/* number of openers */
unsigned dev_pstate;				/* on of DEV_xxx */
unsigned dev_mode;				/* bitmap of MODE_xxx */
unsigned dev_bufsz, dev_round, dev_rate;
struct aparams dev_ipar, dev_opar;
struct aproc *dev_mix, *dev_sub, *dev_rec, *dev_play, *dev_submon, *dev_mon;
struct aproc *dev_midi;

void dev_start(void);
void dev_stop(void);
void dev_clear(void);
void dev_prime(void);
d115 14
a128 7
void
dev_init_sio(char *path, unsigned mode, 
    struct aparams *dipar, struct aparams *dopar,
    unsigned bufsz, unsigned round)
{
	dev_path = path;
	dev_reqmode = mode;
d130 1
a130 1
		dev_reqopar = *dopar;
d132 13
a144 4
		dev_reqipar = *dipar;
	dev_reqbufsz = bufsz;
	dev_reqround = round;
	dev_pstate = DEV_CLOSED;
d150 2
a151 2
void
dev_init_loop(struct aparams *dipar, struct aparams *dopar, unsigned bufsz)
d155 1
d157 5
d166 12
a177 7
	dev_reqipar = par;
	dev_reqopar = par;
	dev_rate = rate;
	dev_reqround = (bufsz + 1) / 2;
	dev_reqbufsz = dev_reqround * 2;
	dev_reqmode = MODE_PLAY | MODE_REC | MODE_LOOP;
	dev_pstate = DEV_CLOSED;
d183 2
a184 2
void
dev_init_thru(void)
d186 14
a199 2
	dev_reqmode = 0;
	dev_pstate = DEV_CLOSED;
d207 1
a207 1
dev_open(void)
d215 10
a224 10
	dev_mode = dev_reqmode;
	dev_round = dev_reqround;
	dev_bufsz = dev_reqbufsz;
	dev_ipar = dev_reqipar;
	dev_opar = dev_reqopar;
	dev_rec = NULL;
	dev_play = NULL;
	dev_mon = NULL;
	dev_submon = NULL;
	dev_rate = 0;
d229 2
a230 2
	if ((dev_mode & (MODE_PLAY | MODE_REC)) && !(dev_mode & MODE_LOOP)) {
		siomode = dev_mode & (MODE_PLAY | MODE_REC);
d232 1
a232 1
		    dev_path,
d234 4
a237 4
		    &dev_ipar,
		    &dev_opar,
		    &dev_bufsz,
		    &dev_round);
d241 1
a241 1
				dbg_puts(dev_path ? dev_path : "default");
d248 1
a248 1
			dev_mode &= ~(MODE_PLAY | MODE_MON);
d250 2
a251 2
			dev_mode &= ~MODE_REC;
		if ((dev_mode & (MODE_PLAY | MODE_REC)) == 0) {
d254 1
a254 1
				dbg_puts(dev_path ? dev_path : "default");
d260 1
a260 1
		dev_rate = dev_mode & MODE_REC ? dev_ipar.rate : dev_opar.rate;
d263 1
a263 1
			if (dev_mode & MODE_REC) {
d265 1
a265 1
				aparams_dbg(&dev_ipar);
d268 1
a268 1
			if (dev_mode & MODE_PLAY) {
d270 1
a270 1
				aparams_dbg(&dev_opar);
d275 7
a281 7
		if (dev_mode & MODE_REC) {
			dev_rec = rsio_new(f);
			dev_rec->refs++;
		}
		if (dev_mode & MODE_PLAY) {
			dev_play = wsio_new(f);
			dev_play->refs++;
d289 2
a290 2
	dev_midi = (dev_mode == 0) ? thru_new("thru") : ctl_new("ctl");
	dev_midi->refs++;
d295 8
a302 8
	if (dev_mode & MODE_PLAY) {
		dev_mix = mix_new("play", dev_bufsz, dev_round);
		dev_mix->refs++;
		dev_mix->u.mix.ctl = dev_midi;
	}
	if (dev_mode & MODE_REC) {
		dev_sub = sub_new("rec", dev_bufsz, dev_round);
		dev_sub->refs++;
d306 2
a307 2
		if (!(dev_mode & MODE_PLAY))
			dev_sub->u.sub.ctl = dev_midi;
d309 1
a309 1
	if (dev_mode & MODE_LOOP) {
d313 7
a319 7
		buf = abuf_new(dev_bufsz, &dev_opar);
		aproc_setout(dev_mix, buf);
		aproc_setin(dev_sub, buf);

		dev_mix->flags |= APROC_QUIT;
		dev_sub->flags |= APROC_QUIT;
		dev_rate = dev_opar.rate;
d321 2
a322 2
	if (dev_rec) {
		aparams_init(&par, dev_ipar.cmin, dev_ipar.cmax, dev_rate);
d327 2
a328 2
		buf = abuf_new(dev_bufsz, &dev_ipar);
		aproc_setout(dev_rec, buf);
d333 2
a334 2
		if (!aparams_eqenc(&dev_ipar, &par)) {
			conv = dec_new("rec", &dev_ipar);
d336 1
a336 1
			buf = abuf_new(dev_round, &par);
d339 2
a340 2
		dev_ipar = par;
		aproc_setin(dev_sub, buf);
d342 2
a343 2
	if (dev_play) {
		aparams_init(&par, dev_opar.cmin, dev_opar.cmax, dev_rate);
d348 2
a349 2
		buf = abuf_new(dev_bufsz, &dev_opar);
		aproc_setin(dev_play, buf);
d354 2
a355 2
		if (!aparams_eqenc(&par, &dev_opar)) {
			conv = enc_new("play", &dev_opar);
d357 1
a357 1
			buf = abuf_new(dev_round, &par);
d360 2
a361 2
		dev_opar = par;
		aproc_setout(dev_mix, buf);
d363 5
a367 5
	if (dev_mode & MODE_MON) {
		dev_mon = mon_new("mon", dev_bufsz);
		dev_mon->refs++;
		buf = abuf_new(dev_bufsz, &dev_opar);
		aproc_setout(dev_mon, buf);
d372 3
a374 3
		dev_submon = sub_new("mon", dev_bufsz, dev_round);
		dev_submon->refs++;
		aproc_setin(dev_submon, buf);
d379 2
a380 2
		dev_mix->u.mix.mon = dev_mon;
		dev_mon->refs++;
d384 1
a384 1
		if (dev_mode & (MODE_PLAY | MODE_RECMASK)) {
d386 1
a386 1
			dbg_putu(dev_round);
d388 1
a388 1
			dbg_putu(dev_bufsz / dev_round);
d393 3
a395 3
	dev_pstate = DEV_INIT;
	if (dev_reqprime)
		dev_prime();
d404 1
a404 1
dev_close(void)
d412 1
a412 1
	switch (dev_pstate) {
d418 1
a418 1
		dev_start();
d425 1
a425 1
		dev_clear();
d433 1
a433 1
	if (dev_mix) {
d444 2
a445 2
		if (APROC_OK(dev_mix))
			mix_quit(dev_mix);
d450 4
a453 4
		if (APROC_OK(dev_mix->u.mix.mon)) {
			dev_mix->u.mix.mon->refs--;
			aproc_del(dev_mix->u.mix.mon);
			dev_mix->u.mix.mon = NULL;
d458 1
a458 1
			    aproc_depend(dev_mix, f->rproc)) {
d463 1
a463 1
	} else if (dev_sub || dev_submon) {
d472 2
a473 2
			    (aproc_depend(dev_sub, f->rproc) ||
			     aproc_depend(dev_submon, f->rproc))) {
d479 4
a482 4
	if (dev_midi) {
		dev_midi->flags |= APROC_QUIT;
		if (LIST_EMPTY(&dev_midi->ins))
			aproc_del(dev_midi);
d486 1
a486 1
			    aproc_depend(dev_midi, f->rproc)) {
d492 34
a525 34
	if (dev_mix) {
		if (--dev_mix->refs == 0 && (dev_mix->flags & APROC_ZOMB))
			aproc_del(dev_mix);
		dev_mix = NULL;
	}
	if (dev_play) {
		if (--dev_play->refs == 0 && (dev_play->flags & APROC_ZOMB))
			aproc_del(dev_play);
		dev_play = NULL;
	}
	if (dev_sub) {
		if (--dev_sub->refs == 0 && (dev_sub->flags & APROC_ZOMB))
			aproc_del(dev_sub);
		dev_sub = NULL;
	}
	if (dev_rec) {
		if (--dev_rec->refs == 0 && (dev_rec->flags & APROC_ZOMB))
			aproc_del(dev_rec);
		dev_rec = NULL;
	}
	if (dev_submon) {
		if (--dev_submon->refs == 0 && (dev_submon->flags & APROC_ZOMB))
			aproc_del(dev_submon);
		dev_submon = NULL;
	}
	if (dev_mon) {
		if (--dev_mon->refs == 0 && (dev_mon->flags & APROC_ZOMB))
			aproc_del(dev_mon);
		dev_mon = NULL;
	}
	if (dev_midi) {
		if (--dev_midi->refs == 0 && (dev_midi->flags & APROC_ZOMB))
			aproc_del(dev_midi);
		dev_midi = NULL;
d527 1
a527 1
	dev_pstate = DEV_CLOSED;
d534 1
a534 1
dev_done(void)
d536 14
a549 2
	if (dev_pstate != DEV_CLOSED)
		dev_close();
d556 1
a556 1
dev_thruadd(char *name, int in, int out)
d562 1
a562 1
	if (!dev_ref())
d577 1
a577 1
	dev_midiattach(rbuf, wbuf);
d585 1
a585 1
dev_midiattach(struct abuf *ibuf, struct abuf *obuf)
d588 1
a588 1
		aproc_setin(dev_midi, ibuf);
d590 1
a590 1
		aproc_setout(dev_midi, obuf);
d599 1
a599 1
dev_roundof(unsigned newrate)
d601 1
a601 1
	return (dev_round * newrate + dev_rate / 2) / dev_rate;
d608 1
a608 1
dev_start(void)
d616 2
a617 2
	dev_pstate = DEV_RUN;
	if (dev_mode & MODE_LOOP)
d619 8
a626 8
	if (APROC_OK(dev_mix))
		dev_mix->flags |= APROC_DROP;
	if (APROC_OK(dev_sub))
		dev_sub->flags |= APROC_DROP;
	if (APROC_OK(dev_submon))
		dev_submon->flags |= APROC_DROP;
	if (APROC_OK(dev_play) && dev_play->u.io.file) {
		f = dev_play->u.io.file;
d628 2
a629 2
	} else if (APROC_OK(dev_rec) && dev_rec->u.io.file) {
		f = dev_rec->u.io.file;
d639 1
a639 1
dev_stop(void)
d645 1
a645 1
		dbg_puts("stopping stopped\n");
d647 2
a648 2
	dev_pstate = DEV_INIT;
	if (dev_mode & MODE_LOOP)
d650 2
a651 2
	if (APROC_OK(dev_play) && dev_play->u.io.file) {
		f = dev_play->u.io.file;
d653 2
a654 2
	} else if (APROC_OK(dev_rec) && dev_rec->u.io.file) {
		f = dev_rec->u.io.file;
d657 6
a662 6
	if (APROC_OK(dev_mix))
		dev_mix->flags &= ~APROC_DROP;
	if (APROC_OK(dev_sub))
		dev_sub->flags &= ~APROC_DROP;
	if (APROC_OK(dev_submon))
		dev_submon->flags &= ~APROC_DROP;
d666 1
a666 1
dev_ref(void)
d672 3
a674 1
	if (dev_pstate == DEV_CLOSED && !dev_open())
d676 2
a677 1
	dev_refcnt++;
d682 1
a682 1
dev_unref(void)
d688 3
a690 3
	dev_refcnt--;
	if (dev_refcnt == 0 && dev_pstate == DEV_INIT)
		dev_close();
d704 1
a704 1
dev_run(void)
d706 1
a706 1
	if (dev_pstate == DEV_CLOSED)
d711 3
a713 3
	if (((dev_mode & MODE_PLAY) && !APROC_OK(dev_mix)) ||
	    ((dev_mode & MODE_REC)  && !APROC_OK(dev_sub)) ||
	    ((dev_mode & MODE_MON)  && !APROC_OK(dev_submon))) {
d718 6
a723 2
		dev_close();
		return 0;
d725 1
a725 1
	switch (dev_pstate) {
d730 1
a730 1
		dev_start();
d736 8
a743 8
		if ((!APROC_OK(dev_mix) ||
			dev_mix->u.mix.idle > 2 * dev_bufsz) &&
		    (!APROC_OK(dev_sub) ||
			dev_sub->u.sub.idle > 2 * dev_bufsz) &&
		    (!APROC_OK(dev_submon) ||
			dev_submon->u.sub.idle > 2 * dev_bufsz) &&
		    (!APROC_OK(dev_midi) ||
			dev_midi->u.ctl.tstate != CTL_RUN)) {
d748 3
a750 3
			dev_stop();
			if (dev_refcnt == 0)
				dev_close();
d752 3
a754 3
				dev_clear();
				if (dev_reqprime)
					dev_prime();
d770 1
a770 1
dev_wakeup(void)
d772 2
a773 2
	if (dev_pstate == DEV_INIT)
		dev_pstate = DEV_START;
d780 2
a781 1
dev_getep(unsigned mode, struct abuf **sibuf, struct abuf **sobuf)
d786 1
a786 1
		if (!APROC_OK(dev_mix))
d799 1
a799 1
			if (ibuf->rproc == dev_mix)
d806 1
a806 1
		if (!APROC_OK(dev_sub))
d819 1
a819 1
			if (obuf->wproc == dev_sub)
d826 1
a826 1
		if (!APROC_OK(dev_submon))
d839 1
a839 1
			if (obuf->wproc == dev_submon)
d853 1
a853 1
dev_sync(unsigned mode, struct abuf *ibuf, struct abuf *obuf)
d856 1
a856 1
	struct abuf *mbuf;
d858 1
a858 1
	if (!dev_getep(mode, &ibuf, &obuf))
d867 2
a868 2
	if (APROC_OK(dev_mix)) {
		mbuf = LIST_FIRST(&dev_mix->outs);
d870 1
a870 1
		delta += dev_mix->u.mix.lat;
d872 2
a873 2
	if (APROC_OK(dev_sub))
		delta += dev_sub->u.sub.lat;
d877 1
a877 1
		if (APROC_OK(dev_mix)) {
d879 1
a879 1
			aproc_dbg(dev_mix);
d883 1
a883 1
			dbg_putu(dev_mix->u.mix.lat);
d885 1
a885 1
		if (APROC_OK(dev_sub)) {
d887 1
a887 1
			aproc_dbg(dev_sub);
d889 1
a889 1
			dbg_putu(dev_sub->u.sub.lat);
d905 1
a905 1
dev_getpos(void)
d909 3
a911 3
	if (APROC_OK(dev_mix)) {
		mbuf = LIST_FIRST(&dev_mix->outs);
		return -(mbuf->w.mix.todo + dev_mix->u.mix.lat);
d923 1
a923 1
dev_attach(char *name, unsigned mode,
d934 3
a936 3
	if ((!APROC_OK(dev_mix)    && (mode & MODE_PLAY)) ||
	    (!APROC_OK(dev_sub)    && (mode & MODE_REC)) ||
	    (!APROC_OK(dev_submon) && (mode & MODE_MON))) {
d943 3
a945 3
		pbuf = LIST_FIRST(&dev_mix->outs);
		nblk = (dev_bufsz / dev_round + 3) / 4;
		round = dev_roundof(ipar.rate);
d947 1
a947 1
		if (!aparams_eqenc(&ipar, &dev_opar)) {
d949 5
a953 5
			ipar.bps = dev_opar.bps;
			ipar.bits = dev_opar.bits;
			ipar.sig = dev_opar.sig;
			ipar.le = dev_opar.le;
			ipar.msb = dev_opar.msb;
d965 4
a968 4
		if (!aparams_eqrate(&ipar, &dev_opar)) {
			conv = resamp_new(name, round, dev_round);
			ipar.rate = dev_opar.rate;
			round = dev_round;
d980 1
a980 1
		aproc_setin(dev_mix, ibuf);
d983 1
a983 1
		mix_setmaster(dev_mix);
d987 3
a989 3
		rbuf = LIST_FIRST(&dev_sub->ins);
		round = dev_roundof(opar.rate);
		nblk = (dev_bufsz / dev_round + 3) / 4;
d991 1
a991 1
		if (!aparams_eqenc(&opar, &dev_ipar)) {
d993 5
a997 5
			opar.bps = dev_ipar.bps;
			opar.bits = dev_ipar.bits;
			opar.sig = dev_ipar.sig;
			opar.le = dev_ipar.le;
			opar.msb = dev_ipar.msb;
d1009 4
a1012 4
		if (!aparams_eqrate(&opar, &dev_ipar)) {
			conv = resamp_new(name, dev_round, round);
			opar.rate = dev_ipar.rate;
			round = dev_round;
d1024 1
a1024 1
		aproc_setout(dev_sub, obuf);
d1029 3
a1031 3
		rbuf = LIST_FIRST(&dev_submon->ins);
		round = dev_roundof(opar.rate);
		nblk = (dev_bufsz / dev_round + 3) / 4;
d1033 1
a1033 1
		if (!aparams_eqenc(&opar, &dev_opar)) {
d1035 5
a1039 5
			opar.bps = dev_opar.bps;
			opar.bits = dev_opar.bits;
			opar.sig = dev_opar.sig;
			opar.le = dev_opar.le;
			opar.msb = dev_opar.msb;
d1051 4
a1054 4
		if (!aparams_eqrate(&opar, &dev_opar)) {
			conv = resamp_new(name, dev_round, round);
			opar.rate = dev_opar.rate;
			round = dev_round;
d1066 1
a1066 1
		aproc_setout(dev_submon, obuf);
d1077 1
a1077 1
	dev_sync(mode, ibuf, obuf);
d1084 1
a1084 1
dev_setvol(struct abuf *ibuf, int vol)
d1094 1
a1094 1
	if (!dev_getep(MODE_PLAY, &ibuf, NULL)) {
d1105 1
a1105 1
dev_clear(void)
d1109 1
a1109 1
	if (APROC_OK(dev_mix)) {
d1111 1
a1111 1
		if (!LIST_EMPTY(&dev_mix->ins)) {
d1116 1
a1116 1
		buf = LIST_FIRST(&dev_mix->outs);
d1121 1
a1121 1
		mix_clear(dev_mix);
d1123 1
a1123 1
	if (APROC_OK(dev_sub)) {
d1125 1
a1125 1
		if (!LIST_EMPTY(&dev_sub->outs)) {
d1130 1
a1130 1
		buf = LIST_FIRST(&dev_sub->ins);
d1135 1
a1135 1
		sub_clear(dev_sub);
d1137 1
a1137 1
	if (APROC_OK(dev_submon)) {
d1140 1
a1140 1
		if (!LIST_EMPTY(&dev_submon->outs)) {
d1145 1
a1145 1
		buf = LIST_FIRST(&dev_submon->ins);
d1150 2
a1151 2
		sub_clear(dev_submon);
		mon_clear(dev_mon);
d1160 1
a1160 1
dev_prime(void)
d1167 1
a1167 1
	if (APROC_OK(dev_mix)) {
d1169 1
a1169 1
		if (!LIST_EMPTY(&dev_mix->ins)) {
d1174 1
a1174 1
		mix_prime(dev_mix);
@


1.55
log
@Fix sign in dev_getpos(). Indeed, positive device playback latency
is accounted as negative start position offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.54 2010/05/08 12:29:08 ratchov Exp $	*/
d118 1
d380 2
d718 1
a718 1
			else
d720 3
d737 1
a737 1
dev_wakeup(int prime)
d739 1
a739 3
	if (dev_pstate == DEV_INIT) {
		if (prime)
			dev_prime();
a740 1
	 }
@


1.54
log
@don't take into account recording latency in dev_getpos(), since
dev_sync() always discards any recorded samples
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.53 2010/05/07 07:13:21 ratchov Exp $	*/
d874 1
a874 1
		return mbuf->w.mix.todo + dev_mix->u.mix.lat;
@


1.53
log
@Since aucat uses libsndio, play and rec clocks are the same, so
use play and rec latencies counters to calculate the offset
between play and rec direction. Greatly simplifies stream
attaching code.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.52 2010/05/04 19:35:20 ratchov Exp $	*/
a870 1
	int lat;
a871 1
	lat = 0;
d874 3
a876 5
		lat -= mbuf->w.mix.todo + dev_mix->u.mix.lat;
	}
	if (APROC_OK(dev_sub))
		lat -= dev_sub->u.sub.lat;
	return lat;
@


1.52
log
@if the ``device'' is in loopback mode (ie no audio device), then
disable overruns/underruns since aucat must pause when an input or
an output blocks. This is a theoretical fix, since the
start/stop code is never reached in loopback mode
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.51 2010/05/02 11:54:26 ratchov Exp $	*/
d818 2
a819 1
	int delta;
d828 9
a836 6
	if (APROC_OK(dev_mix) && APROC_OK(dev_sub)) {
		delta = dev_mix->u.mix.abspos - dev_sub->u.sub.abspos;
	} else if (APROC_OK(dev_mix)) {
		delta = dev_mix->u.mix.lat;
	} else
		delta = 0;
d839 1
a839 2
		dbg_puts("syncing device, delta = ");
		dbg_putu(delta);
d843 4
a846 2
			dbg_puts(": abspos = ");
			dbg_putu(dev_mix->u.mix.abspos);
d851 2
a852 2
			dbg_puts(": abspos = ");
			dbg_putu(dev_sub->u.sub.abspos);
d857 4
a860 15
	if (delta > 0) {
		/*
		 * The play chain is ahead (most cases) drop some of
		 * the recorded input, to get both in sync.
		 */
		if (mode & MODE_RECMASK)
			sub_silence(obuf, -delta);
	} else if (delta < 0) {
		/*
		 * The record chain is ahead (should never happen,
		 * right?) then insert silence to play.
		 */
		 if (mode & MODE_PLAY)
		 	mix_drop(ibuf, delta);
	}
d870 2
a871 3
	struct abuf *pbuf = NULL, *rbuf = NULL;
	int plat = 0, rlat = 0;
	int delta;
d873 1
d875 2
a876 4
		pbuf = LIST_FIRST(&dev_mix->outs);
		if (!pbuf)
			return 0;
		plat = -dev_mix->u.mix.lat;
d878 3
a880 23
	if (APROC_OK(dev_sub)) {
		rbuf = LIST_FIRST(&dev_sub->ins);
		if (!rbuf)
			return 0;
		rlat = -dev_sub->u.sub.lat;
	}
	if (APROC_OK(dev_mix) && APROC_OK(dev_sub)) {
		delta = dev_mix->u.mix.abspos - dev_sub->u.sub.abspos;
		if (delta > 0)
			rlat -= delta;
		else if (delta < 0)
			plat += delta;
#ifdef DEBUG
		if (rlat != plat) {
			dbg_puts("dev_getpos: play/rec out of sync: plat = ");
			dbg_puti(plat);
			dbg_puts(", rlat = ");
			dbg_puti(rlat);
			dbg_puts("\n");
		}
#endif
	}
	return APROC_OK(dev_mix) ? plat : rlat;
@


1.51
log
@Clean up device handling code to clarify different initialization phases
and different device states. Split initialization in two phases:
first global variables are initialized then the audio hardware is opened.
Allow devices that don't support full-duplex to work in play-only or
record-only mode, even if ``-m play'' or ``-m rec'' are not specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.50 2010/05/02 11:12:31 ratchov Exp $	*/
d588 2
d614 4
d619 2
a633 4
#ifdef DEBUG
	if (debug_level >= 2)
		dbg_puts("device stopped\n");
#endif
@


1.50
log
@Don't systematically fill with silence the mixer output. This
might result in extra samples being written to the device
when the mixer is closed.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.49 2010/04/24 06:18:23 ratchov Exp $	*/
d17 69
a85 1

d103 7
a109 5
unsigned dev_pstate;
unsigned dev_bufsz, dev_round, dev_rate;
struct aparams dev_ipar, dev_opar;
struct aproc *dev_mix, *dev_sub, *dev_rec, *dev_play, *dev_submon, *dev_mon;
struct aproc *dev_midi;
d112 1
a112 1
 * Create a MIDI thru box as the MIDI end of the device
d114 4
a117 6
void
dev_thruinit(void)
{
	dev_midi = thru_new("thru");
	dev_midi->refs++;
}
d120 1
a120 1
 * Open a MIDI device and connect it to the thru box
d122 8
a129 6
int
dev_thruadd(char *name, int in, int out)
{
	struct file *f;
	struct abuf *rbuf = NULL, *wbuf = NULL;
	struct aproc *rproc, *wproc;
d131 4
a134 16
	f = (struct file *)miofile_new(&miofile_ops, name, in, out);
	if (f == NULL)
		return 0;
	if (in) {
		rproc = rfile_new(f);
		rbuf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setout(rproc, rbuf);
	}
	if (out) {
		wproc = wfile_new(f);
		wbuf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setin(wproc, wbuf);
	}
	dev_midiattach(rbuf, wbuf);
	return 1;
}
d137 1
a137 1
 * Attach a bi-directional MIDI stream to the MIDI device
d140 3
a142 1
dev_midiattach(struct abuf *ibuf, struct abuf *obuf)
d144 9
a152 9
	if (ibuf)
		aproc_setin(dev_midi, ibuf);
	if (obuf) {
		aproc_setout(dev_midi, obuf);
		if (ibuf) {
			ibuf->duplex = obuf;
			obuf->duplex = ibuf;
		}
	}
d156 1
a156 2
 * Same as dev_init(), but create a fake device that records what is
 * played.
d159 1
a159 1
dev_loopinit(struct aparams *dipar, struct aparams *dopar, unsigned bufsz)
a160 1
	struct abuf *buf;
a163 8
	/*
	 * in principle we don't need control, but the start-stop mechanism
	 * depend on it and it's simpler to reuse this mechanism rather than
	 * dealing with lots of special cases
	 */
	dev_midi = ctl_new("ctl");
	dev_midi->refs++;

d168 7
a174 24
	dev_ipar = par;
	dev_opar = par;
	dev_round = (bufsz + 1) / 2;
	dev_bufsz = dev_round * 2;
	dev_rate  = rate;
	dev_rec = NULL;
	dev_play = NULL;
	dev_mon = NULL;
	dev_submon = NULL;
	dev_pstate = DEV_INIT;

	buf = abuf_new(dev_bufsz, &par);
	dev_mix = mix_new("mix", dev_bufsz, 1);
	dev_mix->refs++;
	dev_sub = sub_new("sub", dev_bufsz, 1);
	dev_sub->refs++;
	aproc_setout(dev_mix, buf);
	aproc_setin(dev_sub, buf);

	dev_mix->flags |= APROC_QUIT;
	dev_sub->flags |= APROC_QUIT;

	*dipar = dev_ipar;
	*dopar = dev_opar;
d177 5
a181 2
unsigned
dev_roundof(unsigned newrate)
d183 2
a184 1
	return (dev_round * newrate + dev_rate / 2) / dev_rate;
d188 2
a189 3
 * Open the device with the given hardware parameters and create a mixer
 * and a multiplexer connected to it with all necessary conversions
 * setup.
d192 1
a192 2
dev_init(char *devpath, unsigned mode,
    struct aparams *dipar, struct aparams *dopar, unsigned bufsz, unsigned round)
d195 1
a195 1
	struct aparams ipar, opar;
d198 12
a209 3

	dev_midi = ctl_new("ctl");
	dev_midi->refs++;
d212 1
a212 2
	 * Ask for 1/4 of the buffer for the kernel ring and
	 * limit the block size to 1/4 of the requested buffer.
d214 10
a223 8
	dev_round = round;
	dev_bufsz = bufsz;
	f = (struct file *)siofile_new(&siofile_ops, devpath,
	    mode & (MODE_PLAY | MODE_REC), dipar, dopar,
	    &dev_bufsz, &dev_round);
	if (f == NULL)
		return 0;
	if (mode & MODE_REC) {
d225 6
a230 4
		if (debug_level >= 2) {
			dbg_puts("hw recording ");
			aparams_dbg(dipar);
			dbg_puts("\n");
d232 10
d243 3
a245 3
		dev_rate = dipar->rate;
	}
	if (mode & MODE_PLAY) {
d248 10
a257 3
			dbg_puts("hw playing ");
			aparams_dbg(dopar);
			dbg_puts("\n");
d260 8
a267 1
		dev_rate = dopar->rate;
d271 8
a278 1
	 * Create record chain.
d280 29
a308 2
	if (mode & MODE_REC) {
		aparams_init(&ipar, dipar->cmin, dipar->cmax, dipar->rate);
d310 1
a310 1
		 * Create the read end.
d312 1
a312 3
		dev_rec = rsio_new(f);
		dev_rec->refs++;
		buf = abuf_new(dev_bufsz, dipar);
d316 1
a316 1
		 * Append a converter, if needed.
d318 2
a319 2
		if (!aparams_eqenc(dipar, &ipar)) {
			conv = dec_new("rec", dipar);
d321 1
a321 1
			buf = abuf_new(dev_round, &ipar);
d324 1
a324 10
		dev_ipar = ipar;

		/*
		 * Append a "sub" to which clients will connect.
		 * Link it to the controller only in record-only mode
		 */
		dev_sub = sub_new("rec", dev_bufsz, dev_round);
		dev_sub->refs++;
		if (!(mode & MODE_PLAY))
			dev_sub->u.sub.ctl = dev_midi;
a325 3
	} else {
		dev_rec = NULL;
		dev_sub = NULL;
d327 2
a329 5
	/*
	 * Create play chain.
	 */
	if (mode & MODE_PLAY) {
		aparams_init(&opar, dopar->cmin, dopar->cmax, dopar->rate);
d331 1
a331 1
		 * Create the write end.
d333 1
a333 3
		dev_play = wsio_new(f);
		dev_play->refs++;
		buf = abuf_new(dev_bufsz, dopar);
d339 2
a340 2
		if (!aparams_eqenc(&opar, dopar)) {
			conv = enc_new("play", dopar);
d342 1
a342 1
			buf = abuf_new(dev_round, &opar);
d345 1
a345 8
		dev_opar = opar;

		/*
		 * Append a "mix" to which clients will connect.
		 */
		dev_mix = mix_new("play", dev_bufsz, dev_round);
		dev_mix->refs++;
		dev_mix->u.mix.ctl = dev_midi;
a346 3
	} else {
		dev_play = NULL;
		dev_mix = NULL;
d348 1
a348 5

	/*
	 * Create monitoring chain
	 */
	if (mode & MODE_MON) {
a355 1
		 * Link it to the controller only in record-only mode
d362 1
a362 1
		 * Attack to the mixer
a365 4
	} else {
		dev_submon = NULL;
		if (APROC_OK(dev_mix))
			dev_mix->u.mix.mon = NULL;
a366 1

d368 8
a375 6
	if (debug_level >= 2) {
		dbg_puts("device block size is ");
		dbg_putu(dev_round);
		dbg_puts(" frames, using ");
		dbg_putu(dev_bufsz / dev_round);
		dbg_puts(" blocks\n");
d387 1
a387 1
dev_done(void)
d413 1
a413 1
		dbg_puts("closing audio device\n");
d415 1
d429 4
d510 56
a565 3
	for (;;) {
		if (!file_poll())
			break;
d569 6
d585 1
a585 1
		dbg_puts("starting audio device\n");
d587 1
d612 1
d628 79
a706 1
		dbg_puts("audio device stopped\n");
d708 26
a832 1
		dbg_puts(" ");
d834 1
d840 1
a931 1

a1068 6

	/*
	 * Start device if not already started
	 */
	if (dev_pstate == DEV_INIT)
		dev_pstate = DEV_START;
d1153 5
@


1.49
log
@rename ibuflist/obuflist -> ins/outs to cut long lines
from Thomas Pfaff, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.48 2010/04/21 06:13:07 ratchov Exp $	*/
d130 1
a130 1
	dev_mix = mix_new("mix", dev_bufsz, 1, NULL);
d132 1
a132 1
	dev_sub = sub_new("sub", dev_bufsz, 1, NULL);
d227 1
a227 2
		dev_sub = sub_new("rec", dev_bufsz, dev_round,
		    dopar ? NULL : dev_midi);
d229 2
d264 1
a264 1
		dev_mix = mix_new("play", dev_bufsz, dev_round, dev_midi);
d266 1
d286 1
a286 1
		dev_submon = sub_new("mon", dev_bufsz, dev_round, NULL);
d323 20
d358 2
a359 1
		dev_mix->flags |= APROC_QUIT;
@


1.48
log
@adds the necessary bits to join channels (ex stereo->mono) or
expand channels (ex mono->stereo).  It's switched on/off with
the ``-j'' option, (default is "on").
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.47 2010/04/17 09:16:57 ratchov Exp $	*/
d368 1
a368 1
		if (LIST_EMPTY(&dev_midi->ibuflist))
d499 1
a499 1
			ibuf = LIST_FIRST(&ibuf->rproc->obuflist);
d519 1
a519 1
			obuf = LIST_FIRST(&obuf->wproc->ibuflist);
d539 1
a539 1
			obuf = LIST_FIRST(&obuf->wproc->ibuflist);
d615 1
a615 1
		pbuf = LIST_FIRST(&dev_mix->obuflist);
d621 1
a621 1
		rbuf = LIST_FIRST(&dev_sub->ibuflist);
d673 1
a673 1
		pbuf = LIST_FIRST(&dev_mix->obuflist);
d717 1
a717 1
		rbuf = LIST_FIRST(&dev_sub->ibuflist);
d759 1
a759 1
		rbuf = LIST_FIRST(&dev_submon->ibuflist);
d847 1
a847 1
		if (!LIST_EMPTY(&dev_mix->ibuflist)) {
d852 1
a852 1
		buf = LIST_FIRST(&dev_mix->obuflist);
d855 1
a855 1
			buf = LIST_FIRST(&buf->rproc->obuflist);
d861 1
a861 1
		if (!LIST_EMPTY(&dev_sub->obuflist)) {
d866 1
a866 1
		buf = LIST_FIRST(&dev_sub->ibuflist);
d869 1
a869 1
			buf = LIST_FIRST(&buf->wproc->ibuflist);
d876 1
a876 1
		if (!LIST_EMPTY(&dev_submon->obuflist)) {
d881 1
a881 1
		buf = LIST_FIRST(&dev_submon->ibuflist);
d884 1
a884 1
			buf = LIST_FIRST(&buf->wproc->ibuflist);
d900 1
a900 1
		if (!LIST_EMPTY(&dev_mix->ibuflist)) {
@


1.47
log
@Allow the mixer to handle inputs with channel ranges outside
the device channel range. This makes the channel mapping code
no longer usefuli, so remove it. No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.46 2010/04/06 20:07:01 ratchov Exp $	*/
d653 2
a654 2
    struct abuf *ibuf, struct aparams *sipar,
    struct abuf *obuf, struct aparams *sopar,
d660 1
a660 1
	unsigned round, nblk;
d670 1
d676 1
d688 7
d703 7
d720 1
d732 7
d747 7
d762 1
d774 7
d786 7
@


1.46
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.45 2010/04/03 17:59:17 ratchov Exp $	*/
a685 8
		if (!aparams_subset(&ipar, &dev_opar)) {
			conv = cmap_new(name, &ipar, &dev_opar);
			ipar.cmin = dev_opar.cmin;
			ipar.cmax = dev_opar.cmax;
			aproc_setin(conv, ibuf);
			ibuf = abuf_new(nblk * round, &ipar);
			aproc_setout(conv, ibuf);
		}
a714 8
		if (!aparams_subset(&opar, &dev_ipar)) {
			conv = cmap_new(name, &dev_ipar, &opar);
			opar.cmin = dev_ipar.cmin;
			opar.cmax = dev_ipar.cmax;
			aproc_setout(conv, obuf);
			obuf = abuf_new(nblk * round, &opar);
			aproc_setin(conv, obuf);
		}
a737 8
			aproc_setout(conv, obuf);
			obuf = abuf_new(nblk * round, &opar);
			aproc_setin(conv, obuf);
		}
		if (!aparams_subset(&opar, &dev_opar)) {
			conv = cmap_new(name, &dev_opar, &opar);
			opar.cmin = dev_opar.cmin;
			opar.cmax = dev_opar.cmax;
@


1.45
log
@backout last change, committed by mistake, sorry...
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.43 2010/01/16 23:18:31 ratchov Exp $	*/
d30 1
d35 1
d38 1
a38 1
struct aproc *dev_mix, *dev_sub, *dev_rec, *dev_play;
d106 8
d125 3
d130 1
a130 1
	dev_mix = mix_new("mix", dev_bufsz, NULL);
d132 1
a132 1
	dev_sub = sub_new("sub", dev_bufsz, NULL);
d156 1
a156 1
dev_init(char *devpath,
a162 1
	unsigned nfr, ibufsz, obufsz;
d172 1
a172 2
	dev_bufsz = (bufsz + 3) / 4 + (dev_round - 1);
	dev_bufsz -= dev_bufsz % dev_round;
d174 2
a175 1
	    dipar, dopar, &dev_bufsz, &dev_round);
d178 1
a178 1
	if (dipar) {
d188 1
a188 1
	if (dopar) {
a197 13
	ibufsz = obufsz = dev_bufsz;
	bufsz = (bufsz > dev_bufsz) ? bufsz - dev_bufsz : 0;

	/*
	 * Use 1/8 of the buffer for the mixer/converters.  Since we
	 * already consumed 1/4 for the device, bufsz represents the
	 * remaining 3/4. So 1/8 is 1/6 of 3/4.
	 */
	nfr = (bufsz + 5) / 6;
	nfr += dev_round - 1;
	nfr -= nfr % dev_round;
	if (nfr == 0)
		nfr = dev_round;
d202 1
a202 1
	if (dipar) {
d207 1
a207 1
		dev_rec = rfile_new(f);
d209 1
a209 1
		buf = abuf_new(nfr, dipar);
a210 1
		ibufsz += nfr;
d218 1
a218 1
			buf = abuf_new(nfr, &ipar);
a219 1
			ibufsz += nfr;
d227 2
a228 1
		dev_sub = sub_new("rec", ibufsz, dopar ? NULL : dev_midi);
d239 1
a239 1
	if (dopar) {
d244 1
a244 1
		dev_play = wfile_new(f);
d246 1
a246 1
		buf = abuf_new(nfr, dopar);
a247 1
		obufsz += nfr;
d255 1
a255 1
			buf = abuf_new(nfr, &opar);
a256 1
			obufsz += nfr;
d263 1
a263 1
		dev_mix = mix_new("play", obufsz, dev_midi);
d270 29
a298 1
	dev_bufsz = (dopar) ? obufsz : ibufsz;
d308 1
a308 1
	dev_start();
d337 5
d350 1
a350 1
	} else if (dev_sub) {
d359 2
a360 1
			    aproc_depend(dev_sub, f->rproc)) {
d380 1
a380 2
		dev_mix->refs--;
		if (dev_mix->flags & APROC_ZOMB)
d385 1
a385 2
		dev_play->refs--;
		if (dev_play->flags & APROC_ZOMB)
d390 1
a390 2
		dev_sub->refs--;
		if (dev_sub->flags & APROC_ZOMB)
d395 1
a395 2
		dev_rec->refs--;
		if (dev_rec->flags & APROC_ZOMB)
d399 10
d410 1
a410 2
		dev_midi->refs--;
		if (dev_midi->flags & APROC_ZOMB)
d428 5
a432 1
	if (dev_mix)
d434 1
a434 1
	if (dev_sub)
d436 3
a438 1
	if (dev_play && dev_play->u.io.file) {
d441 1
a441 1
	} else if (dev_rec && dev_rec->u.io.file) {
d448 2
a449 1
 * Pause the device.
d456 1
a456 1
	if (dev_play && dev_play->u.io.file) {
d459 1
a459 1
	} else if (dev_rec && dev_rec->u.io.file) {
d463 1
a463 1
	if (dev_mix)
d465 1
a465 1
	if (dev_sub)
d467 6
d479 1
a479 1
dev_getep(struct abuf **sibuf, struct abuf **sobuf)
d483 3
a485 1
	if (sibuf && *sibuf) {
d503 3
a505 1
	if (sobuf && *sobuf) {
d523 20
d551 1
a551 1
dev_sync(struct abuf *ibuf, struct abuf *obuf)
a552 1
	struct abuf *pbuf, *rbuf;
d555 1
a555 1
	if (!dev_mix || !dev_sub)
a556 9
	pbuf = LIST_FIRST(&dev_mix->obuflist);
	if (!pbuf)
		return;
	rbuf = LIST_FIRST(&dev_sub->ibuflist);
	if (!rbuf)
		return;
	if (!dev_getep(&ibuf, &obuf))
		return;

d562 6
a567 4
	delta =
	    rbuf->bpf * (pbuf->abspos + pbuf->used) -
	    pbuf->bpf *  rbuf->abspos;
	delta /= pbuf->bpf * rbuf->bpf;
d572 11
a582 10
		dbg_puts(": ");
		abuf_dbg(pbuf);
		dbg_puts(" abspos = ");
		dbg_putu(pbuf->abspos);
		dbg_puts(" used = ");
		dbg_putu(pbuf->used);
		dbg_puts(" <---> ");
		abuf_dbg(rbuf);
		dbg_puts(" abspos = ");
		dbg_putu(rbuf->abspos);
d591 2
a592 4
		if (obuf) {
			obuf->drop += delta * obuf->bpf;
			abuf_ipos(obuf, -delta);
		}
d598 2
a599 4
		 if (ibuf) {
			ibuf->silence += -delta * ibuf->bpf;
			abuf_opos(ibuf, delta);
		}
d614 1
a614 1
	if (dev_mix) {
d620 1
a620 1
	if (dev_sub) {
d626 2
a627 5
	if (dev_mix && dev_sub) {
		delta =
		    rbuf->bpf * (pbuf->abspos + pbuf->used) -
		    pbuf->bpf *  rbuf->abspos;
		delta /= pbuf->bpf * rbuf->bpf;
d642 1
a642 1
	return dev_mix ? plat : rlat;
d652 4
a655 3
dev_attach(char *name,
    struct abuf *ibuf, struct aparams *sipar, unsigned underrun,
    struct abuf *obuf, struct aparams *sopar, unsigned overrun, int vol)
d662 9
a670 1
	if (ibuf) {
d703 1
a703 3
		if (dev_mix->u.mix.lat > 0)
			abuf_opos(ibuf, -dev_mix->u.mix.lat);
		ibuf->r.mix.xrun = underrun;
d707 1
a707 1
	if (obuf) {
d740 36
a775 3
		if (dev_sub->u.sub.lat > 0)
			abuf_ipos(obuf, -dev_sub->u.sub.lat);
		obuf->w.sub.xrun = overrun;
d781 1
a781 1
	if (ibuf && obuf) {
d785 7
a791 1
	dev_sync(ibuf, obuf);
d808 1
a808 1
	if (!dev_getep(&ibuf, NULL)) {
d823 1
a823 1
	if (dev_mix) {
d837 1
a837 1
	if (dev_sub) {
d851 16
d876 1
a876 1
	if (dev_mix) {
@


1.44
log
@doc fixes from jmc
@
text
@a29 1
#include "opt.h"
a33 1
unsigned dev_pstate;
d36 1
a36 1
struct aproc *dev_mix, *dev_sub, *dev_rec, *dev_play, *dev_submon, *dev_mon;
a103 8
	/*
	 * in principle we don't need control, but the start-stop mechanism
	 * depend on it and it's simpler to reuse this mechanism rather than
	 * dealing with lots of special cases
	 */
	dev_midi = ctl_new("ctl");
	dev_midi->refs++;

a114 3
	dev_mon = NULL;
	dev_submon = NULL;
	dev_pstate = DEV_INIT;
d117 1
a117 1
	dev_mix = mix_new("mix", dev_bufsz, 1, NULL);
d119 1
a119 1
	dev_sub = sub_new("sub", dev_bufsz, 1, NULL);
d143 1
a143 1
dev_init(char *devpath, unsigned mode,
d150 1
d160 2
a161 1
	dev_bufsz = bufsz;
d163 1
a163 2
	    mode & (MODE_PLAY | MODE_REC), dipar, dopar,
	    &dev_bufsz, &dev_round);
d166 1
a166 1
	if (mode & MODE_REC) {
d176 1
a176 1
	if (mode & MODE_PLAY) {
d186 13
d203 1
a203 1
	if (mode & MODE_REC) {
d208 1
a208 1
		dev_rec = rsio_new(f);
d210 1
a210 1
		buf = abuf_new(dev_bufsz, dipar);
d212 1
d220 1
a220 1
			buf = abuf_new(dev_round, &ipar);
d222 1
d230 1
a230 2
		dev_sub = sub_new("rec", dev_bufsz, dev_round,
		    dopar ? NULL : dev_midi);
d241 1
a241 1
	if (mode & MODE_PLAY) {
d246 1
a246 1
		dev_play = wsio_new(f);
d248 1
a248 1
		buf = abuf_new(dev_bufsz, dopar);
d250 1
d258 1
a258 1
			buf = abuf_new(dev_round, &opar);
d260 1
d267 1
a267 1
		dev_mix = mix_new("play", dev_bufsz, dev_round, dev_midi);
d274 1
a274 29

	/*
	 * Create monitoring chain
	 */
	if (mode & MODE_MON) {
		dev_mon = mon_new("mon", dev_bufsz);
		dev_mon->refs++;
		buf = abuf_new(dev_bufsz, &dev_opar);
		aproc_setout(dev_mon, buf);

		/*
		 * Append a "sub" to which clients will connect.
		 * Link it to the controller only in record-only mode
		 */
		dev_submon = sub_new("mon", dev_bufsz, dev_round, NULL);
		dev_submon->refs++;
		aproc_setin(dev_submon, buf);

		/*
		 * Attack to the mixer
		 */
		dev_mix->u.mix.mon = dev_mon;
		dev_mon->refs++;
	} else {
		dev_submon = NULL;
		if (APROC_OK(dev_mix))
			dev_mix->u.mix.mon = NULL;
	}

d284 1
a284 1
	dev_pstate = DEV_INIT;
a312 5
		if (APROC_OK(dev_mix->u.mix.mon)) {
			dev_mix->u.mix.mon->refs--;
			aproc_del(dev_mix->u.mix.mon);
			dev_mix->u.mix.mon = NULL;
		}
d321 1
a321 1
	} else if (dev_sub || dev_submon) {
d330 1
a330 2
			    (aproc_depend(dev_sub, f->rproc) ||
			     aproc_depend(dev_submon, f->rproc))) {
d350 2
a351 1
		if (--dev_mix->refs == 0 && (dev_mix->flags & APROC_ZOMB))
d356 2
a357 1
		if (--dev_play->refs == 0 && (dev_play->flags & APROC_ZOMB))
d362 2
a363 1
		if (--dev_sub->refs == 0 && (dev_sub->flags & APROC_ZOMB))
d368 2
a369 1
		if (--dev_rec->refs == 0 && (dev_rec->flags & APROC_ZOMB))
a372 10
	if (dev_submon) {
		if (--dev_submon->refs == 0 && (dev_submon->flags & APROC_ZOMB))
			aproc_del(dev_submon);
		dev_submon = NULL;
	}
	if (dev_mon) {
		if (--dev_mon->refs == 0 && (dev_mon->flags & APROC_ZOMB))
			aproc_del(dev_mon);
		dev_mon = NULL;
	}
d374 2
a375 1
		if (--dev_midi->refs == 0 && (dev_midi->flags & APROC_ZOMB))
d393 1
a393 5
#ifdef DEBUG
	if (debug_level >= 2)
		dbg_puts("starting audio device\n");
#endif
	if (APROC_OK(dev_mix))
d395 1
a395 1
	if (APROC_OK(dev_sub))
d397 1
a397 3
	if (APROC_OK(dev_submon))
		dev_submon->flags |= APROC_DROP;
	if (APROC_OK(dev_play) && dev_play->u.io.file) {
d400 1
a400 1
	} else if (APROC_OK(dev_rec) && dev_rec->u.io.file) {
d407 1
a407 2
 * Pause the device. This may trigger context switches,
 * so it shouldn't be called from aproc methods
d414 1
a414 1
	if (APROC_OK(dev_play) && dev_play->u.io.file) {
d417 1
a417 1
	} else if (APROC_OK(dev_rec) && dev_rec->u.io.file) {
d421 1
a421 1
	if (APROC_OK(dev_mix))
d423 1
a423 1
	if (APROC_OK(dev_sub))
a424 6
	if (APROC_OK(dev_submon))
		dev_submon->flags &= ~APROC_DROP;
#ifdef DEBUG
	if (debug_level >= 2)
		dbg_puts("audio device stopped\n");
#endif
d431 1
a431 1
dev_getep(unsigned mode, struct abuf **sibuf, struct abuf **sobuf)
d435 1
a435 3
	if (mode & MODE_PLAY) {
		if (!APROC_OK(dev_mix))
			return 0;
d453 1
a453 3
	if (mode & MODE_REC) {
		if (!APROC_OK(dev_sub))
			return 0;
a470 20
	if (mode & MODE_MON) {
		if (!APROC_OK(dev_submon))
			return 0;
		obuf = *sobuf;
		for (;;) {
			if (!obuf || !obuf->wproc) {
#ifdef DEBUG
				if (debug_level >= 3) {
					abuf_dbg(*sobuf);
					dbg_puts(": not connected to device\n");
				}
#endif
				return 0;
			}
			if (obuf->wproc == dev_submon)
				break;
			obuf = LIST_FIRST(&obuf->wproc->ibuflist);
		}
		*sobuf = obuf;
	}
d479 1
a479 1
dev_sync(unsigned mode, struct abuf *ibuf, struct abuf *obuf)
d481 1
d484 1
a484 1
	if (!dev_getep(mode, &ibuf, &obuf))
d486 9
d500 4
a503 6
	if (APROC_OK(dev_mix) && APROC_OK(dev_sub)) {
		delta = dev_mix->u.mix.abspos - dev_sub->u.sub.abspos;
	} else if (APROC_OK(dev_mix)) {
		delta = dev_mix->u.mix.lat;
	} else
		delta = 0;
d508 10
a517 11
		dbg_puts(" ");
		if (APROC_OK(dev_mix)) {
			aproc_dbg(dev_mix);
			dbg_puts(": abspos = ");
			dbg_putu(dev_mix->u.mix.abspos);
		}
		if (APROC_OK(dev_sub)) {
			aproc_dbg(dev_sub);
			dbg_puts(": abspos = ");
			dbg_putu(dev_sub->u.sub.abspos);
		}
d526 4
a529 2
		if (mode & MODE_RECMASK)
			sub_silence(obuf, -delta);
d535 4
a538 2
		 if (mode & MODE_PLAY)
		 	mix_drop(ibuf, delta);
d553 1
a553 1
	if (APROC_OK(dev_mix)) {
d559 1
a559 1
	if (APROC_OK(dev_sub)) {
d565 5
a569 2
	if (APROC_OK(dev_mix) && APROC_OK(dev_sub)) {
		delta = dev_mix->u.mix.abspos - dev_sub->u.sub.abspos;
d584 1
a584 1
	return APROC_OK(dev_mix) ? plat : rlat;
d594 3
a596 4
dev_attach(char *name, unsigned mode,
    struct abuf *ibuf, struct aparams *sipar,
    struct abuf *obuf, struct aparams *sopar,
    unsigned xrun, int vol)
d603 1
a603 9
#ifdef DEBUG
	if ((!APROC_OK(dev_mix)    && (mode & MODE_PLAY)) ||
	    (!APROC_OK(dev_sub)    && (mode & MODE_REC)) ||
	    (!APROC_OK(dev_submon) && (mode & MODE_MON))) {
	    	dbg_puts("mode beyond device mode, not attaching\n");
		return;
	}
#endif
	if (mode & MODE_PLAY) {
d636 3
a638 1
		ibuf->r.mix.xrun = xrun;
d642 1
a642 1
	if (mode & MODE_REC) {
d675 3
a677 36
		obuf->w.sub.xrun = xrun;
	}
	if (mode & MODE_MON) {
		opar = *sopar;
		rbuf = LIST_FIRST(&dev_submon->ibuflist);
		round = dev_roundof(opar.rate);
		nblk = (dev_bufsz / dev_round + 3) / 4;
		if (!aparams_eqenc(&opar, &dev_opar)) {
			conv = enc_new(name, &opar);
			opar.bps = dev_opar.bps;
			opar.bits = dev_opar.bits;
			opar.sig = dev_opar.sig;
			opar.le = dev_opar.le;
			opar.msb = dev_opar.msb;
			aproc_setout(conv, obuf);
			obuf = abuf_new(nblk * round, &opar);
			aproc_setin(conv, obuf);
		}
		if (!aparams_subset(&opar, &dev_opar)) {
			conv = cmap_new(name, &dev_opar, &opar);
			opar.cmin = dev_opar.cmin;
			opar.cmax = dev_opar.cmax;
			aproc_setout(conv, obuf);
			obuf = abuf_new(nblk * round, &opar);
			aproc_setin(conv, obuf);
		}
		if (!aparams_eqrate(&opar, &dev_opar)) {
			conv = resamp_new(name, dev_round, round);
			opar.rate = dev_opar.rate;
			round = dev_round;
			aproc_setout(conv, obuf);
			obuf = abuf_new(nblk * round, &opar);
			aproc_setin(conv, obuf);
		}
		aproc_setout(dev_submon, obuf);
		obuf->w.sub.xrun = xrun;
d683 1
a683 1
	if ((mode & MODE_PLAY) && (mode & MODE_RECMASK)) {
d687 1
a687 7
	dev_sync(mode, ibuf, obuf);

	/*
	 * Start device if not already started
	 */
	if (dev_pstate == DEV_INIT)
		dev_pstate = DEV_START;
d704 1
a704 1
	if (!dev_getep(MODE_PLAY, &ibuf, NULL)) {
d719 1
a719 1
	if (APROC_OK(dev_mix)) {
d733 1
a733 1
	if (APROC_OK(dev_sub)) {
a746 16
	if (APROC_OK(dev_submon)) {
#ifdef DEBUG
		dbg_puts("clearing monitor\n");
		if (!LIST_EMPTY(&dev_submon->obuflist)) {
			dbg_puts("monitoring end not idle, can't clear device\n");
			dbg_panic();
		}
#endif
		buf = LIST_FIRST(&dev_submon->ibuflist);
		while (buf) {
			abuf_clear(buf);
			buf = LIST_FIRST(&buf->wproc->ibuflist);
		}
		sub_clear(dev_submon);
		mon_clear(dev_mon);
	}
d756 1
a756 1
	if (APROC_OK(dev_mix)) {
@


1.43
log
@when closing the device, delete its MIDI end, if it has no writers.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.42 2010/01/13 10:02:52 ratchov Exp $	*/
d30 1
d35 1
d38 1
a38 1
struct aproc *dev_mix, *dev_sub, *dev_rec, *dev_play;
d106 8
d125 3
d130 1
a130 1
	dev_mix = mix_new("mix", dev_bufsz, NULL);
d132 1
a132 1
	dev_sub = sub_new("sub", dev_bufsz, NULL);
d156 1
a156 1
dev_init(char *devpath,
a162 1
	unsigned nfr, ibufsz, obufsz;
d172 1
a172 2
	dev_bufsz = (bufsz + 3) / 4 + (dev_round - 1);
	dev_bufsz -= dev_bufsz % dev_round;
d174 2
a175 1
	    dipar, dopar, &dev_bufsz, &dev_round);
d178 1
a178 1
	if (dipar) {
d188 1
a188 1
	if (dopar) {
a197 13
	ibufsz = obufsz = dev_bufsz;
	bufsz = (bufsz > dev_bufsz) ? bufsz - dev_bufsz : 0;

	/*
	 * Use 1/8 of the buffer for the mixer/converters.  Since we
	 * already consumed 1/4 for the device, bufsz represents the
	 * remaining 3/4. So 1/8 is 1/6 of 3/4.
	 */
	nfr = (bufsz + 5) / 6;
	nfr += dev_round - 1;
	nfr -= nfr % dev_round;
	if (nfr == 0)
		nfr = dev_round;
d202 1
a202 1
	if (dipar) {
d207 1
a207 1
		dev_rec = rfile_new(f);
d209 1
a209 1
		buf = abuf_new(nfr, dipar);
a210 1
		ibufsz += nfr;
d218 1
a218 1
			buf = abuf_new(nfr, &ipar);
a219 1
			ibufsz += nfr;
d227 2
a228 1
		dev_sub = sub_new("rec", ibufsz, dopar ? NULL : dev_midi);
d239 1
a239 1
	if (dopar) {
d244 1
a244 1
		dev_play = wfile_new(f);
d246 1
a246 1
		buf = abuf_new(nfr, dopar);
a247 1
		obufsz += nfr;
d255 1
a255 1
			buf = abuf_new(nfr, &opar);
a256 1
			obufsz += nfr;
d263 1
a263 1
		dev_mix = mix_new("play", obufsz, dev_midi);
d270 29
a298 1
	dev_bufsz = (dopar) ? obufsz : ibufsz;
d308 1
a308 1
	dev_start();
d337 5
d350 1
a350 1
	} else if (dev_sub) {
d359 2
a360 1
			    aproc_depend(dev_sub, f->rproc)) {
d380 1
a380 2
		dev_mix->refs--;
		if (dev_mix->flags & APROC_ZOMB)
d385 1
a385 2
		dev_play->refs--;
		if (dev_play->flags & APROC_ZOMB)
d390 1
a390 2
		dev_sub->refs--;
		if (dev_sub->flags & APROC_ZOMB)
d395 1
a395 2
		dev_rec->refs--;
		if (dev_rec->flags & APROC_ZOMB)
d399 10
d410 1
a410 2
		dev_midi->refs--;
		if (dev_midi->flags & APROC_ZOMB)
d428 5
a432 1
	if (dev_mix)
d434 1
a434 1
	if (dev_sub)
d436 3
a438 1
	if (dev_play && dev_play->u.io.file) {
d441 1
a441 1
	} else if (dev_rec && dev_rec->u.io.file) {
d448 2
a449 1
 * Pause the device.
d456 1
a456 1
	if (dev_play && dev_play->u.io.file) {
d459 1
a459 1
	} else if (dev_rec && dev_rec->u.io.file) {
d463 1
a463 1
	if (dev_mix)
d465 1
a465 1
	if (dev_sub)
d467 6
d479 1
a479 1
dev_getep(struct abuf **sibuf, struct abuf **sobuf)
d483 3
a485 1
	if (sibuf && *sibuf) {
d503 3
a505 1
	if (sobuf && *sobuf) {
d523 20
d551 1
a551 1
dev_sync(struct abuf *ibuf, struct abuf *obuf)
a552 1
	struct abuf *pbuf, *rbuf;
d555 1
a555 1
	if (!dev_mix || !dev_sub)
a556 9
	pbuf = LIST_FIRST(&dev_mix->obuflist);
	if (!pbuf)
		return;
	rbuf = LIST_FIRST(&dev_sub->ibuflist);
	if (!rbuf)
		return;
	if (!dev_getep(&ibuf, &obuf))
		return;

d562 6
a567 4
	delta =
	    rbuf->bpf * (pbuf->abspos + pbuf->used) -
	    pbuf->bpf *  rbuf->abspos;
	delta /= pbuf->bpf * rbuf->bpf;
d572 11
a582 10
		dbg_puts(": ");
		abuf_dbg(pbuf);
		dbg_puts(" abspos = ");
		dbg_putu(pbuf->abspos);
		dbg_puts(" used = ");
		dbg_putu(pbuf->used);
		dbg_puts(" <---> ");
		abuf_dbg(rbuf);
		dbg_puts(" abspos = ");
		dbg_putu(rbuf->abspos);
d591 2
a592 4
		if (obuf) {
			obuf->drop += delta * obuf->bpf;
			abuf_ipos(obuf, -delta);
		}
d598 2
a599 4
		 if (ibuf) {
			ibuf->silence += -delta * ibuf->bpf;
			abuf_opos(ibuf, delta);
		}
d614 1
a614 1
	if (dev_mix) {
d620 1
a620 1
	if (dev_sub) {
d626 2
a627 5
	if (dev_mix && dev_sub) {
		delta =
		    rbuf->bpf * (pbuf->abspos + pbuf->used) -
		    pbuf->bpf *  rbuf->abspos;
		delta /= pbuf->bpf * rbuf->bpf;
d642 1
a642 1
	return dev_mix ? plat : rlat;
d652 4
a655 3
dev_attach(char *name,
    struct abuf *ibuf, struct aparams *sipar, unsigned underrun,
    struct abuf *obuf, struct aparams *sopar, unsigned overrun, int vol)
d662 9
a670 1
	if (ibuf) {
d703 1
a703 3
		if (dev_mix->u.mix.lat > 0)
			abuf_opos(ibuf, -dev_mix->u.mix.lat);
		ibuf->r.mix.xrun = underrun;
d707 1
a707 1
	if (obuf) {
d740 36
a775 3
		if (dev_sub->u.sub.lat > 0)
			abuf_ipos(obuf, -dev_sub->u.sub.lat);
		obuf->w.sub.xrun = overrun;
d781 1
a781 1
	if (ibuf && obuf) {
d785 7
a791 1
	dev_sync(ibuf, obuf);
d808 1
a808 1
	if (!dev_getep(&ibuf, NULL)) {
d823 1
a823 1
	if (dev_mix) {
d837 1
a837 1
	if (dev_sub) {
d851 16
d876 1
a876 1
	if (dev_mix) {
@


1.42
log
@Rename s/safile/siofile/g, missed when libsa was renamed to
libsndio. Fixes crashes in full-duplex mode on vax and hp300.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.41 2010/01/12 21:39:39 ratchov Exp $	*/
d338 2
@


1.41
log
@When attaching a new stream, if the "extra" latency is zero, then
don't trigger a zero-length clock tick. Fixes duplicate start
ticks seen by full-duplex clients.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.40 2010/01/11 13:06:32 ratchov Exp $	*/
d28 1
a28 1
#include "safile.h"
d162 1
a162 1
	f = (struct file *)safile_new(&safile_ops, devpath,
@


1.40
log
@When resuming from suspend, prime play buffers with silence,
otherwise the client would underrun by more than its own buffer
size, which currently is not allowed (causes the client to
deadlock).

Set the minimum client buffer size to two blocks. Single block
buffers don't work properly yet.

with help from jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.39 2010/01/10 21:47:41 ratchov Exp $	*/
d634 2
a635 1
		abuf_opos(ibuf, -dev_mix->u.mix.lat);
d673 2
a674 1
		abuf_ipos(obuf, -dev_sub->u.sub.lat);
@


1.39
log
@Add traces to help tracking subtle timing bugs often causing
underuns and overruns; such bugs are hard to debug with ktrace
or a debugger. They are also handy to debug or monitor code
using aucat.

To enable traces, compile aucat with ``make DEBUG=-DDEBUG'' and
use the -d option multiple times.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.38 2010/01/05 10:18:12 ratchov Exp $	*/
d230 1
a230 1
		dev_sub = sub_new("rec", nfr, dopar ? NULL : dev_midi);
d267 1
a267 1
		dev_mix = mix_new("play", nfr, dev_midi);
d742 18
@


1.38
log
@Make the way .wav files are handled closer to the way sockets are
handled, which is conceptually simpler. No behaviour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.37 2009/11/08 00:08:41 ratchov Exp $	*/
d30 3
d167 7
d177 7
d275 9
d297 4
d437 6
d455 6
d502 17
d572 9
d692 8
d716 6
d730 6
@


1.37
log
@use the same algorithm to attach play-only, record-only and
full-duplex streams. Fixes, streams with different modes not
starting simultaneously.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.36 2009/11/03 21:31:37 ratchov Exp $	*/
d27 1
d47 27
d191 1
a191 1
		dev_rec = rpipe_new(f);
d229 1
a229 1
		dev_play = wpipe_new(f);
@


1.36
log
@Allow any program using aucat to act as MMC slave and MTC master
transparently.  Multiple audio applications can be started
synchronously from external software/hardware supporting the
standard Start/Stop/Relocate messages. The server clock is exposed
through MTC, allowing non-audio software/hardware to be
synchronized to audio applications.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.35 2009/10/27 22:24:27 ratchov Exp $	*/
d375 1
a375 1
	if (sibuf) {
d387 1
a387 1
	if (sobuf) {
d434 1
a434 1
		 * If the play chain is ahead (most cases) drop some of
d437 4
a440 2
		obuf->drop += delta * obuf->bpf;
		abuf_ipos(obuf, -delta);
d443 1
a443 1
		 * If record chain is ahead (should never happen,
d446 4
a449 2
		ibuf->silence += -delta * ibuf->bpf;
		abuf_opos(ibuf, delta);
a585 1
		dev_sync(ibuf, obuf);
d587 1
@


1.35
log
@set the THRU_AUTOQUIT flag only for ``thru'' devices
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.34 2009/10/10 12:43:09 ratchov Exp $	*/
d86 1
a86 1
	dev_mix = mix_new("mix", dev_bufsz);
d88 1
a88 1
	dev_sub = sub_new("sub", dev_bufsz);
d93 2
a94 2
	dev_mix->u.mix.flags |= MIX_AUTOQUIT;
	dev_sub->u.sub.flags |= SUB_AUTOQUIT;
d113 1
a113 1
    struct aparams *dipar, struct aparams *dopar, unsigned bufsz)
d121 3
d128 3
a130 2
	dev_bufsz = (bufsz + 3) / 4;
	dev_round = (bufsz + 3) / 4;
d183 1
d185 1
a185 1
		dev_sub = sub_new("rec", nfr);
d222 1
a222 1
		dev_mix = mix_new("play", nfr);
a229 2
	dev_midi = ctl_new("ctl");
	dev_midi->refs++;
a242 12
	if (dev_midi) {
		if (!dev_sub && !dev_mix)
			dev_midi->u.thru.flags |= THRU_AUTOQUIT;
 	restart_midi:
		LIST_FOREACH(f, &file_list, entry) {
			if (f->rproc &&
			    aproc_depend(dev_midi, f->rproc)) {
				file_eof(f);
				goto restart_midi;
			}
		}
	}
d254 1
a254 1
		dev_mix->u.mix.flags |= MIX_AUTOQUIT;
d278 11
d291 1
a291 1
		if (dev_mix->zomb)
d297 1
a297 1
		if (dev_play->zomb)
d303 1
a303 1
		if (dev_sub->zomb)
d309 1
a309 1
		if (dev_rec->zomb)
d315 1
a315 1
		if (dev_midi->zomb)
d334 1
a334 1
		dev_mix->u.mix.flags |= MIX_DROP;
d336 1
a336 1
		dev_sub->u.sub.flags |= SUB_DROP;
d362 1
a362 1
		dev_mix->u.mix.flags &= ~MIX_DROP;
d364 1
a364 1
		dev_sub->u.sub.flags &= ~SUB_DROP;
d447 36
@


1.34
log
@make dev_done() common to audio and MIDI, and drop dev_thrudone()
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.33 2009/10/10 11:58:41 ratchov Exp $	*/
d241 2
a242 1
		dev_midi->u.mix.flags |= THRU_AUTOQUIT;
@


1.33
log
@use dev_done() for loopback devices too and remove dev_loopdone()
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.32 2009/10/10 09:54:06 ratchov Exp $	*/
a45 26
 * Terminate the MIDI thru box
 */
void
dev_thrudone(void)
{
	struct file *f;

 restart:
	LIST_FOREACH(f, &file_list, entry) {
		if (f->rproc && aproc_depend(dev_midi, f->rproc)) {
			file_eof(f);
			goto restart;
		}
	}
	while (!LIST_EMPTY(&dev_midi->ibuflist)) {
		if (!file_poll())
			break;
	}
	dev_midi->refs--;
	aproc_del(dev_midi);
	dev_midi = NULL;
	while (file_poll())
		; /* nothing */
}

/*
d241 9
a249 7
		/*
		 * We don't have the necessary bits to drain
		 * control MIDI device, so just kill it
		 */
		dev_midi->refs--;
		aproc_del(dev_midi);
		dev_midi = NULL;
d309 6
@


1.32
log
@We don't need independent file reader and writer anymore. So,
destroy reader when writer terminates and destroy writer when
reader terminates. This simplifies a lot the way we drain
audio devices and will help simplifying other parts.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.31 2009/10/09 16:49:48 ratchov Exp $	*/
a123 26
}

/*
 * Same as dev_done(), but destroy a loopback device.
 */
void
dev_loopdone(void)
{
	struct file *f;

	dev_sub->refs--;
	dev_sub = NULL;
	dev_mix->refs--;
	dev_mix = NULL;
	/*
	 * Generate EOF on all inputs.
	 */
 restart:
	LIST_FOREACH(f, &file_list, entry) {
		if (f->rproc != NULL) {
			file_eof(f);
			goto restart;
		}
	}
	while (file_poll())
		; /* nothing */
@


1.31
log
@Make abuf structure smaller:
 - put aproc-specific parameters into unions since they are never
   used together
 - remove constant ``data'' pointer always pointing the end of the
   abuf structure
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.30 2009/09/27 11:51:20 ratchov Exp $	*/
d292 9
a300 4
	dev_midi->refs--;
	aproc_del(dev_midi);
	dev_midi = NULL;

a301 3
		dev_mix->refs--;
		dev_mix->u.mix.flags |= MIX_AUTOQUIT;
		dev_mix = NULL;
d303 4
a306 4
		 * Generate EOF on all inputs (but not the device), and
		 * put the mixer in ``autoquit'' state, so once buffers
		 * are drained the mixer will terminate and shutdown the
		 * write-end of the device.
d312 2
a313 1
	restart:
d315 2
a316 1
			if (f->rproc != NULL && f->rproc != dev_rec) {
d318 1
a318 1
				goto restart;
d321 1
a321 1

d323 10
a332 6
		 * Wait for play chain to terminate.
		 */
		if (dev_play) {
			while (!LIST_EMPTY(&dev_play->ibuflist)) {
				if (!file_poll())
					break;
d334 11
a344 1
			dev_play->refs--;
d346 1
a346 2
			dev_play = NULL;
		}
d350 2
a351 1
		dev_sub->u.sub.flags |= SUB_AUTOQUIT;
d353 4
a356 16
		/*
		 * Same as above, but for the record chain: generate eof
		 * on the read-end of the device and wait record buffers
		 * to disappear.  We must stop the device first, because
		 * play-end will underrun (and xrun correction code will
		 * insert silence on the record-end of the device).
		 */
		if (dev_rec) {
			dev_stop();
			if (dev_rec->u.io.file)
				file_eof(dev_rec->u.io.file);
			while (!LIST_EMPTY(&dev_rec->obuflist)) {
				if (!file_poll())
					break;
			}
			dev_rec->refs--;
d358 5
a362 2
			dev_rec = NULL;
		}
@


1.30
log
@remove all debug traces
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.29 2009/08/21 16:48:03 ratchov Exp $	*/
d531 2
a532 2
		ibuf->xrun = underrun;
		ibuf->mixmaxweight = vol;
d569 1
a569 1
		obuf->xrun = overrun;
d591 1
a591 1
	ibuf->mixvol = vol;
@


1.29
log
@make aucat(1) expose a MIDI device to control server behaviour in
realtime.  For now only the playback volume of individual streams can be
changed/monitored. To each stream is assigned a MIDI channel; the volume
is changed/monitored using the standard controller number 7.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.28 2009/08/19 05:54:15 ratchov Exp $	*/
a133 2
	DPRINTF("dev_loopdone:\n");

a183 7
#ifdef DEBUG
		if (debug_level > 0) {
			fprintf(stderr, "dev_init: hw recording ");
			aparams_print(dipar);
			fprintf(stderr, "\n");
		}
#endif
a186 7
#ifdef DEBUG
		if (debug_level > 0) {
			fprintf(stderr, "dev_init: hw playing ");
			aparams_print(dopar);
			fprintf(stderr, "\n");
		}
#endif
d221 1
a221 1
			conv = dec_new("subin", dipar);
d232 1
a232 1
		dev_sub = sub_new("sub", nfr);
d258 1
a258 1
			conv = enc_new("mixout", dopar);
d269 1
a269 1
		dev_mix = mix_new("mix", nfr);
a276 1
	DPRINTF("dev_init: using %u fpb\n", dev_bufsz);
a291 1
	DPRINTF("dev_done: dev_mix = %p, dev_sub = %p\n", dev_mix, dev_sub);
a410 1
				DPRINTF("dev_getep: reader desappeared\n");
a422 1
				DPRINTF("dev_getep: writer desappeared\n");
a463 3
	DPRINTF("dev_sync: delta = %d, ppos = %u, pused = %u, rpos = %u\n",
	    delta, pbuf->abspos, pbuf->used, rbuf->abspos);

d478 1
a478 2
	} else
		DPRINTF("dev_sync: nothing to do\n");
a587 1
	DPRINTF("dev_setvol: %p\n", ibuf);
a588 1
		DPRINTF("dev_setvol: not connected yet\n");
a591 1
	DPRINTF("dev_setvol: %p -> %d\n", ibuf, vol);
a603 4
		if (!LIST_EMPTY(&dev_mix->ibuflist)) {
			fprintf(stderr, "dev_clear: mixer not idle\n");
			abort();
		}
a611 4
		if (!LIST_EMPTY(&dev_sub->obuflist)) {
			fprintf(stderr, "dev_suspend: demux not idle\n");
			abort();
		}
@


1.28
log
@organize midi code like audio code, no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.27 2009/07/25 10:52:18 ratchov Exp $	*/
d294 2
d310 4
@


1.27
log
@fix comments, remove no longer needed declaration, reorder includes
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.26 2009/02/06 08:26:34 ratchov Exp $	*/
d28 1
d33 54
@


1.26
log
@move error messages reported to user into main()
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.25 2009/01/23 17:38:15 ratchov Exp $	*/
d17 1
a21 1
#include "dev.h"
d24 2
a26 1
#include "conf.h"
d34 2
a35 2
 * same as dev_init(), but create a fake device that records what is
 * played
d72 1
a72 1
 * same as dev_done(), but destroy a loopback device
d86 1
a86 1
	 * generate EOF on all inputs
d106 1
a106 1
 * open the device with the given hardware parameters and create a mixer
d108 1
a108 1
 * setup
d121 2
a122 2
	 * ask for 1/4 of the buffer for the kernel ring and
	 * limit the block size to 1/4 of the requested buffer
d154 1
a154 1
	 * use 1/8 of the buffer for the mixer/converters.  Since we
d156 1
a156 1
	 * remaining 3/4. So 1/8 is 1/6 of 3/4
d165 1
a165 1
	 * create record chain
d170 1
a170 1
		 * create the read end
d179 1
a179 1
		 * append a converter, if needed
d191 1
a191 1
		 * append a "sub" to which clients will connect
d202 1
a202 1
	 * create play chain
d207 1
a207 1
		 * create the write end
d216 1
a216 1
		 * append a converter, if needed
d228 1
a228 1
		 * append a "mix" to which clients will connect
d244 2
a245 2
 * cleanly stop and drain everything and close the device
 * once both play chain and record chain are gone
d258 1
a258 1
		 * generate EOF on all inputs (but not the device), and
d261 1
a261 1
		 * write-end of the device
d265 1
a265 1
		 * after each call to file_eof()
d276 1
a276 1
		 * wait play chain to terminate
d293 1
a293 1
		 * same as above, but for the record chain: generate eof
d295 1
a295 1
		 * to desappear.  We must stop the device first, because
d297 1
a297 1
		 * insert silence on the record-end of the device)
d315 1
a315 1
 * start the (paused) device. By default it's paused
d336 1
a336 1
 * pause the device
d357 1
a357 1
 * find the end points connected to the mix/sub
d394 2
a395 2
 * sync play buffer to rec buffer (for instance when one of
 * them underruns/overruns)
d415 1
a415 1
	 * calculate delta, the number of frames the play chain is ahead
d428 2
a429 2
		 * if the play chain is ahead (most cases) drop some of
		 * the recorded input, to get both in sync
d435 2
a436 2
		 * if record chain is ahead (should never happen,
		 * right?) then insert silence to play
d445 1
a445 1
 * attach the given input and output buffers to the mixer and the
d448 1
a448 1
 * and rec
d536 1
a536 1
	 * sync play to record
d546 1
a546 1
 * change the playback volume of the fiven stream
d561 2
a562 2
 * clear buffers of the play and record chains so that when the device
 * is started, playback and record start in sync
@


1.25
log
@spacing + typo fix from Matt Jibson <matt.jibson(at)gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.24 2009/01/10 20:02:28 ratchov Exp $	*/
d109 1
a109 1
void
d128 1
a128 1
		exit(1);
d239 1
@


1.24
log
@add "loopback" mode in which input is connected to the output.
This is useful to mix, demultiplex, resample or reencode audio
files off-line.
tweak + ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.23 2009/01/06 19:27:22 ratchov Exp $	*/
d51 1
a51 1
	dev_rate  = rate;       
d54 1
a54 1
	
d118 1
a118 1
	
d213 1
a213 1
		
d417 2
a418 2
	delta = 
	    rbuf->bpf * (pbuf->abspos + pbuf->used) - 
d449 2
a450 2
dev_attach(char *name, 
    struct abuf *ibuf, struct aparams *sipar, unsigned underrun, 
d470 1
a470 1
			aproc_setin(conv, ibuf);			
d568 1
a568 1
		if (!LIST_EMPTY(&dev_mix->ibuflist)) { 
d580 1
a580 1
		if (!LIST_EMPTY(&dev_sub->obuflist)) { 
@


1.23
log
@don't use a reference to the device file. Use the corresponding aproc
structure instread.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.22 2008/12/29 17:59:08 ratchov Exp $	*/
d31 66
@


1.22
log
@make the code "more correct": add reference counters to aproc
structures so we can keep a pointer to the device. Beside some
simplifications, this allows to easily handle the situation
where the audio device desappears. No change in the behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.21 2008/12/16 22:11:12 ratchov Exp $	*/
a30 1
struct file *dev_file;
d47 1
d59 1
a59 1
	dev_file = (struct file *)safile_new(&safile_ops, devpath,
d61 1
a61 1
	if (!dev_file)
d105 1
a105 1
		dev_rec = rpipe_new(dev_file);
d142 1
a142 1
		dev_play = wpipe_new(dev_file);
d201 1
a201 1
			if (f != dev_file && f->rproc) {
d210 8
a217 3
		while (!LIST_EMPTY(&dev_play->ibuflist)) {
			if (!file_poll())
				break;
a218 3
		dev_play->refs--;
		aproc_del(dev_play);
		dev_play = NULL;
d231 11
a241 6
		dev_stop();
		if (dev_rec->u.io.file)
			file_eof(dev_rec->u.io.file);
		for (;;) {
			if (!file_poll())
				break;
a242 3
		dev_rec->refs--;
		aproc_del(dev_rec);
		dev_rec = NULL;
@


1.21
log
@when searching for an endpoint, return the correct abuf pointers.
Fixes the volume knob not working when the input chain has more
than two aprocs
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.20 2008/12/07 17:10:41 ratchov Exp $	*/
d106 1
d127 1
d143 1
d164 1
d186 1
d188 1
d210 1
a210 1
		while (dev_file->wproc != NULL) {
d214 3
a216 1
		dev_mix = 0;
d219 1
d221 1
d230 2
a231 1
		file_eof(dev_file);
d236 3
a238 1
		dev_sub = NULL;
d248 2
d254 7
a260 1
	dev_file->ops->start(dev_file);
d269 9
a277 1
	dev_file->ops->stop(dev_file);
@


1.20
log
@When resampling, don't require the sample frequency to be an integer.
This removes the arithmetic constraint between the sample frequency
and the block size and all the associated code. Now aucat can work
in server mode with any block size.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.19 2008/11/16 17:08:32 ratchov Exp $	*/
d274 1
d287 1
d450 1
d456 1
a456 1
	DPRINTF("dev_setvol: %d\n", vol);
@


1.19
log
@make aucat compile without DEBUG defined (still defined by default)
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.18 2008/11/16 16:30:22 ratchov Exp $	*/
a28 1
unsigned dev_rate_div, dev_round_div;
d33 2
a34 20
/*
 * supported rates
 */
#define NRATES (sizeof(dev_rates) / sizeof(dev_rates[0]))
unsigned dev_rates[] = {
	  6400,   7200,   8000,   9600,  11025,  12000,
	 12800,  14400,  16000,  19200,  22050,  24000,
	 25600,  28800,  32000,  38400,  44100,  48000,
	 51200,  57600,  64000,  76800,  88200,  96000,
	102400, 115200, 128000, 153600, 176400, 192000
};

/*
 * factors of supported rates
 */
#define NPRIMES (sizeof(dev_primes) / sizeof(dev_primes[0]))
unsigned dev_primes[] = {2, 3, 5, 7};

int
dev_setrate(unsigned rate)
d36 1
a36 33
	unsigned i, r, p;

	r = 1000 * rate;
	for (i = 0; i < NRATES; i++) {
		if (i == NRATES) {
			fprintf(stderr, "dev_setrate: %u, unsupported\n", rate);
			return 0;
		}
		if (r > 996 * dev_rates[i] &&
		    r < 1004 * dev_rates[i]) {
			dev_rate = dev_rates[i];
			break;
		}
	}

	dev_rate_div = dev_rate;
	dev_round_div = dev_round;
	for (i = 0; i < NPRIMES; i++) {
		p = dev_primes[i];
		while (dev_rate_div % p == 0 && dev_round_div % p == 0) {
			dev_rate_div /= p;
			dev_round_div /= p;
		}
	}
	return 1;
}

void
dev_roundrate(unsigned *newrate, unsigned *newround)
{
	*newrate += dev_rate_div - 1;
	*newrate -= *newrate % dev_rate_div;
	*newround = *newrate * dev_round_div / dev_rate_div;
d46 1
a46 2
    struct aparams *dipar, struct aparams *dopar,
    unsigned bufsz, int blkio)
d52 1
a52 1

d60 1
a60 1
	    dipar, dopar, &dev_bufsz, &dev_round, blkio);
a62 2
	if (!dev_setrate(dipar ? dipar->rate : dopar->rate))
		exit(1);
a63 1
		dipar->rate = dev_rate;
d71 1
a73 1
		dopar->rate = dev_rate;
d81 1
d355 2
a356 2
	unsigned nfr;
	
d359 3
a361 1
		pbuf = LIST_FIRST(&dev_mix->obuflist);		
a362 2
			nfr = (dev_bufsz + 3) / 4 + dev_round - 1;
			nfr -= nfr % dev_round;
d370 1
a370 1
			ibuf = abuf_new(nfr, &ipar);
a373 2
			nfr = (dev_bufsz + 3) / 4 + dev_round - 1;
			nfr -= nfr % dev_round;
d378 1
a378 1
			ibuf = abuf_new(nfr, &ipar);
d382 1
a382 3
			nfr = (dev_bufsz + 3) / 4 + dev_round - 1;
			nfr -= nfr % dev_round;
			conv = resamp_new(name, &ipar, &dev_opar);
d384 1
d386 1
a386 1
			ibuf = abuf_new(nfr, &ipar);
d398 2
a400 2
			nfr = (dev_bufsz + 3) / 4 + dev_round - 1;
			nfr -= nfr % dev_round;
d408 1
a408 1
			obuf = abuf_new(nfr, &opar);
a411 2
			nfr = (dev_bufsz + 3) / 4 + dev_round - 1;
			nfr -= nfr % dev_round;
d416 1
a416 1
			obuf = abuf_new(nfr, &opar);
d420 1
a420 3
			nfr = (dev_bufsz + 3) / 4 + dev_round - 1;
			nfr -= nfr % dev_round;
			conv = resamp_new(name, &dev_ipar, &opar);
d422 1
d424 1
a424 1
			obuf = abuf_new(nfr, &opar);
@


1.18
log
@Make clients inherit the volume parameter when the -v option is used in
server mode. It gives the maximum volume a client may have. This wastes
dynamic range, but allows volume to stay constant when other clients
connect or disconnect.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.17 2008/11/12 19:36:39 ratchov Exp $	*/
d119 1
d125 1
d129 1
d135 1
@


1.17
log
@when destroying the device, mark the mixer and the demultiplexer
for ``AUTOQUIT'' first, and then call file_eof() and friends.
fixes crashes sthen@@ noticed on zaurus
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.16 2008/11/11 19:21:20 ratchov Exp $	*/
d400 1
a400 1
    struct abuf *obuf, struct aparams *sopar, unsigned overrun)
d445 2
@


1.16
log
@expose the volume knob in server mode too
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.15 2008/11/11 12:56:02 ratchov Exp $	*/
d232 1
a249 2
		if (dev_mix)
			dev_mix->u.mix.flags |= MIX_AUTOQUIT;
d261 1
a270 2
		if (dev_sub)
			dev_sub->u.sub.flags |= SUB_AUTOQUIT;
@


1.15
log
@when not in server mode, aucat terminates automatically using
the {MIX,SUB}_AUTAQUIT features. In this case we're not
allowed to directly touch dev_mix and dev_sub because they
can disappar. So disable the ``suspend'' and ``quit'' bits
when {MIX,SUB}_AUTAQUIT are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.14 2008/11/10 23:25:37 ratchov Exp $	*/
d504 2
a505 1
	if (!dev_getep(&ibuf, NULL))
d507 1
a507 1
	fprintf(stderr, "vol = %d\n", vol);
d509 1
@


1.14
log
@add a per-stream ``soft volume'' knob and the corresponding -v option.
The code will be useful later for the volume knob in the sndio API.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.13 2008/11/09 16:26:07 ratchov Exp $	*/
d230 1
@


1.13
log
@make aucat(1) stop automatically the audio(1) device if it's idle. This
way, when in server mode, it consumes no CPU if there are no clients.
Later, this will allow to start aucat(1) at session or system startup.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.12 2008/11/08 10:01:43 ratchov Exp $	*/
d307 35
d359 2
a360 18
	for (;;) {
		if (!ibuf || !ibuf->rproc) {
			DPRINTF("dev_sync: reader desappeared\n");
			return;
		}
		if (ibuf->rproc == dev_mix)
			break;
		ibuf = LIST_FIRST(&ibuf->rproc->obuflist);
	}
	for (;;) {
		if (!obuf || !obuf->wproc) {
			DPRINTF("dev_sync: writer desappeared\n");
			return;
		}
		if (obuf->wproc == dev_sub)
			break;
		obuf = LIST_FIRST(&obuf->wproc->ibuflist);
	}
d495 12
@


1.12
log
@when dev_attach()ing play-only or record-only streams, don't
use both play and record parameters (one of them might be
NULL, causing aucat to segfault).
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.11 2008/11/07 21:01:15 ratchov Exp $	*/
d475 35
@


1.11
log
@expose the block size in the sndio API by making par->round writable
and thus remove the ugly rate <-> block-size table from
sio_setpar(3). Handle the block size negociation in aucat(1), since
it has few constrains the code is overally simpler.
ok jakemsr@@, major crank suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.10 2008/11/07 00:21:02 ratchov Exp $	*/
d385 1
a385 1
	struct aparams ipar = *sipar, opar = *sopar;
d390 1
d429 1
@


1.10
log
@when attaching a new stream, don't overwrite it's parameters
with the emulated ones (otherwise the next time it's attached
conversions will not be setup).
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.9 2008/11/04 22:18:12 ratchov Exp $	*/
d97 2
a98 1
    struct aparams *dipar, struct aparams *dopar, unsigned bufsz)
d106 2
a107 1
	 * use 1/4 of the total buffer for the device
d110 1
d112 1
a112 1
	    dipar, dopar, &dev_bufsz, &dev_round);
d133 2
a134 1
	nfr = ibufsz = obufsz = dev_bufsz;
d137 12
a148 1
	 * create record chain: use 1/4 for the file i/o buffers
@


1.9
log
@split code that converts any->any in two parts: one to encode
native->any and one to decode any->native. It is simpler and
faster this way.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.8 2008/11/04 18:24:06 ratchov Exp $	*/
d366 2
a367 2
    struct abuf *ibuf, struct aparams *ipar, unsigned underrun, 
    struct abuf *obuf, struct aparams *opar, unsigned overrun)
d370 1
d376 1
a376 1
		if (!aparams_eqenc(ipar, &dev_opar)) {
d379 6
a384 6
			conv = dec_new(name, ipar);
			ipar->bps = dev_opar.bps;
			ipar->bits = dev_opar.bits;
			ipar->sig = dev_opar.sig;
			ipar->le = dev_opar.le;
			ipar->msb = dev_opar.msb;
d386 1
a386 1
			ibuf = abuf_new(nfr, ipar);
d389 1
a389 1
		if (!aparams_subset(ipar, &dev_opar)) {
d392 3
a394 3
			conv = cmap_new(name, ipar, &dev_opar);
			ipar->cmin = dev_opar.cmin;
			ipar->cmax = dev_opar.cmax;
d396 1
a396 1
			ibuf = abuf_new(nfr, ipar);
d399 1
a399 1
		if (!aparams_eqrate(ipar, &dev_opar)) {
d402 2
a403 2
			conv = resamp_new(name, ipar, &dev_opar);
			ipar->rate = dev_opar.rate;
d405 1
a405 1
			ibuf = abuf_new(nfr, ipar);
d414 1
a414 1
		if (!aparams_eqenc(opar, &dev_ipar)) {
d417 6
a422 6
			conv = enc_new(name, opar);
			opar->bps = dev_ipar.bps;
			opar->bits = dev_ipar.bits;
			opar->sig = dev_ipar.sig;
			opar->le = dev_ipar.le;
			opar->msb = dev_ipar.msb;
d424 1
a424 1
			obuf = abuf_new(nfr, opar);
d427 1
a427 1
		if (!aparams_subset(opar, &dev_ipar)) {
d430 3
a432 3
			conv = cmap_new(name, &dev_ipar, opar);
			opar->cmin = dev_ipar.cmin;
			opar->cmax = dev_ipar.cmax;
d434 1
a434 1
			obuf = abuf_new(nfr, opar);
d437 1
a437 1
		if (!aparams_eqrate(opar, &dev_ipar)) {
d440 2
a441 2
			conv = resamp_new(name, &dev_ipar, opar);
			opar->rate = dev_ipar.rate;
d443 1
a443 1
			obuf = abuf_new(nfr, opar);
@


1.8
log
@cleanup: remove channel mapping bits from encoding conversion code.
As a side effect, reduce CPU usage by ~10% on envy(4) devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.7 2008/11/04 17:51:46 ratchov Exp $	*/
d117 1
a117 1
			DPRINTF("dev_init: dipar: ");
d119 1
a119 1
			DPRINTF("\n");
d125 1
a125 1
			DPRINTF("dev_init: dopar: ");
d127 1
a127 1
			DPRINTF("\n");
d149 1
a149 6
			if (debug_level > 0) {
				fprintf(stderr, "%s: ", devpath);
				aparams_print2(dipar, &ipar);
				fprintf(stderr, "\n");
			}
			conv = conv_new("subconv", dipar, &ipar);
d184 1
a184 6
			if (debug_level > 0) {
				fprintf(stderr, "%s: ", devpath);
				aparams_print2(&opar, dopar);
				fprintf(stderr, "\n");
			}
			conv = conv_new("mixconv", &opar, dopar);
d378 1
a378 4
			conv = conv_new(name, ipar, &dev_opar);
			aproc_setin(conv, ibuf);
			ibuf = abuf_new(nfr, &dev_opar);
			aproc_setout(conv, ibuf);
d384 3
d392 2
d395 1
a395 1
			ibuf = abuf_new(nfr, &dev_opar);
a396 2
			ipar->cmin = dev_opar.cmin;
			ipar->cmax = dev_opar.cmax;
d402 1
d404 1
a404 1
			ibuf = abuf_new(nfr, &dev_opar);
a405 1
			ipar->rate = dev_opar.rate;
d416 1
a416 4
			conv = conv_new(name, &dev_ipar, opar);
			aproc_setout(conv, obuf);
			obuf = abuf_new(nfr, &dev_ipar);
			aproc_setin(conv, obuf);
d422 3
d430 2
d433 1
a433 1
			obuf = abuf_new(nfr, &dev_ipar);
a434 2
			opar->cmin = dev_ipar.cmin;
			opar->cmax = dev_ipar.cmax;
d440 1
d442 1
a442 1
			obuf = abuf_new(nfr, &dev_ipar);
a443 1
			opar->rate = dev_ipar.rate;
@


1.7
log
@add "new" conversion code to map any channel range into any other
channel range (based on the encoding conversion code). Will allow to
unentangle channel mapping from encoding conversion. As a side effect,
greatly reduces CPU usage for channel mapping. No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.6 2008/11/04 15:22:40 ratchov Exp $	*/
d397 2
a398 3
			ipar->cmin = dev_opar.cmin;
			ipar->cmax = dev_opar.cmax;
		} else if (!aparams_subset(ipar, &dev_opar)) {
d435 2
a436 3
			opar->cmin = dev_ipar.cmin;
			opar->cmax = dev_ipar.cmax;
		} else if (!aparams_subset(opar, &dev_ipar)) {
@


1.6
log
@cleanup: resample stream while in native format and remove resampling
bits from the encoding conversion code. As a side effect this reduces
CPU usage by 30% on envy(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.5 2008/11/04 14:16:09 ratchov Exp $	*/
d385 1
a385 2
		if (!aparams_eqenc(ipar, &dev_opar) ||
		    !aparams_subset(ipar, &dev_opar)) {
d392 16
a407 1
			/* XXX: call abuf_fill() here ? */
d416 1
d424 1
a424 2
		if (!aparams_eqenc(opar, &dev_ipar) ||
		    !aparams_subset(opar, &dev_ipar)) {
d431 16
d455 1
@


1.5
log
@optimization: add "new" resampling code (actually based on the existing
conversion bits) and use it when resampling only is required (ie for
clients using s16 encoding), this is the most common case. Reduces CPU
usage by ~50%. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.4 2008/11/03 22:25:13 ratchov Exp $	*/
d394 2
a395 1
		} else if (!aparams_eqrate(ipar, &dev_opar)) {
d417 2
a418 1
		} else if (!aparams_eqrate(opar, &dev_ipar)) {
@


1.4
log
@A small optimization: handle most N-channel <-> M-channel conversions
inside the mixer and the demultiplexer. This way, aucat will not
trigger the heavy conversion code when only channel conversions are
required. Cuts ~50% of the CPU usage on envy(4) devices, can improve
surround 4.0, 5.1 and 7.1 capable devices. No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.3 2008/10/26 08:49:43 ratchov Exp $	*/
a385 1
		    !aparams_eqrate(ipar, &dev_opar) ||
a386 5
			if (debug_level > 1) {
				fprintf(stderr, "dev_attach: %s: ", name);
				aparams_print2(ipar, &dev_opar);
				fprintf(stderr, "\n");
			}
d394 7
a408 1
		    !aparams_eqrate(opar, &dev_ipar) ||
a409 5
			if (debug_level > 1) {
				fprintf(stderr, "dev_attach: %s: ", name);
				aparams_print2(&dev_ipar, opar);
				fprintf(stderr, "\n");
			}
d413 7
@


1.3
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d141 1
a141 1
		buf = abuf_new(nfr, aparams_bpf(dipar));
d148 1
a148 1
		if (!aparams_eq(dipar, &ipar)) {
d156 1
a156 1
			buf = abuf_new(nfr, aparams_bpf(&ipar));
d181 1
a181 1
		buf = abuf_new(nfr, aparams_bpf(dopar));
d188 1
a188 1
		if (!aparams_eq(&opar, dopar)) {
d196 1
a196 1
			buf = abuf_new(nfr, aparams_bpf(&opar));
d385 3
a387 1
		if (!aparams_eq(ipar, &dev_opar)) {
d397 1
a397 1
			ibuf = abuf_new(nfr, aparams_bpf(&dev_opar));
d407 3
a409 1
		if (!aparams_eq(opar, &dev_ipar)) {
d419 1
a419 1
			obuf = abuf_new(nfr, aparams_bpf(&dev_ipar));
@


1.2
log
@fix comments suggested by eric@@, remove stupid DPRINTF()
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.c,v 1.1 2008/08/14 09:58:55 ratchov Exp $	*/
a19 2
#include <signal.h>
#include <err.h>
d24 1
a24 1
#include "file.h"
d26 1
d28 2
a29 2
int quit_flag, pause_flag;
unsigned dev_infr, dev_onfr;
d32 1
a32 2
struct file  *dev_file;
struct devops *devops = &devops_sun;
d35 1
a35 3
 * SIGINT handler, it raises the quit flag. If the flag is already set,
 * that means that the last SIGINT was not handled, because the process
 * is blocked somewhere, so exit
d37 8
a44 7
void
sigint(int s)
{
	if (quit_flag)
		_exit(1);
	quit_flag = 1;
}
d47 1
a47 1
 * called when the user hits ctrl-z
d49 2
a50 5
void
sigtstp(int s)
{
	pause_flag = 1;
}
d52 2
a53 8
/*
 * SIGCONT is send when resumed after SIGTSTP or SIGSTOP. If the pause
 * flag is not set, that means that the process was not suspended by
 * dev_suspend(), which means that we lost the sync; since we cannot
 * resync, just exit
 */
void
sigcont(int s)
d55 1
a55 7
	static char msg[] = "can't resume afer SIGSTOP, terminating...\n";
	
	if (!pause_flag) {
		write(STDERR_FILENO, msg, sizeof(msg) - 1);
		_exit(1);
	}
}
d57 9
a65 41
/*
 * suicide with SIGTSTP (tty stop) as if the user had hit ctrl-z
 */
void
dev_suspend(void)
{
	struct sigaction sa;

	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = SIG_DFL;
	if (sigaction(SIGTSTP, &sa, NULL) < 0)
		err(1, "sigaction");
	DPRINTF("suspended by tty\n");
	kill(getpid(), SIGTSTP);
	pause_flag = 0;
	sa.sa_handler = sigtstp;
	if (sigaction(SIGTSTP, &sa, NULL) < 0)
		err(1, "sigaction");
	DPRINTF("resumed after suspend\n");
}

/*
 * fill playback buffer, so when device is started there
 * are samples to play
 */
void
dev_fill(void)
{
	struct abuf *buf;


	/*
	 * if there are no inputs, zero fill the mixer
	 */
	if (dev_mix && LIST_EMPTY(&dev_mix->ibuflist))
		mix_pushzero(dev_mix);
	DPRINTF("filling play buffers...\n");	
	for (;;) {
		if (!dev_file->wproc) {
			DPRINTF("fill: no writer\n");
d68 9
a76 10
		if (dev_file->events & POLLOUT) {
			/*
			 * kernel buffers are full, but continue
			 * until the play buffer is full too.
			 */
			buf = LIST_FIRST(&dev_file->wproc->ibuflist);
			if (!ABUF_WOK(buf))
				break;		/* buffer full */
			if (!buf->wproc)
				break;		/* will never be filled */
a77 4
		if (!file_poll())
			break;
		if (pause_flag)
			dev_suspend();
d79 1
a81 4
/*
 * flush recorded samples once the device is stopped so
 * they aren't lost
 */
d83 1
a83 1
dev_flush(void)
d85 3
a87 24
	struct abuf *buf;

	DPRINTF("flushing record buffers...\n");
	for (;;) {
		if (!dev_file->rproc) {
			DPRINTF("flush: no more reader\n");
			break;
		}
		if (dev_file->events & POLLIN) {
			/*
			 * we drained kernel buffers, but continue
			 * until the record buffer is empty.
			 */
			buf = LIST_FIRST(&dev_file->rproc->obuflist);
			if (!ABUF_ROK(buf))
				break;		/* buffer empty */
			if (!buf->rproc)
				break;		/* will never be drained */
		}
		if (!file_poll())
			break;
		if (pause_flag)
			dev_suspend();
	}
a89 1

d96 2
a97 1
dev_init(char *devpath, struct aparams *dipar, struct aparams *dopar)
a98 3
	int fd;
	struct sigaction sa;
	unsigned infr, onfr;
d102 1
d104 9
a112 17
	quit_flag = 0;
	pause_flag = 0;

	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = sigint;
	if (sigaction(SIGINT, &sa, NULL) < 0)
		err(1, "sigaction");
	sa.sa_handler = sigtstp;
	if (sigaction(SIGTSTP, &sa, NULL) < 0)
		err(1, "sigaction");
	sa.sa_handler = sigcont;
	if (sigaction(SIGCONT, &sa, NULL) < 0)
		err(1, "sigaction");

	fd = devops->open(devpath, dipar, dopar, &infr, &onfr);
	if (fd < 0)
d114 17
a130 1
	dev_file = file_new(fd, devpath);
d133 1
a133 1
	 * create record chain
a136 2
		infr *= DEFAULT_NBLK;

d141 1
a141 1
		buf = abuf_new(infr, aparams_bpf(dipar));
d143 1
d156 1
a156 1
			buf = abuf_new(infr, aparams_bpf(&ipar));
d158 1
a160 1
		dev_infr = infr;
d165 1
a165 1
		dev_sub = sub_new();
a176 2
		onfr *= DEFAULT_NBLK;	

d181 1
a181 1
		buf = abuf_new(onfr, aparams_bpf(dopar));
d183 2
a184 1

d196 1
a196 1
			buf = abuf_new(onfr, aparams_bpf(&opar));
d198 1
a198 1
			*dopar = opar;
a200 1
		dev_onfr = onfr;
d205 1
a205 1
		dev_mix = mix_new();
d211 3
a222 1
	struct sigaction sa;
d225 29
a253 7
	/*
	 * generate EOF on all inputs (including device), so once
	 * buffers are drained, everything will be cleaned
	 */
	LIST_FOREACH(f, &file_list, entry) {
		if (f->rproc)
			file_eof(f);
d255 17
a271 14
	/*
	 * destroy automatically mixe instead
	 * of generating silence
	 */
	if (dev_mix)
		dev_mix->u.mix.flags |= MIX_AUTOQUIT;
	if (dev_sub)
		dev_sub->u.sub.flags |= SUB_AUTOQUIT;
	/*
	 * drain buffers of terminated inputs.
	 */
	for (;;) {
		if (!file_poll())
			break;
a272 11
	devops->close(dev_file->fd);

	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = SIG_DFL;
	if (sigaction(SIGINT, &sa, NULL) < 0)
		err(1, "sigaction");
	if (sigaction(SIGTSTP, &sa, NULL) < 0)
		err(1, "sigaction");
	if (sigaction(SIGCONT, &sa, NULL) < 0)
		err(1, "sigaction");
a280 1
	dev_fill();
d285 1
a285 1
	devops->start(dev_file->fd);
d294 1
a294 1
	devops->stop(dev_file->fd);
a298 1
	dev_flush();
d302 2
a303 1
 * loop until there's either input or output to process
d306 1
a306 1
dev_run(int autoquit)
d308 17
a324 3
	while (!quit_flag) {
		if ((!dev_mix || LIST_EMPTY(&dev_mix->ibuflist)) &&
		    (!dev_sub || LIST_EMPTY(&dev_sub->obuflist)) && autoquit)
d326 8
a333 1
		if (!file_poll())
d335 1
a335 7
		if (pause_flag) {
			devops->stop(dev_file->fd);
			dev_flush();
			dev_suspend();
			dev_fill();
			devops->start(dev_file->fd);
		}
d337 29
a378 1
	int delta;
d381 1
d391 2
d395 1
a395 1
			ibuf = abuf_new(dev_onfr, aparams_bpf(&dev_opar));
d397 1
d400 1
a401 1
		mix_setmaster(dev_mix);
d411 2
d415 1
a415 1
			obuf = abuf_new(dev_infr, aparams_bpf(&dev_ipar));
d419 1
d424 1
a424 3
	 * calculate delta, the number of frames the play chain is ahead
	 * of the record chain. It's necessary to schedule silences (or
	 * drops) in order to start playback and record in sync.
d427 3
a429 43
		delta = 
		    rbuf->bpf * (pbuf->abspos + pbuf->used) - 
		    pbuf->bpf *  rbuf->abspos;
		delta /= pbuf->bpf * rbuf->bpf;
		DPRINTF("dev_attach: ppos = %u, pused = %u, rpos = %u\n",
		    pbuf->abspos, pbuf->used, rbuf->abspos);
	} else
		delta = 0;
	DPRINTF("dev_attach: delta = %u\n", delta);

	if (delta > 0) {
		/*
		 * if the play chain is ahead (most cases) drop some of
		 * the recorded input, to get both in sync
		 */
		obuf->drop += delta * obuf->bpf;
	} else if (delta < 0) {
		/*
		 * if record chain is ahead (should never happen,
		 * right?) then insert silence to play
		 */
		ibuf->silence += -delta * ibuf->bpf;
	}
	if (ibuf && (dev_mix->u.mix.flags & MIX_DROP)) {
		/*
		 * fill the play buffer with silence to avoid underruns,
		 * drop samples on the input to keep play/record in sync
		 * after the silence insertion
		 */
		ibuf->silence += dev_onfr * ibuf->bpf;
		if (obuf)
			obuf->drop += dev_onfr * obuf->bpf;
		/*
		 * force data to propagate
		 */
		abuf_run(ibuf);
		DPRINTF("dev_attach: ibuf: used = %u, silence = %u\n", 
		    ibuf->used, ibuf->silence);
	}
	if (obuf && (dev_sub->u.mix.flags & SUB_DROP)) {
		abuf_run(obuf);	
		DPRINTF("dev_attach: ibuf: used = %u, drop = %u\n",
		    obuf->used, obuf->drop);
@


1.1
log
@move all device related stuff from aucat.c to a new dev.c file.
The new dev_xxx() routines expose a "high level" self-contained
interface to the device. At initialization, the device is opened
and two chains of aproc structures are created:

 * a playback chain that exposes a (initially) empty mix
   aproc to which the rest of the code can attach new
   streams to be played

 * record chain that exposes a (initially) empty sub aproc
   to which the rest of the code can attach new stream to
   to record

The rest of the code, has just to use dev_attach() routine to
attach streams. While we're at it, add a ``devops'' structure
containing pointers to the device-specific routines. This will
allow later to add support for other type of device than the
Sun API.

Also, write the .wav headers in file_del(), so put all header
related data in the file strucuture. This allows to close() the
file, as soon as wpipe_xxx() aproc terminates. This will be
useful for the server, because it will need to close() descripts
of closed connections immediately.

add mix_pushzero() routine to fill the mixer with silence. It
will be used to avoid the mixer to underrun when there are no
input streams. Since we always have at least one input stream
there's no behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a463 1
		DPRINTF("lmkqsjdlkqsjklqsd\n");
@

