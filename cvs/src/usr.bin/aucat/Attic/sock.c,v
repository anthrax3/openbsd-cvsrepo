head	1.68;
access;
symbols
	OPENBSD_5_4:1.67.0.4
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.67.0.2
	OPENBSD_5_3_BASE:1.67
	OPENBSD_5_2:1.64.0.2
	OPENBSD_5_2_BASE:1.64
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.2
	OPENBSD_5_0:1.60.0.2
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.53.0.2
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.50.0.2
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14;
locks; strict;
comment	@ * @;


1.68
date	2013.11.12.06.47.34;	author ratchov;	state dead;
branches;
next	1.67;

1.67
date	2012.11.23.06.40.26;	author ratchov;	state Exp;
branches;
next	1.66;

1.66
date	2012.11.02.10.24.58;	author ratchov;	state Exp;
branches;
next	1.65;

1.65
date	2012.10.27.11.54.27;	author ratchov;	state Exp;
branches;
next	1.64;

1.64
date	2012.04.11.21.17.32;	author ratchov;	state Exp;
branches;
next	1.63;

1.63
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.62;

1.62
date	2011.11.20.22.54.51;	author ratchov;	state Exp;
branches;
next	1.61;

1.61
date	2011.11.15.08.05.22;	author ratchov;	state Exp;
branches;
next	1.60;

1.60
date	2011.06.03.16.22.34;	author ratchov;	state Exp;
branches;
next	1.59;

1.59
date	2011.05.02.22.32.29;	author ratchov;	state Exp;
branches;
next	1.58;

1.58
date	2011.05.02.22.20.18;	author ratchov;	state Exp;
branches;
next	1.57;

1.57
date	2011.04.28.06.19.57;	author ratchov;	state Exp;
branches;
next	1.56;

1.56
date	2011.04.16.11.24.18;	author ratchov;	state Exp;
branches;
next	1.55;

1.55
date	2011.04.16.10.52.22;	author ratchov;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.08.13.00.57;	author ratchov;	state Exp;
branches;
next	1.53;

1.53
date	2010.11.04.17.55.28;	author ratchov;	state Exp;
branches;
next	1.52;

1.52
date	2010.10.21.19.10.52;	author ratchov;	state Exp;
branches;
next	1.51;

1.51
date	2010.10.21.18.57.42;	author ratchov;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.05.16.00.52;	author ratchov;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.05.12.45.48;	author ratchov;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.04.06.15.28;	author ratchov;	state Exp;
branches;
next	1.47;

1.47
date	2010.05.08.15.35.45;	author ratchov;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.02.11.54.27;	author ratchov;	state Exp;
branches;
next	1.45;

1.45
date	2010.04.24.06.18.23;	author ratchov;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.22.17.43.30;	author ratchov;	state Exp;
branches;
next	1.43;

1.43
date	2010.04.21.06.13.07;	author ratchov;	state Exp;
branches;
next	1.42;

1.42
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.40;

1.40
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.39;

1.39
date	2010.01.15.22.17.44;	author ratchov;	state Exp;
branches;
next	1.38;

1.38
date	2010.01.11.13.06.32;	author ratchov;	state Exp;
branches;
next	1.37;

1.37
date	2010.01.10.21.47.41;	author ratchov;	state Exp;
branches;
next	1.36;

1.36
date	2010.01.05.10.18.12;	author ratchov;	state Exp;
branches;
next	1.35;

1.35
date	2009.11.03.21.31.37;	author ratchov;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.27.22.41.03;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.22.21.41.30;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.21.05.43.41;	author ratchov;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.10.13.55.37;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.05.07.05.24;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2009.09.27.11.51.20;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2009.08.28.06.37.06;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.27.06.54.23;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.27.06.31.13;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.26.06.10.15;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.21.16.48.03;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.19.05.54.15;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.17.16.17.46;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.17.15.07.49;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.25.10.52.19;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.16.12.20.31;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.16.11.15.26;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.15.10.31.37;	author jakemsr;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.12.07.26.04;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.06.08.29.35;	author ratchov;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2009.02.04.20.35.14;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.23.17.38.15;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.29.17.59.08;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.17.07.19.27;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.07.17.10.41;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.17.07.04.13;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.16.20.44.03;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.16.18.34.56;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.16.17.08.32;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.16.16.30.22;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.11.19.21.20;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.03.22.25.13;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.26.08.49.44;	author ratchov;	state Exp;
branches;
next	;

1.14.2.1
date	2009.04.27.20.42.51;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.68
log
@remove bogus legacy server-specific bits that cause confusion
@
text
@/*	$OpenBSD: sock.c,v 1.67 2012/11/23 06:40:26 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "abuf.h"
#include "aproc.h"
#include "conf.h"
#include "dev.h"
#include "midi.h"
#include "opt.h"
#include "sock.h"
#ifdef DEBUG
#include "dbg.h"
#endif

void sock_attach(struct sock *, int);
int sock_read(struct sock *);
int sock_write(struct sock *);
int sock_execmsg(struct sock *);
void sock_reset(struct sock *);
void sock_close(struct file *);

struct fileops sock_ops = {
	"sock",
	sizeof(struct sock),
       	sock_close,
	pipe_read,
	pipe_write,
	NULL, /* start */
	NULL, /* stop */
	pipe_nfds,
	pipe_pollfd,
	pipe_revents
};

#ifdef DEBUG
void
sock_dbg(struct sock *f)
{
	static char *pstates[] = {
		"aut", "hel", "ini", "sta", "rdy", "run", "stp", "mid"
	};
	static char *rstates[] = { "rdat", "rmsg", "rret" };
	static char *wstates[] = { "widl", "wmsg", "wdat" };

	if (f->slot >= 0) {
		dbg_puts(f->dev->slot[f->slot].name);
		dbg_putu(f->dev->slot[f->slot].unit);
	} else
		dbg_puts(f->pipe.file.name);
	dbg_puts("/");
	dbg_puts(pstates[f->pstate]);
	dbg_puts("|");
	dbg_puts(rstates[f->rstate]);
	dbg_puts("|");
	dbg_puts(wstates[f->wstate]);
}
#endif

void sock_setvol(void *, unsigned int);
void sock_startreq(void *);
void sock_stopreq(void *);
void sock_quitreq(void *);
void sock_locreq(void *, unsigned int);

struct ctl_ops ctl_sockops = {
	sock_setvol,
	sock_startreq,
	sock_stopreq,
	sock_locreq,
	sock_quitreq
};

unsigned int sock_sesrefs = 0;		/* connections to the session */
uint8_t sock_sescookie[AMSG_COOKIELEN];	/* owner of the session */

void
sock_close(struct file *arg)
{
	struct sock *f = (struct sock *)arg;

	if (f->pstate != SOCK_AUTH)
		sock_sesrefs--;
	pipe_close(&f->pipe.file);
	if (f->dev) {
		dev_unref(f->dev);
		f->dev = NULL;
	}
}

void
rsock_done(struct aproc *p)
{
	struct sock *f = (struct sock *)p->u.io.file;

	if (f == NULL)
		return;
	sock_reset(f);
	f->pipe.file.rproc = NULL;
	if (f->pipe.file.wproc) {
		if (f->slot >= 0)
			dev_slotdel(f->dev, f->slot);
		aproc_del(f->pipe.file.wproc);
		file_del(&f->pipe.file);
	}
	p->u.io.file = NULL;
}

int
rsock_in(struct aproc *p, struct abuf *ibuf_dummy)
{
	struct sock *f = (struct sock *)p->u.io.file;
	struct abuf *obuf;

	if (!sock_read(f))
		return 0;
	obuf = LIST_FIRST(&p->outs);
	if (obuf && f->pstate >= SOCK_RUN) {
		if (!abuf_flush(obuf))
			return 0;
	}
	return 1;
}

int
rsock_out(struct aproc *p, struct abuf *obuf)
{
	struct sock *f = (struct sock *)p->u.io.file;

	if (f->pipe.file.state & FILE_RINUSE)
		return 0;

	/*
	 * When calling sock_read(), we may receive a ``STOP'' command,
	 * and detach ``obuf''. In this case, there's no more caller and
	 * we'll stop processing further messages, resulting in a deadlock.
	 * The solution is to iterate over sock_read() in order to
	 * consume all messages().
	 */
	for (;;) {
		if (!sock_read(f))
			return 0;
	}
	return 1;
}

void
rsock_eof(struct aproc *p, struct abuf *ibuf_dummy)
{
	aproc_del(p);
}

void
rsock_hup(struct aproc *p, struct abuf *ibuf)
{
	aproc_del(p);
}

void
rsock_opos(struct aproc *p, struct abuf *obuf, int delta)
{
	struct sock *f = (struct sock *)p->u.io.file;

	if (f->mode & MODE_RECMASK)
		return;

	f->delta += delta;
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": moved to delta = ");
		dbg_puti(f->delta);
		dbg_puts("\n");
	}
#endif
	f->tickpending++;
	for (;;) {
		if (!sock_write(f))
			break;
	}
}

struct aproc_ops rsock_ops = {
	"rsock",
	rsock_in,
	rsock_out,
	rsock_eof,
	rsock_hup,
	NULL, /* newin */
	NULL, /* newout */
	NULL, /* ipos */
	rsock_opos,
	rsock_done
};

void
wsock_done(struct aproc *p)
{
	struct sock *f = (struct sock *)p->u.io.file;

	if (f == NULL)
		return;
	sock_reset(f);
	f->pipe.file.wproc = NULL;
	if (f->pipe.file.rproc) {
		if (f->slot >= 0)
			dev_slotdel(f->dev, f->slot);
		aproc_del(f->pipe.file.rproc);
		file_del(&f->pipe.file);
	}
	p->u.io.file = NULL;
}

int
wsock_in(struct aproc *p, struct abuf *ibuf)
{
	struct sock *f = (struct sock *)p->u.io.file;

	if (f->pipe.file.state & FILE_WINUSE)
		return 0;
	/*
	 * See remark in rsock_out().
	 */
	for (;;) {
		if (!sock_write(f))
			return 0;
	}
	return 1;
}

int
wsock_out(struct aproc *p, struct abuf *obuf_dummy)
{
	struct abuf *ibuf = LIST_FIRST(&p->ins);
	struct sock *f = (struct sock *)p->u.io.file;

	if (ibuf) {
		if (!abuf_fill(ibuf))
			return 0;
	}
	if (!sock_write(f))
		return 0;
	return 1;
}

void
wsock_eof(struct aproc *p, struct abuf *obuf)
{
	aproc_del(p);
}

void
wsock_hup(struct aproc *p, struct abuf *obuf_dummy)
{
	aproc_del(p);
}

void
wsock_ipos(struct aproc *p, struct abuf *obuf, int delta)
{
	struct sock *f = (struct sock *)p->u.io.file;

	if (!(f->mode & MODE_RECMASK))
		return;

	f->delta += delta;
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": moved to delta = ");
		dbg_puti(f->delta);
		dbg_puts("\n");
	}
#endif
	f->tickpending++;
	for (;;) {
		if (!sock_write(f))
			break;
	}
}

struct aproc_ops wsock_ops = {
	"wsock",
	wsock_in,
	wsock_out,
	wsock_eof,
	wsock_hup,
	NULL, /* newin */
	NULL, /* newout */
	wsock_ipos,
	NULL, /* opos */
	wsock_done
};

/*
 * Initialise socket in the SOCK_HELLO state with default
 * parameters.
 */
struct sock *
sock_new(struct fileops *ops, int fd)
{
	struct aproc *rproc, *wproc;
	struct sock *f;

	f = (struct sock *)pipe_new(ops, fd, "sock");
	if (f == NULL) {
		close(fd);
		return NULL;
	}
	f->pstate = SOCK_AUTH;
	f->mode = 0;
	f->opt = NULL;
	f->dev = NULL;
	f->xrun = XRUN_IGNORE;
	f->delta = 0;
	f->tickpending = 0;
	f->fillpending = 0;
	f->vol = f->lastvol = MIDI_MAXCTL;
	f->slot = -1;

	wproc = aproc_new(&wsock_ops, f->pipe.file.name);
	wproc->u.io.file = &f->pipe.file;
	wproc->u.io.partial = 0;
	f->pipe.file.wproc = wproc;
	f->wstate = SOCK_WIDLE;
	f->wtodo = 0xdeadbeef;

	rproc = aproc_new(&rsock_ops, f->pipe.file.name);
	rproc->u.io.file = &f->pipe.file;
	rproc->u.io.partial = 0;
	f->pipe.file.rproc = rproc;
	f->rstate = SOCK_RMSG;
	f->rtodo = sizeof(struct amsg);
	return f;
}

/*
 * Free buffers.
 */
void
sock_freebuf(struct sock *f)
{
	struct abuf *rbuf, *wbuf;

	f->pstate = SOCK_INIT;
#ifdef DEBUG
	if (debug_level >= 3) {
		sock_dbg(f);
		dbg_puts(": freeing buffers\n");
	}
#endif
	wbuf = LIST_FIRST(&f->pipe.file.wproc->ins);
	rbuf = LIST_FIRST(&f->pipe.file.rproc->outs);
	if (rbuf || wbuf)
		dev_slotstop(f->dev, f->slot);
	if (rbuf)
		abuf_eof(rbuf);
	if (wbuf)
		abuf_hup(wbuf);
	f->tickpending = 0;
	f->fillpending = 0;
}

/*
 * Allocate buffers, so client can start filling write-end.
 */
void
sock_allocbuf(struct sock *f)
{
	struct abuf *rbuf = NULL, *wbuf = NULL;
	unsigned int bufsz;

	bufsz = f->bufsz + f->dev->bufsz / f->dev->round * f->round;
	f->pstate = SOCK_START;
	if (f->mode & MODE_PLAY) {
		rbuf = abuf_new(bufsz, &f->rpar);
		aproc_setout(f->pipe.file.rproc, rbuf);
		if (!ABUF_WOK(rbuf) || (f->pipe.file.state & FILE_EOF))
			f->pstate = SOCK_READY;
		f->fillpending = bufsz;
		f->rmax = 0;
	}
	if (f->mode & MODE_RECMASK) {
		wbuf = abuf_new(bufsz, &f->wpar);
		aproc_setin(f->pipe.file.wproc, wbuf);
		f->walign = f->round;
		f->wmax = 0;
	}
	f->delta = 0;
	f->tickpending = 0;
#ifdef DEBUG
	if (debug_level >= 3) {
		sock_dbg(f);
		dbg_puts(": allocating ");
		dbg_putu(f->bufsz);
		dbg_puts("/");
		dbg_putu(bufsz);
		dbg_puts(" fr buffers, rmax = ");
		dbg_putu(f->rmax);
		dbg_puts("\n");
	}
#endif
	if (f->mode & MODE_PLAY) {
		f->pstate = SOCK_START;
	} else {
		f->pstate = SOCK_READY;
		if (dev_slotstart(f->dev, f->slot))
			(void)sock_attach(f, 0);
	}
}

/*
 * Set volume. Callback invoked when volume is modified externally
 */
void
sock_setvol(void *arg, unsigned int vol)
{
	struct sock *f = (struct sock *)arg;
	struct abuf *rbuf;

	f->vol = vol;
	rbuf = LIST_FIRST(&f->pipe.file.rproc->outs);
	if (!rbuf) {
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": no read buffer to set volume yet\n");
		}
#endif
		return;
	}
	dev_setvol(f->dev, rbuf, MIDI_TO_ADATA(vol));
}

/*
 * Attach the stream. Callback invoked when MMC start
 */
void
sock_startreq(void *arg)
{
	struct sock *f = (struct sock *)arg;

#ifdef DEBUG
	if (f->pstate != SOCK_READY) {
		sock_dbg(f);
		dbg_puts(": not in READY state\n");
		dbg_panic();
	}
#endif
	(void)sock_attach(f, 0);
}

/*
 * Callback invoked by MMC stop
 */
void
sock_stopreq(void *arg)
{
#ifdef DEBUG
	struct sock *f = (struct sock *)arg;

	if (debug_level >= 3) {
		sock_dbg(f);
		dbg_puts(": ignored STOP signal\n");
	}
#endif
}

/*
 * Callback invoked by MMC relocate, ignored
 */
void
sock_locreq(void *arg, unsigned int mmcpos)
{
#ifdef DEBUG
	struct sock *f = (struct sock *)arg;

	if (debug_level >= 3) {
		sock_dbg(f);
		dbg_puts(": ignored RELOCATE signal\n");
	}
#endif
}

/*
 * Callback invoked when slot is gone
 */
void
sock_quitreq(void *arg)
{
	struct sock *f = (struct sock *)arg;

#ifdef DEBUG
	if (debug_level >= 3) {
		sock_dbg(f);
		dbg_puts(": slot gone\n");
	}
#endif
	file_close(&f->pipe.file);
}

/*
 * Attach play and/or record buffers to the device
 */
void
sock_attach(struct sock *f, int force)
{
	struct abuf *rbuf, *wbuf;
	unsigned int rch, wch;

	rbuf = LIST_FIRST(&f->pipe.file.rproc->outs);
	wbuf = LIST_FIRST(&f->pipe.file.wproc->ins);

	/*
	 * If in SOCK_START state, dont attach until
	 * the buffer isn't completely filled.
	 */
	if (!force && rbuf && ABUF_WOK(rbuf))
		return;

	/*
	 * start the device (dev_getpos() and dev_attach() must
	 * be called on a started device
	 */
	dev_wakeup(f->dev);

	/*
	 * get the current position, the origin is when
	 * the first sample is played/recorded
	 */
	f->delta = dev_getpos(f->dev) *
	    (int)f->round / (int)f->dev->round;
	f->pstate = SOCK_RUN;
#ifdef DEBUG
	if (debug_level >= 3) {
		sock_dbg(f);
		dbg_puts(": attaching at ");
		dbg_puti(f->delta);
		dbg_puts("fillpending = ");
		dbg_puti(f->fillpending);
		dbg_puts("\n");
	}
#endif
	/*
	 * We dont check whether the device is dying,
	 * because dev_xxx() functions are supposed to
	 * work (i.e., not to crash)
	 */
	if (f->opt->join) {
		rch = f->opt->rpar.cmax - f->opt->rpar.cmin + 1;
		wch = f->opt->wpar.cmax - f->opt->wpar.cmin + 1;
	} else
		rch = wch = 0;
	dev_attach(f->dev, f->pipe.file.name, f->mode,
	    rbuf, &f->rpar, rch, wbuf, &f->wpar, wch,
	    f->xrun, f->opt->maxweight);
	if (f->mode & MODE_PLAY)
		dev_setvol(f->dev, rbuf, MIDI_TO_ADATA(f->vol));
}

void
sock_reset(struct sock *f)
{
	switch (f->pstate) {
	case SOCK_START:
	case SOCK_READY:
		if (dev_slotstart(f->dev, f->slot)) {
			(void)sock_attach(f, 1);
			f->pstate = SOCK_RUN;
		}
		/* PASSTHROUGH */
	case SOCK_RUN:
		sock_freebuf(f);
		f->pstate = SOCK_INIT;
		/* PASSTHROUGH */
	case SOCK_INIT:
		/* nothing yet */
		break;
	}
}

/*
 * Read a message from the file descriptor, return 1 if done, 0
 * otherwise. The message is stored in f->rmsg.
 */
int
sock_rmsg(struct sock *f)
{
	unsigned int count;
	unsigned char *data;

	while (f->rtodo > 0) {
		if (!(f->pipe.file.state & FILE_ROK)) {
#ifdef DEBUG
			if (debug_level >= 4) {
				sock_dbg(f);
				dbg_puts(": reading message blocked, ");
				dbg_putu(f->rtodo);
				dbg_puts(" bytes remaining\n");
			}
#endif
			return 0;
		}
		data = (unsigned char *)&f->rmsg;
		data += sizeof(struct amsg) - f->rtodo;
		count = file_read(&f->pipe.file, data, f->rtodo);
		if (count == 0)
			return 0;
		f->rtodo -= count;
	}
#ifdef DEBUG
	if (debug_level >= 4) {
		sock_dbg(f);
		dbg_puts(": read full message\n");
	}
#endif
	return 1;
}

/*
 * Write a message to the file descriptor, return 1 if done, 0
 * otherwise.  The "m" argument is f->rmsg or f->wmsg, and the "ptodo"
 * points to the f->rtodo or f->wtodo respectively.
 */
int
sock_wmsg(struct sock *f, struct amsg *m, unsigned int *ptodo)
{
	unsigned int count;
	unsigned char *data;

	while (*ptodo > 0) {
		if (!(f->pipe.file.state & FILE_WOK)) {
#ifdef DEBUG
			if (debug_level >= 4) {
				sock_dbg(f);
				dbg_puts(": writing message blocked, ");
				dbg_putu(*ptodo);
				dbg_puts(" bytes remaining\n");
			}
#endif
			return 0;
		}
		data = (unsigned char *)m;
		data += sizeof(struct amsg) - *ptodo;
		count = file_write(&f->pipe.file, data, *ptodo);
		if (count == 0)
			return 0;
		*ptodo -= count;
	}
#ifdef DEBUG
	if (debug_level >= 4) {
		sock_dbg(f);
		dbg_puts(": wrote full message\n");
	}
#endif
	return 1;
}

/*
 * Read data chunk from the file descriptor, return 1 if at least one
 * byte was read, 0 if the file blocked.
 */
int
sock_rdata(struct sock *f)
{
	struct aproc *p;
	struct abuf *obuf;
	unsigned int n;

#ifdef DEBUG
	if (f->rtodo == 0) {
		sock_dbg(f);
		dbg_puts(": data block already read\n");
		dbg_panic();
	}
#endif
	p = f->pipe.file.rproc;
	obuf = LIST_FIRST(&p->outs);
	if (obuf == NULL)
		return 0;
	if (!ABUF_WOK(obuf) || !(f->pipe.file.state & FILE_ROK))
		return 0;
	if (!rfile_do(p, f->rtodo, &n))
		return 0;
	f->rtodo -= n;
	if (f->pstate == SOCK_START) {
		if (!ABUF_WOK(obuf) || (f->pipe.file.state & FILE_EOF))
			f->pstate = SOCK_READY;
	}
	return 1;
}

/*
 * Write data chunk to the file descriptor, return 1 if at least one
 * byte was written, 0 if the file blocked.
 */
int
sock_wdata(struct sock *f)
{
	struct aproc *p;
	struct abuf *ibuf;
	unsigned int n;

#ifdef DEBUG
	if (f->wtodo == 0) {
		sock_dbg(f);
		dbg_puts(": attempted to write zero-sized data block\n");
		dbg_panic();
	}
#endif
	if (!(f->pipe.file.state & FILE_WOK))
		return 0;
	p = f->pipe.file.wproc;
	ibuf = LIST_FIRST(&p->ins);
#ifdef DEBUG
	if (ibuf == NULL) {
		sock_dbg(f);
		dbg_puts(": attempted to write on detached buffer\n");
		dbg_panic();
	}
#endif
	if (ibuf == NULL)
		return 0;
	if (!ABUF_ROK(ibuf))
		return 0;
	if (!wfile_do(p, f->wtodo, &n))
		return 0;
	f->wtodo -= n;
	return 1;
}

int
sock_setpar(struct sock *f)
{
	struct amsg_par *p = &f->rmsg.u.par;
	unsigned int min, max, rate, pchan, rchan, appbufsz;

	rchan = ntohs(p->rchan);
	pchan = ntohs(p->pchan);
	appbufsz = ntohl(p->appbufsz);
	rate = ntohl(p->rate);

	if (AMSG_ISSET(p->bits)) {
		if (p->bits < BITS_MIN || p->bits > BITS_MAX) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": ");
				dbg_putu(p->bits);
				dbg_puts(": bits out of bounds\n");
			}
#endif
			return 0;
		}
		if (AMSG_ISSET(p->bps)) {
			if (p->bps < ((p->bits + 7) / 8) || p->bps > 4) {
#ifdef DEBUG
				if (debug_level >= 1) {
					sock_dbg(f);
					dbg_puts(": ");
					dbg_putu(p->bps);
					dbg_puts(": wrong bytes per sample\n");
				}
#endif
				return 0;
			}
		} else
			p->bps = APARAMS_BPS(p->bits);
		f->rpar.bits = f->wpar.bits = p->bits;
		f->rpar.bps = f->wpar.bps = p->bps;
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": using ");
			dbg_putu(p->bits);
			dbg_puts("bits, ");
			dbg_putu(p->bps);
			dbg_puts(" bytes per sample\n");
		}
#endif
	}
	if (AMSG_ISSET(p->sig))
		f->rpar.sig = f->wpar.sig = p->sig ? 1 : 0;
	if (AMSG_ISSET(p->le))
		f->rpar.le = f->wpar.le = p->le ? 1 : 0;
	if (AMSG_ISSET(p->msb))
		f->rpar.msb = f->wpar.msb = p->msb ? 1 : 0;
	if (AMSG_ISSET(rchan) && (f->mode & MODE_RECMASK)) {
		if (rchan < 1)
			rchan = 1;
		if (rchan > NCHAN_MAX)
			rchan = NCHAN_MAX;
		f->wpar.cmin = f->opt->wpar.cmin;
		f->wpar.cmax = f->opt->wpar.cmin + rchan - 1;
		if (f->wpar.cmax > f->opt->wpar.cmax)
			f->wpar.cmax = f->opt->wpar.cmax;
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": using recording channels ");
			dbg_putu(f->wpar.cmin);
			dbg_puts("..");
			dbg_putu(f->wpar.cmax);
			dbg_puts("\n");
		}
#endif
	}
	if (AMSG_ISSET(pchan) && (f->mode & MODE_PLAY)) {
		if (pchan < 1)
			pchan = 1;
		if (pchan > NCHAN_MAX)
			pchan = NCHAN_MAX;
		f->rpar.cmin = f->opt->rpar.cmin;
		f->rpar.cmax = f->opt->rpar.cmin + pchan - 1;
		if (f->rpar.cmax > f->opt->rpar.cmax)
			f->rpar.cmax = f->opt->rpar.cmax;
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": using playback channels ");
			dbg_putu(f->rpar.cmin);
			dbg_puts("..");
			dbg_putu(f->rpar.cmax);
			dbg_puts("\n");
		}
#endif
	}
	if (AMSG_ISSET(rate)) {
		if (rate < RATE_MIN)
			rate = RATE_MIN;
		if (rate > RATE_MAX)
			rate = RATE_MAX;
		f->round = dev_roundof(f->dev, rate);
		f->rpar.rate = f->wpar.rate = rate;
		if (!AMSG_ISSET(appbufsz)) {
			appbufsz = f->dev->bufsz / f->dev->round * f->round;
#ifdef DEBUG
			if (debug_level >= 3) {
				sock_dbg(f);
				dbg_puts(": using ");
				dbg_putu(appbufsz);
				dbg_puts(" fr app buffer size\n");
			}
#endif
		}
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": using ");
			dbg_putu(rate);
			dbg_puts("Hz sample rate, ");
			dbg_putu(f->round);
			dbg_puts(" fr block size\n");
		}
#endif
	}
	if (AMSG_ISSET(p->xrun)) {
		if (p->xrun != XRUN_IGNORE &&
		    p->xrun != XRUN_SYNC &&
		    p->xrun != XRUN_ERROR) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": ");
				dbg_putx(p->xrun);
				dbg_puts(": bad xrun policy\n");
			}
#endif
			return 0;
		}
		f->xrun = p->xrun;
		if (f->opt->mmc && f->xrun == XRUN_IGNORE)
			f->xrun = XRUN_SYNC;
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": using 0x");
			dbg_putx(f->xrun);
			dbg_puts(" xrun policy\n");
		}
#endif
	}
	if (AMSG_ISSET(appbufsz)) {
		rate = (f->mode & MODE_PLAY) ? f->rpar.rate : f->wpar.rate;
		min = 1;
		max = 1 + rate / f->dev->round;
		min *= f->round;
		max *= f->round;
		appbufsz += f->round - 1;
		appbufsz -= appbufsz % f->round;
		if (appbufsz < min)
			appbufsz = min;
		if (appbufsz > max)
			appbufsz = max;
		f->bufsz = appbufsz;
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": using ");
			dbg_putu(f->bufsz);
			dbg_puts(" buffer size\n");
		}
#endif
	}
#ifdef DEBUG
	if (debug_level >= 2) {
		dbg_puts(f->dev->slot[f->slot].name);
		dbg_putu(f->dev->slot[f->slot].unit);
		dbg_puts(": buffer size = ");
		dbg_putu(f->bufsz);
		if (f->mode & MODE_PLAY) {
			dbg_puts(", play = ");
			aparams_dbg(&f->rpar);
		}
		if (f->mode & MODE_RECMASK) {
			dbg_puts(", rec:");
			aparams_dbg(&f->wpar);
		}
		dbg_puts("\n");
	}
#endif
	return 1;
}

/*
 * allocate buffers, so client can start filling write-end.
 */
void
sock_midiattach(struct sock *f)
{
	struct abuf *rbuf = NULL, *wbuf = NULL;
	
	if (f->mode & MODE_MIDIOUT) {
		rbuf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setout(f->pipe.file.rproc, rbuf);
	}
	if (f->mode & MODE_MIDIIN) {
		wbuf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setin(f->pipe.file.wproc, wbuf);
	}
	f->pstate = SOCK_MIDI;
	f->fillpending = MIDI_BUFSZ;
	dev_midiattach(f->dev, rbuf, wbuf);
}

int
sock_auth(struct sock *f)
{
	struct amsg_auth *p = &f->rmsg.u.auth;

	if (sock_sesrefs == 0) {
		/* start a new session */
		memcpy(sock_sescookie, p->cookie, AMSG_COOKIELEN);
	} else if (memcmp(sock_sescookie, p->cookie, AMSG_COOKIELEN) != 0) {
		/* another session is active, drop connection */
		return 0;
	}
	sock_sesrefs++;
	f->pstate = SOCK_HELLO;
	return 1;
}

int
sock_hello(struct sock *f)
{
	struct amsg_hello *p = &f->rmsg.u.hello;
	unsigned int mode;

	mode = ntohs(p->mode);
#ifdef DEBUG
	if (debug_level >= 3) {
		sock_dbg(f);
		dbg_puts(": hello from <");
		dbg_puts(p->who);
		dbg_puts(">, mode = ");
		dbg_putx(mode);
		dbg_puts(", ver ");
		dbg_putu(p->version);
		dbg_puts("\n");
	}
#endif
	if (p->version != AMSG_VERSION) {
#ifdef DEBUG
		if (debug_level >= 1) {
			sock_dbg(f);
			dbg_puts(": ");
			dbg_putu(p->version);
			dbg_puts(": unsupported protocol version\n");
		}
#endif
		return 0;
	}
	switch (mode) {
	case MODE_MIDIIN:
	case MODE_MIDIOUT:
	case MODE_MIDIOUT | MODE_MIDIIN:
	case MODE_REC:
	case MODE_PLAY:
	case MODE_PLAY | MODE_REC:
		break;
	default:
#ifdef DEBUG
		if (debug_level >= 1) {
			sock_dbg(f);
			dbg_puts(": ");
			dbg_putx(mode);
			dbg_puts(": unsupported mode\n");
		}
#endif
		return 0;
	}
	f->opt = opt_byname(p->opt, AMSG_ISSET(p->devnum) ? p->devnum : 0);
	if (f->opt == NULL)
		return 0;
#ifdef DEBUG
	if (debug_level >= 3) {
		sock_dbg(f);
		dbg_puts(": using ");
		dev_dbg(f->opt->dev);
		dbg_puts(".");
		dbg_puts(f->opt->name);
		dbg_puts("\n");
	}
#endif
	if (!dev_ref(f->opt->dev))
		return 0;
	if ((mode & MODE_REC) && (f->opt->mode & MODE_MON)) {
		mode &= ~MODE_REC;
		mode |= MODE_MON;
	}
	f->dev = f->opt->dev;
	f->mode = (mode & f->opt->mode) & f->dev->mode;
#ifdef DEBUG
	if (debug_level >= 3) {
		sock_dbg(f);
		dbg_puts(": using mode = ");
		dbg_putx(f->mode);
		dbg_puts("\n");
	}
#endif
	if (f->mode != mode) {
#ifdef DEBUG
		if (debug_level >= 1) {
			sock_dbg(f);
			dbg_puts(": requested mode not available\n");
		}
#endif
		return 0;
	}
	if (f->mode & (MODE_MIDIOUT | MODE_MIDIIN)) {
		sock_midiattach(f);
		return 1;
	}
	if (f->mode & MODE_PLAY)
		f->rpar = f->opt->rpar;
	if (f->mode & MODE_RECMASK)
		f->wpar = f->opt->wpar;
	f->xrun = (f->opt->mmc) ? XRUN_SYNC : XRUN_IGNORE;
	f->bufsz = f->dev->bufsz;
	f->round = f->dev->round;
	f->slot = dev_slotnew(f->dev, p->who, &ctl_sockops, f, f->opt->mmc);
	if (f->slot < 0)
		return 0;
	f->pstate = SOCK_INIT;
	return 1;
}

/*
 * Execute message in f->rmsg and change the state accordingly; return 1
 * on success, and 0 on failure, in which case the socket is destroyed.
 */
int
sock_execmsg(struct sock *f)
{
	struct amsg *m = &f->rmsg;
	struct abuf *obuf;
	unsigned int size, ctl;

	switch (ntohl(m->cmd)) {
	case AMSG_DATA:
#ifdef DEBUG
		if (debug_level >= 4) {
			sock_dbg(f);
			dbg_puts(": DATA message\n");
		}
#endif
		if (f->pstate != SOCK_MIDI && f->pstate != SOCK_RUN &&
		    f->pstate != SOCK_START && f->pstate != SOCK_READY) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": DATA, bad state\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		if (!(f->mode & (MODE_PLAY | MODE_MIDIOUT))) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": DATA not allowed in record-only mode\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		obuf = LIST_FIRST(&f->pipe.file.rproc->outs);
		if (f->pstate == SOCK_START && !ABUF_WOK(obuf)) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": DATA client violates flow control\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		size = ntohl(m->u.data.size);
		if (size % obuf->bpf != 0) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": unaligned data chunk\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		f->rstate = SOCK_RDATA;
		f->rtodo = size / obuf->bpf;
#ifdef DEBUG
		if (debug_level >= 2 &&
		    f->pstate != SOCK_MIDI && f->rtodo > f->rmax) {
			sock_dbg(f);
			dbg_puts(": received past current position, rtodo = ");
			dbg_putu(f->rtodo);
			dbg_puts(", rmax = ");
			dbg_putu(f->rmax);
			dbg_puts("\n");
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
#endif
		if (f->pstate != SOCK_MIDI)
			f->rmax -= f->rtodo;
		else
			f->fillpending += f->rtodo;
		if (f->rtodo == 0) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": zero-length data chunk\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		break;
	case AMSG_START:
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": START message\n");
		}
#endif
		if (f->pstate != SOCK_INIT) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": START, bad state\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		sock_allocbuf(f);
		f->rstate = SOCK_RMSG;
		f->rtodo = sizeof(struct amsg);
		break;
	case AMSG_STOP:
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": STOP message\n");
		}
#endif
		if (f->pstate != SOCK_RUN &&
		    f->pstate != SOCK_START && f->pstate != SOCK_READY) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": STOP, bad state\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		/*
		 * XXX: device could have desappeared at this point,
		 * see how this is fixed in wav.c
		 */
		if ((f->pstate == SOCK_START || f->pstate == SOCK_READY) &&
		    dev_slotstart(f->dev, f->slot))
			(void)sock_attach(f, 1);
		if (f->wstate != SOCK_WDATA || f->wtodo == 0)
			sock_freebuf(f);
		else
			f->pstate = SOCK_STOP;
		AMSG_INIT(m);
		m->cmd = htonl(AMSG_STOP);
		f->rstate = SOCK_RRET;
		f->rtodo = sizeof(struct amsg);
		break;
	case AMSG_SETPAR:
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": SETPAR message\n");
		}
#endif
		if (f->pstate != SOCK_INIT) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": SETPAR, bad state\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		if (!sock_setpar(f)) {
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		f->rtodo = sizeof(struct amsg);
		f->rstate = SOCK_RMSG;
		break;
	case AMSG_GETPAR:
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": GETPAR message\n");
		}
#endif
		if (f->pstate != SOCK_INIT) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": GETPAR, bad state\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		AMSG_INIT(m);
		m->cmd = htonl(AMSG_GETPAR);
		m->u.par.legacy_mode = f->mode;
		if (f->mode & MODE_PLAY) {
			m->u.par.bits = f->rpar.bits;
			m->u.par.bps = f->rpar.bps;
			m->u.par.sig = f->rpar.sig;
			m->u.par.le = f->rpar.le;
			m->u.par.msb = f->rpar.msb;
			m->u.par.rate = htonl(f->rpar.rate);
			m->u.par.pchan = htons(f->rpar.cmax - f->rpar.cmin + 1);
		}
		if (f->mode & MODE_RECMASK) {
			m->u.par.bits = f->wpar.bits;
			m->u.par.bps = f->wpar.bps;
			m->u.par.sig = f->wpar.sig;
			m->u.par.le = f->wpar.le;
			m->u.par.msb = f->wpar.msb;
			m->u.par.rate = htonl(f->wpar.rate);
			m->u.par.rchan = htons(f->wpar.cmax - f->wpar.cmin + 1);
		}
		m->u.par.appbufsz = htonl(f->bufsz);
		m->u.par.bufsz = htonl(
			f->bufsz + (f->dev->bufsz / f->dev->round) * f->round);
		m->u.par.round = htonl(f->round);
		f->rstate = SOCK_RRET;
		f->rtodo = sizeof(struct amsg);
		break;
	case AMSG_SETVOL:
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": SETVOL message\n");
		}
#endif
		if (f->pstate != SOCK_RUN && f->pstate != SOCK_START &&
		    f->pstate != SOCK_INIT && f->pstate != SOCK_READY) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": SETVOL, bad state\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		ctl = ntohl(m->u.vol.ctl);
		if (ctl > MIDI_MAXCTL) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": SETVOL, volume out of range\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		sock_setvol(f, ctl);
		if (f->slot >= 0)
			dev_slotvol(f->dev, f->slot, ctl);
		f->rtodo = sizeof(struct amsg);
		f->rstate = SOCK_RMSG;
		break;
	case AMSG_AUTH:
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": AUTH message\n");
		}
#endif
		if (f->pstate != SOCK_AUTH) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": AUTH, bad state\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		if (!sock_auth(f)) {
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		f->rstate = SOCK_RMSG;
		f->rtodo = sizeof(struct amsg);
		break;
	case AMSG_HELLO:
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": HELLO message\n");
		}
#endif
		if (f->pstate != SOCK_HELLO) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": HELLO, bad state\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		if (!sock_hello(f)) {
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		AMSG_INIT(m);
		m->cmd = htonl(AMSG_ACK);
		f->rstate = SOCK_RRET;
		f->rtodo = sizeof(struct amsg);
		break;
	case AMSG_BYE:
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": BYE message\n");
		}
#endif
		if (f->pstate != SOCK_INIT && f->pstate != SOCK_MIDI) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": BYE, bad state\n");
			}
#endif
		}
		aproc_del(f->pipe.file.rproc);
		return 0;
	default:
#ifdef DEBUG
		if (debug_level >= 1) {
			sock_dbg(f);
			dbg_puts(": unknown command in message\n");
		}
#endif
		aproc_del(f->pipe.file.rproc);
		return 0;
	}
	return 1;
}

/*
 * Create a new data/pos message.
 */
int
sock_buildmsg(struct sock *f)
{
	struct aproc *p;
	struct abuf *ibuf;
	unsigned int size, max;

	/*
	 * If pos changed, build a MOVE message.
	 */
	if (f->tickpending && f->delta >= 0) {
#ifdef DEBUG
		if (debug_level >= 4) {
			sock_dbg(f);
			dbg_puts(": building MOVE message, delta = ");
			dbg_puti(f->delta);
			dbg_puts("\n");
		}
#endif
		AMSG_INIT(&f->wmsg);
		f->wmsg.cmd = htonl(AMSG_MOVE);
		f->wmsg.u.ts.delta = htonl(f->delta);
		f->wtodo = sizeof(struct amsg);
		f->wstate = SOCK_WMSG;
		f->wmax += f->delta;
		f->fillpending += f->delta;
		f->delta = 0;
		f->tickpending = 0;
		return 1;
	}

	if (f->fillpending > 0) {
#ifdef DEBUG
		if (debug_level >= 4) {
			sock_dbg(f);
			dbg_puts(": building FLOWCTL message, count = ");
			dbg_puti(f->fillpending);
			dbg_puts("\n");
		}
#endif
		AMSG_INIT(&f->wmsg);
		f->wmsg.cmd = htonl(AMSG_FLOWCTL);	       
		f->wmsg.u.ts.delta = htonl(f->fillpending);
		f->wtodo = sizeof(struct amsg);
		f->wstate = SOCK_WMSG;
		f->rmax += f->fillpending;
		f->fillpending = 0;
		return 1;
	}

	/*
	 * if volume changed build a SETVOL message
	 */
	if (f->pstate >= SOCK_START && f->vol != f->lastvol) {
#ifdef DEBUG
		if (debug_level >= 4) {
			sock_dbg(f);
			dbg_puts(": building SETVOL message, vol = ");
			dbg_puti(f->vol);
			dbg_puts("\n");
		}
#endif
		AMSG_INIT(&f->wmsg);
		f->wmsg.cmd = htonl(AMSG_SETVOL);
		f->wmsg.u.vol.ctl = htonl(f->vol);
		f->wtodo = sizeof(struct amsg);
		f->wstate = SOCK_WMSG;
		f->lastvol = f->vol;
		return 1;
	}

	/*
	 * If data available, build a DATA message.
	 */
	p = f->pipe.file.wproc;
	ibuf = LIST_FIRST(&p->ins);
	if (ibuf && ABUF_ROK(ibuf)) {
#ifdef DEBUG
		if (debug_level >= 3 &&
		    f->pstate != SOCK_MIDI && ibuf->used > f->wmax) {
			sock_dbg(f);
			dbg_puts(": attempt to send past current position: used = ");
			dbg_putu(ibuf->used);
			dbg_puts(" wmax = ");
			dbg_putu(f->wmax);
			dbg_puts("\n");
		}
#endif
		size = ibuf->used;
		if (f->pstate == SOCK_MIDI) {
			if (size > AMSG_DATAMAX)
				size = AMSG_DATAMAX;			    
			if (size == 0)
				return 0;
		} else {
			max = AMSG_DATAMAX / ibuf->bpf;
			if (size > max)
				size = max;
			if (size > f->walign)
				size = f->walign;
			if (size > f->wmax)
				size = f->wmax;
			if (size == 0)
				return 0;
			f->walign -= size;
			f->wmax -= size;
			if (f->walign == 0)
				f->walign = f->round;
			size *= ibuf->bpf;
		}
		AMSG_INIT(&f->wmsg);
		f->wmsg.cmd = htonl(AMSG_DATA);
		f->wmsg.u.data.size = htonl(size);
		f->wtodo = sizeof(struct amsg);
		f->wstate = SOCK_WMSG;
		return 1;
	}
#ifdef DEBUG
	if (debug_level >= 4) {
		sock_dbg(f);
		dbg_puts(": no messages to build anymore, idling...\n");
	}
#endif
	f->wstate = SOCK_WIDLE;
	return 0;
}

/*
 * Read from the socket file descriptor, fill input buffer and update
 * the state. Return 1 if at least one message or 1 data byte was
 * processed, 0 if something blocked.
 */
int
sock_read(struct sock *f)
{
	int rc;

#ifdef DEBUG
	if (debug_level >= 4) {
		sock_dbg(f);
		dbg_puts(": reading ");
		dbg_putu(f->rtodo);
		dbg_puts(" todo\n");
	}
#endif
	switch (f->rstate) {
	case SOCK_RMSG:
		if (!sock_rmsg(f))
			return 0;
		if (!sock_execmsg(f))
			return 0;
		break;
	case SOCK_RDATA:
		if (!sock_rdata(f))
			return 0;
		if (f->rtodo == 0) {
			f->rstate = SOCK_RMSG;
			f->rtodo = sizeof(struct amsg);
		}
		/*
		 * XXX: sock_attach() may not start if there's not enough
		 *	samples queued, if so dev_slotstart() will trigger
		 *	other streams, but this one won't start.
		 */
		if (f->pstate == SOCK_READY && dev_slotstart(f->dev, f->slot))
			(void)sock_attach(f, 0);
		break;
	case SOCK_RRET:
#ifdef DEBUG
		if (debug_level >= 4) {
			sock_dbg(f);
			dbg_puts(": blocked by pending RRET message\n");
		}
#endif
		return 0;
	}
	for (;;) {
		/*
		 * send pending ACKs, initial positions, initial volumes
		 */
		f->pipe.file.state |= FILE_WINUSE;
		rc = sock_write(f);
		f->pipe.file.state &= ~FILE_WINUSE;
		if (f->pipe.file.state & FILE_ZOMB) {
			file_del(&f->pipe.file);
			return 0;
		}
		if (!rc)
			break;
	}
	return 1;
}

/*
 * Process messages to return.
 */
int
sock_return(struct sock *f)
{
	struct aproc *rp;

	while (f->rstate == SOCK_RRET) {
		if (!sock_wmsg(f, &f->rmsg, &f->rtodo))
			return 0;
#ifdef DEBUG
		if (debug_level >= 4) {
			sock_dbg(f);
			dbg_puts(": sent RRET message\n");
		}
#endif
		f->rstate = SOCK_RMSG;
		f->rtodo = sizeof(struct amsg);
		if (f->pipe.file.state & FILE_RINUSE)
			break;
		f->pipe.file.state |= FILE_RINUSE;
		for (;;) {
			/*
			 * in() may trigger rsock_done and destroy the
			 * wsock.
			 */
			rp = f->pipe.file.rproc;
			if (!rp)
				break;
#ifdef DEBUG
			if (debug_level >= 4) {
				aproc_dbg(rp);
				dbg_puts(": in\n");
			}
#endif
			if (!rp->ops->in(rp, NULL)) {
				break;
			}
		}
		f->pipe.file.state &= ~FILE_RINUSE;
		if (f->pipe.file.state & FILE_ZOMB) {
			file_del(&f->pipe.file);
			return 0;
		}
	}
	return 1;
}

/*
 * Write messages and data on the socket file descriptor. Return 1 if
 * at least one message or one data byte was processed, 0 if something
 * blocked.
 */
int
sock_write(struct sock *f)
{
#ifdef DEBUG
	if (debug_level >= 4) {
		sock_dbg(f);
		dbg_puts(": writing");
		if (f->wstate != SOCK_WIDLE) {
			dbg_puts(" todo = ");
			dbg_putu(f->wtodo);
		}
		dbg_puts("\n");
	}
#endif
	switch (f->wstate) {
	case SOCK_WMSG:
		if (!sock_wmsg(f, &f->wmsg, &f->wtodo))
			return 0;
		if (ntohl(f->wmsg.cmd) != AMSG_DATA) {
			f->wstate = SOCK_WIDLE;
			f->wtodo = 0xdeadbeef;
			break;
		}
		/*
		 * XXX: why not set f->wtodo in sock_wmsg() ?
		 */
		f->wstate = SOCK_WDATA;
		f->wtodo = ntohl(f->wmsg.u.data.size) /
		    LIST_FIRST(&f->pipe.file.wproc->ins)->bpf;
		/* PASSTHROUGH */
	case SOCK_WDATA:
		if (!sock_wdata(f))
			return 0;
		if (f->wtodo > 0)
			break;
		f->wstate = SOCK_WIDLE;
		f->wtodo = 0xdeadbeef;
		if (f->pstate == SOCK_STOP)
			sock_freebuf(f);
		/* PASSTHROUGH */
	case SOCK_WIDLE:
		if (!sock_return(f))
			return 0;
		if (!sock_buildmsg(f))
			return 0;
		break;
#ifdef DEBUG
	default:
		sock_dbg(f);
		dbg_puts(": bad writing end state\n");
		dbg_panic();
#endif
	}
	return 1;
}
@


1.67
log
@Make the client wait for the first flow control message rather than
assuming it can send a full initial data buffer. This requires protocol
version bump (but no library version bump).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.66
log
@Use dedicated messages for flow control instead of abusing clock tick
messages and enable flow control for MIDI. Since this requires protocol
version bump, both sndiod and libsndio must be kept up to date to work
together.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.65 2012/10/27 11:54:27 ratchov Exp $	*/
d401 2
a402 1
		f->rmax = bufsz * aparams_bpf(&f->rpar);
a411 1
	f->fillpending = 0;
a553 1
	f->fillpending = 0;
d560 2
@


1.65
log
@include netinet/in.h to get htons & friends prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.64 2012/04/11 21:17:32 ratchov Exp $	*/
d338 1
a338 2
	f->startpos = 0;
	f->startpending = 0;
d382 1
a382 1
	f->startpending = 0;
a409 1
	f->startpos = 0;
d411 1
a411 1
	f->startpending = 0;
d552 3
a554 2
	f->startpos = dev_getpos(f->dev) * (int)f->round / (int)f->dev->round;
	f->startpending = 1;
d560 1
a560 1
		dbg_puti(f->startpos);
d962 1
d1167 2
d1430 1
a1430 1
	 * Send initial position
d1432 1
a1432 1
	if (f->startpending) {
d1436 2
a1437 2
			dbg_puts(": building POS message, pos = ");
			dbg_puti(f->startpos);
d1442 2
a1443 3
		f->wmsg.cmd = htonl(AMSG_POS);
		f->wmsg.u.ts.delta = htonl(f->startpos);
		f->rmax += f->startpos;
d1446 4
a1449 1
		f->startpending = 0;
d1453 1
a1453 4
	/*
	 * If pos changed, build a MOVE message.
	 */
	if (f->tickpending) {
d1457 2
a1458 2
			dbg_puts(": building MOVE message, delta = ");
			dbg_puti(f->delta);
a1461 2
		f->wmax += f->delta;
		f->rmax += f->delta;
d1463 2
a1464 2
		f->wmsg.cmd = htonl(AMSG_MOVE);
		f->wmsg.u.ts.delta = htonl(f->delta);
d1467 2
a1468 2
		f->delta = 0;
		f->tickpending = 0;
@


1.64
log
@In the "reply" code path, lock the socket while invoking the
write-end code from the read-end code, and don't forget to check
if the socket was not destroyed. Fixes very rare random crashes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.63 2012/04/11 06:05:43 ratchov Exp $	*/
d20 1
@


1.63
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.62 2011/11/20 22:54:51 ratchov Exp $	*/
d1557 2
d1602 8
a1609 1
		if (!sock_write(f))
d1643 1
a1643 1
			if (!rp || !rp->ops->in(rp, NULL))
d1645 9
d1656 2
a1657 1
		if (f->pipe.file.wproc == NULL)
d1659 1
@


1.62
log
@Move mmc/mtc and volume control bits from struct aproc to struct
dev. Allows volume settings to be saved while the device is kept
closed. Besides that, no behabiour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.61 2011/11/15 08:05:22 ratchov Exp $	*/
d80 1
a80 1
void sock_setvol(void *, unsigned);
d84 1
a84 1
void sock_locreq(void *, unsigned);
d94 1
a94 1
unsigned sock_sesrefs = 0;		/* connections to the session */
d392 1
a392 1
	unsigned bufsz;
d438 1
a438 1
sock_setvol(void *arg, unsigned vol)
d495 1
a495 1
sock_locreq(void *arg, unsigned mmcpos)
d531 1
a531 1
	unsigned rch, wch;
d609 1
a609 1
	unsigned count;
d646 1
a646 1
sock_wmsg(struct sock *f, struct amsg *m, unsigned *ptodo)
d648 1
a648 1
	unsigned count;
d688 1
a688 1
	unsigned n;
d722 1
a722 1
	unsigned n;
d756 1
a756 1
	unsigned min, max, rate, pchan, rchan, appbufsz;
d986 1
a986 1
	unsigned mode;
d1096 1
a1096 1
	unsigned size, ctl;
d1424 1
a1424 1
	unsigned size, max;
@


1.61
log
@Add a "device number" component in sndio(7) device names, allowing a
single aucat instance to handle all audio and MIDI services. Since
this partially breaks compatibility, this is a opportunitiy to fix few
other design mistakes (eg ':' being used by inet6, type name vs api
name confusion, etc..). This leads to the following names:

        type[@@hostname][,unit]/devnum[.option]

The device number is the minor device number for direct hardware
access (ie the 'N' in /dev/audioN). For aucat, this is the occurence
number of the -f (or -M) option.

There's a compatibility hook to keep old names working if only one
aucat server is running.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.60 2011/06/03 16:22:34 ratchov Exp $	*/
a64 1
	struct aproc *midi;
d66 3
a68 4
	midi = f->dev ? f->dev->midi : NULL;
	if (f->slot >= 0 && APROC_OK(midi)) {
		dbg_puts(midi->u.ctl.slot[f->slot].name);
		dbg_putu(midi->u.ctl.slot[f->slot].unit);
d122 1
a122 1
			ctl_slotdel(f->dev->midi, f->slot);
d227 1
a227 1
			ctl_slotdel(f->dev->midi, f->slot);
d376 1
a376 1
		ctl_slotstop(f->dev->midi, f->slot);
d429 1
a429 1
		if (ctl_slotstart(f->dev->midi, f->slot))
d587 1
a587 1
		if (ctl_slotstart(f->dev->midi, f->slot)) {
d927 2
a928 5
		if (APROC_OK(f->dev->midi)) {
			dbg_puts(f->dev->midi->u.ctl.slot[f->slot].name);
			dbg_putu(f->dev->midi->u.ctl.slot[f->slot].unit);
		} else
			dbg_puts(f->pipe.file.name);
d1080 1
a1080 3
	f->slot = ctl_slotnew(f->dev->midi, p->who,
	    &ctl_sockops, f,
	    f->opt->mmc);
d1221 1
a1221 1
		    ctl_slotstart(f->dev->midi, f->slot))
d1332 1
a1332 1
			ctl_slotvol(f->dev->midi, f->slot, ctl);
d1581 1
a1581 1
		 *	samples queued, if so ctl_slotstart() will trigger
d1584 1
a1584 1
		if (f->pstate == SOCK_READY && ctl_slotstart(f->dev->midi, f->slot))
@


1.60
log
@factor tests for f->opt->join flag, no behaviour change
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.59 2011/05/02 22:32:29 ratchov Exp $	*/
d1036 1
a1036 1
	f->opt = opt_byname(p->opt);
d1039 10
@


1.59
log
@Add missing byter order conversions in message headers. Fixes the case
when the server and the client are not of the same endianness.
Found by naddy.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.58 2011/05/02 22:20:18 ratchov Exp $	*/
d533 1
d571 5
d577 1
a577 4
	    rbuf, &f->rpar,
	    f->opt->join ? f->opt->rpar.cmax - f->opt->rpar.cmin + 1 : 0,
	    wbuf, &f->wpar, 
	    f->opt->join ? f->opt->wpar.cmax - f->opt->wpar.cmin + 1 : 0,
@


1.58
log
@fix string containing state names used for debug printf()s,
add the missing SOCK_AUTH state
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.57 2011/04/28 06:19:57 ratchov Exp $	*/
d755 6
a760 1
	unsigned min, max, rate;
d807 5
a811 5
	if (AMSG_ISSET(p->rchan) && (f->mode & MODE_RECMASK)) {
		if (p->rchan < 1)
			p->rchan = 1;
		if (p->rchan > NCHAN_MAX)
			p->rchan = NCHAN_MAX;
d813 1
a813 1
		f->wpar.cmax = f->opt->wpar.cmin + p->rchan - 1;
d827 5
a831 5
	if (AMSG_ISSET(p->pchan) && (f->mode & MODE_PLAY)) {
		if (p->pchan < 1)
			p->pchan = 1;
		if (p->pchan > NCHAN_MAX)
			p->pchan = NCHAN_MAX;
d833 1
a833 1
		f->rpar.cmax = f->opt->rpar.cmin + p->pchan - 1;
d847 9
a855 9
	if (AMSG_ISSET(p->rate)) {
		if (p->rate < RATE_MIN)
			p->rate = RATE_MIN;
		if (p->rate > RATE_MAX)
			p->rate = RATE_MAX;
		f->round = dev_roundof(f->dev, p->rate);
		f->rpar.rate = f->wpar.rate = p->rate;
		if (!AMSG_ISSET(p->appbufsz)) {
			p->appbufsz = f->dev->bufsz / f->dev->round * f->round;
d860 1
a860 1
				dbg_putu(p->appbufsz);
d869 1
a869 1
			dbg_putu(p->rate);
d902 1
a902 1
	if (AMSG_ISSET(p->appbufsz)) {
d908 7
a914 7
		p->appbufsz += f->round - 1;
		p->appbufsz -= p->appbufsz % f->round;
		if (p->appbufsz < min)
			p->appbufsz = min;
		if (p->appbufsz > max)
			p->appbufsz = max;
		f->bufsz = p->appbufsz;
d988 1
d990 1
d997 1
a997 1
		dbg_putx(p->mode);
d1014 1
a1014 1
	switch (p->mode) {
d1027 1
a1027 1
			dbg_putx(p->mode);
d1038 3
a1040 3
	if ((p->mode & MODE_REC) && (f->opt->mode & MODE_MON)) {
		p->mode &= ~MODE_REC;
		p->mode |= MODE_MON;
d1043 1
a1043 1
	f->mode = (p->mode & f->opt->mode) & f->dev->mode;
d1052 1
a1052 1
	if (f->mode != p->mode) {
d1090 1
d1092 1
a1092 1
	switch (m->cmd) {
d1132 2
a1133 1
		if (m->u.data.size % obuf->bpf != 0) {
d1144 1
a1144 1
		f->rtodo = m->u.data.size / obuf->bpf;
d1222 1
a1222 1
		m->cmd = AMSG_STOP;
d1268 1
a1268 1
		m->cmd = AMSG_GETPAR;
d1276 2
a1277 2
			m->u.par.rate = f->rpar.rate;
			m->u.par.pchan = f->rpar.cmax - f->rpar.cmin + 1;
d1285 2
a1286 2
			m->u.par.rate = f->wpar.rate;
			m->u.par.rchan = f->wpar.cmax - f->wpar.cmin + 1;
d1288 4
a1291 4
		m->u.par.appbufsz = f->bufsz;
		m->u.par.bufsz =
		    f->bufsz + (f->dev->bufsz / f->dev->round) * f->round;
		m->u.par.round = f->round;
d1313 2
a1314 1
		if (m->u.vol.ctl > MIDI_MAXCTL) {
d1324 1
a1324 1
		sock_setvol(f, m->u.vol.ctl);
d1326 1
a1326 1
			ctl_slotvol(f->dev->midi, f->slot, m->u.vol.ctl);
d1376 1
a1376 1
		m->cmd = AMSG_ACK;
d1433 2
a1434 2
		f->wmsg.cmd = AMSG_POS;
		f->wmsg.u.ts.delta = f->startpos;
d1457 2
a1458 2
		f->wmsg.cmd = AMSG_MOVE;
		f->wmsg.u.ts.delta = f->delta;
d1479 2
a1480 2
		f->wmsg.cmd = AMSG_SETVOL;
		f->wmsg.u.vol.ctl = f->vol;
d1527 2
a1528 2
		f->wmsg.cmd = AMSG_DATA;
		f->wmsg.u.data.size = size;
d1661 1
a1661 1
		if (f->wmsg.cmd != AMSG_DATA) {
d1670 1
a1670 1
		f->wtodo = f->wmsg.u.data.size /
@


1.57
log
@Implement a new authentication method allowing aucat and midicat to
work over TCP, for instance, to expose the sound card of one machine
with other machines of the network.

The first client generates a 128-bit random number (aka the
session cookie), saves it in $HOME/.aucat_cookie and sends it to the
server. Successive clients load the cookie from $HOME/.aucat_cookie
and send it to the server but the server accepts only clients whose
cookie matches the session cookie. When all clients are gone, the
session is over, and another cookie could start a new session, and so
on.

TCP is enabled on the server with the new -L option, and on the client
side hostnames are specified with a new optional component in the
device name.

hints from damien, dlg and deraadt, tweaks from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.56 2011/04/16 11:24:18 ratchov Exp $	*/
d61 1
a61 1
		"hel", "ini", "sta", "rdy", "run", "stp", "mid"
@


1.56
log
@Since aucat supports any parameter combination sio_getcap() doesn't
need to query the server for supported parameters. So stop using the
AMSG_GETCAP message, and remove it completely from the aucat protocol.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.55 2011/04/16 10:52:22 ratchov Exp $	*/
d96 2
a97 2
unsigned sock_sesrefs = 0;	/* connections to the session */
uid_t sock_sesuid;		/* owner of the session */
d104 2
a105 1
	sock_sesrefs--;
a325 21
	uid_t uid, gid;

	/*
	 * ensure that all connections belong to the same user,
	 * for privacy reasons.
	 *
	 * XXX: is there a portable way of doing this ?
	 */
	if (getpeereid(fd, &uid, &gid) < 0) {
		close(fd);
		return NULL;
	}
	if (sock_sesrefs == 0) {
		/* start a new session */
		sock_sesuid = uid;
	} else if (uid != sock_sesuid) {
		/* session owned by another user, drop connection */
		close(fd);
		return NULL;
	}
	sock_sesrefs++;
d332 1
a332 1
	f->pstate = SOCK_HELLO;
d963 17
d1319 24
@


1.55
log
@Make aucat audio and midi backends share the same code to communicate
with the server. As we're at it use the same protocol for midi and
audio. Now, both audio and midi code use the same SNDIO_DEBUG environment
variable to turn on/off DPRINTF's.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.54 2011/04/08 13:00:57 ratchov Exp $	*/
a1285 29
		f->rstate = SOCK_RRET;
		f->rtodo = sizeof(struct amsg);
		break;
	case AMSG_GETCAP:
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": GETCAP message\n");
		}
#endif
		if (f->pstate != SOCK_INIT) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": GETCAP, bad state\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
		AMSG_INIT(m);
		m->cmd = AMSG_GETCAP;
		m->u.cap.rate = f->dev->rate;
		m->u.cap.pchan = (f->opt->mode & MODE_PLAY) ?
		    (f->opt->rpar.cmax - f->opt->rpar.cmin + 1) : 0;
		m->u.cap.rchan = (f->opt->mode & (MODE_PLAY | MODE_REC)) ?
		    (f->opt->wpar.cmax - f->opt->wpar.cmin + 1) : 0;
		m->u.cap.bits = ADATA_BITS;
		m->u.cap.bps = sizeof(adata_t);
@


1.54
log
@When a message is read (and processed), always call sock_write(), to
send any pending messages resulting from the processing (ACKs, position
changes, volume changes). In theory the previous approach didn't
ensuire that outgoing messages are not reordered.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.53 2010/11/04 17:55:28 ratchov Exp $	*/
d710 1
a710 1
	if (f->pstate != SOCK_MIDI && f->rtodo == 0) {
d722 6
a727 11
	if (f->pstate == SOCK_MIDI) {
		if (!rfile_do(p, obuf->len, NULL))
			return 0;
	} else {
		if (!rfile_do(p, f->rtodo, &n))
			return 0;
		f->rtodo -= n;
		if (f->pstate == SOCK_START) {
			if (!ABUF_WOK(obuf) || (f->pipe.file.state & FILE_EOF))
				f->pstate = SOCK_READY;
		}
d744 1
a744 1
	if (f->pstate != SOCK_MIDI && f->wtodo == 0) {
d755 1
a755 1
	if (f->pstate != SOCK_MIDI && ibuf == NULL) {
d765 3
a767 8
	if (f->pstate == SOCK_MIDI) {
		if (!wfile_do(p, ibuf->len, NULL))
			return 0;
	} else {
		if (!wfile_do(p, f->wtodo, &n))
			return 0;
		f->wtodo -= n;
	}
d1095 2
a1096 2
		if (f->pstate != SOCK_RUN && f->pstate != SOCK_START &&
		    f->pstate != SOCK_READY) {
d1106 1
a1106 1
		if (!(f->mode & MODE_PLAY)) {
d1140 2
a1141 1
		if (f->rtodo > f->rmax && debug_level >= 2) {
d1152 2
a1153 1
		f->rmax -= f->rtodo;
d1216 1
a1216 1
		m->cmd = AMSG_ACK;
d1385 1
a1385 1
		if (f->pstate != SOCK_INIT) {
a1417 12
	if (f->pstate == SOCK_MIDI) {
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": switching to MIDI mode\n");
		}
#endif
		f->wstate = SOCK_WDATA;
		f->wtodo = 0;
		return 1;
	}

d1492 2
a1493 1
		if (ibuf->used > f->wmax && debug_level >= 3) {
a1501 1
		max = AMSG_DATAMAX / ibuf->bpf;
d1503 21
a1523 12
		if (size > f->walign)
			size = f->walign;
		if (size > f->wmax)
			size = f->wmax;
		if (size > max)
			size = max;
		if (size == 0)
			return 0;
		f->walign -= size;
		f->wmax -= size;
		if (f->walign == 0)
			f->walign = f->round;
d1526 1
a1526 1
		f->wmsg.u.data.size = size * ibuf->bpf;
d1567 1
a1567 1
		if (f->pstate != SOCK_MIDI && f->rtodo == 0) {
d1615 2
a1616 7
		if (f->pstate == SOCK_MIDI && (f->mode & MODE_MIDIOUT)) {
			f->rstate = SOCK_RDATA;
			f->rtodo = 0;
		} else {
			f->rstate = SOCK_RMSG;
			f->rtodo = sizeof(struct amsg);
		}
d1674 1
a1674 1
		if (f->pstate == SOCK_MIDI || f->wtodo > 0)
@


1.53
log
@Replace ``short'' by a new ``adata_t'' typedef corresponding to
audio samples and cleanup ADATA_XXX macros. This allows easilly
switching to 24 bit fixed point arithmetic by simply redefining
the adata_t typedef to int and updating ADATA_XXX macros. No
object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.52 2010/10/21 19:10:52 ratchov Exp $	*/
a597 8

	/*
	 * Send the initial position, if needed.
	 */
	for (;;) {
		if (!sock_write(f))
			break;
	}
a1412 18
	if (f->rstate == SOCK_RRET) {
		if (f->wstate != SOCK_WIDLE ||
		    !sock_wmsg(f, &f->rmsg, &f->rtodo))
			return 0;
#ifdef DEBUG
		if (debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": RRET done\n");
		}
#endif
		if (f->pstate == SOCK_MIDI && (f->mode & MODE_MIDIOUT)) {
			f->rstate = SOCK_RDATA;
			f->rtodo = 0;
		} else {
			f->rstate = SOCK_RMSG;
			f->rtodo = sizeof(struct amsg);
		}
	}
d1599 7
d1663 6
a1668 3
		dbg_puts(": writing ");
		dbg_putu(f->wtodo);
		dbg_puts(" todo\n");
@


1.52
log
@fix style and typos in messages and comments
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.51 2010/10/21 18:57:42 ratchov Exp $	*/
d1329 2
a1330 2
		m->u.cap.bits = sizeof(short) * 8;
		m->u.cap.bps = sizeof(short);
@


1.51
log
@use MODE_xxx and XRUN_xxx macros everywhere, and zap corresponding
AMSG_xxx macros, which in turns simplifies the code
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.50 2010/06/05 16:00:52 ratchov Exp $	*/
d495 3
a497 1
}/*
d1219 1
a1223 1
		}
d1610 1
a1610 1
		 *	samples queues, if so ctl_slotstart() will trigger
@


1.50
log
@don't prime server buffers, because it's ugly and conceptually
complicated. Instead, request clients to provide enough samples
and start with buffers full.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.49 2010/06/05 12:45:48 ratchov Exp $	*/
d60 3
a62 1
	static char *pstates[] = { "hel", "ini", "sta", "rdy", "run", "mid" };
d185 1
a185 1
	if (f->mode & AMSG_RECMASK)
d284 1
a284 1
	if (!(f->mode & AMSG_RECMASK))
d356 1
a356 1
	f->xrun = AMSG_IGNORE;
d418 1
a418 1
	if (f->mode & AMSG_PLAY) {
d425 1
a425 1
	if (f->mode & AMSG_RECMASK) {
d447 1
a447 1
	if (f->mode & AMSG_PLAY) {
d495 1
a495 3
}

/*
d545 1
a545 1
 * Attach play and/or record buffers to dev->mix and/or dev->sub.
d594 1
a594 1
	if (f->mode & AMSG_PLAY)
d838 1
a838 1
	if (AMSG_ISSET(p->rchan) && (f->mode & AMSG_RECMASK)) {
d858 1
a858 1
	if (AMSG_ISSET(p->pchan) && (f->mode & AMSG_PLAY)) {
d908 3
a910 3
		if (p->xrun != AMSG_IGNORE &&
		    p->xrun != AMSG_SYNC &&
		    p->xrun != AMSG_ERROR) {
d922 2
a923 2
		if (f->opt->mmc && f->xrun == AMSG_IGNORE)
			f->xrun = AMSG_SYNC;
d934 1
a934 1
		rate = (f->mode & AMSG_PLAY) ? f->rpar.rate : f->wpar.rate;
d964 1
a964 1
		if (f->mode & AMSG_PLAY) {
d968 1
a968 1
		if (f->mode & AMSG_RECMASK) {
d982 1
a982 1
sock_midiattach(struct sock *f, unsigned mode)
d986 1
a986 1
	if (mode & AMSG_MIDIOUT) {
d990 1
a990 1
	if (mode & AMSG_MIDIIN) {
d994 1
d1008 2
a1009 2
		dbg_puts(">, proto = ");
		dbg_putx(p->proto);
d1021 20
a1040 1
			dbg_puts(": bad version\n");
d1050 4
d1055 1
a1055 3

	if (APROC_OK(f->dev->midi) && (p->proto & (AMSG_MIDIIN | AMSG_MIDIOUT))) {
		if (p->proto & ~(AMSG_MIDIIN | AMSG_MIDIOUT)) {
d1057 6
a1062 6
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": ");
				dbg_putx(p->proto);
				dbg_puts(": bad hello protocol\n");
			}
d1064 1
a1064 17
			return 0;
		}
		f->mode = p->proto;
		f->pstate = SOCK_MIDI;
		sock_midiattach(f, p->proto);
		return 1;
	}
	if (f->opt->mode & MODE_RECMASK)
		f->wpar = f->opt->wpar;
	if (f->opt->mode & MODE_PLAY)
		f->rpar = f->opt->rpar;
	if (f->opt->mmc)
		f->xrun = AMSG_SYNC;
	f->bufsz = f->dev->bufsz;
	f->round = f->dev->round;
	if ((p->proto & ~(AMSG_PLAY | AMSG_REC)) != 0 ||
	    (p->proto &  (AMSG_PLAY | AMSG_REC)) == 0) {
d1068 1
a1068 3
			dbg_puts(": ");
			dbg_putx(p->proto);
			dbg_puts(": unsupported hello protocol\n");
d1073 3
a1075 39
	f->mode = 0;
	if (p->proto & AMSG_PLAY) {
		if (!APROC_OK(f->dev->mix) || !(f->opt->mode & MODE_PLAY)) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": playback not available\n");
			}
#endif
			return 0;
		}
		f->mode |= AMSG_PLAY;
	}
	if (p->proto & AMSG_REC) {
		if (!(APROC_OK(f->dev->sub)    && (f->opt->mode & MODE_REC)) &&
		    !(APROC_OK(f->dev->submon) && (f->opt->mode & MODE_MON))) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": recording not available\n");
			}
#endif
			return 0;
		}
		f->mode |= (f->opt->mode & MODE_MON) ? AMSG_MON : AMSG_REC;
	}
	if (APROC_OK(f->dev->midi)) {
		f->slot = ctl_slotnew(f->dev->midi,
		     p->who, &ctl_sockops, f,
		     f->opt->mmc);
		if (f->slot < 0) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": out of mixer slots\n");
			}
#endif
			return 0;
		}
d1077 12
d1122 1
a1122 1
		if (!(f->mode & AMSG_PLAY)) {
d1278 1
a1278 1
		if (f->mode & AMSG_PLAY) {
d1287 1
a1287 1
		if (f->mode & AMSG_RECMASK) {
d1429 1
a1429 1
		if (f->pstate == SOCK_MIDI && (f->mode & AMSG_MIDIOUT)) {
d1643 1
a1643 1
		if (f->pstate == SOCK_MIDI && (f->mode & AMSG_MIDIOUT)) {
@


1.49
log
@Don't send the initial position as a clock tick with a negative delta.
Add a new ``initial position'' message which is simpler. No bahaviour
change, except effects of the protocol version crank.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.48 2010/06/04 06:15:28 ratchov Exp $	*/
d412 1
d414 1
d417 1
a417 1
		rbuf = abuf_new(f->bufsz, &f->rpar);
d421 1
d424 1
a424 1
		wbuf = abuf_new(f->bufsz, &f->wpar);
d427 1
a430 2
	f->wmax = 0;
	f->rmax = f->bufsz;
d438 2
a932 18
	if (AMSG_ISSET(p->bufsz)) {
		/*
		 * XXX: bufsz will become read-only, but for now
		 *      allow old library to properly work
		 */
#ifdef DEBUG
		if (debug_level >= 1) {
			sock_dbg(f);
			dbg_puts(": legacy client using ");
			dbg_putx(p->bufsz);
			dbg_puts("fr total buffer size\n");
		}
#endif
		min = (f->dev->bufsz / f->dev->round) * f->round;
		if (p->bufsz < min)
			p->bufsz = min;
		p->appbufsz = p->bufsz - min;
	}
d1497 1
@


1.48
log
@Allow the audio device to be opened only while it's actually used.
This is necessary for uaudio devices, for instance to start aucat
before the device is plugged. Or to unplug a device whithout
having to restart aucat when another device is plugged.  This is
controlled with the new -a option.

Allow multiple audio devices to be used concurently, i.e.
multiple ``-f devname'' options to be used; -f options must follow
per-device options, which is what we do for other options.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.47 2010/05/08 15:35:45 ratchov Exp $	*/
d357 1
d426 1
d568 1
a568 1
	f->delta = dev_getpos(f->dev) * (int)f->round / (int)f->dev->round;
d575 1
a575 1
		dbg_puti(f->delta);
d1497 21
d1520 1
a1520 1
	if ((f->tickpending && f->delta > 0) || f->startpending) {
d1524 1
a1524 1
			dbg_puts(": building POS message, delta = ");
d1530 1
a1530 2
		if (f->delta > 0)
			f->rmax += f->delta;
a1537 1
		f->startpending = 0;
@


1.47
log
@prime play buffers as soon as the device is opened, otherwise a
midi client could start it with empty buffers, in turn hurting
audio clients.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.46 2010/05/02 11:54:27 ratchov Exp $	*/
d63 1
d65 4
a68 3
	if (f->slot >= 0 && APROC_OK(dev_midi)) {
		dbg_puts(dev_midi->u.ctl.slot[f->slot].name);
		dbg_putu(dev_midi->u.ctl.slot[f->slot].unit);
d83 1
d90 2
a91 1
	sock_locreq
d98 1
a98 1
sock_close(struct file *f)
d100 2
d103 5
a107 2
	pipe_close(f);
	dev_unref();
d121 1
a121 1
			ctl_slotdel(dev_midi, f->slot);
d226 1
a226 1
			ctl_slotdel(dev_midi, f->slot);
a349 4
	if (!dev_ref()) {
		close(fd);
		return NULL;
	}
d352 2
a353 7
	f->opt = opt_byname("default");
	if (f->opt) {
		if (f->opt->mode & MODE_RECMASK)
			f->wpar = f->opt->wpar;
		if (f->opt->mode & MODE_PLAY)
			f->rpar = f->opt->rpar;
	}
a354 2
	f->bufsz = dev_bufsz;
	f->round = dev_round;
d395 1
a395 1
		ctl_slotstop(dev_midi, f->slot);
d443 1
a443 1
		if (ctl_slotstart(dev_midi, f->slot))
d468 1
a468 1
	dev_setvol(rbuf, MIDI_TO_ADATA(vol));
d522 18
a539 1
 * Attach play and/or record buffers to dev_mix and/or dev_sub.
d560 1
a560 1
	dev_wakeup();
d566 1
a566 1
	f->delta = dev_getpos() * (int)f->round / (int)dev_round;
d582 1
a582 1
	dev_attach(f->pipe.file.name, f->mode,
d589 1
a589 1
		dev_setvol(rbuf, MIDI_TO_ADATA(f->vol));
d606 1
a606 1
		if (ctl_slotstart(dev_midi, f->slot)) {
d877 1
a877 1
		f->round = dev_roundof(p->rate);
d880 1
a880 1
			p->appbufsz = dev_bufsz / dev_round * f->round;
d940 1
a940 1
		min = (dev_bufsz / dev_round) * f->round;
d948 1
a948 1
		max = 1 + rate / dev_round;
d969 3
a971 3
		if (f->slot >= 0 && dev_midi) {
			dbg_puts(dev_midi->u.ctl.slot[f->slot].name);
			dbg_putu(dev_midi->u.ctl.slot[f->slot].unit);
d1006 1
a1006 1
	dev_midiattach(rbuf, wbuf);
d1037 8
a1044 4
	/*
	 * XXX : dev_midi can no longer be NULL, right ?
	 */
	if (APROC_OK(dev_midi) && (p->proto & (AMSG_MIDIIN | AMSG_MIDIOUT))) {
a1060 3
	f->opt = opt_byname(p->opt);
	if (f->opt == NULL)
		return 0;
d1067 2
d1083 1
a1083 1
		if (!APROC_OK(dev_mix) || !(f->opt->mode & MODE_PLAY)) {
d1095 2
a1096 2
		if (!(APROC_OK(dev_sub)    && (f->opt->mode & MODE_REC)) &&
		    !(APROC_OK(dev_submon) && (f->opt->mode & MODE_MON))) {
d1107 2
a1108 2
	if (APROC_OK(dev_midi)) {
		f->slot = ctl_slotnew(dev_midi,
d1255 1
a1255 1
		    ctl_slotstart(dev_midi, f->slot))
d1330 1
a1330 1
		    f->bufsz + (dev_bufsz / dev_round) * f->round;
d1354 1
a1354 1
		m->u.cap.rate = dev_rate;
d1394 1
a1394 1
			ctl_slotvol(dev_midi, f->slot, m->u.vol.ctl);
d1623 1
a1623 1
		if (f->pstate == SOCK_READY && ctl_slotstart(dev_midi, f->slot))
@


1.46
log
@Clean up device handling code to clarify different initialization phases
and different device states. Split initialization in two phases:
first global variables are initialized then the audio hardware is opened.
Allow devices that don't support full-duplex to work in play-only or
record-only mode, even if ``-m play'' or ``-m rec'' are not specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.45 2010/04/24 06:18:23 ratchov Exp $	*/
d545 1
a545 1
	dev_wakeup(1);
@


1.45
log
@rename ibuflist/obuflist -> ins/outs to cut long lines
from Thomas Pfaff, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.44 2010/04/22 17:43:30 ratchov Exp $	*/
d98 1
d337 6
a342 1
	if (f == NULL)
d344 1
d542 6
d1532 5
a1536 1
			dbg_puts(": attempt to send past current position\n");
@


1.44
log
@Allow multiple users to share the same aucat server. If aucat is
run by root, it binds a shared address to the socket, cranks the
process priority and drops privileges. sio_open(3) will try to
connect to the private socket first (if any), then to the shared
socket. Only one user may have connections to aucat at a given
time.

based on discussions with henning, pyr and others
ok jacek, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.43 2010/04/21 06:13:07 ratchov Exp $	*/
d126 1
a126 1
	obuf = LIST_FIRST(&p->obuflist);
d243 1
a243 1
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
d387 2
a388 2
	wbuf = LIST_FIRST(&f->pipe.file.wproc->ibuflist);
	rbuf = LIST_FIRST(&f->pipe.file.rproc->obuflist);
d453 1
a453 1
	rbuf = LIST_FIRST(&f->pipe.file.rproc->obuflist);
d524 2
a525 2
	rbuf = LIST_FIRST(&f->pipe.file.rproc->obuflist);
	wbuf = LIST_FIRST(&f->pipe.file.wproc->ibuflist);
d689 1
a689 1
	obuf = LIST_FIRST(&p->obuflist);
d730 1
a730 1
	ibuf = LIST_FIRST(&p->ibuflist);
d1133 1
a1133 1
		obuf = LIST_FIRST(&f->pipe.file.rproc->obuflist);
d1514 1
a1514 1
	ibuf = LIST_FIRST(&p->ibuflist);
d1676 1
a1676 1
		    LIST_FIRST(&f->pipe.file.wproc->ibuflist)->bpf;
@


1.43
log
@adds the necessary bits to join channels (ex stereo->mono) or
expand channels (ex mono->stereo).  It's switched on/off with
the ``-j'' option, (default is "on").
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.42 2010/04/06 20:07:01 ratchov Exp $	*/
d18 3
d41 1
d46 1
a46 1
       	pipe_close,
d90 10
d313 21
@


1.42
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.41 2010/04/03 17:59:17 ratchov Exp $	*/
d520 5
a524 1
	    rbuf, &f->rpar, wbuf, &f->wpar, f->xrun, f->opt->maxweight);
@


1.41
log
@backout last change, committed by mistake, sorry...
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.39 2010/01/15 22:17:44 ratchov Exp $	*/
a16 6
/*
 * TODO:
 *
 *	change f->bufsz to contain only socket-side buffer,
 *	because it's less error prone
 */
d33 1
a33 1
int sock_attach(struct sock *, int);
d56 1
a56 1
	static char *pstates[] = { "hel", "ini", "sta", "run", "mid" };
d60 1
a60 1
	if (f->slot >= 0 && dev_midi) {
d76 2
d81 3
a83 1
	sock_startreq
d159 1
a159 1
	if (f->mode & AMSG_REC)
d258 1
a258 1
	if (!(f->mode & AMSG_REC))
d307 1
a307 1
		if (dev_sub)
d309 1
a309 1
		if (dev_mix)
d317 1
d323 1
d330 1
d361 1
d372 1
d376 2
d379 1
a379 1
	if (f->mode & AMSG_REC) {
d382 1
a382 1
		f->walign = dev_round * wbuf->bpf;
d385 2
d388 1
d394 3
a396 1
		dbg_puts(" fr buffers\n");
d399 7
a405 3
	f->pstate = SOCK_START;
	if (!(f->mode & AMSG_PLAY) && ctl_slotstart(dev_midi, f->slot))
		(void)sock_attach(f, 0);
d440 1
a440 1
	if (f->pstate != SOCK_START) {
d442 1
a442 1
		dbg_puts(": not in START state\n");
d450 32
d484 1
a484 1
int
d497 1
a497 1
		return 0;
d499 7
d509 3
a511 1
		dbg_puts(": attaching to device\n");
a513 2
	f->pstate = SOCK_RUN;

d515 3
a517 1
	 * Attach them to the device.
d519 2
a520 4
	dev_attach(f->pipe.file.name,
	    (f->mode & AMSG_PLAY) ? rbuf : NULL, &f->rpar, f->xrun,
	    (f->mode & AMSG_REC)  ? wbuf : NULL, &f->wpar, f->xrun,
	    f->opt->maxweight);
a530 1
	return 1;
d538 1
d640 1
a640 2
	unsigned char *data;
	unsigned count, n;
d653 1
a653 1
	if (ABUF_FULL(obuf) || !(f->pipe.file.state & FILE_ROK))
d655 6
a660 8
	data = abuf_wgetblk(obuf, &count, 0);
	if (f->pstate != SOCK_MIDI && count > f->rtodo)
		count = f->rtodo;
	n = file_read(&f->pipe.file, data, count);
	if (n == 0)
		return 0;
	abuf_wcommit(obuf, n);
	if (f->pstate != SOCK_MIDI)
d662 5
d679 1
a679 4
	unsigned char *data;
	unsigned count, n;
#define ZERO_MAX 0x1000
	static unsigned char zero[ZERO_MAX];
d692 13
a704 2
	if (ibuf) {
		if (ABUF_EMPTY(ibuf))
a705 9
		data = abuf_rgetblk(ibuf, &count, 0);
		if (f->pstate != SOCK_MIDI && count > f->wtodo)
			count = f->wtodo;
		n = file_write(&f->pipe.file, data, count);
		if (n == 0)
			return 0;
		abuf_rdiscard(ibuf, n);
		if (f->pstate != SOCK_MIDI)
			f->wtodo -= n;
d707 1
a707 13
		if (f->pstate == SOCK_MIDI)
			return 0; 
		/*
		 * There's no dev_detach() routine yet,
		 * so now we abruptly destroy the buffer.
		 * Until we implement dev_detach, complete
		 * the packet with zeros...
		 */
		count = ZERO_MAX;
		if (count > f->wtodo)
			count = f->wtodo;
		n = file_write(&f->pipe.file, zero, count);
		if (n == 0)
d765 1
a765 1
	if (AMSG_ISSET(p->rchan) && (f->mode & AMSG_REC)) {
d880 2
a881 2
		min = 2;
		max = 2 + rate / dev_round;
d902 1
a902 1
		if (f->slot >= -1 && dev_midi) {
d913 1
a913 1
		if (f->mode & AMSG_REC) {
d973 1
a973 1
	if (dev_midi && (p->proto & (AMSG_MIDIIN | AMSG_MIDIOUT))) {
d993 1
a993 1
	if (dev_sub)
d995 1
a995 1
	if (dev_mix)
d1013 1
a1013 1
		if (!dev_mix) {
d1025 2
a1026 1
		if (!dev_sub) {
d1035 1
a1035 1
		f->mode |= AMSG_REC;
d1037 1
a1037 1
	if (dev_midi) {
d1063 1
d1073 2
a1074 1
		if (f->pstate != SOCK_RUN && f->pstate != SOCK_START) {
d1094 2
a1095 2
		if (f->pstate == SOCK_START &&
		    ABUF_FULL(LIST_FIRST(&f->pipe.file.rproc->obuflist))) {
d1105 10
d1116 14
a1129 1
		f->rtodo = m->u.data.size;
d1169 2
a1170 1
		if (f->pstate != SOCK_RUN && f->pstate != SOCK_START) {
d1179 4
d1184 1
a1184 1
		if (f->pstate == SOCK_START &&
d1187 4
a1190 1
		sock_freebuf(f);
d1240 18
a1257 8
		m->u.par.bits = f->rpar.bits;
		m->u.par.bps = f->rpar.bps;
		m->u.par.sig = f->rpar.sig;
		m->u.par.le = f->rpar.le;
		m->u.par.msb = f->rpar.msb;
		m->u.par.rate = f->rpar.rate;
		m->u.par.rchan = f->wpar.cmax - f->wpar.cmin + 1;
		m->u.par.pchan = f->rpar.cmax - f->rpar.cmin + 1;
d1285 1
a1285 1
		m->u.cap.pchan = dev_mix ?
d1287 1
a1287 1
		m->u.cap.rchan = dev_sub ?
d1301 2
a1302 2
		if (f->pstate != SOCK_RUN &&
		    f->pstate != SOCK_START && f->pstate != SOCK_INIT) {
d1410 1
a1410 1
	unsigned size;
d1427 1
a1427 1
	if (f->tickpending) {
d1436 3
d1446 1
d1477 8
a1484 3
		size = ibuf->used - (ibuf->used % ibuf->bpf);
		if (size > AMSG_DATAMAX)
			size = AMSG_DATAMAX - (AMSG_DATAMAX % ibuf->bpf);
d1487 6
d1494 1
d1496 1
a1496 1
			f->walign = dev_round * ibuf->bpf;
d1499 1
a1499 1
		f->wmsg.u.data.size = size;
d1545 3
a1547 1
		 * XXX: have to way that the buffer is full before starting
d1549 1
a1549 1
		if (f->pstate == SOCK_START && ctl_slotstart(dev_midi, f->slot))
d1632 3
d1636 2
a1637 1
		f->wtodo = f->wmsg.u.data.size;
d1646 2
@


1.40
log
@doc fixes from jmc
@
text
@d17 6
d39 1
a39 1
void sock_attach(struct sock *, int);
d62 1
a62 1
	static char *pstates[] = { "hel", "ini", "sta", "rdy", "run", "mid" };
d66 1
a66 1
	if (f->slot >= 0 && APROC_OK(dev_midi)) {
a81 2
void sock_stopreq(void *);
void sock_locreq(void *, unsigned);
d85 1
a85 3
	sock_startreq,
	sock_stopreq,
	sock_locreq
d161 1
a161 1
	if (f->mode & AMSG_RECMASK)
d260 1
a260 1
	if (!(f->mode & AMSG_RECMASK))
d309 1
a309 1
		if (f->opt->mode & MODE_RECMASK)
d311 1
a311 1
		if (f->opt->mode & MODE_PLAY)
a318 1
	f->startpending = 0;
a323 1
	wproc->u.io.partial = 0;
a329 1
	rproc->u.io.partial = 0;
a359 1
	f->startpending = 0;
a369 1
	f->pstate = SOCK_START;
a372 2
		if (!ABUF_WOK(rbuf) || (f->pipe.file.state & FILE_EOF))
			f->pstate = SOCK_READY;
d374 1
a374 1
	if (f->mode & AMSG_RECMASK) {
d377 1
a377 1
		f->walign = f->round;
a379 2
	f->wmax = 0;
	f->rmax = f->bufsz;
a380 1
	f->startpending = 0;
d386 1
a386 3
		dbg_puts(" fr buffers, rmax = ");
		dbg_putu(f->rmax);
		dbg_puts("\n");
d389 3
a391 7
	if (f->mode & AMSG_PLAY) {
		f->pstate = SOCK_START;
	} else {
		f->pstate = SOCK_READY;
		if (ctl_slotstart(dev_midi, f->slot))
			(void)sock_attach(f, 0);
	}
d426 1
a426 1
	if (f->pstate != SOCK_READY) {
d428 1
a428 1
		dbg_puts(": not in READY state\n");
a435 32
 * Callback invoked by MMC stop
 */
void
sock_stopreq(void *arg)
{
#ifdef DEBUG
	struct sock *f = (struct sock *)arg;

	if (debug_level >= 3) {
		sock_dbg(f);
		dbg_puts(": ignored STOP signal\n");
	}
#endif
}

/*
 * Callback invoked by MMC relocate, ignored
 */
void
sock_locreq(void *arg, unsigned mmcpos)
{
#ifdef DEBUG
	struct sock *f = (struct sock *)arg;

	if (debug_level >= 3) {
		sock_dbg(f);
		dbg_puts(": ignored RELOCATE signal\n");
	}
#endif
}

/*
d438 1
a438 1
void
d451 1
a451 1
		return;
a452 7
	/*
	 * get the current position, the origin is when
	 * the first sample is played/recorded
	 */
	f->delta = dev_getpos() * (int)f->round / (int)dev_round;
	f->startpending = 1;
	f->pstate = SOCK_RUN;
d456 1
a456 3
		dbg_puts(": attaching at ");
		dbg_puti(f->delta);
		dbg_puts("\n");
d459 2
d462 1
a462 3
	 * We dont check whether the device is dying,
	 * because dev_xxx() functions are supposed to
	 * work (i.e., not to crash)
d464 4
a467 2
	dev_attach(f->pipe.file.name, f->mode,
	    rbuf, &f->rpar, wbuf, &f->wpar, f->xrun, f->opt->maxweight);
d478 1
a485 1
	case SOCK_READY:
d587 2
a588 1
	unsigned n;
d601 7
a607 1
	if (!ABUF_WOK(obuf) || !(f->pipe.file.state & FILE_ROK))
d609 2
a610 6
	if (f->pstate == SOCK_MIDI) {
		if (!rfile_do(p, obuf->len, NULL))
			return 0;
	} else {
		if (!rfile_do(p, f->rtodo, &n))
			return 0;
a611 5
		if (f->pstate == SOCK_START) {
			if (!ABUF_WOK(obuf) || (f->pipe.file.state & FILE_EOF))
				f->pstate = SOCK_READY;
		}
	}
d624 4
a627 1
	unsigned n;
d640 2
a641 13
#ifdef DEBUG
	if (f->pstate != SOCK_MIDI && ibuf == NULL) {
		sock_dbg(f);
		dbg_puts(": attempted to write on detached buffer\n");
		dbg_panic();
	}
#endif
	if (ibuf == NULL)
		return 0;
	if (!ABUF_ROK(ibuf))
		return 0;
	if (f->pstate == SOCK_MIDI) {
		if (!wfile_do(p, ibuf->len, NULL))
d643 9
d653 13
a665 1
		if (!wfile_do(p, f->wtodo, &n))
d723 1
a723 1
	if (AMSG_ISSET(p->rchan) && (f->mode & AMSG_RECMASK)) {
d838 2
a839 2
		min = 1;
		max = 1 + rate / dev_round;
d860 1
a860 1
		if (f->slot >= 0 && dev_midi) {
d871 1
a871 1
		if (f->mode & AMSG_RECMASK) {
d931 1
a931 1
	if (APROC_OK(dev_midi) && (p->proto & (AMSG_MIDIIN | AMSG_MIDIOUT))) {
d951 1
a951 1
	if (f->opt->mode & MODE_RECMASK)
d953 1
a953 1
	if (f->opt->mode & MODE_PLAY)
d971 1
a971 1
		if (!APROC_OK(dev_mix) || !(f->opt->mode & MODE_PLAY)) {
d983 1
a983 2
		if (!(APROC_OK(dev_sub)    && (f->opt->mode & MODE_REC)) &&
		    !(APROC_OK(dev_submon) && (f->opt->mode & MODE_MON))) {
d992 1
a992 1
		f->mode |= (f->opt->mode & MODE_MON) ? AMSG_MON : AMSG_REC;
d994 1
a994 1
	if (APROC_OK(dev_midi)) {
a1019 1
	struct abuf *obuf;
d1029 1
a1029 2
		if (f->pstate != SOCK_RUN && f->pstate != SOCK_START &&
		    f->pstate != SOCK_READY) {
d1049 2
a1050 2
		obuf = LIST_FIRST(&f->pipe.file.rproc->obuflist);
		if (f->pstate == SOCK_START && !ABUF_WOK(obuf)) {
a1059 10
		if (m->u.data.size % obuf->bpf != 0) {
#ifdef DEBUG
			if (debug_level >= 1) {
				sock_dbg(f);
				dbg_puts(": unaligned data chunk\n");
			}
#endif
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
d1061 1
a1061 14
		f->rtodo = m->u.data.size / obuf->bpf;
#ifdef DEBUG
		if (f->rtodo > f->rmax && debug_level >= 2) {
			sock_dbg(f);
			dbg_puts(": received past current position, rtodo = ");
			dbg_putu(f->rtodo);
			dbg_puts(", rmax = ");
			dbg_putu(f->rmax);
			dbg_puts("\n");
			aproc_del(f->pipe.file.rproc);
			return 0;
		}
#endif
		f->rmax -= f->rtodo;
d1101 1
a1101 2
		if (f->pstate != SOCK_RUN &&
		    f->pstate != SOCK_START && f->pstate != SOCK_READY) {
a1109 4
		/*
		 * XXX: device could have desappeared at this point,
		 * see how this is fixed in wav.c
		 */
d1111 1
a1111 1
		if ((f->pstate == SOCK_START || f->pstate == SOCK_READY) &&
d1114 1
a1114 4
		if (f->wstate != SOCK_WDATA || f->wtodo == 0)
			sock_freebuf(f);
		else
			f->pstate = SOCK_STOP;
d1164 8
a1171 18
		if (f->mode & AMSG_PLAY) {
			m->u.par.bits = f->rpar.bits;
			m->u.par.bps = f->rpar.bps;
			m->u.par.sig = f->rpar.sig;
			m->u.par.le = f->rpar.le;
			m->u.par.msb = f->rpar.msb;
			m->u.par.rate = f->rpar.rate;
			m->u.par.pchan = f->rpar.cmax - f->rpar.cmin + 1;
		}
		if (f->mode & AMSG_RECMASK) {
			m->u.par.bits = f->wpar.bits;
			m->u.par.bps = f->wpar.bps;
			m->u.par.sig = f->wpar.sig;
			m->u.par.le = f->wpar.le;
			m->u.par.msb = f->wpar.msb;
			m->u.par.rate = f->wpar.rate;
			m->u.par.rchan = f->wpar.cmax - f->wpar.cmin + 1;
		}
d1199 1
a1199 1
		m->u.cap.pchan = (f->opt->mode & MODE_PLAY) ?
d1201 1
a1201 1
		m->u.cap.rchan = (f->opt->mode & (MODE_PLAY | MODE_REC)) ?
d1215 2
a1216 2
		if (f->pstate != SOCK_RUN && f->pstate != SOCK_START &&
		    f->pstate != SOCK_INIT && f->pstate != SOCK_READY) {
d1324 1
a1324 1
	unsigned size, max;
d1341 1
a1341 1
	if ((f->tickpending && f->delta > 0) || f->startpending) {
a1349 3
		f->wmax += f->delta;
		if (f->delta > 0)
			f->rmax += f->delta;
a1356 1
		f->startpending = 0;
d1387 3
a1389 8
#ifdef DEBUG
		if (ibuf->used > f->wmax && debug_level >= 3) {
			sock_dbg(f);
			dbg_puts(": attempt to send past current position\n");
		}
#endif
		max = AMSG_DATAMAX / ibuf->bpf;
		size = ibuf->used;
a1391 6
		if (size > f->wmax)
			size = f->wmax;
		if (size > max)
			size = max;
		if (size == 0)
			return 0;
a1392 1
		f->wmax -= size;
d1394 1
a1394 1
			f->walign = f->round;
d1397 1
a1397 1
		f->wmsg.u.data.size = size * ibuf->bpf;
d1443 1
a1443 3
		 * XXX: sock_attach() may not start if there's not enough
		 *	samples queues, if so ctl_slotstart() will trigger
		 *	other streams, but this one won't start.
d1445 1
a1445 1
		if (f->pstate == SOCK_READY && ctl_slotstart(dev_midi, f->slot))
a1527 3
		/*
		 * XXX: why not set f->wtodo in sock_wmsg() ?
		 */
d1529 1
a1529 2
		f->wtodo = f->wmsg.u.data.size /
		    LIST_FIRST(&f->pipe.file.wproc->ibuflist)->bpf;
a1537 2
		if (f->pstate == SOCK_STOP)
			sock_freebuf(f);
@


1.39
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.38 2010/01/11 13:06:32 ratchov Exp $	*/
a16 6
/*
 * TODO:
 *
 *	change f->bufsz to contain only socket-side buffer,
 *	because it's less error prone
 */
d33 1
a33 1
int sock_attach(struct sock *, int);
d56 1
a56 1
	static char *pstates[] = { "hel", "ini", "sta", "run", "mid" };
d60 1
a60 1
	if (f->slot >= 0 && dev_midi) {
d76 2
d81 3
a83 1
	sock_startreq
d159 1
a159 1
	if (f->mode & AMSG_REC)
d258 1
a258 1
	if (!(f->mode & AMSG_REC))
d307 1
a307 1
		if (dev_sub)
d309 1
a309 1
		if (dev_mix)
d317 1
d323 1
d330 1
d361 1
d372 1
d376 2
d379 1
a379 1
	if (f->mode & AMSG_REC) {
d382 1
a382 1
		f->walign = dev_round * wbuf->bpf;
d385 2
d388 1
d394 3
a396 1
		dbg_puts(" fr buffers\n");
d399 7
a405 3
	f->pstate = SOCK_START;
	if (!(f->mode & AMSG_PLAY) && ctl_slotstart(dev_midi, f->slot))
		(void)sock_attach(f, 0);
d440 1
a440 1
	if (f->pstate != SOCK_START) {
d442 1
a442 1
		dbg_puts(": not in START state\n");
d450 32
d484 1
a484 1
int
d497 1
a497 1
		return 0;
d499 7
d509 3
a511 1
		dbg_puts(": attaching to device\n");
a513 2
	f->pstate = SOCK_RUN;

d515 3
a517 1
	 * Attach them to the device.
d519 2
a520 4
	dev_attach(f->pipe.file.name,
	    (f->mode & AMSG_PLAY) ? rbuf : NULL, &f->rpar, f->xrun,
	    (f->mode & AMSG_REC)  ? wbuf : NULL, &f->wpar, f->xrun,
	    f->opt->maxweight);
a530 1
	return 1;
d538 1
d640 1
a640 2
	unsigned char *data;
	unsigned count, n;
d653 1
a653 1
	if (ABUF_FULL(obuf) || !(f->pipe.file.state & FILE_ROK))
d655 6
a660 8
	data = abuf_wgetblk(obuf, &count, 0);
	if (f->pstate != SOCK_MIDI && count > f->rtodo)
		count = f->rtodo;
	n = file_read(&f->pipe.file, data, count);
	if (n == 0)
		return 0;
	abuf_wcommit(obuf, n);
	if (f->pstate != SOCK_MIDI)
d662 5
d679 1
a679 4
	unsigned char *data;
	unsigned count, n;
#define ZERO_MAX 0x1000
	static unsigned char zero[ZERO_MAX];
d692 13
a704 2
	if (ibuf) {
		if (ABUF_EMPTY(ibuf))
a705 9
		data = abuf_rgetblk(ibuf, &count, 0);
		if (f->pstate != SOCK_MIDI && count > f->wtodo)
			count = f->wtodo;
		n = file_write(&f->pipe.file, data, count);
		if (n == 0)
			return 0;
		abuf_rdiscard(ibuf, n);
		if (f->pstate != SOCK_MIDI)
			f->wtodo -= n;
d707 1
a707 13
		if (f->pstate == SOCK_MIDI)
			return 0; 
		/*
		 * There's no dev_detach() routine yet,
		 * so now we abruptly destroy the buffer.
		 * Until we implement dev_detach, complete
		 * the packet with zeros...
		 */
		count = ZERO_MAX;
		if (count > f->wtodo)
			count = f->wtodo;
		n = file_write(&f->pipe.file, zero, count);
		if (n == 0)
d765 1
a765 1
	if (AMSG_ISSET(p->rchan) && (f->mode & AMSG_REC)) {
d880 2
a881 2
		min = 2;
		max = 2 + rate / dev_round;
d902 1
a902 1
		if (f->slot >= -1 && dev_midi) {
d913 1
a913 1
		if (f->mode & AMSG_REC) {
d973 1
a973 1
	if (dev_midi && (p->proto & (AMSG_MIDIIN | AMSG_MIDIOUT))) {
d993 1
a993 1
	if (dev_sub)
d995 1
a995 1
	if (dev_mix)
d1013 1
a1013 1
		if (!dev_mix) {
d1025 2
a1026 1
		if (!dev_sub) {
d1035 1
a1035 1
		f->mode |= AMSG_REC;
d1037 1
a1037 1
	if (dev_midi) {
d1063 1
d1073 2
a1074 1
		if (f->pstate != SOCK_RUN && f->pstate != SOCK_START) {
d1094 2
a1095 2
		if (f->pstate == SOCK_START &&
		    ABUF_FULL(LIST_FIRST(&f->pipe.file.rproc->obuflist))) {
d1105 10
d1116 14
a1129 1
		f->rtodo = m->u.data.size;
d1169 2
a1170 1
		if (f->pstate != SOCK_RUN && f->pstate != SOCK_START) {
d1179 4
d1184 1
a1184 1
		if (f->pstate == SOCK_START &&
d1187 4
a1190 1
		sock_freebuf(f);
d1240 18
a1257 8
		m->u.par.bits = f->rpar.bits;
		m->u.par.bps = f->rpar.bps;
		m->u.par.sig = f->rpar.sig;
		m->u.par.le = f->rpar.le;
		m->u.par.msb = f->rpar.msb;
		m->u.par.rate = f->rpar.rate;
		m->u.par.rchan = f->wpar.cmax - f->wpar.cmin + 1;
		m->u.par.pchan = f->rpar.cmax - f->rpar.cmin + 1;
d1285 1
a1285 1
		m->u.cap.pchan = dev_mix ?
d1287 1
a1287 1
		m->u.cap.rchan = dev_sub ?
d1301 2
a1302 2
		if (f->pstate != SOCK_RUN &&
		    f->pstate != SOCK_START && f->pstate != SOCK_INIT) {
d1410 1
a1410 1
	unsigned size;
d1427 1
a1427 1
	if (f->tickpending) {
d1436 3
d1446 1
d1477 8
a1484 3
		size = ibuf->used - (ibuf->used % ibuf->bpf);
		if (size > AMSG_DATAMAX)
			size = AMSG_DATAMAX - (AMSG_DATAMAX % ibuf->bpf);
d1487 6
d1494 1
d1496 1
a1496 1
			f->walign = dev_round * ibuf->bpf;
d1499 1
a1499 1
		f->wmsg.u.data.size = size;
d1545 3
a1547 1
		 * XXX: have to way that the buffer is full before starting
d1549 1
a1549 1
		if (f->pstate == SOCK_START && ctl_slotstart(dev_midi, f->slot))
d1632 3
d1636 2
a1637 1
		f->wtodo = f->wmsg.u.data.size;
d1646 2
@


1.38
log
@When resuming from suspend, prime play buffers with silence,
otherwise the client would underrun by more than its own buffer
size, which currently is not allowed (causes the client to
deadlock).

Set the minimum client buffer size to two blocks. Single block
buffers don't work properly yet.

with help from jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.37 2010/01/10 21:47:41 ratchov Exp $	*/
d377 1
d1324 1
d1387 8
d1397 1
a1397 4
		f->wmsg.u.data.size = ibuf->used - (ibuf->used % ibuf->bpf);
		if (f->wmsg.u.data.size > AMSG_DATAMAX)
			f->wmsg.u.data.size =
			    AMSG_DATAMAX - (AMSG_DATAMAX % ibuf->bpf);
d1423 1
a1423 3
		dbg_puts(": reading, state = ");
		dbg_putu(f->rstate);
		dbg_puts(", todo = ");
d1425 1
a1425 1
		dbg_puts("\n");
d1514 1
a1514 3
		dbg_puts(": writing, state = ");
		dbg_putu(f->wstate);
		dbg_puts(", todo = ");
d1516 1
a1516 1
		dbg_puts("\n");
@


1.37
log
@Add traces to help tracking subtle timing bugs often causing
underuns and overruns; such bugs are hard to debug with ktrace
or a debugger. They are also handy to debug or monitor code
using aucat.

To enable traces, compile aucat with ``make DEBUG=-DDEBUG'' and
use the -d option multiple times.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.36 2010/01/05 10:18:12 ratchov Exp $	*/
d837 2
a838 2
		min = 1;
		max = 1 + rate / dev_round;
@


1.36
log
@Make the way .wav files are handled closer to the way sockets are
handled, which is conceptually simpler. No behaviour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.35 2009/11/03 21:31:37 ratchov Exp $	*/
d35 3
d58 21
d165 8
d264 8
d345 6
d380 8
d405 6
d424 7
d452 6
d512 8
d529 6
d551 8
d568 6
d589 7
d628 7
d679 8
d691 8
d705 10
d731 10
d751 10
d771 17
d789 1
d795 8
d808 8
d822 8
d848 27
d876 1
d904 12
d917 8
d932 8
d958 8
d971 6
d983 6
d998 6
d1022 6
d1029 6
d1039 6
d1050 6
d1062 6
d1073 6
d1080 6
d1094 6
d1101 6
d1120 6
d1127 6
d1144 6
d1151 6
d1179 6
d1186 6
d1208 6
d1216 6
d1226 6
d1242 6
d1249 6
d1268 6
d1275 6
d1285 6
d1298 6
d1325 6
d1340 8
d1362 8
d1395 6
d1413 10
d1444 6
d1466 6
d1506 10
d1542 6
@


1.35
log
@Allow any program using aucat to act as MMC slave and MTC master
transparently.  Multiple audio applications can be started
synchronously from external software/hardware supporting the
standard Start/Stop/Relocate messages. The server clock is exposed
through MTC, allowing non-audio software/hardware to be
synchronized to audio applications.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.34 2009/10/27 22:41:03 ratchov Exp $	*/
d518 1
a518 1
	static char zero[ZERO_MAX];
@


1.34
log
@slightly cleanup the socket and control bits:
- reject bogus clients ignoring flow control during the start phase
- don't check if dev_midi is NULL, it can't be NULL anymore
- use ``struct ctl_ops'' instead of a simple call-backs
- don't try to flush play buffer if it's not attached yet
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.33 2009/10/22 21:41:30 ratchov Exp $	*/
d57 1
d61 1
d305 1
d307 2
a310 1
	wbuf = LIST_FIRST(&f->pipe.file.wproc->ibuflist);
d335 1
a335 1
	if (!(f->mode & AMSG_PLAY))
d357 11
d412 4
a415 2
		(void)sock_attach(f, 1);
		f->pstate = SOCK_RUN;
d619 2
d695 2
d715 3
a717 1
		f->slot = ctl_slotnew(dev_midi, p->who, &ctl_sockops, f);
d771 2
a772 1
		if (f->pstate == SOCK_START)
d970 4
a973 1
		if (f->pstate == SOCK_START)
@


1.33
log
@When starting playback, the client tries to write ``bufsz'' frames
instead of ``appbufsz'', which violates the flow control mechanism.
Fix this longstanding bug by enabling negative values in AMSG_MOVE
messages, this way the client is notified when its stream is
attached to the mixer, and can update its max transfer limit.

Since this fix changes the AMSG_MOVE message format, we crank the
protocol version, and thus remove code specific to the old protocol.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.32 2009/10/21 05:43:41 ratchov Exp $	*/
d56 6
d72 1
a72 1
		if (dev_midi && f->slot >= 0)
d89 1
a89 1
	if (obuf) {
d169 1
a169 1
		if (dev_midi && f->slot >= 0)
d694 1
a694 1
		f->slot = ctl_slotnew(dev_midi, p->who, sock_setvol, f);
d722 5
d819 1
a819 1
		if (dev_midi && f->slot >= 0)
@


1.32
log
@when freeing buffers (i.e. when sio_stop() is called on client side),
clear the ``tickpending'' flag to avoid sending ticks corresponding
to non existent buffers (which in turn confuses clients).
found and analysed by jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.31 2009/10/10 13:55:37 ratchov Exp $	*/
a132 7
	/*
	 * Negative deltas are xrun notifications for internal uses
	 * only. Don't generate a packet for this, the client will be
	 * notified later.
	 */
	if (delta < 0)
		return;
d224 1
a224 8
	/*
	 * Negative deltas are xrun notifications for internal uses
	 * only. Don't generate a packet for this, the client will be
	 * notified later.
	 */
	if (delta < 0)
		return;
	f->tickpending++;	
a538 15
	if (AMSG_ISSET(p->legacy_mode)) {
		/*
		 * allow old clients that don't support HELLO to work
		 * XXX: remove this.
		 */
		if ((p->legacy_mode & ~(AMSG_PLAY | AMSG_REC)) ||
		    (p->legacy_mode == 0)) {
			return 0;
		}
		f->mode = 0;
		if ((p->legacy_mode & AMSG_PLAY) && dev_mix)
			f->mode |= AMSG_PLAY;
		if ((p->legacy_mode & AMSG_REC) && dev_sub)
			f->mode |= AMSG_REC;
	}
d648 6
a653 3
	/* XXX : set file name to p->who */
	/* XXX : dev_midi can no longer be NULL, right ? */

a705 7
	/*
	 * XXX: allow old clients to work without hello on the default socket
	 */
	if (f->pstate == SOCK_HELLO && m->cmd != AMSG_HELLO && f->opt != NULL) {
		f->pstate = SOCK_INIT;
	}

d869 1
a869 1
	if (f->tickpending && f->delta >= 0) {
@


1.31
log
@don't use a references to the device file to check the current mode
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.30 2009/10/05 07:05:24 ratchov Exp $	*/
d317 1
@


1.30
log
@add -d flag. When started in server mode, if the -d flag is
used aucat and midicat don't daemonize and log on stderr.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.29 2009/09/27 11:51:20 ratchov Exp $	*/
d275 1
a275 1
		if (dev_rec)
d277 1
a277 1
		if (dev_play)
d691 1
a691 1
	if (dev_rec)
d693 1
a693 1
	if (dev_play)
@


1.29
log
@remove all debug traces
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.28 2009/08/28 06:37:06 ratchov Exp $	*/
d54 1
@


1.28
log
@add a new AMSG_BYE, sent by the client to requst the server to
free resources and drop the connection. This allows the client
to ensuire that at any time it's using only one connection, thus
only one MIDI control channel.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.27 2009/08/27 06:54:23 ratchov Exp $	*/
a59 1
	DPRINTFN(1, "rsock_done: %p\n", f);
a78 2
	DPRINTFN(4, "rsock_in: %p\n", f);

a96 2
	DPRINTFN(4, "rsock_out: %p\n", f);

a113 1
	DPRINTFN(3, "rsock_eof: %p\n", p->u.io.file);
a119 1
	DPRINTFN(3, "rsock_hup: %p\n", p->u.io.file);
a131 3
	DPRINTFN(3, "rsock_opos: %p: delta = %d, f->delta = %d\n",
	    f, delta, f->delta);

a163 1
	DPRINTFN(1, "wsock_done: %p\n", f);
a183 2

	DPRINTFN(4, "wsock_in: %p\n", f);
a199 2
	DPRINTFN(3, "wsock_out: %p\n", f);

a200 1
		DPRINTFN(3, "wsock_out: %p, filling ibuf\n", f);
a211 1
	DPRINTFN(3, "wsock_eof: %p\n", p->u.io.file);
a217 1
	DPRINTFN(3, "wsock_hup: %p\n", p->u.io.file);
a229 2
	DPRINTFN(3, "wsock_ipos: %p, delta = %d, f->delta = %d\n",
	    f, delta, f->delta);
a309 1
	DPRINTF("sock_freebuf:\n");
a335 3

	DPRINTF("sock_allocbuf: %p, using %u frames buffer\n", f, f->bufsz);

a352 1
		DPRINTF("sock_setvol: no read buffer yet\n");
a375 1
	DPRINTF("sock_attach: %p\n", f);
a427 1
			DPRINTFN(4, "sock_rmsg: blk, rtodo = %u\n", f->rtodo);
a436 1
	DPRINTFN(4, "sock_rmsg: %p: done\n", f);
a452 1
			DPRINTFN(4, "sock_wmsg: blk, *ptodo = %u\n", *ptodo);
a461 1
	DPRINTFN(4, "sock_wmsg: %p: done\n", f);
a476 6
#ifdef DEBUG
	if (f->pstate != SOCK_MIDI && f->rtodo == 0) {
		fprintf(stderr, "sock_rdata: bad call: zero arg\n");
		abort();
	}
#endif
a508 6
#ifdef DEBUG
	if (f->pstate != SOCK_MIDI && f->wtodo == 0) {
		fprintf(stderr, "sock_wdata: bad call: zero arg\n");
		abort();
	}
#endif
d553 2
a554 2
		 * XXX: allow old clients that don't support HELLO
		 * to work
a557 1
			DPRINTF("sock_setpar: bad mode %x\n", p->legacy_mode);
a564 1
		DPRINTF("sock_setpar: mode -> %x\n", f->mode);
a567 1
			DPRINTF("sock_setpar: bits out of bounds\n");
a571 1
				DPRINTF("sock_setpar: bps out of bounds\n");
a577 1
		DPRINTF("sock_setpar: bits/bps -> %u/%u\n", p->bits, p->bps);
a593 2
		DPRINTF("sock_setpar: rchan -> %u:%u\n",
		    f->wpar.cmin, f->wpar.cmax);
a603 2
		DPRINTF("sock_setpar: pchan -> %u:%u\n",
		    f->rpar.cmin, f->rpar.cmax);
a613 1
			DPRINTF("sock_setpar: appbufsz -> %u\n", p->appbufsz);
a614 2
		DPRINTF("sock_setpar: rate -> %u, round -> %u\n",
		    p->rate, f->round);
a619 1
			DPRINTF("sock_setpar: bad xrun: %u\n", p->xrun);
a622 1
		DPRINTF("sock_setpar: xrun -> %u\n", f->xrun);
a628 1
		DPRINTF("sock_setpar: bufsz: %u\n", p->bufsz);
a646 9
		DPRINTF("sock_setpar: bufsz -> %u\n", f->bufsz);
	}
#ifdef DEBUG
	if (debug_level > 0) {
		fprintf(stderr, "sock_setpar: %p: rpar=", f);
		aparams_print(&f->rpar);
		fprintf(stderr, ", wpar=");
		aparams_print(&f->wpar);
		fprintf(stderr, ", mode=%u, bufsz=%u\n", f->mode, f->bufsz);
a647 1
#endif
d675 2
a676 1
	DPRINTF("sock_hello: from <%s>, mode = %x\n", p->who, p->proto);
a679 1
			DPRINTF("sock_hello: %x: bad proto\n", p->proto);
a695 1
		DPRINTF("sock_hello: %x: unsupported proto\n", p->proto);
a700 1
			DPRINTF("sock_hello: playback not supported\n");
a706 1
			DPRINTF("sock_hello: recording not supported\n");
a713 1
			DPRINTF("sock_hello: out of mixer slots\n");
a733 1
		DPRINTF("sock_execmsg: legacy client\n");
a738 1
		DPRINTFN(4, "sock_execmsg: %p: DATA\n", f);
a739 1
			DPRINTF("sock_execmsg: %p: DATA, bad state\n", f);
a743 1
			DPRINTF("sock_execmsg: %p: DATA, not allowed\n", f);
a749 1
			DPRINTF("sock_execmsg: zero-length data chunk\n");
a754 1
		DPRINTFN(2, "sock_execmsg: %p: START\n", f);
a755 1
			DPRINTF("sock_execmsg: %p: START, bad state\n", f);
a763 1
		DPRINTFN(2, "sock_execmsg: %p: STOP\n", f);
a764 1
			DPRINTF("sock_execmsg: %p: STOP, bad state\n", f);
a776 1
		DPRINTFN(2, "sock_execmsg: %p: SETPAR\n", f);
a777 1
			DPRINTF("sock_execmsg: %p: SETPAR, bad state\n", f);
a788 1
		DPRINTFN(2, "sock_execmsg: %p: GETPAR\n", f);
a789 1
			DPRINTF("sock_execmsg: %p: GETPAR, bad state\n", f);
a811 1
		DPRINTFN(2, "sock_execmsg: %p: GETCAP\n", f);
a812 1
			DPRINTF("sock_execmsg: %p: GETCAP, bad state\n", f);
a828 1
		DPRINTFN(2, "sock_execmsg: %p: SETVOL\n", f);
a830 1
			DPRINTF("sock_execmsg: %p: SETVOL, bad state\n", f);
a834 1
			DPRINTF("sock_execmsg: %p: SETVOL, out of range\n", f);
a837 1
		DPRINTF("sock_execmsg: SETVOL %u\n", m->u.vol.ctl);
a844 1
		DPRINTFN(2, "sock_execmsg: %p: HELLO\n", f);
a845 1
			DPRINTF("sock_execmsg: %p: HELLO, bad state\n", f);
d859 2
a860 3
		DPRINTFN(2, "sock_execmsg: %p: BYE\n", f);
		if (f->pstate != SOCK_INIT)
			DPRINTF("sock_execmsg: %p: BYE, bad state\n", f);
a863 1
		DPRINTF("sock_execmsg: %p bogus command\n", f);
a870 1
		DPRINTF("sock_execmsg: %p RRET done\n", f);
a891 1
		DPRINTFN(4, "sock_buildmsg: %p: switched to midi\n", f);
a900 1
		DPRINTFN(4, "sock_buildmsg: %p: POS: %d\n", f, f->delta);
a914 1
		DPRINTFN(4, "sock_buildmsg: %p: SETVOL: %d\n", f, f->vol);
a939 2

	DPRINTFN(4, "sock_buildmsg: %p: idling...\n", f);
a951 3
	DPRINTFN(4, "sock_read: %p; rstate = %u, rtodo = %u\n",
	    f, f->rstate, f->rtodo);

a969 1
		DPRINTF("sock_read: %p: blocked in RRET\n", f);
a971 1
	DPRINTFN(4, "sock_read: %p: done, rstate = %u\n", f, f->rstate);
a985 1
		DPRINTF("sock_return: %p: done\n", f);
a1019 3
	DPRINTFN(4, "sock_write: %p: wstate = %u, wtodo = %u\n",
	    f, f->wstate, f->wtodo);

a1045 3
	default:
		fprintf(stderr, "sock_write: unknown state\n");
		abort();
@


1.27
log
@don't discard the initial volume change message; now it matters
because the initial volume may not be MIDI_MAXCTL
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.26 2009/08/27 06:31:13 ratchov Exp $	*/
d950 6
@


1.26
log
@when an audio program connects to aucat, restore the volume it
had the last time. For instance, this fixes the problem of programs
reopenning the connection to aucat very often and thus resetting
the volume setting all the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.25 2009/08/26 06:10:15 ratchov Exp $	*/
a374 2
	if (f->pstate <= SOCK_START)
		f->lastvol = f->vol;
d1005 1
a1005 1
	if (f->vol != f->lastvol) {
@


1.25
log
@don't mess with audio internals from within the midi bits. Instead
use a call-back interface. This allows easily sending volume changes
feedback to audio applications.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.24 2009/08/21 16:48:03 ratchov Exp $	*/
a788 2
		if (f->mode & AMSG_PLAY)
			ctl_slotvol(dev_midi, f->slot, MIDI_MAXCTL);
@


1.24
log
@make aucat(1) expose a MIDI device to control server behaviour in
realtime.  For now only the playback volume of individual streams can be
changed/monitored. To each stream is assigned a MIDI channel; the volume
is changed/monitored using the standard controller number 7.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.23 2009/08/19 05:54:15 ratchov Exp $	*/
d304 1
a304 1
	f->vol = ADATA_UNIT;
d366 1
a366 1
 * Set volume.
d369 1
a369 1
sock_setvol(struct sock *f, int vol)
d371 1
d375 2
d382 1
a382 1
	dev_setvol(rbuf, vol);
d414 1
a414 1
		dev_setvol(rbuf, f->vol);
d784 1
a784 1
		f->slot = ctl_slotnew(dev_midi, p->who, f->pipe.file.rproc);
d932 1
a932 1
		sock_setvol(f, MIDI_TO_ADATA(m->u.vol.ctl));
d1003 14
@


1.23
log
@organize midi code like audio code, no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.22 2009/08/17 16:17:46 ratchov Exp $	*/
d66 2
d180 2
d305 1
d780 9
d930 2
@


1.22
log
@allow midicat to take multiple -i and -o options
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.21 2009/08/17 15:07:49 ratchov Exp $	*/
a722 1
		aproc_setin(thrubox, rbuf);
a726 5
		aproc_setout(thrubox, wbuf);
		if (mode & AMSG_MIDIOUT) {
			rbuf->duplex = wbuf;
			wbuf->duplex = rbuf;
		}
d728 1
d738 1
a738 1
	if (thrubox && (p->proto & (AMSG_MIDIIN | AMSG_MIDIOUT))) {
@


1.21
log
@if one or more MIDI devices are specified in server mode, subscribe
them to the MIDI thru box
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.20 2009/07/25 10:52:19 ratchov Exp $	*/
d721 1
a721 1
		rbuf = abuf_new(3125, &aparams_none);
d726 1
a726 1
		wbuf = abuf_new(3125, &aparams_none);
@


1.20
log
@fix comments, remove no longer needed declaration, reorder includes
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.19 2009/07/25 08:44:27 ratchov Exp $	*/
a718 1
	struct aparams dummy;
a719 3
	memset(&dummy, 0, sizeof(dummy));
	dummy.bps = 1;

d721 1
a721 1
		rbuf = abuf_new(3125, &dummy);
d726 1
a726 1
		wbuf = abuf_new(3125, &dummy);
@


1.19
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.18 2009/05/16 12:20:31 ratchov Exp $	*/
d27 2
d30 1
a30 2
#include "abuf.h"
#include "sock.h"
a31 1
#include "conf.h"
d34 1
d101 1
a101 1
	 * when calling sock_read(), we may receive a ``STOP'' command,
d103 1
a103 1
	 * we'll stop processing further messages, resulting in a dead lock.
d194 1
a194 1
	 * see remark in rsock_out()
d274 2
a275 2
 * initialise socket in the SOCK_HELLO state with default
 * parameters
d317 1
a317 1
 * free buffers
d335 1
a335 1
 * allocate buffers, so client can start filling write-end.
d361 1
a361 1
 * free buffers
d378 1
a378 1
 * attach play and/or record buffers to dev_mix and/or dev_sub
d389 2
a390 2
	 * if in SOCK_START state, dont attach until
	 * the buffer isn't completely filled
d399 1
a399 1
	 * attach them to the device
d409 1
a409 1
	 * send the initial position, if needed
d437 2
a438 2
 * read a message from the file descriptor, return 1 if done, 0
 * otherwise. The message is stored in f->rmsg
d463 1
a463 1
 * write a message to the file descriptor, return 1 if done, 0
d490 1
a490 1
 * read data chunk from the file descriptor, return 1 if at least one
d526 1
a526 1
 * write data chunk to the file descriptor, return 1 if at least one
d565 1
a565 1
		 * there's no dev_detach() routine yet,
d789 1
a789 1
 * execute message in f->rmsg and change the state accordingly; return 1
d966 1
a966 1
 * create a new data/pos message
d982 1
a982 1
	 * if pos changed, build a MOVE message
d997 1
a997 1
	 * if data available, build a DATA message
d1019 1
a1019 1
 * read from the socket file descriptor, fill input buffer and update
d1055 1
a1055 1
 * process messages to return
d1079 1
a1079 1
			 * wsock
d1093 1
a1093 1
 * write messages and data on the socket file descriptor. Return 1 if
@


1.18
log
@use the ``hello'' message a to set the device mode, and thus make
it mandatory. Old legacy clients setting the mode with sio_setpar()
are still working thanks to small hack.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.17 2009/05/16 11:15:26 ratchov Exp $	*/
d32 2
d94 1
a94 1
	if (f->pipe.file.refs > 0)
d188 1
a188 1
	if (f->pipe.file.refs > 0)
a191 1

d277 1
a277 2
sock_new(struct fileops *ops, int fd, char *name,
    struct aparams *wpar, struct aparams *rpar, int maxweight)
d282 1
a282 1
	f = (struct sock *)pipe_new(ops, fd, name);
d287 6
a292 7
	if (dev_rec) {
		f->templ_wpar = *wpar;
		f->wpar = f->templ_wpar;
	}
	if (dev_play) {
		f->templ_rpar = *rpar;
		f->rpar = f->templ_rpar;
a298 1
	f->maxweight = maxweight;
d301 1
a301 1
	wproc = aproc_new(&wsock_ops, name);
d307 1
a307 1
	rproc = aproc_new(&rsock_ops, name);
d403 1
a403 1
	    f->maxweight);
d501 1
a501 1
	if (f->rtodo == 0) {
d508 2
d513 1
a513 1
	if (count > f->rtodo)
d519 2
a520 1
	f->rtodo -= n;
d539 1
a539 1
	if (f->wtodo == 0) {
d552 1
a552 1
		if (count > f->wtodo)
d558 2
a559 1
		f->wtodo -= n;
d561 2
d630 4
a633 4
		f->wpar.cmin = f->templ_wpar.cmin;
		f->wpar.cmax = f->templ_wpar.cmin + p->rchan - 1;
		if (f->wpar.cmax > f->templ_wpar.cmax)
			f->wpar.cmax = f->templ_wpar.cmax;
d642 4
a645 4
		f->rpar.cmin = f->templ_rpar.cmin;
		f->rpar.cmax = f->templ_rpar.cmin + p->pchan - 1;
		if (f->rpar.cmax > f->templ_rpar.cmax)
			f->rpar.cmax = f->templ_rpar.cmax;
d711 28
d744 19
a762 1
	DPRINTF("sock_hello: from <%s>\n", p->who);
d797 1
a797 1
	 * XXX: allow old clients to work without hello
d799 1
a799 1
	if (f->pstate == SOCK_HELLO && m->cmd != AMSG_HELLO) {
d901 1
a901 1
		    (f->templ_rpar.cmax - f->templ_rpar.cmin + 1) : 0;
d903 1
a903 1
		    (f->templ_wpar.cmax - f->templ_wpar.cmin + 1) : 0;
d953 7
a959 2
		f->rtodo = sizeof(struct amsg);
		f->rstate = SOCK_RMSG;
d973 7
d1038 1
a1038 1
		if (f->rtodo == 0) {
d1065 10
a1074 2
		f->rstate = SOCK_RMSG;
		f->rtodo = sizeof(struct amsg);
d1084 1
d1117 1
a1117 1
		if (f->wtodo > 0)
@


1.17
log
@add a new ``hello'' message to aucat protocol useful to work on
future aucat extentions. No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.16 2009/03/15 10:31:37 jakemsr Exp $	*/
d272 1
a272 1
 * initialise socket in the SOCK_INIT state with default
d285 1
a285 1
	f->pstate = SOCK_INIT;
a289 1
		f->mode |= AMSG_REC;
a293 1
		f->mode |= AMSG_PLAY;
d582 8
a589 3
	if (AMSG_ISSET(p->mode)) {
		if ((p->mode & ~(AMSG_PLAY | AMSG_REC)) || p->mode == 0) {
			DPRINTF("sock_setpar: bad mode %x\n", p->mode);
d593 1
a593 1
		if ((p->mode & AMSG_PLAY) && dev_mix)
d595 1
a595 1
		if ((p->mode & AMSG_REC) && dev_sub)
d713 3
a715 2
	if ((p->proto & AMSG_PLAY) && dev_mix == NULL) {
		DPRINTF("sock_hello: playback not supported\n");
d718 7
a724 3
	if ((p->proto & AMSG_REC) && dev_sub == NULL) {
		DPRINTF("sock_hello: recording not supported\n");
		return 0;
d726 6
a731 3
	if ((p->proto & ~(AMSG_PLAY | AMSG_REC)) != 0) {
		DPRINTF("sock_hello: %x: unsupported proto\n", p->proto);
		return 0;
d733 1
d746 8
d824 1
a824 1
		m->u.par.mode = f->mode;
d879 1
a879 1
		if (f->pstate != SOCK_INIT) {
@


1.16
log
@fix a couple comment typos
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.15 2009/03/12 07:26:04 ratchov Exp $	*/
d704 21
d856 16
@


1.15
log
@in full-duplex, don't send AMSG_MOVE messages twice; instead,
send only the record direction one. spotted by jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.14 2009/02/06 08:29:35 ratchov Exp $	*/
d138 2
a139 2
	 * negative deltas are xrun notifications for internal uses
	 * only. Dont generate a packet for this, the client will be
d245 2
a246 2
	 * negative deltas are xrun notifications for internal uses
	 * only. Dont generate a packet for this, the client will be
@


1.14
log
@simplify the clock tick messages generation code and ensuire that
the first clock tick (ie the start tick) is not lost
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.13 2009/02/04 20:35:14 ratchov Exp $	*/
d130 1
a130 1
	if (!(f->mode & AMSG_PLAY))
@


1.14.2.1
log
@In server mode when in full-duplex mode (the default) aucat(1) will send
each synchronization message twice, causing client applications to think
that buffer underruns are occuring. Depending on the application, this may
cause the sound to stutter.

from current, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.14 2009/02/06 08:29:35 ratchov Exp $	*/
d130 1
a130 1
	if (f->mode & AMSG_REC)
@


1.13
log
@if there are too many connections, stop acceping new ones rather
than exit()ing with ``too many open files'' fatal error
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.12 2009/01/23 17:38:15 ratchov Exp $	*/
d130 6
a135 3
	f->odelta += delta;
	DPRINTFN(3, "rsock_opos: %p: delta = %d, odelta = %d\n",
	    f, delta, f->odelta);
d142 1
a142 1
	if (delta <= 0)
d144 1
d238 2
a239 3
	f->idelta += delta;
	DPRINTFN(3, "wsock_ipos: %p, delta = %d, odelta = %d\n",
	    f, delta, f->idelta);
d241 3
d249 1
a249 1
	if (delta <= 0)
d251 1
d300 2
a301 1
	f->odelta = f->idelta = 0;
a347 1
		f->odelta = 0;
a351 1
		f->idelta = 0;
d353 2
a859 1
	int *pdelta;
d864 2
a865 4
	pdelta = (f->mode & AMSG_REC) ? &f->idelta : &f->odelta;
	if ((f->pstate == SOCK_RUN && *pdelta > 0) ||
	    (f->pstate == SOCK_START && *pdelta < 0)) {
		DPRINTFN(4, "sock_buildmsg: %p: POS: %d\n", f, *pdelta);
d868 1
a868 2
		f->wmsg.u.ts.delta = *pdelta;
		*pdelta = 0;
d871 2
@


1.12
log
@spacing + typo fix from Matt Jibson <matt.jibson(at)gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.11 2008/12/29 17:59:08 ratchov Exp $	*/
d276 2
@


1.11
log
@make the code "more correct": add reference counters to aproc
structures so we can keep a pointer to the device. Beside some
simplifications, this allows to easily handle the situation
where the audio device desappears. No change in the behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.10 2008/12/17 07:19:27 ratchov Exp $	*/
d97 1
a97 1
	/* 
d106 1
a106 1
			return 0;		
d316 1
a316 1
	
d360 1
a360 1
	
d362 1
a362 1
	rbuf = LIST_FIRST(&f->pipe.file.rproc->obuflist);	
d387 1
a387 1
	
d564 1
a564 1
	}		
d573 1
a573 1
	
d783 1
a783 1
		m->u.par.bufsz = 
d851 1
a851 1
	
@


1.10
log
@add a writable ``appbufsz'' field to the sa_par structure, containing
the program-part of the buffer size, ie the part that is subject to
underruns. Useful for apps like cdio(1) that don't have their own
rings, or to apps that have a minimum ring size constraint. Setting
the ``bufsz'' parameter becomes deprecated.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.9 2008/12/07 17:10:41 ratchov Exp $	*/
d58 2
d66 1
d166 2
d174 1
@


1.9
log
@When resampling, don't require the sample frequency to be an integer.
This removes the arithmetic constraint between the sample frequency
and the block size and all the associated code. Now aucat can work
in server mode with any block size.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.8 2008/11/17 07:04:13 ratchov Exp $	*/
d283 1
a283 1
	f->bufsz = 2 * dev_bufsz;
a327 1
	unsigned nfr = 0;
d330 1
a330 2
		nfr = f->bufsz - dev_bufsz * f->rpar.rate / dev_rate;
		rbuf = abuf_new(nfr, &f->rpar);
d335 1
a335 2
		nfr = f->bufsz - dev_bufsz * f->wpar.rate / dev_rate;
		wbuf = abuf_new(nfr, &f->wpar);
d340 1
a340 2
	DPRINTF("sock_allocbuf: %p, using %u/%u frames buffer\n",
	    f, nfr, f->bufsz);
d633 4
a636 2
		if (!AMSG_ISSET(p->bufsz))
			p->bufsz = 2 * dev_bufsz / dev_round * f->round;
d651 11
d663 2
a664 2
		min = (3 * (dev_bufsz / dev_round) + 1) / 2;
		max = (dev_bufsz + rate + dev_round - 1) / dev_round;
d667 7
a673 7
		p->bufsz += f->round - 1;
		p->bufsz -= p->bufsz % f->round;
		if (p->bufsz < min)
			p->bufsz = min;
		if (p->bufsz > max)
			p->bufsz = max;
		f->bufsz = p->bufsz;
d776 3
a778 1
		m->u.par.bufsz = f->bufsz;
a792 1
		m->u.cap.rate_div = dev_rate;
@


1.8
log
@allow aucat to run as server in play-only and record-only mode, so
it can be used on play-only, record-only and half-duplex devices.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.7 2008/11/16 20:44:03 ratchov Exp $	*/
d570 1
a570 1
	unsigned minbuf, maxbuf;
d635 1
a635 1
		dev_roundrate(&p->rate, &f->round);
d637 4
a640 5
		if (f->mode & AMSG_PLAY)
			f->bufsz = 2 * dev_bufsz * f->rpar.rate / dev_rate;
		else
			f->bufsz = 2 * dev_bufsz * f->wpar.rate / dev_rate;
		DPRINTF("sock_setpar: rate -> %u\n", p->rate);
d653 12
a664 18
		minbuf = 3 * dev_bufsz / 2;
		minbuf -= minbuf % dev_round;
		maxbuf = dev_bufsz;
		if (f->mode & AMSG_PLAY) {
			minbuf = minbuf * f->rpar.rate / dev_rate;
			maxbuf = maxbuf * f->rpar.rate / dev_rate;
			maxbuf += f->rpar.rate;
		} else {
			minbuf = minbuf * f->wpar.rate / dev_rate;
			maxbuf = maxbuf * f->wpar.rate / dev_rate;
			maxbuf += f->wpar.rate;
		}
		if (p->bufsz < minbuf)
			p->bufsz = minbuf;
		if (p->bufsz > maxbuf)
			p->bufsz = maxbuf;
		f->bufsz = p->bufsz + f->round - 1;
		f->bufsz -= f->bufsz % f->round;
d782 1
a782 1
		m->u.cap.rate_div = dev_rate_div;
@


1.7
log
@allow aucat to listen on multiple sockets. Each socket carries its
channel and volume settings allowing multiple configuration to
coexist. Mostly useful for envy(4)-like devices, but can be used
to force different apps to use different settings.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.6 2008/11/16 18:34:56 ratchov Exp $	*/
d700 5
@


1.6
log
@add ``template'' parameters to sockets rather than using device
parameters. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.5 2008/11/16 17:08:32 ratchov Exp $	*/
d613 2
a614 2
		if (f->wpar.cmax > NCHAN_MAX - 1)
			f->wpar.cmax = NCHAN_MAX - 1;
d624 3
a626 3
		f->rpar.cmax = f->templ_wpar.cmin + p->pchan - 1;
		if (f->rpar.cmax > NCHAN_MAX - 1)
			f->rpar.cmax = NCHAN_MAX - 1;
@


1.5
log
@make aucat compile without DEBUG defined (still defined by default)
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.4 2008/11/16 16:30:22 ratchov Exp $	*/
d263 2
a264 1
sock_new(struct fileops *ops, int fd, char *name, int maxweight)
d272 3
a274 2
	if (dev_rec) {		
		f->wpar = dev_ipar;
d278 2
a279 1
		f->rpar = dev_opar;
d609 8
a616 5
		if (p->rchan > NCHAN_MAX - 1)
			p->rchan = NCHAN_MAX - 1;
		f->wpar.cmin = 0;
		f->wpar.cmax = p->rchan - 1;
		DPRINTF("sock_setpar: rchan -> %u\n", p->rchan);
d621 8
a628 5
		if (p->pchan > NCHAN_MAX - 1)
			p->pchan = NCHAN_MAX - 1;
		f->rpar.cmin = 0;
		f->rpar.cmax = p->pchan - 1;
		DPRINTF("sock_setpar: pchan -> %u\n", p->pchan);
d785 4
a788 2
		m->u.cap.pchan = dev_opar.cmax - dev_opar.cmin + 1;	
		m->u.cap.rchan = dev_ipar.cmax - dev_ipar.cmin + 1;	
a983 1

@


1.4
log
@Make clients inherit the volume parameter when the -v option is used in
server mode. It gives the maximum volume a client may have. This wastes
dynamic range, but allows volume to stay constant when other clients
connect or disconnect.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.3 2008/11/11 19:21:20 ratchov Exp $	*/
d665 1
d673 1
@


1.3
log
@expose the volume knob in server mode too
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.2 2008/11/03 22:25:13 ratchov Exp $	*/
d263 1
a263 1
sock_new(struct fileops *ops, int fd, char *name)
d283 1
d391 2
a392 1
	    (f->mode & AMSG_REC)  ? wbuf : NULL, &f->wpar, f->xrun);
@


1.2
log
@A small optimization: handle most N-channel <-> M-channel conversions
inside the mixer and the demultiplexer. This way, aucat will not
trigger the heavy conversion code when only channel conversions are
required. Cuts ~50% of the CPU usage on envy(4) devices, can improve
surround 4.0, 5.1 and 7.1 capable devices. No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sock.c,v 1.1 2008/10/26 08:49:44 ratchov Exp $	*/
d283 1
d348 17
d391 3
a393 1
	
d778 18
@


1.1
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d327 1
a327 1
		rbuf = abuf_new(nfr, aparams_bpf(&f->rpar));
d333 1
a333 1
		wbuf = abuf_new(nfr, aparams_bpf(&f->wpar));
@

