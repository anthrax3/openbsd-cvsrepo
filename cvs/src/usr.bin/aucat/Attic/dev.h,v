head	1.37;
access;
symbols
	OPENBSD_5_6:1.36.0.12
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.10
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.6
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.4
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.2
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.1.0.2
	OPENBSD_4_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.37
date	2015.01.21.08.43.55;	author ratchov;	state dead;
branches;
next	1.36;
commitid	SYQcoS9jhSKqSJDL;

1.36
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.35;

1.35
date	2012.03.23.11.59.54;	author ratchov;	state Exp;
branches;
next	1.34;

1.34
date	2011.12.02.10.34.50;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.02.10.29.01;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2011.11.20.22.54.51;	author ratchov;	state Exp;
branches;
next	1.31;

1.31
date	2011.11.15.08.05.22;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2011.10.12.07.20.04;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.20.20.18.44;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2011.05.26.07.18.40;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.06.01.12.45;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.25.07.32.05;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.05.16.00.52;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.04.06.15.28;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2010.05.08.15.35.45;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.02.11.54.26;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.21.06.13.07;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.11.13.06.32;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.05.10.18.12;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.03.21.31.37;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.10.13.55.37;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.09.16.49.48;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.19.05.54.15;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.25.10.52.19;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2009.02.06.08.26.34;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.10.20.02.28;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.07.17.10.41;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.16.16.30.22;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.10.23.25.37;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.09.16.26.07;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.07.21.01.15;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.26.08.49.43;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.14.09.58.55;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.23.07.15.46;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Simplify internals and rewrite file header parsing code:
- remove -M, -t, -w, -C, -x flags that don't make sense anymore
- make "-j off" the default (sndiod already does the job)
- don't limit the number of played/recorded files.
- add support for floating-point encoded files.
- add support for apple .aiff and sun/next .au files
@
text
@/*	$OpenBSD: dev.h,v 1.36 2012/04/11 06:05:43 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifndef DEV_H
#define DEV_H

#include "aparams.h"

struct aproc;
struct abuf;

struct dev {
	struct dev *next;

	/*
	 * desired parameters
	 */
	unsigned int reqmode;			/* mode */
	struct aparams reqipar, reqopar;	/* parameters */
	unsigned int reqbufsz;			/* buffer size */
	unsigned int reqround;			/* block size */
	unsigned int hold;				/* hold the device open ? */
	unsigned int autovol;			/* auto adjust playvol ? */
	unsigned int autostart;			/* don't wait for MMC start */
	unsigned int refcnt;			/* number of openers */
#define DEV_NMAX	16			/* max number of devices */
	unsigned int num;				/* serial number */
#define DEV_CLOSED	0			/* closed */
#define DEV_INIT	1			/* stopped */
#define DEV_START	2			/* ready to start */
#define DEV_RUN		3			/* started */
	unsigned int pstate;			/* on of DEV_xxx */
	char *path;				/* sio path */

	/*
	 * actual parameters and runtime state (i.e. once opened)
	 */
	unsigned int mode;				/* bitmap of MODE_xxx */
	unsigned int bufsz, round, rate;
	struct aparams ipar, opar;
	struct aproc *mix, *sub, *submon;
	struct aproc *rec, *play, *mon;
	struct aproc *midi;
	struct devctl {
		struct devctl *next;
		unsigned int mode;
		char *path;
	} *ctl_list;

	/* volume control and MMC/MTC */
#define CTL_NSLOT	8
#define CTL_NAMEMAX	8
	unsigned int serial;
	struct ctl_slot {
		struct ctl_ops {
			void (*vol)(void *, unsigned int);
			void (*start)(void *);
			void (*stop)(void *);
			void (*loc)(void *, unsigned int);
			void (*quit)(void *);
		} *ops;
		void *arg;
		unsigned int unit;
		char name[CTL_NAMEMAX];
		unsigned int serial;
		unsigned int vol;
		unsigned int tstate;
	} slot[CTL_NSLOT];
#define CTL_OFF		0			/* ignore MMC messages */
#define CTL_STOP	1			/* stopped, can't start */
#define CTL_START	2			/* attempting to start */
#define CTL_RUN		3			/* started */
	unsigned int tstate;			/* one of above */
	unsigned int origin;			/* MTC start time */
	unsigned int master;			/* master volume controller */
};

extern struct dev *dev_list;

void dev_dbg(struct dev *);
int  dev_init(struct dev *);
int  dev_run(struct dev *);
int  dev_ref(struct dev *);
void dev_unref(struct dev *);
void dev_del(struct dev *);
void dev_wakeup(struct dev *);
void dev_drain(struct dev *);
struct dev *dev_new(char *, unsigned int, unsigned int,
    unsigned int, unsigned int, unsigned int);
void dev_adjpar(struct dev *, unsigned int,
    struct aparams *, struct aparams *);
int  devctl_add(struct dev *, char *, unsigned int);
void dev_midiattach(struct dev *, struct abuf *, struct abuf *);
unsigned int dev_roundof(struct dev *, unsigned int);
int dev_getpos(struct dev *);
void dev_attach(struct dev *, char *, unsigned int,
    struct abuf *, struct aparams *, unsigned int,
    struct abuf *, struct aparams *, unsigned int,
    unsigned int, int);
void dev_setvol(struct dev *, struct abuf *, int);

void dev_slotdbg(struct dev *, int);
int  dev_slotnew(struct dev *, char *, struct ctl_ops *, void *, int);
void dev_slotdel(struct dev *, int);
void dev_slotvol(struct dev *, int, unsigned int);

int  dev_slotstart(struct dev *, int);
void dev_slotstop(struct dev *, int);
void dev_mmcstart(struct dev *);
void dev_mmcstop(struct dev *);
void dev_loc(struct dev *, unsigned int);
void dev_master(struct dev *, unsigned int);

#endif /* !define(DEV_H) */
@


1.36
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.35 2012/03/23 11:59:54 ratchov Exp $	*/
@


1.35
log
@add a MIDI-controlled master volume knob to adjust the mix of
all playback stream, discussed with armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.34 2011/12/02 10:34:50 ratchov Exp $	*/
d31 1
a31 1
	unsigned reqmode;			/* mode */
d33 6
a38 6
	unsigned reqbufsz;			/* buffer size */
	unsigned reqround;			/* block size */
	unsigned hold;				/* hold the device open ? */
	unsigned autovol;			/* auto adjust playvol ? */
	unsigned autostart;			/* don't wait for MMC start */
	unsigned refcnt;			/* number of openers */
d40 1
a40 1
	unsigned num;				/* serial number */
d45 1
a45 1
	unsigned pstate;			/* on of DEV_xxx */
d51 2
a52 2
	unsigned mode;				/* bitmap of MODE_xxx */
	unsigned bufsz, round, rate;
d59 1
a59 1
		unsigned mode;
d66 1
a66 1
	unsigned serial;
d69 1
a69 1
			void (*vol)(void *, unsigned);
d72 1
a72 1
			void (*loc)(void *, unsigned);
d76 1
a76 1
		unsigned unit;
d78 3
a80 3
		unsigned serial;
		unsigned vol;
		unsigned tstate;
d86 3
a88 3
	unsigned tstate;			/* one of above */
	unsigned origin;			/* MTC start time */
	unsigned master;			/* master volume controller */
d101 5
a105 3
struct dev *dev_new(char *, unsigned, unsigned, unsigned, unsigned, unsigned);
void dev_adjpar(struct dev *, unsigned, struct aparams *, struct aparams *);
int  devctl_add(struct dev *, char *, unsigned);
d107 1
a107 1
unsigned dev_roundof(struct dev *, unsigned);
d109 4
a112 4
void dev_attach(struct dev *, char *, unsigned,
    struct abuf *, struct aparams *, unsigned,
    struct abuf *, struct aparams *, unsigned,
    unsigned, int);
d118 1
a118 1
void dev_slotvol(struct dev *, int, unsigned);
d124 2
a125 2
void dev_loc(struct dev *, unsigned);
void dev_master(struct dev *, unsigned);
@


1.34
log
@reuse midi-control code to implement midi thru boxes and remove
the old midithru implementation; less code, less bugs. As a side
effect, midi output doesn't implement running status "compression"
any more.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.33 2011/12/02 10:29:01 ratchov Exp $	*/
d88 1
d123 1
@


1.33
log
@remove unused 'reqrate' parameter
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.32 2011/11/20 22:54:51 ratchov Exp $	*/
a121 1
int  dev_idle(struct dev *);
@


1.32
log
@Move mmc/mtc and volume control bits from struct aproc to struct
dev. Allows volume settings to be saved while the device is kept
closed. Besides that, no behabiour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.31 2011/11/15 08:05:22 ratchov Exp $	*/
a34 1
	unsigned reqrate;			/* sample rate */
@


1.31
log
@Add a "device number" component in sndio(7) device names, allowing a
single aucat instance to handle all audio and MIDI services. Since
this partially breaks compatibility, this is a opportunitiy to fix few
other design mistakes (eg ':' being used by inet6, type name vs api
name confusion, etc..). This leads to the following names:

        type[@@hostname][,unit]/devnum[.option]

The device number is the minor device number for direct hardware
access (ie the 'N' in /dev/audioN). For aucat, this is the occurence
number of the -f (or -M) option.

There's a compatibility hook to keep old names working if only one
aucat server is running.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.30 2011/10/12 07:20:04 ratchov Exp $	*/
d63 26
d112 12
@


1.30
log
@Simplify and improve the way options are parsed and remove ~300 lines
of code that becomes unused. Few command line arguments changes are
required though:

  - stream definitions (-ios) now must follow devices definitions they
    are attached to (-fMn)

  - the -n option is now a special "loopback" device and is thus used
    like -f, eg it must precede streams

  - in midicat, midi thru boxes are not created automatically anymore,
    the new "-M" option must be used for that

  - channel numbers (-Cc options) correspond always to channel numbers
    of the hardware.

  - the -u option isn't needed anymore

  - increase the log verbosity so user errors are logged
    without using -d

tested by many, help from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.29 2011/06/20 20:18:44 ratchov Exp $	*/
d40 2
d67 1
@


1.29
log
@Make -aoff option apply to MIDI ports (-q) as well, ensuring the device
stays closed also if -q is used. As we're at it, add -a to midicat so
it behaves like aucat.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.28 2011/05/26 07:18:40 ratchov Exp $	*/
d38 1
d65 1
d72 2
a73 5
struct dev *dev_new_thru(int);
struct dev *dev_new_loop(struct aparams *, struct aparams *, unsigned);
struct dev *dev_new_sio(char *, unsigned, 
    struct aparams *, struct aparams *,
    unsigned, unsigned, unsigned, unsigned);
@


1.28
log
@add a new -w flag to control whether master volume is automatically
adjusted when new streams are connected and disconnected. Disabling
automatic volume adjustment makes sense if all streams are recorded
with properly lowered volumes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.27 2010/07/06 01:12:45 ratchov Exp $	*/
d55 5
d70 1
a70 1
struct dev *dev_new_thru(void);
d75 1
a75 1
int  dev_thruadd(struct dev *, char *, int, int);
@


1.27
log
@Handle all streams the same way because there's no actual
difference between audio files and client connections. Clean up
the way command line options are handled and clarify this in the
manual page: stream parameters (-Ccehjmrtvx) must precede stream
definitions (-ios) and per-device parameters (-abz) and stream
definitions (-ios) must precede device definitions (-f). Since
there's no ``server'' and ``non-server'' modes anymore, make the
-l option just detach the process.

ok and help from jakemsr and jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.26 2010/06/25 07:32:05 ratchov Exp $	*/
d37 1
d68 2
a69 1
    struct aparams *, struct aparams *, unsigned, unsigned, unsigned);
@


1.26
log
@don't attempt to drain devices after they are destroyed, which
results in a use after free(). Catched by jakemsr@@ with MALLOC_OPTIONS=J
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.25 2010/06/05 16:00:52 ratchov Exp $	*/
d20 2
a22 1
struct aparams;
@


1.25
log
@don't prime server buffers, because it's ugly and conceptually
complicated. Instead, request clients to provide enough samples
and start with buffers full.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.24 2010/06/04 06:15:28 ratchov Exp $	*/
d62 1
@


1.24
log
@Allow the audio device to be opened only while it's actually used.
This is necessary for uaudio devices, for instance to start aucat
before the device is plugged. Or to unplug a device whithout
having to restart aucat when another device is plugged.  This is
controlled with the new -a option.

Allow multiple audio devices to be used concurently, i.e.
multiple ``-f devname'' options to be used; -f options must follow
per-device options, which is what we do for other options.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.23 2010/05/08 15:35:45 ratchov Exp $	*/
a34 1
	unsigned prime;				/* prime play buffer? */
d65 1
a65 2
    struct aparams *, struct aparams *, unsigned, unsigned,
    unsigned, unsigned);
@


1.23
log
@prime play buffers as soon as the device is opened, otherwise a
midi client could start it with empty buffers, in turn hurting
audio clients.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.22 2010/05/02 11:54:26 ratchov Exp $	*/
d24 49
a72 21
extern unsigned dev_reqprime;
extern unsigned dev_bufsz, dev_round, dev_rate;
extern struct aparams dev_ipar, dev_opar;
extern struct aproc *dev_mix, *dev_sub, *dev_midi, *dev_submon, *dev_mon;

int dev_run(void);
int dev_open(void);
void dev_close(void);
int dev_ref(void);
void dev_unref(void);
void dev_done(void);
void dev_wakeup(void);
void dev_init_thru(void);
void dev_init_loop(struct aparams *, struct aparams *, unsigned);
void dev_init_sio(char *, unsigned,
    struct aparams *, struct aparams *, unsigned, unsigned);
int  dev_thruadd(char *, int, int);
void dev_midiattach(struct abuf *, struct abuf *);
unsigned dev_roundof(unsigned);
int dev_getpos(void);
void dev_attach(char *, unsigned,
d76 1
a76 1
void dev_setvol(struct abuf *, int);
@


1.22
log
@Clean up device handling code to clarify different initialization phases
and different device states. Split initialization in two phases:
first global variables are initialized then the audio hardware is opened.
Allow devices that don't support full-duplex to work in play-only or
record-only mode, even if ``-m play'' or ``-m rec'' are not specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.21 2010/04/21 06:13:07 ratchov Exp $	*/
d24 1
d35 1
a35 1
void dev_wakeup(int);
@


1.21
log
@adds the necessary bits to join channels (ex stereo->mono) or
expand channels (ex mono->stereo).  It's switched on/off with
the ``-j'' option, (default is "on").
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.20 2010/04/06 20:07:01 ratchov Exp $	*/
a23 6
#define DEV_INIT	0
#define DEV_START	1
#define DEV_RUN		2
#define DEV_STOP	3

extern unsigned dev_pstate;
d28 11
a38 1
void dev_thruinit(void);
a41 10
void dev_loopinit(struct aparams *, struct aparams *, unsigned);
int  dev_init(char *, unsigned,
    struct aparams *, struct aparams *, unsigned, unsigned);
void dev_start(void);
void dev_stop(void);
void dev_run(int);
void dev_done(void);
int  dev_getep(unsigned, struct abuf **, struct abuf **);
void dev_sync(unsigned, struct abuf *, struct abuf *);
unsigned dev_getmode(void);
a47 2
void dev_clear(void);
void dev_prime(void);
@


1.20
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.19 2010/04/03 17:59:17 ratchov Exp $	*/
d50 3
a52 2
    struct abuf *, struct aparams *,
    struct abuf *, struct aparams *, unsigned, int);
@


1.19
log
@backout last change, committed by mistake, sorry...
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.17 2010/01/11 13:06:32 ratchov Exp $	*/
d24 6
d32 1
a32 1
extern struct aproc *dev_mix, *dev_sub, *dev_midi;
d39 2
a40 1
int  dev_init(char *, struct aparams *, struct aparams *, unsigned, unsigned);
d45 3
a47 2
int  dev_getep(struct abuf **, struct abuf **);
void dev_sync(struct abuf *, struct abuf *);
d49 2
a50 2
void dev_attach(char *,
    struct abuf *, struct aparams *, unsigned,
@


1.18
log
@doc fixes from jmc
@
text
@a23 6
#define DEV_INIT	0
#define DEV_START	1
#define DEV_RUN		2
#define DEV_STOP	3

extern unsigned dev_pstate;
d26 1
a26 1
extern struct aproc *dev_mix, *dev_sub, *dev_midi, *dev_submon, *dev_mon;
d33 1
a33 2
int  dev_init(char *, unsigned,
    struct aparams *, struct aparams *, unsigned, unsigned);
d38 2
a39 3
int  dev_getep(unsigned, struct abuf **, struct abuf **);
void dev_sync(unsigned, struct abuf *, struct abuf *);
unsigned dev_getmode(void);
d41 2
a42 2
void dev_attach(char *, unsigned,
    struct abuf *, struct aparams *,
@


1.17
log
@When resuming from suspend, prime play buffers with silence,
otherwise the client would underrun by more than its own buffer
size, which currently is not allowed (causes the client to
deadlock).

Set the minimum client buffer size to two blocks. Single block
buffers don't work properly yet.

with help from jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.16 2010/01/05 10:18:12 ratchov Exp $	*/
d24 6
d32 1
a32 1
extern struct aproc *dev_mix, *dev_sub, *dev_midi;
d39 2
a40 1
int  dev_init(char *, struct aparams *, struct aparams *, unsigned, unsigned);
d45 3
a47 2
int  dev_getep(struct abuf **, struct abuf **);
void dev_sync(struct abuf *, struct abuf *);
d49 2
a50 2
void dev_attach(char *,
    struct abuf *, struct aparams *, unsigned,
@


1.16
log
@Make the way .wav files are handled closer to the way sockets are
handled, which is conceptually simpler. No behaviour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.15 2009/11/03 21:31:37 ratchov Exp $	*/
d46 1
@


1.15
log
@Allow any program using aucat to act as MMC slave and MTC master
transparently.  Multiple audio applications can be started
synchronously from external software/hardware supporting the
standard Start/Stop/Relocate messages. The server clock is exposed
through MTC, allowing non-audio software/hardware to be
synchronized to audio applications.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.14 2009/10/10 13:55:37 ratchov Exp $	*/
d29 1
@


1.14
log
@don't use a references to the device file to check the current mode
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.13 2009/10/09 16:49:48 ratchov Exp $	*/
d32 1
a32 1
int  dev_init(char *, struct aparams *, struct aparams *, unsigned);
d39 1
@


1.13
log
@Make abuf structure smaller:
 - put aproc-specific parameters into unions since they are never
   used together
 - remove constant ``data'' pointer always pointing the end of the
   abuf structure
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.12 2009/08/19 05:54:15 ratchov Exp $	*/
d26 1
a26 1
extern struct aproc *dev_mix, *dev_sub, *dev_rec, *dev_play, *dev_midi;
a28 1
void dev_thrudone(void);
a31 1
void dev_loopdone(void);
@


1.12
log
@organize midi code like audio code, no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.11 2009/07/25 10:52:19 ratchov Exp $	*/
a24 1
extern unsigned dev_rate_div, dev_round_div;
a45 2

extern struct devops *devops, devops_sun, devops_aucat;
@


1.11
log
@fix comments, remove no longer needed declaration, reorder includes
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.10 2009/02/06 08:26:34 ratchov Exp $	*/
d27 1
a27 1
extern struct aproc *dev_mix, *dev_sub, *dev_rec, *dev_play;
d29 3
@


1.10
log
@move error messages reported to user into main()
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.9 2009/01/10 20:02:28 ratchov Exp $	*/
a21 1
struct file;
@


1.9
log
@add "loopback" mode in which input is connected to the output.
This is useful to mix, demultiplex, resample or reencode audio
files off-line.
tweak + ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.8 2008/12/07 17:10:41 ratchov Exp $	*/
d33 1
a33 1
void dev_init(char *, struct aparams *, struct aparams *, unsigned);
@


1.8
log
@When resampling, don't require the sample frequency to be an integer.
This removes the arithmetic constraint between the sample frequency
and the block size and all the associated code. Now aucat can work
in server mode with any block size.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.7 2008/11/16 16:30:22 ratchov Exp $	*/
d31 2
@


1.7
log
@Make clients inherit the volume parameter when the -v option is used in
server mode. It gives the maximum volume a client may have. This wastes
dynamic range, but allows volume to stay constant when other clients
connect or disconnect.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.6 2008/11/10 23:25:37 ratchov Exp $	*/
d30 2
a31 2
void dev_roundrate(unsigned *, unsigned *);
void dev_init(char *, struct aparams *, struct aparams *, unsigned, int);
@


1.6
log
@add a per-stream ``soft volume'' knob and the corresponding -v option.
The code will be useful later for the volume knob in the sndio API.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.5 2008/11/09 16:26:07 ratchov Exp $	*/
d40 1
a40 1
    struct abuf *, struct aparams *, unsigned);
@


1.5
log
@make aucat(1) stop automatically the audio(1) device if it's idle. This
way, when in server mode, it consumes no CPU if there are no clients.
Later, this will allow to start aucat(1) at session or system startup.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.4 2008/11/07 21:01:15 ratchov Exp $	*/
d36 1
d41 1
@


1.4
log
@expose the block size in the sndio API by making par->round writable
and thus remove the ugly rate <-> block-size table from
sio_setpar(3). Handle the block size negociation in aucat(1), since
it has few constrains the code is overally simpler.
ok jakemsr@@, major crank suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.3 2008/10/26 08:49:43 ratchov Exp $	*/
d40 1
@


1.3
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.2 2008/08/14 09:58:55 ratchov Exp $	*/
d31 1
a31 1
void dev_init(char *, struct aparams *, struct aparams *, unsigned);
@


1.2
log
@move all device related stuff from aucat.c to a new dev.c file.
The new dev_xxx() routines expose a "high level" self-contained
interface to the device. At initialization, the device is opened
and two chains of aproc structures are created:

 * a playback chain that exposes a (initially) empty mix
   aproc to which the rest of the code can attach new
   streams to be played

 * record chain that exposes a (initially) empty sub aproc
   to which the rest of the code can attach new stream to
   to record

The rest of the code, has just to use dev_attach() routine to
attach streams. While we're at it, add a ``devops'' structure
containing pointers to the device-specific routines. This will
allow later to add support for other type of device than the
Sun API.

Also, write the .wav headers in file_del(), so put all header
related data in the file strucuture. This allows to close() the
file, as soon as wpipe_xxx() aproc terminates. This will be
useful for the server, because it will need to close() descripts
of closed connections immediately.

add mix_pushzero() routine to fill the mixer with silence. It
will be used to avoid the mixer to underrun when there are no
input streams. Since we always have at least one input stream
there's no behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: dev.h,v 1.1 2008/05/23 07:15:46 ratchov Exp $	*/
d25 2
a26 1
extern unsigned dev_infr, dev_onfr;
a28 1
extern struct file  *dev_file;
d30 2
a31 3
void dev_fill(void);
void dev_flush(void);
void dev_init(char *, struct aparams *, struct aparams *);
d36 1
d41 1
a41 16
struct devops {
	int (*open)(char *, struct aparams *, struct aparams *,
	    unsigned *, unsigned *);
	void (*close)(int);
	void (*start)(int);
	void (*stop)(int);
};

extern struct devops *devops, devops_sun;

/*
 * Sun API specific functions
 */
struct audio_prinfo;
int sun_infotopar(struct audio_prinfo *, struct aparams *);
void sun_partoinfo(struct audio_prinfo *, struct aparams *);
@


1.1
log
@add support for:
 - recording, full-duplex operation
 - format conversions and resampling on the fly
 - mixing on the fly of multiple inputs of different formats
 - up to 16 channels, simplistic "routing" of channel ranges
 - more linear encodings (in raw and wav files)
the old behaviour is fully preserved if none of the new -i and -o
options are used.

code and fixes from jakemsr@@ and eric@@, suggestions by others.
ok "go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d20 4
a23 10
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/audioio.h>
#include <string.h>

int dev_init(char *, struct aparams *, struct aparams *,
    unsigned *, unsigned *);
void dev_done(int);
void dev_start(int);
void dev_stop(int);
d25 30
a56 1

@

