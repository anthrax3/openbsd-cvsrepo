head	1.37;
access;
symbols
	OPENBSD_5_6:1.35.0.6
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.33.0.4
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.31.0.2
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.2
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.37
date	2015.01.21.08.43.55;	author ratchov;	state dead;
branches;
next	1.36;
commitid	SYQcoS9jhSKqSJDL;

1.36
date	2014.08.10.10.25.04;	author ratchov;	state Exp;
branches;
next	1.35;
commitid	cVWpc0M67XlOTYRV;

1.35
date	2013.11.18.17.37.45;	author ratchov;	state Exp;
branches;
next	1.34;

1.34
date	2013.11.12.06.47.34;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2012.11.02.11.16.58;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2012.11.02.11.08.32;	author ratchov;	state Exp;
branches;
next	1.31;

1.31
date	2012.04.19.06.58.29;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2011.12.02.10.27.24;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2011.11.20.22.54.51;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2011.10.12.07.20.04;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2011.06.03.10.05.27;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2011.05.09.17.32.27;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2010.11.20.05.12.38;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2010.11.05.15.23.18;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.18.08.36.00;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.04.07.07.33;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.04.06.15.28;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.08.15.35.45;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2010.05.02.11.54.27;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.24.06.18.23;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.21.06.13.07;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2010.01.14.17.43.55;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2010.01.10.21.47.41;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2010.01.05.10.18.12;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.27.11.51.20;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.19.21.21.36;	author jakemsr;	state Exp;
branches;
next	1.7;

1.7
date	2009.07.25.10.52.19;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.22.10.57.33;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.11.10.24.21;	author jakemsr;	state Exp;
branches;
next	1.4;

1.4
date	2009.02.04.20.35.14;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.23.17.38.15;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.26.00.33.40;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.26.08.49.44;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Simplify internals and rewrite file header parsing code:
- remove -M, -t, -w, -C, -x flags that don't make sense anymore
- make "-j off" the default (sndiod already does the job)
- don't limit the number of played/recorded files.
- add support for floating-point encoded files.
- add support for apple .aiff and sun/next .au files
@
text
@/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "abuf.h"
#include "aproc.h"
#include "conf.h"
#include "dev.h"
#include "midi.h"
#include "wav.h"
#ifdef DEBUG
#include "dbg.h"
#endif

void wav_dbg(struct wav *);
void wav_conv(unsigned char *, unsigned int, short *);
unsigned int wav_read(struct file *, unsigned char *, unsigned int);
unsigned int wav_write(struct file *, unsigned char *, unsigned int);
void wav_close(struct file *);
int wav_attach(struct wav *, int);
void wav_midiattach(struct wav *);
void wav_allocbuf(struct wav *);
void wav_freebuf(struct wav *);
void wav_reset(struct wav *);
void wav_exit(struct wav *);
int wav_init(struct wav *);
int wav_seekmmc(struct wav *);
int wav_rdata(struct wav *);
int wav_wdata(struct wav *);
void wav_setvol(void *, unsigned int);
void wav_startreq(void *);
void wav_stopreq(void *);
void wav_locreq(void *, unsigned int);
void wav_quitreq(void *);
int wav_autohdr(char *, struct dev *, unsigned int *, unsigned int *);
void rwav_done(struct aproc *);
int rwav_in(struct aproc *, struct abuf *);
int rwav_out(struct aproc *, struct abuf *);
struct aproc *rwav_new(struct file *);
void wwav_done(struct aproc *);
int wwav_in(struct aproc *, struct abuf *);
int wwav_out(struct aproc *, struct abuf *);
struct aproc *wwav_new(struct file *);

short wav_ulawmap[256] = {
	-32124, -31100, -30076, -29052, -28028, -27004, -25980, -24956,
	-23932, -22908, -21884, -20860, -19836, -18812, -17788, -16764,
	-15996, -15484, -14972, -14460, -13948, -13436, -12924, -12412,
	-11900, -11388, -10876, -10364,  -9852,  -9340,  -8828,  -8316,
	 -7932,  -7676,  -7420,  -7164,  -6908,  -6652,  -6396,  -6140,
	 -5884,  -5628,  -5372,  -5116,  -4860,  -4604,  -4348,  -4092,
	 -3900,  -3772,  -3644,  -3516,  -3388,  -3260,  -3132,  -3004,
	 -2876,  -2748,  -2620,  -2492,  -2364,  -2236,  -2108,  -1980,
	 -1884,  -1820,  -1756,  -1692,  -1628,  -1564,  -1500,  -1436,
	 -1372,  -1308,  -1244,  -1180,  -1116,  -1052,   -988,   -924,
	  -876,   -844,   -812,   -780,   -748,   -716,   -684,   -652,
	  -620,   -588,   -556,   -524,   -492,   -460,   -428,   -396,
	  -372,   -356,   -340,   -324,   -308,   -292,   -276,   -260,
	  -244,   -228,   -212,   -196,   -180,   -164,   -148,   -132,
	  -120,   -112,   -104,    -96,    -88,    -80,    -72,    -64,
	   -56,    -48,    -40,    -32,    -24,    -16,     -8,      0,
	 32124,  31100,  30076,  29052,  28028,  27004,  25980,  24956,
	 23932,  22908,  21884,  20860,  19836,  18812,  17788,  16764,
	 15996,  15484,  14972,  14460,  13948,  13436,  12924,  12412,
	 11900,  11388,  10876,  10364,   9852,   9340,   8828,   8316,
	  7932,   7676,   7420,   7164,   6908,   6652,   6396,   6140,
	  5884,   5628,   5372,   5116,   4860,   4604,   4348,   4092,
	  3900,   3772,   3644,   3516,   3388,   3260,   3132,   3004,
	  2876,   2748,   2620,   2492,   2364,   2236,   2108,   1980,
	  1884,   1820,   1756,   1692,   1628,   1564,   1500,   1436,
	  1372,   1308,   1244,   1180,   1116,   1052,    988,    924,
	   876,    844,    812,    780,    748,    716,    684,    652,
	   620,    588,    556,    524,    492,    460,    428,    396,
	   372,    356,    340,    324,    308,    292,    276,    260,
	   244,    228,    212,    196,    180,    164,    148,    132,
	   120,    112,    104,     96,     88,     80,     72,     64,
	    56,     48,     40,     32,     24,     16,      8,      0
};

short wav_alawmap[256] = {
	 -5504,  -5248,  -6016,  -5760,  -4480,  -4224,  -4992,  -4736,
	 -7552,  -7296,  -8064,  -7808,  -6528,  -6272,  -7040,  -6784,
	 -2752,  -2624,  -3008,  -2880,  -2240,  -2112,  -2496,  -2368,
	 -3776,  -3648,  -4032,  -3904,  -3264,  -3136,  -3520,  -3392,
	-22016, -20992, -24064, -23040, -17920, -16896, -19968, -18944,
	-30208, -29184, -32256, -31232, -26112, -25088, -28160, -27136,
	-11008, -10496, -12032, -11520,  -8960,  -8448,  -9984,  -9472,
	-15104, -14592, -16128, -15616, -13056, -12544, -14080, -13568,
	  -344,   -328,   -376,   -360,   -280,   -264,   -312,   -296,
	  -472,   -456,   -504,   -488,   -408,   -392,   -440,   -424,
	   -88,    -72,   -120,   -104,    -24,     -8,    -56,    -40,
	  -216,   -200,   -248,   -232,   -152,   -136,   -184,   -168,
	 -1376,  -1312,  -1504,  -1440,  -1120,  -1056,  -1248,  -1184,
	 -1888,  -1824,  -2016,  -1952,  -1632,  -1568,  -1760,  -1696,
	  -688,   -656,   -752,   -720,   -560,   -528,   -624,   -592,
	  -944,   -912,  -1008,   -976,   -816,   -784,   -880,   -848,
	  5504,   5248,   6016,   5760,   4480,   4224,   4992,   4736,
	  7552,   7296,   8064,   7808,   6528,   6272,   7040,   6784,
	  2752,   2624,   3008,   2880,   2240,   2112,   2496,   2368,
	  3776,   3648,   4032,   3904,   3264,   3136,   3520,   3392,
	 22016,  20992,  24064,  23040,  17920,  16896,  19968,  18944,
	 30208,  29184,  32256,  31232,  26112,  25088,  28160,  27136,
	 11008,  10496,  12032,  11520,   8960,   8448,   9984,   9472,
	 15104,  14592,  16128,  15616,  13056,  12544,  14080,  13568,
	   344,    328,    376,    360,    280,    264,    312,    296,
	   472,    456,    504,    488,    408,    392,    440,    424,
	    88,     72,    120,    104,     24,      8,     56,     40,
	   216,    200,    248,    232,    152,    136,    184,    168,
	  1376,   1312,   1504,   1440,   1120,   1056,   1248,   1184,
	  1888,   1824,   2016,   1952,   1632,   1568,   1760,   1696,
	   688,    656,    752,    720,    560,    528,    624,    592,
	   944,    912,   1008,    976,    816,    784,    880,    848
};

/*
 * Max data of a .wav file. The total file size must be smaller than
 * 2^31, and we also have to leave some space for the headers (around 40
 * bytes).
 */
#define WAV_DATAMAX	(0x7fff0000)

struct fileops wav_ops = {
	"wav",
	sizeof(struct wav),
	wav_close,
	wav_read,
	wav_write,
	NULL, /* start */
	NULL, /* stop */
	pipe_nfds,
	pipe_pollfd,
	pipe_revents
};

struct wav *wav_list = NULL;

int rwav_in(struct aproc *, struct abuf *);
int rwav_out(struct aproc *, struct abuf *);
void rwav_eof(struct aproc *, struct abuf *);
void rwav_hup(struct aproc *, struct abuf *);
void rwav_done(struct aproc *);
struct aproc *rwav_new(struct file *);

int wwav_in(struct aproc *, struct abuf *);
int wwav_out(struct aproc *, struct abuf *);
void wwav_eof(struct aproc *, struct abuf *);
void wwav_hup(struct aproc *, struct abuf *);
void wwav_done(struct aproc *);
struct aproc *wwav_new(struct file *);

void wav_setvol(void *, unsigned int);
void wav_startreq(void *);
void wav_stopreq(void *);
void wav_locreq(void *, unsigned int);
void wav_quitreq(void *);

struct ctl_ops ctl_wavops = {
	wav_setvol,
	wav_startreq,
	wav_stopreq,
	wav_locreq,
	wav_quitreq
};

struct aproc_ops rwav_ops = {
	"rwav",
	rwav_in,
	rwav_out,
	rfile_eof,
	rfile_hup,
	NULL, /* newin */
	NULL, /* newout */
	NULL, /* ipos */
	NULL, /* opos */
	rwav_done
};

struct aproc_ops wwav_ops = {
	"wwav",
	wwav_in,
	wwav_out,
	wfile_eof,
	wfile_hup,
	NULL, /* newin */
	NULL, /* newout */
	NULL, /* ipos */
	NULL, /* opos */
	wwav_done
};

#ifdef DEBUG
/*
 * print the given wav structure
 */
void
wav_dbg(struct wav *f)
{
	static char *pstates[] = { "cfg", "ini", "sta", "rdy", "run", "mid" };

	dbg_puts("wav(");
	if (f->slot >= 0) {
		dbg_puts(f->dev->slot[f->slot].name);
		dbg_putu(f->dev->slot[f->slot].unit);
	} else
		dbg_puts(f->pipe.file.name);
	dbg_puts(")/");
	dbg_puts(pstates[f->pstate]);
}
#endif

/*
 * convert ``count'' samples using the given char->short map
 */
void
wav_conv(unsigned char *data, unsigned int count, short *map)
{
	unsigned int i;
	unsigned char *iptr;
	adata_t *optr;

	iptr = data + count;
	optr = (adata_t *)data + count;
	for (i = count; i > 0; i--) {
		--optr;
		--iptr;
		*optr = (adata_t)(map[*iptr]) << (ADATA_BITS - 16);
	}
}

/*
 * read method of the file structure
 */
unsigned int
wav_read(struct file *file, unsigned char *data, unsigned int count)
{
	struct wav *f = (struct wav *)file;
	unsigned int n;

	if (f->map)
		count /= sizeof(adata_t);
	if (f->rbytes >= 0 && count > f->rbytes) {
		count = f->rbytes; /* file->rbytes fits in count */
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 3) {
				wav_dbg(f);
				dbg_puts(": read complete\n");
			}
#endif
			if (!f->mmc)
				file_eof(&f->pipe.file);
			return 0;
		}
	}
	n = pipe_read(file, data, count);
	if (n == 0)
		return 0;
	if (f->rbytes >= 0)
		f->rbytes -= n;
	if (f->map) {
		wav_conv(data, n, f->map);
		n *= sizeof(adata_t);
	}
	return n;
}

/*
 * write method of the file structure
 */
unsigned int
wav_write(struct file *file, unsigned char *data, unsigned int count)
{
	struct wav *f = (struct wav *)file;
	unsigned int n;

	if (f->wbytes >= 0 && count > f->wbytes) {
		count = f->wbytes; /* wbytes fits in count */
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 3) {
				wav_dbg(f);
				dbg_puts(": write complete\n");
			}
#endif
			file_hup(&f->pipe.file);
			return 0;
		}
	}
	n = pipe_write(file, data, count);
	if (f->wbytes >= 0)
		f->wbytes -= n;
	f->endpos += n;
	return n;
}

/*
 * close method of the file structure
 */
void
wav_close(struct file *file)
{
	struct wav *f = (struct wav *)file, **pf;

	if (f->mode & MODE_RECMASK) {
		pipe_trunc(&f->pipe.file, f->endpos);
		if (f->hdr == HDR_WAV) {
			wav_writehdr(f->pipe.fd,
			    &f->hpar,
			    &f->startpos,
			    f->endpos - f->startpos);
		}
	}
	pipe_close(file);
	if (f->pstate != WAV_CFG)
		dev_unref(f->dev);
	for (pf = &wav_list; *pf != f; pf = &(*pf)->next) {
#ifdef DEBUG
		if (*pf == NULL) {
			dbg_puts("wav_close: not on list\n");
			dbg_panic();
		}
#endif
	}
	*pf = f->next;
}

/*
 * attach play (rec) abuf structure to the device and
 * switch to the ``RUN'' state; the play abug must not be empty
 */
int
wav_attach(struct wav *f, int force)
{
	struct abuf *rbuf = NULL, *wbuf = NULL;
	struct dev *d = f->dev;

	if (f->mode & MODE_PLAY)
		rbuf = LIST_FIRST(&f->pipe.file.rproc->outs);
	if (f->mode & MODE_RECMASK)
		wbuf = LIST_FIRST(&f->pipe.file.wproc->ins);
	f->pstate = WAV_RUN;
#ifdef DEBUG
	if (debug_level >= 3) {
		wav_dbg(f);
		dbg_puts(": attaching\n");
	}
#endif

	/*
	 * start the device (dev_getpos() and dev_attach() must
	 * be called on a started device
	 */
	dev_wakeup(d);

	dev_attach(d, f->pipe.file.name, f->mode,
	    rbuf, &f->hpar, f->join ? d->opar.cmax - d->opar.cmin + 1 : 0,
	    wbuf, &f->hpar, f->join ? d->ipar.cmax - d->ipar.cmin + 1 : 0,
	    f->xrun, f->maxweight);
	if (f->mode & MODE_PLAY)
		dev_setvol(d, rbuf, MIDI_TO_ADATA(f->vol));
	return 1;
}

/*
 * allocate buffers, so client can start filling write-end.
 */
void
wav_midiattach(struct wav *f)
{
	struct abuf *rbuf = NULL, *wbuf = NULL;
	
	if (f->mode & MODE_MIDIOUT) {
		rbuf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setout(f->pipe.file.rproc, rbuf);
	}
	if (f->mode & MODE_MIDIIN) {
		wbuf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setin(f->pipe.file.wproc, wbuf);
	}
	f->pstate = WAV_MIDI;
	dev_midiattach(f->dev, rbuf, wbuf);
}

/*
 * allocate the play (rec) abuf structure; if this is a
 * file to record, then attach it to the device
 *
 * XXX: buffer size should be larger than dev_bufsz, because
 *	in non-server mode we don't prime play buffers with
 *	silence
 */
void
wav_allocbuf(struct wav *f)
{
	struct abuf *buf;
	struct dev *d = f->dev;
	unsigned int nfr;

	f->pstate = WAV_START;
	if (f->mode & MODE_PLAY) {
		nfr = 2 * d->bufsz * f->hpar.rate / d->rate;
		buf = abuf_new(nfr, &f->hpar);
		aproc_setout(f->pipe.file.rproc, buf);
		abuf_fill(buf);
		if (!ABUF_WOK(buf) || (f->pipe.file.state & FILE_EOF))
			f->pstate = WAV_READY;
	}
	if (f->mode & MODE_RECMASK) {
		nfr = 2 * d->bufsz * f->hpar.rate / d->rate;
		buf = abuf_new(nfr, &f->hpar);
		aproc_setin(f->pipe.file.wproc, buf);
		f->pstate = WAV_READY;
	}
#ifdef DEBUG
	if (debug_level >= 3) {
		wav_dbg(f);
		dbg_puts(": allocating buffers\n");
	}
#endif
	if (f->pstate == WAV_READY && dev_slotstart(d, f->slot))
		(void)wav_attach(f, 0);
}

/*
 * free abuf structure and switch to the ``INIT'' state
 */
void
wav_freebuf(struct wav *f)
{
	struct abuf *rbuf = NULL, *wbuf = NULL;

	if (f->mode & MODE_PLAY)
		rbuf = LIST_FIRST(&f->pipe.file.rproc->outs);
	if (f->mode & MODE_RECMASK)
		wbuf = LIST_FIRST(&f->pipe.file.wproc->ins);
	f->pstate = WAV_INIT;
#ifdef DEBUG
	if (debug_level >= 3) {
		wav_dbg(f);
		dbg_puts(": freeing buffers\n");
	}
#endif
	if (rbuf || wbuf)
		dev_slotstop(f->dev, f->slot);
	if (rbuf)
		abuf_eof(rbuf);
	if (wbuf)
		abuf_hup(wbuf);
}

/*
 * switch to the ``INIT'' state performing
 * necessary actions to reach it
 */
void
wav_reset(struct wav *f)
{
	switch (f->pstate) {
	case WAV_START:
	case WAV_READY:
		if (dev_slotstart(f->dev, f->slot))
			(void)wav_attach(f, 1);
		/* PASSTHROUGH */
	case WAV_RUN:
		wav_freebuf(f);
		/* PASSTHROUGH */
	case WAV_INIT:
		/* nothing yet */
		break;
#ifdef DEBUG
	case WAV_MIDI:
		dbg_puts("wav_reset: in midi mode\n");
		dbg_panic();
#endif
	}
}

/*
 * terminate the wav reader/writer
 */
void
wav_exit(struct wav *f)
{
	/* XXX: call file_close() ? */
	if (f->mode & (MODE_PLAY | MODE_MIDIOUT)) {
		aproc_del(f->pipe.file.rproc);
	} else if (f->mode & (MODE_RECMASK | MODE_MIDIIN)) {
		aproc_del(f->pipe.file.wproc);
	}
}

/*
 * allocate the device
 */
int
wav_init(struct wav *f)
{
	if (!dev_ref(f->dev)) {
		wav_exit(f);
		return 0;
	}
	if (!f->mmc)
		f->dev->autostart = 1;
	if (f->mode & MODE_MIDIMASK) {
		wav_midiattach(f);
		return 1;
	}
	f->slot = dev_slotnew(f->dev, "wav", &ctl_wavops, f, 1);
	f->pstate = WAV_INIT;
	if ((f->mode & f->dev->mode) != f->mode) {
#ifdef DEBUG
		if (debug_level >= 1) {
			wav_dbg(f);
			dbg_puts(": ");
			dbg_puts(": operation not supported by device\n");
		}
#endif
		wav_exit(f);
		return 0;
	}
	wav_allocbuf(f);
	return 1;
}

/*
 * seek to f->mmcpos and prepare to start, close
 * the file on error.
 */
int
wav_seekmmc(struct wav *f)
{
	/*
	 * don't go beyond the end-of-file, if so
	 * put it in INIT state so it dosn't start
	 */
	if (f->mmcpos > f->endpos && !(f->mode & MODE_RECMASK)) {
		wav_reset(f);
		/*
		 * don't make other stream wait for us
		 */
		if (f->slot >= 0)
			dev_slotstart(f->dev, f->slot);
		return 0;
	}
	if (!pipe_seek(&f->pipe.file, f->mmcpos)) {
		wav_exit(f);
		return 0;
	}
	if ((f->mode & MODE_RECMASK) && f->mmcpos > f->endpos)
		f->endpos = f->mmcpos;
	if (f->hdr == HDR_WAV)
		f->wbytes = WAV_DATAMAX - f->mmcpos;
	f->rbytes = f->endpos - f->mmcpos;
	wav_reset(f);
	wav_allocbuf(f);
	return 1;
}

/*
 * read samples from the file and possibly start it
 */
int
wav_rdata(struct wav *f)
{
	struct aproc *p;
	struct abuf *obuf;

	p = f->pipe.file.rproc;
	obuf = LIST_FIRST(&p->outs);
	if (obuf == NULL)
		return 0;
	if (!ABUF_WOK(obuf) || !(f->pipe.file.state & FILE_ROK))
		return 0;
	if (!rfile_do(p, obuf->len, NULL))
		return 0;
	switch (f->pstate) {
	case WAV_START:
		if (!ABUF_WOK(obuf) || (f->pipe.file.state & FILE_EOF))
			f->pstate = WAV_READY;
		/* PASSTHROUGH */
	case WAV_READY:
		if (dev_slotstart(f->dev, f->slot))
			(void)wav_attach(f, 0);
		break;
	case WAV_RUN:
		break;
	case WAV_MIDI:
		return 1;
#ifdef DEBUG
	default:
		wav_dbg(f);
		dbg_puts(": bad state\n");
		dbg_panic();
#endif
	}
	if (f->rbytes == 0 && f->mmc) {
#ifdef DEBUG
		if (debug_level >= 3) {
			wav_dbg(f);
			dbg_puts(": trying to restart\n");
		}
#endif
		if (!wav_seekmmc(f))
			return 0;
	}
	return 1;
}

int
wav_wdata(struct wav *f)
{
	struct aproc *p;
	struct abuf *ibuf;

	if (!(f->pipe.file.state & FILE_WOK))
		return 0;
	p = f->pipe.file.wproc;
	ibuf = LIST_FIRST(&p->ins);
	if (ibuf == NULL)
		return 0;
	if (!ABUF_ROK(ibuf))
		return 0;
	if (!wfile_do(p, ibuf->len, NULL))
		return 0;
	return 1;
}

/*
 * callback to set the volume, invoked by the MIDI control code
 */
void
wav_setvol(void *arg, unsigned int vol)
{
	struct wav *f = (struct wav *)arg;
	struct abuf *rbuf;

	f->vol = vol;
	if ((f->mode & MODE_PLAY) && f->pstate == WAV_RUN) {
		rbuf = LIST_FIRST(&f->pipe.file.rproc->outs);
		dev_setvol(f->dev, rbuf, MIDI_TO_ADATA(vol));
	}
}

/*
 * callback to start the stream, invoked by the MIDI control code
 */
void
wav_startreq(void *arg)
{
	struct wav *f = (struct wav *)arg;

	switch (f->pstate) {
	case WAV_INIT:
#ifdef DEBUG
		if (debug_level >= 2) {
			wav_dbg(f);
			dbg_puts(": skipped (failed to seek)\n");
		}
#endif
		return;
	case WAV_READY:
		if (f->mode & MODE_RECMASK)
			f->endpos = f->mmcpos + f->startpos;
		(void)wav_attach(f, 0);
		break;
#ifdef DEBUG
	default:
		wav_dbg(f);
		dbg_puts(": not in READY state\n");
		dbg_panic();
		break;
#endif
	}
}

/*
 * callback to stop the stream, invoked by the MIDI control code
 */
void
wav_stopreq(void *arg)
{
	struct wav *f = (struct wav *)arg;

#ifdef DEBUG
	if (debug_level >= 2) {
		wav_dbg(f);
		dbg_puts(": stopping");
		if (f->pstate != WAV_INIT && (f->mode & MODE_RECMASK)) {
			dbg_puts(", ");
			dbg_putu(f->endpos);
			dbg_puts(" bytes recorded");
		}
		dbg_puts("\n");
	}
#endif
	if (!f->mmc) {
		wav_exit(f);
		return;
	}
	(void)wav_seekmmc(f);
}

/*
 * callback to relocate the stream, invoked by the MIDI control code
 * on a stopped stream
 */
void
wav_locreq(void *arg, unsigned int mmc)
{
	struct wav *f = (struct wav *)arg;

#ifdef DEBUG
	if (f->pstate == WAV_RUN) {
		wav_dbg(f);
		dbg_puts(": in RUN state\n");
		dbg_panic();
	}
#endif
	f->mmcpos = f->startpos + 
	    ((off_t)mmc * f->hpar.rate / MTC_SEC) * aparams_bpf(&f->hpar);
	(void)wav_seekmmc(f);
}

/*
 * Callback invoked when slot is gone
 */
void
wav_quitreq(void *arg)
{
	struct wav *f = (struct wav *)arg;

#ifdef DEBUG
	if (debug_level >= 3) {
		wav_dbg(f);
		dbg_puts(": slot gone\n");
	}
#endif
	if (f->pstate != WAV_RUN)
		wav_exit(f);
}

/*
 * determine the header by the file name
 */
int
wav_autohdr(char *name, struct dev *dev, unsigned int *hdr, unsigned int *mode)
{
	char *ext;

	if (dev->reqmode & MODE_THRU)
		*mode &= MODE_MIDIMASK;
	if (*hdr == HDR_AUTO) {
		ext = strrchr(name, '.');
		if (ext != NULL) {
			ext++;
			if (strcasecmp(ext, "wav") == 0) {
				*hdr = HDR_WAV;
				*mode &= ~MODE_MIDIMASK;
			} else if (strcasecmp(ext, "syx") == 0) {
				*hdr = HDR_RAW;
				*mode &= ~MODE_AUDIOMASK;
			}
		} else
			*hdr = HDR_RAW;
	}
	if (*mode & MODE_AUDIOMASK)
		*mode &= ~MODE_MIDIMASK;
	if (*mode == 0) {
#ifdef DEBUG
		if (debug_level >= 1) {
			dbg_puts(name);
			dbg_puts(": requested mode not supported\n");
		}
#endif
		return 0;
	}
	return 1;
}

/*
 * create a file reader in the ``INIT'' state
 */
struct wav *
wav_new_in(struct fileops *ops, struct dev *dev,
    unsigned int mode, char *name, unsigned int hdr,
    struct aparams *par, unsigned int xrun,
    unsigned int volctl, int mmc, int join)
{
	int fd;
	struct wav *f;

	if (!wav_autohdr(name, dev, &hdr, &mode))
		return NULL;
	if (strcmp(name, "-") == 0) {
		fd = STDIN_FILENO;
		if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)
			perror(name);
	} else {
		fd = open(name, O_RDONLY | O_NONBLOCK, 0666);
		if (fd < 0) {
			perror(name);
			return NULL;
		}
	}
	f = (struct wav *)pipe_new(ops, fd, name);
	if (f == NULL) {
		close(fd);
		return NULL;
	}
	f->mode = mode;
	f->pstate = WAV_CFG;
	f->endpos = f->startpos = 0;
	f->next = wav_list;
	wav_list = f;
	if (hdr == HDR_WAV) {
		if (!wav_readhdr(f->pipe.fd, par,
			&f->startpos, &f->rbytes, &f->map)) {
			file_del((struct file *)f);
			return NULL;
		}
		f->endpos = f->startpos + f->rbytes;
	} else {
		f->endpos = pipe_endpos(&f->pipe.file);
		if (f->endpos > 0) {
			if (!pipe_seek(&f->pipe.file, 0)) {
				file_del((struct file *)f);
				return NULL;
			}
			f->rbytes = f->endpos;
		} else
			f->rbytes = -1;
		f->map = NULL;
	}
	f->dev = dev;
	f->mmc = mmc;
	f->join = join;
	f->mode = mode;
	f->hpar = *par;
	f->hdr = hdr;
	f->xrun = xrun;
	f->maxweight = MIDI_TO_ADATA(volctl);
	f->slot = -1;
	rwav_new((struct file *)f);
#ifdef DEBUG
	if (debug_level >= 2) {
		dbg_puts(name);
		dbg_puts(":");
		if (f->mode & MODE_PLAY) {
			dbg_puts(" playing ");
			aparams_dbg(par);
			dbg_puts(" ");
			dbg_putu(f->startpos);
			dbg_puts("..");
			dbg_putu(f->endpos);
			if (f->mmc)
				dbg_puts(", mmc");
		}
		if (f->mode & MODE_MIDIOUT)
			dbg_puts(" midi/out");
		dbg_puts("\n");
	}
#endif
	return f;
}

/*
 * create a file writer in the ``INIT'' state
 */
struct wav *
wav_new_out(struct fileops *ops, struct dev *dev,
    unsigned int mode, char *name, unsigned int hdr,
    struct aparams *par, unsigned int xrun, int mmc, int join)
{
	int fd;
	struct wav *f;

	if (!wav_autohdr(name, dev, &hdr, &mode))
		return NULL;
	if (strcmp(name, "-") == 0) {
		fd = STDOUT_FILENO;
		if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)
			perror(name);
	} else {
		fd = open(name,
		    O_WRONLY | O_TRUNC | O_CREAT | O_NONBLOCK, 0666);
		if (fd < 0) {
			perror(name);
			return NULL;
		}
	}
	f = (struct wav *)pipe_new(ops, fd, name);
	if (f == NULL) {
		close(fd);
		return NULL;
	}
	f->mode = mode;
	f->pstate = WAV_CFG;
	f->mmcpos = f->endpos = f->startpos = 0;
	f->next = wav_list;
	wav_list = f;
	if (hdr == HDR_WAV) {
		par->le = 1;
		par->sig = (par->bits <= 8) ? 0 : 1;
		par->bps = (par->bits + 7) / 8;
		if (!wav_writehdr(f->pipe.fd, par, &f->startpos, 0)) {
			file_del((struct file *)f);
			return NULL;
		}
		f->wbytes = WAV_DATAMAX;
		f->endpos = f->startpos;
	} else
		f->wbytes = -1;
	f->dev = dev;
	f->mmc = mmc;
	f->join = join;
	f->hpar = *par;
	f->hdr = hdr;
	f->xrun = xrun;
	wwav_new((struct file *)f);
#ifdef DEBUG
	if (debug_level >= 2) {
		dbg_puts(name);
		dbg_puts(":");
		if (f->mode & MODE_RECMASK) {
			dbg_puts(" recording ");
			aparams_dbg(par);
			if (f->mmc)
				dbg_puts(", mmc");
		}
		if (f->mode & MODE_MIDIIN)
			dbg_puts(" midi/in");
		dbg_puts("\n");
	}
#endif
	return f;
}

void
rwav_done(struct aproc *p)
{
	struct wav *f = (struct wav *)p->u.io.file;

	if (f->slot >= 0)
		dev_slotdel(f->dev, f->slot);
	f->slot = -1;
	rfile_done(p);
}

int
rwav_in(struct aproc *p, struct abuf *ibuf_dummy)
{
	struct wav *f = (struct wav *)p->u.io.file;
	struct abuf *obuf;

	if (!wav_rdata(f))
		return 0;
	obuf = LIST_FIRST(&p->outs);
	if (obuf && f->pstate >= WAV_RUN) {
		if (!abuf_flush(obuf))
			return 0;
	}
	return 1;
}

int
rwav_out(struct aproc *p, struct abuf *obuf)
{
	struct wav *f = (struct wav *)p->u.io.file;

	if (f->pipe.file.state & FILE_RINUSE)
		return 0;
	for (;;) {
		if (!wav_rdata(f))
			return 0;
	}
	return 1;
}

struct aproc *
rwav_new(struct file *f)
{
	struct aproc *p;

	p = aproc_new(&rwav_ops, f->name);
	p->u.io.file = f;
	p->u.io.partial = 0;
	f->rproc = p;
	return p;
}

void
wwav_done(struct aproc *p)
{
	struct wav *f = (struct wav *)p->u.io.file;

	if (f->slot >= 0)
		dev_slotdel(f->dev, f->slot);
	f->slot = -1;
	wfile_done(p);
}

int
wwav_in(struct aproc *p, struct abuf *ibuf)
{
	struct wav *f = (struct wav *)p->u.io.file;

	if (f->pipe.file.state & FILE_WINUSE)
		return 0;
	for (;;) {
		if (!wav_wdata(f))
			return 0;
	}
	return 1;
}

int
wwav_out(struct aproc *p, struct abuf *obuf_dummy)
{
	struct abuf *ibuf = LIST_FIRST(&p->ins);
	struct wav *f = (struct wav *)p->u.io.file;

	if (ibuf && f->pstate == WAV_RUN) {
		if (!abuf_fill(ibuf))
			return 0;
	}
	if (!wav_wdata(f))
		return 0;
	return 1;
}

struct aproc *
wwav_new(struct file *f)
{
	struct aproc *p;

	p = aproc_new(&wwav_ops, f->name);
	p->u.io.file = f;
	p->u.io.partial = 0;
	f->wproc = p;
	return p;
}
@


1.36
log
@initialize mmcpos, found by guenther
@
text
@@


1.35
log
@add missing prototypes
@
text
@d916 1
a916 1
	f->endpos = f->startpos = 0;
@


1.34
log
@remove bogus legacy server-specific bits that cause confusion
@
text
@d33 30
@


1.33
log
@Dont insert twice recorded wav files (-o) on the list of recorded files;
with help from Remco <remco at d-compu.dyndns.org>
@
text
@a28 1
#include "opt.h"
@


1.32
log
@Initialize wav structure enough for wav_close() to work in the error
code path. Fixes crashes when wav_close() is called on uninitialized
wav structure. With help from Remco <remco at d-compu.dyndns.org>,
thanks!
@
text
@a923 2
	f->next = wav_list;
	wav_list = f;
@


1.31
log
@unbreak compilation without DEBUG defined
@
text
@d799 1
d801 3
a811 1
		f->startpos = 0;
a851 2
	f->next = wav_list;
	wav_list = f;
d885 1
d887 3
d900 1
a900 1
	} else {
a901 2
		f->startpos = f->endpos = 0;
	}
a904 1
	f->mode = mode;
@


1.30
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d459 1
d463 1
@


1.29
log
@don't add .wav header to .syx files
@
text
@d140 1
a140 1
void wav_setvol(void *, unsigned);
d143 1
a143 1
void wav_locreq(void *, unsigned);
d204 1
a204 1
wav_conv(unsigned char *data, unsigned count, short *map)
d206 1
a206 1
	unsigned i;
d222 2
a223 2
unsigned
wav_read(struct file *file, unsigned char *data, unsigned count)
d226 1
a226 1
	unsigned n;
d259 2
a260 2
unsigned
wav_write(struct file *file, unsigned char *data, unsigned count)
d263 1
a263 1
	unsigned n;
d386 1
a386 1
	unsigned nfr;
d619 1
a619 1
wav_setvol(void *arg, unsigned vol)
d695 1
a695 1
wav_locreq(void *arg, unsigned mmc)
d733 1
a733 1
wav_autohdr(char *name, struct dev *dev, unsigned *hdr, unsigned *mode)
d772 3
a774 2
    unsigned mode, char *name, unsigned hdr,
    struct aparams *par, unsigned xrun, unsigned volctl, int mmc, int join)
d857 2
a858 2
    unsigned mode, char *name, unsigned hdr,
    struct aparams *par, unsigned xrun, int mmc, int join)
@


1.28
log
@Move mmc/mtc and volume control bits from struct aproc to struct
dev. Allows volume settings to be saved while the device is kept
closed. Besides that, no behabiour changes.
@
text
@d747 1
a747 1
				*hdr = HDR_WAV;
@


1.27
log
@Simplify and improve the way options are parsed and remove ~300 lines
of code that becomes unused. Few command line arguments changes are
required though:

  - stream definitions (-ios) now must follow devices definitions they
    are attached to (-fMn)

  - the -n option is now a special "loopback" device and is thus used
    like -f, eg it must precede streams

  - in midicat, midi thru boxes are not created automatically anymore,
    the new "-M" option must be used for that

  - channel numbers (-Cc options) correspond always to channel numbers
    of the hardware.

  - the -u option isn't needed anymore

  - increase the log verbosity so user errors are logged
    without using -d

tested by many, help from jmc
@
text
@a187 1
	struct aproc *midi = f->dev ? f->dev->midi : NULL;
d190 3
a192 3
	if (f->slot >= 0 && APROC_OK(midi)) {
		dbg_puts(midi->u.ctl.slot[f->slot].name);
		dbg_putu(midi->u.ctl.slot[f->slot].unit);
d409 1
a409 1
	if (f->pstate == WAV_READY && ctl_slotstart(d->midi, f->slot))
d433 1
a433 1
		ctl_slotstop(f->dev->midi, f->slot);
d450 1
a450 1
		if (ctl_slotstart(f->dev->midi, f->slot))
d495 1
a495 1
	f->slot = ctl_slotnew(f->dev->midi, "wav", &ctl_wavops, f, 1);
d529 1
a529 1
			ctl_slotstart(f->dev->midi, f->slot);
d536 1
a536 1
	if (f->mode & MODE_RECMASK)
d569 1
a569 1
		if (ctl_slotstart(f->dev->midi, f->slot))
d930 1
a930 1
		ctl_slotdel(f->dev->midi, f->slot);
d983 1
a983 1
		ctl_slotdel(f->dev->midi, f->slot);
@


1.26
log
@Reorganize the way command line options are parsed and stored.
No behaviour change.
@
text
@d124 2
d187 1
a187 1
	static char *pstates[] = { "ini", "sta", "rdy", "run", "fai" };
d292 1
a292 1
	struct wav *f = (struct wav *)file;
d304 1
a304 1
	if (f->dev) {
d306 7
a312 1
		f->dev = NULL;
d314 1
d355 20
a455 1
		f->pstate = WAV_INIT;
a457 1
	case WAV_FAILED:
d460 3
d473 1
a473 1
	if (f->mode & MODE_PLAY) {
d475 1
a475 1
	} else if (f->mode & MODE_RECMASK) {
d481 33
d524 1
a524 1
	if (f->mmcpos > f->endpos) {
a525 1
		f->pstate = WAV_FAILED;
d537 2
a572 1
#ifdef DEBUG
d575 3
d641 1
a641 1
	case WAV_FAILED:
d651 1
a651 1
			f->endpos = f->startpos;
d676 1
a676 1
		if (f->pstate != WAV_FAILED && (f->mode & MODE_RECMASK)) {
d733 2
a734 2
unsigned
wav_autohdr(char *name, unsigned hdr)
d736 1
a736 1
	size_t len;
d738 28
a765 9
	if (hdr != HDR_AUTO)
		return hdr;
	if (name == NULL)
		return HDR_RAW;
	len = strlen(name);
	if (len >= 4 && strcasecmp(name + len - 4, ".wav") == 0)
		return HDR_WAV;
	else
		return HDR_RAW;
d772 3
a774 3
wav_new_in(struct fileops *ops,
    struct dev *dev, unsigned mode, char *name, unsigned hdr,
    struct aparams *par, unsigned xrun, unsigned volctl, int tr, int join)
d779 7
a785 2
	hdr = wav_autohdr(name, hdr);
	if (name != NULL) {
a790 5
	} else {
		name = "stdin";
		fd = STDIN_FILENO;
		if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)
			perror(name);
d797 1
a797 14
	if (!dev_ref(dev)) {
		close(fd);
		return NULL;
	}
	if (!(dev->mode & MODE_PLAY)) {
#ifdef DEBUG
		dbg_puts(name);
		dbg_puts(": device can't play\n");
#endif
		close(fd);
		dev_unref(dev);
		return NULL;
	}
	f->dev = dev;
d799 2
a800 1
		if (!wav_readhdr(f->pipe.fd, par, &f->startpos, &f->rbytes, &f->map)) {
d818 2
a819 2
	f->pstate = WAV_INIT;
	f->mmc = tr;
d826 1
a826 1
	f->slot = ctl_slotnew(f->dev->midi, "play", &ctl_wavops, f, 1);
a827 1
	wav_allocbuf(f);
d831 13
a843 8
		dbg_puts(": playing ");
		dbg_putu(f->startpos);
		dbg_puts("..");
		dbg_putu(f->endpos);
		dbg_puts(": playing ");
		aparams_dbg(par);
		if (f->mmc)
			dbg_puts(", mmc");
d847 2
d856 3
a858 3
wav_new_out(struct fileops *ops,
    struct dev *dev, unsigned mode, char *name, unsigned hdr,
    struct aparams *par, unsigned xrun, int tr, int join)
d863 3
a865 3
	hdr = wav_autohdr(name, hdr);
	if (name == NULL) {
		name = "stdout";
d882 1
a882 14
	if (!dev_ref(dev)) {
		close(fd);
		return NULL;
	}
	if (!(dev->mode & MODE_RECMASK)) {
#ifdef DEBUG
		dbg_puts(name);
		dbg_puts(": device can't record\n");
#endif
		close(fd);
		dev_unref(dev);
		return NULL;
	}
	f->dev = dev;
d897 2
a898 2
	f->pstate = WAV_INIT;
	f->mmc = tr;
a903 1
	f->slot = ctl_slotnew(f->dev->midi, "rec", &ctl_wavops, f, 1);
a904 1
	wav_allocbuf(f);
d908 9
a916 2
		dbg_puts(": recording ");
		aparams_dbg(par);
d920 2
a1028 1

@


1.25
log
@initialize 'pstate' field of the wav structure
@
text
@d17 1
d20 1
a20 1
#include <fcntl.h>
d665 19
d694 1
d750 1
a750 1
	f->hdr = 0;
d784 1
@


1.24
log
@clean up cases of ;;
@
text
@d724 1
d809 1
@


1.23
log
@Convert ulaw/alaw to native format (ie using ADATA_XXX defines) rather
than s16 (using hardcoded constants). Currently s16 is the native format,
so no behavior change.
@
text
@d876 1
a876 1
	p->u.io.partial = 0;;
d928 1
a928 1
	p->u.io.partial = 0;;
@


1.22
log
@add forgotten ``return NULL'' when a .wav file fails to get the
device with the required mode
@
text
@d206 1
a206 1
	short *optr;
d209 1
a209 1
	optr = (short *)data + count;
d213 1
a213 1
		*optr = map[*iptr];
d227 1
a227 1
		count /= sizeof(short);
d249 1
a249 1
		n *= sizeof(short);
@


1.21
log
@when attaching files to play or record to the device, check that
the device supports play or record modes respectively.

spotted by jakemsr
@
text
@d702 1
d791 1
@


1.20
log
@Allow the audio device to be opened only while it's actually used.
This is necessary for uaudio devices, for instance to start aucat
before the device is plugged. Or to unplug a device whithout
having to restart aucat when another device is plugged.  This is
controlled with the new -a option.

Allow multiple audio devices to be used concurently, i.e.
multiple ``-f devname'' options to be used; -f options must follow
per-device options, which is what we do for other options.
@
text
@d695 8
d782 8
@


1.19
log
@prime play buffers as soon as the device is opened, otherwise a
midi client could start it with empty buffers, in turn hurting
audio clients.
@
text
@d141 1
d147 2
a148 1
	wav_locreq
d185 1
d188 3
a190 3
	if (f->slot >= 0 && APROC_OK(dev_midi)) {
		dbg_puts(dev_midi->u.ctl.slot[f->slot].name);
		dbg_putu(dev_midi->u.ctl.slot[f->slot].unit);
d237 1
a237 1
			if (!f->tr)
d301 4
a304 1
	dev_unref();
d315 1
d333 1
a333 1
	dev_wakeup();
d335 3
a337 3
	dev_attach(f->pipe.file.name, f->mode,
	    rbuf, &f->hpar, f->join ? dev_opar.cmax - dev_opar.cmin + 1 : 0,
	    wbuf, &f->hpar, f->join ? dev_ipar.cmax - dev_ipar.cmin + 1 : 0,
d340 1
a340 1
		dev_setvol(rbuf, MIDI_TO_ADATA(f->vol));
d356 1
d361 1
a361 1
		nfr = 2 * dev_bufsz * f->hpar.rate / dev_rate;
d369 1
a369 1
		nfr = 2 * dev_bufsz * f->hpar.rate / dev_rate;
d380 1
a380 1
	if (f->pstate == WAV_READY && ctl_slotstart(dev_midi, f->slot))
d404 1
a404 1
		ctl_slotstop(dev_midi, f->slot);
d421 1
a421 1
		if (ctl_slotstart(dev_midi, f->slot))
d441 1
d467 1
a467 1
			ctl_slotstart(dev_midi, f->slot);
d505 1
a505 1
		if (ctl_slotstart(dev_midi, f->slot))
d517 1
a517 1
	if (f->rbytes == 0 && f->tr) {
d561 1
a561 1
		dev_setvol(rbuf, MIDI_TO_ADATA(vol));
d617 1
a617 1
	if (!f->tr) {
d646 18
d667 2
a668 1
wav_new_in(struct fileops *ops, unsigned mode, char *name, unsigned hdr, 
d691 1
a691 1
	if (!dev_ref()) {
d695 1
d715 1
a715 1
	f->tr = tr;
d722 1
a722 1
	f->slot = ctl_slotnew(dev_midi, "play", &ctl_wavops, f, 1);
d734 1
a734 1
		if (f->tr)
d746 2
a747 1
wav_new_out(struct fileops *ops, unsigned mode, char *name, unsigned hdr,
d771 1
a771 1
	if (!dev_ref()) {
d775 1
d790 1
a790 1
	f->tr = tr;
d796 1
a796 1
	f->slot = ctl_slotnew(dev_midi, "rec", &ctl_wavops, f, 1);
d816 1
a816 1
		ctl_slotdel(dev_midi, f->slot);
d869 1
a869 1
		ctl_slotdel(dev_midi, f->slot);
@


1.18
log
@Clean up device handling code to clarify different initialization phases
and different device states. Split initialization in two phases:
first global variables are initialized then the audio hardware is opened.
Allow devices that don't support full-duplex to work in play-only or
record-only mode, even if ``-m play'' or ``-m rec'' are not specified.
@
text
@d326 1
a326 1
	dev_wakeup(0);
@


1.17
log
@rename ibuflist/obuflist -> ins/outs to cut long lines
from Thomas Pfaff, thanks
@
text
@d298 1
d321 7
d659 6
a664 1
	if (f == NULL)
d666 1
d737 2
a738 1
	if (f == NULL)
d740 5
@


1.16
log
@adds the necessary bits to join channels (ex stereo->mono) or
expand channels (ex mono->stereo).  It's switched on/off with
the ``-j'' option, (default is "on").
@
text
@d310 1
a310 1
		rbuf = LIST_FIRST(&f->pipe.file.rproc->obuflist);
d312 1
a312 1
		wbuf = LIST_FIRST(&f->pipe.file.wproc->ibuflist);
d377 1
a377 1
		rbuf = LIST_FIRST(&f->pipe.file.rproc->obuflist);
d379 1
a379 1
		wbuf = LIST_FIRST(&f->pipe.file.wproc->ibuflist);
d475 1
a475 1
	obuf = LIST_FIRST(&p->obuflist);
d522 1
a522 1
	ibuf = LIST_FIRST(&p->ibuflist);
d543 1
a543 1
		rbuf = LIST_FIRST(&f->pipe.file.rproc->obuflist);
d778 1
a778 1
	obuf = LIST_FIRST(&p->obuflist);
d840 1
a840 1
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
@


1.15
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d321 3
a323 1
	    rbuf, &f->hpar, wbuf, &f->hpar, f->xrun, f->maxweight);
d633 1
a633 1
    struct aparams *par, unsigned xrun, unsigned volctl, int tr)
d673 1
d704 1
a704 1
    struct aparams *par, unsigned xrun, int tr)
d740 1
@


1.14
log
@backout last change, committed by mistake, sorry...
@
text
@d26 1
d28 1
d128 1
d135 13
d153 2
a154 2
	rwav_eof,
	rwav_hup,
d166 2
a167 2
	wwav_eof,
	wwav_hup,
d175 25
a199 2
struct aproc *
rwav_new(struct file *f)
d201 3
a203 1
	struct aproc *p;
d205 7
a211 4
	p = aproc_new(&rwav_ops, f->name);
	p->u.io.file = f;
	f->rproc = p;
	return p;
d214 5
a218 2
int
rwav_in(struct aproc *p, struct abuf *ibuf_dummy)
d220 21
a240 10
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
	struct file *f = p->u.io.file;
	unsigned char *data;
	unsigned count;

	if (ABUF_FULL(obuf) || !(f->state & FILE_ROK))
		return 0;
	data = abuf_wgetblk(obuf, &count, 0);
	count = file_read(f, data, count);
	if (count == 0)
d242 56
a297 4
	abuf_wcommit(obuf, count);
	if (!abuf_flush(obuf))
		return 0;
	return 1;
d300 4
d305 1
a305 1
rwav_out(struct aproc *p, struct abuf *obuf)
d307 1
a307 3
	struct file *f = p->u.io.file;
	unsigned char *data;
	unsigned count;
d309 15
a323 9
	if (f->state & FILE_RINUSE)
		return 0;
	if (ABUF_FULL(obuf) || !(f->state & FILE_ROK))
		return 0;
	data = abuf_wgetblk(obuf, &count, 0);
	count = file_read(f, data, count);
	if (count == 0)
		return 0;
	abuf_wcommit(obuf, count);
d327 8
d336 1
a336 1
rwav_done(struct aproc *p)
d338 2
a339 2
	struct file *f = p->u.io.file;
	struct abuf *obuf;
d341 23
a363 15
	if (f == NULL)
		return;
	/*
	 * all buffers must be detached before deleting f->wproc,
	 * because otherwise it could trigger this code again
	 */
	obuf = LIST_FIRST(&p->obuflist);
	if (obuf)
		abuf_eof(obuf);
	if (f->wproc) {
		f->rproc = NULL;
		aproc_del(f->wproc);
	} else
		file_del(f);
	p->u.io.file = NULL;
d366 3
d370 1
a370 1
rwav_eof(struct aproc *p, struct abuf *ibuf_dummy)
d372 19
a390 1
	aproc_del(p);
d393 4
d398 1
a398 1
rwav_hup(struct aproc *p, struct abuf *obuf)
d400 15
a414 1
	aproc_del(p);
d417 5
a421 2
struct aproc *
wwav_new(struct file *f)
d423 5
a427 6
	struct aproc *p;

	p = aproc_new(&wwav_ops, f->name);
	p->u.io.file = f;
	f->wproc = p;
	return p;
d430 6
a435 2
void
wwav_done(struct aproc *p)
a436 5
	struct file *f = p->u.io.file;
	struct abuf *ibuf;

	if (f == NULL)
		return;
d438 2
a439 2
	 * all buffers must be detached before deleting f->rproc,
	 * because otherwise it could trigger this code again
d441 20
a460 9
	ibuf = LIST_FIRST(&p->ibuflist);
	if (ibuf)
		abuf_hup(ibuf);
	if (f->rproc) {
		f->wproc = NULL;
		aproc_del(f->rproc);
	} else
		file_del(f);
	p->u.io.file = NULL;
d463 3
d467 1
a467 1
wwav_in(struct aproc *p, struct abuf *ibuf)
d469 2
a470 3
	struct file *f = p->u.io.file;
	unsigned char *data;
	unsigned count;
d472 3
a474 1
	if (f->state & FILE_WINUSE)
d476 1
a476 1
	if (ABUF_EMPTY(ibuf) || !(f->state & FILE_WOK))
d478 1
a478 3
	data = abuf_rgetblk(ibuf, &count, 0);
	count = file_write(f, data, count);
	if (count == 0)
d480 28
a507 1
	abuf_rdiscard(ibuf, count);
d512 1
a512 1
wwav_out(struct aproc *p, struct abuf *obuf_dummy)
d514 2
a515 4
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
	struct file *f = p->u.io.file;
	unsigned char *data;
	unsigned count;
d517 1
a517 1
	if (!abuf_fill(ibuf))
d519 3
a521 1
	if (ABUF_EMPTY(ibuf) || !(f->state & FILE_WOK))
d523 1
a523 3
	data = abuf_rgetblk(ibuf, &count, 0);
	if (count == 0) {
		/* XXX: this can't happen, right ? */
d525 1
a525 3
	}
	count = file_write(f, data, count);
	if (count == 0)
a526 1
	abuf_rdiscard(ibuf, count);
d530 51
d582 1
a582 1
wwav_eof(struct aproc *p, struct abuf *ibuf)
d584 19
a602 1
	aproc_del(p);
d605 4
d610 1
a610 1
wwav_hup(struct aproc *p, struct abuf *obuf_dummy)
d612 12
a623 1
	aproc_del(p);
d626 3
d630 2
a631 2
wav_new_in(struct fileops *ops, char *name, unsigned hdr, 
    struct aparams *par, unsigned xrun, unsigned volctl)
a634 3
	struct aproc *p;
	struct abuf *buf;
	unsigned nfr;
d652 1
a652 1
		if (!wav_readhdr(f->pipe.fd, par, &f->rbytes, &f->map)) {
d656 1
a656 1
		f->hpar = *par;
d658 10
a667 1
		f->rbytes = -1;
d670 3
d674 5
a678 7
	nfr = dev_bufsz * par->rate / dev_rate;
	buf = abuf_new(nfr, par);
	p = rwav_new((struct file *)f);
	aproc_setout(p, buf);
	abuf_fill(buf); /* XXX: move this in dev_attach() ? */
	dev_attach(name, buf, par, xrun, NULL, NULL, 0, ADATA_UNIT);
	dev_setvol(buf, MIDI_TO_ADATA(volctl));
d683 4
d688 2
d696 3
d700 2
a701 2
wav_new_out(struct fileops *ops, char *name, unsigned hdr,
    struct aparams *par, unsigned xrun)
a704 3
	struct aproc *p;
	struct abuf *buf;
	unsigned nfr;
d726 1
a726 1
		if (!wav_writehdr(f->pipe.fd, par)) {
a729 1
		f->hpar = *par;
d731 2
a732 1
	} else
d734 5
d740 4
a743 5
	nfr = dev_bufsz * par->rate / dev_rate;
	p = wwav_new((struct file *)f);
	buf = abuf_new(nfr, par);
	aproc_setin(p, buf);
	dev_attach(name, NULL, NULL, 0, buf, par, xrun, 0);
d756 12
a767 1
wav_conv(unsigned char *data, unsigned count, short *map)
d769 2
a770 3
	unsigned i;
	unsigned char *iptr;
	short *optr;
d772 6
a777 6
	iptr = data + count;
	optr = (short *)data + count;
	for (i = count; i > 0; i--) {
		--optr;
		--iptr;
		*optr = map[*iptr];
d779 1
d782 2
a783 2
unsigned
wav_read(struct file *file, unsigned char *data, unsigned count)
d785 1
a785 2
	struct wav *f = (struct wav *)file;
	unsigned n;
d787 4
a790 12
	if (f->map)
		count /= sizeof(short);
	if (f->rbytes >= 0 && count > f->rbytes) {
		count = f->rbytes; /* file->rbytes fits in count */
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 3) {
				file_dbg(&f->pipe.file);
				dbg_puts(": read complete\n");
			}
#endif
			file_eof(&f->pipe.file);
a791 1
		}
d793 32
a824 2
	n = pipe_read(file, data, count);
	if (n == 0)
d826 3
a828 5
	if (f->rbytes >= 0)
		f->rbytes -= n;
	if (f->map) {
		wav_conv(data, n, f->map);
		n *= sizeof(short);
d830 1
a830 1
	return n;
d833 2
a834 2
unsigned
wav_write(struct file *file, unsigned char *data, unsigned count)
d836 2
a837 2
	struct wav *f = (struct wav *)file;
	unsigned n;
d839 2
a840 10
	if (f->wbytes >= 0 && count > f->wbytes) {
		count = f->wbytes; /* wbytes fits in count */
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 3) {
				file_dbg(&f->pipe.file);
				dbg_puts(": write complete\n");
			}
#endif
			file_hup(&f->pipe.file);
a841 1
		}
d843 3
a845 4
	n = pipe_write(file, data, count);
	if (f->wbytes >= 0)
		f->wbytes -= n;
	return n;
d848 2
a849 2
void
wav_close(struct file *file)
d851 1
a851 1
	struct wav *f = (struct wav *)file;
d853 5
a857 3
	if (f->hdr == HDR_WAV)
		wav_writehdr(f->pipe.fd, &f->hpar);
	pipe_close(file);
@


1.13
log
@doc fixes from jmc
@
text
@a25 1
#include "midi.h"
a26 1
#include "opt.h"
a125 1
struct aproc *rwav_new(struct file *);
a131 13
struct aproc *wwav_new(struct file *);

void wav_setvol(void *, unsigned);
void wav_startreq(void *);
void wav_stopreq(void *);
void wav_locreq(void *, unsigned);

struct ctl_ops ctl_wavops = {
	wav_setvol,
	wav_startreq,
	wav_stopreq,
	wav_locreq
};
d137 2
a138 2
	rfile_eof,
	rfile_hup,
d150 2
a151 2
	wfile_eof,
	wfile_hup,
d159 2
a160 6
#ifdef DEBUG
/*
 * print the given wav structure
 */
void
wav_dbg(struct wav *f)
d162 1
a162 1
	static char *pstates[] = { "ini", "sta", "rdy", "run", "fai" };
d164 4
a167 8
	dbg_puts("wav(");
	if (f->slot >= 0 && APROC_OK(dev_midi)) {
		dbg_puts(dev_midi->u.ctl.slot[f->slot].name);
		dbg_putu(dev_midi->u.ctl.slot[f->slot].unit);
	} else
		dbg_puts(f->pipe.file.name);
	dbg_puts(")/");
	dbg_puts(pstates[f->pstate]);
a168 1
#endif
d170 2
a171 5
/*
 * convert ``count'' samples using the given char->short map
 */
void
wav_conv(unsigned char *data, unsigned count, short *map)
d173 15
a187 11
	unsigned i;
	unsigned char *iptr;
	short *optr;

	iptr = data + count;
	optr = (short *)data + count;
	for (i = count; i > 0; i--) {
		--optr;
		--iptr;
		*optr = map[*iptr];
	}
d190 2
a191 5
/*
 * read method of the file structure
 */
unsigned
wav_read(struct file *file, unsigned char *data, unsigned count)
d193 3
a195 2
	struct wav *f = (struct wav *)file;
	unsigned n;
d197 7
a203 18
	if (f->map)
		count /= sizeof(short);
	if (f->rbytes >= 0 && count > f->rbytes) {
		count = f->rbytes; /* file->rbytes fits in count */
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 3) {
				wav_dbg(f);
				dbg_puts(": read complete\n");
			}
#endif
			if (!f->tr)
				file_eof(&f->pipe.file);
			return 0;
		}
	}
	n = pipe_read(file, data, count);
	if (n == 0)
d205 2
a206 7
	if (f->rbytes >= 0)
		f->rbytes -= n;
	if (f->map) {
		wav_conv(data, n, f->map);
		n *= sizeof(short);
	}
	return n;
d209 2
a210 5
/*
 * write method of the file structure
 */
unsigned
wav_write(struct file *file, unsigned char *data, unsigned count)
d212 2
a213 2
	struct wav *f = (struct wav *)file;
	unsigned n;
d215 15
a229 18
	if (f->wbytes >= 0 && count > f->wbytes) {
		count = f->wbytes; /* wbytes fits in count */
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 3) {
				wav_dbg(f);
				dbg_puts(": write complete\n");
			}
#endif
			file_hup(&f->pipe.file);
			return 0;
		}
	}
	n = pipe_write(file, data, count);
	if (f->wbytes >= 0)
		f->wbytes -= n;
	f->endpos += n;
	return n;
a231 3
/*
 * close method of the file structure
 */
d233 1
a233 22
wav_close(struct file *file)
{
	struct wav *f = (struct wav *)file;

	if (f->mode & MODE_RECMASK) {
		pipe_trunc(&f->pipe.file, f->endpos);
		if (f->hdr == HDR_WAV) {
			wav_writehdr(f->pipe.fd,
			    &f->hpar,
			    &f->startpos,
			    f->endpos - f->startpos);
		}
	}
	pipe_close(file);
}

/*
 * attach play (rec) abuf structure to the device and
 * switch to the ``RUN'' state; the play abug must not be empty
 */
int
wav_attach(struct wav *f, int force)
d235 1
a235 18
	struct abuf *rbuf = NULL, *wbuf = NULL;

	if (f->mode & MODE_PLAY)
		rbuf = LIST_FIRST(&f->pipe.file.rproc->obuflist);
	if (f->mode & MODE_RECMASK)
		wbuf = LIST_FIRST(&f->pipe.file.wproc->ibuflist);
	f->pstate = WAV_RUN;
#ifdef DEBUG
	if (debug_level >= 3) {
		wav_dbg(f);
		dbg_puts(": attaching\n");
	}
#endif
	dev_attach(f->pipe.file.name, f->mode,
	    rbuf, &f->hpar, wbuf, &f->hpar, f->xrun, f->maxweight);
	if (f->mode & MODE_PLAY)
		dev_setvol(rbuf, MIDI_TO_ADATA(f->vol));
	return 1;
a237 8
/*
 * allocate the play (rec) abuf structure; if this is a
 * file to record, then attach it to the device
 *
 * XXX: buffer size should be larger than dev_bufsz, because
 *	in non-server mode we don't prime play buffers with
 *	silence
 */
d239 1
a239 1
wav_allocbuf(struct wav *f)
d241 1
a241 26
	struct abuf *buf;
	unsigned nfr;

	f->pstate = WAV_START;
	if (f->mode & MODE_PLAY) {
		nfr = 2 * dev_bufsz * f->hpar.rate / dev_rate;
		buf = abuf_new(nfr, &f->hpar);
		aproc_setout(f->pipe.file.rproc, buf);
		abuf_fill(buf);
		if (!ABUF_WOK(buf) || (f->pipe.file.state & FILE_EOF))
			f->pstate = WAV_READY;
	}
	if (f->mode & MODE_RECMASK) {
		nfr = 2 * dev_bufsz * f->hpar.rate / dev_rate;
		buf = abuf_new(nfr, &f->hpar);
		aproc_setin(f->pipe.file.wproc, buf);
		f->pstate = WAV_READY;
	}
#ifdef DEBUG
	if (debug_level >= 3) {
		wav_dbg(f);
		dbg_puts(": allocating buffers\n");
	}
#endif
	if (f->pstate == WAV_READY && ctl_slotstart(dev_midi, f->slot))
		(void)wav_attach(f, 0);
d244 2
a245 5
/*
 * free abuf structure and switch to the ``INIT'' state
 */
void
wav_freebuf(struct wav *f)
d247 1
a247 1
	struct abuf *rbuf = NULL, *wbuf = NULL;
d249 4
a252 17
	if (f->mode & MODE_PLAY)
		rbuf = LIST_FIRST(&f->pipe.file.rproc->obuflist);
	if (f->mode & MODE_RECMASK)
		wbuf = LIST_FIRST(&f->pipe.file.wproc->ibuflist);
	f->pstate = WAV_INIT;
#ifdef DEBUG
	if (debug_level >= 3) {
		wav_dbg(f);
		dbg_puts(": freeing buffers\n");
	}
#endif
	if (rbuf || wbuf)
		ctl_slotstop(dev_midi, f->slot);
	if (rbuf)
		abuf_eof(rbuf);
	if (wbuf)
		abuf_hup(wbuf);
a254 4
/*
 * switch to the ``INIT'' state performing
 * necessary actions to reach it
 */
d256 1
a256 1
wav_reset(struct wav *f)
d258 2
a259 16
	switch (f->pstate) {
	case WAV_START:
	case WAV_READY:
		if (ctl_slotstart(dev_midi, f->slot))
			(void)wav_attach(f, 1);
		/* PASSTHROUGH */
	case WAV_RUN:
		wav_freebuf(f);
		f->pstate = WAV_INIT;
		/* PASSTHROUGH */
	case WAV_INIT:
	case WAV_FAILED:
		/* nothing yet */
		break;
	}
}
d261 2
a262 20
/*
 * terminate the wav reader/writer
 */
void
wav_exit(struct wav *f)
{
	if (f->mode & MODE_PLAY) {
		aproc_del(f->pipe.file.rproc);
	} else if (f->mode & MODE_RECMASK) {
		aproc_del(f->pipe.file.wproc);
	}
}

/*
 * seek to f->mmcpos and prepare to start, close
 * the file on error.
 */
int
wav_seekmmc(struct wav *f)
{
d264 2
a265 2
	 * don't go beyond the end-of-file, if so
	 * put it in INIT state so it dosn't start
d267 9
a275 20
	if (f->mmcpos > f->endpos) {
		wav_reset(f);
		f->pstate = WAV_FAILED;
		/*
		 * don't make other stream wait for us
		 */
		if (f->slot >= 0)
			ctl_slotstart(dev_midi, f->slot);
		return 0;
	}
	if (!pipe_seek(&f->pipe.file, f->mmcpos)) {
		wav_exit(f);
		return 0;
	}
	if (f->hdr == HDR_WAV)
		f->wbytes = WAV_DATAMAX - f->mmcpos;
	f->rbytes = f->endpos - f->mmcpos;
	wav_reset(f);
	wav_allocbuf(f);
	return 1;
a277 3
/*
 * read samples from the file and possibly start it
 */
d279 1
a279 1
wav_rdata(struct wav *f)
d281 3
a283 2
	struct aproc *p;
	struct abuf *obuf;
d285 1
a285 3
	p = f->pipe.file.rproc;
	obuf = LIST_FIRST(&p->obuflist);
	if (obuf == NULL)
d287 1
a287 1
	if (!ABUF_WOK(obuf) || !(f->pipe.file.state & FILE_ROK))
d289 3
a291 1
	if (!rfile_do(p, obuf->len, NULL))
d293 1
a293 28
	switch (f->pstate) {
	case WAV_START:
		if (!ABUF_WOK(obuf) || (f->pipe.file.state & FILE_EOF))
			f->pstate = WAV_READY;
		/* PASSTHROUGH */
	case WAV_READY:
		if (ctl_slotstart(dev_midi, f->slot))
			(void)wav_attach(f, 0);
		break;
#ifdef DEBUG
	case WAV_RUN:
		break;
	default:
		wav_dbg(f);
		dbg_puts(": bad state\n");
		dbg_panic();
#endif
	}
	if (f->rbytes == 0 && f->tr) {
#ifdef DEBUG
		if (debug_level >= 3) {
			wav_dbg(f);
			dbg_puts(": trying to restart\n");
		}
#endif
		if (!wav_seekmmc(f))
			return 0;
	}
d298 1
a298 1
wav_wdata(struct wav *f)
d300 4
a303 2
	struct aproc *p;
	struct abuf *ibuf;
d305 1
a305 1
	if (!(f->pipe.file.state & FILE_WOK))
d307 1
a307 3
	p = f->pipe.file.wproc;
	ibuf = LIST_FIRST(&p->ibuflist);
	if (ibuf == NULL)
d309 3
a311 1
	if (!ABUF_ROK(ibuf))
d313 3
a315 1
	if (!wfile_do(p, ibuf->len, NULL))
d317 1
a320 51
/*
 * callback to set the volume, invoked by the MIDI control code
 */
void
wav_setvol(void *arg, unsigned vol)
{
	struct wav *f = (struct wav *)arg;
	struct abuf *rbuf;

	f->vol = vol;
	if ((f->mode & MODE_PLAY) && f->pstate == WAV_RUN) {
		rbuf = LIST_FIRST(&f->pipe.file.rproc->obuflist);
		dev_setvol(rbuf, MIDI_TO_ADATA(vol));
	}
}

/*
 * callback to start the stream, invoked by the MIDI control code
 */
void
wav_startreq(void *arg)
{
	struct wav *f = (struct wav *)arg;

	switch (f->pstate) {
	case WAV_FAILED:
#ifdef DEBUG
		if (debug_level >= 2) {
			wav_dbg(f);
			dbg_puts(": skipped (failed to seek)\n");
		}
#endif
		return;
	case WAV_READY:
		if (f->mode & MODE_RECMASK)
			f->endpos = f->startpos;
		(void)wav_attach(f, 0);
		break;
#ifdef DEBUG
	default:
		wav_dbg(f);
		dbg_puts(": not in READY state\n");
		dbg_panic();
		break;
#endif
	}
}

/*
 * callback to stop the stream, invoked by the MIDI control code
 */
d322 1
a322 1
wav_stopreq(void *arg)
d324 1
a324 19
	struct wav *f = (struct wav *)arg;

#ifdef DEBUG
	if (debug_level >= 2) {
		wav_dbg(f);
		dbg_puts(": stopping");
		if (f->pstate != WAV_FAILED && (f->mode & MODE_RECMASK)) {
			dbg_puts(", ");
			dbg_putu(f->endpos);
			dbg_puts(" bytes recorded");
		}
		dbg_puts("\n");
	}
#endif
	if (!f->tr) {
		wav_exit(f);
		return;
	}
	(void)wav_seekmmc(f);
a326 4
/*
 * callback to relocate the stream, invoked by the MIDI control code
 * on a stopped stream
 */
d328 1
a328 1
wav_locreq(void *arg, unsigned mmc)
d330 1
a330 12
	struct wav *f = (struct wav *)arg;

#ifdef DEBUG
	if (f->pstate == WAV_RUN) {
		wav_dbg(f);
		dbg_puts(": in RUN state\n");
		dbg_panic();
	}
#endif
	f->mmcpos = f->startpos + 
	    ((off_t)mmc * f->hpar.rate / MTC_SEC) * aparams_bpf(&f->hpar);
	(void)wav_seekmmc(f);
a332 3
/*
 * create a file reader in the ``INIT'' state
 */
d334 2
a335 2
wav_new_in(struct fileops *ops, unsigned mode, char *name, unsigned hdr, 
    struct aparams *par, unsigned xrun, unsigned volctl, int tr)
d339 3
d359 1
a359 1
		if (!wav_readhdr(f->pipe.fd, par, &f->startpos, &f->rbytes, &f->map)) {
d363 1
a363 1
		f->endpos = f->startpos + f->rbytes;
d365 1
a365 10
		f->startpos = 0;
		f->endpos = pipe_endpos(&f->pipe.file);
		if (f->endpos > 0) {
			if (!pipe_seek(&f->pipe.file, 0)) {
				file_del((struct file *)f);
				return NULL;
			}
			f->rbytes = f->endpos;
		} else
			f->rbytes = -1;
a367 3
	f->tr = tr;
	f->mode = mode;
	f->hpar = *par;
d369 7
a375 5
	f->xrun = xrun;
	f->maxweight = MIDI_TO_ADATA(volctl);
	f->slot = ctl_slotnew(dev_midi, "play", &ctl_wavops, f, 1);
	rwav_new((struct file *)f);
	wav_allocbuf(f);
a379 4
		dbg_putu(f->startpos);
		dbg_puts("..");
		dbg_putu(f->endpos);
		dbg_puts(": playing ");
a380 2
		if (f->tr)
			dbg_puts(", mmc");
a386 3
/*
 * create a file writer in the ``INIT'' state
 */
d388 2
a389 2
wav_new_out(struct fileops *ops, unsigned mode, char *name, unsigned hdr,
    struct aparams *par, unsigned xrun, int tr)
d393 3
d417 1
a417 1
		if (!wav_writehdr(f->pipe.fd, par, &f->startpos, 0)) {
d421 1
d423 1
a423 2
		f->endpos = f->startpos;
	} else {
a424 5
		f->startpos = f->endpos = 0;
	}
	f->tr = tr;
	f->mode = mode;
	f->hpar = *par;
d426 5
a430 4
	f->xrun = xrun;
	f->slot = ctl_slotnew(dev_midi, "rec", &ctl_wavops, f, 1);
	wwav_new((struct file *)f);
	wav_allocbuf(f);
d443 1
a443 1
rwav_done(struct aproc *p)
d445 3
a447 1
	struct wav *f = (struct wav *)p->u.io.file;
d449 6
a454 18
	if (f->slot >= 0)
		ctl_slotdel(dev_midi, f->slot);
	f->slot = -1;
	rfile_done(p);
}

int
rwav_in(struct aproc *p, struct abuf *ibuf_dummy)
{
	struct wav *f = (struct wav *)p->u.io.file;
	struct abuf *obuf;

	if (!wav_rdata(f))
		return 0;
	obuf = LIST_FIRST(&p->obuflist);
	if (obuf && f->pstate >= WAV_RUN) {
		if (!abuf_flush(obuf))
			return 0;
a455 1
	return 1;
d458 2
a459 2
int
rwav_out(struct aproc *p, struct abuf *obuf)
d461 2
a462 1
	struct wav *f = (struct wav *)p->u.io.file;
d464 12
a475 4
	if (f->pipe.file.state & FILE_RINUSE)
		return 0;
	for (;;) {
		if (!wav_rdata(f))
d477 1
d479 2
a480 32
	return 1;
}

struct aproc *
rwav_new(struct file *f)
{
	struct aproc *p;

	p = aproc_new(&rwav_ops, f->name);
	p->u.io.file = f;
	p->u.io.partial = 0;;
	f->rproc = p;
	return p;
}

void
wwav_done(struct aproc *p)
{
	struct wav *f = (struct wav *)p->u.io.file;

	if (f->slot >= 0)
		ctl_slotdel(dev_midi, f->slot);
	f->slot = -1;
	wfile_done(p);
}

int
wwav_in(struct aproc *p, struct abuf *ibuf)
{
	struct wav *f = (struct wav *)p->u.io.file;

	if (f->pipe.file.state & FILE_WINUSE)
d482 5
a486 3
	for (;;) {
		if (!wav_wdata(f))
			return 0;
d488 1
a488 1
	return 1;
d491 2
a492 2
int
wwav_out(struct aproc *p, struct abuf *obuf_dummy)
d494 2
a495 2
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
	struct wav *f = (struct wav *)p->u.io.file;
d497 10
a506 2
	if (ibuf && f->pstate == WAV_RUN) {
		if (!abuf_fill(ibuf))
d508 1
d510 4
a513 3
	if (!wav_wdata(f))
		return 0;
	return 1;
d516 2
a517 2
struct aproc *
wwav_new(struct file *f)
d519 1
a519 1
	struct aproc *p;
d521 3
a523 5
	p = aproc_new(&wwav_ops, f->name);
	p->u.io.file = f;
	p->u.io.partial = 0;;
	f->wproc = p;
	return p;
@


1.12
log
@Use -C option to specify recorded channel range instead of -c which
is for played channels.

spotted by Jan Stary <hans at stare.cz>, thanks
@
text
@d26 1
d28 1
d128 1
d135 13
d153 2
a154 2
	rwav_eof,
	rwav_hup,
d166 2
a167 2
	wwav_eof,
	wwav_hup,
d175 25
a199 2
struct aproc *
rwav_new(struct file *f)
d201 3
a203 1
	struct aproc *p;
d205 7
a211 4
	p = aproc_new(&rwav_ops, f->name);
	p->u.io.file = f;
	f->rproc = p;
	return p;
d214 5
a218 2
int
rwav_in(struct aproc *p, struct abuf *ibuf_dummy)
d220 21
a240 10
	struct abuf *obuf = LIST_FIRST(&p->obuflist);
	struct file *f = p->u.io.file;
	unsigned char *data;
	unsigned count;

	if (ABUF_FULL(obuf) || !(f->state & FILE_ROK))
		return 0;
	data = abuf_wgetblk(obuf, &count, 0);
	count = file_read(f, data, count);
	if (count == 0)
d242 56
a297 4
	abuf_wcommit(obuf, count);
	if (!abuf_flush(obuf))
		return 0;
	return 1;
d300 4
d305 1
a305 1
rwav_out(struct aproc *p, struct abuf *obuf)
d307 1
a307 3
	struct file *f = p->u.io.file;
	unsigned char *data;
	unsigned count;
d309 15
a323 9
	if (f->state & FILE_RINUSE)
		return 0;
	if (ABUF_FULL(obuf) || !(f->state & FILE_ROK))
		return 0;
	data = abuf_wgetblk(obuf, &count, 0);
	count = file_read(f, data, count);
	if (count == 0)
		return 0;
	abuf_wcommit(obuf, count);
d327 8
d336 1
a336 1
rwav_done(struct aproc *p)
d338 2
a339 2
	struct file *f = p->u.io.file;
	struct abuf *obuf;
d341 23
a363 15
	if (f == NULL)
		return;
	/*
	 * all buffers must be detached before deleting f->wproc,
	 * because otherwise it could trigger this code again
	 */
	obuf = LIST_FIRST(&p->obuflist);
	if (obuf)
		abuf_eof(obuf);
	if (f->wproc) {
		f->rproc = NULL;
		aproc_del(f->wproc);
	} else
		file_del(f);
	p->u.io.file = NULL;
d366 3
d370 1
a370 1
rwav_eof(struct aproc *p, struct abuf *ibuf_dummy)
d372 19
a390 1
	aproc_del(p);
d393 4
d398 1
a398 1
rwav_hup(struct aproc *p, struct abuf *obuf)
d400 15
a414 1
	aproc_del(p);
d417 5
a421 2
struct aproc *
wwav_new(struct file *f)
d423 5
a427 6
	struct aproc *p;

	p = aproc_new(&wwav_ops, f->name);
	p->u.io.file = f;
	f->wproc = p;
	return p;
d430 6
a435 2
void
wwav_done(struct aproc *p)
a436 5
	struct file *f = p->u.io.file;
	struct abuf *ibuf;

	if (f == NULL)
		return;
d438 2
a439 2
	 * all buffers must be detached before deleting f->rproc,
	 * because otherwise it could trigger this code again
d441 20
a460 9
	ibuf = LIST_FIRST(&p->ibuflist);
	if (ibuf)
		abuf_hup(ibuf);
	if (f->rproc) {
		f->wproc = NULL;
		aproc_del(f->rproc);
	} else
		file_del(f);
	p->u.io.file = NULL;
d463 3
d467 1
a467 1
wwav_in(struct aproc *p, struct abuf *ibuf)
d469 2
a470 3
	struct file *f = p->u.io.file;
	unsigned char *data;
	unsigned count;
d472 3
a474 1
	if (f->state & FILE_WINUSE)
d476 1
a476 1
	if (ABUF_EMPTY(ibuf) || !(f->state & FILE_WOK))
d478 1
a478 3
	data = abuf_rgetblk(ibuf, &count, 0);
	count = file_write(f, data, count);
	if (count == 0)
d480 28
a507 1
	abuf_rdiscard(ibuf, count);
d512 1
a512 1
wwav_out(struct aproc *p, struct abuf *obuf_dummy)
d514 2
a515 4
	struct abuf *ibuf = LIST_FIRST(&p->ibuflist);
	struct file *f = p->u.io.file;
	unsigned char *data;
	unsigned count;
d517 1
a517 1
	if (!abuf_fill(ibuf))
d519 3
a521 1
	if (ABUF_EMPTY(ibuf) || !(f->state & FILE_WOK))
d523 1
a523 3
	data = abuf_rgetblk(ibuf, &count, 0);
	if (count == 0) {
		/* XXX: this can't happen, right ? */
d525 1
a525 3
	}
	count = file_write(f, data, count);
	if (count == 0)
a526 1
	abuf_rdiscard(ibuf, count);
d530 51
d582 1
a582 1
wwav_eof(struct aproc *p, struct abuf *ibuf)
d584 19
a602 1
	aproc_del(p);
d605 4
d610 1
a610 1
wwav_hup(struct aproc *p, struct abuf *obuf_dummy)
d612 12
a623 1
	aproc_del(p);
d626 3
d630 2
a631 2
wav_new_in(struct fileops *ops, char *name, unsigned hdr, 
    struct aparams *par, unsigned xrun, unsigned volctl)
a634 3
	struct aproc *p;
	struct abuf *buf;
	unsigned nfr;
d652 1
a652 1
		if (!wav_readhdr(f->pipe.fd, par, &f->rbytes, &f->map)) {
d656 1
a656 1
		f->hpar = *par;
d658 10
a667 1
		f->rbytes = -1;
d670 3
d674 5
a678 7
	nfr = dev_bufsz * par->rate / dev_rate;
	buf = abuf_new(nfr, par);
	p = rwav_new((struct file *)f);
	aproc_setout(p, buf);
	abuf_fill(buf); /* XXX: move this in dev_attach() ? */
	dev_attach(name, buf, par, xrun, NULL, NULL, 0, ADATA_UNIT);
	dev_setvol(buf, MIDI_TO_ADATA(volctl));
d683 4
d688 2
d696 3
d700 2
a701 2
wav_new_out(struct fileops *ops, char *name, unsigned hdr,
    struct aparams *par, unsigned xrun)
a704 3
	struct aproc *p;
	struct abuf *buf;
	unsigned nfr;
d726 1
a726 1
		if (!wav_writehdr(f->pipe.fd, par)) {
a729 1
		f->hpar = *par;
d731 2
a732 1
	} else
d734 5
d740 4
a743 5
	nfr = dev_bufsz * par->rate / dev_rate;
	p = wwav_new((struct file *)f);
	buf = abuf_new(nfr, par);
	aproc_setin(p, buf);
	dev_attach(name, NULL, NULL, 0, buf, par, xrun, 0);
d756 12
a767 1
wav_conv(unsigned char *data, unsigned count, short *map)
d769 2
a770 3
	unsigned i;
	unsigned char *iptr;
	short *optr;
d772 6
a777 6
	iptr = data + count;
	optr = (short *)data + count;
	for (i = count; i > 0; i--) {
		--optr;
		--iptr;
		*optr = map[*iptr];
d779 1
d782 2
a783 2
unsigned
wav_read(struct file *file, unsigned char *data, unsigned count)
d785 1
a785 2
	struct wav *f = (struct wav *)file;
	unsigned n;
d787 4
a790 12
	if (f->map)
		count /= sizeof(short);
	if (f->rbytes >= 0 && count > f->rbytes) {
		count = f->rbytes; /* file->rbytes fits in count */
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 3) {
				file_dbg(&f->pipe.file);
				dbg_puts(": read complete\n");
			}
#endif
			file_eof(&f->pipe.file);
a791 1
		}
d793 32
a824 2
	n = pipe_read(file, data, count);
	if (n == 0)
d826 3
a828 5
	if (f->rbytes >= 0)
		f->rbytes -= n;
	if (f->map) {
		wav_conv(data, n, f->map);
		n *= sizeof(short);
d830 1
a830 1
	return n;
d833 2
a834 2
unsigned
wav_write(struct file *file, unsigned char *data, unsigned count)
d836 2
a837 2
	struct wav *f = (struct wav *)file;
	unsigned n;
d839 2
a840 10
	if (f->wbytes >= 0 && count > f->wbytes) {
		count = f->wbytes; /* wbytes fits in count */
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 3) {
				file_dbg(&f->pipe.file);
				dbg_puts(": write complete\n");
			}
#endif
			file_hup(&f->pipe.file);
a841 1
		}
d843 3
a845 4
	n = pipe_write(file, data, count);
	if (f->wbytes >= 0)
		f->wbytes -= n;
	return n;
d848 2
a849 2
void
wav_close(struct file *file)
d851 1
a851 1
	struct wav *f = (struct wav *)file;
d853 5
a857 3
	if (f->hdr == HDR_WAV)
		wav_writehdr(f->pipe.fd, &f->hpar);
	pipe_close(file);
@


1.11
log
@Add traces to help tracking subtle timing bugs often causing
underuns and overruns; such bugs are hard to debug with ktrace
or a debugger. They are also handy to debug or monitor code
using aucat.

To enable traces, compile aucat with ``make DEBUG=-DDEBUG'' and
use the -d option multiple times.

ok jakemsr
@
text
@d376 8
d431 8
@


1.10
log
@Make the way .wav files are handled closer to the way sockets are
handled, which is conceptually simpler. No behaviour changes.
@
text
@d27 3
d453 6
d484 6
@


1.9
log
@remove all debug traces
@
text
@d18 3
d22 2
d25 1
d118 212
d331 2
a332 2
wav_new_in(struct fileops *ops, int fd, char *name,
    struct aparams *par, unsigned hdr)
d334 1
d336 16
a351 1

d356 4
a359 2
		if (!wav_readhdr(f->pipe.fd, par, &f->rbytes, &f->map))
			exit(1);
d366 7
d377 2
a378 2
wav_new_out(struct fileops *ops, int fd, char *name,
    struct aparams *par, unsigned hdr)
d380 1
d382 17
a398 1

d406 4
a409 2
		if (!wav_writehdr(f->pipe.fd, par))
			exit(1);
d415 5
d494 1
@


1.8
log
@if pipe_read() returns 0 we are at EOF and the structure describing
the pipe will be free()d, so don't try to access the structure.

ok ratchov
@
text
@a16 5
#include <sys/types.h>

#include <err.h>
#include <fcntl.h>
#include <stdio.h>
a17 1
#include <unistd.h>
a182 1
			DPRINTFN(2, "wav_read: %s: complete\n", f->pipe.file.name);
a207 2
			DPRINTFN(2, "wav_write: %s: complete\n",
			    f->pipe.file.name);
@


1.7
log
@fix comments, remove no longer needed declaration, reorder includes
from Thomas Pfaff
@
text
@d195 2
@


1.6
log
@move support for ulaw/alaw encoding in .wav files from legacy mode
to normal mode.

ok jakemsr@@
@
text
@d1 16
d18 1
d99 1
a99 1
 * max data of a .wav file. The total file size must be smaller than
d101 1
a101 1
 * bytes)
@


1.5
log
@- make legacy mode use sio_open(3) (sndio) API
- parse .au headers in legacy mode
- support playback of ulaw and alaw encoded .au and .wav files in
legacy mode

ok ratchov
@
text
@d11 70
d111 1
a111 1
		if (!wav_readhdr(f->pipe.fd, par, &f->rbytes, NULL))
d114 1
a114 1
	} else
d116 2
d145 16
d167 2
d180 4
a185 1

@


1.4
log
@if there are too many connections, stop acceping new ones rather
than exit()ing with ``too many open files'' fatal error
@
text
@d41 1
a41 1
		if (!wav_readhdr(f->pipe.fd, par, &f->rbytes))
@


1.3
log
@spacing + typo fix from Matt Jibson <matt.jibson(at)gmail.com>
@
text
@d38 2
d57 2
@


1.2
log
@when recording .wav files overwrite user supplied parameters with
parameters .wav files format allows (u8, s16le, etc...); a converter
is automatically setup. Allows recording .wav files on BE machines
with default parameters.
idea and help from todd@@
@
text
@d15 1
a15 1
 */ 
d57 1
a57 1
		par->sig = (par->bits <= 8) ? 0 : 1; 
d95 1
a95 1
	
@


1.1
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d56 3
@

