head	1.46;
access;
symbols
	OPENBSD_5_6:1.45.0.6
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.44.0.6
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.4
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.2
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.2
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.37.0.2
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.46
date	2015.01.21.08.43.55;	author ratchov;	state dead;
branches;
next	1.45;
commitid	SYQcoS9jhSKqSJDL;

1.45
date	2013.11.18.17.37.45;	author ratchov;	state Exp;
branches;
next	1.44;

1.44
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.43;

1.43
date	2012.03.23.11.59.54;	author ratchov;	state Exp;
branches;
next	1.42;

1.42
date	2011.12.02.10.34.50;	author ratchov;	state Exp;
branches;
next	1.41;

1.41
date	2011.11.20.22.54.51;	author ratchov;	state Exp;
branches;
next	1.40;

1.40
date	2011.11.15.20.41.54;	author ratchov;	state Exp;
branches;
next	1.39;

1.39
date	2011.05.26.07.18.40;	author ratchov;	state Exp;
branches;
next	1.38;

1.38
date	2010.11.04.17.55.28;	author ratchov;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.04.06.15.28;	author ratchov;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.02.11.12.31;	author ratchov;	state Exp;
branches;
next	1.35;

1.35
date	2010.04.24.06.18.23;	author ratchov;	state Exp;
branches;
next	1.34;

1.34
date	2010.04.21.06.13.07;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2010.04.17.09.16.57;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.11.13.06.32;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.05.10.18.12;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.03.21.31.37;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.27.22.41.03;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.10.12.43.09;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.06.18.06.55;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.27.11.51.20;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.27.06.31.13;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.26.08.28.21;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.26.06.10.15;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.21.16.48.03;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.25.10.52.18;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.23.17.38.15;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.29.17.59.08;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.19.08.01.06;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.07.17.10.41;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.09.16.26.07;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.04.22.18.12;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.04.18.24.06;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.04.17.51.46;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.04.15.22.40;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.04.14.16.09;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.26.08.49.43;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.14.09.58.55;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2008.08.14.09.47.51;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.14.09.45.23;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.02.17.06.36;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.23.07.15.46;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Simplify internals and rewrite file header parsing code:
- remove -M, -t, -w, -C, -x flags that don't make sense anymore
- make "-j off" the default (sndiod already does the job)
- don't limit the number of played/recorded files.
- add support for floating-point encoded files.
- add support for apple .aiff and sun/next .au files
@
text
@/*	$OpenBSD: aproc.h,v 1.45 2013/11/18 17:37:45 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifndef APROC_H
#define APROC_H

#include <sys/queue.h>

#include "aparams.h"
#include "file.h"

struct abuf;
struct aproc;
struct file;

struct aproc_ops {
	/*
	 * Name of the ops structure, ie type of the unit.
	 */
	char *name;

	/*
	 * The state of the given input abuf changed (eg. an input block
	 * is ready for processing). This function must get the block
	 * from the input, process it and remove it from the buffer.
	 *
	 * Processing the block will result in a change of the state of
	 * OTHER buffers that are attached to the aproc (eg. the output
	 * buffer was filled), thus this routine MUST notify ALL aproc
	 * structures that are waiting on it; most of the time this
	 * means just calling abuf_flush() on the output buffer.
	 */
	int (*in)(struct aproc *, struct abuf *);

	/*
	 * The state of the given output abuf changed (eg. space for a
	 * new output block was made available) so processing can
	 * continue.  This function must process more input in order to
	 * fill the output block.
	 *
	 * Producing a block will result in the change of the state of
	 * OTHER buffers that are attached to the aproc, thus this
	 * routine MUST notify ALL aproc structures that are waiting on
	 * it; most of the time this means calling abuf_fill() on the
	 * source buffers.
	 *
	 * Before filling input buffers (using abuf_fill()), this
	 * routine must ALWAYS check for eof condition, and if needed,
	 * handle it appropriately and call abuf_hup() to free the input
	 * buffer.
	 */
	int (*out)(struct aproc *, struct abuf *);

	/*
	 * The input buffer is empty and we can no more receive data
	 * from it. The buffer will be destroyed as soon as this call
	 * returns so the abuf pointer will stop being valid after this
	 * call returns. There's no need to drain the buffer because the
	 * in() call-back was just called before.
	 *
	 * If this call reads and/or writes data on other buffers,
	 * abuf_flush() and abuf_fill() must be called appropriately.
	 */
	void (*eof)(struct aproc *, struct abuf *);

	/*
	 * The output buffer can no more accept data (it should be
	 * considered as full). After this function returns, it will be
	 * destroyed and the "abuf" pointer will be no more valid.
	 */
	void (*hup)(struct aproc *, struct abuf *);

	/*
	 * A new input was connected.
	 */
	void (*newin)(struct aproc *, struct abuf *);

	/*
	 * A new output was connected
	 */
	void (*newout)(struct aproc *, struct abuf *);

	/*
	 * Real-time record position changed (for input buffer),
	 * by the given amount of _frames_.
	 */
	void (*ipos)(struct aproc *, struct abuf *, int);

	/*
	 * Real-time play position changed (for output buffer),
	 * by the given amount of _frames_.
	 */
	void (*opos)(struct aproc *, struct abuf *, int);

	/*
	 * Destroy the aproc, called just before to free the
	 * aproc structure.
	 */
	void (*done)(struct aproc *);
};

/*
 * The aproc structure represents a simple audio processing unit; they are
 * interconnected by abuf structures and form a kind of "circuit". The circuit
 * cannot have loops.
 */
struct aproc {
	char *name;				/* for debug purposes */
	struct aproc_ops *ops;			/* call-backs */
	LIST_HEAD(, abuf) ins;			/* list of inputs */
	LIST_HEAD(, abuf) outs;			/* list of outputs */
	unsigned int refs;			/* extern references */
#define APROC_ZOMB	1			/* destroyed but not freed */
#define APROC_QUIT	2			/* try to terminate if unused */
#define APROC_DROP	4			/* xrun if capable */
	unsigned int flags;					
	union {					/* follow type-specific data */
		struct {			/* file/device io */
			struct file *file;	/* file to read/write */
			unsigned int partial;	/* bytes of partial frame */
		} io;
		struct {
			unsigned int idle;	/* frames since idleing */
			unsigned int round;	/* block size, for xruns */
			int lat;		/* current latency */
			int maxlat;		/* max latency allowed */
			unsigned int abspos;	/* frames produced */
			struct aproc *mon;	/* snoop output */
			unsigned int autovol;	/* adjust volume dynamically */
			int master;		/* master attenuation */
		} mix;
		struct {
			unsigned int idle;	/* frames since idleing */
			unsigned int round;	/* block size, for xruns */
			int lat;		/* current latency */
			int maxlat;		/* max latency allowed */
			unsigned int abspos;	/* frames consumed */
		} sub;
		struct {
			int delta;		/* time position */
			unsigned int bufsz;	/* buffer size (latency) */
			unsigned int pending;	/* uncommited samples */
		} mon;
		struct {
#define RESAMP_NCTX	2
			unsigned int ctx_start;
			adata_t ctx[NCHAN_MAX * RESAMP_NCTX];
			unsigned int iblksz, oblksz;
			int diff;
			int idelta, odelta;	/* remainder of resamp_xpos */
		} resamp;
		struct {
			int bfirst;		/* bytes to skip at startup */
			unsigned int bps;	/* bytes per sample */
			unsigned int shift;	/* shift to get 32bit MSB */
			int sigbit;		/* sign bits to XOR */
			int bnext;		/* to reach the next byte */
			int snext;		/* to reach the next sample */
		} conv;
		struct {
			struct dev *dev;	/* controlled device */
			struct timo timo;	/* timout for throtteling */
			unsigned int fps;	/* MTC frames per second */
#define MTC_FPS_24	0
#define MTC_FPS_25	1
#define MTC_FPS_30	3
			unsigned int fps_id;	/* one of above */
			unsigned int hr;	/* MTC hours */
			unsigned int min;	/* MTC minutes */
			unsigned int sec;	/* MTC seconds */
			unsigned int fr;	/* MTC frames */
			unsigned int qfr;	/* MTC quarter frames */
			int delta;		/* rel. to the last MTC tick */
		} midi;
	} u;
};

/*
 * Check if the given pointer is a valid aproc structure.
 *
 * aproc structures are not free()'d immediately, because
 * there may be pointers to them, instead the APROC_ZOMB flag
 * is set which means that they should not be used. When
 * aprocs reference counter reaches zero, they are actually
 * freed
 */
#define APROC_OK(p) ((p) && !((p)->flags & APROC_ZOMB))


struct aproc *aproc_new(struct aproc_ops *, char *);
void aproc_del(struct aproc *);
void aproc_dbg(struct aproc *);
void aproc_setin(struct aproc *, struct abuf *);
void aproc_setout(struct aproc *, struct abuf *);
int aproc_inuse(struct aproc *);
int aproc_depend(struct aproc *, struct aproc *);

void aproc_ipos(struct aproc *, struct abuf *, int);
void aproc_opos(struct aproc *, struct abuf *, int);

struct aproc *rfile_new(struct file *);
struct aproc *wfile_new(struct file *);
struct aproc *mix_new(char *, int, unsigned int, unsigned int, unsigned int);
struct aproc *sub_new(char *, int, unsigned int);
struct aproc *resamp_new(char *, unsigned int, unsigned int);
struct aproc *enc_new(char *, struct aparams *);
struct aproc *dec_new(char *, struct aparams *);
struct aproc *join_new(char *);
struct aproc *mon_new(char *, unsigned int);

int rfile_in(struct aproc *, struct abuf *);
int rfile_out(struct aproc *, struct abuf *);
void rfile_eof(struct aproc *, struct abuf *);
void rfile_hup(struct aproc *, struct abuf *);
void rfile_done(struct aproc *);
int rfile_do(struct aproc *, unsigned int, unsigned int *);

int wfile_in(struct aproc *, struct abuf *);
int wfile_out(struct aproc *, struct abuf *);
void wfile_eof(struct aproc *, struct abuf *);
void wfile_hup(struct aproc *, struct abuf *);
void wfile_done(struct aproc *);
int wfile_do(struct aproc *, unsigned int, unsigned int *);

void mix_setmaster(struct aproc *);
void mix_clear(struct aproc *);
void mix_prime(struct aproc *);
void mix_quit(struct aproc *);
void mix_drop(struct abuf *, int);
void sub_silence(struct abuf *, int);
void sub_clear(struct aproc *);
void mon_snoop(struct aproc *, struct abuf *, unsigned int, unsigned int);
void mon_clear(struct aproc *);

#endif /* !defined(APROC_H) */
@


1.45
log
@add missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.44
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.43 2012/03/23 11:59:54 ratchov Exp $	*/
d208 1
@


1.43
log
@add a MIDI-controlled master volume knob to adjust the mix of
all playback stream, discussed with armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.42 2011/12/02 10:34:50 ratchov Exp $	*/
d125 1
a125 1
	unsigned refs;				/* extern references */
d129 1
a129 1
	unsigned flags;					
d133 1
a133 1
			unsigned partial;	/* bytes of partial frame */
d136 2
a137 2
			unsigned idle;		/* frames since idleing */
			unsigned round;		/* block size, for xruns */
d140 1
a140 1
			unsigned abspos;	/* frames produced */
d142 1
a142 1
			unsigned autovol;	/* adjust volume dynamically */
d146 2
a147 2
			unsigned idle;		/* frames since idleing */
			unsigned round;		/* block size, for xruns */
d150 1
a150 1
			unsigned abspos;	/* frames consumed */
d154 2
a155 2
			unsigned bufsz;		/* buffer size (latency) */
			unsigned pending;	/* uncommited samples */
d159 1
a159 1
			unsigned ctx_start;
d161 1
a161 1
			unsigned iblksz, oblksz;
d167 2
a168 2
			unsigned bps;		/* bytes per sample */
			unsigned shift;		/* shift to get 32bit MSB */
d176 1
a176 1
			unsigned fps;		/* MTC frames per second */
d180 6
a185 6
			unsigned fps_id;	/* one of above */
			unsigned hr;		/* MTC hours */
			unsigned min;		/* MTC minutes */
			unsigned sec;		/* MTC seconds */
			unsigned fr;		/* MTC frames */
			unsigned qfr;		/* MTC quarter frames */
d215 3
a217 3
struct aproc *mix_new(char *, int, unsigned, unsigned, unsigned);
struct aproc *sub_new(char *, int, unsigned);
struct aproc *resamp_new(char *, unsigned, unsigned);
d221 1
a221 1
struct aproc *mon_new(char *, unsigned);
d228 1
a228 1
int rfile_do(struct aproc *, unsigned, unsigned *);
d235 1
a235 1
int wfile_do(struct aproc *, unsigned, unsigned *);
d244 1
a244 1
void mon_snoop(struct aproc *, struct abuf *, unsigned, unsigned);
@


1.42
log
@reuse midi-control code to implement midi thru boxes and remove
the old midithru implementation; less code, less bugs. As a side
effect, midi output doesn't implement running status "compression"
any more.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.41 2011/11/20 22:54:51 ratchov Exp $	*/
d143 1
d215 1
a215 1
struct aproc *mix_new(char *, int, unsigned, unsigned);
@


1.41
log
@Move mmc/mtc and volume control bits from struct aproc to struct
dev. Allows volume settings to be saved while the device is kept
closed. Besides that, no behabiour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.40 2011/11/15 20:41:54 ratchov Exp $	*/
d173 1
a174 3
		} thru;
		struct {
			struct dev *dev;	/* controlled device */
d186 1
a186 1
		} ctl;
@


1.40
log
@make midi 'owner' pointer per-output
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.39 2011/05/26 07:18:40 ratchov Exp $	*/
a140 1
			struct aproc *ctl;	/* MIDI control/sync */
a149 1
			struct aproc *ctl;
a176 9
#define CTL_NSLOT	8
#define CTL_NAMEMAX	8
			unsigned serial;
#define CTL_OFF		0			/* ignore MMC messages */
#define CTL_STOP	1			/* stopped, can't start */
#define CTL_START	2			/* attempting to start */
#define CTL_RUN		3			/* started */
			unsigned tstate;
			unsigned origin;	/* MTC start time */
a187 15
			struct ctl_slot {
				struct ctl_ops {
					void (*vol)(void *, unsigned);
					void (*start)(void *);
					void (*stop)(void *);
					void (*loc)(void *, unsigned);
					void (*quit)(void *);
				} *ops;
				void *arg;
				unsigned unit;
				char name[CTL_NAMEMAX];
				unsigned serial;
				unsigned vol;
				unsigned tstate;
			} slot[CTL_NSLOT];
@


1.39
log
@add a new -w flag to control whether master volume is automatically
adjusted when new streams are connected and disconnected. Disabling
automatic volume adjustment makes sense if all streams are recorded
with properly lowered volumes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.38 2010/11/04 17:55:28 ratchov Exp $	*/
a174 1
			struct abuf *owner;	/* current input stream */
@


1.38
log
@Replace ``short'' by a new ``adata_t'' typedef corresponding to
audio samples and cleanup ADATA_XXX macros. This allows easilly
switching to 24 bit fixed point arithmetic by simply redefining
the adata_t typedef to int and updating ADATA_XXX macros. No
object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.37 2010/06/04 06:15:28 ratchov Exp $	*/
d143 1
d243 1
a243 1
struct aproc *mix_new(char *, int, unsigned);
@


1.37
log
@Allow the audio device to be opened only while it's actually used.
This is necessary for uaudio devices, for instance to start aucat
before the device is plugged. Or to unplug a device whithout
having to restart aucat when another device is plugged.  This is
controlled with the new -a option.

Allow multiple audio devices to be used concurently, i.e.
multiple ``-f devname'' options to be used; -f options must follow
per-device options, which is what we do for other options.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.36 2010/05/02 11:12:31 ratchov Exp $	*/
d160 1
a160 1
			short ctx[NCHAN_MAX * RESAMP_NCTX];
@


1.36
log
@Don't systematically fill with silence the mixer output. This
might result in extra samples being written to the device
when the mixer is closed.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.35 2010/04/24 06:18:23 ratchov Exp $	*/
d178 1
d205 1
@


1.35
log
@rename ibuflist/obuflist -> ins/outs to cut long lines
from Thomas Pfaff, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.34 2010/04/21 06:13:07 ratchov Exp $	*/
d240 2
a241 2
struct aproc *mix_new(char *, int, unsigned, struct aproc *);
struct aproc *sub_new(char *, int, unsigned, struct aproc *);
d265 1
@


1.34
log
@adds the necessary bits to join channels (ex stereo->mono) or
expand channels (ex mono->stereo).  It's switched on/off with
the ``-j'' option, (default is "on").
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.33 2010/04/17 09:16:57 ratchov Exp $	*/
d123 2
a124 2
	LIST_HEAD(, abuf) ibuflist;		/* list of inputs */
	LIST_HEAD(, abuf) obuflist;		/* list of outputs */
@


1.33
log
@Allow the mixer to handle inputs with channel ranges outside
the device channel range. This makes the channel mapping code
no longer usefuli, so remove it. No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.32 2010/04/06 20:07:01 ratchov Exp $	*/
d245 1
@


1.32
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.31 2010/04/03 17:59:17 ratchov Exp $	*/
a165 3
			short ctx[NCHAN_MAX];
		} cmap;
		struct {
a242 1
struct aproc *cmap_new(char *, struct aparams *, struct aparams *);
@


1.31
log
@backout last change, committed by mistake, sorry...
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.29 2010/01/11 13:06:32 ratchov Exp $	*/
d133 1
d137 1
d140 3
a142 1
			struct aproc *ctl;
d146 1
d149 1
d153 5
d163 1
a163 1
			int idelta, odelta;	/* remainder of resamp_[io]pos */
d205 2
d219 12
d238 3
d243 2
a244 2
struct aproc *mix_new(char *, int, struct aproc *);
struct aproc *sub_new(char *, int, struct aproc *);
d249 15
d268 2
d271 2
@


1.30
log
@doc fixes from jmc
@
text
@a132 1
			unsigned partial;	/* bytes of partial frame */
a135 1
			unsigned round;		/* block size, for xruns */
d138 1
a138 3
			unsigned abspos;	/* frames produced */
			struct aproc *ctl;	/* MIDI control/sync */
			struct aproc *mon;	/* snoop output */
a141 1
			unsigned round;		/* block size, for xruns */
a143 1
			unsigned abspos;	/* frames consumed */
a146 5
			int delta;		/* time position */
			unsigned bufsz;		/* buffer size (latency) */
			unsigned pending;	/* uncommited samples */
		} mon;
		struct {
d152 1
a152 1
			int idelta, odelta;	/* remainder of resamp_xpos */
a193 2
					void (*stop)(void *);
					void (*loc)(void *, unsigned);
a205 12
/*
 * Check if the given pointer is a valid aproc structure.
 *
 * aproc structures are not free()'d immediately, because
 * there may be pointers to them, instead the APROC_ZOMB flag
 * is set which means that they should not be used. When
 * aprocs reference counter reaches zero, they are actually
 * freed
 */
#define APROC_OK(p) ((p) && !((p)->flags & APROC_ZOMB))


a212 3
void aproc_ipos(struct aproc *, struct abuf *, int);
void aproc_opos(struct aproc *, struct abuf *, int);

d215 2
a216 2
struct aproc *mix_new(char *, int, unsigned, struct aproc *);
struct aproc *sub_new(char *, int, unsigned, struct aproc *);
a220 15
struct aproc *mon_new(char *, unsigned);

int rfile_in(struct aproc *, struct abuf *);
int rfile_out(struct aproc *, struct abuf *);
void rfile_eof(struct aproc *, struct abuf *);
void rfile_hup(struct aproc *, struct abuf *);
void rfile_done(struct aproc *);
int rfile_do(struct aproc *, unsigned, unsigned *);

int wfile_in(struct aproc *, struct abuf *);
int wfile_out(struct aproc *, struct abuf *);
void wfile_eof(struct aproc *, struct abuf *);
void wfile_hup(struct aproc *, struct abuf *);
void wfile_done(struct aproc *);
int wfile_do(struct aproc *, unsigned, unsigned *);
a224 2
void mix_drop(struct abuf *, int);
void sub_silence(struct abuf *, int);
a225 2
void mon_snoop(struct aproc *, struct abuf *, unsigned, unsigned);
void mon_clear(struct aproc *);
@


1.29
log
@When resuming from suspend, prime play buffers with silence,
otherwise the client would underrun by more than its own buffer
size, which currently is not allowed (causes the client to
deadlock).

Set the minimum client buffer size to two blocks. Single block
buffers don't work properly yet.

with help from jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.28 2010/01/05 10:18:12 ratchov Exp $	*/
d133 1
d137 1
d140 3
a142 1
			struct aproc *ctl;
d146 1
d149 1
d153 5
d163 1
a163 1
			int idelta, odelta;	/* remainder of resamp_[io]pos */
d205 2
d219 12
d238 3
d243 2
a244 2
struct aproc *mix_new(char *, int, struct aproc *);
struct aproc *sub_new(char *, int, struct aproc *);
d249 15
d268 2
d271 2
@


1.28
log
@Make the way .wav files are handled closer to the way sockets are
handled, which is conceptually simpler. No behaviour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.27 2009/11/03 21:31:37 ratchov Exp $	*/
a221 1
void mix_pushzero(struct aproc *);
d224 1
@


1.27
log
@Allow any program using aucat to act as MMC slave and MTC master
transparently.  Multiple audio applications can be started
synchronously from external software/hardware supporting the
standard Start/Stop/Relocate messages. The server clock is exposed
through MTC, allowing non-audio software/hardware to be
synchronized to audio applications.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.26 2009/10/27 22:41:03 ratchov Exp $	*/
d213 2
a214 14
struct aproc *rpipe_new(struct file *);
int rpipe_in(struct aproc *, struct abuf *);
int rpipe_out(struct aproc *, struct abuf *);
void rpipe_done(struct aproc *);
void rpipe_eof(struct aproc *, struct abuf *);
void rpipe_hup(struct aproc *, struct abuf *);

struct aproc *wpipe_new(struct file *);
void wpipe_done(struct aproc *);
int wpipe_in(struct aproc *, struct abuf *);
int wpipe_out(struct aproc *, struct abuf *);
void wpipe_eof(struct aproc *, struct abuf *);
void wpipe_hup(struct aproc *, struct abuf *);

@


1.26
log
@slightly cleanup the socket and control bits:
- reject bogus clients ignoring flow control during the start phase
- don't check if dev_midi is NULL, it can't be NULL anymore
- use ``struct ctl_ops'' instead of a simple call-backs
- don't try to flush play buffer if it's not attached yet
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.25 2009/10/10 12:43:09 ratchov Exp $	*/
d126 4
a129 1
	unsigned zomb;				/* destroyed but not freed */
a134 3
#define MIX_DROP	1
#define MIX_AUTOQUIT	2
			unsigned flags;		/* bit mask of above */
d137 2
a138 1
			int maxlat;		/* max latency allowed*/
a140 2
#define SUB_DROP	1
#define SUB_AUTOQUIT	2
a141 1
			unsigned flags;		/* bit mask of above */
d143 2
a144 1
			int maxlat;		/* max latency allowed*/
a167 2
#define THRU_AUTOQUIT	1
			unsigned flags;		/* bit mask of above */
d173 17
d193 1
d200 1
d227 2
a228 2
struct aproc *mix_new(char *, int);
struct aproc *sub_new(char *, int);
@


1.25
log
@make dev_done() common to audio and MIDI, and drop dev_thrudone()
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.24 2009/10/06 18:06:55 ratchov Exp $	*/
d177 3
a179 1
				void (*cb)(void *, unsigned);
@


1.24
log
@prevent aproc structures to be deleted twice. Doesn't change anything
for now but will be used in future code.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.23 2009/09/27 11:51:20 ratchov Exp $	*/
d169 2
@


1.23
log
@remove all debug traces
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.22 2009/08/27 06:31:13 ratchov Exp $	*/
d126 1
@


1.22
log
@when an audio program connects to aucat, restore the volume it
had the last time. For instance, this fixes the problem of programs
reopenning the connection to aucat very often and thus resetting
the volume setting all the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.21 2009/08/26 08:28:21 ratchov Exp $	*/
d187 1
@


1.21
log
@when allocating the midi channel for the volume control of a new
client, pick the oldest unused channel rather than the first found.
This way new clients don't reuse channels of recently used applications,
thus improving a lot the client<->channel affinity.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.20 2009/08/26 06:10:15 ratchov Exp $	*/
d179 1
@


1.20
log
@don't mess with audio internals from within the midi bits. Instead
use a call-back interface. This allows easily sending volume changes
feedback to audio applications.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.19 2009/08/21 16:48:03 ratchov Exp $	*/
d172 1
d178 1
@


1.19
log
@make aucat(1) expose a MIDI device to control server behaviour in
realtime.  For now only the playback volume of individual streams can be
changed/monitored. To each stream is assigned a MIDI channel; the volume
is changed/monitored using the standard controller number 7.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.18 2009/07/25 10:52:18 ratchov Exp $	*/
d173 2
a174 1
				struct aproc *owner;
@


1.18
log
@fix comments, remove no longer needed declaration, reorder includes
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.17 2009/07/25 08:44:27 ratchov Exp $	*/
d169 9
@


1.17
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.16 2009/01/23 17:38:15 ratchov Exp $	*/
d98 1
a98 1
	 * by the given amount of _frames_
d104 1
a104 1
	 * by the given amount of _frames_
d109 2
a110 2
	 * destroy the aproc, called just before to free the
	 * aproc structure
@


1.16
log
@spacing + typo fix from Matt Jibson <matt.jibson(at)gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.15 2008/12/29 17:59:08 ratchov Exp $	*/
d23 1
d165 4
d176 1
@


1.15
log
@make the code "more correct": add reference counters to aproc
structures so we can keep a pointer to the device. Beside some
simplifications, this allows to easily handle the situation
where the audio device desappears. No change in the behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.14 2008/12/19 08:01:06 ratchov Exp $	*/
d151 1
a151 1
			int idelta, odelta;	/* reminder of conv_[io]pos */
@


1.14
log
@use simple linear interpolation in the resampling code.
This partially removes the ``metallic'' noise audible
especially when upsampling 8k -> 44.1k.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.13 2008/12/07 17:10:41 ratchov Exp $	*/
d124 1
@


1.13
log
@When resampling, don't require the sample frequency to be an integer.
This removes the arithmetic constraint between the sample frequency
and the block size and all the associated code. Now aucat can work
in server mode with any block size.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.12 2008/11/09 16:26:07 ratchov Exp $	*/
d145 3
a147 1
			short ctx[NCHAN_MAX];
d149 1
a149 1
			int ipos, opos;
@


1.12
log
@make aucat(1) stop automatically the audio(1) device if it's idle. This
way, when in server mode, it consumes no CPU if there are no clients.
Later, this will allow to start aucat(1) at session or system startup.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.11 2008/11/04 22:18:12 ratchov Exp $	*/
d146 1
a146 1
			unsigned irate, orate;
d185 1
a185 1
struct aproc *resamp_new(char *, struct aparams *, struct aparams *);
@


1.11
log
@split code that converts any->any in two parts: one to encode
native->any and one to decode any->native. It is simpler and
faster this way.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.10 2008/11/04 18:24:06 ratchov Exp $	*/
d132 1
d139 1
d192 2
@


1.10
log
@cleanup: remove channel mapping bits from encoding conversion code.
As a side effect, reduce CPU usage by ~10% on envy(4) devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.9 2008/11/04 17:51:46 ratchov Exp $	*/
a113 12
struct aconv {
	/*
	 * Format of the buffer. This part is used by conversion code.
	 */
	int bfirst;		/* bytes to skip at startup */
	unsigned bps;		/* bytes per sample (padding included) */
	unsigned shift;		/* shift to get 32bit MSB-justified int */
	int sigbit;		/* sign bits to XOR to unsigned samples */
	int bnext;		/* bytes to skip to reach the next byte */
	int snext;		/* bytes to skip to reach the next sample */
};

a128 4
			struct aconv ist, ost;
			int idelta, odelta;	/* reminder of conv_[io]pos */
		} conv;
		struct {
d151 8
a182 1
struct aproc *conv_new(char *, struct aparams *, struct aparams *);
d185 2
d191 1
a191 1
#endif /* !defined(FIFO_H) */
@


1.9
log
@add "new" conversion code to map any channel range into any other
channel range (based on the encoding conversion code). Will allow to
unentangle channel mapping from encoding conversion. As a side effect,
greatly reduces CPU usage for channel mapping. No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.8 2008/11/04 15:22:40 ratchov Exp $	*/
a117 1

a118 1
	unsigned nch;		/* number of channels: nch = cmax - cmin + 1 */
a123 2
	unsigned cmin;		/* provided/consumed channels */
	unsigned bpf;		/* bytes per frame: bpf = nch * bps */
@


1.8
log
@cleanup: resample stream while in native format and remove resampling
bits from the encoding conversion code. As a side effect this reduces
CPU usage by 30% on envy(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.7 2008/11/04 14:16:09 ratchov Exp $	*/
d168 3
d197 1
@


1.7
log
@optimization: add "new" resampling code (actually based on the existing
conversion bits) and use it when resampling only is required (ie for
clients using s16 encoding), this is the most common case. Reduces CPU
usage by ~50%. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.6 2008/10/26 08:49:43 ratchov Exp $	*/
a119 2
	unsigned rate;		/* frames per second */
	unsigned pos;		/* current position in the stream */
a127 1
	int ctx[NCHAN_MAX];	/* current frame (for resampling) */
@


1.6
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.5 2008/08/14 09:58:55 ratchov Exp $	*/
d165 6
d196 1
@


1.5
log
@move all device related stuff from aucat.c to a new dev.c file.
The new dev_xxx() routines expose a "high level" self-contained
interface to the device. At initialization, the device is opened
and two chains of aproc structures are created:

 * a playback chain that exposes a (initially) empty mix
   aproc to which the rest of the code can attach new
   streams to be played

 * record chain that exposes a (initially) empty sub aproc
   to which the rest of the code can attach new stream to
   to record

The rest of the code, has just to use dev_attach() routine to
attach streams. While we're at it, add a ``devops'' structure
containing pointers to the device-specific routines. This will
allow later to add support for other type of device than the
Sun API.

Also, write the .wav headers in file_del(), so put all header
related data in the file strucuture. This allows to close() the
file, as soon as wpipe_xxx() aproc terminates. This will be
useful for the server, because it will need to close() descripts
of closed connections immediately.

add mix_pushzero() routine to fill the mixer with silence. It
will be used to avoid the mixer to underrun when there are no
input streams. Since we always have at least one input stream
there's no behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.4 2008/08/14 09:47:51 ratchov Exp $	*/
d96 12
d130 1
a130 1
	int ctx[CHAN_MAX];	/* current frame (for resampling) */
d149 1
d154 3
a156 1
			unsigned flags;
d161 3
a163 1
			unsigned flags;
d187 2
a188 2
struct aproc *mix_new(void);
struct aproc *sub_new(void);
@


1.4
log
@add an "AUTOQUIT" flag to mix and sub aprocs. If the flag is
set, the mix aproc will exit once there are no more input
streams, similarly the sub aproc will exit once there are no
more ouput streams. If the flag is not set, the mix aproc will
generate silence, and the sub aproc will drop samples. By
default this flag is set, so no behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.3 2008/08/14 09:45:23 ratchov Exp $	*/
d173 3
@


1.3
log
@add a xxx_done() method to aproc structures, that cleans up just
before free()ing the aproc structure, this is cleaner and will
allow to reuse wpipe_xxx() and rpipe_xxx() when defining new
aprocs. No behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.2 2008/06/02 17:06:36 ratchov Exp $	*/
d139 2
a140 1
#define MIX_DROP 1
d144 2
a145 1
#define SUB_DROP 1
@


1.2
log
@allow the user to choose the aucat behaviour when underruns/overruns
occur on a per-stream basis, using -Xx flags.  There are 3 possible
policies:

 - ignore : ignores underruns/overruns, for instance, this mode
   could be used for creating simple pipes with utilities; like in
   your last cdio diff.

 - sync : insert/discard samples in order to keep all streams in
   sync, useful for multi-tracker-like apps and/or to sync
   midi/video/whatever on audio streams (this was the previous
   behaviour)

 - error : if overruns/underruns occur, consider it as fatal error
   and kill the corresponding stream (without disturbing others).
   Useful, for reliable recordings (and/or debugging aucat
   itself:).

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aproc.h,v 1.1 2008/05/23 07:15:46 ratchov Exp $	*/
d94 6
d149 1
d155 6
d162 6
@


1.1
log
@add support for:
 - recording, full-duplex operation
 - format conversions and resampling on the fly
 - mixing on the fly of multiple inputs of different formats
 - up to 16 channels, simplistic "routing" of channel ranges
 - more linear encodings (in raw and wav files)
the old behaviour is fully preserved if none of the new -i and -o
options are used.

code and fixes from jakemsr@@ and eric@@, suggestions by others.
ok "go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d132 8
@

