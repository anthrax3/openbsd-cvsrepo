head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.6
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.4
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.2
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.2
	OPENBSD_5_0:1.22.0.6
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.30
date	2017.01.03.07.33.22;	author ratchov;	state Exp;
branches;
next	1.29;
commitid	jtT5MKNlfvRYBwMA;

1.29
date	2016.09.30.08.43.23;	author ratchov;	state Exp;
branches;
next	1.28;
commitid	b4CFwzFxQMLhrOkt;

1.28
date	2016.01.10.11.06.44;	author ratchov;	state Exp;
branches;
next	1.27;
commitid	Mp9fmG748uiNux1y;

1.27
date	2015.11.09.14.44.23;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	l5KOsRzgoVRRaPAL;

1.26
date	2015.01.21.08.43.55;	author ratchov;	state Exp;
branches;
next	1.25;
commitid	SYQcoS9jhSKqSJDL;

1.25
date	2013.11.18.17.37.45;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2011.10.12.07.20.03;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.04.06.15.28;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2010.01.11.13.06.32;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.10.21.47.41;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.09.16.49.48;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.27.11.51.20;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.21.16.48.03;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.25.10.52.18;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.19.15.49.48;	author martynas;	state Exp;
branches;
next	1.11;

1.11
date	2009.02.13.20.48.49;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.23.17.38.15;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.09.16.26.07;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.03.22.25.13;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2008.10.26.08.49.43;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.14.10.02.10;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.14.09.46.36;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2008.08.14.09.44.15;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.14.09.39.16;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.25.21.16.37;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.23.07.15.46;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Assert we're not freeing buffers we didn't allocate (DEBUG mode).
@
text
@/*	$OpenBSD: abuf.c,v 1.28 2016/01/10 11:06:44 ratchov Exp $	*/
/*
 * Copyright (c) 2008-2012 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Simple byte fifo.
 *
 * The abuf data is split in two parts: (1) valid data available to the reader
 * (2) space available to the writer, which is not necessarily unused. It works
 * as follows: the write starts filling at offset (start + used), once the data
 * is ready, the writer adds to used the count of bytes available.
 */
#include <stdlib.h>

#include "abuf.h"
#include "utils.h"

#ifdef DEBUG
void
abuf_log(struct abuf *buf)
{
	log_putu(buf->start);
	log_puts("+");
	log_putu(buf->used);
	log_puts("/");
	log_putu(buf->len);
}
#endif

void
abuf_init(struct abuf *buf, unsigned int len)
{
	buf->data = xmalloc(len);
	buf->len = len;
	buf->used = 0;
	buf->start = 0;
}

void
abuf_done(struct abuf *buf)
{
#ifdef DEBUG
	if (buf->used > 0) {
		if (log_level >= 3) {
			log_puts("deleting non-empty buffer, used = ");
			log_putu(buf->used);
			log_puts("\n");
		}
	}
#endif
	xfree(buf->data);
	buf->data = (void *)0xdeadbeef;
}

/*
 * return the reader pointer and the number of bytes available
 */
unsigned char *
abuf_rgetblk(struct abuf *buf, int *rsize)
{
	int count;

	count = buf->len - buf->start;
	if (count > buf->used)
		count = buf->used;
	*rsize = count;
	return buf->data + buf->start;
}

/*
 * discard "count" bytes at the start postion.
 */
void
abuf_rdiscard(struct abuf *buf, int count)
{
#ifdef DEBUG
	if (count < 0 || count > buf->used) {
		log_puts("abuf_rdiscard: bad count = ");
		log_putu(count);
		log_puts("\n");
		panic();
	}
#endif
	buf->used -= count;
	buf->start += count;
	if (buf->start >= buf->len)
		buf->start -= buf->len;
}

/*
 * advance the writer pointer by "count" bytes
 */
void
abuf_wcommit(struct abuf *buf, int count)
{
#ifdef DEBUG
	if (count < 0 || count > (buf->len - buf->used)) {
		log_puts("abuf_wcommit: bad count = ");
		log_putu(count);
		log_puts("\n");
		panic();
	}
#endif
	buf->used += count;
}

/*
 * get writer pointer and the number of bytes writable
 */
unsigned char *
abuf_wgetblk(struct abuf *buf, int *rsize)
{
	int end, avail, count;

	end = buf->start + buf->used;
	if (end >= buf->len)
		end -= buf->len;
	avail = buf->len - buf->used;
	count = buf->len - end;
	if (count > avail)
		count = avail;
	*rsize = count;
	return buf->data + end;
}
@


1.29
log
@Remove unnecessary includes. From Michael W. Bombardieri <mb at ii.net>.
@
text
@d63 1
a63 1
	free(buf->data);
@


1.28
log
@trailing spaces, fit in 80 columns
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.26 2015/01/21 08:43:55 ratchov Exp $	*/
a24 1
#include <stdio.h>
a25 1
#include <string.h>
@


1.27
log
@Remove xfree(). From Michael W. Bombardieri.

ok ratchov@@
@
text
@d56 1
a56 1
#ifdef DEBUG	
@


1.26
log
@Simplify internals and rewrite file header parsing code:
- remove -M, -t, -w, -C, -x flags that don't make sense anymore
- make "-j off" the default (sndiod already does the job)
- don't limit the number of played/recorded files.
- add support for floating-point encoded files.
- add support for apple .aiff and sun/next .au files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 1
a65 1
	xfree(buf->data);
@


1.25
log
@add missing prototypes
@
text
@d3 1
a3 1
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
d18 1
a18 3
 * Simple byte fifo. It has one reader and one writer. The abuf
 * structure is used to interconnect audio processing units (aproc
 * structures).
a24 9
/*
 * TODO
 *
 *	use blocks instead of frames for WOK and ROK macros. If necessary
 *	(unlikely) define reader block size and writer blocks size to
 *	ease pipe/socket implementation
 */
#include <err.h>
#include <stdarg.h>
d30 1
a30 12
#include "aparams.h"
#include "aproc.h"
#include "conf.h"
#ifdef DEBUG
#include "dbg.h"
#endif

void abuf_dump(struct abuf *);
int abuf_flush_do(struct abuf *);
int abuf_fill_do(struct abuf *);
void abuf_eof_do(struct abuf *);
void abuf_hup_do(struct abuf *);
d34 1
a34 1
abuf_dbg(struct abuf *buf)
d36 5
a40 11
	if (buf->wproc) {
		aproc_dbg(buf->wproc);
	} else {
		dbg_puts("none");
	}
	dbg_puts(buf->inuse ? "=>" : "->");
	if (buf->rproc) {
		aproc_dbg(buf->rproc);
	} else {
		dbg_puts("none");
	}
d42 1
d45 1
a45 15
abuf_dump(struct abuf *buf)
{
	abuf_dbg(buf);
	dbg_puts(": used = ");
	dbg_putu(buf->used);
	dbg_puts("/");
	dbg_putu(buf->len);
	dbg_puts(" start = ");
	dbg_putu(buf->start);
	dbg_puts("\n");
}
#endif

struct abuf *
abuf_new(unsigned int nfr, struct aparams *par)
d47 2
a48 27
	struct abuf *buf;
	unsigned int len, bpf;

	bpf = aparams_bpf(par);
	len = nfr * bpf;
	buf = malloc(sizeof(struct abuf) + len);
	if (buf == NULL) {
#ifdef DEBUG
		dbg_puts("couldn't allocate abuf of ");
		dbg_putu(nfr);
		dbg_puts("fr * ");
		dbg_putu(bpf);
		dbg_puts("bpf\n");
		dbg_panic();
#else
		err(1, "malloc");
#endif
	}
	buf->bpf = bpf;
	buf->cmin = par->cmin;
	buf->cmax = par->cmax;
	buf->inuse = 0;

	/*
	 * fill fifo pointers
	 */
	buf->len = nfr;
a50 4
	buf->rproc = NULL;
	buf->wproc = NULL;
	buf->duplex = NULL;
	return buf;
d54 1
a54 1
abuf_del(struct abuf *buf)
d56 6
a61 21
	if (buf->duplex)
		buf->duplex->duplex = NULL;
#ifdef DEBUG
	if (buf->rproc || buf->wproc) {
		abuf_dbg(buf);
		dbg_puts(": can't delete referenced buffer\n");
		dbg_panic();
	}
	if (ABUF_ROK(buf)) {
		/*
		 * XXX: we should call abort(), here.
		 * However, poll() doesn't seem to return POLLHUP,
		 * so the reader is never destroyed; instead it appears	
		 * as blocked. Fix file_poll(), if fixable, and add
		 * a call to abord() here.
		 */
		if (debug_level >= 3) {
			abuf_dbg(buf);
			dbg_puts(": deleting non-empty buffer, used = ");
			dbg_putu(buf->used);
			dbg_puts("\n");
d65 2
a66 17
	free(buf);
}

/*
 * Clear buffer contents.
 */
void
abuf_clear(struct abuf *buf)
{
#ifdef DEBUG
	if (debug_level >= 3) {
		abuf_dbg(buf);
		dbg_puts(": cleared\n");
	}
#endif
	buf->used = 0;
	buf->start = 0;
d70 1
a70 1
 * Get a pointer to the readable block at the given offset.
d73 1
a73 1
abuf_rgetblk(struct abuf *buf, unsigned int *rsize, unsigned int ofs)
d75 1
a75 1
	unsigned int count, start, used;
d77 3
a79 16
	start = buf->start + ofs;
	used = buf->used - ofs;
	if (start >= buf->len)
		start -= buf->len;
#ifdef DEBUG
	if (start >= buf->len || used > buf->used) {
		abuf_dump(buf);
		dbg_puts(": rgetblk: bad ofs = ");
		dbg_putu(ofs);
		dbg_puts("\n");
		dbg_panic();
	}
#endif
	count = buf->len - start;
	if (count > used)
		count = used;
d81 1
a81 1
	return (unsigned char *)buf + sizeof(struct abuf) + start * buf->bpf;
d85 1
a85 1
 * Discard the block at the start postion.
d88 1
a88 1
abuf_rdiscard(struct abuf *buf, unsigned int count)
d91 5
a95 12
	if (count > buf->used) {
		abuf_dump(buf);
		dbg_puts(": rdiscard: bad count = ");
		dbg_putu(count);
		dbg_puts("\n");
		dbg_panic();
	}
	if (debug_level >= 4) {
		abuf_dbg(buf);
		dbg_puts(": discard(");
		dbg_putu(count);
		dbg_puts(")\n");
d105 1
a105 1
 * Commit the data written at the end postion.
d108 1
a108 1
abuf_wcommit(struct abuf *buf, unsigned int count)
d111 5
a115 12
	if (count > (buf->len - buf->used)) {
		abuf_dump(buf);
		dbg_puts(": rdiscard: bad count = ");
		dbg_putu(count);
		dbg_puts("\n");
		dbg_panic();
	}
	if (debug_level >= 4) {
		abuf_dbg(buf);
		dbg_puts(": commit(");
		dbg_putu(count);
		dbg_puts(")\n");
d122 1
a122 1
 * Get a pointer to the writable block at offset ofs.
d125 1
a125 1
abuf_wgetblk(struct abuf *buf, unsigned int *rsize, unsigned int ofs)
d127 1
a127 1
	unsigned int end, avail, count;
d129 1
a129 2

	end = buf->start + buf->used + ofs;
d132 1
a132 10
#ifdef DEBUG
	if (end >= buf->len) {
		abuf_dump(buf);
		dbg_puts(": wgetblk: bad ofs = ");
		dbg_putu(ofs);
		dbg_puts("\n");
		dbg_panic();
	}
#endif
	avail = buf->len - (buf->used + ofs);
d135 1
a135 1
			count = avail;
d137 1
a137 351
	return (unsigned char *)buf + sizeof(struct abuf) + end * buf->bpf;
}

/*
 * Flush buffer either by dropping samples or by calling the aproc
 * call-back to consume data. Return 0 if blocked, 1 otherwise.
 */
int
abuf_flush_do(struct abuf *buf)
{
	struct aproc *p;

	p = buf->rproc;
	if (!p)
		return 0;
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": in\n");
	}
#endif
	return p->ops->in(p, buf);
}

/*
 * Fill the buffer either by generating silence or by calling the aproc
 * call-back to provide data. Return 0 if blocked, 1 otherwise.
 */
int
abuf_fill_do(struct abuf *buf)
{
	struct aproc *p;

	p = buf->wproc;
	if (!p)
		return 0;
#ifdef DEBUG
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": out\n");
	}
#endif
	return p->ops->out(p, buf);
}

/*
 * Notify the reader that there will be no more input (producer
 * disappeared) and destroy the buffer.
 */
void
abuf_eof_do(struct abuf *buf)
{
	struct aproc *p;

	p = buf->rproc;
	if (p) {
		buf->rproc = NULL;
		LIST_REMOVE(buf, ient);
		buf->inuse++;
#ifdef DEBUG
		if (debug_level >= 4) {
			aproc_dbg(p);
			dbg_puts(": eof\n");
		}
#endif
		p->ops->eof(p, buf);
		buf->inuse--;
	}
	abuf_del(buf);
}

/*
 * Notify the writer that the buffer has no more consumer,
 * and destroy the buffer.
 */
void
abuf_hup_do(struct abuf *buf)
{
	struct aproc *p;

	if (ABUF_ROK(buf)) {
#ifdef DEBUG
		if (debug_level >= 3) {
			abuf_dbg(buf);
			dbg_puts(": hup: lost ");
			dbg_putu(buf->used);
			dbg_puts(" bytes\n");
		}
#endif
		buf->used = 0;
	}
	p = buf->wproc;
	if (p != NULL) {
		buf->wproc = NULL;
		LIST_REMOVE(buf, oent);
		buf->inuse++;
#ifdef DEBUG
		if (debug_level >= 3) {
			aproc_dbg(p);
			dbg_puts(": hup\n");
		}
#endif
		p->ops->hup(p, buf);
		buf->inuse--;
	}
	abuf_del(buf);
}

/*
 * Notify the read end of the buffer that there is input available
 * and that data can be processed again.
 */
int
abuf_flush(struct abuf *buf)
{
	if (buf->inuse) {
#ifdef DEBUG
		if (debug_level >= 4) {
			abuf_dbg(buf);
			dbg_puts(": flush blocked (inuse)\n");
		}
#endif
	} else {
		buf->inuse++;
		for (;;) {
			if (!abuf_flush_do(buf))
				break;
		}
		buf->inuse--;
		if (ABUF_HUP(buf)) {
			abuf_hup_do(buf);
			return 0;
		}
	}
	return 1;
}

/*
 * Notify the write end of the buffer that there is room and data can be
 * written again. This routine can only be called from the out()
 * call-back of the reader.
 *
 * Return 1 if the buffer was filled, and 0 if eof condition occured. The
 * reader must detach the buffer on EOF condition, since its aproc->eof()
 * call-back will never be called.
 */
int
abuf_fill(struct abuf *buf)
{
	if (buf->inuse) {
#ifdef DEBUG
		if (debug_level >= 4) {
			abuf_dbg(buf);
			dbg_puts(": fill blocked (inuse)\n");
		}
#endif
	} else {
		buf->inuse++;
		for (;;) {
			if (!abuf_fill_do(buf))
				break;
		}
		buf->inuse--;
		if (ABUF_EOF(buf)) {
			abuf_eof_do(buf);
			return 0;
		}
	}
	return 1;
}

/*
 * Run a read/write loop on the buffer until either the reader or the
 * writer blocks, or until the buffer reaches eofs. We can not get hup here,
 * since hup() is only called from terminal nodes, from the main loop.
 *
 * NOTE: The buffer may disappear (ie. be free()ed) if eof is reached, so
 * do not keep references to the buffer or to its writer or reader.
 */
void
abuf_run(struct abuf *buf)
{
	int canfill = 1, canflush = 1;

	if (buf->inuse) {
#ifdef DEBUG
		if (debug_level >= 4) {
			abuf_dbg(buf);
			dbg_puts(": run blocked (inuse)\n");
		}
#endif
		return;
	}
	buf->inuse++;
	for (;;) {
		if (canfill) {
			if (!abuf_fill_do(buf))
				canfill = 0;
			else
				canflush = 1;
		} else if (canflush) {
			if (!abuf_flush_do(buf))
				canflush = 0;
			else
				canfill = 1;
		} else
			break;
	}
	buf->inuse--;
	if (ABUF_EOF(buf)) {
		abuf_eof_do(buf);
		return;
	}
	if (ABUF_HUP(buf)) {
		abuf_hup_do(buf);
		return;
	}
}

/*
 * Notify the reader that there will be no more input (producer
 * disappeared). The buffer is flushed and eof() is called only if all
 * data is flushed.
 */
void
abuf_eof(struct abuf *buf)
{
#ifdef DEBUG
	if (debug_level >= 3) {
		abuf_dbg(buf);
		dbg_puts(": eof requested\n");
	}
	if (buf->wproc == NULL) {
		abuf_dbg(buf);
		dbg_puts(": eof, no writer\n");
		dbg_panic();
	}
#endif
	LIST_REMOVE(buf, oent);
	buf->wproc = NULL;
	if (buf->rproc != NULL) {
		if (!abuf_flush(buf))
			return;
		if (ABUF_ROK(buf)) {
			/*
			 * Could not flush everything, the reader will
			 * have a chance to delete the abuf later.
			 */
#ifdef DEBUG
			if (debug_level >= 3) {
				abuf_dbg(buf);
				dbg_puts(": eof, blocked (drain)\n");
			}
#endif
			return;
		}
	}
	if (buf->inuse) {
#ifdef DEBUG
		if (debug_level >= 3) {
			abuf_dbg(buf);
			dbg_puts(": eof, blocked (inuse)\n");
		}
#endif
		return;
	}
	abuf_eof_do(buf);
}

/*
 * Notify the writer that the buffer has no more consumer,
 * and that no more data will accepted.
 */
void
abuf_hup(struct abuf *buf)
{
#ifdef DEBUG
	if (debug_level >= 3) {
		abuf_dbg(buf);
		dbg_puts(": hup requested\n");
	}
	if (buf->rproc == NULL) {
		abuf_dbg(buf);
		dbg_puts(": hup, no reader\n");
		dbg_panic();
	}
#endif
	buf->rproc = NULL;
	LIST_REMOVE(buf, ient);
	if (buf->wproc != NULL) {
		if (buf->inuse) {
#ifdef DEBUG
			if (debug_level >= 3) {
				abuf_dbg(buf);
				dbg_puts(": eof, blocked (inuse)\n");
			}
#endif
			return;
		}
	}
	abuf_hup_do(buf);
}

/*
 * Notify the reader of the change of its real-time position
 */
void
abuf_ipos(struct abuf *buf, int delta)
{
	struct aproc *p = buf->rproc;

	if (p && p->ops->ipos) {
		buf->inuse++;
#ifdef DEBUG
		if (debug_level >= 4) {
			aproc_dbg(p);
			dbg_puts(": ipos delta = ");
			dbg_puti(delta);
			dbg_puts("\n");
		}
#endif
		p->ops->ipos(p, buf, delta);
		buf->inuse--;
	}
	if (ABUF_HUP(buf))
		abuf_hup_do(buf);
}

/*
 * Notify the writer of the change of its real-time position
 */
void
abuf_opos(struct abuf *buf, int delta)
{
	struct aproc *p = buf->wproc;

	if (p && p->ops->opos) {
		buf->inuse++;
#ifdef DEBUG
		if (debug_level >= 4) {
			aproc_dbg(p);
			dbg_puts(": opos delta = ");
			dbg_puti(delta);
			dbg_puts("\n");
		}
#endif
		p->ops->opos(p, buf, delta);
		buf->inuse--;
	}
	if (ABUF_HUP(buf))
		abuf_hup_do(buf);
@


1.24
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.23 2011/10/12 07:20:03 ratchov Exp $	*/
d47 6
@


1.23
log
@Simplify and improve the way options are parsed and remove ~300 lines
of code that becomes unused. Few command line arguments changes are
required though:

  - stream definitions (-ios) now must follow devices definitions they
    are attached to (-fMn)

  - the -n option is now a special "loopback" device and is thus used
    like -f, eg it must precede streams

  - in midicat, midi thru boxes are not created automatically anymore,
    the new "-M" option must be used for that

  - channel numbers (-Cc options) correspond always to channel numbers
    of the hardware.

  - the -u option isn't needed anymore

  - increase the log verbosity so user errors are logged
    without using -d

tested by many, help from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.22 2010/06/04 06:15:28 ratchov Exp $	*/
d80 1
a80 1
abuf_new(unsigned nfr, struct aparams *par)
d83 1
a83 1
	unsigned len, bpf;
d167 1
a167 1
abuf_rgetblk(struct abuf *buf, unsigned *rsize, unsigned ofs)
d169 1
a169 1
	unsigned count, start, used;
d195 1
a195 1
abuf_rdiscard(struct abuf *buf, unsigned count)
d222 1
a222 1
abuf_wcommit(struct abuf *buf, unsigned count)
d246 1
a246 1
abuf_wgetblk(struct abuf *buf, unsigned *rsize, unsigned ofs)
d248 1
a248 1
	unsigned end, avail, count;
@


1.22
log
@Allow the audio device to be opened only while it's actually used.
This is necessary for uaudio devices, for instance to start aucat
before the device is plugged. Or to unplug a device whithout
having to restart aucat when another device is plugged.  This is
controlled with the new -a option.

Allow multiple audio devices to be used concurently, i.e.
multiple ``-f devname'' options to be used; -f options must follow
per-device options, which is what we do for other options.
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.21 2010/04/06 20:07:01 ratchov Exp $	*/
d130 1
a130 1
		 * XXX : we should call abort(), here.
@


1.21
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.20 2010/04/03 17:59:17 ratchov Exp $	*/
d205 6
d231 6
@


1.20
log
@backout last change, committed by mistake, sorry...
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.18 2010/01/11 13:06:32 ratchov Exp $	*/
d108 1
a108 1
	buf->len = len;
a110 3
	buf->abspos = 0;
	buf->silence = 0;
	buf->drop = 0;
a160 3
	buf->abspos = 0;
	buf->silence = 0;
	buf->drop = 0;
d188 1
a188 1
	return (unsigned char *)buf + sizeof(struct abuf) + start;
a209 1
	buf->abspos += count;
d256 1
a256 1
	return (unsigned char *)buf + sizeof(struct abuf) + end;
a266 1
	unsigned count;
d268 3
a270 15
	if (buf->drop > 0) {
		count = buf->drop;
		if (count > buf->used)
			count = buf->used;
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 4) {
				abuf_dbg(buf);
				dbg_puts(": flush: no data to drop\n");
			}
#endif
			return 0;
		}
		abuf_rdiscard(buf, count);
		buf->drop -= count;
d272 4
a275 8
		if (debug_level >= 4) {
			abuf_dbg(buf);
			dbg_puts(": flush: dropped ");
			dbg_putu(count);
			dbg_puts(", to drop = ");
			dbg_putu(buf->drop);
			dbg_puts("\n");
		}
d277 1
a277 14
	} else {
		p = buf->rproc;
		if (!p)
			return 0;
#ifdef DEBUG
		if (debug_level >= 4) {
			aproc_dbg(p);
			dbg_puts(": in\n");
		}
#endif
		if (!p->ops->in(p, buf))
			return 0;
	}
	return 1;
a287 2
	unsigned char *data;
	unsigned count;
d289 3
a291 16
	if (buf->silence > 0) {
		data = abuf_wgetblk(buf, &count, 0);
		if (count >= buf->silence)
			count = buf->silence;
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 4) {
				abuf_dbg(buf);
				dbg_puts(": fill: no space for silence\n");
			}
#endif
			return 0;
		}
		memset(data, 0, count);
		abuf_wcommit(buf, count);
		buf->silence -= count;
d293 4
a296 8
		if (debug_level >= 4) {
			abuf_dbg(buf);
			dbg_puts(": fill: inerted ");
			dbg_putu(count);
			dbg_puts(", remaining silence = ");
			dbg_putu(buf->silence);
			dbg_puts("\n");
		}
d298 1
a298 16
		p = buf->wproc;
	} else {
		p = buf->wproc;
		if (!p)
			return 0;
#ifdef DEBUG
		if (debug_level >= 4) {
			aproc_dbg(p);
			dbg_puts(": out\n");
		}
#endif
		if (!p->ops->out(p, buf)) {
			return 0;
		}
	}
	return 1;
@


1.19
log
@doc fixes from jmc
@
text
@d108 1
a108 1
	buf->len = nfr;
d111 3
d164 3
d194 1
a194 1
	return (unsigned char *)buf + sizeof(struct abuf) + start * buf->bpf;
d216 1
d263 1
a263 1
	return (unsigned char *)buf + sizeof(struct abuf) + end * buf->bpf;
d274 1
d276 5
a280 3
	p = buf->rproc;
	if (!p)
		return 0;
d282 31
a312 3
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": in\n");
d314 1
a314 2
#endif
	return p->ops->in(p, buf);
d325 2
d328 5
a332 3
	p = buf->wproc;
	if (!p)
		return 0;
d334 34
a367 3
	if (debug_level >= 4) {
		aproc_dbg(p);
		dbg_puts(": out\n");
d369 1
a369 2
#endif
	return p->ops->out(p, buf);
@


1.18
log
@When resuming from suspend, prime play buffers with silence,
otherwise the client would underrun by more than its own buffer
size, which currently is not allowed (causes the client to
deadlock).

Set the minimum client buffer size to two blocks. Single block
buffers don't work properly yet.

with help from jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.17 2010/01/10 21:47:41 ratchov Exp $	*/
d108 1
a108 1
	buf->len = len;
a110 3
	buf->abspos = 0;
	buf->silence = 0;
	buf->drop = 0;
a160 3
	buf->abspos = 0;
	buf->silence = 0;
	buf->drop = 0;
d188 1
a188 1
	return (unsigned char *)buf + sizeof(struct abuf) + start;
a209 1
	buf->abspos += count;
d256 1
a256 1
	return (unsigned char *)buf + sizeof(struct abuf) + end;
a266 1
	unsigned count;
d268 3
a270 15
	if (buf->drop > 0) {
		count = buf->drop;
		if (count > buf->used)
			count = buf->used;
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 4) {
				abuf_dbg(buf);
				dbg_puts(": flush: no data to drop\n");
			}
#endif
			return 0;
		}
		abuf_rdiscard(buf, count);
		buf->drop -= count;
d272 4
a275 8
		if (debug_level >= 4) {
			abuf_dbg(buf);
			dbg_puts(": flush: dropped ");
			dbg_putu(count);
			dbg_puts(", to drop = ");
			dbg_putu(buf->drop);
			dbg_puts("\n");
		}
d277 1
a277 14
	} else {
		p = buf->rproc;
		if (!p)
			return 0;
#ifdef DEBUG
		if (debug_level >= 4) {
			aproc_dbg(p);
			dbg_puts(": in\n");
		}
#endif
		if (!p->ops->in(p, buf))
			return 0;
	}
	return 1;
a287 2
	unsigned char *data;
	unsigned count;
d289 3
a291 16
	if (buf->silence > 0) {
		data = abuf_wgetblk(buf, &count, 0);
		if (count >= buf->silence)
			count = buf->silence;
		if (count == 0) {
#ifdef DEBUG
			if (debug_level >= 4) {
				abuf_dbg(buf);
				dbg_puts(": fill: no space for silence\n");
			}
#endif
			return 0;
		}
		memset(data, 0, count);
		abuf_wcommit(buf, count);
		buf->silence -= count;
d293 4
a296 8
		if (debug_level >= 4) {
			abuf_dbg(buf);
			dbg_puts(": fill: inerted ");
			dbg_putu(count);
			dbg_puts(", remaining silence = ");
			dbg_putu(buf->silence);
			dbg_puts("\n");
		}
d298 1
a298 16
		p = buf->wproc;
	} else {
		p = buf->wproc;
		if (!p)
			return 0;
#ifdef DEBUG
		if (debug_level >= 4) {
			aproc_dbg(p);
			dbg_puts(": out\n");
		}
#endif
		if (!p->ops->out(p, buf)) {
			return 0;
		}
	}
	return 1;
@


1.17
log
@Add traces to help tracking subtle timing bugs often causing
underuns and overruns; such bugs are hard to debug with ktrace
or a debugger. They are also handy to debug or monitor code
using aucat.

To enable traces, compile aucat with ``make DEBUG=-DDEBUG'' and
use the -d option multiple times.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.16 2009/10/09 16:49:48 ratchov Exp $	*/
d252 1
a252 1
		dbg_puts(": rgetblk: bad ofs = ");
@


1.16
log
@Make abuf structure smaller:
 - put aproc-specific parameters into unions since they are never
   used together
 - remove constant ``data'' pointer always pointing the end of the
   abuf structure
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.15 2009/09/27 11:51:20 ratchov Exp $	*/
d44 3
d48 30
d89 8
d98 1
d125 22
d156 6
d181 9
d203 9
d225 9
d249 9
d281 6
d291 10
d305 6
d333 6
d344 10
d359 6
d386 6
d408 8
d423 6
d443 6
d477 6
d512 6
d554 11
d575 6
d585 6
d603 11
d618 6
d640 8
d665 8
@


1.15
log
@remove all debug traces
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.14 2009/08/21 16:48:03 ratchov Exp $	*/
a74 1
	buf->data = (unsigned char *)buf + sizeof(*buf);
d115 1
a115 1
	return buf->data + start;
d157 1
a157 1
	return buf->data + end;
@


1.14
log
@make aucat(1) expose a MIDI device to control server behaviour in
realtime.  For now only the playback volume of individual streams can be
changed/monitored. To each stream is assigned a MIDI channel; the volume
is changed/monitored using the standard controller number 7.
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.13 2009/07/25 10:52:18 ratchov Exp $	*/
a44 21
#ifdef DEBUG
void
abuf_dprn(int n, struct abuf *buf, char *fmt, ...)
{
	va_list ap;

	if (debug_level < n)
		return;
	fprintf(stderr, "%s->%s: ",
	    buf->wproc ? buf->wproc->name : "none",
	    buf->rproc ? buf->rproc->name : "none");
	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
}
#define ABUF_DPRN(n, buf, ...) abuf_dprn((n), (buf), __VA_ARGS__)
#define ABUF_DPR(buf, ...) abuf_dprn(1, (buf), __VA_ARGS__)
#else
#define ABUF_DPRN(n, buf, ...) do {} while (0)
#define ABUF_DPR(buf, ...) do {} while (0)
#endif
d56 1
a56 2
		fprintf(stderr, "abuf_new: out of mem: %u * %u\n", nfr, bpf);
		abort();
a83 15
#ifdef DEBUG
	if (buf->rproc || buf->wproc || ABUF_ROK(buf)) {
		/*
		 * XXX : we should call abort(), here.
		 * However, poll() doesn't seem to return POLLHUP,
		 * so the reader is never destroyed; instead it appears	
		 * as blocked. Fix file_poll(), if fixable, and add
		 * a call to abord() here.
		 */
#if 0
		ABUF_DPRN(0, buf, "abuf_del: used = %u\n", buf->used);
		abort();
#endif
	}
#endif
a92 1
	ABUF_DPR(buf, "abuf_clear:\n");
a111 8
#ifdef DEBUG
	if (start >= buf->len || used > buf->used) {
		ABUF_DPRN(0, buf, "abuf_rgetblk: "
		    "bad ofs: start = %u used = %u/%u, ofs = %u\n",
		    buf->start, buf->used, buf->len, ofs);
		abort();
	}
#endif
a124 6
#ifdef DEBUG
	if (count > buf->used) {
		ABUF_DPRN(0, buf, "abuf_rdiscard: bad count %u\n", count);
		abort();
	}
#endif
a137 6
#ifdef DEBUG
	if (count > (buf->len - buf->used)) {
		ABUF_DPR(buf, "abuf_wcommit: bad count\n");
		abort();
	}
#endif
a152 9
#ifdef DEBUG
	if (end >= buf->len) {
		ABUF_DPR(buf, "abuf_wgetblk: %s -> %s: bad ofs, "
		    "start = %u, used = %u, len = %u, ofs = %u\n",
		    buf->wproc->name, buf->rproc->name,
		    buf->start, buf->used, buf->len, ofs);
		abort();
	}
#endif
a175 1
			ABUF_DPR(buf, "abuf_flush_do: no data to drop\n");
a179 2
		ABUF_DPR(buf, "abuf_flush_do: drop = %u\n", buf->drop);
		p = buf->rproc;
a180 1
		ABUF_DPRN(4, buf, "abuf_flush_do: in ready\n");
d182 3
a184 1
		if (!p || !p->ops->in(p, buf))
a205 1
			ABUF_DPR(buf, "abuf_fill_do: no space for silence\n");
a210 1
		ABUF_DPR(buf, "abuf_fill_do: silence = %u\n", buf->silence);
a212 1
		ABUF_DPRN(4, buf, "abuf_fill_do: out avail\n");
d214 3
a216 1
		if (p == NULL || !p->ops->out(p, buf)) {
a233 1
		ABUF_DPRN(2, buf, "abuf_eof_do: signaling reader\n");
d239 1
a239 2
	} else
		ABUF_DPR(buf, "abuf_eof_do: no reader, freeng buf\n");
a252 1
		ABUF_DPR(buf, "abuf_hup_do: lost %u bytes\n", buf->used);
a256 1
		ABUF_DPRN(2, buf, "abuf_hup_do: signaling writer\n");
d262 1
a262 2
	} else
		ABUF_DPR(buf, "abuf_hup_do: no writer, freeng buf\n");
a273 1
		ABUF_DPRN(4, buf, "abuf_flush: blocked\n");
a301 1
		ABUF_DPRN(4, buf, "abuf_fill: blocked\n");
a330 1
		ABUF_DPRN(4, buf, "abuf_run: blocked\n");
a366 7
#ifdef DEBUG
	if (buf->wproc == NULL) {
		ABUF_DPR(buf, "abuf_eof: no writer\n");
		abort();
	}
#endif
	ABUF_DPRN(2, buf, "abuf_eof: requested\n");
a376 1
			ABUF_DPRN(2, buf, "abuf_eof: will drain later\n");
a380 1
		ABUF_DPRN(2, buf, "abuf_eof: signal blocked\n");
a392 8
#ifdef DEBUG
	if (buf->rproc == NULL) {
		ABUF_DPR(buf, "abuf_hup: no reader\n");
		abort();
	}
#endif
	ABUF_DPRN(2, buf, "abuf_hup: initiated\n");

a396 1
			ABUF_DPRN(2, buf, "abuf_hup: signal blocked\n");
@


1.13
log
@fix comments, remove no longer needed declaration, reorder includes
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.12 2009/07/19 15:49:48 martynas Exp $	*/
d108 8
d118 1
@


1.12
log
@missing va_end in abuf_dprn.  ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.11 2009/02/13 20:48:49 ratchov Exp $	*/
d40 1
a40 1
#include "conf.h"
d43 1
a43 1
#include "abuf.h"
d116 1
a116 1
 * Clear buffer contents
d157 1
a157 1
 * Discard the block at the start postion
d176 1
a176 1
 * Commit the data written at the end postion
d220 2
a221 2
 * flush buffer either by dropping samples or by calling the aproc
 * call-back to consume data. Return 0 if blocked, 1 otherwise
d251 2
a252 2
 * fill the buffer either by generating silence or by calling the aproc
 * call-back to provide data. Return 0 if blocked, 1 otherwise
d286 1
a286 1
 * disappeared) and destroy the buffer
d308 1
a308 1
 * and destroy the buffer
d362 1
a362 1
 * reader must detach the buffer on EOF condition, since it's aproc->eof()
d387 1
a387 1
 * writer blocks, or until the buffer reaches eofs. We can not get hup hear,
a513 1

@


1.11
log
@style and typos fixes from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.10 2009/01/23 17:38:15 ratchov Exp $	*/
d58 1
@


1.10
log
@spacing + typo fix from Matt Jibson <matt.jibson(at)gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.9 2008/11/09 16:26:07 ratchov Exp $	*/
d35 1
a38 1
#include <stdarg.h>
@


1.9
log
@make aucat(1) stop automatically the audio(1) device if it's idle. This
way, when in server mode, it consumes no CPU if there are no clients.
Later, this will allow to start aucat(1) at session or system startup.
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.8 2008/11/03 22:25:13 ratchov Exp $	*/
d53 1
a53 1
	fprintf(stderr, "%s->%s: ", 
d337 1
a337 1
{	
d446 1
a446 1
			return;			
d499 1
a499 1
		p->ops->ipos(p, buf, delta);		
d514 1
a514 1
	
@


1.8
log
@A small optimization: handle most N-channel <-> M-channel conversions
inside the mixer and the demultiplexer. This way, aucat will not
trigger the heavy conversion code when only channel conversions are
required. Cuts ~50% of the CPU usage on envy(4) devices, can improve
surround 4.0, 5.1 and 7.1 capable devices. No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.7 2008/10/26 08:49:43 ratchov Exp $	*/
d112 14
@


1.7
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.6 2008/08/14 10:02:10 ratchov Exp $	*/
d41 1
d67 1
a67 1
abuf_new(unsigned nfr, unsigned bpf)
d70 1
a70 1
	unsigned len;
d72 1
d80 2
@


1.6
log
@in abuf_rgetblk() the ``start'' pointer may take a value beyond the
end of the buffer because periodic boundary conditions of the FIFO are
not met

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.5 2008/08/14 09:46:36 ratchov Exp $	*/
d26 3
d30 3
a32 8
 * TODO:
 *
 *	(hard) make abuf_fill() a boolean depending on whether
 *	eof is reached. So the caller can do:
 *
 *		if (!abuf_fill(buf)) {
 *			...
 *		}
d38 1
d44 21
d74 2
a75 1
		err(1, "abuf_new: malloc");
d78 1
d91 1
d99 5
a103 3
	DPRINTF("abuf_del:\n");
	if (buf->rproc) {
		fprintf(stderr, "abuf_del: has rproc: %s\n", buf->rproc->name);
d106 1
a106 6
	if (buf->wproc) {
		fprintf(stderr, "abuf_del: has wproc: %s\n", buf->wproc->name);
		abort();
	}
	if (buf->used > 0)
		fprintf(stderr, "abuf_del: used = %u\n", buf->used);
d122 8
d143 6
d162 6
d185 1
a185 1
		fprintf(stderr, "abuf_wgetblk: %s -> %s: bad ofs, "
d214 4
d220 2
a221 1
		DPRINTF("abuf_flush_do: drop = %u\n", buf->drop);
d223 1
d225 1
a225 1
		if (p == NULL || !p->ops->in(p, buf))
a231 15
 * Notify the read end of the buffer that there is input available
 * and that data can be processed again.
 */
void
abuf_flush(struct abuf *buf)
{
	for (;;) {
		if (!ABUF_ROK(buf))
			break;
		if (!abuf_flush_do(buf))
			break;
	}
}

/*
d246 4
d253 2
a254 1
		DPRINTF("abuf_fill_do: silence = %u\n", buf->silence);
d256 1
d258 1
a258 1
		if (p == NULL || !p->ops->out(p, buf))
d260 73
d342 3
a344 2
 * NOTE: The abuf writer may reach eof condition and disappear, dont keep
 * references to abuf->wproc.
d346 1
a346 1
void
d349 13
a361 5
	for (;;) {
		if (!ABUF_WOK(buf))
			break;
		if (!abuf_fill_do(buf))
			break;
d363 1
a376 1
	struct aproc *p;
d379 5
d385 10
a394 12
		if (ABUF_EOF(buf)) {
			p = buf->rproc;
			DPRINTFN(2, "abuf_run: %s: got eof\n", p->name);
			p->ops->eof(p, buf);
			buf->rproc = NULL;
			abuf_del(buf);
			return;
		}
		if (ABUF_WOK(buf) && canfill) {
			canfill = abuf_fill_do(buf);
		} else if (ABUF_ROK(buf) && canflush) {
			canflush = abuf_flush_do(buf);
d396 10
a405 1
			break; /* can neither read nor write */
d419 1
a419 1
		fprintf(stderr, "abuf_eof: no writer\n");
d423 2
a424 1
	DPRINTFN(2, "abuf_eof: requested by %s\n", buf->wproc->name);
d427 2
a428 1
		abuf_flush(buf);
d434 1
a434 2
			DPRINTFN(2, "abuf_eof: %s will drain the buf later\n",
			    buf->rproc->name);
a436 3
		DPRINTFN(2, "abuf_eof: signaling %s\n", buf->rproc->name);
		buf->rproc->ops->eof(buf->rproc, buf);
		buf->rproc = NULL;
d438 5
a442 1
	abuf_del(buf);
a444 1

d454 1
a454 1
		fprintf(stderr, "abuf_hup: no reader\n");
d458 2
a459 1
	DPRINTFN(2, "abuf_hup: initiated by %s\n", buf->rproc->name);
d461 1
d463 3
a465 4
		if (ABUF_ROK(buf)) {
			warnx("abuf_hup: %s: lost %u bytes",
			    buf->wproc->name, buf->used);
			buf->used = 0;
a466 3
		DPRINTFN(2, "abuf_hup: signaling %s\n", buf->wproc->name);
		buf->wproc->ops->hup(buf->wproc, buf);
		buf->wproc = NULL;
d468 36
a503 1
	abuf_del(buf);
@


1.5
log
@add a bytes counter to abuf structures to count the number of
bytes that entered the FIFO. The counter may overflow, so it
should be used with "modulo 2^32" arithmetic. The counter will
be used later to synchronize playback to record. No behaviour
change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.4 2008/08/14 09:44:15 ratchov Exp $	*/
d100 2
@


1.4
log
@move mix/sub underrun/overrun handling code and data in the
generic abuf structure, so it can reused. Required for an audio
server. No behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.3 2008/08/14 09:39:16 ratchov Exp $	*/
d64 1
d117 1
@


1.3
log
@factor code that discards data from abuf strucure into a single
abuf_rdiscard() routine. Similarly add abuf_wcommit() routine for
writing. The purpose is to stop manupulating FIFO pointers in
various places outiside abuf.c, its too error prone.
No behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.2 2008/05/25 21:16:37 ratchov Exp $	*/
d39 1
d64 2
d157 25
a187 2
	struct aproc *p = buf->rproc;

d191 1
a191 1
		if (p == NULL || !p->ops->in(p, buf))
d197 27
a233 2
	struct aproc *p = buf->wproc;

d237 1
a237 1
		if (p == NULL || !p->ops->out(p, buf))
d265 2
a266 3
		if (ABUF_WOK(buf) && canfill && buf->wproc) {
			p = buf->wproc;
			canfill = p->ops->out(p, buf);
d268 1
a268 2
			p = buf->rproc;
			canflush = p->ops->in(p, buf);
@


1.2
log
@give argument to LIST_END(), don't use variable lenght arrays as last
field of structures.

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.c,v 1.1 2008/05/23 07:15:46 ratchov Exp $	*/
a28 6
 *	(easy) create abuf_wcommitblk(), abuf_rdiscardblk() instead of tweeking
 *	the fifo pointers by hand. But first, find shorter function names...
 *
 *	(easy) dont initialize aproc-specific stuff in abuf_new(), let the
 *	aproc xxx_new() routines do it
 *
d101 21
@


1.1
log
@add support for:
 - recording, full-duplex operation
 - format conversions and resampling on the fly
 - mixing on the fly of multiple inputs of different formats
 - up to 16 channels, simplistic "routing" of channel ranges
 - more linear encodings (in raw and wav files)
the old behaviour is fully preserved if none of the new -i and -o
options are used.

code and fixes from jakemsr@@ and eric@@, suggestions by others.
ok "go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 1
@

