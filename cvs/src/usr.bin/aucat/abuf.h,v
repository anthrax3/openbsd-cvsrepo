head	1.26;
access;
symbols
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.8
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.4
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.12
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.10
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.6
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.4
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.23.0.4
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.26
date	2015.01.21.08.43.55;	author ratchov;	state Exp;
branches;
next	1.25;
commitid	SYQcoS9jhSKqSJDL;

1.25
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2011.11.15.20.41.54;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2010.10.21.18.57.42;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.09.16.49.48;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.27.11.51.20;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.13.20.48.49;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.23.17.38.15;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.16.16.30.22;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.10.23.25.37;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.09.16.26.07;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.03.22.55.34;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.03.22.25.13;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2008.10.26.08.49.43;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2008.08.14.15.25.16;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2008.08.14.09.46.36;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.14.09.44.15;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.14.09.39.16;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.02.17.06.36;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.02.17.03.25;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.25.21.16.37;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.23.07.15.46;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Simplify internals and rewrite file header parsing code:
- remove -M, -t, -w, -C, -x flags that don't make sense anymore
- make "-j off" the default (sndiod already does the job)
- don't limit the number of played/recorded files.
- add support for floating-point encoded files.
- add support for apple .aiff and sun/next .au files
@
text
@/*	$OpenBSD$	*/
/*
 * Copyright (c) 2008-2012 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifndef ABUF_H
#define ABUF_H

struct abuf {
	int start;	/* offset (frames) where stored data starts */
	int used;	/* frames stored in the buffer */
	int len;	/* total size of the buffer (frames) */
	unsigned char *data;
};

void abuf_init(struct abuf *, unsigned int);
void abuf_done(struct abuf *);
void abuf_log(struct abuf *);
unsigned char *abuf_rgetblk(struct abuf *, int *);
unsigned char *abuf_wgetblk(struct abuf *, int *);
void abuf_rdiscard(struct abuf *, int);
void abuf_wcommit(struct abuf *, int);

#endif /* !defined(ABUF_H) */
@


1.25
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.24 2011/11/15 20:41:54 ratchov Exp $	*/
d3 1
a3 1
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
a19 5
#include <sys/queue.h>

struct aproc;
struct aparams;

d21 4
a24 55
	LIST_ENTRY(abuf) ient;	/* reader's list of inputs entry */
	LIST_ENTRY(abuf) oent;	/* writer's list of outputs entry */

	/*
	 * fifo parameters
	 */
	unsigned int bpf;		/* bytes per frame */
	unsigned int cmin, cmax;	/* channel range of this buf */
	unsigned int start;		/* offset where data starts */
	unsigned int used;		/* valid data */
	unsigned int len;		/* size of the ring */
	struct aproc *rproc;		/* reader */
	struct aproc *wproc;		/* writer */
	struct abuf *duplex;		/* link to buffer of the other dir */
	unsigned int inuse;		/* in abuf_{flush,fill,run}() */
	unsigned int tickets;		/* max data to (if throttling) */

	/*
	 * Misc reader aproc-specific per-buffer parameters.
	 */
	union {
		struct {
			int weight;		/* dynamic range */	
			int maxweight;		/* max dynamic range allowed */
			unsigned int vol;	/* volume within the vol */
			unsigned int done;	/* frames ready */
			unsigned int xrun;	/* underrun policy */
			int drop;		/* to drop on next read */
		} mix;
		struct {
			unsigned int st;	/* MIDI running status */
			unsigned int used;	/* bytes used from ``msg'' */
			unsigned int idx;	/* actual MIDI message size */
			unsigned int len;	/* MIDI message length */
#define MIDI_MSGMAX	16			/* max size of MIDI msg */
			unsigned char msg[MIDI_MSGMAX];
		} midi;
	} r;

	/*
	 * Misc reader aproc-specific per-buffer parameters.
	 */
	union {
		struct {
			unsigned int todo;	/* frames to process */
		} mix;
		struct {
			unsigned int done;	/* frames copied */
			unsigned int xrun;	/* one of XRUN_XXX */
			int silence;		/* to add on next write */
		} sub;
		struct {
			struct abuf *owner;	/* current input stream */
		} midi;
	} w;
d27 7
a33 38
/*
 * the buffer contains at least one frame. This macro should
 * be used to check if the buffer can be flushed
 */
#define ABUF_ROK(b) ((b)->used > 0)

/*
 * there's room for at least one frame
 */
#define ABUF_WOK(b) ((b)->len - (b)->used > 0)

/*
 * the buffer is empty and has no writer anymore
 */
#define ABUF_EOF(b) (!ABUF_ROK(b) && (b)->wproc == NULL)

/*
 * the buffer has no reader anymore, note that it's not
 * enough the buffer to be disconnected, because it can
 * be not yet connected buffer (eg. socket play buffer)
 */
#define ABUF_HUP(b) (!ABUF_WOK(b) && (b)->rproc == NULL)

struct abuf *abuf_new(unsigned int, struct aparams *);
void abuf_del(struct abuf *);
void abuf_dbg(struct abuf *);
void abuf_clear(struct abuf *);
unsigned char *abuf_rgetblk(struct abuf *, unsigned int *, unsigned int);
unsigned char *abuf_wgetblk(struct abuf *, unsigned int *, unsigned int);
void abuf_rdiscard(struct abuf *, unsigned int);
void abuf_wcommit(struct abuf *, unsigned int);
int abuf_fill(struct abuf *);
int abuf_flush(struct abuf *);
void abuf_eof(struct abuf *);
void abuf_hup(struct abuf *);
void abuf_run(struct abuf *);
void abuf_ipos(struct abuf *, int);
void abuf_opos(struct abuf *, int);
@


1.24
log
@make midi 'owner' pointer per-output
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.23 2010/10/21 18:57:42 ratchov Exp $	*/
d32 10
a41 10
	unsigned bpf;		/* bytes per frame */
	unsigned cmin, cmax;	/* channel range of this buf */
	unsigned start;		/* offset where data starts */
	unsigned used;		/* valid data */
	unsigned len;		/* size of the ring */
	struct aproc *rproc;	/* reader */
	struct aproc *wproc;	/* writer */
	struct abuf *duplex;	/* link to buffer of the other direction */
	unsigned inuse;		/* in abuf_{flush,fill,run}() */
	unsigned tickets;	/* max data to (if throttling) */
d48 6
a53 6
			int weight;	/* dynamic range */	
			int maxweight;	/* max dynamic range allowed */
			unsigned vol;	/* volume within the dynamic range */
			unsigned done;	/* frames ready */
			unsigned xrun;	/* underrun policy */
			int drop;	/* frames to drop on next read */
d56 5
a60 5
			unsigned st;	/* MIDI running status */
			unsigned used;	/* bytes used from ``msg'' */
			unsigned idx;	/* actual MIDI message size */
			unsigned len;	/* MIDI message length */
#define MIDI_MSGMAX	16		/* max size of MIDI messaage */
d70 1
a70 1
			unsigned todo;	/* frames to process */
d73 3
a75 3
			unsigned done;	/* frames copied */
			unsigned xrun;	/* overrun policy, one of XRUN_XXX */
			int silence;	/* silence to add on next write */
d106 1
a106 1
struct abuf *abuf_new(unsigned, struct aparams *);
d110 4
a113 4
unsigned char *abuf_rgetblk(struct abuf *, unsigned *, unsigned);
unsigned char *abuf_wgetblk(struct abuf *, unsigned *, unsigned);
void abuf_rdiscard(struct abuf *, unsigned);
void abuf_wcommit(struct abuf *, unsigned);
@


1.23
log
@use MODE_xxx and XRUN_xxx macros everywhere, and zap corresponding
AMSG_xxx macros, which in turns simplifies the code
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.22 2010/04/06 20:07:01 ratchov Exp $	*/
d77 3
@


1.22
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.21 2010/04/03 17:59:17 ratchov Exp $	*/
a21 5
#define XRUN_IGNORE	0	/* on xrun silently insert/discard samples */
#define XRUN_SYNC	1	/* catchup to sync to the mix/sub */
#define XRUN_ERROR	2	/* xruns are errors, eof/hup buffer */
#define MIDI_MSGMAX	16	/* max size of MIDI messaage */

d60 1
d74 1
a74 1
			unsigned xrun;	/* overrun policy */
@


1.21
log
@backout last change, committed by mistake, sorry...
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.19 2009/10/09 16:49:48 ratchov Exp $	*/
a41 3
	unsigned abspos;	/* frame number of the start position */
	unsigned silence;	/* silence to insert on next write */
	unsigned drop;		/* bytes to drop on next read */
d56 1
a56 1
			unsigned done;	/* bytes ready */
d58 1
d74 1
a74 1
			unsigned todo;	/* bytes to process */
d77 1
a77 1
			unsigned done;	/* bytes copied */
d79 1
d88 1
a88 1
#define ABUF_ROK(b) ((b)->used >= (b)->bpf)
d93 1
a93 1
#define ABUF_WOK(b) ((b)->len - (b)->used >= (b)->bpf)
a105 12

/*
 * similar to !ABUF_WOK, but is used for file i/o, where
 * operation may not involve an integer number of frames
 */
#define ABUF_FULL(b) ((b)->used == (b)->len)

/*
 * same as !ABUF_ROK, but used for files, where
 * operations are byte orientated, not frame-oriented
 */
#define ABUF_EMPTY(b) ((b)->used == 0)
@


1.20
log
@doc fixes from jmc
@
text
@d42 3
d59 1
a59 1
			unsigned done;	/* frames ready */
a60 1
			int drop;	/* frames to drop on next read */
d76 1
a76 1
			unsigned todo;	/* frames to process */
d79 1
a79 1
			unsigned done;	/* frames copied */
a80 1
			int silence;	/* silence to add on next write */
d89 1
a89 1
#define ABUF_ROK(b) ((b)->used > 0)
d94 1
a94 1
#define ABUF_WOK(b) ((b)->len - (b)->used > 0)
d107 12
@


1.19
log
@Make abuf structure smaller:
 - put aproc-specific parameters into unions since they are never
   used together
 - remove constant ``data'' pointer always pointing the end of the
   abuf structure
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.18 2009/09/27 11:51:20 ratchov Exp $	*/
a41 3
	unsigned abspos;	/* frame number of the start position */
	unsigned silence;	/* silence to insert on next write */
	unsigned drop;		/* bytes to drop on next read */
d56 1
a56 1
			unsigned done;	/* bytes ready */
d58 1
d74 1
a74 1
			unsigned todo;	/* bytes to process */
d77 1
a77 1
			unsigned done;	/* bytes copied */
d79 1
d88 1
a88 1
#define ABUF_ROK(b) ((b)->used >= (b)->bpf)
d93 1
a93 1
#define ABUF_WOK(b) ((b)->len - (b)->used >= (b)->bpf)
a105 12

/*
 * similar to !ABUF_WOK, but is used for file i/o, where
 * operation may not involve an integer number of frames
 */
#define ABUF_FULL(b) ((b)->used == (b)->len)

/*
 * same as !ABUF_ROK, but used for files, where
 * operations are byte orientated, not frame-oriented
 */
#define ABUF_EMPTY(b) ((b)->used == 0)
@


1.18
log
@remove all debug traces
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.17 2009/07/25 08:44:27 ratchov Exp $	*/
d22 5
d31 2
a32 27
	/*
	 * Misc aproc-specific per-buffer parameters.
	 * since the buffer can connect any pair of aproc structure,
	 * each aproc must have it's own specific data. Thus we cannot
	 * use a union. The only exception is the xrun field, because
	 * there can be only one aproc that absorbs xruns in any
	 * intput->output path.
	 */
	int mixweight;		/* dynamic range for the source stream */
	int mixmaxweight;	/* max dynamic range allowed */
	unsigned mixvol;	/* volume within the dynamic range */
	unsigned mixodone;	/* bytes done on the dest stream */
	unsigned mixitodo;	/* bytes to do on the source stream */
	unsigned subidone;	/* bytes copied from the source stream */
#define XRUN_IGNORE	0	/* on xrun silently insert/discard samples */
#define XRUN_SYNC	1	/* catchup to sync to the mix/sub */
#define XRUN_ERROR	2	/* xruns are errors, eof/hup buffer */
	unsigned xrun;		/* common to mix and sub */
	LIST_ENTRY(abuf) ient;	/* for mix inputs list */
	LIST_ENTRY(abuf) oent;	/* for sub outputs list */
	unsigned mstatus;	/* MIDI running status */
	unsigned mindex;	/* current MIDI message size */
	unsigned mused;		/* bytes used from mdata */
	unsigned mlen;		/* MIDI message length */
#define MDATA_NMAX 16
	unsigned char mdata[MDATA_NMAX]; /* MIDI message data */
	unsigned mtickets;	/* max data to transmit (throttling) */
d49 34
a82 1
	unsigned char *data;	/* actual data (immediately following) */
@


1.17
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.16 2009/02/13 20:48:49 ratchov Exp $	*/
d109 1
@


1.16
log
@style and typos fixes from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.15 2009/01/23 17:38:15 ratchov Exp $	*/
d46 7
d84 1
a84 1
 * the buffer is empty and has no more writer
d89 3
a91 1
 * the buffer is empty and has no more writer
@


1.15
log
@spacing + typo fix from Matt Jibson <matt.jibson(at)gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.14 2008/11/16 16:30:22 ratchov Exp $	*/
a21 1
struct abuf;
d23 1
a23 1
struct aparam;
d30 1
a30 1
	 * use an union. The only exception is the xrun field, because
@


1.14
log
@Make clients inherit the volume parameter when the -v option is used in
server mode. It gives the maximum volume a client may have. This wastes
dynamic range, but allows volume to stay constant when other clients
connect or disconnect.
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.13 2008/11/10 23:25:37 ratchov Exp $	*/
d30 1
a30 1
	 * each aproc must have it's own specific data. Thus we cannot 
d32 1
a32 1
	 * there can be only one aproc that absorbs xruns in any 
d47 1
a47 1
	
@


1.13
log
@add a per-stream ``soft volume'' knob and the corresponding -v option.
The code will be useful later for the volume knob in the sndio API.
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.12 2008/11/09 16:26:07 ratchov Exp $	*/
d35 3
a37 2
	int mixweight;		/* volume of the source stream */
	unsigned mixvol;	/* volume in the range defined by wight */
@


1.12
log
@make aucat(1) stop automatically the audio(1) device if it's idle. This
way, when in server mode, it consumes no CPU if there are no clients.
Later, this will allow to start aucat(1) at session or system startup.
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.11 2008/11/03 22:55:34 ratchov Exp $	*/
d35 2
a36 1
	int mixivol;		/* volume of the source stream */
@


1.11
log
@rename mixxxx and subxxx fields of struct abuf to avoid confusion:
Add ``i'' to offsets in the input buffer and ``o'' to offsets
in the output buffer. This is necessary because input and output
use no more the same frame size.
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.10 2008/11/03 22:25:13 ratchov Exp $	*/
d99 1
@


1.10
log
@A small optimization: handle most N-channel <-> M-channel conversions
inside the mixer and the demultiplexer. This way, aucat will not
trigger the heavy conversion code when only channel conversions are
required. Cuts ~50% of the CPU usage on envy(4) devices, can improve
surround 4.0, 5.1 and 7.1 capable devices. No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.9 2008/10/26 08:49:43 ratchov Exp $	*/
d35 4
a38 4
	int mixvol;		/* input gain */
	unsigned mixdone;	/* input already processed */
	unsigned mixtodo;	/* output not yet complete */
	unsigned subdone;	/* output already processed */
@


1.9
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.7 2008/08/14 09:46:36 ratchov Exp $	*/
d24 1
d36 3
a38 3
	unsigned mixdone;	/* input of mixer */
	unsigned mixtodo;	/* output of mixer */
	unsigned subdone;	/* output if sub */
d50 1
d97 1
a97 1
struct abuf *abuf_new(unsigned, unsigned);
@


1.8
log
@fix comments suggested by eric@@, remove stupid DPRINTF()
@
text
@d44 1
a44 1

d57 2
d79 5
d101 2
a102 2
void abuf_fill(struct abuf *);
void abuf_flush(struct abuf *);
d106 2
@


1.7
log
@add a bytes counter to abuf structures to count the number of
bytes that entered the FIFO. The counter may overflow, so it
should be used with "modulo 2^32" arithmetic. The counter will
be used later to synchronize playback to record. No behaviour
change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.6 2008/08/14 09:44:15 ratchov Exp $	*/
d54 1
a54 1
	unsigned drop;		/* frames to drop on next read */
@


1.6
log
@move mix/sub underrun/overrun handling code and data in the
generic abuf structure, so it can reused. Required for an audio
server. No behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.5 2008/08/14 09:39:16 ratchov Exp $	*/
d52 1
@


1.5
log
@factor code that discards data from abuf strucure into a single
abuf_rdiscard() routine. Similarly add abuf_wcommit() routine for
writing. The purpose is to stop manupulating FIFO pointers in
various places outiside abuf.c, its too error prone.
No behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.4 2008/06/02 17:06:36 ratchov Exp $	*/
a36 1
	unsigned mixdrop;	/* frames mix_in() will discard */
a37 1
	unsigned subdrop;	/* silence frames sub_out() will insert */ 
d52 2
d56 1
a56 1
	unsigned char *data;	/* pointer to actual data (immediately following) */
@


1.4
log
@allow the user to choose the aucat behaviour when underruns/overruns
occur on a per-stream basis, using -Xx flags.  There are 3 possible
policies:

 - ignore : ignores underruns/overruns, for instance, this mode
   could be used for creating simple pipes with utilities; like in
   your last cdio diff.

 - sync : insert/discard samples in order to keep all streams in
   sync, useful for multi-tracker-like apps and/or to sync
   midi/video/whatever on audio streams (this was the previous
   behaviour)

 - error : if overruns/underruns occur, consider it as fatal error
   and kill the corresponding stream (without disturbing others).
   Useful, for reliable recordings (and/or debugging aucat
   itself:).

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.3 2008/06/02 17:03:25 ratchov Exp $	*/
d91 2
@


1.3
log
@Allows any input/output stream to underrun/overrun without disturbing
other streams. Beside making aucat usable with slow apps (eg. cdio),
this change will ease turning aucat into an audio server later

if one of the input buffers underruns, then silence is generated in
place of the missing samples. Later, as many samples are dropped in
order to maintain the stream in sync with the rest

if one of the output buffers overruns then newer samples are
discarded. Later silence is generated in order to maintain the
stream in sync with the rest.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.2 2008/05/25 21:16:37 ratchov Exp $	*/
d27 6
a32 1
	 * misc aproc-specific per-buffer parameters
d40 4
@


1.2
log
@give argument to LIST_END(), don't use variable lenght arrays as last
field of structures.

from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: abuf.h,v 1.1 2008/05/23 07:15:46 ratchov Exp $	*/
d32 1
d34 1
@


1.1
log
@add support for:
 - recording, full-duplex operation
 - format conversions and resampling on the fly
 - mixing on the fly of multiple inputs of different formats
 - up to 16 channels, simplistic "routing" of channel ranges
 - more linear encodings (in raw and wav files)
the old behaviour is fully preserved if none of the new -i and -o
options are used.

code and fixes from jakemsr@@ and eric@@, suggestions by others.
ok "go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 1
	unsigned char data[];	/* actual data */
@

