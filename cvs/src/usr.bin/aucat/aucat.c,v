head	1.170;
access;
symbols
	OPENBSD_6_2_BASE:1.170
	OPENBSD_6_1:1.169.0.4
	OPENBSD_6_1_BASE:1.169
	OPENBSD_6_0:1.164.0.2
	OPENBSD_6_0_BASE:1.164
	OPENBSD_5_9:1.152.0.2
	OPENBSD_5_9_BASE:1.152
	OPENBSD_5_8:1.148.0.4
	OPENBSD_5_8_BASE:1.148
	OPENBSD_5_7:1.147.0.2
	OPENBSD_5_7_BASE:1.147
	OPENBSD_5_6:1.144.0.6
	OPENBSD_5_6_BASE:1.144
	OPENBSD_5_5:1.144.0.4
	OPENBSD_5_5_BASE:1.144
	OPENBSD_5_4:1.141.0.4
	OPENBSD_5_4_BASE:1.141
	OPENBSD_5_3:1.141.0.2
	OPENBSD_5_3_BASE:1.141
	OPENBSD_5_2:1.137.0.2
	OPENBSD_5_2_BASE:1.137
	OPENBSD_5_1_BASE:1.133
	OPENBSD_5_1:1.133.0.2
	OPENBSD_5_0:1.119.0.2
	OPENBSD_5_0_BASE:1.119
	OPENBSD_4_9:1.107.0.2
	OPENBSD_4_9_BASE:1.107
	OPENBSD_4_8:1.102.0.2
	OPENBSD_4_8_BASE:1.102
	OPENBSD_4_7:1.80.0.2
	OPENBSD_4_7_BASE:1.80
	OPENBSD_4_6:1.60.0.4
	OPENBSD_4_6_BASE:1.60
	OPENBSD_4_5:1.58.0.2
	OPENBSD_4_5_BASE:1.58
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.10
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.170
date	2017.07.20.10.20.53;	author ratchov;	state Exp;
branches;
next	1.169;
commitid	a4zBVz73rs9d8hTN;

1.169
date	2017.01.03.07.33.22;	author ratchov;	state Exp;
branches;
next	1.168;
commitid	jtT5MKNlfvRYBwMA;

1.168
date	2017.01.03.07.29.20;	author ratchov;	state Exp;
branches;
next	1.167;
commitid	tqmVnjwThvtKlV3s;

1.167
date	2016.09.30.09.14.44;	author ratchov;	state Exp;
branches;
next	1.166;
commitid	rLa1VaOF5Mspjd6g;

1.166
date	2016.09.30.08.43.23;	author ratchov;	state Exp;
branches;
next	1.165;
commitid	b4CFwzFxQMLhrOkt;

1.165
date	2016.09.27.07.02.28;	author ratchov;	state Exp;
branches;
next	1.164;
commitid	79VkjVVHCUTnheM0;

1.164
date	2016.06.07.06.26.24;	author ratchov;	state Exp;
branches;
next	1.163;
commitid	BbbvMARVpsdeNJqE;

1.163
date	2016.06.07.06.11.32;	author ratchov;	state Exp;
branches;
next	1.162;
commitid	QLXQbFr1hZrn4UqM;

1.162
date	2016.06.02.05.29.35;	author ratchov;	state Exp;
branches;
next	1.161;
commitid	CBukLYQWgmODjcoy;

1.161
date	2016.06.02.05.07.50;	author ratchov;	state Exp;
branches;
next	1.160;
commitid	qhwfohB39wgACgUK;

1.160
date	2016.05.31.17.28.10;	author ratchov;	state Exp;
branches;
next	1.159;
commitid	J0yb1B2BrEcq9fFS;

1.159
date	2016.05.31.07.31.45;	author ratchov;	state Exp;
branches;
next	1.158;
commitid	IVqjVUcDs4UaUMTS;

1.158
date	2016.05.28.07.28.50;	author ratchov;	state Exp;
branches;
next	1.157;
commitid	dYYFsmr8KIKfsn6v;

1.157
date	2016.05.27.16.18.59;	author ratchov;	state Exp;
branches;
next	1.156;
commitid	aEreEWUv0B95BKoY;

1.156
date	2016.05.27.16.02.54;	author ratchov;	state Exp;
branches;
next	1.155;
commitid	KQfNYhO5L0mqMxuV;

1.155
date	2016.05.27.15.46.41;	author ratchov;	state Exp;
branches;
next	1.154;
commitid	EEIMlPbDDqhcNn0t;

1.154
date	2016.05.27.15.38.27;	author ratchov;	state Exp;
branches;
next	1.153;
commitid	OfV5uiPuEn2WjCG3;

1.153
date	2016.05.26.06.17.31;	author ratchov;	state Exp;
branches;
next	1.152;
commitid	olLospeMe26a4NJv;

1.152
date	2016.01.29.16.24.22;	author ratchov;	state Exp;
branches;
next	1.151;
commitid	qzg85FBnSAP7BWdp;

1.151
date	2016.01.10.11.06.44;	author ratchov;	state Exp;
branches;
next	1.150;
commitid	Mp9fmG748uiNux1y;

1.150
date	2015.11.09.14.44.23;	author mmcc;	state Exp;
branches;
next	1.149;
commitid	l5KOsRzgoVRRaPAL;

1.149
date	2015.08.27.07.25.56;	author ratchov;	state Exp;
branches;
next	1.148;
commitid	tcwZ1xjHaUVcVyNa;

1.148
date	2015.05.16.19.27.53;	author ratchov;	state Exp;
branches;
next	1.147;
commitid	Kdo13BniYXDkreyq;

1.147
date	2015.01.21.09.21.05;	author jmc;	state Exp;
branches;
next	1.146;
commitid	QiWW890QTGETe8Ep;

1.146
date	2015.01.21.08.43.55;	author ratchov;	state Exp;
branches;
next	1.145;
commitid	SYQcoS9jhSKqSJDL;

1.145
date	2015.01.16.06.40.05;	author deraadt;	state Exp;
branches;
next	1.144;
commitid	Uu5nFG3wCl0LACBb;

1.144
date	2013.11.18.17.51.59;	author ratchov;	state Exp;
branches;
next	1.143;

1.143
date	2013.11.18.17.37.45;	author ratchov;	state Exp;
branches;
next	1.142;

1.142
date	2013.11.12.06.47.34;	author ratchov;	state Exp;
branches;
next	1.141;

1.141
date	2012.12.03.15.35.25;	author ratchov;	state Exp;
branches;
next	1.140;

1.140
date	2012.11.23.07.15.47;	author ratchov;	state Exp;
branches;
next	1.139;

1.139
date	2012.10.27.08.39.03;	author ratchov;	state Exp;
branches;
next	1.138;

1.138
date	2012.10.27.08.36.36;	author ratchov;	state Exp;
branches;
next	1.137;

1.137
date	2012.06.27.06.53.13;	author ratchov;	state Exp;
branches;
next	1.136;

1.136
date	2012.06.19.20.03.29;	author ratchov;	state Exp;
branches;
next	1.135;

1.135
date	2012.05.23.19.25.11;	author ratchov;	state Exp;
branches;
next	1.134;

1.134
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.133;

1.133
date	2012.02.09.18.33.36;	author ratchov;	state Exp;
branches;
next	1.132;

1.132
date	2012.01.26.09.07.03;	author ratchov;	state Exp;
branches;
next	1.131;

1.131
date	2012.01.10.08.04.19;	author ratchov;	state Exp;
branches;
next	1.130;

1.130
date	2011.12.09.22.56.35;	author ratchov;	state Exp;
branches;
next	1.129;

1.129
date	2011.12.09.14.36.42;	author ratchov;	state Exp;
branches;
next	1.128;

1.128
date	2011.12.02.12.45.29;	author ratchov;	state Exp;
branches;
next	1.127;

1.127
date	2011.12.02.10.34.50;	author ratchov;	state Exp;
branches;
next	1.126;

1.126
date	2011.11.20.22.54.51;	author ratchov;	state Exp;
branches;
next	1.125;

1.125
date	2011.11.15.08.05.22;	author ratchov;	state Exp;
branches;
next	1.124;

1.124
date	2011.10.18.21.04.26;	author ratchov;	state Exp;
branches;
next	1.123;

1.123
date	2011.10.18.18.40.32;	author ratchov;	state Exp;
branches;
next	1.122;

1.122
date	2011.10.17.21.09.11;	author ratchov;	state Exp;
branches;
next	1.121;

1.121
date	2011.10.12.12.16.10;	author jmc;	state Exp;
branches;
next	1.120;

1.120
date	2011.10.12.07.20.03;	author ratchov;	state Exp;
branches;
next	1.119;

1.119
date	2011.06.29.07.39.02;	author ratchov;	state Exp;
branches;
next	1.118;

1.118
date	2011.06.20.20.18.44;	author ratchov;	state Exp;
branches;
next	1.117;

1.117
date	2011.06.03.17.04.47;	author ratchov;	state Exp;
branches;
next	1.116;

1.116
date	2011.06.03.10.05.27;	author ratchov;	state Exp;
branches;
next	1.115;

1.115
date	2011.05.26.07.18.40;	author ratchov;	state Exp;
branches;
next	1.114;

1.114
date	2011.05.10.06.26.34;	author ratchov;	state Exp;
branches;
next	1.113;

1.113
date	2011.04.28.06.19.57;	author ratchov;	state Exp;
branches;
next	1.112;

1.112
date	2011.04.27.21.20.36;	author ratchov;	state Exp;
branches;
next	1.111;

1.111
date	2011.04.27.17.58.43;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2011.04.19.00.02.28;	author ratchov;	state Exp;
branches;
next	1.109;

1.109
date	2011.04.16.11.51.48;	author ratchov;	state Exp;
branches;
next	1.108;

1.108
date	2011.03.17.07.55.35;	author ratchov;	state Exp;
branches;
next	1.107;

1.107
date	2010.11.05.16.09.50;	author ratchov;	state Exp;
branches;
next	1.106;

1.106
date	2010.10.21.18.57.42;	author ratchov;	state Exp;
branches;
next	1.105;

1.105
date	2010.09.08.22.07.26;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2010.08.20.06.56.54;	author ratchov;	state Exp;
branches;
next	1.103;

1.103
date	2010.08.19.06.31.06;	author ratchov;	state Exp;
branches;
next	1.102;

1.102
date	2010.07.31.08.48.01;	author ratchov;	state Exp;
branches;
next	1.101;

1.101
date	2010.07.10.12.28.17;	author ratchov;	state Exp;
branches;
next	1.100;

1.100
date	2010.07.10.11.56.28;	author ratchov;	state Exp;
branches;
next	1.99;

1.99
date	2010.07.06.10.45.01;	author jmc;	state Exp;
branches;
next	1.98;

1.98
date	2010.07.06.01.12.45;	author ratchov;	state Exp;
branches;
next	1.97;

1.97
date	2010.06.29.06.48.39;	author jakemsr;	state Exp;
branches;
next	1.96;

1.96
date	2010.06.25.07.32.05;	author ratchov;	state Exp;
branches;
next	1.95;

1.95
date	2010.06.20.11.32.54;	author ratchov;	state Exp;
branches;
next	1.94;

1.94
date	2010.06.05.16.00.52;	author ratchov;	state Exp;
branches;
next	1.93;

1.93
date	2010.06.05.12.45.48;	author ratchov;	state Exp;
branches;
next	1.92;

1.92
date	2010.06.04.06.15.28;	author ratchov;	state Exp;
branches;
next	1.91;

1.91
date	2010.05.08.15.35.45;	author ratchov;	state Exp;
branches;
next	1.90;

1.90
date	2010.05.02.11.54.26;	author ratchov;	state Exp;
branches;
next	1.89;

1.89
date	2010.05.02.11.12.31;	author ratchov;	state Exp;
branches;
next	1.88;

1.88
date	2010.04.24.14.33.46;	author ratchov;	state Exp;
branches;
next	1.87;

1.87
date	2010.04.24.06.18.23;	author ratchov;	state Exp;
branches;
next	1.86;

1.86
date	2010.04.22.17.43.30;	author ratchov;	state Exp;
branches;
next	1.85;

1.85
date	2010.04.21.06.15.02;	author ratchov;	state Exp;
branches;
next	1.84;

1.84
date	2010.04.21.06.13.07;	author ratchov;	state Exp;
branches;
next	1.83;

1.83
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.82;

1.82
date	2010.04.03.17.59.17;	author ratchov;	state Exp;
branches;
next	1.81;

1.81
date	2010.04.03.17.40.33;	author ratchov;	state Exp;
branches;
next	1.80;

1.80
date	2010.01.14.17.43.55;	author ratchov;	state Exp;
branches;
next	1.79;

1.79
date	2010.01.11.13.06.32;	author ratchov;	state Exp;
branches;
next	1.78;

1.78
date	2010.01.10.21.47.41;	author ratchov;	state Exp;
branches;
next	1.77;

1.77
date	2010.01.05.10.18.12;	author ratchov;	state Exp;
branches;
next	1.76;

1.76
date	2009.11.21.14.21.08;	author ratchov;	state Exp;
branches;
next	1.75;

1.75
date	2009.11.21.10.24.13;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2009.11.03.21.31.37;	author ratchov;	state Exp;
branches;
next	1.73;

1.73
date	2009.10.27.22.21.37;	author ratchov;	state Exp;
branches;
next	1.72;

1.72
date	2009.10.10.13.55.37;	author ratchov;	state Exp;
branches;
next	1.71;

1.71
date	2009.10.10.12.43.09;	author ratchov;	state Exp;
branches;
next	1.70;

1.70
date	2009.10.10.11.58.41;	author ratchov;	state Exp;
branches;
next	1.69;

1.69
date	2009.10.05.07.05.24;	author ratchov;	state Exp;
branches;
next	1.68;

1.68
date	2009.09.27.11.51.20;	author ratchov;	state Exp;
branches;
next	1.67;

1.67
date	2009.08.26.06.33.52;	author jmc;	state Exp;
branches;
next	1.66;

1.66
date	2009.08.19.18.29.34;	author ratchov;	state Exp;
branches;
next	1.65;

1.65
date	2009.08.19.05.54.15;	author ratchov;	state Exp;
branches;
next	1.64;

1.64
date	2009.08.17.16.17.46;	author ratchov;	state Exp;
branches;
next	1.63;

1.63
date	2009.08.17.15.07.49;	author ratchov;	state Exp;
branches;
next	1.62;

1.62
date	2009.07.25.10.52.18;	author ratchov;	state Exp;
branches;
next	1.61;

1.61
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	1.60;

1.60
date	2009.04.27.18.09.34;	author ratchov;	state Exp;
branches;
next	1.59;

1.59
date	2009.03.17.21.26.44;	author jmc;	state Exp;
branches;
next	1.58;

1.58
date	2009.02.06.08.26.34;	author ratchov;	state Exp;
branches;
next	1.57;

1.57
date	2009.02.04.20.35.14;	author ratchov;	state Exp;
branches;
next	1.56;

1.56
date	2009.02.04.08.00.33;	author ratchov;	state Exp;
branches;
next	1.55;

1.55
date	2009.02.03.19.44.58;	author ratchov;	state Exp;
branches;
next	1.54;

1.54
date	2009.01.25.17.07.39;	author ratchov;	state Exp;
branches;
next	1.53;

1.53
date	2009.01.23.17.52.13;	author ratchov;	state Exp;
branches;
next	1.52;

1.52
date	2009.01.23.17.38.15;	author ratchov;	state Exp;
branches;
next	1.51;

1.51
date	2009.01.10.20.02.28;	author ratchov;	state Exp;
branches;
next	1.50;

1.50
date	2008.12.29.17.59.08;	author ratchov;	state Exp;
branches;
next	1.49;

1.49
date	2008.12.26.13.29.31;	author ratchov;	state Exp;
branches;
next	1.48;

1.48
date	2008.12.07.17.10.41;	author ratchov;	state Exp;
branches;
next	1.47;

1.47
date	2008.11.23.12.29.32;	author ratchov;	state Exp;
branches;
next	1.46;

1.46
date	2008.11.20.10.10.01;	author ratchov;	state Exp;
branches;
next	1.45;

1.45
date	2008.11.17.09.40.09;	author jmc;	state Exp;
branches;
next	1.44;

1.44
date	2008.11.17.07.36.43;	author jmc;	state Exp;
branches;
next	1.43;

1.43
date	2008.11.17.07.04.13;	author ratchov;	state Exp;
branches;
next	1.42;

1.42
date	2008.11.16.20.44.03;	author ratchov;	state Exp;
branches;
next	1.41;

1.41
date	2008.11.16.18.34.56;	author ratchov;	state Exp;
branches;
next	1.40;

1.40
date	2008.11.16.16.30.22;	author ratchov;	state Exp;
branches;
next	1.39;

1.39
date	2008.11.12.19.36.39;	author ratchov;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.11.21.26.21;	author ratchov;	state Exp;
branches;
next	1.37;

1.37
date	2008.11.11.13.12.03;	author ratchov;	state Exp;
branches;
next	1.36;

1.36
date	2008.11.11.12.56.02;	author ratchov;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.10.23.25.37;	author ratchov;	state Exp;
branches;
next	1.34;

1.34
date	2008.11.09.16.26.07;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2008.11.08.10.40.52;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2008.11.07.21.01.15;	author ratchov;	state Exp;
branches;
next	1.31;

1.31
date	2008.11.03.22.25.13;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.26.12.38.38;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2008.10.26.11.55.22;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2008.10.26.08.49.43;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2008.08.25.11.56.12;	author sobrado;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.14.09.58.55;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.02.17.09.51;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.02.17.08.51;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.02.17.08.11;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.02.17.06.36;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.02.17.05.45;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.02.17.05.12;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.02.17.04.32;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.26.08.32.11;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.26.07.56.17;	author jakemsr;	state Exp;
branches;
next	1.16;

1.16
date	2008.05.23.12.56.27;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.23.07.15.46;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.13.22.39.29;	author jakemsr;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.20.23.35.15;	author uwe;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.20.06.45.10;	author steven;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.20.04.21.42;	author jaredy;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.13.19.19.44;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.20.21.10.19;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.10.00.06.50;	author david;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.02.21.04.09;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.10.22.20.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.09.00.45.38;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.01.19.54.36;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.05.19.00.51;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	97.01.03.21.05.28;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	97.01.02.22.12.27;	author kstailey;	state Exp;
branches;
next	;


desc
@@


1.170
log
@Fix integer overflow that would causes >12 hours files
to not properly relocate. Found with coverity.
@
text
@/*
 * Copyright (c) 2008-2014 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <errno.h>
#include <limits.h>
#include <poll.h>
#include <signal.h>
#include <sndio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "abuf.h"
#include "afile.h"
#include "dsp.h"
#include "sysex.h"
#include "utils.h"

/*
 * masks to extract command and channel of status byte
 */
#define MIDI_CMDMASK	0xf0
#define MIDI_CHANMASK	0x0f

/*
 * MIDI status bytes of voice messages
 */
#define MIDI_NOFF	0x80		/* note off */
#define MIDI_NON	0x90		/* note on */
#define MIDI_KAT	0xa0		/* key after touch */
#define MIDI_CTL	0xb0		/* controller */
#define MIDI_PC		0xc0		/* program change */
#define MIDI_CAT	0xd0		/* channel after touch */
#define MIDI_BEND	0xe0		/* pitch bend */
#define MIDI_ACK	0xfe		/* active sensing message */

/*
 * MIDI controller numbers
 */
#define MIDI_CTL_VOL	7

/*
 * Max coarse value
 */
#define MIDI_MAXCTL	127

/*
 * MIDI status bytes for sysex
 */
#define MIDI_SX_START	0xf0
#define MIDI_SX_STOP	0xf7

/*
 * audio device defaults
 */
#define DEFAULT_RATE		48000
#define DEFAULT_BUFSZ_MS	200

struct slot {
	struct slot *next;		/* next on the play/rec list */
	int vol;			/* dynamic range */
	int volctl;			/* volume in the 0..127 range */
	struct abuf buf;		/* file i/o buffer */
	int bpf;			/* bytes per frame */
	int cmin, cmax;			/* file channel range */
	struct cmap cmap;		/* channel mapper state */
	struct resamp resamp;		/* resampler state */
	struct conv conv;		/* format encoder state */
	int join;			/* channel join factor */
	int expand;			/* channel expand factor */
	void *resampbuf, *convbuf;	/* conversion tmp buffers */
	int dup;			/* mono-to-stereo and alike */
	int round;			/* slot-side block size */
	int mode;			/* MODE_{PLAY,REC} */
#define SLOT_CFG	0		/* buffers not allocated yet */
#define SLOT_INIT	1		/* not trying to do anything */
#define SLOT_RUN	2		/* playing/recording */
#define SLOT_STOP	3		/* draining (play only) */
	int pstate;			/* one of above */
	long long skip;			/* frames to skip at the beginning */
	long long pos;			/* start position (at device rate) */
	struct afile afile;		/* file desc & friends */
};

/*
 * device properties
 */
unsigned int dev_mode;			/* bitmap of SIO_{PLAY,REC} */
unsigned int dev_bufsz;			/* device buffer size */
unsigned int dev_round;			/* device block size */
int dev_rate;				/* device sample rate (Hz) */
unsigned int dev_pchan, dev_rchan;	/* play & rec channels count */
adata_t *dev_pbuf, *dev_rbuf;		/* play & rec buffers */
long long dev_pos;			/* last MMC position in frames */
#define DEV_STOP	0		/* stopped */
#define DEV_START	1		/* started */
unsigned int dev_pstate;		/* one of above */
char *dev_name;				/* device sndio(7) name */
char *dev_port;				/* control port sndio(7) name */
struct sio_hdl *dev_sh;			/* device handle */
struct mio_hdl *dev_mh;			/* MIDI control port handle */
unsigned int dev_volctl = MIDI_MAXCTL;	/* master volume */

/*
 * MIDI parser state
 */
#define MIDI_MSGMAX	32		/* max size of MIDI msg */
unsigned char dev_msg[MIDI_MSGMAX];	/* parsed input message */
unsigned int dev_mst;			/* input MIDI running status */
unsigned int dev_mused;			/* bytes used in ``msg'' */
unsigned int dev_midx;			/* current ``msg'' size */
unsigned int dev_mlen;			/* expected ``msg'' length */
unsigned int dev_prime;			/* blocks to write to start */

unsigned int log_level = 1;
volatile sig_atomic_t quit_flag = 0;
struct slot *slot_list = NULL;

/*
 * length of voice and common MIDI messages (status byte included)
 */
unsigned int voice_len[] = { 3, 3, 3, 3, 2, 2, 3 };
unsigned int common_len[] = { 0, 2, 3, 2, 0, 0, 1, 1 };

char usagestr[] = "usage: aucat [-dn] [-b size] "
    "[-c min:max] [-e enc] [-f device] [-g position]\n\t"
    "[-h fmt] [-i file] [-j flag] [-o file] [-p position] [-q port]\n\t"
    "[-r rate] [-v volume]\n";

static void
slot_log(struct slot *s)
{
#ifdef DEBUG
	static char *pstates[] = {
		"cfg", "ini", "run", "stp"
	};
#endif
	log_puts(s->afile.path);
#ifdef DEBUG
	if (log_level >= 3) {
		log_puts(",pst=");
		log_puts(pstates[s->pstate]);
	}
#endif
}

static void
slot_flush(struct slot *s)
{
	int count, n;
	unsigned char *data;

	for (;;) {
		data = abuf_rgetblk(&s->buf, &count);
		if (count == 0)
			break;
		n = afile_write(&s->afile, data, count);
		if (n == 0) {
			slot_log(s);
			log_puts(": can't write, disabled\n");
			s->pstate = SLOT_INIT;
			return;
		}
		abuf_rdiscard(&s->buf, n);
	}
}

static void
slot_fill(struct slot *s)
{
	int count, n;
	unsigned char *data;

	for (;;) {
		data = abuf_wgetblk(&s->buf, &count);
		if (count == 0)
			break;
		n = afile_read(&s->afile, data, count);
		if (n == 0) {
#ifdef DEBUG
			if (log_level >= 3) {
				slot_log(s);
				log_puts(": eof reached, stopping\n");
			}
#endif
			s->pstate = SLOT_STOP;
			break;
		}
		abuf_wcommit(&s->buf, n);
	}
}

static int
slot_new(char *path, int mode, struct aparams *par, int hdr,
    int cmin, int cmax, int rate, int dup, int vol, long long pos)
{
	struct slot *s;

	s = xmalloc(sizeof(struct slot));
	if (!afile_open(&s->afile, path, hdr,
		mode == SIO_PLAY ? AFILE_FREAD : AFILE_FWRITE,
		par, rate, cmax - cmin + 1)) {
		xfree(s);
		return 0;
	}
	s->cmin = cmin;
	s->cmax = cmin + s->afile.nch - 1;
	s->dup = dup;
	s->vol = MIDI_TO_ADATA(vol);
	s->mode = mode;
	s->pstate = SLOT_CFG;
	s->pos = pos;
	if (log_level >= 2) {
		slot_log(s);
		log_puts(": ");
		log_puts(s->mode == SIO_PLAY ? "play" : "rec");
		log_puts(", chan ");
		log_putu(s->cmin);
		log_puts(":");
		log_putu(s->cmax);
		log_puts(", ");
		log_putu(s->afile.rate);
		log_puts("Hz, ");
		switch (s->afile.fmt) {
		case AFILE_FMT_PCM:
			aparams_log(&s->afile.par);
			break;
		case AFILE_FMT_ULAW:
			log_puts("ulaw");
			break;
		case AFILE_FMT_ALAW:
			log_puts("alaw");
			break;
		case AFILE_FMT_FLOAT:
			log_puts("f32le");
			break;
		}
		if (s->mode == SIO_PLAY && s->afile.endpos >= 0) {
			log_puts(", bytes ");
			log_puti(s->afile.startpos);
			log_puts("..");
			log_puti(s->afile.endpos);
		}
		if (s->mode == SIO_PLAY) {
			log_puts(", vol ");
			log_puti(s->vol);
		}
		log_puts("\n");
	}
	s->next = slot_list;
	slot_list = s;
	return 1;
}

static void
slot_init(struct slot *s)
{
	unsigned int slot_nch, bufsz;

#ifdef DEBUG
	if (s->pstate != SLOT_CFG) {
		slot_log(s);
		log_puts(": slot_init: wrong state\n");
		panic();
	}
#endif
	s->bpf = s->afile.par.bps * (s->cmax - s->cmin + 1);
	s->round = (dev_round * s->afile.rate + dev_rate - 1) / dev_rate;

	bufsz = s->round * (dev_bufsz / dev_round);
	bufsz -= bufsz % s->round;
	if (bufsz == 0)
		bufsz = s->round;
	abuf_init(&s->buf, bufsz * s->bpf);
#ifdef DEBUG
	if (log_level >= 3) {
		slot_log(s);
		log_puts(": allocated ");
		log_putu(bufsz);
		log_puts(" frame buffer\n");
	}
#endif

	slot_nch = s->cmax - s->cmin + 1;
	s->convbuf = NULL;
	s->resampbuf = NULL;
	s->join = 1;
	s->expand = 1;
	if (s->mode & SIO_PLAY) {
		if (s->dup) {
			if (dev_pchan > slot_nch)
				s->expand = dev_pchan / slot_nch;
			else if (dev_pchan < slot_nch)
				s->join = slot_nch / dev_pchan;
		}
		cmap_init(&s->cmap,
		    s->cmin, s->cmax,
		    s->cmin, s->cmax,
		    0, dev_pchan - 1,
		    0, dev_pchan - 1);
		if (s->afile.fmt != AFILE_FMT_PCM ||
		    !aparams_native(&s->afile.par)) {
			dec_init(&s->conv, &s->afile.par, slot_nch);
			s->convbuf =
			    xmalloc(s->round * slot_nch * sizeof(adata_t));
		}
		if (s->afile.rate != dev_rate) {
			resamp_init(&s->resamp, s->afile.rate, dev_rate,
			    slot_nch);
			s->resampbuf =
			    xmalloc(dev_round * slot_nch * sizeof(adata_t));
		}
	}
	if (s->mode & SIO_REC) {
		if (s->dup) {
			if (dev_rchan > slot_nch)
				s->join = dev_rchan / slot_nch;
			else if (dev_rchan < slot_nch)
				s->expand = slot_nch / dev_rchan;
		}
		cmap_init(&s->cmap,
		    0, dev_rchan - 1,
		    0, dev_rchan - 1,
		    s->cmin, s->cmax,
		    s->cmin, s->cmax);
		if (s->afile.rate != dev_rate) {
			resamp_init(&s->resamp, dev_rate, s->afile.rate,
			    slot_nch);
			s->resampbuf =
			    xmalloc(dev_round * slot_nch * sizeof(adata_t));
		}
		if (!aparams_native(&s->afile.par)) {
			enc_init(&s->conv, &s->afile.par, slot_nch);
			s->convbuf =
			    xmalloc(s->round * slot_nch * sizeof(adata_t));
		}
	}
	s->pstate = SLOT_INIT;
#ifdef DEBUG
	if (log_level >= 3) {
		slot_log(s);
		log_puts(": chain initialized\n");
	}
#endif
}

static void
slot_start(struct slot *s, long long pos)
{
#ifdef DEBUG
	if (s->pstate != SLOT_INIT) {
		slot_log(s);
		log_puts(": slot_start: wrong state\n");
		panic();
	}
#endif
	pos -= s->pos;
	if (pos < 0) {
		s->skip = -pos;
		pos = 0;
	} else
		s->skip = 0;

	/*
	 * convert pos to slot sample rate
	 *
	 * At this stage, we could adjust s->resamp.diff to get
	 * sub-frame accuracy.
	 */
	pos = pos * s->afile.rate / dev_rate;

	if (!afile_seek(&s->afile, pos * s->bpf)) {
		s->pstate = SLOT_INIT;
		return;
	}
	s->pstate = SLOT_RUN;
	if (s->mode & SIO_PLAY)
		slot_fill(s);
#ifdef DEBUG
	if (log_level >= 2) {
		slot_log(s);
		log_puts(": started\n");
	}
#endif
}

static void
slot_stop(struct slot *s)
{
	if (s->pstate == SLOT_INIT)
		return;
	if (s->mode & SIO_REC)
		slot_flush(s);
	if (s->mode & SIO_PLAY)
		s->buf.used = s->buf.start = 0;
	s->pstate = SLOT_INIT;
#ifdef DEBUG
	if (log_level >= 2) {
		slot_log(s);
		log_puts(": stopped\n");
	}
#endif
}

static void
slot_del(struct slot *s)
{
	struct slot **ps;

	if (s->pstate != SLOT_CFG) {
		slot_stop(s);
		afile_close(&s->afile);
#ifdef DEBUG
		if (log_level >= 3) {
			slot_log(s);
			log_puts(": closed\n");
		}
#endif
		abuf_done(&s->buf);
		if (s->resampbuf)
			xfree(s->resampbuf);
		if (s->convbuf)
			xfree(s->convbuf);
	}
	for (ps = &slot_list; *ps != s; ps = &(*ps)->next)
		; /* nothing */
	*ps = s->next;
	xfree(s);
}

static void
slot_getcnt(struct slot *s, int *icnt, int *ocnt)
{
	int cnt;

	if (s->resampbuf)
		resamp_getcnt(&s->resamp, icnt, ocnt);
	else {
		cnt = (*icnt < *ocnt) ? *icnt : *ocnt;
		*icnt = cnt;
		*ocnt = cnt;
	}
}

static void
play_filt_resamp(struct slot *s, void *res_in, void *out, int icnt, int ocnt)
{
	int i, offs, vol, nch;
	void *in;

	if (s->resampbuf) {
		resamp_do(&s->resamp, res_in, s->resampbuf, icnt, ocnt);
		in = s->resampbuf;
	} else
		in = res_in;

	nch = s->cmap.nch;
	vol = s->vol / s->join; /* XXX */
	cmap_add(&s->cmap, in, out, vol, ocnt);

	offs = 0;
	for (i = s->join - 1; i > 0; i--) {
		offs += nch;
		cmap_add(&s->cmap, (adata_t *)in + offs, out, vol, ocnt);
	}
	offs = 0;
	for (i = s->expand - 1; i > 0; i--) {
		offs += nch;
		cmap_add(&s->cmap, in, (adata_t *)out + offs, vol, ocnt);
	}
}

static void
play_filt_dec(struct slot *s, void *in, void *out, int icnt, int ocnt)
{
	void *tmp;

	tmp = s->convbuf;
	if (tmp) {
		switch (s->afile.fmt) {
		case AFILE_FMT_PCM:
			dec_do(&s->conv, in, tmp, icnt);
			break;
		case AFILE_FMT_ULAW:
			dec_do_ulaw(&s->conv, in, tmp, icnt, 0);
			break;
		case AFILE_FMT_ALAW:
			dec_do_ulaw(&s->conv, in, tmp, icnt, 1);
			break;
		case AFILE_FMT_FLOAT:
			dec_do_float(&s->conv, in, tmp, icnt);
			break;
		}
	} else
		tmp = in;
	play_filt_resamp(s, tmp, out, icnt, ocnt);
}

/*
 * Mix as many as possible frames (but not more than a block) from the
 * slot buffer to the given location. Return the number of frames mixed
 * in the output buffer
 */
static int
slot_mix_badd(struct slot *s, adata_t *odata)
{
	adata_t *idata;
	int len, icnt, ocnt, otodo, odone;

	odone = 0;
	otodo = dev_round;
	if (s->skip > 0) {		
		ocnt = otodo;
		if (ocnt > s->skip)
			ocnt = s->skip;
		s->skip -= ocnt;
		odata += dev_pchan * ocnt;
		otodo -= ocnt;
		odone += ocnt;
	}
	while (otodo > 0) {
		idata = (adata_t *)abuf_rgetblk(&s->buf, &len);
		icnt = len / s->bpf;
		if (icnt > s->round)
			icnt = s->round;
		ocnt = otodo;
		slot_getcnt(s, &icnt, &ocnt);
		if (icnt == 0)
			break;
		play_filt_dec(s, idata, odata, icnt, ocnt);
		abuf_rdiscard(&s->buf, icnt * s->bpf);
		otodo -= ocnt;
		odone += ocnt;
		odata += ocnt * dev_pchan;
	}
	return odone;
}

static void
rec_filt_resamp(struct slot *s, void *in, void *res_out, int icnt, int ocnt)
{
	int i, vol, offs, nch;
	void *out = res_out;

	out = (s->resampbuf) ? s->resampbuf : res_out;

	nch = s->cmap.nch;
	vol = ADATA_UNIT / s->join;
	cmap_copy(&s->cmap, in, out, vol, icnt);

	offs = 0;
	for (i = s->join - 1; i > 0; i--) {
		offs += nch;
		cmap_add(&s->cmap, (adata_t *)in + offs, out, vol, icnt);
	}
	offs = 0;
	for (i = s->expand - 1; i > 0; i--) {
		offs += nch;
		cmap_copy(&s->cmap, in, (adata_t *)out + offs, vol, icnt);
	}
	if (s->resampbuf)
		resamp_do(&s->resamp, s->resampbuf, res_out, icnt, ocnt);
	else
		ocnt = icnt;
}

static void
rec_filt_enc(struct slot *s, void *in, void *out, int icnt, int ocnt)
{
	void *tmp;

	tmp = s->convbuf;
	rec_filt_resamp(s, in, tmp ? tmp : out, icnt, ocnt);
	if (tmp)
		enc_do(&s->conv, tmp, out, ocnt);
}

/*
 * Copy "todo" frames from the given buffer to the slot buffer,
 * but not more than a block.
 */
static void
slot_sub_bcopy(struct slot *s, adata_t *idata, int itodo)
{
	adata_t *odata;
	int len, icnt, ocnt;

	if (s->skip > 0) {
		icnt = itodo;
		if (icnt > s->skip)
			icnt = s->skip;
		s->skip -= icnt;
		idata += dev_rchan * icnt;
		itodo -= icnt;
	}

	while (itodo > 0) {
		odata = (adata_t *)abuf_wgetblk(&s->buf, &len);
		ocnt = len / s->bpf;
		if (ocnt > s->round)
			ocnt = s->round;
		icnt = itodo;
		slot_getcnt(s, &icnt, &ocnt);
		if (ocnt == 0)
			break;
		rec_filt_enc(s, idata, odata, icnt, ocnt);
		abuf_wcommit(&s->buf, ocnt * s->bpf);
		itodo -= icnt;
		idata += icnt * dev_rchan;
	}
}

static int
dev_open(char *dev, int mode, int bufsz, char *port)
{
	int rate, pmax, rmax;
	struct sio_par par;
	struct slot *s;

	if (port) {
		dev_port = port;
		dev_mh = mio_open(dev_port, MIO_IN, 0);
		if (dev_mh == NULL) {
			log_puts(port);
			log_puts(": couldn't open midi port\n");
			return 0;
		}
	} else
		dev_mh = NULL;

	dev_name = dev;
	dev_sh = sio_open(dev, mode, 0);
	if (dev_sh == NULL) {
		log_puts(dev_name);
		log_puts(": couldn't open audio device\n");
		return 0;
	}

	rate = pmax = rmax = 0;
	for (s = slot_list; s != NULL; s = s->next) {
		if (s->afile.rate > rate)
			rate = s->afile.rate;
		if (s->mode == SIO_PLAY) {
			if (s->cmax > pmax)
				pmax = s->cmax;
		}
		if (s->mode == SIO_REC) {
			if (s->cmax > rmax)
				rmax = s->cmax;
		}
	}
	sio_initpar(&par);
	par.bits = ADATA_BITS;
	par.bps = sizeof(adata_t);
	par.msb = 0;
	par.le = SIO_LE_NATIVE;
	par.rate = rate;
	if (mode & SIO_PLAY)
		par.pchan = pmax + 1;
	if (mode & SIO_REC)
		par.rchan = rmax + 1;
	par.appbufsz = bufsz > 0 ? bufsz : rate * DEFAULT_BUFSZ_MS / 1000;
	if (!sio_setpar(dev_sh, &par) || !sio_getpar(dev_sh, &par)) {
		log_puts(dev_name);
		log_puts(": couldn't set audio params\n");
		return 0;
	}
	if (par.bits != ADATA_BITS ||
	    par.bps != sizeof(adata_t) ||
	    (par.bps > 1 && par.le != SIO_LE_NATIVE) ||
	    (par.bps * 8 > par.bits && par.msb)) {
		log_puts(dev_name);
		log_puts(": unsupported audio params\n");
		return 0;
	}
	dev_mode = mode;
	dev_rate = par.rate;
	dev_bufsz = par.bufsz;
	dev_round = par.round;
	if (mode & SIO_PLAY) {
		dev_pchan = par.pchan;
		dev_pbuf = xmalloc(sizeof(adata_t) * dev_pchan * dev_round);
	}
	if (mode & SIO_REC) {
		dev_rchan = par.rchan;
		dev_rbuf = xmalloc(sizeof(adata_t) * dev_rchan * dev_round);
	}
	dev_pstate = DEV_STOP;
	if (log_level >= 2) {
		log_puts(dev_name);
		log_puts(": ");
		log_putu(dev_rate);
		log_puts("Hz");
		if (dev_mode & SIO_PLAY) {
			log_puts(", play 0:");
			log_puti(dev_pchan - 1);
		}
		if (dev_mode & SIO_REC) {
			log_puts(", rec 0:");
			log_puti(dev_rchan - 1);
		}
		log_puts(", ");
		log_putu(dev_bufsz / dev_round);
		log_puts(" blocks of ");
		log_putu(dev_round);
		log_puts(" frames\n");
	}
	return 1;
}

static void
dev_close(void)
{
	sio_close(dev_sh);
	if (dev_mh)
		mio_close(dev_mh);
	if (dev_mode & SIO_PLAY)
		xfree(dev_pbuf);
	if (dev_mode & SIO_REC)
		xfree(dev_rbuf);
}

static void
dev_master(int val)
{
	struct slot *s;
	int mastervol, slotvol;

	mastervol = MIDI_TO_ADATA(dev_volctl);
	for (s = slot_list; s != NULL; s = s->next) {
		slotvol = MIDI_TO_ADATA(val);
		s->vol = ADATA_MUL(mastervol, slotvol);
	}
#ifdef DEBUG
	if (log_level >= 3) {
		log_puts("master volume set to ");
		log_putu(val);
		log_puts("\n");
	}
#endif
}

static void
dev_slotvol(int midich, int val)
{
	struct slot *s;
	int mastervol, slotvol;

	for (s = slot_list; s != NULL; s = s->next) {
		if (midich == 0) {
			mastervol = MIDI_TO_ADATA(dev_volctl);
			slotvol = MIDI_TO_ADATA(val);
			s->vol = ADATA_MUL(mastervol, slotvol);
#ifdef DEBUG
			if (log_level >= 3) {
				slot_log(s);
				log_puts(": volume set to ");
				log_putu(val);
				log_puts("\n");
			}
#endif
			break;
		}
	}
}

/*
 * start all slots simultaneously
 */
static void
dev_mmcstart(void)
{
	struct slot *s;

	if (dev_pstate == DEV_STOP) {
		dev_pstate = DEV_START;
		for (s = slot_list; s != NULL; s = s->next)
			slot_start(s, dev_pos);
		dev_prime = (dev_mode & SIO_PLAY) ? dev_bufsz / dev_round : 0;
		sio_start(dev_sh);
		if (log_level >= 2)
			log_puts("started\n");
	} else {
#ifdef DEBUG
		if (log_level >= 3)
			log_puts("ignoring mmc start\n");
#endif
	}
}

/*
 * stop all slots simultaneously
 */
static void
dev_mmcstop(void)
{
	struct slot *s;

	if (dev_pstate == DEV_START) {
		dev_pstate = DEV_STOP;
		for (s = slot_list; s != NULL; s = s->next)
			slot_stop(s);
		sio_stop(dev_sh);
		if (log_level >= 2)
			log_puts("stopped\n");
	} else {
#ifdef DEBUG
		if (log_level >= 3)
			log_puts("ignored mmc stop\n");
#endif
	}
}

/*
 * relocate all slots simultaneously
 */
static void
dev_mmcloc(int hr, int min, int sec, int fr, int cent, int fps)
{
	long long pos;

	pos = (long long)dev_rate * hr * 3600 +
	    (long long)dev_rate * min * 60 +
	    (long long)dev_rate * sec +
	    (long long)dev_rate * fr / fps +
	    (long long)dev_rate * cent / (100 * fps);
	if (dev_pos == pos)
		return;
	dev_pos = pos;
	if (log_level >= 2) {
		log_puts("relocated to ");
		log_putu(hr);
		log_puts(":");
		log_putu(min);
		log_puts(":");
		log_putu(sec);
		log_puts(".");
		log_putu(fr);
		log_puts(".");
		log_putu(cent);
		log_puts(" at ");
		log_putu(fps);
		log_puts("fps\n");
	}
	if (dev_pstate == DEV_START) {
		dev_mmcstop();
		dev_mmcstart();
	}
}

static void
dev_imsg(unsigned char *msg, unsigned int len)
{
	struct sysex *x;
	unsigned int fps, chan;

	if ((msg[0] & MIDI_CMDMASK) == MIDI_CTL && msg[1] == MIDI_CTL_VOL) {
		chan = msg[0] & MIDI_CHANMASK;
		dev_slotvol(chan, msg[2]);
		return;
	}
	x = (struct sysex *)msg;
	if (x->start != SYSEX_START)
		return;
	if (len < SYSEX_SIZE(empty))
		return;
	if (x->type != SYSEX_TYPE_RT)
		return;
	if (x->id0 == SYSEX_CONTROL && x->id1 == SYSEX_MASTER) {
		if (len == SYSEX_SIZE(master))
			dev_master(x->u.master.coarse);
		return;
	}
	if (x->id0 != SYSEX_MMC)
		return;
	switch (x->id1) {
	case SYSEX_MMC_STOP:
		if (len != SYSEX_SIZE(stop))
			return;
		dev_mmcstop();
		break;
	case SYSEX_MMC_START:
		if (len != SYSEX_SIZE(start))
			return;
		dev_mmcstart();
		break;
	case SYSEX_MMC_LOC:
		if (len != SYSEX_SIZE(loc) ||
		    x->u.loc.len != SYSEX_MMC_LOC_LEN ||
		    x->u.loc.cmd != SYSEX_MMC_LOC_CMD)
			return;
		switch (x->u.loc.hr >> 5) {
		case MTC_FPS_24:
			fps = 24;
			break;
		case MTC_FPS_25:
			fps = 25;
			break;
		case MTC_FPS_30:
			fps = 30;
			break;
		default:
			dev_mmcstop();
			return;
		}
		dev_mmcloc(x->u.loc.hr & 0x1f,
		    x->u.loc.min,
		    x->u.loc.sec,
		    x->u.loc.fr,
		    x->u.loc.cent,
		    fps);
		break;
	}
}

/*
 * parse the given data chunk and call imsg() for each message
 */
static void
midi_in(unsigned char *idata, int icount)
{
	int i;
	unsigned char c;

	for (i = 0; i < icount; i++) {
		c = *idata++;
		if (c >= 0xf8) {
			/* we don't use real-time events */
		} else if (c == SYSEX_END) {
			if (dev_mst == SYSEX_START) {
				dev_msg[dev_midx++] = c;
				dev_imsg(dev_msg, dev_midx);
			}
			dev_mst = 0;
			dev_midx = 0;
		} else if (c >= 0xf0) {
			dev_msg[0] = c;
			dev_mlen = common_len[c & 7];
			dev_mst = c;
			dev_midx = 1;
		} else if (c >= 0x80) {
			dev_msg[0] = c;
			dev_mlen = voice_len[(c >> 4) & 7];
			dev_mst = c;
			dev_midx = 1;
		} else if (dev_mst) {
			if (dev_midx == 0 && dev_mst != SYSEX_START)
				dev_msg[dev_midx++] = dev_mst;
			dev_msg[dev_midx++] = c;
			if (dev_midx == dev_mlen) {
				dev_imsg(dev_msg, dev_midx);
				if (dev_mst >= 0xf0)
					dev_mst = 0;
				dev_midx = 0;
			} else if (dev_midx == MIDI_MSGMAX) {
				/* sysex too long */
				dev_mst = 0;
			}
		}
	}
}

static int
slot_list_mix(unsigned int round, unsigned int pchan, adata_t *pbuf)
{
	unsigned int done, n;
	struct slot *s;

	memset(pbuf, 0, pchan * round * sizeof(adata_t));
	done = 0;
	for (s = slot_list; s != NULL; s = s->next) {
		if (s->pstate == SLOT_INIT || !(s->mode & SIO_PLAY))
			continue;
		if (s->pstate == SLOT_STOP && s->buf.used < s->bpf) {
#ifdef DEBUG
			if (log_level >= 3) {
				slot_log(s);
				log_puts(": drained, done\n");
			}
#endif
			slot_stop(s);
			continue;
		}
		n = slot_mix_badd(s, dev_pbuf);
		if (n > done)
			done = n;
	}
	return done;
}

static int
slot_list_copy(unsigned int count, unsigned int rchan, adata_t *rbuf)
{
	unsigned int done;
	struct slot *s;

	done = 0;
	for (s = slot_list; s != NULL; s = s->next) {
		if (s->pstate == SLOT_INIT || !(s->mode & SIO_REC))
			continue;
		slot_sub_bcopy(s, rbuf, count);
		done = count;
	}
	return done;
}

static void
slot_list_iodo(void)
{
	struct slot *s;

	for (s = slot_list; s != NULL; s = s->next) {
		if (s->pstate != SLOT_RUN)
			continue;
		if ((s->mode & SIO_PLAY) &&
		    (s->buf.used < s->round * s->bpf))
			slot_fill(s);
		if ((s->mode & SIO_REC) &&
		    (s->buf.len - s->buf.used < s->round * s->bpf))
			slot_flush(s);
	}
}

static int
offline(void)
{
	unsigned int todo;
	int rate, cmax;
	struct slot *s;

	rate = cmax = 0;
	for (s = slot_list; s != NULL; s = s->next) {
		if (s->afile.rate > rate)
			rate = s->afile.rate;
		if (s->cmax > cmax)
			cmax = s->cmax;
	}
	dev_sh = NULL;
	dev_name = "offline";
	dev_mode = SIO_PLAY | SIO_REC;
	dev_rate = rate;
	dev_bufsz = rate;
	dev_round = rate;
	dev_pchan = dev_rchan = cmax + 1;
	dev_pbuf = dev_rbuf = xmalloc(sizeof(adata_t) * dev_pchan * dev_round);
	dev_pstate = DEV_STOP;
	for (s = slot_list; s != NULL; s = s->next)
		slot_init(s);
	for (s = slot_list; s != NULL; s = s->next)
		slot_start(s, 0);
	for (;;) {
		todo = slot_list_mix(dev_round, dev_pchan, dev_pbuf);
		if (todo == 0)
			break;
		slot_list_copy(todo, dev_pchan, dev_pbuf);
		slot_list_iodo();
	}
	xfree(dev_pbuf);
	while (slot_list)
		slot_del(slot_list);
	return 1;
}

static int
playrec_cycle(void)
{
	unsigned int n, todo;
	unsigned char *p;
	int pcnt, rcnt;

#ifdef DEBUG
	if (log_level >= 4) {
		log_puts(dev_name);
		log_puts(": cycle, prime = ");
		log_putu(dev_prime);
		log_puts("\n");
	}
#endif
	pcnt = rcnt = 0;
	if (dev_mode & SIO_REC) {
		if (dev_prime > 0)
			dev_prime--;
		else {
			todo = dev_round * dev_rchan * sizeof(adata_t);
			p = (unsigned char *)dev_rbuf;
			while (todo > 0) {
				n = sio_read(dev_sh, p, todo);
				if (n == 0) {
					log_puts(dev_name);
					log_puts(": failed to read "
					    "from device\n");
					return 0;
				}
				p += n;
				todo -= n;
			}
			rcnt = slot_list_copy(dev_round, dev_rchan, dev_rbuf);
		}
	}
	if (dev_mode & SIO_PLAY) {
		pcnt = slot_list_mix(dev_round, dev_pchan, dev_pbuf);
		todo = sizeof(adata_t) * dev_pchan * dev_round;
		n = sio_write(dev_sh, dev_pbuf, todo);
		if (n == 0) {
			log_puts(dev_name);
			log_puts(": failed to write to device\n");
			return 0;
		}
	}
	slot_list_iodo();
	return pcnt > 0 || rcnt > 0;
}

static void
sigint(int s)
{
	if (quit_flag)
		_exit(1);
	quit_flag = 1;
}

static int
playrec(char *dev, int mode, int bufsz, char *port)
{
#define MIDIBUFSZ 0x100
	unsigned char mbuf[MIDIBUFSZ];
	struct sigaction sa;
	struct pollfd *pfds;
	struct slot *s;
	int n, ns, nm, ev;

	if (!dev_open(dev, mode, bufsz, port))
		return 0;
	n = sio_nfds(dev_sh);
	if (dev_mh)
		n += mio_nfds(dev_mh);
	pfds = xmalloc(n * sizeof(struct pollfd));
	for (s = slot_list; s != NULL; s = s->next)
		slot_init(s);
	if (dev_mh == NULL)
		dev_mmcstart();
	else {
		if (log_level >= 2)
			log_puts("ready, waiting for mmc messages\n");
	}

	quit_flag = 0;
	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = sigint;
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGTERM, &sa, NULL);
	sigaction(SIGHUP, &sa, NULL);
	while (!quit_flag) {
		if (dev_pstate == DEV_START) {
			ev = 0;
			if (mode & SIO_PLAY)
				ev |= POLLOUT;
			if (mode & SIO_REC)
				ev |= POLLIN;
			ns = sio_pollfd(dev_sh, pfds, ev);
		} else
			ns = 0;
		if (dev_mh)
			nm = mio_pollfd(dev_mh, pfds + ns, POLLIN);
		else
			nm = 0;
		if (poll(pfds, ns + nm, -1) < 0) {
			if (errno == EINTR)
				continue;
			log_puts("poll failed\n");
			panic();
		}
		if (dev_pstate == DEV_START) {
			ev = sio_revents(dev_sh, pfds);
			if (ev & POLLHUP) {
				log_puts(dev);
				log_puts(": audio device gone, stopping\n");
				break;
			}
			if (ev & (POLLIN | POLLOUT)) {
				if (!playrec_cycle() && dev_mh == NULL)
					break;
			}
		}
		if (dev_mh) {
			ev = mio_revents(dev_mh, pfds + ns);
			if (ev & POLLHUP) {
				log_puts(dev_port);
				log_puts(": midi port gone, stopping\n");
				break;
			}
			if (ev & POLLIN) {
				n = mio_read(dev_mh, mbuf, MIDIBUFSZ);
				midi_in(mbuf, n);
			}
		}
	}
	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = SIG_DFL;
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGTERM, &sa, NULL);
	sigaction(SIGHUP, &sa, NULL);

	if (dev_pstate == DEV_START)
		dev_mmcstop();
	xfree(pfds);
	dev_close();
	while (slot_list)
		slot_del(slot_list);
	return 1;
}

static int
opt_onoff(char *s, int *flag)
{
	if (strcmp("off", s) == 0) {
		*flag = 0;
		return 1;
	}
	if (strcmp("on", s) == 0) {
		*flag = 1;
		return 1;
	}
	log_puts(s);
	log_puts(": on/off expected\n");
	return 0;
}

static int
opt_enc(char *s, struct aparams *par)
{
	int len;

	len = aparams_strtoenc(par, s);
	if (len == 0 || s[len] != '\0') {
		log_puts(s);
		log_puts(": bad encoding\n");
		return 0;
	}
	return 1;
}

static int
opt_hdr(char *s, int *hdr)
{
	if (strcmp("auto", s) == 0) {
		*hdr = AFILE_HDR_AUTO;
		return 1;
	}
	if (strcmp("raw", s) == 0) {
		*hdr = AFILE_HDR_RAW;
		return 1;
	}
	if (strcmp("wav", s) == 0) {
		*hdr = AFILE_HDR_WAV;
		return 1;
	}
	if (strcmp("aiff", s) == 0) {
		*hdr = AFILE_HDR_AIFF;
		return 1;
	}
	if (strcmp("au", s) == 0) {
		*hdr = AFILE_HDR_AU;
		return 1;
	}
	log_puts(s);
	log_puts(": bad header type\n");
	return 0;
}

static int
opt_ch(char *s, int *rcmin, int *rcmax)
{
	char *next, *end;
	long cmin, cmax;

	errno = 0;
	cmin = strtol(s, &next, 10);
	if (next == s || *next != ':')
		goto failed;
	cmax = strtol(++next, &end, 10);
	if (end == next || *end != '\0')
		goto failed;
	if (cmin < 0 || cmax < cmin || cmax >= NCHAN_MAX)
		goto failed;
	*rcmin = cmin;
	*rcmax = cmax;
	return 1;
failed:
	log_puts(s);
	log_puts(": channel range expected\n");
	return 0;
}

static int
opt_num(char *s, int min, int max, int *num)
{
	const char *errstr;

	*num = strtonum(s, min, max, &errstr);
	if (errstr) {
		log_puts(s);
		log_puts(": expected integer between ");
		log_puti(min);
		log_puts(" and ");
		log_puti(max);
		log_puts("\n");
		return 0;
	}
	return 1;
}

static int
opt_pos(char *s, long long *pos)
{
	const char *errstr;

	*pos = strtonum(s, 0, LLONG_MAX, &errstr);
	if (errstr) {
		log_puts(s);
		log_puts(": positive number of samples expected\n");
		return 0;
	}
	return 1;
}

int
main(int argc, char **argv)
{
	int dup, cmin, cmax, rate, vol, bufsz, hdr, mode;
	char *port, *dev;
	struct aparams par;
	int n_flag, c;
	long long pos;

	vol = 127;
	dup = 0;
	bufsz = 0;
	rate = DEFAULT_RATE;
	cmin = 0;
	cmax = 1;
	aparams_init(&par);
	hdr = AFILE_HDR_AUTO;
	n_flag = 0;
	port = NULL;
	dev = NULL;
	mode = 0;
	pos = 0;

	while ((c = getopt(argc, argv,
		"b:c:de:f:g:h:i:j:no:p:q:r:t:v:")) != -1) {
		switch (c) {
		case 'b':
			if (!opt_num(optarg, 1, RATE_MAX, &bufsz))
				return 1;
			break;
		case 'c':
			if (!opt_ch(optarg, &cmin, &cmax))
				return 1;
			break;
		case 'd':
			log_level++;
			break;
		case 'e':
			if (!opt_enc(optarg, &par))
				return 1;
			break;
		case 'f':
			dev = optarg;
			break;
		case 'g':
			if (!opt_pos(optarg, &dev_pos))
				return 1;
			break;
		case 'h':
			if (!opt_hdr(optarg, &hdr))
				return 1;
			break;
		case 'i':
			if (!slot_new(optarg, SIO_PLAY,
				&par, hdr, cmin, cmax, rate, dup, vol, pos))
				return 1;
			mode |= SIO_PLAY;
			break;
		case 'j':
			if (!opt_onoff(optarg, &dup))
				return 1;
			break;
		case 'n':
			n_flag = 1;
			break;
		case 'o':
			if (!slot_new(optarg, SIO_REC,
				&par, hdr, cmin, cmax, rate, dup, 0, pos))
				return 1;
			mode |= SIO_REC;
			break;
		case 'p':
			if (!opt_pos(optarg, &pos))
				return 1;
			break;
		case 'q':
			port = optarg;
			break;
		case 'r':
			if (!opt_num(optarg, RATE_MIN, RATE_MAX, &rate))
				return 1;
			break;
		case 'v':
			if (!opt_num(optarg, 0, MIDI_MAXCTL, &vol))
				return 1;
			break;
		default:
			goto bad_usage;
		}
	}
	argc -= optind;
	argv += optind;
	if (argc != 0) {
	bad_usage:
		log_puts(usagestr);
		return 1;
	}
	if (n_flag) {
		if (dev != NULL || port != NULL) {
			log_puts("-f and -q make no sense in off-line mode\n");
			return 1;
		}
		if (mode != (SIO_PLAY | SIO_REC)) {
			log_puts("both -i and -o required\n");
			return 1;
		}
		if (!offline())
			return 1;
	} else {
		if (dev == NULL)
			dev = SIO_DEVANY;
		if (mode == 0) {
			log_puts("at least -i or -o required\n");
			return 1;
		}
		if (!playrec(dev, mode, bufsz, port))
			return 1;
	}
	return 0;
}
@


1.169
log
@Assert we're not freeing buffers we didn't allocate (DEBUG mode).
@
text
@d834 5
a838 5
	pos = dev_rate * hr * 3600 +
	    dev_rate * min * 60 +
	    dev_rate * sec +
	    dev_rate * fr / fps +
	    dev_rate * cent / (100 * fps);
@


1.168
log
@Log play volume together with other play parameters.
@
text
@d215 1
a215 1
		free(s);
d433 1
a433 1
			free(s->resampbuf);
d435 1
a435 1
			free(s->convbuf);
d440 1
a440 1
	free(s);
d730 1
a730 1
		free(dev_pbuf);
d732 1
a732 1
		free(dev_rbuf);
d1070 1
a1070 1
	free(dev_pbuf);
d1220 1
a1220 1
	free(pfds);
@


1.167
log
@Set the device rate to the calculated rate. Otherwise, the signal
may endup resampled twice.
@
text
@d256 4
@


1.166
log
@Remove unnecessary includes. From Michael W. Bombardieri <mb at ii.net>.
@
text
@d665 1
@


1.165
log
@Don't rely on the resampling code to calculate the number of samples
to process, as it may produce one extra sample (to handle accumulation
of fractional samples), which would cause access to one sample past
the end of the buffer and crash aucat. Fix this by limiting the number
of samples processed to a single block.

Found by and help from Michael W. Bombardieri <mb at ii.net>. Thanks.
@
text
@a16 1
#include <fcntl.h>
a21 1
#include <stdio.h>
@


1.164
log
@Add -g and -p options to control device and file start position.
@
text
@d534 2
d610 2
@


1.163
log
@Add resamp_getcnt() routine to calculate the exact number of samples
that would be consumed and produced by the sampler rate converter. Use
it to avoid partial samples that are not properly handled. Fixes
last samples of certain files causing aucat to abort.
@
text
@d19 1
d94 2
d140 3
a142 2
    "[-c min:max] [-e enc] [-f device] [-h fmt]\n\t"
    "[-i file] [-j flag] [-o file] [-q port] [-r rate] [-v volume]\n";
d209 1
a209 1
    int cmin, int cmax, int rate, int dup, int vol)
d226 1
d367 7
d430 4
a433 2
		free(s->resampbuf);
		free(s->convbuf);
d522 9
d596 9
a692 1
	dev_pos = 0;
a1051 1
	dev_pos = 0;
d1320 14
d1341 1
d1355 1
d1357 2
a1358 1
	while ((c = getopt(argc, argv, "b:c:de:f:h:i:j:no:q:r:t:v:")) != -1) {
d1378 4
d1388 1
a1388 1
				&par, hdr, cmin, cmax, rate, dup, vol))
d1401 1
a1401 1
				&par, hdr, cmin, cmax, rate, dup, 0))
d1404 4
@


1.162
log
@remove forgotten debug printfs
@
text
@d427 2
a428 2
static int
slot_ocnt(struct slot *s, int icnt)
d430 1
a430 2
	return s->resampbuf ? resamp_ocnt(&s->resamp, icnt) : icnt;
}
d432 7
a438 4
static int
slot_icnt(struct slot *s, int ocnt)
{
	return s->resampbuf ? resamp_icnt(&s->resamp, ocnt) : ocnt;
a509 1

d511 2
a512 5
		ocnt = slot_ocnt(s, icnt);
		if (ocnt > otodo) {
			ocnt = otodo;
			icnt = slot_icnt(s, ocnt);
		}
a574 1

d576 2
a577 5
		icnt = slot_icnt(s, ocnt);
		if (icnt > itodo) {
			icnt = itodo;
			ocnt = slot_ocnt(s, icnt);
		}
@


1.161
log
@set exit status to 1 if -n is used without -i and -o
@
text
@a823 4

		log_puts("pos: ");
		log_putu(pos);
		log_puts("\n");
@


1.160
log
@Pass hr:min:sec:frame.cent to dev_mmcloc() directly and remove the
useless intermediate conversion from and to 2400-th of seconds.
@
text
@d1393 1
a1393 1
			return 0;
@


1.159
log
@To store MMC position, use samples (at device rate) as time units
instead of 2400-ths of second. No behaviour change.
@
text
@d798 1
a798 1
dev_mmcloc(unsigned int mmc)
d802 5
a806 1
	pos = mmc * dev_rate / MTC_SEC;
d812 1
a812 1
		log_putu((mmc / (MTC_SEC * 3600)) % 24);
d814 1
a814 1
		log_putu((mmc / (MTC_SEC * 60)) % 60);
d816 1
a816 1
		log_putu((mmc / (MTC_SEC)) % 60);
d818 1
a818 1
		log_putu((mmc / (MTC_SEC / 100)) % 100);
d820 7
a826 1
		log_putu((mmc / (MTC_SEC / 100)) % 100);
d890 6
a895 5
		dev_mmcloc((x->u.loc.hr & 0x1f) * 3600 * MTC_SEC +
		    x->u.loc.min * 60 * MTC_SEC +
		    x->u.loc.sec * MTC_SEC +
		    x->u.loc.fr * (MTC_SEC / fps) +
		    x->u.loc.cent * (MTC_SEC / 100 / fps));
@


1.158
log
@Fix file block size rounding and ensure it's large enough to store a
full audio block.
@
text
@d105 1
a105 1
unsigned int dev_mmcpos;		/* last MMC position */
d353 1
a353 1
slot_start(struct slot *s, unsigned int mmc)
a354 2
	off_t mmcpos;

d362 9
a370 2
	mmcpos = ((off_t)mmc * s->afile.rate / MTC_SEC) * s->bpf;
	if (!afile_seek(&s->afile, mmcpos)) {
d667 1
a667 1
	dev_mmcpos = 0;
d758 1
a758 1
			slot_start(s, dev_mmcpos);
d800 4
a803 1
	if (dev_mmcpos == mmc)
d805 1
a805 1
	dev_mmcpos = mmc;
d808 1
a808 1
		log_putu((dev_mmcpos / (MTC_SEC * 3600)) % 24);
d810 1
a810 1
		log_putu((dev_mmcpos / (MTC_SEC * 60)) % 60);
d812 3
a814 1
		log_putu((dev_mmcpos / (MTC_SEC)) % 60);
d816 1
a816 1
		log_putu((dev_mmcpos / (MTC_SEC / 100)) % 100);
d1020 1
a1020 1
	dev_mmcpos = 0;
@


1.157
log
@When resampling, use the exact resampling factor instead of the ratio
between input and output block sizes.  This was inherited from sndiod,
but is not required for files because they are continuous streams of
samples and do not need to be split in blocks of equal duration.

This change makes playback/recording rate match exactly the requested
sample rate.
@
text
@d273 1
a273 1
	s->round = (dev_round * s->afile.rate + dev_rate / 2) / dev_rate;
@


1.156
log
@Flush rec buffer if there's less than one block space left and refill
play buffer if there's less than one block of data left. This is the
correct condition in the general case. No behaviour change, as all
input/output is multiple of the block size.
@
text
@d313 1
a313 1
			resamp_init(&s->resamp, s->round, dev_round,
d332 1
a332 1
			resamp_init(&s->resamp, dev_round, s->round,
@


1.155
log
@Simplify slot_fill() and slot_flush(). No behaviour change
@
text
@d978 2
a979 1
		if ((s->mode & SIO_PLAY) && (s->buf.used == 0))
d981 2
a982 1
		if ((s->mode & SIO_REC) && (s->buf.used == s->buf.len))
@


1.154
log
@Make resamp_do() get the exact number input and output samples and
provide routines to calculate them. This way we don't rely on it
to calculate the bytes procuded/consumed anymore. No behaviour change.
@
text
@d160 1
a160 1
	int todo, count, n;
d163 1
a163 2
	todo = s->buf.used;
	while (todo > 0) {
d165 2
a166 2
		if (count > todo)
			count = todo;
a174 1
		todo -= n;
d181 1
a181 1
	int todo, count, n;
d184 1
a184 2
	todo = s->buf.len;
	while (todo > 0) {
d186 2
a187 2
		if (count > todo)
			count = todo;
a199 1
		todo -= n;
@


1.153
log
@Make format conversion routines return the number of frames
consumed from both input and output buffers. No behaviour change.
@
text
@d426 12
d439 1
a439 1
play_filt_resamp(struct slot *s, void *res_in, void *out, int *icnt, int *ocnt)
d452 1
a452 1
	cmap_add(&s->cmap, in, out, vol, *ocnt);
d457 1
a457 1
		cmap_add(&s->cmap, (adata_t *)in + offs, out, vol, *ocnt);
d462 1
a462 1
		cmap_add(&s->cmap, in, (adata_t *)out + offs, vol, *ocnt);
d467 1
a467 1
play_filt_dec(struct slot *s, void *in, void *out, int *icnt, int *ocnt)
d475 1
a475 1
			dec_do(&s->conv, in, tmp, *icnt);
d478 1
a478 1
			dec_do_ulaw(&s->conv, in, tmp, *icnt, 0);
d481 1
a481 1
			dec_do_ulaw(&s->conv, in, tmp, *icnt, 1);
d484 1
a484 1
			dec_do_float(&s->conv, in, tmp, *icnt);
d501 1
a501 1
	int len, icnt, ocnt;
d503 20
a522 14
	idata = (adata_t *)abuf_rgetblk(&s->buf, &len);
	icnt = len / s->bpf;
	if (icnt > s->round)
		icnt = s->round;
#ifdef DEBUG
	if (icnt == 0) {
		log_puts("slot_mix_badd: not enough data\n");
		panic();
	}
#endif
	ocnt = dev_round;
	play_filt_dec(s, idata, odata, &icnt, &ocnt);
	abuf_rdiscard(&s->buf, icnt * s->bpf);
	return ocnt;
d526 1
a526 1
rec_filt_resamp(struct slot *s, void *in, void *res_out, int *icnt, int *ocnt)
d535 1
a535 1
	cmap_copy(&s->cmap, in, out, vol, *icnt);
d540 1
a540 1
		cmap_add(&s->cmap, (adata_t *)in + offs, out, vol, *icnt);
d545 1
a545 1
		cmap_copy(&s->cmap, in, (adata_t *)out + offs, vol, *icnt);
d550 1
a550 1
		*ocnt = *icnt;
d554 1
a554 1
rec_filt_enc(struct slot *s, void *in, void *out, int *icnt, int *ocnt)
d561 1
a561 1
		enc_do(&s->conv, tmp, out, *ocnt);
d569 1
a569 1
slot_sub_bcopy(struct slot *s, adata_t *idata, int todo)
d574 16
a589 11
	odata = (adata_t *)abuf_wgetblk(&s->buf, &len);
#ifdef DEBUG
	if (len < s->round * s->bpf) {
		log_puts("slot_sub_bcopy: not enough space\n");
		panic();
	}
#endif
	icnt = todo;
	ocnt = len / s->bpf;
	rec_filt_enc(s, idata, odata, &icnt, &ocnt);
	abuf_wcommit(&s->buf, ocnt * s->bpf);
@


1.152
log
@Check that byte order is native only if we're using more than one
byte per sample, check that samples are lsb-aligned only if there's
padding. Fixes unsupported parameters not being detected if compiled
in 24-bit mode and sndiod is not running.
@
text
@d426 2
a427 2
static int
play_filt_resamp(struct slot *s, void *res_in, void *out, int todo)
d433 1
a433 2
		todo = resamp_do(&s->resamp,
		    res_in, s->resampbuf, todo);
d440 1
a440 1
	cmap_add(&s->cmap, in, out, vol, todo);
d445 1
a445 1
		cmap_add(&s->cmap, (adata_t *)in + offs, out, vol, todo);
d450 1
a450 1
		cmap_add(&s->cmap, in, (adata_t *)out + offs, vol, todo);
a451 1
	return todo;
d454 2
a455 2
static int
play_filt_dec(struct slot *s, void *in, void *out, int todo)
d463 1
a463 1
			dec_do(&s->conv, in, tmp, todo);
d466 1
a466 1
			dec_do_ulaw(&s->conv, in, tmp, todo, 0);
d469 1
a469 1
			dec_do_ulaw(&s->conv, in, tmp, todo, 1);
d472 1
a472 1
			dec_do_float(&s->conv, in, tmp, todo);
d475 3
a477 2
	}
	return play_filt_resamp(s, tmp ? tmp : in, out, todo);
d489 1
a489 1
	int icount, todo, done;
d491 4
a494 4
	idata = (adata_t *)abuf_rgetblk(&s->buf, &icount);
	todo = icount / s->bpf;
	if (todo > s->round)
		todo = s->round;
d496 1
a496 1
	if (todo == 0) {
d501 4
a504 3
	done = play_filt_dec(s, idata, odata, todo);
	abuf_rdiscard(&s->buf, todo * s->bpf);
	return done;
d507 2
a508 2
static int
rec_filt_resamp(struct slot *s, void *in, void *res_out, int todo)
d517 1
a517 1
	cmap_copy(&s->cmap, in, out, vol, todo);
d522 1
a522 1
		cmap_add(&s->cmap, (adata_t *)in + offs, out, vol, todo);
d527 1
a527 5
		cmap_copy(&s->cmap, in, (adata_t *)out + offs, vol, todo);
	}
	if (s->resampbuf) {
		todo = resamp_do(&s->resamp,
		    s->resampbuf, res_out, todo);
d529 4
a532 1
	return todo;
d535 2
a536 2
static int
rec_filt_enc(struct slot *s, void *in, void *out, int todo)
d541 1
a541 1
	todo = rec_filt_resamp(s, in, tmp ? tmp : out, todo);
d543 1
a543 2
		enc_do(&s->conv, tmp, out, todo);
	return todo;
d554 1
a554 1
	int ocount;
d556 1
a556 1
	odata = (adata_t *)abuf_wgetblk(&s->buf, &ocount);
d558 1
a558 1
	if (ocount < s->round * s->bpf) {
d563 4
a566 2
	ocount = rec_filt_enc(s, idata, odata, todo);
	abuf_wcommit(&s->buf, ocount * s->bpf);
@


1.151
log
@trailing spaces, fit in 80 columns
@
text
@d625 2
a626 2
	    par.le != SIO_LE_NATIVE ||
	    (par.bps != SIO_BPS(par.bits) && par.msb)) {
@


1.150
log
@Remove xfree(). From Michael W. Bombardieri.

ok ratchov@@
@
text
@d310 2
a311 1
		if (s->afile.fmt != AFILE_FMT_PCM || !aparams_native(&s->afile.par)) {
d426 1
a426 1
static int 
d456 1
a456 1
static int 
d507 1
a507 1
static int 
d536 1
a536 1
static int 
d1033 2
a1034 1
					log_puts(": failed to read from device\n");
d1116 1
a1116 1
		}		
d1278 1
a1278 1
	
d1361 1
a1361 1
		} 
@


1.149
log
@fix typos in comments and error messages
@
text
@d217 1
a217 1
		xfree(s);
d416 2
a417 4
		if (s->resampbuf)
			xfree(s->resampbuf);
		if (s->convbuf)
			xfree(s->convbuf);
d422 1
a422 1
	xfree(s);
d673 1
a673 1
		xfree(dev_pbuf);
d675 1
a675 1
		xfree(dev_rbuf);
d1000 1
a1000 1
	xfree(dev_pbuf);
d1149 1
a1149 1
	xfree(pfds);
@


1.148
log
@Call slot_stop() after the play buffer is drained to properly cleanup
the slot. Fixes periodic glitches occurring after eof is reached, and
then playback restarted with a MMC-relocate and MMC-start.
@
text
@d73 1
a73 1
	struct slot *next;		/* next on the play list */
d93 1
a93 1
	struct afile afile;			/* file desc & friends */
d862 1
a862 1
 * parse then given data chunk, and calling imsg() for each message
d873 1
a873 1
			/* we don't use reat-time events */
d1359 1
a1359 1
			log_puts("at least of -i and -o required\n");
@


1.147
log
@fix macro breakage and update usage();
@
text
@a919 1
			s->pstate = SLOT_INIT;
d926 1
@


1.146
log
@Simplify internals and rewrite file header parsing code:
- remove -M, -t, -w, -C, -x flags that don't make sense anymore
- make "-j off" the default (sndiod already does the job)
- don't limit the number of played/recorded files.
- add support for floating-point encoded files.
- add support for apple .aiff and sun/next .au files
@
text
@d136 3
a138 3
char usagestr[] = "usage: aucat [-d] [-b nframes] "
    "[-c min:max] [-e enc] [-f device]\n\t"
    "[-j flag] [-q port] [-r rate] [-v volume]\n";
@


1.145
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@a0 1
/*	$OpenBSD: aucat.c,v 1.144 2013/11/18 17:51:59 ratchov Exp $	*/
d2 1
a2 1
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
d17 1
a17 6
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/resource.h>

#include <err.h>
d19 1
a19 4
#include <fcntl.h>
#include <grp.h>
#include <limits.h>
#include <pwd.h>
d26 356
d383 10
a392 8
#include "abuf.h"
#include "amsg.h"
#include "aparams.h"
#include "aproc.h"
#include "conf.h"
#include "dev.h"
#include "midi.h"
#include "wav.h"
d394 4
a397 1
#include "dbg.h"
d399 1
d401 4
a404 1
#define PROG_AUCAT	"aucat"
d406 8
a413 5
/*
 * sample rate if no ``-r'' is used
 */
#ifndef DEFAULT_RATE
#define DEFAULT_RATE	48000
d415 66
d483 3
a485 1
 * block size if neither ``-z'' nor ``-b'' is used
d487 15
a501 2
#ifndef DEFAULT_ROUND
#define DEFAULT_ROUND	960
d503 45
d550 2
a551 1
 * buffer size if neither ``-z'' nor ``-b'' is used
d553 12
a564 2
#ifndef DEFAULT_BUFSZ
#define DEFAULT_BUFSZ	7860
d566 101
d668 17
a684 12
void sigint(int);
void sigusr1(int);
void sigusr2(int);
void opt_ch(struct aparams *);
void opt_enc(struct aparams *);
int opt_hdr(void);
int opt_mmc(void);
int opt_onoff(void);
int opt_xrun(void);
void setsig(void);
void unsetsig(void);
struct dev *mkdev(char *, int, int, int, int, int);
d686 5
d692 5
a696 1
volatile sig_atomic_t debug_level = 1;
d698 1
a698 1
volatile sig_atomic_t quit_flag = 0;
d700 23
a722 4
char aucat_usage[] = "usage: " PROG_AUCAT " [-dMn]\n\t"
    "[-C min:max] [-c min:max] [-e enc] [-f device]\n\t"
    "[-h fmt] [-i file] [-j flag] [-o file] [-q port]\n\t"
    "[-r rate] [-t mode] [-v volume] [-w flag] [-x policy]\n";
d725 1
a725 3
 * SIGINT handler, it raises the quit flag. If the flag is already set,
 * that means that the last SIGINT was not handled, because the process
 * is blocked somewhere, so exit.
d727 2
a728 2
void
sigint(int s)
d730 16
a745 3
	if (quit_flag)
		_exit(1);
	quit_flag = 1;
d748 16
d765 6
d772 1
a772 1
 * Increase debug level on SIGUSR1.
d774 2
a775 2
void
sigusr1(int s)
d777 82
a858 2
	if (debug_level < 4)
		debug_level++;
d862 1
a862 1
 * Decrease debug level on SIGUSR2.
d864 2
a865 2
void
sigusr2(int s)
d867 39
a905 2
	if (debug_level > 0)
		debug_level--;
a906 1
#endif
d908 2
a909 2
void
opt_ch(struct aparams *par)
d911 2
a912 2
	char *next, *end;
	long cmin, cmax;
d914 20
a933 14
	errno = 0;
	cmin = strtol(optarg, &next, 10);
	if (next == optarg || *next != ':')
		goto failed;
	cmax = strtol(++next, &end, 10);
	if (end == next || *end != '\0')
		goto failed;
	if (cmin < 0 || cmax < cmin || cmax > NCHAN_MAX)
		goto failed;
	par->cmin = cmin;
	par->cmax = cmax;
	return;
failed:
	errx(1, "%s: bad channel range", optarg);
d936 2
a937 2
void
opt_enc(struct aparams *par)
d939 2
a940 1
	int len;
d942 8
a949 3
	len = aparams_strtoenc(par, optarg);
	if (len == 0 || optarg[len] != '\0')
		errx(1, "%s: bad encoding", optarg);
d952 2
a953 2
int
opt_hdr(void)
d955 10
a964 7
	if (strcmp("auto", optarg) == 0)
		return HDR_AUTO;
	if (strcmp("raw", optarg) == 0)
		return HDR_RAW;
	if (strcmp("wav", optarg) == 0)
		return HDR_WAV;
	errx(1, "%s: bad header specification", optarg);
d967 2
a968 2
int
opt_mmc(void)
d970 36
a1005 5
	if (strcmp("off", optarg) == 0)
		return 0;
	if (strcmp("slave", optarg) == 0)
		return 1;
	errx(1, "%s: bad MMC mode", optarg);
d1008 2
a1009 2
int
opt_onoff(void)
d1011 44
a1054 5
	if (strcmp("off", optarg) == 0)
		return 0;
	if (strcmp("on", optarg) == 0)
		return 1;
	errx(1, "%s: bad join/expand setting", optarg);
d1057 2
a1058 2
int
opt_xrun(void)
d1060 3
a1062 7
	if (strcmp("ignore", optarg) == 0)
		return XRUN_IGNORE;
	if (strcmp("sync", optarg) == 0)
		return XRUN_SYNC;
	if (strcmp("error", optarg) == 0)
		return XRUN_ERROR;
	errx(1, "%s: bad underrun/overrun policy", optarg);
d1065 2
a1066 2
void
setsig(void)
d1068 2
d1071 18
d1094 144
a1237 14
	if (sigaction(SIGINT, &sa, NULL) < 0)
		err(1, "sigaction(int) failed");
	if (sigaction(SIGTERM, &sa, NULL) < 0)
		err(1, "sigaction(term) failed");
	if (sigaction(SIGHUP, &sa, NULL) < 0)
		err(1, "sigaction(hup) failed");
#ifdef DEBUG
	sa.sa_handler = sigusr1;
	if (sigaction(SIGUSR1, &sa, NULL) < 0)
		err(1, "sigaction(usr1) failed");
	sa.sa_handler = sigusr2;
	if (sigaction(SIGUSR2, &sa, NULL) < 0)
		err(1, "sigaction(usr2) failed1n");
#endif
d1240 2
a1241 2
void
unsetsig(void)
d1243 1
a1243 1
	struct sigaction sa;
d1245 11
a1255 45
	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = SIG_DFL;
#ifdef DEBUG
	if (sigaction(SIGUSR2, &sa, NULL) < 0)
		err(1, "unsetsig(usr2): sigaction failed");
	if (sigaction(SIGUSR1, &sa, NULL) < 0)
		err(1, "unsetsig(usr1): sigaction failed");
#endif
	if (sigaction(SIGHUP, &sa, NULL) < 0)
		err(1, "unsetsig(hup): sigaction failed\n");
	if (sigaction(SIGTERM, &sa, NULL) < 0)
		err(1, "unsetsig(term): sigaction failed\n");
	if (sigaction(SIGINT, &sa, NULL) < 0)
		err(1, "unsetsig(int): sigaction failed\n");
}

struct dev *
mkdev(char *path, int mode, int bufsz, int round, int hold, int autovol)
{
	struct dev *d;

	if (path) {
		for (d = dev_list; d != NULL; d = d->next) {
			if (d->reqmode & (MODE_LOOP | MODE_THRU))
				continue;
			if (strcmp(d->path, path) == 0)
				return d;
		}
	} else {
		if (dev_list)
			return dev_list;
		path = SIO_DEVANY;
	}
	if (!bufsz && !round) {
		round = DEFAULT_ROUND;
		bufsz = DEFAULT_BUFSZ;
	} else if (!bufsz) {
		bufsz = round * 2;
	} else if (!round)
		round = bufsz / 2;
	d = dev_new(path, mode, bufsz, round, hold, autovol);
	if (d == NULL)
		exit(1);
	return d;
d1261 7
a1267 18
	int c, active;
	unsigned int mode, hdr, xrun, rate, join, mmc, vol;
	unsigned int hold, autovol, bufsz, round;
	const char *str;
	struct aparams ppar, rpar;
	struct dev *d, *dnext;
	struct wav *w;

	/*
	 * global options defaults
	 */
	hdr = HDR_AUTO;
	xrun = XRUN_IGNORE;
	vol = MIDI_MAXCTL;
	join = 1;
	mmc = 0;
	hold = 0;
	autovol = 1;
d1269 11
a1279 13
	round = 0;
	aparams_init(&ppar, 0, 1, DEFAULT_RATE);
	aparams_init(&rpar, 0, 1, DEFAULT_RATE);
	mode = MODE_MIDIMASK | MODE_PLAY | MODE_REC;

#ifdef DEBUG
	atexit(dbg_flush);
#endif
	setsig();
	filelist_init();

	while ((c = getopt(argc, argv,
		    "a:b:c:C:de:f:h:i:j:Mno:q:r:t:v:w:x:z:")) != -1) {
d1281 3
a1283 17
		case 'd':
#ifdef DEBUG
			if (debug_level < 4)
				debug_level++;
#endif
			break;
		case 'h':
			hdr = opt_hdr();
			break;
		case 'x':
			xrun = opt_xrun();
			break;
		case 'j':
			join = opt_onoff();
			break;
		case 't':
			mmc = opt_mmc();
d1286 2
a1287 1
			opt_ch(&ppar);
d1289 2
a1290 2
		case 'C':
			opt_ch(&rpar);
d1293 2
a1294 2
			opt_enc(&ppar);
			aparams_copyenc(&rpar, &ppar);
d1296 2
a1297 5
		case 'r':
			rate = strtonum(optarg, RATE_MIN, RATE_MAX, &str);
			if (str)
				errx(1, "%s: rate is %s", optarg, str);
			ppar.rate = rpar.rate = rate;
d1299 3
a1301 4
		case 'v':
			vol = strtonum(optarg, 0, MIDI_MAXCTL, &str);
			if (str)
				errx(1, "%s: volume is %s", optarg, str);
d1304 4
a1307 16
			d = mkdev(NULL, 0, bufsz, round, 1, autovol);
			w = wav_new_in(&wav_ops, d,
			    mode & (MODE_PLAY | MODE_MIDIOUT), optarg,
			    hdr, &ppar, xrun, vol, mmc, join);
			if (w == NULL)
				errx(1, "%s: couldn't create stream", optarg);
			dev_adjpar(d, w->mode, NULL, &w->hpar);
			break;
		case 'o':	
			d = mkdev(NULL, 0, bufsz, round, 1, autovol);
			w = wav_new_out(&wav_ops, d,
			    mode & (MODE_RECMASK | MODE_MIDIIN), optarg,
			    hdr, &rpar, xrun, mmc, join);
			if (w == NULL)
				errx(1, "%s: couldn't create stream", optarg);
			dev_adjpar(d, w->mode, &w->hpar, NULL);
d1309 3
a1311 5
		case 'q':
			d = mkdev(NULL, mode, bufsz, round, 1, autovol);
			if (!devctl_add(d, optarg, MODE_MIDIMASK))
				errx(1, "%s: can't open port", optarg);
			d->reqmode |= MODE_MIDIMASK;
d1313 2
a1314 2
		case 'w':
			autovol = opt_onoff();
d1316 5
a1320 9
		case 'b':
			bufsz = strtonum(optarg, 1, RATE_MAX * 5, &str);
			if (str)
				errx(1, "%s: buffer size is %s", optarg, str);
			break;
		case 'z':
			round = strtonum(optarg, 1, SHRT_MAX, &str);
			if (str)
				errx(1, "%s: block size is %s", optarg, str);
d1322 2
a1323 2
		case 'f':
			mkdev(optarg, 0, bufsz, round, hold, autovol);
d1325 3
a1327 2
		case 'n':
			mkdev("loopback", MODE_LOOP, bufsz, round, 1, autovol);
d1329 3
a1331 2
		case 'M':
			mkdev("midithru", MODE_THRU, 0, 0, hold, 0);
d1334 1
a1334 2
			fputs(aucat_usage, stderr);
			exit(1);
d1339 9
a1347 11
	if (argc > 0) {
		fputs(aucat_usage, stderr);
		exit(1);
	}
	if (wav_list) {
		if ((d = dev_list) && d->next)
			errx(1, "only one device allowed");
		if ((d->reqmode & MODE_THRU) && d->ctl_list == NULL) {
			if (!devctl_add(d, "default", MODE_MIDIMASK))
				errx(1, "%s: can't open port", optarg);
			d->reqmode |= MODE_MIDIMASK;
d1349 6
d1356 8
a1363 2
		fputs(aucat_usage, stderr);
		exit(1);
a1364 46
	for (w = wav_list; w != NULL; w = w->next) {
		if (!wav_init(w))
			exit(1);
	}
	for (d = dev_list; d != NULL; d = d->next) {
		if (!dev_init(d))
			exit(1);
		if (d->autostart && (d->mode & MODE_AUDIOMASK))
			dev_mmcstart(d);
	}

	/*
	 * Loop, start audio.
	 */
	for (;;) {
		if (quit_flag)
			break;
		active = 0;
		for (d = dev_list; d != NULL; d = dnext) {
			dnext = d->next;
			if (!dev_run(d))
				goto fatal;
			if (d->refcnt > 0)
				active = 1;
		}
		if (dev_list == NULL)
			break;
		if (!active)
			break;
		if (!file_poll())
			break;
	}
  fatal:

	/*
	 * give a chance to drain
	 */
	for (d = dev_list; d != NULL; d = d->next)
		dev_drain(d);
	while (file_poll())
		; /* nothing */

	while (dev_list)
		dev_del(dev_list);
	filelist_done();
	unsetsig();
@


1.144
log
@remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d17 1
a17 1
#include <sys/param.h>
@


1.143
log
@add missing prototypes
@
text
@d285 1
a285 1
	int c, background, unit, active;
a304 2
	unit = 0;
	background = 0;
a322 1
			background = 0;
@


1.142
log
@remove bogus legacy server-specific bits that cause confusion
@
text
@d71 13
@


1.141
log
@Remove server capability description from the documentation and from
the usage string, and just say that for historic reasons aucat behaves
like sndiod.
with help from jmc@@
@
text
@a41 1
#include "listen.h"
a42 1
#include "opt.h"
a47 14
/*
 * unprivileged user name
 */
#ifndef SNDIO_USER
#define SNDIO_USER	"_sndio"
#endif

/*
 * priority when run as root
 */
#ifndef SNDIO_PRIO
#define SNDIO_PRIO	(-20)
#endif

a48 1
#define PROG_SNDIOD	"sndiod"
a70 7
/*
 * default device in server mode
 */
#ifndef DEFAULT_DEV
#define DEFAULT_DEV "rsnd/0"
#endif

d76 1
a76 1
char aucat_usage[] = "usage: " PROG_AUCAT " [-dMn] "
d78 1
a78 1
    "[-h fmt] [-i file] [-j flag] [-m mode] [-o file] [-q port]\n\t"
a80 6
char sndiod_usage[] = "usage: " PROG_SNDIOD " [-dM] [-a flag] [-b nframes] "
    "[-C min:max] [-c min:max] [-e enc]\n\t"
    "[-f device] [-j flag] [-L addr] [-m mode] [-q port] [-r rate]\n\t"
    "[-s name] [-t mode] [-U unit] [-v volume] [-w flag] [-x policy]\n\t"
    "[-z nframes]\n";

a191 28
unsigned int
opt_mode(void)
{
	unsigned int mode = 0;
	char *p = optarg;
	size_t len;

	for (p = optarg; *p != '\0'; p++) {
		len = strcspn(p, ",");
		if (strncmp("play", p, len) == 0) {
			mode |= MODE_PLAY;
		} else if (strncmp("rec", p, len) == 0) {
			mode |= MODE_REC;
		} else if (strncmp("mon", p, len) == 0) {
			mode |= MODE_MON;
		} else if (strncmp("midi", p, len) == 0) {
			mode |= MODE_MIDIMASK;
		} else 
			errx(1, "%s: bad mode", optarg);
		p += len;
		if (*p == '\0')
			break;
	}
	if (mode == 0)
		errx(1, "empty mode");
	return mode;
}

a238 40
void
getbasepath(char *base, size_t size)
{
	uid_t uid;
	struct stat sb;
	mode_t mask;

	uid = geteuid();
	if (uid == 0) {
		mask = 022;
		snprintf(base, PATH_MAX, "/tmp/aucat");
	} else {
		mask = 077;
		snprintf(base, PATH_MAX, "/tmp/aucat-%u", uid);
	}
	if (mkdir(base, 0777 & ~mask) < 0) {
		if (errno != EEXIST)
			err(1, "mkdir(\"%s\")", base);
	}
	if (stat(base, &sb) < 0)
		err(1, "stat(\"%s\")", base);
	if (sb.st_uid != uid || (sb.st_mode & mask) != 0)
		errx(1, "%s has wrong permissions", base);
}

void
privdrop(void)
{
	struct passwd *pw;

	if ((pw = getpwnam(SNDIO_USER)) == NULL)
		errx(1, "unknown user %s", SNDIO_USER);
	if (setpriority(PRIO_PROCESS, 0, SNDIO_PRIO) < 0)
		err(1, "setpriority");
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		err(1, "cannot drop privileges");
}

a268 19
struct opt *
mkopt(char *path, struct dev *d, struct aparams *rpar, struct aparams *ppar,
    int mode, int vol, int mmc, int join)
{
	struct opt *o;

	if (d->reqmode & MODE_LOOP)
		errx(1, "%s: can't attach to loopback", path);
	if (d->reqmode & MODE_THRU)
		mode = MODE_MIDIMASK;
	if (!rpar->rate)
		ppar->rate = rpar->rate = DEFAULT_RATE;
	o = opt_new(path, d, rpar, ppar, MIDI_TO_ADATA(vol), mmc, join, mode);
	if (o == NULL)
		errx(1, "%s: couldn't create subdev", path);
	dev_adjpar(d, o->mode, rpar, ppar);
	return o;
}

a271 1
	char *prog, *optstr, *usagestr;
a272 1
	char base[PATH_MAX], path[PATH_MAX];
a277 1
	struct listen *l;
d304 2
a305 17
	prog = strrchr(argv[0], '/');
	if (prog == NULL)
		prog = argv[0];
	else
		prog++;
	if (strcmp(prog, PROG_AUCAT) == 0) {
 		optstr = "a:b:c:C:de:f:h:i:j:L:m:Mno:q:r:s:t:U:v:w:x:z:";
		usagestr = aucat_usage;
		hold = 1;
	} else if (strcmp(prog, PROG_SNDIOD) == 0) {
		optstr = "a:b:c:C:de:f:j:L:m:Mq:r:s:t:U:v:w:x:z:";
		usagestr = sndiod_usage;
		background = 1;
	} else
		errx(1, "%s: can't determine program to run", prog);

	while ((c = getopt(argc, argv, optstr)) != -1) {
a313 13
		case 'U':
			if (listen_list)
				errx(1, "-U must come before -L");
			unit = strtonum(optarg, 0, MIDI_MAXCTL, &str);
			if (str)
				errx(1, "%s: unit number is %s", optarg, str);
			break;
		case 'L':
			listen_new_tcp(optarg, AUCAT_PORT + unit);
			break;
		case 'm':
			mode = opt_mode();
			break;
a364 8
		case 's':
			if ((d = dev_list) == NULL) {
				d = mkdev(DEFAULT_DEV, 0, bufsz, round,
				    hold, autovol);
			}
			mkopt(optarg, d, &rpar, &ppar, mode, vol, mmc, join);
			/* XXX: set device rate, if never set */
			break;
a370 3
		case 'a':
			hold = opt_onoff();
			break;
d394 1
a394 1
			fputs(usagestr, stderr);
d401 1
a401 1
		fputs(usagestr, stderr);
a404 2
		if (opt_list || listen_list)
			errx(1, "-io not allowed in server mode");
d406 1
a406 1
			errx(1, "only one device allowed in non-server mode");
d413 2
a414 14
		if (dev_list == NULL)
			mkdev(DEFAULT_DEV, 0, bufsz, round, hold, autovol);
		for (d = dev_list; d != NULL; d = d->next) {
			if (opt_byname("default", d->num))
				continue;
			mkopt("default", d, &rpar, &ppar, mode, vol, mmc, join);
		}
	}
	if (opt_list) {
		getbasepath(base, sizeof(base));
		snprintf(path, PATH_MAX, "%s/%s%u", base, AUCAT_PATH, unit);
		listen_new_un(path);
		if (geteuid() == 0)
			privdrop();
a425 12
	for (l = listen_list; l != NULL; l = l->next) {
		if (!listen_init(l))
			exit(1);
	}
	if (background) {
#ifdef DEBUG
		debug_level = 0;
		dbg_flush();
#endif
		if (daemon(0, 0) < 0)
			err(1, "daemon");
	}
d443 1
a443 1
		if (!opt_list && !active)
a448 2
	while (listen_list != NULL)
		file_close(&listen_list->file);
a460 4
	if (opt_list) {
		if (rmdir(base) < 0 && errno != ENOTEMPTY && errno != EPERM)
			warn("rmdir(\"%s\")", base);
	}
@


1.140
log
@Since there's no sndiod -> aucat link anymore, allow aucat to be run
in server mode even when not invoked as sndiod. This allows aucat and
the new sndiod daemon to live together in /usr/bin, which makes easy
to quickly compare sndiod and aucat (and spot possible regressions)
without having to modify /usr/bin.
@
text
@d100 4
a103 5
char aucat_usage[] = "usage: " PROG_AUCAT " [-dlMn] [-a flag] [-b nframes] "
    "[-C min:max] [-c min:max] [-e enc]\n\t"
    "[-f device] [-h fmt] [-i file] [-j flag] [-m mode] [-o file]\n\t"
    "[-q port] [-r rate] [-t mode] [-v volume] [-w flag] [-x policy]\n\t"
    "[-z nframes]\n";
d430 1
a430 1
 		optstr = "a:b:c:C:de:f:h:i:j:lL:m:Mno:q:r:s:t:U:v:w:x:z:";
@


1.139
log
@don't stat & test sndio home directory since we never use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.138 2012/10/27 08:36:36 ratchov Exp $	*/
d100 1
a100 1
char aucat_usage[] = "usage: " PROG_AUCAT " [-dn] [-b nframes] "
d431 1
a431 1
		optstr = "b:c:C:de:f:h:i:j:m:no:q:r:t:v:w:x:z:";
d433 1
a437 1
		hold = 0;
@


1.138
log
@don't (re-)define SNDIO_USER and SNDIO_PRIO if they are already defined,
this way they can be defined at compilation time
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.137 2012/06/27 06:53:13 ratchov Exp $	*/
a326 1
	struct stat sb;
a329 4
	if (stat(pw->pw_dir, &sb) < 0)
		err(1, "stat(\"%s\")", pw->pw_dir);
	if (sb.st_uid != 0 || (sb.st_mode & 022) != 0)
		errx(1, "%s has wrong permissions", pw->pw_dir);
@


1.137
log
@Uniformize error messages printing, use err() instead of fprintf()
when appropriate. From Michael W. Bombardieri <mb at ii.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.136 2012/06/19 20:03:29 ratchov Exp $	*/
d26 1
d53 1
d55 1
d60 1
d62 1
@


1.136
log
@Remove hidden options that are not needed any more,
from Remco <remco at d-compu.dyndns.org>. Thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.135 2012/05/23 19:25:11 ratchov Exp $	*/
d438 2
a439 4
	} else {
		fprintf(stderr, "%s: can't determine program to run\n", prog);
		return 1;
	}
@


1.135
log
@Make the "default" string a valid device name that has the same effect
as NULL has. This will (hopefully) simplify ports where the user
passes the device string.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.134 2012/04/11 06:05:43 ratchov Exp $	*/
d431 1
a431 1
		optstr = "a:b:c:C:de:f:h:i:j:lL:m:Mno:q:r:s:t:U:v:w:x:z:";
a553 3
			break;
		case 'l':
			background = 1;
@


1.134
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.133 2012/02/09 18:33:36 ratchov Exp $	*/
d29 1
d353 1
a353 1
		path = "default";
@


1.133
log
@Crank the default buffer size to 160ms (ie 7680 frames at 48kHz).
Workarounds stuttering caused by something hogging the cpu in kernel
mode and preventing sndiod from running at time.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.132 2012/01/26 09:07:03 ratchov Exp $	*/
d217 1
a217 1
unsigned
d220 1
a220 1
	unsigned mode = 0;
d392 2
a393 2
	unsigned mode, hdr, xrun, rate, join, mmc, vol;
	unsigned hold, autovol, bufsz, round;
@


1.132
log
@Make the default rate 48kHz and the default block size 10ms. These
settings ensure video players and programs using MTC are smooth by
default. Thanks to all who tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.131 2012/01/10 08:04:19 ratchov Exp $	*/
d69 1
a69 1
 * block size if no ``-z'' is used
d72 8
a79 1
#define DEFAULT_ROUND	(48000 / 100)
d354 4
a357 3
	if (!bufsz) {
		if (!round)
			round = DEFAULT_ROUND;
@


1.131
log
@When a sub-device is created (-s), check if a hardware
device was already created (-f) before trying to use the
default one, otherwise all sub-devices end up attached
to the default device. Noticed by peters at schwertfisch.de,
thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.130 2011/12/09 22:56:35 ratchov Exp $	*/
d65 1
a65 1
#define DEFAULT_RATE	44100
d72 1
a72 1
#define DEFAULT_ROUND	(44100 / 15)
d350 1
a350 1
		bufsz = round * 4;
d352 1
a352 1
		round = bufsz / 4;
@


1.130
log
@fix usage string: remove -M from aucat and -l from aucat and sndiod
from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.129 2011/12/09 14:36:42 ratchov Exp $	*/
d508 5
a512 3
			d = mkdev(DEFAULT_DEV, 0, bufsz, round, 1, autovol);
			mkopt(optarg, d, &rpar, &ppar,
			    mode, vol, mmc, join);
@


1.129
log
@add a new sndiod audio/midi daemon and hide aucat server-specific
options.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.128 2011/12/02 12:45:29 ratchov Exp $	*/
d87 1
a87 1
char aucat_usage[] = "usage: " PROG_AUCAT " [-dlMn] [-b nframes] "
d93 1
a93 1
char sndiod_usage[] = "usage: " PROG_SNDIOD " [-dlM] [-a flag] [-b nframes] "
@


1.128
log
@don't use a "server" flag, just check if we expose sub-devices
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.127 2011/12/02 10:34:50 ratchov Exp $	*/
d59 1
d87 1
a87 1
char aucat_usage[] = "usage: " PROG_AUCAT " [-dlMn] [-a flag] [-b nframes] "
d89 9
a97 4
    "[-f device] [-h fmt] [-i file] [-j flag] [-L addr] [-m mode] "
    "[-o file]\n\t"
    "[-q port] [-r rate] [-s name] [-t mode] [-U unit] [-v volume]\n\t"
    "[-w flag] [-x policy] [-z nframes]\n";
d424 5
d441 1
d508 1
a508 1
			d = mkdev(NULL, 0, bufsz, round, 1, autovol);
@


1.127
log
@reuse midi-control code to implement midi thru boxes and remove
the old midithru implementation; less code, less bugs. As a side
effect, midi output doesn't implement running status "compression"
any more.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.126 2011/11/20 22:54:51 ratchov Exp $	*/
d376 1
a376 1
	int c, background, unit, server, active;
a402 1
	server = 0;
d432 2
a433 2
			if (server)
				errx(1, "-U must come before server options");
a436 1
			server = 1;
a439 1
			server = 1;
a499 1
			server = 1;
d547 1
a547 1
		if (server)
a562 1
			server = 1;
d565 1
a565 1
	if (server) {
d611 1
a611 1
		if (!server && !active)
d631 1
a631 1
	if (server) {
@


1.126
log
@Move mmc/mtc and volume control bits from struct aproc to struct
dev. Allows volume settings to be saved while the device is kept
closed. Besides that, no behabiour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.125 2011/11/15 08:05:22 ratchov Exp $	*/
d534 1
a534 1
			mkdev("midithru", MODE_THRU, 0, 0, 1, 0);
d611 1
a611 1
			if (!dev_idle(d))
@


1.125
log
@Add a "device number" component in sndio(7) device names, allowing a
single aucat instance to handle all audio and MIDI services. Since
this partially breaks compatibility, this is a opportunitiy to fix few
other design mistakes (eg ':' being used by inet6, type name vs api
name confusion, etc..). This leads to the following names:

        type[@@hostname][,unit]/devnum[.option]

The device number is the minor device number for direct hardware
access (ie the 'N' in /dev/audioN). For aucat, this is the occurence
number of the -f (or -M) option.

There's a compatibility hook to keep old names working if only one
aucat server is running.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.124 2011/10/18 21:04:26 ratchov Exp $	*/
d585 1
a585 1
			ctl_start(d->midi);
d611 1
a611 2
			if ((d->mode & MODE_THRU) ||
			    (d->pstate != DEV_CLOSED && !ctl_idle(d->midi)))
@


1.124
log
@keep the device closed by default (when not used)
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.123 2011/10/18 18:40:32 ratchov Exp $	*/
d74 7
d347 4
a350 1
	return dev_new(path, mode, bufsz, round, hold, autovol);
d550 6
a555 10
	if (wav_list == NULL) {
		if (opt_list == NULL) {
			d = mkdev(NULL, 0, bufsz, round, 1, autovol);
			mkopt("default", d, &rpar, &ppar,
			    mode, vol, mmc, join);
			server = 1;
		}
	} else {
		d = mkdev(NULL, 0, bufsz, round, 1, autovol);
		if ((d->reqmode & MODE_THRU) && !d->ctl_list) {
d559 9
@


1.123
log
@remove duplicate options in getopt() string
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.122 2011/10/17 21:09:11 ratchov Exp $	*/
d382 1
a382 1
	hold = join = autovol = 1;
d384 2
@


1.122
log
@Remove midicat since aucat can now be used instead of midicat
with almost the same syntax (roughly an extra -M option).
Thru boxes are created with aucat, and corresponding MIDI port
names have the "aucat" prefix instead of "midithru". The old
device name will still work some time for backward compatibility.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.121 2011/10/12 12:16:10 jmc Exp $	*/
d390 1
d405 1
a405 2
		mode = MODE_MIDIMASK | MODE_PLAY | MODE_REC;
		optstr = "a:b:c:C:de:f:h:i:j:lL:m:Mno:q:r:s:t:U:v:w:x:z:t:j:z:";
@


1.121
log
@- avoid line wrapping an example
- sort usage() for midicat
- tweak a bit of unclear wording

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.120 2011/10/12 07:20:03 ratchov Exp $	*/
a58 1
#define PROG_MIDICAT	"midicat"
a85 4
char midicat_usage[] = "usage: " PROG_MIDICAT " [-dlM] [-a flag] "
    "[-i file] [-L addr] [-o file] [-q port]\n\t"
    "[-s name] [-U unit]\n";

d365 2
a366 2
	char *prog, *un_path, *optstr, *usagestr;
	int c, background, unit, server, tcp_port, active;
a406 9
		un_path = AUCAT_PATH;
		tcp_port = AUCAT_PORT;
	} else if (strcmp(prog, PROG_MIDICAT) == 0) {
		mode = MODE_MIDIMASK | MODE_THRU;
		optstr = "a:di:lL:Mo:q:s:U:";
		usagestr = midicat_usage;
		un_path = MIDICAT_PATH;
		tcp_port = MIDICAT_PORT;
		mkdev("midithru", MODE_THRU, 0, 0, 1, 0);
a411 1

d429 1
a429 1
			listen_new_tcp(optarg, tcp_port + unit);
d555 1
a555 1
		snprintf(path, PATH_MAX, "%s/%s%u", base, un_path, unit);
@


1.120
log
@Simplify and improve the way options are parsed and remove ~300 lines
of code that becomes unused. Few command line arguments changes are
required though:

  - stream definitions (-ios) now must follow devices definitions they
    are attached to (-fMn)

  - the -n option is now a special "loopback" device and is thus used
    like -f, eg it must precede streams

  - in midicat, midi thru boxes are not created automatically anymore,
    the new "-M" option must be used for that

  - channel numbers (-Cc options) correspond always to channel numbers
    of the hardware.

  - the -u option isn't needed anymore

  - increase the log verbosity so user errors are logged
    without using -d

tested by many, help from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.119 2011/06/29 07:39:02 ratchov Exp $	*/
d88 2
a89 2
    "[-i file] [-L addr] [-s name] [-o file]\n\t"
    "[-q port] [-U unit]\n";
@


1.119
log
@make -u flag per-device similarly to -a and -w
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.118 2011/06/20 20:18:44 ratchov Exp $	*/
d68 7
d76 1
a76 1
volatile sig_atomic_t debug_level = 0;
d80 11
d217 2
a218 3
		} else if (strncmp("duplex", p, len) == 0) {
			/* XXX: backward compat, remove this */
			mode |= MODE_REC | MODE_PLAY;
a229 157
/*
 * stream configuration
 */
struct cfstr {
	SLIST_ENTRY(cfstr) entry;
	unsigned mode;			/* bitmap of MODE_XXX */
	struct aparams ipar;		/* input (read) parameters */
	struct aparams opar;		/* output (write) parameters */
	unsigned vol;			/* last requested volume */
	int hdr;			/* header format */
	int xrun;			/* overrun/underrun policy */
	int mmc;			/* MMC mode */
	int join;			/* join/expand enabled */
	char *path;			/* static path (no need to copy it) */
};

SLIST_HEAD(cfstrlist, cfstr);

/*
 * midi device (control stream)
 */
struct cfmid {
	SLIST_ENTRY(cfmid) entry;
	char *path;			/* static path (no need to copy it) */
};

SLIST_HEAD(cfmidlist, cfmid);

/*
 * audio device configuration
 */
struct cfdev {
	SLIST_ENTRY(cfdev) entry;
	struct cfstrlist ins;		/* files to play */
	struct cfstrlist outs;		/* files to record */
	struct cfstrlist opts;		/* subdevices to expose */
	struct cfmidlist mids;		/* midi ports to subscribe */
	struct aparams ipar;		/* input (read) parameters */
	struct aparams opar;		/* output (write) parameters */
	unsigned hold;			/* open immediately */
	unsigned autovol;		/* adjust volumes */
	unsigned autopar;		/* adjust parameters to streams */
	unsigned bufsz;			/* par.bufsz for sio device */
	unsigned round;			/* par.round for sio device */
	unsigned mode;			/* bitmap of MODE_XXX */
	char *path;			/* static path (no need to copy it) */
};

SLIST_HEAD(cfdevlist, cfdev);

/*
 * local network addresse to listen on
 */
struct cfnet {
	SLIST_ENTRY(cfnet) entry;
	char *addr;
};

SLIST_HEAD(cfnetlist, cfnet);

struct cfdev *
cfdev_new(struct cfdev *templ)
{
	struct cfdev *cd;

	cd = malloc(sizeof(struct cfdev));
	if (cd == NULL) {
		perror("malloc");
		abort();
	}
	if (templ)
		memcpy(cd, templ, sizeof(struct cfdev));
	else {
		aparams_init(&cd->ipar, 0, 1, DEFAULT_RATE);
		aparams_init(&cd->opar, 0, 1, DEFAULT_RATE);
		cd->bufsz = 0;
		cd->round = 0;
		cd->hold = 1;
		cd->autovol = 1;
		cd->autopar = 1;
	}
	SLIST_INIT(&cd->ins);
	SLIST_INIT(&cd->outs);
	SLIST_INIT(&cd->opts);
	SLIST_INIT(&cd->mids);
	cd->path = NULL;
	return cd;
}

void
cfdev_add(struct cfdevlist *list, struct cfdev *cd, char *path)
{
	cd->path = path;
	SLIST_INSERT_HEAD(list, cd, entry);
}

struct cfstr *
cfstr_new(struct cfstr *templ)
{
	struct cfstr *cs;

	cs = malloc(sizeof(struct cfstr));
	if (cs == NULL) {
		perror("malloc");
		abort();
	}
	if (templ)
		memcpy(cs, templ, sizeof(struct cfstr));
	else {
		aparams_init(&cs->ipar, 0, 1, DEFAULT_RATE);
		aparams_init(&cs->opar, 0, 1, DEFAULT_RATE);
		cs->mmc = 0;
		cs->hdr = HDR_AUTO;
		cs->xrun = XRUN_IGNORE;
		cs->vol = MIDI_MAXCTL;
		cs->mode = MODE_PLAY | MODE_REC;
		cs->join = 1;
	}
	cs->path = NULL;
	return cs;
}

void
cfstr_add(struct cfstrlist *list, struct cfstr *cs, char *path)
{
	cs->path = path;
	SLIST_INSERT_HEAD(list, cs, entry);
}

void
cfmid_add(struct cfmidlist *list, char *path)
{
	struct cfmid *cm;

	cm = malloc(sizeof(struct cfmid));
	if (cm == NULL) {
		perror("malloc");
		abort();
	}
	cm->path = path;
	SLIST_INSERT_HEAD(list, cm, entry);
}

void
cfnet_add(struct cfnetlist *list, char *addr)
{
	struct cfnet *cn;

	cn = malloc(sizeof(struct cfnet));
	if (cn == NULL) {
		perror("malloc");
		abort();
	}
	cn->addr = addr;
	SLIST_INSERT_HEAD(list, cn, entry);
}

d322 2
a323 2
void
aucat_usage(void)
d325 40
a364 8
	(void)fputs("usage: " PROG_AUCAT " [-dln] [-a flag] [-b nframes] "
	    "[-C min:max] [-c min:max] [-e enc]\n\t"
	    "[-f device] [-h fmt] [-i file] [-j flag] [-L addr] [-m mode] "
	    "[-o file]\n\t"
	    "[-q device] [-r rate] [-s name] [-t mode] [-U unit] "
	    "[-u flag]\nt"
	    "[-v volume] [-w flag] [-x policy] [-z nframes]\n",
	    stderr);
d368 1
a368 1
aucat_main(int argc, char **argv)
d370 2
a371 7
	struct cfdevlist cfdevs;
	struct cfnetlist cfnets;
	struct cfmid *cm;
	struct cfstr *cs;
	struct cfdev *cd;
	struct cfnet *cn;
	int c, d_flag, l_flag, n_flag, unit;
d373 2
a374 1
	unsigned mode, rate;
d376 1
a376 1
	int autostart;
d378 2
a379 2
	unsigned active;
	unsigned nsock;
d384 41
a424 7
	unit = -1;
	d_flag = 0;
	l_flag = 0;
	n_flag = 0;
	SLIST_INIT(&cfdevs);
	SLIST_INIT(&cfnets);
	nsock = 0;
a425 5
	/*
	 * default device and stream
	 */
	cd = cfdev_new(NULL);
	cs = cfstr_new(NULL);
d427 1
a427 1
	while ((c = getopt(argc, argv, "a:w:dnb:c:C:e:r:h:x:v:i:o:f:m:lu:q:s:U:L:t:j:z:")) != -1) {
d431 1
a431 1
			if (d_flag)
a433 4
			d_flag = 1;
			break;
		case 'n':
			n_flag = 1;
d436 2
d441 1
d444 2
a445 1
			cfnet_add(&cfnets, optarg);
d448 1
a448 1
			cs->mode = opt_mode();
d451 1
a451 1
			cs->hdr = opt_hdr();
d454 1
a454 1
			cs->xrun = opt_xrun();
d457 1
a457 1
			cs->join = opt_onoff();
d460 1
a460 1
			cs->mmc = opt_mmc();
d463 1
a463 3
			opt_ch(&cs->ipar);
			cd->opar.cmin = cs->ipar.cmin;
			cd->opar.cmax = cs->ipar.cmax;
d466 1
a466 3
			opt_ch(&cs->opar);
			cd->ipar.cmin = cs->opar.cmin;
			cd->ipar.cmax = cs->opar.cmax;
d469 2
a470 4
			opt_enc(&cs->ipar);
			aparams_copyenc(&cs->opar, &cs->ipar);
			aparams_copyenc(&cd->ipar, &cs->ipar);
			aparams_copyenc(&cd->opar, &cd->ipar);
d476 1
a476 2
			cs->opar.rate = cs->ipar.rate = rate;
			cd->ipar.rate = cd->opar.rate = rate;
d479 1
a479 1
			cs->vol = strtonum(optarg, 0, MIDI_MAXCTL, &str);
d484 16
a499 2
			cfstr_add(&cd->ins, cs, optarg);
			cs = cfstr_new(cs);
d501 6
a506 3
		case 'o':
			cfstr_add(&cd->outs, cs, optarg);
			cs = cfstr_new(cs);
d508 5
a512 4
		case 's':
			cfstr_add(&cd->opts, cs, optarg);
			cs = cfstr_new(cs);
			nsock++;
d515 1
a515 1
			cd->hold = opt_onoff();
d518 1
a518 7
			cd->autovol = opt_onoff();
			break;
		case 'u':
			cd->autopar = opt_onoff();
			break;
		case 'q':
			cfmid_add(&cd->mids, optarg);
d521 1
a521 1
			cd->bufsz = strtonum(optarg, 1, RATE_MAX * 5, &str);
d526 1
a526 1
			cd->round = strtonum(optarg, 1, SHRT_MAX, &str);
d531 7
a537 9
			if (SLIST_EMPTY(&cd->opts) &&
			    SLIST_EMPTY(&cd->ins) &&
			    SLIST_EMPTY(&cd->outs)) {
				cfstr_add(&cd->opts, cs, DEFAULT_OPT);
				cs = cfstr_new(cs);
				nsock++;
			}
			cfdev_add(&cfdevs, cd, optarg);
			cd = cfdev_new(cd);
d540 1
a540 2
			l_flag = 1;
			autostart = 0;
d543 1
a543 1
			aucat_usage();
a548 5

#ifdef DEBUG
	if (debug_level == 0)
		debug_level = 1;
#endif
d550 1
a550 1
		aucat_usage();
d553 7
a559 28

	/*
	 * Check constraints specific to -n option
	 */
	if (n_flag) {
		if (!SLIST_EMPTY(&cfdevs) ||
		    !SLIST_EMPTY(&cd->mids) ||
		    !SLIST_EMPTY(&cd->opts))
			errx(1, "-f, -s, and -q not allowed in loopback mode");
		if (SLIST_EMPTY(&cd->ins) || SLIST_EMPTY(&cd->outs))
			errx(1, "-i and -o are required in loopback mode");
	}

	/*
	 * If there's no device specified, do as if the default
	 * device is specified as last argument.
	 */
	if (SLIST_EMPTY(&cfdevs)) {
		if (SLIST_EMPTY(&cd->opts) &&
		    SLIST_EMPTY(&cd->ins) &&
		    SLIST_EMPTY(&cd->outs)) {
			cfstr_add(&cd->opts, cs, DEFAULT_OPT);
			nsock++;
		} else
			free(cs);
		if (!cd->hold)
			errx(1, "-a off not compatible with default device");
		cfdev_add(&cfdevs, cd, "default");
d561 5
a565 26
		if (!SLIST_EMPTY(&cd->opts) ||
		    !SLIST_EMPTY(&cd->ins) ||
		    !SLIST_EMPTY(&cd->outs) ||
		    !SLIST_EMPTY(&cd->outs))
			errx(1, "no device to attach last stream to");
		free(cs);
		free(cd);
	}

	/*
	 * Check modes and calculate "best" device parameters. Iterate over all
	 * inputs and outputs and find the maximum sample rate and channel
	 * number.
	 */
	SLIST_FOREACH(cd, &cfdevs, entry) {
		mode = 0;
		if (cd->autopar) {
			aparams_init(&cd->opar, NCHAN_MAX - 1, 0, RATE_MIN);
			aparams_init(&cd->opar, NCHAN_MAX - 1, 0, RATE_MIN);
		}
		SLIST_FOREACH(cs, &cd->ins, entry) {
			if (cs->mode == 0)
				errx(1, "%s: not in play mode", cs->path);
			mode |= (cs->mode & MODE_PLAY);
			if (cd->autopar)
				aparams_grow(&cd->opar, &cs->ipar);
a566 28
		SLIST_FOREACH(cs, &cd->outs, entry) {
			if (cs->mode == 0)
				errx(1, "%s: not in rec/mon mode", cs->path);
			if ((cs->mode & MODE_REC) && (cs->mode & MODE_MON))
				errx(1, "%s: can't rec and mon", cs->path);
			mode |= (cs->mode & MODE_RECMASK);
			if (cd->autopar)
				aparams_grow(&cd->ipar, &cs->opar);
		}
		SLIST_FOREACH(cs, &cd->opts, entry) {
			if ((cs->mode & MODE_REC) && (cs->mode & MODE_MON))
				errx(1, "%s: can't rec and mon", cs->path);
			mode |= (cs->mode & (MODE_RECMASK | MODE_PLAY));
			if (cd->autopar) {
				aparams_grow(&cd->opar, &cs->ipar);
				aparams_grow(&cd->ipar, &cs->opar);
			}
		}
		if ((mode & MODE_MON) && !(mode & MODE_PLAY))
			errx(1, "no playback stream to monitor");
		if (n_flag && (mode & MODE_MON))
			errx(1, "-m mon not allowed in loopback mode");	
		rate = (mode & MODE_REC) ? cd->ipar.rate : cd->opar.rate;
		if (!cd->round)
			cd->round = rate / 15;
		if (!cd->bufsz)
			cd->bufsz = rate / 15 * 4;
		cd->mode = mode;
d568 1
a568 1
	if (nsock > 0) {
d570 8
a577 2
		if (unit < 0)
			unit = 0;
d579 4
a582 74
	setsig();
	filelist_init();

	/*
	 * Open devices
	 */
	while (!SLIST_EMPTY(&cfdevs)) {
		cd = SLIST_FIRST(&cfdevs);
		SLIST_REMOVE_HEAD(&cfdevs, entry);

		if (n_flag) {
			d = dev_new_loop(&cd->ipar, &cd->opar, cd->bufsz);
		} else {
			d = dev_new_sio(cd->path, cd->mode | MODE_MIDIMASK,
			    &cd->ipar, &cd->opar, cd->bufsz, cd->round,
			    cd->hold, cd->autovol);
		}
		if (d == NULL)
			errx(1, "%s: can't open device", cd->path);

		/*
		 * register midi devices
		 */
		while (!SLIST_EMPTY(&cd->mids)) {
			cm = SLIST_FIRST(&cd->mids);
			SLIST_REMOVE_HEAD(&cd->mids, entry);
			if (!devctl_add(d, cm->path, MODE_MIDIMASK))
				errx(1, "%s: can't open port", cm->path);
			free(cm);
		}

		/*
		 * register files
		 */
		autostart = 0;
		while (!SLIST_EMPTY(&cd->ins)) {
			cs = SLIST_FIRST(&cd->ins);
			SLIST_REMOVE_HEAD(&cd->ins, entry);
			if (!cs->mmc)
				autostart = 1;
			if (strcmp(cs->path, "-") == 0)
				cs->path = NULL;
			if (!wav_new_in(&wav_ops, d, cs->mode & MODE_PLAY,
				cs->path, cs->hdr, &cs->ipar, cs->xrun,
				cs->vol, cs->mmc, cs->join))
				exit(1);
			free(cs);
		}
		while (!SLIST_EMPTY(&cd->outs)) {
			cs = SLIST_FIRST(&cd->outs);
			SLIST_REMOVE_HEAD(&cd->outs, entry);
			if (!cs->mmc)
				autostart = 1;
			if (strcmp(cs->path, "-") == 0)
				cs->path = NULL;
			if (!wav_new_out(&wav_ops, d, cs->mode & MODE_RECMASK,
				cs->path, cs->hdr, &cs->opar, cs->xrun,
				cs->mmc, cs->join))
				exit(1);
			free(cs);
		}
		while (!SLIST_EMPTY(&cd->opts)) {
			cs = SLIST_FIRST(&cd->opts);
			SLIST_REMOVE_HEAD(&cd->opts, entry);
			opt_new(cs->path, d, &cs->opar, &cs->ipar,
			    MIDI_TO_ADATA(cs->vol), cs->mmc,
			    cs->join, cs->mode | MODE_MIDIMASK);
			free(cs);
		}
		free(cd);
		if (autostart) {
			/*
			 * inject artificial mmc start
			 */
a583 1
		}
d585 3
a587 9
	if (nsock > 0) {
		snprintf(path, sizeof(path), "%s/%s%u", base,
		    AUCAT_PATH, unit);
		listen_new_un(path);
		while (!SLIST_EMPTY(&cfnets)) {
			cn = SLIST_FIRST(&cfnets);
			SLIST_REMOVE_HEAD(&cfnets, entry);
			listen_new_tcp(cn->addr, AUCAT_PORT + unit);
		}
d589 1
a589 3
	if (geteuid() == 0)
		privdrop();
	if (l_flag) {
d609 2
a610 1
			if (d->pstate != DEV_CLOSED && !ctl_idle(d->midi))
d615 1
a615 1
		if (nsock == 0 && !active)
d621 2
a622 1
	listen_closeall();
d635 1
a635 1
	if (nsock > 0) {
a640 286
}

void
midicat_usage(void)
{
	(void)fputs("usage: " PROG_MIDICAT " [-dl] [-a flag] "
	    "[-i file] [-L addr] [-o file] [-q port]\n\t"
	    "[-s name] [-U unit]\n",
	    stderr);
}

int
midicat_main(int argc, char **argv)
{
	struct cfdevlist cfdevs;
	struct cfnetlist cfnets;
	struct cfmid *cm;
	struct cfstr *cs;
	struct cfdev *cd;
	struct cfnet *cn;
	int c, d_flag, l_flag, unit, fd;
	char base[PATH_MAX], path[PATH_MAX];
	struct file *stdx;
	struct aproc *p;
	struct abuf *buf;
	const char *str;
	struct dev *d, *dnext;
	unsigned nsock;

	/*
	 * global options defaults
	 */
	unit = -1;
	d_flag = 0;
	l_flag = 0;
	SLIST_INIT(&cfdevs);
	SLIST_INIT(&cfnets);
	nsock = 0;
	
	/*
	 * default device and stream
	 */
	cs = cfstr_new(NULL);
	cd = cfdev_new(NULL);

	while ((c = getopt(argc, argv, "di:o:ls:a:q:U:L:")) != -1) {
		switch (c) {
		case 'd':
#ifdef DEBUG
			if (d_flag)
				debug_level++;
#endif
			d_flag = 1;
			break;
		case 'i':
			cfstr_add(&cd->ins, cs, optarg);
			cs = cfstr_new(cs);
			break;
		case 'o':
			cfstr_add(&cd->outs, cs, optarg);
			cs = cfstr_new(cs);
			break;
		case 'a':
			cd->hold = opt_onoff();
			break;
		case 'q':
			cfmid_add(&cd->mids, optarg);
			break;
		case 's':
			cfstr_add(&cd->opts, cs, optarg);
			cfdev_add(&cfdevs, cd, optarg);
			cd = cfdev_new(cd);
			cs = cfstr_new(NULL);
			nsock++;
			break;
		case 'l':
			l_flag = 1;
			break;
		case 'U':
			unit = strtonum(optarg, 0, MIDI_MAXCTL, &str);
			if (str)
				errx(1, "%s: unit number is %s", optarg, str);
			break;
		case 'L':
			cfnet_add(&cfnets, optarg);
			break;
		default:
			midicat_usage();
			exit(1);
		}
	}
	argc -= optind;
	argv += optind;

#ifdef DEBUG
	if (debug_level == 0)
		debug_level = 1;
#endif
	if (argc > 0) {
		midicat_usage();
		exit(1);
	}

	/*
	 * If there's no device specified (-s), then create one with
	 * reasonable defaults:
	 *
	 *  - if there are no streams (-ioq) defined, assume server mode
	 *    and expose the "defaut" option
	 *
	 *  - if there are files (-io) but no ports (-q) to send/receive
	 *    from, add the default sndio(7) MIDI port
	 */
	if (SLIST_EMPTY(&cfdevs)) {
		if (SLIST_EMPTY(&cd->mids)) {
			if (SLIST_EMPTY(&cd->ins) && SLIST_EMPTY(&cd->outs)) {
				cfstr_add(&cd->opts, cs, DEFAULT_OPT);
				nsock++;
			} else {
				cfmid_add(&cd->mids, "default");
				free(cs);
			}
		} else
			free(cs);
		cfdev_add(&cfdevs, cd, "default");
	} else {
		free(cs);
		free(cd);
	}
	if (nsock > 0) {
		getbasepath(base, sizeof(path));
		if (unit < 0)
			unit = 0;
	}
	setsig();
	filelist_init();

	while (!SLIST_EMPTY(&cfdevs)) {
		cd = SLIST_FIRST(&cfdevs);
		SLIST_REMOVE_HEAD(&cfdevs, entry);

		d = dev_new_thru(cd->hold);
		if (d == NULL)
			errx(1, "%s: can't open device", cd->path);
		if (SLIST_EMPTY(&cd->opts) && APROC_OK(d->midi))
			d->midi->flags |= APROC_QUIT;

		/*
		 * register midi ports
		 */
		while (!SLIST_EMPTY(&cd->mids)) {
			cm = SLIST_FIRST(&cd->mids);
			SLIST_REMOVE_HEAD(&cd->mids, entry);
			if (!devctl_add(d, cm->path, MODE_MIDIMASK))
				errx(1, "%s: can't open port", cm->path);
			free(cm);
		}

		/*
		 * register files
		 */
		while (!SLIST_EMPTY(&cd->ins)) {
			cs = SLIST_FIRST(&cd->ins);
			SLIST_REMOVE_HEAD(&cd->ins, entry);
			if (strcmp(cs->path, "-") == 0) {
				fd = STDIN_FILENO;
				if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)
					warn("stdin");
			} else {
				fd = open(cs->path, O_RDONLY | O_NONBLOCK, 0666);
				if (fd < 0)
					err(1, "%s", cs->path);
			}
			stdx = (struct file *)pipe_new(&pipe_ops, fd, cs->path);
			p = rfile_new(stdx);
			buf = abuf_new(MIDI_BUFSZ, &aparams_none);
			aproc_setout(p, buf);
			dev_midiattach(d, buf, NULL);
			free(cs);
		}
		while (!SLIST_EMPTY(&cd->outs)) {
			cs = SLIST_FIRST(&cd->outs);
			SLIST_REMOVE_HEAD(&cd->outs, entry);
			if (strcmp(cs->path, "-") == 0) {
				fd = STDOUT_FILENO;
				if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)
					warn("stdout");
			} else {
				fd = open(cs->path,
				    O_WRONLY | O_TRUNC | O_CREAT | O_NONBLOCK, 0666);
				if (fd < 0)
					err(1, "%s", cs->path);
			}
			stdx = (struct file *)pipe_new(&pipe_ops, fd, cs->path);
			p = wfile_new(stdx);
			buf = abuf_new(MIDI_BUFSZ, &aparams_none);
			aproc_setin(p, buf);
			dev_midiattach(d, NULL, buf);
			free(cs);
		}
		while (!SLIST_EMPTY(&cd->opts)) {
			cs = SLIST_FIRST(&cd->opts);
			SLIST_REMOVE_HEAD(&cd->opts, entry);
			opt_new(cs->path, d, NULL, NULL, 0, 0, 0, MODE_MIDIMASK);
			free(cs);
		}
		free(cd);
	}
	if (nsock > 0) {
		snprintf(path, sizeof(path), "%s/%s%u", base,
		    MIDICAT_PATH, unit);
		listen_new_un(path);
		while (!SLIST_EMPTY(&cfnets)) {
			cn = SLIST_FIRST(&cfnets);
			SLIST_REMOVE_HEAD(&cfnets, entry);
			listen_new_tcp(cn->addr, MIDICAT_PORT + unit);
		}
	}
	if (geteuid() == 0)
		privdrop();
	if (l_flag) {
#ifdef DEBUG
		debug_level = 0;
		dbg_flush();
#endif
		if (daemon(0, 0) < 0)
			err(1, "daemon");
	}

	/*
	 * loop, start processing
	 */
	for (;;) {
		if (quit_flag)
			break;
		for (d = dev_list; d != NULL; d = dnext) {
			dnext = d->next;
			if (!dev_run(d))
				goto fatal;
		}
		if (!file_poll())
			break;
	}
  fatal:
	listen_closeall();

	/*
	 * give a chance to drain
	 */
	for (d = dev_list; d != NULL; d = d->next)
		dev_drain(d);
	while (file_poll())
		; /* nothing */

	while (dev_list)
		dev_del(dev_list);
	filelist_done();
	if (nsock > 0) {
		if (rmdir(base) < 0 && errno != ENOTEMPTY && errno != EPERM)
			warn("rmdir(\"%s\")", base);
	}
	unsetsig();
	return 0;
}

int
main(int argc, char **argv)
{
	char *prog;

#ifdef DEBUG
	atexit(dbg_flush);
#endif
	prog = strrchr(argv[0], '/');
	if (prog == NULL)
		prog = argv[0];
	else
		prog++;
	if (strcmp(prog, PROG_AUCAT) == 0) {
		return aucat_main(argc, argv);
	} else if (strcmp(prog, PROG_MIDICAT) == 0) {
		return midicat_main(argc, argv);
	} else {
		fprintf(stderr, "%s: can't determine program to run\n", prog);
	}
	return 1;
@


1.118
log
@Make -aoff option apply to MIDI ports (-q) as well, ensuring the device
stays closed also if -q is used. As we're at it, add -a to midicat so
it behaves like aucat.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.117 2011/06/03 17:04:47 ratchov Exp $	*/
d254 1
d292 1
d465 1
a465 1
	(void)fputs("usage: " PROG_AUCAT " [-dlnu] [-a flag] [-b nframes] "
d470 2
a471 2
	    "[-v volume]\n\t"
	    "[-w flag] [-x policy] [-z nframes]\n",
d484 1
a484 1
	int c, u_flag, d_flag, l_flag, n_flag, unit;
a496 1
	u_flag = 0;
d510 1
a510 1
	while ((c = getopt(argc, argv, "a:w:dnb:c:C:e:r:h:x:v:i:o:f:m:luq:s:U:L:t:j:z:")) != -1) {
a521 3
		case 'u':
			u_flag = 1;
			break;
d592 3
d684 1
a684 1
		if (!u_flag) {
d692 1
a692 1
			if (!u_flag)
d701 1
a701 1
			if (!u_flag)
d708 1
a708 1
			if (!u_flag) {
@


1.117
log
@Allow device encoding to be set if -u is also used. Useful to degrade
quality to save bandwith when a remote audio device is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.116 2011/06/03 10:05:27 ratchov Exp $	*/
d344 1
a344 1
	
d754 2
a755 2
			if (!dev_thruadd(d, cm->path, 1, 1))
				errx(1, "%s: can't open device", cm->path);
d872 3
a874 2
	(void)fputs("usage: " PROG_MIDICAT " [-dl] "
	    "[-i file] [-L addr] [-o file] [-q port] [-s name] [-U unit]\n",
d912 1
a912 1
	while ((c = getopt(argc, argv, "di:o:ls:q:U:L:")) != -1) {
d929 3
d1008 1
a1008 1
		d = dev_new_thru();
d1020 2
a1021 2
			if (!dev_thruadd(d, cm->path, 1, 1))
				errx(1, "%s: can't open device", cm->path);
@


1.116
log
@Reorganize the way command line options are parsed and stored.
No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.115 2011/05/26 07:18:40 ratchov Exp $	*/
d560 2
d683 4
@


1.115
log
@add a new -w flag to control whether master volume is automatically
adjusted when new streams are connected and disconnected. Disabling
automatic volume adjustment makes sense if all streams are recorded
with properly lowered volumes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.114 2011/05/10 06:26:34 ratchov Exp $	*/
d272 2
a273 2
void
cfdev_add(struct cfdevlist *list, struct cfdev *templ, char *path)
d282 21
a302 1
	*cd = *templ;
a304 4
	SLIST_INIT(&templ->ins);
	SLIST_INIT(&templ->outs);
	SLIST_INIT(&templ->opts);
	SLIST_INIT(&templ->mids);
d307 2
a308 2
void
cfstr_add(struct cfstrlist *list, struct cfstr *templ, char *path)
a309 1
	size_t len;
a310 1
	unsigned hdr;
a311 8
	if (templ->hdr == HDR_AUTO) {
		len = strlen(path);
		if (len >= 4 && strcasecmp(path + len - 4, ".wav") == 0)
			hdr = HDR_WAV;
		else
			hdr = HDR_RAW;
	} else
		hdr = templ->hdr;
d317 19
a335 1
	*cs = *templ;
a336 1
	cs->hdr = hdr;
d489 1
a489 1
	unsigned nsock, nfile;
d501 1
a501 1
	nfile = nsock = 0;
d504 1
a504 1
	 * default stream params
d506 2
a507 33
	cs = malloc(sizeof(struct cfstr));
	if (cs == NULL) {
		perror("malloc");
		exit(1);
	}
	aparams_init(&cs->ipar, 0, 1, DEFAULT_RATE);
	aparams_init(&cs->opar, 0, 1, DEFAULT_RATE);
	cs->mmc = 0;
	cs->hdr = HDR_AUTO;
	cs->xrun = XRUN_IGNORE;
	cs->vol = MIDI_MAXCTL;
	cs->mode = MODE_PLAY | MODE_REC;
	cs->join = 1;

	/*
	 * default device
	 */
	cd = malloc(sizeof(struct cfdev));
	if (cd == NULL) {
		perror("malloc");
		exit(1);
	}
	aparams_init(&cd->ipar, 0, 1, DEFAULT_RATE);
	aparams_init(&cd->opar, 0, 1, DEFAULT_RATE);
	SLIST_INIT(&cd->ins);
	SLIST_INIT(&cd->outs);
	SLIST_INIT(&cd->opts);
	SLIST_INIT(&cd->mids);
	cd->path = NULL;
	cd->bufsz = 0;
	cd->round = 0;
	cd->hold = 1;
	cd->autovol = 1;
a533 1
			cd->mode = cs->mode;
d575 1
a575 1
			nfile++;
d579 1
a579 1
			nfile++;
d583 1
d610 1
d614 1
d659 2
a660 1
		}
d664 8
a672 4
	if ((cs = SLIST_FIRST(&cd->opts)) ||
	    (cs = SLIST_FIRST(&cd->ins)) ||
	    (cs = SLIST_FIRST(&cd->outs)))
		errx(1, "%s: no device to attach the stream to", cs->path);
d900 1
a900 11
	 * default stream params
	 */
	cs = malloc(sizeof(struct cfstr));
	if (cs == NULL) {
		perror("malloc");
		exit(1);
	}
	cs->hdr = HDR_RAW;

	/*
	 * default device
d902 2
a903 11
	cd = malloc(sizeof(struct cfdev));
	if (cd == NULL) {
		perror("malloc");
		exit(1);
	}
	SLIST_INIT(&cd->ins);
	SLIST_INIT(&cd->outs);
	SLIST_INIT(&cd->opts);
	SLIST_INIT(&cd->mids);
	cd->path = NULL;

d916 1
d920 1
d928 2
d972 1
a972 3
			if (!SLIST_EMPTY(&cd->ins) || !SLIST_EMPTY(&cd->outs))
			    	cfmid_add(&cd->mids, "default");
			else {
d975 3
d979 2
a980 1
		}
d982 3
a1000 2
		if (!dev_ref(d))
			errx(1, "couldn't open midi thru box");
@


1.114
log
@fix option handling and enable TCP in midicat
from peters at schwertfisch.de, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.113 2011/04/28 06:19:57 ratchov Exp $	*/
d253 1
d446 1
a446 1
	    "[-x policy] [-z nframes]\n",
d515 1
d517 1
a517 1
	while ((c = getopt(argc, argv, "a:dnb:c:C:e:r:h:x:v:i:o:f:m:luq:s:U:L:t:j:z:")) != -1) {
d597 3
d738 1
a738 1
			    cd->hold);
@


1.113
log
@Implement a new authentication method allowing aucat and midicat to
work over TCP, for instance, to expose the sound card of one machine
with other machines of the network.

The first client generates a 128-bit random number (aka the
session cookie), saves it in $HOME/.aucat_cookie and sends it to the
server. Successive clients load the cookie from $HOME/.aucat_cookie
and send it to the server but the server accepts only clients whose
cookie matches the session cookie. When all clients are gone, the
session is over, and another cookie could start a new session, and so
on.

TCP is enabled on the server with the new -L option, and on the client
side hostnames are specified with a new optional component in the
device name.

hints from damien, dlg and deraadt, tweaks from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.112 2011/04/27 21:20:36 ratchov Exp $	*/
d920 1
a920 1
	while ((c = getopt(argc, argv, "di:o:ls:q:U:")) != -1) {
@


1.112
log
@move amsg.h containing protocol defs from aucat side to libsndio side.

requested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.111 2011/04/27 17:58:43 deraadt Exp $	*/
d261 10
d331 14
d441 5
a445 5
	    "[-f device] [-h fmt] [-i file] [-j flag] [-m mode]"
	    "[-o file] [-q device]\n\t"
	    "[-r rate] [-s name] [-t mode] [-U unit] "
	    "[-v volume] [-x policy]\n\t"
	    "[-z nframes]\n",
d453 1
d457 1
d476 1
d515 1
a515 1
	while ((c = getopt(argc, argv, "a:dnb:c:C:e:r:h:x:v:i:o:f:m:luq:s:U:t:j:z:")) != -1) {
d535 3
d799 5
d863 1
a863 1
	    "[-i file] [-o file] [-q port] [-s name] [-U unit]\n",
d871 1
d875 1
d892 1
d951 3
d1077 5
@


1.111
log
@use more volatile sig_atomic_t in signal handlers
ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.110 2011/04/19 00:02:28 ratchov Exp $	*/
d35 1
@


1.110
log
@don't hold a pointer to "listen" structure. Instead, when it must
be free()ed, iterate over the file_list, and find the structure
to free. This is safer and simpler. No behaviour change
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.109 2011/04/16 11:51:48 ratchov Exp $	*/
d68 1
a68 1
int debug_level = 0;
d70 1
a70 1
volatile int quit_flag = 0;
@


1.109
log
@for unix domain socket addresses use AUCAT_PATH and MIDICAT_PATH
macros instead of hardcoded strings. No object change
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.108 2011/03/17 07:55:35 ratchov Exp $	*/
a430 1
	struct listen *listen = NULL;
d767 1
a767 3
		listen = listen_new(&listen_ops, path);
		if (listen == NULL)
			exit(1);
d802 2
a803 2
	if (nsock > 0)
		file_close(&listen->file);
a837 1
	struct listen *listen = NULL;
d1034 1
a1034 3
		listen = listen_new(&listen_ops, path);
		if (listen == NULL)
			exit(1);
d1062 2
a1063 2
	if (nsock > 0)
		file_close(&listen->file);
@


1.108
log
@use a DEFAULT_RATE macro instead of hardcoding 44100, no object change
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.107 2010/11/05 16:09:50 ratchov Exp $	*/
d767 1
a767 1
		    DEFAULT_SOFTAUDIO, unit);
d1037 1
a1037 1
		    DEFAULT_MIDITHRU, unit);
@


1.107
log
@unbreak compilation without DEBUG defined
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.106 2010/10/21 18:57:42 ratchov Exp $	*/
d60 7
d460 2
a461 2
	aparams_init(&cs->ipar, 0, 1, 44100);
	aparams_init(&cs->opar, 0, 1, 44100);
d477 2
a478 2
	aparams_init(&cd->ipar, 0, 1, 44100);
	aparams_init(&cd->opar, 0, 1, 44100);
@


1.106
log
@use MODE_xxx and XRUN_xxx macros everywhere, and zap corresponding
AMSG_xxx macros, which in turns simplifies the code
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.105 2010/09/08 22:07:26 deraadt Exp $	*/
d768 1
d771 1
d1038 1
d1041 1
@


1.105
log
@aucat: getpwnam: No such file or directory
is not a proper error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.104 2010/08/20 06:56:54 ratchov Exp $	*/
d694 1
a694 1
			d = dev_new_sio(cd->path, cd->mode,
d747 1
a747 1
			    cs->join, cs->mode);
d1021 1
a1021 1
			opt_new(cs->path, d, NULL, NULL, 0, 0, 0, 0);
@


1.104
log
@polish the code: remove few unused #includes, add missing ones,
fix NULL vs 0, etc. No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.103 2010/08/19 06:31:06 ratchov Exp $	*/
d391 1
a391 1
		err(1, "getpwnam");
@


1.103
log
@fix NULL pointer deref in midicat option parsing when ``-'' is
used as filename
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.102 2010/07/31 08:48:01 ratchov Exp $	*/
a32 1
#include <varargs.h>
d183 1
a183 1
	for (p = optarg; *p != NULL; p++) {
@


1.102
log
@remove 2 years old compatibility mode
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.101 2010/07/10 12:28:17 ratchov Exp $	*/
d280 1
a280 4
	if (strcmp(path, "-") == 0) {
		path = NULL;
		hdr = HDR_RAW;
	} else if (templ->hdr == HDR_AUTO) {
d722 2
d735 2
@


1.101
log
@In midi server mode, don't terminate the midi thru box if there are
no connections anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.100 2010/07/10 11:56:28 ratchov Exp $	*/
d433 1
a433 2
	char *legacy_path;
	int autostart, legacy;
a445 2
	legacy = 1;
	legacy_path = NULL;
a494 1
			legacy = 0;
a497 1
			legacy = 0;
a500 1
			legacy = 0;
a505 1
			legacy = 0;
a509 1
			legacy = 0;
a512 1
			legacy = 0;
a515 1
			legacy = 0;
a518 1
			legacy = 0;
a521 1
			legacy = 0;
a526 1
			legacy = 0;
a531 1
			legacy = 0;
a535 1
			legacy = 0;
a542 1
			legacy = 0;
a547 1
			legacy = 0;
a551 1
			legacy = 0;
a555 1
			legacy = 0;
a559 1
			legacy = 0;
a562 1
			legacy = 0;
a565 1
			legacy = 0;
a570 1
			legacy = 0;
a575 2
			legacy = 0;
			legacy_path = optarg;
a584 1
			legacy = 0;
d601 2
a602 9
		if (!legacy) {
			aucat_usage();
			exit(1);
		}
		for (c = 0; c < argc; c++)
			if (legacy_play(legacy_path, argv[c]) != 0) {
				errx(1, "%s: could not play\n", argv[c]);
			}
		exit(0);
@


1.100
log
@fix parameter handling: don't try to open a ``default'' midi port
if no files are given on the command line
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.99 2010/07/06 10:45:01 jmc Exp $	*/
d995 1
a995 1
		if (!SLIST_EMPTY(&cd->opts) && APROC_OK(d->midi))
@


1.99
log
@various tweaks to previous; ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.98 2010/07/06 01:12:45 ratchov Exp $	*/
d969 1
a969 1
			if (SLIST_EMPTY(&cd->ins) && SLIST_EMPTY(&cd->outs))
@


1.98
log
@Handle all streams the same way because there's no actual
difference between audio files and client connections. Clean up
the way command line options are handled and clarify this in the
manual page: stream parameters (-Ccehjmrtvx) must precede stream
definitions (-ios) and per-device parameters (-abz) and stream
definitions (-ios) must precede device definitions (-f). Since
there's no ``server'' and ``non-server'' modes anymore, make the
-l option just detach the process.

ok and help from jakemsr and jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.97 2010/06/29 06:48:39 jakemsr Exp $	*/
d854 1
a854 1
	    "[-i file] [-o file] [-q device] [-U unit]\n",
@


1.97
log
@If the device isn't opened yet (as can be the case with '-a off'),
don't check if the midi control interface is idle
from ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.96 2010/06/25 07:32:05 ratchov Exp $	*/
d437 1
d450 1
d566 1
d571 1
d576 1
d601 6
d638 3
a640 2
	if (!l_flag && unit >= 0)
		errx(1, "can't use -U without -l");
d642 4
a645 3
		if (!SLIST_EMPTY(&cfdevs) || l_flag ||
		    !SLIST_EMPTY(&cd->opts) || !SLIST_EMPTY(&cd->mids))
			errx(1, "can't use -n with -l, -f, -q or -s");
d647 1
a647 1
			errx(1, "both -i and -o are required with -n");
d651 2
a652 1
	 * if no device is given, add the default one
d655 6
d662 1
a662 1
			errx(1, "-a not compatible with default device");
d665 4
a668 12

	/*
	 * If there are no sockets paths provided use the default.
	 */
	if (l_flag) {
		SLIST_FOREACH(cd, &cfdevs, entry) {
			if (!SLIST_EMPTY(&cd->opts))
				continue;
			cfstr_add(&cd->opts, cs, DEFAULT_OPT);
			break;
		}
	}
a701 6
		if (l_flag && SLIST_EMPTY(&cd->opts))
			errx(1, "%s: no subdevs for this device", cd->path);
		if (!l_flag && SLIST_EMPTY(&cd->ins) && SLIST_EMPTY(&cd->outs))
			errx(1, "%s: no files for this device", cd->path);
		if (n_flag && (mode & MODE_MON))
			errx(1, "monitoring not allowed in loopback mode");
d704 2
d713 1
a713 2

	if (l_flag) {
d791 1
a791 1
	if (l_flag) {
d795 1
a795 1
		if (listen == 0)
d797 7
a803 3
		if (geteuid() == 0)
			privdrop();
		if (!d_flag && daemon(0, 0) < 0)
d823 1
a823 1
		if (!l_flag && !active)
d829 1
a829 1
	if (l_flag)
d842 1
a842 1
	if (l_flag) {
d861 1
a861 1
	struct cfmidlist mids, ins, outs;
d863 2
d872 2
a873 1
	struct dev *d;
d881 27
a907 3
	SLIST_INIT(&mids);
	SLIST_INIT(&ins);
	SLIST_INIT(&outs);
d909 1
a909 1
	while ((c = getopt(argc, argv, "di:o:lf:q:U:")) != -1) {
d919 1
a919 1
			cfmid_add(&ins, optarg);
d922 1
a922 1
			cfmid_add(&outs, optarg);
a923 2
			/* XXX: backward compat, remove this */
		case 'f':	
d925 6
a930 1
			cfmid_add(&mids, optarg);
d948 5
a952 1
	if (argc > 0 || (SLIST_EMPTY(&ins) && SLIST_EMPTY(&outs) && !l_flag)) {
d956 23
a978 5
	if (!l_flag && unit >= 0)
		errx(1, "can't use -U without -l");
	if (l_flag) {
		if (!SLIST_EMPTY(&ins) || !SLIST_EMPTY(&outs))
			errx(1, "can't use -i or -o with -l");
d986 44
a1029 15
	d = dev_new_thru();
	if (!dev_ref(d))
		errx(1, "couldn't open midi thru box");
	if (!l_flag && APROC_OK(d->midi))
		d->midi->flags |= APROC_QUIT;
	if ((!SLIST_EMPTY(&ins) || !SLIST_EMPTY(&outs)) && SLIST_EMPTY(&mids)) {
	    	cfmid_add(&mids, "default");
	}
	while (!SLIST_EMPTY(&mids)) {
		cm = SLIST_FIRST(&mids);
		SLIST_REMOVE_HEAD(&mids, entry);
		if (!dev_thruadd(d, cm->path,
			!SLIST_EMPTY(&outs) || l_flag,
			!SLIST_EMPTY(&ins) || l_flag)) {
			errx(1, "%s: can't open device", cm->path);
d1031 27
a1057 1
		free(cm);
d1059 1
a1059 2
	if (l_flag) {
		opt_new(DEFAULT_OPT, d, NULL, NULL, 0, 0, 0, 0);
d1063 9
a1071 3
		if (geteuid() == 0)
			privdrop();
		if (!d_flag && daemon(0, 0) < 0)
d1074 1
a1074 39
	while (!SLIST_EMPTY(&ins)) {
		cm = SLIST_FIRST(&ins);
		SLIST_REMOVE_HEAD(&ins, entry);
		if (strcmp(cm->path, "-") == 0) {
			fd = STDIN_FILENO;
			if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)
				warn("stdin");
		} else {
			fd = open(cm->path, O_RDONLY | O_NONBLOCK, 0666);
			if (fd < 0)
				err(1, "%s", cm->path);
		}
		stdx = (struct file *)pipe_new(&pipe_ops, fd, cm->path);
		p = rfile_new(stdx);
		buf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setout(p, buf);
		dev_midiattach(d, buf, NULL);
		free(cm);
	}
	while (!SLIST_EMPTY(&outs)) {
		cm = SLIST_FIRST(&outs);
		SLIST_REMOVE_HEAD(&outs, entry);
		if (strcmp(cm->path, "-") == 0) {
			fd = STDOUT_FILENO;
			if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)
				warn("stdout");
		} else {
			fd = open(cm->path,
			    O_WRONLY | O_TRUNC | O_CREAT | O_NONBLOCK, 0666);
			if (fd < 0)
				err(1, "%s", cm->path);
		}
		stdx = (struct file *)pipe_new(&pipe_ops, fd, cm->path);
		p = wfile_new(stdx);
		buf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setin(p, buf);
		dev_midiattach(d, NULL, buf);
		free(cm);
	}
d1081 5
a1085 2
		if (!dev_run(d))
			break;
d1089 2
a1090 1
	if (l_flag)
a1091 2
	dev_unref(d);
	dev_del(d);
d1093 1
a1093 1
	 * drain
d1095 2
d1099 3
d1103 1
a1103 1
	if (l_flag) {
@


1.96
log
@don't attempt to drain devices after they are destroyed, which
results in a use after free(). Catched by jakemsr@@ with MALLOC_OPTIONS=J
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.95 2010/06/20 11:32:54 ratchov Exp $	*/
d807 1
a807 1
			if (!ctl_idle(d->midi))
@


1.95
log
@fix midicat(1) device mode when only -i or only -o is used (ie
open the device input-only if -o is used, and output-only if -i is
used).
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.94 2010/06/05 16:00:52 ratchov Exp $	*/
a819 3
	while (dev_list)
		dev_del(dev_list);

d823 2
d827 3
@


1.94
log
@don't prime server buffers, because it's ugly and conceptually
complicated. Instead, request clients to provide enough samples
and start with buffers full.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.93 2010/06/05 12:45:48 ratchov Exp $	*/
d933 2
a934 2
			!SLIST_EMPTY(&ins) || l_flag,
			!SLIST_EMPTY(&outs) || l_flag)) {
@


1.93
log
@Don't send the initial position as a clock tick with a negative delta.
Add a new ``initial position'' message which is simpler. No bahaviour
change, except effects of the protocol version crank.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.92 2010/06/04 06:15:28 ratchov Exp $	*/
d726 1
a726 1
			    cd->hold, l_flag);
@


1.92
log
@Allow the audio device to be opened only while it's actually used.
This is necessary for uaudio devices, for instance to start aucat
before the device is plugged. Or to unplug a device whithout
having to restart aucat when another device is plugged.  This is
controlled with the new -a option.

Allow multiple audio devices to be used concurently, i.e.
multiple ``-f devname'' options to be used; -f options must follow
per-device options, which is what we do for other options.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.91 2010/05/08 15:35:45 ratchov Exp $	*/
d245 1
a245 1
	unsigned hold;		/* open immediately */
@


1.91
log
@prime play buffers as soon as the device is opened, otherwise a
midi client could start it with empty buffers, in turn hurting
audio clients.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.90 2010/05/02 11:54:26 ratchov Exp $	*/
a110 2
	if (errno == ERANGE && (cmin == LONG_MIN || cmin == LONG_MAX))
		goto failed;
a113 2
	if (errno == ERANGE && (cmax == LONG_MIN || cmax == LONG_MAX))
		goto failed;
d207 19
a225 1
 * Arguments of -i, -o and -s options are stored in a list.
d227 3
a229 11
struct farg {
	SLIST_ENTRY(farg) entry;
	struct aparams ipar;	/* input (read) parameters */
	struct aparams opar;	/* output (write) parameters */
	unsigned vol;		/* last requested volume */
	char *name;		/* optarg pointer (no need to copy it */
	int hdr;		/* header format */
	int xrun;		/* overrun/underrun policy */
	int mmc;		/* MMC mode */
	int join;		/* join/expand enabled */
	unsigned mode;
d232 1
a232 1
SLIST_HEAD(farglist, farg);
d235 1
a235 2
 * Add a farg entry to the given list, corresponding
 * to the given file name.
d237 17
d255 34
a288 18
farg_add(struct farglist *list,
    struct aparams *ipar, struct aparams *opar, unsigned vol,
    int hdr, int xrun, int mmc, int join, unsigned mode, char *name)
{
	struct farg *fa;
	size_t namelen;

	fa = malloc(sizeof(struct farg));
	if (fa == NULL)
		err(1, "%s", name);

	if (hdr == HDR_AUTO) {
		if (name != NULL && (namelen = strlen(name)) >= 4 &&
		    strcasecmp(name + namelen - 4, ".wav") == 0) {
			fa->hdr = HDR_WAV;
		} else {
			fa->hdr = HDR_RAW;
		}
d290 24
a313 12
		fa->hdr = hdr;
	if (mmc && xrun == XRUN_IGNORE)
		xrun = XRUN_SYNC;
	fa->xrun = xrun;
	fa->ipar = *ipar;
	fa->opar = *opar;
	fa->vol = vol;
	fa->name = name; 
	fa->mmc = mmc;
	fa->join = join;
	fa->mode = mode;
	SLIST_INSERT_HEAD(list, fa, entry);
a408 42
stopall(void)
{
	struct file *f;

  restart:
	LIST_FOREACH(f, &file_list, entry) {
		/*
		 * skip connected streams (handled by dev_close())
		 */
		if (APROC_OK(dev_mix)) {
			if (f->rproc && aproc_depend(dev_mix, f->rproc))
				continue;
			if (f->wproc && aproc_depend(f->wproc, dev_mix))
				continue;
		}
		if (APROC_OK(dev_sub)) {
			if (f->rproc && aproc_depend(dev_sub, f->rproc))
				continue;
			if (f->wproc && aproc_depend(f->wproc, dev_sub))
				continue;
		}
		if (APROC_OK(dev_submon)) {
			if (f->rproc && aproc_depend(dev_submon, f->rproc))
				continue;
			if (f->wproc && aproc_depend(f->wproc, dev_submon))
				continue;
		}
		if (APROC_OK(dev_midi)) {
			if (f->rproc && aproc_depend(dev_midi, f->rproc))
				continue;
			if (f->wproc && aproc_depend(f->wproc, dev_midi))
				continue;
		}
		/*
		 * kill anything else
		 */
		file_close(f);
		goto restart;
	}
}

void
d411 1
a411 1
	(void)fputs("usage: " PROG_AUCAT " [-dlnu] [-b nframes] "
d424 8
a431 7
	int c, u_flag, d_flag, l_flag, n_flag, hdr, xrun, unit;
	struct farg *fa;
	struct farglist ifiles, ofiles, sfiles, qfiles;
	struct aparams ipar, opar, dipar, dopar;
	char base[PATH_MAX], path[PATH_MAX], *file;
	unsigned bufsz, round, mode;
	char *devpath;
d433 4
a436 2
	unsigned volctl;
	int mmc, autostart, join;
d438 4
a441 2
	aparams_init(&ipar, 0, 1, 44100);
	aparams_init(&opar, 0, 1, 44100);
d446 39
a484 15
	unit = -1;
	mmc = 0;
	devpath = NULL;
	SLIST_INIT(&ifiles);
	SLIST_INIT(&ofiles);
	SLIST_INIT(&sfiles);
	SLIST_INIT(&qfiles);
	hdr = HDR_AUTO;
	xrun = XRUN_IGNORE;
	volctl = MIDI_MAXCTL;
	mode = MODE_PLAY | MODE_REC;
	bufsz = 0;
	round = 0;
	autostart = 1;
	join = 1;
d486 1
a486 1
	while ((c = getopt(argc, argv, "dnb:c:C:e:r:h:x:v:i:o:f:m:luq:s:U:t:j:z:")) != -1) {
d496 1
d499 10
d510 3
a512 1
			mode = opt_mode();
d515 2
a516 1
			hdr = opt_hdr();
d519 2
a520 1
			xrun = opt_xrun();
d523 2
a524 1
			join = opt_onoff();
d527 2
a528 3
			mmc = opt_mmc();
			if (mmc)
				autostart = 0;
d531 4
a534 1
			opt_ch(&ipar);
d537 4
a540 1
			opt_ch(&opar);
d543 3
a545 2
			opt_enc(&ipar);
			aparams_copyenc(&opar, &ipar);
d548 2
a549 1
			ipar.rate = strtonum(optarg, RATE_MIN, RATE_MAX, &str);
d552 2
a553 1
			opar.rate = ipar.rate;
d556 2
a557 1
			volctl = strtonum(optarg, 0, MIDI_MAXCTL, &str);
d562 2
a563 5
			file = optarg;
			if (strcmp(file, "-") == 0)
				file = NULL;
			farg_add(&ifiles, &ipar, &opar, volctl,
			    hdr, xrun, mmc, join, mode & MODE_PLAY, file);
d566 2
a567 5
			file = optarg;
			if (strcmp(file, "-") == 0)
				file = NULL;
			farg_add(&ofiles, &ipar, &opar, volctl,
			    hdr, xrun, mmc, join, mode & MODE_RECMASK, file);
d570 6
a575 2
			farg_add(&sfiles, &ipar, &opar, volctl,
			    hdr, xrun, mmc, join, mode, optarg);
d578 2
a579 16
			farg_add(&qfiles, &aparams_none, &aparams_none,
			    0, HDR_RAW, 0, 0, 0, 0, optarg);
			break;
		case 'f':
			if (devpath)
				err(1, "only one -f allowed");
			devpath = optarg;
			dipar = opar;
			dopar = ipar;
			break;
		case 'l':
			l_flag = 1;
			autostart = 0;
			break;
		case 'u':
			u_flag = 1;
d582 2
a583 1
			bufsz = strtonum(optarg, 1, RATE_MAX * 5, &str);
a586 5
		case 'U':
			unit = strtonum(optarg, 0, MIDI_MAXCTL, &str);
			if (str)
				errx(1, "%s: device number is %s", optarg, str);
			break;
d588 2
a589 1
			round = strtonum(optarg, 1, SHRT_MAX, &str);
d593 10
d611 6
a616 17
	if (!devpath) {
		dopar = ipar;
		dipar = opar;
	}
	if (!l_flag && SLIST_EMPTY(&ifiles) && SLIST_EMPTY(&ofiles)) {
		if (argc > 0) {
			/*
			 * Legacy mode: if no -i or -o options are provided, and
			 * there are arguments then assume the arguments are files
			 * to play.
			 */
			for (c = 0; c < argc; c++)
				if (legacy_play(devpath, argv[c]) != 0) {
					errx(1, "%s: could not play\n", argv[c]);
				}
			exit(0);
		} else {
d620 5
d627 2
a628 4
	if (!l_flag && (!SLIST_EMPTY(&sfiles) || unit >= 0))
		errx(1, "can't use -s or -U without -l");
	if (l_flag && (!SLIST_EMPTY(&ofiles) || !SLIST_EMPTY(&ifiles)))
		errx(1, "can't use -l, and -s with -o or -i");
d630 4
a633 4
		if (devpath != NULL || !SLIST_EMPTY(&qfiles) ||
		    l_flag || !autostart)
			errx(1, "can't use -n with -f, -q, -t or -l");
		if (SLIST_EMPTY(&ifiles) || SLIST_EMPTY(&ofiles))
d638 9
d649 7
a655 3
	if (l_flag && SLIST_EMPTY(&sfiles)) {
		farg_add(&sfiles, &ipar, &opar,
		    volctl, HDR_RAW, XRUN_IGNORE, mmc, join, mode, DEFAULT_OPT);
d663 41
a703 27
	mode = 0;
	aparams_init(&dipar, dipar.cmin, dipar.cmax, dipar.rate);
	aparams_init(&dopar, dopar.cmin, dopar.cmax, dopar.rate);
	SLIST_FOREACH(fa, &ifiles, entry) {
		if (fa->mode == 0)
			errx(1, "%s: not in play mode", fa->name);
		mode |= fa->mode;
		if (!u_flag)
			aparams_grow(&dopar, &fa->ipar);
	}
	SLIST_FOREACH(fa, &ofiles, entry) {
		if (fa->mode == 0)
			errx(1, "%s: not in rec/mon mode", fa->name);
		if ((fa->mode & MODE_REC) && (fa->mode & MODE_MON))
			errx(1, "%s: can't record and monitor", fa->name);
		mode |= fa->mode;
		if (!u_flag)
			aparams_grow(&dipar, &fa->opar);
	}
	SLIST_FOREACH(fa, &sfiles, entry) {
		if ((fa->mode & MODE_REC) && (fa->mode & MODE_MON))
			errx(1, "%s: can't record and monitor", fa->name);
		mode |= fa->mode;
		if (!u_flag) {
			aparams_grow(&dopar, &fa->ipar);
			aparams_grow(&dipar, &fa->opar);
		}
a705 5
	if (!round)
		round = ((mode & MODE_REC) ? dipar.rate : dopar.rate) / 15;
	if (!bufsz)
		bufsz = ((mode & MODE_REC) ? dipar.rate : dopar.rate) * 4 / 15;

d715 1
a715 1
	 * Open the device
d717 24
a740 15
	if (n_flag) {
		if (mode & MODE_MON)
			errx(1, "monitoring not allowed in loopback mode");
		dev_init_loop(&dipar, &dopar, bufsz);
	} else {
		if (l_flag)
			dev_reqprime = 1;
		if ((mode & MODE_MON) && !(mode & MODE_PLAY))
			errx(1, "no playback stream to monitor");
		dev_init_sio(devpath, mode, &dipar, &dopar, bufsz, round);
	}
	if (!dev_ref()) {
		errx(1, "%s: can't open device",
		    devpath ? devpath : "<default>");
	}
d742 41
a782 33
	/*
	 * Create buffers for all input and output pipes.
	 */
	while (!SLIST_EMPTY(&qfiles)) {
		fa = SLIST_FIRST(&qfiles);
		SLIST_REMOVE_HEAD(&qfiles, entry);
		if (!dev_thruadd(fa->name, 1, 1))
			errx(1, "%s: can't open device", fa->name);
		free(fa);
	}
	while (!SLIST_EMPTY(&ifiles)) {
		fa = SLIST_FIRST(&ifiles);
		SLIST_REMOVE_HEAD(&ifiles, entry);
		if (!wav_new_in(&wav_ops, fa->mode, fa->name,
			fa->hdr, &fa->ipar, fa->xrun, fa->vol, fa->mmc,
			fa->join))
			exit(1);
		free(fa);
	}
	while (!SLIST_EMPTY(&ofiles)) {
		fa = SLIST_FIRST(&ofiles);
		SLIST_REMOVE_HEAD(&ofiles, entry);
		if (!wav_new_out(&wav_ops, fa->mode, fa->name,
			fa->hdr, &fa->opar, fa->xrun, fa->mmc,
			fa->join))
		free(fa);
	}
	while (!SLIST_EMPTY(&sfiles)) {
		fa = SLIST_FIRST(&sfiles);
		SLIST_REMOVE_HEAD(&sfiles, entry);
		opt_new(fa->name, &fa->opar, &fa->ipar,
		    MIDI_TO_ADATA(fa->vol), fa->mmc, fa->join, fa->mode);
		free(fa);
d787 3
a789 1
		listen_new(&listen_ops, path);
a794 6
	if (autostart) {
		/*
		 * inject artificial mmc start
		 */
		ctl_start(dev_midi);
	}
d802 9
a810 1
		if (!dev_run())
d812 1
a812 1
		if (!l_flag && ctl_idle(dev_midi))
d817 6
a822 3
	dev_unref();
	stopall();
	dev_done();
d844 1
d848 3
a851 1
	struct farglist dfiles, ifiles, ofiles;
a852 1
	struct farg *fa;
d857 1
d859 4
d865 3
a867 4
	unit = -1;
	SLIST_INIT(&dfiles);
	SLIST_INIT(&ifiles);
	SLIST_INIT(&ofiles);
d879 1
a879 2
			farg_add(&ifiles, &aparams_none, &aparams_none,
			    0, HDR_RAW, 0, 0, 0, 0, optarg);
d882 1
a882 2
			farg_add(&ofiles, &aparams_none, &aparams_none,
			    0, HDR_RAW, 0, 0, 0, 0, optarg);
d887 1
a887 2
			farg_add(&dfiles, &aparams_none, &aparams_none,
			    0, HDR_RAW, 0, 0, 0, 0, optarg);
d895 1
a895 1
				errx(1, "%s: device number is %s", optarg, str);
d905 1
a905 2
	if (argc > 0 || (SLIST_EMPTY(&ifiles) && SLIST_EMPTY(&ofiles) &&
	    !l_flag)) {
d912 1
a912 1
		if (!SLIST_EMPTY(&ifiles) || !SLIST_EMPTY(&ofiles))
d921 15
a935 18
	dev_init_thru();
	if (0 && !dev_ref())
		errx(1, "couldn't opem midi thru box");
	if (!l_flag && APROC_OK(dev_midi))
		dev_midi->flags |= APROC_QUIT;
	if ((!SLIST_EMPTY(&ifiles) || !SLIST_EMPTY(&ofiles)) && 
	    SLIST_EMPTY(&dfiles)) {
		farg_add(&dfiles, &aparams_none, &aparams_none,
		    0, HDR_RAW, 0, 0, 0, 0, NULL);
	}
	while (!SLIST_EMPTY(&dfiles)) {
		fa = SLIST_FIRST(&dfiles);
		SLIST_REMOVE_HEAD(&dfiles, entry);
		if (!dev_thruadd(fa->name, 
			!SLIST_EMPTY(&ofiles) || l_flag,
			!SLIST_EMPTY(&ifiles) || l_flag)) {
			errx(1, "%s: can't open device", 
			    fa->name ? fa->name : "<default>");
d937 1
a937 1
		free(fa);
d940 1
d943 1
a943 1
		listen_new(&listen_ops, path);
d949 4
a952 4
	while (!SLIST_EMPTY(&ifiles)) {
		fa = SLIST_FIRST(&ifiles);
		SLIST_REMOVE_HEAD(&ifiles, entry);
		if (strcmp(fa->name, "-") == 0) {
d957 1
a957 1
			fd = open(fa->name, O_RDONLY | O_NONBLOCK, 0666);
d959 1
a959 1
				err(1, "%s", fa->name);
d961 1
a961 1
		stdx = (struct file *)pipe_new(&pipe_ops, fd, fa->name);
d965 2
a966 2
		dev_midiattach(buf, NULL);
		free(fa);
d968 4
a971 4
	while (!SLIST_EMPTY(&ofiles)) {
		fa = SLIST_FIRST(&ofiles);
		SLIST_REMOVE_HEAD(&ofiles, entry);
		if (strcmp(fa->name, "-") == 0) {
d976 1
a976 1
			fd = open(fa->name,
d979 1
a979 1
				err(1, "%s", fa->name);
d981 1
a981 1
		stdx = (struct file *)pipe_new(&pipe_ops, fd, fa->name);
d985 2
a986 2
		dev_midiattach(NULL, buf);
		free(fa);
d994 1
a994 1
		if (!dev_run())
d999 4
a1002 4
	stopall();
	if (0)
		dev_unref();
	dev_done();
a1015 1

@


1.90
log
@Clean up device handling code to clarify different initialization phases
and different device states. Split initialization in two phases:
first global variables are initialized then the audio hardware is opened.
Allow devices that don't support full-duplex to work in play-only or
record-only mode, even if ``-m play'' or ``-m rec'' are not specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.89 2010/05/02 11:12:31 ratchov Exp $	*/
d655 2
@


1.89
log
@Don't systematically fill with silence the mixer output. This
might result in extra samples being written to the device
when the mixer is closed.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.88 2010/04/24 14:33:46 ratchov Exp $	*/
d160 1
a160 1
opt_join(void)
d471 1
a471 1
			join = opt_join();
d648 1
a648 2
	 * Open the device. Give half of the buffer to the device,
	 * the other half is for the socket/files.
d653 1
a653 1
		dev_loopinit(&dipar, &dopar, bufsz);
d657 5
a661 4
		if (!dev_init(devpath, mode, &dipar, &dopar, bufsz, round)) {
			errx(1, "%s: can't open device", 
			    devpath ? devpath : "<default>");
		}
a712 2
	if (l_flag)
		dev_prime();
d718 1
a718 1
		if (quit_flag) {
d720 1
a720 4
		}
		if ((APROC_OK(dev_mix) && LIST_EMPTY(&dev_mix->outs)) ||
		    (APROC_OK(dev_sub) && LIST_EMPTY(&dev_sub->ins))) {
			fprintf(stderr, "device disappeared, terminating\n");
a721 1
		}
a725 25
		if ((!APROC_OK(dev_mix)    || dev_mix->u.mix.idle > 2 * dev_bufsz) &&
		    (!APROC_OK(dev_sub)    || dev_sub->u.sub.idle > 2 * dev_bufsz) &&
		    (!APROC_OK(dev_submon) || dev_submon->u.sub.idle > 2 * dev_bufsz) &&
		    (!APROC_OK(dev_midi)   || dev_midi->u.ctl.tstate != CTL_RUN)) {
		    	if (dev_pstate == DEV_RUN) {
				dev_pstate = DEV_INIT;
				dev_stop();
				dev_clear();
				/*
				 * priming buffer in non-server mode is not
				 * ok, because it will insert silence and
				 * break synchronization
				 */
				if (l_flag)
					dev_prime();
			}
		}
		/*
		 * move device state machine
		 * XXX: move this to dev.c
		 */
		if (dev_pstate == DEV_START) {
			dev_pstate = DEV_RUN;
			dev_start();
		}
d727 1
d730 5
d826 3
a828 1
	dev_thruinit();
d899 3
a901 1
		if (quit_flag) {
a902 1
		}
d907 2
d910 5
d930 3
@


1.88
log
@if there are no files to play in legacy mode, print the usage message
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.87 2010/04/24 06:18:23 ratchov Exp $	*/
d359 1
a359 1
stopall(char *base)
d366 1
a366 1
		 * skip connected streams (handled by dev_done())
d368 18
a385 6
		if (APROC_OK(dev_mix) && f->rproc &&
		    aproc_depend(dev_mix, f->rproc))
			continue;
		if (APROC_OK(dev_sub) && f->wproc &&
		    aproc_depend(f->wproc, dev_sub))
			continue;
d758 1
a758 1
	stopall(base);
d928 1
a928 1
	stopall(base);
@


1.87
log
@rename ibuflist/obuflist -> ins/outs to cut long lines
from Thomas Pfaff, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.86 2010/04/22 17:43:30 ratchov Exp $	*/
d550 16
a565 15
	if (!l_flag && SLIST_EMPTY(&ifiles) &&
	    SLIST_EMPTY(&ofiles) && argc > 0) {
		/*
		 * Legacy mode: if no -i or -o options are provided, and
		 * there are arguments then assume the arguments are files
		 * to play.
		 */
		for (c = 0; c < argc; c++)
			if (legacy_play(devpath, argv[c]) != 0) {
				errx(1, "%s: could not play\n", argv[c]);
			}
		exit(0);
	} else if (argc > 0) {
		aucat_usage();
		exit(1);
@


1.86
log
@Allow multiple users to share the same aucat server. If aucat is
run by root, it binds a shared address to the socket, cranks the
process priority and drops privileges. sio_open(3) will try to
connect to the private socket first (if any), then to the shared
socket. Only one user may have connections to aucat at a given
time.

based on discussions with henning, pyr and others
ok jacek, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.85 2010/04/21 06:15:02 ratchov Exp $	*/
d710 2
a711 2
		if ((APROC_OK(dev_mix) && LIST_EMPTY(&dev_mix->obuflist)) ||
		    (APROC_OK(dev_sub) && LIST_EMPTY(&dev_sub->ibuflist))) {
@


1.85
log
@when creating the ``default'' subdevice, use last parameters of the
command line, instead of the device parameters.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.84 2010/04/21 06:13:07 ratchov Exp $	*/
d21 1
d27 1
d48 10
d318 1
d321 8
a328 2
	snprintf(base, PATH_MAX, "/tmp/aucat-%u", uid);
	if (mkdir(base, 0700) < 0) {
d334 1
a334 1
	if (sb.st_uid != uid || (sb.st_mode & 077) != 0)
d339 20
d689 2
d749 1
a749 1
		if (rmdir(base) < 0 && errno != ENOTEMPTY)
d861 2
d919 1
a919 1
		if (rmdir(base) < 0 && errno != ENOTEMPTY)
@


1.84
log
@adds the necessary bits to join channels (ex stereo->mono) or
expand channels (ex mono->stereo).  It's switched on/off with
the ``-j'' option, (default is "on").
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.83 2010/04/06 20:07:01 ratchov Exp $	*/
d544 2
a545 2
		farg_add(&sfiles, &dopar, &dipar,
		    volctl, HDR_RAW, XRUN_IGNORE, mmc, 0, mode, DEFAULT_OPT);
@


1.83
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.82 2010/04/03 17:59:17 ratchov Exp $	*/
d148 10
d210 1
d223 1
a223 1
    int hdr, int xrun, int mmc, unsigned mode, char *name)
d249 1
d354 1
a354 1
	    "[-f device] [-h fmt] [-i file] [-m mode]"
d374 1
a374 1
	int mmc, autostart;
d396 1
d398 1
a398 1
	while ((c = getopt(argc, argv, "dnb:c:C:e:r:h:x:v:i:o:f:m:luq:s:U:t:z:")) != -1) {
d419 3
d453 1
a453 1
			    hdr, xrun, mmc, mode & MODE_PLAY, file);
d460 1
a460 1
			    hdr, xrun, mmc, mode & MODE_RECMASK, file);
d464 1
a464 1
			    hdr, xrun, mmc, mode, optarg);
d468 1
a468 1
			    0, HDR_RAW, 0, 0, 0, optarg);
d545 1
a545 1
		    volctl, HDR_RAW, XRUN_IGNORE, mmc, mode, DEFAULT_OPT);
d626 2
a627 1
			fa->hdr, &fa->ipar, fa->xrun, fa->vol, fa->mmc))
d635 2
a636 1
			fa->hdr, &fa->opar, fa->xrun, fa->mmc))
d643 1
a643 1
		    MIDI_TO_ADATA(fa->vol), fa->mmc, fa->mode);
d752 1
a752 1
			    0, HDR_RAW, 0, 0, 0, optarg);
d756 1
a756 1
			    0, HDR_RAW, 0, 0, 0, optarg);
d762 1
a762 1
			    0, HDR_RAW, 0, 0, 0, optarg);
d803 1
a803 1
		    0, HDR_RAW, 0, 0, 0, NULL);
@


1.82
log
@backout last change, committed by mistake, sorry...
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.80 2010/01/14 17:43:55 ratchov Exp $	*/
a45 3
#define MODE_PLAY	1
#define MODE_REC	2

d159 1
a159 1
int
d162 24
a185 7
	if (strcmp("play", optarg) == 0)
		return MODE_PLAY;
	if (strcmp("rec", optarg) == 0)
		return MODE_REC;
	if (strcmp("duplex", optarg) == 0)
		return MODE_PLAY | MODE_REC;
	errx(1, "%s: bad mode", optarg);
d200 1
d212 1
a212 1
    int hdr, int xrun, int mmc, char *name)
d230 2
d238 1
d308 30
d341 6
a346 3
	    "[-C min:max] [-c min:max] [-e enc] [-f device]\n"
	    "\t[-h fmt] [-i file] [-m mode] [-o file] [-r rate] [-s name]\n"
	    "\t[-t mode] [-U unit] [-v volume] [-x policy] [-z nframes]\n",
d353 1
a353 1
	int c, u_flag, d_flag, l_flag, n_flag, hdr, xrun, suspend = 0, unit;
d355 1
a355 1
	struct farglist ifiles, ofiles, sfiles;
d362 1
a362 1
	int mmc;
d376 1
d380 1
a380 1
	mode = 0;
d383 1
d385 1
a385 1
	while ((c = getopt(argc, argv, "dnb:c:C:e:r:h:x:v:i:o:f:m:lus:U:t:z:")) != -1) {
d408 2
d437 1
a437 1
			    hdr, xrun, 0, file);
d444 1
a444 1
			    hdr, xrun, 0, file);
d448 5
a452 1
			    hdr, xrun, mmc, optarg);
d463 1
d514 2
a515 13
	if ((l_flag || mode != 0) &&
	    (!SLIST_EMPTY(&ofiles) || !SLIST_EMPTY(&ifiles)))
		errx(1, "can't use -l, -m and -s with -o or -i");
	if (!mode) {
		if (l_flag || !SLIST_EMPTY(&ifiles))
			mode |= MODE_PLAY;
		if (l_flag || !SLIST_EMPTY(&ofiles))
			mode |= MODE_REC;
		if (!mode) {
			aucat_usage();
			exit(1);
		}
	}
d517 3
a519 2
		if (devpath != NULL || l_flag)
			errx(1, "can't use -n with -f or -l");
d529 1
a529 1
		    volctl, HDR_RAW, XRUN_IGNORE, mmc, DEFAULT_OPT);
d532 13
a544 9
	if (!u_flag) {
		/*
		 * Calculate "best" device parameters. Iterate over all
		 * inputs and outputs and find the maximum sample rate
		 * and channel number.
		 */
		aparams_init(&dipar, dipar.cmin, dipar.cmax, dipar.rate);
		aparams_init(&dopar, dopar.cmin, dopar.cmax, dopar.rate);
		SLIST_FOREACH(fa, &ifiles, entry) {
d546 8
a553 2
		}
		SLIST_FOREACH(fa, &ofiles, entry) {
d555 6
a560 2
		}
		SLIST_FOREACH(fa, &sfiles, entry) {
d565 1
d584 2
d588 3
a590 4
		if (!dev_init(devpath,
			(mode & MODE_REC) ? &dipar : NULL,
			(mode & MODE_PLAY) ? &dopar : NULL,
			bufsz, round)) {
d599 7
d609 2
a610 2
		if (!wav_new_in(&wav_ops, fa->name,
			fa->hdr, &fa->ipar, fa->xrun, fa->vol))
d617 2
a618 2
		if (!wav_new_out(&wav_ops, fa->name,
			fa->hdr, &fa->opar, fa->xrun))
d625 1
a625 1
		    MIDI_TO_ADATA(fa->vol), fa->mmc);
d635 8
d651 2
a652 2
		if ((dev_mix && LIST_EMPTY(&dev_mix->obuflist)) ||
		    (dev_sub && LIST_EMPTY(&dev_sub->ibuflist))) {
d656 2
d660 6
a665 11
		if ((!dev_mix || dev_mix->u.mix.idle > 2 * dev_bufsz) &&
		    (!dev_sub || dev_sub->u.sub.idle > 2 * dev_bufsz) &&
		    ((dev_mix || dev_sub) && dev_midi->u.ctl.tstate != CTL_RUN)) {
			if (!l_flag)
				break;
			if (!suspend) {
#ifdef DEBUG
				if (debug_level >= 2)
					dbg_puts("suspending\n");
#endif
				suspend = 1;
d668 7
a674 1
				dev_prime();
d677 7
a683 11
		if ((dev_mix && dev_mix->u.mix.idle == 0) ||
		    (dev_sub && dev_sub->u.sub.idle == 0) ||
		    ((dev_mix || dev_sub) && dev_midi->u.ctl.tstate == CTL_RUN)) {
			if (suspend) {
#ifdef DEBUG
				if (debug_level >= 2)
					dbg_puts("resuming\n");
#endif
				suspend = 0;
				dev_start();
			}
d686 3
d690 1
a690 2
		filelist_unlisten();
		if (rmdir(base) < 0)
a692 10
	if (suspend) {
#ifdef DEBUG
		if (debug_level >= 2)
			dbg_puts("resuming to drain\n");
#endif
		suspend = 0;
		dev_start();
	}
	dev_done();
	filelist_done();
d700 2
a701 2
	(void)fputs("usage: " PROG_MIDICAT " [-dl] [-f device] "
	    "[-i file] [-o file] [-U unit]\n",
d723 1
a723 1
	while ((c = getopt(argc, argv, "di:o:lf:U:")) != -1) {
d734 1
a734 1
			    0, HDR_RAW, 0, 0, optarg);
d738 1
a738 1
			    0, HDR_RAW, 0, 0, optarg);
d740 3
a742 1
		case 'f':
d744 1
a744 1
			    0, HDR_RAW, 0, 0, optarg);
d780 1
a780 1
	if (!l_flag)
d785 1
a785 1
		    0, HDR_RAW, 0, 0, NULL);
a843 1

d854 3
d858 1
a858 2
		filelist_unlisten();
		if (rmdir(base) < 0)
a860 2
	dev_done();
	filelist_done();
@


1.81
log
@doc fixes from jmc
@
text
@d46 3
d162 1
a162 1
unsigned
d165 7
a171 24
	unsigned mode = 0;
	char *p = optarg;
	size_t len;

	for (p = optarg; *p != NULL; p++) {
		len = strcspn(p, ",");
		if (strncmp("play", p, len) == 0) {
			mode |= MODE_PLAY;
		} else if (strncmp("rec", p, len) == 0) {
			mode |= MODE_REC;
		} else if (strncmp("mon", p, len) == 0) {
			mode |= MODE_MON;
		} else if (strncmp("duplex", p, len) == 0) {
			/* XXX: backward compat, remove this */
			mode |= MODE_REC | MODE_PLAY;
		} else 
			errx(1, "%s: bad mode", optarg);
		p += len;
		if (*p == '\0')
			break;
	}
	if (mode == 0)
		errx(1, "empty mode");
	return mode;
a185 1
	unsigned mode;
d197 1
a197 1
    int hdr, int xrun, int mmc, unsigned mode, char *name)
a214 2
	if (mmc && xrun == XRUN_IGNORE)
		xrun = XRUN_SYNC;
a220 1
	fa->mode = mode;
a289 30
stopall(char *base)
{
	struct file *f;

  restart:
	LIST_FOREACH(f, &file_list, entry) {
		/*
		 * skip connected streams (handled by dev_done())
		 */
		if (APROC_OK(dev_mix) && f->rproc &&
		    aproc_depend(dev_mix, f->rproc))
			continue;
		if (APROC_OK(dev_sub) && f->wproc &&
		    aproc_depend(f->wproc, dev_sub))
			continue;
		if (APROC_OK(dev_midi)) {
			if (f->rproc && aproc_depend(dev_midi, f->rproc))
				continue;
			if (f->wproc && aproc_depend(f->wproc, dev_midi))
				continue;
		}
		/*
		 * kill anything else
		 */
		file_close(f);
		goto restart;
	}
}

void
d293 3
a295 6
	    "[-C min:max] [-c min:max] [-e enc]\n\t"
	    "[-f device] [-h fmt] [-i file] [-m mode]"
	    "[-o file] [-q device]\n\t"
	    "[-r rate] [-s name] [-t mode] [-U unit] "
	    "[-v volume] [-x policy]\n\t"
	    "[-z nframes]\n",
d302 1
a302 1
	int c, u_flag, d_flag, l_flag, n_flag, hdr, xrun, unit;
d304 1
a304 1
	struct farglist ifiles, ofiles, sfiles, qfiles;
d311 1
a311 1
	int mmc, autostart;
a324 1
	SLIST_INIT(&qfiles);
d328 1
a328 1
	mode = MODE_PLAY | MODE_REC;
a330 1
	autostart = 1;
d332 1
a332 1
	while ((c = getopt(argc, argv, "dnb:c:C:e:r:h:x:v:i:o:f:m:luq:s:U:t:z:")) != -1) {
a354 2
			if (mmc)
				autostart = 0;
d382 1
a382 1
			    hdr, xrun, mmc, mode & MODE_PLAY, file);
d389 1
a389 1
			    hdr, xrun, mmc, mode & MODE_RECMASK, file);
d393 1
a393 5
			    hdr, xrun, mmc, mode, optarg);
			break;
		case 'q':
			farg_add(&qfiles, &aparams_none, &aparams_none,
			    0, HDR_RAW, 0, 0, 0, optarg);
a403 1
			autostart = 0;
d454 13
a466 2
	if (l_flag && (!SLIST_EMPTY(&ofiles) || !SLIST_EMPTY(&ifiles)))
		errx(1, "can't use -l, and -s with -o or -i");
d468 2
a469 3
		if (devpath != NULL || !SLIST_EMPTY(&qfiles) ||
		    l_flag || !autostart)
			errx(1, "can't use -n with -f, -q, -t or -l");
d479 1
a479 1
		    volctl, HDR_RAW, XRUN_IGNORE, mmc, mode, DEFAULT_OPT);
d482 9
a490 13
	/*
	 * Check modes and calculate "best" device parameters. Iterate over all
	 * inputs and outputs and find the maximum sample rate and channel
	 * number.
	 */
	mode = 0;
	aparams_init(&dipar, dipar.cmin, dipar.cmax, dipar.rate);
	aparams_init(&dopar, dopar.cmin, dopar.cmax, dopar.rate);
	SLIST_FOREACH(fa, &ifiles, entry) {
		if (fa->mode == 0)
			errx(1, "%s: not in play mode", fa->name);
		mode |= fa->mode;
		if (!u_flag)
d492 2
a493 8
	}
	SLIST_FOREACH(fa, &ofiles, entry) {
		if (fa->mode == 0)
			errx(1, "%s: not in rec/mon mode", fa->name);
		if ((fa->mode & MODE_REC) && (fa->mode & MODE_MON))
			errx(1, "%s: can't record and monitor", fa->name);
		mode |= fa->mode;
		if (!u_flag)
d495 2
a496 6
	}
	SLIST_FOREACH(fa, &sfiles, entry) {
		if ((fa->mode & MODE_REC) && (fa->mode & MODE_MON))
			errx(1, "%s: can't record and monitor", fa->name);
		mode |= fa->mode;
		if (!u_flag) {
a500 1

a518 2
		if (mode & MODE_MON)
			errx(1, "monitoring not allowed in loopback mode");
d521 4
a524 3
		if ((mode & MODE_MON) && !(mode & MODE_PLAY))
			errx(1, "no playback stream to monitor");
		if (!dev_init(devpath, mode, &dipar, &dopar, bufsz, round)) {
a532 7
	while (!SLIST_EMPTY(&qfiles)) {
		fa = SLIST_FIRST(&qfiles);
		SLIST_REMOVE_HEAD(&qfiles, entry);
		if (!dev_thruadd(fa->name, 1, 1))
			errx(1, "%s: can't open device", fa->name);
		free(fa);
	}
d536 2
a537 2
		if (!wav_new_in(&wav_ops, fa->mode, fa->name,
			fa->hdr, &fa->ipar, fa->xrun, fa->vol, fa->mmc))
d544 2
a545 2
		if (!wav_new_out(&wav_ops, fa->mode, fa->name,
			fa->hdr, &fa->opar, fa->xrun, fa->mmc))
d552 1
a552 1
		    MIDI_TO_ADATA(fa->vol), fa->mmc, fa->mode);
a561 8
	if (autostart) {
		/*
		 * inject artificial mmc start
		 */
		ctl_start(dev_midi);
	}
	if (l_flag)
		dev_prime();
d570 2
a571 2
		if ((APROC_OK(dev_mix) && LIST_EMPTY(&dev_mix->obuflist)) ||
		    (APROC_OK(dev_sub) && LIST_EMPTY(&dev_sub->ibuflist))) {
a574 2
		if (!l_flag && ctl_idle(dev_midi))
			break;
d577 11
a587 6
		if ((!APROC_OK(dev_mix)    || dev_mix->u.mix.idle > 2 * dev_bufsz) &&
		    (!APROC_OK(dev_sub)    || dev_sub->u.sub.idle > 2 * dev_bufsz) &&
		    (!APROC_OK(dev_submon) || dev_submon->u.sub.idle > 2 * dev_bufsz) &&
		    (!APROC_OK(dev_midi)   || dev_midi->u.ctl.tstate != CTL_RUN)) {
		    	if (dev_pstate == DEV_RUN) {
				dev_pstate = DEV_INIT;
d590 1
a590 7
				/*
				 * priming buffer in non-server mode is not
				 * ok, because it will insert silence and
				 * break synchronization
				 */
				if (l_flag)
					dev_prime();
d593 11
a603 7
		/*
		 * move device state machine
		 * XXX: move this to dev.c
		 */
		if (dev_pstate == DEV_START) {
			dev_pstate = DEV_RUN;
			dev_start();
a605 3
	stopall(base);
	dev_done();
	filelist_done();
d607 2
a608 1
		if (rmdir(base) < 0 && errno != ENOTEMPTY)
d611 10
d628 2
a629 2
	(void)fputs("usage: " PROG_MIDICAT " [-dl] "
	    "[-i file] [-o file] [-q device] [-U unit]\n",
d651 1
a651 1
	while ((c = getopt(argc, argv, "di:o:lf:q:U:")) != -1) {
d662 1
a662 1
			    0, HDR_RAW, 0, 0, 0, optarg);
d666 1
a666 1
			    0, HDR_RAW, 0, 0, 0, optarg);
d668 1
a668 3
			/* XXX: backward compat, remove this */
		case 'f':	
		case 'q':
d670 1
a670 1
			    0, HDR_RAW, 0, 0, 0, optarg);
d706 1
a706 1
	if (!l_flag && APROC_OK(dev_midi))
d711 1
a711 1
		    0, HDR_RAW, 0, 0, 0, NULL);
d770 1
a780 3
	stopall(base);
	dev_done();
	filelist_done();
d782 2
a783 1
		if (rmdir(base) < 0 && errno != ENOTEMPTY)
d786 2
@


1.80
log
@Use -C option to specify recorded channel range instead of -c which
is for played channels.

spotted by Jan Stary <hans at stare.cz>, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.79 2010/01/11 13:06:32 ratchov Exp $	*/
a45 3
#define MODE_PLAY	1
#define MODE_REC	2

d159 1
a159 1
int
d162 24
a185 7
	if (strcmp("play", optarg) == 0)
		return MODE_PLAY;
	if (strcmp("rec", optarg) == 0)
		return MODE_REC;
	if (strcmp("duplex", optarg) == 0)
		return MODE_PLAY | MODE_REC;
	errx(1, "%s: bad mode", optarg);
d200 1
d212 1
a212 1
    int hdr, int xrun, int mmc, char *name)
d230 2
d238 1
d308 30
d341 6
a346 3
	    "[-C min:max] [-c min:max] [-e enc] [-f device]\n"
	    "\t[-h fmt] [-i file] [-m mode] [-o file] [-r rate] [-s name]\n"
	    "\t[-t mode] [-U unit] [-v volume] [-x policy] [-z nframes]\n",
d353 1
a353 1
	int c, u_flag, d_flag, l_flag, n_flag, hdr, xrun, suspend = 0, unit;
d355 1
a355 1
	struct farglist ifiles, ofiles, sfiles;
d362 1
a362 1
	int mmc;
d376 1
d380 1
a380 1
	mode = 0;
d383 1
d385 1
a385 1
	while ((c = getopt(argc, argv, "dnb:c:C:e:r:h:x:v:i:o:f:m:lus:U:t:z:")) != -1) {
d408 2
d437 1
a437 1
			    hdr, xrun, 0, file);
d444 1
a444 1
			    hdr, xrun, 0, file);
d448 5
a452 1
			    hdr, xrun, mmc, optarg);
d463 1
d514 2
a515 13
	if ((l_flag || mode != 0) &&
	    (!SLIST_EMPTY(&ofiles) || !SLIST_EMPTY(&ifiles)))
		errx(1, "can't use -l, -m and -s with -o or -i");
	if (!mode) {
		if (l_flag || !SLIST_EMPTY(&ifiles))
			mode |= MODE_PLAY;
		if (l_flag || !SLIST_EMPTY(&ofiles))
			mode |= MODE_REC;
		if (!mode) {
			aucat_usage();
			exit(1);
		}
	}
d517 3
a519 2
		if (devpath != NULL || l_flag)
			errx(1, "can't use -n with -f or -l");
d529 1
a529 1
		    volctl, HDR_RAW, XRUN_IGNORE, mmc, DEFAULT_OPT);
d532 13
a544 9
	if (!u_flag) {
		/*
		 * Calculate "best" device parameters. Iterate over all
		 * inputs and outputs and find the maximum sample rate
		 * and channel number.
		 */
		aparams_init(&dipar, dipar.cmin, dipar.cmax, dipar.rate);
		aparams_init(&dopar, dopar.cmin, dopar.cmax, dopar.rate);
		SLIST_FOREACH(fa, &ifiles, entry) {
d546 8
a553 2
		}
		SLIST_FOREACH(fa, &ofiles, entry) {
d555 6
a560 2
		}
		SLIST_FOREACH(fa, &sfiles, entry) {
d565 1
d584 2
d588 3
a590 4
		if (!dev_init(devpath,
			(mode & MODE_REC) ? &dipar : NULL,
			(mode & MODE_PLAY) ? &dopar : NULL,
			bufsz, round)) {
d599 7
d609 2
a610 2
		if (!wav_new_in(&wav_ops, fa->name,
			fa->hdr, &fa->ipar, fa->xrun, fa->vol))
d617 2
a618 2
		if (!wav_new_out(&wav_ops, fa->name,
			fa->hdr, &fa->opar, fa->xrun))
d625 1
a625 1
		    MIDI_TO_ADATA(fa->vol), fa->mmc);
d635 8
d651 2
a652 2
		if ((dev_mix && LIST_EMPTY(&dev_mix->obuflist)) ||
		    (dev_sub && LIST_EMPTY(&dev_sub->ibuflist))) {
d656 2
d660 6
a665 11
		if ((!dev_mix || dev_mix->u.mix.idle > 2 * dev_bufsz) &&
		    (!dev_sub || dev_sub->u.sub.idle > 2 * dev_bufsz) &&
		    ((dev_mix || dev_sub) && dev_midi->u.ctl.tstate != CTL_RUN)) {
			if (!l_flag)
				break;
			if (!suspend) {
#ifdef DEBUG
				if (debug_level >= 2)
					dbg_puts("suspending\n");
#endif
				suspend = 1;
d668 7
a674 1
				dev_prime();
d677 7
a683 11
		if ((dev_mix && dev_mix->u.mix.idle == 0) ||
		    (dev_sub && dev_sub->u.sub.idle == 0) ||
		    ((dev_mix || dev_sub) && dev_midi->u.ctl.tstate == CTL_RUN)) {
			if (suspend) {
#ifdef DEBUG
				if (debug_level >= 2)
					dbg_puts("resuming\n");
#endif
				suspend = 0;
				dev_start();
			}
d686 3
d690 1
a690 2
		filelist_unlisten();
		if (rmdir(base) < 0)
a692 10
	if (suspend) {
#ifdef DEBUG
		if (debug_level >= 2)
			dbg_puts("resuming to drain\n");
#endif
		suspend = 0;
		dev_start();
	}
	dev_done();
	filelist_done();
d700 2
a701 2
	(void)fputs("usage: " PROG_MIDICAT " [-dl] [-f device] "
	    "[-i file] [-o file] [-U unit]\n",
d723 1
a723 1
	while ((c = getopt(argc, argv, "di:o:lf:U:")) != -1) {
d734 1
a734 1
			    0, HDR_RAW, 0, 0, optarg);
d738 1
a738 1
			    0, HDR_RAW, 0, 0, optarg);
d740 3
a742 1
		case 'f':
d744 1
a744 1
			    0, HDR_RAW, 0, 0, optarg);
d780 1
a780 1
	if (!l_flag)
d785 1
a785 1
		    0, HDR_RAW, 0, 0, NULL);
a843 1

d854 3
d858 1
a858 2
		filelist_unlisten();
		if (rmdir(base) < 0)
a860 2
	dev_done();
	filelist_done();
@


1.79
log
@When resuming from suspend, prime play buffers with silence,
otherwise the client would underrun by more than its own buffer
size, which currently is not allowed (causes the client to
deadlock).

Set the minimum client buffer size to two blocks. Single block
buffers don't work properly yet.

with help from jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.78 2010/01/10 21:47:41 ratchov Exp $	*/
d545 1
a545 1
			fa->hdr, &fa->ipar, fa->xrun))
@


1.78
log
@Add traces to help tracking subtle timing bugs often causing
underuns and overruns; such bugs are hard to debug with ktrace
or a debugger. They are also handy to debug or monitor code
using aucat.

To enable traces, compile aucat with ``make DEBUG=-DDEBUG'' and
use the -d option multiple times.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.77 2010/01/05 10:18:12 ratchov Exp $	*/
d590 1
@


1.77
log
@Make the way .wav files are handled closer to the way sockets are
handled, which is conceptually simpler. No behaviour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.76 2009/11/21 14:21:08 ratchov Exp $	*/
d42 3
d52 3
d70 21
d239 8
d257 6
d335 4
d583 4
d596 4
d611 4
d653 4
@


1.76
log
@use strtonum(3) and strtol(3) instead of sscanf(3)
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.75 2009/11/21 10:24:13 deraadt Exp $	*/
a39 1
#include "miofile.h"
d170 1
a170 1
    int hdr, int xrun, int mmc, char *optarg)
d177 1
a177 1
		err(1, "%s", optarg);
d180 2
a181 3
		namelen = strlen(optarg);
		if (namelen >= 4 &&
		    strcasecmp(optarg + namelen - 4, ".wav") == 0) {
d192 1
a192 1
	fa->name = optarg;
a196 108
/*
 * Open an input file and setup converter if necessary.
 */
void
newinput(struct farg *fa)
{
	int fd;
	struct wav *f;
	struct aproc *proc;
	struct abuf *buf;
	unsigned nfr;

	if (strcmp(fa->name, "-") == 0) {
		fd = STDIN_FILENO;
		if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)
			warn("stdin");
		fa->name = "stdin";
	} else {
		fd = open(fa->name, O_RDONLY | O_NONBLOCK, 0666);
		if (fd < 0)
			err(1, "%s", fa->name);
	}
	/*
	 * XXX : we should round rate, right ?
	 */
	f = wav_new_in(&wav_ops, fd, fa->name, &fa->ipar, fa->hdr);
	if (f == NULL) {
		if (fd != STDIN_FILENO)
			close(fd);
		return;
	}
	nfr = dev_bufsz * fa->ipar.rate / dev_rate;
	buf = abuf_new(nfr, &fa->ipar);
	proc = rpipe_new((struct file *)f);
	aproc_setout(proc, buf);
	abuf_fill(buf); /* XXX: move this in dev_attach() ? */
	dev_attach(fa->name, buf, &fa->ipar, fa->xrun,
	    NULL, NULL, 0, ADATA_UNIT);
	dev_setvol(buf, MIDI_TO_ADATA(fa->vol));
}

/*
 * Open an output file and setup converter if necessary.
 */
void
newoutput(struct farg *fa)
{
	int fd;
	struct wav *f;
	struct aproc *proc;
	struct abuf *buf;
	unsigned nfr;

	if (strcmp(fa->name, "-") == 0) {
		fd = STDOUT_FILENO;
		if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0)
			warn("stdout");
		fa->name = "stdout";
	} else {
		fd = open(fa->name,
		    O_WRONLY | O_TRUNC | O_CREAT | O_NONBLOCK, 0666);
		if (fd < 0)
			err(1, "%s", fa->name);
	}
	/*
	 * XXX : we should round rate, right ?
	 */
	f = wav_new_out(&wav_ops, fd, fa->name, &fa->opar, fa->hdr);
	if (f == NULL) {
		if (fd != STDOUT_FILENO)
			close(fd);
		return;
	}
	nfr = dev_bufsz * fa->opar.rate / dev_rate;
	proc = wpipe_new((struct file *)f);
	buf = abuf_new(nfr, &fa->opar);
	aproc_setin(proc, buf);
	dev_attach(fa->name, NULL, NULL, 0, buf, &fa->opar, fa->xrun, 0);
}

/*
 * Open a MIDI device and connect it to the thru box
 */
void
newmidi(struct farg *fa, int in, int out)
{
	struct file *dev;
	struct abuf *rbuf = NULL, *wbuf = NULL;
	struct aproc *rproc, *wproc;

	dev = (struct file *)miofile_new(&miofile_ops, fa->name, in, out);
	if (dev == NULL) {
		errx(1, "%s: can't open device", 
		    fa->name ? fa->name : "<default>");
	}
	if (in) {
		rproc = rpipe_new(dev);
		rbuf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setout(rproc, rbuf);
	}
	if (out) {
		wproc = wpipe_new(dev);
		wbuf = abuf_new(MIDI_BUFSZ, &aparams_none);
		aproc_setin(wproc, wbuf);
	}
	dev_midiattach(rbuf, wbuf);
}

d265 1
a265 1
	char base[PATH_MAX], path[PATH_MAX];
d333 3
d337 1
a337 1
			    hdr, xrun, 0, optarg);
d340 3
d344 1
a344 1
			    hdr, xrun, 0, optarg);
d491 3
a493 1
		newinput(fa);
d499 2
a500 1
		newoutput(fa);
d654 6
a659 3
		newmidi(fa,
		    !SLIST_EMPTY(&ofiles) || l_flag,
		    !SLIST_EMPTY(&ifiles) || l_flag);
d682 1
a682 1
		p = rpipe_new(stdx);
d702 1
a702 1
		p = wpipe_new(stdx);
@


1.75
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.74 2009/11/03 21:31:37 ratchov Exp $	*/
d69 2
a70 4
	if (sscanf(optarg, "%u:%u", &par->cmin, &par->cmax) != 2 ||
	    par->cmax < par->cmin || par->cmax > NCHAN_MAX - 1)
		errx(1, "%s: bad channel range", optarg);
}
d72 18
a89 14
void
opt_rate(struct aparams *par)
{
	if (sscanf(optarg, "%u", &par->rate) != 1 ||
	    par->rate < RATE_MIN || par->rate > RATE_MAX)
		errx(1, "%s: bad sample rate", optarg);
}

void
opt_vol(unsigned *vol)
{
	if (sscanf(optarg, "%u", vol) != 1 ||
	    *vol > MIDI_MAXCTL)
		errx(1, "%s: bad volume", optarg);
d378 1
d432 3
a434 1
			opt_rate(&ipar);
d438 3
a440 1
			opt_vol(&volctl);
d468 3
a470 4
			if (sscanf(optarg, "%u", &bufsz) != 1 || bufsz == 0) {
				fprintf(stderr, "%s: bad buf size\n", optarg);
				exit(1);
			}
d473 3
a475 4
			if (sscanf(optarg, "%u", &unit) != 1) {
				fprintf(stderr, "%s: bad device number\n", optarg);
				exit(1);
			}
d478 3
a480 4
			if (sscanf(optarg, "%u", &round) != 1 || round == 0) {
				fprintf(stderr, "%s: bad block size\n", optarg);
				exit(1);
			}
a481 1
			
d685 1
d715 3
a717 4
			if (sscanf(optarg, "%u", &unit) != 1) {
				fprintf(stderr, "%s: bad device number\n", optarg);
				exit(1);
			}
@


1.74
log
@Allow any program using aucat to act as MMC slave and MTC master
transparently.  Multiple audio applications can be started
synchronously from external software/hardware supporting the
standard Start/Stop/Relocate messages. The server clock is exposed
through MTC, allowing non-audio software/hardware to be
synchronized to audio applications.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.73 2009/10/27 22:21:37 ratchov Exp $	*/
d625 1
a625 1
			fprintf(stderr, "device desappeared, terminating\n");
@


1.73
log
@add missing word in error message
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.72 2009/10/10 13:55:37 ratchov Exp $	*/
d113 10
d157 1
d169 1
a169 1
    int hdr, int xrun, char *optarg)
d193 1
d362 1
a362 1
	    "\t[-U unit] [-v volume] [-x policy]\n",
d374 1
a374 1
	unsigned bufsz, mode;
d377 1
d386 1
a393 1
	bufsz = 44100 * 4 / 15; /* XXX: use milliseconds, not frames */
d395 2
d398 1
a398 1
	while ((c = getopt(argc, argv, "dnb:c:C:e:r:h:x:v:i:o:f:m:lus:U:")) != -1) {
d415 3
d437 1
a437 1
			    hdr, xrun, optarg);
d441 1
a441 1
			    hdr, xrun, optarg);
d445 1
a445 1
			    hdr, xrun, optarg);
d472 7
d535 1
a535 1
		    volctl, HDR_RAW, XRUN_IGNORE, DEFAULT_OPT);
d557 4
d580 1
a580 1
			bufsz)) {
d604 2
a605 1
		opt_new(fa->name, &fa->opar, &fa->ipar, MIDI_TO_ADATA(fa->vol));
d631 2
a632 1
		    (!dev_sub || dev_sub->u.sub.idle > 2 * dev_bufsz)) {
d642 2
a643 1
		    (dev_sub && dev_sub->u.sub.idle == 0)) {
d697 1
a697 1
			    0, HDR_RAW, 0, optarg);
d701 1
a701 1
			    0, HDR_RAW, 0, optarg);
d705 1
a705 1
			    0, HDR_RAW, 0, optarg);
d743 1
a743 1
		dev_midi->u.thru.flags |= THRU_AUTOQUIT;
d747 1
a747 1
		    0, HDR_RAW, 0, NULL);
@


1.72
log
@don't use a references to the device file to check the current mode
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.71 2009/10/10 12:43:09 ratchov Exp $	*/
d121 1
a121 1
	errx(1, "%s: underrun/overrun policy", optarg);
@


1.71
log
@make dev_done() common to audio and MIDI, and drop dev_thrudone()
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.70 2009/10/10 11:58:41 ratchov Exp $	*/
d593 2
a594 2
		if ((!dev_rec || dev_rec->u.io.file == NULL) &&
		    (!dev_play || dev_play->u.io.file == NULL) && !n_flag) {
@


1.70
log
@use dev_done() for loopback devices too and remove dev_loopdone()
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.69 2009/10/05 07:05:24 ratchov Exp $	*/
d710 2
a778 2
		if (!l_flag && LIST_EMPTY(&dev_midi->ibuflist))
			break;
d787 1
a787 1
	dev_thrudone();
@


1.69
log
@add -d flag. When started in server mode, if the -d flag is
used aucat and midicat don't daemonize and log on stderr.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.68 2009/09/27 11:51:20 ratchov Exp $	*/
d627 1
a627 4
	if (n_flag) {
		dev_loopdone();
	} else
		dev_done();
@


1.68
log
@remove all debug traces
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.67 2009/08/26 06:33:52 jmc Exp $	*/
d347 1
a347 1
	(void)fputs("usage: " PROG_AUCAT " [-lnu] [-b nframes] "
d357 1
a357 1
	int c, u_flag, l_flag, n_flag, hdr, xrun, suspend = 0, unit;
d369 1
d383 1
a383 1
	while ((c = getopt(argc, argv, "nb:c:C:e:r:h:x:v:i:o:f:m:lus:U:")) != -1) {
d385 3
d582 1
a582 1
		if (daemon(0, 0) < 0)
d639 1
a639 1
	(void)fputs("usage: " PROG_MIDICAT " [-l] [-f device] "
d646 1
a646 1
	int c, l_flag, unit, fd;
d654 1
d661 1
a661 1
	while ((c = getopt(argc, argv, "i:o:lf:U:")) != -1) {
d663 3
d730 1
a730 1
		if (daemon(0, 0) < 0)
@


1.67
log
@oops, forgot to update usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.66 2009/08/19 18:29:34 ratchov Exp $	*/
a49 1
int debug_level = 0;
a64 33
/*
 * Increase debug level on SIGUSR1.
 */
void
sigusr1(int s)
{
	if (debug_level < 4)
		debug_level++;
}

/*
 * Decrease debug level on SIGUSR2.
 */
void
sigusr2(int s)
{
	if (debug_level > 0)
		debug_level--;
}

void
set_debug_level(char *envname)
{
	char *dbgenv;
	const char *errstr;

	dbgenv = getenv(envname);
	if (dbgenv) {
		debug_level = strtonum(dbgenv, 0, 4, &errstr);
		if (errstr)
			errx(1, "%s is %s: %s", envname, errstr, dbgenv);
	}
}
a171 1
			DPRINTF("%s: assuming wav file format\n", optarg);
a173 1
			DPRINTF("%s: assuming headerless file\n", optarg);
d303 1
a303 1
		DPRINTF("sigaction(int) failed\n");
d305 1
a305 1
		DPRINTF("sigaction(term) failed\n");
d307 1
a307 9
		DPRINTF("sigaction(hup) failed\n");
#ifdef DEBUG
	sa.sa_handler = sigusr1;
	if (sigaction(SIGUSR1, &sa, NULL) < 0)
		DPRINTF("sigaction(usr1) failed\n");
	sa.sa_handler = sigusr2;
	if (sigaction(SIGUSR2, &sa, NULL) < 0)
		DPRINTF("sigaction(usr2) failed1n");
#endif
a317 6
#ifdef DEBUG
	if (sigaction(SIGUSR2, &sa, NULL) < 0)
		DPRINTF("unsetsig(usr2): sigaction failed\n");
	if (sigaction(SIGUSR1, &sa, NULL) < 0)
		DPRINTF("unsetsig(usr1): sigaction failed\n");
#endif
d319 1
a319 1
		DPRINTF("unsetsig(hup): sigaction failed\n");
d321 1
a321 1
		DPRINTF("unsetsig(term): sigaction failed\n");
d323 1
a323 1
		DPRINTF("unsetsig(int): sigaction failed\n");
d578 1
a578 1
		if (debug_level == 0 && daemon(0, 0) < 0)
a600 1
				DPRINTF("suspending\n");
a608 1
				DPRINTF("resuming\n");
a619 1
		DPRINTF("resuming to drain\n");
d722 1
a722 1
		if (debug_level == 0 && daemon(0, 0) < 0)
a799 1
		set_debug_level("AUCAT_DEBUG");
a801 1
		set_debug_level("MIDICAT_DEBUG");
@


1.66
log
@don't try to process -o arguments using the input file list, fixes
midicat crashing sometimes when -o is used
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.65 2009/08/19 05:54:15 ratchov Exp $	*/
d399 1
a399 1
	    "\t[-h fmt] [-i file] [-m mode] [-o file] [-r rate] [-s socket]\n"
@


1.65
log
@organize midi code like audio code, no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.64 2009/08/17 16:17:46 ratchov Exp $	*/
d798 2
a799 2
		fa = SLIST_FIRST(&ifiles);
		SLIST_REMOVE_HEAD(&ifiles, entry);
@


1.64
log
@allow midicat to take multiple -i and -o options
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.63 2009/08/17 15:07:49 ratchov Exp $	*/
a319 1
		aproc_setin(thrubox, rbuf);
a324 5
		aproc_setout(thrubox, wbuf);
		if (in) {
			rbuf->duplex = wbuf;
			wbuf->duplex = rbuf;
		}
d326 1
d699 1
a699 1
	struct file *stdx, *f;
d757 1
a757 3
	thrubox = thru_new("thru");
	thrubox->refs++;

d794 1
a794 1
		aproc_setin(thrubox, buf);
d814 1
a814 1
		aproc_setout(thrubox, buf);
d825 1
a825 1
		if (!l_flag && LIST_EMPTY(&thrubox->ibuflist))
d835 1
a835 18
	if (thrubox) {
	restart_thrubox:
		LIST_FOREACH(f, &file_list, entry) {
			if (f->rproc && aproc_depend(thrubox, f->rproc)) {
				file_eof(f);
				goto restart_thrubox;
			}
		}
		while (!LIST_EMPTY(&thrubox->ibuflist)) {
			if (!file_poll())
				break;
		}
		thrubox->refs--;
		aproc_del(thrubox);
		thrubox = NULL;
		while (file_poll())
			; /* nothing */
	}
@


1.63
log
@if one or more MIDI devices are specified in server mode, subscribe
them to the MIDI thru box
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.62 2009/07/25 10:52:18 ratchov Exp $	*/
d318 1
a318 1
		rbuf = abuf_new(3125, &aparams_none);
d324 1
a324 1
		wbuf = abuf_new(3125, &aparams_none);
d701 1
a701 1
	struct farglist dfiles;
a702 1
	char *input, *output;
a709 2
	output = NULL;
	input = NULL;
d711 2
d717 2
a718 3
			if (input != NULL)
				errx(1, "only one -i allowed");
			input = optarg;
d721 2
a722 3
			if (output != NULL)
				errx(1, "only one -o allowed");
			output = optarg;
d726 1
a726 1
			    HDR_RAW, 0, 0, optarg);
d745 2
a746 1
	if (argc > 0 || (!input && !output && !l_flag)) {
d753 1
a753 1
		if (input || output)
d765 2
a766 1
	if ((input || output) && SLIST_EMPTY(&dfiles)) {
a769 1

d773 3
a775 1
		newmidi(fa, output || l_flag, input || l_flag);
a777 1
	
d785 4
a788 2
	if (input) {
		if (strcmp(input, "-") == 0) {
d793 1
a793 1
			fd = open(input, O_RDONLY | O_NONBLOCK, 0666);
d795 1
a795 1
				err(1, "%s", input);
d797 1
a797 1
		stdx = (struct file *)pipe_new(&pipe_ops, fd, "stdin");
d799 1
a799 1
		buf = abuf_new(3125, &aparams_none);
d802 1
d804 4
a807 2
	if (output) {
		if (strcmp(output, "-") == 0) {
d812 1
a812 1
			fd = open(output,
d815 1
a815 1
				err(1, "%s", output);
d817 1
a817 1
		stdx = (struct file *)pipe_new(&pipe_ops, fd, "stdout");
d819 1
a819 1
		buf = abuf_new(3125, &aparams_none);
d822 1
@


1.62
log
@fix comments, remove no longer needed declaration, reorder includes
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.61 2009/07/25 08:44:27 ratchov Exp $	*/
d301 33
d414 1
a414 1
	struct farglist  ifiles, ofiles, sfiles;
a699 1
	static struct aparams noparams = { 1, 0, 0, 0, 0, 0, 0, 0 };
d701 1
d703 4
a706 3
	char *input, *output, *devpath;
	struct file *dev, *stdx, *f;
	struct aproc *p, *send, *recv;
a710 1
	devpath = NULL;
d713 1
d728 2
a729 1
			devpath = optarg;
d764 15
a779 2
		thrubox = thru_new("thru");
		thrubox->refs++;
a785 8
	if (input || output) {
		dev = (struct file *)miofile_new(&miofile_ops, devpath,
		     output ? 1 : 0, input ? 1 : 0);
		if (dev == NULL)
			errx(1, "%s: can't open device", 
			    devpath ? devpath : "<default>");
	} else
		dev = NULL;
a786 2
		send = wpipe_new(dev);
		send->refs++;
d798 1
a798 1
		buf = abuf_new(3125, &noparams);
d800 2
a801 3
		aproc_setin(send, buf);
	} else
		send = NULL;
a802 2
		recv = rpipe_new(dev);
		recv->refs++;
d815 1
a815 1
		buf = abuf_new(3125, &noparams);
d817 2
a818 3
		aproc_setout(recv, buf);
	} else
		recv = NULL;
d827 2
a853 27
	}
	if (send) {
	restart_send:
		LIST_FOREACH(f, &file_list, entry) {
			if (f->rproc && aproc_depend(send, f->rproc)) {
				file_eof(f);
				goto restart_send;
			}
		}
		while (!LIST_EMPTY(&send->ibuflist)) {
			if (!file_poll())
				break;
		}
		send->refs--;
		aproc_del(send);
		send = NULL;
	}
	if (recv) {
		if (recv->u.io.file)
			file_eof(recv->u.io.file);
		while (!LIST_EMPTY(&recv->obuflist)) {
			if (!file_poll())
				break;
		}
		recv->refs--;
		aproc_del(recv);
		recv = NULL;
@


1.61
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.60 2009/04/27 18:09:34 ratchov Exp $	*/
a17 1
#include <sys/types.h>
d20 1
d33 1
a33 1
#include "conf.h"
d36 2
a37 2
#include "abuf.h"
#include "wav.h"
a38 1
#include "dev.h"
d40 1
d42 1
a42 1
#include "miofile.h"
d56 1
a56 1
 * is blocked somewhere, so exit
d67 1
a67 1
 * increase debug level on SIGUSR1
d77 1
a77 1
 * decrease debug level on SIGUSR2
d155 1
a155 1
	errx(1, "%s: onderrun/overrun policy", optarg);
d524 1
a524 1
	 * if there are no sockets paths provided use the default
d561 1
a561 1
	 * the other half is for the socket/files
d605 1
a605 1
	 * loop, start audio
@


1.60
log
@make -v option apply also to implicit default socket
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.59 2009/03/17 21:26:44 jmc Exp $	*/
a16 30
/*
 * TODO:
 *
 *	(hard) use parsable encoding names instead of the lookup
 *	table. For instance, [s|u]bits[le|be][/bytes{msb|lsb}], example
 *	s8, s16le, s24le/3msb. This would give names that correspond to
 *	what use most linux-centric apps, but for which we have an
 *	algorithm to convert the name to a aparams structure.
 *
 *	(easy) uses {chmin-chmax} instead of chmin:chmax notation for
 *	channels specification to match the notation used in rmix.
 *
 *	(easy) use comma-separated parameters syntax, example:
 *	s24le/3msb,{3-6},48000 so we don't have to use three -e, -r, -c
 *	flags, but only one -p flag that specify one or more parameters.
 *
 *	(hard) if all inputs are over, the mixer terminates and closes
 *	the write end of the device. It should continue writing zeros
 *	until the recording is over (or be able to stop write end of
 *	the device)
 *
 *	(hard) implement -n flag (no device) to connect all inputs to
 *	the outputs.
 *
 *	(hard) ignore input files that are not audible (because channels
 *	they provide are not used on the output). Similarly ignore
 *	outputs that are zero filled (because channels they consume are
 *	not provided).
 */

d40 3
d47 3
d87 1
a87 1
usage(void)
d89 2
a90 1
	extern char *__progname;
d92 6
a97 6
	fprintf(stderr,
	    "usage: %s [-lnu] [-b nframes] [-C min:max] [-c min:max] [-e enc] "
	    "[-f device]\n"
	    "\t[-h fmt] [-i file] [-m mode] [-o file] [-r rate] [-s socket]\n"
	    "\t[-v volume] [-x policy]\n",
	    __progname);
d301 75
d377 1
a377 1
main(int argc, char **argv)
d379 1
a379 1
	int c, u_flag, l_flag, n_flag, hdr, xrun, suspend = 0;
a382 2
	struct sigaction sa;
	struct stat sb;
d385 1
a385 2
	char *devpath, *dbgenv;
	const char *errstr;
a386 8
	uid_t uid;

	dbgenv = getenv("AUCAT_DEBUG");
	if (dbgenv) {
		debug_level = strtonum(dbgenv, 0, 4, &errstr);
		if (errstr)
			errx(1, "AUCAT_DEBUG is %s: %s", errstr, dbgenv);
	}
d393 1
d404 1
a404 1
	while ((c = getopt(argc, argv, "nb:c:C:e:r:h:x:v:i:o:f:m:lus:")) != -1) {
d466 6
d473 1
a473 1
			usage();
a483 1

d497 1
a497 1
		usage();
d501 2
a502 2
	if (!l_flag && !SLIST_EMPTY(&sfiles))
		errx(1, "can't use -s without -l");
d511 4
a514 2
		if (!mode)
			errx(1, "nothing to play or record");
d528 1
a528 1
		    volctl, HDR_RAW, XRUN_IGNORE, DEFAULT_SOCKET);
d552 3
a554 10
		uid = geteuid();
		snprintf(base, PATH_MAX, "/tmp/aucat-%u", uid);
		if (mkdir(base, 0700) < 0) {
			if (errno != EEXIST)
				err(1, "mkdir(\"%s\")", base);
		}
		if (stat(base, &sb) < 0)
			err(1, "stat(\"%s\")", base);
		if (sb.st_uid != uid || (sb.st_mode & 077) != 0)
			errx(1, "%s has wrong permissions", base);
d556 1
a556 18
	quit_flag = 0;
	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = sigint;
	if (sigaction(SIGINT, &sa, NULL) < 0)
		DPRINTF("sigaction(int) failed\n");
	if (sigaction(SIGTERM, &sa, NULL) < 0)
		DPRINTF("sigaction(term) failed\n");
	if (sigaction(SIGHUP, &sa, NULL) < 0)
		DPRINTF("sigaction(hup) failed\n");
#ifdef DEBUG
	sa.sa_handler = sigusr1;
	if (sigaction(SIGUSR1, &sa, NULL) < 0)
		DPRINTF("sigaction(usr1) failed\n");
	sa.sa_handler = sigusr2;
	if (sigaction(SIGUSR2, &sa, NULL) < 0)
		DPRINTF("sigaction(usr2) failed1n");
#endif
d593 1
a593 5
		if (strchr(fa->name, '/') != NULL)
			errx(1, "socket names must not contain '/'");
		snprintf(path, PATH_MAX, "%s/%s", base, fa->name);
		listen_new(&listen_ops, path, &fa->opar, &fa->ipar,
		    MIDI_TO_ADATA(fa->vol));
d596 5
a600 2
	if (l_flag && debug_level == 0) {
		if (daemon(0, 0) < 0)
d653 132
d786 62
a847 5
       	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = SIG_DFL;
	if (sigaction(SIGINT, &sa, NULL) < 0)
		DPRINTF("dev_done: sigaction failed\n");
d849 23
@


1.59
log
@- rename the arg to -b "nframes" and sync usage()
- grammar fix for the server section

from Thomas Pfaff
ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.58 2009/02/06 08:26:34 ratchov Exp $	*/
d479 1
a479 1
		    MIDI_MAXCTL, HDR_RAW, XRUN_IGNORE, DEFAULT_SOCKET);
@


1.58
log
@move error messages reported to user into main()
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.57 2009/02/04 20:35:14 ratchov Exp $	*/
d116 1
a116 1
	    "usage: %s [-lnu] [-b nsamples] [-C min:max] [-c min:max] [-e enc] "
@


1.57
log
@if there are too many connections, stop acceping new ones rather
than exit()ing with ``too many open files'' fatal error
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.56 2009/02/04 08:00:33 ratchov Exp $	*/
d461 1
a461 1
		mode |= MODE_PLAY;
d464 2
d541 7
a547 4
		dev_init(devpath,
		    (mode & MODE_REC) ? &dipar : NULL,
		    (mode & MODE_PLAY) ? &dopar : NULL,
		    bufsz);
@


1.56
log
@daemonize when in server mode, suggested by many
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.55 2009/02/03 19:44:58 ratchov Exp $	*/
d270 5
d312 5
@


1.55
log
@in server mode, create /tmp/aucat-userid/ directory with
permissions 0700, and create sockets in it. This prevents
one local user to eavesdrop or disturb audio programs of
other users.

if you're using the ``-s socket'' option with an absolute
path as argument, please update it to use a socket name.

requested by many, bits from jakemsr and otto
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.54 2009/01/25 17:07:39 ratchov Exp $	*/
d559 4
@


1.54
log
@don't set malloc_options to not interfer with /etc/malloc.conf
requested and explained by fgsch@@, henning@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.53 2009/01/23 17:52:13 ratchov Exp $	*/
d50 1
a51 1
#include <signal.h>
d53 1
d55 1
d322 2
d328 1
d490 12
d553 5
a557 2
		(void)listen_new(&listen_ops, fa->name,
		    &fa->opar, &fa->ipar, MIDI_TO_ADATA(fa->vol));
d595 1
a595 1
	if (l_flag)
d597 3
@


1.53
log
@catch SIGHUP and SIGTERM too, to ensure that recorded files are
properly closed and sockets are cleaned up.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.52 2009/01/23 17:38:15 ratchov Exp $	*/
a322 1
	extern char *malloc_options;
a323 2

	malloc_options = "FGJ";
@


1.52
log
@spacing + typo fix from Matt Jibson <matt.jibson(at)gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.51 2009/01/10 20:02:28 ratchov Exp $	*/
d494 4
@


1.51
log
@add "loopback" mode in which input is connected to the output.
This is useful to mix, demultiplex, resample or reencode audio
files off-line.
tweak + ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.50 2008/12/29 17:59:08 ratchov Exp $	*/
d211 1
a211 1
farg_add(struct farglist *list, 
d217 1
a217 1
	
d224 1
a224 1
		if (namelen >= 4 && 
d232 1
a232 1
	} else 
d511 1
a511 1
		dev_init(devpath, 
d516 1
a516 1
	
@


1.50
log
@make the code "more correct": add reference counters to aproc
structures so we can keep a pointer to the device. Beside some
simplifications, this allows to easily handle the situation
where the audio device desappears. No change in the behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.49 2008/12/26 13:29:31 ratchov Exp $	*/
d114 1
a114 1
	    "usage: %s [-lu] [-b nsamples] [-C min:max] [-c min:max] [-e enc] "
d315 1
a315 1
	int c, u_flag, l_flag, hdr, xrun, suspend = 0;
d339 1
d350 1
a350 1
	while ((c = getopt(argc, argv, "b:c:C:e:r:h:x:v:i:o:f:m:lus:")) != -1) {
d352 3
d453 6
d503 1
d508 9
a516 5
	dev_init(devpath, 
	    (mode & MODE_REC) ? &dipar : NULL,
	    (mode & MODE_PLAY) ? &dopar : NULL,
	    bufsz);

d548 1
a548 1
		    (!dev_play || dev_play->u.io.file == NULL)) {
d581 4
a584 1
	dev_done();
@


1.49
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.48 2008/12/07 17:10:41 ratchov Exp $	*/
a529 2
			if (l_flag)
				filelist_unlisten();
d532 4
a535 3
		if (!file_poll()) {
			fprintf(stderr, "Terminated, device disappeared?\n");
			exit(1);
d537 2
d559 2
@


1.48
log
@When resampling, don't require the sample frequency to be an integer.
This removes the arithmetic constraint between the sample frequency
and the block size and all the associated code. Now aucat can work
in server mode with any block size.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.47 2008/11/23 12:29:32 ratchov Exp $	*/
d464 2
a465 2
		aparams_init(&dipar, NCHAN_MAX - 1, 0, RATE_MIN);
		aparams_init(&dopar, NCHAN_MAX - 1, 0, RATE_MIN);
@


1.47
log
@Use file input parameter as default device output and file output parameters
as default device input. That's what the man page says
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.46 2008/11/20 10:10:01 ratchov Exp $	*/
d500 1
a500 1
	    bufsz, l_flag);
@


1.46
log
@take into account socket parameters into calculation of device
parameters; without this change aucat uses the device default
parameters and they are not necessarily usable for multi-stream
mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.45 2008/11/17 09:40:09 jmc Exp $	*/
d417 2
a418 2
		dipar = ipar;
		dopar = opar;
@


1.45
log
@- rename -s arg name to "socket"
- condense EXAMPLES into a single screenful

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.44 2008/11/17 07:36:43 jmc Exp $	*/
d450 9
a458 1
	if (!u_flag && !l_flag) {
d464 1
a464 1
		aparams_init(&dipar, NCHAN_MAX - 1, 0, RATE_MAX);
d467 1
a467 6
			if (dopar.cmin > fa->ipar.cmin)
				dopar.cmin = fa->ipar.cmin;
			if (dopar.cmax < fa->ipar.cmax)
				dopar.cmax = fa->ipar.cmax;
			if (dopar.rate < fa->ipar.rate)
				dopar.rate = fa->ipar.rate;
d470 5
a474 6
			if (dipar.cmin > fa->opar.cmin)
				dipar.cmin = fa->opar.cmin;
			if (dipar.cmax < fa->opar.cmax)
				dipar.cmax = fa->opar.cmax;
			if (dipar.rate > fa->opar.rate)
				dipar.rate = fa->opar.rate;
a475 8
	}

	/*
	 * if there are no sockets paths provided use the default
	 */
	if (l_flag && SLIST_EMPTY(&sfiles)) {
		farg_add(&sfiles, &dopar, &dipar,
		    MIDI_MAXCTL, HDR_RAW, XRUN_IGNORE, DEFAULT_SOCKET);
@


1.44
log
@tweak previous man page changes, and sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.43 2008/11/17 07:04:13 ratchov Exp $	*/
d116 1
a116 1
	    "\t[-h fmt] [-i file] [-m mode] [-o file] [-r rate] [-s file]\n"
@


1.43
log
@allow aucat to run as server in play-only and record-only mode, so
it can be used on play-only, record-only and half-duplex devices.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.42 2008/11/16 20:44:03 ratchov Exp $	*/
d116 2
a117 2
	    "\t[-h fmt] [-i file] [-o file] [-r rate] [-s path] [-v volume] "
	    "[-x policy]\n",
@


1.42
log
@allow aucat to listen on multiple sockets. Each socket carries its
channel and volume settings allowing multiple configuration to
coexist. Mostly useful for envy(4)-like devices, but can be used
to force different apps to use different settings.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.41 2008/11/16 18:34:56 ratchov Exp $	*/
d69 3
d179 12
d320 1
a320 1
	unsigned bufsz;
d347 1
d349 1
a349 1
	while ((c = getopt(argc, argv, "b:c:C:e:r:h:x:v:i:o:f:lus:")) != -1) {
d351 3
a437 2
	if (l_flag && (!SLIST_EMPTY(&ofiles) || !SLIST_EMPTY(&ifiles)))
		errx(1, "can't use -l and -s with -o or -i");
d440 9
a498 1

d504 2
a505 2
	    (l_flag || !SLIST_EMPTY(&ofiles)) ? &dipar : NULL,
	    (l_flag || !SLIST_EMPTY(&ifiles)) ? &dopar : NULL,
@


1.41
log
@add ``template'' parameters to sockets rather than using device
parameters. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.40 2008/11/16 16:30:22 ratchov Exp $	*/
d113 1
a113 1
	    "\t[-h fmt] [-i file] [-o file] [-r rate] [-v volume] "
d177 1
a177 1
 * Arguments of -i and -o opations are stored in a list.
d181 2
a182 1
	struct aparams par;	/* last requested format */
d196 3
a198 2
opt_file(struct farglist *list, 
    struct aparams *par, unsigned vol, int hdr, int xrun, char *optarg)
d220 2
a221 1
	fa->par = *par;
d252 3
a254 3
	f = wav_new_in(&wav_ops, fd, fa->name, &fa->par, fa->hdr);
	nfr = dev_bufsz * fa->par.rate / dev_rate;
	buf = abuf_new(nfr, &fa->par);
d258 1
a258 1
	dev_attach(fa->name, buf, &fa->par, fa->xrun,
d289 2
a290 2
	f = wav_new_out(&wav_ops, fd, fa->name, &fa->par, fa->hdr);
	nfr = dev_bufsz * fa->par.rate / dev_rate;
d292 1
a292 1
	buf = abuf_new(nfr, &fa->par);
d294 1
a294 1
	dev_attach(fa->name, NULL, NULL, 0, buf, &fa->par, fa->xrun, 0);
d302 1
a302 1
	struct farglist  ifiles, ofiles;
d306 1
a306 1
	char *devpath, *dbgenv, *listenpath;
d327 1
d333 1
a333 1
	while ((c = getopt(argc, argv, "b:c:C:e:r:h:x:v:i:o:f:lu")) != -1) {
d359 2
a360 1
			opt_file(&ifiles, &ipar, volctl, hdr, xrun, optarg);
d363 6
a368 1
			opt_file(&ofiles, &opar, 127, hdr, xrun, optarg);
d420 3
a422 1
		errx(1, "can't use -l with -o or -i");
d433 6
a438 6
			if (dopar.cmin > fa->par.cmin)
				dopar.cmin = fa->par.cmin;
			if (dopar.cmax < fa->par.cmax)
				dopar.cmax = fa->par.cmax;
			if (dopar.rate < fa->par.rate)
				dopar.rate = fa->par.rate;
d441 6
a446 6
			if (dipar.cmin > fa->par.cmin)
				dipar.cmin = fa->par.cmin;
			if (dipar.cmax < fa->par.cmax)
				dipar.cmax = fa->par.cmax;
			if (dipar.rate > fa->par.rate)
				dipar.rate = fa->par.rate;
d450 8
a482 8
	if (l_flag) {
		listenpath = getenv("AUCAT_SOCKET");
		if (!listenpath)
			listenpath = DEFAULT_SOCKET;
		(void)listen_new(&listen_ops, listenpath,
		    &dipar, &dopar, MIDI_TO_ADATA(volctl));
	}

d496 7
@


1.40
log
@Make clients inherit the volume parameter when the -v option is used in
server mode. It gives the maximum volume a client may have. This wastes
dynamic range, but allows volume to stay constant when other clients
connect or disconnect.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.39 2008/11/12 19:36:39 ratchov Exp $	*/
d468 1
a468 1
		    MIDI_TO_ADATA(volctl));
@


1.39
log
@when destroying the device, mark the mixer and the demultiplexer
for ``AUTOQUIT'' first, and then call file_eof() and friends.
fixes crashes sthen@@ noticed on zaurus
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.38 2008/11/11 21:26:21 ratchov Exp $	*/
d255 2
a256 1
	dev_attach(fa->name, buf, &fa->par, fa->xrun, NULL, NULL, 0);
d291 1
a291 1
	dev_attach(fa->name, NULL, NULL, 0, buf, &fa->par, fa->xrun);
d302 1
a302 1
	unsigned ivol, bufsz;
d306 1
d326 1
a326 1
	ivol = MIDI_MAXCTL;
d352 1
a352 1
			opt_vol(&ivol);
d355 1
a355 1
			opt_file(&ifiles, &ipar, ivol, hdr, xrun, optarg);
d467 2
a468 1
		(void)listen_new(&listen_ops, listenpath);
@


1.38
log
@if the device disappear the mixer and demultiplexer chains are
destroyed. If this happen then warn and exit, rather than crashing.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.37 2008/11/11 13:12:03 ratchov Exp $	*/
d494 1
a494 1
			fprintf(stderr, "Terminated, device desappeared?\n");
@


1.37
log
@termninate non-server aucat when it's idle rather that using
the hackish {MIX,SUB}_AUTOQUIT features. This way we don't
have to care about possible references on destroyed objects.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.36 2008/11/11 12:56:02 ratchov Exp $	*/
d493 4
a496 2
		if (!file_poll())
			break;
@


1.36
log
@when not in server mode, aucat terminates automatically using
the {MIX,SUB}_AUTAQUIT features. In this case we're not
allowed to directly touch dev_mix and dev_sub because they
can disappar. So disable the ``suspend'' and ``quit'' bits
when {MIX,SUB}_AUTAQUIT are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.35 2008/11/10 23:25:37 ratchov Exp $	*/
a484 10
	 * automatically terminate when there no are streams
	 */
	if (!l_flag) {
		if (dev_mix)
			dev_mix->u.mix.flags |= MIX_AUTOQUIT;
		if (dev_sub)
			dev_sub->u.sub.flags |= SUB_AUTOQUIT;
	}

	/*
a494 2
		if (!l_flag)
			continue;
d497 2
d520 1
a520 2
	if (l_flag)
		dev_done();
@


1.35
log
@add a per-stream ``soft volume'' knob and the corresponding -v option.
The code will be useful later for the volume knob in the sndio API.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.34 2008/11/09 16:26:07 ratchov Exp $	*/
d505 2
d530 2
a531 1
	dev_done();
@


1.34
log
@make aucat(1) stop automatically the audio(1) device if it's idle. This
way, when in server mode, it consumes no CPU if there are no clients.
Later, this will allow to start aucat(1) at session or system startup.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.33 2008/11/08 10:40:52 ratchov Exp $	*/
d113 2
a114 1
	    "\t[-h fmt] [-i file] [-o file] [-r rate] [-x policy]\n",
d123 1
a123 1
		err(1, "%s: bad channel range", optarg);
d131 9
a139 1
		err(1, "%s: bad sample rate", optarg);
d161 1
a161 1
	err(1, "%s: bad header specification", optarg);
d256 1
d301 1
a301 1
	unsigned ivol, ovol, bufsz;
d324 1
a324 1
	ivol = ovol = MIDI_TO_ADATA(127);
d327 1
a327 1
	while ((c = getopt(argc, argv, "b:c:C:e:r:h:x:i:o:f:lu")) != -1) {
d349 3
d353 1
a353 1
			opt_file(&ifiles, &ipar, 127, hdr, xrun, optarg);
@


1.33
log
@set the default device to /dev/audio for legacy mode.
From Thomas Pfaff <tpfaff _at_ agderlink.no> and tweaks from me
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.32 2008/11/07 21:01:15 ratchov Exp $	*/
d286 1
a286 1
	int c, u_flag, l_flag, hdr, xrun;
d492 22
a514 1

@


1.32
log
@expose the block size in the sndio API by making par->round writable
and thus remove the ugly rate <-> block-size table from
sio_setpar(3). Handle the block size negociation in aucat(1), since
it has few constrains the code is overally simpler.
ok jakemsr@@, major crank suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.31 2008/11/03 22:25:13 ratchov Exp $	*/
d317 1
a317 2
	while ((c = getopt(argc, argv, "b:c:C:e:r:h:x:i:o:f:lu"))
	    != -1) {
@


1.31
log
@A small optimization: handle most N-channel <-> M-channel conversions
inside the mixer and the demultiplexer. This way, aucat will not
trigger the heavy conversion code when only channel conversions are
required. Cuts ~50% of the CPU usage on envy(4) devices, can improve
surround 4.0, 5.1 and 7.1 capable devices. No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.30 2008/10/26 12:38:38 ratchov Exp $	*/
d291 1
a291 1
	unsigned ivol, ovol, bufsz = 0;
a306 1

d315 1
d360 1
a360 1
			if (sscanf(optarg, "%u", &bufsz) != 1) {
d441 2
a442 1
	 * Open the device.
d447 1
a447 1
	    bufsz);
@


1.30
log
@zap `q' from the getopts string too,
requested by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.29 2008/10/26 11:55:22 jmc Exp $	*/
d242 1
a242 1
	buf = abuf_new(nfr, aparams_bpf(&fa->par));
d278 1
a278 1
	buf = abuf_new(nfr, aparams_bpf(&fa->par));
@


1.29
log
@sync SYNOPSIS and usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.28 2008/10/26 08:49:43 ratchov Exp $	*/
d317 1
a317 1
	while ((c = getopt(argc, argv, "b:c:C:e:r:h:x:i:o:f:lqu"))
@


1.28
log
@add minimal server capability to aucat(1). When started in server
mode, it listens on an unix socket and mixes/demultiplexes any number
of full-duplex streams, doing necessary format conversions and
resampling on the fly.

programs can use the new libsa(3) library to play and record audio.
The library provides a very simple API to connect to the audio server;
if aucat(1) isn't running, it uses the audio(4) driver transparently
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.26 2008/08/14 09:58:55 ratchov Exp $	*/
d111 3
a113 4
	    "usage: %s [-lu] [-C min:max] [-c min:max] [-d level] "
	    "[-e enc]\n"
	    "\t[-f device] [-h fmt] [-i file] [-o file] "
	    "[-r rate] [-x policy]\n",
@


1.27
log
@minor tweak for removal of "[-d devel]" (change done in r1.19 and r1.21).

ok ratchov@@
@
text
@d51 1
d65 2
a66 1
#include "file.h"
d69 2
a70 2
int debug_level = 0, quiet_flag = 0;
volatile int quit_flag = 0, pause_flag = 0;
d72 12
a83 3
void suspend(struct file *);
void fill(struct file *);
void flush(struct file *);
d86 1
a86 1
 * List of allowed encodings and their names.
d88 6
a93 33
struct enc {
	char *name;
	struct aparams par;
} enc_list[] = {
	/* name		bps,	bits,	le,	sign,	msb,	unused  */
	{ "s8",		{ 1, 	8,	1,	1,	1,	0, 0, 0 } },
	{ "u8",		{ 1,	8,	1,	0,	1,	0, 0, 0 } },
	{ "s16le",	{ 2,	16,	1,	1,	1,	0, 0, 0 } },
	{ "u16le",	{ 2,	16,	1,	0,	1,	0, 0, 0 } },
	{ "s16be",	{ 2,	16,	0,	1,	1,	0, 0, 0 } },
	{ "u16be",	{ 2,	16,	0,	0,	1,	0, 0, 0 } },
	{ "s24le",	{ 4,	24,	1,	1,	1,	0, 0, 0 } },
	{ "u24le",	{ 4,	24,	1,	0,	1,	0, 0, 0 } },
	{ "s24be",	{ 4,	24,	0,	1,	1,	0, 0, 0 } },
	{ "u24be",	{ 4,	24,	0,	0,	1,	0, 0, 0 } },
	{ "s32le",	{ 4,	32,	1,	1,	1,	0, 0, 0 } },
	{ "u32le",	{ 4,	32,	1,	0,	1,	0, 0, 0 } },
	{ "s32be",	{ 4,	32,	0,	1,	1,	0, 0, 0 } },
	{ "u32be",	{ 4,	32,	0,	0,	1,	0, 0, 0 } },
	{ "s24le3",	{ 3,	24,	1,	1,	1,	0, 0, 0 } },
	{ "u24le3",	{ 3,	24,	1,	0,	1,	0, 0, 0 } },
	{ "s24be3",	{ 3,	24,	0,	1,	1,	0, 0, 0 } },
	{ "u24be3",	{ 3,	24,	0,	0,	1,	0, 0, 0 } },
	{ "s20le3",	{ 3,	20,	1,	1,	1,	0, 0, 0 } },
	{ "u20le3",	{ 3,	20,	1,	0,	1,	0, 0, 0 } },
	{ "s20be3",	{ 3,	20,	0,	1,	1,	0, 0, 0 } },
	{ "u20be3",	{ 3,	20,	0,	0,	1,	0, 0, 0 } },
	{ "s18le3",	{ 3,	18,	1,	1,	1,	0, 0, 0 } },
	{ "u18le3",	{ 3,	18,	1,	0,	1,	0, 0, 0 } },
	{ "s18be3",	{ 3,	18,	0,	1,	1,	0, 0, 0 } },
	{ "u18be3",	{ 3,	18,	0,	0,	1,	0, 0, 0 } },
	{ NULL,		{ 0,	0,	0,	0,	0,	0, 0, 0 } }
};
d96 1
a96 2
 * Search an encoding in the above table. On success fill encoding
 * part of "par" and return 1, otherwise return 0.
d98 2
a99 2
unsigned
enc_lookup(char *name, struct aparams *par)
d101 2
a102 13
	struct enc *e;

	for (e = enc_list; e->name != NULL; e++) {
		if (strcmp(e->name, name) == 0) {
			par->bps = e->par.bps;
			par->bits = e->par.bits;
			par->sig = e->par.sig;
			par->le = e->par.le;
			par->msb = e->par.msb;
			return 1;
		}
	}
	return 0;
d111 4
a114 4
	    "usage: %s [-qu] [-C min:max] [-c min:max] [-E enc] [-e enc] "
	    "[-f device]\n"
	    "\t[-H fmt] [-h fmt] [-i file] [-o file] [-R rate] [-r rate]\n"
	    "\t[-X policy] [-x policy]\n",
d122 1
a122 2
	    par->cmin > CHAN_MAX || par->cmax > CHAN_MAX ||
	    par->cmin > par->cmax)
d137 5
a141 2
	if (!enc_lookup(optarg, par))
		err(1, "%s: bad encoding", optarg);
d223 1
a223 1
	struct file *f;
d238 7
a244 10
	f = file_new(fd, fa->name);
	f->hdr = 0;
	f->hpar = fa->par;
	if (fa->hdr == HDR_WAV) {
		if (!wav_readhdr(fd, &f->hpar, &f->rbytes))
			exit(1);
	}
	nfr = dev_onfr * f->hpar.rate / dev_opar.rate;
	buf = abuf_new(nfr, aparams_bpf(&f->hpar));
	proc = rpipe_new(f);
d246 2
a247 1
	dev_attach(fa->name, buf, &f->hpar, fa->xrun, NULL, NULL, 0);
d257 1
a257 1
	struct file *f;
d273 7
a279 11
	f = file_new(fd, fa->name);
	f->hdr = fa->hdr;
	f->hpar = fa->par;
	if (f->hdr == HDR_WAV) {
		f->wbytes = WAV_DATAMAX;
		if (!wav_writehdr(fd, &f->hpar))
			exit(1);
	}
	nfr = dev_infr * f->hpar.rate / dev_ipar.rate;
	proc = wpipe_new(f);
	buf = abuf_new(nfr, aparams_bpf(&f->hpar));
d281 1
a281 1
	dev_attach(fa->name, NULL, NULL, 0, buf, &f->hpar, fa->xrun);
d287 1
a287 1
	int c, u_flag, ohdr, ihdr, ixrun, oxrun;
d291 3
a293 2
	unsigned ivol, ovol;
	char *devpath, *dbgenv;
d295 3
d310 1
d314 2
a315 2
	ihdr = ohdr = HDR_AUTO;
	ixrun = oxrun = XRUN_IGNORE;
d318 1
a318 1
	while ((c = getopt(argc, argv, "c:C:e:E:r:R:h:H:x:X:i:o:f:qu"))
d322 1
a322 4
			ihdr = opt_hdr();
			break;
		case 'H':
			ohdr = opt_hdr();
d325 1
a325 4
			ixrun = opt_xrun();
			break;
		case 'X':
			oxrun = opt_xrun();
d335 1
a335 3
			break;
		case 'E':
			opt_enc(&opar);
d339 1
a339 3
			break;
		case 'R':
			opt_rate(&opar);
d342 1
a342 1
			opt_file(&ifiles, &ipar, 127, ihdr, ixrun, optarg);
d345 1
a345 1
			opt_file(&ofiles, &opar, 127, ohdr, oxrun, optarg);
d351 2
a352 2
			dipar = ipar;
			dopar = opar;
d354 2
a355 2
		case 'q':
			quiet_flag = 1;
d360 6
a374 3
		devpath = getenv("AUDIODEVICE");
		if (devpath == NULL)
			devpath = DEFAULT_DEVICE;
d379 2
a380 1
	if (SLIST_EMPTY(&ifiles) && SLIST_EMPTY(&ofiles) && argc > 0) {
d396 2
d399 1
a399 1
	if (!u_flag) {
d405 2
a406 2
		aparams_init(&dipar, CHAN_MAX, 0, RATE_MAX);
		aparams_init(&dopar, CHAN_MAX, 0, RATE_MIN);
d424 16
a439 1
	file_start();
d442 1
a442 2
	 * Open the device, dev_init() will return new parameters
	 * that must be used by all inputs and outputs.
d445 10
a454 2
	    (!SLIST_EMPTY(&ofiles)) ? &dipar : NULL,
	    (!SLIST_EMPTY(&ifiles)) ? &dopar : NULL);
d473 1
a473 1
	 * Normalize input levels
d475 6
a480 2
	if (dev_mix)
		mix_setmaster(dev_mix);
d483 1
a483 1
	 * start audio
d485 10
a494 8
	if (!quiet_flag)
		fprintf(stderr, "starting device...\n");
	dev_start();
	if (!quiet_flag)
		fprintf(stderr, "process started...\n");
	dev_run(1);
	if (!quiet_flag)
		fprintf(stderr, "stopping device...\n");
d496 1
d498 5
a502 1
	file_stop();
@


1.26
log
@move all device related stuff from aucat.c to a new dev.c file.
The new dev_xxx() routines expose a "high level" self-contained
interface to the device. At initialization, the device is opened
and two chains of aproc structures are created:

 * a playback chain that exposes a (initially) empty mix
   aproc to which the rest of the code can attach new
   streams to be played

 * record chain that exposes a (initially) empty sub aproc
   to which the rest of the code can attach new stream to
   to record

The rest of the code, has just to use dev_attach() routine to
attach streams. While we're at it, add a ``devops'' structure
containing pointers to the device-specific routines. This will
allow later to add support for other type of device than the
Sun API.

Also, write the .wav headers in file_del(), so put all header
related data in the file strucuture. This allows to close() the
file, as soon as wpipe_xxx() aproc terminates. This will be
useful for the server, because it will need to close() descripts
of closed connections immediately.

add mix_pushzero() routine to fill the mixer with silence. It
will be used to avoid the mixer to underrun when there are no
input streams. Since we always have at least one input stream
there's no behaviour change.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.25 2008/06/02 17:09:51 ratchov Exp $	*/
d139 4
a142 4
	    "usage: %s [-qu] [-C min:max] [-c min:max] [-d level] "
	    "[-E enc] [-e enc]\n"
	    "\t[-f device] [-H fmt] [-h fmt] [-i file] [-o file] [-R rate]\n"
	    "\t[-r rate] [-X policy] [-x policy]\n",
@


1.25
log
@document latest changes: -d flag is replaced by AUCAT_DEBUG
environment variable, new -xX options

bits from eric, ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.24 2008/06/02 17:08:51 ratchov Exp $	*/
a19 4
 *	(not yet)add a silent/quiet/verbose/whatever flag, but be sure
 *	that by default the user is notified when one of the following
 *	(cpu consuming) aproc is created: mix, sub, conv
 *
a32 2
 *	(hard) dont create mix (sub) if there's only one input (output)
 *
a44 2
 *
 *	(easy) do we need -d flag ?
d67 2
a68 6
/*
 * Format for file headers.
 */
#define HDR_AUTO	0	/* guess by looking at the file name */
#define HDR_RAW		1	/* no headers, ie openbsd native ;-) */
#define HDR_WAV		2	/* microsoft riff wave */
d70 3
a72 2
int debug_level = 0;
volatile int quit_flag = 0;
a203 3
	int fd;			/* file descriptor for I/O */
	struct aproc *proc;	/* rpipe_xxx our wpipe_xxx */
	struct abuf *buf;
a238 1
	fa->proc = NULL;
d246 1
a246 1
newinput(struct farg *fa, struct aparams *npar, unsigned nfr, int quiet_flag)
d250 3
a252 2
	struct aproc *p, *c;
	struct abuf *buf, *nbuf;
d265 2
d268 1
a268 1
		if (!wav_readhdr(fd, &fa->par, &f->rbytes))
d271 5
a275 18
	buf = abuf_new(nfr, aparams_bpf(&fa->par));
	p = rpipe_new(f);
	aproc_setout(p, buf);
	if (!aparams_eq(&fa->par, npar)) {
		if (!quiet_flag) {
			fprintf(stderr, "%s: ", fa->name);
			aparams_print2(&fa->par, npar);
			fprintf(stderr, "\n");
		}
		nbuf = abuf_new(nfr, aparams_bpf(npar));
		c = conv_new(fa->name, &fa->par, npar);
		aproc_setin(c, buf);
		aproc_setout(c, nbuf);
		fa->buf = nbuf;
	} else
		fa->buf = buf;
	fa->proc = p;
	fa->fd = fd;
d282 1
a282 1
newoutput(struct farg *fa, struct aparams *npar, unsigned nfr, int quiet_flag)
d286 3
a288 2
	struct aproc *p, *c;
	struct abuf *buf, *nbuf;
d302 3
a304 1
	if (fa->hdr == HDR_WAV) {
d306 1
a306 1
		if (!wav_writehdr(fd, &fa->par))
d309 5
a313 26
	buf = abuf_new(nfr, aparams_bpf(&fa->par));
	p = wpipe_new(f);
	aproc_setin(p, buf);
	if (!aparams_eq(&fa->par, npar)) {
		if (!quiet_flag) {
			fprintf(stderr, "%s: ", fa->name);
			aparams_print2(npar, &fa->par);
			fprintf(stderr, "\n");
		}
		c = conv_new(fa->name, npar, &fa->par);
		nbuf = abuf_new(nfr, aparams_bpf(npar));
		aproc_setin(c, nbuf);
		aproc_setout(c, buf);
		fa->buf = nbuf;
	} else
		fa->buf = buf;
	fa->proc = p;
	fa->fd = fd;
}

void
sighdl(int s)
{
	if (quit_flag)
		_exit(1);
	quit_flag = 1;
d319 1
a319 3
	sigset_t sigset;
	struct sigaction sa;
	int c, u_flag, quiet_flag, ohdr, ihdr, ixrun, oxrun;
d322 1
a322 1
	struct aparams ipar, opar, dipar, dopar, cipar, copar;
a323 1
	unsigned dinfr, donfr, cinfr, confr;
a324 4
	unsigned n;
	struct aproc *rec, *play, *mix, *sub, *conv;
	struct file *dev, *f;
	struct abuf *buf, *cbuf;
a325 1
	int fd;
d337 1
a337 1
	u_flag = quiet_flag = 0;
a428 38
	sigfillset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = sighdl;
	if (sigaction(SIGINT, &sa, NULL) < 0)
		err(1, "sigaction");

	sigemptyset(&sigset);
	(void)sigaddset(&sigset, SIGTSTP);
	(void)sigaddset(&sigset, SIGCONT);
	if (sigprocmask(SIG_BLOCK, &sigset, NULL))
		err(1, "sigprocmask");
	
	file_start();
	play = rec = mix = sub = NULL;

	aparams_init(&cipar, CHAN_MAX, 0, RATE_MIN);
	aparams_init(&copar, CHAN_MAX, 0, RATE_MAX);

	/*
	 * Iterate over all inputs and outputs and find the maximum
	 * sample rate and channel number.
	 */
	SLIST_FOREACH(fa, &ifiles, entry) {
		if (cipar.cmin > fa->par.cmin)
			cipar.cmin = fa->par.cmin;
		if (cipar.cmax < fa->par.cmax)
			cipar.cmax = fa->par.cmax;
		if (cipar.rate < fa->par.rate)
			cipar.rate = fa->par.rate;
	}	
	SLIST_FOREACH(fa, &ofiles, entry) {
		if (copar.cmin > fa->par.cmin)
			copar.cmin = fa->par.cmin;
		if (copar.cmax < fa->par.cmax)
			copar.cmax = fa->par.cmax;
		if (copar.rate > fa->par.rate)
			copar.rate = fa->par.rate;
	}
a429 4
	/*
	 * Open the device and increase the maximum sample rate.
	 * channel number to include those used by the device
	 */
d431 22
a452 29
		dipar = copar;
		dopar = cipar;
	}
	fd = dev_init(devpath,
	    !SLIST_EMPTY(&ofiles) ? &dipar : NULL,
	    !SLIST_EMPTY(&ifiles) ? &dopar : NULL, &dinfr, &donfr);
	if (fd < 0)
		exit(1);
	if (!SLIST_EMPTY(&ofiles)) {
		if (!quiet_flag) {
			fprintf(stderr, "%s: recording ", devpath);
			aparams_print(&dipar);
			fprintf(stderr, "\n");
		}
		if (copar.cmin > dipar.cmin)
			copar.cmin = dipar.cmin;
		if (copar.cmax < dipar.cmax)
			copar.cmax = dipar.cmax;
		if (copar.rate > dipar.rate)
			copar.rate = dipar.rate;
		dinfr *= DEFAULT_NBLK;
		DPRINTF("%s: using %ums rec buffer\n", devpath,
		    1000 * dinfr / dipar.rate);
	}
	if (!SLIST_EMPTY(&ifiles)) {
		if (!quiet_flag) {
			fprintf(stderr, "%s: playing ", devpath);
			aparams_print(&dopar);
			fprintf(stderr, "\n");
a453 22
		if (cipar.cmin > dopar.cmin)
			cipar.cmin = dopar.cmin;
		if (cipar.cmax < dopar.cmax)
			cipar.cmax = dopar.cmax;
		if (cipar.rate < dopar.rate)
			cipar.rate = dopar.rate;
		donfr *= DEFAULT_NBLK;
		DPRINTF("%s: using %ums play buffer\n", devpath,
		    1000 * donfr / dopar.rate);
	}
	
	/*
	 * Create buffers for the device.
	 */
	dev = file_new(fd, devpath);
	if (!SLIST_EMPTY(&ofiles)) {
		rec = rpipe_new(dev);
		sub = sub_new();
	}
	if (!SLIST_EMPTY(&ifiles)) {
		play = wpipe_new(dev);
		mix = mix_new();
d455 1
d458 2
a459 2
	 * Calculate sizes of buffers using "common" parameters, to
	 * have roughly the same duration as device buffers.
d461 3
a463 2
	cinfr = donfr * cipar.rate / dopar.rate;
	confr = dinfr * copar.rate / dipar.rate;
d468 11
a478 23
	SLIST_FOREACH(fa, &ifiles, entry) {
		newinput(fa, &cipar, cinfr, quiet_flag);
		if (mix) {
			aproc_setin(mix, fa->buf);
			fa->buf->xrun = fa->xrun;
		}
		if (!quiet_flag) {
			fprintf(stderr, "%s: reading ", fa->name);
			aparams_print(&fa->par);
			fprintf(stderr, "\n");
		}
	}
	SLIST_FOREACH(fa, &ofiles, entry) {
		newoutput(fa, &copar, confr, quiet_flag);
		if (sub) {
			aproc_setout(sub, fa->buf);
			fa->buf->xrun = fa->xrun;
		}
		if (!quiet_flag) {
			fprintf(stderr, "%s: writing ", fa->name);
			aparams_print(&fa->par);
			fprintf(stderr, "\n");
		}
d482 1
a482 1
	 * Connect the multiplexer to the device input.
d484 2
a485 44
	if (sub) {
		buf = abuf_new(dinfr, aparams_bpf(&dipar));
		aproc_setout(rec, buf);
		if (!aparams_eq(&copar, &dipar)) {
			if (!quiet_flag) {
				fprintf(stderr, "%s: ", devpath);
				aparams_print2(&dipar, &copar);
				fprintf(stderr, "\n");
			}
			conv = conv_new("subconv", &dipar, &copar);
			cbuf = abuf_new(confr, aparams_bpf(&copar));
			aproc_setin(conv, buf);
			aproc_setout(conv, cbuf);
			aproc_setin(sub, cbuf);
		} else
			aproc_setin(sub, buf);
	}

	/*
	 * Normalize input levels and connect the mixer to the device
	 * output.
	 */
	if (mix) {
		n = 0;
		SLIST_FOREACH(fa, &ifiles, entry)
			n++;
		SLIST_FOREACH(fa, &ifiles, entry)
			fa->buf->mixvol /= n;
		buf = abuf_new(donfr, aparams_bpf(&dopar));
		aproc_setin(play, buf);
		if (!aparams_eq(&cipar, &dopar)) {
			if (!quiet_flag) {
				fprintf(stderr, "%s: ", devpath);
				aparams_print2(&cipar, &dopar);
				fprintf(stderr, "\n");
			}
			conv = conv_new("mixconv", &cipar, &dopar);
			cbuf = abuf_new(cinfr, aparams_bpf(&cipar));
			aproc_setout(conv, buf);
			aproc_setin(conv, cbuf);
			aproc_setout(mix, cbuf);
		} else
			aproc_setout(mix, buf);
	}
a489 16
	if (play != NULL) {
		if (!quiet_flag)
			fprintf(stderr, "filling buffers...\n");
		buf = LIST_FIRST(&play->ibuflist);
		while (!quit_flag) {
			/* no more devices to poll */
			if (!file_poll())
				break;
			/* eof */
			if (dev->state & FILE_EOF)
				break;
			/* device is blocked and play buffer is full */
			if ((dev->events & POLLOUT) && !ABUF_WOK(buf))
				break;
		}
	}
d492 4
a495 10
	dev_start(dev->fd);
	if (mix)
		mix->u.mix.flags |= MIX_DROP;
	if (sub)
		sub->u.sub.flags |= SUB_DROP;
	while (!quit_flag) {
		if (!file_poll())
			break;
	}

d497 2
a498 1
		fprintf(stderr, "draining buffers...\n");
a499 19
	/*
	 * generate EOF on all files that do input, so
	 * once buffers are drained, everything will be cleaned
	 */
	LIST_FOREACH(f, &file_list, entry) {
		if ((f->events) & POLLIN || (f->state & FILE_ROK))
			file_eof(f);
	}
	for (;;) {
		if (!file_poll())
			break;
	}
	SLIST_FOREACH(fa, &ofiles, entry) {
		if (fa->hdr == HDR_WAV)
			wav_writehdr(fa->fd, &fa->par);
		close(fa->fd);
		DPRINTF("%s: closed\n", fa->name);
	}
	dev_stop(dev->fd);
@


1.24
log
@currently, we start the device as soon as write() blocks; it's better
to continue filling the play buffer until it's full. This way, the
play buffer has fewer chances to underrun when the device is started.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.23 2008/06/02 17:08:11 ratchov Exp $	*/
d153 1
a153 1
	    "\t[-r rate]\n",
@


1.23
log
@if aucat is suspended, then the kernel continues running the device
(produces silence) and later, once aucat is resumed the kernel starts
dropping samples, it will try to drop as many samples as silence was
produced. So suspending breaks the aucat process permanently.

workaround this by blocking the signals ie disabling suspending of aucat
from the tty. The long term solution would be to catch SIGCONT and to stop
the device, resync/refill buffers and restart the device. That's really a
lot of work...

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.22 2008/06/02 17:06:36 ratchov Exp $	*/
d667 1
a671 3
			/* device is blocked */
			if (dev->events & POLLOUT)
				break;
d674 3
@


1.22
log
@allow the user to choose the aucat behaviour when underruns/overruns
occur on a per-stream basis, using -Xx flags.  There are 3 possible
policies:

 - ignore : ignores underruns/overruns, for instance, this mode
   could be used for creating simple pipes with utilities; like in
   your last cdio diff.

 - sync : insert/discard samples in order to keep all streams in
   sync, useful for multi-tracker-like apps and/or to sync
   midi/video/whatever on audio streams (this was the previous
   behaviour)

 - error : if overruns/underruns occur, consider it as fatal error
   and kill the corresponding stream (without disturbing others).
   Useful, for reliable recordings (and/or debugging aucat
   itself:).

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.21 2008/06/02 17:05:45 ratchov Exp $	*/
d362 1
d485 6
@


1.21
log
@(remove -d, second part) use strtonum() instead of sscanf() and inlined
checks

suggested and ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.20 2008/06/02 17:05:12 ratchov Exp $	*/
d84 1
d193 12
d214 1
d228 1
a228 1
    struct aparams *par, unsigned vol, int hdr, char *optarg)
d249 1
d363 1
a363 1
	int c, u_flag, quiet_flag, ohdr, ihdr;
d392 1
d395 2
a396 1
	while ((c = getopt(argc, argv, "c:C:e:E:r:R:h:H:i:o:f:qu")) != -1) {
d404 6
d429 1
a429 1
			opt_file(&ifiles, &ipar, 127, ihdr, optarg);
d432 1
a432 1
			opt_file(&ofiles, &opar, 127, ohdr, optarg);
d583 1
a583 1
		if (mix)
d585 2
d595 1
a595 1
		if (sub)
d597 2
d675 4
@


1.20
log
@since underruns/overruns are handled outside devices, remove code that
check for xruns in devices.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.19 2008/06/02 17:04:32 ratchov Exp $	*/
d359 1
d364 3
a366 3
		if (sscanf(dbgenv, "%u", &debug_level) != 1 ||
		    debug_level > 4)
			err(1, "%s: not an integer in the 0..4 range", dbgenv);
@


1.19
log
@(remove -d, first part) replace -d flag by AUCAT_DEBUG environment
variable. This eases turning debugging on/off when aucat is started by
another program.

"i like the idea" jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.18 2008/05/26 08:32:11 jmc Exp $	*/
a646 1
	dev->state &= ~(FILE_RFLOW | FILE_WFLOW);
@


1.18
log
@put -q in the right place;
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.17 2008/05/26 07:56:17 jakemsr Exp $	*/
d354 1
a354 1
	char *devpath;
d361 7
d378 1
a378 1
	while ((c = getopt(argc, argv, "d:c:C:e:E:r:R:h:H:i:o:f:qu")) != -1) {
a379 6
		case 'd':
			if (sscanf(optarg, "%u", &debug_level) != 1 ||
			    debug_level > 4)
				err(1, "%s: not an integer in the 0..4 range",
				    optarg);
			break;
@


1.17
log
@
add -q option which enables "quiet" operation.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.16 2008/05/23 12:56:27 jmc Exp $	*/
d149 1
a149 1
	    "usage: %s [-uq] [-C min:max] [-c min:max] [-d level] "
@


1.16
log
@various fixes for aucat.1, and sync usage(); ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.15 2008/05/23 07:15:46 ratchov Exp $	*/
d149 1
a149 1
	    "usage: %s [-u] [-C min:max] [-c min:max] [-d level] "
d246 1
a246 1
newinput(struct farg *fa, struct aparams *npar, unsigned nfr)
d272 5
a276 3
		fprintf(stderr, "%s: ", fa->name);
		aparams_print2(&fa->par, npar);
		fprintf(stderr, "\n");
d292 1
a292 1
newoutput(struct farg *fa, struct aparams *npar, unsigned nfr)
d320 5
a324 3
		fprintf(stderr, "%s: ", fa->name);
		aparams_print2(npar, &fa->par);
		fprintf(stderr, "\n");
d348 1
a348 1
	int c, u_flag, ohdr, ihdr;
d364 1
a364 1
	u_flag = 0;
d371 1
a371 1
	while ((c = getopt(argc, argv, "d:c:C:e:E:r:R:h:H:i:o:f:u")) != -1) {
d416 3
d446 1
a446 3
				fprintf(stderr, "%s: could not play\n",
				    argv[c]);
				exit(1);
d501 5
a505 3
		fprintf(stderr, "%s: recording ", devpath);
		aparams_print(&dipar);
		fprintf(stderr, "\n");
d517 5
a521 3
		fprintf(stderr, "%s: playing ", devpath);
		aparams_print(&dopar);
		fprintf(stderr, "\n");
d557 1
a557 1
		newinput(fa, &cipar, cinfr);
d560 5
a564 3
		fprintf(stderr, "%s: reading ", fa->name);
		aparams_print(&fa->par);
		fprintf(stderr, "\n");
d567 1
a567 1
		newoutput(fa, &copar, confr);
d570 5
a574 3
		fprintf(stderr, "%s: writing ", fa->name);
		aparams_print(&fa->par);
		fprintf(stderr, "\n");
d584 5
a588 3
			fprintf(stderr, "%s: ", devpath);
			aparams_print2(&dipar, &copar);
			fprintf(stderr, "\n");
d611 5
a615 3
			fprintf(stderr, "%s: ", devpath);
			aparams_print2(&cipar, &dopar);
			fprintf(stderr, "\n");
d629 2
a630 1
		fprintf(stderr, "filling buffers...\n");
d643 2
a644 1
	fprintf(stderr, "starting device...\n");
d652 2
a653 1
	fprintf(stderr, "draining buffers...\n");
@


1.15
log
@add support for:
 - recording, full-duplex operation
 - format conversions and resampling on the fly
 - mixing on the fly of multiple inputs of different formats
 - up to 16 channels, simplistic "routing" of channel ranges
 - more linear encodings (in raw and wav files)
the old behaviour is fully preserved if none of the new -i and -o
options are used.

code and fixes from jakemsr@@ and eric@@, suggestions by others.
ok "go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d149 4
a152 17
	    "usage: %s [-u] [-d level] [-f device]\n"
	    "\t[-C min:max] [-E enc] [-R rate] [-H fmt] [-o file]\n"
	    "\t[-c min:max] [-e enc] [-r rate] [-h fmt] [-i file]\n"
	    "\t-C: range of channel numbers stored in the output file\n"
	    "\t-c: range of channel numbers provided by the input file\n"
	    "\t-d: debug level, between 0 and 4\n"
	    "\t-E: output file encoding (eg. s8, u8, s16le, u32be...)\n"
	    "\t-e: input file encoding (eg. s8, u8, s16le, u32be...)\n"
	    "\t-f: use this device instead of /dev/audio\n"
	    "\t-H: output file header format (eg. auto, wav, raw)\n"
	    "\t-h: input file header format (eg. auto, wav, raw)\n"
	    "\t-i: read samples from file (\"-\" means stdin)\n"
	    "\t-R: sample rate in Hz of the output file\n"
	    "\t-r: sample rate in Hz of the input file\n"
	    "\t-o: write samples to file (\"-\" means stdout)\n"
	    "\t-u: use last -C, -c, -E, -e, -R, -r options "
	    "for device parameters\n",
@


1.14
log
@
- remove code that was rendered pointless by the last commit
- minor knf

from Pierre Riteau
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.13 2007/03/20 23:35:15 uwe Exp $	*/
d3 1
a3 1
 * Copyright (c) 1997 Kenneth Stailey.  All rights reserved.
d5 48
a52 24
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Kenneth Stailey.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d55 1
d57 1
a57 2
#include <sys/audioio.h>
#include <sys/ioctl.h>
d59 1
d61 1
d66 1
a66 1
#include <err.h>
d68 6
a73 1
#define _PATH_AUDIO "/dev/audio"
d76 1
a76 2
 * aucat: concatenate and play Sun 8-bit .au files or 8/16-bit
 * uncompressed WAVE RIFF files
d78 3
d82 38
a119 5
int 		playfile(int, audio_info_t *);
int		readwaveheader(int, audio_info_t *);
__dead void	usage(void);

int afd;
d122 2
a123 3
 * function playfile: given a file which is positioned at the beginning
 * of what is assumed to be an .au data stream copy it out to the audio
 * device.  Return 0 on success, -1 on failure.
d125 20
a144 2
int
playfile(int fd, audio_info_t *audioinfo)
d146 1
a146 2
	ssize_t rd;
	char buf[5120];
d148 29
a176 6
	/*
	 * If we don't wait here, the AUDIO_SETINFO ioctl interrupts
	 * the playback of the previous file.
	 */
	if (ioctl(afd, AUDIO_DRAIN, NULL) == -1)
		warn("AUDIO_DRAIN");
d178 7
a184 4
	if (ioctl(afd, AUDIO_SETINFO, audioinfo) == -1) {
		warn("AUDIO_SETINFO");
		return -1;
	}
d186 6
a191 5
	while ((rd = read(fd, buf, sizeof(buf))) > 0)
		if (write(afd, buf, rd) != rd)
			warn("write");
	if (rd == -1)
		warn("read");
d193 10
a202 1
	return (0);
d206 1
a206 5
 * function readwaveheader: given a file which is positioned at four
 * bytes into a RIFF file header, read the rest of the header, check
 * to see if it is a simple WAV file that we can handle, seek to the
 * beginning of the audio data, and set the playback parameters in
 * the audio_info_t structure.  Return 0 on success, -1 on failure.
d208 10
a217 23
int
readwaveheader(int fd, audio_info_t *audioinfo)
{
	/*
	 * The simplest form of a RIFF file...
	 */
	struct {
	/*	u_int32_t riff_chunkid; -- this is read before in main()! */
		u_int32_t riff_chunksize;
		u_int32_t riff_format;

		u_int32_t fmt_subchunkid;
		u_int32_t fmt_subchunksize;

		u_int16_t fmt_format;		/* 1 = PCM uncompressed */
		u_int16_t fmt_channels;		/* 1 = mono, 2 = stereo */
		u_int32_t fmt_samplespersec;	/* 8000, 22050, 44100 etc. */
		u_int32_t fmt_byterate;		/* total bytes per second */
		u_int16_t fmt_blockalign;	/* channels * bitspersample/8 */
		u_int16_t fmt_bitspersample;	/* 8 = 8 bits, 16 = 16 bits etc. */
	} header;
	u_int datatag;
	char c;
d219 1
a219 13
	/*
	 * Is it an uncompressed wave file?
	 */
	if (read(fd, &header, sizeof(header)) != sizeof(header)) {
		warn("read");
		return -1;
	}
	if (strncmp((char *) &header.riff_format, "WAVE", 4) ||
	    letoh16(header.fmt_format) != 1 ||
	    strncmp((char *) &header.fmt_subchunkid, "fmt ", 4) ||
	    (letoh16(header.fmt_bitspersample) != 8 &&
	     letoh16(header.fmt_bitspersample) != 16))
		return -1;
d221 24
a244 7
	/*
	 * Seek to the data chunk.
	 */
	for (datatag = 0; datatag < 4; ) {
		if (read(fd, &c, 1) != 1) {
			warn("read");
			return -1;
d246 8
d255 20
a274 21
		switch(datatag) {
		case 0:
			if (c == 'd')
				++datatag;
			break;
		case 1:
			if (c == 'a')
				++datatag;
			break;
		case 2:
			if (c == 't')
				++datatag;
			break;
		case 3:
			if (c == 'a')
				++datatag;
			break;
		default:
			datatag = 0;
			break;
		}
d276 4
a279 3
	if (datatag != 4) {
		warnx("no data chunk found in wave file");
		return -1;
d281 17
d299 27
a325 6
	/*
	 * Ignore the size of the data chunk.
	 */
	if (lseek(fd, 4, SEEK_CUR) == -1) {
		warn("lseek");
		return -1;
d327 17
d345 6
a350 6
	audioinfo->play.sample_rate = letoh32(header.fmt_samplespersec);
	audioinfo->play.channels    = letoh16(header.fmt_channels);
	audioinfo->play.precision   = letoh16(header.fmt_bitspersample);
	audioinfo->play.encoding    = audioinfo->play.precision == 8 ?
	    AUDIO_ENCODING_ULINEAR : AUDIO_ENCODING_SLINEAR_LE;
	return 0;
d354 1
a354 1
main(int argc, char *argv[])
d356 62
a417 13
	int fd, ch;
	u_int32_t data;
	char magic[4];
	char *dev;
	audio_info_t ai;
	audio_info_t ai_defaults;

	dev = getenv("AUDIODEVICE");
	if (dev == NULL)
		dev = _PATH_AUDIO;

	while ((ch = getopt(argc, argv, "f:")) != -1) {
		switch (ch) {
d419 8
a426 1
			dev = optarg;
d430 1
a430 1
			/* NOTREACHED */
d436 22
a457 1
	if (argc == 0)
d459 117
d577 18
a594 2
	if ((afd = open(dev, O_WRONLY)) < 0)
		err(1, "can't open %s", dev);
d596 24
a619 2
	if (ioctl(afd, AUDIO_GETINFO, &ai_defaults) == -1)
		err(1, "AUDIO_GETINFO");
d621 15
a635 33
	while (argc) {
		if ((fd = open(*argv, O_RDONLY)) < 0)
			err(1, "cannot open %s", *argv);

		AUDIO_INITINFO(&ai);

		ai.play.sample_rate = ai_defaults.play.sample_rate;
		ai.play.channels    = ai_defaults.play.channels;
		ai.play.encoding    = ai_defaults.play.encoding;
		ai.play.precision   = ai_defaults.play.precision;

		if (read(fd, magic, sizeof(magic)) != sizeof(magic) ||
		    strncmp(magic, ".snd", 4)) {
			/*
			 * not an .au file, bad header.
			 * Check if it could be a .wav file and set
			 * the playback parameters in ai.
			 */
			if (strncmp(magic, "RIFF", 4) ||
			    readwaveheader(fd, &ai)) {
				/*
				 * Assume raw audio data since that's
				 * what /dev/audio generates by default.
				 */
				if (lseek(fd, 0, SEEK_SET) == -1)
					warn("lseek");
			}
		} else {
			if (read(fd, &data, sizeof(data)) == sizeof(data)) {
				data = ntohl(data);
				if (lseek(fd, (off_t)data, SEEK_SET) == -1)
					warn("lseek");
			}
a636 6

		if (playfile(fd, &ai) < 0)
			exit(1);
		(void) close(fd);
		argc--;
		argv++;
d638 7
a644 2
	exit(0);
}
d646 1
a646 4
__dead void
usage(void)
{
	extern char *__progname;
d648 21
a668 2
	fprintf(stderr, "usage: %s [-f device] file ...\n", __progname);
	exit(1);
@


1.13
log
@Support for playing simple RIFF files (.wav) from Simon Effenberg, savar
at schuldeigen de, with some tweaks from me.  ok millert, tests ckuethe,
liked by some disliked by nobody, but he's not even a real user :)
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.12 2006/12/20 06:45:10 steven Exp $	*/
d49 3
a51 3
int 	playfile(int, char *, audio_info_t *);
int	readwaveheader(int, audio_info_t *);
void	usage(void) __attribute__((__noreturn__));
d53 1
a53 1
int afd = -1;
d61 1
a61 1
playfile(int fd, char *dev, audio_info_t *audioinfo)
a65 5
	if (afd == -1 && (afd = open(dev, O_WRONLY)) < 0) {
		warn("can't open %s", dev);
		return(-1);
	}

d214 1
a214 1
	if (afd == -1 && (afd = open(dev, O_WRONLY)) < 0)
d255 1
a255 1
		if (playfile(fd, dev, &ai) < 0)
d264 1
a264 1
void
@


1.12
log
@remove unneeded #include

ok mbalmer@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.11 2005/01/20 04:21:42 jaredy Exp $	*/
d32 3
d44 3
a46 2
/* 
 * aucat: concatenate and play Sun 8-bit .au files
d49 2
a50 1
int	playfile(int, char *);
d53 2
d61 1
a61 1
playfile(int fd, char *dev)
a62 1
	static int afd = -1;
d70 13
d92 97
d196 2
d218 7
d229 7
d240 2
a241 2
			 * Assume raw audio data since that's
			 * what /dev/audio generates by default.
d243 9
a251 2
			if (lseek(fd, 0, SEEK_SET) == -1)
				warn("lseek");
d259 2
a260 1
		if (playfile(fd, dev) < 0)
@


1.11
log
@- knf
- check read/write/etc. calls for errors
- use constants instead of hardcoded pathnames
- better variable types
- add usage output

suggestions from various, ok ian
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.10 2005/01/13 19:19:44 ian Exp $	*/
a31 1
#include <machine/endian.h>
@


1.10
log
@Close what you open: obvious fix, ok jared@@, more to follow
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.9 2003/10/20 21:10:19 jmc Exp $	*/
d40 2
d47 1
d49 2
a50 1
/* function playfile: given a file which is positioned at the beginning
d58 1
a58 1
	int rd;
d65 5
a69 5
	while ((rd = read(fd, buf, sizeof(buf))) > 0) {
		write(afd, buf, rd);
		if (rd < sizeof(buf))
			break;
	}
d78 2
a79 2
	unsigned long data;
	char magic[5];
d83 2
a84 2
	if (dev == 0)
		dev = "/dev/audio";
d87 1
a87 1
		switch(ch) {
d91 3
d99 2
d105 2
a106 3
		read(fd, magic, 4);
		magic[4] = '\0';
		if (strcmp(magic, ".snd")) {
d112 2
a113 1
			lseek(fd, 0, SEEK_SET);
d115 5
a119 3
			read(fd, &data, sizeof(data));
			data = ntohl(data);
			lseek(fd, (off_t)data, SEEK_SET);
d128 9
@


1.9
log
@typos from Jared Yanovich, slightly ammended;
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.8 2003/07/10 00:06:50 david Exp $	*/
d112 1
@


1.8
log
@add missing includes
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.7 2003/07/02 21:04:09 deraadt Exp $	*/
d41 1
a41 1
 * aucat: concatinate and play Sun 8-bit .au files
@


1.7
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.6 2003/06/10 22:20:44 deraadt Exp $	*/
d36 1
@


1.6
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.5 2002/12/09 00:45:38 millert Exp $	*/
d42 2
@


1.5
log
@From Andrushock, s/sucess/success/g
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.4 2000/07/01 19:54:36 millert Exp $	*/
d48 1
a48 3
playfile(fd, dev)
	int fd;
	char *dev;
d68 1
a68 3
main(argc, argv)
	int argc;
	char **argv;
@


1.4
log
@Add -f option to specify audio device, honor AUDIODEVICE environment vairable,
and some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.3 1997/01/05 19:00:51 kstailey Exp $	*/
d45 1
a45 1
 * device.  Return 0 on sucess, -1 on failure.
@


1.3
log
@minor tweaks; htonl() -> ntohl(); added SEE ALSO
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.2 1997/01/03 21:05:28 kstailey Exp $	*/
d35 1
d37 1
d48 3
a50 1
playfile(int fd)
d52 15
a66 16
  static int afd = -1;
  int rd;
  char buf[5120];

  if (afd == -1)
    if ((afd = open("/dev/audio", O_WRONLY)) < 0) {
      perror("open /dev/audio");
      return(-1);
    }
  while ((rd = read(fd, buf, sizeof(buf))) > 0) {
    write(afd, buf, rd);
    if (rd < sizeof(buf))
      break;
  }
  
  return (0);
d70 3
a72 1
main(int argc, char **argv)
d74 43
a116 28
  int fd;
  int argcInc = 0;		/* incrementing version of argc */
  unsigned long data;
  char magic[5];

  while (--argc) {
    ++argcInc;
    if ((fd = open(argv[argcInc], O_RDONLY)) < 0) {
      perror("open file");
      exit(1);
    }

    read(fd, magic, 4);
    magic[4] = '\0';
    if (strcmp(magic, ".snd")) {
      /* not an .au file, bad header.  Assume raw audio data since that's
       * what /dev/audio generates by default.
       */
      lseek(fd, 0, SEEK_SET);
    } else {
      read(fd, &data, sizeof(data));
      data = ntohl(data);
      lseek(fd, (off_t)data, SEEK_SET);
    }
    if (playfile(fd) < 0)
      exit(1);
  }
  exit(0);
@


1.2
log
@removed unnecessary test
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.1 1997/01/02 22:12:27 kstailey Exp $	*/
d90 1
a90 1
      data = htonl(data);
@


1.1
log
@new utility for playing sound files
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
a90 2
      if (BYTE_ORDER != BIG_ENDIAN)
	data = htonl(data);
@
