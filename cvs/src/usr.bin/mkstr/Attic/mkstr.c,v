head	1.12;
access;
symbols
	OPENBSD_5_5:1.11.0.20
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.10
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.6
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.8.0.16
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.3.0.18
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.16
	OPENBSD_2_8:1.3.0.14
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.12
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.07.09.19.04.03;	author tedu;	state dead;
branches;
next	1.11;
commitid	eAzXgBFfumEMgfe3;

1.11
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.10.14.29.53;	author tobias;	state Exp;
branches;
next	1.9;

1.9
date	2007.08.06.19.16.06;	author sobrado;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.02.56.13;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.13.14.39.55;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.27.03.14.22;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.3;

1.3
date	97.07.05.23.11.12;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.37.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Do you know what horrors lie beyond that wall?
No.
Then you go first.
@
text
@/*	$OpenBSD: mkstr.c,v 1.11 2009/10/27 23:59:40 deraadt Exp $	*/
/*	$NetBSD: mkstr.c,v 1.4 1995/09/28 06:22:20 tls Exp $	*/

/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/stat.h>

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define	ungetchar(c)	ungetc(c, stdin)

/*
 * mkstr - create a string error message file by massaging C source
 *
 * Bill Joy UCB August 1977
 *
 * Modified March 1978 to hash old messages to be able to recompile
 * without addding messages to the message file (usually)
 *
 * Based on an earlier program conceived by Bill Joy and Chuck Haley
 *
 * Program to create a string error message file
 * from a group of C programs.  Arguments are the name
 * of the file where the strings are to be placed, the
 * prefix of the new files where the processed source text
 * is to be placed, and the files to be processed.
 *
 * The program looks for 'error("' in the source stream.
 * Whenever it finds this, the following characters from the '"'
 * to a '"' are replaced by 'seekpt' where seekpt is a
 * pointer into the error message file.
 * If the '(' is not immediately followed by a '"' no change occurs.
 *
 * The optional '-' causes strings to be added at the end of the
 * existing error message file for recompilation of single routines.
 */


FILE	*mesgread, *mesgwrite;
char	name[MAXPATHLEN], *np;

void inithash(void);
void process(void);
int match(char *);
void copystr(void);
int octdigit(char);
unsigned int hashit(char *, char, unsigned int);
int fgetNUL(char *, int, FILE *);
__dead void usage(void);

int
main(int argc, char **argv)
{
	size_t n;
	char addon = 0;

	argc--, argv++;
	if (argc > 1 && argv[0][0] == '-')
		addon++, argc--, argv++;
	if (argc < 3)
		usage();
	mesgwrite = fopen(argv[0], addon ? "a" : "w");
	if (mesgwrite == NULL)
		perror(argv[0]), exit(1);
	mesgread = fopen(argv[0], "r");
	if (mesgread == NULL)
		perror(argv[0]), exit(1);
	inithash();
	argc--, argv++;
	if ((n = strlcpy(name, argv[0], sizeof(name))) >= sizeof(name))
		errx(1, "%s too long", argv[0]); 
	np = name + n;
	argc--, argv++;
	do {
		if (strlcpy(np, argv[0], sizeof(name) - n) >=
		    sizeof(name) - n)
			errx(1, "%s too long", argv[0]);
		if (freopen(name, "w", stdout) == NULL)
			perror(name), exit(1);
		if (freopen(argv[0], "r", stdin) == NULL)
			perror(argv[0]), exit(1);
		process();
		argc--, argv++;
	} while (argc > 0);
	exit (0);
}

void
process(void)
{
	int c;

	for (;;) {
		c = getchar();
		if (c == EOF)
			return;
		if (c != 'e') {
			putchar(c);
			continue;
		}
		if (match("error(")) {
			printf("error(");
			c = getchar();
			if (c != '"')
				putchar(c);
			else
				copystr();
		}
	}
}

int
match(char *ocp)
{
	char *cp;
	int c;

	for (cp = ocp + 1; *cp; cp++) {
		c = getchar();
		if (c != *cp) {
			while (ocp < cp)
				putchar(*ocp++);
			ungetchar(c);
			return (0);
		}
	}
	return (1);
}

void
copystr(void)
{
	int c, ch;
	char buf[512];
	char *cp = buf;

	for (;;) {
		c = getchar();
		if (c == EOF)
			break;
		switch (c) {

		case '"':
			*cp++ = 0;
			goto out;
		case '\\':
			c = getchar();
			switch (c) {

			case 'b':
				c = '\b';
				break;
			case 't':
				c = '\t';
				break;
			case 'r':
				c = '\r';
				break;
			case 'n':
				c = '\n';
				break;
			case '\n':
				continue;
			case 'f':
				c = '\f';
				break;
			case '0':
				c = 0;
				break;
			case '\\':
				break;
			default:
				if (!octdigit(c))
					break;
				c -= '0';
				ch = getchar();
				if (!octdigit(ch))
					break;
				c <<= 7, c += ch - '0';
				ch = getchar();
				if (!octdigit(ch))
					break;
				c <<= 3, c+= ch - '0', ch = -1;
				break;
			}
		}
		*cp++ = c;
	}
out:
	*cp = 0;
	printf("%d", hashit(buf, 1, 0));
}

int
octdigit(char c)
{

	return (c >= '0' && c <= '7');
}

void
inithash(void)
{
	char buf[512];
	int mesgpt = 0;

	rewind(mesgread);
	while (fgetNUL(buf, sizeof buf, mesgread) != 0) {
		hashit(buf, 0, mesgpt);
		mesgpt += strlen(buf) + 2;
	}
}

#define	NBUCKETS	511

struct	hash {
	long	hval;
	unsigned int hpt;
	struct	hash *hnext;
} *bucket[NBUCKETS];

unsigned int
hashit(char *str, char really, unsigned int fakept)
{
	int i;
	struct hash *hp;
	char buf[512];
	long hashval = 0;
	char *cp;

	if (really)
		fflush(mesgwrite);
	for (cp = str; *cp;)
		hashval = (hashval << 1) + *cp++;
	i = hashval % NBUCKETS;
	if (i < 0)
		i += NBUCKETS;
	if (really != 0)
		for (hp = bucket[i]; hp != 0; hp = hp->hnext)
		if (hp->hval == hashval) {
			fseek(mesgread, (long) hp->hpt, SEEK_SET);
			fgetNUL(buf, sizeof buf, mesgread);
#ifdef DEBUG
			fprintf(stderr, "Got (from %d) %s\n", hp->hpt, buf);
#endif
			if (strcmp(buf, str) == 0)
				break;
		}
	if (!really || hp == 0) {
		if ((hp = (struct hash *) calloc(1, sizeof *hp)) == NULL)
			err(1, "calloc");
		hp->hnext = bucket[i];
		hp->hval = hashval;
		hp->hpt = really ? ftell(mesgwrite) : fakept;
		if (really) {
			fwrite(str, sizeof (char), strlen(str) + 1, mesgwrite);
			fwrite("\n", sizeof (char), 1, mesgwrite);
		}
		bucket[i] = hp;
	}
#ifdef DEBUG
	fprintf(stderr, "%s hashed to %ld at %d\n", str, hp->hval, hp->hpt);
#endif
	return (hp->hpt);
}

int
fgetNUL(char *obuf, int rmdr, FILE *file)
{
	int c;
	char *buf = obuf;

	while (--rmdr > 0 && (c = getc(file)) != 0 && c != EOF)
		*buf++ = c;
	*buf++ = 0;
	getc(file);
	return ((feof(file) || ferror(file)) ? 0 : 1);
}

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-] messagefile prefix file ...\n",
	    __progname);
	exit(1);
}
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mkstr.c,v 1.10 2007/09/10 14:29:53 tobias Exp $	*/
@


1.10
log
@Proper use of fseek/fseeko macros.

OK joris@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkstr.c,v 1.9 2007/08/06 19:16:06 sobrado Exp $	*/
a31 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)mkstr.c	8.1 (Berkeley) 6/6/93";
#else
static const char rcsid[] = "$OpenBSD: mkstr.c,v 1.9 2007/08/06 19:16:06 sobrado Exp $";
#endif
#endif /* not lint */
@


1.9
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkstr.c,v 1.8 2003/06/03 02:56:13 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: mkstr.c,v 1.8 2003/06/03 02:56:13 millert Exp $";
d286 1
a286 1
			fseek(mesgread, (long) hp->hpt, 0);
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkstr.c,v 1.7 2002/12/13 14:39:55 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: mkstr.c,v 1.7 2002/12/13 14:39:55 millert Exp $";
d330 2
a331 1
	fprintf(stderr, "usage: %s [-] mesgfile prefix file ...\n", __progname);
@


1.7
log
@Some KNF from Andrey Matveev plus a little cleanup of my own.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkstr.c,v 1.6 2002/05/27 03:14:22 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: mkstr.c,v 1.6 2002/05/27 03:14:22 deraadt Exp $";
@


1.6
log
@unsigned vs unsigned int
@
text
@d1 1
a1 1
/*	$OpenBSD: mkstr.c,v 1.5 2002/02/16 21:27:49 millert Exp $	*/
d38 1
a38 1
static char copyright[] =
d45 1
a45 1
static char sccsid[] = "@@(#)mkstr.c	8.1 (Berkeley) 6/6/93";
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mkstr.c,v 1.5 2002/02/16 21:27:49 millert Exp $";
d51 1
a51 1
#include <sys/types.h>
d53 2
d89 1
a89 3
char	*progname;
char	usagestr[] =	"usage: %s [ - ] mesgfile prefix file ...\n";
char	name[100], *np;
d96 1
a96 1
unsigned int hashit(char *, char, unsigned);
d98 1
d101 1
a101 3
main(argc, argv)
	int argc;
	char *argv[];
d103 1
d106 1
a106 1
	argc--, progname = *argv++;
d110 1
a110 1
		fprintf(stderr, usagestr, progname), exit(1);
d119 3
a121 2
	strcpy(name, argv[0]);
	np = name + strlen(name);
d124 3
a126 1
		strcpy(np, argv[0]);
d134 1
a134 1
	return 0;
d138 1
a138 1
process()
d162 1
a162 2
match(ocp)
	char *ocp;
d180 1
a180 1
copystr()
d244 1
a244 2
octdigit(c)
	char c;
d251 1
a251 1
inithash()
d272 1
a272 4
hashit(str, really, fakept)
	char *str;
	char really;
	unsigned int fakept;
d292 1
a292 1
/*
d294 1
a294 1
*/
d299 2
a300 1
		hp = (struct hash *) calloc(1, sizeof *hp);
d310 1
a310 1
/*
d312 1
a312 1
*/
d317 1
a317 4
fgetNUL(obuf, rmdr, file)
	char *obuf;
	int rmdr;
	FILE *file;
d327 9
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkstr.c,v 1.4 2001/11/19 19:02:15 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mkstr.c,v 1.4 2001/11/19 19:02:15 mpech Exp $";
d96 1
a96 1
unsigned hashit(char *, char, unsigned);
d266 1
a266 1
	unsigned hpt;
d270 1
a270 1
unsigned
d274 1
a274 1
	unsigned fakept;
@


1.4
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mkstr.c,v 1.3 1997/07/05 23:11:12 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mkstr.c,v 1.3 1997/07/05 23:11:12 deraadt Exp $";
d91 7
a97 7
void inithash __P((void));
void process __P((void));
int match __P((char *));
void copystr __P((void));
int octdigit __P((char));
unsigned hashit __P((char *, char, unsigned));
int fgetNUL __P((char *, int, FILE *));
@


1.3
log
@Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: mkstr.c,v 1.2 1996/06/26 05:37:13 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mkstr.c,v 1.2 1996/06/26 05:37:13 deraadt Exp $";
d137 1
a137 1
	register c;
d162 2
a163 2
	register char *cp;
	register c;
d180 1
a180 1
	register c, ch;
d182 1
a182 1
	register char *cp = buf;
d277 1
a277 1
	register struct hash *hp;
d280 1
a280 1
	register char *cp;
d320 1
a320 1
	register int rmdr;
d323 2
a324 2
	register c;
	register char *buf = obuf;
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: mkstr.c,v 1.4 1995/09/28 06:22:20 tls Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: mkstr.c,v 1.4 1995/09/28 06:22:20 tls Exp $";
d51 2
d91 9
d131 1
a131 1
	exit(0);
d134 1
a136 1
	register char *cp;
d158 1
d177 1
d238 1
a238 1
	printf("%d", hashit(buf, 1, NULL));
d241 1
d249 1
d256 1
a256 1
	while (fgetNUL(buf, sizeof buf, mesgread) != NULL) {
d270 1
d317 1
a317 3
#include <sys/types.h>
#include <sys/stat.h>

d330 1
a330 1
	return ((feof(file) || ferror(file)) ? NULL : 1);
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: mkstr.c,v 1.4 1995/09/28 06:22:20 tls Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
