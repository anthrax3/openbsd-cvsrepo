head	1.26;
access;
symbols
	OPENBSD_6_0:1.25.0.8
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.4
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.8
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.6
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.10
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.6
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.6
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.14
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.12
	OPENBSD_2_8:1.3.0.10
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.8
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.26
date	2017.03.15.04.24.14;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	oL4eFXBEzCBQNxCU;

1.25
date	2015.01.16.06.40.13;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	Uu5nFG3wCl0LACBb;

1.24
date	2013.04.02.06.04.50;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.10.03.20.59;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2010.01.29.00.36.09;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.01.09.15.44;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.27.13.57.50;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.16.15.14.33;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.04.19.22.46;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.27.16.27.39;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.08.22.36.43;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.22.15.26.53;	author pat;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.07.06.26.12;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.07.21.36.52;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.20.16.53.15;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.19.22.40.45;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.12.23.09.30;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.12.22.30.23;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.25.23.58.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.25.21.40.52;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.15.17.20.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.03.20.41.22;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.3;

1.3
date	98.09.20.06.19.14;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.08.22.07.16.31;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.08.14.14.00.27;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.26
log
@annoying whitespace die die die
@
text
@/* $OpenBSD: utils.c,v 1.25 2015/01/16 06:40:13 deraadt Exp $	 */

/*
 *  Top users/processes display for Unix
 *  Version 3
 *
 * Copyright (c) 1984, 1989, William LeFebvre, Rice University
 * Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS EMPLOYER BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *  This file contains various handy utilities used by top.
 */

#include <sys/types.h>
#include <sys/sysctl.h>
#include <err.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <limits.h>

#include "top.h"
#include "machine.h"
#include "utils.h"

int
atoiwi(char *str)
{
	size_t len;
	const char *errstr;
	int i;

	len = strlen(str);
	if (len != 0) {
		if (strncmp(str, "infinity", len) == 0 ||
		    strncmp(str, "all", len) == 0 ||
		    strncmp(str, "maximum", len) == 0) {
			return (Infinity);
		}
		i = (int)strtonum(str, 0, INT_MAX, &errstr);
		if (errstr) {
			return (Invalid);
		} else
			return (i);
	}
	return (0);
}

/*
 * itoa - convert integer (decimal) to ascii string.
 */
char *
itoa(int val)
{
	static char buffer[16];	/* result is built here */

	/*
	 * 16 is sufficient since the largest number we will ever convert
	 * will be 2^32-1, which is 10 digits.
	 */
	(void)snprintf(buffer, sizeof(buffer), "%d", val);
	return (buffer);
}

/*
 * format_uid(uid) - like itoa, except for uid_t and the number is right
 * justified in a 6 character field to match uname_field in top.c.
 */
char *
format_uid(uid_t uid)
{
	static char buffer[16];	/* result is built here */

	/*
	 * 16 is sufficient since the largest uid we will ever convert
	 * will be 2^32-1, which is 10 digits.
	 */
	(void)snprintf(buffer, sizeof(buffer), "%6u", uid);
	return (buffer);
}

/*
 * digits(val) - return number of decimal digits in val.  Only works for
 * positive numbers.  If val <= 0 then digits(val) == 0.
 */
int
digits(int val)
{
	int cnt = 0;

	while (val > 0) {
		cnt++;
		val /= 10;
	}
	return (cnt);
}

/*
 * string_index(string, array) - find string in array and return index
 */
int
string_index(char *string, char **array)
{
	int i = 0;

	while (*array != NULL) {
		if (strncmp(string, *array, strlen(string)) == 0)
			return (i);
		array++;
		i++;
	}
	return (-1);
}

/*
 * argparse(line, cntp) - parse arguments in string "line", separating them
 * out into an argv-like array, and setting *cntp to the number of
 * arguments encountered.  This is a simple parser that doesn't understand
 * squat about quotes.
 */
char **
argparse(char *line, int *cntp)
{
	char **argv, **argarray, *args, *from, *to;
	int cnt, ch, length, lastch;

	/*
	 * unfortunately, the only real way to do this is to go thru the
	 * input string twice.
	 */

	/* step thru the string counting the white space sections */
	from = line;
	lastch = cnt = length = 0;
	while ((ch = *from++) != '\0') {
		length++;
		if (ch == ' ' && lastch != ' ')
			cnt++;
		lastch = ch;
	}

	/*
	 * add three to the count:  one for the initial "dummy" argument, one
	 * for the last argument and one for NULL
	 */
	cnt += 3;

	/* allocate a char * array to hold the pointers */
	if ((argarray = calloc(cnt, sizeof(char *))) == NULL)
		err(1, NULL);

	/* allocate another array to hold the strings themselves */
	if ((args = malloc(length + 2)) == NULL)
		err(1, NULL);

	/* initialization for main loop */
	from = line;
	to = args;
	argv = argarray;
	lastch = '\0';

	/* create a dummy argument to keep getopt happy */
	*argv++ = to;
	*to++ = '\0';
	cnt = 2;

	/* now build argv while copying characters */
	*argv++ = to;
	while ((ch = *from++) != '\0') {
		if (ch != ' ') {
			if (lastch == ' ') {
				*to++ = '\0';
				*argv++ = to;
				cnt++;
			}
			*to++ = ch;
		}
		lastch = ch;
	}
	*to++ = '\0';

	/* set cntp and return the allocated array */
	*cntp = cnt;
	return (argarray);
}

/*
 * percentages(cnt, out, new, old, diffs) - calculate percentage change
 * between array "old" and "new", putting the percentages in "out".
 * "cnt" is size of each array and "diffs" is used for scratch space.
 * The array "old" is updated on each call.
 * The routine assumes modulo arithmetic.  This function is especially
 * useful on BSD machines for calculating cpu state percentages.
 */
int
percentages(int cnt, int64_t *out, int64_t *new, int64_t *old, int64_t *diffs)
{
	int64_t change, total_change, *dp, half_total;
	int i;

	/* initialization */
	total_change = 0;
	dp = diffs;

	/* calculate changes for each state and the overall change */
	for (i = 0; i < cnt; i++) {
		if ((change = *new - *old) < 0) {
			/* this only happens when the counter wraps */
			change = INT64_MAX - *old + *new;
		}
		total_change += (*dp++ = change);
		*old++ = *new++;
	}

	/* avoid divide by zero potential */
	if (total_change == 0)
		total_change = 1;

	/* calculate percentages based on overall change, rounding up */
	half_total = total_change / 2l;
	for (i = 0; i < cnt; i++)
		*out++ = ((*diffs++ * 1000 + half_total) / total_change);

	/* return the total in case the caller wants to use it */
	return (total_change);
}

/*
 * format_time(seconds) - format number of seconds into a suitable display
 * that will fit within 6 characters.  Note that this routine builds its
 * string in a static area.  If it needs to be called more than once without
 * overwriting previous data, then we will need to adopt a technique similar
 * to the one used for format_k.
 */

/*
 * Explanation: We want to keep the output within 6 characters.  For low
 * values we use the format mm:ss.  For values that exceed 999:59, we switch
 * to a format that displays hours and fractions:  hhh.tH.  For values that
 * exceed 999.9, we use hhhh.t and drop the "H" designator.  For values that
 * exceed 9999.9, we use "???".
 */

char *
format_time(time_t seconds)
{
	static char result[10];

	/* sanity protection */
	if (seconds < 0 || seconds > (99999l * 360l)) {
		strlcpy(result, "   ???", sizeof result);
	} else if (seconds >= (1000l * 60l)) {
		/* alternate (slow) method displaying hours and tenths */
		snprintf(result, sizeof(result), "%5.1fH",
		    (double) seconds / (double) (60l * 60l));

		/*
		 * It is possible that the snprintf took more than 6
		 * characters. If so, then the "H" appears as result[6].  If
		 * not, then there is a \0 in result[6].  Either way, it is
		 * safe to step on.
		 */
		result[6] = '\0';
	} else {
		/* standard method produces MMM:SS */
		/* we avoid printf as must as possible to make this quick */
		snprintf(result, sizeof(result), "%3d:%02d", (int)seconds / 60,
		    (int)seconds % 60);
	}
	return (result);
}

/*
 * format_k(amt) - format a kilobyte memory value, returning a string
 * suitable for display.  Returns a pointer to a static
 * area that changes each call.  "amt" is converted to a
 * string with a trailing "K".  If "amt" is 10000 or greater,
 * then it is formatted as megabytes (rounded) with a
 * trailing "M".
 */

/*
 * Compromise time.  We need to return a string, but we don't want the
 * caller to have to worry about freeing a dynamically allocated string.
 * Unfortunately, we can't just return a pointer to a static area as one
 * of the common uses of this function is in a large call to snprintf where
 * it might get invoked several times.  Our compromise is to maintain an
 * array of strings and cycle thru them with each invocation.  We make the
 * array large enough to handle the above mentioned case.  The constant
 * NUM_STRINGS defines the number of strings in this array:  we can tolerate
 * up to NUM_STRINGS calls before we start overwriting old information.
 * Keeping NUM_STRINGS a power of two will allow an intelligent optimizer
 * to convert the modulo operation into something quicker.  What a hack!
 */

#define NUM_STRINGS 8

char *
format_k(int amt)
{
	static char retarray[NUM_STRINGS][16];
	static int  idx = 0;
	char *ret, tag = 'K';

	ret = retarray[idx];
	idx = (idx + 1) % NUM_STRINGS;

	if (amt >= 10000) {
		amt = (amt + 512) / 1024;
		tag = 'M';
		if (amt >= 10000) {
			amt = (amt + 512) / 1024;
			tag = 'G';
		}
	}
	snprintf(ret, sizeof(retarray[0]), "%d%c", amt, tag);
	return (ret);
}

int
find_pid(pid_t pid)
{
	struct kinfo_proc *pbase, *cur;
	int nproc;

	if ((pbase = getprocs(KERN_PROC_KTHREAD, 0, &nproc)) == NULL)
		quit(23);

	for (cur = pbase; cur < &pbase[nproc]; cur++)
		if (cur->p_pid == pid)
			return 1;
	return 0;
}
@


1.25
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.24 2013/04/02 06:04:50 guenther Exp $	 */
d61 1
a61 1
		} 
@


1.24
log
@Handle big time_t

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.23 2011/04/10 03:20:59 guenther Exp $	 */
d35 1
a35 1
#include <sys/param.h>
d42 1
@


1.23
log
@Switch back from KERN_PROC2/kinfo_proc2 to KERN_PROC/kinfo_proc now
that we've got name we want for the API we want

"ZAP!" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.22 2010/01/29 00:36:09 tedu Exp $	 */
d288 2
a289 2
		snprintf(result, sizeof(result), "%3d:%02d", seconds / 60,
		    seconds % 60);
@


1.22
log
@Allow sorting by command and pid.  Also, allow partial matches with strncmp.
ok jmc otto
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.21 2007/10/01 09:15:44 otto Exp $	 */
d344 1
a344 1
	struct kinfo_proc2 *pbase, *cur;
@


1.21
log
@typos in comment; from Pierre Riteau
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.20 2007/07/27 13:57:50 deraadt Exp $	 */
d128 1
a128 1
		if (strcmp(string, *array) == 0)
@


1.20
log
@replace a few more malloc(n*m) idioms with calloc(n,m) for safety;
inspired by zinovik@@cs.karelia.ru
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.19 2007/07/16 15:14:33 otto Exp $	 */
d210 1
a210 1
 * between array "old" and "new", putting the percentages i "out".
d214 1
a214 1
 * useful on BSD mchines for calculating cpu state percentages.
@


1.19
log
@fix percentage computation of wrapping numbers; from Willem Dijkstra
via henning@@ with a twist by me
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.18 2007/04/04 19:22:46 otto Exp $	 */
d170 1
a170 1
	if ((argarray = malloc(cnt * sizeof(char *))) == NULL)
@


1.18
log
@unneeded include; -Wall -Wmissing-prototypes is happy; from Mark Lumsden
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.17 2007/02/27 16:27:39 otto Exp $	 */
d41 1
d230 1
a230 1
			change = (*new - *old);
@


1.17
log
@an atoi() -> strtonum() conversion from Mark Lumsden; ok simon@@ ray@@
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.16 2005/06/08 22:36:43 millert Exp $	 */
a40 1
#include <unistd.h>
@


1.16
log
@Multi-cpu support for top.  Each cpu now gets its own stats line.
Based on work by todd@@ at the hackathon.
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.15 2004/11/22 15:26:53 pat Exp $	 */
d51 2
d60 3
a62 1
		} else if (str[0] == '-')
d64 2
a65 2
		else
			return (atoi(str));
@


1.15
log
@simplify loop iteration

ok otto millert
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.14 2004/10/07 06:26:12 otto Exp $	 */
d37 1
d166 2
a167 1
	argarray = (char **) malloc(cnt * sizeof(char *));
d170 2
a171 1
	args = (char *) malloc(length + 2);
d213 1
a213 1
percentages(int cnt, int *out, long *new, long *old, long *diffs)
d215 1
a215 1
	long change, total_change, *dp, half_total;
d226 1
a226 1
			change = ((unsigned int)*new - (unsigned int)*old);
@


1.14
log
@introduce -p option and p command to only show a single process.
From Patrick Latifi. ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.13 2003/07/07 21:36:52 deraadt Exp $	 */
d338 1
a338 1
	int i, nproc;
d343 1
a343 1
	for (i = 0, cur = pbase; i < nproc; i++, cur++)
@


1.13
log
@protos
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.12 2003/06/20 16:53:15 deraadt Exp $	 */
d35 2
a36 1
#include <sys/types.h>
d43 1
d332 15
@


1.12
log
@some cleanings recommended by lint
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.11 2003/06/19 22:40:45 millert Exp $	 */
d42 1
@


1.11
log
@o get rid of strecpy() and use strlcpy() and/or snprintf() instead.
o make itoa() just use snprintf()
o rename itoa7() to format_uid() and use snprintf()
o max username len is _PW_NAME_LEN, not 8
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.10 2003/06/12 23:09:30 deraadt Exp $	 */
d46 1
a46 1
	int len;
d313 1
a313 1
	static int  index = 0;
d316 2
a317 2
	ret = retarray[index];
	index = (index + 1) % NUM_STRINGS;
@


1.10
log
@knf
@
text
@d1 1
a1 1
/* $OpenBSD: utils.c,v 1.9 2003/06/12 22:30:23 pvalchev Exp $	 */
d63 1
a63 3
 * itoa - convert integer (decimal) to ascii string for positive numbers
 * only (we don't bother with negative numbers since we know we
 * don't use them).
a68 1
	char *ptr;
d74 2
a75 11
	ptr = buffer + sizeof(buffer);
	*--ptr = '\0';
	if (val == 0) {
		*--ptr = '0';
	} else {
		while (val != 0) {
			*--ptr = (val % 10) + '0';
			val /= 10;
		}
	}
	return (ptr);
d79 2
a80 3
 * itoa7(val) - like itoa, except the number is right justified in a 7
 * character field.  This code is a duplication of itoa instead of
 * a front end to a more general routine for efficiency.
d83 1
a83 1
itoa7(int val)
d85 1
a85 2
	static char buffer[25];	/* result is built here */
	char *ptr;
d87 6
a92 13
	ptr = buffer + sizeof(buffer);
	*--ptr = '\0';
	if (val == 0) {
		*--ptr = '0';
	} else {
		while (val != 0) {
			*--ptr = (val % 10) + '0';
			val /= 10;
		}
	}
	while (ptr > buffer + sizeof(buffer) - 7)
		*--ptr = ' ';
	return (ptr);
a111 12
 * strecpy(to, from) - copy string "from" into "to" and return a pointer
 * to the END of the string "to".
 */
char *
strecpy(char *to, char *from)
{
	while ((*to++ = *from++) != '\0')
		;
	return (--to);
}

/*
d314 1
a314 1
	char *p, *ret, tag = 'K';
d316 1
a316 1
	p = ret = retarray[index];
d327 1
a327 3
	p = strecpy(p, itoa(amt));
	*p++ = tag;
	*p = '\0';
@


1.9
log
@cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.8 2003/04/25 23:58:36 deraadt Exp $	*/
d46 1
a46 1
    int len;
d48 10
a57 8
    len = strlen(str);
    if (len != 0)
    {
	if (strncmp(str, "infinity", len) == 0 ||
	    strncmp(str, "all",      len) == 0 ||
	    strncmp(str, "maximum",  len) == 0)
	{
	    return(Infinity);
d59 1
a59 10
	else if (str[0] == '-')
	{
	    return(Invalid);
	}
	else
	{
	    return(atoi(str));
	}
    }
    return(0);
d63 3
a65 3
 *  itoa - convert integer (decimal) to ascii string for positive numbers
 *  	   only (we don't bother with negative numbers since we know we
 *	   don't use them).
a66 8

				/*
				 * How do we know that 16 will suffice?
				 * Because the biggest number that we will
				 * ever convert will be 2^32-1, which is 10
				 * digits.
				 */

d70 18
a87 18
    char *ptr;
    static char buffer[16];	/* result is built here */
    				/* 16 is sufficient since the largest number
				   we will ever convert will be 2^32-1,
				   which is 10 digits. */

    ptr = buffer + sizeof(buffer);
    *--ptr = '\0';
    if (val == 0)
    {
	*--ptr = '0';
    }
    else while (val != 0)
    {
	*--ptr = (val % 10) + '0';
	val /= 10;
    }
    return(ptr);
d91 3
a93 3
 *  itoa7(val) - like itoa, except the number is right justified in a 7
 *	character field.  This code is a duplication of itoa instead of
 *	a front end to a more general routine for efficiency.
a94 1

d98 2
a99 2
    char *ptr;
    static char buffer[25];	/* result is built here */
d101 13
a113 16
    ptr = buffer + sizeof(buffer);
    *--ptr = '\0';
    if (val == 0)
    {
	*--ptr = '0';
    }
    else while (val != 0)
    {
	*--ptr = (val % 10) + '0';
	val /= 10;
    }
    while (ptr > buffer + sizeof(buffer) - 7)
    {
	*--ptr = ' ';
    }
    return(ptr);
d117 2
a118 2
 *  digits(val) - return number of decimal digits in val.  Only works for
 *	positive numbers.  If val <= 0 then digits(val) == 0.
a119 1

d123 1
a123 1
    int cnt = 0;
d125 5
a129 6
    while (val > 0)
    {
	cnt++;
	val /= 10;
    }
    return(cnt);
d133 2
a134 2
 *  strecpy(to, from) - copy string "from" into "to" and return a pointer
 *	to the END of the string "to".
a135 1

d139 3
a141 2
    while ((*to++ = *from++) != '\0');
    return(--to);
a146 1

d150 1
a150 1
    int i = 0;
d152 5
a156 5
    while (*array != NULL)
    {
	if (strcmp(string, *array) == 0)
	{
	    return(i);
d158 1
a158 4
	array++;
	i++;
    }
    return(-1);
d163 3
a165 3
 *	out into an argv-like array, and setting *cntp to the number of
 *	arguments encountered.  This is a simple parser that doesn't understand
 *	squat about quotes.
a166 1

d170 16
a185 22
    char *from;
    char *to;
    int cnt;
    int ch;
    int length;
    int lastch;
    char **argv;
    char **argarray;
    char *args;

    /* unfortunately, the only real way to do this is to go thru the
       input string twice. */

    /* step thru the string counting the white space sections */
    from = line;
    lastch = cnt = length = 0;
    while ((ch = *from++) != '\0')
    {
	length++;
	if (ch == ' ' && lastch != ' ')
	{
	    cnt++;
a186 2
	lastch = ch;
    }
d188 35
a222 34
    /* add three to the count:  one for the initial "dummy" argument,
       one for the last argument and one for NULL */
    cnt += 3;

    /* allocate a char * array to hold the pointers */
    argarray = (char **)malloc(cnt * sizeof(char *));

    /* allocate another array to hold the strings themselves */
    args = (char *)malloc(length+2);

    /* initialization for main loop */
    from = line;
    to = args;
    argv = argarray;
    lastch = '\0';

    /* create a dummy argument to keep getopt happy */
    *argv++ = to;
    *to++ = '\0';
    cnt = 2;

    /* now build argv while copying characters */
    *argv++ = to;
    while ((ch = *from++) != '\0')
    {
	if (ch != ' ')
	{
	    if (lastch == ' ')
	    {
		*to++ = '\0';
		*argv++ = to;
		cnt++;
	    }
	    *to++ = ch;
d224 5
a228 7
	lastch = ch;
    }
    *to++ = '\0';

    /* set cntp and return the allocated array */
    *cntp = cnt;
    return(argarray);
d232 6
a237 6
 *  percentages(cnt, out, new, old, diffs) - calculate percentage change
 *	between array "old" and "new", putting the percentages i "out".
 *	"cnt" is size of each array and "diffs" is used for scratch space.
 *	The array "old" is updated on each call.
 *	The routine assumes modulo arithmetic.  This function is especially
 *	useful on BSD mchines for calculating cpu state percentages.
a238 1

d242 15
a256 17
    int i;
    long change;
    long total_change;
    long *dp;
    long half_total;

    /* initialization */
    total_change = 0;
    dp = diffs;

    /* calculate changes for each state and the overall change */
    for (i = 0; i < cnt; i++)
    {
	if ((change = *new - *old) < 0)
	{
	    /* this only happens when the counter wraps */
	    change = ((unsigned int)*new-(unsigned int)*old);
a257 16
	total_change += (*dp++ = change);
	*old++ = *new++;
    }

    /* avoid divide by zero potential */
    if (total_change == 0)
    {
	total_change = 1;
    }

    /* calculate percentages based on overall change, rounding up */
    half_total = total_change / 2l;
    for (i = 0; i < cnt; i++)
    {
	*out++ = ((*diffs++ * 1000 + half_total) / total_change);
    }
d259 11
a269 2
    /* return the total in case the caller wants to use it */
    return(total_change);
d272 6
a277 6
/* format_time(seconds) - format number of seconds into a suitable
 *		display that will fit within 6 characters.  Note that this
 *		routine builds its string in a static area.  If it needs
 *		to be called more than once without overwriting previous data,
 *		then we will need to adopt a technique similar to the
 *		one used for format_k.
d280 6
a285 6
/* Explanation:
   We want to keep the output within 6 characters.  For low values we use
   the format mm:ss.  For values that exceed 999:59, we switch to a format
   that displays hours and fractions:  hhh.tH.  For values that exceed
   999.9, we use hhhh.t and drop the "H" designator.  For values that
   exceed 9999.9, we use "???".
d291 1
a291 1
    static char result[10];
d293 22
a314 25
    /* sanity protection */
    if (seconds < 0 || seconds > (99999l * 360l))
    {
	strlcpy(result, "   ???", sizeof result);
    }
    else if (seconds >= (1000l * 60l))
    {
	/* alternate (slow) method displaying hours and tenths */
	snprintf(result, sizeof(result), "%5.1fH",
		(double)seconds / (double)(60l * 60l));

	/* It is possible that the snprintf took more than 6 characters.
	   If so, then the "H" appears as result[6].  If not, then there
	   is a \0 in result[6].  Either way, it is safe to step on.
	 */
	result[6] = '\0';
    }
    else
    {
	/* standard method produces MMM:SS */
	/* we avoid printf as must as possible to make this quick */
	snprintf(result, sizeof(result), "%3d:%02d", seconds / 60,
		seconds % 60);
    }
    return(result);
d319 5
a323 5
 *		suitable for display.  Returns a pointer to a static
 *		area that changes each call.  "amt" is converted to a
 *		string with a trailing "K".  If "amt" is 10000 or greater,
 *		then it is formatted as megabytes (rounded) with a
 *		trailing "M".
d345 14
a358 17
    static char retarray[NUM_STRINGS][16];
    static int index = 0;
    char *p;
    char *ret;
    char tag = 'K';

    p = ret = retarray[index];
    index = (index + 1) % NUM_STRINGS;

    if (amt >= 10000)
    {
	amt = (amt + 512) / 1024;
	tag = 'M';
	if (amt >= 10000)
	{
	    amt = (amt + 512) / 1024;
	    tag = 'G';
d360 4
a363 7
    }

    p = strecpy(p, itoa(amt));
    *p++ = tag;
    *p = '\0';

    return(ret);
@


1.8
log
@comment
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.7 2003/04/25 21:40:52 deraadt Exp $	*/
d43 2
a44 4
int atoiwi(str)

char *str;

d82 2
a83 4
char *itoa(val)

int val;

d111 2
a112 4
char *itoa7(val)

int val;

d140 2
a141 4
int digits(val)

int val;

d158 2
a159 5
char *strecpy(to, from)

char *to;
char *from;

d169 2
a170 5
int string_index(string, array)

char *string;
char **array;

d193 2
a194 5
char **argparse(line, cntp)

char *line;
int *cntp;

d275 2
a276 8
int percentages(cnt, out, new, old, diffs)

int cnt;
int *out;
long *new;
long *old;
long *diffs;

d333 2
a334 4
char *format_time(seconds)

time_t seconds;

d390 2
a391 4
char *format_k(amt)

int amt;

@


1.7
log
@comment fix
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.6 2002/07/15 17:20:36 deraadt Exp $	*/
d403 1
a403 1
 * of the common uses of this function is in a large call to sprintf where
@


1.6
log
@license change from William LeFebvre <wnl@@groupsys.com>; top is now BSD
licensed.  this same license will show up on his next release as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.5 2002/06/03 20:41:22 deraadt Exp $	*/
d374 1
a374 1
	/* It is possible that the sprintf took more than 6 characters.
@


1.5
log
@strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.4 2001/11/19 19:02:17 mpech Exp $	*/
d7 2
a8 2
 *  This program may be freely redistributed,
 *  but this entire comment MUST remain intact.
d10 19
a28 2
 *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
 *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
@


1.4
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.3 1998/09/20 06:19:14 niklas Exp $	*/
d349 1
a349 1
	strcpy(result, "   ???");
@


1.3
log
@cp_time is long, deal with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.2 1997/08/22 07:16:31 downsj Exp $	*/
d31 1
a31 1
    register int len;
d69 1
a69 1
register int val;
d72 1
a72 1
    register char *ptr;
d100 1
a100 1
register int val;
d103 1
a103 1
    register char *ptr;
d134 1
a134 1
    register int cnt = 0;
d151 2
a152 2
register char *to;
register char *from;
d169 1
a169 1
    register int i = 0;
d196 4
a199 4
    register char *from;
    register char *to;
    register int cnt;
    register int ch;
d202 1
a202 1
    register char **argv;
d279 2
a280 2
register long *new;
register long *old;
d284 4
a287 4
    register int i;
    register long change;
    register long total_change;
    register long *dp;
d405 3
a407 3
    register char *p;
    register char *ret;
    register char tag = 'K';
@


1.2
log
@First sweep.  Prototype, type fixes, long fixes, mostly compiles with
-Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: utils.c,v 1.1 1997/08/14 14:00:27 downsj Exp $	*/
d279 3
a281 3
register int *new;
register int *old;
int *diffs;
d285 4
a288 4
    register int change;
    register int total_change;
    register int *dp;
    int half_total;
@


1.1
log
@top 3.4, with a few changes.  Still needs more work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d18 6
a24 1
#include "os.h"
d104 1
a104 4
    static char buffer[16];	/* result is built here */
    				/* 16 is sufficient since the largest number
				   we will ever convert will be 2^32-1,
				   which is 10 digits. */
d275 1
a275 1
long percentages(cnt, out, new, old, diffs)
d279 3
a281 3
register long *new;
register long *old;
long *diffs;
d285 4
a288 4
    register long change;
    register long total_change;
    register long *dp;
    long half_total;
d300 1
a300 2
	    change = (int)
		((unsigned long)*new-(unsigned long)*old);
d316 1
a316 1
	*out++ = (int)((*diffs++ * 1000 + half_total) / total_change);
a322 27
/*
 * errmsg(errnum) - return an error message string appropriate to the
 *           error number "errnum".  This is a substitute for the System V
 *           function "strerror" with one important difference:  the string
 *           returned by this function does NOT end in a newline!
 *           N.B.:  there appears to be no reliable way to determine if
 *           "strerror" exists at compile time, so I make do by providing
 *           something of similar functionality.
 */

/* externs referenced by errmsg */

extern char *sys_errlist[];
extern int sys_nerr;

char *errmsg(errnum)

int errnum;

{
    if (errnum > 0 && errnum < sys_nerr)
    {
	return(sys_errlist[errnum]);
    }
    return("No error");
}

d341 1
a341 1
long seconds;
a343 3
    register int value;
    register int digit;
    register char *ptr;
d367 2
a368 2
	snprintf(result, sizeof(result), "%3d:%02d", seconds / 60l,
		seconds % 60l);
@
