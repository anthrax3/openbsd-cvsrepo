head	1.32;
access;
symbols
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.31.0.12
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.8
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.10
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.6
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.14
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.12
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.10
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.8
	OPENBSD_5_0:1.30.0.6
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.28.0.10
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.12
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.8
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.6
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.19.0.4
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.2.0.18
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.16
	OPENBSD_2_8:1.2.0.14
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.12
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.10
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.32
date	2017.03.15.04.24.14;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	oL4eFXBEzCBQNxCU;

1.31
date	2013.11.28.18.24.55;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.01.05.05.19;	author lum;	state Exp;
branches;
next	1.29;

1.29
date	2010.03.23.16.16.09;	author lum;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.29.00.56.56;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.23.13.31.45;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.14.08.29.28;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.09.21.15.18;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.09.20.57.15;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.06.06.53.13;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.04.19.17.14;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2007.01.05.09.46.12;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.05.07.26.46;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.04.23.10.06;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.07.17.46.13;	author hshoexer;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.17.09.40.48;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.07.06.26.12;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.27.00.48.22;	author marc;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.09.22.14.15;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.19.10.32.24;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.20.16.53.15;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.17.00.51.29;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.15.16.24.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.13.21.52.24;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.12.22.30.23;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.06.20.39.20;	author tdeval;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.15.17.20.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.29.18.33.40;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.2;

1.2
date	97.08.22.07.16.26;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.08.14.14.00.20;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.32
log
@annoying whitespace die die die
@
text
@/* $OpenBSD: commands.c,v 1.31 2013/11/28 18:24:55 deraadt Exp $	 */

/*
 *  Top users/processes display for Unix
 *  Version 3
 *
 * Copyright (c) 1984, 1989, William LeFebvre, Rice University
 * Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS EMPLOYER BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *  This file contains the routines that implement some of the interactive
 *  mode commands.  Note that some of the commands are implemented in-line
 *  in "main".  This is necessary because they change the global state of
 *  "top" (i.e.:  changing the number of processes to display).
 */

#include <sys/types.h>
#include <stdio.h>
#include <err.h>
#include <ctype.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/resource.h>

#include "top.h"

#include "boolean.h"
#include "utils.h"
#include "machine.h"

static char    *next_field(char *);
static int      scan_arg(char *, int *, char *);
static char    *err_string(void);
static size_t   str_adderr(char *, size_t, int);
static size_t   str_addarg(char *, size_t, char *, int);
static int      err_compar(const void *, const void *);

/*
 *  Utility routines that help with some of the commands.
 */
static char *
next_field(char *str)
{
	char *spaces = " \t";
	size_t span;

	span = strcspn(str, spaces);
	if (span == strlen(str))
		return (NULL);

	str += span;
	*str++  = '\0';

	while (strcspn(str, spaces) == 0)
		str++;

	if (*str == '\0')
		return (NULL);

	return(str);
}

/*
 * Scan the renice or kill interactive arguments for data and/or errors.
 */
static int
scan_arg(char *str, int *intp, char *nptr)
{
	int val = 0, bad_flag = 0;
	char ch;

	*nptr = '\0';

	if (*str == '\0')
		return (-1);

	while ((ch = *str++) != '\0') {
		if (isspace((unsigned char)ch))
			break;
		else if (!isdigit((unsigned char)ch))
			bad_flag = 1;
		else
			val = val * 10 + (ch - '0');

		*(nptr++) = ch;
	}
	*nptr = '\0';

	if (bad_flag == 1)
		return(-1);

	*intp = val;
	return (0);
}

/*
 *  Some of the commands make system calls that could generate errors.
 *  These errors are collected up in an array of structures for later
 *  contemplation and display.  Such routines return a string containing an
 *  error message, or NULL if no errors occurred.  The next few routines are
 *  for manipulating and displaying these errors.  We need an upper limit on
 *  the number of errors, so we arbitrarily choose 20.
 */

#define ERRMAX 20

struct errs	errs[ERRMAX];
int		errcnt;
static char    *err_toomany = " too many errors occurred";
static char    *err_listem =
	" Many errors occurred.  Press `e' to display the list of errors.";

/* These macros get used to reset and log the errors */
#define ERR_RESET   errcnt = 0
#define ERROR(p, e) \
	if (errcnt >= ERRMAX) { \
		return(err_toomany); \
	} else { \
		free(errs[errcnt].arg); \
		if ((errs[errcnt].arg = strdup(p)) == NULL) \
			err(1, "strdup"); \
		errs[errcnt++].err = (e); \
	}

#define STRMAX 80

/*
 *  err_string() - return an appropriate error string.  This is what the
 *	command will return for displaying.  If no errors were logged, then
 *	return NULL.  The maximum length of the error string is defined by
 *	"STRMAX".
 */
static char *
err_string(void)
{
	int cnt = 0, first = Yes, currerr = -1;
	static char string[STRMAX];
	struct errs *errp;

	/* if there are no errors, return NULL */
	if (errcnt == 0)
		return (NULL);

	/* sort the errors */
	qsort(errs, errcnt, sizeof(struct errs), err_compar);

	/* need a space at the front of the error string */
	string[0] = ' ';
	string[1] = '\0';

	/* loop thru the sorted list, building an error string */
	while (cnt < errcnt) {
		errp = &(errs[cnt++]);
		if (errp->err != currerr) {
			if (currerr != -1) {
				if (str_adderr(string, sizeof string, currerr) >
				    sizeof string - 2)
					return (err_listem);

				/* we know there's more */
				(void) strlcat(string, "; ", sizeof string);
			}
			currerr = errp->err;
			first = Yes;
		}
		if (str_addarg(string, sizeof string, errp->arg, first) >=
		    sizeof string)
			return (err_listem);

		first = No;
	}

	/* add final message */
	if (str_adderr(string, sizeof string, currerr) >= sizeof string)
		return (err_listem);

	/* return the error string */
	return (string);
}

/*
 *  str_adderr(str, len, err) - add an explanation of error "err" to
 *	the string "str".
 */
static size_t
str_adderr(char *str, size_t len, int err)
{
	size_t msglen;
	char *msg;

	msg = err == 0 ? "Not a number" : strerror(err);

	if ((msglen = strlcat(str, ": ", len)) >= len)
		return (msglen);

	return (strlcat(str, msg, len));
}

/*
 *  str_addarg(str, len, arg, first) - add the string argument "arg" to
 *	the string "str".  This is the first in the group when "first"
 *	is set (indicating that a comma should NOT be added to the front).
 */
static size_t
str_addarg(char *str, size_t len, char *arg, int first)
{
	size_t msglen;

	if (!first) {
		if ((msglen = strlcat(str, ", ", len)) >= len)
			return (msglen);
	}
	return (strlcat(str, arg, len));
}

/*
 *  err_compar(p1, p2) - comparison routine used by "qsort"
 *	for sorting errors.
 */
static int
err_compar(const void *e1, const void *e2)
{
	const struct errs *p1 = (const struct errs *) e1;
	const struct errs *p2 = (const struct errs *) e2;
	int result;

	if ((result = p1->err - p2->err) == 0)
		return (strcmp(p1->arg, p2->arg));
	return (result);
}

/*
 *  error_count() - return the number of errors currently logged.
 */
int
error_count(void)
{
	return (errcnt);
}

/*
 *  kill_procs(str) - send signals to processes, much like the "kill"
 *		command does; invoked in response to 'k'.
 */
char *
kill_procs(char *str)
{
	int signum = SIGTERM, procnum;
	uid_t uid, puid;
	char tempbuf[TEMPBUFSIZE];
	char *nptr, *tmp;

	tmp = tempbuf;

	/* reset error array */
	ERR_RESET;

	/* remember our uid */
	uid = getuid();

	/* skip over leading white space */
	while (isspace((unsigned char)*str))
		str++;

	if (*str == '-') {
		str++;

		/* explicit signal specified */
		if ((nptr = next_field(str)) == NULL)
			return (" kill: no processes specified");

		if (isdigit((unsigned char)*str)) {
			(void) scan_arg(str, &signum, tmp);
			if (signum <= 0 || signum >= NSIG)
				return (" invalid signal number");
		} else {
			/* translate the name into a number */
			for (signum = 0; signum < NSIG; signum++) {
				if (strcasecmp(sys_signame[signum],
				    str) == 0)
					break;
			}

			/* was it ever found */
			if (signum == NSIG)
				return (" bad signal name");
		}
		/* put the new pointer in place */
		str = nptr;
	}
	nptr = tempbuf;
	/* loop thru the string, killing processes */
	do {
		if (scan_arg(str, &procnum, nptr) == -1) {
			ERROR(nptr, 0);
		} else {
			/* check process owner if we're not root */
			puid = proc_owner(procnum);
			if (puid == (uid_t)(-1)) {
				ERROR(nptr, ESRCH);
			} else if (uid && (uid != puid)) {
				ERROR(nptr, EACCES);
			} else if (kill(procnum, signum) == -1) {
				ERROR(nptr, errno);
			}
		}
	} while ((str = next_field(str)) != NULL);

	/* return appropriate error string */
	return (err_string());
}

/*
 *  renice_procs(str) - change the "nice" of processes, much like the
 *		"renice" command does; invoked in response to 'r'.
 */
char *
renice_procs(char *str)
{
	uid_t uid;
	char negate;
	int prio, procnum;
	char tempbuf[TEMPBUFSIZE];
	char *nptr;

	ERR_RESET;
	uid = getuid();

	/* skip over leading white space */
	while (isspace((unsigned char)*str))
		str++;

	/* allow for negative priority values */
	if ((negate = (*str == '-')) != 0) {
		/* move past the minus sign */
		str++;
	}

	nptr = tempbuf;
	/* use procnum as a temporary holding place and get the number */
	procnum = scan_arg(str, &prio, nptr);

	/* negate if necessary */
	if (negate)
		prio = -prio;

#if defined(PRIO_MIN) && defined(PRIO_MAX)
	/* check for validity */
	if (procnum == -1 || prio < PRIO_MIN || prio > PRIO_MAX)
		return (" bad priority value");
#endif

	/* move to the first process number */
	if ((str = next_field(str)) == NULL)
		return (" no processes specified");

	/* loop thru the process numbers, renicing each one */
	do {
		if (scan_arg(str, &procnum, nptr) == -1) {
			ERROR(nptr, 0);
		}
		/* check process owner if we're not root */
		else if (uid && (uid != proc_owner(procnum))) {
			ERROR(nptr, EACCES);
		} else if (setpriority(PRIO_PROCESS, procnum, prio) == -1) {
			ERROR(nptr, errno);
		}
	} while ((str = next_field(str)) != NULL);

	/* return appropriate error string */
	return (err_string());
}
@


1.31
log
@unsigned char for ctype
ok krw okan
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.30 2010/04/01 05:05:19 lum Exp $	 */
d73 1
a73 1
	if (span == strlen(str)) 
d79 1
a79 1
	while (strcspn(str, spaces) == 0) 
d304 1
a304 1
				if (strcasecmp(sys_signame[signum], 
@


1.30
log
@Allow top to accept tab characters as input in interactive mode
while using the kill and renice commands. This removes a bug
where process numbers that came after a tab character in the
input string would not be affected by the corresponding command.

ok tedu@@ otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.29 2010/03/23 16:16:09 lum Exp $	 */
d103 1
a103 1
		if (isspace(ch))
d105 1
a105 1
		else if (!isdigit(ch))
d287 1
a287 1
	while (isspace(*str))
d297 1
a297 1
		if (isdigit(*str)) {
d355 1
a355 1
	while (isspace(*str))
@


1.29
log
@Fix pointer usage with the renice and kill error message structure. Pointer was used without allocating memory. ok beck@@ otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.28 2007/05/29 00:56:56 otto Exp $	 */
d69 14
a82 1
	if ((str = strchr(str, ' ')) == NULL)
d85 1
a85 7
	*str = '\0';
	while (*++str == ' ')	/* loop */
		;

	/* if there is nothing left of the string, return NULL */
	/* This fix is dedicated to Greg Earle */
	return (*str == '\0' ? NULL : str);
d276 3
a278 1
	char *nptr;
d290 3
a292 1
	if (str[0] == '-') {
d297 2
a298 2
		if (isdigit(str[1])) {
			(void) scan_arg(str + 1, &signum, nptr);
d304 2
a305 1
				if (strcasecmp(sys_signame[signum], str + 1) == 0)
@


1.28
log
@Instead of using hand-crafted redraws minimizing screen updates, use curses.
Enables nice things like process highlighting without hurting the brain.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.27 2007/02/23 13:31:45 millert Exp $	 */
d40 1
d57 1
a57 1
static int      scanint(char *, int *);
d81 3
d85 1
a85 1
scanint(char *str, int *intp)
d87 1
a87 1
	int val = 0;
d90 2
a91 2
	/* if there is nothing left of the string, flag it as an error */
	/* This fix is dedicated to Greg Earle */
d96 1
a96 3
		if (isdigit(ch))
			val = val * 10 + (ch - '0');
		else if (isspace(ch))
d98 2
d101 3
a103 1
			return (-1);
d105 5
d137 3
a139 1
		errs[errcnt].arg = (p); \
d268 1
d287 1
a287 1
			(void) scanint(str + 1, &signum);
d304 1
d307 2
a308 2
		if (scanint(str, &procnum) == -1) {
			ERROR(str, 0);
d313 1
a313 1
				ERROR(str, ESRCH);
d315 1
a315 1
				ERROR(str, EACCES);
d317 1
a317 1
				ERROR(str, errno);
d336 2
d342 4
d351 2
d354 1
a354 1
	procnum = scanint(str, &prio);
d372 2
a373 2
		if (scanint(str, &procnum) == -1) {
			ERROR(str, 0);
d377 1
a377 1
			ERROR(str, EACCES);
d379 1
a379 1
			ERROR(str, errno);
@


1.27
log
@Use sys_signame[] from libc instead of creating a top-specific
signame name to number table.  Also use strcasecmp() when matching
signal names for consistency with /bin/kill.
OK deraadt@@ henning@@ simon@@
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.26 2007/02/14 08:29:28 jmc Exp $	 */
a62 40
 *  show_help() - display the help screen; invoked in response to
 *		either 'h' or '?'.
 */
void
show_help(void)
{
	printf("Top version %s, %s\n", version_string(), copyright);
	puts("These single-character commands are available:\n"
	    "\n"
	    "h | ?        - help; show this text\n"
	    "^L           - redraw screen\n"
	    "q            - quit");

	/* not all commands are available with overstrike terminals */
	if (overstrike) {
		puts("\n"
		    "Other commands are also available, but this terminal is not\n"
		    "sophisticated enough to handle those commands gracefully.\n");
	} else {
		puts(
		    "+            - reset any g, p, or u filters\n"
		    "C            - toggle the display of command line arguments\n"
		    "d count      - show `count' displays, then exit\n"
		    "e            - list errors generated by last \"kill\" or \"renice\" command\n"
		    "g string     - filter on command name (g+ selects all commands)\n"
		    "I | i        - toggle the display of idle processes\n"
		    "k [-sig] pid - send signal `-sig' to process `pid'\n"
		    "n|# count    - show `count' processes\n"
		    "o field      - specify sort order (size, res, cpu, time, pri)\n"
		    "p pid        - display process by `pid' (p+ selects all processes)\n"
		    "r count pid  - renice process `pid' to nice value `count'\n"
		    "S            - toggle the display of system processes\n"
		    "s time       - change delay between displays to `time' seconds\n"
		    "T            - toggle the display of threads\n"
		    "u user       - display processes for `user' (u+ selects all users)\n"
		    "\n");
	}
}

/*
d114 2
a115 7
struct errs {			/* structure for a system-call error */
	int             err;	/* value of errno (that is, the actual error) */
	char           *arg;	/* argument that caused the error */
};

static struct errs errs[ERRMAX];
static int      errcnt;
d228 2
a229 2
	const struct errs *p1 = (struct errs *) e1;
	const struct errs *p2 = (struct errs *) e2;
a243 17
}

/*
 *  show_errors() - display on stdout the current log of errors.
 */
void
show_errors(void)
{
	struct errs *errp = errs;
	int cnt = 0;

	printf("%d error%s:\n\n", errcnt, errcnt == 1 ? "" : "s");
	while (cnt++ < errcnt) {
		printf("%5s: %s\n", errp->arg,
		    errp->err == 0 ? "Not a number" : strerror(errp->err));
		errp++;
	}
@


1.26
log
@more refinements for the interactive commands section; ok otto
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.25 2007/02/09 21:15:18 jmc Exp $	 */
a50 1
#include "sigdesc.h"		/* generated automatically */
a315 1
	struct sigdesc *sigp;
d340 2
a341 3
			for (sigp = sigdesc; sigp->name != NULL; sigp++) {
				if (strcmp(sigp->name, str + 1) == 0) {
					signum = sigp->number;
a342 1
				}
d346 1
a346 1
			if (sigp->name == NULL)
@


1.25
log
@document how signalling via `k' works, after some help from theo and miod;
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.24 2007/02/09 20:57:15 jmc Exp $	 */
d86 1
a86 1
		    "d n          - show number `n' displays\n"
d91 1
a91 1
		    "n|# n        - show number `n' processes\n"
d94 1
a94 1
		    "r n pid      - renice process `pid' to nice value `n'\n"
d96 1
a96 1
		    "s n          - change delay between displays to `n' seconds\n"
@


1.24
log
@sync somewhat to the man page;
started by a diff from Mark Lumsden
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.23 2007/02/06 06:53:13 otto Exp $	 */
d73 3
a75 3
	    "h | ?    - help; show this text\n"
	    "^L       - redraw screen\n"
	    "q        - quit");
d84 15
a98 15
		    "+        - reset any g, p, or u filters\n"
		    "C        - toggle the display of command line arguments\n"
		    "d n      - show number `n' displays\n"
		    "e        - list errors generated by last \"kill\" or \"renice\" command\n"
		    "g string - filter on command name (g+ selects all commands)\n"
		    "I | i    - toggle the display of idle processes\n"
		    "k        - send a signal to a list of processes\n"
		    "n|# n    - show number `n' processes\n"
		    "o field  - specify sort order (size, res, cpu, time, pri)\n"
		    "p pid    - display process by pid (p+ selects all processes)\n"
		    "r n pid  - renice process `pid' to nice value `n'\n"
		    "S        - toggle the display of system processes\n"
		    "s n      - change delay between displays to `n' seconds\n"
		    "T        - toggle the display of threads\n"
		    "u user   - display processes for `user' (u+ selects all users)\n"
@


1.23
log
@Compact help screen a bit so it fits in 24 lines again. Based on a
diff from Mark Lumsden.
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.22 2007/02/04 19:17:14 otto Exp $	 */
d73 3
a75 3
	    "^L      - redraw screen\n"
	    "h or ?  - help; show this text\n"
	    "q       - quit");
d84 15
a98 15
		    "+       - remove process filter(s)\n"
		    "C       - toggle the display of the command line arguments\n"
		    "d       - change number of displays to show\n"
		    "e       - list errors generated by last \"kill\" or \"renice\" command\n"
		    "g       - filter on command name (+ selects all commands)\n"
		    "i or I  - toggle the displaying of idle processes\n"
		    "k       - kill processes; send a signal to a list of processes\n"
		    "n or #  - change number of processes to display\n"
		    "o       - specify sort order (size, res, cpu, time, pri)\n"
		    "p       - display one process (+ selects all processes)\n"
		    "r       - renice a process\n"
		    "s       - change number of seconds to delay between updates\n"
		    "S       - toggle the display of system processes\n"
		    "T       - toggle the display of threads\n"
		    "u       - display processes for only one user (+ selects all users)\n"
@


1.22
log
@Introducing the '+' interactive command to reset all filters.
From Mark Lumsden. ok millert@@ deraadt@@ simon@@
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.21 2007/01/05 09:46:12 otto Exp $	 */
d71 1
a71 4
	puts("\n\n"
	    "A top users display for Unix\n"
	    "\n"
	    "These single-character commands are available:\n"
d89 1
a89 2
		    "i       - toggle the displaying of idle processes\n"
		    "I       - same as 'i'\n"
@


1.21
log
@tidy & sort help display
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.20 2007/01/05 07:26:46 otto Exp $	 */
d87 1
@


1.20
log
@add new g command to interactive help; from Mark Lumsden
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.19 2005/12/04 23:10:06 tedu Exp $	 */
d71 1
a71 1
	fputs("\n\n"
d78 1
a78 1
	    "q       - quit\n", stdout);
d82 1
a82 1
		fputs("\n"
d84 1
a84 2
		    "sophisticated enough to handle those commands gracefully.\n\n",
		    stdout);
d86 2
a87 1
		fputs(
d94 1
a94 2
		    "n or #  - change number of processes to display\n", stdout);
		fputs(
d96 1
a96 3
		    "p       - display one process (+ selects all processes)\n",
		    stdout);
		fputs(
d100 1
d102 1
a102 3
		    "T       - toggle the display of threads\n"
		    "C       - toggle the display of the command line arguments\n"
		    "\n\n", stdout);
@


1.19
log
@support for toggling thread viewing.
ok brad, hints from jmc
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.18 2005/10/07 17:46:13 hshoexer Exp $	 */
d90 1
@


1.18
log
@sync help message with reality:  sort acceptes keyword "pri"

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.17 2005/06/17 09:40:48 markus Exp $	 */
d103 1
@


1.17
log
@add a 'C' command ) that toggles the display of the full cmdline;
with Jared Yanovich; ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.16 2004/10/07 06:26:12 otto Exp $	 */
d95 1
a95 1
		    "o       - specify sort order (size, res, cpu, time)\n"
@


1.16
log
@introduce -p option and p command to only show a single process.
From Patrick Latifi. ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.15 2004/06/27 00:48:22 marc Exp $	 */
d103 1
@


1.15
log
@errno struct member -> err; ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.14 2004/05/09 22:14:15 deraadt Exp $	 */
d95 2
a96 1
		    "o       - specify sort order (size, res, cpu, time)\n",
@


1.14
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.13 2003/09/19 10:32:24 jmc Exp $	 */
d159 1
a159 1
	int             errno;	/* value of errno (that is, the actual error) */
d176 1
a176 1
		errs[errcnt++].errno = (e); \
d208 1
a208 1
		if (errp->errno != currerr) {
d217 1
a217 1
			currerr = errp->errno;
d281 1
a281 1
	if ((result = p1->errno - p2->errno) == 0)
d307 1
a307 1
		    errp->errno == 0 ? "Not a number" : strerror(errp->errno));
@


1.13
log
@commands.c: add `o' and `S' to internal help, sort options
top.1: sort options and SYNOPSIS
       add description of `o' (from Patrick Latifi)
top.c: sync usage() with SYNOPSIS

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.12 2003/06/20 16:53:15 deraadt Exp $	 */
d124 1
a124 1
static int 
@


1.12
log
@some cleanings recommended by lint
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.11 2003/06/17 00:51:29 jfb Exp $	 */
d77 2
a78 2
	    "q       - quit\n"
	    "h or ?  - help; show this text\n", stdout);
a93 1
#ifdef ORDER
a96 1
#endif
d100 1
@


1.11
log
@properly typecast to uid_t the return value of proc_owner() and report
ESRCH instead of EACCES if it returns -1

ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.10 2003/06/15 16:24:44 millert Exp $	 */
d200 1
a200 1
	qsort((char *) errs, errcnt, sizeof(struct errs), err_compar);
@


1.10
log
@use uid_t and fix some sign compare warnings; OK krw@@ and deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.9 2003/06/13 21:52:24 deraadt Exp $	 */
d322 1
a322 1
	uid_t uid;
d366 4
a369 1
			if (uid && (uid != proc_owner(procnum))) {
@


1.9
log
@readable code
@
text
@d1 1
a1 1
/* $OpenBSD: commands.c,v 1.8 2003/06/12 22:30:23 pvalchev Exp $	 */
d320 1
a320 1
	int signum = SIGTERM, procnum, uid;
d322 1
d385 1
a385 1
	int prio, procnum, uid;
d387 1
@


1.8
log
@cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.7 2003/04/06 20:39:20 tdeval Exp $	*/
d56 6
a61 6
static char *next_field(char *);
static int scanint(char *, int *);
static char *err_string(void);
static size_t str_adderr(char *, size_t, int);
static size_t str_addarg(char *, size_t, char *, int);
static int err_compar(const void *, const void *);
a66 1

d70 24
a93 26
    printf("Top version %s, %s\n", version_string(), copyright);
    fputs("\n\n\
A top users display for Unix\n\
\n\
These single-character commands are available:\n\
\n\
^L      - redraw screen\n\
q       - quit\n\
h or ?  - help; show this text\n", stdout);

    /* not all commands are availalbe with overstrike terminals */
    if (overstrike)
    {
	fputs("\n\
Other commands are also available, but this terminal is not\n\
sophisticated enough to handle those commands gracefully.\n\n", stdout);
    }
    else
    {
	fputs("\
d       - change number of displays to show\n\
e       - list errors generated by last \"kill\" or \"renice\" command\n\
i       - toggle the displaying of idle processes\n\
I       - same as 'i'\n\
k       - kill processes; send a signal to a list of processes\n\
n or #  - change number of processes to display\n", stdout);
d95 3
a97 2
	fputs("\
o       - specify sort order (size, res, cpu, time)\n", stdout);
d99 6
a104 7
	fputs("\
r       - renice a process\n\
s       - change number of seconds to delay between updates\n\
u       - display processes for only one user (+ selects all users)\n\
\n\
\n", stdout);
    }
a109 1

d113 10
a122 10
    if ((str = strchr(str, ' ')) == NULL)
    {
	return(NULL);
    }
    *str = '\0';
    while (*++str == ' ') /* loop */;

    /* if there is nothing left of the string, return NULL */
    /* This fix is dedicated to Greg Earle */
    return (*str == '\0' ? NULL : str);
d125 2
a126 1
static int scanint(char *str, int *intp)
d128 2
a129 2
    int val = 0;
    char ch;
d131 12
a142 16
    /* if there is nothing left of the string, flag it as an error */
    /* This fix is dedicated to Greg Earle */
    if (*str == '\0')
    {
	return(-1);
    }

    while ((ch = *str++) != '\0')
    {
	if (isdigit(ch))
	{
	    val = val * 10 + (ch - '0');
	}
	else if (isspace(ch))
	{
	    break;
d144 2
a145 7
	else
	{
	    return(-1);
	}
    }
    *intp = val;
    return(0);
d159 3
a161 4
struct errs		/* structure for a system-call error */
{
    int  errno;		/* value of errno (that is, the actual error) */
    char *arg;		/* argument that caused the error */
d165 3
a167 3
static int errcnt;
static char *err_toomany = " too many errors occurred";
static char *err_listem = 
d172 9
a180 9
#define ERROR(p, e) if (errcnt >= ERRMAX) \
		    { \
			return(err_toomany); \
		    } \
		    else \
		    { \
			errs[errcnt].arg = (p); \
			errs[errcnt++].errno = (e); \
		    }
a187 3

#define STRMAX 80

d191 29
a219 31
    struct errs *errp;
    int  cnt = 0;
    int  first = Yes;
    int  currerr = -1;
    static char string[STRMAX];

    /* if there are no errors, return NULL */
    if (errcnt == 0)
    {
	return(NULL);
    }

    /* sort the errors */
    qsort((char *)errs, errcnt, sizeof(struct errs), err_compar);

    /* need a space at the front of the error string */
    string[0] = ' ';
    string[1] = '\0';

    /* loop thru the sorted list, building an error string */
    while (cnt < errcnt)
    {
	errp = &(errs[cnt++]);
	if (errp->errno != currerr)
	{
	    if (currerr != -1)
	    {
		if (str_adderr(string, sizeof string, currerr) >
		    (sizeof string - 2))
		{
		    return(err_listem);
d221 5
a225 10
		/* we know there's more */
		(void) strlcat(string, "; ", sizeof string);
	    }
	    currerr = errp->errno;
	    first = Yes;
	}
	if (str_addarg(string, sizeof string, errp->arg, first) >=
	    sizeof string)
	{
	    return(err_listem);
a226 2
	first = No;
    }
d228 3
a230 3
    /* add final message */
    if (str_adderr(string, sizeof string, currerr) >= sizeof string)
	return(err_listem);
d232 2
a233 2
    /* return the error string */
    return(string);
a239 1

d243 2
a244 2
    char *msg;
    size_t msglen;
d246 1
a246 1
    msg = err == 0 ? "Not a number" : strerror(err);
d248 2
a249 2
    if ((msglen = strlcat(str, ": ", len)) >= len)
	return(msglen);
d251 1
a251 1
    return(strlcat(str, msg, len));
a258 1

d262 1
a262 1
    size_t msglen;
d264 5
a268 7
    if (!first)
    {
	if ((msglen = strlcat(str, ", ", len)) >= len)
	    return(msglen);
    }

    return (strlcat(str, arg, len));
a274 1

d278 7
a284 9
    const struct errs *p1 = (struct errs *)e1;
    const struct errs *p2 = (struct errs *)e2;
    int result;

    if ((result = p1->errno - p2->errno) == 0)
    {
	return(strcmp(p1->arg, p2->arg));
    }
    return(result);
a289 1

d293 1
a293 1
    return(errcnt);
a298 1

d302 2
a303 2
    int cnt = 0;
    struct errs *errp = errs;
d305 6
a310 7
    printf("%d error%s:\n\n", errcnt, errcnt == 1 ? "" : "s");
    while (cnt++ < errcnt)
    {
	printf("%5s: %s\n", errp->arg,
	    errp->errno == 0 ? "Not a number" : strerror(errp->errno));
	errp++;
    }
a316 1

d320 38
a357 21
    char *nptr;
    int signum = SIGTERM;	/* default */
    int procnum;
    struct sigdesc *sigp;
    int uid;

    /* reset error array */
    ERR_RESET;

    /* remember our uid */
    uid = getuid();

    /* skip over leading white space */
    while (isspace(*str)) str++;

    if (str[0] == '-')
    {
	/* explicit signal specified */
	if ((nptr = next_field(str)) == NULL)
	{
	    return(" kill: no processes specified");
d359 11
a369 18

	if (isdigit(str[1]))
	{
	    (void) scanint(str + 1, &signum);
	    if (signum <= 0 || signum >= NSIG)
	    {
		return(" invalid signal number");
	    }
	}
	else 
	{
	    /* translate the name into a number */
	    for (sigp = sigdesc; sigp->name != NULL; sigp++)
	    {
		if (strcmp(sigp->name, str + 1) == 0)
		{
		    signum = sigp->number;
		    break;
d371 1
a371 34
	    }

	    /* was it ever found */
	    if (sigp->name == NULL)
	    {
		return(" bad signal name");
	    }
	}
	/* put the new pointer in place */
	str = nptr;
    }

    /* loop thru the string, killing processes */
    do
    {
	if (scanint(str, &procnum) == -1)
	{
	    ERROR(str, 0);
	}
	else
	{
	    /* check process owner if we're not root */
	    if (uid && (uid != proc_owner(procnum)))
	    {
		ERROR(str, EACCES);
	    }
	    /* go in for the kill */
	    else if (kill(procnum, signum) == -1)
	    {
		/* chalk up an error */
		ERROR(str, errno);
	    }
	}
    } while ((str = next_field(str)) != NULL);
d373 2
a374 2
    /* return appropriate error string */
    return(err_string());
a380 1

d384 17
a400 23
    char negate;
    int prio;
    int procnum;
    int uid;

    ERR_RESET;
    uid = getuid();

    /* allow for negative priority values */
    if ((negate = (*str == '-')) != 0)
    {
	/* move past the minus sign */
	str++;
    }

    /* use procnum as a temporary holding place and get the number */
    procnum = scanint(str, &prio);

    /* negate if necessary */
    if (negate)
    {
	prio = -prio;
    }
d403 3
a405 5
    /* check for validity */
    if (procnum == -1 || prio < PRIO_MIN || prio > PRIO_MAX)
    {
	return(" bad priority value");
    }
d408 16
a423 24
    /* move to the first process number */
    if ((str = next_field(str)) == NULL)
    {
	return(" no processes specified");
    }

    /* loop thru the process numbers, renicing each one */
    do
    {
	if (scanint(str, &procnum) == -1)
	{
	    ERROR(str, 0);
	}

	/* check process owner if we're not root */
	else if (uid && (uid != proc_owner(procnum)))
	{
	    ERROR(str, EACCES);
	}
	else if (setpriority(PRIO_PROCESS, procnum, prio) == -1)
	{
	    ERROR(str, errno);
	}
    } while ((str = next_field(str)) != NULL);
d425 2
a426 2
    /* return appropriate error string */
    return(err_string());
@


1.7
log
@strcat -> strlcat fix.  ok tedu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.6 2002/07/15 17:20:36 deraadt Exp $	*/
d69 1
a69 2
show_help()

d114 2
a115 4
static char *next_field(str)

char *str;

d126 1
a126 1
    return(*str == '\0' ? NULL : str);
d129 1
a129 5
static int scanint(str, intp)

char *str;
int  *intp;

d204 2
a205 2
static char *err_string()

d266 2
a267 6
static size_t str_adderr(str, len, err)

char *str;
size_t len;
int err;

d273 1
d276 1
d286 2
a287 7
static size_t str_addarg(str, len, arg, first)

char *str;
size_t len;
char *arg;
int  first;

d296 2
a297 1
    return(strlcat(str, arg, len));
d305 2
a306 4
static int err_compar(e1, e2)

const void *e1, *e2;

d323 2
a324 2
int error_count()

d333 2
a334 2
void show_errors()

d353 2
a354 4
char *kill_procs(str)

char *str;

d441 2
a442 4
char *renice_procs(str)

char *str;

a503 1

@


1.6
log
@license change from William LeFebvre <wnl@@groupsys.com>; top is now BSD
licensed.  this same license will show up on his next release as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.5 2002/05/29 18:33:40 deraadt Exp $	*/
d59 2
a60 2
static int str_adderr(char *, int, int);
static int str_addarg(char *, int, char *, int);
a217 1
    int stringlen;		/* characters still available in "string" */
a231 1
    stringlen = STRMAX - 2;
d241 2
a242 1
		if ((stringlen = str_adderr(string, stringlen, currerr)) < 2)
d252 2
a253 1
	if ((stringlen = str_addarg(string, stringlen, errp->arg, first)) ==0)
d261 2
a262 1
    stringlen = str_adderr(string, stringlen, currerr);
d265 1
a265 1
    return(stringlen == 0 ? err_listem : string);
d273 1
a273 1
static int str_adderr(str, len, err)
d276 1
a276 1
int len;
d281 1
a281 1
    int  msglen;
d284 3
a286 8
    msglen = strlen(msg) + 2;
    if (len <= msglen)
    {
	return(0);
    }
    (void) strcat(str, ": ");
    (void) strcat(str, msg);
    return(len - msglen);
d295 1
a295 1
static int str_addarg(str, len, arg, first)
d298 1
a298 1
int  len;
d303 1
a303 1
    int arglen;
a304 9
    arglen = strlen(arg);
    if (!first)
    {
	arglen += 2;
    }
    if (len <= arglen)
    {
	return(0);
    }
d307 2
a308 1
	(void) strcat(str, ", ");
d310 1
a310 2
    (void) strcat(str, arg);
    return(len - arglen);
@


1.5
log
@strlcat
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.4 2002/02/16 21:27:55 millert Exp $	*/
d7 2
a8 2
 *  This program may be freely redistributed,
 *  but this entire comment MUST remain intact.
d10 19
a28 2
 *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
 *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.3 2001/11/19 19:02:17 mpech Exp $	*/
d230 2
a231 1
		(void) strcat(string, "; ");	  /* we know there's more */
@


1.3
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.2 1997/08/22 07:16:26 downsj Exp $	*/
d39 6
a44 6
static char *next_field __P((char *));
static int scanint __P((char *, int *));
static char *err_string __P((void));
static int str_adderr __P((char *, int, int));
static int str_addarg __P((char *, int, char *, int));
static int err_compar __P((const void *, const void *));
@


1.2
log
@First sweep.  Prototype, type fixes, long fixes, mostly compiles with
-Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: commands.c,v 1.1 1997/08/14 14:00:20 downsj Exp $	*/
d100 1
a100 1
register char *str;
d121 2
a122 2
    register int val = 0;
    register char ch;
d197 4
a200 4
    register struct errs *errp;
    register int  cnt = 0;
    register int  first = Yes;
    register int  currerr = -1;
d261 2
a262 2
    register char *msg;
    register int  msglen;
d289 1
a289 1
    register int arglen;
d318 3
a320 3
    register const struct errs *p1 = (struct errs *)e1;
    register const struct errs *p2 = (struct errs *)e2;
    register int result;
d346 2
a347 2
    register int cnt = 0;
    register struct errs *errp = errs;
d368 1
a368 1
    register char *nptr;
d458 1
a458 1
    register char negate;
@


1.1
log
@top 3.4, with a few changes.  Still needs more work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d21 2
a22 1
#include "os.h"
d24 3
d28 1
a28 1
#include <errno.h>
d32 2
d37 1
d39 6
a44 9
extern int  errno;

extern char *copyright;

/* imported from screen.c */
extern int overstrike;

int err_compar();
char *err_string();
d51 1
d98 1
a98 1
char *next_field(str)
d115 1
a115 1
scanint(str, intp)
d194 1
a194 1
char *err_string()
d254 1
a254 1
str_adderr(str, len, err)
d264 1
a264 1
    msg = err == 0 ? "Not a number" : errmsg(err);
d281 1
a281 1
str_addarg(str, len, arg, first)
d313 1
a313 1
err_compar(p1, p2)
d315 1
a315 1
register struct errs *p1, *p2;
d318 2
d333 1
a333 1
error_count()
d343 1
a343 1
show_errors()
d353 1
a353 1
	    errp->errno == 0 ? "Not a number" : errmsg(errp->errno));
@
