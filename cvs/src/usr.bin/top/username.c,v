head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.6
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.8
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.26
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.18
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.22
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.20
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.16
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.14
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.12
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.10
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.8
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.16
	OPENBSD_2_8:1.2.0.14
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.12
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.10
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2015.10.26.13.56.18;	author tedu;	state Exp;
branches;
next	1.16;
commitid	DkCkg3QZjZupcqUB;

1.16
date	2009.07.22.15.27.52;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2008.04.02.16.41.24;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.09.22.14.15;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.07.21.36.52;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.19.22.40.45;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.15.16.24.44;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.13.21.52.25;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.12.23.09.30;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.12.22.30.23;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.15.17.20.36;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.23.03.07.22;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.55;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.27.17.04.06;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.08.22.07.16.31;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.08.14.14.00.27;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.17
log
@remove the silly username cache here and use libc user_from_uid.
libc isn't (yet) any better, but it can improve with time.
@
text
@/* $OpenBSD: username.c,v 1.16 2009/07/22 15:27:52 deraadt Exp $	 */

/*
 *  Top users/processes display for Unix
 *  Version 3
 *
 * Copyright (c) 1984, 1989, William LeFebvre, Rice University
 * Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS EMPLOYER BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *  Username translation code for top.
 */

#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <pwd.h>

#include "top.local.h"
#include "top.h"
#include "utils.h"

char *
username(uid_t uid)
{
	return user_from_uid(uid, 0);
}

uid_t
userid(char *username)
{
	struct passwd *pwd;

	if ((pwd = getpwnam(username)) == NULL)
		return ((uid_t)-1);

	return (pwd->pw_uid);
}
@


1.16
log
@enter_user() is only called in one way, rendering the third parameter
useless; from mark@@cyodesigns.com
@
text
@d1 1
a1 1
/* $OpenBSD: username.c,v 1.15 2008/04/02 16:41:24 deraadt Exp $	 */
a32 15
 *
 *  These routines handle uid to username mapping.
 *  They use a hashing table scheme to reduce reading overhead.
 *  For the time being, these are very straightforward hashing routines.
 *  Maybe someday I'll put in something better.  But with the advent of
 *  "random access" password files, it might not be worth the effort.
 *
 *  Changes to these have been provided by John Gilmore (gnu@@toad.com).
 *
 *  The hash has been simplified in this release, to avoid the
 *  table overflow problems of previous releases.  If the value
 *  at the initial hash location is not right, it is replaced
 *  by the right value.  Collisions will cause us to call getpw*
 *  but hey, this is a cache, not the Library of Congress.
 *  This makes the table size independent of the passwd file size.
a43 17
struct hash_el {
	uid_t	uid;
	char	name[_PW_NAME_LEN + 1];
};

static int	enter_user(uid_t, char *);
static int	get_user(uid_t);

#define	is_empty_hash(x)	(hash_table[x].name[0] == 0)

/*
 * Simple minded hashing function, assumes i is unsigned.
 */
#define	hashit(i)	(i % Table_size)

struct hash_el  hash_table[Table_size];

d47 1
a47 8
	int hashindex;

	hashindex = hashit(uid);
	if (is_empty_hash(hashindex) || (hash_table[hashindex].uid != uid)) {
		/* not here or not right -- get it out of passwd */
		hashindex = get_user(uid);
	}
	return (hash_table[hashindex].name);
a54 4
	/*
	 * Eventually we want this to enter everything in the hash table, but
	 * for now we just do it simply and remember just the result.
	 */
a57 4
	/* enter the result in the hash table */
	enter_user(pwd->pw_uid, username);

	/* return our result */
a58 38
}

static int
enter_user(uid_t uid, char *name)
{
	int hashindex;

#ifdef DEBUG
	fprintf(stderr, "enter_hash(%u, %s)\n", uid, name);
#endif

	hashindex = hashit(uid);

	if (!is_empty_hash(hashindex)) {
		if (hash_table[hashindex].uid == uid)
			return (hashindex);	/* Fortuitous find */
	}
	/* empty or wrong slot -- fill it with new value */
	hash_table[hashindex].uid = uid;
	(void) strlcpy(hash_table[hashindex].name, name,
	    sizeof(hash_table[hashindex].name));
	return (hashindex);
}

/*
 * Get a userid->name mapping from the system.
 */
static int
get_user(uid_t uid)
{
	struct passwd *pwd;

	/* no performance penalty for using getpwuid makes it easy */
	if ((pwd = getpwuid(uid)) != NULL)
		return (enter_user(pwd->pw_uid, pwd->pw_name));

	/* if we can't find the name at all, then use the uid as the name */
	return (enter_user(uid, format_uid(uid)));
@


1.15
log
@using getpwent() in a loop is so 1980; ok millert
@
text
@d1 1
a1 1
/* $OpenBSD: username.c,v 1.14 2004/05/09 22:14:15 deraadt Exp $	 */
d64 1
a64 1
static int	enter_user(uid_t, char *, int);
d102 1
a102 1
	enter_user(pwd->pw_uid, username, 1);
a107 3
/*
 * wecare: 1 = enter it always, 0 = nice to have
 */
d109 1
a109 1
enter_user(uid_t uid, char *name, int wecare)
d114 1
a114 1
	fprintf(stderr, "enter_hash(%u, %s, %d)\n", uid, name, wecare);
a119 2
		if (!wecare)
			return 0;	/* Don't clobber a slot for trash */
d140 1
a140 1
		return (enter_user(pwd->pw_uid, pwd->pw_name, 1));
d143 1
a143 1
	return (enter_user(uid, format_uid(uid), 1));
@


1.14
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: username.c,v 1.13 2003/07/07 21:36:52 deraadt Exp $	 */
a136 3
 * If the passwd database is hashed (#define RANDOM_PW), we
 * just handle this uid.  Otherwise we scan the passwd file
 * and cache any entries we pass over while looking.
a142 1
#ifdef RANDOM_PW
a145 1
#else
a146 24
	int from_start = 0;

	/*
	 *  If we just called getpwuid each time, things would be very slow
	 *  since that just iterates through the passwd file each time.  So,
	 *  we walk through the file instead (using getpwent) and cache each
	 *  entry as we go.  Once the right record is found, we cache it and
	 *  return immediately.  The next time we come in, getpwent will get
	 *  the next record.  In theory, we never have to read the passwd file
	 *  a second time (because we cache everything we read).  But in
	 *  practice, the cache may not be large enough, so if we don't find
	 *  it the first time we have to scan the file a second time.  This
	 *  is not very efficient, but it will do for now.
	 */
	while (from_start++ < 2) {
		while ((pwd = getpwent()) != NULL) {
			if (pwd->pw_uid == uid)
				return (enter_user(pwd->pw_uid, pwd->pw_name, 1));
			(void) enter_user(pwd->pw_uid, pwd->pw_name, 0);
		}
		/* try again */
		setpwent();
	}
#endif
@


1.13
log
@protos
@
text
@d1 1
a1 1
/* $OpenBSD: username.c,v 1.12 2003/06/19 22:40:45 millert Exp $	 */
d64 2
a65 2
static int      enter_user(uid_t, char *, int);
static int      get_user(uid_t);
@


1.12
log
@o get rid of strecpy() and use strlcpy() and/or snprintf() instead.
o make itoa() just use snprintf()
o rename itoa7() to format_uid() and use snprintf()
o max username len is _PW_NAME_LEN, not 8
@
text
@d1 1
a1 1
/* $OpenBSD: username.c,v 1.11 2003/06/15 16:24:44 millert Exp $	 */
d56 1
@


1.11
log
@use uid_t and fix some sign compare warnings; OK krw@@ and deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: username.c,v 1.10 2003/06/13 21:52:25 deraadt Exp $	 */
d60 1
a60 1
	char	name[9];
a67 1
/* simple minded hashing function */
d69 1
a69 2
 * Uid "nobody" is -2 results in hashit(-2) = -2 which is out of bounds for
 * the hash_table.  Applied abs() function to fix. 2/16/96 tpugh
d71 1
a71 1
#define	hashit(i)	(abs(i) % Table_size)
a72 2
/* K&R requires that statically declared tables be initialized to zero. */
/* We depend on that for hash_table and YOUR compiler had BETTER do it! */
d176 1
a176 1
	return (enter_user(uid, itoa7(uid), 1));
@


1.10
log
@readable code
@
text
@d1 1
a1 1
/* $OpenBSD: username.c,v 1.9 2003/06/12 23:09:30 deraadt Exp $	 */
d59 2
a60 2
	uid_t	   uid;
	char	    name[9];
d66 1
a66 1
#define    is_empty_hash(x)	(hash_table[x].name[0] == 0)
d73 1
a73 1
#define    hashit(i)	(abs(i) % Table_size)
d102 1
a102 1
		return (-1);
@


1.9
log
@knf
@
text
@d1 1
a1 1
/* $OpenBSD: username.c,v 1.8 2003/06/12 22:30:23 pvalchev Exp $	 */
a78 10
void
init_hash(void)
{
	/*
	 *  There used to be some steps we had to take to initialize things.
	 *  We don't need to do that anymore, but we will leave this stub in
	 *  just in case future changes require initialization steps.
	 */
}

a100 1

@


1.8
log
@cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: username.c,v 1.7 2002/07/15 17:20:36 deraadt Exp $	*/
d59 2
a60 2
    uid_t  uid;
    char name[9];
d63 2
a64 2
static int enter_user(uid_t, char *, int);
static int get_user(uid_t);
d69 4
a72 3
/* Uid "nobody" is -2 results in hashit(-2) = -2 which is out of bounds for
   the hash_table.  Applied abs() function to fix. 2/16/96 tpugh
*/
d77 1
a77 1
struct hash_el hash_table[Table_size];
d82 5
a86 5
    /*
     *  There used to be some steps we had to take to initialize things.
     *  We don't need to do that anymore, but we will leave this stub in
     *  just in case future changes require initialization steps.
     */
d92 1
a92 1
    int hashindex;
d94 6
a99 7
    hashindex = hashit(uid);
    if (is_empty_hash(hashindex) || (hash_table[hashindex].uid != uid))
    {
	/* not here or not right -- get it out of passwd */
	hashindex = get_user(uid);
    }
    return(hash_table[hashindex].name);
d105 6
a110 1
    struct passwd *pwd;
d112 2
a113 8
    /* Eventually we want this to enter everything in the hash table,
       but for now we just do it simply and remember just the result.
     */

    if ((pwd = getpwnam(username)) == NULL)
    {
	return(-1);
    }
d115 2
a116 2
    /* enter the result in the hash table */
    enter_user(pwd->pw_uid, username, 1);
d118 2
a119 2
    /* return our result */
    return(pwd->pw_uid);
d122 3
a124 1
/* wecare: 1 = enter it always, 0 = nice to have */
d128 1
a128 1
    int hashindex;
d131 1
a131 1
    fprintf(stderr, "enter_hash(%u, %s, %d)\n", uid, name, wecare);
d134 1
a134 1
    hashindex = hashit(uid);
d136 11
a146 13
    if (!is_empty_hash(hashindex))
    {
	if (!wecare)
	    return 0;		/* Don't clobber a slot for trash */
	if (hash_table[hashindex].uid == uid)
	    return(hashindex);	/* Fortuitous find */
    }

    /* empty or wrong slot -- fill it with new value */
    hash_table[hashindex].uid = uid;
    (void) strlcpy(hash_table[hashindex].name, name,
               sizeof(hash_table[hashindex].name));
    return(hashindex);
a154 1

d158 1
a158 1
    struct passwd *pwd;
d161 3
a163 5
    /* no performance penalty for using getpwuid makes it easy */
    if ((pwd = getpwuid(uid)) != NULL)
    {
	return(enter_user(pwd->pw_uid, pwd->pw_name, 1));
    }
d166 1
a166 1
    int from_start = 0;
d168 20
a187 22
    /*
     *  If we just called getpwuid each time, things would be very slow
     *  since that just iterates through the passwd file each time.  So,
     *  we walk through the file instead (using getpwent) and cache each
     *  entry as we go.  Once the right record is found, we cache it and
     *  return immediately.  The next time we come in, getpwent will get
     *  the next record.  In theory, we never have to read the passwd file
     *  a second time (because we cache everything we read).  But in
     *  practice, the cache may not be large enough, so if we don't find
     *  it the first time we have to scan the file a second time.  This
     *  is not very efficient, but it will do for now.
     */

    while (from_start++ < 2)
    {
	while ((pwd = getpwent()) != NULL)
	{
	    if (pwd->pw_uid == uid)
	    {
		return(enter_user(pwd->pw_uid, pwd->pw_name, 1));
	    }
	    (void) enter_user(pwd->pw_uid, pwd->pw_name, 0);
a188 3
	/* try again */
	setpwent();
    }
d190 2
a191 2
    /* if we can't find the name at all, then use the uid as the name */
    return(enter_user(uid, itoa7(uid), 1));
@


1.7
log
@license change from William LeFebvre <wnl@@groupsys.com>; top is now BSD
licensed.  this same license will show up on his next release as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: username.c,v 1.6 2002/06/23 03:07:22 deraadt Exp $	*/
d78 2
a79 2
void init_hash()

d88 2
a89 4
char *username(uid)

uid_t uid;

d102 2
a103 4
uid_t userid(username)

char *username;

d123 3
a125 6
static int enter_user(uid, name, wecare)

uid_t  uid;
char *name;
int wecare;		/* 1 = enter it always, 0 = nice to have */

d157 2
a158 4
static int get_user(uid)

uid_t uid;

@


1.6
log
@uid_t and gid_t are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: username.c,v 1.5 2002/02/16 21:27:55 millert Exp $	*/
d7 2
a8 2
 *  This program may be freely redistributed,
 *  but this entire comment MUST remain intact.
d10 19
a28 2
 *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
 *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: username.c,v 1.4 2001/11/19 19:02:17 mpech Exp $	*/
d120 1
a120 1
    fprintf(stderr, "enter_hash(%d, %s, %d)\n", uid, name, wecare);
@


1.4
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: username.c,v 1.3 2001/07/27 17:04:06 deraadt Exp $	*/
d46 2
a47 2
static int enter_user __P((uid_t, char *, int));
static int get_user __P((uid_t));
@


1.3
log
@more careful handling; i.mcwilliam@@uws.edu.au
@
text
@d1 1
a1 1
/*	$OpenBSD: username.c,v 1.2 1997/08/22 07:16:31 downsj Exp $	*/
d73 1
a73 1
register uid_t uid;
d76 1
a76 1
    register int hashindex;
d112 2
a113 2
register uid_t  uid;
register char *name;
d117 1
a117 1
    register int hashindex;
d149 1
a149 1
register uid_t uid;
@


1.2
log
@First sweep.  Prototype, type fixes, long fixes, mostly compiles with
-Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: username.c,v 1.1 1997/08/14 14:00:27 downsj Exp $	*/
d135 2
a136 1
    (void) strncpy(hash_table[hashindex].name, name, 8);
@


1.1
log
@top 3.4, with a few changes.  Still needs more work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 1
d35 1
d42 1
a42 1
    int  uid;
d46 3
d61 1
a61 1
init_hash()
d73 1
a73 1
register int uid;
d87 1
a87 1
int userid(username)
d110 1
a110 1
int enter_user(uid, name, wecare)
d112 1
a112 1
register int  uid;
d146 1
a146 1
int get_user(uid)
d148 1
a148 1
register int uid;
@
