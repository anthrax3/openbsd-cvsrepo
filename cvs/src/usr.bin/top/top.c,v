head	1.89;
access;
symbols
	OPENBSD_6_0:1.88.0.4
	OPENBSD_6_0_BASE:1.88
	OPENBSD_5_9:1.88.0.2
	OPENBSD_5_9_BASE:1.88
	OPENBSD_5_8:1.83.0.4
	OPENBSD_5_8_BASE:1.83
	OPENBSD_5_7:1.82.0.2
	OPENBSD_5_7_BASE:1.82
	OPENBSD_5_6:1.81.0.4
	OPENBSD_5_6_BASE:1.81
	OPENBSD_5_5:1.80.0.8
	OPENBSD_5_5_BASE:1.80
	OPENBSD_5_4:1.80.0.4
	OPENBSD_5_4_BASE:1.80
	OPENBSD_5_3:1.80.0.2
	OPENBSD_5_3_BASE:1.80
	OPENBSD_5_2:1.79.0.2
	OPENBSD_5_2_BASE:1.79
	OPENBSD_5_1_BASE:1.76
	OPENBSD_5_1:1.76.0.2
	OPENBSD_5_0:1.75.0.6
	OPENBSD_5_0_BASE:1.75
	OPENBSD_4_9:1.75.0.4
	OPENBSD_4_9_BASE:1.75
	OPENBSD_4_8:1.75.0.2
	OPENBSD_4_8_BASE:1.75
	OPENBSD_4_7:1.69.0.2
	OPENBSD_4_7_BASE:1.69
	OPENBSD_4_6:1.66.0.4
	OPENBSD_4_6_BASE:1.66
	OPENBSD_4_5:1.65.0.6
	OPENBSD_4_5_BASE:1.65
	OPENBSD_4_4:1.65.0.4
	OPENBSD_4_4_BASE:1.65
	OPENBSD_4_3:1.65.0.2
	OPENBSD_4_3_BASE:1.65
	OPENBSD_4_2:1.52.0.2
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.49.0.2
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.43.0.2
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.40.0.2
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.35.0.2
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.33.0.2
	OPENBSD_3_6_BASE:1.33
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.89
date	2017.03.15.04.24.14;	author deraadt;	state Exp;
branches;
next	1.88;
commitid	oL4eFXBEzCBQNxCU;

1.88
date	2015.11.05.17.17.13;	author espie;	state Exp;
branches;
next	1.87;
commitid	vZ7Oylp87XWz7lvr;

1.87
date	2015.11.04.21.28.27;	author tedu;	state Exp;
branches;
next	1.86;
commitid	9OljUYNxYoGFLTQ8;

1.86
date	2015.10.30.13.57.33;	author deraadt;	state Exp;
branches;
next	1.85;
commitid	KG2SuUEMe9uxE7CM;

1.85
date	2015.10.25.09.39.00;	author deraadt;	state Exp;
branches;
next	1.84;
commitid	D2D4KkN3zTC2PhBw;

1.84
date	2015.10.23.03.26.24;	author deraadt;	state Exp;
branches;
next	1.83;
commitid	7XmiAOXOqUGI0vLc;

1.83
date	2015.05.06.07.53.29;	author mpi;	state Exp;
branches;
next	1.82;
commitid	Q6ompHwEqgonty8G;

1.82
date	2014.09.17.01.56.54;	author dlg;	state Exp;
branches;
next	1.81;
commitid	dV1NkTNsF7KrC3AE;

1.81
date	2014.04.07.15.49.22;	author millert;	state Exp;
branches;
next	1.80;

1.80
date	2013.01.14.21.33.59;	author guenther;	state Exp;
branches;
next	1.79;

1.79
date	2012.06.08.13.41.16;	author lum;	state Exp;
branches;
next	1.78;

1.78
date	2012.06.05.18.52.53;	author brynet;	state Exp;
branches;
next	1.77;

1.77
date	2012.04.20.16.36.11;	author pirofti;	state Exp;
branches;
next	1.76;

1.76
date	2011.12.16.14.50.24;	author jsing;	state Exp;
branches;
next	1.75;

1.75
date	2010.04.24.22.02.14;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2010.04.21.11.29.59;	author lum;	state Exp;
branches;
next	1.73;

1.73
date	2010.03.26.16.56.00;	author lum;	state Exp;
branches;
next	1.72;

1.72
date	2010.03.23.16.16.09;	author lum;	state Exp;
branches;
next	1.71;

1.71
date	2010.03.22.12.20.25;	author lum;	state Exp;
branches;
next	1.70;

1.70
date	2010.03.18.12.47.48;	author otto;	state Exp;
branches;
next	1.69;

1.69
date	2010.01.29.00.36.09;	author tedu;	state Exp;
branches;
next	1.68;

1.68
date	2009.12.10.13.16.02;	author tedu;	state Exp;
branches;
next	1.67;

1.67
date	2009.07.18.06.12.41;	author jmc;	state Exp;
branches;
next	1.66;

1.66
date	2009.06.04.19.01.30;	author sthen;	state Exp;
branches;
next	1.65;

1.65
date	2007.11.29.10.06.30;	author otto;	state Exp;
branches;
next	1.64;

1.64
date	2007.11.27.13.19.16;	author otto;	state Exp;
branches;
next	1.63;

1.63
date	2007.11.22.11.01.04;	author otto;	state Exp;
branches;
next	1.62;

1.62
date	2007.11.06.06.56.59;	author otto;	state Exp;
branches;
next	1.61;

1.61
date	2007.11.04.18.51.48;	author otto;	state Exp;
branches;
next	1.60;

1.60
date	2007.11.04.18.45.48;	author otto;	state Exp;
branches;
next	1.59;

1.59
date	2007.11.01.19.25.32;	author otto;	state Exp;
branches;
next	1.58;

1.58
date	2007.10.16.07.33.08;	author otto;	state Exp;
branches;
next	1.57;

1.57
date	2007.10.04.07.47.53;	author otto;	state Exp;
branches;
next	1.56;

1.56
date	2007.09.27.19.44.54;	author otto;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.26.11.06.41;	author otto;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.18.11.15.25;	author otto;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.10.10.48.01;	author otto;	state Exp;
branches;
next	1.52;

1.52
date	2007.07.27.13.59.27;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.29.00.56.56;	author otto;	state Exp;
branches;
next	1.50;

1.50
date	2007.04.01.19.07.48;	author jmc;	state Exp;
branches;
next	1.49;

1.49
date	2007.02.27.16.27.39;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2007.02.04.19.23.27;	author otto;	state Exp;
branches;
next	1.47;

1.47
date	2007.02.04.19.17.14;	author otto;	state Exp;
branches;
next	1.46;

1.46
date	2007.02.04.15.01.11;	author otto;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.03.18.57.49;	author otto;	state Exp;
branches;
next	1.44;

1.44
date	2006.12.27.07.24.52;	author otto;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.04.06.58.12;	author otto;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.04.06.54.18;	author otto;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.04.23.10.06;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2005.06.17.09.40.48;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2005.06.08.22.36.43;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.14.09.03.31;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.13.20.43.30;	author jaredy;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.13.02.33.09;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.07.06.26.12;	author otto;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.14.22.55.48;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.09.22.16.26;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.09.22.14.15;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.07.19.19.49;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.01.20.20.57;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.19.10.32.24;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.21.08.14.50;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.07.21.36.52;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.19.22.40.45;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.18.08.42.17;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.18.08.36.31;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.16.17.24.44;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.16.01.09.02;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.15.16.24.44;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.13.21.52.25;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.12.22.30.23;	author pvalchev;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.15.17.20.36;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.14.21.35.00;	author todd;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.21.18.52.33;	author hugh;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.55;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.17.19.57.36;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.11.01.48.58;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.05.06.25.39;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.27.17.13.42;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.17.02.23.58;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.18.07.29.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.22.22.46.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.07.22.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.04.21.19.38;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.05.23.17.19.21;	author aaron;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	97.08.22.07.16.30;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.08.14.14.00.26;	author downsj;	state Exp;
branches;
next	;

1.3.4.1
date	2000.10.06.20.06.24;	author jason;	state Exp;
branches;
next	;


desc
@@


1.89
log
@annoying whitespace die die die
@
text
@/*	$OpenBSD: top.c,v 1.88 2015/11/05 17:17:13 espie Exp $	*/

/*
 *  Top users/processes display for Unix
 *  Version 3
 *
 * Copyright (c) 1984, 1989, William LeFebvre, Rice University
 * Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS EMPLOYER BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <curses.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <poll.h>
#include <stdlib.h>
#include <limits.h>
#include <unistd.h>

/* includes specific to top */
#include "display.h"		/* interface to display package */
#include "screen.h"		/* interface to screen package */
#include "top.h"
#include "top.local.h"
#include "boolean.h"
#include "machine.h"
#include "utils.h"

/* Size of the stdio buffer given to stdout */
#define BUFFERSIZE	2048

/* The buffer that stdio will use */
char		stdoutbuf[BUFFERSIZE];

/* signal handling routines */
static void	leave(int);
static void	onalrm(int);
static void	tstop(int);
static void	sigwinch(int);

volatile sig_atomic_t leaveflag, tstopflag, winchflag;

static void	reset_display(void);
int		rundisplay(void);

static int	max_topn;	/* maximum displayable processes */

extern int	(*proc_compares[])(const void *, const void *);
int order_index;

int displays = 0;	/* indicates unspecified */
char do_unames = Yes;
struct process_select ps;
char interactive = Maybe;
double delay = Default_DELAY;
char *order_name = NULL;
int topn = Default_TOPN;
int no_command = Yes;
int old_system = No;
int old_threads = No;
int show_args = No;
pid_t hlpid = -1;
int combine_cpus = 0;

#if Default_TOPN == Infinity
char topn_specified = No;
#endif

/*
 * these defines enumerate the "strchr"s of the commands in
 * command_chars
 */
#define CMD_redraw	0
#define CMD_update	1
#define CMD_quit	2
#define CMD_help1	3
#define CMD_help2	4
#define CMD_OSLIMIT	4	/* terminals with OS can only handle commands */
#define CMD_errors	5	/* less than or equal to CMD_OSLIMIT	   */
#define CMD_number1	6
#define CMD_number2	7
#define CMD_delay	8
#define CMD_displays	9
#define CMD_kill	10
#define CMD_renice	11
#define CMD_idletog	12
#define CMD_idletog2	13
#define CMD_user	14
#define CMD_system	15
#define CMD_order	16
#define CMD_pid		17
#define CMD_command	18
#define CMD_threads	19
#define CMD_grep	20
#define CMD_add		21
#define CMD_hl		22
#define CMD_cpus	23

static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-1bCHIinqSu] [-d count] [-g string] [-o field] "
	    "[-p pid] [-s time]\n\t[-U [-]user] [number]\n",
	    __progname);
}

static void
parseargs(int ac, char **av)
{
	char *endp;
	int i;

	while ((i = getopt(ac, av, "1SHICbinqus:d:p:U:o:g:")) != -1) {
		switch (i) {
		case '1':
			combine_cpus = 1;
			break;
		case 'C':
			show_args = Yes;
			break;
		case 'u':	/* toggle uid/username display */
			do_unames = !do_unames;
			break;

		case 'U':	/* display only username's processes */
			if (optarg[0] == '-') {
				if ((ps.huid = userid(optarg+1)) == (uid_t)-1)
					new_message(MT_delayed, "%s: unknown user",
					    optarg);
				else
					ps.uid = (uid_t)-1;
			} else if ((ps.uid = userid(optarg)) == (uid_t)-1)
				new_message(MT_delayed, "%s: unknown user",
				    optarg);
			else
				ps.huid = (uid_t)-1;
			break;

		case 'p': {	/* display only process id */
			const char *errstr;

			i = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr != NULL || !find_pid(i))
				new_message(MT_delayed, "%s: unknown pid",
				    optarg);
			else {
				ps.pid = (pid_t)i;
				ps.system = Yes;
			}
			break;
		}

		case 'S':	/* show system processes */
			ps.system = !ps.system;
			old_system = !old_system;
			break;

		case 'H':	/* show threads */
			ps.threads = Yes;
			old_threads = Yes;
			break;

		case 'I':	/* show idle processes */
			ps.idle = !ps.idle;
			break;

		case 'i':	/* go interactive regardless */
			interactive = Yes;
			break;

		case 'n':	/* batch, or non-interactive */
		case 'b':
			interactive = No;
			break;

		case 'd':	/* number of displays to show */
			if ((i = atoiwi(optarg)) != Invalid && i != 0) {
				displays = i;
				if (displays == 1)
					interactive = No;
				break;
			}
			new_message(MT_delayed,
			    "warning: display count should be positive "
			    "-- option ignored");
			break;

		case 's':
			delay = strtod(optarg, &endp);

			if (delay >= 0 && delay <= 1000000 && *endp == '\0')
				break;

			new_message(MT_delayed,
			    "warning: delay should be a non-negative number"
			    " -- using default");
			delay = Default_DELAY;
			break;

		case 'q':	/* be quick about it */
			/* only allow this if user is really root */
			if (getuid() == 0) {
				/* be very un-nice! */
				(void) nice(-20);
				break;
			}
			new_message(MT_delayed,
			    "warning: `-q' option can only be used by root");
			break;

		case 'o':	/* select sort order */
			order_name = optarg;
			break;

		case 'g':	/* grep command name */
			free(ps.command);
			if ((ps.command = strdup(optarg)) == NULL)
				err(1, NULL);
			break;

		default:
			usage();
			exit(1);
		}
	}

	i = getncpu();
	if (i == -1)
		err(1, NULL);

	if (i > 8)
		combine_cpus = 1;

	/* get count of top processes to display (if any) */
	if (optind < ac) {
		if ((topn = atoiwi(av[optind])) == Invalid) {
			new_message(MT_delayed,
			    "warning: process count should "
			    "be a non-negative number -- using default");
			topn = Infinity;
		}
#if Default_TOPN == Infinity
		else
			topn_specified = Yes;
#endif
	}
}

struct system_info system_info;
struct statics  statics;

int
main(int argc, char *argv[])
{
	char *uname_field = "USERNAME", *header_text, *env_top;
	char *(*get_userid)(uid_t) = username;
	char **preset_argv = NULL, **av = argv;
	int preset_argc = 0, ac = argc, active_procs, i;
	sigset_t mask, oldmask;
	time_t curr_time;
	caddr_t processes;

	/* set the buffer for stdout */
#ifdef DEBUG
	setvbuf(stdout, NULL, _IONBUF, 0);
#else
	setvbuf(stdout, stdoutbuf, _IOFBF, sizeof stdoutbuf);
#endif

	/* initialize some selection options */
	ps.idle = Yes;
	ps.system = No;
	ps.uid = (uid_t)-1;
	ps.huid = (uid_t)-1;
	ps.pid = (pid_t)-1;
	ps.command = NULL;

	/* get preset options from the environment */
	if ((env_top = getenv("TOP")) != NULL) {
		av = preset_argv = argparse(env_top, &preset_argc);
		ac = preset_argc;

		/*
		 * set the dummy argument to an explanatory message, in case
		 * getopt encounters a bad argument
		 */
		preset_argv[0] = "while processing environment";
	}
	/* process options */
	do {
		/*
		 * if we're done doing the presets, then process the real
		 * arguments
		 */
		if (preset_argc == 0) {
			ac = argc;
			av = argv;
			optind = 1;
		}
		parseargs(ac, av);
		i = preset_argc;
		preset_argc = 0;
	} while (i != 0);

	if (pledge("stdio rpath getpw tty proc ps vminfo", NULL) == -1)
		err(1, "pledge");

	/* set constants for username/uid display correctly */
	if (!do_unames) {
		uname_field = "   UID  ";
		get_userid = format_uid;
	}
	/* initialize the kernel memory interface */
	if (machine_init(&statics) == -1)
		exit(1);

	/* determine sorting order index, if necessary */
	if (order_name != NULL) {
		if ((order_index = string_index(order_name,
		    statics.order_names)) == -1) {
			char **pp, msg[512];

			snprintf(msg, sizeof(msg),
			    "'%s' is not a recognized sorting order",
			    order_name);
			strlcat(msg, ". Valid are:", sizeof(msg));
			pp = statics.order_names;
			while (*pp != NULL) {
				strlcat(msg, " ", sizeof(msg));
				strlcat(msg, *pp++, sizeof(msg));
			}
			new_message(MT_delayed, msg);
			order_index = 0;
		}
	}

	/* initialize termcap */
	init_termcap(interactive);

	/* initialize display interface */
	max_topn = display_init(&statics);

	/* print warning if user requested more processes than we can display */
	if (topn > max_topn)
		new_message(MT_delayed,
		    "warning: this terminal can only display %d processes",
		    max_topn);
	/* adjust for topn == Infinity */
	if (topn == Infinity) {
		/*
		 *  For smart terminals, infinity really means everything that can
		 *  be displayed, or Largest.
		 *  On dumb terminals, infinity means every process in the system!
		 *  We only really want to do that if it was explicitly specified.
		 *  This is always the case when "Default_TOPN != Infinity".  But if
		 *  topn wasn't explicitly specified and we are on a dumb terminal
		 *  and the default is Infinity, then (and only then) we use
		 *  "Nominal_TOPN" instead.
		 */
#if Default_TOPN == Infinity
		topn = smart_terminal ? Largest :
		    (topn_specified ? Largest : Nominal_TOPN);
#else
		topn = Largest;
#endif
	}
	/* set header display accordingly */
	display_header(topn > 0);

	/* determine interactive state */
	if (interactive == Maybe)
		interactive = smart_terminal;

	/* if # of displays not specified, fill it in */
	if (displays == 0)
		displays = smart_terminal ? Infinity : 1;

	/*
	 * block interrupt signals while setting up the screen and the
	 * handlers
	 */
	sigemptyset(&mask);
	sigaddset(&mask, SIGINT);
	sigaddset(&mask, SIGQUIT);
	sigaddset(&mask, SIGTSTP);
	sigprocmask(SIG_BLOCK, &mask, &oldmask);
	if (interactive)
		init_screen();
	(void) signal(SIGINT, leave);
	siginterrupt(SIGINT, 1);
	(void) signal(SIGQUIT, leave);
	(void) signal(SIGTSTP, tstop);
	if (smart_terminal)
		(void) signal(SIGWINCH, sigwinch);
	sigprocmask(SIG_SETMASK, &oldmask, NULL);
restart:

	/*
	 *  main loop -- repeat while display count is positive or while it
	 *		indicates infinity (by being -1)
	 */
	while ((displays == -1) || (displays-- > 0)) {
		if (winchflag) {
			/*
			 * reascertain the screen
			 * dimensions
			 */
			get_screensize();
			resizeterm(screen_length, screen_width + 1);

			/* tell display to resize */
			max_topn = display_resize();

			/* reset the signal handler */
			(void) signal(SIGWINCH, sigwinch);

			reset_display();
			winchflag = 0;
		}

		/* get the current stats */
		get_system_info(&system_info);

		/* get the current set of processes */
		processes = get_process_info(&system_info, &ps,
		    proc_compares[order_index]);

		/* display the load averages */
		i_loadave(system_info.last_pid, system_info.load_avg);

		/* display the current time */
		/* this method of getting the time SHOULD be fairly portable */
		time(&curr_time);
		i_timeofday(&curr_time);

		/* display process/threads state breakdown */
		i_procstates(system_info.p_total, system_info.procstates,
		    ps.threads);

		/* display the cpu state percentage breakdown */
		i_cpustates(system_info.cpustates);

		/* display memory stats */
		i_memory(system_info.memory);

		/* handle message area */
		i_message();

		/* get the string to use for the process area header */
		header_text = format_header(uname_field, ps.threads);

		/* update the header area */
		i_header(header_text);

		if (topn == Infinity) {
#if Default_TOPN == Infinity
			topn = smart_terminal ? Largest :
			    (topn_specified ? Largest : Nominal_TOPN);
#else
			topn = Largest;
#endif
		}

		if (topn > 0) {
			/* determine number of processes to actually display */
			/*
			 * this number will be the smallest of:  active
			 * processes, number user requested, number current
			 * screen accommodates
			 */
			active_procs = system_info.p_active;
			if (active_procs > topn)
				active_procs = topn;
			if (active_procs > max_topn)
				active_procs = max_topn;
			/* now show the top "n" processes. */
			for (i = 0; i < active_procs; i++) {
				pid_t pid;
				char * s;

				s = format_next_process(processes, get_userid,
				    &pid, ps.threads);
				i_process(i, s, pid == hlpid);
			}
		}

		/* do end-screen processing */
		u_endscreen();

		/* now, flush the output buffer */
		fflush(stdout);

		if (smart_terminal)
			refresh();

		/* only do the rest if we have more displays to show */
		if (displays) {
			/* switch out for new display on smart terminals */
			no_command = Yes;
			if (!interactive) {
				/* set up alarm */
				(void) signal(SIGALRM, onalrm);
				(void) alarm((unsigned) delay);

				/* wait for the rest of it .... */
				pause();
				if (leaveflag)
					exit(0);
				if (tstopflag) {
					(void) signal(SIGTSTP, SIG_DFL);
					(void) kill(0, SIGTSTP);
					/* reset the signal handler */
					(void) signal(SIGTSTP, tstop);
					tstopflag = 0;
				}
			} else {
				while (no_command)
					if (rundisplay())
						goto restart;
			}
		}
	}

	quit(0);
	/* NOTREACHED */
	return (0);
}

int
rundisplay(void)
{
	static char tempbuf[TEMPBUFSIZE];
	sigset_t mask;
	char ch, *iptr;
	int change, i;
	struct pollfd pfd[1];
	uid_t uid, huid;
	static char command_chars[] = "\f qh?en#sdkriIuSopCHg+P1";

	/*
	 * assume valid command unless told
	 * otherwise
	 */
	no_command = No;

	/*
	 * set up arguments for select with
	 * timeout
	 */
	pfd[0].fd = STDIN_FILENO;
	pfd[0].events = POLLIN;

	if (leaveflag)
		quit(0);
	if (tstopflag) {
		/* move to the lower left */
		end_screen();
		fflush(stdout);

		/*
		 * default the signal handler
		 * action
		 */
		(void) signal(SIGTSTP, SIG_DFL);

		/*
		 * unblock the signal and
		 * send ourselves one
		 */
		sigemptyset(&mask);
		sigaddset(&mask, SIGTSTP);
		sigprocmask(SIG_UNBLOCK, &mask, NULL);
		(void) kill(0, SIGTSTP);

		/* reset the signal handler */
		(void) signal(SIGTSTP, tstop);

		/* reinit screen */
		reinit_screen();
		reset_display();
		tstopflag = 0;
		return 1;
	}
	/*
	 * wait for either input or the end
	 * of the delay period
	 */
	if (poll(pfd, 1, (int)(delay * 1000)) > 0) {
		char *errmsg;
		ssize_t len;

		if ((pfd[0].revents & (POLLERR|POLLHUP|POLLNVAL)))
			exit(1);

		clear_message();

		/*
		 * now read it and convert to
		 * command strchr
		 */
		while (1) {
			len = read(STDIN_FILENO, &ch, 1);
			if (len == -1 && errno == EINTR)
				continue;
			if (len == 0)
				exit(1);
			break;
		}
		if ((iptr = strchr(command_chars, ch)) == NULL) {
			/* illegal command */
			new_message(MT_standout, " Command not understood");
			putr();
			no_command = Yes;
			fflush(stdout);
			return (0);
		}

		change = iptr - command_chars;

		switch (change) {
		case CMD_redraw:	/* redraw screen */
			reset_display();
			break;

		case CMD_update:	/* merely update display */
			/*
			 * is the load average high?
			 */
			if (system_info.load_avg[0] > LoadMax) {
				/* yes, go home for visual feedback */
				go_home();
				fflush(stdout);
			}
			break;

		case CMD_quit:	/* quit */
			quit(0);
			break;

		case CMD_help1:	/* help */
		case CMD_help2:
			clear();
			show_help();
			anykey();
			clear();
			break;

		case CMD_errors:	/* show errors */
			if (error_count() == 0) {
				new_message(MT_standout,
				    " Currently no errors to report.");
				putr();
				no_command = Yes;
			} else {
				clear();
				show_errors();
				anykey();
				clear();
			}
			break;

		case CMD_number1:	/* new number */
		case CMD_number2:
			new_message(MT_standout,
			    "Number of processes to show: ");

			if (readline(tempbuf, 8) > 0) {
				if ((i = atoiwi(tempbuf)) != Invalid) {
					if (i > max_topn) {
						new_message(MT_standout |
						    MT_delayed,
						    " This terminal can only "
						    "display %d processes.",
						    max_topn);
						putr();
					}
					if ((i > topn || i == Infinity)
					    && topn == 0) {
						/* redraw the header */
						display_header(Yes);
					} else if (i == 0)
						display_header(No);
					topn = i;
				} else {
					new_message(MT_standout,
					    "Processes should be a "
					    "non-negative number");
					putr();
					no_command = Yes;
				}
			} else
				clear_message();
			break;

		case CMD_delay:	/* new seconds delay */
			new_message(MT_standout, "Seconds to delay: ");
			if (readline(tempbuf, sizeof(tempbuf)) > 0) {
				char *endp;
				double newdelay = strtod(tempbuf, &endp);

				if (newdelay >= 0 && newdelay <= 1000000 &&
				    *endp == '\0') {
					delay = newdelay;
				} else {
					new_message(MT_standout,
					    "Delay should be a non-negative number");
					putr();
					no_command = Yes;
				}

			} else
				clear_message();
			break;

		case CMD_displays:	/* change display count */
			new_message(MT_standout,
			    "Displays to show (currently %s): ",
			    displays == -1 ? "infinite" :
			    itoa(displays));

			if (readline(tempbuf, 10) > 0) {
				if ((i = atoiwi(tempbuf)) != Invalid) {
					if (i == 0)
						quit(0);
					displays = i;
				} else {
					new_message(MT_standout,
					    "Displays should be a non-negative number");
					putr();
					no_command = Yes;
				}
			} else
				clear_message();
			break;

		case CMD_kill:	/* kill program */
			new_message(0, "kill ");
			if (readline(tempbuf, sizeof(tempbuf)) > 0) {
				if ((errmsg = kill_procs(tempbuf)) != NULL) {
					new_message(MT_standout, "%s", errmsg);
					putr();
					no_command = Yes;
				}
			} else
				clear_message();
			break;

		case CMD_renice:	/* renice program */
			new_message(0, "renice ");
			if (readline(tempbuf, sizeof(tempbuf)) > 0) {
				if ((errmsg = renice_procs(tempbuf)) != NULL) {
					new_message(MT_standout, "%s", errmsg);
					putr();
					no_command = Yes;
				}
			} else
				clear_message();
			break;

		case CMD_idletog:
		case CMD_idletog2:
			ps.idle = !ps.idle;
			new_message(MT_standout | MT_delayed,
			    " %sisplaying idle processes.",
			    ps.idle ? "D" : "Not d");
			putr();
			break;

		case CMD_user:
			new_message(MT_standout,
			    "Username to show: ");
			if (readline(tempbuf, sizeof(tempbuf)) > 0) {
				if ((tempbuf[0] == '+' || tempbuf[0] == '-') &&
				    tempbuf[1] == '\0') {
					ps.uid = (uid_t)-1;
					ps.huid = (uid_t)-1;
				} else if (tempbuf[0] == '-') {
					if ((huid = userid(tempbuf+1)) == (uid_t)-1) {
						new_message(MT_standout,
						    " %s: unknown user", tempbuf+1);
						no_command = Yes;
					} else {
						ps.huid = huid;
						ps.uid = (uid_t)-1;
					}
				} else if ((uid = userid(tempbuf)) == (uid_t)-1) {
						new_message(MT_standout,
						    " %s: unknown user", tempbuf);
						no_command = Yes;
				} else {
					ps.uid = uid;
					ps.huid = (uid_t)-1;
				}
				putr();
			} else
				clear_message();
			break;

		case CMD_system:
			ps.system = !ps.system;
			old_system = ps.system;
			new_message(MT_standout | MT_delayed,
			    " %sisplaying system processes.",
			    ps.system ? "D" : "Not d");
			break;

		case CMD_order:
			new_message(MT_standout,
			    "Order to sort: ");
			if (readline(tempbuf, sizeof(tempbuf)) > 0) {
				if ((i = string_index(tempbuf,
				    statics.order_names)) == -1) {
					new_message(MT_standout,
					    " %s: unrecognized sorting order",
					    tempbuf);
					no_command = Yes;
				} else
					order_index = i;
				putr();
			} else
				clear_message();
			break;

		case CMD_pid:
			new_message(MT_standout, "Process ID to show: ");
			if (readline(tempbuf, sizeof(tempbuf)) > 0) {
				if (tempbuf[0] == '+' &&
				    tempbuf[1] == '\0') {
					ps.pid = (pid_t)-1;
					ps.system = old_system;
				} else {
					unsigned long long num;
					const char *errstr;

					num = strtonum(tempbuf, 0, INT_MAX,
					    &errstr);
					if (errstr != NULL || !find_pid(num)) {
						new_message(MT_standout,
						    " %s: unknown pid",
						    tempbuf);
						no_command = Yes;
					} else {
						if (ps.system == No)
							old_system = No;
						ps.pid = (pid_t)num;
						ps.system = Yes;
					}
				}
				putr();
			} else
				clear_message();
			break;

		case CMD_command:
			show_args = (show_args == No) ? Yes : No;
			break;

		case CMD_threads:
			ps.threads = !ps.threads;
			old_threads = ps.threads;
			new_message(MT_standout | MT_delayed,
			    " %sisplaying threads.",
			    ps.threads ? "D" : "Not d");
			break;

		case CMD_grep:
			new_message(MT_standout,
			    "Grep command name: ");
			if (readline(tempbuf, sizeof(tempbuf)) > 0) {
				free(ps.command);
				if (tempbuf[0] == '+' &&
				    tempbuf[1] == '\0')
					ps.command = NULL;
				else
					if ((ps.command = strdup(tempbuf)) ==
					    NULL)
						err(1, NULL);
				putr();
			} else
				clear_message();
			break;

		case CMD_hl:
			new_message(MT_standout, "Process ID to highlight: ");
			if (readline(tempbuf, sizeof(tempbuf)) > 0) {
				if (tempbuf[0] == '+' &&
				    tempbuf[1] == '\0') {
					hlpid = -1;
				} else {
					unsigned long long num;
					const char *errstr;

					num = strtonum(tempbuf, 0, INT_MAX,
					    &errstr);
					if (errstr != NULL || !find_pid(num)) {
						new_message(MT_standout,
						    " %s: unknown pid",
						    tempbuf);
						no_command = Yes;
					} else
						hlpid = (pid_t)num;
				}
				putr();
			} else
				clear_message();
			break;

		case CMD_add:
			ps.uid = (uid_t)-1;	/* uid */
			ps.huid = (uid_t)-1;
			ps.pid = (pid_t)-1;	/* pid */
			ps.system = old_system;
			ps.command = NULL;	/* grep */
			hlpid = -1;
			break;
		case CMD_cpus:
			combine_cpus = !combine_cpus;
			max_topn = display_resize();
			reset_display();
			break;
		default:
			new_message(MT_standout, " BAD CASE IN SWITCH!");
			putr();
		}
	}

	/* flush out stuff that may have been written */
	fflush(stdout);
	return 0;
}


/*
 *  reset_display() - reset all the display routine pointers so that entire
 *	screen will get redrawn.
 */
static void
reset_display(void)
{
	if (smart_terminal) {
		clear();
		refresh();
	}
}

/* ARGSUSED */
void
leave(int signo)
{
	leaveflag = 1;
}

/* ARGSUSED */
void
tstop(int signo)
{
	tstopflag = 1;
}

/* ARGSUSED */
void
sigwinch(int signo)
{
	winchflag = 1;
}

/* ARGSUSED */
void
onalrm(int signo)
{
}

void
quit(int ret)
{
	end_screen();
	exit(ret);
}
@


1.88
log
@allow "kill" from top, by using proc instead of id
(event though the documentation does not yet state that proc allows
setpriority for renice)

Problem found by me, tweak suggested by theo buehler
Committed prompted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.87 2015/11/04 21:28:27 tedu Exp $	*/
d714 1
a714 1
 					putr();
d814 1
a814 1
					    	    " %s: unknown user", tempbuf);
d883 1
a883 1
		
d937 1
a937 1
			ps.pid = (pid_t)-1; 	/* pid */
@


1.87
log
@replace setbuf with setvbuf, from Frederic Nowak
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.86 2015/10/30 13:57:33 deraadt Exp $	*/
d331 1
a331 1
	if (pledge("stdio rpath getpw tty id ps vminfo", NULL) == -1)
@


1.86
log
@top renice command requires pledge "id", from Michael Lesniewski
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.85 2015/10/25 09:39:00 deraadt Exp $	*/
d291 1
a291 1
	setbuffer(stdout, NULL, 0);
d293 1
a293 1
	setbuffer(stdout, stdoutbuf, sizeof stdoutbuf);
@


1.85
log
@need "getpw" pledge; spotted by matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.84 2015/10/23 03:26:24 deraadt Exp $	*/
d331 1
a331 1
	if (pledge("stdio rpath getpw tty ps vminfo", NULL) == -1)
@


1.84
log
@With new pledge "ps" and "vminfo" requests, ps/top/w become possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.83 2015/05/06 07:53:29 mpi Exp $	*/
d331 1
a331 1
	if (pledge("abort stdio rpath tty ps vminfo", NULL) == -1)
@


1.83
log
@Display thread IDs instead of the name of the process's owner when "-H"
is used.

The rationnal is that when you're looking at threads you're generally
already filtereing by PID and this allow you to see which thread is a
pig.

Written some time ago with mikeb@@

ok sthen@@, krw@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.82 2014/09/17 01:56:54 dlg Exp $	*/
d330 3
@


1.82
log
@if there are more than 8 cpus, default to combined cpu stats (like
you passed -1 on the command line).

ok kettenis@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.81 2014/04/07 15:49:22 millert Exp $	*/
a362 3
	/* get the string to use for the process area header */
	header_text = format_header(uname_field);

d472 3
d505 1
a505 1
				    &pid);
@


1.81
log
@Just exit if we get an error or HUP when poll()ing the keyboard.
Otherwise, top may spin when its tty goes away.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.80 2013/01/14 21:33:59 guenther Exp $	*/
d252 7
@


1.80
log
@When showing threads, say so.  Fix up some comments and names at the same time.

original diff by zhuk@@
ok jsing@@ mpi@@ zhuk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.79 2012/06/08 13:41:16 lum Exp $	*/
d604 1
a604 2
	if (poll(pfd, 1, (int)(delay * 1000)) > 0 &&
	    !(pfd[0].revents & (POLLERR|POLLHUP|POLLNVAL))) {
d607 3
@


1.79
log
@Add checks for command line input (or the TOP environment var)
ommitted from 1.78.  Now a $ top -U -username -U username command will
behave the same as interactive mode. ok brynet@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.78 2012/06/05 18:52:53 brynet Exp $	*/
d455 3
a457 2
		/* display process state breakdown */
		i_procstates(system_info.p_total, system_info.procstates);
@


1.78
log
@Add support for hiding a user's processes in top.

feedback & ok lum@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.77 2012/04/20 16:36:11 pirofti Exp $	*/
d156 2
d161 2
@


1.77
log
@Silence warnings. Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.76 2011/12/16 14:50:24 jsing Exp $	*/
d129 1
a129 1
	    "[-p pid] [-s time]\n\t[-U user] [number]\n",
d152 5
a156 1
			if ((ps.uid = userid(optarg)) == (uid_t)-1)
d289 1
d548 1
a548 1
	uid_t uid;
d782 1
a782 1
				if (tempbuf[0] == '+' &&
d785 10
d796 4
a799 4
					new_message(MT_standout,
					    " %s: unknown user", tempbuf);
					no_command = Yes;
				} else
d801 2
d919 1
@


1.76
log
@Use H to make top show process threads, instead of the current T. This is
consistent with our ps(1) and top(1) on other operating systems.

ok deraadt@@ mikeb@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.74 2010/04/21 11:29:59 lum Exp $	*/
d267 3
a269 2
	char *(*get_userid)(uid_t) = username, **preset_argv, **av;
	int preset_argc = 0, ac, active_procs, i;
@


1.75
log
@delete two extra ; that got inserted somewhere along the line
@
text
@d128 1
a128 1
	    "usage: %s [-1bCIinqSTu] [-d count] [-g string] [-o field] "
d139 1
a139 1
	while ((i = getopt(ac, av, "1STICbinqus:d:p:U:o:g:")) != -1) {
d176 1
a176 1
		case 'T':	/* show threads */
d543 1
a543 1
	static char command_chars[] = "\f qh?en#sdkriIuSopCTg+P1";
@


1.74
log
@Handle a strdup failure.
ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.73 2010/03/26 16:56:00 lum Exp $	*/
d235 1
a235 1
			if((ps.command = strdup(optarg)) == NULL);
d866 2
a867 2
					if((ps.command = strdup(tempbuf)) ==
					    NULL);
@


1.73
log
@Remove unnecessary ptr.
ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.72 2010/03/23 16:16:09 lum Exp $	*/
d234 3
a236 1
			ps.command = strdup(optarg);
d866 3
a868 1
					ps.command = strdup(tempbuf);
@


1.72
log
@Fix pointer usage with the renice and kill error message structure. Pointer was used without allocating memory. ok beck@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.71 2010/03/22 12:20:25 lum Exp $	*/
d669 1
a669 3
				char *ptr;
				ptr = tempbuf;
				if ((i = atoiwi(ptr)) != Invalid) {
d723 1
a723 3
				char *ptr;
				ptr = tempbuf;				
				if ((i = atoiwi(ptr)) != Invalid) {
@


1.71
log
@make argument check for '-s' cli option and interactive 's' consistent. ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.70 2010/03/18 12:47:48 otto Exp $	*/
d535 1
a535 1
	static char tempbuf[50];
@


1.70
log
@While resizing, show correct CPU stats, from Mark Lumsden
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.69 2010/01/29 00:36:09 tedu Exp $	*/
d704 1
a704 1
				if (newdelay >= 0 && newdelay < 1000000 &&
@


1.69
log
@Allow sorting by command and pid.  Also, allow partial matches with strncmp.
ok jmc otto
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.68 2009/12/10 13:16:02 tedu Exp $	*/
d410 18
a584 18
		return 1;
	}
	if (winchflag) {
		/*
		 * reascertain the screen
		 * dimensions
		 */
		get_screensize();
		resizeterm(screen_length, screen_width + 1);

		/* tell display to resize */
		max_topn = display_resize();

		/* reset the signal handler */
		(void) signal(SIGWINCH, sigwinch);

		reset_display();
		winchflag = 0;
@


1.68
log
@add an option '1' to display all cpu stats combined.  helps save space
with increasing processor counts.
ok deraadt (kettenis otto)
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.67 2009/07/18 06:12:41 jmc Exp $	*/
d325 1
a325 1
			char **pp, msg[80];
@


1.67
log
@restore -S as toggle;

from Mark Lumsden
ok oga
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.66 2009/06/04 19:01:30 sthen Exp $	*/
d86 1
d120 1
d128 1
a128 1
	    "usage: %s [-bCIinqSTu] [-d count] [-g string] [-o field] "
d139 1
a139 1
	while ((i = getopt(ac, av, "STICbinqus:d:p:U:o:g:")) != -1) {
d141 3
a146 1

d523 1
a523 1
	static char command_chars[] = "\f qh?en#sdkriIuSopCTg+P";
d906 5
a910 1
		
@


1.66
log
@with -d1, switch interactive mode off, so the screen isn't restored
immediately afterwards on a smart terminal. found by claudio@@.
"I like that diff" deraadt "yes please!" phessler "I think that
makes sense" claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.65 2007/11/29 10:06:30 otto Exp $	*/
d168 2
a169 2
			ps.system = Yes;
			old_system = Yes;
@


1.65
log
@fix small glitch in displaying process list header; from Mark Lumsden
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.64 2007/11/27 13:19:16 otto Exp $	*/
d193 2
@


1.64
log
@use symbolic constant 'Infinity' instead of -1 where appropriate; from
Mark Lumsden
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.63 2007/11/22 11:01:04 otto Exp $	*/
d667 2
a668 1
						new_message(MT_standout | MT_delayed,
d673 2
a674 3
					} else if (i == 0)
						display_header(No);
					else if ((i > topn || i == Infinity) 
d678 2
a679 1
					}
d683 2
a684 1
					    "Processes should be a non-negative number");
@


1.63
log
@Diff from Mark Lumsden: cleanup of reading strings and numbers, to
make sure command line args and interactive reading of numbers use the
same code. More concrete, interactive use of 'd' and 'n' now also
interpret 'max', 'infinite' and 'all' and handle non-numbers
correctly. tested by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.62 2007/11/06 06:56:59 otto Exp $	*/
d674 2
a675 1
					else if ((i > topn || i == -1) && topn == 0) {
@


1.62
log
@prevent segv on wrong sort name; Mark Lumsden.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.61 2007/11/04 18:51:48 otto Exp $	*/
d434 9
a588 1
		int newval;
d661 23
a683 8
			newval = readline(tempbuf, 8, Yes);
			if (newval > -1) {
				if (newval > max_topn) {
					new_message(MT_standout | MT_delayed,
					    " This terminal can only "
					    "display %d processes.",
					    max_topn);
					putr();
d685 2
a686 8
				if (newval == 0)
					display_header(No);
				else if (newval > topn && topn == 0) {
					/* redraw the header */
					display_header(Yes);
				}
				topn = newval;
			}
d691 1
a691 1
			if (readline(tempbuf, sizeof(tempbuf), No) > 0) {
a713 4
			if ((i = readline(tempbuf, 10, Yes)) > 0)
				displays = i;
			else if (i == 0)
				quit(0);
d715 15
a729 1
			clear_message();
d734 1
a734 1
			if (readline(tempbuf, sizeof(tempbuf), No) > 0) {
d746 1
a746 1
			if (readline(tempbuf, sizeof(tempbuf), No) > 0) {
d768 1
a768 1
			if (readline(tempbuf, sizeof(tempbuf), No) > 0) {
d794 1
a794 1
			if (readline(tempbuf, sizeof(tempbuf), No) > 0) {
d810 1
a810 1
			if (readline(tempbuf, sizeof(tempbuf), No) > 0) {
d853 1
a853 1
			if (readline(tempbuf, sizeof(tempbuf), No) > 0) {
d867 1
a867 1
			if (readline(tempbuf, sizeof(tempbuf), No) > 0) {
@


1.61
log
@Also show warning message for -U and -p in message area; noted by Mark
Lumsden
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.60 2007/11/04 18:45:48 otto Exp $	*/
d331 1
@


1.60
log
@Get rid of the very annoying warning message + delay when a command
line argument is wrong. Just display the message in the message area.
ok deraadt@@ sobrado@@ simon@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.59 2007/11/01 19:25:32 otto Exp $	*/
d148 3
a150 4
			if ((ps.uid = userid(optarg)) == (uid_t)-1) {
				fprintf(stderr, "%s: unknown user\n", optarg);
				exit(1);
			}
d157 6
a162 3
			if (errstr != NULL || !find_pid(i)) {
				fprintf(stderr, "%s: unknown pid\n", optarg);
				exit(1);
a163 2
			ps.pid = (pid_t)i;
			ps.system = Yes;
@


1.59
log
@make check on -s and interactive s consistent; from Tilo Stritzky
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.58 2007/10/16 07:33:08 otto Exp $	*/
a77 1
char warnings = 0;
d195 2
a196 1
			warnx("warning: display count should be positive "
a197 1
			warnings++;
d206 2
a207 1
			warnx("warning: delay should be a non-negative number"
a209 1
			warnings++;
d219 2
a220 2
			warnx("warning: `-q' option can only be used by root");
			warnings++;
d240 2
a241 1
			warnx("warning: process count should "
a242 1
			warnings++;
d319 1
a319 1
			char **pp;
d321 2
a322 1
			warnx("'%s' is not a recognized sorting order",
d324 1
a324 1
			fprintf(stderr, "\tTry one of these:");
d326 5
a330 4
			while (*pp != NULL)
				fprintf(stderr, " %s", *pp++);
			fputc('\n', stderr);
			exit(1);
d344 3
a346 2
	if (topn > max_topn) {
		warnx("warning: this terminal can only display %d processes",
a347 2
		warnings++;
	}
a395 6
	if (warnings) {
		fputs("....", stderr);
		fflush(stderr);	/* why must I do this? */
		sleep((unsigned)(3 * warnings));
		fputc('\n', stderr);
	}
@


1.58
log
@Properly adjust headers displayed when the screen contains few lines.
Avoid a segv also. Problem reported by Mark Lumsden; inital diff by
me, further polishing by Mark. Tested by ray@@ canacar@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.57 2007/10/04 07:47:53 otto Exp $	*/
d204 1
a204 1
			if (delay > 0 && delay <= 1000000 && *endp == '\0')
@


1.57
log
@only init screen when in interactive mode; ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.56 2007/09/27 19:44:54 otto Exp $	*/
d340 2
a341 4
	if ((max_topn = display_init(&statics)) == -1) {
		warnx("can't allocate sufficient memory");
		exit(4);
	}
@


1.56
log
@No need to use two buffers for reading data from the user. From Mark
Lumsden; ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.55 2007/09/26 11:06:41 otto Exp $	*/
d389 2
a390 1
	init_screen();
@


1.55
log
@reuse available var, from Mark Lumsden
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.54 2007/09/18 11:15:25 otto Exp $	*/
d508 1
a508 1
	static char tempbuf1[50], tempbuf2[50];
d659 1
a659 1
			newval = readline(tempbuf1, 8, Yes);
d680 1
a680 1
			if (readline(tempbuf2, sizeof(tempbuf2), No) > 0) {
d682 1
a682 1
				double newdelay = strtod(tempbuf2, &endp);
d703 1
a703 1
			if ((i = readline(tempbuf1, 10, Yes)) > 0)
d713 2
a714 2
			if (readline(tempbuf2, sizeof(tempbuf2), No) > 0) {
				if ((errmsg = kill_procs(tempbuf2)) != NULL) {
d725 2
a726 2
			if (readline(tempbuf2, sizeof(tempbuf2), No) > 0) {
				if ((errmsg = renice_procs(tempbuf2)) != NULL) {
d747 3
a749 3
			if (readline(tempbuf2, sizeof(tempbuf2), No) > 0) {
				if (tempbuf2[0] == '+' &&
				    tempbuf2[1] == '\0') {
d751 1
a751 1
				} else if ((uid = userid(tempbuf2)) == (uid_t)-1) {
d753 1
a753 1
					    " %s: unknown user", tempbuf2);
d773 2
a774 3
			if (readline(tempbuf2,
			    sizeof(tempbuf2), No) > 0) {
				if ((i = string_index(tempbuf2,
d778 1
a778 1
					    tempbuf2);
d789 3
a791 3
			if (readline(tempbuf2, sizeof(tempbuf2), No) > 0) {
				if (tempbuf2[0] == '+' &&
				    tempbuf2[1] == '\0') {
d798 1
a798 1
					num = strtonum(tempbuf2, 0, INT_MAX,
d803 1
a803 1
						    tempbuf2);
d832 1
a832 1
			if (readline(tempbuf2, sizeof(tempbuf2), No) > 0) {
d834 2
a835 2
				if (tempbuf2[0] == '+' &&
				    tempbuf2[1] == '\0')
d838 1
a838 1
					ps.command = strdup(tempbuf2);
d846 3
a848 3
			if (readline(tempbuf2, sizeof(tempbuf2), No) > 0) {
				if (tempbuf2[0] == '+' &&
				    tempbuf2[1] == '\0') {
d854 1
a854 1
					num = strtonum(tempbuf2, 0, INT_MAX,
d859 1
a859 1
						    tempbuf2);
@


1.54
log
@redundant asignment; from Mark Lumsden
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.53 2007/09/10 10:48:01 otto Exp $	*/
a155 1
			unsigned long long num;
d158 2
a159 2
			num = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr != NULL || !find_pid(num)) {
d163 1
a163 1
			ps.pid = (pid_t)num;
@


1.53
log
@typo in message, from Mark Lumsden.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.52 2007/07/27 13:59:27 deraadt Exp $	*/
d462 1
a462 2
		} else
			i = 0;
@


1.52
log
@u_endscreen()'s argument is entirely unused; inspired by zinovik@@cs.karelia.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.51 2007/05/29 00:56:56 otto Exp $	*/
d848 1
a848 1
			new_message(MT_standout, "Process ID to higlight: ");
@


1.51
log
@Instead of using hand-crafted redraws minimizing screen updates, use curses.
Enables nice things like process highlighting without hurting the brain.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.50 2007/04/01 19:07:48 jmc Exp $	*/
d466 1
a466 1
		u_endscreen(i);
@


1.50
log
@tidy up usage(); partly from Mark Lumsden
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.49 2007/02/27 16:27:39 otto Exp $	*/
a30 2
const char	copyright[] = "Copyright (c) 1984 through 1996, William LeFebvre";

d32 1
a32 1
#include <sys/time.h>
a35 1
#include <ctype.h>
a41 1
#include <sys/stat.h>
a57 2
extern int	overstrike;

d62 1
a62 1
static void	winch(int);
a73 9
/* pointers to display routines */
void		(*d_loadave)(int, double *) = i_loadave;
void		(*d_procstates)(int, int *) = i_procstates;
void		(*d_cpustates)(int64_t *) = i_cpustates;
void		(*d_memory)(int *) = i_memory;
void		(*d_message)(void) = i_message;
void		(*d_header)(char *) = i_header;
void		(*d_process)(int, char *) = i_process;

d86 1
d119 1
d395 2
a396 1
	(void) signal(SIGWINCH, winch);
d419 1
a419 1
		(*d_loadave)(system_info.last_pid, system_info.load_avg);
d427 1
a427 1
		(*d_procstates)(system_info.p_total, system_info.procstates);
d430 1
a430 1
		(*d_cpustates)(system_info.cpustates);
d433 1
a433 1
		(*d_memory)(system_info.memory);
d436 1
a436 1
		(*d_message)();
d439 1
a439 1
		(*d_header)(header_text);
d454 8
a461 3
			for (i = 0; i < active_procs; i++)
				(*d_process)(i, format_next_process(processes,
				    get_userid));
d471 3
a476 13
			if (smart_terminal) {
				if (overstrike) {
					reset_display();
				} else {
					d_loadave = u_loadave;
					d_procstates = u_procstates;
					d_cpustates = u_cpustates;
					d_memory = u_memory;
					d_message = u_message;
					d_header = u_header;
					d_process = u_process;
				}
			}
d516 1
a516 1
	static char command_chars[] = "\f qh?en#sdkriIuSopCTg+";
d568 1
d574 1
a574 1
		(void) signal(SIGWINCH, winch);
d607 1
a607 2
			if (putchar('\r') == EOF)
				exit(1);
a613 10
		if (overstrike && change > CMD_OSLIMIT) {
			/* error */
			new_message(MT_standout,
			    " Command cannot be handled by this terminal");
			if (putchar('\r') == EOF)
				exit(1);
			no_command = Yes;
			fflush(stdout);
			return (0);
		}
a636 1
			reset_display();
d639 2
a640 10
			standout("Hit any key to continue: ");
			fflush(stdout);
			while (1) {
				len = read(STDIN_FILENO, &ch, 1);
				if (len == -1 && errno == EINTR)
					continue;
				if (len == 0)
					exit(1);
				break;
			}
d647 1
a647 2
				if (putchar('\r') == EOF)
					exit(1);
a649 1
				reset_display();
d652 2
a653 10
				standout("Hit any key to continue: ");
				fflush(stdout);
				while (1) {
					len = read(STDIN_FILENO, &ch, 1);
					if (len == -1 && errno == EINTR)
						continue;
					if (len == 0)
						exit(1);
					break;
				}
d668 1
a668 2
					if (putchar('\r') == EOF)
						exit(1);
a674 1
					d_header = i_header;
d692 1
a692 2
					if (putchar('\r') == EOF)
						exit(1);
d718 1
a718 2
					if (putchar('\r') == EOF)
						exit(1);
d730 1
a730 2
					if (putchar('\r') == EOF)
						exit(1);
d743 1
a743 2
			if (putchar('\r') == EOF)
				exit(1);
d759 1
a759 2
				if (putchar('\r') == EOF)
					exit(1);
d785 1
a785 2
				if (putchar('\r') == EOF)
					exit(1);
d815 1
a815 2
				if (putchar('\r') == EOF)
					exit(1);
d842 26
a867 2
				if (putchar('\r') == EOF)
					exit(1);
d877 1
d882 1
a882 2
			if (putchar('\r') == EOF)
				exit(1);
d899 4
a902 7
	d_loadave = i_loadave;
	d_procstates = i_procstates;
	d_cpustates = i_cpustates;
	d_memory = i_memory;
	d_message = i_message;
	d_header = i_header;
	d_process = i_process;
d921 1
a921 1
winch(int signo)
@


1.49
log
@an atoi() -> strtonum() conversion from Mark Lumsden; ok simon@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.48 2007/02/04 19:23:27 otto Exp $	*/
d140 2
a141 1
	    "usage: %s [-bCIinqSTu] [-d count] [-g command] [-o field] [-p pid] [-s time]\n\t[-U username] [number]\n",
@


1.48
log
@Complain of the user specifies a negative number for the 's' command.
From Mark Lumsden.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.47 2007/02/04 19:17:14 otto Exp $	*/
d254 2
a255 2
			warnx("warning: process display count should "
			    "be non-negative -- using default");
@


1.47
log
@Introducing the '+' interactive command to reset all filters.
From Mark Lumsden. ok millert@@ deraadt@@ simon@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.46 2007/02/04 15:01:11 otto Exp $	*/
d734 1
a734 1
				    *endp == '\0')
d736 10
a745 2
			}
			clear_message();
@


1.46
log
@actully use a default value when we say so. from Mark Lumsden
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.45 2007/01/03 18:57:49 otto Exp $	*/
d132 1
d532 1
a532 1
	static char command_chars[] = "\f qh?en#sdkriIuSopCTg";
d894 7
@


1.45
log
@Add a 'g' command to only show processes having a string in their
command name. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.44 2006/12/27 07:24:52 otto Exp $	*/
d256 1
@


1.44
log
@Also provide 'C' as a command line arg. From Mark Lumsden <mark at cyodesigns
dot com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.43 2006/03/04 06:58:12 otto Exp $	*/
d131 1
d139 1
a139 1
	    "usage: %s [-bCIinqSTu] [-d count] [-o field] [-p pid] [-s time] [-U username] [number]\n",
d149 1
a149 1
	while ((i = getopt(ac, av, "STICbinqus:d:p:U:o:")) != -1) {
d240 4
d530 1
a530 1
	static char command_chars[] = "\f qh?en#sdkriIuSopCT";
d874 16
@


1.43
log
@Show the CPU state %'s on first display as well. "looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.42 2006/03/04 06:54:18 otto Exp $	*/
d138 1
a138 1
	    "usage: %s [-bIinqSTu] [-d count] [-o field] [-p pid] [-s time] [-U username] [number]\n",
d148 1
a148 1
	while ((i = getopt(ac, av, "STIbinqus:d:p:U:o:")) != -1) {
d150 4
@


1.42
log
@Handle signals in non-interactive mode. "looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.41 2005/12/04 23:10:06 tedu Exp $	*/
a91 1
char dostates = No;
d430 1
a430 12
		if (dostates) {	/* but not the first time */
			(*d_cpustates)(system_info.cpustates);
		} else {
			/* we'll do it next time */
			if (smart_terminal)
				z_cpustates();
			else {
				if (putchar('\n') == EOF)
					exit(1);
			}
			dostates = Yes;
		}
@


1.41
log
@support for toggling thread viewing.
ok brad, hints from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.40 2005/06/17 09:40:48 markus Exp $	*/
d502 9
d548 2
a549 4
	if (leaveflag) {
		end_screen();
		exit(0);
	}
@


1.40
log
@add a 'C' command ) that toggles the display of the full cmdline;
with Jared Yanovich; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.39 2005/06/08 22:36:43 millert Exp $	*/
d100 1
d131 1
d139 1
a139 1
	    "usage: %s [-bIinqSu] [-d count] [-o field] [-p pid] [-s time] [-U username] [number]\n",
d149 1
a149 1
	while ((i = getopt(ac, av, "SIbinqus:d:p:U:o:")) != -1) {
d181 5
d524 1
a524 1
	static char command_chars[] = "\f qh?en#sdkriIuSopC";
d862 8
@


1.39
log
@Multi-cpu support for top.  Each cpu now gets its own stats line.
Based on work by todd@@ at the hackathon.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.38 2005/05/14 09:03:31 jmc Exp $	*/
d100 1
d129 1
d517 1
a517 1
	static char command_chars[] = "\f qh?en#sdkriIuSop";
d851 4
@


1.38
log
@sort options + sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.37 2005/05/13 20:43:30 jaredy Exp $	*/
d45 1
d83 1
a83 1
void		(*d_cpustates)(int *) = i_cpustates;
@


1.37
log
@grab bag of man page updates
- sync to reality (kill first BUG, WCPU field, and ABANDONED
  state and add WAIT field description)
- transform paragraph of field descriptions into a list
- minor mdoc, spelling, capitalization nits

ok & help jmc, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.36 2005/04/13 02:33:09 deraadt Exp $	*/
d134 1
a134 1
	    "usage: %s [-biInqSu] [-d count] [-o field] [-p pid] [-s time] [-U username] [number]\n",
@


1.36
log
@use STD{IN,OUT,ERR}_FILENO
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.35 2004/10/07 06:26:12 otto Exp $	*/
d820 1
a820 1
			new_message(MT_standout, "Process id to show: ");
@


1.35
log
@introduce -p option and p command to only show a single process.
From Patrick Latifi. ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.34 2004/09/14 22:55:48 deraadt Exp $	*/
d596 1
a596 1
			len = read(0, &ch, 1);
d653 1
a653 1
				len = read(0, &ch, 1);
d676 1
a676 1
					len = read(0, &ch, 1);
@


1.34
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.33 2004/05/09 22:16:26 deraadt Exp $	*/
d43 1
d98 1
d126 1
d134 1
a134 1
	    "usage: %s [-biInqSu] [-d count] [-o field] [-s time] [-U username] [number]\n",
d144 1
a144 1
	while ((i = getopt(ac, av, "SIbinqus:d:U:o:")) != -1) {
d157 14
d172 2
a173 1
			ps.system = !ps.system;
d270 1
d514 1
a514 1
	static char command_chars[] = "\f qh?en#sdkriIuSo";
d794 1
d813 31
@


1.33
log
@delint
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.32 2004/05/09 22:14:15 deraadt Exp $	*/
d828 1
d835 1
d842 1
d849 1
@


1.32
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.31 2004/05/07 19:19:49 millert Exp $	*/
d564 1
a564 1
	if (poll(pfd, 1, delay * 1000) > 0 &&
@


1.31
log
@Check poll revents for error.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.30 2003/11/01 20:20:57 deraadt Exp $	*/
d31 1
a31 1
const char      copyright[] = "Copyright (c) 1984 through 1996, William LeFebvre";
d58 1
a58 1
char            stdoutbuf[BUFFERSIZE];
d60 1
a60 1
extern int      overstrike;
d63 4
a66 4
static void     leave(int);
static void     onalrm(int);
static void     tstop(int);
static void     winch(int);
d70 1
a70 1
static void     reset_display(void);
d73 1
a73 1
static int      max_topn;	/* maximum displayable processes */
d75 1
a75 1
extern int      (*proc_compares[])(const void *, const void *);
d79 7
a85 7
void            (*d_loadave) (int, double *) = i_loadave;
void            (*d_procstates) (int, int *) = i_procstates;
void            (*d_cpustates) (int *) = i_cpustates;
void            (*d_memory) (int *) = i_memory;
void            (*d_message) (void) = i_message;
void            (*d_header) (char *) = i_header;
void            (*d_process) (int, char *) = i_process;
d119 2
a120 2
#define CMD_idletog     12
#define CMD_idletog2    13
d123 1
a123 1
#define CMD_order       16
d175 1
a175 1
			}				
d373 1
a373 1
		sleep((unsigned) (3 * warnings));
d403 1
a403 1
			(*d_cpustates) (system_info.cpustates);
d416 1
a416 1
		(*d_memory) (system_info.memory);
d419 1
a419 1
		(*d_message) ();
d422 1
a422 1
		(*d_header) (header_text);
@


1.30
log
@process signals at the right time.  also handle stdin failure better;
millert looked at it..
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.29 2003/09/19 10:32:24 jmc Exp $	*/
d564 2
a565 1
	if (poll(pfd, 1, delay * 1000) > 0) {
@


1.29
log
@commands.c: add `o' and `S' to internal help, sort options
top.1: sort options and SYNOPSIS
       add description of `o' (from Patrick Latifi)
top.c: sync usage() with SYNOPSIS

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.28 2003/08/21 08:14:50 deraadt Exp $	*/
d365 1
d566 1
d575 8
a582 1
		(void) read(0, &ch, 1);
d632 8
a639 1
			(void) read(0, &ch, 1);
d655 8
a662 1
				(void) read(0, &ch, 1);
@


1.28
log
@use poll
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.27 2003/07/07 21:36:52 deraadt Exp $	*/
d131 1
a131 1
	    "usage: %s [-ISbinqu] [-d x] [-s x] [-o field] [-U username] [number]\n",
@


1.27
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.26 2003/06/19 22:40:45 millert Exp $	*/
d41 1
a488 2
	struct timeval timeout;
	fd_set readfds;
d492 1
d506 2
a507 4
	FD_ZERO(&readfds);
	FD_SET(STDIN_FILENO, &readfds);
	timeout.tv_sec = (long) delay;
	timeout.tv_usec = (long) ((delay - timeout.tv_sec) * 1000000);
d563 1
a563 2
	if (select(STDIN_FILENO + 1, &readfds, (fd_set *) NULL,
	    (fd_set *) NULL, &timeout) > 0) {
@


1.26
log
@o get rid of strecpy() and use strlcpy() and/or snprintf() instead.
o make itoa() just use snprintf()
o rename itoa7() to format_uid() and use snprintf()
o max username len is _PW_NAME_LEN, not 8
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.25 2003/06/18 08:42:17 deraadt Exp $	*/
d78 7
a84 7
void            (*d_loadave) () = i_loadave;
void            (*d_procstates) () = i_procstates;
void            (*d_cpustates) () = i_cpustates;
void            (*d_memory) () = i_memory;
void            (*d_message) () = i_message;
void            (*d_header) () = i_header;
void            (*d_process) () = i_process;
d124 1
a124 1
void
d134 1
a134 1
void
d234 1
a234 1
	char *(*get_userid)() = username, **preset_argv, **av;
@


1.25
log
@SIGWINCH is always here
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.24 2003/06/18 08:36:31 deraadt Exp $	*/
d283 1
a283 1
		get_userid = itoa7;
@


1.24
log
@remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.23 2003/06/16 17:24:44 millert Exp $	*/
a64 1
#ifdef SIGWINCH
a65 1
#endif
d67 1
a67 3
volatile sig_atomic_t leaveflag;
volatile sig_atomic_t tstopflag;
volatile sig_atomic_t winchflag;
a365 1
#ifdef SIGWINCH
a366 1
#endif
a818 1
#ifdef SIGWINCH
a823 1
#endif
@


1.23
log
@Add missing #include <err.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.22 2003/06/16 01:09:02 deraadt Exp $	*/
a39 1
#include <setjmp.h>
a75 1
/* values which need to be accessed by signal handlers */
a77 3
/* miscellaneous things */
jmp_buf         jmp_int;

d99 1
a99 1
int no_command = 1;
@


1.22
log
@use warnx(); millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.21 2003/06/15 16:24:44 millert Exp $	*/
d34 3
a43 2
#include <errno.h>
#include <sys/time.h>
@


1.21
log
@use uid_t and fix some sign compare warnings; OK krw@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.20 2003/06/13 21:52:25 deraadt Exp $	*/
a81 4
/* routines that don't return int */

extern char *__progname;

d135 2
d138 2
a139 3
	    "Top version %s\n"
	    "Usage: %s [-ISbinqu] [-d x] [-s x] [-o field] [-U username] [number]\n",
	    version_string(), __progname);
d183 2
a184 4
			fprintf(stderr,
			    "%s: warning: display count should be positive "
			    "-- option ignored\n",
			    __progname);
d194 2
a195 4
			fprintf(stderr,
			    "%s: warning: delay should be a non-negative number"
			    " -- using default\n",
			    __progname);
d207 1
a207 3
			fprintf(stderr,
			    "%s: warning: `-q' option can only be used by root\n",
			    __progname);
d224 2
a225 4
			fprintf(stderr,
			    "%s: warning: process display count should "
			    "be non-negative -- using default\n",
			    __progname);
d303 2
a304 2
			fprintf(stderr, "%s: '%s' is not a recognized sorting order.\n",
			    __progname, order_name);
d322 1
a322 1
		fprintf(stderr, "%s: can't allocate sufficient memory\n", __progname);
d327 2
a328 3
		fprintf(stderr,
		    "%s: warning: this terminal can only display %d processes.\n",
		    __progname, max_topn);
@


1.20
log
@readable code
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.19 2003/06/12 22:30:23 pvalchev Exp $	*/
d158 1
a158 1
			if ((ps.uid = userid(optarg)) == -1) {
d269 1
a269 1
	ps.uid = -1;
d515 1
d761 2
a762 2
					ps.uid = -1;
				} else if ((i = userid(tempbuf2)) == -1) {
d767 1
a767 1
					ps.uid = i;
@


1.19
log
@cleanup; ok deraadt
@
text
@d1 1
a1 3
/*	$OpenBSD: top.c,v 1.18 2002/07/15 17:20:36 deraadt Exp $	*/

const char copyright[] = "Copyright (c) 1984 through 1996, William LeFebvre";
d31 1
a31 14
/*
 *  See the file "Changes" for information on version-to-version changes.
 */

/*
 *  This file contains "main" and other high-level routines.
 */

/*
 * The following preprocessor variables, when defined, are used to
 * distinguish between different Unix implementations:
 *
 *	FD_SET   - macros FD_SET and FD_ZERO are used when defined
 */
d54 1
a54 1
#define Buffersize	2048
d57 1
a57 1
char stdoutbuf[Buffersize];
d59 1
a59 2
/* imported from screen.c */
extern int overstrike;
d62 3
a64 3
static void leave(int);
static void onalrm(int);
static void tstop(int);
d66 1
a66 1
static void winch(int);
d73 2
a74 1
static void reset_display(void);
d77 1
a77 1
static int max_topn;		/* maximum displayable processes */
d80 1
a80 2
char *myname = "top";
jmp_buf jmp_int;
d84 1
a84 6
#ifdef ORDER
extern int (*proc_compares[])();
#else
extern int proc_compare();
#endif
time_t time();
d86 2
a87 1
caddr_t get_process_info();
d90 18
a107 7
void (*d_loadave)() = i_loadave;
void (*d_procstates)() = i_procstates;
void (*d_cpustates)() = i_cpustates;
void (*d_memory)() = i_memory;
void (*d_message)() = i_message;
void (*d_header)() = i_header;
void (*d_process)() = i_process;
a108 31

int
main(int argc, char *argv[])
{
    int i;
    int active_procs;
    int change;

    struct system_info system_info;
    struct statics statics;
    caddr_t processes;

    static char tempbuf1[50];
    static char tempbuf2[50];
    sigset_t mask, oldmask;
    int topn = Default_TOPN;
    double delay = Default_DELAY;
    int displays = 0;		/* indicates unspecified */
    time_t curr_time;
    char *(*get_userid)() = username;
    char *uname_field = "USERNAME";
    char *header_text;
    char *env_top;
    char **preset_argv;
    int  preset_argc = 0;
    char **av;
    int  ac;
    char dostates = No;
    char do_unames = Yes;
    char interactive = Maybe;
    char warnings = 0;
d110 1
a110 16
    char topn_specified = No;
#endif
    char ch;
    char *iptr;
    char no_command = 1;
    struct timeval timeout;
    struct process_select ps;
#ifdef ORDER
    char *order_name = NULL;
    int order_index = 0;
#endif
#ifndef FD_SET
    /* FD_SET and friends are not present:  fake it */
    typedef int fd_set;
#define FD_ZERO(x)     (*(x) = 0)
#define FD_SET(f, x)   (*(x) = f)
a111 1
    fd_set readfds;
d113 4
a116 6
#ifdef ORDER
    static char command_chars[] = "\f qh?en#sdkriIuSo";
#else
    static char command_chars[] = "\f qh?en#sdkriIuS";
#endif
/* these defines enumerate the "strchr"s of the commands in command_chars */
d122 2
a123 2
#define CMD_OSLIMIT	4    /* terminals with OS can only handle commands */
#define CMD_errors	5    /* less than or equal to CMD_OSLIMIT	   */
a133 1
#ifdef ORDER
a134 1
#endif
d136 27
a162 6
    /* set the buffer for stdout */
#ifdef DEBUG
    setbuffer(stdout, NULL, 0);
#else
    setbuffer(stdout, stdoutbuf, Buffersize);
#endif
d164 63
a226 55
    /* get our name */
    if (argc > 0)
    {
	if ((myname = strrchr(argv[0], '/')) == 0)
	{
	    myname = argv[0];
	}
	else
	{
	    myname++;
	}
    }

    /* initialize some selection options */
    ps.idle    = Yes;
    ps.system  = No;
    ps.uid     = -1;
    ps.command = NULL;

    /* get preset options from the environment */
    if ((env_top = getenv("TOP")) != NULL)
    {
	av = preset_argv = argparse(env_top, &preset_argc);
	ac = preset_argc;

	/* set the dummy argument to an explanatory message, in case
	   getopt encounters a bad argument */
	preset_argv[0] = "while processing environment";
    }

    /* process options */
    do {
	/* if we're done doing the presets, then process the real arguments */
	if (preset_argc == 0)
	{
	    ac = argc;
	    av = argv;

	    /* this should keep getopt happy... */
	    optind = 1;
	}

	while ((i = getopt(ac, av, "SIbinqus:d:U:o:")) != -1)
	{
	    switch(i)
	    {
	      case 'u':			/* toggle uid/username display */
		do_unames = !do_unames;
		break;

	      case 'U':			/* display only username's processes */
		if ((ps.uid = userid(optarg)) == -1)
		{
		    fprintf(stderr, "%s: unknown user\n", optarg);
		    exit(1);
d228 1
a228 1
		break;
d230 8
a237 24
	      case 'S':			/* show system processes */
		ps.system = !ps.system;
		break;

	      case 'I':                   /* show idle processes */
		ps.idle = !ps.idle;
		break;

	      case 'i':			/* go interactive regardless */
		interactive = Yes;
		break;

	      case 'n':			/* batch, or non-interactive */
	      case 'b':
		interactive = No;
		break;

	      case 'd':			/* number of displays to show */
		if ((i = atoiwi(optarg)) == Invalid || i == 0)
		{
		    fprintf(stderr,
			"%s: warning: display count should be positive -- option ignored\n",
			myname);
		    warnings++;
d239 1
d241 4
a244 4
		{
		    displays = i;
		}
		break;
d246 2
a247 16
	      case 's':
		{
		  char *endp;

		  delay = strtod(optarg, &endp);

		  if (delay < 0 || delay >= 1000000 || *endp != '\0')
		  {
		    fprintf(stderr,
			"%s: warning: delay should be a non-negative number -- using default\n",
			myname);
		    delay = Default_DELAY;
		    warnings++;
		  }
		}
		break;
d249 9
a257 15
	      case 'q':		/* be quick about it */
		/* only allow this if user is really root */
		if (getuid() == 0)
		{
		    /* be very un-nice! */
		    (void) nice(-20);
		}
		else
		{
		    fprintf(stderr,
			"%s: warning: `-q' option can only be used by root\n",
			myname);
		    warnings++;
		}
		break;
d259 3
a261 3
	      case 'o':		/* select sort order */
#ifdef ORDER
		order_name = optarg;
d263 1
a263 4
		fprintf(stderr,
			"%s: this platform does not support arbitrary ordering.  Sorry.\n",
			myname);
		warnings++;
a264 1
		break;
d266 40
a305 5
	      default:
		fprintf(stderr, "\
Top version %s\n\
Usage: %s [-ISbinqu] [-d x] [-s x] [-o field] [-U username] [number]\n",
			version_string(), myname);
d307 16
a322 1
	    }
d325 13
a337 5
	/* get count of top processes to display (if any) */
	if (optind < ac)
	{
	    if ((topn = atoiwi(av[optind])) == Invalid)
	    {
d339 2
a340 2
			"%s: warning: process display count should be non-negative -- using default\n",
			myname);
d342 13
a354 1
	    }
d356 4
a359 4
            else
	    {
		topn_specified = Yes;
	    }
d362 2
d365 3
a367 41
	/* tricky:  remember old value of preset_argc & set preset_argc = 0 */
	i = preset_argc;
	preset_argc = 0;

    /* repeat only if we really did the preset arguments */
    } while (i != 0);

    /* set constants for username/uid display correctly */
    if (!do_unames)
    {
	uname_field = "   UID  ";
	get_userid = itoa7;
    }

    /* initialize the kernel memory interface */
    if (machine_init(&statics) == -1)
    {
	exit(1);
    }

#ifdef ORDER
    /* determine sorting order index, if necessary */
    if (order_name != NULL)
    {
	if ((order_index = string_index(order_name, statics.order_names)) == -1)
	{
	    char **pp;

	    fprintf(stderr, "%s: '%s' is not a recognized sorting order.\n",
		    myname, order_name);
	    fprintf(stderr, "\tTry one of these:");
	    pp = statics.order_names;
	    while (*pp != NULL)
	    {
		fprintf(stderr, " %s", *pp++);
	    }
	    fputc('\n', stderr);
	    exit(1);
	}
    }
#endif
d369 3
a371 13
#ifdef no_initialization_needed
    /* initialize the hashing stuff */
    if (do_unames)
    {
	init_hash();
    }
#endif

    /* initialize termcap */
    init_termcap(interactive);

    /* get the string to use for the process area header */
    header_text = format_header(uname_field);
a372 19
    /* initialize display interface */
    if ((max_topn = display_init(&statics)) == -1)
    {
	fprintf(stderr, "%s: can't allocate sufficient memory\n", myname);
	exit(4);
    }
    
    /* print warning if user requested more processes than we can display */
    if (topn > max_topn)
    {
	fprintf(stderr,
		"%s: warning: this terminal can only display %d processes.\n",
		myname, max_topn);
	warnings++;
    }

    /* adjust for topn == Infinity */
    if (topn == Infinity)
    {
d374 2
a375 8
	 *  For smart terminals, infinity really means everything that can
	 *  be displayed, or Largest.
	 *  On dumb terminals, infinity means every process in the system!
	 *  We only really want to do that if it was explicitly specified.
	 *  This is always the case when "Default_TOPN != Infinity".  But if
	 *  topn wasn't explicitly specified and we are on a dumb terminal
	 *  and the default is Infinity, then (and only then) we use
	 *  "Nominal_TOPN" instead.
d377 9
a385 33
#if Default_TOPN == Infinity
	topn = smart_terminal ? Largest :
		    (topn_specified ? Largest : Nominal_TOPN);
#else
	topn = Largest;
#endif
    }

    /* set header display accordingly */
    display_header(topn > 0);

    /* determine interactive state */
    if (interactive == Maybe)
    {
	interactive = smart_terminal;
    }

    /* if # of displays not specified, fill it in */
    if (displays == 0)
    {
	displays = smart_terminal ? Infinity : 1;
    }

    /* block interrupt signals while setting up the screen and the handlers */
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);
    sigaddset(&mask, SIGQUIT);
    sigaddset(&mask, SIGTSTP);
    sigprocmask(SIG_BLOCK, &mask, &oldmask);
    init_screen();
    (void) signal(SIGINT, leave);
    (void) signal(SIGQUIT, leave);
    (void) signal(SIGTSTP, tstop);
d387 1
a387 1
    (void) signal(SIGWINCH, winch);
d389 7
a395 9
    sigprocmask(SIG_SETMASK, &oldmask, NULL);
    if (warnings)
    {
	fputs("....", stderr);
	fflush(stderr);			/* why must I do this? */
	sleep((unsigned)(3 * warnings));
	fputc('\n', stderr);
    }

d398 36
a433 19
    /*
     *  main loop -- repeat while display count is positive or while it
     *		indicates infinity (by being -1)
     */

    while ((displays == -1) || (displays-- > 0))
    {
	/* get the current stats */
	get_system_info(&system_info);

	/* get the current set of processes */
	processes =
		get_process_info(&system_info,
				 &ps,
#ifdef ORDER
				 proc_compares[order_index]);
#else
				 proc_compare);
#endif
d435 2
a436 67
	/* display the load averages */
	(*d_loadave)(system_info.last_pid,
		     system_info.load_avg);

	/* display the current time */
	/* this method of getting the time SHOULD be fairly portable */
	time(&curr_time);
	i_timeofday(&curr_time);

	/* display process state breakdown */
	(*d_procstates)(system_info.p_total,
			system_info.procstates);

	/* display the cpu state percentage breakdown */
	if (dostates)	/* but not the first time */
	{
	    (*d_cpustates)(system_info.cpustates);
	}
	else
	{
	    /* we'll do it next time */
	    if (smart_terminal)
	    {
		z_cpustates();
	    }
	    else
	    {
		if (putchar('\n') == EOF)
		    exit(1);
	    }
	    dostates = Yes;
	}

	/* display memory stats */
	(*d_memory)(system_info.memory);

	/* handle message area */
	(*d_message)();

	/* update the header area */
	(*d_header)(header_text);
    
	if (topn > 0)
	{
	    /* determine number of processes to actually display */
	    /* this number will be the smallest of:  active processes,
	       number user requested, number current screen accommodates */
	    active_procs = system_info.p_active;
	    if (active_procs > topn)
	    {
		active_procs = topn;
	    }
	    if (active_procs > max_topn)
	    {
		active_procs = max_topn;
	    }

	    /* now show the top "n" processes. */
	    for (i = 0; i < active_procs; i++)
	    {
		(*d_process)(i, format_next_process(processes, get_userid));
	    }
	}
	else
	{
	    i = 0;
	}
d438 2
a439 2
	/* do end-screen processing */
	u_endscreen(i);
d441 59
a499 2
	/* now, flush the output buffer */
	fflush(stdout);
d501 4
a504 47
	/* only do the rest if we have more displays to show */
	if (displays)
	{
	    /* switch out for new display on smart terminals */
	    if (smart_terminal)
	    {
		if (overstrike)
		{
		    reset_display();
		}
		else
		{
		    d_loadave = u_loadave;
		    d_procstates = u_procstates;
		    d_cpustates = u_cpustates;
		    d_memory = u_memory;
		    d_message = u_message;
		    d_header = u_header;
		    d_process = u_process;
		}
	    }
    
	    no_command = Yes;
	    if (!interactive)
	    {
		/* set up alarm */
		(void) signal(SIGALRM, onalrm);
		(void) alarm((unsigned)delay);
    
		/* wait for the rest of it .... */
		pause();
	    }
	    else while (no_command)
	    {
		/* assume valid command unless told otherwise */
		no_command = No;

		/* set up arguments for select with timeout */
		FD_ZERO(&readfds);
		FD_SET(STDIN_FILENO, &readfds);	/* for standard input */
		timeout.tv_sec  = (long)delay;
		timeout.tv_usec = (long)((delay - timeout.tv_sec) * 1000000);

		if (leaveflag) {
		    end_screen();
		    exit(0);
		}
d506 10
a515 23
		if (tstopflag) {
		    /* move to the lower left */
		    end_screen();
		    fflush(stdout);

		    /* default the signal handler action */
		    (void) signal(SIGTSTP, SIG_DFL);

		    /* unblock the signal and send ourselves one */
		    sigemptyset(&mask);
		    sigaddset(&mask, SIGTSTP);
		    sigprocmask(SIG_UNBLOCK, &mask, NULL);
		    (void) kill(0, SIGTSTP);

		    /* reset the signal handler */
		    (void) signal(SIGTSTP, tstop);

		    /* reinit screen */
		    reinit_screen();
		    reset_display();
		    tstopflag = 0;
		    goto restart;
		}
d517 5
a521 14
		if (winchflag) {
		    /* reascertain the screen dimensions */
		    get_screensize();

		    /* tell display to resize */
		    max_topn = display_resize();

		    /* reset the signal handler */
		    (void) signal(SIGWINCH, winch);

		    reset_display();
		    winchflag = 0;
		    goto restart;
		}
d523 76
a598 15
		/* wait for either input or the end of the delay period */
		if (select(STDIN_FILENO + 1, &readfds, (fd_set *)NULL,
		  (fd_set *)NULL, &timeout) > 0)
		{
		    int newval;
		    char *errmsg;
    
		    /* something to read -- clear the message area first */
		    clear_message();

		    /* now read it and convert to command strchr */
		    /* (use "change" as a temporary to hold strchr) */
		    (void) read(0, &ch, 1);
		    if ((iptr = strchr(command_chars, ch)) == NULL)
		    {
d602 1
a602 1
			    exit(1);
d604 8
a611 8
		    }
		    else
		    {
			change = iptr - command_chars;
			if (overstrike && change > CMD_OSLIMIT)
			{
			    /* error */
			    new_message(MT_standout,
d613 20
a632 3
			    if (putchar('\r') == EOF)
			        exit(1);
			    no_command = Yes;
d634 24
a657 23
			else switch(change)
			{
			    case CMD_redraw:	/* redraw screen */
				reset_display();
				break;
    
			    case CMD_update:	/* merely update display */
				/* is the load average high? */
				if (system_info.load_avg[0] > LoadMax)
				{
				    /* yes, go home for visual feedback */
				    go_home();
				    fflush(stdout);
				}
				break;
	    
			    case CMD_quit:	/* quit */
				quit(0);
				/*NOTREACHED*/
				break;
	    
			    case CMD_help1:	/* help */
			    case CMD_help2:
d660 1
a660 1
				show_help();
d664 10
a673 31
				break;
	
			    case CMD_errors:	/* show errors */
				if (error_count() == 0)
				{
				    new_message(MT_standout,
					" Currently no errors to report.");
				    if (putchar('\r') == EOF)
				        exit(1);
				    no_command = Yes;
				}
				else
				{
				    reset_display();
				    clear();
				    show_errors();
				    standout("Hit any key to continue: ");
				    fflush(stdout);
				    (void) read(0, &ch, 1);
				}
				break;
	
			    case CMD_number1:	/* new number */
			    case CMD_number2:
				new_message(MT_standout,
				    "Number of processes to show: ");
				newval = readline(tempbuf1, 8, Yes);
				if (newval > -1)
				{
				    if (newval > max_topn)
				    {
d675 3
a677 2
					  " This terminal can only display %d processes.",
					  max_topn);
d679 3
a681 6
					    exit(1);
				    }

				    if (newval == 0)
				    {
					/* inhibit the header */
d683 1
a683 3
				    }
				    else if (newval > topn && topn == 0)
				    {
a686 2
				    }
				    topn = newval;
d688 12
a699 10
				break;
	    
			    case CMD_delay:	/* new seconds delay */
				new_message(MT_standout, "Seconds to delay: ");
				if (readline(tempbuf2, sizeof(tempbuf2), No) > 0)
				{
				    char *endp;
				    double newdelay = strtod(tempbuf2, &endp);
				    if (newdelay >= 0 && newdelay < 1000000 && *endp == '\0')
				    {
d701 21
a721 27
				    }
				}
				clear_message();
				break;
	
			    case CMD_displays:	/* change display count */
				new_message(MT_standout,
					"Displays to show (currently %s): ",
					displays == -1 ? "infinite" :
							 itoa(displays));
				if ((i = readline(tempbuf1, 10, Yes)) > 0)
				{
				    displays = i;
				}
				else if (i == 0)
				{
				    quit(0);
				}
				clear_message();
				break;
    
			    case CMD_kill:	/* kill program */
				new_message(0, "kill ");
				if (readline(tempbuf2, sizeof(tempbuf2), No) > 0)
				{
				    if ((errmsg = kill_procs(tempbuf2)) != NULL)
				    {
d724 1
a724 1
					    exit(1);
a725 1
				    }
d727 8
a734 12
				else
				{
				    clear_message();
				}
				break;
	    
			    case CMD_renice:	/* renice program */
				new_message(0, "renice ");
				if (readline(tempbuf2, sizeof(tempbuf2), No) > 0)
				{
				    if ((errmsg = renice_procs(tempbuf2)) != NULL)
				    {
d737 1
a737 1
					    exit(1);
a738 1
				    }
d740 3
a742 5
				else
				{
				    clear_message();
				}
				break;
d744 9
a752 9
			    case CMD_idletog:
			    case CMD_idletog2:
				ps.idle = !ps.idle;
				new_message(MT_standout | MT_delayed,
				    " %sisplaying idle processes.",
				    ps.idle ? "D" : "Not d");
				if (putchar('\r') == EOF)
				    exit(1);
				break;
d754 6
a759 8
			    case CMD_user:
				new_message(MT_standout,
				    "Username to show: ");
				if (readline(tempbuf2, sizeof(tempbuf2), No) > 0)
				{
				    if (tempbuf2[0] == '+' &&
					tempbuf2[1] == '\0')
				    {
d761 1
a761 3
				    }
				    else if ((i = userid(tempbuf2)) == -1)
				    {
d765 1
a765 3
				    }
				    else
				    {
d767 5
a771 9
				    }
				    if (putchar('\r') == EOF)
				        exit(1);
				}
				else
				{
				    clear_message();
				}
				break;
d773 19
a791 21
			    case CMD_system:
				ps.system = !ps.system;
				new_message(MT_standout | MT_delayed,
				    " %sisplaying system processes.",
				    ps.system ? "D" : "Not d");
				break;

#ifdef ORDER
			    case CMD_order:
				new_message(MT_standout,
				    "Order to sort: ");
				if (readline(tempbuf2, sizeof(tempbuf2), No) > 0)
				{
				  if ((i = string_index(tempbuf2, statics.order_names)) == -1)
					{
					  new_message(MT_standout,
					      " %s: unrecognized sorting order", tempbuf2);
					  no_command = Yes;
				    }
				    else
				    {
a792 13
				    }
				    if (putchar('\r') == EOF)
				        exit(1);
				}
				else
				{
				    clear_message();
				}
				break;
#endif
	    
			    default:
				new_message(MT_standout, " BAD CASE IN SWITCH!");
d794 4
a797 3
				    exit(1);
			}
		    }
d799 4
a802 2
		    /* flush out stuff that may have been written */
		    fflush(stdout);
a803 1
	    }
a804 1
    }
d806 3
a808 3
    quit(0);
    /*NOTREACHED*/
    return(0);
d811 1
a815 1

d819 7
a825 7
    d_loadave    = i_loadave;
    d_procstates = i_procstates;
    d_cpustates  = i_cpustates;
    d_memory     = i_memory;
    d_message	 = i_message;
    d_header	 = i_header;
    d_process	 = i_process;
a827 4
/*
 *  signal handlers
 */

d829 1
a829 1
leave(int unused)	/* exit under normal conditions -- INT handler */
d831 1
a831 1
    leaveflag = 1;
d835 1
a835 1
tstop(int i)	/* SIGTSTP handler */
d837 1
a837 1
    tstopflag = 1;
d842 1
a842 1
winch(int i)		/* SIGWINCH handler */
d844 1
a844 1
    winchflag = 1;
d849 1
a849 1
quit(int status)		/* exit under duress */
a850 3
    end_screen();
    exit(status);
    /*NOTREACHED*/
d854 1
a854 1
onalrm(int unused)	/* SIGALRM handler */
d856 2
a857 2
    /* this is only used in batch mode to break out of the pause() */
    /* return; */
a858 1

@


1.18
log
@license change from William LeFebvre <wnl@@groupsys.com>; top is now BSD
licensed.  this same license will show up on his next release as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.17 2002/06/14 21:35:00 todd Exp $	*/
d119 2
a120 5
int main(argc, argv)

int  argc;
char *argv[];

d953 2
a954 2
static void reset_display()

d969 2
a970 4
void leave(unused)	/* exit under normal conditions -- INT handler */

int unused;

d975 2
a976 4
void tstop(i)	/* SIGTSTP handler */

int i;

d982 2
a983 4
void winch(i)		/* SIGWINCH handler */

int i;

d989 2
a990 4
void quit(status)		/* exit under duress */

int status;

d997 2
a998 4
void onalrm(unused)	/* SIGALRM handler */

int unused;

@


1.17
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.16 2002/04/21 18:52:33 hugh Exp $	*/
d9 2
a10 2
 *  This program may be freely redistributed,
 *  but this entire comment MUST remain intact.
d12 19
a30 2
 *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
 *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
@


1.16
log
@Add support for fractional delay values. Useful for fast updates
without spinning top. Cleared by millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.15 2002/02/16 21:27:55 millert Exp $	*/
d547 1
a547 1
	       number user requested, number current screen accomodates */
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.14 2001/11/19 19:02:17 mpech Exp $	*/
d120 1
a120 1
    int delay = Default_DELAY;
d282 3
a284 2
		  delay = strtoul(optarg, &endp, 10);
		  if (delay < 0 || *endp != '\0')
d287 1
a287 1
			"%s: warning: seconds delay should be non-negative -- using default\n",
d615 2
a616 2
		timeout.tv_sec  = delay;
		timeout.tv_usec = 0;
d779 1
a779 1
				if ((i = readline(tempbuf1, 8, Yes)) > -1)
d781 6
a786 1
				    delay = i;
@


1.14
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.13 2001/11/17 19:57:36 deraadt Exp $	*/
d61 3
a63 3
static void leave __P((int));
static void onalrm __P((int));
static void tstop __P((int));
d65 1
a65 1
static void winch __P((int));
d72 1
a72 1
static void reset_display __P((void));
@


1.13
log
@volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.12 2001/11/11 01:48:58 fgsch Exp $	*/
d108 3
a110 3
    register int i;
    register int active_procs;
    register int change;
@


1.12
log
@Add 'S' to interactive mode to toggle the display of system
processes; From NetBSD.
millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.11 2001/09/05 06:25:39 deraadt Exp $	*/
d68 3
a70 3
sig_atomic_t leaveflag;
sig_atomic_t tstopflag;
sig_atomic_t winchflag;
@


1.11
log
@select correctly, and on the right file descriptors too!
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.10 2001/09/04 23:35:59 millert Exp $	*/
d156 1
a156 1
    static char command_chars[] = "\f qh?en#sdkriIuo";
d158 1
a158 1
    static char command_chars[] = "\f qh?en#sdkriIu";
d177 1
d179 1
a179 1
#define CMD_order       15
d875 8
a882 1
	    
@


1.10
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.9 2001/07/27 17:13:42 deraadt Exp $	*/
d612 1
a612 1
		FD_SET(1, &readfds);		/* for standard input */
d661 2
a662 1
		if (select(32, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timeout) > 0)
@


1.9
log
@abort if stdout use ever produces EOF.  before, top was one of those nasty
processes that could spin if it's output tty went away in some cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.8 2001/07/17 02:23:58 pvalchev Exp $	*/
a27 2
 *	SIGHOLD  - use SVR4 sighold function when defined
 *	SIGRELSE - use SVR4 sigrelse function when defined
a56 3
/* build Signal masks */
#define Smask(s)	(1 << ((s) - 1))

d118 1
a118 1
    int old_sigmask;		/* only used for BSD-style signals */
d455 6
a460 8
    /* hold interrupt signals while setting up the screen and the handlers */
#ifdef SIGHOLD
    sighold(SIGINT);
    sighold(SIGQUIT);
    sighold(SIGTSTP);
#else
    old_sigmask = sigblock(Smask(SIGINT) | Smask(SIGQUIT) | Smask(SIGTSTP));
#endif
d468 1
a468 7
#ifdef SIGRELSE
    sigrelse(SIGINT);
    sigrelse(SIGQUIT);
    sigrelse(SIGTSTP);
#else
    (void) sigsetmask(old_sigmask);
#endif
d630 3
a632 5
#ifdef SIGRELSE
		    sigrelse(SIGTSTP);
#else
		    (void) sigsetmask(sigblock(0) & ~(1 << (SIGTSTP - 1)));
#endif
@


1.8
log
@-Wall cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.7 2001/01/18 07:29:28 deraadt Exp $	*/
d539 2
a540 1
		putchar('\n');
d691 2
a692 1
			putchar('\r');
d703 2
a704 1
			    putchar('\r');
d743 2
a744 1
				    putchar('\r');
d770 2
a771 1
					putchar('\r');
d821 2
a822 1
					putchar('\r');
d839 2
a840 1
					putchar('\r');
d856 2
a857 1
				putchar('\r');
d880 2
a881 1
				    putchar('\r');
d905 2
a906 1
				    putchar('\r');
d917 2
a918 1
				putchar('\r');
@


1.7
log
@remove signal races, using flags
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.6 2000/12/22 22:46:57 deraadt Exp $	*/
d920 1
@


1.6
log
@use strtoul() instead of atoi()
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.5 2000/11/21 07:22:19 deraadt Exp $	*/
d73 4
d490 1
a490 6
    /* setup the jump buffer for stops */
    if (setjmp(jmp_int) != 0)
    {
	/* control ends up here after an interrupt */
	reset_display();
    }
d628 46
d948 1
a948 2
    end_screen();
    exit(0);
d956 1
a956 29
    int save_errno = errno;

    /* move to the lower left */
    end_screen();
    fflush(stdout);

    /* default the signal handler action */
    (void) signal(SIGTSTP, SIG_DFL);

    /* unblock the signal and send ourselves one */
#ifdef SIGRELSE
    sigrelse(SIGTSTP);
#else
    (void) sigsetmask(sigblock(0) & ~(1 << (SIGTSTP - 1)));
#endif
    (void) kill(0, SIGTSTP);

    /* reset the signal handler */
    (void) signal(SIGTSTP, tstop);

    /* reinit screen */
    reinit_screen();

    errno = save_errno;

    /* jump to appropriate place */
    longjmp(jmp_int, 1);

    /*NOTREACHED*/
d965 1
a965 15
    int save_errno = errno;

    /* reascertain the screen dimensions */
    get_screensize();

    /* tell display to resize */
    max_topn = display_resize();

    /* reset the signal handler */
    (void) signal(SIGWINCH, winch);

    errno = save_errno;

    /* jump to appropriate place */
    longjmp(jmp_int, 1);
@


1.5
log
@errno saving inside really crummy signal handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.4 2000/10/04 21:19:38 millert Exp $	*/
a278 1
		if ((delay = atoi(optarg)) < 0)
d280 5
d290 1
@


1.4
log
@Fixes a format string error in the kill (k) command; vort@@wiretapped.net
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.3 1999/05/23 17:19:21 aaron Exp $	*/
d41 1
d907 2
d930 2
d944 2
d954 2
@


1.3
log
@getopt(3) returns -1, not EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.2 1997/08/22 07:16:30 downsj Exp $	*/
d764 1
a764 1
					new_message(MT_standout, errmsg);
d781 1
a781 1
					new_message(MT_standout, errmsg);
@


1.3.4.1
log
@Pull in patch from current:
Fix (millert):
Fixes a format string error in the kill (k) command; vort@@wiretapped.net
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.3 1999/05/23 17:19:21 aaron Exp $	*/
d764 1
a764 1
					new_message(MT_standout, "%s", errmsg);
d781 1
a781 1
					new_message(MT_standout, "%s", errmsg);
@


1.2
log
@First sweep.  Prototype, type fixes, long fixes, mostly compiles with
-Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: top.c,v 1.1 1997/08/14 14:00:26 downsj Exp $	*/
d230 1
a230 1
	while ((i = getopt(ac, av, "SIbinqus:d:U:o:")) != EOF)
@


1.1
log
@top 3.4, with a few changes.  Still needs more work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
a3 2
char *copyright =
    "Copyright (c) 1984 through 1996, William LeFebvre";
d33 3
a35 1
#include "os.h"
d38 3
a40 1
#include <ctype.h>
a60 7
/* for system errors */
extern int errno;

/* for getopt: */
extern int  optind;
extern char *optarg;

d65 3
a67 3
sigret_t leave();
sigret_t onalrm();
sigret_t tstop();
d69 1
a69 1
sigret_t winch();
d72 1
a72 2
/* internal routines */
void quit();
a82 5
char *username();
char *ctime();
char *kill_procs();
char *renice_procs();

a91 21
/* different routines for displaying the user's identification */
/* (values assigned to get_userid) */
char *username();
char *itoa7();

/* display routines that need to be predeclared */
int i_loadave();
int u_loadave();
int i_procstates();
int u_procstates();
int i_cpustates();
int u_cpustates();
int i_memory();
int u_memory();
int i_message();
int u_message();
int i_header();
int u_header();
int i_process();
int u_process();

d93 7
a99 7
int (*d_loadave)() = i_loadave;
int (*d_procstates)() = i_procstates;
int (*d_cpustates)() = i_cpustates;
int (*d_memory)() = i_memory;
int (*d_message)() = i_message;
int (*d_header)() = i_header;
int (*d_process)() = i_process;
d102 1
a102 1
main(argc, argv)
d876 1
a876 1
reset_display()
d892 3
a894 1
sigret_t leave()	/* exit under normal conditions -- INT handler */
d901 1
a901 1
sigret_t tstop(i)	/* SIGTSTP handler */
d934 1
a934 1
sigret_t winch(i)		/* SIGWINCH handler */
d963 3
a965 1
sigret_t onalrm()	/* SIGALRM handler */
@
