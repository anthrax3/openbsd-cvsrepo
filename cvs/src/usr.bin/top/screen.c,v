head	1.21;
access;
symbols
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.28
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.24
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.26
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.18
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.22
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.20
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.16
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.14
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.12
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.6
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.18.0.6
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.14.0.12
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.10
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.8
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.8
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.21
date	2017.03.15.04.24.14;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	oL4eFXBEzCBQNxCU;

1.20
date	2010.02.05.10.21.10;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.24.18.53.55;	author chl;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.10.19.10.06;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.29.00.56.56;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.04.19.12.15;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.30.19.21.19;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.09.22.14.15;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.16.17.24.44;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.16.01.09.02;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.13.21.52.25;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.12.23.09.30;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.12.22.30.23;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.15.17.20.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.27.17.13.42;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.04.26.01.34.04;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.12.02.17.56.30;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	97.09.16.19.25.00;	author weingart;	state Exp;
branches;
next	1.3;

1.3
date	97.08.24.18.37.47;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.08.22.07.16.29;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.08.14.14.00.24;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.21
log
@annoying whitespace die die die
@
text
@/* $OpenBSD: screen.c,v 1.20 2010/02/05 10:21:10 otto Exp $	 */

/*
 *  Top users/processes display for Unix
 *  Version 3
 *
 * Copyright (c) 1984, 1989, William LeFebvre, Rice University
 * Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS EMPLOYER BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This file contains the routines that interface to termcap and stty/gtty.
 *
 * Paul Vixie, February 1987: converted to use ioctl() instead of stty/gtty.
 *
 * I put in code to turn on the TOSTOP bit while top was running, but I didn't
 * really like the results.  If you desire it, turn on the preprocessor
 * variable "TOStop".   --wnl
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <curses.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <term.h>
#include <unistd.h>

#include "top.h"
#include "screen.h"
#include "layout.h"
#include "boolean.h"

int	screen_length, screen_width;
char	ch_erase, ch_kill, smart_terminal;

static struct termios old_settings, new_settings;
static char is_a_terminal = No;

void
init_termcap(int interactive)
{
	char *term_name;
	int status;

	/* set defaults in case we aren't smart */
	screen_width = MAX_COLS;
	screen_length = 0;

	if (!interactive) {
		/* pretend we have a dumb terminal */
		smart_terminal = No;
		return;
	}
	/* assume we have a smart terminal until proven otherwise */
	smart_terminal = Yes;

	/* get the terminal name */
	term_name = getenv("TERM");

	/* if there is no TERM, assume it's a dumb terminal */
	/* patch courtesy of Sam Horrocks at telegraph.ics.uci.edu */
	if (term_name == NULL) {
		smart_terminal = No;
		return;
	}

	/* now get the termcap entry */
	if ((status = tgetent(NULL, term_name)) != 1) {
		if (status == -1)
			warnx("can't open termcap file");
		else
			warnx("no termcap entry for a `%s' terminal", term_name);

		/* pretend it's dumb and proceed */
		smart_terminal = No;
		return;
	}

	/* "hardcopy" immediately indicates a very stupid terminal */
	if (tgetflag("hc")) {
		smart_terminal = No;
		return;
	}

	/* set up common terminal capabilities */
	if ((screen_length = tgetnum("li")) <= y_procs) {
		screen_length = smart_terminal = 0;
		return;
	}

	/* screen_width is a little different */
	if ((screen_width = tgetnum("co")) == -1)
		screen_width = 79;
	else
		screen_width -= 1;

	/* get necessary capabilities */
	if (tgetstr("cl", NULL) == NULL || tgetstr("cm", NULL) == NULL) {
		smart_terminal = No;
		return;
	}

	/* get the actual screen size with an ioctl, if needed */
	/*
	 * This may change screen_width and screen_length, and it always sets
	 * lower_left.
	 */
	get_screensize();

	/* if stdout is not a terminal, pretend we are a dumb terminal */
	if (tcgetattr(STDOUT_FILENO, &old_settings) == -1)
		smart_terminal = No;
}

void
init_screen(void)
{
	/* get the old settings for safe keeping */
	if (tcgetattr(STDOUT_FILENO, &old_settings) != -1) {
		/* copy the settings so we can modify them */
		new_settings = old_settings;
		/* turn off ICANON, character echo and tab expansion */
		new_settings.c_lflag &= ~(ICANON | ECHO);
		new_settings.c_oflag &= ~(OXTABS);
		new_settings.c_cc[VMIN] = 1;
		new_settings.c_cc[VTIME] = 0;

		(void) tcsetattr(STDOUT_FILENO, TCSADRAIN, &new_settings);
		/* remember the erase and kill characters */
		ch_erase = old_settings.c_cc[VERASE];
		ch_kill = old_settings.c_cc[VKILL];

		is_a_terminal = Yes;
#if 0
		/* send the termcap initialization string */
		putcap(terminal_init);
#endif
	}
	if (!is_a_terminal) {
		/* not a terminal at all---consider it dumb */
		smart_terminal = No;
	}

	if (smart_terminal)
		initscr();
}

void
end_screen(void)
{
	if (smart_terminal) {
		move(screen_length-1, 0);
		clrtoeol();
		refresh();
		endwin();
	}
	if (is_a_terminal)
		(void) tcsetattr(STDOUT_FILENO, TCSADRAIN, &old_settings);
}

void
reinit_screen(void)
{
#if 0
	/* install our settings if it is a terminal */
	if (is_a_terminal)
		(void) tcsetattr(STDOUT_FILENO, TCSADRAIN, &new_settings);

	/* send init string */
	if (smart_terminal)
		putcap(terminal_init);
#endif
}

void
get_screensize(void)
{
	struct winsize ws;

	if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) != -1) {
		if (ws.ws_row != 0)
			screen_length = ws.ws_row;
		if (ws.ws_col != 0)
			screen_width = ws.ws_col - 1;
	}
}

void
go_home(void)
{
	if (smart_terminal) {
		move(0, 0);
		refresh();
	}
}
@


1.20
log
@Header_lines always has the same value as y_procs; so zap the former;
from Mark Lumsden.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.19 2008/09/24 18:53:55 chl Exp $	 */
d119 5
a123 5
        /* get necessary capabilities */
        if (tgetstr("cl", NULL) == NULL || tgetstr("cm", NULL) == NULL) {
                smart_terminal = No;
                return;
        }
@


1.19
log
@remove unused function

from tobias@@

ok otto@@ tobias@@
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.18 2007/06/10 19:10:06 otto Exp $	 */
d52 1
d108 1
a108 1
	if ((screen_length = tgetnum("li")) <= Header_lines) {
@


1.18
log
@clear to end of line at quit, needed for terms that do not restore
content on quiting curses mode, like screen. found and tested by ray@@
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.17 2007/05/29 00:56:56 otto Exp $	 */
a215 12
}

/* This has to be defined as a subroutine for tputs (instead of a macro) */
int
putstdout(int ch)
{
	int ret;

	ret = putchar(ch);
	if (ret == EOF)
		exit(1);
	return (ret);
@


1.17
log
@Instead of using hand-crafted redraws minimizing screen updates, use curses.
Enables nice things like process highlighting without hurting the brain.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.16 2007/04/04 19:12:15 otto Exp $	 */
d172 4
a175 1
	if (smart_terminal)
d177 1
@


1.16
log
@garbage collect unused var ospeed; from Mark Lumsden
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.15 2007/03/30 19:21:19 otto Exp $	 */
d43 1
a46 1
#include <string.h>
d54 2
a55 6
int	overstrike, screen_length, screen_width;
char	ch_erase, ch_kill, smart_terminal, PC;
char	string_buffer[1024], home[15], lower_left[15];
char	*clear_line, *clear_scr, *clear_to_end;
char	*cursor_motion, *start_standout, *end_standout;
char	*terminal_init, *terminal_end;
d58 1
a58 2

static char	is_a_terminal = No;
d63 1
a63 1
	char *bufptr, *PCptr, *term_name;
d105 1
d118 5
a122 29
	/* terminals that overstrike need special attention */
	overstrike = tgetflag("os");

	/* initialize the pointer into the termcap string buffer */
	bufptr = string_buffer;

	/* get "ce", clear to end */
	if (!overstrike) {
		clear_line = tgetstr("ce", &bufptr);
	}
	/* get necessary capabilities */
	if ((clear_scr = tgetstr("cl", &bufptr)) == NULL ||
	    (cursor_motion = tgetstr("cm", &bufptr)) == NULL) {
		smart_terminal = No;
		return;
	}
	/* get some more sophisticated stuff -- these are optional */
	clear_to_end = tgetstr("cd", &bufptr);
	terminal_init = tgetstr("ti", &bufptr);
	terminal_end = tgetstr("te", &bufptr);
	start_standout = tgetstr("so", &bufptr);
	end_standout = tgetstr("se", &bufptr);

	/* pad character */
	PC = (PCptr = tgetstr("pc", &bufptr)) ? *PCptr : 0;

	/* set convenience strings */
	(void) strlcpy(home, tgoto(cursor_motion, 0, 0), sizeof(home));
	/* (lower_left is set in get_screensize) */
a142 1

d148 1
a149 1

a153 1
		/* remember that it really is a terminal */
d155 1
a155 1

d158 1
d164 3
d172 2
a173 9
	/* move to the lower left, clear the line and send "te" */
	if (smart_terminal) {
		putcap(lower_left);
		putcap(clear_line);
		fflush(stdout);
		putcap(terminal_end);
	}

	/* if we have settings to reset, then do so */
d181 1
d189 1
a202 2
	(void) strlcpy(lower_left, tgoto(cursor_motion, 0, screen_length - 1),
	    sizeof(lower_left));
d206 1
a206 1
standout(char *msg)
d209 2
a210 7
		putcap(start_standout);
		if (fputs(msg, stdout) == EOF)
			exit(1);
		putcap(end_standout);
	} else {
		if (fputs(msg, stdout) == EOF)
			exit(1);
a211 32
}

void
clear(void)
{
	if (smart_terminal)
		putcap(clear_scr);
}

int
clear_eol(int len)
{
	if (smart_terminal && !overstrike && len > 0) {
		if (clear_line) {
			putcap(clear_line);
			return (0);
		} else {
			while (len-- > 0) {
				if (putchar(' ') == EOF)
					exit(1);
			}
			return (1);
		}
	}
	return (-1);
}

void
go_home(void)
{
	if (smart_terminal)
		putcap(home);
@


1.15
log
@Remove some uneeded includes and declarations. -Wall is happy and no
binary change. From Mark Lumsden.
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.14 2004/05/09 22:14:15 deraadt Exp $	 */
a59 1
short	ospeed;
@


1.14
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.13 2003/06/16 17:24:44 millert Exp $	 */
a47 1
#include <termios.h>
@


1.13
log
@Add missing #include <err.h>
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.12 2003/06/16 01:09:02 deraadt Exp $	 */
d33 1
a33 1
 * 
d35 1
a35 1
 * 
d254 2
a255 2
void 
clear()
@


1.12
log
@use warnx(); millert ok
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.11 2003/06/13 21:52:25 deraadt Exp $	 */
d43 1
@


1.11
log
@readable code
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.10 2003/06/12 23:09:30 deraadt Exp $	 */
d54 7
a60 1
extern char    *__progname;
d62 1
a62 19
int             overstrike;
int             screen_length;
int             screen_width;
char            ch_erase;
char            ch_kill;
char            smart_terminal;
char            PC;
char            string_buffer[1024];
char            home[15];
char            lower_left[15];
char           *clear_line;
char           *clear_scr;
char           *clear_to_end;
char           *cursor_motion;
char           *start_standout;
char           *end_standout;
char           *terminal_init;
char           *terminal_end;
short           ospeed;
d64 1
a64 4
static struct termios old_settings;
static struct termios new_settings;

static char     is_a_terminal = No;
d97 1
a97 1
			fprintf(stderr, "%s: can't open termcap file\n", __progname);
d99 1
a99 2
			fprintf(stderr, "%s: no termcap entry for a `%s' terminal\n",
			    __progname, term_name);
@


1.10
log
@knf
@
text
@d1 1
a1 1
/* $OpenBSD: screen.c,v 1.9 2003/06/12 22:30:23 pvalchev Exp $	 */
d54 1
a54 1
extern char    *myname;
d112 1
a112 1
			fprintf(stderr, "%s: can't open termcap file\n", myname);
d115 1
a115 1
			    myname, term_name);
@


1.9
log
@cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.c,v 1.8 2002/07/15 17:20:36 deraadt Exp $	*/
d31 8
a38 7
/*  This file contains the routines that interface to termcap and stty/gtty.
 *
 *  Paul Vixie, February 1987: converted to use ioctl() instead of stty/gtty.
 *
 *  I put in code to turn on the TOSTOP bit while top was running, but I
 *  didn't really like the results.  If you desire it, turn on the
 *  preprocessor variable "TOStop".   --wnl
d54 1
a54 1
extern char *myname;
d56 19
a74 19
int  overstrike;
int  screen_length;
int  screen_width;
char ch_erase;
char ch_kill;
char smart_terminal;
char PC;
char string_buffer[1024];
char home[15];
char lower_left[15];
char *clear_line;
char *clear_scr;
char *clear_to_end;
char *cursor_motion;
char *start_standout;
char *end_standout;
char *terminal_init;
char *terminal_end;
short ospeed;
d79 1
a79 1
static char is_a_terminal = No;
d84 36
a119 36
    char *bufptr;
    char *PCptr;
    char *term_name;
    int status;

    /* set defaults in case we aren't smart */
    screen_width = MAX_COLS;
    screen_length = 0;

    if (!interactive)
    {
	/* pretend we have a dumb terminal */
	smart_terminal = No;
	return;
    }

    /* assume we have a smart terminal until proven otherwise */
    smart_terminal = Yes;

    /* get the terminal name */
    term_name = getenv("TERM");

    /* if there is no TERM, assume it's a dumb terminal */
    /* patch courtesy of Sam Horrocks at telegraph.ics.uci.edu */
    if (term_name == NULL)
    {
	smart_terminal = No;
	return;
    }

    /* now get the termcap entry */
    if ((status = tgetent(NULL, term_name)) != 1)
    {
	if (status == -1)
	{
	    fprintf(stderr, "%s: can't open termcap file\n", myname);
d121 15
d137 42
a178 79
	{
	    fprintf(stderr, "%s: no termcap entry for a `%s' terminal\n",
		    myname, term_name);
	}

	/* pretend it's dumb and proceed */
	smart_terminal = No;
	return;
    }

    /* "hardcopy" immediately indicates a very stupid terminal */
    if (tgetflag("hc"))
    {
	smart_terminal = No;
	return;
    }

    /* set up common terminal capabilities */
    if ((screen_length = tgetnum("li")) <= Header_lines)
    {
	screen_length = smart_terminal = 0;
	return;
    }

    /* screen_width is a little different */
    if ((screen_width = tgetnum("co")) == -1)
    {
	screen_width = 79;
    }
    else
    {
	screen_width -= 1;
    }

    /* terminals that overstrike need special attention */
    overstrike = tgetflag("os");

    /* initialize the pointer into the termcap string buffer */
    bufptr = string_buffer;

    /* get "ce", clear to end */
    if (!overstrike)
    {
	clear_line = tgetstr("ce", &bufptr);
    }

    /* get necessary capabilities */
    if ((clear_scr  = tgetstr("cl", &bufptr)) == NULL ||
	(cursor_motion = tgetstr("cm", &bufptr)) == NULL)
    {
	smart_terminal = No;
	return;
    }

    /* get some more sophisticated stuff -- these are optional */
    clear_to_end   = tgetstr("cd", &bufptr);
    terminal_init  = tgetstr("ti", &bufptr);
    terminal_end   = tgetstr("te", &bufptr);
    start_standout = tgetstr("so", &bufptr);
    end_standout   = tgetstr("se", &bufptr);

    /* pad character */
    PC = (PCptr = tgetstr("pc", &bufptr)) ? *PCptr : 0;

    /* set convenience strings */
    (void) strncpy(home, tgoto(cursor_motion, 0, 0), sizeof (home) -1);
    home[sizeof (home) -1] = 0;
    /* (lower_left is set in get_screensize) */

    /* get the actual screen size with an ioctl, if needed */
    /* This may change screen_width and screen_length, and it always
       sets lower_left. */
    get_screensize();

    /* if stdout is not a terminal, pretend we are a dumb terminal */
    if (tcgetattr(STDOUT_FILENO, &old_settings) == -1)
    {
	smart_terminal = No;
    }
d184 26
a209 29
    /* get the old settings for safe keeping */
    if (tcgetattr(STDOUT_FILENO, &old_settings) != -1)
    {
	/* copy the settings so we can modify them */
	new_settings = old_settings;

	/* turn off ICANON, character echo and tab expansion */
	new_settings.c_lflag &= ~(ICANON|ECHO);
	new_settings.c_oflag &= ~(OXTABS);
	new_settings.c_cc[VMIN] = 1;
	new_settings.c_cc[VTIME] = 0;
	(void) tcsetattr(STDOUT_FILENO, TCSADRAIN, &new_settings);

	/* remember the erase and kill characters */
	ch_erase = old_settings.c_cc[VERASE];
	ch_kill  = old_settings.c_cc[VKILL];

	/* remember that it really is a terminal */
	is_a_terminal = Yes;

	/* send the termcap initialization string */
	putcap(terminal_init);
    }

    if (!is_a_terminal)
    {
	/* not a terminal at all---consider it dumb */
	smart_terminal = No;
    }
d215 11
a225 14
    /* move to the lower left, clear the line and send "te" */
    if (smart_terminal)
    {
	putcap(lower_left);
	putcap(clear_line);
	fflush(stdout);
	putcap(terminal_end);
    }

    /* if we have settings to reset, then do so */
    if (is_a_terminal)
    {
	(void) tcsetattr(STDOUT_FILENO, TCSADRAIN, &old_settings);
    }
d231 7
a237 11
    /* install our settings if it is a terminal */
    if (is_a_terminal)
    {
	(void) tcsetattr(STDOUT_FILENO, TCSADRAIN, &new_settings);
    }

    /* send init string */
    if (smart_terminal)
    {
	putcap(terminal_init);
    }
d243 1
a243 1
    struct winsize ws;
d245 8
a252 15
    if (ioctl (STDOUT_FILENO, TIOCGWINSZ, &ws) != -1)
    {
	if (ws.ws_row != 0)
	{
	    screen_length = ws.ws_row;
	}
	if (ws.ws_col != 0)
	{
	    screen_width = ws.ws_col - 1;
	}
    }

    (void) strncpy(lower_left, tgoto(cursor_motion, 0, screen_length - 1),
		   sizeof (lower_left) -1);
    lower_left[sizeof(lower_left) -1] = 0;
d258 9
a266 12
    if (smart_terminal)
    {
	putcap(start_standout);
	if (fputs(msg, stdout) == EOF)
	    exit(1);
	putcap(end_standout);
    }
    else
    {
	if (fputs(msg, stdout) == EOF)
	    exit(1);
    }
d269 2
a270 2
void clear()

d272 2
a273 4
    if (smart_terminal)
    {
	putcap(clear_scr);
    }
d279 11
a289 6
    if (smart_terminal && !overstrike && len > 0)
    {
	if (clear_line)
	{
	    putcap(clear_line);
	    return(0);
d291 1
a291 11
	else
	{
	    while (len-- > 0)
	    {
		if (putchar(' ') == EOF)
			exit(1);
	    }
	    return(1);
	}
    }
    return(-1);
d297 2
a298 4
    if (smart_terminal)
    {
	putcap(home);
    }
a301 1

d305 1
a305 1
    int ret;
d307 4
a310 4
    ret = putchar(ch);
    if (ret == EOF)
	exit(1);
    return (ret);
@


1.8
log
@license change from William LeFebvre <wnl@@groupsys.com>; top is now BSD
licensed.  this same license will show up on his next release as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.c,v 1.7 2001/07/27 17:13:42 deraadt Exp $	*/
d80 2
a81 4
void init_termcap(interactive)

int interactive;

d202 2
a203 2
void init_screen()

d236 2
a237 2
void end_screen()

d255 2
a256 2
void reinit_screen()

d271 2
a272 2
void get_screensize()

d293 2
a294 4
void standout(msg)

char *msg;

d319 2
a320 4
int clear_eol(len)

int len;

d342 2
a343 2
void go_home()

d353 2
a354 4
int putstdout(ch)

int ch;

a362 1

@


1.7
log
@abort if stdout use ever produces EOF.  before, top was one of those nasty
processes that could spin if it's output tty went away in some cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.c,v 1.6 1999/04/26 01:34:04 downsj Exp $	*/
d7 2
a8 2
 *  This program may be freely redistributed,
 *  but this entire comment MUST remain intact.
d10 19
a28 2
 *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
 *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
@


1.6
log
@s/STDIN_FILENO/STDOUT_FILENO/ to match top distribution code, rohee@@essi.fr.
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.c,v 1.5 1997/12/02 17:56:30 bitblt Exp $	*/
d286 2
a287 1
	fputs(msg, stdout);
d292 2
a293 1
	fputs(msg, stdout);
d322 2
a323 1
		putchar(' ');
d347 6
a352 1
    return(putchar(ch));
@


1.5
log
@watch those overflows
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.c,v 1.4 1997/09/16 19:25:00 weingart Exp $	*/
d261 1
a261 1
    if (ioctl (STDIN_FILENO, TIOCGWINSZ, &ws) != -1)
@


1.4
log
@small terminals are dumb
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.c,v 1.3 1997/08/24 18:37:47 millert Exp $	*/
d171 2
a172 1
    (void) strcpy(home, tgoto(cursor_motion, 0, 0));
d273 3
a275 1
    (void) strcpy(lower_left, tgoto(cursor_motion, 0, screen_length - 1));
@


1.3
log
@Fix compiler warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.c,v 1.2 1997/08/22 07:16:29 downsj Exp $	*/
d124 1
a124 1
    if ((screen_length = tgetnum("li")) <= 0)
@


1.2
log
@First sweep.  Prototype, type fixes, long fixes, mostly compiles with
-Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: screen.c,v 1.1 1997/08/14 14:00:24 downsj Exp $	*/
d27 1
@


1.1
log
@top 3.4, with a few changes.  Still needs more work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d23 8
a30 1
#include "os.h"
a31 23

#include <sys/ioctl.h>
#ifdef CBREAK
# include <sgtty.h>
# define SGTTY
#else
# ifdef TCGETA
#  define TERMIO
#  include <termio.h>
# else
#  define TERMIOS
#  include <termios.h>
# endif
#endif
#if defined(TERMIO) || defined(TERMIOS)
# ifndef TAB3
#  ifdef OXTABS
#   define TAB3 OXTABS
#  else
#   define TAB3 0
#  endif
# endif
#endif
a36 2
int putstdout();

a43 3
char *tgetstr();
char *tgoto();
char termcap_buf[1024];
d48 1
a48 1
char *clear_screen;
a56 9
#ifdef SGTTY
static struct sgttyb old_settings;
static struct sgttyb new_settings;
#endif
#ifdef TERMIO
static struct termio old_settings;
static struct termio new_settings;
#endif
#ifdef TERMIOS
d59 1
a59 1
#endif
a60 8
#ifdef TOStop
static int old_lword;
static int new_lword;
#endif

#define	STDIN	0
#define	STDOUT	1
#define	STDERR	2
d62 1
a62 1
init_termcap(interactive)
a69 1
    char *getenv();
d98 1
a98 1
    if ((status = tgetent(termcap_buf, term_name)) != 1)
d152 1
a152 1
    if ((clear_screen  = tgetstr("cl", &bufptr)) == NULL ||
d179 1
a179 8
#ifdef SGTTY
    if (ioctl(STDOUT, TIOCGETP, &old_settings) == -1)
    {
	smart_terminal = No;
    }
#endif
#ifdef TERMIO
    if (ioctl(STDOUT, TCGETA, &old_settings) == -1)
a182 7
#endif
#ifdef TERMIOS
    if (tcgetattr(STDOUT, &old_settings) == -1)
    {
	smart_terminal = No;
    }
#endif
d185 1
a185 1
init_screen()
d189 1
a189 56
#ifdef SGTTY
    if (ioctl(STDOUT, TIOCGETP, &old_settings) != -1)
    {
	/* copy the settings so we can modify them */
	new_settings = old_settings;

	/* turn on CBREAK and turn off character echo and tab expansion */
	new_settings.sg_flags |= CBREAK;
	new_settings.sg_flags &= ~(ECHO|XTABS);
	(void) ioctl(STDOUT, TIOCSETP, &new_settings);

	/* remember the erase and kill characters */
	ch_erase = old_settings.sg_erase;
	ch_kill  = old_settings.sg_kill;

#ifdef TOStop
	/* get the local mode word */
	(void) ioctl(STDOUT, TIOCLGET, &old_lword);

	/* modify it */
	new_lword = old_lword | LTOSTOP;
	(void) ioctl(STDOUT, TIOCLSET, &new_lword);
#endif
	/* remember that it really is a terminal */
	is_a_terminal = Yes;

	/* send the termcap initialization string */
	putcap(terminal_init);
    }
#endif
#ifdef TERMIO
    if (ioctl(STDOUT, TCGETA, &old_settings) != -1)
    {
	/* copy the settings so we can modify them */
	new_settings = old_settings;

	/* turn off ICANON, character echo and tab expansion */
	new_settings.c_lflag &= ~(ICANON|ECHO);
	new_settings.c_oflag &= ~(TAB3);
	new_settings.c_cc[VMIN] = 1;
	new_settings.c_cc[VTIME] = 0;
	(void) ioctl(STDOUT, TCSETA, &new_settings);

	/* remember the erase and kill characters */
	ch_erase = old_settings.c_cc[VERASE];
	ch_kill  = old_settings.c_cc[VKILL];

	/* remember that it really is a terminal */
	is_a_terminal = Yes;

	/* send the termcap initialization string */
	putcap(terminal_init);
    }
#endif
#ifdef TERMIOS
    if (tcgetattr(STDOUT, &old_settings) != -1)
d196 1
a196 1
	new_settings.c_oflag &= ~(TAB3);
d199 1
a199 1
	(void) tcsetattr(STDOUT, TCSADRAIN, &new_settings);
a210 1
#endif
d219 1
a219 1
end_screen()
d234 1
a234 12
#ifdef SGTTY
	(void) ioctl(STDOUT, TIOCSETP, &old_settings);
#ifdef TOStop
	(void) ioctl(STDOUT, TIOCLSET, &old_lword);
#endif
#endif
#ifdef TERMIO
	(void) ioctl(STDOUT, TCSETA, &old_settings);
#endif
#ifdef TERMIOS
	(void) tcsetattr(STDOUT, TCSADRAIN, &old_settings);
#endif
d238 1
a238 1
reinit_screen()
d244 1
a244 12
#ifdef SGTTY
	(void) ioctl(STDOUT, TIOCSETP, &new_settings);
#ifdef TOStop
	(void) ioctl(STDOUT, TIOCLSET, &new_lword);
#endif
#endif
#ifdef TERMIO
	(void) ioctl(STDOUT, TCSETA, &new_settings);
#endif
#ifdef TERMIOS
	(void) tcsetattr(STDOUT, TCSADRAIN, &new_settings);
#endif
d254 1
a254 1
get_screensize()
a256 3

#ifdef TIOCGWINSZ

d259 1
a259 1
    if (ioctl (1, TIOCGWINSZ, &ws) != -1)
a270 20
#else
#ifdef TIOCGSIZE

    struct ttysize ts;

    if (ioctl (1, TIOCGSIZE, &ts) != -1)
    {
	if (ts.ts_lines != 0)
	{
	    screen_length = ts.ts_lines;
	}
	if (ts.ts_cols != 0)
	{
	    screen_width = ts.ts_cols - 1;
	}
    }

#endif /* TIOCGSIZE */
#endif /* TIOCGWINSZ */

d274 1
a274 1
standout(msg)
d291 1
a291 1
clear()
d296 1
a296 1
	putcap(clear_screen);
d300 1
a300 1
clear_eol(len)
d324 1
a324 1
go_home()
d335 1
a335 1
putstdout(ch)
d337 1
a337 1
char ch;
d340 1
a340 1
    putchar(ch);
@
