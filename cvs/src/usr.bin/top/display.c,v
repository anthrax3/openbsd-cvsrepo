head	1.52;
access;
symbols
	OPENBSD_6_1:1.52.0.2
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.50.0.4
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.49.0.4
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.47.0.6
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.45.0.4
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.43.0.2
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.2
	OPENBSD_5_0:1.40.0.6
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.40.0.4
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.33.0.10
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.6
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.4
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.4
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.10
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.52
date	2017.03.15.04.24.14;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	oL4eFXBEzCBQNxCU;

1.51
date	2016.08.27.04.07.42;	author guenther;	state Exp;
branches;
next	1.50;
commitid	0Te5wXjdrYMz6HhF;

1.50
date	2015.10.26.12.44.22;	author tedu;	state Exp;
branches;
next	1.49;
commitid	Z4EjeFY0DgKpORw6;

1.49
date	2015.05.06.07.53.29;	author mpi;	state Exp;
branches;
next	1.48;
commitid	Q6ompHwEqgonty8G;

1.48
date	2014.11.27.14.08.01;	author espie;	state Exp;
branches;
next	1.47;
commitid	HBVeMagFGXCIkkVO;

1.47
date	2014.01.14.02.44.57;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2013.11.28.18.24.55;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2013.01.14.21.35.08;	author guenther;	state Exp;
branches;
next	1.44;

1.44
date	2013.01.14.21.33.59;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2012.06.05.18.52.53;	author brynet;	state Exp;
branches;
next	1.42;

1.42
date	2012.04.15.19.52.16;	author lum;	state Exp;
branches;
next	1.41;

1.41
date	2011.12.16.14.50.24;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2010.04.23.09.26.13;	author otto;	state Exp;
branches;
next	1.39;

1.39
date	2010.03.24.05.03.15;	author lum;	state Exp;
branches;
next	1.38;

1.38
date	2010.03.18.12.52.06;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2010.02.05.10.21.10;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2010.01.29.00.36.09;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2009.12.22.15.06.56;	author jmc;	state Exp;
branches;
next	1.34;

1.34
date	2009.12.10.13.16.02;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.30.10.39.01;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.22.11.01.04;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.01.19.10.32;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.16.07.33.08;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.30.13.26.39;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.27.14.01.16;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.27.13.59.27;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.27.13.57.50;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.29.00.56.56;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.30.19.21.19;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.04.06.58.11;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.01.19.33.35;	author jaredy;	state Exp;
branches;
next	1.21;

1.21
date	2005.06.17.12.12.28;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.08.22.36.43;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.13.02.33.09;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.13.18.49.02;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.01.20.20.57;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.19.22.40.45;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.18.08.36.31;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.13.21.52.24;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.13.04.29.59;	author pvalchev;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.12.22.30.23;	author pvalchev;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.15.17.20.36;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.55;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.03.18.08.10;	author camield;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.24.20.16.35;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.27.17.13.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.03.06.20.27.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.03.06.20.19.21;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.08.22.07.16.27;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.08.14.14.00.21;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.52
log
@annoying whitespace die die die
@
text
@/* $OpenBSD: display.c,v 1.51 2016/08/27 04:07:42 guenther Exp $	 */

/*
 *  Top users/processes display for Unix
 *  Version 3
 *
 * Copyright (c) 1984, 1989, William LeFebvre, Rice University
 * Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS EMPLOYER BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *  This file contains the routines that display information on the screen.
 *  Each section of the screen has two routines:  one for initially writing
 *  all constant and dynamic text, and one for only updating the text that
 *  changes.  The prefix "i_" is used on all the "initial" routines and the
 *  prefix "u_" is used for all the "updating" routines.
 *
 *  ASSUMPTIONS:
 *        None of the "i_" routines use any of the termcap capabilities.
 *        In this way, those routines can be safely used on terminals that
 *        have minimal (or nonexistent) terminal capabilities.
 *
 *        The routines are called in this order:  *_loadave, i_timeofday,
 *        *_procstates, *_cpustates, *_memory, *_message, *_header,
 *        *_process, u_endscreen.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/sched.h>
#include <curses.h>
#include <errno.h>
#include <stdio.h>
#include <ctype.h>
#include <err.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/sysctl.h>

#include "screen.h"		/* interface to screen package */
#include "layout.h"		/* defines for screen position layout */
#include "display.h"
#include "top.h"
#include "boolean.h"
#include "machine.h"		/* we should eliminate this!!! */
#include "utils.h"

#ifdef DEBUG
FILE           *debug;
#endif

static int      display_width = MAX_COLS;

static char    *cpustates_tag(int);
static int      string_count(char **);
static void     summary_format(char *, size_t, int *, char **);
static int	readlinedumb(char *, int);

#define lineindex(l) ((l)*display_width)

/* things initialized by display_init and used throughout */

/* buffer of proc information lines for display updating */
char           *screenbuf = NULL;

static char   **procstate_names;
static char   **cpustate_names;
static char   **memory_names;

static int      num_cpustates;

static int     *cpustate_columns;
static int      cpustate_total_length;

/* display ips */
int y_mem;
int y_message;
int y_header;
int y_idlecursor;
int y_procs;
extern int ncpu;
extern int combine_cpus;
extern struct process_select ps;

int header_status = Yes;

static int
empty(void)
{
	return OK;
}

static int
myfputs(const char *s)
{
	return fputs(s, stdout);
}

static int (*addstrp)(const char *);
static int (*printwp)(const char *, ...);
static int (*standoutp)(void);
static int (*standendp)(void);

int
display_resize(void)
{
	int display_lines;
	int cpu_lines = (combine_cpus ? 1 : ncpu);

	y_mem = 2 + cpu_lines;
	y_header = 4 + cpu_lines;
	y_procs = 5 + cpu_lines;

	/* calculate the current dimensions */
	/* if operating in "dumb" mode, we only need one line */
	display_lines = smart_terminal ? screen_length - y_procs : 1;

	y_idlecursor = y_message = 3 + (combine_cpus ? 1 : ncpu);
	if (screen_length <= y_message)
		y_idlecursor = y_message = screen_length - 1;

	/*
	 * we don't want more than MAX_COLS columns, since the
	 * machine-dependent modules make static allocations based on
	 * MAX_COLS and we don't want to run off the end of their buffers
	 */
	display_width = screen_width;
	if (display_width >= MAX_COLS)
		display_width = MAX_COLS - 1;

	if (display_lines < 0)
		display_lines = 0;

	/* return number of lines available */
	/* for dumb terminals, pretend like we can show any amount */
	return (smart_terminal ? display_lines : Largest);
}

int
display_init(struct statics * statics)
{
	int display_lines, *ip, i;
	char **pp;

	if (smart_terminal) {
		addstrp = addstr;
		printwp = printw;
		standoutp = standout;
		standendp = standend;
	} else {
		addstrp = myfputs;
		printwp = printf;
		standoutp = empty;
		standendp = empty;
	}

	/* call resize to do the dirty work */
	display_lines = display_resize();

	/* only do the rest if we need to */
	/* save pointers and allocate space for names */
	procstate_names = statics->procstate_names;

	cpustate_names = statics->cpustate_names;
	num_cpustates = string_count(cpustate_names);
	
	cpustate_columns = calloc(num_cpustates, sizeof(int));
	if (cpustate_columns == NULL)
		err(1, NULL);

	memory_names = statics->memory_names;

	/* calculate starting columns where needed */
	cpustate_total_length = 0;
	pp = cpustate_names;
	ip = cpustate_columns;
	while (*pp != NULL) {
		if ((i = strlen(*pp++)) > 0) {
			*ip++ = cpustate_total_length;
			cpustate_total_length += i + 8;
		}
	}

	/* return number of lines available */
	return (display_lines);
}
static void
format_uptime(char *buf, size_t buflen)
{
	time_t now, uptime;
	int days, hrs, mins;
	int mib[2];
	size_t size;
	struct timeval boottime;

	now = time(NULL);
	/*
	 * Print how long system has been up.
	 * (Found by getting "boottime" from the kernel)
	 */
	mib[0] = CTL_KERN;
	mib[1] = KERN_BOOTTIME;
	size = sizeof(boottime);
	if (sysctl(mib, 2, &boottime, &size, NULL, 0) != -1) {
		uptime = now - boottime.tv_sec;
		uptime += 30;
		days = uptime / (3600 * 24);
		uptime %= (3600 * 24);
		hrs = uptime / 3600;
		uptime %= 3600;
		mins = uptime / 60;
		if (days > 0)
			snprintf(buf, buflen, "up %d day%s, %2d:%02d",
			    days, days > 1 ? "s" : "", hrs, mins);
		else
			snprintf(buf, buflen, "up %2d:%02d",
			    hrs, mins);
	}
}


void
i_loadave(pid_t mpid, double *avenrun)
{
	if (screen_length > 1 || !smart_terminal) {
		int i;

		move(0, 0);
		clrtoeol();

		addstrp("load averages");
		/* mpid == -1 implies this system doesn't have an _mpid */
		if (mpid != -1)
			printwp("last pid: %5ld;  ", (long) mpid);

		for (i = 0; i < 3; i++)
			printwp("%c %5.2f", i == 0 ? ':' : ',', avenrun[i]);
	}

}

/*
 *  Display the current time.
 *  "ctime" always returns a string that looks like this:
 *
 *	Sun Sep 16 01:03:52 1973
 *      012345678901234567890123
 *	          1         2
 *
 *  We want indices 11 thru 18 (length 8).
 */

void
i_timeofday(time_t * tod)
{
	static char buf[30];

	if (buf[0] == '\0')
		gethostname(buf, sizeof(buf));

	if (screen_length > 1 || !smart_terminal) {
		if (smart_terminal) {
			move(0, screen_width - 8 - strlen(buf) - 1);
		} else {
			if (fputs("    ", stdout) == EOF)
				exit(1);
		}
#ifdef DEBUG
		{
			char *foo;
			foo = ctime(tod);
			addstrp(foo);
		}
#endif
		printwp("%s %-8.8s", buf, &(ctime(tod)[11]));
		putn();
	}
}

/*
 *  *_procstates(total, states, threads) - print the process/thread summary line
 *
 *  Assumptions:  cursor is at the beginning of the line on entry
 */
void
i_procstates(int total, int *states, int threads)
{
	if (screen_length > 2 || !smart_terminal) {
		char procstates_buffer[MAX_COLS];
		char uptime[40];

		move(1, 0);
		clrtoeol();
		/* write current number of procs and remember the value */
		if (threads == Yes)
			printwp("%d threads: ", total);
		else
			printwp("%d processes: ", total);

		/* format and print the process state summary */
		summary_format(procstates_buffer, sizeof(procstates_buffer),
		    states, procstate_names);

		addstrp(procstates_buffer);

		format_uptime(uptime, sizeof(uptime));
		if (smart_terminal)
			move(1, screen_width - strlen(uptime));
		else
			printwp("  ");
		printwp("%s", uptime);
		putn();
	}
}

/*
 *  *_cpustates(states) - print the cpu state percentages
 *
 *  Assumptions:  cursor is on the PREVIOUS line
 */

/* cpustates_tag() calculates the correct tag to use to label the line */

static char *
cpustates_tag(int cpu)
{
	if (screen_length > 3 || !smart_terminal) {
		static char *tag;
		static int cpulen, old_width;
		int i;

		if (cpulen == 0 && ncpu > 1) {
			/* compute length of the cpu string */
			for (i = ncpu; i > 0; cpulen++, i /= 10)
				continue;
		}

		if (old_width == screen_width) {
			if (ncpu > 1) {
				/* just store the cpu number in the tag */
				i = tag[3 + cpulen];
				snprintf(tag + 3, cpulen + 1, "%.*d", cpulen, cpu);
				tag[3 + cpulen] = i;
			}
		} else {
			/*
			 * use a long tag if it will fit, otherwise use short one.
			 */
			free(tag);
			if (cpustate_total_length + 10 + cpulen >= screen_width)
				i = asprintf(&tag, "CPU%.*d: ", cpulen, cpu);
			else
				i = asprintf(&tag, "CPU%.*d states: ", cpulen, cpu);
			if (i == -1)
				tag = NULL;
			else
				old_width = screen_width;
		}
		return (tag);
	} else
		return ("\0");
}

void
i_cpustates(int64_t *ostates)
{
	int i, first, cpu;
	double value;
	int64_t *states;
	char **names, *thisname;

	if (combine_cpus) {
		static double *values;
		if (!values) {
			values = calloc(num_cpustates, sizeof(*values));
			if (!values)
				err(1, NULL);
		}
		memset(values, 0, num_cpustates * sizeof(*values));
		for (cpu = 0; cpu < ncpu; cpu++) {
			names = cpustate_names;
			states = ostates + (CPUSTATES * cpu);
			i = 0;
			while ((thisname = *names++) != NULL) {
				if (*thisname != '\0') {
					/* retrieve the value and remember it */
					values[i++] += *states++;
				}
			}
		}
		if (screen_length > 2 || !smart_terminal) {
			names = cpustate_names;
			i = 0;
			first = 0;
			move(2, 0);
			clrtoeol();
			printwp("%-3d CPUs: ", ncpu);

			while ((thisname = *names++) != NULL) {
				if (*thisname != '\0') {
					value = values[i++] / ncpu;
					/* if percentage is >= 1000, print it as 100% */
					printwp((value >= 1000 ? "%s%4.0f%% %s" :
					    "%s%4.1f%% %s"), first++ == 0 ? "" : ", ",
					    value / 10., thisname);
				}
			}
			putn();
		}
		return;
	}
	for (cpu = 0; cpu < ncpu; cpu++) {
		/* now walk thru the names and print the line */
		names = cpustate_names;
		first = 0;
		states = ostates + (CPUSTATES * cpu);

		if (screen_length > 2 + cpu || !smart_terminal) {
			move(2 + cpu, 0);
			clrtoeol();
			addstrp(cpustates_tag(cpu));

			while ((thisname = *names++) != NULL) {
				if (*thisname != '\0') {
					/* retrieve the value and remember it */
					value = *states++;

					/* if percentage is >= 1000, print it as 100% */
					printwp((value >= 1000 ? "%s%4.0f%% %s" :
					    "%s%4.1f%% %s"), first++ == 0 ? "" : ", ",
					    value / 10., thisname);
				}
			}
			putn();
		}
	}
}

/*
 *  *_memory(stats) - print "Memory: " followed by the memory summary string
 */
void
i_memory(int *stats)
{
	if (screen_length > y_mem || !smart_terminal) {
		char memory_buffer[MAX_COLS];

		move(y_mem, 0);
		clrtoeol();
		addstrp("Memory: ");

		/* format and print the memory summary */
		summary_format(memory_buffer, sizeof(memory_buffer), stats,
		    memory_names);
		addstrp(memory_buffer);
		putn();
	}
}

/*
 *  *_message() - print the next pending message line, or erase the one
 *                that is there.
 */

/*
 *  i_message is funny because it gets its message asynchronously (with
 *	respect to screen updates).
 */

static char     next_msg[MAX_COLS + 5];
static int      msgon = 0;

void
i_message(void)
{
	move(y_message, 0);
	if (next_msg[0] != '\0') {
		standoutp();
		addstrp(next_msg);
		standendp();
		clrtoeol();
		msgon = TRUE;
		next_msg[0] = '\0';
	} else if (msgon) {
		clrtoeol();
		msgon = FALSE;
	}
}

/*
 *  *_header(text) - print the header for the process area
 */

void
i_header(char *text)
{
	if (header_status == Yes && (screen_length > y_header
              || !smart_terminal)) {
		if (!smart_terminal) {
			putn();
			if (fputs(text, stdout) == EOF)
				exit(1);
			putn();
		} else {
			move(y_header, 0);
			clrtoeol();
			addstrp(text);
		}
	}
}

/*
 *  *_process(line, thisline) - print one process line
 */

void
i_process(int line, char *thisline, int hl)
{
	/* make sure we are on the correct line */
	move(y_procs + line, 0);

	/* truncate the line to conform to our current screen width */
	thisline[display_width] = '\0';

	/* write the line out */
	if (hl && smart_terminal)
		standoutp();
	addstrp(thisline);
	if (hl && smart_terminal)
		standendp();
	putn();
	clrtoeol();
}

void
u_endscreen(void)
{
	if (smart_terminal) {
		clrtobot();
		/* move the cursor to a pleasant place */
		move(y_idlecursor, x_idlecursor);
	} else {
		/*
		 * separate this display from the next with some vertical
		 * room
		 */
		if (fputs("\n\n", stdout) == EOF)
			exit(1);
	}
}

void
display_header(int status)
{
	header_status = status;
}

void
new_message(int type, const char *msgfmt,...)
{
	va_list ap;

	va_start(ap, msgfmt);
	/* first, format the message */
	vsnprintf(next_msg, sizeof(next_msg), msgfmt, ap);
	va_end(ap);

	if (next_msg[0] != '\0') {
		/* message there already -- can we clear it? */
		/* yes -- write it and clear to end */
		if ((type & MT_delayed) == 0) {
			move(y_message, 0);
			if (type & MT_standout)
				standoutp();
			addstrp(next_msg);
			if (type & MT_standout)
				standendp();
			clrtoeol();
			msgon = TRUE;
			next_msg[0] = '\0';
			if (smart_terminal)
				refresh();
		}
	}
}

void
clear_message(void)
{
	move(y_message, 0);
	clrtoeol();
}


static int
readlinedumb(char *buffer, int size)
{
	char *ptr = buffer, ch, cnt = 0, maxcnt = 0;
	extern volatile sig_atomic_t leaveflag;
	ssize_t len;

	/* allow room for null terminator */
	size -= 1;

	/* read loop */
	while ((fflush(stdout), (len = read(STDIN_FILENO, ptr, 1)) > 0)) {

		if (len == 0 || leaveflag) {
			end_screen();
			exit(0);
		}

		/* newline means we are done */
		if ((ch = *ptr) == '\n')
			break;

		/* handle special editing characters */
		if (ch == ch_kill) {
			/* return null string */
			*buffer = '\0';
			putr();
			return (-1);
		} else if (ch == ch_erase) {
			/* erase previous character */
			if (cnt <= 0) {
				/* none to erase! */
				if (putchar('\7') == EOF)
					exit(1);
			} else {
				if (fputs("\b \b", stdout) == EOF)
					exit(1);
				ptr--;
				cnt--;
			}
		}
		/* check for character validity and buffer overflow */
		else if (cnt == size || !isprint((unsigned char)ch)) {
			/* not legal */
			if (putchar('\7') == EOF)
				exit(1);
		} else {
			/* echo it and store it in the buffer */
			if (putchar(ch) == EOF)
				exit(1);
			ptr++;
			cnt++;
			if (cnt > maxcnt)
				maxcnt = cnt;
		}
	}

	/* all done -- null terminate the string */
	*ptr = '\0';

	/* return either inputted number or string length */
	putr();
	return (cnt == 0 ? -1 : cnt);
}

int
readline(char *buffer, int size)
{
	size_t cnt;

	/* allow room for null terminator */
	size -= 1;

	if (smart_terminal) {
		int y, x;
		getyx(stdscr, y, x);
		while (getnstr(buffer, size) == KEY_RESIZE)
			move(y, x);
	} else
		return readlinedumb(buffer, size);

	cnt = strlen(buffer);
	if (cnt > 0 && buffer[cnt - 1] == '\n')
		buffer[cnt - 1] = '\0';
	return (cnt == 0 ? -1 : cnt);
}

/* internal support routines */
static int
string_count(char **pp)
{
	int cnt;

	cnt = 0;
	while (*pp++ != NULL)
		cnt++;
	return (cnt);
}

#define	COPYLEFT(to, from)				\
	do {						\
		len = strlcpy((to), (from), left);	\
		if (len >= left)			\
			return;				\
		p += len;				\
		left -= len;				\
	} while (0)

static void
summary_format(char *buf, size_t left, int *numbers, char **names)
{
	char *p, *thisname;
	size_t len;
	int num;

	/* format each number followed by its string */
	p = buf;
	while ((thisname = *names++) != NULL) {
		/* get the number to format */
		num = *numbers++;

		if (num >= 0) {
			/* is this number in kilobytes? */
			if (thisname[0] == 'K') {
				/* yes: format it as a memory value */
				COPYLEFT(p, format_k(num));

				/*
				 * skip over the K, since it was included by
				 * format_k
				 */
				COPYLEFT(p, thisname + 1);
			} else if (num > 0) {
				len = snprintf(p, left, "%d%s", num, thisname);
				if (len == (size_t)-1 || len >= left)
					return;
				p += len;
				left -= len;
			}
		} else {
			/*
			 * Ignore negative numbers, but display corresponding
			 * string.
			 */
			COPYLEFT(p, thisname);
		}
	}

	/* if the last two characters in the string are ", ", delete them */
	p -= 2;
	if (p >= buf && p[0] == ',' && p[1] == ' ')
		*p = '\0';
}

/*
 *  printable(str) - make the string pointed to by "str" into one that is
 *	printable (i.e.: all ascii), by converting all non-printable
 *	characters into '?'.  Replacements are done in place and a pointer
 *	to the original buffer is returned.
 */
char *
printable(char *str)
{
	char *ptr, ch;

	ptr = str;
	while ((ch = *ptr) != '\0') {
		if (!isprint((unsigned char)ch))
			*ptr = '?';
		ptr++;
	}
	return (str);
}


/*
 *  show_help() - display the help screen; invoked in response to
 *		either 'h' or '?'.
 */
void
show_help(void)
{
	if (smart_terminal) {
		clear();
		nl();
	}
	printwp("These single-character commands are available:\n"
	    "\n"
	    "^L           - redraw screen\n"
	    "<space>      - update screen\n"
	    "+            - reset any g, p, or u filters\n"
	    "1            - display CPU statistics on a single line\n"
	    "C            - toggle the display of command line arguments\n"
	    "d count      - show `count' displays, then exit\n"
	    "e            - list errors generated by last \"kill\" or \"renice\" command\n"
	    "g string     - filter on command name (g+ selects all commands)\n"
	    "h | ?        - help; show this text\n"
	    "H            - toggle the display of threads\n"
	    "I | i        - toggle the display of idle processes\n"
	    "k [-sig] pid - send signal `-sig' to process `pid'\n"
	    "n|# count    - show `count' processes\n"
	    "o field      - specify sort order (size, res, cpu, time, pri, pid, command)\n"
	    "P pid        - highlight process `pid' (P+ switches highlighting off)\n"
	    "p pid        - display process by `pid' (p+ selects all processes)\n"
	    "q            - quit\n"
	    "r count pid  - renice process `pid' to nice value `count'\n"
	    "S            - toggle the display of system processes\n"
	    "s time       - change delay between displays to `time' seconds\n"
	    "u [-]user    - show processes for `user' (u+ shows all, u -user hides user)\n"
	    "\n");

	if (smart_terminal) {
		nonl();
		refresh();
	}
}

/*
 *  show_errors() - display on stdout the current log of errors.
 */
void
show_errors(void)
{
	struct errs *errp = errs;
	int cnt = 0;

	if (smart_terminal) {
		clear();
		nl();
	}
	printwp("%d error%s:\n\n", errcnt, errcnt == 1 ? "" : "s");
	while (cnt++ < errcnt) {
		printwp("%5s: %s\n", errp->arg,
		    errp->err == 0 ? "Not a number" : strerror(errp->err));
		errp++;
	}
	printwp("\n");
	if (smart_terminal) {
		nonl();
		refresh();
	}
}

void
anykey(void)
{
	int ch;
	ssize_t len;

	standoutp();
	addstrp("Hit any key to continue: ");
	standendp();
	if (smart_terminal)
		refresh();
	else
		fflush(stdout);
	while (1) {
		len = read(STDIN_FILENO, &ch, 1);
		if (len == -1 && errno == EINTR)
			continue;
		if (len == 0)
			exit(1);
		break;
	}
}
@


1.51
log
@Pull in <sys/time.h> for struct timespec and timeval

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.50 2015/10/26 12:44:22 tedu Exp $	 */
d871 1
a871 1
	else 
@


1.50
log
@print uptime too. ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.49 2015/05/06 07:53:29 mpi Exp $	 */
d49 1
@


1.49
log
@Display thread IDs instead of the name of the process's owner when "-H"
is used.

The rationnal is that when you're looking at threads you're generally
already filtereing by PID and this allow you to see which thread is a
pig.

Written some time ago with mikeb@@

ok sthen@@, krw@@, guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.48 2014/11/27 14:08:01 espie Exp $	 */
d59 1
d208 34
d260 1
d311 1
d326 7
@


1.48
log
@All cpus -> N Cpus
"makes sense" theo
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.47 2014/01/14 02:44:57 guenther Exp $	 */
d103 1
@


1.47
log
@getnstr() returns KEY_RESIZE if there was a pending resize event, so loop
until it stops returning that, resetting the cursor position each time.

hint from Gregor Best (gbe (at) ring0.de)
problem noted by and ok sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.46 2013/11/28 18:24:55 deraadt Exp $	 */
d373 1
a373 1
			addstrp("All CPUs: ");
@


1.46
log
@unsigned char for ctype
ok krw okan
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.45 2013/01/14 21:35:08 guenther Exp $	 */
d644 6
a649 3
	if (smart_terminal)
		getnstr(buffer, size);
	else
@


1.45
log
@Remove an unnecessary function cast

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.44 2013/01/14 21:33:59 guenther Exp $	 */
d613 1
a613 1
		else if (cnt == size || !isprint(ch)) {
d735 1
a735 1
		if (!isprint(ch))
@


1.44
log
@When showing threads, say so.  Fix up some comments and names at the same time.

original diff by zhuk@@
ok jsing@@ mpi@@ zhuk@@
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.43 2012/06/05 18:52:53 brynet Exp $	 */
d166 1
a166 1
		printwp = (int(*)(const char *, ...))printw;
@


1.43
log
@Add support for hiding a user's processes in top.

feedback & ok lum@@
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.42 2012/04/15 19:52:16 lum Exp $	 */
d265 1
a265 1
 *  *_procstates(total, brkdn, names) - print the process summary line
d270 1
a270 1
i_procstates(int total, int *brkdn)
a272 1
		int i;
d277 5
a281 13
		/* write current number of processes and remember the value */
		printwp("%d processes:", total);

		if (smart_terminal)
			move(1, 15);
		else {
			/* put out enough spaces to get to column 15 */
			i = digits(total);
			while (i++ < 4) {
				if (putchar(' ') == EOF)
					exit(1);
			}
		}
d284 2
a285 2
		summary_format(procstates_buffer, sizeof(procstates_buffer), brkdn,
		    procstate_names);
d293 1
a293 1
 *  *_cpustates(states, names) - print the cpu state percentages
@


1.42
log
@Move the check for a <0 number of process display_lines to a better place.
This makes:
This terminal can only display -N processes.
a thing of the past.
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.41 2011/12/16 14:50:24 jsing Exp $	 */
d785 1
a785 1
	    "u user       - display processes for `user' (u+ selects all users)\n"
@


1.41
log
@Use H to make top show process threads, instead of the current T. This is
consistent with our ps(1) and top(1) on other operating systems.

ok deraadt@@ mikeb@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.39 2010/03/24 05:03:15 lum Exp $	 */
d150 3
a201 3

	if (display_lines < 0)
		display_lines = 0;
@


1.40
log
@show hostname in header line; ok lum@@ phessler@@
@
text
@d772 1
d774 1
a774 1
	    "g string     - filter on command name (g+ selects all commands)\n"
a784 1
	    "T            - toggle the display of threads\n"
@


1.39
log
@Document updating the display using the space-bar.
ok jmc@@ otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.38 2010/03/18 12:52:06 otto Exp $	 */
d240 5
d247 1
a247 1
			move(0, screen_width - 8);
d259 1
a259 1
		printwp("%-8.8s", &(ctime(tod)[11]));
@


1.38
log
@make the 'e' command work, from Mark Lumsden
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.37 2010/02/05 10:21:10 otto Exp $	 */
d761 1
@


1.37
log
@Header_lines always has the same value as y_procs; so zap the former;
from Mark Lumsden.
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.36 2010/01/29 00:36:09 tedu Exp $	 */
d803 1
a803 1
		printf("%5s: %s\n", errp->arg,
d807 1
@


1.36
log
@Allow sorting by command and pid.  Also, allow partial matches with strncmp.
ok jmc otto
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.35 2009/12/22 15:06:56 jmc Exp $	 */
a102 1
int Header_lines;
a131 1
	Header_lines = 5 + cpu_lines;
d135 1
a135 1
	display_lines = smart_terminal ? screen_length - Header_lines : 1;
@


1.35
log
@add -1 to show_help(); from Mark Lumsden
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.34 2009/12/10 13:16:02 tedu Exp $	 */
d773 1
a773 1
	    "o field      - specify sort order (size, res, cpu, time, pri)\n"
@


1.34
log
@add an option '1' to display all cpu stats combined.  helps save space
with increasing processor counts.
ok deraadt (kettenis otto)
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.33 2007/11/30 10:39:01 otto Exp $	 */
d764 1
@


1.33
log
@Simplify process header display logic a bit. From Mark Lumsden
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.32 2007/11/22 11:01:04 otto Exp $	 */
a89 1
static int      num_procstates;
a91 3
static int     *lprocstates;
static int64_t **lcpustates;

d102 1
d128 6
d139 1
a139 1
	y_idlecursor = y_message = 3 + ncpu;
d160 1
a160 1
	int display_lines, *ip, i, cpu;
a174 5
	y_mem = 2 + ncpu;
	y_header = 4 + ncpu;
	y_procs = 5 + ncpu;
	Header_lines = 5 + ncpu;

a180 4
	num_procstates = string_count(procstate_names);
	lprocstates = calloc(num_procstates, sizeof(int));
	if (lprocstates == NULL)
		err(1, NULL);
a183 8
	lcpustates = calloc(ncpu, sizeof(int64_t *));
	if (lcpustates == NULL)
		err(1, NULL);
	for (cpu = 0; cpu < ncpu; cpu++) {
		lcpustates[cpu] = calloc(num_cpustates, sizeof(int64_t));
		if (lcpustates[cpu] == NULL)
			err(1, NULL);
	}
d343 1
a343 1
		return ('\0');
d349 2
a350 1
	int i, cpu, value;
d352 28
a379 1
	char **names = cpustate_names, *thisname;
d381 13
d397 1
a397 1
		i = 0;
d412 2
a413 2
					    "%s%4.1f%% %s"), i++ == 0 ? "" : ", ",
					    ((float) value) / 10., thisname);
@


1.32
log
@Diff from Mark Lumsden: cleanup of reading strings and numbers, to
make sure command line args and interactive reading of numbers use the
same code. More concrete, interactive use of 'd' and 'n' now also
interpret 'max', 'infinite' and 'all' and handle non-numbers
correctly. tested by a few
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.31 2007/11/01 19:10:32 otto Exp $	 */
d108 1
a108 3
static enum {
	OFF, ON, ERASE
} header_status = ON;
a444 2
static int      header_length;

d452 1
a452 2
	header_length = strlen(text);
	if (header_status == ON && (screen_length > y_header
a463 2
	} else if (header_status == ERASE) {
		header_status = OFF;
d508 1
a508 1
display_header(int t)
d510 1
a510 5
	if (t) {
		header_status = ON;
	} else if (header_status == ON) {
		header_status = ERASE;
	}
@


1.31
log
@cleanup of message handling, originally from Mark Lumsden, with a
twist by me. ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.30 2007/10/16 07:33:08 otto Exp $	 */
d77 1
a77 1
static int	readlinedumb(char *, int, int);
d562 1
a562 1
readlinedumb(char *buffer, int size, int numeric)
d603 1
a603 2
		else if (cnt == size || (numeric && !isdigit(ch)) ||
		    !isprint(ch)) {
d623 1
a623 1
	return (cnt == 0 ? -1 : numeric ? atoi(buffer) : cnt);
d627 1
a627 1
readline(char *buffer, int size, int numeric)
d637 1
a637 1
		return readlinedumb(buffer, size, numeric);
d642 1
a642 1
	return (cnt == 0 ? -1 : numeric ? atoi(buffer) : cnt);
@


1.30
log
@Properly adjust headers displayed when the screen contains few lines.
Avoid a segv also. Problem reported by Mark Lumsden; inital diff by
me, further polishing by Mark. Tested by ray@@ canacar@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.29 2007/09/30 13:26:39 otto Exp $	 */
a280 1
 *		  lastline is valid
a377 1
			/* print tag and bump lastline */
a397 3
 *
 *  Assumptions:  cursor is on "lastline"
 *                for i_memory ONLY: cursor is on the previous line
a419 4
 *
 *  Note that u_message is (currently) the same as i_message.
 *
 *  Assumptions:  lastline is consistent
d428 1
a428 5
static int      msglen = 0;
/*
 * Invariant: msglen is always the length of the message currently displayed
 * on the screen (even when next_msg doesn't contain that message).
 */
a432 7
	/*
	while (lastline < y_message) {
		if (fputc('\n', stdout) == EOF)
			exit(1);
		lastline++;
	}
	*/
d439 1
a439 1
		msglen = strlen(next_msg);
d441 1
a441 1
	} else if (msglen > 0) {
d443 1
a443 1
		msglen = 0;
a450 2
 *
 *  Assumptions:  cursor is on the previous line and lastline is consistent
a475 2
 *
 *  Assumptions:  lastline is consistent
a527 1
	int i;
d534 1
a534 1
	if (msglen > 0) {
a536 1
		i = strlen(next_msg);
d545 1
a545 13
			msglen = i;
			next_msg[0] = '\0';
		}
	} else {
		if ((type & MT_delayed) == 0) {
			move(y_message, 0);
			if (type & MT_standout)
				standoutp();
			addstrp(next_msg);
			if (type & MT_standout)
				standendp();
			clrtoeol();
			msglen = strlen(next_msg);
d547 2
a550 2
	if (smart_terminal)
		refresh();
a620 3

	/* account for the extra characters in the message area */
	msglen += cnt;
@


1.29
log
@unused static var; from Mark Lumsden
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.28 2007/07/27 14:01:16 deraadt Exp $	 */
d138 4
a174 1
	y_message = 3 + ncpu;
a175 1
	y_idlecursor = 3 + ncpu;
d183 15
a197 6
	if (display_lines > -1) {
		/* save pointers and allocate space for names */
		procstate_names = statics->procstate_names;
		num_procstates = string_count(procstate_names);
		lprocstates = calloc(num_procstates, sizeof(int));
		if (lprocstates == NULL)
d199 16
a214 10

		cpustate_names = statics->cpustate_names;
		num_cpustates = string_count(cpustate_names);
		lcpustates = calloc(ncpu, sizeof(int64_t *));
		if (lcpustates == NULL)
			err(1, NULL);
		for (cpu = 0; cpu < ncpu; cpu++) {
			lcpustates[cpu] = calloc(num_cpustates, sizeof(int64_t));
			if (lcpustates[cpu] == NULL)
				err(1, NULL);
d216 1
a216 4
		
		cpustate_columns = calloc(num_cpustates, sizeof(int));
		if (cpustate_columns == NULL)
			err(1, NULL);
d218 2
a219 1
		memory_names = statics->memory_names;
a220 11
		/* calculate starting columns where needed */
		cpustate_total_length = 0;
		pp = cpustate_names;
		ip = cpustate_columns;
		while (*pp != NULL) {
			if ((i = strlen(*pp++)) > 0) {
				*ip++ = cpustate_total_length;
				cpustate_total_length += i + 8;
			}
		}
	}
d228 2
a229 1
	int i;
d231 2
a232 2
	move(0, 0);
	clrtoeol();
d234 4
a237 3
	/* mpid == -1 implies this system doesn't have an _mpid */
	if (mpid != -1)
		printwp("last pid: %5ld;  ", (long) mpid);
d239 3
a241 4
	addstrp("load averages");

	for (i = 0; i < 3; i++)
		printwp("%c %5.2f", i == 0 ? ':' : ',', avenrun[i]);
d258 7
a264 7

	if (smart_terminal) {
		move(0, screen_width - 8);
	} else {
		if (fputs("    ", stdout) == EOF)
			exit(1);
	}
d266 8
a273 4
	{
		char *foo;
		foo = ctime(tod);
		addstrp(foo);
a274 3
#endif
	printwp("%-8.8s", &(ctime(tod)[11]));
	putn();
d286 8
a293 2
	int i;
	char procstates_buffer[MAX_COLS];
d295 9
a303 13
	move(1, 0);
	clrtoeol();
	/* write current number of processes and remember the value */
	printwp("%d processes:", total);

	if (smart_terminal)
		move(1, 15);
	else {
		/* put out enough spaces to get to column 15 */
		i = digits(total);
		while (i++ < 4) {
			if (putchar(' ') == EOF)
				exit(1);
a304 1
	}
d306 3
a308 3
	/* format and print the process state summary */
	summary_format(procstates_buffer, sizeof(procstates_buffer), brkdn,
	    procstate_names);
d310 3
a312 2
	addstrp(procstates_buffer);
	putn();
d326 10
a335 9
	static char *tag;
	static int cpulen, old_width;
	int i;

	if (cpulen == 0 && ncpu > 1) {
		/* compute length of the cpu string */
		for (i = ncpu; i > 0; cpulen++, i /= 10)
			continue;
	}
d337 20
a356 6
	if (old_width == screen_width) {
		if (ncpu > 1) {
			/* just store the cpu number in the tag */
			i = tag[3 + cpulen];
			snprintf(tag + 3, cpulen + 1, "%.*d", cpulen, cpu);
			tag[3 + cpulen] = i;
d358 3
a360 15
	} else {
		/*
		 * use a long tag if it will fit, otherwise use short one.
		 */
		free(tag);
		if (cpustate_total_length + 10 + cpulen >= screen_width)
			i = asprintf(&tag, "CPU%.*d: ", cpulen, cpu);
		else
			i = asprintf(&tag, "CPU%.*d states: ", cpulen, cpu);
		if (i == -1)
			tag = NULL;
		else
			old_width = screen_width;
	}
	return (tag);
a370 5
		move(2 + cpu, 0);
		clrtoeol();
		/* print tag and bump lastline */
		addstrp(cpustates_tag(cpu));

d375 17
a391 9
		while ((thisname = *names++) != NULL) {
			if (*thisname != '\0') {
				/* retrieve the value and remember it */
				value = *states++;

				/* if percentage is >= 1000, print it as 100% */
				printwp((value >= 1000 ? "%s%4.0f%% %s" :
				    "%s%4.1f%% %s"), i++ == 0 ? "" : ", ",
				    ((float) value) / 10., thisname);
d393 1
a394 1
		putn();
d407 6
a412 1
	char memory_buffer[MAX_COLS];
d414 6
a419 9
	move(y_mem, 0);
	clrtoeol();
	addstrp("Memory: ");

	/* format and print the memory summary */
	summary_format(memory_buffer, sizeof(memory_buffer), stats,
	    memory_names);
	addstrp(memory_buffer);
	putn();
d479 2
a480 1
	if (header_status == ON) {
@


1.28
log
@size_t vs ssize_t error; spotted by zinovik@@cs.karelia.ru
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.27 2007/07/27 13:59:27 deraadt Exp $	 */
a71 1
static pid_t    lmpid = 0;
a236 2

	lmpid = mpid;
@


1.27
log
@u_endscreen()'s argument is entirely unused; inspired by zinovik@@cs.karelia.ru
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.26 2007/07/27 13:57:50 deraadt Exp $	 */
d830 1
a830 1
	size_t len;
@


1.26
log
@replace a few more malloc(n*m) idioms with calloc(n,m) for safety;
inspired by zinovik@@cs.karelia.ru
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.25 2007/05/29 00:56:56 otto Exp $	 */
d508 1
a508 1
u_endscreen(int hi)
@


1.25
log
@Instead of using hand-crafted redraws minimizing screen updates, use curses.
Enables nice things like process highlighting without hurting the brain.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.24 2007/03/30 19:21:19 otto Exp $	 */
d186 1
a186 1
		lprocstates = malloc(num_procstates * sizeof(int));
d192 1
a192 1
		lcpustates = malloc(ncpu * sizeof(int64_t *));
d196 1
a196 1
			lcpustates[cpu] = malloc(num_cpustates * sizeof(int64_t));
d201 1
a201 1
		cpustate_columns = malloc(num_cpustates * sizeof(int));
@


1.24
log
@Remove some uneeded includes and declarations. -Wall is happy and no
binary change. From Mark Lumsden.
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.23 2006/03/04 06:58:11 otto Exp $	 */
d50 2
d55 1
a57 2
#include <signal.h>
#include <term.h>
a58 1
#include <stdarg.h>
a72 2
static int      last_hi = 0;	/* used in u_process and u_endscreen */
static int      lastline = 0;
d78 1
a78 1
static void     line_update(char *, char *, int, int);
d113 17
a134 4
	/* first, deallocate any previous buffer that may have been there */
	if (screenbuf != NULL)
		free(screenbuf);

a147 5
	/* now, allocate space for the screen buffer */
	screenbuf = malloc(display_lines * display_width + 1);
	if (screenbuf == NULL)
		return (-1);

d159 12
d227 2
a228 2
	/* i_loadave also clears the screen, since it is first */
	clear();
d232 1
a232 1
		printf("last pid: %5ld;  ", (long) mpid);
d234 1
a234 1
	printf("load averages");
d237 1
a237 1
		printf("%c %5.2f", i == 0 ? ':' : ',', avenrun[i]);
a241 26
void
u_loadave(pid_t mpid, double *avenrun)
{
	int i;

	if (mpid != -1) {
		/* change screen only when value has really changed */
		if (mpid != lmpid) {
			Move_to(x_lastpid, y_lastpid);
			printf("%5ld", (long) mpid);
			lmpid = mpid;
		}
		/* i remembers x coordinate to move to */
		i = x_loadave;
	} else
		i = x_loadave_nompid;

	/* move into position for load averages */
	Move_to(i, y_loadave);

	/* display new load averages */
	/* we should optimize this and only display changes */
	for (i = 0; i < 3; i++)
		printf("%s%5.2f", i == 0 ? "" : ", ", avenrun[i]);
}

d258 1
a258 1
		Move_to(screen_width - 8, 0);
d267 1
a267 2
		if (fputs(foo, stdout) == EOF)
			exit(1);
d270 2
a271 2
	printf("%-8.8s\n", &(ctime(tod)[11]));
	lastline = 1;
a273 3
static int      ltotal = 0;
static char     procstates_buffer[MAX_COLS];

d284 1
d286 2
d289 1
a289 2
	printf("%d processes:", total);
	ltotal = total;
d291 9
a299 5
	/* put out enough spaces to get to column 15 */
	i = digits(total);
	while (i++ < 4) {
		if (putchar(' ') == EOF)
			exit(1);
a304 23
	if (fputs(procstates_buffer, stdout) == EOF)
		exit(1);

	/* save the numbers for next time */
	memcpy(lprocstates, brkdn, num_procstates * sizeof(int));
}

void
u_procstates(int total, int *brkdn)
{
	static char new[MAX_COLS];
	int i;

	/* update number of processes only if it has changed */
	if (ltotal != total) {
		/* move and overwrite */
#if (x_procstate == 0)
		Move_to(x_procstate, y_procstate);
#else
		/* cursor is already there...no motion needed */
		/* assert(lastline == 1); */
#endif
		printf("%d", total);
d306 2
a307 22
		/* if number of digits differs, rewrite the label */
		if (digits(total) != digits(ltotal)) {
			if (fputs(" processes:", stdout) == EOF)
				exit(1);
			/* put out enough spaces to get to column 15 */
			i = digits(total);
			while (i++ < 4) {
				if (putchar(' ') == EOF)
					exit(1);
			}
			/* cursor may end up right where we want it!!! */
		}
		/* save new total */
		ltotal = total;
	}
	/* see if any of the state numbers has changed */
	if (memcmp(lprocstates, brkdn, num_procstates * sizeof(int)) != 0) {
		/* format and update the line */
		summary_format(new, sizeof(new), brkdn, procstate_names);
		line_update(procstates_buffer, new, x_brkdn, y_brkdn);
		memcpy(lprocstates, brkdn, num_procstates * sizeof(int));
	}
a315 2
static int      cpustates_column;

d349 1
a349 2
		else {
			cpustates_column = strlen(tag);
a350 1
		}
d363 2
d366 1
a366 2
		printf("\n%s", cpustates_tag(cpu));
		lastline++;
d378 1
a378 1
				printf((value >= 1000 ? "%s%4.0f%% %s" :
d383 1
a383 3

		/* copy over values into "last" array */
		memcpy(lcpustates[cpu], ostates, num_cpustates * sizeof(int64_t));
a386 48
void
u_cpustates(int64_t *ostates)
{
	char **names, *thisname;
	int cpu, value, *colp;
	int64_t *lp, *states;

	for (cpu = 0; cpu < ncpu; cpu++) {
		lastline = y_cpustates + cpu;
		states = ostates + (CPUSTATES * cpu);
		Move_to(cpustates_column, lastline);
		lp = lcpustates[cpu];
		colp = cpustate_columns;

		/* we could be much more optimal about this */
		names = cpustate_names;
		while ((thisname = *names++) != NULL) {
			if (*thisname != '\0') {
				/* did the value change since last time? */
				if (*lp != *states) {
					/* yes, move and change */
					lastline = y_cpustates + cpu;
					Move_to(cpustates_column + *colp,
					    lastline);

					/* retrieve value and remember it */
					value = *states;

					/* if percentage is >= 1000,
					 * print it as 100%
					 */
					printf((value >= 1000 ? "%4.0f" :
					    "%4.1f"), ((double) value) / 10.);

					/* remember it for next time */
					*lp = *states;
				}
			}
			/* increment and move on */
			lp++;
			states++;
			colp++;
		}
	}
}

static char     memory_buffer[MAX_COLS];

d396 5
a400 3
	if (fputs("\nMemory: ", stdout) == EOF)
		exit(1);
	lastline++;
d405 2
a406 12
	if (fputs(memory_buffer, stdout) == EOF)
		exit(1);
}

void
u_memory(int *stats)
{
	static char new[MAX_COLS];

	/* format the new line */
	summary_format(new, sizeof(new), stats, memory_names);
	line_update(memory_buffer, new, x_mem, y_mem);
d433 1
d439 2
d442 4
a445 1
		standout(next_msg);
d449 1
a449 1
		(void) clear_eol(msglen);
a453 6
void
u_message(void)
{
	i_message();
}

d467 10
a476 5
		if (putchar('\n') == EOF)
			exit(1);
		if (fputs(text, stdout) == EOF)
			exit(1);
		lastline++;
a481 13
/* ARGSUSED */
void
u_header(char *text)
{
	if (header_status == ERASE) {
		if (putchar('\n') == EOF)
			exit(1);
		lastline++;
		clear_eol(header_length);
		header_status = OFF;
	}
}

d489 1
a489 1
i_process(int line, char *thisline)
a490 3
	char *base;
	size_t len;

d492 1
a492 5
	while (lastline < y_procs + line) {
		if (putchar('\n') == EOF)
			exit(1);
		lastline++;
	}
d498 7
a504 52
	if (fputs(thisline, stdout) == EOF)
		exit(1);

	/* copy it in to our buffer */
	base = smart_terminal ? screenbuf + lineindex(line) : screenbuf;
	len = strlcpy(base, thisline, display_width);
	if (len < (size_t)display_width) {
		/* zero fill the rest of it */
		memset(base + len, 0, display_width - len);
	}
}

void
u_process(int linenum, char *linebuf)
{
	int screen_line = linenum + Header_lines;
	char *bufferline;
	size_t len;

	/* remember a pointer to the current line in the screen buffer */
	bufferline = &screenbuf[lineindex(linenum)];

	/* truncate the line to conform to our current screen width */
	linebuf[display_width] = '\0';
	bufferline[display_width] = '\0';

	/* is line higher than we went on the last display? */
	if (linenum >= last_hi) {
		/* yes, just ignore screenbuf and write it out directly */
		/* get positioned on the correct line */
		if (screen_line - lastline == 1) {
			if (putchar('\n') == EOF)
				exit(1);
			lastline++;
		} else {
			Move_to(0, screen_line);
			lastline = screen_line;
		}

		/* now write the line */
		if (fputs(linebuf, stdout) == EOF)
			exit(1);

		/* copy it in to the buffer */
		len = strlcpy(bufferline, linebuf, display_width);
		if (len < (size_t)display_width) {
			/* zero fill the rest of it */
			memset(bufferline + len, 0, display_width - len);
		}
	} else {
		line_update(bufferline, linebuf, 0, linenum + Header_lines);
	}
a509 2
	int screen_line = hi + Header_lines, i;

d511 1
a511 37
		if (hi < last_hi) {
			/* need to blank the remainder of the screen */
			/*
			 * but only if there is any screen left below this
			 * line
			 */
			if (lastline + 1 < screen_length) {
				/*
				 * efficiently move to the end of currently
				 * displayed info
				 */
				if (screen_line - lastline < 5) {
					while (lastline < screen_line) {
						if (putchar('\n') == EOF)
							exit(1);
						lastline++;
					}
				} else {
					Move_to(0, screen_line);
					lastline = screen_line;
				}

				if (clear_to_end) {
					/* we can do this the easy way */
					putcap(clear_to_end);
				} else {
					/* use clear_eol on each line */
					i = hi;
					while ((void) clear_eol(strlen(&screenbuf[lineindex(i++)])), i < last_hi) {
						if (putchar('\n') == EOF)
							exit(1);
					}
				}
			}
		}
		last_hi = hi;

d513 1
a513 2
		Move_to(x_idlecursor, y_idlecursor);
		lastline = y_idlecursor;
d547 12
a558 14
		if (!overstrike) {
			/* yes -- write it and clear to end */
			i = strlen(next_msg);
			if ((type & MT_delayed) == 0) {
				if (type & MT_standout)
					standout(next_msg);
				else {
					if (fputs(next_msg, stdout) == EOF)
						exit(1);
				}
				(void) clear_eol(msglen - i);
				msglen = i;
				next_msg[0] = '\0';
			}
d562 4
d567 2
a568 5
				standout(next_msg);
			else {
				if (fputs(next_msg, stdout) == EOF)
					exit(1);
			}
d573 2
d580 2
a581 4
	if (clear_eol(msglen) == 1) {
		if (putchar('\r') == EOF)
			exit(1);
	}
d584 3
a586 2
int
readline(char *buffer, int size, int numeric)
a608 4
			/* kill line -- account for overstriking */
			if (overstrike)
				msglen += maxcnt;

d611 1
a611 2
			if (putchar('\r') == EOF)
				exit(1);
d647 1
a647 2
	/* (if terminal overstrikes, remember the furthest they went) */
	msglen += overstrike ? maxcnt : cnt;
d650 20
a669 2
	if (putchar('\r') == EOF)
		exit(1);
a739 102
static void
line_update(char *old, char *new, int start, int line)
{
	int ch, diff, newcol = start + 1, lastcol = start;
	char cursor_on_line = No, *current;

	/* compare the two strings and only rewrite what has changed */
	current = old;
#ifdef DEBUG
	fprintf(debug, "line_update, starting at %d\n", start);
	fputs(old, debug);
	fputc('\n', debug);
	fputs(new, debug);
	fputs("\n-\n", debug);
#endif

	/* start things off on the right foot		    */
	/* this is to make sure the invariants get set up right */
	if ((ch = *new++) != *old) {
		if (line - lastline == 1 && start == 0) {
			if (putchar('\n') == EOF)
				exit(1);
		} else
			Move_to(start, line);

		cursor_on_line = Yes;
		if (putchar(ch) == EOF)
			exit(1);
		*old = ch;
		lastcol = 1;
	}
	old++;

	/*
	 *  main loop -- check each character.  If the old and new aren't the
	 *	same, then update the display.  When the distance from the
	 *	current cursor position to the new change is small enough,
	 *	the characters that belong there are written to move the
	 *	cursor over.
	 *
	 *	Invariants:
	 *	    lastcol is the column where the cursor currently is sitting
	 *		(always one beyond the end of the last mismatch).
	 */
	do {
		if ((ch = *new++) != *old) {
			/* new character is different from old	  */
			/* make sure the cursor is on top of this character */
			diff = newcol - lastcol;
			if (diff > 0) {
				/*
				 * some motion is required--figure out which
				 * is shorter
				 */
				if (diff < 6 && cursor_on_line) {
					/*
					 * overwrite old stuff--get it out of
					 * the old buffer
					 */
					printf("%.*s", diff, &current[lastcol - start]);
				} else {
					/* use cursor addressing */
					Move_to(newcol, line);
					cursor_on_line = Yes;
				}
				/* remember where the cursor is */
				lastcol = newcol + 1;
			} else {
				/* already there, update position */
				lastcol++;
			}

			/* write what we need to */
			if (ch == '\0') {
				/*
				 * at the end--terminate with a
				 * clear-to-end-of-line
				 */
				(void) clear_eol(strlen(old));
			} else {
				/* write the new character */
				if (putchar(ch) == EOF)
					exit(1);
			}
			/* put the new character in the screen buffer */
			*old = ch;
		}
		/* update working column and screen buffer pointer */
		newcol++;
		old++;
	} while (ch != '\0');

	/* zero out the rest of the line buffer -- MUST BE DONE! */
	diff = display_width - newcol;
	if (diff > 0)
		memset(old, 0, diff);

	/* remember where the current line is */
	if (cursor_on_line)
		lastline = line;
}

d758 89
@


1.23
log
@Show the CPU state %'s on first display as well. "looks good" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.22 2005/07/01 19:33:35 jaredy Exp $	 */
a48 1
#include <sys/time.h>
a56 1
#include <time.h>
a63 1
#include "top.local.h"
@


1.22
log
@NUL-terminate the screen buffer in u_process(), since it is passed to
strlen() in line_buffer() (requires allocating an extra byte for it).

from markus, ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.21 2005/06/17 12:12:28 markus Exp $	 */
a486 28
	}
}

void
z_cpustates(void)
{
	char **names, *thisname;
	int cpu, i;
	int64_t *lp;

	for (cpu = 0; cpu < ncpu; cpu++) {
		/* show tag and bump lastline */
		printf("\n%s", cpustates_tag(cpu));
		lastline++;

		names = cpustate_names;
		i = 0;
		while ((thisname = *names++) != NULL) {
			if (*thisname != '\0')
				printf("%s    %% %s", i++ == 0 ? "" : ", ",
				    thisname);
		}

		/* fill the "last" array with all -1s, to ensure correct updating */
		lp = lcpustates[cpu];
		i = num_cpustates;
		while (--i >= 0)
			*lp++ = -1;
@


1.21
log
@replace hardcoded 128 with MAX_COLS (now 256)
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.20 2005/06/08 22:36:43 millert Exp $	 */
d141 1
a141 1
	screenbuf = malloc(display_lines * display_width);
d678 1
@


1.20
log
@Multi-cpu support for top.  Each cpu now gets its own stats line.
Based on work by todd@@ at the hackathon.
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.19 2005/04/13 02:33:09 deraadt Exp $	 */
d287 1
a287 1
static char     procstates_buffer[128];
d324 1
a324 1
	static char new[128];
@


1.19
log
@use STD{IN,OUT,ERR}_FILENO
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.18 2004/06/13 18:49:02 otto Exp $	 */
d49 2
d53 1
d80 1
a80 1
static char    *cpustates_tag(void);
d100 1
a100 1
static int     *lcpustates;
d105 9
d141 2
a142 2
	screenbuf = (char *) malloc(display_lines * display_width);
	if (screenbuf == (char *) NULL)
d153 1
a153 1
	int display_lines, *ip, i;
d156 7
d171 3
a173 1
		lprocstates = (int *) malloc(num_procstates * sizeof(int));
d177 12
a188 2
		lcpustates = (int *) malloc(num_cpustates * sizeof(int));
		cpustate_columns = (int *) malloc(num_cpustates * sizeof(int));
d373 1
a373 1
cpustates_tag(void)
d375 3
a377 3
	static char *short_tag = "CPU: ";
	static char *long_tag = "CPU states: ";
	char *use;
d379 30
a408 12
	/*
	 * if length + strlen(long_tag) >= screen_width, then we have to use
	 * the shorter tag (we subtract 2 to account for ": ")
	 */
	if (cpustate_total_length + (int) strlen(long_tag) - 2 >= screen_width)
		use = short_tag;
	else
		use = long_tag;

	/* set cpustates_column accordingly then return result */
	cpustates_column = strlen(use);
	return (use);
d412 1
a412 1
i_cpustates(int *states)
d414 2
a415 1
	int i = 0, value;
d418 19
a436 15
	/* print tag and bump lastline */
	printf("\n%s", cpustates_tag());
	lastline++;

	/* now walk thru the names and print the line */
	while ((thisname = *names++) != NULL) {
		if (*thisname != '\0') {
			/* retrieve the value and remember it */
			value = *states++;

			/* if percentage is >= 1000, print it as 100% */
			printf((value >= 1000 ? "%s%4.0f%% %s" : "%s%4.1f%% %s"),
			    i++ == 0 ? "" : ", ",
			    ((float) value) / 10.,
			    thisname);
d438 3
a441 3

	/* copy over values into "last" array */
	memcpy(lcpustates, states, num_cpustates * sizeof(int));
d445 1
a445 1
u_cpustates(int *states)
d447 34
a480 26
	char **names = cpustate_names, *thisname;
	int value, *lp, *colp;

	Move_to(cpustates_column, y_cpustates);
	lastline = y_cpustates;
	lp = lcpustates;
	colp = cpustate_columns;

	/* we could be much more optimal about this */
	while ((thisname = *names++) != NULL) {
		if (*thisname != '\0') {
			/* did the value change since last time? */
			if (*lp != *states) {
				/* yes, move and change */
				Move_to(cpustates_column + *colp, y_cpustates);
				lastline = y_cpustates;

				/* retrieve value and remember it */
				value = *states;

				/* if percentage is >= 1000, print it as 100% */
				printf((value >= 1000 ? "%4.0f" : "%4.1f"),
				    ((double) value) / 10.);

				/* remember it for next time */
				*lp = *states;
d482 4
a486 4
		/* increment and move on */
		lp++;
		states++;
		colp++;
d493 16
a508 2
	char **names = cpustate_names, *thisname;
	int i = 0, *lp;
d510 6
a515 14
	/* show tag and bump lastline */
	printf("\n%s", cpustates_tag());
	lastline++;

	while ((thisname = *names++) != NULL) {
		if (*thisname != '\0')
			printf("%s    %% %s", i++ == 0 ? "" : ", ", thisname);
	}

	/* fill the "last" array with all -1s, to insure correct updating */
	lp = lcpustates;
	i = num_cpustates;
	while (--i >= 0)
		*lp++ = -1;
@


1.18
log
@Typos in comments and a redundant prototype. From Brian Poole via jmc@@
ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.17 2003/11/01 20:20:57 deraadt Exp $	 */
d767 1
a767 1
	while ((fflush(stdout), (len = read(0, ptr, 1)) > 0)) {
@


1.17
log
@process signals at the right time.  also handle stdin failure better;
millert looked at it..
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.16 2003/06/19 22:40:45 millert Exp $	 */
d41 1
a41 1
 *        have minimal (or nonexistant) terminal capabilities.
d84 1
a84 1
/* things initialized by display_init and used thruout */
@


1.16
log
@o get rid of strecpy() and use strlcpy() and/or snprintf() instead.
o make itoa() just use snprintf()
o rename itoa7() to format_uid() and use snprintf()
o max username len is _PW_NAME_LEN, not 8
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.15 2003/06/18 08:36:31 deraadt Exp $	 */
d53 1
d760 2
d767 7
a773 1
	while ((fflush(stdout), read(0, ptr, 1) > 0)) {
@


1.15
log
@remove unused variables
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.14 2003/06/13 21:52:24 deraadt Exp $	 */
d78 1
a78 1
static void     summary_format(char *, int *, char **);
d280 2
a281 1
	summary_format(procstates_buffer, brkdn, procstate_names);
d324 1
a324 1
		summary_format(new, brkdn, procstate_names);
d465 2
a466 1
	summary_format(memory_buffer, stats, memory_names);
d477 1
a477 1
	summary_format(new, stats, memory_names);
d571 2
a572 1
	char *p, *base;
d590 5
a594 4
	p = strecpy(base, thisline);

	/* zero fill the rest of it */
	memset(p, 0, display_width - (p - base));
d601 2
a602 1
	char *optr, *bufferline;
d628 5
a632 4
		optr = strecpy(bufferline, linebuf);

		/* zero fill the rest of it */
		memset(optr, 0, display_width - (optr - bufferline));
d835 9
d845 1
a845 1
summary_format(char *str, int *numbers, char **names)
d848 1
d852 1
a852 1
	p = str;
d861 1
a861 1
				p = strecpy(p, format_k(num));
d867 1
a867 1
				p = strecpy(p, thisname + 1);
d869 5
a873 2
				p = strecpy(p, itoa(num));
				p = strecpy(p, thisname);
d875 6
a881 3
		/* ignore negative numbers, but display corresponding string */
		else
			p = strecpy(p, thisname);
d886 1
a886 1
	if (p >= str && p[0] == ',' && p[1] == ' ')
@


1.14
log
@readable code
@
text
@d1 1
a1 1
/* $OpenBSD: display.c,v 1.13 2003/06/13 04:29:59 pvalchev Exp $	 */
a93 1
static int      num_memory;
a96 1
static int     *lmemory;
a158 2
		num_memory = string_count(memory_names);
		lmemory = (int *) malloc(num_memory * sizeof(int));
@


1.13
log
@use proper varargs(3), as opposed to a hack; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.12 2003/06/12 22:30:23 pvalchev Exp $	*/
d68 1
a68 1
FILE *debug;
d71 9
a79 9
static pid_t lmpid = 0;
static int last_hi = 0;		/* used in u_process and u_endscreen */
static int lastline = 0;
static int display_width = MAX_COLS;

static char *cpustates_tag(void);
static int string_count(char **);
static void summary_format(char *, int *, char **);
static void line_update(char *, char *, int, int);
d86 1
a86 1
char *screenbuf = NULL;
d88 18
a105 20
static char **procstate_names;
static char **cpustate_names;
static char **memory_names;

static int num_procstates;
static int num_cpustates;
static int num_memory;

static int *lprocstates;
static int *lcpustates;
static int *lmemory;

static int *cpustate_columns;
static int cpustate_total_length;

static enum { OFF, ON, ERASE } header_status = ON;

static int string_count();
static void summary_format();
static void line_update();
d110 1
a110 1
    int display_lines;
d112 25
a136 30
    /* first, deallocate any previous buffer that may have been there */
    if (screenbuf != NULL)
    {
	free(screenbuf);
    }

    /* calculate the current dimensions */
    /* if operating in "dumb" mode, we only need one line */
    display_lines = smart_terminal ? screen_length - Header_lines : 1;

    /* we don't want more than MAX_COLS columns, since the machine-dependent
       modules make static allocations based on MAX_COLS and we don't want
       to run off the end of their buffers */
    display_width = screen_width;
    if (display_width >= MAX_COLS)
    {
	display_width = MAX_COLS - 1;
    }

    /* now, allocate space for the screen buffer */
    screenbuf = (char *)malloc(display_lines * display_width);
    if (screenbuf == (char *)NULL)
    {
	/* oops! */
	return(-1);
    }

    /* return number of lines available */
    /* for dumb terminals, pretend like we can show any amount */
    return(smart_terminal ? display_lines : Largest);
d140 1
a140 1
display_init(struct statics *statics)
d142 32
a173 36
    int display_lines;
    char **pp;
    int *ip;
    int i;

    /* call resize to do the dirty work */
    display_lines = display_resize();

    /* only do the rest if we need to */
    if (display_lines > -1)
    {
	/* save pointers and allocate space for names */
	procstate_names = statics->procstate_names;
	num_procstates = string_count(procstate_names);
	lprocstates = (int *)malloc(num_procstates * sizeof(int));

	cpustate_names = statics->cpustate_names;
	num_cpustates = string_count(cpustate_names);
	lcpustates = (int *)malloc(num_cpustates * sizeof(int));
	cpustate_columns = (int *)malloc(num_cpustates * sizeof(int));

	memory_names = statics->memory_names;
	num_memory = string_count(memory_names);
	lmemory = (int *)malloc(num_memory * sizeof(int));

	/* calculate starting columns where needed */
	cpustate_total_length = 0;
	pp = cpustate_names;
	ip = cpustate_columns;
	while (*pp != NULL)
	{
	    if ((i = strlen(*pp++)) > 0)
	    {
		*ip++ = cpustate_total_length;
		cpustate_total_length += i + 8;
	    }
d175 2
a176 4
    }

    /* return number of lines available */
    return(display_lines);
d182 4
a185 1
    int i;
d187 3
a189 2
    /* i_loadave also clears the screen, since it is first */
    clear();
d191 6
a196 15
    /* mpid == -1 implies this system doesn't have an _mpid */
    if (mpid != -1)
    {
	printf("last pid: %5ld;  ", (long)mpid);
    }

    printf("load averages");

    for (i = 0; i < 3; i++)
    {
	printf("%c %5.2f",
	    i == 0 ? ':' : ',',
	    avenrun[i]);
    }
    lmpid = mpid;
d202 1
a202 1
    int i;
d204 19
a222 29
    if (mpid != -1)
    {
	/* change screen only when value has really changed */
	if (mpid != lmpid)
	{
	    Move_to(x_lastpid, y_lastpid);
	    printf("%5ld", (long)mpid);
	    lmpid = mpid;
	}

	/* i remembers x coordinate to move to */
	i = x_loadave;
    }
    else
    {
	i = x_loadave_nompid;
    }

    /* move into position for load averages */
    Move_to(i, y_loadave);

    /* display new load averages */
    /* we should optimize this and only display changes */
    for (i = 0; i < 3; i++)
    {
	printf("%s%5.2f",
	    i == 0 ? "" : ", ",
	    avenrun[i]);
    }
d225 11
d237 1
a237 1
i_timeofday(time_t *tod)
d239 7
a245 20
    /*
     *  Display the current time.
     *  "ctime" always returns a string that looks like this:
     *  
     *	Sun Sep 16 01:03:52 1973
     *      012345678901234567890123
     *	          1         2
     *
     *  We want indices 11 thru 18 (length 8).
     */

    if (smart_terminal)
    {
	Move_to(screen_width - 8, 0);
    }
    else
    {
	if (fputs("    ", stdout) == EOF)
	    exit(1);
    }
d247 6
a252 6
    {
	char *foo;
	foo = ctime(tod);
	if (fputs(foo, stdout) == EOF)
	    exit(1);
    }
d254 2
a255 2
    printf("%-8.8s\n", &(ctime(tod)[11]));
    lastline = 1;
d258 2
a259 2
static int ltotal = 0;
static char procstates_buffer[128];
a266 1

d270 1
a270 1
    int i;
d272 14
a285 9
    /* write current number of processes and remember the value */
    printf("%d processes:", total);
    ltotal = total;

    /* put out enough spaces to get to column 15 */
    i = digits(total);
    while (i++ < 4)
    {
	if (putchar(' ') == EOF)
a286 1
    }
d288 2
a289 7
    /* format and print the process state summary */
    summary_format(procstates_buffer, brkdn, procstate_names);
    if (fputs(procstates_buffer, stdout) == EOF)
	exit(1);

    /* save the numbers for next time */
    memcpy(lprocstates, brkdn, num_procstates * sizeof(int));
d295 2
a296 2
    static char new[128];
    int i;
d298 3
a300 4
    /* update number of processes only if it has changed */
    if (ltotal != total)
    {
	/* move and overwrite */
d302 1
a302 1
	Move_to(x_procstate, y_procstate);
d304 2
a305 2
	/* cursor is already there...no motion needed */
	/* assert(lastline == 1); */
d307 1
a307 1
	printf("%d", total);
d309 21
a329 13
	/* if number of digits differs, rewrite the label */
	if (digits(total) != digits(ltotal))
	{
	    if (fputs(" processes:", stdout) == EOF)
		exit(1);
	    /* put out enough spaces to get to column 15 */
	    i = digits(total);
	    while (i++ < 4)
	    {
		if (putchar(' ') == EOF)
		    exit(1);
	    }
	    /* cursor may end up right where we want it!!! */
a330 13

	/* save new total */
	ltotal = total;
    }

    /* see if any of the state numbers has changed */
    if (memcmp(lprocstates, brkdn, num_procstates * sizeof(int)) != 0)
    {
	/* format and update the line */
	summary_format(new, brkdn, procstate_names);
	line_update(procstates_buffer, new, x_brkdn, y_brkdn);
	memcpy(lprocstates, brkdn, num_procstates * sizeof(int));
    }
d339 1
a339 1
static int cpustates_column;
d346 12
a357 1
    char *use;
d359 3
a361 17
    static char *short_tag = "CPU: ";
    static char *long_tag = "CPU states: ";

    /* if length + strlen(long_tag) >= screen_width, then we have to
       use the shorter tag (we subtract 2 to account for ": ") */
    if (cpustate_total_length + (int)strlen(long_tag) - 2 >= screen_width)
    {
	use = short_tag;
    }
    else
    {
	use = long_tag;
    }

    /* set cpustates_column accordingly then return result */
    cpustates_column = strlen(use);
    return(use);
d367 6
a372 16
    int i = 0;
    int value;
    char **names = cpustate_names;
    char *thisname;

    /* print tag and bump lastline */
    printf("\n%s", cpustates_tag());
    lastline++;

    /* now walk thru the names and print the line */
    while ((thisname = *names++) != NULL)
    {
	if (*thisname != '\0')
	{
	    /* retrieve the value and remember it */
	    value = *states++;
d374 12
a385 5
	    /* if percentage is >= 1000, print it as 100% */
	    printf((value >= 1000 ? "%s%4.0f%% %s" : "%s%4.1f%% %s"),
		   i++ == 0 ? "" : ", ",
		   ((float)value)/10.,
		   thisname);
a386 1
    }
d388 2
a389 2
    /* copy over values into "last" array */
    memcpy(lcpustates, states, num_cpustates * sizeof(int));
d395 33
a427 40
    int value;
    char **names = cpustate_names;
    char *thisname;
    int *lp;
    int *colp;

    Move_to(cpustates_column, y_cpustates);
    lastline = y_cpustates;
    lp = lcpustates;
    colp = cpustate_columns;

    /* we could be much more optimal about this */
    while ((thisname = *names++) != NULL)
    {
	if (*thisname != '\0')
	{
	    /* did the value change since last time? */
	    if (*lp != *states)
	    {
		/* yes, move and change */
		Move_to(cpustates_column + *colp, y_cpustates);
		lastline = y_cpustates;

		/* retrieve value and remember it */
		value = *states;

		/* if percentage is >= 1000, print it as 100% */
		printf((value >= 1000 ? "%4.0f" : "%4.1f"),
		       ((double)value)/10.);

		/* remember it for next time */
		*lp = *states;
	    }
	}

	/* increment and move on */
	lp++;
	states++;
	colp++;
    }
d433 10
a442 14
    int i = 0;
    char **names = cpustate_names;
    char *thisname;
    int *lp;

    /* show tag and bump lastline */
    printf("\n%s", cpustates_tag());
    lastline++;

    while ((thisname = *names++) != NULL)
    {
	if (*thisname != '\0')
	{
	    printf("%s    %% %s", i++ == 0 ? "" : ", ", thisname);
a443 1
    }
d445 5
a449 7
    /* fill the "last" array with all -1s, to insure correct updating */
    lp = lcpustates;
    i = num_cpustates;
    while (--i >= 0)
    {
	*lp++ = -1;
    }
d452 2
a459 3

static char memory_buffer[MAX_COLS];

d463 8
a470 8
    if (fputs("\nMemory: ", stdout) == EOF)
	exit(1);
    lastline++;

    /* format and print the memory summary */
    summary_format(memory_buffer, stats, memory_names);
    if (fputs(memory_buffer, stdout) == EOF)
	exit(1);
d476 1
a476 1
    static char new[MAX_COLS];
d478 3
a480 3
    /* format the new line */
    summary_format(new, stats, memory_names);
    line_update(memory_buffer, new, x_mem, y_mem);
d497 6
a502 4
static char next_msg[MAX_COLS + 5];
static int msglen = 0;
/* Invariant: msglen is always the length of the message currently displayed
   on the screen (even when next_msg doesn't contain that message). */
d507 13
a519 17
    while (lastline < y_message)
    {
	if (fputc('\n', stdout) == EOF)
	    exit(1);
	lastline++;
    }
    if (next_msg[0] != '\0')
    {
	standout(next_msg);
	msglen = strlen(next_msg);
	next_msg[0] = '\0';
    }
    else if (msglen > 0)
    {
	(void) clear_eol(msglen);
	msglen = 0;
    }
d525 1
a525 1
    i_message();
d528 1
a528 1
static int header_length;
d539 10
a548 13
    header_length = strlen(text);
    if (header_status == ON)
    {
	if (putchar('\n') == EOF)
	    exit(1);
	if (fputs(text, stdout) == EOF)
	    exit(1);
	lastline++;
    }
    else if (header_status == ERASE)
    {
	header_status = OFF;
    }
d551 1
a551 1
/*ARGSUSED*/
d555 7
a561 8
    if (header_status == ERASE)
    {
	if (putchar('\n') == EOF)
	    exit(1);
	lastline++;
	clear_eol(header_length);
	header_status = OFF;
    }
d573 1
a573 2
    char *p;
    char *base;
d575 6
a580 7
    /* make sure we are on the correct line */
    while (lastline < y_procs + line)
    {
	if (putchar('\n') == EOF)
	    exit(1);
	lastline++;
    }
d582 2
a583 2
    /* truncate the line to conform to our current screen width */
    thisline[display_width] = '\0';
d585 3
a587 3
    /* write the line out */
    if (fputs(thisline, stdout) == EOF)
	exit(1);
d589 3
a591 3
    /* copy it in to our buffer */
    base = smart_terminal ? screenbuf + lineindex(line) : screenbuf;
    p = strecpy(base, thisline);
d593 2
a594 2
    /* zero fill the rest of it */
    memset(p, 0, display_width - (p - base));
d600 21
a620 26
    char *optr;
    int screen_line = linenum + Header_lines;
    char *bufferline;

    /* remember a pointer to the current line in the screen buffer */
    bufferline = &screenbuf[lineindex(linenum)];

    /* truncate the line to conform to our current screen width */
    linebuf[display_width] = '\0';

    /* is line higher than we went on the last display? */
    if (linenum >= last_hi)
    {
	/* yes, just ignore screenbuf and write it out directly */
	/* get positioned on the correct line */
	if (screen_line - lastline == 1)
	{
	    if (putchar('\n') == EOF)
		exit(1);
	    lastline++;
	}
	else
	{
	    Move_to(0, screen_line);
	    lastline = screen_line;
	}
d622 3
a624 3
	/* now write the line */
	if (fputs(linebuf, stdout) == EOF)
	    exit(1);
d626 2
a627 2
	/* copy it in to the buffer */
	optr = strecpy(bufferline, linebuf);
d629 5
a633 7
	/* zero fill the rest of it */
	memset(optr, 0, display_width - (optr - bufferline));
    }
    else
    {
	line_update(bufferline, linebuf, 0, linenum + Header_lines);
    }
d639 1
a639 2
    int screen_line = hi + Header_lines;
    int i;
d641 35
a675 22
    if (smart_terminal)
    {
	if (hi < last_hi)
	{
	    /* need to blank the remainder of the screen */
	    /* but only if there is any screen left below this line */
	    if (lastline + 1 < screen_length)
	    {
		/* efficiently move to the end of currently displayed info */
		if (screen_line - lastline < 5)
		{
		    while (lastline < screen_line)
		    {
			if (putchar('\n') == EOF)
			    exit(1);
			lastline++;
		    }
		}
		else
		{
		    Move_to(0, screen_line);
		    lastline = screen_line;
d677 1
d679 10
a688 16
		if (clear_to_end)
		{
		    /* we can do this the easy way */
		    putcap(clear_to_end);
		}
		else
		{
		    /* use clear_eol on each line */
		    i = hi;
		    while ((void) clear_eol(strlen(&screenbuf[lineindex(i++)])), i < last_hi)
		    {
			if (putchar('\n') == EOF)
			    exit(1);
		    }
		}
	    }
a689 12
	last_hi = hi;

	/* move the cursor to a pleasant place */
	Move_to(x_idlecursor, y_idlecursor);
	lastline = y_idlecursor;
    }
    else
    {
	/* separate this display from the next with some vertical room */
	if (fputs("\n\n", stdout) == EOF)
	    exit(1);
    }
d695 5
a699 8
    if (t)
    {
	header_status = ON;
    }
    else if (header_status == ON)
    {
	header_status = ERASE;
    }
d703 37
a739 24
new_message(int type, const char *msgfmt, ...)
{
    int i;
    va_list ap;

    va_start(ap, msgfmt);
    /* first, format the message */
    vsnprintf(next_msg, sizeof(next_msg), msgfmt, ap);
    va_end(ap);

    if (msglen > 0)
    {
	/* message there already -- can we clear it? */
	if (!overstrike)
	{
	    /* yes -- write it and clear to end */
	    i = strlen(next_msg);
	    if ((type & MT_delayed) == 0)
	    {
		if (type & MT_standout)
		    standout(next_msg);
		else {
		    if (fputs(next_msg, stdout) == EOF)
			exit(1);
a740 18
		(void) clear_eol(msglen - i);
		msglen = i;
		next_msg[0] = '\0';
	    }
	}
    }
    else
    {
	if ((type & MT_delayed) == 0)
	{
	    if (type & MT_standout)
		standout(next_msg);
	    else {
		if (fputs(next_msg, stdout) == EOF)
		    exit(1);
	    }
	    msglen = strlen(next_msg);
	    next_msg[0] = '\0';
a741 1
    }
d747 4
a750 5
    if (clear_eol(msglen) == 1)
    {
	if (putchar('\r') == EOF)
	    exit(1);
    }
d756 50
a805 15
    char *ptr = buffer;
    char ch;
    char cnt = 0;
    char maxcnt = 0;

    /* allow room for null terminator */
    size -= 1;

    /* read loop */
    while ((fflush(stdout), read(0, ptr, 1) > 0))
    {
	/* newline means we are done */
	if ((ch = *ptr) == '\n')
	{
	    break;
d808 9
a816 12
	/* handle special editing characters */
	if (ch == ch_kill)
	{
	    /* kill line -- account for overstriking */
	    if (overstrike)
	    {
		msglen += maxcnt;
	    }

	    /* return null string */
	    *buffer = '\0';
	    if (putchar('\r') == EOF)
d818 1
a818 52
	    return(-1);
	}
	else if (ch == ch_erase)
	{
	    /* erase previous character */
	    if (cnt <= 0)
	    {
		/* none to erase! */
		if (putchar('\7') == EOF)
		    exit(1);
	    }
	    else
	    {
		if (fputs("\b \b", stdout) == EOF)
		    exit(1);
		ptr--;
		cnt--;
	    }
	}
	/* check for character validity and buffer overflow */
	else if (cnt == size || (numeric && !isdigit(ch)) ||
		!isprint(ch))
	{
	    /* not legal */
	    if (putchar('\7') == EOF)
		exit(1);
	}
	else
	{
	    /* echo it and store it in the buffer */
	    if (putchar(ch) == EOF)
		exit(1);
	    ptr++;
	    cnt++;
	    if (cnt > maxcnt)
	    {
		maxcnt = cnt;
	    }
	}
    }

    /* all done -- null terminate the string */
    *ptr = '\0';

    /* account for the extra characters in the message area */
    /* (if terminal overstrikes, remember the furthest they went) */
    msglen += overstrike ? maxcnt : cnt;

    /* return either inputted number or string length */
    if (putchar('\r') == EOF)
	exit(1);
    return(cnt == 0 ? -1 : numeric ? atoi(buffer) : cnt);
a821 1

d825 1
a825 1
    int cnt;
d827 4
a830 6
    cnt = 0;
    while (*pp++ != NULL)
    {
	cnt++;
    }
    return(cnt);
d836 2
a837 10
    char *p;
    int num;
    char *thisname;

    /* format each number followed by its string */
    p = str;
    while ((thisname = *names++) != NULL)
    {
	/* get the number to format */
	num = *numbers++;
d839 25
a863 16
	if (num >= 0)
	{
	    /* is this number in kilobytes? */
	    if (thisname[0] == 'K')
	    {
		/* yes: format it as a memory value */
		p = strecpy(p, format_k(num));

		/* skip over the K, since it was included by format_k */
		p = strecpy(p, thisname+1);
	    }
	    else if (num > 0)
	    {
		p = strecpy(p, itoa(num));
		p = strecpy(p, thisname);
	    }
d866 4
a869 13
	/* ignore negative numbers, but display corresponding string */
	else
	{
	    p = strecpy(p, thisname);
	}
    }

    /* if the last two characters in the string are ", ", delete them */
    p -= 2;
    if (p >= str && p[0] == ',' && p[1] == ' ')
    {
	*p = '\0';
    }
d875 2
a876 6
    int ch;
    int diff;
    int newcol = start + 1;
    int lastcol = start;
    char cursor_on_line = No;
    char *current;
d878 2
a879 2
    /* compare the two strings and only rewrite what has changed */
    current = old;
d881 5
a885 5
    fprintf(debug, "line_update, starting at %d\n", start);
    fputs(old, debug);
    fputc('\n', debug);
    fputs(new, debug);
    fputs("\n-\n", debug);
d888 14
a901 12
    /* start things off on the right foot		    */
    /* this is to make sure the invariants get set up right */
    if ((ch = *new++) != *old)
    {
	if (line - lastline == 1 && start == 0)
	{
	    if (putchar('\n') == EOF)
		exit(1);
	}
	else
	{
	    Move_to(start, line);
a902 67
	cursor_on_line = Yes;
	if (putchar(ch) == EOF)
	    exit(1);
	*old = ch;
	lastcol = 1;
    }
    old++;
	
    /*
     *  main loop -- check each character.  If the old and new aren't the
     *	same, then update the display.  When the distance from the
     *	current cursor position to the new change is small enough,
     *	the characters that belong there are written to move the
     *	cursor over.
     *
     *	Invariants:
     *	    lastcol is the column where the cursor currently is sitting
     *		(always one beyond the end of the last mismatch).
     */
    do		/* yes, a do...while */
    {
	if ((ch = *new++) != *old)
	{
	    /* new character is different from old	  */
	    /* make sure the cursor is on top of this character */
	    diff = newcol - lastcol;
	    if (diff > 0)
	    {
		/* some motion is required--figure out which is shorter */
		if (diff < 6 && cursor_on_line)
		{
		    /* overwrite old stuff--get it out of the old buffer */
		    printf("%.*s", diff, &current[lastcol-start]);
		}
		else
		{
		    /* use cursor addressing */
		    Move_to(newcol, line);
		    cursor_on_line = Yes;
		}
		/* remember where the cursor is */
		lastcol = newcol + 1;
	    }
	    else
	    {
		/* already there, update position */
		lastcol++;
	    }
		
	    /* write what we need to */
	    if (ch == '\0')
	    {
		/* at the end--terminate with a clear-to-end-of-line */
		(void) clear_eol(strlen(old));
	    }
	    else
	    {
		/* write the new character */
		if (putchar(ch) == EOF)
		    exit(1);
	    }
	    /* put the new character in the screen buffer */
	    *old = ch;
	}
	    
	/* update working column and screen buffer pointer */
	newcol++;
a903 2
	    
    } while (ch != '\0');
d905 67
a971 12
    /* zero out the rest of the line buffer -- MUST BE DONE! */
    diff = display_width - newcol;
    if (diff > 0)
    {
	memset(old, 0, diff);
    }

    /* remember where the current line is */
    if (cursor_on_line)
    {
	lastline = line;
    }
a979 1

d983 1
a983 2
    char *ptr;
    char ch;
d985 5
a989 6
    ptr = str;
    while ((ch = *ptr) != '\0')
    {
	if (!isprint(ch))
	{
	    *ptr = '?';
d991 1
a991 3
	ptr++;
    }
    return(str);
@


1.12
log
@cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.11 2002/07/15 17:20:36 deraadt Exp $	*/
d56 1
a784 1
/*VARARGS2*/
d786 1
a786 1
new_message(int type, char *msgfmt, caddr_t a1, caddr_t a2, caddr_t a3)
d789 1
d791 1
d793 2
a794 1
    (void) snprintf(next_msg, sizeof(next_msg), msgfmt, a1, a2, a3);
@


1.11
log
@license change from William LeFebvre <wnl@@groupsys.com>; top is now BSD
licensed.  this same license will show up on his next release as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.10 2002/06/12 06:07:16 mpech Exp $	*/
d108 2
a109 2
int display_resize()

d145 2
a146 4
int display_init(statics)

struct statics *statics;

d191 2
a192 5
void i_loadave(mpid, avenrun)

pid_t mpid;
double *avenrun;

d216 2
a217 5
void u_loadave(mpid, avenrun)

pid_t mpid;
double *avenrun;

d252 2
a253 4
void i_timeofday(tod)

time_t *tod;

d297 2
a298 5
void i_procstates(total, brkdn)

int total;
int *brkdn;

d323 2
a324 5
void u_procstates(total, brkdn)

int total;
int *brkdn;

d380 2
a381 2
static char *cpustates_tag()

d404 2
a405 4
void i_cpustates(states)

int *states;

d436 2
a437 4
void u_cpustates(states)

int *states;

d481 2
a482 2
void z_cpustates()

d519 2
a520 4
void i_memory(stats)

int *stats;

d532 2
a533 4
void u_memory(stats)

int *stats;

d561 2
a562 2
void i_message()

d583 2
a584 2
void u_message()

d597 2
a598 4
void i_header(text)

char *text;

d616 2
a617 4
void u_header(text)

char *text;		/* ignored */

d635 2
a636 5
void i_process(line, thisline)

int line;
char *thisline;

d664 2
a665 5
void u_process(linenum, linebuf)

int linenum;
char *linebuf;

d710 2
a711 4
void u_endscreen(hi)

int hi;

d771 2
a772 4
void display_header(t)

int t;

d785 2
a786 6
void new_message(type, msgfmt, a1, a2, a3)

int type;
char *msgfmt;
caddr_t a1, a2, a3;

d830 2
a831 2
void clear_message()

d840 2
a841 6
int readline(buffer, size, numeric)

char *buffer;
int  size;
int  numeric;

d929 2
a930 4
static int string_count(pp)

char **pp;

d942 2
a943 6
static void summary_format(str, numbers, names)

char *str;
int *numbers;
char **names;

d989 2
a990 7
static void line_update(old, new, start, line)

char *old;
char *new;
int start;
int line;

d1114 2
a1115 4
char *printable(str)

char *str;

@


1.10
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.9 2002/02/16 21:27:55 millert Exp $	*/
d7 2
a8 2
 *  This program may be freely redistributed,
 *  but this entire comment MUST remain intact.
d10 19
a28 2
 *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
 *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.8 2001/11/19 19:02:17 mpech Exp $	*/
d53 1
a53 1
static int lmpid = 0;
d178 1
a178 1
int mpid;
d190 1
a190 1
	printf("last pid: %5d;  ", mpid);
d206 1
a206 1
int mpid;
d218 1
a218 1
	    printf("%5d", mpid);
@


1.8
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.7 2001/09/03 18:08:10 camield Exp $	*/
d58 4
a61 4
static char *cpustates_tag __P((void));
static int string_count __P((char **));
static void summary_format __P((char *, int *, char **));
static void line_update __P((char *, char *, int, int));
@


1.7
log
@don't print zero values on processes line

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.6 2001/08/24 20:16:35 art Exp $	*/
d94 1
a94 1
    register int display_lines;
d133 4
a136 4
    register int display_lines;
    register char **pp;
    register int *ip;
    register int i;
d182 1
a182 1
    register int i;
d210 1
a210 1
    register int i;
d296 1
a296 1
    register int i;
d326 1
a326 1
    register int i;
d382 1
a382 1
    register char *use;
d405 1
a405 1
register int *states;
d408 4
a411 4
    register int i = 0;
    register int value;
    register char **names = cpustate_names;
    register char *thisname;
d439 1
a439 1
register int *states;
d442 5
a446 5
    register int value;
    register char **names = cpustate_names;
    register char *thisname;
    register int *lp;
    register int *colp;
d487 4
a490 4
    register int i = 0;
    register char **names = cpustate_names;
    register char *thisname;
    register int *lp;
d652 2
a653 2
    register char *p;
    register char *base;
d684 3
a686 3
    register char *optr;
    register int screen_line = linenum + Header_lines;
    register char *bufferline;
d729 1
a729 1
register int hi;
d732 2
a733 2
    register int screen_line = hi + Header_lines;
    register int i;
d813 1
a813 1
    register int i;
d872 4
a875 4
    register char *ptr = buffer;
    register char ch;
    register char cnt = 0;
    register char maxcnt = 0;
d960 1
a960 1
register char **pp;
d963 1
a963 1
    register int cnt;
d977 1
a977 1
register char **names;
d980 3
a982 3
    register char *p;
    register int num;
    register char *thisname;
d1026 2
a1027 2
register char *old;
register char *new;
d1032 4
a1035 4
    register int ch;
    register int diff;
    register int newcol = start + 1;
    register int lastcol = start;
d1159 2
a1160 2
    register char *ptr;
    register char ch;
@


1.6
log
@Display even zeros so that the swap output makes more sense.
From Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.5 2001/07/27 17:13:42 deraadt Exp $	*/
d1002 1
a1002 1
	    else
d1010 1
a1010 1
	else if (num < 0)
@


1.5
log
@abort if stdout use ever produces EOF.  before, top was one of those nasty
processes that could spin if it's output tty went away in some cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.4 1999/03/06 20:27:42 millert Exp $	*/
d991 1
a991 2
	/* display only non-zero numbers */
	if (num > 0)
@


1.4
log
@back out changes that should not have escaped my local tree
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.2 1997/08/22 07:16:27 downsj Exp $	*/
d265 2
a266 1
	fputs("    ", stdout);
d272 2
a273 1
	fputs(foo, stdout);
d306 2
a307 1
	putchar(' ');
d312 2
a313 1
    fputs(procstates_buffer, stdout);
d343 2
a344 1
	    fputs(" processes:", stdout);
d349 2
a350 1
		putchar(' ');
d527 2
a528 1
    fputs("\nMemory: ", stdout);
d533 2
a534 1
    fputs(memory_buffer, stdout);
d573 2
a574 1
	fputc('\n', stdout);
d612 4
a615 2
	putchar('\n');
	fputs(text, stdout);
d632 2
a633 1
	putchar('\n');
d658 2
a659 1
	putchar('\n');
d667 2
a668 1
    fputs(thisline, stdout);
d701 2
a702 1
	    putchar('\n');
d712 2
a713 1
	fputs(linebuf, stdout);
d748 2
a749 1
			putchar('\n');
d770 2
a771 1
			putchar('\n');
d785 2
a786 1
	fputs("\n\n", stdout);
d827 6
a832 2
		type & MT_standout ? standout(next_msg) :
		                     fputs(next_msg, stdout);
d843 6
a848 1
	    type & MT_standout ? standout(next_msg) : fputs(next_msg, stdout);
d860 2
a861 1
	putchar('\r');
d900 2
a901 1
	    putchar('\r');
d910 2
a911 1
		putchar('\7');
d915 2
a916 1
		fputs("\b \b", stdout);
d926 2
a927 1
	    putchar('\7');
d932 2
a933 1
	    putchar(ch);
d951 2
a952 1
    putchar('\r');
d1056 2
a1057 1
	    putchar('\n');
d1064 2
a1065 1
	putchar(ch);
d1121 2
a1122 1
		putchar(ch);
@


1.3
log
@add missing reference to infocmp
@
text
@d60 1
a60 1
static void summary_format __P((char *, size_t, int *, char **));
d308 1
a308 2
    summary_format(procstates_buffer, sizeof(procstates_buffer), brkdn,
	procstate_names);
d357 1
a357 1
	summary_format(new, sizeof(new), brkdn, procstate_names);
d525 1
a525 1
    summary_format(memory_buffer, sizeof(memory_buffer), stats, memory_names);
d537 1
a537 1
    summary_format(new, sizeof(new), stats, memory_names);
d938 1
a938 1
static void summary_format(str, siz, numbers, names)
a940 1
size_t siz;
d945 1
a948 3
    if (siz == 0)
	return;

d950 1
a950 1
    *str = '\0';
d963 1
a963 1
		strlcat(str, format_k(num), siz);
d966 1
a966 1
		strlcat(str, thisname+1, siz);
d970 2
a971 2
		strlcat(str, itoa(num), siz);
		strlcat(str, thisname, siz);
d978 1
a978 1
	    strlcat(str, thisname, siz);
d983 2
a984 2
    thisname = str + strlen(str) - 2;
    if (thisname >= str && thisname[0] == ',' && thisname[1] == ' ')
d986 1
a986 1
	*thisname = '\0';
@


1.2
log
@First sweep.  Prototype, type fixes, long fixes, mostly compiles with
-Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: display.c,v 1.1 1997/08/14 14:00:21 downsj Exp $	*/
d60 1
a60 1
static void summary_format __P((char *, int *, char **));
d308 2
a309 1
    summary_format(procstates_buffer, brkdn, procstate_names);
d358 1
a358 1
	summary_format(new, brkdn, procstate_names);
d526 1
a526 1
    summary_format(memory_buffer, stats, memory_names);
d538 1
a538 1
    summary_format(new, stats, memory_names);
d939 1
a939 1
static void summary_format(str, numbers, names)
d942 1
a946 1
    register char *p;
d950 3
d954 1
a954 1
    p = str;
d967 1
a967 1
		p = strecpy(p, format_k(num));
d970 1
a970 1
		p = strecpy(p, thisname+1);
d974 2
a975 2
		p = strecpy(p, itoa(num));
		p = strecpy(p, thisname);
d982 1
a982 1
	    p = strecpy(p, thisname);
d987 2
a988 2
    p -= 2;
    if (p >= str && p[0] == ',' && p[1] == ' ')
d990 1
a990 1
	*p = '\0';
@


1.1
log
@top 3.4, with a few changes.  Still needs more work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 2
a32 1
#include "os.h"
d34 3
d38 1
a52 3
/* imported from screen.c */
extern int overstrike;

d58 5
a64 2
char *printable();

d94 1
a94 1
    register int lines;
d104 1
a104 1
    lines = smart_terminal ? screen_length - Header_lines : 1;
d116 1
a116 1
    screenbuf = (char *)malloc(lines * display_width);
d125 1
a125 1
    return(smart_terminal ? lines : Largest);
d133 1
a133 1
    register int lines;
d139 1
a139 1
    lines = display_resize();
d142 1
a142 1
    if (lines > -1)
d173 1
a173 1
    return(lines);
d176 1
a176 1
i_loadave(mpid, avenrun)
d204 1
a204 1
u_loadave(mpid, avenrun)
d243 1
a243 1
i_timeofday(tod)
d288 1
a288 1
i_procstates(total, brkdn)
d315 1
a315 1
u_procstates(total, brkdn)
d373 1
a373 1
char *cpustates_tag()
d397 1
a397 1
i_cpustates(states)
d431 1
a431 1
u_cpustates(states)
d478 1
a478 1
z_cpustates()
d514 1
a514 1
char memory_buffer[MAX_COLS];
d516 1
a516 1
i_memory(stats)
d529 1
a529 1
u_memory(stats)
d560 1
a560 1
i_message()
d581 1
a581 1
u_message()
d595 1
a595 1
i_header(text)
d614 1
a614 1
u_header(text)
d634 1
a634 1
i_process(line, thisline)
d661 1
a661 1
    memzero(p, display_width - (p - base));
d664 1
a664 1
u_process(line, newline)
d666 2
a667 2
int line;
char *newline;
d671 1
a671 1
    register int screen_line = line + Header_lines;
d675 1
a675 1
    bufferline = &screenbuf[lineindex(line)];
d678 1
a678 1
    newline[display_width] = '\0';
d681 1
a681 1
    if (line >= last_hi)
d697 1
a697 1
	fputs(newline, stdout);
d700 1
a700 1
	optr = strecpy(bufferline, newline);
d703 1
a703 1
	memzero(optr, display_width - (optr - bufferline));
d707 1
a707 1
	line_update(bufferline, newline, 0, line + Header_lines);
d711 1
a711 1
u_endscreen(hi)
d771 1
a771 1
display_header(t)
d787 1
a787 1
new_message(type, msgfmt, a1, a2, a3)
d827 1
a827 1
clear_message()
d836 1
a836 1
readline(buffer, size, numeric)
a947 1
    register int useM = No;
d1100 1
a1100 1
	memzero(old, diff);
@
