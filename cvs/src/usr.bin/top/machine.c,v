head	1.89;
access;
symbols
	OPENBSD_6_2:1.89.0.2
	OPENBSD_6_2_BASE:1.89
	OPENBSD_6_1:1.88.0.4
	OPENBSD_6_1_BASE:1.88
	OPENBSD_6_0:1.86.0.2
	OPENBSD_6_0_BASE:1.86
	OPENBSD_5_9:1.85.0.2
	OPENBSD_5_9_BASE:1.85
	OPENBSD_5_8:1.84.0.4
	OPENBSD_5_8_BASE:1.84
	OPENBSD_5_7:1.83.0.2
	OPENBSD_5_7_BASE:1.83
	OPENBSD_5_6:1.78.0.4
	OPENBSD_5_6_BASE:1.78
	OPENBSD_5_5:1.76.0.6
	OPENBSD_5_5_BASE:1.76
	OPENBSD_5_4:1.76.0.2
	OPENBSD_5_4_BASE:1.76
	OPENBSD_5_3:1.75.0.2
	OPENBSD_5_3_BASE:1.75
	OPENBSD_5_2:1.74.0.2
	OPENBSD_5_2_BASE:1.74
	OPENBSD_5_1_BASE:1.69
	OPENBSD_5_1:1.69.0.4
	OPENBSD_5_0:1.69.0.2
	OPENBSD_5_0_BASE:1.69
	OPENBSD_4_9:1.67.0.4
	OPENBSD_4_9_BASE:1.67
	OPENBSD_4_8:1.67.0.2
	OPENBSD_4_8_BASE:1.67
	OPENBSD_4_7:1.65.0.2
	OPENBSD_4_7_BASE:1.65
	OPENBSD_4_6:1.64.0.4
	OPENBSD_4_6_BASE:1.64
	OPENBSD_4_5:1.63.0.6
	OPENBSD_4_5_BASE:1.63
	OPENBSD_4_4:1.63.0.4
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.63.0.2
	OPENBSD_4_3_BASE:1.63
	OPENBSD_4_2:1.62.0.2
	OPENBSD_4_2_BASE:1.62
	OPENBSD_4_1:1.57.0.2
	OPENBSD_4_1_BASE:1.57
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.51.0.2
	OPENBSD_3_9_BASE:1.51
	OPENBSD_3_8:1.49.0.2
	OPENBSD_3_8_BASE:1.49
	OPENBSD_3_7:1.47.0.2
	OPENBSD_3_7_BASE:1.47
	OPENBSD_3_6:1.43.0.2
	OPENBSD_3_6_BASE:1.43
	OPENBSD_3_5:1.37.0.2
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	OPENBSD_3_3:1.28.0.4
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	OPENBSD_3_0:1.25.0.2
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7;
locks; strict;
comment	@ * @;


1.89
date	2017.05.30.06.01.30;	author tedu;	state Exp;
branches;
next	1.88;
commitid	QvCS2lJV2IKmzIbb;

1.88
date	2017.03.15.04.24.14;	author deraadt;	state Exp;
branches;
next	1.87;
commitid	oL4eFXBEzCBQNxCU;

1.87
date	2016.07.28.21.45.00;	author tedu;	state Exp;
branches;
next	1.86;
commitid	3hWi1eSMMxmFQHQh;

1.86
date	2016.05.11.08.11.27;	author edd;	state Exp;
branches;
next	1.85;
commitid	dYywJegc3emWYNiH;

1.85
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.84;
commitid	0Dp7Dy9FuNZesYo2;

1.84
date	2015.05.06.07.53.29;	author mpi;	state Exp;
branches;
next	1.83;
commitid	Q6ompHwEqgonty8G;

1.83
date	2015.01.19.18.01.13;	author millert;	state Exp;
branches;
next	1.82;
commitid	gyCo1HmvlKsVnGu2;

1.82
date	2015.01.19.01.53.18;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	mxxIIZRu7wmyiSNE;

1.81
date	2015.01.16.06.40.13;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	Uu5nFG3wCl0LACBb;

1.80
date	2014.09.17.01.56.54;	author dlg;	state Exp;
branches;
next	1.79;
commitid	dV1NkTNsF7KrC3AE;

1.79
date	2014.09.15.19.08.21;	author miod;	state Exp;
branches;
next	1.78;
commitid	uuiU9j2I8AUx0fez;

1.78
date	2014.07.04.05.58.31;	author guenther;	state Exp;
branches;
next	1.77;
commitid	vhXZZxMGVTWiFaF3;

1.77
date	2014.04.08.14.04.11;	author mpi;	state Exp;
branches;
next	1.76;

1.76
date	2013.03.23.21.12.32;	author tedu;	state Exp;
branches;
next	1.75;

1.75
date	2012.12.18.21.28.45;	author millert;	state Exp;
branches;
next	1.74;

1.74
date	2012.07.09.22.41.45;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2012.06.05.18.52.53;	author brynet;	state Exp;
branches;
next	1.72;

1.72
date	2012.04.21.03.14.50;	author guenther;	state Exp;
branches;
next	1.71;

1.71
date	2012.04.17.23.17.53;	author pirofti;	state Exp;
branches;
next	1.70;

1.70
date	2012.04.12.14.59.19;	author pirofti;	state Exp;
branches;
next	1.69;

1.69
date	2011.07.12.14.57.53;	author tedu;	state Exp;
branches;
next	1.68;

1.68
date	2011.04.10.03.20.59;	author guenther;	state Exp;
branches;
next	1.67;

1.67
date	2010.04.26.00.30.58;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2010.03.26.05.10.50;	author lum;	state Exp;
branches;
next	1.65;

1.65
date	2010.01.29.00.36.09;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2009.04.28.21.24.41;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2007.11.01.19.19.48;	author otto;	state Exp;
branches;
next	1.62;

1.62
date	2007.07.27.13.57.50;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.29.00.56.56;	author otto;	state Exp;
branches;
next	1.60;

1.60
date	2007.04.16.11.49.51;	author otto;	state Exp;
branches;
next	1.59;

1.59
date	2007.04.13.19.19.54;	author otto;	state Exp;
branches;
next	1.58;

1.58
date	2007.04.04.19.24.18;	author otto;	state Exp;
branches;
next	1.57;

1.57
date	2007.02.04.14.58.45;	author otto;	state Exp;
branches;
next	1.56;

1.56
date	2007.01.03.18.57.49;	author otto;	state Exp;
branches;
next	1.55;

1.55
date	2007.01.02.19.09.24;	author otto;	state Exp;
branches;
next	1.54;

1.54
date	2006.11.29.12.34.22;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2006.09.20.21.26.20;	author ray;	state Exp;
branches;
next	1.52;

1.52
date	2006.04.29.14.40.44;	author otto;	state Exp;
branches;
next	1.51;

1.51
date	2005.12.21.01.40.24;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.04.23.10.06;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2005.06.17.09.40.48;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2005.06.08.22.36.43;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.06.15.57.04;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2004.11.22.15.26.53;	author pat;	state Exp;
branches;
next	1.45;

1.45
date	2004.11.17.09.22.43;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2004.10.07.06.26.12;	author otto;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.13.18.49.02;	author otto;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.11.16.08.54;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.11.05.29.28;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2004.06.11.01.32.11;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.11.01.00.58;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.09.22.14.15;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.08.18.15.06;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.07.21.36.52;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.18.08.36.31;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.17.00.51.29;	author jfb;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.15.16.24.44;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.14.20.23.41;	author avsm;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.13.21.52.24;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.12.23.09.29;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.12.22.30.23;	author pvalchev;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.02.03.05.47;	author tholo;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.16.21.27.55;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.05.02.29.19;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.12.05.17.26;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.03.06.46.47;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.22.03.10.24;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.17.23.01.40;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.17.22.55.07;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.17.22.51.26;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.18.17.59.56;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	99.11.14.09.03.46;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.10.29.08.58.43;	author todd;	state Exp;
branches;
next	1.16;

1.16
date	99.06.21.20.48.01;	author art;	state Exp;
branches;
next	1.15;

1.15
date	99.05.22.21.42.26;	author weingart;	state Exp;
branches;
next	1.14;

1.14
date	98.11.28.02.37.35;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	98.09.20.06.19.14;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	98.09.20.05.58.54;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	98.08.21.13.55.23;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	98.07.08.22.14.16;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.06.25.16.54.35;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.11.08.23.36.44;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.09.09.15.23.13;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.09.14.58.21;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.08.24.18.37.46;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.08.22.07.39.27;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.08.22.07.16.28;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.08.17.23.18.47;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	97.08.14.14.00.22;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.89
log
@avoid some shadow warnings. from Brian Callahan
@
text
@/* $OpenBSD: machine.c,v 1.88 2017/03/15 04:24:14 deraadt Exp $	 */

/*-
 * Copyright (c) 1994 Thorsten Lockert <tholo@@sigmasoft.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * AUTHOR:  Thorsten Lockert <tholo@@sigmasoft.com>
 *          Adapted from BSD4.4 by Christos Zoulas <christos@@ee.cornell.edu>
 *          Patch for process wait display by Jarl F. Greipsland <jarle@@idt.unit.no>
 *	    Patch for -DORDER by Kenneth Stailey <kstailey@@disclosure.com>
 *	    Patch for new swapctl(2) by Tobias Weingartner <weingart@@openbsd.org>
 */

#include <sys/param.h>	/* DEV_BSIZE MAXCOMLEN PZERO */
#include <sys/types.h>
#include <sys/signal.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/sched.h>
#include <sys/swap.h>
#include <sys/sysctl.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <err.h>
#include <errno.h>

#include "top.h"
#include "display.h"
#include "machine.h"
#include "utils.h"

static int	swapmode(int *, int *);
static char	*state_abbr(struct kinfo_proc *);
static char	*format_comm(struct kinfo_proc *);
static int	cmd_matches(struct kinfo_proc *, char *);
static char	**get_proc_args(struct kinfo_proc *);

/* get_process_info passes back a handle.  This is what it looks like: */

struct handle {
	struct kinfo_proc **next_proc;	/* points to next valid proc pointer */
	int		remaining;	/* number of pointers remaining */
};

/* what we consider to be process size: */
#define PROCSIZE(pp) ((pp)->p_vm_tsize + (pp)->p_vm_dsize + (pp)->p_vm_ssize)

/*
 *  These definitions control the format of the per-process area
 */
static char header[] =
	"  PID X        PRI NICE  SIZE   RES STATE     WAIT      TIME    CPU COMMAND";

/* 0123456   -- field to fill in starts at header+6 */
#define UNAME_START 6

#define Proc_format \
	"%5d %-8.8s %3d %4d %5s %5s %-9s %-7.7s %6s %5.2f%% %s"

/* process state names for the "STATE" column of the display */
/*
 * the extra nulls in the string "run" are for adding a slash and the
 * processor number when needed
 */

char	*state_abbrev[] = {
	"", "start", "run", "sleep", "stop", "zomb", "dead", "onproc"
};

/* these are for calculating cpu state percentages */
static int64_t	**cp_time;
static int64_t	**cp_old;
static int64_t	**cp_diff;

/* these are for detailing the process states */
int process_states[8];
char *procstatenames[] = {
	"", " starting, ", " running, ", " idle, ",
	" stopped, ", " zombie, ", " dead, ", " on processor, ",
	NULL
};

/* these are for detailing the cpu states */
int64_t *cpu_states;
char *cpustatenames[] = {
	"user", "nice", "system", "interrupt", "idle", NULL
};

/* these are for detailing the memory statistics */
int memory_stats[10];
char *memorynames[] = {
	"Real: ", "K/", "K act/tot ", "Free: ", "K ",
	"Cache: ", "K ",
	"Swap: ", "K/", "K",
	NULL
};

/* these are names given to allowed sorting orders -- first is default */
char	*ordernames[] = {
	"cpu", "size", "res", "time", "pri", "pid", "command", NULL
};

/* these are for keeping track of the proc array */
static int	nproc;
static int	onproc = -1;
static int	pref_len;
static struct kinfo_proc *pbase;
static struct kinfo_proc **pref;

/* these are for getting the memory statistics */
static int	pageshift;	/* log base 2 of the pagesize */

/* define pagetok in terms of pageshift */
#define pagetok(size) ((size) << pageshift)

int		ncpu;
int		fscale;

unsigned int	maxslp;

int
getfscale(void)
{
	int mib[] = { CTL_KERN, KERN_FSCALE };
	size_t size = sizeof(fscale);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &fscale, &size, NULL, 0) < 0)
		return (-1);
	return fscale;
}

int
getncpu(void)
{
	int mib[] = { CTL_HW, HW_NCPU };
	int numcpu;
	size_t size = sizeof(numcpu);

	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    &numcpu, &size, NULL, 0) == -1)
		return (-1);

	return (numcpu);
}

int
machine_init(struct statics *statics)
{
	int pagesize, cpu;

	ncpu = getncpu();
	if (ncpu == -1)
		return (-1);
	if (getfscale() == -1)
		return (-1);
	cpu_states = calloc(ncpu, CPUSTATES * sizeof(int64_t));
	if (cpu_states == NULL)
		err(1, NULL);
	cp_time = calloc(ncpu, sizeof(int64_t *));
	cp_old  = calloc(ncpu, sizeof(int64_t *));
	cp_diff = calloc(ncpu, sizeof(int64_t *));
	if (cp_time == NULL || cp_old == NULL || cp_diff == NULL)
		err(1, NULL);
	for (cpu = 0; cpu < ncpu; cpu++) {
		cp_time[cpu] = calloc(CPUSTATES, sizeof(int64_t));
		cp_old[cpu] = calloc(CPUSTATES, sizeof(int64_t));
		cp_diff[cpu] = calloc(CPUSTATES, sizeof(int64_t));
		if (cp_time[cpu] == NULL || cp_old[cpu] == NULL ||
		    cp_diff[cpu] == NULL)
			err(1, NULL);
	}

	pbase = NULL;
	pref = NULL;
	onproc = -1;
	nproc = 0;

	/*
	 * get the page size with "getpagesize" and calculate pageshift from
	 * it
	 */
	pagesize = getpagesize();
	pageshift = 0;
	while (pagesize > 1) {
		pageshift++;
		pagesize >>= 1;
	}

	/* we only need the amount of log(2)1024 for our conversion */
	pageshift -= LOG1024;

	/* fill in the statics information */
	statics->procstate_names = procstatenames;
	statics->cpustate_names = cpustatenames;
	statics->memory_names = memorynames;
	statics->order_names = ordernames;
	return (0);
}

char *
format_header(char *second_field, int show_threads)
{
	char *field_name, *thread_field = "     TID";
	char *ptr;

	if (show_threads)
		field_name = thread_field;
	else
		field_name = second_field;

	ptr = header + UNAME_START;
	while (*field_name != '\0')
		*ptr++ = *field_name++;
	return (header);
}

void
get_system_info(struct system_info *si)
{
	static int sysload_mib[] = {CTL_VM, VM_LOADAVG};
	static int uvmexp_mib[] = {CTL_VM, VM_UVMEXP};
	static int bcstats_mib[] = {CTL_VFS, VFS_GENERIC, VFS_BCACHESTAT};
	struct loadavg sysload;
	struct uvmexp uvmexp;
	struct bcachestats bcstats;
	double *infoloadp;
	size_t size;
	int i;
	int64_t *tmpstate;

	if (ncpu > 1) {
		int cp_time_mib[] = {CTL_KERN, KERN_CPTIME2, /*fillme*/0};

		size = CPUSTATES * sizeof(int64_t);
		for (i = 0; i < ncpu; i++) {
			cp_time_mib[2] = i;
			tmpstate = cpu_states + (CPUSTATES * i);
			if (sysctl(cp_time_mib, 3, cp_time[i], &size, NULL, 0) < 0)
				warn("sysctl kern.cp_time2 failed");
			/* convert cp_time2 counts to percentages */
			(void) percentages(CPUSTATES, tmpstate, cp_time[i],
			    cp_old[i], cp_diff[i]);
		}
	} else {
		int cp_time_mib[] = {CTL_KERN, KERN_CPTIME};
		long cp_time_tmp[CPUSTATES];

		size = sizeof(cp_time_tmp);
		if (sysctl(cp_time_mib, 2, cp_time_tmp, &size, NULL, 0) < 0)
			warn("sysctl kern.cp_time failed");
		for (i = 0; i < CPUSTATES; i++)
			cp_time[0][i] = cp_time_tmp[i];
		/* convert cp_time counts to percentages */
		(void) percentages(CPUSTATES, cpu_states, cp_time[0],
		    cp_old[0], cp_diff[0]);
	}

	size = sizeof(sysload);
	if (sysctl(sysload_mib, 2, &sysload, &size, NULL, 0) < 0)
		warn("sysctl failed");
	infoloadp = si->load_avg;
	for (i = 0; i < 3; i++)
		*infoloadp++ = ((double) sysload.ldavg[i]) / sysload.fscale;


	/* get total -- systemwide main memory usage structure */
	size = sizeof(uvmexp);
	if (sysctl(uvmexp_mib, 2, &uvmexp, &size, NULL, 0) < 0) {
		warn("sysctl failed");
		bzero(&uvmexp, sizeof(uvmexp));
	}
	size = sizeof(bcstats);
	if (sysctl(bcstats_mib, 3, &bcstats, &size, NULL, 0) < 0) {
		warn("sysctl failed");
		bzero(&bcstats, sizeof(bcstats));
	}
	/* convert memory stats to Kbytes */
	memory_stats[0] = -1;
	memory_stats[1] = pagetok(uvmexp.active);
	memory_stats[2] = pagetok(uvmexp.npages - uvmexp.free);
	memory_stats[3] = -1;
	memory_stats[4] = pagetok(uvmexp.free);
	memory_stats[5] = -1;
	memory_stats[6] = pagetok(bcstats.numbufpages);
	memory_stats[7] = -1;

	if (!swapmode(&memory_stats[8], &memory_stats[9])) {
		memory_stats[8] = 0;
		memory_stats[9] = 0;
	}

	/* set arrays and strings */
	si->cpustates = cpu_states;
	si->memory = memory_stats;
	si->last_pid = -1;
}

static struct handle handle;

struct kinfo_proc *
getprocs(int op, int arg, int *cnt)
{
	size_t size;
	int mib[6] = {CTL_KERN, KERN_PROC, 0, 0, sizeof(struct kinfo_proc), 0};
	static int maxslp_mib[] = {CTL_VM, VM_MAXSLP};
	static struct kinfo_proc *procbase;
	int st;

	mib[2] = op;
	mib[3] = arg;

	size = sizeof(maxslp);
	if (sysctl(maxslp_mib, 2, &maxslp, &size, NULL, 0) < 0) {
		warn("sysctl vm.maxslp failed");
		return (0);
	}
    retry:
	free(procbase);
	st = sysctl(mib, 6, NULL, &size, NULL, 0);
	if (st == -1) {
		/* _kvm_syserr(kd, kd->program, "kvm_getprocs"); */
		return (0);
	}
	size = 5 * size / 4;			/* extra slop */
	if ((procbase = malloc(size)) == NULL)
		return (0);
	mib[5] = (int)(size / sizeof(struct kinfo_proc));
	st = sysctl(mib, 6, procbase, &size, NULL, 0);
	if (st == -1) {
		if (errno == ENOMEM)
			goto retry;
		/* _kvm_syserr(kd, kd->program, "kvm_getprocs"); */
		return (0);
	}
	*cnt = (int)(size / sizeof(struct kinfo_proc));
	return (procbase);
}

static char **
get_proc_args(struct kinfo_proc *kp)
{
	static char	**s;
	static size_t	siz = 1023;
	int		mib[4];

	if (!s && !(s = malloc(siz)))
		err(1, NULL);

	mib[0] = CTL_KERN;
	mib[1] = KERN_PROC_ARGS;
	mib[2] = kp->p_pid;
	mib[3] = KERN_PROC_ARGV;
	for (;;) {
		size_t space = siz;
		if (sysctl(mib, 4, s, &space, NULL, 0) == 0)
			break;
		if (errno != ENOMEM)
			return NULL;
		siz *= 2;
		if ((s = realloc(s, siz)) == NULL)
			err(1, NULL);
	}
	return s;
}

static int
cmd_matches(struct kinfo_proc *proc, char *term)
{
	extern int	show_args;
	char		**args = NULL;

	if (!term) {
		/* No command filter set */
		return 1;
	} else {
		/* Filter set, process name needs to contain term */
		if (strstr(proc->p_comm, term))
			return 1;
		/* If showing arguments, search those as well */
		if (show_args) {
			args = get_proc_args(proc);

			if (args == NULL) {
				/* Failed to get args, so can't search them */
				return 0;
			}

			while (*args != NULL) {
				if (strstr(*args, term))
					return 1;
				args++;
			}
		}
	}
	return 0;
}

caddr_t
get_process_info(struct system_info *si, struct process_select *sel,
    int (*compare) (const void *, const void *))
{
	int show_idle, show_system, show_threads, show_uid, show_pid, show_cmd;
	int hide_uid;
	int total_procs, active_procs;
	struct kinfo_proc **prefp, *pp;
	int what = KERN_PROC_KTHREAD;

	if (sel->threads)
		what |= KERN_PROC_SHOW_THREADS;

	if ((pbase = getprocs(what, 0, &nproc)) == NULL) {
		/* warnx("%s", kvm_geterr(kd)); */
		quit(23);
	}
	if (nproc > onproc)
		pref = reallocarray(pref, (onproc = nproc),
		    sizeof(struct kinfo_proc *));
	if (pref == NULL) {
		warnx("Out of memory.");
		quit(23);
	}
	/* get a pointer to the states summary array */
	si->procstates = process_states;

	/* set up flags which define what we are going to select */
	show_idle = sel->idle;
	show_system = sel->system;
	show_threads = sel->threads;
	show_uid = sel->uid != (uid_t)-1;
	hide_uid = sel->huid != (uid_t)-1;
	show_pid = sel->pid != (pid_t)-1;
	show_cmd = sel->command != NULL;

	/* count up process states and get pointers to interesting procs */
	total_procs = 0;
	active_procs = 0;
	memset((char *) process_states, 0, sizeof(process_states));
	prefp = pref;
	for (pp = pbase; pp < &pbase[nproc]; pp++) {
		/*
		 *  Place pointers to each valid proc structure in pref[].
		 *  Process slots that are actually in use have a non-zero
		 *  status field.  Processes with P_SYSTEM set are system
		 *  processes---these get ignored unless show_system is set.
		 */
		if (show_threads && pp->p_tid == -1)
			continue;
		if (pp->p_stat != 0 &&
		    (show_system || (pp->p_flag & P_SYSTEM) == 0) &&
		    (show_threads || (pp->p_flag & P_THREAD) == 0)) {
			total_procs++;
			process_states[(unsigned char) pp->p_stat]++;
			if ((pp->p_psflags & PS_ZOMBIE) == 0 &&
			    (show_idle || pp->p_pctcpu != 0 ||
			    pp->p_stat == SRUN) &&
			    (!hide_uid || pp->p_ruid != sel->huid) &&
			    (!show_uid || pp->p_ruid == sel->uid) &&
			    (!show_pid || pp->p_pid == sel->pid) &&
			    (!show_cmd || cmd_matches(pp, sel->command))) {
				*prefp++ = pp;
				active_procs++;
			}
		}
	}

	/* if requested, sort the "interesting" processes */
	if (compare != NULL)
		qsort((char *) pref, active_procs,
		    sizeof(struct kinfo_proc *), compare);
	/* remember active and total counts */
	si->p_total = total_procs;
	si->p_active = pref_len = active_procs;

	/* pass back a handle */
	handle.next_proc = pref;
	handle.remaining = active_procs;
	return ((caddr_t) & handle);
}

char fmt[MAX_COLS];	/* static area where result is built */

static char *
state_abbr(struct kinfo_proc *pp)
{
	static char buf[10];

	if (ncpu > 1 && pp->p_cpuid != KI_NOCPU)
		snprintf(buf, sizeof buf, "%s/%llu",
		    state_abbrev[(unsigned char)pp->p_stat], pp->p_cpuid);
	else
		snprintf(buf, sizeof buf, "%s",
		    state_abbrev[(unsigned char)pp->p_stat]);
	return buf;
}

static char *
format_comm(struct kinfo_proc *kp)
{
	static char	buf[MAX_COLS];
	char		**p, **s;
	extern int	show_args;

	if (!show_args)
		return (kp->p_comm);

	s = get_proc_args(kp);
	if (s == NULL)
		return kp->p_comm;

	buf[0] = '\0';
	for (p = s; *p != NULL; p++) {
		if (p != s)
			strlcat(buf, " ", sizeof(buf));
		strlcat(buf, *p, sizeof(buf));
	}
	if (buf[0] == '\0')
		return (kp->p_comm);
	return (buf);
}

char *
format_next_process(caddr_t hndl, char *(*get_userid)(uid_t), pid_t *pid,
    int show_threads)
{
	char *p_wait;
	struct kinfo_proc *pp;
	struct handle *hp;
	int cputime;
	double pct;
	char buf[16];

	/* find and remember the next proc structure */
	hp = (struct handle *) hndl;
	pp = *(hp->next_proc++);
	hp->remaining--;

	cputime = pp->p_rtime_sec + ((pp->p_rtime_usec + 500000) / 1000000);

	/* calculate the base for cpu percentages */
	pct = (double)pp->p_pctcpu / fscale;

	if (pp->p_wmesg[0])
		p_wait = pp->p_wmesg;
	else
		p_wait = "-";

	if (show_threads)
		snprintf(buf, sizeof(buf), "%8d", pp->p_tid);
	else
		snprintf(buf, sizeof(buf), "%s", (*get_userid)(pp->p_ruid));

	/* format this entry */
	snprintf(fmt, sizeof(fmt), Proc_format, pp->p_pid, buf,
	    pp->p_priority - PZERO, pp->p_nice - NZERO,
	    format_k(pagetok(PROCSIZE(pp))),
	    format_k(pagetok(pp->p_vm_rssize)),
	    (pp->p_stat == SSLEEP && pp->p_slptime > maxslp) ?
	    "idle" : state_abbr(pp),
	    p_wait, format_time(cputime), 100.0 * pct,
	    printable(format_comm(pp)));

	*pid = pp->p_pid;
	/* return the result */
	return (fmt);
}

/* comparison routine for qsort */
static unsigned char sorted_state[] =
{
	0,			/* not used		 */
	4,			/* start		 */
	5,			/* run			 */
	2,			/* sleep		 */
	3,			/* stop			 */
	1			/* zombie		 */
};

/*
 *  proc_compares - comparison functions for "qsort"
 */

/*
 * First, the possible comparison keys.  These are defined in such a way
 * that they can be merely listed in the source code to define the actual
 * desired ordering.
 */

#define ORDERKEY_PCTCPU \
	if ((result = (int)(p2->p_pctcpu - p1->p_pctcpu)) == 0)
#define ORDERKEY_CPUTIME \
	if ((result = p2->p_rtime_sec - p1->p_rtime_sec) == 0) \
		if ((result = p2->p_rtime_usec - p1->p_rtime_usec) == 0)
#define ORDERKEY_STATE \
	if ((result = sorted_state[(unsigned char)p2->p_stat] - \
	    sorted_state[(unsigned char)p1->p_stat])  == 0)
#define ORDERKEY_PRIO \
	if ((result = p2->p_priority - p1->p_priority) == 0)
#define ORDERKEY_RSSIZE \
	if ((result = p2->p_vm_rssize - p1->p_vm_rssize) == 0)
#define ORDERKEY_MEM \
	if ((result = PROCSIZE(p2) - PROCSIZE(p1)) == 0)
#define ORDERKEY_PID \
	if ((result = p1->p_pid - p2->p_pid) == 0)
#define ORDERKEY_CMD \
	if ((result = strcmp(p1->p_comm, p2->p_comm)) == 0)

/* compare_cpu - the comparison function for sorting by cpu percentage */
static int
compare_cpu(const void *v1, const void *v2)
{
	struct proc **pp1 = (struct proc **) v1;
	struct proc **pp2 = (struct proc **) v2;
	struct kinfo_proc *p1, *p2;
	int result;

	/* remove one level of indirection */
	p1 = *(struct kinfo_proc **) pp1;
	p2 = *(struct kinfo_proc **) pp2;

	ORDERKEY_PCTCPU
	ORDERKEY_CPUTIME
	ORDERKEY_STATE
	ORDERKEY_PRIO
	ORDERKEY_RSSIZE
	ORDERKEY_MEM
		;
	return (result);
}

/* compare_size - the comparison function for sorting by total memory usage */
static int
compare_size(const void *v1, const void *v2)
{
	struct proc **pp1 = (struct proc **) v1;
	struct proc **pp2 = (struct proc **) v2;
	struct kinfo_proc *p1, *p2;
	int result;

	/* remove one level of indirection */
	p1 = *(struct kinfo_proc **) pp1;
	p2 = *(struct kinfo_proc **) pp2;

	ORDERKEY_MEM
	ORDERKEY_RSSIZE
	ORDERKEY_PCTCPU
	ORDERKEY_CPUTIME
	ORDERKEY_STATE
	ORDERKEY_PRIO
		;
	return (result);
}

/* compare_res - the comparison function for sorting by resident set size */
static int
compare_res(const void *v1, const void *v2)
{
	struct proc **pp1 = (struct proc **) v1;
	struct proc **pp2 = (struct proc **) v2;
	struct kinfo_proc *p1, *p2;
	int result;

	/* remove one level of indirection */
	p1 = *(struct kinfo_proc **) pp1;
	p2 = *(struct kinfo_proc **) pp2;

	ORDERKEY_RSSIZE
	ORDERKEY_MEM
	ORDERKEY_PCTCPU
	ORDERKEY_CPUTIME
	ORDERKEY_STATE
	ORDERKEY_PRIO
		;
	return (result);
}

/* compare_time - the comparison function for sorting by CPU time */
static int
compare_time(const void *v1, const void *v2)
{
	struct proc **pp1 = (struct proc **) v1;
	struct proc **pp2 = (struct proc **) v2;
	struct kinfo_proc *p1, *p2;
	int result;

	/* remove one level of indirection */
	p1 = *(struct kinfo_proc **) pp1;
	p2 = *(struct kinfo_proc **) pp2;

	ORDERKEY_CPUTIME
	ORDERKEY_PCTCPU
	ORDERKEY_STATE
	ORDERKEY_PRIO
	ORDERKEY_MEM
	ORDERKEY_RSSIZE
		;
	return (result);
}

/* compare_prio - the comparison function for sorting by CPU time */
static int
compare_prio(const void *v1, const void *v2)
{
	struct proc   **pp1 = (struct proc **) v1;
	struct proc   **pp2 = (struct proc **) v2;
	struct kinfo_proc *p1, *p2;
	int result;

	/* remove one level of indirection */
	p1 = *(struct kinfo_proc **) pp1;
	p2 = *(struct kinfo_proc **) pp2;

	ORDERKEY_PRIO
	ORDERKEY_PCTCPU
	ORDERKEY_CPUTIME
	ORDERKEY_STATE
	ORDERKEY_RSSIZE
	ORDERKEY_MEM
		;
	return (result);
}

static int
compare_pid(const void *v1, const void *v2)
{
	struct proc **pp1 = (struct proc **) v1;
	struct proc **pp2 = (struct proc **) v2;
	struct kinfo_proc *p1, *p2;
	int result;

	/* remove one level of indirection */
	p1 = *(struct kinfo_proc **) pp1;
	p2 = *(struct kinfo_proc **) pp2;

	ORDERKEY_PID
	ORDERKEY_PCTCPU
	ORDERKEY_CPUTIME
	ORDERKEY_STATE
	ORDERKEY_PRIO
	ORDERKEY_RSSIZE
	ORDERKEY_MEM
		;
	return (result);
}

static int
compare_cmd(const void *v1, const void *v2)
{
	struct proc **pp1 = (struct proc **) v1;
	struct proc **pp2 = (struct proc **) v2;
	struct kinfo_proc *p1, *p2;
	int result;

	/* remove one level of indirection */
	p1 = *(struct kinfo_proc **) pp1;
	p2 = *(struct kinfo_proc **) pp2;

	ORDERKEY_CMD
	ORDERKEY_PCTCPU
	ORDERKEY_CPUTIME
	ORDERKEY_STATE
	ORDERKEY_PRIO
	ORDERKEY_RSSIZE
	ORDERKEY_MEM
		;
	return (result);
}


int (*proc_compares[])(const void *, const void *) = {
	compare_cpu,
	compare_size,
	compare_res,
	compare_time,
	compare_prio,
	compare_pid,
	compare_cmd,
	NULL
};

/*
 * proc_owner(pid) - returns the uid that owns process "pid", or -1 if
 *		the process does not exist.
 *		It is EXTREMELY IMPORTANT that this function work correctly.
 *		If top runs setuid root (as in SVR4), then this function
 *		is the only thing that stands in the way of a serious
 *		security problem.  It validates requests for the "kill"
 *		and "renice" commands.
 */
uid_t
proc_owner(pid_t pid)
{
	struct kinfo_proc **prefp, *pp;
	int cnt;

	prefp = pref;
	cnt = pref_len;
	while (--cnt >= 0) {
		pp = *prefp++;
		if (pp->p_pid == pid)
			return ((uid_t)pp->p_ruid);
	}
	return (uid_t)(-1);
}

/*
 * swapmode is rewritten by Tobias Weingartner <weingart@@openbsd.org>
 * to be based on the new swapctl(2) system call.
 */
static int
swapmode(int *used, int *total)
{
	struct swapent *swdev;
	int nswap, rnswap, i;

	nswap = swapctl(SWAP_NSWAP, 0, 0);
	if (nswap == 0)
		return 0;

	swdev = calloc(nswap, sizeof(*swdev));
	if (swdev == NULL)
		return 0;

	rnswap = swapctl(SWAP_STATS, swdev, nswap);
	if (rnswap == -1) {
		free(swdev);
		return 0;
	}

	/* if rnswap != nswap, then what? */

	/* Total things up */
	*total = *used = 0;
	for (i = 0; i < nswap; i++) {
		if (swdev[i].se_flags & SWF_ENABLE) {
			*used += (swdev[i].se_inuse / (1024 / DEV_BSIZE));
			*total += (swdev[i].se_nblks / (1024 / DEV_BSIZE));
		}
	}
	free(swdev);
	return 1;
}
@


1.88
log
@annoying whitespace die die die
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.87 2016/07/28 21:45:00 tedu Exp $	 */
d162 2
a163 2
	int ncpu;
	size_t size = sizeof(ncpu);
d166 1
a166 1
	    &ncpu, &size, NULL, 0) == -1)
d169 1
a169 1
	return (ncpu);
d548 1
a548 1
format_next_process(caddr_t handle, char *(*get_userid)(uid_t), pid_t *pid,
d559 1
a559 1
	hp = (struct handle *) handle;
@


1.87
log
@rework realloc loop. there's no need to shrink the allocation between
calls. if we need a big space once, we'll likely need a big space again.
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.86 2016/05/11 08:11:27 edd Exp $	 */
d96 3
a98 3
static int64_t     **cp_time;
static int64_t     **cp_old;
static int64_t     **cp_diff;
d129 3
a131 3
static int      nproc;
static int      onproc = -1;
static int      pref_len;
d136 1
a136 1
static int      pageshift;	/* log base 2 of the pagesize */
@


1.86
log
@Allow top(1) to filter process args if they are being displayed.

OK tedu@@, deraadt@@, and with input from Michal Mazurek.

Thanks
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.85 2015/08/20 22:32:42 deraadt Exp $	 */
d369 1
a369 1
	size_t		siz = 100;
d372 10
a381 8
	for (;; siz *= 2) {
		if ((s = realloc(s, siz)) == NULL)
			err(1, NULL);
		mib[0] = CTL_KERN;
		mib[1] = KERN_PROC_ARGS;
		mib[2] = kp->p_pid;
		mib[3] = KERN_PROC_ARGV;
		if (sysctl(mib, 4, s, &siz, NULL, 0) == 0)
d385 3
@


1.85
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.84 2015/05/06 07:53:29 mpi Exp $	 */
d60 2
d365 54
d480 1
a480 2
			    (!show_cmd || strstr(pp->p_comm,
				sel->command))) {
d520 3
a522 5
	static char **s, buf[MAX_COLS];
	size_t siz = 100;
	char **p;
	int mib[4];
	extern int show_args;
d527 4
a530 12
	for (;; siz *= 2) {
		if ((s = realloc(s, siz)) == NULL)
			err(1, NULL);
		mib[0] = CTL_KERN;
		mib[1] = KERN_PROC_ARGS;
		mib[2] = kp->p_pid;
		mib[3] = KERN_PROC_ARGV;
		if (sysctl(mib, 4, s, &siz, NULL, 0) == 0)
			break;
		if (errno != ENOMEM)
			return (kp->p_comm);
	}
@


1.84
log
@Display thread IDs instead of the name of the process's owner when "-H"
is used.

The rationnal is that when you're looking at threads you're generally
already filtereing by PID and this allow you to see which thread is a
pig.

Written some time ago with mikeb@@

ok sthen@@, krw@@, guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.83 2015/01/19 18:01:13 millert Exp $	 */
d381 2
a382 2
		pref = (struct kinfo_proc **)realloc(pref,
		    sizeof(struct kinfo_proc *) * (onproc = nproc));
@


1.83
log
@Kill loadavg.h and just use the fscale value directly.
There's no need for crazy casts of p_pctcpu in ORDERKEY_PCTCPU
since kinfo_proc exports it as uint32_t.  OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.82 2015/01/19 01:53:18 deraadt Exp $	 */
d225 1
a225 1
format_header(char *uname_field)
d227 1
d230 5
d236 2
a237 2
	while (*uname_field != '\0')
		*ptr++ = *uname_field++;
d498 2
a499 1
format_next_process(caddr_t handle, char *(*get_userid)(uid_t), pid_t *pid)
d506 1
d523 5
d529 1
a529 2
	snprintf(fmt, sizeof fmt, Proc_format,
	    pp->p_pid, (*get_userid)(pp->p_ruid),
@


1.82
log
@like in ps(1), fetch the FSCALE value using sysctl rather than using
the header version
ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.81 2015/01/16 06:40:13 deraadt Exp $	 */
a55 1
#include "loadavg.h"
d508 1
a508 1
	pct = pctdouble(pp->p_pctcpu);
d553 1
a553 2
	if (lresult = (pctcpu)p2->p_pctcpu - (pctcpu)p1->p_pctcpu, \
	    (result = lresult > 0 ? 1 : lresult < 0 ? -1 : 0) == 0)
a577 1
	pctcpu lresult;
a600 1
	pctcpu lresult;
a623 1
	pctcpu lresult;
a646 1
	pctcpu lresult;
a669 1
	pctcpu lresult;
a691 1
	pctcpu lresult;
a714 1
	pctcpu lresult;
@


1.81
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.80 2014/09/17 01:56:54 dlg Exp $	 */
d141 1
d146 12
d178 2
@


1.80
log
@if there are more than 8 cpus, default to combined cpu stats (like
you passed -1 on the command line).

ok kettenis@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.79 2014/09/15 19:08:21 miod Exp $	 */
d36 1
d38 1
a38 1
#include <sys/param.h>
@


1.79
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.78 2014/07/04 05:58:31 guenther Exp $	 */
d144 14
d160 1
a160 2
	size_t size = sizeof(ncpu);
	int mib[2], pagesize, cpu;
d162 2
a163 3
	mib[0] = CTL_HW;
	mib[1] = HW_NCPU;
	if (sysctl(mib, 2, &ncpu, &size, NULL, 0) == -1)
@


1.78
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.77 2014/04/08 14:04:11 mpi Exp $	 */
a37 1
#include <sys/dkstat.h>
d40 1
@


1.77
log
@Use VM_UVMEXP instead of VM_METER for memory usages and directly
include <sys/vmmeter.h> where it is needed instead of relying on
it being included by <uvm/uvm_extern.h>.

miod@@ likes it, ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.76 2013/03/23 21:12:32 tedu Exp $	 */
d385 1
a385 1
			if (pp->p_stat != SZOMB &&
@


1.76
log
@wchan is no longer exposed, just check if wmesg is not empty.
(wmesg hasn't itself been a pointer since conversion to kinfo_proc.)
noticed by sthen.
ok deraadt jsing millert sthen
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.75 2012/12/18 21:28:45 millert Exp $	 */
d212 1
a212 1
	static int vmtotal_mib[] = {CTL_VM, VM_METER};
d215 1
a215 1
	struct vmtotal vmtotal;
d258 2
a259 2
	size = sizeof(vmtotal);
	if (sysctl(vmtotal_mib, 2, &vmtotal, &size, NULL, 0) < 0) {
d261 1
a261 1
		bzero(&vmtotal, sizeof(vmtotal));
d270 2
a271 2
	memory_stats[1] = pagetok(vmtotal.t_arm);
	memory_stats[2] = pagetok(vmtotal.t_rm);
d273 1
a273 1
	memory_stats[4] = pagetok(vmtotal.t_free);
@


1.75
log
@We no longer use struct eproc for kinfo_proc in sysctl.h so there
is no direct need for sys/proc.h or sys/resource.h.  Some consumers
of kinfo_proc need these for the proc flags and rlimit defines like
RLIM_INF so add the appropriate includes to them.
OK deraadt@@ sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.74 2012/07/09 22:41:45 deraadt Exp $	 */
d467 1
a467 1
	char *p_wait, waddr[sizeof(void *) * 2 + 3];	/* Hexify void pointer */
d483 3
a485 9
	if (pp->p_wchan) {
		if (pp->p_wmesg)
			p_wait = pp->p_wmesg;
		else {
			snprintf(waddr, sizeof(waddr), "%llx",
			    (unsigned long long)pp->p_wchan);
			p_wait = waddr;
		}
	} else
@


1.74
log
@According to miod, KERNBASE used as a userland symbol should die
in a fire.  Start by removing the definitions, before we clean the
headers later.
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.73 2012/06/05 18:52:53 brynet Exp $	 */
d38 6
a47 4
#include <sys/sysctl.h>
#include <sys/dkstat.h>
#include <sys/mount.h>
#include <sys/swap.h>
@


1.73
log
@Add support for hiding a user's processes in top.

feedback & ok lum@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.72 2012/04/21 03:14:50 guenther Exp $	 */
d486 1
a486 1
			    (unsigned long long)(pp->p_wchan & ~KERNBASE));
@


1.72
log
@Remove a check made superfluous by the KERN_PROC_SHOW_THREADS flag.
This lets new binaries work (at least w/o the -H option) with old kernels.

ok pirofti@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.71 2012/04/17 23:17:53 pirofti Exp $	 */
d333 1
d360 1
d386 1
@


1.71
log
@Make it optional for kvm_getprocs() (and related sysctl) to return
thread information.

Add a KERN_PROC_SHOW_THREADS flag that has to be set in order to get the
thread info and make it off by default. This creates backwards compatibility
for applications that relied on a given size/number of items to be returned.

Modify ps(1) and top(1) accordingly.

Okay guenther@@.
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.70 2012/04/12 14:59:19 pirofti Exp $	 */
a373 2
		if (!show_threads && pp->p_tid != -1)
			continue;
@


1.70
log
@Add per thread accounting, mainly for usage & friends.

This expands the already bloated FILL_KPROC macro to take an extra
parameter that indicates if the callee is a thread or a process.

The userland bits are adjusted accordingly and ps(1) and top(1) now
display per thread usage times when -H is used.

Also pkill(1) had to be adjusted so that duplicates don't pop up.

libkvm does basically the same thing as the kernel bits.

Okay guenther@@.
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.69 2011/07/12 14:57:53 tedu Exp $	 */
d335 1
d337 4
a340 1
	if ((pbase = getprocs(KERN_PROC_KTHREAD, 0, &nproc)) == NULL) {
@


1.69
log
@print out the amount of memory used for cache.  ok otto
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.68 2011/04/10 03:20:59 guenther Exp $	 */
d370 4
@


1.68
log
@Switch back from KERN_PROC2/kinfo_proc2 to KERN_PROC/kinfo_proc now
that we've got name we want for the API we want

"ZAP!" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.67 2010/04/26 00:30:58 deraadt Exp $	 */
d44 1
d111 1
a111 1
int memory_stats[8];
d113 3
a115 2
	"Real: ", "K/", "K act/tot  ", "Free: ", "K  ",
	"Swap: ", "K/", "K used/tot",
d211 1
d214 1
d261 5
d273 2
d276 3
a278 3
	if (!swapmode(&memory_stats[6], &memory_stats[7])) {
		memory_stats[6] = 0;
		memory_stats[7] = 0;
@


1.67
log
@more portable code
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.66 2010/03/26 05:10:50 lum Exp $	 */
d55 2
a56 2
static char	*state_abbr(struct kinfo_proc2 *);
static char	*format_comm(struct kinfo_proc2 *);
d61 1
a61 1
	struct kinfo_proc2 **next_proc;	/* points to next valid proc pointer */
d126 2
a127 2
static struct kinfo_proc2 *pbase;
static struct kinfo_proc2 **pref;
d278 1
a278 1
struct kinfo_proc2 *
d282 1
a282 1
	int mib[6] = {CTL_KERN, KERN_PROC2, 0, 0, sizeof(struct kinfo_proc2), 0};
d284 1
a284 1
	static struct kinfo_proc2 *procbase;
d299 1
a299 1
		/* _kvm_syserr(kd, kd->program, "kvm_getproc2"); */
d305 1
a305 1
	mib[5] = (int)(size / sizeof(struct kinfo_proc2));
d310 1
a310 1
		/* _kvm_syserr(kd, kd->program, "kvm_getproc2"); */
d313 1
a313 1
	*cnt = (int)(size / sizeof(struct kinfo_proc2));
d323 1
a323 1
	struct kinfo_proc2 **prefp, *pp;
d330 2
a331 2
		pref = (struct kinfo_proc2 **)realloc(pref,
		    sizeof(struct kinfo_proc2 *) * (onproc = nproc));
d380 1
a380 1
		    sizeof(struct kinfo_proc2 *), compare);
d394 1
a394 1
state_abbr(struct kinfo_proc2 *pp)
d408 1
a408 1
format_comm(struct kinfo_proc2 *kp)
d446 1
a446 1
	struct kinfo_proc2 *pp;
d535 1
a535 1
	struct kinfo_proc2 *p1, *p2;
d540 2
a541 2
	p1 = *(struct kinfo_proc2 **) pp1;
	p2 = *(struct kinfo_proc2 **) pp2;
d559 1
a559 1
	struct kinfo_proc2 *p1, *p2;
d564 2
a565 2
	p1 = *(struct kinfo_proc2 **) pp1;
	p2 = *(struct kinfo_proc2 **) pp2;
d583 1
a583 1
	struct kinfo_proc2 *p1, *p2;
d588 2
a589 2
	p1 = *(struct kinfo_proc2 **) pp1;
	p2 = *(struct kinfo_proc2 **) pp2;
d607 1
a607 1
	struct kinfo_proc2 *p1, *p2;
d612 2
a613 2
	p1 = *(struct kinfo_proc2 **) pp1;
	p2 = *(struct kinfo_proc2 **) pp2;
d631 1
a631 1
	struct kinfo_proc2 *p1, *p2;
d636 2
a637 2
	p1 = *(struct kinfo_proc2 **) pp1;
	p2 = *(struct kinfo_proc2 **) pp2;
d654 1
a654 1
	struct kinfo_proc2 *p1, *p2;
d659 2
a660 2
	p1 = *(struct kinfo_proc2 **) pp1;
	p2 = *(struct kinfo_proc2 **) pp2;
d678 1
a678 1
	struct kinfo_proc2 *p1, *p2;
d683 2
a684 2
	p1 = *(struct kinfo_proc2 **) pp1;
	p2 = *(struct kinfo_proc2 **) pp2;
d721 1
a721 1
	struct kinfo_proc2 **prefp, *pp;
@


1.66
log
@Make the source of process TIME for displaying and sorting the same.
top(1) and ps(1) now display the same info.
ok tedu@@ millert@@ otto@@ and tested on sparc64 by landry@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.65 2010/01/29 00:36:09 tedu Exp $	 */
d217 2
d221 1
a221 1
			int cp_time_mib[] = {CTL_KERN, KERN_CPTIME2, i};
@


1.65
log
@Allow sorting by command and pid.  Also, allow partial matches with strncmp.
ok jmc otto
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.64 2009/04/28 21:24:41 deraadt Exp $	 */
a89 2
static int      stathz;

a138 14
static int
getstathz(void)
{
	struct clockinfo cinf;
	size_t size = sizeof(cinf);
	int mib[2];

	mib[0] = CTL_KERN;
	mib[1] = KERN_CLOCKRATE;
	if (sysctl(mib, 2, &cinf, &size, NULL, 0) == -1)
		return (-1);
	return (cinf.stathz);
}

a165 4
	stathz = getstathz();
	if (stathz == -1)
		return (-1);

d454 1
a454 1
	cputime = (pp->p_uticks + pp->p_sticks + pp->p_iticks) / stathz;
@


1.64
log
@extend STATE column to fit > 9 cpus; Aivar Jaakson; PR6131
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.63 2007/11/01 19:19:48 otto Exp $	 */
d121 1
a121 1
	"cpu", "size", "res", "time", "pri", NULL
d542 4
d667 49
d722 2
@


1.63
log
@bump arbitrary limit on arg length shown by -C; requested by and ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.62 2007/07/27 13:57:50 deraadt Exp $	 */
d72 1
a72 1
	"  PID X        PRI NICE  SIZE   RES STATE    WAIT      TIME    CPU COMMAND";
d78 1
a78 1
	"%5d %-8.8s %3d %4d %5s %5s %-8s %-7.7s %6s %5.2f%% %s"
@


1.62
log
@replace a few more malloc(n*m) idioms with calloc(n,m) for safety;
inspired by zinovik@@cs.karelia.ru
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.61 2007/05/29 00:56:56 otto Exp $	 */
d78 1
a78 1
	"%5d %-8.8s %3d %4d %5s %5s %-8s %-7.7s %6s %5.2f%% %.50s"
d428 1
a428 2
#define ARG_SIZE 60
	static char **s, buf[ARG_SIZE];
@


1.61
log
@Instead of using hand-crafted redraws minimizing screen updates, use curses.
Enables nice things like process highlighting without hurting the brain.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.60 2007/04/16 11:49:51 otto Exp $	 */
d165 1
a165 1
	cpu_states = malloc(ncpu * CPUSTATES * sizeof(int64_t));
d168 3
a170 3
	cp_time = malloc(ncpu * sizeof(int64_t *));
	cp_old  = malloc(ncpu * sizeof(int64_t *));
	cp_diff = malloc(ncpu * sizeof(int64_t *));
d712 1
a712 1
	swdev = malloc(nswap * sizeof(*swdev));
@


1.60
log
@don't truncate wchan, ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.59 2007/04/13 19:19:54 otto Exp $	 */
d462 1
a462 1
format_next_process(caddr_t handle, char *(*get_userid)(uid_t))
d502 1
@


1.59
log
@include cleanup and fix in comment; from Mark Lumsden
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.58 2007/04/04 19:24:18 otto Exp $	 */
d72 1
a72 1
	"  PID X        PRI NICE  SIZE   RES STATE    WAIT     TIME    CPU COMMAND";
d78 1
a78 1
	"%5d %-8.8s %3d %4d %5s %5s %-8s %-6.6s %6s %5.2f%% %.51s"
@


1.58
log
@missing prototypes; from Mark Lumsden with a twist by me.
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.57 2007/02/04 14:58:45 otto Exp $	 */
a36 1
#include <sys/signal.h>
a40 2
#include <limits.h>
#include <err.h>
a42 1
#include <sys/dir.h>
a43 3
#include <sys/file.h>
#include <sys/time.h>
#include <sys/resource.h>
d374 2
a375 2
		 *  status field.  Processes with SSYS set are system
		 *  processes---these get ignored unless show_sysprocs is set.
@


1.57
log
@long and long long is not the same on 32 bits archs
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.56 2007/01/03 18:57:49 otto Exp $	 */
d62 2
d418 1
a418 1
char *
d432 1
a432 1
char *
@


1.56
log
@Add a 'g' command to only show processes having a string in their
command name. ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.55 2007/01/02 19:09:24 otto Exp $	 */
d490 1
a490 1
			    pp->p_wchan & ~KERNBASE);
@


1.55
log
@top(1) doesn't use any math.h function, so do not include math.h and
do not link with libm. ok ray@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.54 2006/11/29 12:34:22 miod Exp $	 */
d344 1
a344 1
	int show_idle, show_system, show_threads, show_uid, show_pid;
d368 1
d391 3
a393 1
			    (!show_pid || pp->p_pid == sel->pid)) {
@


1.54
log
@Do not test for processes being swapped out since this can't happen anymore.
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.53 2006/09/20 21:26:20 ray Exp $	 */
a43 1
#include <math.h>
@


1.53
log
@Recommit memory leak fix.
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.52 2006/04/29 14:40:44 otto Exp $	 */
a477 9
	if ((pp->p_flag & P_INMEM) == 0) {
		/*
		 * Print swapped processes as <pname>
		 */
		char buf[sizeof(pp->p_comm)];

		(void) strlcpy(buf, pp->p_comm, sizeof(buf));
		(void) snprintf(pp->p_comm, sizeof(pp->p_comm), "<%s>", buf);
	}
@


1.52
log
@use calloc(3) instead of malloc(3) to allocate cpu state structs; it's
better style here; plus it prevents bogus data to show up on first display.
report + ok pedro@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.51 2005/12/21 01:40:24 millert Exp $	 */
d728 2
a729 1
	if (rnswap == -1)
d731 1
@


1.51
log
@Userland programs should include <errno.h> not <sys/errno.h>
OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.50 2005/12/04 23:10:06 tedu Exp $	 */
d180 3
a182 3
		cp_time[cpu] = malloc(CPUSTATES * sizeof(int64_t));
		cp_old[cpu] = malloc(CPUSTATES * sizeof(int64_t));
		cp_diff[cpu] = malloc(CPUSTATES * sizeof(int64_t));
@


1.50
log
@support for toggling thread viewing.
ok brad, hints from jmc
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.49 2005/06/17 09:40:48 markus Exp $	 */
a45 1
#include <sys/errno.h>
d54 1
@


1.49
log
@add a 'C' command ) that toggles the display of the full cmdline;
with Jared Yanovich; ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.48 2005/06/08 22:36:43 millert Exp $	 */
d345 1
a345 1
	int show_idle, show_system, show_uid, show_pid;
d366 1
d383 2
a384 1
		    (show_system || (pp->p_flag & P_SYSTEM) == 0)) {
@


1.48
log
@Multi-cpu support for top.  Each cpu now gets its own stats line.
Based on work by todd@@ at the hackathon.
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.47 2004/12/06 15:57:04 markus Exp $	 */
d84 1
a84 1
	"%5d %-8.8s %3d %4d %5s %5s %-8s %-6.6s %6s %5.2f%% %.11s"
d427 36
d510 1
a510 1
	    printable(pp->p_comm));
@


1.47
log
@missing space; bluhm at genua.de
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.46 2004/11/22 15:26:53 pat Exp $	 */
d99 3
a101 3
static long     cp_time[CPUSTATES];
static long     cp_old[CPUSTATES];
static long     cp_diff[CPUSTATES];
d112 1
a112 1
int cpu_states[CPUSTATES];
d165 1
a165 1
	int mib[2], pagesize;
d171 16
a234 1
	static int cp_time_mib[] = {CTL_KERN, KERN_CPTIME};
d240 1
d242 24
a265 3
	size = sizeof(cp_time);
	if (sysctl(cp_time_mib, 2, &cp_time, &size, NULL, 0) < 0)
		warn("sysctl kern.cp_time failed");
a273 2
	/* convert cp_time counts to percentages */
	(void) percentages(CPUSTATES, cpu_states, cp_time, cp_old, cp_diff);
d418 1
a418 1
		snprintf(buf, sizeof buf, "%s/%d",
@


1.46
log
@simplify loop iteration

ok otto millert
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.45 2004/11/17 09:22:43 markus Exp $	 */
d107 1
a107 1
	" stopped, ", " zombie, ", "dead, ", " on processor, ",
@


1.45
log
@off-by-one in process_states[], fixes display of memory; ok deraadt, aaron
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.44 2004/10/07 06:26:12 otto Exp $	 */
d311 1
a311 1
	int total_procs, active_procs, i;
d339 1
a339 1
	for (pp = pbase, i = 0; i < nproc; pp++, i++) {
@


1.44
log
@introduce -p option and p command to only show a single process.
From Patrick Latifi. ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.43 2004/06/13 18:49:02 otto Exp $	 */
d104 1
a104 1
int process_states[7];
d107 1
a107 1
	" stopped, ", " zombie, ",
@


1.43
log
@Typos in comments and a redundant prototype. From Brian Poole via jmc@@
ok jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.42 2004/06/11 16:08:54 deraadt Exp $	 */
d267 1
a267 1
static struct kinfo_proc2 *
d310 1
a310 1
	int show_idle, show_system, show_uid;
d332 1
d353 2
a354 1
			    (!show_uid || pp->p_ruid == sel->uid)) {
@


1.42
log
@handle the KI_NOCPU case, pointed out by markus
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.41 2004/06/11 05:29:28 deraadt Exp $	 */
d612 1
a612 1
 *		It is EXTREMLY IMPORTANT that this function work correctly.
@


1.41
log
@only print /# if > 1 cpu on a machine
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.40 2004/06/11 01:32:11 deraadt Exp $	 */
d380 1
a380 1
	if (ncpu > 1)
@


1.40
log
@export cpuid via kproc2, and make ps & top aware... from niklas
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.39 2004/06/11 01:00:58 deraadt Exp $	 */
d143 2
d164 7
a170 1
	int pagesize;
d380 6
a385 2
	snprintf(buf, sizeof buf, "%s/%d",
	    state_abbrev[(unsigned char)pp->p_stat], pp->p_cpuid);
@


1.39
log
@hide top breakage, until the next commit which will do it right
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.38 2004/05/09 22:14:15 deraadt Exp $	 */
d78 1
a78 1
	"  PID X        PRI NICE  SIZE   RES STATE WAIT     TIME    CPU COMMAND";
d84 1
a84 1
	"%5d %-8.8s %3d %4d %5s %5s %-5s %-6.6s %6s %5.2f%% %.14s"
d93 1
a93 1
	"", "start", "run", "sleep", "stop", "zomb", "onproc"
d368 10
d423 1
a423 1
	    "idle" : state_abbrev[(unsigned char)pp->p_stat],
@


1.38
log
@spaces
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.37 2004/01/08 18:15:06 millert Exp $	 */
d93 1
a93 1
	"", "start", "run\0\0\0", "sleep", "stop", "zomb",
@


1.37
log
@Convert to kinfo_proc2; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.36 2003/07/07 21:36:52 deraadt Exp $	 */
d62 1
a62 1
static int      swapmode(int *, int *);
d68 1
a68 1
	int             remaining;	/* number of pointers remaining */
d77 1
a77 1
static char     header[] =
@


1.36
log
@protos
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.35 2003/06/18 08:36:31 deraadt Exp $	 */
d67 1
a67 1
	struct kinfo_proc **next_proc;	/* points to next valid proc pointer */
a70 4
#define PP(pp, field) ((pp)->kp_proc . field)
#define EP(pp, field) ((pp)->kp_eproc . field)
#define VP(pp, field) ((pp)->kp_eproc.e_vm . field)

d72 1
a72 1
#define PROCSIZE(pp) (VP((pp), vm_tsize) + VP((pp), vm_dsize) + VP((pp), vm_ssize))
d134 2
a135 2
static struct kinfo_proc *pbase;
static struct kinfo_proc **pref;
d259 1
a259 1
static struct kinfo_proc *
d262 2
a263 3
	size_t size = sizeof(int);
	int mib[4] = {CTL_KERN, KERN_PROC, 0, 0};
	int smib[2] = {CTL_KERN, KERN_NPROCS};
d265 1
a265 1
	static struct kinfo_proc *procbase;
d276 3
a278 1
	st = sysctl(smib, 2, cnt, &size, NULL, 0);
d280 1
a280 1
		/* _kvm_syserr(kd, kd->program, "kvm_getprocs"); */
d283 2
a284 5
	if (procbase)
		free(procbase);
	size = (6 * (*cnt) * sizeof(struct kinfo_proc)) / 5;
	procbase = (struct kinfo_proc *) malloc(size);
	if (procbase == NULL)
d286 2
a287 1
	st = sysctl(mib, 4, procbase, &size, NULL, 0);
d289 3
a291 8
		/* _kvm_syserr(kd, kd->program, "kvm_getprocs"); */
		return (0);
	}
	if (size % sizeof(struct kinfo_proc) != 0) {
		/*
		 * _kvm_err(kd, kd->program, "proc size mismatch (%d total,
		 * %d chunks)", size, sizeof(struct kinfo_proc));
		 */
d294 1
d304 1
a304 1
	struct kinfo_proc **prefp, *pp;
d311 2
a312 2
		pref = (struct kinfo_proc **)realloc(pref,
		    sizeof(struct kinfo_proc *) * (onproc = nproc));
d337 2
a338 2
		if (PP(pp, p_stat) != 0 &&
		    (show_system || ((PP(pp, p_flag) & P_SYSTEM) == 0))) {
d340 5
a344 5
			process_states[(unsigned char) PP(pp, p_stat)]++;
			if ((PP(pp, p_stat) != SZOMB) &&
			    (show_idle || (PP(pp, p_pctcpu) != 0) ||
			    (PP(pp, p_stat) == SRUN)) &&
			    (!show_uid || EP(pp, e_pcred.p_ruid) == sel->uid)) {
d354 1
a354 1
		    sizeof(struct kinfo_proc *), compare);
d371 1
a371 1
	struct kinfo_proc *pp;
d381 1
a381 2
	/* get the process's user struct and set cputime */
	if ((PP(pp, p_flag) & P_INMEM) == 0) {
d385 1
a385 2
		char *comm = PP(pp, p_comm);
		char buf[sizeof(PP(pp, p_comm))];
d387 2
a388 4
		(void) strlcpy(buf, comm, sizeof buf);
		comm[0] = '<';
		(void) strlcpy(&comm[1], buf, sizeof buf - 1);
		(void) strlcat(comm, ">", sizeof buf);
d390 1
a390 1
	cputime = (PP(pp, p_uticks) + PP(pp, p_sticks) + PP(pp, p_iticks)) / stathz;
d393 1
a393 1
	pct = pctdouble(PP(pp, p_pctcpu));
d395 3
a397 3
	if (PP(pp, p_wchan)) {
		if (PP(pp, p_wmesg))
			p_wait = EP(pp, e_wmesg);
d399 2
a400 2
			snprintf(waddr, sizeof(waddr), "%lx",
			    (unsigned long) (PP(pp, p_wchan)) & ~KERNBASE);
d408 2
a409 2
	    PP(pp, p_pid), (*get_userid) (EP(pp, e_pcred.p_ruid)),
	    PP(pp, p_priority) - PZERO, PP(pp, p_nice) - NZERO,
d411 3
a413 3
	    format_k(pagetok(VP(pp, vm_rssize))),
	    (PP(pp, p_stat) == SSLEEP && PP(pp, p_slptime) > maxslp) ?
	    "idle" : state_abbrev[(unsigned char) PP(pp, p_stat)],
d415 1
a415 1
	    printable(PP(pp, p_comm)));
d443 1
a443 1
	if (lresult = (pctcpu)PP(p2, p_pctcpu) - (pctcpu)PP(p1, p_pctcpu), \
d446 2
a447 3
	if ((result = PP(p2, p_rtime.tv_sec) - PP(p1, p_rtime.tv_sec)) == 0) \
		if ((result = PP(p2, p_rtime.tv_usec) - \
		     PP(p1, p_rtime.tv_usec)) == 0)
d449 2
a450 2
	if ((result = sorted_state[(unsigned char) PP(p2, p_stat)] - \
	    sorted_state[(unsigned char) PP(p1, p_stat)])  == 0)
d452 1
a452 1
	if ((result = PP(p2, p_priority) - PP(p1, p_priority)) == 0)
d454 1
a454 1
	if ((result = VP(p2, vm_rssize) - VP(p1, vm_rssize)) == 0)
d464 1
a464 1
	struct kinfo_proc *p1, *p2;
d469 2
a470 2
	p1 = *(struct kinfo_proc **) pp1;
	p2 = *(struct kinfo_proc **) pp2;
d488 1
a488 1
	struct kinfo_proc *p1, *p2;
d493 2
a494 2
	p1 = *(struct kinfo_proc **) pp1;
	p2 = *(struct kinfo_proc **) pp2;
d512 1
a512 1
	struct kinfo_proc *p1, *p2;
d517 2
a518 2
	p1 = *(struct kinfo_proc **) pp1;
	p2 = *(struct kinfo_proc **) pp2;
d536 1
a536 1
	struct kinfo_proc *p1, *p2;
d541 2
a542 2
	p1 = *(struct kinfo_proc **) pp1;
	p2 = *(struct kinfo_proc **) pp2;
d560 1
a560 1
	struct kinfo_proc *p1, *p2;
d565 2
a566 2
	p1 = *(struct kinfo_proc **) pp1;
	p2 = *(struct kinfo_proc **) pp2;
d599 1
a599 1
	struct kinfo_proc **prefp, *pp;
d606 2
a607 2
		if (PP(pp, p_pid) == pid)
			return ((uid_t) EP(pp, e_pcred.p_ruid));
@


1.35
log
@remove unused variables
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.34 2003/06/17 00:51:29 jfb Exp $	 */
d149 1
a149 1
int
d263 1
a263 1
struct kinfo_proc *
d377 1
a377 1
format_next_process(caddr_t handle, char *(*get_userid)())
d473 1
a473 1
int
d497 1
a497 1
int
d521 1
a521 1
int
d545 1
a545 1
int
d569 1
a569 1
int
@


1.34
log
@properly typecast to uid_t the return value of proc_owner() and report
ESRCH instead of EACCES if it returns -1

ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.33 2003/06/15 16:24:44 millert Exp $	 */
a218 1
	int total, i;
d220 1
d223 1
a223 1
	if (sysctl(cp_time_mib, 2, &cp_time, &size, NULL, 0) < 0) {
d225 1
a225 2
		total = 0;
	}
d227 1
a227 1
	if (sysctl(sysload_mib, 2, &sysload, &size, NULL, 0) < 0) {
a228 2
		total = 0;
	}
d234 1
a234 1
	total = percentages(CPUSTATES, cpu_states, cp_time, cp_old, cp_diff);
@


1.33
log
@use uid_t and fix some sign compare warnings; OK krw@@ and deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.32 2003/06/14 20:23:41 avsm Exp $	 */
d624 1
a624 1
			return ((int) EP(pp, e_pcred.p_ruid));
d626 1
a626 1
	return (-1);
@


1.32
log
@use correct length instead of sizeof(char *) for some strl* bound values
millert@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.31 2003/06/13 21:52:24 deraadt Exp $	 */
d147 1
a147 1
int             maxslp;
d314 1
a314 1
	int show_idle, show_system, show_uid, show_command;
d335 1
a335 1
	show_uid = sel->uid != -1;
d356 1
a356 1
			    (!show_uid || EP(pp, e_pcred.p_ruid) == (uid_t) sel->uid)) {
d613 1
a613 1
int
@


1.31
log
@readable code
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.30 2003/06/12 23:09:29 deraadt Exp $	 */
d401 1
a401 1
		(void) strlcpy(buf, comm, sizeof comm);
d403 2
a404 2
		(void) strlcpy(&comm[1], buf, sizeof comm - 1);
		(void) strlcat(comm, ">", sizeof comm);
@


1.30
log
@knf
@
text
@d1 1
a1 1
/* $OpenBSD: machine.c,v 1.29 2003/06/12 22:30:23 pvalchev Exp $	 */
a27 15
 */

/*
 * top - a top users display for Unix
 *
 * SYNOPSIS:  For an OpenBSD system
 *
 * DESCRIPTION:
 * This is the machine-dependent module for OpenBSD
 * Tested on:
 *	i386
 *
 * TERMCAP: -ltermlib
 *
 * CFLAGS: -DHAVE_GETOPT -DORDER
a38 3

#define DOSWAP

a52 2

#ifdef DOSWAP
a54 3
#endif

static int      swapmode(int *, int *);
d60 3
a70 3
/* declarations for load_avg */
#include "loadavg.h"

d82 2
a83 1
"  PID X        PRI NICE  SIZE   RES STATE WAIT     TIME    CPU COMMAND";
a124 1
#ifdef DOSWAP
a125 1
#endif
a128 1
#ifdef ORDER
d130 3
a132 2
char           *ordernames[] = {"cpu", "size", "res", "time", "pri", NULL};
#endif
a194 1
#ifdef ORDER
a195 1
#endif
d211 1
a211 2
get_system_info(si)
	struct system_info *si;
d252 1
a252 1
#ifdef DOSWAP
a256 1
#endif
d270 1
a270 1
	int mib[4] = {CTL_KERN, KERN_PROC, op, arg};
d276 3
a335 1
	show_command = sel->command != NULL;
a446 1
#ifdef ORDER
d595 1
a595 1
int (*proc_compares[]) () = {
a603 56
#else

/*
 * proc_compare - comparison function for "qsort"
 * Compares the resource consumption of two processes using five
 * distinct keys.  The keys (in descending order of importance) are:
 * percent cpu, cpu ticks, state, resident set size, total virtual
 * memory usage.  The process states are ordered as follows (from least
 * to most important):  zombie, sleep, stop, start, run.  The array
 * declaration below maps a process state index into a number that
 * reflects this ordering.
 */
int
proc_compare(const void *v1, const void *v2)
{
	struct proc **pp1 = (struct proc **) v1;
	struct proc **pp2 = (struct proc **) v2;
	struct kinfo_proc *p1, *p2;
	pctcpu lresult;
	int result;

	/* remove one level of indirection */
	p1 = *(struct kinfo_proc **) pp1;
	p2 = *(struct kinfo_proc **) pp2;

	/* compare percent cpu (pctcpu) */
	if ((lresult = PP(p2, p_pctcpu) - PP(p1, p_pctcpu)) == 0) {
		/* use CPU usage to break the tie */
		if ((result = PP(p2, p_rtime).tv_sec - PP(p1, p_rtime).tv_sec) == 0) {
			/* use process state to break the tie */
			if ((result = sorted_state[(unsigned char) PP(p2, p_stat)] -
			sorted_state[(unsigned char) PP(p1, p_stat)]) == 0) {
				/* use priority to break the tie */
				if ((result = PP(p2, p_priority) -
				     PP(p1, p_priority)) == 0) {
					/*
					 * use resident set size (rssize) to
					 * break the tie
					 */
					if ((result = VP(p2, vm_rssize) -
					     VP(p1, vm_rssize)) == 0) {
						/*
						 * use total memory to break
						 * the tie
						 */
						result = PROCSIZE(p2) - PROCSIZE(p1);
					}
				}
			}
		}
	} else
		result = lresult < 0 ? -1 : 1;
	return (result);
}
#endif

a628 1
#ifdef DOSWAP
a663 1
#endif
@


1.29
log
@cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.28 2002/07/02 03:05:47 tholo Exp $	*/
d77 1
a77 1
static int swapmode(int *, int *);
d88 1
a88 1
	int     remaining;	/* number of pointers remaining */
d104 1
a104 1
static char header[] =
a111 1

d113 4
a116 2
/* the extra nulls in the string "run" are for adding a slash and
   the processor number when needed */
d118 1
a118 1
char *state_abbrev[] = {
d122 1
a122 2

static int stathz;
d125 3
a127 3
static long cp_time[CPUSTATES];
static long cp_old[CPUSTATES];
static long cp_diff[CPUSTATES];
d130 4
a133 3
int     process_states[7];
char   *procstatenames[] = {
	"", " starting, ", " running, ", " idle, ", " stopped, ", " zombie, ",
d138 2
a139 2
int     cpu_states[CPUSTATES];
char   *cpustatenames[] = {
d144 2
a145 2
int     memory_stats[8];
char   *memorynames[] = {
d155 1
a155 1
char   *ordernames[] = {"cpu", "size", "res", "time", "pri", NULL};
d159 3
a161 3
static int nproc;
static int onproc = -1;
static int pref_len;
d166 1
a166 1
static int pageshift;		/* log base 2 of the pagesize */
d171 1
a171 1
int maxslp;
d177 2
a178 2
	size_t  size = sizeof(cinf);
	int     mib[2];
d201 4
a204 2
	/* get the page size with "getpagesize" and calculate pageshift from
	 * it */
d231 1
a231 1
	while (*uname_field != '\0') {
a232 1
	}
d242 1
a242 1
	static int cp_time_mib[] = { CTL_KERN, KERN_CPTIME };
d247 2
a248 2
	size_t  size;
	
a253 1

a308 1

d317 1
a317 1
	procbase = (struct kinfo_proc *)malloc(size);
d326 4
a329 3
		/* _kvm_err(kd, kd->program,
		    "proc size mismatch (%d total, %d chunks)",
		    size, sizeof(struct kinfo_proc)); */
d335 1
a335 1
caddr_t 
d337 1
a337 1
    int (*compare)(const void *, const void *))
d348 2
a349 2
		pref = (struct kinfo_proc **) realloc(pref, sizeof(struct kinfo_proc *)
		    * (onproc = nproc));
d381 1
a381 1
				(PP(pp, p_stat) == SRUN)) &&
d390 3
a392 3
	if (compare != NULL) {
		qsort((char *) pref, active_procs, sizeof(struct kinfo_proc *), compare);
	}
d403 1
a403 1
char    fmt[MAX_COLS];		/* static area where result is built */
d408 1
a408 1
	char waddr[sizeof(void *) * 2 + 3];	/* Hexify void pointer */
a410 1
	char *p_wait;
d424 4
a427 4
		char   *comm = PP(pp, p_comm);
#define COMSIZ sizeof(PP(pp, p_comm))
		char    buf[COMSIZ];
		(void) strncpy(buf, comm, COMSIZ);
d429 2
a430 4
		(void) strncpy(&comm[1], buf, COMSIZ - 2);
		comm[COMSIZ - 2] = '\0';
		(void) strncat(comm, ">", COMSIZ - 1);
		comm[COMSIZ - 1] = '\0';
d437 1
a437 1
	if (PP(pp, p_wchan))
d445 1
a445 1
	else
d449 3
a451 6
	snprintf(fmt, MAX_COLS,
	    Proc_format,
	    PP(pp, p_pid),
	    (*get_userid) (EP(pp, e_pcred.p_ruid)),
	    PP(pp, p_priority) - PZERO,
	    PP(pp, p_nice) - NZERO,
d454 3
a456 5
	    (PP(pp, p_stat) == SSLEEP && PP(pp, p_slptime) > maxslp)
	    ? "idle" : state_abbrev[(unsigned char) PP(pp, p_stat)],
	    p_wait,
	    format_time(cputime),
	    100.0 * pct,
a484 1

a501 1

d508 2
a509 2
	struct kinfo_proc *p1;
	struct kinfo_proc *p2;
a510 1
	pctcpu lresult;
d517 6
a522 6
	    ORDERKEY_CPUTIME
	    ORDERKEY_STATE
	    ORDERKEY_PRIO
	    ORDERKEY_RSSIZE
	    ORDERKEY_MEM
	    ;
d532 2
a533 2
	struct kinfo_proc *p1;
	struct kinfo_proc *p2;
a534 1
	pctcpu lresult;
d541 6
a546 6
	    ORDERKEY_RSSIZE
	    ORDERKEY_PCTCPU
	    ORDERKEY_CPUTIME
	    ORDERKEY_STATE
	    ORDERKEY_PRIO
	    ;
d556 2
a557 2
	struct kinfo_proc *p1;
	struct kinfo_proc *p2;
a558 1
	pctcpu lresult;
d565 6
a570 6
	    ORDERKEY_MEM
	    ORDERKEY_PCTCPU
	    ORDERKEY_CPUTIME
	    ORDERKEY_STATE
	    ORDERKEY_PRIO
	    ;
d580 2
a581 2
	struct kinfo_proc *p1;
	struct kinfo_proc *p2;
a582 1
	pctcpu lresult;
d589 6
a594 6
	    ORDERKEY_PCTCPU
	    ORDERKEY_STATE
	    ORDERKEY_PRIO
	    ORDERKEY_MEM
	    ORDERKEY_RSSIZE
	    ;
d602 4
a605 4
	struct proc **pp1 = (struct proc **) v1;
	struct proc **pp2 = (struct proc **) v2;
	struct kinfo_proc *p1;
	struct kinfo_proc *p2;
a606 1
	pctcpu lresult;
d613 6
a618 6
	    ORDERKEY_PCTCPU
	    ORDERKEY_CPUTIME
	    ORDERKEY_STATE
	    ORDERKEY_RSSIZE
	    ORDERKEY_MEM
	    ;
d622 1
a622 1
int     (*proc_compares[]) () = {
d630 1
d632 1
d634 8
a641 8
 *  proc_compare - comparison function for "qsort"
 *	Compares the resource consumption of two processes using five
 *  	distinct keys.  The keys (in descending order of importance) are:
 *  	percent cpu, cpu ticks, state, resident set size, total virtual
 *  	memory usage.  The process states are ordered as follows (from least
 *  	to most important):  zombie, sleep, stop, start, run.  The array
 *  	declaration below maps a process state index into a number that
 *  	reflects this ordering.
d648 2
a649 2
	struct kinfo_proc *p1;
	struct kinfo_proc *p2;
a650 1
	pctcpu lresult;
d662 1
a662 1
				sorted_state[(unsigned char) PP(p1, p_stat)]) == 0) {
d665 5
a669 3
				    PP(p1, p_priority)) == 0) {
					/* use resident set size (rssize) to
					 * break the tie */
d671 5
a675 3
					    VP(p1, vm_rssize)) == 0) {
						/* use total memory to break
						 * the tie */
d681 1
a681 1
	} else {
a682 1
	}
d696 1
a696 1
int 
d706 1
a706 1
		if (PP(pp, p_pid) == pid) {
a707 1
		}
d711 1
a719 1
	int     nswap, rnswap, i;
d721 1
a744 1

@


1.28
log
@Add missing copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.27 2002/02/16 21:27:55 millert Exp $	*/
d173 1
a173 1
getstathz()
d187 1
a187 2
machine_init(statics)
	struct statics *statics;
d223 1
a223 2
format_header(uname_field)
	char   *uname_field;
d294 1
a294 3
getprocs(op, arg, cnt)
	int op, arg;
	int *cnt;
d335 2
a336 5
get_process_info(si, sel, compare)
	struct system_info *si;
	struct process_select *sel;
	int (*compare)(const void *, const void *);

d405 1
a405 4
format_next_process(handle, get_userid)
	caddr_t handle;
	char *(*get_userid)();

d513 1
a513 2
compare_cpu(v1, v2)
	const void *v1, *v2;
d538 1
a538 2
compare_size(v1, v2)
	const void *v1, *v2;
d563 1
a563 2
compare_res(v1, v2)
	const void *v1, *v2;
d588 1
a588 2
compare_time(v1, v2)
	const void *v1, *v2;
d613 1
a613 2
compare_prio(v1, v2)
	const void *v1, *v2;
d656 1
a656 2
proc_compare(v1, v2)
	const void *v1, *v2;
d707 1
a707 2
proc_owner(pid)
	pid_t   pid;
d728 1
a728 3
swapmode(used, total)
	int    *used;
	int    *total;
@


1.27
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 28
a28 1
/*	$OpenBSD: machine.c,v 1.26 2001/12/05 02:29:19 art Exp $	*/
@


1.26
log
@Get maxslp with sysctl. Not the constant.
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.25 2001/07/12 05:17:26 deraadt Exp $	*/
d50 1
a50 1
static int swapmode __P((int *, int *));
d315 1
a315 1
	int (*compare) __P((const void *, const void *));
@


1.25
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.24 2001/06/03 06:46:47 angelos Exp $	*/
d143 2
d221 1
a221 1

d276 1
d280 6
d442 1
a442 1
	    (PP(pp, p_stat) == SSLEEP && PP(pp, p_slptime) > MAXSLP)
@


1.24
log
@Use KERN_NPROCS to get the number of processes on the system, to
determine the amount of space we'll need to store the
information. The alternative, calling sysctl() with a NULL argument
for data, meant the kernel had to go through the process table.
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.23 2001/02/22 03:10:24 deraadt Exp $	*/
a49 1
static int getkval __P((unsigned long, int *, int, char *));
a96 4
/* these are offsets obtained via nlist and used in the get_ functions */

static unsigned long cp_time_offset;

d161 1
a161 2
	char    errbuf[_POSIX2_LINE_MAX];
	int pagesize, i = 0;
@


1.23
log
@plug mem leak i introduced; spotted by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.22 2001/02/17 23:01:40 deraadt Exp $	*/
d277 1
a277 1
	size_t size = 0;
d279 1
a279 1
	int st, nprocs;
d281 1
d283 1
a283 1
	st = sysctl(mib, 4, NULL, &size, NULL, 0);
d290 1
a304 1
	*cnt = size / sizeof(struct kinfo_proc);
@


1.22
log
@bye bye setgid kvm
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.21 2001/02/17 22:55:07 deraadt Exp $	*/
d280 1
a280 1
	struct kinfo_proc *procbase;
d287 2
@


1.21
log
@do not use nlist anymore, kvm gets the bullet next
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.20 2001/02/17 22:51:26 deraadt Exp $	*/
a12 2
 * LIBS: -lkvm
 *
a35 1
#include <kvm.h>
a95 4
static kvm_t *kd;

/* these are retrieved from the kernel in _init */

a168 7
	if ((kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) == NULL) {
		warnx("%s", errbuf);
		return (-1);
	}
	setegid(getgid());
	setgid(getgid());

a225 1
#if 1
a230 5
#else
	/* get the cp_time array */
	(void) getkval(cp_time_offset, (int *) cp_time, sizeof(cp_time),
	    "_cp_time");
#endif
d235 1
a235 1
		bzero(&total, sizeof(total));
d272 33
d316 2
a317 2
	if ((pbase = kvm_getprocs(kd, KERN_PROC_KTHREAD, 0, &nproc)) == NULL) {
		warnx("%s", kvm_geterr(kd));
d472 1
a472 1
           (result = lresult > 0 ? 1 : lresult < 0 ? -1 : 0) == 0)
d479 1
a479 1
                      sorted_state[(unsigned char) PP(p1, p_stat)])  == 0)
d660 2
a661 1
				if ((result = PP(p2, p_priority) - PP(p1, p_priority)) == 0) {
d664 2
a665 1
					if ((result = VP(p2, vm_rssize) - VP(p1, vm_rssize)) == 0) {
a675 1

@


1.20
log
@partial KNF, because i cannot read the diffs i am trying to debug
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.19 2000/06/18 17:59:56 niklas Exp $	*/
a36 1
#include <nlist.h>
a52 1
static int check_nlist __P((struct nlist *));
a77 7
/* definitions for indices in the nlist array */
#define X_CP_TIME	0

static struct nlist nlst[] = {
	{"_cp_time"},		/* 0 */
	{0}
};
a80 1

a182 9
	/* get the list of symbols we want to access in the kernel */
	if (kvm_nlist(kd, nlst) < 0) {
		warnx("nlist failed");
		return (-1);
	}
	/* make sure they were all found */
	if (i > 0 && check_nlist(nlst) > 0)
		return (-1);

a186 3
	/* stash away certain offsets for later use */
	cp_time_offset = nlst[X_CP_TIME].n_value;

d233 1
d240 7
d250 1
a433 59

/*
 * check_nlist(nlst) - checks the nlist to see if any symbols were not
 *		found.  For every symbol that was not found, a one-line
 *		message is printed to stderr.  The routine returns the
 *		number of symbols NOT found.
 */
int
check_nlist(nlst)
	struct nlist *nlst;
{
	int i;

	/* check to see if we got ALL the symbols we requested */
	/* this will write one line to stderr for every symbol not found */

	i = 0;
	while (nlst->n_name != NULL) {
		if (nlst->n_type == 0) {
			/* this one wasn't found */
			(void) fprintf(stderr, "kernel: no symbol named `%s'\n",
			    nlst->n_name);
			i = 1;
		}
		nlst++;
	}

	return (i);
}


/*
 *  getkval(offset, ptr, size, refstr) - get a value out of the kernel.
 *	"offset" is the byte offset into the kernel for the desired value,
 *  	"ptr" points to a buffer into which the value is retrieved,
 *  	"size" is the size of the buffer (and the object to retrieve),
 *  	"refstr" is a reference string used when printing error meessages,
 *	    if "refstr" starts with a '!', then a failure on read will not
 *  	    be fatal (this may seem like a silly way to do things, but I
 *  	    really didn't want the overhead of another argument).
 *
 */
int 
getkval(offset, ptr, size, refstr)
	unsigned long offset;
	int    *ptr;
	int     size;
	char   *refstr;
{
	if (kvm_read(kd, offset, ptr, size) != size) {
		if (*refstr == '!') {
			return (0);
		} else {
			warn("kvm_read for %s", refstr);
			quit(23);
		}
	}
	return (1);
}
a434 1

@


1.19
log
@Mark kernel threads as system processes.  Make ps hide them by default,
show them with -k.  Do not try to show RSS based values for them as they
mess up column alignment.  vmstat -f now shows kernel threads separately
from rforks too.
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.18 1999/11/14 09:03:46 deraadt Exp $	*/
d65 3
a67 4
struct handle
{
    struct kinfo_proc **next_proc;	/* points to next valid proc pointer */
    int remaining;		/* number of pointers remaining */
d84 2
a85 2
    { "_cp_time" },		/* 0 */
    { 0 }
a86 1

d92 1
a92 1
  "  PID X        PRI NICE  SIZE   RES STATE WAIT     TIME    CPU COMMAND";
d104 2
a105 3
char *state_abbrev[] =
{
    "", "start", "run\0\0\0", "sleep", "stop", "zomb",
d113 1
a113 1
static          int stathz;
d125 4
a128 5

int process_states[7];
char *procstatenames[] = {
    "", " starting, ", " running, ", " idle, ", " stopped, ", " zombie, ",
    NULL
d132 3
a134 4

int cpu_states[CPUSTATES];
char *cpustatenames[] = {
    "user", "nice", "system", "interrupt", "idle", NULL
d138 3
a140 4

int memory_stats[8];
char *memorynames[] = {
    "Real: ", "K/", "K act/tot  ", "Free: ", "K  ",
d142 1
a142 1
    "Swap: ", "K/", "K used/tot",
d144 1
a144 1
    NULL
d149 1
a149 2

char *ordernames[] = {"cpu", "size", "res", "time", "pri", NULL};
a152 1

a159 1

a162 1

a167 1
	int mib[2];
d169 2
a170 1
	size_t size = sizeof(cinf);
d181 1
a181 1
struct statics *statics;
d183 47
a229 50
    register int i = 0;
    register int pagesize;
    char errbuf[_POSIX2_LINE_MAX];

    if ((kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf)) == NULL) {
	warnx("%s", errbuf);
	return(-1);
    }

    setegid(getgid());
    setgid(getgid());

    /* get the list of symbols we want to access in the kernel */
    if (kvm_nlist(kd, nlst) < 0) {
	warnx("nlist failed");
	return(-1);
    }

    /* make sure they were all found */
    if (i > 0 && check_nlist(nlst) > 0)
	return(-1);

    stathz = getstathz();
    if (stathz == -1)
	return(-1);

    /* stash away certain offsets for later use */
    cp_time_offset = nlst[X_CP_TIME].n_value;

    pbase = NULL;
    pref = NULL;
    onproc = -1;
    nproc = 0;

    /* get the page size with "getpagesize" and calculate pageshift from it */
    pagesize = getpagesize();
    pageshift = 0;
    while (pagesize > 1)
    {
	pageshift++;
	pagesize >>= 1;
    }

    /* we only need the amount of log(2)1024 for our conversion */
    pageshift -= LOG1024;

    /* fill in the statics information */
    statics->procstate_names = procstatenames;
    statics->cpustate_names = cpustatenames;
    statics->memory_names = memorynames;
d231 1
a231 1
    statics->order_names = ordernames;
d233 1
a233 3

    /* all done! */
    return(0);
d236 3
a238 4
char *format_header(uname_field)

register char *uname_field;

d240 1
a240 1
    register char *ptr;
d242 5
a246 7
    ptr = header + UNAME_START;
    while (*uname_field != '\0')
    {
	*ptr++ = *uname_field++;
    }

    return(header);
d251 1
a251 3

struct system_info *si;

d253 2
a254 10
    int total;

    /* get the cp_time array */
    (void) getkval(cp_time_offset, (int *)cp_time, sizeof(cp_time),
		   "_cp_time");

    /* convert load averages to doubles */
    {
	register int i;
	register double *infoloadp;
d256 13
a268 6
	size_t size = sizeof(sysload);
	static int mib[] = { CTL_VM, VM_LOADAVG };

	if (sysctl(mib, 2, &sysload, &size, NULL, 0) < 0) {
	    warn("sysctl failed");
	    bzero(&total, sizeof(total));
a269 1

d272 1
a272 2
	    *infoloadp++ = ((double) sysload.ldavg[i]) / sysload.fscale;
    }
d274 2
a275 8
    /* convert cp_time counts to percentages */
    total = percentages(CPUSTATES, cpu_states, cp_time, cp_old, cp_diff);

    /* sum memory statistics */
    {
	struct vmtotal total;
	size_t size = sizeof(total);
	static int mib[] = { CTL_VM, VM_METER };
d278 4
a281 3
	if (sysctl(mib, 2, &total, &size, NULL, 0) < 0) {
	    warn("sysctl failed");
	    bzero(&total, sizeof(total));
d285 2
a286 2
	memory_stats[1] = pagetok(total.t_arm);
	memory_stats[2] = pagetok(total.t_rm);
d288 1
a288 1
	memory_stats[4] = pagetok(total.t_free);
d292 2
a293 2
	    memory_stats[6] = 0;
	    memory_stats[7] = 0;
a295 1
    }
d297 4
a300 4
    /* set arrays and strings */
    si->cpustates = cpu_states;
    si->memory = memory_stats;
    si->last_pid = -1;
d305 24
a328 1
caddr_t get_process_info(si, sel, compare)
d330 72
a401 110
struct system_info *si;
struct process_select *sel;
int (*compare) __P((const void *, const void *));

{
    register int i;
    register int total_procs;
    register int active_procs;
    register struct kinfo_proc **prefp;
    register struct kinfo_proc *pp;

    /* these are copied out of sel for speed */
    int show_idle;
    int show_system;
    int show_uid;
    int show_command;

    
    if ((pbase = kvm_getprocs(kd, KERN_PROC_KTHREAD, 0, &nproc)) == NULL) {
	warnx("%s", kvm_geterr(kd));
	quit(23);
    }
    if (nproc > onproc)
	pref = (struct kinfo_proc **) realloc(pref, sizeof(struct kinfo_proc *)
		* (onproc = nproc));
    if (pref == NULL) {
	warnx("Out of memory.");
	quit(23);
    }
    /* get a pointer to the states summary array */
    si->procstates = process_states;

    /* set up flags which define what we are going to select */
    show_idle = sel->idle;
    show_system = sel->system;
    show_uid = sel->uid != -1;
    show_command = sel->command != NULL;

    /* count up process states and get pointers to interesting procs */
    total_procs = 0;
    active_procs = 0;
    memset((char *)process_states, 0, sizeof(process_states));
    prefp = pref;
    for (pp = pbase, i = 0; i < nproc; pp++, i++)
    {
	/*
	 *  Place pointers to each valid proc structure in pref[].
	 *  Process slots that are actually in use have a non-zero
	 *  status field.  Processes with SSYS set are system
	 *  processes---these get ignored unless show_sysprocs is set.
	 */
	if (PP(pp, p_stat) != 0 &&
	    (show_system || ((PP(pp, p_flag) & P_SYSTEM) == 0)))
	{
	    total_procs++;
	    process_states[(unsigned char) PP(pp, p_stat)]++;
	    if ((PP(pp, p_stat) != SZOMB) &&
		(show_idle || (PP(pp, p_pctcpu) != 0) || 
		 (PP(pp, p_stat) == SRUN)) &&
		(!show_uid || EP(pp, e_pcred.p_ruid) == (uid_t)sel->uid))
	    {
		*prefp++ = pp;
		active_procs++;
	    }
	}
    }

    /* if requested, sort the "interesting" processes */
    if (compare != NULL)
    {
	qsort((char *)pref, active_procs, sizeof(struct kinfo_proc *), compare);
    }

    /* remember active and total counts */
    si->p_total = total_procs;
    si->p_active = pref_len = active_procs;

    /* pass back a handle */
    handle.next_proc = pref;
    handle.remaining = active_procs;
    return((caddr_t)&handle);
}

char fmt[MAX_COLS];		/* static area where result is built */

char *format_next_process(handle, get_userid)

caddr_t handle;
char *(*get_userid)();

{
    register struct kinfo_proc *pp;
    register int cputime;
    register double pct;
    struct handle *hp;
    char waddr[sizeof(void *) * 2 + 3];	/* Hexify void pointer */
    char *p_wait;

    /* find and remember the next proc structure */
    hp = (struct handle *)handle;
    pp = *(hp->next_proc++);
    hp->remaining--;
    

    /* get the process's user struct and set cputime */
    if ((PP(pp, p_flag) & P_INMEM) == 0) {
	/*
	 * Print swapped processes as <pname>
	 */
	char *comm = PP(pp, p_comm);
d403 26
a428 27
	char buf[COMSIZ];
	(void) strncpy(buf, comm, COMSIZ);
	comm[0] = '<';
	(void) strncpy(&comm[1], buf, COMSIZ - 2);
	comm[COMSIZ - 2] = '\0';
	(void) strncat(comm, ">", COMSIZ - 1);
	comm[COMSIZ - 1] = '\0';
    }

    cputime = (PP(pp, p_uticks) + PP(pp, p_sticks) + PP(pp, p_iticks)) / stathz;

    /* calculate the base for cpu percentages */
    pct = pctdouble(PP(pp, p_pctcpu));

    if (PP(pp, p_wchan))
        if (PP(pp, p_wmesg))
	    p_wait = EP(pp, e_wmesg);
	else {
	    snprintf(waddr, sizeof(waddr), "%lx", 
		(unsigned long)(PP(pp, p_wchan)) & ~KERNBASE);
	    p_wait = waddr;
        }
    else
	p_wait = "-";
	    
    /* format this entry */
    snprintf(fmt, MAX_COLS,
d431 1
a431 1
	    (*get_userid)(EP(pp, e_pcred.p_ruid)),
d437 1
a437 1
	     ? "idle" : state_abbrev[(unsigned char) PP(pp, p_stat)],
d443 2
a444 2
    /* return the result */
    return(fmt);
d454 3
a456 5

static int check_nlist(nlst)

register struct nlist *nlst;

d458 1
a458 1
    register int i;
d460 2
a461 2
    /* check to see if we got ALL the symbols we requested */
    /* this will write one line to stderr for every symbol not found */
d463 9
a471 9
    i = 0;
    while (nlst->n_name != NULL)
    {
	if (nlst->n_type == 0)
	{
	    /* this one wasn't found */
	    (void) fprintf(stderr, "kernel: no symbol named `%s'\n",
			   nlst->n_name);
	    i = 1;
a472 2
	nlst++;
    }
d474 1
a474 1
    return(i);
d487 1
a487 1
 *  	
d489 14
a502 14

static int getkval(offset, ptr, size, refstr)

unsigned long offset;
int *ptr;
int size;
char *refstr;

{
    if (kvm_read(kd, offset, ptr, size) != size)
    {
	if (*refstr == '!')
	{
	    return(0);
d504 1
a504 7
	else
	{
	    warn("kvm_read for %s", refstr);
	    quit(23);
	}
    }
    return(1);
a505 1
    
d510 6
a515 6
    0,	/* not used		*/
    4,	/* start		*/
    5,	/* run			*/
    2,	/* sleep		*/
    3,	/* stop			*/
    1	/* zombie		*/
a516 1

d547 1
a547 1
 
a548 1

d551 1
a551 3

const void *v1, *v2;

d553 19
a571 19
    register struct proc **pp1 = (struct proc **)v1;
    register struct proc **pp2 = (struct proc **)v2;
    register struct kinfo_proc *p1;
    register struct kinfo_proc *p2;
    register int result;
    register pctcpu lresult;

    /* remove one level of indirection */
    p1 = *(struct kinfo_proc **) pp1;
    p2 = *(struct kinfo_proc **) pp2;

    ORDERKEY_PCTCPU
    ORDERKEY_CPUTIME
    ORDERKEY_STATE
    ORDERKEY_PRIO
    ORDERKEY_RSSIZE
    ORDERKEY_MEM
    ;
    return(result);
a574 1

d577 1
a577 3

const void *v1, *v2;

d579 19
a597 20
    register struct proc **pp1 = (struct proc **)v1;
    register struct proc **pp2 = (struct proc **)v2;
    register struct kinfo_proc *p1;
    register struct kinfo_proc *p2;
    register int result;
    register pctcpu lresult;

    /* remove one level of indirection */
    p1 = *(struct kinfo_proc **) pp1;
    p2 = *(struct kinfo_proc **) pp2;

    ORDERKEY_MEM
    ORDERKEY_RSSIZE
    ORDERKEY_PCTCPU
    ORDERKEY_CPUTIME
    ORDERKEY_STATE
    ORDERKEY_PRIO
    ;

    return(result);
a600 1

d603 1
a603 3

const void *v1, *v2;

d605 19
a623 20
    register struct proc **pp1 = (struct proc **)v1;
    register struct proc **pp2 = (struct proc **)v2;
    register struct kinfo_proc *p1;
    register struct kinfo_proc *p2;
    register int result;
    register pctcpu lresult;

    /* remove one level of indirection */
    p1 = *(struct kinfo_proc **) pp1;
    p2 = *(struct kinfo_proc **) pp2;

    ORDERKEY_RSSIZE
    ORDERKEY_MEM
    ORDERKEY_PCTCPU
    ORDERKEY_CPUTIME
    ORDERKEY_STATE
    ORDERKEY_PRIO
    ;

    return(result);
a626 1

d629 1
a629 3

const void *v1, *v2;

d631 19
a649 20
    register struct proc **pp1 = (struct proc **)v1;
    register struct proc **pp2 = (struct proc **)v2;
    register struct kinfo_proc *p1;
    register struct kinfo_proc *p2;
    register int result;
    register pctcpu lresult;

    /* remove one level of indirection */
    p1 = *(struct kinfo_proc **) pp1;
    p2 = *(struct kinfo_proc **) pp2;

    ORDERKEY_CPUTIME
    ORDERKEY_PCTCPU
    ORDERKEY_STATE
    ORDERKEY_PRIO
    ORDERKEY_MEM
    ORDERKEY_RSSIZE
    ;

    return(result);
a652 1

d655 1
a655 3

const void *v1, *v2;

d657 28
a684 29
    register struct proc **pp1 = (struct proc **)v1;
    register struct proc **pp2 = (struct proc **)v2;
    register struct kinfo_proc *p1;
    register struct kinfo_proc *p2;
    register int result;
    register pctcpu lresult;

    /* remove one level of indirection */
    p1 = *(struct kinfo_proc **) pp1;
    p2 = *(struct kinfo_proc **) pp2;

    ORDERKEY_PRIO
    ORDERKEY_PCTCPU
    ORDERKEY_CPUTIME
    ORDERKEY_STATE
    ORDERKEY_RSSIZE
    ORDERKEY_MEM
    ;

    return(result);
}

int (*proc_compares[])() = {
    compare_cpu,
    compare_size,
    compare_res,
    compare_time,
    compare_prio,
    NULL
d686 1
a686 1
#else 
a696 1

d699 1
a699 3

const void *v1, *v2;

d701 29
a729 30
    register struct proc **pp1 = (struct proc **)v1;
    register struct proc **pp2 = (struct proc **)v2;
    register struct kinfo_proc *p1;
    register struct kinfo_proc *p2;
    register int result;
    register pctcpu lresult;

    /* remove one level of indirection */
    p1 = *(struct kinfo_proc **) pp1;
    p2 = *(struct kinfo_proc **) pp2;

    /* compare percent cpu (pctcpu) */
    if ((lresult = PP(p2, p_pctcpu) - PP(p1, p_pctcpu)) == 0)
    {
	/* use CPU usage to break the tie */
	if ((result = PP(p2, p_rtime).tv_sec - PP(p1, p_rtime).tv_sec) == 0)
	{
	    /* use process state to break the tie */
	    if ((result = sorted_state[(unsigned char) PP(p2, p_stat)] -
			  sorted_state[(unsigned char) PP(p1, p_stat)])  == 0)
	    {
		/* use priority to break the tie */
		if ((result = PP(p2, p_priority) - PP(p1, p_priority)) == 0)
		{
		    /* use resident set size (rssize) to break the tie */
		    if ((result = VP(p2, vm_rssize) - VP(p1, vm_rssize)) == 0)
		    {
			/* use total memory to break the tie */
			result = PROCSIZE(p2) - PROCSIZE(p1);
		    }
d731 2
a732 1
	    }
a733 5
    }
    else
    {
	result = lresult < 0 ? -1 : 1;
    }
d735 1
a735 1
    return(result);
d748 14
a761 18

int proc_owner(pid)

pid_t pid;

{
    register int cnt;
    register struct kinfo_proc **prefp;
    register struct kinfo_proc *pp;

    prefp = pref;
    cnt = pref_len;
    while (--cnt >= 0)
    {
	pp = *prefp++;	
	if (PP(pp, p_pid) == pid)
	{
	    return((int)EP(pp, e_pcred.p_ruid));
d763 1
a763 2
    }
    return(-1);
a764 1

d772 2
a773 2
int *used;
int *total;
d775 1
a775 1
	int nswap, rnswap, i;
d779 1
a779 1
	if (nswap == 0) 
d783 1
a783 1
	if(swdev == NULL)
d787 1
a787 1
	if(rnswap == -1)
d796 2
a797 2
			*used += (swdev[i].se_inuse / (1024/DEV_BSIZE));
			*total += (swdev[i].se_nblks / (1024/DEV_BSIZE));
d801 1
a801 1
	free (swdev);
@


1.18
log
@stathz instead of hz, plus improvements by me; camield@@inet.unisource.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.17 1999/10/29 08:58:43 todd Exp $	*/
d354 1
a354 1
    if ((pbase = kvm_getprocs(kd, KERN_PROC_ALL, 0, &nproc)) == NULL) {
@


1.17
log
@writen
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.16 1999/06/21 20:48:01 art Exp $	*/
a82 1
#define X_HZ		1
a85 1
    { "_hz" },			/* 1 */
d116 1
a116 1
static          int hz;
d176 14
a190 1

a191 1

d215 3
a217 3
    /* get the symbol values out of kmem */
    (void) getkval(nlst[X_HZ].n_value,     (int *)(&hz),	sizeof(hz),
	    nlst[X_HZ].n_name);
d456 1
a456 1
    cputime = (PP(pp, p_uticks) + PP(pp, p_sticks) + PP(pp, p_iticks)) / hz;
@


1.16
log
@stop casting the third argument to kvm_read to char *. it is a void *.
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.15 1999/05/22 21:42:26 weingart Exp $	*/
d847 1
a847 1
 * swapmode is rewriten by Tobias Weingartner <weingart@@openbsd.org>
@


1.15
log
@Update for new vmswap code.
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.14 1998/11/28 02:37:35 kstailey Exp $	*/
d537 1
a537 1
    if (kvm_read(kd, offset, (char *) ptr, size) != size)
@


1.14
log
@do not count swap spaces that were not swapon(2)ed
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.13 1998/09/20 06:19:14 niklas Exp $	*/
d23 1
d50 1
a51 2
#include <sys/map.h>
#include <sys/conf.h>
a84 11
#ifdef DOSWAP
#define	VM_SWAPMAP	2
#define	VM_NSWAPMAP	3
#define	VM_SWDEVT	4
#define	VM_NSWAP	5
#define	VM_NSWDEV	6
#define	VM_DMMAX	7
#define	VM_NISWAP	8
#define	VM_NISWDEV	9
#endif

a87 10
#ifdef DOSWAP
    { "_swapmap" },		/* 2 */
    { "_nswapmap" },		/* 3 */
    { "_swdevt" },		/* 4 */
    { "_nswap" },		/* 5 */
    { "_nswdev" },		/* 6 */
    { "_dmmax" },		/* 7 */
    { "_niswap" },		/* 8 */
    { "_niswdev" },		/* 9 */
#endif
d196 1
a196 1
    if (kvm_nlist(kd, nlst) <= 0) {
d847 2
a848 2
 * swapmode is based on a program called swapinfo written
 * by Kevin Lahey <kml@@rokkaku.atl.ga.us>.
a849 10

#define	SVAR(var) __STRING(var)	/* to force expansion */
#define	KGET(idx, var)							\
	KGET1(idx, &var, sizeof(var), SVAR(var))
#define	KGET1(idx, p, s, msg)						\
	KGET2(nlst[idx].n_value, p, s, msg)
#define	KGET2(addr, p, s, msg)						\
	if (kvm_read(kd, (u_long)(addr), p, s) != s)			\
		warnx("cannot read %s: %s", msg, kvm_geterr(kd))

d855 2
a856 32
	int nswap, nswdev, dmmax, nswapmap, niswap, niswdev;
	int s, e, i, l, nfree;
	struct swdevt *sw;
	long *perdev;
	struct map *swapmap, *kswapmap;
	struct mapent *mp, *freemp;

	KGET(VM_NSWAP, nswap);
	KGET(VM_NSWDEV, nswdev);
	KGET(VM_DMMAX, dmmax);
	KGET(VM_NSWAPMAP, nswapmap);
	KGET(VM_SWAPMAP, kswapmap);	/* kernel `swapmap' is a pointer */
	if (nswap == 0) {
		*used = 0;
		*total = 0;
		return (1);
	}
	if ((sw = malloc(nswdev * sizeof(*sw))) == NULL ||
	    (perdev = malloc(nswdev * sizeof(*perdev))) == NULL ||
	    (freemp = mp = malloc(nswapmap * sizeof(*mp))) == NULL)
		err(1, "malloc");
	KGET1(VM_SWDEVT, sw, nswdev * sizeof(*sw), "swdevt");
	KGET2((long)kswapmap, mp, nswapmap * sizeof(*mp), "swapmap");

	/* Supports sequential swap */
	if (nlst[VM_NISWAP].n_value != 0) {
		KGET(VM_NISWAP, niswap);
		KGET(VM_NISWDEV, niswdev);
	} else {
		niswap = nswap;
		niswdev = nswdev;
	}
d858 20
a877 60
	/* First entry in map is `struct map'; rest are mapent's. */
	swapmap = (struct map *)mp;
	if (nswapmap != swapmap->m_limit - (struct mapent *)kswapmap)
		errx(1, "panic: nswapmap goof");

	/* Count up swap space. */
	nfree = 0;
	memset(perdev, 0, nswdev * sizeof(*perdev));
	for (mp++; mp->m_addr != 0; mp++) {
		s = mp->m_addr;			/* start of swap region */
		e = mp->m_addr + mp->m_size;	/* end of region */
		nfree += mp->m_size;

		/*
		 * Swap space is split up among the configured disks.
		 *
		 * For interleaved swap devices, the first dmmax blocks
		 * of swap space some from the first disk, the next dmmax
		 * blocks from the next, and so on up to niswap blocks.
		 *
		 * Sequential swap devices follow the interleaved devices
		 * (i.e. blocks starting at niswap) in the order in which
		 * they appear in the swdev table.  The size of each device
		 * will be a multiple of dmmax.
		 *
		 * The list of free space joins adjacent free blocks,
		 * ignoring device boundries.  If we want to keep track
		 * of this information per device, we'll just have to
		 * extract it ourselves.  We know that dmmax-sized chunks
		 * cannot span device boundaries (interleaved or sequential)
		 * so we loop over such chunks assigning them to devices.
		 */
		i = -1;
		while (s < e) {		/* XXX this is inefficient */
			int bound = roundup(s+1, dmmax);

			if (bound > e)
				bound = e;
			if (bound <= niswap) {
				/* Interleaved swap chunk. */
				if (i == -1)
					i = (s / dmmax) % niswdev;
				perdev[i] += bound - s;
				if (++i >= niswdev)
					i = 0;
			} else {
				/* Sequential swap chunk. */
				if (i < niswdev) {
					i = niswdev;
					l = niswap + sw[i].sw_nblks;
				}
				while (s >= l) {
					/* XXX don't die on bogus blocks */
					if (i == nswdev-1)
						break;
					l += sw[++i].sw_nblks;
				}
				perdev[i] += bound - s;
			}
			s = bound;
d881 1
a881 23
	*total = 0;
	for (i = 0; i < nswdev; i++) {
		int xsize, xfree;

		if (sw[i].sw_flags & SW_FREED) {
			xsize = sw[i].sw_nblks;
			xfree = perdev[i];
			*total += xsize;
		}
	}

	/* 
	 * If only one partition has been set up via swapon(8), we don't
	 * need to bother with totals.
	 */
#if DEV_BSHIFT < 10
	*used = (*total - nfree) >> (10 - DEV_BSHIFT);
	*total >>= 10 - DEV_BSHIFT;
#elif DEV_BSHIFT > 10
	*used = (*total - nfree) >> (DEV_BSHIFT - 10);
	*total >>= DEV_BSHIFT - 10;
#endif
	free (sw); free (freemp); free (perdev);
@


1.13
log
@cp_time is long, deal with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.12 1998/09/20 05:58:54 niklas Exp $	*/
d986 5
a990 3
		xsize = sw[i].sw_nblks;
		xfree = perdev[i];
		*total += xsize;
@


1.12
log
@widen unsigned entities to signed ones before subtracting, fixes sorting on alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.11 1998/08/21 13:55:23 kstailey Exp $	*/
d146 3
a148 3
static int cp_time[CPUSTATES];
static int cp_old[CPUSTATES];
static int cp_diff[CPUSTATES];
@


1.11
log
@support "-o field" and the interactive "o" command
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.10 1998/07/08 22:14:16 deraadt Exp $	*/
d599 1
a599 1
	if (lresult = PP(p2, p_pctcpu) - PP(p1, p_pctcpu), \
@


1.10
log
@whack kmem gid after kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.9 1998/06/25 16:54:35 deraadt Exp $	*/
d17 1
a17 1
 * CFLAGS: -DHAVE_GETOPT
d22 1
d176 6
d254 3
d575 199
a784 10
static unsigned char sorted_state[] =
{
    0,	/* not used		*/
    4,	/* start		*/
    5,	/* run			*/
    2,	/* sleep		*/
    3,	/* stop			*/
    1	/* zombie		*/
};
 
d832 1
a832 1

@


1.9
log
@handle missing swap
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.8 1997/11/08 23:36:44 millert Exp $	*/
d205 3
@


1.8
log
@Sort idle processes by total CPU usage, not cpticks since cpticks
get zeroed every second; dan@@dan.emsphone.com
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.7 1997/09/09 15:23:13 millert Exp $	*/
d696 5
@


1.7
log
@"last pid" stuff is useless with random pids.
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.6 1997/09/09 14:58:21 millert Exp $	*/
d603 2
a604 2
	/* use cpticks to break the tie */
	if ((result = PP(p2, p_cpticks) - PP(p1, p_cpticks)) == 0)
@


1.6
log
@Use kvm_openfiles() not the sunos compat kvm_open().
Use warn/warnx where it makes sense and check some more ret vals.
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.5 1997/08/24 18:37:46 millert Exp $	*/
a27 1
#define LASTPID
a92 4

#define	X_LASTPID	10
#elif defined(LASTPID)
#define	X_LASTPID	2
a107 3
#ifdef LASTPID
    { "_lastpid" },		/* 2 / 10 */
#endif
a142 4
#ifdef LASTPID
static unsigned long lastpid_offset;
static pid_t lastpid;
#endif
a221 3
#ifdef LASTPID
    lastpid_offset = nlst[X_LASTPID].n_value;
#endif
a275 4
#ifdef LASTPID
    (void) getkval(lastpid_offset, (int *)&lastpid, sizeof(lastpid),
		   "!");
#endif
d327 1
a327 6
#ifdef LASTPID
    if (lastpid > 0)
	si->last_pid = lastpid;
    else
#endif
	si->last_pid = -1;
@


1.5
log
@Fix compiler warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.4 1997/08/22 07:39:27 downsj Exp $	*/
d34 2
d211 1
d213 4
a216 3
    if ((kd = kvm_open(NULL, NULL, NULL, O_RDONLY, "kvm_open")) == NULL)
	return -1;

d219 2
a220 4
    (void) kvm_nlist(kd, nlst);
    if (nlst[0].n_type == 0)
    {
	fprintf(stderr, "top: nlist failed\n");
a225 1
    {
a226 1
    }
d305 1
a305 1
	    (void) fprintf(stderr, "top: sysctl failed: %s\n", strerror(errno));
d325 1
a325 1
	    (void) fprintf(stderr, "top: sysctl failed: %s\n", strerror(errno));
d376 4
a379 1
    pbase = kvm_getprocs(kd, KERN_PROC_ALL, 0, &nproc);
d383 2
a384 2
    if (pref == NULL || pbase == NULL) {
	(void) fprintf(stderr, "top: Out of memory.\n");
d577 1
a577 2
	    fprintf(stderr, "top: kvm_read for %s: %s\n",
		refstr, strerror(errno));
@


1.4
log
@Two more alpha warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.3 1997/08/22 07:16:28 downsj Exp $	*/
d485 1
a485 1
		(unsigned int)(PP(pp, p_wchan)) & ~KERNBASE);
@


1.3
log
@First sweep.  Prototype, type fixes, long fixes, mostly compiles with
-Wall.
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.2 1997/08/17 23:18:47 kstailey Exp $	*/
d301 1
a301 1
	int size = sizeof(sysload);
d320 1
a320 1
	int size = sizeof(total);
d484 1
a484 1
	    snprintf(waddr, sizeof(waddr), "%x", 
@


1.2
log
@print "idle" for idle processes
@
text
@d1 1
a1 1
/*	$OpenBSD: machine.c,v 1.1 1997/08/14 14:00:22 downsj Exp $	*/
a30 1
#include "os.h"
d33 1
a54 1
extern char* printable __P((char *));
d57 1
d144 1
a144 1
static          long hz;
d155 3
a157 3
static long cp_time[CPUSTATES];
static long cp_old[CPUSTATES];
static long cp_diff[CPUSTATES];
d286 1
a286 1
    long total;
d360 1
a360 1
int (*compare)();
d447 1
a447 1
    register long cputime;
d485 1
a485 1
		(unsigned long)(PP(pp, p_wchan)) & ~KERNBASE);
d606 1
a606 1
proc_compare(pp1, pp2)
d608 1
a608 2
struct proc **pp1;
struct proc **pp2;
d611 2
d666 1
a666 1
int pid;
d678 1
a678 1
	if (PP(pp, p_pid) == (pid_t)pid)
@


1.1
log
@top 3.4, with a few changes.  Still needs more work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d500 2
a501 1
	    state_abbrev[(unsigned char) PP(pp, p_stat)],
@
