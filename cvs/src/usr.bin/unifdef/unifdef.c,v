head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.2
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.28.0.6
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.15.0.10
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.6
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.12
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.8
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.6
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.12
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.10
	OPENBSD_2_8:1.3.0.8
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2017.04.02.02.51.51;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	2MzqyZbTIG8WtXLB;

1.28
date	2016.03.15.01.00.17;	author mmcc;	state Exp;
branches;
next	1.27;
commitid	Q9IIV8nuRebks69D;

1.27
date	2015.12.10.22.52.12;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	CJJTsvohwBhmOr86;

1.26
date	2015.12.10.19.10.46;	author mmcc;	state Exp;
branches;
next	1.25;
commitid	UnuG5HBgBaiRlgFL;

1.25
date	2015.12.04.21.23.19;	author mmcc;	state Exp;
branches;
next	1.24;
commitid	4rr6qpSkmrhhcFZ4;

1.24
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	sbrB3Q5CNxcwZpfU;

1.23
date	2015.10.05.06.57.01;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	j4v0iEP2wibPVc5p;

1.22
date	2015.10.05.06.54.59;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	uzxRO8YxicG3arDR;

1.21
date	2015.10.03.20.12.53;	author tedu;	state Exp;
branches;
next	1.20;
commitid	PPSZNrimJ0gStJrm;

1.20
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	0Dp7Dy9FuNZesYo2;

1.19
date	2015.04.18.18.28.38;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	6b2lLILbgCR1fvia;

1.18
date	2015.02.17.05.16.09;	author miod;	state Exp;
branches;
next	1.17;
commitid	enVRsSxBx3NOEeTV;

1.17
date	2014.04.30.06.06.09;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.18.21.11.34;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.46;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.25.15.57.28;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.02.14.12.51;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.30.18.37.48;	author avsm;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.03.02.56.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.22.18.26.15;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.18.23.42.51;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.02.07.16.23;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.04.20.27.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.10.19.13.07;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.56;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.11.16.21.58.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.42.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.29;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Replace snprintf(NULL, malloc, snprintf.... with the much better asprintf.
ok millert
@
text
@/*
 * Copyright (c) 2002 - 2014 Tony Finch <dot@@dotat.at>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * unifdef - remove ifdef'ed lines
 *
 * This code was derived from software contributed to Berkeley by Dave Yost.
 * It was rewritten to support ANSI C by Tony Finch. The original version
 * of unifdef carried the 4-clause BSD copyright licence. None of its code
 * remains in this version (though some of the names remain) so it now
 * carries a more liberal licence.
 *
 *  Wishlist:
 *      provide an option which will append the name of the
 *        appropriate symbol after #else's and #endif's
 *      provide an option which will check symbols after
 *        #else's and #endif's to see that they match their
 *        corresponding #ifdef or #ifndef
 *
 *   These require better buffer handling, which would also make
 *   it possible to handle all "dodgy" directives correctly.
 */

#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

static const char copyright[] =
    #include "version.h"
    "@@(#) $Author: mmcc $\n"
    "@@(#) $URL: http://dotat.at/prog/unifdef $\n"
;

/* types of input lines: */
typedef enum {
	LT_TRUEI,		/* a true #if with ignore flag */
	LT_FALSEI,		/* a false #if with ignore flag */
	LT_IF,			/* an unknown #if */
	LT_TRUE,		/* a true #if */
	LT_FALSE,		/* a false #if */
	LT_ELIF,		/* an unknown #elif */
	LT_ELTRUE,		/* a true #elif */
	LT_ELFALSE,		/* a false #elif */
	LT_ELSE,		/* #else */
	LT_ENDIF,		/* #endif */
	LT_DODGY,		/* flag: directive is not on one line */
	LT_DODGY_LAST = LT_DODGY + LT_ENDIF,
	LT_PLAIN,		/* ordinary line */
	LT_EOF,			/* end of file */
	LT_ERROR,		/* unevaluable #if */
	LT_COUNT
} Linetype;

static char const * const linetype_name[] = {
	"TRUEI", "FALSEI", "IF", "TRUE", "FALSE",
	"ELIF", "ELTRUE", "ELFALSE", "ELSE", "ENDIF",
	"DODGY TRUEI", "DODGY FALSEI",
	"DODGY IF", "DODGY TRUE", "DODGY FALSE",
	"DODGY ELIF", "DODGY ELTRUE", "DODGY ELFALSE",
	"DODGY ELSE", "DODGY ENDIF",
	"PLAIN", "EOF", "ERROR"
};

#define linetype_if2elif(lt) ((Linetype)(lt - LT_IF + LT_ELIF))
#define linetype_2dodgy(lt) ((Linetype)(lt + LT_DODGY))

/* state of #if processing */
typedef enum {
	IS_OUTSIDE,
	IS_FALSE_PREFIX,	/* false #if followed by false #elifs */
	IS_TRUE_PREFIX,		/* first non-false #(el)if is true */
	IS_PASS_MIDDLE,		/* first non-false #(el)if is unknown */
	IS_FALSE_MIDDLE,	/* a false #elif after a pass state */
	IS_TRUE_MIDDLE,		/* a true #elif after a pass state */
	IS_PASS_ELSE,		/* an else after a pass state */
	IS_FALSE_ELSE,		/* an else after a true state */
	IS_TRUE_ELSE,		/* an else after only false states */
	IS_FALSE_TRAILER,	/* #elifs after a true are false */
	IS_COUNT
} Ifstate;

static char const * const ifstate_name[] = {
	"OUTSIDE", "FALSE_PREFIX", "TRUE_PREFIX",
	"PASS_MIDDLE", "FALSE_MIDDLE", "TRUE_MIDDLE",
	"PASS_ELSE", "FALSE_ELSE", "TRUE_ELSE",
	"FALSE_TRAILER"
};

/* state of comment parser */
typedef enum {
	NO_COMMENT = false,	/* outside a comment */
	C_COMMENT,		/* in a comment like this one */
	CXX_COMMENT,		/* between // and end of line */
	STARTING_COMMENT,	/* just after slash-backslash-newline */
	FINISHING_COMMENT,	/* star-backslash-newline in a C comment */
	CHAR_LITERAL,		/* inside '' */
	STRING_LITERAL		/* inside "" */
} Comment_state;

static char const * const comment_name[] = {
	"NO", "C", "CXX", "STARTING", "FINISHING", "CHAR", "STRING"
};

/* state of preprocessor line parser */
typedef enum {
	LS_START,		/* only space and comments on this line */
	LS_HASH,		/* only space, comments, and a hash */
	LS_DIRTY		/* this line can't be a preprocessor line */
} Line_state;

static char const * const linestate_name[] = {
	"START", "HASH", "DIRTY"
};

/*
 * Minimum translation limits from ISO/IEC 9899:1999 5.2.4.1
 */
#define	MAXDEPTH        64			/* maximum #if nesting */
#define	MAXLINE         4096			/* maximum length of line */
#define	MAXSYMS         16384			/* maximum number of symbols */

/*
 * Sometimes when editing a keyword the replacement text is longer, so
 * we leave some space at the end of the tline buffer to accommodate this.
 */
#define	EDITSLOP        10

/*
 * Globals.
 */

static bool             compblank;		/* -B: compress blank lines */
static bool             lnblank;		/* -b: blank deleted lines */
static bool             complement;		/* -c: do the complement */
static bool             debugging;		/* -d: debugging reports */
static bool             inplace;		/* -m: modify in place */
static bool             iocccok;		/* -e: fewer IOCCC errors */
static bool             strictlogic;		/* -K: keep ambiguous #ifs */
static bool             killconsts;		/* -k: eval constant #ifs */
static bool             lnnum;			/* -n: add #line directives */
static bool             symlist;		/* -s: output symbol list */
static bool             symdepth;		/* -S: output symbol depth */
static bool             text;			/* -t: this is a text file */

static const char      *symname[MAXSYMS];	/* symbol name */
static const char      *value[MAXSYMS];		/* -Dsym=value */
static bool             ignore[MAXSYMS];	/* -iDsym or -iUsym */
static int              nsyms;			/* number of symbols */

static FILE            *input;			/* input file pointer */
static const char      *filename;		/* input file name */
static int              linenum;		/* current line number */
static const char      *linefile;		/* file name for #line */
static FILE            *output;			/* output file pointer */
static const char      *ofilename;		/* output file name */
static const char      *backext;		/* backup extension */
static char            *tempname;		/* avoid splatting input */

static char             tline[MAXLINE+EDITSLOP];/* input buffer plus space */
static char            *keyword;		/* used for editing #elif's */

/*
 * When processing a file, the output's newline style will match the
 * input's, and unifdef correctly handles CRLF or LF endings whatever
 * the platform's native style. The stdio streams are opened in binary
 * mode to accommodate platforms whose native newline style is CRLF.
 * When the output isn't a processed input file (when it is error /
 * debug / diagnostic messages) then unifdef uses native line endings.
 */

static const char      *newline;		/* input file format */
static const char       newline_unix[] = "\n";
static const char       newline_crlf[] = "\r\n";

static Comment_state    incomment;		/* comment parser state */
static Line_state       linestate;		/* #if line parser state */
static Ifstate          ifstate[MAXDEPTH];	/* #if processor state */
static bool             ignoring[MAXDEPTH];	/* ignore comments state */
static int              stifline[MAXDEPTH];	/* start of current #if */
static int              depth;			/* current #if nesting */
static int              delcount;		/* count of deleted lines */
static unsigned         blankcount;		/* count of blank lines */
static unsigned         blankmax;		/* maximum recent blankcount */
static bool             constexpr;		/* constant #if expression */
static bool             zerosyms;		/* to format symdepth output */
static bool             firstsym;		/* ditto */

static int              exitmode;		/* exit status mode */
static int              exitstat;		/* program exit status */

static void             addsym1(bool, bool, char *);
static void             addsym2(bool, const char *, const char *);
static char            *astrcat(const char *, const char *);
static void             cleantemp(void);
static void             closeio(void);
static void             debug(const char *, ...);
static void             debugsym(const char *, int);
static bool             defundef(void);
static void             defundefile(const char *);
static void             done(void);
static void             error(const char *);
static int              findsym(const char **);
static void             flushline(bool);
static void             hashline(void);
static void             help(void);
static Linetype         ifeval(const char **);
static void             ignoreoff(void);
static void             ignoreon(void);
static void             indirectsym(void);
static void             keywordedit(const char *);
static const char      *matchsym(const char *, const char *);
static void             nest(void);
static Linetype         parseline(void);
static void             process(void);
static void             processinout(const char *, const char *);
static const char      *skipargs(const char *);
static const char      *skipcomment(const char *);
static const char      *skiphash(void);
static const char      *skipline(const char *);
static const char      *skipsym(const char *);
static void             state(Ifstate);
static void             unnest(void);
static void             usage(void);
static void             version(void);
static const char      *xstrdup(const char *, const char *);
static FILE *		mktempmode(char *tmp, int mode);

#define endsym(c) (!isalnum((unsigned char)c) && c != '_')

/*
 * The main program.
 */
int
main(int argc, char *argv[])
{
	const char *errstr;
	int opt;

	if (pledge("stdio rpath wpath cpath fattr", NULL) == -1)
		err(1, "pledge");

	while ((opt = getopt(argc, argv, "i:D:U:f:I:M:o:x:bBcdehKklmnsStV")) != -1)
		switch (opt) {
		case 'i': /* treat stuff controlled by these symbols as text */
			/*
			 * For strict backwards-compatibility the U or D
			 * should be immediately after the -i but it doesn't
			 * matter much if we relax that requirement.
			 */
			opt = *optarg++;
			if (opt == 'D')
				addsym1(true, true, optarg);
			else if (opt == 'U')
				addsym1(true, false, optarg);
			else
				usage();
			break;
		case 'D': /* define a symbol */
			addsym1(false, true, optarg);
			break;
		case 'U': /* undef a symbol */
			addsym1(false, false, optarg);
			break;
		case 'I': /* no-op for compatibility with cpp */
			break;
		case 'b': /* blank deleted lines instead of omitting them */
		case 'l': /* backwards compatibility */
			lnblank = true;
			break;
		case 'B': /* compress blank lines around removed section */
			compblank = true;
			break;
		case 'c': /* treat -D as -U and vice versa */
			complement = true;
			break;
		case 'd':
			debugging = true;
			break;
		case 'e': /* fewer errors from dodgy lines */
			iocccok = true;
			break;
		case 'f': /* definitions file */
			defundefile(optarg);
			break;
		case 'h':
			help();
			break;
		case 'K': /* keep ambiguous #ifs */
			strictlogic = true;
			break;
		case 'k': /* process constant #ifs */
			killconsts = true;
			break;
		case 'm': /* modify in place */
			inplace = true;
			break;
		case 'M': /* modify in place and keep backup */
			inplace = true;
			backext = optarg;
			break;
		case 'n': /* add #line directive after deleted lines */
			lnnum = true;
			break;
		case 'o': /* output to a file */
			ofilename = optarg;
			break;
		case 's': /* only output list of symbols that control #ifs */
			symlist = true;
			break;
		case 'S': /* list symbols with their nesting depth */
			symlist = symdepth = true;
			break;
		case 't': /* don't parse C comments */
			text = true;
			break;
		case 'V':
			version();
			break;
		case 'x':
			exitmode = strtonum(optarg, 0, 2, &errstr);
			if (errstr)
				errx(1, "-x %s: %s", optarg, errstr);
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;
	if (compblank && lnblank)
		errx(2, "-B and -b are mutually exclusive");
	if (symlist && (ofilename != NULL || inplace || argc > 1))
		errx(2, "-s only works with one input file");
	if (argc > 1 && ofilename != NULL)
		errx(2, "-o cannot be used with multiple input files");
	if (argc > 1 && !inplace)
		errx(2, "multiple input files require -m or -M");
	if (argc == 0 && inplace)
		errx(2, "can't edit stdin in place");
	if (argc == 0)
		argc = 1;
	if (argc == 1 && !inplace && ofilename == NULL)
		ofilename = "-";
	indirectsym();

	atexit(cleantemp);
	if (ofilename != NULL)
		processinout(*argv, ofilename);
	else while (argc-- > 0) {
		processinout(*argv, *argv);
		argv++;
	}
	switch(exitmode) {
	case(0): exit(exitstat);
	case(1): exit(!exitstat);
	case(2): exit(0);
	default: abort(); /* bug */
	}
}

/*
 * File logistics.
 */
static void
processinout(const char *ifn, const char *ofn)
{
	struct stat st;

	if (ifn == NULL || strcmp(ifn, "-") == 0) {
		filename = "[stdin]";
		linefile = NULL;
		input = stdin;
	} else {
		filename = ifn;
		linefile = ifn;
		input = fopen(ifn, "rb");
		if (input == NULL)
			err(2, "can't open %s", ifn);
	}
	if (strcmp(ofn, "-") == 0) {
		output = stdout;
		process();
		return;
	}
	if (stat(ofn, &st) < 0) {
		output = fopen(ofn, "wb");
		if (output == NULL)
			err(2, "can't create %s", ofn);
		process();
		return;
	}

	tempname = astrcat(ofn, ".XXXXXX");
	output = mktempmode(tempname, st.st_mode);
	if (output == NULL)
		err(2, "can't create %s", tempname);

	process();

	if (backext != NULL && *backext != '\0') {
		char *backname = astrcat(ofn, backext);
		if (rename(ofn, backname) < 0)
			err(2, "can't rename \"%s\" to \"%s\"", ofn, backname);
		free(backname);
	}
	if (rename(tempname, ofn) < 0)
		err(2, "can't rename \"%s\" to \"%s\"", tempname, ofn);
	free(tempname);
	tempname = NULL;
}

/*
 * For cleaning up if there is an error.
 */
static void
cleantemp(void)
{
	if (tempname != NULL)
		remove(tempname);
}

/*
 * Self-identification functions.
 */

static void
version(void)
{
	const char *c = copyright;
	for (;;) {
		while (*++c != '$')
			if (*c == '\0')
				exit(0);
		while (*++c != '$')
			putc(*c, stderr);
		putc('\n', stderr);
	}
}

static void
synopsis(FILE *fp)
{
	fprintf(fp,
	    "usage:	unifdef [-BbcdehKkmnSstV] [-[i]Dsym[=val]] [-[i]Usym] [-f defile]\n"
	    "		[-M backext] [-o outfile] [-x 0 | 1 | 2] file ...\n");
}

static void
usage(void)
{
	synopsis(stderr);
	exit(2);
}

static void
help(void)
{
	synopsis(stdout);
	printf(
	    "	-Dsym=val  define preprocessor symbol with given value\n"
	    "	-Dsym      define preprocessor symbol with value 1\n"
	    "	-Usym	   preprocessor symbol is undefined\n"
	    "	-iDsym=val \\  ignore C strings and comments\n"
	    "	-iDsym      ) in sections controlled by these\n"
	    "	-iUsym	   /  preprocessor symbols\n"
	    "	-fpath	file containing #define and #undef directives\n"
	    "	-b	blank lines instead of deleting them\n"
	    "	-B	compress blank lines around deleted section\n"
	    "	-c	complement (invert) keep vs. delete\n"
	    "	-d	debugging mode\n"
	    "	-e	ignore multiline preprocessor directives\n"
	    "	-h	print help\n"
	    "	-Ipath	extra include file path (ignored)\n"
	    "	-K	disable && and || short-circuiting\n"
	    "	-k	process constant #if expressions\n"
	    "	-Mext	modify in place and keep backups\n"
	    "	-m	modify input files in place\n"
	    "	-n	add #line directives to output\n"
	    "	-opath	output file name\n"
	    "	-S	list #if control symbols with nesting\n"
	    "	-s	list #if control symbols\n"
	    "	-t	ignore C strings and comments\n"
	    "	-V	print version\n"
	    "	-x{012}	exit status mode\n"
	);
	exit(0);
}

/*
 * A state transition function alters the global #if processing state
 * in a particular way. The table below is indexed by the current
 * processing state and the type of the current line.
 *
 * Nesting is handled by keeping a stack of states; some transition
 * functions increase or decrease the depth. They also maintain the
 * ignore state on a stack. In some complicated cases they have to
 * alter the preprocessor directive, as follows.
 *
 * When we have processed a group that starts off with a known-false
 * #if/#elif sequence (which has therefore been deleted) followed by a
 * #elif that we don't understand and therefore must keep, we edit the
 * latter into a #if to keep the nesting correct. We use memcpy() to
 * overwrite the 4 byte token "elif" with "if  " without a '\0' byte.
 *
 * When we find a true #elif in a group, the following block will
 * always be kept and the rest of the sequence after the next #elif or
 * #else will be discarded. We edit the #elif into a #else and the
 * following directive to #endif since this has the desired behaviour.
 *
 * "Dodgy" directives are split across multiple lines, the most common
 * example being a multi-line comment hanging off the right of the
 * directive. We can handle them correctly only if there is no change
 * from printing to dropping (or vice versa) caused by that directive.
 * If the directive is the first of a group we have a choice between
 * failing with an error, or passing it through unchanged instead of
 * evaluating it. The latter is not the default to avoid questions from
 * users about unifdef unexpectedly leaving behind preprocessor directives.
 */
typedef void state_fn(void);

/* report an error */
static void Eelif (void) { error("Inappropriate #elif"); }
static void Eelse (void) { error("Inappropriate #else"); }
static void Eendif(void) { error("Inappropriate #endif"); }
static void Eeof  (void) { error("Premature EOF"); }
static void Eioccc(void) { error("Obfuscated preprocessor control line"); }
/* plain line handling */
static void print (void) { flushline(true); }
static void drop  (void) { flushline(false); }
/* output lacks group's start line */
static void Strue (void) { drop();  ignoreoff(); state(IS_TRUE_PREFIX); }
static void Sfalse(void) { drop();  ignoreoff(); state(IS_FALSE_PREFIX); }
static void Selse (void) { drop();               state(IS_TRUE_ELSE); }
/* print/pass this block */
static void Pelif (void) { print(); ignoreoff(); state(IS_PASS_MIDDLE); }
static void Pelse (void) { print();              state(IS_PASS_ELSE); }
static void Pendif(void) { print(); unnest(); }
/* discard this block */
static void Dfalse(void) { drop();  ignoreoff(); state(IS_FALSE_TRAILER); }
static void Delif (void) { drop();  ignoreoff(); state(IS_FALSE_MIDDLE); }
static void Delse (void) { drop();               state(IS_FALSE_ELSE); }
static void Dendif(void) { drop();  unnest(); }
/* first line of group */
static void Fdrop (void) { nest();  Dfalse(); }
static void Fpass (void) { nest();  Pelif(); }
static void Ftrue (void) { nest();  Strue(); }
static void Ffalse(void) { nest();  Sfalse(); }
/* variable pedantry for obfuscated lines */
static void Oiffy (void) { if (!iocccok) Eioccc(); Fpass(); ignoreon(); }
static void Oif   (void) { if (!iocccok) Eioccc(); Fpass(); }
static void Oelif (void) { if (!iocccok) Eioccc(); Pelif(); }
/* ignore comments in this block */
static void Idrop (void) { Fdrop();  ignoreon(); }
static void Itrue (void) { Ftrue();  ignoreon(); }
static void Ifalse(void) { Ffalse(); ignoreon(); }
/* modify this line */
static void Mpass (void) { memcpy(keyword, "if  ", 4); Pelif(); }
static void Mtrue (void) { keywordedit("else");  state(IS_TRUE_MIDDLE); }
static void Melif (void) { keywordedit("endif"); state(IS_FALSE_TRAILER); }
static void Melse (void) { keywordedit("endif"); state(IS_FALSE_ELSE); }

static state_fn * const trans_table[IS_COUNT][LT_COUNT] = {
/* IS_OUTSIDE */
{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Eelif, Eelif, Eelif, Eelse, Eendif,
  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eelif, Eelif, Eelif, Eelse, Eendif,
  print, done,  abort },
/* IS_FALSE_PREFIX */
{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Mpass, Strue, Sfalse,Selse, Dendif,
  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Mpass, Eioccc,Eioccc,Eioccc,Eioccc,
  drop,  Eeof,  abort },
/* IS_TRUE_PREFIX */
{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Dfalse,Dfalse,Dfalse,Delse, Dendif,
  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eioccc,Eioccc,Eioccc,Eioccc,Eioccc,
  print, Eeof,  abort },
/* IS_PASS_MIDDLE */
{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Pelif, Mtrue, Delif, Pelse, Pendif,
  Oiffy, Oiffy, Fpass, Oif,   Oif,   Pelif, Oelif, Oelif, Pelse, Pendif,
  print, Eeof,  abort },
/* IS_FALSE_MIDDLE */
{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Pelif, Mtrue, Delif, Pelse, Pendif,
  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Eioccc,Eioccc,Eioccc,Eioccc,Eioccc,
  drop,  Eeof,  abort },
/* IS_TRUE_MIDDLE */
{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Melif, Melif, Melif, Melse, Pendif,
  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eioccc,Eioccc,Eioccc,Eioccc,Pendif,
  print, Eeof,  abort },
/* IS_PASS_ELSE */
{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Eelif, Eelif, Eelif, Eelse, Pendif,
  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eelif, Eelif, Eelif, Eelse, Pendif,
  print, Eeof,  abort },
/* IS_FALSE_ELSE */
{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Eelif, Eelif, Eelif, Eelse, Dendif,
  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Eelif, Eelif, Eelif, Eelse, Eioccc,
  drop,  Eeof,  abort },
/* IS_TRUE_ELSE */
{ Itrue, Ifalse,Fpass, Ftrue, Ffalse,Eelif, Eelif, Eelif, Eelse, Dendif,
  Oiffy, Oiffy, Fpass, Oif,   Oif,   Eelif, Eelif, Eelif, Eelse, Eioccc,
  print, Eeof,  abort },
/* IS_FALSE_TRAILER */
{ Idrop, Idrop, Fdrop, Fdrop, Fdrop, Dfalse,Dfalse,Dfalse,Delse, Dendif,
  Idrop, Idrop, Fdrop, Fdrop, Fdrop, Dfalse,Dfalse,Dfalse,Delse, Eioccc,
  drop,  Eeof,  abort }
/*TRUEI  FALSEI IF     TRUE   FALSE  ELIF   ELTRUE ELFALSE ELSE  ENDIF
  TRUEI  FALSEI IF     TRUE   FALSE  ELIF   ELTRUE ELFALSE ELSE  ENDIF (DODGY)
  PLAIN  EOF    ERROR */
};

/*
 * State machine utility functions
 */
static void
ignoreoff(void)
{
	if (depth == 0)
		abort(); /* bug */
	ignoring[depth] = ignoring[depth-1];
}
static void
ignoreon(void)
{
	ignoring[depth] = true;
}
static void
keywordedit(const char *replacement)
{
	snprintf(keyword, tline + sizeof(tline) - keyword,
	    "%s%s", replacement, newline);
	print();
}
static void
nest(void)
{
	if (depth > MAXDEPTH-1)
		abort(); /* bug */
	if (depth == MAXDEPTH-1)
		error("Too many levels of nesting");
	depth += 1;
	stifline[depth] = linenum;
}
static void
unnest(void)
{
	if (depth == 0)
		abort(); /* bug */
	depth -= 1;
}
static void
state(Ifstate is)
{
	ifstate[depth] = is;
}

/*
 * The last state transition function. When this is called,
 * lineval == LT_EOF, so the process() loop will terminate.
 */
static void
done(void)
{
	if (incomment)
		error("EOF in comment");
	closeio();
}

/*
 * Write a line to the output or not, according to command line options.
 * If writing fails, closeio() will print the error and exit.
 */
static void
flushline(bool keep)
{
	if (symlist)
		return;
	if (keep ^ complement) {
		bool blankline = tline[strspn(tline, " \t\r\n")] == '\0';
		if (blankline && compblank && blankcount != blankmax) {
			delcount += 1;
			blankcount += 1;
		} else {
			if (lnnum && delcount > 0)
				hashline();
			if (fputs(tline, output) == EOF)
				closeio();
			delcount = 0;
			blankmax = blankcount = blankline ? blankcount + 1 : 0;
		}
	} else {
		if (lnblank && fputs(newline, output) == EOF)
			closeio();
		exitstat = 1;
		delcount += 1;
		blankcount = 0;
	}
	if (debugging && fflush(output) == EOF)
		closeio();
}

/*
 * Format of #line directives depends on whether we know the input filename.
 */
static void
hashline(void)
{
	int e;

	if (linefile == NULL)
		e = fprintf(output, "#line %d%s", linenum, newline);
	else
		e = fprintf(output, "#line %d \"%s\"%s",
		    linenum, linefile, newline);
	if (e < 0)
		closeio();
}

/*
 * Flush the output and handle errors.
 */
static void
closeio(void)
{
	/* Tidy up after findsym(). */
	if (symdepth && !zerosyms)
		printf("\n");
	if (output != NULL && (ferror(output) || fclose(output) == EOF))
			err(2, "%s: can't write to output", filename);
	fclose(input);
}

/*
 * The driver for the state machine.
 */
static void
process(void)
{
	Linetype lineval = LT_PLAIN;
	/* When compressing blank lines, act as if the file
	   is preceded by a large number of blank lines. */
	blankmax = blankcount = 1000;
	zerosyms = true;
	newline = NULL;
	linenum = 0;
	while (lineval != LT_EOF) {
		lineval = parseline();
		trans_table[ifstate[depth]][lineval]();
		debug("process line %d %s -> %s depth %d",
		    linenum, linetype_name[lineval],
		    ifstate_name[ifstate[depth]], depth);
	}
}

/*
 * Parse a line and determine its type. We keep the preprocessor line
 * parser state between calls in the global variable linestate, with
 * help from skipcomment().
 */
static Linetype
parseline(void)
{
	const char *cp;
	int cursym;
	Linetype retval;
	Comment_state wascomment;

	wascomment = incomment;
	cp = skiphash();
	if (cp == NULL)
		return (LT_EOF);
	if (newline == NULL) {
		if (strrchr(tline, '\n') == strrchr(tline, '\r') + 1)
			newline = newline_crlf;
		else
			newline = newline_unix;
	}
	if (*cp == '\0') {
		retval = LT_PLAIN;
		goto done;
	}
	keyword = tline + (cp - tline);
	if ((cp = matchsym("ifdef", keyword)) != NULL ||
	    (cp = matchsym("ifndef", keyword)) != NULL) {
		cp = skipcomment(cp);
		if ((cursym = findsym(&cp)) < 0)
			retval = LT_IF;
		else {
			retval = (keyword[2] == 'n')
			    ? LT_FALSE : LT_TRUE;
			if (value[cursym] == NULL)
				retval = (retval == LT_TRUE)
				    ? LT_FALSE : LT_TRUE;
			if (ignore[cursym])
				retval = (retval == LT_TRUE)
				    ? LT_TRUEI : LT_FALSEI;
		}
	} else if ((cp = matchsym("if", keyword)) != NULL)
		retval = ifeval(&cp);
	else if ((cp = matchsym("elif", keyword)) != NULL)
		retval = linetype_if2elif(ifeval(&cp));
	else if ((cp = matchsym("else", keyword)) != NULL)
		retval = LT_ELSE;
	else if ((cp = matchsym("endif", keyword)) != NULL)
		retval = LT_ENDIF;
	else {
		cp = skipsym(keyword);
		/* no way can we deal with a continuation inside a keyword */
		if (strncmp(cp, "\\\r\n", 3) == 0 ||
		    strncmp(cp, "\\\n", 2) == 0)
			Eioccc();
		cp = skipline(cp);
		retval = LT_PLAIN;
		goto done;
	}
	cp = skipcomment(cp);
	if (*cp != '\0') {
		cp = skipline(cp);
		if (retval == LT_TRUE || retval == LT_FALSE ||
		    retval == LT_TRUEI || retval == LT_FALSEI)
			retval = LT_IF;
		if (retval == LT_ELTRUE || retval == LT_ELFALSE)
			retval = LT_ELIF;
	}
	/* the following can happen if the last line of the file lacks a
	   newline or if there is too much whitespace in a directive */
	if (linestate == LS_HASH) {
		long len = cp - tline;
		if (fgets(tline + len, MAXLINE - len, input) == NULL) {
			if (ferror(input))
				err(2, "can't read %s", filename);
			/* append the missing newline at eof */
			strlcpy(tline + len, newline, sizeof(tline) - len);
			cp += strlen(newline);
			linestate = LS_START;
		} else {
			linestate = LS_DIRTY;
		}
	}
	if (retval != LT_PLAIN && (wascomment || linestate != LS_START)) {
		retval = linetype_2dodgy(retval);
		linestate = LS_DIRTY;
	}
done:
	debug("parser line %d state %s comment %s line", linenum,
	    comment_name[incomment], linestate_name[linestate]);
	return (retval);
}

/*
 * These are the binary operators that are supported by the expression
 * evaluator.
 */
static Linetype op_strict(long *p, long v, Linetype at, Linetype bt) {
	if(at == LT_IF || bt == LT_IF) return (LT_IF);
	return (*p = v, v ? LT_TRUE : LT_FALSE);
}
static Linetype op_lt(long *p, Linetype at, long a, Linetype bt, long b) {
	return op_strict(p, a < b, at, bt);
}
static Linetype op_gt(long *p, Linetype at, long a, Linetype bt, long b) {
	return op_strict(p, a > b, at, bt);
}
static Linetype op_le(long *p, Linetype at, long a, Linetype bt, long b) {
	return op_strict(p, a <= b, at, bt);
}
static Linetype op_ge(long *p, Linetype at, long a, Linetype bt, long b) {
	return op_strict(p, a >= b, at, bt);
}
static Linetype op_eq(long *p, Linetype at, long a, Linetype bt, long b) {
	return op_strict(p, a == b, at, bt);
}
static Linetype op_ne(long *p, Linetype at, long a, Linetype bt, long b) {
	return op_strict(p, a != b, at, bt);
}
static Linetype op_or(long *p, Linetype at, long a, Linetype bt, long b) {
	if (!strictlogic && (at == LT_TRUE || bt == LT_TRUE))
		return (*p = 1, LT_TRUE);
	return op_strict(p, a || b, at, bt);
}
static Linetype op_and(long *p, Linetype at, long a, Linetype bt, long b) {
	if (!strictlogic && (at == LT_FALSE || bt == LT_FALSE))
		return (*p = 0, LT_FALSE);
	return op_strict(p, a && b, at, bt);
}

/*
 * An evaluation function takes three arguments, as follows: (1) a pointer to
 * an element of the precedence table which lists the operators at the current
 * level of precedence; (2) a pointer to an integer which will receive the
 * value of the expression; and (3) a pointer to a char* that points to the
 * expression to be evaluated and that is updated to the end of the expression
 * when evaluation is complete. The function returns LT_FALSE if the value of
 * the expression is zero, LT_TRUE if it is non-zero, LT_IF if the expression
 * depends on an unknown symbol, or LT_ERROR if there is a parse failure.
 */
struct ops;

typedef Linetype eval_fn(const struct ops *, long *, const char **);

static eval_fn eval_table, eval_unary;

/*
 * The precedence table. Expressions involving binary operators are evaluated
 * in a table-driven way by eval_table. When it evaluates a subexpression it
 * calls the inner function with its first argument pointing to the next
 * element of the table. Innermost expressions have special non-table-driven
 * handling.
 */
struct op {
	const char *str;
	Linetype (*fn)(long *, Linetype, long, Linetype, long);
};
struct ops {
	eval_fn *inner;
	struct op op[5];
};
static const struct ops eval_ops[] = {
	{ eval_table, { { "||", op_or } } },
	{ eval_table, { { "&&", op_and } } },
	{ eval_table, { { "==", op_eq },
			{ "!=", op_ne } } },
	{ eval_unary, { { "<=", op_le },
			{ ">=", op_ge },
			{ "<", op_lt },
			{ ">", op_gt } } }
};

/* Current operator precedence level */
static long prec(const struct ops *ops)
{
	return (ops - eval_ops);
}

/*
 * Function for evaluating the innermost parts of expressions,
 * viz. !expr (expr) number defined(symbol) symbol
 * We reset the constexpr flag in the last two cases.
 */
static Linetype
eval_unary(const struct ops *ops, long *valp, const char **cpp)
{
	const char *cp;
	char *ep;
	int sym;
	bool defparen;
	Linetype lt;

	cp = skipcomment(*cpp);
	if (*cp == '!') {
		debug("eval%d !", prec(ops));
		cp++;
		lt = eval_unary(ops, valp, &cp);
		if (lt == LT_ERROR)
			return (LT_ERROR);
		if (lt != LT_IF) {
			*valp = !*valp;
			lt = *valp ? LT_TRUE : LT_FALSE;
		}
	} else if (*cp == '(') {
		cp++;
		debug("eval%d (", prec(ops));
		lt = eval_table(eval_ops, valp, &cp);
		if (lt == LT_ERROR)
			return (LT_ERROR);
		cp = skipcomment(cp);
		if (*cp++ != ')')
			return (LT_ERROR);
	} else if (isdigit((unsigned char)*cp)) {
		debug("eval%d number", prec(ops));
		*valp = strtol(cp, &ep, 0);
		if (ep == cp)
			return (LT_ERROR);
		lt = *valp ? LT_TRUE : LT_FALSE;
		cp = ep;
	} else if (matchsym("defined", cp) != NULL) {
		cp = skipcomment(cp+7);
		if (*cp == '(') {
			cp = skipcomment(cp+1);
			defparen = true;
		} else {
			defparen = false;
		}
		sym = findsym(&cp);
		cp = skipcomment(cp);
		if (defparen && *cp++ != ')') {
			debug("eval%d defined missing ')'", prec(ops));
			return (LT_ERROR);
		}
		if (sym < 0) {
			debug("eval%d defined unknown", prec(ops));
			lt = LT_IF;
		} else {
			debug("eval%d defined %s", prec(ops), symname[sym]);
			*valp = (value[sym] != NULL);
			lt = *valp ? LT_TRUE : LT_FALSE;
		}
		constexpr = false;
	} else if (!endsym(*cp)) {
		debug("eval%d symbol", prec(ops));
		sym = findsym(&cp);
		if (sym < 0) {
			lt = LT_IF;
			cp = skipargs(cp);
		} else if (value[sym] == NULL) {
			*valp = 0;
			lt = LT_FALSE;
		} else {
			*valp = strtol(value[sym], &ep, 0);
			if (*ep != '\0' || ep == value[sym])
				return (LT_ERROR);
			lt = *valp ? LT_TRUE : LT_FALSE;
			cp = skipargs(cp);
		}
		constexpr = false;
	} else {
		debug("eval%d bad expr", prec(ops));
		return (LT_ERROR);
	}

	*cpp = cp;
	debug("eval%d = %d", prec(ops), *valp);
	return (lt);
}

/*
 * Table-driven evaluation of binary operators.
 */
static Linetype
eval_table(const struct ops *ops, long *valp, const char **cpp)
{
	const struct op *op;
	const char *cp;
	long val;
	Linetype lt, rt;

	debug("eval%d", prec(ops));
	cp = *cpp;
	lt = ops->inner(ops+1, valp, &cp);
	if (lt == LT_ERROR)
		return (LT_ERROR);
	for (;;) {
		cp = skipcomment(cp);
		for (op = ops->op; op->str != NULL; op++)
			if (strncmp(cp, op->str, strlen(op->str)) == 0)
				break;
		if (op->str == NULL)
			break;
		cp += strlen(op->str);
		debug("eval%d %s", prec(ops), op->str);
		rt = ops->inner(ops+1, &val, &cp);
		if (rt == LT_ERROR)
			return (LT_ERROR);
		lt = op->fn(valp, lt, *valp, rt, val);
	}

	*cpp = cp;
	debug("eval%d = %d", prec(ops), *valp);
	debug("eval%d lt = %s", prec(ops), linetype_name[lt]);
	return (lt);
}

/*
 * Evaluate the expression on a #if or #elif line. If we can work out
 * the result we return LT_TRUE or LT_FALSE accordingly, otherwise we
 * return just a generic LT_IF.
 */
static Linetype
ifeval(const char **cpp)
{
	Linetype ret;
	long val = 0;

	debug("eval %s", *cpp);
	constexpr = killconsts ? false : true;
	ret = eval_table(eval_ops, &val, cpp);
	debug("eval = %d", val);
	return (constexpr ? LT_IF : ret == LT_ERROR ? LT_IF : ret);
}

/*
 * Read a line and examine its initial part to determine if it is a
 * preprocessor directive. Returns NULL on EOF, or a pointer to a
 * preprocessor directive name, or a pointer to the zero byte at the
 * end of the line.
 */
static const char *
skiphash(void)
{
	const char *cp;

	linenum++;
	if (fgets(tline, MAXLINE, input) == NULL) {
		if (ferror(input))
			err(2, "can't read %s", filename);
		else
			return (NULL);
	}
	cp = skipcomment(tline);
	if (linestate == LS_START && *cp == '#') {
		linestate = LS_HASH;
		return (skipcomment(cp + 1));
	} else if (*cp == '\0') {
		return (cp);
	} else {
		return (skipline(cp));
	}
}

/*
 * Mark a line dirty and consume the rest of it, keeping track of the
 * lexical state.
 */
static const char *
skipline(const char *cp)
{
	const char *pcp;
	if (*cp != '\0')
		linestate = LS_DIRTY;
	while (*cp != '\0') {
		cp = skipcomment(pcp = cp);
		if (pcp == cp)
			cp++;
	}
	return (cp);
}

/*
 * Skip over comments, strings, and character literals and stop at the
 * next character position that is not whitespace. Between calls we keep
 * the comment state in the global variable incomment, and we also adjust
 * the global variable linestate when we see a newline.
 * XXX: doesn't cope with the buffer splitting inside a state transition.
 */
static const char *
skipcomment(const char *cp)
{
	if (text || ignoring[depth]) {
		for (; isspace((unsigned char)*cp); cp++)
			if (*cp == '\n')
				linestate = LS_START;
		return (cp);
	}
	while (*cp != '\0')
		/* don't reset to LS_START after a line continuation */
		if (strncmp(cp, "\\\r\n", 3) == 0)
			cp += 3;
		else if (strncmp(cp, "\\\n", 2) == 0)
			cp += 2;
		else switch (incomment) {
		case NO_COMMENT:
			if (strncmp(cp, "/\\\r\n", 4) == 0) {
				incomment = STARTING_COMMENT;
				cp += 4;
			} else if (strncmp(cp, "/\\\n", 3) == 0) {
				incomment = STARTING_COMMENT;
				cp += 3;
			} else if (strncmp(cp, "/*", 2) == 0) {
				incomment = C_COMMENT;
				cp += 2;
			} else if (strncmp(cp, "//", 2) == 0) {
				incomment = CXX_COMMENT;
				cp += 2;
			} else if (strncmp(cp, "\'", 1) == 0) {
				incomment = CHAR_LITERAL;
				linestate = LS_DIRTY;
				cp += 1;
			} else if (strncmp(cp, "\"", 1) == 0) {
				incomment = STRING_LITERAL;
				linestate = LS_DIRTY;
				cp += 1;
			} else if (strncmp(cp, "\n", 1) == 0) {
				linestate = LS_START;
				cp += 1;
			} else if (strchr(" \r\t", *cp) != NULL) {
				cp += 1;
			} else
				return (cp);
			continue;
		case CXX_COMMENT:
			if (strncmp(cp, "\n", 1) == 0) {
				incomment = NO_COMMENT;
				linestate = LS_START;
			}
			cp += 1;
			continue;
		case CHAR_LITERAL:
		case STRING_LITERAL:
			if ((incomment == CHAR_LITERAL && cp[0] == '\'') ||
			    (incomment == STRING_LITERAL && cp[0] == '\"')) {
				incomment = NO_COMMENT;
				cp += 1;
			} else if (cp[0] == '\\') {
				if (cp[1] == '\0')
					cp += 1;
				else
					cp += 2;
			} else if (strncmp(cp, "\n", 1) == 0) {
				if (incomment == CHAR_LITERAL)
					error("Unterminated char literal");
				else
					error("Unterminated string literal");
			} else
				cp += 1;
			continue;
		case C_COMMENT:
			if (strncmp(cp, "*\\\r\n", 4) == 0) {
				incomment = FINISHING_COMMENT;
				cp += 4;
			} else if (strncmp(cp, "*\\\n", 3) == 0) {
				incomment = FINISHING_COMMENT;
				cp += 3;
			} else if (strncmp(cp, "*/", 2) == 0) {
				incomment = NO_COMMENT;
				cp += 2;
			} else
				cp += 1;
			continue;
		case STARTING_COMMENT:
			if (*cp == '*') {
				incomment = C_COMMENT;
				cp += 1;
			} else if (*cp == '/') {
				incomment = CXX_COMMENT;
				cp += 1;
			} else {
				incomment = NO_COMMENT;
				linestate = LS_DIRTY;
			}
			continue;
		case FINISHING_COMMENT:
			if (*cp == '/') {
				incomment = NO_COMMENT;
				cp += 1;
			} else
				incomment = C_COMMENT;
			continue;
		default:
			abort(); /* bug */
		}
	return (cp);
}

/*
 * Skip macro arguments.
 */
static const char *
skipargs(const char *cp)
{
	const char *ocp = cp;
	int level = 0;
	cp = skipcomment(cp);
	if (*cp != '(')
		return (cp);
	do {
		if (*cp == '(')
			level++;
		if (*cp == ')')
			level--;
		cp = skipcomment(cp+1);
	} while (level != 0 && *cp != '\0');
	if (level == 0)
		return (cp);
	else
	/* Rewind and re-detect the syntax error later. */
		return (ocp);
}

/*
 * Skip over an identifier.
 */
static const char *
skipsym(const char *cp)
{
	while (!endsym(*cp))
		++cp;
	return (cp);
}

/*
 * Skip whitespace and take a copy of any following identifier.
 */
static const char *
getsym(const char **cpp)
{
	const char *cp = *cpp, *sym;

	cp = skipcomment(cp);
	cp = skipsym(sym = cp);
	if (cp == sym)
		return NULL;
	*cpp = cp;
	return (xstrdup(sym, cp));
}

/*
 * Check that s (a symbol) matches the start of t, and that the
 * following character in t is not a symbol character. Returns a
 * pointer to the following character in t if there is a match,
 * otherwise NULL.
 */
static const char *
matchsym(const char *s, const char *t)
{
	while (*s != '\0' && *t != '\0')
		if (*s != *t)
			return (NULL);
		else
			++s, ++t;
	if (*s == '\0' && endsym(*t))
		return(t);
	else
		return(NULL);
}

/*
 * Look for the symbol in the symbol table. If it is found, we return
 * the symbol table index, else we return -1.
 */
static int
findsym(const char **strp)
{
	const char *str;
	int symind;

	str = *strp;
	*strp = skipsym(str);
	if (symlist) {
		if (*strp == str)
			return (-1);
		if (symdepth && firstsym)
			printf("%s%3d", zerosyms ? "" : "\n", depth);
		firstsym = zerosyms = false;
		printf("%s%.*s%s",
		       symdepth ? " " : "",
		       (int)(*strp-str), str,
		       symdepth ? "" : "\n");
		/* we don't care about the value of the symbol */
		return (0);
	}
	for (symind = 0; symind < nsyms; ++symind) {
		if (matchsym(symname[symind], str) != NULL) {
			debugsym("findsym", symind);
			return (symind);
		}
	}
	return (-1);
}

/*
 * Resolve indirect symbol values to their final definitions.
 */
static void
indirectsym(void)
{
	const char *cp;
	int changed, sym, ind;

	do {
		changed = 0;
		for (sym = 0; sym < nsyms; ++sym) {
			if (value[sym] == NULL)
				continue;
			cp = value[sym];
			ind = findsym(&cp);
			if (ind == -1 || ind == sym ||
			    *cp != '\0' ||
			    value[ind] == NULL ||
			    value[ind] == value[sym])
				continue;
			debugsym("indir...", sym);
			value[sym] = value[ind];
			debugsym("...ectsym", sym);
			changed++;
		}
	} while (changed);
}

/*
 * Add a symbol to the symbol table, specified with the format sym=val
 */
static void
addsym1(bool ignorethis, bool definethis, char *symval)
{
	const char *sym, *val;

	sym = symval;
	val = skipsym(sym);
	if (definethis && *val == '=') {
		symval[val - sym] = '\0';
		val = val + 1;
	} else if (*val == '\0') {
		val = definethis ? "1" : NULL;
	} else {
		usage();
	}
	addsym2(ignorethis, sym, val);
}

/*
 * Add a symbol to the symbol table.
 */
static void
addsym2(bool ignorethis, const char *sym, const char *val)
{
	const char *cp = sym;
	int symind;

	symind = findsym(&cp);
	if (symind < 0) {
		if (nsyms >= MAXSYMS)
			errx(2, "too many symbols");
		symind = nsyms++;
	}
	ignore[symind] = ignorethis;
	symname[symind] = sym;
	value[symind] = val;
	debugsym("addsym", symind);
}

static void
debugsym(const char *why, int symind)
{
	debug("%s %s%c%s", why, symname[symind],
	    value[symind] ? '=' : ' ',
	    value[symind] ? value[symind] : "undef");
}

/*
 * Add symbols to the symbol table from a file containing
 * #define and #undef preprocessor directives.
 */
static void
defundefile(const char *fn)
{
	filename = fn;
	input = fopen(fn, "rb");
	if (input == NULL)
		err(2, "can't open %s", fn);
	linenum = 0;
	while (defundef())
		;
	if (ferror(input))
		err(2, "can't read %s", filename);
	else
		fclose(input);
	if (incomment)
		error("EOF in comment");
}

/*
 * Read and process one #define or #undef directive
 */
static bool
defundef(void)
{
	const char *cp, *kw, *sym, *val, *end;

	cp = skiphash();
	if (cp == NULL)
		return (false);
	if (*cp == '\0')
		goto done;
	/* strip trailing whitespace, and do a fairly rough check to
	   avoid unsupported multi-line preprocessor directives */
	end = cp + strlen(cp);
	while (end > tline && strchr(" \t\n\r", end[-1]) != NULL)
		--end;
	if (end > tline && end[-1] == '\\')
		Eioccc();

	kw = cp;
	if ((cp = matchsym("define", kw)) != NULL) {
		sym = getsym(&cp);
		if (sym == NULL)
			error("Missing macro name in #define");
		if (*cp == '(') {
			val = "1";
		} else {
			cp = skipcomment(cp);
			val = (cp < end) ? xstrdup(cp, end) : "";
		}
		debug("#define");
		addsym2(false, sym, val);
	} else if ((cp = matchsym("undef", kw)) != NULL) {
		sym = getsym(&cp);
		if (sym == NULL)
			error("Missing macro name in #undef");
		cp = skipcomment(cp);
		debug("#undef");
		addsym2(false, sym, NULL);
	} else {
		error("Unrecognized preprocessor directive");
	}
	skipline(cp);
done:
	debug("parser line %d state %s comment %s line", linenum,
	    comment_name[incomment], linestate_name[linestate]);
	return (true);
}

/*
 * Concatenate two strings into new memory, checking for failure.
 */
static char *
astrcat(const char *s1, const char *s2)
{
	char *s;

	if (asprintf(&s, "%s%s", s1, s2) < 0)
		err(2, "asprintf");
	return (s);
}

/*
 * Duplicate a segment of a string, checking for failure.
 */
static const char *
xstrdup(const char *start, const char *end)
{
	size_t n;
	char *s;

	if (end < start) abort(); /* bug */
	n = (size_t)(end - start) + 1;
	s = (char *)malloc(n);
	if (s == NULL)
		err(2, "malloc");
	snprintf(s, n, "%s", start);
	return (s);
}

/*
 * Diagnostics.
 */
static void
debug(const char *msg, ...)
{
	va_list ap;

	if (debugging) {
		va_start(ap, msg);
		vwarnx(msg, ap);
		va_end(ap);
	}
}

static void
error(const char *msg)
{
	if (depth == 0)
		warnx("%s: %d: %s", filename, linenum, msg);
	else
		warnx("%s: %d: %s (#if line %d depth %d)",
		    filename, linenum, msg, stifline[depth], depth);
	closeio();
	errx(2, "Output may be truncated");
}

static FILE *
mktempmode(char *tmp, int mode)
{
	int fd = mkstemp(tmp);
	if (fd < 0)
		return (NULL);
	fchmod(fd, mode & (S_IRWXU|S_IRWXG|S_IRWXO));
	return (fdopen(fd, "wb"));
}
@


1.28
log
@Replace two malloc casts that deraadt@@ and I removed over the past year
or two. Upstream wants to keep them for C++ support, and it isn't worth
maintaining a larger diff. No binary change.

Upstream commit:

https://github.com/fanf2/unifdef/commit/87dfd91

I'll send more merging diffs to tech@@ soon.
@
text
@a1532 2
	int len;
	size_t size;
d1534 2
a1535 8
	len = snprintf(NULL, 0, "%s%s", s1, s2);
	if (len < 0)
		err(2, "snprintf");
	size = (size_t)len + 1;
	s = (char *)malloc(size);
	if (s == NULL)
		err(2, "malloc");
	snprintf(s, size, "%s%s", s1, s2);
@


1.27
log
@Merge a lexer fix from upstream:

https://github.com/fanf2/unifdef/commit/90ca2eee76db715943ec4b7ca2892d155ca64075

Fixes the supplied test case, as expected.

ok sthen@@
@
text
@d1540 1
a1540 1
	s = malloc(size);
d1558 1
a1558 1
	s = malloc(n);
@


1.26
log
@Capitalize a few error messages to reduce diff with upstream.
@
text
@d1141 1
d1144 5
a1148 2
	while (*cp != '\0')
		cp = skipcomment(cp + 1);
@


1.25
log
@Document that the -M option doesn't save a backup when passed ''. Also
clean up the corresponding logic to avoid a useless rename(2) call.

ok deraadt sthen
@
text
@d59 1
a59 1
    "@@(#) $Author: deraadt $\n"
d1220 1
a1220 1
					error("unterminated char literal");
d1222 1
a1222 1
					error("unterminated string literal");
d1496 1
a1496 1
			error("missing macro name in #define");
d1508 1
a1508 1
			error("missing macro name in #undef");
d1513 1
a1513 1
		error("unrecognized preprocessor directive");
d1585 1
a1585 1
	errx(2, "output may be truncated");
@


1.24
log
@Change all tame callers to namechange to pledge(2).
@
text
@d428 1
a428 1
	if (backext != NULL) {
@


1.23
log
@tame "stdio rpath wpath cpath fattr", because this creates new files,
fchmod's them, and possibly renames them.
ok doug
@
text
@d268 2
a269 2
	if (tame("stdio rpath wpath cpath fattr", NULL) == -1)
		err(1, "tame");
@


1.22
log
@refactor, so we don't a C function in a .h file, yuck!
@
text
@d59 1
a59 1
    "@@(#) $Author: tedu $\n"
d267 3
@


1.21
log
@you can't edit stdin in place. check for this before the hack that
increments argc when run with no arguments, causing a read past the end
of argv.
@
text
@d46 10
a55 1
#include "unifdef.h"
d59 1
a59 1
    "@@(#) $Author: deraadt $\n"
d255 1
d397 1
a397 1
		input = fbinmode(stdin);
d406 1
a406 1
		output = fbinmode(stdout);
d431 1
a431 1
	if (replace(tempname, ofn) < 0)
d1583 10
@


1.20
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d353 2
@


1.19
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d50 1
a50 1
    "@@(#) $Author: miod $\n"
d1521 1
a1521 1
	s = (char *)malloc(size);
@


1.18
log
@Convert a strcpy() call to strlcpy(); ok millert@@ sthen@@
@
text
@d50 1
a50 1
    "@@(#) $Author: jmc $\n"
d255 1
d336 3
a338 3
			exitmode = atoi(optarg);
			if(exitmode < 0 || exitmode > 2)
				usage();
@


1.17
log
@tidy up SYNOPSIS, usage() and the options list; ok sthen
@
text
@d50 1
a50 1
    "@@(#) $Author: sthen $\n"
d841 1
a841 1
			strcpy(tline + len, newline);
@


1.16
log
@Since we've been making heavy use of unifdef recently: update it to the
recent 2.10 release.

"This code was derived from software contributed to Berkeley by Dave Yost.
It was rewritten to support ANSI C by Tony Finch. The original version
of unifdef carried the 4-clause BSD copyright licence. None of its code
remains in this version (though some of the names remain) so it now
carries a more liberal licence."

ok deraadt@@
@
text
@d50 1
a50 1
    "@@(#) $Author: Tony Finch (dot@@dotat.at) $\n"
d456 2
a457 2
	    "usage:	unifdef [-bBcdehKkmnsStV] [-x{012}] [-Mext] [-opath] \\\n"
	    "		[-[i]Dsym[=val]] [-[i]Usym] [-fpath] ... [file] ...\n");
@


1.15
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@a0 1
/*	$OpenBSD: unifdef.c,v 1.14 2009/10/27 23:59:46 deraadt Exp $	*/
d2 1
a2 6
 * Copyright (c) 2002, 2003 Tony Finch <dot@@dotat.at>
 * Copyright (c) 1985, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Dave Yost. Support for #if and #elif was added by Tony Finch.
a11 3
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d13 1
a13 1
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
d16 1
a16 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
d29 6
a40 1
 *      generate #line directives in place of deleted code
d42 2
a43 2
 *   The first two items above require better buffer handling, which would
 *     also make it possible to handle all "dodgy" directives correctly.
d46 7
a52 8
#include <ctype.h>
#include <err.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
d70 1
d81 1
a81 1
	"PLAIN", "EOF"
d84 3
d115 3
a117 1
	FINISHING_COMMENT	/* star-backslash-newline in a C comment */
d121 1
a121 1
	"NO", "C", "CXX", "STARTING", "FINISHING"
d140 1
a140 1
#define	MAXSYMS         4096			/* maximum number of symbols */
d152 2
d156 1
d158 1
d160 1
a160 1
static bool             lnblank;		/* -l: blank deleted lines */
d162 1
d173 5
d182 13
d201 6
a206 1
static bool             keepthis;		/* don't delete constant #if */
d208 1
d211 5
a215 1
static void             addsym(bool, bool, char *);
d217 4
d222 1
a222 1
static int              findsym(const char *);
d224 2
a225 1
static Linetype         get_line(void);
d229 1
d231 1
d233 1
d235 2
d238 2
d242 1
a242 1
static int              strlcmp(const char *, const char *, size_t);
d244 2
d247 1
a247 1
#define endsym(c) (!isalpha((unsigned char)c) && !isdigit((unsigned char)c) && c != '_')
d257 1
a257 1
	while ((opt = getopt(argc, argv, "i:D:U:I:cdeklst")) != -1)
d267 1
a267 1
				addsym(true, true, optarg);
d269 1
a269 1
				addsym(true, false, optarg);
d274 1
a274 1
			addsym(false, true, optarg);
d277 7
a283 1
			addsym(false, false, optarg);
d285 2
a286 2
		case 'I':
			/* no-op for compatibility with cpp */
d297 9
d309 12
a320 2
		case 'l': /* blank deleted lines instead of omitting them */
			lnblank = true;
d325 3
d331 8
d344 26
a369 3
	if (nsyms == 0 && !symlist) {
		warnx("must -D or -U at least one symbol");
		usage();
d371 14
a384 9
	if (argc > 1) {
		errx(2, "can only do one file");
	} else if (argc == 1 && strcmp(*argv, "-") != 0) {
		filename = *argv;
		if ((input = fopen(filename, "r")) != NULL) {
			process();
			(void) fclose(input);
		} else
			err(2, "can't open %s", *argv);
d386 15
a400 2
		filename = "[stdin]";
		input = stdin;
d402 47
d450 1
d452 6
a457 1
	exit(exitstat);
d463 1
a463 4
	fprintf(stderr,
	    "usage: unifdef [-ceklst] [-Dsym[=val]] [-Ipath] [-iDsym[=val]] "
	    "[-iUsym] [-Usym]\n"
	    "\t[file]\n");
d467 34
d504 1
a504 2
 * processing state and the type of the current line. A NULL entry
 * indicates that processing is complete.
d514 2
a515 1
 * latter into a #if to keep the nesting correct.
d534 5
a538 30
static void
Eelif(void)
{
	error("Inappropriate #elif");
}

static void
Eelse(void)
{
	error("Inappropriate #else");
}

static void
Eendif(void)
{
	error("Inappropriate #endif");
}

static void
Eeof(void)
{
	error("Premature EOF");
}

static void
Eioccc(void)
{
	error("Obfuscated preprocessor control line");
}

d540 2
a541 12
static void
print(void)
{
	flushline(true);
}

static void
drop(void)
{
	flushline(false);
}

d543 3
a545 23
static void
Strue(void)
{
	drop();
	ignoreoff();
	state(IS_TRUE_PREFIX);
}

static void
Sfalse(void)
{
	drop();
	ignoreoff();
	state(IS_FALSE_PREFIX);
}

static void
Selse(void)
{
	drop();
	state(IS_TRUE_ELSE);
}

d547 3
a549 22
static void
Pelif(void)
{
	print();
	ignoreoff();
	state(IS_PASS_MIDDLE);
}

static void
Pelse(void)
{
	print();
	state(IS_PASS_ELSE);
}

static void
Pendif(void)
{
	print();
	--depth;
}

d551 4
a554 30
static void
Dfalse(void)
{
	drop();
	ignoreoff();
	state(IS_FALSE_TRAILER);
}

static void
Delif(void)
{
	drop();
	ignoreoff();
	state(IS_FALSE_MIDDLE);
}

static void
Delse(void)
{
	drop();
	state(IS_FALSE_ELSE);
}

static void
Dendif(void)
{
	drop();
	--depth;
}

d556 4
a559 28
static void
Fdrop(void)
{
	nest();
	Dfalse();
}

static void
Fpass(void)
{
	nest();
	Pelif();
}

static void
Ftrue(void)
{
	nest();
	Strue();
}

static void
Ffalse(void)
{
	nest();
	Sfalse();
}

d561 3
a563 28
static void
Oiffy(void)
{
	if (iocccok)
		Fpass();
	else
		Eioccc();
	ignoreon();
}

static void
Oif(void)
{
	if (iocccok)
		Fpass();
	else
		Eioccc();
}

static void
Oelif(void)
{
	if (iocccok)
		Pelif();
	else
		Eioccc();
}

d565 8
a572 49
static void
Idrop(void)
{
	Fdrop();
	ignoreon();
}

static void
Itrue(void)
{
	Ftrue();
	ignoreon();
}

static void
Ifalse(void)
{
	Ffalse();
	ignoreon();
}

/* edit this line */
static void
Mpass (void)
{
	strncpy(keyword, "if  ", 4);
	Pelif();
}

static void
Mtrue (void)
{
	keywordedit("else\n");
	state(IS_TRUE_MIDDLE);
}

static void
Melif (void)
{
	keywordedit("endif\n");
	state(IS_FALSE_TRAILER);
}

static void
Melse (void)
{
	keywordedit("endif\n");
	state(IS_FALSE_ELSE);
}
d578 1
a578 1
  print, NULL },
d582 1
a582 1
  drop,  Eeof },
d586 1
a586 1
  print, Eeof },
d590 1
a590 1
  print, Eeof },
d594 1
a594 1
  drop,  Eeof },
d598 1
a598 1
  print, Eeof },
d602 1
a602 1
  print, Eeof },
d606 1
a606 1
  drop,  Eeof },
d610 1
a610 1
  print, Eeof },
d614 1
a614 1
  drop,  Eeof }
d617 1
a617 1
  PLAIN  EOF */
d626 2
a629 1

a634 1

d638 2
a639 1
	strlcpy(keyword, replacement, tline + sizeof(tline) - keyword);
a641 1

d645 4
a649 2
	if (depth >= MAXDEPTH)
		error("Too many levels of nesting");
d652 7
a658 1

d666 12
d679 1
d686 16
a701 5
	if (keep ^ complement)
		fputs(tline, stdout);
	else {
		if (lnblank)
			putc('\n', stdout);
d703 2
d706 33
d747 12
a758 12
	Linetype lineval;
	state_fn *trans;

	for (;;) {
		linenum++;
		lineval = get_line();
		trans = trans_table[ifstate[depth]][lineval];
		if (trans == NULL)
			break;
		trans();
		debug("process %s -> %s depth %d",
		    linetype_name[lineval],
a760 2
	if (incomment)
		error("EOF in comment");
d765 2
a766 1
 * parser state between calls in a global variable.
d769 1
a769 1
get_line(void)
a772 1
	int kwlen;
d776 3
a778 1
	if (fgets(tline, MAXLINE, input) == NULL)
d780 9
a788 9
	retval = LT_PLAIN;
	wascomment = incomment;
	cp = skipcomment(tline);
	if (linestate == LS_START) {
		if (*cp == '#') {
			linestate = LS_HASH;
			cp = skipcomment(cp + 1);
		} else if (*cp != '\0')
			linestate = LS_DIRTY;
d790 26
a815 4
	if (!incomment && linestate == LS_HASH) {
		keyword = tline + (cp - tline);
		cp = skipsym(cp);
		kwlen = cp - keyword;
d817 2
a818 1
		if (strncmp(cp, "\\\n", 2) == 0)
d820 25
a844 25
		if (strlcmp("ifdef", keyword, kwlen) == 0 ||
		    strlcmp("ifndef", keyword, kwlen) == 0) {
			cp = skipcomment(cp);
			if ((cursym = findsym(cp)) < 0)
				retval = LT_IF;
			else {
				retval = (keyword[2] == 'n')
				    ? LT_FALSE : LT_TRUE;
				if (value[cursym] == NULL)
					retval = (retval == LT_TRUE)
					    ? LT_FALSE : LT_TRUE;
				if (ignore[cursym])
					retval = (retval == LT_TRUE)
					    ? LT_TRUEI : LT_FALSEI;
			}
			cp = skipsym(cp);
		} else if (strlcmp("if", keyword, kwlen) == 0)
			retval = ifeval(&cp);
		else if (strlcmp("elif", keyword, kwlen) == 0)
			retval = ifeval(&cp) - LT_IF + LT_ELIF;
		else if (strlcmp("else", keyword, kwlen) == 0)
			retval = LT_ELSE;
		else if (strlcmp("endif", keyword, kwlen) == 0)
			retval = LT_ENDIF;
		else {
a845 1
			retval = LT_PLAIN;
a846 17
		cp = skipcomment(cp);
		if (*cp != '\0') {
			linestate = LS_DIRTY;
			if (retval == LT_TRUE || retval == LT_FALSE ||
			    retval == LT_TRUEI || retval == LT_FALSEI)
				retval = LT_IF;
			if (retval == LT_ELTRUE || retval == LT_ELFALSE)
				retval = LT_ELIF;
		}
		if (retval != LT_PLAIN && (wascomment || incomment)) {
			retval += LT_DODGY;
			if (incomment)
				linestate = LS_DIRTY;
		}
		/* skipcomment should have changed the state */
		if (linestate == LS_HASH)
			abort(); /* bug */
d848 3
a850 3
	if (linestate == LS_DIRTY) {
		while (*cp != '\0')
			cp = skipcomment(cp + 1);
d852 2
a853 1
	debug("parser %s comment %s line",
d859 2
a860 3
 * These are the operators that are supported by the expression
 * evaluator. Note that if support for division is added then we also
 * need short-circuiting booleans because of divide-by-zero.
d862 6
a867 4
static int
op_lt(int a, int b)
{
	return (a < b);
d869 2
a870 5

static int
op_gt(int a, int b)
{
	return (a > b);
d872 2
a873 5

static int
op_le(int a, int b)
{
	return (a <= b);
d875 2
a876 5

static int
op_ge(int a, int b)
{
	return (a >= b);
d878 2
a879 5

static int
op_eq(int a, int b)
{
	return (a == b);
d881 2
a882 5

static int
op_ne(int a, int b)
{
	return (a != b);
d884 4
a887 5

static int
op_or(int a, int b)
{
	return (a || b);
d889 4
a892 5

static int
op_and(int a, int b)
{
	return (a && b);
d902 2
a903 2
 * the expression is zero, LT_TRUE if it is non-zero, or LT_IF if the
 * expression could not be evaluated.
d907 1
a907 1
typedef Linetype eval_fn(const struct ops *, int *, const char **);
d918 5
a922 1
static const struct ops {
d924 3
a926 5
	struct op {
		const char *str;
		int (*fn)(int, int);
	} op[5];
} eval_ops[] = {
d937 6
d945 2
a946 2
 * viz. !expr (expr) defined(symbol) symbol number
 * We reset the keepthis flag when we find a non-constant subexpression.
d949 1
a949 1
eval_unary(const struct ops *ops, int *valp, const char **cpp)
d954 2
d959 1
a959 1
		debug("eval%d !", ops - eval_ops);
d961 7
a967 3
		if (eval_unary(ops, valp, &cp) == LT_IF)
			return (LT_IF);
		*valp = !*valp;
d970 4
a973 3
		debug("eval%d (", ops - eval_ops);
		if (eval_table(eval_ops, valp, &cp) == LT_IF)
			return (LT_IF);
d976 1
a976 1
			return (LT_IF);
d978 1
a978 1
		debug("eval%d number", ops - eval_ops);
d980 5
a984 2
		cp = skipsym(cp);
	} else if (strncmp(cp, "defined", 7) == 0 && endsym(cp[7])) {
d986 7
a992 3
		debug("eval%d defined", ops - eval_ops);
		if (*cp++ != '(')
			return (LT_IF);
d994 13
a1006 9
		sym = findsym(cp);
		if (sym < 0 && !symlist)
			return (LT_IF);
		*valp = (value[sym] != NULL);
		cp = skipsym(cp);
		cp = skipcomment(cp);
		if (*cp++ != ')')
			return (LT_IF);
		keepthis = false;
d1008 6
a1013 5
		debug("eval%d symbol", ops - eval_ops);
		sym = findsym(cp);
		if (sym < 0 && !symlist)
			return (LT_IF);
		if (value[sym] == NULL)
d1015 2
a1016 1
		else {
d1019 3
a1021 1
				return (LT_IF);
d1023 5
a1027 4
		cp = skipsym(cp);
		keepthis = false;
	} else
		return (LT_IF);
d1030 2
a1031 2
	debug("eval%d = %d", ops - eval_ops, *valp);
	return (*valp ? LT_TRUE : LT_FALSE);
d1038 1
a1038 1
eval_table(const struct ops *ops, int *valp, const char **cpp)
d1042 2
a1043 1
	int val;
d1045 1
a1045 1
	debug("eval%d", ops - eval_ops);
d1047 3
a1049 2
	if (ops->inner(ops+1, valp, &cp) == LT_IF)
		return (LT_IF);
d1058 5
a1062 4
		debug("eval%d %s", ops - eval_ops, op->str);
		if (ops->inner(ops+1, &val, &cp) == LT_IF)
			return (LT_IF);
		*valp = op->fn(*valp, val);
d1066 3
a1068 2
	debug("eval%d = %d", ops - eval_ops, *valp);
	return (*valp ? LT_TRUE : LT_FALSE);
d1079 2
a1080 2
	int ret;
	int val;
d1083 1
a1083 1
	keepthis = killconsts ? false : true;
d1085 45
a1129 1
	return (keepthis ? LT_IF : ret);
d1133 4
a1136 4
 * Skip over comments and stop at the next character position that is
 * not whitespace. Between calls we keep the comment state in the
 * global variable incomment, and we also adjust the global variable
 * linestate when we see a newline.
d1149 4
a1152 1
		if (strncmp(cp, "\\\n", 2) == 0)
d1156 4
a1159 1
			if (strncmp(cp, "/\\\n", 3) == 0) {
d1168 8
d1179 1
a1179 1
			} else if (strchr(" \t", *cp) != NULL) {
d1191 19
d1211 4
a1214 1
			if (strncmp(cp, "*\\\n", 3) == 0) {
d1243 1
a1243 2
			/* bug */
			abort();
d1249 25
d1285 36
d1325 1
a1325 1
findsym(const char *str)
d1327 1
a1327 1
	const char *cp;
d1330 15
a1344 5
	cp = skipsym(str);
	if (cp == str)
		return (-1);
	if (symlist)
		printf("%.*s\n", (int)(cp-str), str);
d1346 2
a1347 3
		if (strlcmp(symname[symind], str, cp-str) == 0) {
			debug("findsym %s %s", symname[symind],
			    value[symind] ? value[symind] : "");
d1355 50
d1408 1
a1408 1
addsym(bool ignorethis, bool definethis, char *sym)
d1410 1
a1411 1
	char *val;
d1413 1
a1413 1
	symind = findsym(sym);
d1419 1
d1421 75
a1495 10
	ignore[symind] = ignorethis;
	val = sym + (skipsym(sym) - sym);
	if (definethis) {
		if (*val == '=') {
			value[symind] = val+1;
			*val = '\0';
		} else if (*val == '\0')
			value[symind] = "";
		else
			usage();
d1497 1
a1497 3
		if (*val != '\0')
			usage();
		value[symind] = NULL;
d1499 26
d1528 1
a1528 2
 * Compare s with n characters of t.
 * The same as strncmp() except that it checks that s[n] == '\0'.
d1530 2
a1531 2
static int
strlcmp(const char *s, const char *t, size_t n)
d1533 10
a1542 6
	while (n-- && *t != '\0')
		if (*s != *t)
			return ((unsigned char)*s - (unsigned char)*t);
		else
			++s, ++t;
	return ((unsigned char)*s);
d1568 1
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: unifdef.c,v 1.13 2007/06/25 15:57:28 jmc Exp $	*/
d186 1
a186 1
static Linetype         getline(void);
d666 1
a666 1
		lineval = getline();
d684 1
a684 1
getline(void)
@


1.13
log
@kill "is is"; from Charles Longeau
@
text
@d1 1
a1 1
/*	$OpenBSD: unifdef.c,v 1.12 2007/04/02 14:12:51 jmc Exp $	*/
a33 11

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1985, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";

#if 0
static char sccsid[] = "@@(#)unifdef.c	8.1 (Berkeley) 6/6/93";
#endif
static const char rcsid[] = "$OpenBSD: unifdef.c,v 1.12 2007/04/02 14:12:51 jmc Exp $";
#endif
@


1.12
log
@tidy up synopsis and usage(); sort options;
from Igor Sobrado, tweaked by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: unifdef.c,v 1.11 2003/06/30 18:37:48 avsm Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: unifdef.c,v 1.11 2003/06/30 18:37:48 avsm Exp $";
d1081 1
a1081 1
 * Look for the symbol in the symbol table. If is is found, we return
@


1.11
log
@sync with freebsd:
- avoid a coredump in 'line mode' and correct a comment
- stub for -I option (our manpage already mentions this)
- add author's copyright (tony finch)
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: unifdef.c,v 1.10 2003/06/03 02:56:21 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: unifdef.c,v 1.10 2003/06/03 02:56:21 millert Exp $";
d296 4
a299 2
	fprintf(stderr, "usage: unifdef [-cdeklst]"
	    " [-Dsym[=val]] [-Usym] [-iDsym[=val]] [-iUsym] ... [file]\n");
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: unifdef.c,v 1.9 2003/01/22 18:26:15 deraadt Exp $	*/
d3 1
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: unifdef.c,v 1.9 2003/01/22 18:26:15 deraadt Exp $";
d220 1
a220 1
	while ((opt = getopt(argc, argv, "i:D:U:cdeklst")) != -1)
d242 3
d988 3
a990 2
 * not whitespace. Between calls we keep the comment state in a global
 * variable, and we also make a note when we get a proper end-of-line.
d997 3
a999 2
		while (isspace((unsigned char)*cp))
			cp += 1;
@


1.9
log
@more sync from freebsd; tedu@@Stanford.EDU
@
text
@d1 1
a1 1
/*	$OpenBSD: unifdef.c,v 1.8 2003/01/18 23:42:51 deraadt Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: unifdef.c,v 1.8 2003/01/18 23:42:51 deraadt Exp $";
@


1.8
log
@merge; by tedu@@Stanford.EDU
@
text
@d1 1
a1 1
/*	$OpenBSD: unifdef.c,v 1.7 2002/12/02 07:16:23 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: unifdef.c,v 1.7 2002/12/02 07:16:23 deraadt Exp $";
d59 3
a74 1
	LT_PLAIN,		/* ordinary line */
d85 3
d93 7
a99 2
	"PLAIN", "TRUEI", "FALSEI", "IF", "TRUE", "FALSE",
	"ELIF", "ELTRUE", "ELFALSE", "ELSE", "ENDIF", "EOF"
d156 6
d167 1
d182 1
a182 3
static char             tline[MAXLINE + 10];	/* input buffer plus space */
static const char      *endtline = &tline[MAXLINE + 9]; /* tline ends here */

d202 3
a210 1
static void             unignore(void);
d223 1
a223 1
	while ((opt = getopt(argc, argv, "i:D:U:I:cdklst")) != -1)
a244 3
		case 'I':
			/* no-op for compatibility with cpp */
			break;
d251 3
d296 2
a297 2
	fprintf(stderr, "usage: unifdef [-cdklst] [[-Dsym[=val]]"
	    " [-Usym] [-iDsym[=val]] [-iUsym]] ... [file]\n");
d305 1
a305 1
 * indicate that processing is complete.
d308 1
a308 1
 * functions increase or decrease the depth. They also maintin the
d314 1
a314 1
 * #elif that we don't understand and therefore must keep, we turn the
d319 1
a319 1
 * #else will be discarded. We change the #elif to #else and the
d321 9
d382 1
a382 1
	unignore();
d390 1
a390 1
	unignore();
d406 1
a406 1
	unignore();
d429 1
a429 1
	unignore();
d437 1
a437 1
	unignore();
d484 29
d518 1
a518 1
	ignore[depth] = true;
d522 2
a523 1
Itrue(void) {
d525 1
a525 1
	ignore[depth] = true;
d532 1
a532 1
	ignore[depth] = true;
d535 1
a535 1
/* modify this line */
d546 1
a546 2
	strlcpy(keyword, "else\n", endtline - keyword);
	print();
d553 1
a553 2
	strlcpy(keyword, "endif\n", endtline - keyword);
	print();
d560 1
a560 2
	strlcpy(keyword, "endif\n", endtline - keyword);
	print();
d566 3
a568 1
{print,Itrue,Ifalse,Fpass,Ftrue,Ffalse,Eelif, Eelif, Eelif, Eelse,Eendif,NULL},
d570 3
a572 1
{drop, Idrop,Idrop, Fdrop,Fdrop,Fdrop, Mpass, Strue, Sfalse,Selse,Dendif,Eeof},
d574 3
a576 1
{print,Itrue,Ifalse,Fpass,Ftrue,Ffalse,Dfalse,Dfalse,Dfalse,Delse,Dendif,Eeof},
d578 3
a580 1
{print,Itrue,Ifalse,Fpass,Ftrue,Ffalse,Pelif, Mtrue, Delif, Pelse,Pendif,Eeof},
d582 3
a584 1
{drop, Idrop,Idrop, Fdrop,Fdrop,Fdrop, Pelif, Mtrue, Delif, Pelse,Pendif,Eeof},
d586 3
a588 1
{print,Itrue,Ifalse,Fpass,Ftrue,Ffalse,Melif, Melif, Melif, Melse,Pendif,Eeof},
d590 3
a592 1
{print,Itrue,Ifalse,Fpass,Ftrue,Ffalse,Eelif, Eelif, Eelif, Eelse,Pendif,Eeof},
d594 3
a596 1
{drop, Idrop,Idrop, Fdrop,Fdrop,Fdrop, Eelif, Eelif, Eelif, Eelse,Dendif,Eeof},
d598 3
a600 1
{print,Itrue,Ifalse,Fpass,Ftrue,Ffalse,Eelif, Eelif, Eelif, Eelse,Dendif,Eeof},
d602 6
a607 2
{drop, Idrop,Idrop, Fdrop,Fdrop,Fdrop, Dfalse,Dfalse,Dfalse,Delse,Dendif,Eeof}
/*PLAIN TRUEI FALSEI IF   TRUE  FALSE  ELIF  ELTRUE ELFALSE ELSE  ENDIF  EOF*/
d614 19
a646 6
static void
unignore(void)
{
	ignore[depth] = ignore[depth-1];
}

d717 1
d757 6
a762 2
		if (retval != LT_PLAIN && (wascomment || incomment))
			Eioccc();
d776 3
a778 1
 * These are the operators that are supported by the expression evaluator.
d1168 1
a1168 1
		errx(2, "%s: %d: %s", filename, linenum, msg);
d1170 1
a1170 1
		errx(2, "%s: %d: %s (#if line %d depth %d)",
d1172 1
@


1.7
log
@freebsd diffs; merged by tedu@@Stanford.EDU
@
text
@d1 1
a1 1
/*	$OpenBSD: unifdef.c,v 1.6 2002/10/04 20:27:16 deraadt Exp $	*/
d46 1
a46 1
static const char rcsid[] = "$OpenBSD: unifdef.c,v 1.6 2002/10/04 20:27:16 deraadt Exp $";
a51 2
 *  Warning: will not work correctly if input contains nul characters.
 *
d73 3
d78 1
a80 2
	LT_IF,			/* an unknown #if */
	LT_ELIF,		/* an unknown #elif */
d83 2
a84 1
	LT_EOF			/* end of file */
d87 4
a90 5
typedef enum {		/* 0 or 1: pass thru; 1 or 2: ignore comments */
	REJ_NO,
	REJ_IGNORE,
	REJ_YES
} Reject_level;
d92 1
d94 27
a120 3
	NO_COMMENT = false,
	C_COMMENT,
	CXX_COMMENT
d123 2
a124 25
typedef enum {
	QUOTE_NONE = false,
	QUOTE_SINGLE,
	QUOTE_DOUBLE
} Quote_state;

const char *const errs[] = {
#define NO_ERR      0
	"",
#define END_ERR     1
	"",
#define ELIF_ERR    2
	"Inappropriate elif",
#define ELSE_ERR    3
	"Inappropriate else",
#define ENDIF_ERR   4
	"Inappropriate endif",
#define IEOF_ERR    5
	"Premature EOF in ifdef",
#define CEOF_ERR    6
	"Premature EOF in comment",
#define Q1EOF_ERR   7
	"Premature EOF in quoted character",
#define Q2EOF_ERR   8
	"Premature EOF in quoted string"
d127 6
a132 11
/*
 * These are the operators that are supported by the expression evaluator.
 */
static int op_lt(int a, int b) { return a < b; }
static int op_gt(int a, int b) { return a > b; }
static int op_le(int a, int b) { return a <= b; }
static int op_ge(int a, int b) { return a >= b; }
static int op_eq(int a, int b) { return a == b; }
static int op_ne(int a, int b) { return a != b; }
static int op_or(int a, int b) { return a || b; }
static int op_and(int a, int b) { return a && b; }
d134 3
a136 1
struct ops;
d139 1
a139 8
 * An evaluation function takes three arguments, as follows: (1) a pointer to
 * an element of the precedence table which lists the operators at the current
 * level of precedence; (2) a pointer to an integer which will receive the
 * value of the expression; and (3) a pointer to a char* that points to the
 * expression to be evaluated and that is updated to the end of the expression
 * when evaluation is complete. The function returns LT_FALSE if the value of
 * the expression is zero, LT_TRUE if it is non-zero, or LT_IF if the
 * expression could not be evaluated.
d141 3
a143 3
typedef Linetype eval_fn(struct ops *, int *, const char **);

eval_fn eval_table, eval_unary;
d146 1
a146 5
 * The precedence table. Expressions involving binary operators are evaluated
 * in a table-driven way by eval_table. When it evaluates a subexpression it
 * calls the inner function with its first argument pointing to the next
 * element of the table. Innermost expressions have special non-table-driven
 * handling.
a147 16
struct ops {
	eval_fn *inner;
	struct op {
		const char *str;
		int (*fn)(int, int);
	} op[5];
} eval_ops[] = {
	{ eval_table, { { "||", op_or } } },
	{ eval_table, { { "&&", op_and } } },
	{ eval_table, { { "==", op_eq },
			{ "!=", op_ne } } },
	{ eval_unary, { { "<=", op_le },
			{ ">=", op_ge },
			{ "<", op_lt },
			{ ">", op_gt } } }
};
d149 46
a194 49
FILE           *input;
const char     *filename;
int             linenum;	/* current line number */
int             stifline;	/* start of current #if */
int             stqcline;	/* start of current coment or quote */
bool            keepthis;	/* ignore this #if's value 'cause it's const */

#define MAXLINE 1024
#define KWSIZE 8
/* tline has extra space so that it isn't overflowed when editing #elifs */
char    tline[MAXLINE+KWSIZE];	/* input buffer */
char   *keyword;		/* used for editing #elif's */

bool            complement;	/* -c option in effect: do the complement */
bool            debugging;	/* -d option in effect: debugging reports */
bool            killconsts;	/* -k option in effect: eval constant #ifs */
bool            lnblank;	/* -l option in effect: blank deleted lines */
bool            symlist;	/* -s option in effect: output symbol list */
bool            text;		/* -t option in effect: this is a text file */

#define MAXSYMS 1000
const char     *symname[MAXSYMS];	/* symbol name */
const char     *value[MAXSYMS];		/* -Dsym=value */
bool            ignore[MAXSYMS];	/* -iDsym or -iUsym */

int             nsyms = 1;	/* symbol 0 is used for tracking #ifs */

Reject_level    reject;		/* what kind of filtering we are doing */
Comment_state   incomment;	/* inside C comment */
Quote_state     inquote;	/* inside single or double quotes */

Linetype        checkline(int *);
void            debug(const char *, ...);
Linetype        process(int);
void            doif(int, Linetype, bool);
void            elif2if(void);
void            elif2endif(void);
void            error(int, int);
void            addsym(bool, bool, char *);
int             findsym(const char *);
void            flushline(bool);
#if 0
int             getline(char *, int, FILE *, bool);
#endif
Linetype        ifeval(const char **);
const char     *skipcomment(const char *);
const char     *skipquote(const char *, Quote_state);
const char     *skipsym(const char *);
void            usage(void);
d198 3
d229 1
a229 1
			/* ignore for compatibility with cpp */
d234 3
a239 3
		case 'd':
			debugging = true;
			break;
d246 1
a246 1
		case 't': /* don't parse C comments or strings */
d254 1
a254 1
	if (nsyms == 1 && !symlist) {
d263 1
a263 1
			(void) process(0);
d270 1
a270 1
		(void) process(0);
d273 1
a273 1
	exit(0);
d276 1
a276 1
void
d279 278
a556 3
	fprintf (stderr, "usage: unifdef [-cdklst] [[-Dsym[=val]]"
	    "[-Usym] [-iDsym[=val]] [-iUsym]] ... [file]\n");
	exit (2);
d560 13
a572 117
 * This function processes #if lines and alters the pass-through
 * state accordingly. All the complicated state transition suff is
 * dealt with in this function, as well as checking that the
 * #if/#elif/#else/#endif lines happen in the correct order. Lines
 * between #if lines are handled by a recursive call to process().
 */
void
doif(int depth, Linetype lineval, bool ignoring)
{
	Reject_level savereject;
	bool active;
	bool donetrue;
	bool inelse;
	int saveline;

	debug("#if line %d code %d depth %d",
	    linenum, lineval, depth);
	saveline = stifline;
	stifline = linenum;
	savereject = reject;
	inelse = false;
	donetrue = false;
	if (lineval == LT_IF || reject != REJ_NO) {
		active = false;
		ignoring = false;
		flushline(true);
	} else if (ignoring) {
		active = false;
		flushline(true);
		if (lineval == LT_FALSE)
			reject = REJ_IGNORE;
		else
			donetrue = true;
	} else {
		active = true;
		flushline(false);
		if (lineval == LT_FALSE)
			reject = REJ_YES;
		else
			donetrue = true;
	}
	debug("active %d ignore %d", active, ignoring);
	for (;;) {
		switch (lineval = process(depth)) {
		case LT_ELIF:
			debug("#elif start %d line %d code %d depth %d",
			    stifline, linenum, lineval, depth);
			if (inelse)
				error(ELIF_ERR, depth);
			donetrue = false;
			reject = savereject;
			if (active) {
				active = false;
				elif2if();
				flushline(true);
			} else {
				ignoring = false;
				flushline(true);
			}
			debug("active %d ignore %d", active, ignoring);
			break;
		case LT_ELTRUE:
		case LT_ELFALSE:
			debug("#elif start %d line %d code %d depth %d",
			    stifline, linenum, lineval, depth);
			if (inelse)
				error(ELIF_ERR, depth);
			if (active)
				flushline(false);
			else {
				ignoring = false;
				active = true;
				elif2endif();
				flushline(true);
			}
			if (lineval == LT_ELFALSE)
				reject = REJ_YES;
			else {
				reject = REJ_NO;
				donetrue = true;
			}
			debug("active %d ignore %d", active, ignoring);
			break;
		case LT_ELSE:
			debug("#else start %d line %d code %d depth %d",
			    stifline, linenum, lineval, depth);
			if (inelse)
				error(ELSE_ERR, depth);
			if (active) {
				flushline(false);
				reject = REJ_YES;
				if (reject == REJ_YES && !donetrue)
					reject = REJ_NO;
			} else {
				flushline(true);
				if (ignoring) {
					if (reject == REJ_IGNORE)
						reject = REJ_NO;
				}
			}
			inelse = true;
			debug("active %d ignore %d", active, ignoring);
			break;
		case LT_ENDIF:
			debug("#endif start %d line %d code %d depth %d",
			    stifline, linenum, lineval, depth);
			if (active)
				flushline(false);
			else
				flushline(true);
			reject = savereject;
			stifline = saveline;
			return;
		default:
			/* bug */
			abort();
		}
d577 1
a577 4
 * The main file processing routine. This function deals with passing
 * through normal non-#if lines, correct nesting of #if sections, and
 * checking that things terminate correctly at the end of file. The
 * complicated stuff is delegated to doif().
d579 2
a580 2
Linetype
process(int depth)
d583 1
a583 1
	int cursym;
d587 8
a594 36
		if (fgets(tline, MAXLINE, input) == NULL) {
			if (incomment)
				error(CEOF_ERR, depth);
			if (inquote == QUOTE_SINGLE)
				error(Q1EOF_ERR, depth);
			if (inquote == QUOTE_DOUBLE)
				error(Q2EOF_ERR, depth);
			if (depth != 0)
				error(IEOF_ERR, depth);
			return (LT_EOF);
		}
		switch (lineval = checkline(&cursym)) {
		case LT_PLAIN:
			flushline(true);
			break;
		case LT_IF:
		case LT_TRUE:
		case LT_FALSE:
			doif(depth + 1, lineval, ignore[cursym]);
			break;
		case LT_ELIF:
		case LT_ELTRUE:
		case LT_ELFALSE:
		case LT_ELSE:
		case LT_ENDIF:
			if (depth != 0)
				return (lineval);
			if (lineval == LT_ENDIF)
				error(ENDIF_ERR, depth);
			if (lineval == LT_ELSE)
				error(ELSE_ERR, depth);
			error(ELIF_ERR, depth);
		default:
			/* bug */
			abort();
		}
d596 2
d601 2
a602 1
 * Parse a line and determine its type.
d604 2
a605 2
Linetype
checkline(int *cursym)
d608 2
a609 1
	char *symp;
d611 1
a611 1
	char kw[KWSIZE];
d613 2
d616 1
d618 39
a656 22
	if (*cp != '#' || incomment || inquote == QUOTE_SINGLE ||
	    inquote == QUOTE_DOUBLE)
		goto eol;

	cp = skipcomment(++cp);
	keyword = (char *)cp;
	symp = kw;
	while (!endsym(*cp)) {
		*symp = *cp++;
		if (++symp >= &kw[KWSIZE])
			goto eol;
	}
	*symp = '\0';

	if (strcmp(kw, "ifdef") == 0) {
		retval = LT_TRUE;
		goto ifdef;
	} else if (strcmp(kw, "ifndef") == 0) {
		retval = LT_FALSE;
ifdef:
		cp = skipcomment(++cp);
		if (incomment) {
a657 1
			goto eol;
a658 13
		if ((*cursym = findsym(cp)) == 0)
			retval = LT_IF;
		else if (value[*cursym] == NULL)
			retval = (retval == LT_TRUE)
			    ? LT_FALSE : LT_TRUE;
	} else if (strcmp(kw, "if") == 0) {
		retval = ifeval(&cp);
		cp = skipcomment(cp);
		if (*cp != '\n' || keepthis)
			retval = LT_IF;
		*cursym = 0;
	} else if (strcmp(kw, "elif") == 0) {
		retval = ifeval(&cp);
d660 7
a666 31
		if (*cp != '\n' || keepthis)
			retval = LT_ELIF;
		if (retval == LT_IF)
			retval = LT_ELIF;
		if (retval == LT_TRUE)
			retval = LT_ELTRUE;
		if (retval == LT_FALSE)
			retval = LT_ELFALSE;
		*cursym = 0;
	} else if (strcmp(kw, "else") == 0)
		retval = LT_ELSE;
	else if (strcmp(kw, "endif") == 0)
		retval = LT_ENDIF;

eol:
	if (!text && reject != REJ_IGNORE) {
		for (; *cp;) {
			if (incomment)
				cp = skipcomment(cp);
			else if (inquote == QUOTE_SINGLE)
				cp = skipquote(cp, QUOTE_SINGLE);
			else if (inquote == QUOTE_DOUBLE)
				cp = skipquote(cp, QUOTE_DOUBLE);
			else if (*cp == '/' && (cp[1] == '*' || cp[1] == '/'))
				cp = skipcomment(cp);
			else if (*cp == '\'')
				cp = skipquote(cp, QUOTE_SINGLE);
			else if (*cp == '"')
				cp = skipquote(cp, QUOTE_DOUBLE);
			else
				cp++;
d668 4
d673 6
d683 1
a683 5
 * Turn a #elif line into a #if. This function is used when we are
 * processing a #if/#elif/#else/#endif sequence that starts off with a
 * #if that we understand (and therefore it has been deleted) which is
 * followed by a #elif that we don't understand and therefore must be
 * kept. We turn it into a #if to keep the nesting correct.
d685 32
a716 2
void
elif2if(void)
d718 13
a730 1
	strncpy(keyword, "if  ", 4);
d734 8
a741 5
 * Turn a #elif line into a #endif. This is used in the opposite
 * situation to elif2if, i.e. a #if that we don't understand is
 * followed by a #elif that we do; rather than deleting the #elif (as
 * we would for a #if) we turn it into a #endif to keep the nesting
 * correct.
d743 29
a771 5
void
elif2endif(void)
{
	strcpy(keyword, "endif\n");
}
d778 2
a779 2
Linetype
eval_unary(struct ops *ops, int *valp, const char **cpp)
d786 1
a786 1
	if(*cp == '!') {
d811 1
a811 1
		if (sym == 0 && !symlist)
d822 1
a822 1
		if (sym == 0 && !symlist)
d844 2
a845 2
Linetype
eval_table(struct ops *ops, int *valp, const char **cpp)
d847 1
a848 1
	struct op *op;
d865 1
a865 1
			return LT_IF;
d877 1
a877 2
 * return just a generic LT_IF. If the expression is constant and
 * we are not processing constant #ifs then the keepthis flag is true.
d879 1
a879 1
Linetype
d882 1
d887 2
a888 1
	return (eval_table(eval_ops, &val, cpp));
d893 3
a895 1
 * not whitespace.
d897 1
a897 1
const char *
d900 14
a913 12
	if (incomment)
		goto inside;
	for (;; cp++) {
		while (*cp == ' ' || *cp == '\t')
			cp++;
		if (text)
			return (cp);
		if (cp[0] != '/')
			return (cp);

		if (cp[1] == '*') {
			if (!incomment) {
d915 16
a930 1
				stqcline = linenum;
d932 17
a948 2
		} else if (cp[1] == '/') {
			if (!incomment) {
d950 4
a953 1
				stqcline = linenum;
d955 11
a965 20
		} else
			return (cp);

		cp += 2;
inside:
		if (incomment == C_COMMENT) {
			for (;;) {
				for (; *cp != '*'; cp++)
					if (*cp == '\0')
						return (cp);
				if (*++cp == '/') {
					incomment = NO_COMMENT;
					break;
				}
			}
		} else if (incomment == CXX_COMMENT) {
			for (; *cp != '\n'; cp++)
				if (*cp == '\0')
					return (cp);
			incomment = NO_COMMENT;
d967 1
a967 31
	}
}

/*
 * Skip over a quoted string or character and stop at the next charaacter
 * position that is not whitespace.
 */
const char *
skipquote(const char *cp, Quote_state type)
{
	char qchar;

	qchar = type == QUOTE_SINGLE ? '\'' : '"';

	if (inquote == type)
		goto inside;
	for (;; cp++) {
		if (*cp != qchar)
			return (cp);
		cp++;
		inquote = type;
		stqcline = linenum;
inside:
		for (;; cp++) {
			if (*cp == qchar)
				break;
			if (*cp == '\0' || (*cp == '\\' && *++cp == '\0'))
				return (cp);
		}
		inquote = QUOTE_NONE;
	}
d973 1
a973 1
const char *
d983 1
a983 1
 * the symbol table index, else we return 0.
d985 1
a985 1
int
a988 1
	const char *symp;
d991 4
a994 3
	if (symlist) {
		for (cp = str; !endsym(*cp); cp++)
			continue;
d996 2
a997 6
	}
	for (symind = 1; symind < nsyms; ++symind) {
		for (cp = str, symp = symname[symind];
		    *cp && *symp && *cp == *symp; cp++, symp++)
			continue;
		if (*symp == '\0' && endsym(*cp)) {
d1003 1
a1003 1
	return (0);
d1009 1
a1009 1
void
d1016 1
a1016 1
	if (symind == 0) {
d1023 1
a1023 1
	val = (char *)skipsym(sym);
a1038 1
#if 0
d1040 2
a1041 2
 * Read a line from the input and expand tabs if requested and (if
 * compiled in) treats form-feed as an end-of-line.
d1043 2
a1044 2
int
getline(char *line, int maxline, FILE *inp, bool expandtabs)
d1046 6
a1051 65
	int tmp;
	int num;
	int chr;
#ifdef  FFSPECIAL
	static bool havechar = false;	/* have leftover char from last time */
	static char svchar;
#endif	/* FFSPECIAL */

	num = 0;
#ifdef  FFSPECIAL
	if (havechar) {
		havechar = false;
		chr = svchar;
		goto ent;
	}
#endif	/* FFSPECIAL */
	while (num + 8 < maxline) {	/* leave room for tab */
		chr = getc(inp);
		if (chr == EOF)
			return (EOF);
		if (0 && isprint(chr)) {
#ifdef  FFSPECIAL
ent:
#endif	/* FFSPECIAL */
			*line++ = chr;
			num++;
		} else
			switch (chr) {
			case EOF:
				return (EOF);

			case '\t':
				if (expandtabs) {
					num += tmp = 8 - (num & 7);
					do
						*line++ = ' ';
					while (--tmp);
					break;
				}

			case '\n':
				*line = '\n';
				num++;
				goto end;

#ifdef  FFSPECIAL
			case '\f':
				if (++num == 1)
					*line = '\f';
				else {
					*line = '\n';
					havechar = true;
					svchar = chr;
				}
				goto end;
#endif	/* FFSPECIAL */
			default:
				*line++ = chr;
				num++;
				break;
			}
	}
end:
	*++line = '\0';
	return (num);
a1052 1
#endif
d1055 1
a1055 2
 * Write a line to the output or not, according to the current
 * filtering state.
d1057 1
a1057 12
void
flushline(bool keep)
{
	if (symlist)
		return;
	if ((keep && reject != REJ_YES) ^ complement)
		fputs(tline, stdout);
	else if (lnblank)
		putc('\n', stdout);
}

void
d1069 2
a1070 2
void
error(int code, int depth)
d1072 2
a1073 3
	if (incomment || inquote)
		errx(2, "error in %s line %d: %s (#if depth %d)",
		    filename, stqcline, errs[code], depth);
d1075 2
a1076 3
		errx(2, "error in %s line %d: %s"
		    " (#if depth %d start line %d)",
		    filename, linenum, errs[code], depth, stifline);
@


1.6
log
@remove the BSS crud
@
text
@d1 1
a1 3
/*	$OpenBSD: unifdef.c,v 1.5 2002/05/10 19:13:07 jason Exp $	*/
/*	$NetBSD: unifdef.c,v 1.6 1998/10/08 01:31:59 wsanchez Exp $	*/

d7 1
a7 1
 * Dave Yost.
d39 1
a39 1
static char copyright[] =
a41 1
#endif				/* not lint */
a42 1
#ifndef lint
d46 2
a47 2
static char rcsid[] = "$OpenBSD: unifdef.c,v 1.5 2002/05/10 19:13:07 jason Exp $";
#endif				/* not lint */
d52 1
a52 1
 *  Warning: will not work correctly if input contains null characters.
d60 1
d63 4
d68 3
a70 1
#include <ctype.h>
d72 31
a102 127
FILE   *input;
#ifndef YES
#define YES 1
#define NO  0
#endif				/* YES */
#define C_COMMENT   1
#define CXX_COMMENT 2
typedef int Bool;

char   *progname;
char   *filename;
char text;			/* -t option in effect: this is a text file */
char lnblank;			/* -l option in effect: blank deleted lines */
char complement;		/* -c option in effect: complement the
				 * operation */

#define MAXSYMS 100
char   *symname[MAXSYMS];	/* symbol name */
char    true[MAXSYMS];		/* -Dsym */
char    ignore[MAXSYMS];	/* -iDsym or -iUsym */
char    insym[MAXSYMS];		/* state: false, inactive, true */
#define SYM_INACTIVE 0		/* symbol is currently inactive */
#define SYM_FALSE    1		/* symbol is currently false */
#define SYM_TRUE     2		/* symbol is currently true  */

char nsyms;
char incomment;			/* inside C comment */

#define QUOTE_NONE   0
#define QUOTE_SINGLE 1
#define QUOTE_DOUBLE 2
char inquote;			/* inside single or double quotes */
int exitstat;

int error(int, int, int);
int findsym(char *);
void flushline(Bool);
int getlin(char *, int, FILE *, int);
void pfile(void);
void prname(void);
char   *skipcomment(char *);
char   *skipquote(char *, int);

int
main(argc, argv)
	int     argc;
	char  **argv;
{
	char  **curarg;
	char *cp;
	char *cp1;
	char    ignorethis;

	progname = argv[0][0] ? argv[0] : "unifdef";

	for (curarg = &argv[1]; --argc > 0; curarg++) {
		if (*(cp1 = cp = *curarg) != '-')
			break;
		if (*++cp1 == 'i') {
			ignorethis = YES;
			cp1++;
		} else
			ignorethis = NO;
		if ((*cp1 == 'D'
			|| *cp1 == 'U'
		    )
		    && cp1[1] != '\0'
		    ) {
			int symind;

			if ((symind = findsym(&cp1[1])) < 0) {
				if (nsyms >= MAXSYMS) {
					prname();
					fprintf(stderr, "too many symbols.\n");
					exit(2);
				}
				symind = nsyms++;
				symname[symind] = &cp1[1];
				insym[symind] = SYM_INACTIVE;
			}
			ignore[symind] = ignorethis;
			true[symind] = *cp1 == 'D' ? YES : NO;
		} else
			if (ignorethis)
				goto unrec;
			else
				if (strcmp(&cp[1], "t") == 0)
					text = YES;
				else
					if (strcmp(&cp[1], "l") == 0)
						lnblank = YES;
					else
						if (strcmp(&cp[1], "c") == 0)
							complement = YES;
						else {
					unrec:
							prname();
							fprintf(stderr, "unrecognized option: %s\n", cp);
							goto usage;
						}
	}
	if (nsyms == 0) {
usage:
		fprintf(stderr, "\
Usage: %s [-l] [-t] [-c] [[-Dsym] [-Usym] [-iDsym] [-iUsym]]... [file]\n\
    At least one arg from [-D -U -iD -iU] is required\n", progname);
		exit(2);
	}
	if (argc > 1) {
		prname();
		fprintf(stderr, "can only do one file.\n");
	} else
		if (argc == 1) {
			filename = *curarg;
			if ((input = fopen(filename, "r")) != NULL) {
				pfile();
				(void) fclose(input);
			} else {
				prname();
				fprintf(stderr, "can't open ");
				perror(*curarg);
			}
		} else {
			filename = "[stdin]";
			input = stdin;
			pfile();
		}
d104 1
a104 25
	(void) fflush(stdout);
	exit(exitstat);
}
/* types of input lines: */
typedef int Linetype;
#define LT_PLAIN       0	/* ordinary line */
#define LT_TRUE        1	/* a true  #ifdef of a symbol known to us */
#define LT_FALSE       2	/* a false #ifdef of a symbol known to us */
#define LT_OTHER       3	/* an #ifdef of a symbol not known to us */
#define LT_IF          4	/* an #ifdef of a symbol not known to us */
#define LT_ELSE        5	/* #else */
#define LT_ENDIF       6	/* #endif */
#define LT_LEOF        7	/* end of file */
Linetype checkline(int *);

typedef int Reject_level;
Reject_level reject;		/* 0 or 1: pass thru; 1 or 2: ignore comments */
#define REJ_NO          0
#define REJ_IGNORE      1
#define REJ_YES         2
int doif(int, int, Reject_level, int);

int linenum;			/* current line number */
int stqcline;			/* start of current coment or quote */
char   *errs[] = {
d109 3
a111 1
#define ELSE_ERR    2
d113 1
a113 1
#define ENDIF_ERR   3
d115 1
a115 1
#define IEOF_ERR    4
d117 1
a117 1
#define CEOF_ERR    5
d119 1
a119 1
#define Q1EOF_ERR   6
d121 1
a121 1
#define Q2EOF_ERR   7
d124 179
a302 4
/* States for inif arg to doif */
#define IN_NONE 0
#define IN_IF   1
#define IN_ELSE 2
d305 1
a305 1
pfile()
d307 3
a309 3
	reject = REJ_NO;
	(void) doif(-1, IN_NONE, reject, 0);
	return;
d312 9
a320 6
int
doif(thissym, inif, prevreject, depth)
	int thissym;	/* index of the symbol who was last ifdef'ed */
	int     inif;		/* YES or NO we are inside an ifdef */
	Reject_level prevreject;/* previous value of reject */
	int     depth;		/* depth of ifdef's */
d322 33
a354 7
	Linetype lineval;
	Reject_level thisreject;
	int     doret;		/* tmp return value of doif */
	int     cursym;		/* index of the symbol returned by checkline */
	int     stline;		/* line number when called this time */

	stline = linenum;
d356 17
a372 3
		switch (lineval = checkline(&cursym)) {
		case LT_PLAIN:
			flushline(YES);
d374 8
a381 6

		case LT_TRUE:
		case LT_FALSE:
			thisreject = reject;
			if (lineval == LT_TRUE)
				insym[cursym] = SYM_TRUE;
d383 4
a386 3
				if (reject != REJ_YES)
					reject = ignore[cursym] ? REJ_IGNORE : REJ_YES;
				insym[cursym] = SYM_FALSE;
d388 2
a389 2
			if (ignore[cursym])
				flushline(YES);
d391 2
a392 2
				exitstat = 1;
				flushline(NO);
d394 1
a394 9
			if ((doret = doif(cursym, IN_IF, thisreject, depth + 1)) != NO_ERR)
				return error(doret, stline, depth);
			break;

		case LT_IF:
		case LT_OTHER:
			flushline(YES);
			if ((doret = doif(-1, IN_IF, reject, depth + 1)) != NO_ERR)
				return error(doret, stline, depth);
a395 1

d397 14
a410 15
			if (inif != IN_IF)
				return error(ELSE_ERR, linenum, depth);
			inif = IN_ELSE;
			if (thissym >= 0) {
				if (insym[thissym] == SYM_TRUE) {
					reject = ignore[thissym] ? REJ_IGNORE : REJ_YES;
					insym[thissym] = SYM_FALSE;
				} else {	/* (insym[thissym] ==
						 * SYM_FALSE) */
					reject = prevreject;
					insym[thissym] = SYM_TRUE;
				}
				if (!ignore[thissym]) {
					flushline(NO);
					break;
d413 2
a414 1
			flushline(YES);
d416 16
d433 38
d472 10
a481 32
			if (inif == IN_NONE)
				return error(ENDIF_ERR, linenum, depth);
			if (thissym >= 0) {
				insym[thissym] = SYM_INACTIVE;
				reject = prevreject;
				if (!ignore[thissym]) {
					flushline(NO);
					return NO_ERR;
				}
			}
			flushline(YES);
			return NO_ERR;

		case LT_LEOF:{
				int     err;
				err = incomment
				    ? CEOF_ERR
				    : inquote == QUOTE_SINGLE
				    ? Q1EOF_ERR
				    : inquote == QUOTE_DOUBLE
				    ? Q2EOF_ERR
				    : NO_ERR;
				if (inif != IN_NONE) {
					if (err != NO_ERR)
						(void) error(err, stqcline, depth);
					return error(IEOF_ERR, stline, depth);
				} else
					if (err != NO_ERR)
						return error(err, stqcline, depth);
					else
						return NO_ERR;
			}
a484 4
#define endsym(c) (!isalpha (c) && !isdigit (c) && c != '_')

#define MAXLINE 256
char    tline[MAXLINE];
d486 3
d490 1
a490 3
checkline(cursym)
	int    *cursym;		/* if LT_TRUE or LT_FALSE returned, set this
				 * to sym index */
d492 1
a492 1
	char *cp;
a493 1
	char   *scp;
d495 1
a495 6
#define KWSIZE 8
	char    keyword[KWSIZE];

	linenum++;
	if (getlin(tline, sizeof tline, input, NO) == EOF)
		return LT_LEOF;
d498 3
a500 5
	if (*(cp = tline) != '#'
	    || incomment
	    || inquote == QUOTE_SINGLE
	    || inquote == QUOTE_DOUBLE
	    )
d504 2
a505 1
	symp = keyword;
d508 1
a508 1
		if (++symp >= &keyword[KWSIZE])
d513 2
a514 2
	if (strcmp(keyword, "ifdef") == 0) {
		retval = YES;
d516 35
a550 26
	} else
		if (strcmp(keyword, "ifndef") == 0) {
			retval = NO;
	ifdef:
			scp = cp = skipcomment(++cp);
			if (incomment) {
				retval = LT_PLAIN;
				goto eol;
			} {
				int     symind;

				if ((symind = findsym(scp)) >= 0)
					retval = (retval ^ true[*cursym = symind])
					    ? LT_FALSE : LT_TRUE;
				else
					retval = LT_OTHER;
			}
		} else
			if (strcmp(keyword, "if") == 0)
				retval = LT_IF;
			else
				if (strcmp(keyword, "else") == 0)
					retval = LT_ELSE;
				else
					if (strcmp(keyword, "endif") == 0)
						retval = LT_ENDIF;
d553 1
a553 1
	if (!text && reject != REJ_IGNORE)
d557 10
d568 1
a568 16
				if (inquote == QUOTE_SINGLE)
					cp = skipquote(cp, QUOTE_SINGLE);
				else
					if (inquote == QUOTE_DOUBLE)
						cp = skipquote(cp, QUOTE_DOUBLE);
					else
						if (*cp == '/' && (cp[1] == '*' || cp[1] == '/'))
							cp = skipcomment(cp);
						else
							if (*cp == '\'')
								cp = skipquote(cp, QUOTE_SINGLE);
							else
								if (*cp == '"')
									cp = skipquote(cp, QUOTE_DOUBLE);
								else
									cp++;
d570 129
a698 1
	return retval;
d700 1
d702 4
a705 2
 *  Skip over comments and stop at the next charaacter
 *  position that is not whitespace.
d707 16
a722 3
char   *
skipcomment(cp)
	char *cp;
d730 1
a730 1
			return cp;
d732 1
a732 1
			return cp;
d745 1
a745 1
			return cp;
d753 1
a753 1
						return cp;
d755 1
a755 1
					incomment = NO;
d759 1
a759 2
		}
		else if (incomment == CXX_COMMENT) {
d762 2
a763 2
					return cp;
			incomment = NO;
d767 1
d769 2
a770 2
 *  Skip over a quoted string or character and stop at the next charaacter
 *  position that is not whitespace.
d772 2
a773 4
char   *
skipquote(cp, type)
	char *cp;
	int type;
d783 1
a783 1
			return cp;
d792 1
a792 1
				return cp;
d797 12
d810 2
a811 3
 *  findsym - look for the symbol in the symbol table.
 *            if found, return symbol table index,
 *            else return -1.
d814 1
a814 2
findsym(str)
	char   *str;
d816 2
a817 2
	char *cp;
	char *symp;
a818 1
	char chr;
d820 13
a832 10
	for (symind = 0; symind < nsyms; ++symind) {
		if (insym[symind] == SYM_INACTIVE) {
			for (symp = symname[symind], cp = str
			    ; *symp && *cp == *symp
			    ; cp++, symp++
			    )
				continue;
			chr = *cp;
			if (*symp == '\0' && endsym(chr))
				return symind;
d835 1
a835 1
	return -1;
d837 1
d839 36
a874 2
 *   getlin - expands tabs if asked for
 *            and (if compiled in) treats form-feed as an end-of-line
d877 1
a877 5
getlin(line, maxline, inp, expandtabs)
	char *line;
	int     maxline;
	FILE   *inp;
	int     expandtabs;
d879 1
a879 1
	int     tmp;
d883 1
a883 1
	static char havechar = NO;	/* have leftover char from last time */
d885 1
a885 1
#endif				/* FFSPECIAL */
d890 1
a890 1
		havechar = NO;
d894 1
a894 1
#endif				/* FFSPECIAL */
d898 2
a899 2
			return EOF;
		if (isprint(chr)) {
d901 2
a902 2
	ent:
#endif				/* FFSPECIAL */
d907 3
a917 4
			default:
				*line++ = chr;
				num++;
				break;
d930 1
a930 1
					havechar = YES;
d934 5
a938 1
#endif				/* FFSPECIAL */
d943 1
a943 1
	return num;
d945 1
d947 4
d952 1
a952 2
flushline(keep)
	Bool    keep;
d954 6
a959 11
	if ((keep && reject != REJ_YES) ^ complement) {
		char *line = tline;
		FILE *out = stdout;
		char chr;

		while ((chr = *line++))
			putc(chr, out);
	} else
		if (lnblank)
			putc('\n', stdout);
	return;
d963 1
a963 1
prname()
d965 7
a971 2
	fprintf(stderr, "%s: ", progname);
	return;
d974 10
a983 21
int
error(err, line, depth)
	int     err;		/* type of error & index into error string
				 * array */
	int     line;		/* line number */
	int     depth;		/* how many ifdefs we are inside */
{
	if (err == END_ERR)
		return err;

	prname();

#ifndef TESTING
	fprintf(stderr, "Error in %s line %d: %s.\n", filename, line, errs[err]);
#else				/* TESTING */
	fprintf(stderr, "Error in %s line %d: %s. ", filename, line, errs[err]);
	fprintf(stderr, "ifdef depth: %d\n", depth);
#endif				/* TESTING */

	exitstat = 2;
	return depth > 1 ? IEOF_ERR : END_ERR;
@


1.5
log
@In getlin(): match and handle EOF before checking isprint()
millert ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: unifdef.c,v 1.4 2002/02/16 21:27:56 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: unifdef.c,v 1.4 2002/02/16 21:27:56 millert Exp $";
a68 1
#define BSS
d78 5
a82 5
char   *progname BSS;
char   *filename BSS;
char text BSS;			/* -t option in effect: this is a text file */
char lnblank BSS;		/* -l option in effect: blank deleted lines */
char complement BSS;		/* -c option in effect: complement the
d86 4
a89 4
char   *symname[MAXSYMS] BSS;	/* symbol name */
char    true[MAXSYMS] BSS;	/* -Dsym */
char    ignore[MAXSYMS] BSS;	/* -iDsym or -iUsym */
char    insym[MAXSYMS] BSS;	/* state: false, inactive, true */
d94 2
a95 2
char nsyms BSS;
char incomment BSS;		/* inside C comment */
d100 2
a101 2
char inquote BSS;		/* inside single or double quotes */
int exitstat BSS;
d213 1
a213 1
Reject_level reject BSS;	/* 0 or 1: pass thru; 1 or 2: ignore comments */
d219 2
a220 2
int linenum BSS;		/* current line number */
int stqcline BSS;		/* start of current coment or quote */
d359 1
a359 1
char    tline[MAXLINE] BSS;
d576 1
a576 1
	static char svchar BSS;
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: unifdef.c,v 1.3 1998/11/16 21:58:29 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: unifdef.c,v 1.3 1998/11/16 21:58:29 deraadt Exp $";
d590 2
a599 3
			case EOF:
				return EOF;

@


1.3
log
@clean; adding // comment support
@
text
@d1 1
a1 1
/*	$OpenBSD: unifdef.c,v 1.2 1996/06/26 05:42:10 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: unifdef.c,v 1.2 1996/06/26 05:42:10 deraadt Exp $";
d104 8
a111 8
int error __P((int, int, int));
int findsym __P((char *));
void flushline __P((Bool));
int getlin __P((char *, int, FILE *, int));
void pfile __P((void));
void prname __P((void));
char   *skipcomment __P((char *));
char   *skipquote __P((char *, int));
d211 1
a211 1
Linetype checkline __P((int *));
d218 1
a218 1
int doif __P((int, int, Reject_level, int));
@


1.2
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: unifdef.c,v 1.4 1994/12/20 01:44:07 jtc Exp $	*/
/*	$NetBSD: unifdef.c,v 1.4 1994/12/20 01:44:07 jtc Exp $	*/
d44 1
a44 1
#endif /* not lint */
d50 2
a51 2
static char rcsid[] = "$OpenBSD: unifdef.c,v 1.4 1994/12/20 01:44:07 jtc Exp $";
#endif /* not lint */
d70 1
a70 1
FILE *input;
d74 3
a76 1
#endif/*YES */
d79 6
a84 5
char *progname BSS;
char *filename BSS;
char text BSS;          /* -t option in effect: this is a text file */
char lnblank BSS;       /* -l option in effect: blank deleted lines */
char complement BSS;    /* -c option in effect: complement the operation */
d87 7
a93 7
char *symname[MAXSYMS] BSS; /* symbol name */
char true[MAXSYMS] BSS;     /* -Dsym */
char ignore[MAXSYMS] BSS;   /* -iDsym or -iUsym */
char insym[MAXSYMS] BSS;    /* state: false, inactive, true */
#define SYM_INACTIVE 0      /* symbol is currently inactive */
#define SYM_FALSE    1      /* symbol is currently false */
#define SYM_TRUE     2      /* symbol is currently true  */
d96 1
a96 1
char incomment BSS;         /* inside C comment */
d101 1
a101 1
char inquote BSS;           /* inside single or double quotes */
d104 6
a109 6
int 	error __P((int, int, int));
int 	findsym __P((char *));
void 	flushline __P((Bool));
int 	getlin __P((char *, int, FILE *, int));
void	pfile __P((void));
void	prname __P((void));
d114 56
a169 51
main (argc, argv)
int argc;
char **argv;
{
    char **curarg;
    register char *cp;
    register char *cp1;
    char ignorethis;

    progname = argv[0][0] ? argv[0] : "unifdef";

    for (curarg = &argv[1]; --argc > 0; curarg++) {
	if (*(cp1 = cp = *curarg) != '-')
	    break;
	if (*++cp1 == 'i') {
	    ignorethis = YES;
	    cp1++;
	} else
	    ignorethis = NO;
	if (   (   *cp1 == 'D'
		|| *cp1 == 'U'
	       )
	    && cp1[1] != '\0'
	   ) {
	    register int symind;

	    if ((symind = findsym (&cp1[1])) < 0) {
		if (nsyms >= MAXSYMS) {
		    prname ();
		    fprintf (stderr, "too many symbols.\n");
		    exit (2);
		}
		symind = nsyms++;
		symname[symind] = &cp1[1];
		insym[symind] = SYM_INACTIVE;
	    }
	    ignore[symind] = ignorethis;
	    true[symind] = *cp1 == 'D' ? YES : NO;
	} else if (ignorethis)
	    goto unrec;
	else if (strcmp (&cp[1], "t") == 0)
	    text = YES;
	else if (strcmp (&cp[1], "l") == 0)
	    lnblank = YES;
	else if (strcmp (&cp[1], "c") == 0)
	    complement = YES;
	else {
 unrec:
	    prname ();
	    fprintf (stderr, "unrecognized option: %s\n", cp);
	    goto usage;
d171 3
a173 4
    }
    if (nsyms == 0) {
 usage:
	fprintf (stderr, "\
d176 1
a176 15
	exit (2);
    }

    if (argc > 1) {
	prname ();
	fprintf (stderr, "can only do one file.\n");
    } else if (argc == 1) {
	filename = *curarg;
	if ((input = fopen (filename, "r")) != NULL) {
	    pfile();
	    (void) fclose (input);
	} else {
	    prname ();
	    fprintf (stderr, "can't open ");
	    perror(*curarg);
d178 19
a196 5
    } else {
	filename = "[stdin]";
	input = stdin;
	pfile();
    }
d198 2
a199 2
    (void) fflush (stdout);
    exit (exitstat);
a200 1

d203 8
a210 8
#define LT_PLAIN       0   /* ordinary line */
#define LT_TRUE        1   /* a true  #ifdef of a symbol known to us */
#define LT_FALSE       2   /* a false #ifdef of a symbol known to us */
#define LT_OTHER       3   /* an #ifdef of a symbol not known to us */
#define LT_IF          4   /* an #ifdef of a symbol not known to us */
#define LT_ELSE        5   /* #else */
#define LT_ENDIF       6   /* #endif */
#define LT_LEOF        7   /* end of file */
d214 1
a214 1
Reject_level reject BSS;    /* 0 or 1: pass thru; 1 or 2: ignore comments */
d220 3
a222 3
int linenum BSS;    /* current line number */
int stqcline BSS;   /* start of current coment or quote */
char *errs[] = {
d224 1
a224 1
			"",
d226 1
a226 1
			"",
d228 1
a228 1
			"Inappropriate else",
d230 1
a230 1
			"Inappropriate endif",
d232 1
a232 1
			"Premature EOF in ifdef",
d234 1
a234 1
			"Premature EOF in comment",
d236 1
a236 1
			"Premature EOF in quoted character",
d238 1
a238 1
			"Premature EOF in quoted string"
a239 1

d246 1
a246 1
pfile ()
d248 3
a250 3
    reject = REJ_NO;
    (void) doif (-1, IN_NONE, reject, 0);
    return;
d254 100
a353 57
doif (thissym, inif, prevreject, depth)
register int thissym;   /* index of the symbol who was last ifdef'ed */
int inif;               /* YES or NO we are inside an ifdef */
Reject_level prevreject;/* previous value of reject */
int depth;              /* depth of ifdef's */
{
    register Linetype lineval;
    register Reject_level thisreject;
    int doret;          /* tmp return value of doif */
    int cursym;         /* index of the symbol returned by checkline */
    int stline;         /* line number when called this time */

    stline = linenum;
    for (;;) {
	switch (lineval = checkline (&cursym)) {
	case LT_PLAIN:
	    flushline (YES);
	    break;

	case LT_TRUE:
	case LT_FALSE:
	    thisreject = reject;
	    if (lineval == LT_TRUE)
		insym[cursym] = SYM_TRUE;
	    else {
		if (reject != REJ_YES)
		    reject = ignore[cursym] ? REJ_IGNORE : REJ_YES;
		insym[cursym] = SYM_FALSE;
	    }
	    if (ignore[cursym])
		flushline (YES);
	    else {
		exitstat = 1;
		flushline (NO);
	    }
	    if ((doret = doif (cursym, IN_IF, thisreject, depth + 1)) != NO_ERR)
		return error (doret, stline, depth);
	    break;

	case LT_IF:
	case LT_OTHER:
	    flushline (YES);
	    if ((doret = doif (-1, IN_IF, reject, depth + 1)) != NO_ERR)
		return error (doret, stline, depth);
	    break;

	case LT_ELSE:
	    if (inif != IN_IF)
		return error (ELSE_ERR, linenum, depth);
	    inif = IN_ELSE;
	    if (thissym >= 0) {
		if (insym[thissym] == SYM_TRUE) {
		    reject = ignore[thissym] ? REJ_IGNORE : REJ_YES;
		    insym[thissym] = SYM_FALSE;
		} else { /* (insym[thissym] == SYM_FALSE) */
		    reject = prevreject;
		    insym[thissym] = SYM_TRUE;
a354 40
		if (!ignore[thissym]) {
		    flushline (NO);
		    break;
		}
	    }
	    flushline (YES);
	    break;

	case LT_ENDIF:
	    if (inif == IN_NONE)
		return error (ENDIF_ERR, linenum, depth);
	    if (thissym >= 0) {
		insym[thissym] = SYM_INACTIVE;
		reject = prevreject;
		if (!ignore[thissym]) {
		    flushline (NO);
		    return NO_ERR;
		}
	    }
	    flushline (YES);
	    return NO_ERR;

	case LT_LEOF: {
	    int err;
	    err =   incomment
		  ? CEOF_ERR
		  : inquote == QUOTE_SINGLE
		  ? Q1EOF_ERR
		  : inquote == QUOTE_DOUBLE
		  ? Q2EOF_ERR
		  : NO_ERR;
	    if (inif != IN_NONE) {
		if (err != NO_ERR)
		    (void) error (err, stqcline, depth);
		return error (IEOF_ERR, stline, depth);
	    } else if (err != NO_ERR)
		return error (err, stqcline, depth);
	    else
		return NO_ERR;
	    }
a355 1
    }
a356 1

d360 1
a360 1
char tline[MAXLINE] BSS;
d363 29
a391 41
checkline (cursym)
int *cursym;    /* if LT_TRUE or LT_FALSE returned, set this to sym index */
{
    register char *cp;
    register char *symp;
    char *scp;
    Linetype retval;
#   define KWSIZE 8
    char keyword[KWSIZE];

    linenum++;
    if (getlin (tline, sizeof tline, input, NO) == EOF)
	return LT_LEOF;

    retval = LT_PLAIN;
    if (   *(cp = tline) != '#'
	|| incomment
	|| inquote == QUOTE_SINGLE
	|| inquote == QUOTE_DOUBLE
       )
	goto eol;

    cp = skipcomment (++cp);
    symp = keyword;
    while (!endsym (*cp)) {
	*symp = *cp++;
	if (++symp >= &keyword[KWSIZE])
	    goto eol;
    }
    *symp = '\0';

    if (strcmp (keyword, "ifdef") == 0) {
	retval = YES;
	goto ifdef;
    } else if (strcmp (keyword, "ifndef") == 0) {
	retval = NO;
 ifdef:
	scp = cp = skipcomment (++cp);
	if (incomment) {
	    retval = LT_PLAIN;
	    goto eol;
d393 1
a393 2
	{
	    int symind;
d395 54
a448 32
	    if ((symind = findsym (scp)) >= 0)
		retval = (retval ^ true[*cursym = symind])
			 ? LT_FALSE : LT_TRUE;
	    else
		retval = LT_OTHER;
	}
    } else if (strcmp (keyword, "if") == 0)
	retval = LT_IF;
    else if (strcmp (keyword, "else") == 0)
	retval = LT_ELSE;
    else if (strcmp (keyword, "endif") == 0)
	retval = LT_ENDIF;

 eol:
    if (!text && reject != REJ_IGNORE)
	for (; *cp; ) {
	    if (incomment)
		cp = skipcomment (cp);
	    else if (inquote == QUOTE_SINGLE)
		cp = skipquote (cp, QUOTE_SINGLE);
	    else if (inquote == QUOTE_DOUBLE)
		cp = skipquote (cp, QUOTE_DOUBLE);
	    else if (*cp == '/' && cp[1] == '*')
		cp = skipcomment (cp);
	    else if (*cp == '\'')
		cp = skipquote (cp, QUOTE_SINGLE);
	    else if (*cp == '"')
		cp = skipquote (cp, QUOTE_DOUBLE);
	    else
		cp++;
	}
    return retval;
a449 1

d454 46
a499 29
char *
skipcomment (cp)
register char *cp;
{
    if (incomment)
	goto inside;
    for (;; cp++) {
	while (*cp == ' ' || *cp == '\t')
	    cp++;
	if (text)
	    return cp;
	if (   cp[0] != '/'
	    || cp[1] != '*'
	   )
	    return cp;
	cp += 2;
	if (!incomment) {
	    incomment = YES;
	    stqcline = linenum;
	}
 inside:
	for (;;) {
	    for (; *cp != '*'; cp++)
		if (*cp == '\0')
		    return cp;
	    if (*++cp == '/') {
		incomment = NO;
		break;
	    }
a500 1
    }
a501 1

d506 25
a530 25
char *
skipquote (cp, type)
register char *cp;
register int type;
{
    register char qchar;

    qchar = type == QUOTE_SINGLE ? '\'' : '"';

    if (inquote == type)
	goto inside;
    for (;; cp++) {
	if (*cp != qchar)
	    return cp;
	cp++;
	inquote = type;
	stqcline = linenum;
 inside:
	for (; ; cp++) {
	    if (*cp == qchar)
		break;
	    if (   *cp == '\0'
		|| *cp == '\\' && *++cp == '\0'
	       )
		return cp;
a531 2
	inquote = QUOTE_NONE;
    }
a532 1

d539 2
a540 2
findsym (str)
char *str;
d542 16
a557 15
    register char *cp;
    register char *symp;
    register int symind;
    register char chr;

    for (symind = 0; symind < nsyms; ++symind) {
	if (insym[symind] == SYM_INACTIVE) {
	    for ( symp = symname[symind], cp = str
		; *symp && *cp == *symp
		; cp++, symp++
		)
		continue;
	    chr = *cp;
	    if (*symp == '\0' && endsym (chr))
		return symind;
d559 1
a559 2
    }
    return -1;
a560 1

d566 9
a574 9
getlin (line, maxline, inp, expandtabs)
register char *line;
int maxline;
FILE *inp;
int expandtabs;
{
    int tmp;
    register int num;
    register int chr;
d576 3
a578 3
    static char havechar = NO;  /* have leftover char from last time */
    static char svchar BSS;
#endif/*FFSPECIAL */
d580 1
a580 1
    num = 0;
d582 9
a590 9
    if (havechar) {
	havechar = NO;
	chr = svchar;
	goto ent;
    }
#endif/*FFSPECIAL */
    while (num + 8 < maxline) {   /* leave room for tab */
	chr = getc (inp);
	if (isprint (chr)) {
d592 26
a617 26
 ent:
#endif/*FFSPECIAL */
	    *line++ = chr;
	    num++;
	} else
	    switch (chr) {
	    case EOF:
		return EOF;

	    case '\t':
		if (expandtabs) {
		    num += tmp = 8 - (num & 7);
		    do
			*line++ = ' ';
		    while (--tmp);
		    break;
		}
	    default:
		*line++ = chr;
		num++;
		break;

	    case '\n':
		*line = '\n';
		num++;
		goto end;
d620 15
a634 15
	    case '\f':
		if (++num == 1)
		    *line = '\f';
		else {
		    *line = '\n';
		    havechar = YES;
		    svchar = chr;
		}
		goto end;
#endif/*FFSPECIAL */
	    }
    }
 end:
    *++line = '\0';
    return num;
d638 2
a639 2
flushline (keep)
Bool keep;
d641 11
a651 10
    if ((keep && reject != REJ_YES) ^ complement) {
	register char *line = tline;
	register FILE *out = stdout;
	register char chr;

	while (chr = *line++)
	    putc (chr, out);
    } else if (lnblank)
	putc ('\n', stdout);
    return;
d655 1
a655 1
prname ()
d657 2
a658 2
    fprintf (stderr, "%s: ", progname);
    return;
d662 5
a666 4
error (err, line, depth)
int err;        /* type of error & index into error string array */
int line;       /* line number */
int depth;      /* how many ifdefs we are inside */
d668 2
a669 2
    if (err == END_ERR)
	return err;
d671 1
a671 1
    prname ();
d674 5
a678 5
    fprintf (stderr, "Error in %s line %d: %s.\n", filename, line, errs[err]);
#else/* TESTING */
    fprintf (stderr, "Error in %s line %d: %s. ", filename, line, errs[err]);
    fprintf (stderr, "ifdef depth: %d\n", depth);
#endif/*TESTING */
d680 2
a681 2
    exitstat = 2;
    return depth > 1 ? IEOF_ERR : END_ERR;
@


1.1
log
@Initial revision
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: unifdef.c,v 1.4 1994/12/20 01:44:07 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
