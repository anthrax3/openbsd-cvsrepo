head	1.36;
access;
symbols
	OPENBSD_6_1:1.36.0.4
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.21.0.8
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.6
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.4
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.2
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.12
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.8
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.8
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.6
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2016.09.02.14.23.09;	author tb;	state Exp;
branches;
next	1.35;
commitid	SPbr7FcdSlYLXrQv;

1.35
date	2016.08.16.16.49.24;	author tb;	state Exp;
branches;
next	1.34;
commitid	56TX8jzzwmJRPHwu;

1.34
date	2016.08.12.23.29.59;	author tb;	state Exp;
branches;
next	1.33;
commitid	Pc34bVyikhx5v7K5;

1.33
date	2016.08.12.21.31.11;	author tb;	state Exp;
branches;
next	1.32;
commitid	GmnUpkUx5hrQAXmI;

1.32
date	2016.08.12.21.17.41;	author tb;	state Exp;
branches;
next	1.31;
commitid	QszkYu3Kzskb1nEC;

1.31
date	2016.08.05.13.43.38;	author tb;	state Exp;
branches;
next	1.30;
commitid	aSSjO72hrt8fPTSM;

1.30
date	2016.08.05.13.33.21;	author tb;	state Exp;
branches;
next	1.29;
commitid	P2LbLrAM8YDIHsn7;

1.29
date	2016.08.05.13.21.31;	author tb;	state Exp;
branches;
next	1.28;
commitid	g19yDpMskXsj4YQ6;

1.28
date	2016.07.17.04.04.46;	author tb;	state Exp;
branches;
next	1.27;
commitid	4exU6Lm7QF6Yw3zY;

1.27
date	2016.01.10.01.15.52;	author tb;	state Exp;
branches;
next	1.26;
commitid	2mhFPxGPQukwzhDG;

1.26
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	sbrB3Q5CNxcwZpfU;

1.25
date	2015.10.06.22.55.51;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	gidveJuEJavVAsJJ;

1.24
date	2015.07.21.04.04.06;	author jasper;	state Exp;
branches;
next	1.23;
commitid	euTTbFaxmF4ik45B;

1.23
date	2013.11.26.13.21.18;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.11.15.15.47.53;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2012.01.30.14.08.18;	author okan;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.27.23.59.39;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.01.01.26.30;	author jdixon;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.11.16.31.20;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.08.18.50.02;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.30.19.41.48;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.29.08.51.19;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.15.23.24.20;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.10.22.20.47;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.02.56.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.12.02.45.28;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.29.18.33.38;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.47;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.08.01.39.17;	author pjanzen;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.21.15.34.51;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.21.15.11.29;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.14.07.16.12;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.12.04.21.28.34;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.12.04.21.27.02;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.34.41;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.27;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.36
log
@style cleanup: sort headers; group and sort variables; no parens for
return; sort getopt string and corresponding switch; and some more
tedious stuff

ok martijn
@
text
@/*	$OpenBSD: jot.c,v 1.35 2016/08/16 16:49:24 tb Exp $	*/
/*	$NetBSD: jot.c,v 1.3 1994/12/02 20:29:43 pk Exp $	*/

/*-
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * jot - print sequential or random data
 *
 * Author:  John Kunze, Office of Comp. Affairs, UCB
 */

#include <ctype.h>
#include <err.h>
#include <limits.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define	REPS	1
#define	BEGIN	2
#define	ENDER	4
#define	STEP	8

#define	is_default(s)	(strcmp((s), "-") == 0)

static long	reps	= 100;
static double	begin	= 1;
static double	ender	= 100;
static double	step	= 1;

static char	format[BUFSIZ];
static char	sepstring[BUFSIZ] = "\n";
static int	prec = -1;
static bool	boring;
static bool	chardata;
static bool	finalnl = true;
static bool	infinity;
static bool	intdata;
static bool	longdata;
static bool	nosign;
static bool	randomize;

static void	getformat(void);
static int	getprec(char *);
static int	putdata(double, bool);
static void __dead	usage(void);

int
main(int argc, char *argv[])
{
	double		x;
	double		y;
	long		i;
	unsigned int	mask = 0;
	int		n = 0;
	int		ch;
	const	char	*errstr;

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "b:cnp:rs:w:")) != -1) {
		switch (ch) {
		case 'b':
			boring = true;
			if (strlcpy(format, optarg, sizeof(format)) >=
			    sizeof(format))
				errx(1, "-b word too long");
			break;
		case 'c':
			chardata = true;
			break;
		case 'n':
			finalnl = false;
			break;
		case 'p':
			prec = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr != NULL)
				errx(1, "bad precision value, %s: %s", errstr,
					optarg);
			break;
		case 'r':
			randomize = true;
			break;
		case 's':
			if (strlcpy(sepstring, optarg, sizeof(sepstring)) >=
			    sizeof(sepstring))
				errx(1, "-s string too long");
			break;
		case 'w':
			if (strlcpy(format, optarg, sizeof(format)) >=
			    sizeof(format))
				errx(1, "-w word too long");
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	switch (argc) {	/* examine args right to left, falling thru cases */
	case 4:
		if (!is_default(argv[3])) {
			if (!sscanf(argv[3], "%lf", &step))
				errx(1, "Bad s value:  %s", argv[3]);
			mask |= STEP;
			if (randomize)
				warnx("random seeding not supported");
		}
	case 3:
		if (!is_default(argv[2])) {
			if (!sscanf(argv[2], "%lf", &ender))
				ender = argv[2][strlen(argv[2])-1];
			mask |= ENDER;
			if (prec == -1)
				n = getprec(argv[2]);
		}
	case 2:
		if (!is_default(argv[1])) {
			if (!sscanf(argv[1], "%lf", &begin))
				begin = argv[1][strlen(argv[1])-1];
			mask |= BEGIN;
			if (prec == -1)
				prec = getprec(argv[1]);
			if (n > prec)		/* maximum precision */
				prec = n;
		}
	case 1:
		if (!is_default(argv[0])) {
			if (!sscanf(argv[0], "%ld", &reps))
				errx(1, "Bad reps value:  %s", argv[0]);
			mask |= REPS;
			if (reps == 0)
				infinity = true;
			if (prec == -1)
				prec = 0;
		}
		break;
	case 0:
		usage();
		break;
	default:
		errx(1, "Too many arguments.  What do you mean by %s?",
		    argv[4]);
	}

	getformat();

	if (!randomize) {
		/*
		 * Consolidate the values of reps, begin, ender, step:
		 * The formula ender - begin == (reps - 1) * step shows that any
		 * three determine the fourth (unless reps == 1 or step == 0).
		 * The manual states the following rules:
		 * 1. If four are specified, compare the given and the computed
		 *    value of reps and take the smaller of the two.
		 * 2. If steps was omitted, it takes the default, unless both
		 *    begin and ender were specified.
		 * 3. Assign defaults to omitted values for reps, begin, ender,
		 *    from left to right.
		 */
		switch (mask) { /* Four cases involve both begin and ender. */
		case REPS | BEGIN | ENDER | STEP:
			if (infinity)
				errx(1,
				    "Can't specify end of infinite sequence");
			if (step != 0.0) {
				long t = (ender - begin + step) / step;
				if (t <= 0)
					errx(1, "Impossible stepsize");
				if (t < reps)
					reps = t;
			}
			break;
		case REPS | BEGIN | ENDER:
			if (infinity)
				errx(1,
				    "Can't specify end of infinite sequence");
			if (reps == 1)
				step = 0.0;
			else
				step = (ender - begin) / (reps - 1);
			break;
		case BEGIN | ENDER:
			step = ender > begin ? 1 : -1; /* FreeBSD's behavior. */
			/* FALLTHROUGH */
		case BEGIN | ENDER | STEP:
			if (step == 0.0) {
				reps = 0;
				infinity = true;
				break;
			}
			reps = (ender - begin + step) / step;
			if (reps <= 0)
				errx(1, "Impossible stepsize");
			break;
		case ENDER:		/* Four cases involve only ender. */
		case ENDER | STEP:
		case REPS | ENDER:
		case REPS | ENDER | STEP:
			if (infinity)
				errx(1,
				    "Must specify start of infinite sequence");
			begin = ender - reps * step + step;
			break;
		default:
			/*
			 * The remaining eight cases omit ender.  We don't need
			 * to compute anything because only reps, begin, step
			 * are used for producing output below.  Rules 2. and 3.
			 * together imply that ender will be set last.
			 */
			break;
		}

		for (i = 1, x = begin; i <= reps || infinity; i++, x += step)
			if (putdata(x, reps == i && !infinity))
				errx(1, "range error in conversion: %f", x);
	} else { /* Random output: use defaults for omitted values. */
		bool		use_unif;
		uint32_t	pow10 = 1;
		uint32_t	uintx = 0; /* Initialized to make gcc happy. */

		if (prec > 9)	/* pow(10, prec) > UINT32_MAX */
			errx(1, "requested precision too large");

		if (ender < begin) {
			x = begin;
			begin = ender;
			ender = x;
		}
		x = ender - begin;

		if (prec == 0 && (fmod(ender, 1) != 0 || fmod(begin, 1) != 0))
			use_unif = 0;
		else {
			while (prec-- > 0)
				pow10 *= 10;
			/*
			 * If pow10 * (ender - begin) is an integer, use
			 * arc4random_uniform().
			 */
			use_unif = fmod(pow10 * (ender - begin), 1) == 0;
			if (use_unif) {
				uintx = pow10 * (ender - begin);
				if (uintx >= UINT32_MAX)
					errx(1, "requested range too large");
				uintx++;
			}
		}

		for (i = 1; i <= reps || infinity; i++) {
			double v;

			if (use_unif) {
				y = arc4random_uniform(uintx) / (double)pow10;
				v = y + begin;
			} else {
				y = arc4random() / ((double)0xffffffff + 1);
				v = y * x + begin;
			}
			if (putdata(v, reps == i && !infinity))
				errx(1, "range error in conversion: %f", v);
		}
	}

	if (finalnl)
		putchar('\n');

	return 0;
}

static int
putdata(double x, bool last)
{
	if (boring)
		printf("%s", format);
	else if (longdata && nosign) {
		if (x <= (double)ULONG_MAX && x >= 0.0)
			printf(format, (unsigned long)x);
		else
			return 1;
	} else if (longdata) {
		if (x <= (double)LONG_MAX && x >= (double)LONG_MIN)
			printf(format, (long)x);
		else
			return 1;
	} else if (chardata || (intdata && !nosign)) {
		if (x <= (double)INT_MAX && x >= (double)INT_MIN)
			printf(format, (int)x);
		else
			return 1;
	} else if (intdata) {
		if (x <= (double)UINT_MAX && x >= 0.0)
			printf(format, (unsigned int)x);
		else
			return 1;
	} else
		printf(format, x);
	if (!last)
		fputs(sepstring, stdout);

	return 0;
}

static void __dead
usage(void)
{
	(void)fprintf(stderr, "usage: jot [-cnr] [-b word] [-p precision] "
	    "[-s string] [-w word]\n"
	    "	   [reps [begin [end [s]]]]\n");
	exit(1);
}

static int
getprec(char *s)
{
	if ((s = strchr(s, '.')) == NULL)
		return 0;
	return strspn(s + 1, "0123456789");
}

static void
getformat(void)
{
	char	*p, *p2;
	int dot, hash, space, sign, numbers = 0;
	size_t sz;

	if (boring)				/* no need to bother */
		return;
	for (p = format; *p != '\0'; p++)	/* look for '%' */
		if (*p == '%') {
			if (*(p+1) != '%')
				break;
			p++;			/* leave %% alone */
		}
	sz = sizeof(format) - strlen(format) - 1;
	if (*p == '\0' && !chardata) {
		int n;

		n = snprintf(p, sz, "%%.%df", prec);
		if (n == -1 || n >= (int)sz)
			errx(1, "-w word too long");
	} else if (*p == '\0' && chardata) {
		if (strlcpy(p, "%c", sz) >= sz)
			errx(1, "-w word too long");
		intdata = true;
	} else if (*(p+1) == '\0') {
		if (sz <= 0)
			errx(1, "-w word too long");
		/* cannot end in single '%' */
		strlcat(format, "%", sizeof format);
	} else {
		/*
		 * Allow conversion format specifiers of the form
		 * %[#][ ][{+,-}][0-9]*[.[0-9]*]? where ? must be one of
		 * [l]{d,i,o,u,x} or {f,e,g,E,G,d,o,x,D,O,U,X,c,u}
		 */
		p2 = p++;
		dot = hash = space = sign = numbers = 0;
		while (!isalpha((unsigned char)*p)) {
			if (isdigit((unsigned char)*p)) {
				numbers++;
				p++;
			} else if ((*p == '#' && !(numbers|dot|sign|space|
			    hash++)) ||
			    (*p == ' ' && !(numbers|dot|space++)) ||
			    ((*p == '+' || *p == '-') && !(numbers|dot|sign++))
			    || (*p == '.' && !(dot++)))
				p++;
			else
				goto fmt_broken;
		}
		if (*p == 'l') {
			longdata = true;
			if (*++p == 'l') {
				if (p[1] != '\0')
					p++;
				goto fmt_broken;
			}
		}
		switch (*p) {
		case 'o': case 'u': case 'x': case 'X':
			intdata = nosign = true;
			break;
		case 'd': case 'i':
			intdata = true;
			break;
		case 'D':
			if (!longdata) {
				intdata = true;
				break;
			}
		case 'O': case 'U':
			if (!longdata) {
				intdata = nosign = true;
				break;
			}
		case 'c':
			if (!(intdata | longdata)) {
				chardata = true;
				break;
			}
		case 'h': case 'n': case 'p': case 'q': case 's': case 'L':
		case '$': case '*':
			goto fmt_broken;
		case 'f': case 'e': case 'g': case 'E': case 'G':
			if (!longdata)
				break;
			/* FALLTHROUGH */
		default:
fmt_broken:
			*++p = '\0';
			errx(1, "illegal or unsupported format '%s'", p2);
		}
		while (*++p != '\0')
			if (*p == '%' && *(p+1) != '\0' && *(p+1) != '%')
				errx(1, "too many conversions");
			else if (*p == '%' && *(p+1) == '%')
				p++;
			else if (*p == '%' && *(p+1) == '\0') {
				strlcat(format, "%", sizeof format);
				break;
			}
	}
}
@


1.35
log
@Streamline and refactor the code a bit more:

There are two sentinels for infinite output: infinity == true and reps == 0.
Ensure that infinity is set to true whenever reps is set to zero, then we
can always use 'if (infinity)'.

This allows us to merge the loop for deterministic output into the first
if (!randomize) statement, which is a lot tidier.

Insert an occasional empty line.

"move fast and break stuff" tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.34 2016/08/12 23:29:59 tb Exp $	*/
d39 1
a40 2
#include <stdbool.h>
#include <ctype.h>
d43 1
d50 4
a53 9
#define	REPS_DEF	100
#define	BEGIN_DEF	1
#define	ENDER_DEF	100
#define	STEP_DEF	1

#define	STEP		1
#define	ENDER		2
#define	BEGIN		4
#define	REPS		8
d57 11
a67 5
static double	begin = BEGIN_DEF;
static double	ender = ENDER_DEF;
static double	step = STEP_DEF;
static long	reps = REPS_DEF;
static bool	randomize;
a68 2
static bool	boring;
static int	prec = -1;
a70 1
static bool	chardata;
d72 1
a72 3
static bool	finalnl = true;
static char	sepstring[BUFSIZ] = "\n";
static char	format[BUFSIZ];
d93 1
a93 1
	while ((ch = getopt(argc, argv, "rb:w:cs:np:")) != -1)
d95 5
a99 2
		case 'r':
			randomize = true;
d107 5
a111 5
		case 'b':
			boring = true;
			if (strlcpy(format, optarg, sizeof(format)) >=
			    sizeof(format))
				errx(1, "-b word too long");
d113 2
a114 4
		case 'w':
			if (strlcpy(format, optarg, sizeof(format)) >=
			    sizeof(format))
				errx(1, "-w word too long");
d121 4
a124 5
		case 'p':
			prec = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr != NULL)
				errx(1, "bad precision value, %s: %s", errstr,
					optarg);
d129 1
d302 1
a302 1
	return (0);
d314 1
a314 1
			return (1);
d319 1
a319 1
			return (1);
d324 1
a324 1
			return (1);
d329 1
a329 1
			return (1);
d335 1
a335 1
	return (0);
d351 2
a352 2
		return (0);
	return (strspn(s + 1, "0123456789"));
a447 1
			/* NOTREACHED */
@


1.34
log
@Simplify getprec() by using strchr(3) and strspn(3).
Part of NetBSD's jot r1.20 by dsl.

ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.31 2016/08/05 13:43:38 tb Exp $	*/
d168 2
d181 1
d183 1
a183 1
	/* If random output is requested, use defaults for omitted values. */
a195 1
		 * 4. reps == 0 means infinite output
d199 1
a199 1
			if (reps == 0)
d211 1
a211 1
			if (reps == 0)
d225 1
d236 1
a236 1
			if (reps == 0)
d250 5
a254 4
	}
	if (reps == 0)
		infinity = true;
	if (randomize) {
a299 4
	} else {
		for (i = 1, x = begin; i <= reps || infinity; i++, x += step)
			if (putdata(x, reps == i && !infinity))
				errx(1, "range error in conversion: %f", x);
d301 1
d304 1
@


1.33
log
@usage() is __dead
@
text
@d351 1
a351 7
	char	*p;
	char	*q;

	for (p = s; *p != '\0'; p++)
		if (*p == '.')
			break;
	if (*p == '\0')
d353 1
a353 4
	for (q = ++p; *p != '\0'; p++)
		if (!isdigit((unsigned char)*p))
			break;
	return (p - q);
@


1.32
log
@The last four argumens of jot (reps, begin, end, step) can all be
specified or omitted, yielding 16 possible combinations, plus
a few special cases.

Instead of hardcoded values, use names to make the bit patterns
that indicate which values were specified human readable. Decide
once and for all what to do in a single switch statement. Don't
enter said switch when random output is requested since that
simply makes no sense at all.

While there, make the error messages a bit more meaningful and
fix a bogus value assigned to begin for jot -r x - y z that has
been there since -r1.1. All regression tests now pass.

Inspired by David Laight (dsl)'s r1.21 of NetBSD's jot.

"move fast and break stuff" tedu
agreement from deraadt
@
text
@d81 1
a81 1
static void	usage(void);
d339 1
a339 1
static void
@


1.31
log
@If reps and steps were omitted, while begin and end were specified,
use a default step size of +1 or -1.  Fixes the last two failing
regression tests dhhd and dhhd2.  Adapted from FreeBSD.

'good direction' deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.28 2016/07/17 04:04:46 tb Exp $	*/
d55 5
d64 1
a64 1
static double	s = STEP_DEF;
d139 1
a139 1
			if (!sscanf(argv[3], "%lf", &s))
d141 1
a141 1
			mask |= 01;
d149 1
a149 1
			mask |= 02;
d157 1
a157 1
			mask |= 04;
d167 1
a167 1
			mask |= 010;
d180 39
a218 25
	while (mask)	/* 4 bit mask has 1's where last 4 args were given */
		switch (mask) {	/* fill in the 0's by default or computation */
		case 001:
			reps = REPS_DEF;
			mask = 011;
			break;
		case 002:
			reps = REPS_DEF;
			mask = 012;
			break;
		case 003:
			reps = REPS_DEF;
			mask = 013;
			break;
		case 004:
			reps = REPS_DEF;
			mask = 014;
			break;
		case 005:
			reps = REPS_DEF;
			mask = 015;
			break;
		case 006:
			s = ender > begin ? 1 : -1;
			mask = 007;
d220 2
a221 7
		case 007:
			if (randomize) {
				reps = REPS_DEF;
				mask = 0;
				break;
			}
			if (s == 0.0) {
a222 1
				mask = 0;
d225 1
a225 1
			reps = (ender - begin + s) / s;
a227 32
			mask = 0;
			break;
		case 010:
			begin = BEGIN_DEF;
			mask = 014;
			break;
		case 011:
			begin = BEGIN_DEF;
			mask = 015;
			break;
		case 012:
			s = STEP_DEF;
			mask = 013;
			break;
		case 013:
			if (randomize)
				begin = BEGIN_DEF;
			else if (reps == 0)
				errx(1, "Must specify begin if reps == 0");
			begin = ender - reps * s + s;
			mask = 0;
			break;
		case 014:
			s = STEP_DEF;
			mask = 015;
			break;
		case 015:
			if (randomize)
				ender = ENDER_DEF;
			else
				ender = begin + reps * s - s;
			mask = 0;
d229 4
a232 1
		case 016:
d234 3
a236 6
				errx(1, "Infinite sequences cannot be bounded");
			else if (reps == 1)
				s = 0.0;
			else
				s = (ender - begin) / (reps - 1);
			mask = 0;
d238 7
a244 9
		case 017:		/* if reps given and implied, */
			if (!randomize && s != 0.0) {
				long t = (ender - begin + s) / s;
				if (t <= 0)
					errx(1, "Impossible stepsize");
				if (t < reps)		/* take lesser */
					reps = t;
			}
			mask = 0;
a245 2
		default:
			errx(1, "bad mask");
d247 1
d296 2
a297 3
	}
	else
		for (i = 1, x = begin; i <= reps || infinity; i++, x += s)
d300 1
d303 1
a303 1
	exit(0);
@


1.30
log
@If "%%" appears in the format string, skip it properly.

Part of pjanzen's fixes in r1.8, but was lost in r1.17.
Fixes regression tests wp3, wp4, wp5.

'good direction' deraadt
@
text
@d198 3
a200 3
			reps = REPS_DEF;
			mask = 016;
			break;
@


1.29
log
@Initialize reps, begin, end, steps to their defaults.

Makes jot - - - - behave the same way as jot -, jot - - and jot - - -
instead of spurting out zeroes indefinitely.
Fixes the dddd regression test and matches FreeBSD and NetBSD.

From attila () stalphonsos ! com, thanks!
'good direction' deraadt
@
text
@d397 5
a401 2
		if (*p == '%' && *(p+1) != '%')	/* leave %% alone */
			break;
@


1.28
log
@1. Update manpage in view of the change of behavior I introduced in -r1.27.

The bounds are taken inclusive and -w %d doesn't change the output of
integer random sequences anymore.  This is the same behavior as that
of Linux and NetBSD, but differs from FreeBSD and OS X.

Issue reported by Philippe Meunier on misc@@.

2 Fix a bug from the same commit observed by Otto: if the precision is 0,
values may be printed out of bounds.  Fall back to the old behavior if at
least one bound isn't an integer.

General agreement expressed by otto@@, tedu@@, jmc@@, sobrado@@
Help with checking other operating systems by sobrado@@.

Manpage ok jmc@@.
Bugfix discussed with otto@@ on icb
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.27 2016/01/10 01:15:52 tb Exp $	*/
d57 4
a60 4
static double	begin;
static double	ender;
static double	s;
static long	reps;
@


1.27
log
@Random sequences generated by jot -r have been suffering from a dramatic
bias at both ends of the given interval.  Various clever workarounds are
documented in the manual.

This fixes the bias in some of the most common use cases, namely random
sequences of integers or real numbers rounded to a fixed number of
decimals.  So, `jot -p 3 -r 10000 0 1' produces a uniformly distributed
sequence of 10,000 decimal numbers of the form 0.abc (or 1).

Internally, jot -r now uses arc4random_uniform() whenever this is
clearly possible.  In particular `jot -r 1 10 20' yields an unbiased
random number between 10 and 20 (both ends inclusive) from the shell.

guidance and ok deraadt@@, "i like it" benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.26 2015/10/09 01:37:07 deraadt Exp $	*/
a279 3
		while (prec-- > 0)
			pow10 *= 10;

d287 16
a302 10
		/*
		 * If pow10 * (ender - begin) is an integer, use
		 * arc4random_uniform().
		 */
		use_unif = fmod(pow10 * (ender - begin), 1) == 0;
		if (use_unif) {
			uintx = pow10 * (ender - begin);
			if (uintx >= UINT32_MAX)
				errx(1, "requested range too large");
			uintx++;
@


1.26
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.25 2015/10/06 22:55:51 deraadt Exp $	*/
d43 2
d273 29
a301 1
		x = (ender - begin) * (ender > begin ? 1 : -1);
d304 8
a311 2
			y = arc4random() / ((double)0xffffffff + 1);
			v = y * x + begin;
@


1.25
log
@obvious tame "stdio"
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.24 2015/07/21 04:04:06 jasper Exp $	*/
d87 2
a88 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.24
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.23 2013/11/26 13:21:18 deraadt Exp $	*/
d86 3
@


1.23
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.22 2013/11/15 15:47:53 millert Exp $	*/
d117 1
a117 1
				errx(1, "bad precision value, %s: %s", errstr, 
@


1.22
log
@Include unistd.h as it is the standard location for getopt().
From Eitan Adler
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.21 2012/01/30 14:08:18 okan Exp $	*/
d340 1
a340 1
		if (!isdigit(*p))
d381 2
a382 2
		while (!isalpha(*p)) {
			if (isdigit(*p)) {
@


1.21
log
@typo in error message; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.20 2009/10/27 23:59:39 deraadt Exp $	*/
d46 1
@


1.20
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.19 2007/05/01 01:26:30 jdixon Exp $	*/
d111 1
a111 1
				errx(1, "-s word too long");
@


1.19
log
@use strtonum; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.18 2005/04/11 16:31:20 deraadt Exp $	*/
a31 13

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)jot.c	8.1 (Berkeley) 6/6/93";
#endif
static const char rcsid[] = "$OpenBSD: jot.c,v 1.18 2005/04/11 16:31:20 deraadt Exp $";
#endif /* not lint */
@


1.18
log
@handle -1 potential case from snprintf too
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.17 2004/01/08 18:50:02 otto Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: jot.c,v 1.17 2004/01/08 18:50:02 otto Exp $";
d97 1
d127 4
a130 3
			prec = atoi(optarg);
			if (prec < 0)
				errx(1, "bad precision value");
@


1.17
log
@Pass the right type based on the conversion specified; warn on conversion
errors. Mostly from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.16 2003/12/30 19:41:48 otto Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: jot.c,v 1.16 2003/12/30 19:41:48 otto Exp $";
d369 4
a372 1
		if (snprintf(p, sz, "%%.%df", prec) >= (int)sz)
@


1.16
log
@o From FreeBSD: use the max_value(u_int32_t) + 1 to divide the random number.
o Document and warn that seeding the random generator is no longer supported
  since arc4random is used as the RG.

ok jose@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.15 2003/12/29 08:51:19 otto Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: jot.c,v 1.15 2003/12/29 08:51:19 otto Exp $";
d75 2
a76 1
static bool	dox;
d78 1
d85 1
a85 1
static void	putdata(double, bool);
d280 1
d282 3
a284 1
			putdata(y * x + begin, reps - i == 0 && !infinity);
d289 2
a290 1
			putdata(x, reps - i == 0 && !infinity);
d296 1
a296 1
static void
d299 1
a299 1
	if (boring)				/* repeated word */
d301 21
a321 3
	else if (dox)				/* scalar */
		printf(format, (long)x);
	else					/* real */
d325 2
d358 2
a359 1
	char	*p;
d365 2
a366 5
		if (*p == '%') {
			if (*(p+1) != '%')
				break;
			p++;		/* leave %% alone */
		}
d374 1
a374 1
		dox = true;
d381 28
a408 7
		for (; *p != '\0' && !isalpha(*p); p++)
			/* Certain nonalphanumerics we can't allow */
			if (*p == '$' || *p == '*')
				break;
		/* Allow 'l' prefix, but no other. */
		if (*p == 'l')
			p++;
d410 2
a411 2
		case 'f': case 'e': case 'g': case '%':
		case 'E': case 'G':
d413 2
a414 7
		case 's':
			errx(1, "cannot convert numeric data to strings");
			break;
		case 'd': case 'o': case 'x': case 'u':
		case 'D': case 'O': case 'X': case 'U':
		case 'c': case 'i':
			dox = true;
d416 22
d439 4
a442 1
			errx(1, "unknown or invalid format `%s'", format);
d444 8
a451 6
		/* Need to check for trailing stuff to print */
		for (; *p != '\0'; p++)		/* look for '%' */
			if (*p == '%') {
				if (*(p+1) != '%')
					break;
				p++;		/* leave %% alone */
a452 2
		if (*p != '\0')
			errx(1, "unknown or invalid format `%s'", format);
@


1.15
log
@Cleanup: KNF, -Wall, do not use pointers if the actual var is
available, plus some other minor cleanup.
New features: Allow explicit precision 0. For infinite sequences,
do not print trailing newline if the counter wraps.

Testing by henning@@ and jmc@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.14 2003/12/15 23:24:20 jmc Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: jot.c,v 1.14 2003/12/15 23:24:20 jmc Exp $";
a58 1
#include <time.h>
d140 2
d229 1
a229 1
			s = (randomize ? time(NULL) : STEP_DEF);
d241 1
a241 1
			s = (randomize ? time(NULL) : STEP_DEF);
d252 1
a252 3
			if (randomize)
				s = time(NULL);
			else if (reps == 0)
d278 1
a278 1
			y = (double) arc4random() / UINT_MAX;
@


1.14
log
@jot.1:
- use .Bk/.Ek for SYNOPSIS
- sort options
- better -width for options list
- reword examples to make them clearer
- fix broken example, as reported by Takanori Isihara

jot.c:
- sync usage() with SYNOPSIS
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.13 2003/06/10 22:20:47 deraadt Exp $	*/
d34 1
a34 1
static char copyright[] =
d43 1
a43 1
static char rcsid[] = "$OpenBSD: jot.c,v 1.13 2003/06/10 22:20:47 deraadt Exp $";
d53 1
d68 17
a84 18
double	begin;
double	ender;
double	s;
long	reps;
int	randomize;
int	infinity;
int	boring;
int	prec;
int	dox;
int	chardata;
int	nofinalnl;
char	sepstring[BUFSIZ] = "\n";
char	format[BUFSIZ];

void		getargs(int, char *[]);
void		getformat(void);
int		getprec(char *);
void		putdata(double, long);
d90 3
a92 5
	double	xd, yd;
	long	id;
	double	*x = &xd;
	double	*y = &yd;
	long	*i = &id;
d94 2
a95 2
	int	n = 0;
	int	ch;
d98 1
a98 1
		switch((char)ch) {
d100 1
a100 1
			randomize = 1;
d103 1
a103 1
			chardata = 1;
d106 1
a106 1
			nofinalnl = 1;
d109 1
a109 1
			boring = 1;
d126 1
a126 1
			if (prec <= 0)
d147 1
a147 1
			if (!prec)
d155 1
a155 1
			if (!prec)
d165 2
d173 2
a174 1
		errx(1, "Too many arguments.  What do you mean by %s?", argv[4]);
d275 1
a275 1
		infinity = 1;
d277 4
a280 4
		*x = (ender - begin) * (ender > begin ? 1 : -1);
		for (*i = 1; *i <= reps || infinity; (*i)++) {
			*y = (double) arc4random() / UINT_MAX;
			putdata(*y * *x + begin, reps - *i);
d284 3
a286 3
		for (*i = 1, *x = begin; *i <= reps || infinity; (*i)++, *x += s)
			putdata(*x, reps - *i);
	if (!nofinalnl)
d291 2
a292 2
void
putdata(double x, long notlast)
a293 3
	long		d = x;
	long	*dp = &d;

d297 1
a297 1
		printf(format, *dp);
d300 1
a300 1
	if (notlast != 0)
d313 1
a313 1
int
d319 1
a319 1
	for (p = s; *p; p++)
d322 1
a322 1
	if (!*p)
d324 1
a324 1
	for (q = ++p; *p; p++)
d330 1
a330 1
void
d338 1
a338 1
	for (p = format; *p; p++)		/* look for '%' */
d345 1
a345 1
	if (!*p && !chardata) {
d348 1
a348 1
	} else if (!*p && chardata) {
d351 2
a352 2
		dox = 1;
	} else if (!*(p+1)) {
d355 2
a356 1
		strlcat(format, "%", sizeof format);	/* cannot end in single '%' */
d358 1
a358 1
		for (; *p && !isalpha(*p); p++)
d375 1
a375 1
			dox = 1;
d381 1
a381 1
		for (; *p; p++)		/* look for '%' */
d387 1
a387 1
		if (*p)
@


1.13
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.12 2003/06/03 02:56:09 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: jot.c,v 1.12 2003/06/03 02:56:09 millert Exp $";
d309 3
a311 2
	(void)fprintf(stderr, "usage: jot [-cnr] [-b word] [-w word] "
	    "[-s string] [-p precision] [reps [begin [end [s]]]]\n");
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.11 2003/01/12 02:45:28 beck Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: jot.c,v 1.11 2003/01/12 02:45:28 beck Exp $";
d88 1
a88 3
main(argc, argv)
	int argc;
	char *argv[];
d291 1
a291 3
putdata(x, notlast)
	double x;
	long notlast;
d315 1
a315 2
getprec(s)
	char *s;
d332 1
a332 1
getformat()
@


1.11
log
@Make this work on 64 bit arch's
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.10 2002/05/29 18:33:38 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: jot.c,v 1.10 2002/05/29 18:33:38 deraadt Exp $";
@


1.10
log
@strlcat
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.9 2002/02/16 21:27:47 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: jot.c,v 1.9 2002/02/16 21:27:47 millert Exp $";
d284 1
a284 1
			*y = (double) arc4random() / ULONG_MAX;
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.8 2001/03/08 01:39:17 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: jot.c,v 1.8 2001/03/08 01:39:17 pjanzen Exp $";
d365 1
a365 1
		strcat(format, "%");		/* cannot end in single '%' */
@


1.8
log
@de-register, use getopt(), prevent a few terribly unlikely buffer
overflows, improve a few error messages, and avoid a bundle of faults
involving the -w option.
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.7 2000/12/21 15:34:51 aaron Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: jot.c,v 1.7 2000/12/21 15:34:51 aaron Exp $";
d85 5
a89 5
void		getargs __P((int, char *[]));
void		getformat __P((void));
int		getprec __P((char *));
void		putdata __P((double, long));
static void	usage __P((void));
@


1.7
log
@- Get rid of local error() function and instead use err(3).
- Add a standard usage() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.6 2000/12/21 15:11:29 aaron Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: jot.c,v 1.6 2000/12/21 15:11:29 aaron Exp $";
d69 1
a69 1
#define	isdefault(s)	(strcmp((s), "-") == 0)
d98 6
a103 3
	register double	*x = &xd;
	register double	*y = &yd;
	register long	*i = &id;
d105 2
a106 26
	getargs(argc, argv);
	if (randomize) {
		*x = (ender - begin) * (ender > begin ? 1 : -1);
		for (*i = 1; *i <= reps || infinity; (*i)++) {
			*y = (double) arc4random() / ULONG_MAX;
			putdata(*y * *x + begin, reps - *i);
		}
	}
	else
		for (*i = 1, *x = begin; *i <= reps || infinity; (*i)++, *x += s)
			putdata(*x, reps - *i);
	if (!nofinalnl)
		putchar('\n');
	exit(0);
}

void
getargs(ac, av)
	int ac;
	char *av[];
{
	register unsigned int	mask = 0;
	register int		n = 0;

	while (--ac && **++av == '-' && !isdefault(*av))
		switch ((*av)[1]) {
d118 4
d123 3
a125 11
			if ((*av)[2]) {
				if (strlcpy(format, *av + 2, sizeof(format)) >=
				    sizeof(format))
					errx(1, "-w word too long");
			} else if (!--ac)
				errx(1, "Need context word after -w or -b");
			else {
				if (strlcpy(format, *++av, sizeof(format)) >=
				    sizeof(format))
					errx(1, "-w word too long");
			}
d128 3
a130 11
			if ((*av)[2]) {
				if (strlcpy(sepstring, *av + 2, sizeof(sepstring)) >=
				    sizeof(sepstring))
					errx(1, "-s word too long");
			} else if (!--ac)
				errx(1, "Need string after -s");
			else {
				if (strlcpy(sepstring, *++av, sizeof(sepstring)) >=
				    sizeof(sepstring))
					errx(1, "-s word too long");
			}
d133 1
a133 6
			if ((*av)[2])
				prec = atoi(*av + 2);
			else if (!--ac)
				errx(1, "Need number after -p");
			else
				prec = atoi(*++av);
d135 1
a135 1
				errx(1, "Bad precision value");
d140 2
d143 1
a143 1
	switch (ac) {	/* examine args right to left, falling thru cases */
d145 3
a147 3
		if (!isdefault(av[3])) {
			if (!sscanf(av[3], "%lf", &s))
				errx(1, "Bad s value:  %s", av[3]);
d151 3
a153 3
		if (!isdefault(av[2])) {
			if (!sscanf(av[2], "%lf", &ender))
				ender = av[2][strlen(av[2])-1];
d156 1
a156 1
				n = getprec(av[2]);
d159 3
a161 3
		if (!isdefault(av[1])) {
			if (!sscanf(av[1], "%lf", &begin))
				begin = av[1][strlen(av[1])-1];
d164 1
a164 1
				prec = getprec(av[1]);
d169 3
a171 3
		if (!isdefault(av[0])) {
			if (!sscanf(av[0], "%ld", &reps))
				errx(1, "Bad reps value:  %s", av[0]);
d176 2
a177 1
		errx(1, "jot - print sequential or random data");
d179 1
a179 1
		errx(1, "Too many arguments.  What do you mean by %s?", av[4]);
d277 1
a277 1
			errx(1, "Bad mask");
d281 13
d302 1
a302 1
	register long	*dp = &d;
d326 2
a327 2
	register char	*p;
	register char	*q;
d343 2
a344 1
	register char	*p;
d349 12
a360 6
		if (*p == '%' && *(p+1) != '%')	/* leave %% alone */
			break;
	if (!*p && !chardata)
		sprintf(p, "%%.%df", prec);
	else if (!*p && chardata) {
		strcpy(p, "%c");
d362 3
a364 2
	}
	else if (!*(p+1))
d366 7
a372 2
	else {
		while (!isalpha(*p))
d376 1
d379 1
a379 1
			errx(1, "Cannot convert numeric data to strings");
d381 3
a383 3
		/* case 'd': case 'o': case 'x': case 'D': case 'O': case 'X':
		case 'c': case 'u': */
		default:
d386 2
d389 9
@


1.6
log
@Use arc4random().
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.5 2000/07/14 07:16:12 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: jot.c,v 1.5 2000/07/14 07:16:12 deraadt Exp $";
d56 1
a78 2


d85 5
a89 5
void	error __P((char *, char *));
void	getargs __P((int, char *[]));
void	getformat __P((void));
int	getprec __P((char *));
void	putdata __P((double, long));
d143 1
a143 1
					error("-w word too long", "");
d145 1
a145 1
				error("Need context word after -w or -b", "");
d149 1
a149 1
					error("-w word too long", "");
d156 1
a156 1
					error("-s word too long", "");
d158 1
a158 1
				error("Need string after -s", "");
d162 1
a162 1
					error("-s word too long", "");
d169 1
a169 1
				error("Need number after -p", "");
d173 1
a173 1
				error("Bad precision value", "");
d176 1
a176 1
			error("Unknown option %s", *av);
d183 1
a183 1
				error("Bad s value:  %s", av[3]);
d207 1
a207 1
				error("Bad reps value:  %s", av[0]);
d212 1
a212 1
		error("jot - print sequential or random data", "");
d214 1
a214 1
		error("Too many arguments.  What do you mean by %s?", av[4]);
d256 1
a256 1
				error("Impossible stepsize", "");
d275 1
a275 1
				error("Must specify begin if reps == 0", "");
d294 1
a294 2
				error("Infinite sequences cannot be bounded",
				    "");
d305 1
a305 1
					error("Impossible stepsize", "");
d312 1
a312 1
			error("Bad mask", "");
d336 2
a337 3
void
error(msg, s)
	char *msg, *s;
d339 2
a340 13
	fprintf(stderr, "jot: ");
	fprintf(stderr, msg, s);
	fprintf(stderr,
	    "\nusage:  jot [ options ] [ reps [ begin [ end [ s ] ] ] ]\n");
	if (strncmp("jot - ", msg, 6) == 0)
		fprintf(stderr, "Options:\n\t%s\t%s\t%s\t%s\t%s\t%s\t%s",
			"-r		random data\n",
			"-c		character data\n",
			"-n		no final newline\n",
			"-b word		repeated word\n",
			"-w word		context word\n",
			"-s string	data separator\n",
			"-p precision	number of characters\n");
d387 1
a387 1
			error("Cannot convert numeric data to strings", "");
@


1.5
log
@previous two patches mixed up if/else matching
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.4 1999/12/04 21:28:34 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: jot.c,v 1.4 1999/12/04 21:28:34 deraadt Exp $";
d78 2
a105 1
		srandom((int) s);
d107 1
a107 1
			*y = (double) random() / INT_MAX;
d269 1
a269 1
			s = (randomize ? time(0) : STEP_DEF);
d281 1
a281 1
			s = (randomize ? time(0) : STEP_DEF);
d293 1
a293 1
				s = time(0);
@


1.4
log
@more oflows
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.3 1999/12/04 21:27:02 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: jot.c,v 1.3 1999/12/04 21:27:02 deraadt Exp $";
d140 1
a140 1
			if ((*av)[2])
d144 1
a144 1
			else if (!--ac)
d146 1
a146 1
			else
d150 1
d153 1
a153 1
			if ((*av)[2])
d157 1
a157 1
			else if (!--ac)
d159 1
a159 1
			else
d163 1
@


1.3
log
@oflows
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.2 1996/06/26 05:34:41 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: jot.c,v 1.2 1996/06/26 05:34:41 deraadt Exp $";
d147 3
a149 1
				strcpy(format, *++av);
d159 3
a161 1
				strcpy(sepstring, *++av);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: jot.c,v 1.3 1994/12/02 20:29:43 pk Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: jot.c,v 1.3 1994/12/02 20:29:43 pk Exp $";
d141 3
a143 1
				strcpy(format, *av + 2);
d151 3
a153 1
				strcpy(sepstring, *av + 2);
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: jot.c,v 1.3 1994/12/02 20:29:43 pk Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
