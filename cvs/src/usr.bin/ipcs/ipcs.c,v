head	1.26;
access;
symbols
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.12
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.8
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.4
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.14
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.12
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.8
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.6
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.4
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.2
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.12
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.10
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.6
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.8
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.21.0.12
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.10
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.8
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.6
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.4
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.16.0.4
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2015.01.16.06.40.08;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	Uu5nFG3wCl0LACBb;

1.25
date	2012.02.05.18.27.03;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.26.05.42.21;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.02.23.50.04;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.22.14.47.45;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.04.16.24.45;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.17.23.11.32;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.15.18.47.50;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.12.06.07.15;	author mpech;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.28.01.44.37;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.13.15.10.21;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.13.15.04.29;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.12.05.17.11;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.14.17.48.01;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.29.01.07.49;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.01.21.49.40;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.08.16.16.58.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.07.08.22.14.13;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.01.15.23.42.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.12.22.03.25.54;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.08.11.00.24.32;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.34.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.16.10.35.59;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.30.09.11.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: ipcs.c,v 1.25 2012/02/05 18:27:03 guenther Exp $	*/
/*	$NetBSD: ipcs.c,v 1.25 2000/06/16 03:58:20 simonb Exp $	*/

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Simon Burge.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994 SigmaSoft, Th. Lockert <tholo@@sigmasoft.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/sysctl.h>
#define _KERNEL			/* XXX */
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/msg.h>
#undef _KERNEL

#include <err.h>
#include <fcntl.h>
#include <grp.h>
#include <kvm.h>
#include <limits.h>
#include <nlist.h>
#include <paths.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

void	cvt_time(time_t, char *, size_t);
char   *fmt_perm(mode_t);
void	ipcs_kvm(void);
int	main(int, char **);
void	msg_sysctl(void);
void	sem_sysctl(void);
void	shm_sysctl(void);
void	show_msginfo(time_t, time_t, time_t, int, key_t, mode_t, uid_t,
	    gid_t, uid_t, gid_t, u_long, u_long, u_long, pid_t, pid_t);
void	show_msginfo_hdr(void);
void	show_msgtotal(struct msginfo *);
void	show_seminfo_hdr(void);
void	show_seminfo(time_t, time_t, int, key_t, mode_t, uid_t, gid_t,
	    uid_t, gid_t, int16_t);
void	show_semtotal(struct seminfo *);
void	show_shminfo(time_t, time_t, time_t, int, key_t, mode_t, uid_t,
	    gid_t, uid_t, gid_t, u_int32_t, int, pid_t, pid_t);
void	show_shminfo_hdr(void);
void	show_shmtotal(struct shminfo *);
__dead	void usage(void);

char *
fmt_perm(mode_t mode)
{
	static char buffer[12];

	buffer[0] = '-';
	buffer[1] = '-';
	buffer[2] = ((mode & 0400) ? 'r' : '-');
	buffer[3] = ((mode & 0200) ? 'w' : '-');
	buffer[4] = ((mode & 0100) ? 'a' : '-');
	buffer[5] = ((mode & 0040) ? 'r' : '-');
	buffer[6] = ((mode & 0020) ? 'w' : '-');
	buffer[7] = ((mode & 0010) ? 'a' : '-');
	buffer[8] = ((mode & 0004) ? 'r' : '-');
	buffer[9] = ((mode & 0002) ? 'w' : '-');
	buffer[10] = ((mode & 0001) ? 'a' : '-');
	buffer[11] = '\0';
	return (&buffer[0]);
}

void
cvt_time(time_t t, char *buf, size_t buflen)
{
	struct tm *tm;

	if (t == 0)
		(void)strlcpy(buf, "no-entry", buflen);
	else {
		tm = localtime(&t);
		(void)snprintf(buf, buflen, "%2d:%02d:%02d",
			tm->tm_hour, tm->tm_min, tm->tm_sec);
	}
}
#define	SHMINFO		1
#define	SHMTOTAL	2
#define	MSGINFO		4
#define	MSGTOTAL	8
#define	SEMINFO		16
#define	SEMTOTAL	32

#define BIGGEST		1
#define CREATOR		2
#define OUTSTANDING	4
#define PID		8
#define TIME		16

char	*core = NULL, *namelist = NULL;
int	display = SHMINFO | MSGINFO | SEMINFO;
int	option = 0;

int
main(int argc, char **argv)
{
	int ch;

	while ((ch = getopt(argc, argv, "MmQqSsabC:cN:optT")) != -1)
		switch (ch) {
		case 'M':
			display = SHMTOTAL;
			break;
		case 'm':
			display = SHMINFO;
			break;
		case 'Q':
			display = MSGTOTAL;
			break;
		case 'q':
			display = MSGINFO;
			break;
		case 'S':
			display = SEMTOTAL;
			break;
		case 's':
			display = SEMINFO;
			break;
		case 'T':
			display = SHMTOTAL | MSGTOTAL | SEMTOTAL;
			break;
		case 'a':
			option |= BIGGEST | CREATOR | OUTSTANDING | PID | TIME;
			break;
		case 'b':
			option |= BIGGEST;
			break;
		case 'C':
			core = optarg;
			break;
		case 'c':
			option |= CREATOR;
			break;
		case 'N':
			namelist = optarg;
			break;
		case 'o':
			option |= OUTSTANDING;
			break;
		case 'p':
			option |= PID;
			break;
		case 't':
			option |= TIME;
			break;
		default:
			usage();
		}

	if (argc - optind > 0)
		usage();

	if (namelist == NULL && core == NULL) {
		if (display & (MSGINFO | MSGTOTAL))
			msg_sysctl();
		if (display & (SHMINFO | SHMTOTAL))
			shm_sysctl();
		if (display & (SEMINFO | SEMTOTAL))
			sem_sysctl();
	} else
		ipcs_kvm();

	exit(0);
}

void
show_msgtotal(struct msginfo *msginfo)
{

	printf("msginfo:\n");
	printf("\tmsgmax: %6d\t(max characters in a message)\n",
	    msginfo->msgmax);
	printf("\tmsgmni: %6d\t(# of message queues)\n",
	    msginfo->msgmni);
	printf("\tmsgmnb: %6d\t(max characters in a message queue)\n",
	    msginfo->msgmnb);
	printf("\tmsgtql: %6d\t(max # of messages in system)\n",
	    msginfo->msgtql);
	printf("\tmsgssz: %6d\t(size of a message segment)\n",
	    msginfo->msgssz);
	printf("\tmsgseg: %6d\t(# of message segments in system)\n\n",
	    msginfo->msgseg);
}

void
show_shmtotal(struct shminfo *shminfo)
{

	printf("shminfo:\n");
	printf("\tshmmax: %7d\t(max shared memory segment size)\n",
	    shminfo->shmmax);
	printf("\tshmmin: %7d\t(min shared memory segment size)\n",
	    shminfo->shmmin);
	printf("\tshmmni: %7d\t(max number of shared memory identifiers)\n",
	    shminfo->shmmni);
	printf("\tshmseg: %7d\t(max shared memory segments per process)\n",
	    shminfo->shmseg);
	printf("\tshmall: %7d\t(max amount of shared memory in pages)\n\n",
	    shminfo->shmall);
}

void
show_semtotal(struct seminfo *seminfo)
{

	printf("seminfo:\n");
	printf("\tsemmni: %6d\t(# of semaphore identifiers)\n",
	    seminfo->semmni);
	printf("\tsemmns: %6d\t(# of semaphores in system)\n",
	    seminfo->semmns);
	printf("\tsemmnu: %6d\t(# of undo structures in system)\n",
	    seminfo->semmnu);
	printf("\tsemmsl: %6d\t(max # of semaphores per id)\n",
	    seminfo->semmsl);
	printf("\tsemopm: %6d\t(max # of operations per semop call)\n",
	    seminfo->semopm);
	printf("\tsemume: %6d\t(max # of undo entries per process)\n",
	    seminfo->semume);
	printf("\tsemusz: %6d\t(size in bytes of undo structure)\n",
	    seminfo->semusz);
	printf("\tsemvmx: %6d\t(semaphore maximum value)\n",
	    seminfo->semvmx);
	printf("\tsemaem: %6d\t(adjust on exit max value)\n\n",
	    seminfo->semaem);
}

void
show_msginfo_hdr(void)
{

	printf("Message Queues:\n");
	printf("T       ID     KEY        MODE       OWNER    GROUP");
	if (option & CREATOR)
		printf("  CREATOR   CGROUP");
	if (option & OUTSTANDING)
		printf(" CBYTES  QNUM");
	if (option & BIGGEST)
		printf(" QBYTES");
	if (option & PID)
		printf(" LSPID LRPID");
	if (option & TIME)
		printf("    STIME    RTIME    CTIME");
	printf("\n");
}

void
show_msginfo(time_t stime, time_t rtime, time_t ctime, int ipcid, key_t key,
    mode_t mode, uid_t uid, gid_t gid, uid_t cuid, gid_t cgid,
    u_long cbytes, u_long qnum, u_long qbytes, pid_t lspid,
    pid_t lrpid)
{
	char stime_buf[100], rtime_buf[100], ctime_buf[100];

	if (option & TIME) {
		cvt_time(stime, stime_buf, sizeof(stime_buf));
		cvt_time(rtime, rtime_buf, sizeof(rtime_buf));
		cvt_time(ctime, ctime_buf, sizeof(ctime_buf));
	}

	printf("q %8d %10ld %s %8s %8s", ipcid, key, fmt_perm(mode),
	    user_from_uid(uid, 0), group_from_gid(gid, 0));

	if (option & CREATOR)
		printf(" %8s %8s", user_from_uid(cuid, 0),
		    group_from_gid(cgid, 0));

	if (option & OUTSTANDING)
		printf(" %6lu %5lu", cbytes, qnum);

	if (option & BIGGEST)
		printf(" %6lu", qbytes);

	if (option & PID)
		printf(" %5ld %5ld", (long)lspid, (long)lrpid);

	if (option & TIME)
		printf(" %s %s %s", stime_buf, rtime_buf, ctime_buf);

	printf("\n");
}

void
show_shminfo_hdr(void)
{

	printf("Shared Memory:\n");
	printf("T       ID     KEY        MODE       OWNER    GROUP");
	if (option & CREATOR)
		printf("  CREATOR   CGROUP");
	if (option & OUTSTANDING)
		printf(" NATTCH");
	if (option & BIGGEST)
		printf("   SEGSZ");
	if (option & PID)
		printf("  CPID  LPID");
	if (option & TIME)
		printf("    ATIME    DTIME    CTIME");
	printf("\n");
}

void
show_shminfo(time_t atime, time_t dtime, time_t ctime, int ipcid, key_t key,
    mode_t mode, uid_t uid, gid_t gid, uid_t cuid, gid_t cgid,
    u_int32_t nattch, int segsz, pid_t cpid, pid_t lpid)
{
	char atime_buf[100], dtime_buf[100], ctime_buf[100];

	if (option & TIME) {
		cvt_time(atime, atime_buf, sizeof(atime_buf));
		cvt_time(dtime, dtime_buf, sizeof(dtime_buf));
		cvt_time(ctime, ctime_buf, sizeof(ctime_buf));
	}

	printf("m %8d %10ld %s %8s %8s", ipcid, key, fmt_perm(mode),
	    user_from_uid(uid, 0), group_from_gid(gid, 0));

	if (option & CREATOR)
		printf(" %8s %8s", user_from_uid(cuid, 0),
		    group_from_gid(cgid, 0));

	if (option & OUTSTANDING)
		printf(" %6d", nattch);

	if (option & BIGGEST)
		printf(" %7d", segsz);

	if (option & PID)
		printf(" %5d %5d", cpid, lpid);

	if (option & TIME)
		printf(" %s %s %s",
		    atime_buf,
		    dtime_buf,
		    ctime_buf);

	printf("\n");
}

void
show_seminfo_hdr(void)
{

	printf("Semaphores:\n");
	printf("T       ID     KEY        MODE       OWNER    GROUP");
	if (option & CREATOR)
		printf("  CREATOR   CGROUP");
	if (option & BIGGEST)
		printf(" NSEMS");
	if (option & TIME)
		printf("    OTIME    CTIME");
	printf("\n");
}

void
show_seminfo(time_t otime, time_t ctime, int ipcid, key_t key, mode_t mode,
    uid_t uid, gid_t gid, uid_t cuid, gid_t cgid, int16_t nsems)
{
	char ctime_buf[100], otime_buf[100];

	if (option & TIME) {
		cvt_time(otime, otime_buf, sizeof(otime_buf));
		cvt_time(ctime, ctime_buf, sizeof(ctime_buf));
	}

	printf("s %8d %10ld %s %8s %8s", ipcid, key, fmt_perm(mode),
	    user_from_uid(uid, 0), group_from_gid(gid, 0));

	if (option & CREATOR)
		printf(" %8s %8s", user_from_uid(cuid, 0),
		    group_from_gid(cgid, 0));

	if (option & BIGGEST)
		printf(" %5d", nsems);

	if (option & TIME)
		printf(" %s %s", otime_buf, ctime_buf);

	printf("\n");
}

void
msg_sysctl(void)
{
	struct msg_sysctl_info *msgsi;
	char *buf;
	int mib[3];
	size_t len;
	int i, valid;

	mib[0] = CTL_KERN;
	mib[1] = KERN_SYSVMSG;
	len = sizeof(valid);
	if (sysctl(mib, 2, &valid, &len, NULL, 0) < 0) {
		warn("sysctl(KERN_SYSVMSG)");
		return;
	}
	if (!valid) {
		warnx("SVID messages facility not configured in the system");
		return;
	}

	mib[0] = CTL_KERN;
	mib[1] = KERN_SYSVIPC_INFO;
	mib[2] = KERN_SYSVIPC_MSG_INFO;

	if (!(display & MSGINFO)) {
		/* totals only */
		len = sizeof(struct msginfo);
	} else {
		if (sysctl(mib, 3, NULL, &len, NULL, 0) < 0) {
			warn("sysctl(KERN_SYSVIPC_MSG_INFO)");
			return;
		}
	}

	if ((buf = malloc(len)) == NULL)
		err(1, "malloc");
	msgsi = (struct msg_sysctl_info *)buf;
	if (sysctl(mib, 3, msgsi, &len, NULL, 0) < 0) {
		warn("sysctl(KERN_SYSVIPC_MSG_INFO)");
		return;
	}

	if (display & MSGTOTAL)
		show_msgtotal(&msgsi->msginfo);

	if (display & MSGINFO) {
		show_msginfo_hdr();
		for (i = 0; i < msgsi->msginfo.msgmni; i++) {
			struct msqid_ds *msqptr = &msgsi->msgids[i];
			if (msqptr->msg_qbytes != 0)
				show_msginfo(msqptr->msg_stime,
				    msqptr->msg_rtime,
				    msqptr->msg_ctime,
				    IXSEQ_TO_IPCID(i, msqptr->msg_perm),
				    msqptr->msg_perm.key,
				    msqptr->msg_perm.mode,
				    msqptr->msg_perm.uid,
				    msqptr->msg_perm.gid,
				    msqptr->msg_perm.cuid,
				    msqptr->msg_perm.cgid,
				    msqptr->msg_cbytes,
				    msqptr->msg_qnum,
				    msqptr->msg_qbytes,
				    msqptr->msg_lspid,
				    msqptr->msg_lrpid);
		}
		printf("\n");
	}
}

void
shm_sysctl(void)
{
	struct shm_sysctl_info *shmsi;
	char *buf;
	int mib[3];
	size_t len;
	int i, valid;

	mib[0] = CTL_KERN;
	mib[1] = KERN_SYSVSHM;
	len = sizeof(valid);
	if (sysctl(mib, 2, &valid, &len, NULL, 0) < 0) {
		warn("sysctl(KERN_SYSVSHM)");
		return;
	}
	if (!valid) {
		warnx("SVID shared memory facility not configured in "
		    "the system");
		return;
	}

	mib[0] = CTL_KERN;
	mib[1] = KERN_SYSVIPC_INFO;
	mib[2] = KERN_SYSVIPC_SHM_INFO;

	if (!(display & SHMINFO)) {
		/* totals only */
		len = sizeof(struct shminfo);
	} else {
		if (sysctl(mib, 3, NULL, &len, NULL, 0) < 0) {
			warn("sysctl(KERN_SYSVIPC_SHM_INFO)");
			return;
		}
	}

	if ((buf = malloc(len)) == NULL)
		err(1, "malloc");
	shmsi = (struct shm_sysctl_info *)buf;
	if (sysctl(mib, 3, shmsi, &len, NULL, 0) < 0) {
		warn("sysctl(KERN_SYSVIPC_SHM_INFO)");
		return;
	}

	if (display & SHMTOTAL)
		show_shmtotal(&shmsi->shminfo);

	if (display & SHMINFO) {
		show_shminfo_hdr();
		for (i = 0; i < shmsi->shminfo.shmmni; i++) {
			struct shmid_ds *shmptr = &shmsi->shmids[i];
			if (shmptr->shm_internal)
				show_shminfo(shmptr->shm_atime,
				    shmptr->shm_dtime,
				    shmptr->shm_ctime,
				    IXSEQ_TO_IPCID(i, shmptr->shm_perm),
				    shmptr->shm_perm.key,
				    shmptr->shm_perm.mode,
				    shmptr->shm_perm.uid,
				    shmptr->shm_perm.gid,
				    shmptr->shm_perm.cuid,
				    shmptr->shm_perm.cgid,
				    shmptr->shm_nattch,
				    shmptr->shm_segsz,
				    shmptr->shm_cpid,
				    shmptr->shm_lpid);
		}
		printf("\n");
	}
}

void
sem_sysctl(void)
{
	struct sem_sysctl_info *semsi;
	char *buf;
	int mib[3];
	size_t len;
	int i, valid;

	mib[0] = CTL_KERN;
	mib[1] = KERN_SYSVSEM;
	len = sizeof(valid);
	if (sysctl(mib, 2, &valid, &len, NULL, 0) < 0) {
		warn("sysctl(KERN_SYSVSEM)");
		return;
	}
	if (!valid) {
		warnx("SVID shared memory facility not configured in "
		    "the system");
		return;
	}

	mib[0] = CTL_KERN;
	mib[1] = KERN_SYSVIPC_INFO;
	mib[2] = KERN_SYSVIPC_SEM_INFO;

	if (!(display & SEMINFO)) {
		/* totals only */
		len = sizeof(struct seminfo);
	} else {
		if (sysctl(mib, 3, NULL, &len, NULL, 0) < 0) {
			warn("sysctl(KERN_SYSVIPC_SEM_INFO)");
			return;
		}
	}

	if ((buf = malloc(len)) == NULL)
		err(1, "malloc");
	semsi = (struct sem_sysctl_info *)buf;
	if (sysctl(mib, 3, semsi, &len, NULL, 0) < 0) {
		warn("sysctl(KERN_SYSVIPC_SEM_INFO)");
		return;
	}

	if (display & SEMTOTAL)
		show_semtotal(&semsi->seminfo);

	if (display & SEMINFO) {
		show_seminfo_hdr();
		for (i = 0; i < semsi->seminfo.semmni; i++) {
			struct semid_ds *semaptr = &semsi->semids[i];

			if (semaptr->sem_base != NULL)
				show_seminfo(semaptr->sem_otime,
				    semaptr->sem_ctime,
				    IXSEQ_TO_IPCID(i, semaptr->sem_perm),
				    semaptr->sem_perm.key,
				    semaptr->sem_perm.mode,
				    semaptr->sem_perm.uid,
				    semaptr->sem_perm.gid,
				    semaptr->sem_perm.cuid,
				    semaptr->sem_perm.cgid,
				    semaptr->sem_nsems);
		}
		printf("\n");
	}
}

void
ipcs_kvm(void)
{
	struct msginfo msginfo;
	struct que msgque;
	struct msqid_ds *msqids;
	struct seminfo seminfo;
	struct semid_ds sem, **sema;
	struct shminfo shminfo;
	struct shmid_ds shmseg, **shmsegs;
	char errbuf[_POSIX2_LINE_MAX];
	u_long addr;
	kvm_t *kd;
	int i;
	struct nlist symbols[] = {
		{"_sema"},
	#define X_SEMA		0
		{"_seminfo"},
	#define X_SEMINFO	1
		{"_semu"},
	#define X_SEMU		2
		{"_msginfo"},
	#define X_MSGINFO	3
		{"_msg_queues"},
	#define X_MSG_QUEUES	4
		{"_shminfo"},
	#define X_SHMINFO	5
		{"_shmsegs"},
	#define X_SHMSEGS	6
		{NULL}
	};

	if ((kd = kvm_openfiles(namelist, core, NULL, O_RDONLY,
	    errbuf)) == NULL)
		errx(1, "can't open kvm: %s", errbuf);

	switch (kvm_nlist(kd, symbols)) {
	case 0:
		break;
	case -1:
		errx(1, "%s: unable to read symbol table.",
		    namelist == NULL ? _PATH_UNIX : namelist);
		/* NOTREACHED */
	default:
#ifdef notdef		/* they'll be told more civilly later */
		warnx("nlist failed");
		for (i = 0; symbols[i].n_name != NULL; i++)
			if (symbols[i].n_value == 0)
				warnx("symbol %s not found", symbols[i].n_name);
#endif
		break;
	}

	if ((display & (MSGINFO | MSGTOTAL)) &&
	    (kvm_read(kd, symbols[X_MSGINFO].n_value,
	     &msginfo, sizeof(msginfo)) == sizeof(msginfo))) {

		if (display & MSGTOTAL)
			show_msgtotal(&msginfo);

		if (display & MSGINFO) {
			if (kvm_read(kd, symbols[X_MSG_QUEUES].n_value,
			    &addr, sizeof(addr)) != sizeof(addr))
				errx(1, "kvm_read (%s): %s",
				    symbols[X_MSG_QUEUES].n_name,
				    kvm_geterr(kd));

			msqids = calloc(sizeof(struct msqid_ds),
			    msginfo.msgmni);
			if (msqids == NULL)
				err(1, "calloc");

			/* walk the TAILQ */
			while (addr != 0) {
				if (kvm_read(kd, addr, &msgque, sizeof(msgque))
				    != sizeof(msgque))
					errx(1, "kvm_read (%s): %s",
					    "msg que", kvm_geterr(kd));
				msqids[msgque.que_ix] = msgque.msqid_ds;
				addr = (u_long)TAILQ_NEXT(&msgque, que_next);
			}

			show_msginfo_hdr();
			for (i = 0; i < msginfo.msgmni; i++) {
				struct msqid_ds *msqptr = &msqids[i];
				if (msqptr->msg_qbytes != 0)
					show_msginfo(msqptr->msg_stime,
					    msqptr->msg_rtime,
					    msqptr->msg_ctime,
					    IXSEQ_TO_IPCID(i, msqptr->msg_perm),
					    msqptr->msg_perm.key,
					    msqptr->msg_perm.mode,
					    msqptr->msg_perm.uid,
					    msqptr->msg_perm.gid,
					    msqptr->msg_perm.cuid,
					    msqptr->msg_perm.cgid,
					    msqptr->msg_cbytes,
					    msqptr->msg_qnum,
					    msqptr->msg_qbytes,
					    msqptr->msg_lspid,
					    msqptr->msg_lrpid);
			}
			printf("\n");
		}
	} else {
		if (display & (MSGINFO | MSGTOTAL)) {
			warnx("SVID messages facility not configured in "
			    "the system");
		}
	}
	if ((display & (SHMINFO | SHMTOTAL)) &&
	    (kvm_read(kd, symbols[X_SHMINFO].n_value, &shminfo,
	     sizeof(shminfo)) == sizeof(shminfo))) {

		if (display & SHMTOTAL)
			show_shmtotal(&shminfo);

		if (display & SHMINFO) {
			if (kvm_read(kd, symbols[X_SHMSEGS].n_value, &addr,
			    sizeof(addr)) != sizeof(addr))
				errx(1, "kvm_read (%s): %s",
				    symbols[X_SHMSEGS].n_name, kvm_geterr(kd));

			shmsegs = calloc(sizeof(struct shmid_ds *),
			    shminfo.shmmni);
			if (shmsegs == NULL)
				err(1, "calloc");

			if (kvm_read(kd, addr, shmsegs,
			    sizeof(struct shmid_ds *) * shminfo.shmmni) !=
			    sizeof(struct shmid_ds *) * shminfo.shmmni)
				errx(1, "kvm_read (shmsegs): %s",
				    kvm_geterr(kd));

			show_shminfo_hdr();
			for (i = 0; i < shminfo.shmmni; i++) {
				if (shmsegs[i] == NULL)
					continue;

				if (kvm_read(kd, (u_long)shmsegs[i], &shmseg,
				    sizeof(shmseg)) != sizeof(shmseg))
					errx(1, "kvm_read (shmseg): %s",
					    kvm_geterr(kd));
				show_shminfo(shmseg.shm_atime,
				    shmseg.shm_dtime,
				    shmseg.shm_ctime,
				    IXSEQ_TO_IPCID(i, shmseg.shm_perm),
				    shmseg.shm_perm.key,
				    shmseg.shm_perm.mode,
				    shmseg.shm_perm.uid,
				    shmseg.shm_perm.gid,
				    shmseg.shm_perm.cuid,
				    shmseg.shm_perm.cgid,
				    shmseg.shm_nattch,
				    shmseg.shm_segsz,
				    shmseg.shm_cpid,
				    shmseg.shm_lpid);
			}
			printf("\n");
		}
	} else
		if (display & (SHMINFO | SHMTOTAL)) {
			warnx("SVID shared memory facility not configured in "
			    "the system");
		}
	if ((display & (SEMINFO | SEMTOTAL)) &&
	    (kvm_read(kd, symbols[X_SEMINFO].n_value, &seminfo,
	     sizeof(seminfo)) == sizeof(seminfo))) {
		if (display & SEMTOTAL)
			show_semtotal(&seminfo);

		if (display & SEMINFO) {
			if (kvm_read(kd, symbols[X_SEMA].n_value, &addr,
			    sizeof(addr)) != sizeof(addr))
				errx(1, "kvm_read (%s): %s",
				    symbols[X_SEMA].n_name, kvm_geterr(kd));

			sema = calloc(sizeof(struct semid_ds *),
			    seminfo.semmni);
			if (sema == NULL)
				err(1, "calloc");

			if (kvm_read(kd, addr, sema,
			    sizeof(struct semid_ds *) * seminfo.semmni) !=
			    sizeof(struct semid_ds *) * seminfo.semmni)
				errx(1, "kvm_read (sema): %s",
				    kvm_geterr(kd));

			show_seminfo_hdr();
			for (i = 0; i < seminfo.semmni; i++) {
				if (sema[i] == NULL)
					continue;

				if (kvm_read(kd, (u_long)sema[i], &sem,
				    sizeof(sem)) != sizeof(sem))
					errx(1, "kvm_read (sem): %s",
					    kvm_geterr(kd));
				show_seminfo(sem.sem_otime,
				    sem.sem_ctime,
				    IXSEQ_TO_IPCID(i, sem.sem_perm),
				    sem.sem_perm.key,
				    sem.sem_perm.mode,
				    sem.sem_perm.uid,
				    sem.sem_perm.gid,
				    sem.sem_perm.cuid,
				    sem.sem_perm.cgid,
				    sem.sem_nsems);
			}
			printf("\n");
		}
	} else
		if (display & (SEMINFO | SEMTOTAL)) {
			warnx("SVID semaphores facility not configured in "
			    "the system");
		}
	kvm_close(kd);
}

void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-abcMmopQqSsTt] [-C core] [-N system]\n",
	    __progname);
	exit(1);
}
@


1.25
log
@Fix handling of msg queues when in crash dump mode: the kernel structures
have changed, so update to match

ok miod@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.24 2011/04/06 11:36:26 miod Exp $	*/
d58 1
a58 1
#include <sys/param.h>
@


1.24
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.23 2008/06/26 05:42:21 ray Exp $	*/
d653 1
d672 2
a673 2
		{"_msqids"},
	#define X_MSQIDS	4
d710 1
a710 1
			if (kvm_read(kd, symbols[X_MSQIDS].n_value,
d713 2
a714 1
				    symbols[X_MSQIDS].n_name, kvm_geterr(kd));
d721 9
a729 5
			if (kvm_read(kd, addr, msqids,
			    sizeof(struct msqid_ds) * msginfo.msgmni) !=
			    sizeof(struct msqid_ds) * msginfo.msgmni)
				errx(1, "kvm_read (msqids): %s",
				    kvm_geterr(kd));
@


1.23
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.22 2007/09/02 23:50:04 deraadt Exp $	*/
d451 1
a451 1
	if (sysctl(mib, 2, &valid, &len, NULL, NULL) < 0) {
d468 1
a468 1
		if (sysctl(mib, 3, NULL, &len, NULL, NULL) < 0) {
d477 1
a477 1
	if (sysctl(mib, 3, msgsi, &len, NULL, NULL) < 0) {
d522 1
a522 1
	if (sysctl(mib, 2, &valid, &len, NULL, NULL) < 0) {
d540 1
a540 1
		if (sysctl(mib, 3, NULL, &len, NULL, NULL) < 0) {
d549 1
a549 1
	if (sysctl(mib, 3, shmsi, &len, NULL, NULL) < 0) {
d593 1
a593 1
	if (sysctl(mib, 2, &valid, &len, NULL, NULL) < 0) {
d611 1
a611 1
		if (sysctl(mib, 3, NULL, &len, NULL, NULL) < 0) {
d620 1
a620 1
	if (sysctl(mib, 3, semsi, &len, NULL, NULL) < 0) {
@


1.22
log
@more malloc(n * m) -> calloc(n, m); from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.21 2005/02/22 14:47:45 jmc Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.21
log
@sort options; sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.20 2003/06/04 16:24:45 deraadt Exp $	*/
d721 1
a721 1
			msqids = malloc(sizeof(struct msqid_ds) *
d724 1
a724 1
				err(1, "malloc");
d773 1
a773 1
			shmsegs = malloc(sizeof(struct shmid_ds *) *
d776 1
a776 1
				err(1, "malloc");
d827 1
a827 1
			sema = malloc(sizeof(struct semid_ds *) *
d830 1
a830 1
				err(1, "malloc");
@


1.20
log
@term 3 & 4 from tholo after permission
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.19 2002/12/17 23:11:32 millert Exp $	*/
d874 1
a874 1
	    "usage: %s [-abcmopqstMQST] [-C corefile] [-N namelist]\n",
@


1.19
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.18 2002/06/15 18:47:50 matthieu Exp $	*/
a51 2
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.18
log
@enlarge ID column to fix output alignment.
ok deraadt@@, millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.17 2002/06/12 06:07:15 mpech Exp $	*/
d69 1
a69 1
#define _KERNEL
d526 1
a526 2
	int i /*, valid */;
	long valid;
d570 1
a570 1
			if (shmptr->shm_perm.mode & 0x0800)
d641 2
a642 1
			if ((semaptr->sem_perm.mode & SEM_ALLOC) != 0)
d664 1
a664 1
	struct semid_ds *sema;
d666 3
a668 1
	struct shmid_ds *shmsegs;
a669 1
	char errbuf[_POSIX2_LINE_MAX];
a717 2
			struct msqid_ds *xmsqids;

d719 1
a719 1
			    &msqids, sizeof(msqids)) != sizeof(msqids))
d723 1
a723 1
			xmsqids = malloc(sizeof(struct msqid_ds) *
d725 2
d728 1
a728 1
			if (kvm_read(kd, (u_long)msqids, xmsqids,
d736 1
a736 1
				struct msqid_ds *msqptr = &xmsqids[i];
d770 2
a771 4
			struct shmid_ds *xshmids;

			if (kvm_read(kd, symbols[X_SHMSEGS].n_value, &shmsegs,
			    sizeof(shmsegs)) != sizeof(shmsegs))
d775 1
a775 1
			xshmids = malloc(sizeof(struct shmid_ds) *
d777 2
d780 3
a782 3
			if (kvm_read(kd, (u_long)shmsegs, xshmids,
			    sizeof(struct shmid_ds) * shminfo.shmmni) !=
			    sizeof(struct shmid_ds) * shminfo.shmmni)
d788 21
a808 16
				struct shmid_ds *shmptr = &xshmids[i];
				if (shmptr->shm_perm.mode & 0x0800)
					show_shminfo(shmptr->shm_atime,
					    shmptr->shm_dtime,
					    shmptr->shm_ctime,
					    IXSEQ_TO_IPCID(i, shmptr->shm_perm),
					    shmptr->shm_perm.key,
					    shmptr->shm_perm.mode,
					    shmptr->shm_perm.uid,
					    shmptr->shm_perm.gid,
					    shmptr->shm_perm.cuid,
					    shmptr->shm_perm.cgid,
					    shmptr->shm_nattch,
					    shmptr->shm_segsz,
					    shmptr->shm_cpid,
					    shmptr->shm_lpid);
a819 2
		struct semid_ds *xsema;

d824 2
a825 2
			if (kvm_read(kd, symbols[X_SEMA].n_value, &sema,
			    sizeof(sema)) != sizeof(sema))
d829 1
a829 1
			xsema = malloc(sizeof(struct semid_ds) *
d831 2
d834 3
a836 3
			if (kvm_read(kd, (u_long)sema, xsema,
			    sizeof(struct semid_ds) * seminfo.semmni) !=
			    sizeof(struct semid_ds) * seminfo.semmni)
d842 17
a858 12
				struct semid_ds *semaptr = &xsema[i];
				if ((semaptr->sem_perm.mode & SEM_ALLOC) != 0)
					show_seminfo(semaptr->sem_otime,
					    semaptr->sem_ctime,
					    IXSEQ_TO_IPCID(i, semaptr->sem_perm),
					    semaptr->sem_perm.key,
					    semaptr->sem_perm.mode,
					    semaptr->sem_perm.uid,
					    semaptr->sem_perm.gid,
					    semaptr->sem_perm.cuid,
					    semaptr->sem_perm.cgid,
					    semaptr->sem_nsems);
a859 1

@


1.17
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.16 2001/09/28 01:44:37 millert Exp $	*/
d299 1
a299 1
	printf("T     ID     KEY        MODE       OWNER    GROUP");
d327 1
a327 1
	printf("q %6d %10ld %s %8s %8s", ipcid, key, fmt_perm(mode),
d354 1
a354 1
	printf("T     ID     KEY        MODE       OWNER    GROUP");
d381 1
a381 1
	printf("m %6d %10ld %s %8s %8s", ipcid, key, fmt_perm(mode),
d411 1
a411 1
	printf("T     ID     KEY        MODE       OWNER    GROUP");
d432 1
a432 1
	printf("s %6d %10ld %s %8s %8s", ipcid, key, fmt_perm(mode),
@


1.16
log
@Use the new KERN_SYSVIPC_*_INFO sysctls; simonb@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.15 2001/08/13 15:10:21 millert Exp $	*/
d341 1
a341 1
		printf(" %5d %5d", lspid, lrpid);
@


1.15
log
@Declare globals made extern in sys/sem.h; naddy@@
@
text
@d1 38
a38 2
/*	$OpenBSD: ipcs.c,v 1.14 2001/08/13 15:04:29 millert Exp $	*/
/*	$NetBSD: ipcs.c,v 1.10.6.1 1996/06/07 01:53:47 thorpej Exp $	*/
a66 1
#include <sys/types.h>
d68 1
a68 2
#include <sys/time.h>
#include <sys/proc.h>
d78 1
a79 2
#include <pwd.h>
#include <grp.h>
d83 1
d87 1
d90 20
a109 3
void	usage __P((void));

extern	char *__progname;		/* from crt0.o */
d111 2
a112 23
static struct nlist symbols[] = {
	{"_sema"},
#define X_SEMA		0
	{"_seminfo"},
#define X_SEMINFO	1
	{"_semu"},
#define X_SEMU		2
	{"_msginfo"},
#define X_MSGINFO	3
	{"_msqids"},
#define X_MSQIDS	4
	{"_shminfo"},
#define X_SHMINFO	5
	{"_shmsegs"},
#define X_SHMSEGS	6
	{NULL}
};

static kvm_t *kd;

char   *
fmt_perm(mode)
	u_short mode;
d114 1
a114 1
	static char buffer[100];
d132 1
a132 3
cvt_time(t, buf)
	time_t  t;
	char   *buf;
d136 3
a138 3
	if (t == 0) {
		strcpy(buf, "no-entry");
	} else {
d140 1
a140 1
		sprintf(buf, "%2d:%02d:%02d",
d157 4
d162 3
a164 15
main(argc, argv)
	int     argc;
	char   *argv[];
{
	struct  semid_ds *sema;
	struct  seminfo seminfo;
	int     semu;
	struct  msginfo msginfo;
	struct  msqid_ds *msqids;
	struct  shminfo shminfo;
	struct  shmid_ds *shmsegs;
	int     display = SHMINFO | MSGINFO | SEMINFO;
	int     option = 0;
	char   *core = NULL, *namelist = NULL;
	int     i;
d166 2
a167 2
	while ((i = getopt(argc, argv, "MmQqSsabC:cN:optT")) != -1)
		switch (i) {
d216 273
a488 7
	/*
	 * Discard setgid privileges if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
	 */
	if (namelist != NULL || core != NULL) {
		setegid(getgid());
		setgid(getgid());
a489 2
	if ((kd = kvm_open(namelist, core, NULL, O_RDONLY, "ipcs")) == NULL)
		exit(1);
d491 200
a690 2
	setegid(getgid());
	setgid(getgid());
d696 3
a698 1
		errx(1, "unable to read kernel symbol table.");
d704 2
a705 2
				warnx("symbol %s not found",
				    symbols[i].n_name);
a706 1
#endif
d713 3
a715 15
		if (display & MSGTOTAL) {
			printf("msginfo:\n");
			printf("\tmsgmax: %6d\t(max characters in a message)\n",
			    msginfo.msgmax);
			printf("\tmsgmni: %6d\t(# of message queues)\n",
			    msginfo.msgmni);
			printf("\tmsgmnb: %6d\t(max characters in a message queue)\n",
			    msginfo.msgmnb);
			printf("\tmsgtql: %6d\t(max # of messages in system)\n",
			    msginfo.msgtql);
			printf("\tmsgssz: %6d\t(size of a message segment)\n",
			    msginfo.msgssz);
			printf("\tmsgseg: %6d\t(# of message segments in system)\n\n",
			    msginfo.msgseg);
		}
d733 7
a739 24
			printf("Message Queues:\n");
			printf("T     ID     KEY        MODE       OWNER    GROUP");
			if (option & CREATOR)
				printf("  CREATOR   CGROUP");
			if (option & OUTSTANDING)
				printf(" CBYTES  QNUM");
			if (option & BIGGEST)
				printf(" QBYTES");
			if (option & PID)
				printf(" LSPID LRPID");
			if (option & TIME)
				printf("   STIME    RTIME    CTIME");
			printf("\n");
			for (i = 0; i < msginfo.msgmni; i += 1) {
				if (xmsqids[i].msg_qbytes != 0) {
					char    stime_buf[100], rtime_buf[100],
					        ctime_buf[100];
					struct msqid_ds *msqptr = &xmsqids[i];

					cvt_time(msqptr->msg_stime, stime_buf);
					cvt_time(msqptr->msg_rtime, rtime_buf);
					cvt_time(msqptr->msg_ctime, ctime_buf);

					printf("q %6d %10ld %s %8s %8s",
d742 10
a751 31
					    fmt_perm(msqptr->msg_perm.mode),
					    user_from_uid(msqptr->msg_perm.uid, 0),
					    group_from_gid(msqptr->msg_perm.gid, 0));

					if (option & CREATOR)
						printf(" %8s %8s",
						    user_from_uid(msqptr->msg_perm.cuid, 0),
						    group_from_gid(msqptr->msg_perm.cgid, 0));

					if (option & OUTSTANDING)
						printf(" %6lu %6lu",
						    msqptr->msg_cbytes,
						    msqptr->msg_qnum);

					if (option & BIGGEST)
						printf(" %6lu",
						    msqptr->msg_qbytes);

					if (option & PID)
						printf(" %6d %6d",
						    msqptr->msg_lspid,
						    msqptr->msg_lrpid);

					if (option & TIME)
						printf(" %s %s %s",
						    stime_buf,
						    rtime_buf,
						    ctime_buf);

					printf("\n");
				}
d755 1
a755 1
	} else
d757 2
a758 2
			fprintf(stderr,
			    "SVID messages facility not configured in the system\n");
d760 1
d765 3
a767 13
		if (display & SHMTOTAL) {
			printf("shminfo:\n");
			printf("\tshmmax: %7d\t(max shared memory segment size)\n",
			    shminfo.shmmax);
			printf("\tshmmin: %7d\t(min shared memory segment size)\n",
			    shminfo.shmmin);
			printf("\tshmmni: %7d\t(max number of shared memory identifiers)\n",
			    shminfo.shmmni);
			printf("\tshmseg: %7d\t(max shared memory segments per process)\n",
			    shminfo.shmseg);
			printf("\tshmall: %7d\t(max amount of shared memory in pages)\n\n",
			    shminfo.shmall);
		}
d785 7
a791 24
			printf("Shared Memory:\n");
			printf("T     ID     KEY        MODE       OWNER    GROUP");
			if (option & CREATOR)
				printf("  CREATOR   CGROUP");
			if (option & OUTSTANDING)
				printf(" NATTCH");
			if (option & BIGGEST)
				printf("  SEGSZ");
			if (option & PID)
				printf("  CPID  LPID");
			if (option & TIME)
				printf("   ATIME    DTIME    CTIME");
			printf("\n");
			for (i = 0; i < shminfo.shmmni; i += 1) {
				if (xshmids[i].shm_perm.mode & 0x0800) {
					char    atime_buf[100], dtime_buf[100],
					        ctime_buf[100];
					struct shmid_ds *shmptr = &xshmids[i];

					cvt_time(shmptr->shm_atime, atime_buf);
					cvt_time(shmptr->shm_dtime, dtime_buf);
					cvt_time(shmptr->shm_ctime, ctime_buf);

					printf("m %6d %10ld %s %8s %8s",
d794 9
a802 30
					    fmt_perm(shmptr->shm_perm.mode),
					    user_from_uid(shmptr->shm_perm.uid, 0),
					    group_from_gid(shmptr->shm_perm.gid, 0));

					if (option & CREATOR)
						printf(" %8s %8s",
						    user_from_uid(shmptr->shm_perm.cuid, 0),
						    group_from_gid(shmptr->shm_perm.cgid, 0));

					if (option & OUTSTANDING)
						printf(" %6d",
						    shmptr->shm_nattch);

					if (option & BIGGEST)
						printf(" %6d",
						    shmptr->shm_segsz);

					if (option & PID)
						printf(" %6d %6d",
						    shmptr->shm_cpid,
						    shmptr->shm_lpid);

					if (option & TIME)
						printf(" %s %s %s",
						    atime_buf,
						    dtime_buf,
						    ctime_buf);

					printf("\n");
				}
d808 2
a809 2
			fprintf(stderr,
			    "SVID shared memory facility not configured in the system\n");
d816 3
a818 21
		if (display & SEMTOTAL) {
			printf("seminfo:\n");
			printf("\tsemmni: %6d\t(# of semaphore identifiers)\n",
			    seminfo.semmni);
			printf("\tsemmns: %6d\t(# of semaphores in system)\n",
			    seminfo.semmns);
			printf("\tsemmnu: %6d\t(# of undo structures in system)\n",
			    seminfo.semmnu);
			printf("\tsemmsl: %6d\t(max # of semaphores per id)\n",
			    seminfo.semmsl);
			printf("\tsemopm: %6d\t(max # of operations per semop call)\n",
			    seminfo.semopm);
			printf("\tsemume: %6d\t(max # of undo entries per process)\n",
			    seminfo.semume);
			printf("\tsemusz: %6d\t(size in bytes of undo structure)\n",
			    seminfo.semusz);
			printf("\tsemvmx: %6d\t(semaphore maximum value)\n",
			    seminfo.semvmx);
			printf("\tsemaem: %6d\t(adjust on exit max value)\n\n",
			    seminfo.semaem);
		}
d834 6
a839 18
			printf("Semaphores:\n");
			printf("T     ID     KEY        MODE       OWNER    GROUP");
			if (option & CREATOR)
				printf("  CREATOR   CGROUP");
			if (option & BIGGEST)
				printf(" NSEMS");
			if (option & TIME)
				printf("   OTIME    CTIME");
			printf("\n");
			for (i = 0; i < seminfo.semmni; i += 1) {
				if ((xsema[i].sem_perm.mode & SEM_ALLOC) != 0) {
					char    ctime_buf[100], otime_buf[100];
					struct semid_ds *semaptr = &xsema[i];

					cvt_time(semaptr->sem_otime, otime_buf);
					cvt_time(semaptr->sem_ctime, ctime_buf);

					printf("s %6d %10ld %s %8s %8s",
d842 6
a847 20
					    fmt_perm(semaptr->sem_perm.mode),
					    user_from_uid(semaptr->sem_perm.uid, 0),
					    group_from_gid(semaptr->sem_perm.gid, 0));

					if (option & CREATOR)
						printf(" %8s %8s",
						    user_from_uid(semaptr->sem_perm.cuid, 0),
						    group_from_gid(semaptr->sem_perm.cgid, 0));

					if (option & BIGGEST)
						printf(" %6d",
						    semaptr->sem_nsems);

					if (option & TIME)
						printf(" %s %s",
						    otime_buf,
						    ctime_buf);

					printf("\n");
				}
d854 2
a855 1
			fprintf(stderr, "SVID semaphores facility not configured in the system\n");
a857 2

	exit(0);
d861 1
a861 1
usage()
d863 1
d866 1
a866 1
	    "usage: %s [-abcmopqst] [-C corefile] [-N namelist]\n",
@


1.14
log
@Don't reference seminfo.semmap as it no longer exists.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.13 2001/07/12 05:17:11 deraadt Exp $	*/
d133 7
@


1.13
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.12 2001/02/14 17:48:01 tholo Exp $	*/
a423 2
			printf("\tsemmap: %6d\t(# of entries in semaphore map)\n",
			    seminfo.semmap);
@


1.12
log
@Relax advertising requirements on copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.11 2000/05/29 01:07:49 angelos Exp $	*/
d45 2
a135 1
	char	errbuf[_POSIX2_LINE_MAX];
d277 1
a277 1
					printf("q %6d %10d %s %8s %8s",
d290 1
a290 1
						printf(" %6d %6d",
d295 1
a295 1
						printf(" %6d",
d376 1
a376 1
					printf("m %6d %10d %s %8s %8s",
a472 1
					int     j, value;
d477 1
a477 1
					printf("s %6d %10d %s %8s %8s",
@


1.11
log
@Print space between the last process to attach/use and the access time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.10 2000/05/01 21:49:40 deraadt Exp $	*/
d16 1
a16 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by SigmaSoft, Th.  Lockert.
 * 4. The name of the author may not be used to endorse or promote products
@


1.10
log
@do not use semconfig()
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.9 1999/08/16 16:58:22 millert Exp $	*/
d306 1
a306 1
						printf("%s %s %s",
d404 1
a404 1
						printf("%s %s %s",
d497 1
a497 1
						printf("%s %s",
@


1.9
log
@nuke unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.8 1998/07/08 22:14:13 deraadt Exp $	*/
a55 1
int	semconfig __P((int, ...));
a447 5
			if (semconfig(SEM_CONFIG_FREEZE) != 0) {
				perror("semconfig");
				fprintf(stderr,
				    "Can't lock semaphore facility - winging it...\n");
			}
a503 2

			(void) semconfig(SEM_CONFIG_THAW);
@


1.8
log
@whack kmem gid after kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.7 1997/01/15 23:42:37 millert Exp $	*/
a481 1
					union semun junk;
@


1.7
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.6 1996/12/22 03:25:54 tholo Exp $	*/
d201 3
@


1.6
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.5 1996/08/11 00:24:32 deraadt Exp $	*/
d141 1
a141 1
	while ((i = getopt(argc, argv, "MmQqSsabC:cN:optT")) != EOF)
@


1.5
log
@one incorrect variable; jin@@george.lbl.gov via freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.4 1996/06/26 05:34:37 deraadt Exp $	*/
d195 2
a196 1
	if (namelist != NULL || core != NULL)
d198 1
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: ipcs.c,v 1.10.6.1 1996/06/07 01:53:47 thorpej Exp $	*/
d343 1
a343 1
			    msginfo.msgmni);
@


1.3
log
@sync
@
text
@d1 1
@


1.2
log
@revoke privs before opening kvm if user has specified mem/kernel paths
@
text
@d1 1
a1 1
/*	$NetBSD: ipcs.c,v 1.10 1995/04/15 02:22:40 cgd Exp $	*/
a32 10
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <paths.h>
#include <nlist.h>
#include <kvm.h>
#include <err.h>

d35 1
d42 12
d55 1
a55 1
int	semconfig __P((int,...));
d58 2
d137 1
d216 2
a217 1
	    kvm_read(kd, symbols[X_MSGINFO].n_value, &msginfo, sizeof(msginfo))) {
d237 13
a249 3
			kvm_read(kd, symbols[X_MSQIDS].n_value, &msqids, sizeof(msqids));
			xmsqids = malloc(sizeof(struct msqid_ds) * msginfo.msgmni);
			kvm_read(kd, (u_long) msqids, xmsqids, sizeof(struct msqid_ds) * msginfo.msgmni);
d317 3
a319 1
	    kvm_read(kd, symbols[X_SHMINFO].n_value, &shminfo, sizeof(shminfo))) {
d336 13
a348 4
			kvm_read(kd, symbols[X_SHMSEGS].n_value, &shmsegs, sizeof(shmsegs));
			xshmids = malloc(sizeof(struct shmid_ds) * msginfo.msgmni);
			kvm_read(kd, (u_long) shmsegs, xshmids, sizeof(struct shmid_ds) *
			    shminfo.shmmni);
d415 2
a416 1
	    kvm_read(kd, symbols[X_SEMINFO].n_value, &seminfo, sizeof(seminfo))) {
d448 13
a460 3
			kvm_read(kd, symbols[X_SEMA].n_value, &sema, sizeof(sema));
			xsema = malloc(sizeof(struct semid_ds) * seminfo.semmni);
			kvm_read(kd, (u_long) sema, xsema, sizeof(struct semid_ds) * seminfo.semmni);
d524 2
a525 1
	    "usage: ipcs [-abcmopqst] [-C corefile] [-N namelist]\n");
@


1.1
log
@Initial revision
@
text
@d184 6
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
