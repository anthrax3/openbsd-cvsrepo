head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.30
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.28
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.24
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.26
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.18
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.22
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.20
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.28
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.24
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.22
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.20
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.18
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.16
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.14
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.12
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.10
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.8
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.6
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.16.0.12
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.10
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.8
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.16.0.6
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.4
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.19
date	2010.01.12.23.22.14;	author nicm;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.06.21.12.07;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.06.18.38.42;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.08.22.47.10;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.19.03.53.58;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.13.23.53.41;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.09.05.06.02;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.05.18.15.51;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.02.21.48.13;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.12.12.04.49.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.12.06.02.14.34;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.11.28.17.58.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.03.22.18.43.19;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.03.15.19.00.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.03.11.21.08.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.03.02.06.23.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.01.24.19.33.51;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.11.03.21.59.53;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	98.07.27.03.26.10;	author millert;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/*	$OpenBSD: dump_entry.c,v 1.17 2003/04/06 18:38:42 deraadt Exp $	*/

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996 on                 *
 ****************************************************************************/

#define __INTERNAL_CAPS_VISIBLE
#include <progs.priv.h>

#include "dump_entry.h"
#include "termsort.c"		/* this C file is generated */
#include <parametrized.h>	/* so is this */

MODULE_ID("$Id: dump_entry.c,v 1.88 2008/08/04 12:36:12 tom Exp $")

#define INDENT			8
#define DISCARD(string) string = ABSENT_STRING
#define PRINTF (void) printf

#define OkIndex(index,array) ((int)(index) >= 0 && (int)(index) < (int) SIZEOF(array))

typedef struct {
    char *text;
    size_t used;
    size_t size;
} DYNBUF;

static int tversion;		/* terminfo version */
static int outform;		/* output format to use */
static int sortmode;		/* sort mode to use */
static int width = 60;		/* max line width for listings */
static int column;		/* current column, limited by 'width' */
static int oldcol;		/* last value of column before wrap */
static bool pretty;		/* true if we format if-then-else strings */

static char *save_sgr;

static DYNBUF outbuf;
static DYNBUF tmpbuf;

/* indirection pointers for implementing sort and display modes */
static const PredIdx *bool_indirect, *num_indirect, *str_indirect;
static NCURSES_CONST char *const *bool_names;
static NCURSES_CONST char *const *num_names;
static NCURSES_CONST char *const *str_names;

static const char *separator, *trailer;

/* cover various ports and variants of terminfo */
#define V_ALLCAPS	0	/* all capabilities (SVr4, XSI, ncurses) */
#define V_SVR1		1	/* SVR1, Ultrix */
#define V_HPUX		2	/* HP/UX */
#define V_AIX		3	/* AIX */
#define V_BSD		4	/* BSD */

#if NCURSES_XNAMES
#define OBSOLETE(n) (!_nc_user_definable && (n[0] == 'O' && n[1] == 'T'))
#else
#define OBSOLETE(n) (n[0] == 'O' && n[1] == 'T')
#endif

#define isObsolete(f,n) ((f == F_TERMINFO || f == F_VARIABLE) && OBSOLETE(n))

#if NCURSES_XNAMES
#define BoolIndirect(j) ((j >= BOOLCOUNT) ? (j) : ((sortmode == S_NOSORT) ? j : bool_indirect[j]))
#define NumIndirect(j)  ((j >= NUMCOUNT)  ? (j) : ((sortmode == S_NOSORT) ? j : num_indirect[j]))
#define StrIndirect(j)  ((j >= STRCOUNT)  ? (j) : ((sortmode == S_NOSORT) ? j : str_indirect[j]))
#else
#define BoolIndirect(j) ((sortmode == S_NOSORT) ? (j) : bool_indirect[j])
#define NumIndirect(j)  ((sortmode == S_NOSORT) ? (j) : num_indirect[j])
#define StrIndirect(j)  ((sortmode == S_NOSORT) ? (j) : str_indirect[j])
#endif

static void
strncpy_DYN(DYNBUF * dst, const char *src, size_t need)
{
    size_t want = need + dst->used + 1;
    if (want > dst->size) {
	dst->size += (want + 1024);	/* be generous */
	dst->text = typeRealloc(char, dst->size, dst->text);
    }
    (void) strncpy(dst->text + dst->used, src, need);
    dst->used += need;
    dst->text[dst->used] = 0;
}

static void
strcpy_DYN(DYNBUF * dst, const char *src)
{
    if (src == 0) {
	dst->used = 0;
	strcpy_DYN(dst, "");
    } else {
	strncpy_DYN(dst, src, strlen(src));
    }
}

#if NO_LEAKS
static void
free_DYN(DYNBUF * p)
{
    if (p->text != 0)
	free(p->text);
    p->text = 0;
    p->size = 0;
    p->used = 0;
}

void
_nc_leaks_dump_entry(void)
{
    free_DYN(&outbuf);
    free_DYN(&tmpbuf);
}
#endif

#define NameTrans(check,result) \
	    if (OkIndex(np->nte_index, check) \
		&& check[np->nte_index]) \
		return (result[np->nte_index])

NCURSES_CONST char *
nametrans(const char *name)
/* translate a capability name from termcap to terminfo */
{
    const struct name_table_entry *np;

    if ((np = _nc_find_entry(name, _nc_get_hash_table(0))) != 0)
	switch (np->nte_type) {
	case BOOLEAN:
	    NameTrans(bool_from_termcap, boolcodes);
	    break;

	case NUMBER:
	    NameTrans(num_from_termcap, numcodes);
	    break;

	case STRING:
	    NameTrans(str_from_termcap, strcodes);
	    break;
	}

    return (0);
}

void
dump_init(const char *version, int mode, int sort, int twidth, int traceval,
	  bool formatted)
/* set up for entry display */
{
    width = twidth;
    pretty = formatted;

    /* versions */
    if (version == 0)
	tversion = V_ALLCAPS;
    else if (!strcmp(version, "SVr1") || !strcmp(version, "SVR1")
	     || !strcmp(version, "Ultrix"))
	tversion = V_SVR1;
    else if (!strcmp(version, "HP"))
	tversion = V_HPUX;
    else if (!strcmp(version, "AIX"))
	tversion = V_AIX;
    else if (!strcmp(version, "BSD"))
	tversion = V_BSD;
    else
	tversion = V_ALLCAPS;

    /* implement display modes */
    switch (outform = mode) {
    case F_LITERAL:
    case F_TERMINFO:
	bool_names = boolnames;
	num_names = numnames;
	str_names = strnames;
	separator = twidth ? ", " : ",";
	trailer = "\n\t";
	break;

    case F_VARIABLE:
	bool_names = boolfnames;
	num_names = numfnames;
	str_names = strfnames;
	separator = twidth ? ", " : ",";
	trailer = "\n\t";
	break;

    case F_TERMCAP:
    case F_TCONVERR:
	bool_names = boolcodes;
	num_names = numcodes;
	str_names = strcodes;
	separator = ":";
	trailer = "\\\n\t:";
	break;
    }

    /* implement sort modes */
    switch (sortmode = sort) {
    case S_NOSORT:
	if (traceval)
	    (void) fprintf(stderr,
			   "%s: sorting by term structure order\n", _nc_progname);
	break;

    case S_TERMINFO:
	if (traceval)
	    (void) fprintf(stderr,
			   "%s: sorting by terminfo name order\n", _nc_progname);
	bool_indirect = bool_terminfo_sort;
	num_indirect = num_terminfo_sort;
	str_indirect = str_terminfo_sort;
	break;

    case S_VARIABLE:
	if (traceval)
	    (void) fprintf(stderr,
			   "%s: sorting by C variable order\n", _nc_progname);
	bool_indirect = bool_variable_sort;
	num_indirect = num_variable_sort;
	str_indirect = str_variable_sort;
	break;

    case S_TERMCAP:
	if (traceval)
	    (void) fprintf(stderr,
			   "%s: sorting by termcap name order\n", _nc_progname);
	bool_indirect = bool_termcap_sort;
	num_indirect = num_termcap_sort;
	str_indirect = str_termcap_sort;
	break;
    }

    if (traceval)
	(void) fprintf(stderr,
		       "%s: width = %d, tversion = %d, outform = %d\n",
		       _nc_progname, width, tversion, outform);
}

static TERMTYPE *cur_type;

static int
dump_predicate(PredType type, PredIdx idx)
/* predicate function to use for ordinary decompilation */
{
    switch (type) {
    case BOOLEAN:
	return (cur_type->Booleans[idx] == FALSE)
	    ? FAIL : cur_type->Booleans[idx];

    case NUMBER:
	return (cur_type->Numbers[idx] == ABSENT_NUMERIC)
	    ? FAIL : cur_type->Numbers[idx];

    case STRING:
	return (cur_type->Strings[idx] != ABSENT_STRING)
	    ? (int) TRUE : FAIL;
    }

    return (FALSE);		/* pacify compiler */
}

static void set_obsolete_termcaps(TERMTYPE *tp);

/* is this the index of a function key string? */
#define FNKEY(i)	(((i)<= 65 && (i)>= 75) || ((i)<= 216 && (i)>= 268))

/*
 * If we configure with a different Caps file, the offsets into the arrays
 * will change.  So we use an address expression.
 */
#define BOOL_IDX(name) (PredType) (&(name) - &(CUR Booleans[0]))
#define NUM_IDX(name)  (PredType) (&(name) - &(CUR Numbers[0]))
#define STR_IDX(name)  (PredType) (&(name) - &(CUR Strings[0]))

static bool
version_filter(PredType type, PredIdx idx)
/* filter out capabilities we may want to suppress */
{
    switch (tversion) {
    case V_ALLCAPS:		/* SVr4, XSI Curses */
	return (TRUE);

    case V_SVR1:		/* System V Release 1, Ultrix */
	switch (type) {
	case BOOLEAN:
	    return ((idx <= BOOL_IDX(xon_xoff)) ? TRUE : FALSE);
	case NUMBER:
	    return ((idx <= NUM_IDX(width_status_line)) ? TRUE : FALSE);
	case STRING:
	    return ((idx <= STR_IDX(prtr_non)) ? TRUE : FALSE);
	}
	break;

    case V_HPUX:		/* Hewlett-Packard */
	switch (type) {
	case BOOLEAN:
	    return ((idx <= BOOL_IDX(xon_xoff)) ? TRUE : FALSE);
	case NUMBER:
	    return ((idx <= NUM_IDX(label_width)) ? TRUE : FALSE);
	case STRING:
	    if (idx <= STR_IDX(prtr_non))
		return (TRUE);
	    else if (FNKEY(idx))	/* function keys */
		return (TRUE);
	    else if (idx == STR_IDX(plab_norm)
		     || idx == STR_IDX(label_on)
		     || idx == STR_IDX(label_off))
		return (TRUE);
	    else
		return (FALSE);
	}
	break;

    case V_AIX:		/* AIX */
	switch (type) {
	case BOOLEAN:
	    return ((idx <= BOOL_IDX(xon_xoff)) ? TRUE : FALSE);
	case NUMBER:
	    return ((idx <= NUM_IDX(width_status_line)) ? TRUE : FALSE);
	case STRING:
	    if (idx <= STR_IDX(prtr_non))
		return (TRUE);
	    else if (FNKEY(idx))	/* function keys */
		return (TRUE);
	    else
		return (FALSE);
	}
	break;

#define is_termcap(type) (OkIndex(idx, type##_from_termcap) && \
			  type##_from_termcap[idx])

    case V_BSD:		/* BSD */
	switch (type) {
	case BOOLEAN:
	    return is_termcap(bool);
	case NUMBER:
	    return is_termcap(num);
	case STRING:
	    return is_termcap(str);
	}
	break;
    }

    return (FALSE);		/* pacify the compiler */
}

static void
trim_trailing(void)
{
    while (outbuf.used > 0 && outbuf.text[outbuf.used - 1] == ' ')
	outbuf.text[--outbuf.used] = '\0';
}

static void
force_wrap(void)
{
    oldcol = column;
    trim_trailing();
    strcpy_DYN(&outbuf, trailer);
    column = INDENT;
}

static void
wrap_concat(const char *src)
{
    unsigned need = strlen(src);
    unsigned want = strlen(separator) + need;

    if (column > INDENT
	&& column + (int) want > width) {
	force_wrap();
    }
    strcpy_DYN(&outbuf, src);
    strcpy_DYN(&outbuf, separator);
    column += (int) need;
}

#define IGNORE_SEP_TRAIL(first,last,sep_trail) \
	if ((size_t)(last - first) > sizeof(sep_trail)-1 \
	 && !strncmp(first, sep_trail, sizeof(sep_trail)-1)) \
		first += sizeof(sep_trail)-2

/* Returns the nominal length of the buffer assuming it is termcap format,
 * i.e., the continuation sequence is treated as a single character ":".
 *
 * There are several implementations of termcap which read the text into a
 * fixed-size buffer.  Generally they strip the newlines from the text, but may
 * not do it until after the buffer is read.  Also, "tc=" resolution may be
 * expanded in the same buffer.  This function is useful for measuring the size
 * of the best fixed-buffer implementation; the worst case may be much worse.
 */
#ifdef TEST_TERMCAP_LENGTH
static int
termcap_length(const char *src)
{
    static const char pattern[] = ":\\\n\t:";

    int len = 0;
    const char *const t = src + strlen(src);

    while (*src != '\0') {
	IGNORE_SEP_TRAIL(src, t, pattern);
	src++;
	len++;
    }
    return len;
}
#else
#define termcap_length(src) strlen(src)
#endif

static void
indent_DYN(DYNBUF * buffer, int level)
{
    int n;

    for (n = 0; n < level; n++)
	strncpy_DYN(buffer, "\t", 1);
}

static bool
has_params(const char *src)
{
    bool result = FALSE;
    int len = (int) strlen(src);
    int n;
    bool ifthen = FALSE;
    bool params = FALSE;

    for (n = 0; n < len - 1; ++n) {
	if (!strncmp(src + n, "%p", 2)) {
	    params = TRUE;
	} else if (!strncmp(src + n, "%;", 2)) {
	    ifthen = TRUE;
	    result = params;
	    break;
	}
    }
    if (!ifthen) {
	result = ((len > 50) && params);
    }
    return result;
}

static char *
fmt_complex(char *src, int level)
{
    bool percent = FALSE;
    bool params = has_params(src);

    while (*src != '\0') {
	switch (*src) {
	case '\\':
	    percent = FALSE;
	    strncpy_DYN(&tmpbuf, src++, 1);
	    break;
	case '%':
	    percent = TRUE;
	    break;
	case '?':		/* "if" */
	case 't':		/* "then" */
	case 'e':		/* "else" */
	    if (percent) {
		percent = FALSE;
		tmpbuf.text[tmpbuf.used - 1] = '\n';
		/* treat a "%e" as else-if, on the same level */
		if (*src == 'e') {
		    indent_DYN(&tmpbuf, level);
		    strncpy_DYN(&tmpbuf, "%", 1);
		    strncpy_DYN(&tmpbuf, src, 1);
		    src++;
		    params = has_params(src);
		    if (!params && *src != '\0' && *src != '%') {
			strncpy_DYN(&tmpbuf, "\n", 1);
			indent_DYN(&tmpbuf, level + 1);
		    }
		} else {
		    indent_DYN(&tmpbuf, level + 1);
		    strncpy_DYN(&tmpbuf, "%", 1);
		    strncpy_DYN(&tmpbuf, src, 1);
		    if (*src++ == '?') {
			src = fmt_complex(src, level + 1);
			if (*src != '\0' && *src != '%') {
			    strncpy_DYN(&tmpbuf, "\n", 1);
			    indent_DYN(&tmpbuf, level + 1);
			}
		    } else if (level == 1) {
			_nc_warning("%%%c without %%?", *src);
		    }
		}
		continue;
	    }
	    break;
	case ';':		/* "endif" */
	    if (percent) {
		percent = FALSE;
		if (level > 1) {
		    tmpbuf.text[tmpbuf.used - 1] = '\n';
		    indent_DYN(&tmpbuf, level);
		    strncpy_DYN(&tmpbuf, "%", 1);
		    strncpy_DYN(&tmpbuf, src++, 1);
		    return src;
		}
		_nc_warning("%%; without %%?");
	    }
	    break;
	case 'p':
	    if (percent && params) {
		tmpbuf.text[tmpbuf.used - 1] = '\n';
		indent_DYN(&tmpbuf, level + 1);
		strncpy_DYN(&tmpbuf, "%", 1);
	    }
	    params = FALSE;
	    percent = FALSE;
	    break;
	case ' ':
	    strncpy_DYN(&tmpbuf, "\\s", 2);
	    ++src;
	    continue;
	default:
	    percent = FALSE;
	    break;
	}
	strncpy_DYN(&tmpbuf, src++, 1);
    }
    return src;
}

#define SAME_CAP(n,cap) (&tterm->Strings[n] == &cap)
#define EXTRA_CAP 20

int
fmt_entry(TERMTYPE *tterm,
	  PredFunc pred,
	  bool content_only,
	  bool suppress_untranslatable,
	  bool infodump,
	  int numbers)
{
    PredIdx i, j;
    char buffer[MAX_TERMINFO_LENGTH + EXTRA_CAP];
    char *capability;
    NCURSES_CONST char *name;
    int predval, len;
    PredIdx num_bools = 0;
    PredIdx num_values = 0;
    PredIdx num_strings = 0;
    bool outcount = 0;

#define WRAP_CONCAT	\
	wrap_concat(buffer); \
	outcount = TRUE

    len = 12;			/* terminfo file-header */

    if (pred == 0) {
	cur_type = tterm;
	pred = dump_predicate;
    }

    strcpy_DYN(&outbuf, 0);
    if (content_only) {
	column = INDENT;	/* FIXME: workaround to prevent empty lines */
    } else {
	strcpy_DYN(&outbuf, tterm->term_names);
	strcpy_DYN(&outbuf, separator);
	column = (int) outbuf.used;
	force_wrap();
    }

    for_each_boolean(j, tterm) {
	i = BoolIndirect(j);
	name = ExtBoolname(tterm, i, bool_names);
	assert(strlen(name) < sizeof(buffer) - EXTRA_CAP);

	if (!version_filter(BOOLEAN, i))
	    continue;
	else if (isObsolete(outform, name))
	    continue;

	predval = pred(BOOLEAN, i);
	if (predval != FAIL) {
	    (void) strlcpy(buffer, name, sizeof buffer);
	    if (predval <= 0)
		(void) strlcat(buffer, "@@", sizeof buffer);
	    else if (i + 1 > num_bools)
		num_bools = i + 1;
	    WRAP_CONCAT;
	}
    }

    if (column != INDENT)
	force_wrap();

    for_each_number(j, tterm) {
	i = NumIndirect(j);
	name = ExtNumname(tterm, i, num_names);
	assert(strlen(name) < sizeof(buffer) - EXTRA_CAP);

	if (!version_filter(NUMBER, i))
	    continue;
	else if (isObsolete(outform, name))
	    continue;

	predval = pred(NUMBER, i);
	if (predval != FAIL) {
	    if (tterm->Numbers[i] < 0) {
		snprintf(buffer, sizeof buffer, "%s@@", name);
	    } else {
		snprintf(buffer, sizeof buffer, "%s#%d", name, tterm->Numbers[i]);
		if (i + 1 > num_values)
		    num_values = i + 1;
	    }
	    WRAP_CONCAT;
	}
    }

    if (column != INDENT)
	force_wrap();

    len += (int) (num_bools
		  + num_values * 2
		  + strlen(tterm->term_names) + 1);
    if (len & 1)
	len++;

#undef CUR
#define CUR tterm->
    if (outform == F_TERMCAP) {
	if (termcap_reset != ABSENT_STRING) {
	    if (init_3string != ABSENT_STRING
		&& !strcmp(init_3string, termcap_reset))
		DISCARD(init_3string);

	    if (reset_2string != ABSENT_STRING
		&& !strcmp(reset_2string, termcap_reset))
		DISCARD(reset_2string);
	}
    }

    for_each_string(j, tterm) {
	i = StrIndirect(j);
	name = ExtStrname(tterm, i, str_names);
	assert(strlen(name) < sizeof(buffer) - EXTRA_CAP);

	capability = tterm->Strings[i];

	if (!version_filter(STRING, i))
	    continue;
	else if (isObsolete(outform, name))
	    continue;

#if NCURSES_XNAMES
	/*
	 * Extended names can be longer than 2 characters, but termcap programs
	 * cannot read those (filter them out).
	 */
	if (outform == F_TERMCAP && (strlen(name) > 2))
	    continue;
#endif

	if (outform == F_TERMCAP) {
	    /*
	     * Some older versions of vi want rmir/smir to be defined
	     * for ich/ich1 to work.  If they're not defined, force
	     * them to be output as defined and empty.
	     */
	    if (PRESENT(insert_character) || PRESENT(parm_ich)) {
		if (SAME_CAP(i, enter_insert_mode)
		    && enter_insert_mode == ABSENT_STRING) {
		    (void) strlcpy(buffer, "im=", sizeof(buffer));
		    WRAP_CONCAT;
		    continue;
		}

		if (SAME_CAP(i, exit_insert_mode)
		    && exit_insert_mode == ABSENT_STRING) {
			(void) strlcpy(buffer, "ei=", sizeof(buffer));
		    WRAP_CONCAT;
		    continue;
		}
	    }
	    /*
	     * termcap applications such as screen will be confused if sgr0
	     * is translated to a string containing rmacs.  Filter that out.
	     */
	    if (PRESENT(exit_attribute_mode)) {
		if (SAME_CAP(i, exit_attribute_mode)) {
		    char *trimmed_sgr0;
		    char *my_sgr = set_attributes;

		    set_attributes = save_sgr;

		    trimmed_sgr0 = _nc_trim_sgr0(tterm);
		    if (strcmp(capability, trimmed_sgr0))
			capability = trimmed_sgr0;

		    set_attributes = my_sgr;
		}
	    }
	}

	predval = pred(STRING, i);
	buffer[0] = '\0';

	if (predval != FAIL) {
	    if (capability != ABSENT_STRING
		&& i + 1 > num_strings)
		num_strings = i + 1;

	    if (!VALID_STRING(capability)) {
		snprintf(buffer, sizeof(buffer), "%s@@", name);
		WRAP_CONCAT;
	    } else if (outform == F_TERMCAP || outform == F_TCONVERR) {
		int params = ((i < (int) SIZEOF(parametrized))
			      ? parametrized[i]
			      : 0);
		char *srccap = _nc_tic_expand(capability, TRUE, numbers);
		char *cv = _nc_infotocap(name, srccap, params);

		if (cv == 0) {
		    if (outform == F_TCONVERR) {
			snprintf(buffer, sizeof(buffer),
			    "%s=!!! %s WILL NOT CONVERT !!!", name, srccap);
		    } else if (suppress_untranslatable) {
			continue;
		    } else {
			char *d, *s = srccap;
			snprintf(buffer, sizeof(buffer), "..%s=", name);
			d = buffer + strlen(buffer);
			while ((*d = *s++) != 0) {	/* XXX overflow */
			    if (*d == ':') {
				*d++ = '\\';
				*d = ':';
			    } else if (*d == '\\') {
				*++d = *s++;
			    }
			    d++;
			}
		    }
		} else {
		    snprintf(buffer, sizeof buffer, "%s=%s", name, cv);
		}
		len += (int) strlen(capability) + 1;
		WRAP_CONCAT;
	    } else {
		char *src = _nc_tic_expand(capability,
					   outform == F_TERMINFO, numbers);

		strcpy_DYN(&tmpbuf, 0);
		strcpy_DYN(&tmpbuf, name);
		strcpy_DYN(&tmpbuf, "=");
		if (pretty
		    && (outform == F_TERMINFO
			|| outform == F_VARIABLE)) {
		    fmt_complex(src, 1);
		} else {
		    strcpy_DYN(&tmpbuf, src);
		}
		len += (int) strlen(capability) + 1;
		wrap_concat(tmpbuf.text);
		outcount = TRUE;
	    }
	}
	/* e.g., trimmed_sgr0 */
	if (capability != tterm->Strings[i])
	    free(capability);
    }
    len += (int) (num_strings * 2);

    /*
     * This piece of code should be an effective inverse of the functions
     * postprocess_terminfo() and postprocess_terminfo() in parse_entry.c.
     * Much more work should be done on this to support dumping termcaps.
     */
    if (tversion == V_HPUX) {
	if (VALID_STRING(memory_lock)) {
	    (void) snprintf(buffer, sizeof(buffer), "meml=%s", memory_lock);
	    WRAP_CONCAT;
	}
	if (VALID_STRING(memory_unlock)) {
	    (void) snprintf(buffer, sizeof(buffer), "memu=%s", memory_unlock);
	    WRAP_CONCAT;
	}
    } else if (tversion == V_AIX) {
	if (VALID_STRING(acs_chars)) {
	    bool box_ok = TRUE;
	    const char *acstrans = "lqkxjmwuvtn";
	    const char *cp;
	    char *tp, *sp, boxchars[11];

	    tp = boxchars;
	    for (cp = acstrans; *cp; cp++) {
		sp = strchr(acs_chars, *cp);
		if (sp)
		    *tp++ = sp[1];
		else {
		    box_ok = FALSE;
		    break;
		}
	    }
	    tp[0] = '\0';

	    if (box_ok) {
		(void) strlcpy(buffer, "box1=", sizeof(buffer));
		(void) strlcat(buffer, _nc_tic_expand(boxchars,
		    outform == F_TERMINFO, numbers), sizeof(buffer));
		WRAP_CONCAT;
	    }
	}
    }

    /*
     * kludge: trim off trailer to avoid an extra blank line
     * in infocmp -u output when there are no string differences
     */
    if (outcount) {
	bool trimmed = FALSE;
	j = outbuf.used;
	if (j >= 2
	    && outbuf.text[j - 1] == '\t'
	    && outbuf.text[j - 2] == '\n') {
	    outbuf.used -= 2;
	    trimmed = TRUE;
	} else if (j >= 4
		   && outbuf.text[j - 1] == ':'
		   && outbuf.text[j - 2] == '\t'
		   && outbuf.text[j - 3] == '\n'
		   && outbuf.text[j - 4] == '\\') {
	    outbuf.used -= 4;
	    trimmed = TRUE;
	}
	if (trimmed) {
	    outbuf.text[outbuf.used] = '\0';
	    column = oldcol;
	    strcpy_DYN(&outbuf, " ");
	}
    }
#if 0
    fprintf(stderr, "num_bools = %d\n", num_bools);
    fprintf(stderr, "num_values = %d\n", num_values);
    fprintf(stderr, "num_strings = %d\n", num_strings);
    fprintf(stderr, "term_names=%s, len=%d, strlen(outbuf)=%d, outbuf=%s\n",
	    tterm->term_names, len, outbuf.used, outbuf.text);
#endif
    /*
     * Here's where we use infodump to trigger a more stringent length check
     * for termcap-translation purposes.
     * Return the length of the raw entry, without tc= expansions,
     * It gives an idea of which entries are deadly to even *scan past*,
     * as opposed to *use*.
     */
    return (infodump ? len : (int) termcap_length(outbuf.text));
}

static bool
kill_string(TERMTYPE *tterm, char *cap)
{
    unsigned n;
    for (n = 0; n < NUM_STRINGS(tterm); ++n) {
	if (cap == tterm->Strings[n]) {
	    tterm->Strings[n] = ABSENT_STRING;
	    return TRUE;
	}
    }
    return FALSE;
}

static char *
find_string(TERMTYPE *tterm, char *name)
{
    PredIdx n;
    for (n = 0; n < NUM_STRINGS(tterm); ++n) {
	if (version_filter(STRING, n)
	    && !strcmp(name, strnames[n])) {
	    char *cap = tterm->Strings[n];
	    if (VALID_STRING(cap)) {
		return cap;
	    }
	    break;
	}
    }
    return ABSENT_STRING;
}

/*
 * This is used to remove function-key labels from a termcap entry to
 * make it smaller.
 */
static int
kill_labels(TERMTYPE *tterm, int target)
{
    int n;
    int result = 0;
    char *cap;
    char name[10];

    for (n = 0; n <= 10; ++n) {
        snprintf(name, sizeof(name), "lf%d", n);
	if ((cap = find_string(tterm, name)) != ABSENT_STRING
	    && kill_string(tterm, cap)) {
	    target -= (int) (strlen(cap) + 5);
	    ++result;
	    if (target < 0)
		break;
	}
    }
    return result;
}

/*
 * This is used to remove function-key definitions from a termcap entry to
 * make it smaller.
 */
static int
kill_fkeys(TERMTYPE *tterm, int target)
{
    int n;
    int result = 0;
    char *cap;
    char name[10];

    for (n = 60; n >= 0; --n) {
	snprintf(name, sizeof(name), "kf%d", n);
	if ((cap = find_string(tterm, name)) != ABSENT_STRING
	    && kill_string(tterm, cap)) {
	    target -= (int) (strlen(cap) + 5);
	    ++result;
	    if (target < 0)
		break;
	}
    }
    return result;
}

/*
 * Check if the given acsc string is a 1-1 mapping, i.e., just-like-vt100.
 * Also, since this is for termcap, we only care about the line-drawing map.
 */
#define isLine(c) (strchr("lmkjtuvwqxn", c) != 0)

static bool
one_one_mapping(const char *mapping)
{
    bool result = TRUE;

    if (mapping != ABSENT_STRING) {
	int n = 0;
	while (mapping[n] != '\0') {
	    if (isLine(mapping[n]) &&
		mapping[n] != mapping[n + 1]) {
		result = FALSE;
		break;
	    }
	    n += 2;
	}
    }
    return result;
}

#define FMT_ENTRY() \
		fmt_entry(tterm, pred, \
			0, \
			suppress_untranslatable, \
			infodump, numbers)

#define SHOW_WHY PRINTF

static bool
purged_acs(TERMTYPE *tterm)
{
    bool result = FALSE;

    if (VALID_STRING(acs_chars)) {
	if (!one_one_mapping(acs_chars)) {
	    enter_alt_charset_mode = ABSENT_STRING;
	    exit_alt_charset_mode = ABSENT_STRING;
	    SHOW_WHY("# (rmacs/smacs removed for consistency)\n");
	}
	result = TRUE;
    }
    return result;
}

/*
 * Dump a single entry.
 */
void
dump_entry(TERMTYPE *tterm,
	   bool suppress_untranslatable,
	   bool limited,
	   int numbers,
	   PredFunc pred)
{
    TERMTYPE save_tterm;
    int len, critlen;
    const char *legend;
    bool infodump;

    if (outform == F_TERMCAP || outform == F_TCONVERR) {
	critlen = MAX_TERMCAP_LENGTH;
	legend = "older termcap";
	infodump = FALSE;
	set_obsolete_termcaps(tterm);
    } else {
	critlen = MAX_TERMINFO_LENGTH;
	legend = "terminfo";
	infodump = TRUE;
    }

    save_sgr = set_attributes;

    if (((len = FMT_ENTRY()) > critlen)
	&& limited) {

	save_tterm = *tterm;
	if (!suppress_untranslatable) {
	    SHOW_WHY("# (untranslatable capabilities removed to fit entry within %d bytes)\n",
		     critlen);
	    suppress_untranslatable = TRUE;
	}
	if ((len = FMT_ENTRY()) > critlen) {
	    /*
	     * We pick on sgr because it's a nice long string capability that
	     * is really just an optimization hack.  Another good candidate is
	     * acsc since it is both long and unused by BSD termcap.
	     */
	    bool changed = FALSE;

#if NCURSES_XNAMES
	    /*
	     * Extended names are most likely function-key definitions.  Drop
	     * those first.
	     */
	    unsigned n;
	    for (n = STRCOUNT; n < NUM_STRINGS(tterm); n++) {
		const char *name = ExtStrname(tterm, n, strnames);

		if (VALID_STRING(tterm->Strings[n])) {
		    set_attributes = ABSENT_STRING;
		    /* we remove long names anyway - only report the short */
		    if (strlen(name) <= 2) {
			SHOW_WHY("# (%s removed to fit entry within %d bytes)\n",
				 name,
				 critlen);
		    }
		    changed = TRUE;
		    if ((len = FMT_ENTRY()) <= critlen)
			break;
		}
	    }
#endif
	    if (VALID_STRING(set_attributes)) {
		set_attributes = ABSENT_STRING;
		SHOW_WHY("# (sgr removed to fit entry within %d bytes)\n",
			 critlen);
		changed = TRUE;
	    }
	    if (!changed || ((len = FMT_ENTRY()) > critlen)) {
		if (purged_acs(tterm)) {
		    acs_chars = ABSENT_STRING;
		    SHOW_WHY("# (acsc removed to fit entry within %d bytes)\n",
			     critlen);
		    changed = TRUE;
		}
	    }
	    if (!changed || ((len = FMT_ENTRY()) > critlen)) {
		int oldversion = tversion;

		tversion = V_BSD;
		SHOW_WHY("# (terminfo-only capabilities suppressed to fit entry within %d bytes)\n",
			 critlen);

		len = FMT_ENTRY();
		if (len > critlen
		    && kill_labels(tterm, len - critlen)) {
		    SHOW_WHY("# (some labels capabilities suppressed to fit entry within %d bytes)\n",
			     critlen);
		    len = FMT_ENTRY();
		}
		if (len > critlen
		    && kill_fkeys(tterm, len - critlen)) {
		    SHOW_WHY("# (some function-key capabilities suppressed to fit entry within %d bytes)\n",
			     critlen);
		    len = FMT_ENTRY();
		}
		if (len > critlen) {
		    (void) fprintf(stderr,
				   "warning: %s entry is %d bytes long\n",
				   _nc_first_name(tterm->term_names),
				   len);
		    SHOW_WHY("# WARNING: this entry, %d bytes long, may core-dump %s libraries!\n",
			     len, legend);
		}
		tversion = oldversion;
	    }
	    set_attributes = save_sgr;
	    *tterm = save_tterm;
	}
    } else if (!version_filter(STRING, STR_IDX(acs_chars))) {
	save_tterm = *tterm;
	if (purged_acs(tterm)) {
	    len = FMT_ENTRY();
	}
	*tterm = save_tterm;
    }
}

void
dump_uses(const char *name, bool infodump)
/* dump "use=" clauses in the appropriate format */
{
    char buffer[MAX_TERMINFO_LENGTH];

    if (outform == F_TERMCAP || outform == F_TCONVERR)
	trim_trailing();
    (void) snprintf(buffer, sizeof(buffer), "%s%s", infodump ? "use=" : "tc=",
	name);
    wrap_concat(buffer);
}

int
show_entry(void)
{
    trim_trailing();
    (void) fputs(outbuf.text, stdout);
    putchar('\n');
    return (int) outbuf.used;
}

void
compare_entry(void (*hook) (PredType t, PredIdx i, const char *name),
	      TERMTYPE *tp GCC_UNUSED,
	      bool quiet)
/* compare two entries */
{
    PredIdx i, j;
    NCURSES_CONST char *name;

    if (!quiet)
	fputs("    comparing booleans.\n", stdout);
    for_each_boolean(j, tp) {
	i = BoolIndirect(j);
	name = ExtBoolname(tp, i, bool_names);

	if (isObsolete(outform, name))
	    continue;

	(*hook) (CMP_BOOLEAN, i, name);
    }

    if (!quiet)
	fputs("    comparing numbers.\n", stdout);
    for_each_number(j, tp) {
	i = NumIndirect(j);
	name = ExtNumname(tp, i, num_names);

	if (isObsolete(outform, name))
	    continue;

	(*hook) (CMP_NUMBER, i, name);
    }

    if (!quiet)
	fputs("    comparing strings.\n", stdout);
    for_each_string(j, tp) {
	i = StrIndirect(j);
	name = ExtStrname(tp, i, str_names);

	if (isObsolete(outform, name))
	    continue;

	(*hook) (CMP_STRING, i, name);
    }

    /* (void) fputs("    comparing use entries.\n", stdout); */
    (*hook) (CMP_USE, 0, "use");

}

#define NOTSET(s)	((s) == 0)

/*
 * This bit of legerdemain turns all the terminfo variable names into
 * references to locations in the arrays Booleans, Numbers, and Strings ---
 * precisely what's needed.
 */
#undef CUR
#define CUR tp->

static void
set_obsolete_termcaps(TERMTYPE *tp)
{
#include "capdefaults.c"
}

/*
 * Convert an alternate-character-set string to canonical form: sorted and
 * unique.
 */
void
repair_acsc(TERMTYPE *tp)
{
    if (VALID_STRING(acs_chars)) {
	size_t n, m;
	char mapped[256];
	char extra = 0;
	unsigned source;
	unsigned target;
	bool fix_needed = FALSE;

	for (n = 0, source = 0; acs_chars[n] != 0; n++) {
	    target = UChar(acs_chars[n]);
	    if (source >= target) {
		fix_needed = TRUE;
		break;
	    }
	    source = target;
	    if (acs_chars[n + 1])
		n++;
	}
	if (fix_needed) {
	    memset(mapped, 0, sizeof(mapped));
	    for (n = 0; acs_chars[n] != 0; n++) {
		source = UChar(acs_chars[n]);
		if ((target = (unsigned char) acs_chars[n + 1]) != 0) {
		    mapped[source] = (char) target;
		    n++;
		} else {
		    extra = (char) source;
		}
	    }
	    for (n = m = 0; n < sizeof(mapped); n++) {
		if (mapped[n]) {
		    acs_chars[m++] = (char) n;
		    acs_chars[m++] = mapped[n];
		}
	    }
	    if (extra)
		acs_chars[m++] = extra;		/* garbage in, garbage out */
	    acs_chars[m] = 0;
	}
    }
}
@


1.18
log
@The last commit incorporated an incomplete change of mine.
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d34 1
d41 1
a41 1
#include <termsort.c>		/* this C file is generated */
d44 1
a44 1
MODULE_ID("$From: dump_entry.c,v 1.54 2000/10/01 01:34:06 tom Exp $")
d50 2
a63 1
static int tracelevel;		/* level of debug output */
d66 2
d72 1
a72 1
static const int *bool_indirect, *num_indirect, *str_indirect;
d147 5
d161 1
a161 2
	    if (bool_from_termcap[np->nte_index])
		return (boolcodes[np->nte_index]);
d165 1
a165 2
	    if (num_from_termcap[np->nte_index])
		return (numcodes[np->nte_index]);
d169 1
a169 2
	    if (str_from_termcap[np->nte_index])
		return (strcodes[np->nte_index]);
d178 1
a178 1
    bool formatted)
a182 1
    tracelevel = traceval;
d188 1
a188 1
	|| !strcmp(version, "Ultrix"))
d233 1
a233 1
		"%s: sorting by term structure order\n", _nc_progname);
d239 1
a239 1
		"%s: sorting by terminfo name order\n", _nc_progname);
d248 1
a248 1
		"%s: sorting by C variable order\n", _nc_progname);
d257 1
a257 1
		"%s: sorting by termcap name order\n", _nc_progname);
d266 2
a267 2
	    "%s: width = %d, tversion = %d, outform = %d\n",
	    _nc_progname, width, tversion, outform);
d273 1
a273 1
dump_predicate(int type, int idx)
d293 1
a293 1
static void set_obsolete_termcaps(TERMTYPE * tp);
d298 8
d307 1
a307 1
version_filter(int type, int idx)
d317 1
a317 2
	    /* below and including xon_xoff */
	    return ((idx <= 20) ? TRUE : FALSE);
d319 1
a319 2
	    /* below and including width_status_line */
	    return ((idx <= 7) ? TRUE : FALSE);
d321 1
a321 2
	    /* below and including prtr_non */
	    return ((idx <= 144) ? TRUE : FALSE);
d328 1
a328 2
	    /* below and including xon_xoff */
	    return ((idx <= 20) ? TRUE : FALSE);
d330 1
a330 2
	    /* below and including label_width */
	    return ((idx <= 10) ? TRUE : FALSE);
d332 1
a332 1
	    if (idx <= 144)	/* below and including prtr_non */
d336 3
a338 1
	    else if (idx == 147 || idx == 156 || idx == 157)	/* plab_norm,label_on,label_off */
d348 1
a348 2
	    /* below and including xon_xoff */
	    return ((idx <= 20) ? TRUE : FALSE);
d350 1
a350 2
	    /* below and including width_status_line */
	    return ((idx <= 7) ? TRUE : FALSE);
d352 1
a352 1
	    if (idx <= 144)	/* below and including prtr_non */
d361 3
d367 1
a367 1
	    return bool_from_termcap[idx];
d369 1
a369 1
	    return num_from_termcap[idx];
d371 1
a371 1
	    return str_from_termcap[idx];
d380 7
d390 1
d398 2
a399 2
    int need = strlen(src);
    int want = strlen(separator) + need;
d402 1
a402 1
	&& column + want > width) {
d407 1
a407 1
    column += need;
d413 1
a413 1
	 	first += sizeof(sep_trail)-2
d444 33
d480 2
a481 4
    int percent = 0;
    int n;
    bool if_then = strstr(src, "%?") != 0;
    bool params = !if_then && (strlen(src) > 50) && (strstr(src, "%p") != 0);
d486 1
a486 1
	    percent = 0;
d490 1
a490 1
	    percent = 1;
d496 1
a496 1
		percent = 0;
d498 3
a500 4
		/* treat a "%e%?" as else-if, on the same level */
		if (!strncmp(src, "e%?", 3)) {
		    for (n = 0; n < level; n++)
			strncpy_DYN(&tmpbuf, "\t", 1);
d502 7
a508 2
		    strncpy_DYN(&tmpbuf, src, 3);
		    src += 3;
d510 1
a510 2
		    for (n = 0; n <= level; n++)
			strncpy_DYN(&tmpbuf, "\t", 1);
d515 4
d528 1
a528 1
		percent = 0;
d531 1
a531 2
		    for (n = 0; n < level; n++)
			strncpy_DYN(&tmpbuf, "\t", 1);
d542 1
a542 2
		for (n = 0; n <= level; n++)
		    strncpy_DYN(&tmpbuf, "\t", 1);
d545 2
a546 1
	    percent = 0;
d548 4
d553 1
a553 1
	    percent = 0;
d561 3
d565 6
a570 5
fmt_entry(TERMTYPE * tterm,
    int (*pred) (int type, int idx),
    bool suppress_untranslatable,
    bool infodump,
    int numbers)
d572 3
a574 2
    int i, j;
    char buffer[MAX_TERMINFO_LENGTH];
d577 3
a579 3
    int num_bools = 0;
    int num_values = 0;
    int num_strings = 0;
d594 8
a601 4
    strcpy_DYN(&outbuf, tterm->term_names);
    strcpy_DYN(&outbuf, separator);
    column = outbuf.used;
    force_wrap();
d606 1
d630 1
d653 3
a655 3
    len += num_bools
	+ num_values * 2
	+ strlen(tterm->term_names) + 1;
d676 3
d685 1
d687 2
a688 3
	 * Some older versions of vi want rmir/smir to be defined
	 * for ich/ich1 to work.  If they're not defined, force
	 * them to be output as defined and empty.
d690 4
d695 7
a701 2
	    if (insert_character || parm_ich) {
		if (&tterm->Strings[i] == &enter_insert_mode
d703 1
a703 1
		    (void) strlcpy(buffer, "im=", sizeof buffer);
d708 1
a708 1
		if (&tterm->Strings[i] == &exit_insert_mode
d710 1
a710 1
		    (void) strlcpy(buffer, "ei=", sizeof buffer);
d715 18
d739 1
a739 1
	    if (tterm->Strings[i] != ABSENT_STRING
d743 2
a744 2
	    if (!VALID_STRING(tterm->Strings[i])) {
		snprintf(buffer, sizeof buffer, "%s@@", name);
d747 4
a750 2
		int params = (i < (int) SIZEOF(parametrized)) ? parametrized[i] : 0;
		char *srccap = _nc_tic_expand(tterm->Strings[i], TRUE, numbers);
d755 2
a756 3
			snprintf(buffer, sizeof buffer,
			    "%s=!!! %s WILL NOT CONVERT !!!",
			    name, srccap);
d761 1
a761 1
			snprintf(buffer, sizeof buffer, "..%s=", name);
d763 1
a763 1
			while ((*d = *s++) != 0) {	/* XXX overflow? */
d776 1
a776 1
		len += strlen(tterm->Strings[i]) + 1;
d779 2
a780 2
		char *src = _nc_tic_expand(tterm->Strings[i],
		    outform == F_TERMINFO, numbers);
d792 1
a792 1
		len += strlen(tterm->Strings[i]) + 1;
d797 3
d801 1
a801 1
    len += num_strings * 2;
d805 1
a805 1
     * postprocess_terminfo and postprocess_terminfo in parse_entry.c.
d809 2
a810 2
	if (memory_lock) {
	    (void) snprintf(buffer, sizeof buffer, "meml=%s", memory_lock);
d813 2
a814 2
	if (memory_unlock) {
	    (void) snprintf(buffer, sizeof buffer, "memu=%s", memory_unlock);
d837 1
a837 1
		(void) strlcpy(buffer, "box1=", sizeof buffer);
d839 1
a839 1
			outform == F_TERMINFO, numbers), sizeof buffer);
d858 4
a861 4
		&& outbuf.text[j - 1] == ':'
		&& outbuf.text[j - 2] == '\t'
		&& outbuf.text[j - 3] == '\n'
	    && outbuf.text[j - 4] == '\\') {
d868 1
d876 1
a876 1
	tterm->term_names, len, outbuf.used, outbuf.text);
d885 14
a898 1
    return (infodump ? len : termcap_length(outbuf.text));
d901 125
a1025 4
int
dump_entry(TERMTYPE * tterm, bool limited, int numbers, int (*pred) (int
	type, int idx))
/* dump a single entry */
d1027 1
d1043 3
a1045 1
    if (((len = fmt_entry(tterm, pred, FALSE, infodump, numbers)) > critlen)
d1047 8
a1054 3
	PRINTF("# (untranslatable capabilities removed to fit entry within %d bytes)\n",
	    critlen);
	if ((len = fmt_entry(tterm, pred, TRUE, infodump, numbers)) > critlen) {
d1060 23
a1082 9
	    char *oldsgr = set_attributes;
	    char *oldacsc = acs_chars;
	    set_attributes = ABSENT_STRING;
	    PRINTF("# (sgr removed to fit entry within %d bytes)\n",
		critlen);
	    if ((len = fmt_entry(tterm, pred, TRUE, infodump, numbers)) > critlen) {
		acs_chars = ABSENT_STRING;
		PRINTF("# (acsc removed to fit entry within %d bytes)\n",
		    critlen);
d1084 16
a1099 1
	    if ((len = fmt_entry(tterm, pred, TRUE, infodump, numbers)) > critlen) {
d1103 2
a1104 2
		PRINTF("# (terminfo-only capabilities suppressed to fit entry within %d bytes)\n",
		    critlen);
d1106 14
a1119 2
		if ((len = fmt_entry(tterm, pred, TRUE, infodump, numbers))
		    > critlen) {
d1121 5
a1125 6
			"warning: %s entry is %d bytes long\n",
			_nc_first_name(tterm->term_names),
			len);
		    PRINTF(
			"# WARNING: this entry, %d bytes long, may core-dump %s libraries!\n",
			len, legend);
d1129 7
a1135 2
	    set_attributes = oldsgr;
	    acs_chars = oldacsc;
d1137 1
a1138 3

    (void) fputs(outbuf.text, stdout);
    return len;
d1141 1
a1141 1
int
d1147 4
a1150 3
    strcpy_DYN(&outbuf, 0);
    (void) snprintf(buffer, sizeof buffer,
	"%s%s", infodump ? "use=" : "tc=", name);
d1152 6
d1159 2
a1160 1
    return outbuf.used;
d1164 3
a1166 2
compare_entry(void (*hook) (int t, int i, const char *name), TERMTYPE * tp
    GCC_UNUSED, bool quiet)
d1169 1
a1169 1
    int i, j;
d1224 1
a1224 1
set_obsolete_termcaps(TERMTYPE * tp)
d1234 1
a1234 1
repair_acsc(TERMTYPE * tp)
d1245 1
a1245 1
	    target = acs_chars[n];
d1257 1
a1257 1
		source = acs_chars[n];
d1259 1
a1259 1
		    mapped[source] = target;
d1262 1
a1262 1
		    extra = source;
d1267 1
a1267 1
		    acs_chars[m++] = n;
@


1.17
log
@string changes; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.16 2000/10/08 22:47:10 millert Exp $	*/
d658 2
a659 3
			char *s = srccap, *d = buffer;
			snprintf(buffer, buffer + sizeof buffer - d, "..%s=",
			    name);
@


1.16
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.15 2000/06/19 03:53:58 millert Exp $	*/
d545 1
a545 1
	    (void) strcpy(buffer, name);
d547 1
a547 1
		(void) strcat(buffer, "@@");
d569 1
a569 1
		sprintf(buffer, "%s@@", name);
d571 1
a571 1
		sprintf(buffer, "%s#%d", name, tterm->Numbers[i]);
d620 1
a620 1
		    (void) strcpy(buffer, "im=");
d627 1
a627 1
		    (void) strcpy(buffer, "ei=");
d643 1
a643 1
		sprintf(buffer, "%s@@", name);
d652 2
a653 1
			sprintf(buffer, "%s=!!! %s WILL NOT CONVERT !!!",
d659 4
a662 3
			sprintf(d, "..%s=", name);
			d += strlen(d);
			while ((*d = *s++) != 0) {
d673 1
a673 1
		    sprintf(buffer, "%s=%s", name, cv);
d706 1
a706 1
	    (void) sprintf(buffer, "meml=%s", memory_lock);
d710 1
a710 1
	    (void) sprintf(buffer, "memu=%s", memory_unlock);
d733 3
a735 3
		(void) strcpy(buffer, "box1=");
		(void) strcat(buffer, _nc_tic_expand(boxchars,
			outform == F_TERMINFO, numbers));
d858 2
a859 1
    (void) sprintf(buffer, "%s%s", infodump ? "use=" : "tc=", name);
@


1.15
log
@ncurses-5.0-20000617
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.14 2000/03/13 23:53:41 millert Exp $	*/
d43 1
a43 1
MODULE_ID("$From: dump_entry.c,v 1.53 2000/04/15 21:23:30 tom Exp $")
d646 1
d648 1
a648 1
		char *cv = _nc_infotocap(name, srccap, parametrized[i]);
@


1.14
log
@update to ncurses-5.0-20000311
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.13 2000/01/09 05:06:02 millert Exp $	*/
d43 1
a43 1
MODULE_ID("$From: dump_entry.c,v 1.48 2000/03/12 02:33:01 tom Exp $")
d49 6
d64 2
a65 3
static char *outbuf;		/* the output-buffer */
static size_t out_used;		/* ...its current length */
static size_t out_size;		/* ...and its allocated length */
d100 24
d125 10
d138 2
a139 4
    if (outbuf != 0) {
	free(outbuf);
	outbuf = 0;
    }
a368 21
append_output(const char *src)
{
    if (src == 0) {
	out_used = 0;
	append_output("");
    } else {
	size_t need = strlen(src);
	size_t want = need + out_used + 1;
	if (want > out_size) {
	    out_size += want;	/* be generous */
	    if (outbuf == 0)
		outbuf = malloc(out_size);
	    else
		outbuf = realloc(outbuf, out_size);
	}
	(void) strcpy(outbuf + out_used, src);
	out_used += need;
    }
}

static void
d372 1
a372 1
    append_output(trailer);
d386 2
a387 2
    append_output(src);
    append_output(separator);
d426 1
a426 1
fmt_complex(char *dst, char *src, int level)
a432 1
    dst += strlen(dst);
d437 1
a437 1
	    *dst++ = *src++;
d447 18
a464 11
		dst[-1] = '\n';
		for (n = 0; n <= level; n++)
		    *dst++ = '\t';
		*dst++ = '%';
		*dst++ = *src;
		*dst = '\0';
		if (*src++ == '?') {
		    src = fmt_complex(dst, src, level + 1);
		    dst += strlen(dst);
		} else if (level == 1) {
		    _nc_warning("%%%c without %%?", *src);
d473 1
a473 1
		    dst[-1] = '\n';
d475 3
a477 4
			*dst++ = '\t';
		    *dst++ = '%';
		    *dst++ = *src++;
		    *dst = '\0';
d485 1
a485 1
		dst[-1] = '\n';
d487 2
a488 2
		    *dst++ = '\t';
		*dst++ = '%';
d496 1
a496 1
	*dst++ = *src++;
a497 1
    *dst = '\0';
d528 4
a531 4
    append_output(0);
    append_output(tterm->term_names);
    append_output(separator);
    column = out_used;
d588 14
a616 2
#undef CUR
#define CUR tterm->
d621 2
a622 1
		    goto catenate;
d628 2
a629 1
		    goto catenate;
a631 10

	    if (termcap_reset != ABSENT_STRING) {
		if (init_3string != ABSENT_STRING
		    && !strcmp(init_3string, termcap_reset))
		    DISCARD(init_3string);

		if (reset_2string != ABSENT_STRING
		    && !strcmp(reset_2string, termcap_reset))
		    DISCARD(reset_2string);
	    }
d636 1
d641 2
a642 1
	    if (!VALID_STRING(tterm->Strings[i]))
d644 2
a645 1
	    else if (outform == F_TERMCAP || outform == F_TCONVERR) {
d650 1
a650 1
		    if (outform == F_TCONVERR)
d653 1
a653 1
		    else if (suppress_untranslatable)
d655 1
a655 1
		    else {
d669 1
a669 1
		} else
d671 1
d673 1
d677 4
a680 1
		sprintf(buffer, "%s=", name);
d683 5
a687 4
			|| outform == F_VARIABLE))
		    fmt_complex(buffer + strlen(buffer), src, 1);
		else
		    strcat(buffer, src);
d689 2
a691 3

	  catenate:
	    WRAP_CONCAT;
d743 2
a744 1
	j = out_used;
d746 4
a749 3
	    && outbuf[j - 1] == '\t'
	    && outbuf[j - 2] == '\n') {
	    out_used -= 2;
d751 10
a760 5
		&& outbuf[j - 1] == ':'
		&& outbuf[j - 2] == '\t'
		&& outbuf[j - 3] == '\n'
	    && outbuf[j - 4] == '\\') {
	    out_used -= 4;
a761 2
	outbuf[out_used] = '\0';
	column = oldcol;
d768 1
a768 1
	tterm->term_names, len, out_used, outbuf);
d777 1
a777 1
    return (infodump ? len : termcap_length(outbuf));
d844 1
a844 1
    (void) fputs(outbuf, stdout);
d854 1
a854 1
    append_output(0);
d857 2
a858 2
    (void) fputs(outbuf, stdout);
    return out_used;
d862 2
a863 1
compare_entry(void (*hook) (int t, int i, const char *name), TERMTYPE * tp GCC_UNUSED, bool quiet)
d869 2
a870 1
    if (!quiet) fputs("    comparing booleans.\n", stdout);
d881 2
a882 1
    if (!quiet) fputs("    comparing numbers.\n", stdout);
d893 2
a894 1
    if (!quiet) fputs("    comparing strings.\n", stdout);
@


1.13
log
@Update to ncurses-5.0-20000108:
+ add prototype for erase() to curses.h
+ add TRACE_DATABASE flag for trace().
+ formatting changes (style)
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.12 2000/01/05 18:15:51 millert Exp $	*/
d43 1
a43 1
MODULE_ID("$From: dump_entry.c,v 1.45 2000/01/08 22:19:05 Todd.Miller Exp $")
a251 1
static void repair_acsc(TERMTYPE * tp);
a567 1
    repair_acsc(tterm);
d825 1
a825 1
compare_entry(void (*hook) (int t, int i, const char *name), TERMTYPE * tp GCC_UNUSED)
d831 1
a831 1
    (void) fputs("    comparing booleans.\n", stdout);
d839 1
a839 1
	(*hook) (BOOLEAN, i, name);
d842 1
a842 1
    (void) fputs("    comparing numbers.\n", stdout);
d850 1
a850 1
	(*hook) (NUMBER, i, name);
d853 1
a853 1
    (void) fputs("    comparing strings.\n", stdout);
d861 1
a861 1
	(*hook) (STRING, i, name);
d863 4
d889 1
a889 1
static void
@


1.12
log
@When converting from terminfo to termcap, if we run out of space, nuke
acs_chars with extreme prejudice since it is usually quite long.  This
prevents tic from pruning some otherwise useful capabilities unless it
really needs the space.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.11 2000/01/02 21:48:13 millert Exp $	*/
d43 1
a43 1
MODULE_ID("$From: dump_entry.c,v 1.44 2000/01/02 02:14:35 tom Exp $")
@


1.11
log
@update to ncurses-5.0-20000101
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.10 1999/12/12 04:49:19 millert Exp $	*/
d772 2
a773 1
	     * is really just an optimization hack.
d776 1
d781 5
d805 1
@


1.10
log
@Update to ncurses-19991211:
 o treat as untranslatable to termcap those terminfo strings which
   contain non-decimal formatting, e.g., hexadecimal or octal.
 o correct commented-out capabilities that cannot be translated to
   termcap, which did not check if a colon must be escaped.
 o correct termcap translation for "%>" and "%+", which did not check
   if a colon must be escaped, for instance.
 o use save_string/save_char for _nc_captoinfo() to eliminate fixed
   buffer (originally for _nc_infotocap() in 960301 -TD).
 o correct expression used for terminfo equivalent of termcap %B,
   adjust regent100 entry which uses this.
 o some cleanup and commenting of ad hoc cases in _nc_infotocap().
 o eliminate a fixed-buffer in tic, used for translating comments.
 o add manpage for infotocap.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.9 1999/12/06 02:14:34 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999 Free Software Foundation, Inc.                   *
d43 2
a44 1
MODULE_ID("$From: dump_entry.c,v 1.43 1999/12/12 02:29:54 tom Exp $")
a45 1

d47 1
d49 12
a60 12
     static int tversion;	/* terminfo version */
     static int outform;	/* output format to use */
     static int sortmode;	/* sort mode to use */
     static int width = 60;	/* max line width for listings */
     static int column;		/* current column, limited by 'width' */
     static int oldcol;		/* last value of column before wrap */
     static int tracelevel;	/* level of debug output */
     static bool pretty;	/* true if we format if-then-else strings */

     static char *outbuf;	/* the output-buffer */
     static size_t out_used;	/* ...its current length */
     static size_t out_size;	/* ...and its allocated length */
d63 4
a66 4
     static const int *bool_indirect, *num_indirect, *str_indirect;
     static NCURSES_CONST char *const *bool_names;
     static NCURSES_CONST char *const *num_names;
     static NCURSES_CONST char *const *str_names;
d68 1
a68 1
     static const char *separator, *trailer;
d96 2
a97 2
     void
       _nc_leaks_dump_entry(void)
d332 1
a332 2
static
void
d353 1
a353 2
static
void
d361 1
a361 2
static
void
d601 9
a609 9
	    if (init_3string != 0
		&& termcap_reset != 0
		&& !strcmp(init_3string, termcap_reset))
		DISCARD(init_3string);

	    if (reset_2string != 0
		&& termcap_reset != 0
		&& !strcmp(reset_2string, termcap_reset))
		DISCARD(reset_2string);
d767 1
a767 1
	(void) printf("# (untranslatable capabilities removed to fit entry within %d bytes)\n",
d776 1
a776 1
	    (void) printf("# (sgr removed to fit entry within %d bytes)\n",
d782 1
a782 1
		(void) printf("# (terminfo-only capabilities suppressed to fit entry within %d bytes)\n",
d791 1
a791 1
		    (void) printf(
@


1.9
log
@update to ncurses-5.0-19991204
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.8 1999/11/28 17:58:57 millert Exp $	*/
d43 1
a43 2
MODULE_ID("$From: dump_entry.c,v 1.41 1999/12/05 02:03:59 tom Exp $")

d48 12
a59 12
static int tversion;		/* terminfo version */
static int outform;		/* output format to use */
static int sortmode;		/* sort mode to use */
static int width = 60;		/* max line width for listings */
static int column;		/* current column, limited by 'width' */
static int oldcol;		/* last value of column before wrap */
static int tracelevel;		/* level of debug output */
static bool pretty;		/* true if we format if-then-else strings */

static char *outbuf;		/* the output-buffer */
static size_t out_used;		/* ...its current length */
static size_t out_size;		/* ...and its allocated length */
d62 4
a65 4
static const int *bool_indirect, *num_indirect, *str_indirect;
static NCURSES_CONST char * const *bool_names;
static NCURSES_CONST char * const *num_names;
static NCURSES_CONST char * const *str_names;
d67 1
a67 1
static const char *separator, *trailer;
d95 2
a96 1
void _nc_leaks_dump_entry(void)
d98 4
a101 4
	if (outbuf != 0) {
		free(outbuf);
		outbuf = 0;
	}
d105 2
a106 1
NCURSES_CONST char *nametrans(const char *name)
d109 1
a109 1
    const struct name_table_entry 	*np;
d112 1
a112 2
        switch(np->nte_type)
	{
d115 1
a115 1
		return(boolcodes[np->nte_index]);
d120 1
a120 1
		return(numcodes[np->nte_index]);
d125 1
a125 1
		return(strcodes[np->nte_index]);
d129 1
a129 1
    return(0);
d132 3
a134 1
void dump_init(const char *version, int mode, int sort, int twidth, int traceval, bool formatted)
d145 1
a145 1
					|| !strcmp(version, "Ultrix"))
d157 1
a157 2
    switch (outform = mode)
    {
d186 1
a186 2
    switch(sortmode = sort)
    {
d190 1
a190 1
			   "%s: sorting by term structure order\n", _nc_progname);
d196 1
a196 1
			   "%s: sorting by terminfo name order\n", _nc_progname);
d205 1
a205 1
			   "%s: sorting by C variable order\n", _nc_progname);
d214 1
a214 1
			   "%s: sorting by termcap name order\n", _nc_progname);
d223 2
a224 2
		       "%s: width = %d, tversion = %d, outform = %d\n",
		       _nc_progname, width, tversion, outform);
d227 1
a227 1
static TERMTYPE	*cur_type;
d229 2
a230 1
static int dump_predicate(int type, int idx)
d233 4
a236 4
    	switch(type) {
    	case BOOLEAN:
		return (cur_type->Booleans[idx] == FALSE)
		    ? FAIL : cur_type->Booleans[idx];
d238 3
a240 3
    	case NUMBER:
		return (cur_type->Numbers[idx] == ABSENT_NUMERIC)
		    ? FAIL : cur_type->Numbers[idx];
d242 4
a245 4
    	case STRING:
		return (cur_type->Strings[idx] != ABSENT_STRING)
		    ? (int)TRUE : FAIL;
    	}
d247 1
a247 1
    	return(FALSE);	/* pacify compiler */
d250 2
a251 2
static void set_obsolete_termcaps(TERMTYPE *tp);
static void repair_acsc(TERMTYPE *tp);
d256 2
a257 1
static bool version_filter(int type, int idx)
d260 6
a265 8
    switch (tversion)
    {
    case V_ALLCAPS:	/* SVr4, XSI Curses */
	return(TRUE);

    case V_SVR1:	/* System V Release 1, Ultrix */
	switch (type)
	{
d279 1
a279 2
	switch (type)
	{
d288 1
a288 1
		return(TRUE);
d290 3
a292 3
		return(TRUE);
	    else if (idx==147||idx==156||idx==157) /* plab_norm,label_on,label_off */
		return(TRUE);
d294 1
a294 1
		return(FALSE);
d299 1
a299 2
	switch (type)
	{
d308 1
a308 1
		return(TRUE);
d310 1
a310 1
		return(TRUE);
d312 1
a312 1
		return(FALSE);
d317 1
a317 2
	switch (type)
	{
d328 1
a328 1
    return(FALSE);	/* pacify the compiler */
d332 2
a333 1
void append_output (const char *src)
d335 12
a346 15
	if (src == 0) {
		out_used = 0;
		append_output("");
	} else {
		size_t need = strlen(src);
		size_t want = need + out_used + 1;
		if (want > out_size) {
			out_size += want;	/* be generous */
			if (outbuf == 0)
				outbuf = malloc(out_size);
			else
				outbuf = realloc(outbuf, out_size);
		}
		(void)strcpy(outbuf + out_used, src);
		out_used += need;
d348 3
d354 2
a355 1
void force_wrap(void)
d357 3
a359 3
	oldcol = column;
	append_output(trailer);
	column = INDENT;
d363 2
a364 1
void wrap_concat(const char *src)
d366 2
a367 2
	int need = strlen(src);
	int want = strlen(separator) + need;
d369 7
a375 7
	if (column > INDENT
	 && column + want > width) {
		force_wrap();
	}
	append_output(src);
	append_output(separator);
	column += need;
d393 2
a394 1
static int termcap_length(const char *src)
d396 1
a396 1
	static const char pattern[] = ":\\\n\t:";
d398 2
a399 2
	int len = 0;
	const char *const t = src + strlen(src);
d401 6
a406 6
	while (*src != '\0') {
		IGNORE_SEP_TRAIL(src, t, pattern);
		src++;
		len++;
	}
	return len;
d412 2
a413 1
static char * fmt_complex(char *dst, char *src, int level)
d415 46
a460 62
	int percent = 0;
	int n;
	bool if_then = strstr(src, "%?") != 0;
	bool params = !if_then && (strlen(src) > 50) && (strstr(src, "%p") != 0);

	dst += strlen(dst);
	while (*src != '\0') {
		switch (*src) {
		case '\\':
			percent = 0;
			*dst++ = *src++;
			break;
		case '%':
			percent = 1;
			break;
		case '?':	/* "if" */
		case 't':	/* "then" */
		case 'e':	/* "else" */
			if (percent) {
				percent = 0;
				dst[-1] = '\n';
				for (n = 0; n <= level; n++)
					*dst++ = '\t';
				*dst++ = '%';
				*dst++ = *src;
				*dst   = '\0';
				if (*src++ == '?') {
					src = fmt_complex(dst, src, level+1);
					dst += strlen(dst);
				} else if (level == 1) {
					_nc_warning("%%%c without %%?", *src);
				}
				continue;
			}
			break;
		case ';':	/* "endif" */
			if (percent) {
				percent = 0;
				if (level > 1) {
					dst[-1] = '\n';
					for (n = 0; n < level; n++)
						*dst++ = '\t';
					*dst++ = '%';
					*dst++ = *src++;
					*dst   = '\0';
					return src;
				}
				_nc_warning("%%; without %%?");
			}
			break;
		case 'p':
			if (percent && params) {
				dst[-1] = '\n';
				for (n = 0; n <= level; n++)
					*dst++ = '\t';
				*dst++ = '%';
			}
			percent = 0;
			break;
		default:
			percent = 0;
			break;
d462 15
a476 1
		*dst++ = *src++;
d478 4
a481 2
	*dst = '\0';
	return src;
d484 15
a498 14
int fmt_entry(TERMTYPE *tterm,
			   int (*pred)(int type, int idx),
			   bool suppress_untranslatable,
			   bool infodump,
			   int numbers)
{
int	i, j;
char    buffer[MAX_TERMINFO_LENGTH];
NCURSES_CONST char *name;
int	predval, len;
int	num_bools = 0;
int	num_values = 0;
int	num_strings = 0;
bool	outcount = 0;
d517 1
a517 1
    for_each_boolean(j,tterm) {
d519 1
a519 1
	name = ExtBoolname(tterm,i,bool_names);
d523 1
a523 1
	else if (isObsolete(outform,name))
d540 1
a540 1
    for_each_number(j,tterm) {
d542 1
a542 1
	name = ExtNumname(tterm,i,num_names);
d546 1
a546 1
	else if (isObsolete(outform,name))
d566 2
a567 2
    	+ num_values * 2
    	+ strlen(tterm->term_names) + 1;
d569 1
a569 1
    	len++;
d574 1
a574 1
	name = ExtStrname(tterm,i,str_names);
d578 1
a578 1
	else if (isObsolete(outform,name))
d586 1
a586 2
	if (outform==F_TERMCAP)
	{
d589 1
a589 2
	    if (insert_character || parm_ich)
	    {
d591 1
a591 2
		    && enter_insert_mode == ABSENT_STRING)
		{
d597 1
a597 2
		    && exit_insert_mode == ABSENT_STRING)
		{
d604 2
a605 2
	     && termcap_reset != 0
	     && !strcmp(init_3string, termcap_reset))
d609 2
a610 2
	     && termcap_reset != 0
	     && !strcmp(reset_2string, termcap_reset))
d618 1
a618 1
	     && i + 1 > num_strings)
d622 1
a622 2
	    else if (outform == F_TERMCAP || outform == F_TCONVERR)
	    {
d626 1
a626 2
		if (cv == 0)
		{
d628 2
a629 1
			sprintf(buffer, "%s=!!! %s WILL NOT CONVERT !!!", name, srccap);
d632 15
a646 4
		    else
			sprintf(buffer, "..%s=%s", name, srccap);
		}
		else
d649 3
a651 4
	    }
	    else
	    {
		char *src = _nc_tic_expand(tterm->Strings[i], outform==F_TERMINFO, numbers);
d654 2
a655 2
		 && (outform == F_TERMINFO
		  || outform == F_VARIABLE))
d662 1
a662 1
	catenate:
d673 2
a674 4
    if (tversion == V_HPUX)
    {
	if (memory_lock)
	{
d678 1
a678 2
	if (memory_unlock)
	{
d682 6
a687 9
    }
    else if (tversion == V_AIX)
    {
	if (VALID_STRING(acs_chars))
	{
	    bool	box_ok = TRUE;
	    const char	*acstrans = "lqkxjmwuvtn";
	    const char	*cp;
	    char	*tp, *sp, boxchars[11];
d690 1
a690 2
	    for (cp = acstrans; *cp; cp++)
	    {
d694 1
a694 2
		else
		{
d701 1
a701 2
	    if (box_ok)
	    {
d703 2
a704 1
		(void) strcat(buffer, _nc_tic_expand(boxchars, outform==F_TERMINFO, numbers));
d714 1
a714 2
    if (outcount)
    {
d717 2
a718 2
	 && outbuf[j-1] == '\t'
	 && outbuf[j-2] == '\n') {
d721 4
a724 4
	 && outbuf[j-1] == ':'
	 && outbuf[j-2] == '\t'
	 && outbuf[j-3] == '\n'
	 && outbuf[j-4] == '\\') {
a729 1

d735 1
a735 1
	    tterm->term_names, len, out_used, outbuf);
d744 1
a744 1
    return(infodump ? len : termcap_length(outbuf));
d747 3
a749 1
int dump_entry(TERMTYPE *tterm, bool limited, int numbers, int (*pred)(int type, int idx))
d752 3
a754 3
    int	len, critlen;
    const char	*legend;
    bool	infodump;
d756 1
a756 2
    if (outform==F_TERMCAP || outform==F_TCONVERR)
    {
d761 1
a761 3
    }
    else
    {
d767 2
a768 2
    if (((len = fmt_entry(tterm, pred, FALSE, infodump, numbers)) > critlen) && limited)
    {
d770 2
a771 3
		      critlen);
	if ((len = fmt_entry(tterm, pred, TRUE, infodump, numbers)) > critlen)
	{
d779 2
a780 3
			  critlen);
	    if ((len = fmt_entry(tterm, pred, TRUE, infodump, numbers)) > critlen)
	    {
d785 1
a785 1
			      critlen);
d787 2
a788 2
		if ((len = fmt_entry(tterm, pred, TRUE, infodump, numbers)) > critlen)
		{
d790 3
a792 3
			       "warning: %s entry is %d bytes long\n",
			       _nc_first_name(tterm->term_names),
			       len);
d794 2
a795 2
			      "# WARNING: this entry, %d bytes long, may core-dump %s libraries!\n",
			      len, legend);
d807 2
a808 1
int dump_uses(const char *name, bool infodump)
d814 1
a814 1
    (void)sprintf(buffer, "%s%s", infodump ? "use=" : "tc=", name);
d820 2
a821 1
void compare_entry(void (*hook)(int t, int i, const char *name), TERMTYPE *tp GCC_UNUSED)
d824 2
a825 2
    int	i, j;
    NCURSES_CONST char * name;
d828 1
a828 2
    for_each_boolean(j,tp)
    {
d830 1
a830 1
	name = ExtBoolname(tp,i,bool_names);
d832 1
a832 1
	if (isObsolete(outform,name))
d835 1
a835 1
	(*hook)(BOOLEAN, i, name);
d839 1
a839 2
    for_each_number(j,tp)
    {
d841 1
a841 1
	name = ExtNumname(tp,i,num_names);
d843 1
a843 1
	if (isObsolete(outform,name))
d846 1
a846 1
	(*hook)(NUMBER, i, name);
d850 1
a850 2
    for_each_string(j,tp)
    {
d852 1
a852 1
	name = ExtStrname(tp,i,str_names);
d854 1
a854 1
	if (isObsolete(outform,name))
d857 1
a857 1
	(*hook)(STRING, i, name);
d871 2
a872 1
static void set_obsolete_termcaps(TERMTYPE *tp)
d881 2
a882 1
static void repair_acsc(TERMTYPE *tp)
d884 27
a910 13
	if (VALID_STRING(acs_chars)) {
	    size_t n, m;
	    char mapped[256];
	    char extra = 0;
	    unsigned source;
	    unsigned target;
	    bool fix_needed = FALSE;

	    for (n = 0, source = 0; acs_chars[n] != 0; n++) {
		target = acs_chars[n];
		if (source >= target) {
		    fix_needed = TRUE;
		    break;
a911 3
		source = target;
		if (acs_chars[n+1])
		    n++;
d913 4
a916 10
	    if (fix_needed) {
		memset(mapped, 0, sizeof(mapped));
		for (n = 0; acs_chars[n] != 0; n++) {
		    source = acs_chars[n];
		    if ((target = (unsigned char)acs_chars[n+1]) != 0) {
		        mapped[source] = target;
			n++;
		    } else {
			extra = source;
		    }
a917 9
		for (n = m = 0; n < sizeof(mapped); n++) {
		    if (mapped[n]) {
			acs_chars[m++] = n;
			acs_chars[m++] = mapped[n];
		    }
		}
		if (extra)
		    acs_chars[m++] = extra;	/* garbage in, garbage out */
		acs_chars[m] = 0;
d919 3
d923 1
@


1.8
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.7 1999/03/22 18:43:19 millert Exp $	*/
d43 1
a43 1
MODULE_ID("$From: dump_entry.c,v 1.38 1999/11/27 23:00:21 tom Exp $")
d77 3
d81 3
d415 2
d463 9
d520 1
a520 2
	else if ((outform == F_LITERAL || outform == F_TERMINFO || outform == F_VARIABLE)
		 && (OBSOLETE(name) && outform != F_LITERAL))
d543 1
a543 2
	else if ((outform == F_LITERAL || outform == F_TERMINFO || outform == F_VARIABLE)
		 && (OBSOLETE(name) && outform != F_LITERAL))
d575 1
a575 2
	else if ((outform == F_LITERAL || outform == F_TERMINFO || outform == F_VARIABLE)
		 && (OBSOLETE(name) && outform != F_LITERAL))
d625 1
a625 1
		char *srccap = _nc_tic_expand(tterm->Strings[i], FALSE, numbers);
d836 1
a836 2
	if ((outform == F_LITERAL || outform == F_TERMINFO || outform == F_VARIABLE)
		 && (OBSOLETE(name) && outform != F_LITERAL))
d848 1
a848 2
	if ((outform==F_LITERAL || outform==F_TERMINFO || outform==F_VARIABLE)
		 && (OBSOLETE(name) && outform != F_LITERAL))
d860 1
a860 2
	if ((outform==F_LITERAL || outform==F_TERMINFO || outform==F_VARIABLE)
		 && (OBSOLETE(name) && outform != F_LITERAL))
@


1.7
log
@back out local change that should not have escaped
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.6 1999/03/15 19:00:18 millert Exp $	*/
d43 1
a43 1
MODULE_ID("$From: dump_entry.c,v 1.37 1999/03/14 12:29:30 tom Exp $")
d631 3
a633 1
		if (pretty && outform==F_TERMINFO)
@


1.6
log
@ncurses-4.2-990314
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.5 1999/03/11 21:08:08 millert Exp $	*/
d754 1
a754 1
    if (((len = fmt_entry(tterm, pred, outform == F_TERMCAP ? TRUE : FALSE, infodump, numbers)) > critlen) && limited)
@


1.5
log
@Add -G flag; ncurses-4.2-990306
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.4 1999/03/02 06:23:55 millert Exp $	*/
d43 1
a43 1
MODULE_ID("$From: dump_entry.c,v 1.36 1999/03/06 23:37:55 tom Exp $")
d473 1
a473 1
char *	name;
d812 1
a812 1
    char * name;
@


1.4
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.3 1999/01/24 19:33:51 millert Exp $	*/
d43 1
a43 1
MODULE_ID("$From: dump_entry.c,v 1.35 1999/03/02 01:23:01 tom Exp $")
d469 1
a469 1
			   bool numbers)
d733 1
a733 1
int dump_entry(TERMTYPE *tterm, bool limited, bool numbers, int (*pred)(int type, int idx))
@


1.3
log
@updates from ncurses-4.2-990123
@
text
@d1 1
a1 1
/*	$OpenBSD: dump_entry.c,v 1.2 1998/11/03 21:59:53 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d43 1
a43 1
MODULE_ID("$From: dump_entry.c,v 1.30 1999/01/24 02:44:40 Jeffrey.C.Honig Exp $")
d79 10
d473 1
d497 3
a499 5
    for (j=0; j < BOOLCOUNT; j++) {
	if (sortmode == S_NOSORT)
	    i = j;
	else
	    i = bool_indirect[j];
d504 1
a504 1
		 && (OBSOLETE(bool_names[i]) && outform != F_LITERAL))
d509 1
a509 1
	    (void) strcpy(buffer, bool_names[i]);
d521 3
a523 5
    for (j=0; j < NUMCOUNT; j++) {
	if (sortmode == S_NOSORT)
	    i = j;
	else
	    i = num_indirect[j];
d528 1
a528 1
		 && (OBSOLETE(num_names[i]) && outform != F_LITERAL))
d534 1
a534 1
		sprintf(buffer, "%s@@", num_names[i]);
d536 1
a536 1
		sprintf(buffer, "%s#%d", num_names[i], tterm->Numbers[i]);
d554 3
a556 5
    for (j=0; j < STRCOUNT; j++) {
	if (sortmode == S_NOSORT)
	    i = j;
	else
	    i = str_indirect[j];
d561 1
a561 1
		 && (OBSOLETE(str_names[i]) && outform != F_LITERAL))
d608 1
a608 1
		sprintf(buffer, "%s@@", str_names[i]);
d612 1
a612 1
		char *cv = _nc_infotocap(str_names[i], srccap, parametrized[i]);
d617 1
a617 1
			sprintf(buffer, "%s=!!! %s WILL NOT CONVERT !!!", str_names[i], srccap);
d621 1
a621 1
			sprintf(buffer, "..%s=%s", str_names[i], srccap);
d624 1
a624 1
		    sprintf(buffer, "%s=%s", str_names[i], cv);
d630 1
a630 1
		sprintf(buffer, "%s=", str_names[i]);
d754 1
a754 1
    if (((len = fmt_entry(tterm, pred, FALSE, infodump, numbers)) > critlen) && limited)
d808 1
a808 1
void compare_entry(void (*hook)(int t, int i, const char *name))
d812 1
d815 1
a815 1
    for (j=0; j < BOOLCOUNT; j++)
d817 2
a818 4
	if (sortmode == S_NOSORT)
	    i = j;
	else
	    i = bool_indirect[j];
d821 1
a821 1
		 && (OBSOLETE(bool_names[i]) && outform != F_LITERAL))
d824 1
a824 1
	(*hook)(BOOLEAN, i, bool_names[i]);
d828 1
a828 1
    for (j=0; j < NUMCOUNT; j++)
d830 2
a831 4
	if (sortmode == S_NOSORT)
	    i = j;
	else
	    i = num_indirect[j];
d834 1
a834 1
		 && (OBSOLETE(num_names[i]) && outform != F_LITERAL))
d837 1
a837 1
	(*hook)(NUMBER, i, num_names[i]);
d841 1
a841 1
    for (j=0; j < STRCOUNT; j++)
d843 2
a844 4
	if (sortmode == S_NOSORT)
	    i = j;
	else
	    i = str_indirect[j];
d847 1
a847 1
		 && (OBSOLETE(str_names[i]) && outform != F_LITERAL))
d850 1
a850 1
	(*hook)(STRING, i, str_names[i]);
@


1.2
log
@updated from ncurses-4.2-981017
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a43 1
MODULE_ID("$From: dump_entry.c,v 1.29 1998/09/26 13:15:00 tom Exp $")
d94 1
a94 1
    if ((np = _nc_find_entry(name, _nc_info_hash_table)) != 0)
d170 1
a170 1
    { 
d760 1
a760 1
	    set_attributes = ABSENT_STRING; 
@


1.1
log
@Add missing files
@
text
@d1 2
d43 1
a43 1
MODULE_ID("$Id: dump_entry.c,v 1.27 1998/05/30 23:19:53 tom Exp $")
d47 2
d458 2
a459 1
			   bool infodump)
d565 1
d585 11
d606 1
a606 1
		char *srccap = _nc_tic_expand(tterm->Strings[i], FALSE);
d624 1
a624 1
		char *src = _nc_tic_expand(tterm->Strings[i], outform==F_TERMINFO);
d683 1
a683 1
		(void) strcat(buffer, _nc_tic_expand(boxchars, outform==F_TERMINFO));
d728 1
a728 1
int dump_entry(TERMTYPE *tterm, bool limited, int (*pred)(int type, int idx))
d749 1
a749 1
    if (((len = fmt_entry(tterm, pred, FALSE, infodump)) > critlen) && limited)
d753 1
a753 1
	if ((len = fmt_entry(tterm, pred, TRUE, infodump)) > critlen)
d763 1
a763 1
	    if ((len = fmt_entry(tterm, pred, TRUE, infodump)) > critlen)
d771 1
a771 1
		if ((len = fmt_entry(tterm, pred, TRUE, infodump)) > critlen)
@

