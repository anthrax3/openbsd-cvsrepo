head	1.33;
access;
symbols
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.31.0.10
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.6
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.16
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.14
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.12
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.10
	OPENBSD_5_0:1.30.0.8
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.6
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.14
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.10
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.8
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.6
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.4
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.28.0.12
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.10
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.8
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.6
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.4
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.25.0.10
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.8
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.25.0.6
	OPENBSD_3_1_BASE:1.25
	OPENBSD_3_0:1.25.0.4
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.33
date	2015.11.11.02.52.46;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	6fvHpVQjE6wYuHzb;

1.32
date	2015.10.10.14.27.43;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	Zr63ULkPEo6vMaCn;

1.31
date	2013.11.28.18.24.55;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.12.23.22.14;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2006.10.10.21.38.16;	author cloder;	state Exp;
branches;
next	1.28;

1.28
date	2003.10.21.23.57.04;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.02.00.21.16;	author avsm;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.14.03.35.10;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.22.04.16.36;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.29.01.58.23;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.22.18.02.20;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.22.18.27.25;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.08.22.47.10;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.19.03.53.59;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.26.16.45.04;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.13.23.53.41;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.10.01.35.06;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.16.01.35.19;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.12.16.26.47;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.12.12.04.49.19;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.12.06.02.14.34;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.11.28.17.58.57;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.06.27.08.17.46;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.03.22.18.43.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.03.16.15.25.32;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.03.11.21.08.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.03.02.06.23.55;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.02.24.06.38.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.01.24.19.33.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.01.18.18.57.52;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.12.28.05.54.44;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.11.03.21.59.53;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	98.07.24.19.37.35;	author millert;	state Exp;
branches;
next	;


desc
@@


1.33
log
@exit() after perror() for pledge failure.  Perhaps this got introduced
as a test idiom, either when pledge was young or during the transition
to strings.... dunno
@
text
@/*	$OpenBSD: tic.c,v 1.32 2015/10/10 14:27:43 deraadt Exp $	*/

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996 on                 *
 ****************************************************************************/

/*
 *	tic.c --- Main program for terminfo compiler
 *			by Eric S. Raymond
 *
 */

#include <progs.priv.h>
#include <sys/stat.h>

#include <dump_entry.h>
#include <transform.h>

MODULE_ID("$Id: tic.c,v 1.32 2015/10/10 14:27:43 deraadt Exp $")

const char *_nc_progname = "tic";

static FILE *log_fp;
static FILE *tmp_fp;
static bool capdump = FALSE;	/* running as infotocap? */
static bool infodump = FALSE;	/* running as captoinfo? */
static bool showsummary = FALSE;
static const char *to_remove;

static void (*save_check_termtype) (TERMTYPE *, bool);
static void check_termtype(TERMTYPE *tt, bool);

static const char usage_string[] = "\
[-e names] \
[-o dir] \
[-R name] \
[-v[n]] \
[-V] \
[-w[n]] \
[-\
1\
a\
C\
c\
f\
G\
g\
I\
L\
N\
r\
s\
T\
t\
U\
x\
] \
source-file\n";

#if NO_LEAKS
static void
free_namelist(char **src)
{
    if (src != 0) {
	int n;
	for (n = 0; src[n] != 0; ++n)
	    free(src[n]);
	free(src);
    }
}
#endif

static void
cleanup(char **namelst GCC_UNUSED)
{
#if NO_LEAKS
    free_namelist(namelst);
#endif
    if (tmp_fp != 0)
	fclose(tmp_fp);
    if (to_remove != 0) {
#if HAVE_REMOVE
	remove(to_remove);
#else
	unlink(to_remove);
#endif
    }
}

static void
failed(const char *msg)
{
    perror(msg);
    cleanup((char **) 0);
    ExitProgram(EXIT_FAILURE);
}

static void
usage(void)
{
    static const char *const tbl[] =
    {
	"Options:",
	"  -1         format translation output one capability per line",
#if NCURSES_XNAMES
	"  -a         retain commented-out capabilities (sets -x also)",
#endif
	"  -C         translate entries to termcap source form",
	"  -c         check only, validate input without compiling or translating",
	"  -e<names>  translate/compile only entries named by comma-separated list",
	"  -f         format complex strings for readability",
	"  -G         format %{number} to %'char'",
	"  -g         format %'char' to %{number}",
	"  -I         translate entries to terminfo source form",
	"  -L         translate entries to full terminfo source form",
	"  -N         disable smart defaults for source translation",
	"  -o<dir>    set output directory for compiled entry writes",
	"  -R<name>   restrict translation to given terminfo/termcap version",
	"  -r         force resolution of all use entries in source translation",
	"  -s         print summary statistics",
	"  -T         remove size-restrictions on compiled description",
#if NCURSES_XNAMES
	"  -t         suppress commented-out capabilities",
#endif
	"  -U         suppress post-processing of entries",
	"  -V         print version",
	"  -v[n]      set verbosity level",
	"  -w[n]      set format width for translation output",
#if NCURSES_XNAMES
	"  -x         treat unknown capabilities as user-defined",
#endif
	"",
	"Parameters:",
	"  <file>     file to translate or compile"
    };
    size_t j;

    fprintf(stderr, "Usage: %s %s\n", _nc_progname, usage_string);
    for (j = 0; j < SIZEOF(tbl); j++) {
	fputs(tbl[j], stderr);
	putc('\n', stderr);
    }
    ExitProgram(EXIT_FAILURE);
}

#define L_BRACE '{'
#define R_BRACE '}'
#define S_QUOTE '\'';

static void
write_it(ENTRY * ep)
{
    unsigned n;
    int ch;
    char *s, *d, *t;
    char result[MAX_ENTRY_SIZE];

    /*
     * Look for strings that contain %{number}, convert them to %'char',
     * which is shorter and runs a little faster.
     */
    for (n = 0; n < STRCOUNT; n++) {
	s = ep->tterm.Strings[n];
	if (VALID_STRING(s)
	    && strchr(s, L_BRACE) != 0) {
	    d = result;
	    t = s;
	    while ((ch = *t++) != 0) {
		*d++ = (char) ch;
		if (ch == '\\') {
		    *d++ = *t++;
		} else if ((ch == '%')
			   && (*t == L_BRACE)) {
		    char *v = 0;
		    long value = strtol(t + 1, &v, 0);
		    if (v != 0
			&& *v == R_BRACE
			&& value > 0
			&& value != '\\'	/* FIXME */
			&& value < 127
			&& isprint((int) value)) {
			*d++ = S_QUOTE;
			*d++ = (char) value;
			*d++ = S_QUOTE;
			t = (v + 1);
		    }
		}
	    }
	    *d = 0;
            if (strlen(result) < strlen(s)) {
		    /* new string is same length as what is there, or shorter */
		    strlcpy(s, result, strlen(s));
            }
	}
    }

    _nc_set_type(_nc_first_name(ep->tterm.term_names));
    _nc_curr_line = ep->startline;
    _nc_write_entry(&ep->tterm);
}

static bool
immedhook(ENTRY * ep GCC_UNUSED)
/* write out entries with no use capabilities immediately to save storage */
{
#if !HAVE_BIG_CORE
    /*
     * This is strictly a core-economy kluge.  The really clean way to handle
     * compilation is to slurp the whole file into core and then do all the
     * name-collision checks and entry writes in one swell foop.  But the
     * terminfo master file is large enough that some core-poor systems swap
     * like crazy when you compile it this way...there have been reports of
     * this process taking *three hours*, rather than the twenty seconds or
     * less typical on my development box.
     *
     * So.  This hook *immediately* writes out the referenced entry if it
     * has no use capabilities.  The compiler main loop refrains from
     * adding the entry to the in-core list when this hook fires.  If some
     * other entry later needs to reference an entry that got written
     * immediately, that's OK; the resolution code will fetch it off disk
     * when it can't find it in core.
     *
     * Name collisions will still be detected, just not as cleanly.  The
     * write_entry() code complains before overwriting an entry that
     * postdates the time of tic's first call to write_entry().  Thus
     * it will complain about overwriting entries newly made during the
     * tic run, but not about overwriting ones that predate it.
     *
     * The reason this is a hook, and not in line with the rest of the
     * compiler code, is that the support for termcap fallback cannot assume
     * it has anywhere to spool out these entries!
     *
     * The _nc_set_type() call here requires a compensating one in
     * _nc_parse_entry().
     *
     * If you define HAVE_BIG_CORE, you'll disable this kluge.  This will
     * make tic a bit faster (because the resolution code won't have to do
     * disk I/O nearly as often).
     */
    if (ep->nuses == 0) {
	int oldline = _nc_curr_line;

	write_it(ep);
	_nc_curr_line = oldline;
	free(ep->tterm.str_table);
	return (TRUE);
    }
#endif /* HAVE_BIG_CORE */
    return (FALSE);
}

static void
put_translate(int c)
/* emit a comment char, translating terminfo names to termcap names */
{
    static bool in_name = FALSE;
    static size_t have, used;
    static char *namebuf, *suffix;

    if (in_name) {
	if (used + 1 >= have) {
	    have += 132;
	    namebuf = typeRealloc(char, have, namebuf);
	    suffix = typeRealloc(char, have, suffix);
	}
	if (c == '\n' || c == '@@') {
	    namebuf[used++] = '\0';
	    (void) putchar('<');
	    (void) fputs(namebuf, stdout);
	    putchar(c);
	    in_name = FALSE;
	} else if (c != '>') {
	    namebuf[used++] = (char) c;
	} else {		/* ah! candidate name! */
	    char *up;
	    NCURSES_CONST char *tp;

	    namebuf[used++] = '\0';
	    in_name = FALSE;

	    suffix[0] = '\0';
	    if ((up = strchr(namebuf, '#')) != 0
		|| (up = strchr(namebuf, '=')) != 0
		|| ((up = strchr(namebuf, '@@')) != 0 && up[1] == '>')) {
		    (void) strlcpy(suffix, up, have);
		*up = '\0';
	    }

	    if ((tp = nametrans(namebuf)) != 0) {
		(void) putchar(':');
		(void) fputs(tp, stdout);
		(void) fputs(suffix, stdout);
		(void) putchar(':');
	    } else {
		/* couldn't find a translation, just dump the name */
		(void) putchar('<');
		(void) fputs(namebuf, stdout);
		(void) fputs(suffix, stdout);
		(void) putchar('>');
	    }
	}
    } else {
	used = 0;
	if (c == '<') {
	    in_name = TRUE;
	} else {
	    putchar(c);
	}
    }
}

/* Returns a string, stripped of leading/trailing whitespace */
static char *
stripped(char *src)
{
    while (isspace(UChar(*src)))
	src++;
    if (*src != '\0') {
	char *dst;
	size_t len;

	if ((dst = strdup(src)) == NULL)
	    failed("strdup");
	len = strlen(dst);
	while (--len != 0 && isspace(UChar(dst[len])))
	    dst[len] = '\0';
	return dst;
    }
    return 0;
}

static FILE *
open_input(const char *filename)
{
    FILE *fp = fopen(filename, "r");
    struct stat sb;

    if (fp == 0) {
	fprintf(stderr, "%s: Can't open %s\n", _nc_progname, filename);
	ExitProgram(EXIT_FAILURE);
    }
    if (fstat(fileno(fp), &sb) < 0
	|| (sb.st_mode & S_IFMT) != S_IFREG) {
	fprintf(stderr, "%s: %s is not a file\n", _nc_progname, filename);
	ExitProgram(EXIT_FAILURE);
    }
    return fp;
}

/* Parse the "-e" option-value into a list of names */
static char **
make_namelist(char *src)
{
    char **dst = 0;

    char *s, *base;
    unsigned pass, n, nn;
    char buffer[BUFSIZ];

    if (src == 0) {
	/* EMPTY */ ;
    } else if (strchr(src, '/') != 0) {		/* a filename */
	FILE *fp = open_input(src);

	for (pass = 1; pass <= 2; pass++) {
	    nn = 0;
	    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
		if ((s = stripped(buffer)) != 0) {
		    if (dst != 0)
			dst[nn] = s;
		    else
			free(s);
		    nn++;
		}
	    }
	    if (pass == 1) {
		dst = typeCalloc(char *, nn + 1);
		rewind(fp);
	    }
	}
	fclose(fp);
    } else {			/* literal list of names */
	for (pass = 1; pass <= 2; pass++) {
	    for (n = nn = 0, base = src;; n++) {
		int mark = src[n];
		if (mark == ',' || mark == '\0') {
		    if (pass == 1) {
			nn++;
		    } else {
			src[n] = '\0';
			if ((s = stripped(base)) != 0)
			    dst[nn++] = s;
			base = &src[n + 1];
		    }
		}
		if (mark == '\0')
		    break;
	    }
	    if (pass == 1)
		dst = typeCalloc(char *, nn + 1);
	}
    }
    if (showsummary && (dst != 0)) {
	fprintf(log_fp, "Entries that will be compiled:\n");
	for (n = 0; dst[n] != 0; n++)
	    fprintf(log_fp, "%u:%s\n", n + 1, dst[n]);
    }
    return dst;
}

static bool
matches(char **needle, const char *haystack)
/* does entry in needle list match |-separated field in haystack? */
{
    bool code = FALSE;
    size_t n;

    if (needle != 0) {
	for (n = 0; needle[n] != 0; n++) {
	    if (_nc_name_match(haystack, needle[n], "|")) {
		code = TRUE;
		break;
	    }
	}
    } else
	code = TRUE;
    return (code);
}

static FILE *
open_tempfile(char *name)
{
    FILE *result = 0;
#if HAVE_MKSTEMP
    int fd = mkstemp(name);
    if (fd >= 0)
	result = fdopen(fd, "w");
#else
    if (tmpnam(name) != 0)
	result = fopen(name, "w");
#endif
    return result;
}

int
main(int argc, char *argv[])
{
    char my_tmpname[PATH_MAX];
    int v_opt = -1, debug_level;
    int smart_defaults = TRUE;
    char *termcap;
    ENTRY *qp;

    int this_opt, last_opt = '?';

    int outform = F_TERMINFO;	/* output format */
    int sortmode = S_TERMINFO;	/* sort_mode */

    int width = 60;
    bool formatted = FALSE;	/* reformat complex strings? */
    bool literal = FALSE;	/* suppress post-processing? */
    int numbers = 0;		/* format "%'char'" to/from "%{number}" */
    bool forceresolve = FALSE;	/* force resolution */
    bool limited = TRUE;
    char *tversion = (char *) NULL;
    const char *source_file = "terminfo";
    char **namelst = 0;
    char *outdir = (char *) NULL;
    bool check_only = FALSE;
    bool suppress_untranslatable = FALSE;

    if (pledge("stdio rpath wpath cpath", NULL) == -1) {
	perror("pledge");
	exit(1);
    }

    log_fp = stderr;

    _nc_progname = _nc_rootname(argv[0]);

    if ((infodump = (strcmp(_nc_progname, PROG_CAPTOINFO) == 0)) != FALSE) {
	outform = F_TERMINFO;
	sortmode = S_TERMINFO;
    }
    if ((capdump = (strcmp(_nc_progname, PROG_INFOTOCAP) == 0)) != FALSE) {
	outform = F_TERMCAP;
	sortmode = S_TERMCAP;
    }
#if NCURSES_XNAMES
    use_extended_names(FALSE);
#endif

    /*
     * Processing arguments is a little complicated, since someone made a
     * design decision to allow the numeric values for -w, -v options to
     * be optional.
     */
    while ((this_opt = getopt(argc, argv,
			      "0123456789CILNR:TUVace:fGgo:rstvwx")) != -1) {
	if (isdigit(this_opt)) {
	    switch (last_opt) {
	    case 'v':
		v_opt = (v_opt * 10) + (this_opt - '0');
		break;
	    case 'w':
		width = (width * 10) + (this_opt - '0');
		break;
	    default:
		if (this_opt != '1')
		    usage();
		last_opt = this_opt;
		width = 0;
	    }
	    continue;
	}
	switch (this_opt) {
	case 'C':
	    capdump = TRUE;
	    outform = F_TERMCAP;
	    sortmode = S_TERMCAP;
	    break;
	case 'I':
	    infodump = TRUE;
	    outform = F_TERMINFO;
	    sortmode = S_TERMINFO;
	    break;
	case 'L':
	    infodump = TRUE;
	    outform = F_VARIABLE;
	    sortmode = S_VARIABLE;
	    break;
	case 'N':
	    smart_defaults = FALSE;
	    literal = TRUE;
	    break;
	case 'R':
	    tversion = optarg;
	    break;
	case 'T':
	    limited = FALSE;
	    break;
	case 'U':
	    literal = TRUE;
	    break;
	case 'V':
	    puts(curses_version());
	    cleanup(namelst);
	    ExitProgram(EXIT_SUCCESS);
	case 'c':
	    check_only = TRUE;
	    break;
	case 'e':
	    namelst = make_namelist(optarg);
	    break;
	case 'f':
	    formatted = TRUE;
	    break;
	case 'G':
	    numbers = 1;
	    break;
	case 'g':
	    numbers = -1;
	    break;
	case 'o':
	    outdir = optarg;
	    break;
	case 'r':
	    forceresolve = TRUE;
	    break;
	case 's':
	    showsummary = TRUE;
	    break;
	case 'v':
	    v_opt = 0;
	    break;
	case 'w':
	    width = 0;
	    break;
#if NCURSES_XNAMES
	case 't':
	    _nc_disable_period = FALSE;
	    suppress_untranslatable = TRUE;
	    break;
	case 'a':
	    _nc_disable_period = TRUE;
	    /* FALLTHRU */
	case 'x':
	    use_extended_names(TRUE);
	    break;
#endif
	default:
	    usage();
	}
	last_opt = this_opt;
    }

    debug_level = (v_opt > 0) ? v_opt : (v_opt == 0);
    set_trace_level(debug_level);

    if (_nc_tracing) {
	save_check_termtype = _nc_check_termtype2;
	_nc_check_termtype2 = check_termtype;
    }
#if !HAVE_BIG_CORE
    /*
     * Aaargh! immedhook seriously hoses us!
     *
     * One problem with immedhook is it means we can't do -e.  Problem
     * is that we can't guarantee that for each terminal listed, all the
     * terminals it depends on will have been kept in core for reference
     * resolution -- in fact it's certain the primitive types at the end
     * of reference chains *won't* be in core unless they were explicitly
     * in the select list themselves.
     */
    if (namelst && (!infodump && !capdump)) {
	(void) fprintf(stderr,
		       "Sorry, -e can't be used without -I or -C\n");
	cleanup(namelst);
	ExitProgram(EXIT_FAILURE);
    }
#endif /* HAVE_BIG_CORE */

    if (optind < argc) {
	source_file = argv[optind++];
	if (optind < argc) {
	    fprintf(stderr,
		    "%s: Too many file names.  Usage:\n\t%s %s",
		    _nc_progname,
		    _nc_progname,
		    usage_string);
	    ExitProgram(EXIT_FAILURE);
	}
    } else {
	if (infodump == TRUE) {
	    /* captoinfo's no-argument case */
	    source_file = "/etc/termcap";
	    if ((termcap = getenv("TERMCAP")) != 0
		&& (namelst = make_namelist(getenv("TERM"))) != 0) {
		strlcpy(my_tmpname, "/tmp/XXXXXXXXXX", sizeof my_tmpname);
		if (access(termcap, F_OK) == 0) {
		    /* file exists */
		    source_file = termcap;
		} else if ((tmp_fp = open_tempfile(my_tmpname)) != 0) {
		    source_file = my_tmpname;
		    fprintf(tmp_fp, "%s\n", termcap);
		    fclose(tmp_fp);
		    tmp_fp = open_input(source_file);
		    to_remove = source_file;
		} else {
		    failed("tmpnam");
		}
	    }
	} else {
	    /* tic */
	    fprintf(stderr,
		    "%s: File name needed.  Usage:\n\t%s %s",
		    _nc_progname,
		    _nc_progname,
		    usage_string);
	    cleanup(namelst);
	    ExitProgram(EXIT_FAILURE);
	}
    }

    if (tmp_fp == 0)
	tmp_fp = open_input(source_file);

    if (infodump)
	dump_init(tversion,
		  smart_defaults
		  ? outform
		  : F_LITERAL,
		  sortmode, width, debug_level, formatted);
    else if (capdump)
	dump_init(tversion,
		  outform,
		  sortmode, width, debug_level, FALSE);

    /* parse entries out of the source file */
    _nc_set_source(source_file);
#if !HAVE_BIG_CORE
    if (!(check_only || infodump || capdump))
	_nc_set_writedir(outdir);
#endif /* HAVE_BIG_CORE */
    _nc_read_entry_source(tmp_fp, (char *) NULL,
			  !smart_defaults || literal, FALSE,
			  ((check_only || infodump || capdump)
			   ? NULLHOOK
			   : immedhook));

    /* do use resolution */
    if (check_only || (!infodump && !capdump) || forceresolve) {
	if (!_nc_resolve_uses2(TRUE, literal) && !check_only) {
	    cleanup(namelst);
	    ExitProgram(EXIT_FAILURE);
	}
    }

    /* length check */
    if (check_only && (capdump || infodump)) {
	for_entry_list(qp) {
	    if (matches(namelst, qp->tterm.term_names)) {
		int len = fmt_entry(&qp->tterm, NULL, FALSE, TRUE, infodump, numbers);

		if (len > (infodump ? MAX_TERMINFO_LENGTH : MAX_TERMCAP_LENGTH))
		    (void) fprintf(stderr,
				   "warning: resolved %s entry is %d bytes long\n",
				   _nc_first_name(qp->tterm.term_names),
				   len);
	    }
	}
    }

    /* write or dump all entries */
    if (!check_only) {
	if (!infodump && !capdump) {
	    _nc_set_writedir(outdir);
	    for_entry_list(qp) {
		if (matches(namelst, qp->tterm.term_names))
		    write_it(qp);
	    }
	} else {
	    /* this is in case infotocap() generates warnings */
	    _nc_curr_col = _nc_curr_line = -1;

	    for_entry_list(qp) {
		if (matches(namelst, qp->tterm.term_names)) {
		    int j = qp->cend - qp->cstart;
		    int len = 0;

		    /* this is in case infotocap() generates warnings */
		    _nc_set_type(_nc_first_name(qp->tterm.term_names));

		    (void) fseek(tmp_fp, qp->cstart, SEEK_SET);
		    while (j-- > 0) {
			if (infodump)
			    (void) putchar(fgetc(tmp_fp));
			else
			    put_translate(fgetc(tmp_fp));
		    }

		    dump_entry(&qp->tterm, suppress_untranslatable,
			       limited, numbers, NULL);
		    for (j = 0; j < (int) qp->nuses; j++)
			dump_uses(qp->uses[j].name, !capdump);
		    len = show_entry();
		    if (debug_level != 0 && !limited)
			printf("# length=%d\n", len);
		}
	    }
	    if (!namelst && _nc_tail) {
		int c, oldc = '\0';
		bool in_comment = FALSE;
		bool trailing_comment = FALSE;

		(void) fseek(tmp_fp, _nc_tail->cend, SEEK_SET);
		while ((c = fgetc(tmp_fp)) != EOF) {
		    if (oldc == '\n') {
			if (c == '#') {
			    trailing_comment = TRUE;
			    in_comment = TRUE;
			} else {
			    in_comment = FALSE;
			}
		    }
		    if (trailing_comment
			&& (in_comment || (oldc == '\n' && c == '\n')))
			putchar(c);
		    oldc = c;
		}
	    }
	}
    }

    /* Show the directory into which entries were written, and the total
     * number of entries
     */
    if (showsummary
	&& (!(check_only || infodump || capdump))) {
	int total = _nc_tic_written();
	if (total != 0)
	    fprintf(log_fp, "%d entries written to %s\n",
		    total,
		    _nc_tic_dir((char *) 0));
	else
	    fprintf(log_fp, "No entries written\n");
    }
    cleanup(namelst);
    ExitProgram(EXIT_SUCCESS);
}

/*
 * This bit of legerdemain turns all the terminfo variable names into
 * references to locations in the arrays Booleans, Numbers, and Strings ---
 * precisely what's needed (see comp_parse.c).
 */
#undef CUR
#define CUR tp->

/*
 * Check if the alternate character-set capabilities are consistent.
 */
static void
check_acs(TERMTYPE *tp)
{
    if (VALID_STRING(acs_chars)) {
	const char *boxes = "lmkjtuvwqxn";
	char mapped[256];
	char missing[256];
	const char *p;
	char *q;

	memset(mapped, 0, sizeof(mapped));
	for (p = acs_chars; *p != '\0'; p += 2) {
	    if (p[1] == '\0') {
		_nc_warning("acsc has odd number of characters");
		break;
	    }
	    mapped[UChar(p[0])] = p[1];
	}

	if (mapped[UChar('I')] && !mapped[UChar('i')]) {
	    _nc_warning("acsc refers to 'I', which is probably an error");
	}

	for (p = boxes, q = missing; *p != '\0'; ++p) {
	    if (!mapped[UChar(p[0])]) {
		*q++ = p[0];
	    }
	}
	*q = '\0';

	assert(strlen(missing) <= strlen(boxes));
	if (*missing != '\0' && strcmp(missing, boxes)) {
	    _nc_warning("acsc is missing some line-drawing mapping: %s", missing);
	}
    }
}

/*
 * Check if the color capabilities are consistent
 */
static void
check_colors(TERMTYPE *tp)
{
    if ((max_colors > 0) != (max_pairs > 0)
	|| ((max_colors > max_pairs) && (initialize_pair == 0)))
	_nc_warning("inconsistent values for max_colors (%d) and max_pairs (%d)",
		    max_colors, max_pairs);

    PAIRED(set_foreground, set_background);
    PAIRED(set_a_foreground, set_a_background);
    PAIRED(set_color_pair, initialize_pair);

    if (VALID_STRING(set_foreground)
	&& VALID_STRING(set_a_foreground)
	&& !_nc_capcmp(set_foreground, set_a_foreground))
	_nc_warning("expected setf/setaf to be different");

    if (VALID_STRING(set_background)
	&& VALID_STRING(set_a_background)
	&& !_nc_capcmp(set_background, set_a_background))
	_nc_warning("expected setb/setab to be different");

    /* see: has_colors() */
    if (VALID_NUMERIC(max_colors) && VALID_NUMERIC(max_pairs)
	&& (((set_foreground != NULL)
	     && (set_background != NULL))
	    || ((set_a_foreground != NULL)
		&& (set_a_background != NULL))
	    || set_color_pair)) {
	if (!VALID_STRING(orig_pair) && !VALID_STRING(orig_colors))
	    _nc_warning("expected either op/oc string for resetting colors");
    }
}

static char
keypad_final(const char *string)
{
    char result = '\0';

    if (VALID_STRING(string)
	&& *string++ == '\033'
	&& *string++ == 'O'
	&& strlen(string) == 1) {
	result = *string;
    }

    return result;
}

static int
keypad_index(const char *string)
{
    char *test;
    const char *list = "PQRSwxymtuvlqrsPpn";	/* app-keypad except "Enter" */
    int ch;
    int result = -1;

    if ((ch = keypad_final(string)) != '\0') {
	test = strchr(list, ch);
	if (test != 0)
	    result = (test - list);
    }
    return result;
}

#define MAX_KP 5
/*
 * Do a quick sanity-check for vt100-style keypads to see if the 5-key keypad
 * is mapped inconsistently.
 */
static void
check_keypad(TERMTYPE *tp)
{
    char show[80];

    if (VALID_STRING(key_a1) &&
	VALID_STRING(key_a3) &&
	VALID_STRING(key_b2) &&
	VALID_STRING(key_c1) &&
	VALID_STRING(key_c3)) {
	char final[MAX_KP + 1];
	int list[MAX_KP];
	int increase = 0;
	int j, k, kk;
	int last;
	int test;

	final[0] = keypad_final(key_a1);
	final[1] = keypad_final(key_a3);
	final[2] = keypad_final(key_b2);
	final[3] = keypad_final(key_c1);
	final[4] = keypad_final(key_c3);
	final[5] = '\0';

	/* special case: legacy coding using 1,2,3,0,. on the bottom */
	assert(strlen(final) <= MAX_KP);
	if (!strcmp(final, "qsrpn"))
	    return;

	list[0] = keypad_index(key_a1);
	list[1] = keypad_index(key_a3);
	list[2] = keypad_index(key_b2);
	list[3] = keypad_index(key_c1);
	list[4] = keypad_index(key_c3);

	/* check that they're all vt100 keys */
	for (j = 0; j < MAX_KP; ++j) {
	    if (list[j] < 0) {
		return;
	    }
	}

	/* check if they're all in increasing order */
	for (j = 1; j < MAX_KP; ++j) {
	    if (list[j] > list[j - 1]) {
		++increase;
	    }
	}
	if (increase != (MAX_KP - 1)) {
	    show[0] = '\0';

	    for (j = 0, last = -1; j < MAX_KP; ++j) {
		for (k = 0, kk = -1, test = 100; k < 5; ++k) {
		    if (list[k] > last &&
			list[k] < test) {
			test = list[k];
			kk = k;
		    }
		}
		last = test;
		assert(strlen(show) < (MAX_KP * 4));
		switch (kk) {
		case 0:
		    strlcat(show, " ka1", sizeof(show));
		    break;
		case 1:
		    strlcat(show, " ka3", sizeof(show));
		    break;
		case 2:
		    strlcat(show, " kb2", sizeof(show));
		    break;
		case 3:
		    strlcat(show, " kc1", sizeof(show));
		    break;
		case 4:
		    strlcat(show, " kc3", sizeof(show));
		    break;
		}
	    }

	    _nc_warning("vt100 keypad order inconsistent: %s", show);
	}

    } else if (VALID_STRING(key_a1) ||
	       VALID_STRING(key_a3) ||
	       VALID_STRING(key_b2) ||
	       VALID_STRING(key_c1) ||
	       VALID_STRING(key_c3)) {
	show[0] = '\0';
	if (keypad_index(key_a1) >= 0)
	    strlcat(show, " ka1", sizeof(show));
	if (keypad_index(key_a3) >= 0)
	    strlcat(show, " ka3", sizeof(show));
	if (keypad_index(key_b2) >= 0)
	    strlcat(show, " kb2", sizeof(show));
	if (keypad_index(key_c1) >= 0)
	    strlcat(show, " kc1", sizeof(show));
	if (keypad_index(key_c3) >= 0)
	    strlcat(show, " kc3", sizeof(show));
	if (*show != '\0')
	    _nc_warning("vt100 keypad map incomplete:%s", show);
    }
}

/*
 * Returns the expected number of parameters for the given capability.
 */
static int
expected_params(const char *name)
{
    /* *INDENT-OFF* */
    static const struct {
	const char *name;
	int count;
    } table[] = {
	{ "S0",			1 },	/* 'screen' extension */
	{ "birep",		2 },
	{ "chr",		1 },
	{ "colornm",		1 },
	{ "cpi",		1 },
	{ "csnm",		1 },
	{ "csr",		2 },
	{ "cub",		1 },
	{ "cud",		1 },
	{ "cuf",		1 },
	{ "cup",		2 },
	{ "cuu",		1 },
	{ "cvr",		1 },
	{ "cwin",		5 },
	{ "dch",		1 },
	{ "defc",		3 },
	{ "dial",		1 },
	{ "dispc",		1 },
	{ "dl",			1 },
	{ "ech",		1 },
	{ "getm",		1 },
	{ "hpa",		1 },
	{ "ich",		1 },
	{ "il",			1 },
	{ "indn",		1 },
	{ "initc",		4 },
	{ "initp",		7 },
	{ "lpi",		1 },
	{ "mc5p",		1 },
	{ "mrcup",		2 },
	{ "mvpa",		1 },
	{ "pfkey",		2 },
	{ "pfloc",		2 },
	{ "pfx",		2 },
	{ "pfxl",		3 },
	{ "pln",		2 },
	{ "qdial",		1 },
	{ "rcsd",		1 },
	{ "rep",		2 },
	{ "rin",		1 },
	{ "sclk",		3 },
	{ "scp",		1 },
	{ "scs",		1 },
	{ "scsd",		2 },
	{ "setab",		1 },
	{ "setaf",		1 },
	{ "setb",		1 },
	{ "setcolor",		1 },
	{ "setf",		1 },
	{ "sgr",		9 },
	{ "sgr1",		6 },
	{ "slength",		1 },
	{ "slines",		1 },
	{ "smgbp",		1 },	/* 2 if smgtp is not given */
	{ "smglp",		1 },
	{ "smglr",		2 },
	{ "smgrp",		1 },
	{ "smgtb",		2 },
	{ "smgtp",		1 },
	{ "tsl",		1 },
	{ "u6",			-1 },
	{ "vpa",		1 },
	{ "wind",		4 },
	{ "wingo",		1 },
    };
    /* *INDENT-ON* */

    unsigned n;
    int result = 0;		/* function-keys, etc., use none */

    for (n = 0; n < SIZEOF(table); n++) {
	if (!strcmp(name, table[n].name)) {
	    result = table[n].count;
	    break;
	}
    }

    return result;
}

/*
 * Make a quick sanity check for the parameters which are used in the given
 * strings.  If there are no "%p" tokens, then there should be no other "%"
 * markers.
 */
static void
check_params(TERMTYPE *tp, const char *name, char *value)
{
    int expected = expected_params(name);
    int actual = 0;
    int n;
    bool params[10];
    char *s = value;

#ifdef set_top_margin_parm
    if (!strcmp(name, "smgbp")
	&& set_top_margin_parm == 0)
	expected = 2;
#endif

    for (n = 0; n < 10; n++)
	params[n] = FALSE;

    while (*s != 0) {
	if (*s == '%') {
	    if (*++s == '\0') {
		_nc_warning("expected character after %% in %s", name);
		break;
	    } else if (*s == 'p') {
		if (*++s == '\0' || !isdigit(UChar(*s))) {
		    _nc_warning("expected digit after %%p in %s", name);
		    return;
		} else {
		    n = (*s - '0');
		    if (n > actual)
			actual = n;
		    params[n] = TRUE;
		}
	    }
	}
	s++;
    }

    if (params[0]) {
	_nc_warning("%s refers to parameter 0 (%%p0), which is not allowed", name);
    }
    if (value == set_attributes || expected < 0) {
	;
    } else if (expected != actual) {
	_nc_warning("%s uses %d parameters, expected %d", name,
		    actual, expected);
	for (n = 1; n < actual; n++) {
	    if (!params[n])
		_nc_warning("%s omits parameter %d", name, n);
	}
    }
}

static char *
skip_delay(char *s)
{
    while (*s == '/' || isdigit(UChar(*s)))
	++s;
    return s;
}

/*
 * Skip a delay altogether, e.g., when comparing a simple string to sgr,
 * the latter may have a worst-case delay on the end.
 */
static char *
ignore_delays(char *s)
{
    int delaying = 0;

    do {
	switch (*s) {
	case '$':
	    if (delaying == 0)
		delaying = 1;
	    break;
	case '<':
	    if (delaying == 1)
		delaying = 2;
	    break;
	case '\0':
	    delaying = 0;
	    break;
	default:
	    if (delaying) {
		s = skip_delay(s);
		if (*s == '>')
		    ++s;
		delaying = 0;
	    }
	    break;
	}
	if (delaying)
	    ++s;
    } while (delaying);
    return s;
}

/*
 * An sgr string may contain several settings other than the one we're
 * interested in, essentially sgr0 + rmacs + whatever.  As long as the
 * "whatever" is contained in the sgr string, that is close enough for our
 * sanity check.
 */
static bool
similar_sgr(int num, char *a, char *b)
{
    static const char *names[] =
    {
	"none"
	,"standout"
	,"underline"
	,"reverse"
	,"blink"
	,"dim"
	,"bold"
	,"invis"
	,"protect"
	,"altcharset"
    };
    char *base_a = a;
    char *base_b = b;
    int delaying = 0;

    while (*b != 0) {
	while (*a != *b) {
	    if (*a == 0) {
		if (b[0] == '$'
		    && b[1] == '<') {
		    _nc_warning("Did not find delay %s", _nc_visbuf(b));
		} else {
		    _nc_warning("checking sgr(%s) %s\n\tcompare to %s\n\tunmatched %s",
				names[num], _nc_visbuf2(1, base_a),
				_nc_visbuf2(2, base_b),
				_nc_visbuf2(3, b));
		}
		return FALSE;
	    } else if (delaying) {
		a = skip_delay(a);
		b = skip_delay(b);
	    } else {
		a++;
	    }
	}
	switch (*a) {
	case '$':
	    if (delaying == 0)
		delaying = 1;
	    break;
	case '<':
	    if (delaying == 1)
		delaying = 2;
	    break;
	default:
	    delaying = 0;
	    break;
	}
	a++;
	b++;
    }
    /* ignore delays on the end of the string */
    a = ignore_delays(a);
    return ((num != 0) || (*a == 0));
}

static char *
check_sgr(TERMTYPE *tp, char *zero, int num, char *cap, const char *name)
{
    char *test;

    _nc_tparm_err = 0;
    test = TPARM_9(set_attributes,
		   num == 1,
		   num == 2,
		   num == 3,
		   num == 4,
		   num == 5,
		   num == 6,
		   num == 7,
		   num == 8,
		   num == 9);
    if (test != 0) {
	if (PRESENT(cap)) {
	    if (!similar_sgr(num, test, cap)) {
		_nc_warning("%s differs from sgr(%d)\n\t%s=%s\n\tsgr(%d)=%s",
			    name, num,
			    name, _nc_visbuf2(1, cap),
			    num, _nc_visbuf2(2, test));
	    }
	} else if (_nc_capcmp(test, zero)) {
	    _nc_warning("sgr(%d) present, but not %s", num, name);
	}
    } else if (PRESENT(cap)) {
	_nc_warning("sgr(%d) missing, but %s present", num, name);
    }
    if (_nc_tparm_err)
	_nc_warning("stack error in sgr(%d) string", num);
    return test;
}

#define CHECK_SGR(num,name) check_sgr(tp, zero, num, name, #name)

#ifdef TRACE
/*
 * If tic is compiled with TRACE, we'll be able to see the output from the
 * DEBUG() macro.  But since it doesn't use traceon(), it always goes to
 * the standard error.  Use this function to make it simpler to follow the
 * resulting debug traces.
 */
static void
show_where(unsigned level)
{
    if (_nc_tracing >= DEBUG_LEVEL(level)) {
	char my_name[256];
	_nc_get_type(my_name);
	fprintf(stderr, "\"%s\", line %d, '%s' ",
		_nc_get_source(),
		_nc_curr_line, my_name);
    }
}

#else
#define show_where(level)	/* nothing */
#endif

/* other sanity-checks (things that we don't want in the normal
 * logic that reads a terminfo entry)
 */
static void
check_termtype(TERMTYPE *tp, bool literal)
{
    bool conflict = FALSE;
    unsigned j, k;
    char fkeys[STRCOUNT];

    /*
     * A terminal entry may contain more than one keycode assigned to
     * a given string (e.g., KEY_END and KEY_LL).  But curses will only
     * return one (the last one assigned).
     */
    if (!(_nc_syntax == SYN_TERMCAP && capdump)) {
	memset(fkeys, 0, sizeof(fkeys));
	for (j = 0; _nc_tinfo_fkeys[j].code; j++) {
	    char *a = tp->Strings[_nc_tinfo_fkeys[j].offset];
	    bool first = TRUE;
	    if (!VALID_STRING(a))
		continue;
	    for (k = j + 1; _nc_tinfo_fkeys[k].code; k++) {
		char *b = tp->Strings[_nc_tinfo_fkeys[k].offset];
		if (!VALID_STRING(b)
		    || fkeys[k])
		    continue;
		if (!_nc_capcmp(a, b)) {
		    fkeys[j] = 1;
		    fkeys[k] = 1;
		    if (first) {
			if (!conflict) {
			    _nc_warning("Conflicting key definitions (using the last)");
			    conflict = TRUE;
			}
			fprintf(stderr, "... %s is the same as %s",
				keyname((int) _nc_tinfo_fkeys[j].code),
				keyname((int) _nc_tinfo_fkeys[k].code));
			first = FALSE;
		    } else {
			fprintf(stderr, ", %s",
				keyname((int) _nc_tinfo_fkeys[k].code));
		    }
		}
	    }
	    if (!first)
		fprintf(stderr, "\n");
	}
    }

    for (j = 0; j < NUM_STRINGS(tp); j++) {
	char *a = tp->Strings[j];
	if (VALID_STRING(a))
	    check_params(tp, ExtStrname(tp, j, strnames), a);
    }

    check_acs(tp);
    check_colors(tp);
    check_keypad(tp);

    /*
     * These may be mismatched because the terminal description relies on
     * restoring the cursor visibility by resetting it.
     */
    ANDMISSING(cursor_invisible, cursor_normal);
    ANDMISSING(cursor_visible, cursor_normal);

    if (PRESENT(cursor_visible) && PRESENT(cursor_normal)
	&& !_nc_capcmp(cursor_visible, cursor_normal))
	_nc_warning("cursor_visible is same as cursor_normal");

    /*
     * From XSI & O'Reilly, we gather that sc/rc are required if csr is
     * given, because the cursor position after the scrolling operation is
     * performed is undefined.
     */
    ANDMISSING(change_scroll_region, save_cursor);
    ANDMISSING(change_scroll_region, restore_cursor);

    if (PRESENT(set_attributes)) {
	char *zero = 0;

	_nc_tparm_err = 0;
	if (PRESENT(exit_attribute_mode)) {
	    zero = strdup(CHECK_SGR(0, exit_attribute_mode));
	} else {
	    zero = strdup(TPARM_9(set_attributes, 0, 0, 0, 0, 0, 0, 0, 0, 0));
	}
	if (_nc_tparm_err)
	    _nc_warning("stack error in sgr(0) string");

	if (zero != 0) {
	    CHECK_SGR(1, enter_standout_mode);
	    CHECK_SGR(2, enter_underline_mode);
	    CHECK_SGR(3, enter_reverse_mode);
	    CHECK_SGR(4, enter_blink_mode);
	    CHECK_SGR(5, enter_dim_mode);
	    CHECK_SGR(6, enter_bold_mode);
	    CHECK_SGR(7, enter_secure_mode);
	    CHECK_SGR(8, enter_protected_mode);
	    CHECK_SGR(9, enter_alt_charset_mode);
	    free(zero);
	} else {
	    _nc_warning("sgr(0) did not return a value");
	}
    } else if (PRESENT(exit_attribute_mode) &&
	       set_attributes != CANCELLED_STRING) {
	if (_nc_syntax == SYN_TERMINFO)
	    _nc_warning("missing sgr string");
    }

    if (PRESENT(exit_attribute_mode)) {
	char *check_sgr0 = _nc_trim_sgr0(tp);

	if (check_sgr0 == 0 || *check_sgr0 == '\0') {
	    _nc_warning("trimmed sgr0 is empty");
	} else {
	    show_where(2);
	    if (check_sgr0 != exit_attribute_mode) {
		DEBUG(2,
		      ("will trim sgr0\n\toriginal sgr0=%s\n\ttrimmed  sgr0=%s",
		       _nc_visbuf2(1, exit_attribute_mode),
		       _nc_visbuf2(2, check_sgr0)));
		free(check_sgr0);
	    } else {
		DEBUG(2,
		      ("will not trim sgr0\n\toriginal sgr0=%s",
		       _nc_visbuf(exit_attribute_mode)));
	    }
	}
    }
#ifdef TRACE
    show_where(2);
    if (!auto_right_margin) {
	DEBUG(2,
	      ("can write to lower-right directly"));
    } else if (PRESENT(enter_am_mode) && PRESENT(exit_am_mode)) {
	DEBUG(2,
	      ("can write to lower-right by suppressing automargin"));
    } else if ((PRESENT(enter_insert_mode) && PRESENT(exit_insert_mode))
	       || PRESENT(insert_character) || PRESENT(parm_ich)) {
	DEBUG(2,
	      ("can write to lower-right by using inserts"));
    } else {
	DEBUG(2,
	      ("cannot write to lower-right"));
    }
#endif

    /*
     * Some standard applications (e.g., vi) and some non-curses
     * applications (e.g., jove) get confused if we have both ich1 and
     * smir/rmir.  Let's be nice and warn about that, too, even though
     * ncurses handles it.
     */
    if ((PRESENT(enter_insert_mode) || PRESENT(exit_insert_mode))
	&& PRESENT(parm_ich)) {
	_nc_warning("non-curses applications may be confused by ich1 with smir/rmir");
    }

    /*
     * Finally, do the non-verbose checks
     */
    if (save_check_termtype != 0)
	save_check_termtype(tp, literal);
}
@


1.32
log
@pledge "stdio rpath wpath cpath". as a curses program, I expected this
to maybe need "tty", but have not found a path which calls those kind
of curses functions.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.31 2013/11/28 18:24:55 deraadt Exp $	*/
d49 1
a49 1
MODULE_ID("$Id: tic.c,v 1.31 2013/11/28 18:24:55 deraadt Exp $")
d502 1
a502 1
    if (pledge("stdio rpath wpath cpath", NULL) == -1)
d504 2
@


1.31
log
@unsigned char for ctype
ok krw okan
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.30 2010/01/12 23:22:14 nicm Exp $	*/
d49 1
a49 1
MODULE_ID("$Id: tic.c,v 1.30 2010/01/12 23:22:14 nicm Exp $")
d501 3
@


1.30
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.28 2003/10/21 23:57:04 deraadt Exp $	*/
d49 1
a49 1
MODULE_ID("$Id: tic.c,v 1.137 2008/09/13 16:59:24 tom Exp $")
d1162 1
a1162 1
		if (*++s == '\0' || !isdigit((int) *s)) {
@


1.29
log
@fgets(3) returns NULL on error, not 0. No functional change, but it makes
the code easier to read.
OK deraadt
@
text
@d4 1
a4 1
 * Copyright (c) 1998,1999,2000,2001 Free Software Foundation, Inc.         *
d34 1
a46 1
#include <term_entry.h>
d49 1
a49 1
MODULE_ID("$From: tic.c,v 1.85 2001/02/03 23:31:45 tom Exp $")
d55 2
d60 2
a61 2
static void (*save_check_termtype) (TERMTYPE *);
static void check_termtype(TERMTYPE * tt);
d63 26
a88 1
static const char usage_string[] = "[-V] [-v[n]] [-e names] [-CILNRTcfrswx1] source-file\n";
d90 1
d92 1
a92 1
cleanup(void)
d94 15
d124 2
a125 2
    cleanup();
    exit(EXIT_FAILURE);
a134 7
	"  -C         translate entries to termcap source form",
	"  -I         translate entries to terminfo source form",
	"  -L         translate entries to full terminfo source form",
	"  -N         disable smart defaults for source translation",
	"  -R         restrict translation to given terminfo/termcap version",
	"  -T         remove size-restrictions on compiled description",
	"  -V         print version",
d138 1
d140 1
d144 3
a146 1
	"  -e<names>  translate/compile only entries named by comma-separated list",
d148 1
d151 6
d173 1
a173 1
    exit(EXIT_FAILURE);
d199 1
a199 1
		*d++ = ch;
d213 1
a213 1
			*d++ = (int) value;
d220 4
a223 4
	    if (strlen(result) < strlen(s)) {
		/* new string is same length as what is there, or shorter */
		strlcpy(s, result, strlen(s));
	    }
d303 1
a303 1
	    namebuf[used++] = c;
d315 1
a315 1
		(void) strlcpy(suffix, up, have);
d346 1
a346 1
    while (isspace(CharOf(*src)))
d353 1
a353 1
		failed("strdup");
d355 1
a355 1
	while (--len != 0 && isspace(CharOf(dst[len])))
d370 1
a370 1
	exit(EXIT_FAILURE);
d375 1
a375 1
	exit(EXIT_FAILURE);
d381 1
a381 1
static const char **
d384 1
a384 1
    const char **dst = 0;
d401 2
d407 1
a407 1
		dst = typeCalloc(const char *, nn + 1);
d430 1
a430 1
		dst = typeCalloc(const char *, nn + 1);
d433 1
a433 1
    if (showsummary) {
d436 1
a436 1
	    fprintf(log_fp, "%d:%s\n", n + 1, dst[n]);
d442 1
a442 1
matches(const char **needle, const char *haystack)
d491 1
a492 2
    bool infodump = FALSE;	/* running as captoinfo? */
    bool capdump = FALSE;	/* running as infotocap? */
d497 1
a497 1
    const char **namelst = 0;
d500 1
d504 1
a504 1
    _nc_progname = _nc_basename(argv[0]);
d524 1
a524 1
			      "0123456789CILNR:TVace:fGgo:rsvwx")) != -1) {
d559 1
d567 3
d572 2
a573 1
	    return EXIT_SUCCESS;
d605 4
d626 2
a627 2
	save_check_termtype = _nc_check_termtype;
	_nc_check_termtype = check_termtype;
d643 2
a644 2
	cleanup();
	return EXIT_FAILURE;
d656 1
a656 1
	    return EXIT_FAILURE;
d661 1
a661 1
	    source_file = "/usr/share/misc/termcap";
d675 1
a675 1
		    failed("mkstemp");
d685 2
a686 2
	    cleanup();
	    return EXIT_FAILURE;
d711 4
a714 2
			  !smart_defaults, FALSE,
			  (check_only || infodump || capdump) ? NULLHOOK : immedhook);
d718 3
a720 3
	if (!_nc_resolve_uses(TRUE) && !check_only) {
	    cleanup();
	    return EXIT_FAILURE;
d728 1
a728 1
		int len = fmt_entry(&qp->tterm, NULL, TRUE, infodump, numbers);
d760 1
a760 1
		    while (j--) {
d767 5
a771 4
		    len = dump_entry(&qp->tterm, limited, numbers, NULL);
		    for (j = 0; j < qp->nuses; j++)
			len += dump_uses(qp->uses[j].name, !capdump);
		    (void) putchar('\n');
d813 2
a814 2
    cleanup();
    return (EXIT_SUCCESS);
d822 195
d1018 2
a1019 1
TERMINAL *cur_term;		/* tweak to avoid linking lib_cur_term.c */
d1021 20
a1040 2
#undef CUR
#define CUR tp->
d1046 1
a1046 1
expected_params(char *name)
d1053 1
d1106 2
a1107 2
	{ "smgbp",		2 },
	{ "smglp",		2 },
d1139 1
a1139 1
check_params(TERMTYPE * tp, char *name, char *value)
d1147 6
d1191 45
d1243 1
a1243 1
similar_sgr(char *a, char *b)
d1245 17
d1264 10
a1273 1
	    if (*a == 0)
d1275 19
a1293 1
	    a++;
d1298 3
a1300 1
    return TRUE;
d1303 2
a1304 2
static void
check_sgr(TERMTYPE * tp, char *zero, int num, char *cap, const char *name)
d1306 13
a1318 10
    char *test = tparm(set_attributes,
		       num == 1,
		       num == 2,
		       num == 3,
		       num == 4,
		       num == 5,
		       num == 6,
		       num == 7,
		       num == 8,
		       num == 9);
d1321 5
a1325 3
	    if (!similar_sgr(test, cap)) {
		_nc_warning("%s differs from sgr(%d): %s", name, num,
			    _nc_visbuf(test));
d1327 1
a1327 1
	} else if (strcmp(test, zero)) {
d1333 3
d1340 23
d1367 1
a1367 1
check_termtype(TERMTYPE * tp)
d1378 6
a1383 10
    memset(fkeys, 0, sizeof(fkeys));
    for (j = 0; _nc_tinfo_fkeys[j].code; j++) {
	char *a = tp->Strings[_nc_tinfo_fkeys[j].offset];
	bool first = TRUE;
	if (!VALID_STRING(a))
	    continue;
	for (k = j + 1; _nc_tinfo_fkeys[k].code; k++) {
	    char *b = tp->Strings[_nc_tinfo_fkeys[k].offset];
	    if (!VALID_STRING(b)
		|| fkeys[k])
d1385 20
a1404 7
	    if (!strcmp(a, b)) {
		fkeys[j] = 1;
		fkeys[k] = 1;
		if (first) {
		    if (!conflict) {
			_nc_warning("Conflicting key definitions (using the last)");
			conflict = TRUE;
a1405 7
		    fprintf(stderr, "... %s is the same as %s",
			    keyname(_nc_tinfo_fkeys[j].code),
			    keyname(_nc_tinfo_fkeys[k].code));
		    first = FALSE;
		} else {
		    fprintf(stderr, ", %s",
			    keyname(_nc_tinfo_fkeys[k].code));
d1408 2
a1410 2
	if (!first)
	    fprintf(stderr, "\n");
d1419 3
a1421 10
    /*
     * Quick check for color.  We could also check if the ANSI versus
     * non-ANSI strings are misused.
     */
    if ((max_colors > 0) != (max_pairs > 0)
	|| (max_colors > max_pairs))
	_nc_warning("inconsistent values for max_colors and max_pairs");

    PAIRED(set_foreground, set_background);
    PAIRED(set_a_foreground, set_a_background);
d1431 1
a1431 1
	&& !strcmp(cursor_visible, cursor_normal))
d1443 1
a1443 1
	char *zero = tparm(set_attributes, 0, 0, 0, 0, 0, 0, 0, 0, 0);
d1445 27
a1471 11
	zero = strdup(zero);
	CHECK_SGR(1, enter_standout_mode);
	CHECK_SGR(2, enter_underline_mode);
	CHECK_SGR(3, enter_reverse_mode);
	CHECK_SGR(4, enter_blink_mode);
	CHECK_SGR(5, enter_dim_mode);
	CHECK_SGR(6, enter_bold_mode);
	CHECK_SGR(7, enter_secure_mode);
	CHECK_SGR(8, enter_protected_mode);
	CHECK_SGR(9, enter_alt_charset_mode);
	free(zero);
d1474 38
d1514 1
a1514 1
     * applications (e.g., jove) get confused if we have both ich/ich1 and
d1519 2
a1520 2
	&& (PRESENT(insert_character) || PRESENT(parm_ich))) {
	_nc_warning("non-curses applications may be confused by ich/ich1 with smir/rmir");
d1527 1
a1527 1
	save_check_termtype(tp);
@


1.28
log
@strdup check missing; noted by nimadeus@@pandora.be
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.27 2003/07/02 00:21:16 avsm Exp $	*/
d350 1
a350 1
	    while (fgets(buffer, sizeof(buffer), fp) != 0) {
@


1.27
log
@bump randomness of mktemp to from 6 to 10 X's, as recommended by mktemp(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.26 2003/04/14 03:35:10 deraadt Exp $	*/
d302 6
a307 2
	char *dst = strdup(src);
	size_t len = strlen(dst);
@


1.26
log
@spring cleaning; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.25 2001/02/22 04:16:36 millert Exp $	*/
d602 1
a602 1
		strlcpy(my_tmpname, "/tmp/XXXXXX", sizeof my_tmpname);
@


1.25
log
@Update to ncurses-5.2-20010210:
o remove macro callPutChar() from tty_update.c, since this is no longer
  needed (reported by Philippe Blain).
o add a null-pointer check in tic.c to handle the case when the input
  file is really empty.  Modify the next_char() function in comp_scan.c
  to allow arbitrarily long lines, and incidentally supply a newline to
  files that do not end in a newline.  These changes improve tic's
  recovery from attempts to read binary files, e.g., its output from
  the terminfo database (reported by Bernhard Rosenkraenzer).
o revert change to c++/demo.cc from 20001209, which changed definition
  of main() apparently to accommodate cygwin linker, but broke the demo
  program.
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.24 2001/01/29 01:58:23 niklas Exp $	*/
d173 4
a176 2
	    if (strlen(result) < strlen(s))
		strcpy(s, result);
d268 1
a268 1
		(void) strcpy(suffix, up);
d302 1
a302 1
	char *dst = strcpy(malloc(strlen(src) + 1), src);
d602 1
d606 1
a606 3
		} else if ((tmp_fp = open_tempfile(strcpy(my_tmpname,
							  "/tmp/XXXXXX")))
			   != 0) {
@


1.24
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d49 1
a49 1
MODULE_ID("$From: tic.c,v 1.84 2000/11/04 22:50:16 tom Exp $")
d710 1
a710 1
	    if (!namelst) {
@


1.23
log
@Update to ncurses-5.2-20010114
@
text
@d1 2
@


1.22
log
@update to ncurses 5.2
@
text
@d47 1
a47 1
MODULE_ID("$From: tic.c,v 1.83 2000/10/14 17:30:26 tom Exp $")
d295 1
a295 1
    while (isspace(*src))
d300 1
a300 1
	while (--len != 0 && isspace(dst[len]))
@


1.21
log
@update to ncurses-5.1-20001007
@
text
@d47 1
a47 1
MODULE_ID("$From: tic.c,v 1.82 2000/10/01 02:11:39 tom Exp $")
d775 1
d781 1
a782 1
	{ "cuu",		1 },
d785 1
a785 1
	{ "dclk",		2 },
d807 1
d813 1
d828 1
a828 1
	{ "smgtp",		2 },
@


1.20
log
@ncurses-5.0-20000617
@
text
@d41 1
d45 1
d47 1
a47 1
MODULE_ID("$From: tic.c,v 1.69 2000/04/08 23:53:49 tom Exp $")
d59 1
a59 1
static const char usage_string[] = "[-h] [-v[n]] [-e names] [-CILNRTcfrswx1] source-file\n";
d96 1
d120 1
a120 1
    for (j = 0; j < sizeof(tbl) / sizeof(tbl[0]); j++) {
d154 1
a154 1
		    && (*t == L_BRACE)) {
d185 1
a185 1
#ifndef HAVE_BIG_CORE
d307 18
d338 1
a338 3
	FILE *fp = fopen(src, "r");
	if (fp == 0)
	    failed(src);
d447 1
a447 4
    if ((_nc_progname = strrchr(argv[0], '/')) == NULL)
	_nc_progname = argv[0];
    else
	_nc_progname++;
d449 1
a449 1
    if ((infodump = (strcmp(_nc_progname, "captoinfo") == 0)) != FALSE) {
d453 1
a453 1
    if ((capdump = (strcmp(_nc_progname, "infotocap") == 0)) != FALSE) {
d467 1
a467 1
		"0123456789CILNR:TVace:fGgo:rsvwx")) != -1) {
d510 1
a510 1
	    puts(NCURSES_VERSION);
d563 1
a563 1
#ifndef HAVE_BIG_CORE
d576 1
a576 1
	    "Sorry, -e can't be used without -I or -C\n");
d586 4
a589 4
		"%s: Too many file names.  Usage:\n\t%s %s",
		_nc_progname,
		_nc_progname,
		usage_string);
d601 3
a603 1
		} else if ((tmp_fp = open_tempfile(my_tmpname)) != 0) {
d607 1
a607 1
		    tmp_fp = fopen(source_file, "r");
d616 4
a619 4
		"%s: File name needed.  Usage:\n\t%s %s",
		_nc_progname,
		_nc_progname,
		usage_string);
d625 2
a626 5
    if (tmp_fp == 0
	&& (tmp_fp = fopen(source_file, "r")) == 0) {
	fprintf(stderr, "%s: Can't open %s\n", _nc_progname, source_file);
	return EXIT_FAILURE;
    }
d630 4
a633 4
	    smart_defaults
	    ? outform
	    : F_LITERAL,
	    sortmode, width, debug_level, formatted);
d636 2
a637 2
	    outform,
	    sortmode, width, debug_level, FALSE);
d641 1
a641 1
#ifndef HAVE_BIG_CORE
d646 2
a647 2
	!smart_defaults, FALSE,
	(check_only || infodump || capdump) ? NULLHOOK : immedhook);
d665 3
a667 3
			"warning: resolved %s entry is %d bytes long\n",
			_nc_first_name(qp->tterm.term_names),
			len);
d740 2
a741 2
		total,
		_nc_tic_dir((char *) 0));
d761 139
d924 9
a932 9
	num == 1,
	num == 2,
	num == 3,
	num == 4,
	num == 5,
	num == 6,
	num == 7,
	num == 8,
	num == 9);
d937 1
a937 1
		    _nc_visbuf(test));
d984 2
a985 2
			keyname(_nc_tinfo_fkeys[j].code),
			keyname(_nc_tinfo_fkeys[k].code));
d989 1
a989 1
			keyname(_nc_tinfo_fkeys[k].code));
d995 6
@


1.19
log
@Update to ncurses-5.0-20000325
@
text
@d45 1
a45 1
MODULE_ID("$From: tic.c,v 1.67 2000/03/19 02:08:10 tom Exp $")
d239 2
a240 2
	    namebuf = (namebuf != 0) ? realloc(namebuf, have) : malloc(have);
	    suffix = (suffix != 0) ? realloc(suffix, have) : malloc(have);
d331 1
a331 1
		dst = (const char **) calloc(nn + 1, sizeof(*dst));
d354 1
a354 1
		dst = (const char **) calloc(nn + 1, sizeof(*dst));
@


1.18
log
@update to ncurses-5.0-20000311
@
text
@d45 1
a45 1
MODULE_ID("$From: tic.c,v 1.64 2000/03/11 21:45:07 tom Exp $")
d94 3
d451 1
a451 1
		"0123456789CILNR:TVce:fGgo:rsvwx")) != -1) {
d527 3
d661 1
a661 1
	    for_entry_list(qp)
d663 2
a664 1
		write_it(qp);
d767 1
a767 1
check_sgr(TERMTYPE * tp, char *zero, int num, char *cap, char *name)
@


1.17
log
@Update to ncurses-5.0-20000304
@
text
@d45 1
a45 1
MODULE_ID("$From: tic.c,v 1.63 2000/03/05 04:33:15 tom Exp $")
d630 1
a630 1
	if (!_nc_resolve_uses() && !check_only) {
d680 1
a680 1
			len += dump_uses((char *) (qp->uses[j].parent), !capdump);
@


1.16
log
@Update to ncurses-5.0-20000115:
+ additional fixes for non-bce terminals (handling of delete_character)
to work when assume_default_colors() is not specified.
+ modify warning message from _nc_parse_entry() regarding extended
capability names to print only if tic/infocmp/toe have the -v flag
set, and not at all in ordinary user applications.  Otherwise, this
warning would be shown for screen's extended capabilities in programs
that use the termcap interface.
+ modify use of _nc_tracing from programs such as tic so their debug
level is not in the same range as values set by trace() function.
+ small panel header cleanup (patch by Juergen Pfeifer).
@
text
@d2 1
a2 1
 * Copyright (c) 1998-2000 Free Software Foundation, Inc.                   *
d45 1
a45 1
MODULE_ID("$From: tic.c,v 1.57 2000/01/15 21:44:28 tom Exp $")
d381 15
a409 1
    int fd;
d579 2
a580 3
		} else if (strcpy(my_tmpname, "/tmp/tic.XXXXXXXX")
		    && (fd = mkstemp(my_tmpname)) != -1
		    && (tmp_fp = fdopen(fd, "w")) != 0) {
d738 50
d844 2
a845 2
    PAIRED(set_foreground, set_background)
	PAIRED(set_a_foreground, set_a_background)
d851 6
a856 2
	ANDMISSING(cursor_invisible, cursor_normal)
	ANDMISSING(cursor_visible, cursor_normal)
d863 18
a880 2
	ANDMISSING(change_scroll_region, save_cursor)
	ANDMISSING(change_scroll_region, restore_cursor)
d888 1
a888 1
	if ((PRESENT(enter_insert_mode) || PRESENT(exit_insert_mode))
@


1.15
log
@usage() should go to stderr, not stdout.
@
text
@d2 1
a2 1
 * Copyright (c) 1998,1999 Free Software Foundation, Inc.                   *
d45 1
a45 1
MODULE_ID("$From: tic.c,v 1.55 1999/12/11 20:20:54 tom Exp $")
d521 1
a521 1
    _nc_tracing = (1 << debug_level) - 1;
@


1.14
log
@Update to ncurses-19991211:
 o treat as untranslatable to termcap those terminfo strings which
   contain non-decimal formatting, e.g., hexadecimal or octal.
 o correct commented-out capabilities that cannot be translated to
   termcap, which did not check if a colon must be escaped.
 o correct termcap translation for "%>" and "%+", which did not check
   if a colon must be escaped, for instance.
 o use save_string/save_char for _nc_captoinfo() to eliminate fixed
   buffer (originally for _nc_infotocap() in 960301 -TD).
 o correct expression used for terminfo equivalent of termcap %B,
   adjust regent100 entry which uses this.
 o some cleanup and commenting of ad hoc cases in _nc_infotocap().
 o eliminate a fixed-buffer in tic, used for translating comments.
 o add manpage for infotocap.
@
text
@d113 5
a117 3
    printf("Usage: %s %s\n", _nc_progname, usage_string);
    for (j = 0; j < sizeof(tbl) / sizeof(tbl[0]); j++)
	puts(tbl[j]);
@


1.13
log
@update to ncurses-5.0-19991204
@
text
@a0 2
/*	$OpenBSD: tic.c,v 1.12 1999/11/28 17:58:57 millert Exp $	*/

d45 1
a45 1
MODULE_ID("$From: tic.c,v 1.53 1999/12/04 22:45:52 tom Exp $")
d49 16
a64 15
static	FILE	*log_fp;
static	FILE	*tmp_fp;
static	bool	showsummary = FALSE;
static	const char *to_remove;

static	void	(*save_check_termtype)(TERMTYPE *);
static	void	check_termtype(TERMTYPE *tt);

static	const	char usage_string[] = "[-h] [-v[n]] [-e names] [-CILNRTcfrswx1] source-file\n";

static void cleanup(void)
{
	if (tmp_fp != 0)
		fclose(tmp_fp);
	if (to_remove != 0) {
d66 1
a66 1
		remove(to_remove);
d68 1
a68 1
		unlink(to_remove);
d70 1
a70 1
	}
d73 2
a74 1
static void failed(const char *msg)
d76 3
a78 3
	perror(msg);
	cleanup();
	exit(EXIT_FAILURE);
d81 2
a82 1
static void usage(void)
d84 2
a85 1
	static const char *const tbl[] = {
d110 2
a111 2
	};
	size_t j;
d113 4
a116 4
	printf("Usage: %s %s\n", _nc_progname, usage_string);
	for (j = 0; j < sizeof(tbl)/sizeof(tbl[0]); j++)
		puts(tbl[j]);
	exit(EXIT_FAILURE);
d123 2
a124 1
static void write_it(ENTRY *ep)
d126 34
a159 39
	unsigned n;
	int ch;
	char *s, *d, *t;
	char result[MAX_ENTRY_SIZE];

	/*
	 * Look for strings that contain %{number}, convert them to %'char',
	 * which is shorter and runs a little faster.
	 */
	for (n = 0; n < STRCOUNT; n++) {
		s = ep->tterm.Strings[n];
		if (VALID_STRING(s)
		 && strchr(s, L_BRACE) != 0) {
			d = result;
			t = s;
			while ((ch = *t++) != 0) {
				*d++ = ch;
				if (ch == '\\') {
					*d++ = *t++;
				} else if ((ch == '%')
				 && (*t == L_BRACE)) {
					char *v = 0;
					long value = strtol(t+1, &v, 0);
					if (v != 0
					 && *v == R_BRACE
					 && value > 0
					 && value != '\\'	/* FIXME */
					 && value < 127
					 && isprint((int)value)) {
						*d++ = S_QUOTE;
						*d++ = (int)value;
						*d++ = S_QUOTE;
						t = (v + 1);
					}
				}
			}
			*d = 0;
			if (strlen(result) < strlen(s))
				strcpy(s, result);
d161 4
d166 1
d168 3
a170 3
	_nc_set_type(_nc_first_name(ep->tterm.term_names));
	_nc_curr_line = ep->startline;
	_nc_write_entry(&ep->tterm);
d173 2
a174 1
static bool immedhook(ENTRY *ep GCC_UNUSED)
d211 2
a212 3
    if (ep->nuses == 0)
    {
	int	oldline = _nc_curr_line;
d217 1
a217 1
	return(TRUE);
d220 1
a220 1
    return(FALSE);
d223 2
a224 1
static void put_translate(int c)
d228 2
a229 1
    static char namebuf[132], suffix[132], *sp;
d231 5
a235 6
    if (!in_name)
    {
	if (c == '<')
	{
	    in_name = TRUE;
	    sp = namebuf;
d237 4
a240 1
	else
d242 17
a258 15
    }
    else if (c == '\n' || c == '@@')
    {
	*sp++ = '\0';
	(void) putchar('<');
	(void) fputs(namebuf, stdout);
	putchar(c);
	in_name = FALSE;
    }
    else if (c != '>')
	*sp++ = c;
    else		/* ah! candidate name! */
    {
	char	*up;
	NCURSES_CONST char *tp;
d260 12
a271 18
	*sp++ = '\0';
	in_name = FALSE;

	suffix[0] = '\0';
	if ((up = strchr(namebuf, '#')) != 0
	 || (up = strchr(namebuf, '=')) != 0
	 || ((up = strchr(namebuf, '@@')) != 0 && up[1] == '>'))
	{
	    (void) strcpy(suffix, up);
	    *up = '\0';
	}

	if ((tp = nametrans(namebuf)) != 0)
	{
	    (void) putchar(':');
	    (void) fputs(tp, stdout);
	    (void) fputs(suffix, stdout);
	    (void) putchar(':');
d273 6
a278 7
	else
	{
	    /* couldn't find a translation, just dump the name */
	    (void) putchar('<');
	    (void) fputs(namebuf, stdout);
	    (void) fputs(suffix, stdout);
	    (void) putchar('>');
a279 1

d284 2
a285 1
static char *stripped(char *src)
d287 10
a296 10
	while (isspace(*src))
		src++;
	if (*src != '\0') {
		char *dst = strcpy(malloc(strlen(src)+1), src);
		size_t len = strlen(dst);
		while (--len != 0 && isspace(dst[len]))
			dst[len] = '\0';
		return dst;
	}
	return 0;
d300 2
a301 1
static const char **make_namelist(char *src)
d303 1
a303 1
	const char **dst = 0;
d305 18
a322 24
	char *s, *base;
	unsigned pass, n, nn;
	char buffer[BUFSIZ];

	if (src == 0) {
		/* EMPTY */;
	} else if (strchr(src, '/') != 0) {	/* a filename */
		FILE *fp = fopen(src, "r");
		if (fp == 0)
			failed(src);

		for (pass = 1; pass <= 2; pass++) {
			nn = 0;
			while (fgets(buffer, sizeof(buffer), fp) != 0) {
				if ((s = stripped(buffer)) != 0) {
					if (dst != 0)
						dst[nn] = s;
					nn++;
				}
			}
			if (pass == 1) {
				dst = (const char **)calloc(nn+1, sizeof(*dst));
				rewind(fp);
			}
d324 20
a343 20
		fclose(fp);
	} else {			/* literal list of names */
		for (pass = 1; pass <= 2; pass++) {
			for (n = nn = 0, base = src; ; n++) {
				int mark = src[n];
				if (mark == ',' || mark == '\0') {
					if (pass == 1) {
						nn++;
					} else {
						src[n] = '\0';
						if ((s = stripped(base)) != 0)
							dst[nn++] = s;
						base = &src[n+1];
					}
				}
				if (mark == '\0')
					break;
			}
			if (pass == 1)
				dst = (const char **)calloc(nn+1, sizeof(*dst));
d345 5
d351 7
a357 6
	if (showsummary) {
		fprintf(log_fp, "Entries that will be compiled:\n");
		for (n = 0; dst[n] != 0; n++)
			fprintf(log_fp, "%d:%s\n", n+1, dst[n]);
	}
	return dst;
d360 2
a361 1
static bool matches(const char **needle, const char *haystack)
d364 2
a365 2
	bool code = FALSE;
	size_t n;
d367 6
a372 10
	if (needle != 0)
	{
		for (n = 0; needle[n] != 0; n++)
		{
			if (_nc_name_match(haystack, needle[n], "|"))
			{
				code = TRUE;
				break;
			}
		}
d374 3
a376 3
	else
		code = TRUE;
	return(code);
d379 2
a380 1
int main (int argc, char *argv[])
d382 40
a421 40
char	my_tmpname[PATH_MAX];
int	v_opt = -1, debug_level;
int	smart_defaults = TRUE;
char    *termcap;
ENTRY	*qp;

int	this_opt, last_opt = '?';

int	outform = F_TERMINFO;	/* output format */
int	sortmode = S_TERMINFO;	/* sort_mode */

int	fd;
int	width = 60;
bool	formatted = FALSE;	/* reformat complex strings? */
int	numbers = 0;		/* format "%'char'" to/from "%{number}" */
bool	infodump = FALSE;	/* running as captoinfo? */
bool	capdump = FALSE;	/* running as infotocap? */
bool	forceresolve = FALSE;	/* force resolution */
bool	limited = TRUE;
char	*tversion = (char *)NULL;
const	char	*source_file = "terminfo";
const	char	**namelst = 0;
char	*outdir = (char *)NULL;
bool	check_only = FALSE;

	log_fp = stderr;

	if ((_nc_progname = strrchr(argv[0], '/')) == NULL)
		_nc_progname = argv[0];
	else
		_nc_progname++;

	if ((infodump = (strcmp(_nc_progname, "captoinfo") == 0)) != FALSE) {
		outform  = F_TERMINFO;
		sortmode = S_TERMINFO;
	}
	if ((capdump = (strcmp(_nc_progname, "infotocap") == 0)) != FALSE) {
		outform  = F_TERMCAP;
		sortmode = S_TERMCAP;
	}
d423 1
a423 1
	use_extended_names(FALSE);
d426 81
a506 80
	/*
	 * Processing arguments is a little complicated, since someone made a
	 * design decision to allow the numeric values for -w, -v options to
	 * be optional.
	 */
	while ((this_opt = getopt(argc, argv, "0123456789CILNR:TVce:fGgo:rsvwx")) != -1) {
		if (isdigit(this_opt)) {
			switch (last_opt) {
			case 'v':
				v_opt = (v_opt * 10) + (this_opt - '0');
				break;
			case 'w':
				width = (width * 10) + (this_opt - '0');
				break;
			default:
				if (this_opt != '1')
					usage();
				last_opt = this_opt;
				width = 0;
			}
			continue;
		}
		switch (this_opt) {
		case 'C':
			capdump  = TRUE;
			outform  = F_TERMCAP;
			sortmode = S_TERMCAP;
			break;
		case 'I':
			infodump = TRUE;
			outform  = F_TERMINFO;
			sortmode = S_TERMINFO;
			break;
		case 'L':
			infodump = TRUE;
			outform  = F_VARIABLE;
			sortmode = S_VARIABLE;
			break;
		case 'N':
			smart_defaults = FALSE;
			break;
		case 'R':
			tversion = optarg;
			break;
		case 'T':
			limited = FALSE;
			break;
		case 'V':
			puts(NCURSES_VERSION);
			return EXIT_SUCCESS;
		case 'c':
			check_only = TRUE;
			break;
		case 'e':
			namelst = make_namelist(optarg);
			break;
		case 'f':
			formatted = TRUE;
			break;
		case 'G':
			numbers = 1;
			break;
		case 'g':
			numbers = -1;
			break;
		case 'o':
			outdir = optarg;
			break;
		case 'r':
			forceresolve = TRUE;
			break;
		case 's':
			showsummary = TRUE;
			break;
		case 'v':
			v_opt = 0;
			break;
		case 'w':
			width = 0;
			break;
d508 3
a510 3
		case 'x':
			use_extended_names(TRUE);
			break;
d512 2
a513 4
		default:
			usage();
		}
		last_opt = this_opt;
d515 2
d518 2
a519 8
	debug_level = (v_opt > 0) ? v_opt : (v_opt == 0);
	_nc_tracing = (1 << debug_level) - 1;

	if (_nc_tracing)
	{
		save_check_termtype = _nc_check_termtype;
		_nc_check_termtype = check_termtype;
	}
d521 4
d526 16
a541 17
	/*
	 * Aaargh! immedhook seriously hoses us!
	 *
	 * One problem with immedhook is it means we can't do -e.  Problem
	 * is that we can't guarantee that for each terminal listed, all the
	 * terminals it depends on will have been kept in core for reference
	 * resolution -- in fact it's certain the primitive types at the end
	 * of reference chains *won't* be in core unless they were explicitly
	 * in the select list themselves.
	 */
	if (namelst && (!infodump && !capdump))
	{
	    (void) fprintf(stderr,
			   "Sorry, -e can't be used without -I or -C\n");
	    cleanup();
	    return EXIT_FAILURE;
	}
d544 2
d547 25
a571 8
		source_file = argv[optind++];
		if (optind < argc) {
			fprintf (stderr,
				"%s: Too many file names.  Usage:\n\t%s %s",
				_nc_progname,
				_nc_progname,
				usage_string);
			return EXIT_FAILURE;
d573 1
d575 8
a582 30
		if (infodump == TRUE) {
			/* captoinfo's no-argument case */
			source_file = "/usr/share/misc/termcap";
			if ((termcap = getenv("TERMCAP")) != 0
			 && (namelst = make_namelist(getenv("TERM"))) != 0) {
				if (access(termcap, F_OK) == 0) {
					/* file exists */
					source_file = termcap;
				} else
				if (strcpy(my_tmpname, "/tmp/tic.XXXXXXXX")
				 && (fd = mkstemp(my_tmpname)) != -1
				 && (tmp_fp = fdopen(fd, "w")) != 0) {
					fprintf(tmp_fp, "%s\n", termcap);
					fclose(tmp_fp);
					tmp_fp = fopen(source_file, "r");
					to_remove = source_file;
				} else {
					failed("mkstemp");
				}
			}
		} else {
		/* tic */
			fprintf (stderr,
				"%s: File name needed.  Usage:\n\t%s %s",
				_nc_progname,
				_nc_progname,
				usage_string);
			cleanup();
			return EXIT_FAILURE;
		}
d584 7
d592 10
a601 16
	if (tmp_fp == 0
	 && (tmp_fp = fopen(source_file, "r")) == 0) {
		fprintf (stderr, "%s: Can't open %s\n", _nc_progname, source_file);
		return EXIT_FAILURE;
	}

	if (infodump)
		dump_init(tversion,
			  smart_defaults
				? outform
				: F_LITERAL,
			  sortmode, width, debug_level, formatted);
	else if (capdump)
		dump_init(tversion,
			  outform,
			  sortmode, width, debug_level, FALSE);
d603 2
a604 2
	/* parse entries out of the source file */
	_nc_set_source(source_file);
d606 2
a607 2
	if (!(check_only || infodump || capdump))
	    _nc_set_writedir(outdir);
d609 11
a619 3
	_nc_read_entry_source(tmp_fp, (char *)NULL,
			      !smart_defaults, FALSE,
			      (check_only || infodump || capdump) ? NULLHOOK : immedhook);
d621 11
a631 5
	/* do use resolution */
	if (check_only || (!infodump && !capdump) || forceresolve) {
	    if (!_nc_resolve_uses() && !check_only) {
		cleanup();
		return EXIT_FAILURE;
d634 1
d636 4
a639 3
	/* length check */
	if (check_only && (capdump || infodump))
	{
a640 1
	    {
d642 4
a645 2
		{
		    int	len = fmt_entry(&qp->tterm, NULL, TRUE, infodump, numbers);
d647 22
a668 5
		    if (len>(infodump?MAX_TERMINFO_LENGTH:MAX_TERMCAP_LENGTH))
			    (void) fprintf(stderr,
			   "warning: resolved %s entry is %d bytes long\n",
			   _nc_first_name(qp->tterm.term_names),
			   len);
d671 13
a683 56
	}

	/* write or dump all entries */
	if (!check_only)
	{
	    if (!infodump && !capdump)
	    {
		_nc_set_writedir(outdir);
		for_entry_list(qp)
		    if (matches(namelst, qp->tterm.term_names))
			write_it(qp);
	    }
	    else
	    {
		/* this is in case infotocap() generates warnings */
		_nc_curr_col = _nc_curr_line = -1;

		for_entry_list(qp)
		    if (matches(namelst, qp->tterm.term_names))
		    {
			int	j = qp->cend - qp->cstart;
			int	len = 0;

			/* this is in case infotocap() generates warnings */
			_nc_set_type(_nc_first_name(qp->tterm.term_names));

			(void) fseek(tmp_fp, qp->cstart, SEEK_SET);
			while (j-- )
			    if (infodump)
				(void) putchar(fgetc(tmp_fp));
			    else
				put_translate(fgetc(tmp_fp));

			len = dump_entry(&qp->tterm, limited, numbers, NULL);
			for (j = 0; j < qp->nuses; j++)
			    len += dump_uses((char *)(qp->uses[j].parent), !capdump);
			(void) putchar('\n');
			if (debug_level != 0 && !limited)
			    printf("# length=%d\n", len);
		    }
		if (!namelst)
		{
		    int  c, oldc = '\0';
		    bool in_comment = FALSE;
		    bool trailing_comment = FALSE;

		    (void) fseek(tmp_fp, _nc_tail->cend, SEEK_SET);
		    while ((c = fgetc(tmp_fp)) != EOF)
		    {
			if (oldc == '\n') {
			    if (c == '#') {
				trailing_comment = TRUE;
				in_comment = TRUE;
			    } else {
				in_comment = FALSE;
			    }
a684 4
			if (trailing_comment
			 && (in_comment || (oldc == '\n' && c == '\n')))
			    putchar(c);
			oldc = c;
d686 4
d693 1
d695 15
a709 15
	/* Show the directory into which entries were written, and the total
	 * number of entries
	 */
	if (showsummary
	 && (!(check_only || infodump || capdump))) {
		int total = _nc_tic_written();
		if (total != 0)
			fprintf(log_fp, "%d entries written to %s\n",
				total,
				_nc_tic_dir((char *)0));
		else
			fprintf(log_fp, "No entries written\n");
	}
	cleanup();
	return(EXIT_SUCCESS);
d718 1
a718 1
TERMINAL *cur_term;	/* tweak to avoid linking lib_cur_term.c */
d726 2
a727 1
static void check_termtype(TERMTYPE *tp)
d729 19
a747 14
	bool conflict = FALSE;
	unsigned j, k;
	char  fkeys[STRCOUNT];

	/*
	 * A terminal entry may contain more than one keycode assigned to
	 * a given string (e.g., KEY_END and KEY_LL).  But curses will only
	 * return one (the last one assigned).
	 */
	memset(fkeys, 0, sizeof(fkeys));
	for (j = 0; _nc_tinfo_fkeys[j].code; j++) {
	    char *a = tp->Strings[_nc_tinfo_fkeys[j].offset];
	    bool first = TRUE;
	    if (!VALID_STRING(a))
d749 7
a755 20
	    for (k = j+1; _nc_tinfo_fkeys[k].code; k++) {
		char *b = tp->Strings[_nc_tinfo_fkeys[k].offset];
		if (!VALID_STRING(b)
		 || fkeys[k])
		    continue;
		if (!strcmp(a,b)) {
		    fkeys[j] = 1;
		    fkeys[k] = 1;
		    if (first) {
			if (!conflict) {
			    _nc_warning("Conflicting key definitions (using the last)");
			    conflict = TRUE;
			}
			fprintf(stderr, "... %s is the same as %s",
				keyname(_nc_tinfo_fkeys[j].code),
				keyname(_nc_tinfo_fkeys[k].code));
			first = FALSE;
		    } else {
			fprintf(stderr, ", %s",
				keyname(_nc_tinfo_fkeys[k].code));
d757 7
a765 2
	    if (!first)
		fprintf(stderr, "\n");
d767 14
d782 21
a802 32
	/*
	 * Quick check for color.  We could also check if the ANSI versus
	 * non-ANSI strings are misused.
	 */
	if ((max_colors > 0) != (max_pairs > 0)
	 || (max_colors > max_pairs))
		_nc_warning("inconsistent values for max_colors and max_pairs");

	PAIRED(set_foreground,                  set_background)
	PAIRED(set_a_foreground,                set_a_background)

	/*
	 * These may be mismatched because the terminal description relies on
	 * restoring the cursor visibility by resetting it.
	 */
	ANDMISSING(cursor_invisible,            cursor_normal)
	ANDMISSING(cursor_visible,              cursor_normal)

	/*
	 * From XSI & O'Reilly, we gather that sc/rc are required if csr is
	 * given, because the cursor position after the scrolling operation is
	 * performed is undefined.
	 */
	ANDMISSING(change_scroll_region,	save_cursor)
	ANDMISSING(change_scroll_region,	restore_cursor)

	/*
	 * Some standard applications (e.g., vi) and some non-curses
	 * applications (e.g., jove) get confused if we have both ich/ich1 and
	 * smir/rmir.  Let's be nice and warn about that, too, even though
	 * ncurses handles it.
	 */
d804 3
a806 3
	 && (PRESENT(insert_character)  || PRESENT(parm_ich))) {
	   _nc_warning("non-curses applications may be confused by ich/ich1 with smir/rmir");
	}
d808 5
a812 5
	/*
	 * Finally, do the non-verbose checks
	 */
	if (save_check_termtype != 0)
	    save_check_termtype(tp);
@


1.12
log
@update to ncurses-5.0-19991127
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.11 1999/06/27 08:17:46 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: tic.c,v 1.52 1999/09/25 22:47:54 tom Exp $")
d413 8
a420 2
	infodump = (strcmp(_nc_progname, "captoinfo") == 0);
	capdump = (strcmp(_nc_progname, "infotocap") == 0);
@


1.11
log
@ncurses-5.0-990626
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.10 1999/03/22 18:43:19 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: tic.c,v 1.51 1999/06/19 21:35:36 Philippe.De.Muyter Exp $")
d668 1
a668 1
			    len += dump_uses((char *)(qp->uses[j].parent), infodump);
@


1.10
log
@back out local change that should not have escaped
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.9 1999/03/16 15:25:32 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: tic.c,v 1.50 1999/03/16 01:12:04 tom Exp $")
d65 2
a66 1
	if (to_remove != 0)
d68 4
@


1.9
log
@ncurses-4.2-990316
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.8 1999/03/11 21:08:10 millert Exp $	*/
d390 1
a390 1
bool	numbers = 0;		/* format "%'char'" to/from "%{number}" */
@


1.8
log
@Add -G flag; ncurses-4.2-990306
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.7 1999/03/02 06:23:55 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: tic.c,v 1.49 1999/03/07 01:21:14 tom Exp $")
d716 2
@


1.7
log
@ncurses-4.2-990301
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.6 1999/02/24 06:38:23 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: tic.c,v 1.48 1999/03/01 00:26:51 tom Exp $")
d89 1
d390 1
a390 1
bool	numbers = TRUE;		/* format "%'char'" to "%{number}" */
d419 1
a419 1
	while ((this_opt = getopt(argc, argv, "0123456789CILNR:TVce:fgo:rsvwx")) != EOF) {
d473 3
d477 1
a477 1
			numbers = FALSE;
@


1.6
log
@updates from ncurses-4.2-990220
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.5 1999/01/24 19:33:51 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d47 1
a47 1
MODULE_ID("$From: tic.c,v 1.45 1999/02/19 10:40:00 tom Exp $")
d59 1
a59 1
static	const	char usage_string[] = "[-h] [-v[n]] [-e names] [-CILNRTcfrsw1] source-file\n";
d96 3
a209 1
    else
d211 1
a211 1
	return(FALSE);
d409 3
d418 1
a418 1
	while ((this_opt = getopt(argc, argv, "0123456789CILNR:TVce:fgo:rsvw")) != EOF) {
d490 5
@


1.5
log
@updates from ncurses-4.2-990123
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.4 1999/01/18 18:57:52 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: tic.c,v 1.41 1999/01/24 02:55:48 tom Exp $")
d56 3
d494 6
d695 100
@


1.4
log
@updates from ncurses-4.2-990116
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.3 1998/12/28 05:54:44 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$Id: tic.c,v 1.40 1999/01/03 02:05:50 tom Exp $")
d158 1
a158 1
static bool immedhook(ENTRY *ep)
@


1.3
log
@don't dump core when invoked with no args; pavel_roskin@@geocities.com
@
text
@d1 1
a1 1
/*	$OpenBSD: tic.c,v 1.2 1998/11/03 21:59:53 millert Exp $	*/
d47 1
a47 1
MODULE_ID("$From: tic.c,v 1.38 1998/10/18 00:27:14 tom Exp $")
d491 20
a587 20

#ifndef HAVE_BIG_CORE
	/*
	 * Aaargh! immedhook seriously hoses us!
	 *
	 * One problem with immedhook is it means we can't do -e.  Problem
	 * is that we can't guarantee that for each terminal listed, all the
	 * terminals it depends on will have been kept in core for reference
	 * resolution -- in fact it's certain the primitive types at the end
	 * of reference chains *won't* be in core unless they were explicitly
	 * in the select list themselves.
	 */
	if (namelst && (!infodump && !capdump))
	{
	    (void) fprintf(stderr,
			   "Sorry, -e can't be used without -I or -C\n");
	    cleanup();
	    return EXIT_FAILURE;
	}
#endif /* HAVE_BIG_CORE */
@


1.2
log
@updated from ncurses-4.2-981017
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 2
a61 1
	fclose(tmp_fp);
@


1.1
log
@tic/captoinfo/infotocap from ncurses-4.2-980718
@
text
@d47 1
a47 1
MODULE_ID("$From: tic.c,v 1.30 1998/03/28 20:04:11 tom Exp $")
d52 1
d54 1
d58 14
d85 1
d104 53
d198 1
a198 3
	_nc_set_type(_nc_first_name(ep->tterm.term_names));
	_nc_curr_line = ep->startline;
	_nc_write_entry(&ep->tterm);
d291 1
a291 1
	size_t pass, n, nn;
d294 3
a296 1
	if (strchr(src, '/') != 0) {	/* a filename */
d298 3
a300 4
		if (fp == 0) {
			perror(src);
			exit(EXIT_FAILURE);
		}
d369 1
d380 1
d383 1
d409 1
a409 1
	while ((this_opt = getopt(argc, argv, "0123456789CILNR:TVce:fo:rsvw")) != EOF) {
d463 3
d503 3
a505 2
			source_file = "/etc/termcap";
			if ((termcap = getenv("TERMCAP")) != NULL) {
d509 10
d528 1
d533 2
a534 1
	if (freopen(source_file, "r", stdin) == NULL) {
d556 1
a556 1
	_nc_read_entry_source(stdin, (char *)NULL,
d561 3
a563 2
	if (check_only || (!infodump && !capdump) || forceresolve)
	    if (!_nc_resolve_uses() && !check_only)
d565 2
d583 1
d595 1
a595 1
		    int	len = fmt_entry(&qp->tterm, NULL, TRUE, infodump);
d614 1
a614 5
		    {
			_nc_set_type(_nc_first_name(qp->tterm.term_names));
			_nc_curr_line = qp->startline;
			_nc_write_entry(&qp->tterm);
		    }
d630 1
a630 1
			(void) fseek(stdin, qp->cstart, SEEK_SET);
d633 1
a633 1
				(void) putchar(getchar());
d635 1
a635 1
				put_translate(getchar());
d637 1
a637 1
			len = dump_entry(&qp->tterm, limited, NULL);
d650 2
a651 2
		    (void) fseek(stdin, _nc_tail->cend, SEEK_SET);
		    while ((c = getchar()) != EOF)
d683 1
@

