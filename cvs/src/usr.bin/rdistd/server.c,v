head	1.42;
access;
symbols
	OPENBSD_6_1:1.42.0.6
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.42.0.2
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.37.0.6
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.22.0.6
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.17.0.10
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.10
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.10
	OPENBSD_2_8:1.8.0.8
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.42
date	2016.03.30.20.51.59;	author millert;	state Exp;
branches;
next	1.41;
commitid	ume5fmOSwt4fBXqE;

1.41
date	2016.03.30.17.03.06;	author millert;	state Exp;
branches;
next	1.40;
commitid	TFGUN1b9tDywlO7H;

1.40
date	2015.12.22.08.48.39;	author mmcc;	state Exp;
branches;
next	1.39;
commitid	W22M9q9LQKpNifAI;

1.39
date	2015.12.22.08.22.33;	author mmcc;	state Exp;
branches;
next	1.38;
commitid	E4ooZsE11pj5vkOt;

1.38
date	2015.11.15.06.18.19;	author guenther;	state Exp;
branches;
next	1.37;
commitid	yTtMMDLYMvrYmv14;

1.37
date	2015.01.21.04.08.37;	author guenther;	state Exp;
branches;
next	1.36;
commitid	odBXDHtM07CJ1lov;

1.36
date	2015.01.21.03.18.31;	author guenther;	state Exp;
branches;
next	1.35;
commitid	yj8bO7Z9PXVbwqj2;

1.35
date	2015.01.20.09.00.16;	author guenther;	state Exp;
branches;
next	1.34;
commitid	0Y0sKBv6c3xIKoav;

1.34
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	Uu5nFG3wCl0LACBb;

1.33
date	2014.07.12.03.10.03;	author guenther;	state Exp;
branches;
next	1.32;
commitid	UQrxn7Tr7s8WKc1E;

1.32
date	2014.07.12.03.02.27;	author guenther;	state Exp;
branches;
next	1.31;
commitid	k3YJzgYkWouFBDB9;

1.31
date	2014.07.05.07.39.18;	author guenther;	state Exp;
branches;
next	1.30;
commitid	E4B0eQDx5RoYq5Bl;

1.30
date	2014.07.05.07.22.18;	author guenther;	state Exp;
branches;
next	1.29;
commitid	yx9CbZuQ0BTvpYrS;

1.29
date	2014.07.05.06.53.36;	author guenther;	state Exp;
branches;
next	1.28;
commitid	3v5IRXVPobEqlKhc;

1.28
date	2014.07.05.06.45.00;	author guenther;	state Exp;
branches;
next	1.27;
commitid	zoLIfEXn2KDMNucz;

1.27
date	2014.07.05.06.40.54;	author guenther;	state Exp;
branches;
next	1.26;
commitid	uXpuety4aU4qJWxx;

1.26
date	2014.07.05.06.39.13;	author guenther;	state Exp;
branches;
next	1.25;
commitid	1wp4j2vQSx7nWtxR;

1.25
date	2013.10.27.18.31.24;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2013.04.16.19.24.53;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2012.11.12.01.14.41;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.10.15.47.28;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.28.15.18.29;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.25.22.33.56;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.13.02.13.46;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.01.19.06.24;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.07.14.39.26;	author mpech;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.03.02.56.15;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.14.01.34.35;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.19.17.22.30;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.10.22.42.29;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.05.20.31.58;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	99.02.04.23.18.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.06.26.21.20.53;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.05.18.19.12.53;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.25.05.31.03;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.38.24;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.25.22.43.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.05.03.16.21;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.02.03.12.13.03;	author dm;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Avoid compiler warning about zero-length printf format strings.
Allow a NULL format in message() and switch the two calls to
error() and message() with an empty format string to using NULL.
OK deraadt@@
@
text
@/*	$OpenBSD: server.c,v 1.41 2016/03/30 17:03:06 millert Exp $	*/

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <grp.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "server.h"

/*
 * Server routines
 */

char	tempname[sizeof _RDIST_TMP + 1]; /* Tmp file name */
char	buf[BUFSIZ];		/* general purpose buffer */
char	target[PATH_MAX];	/* target/source directory name */
char	*ptarget;		/* pointer to end of target name */
int	catname = 0;		/* cat name to target name */
char	*sptarget[32];		/* stack of saved ptarget's for directories */
char   *fromhost = NULL;	/* Client hostname */
static int64_t min_freespace = 0; /* Minimium free space on a filesystem */
static int64_t min_freefiles = 0; /* Minimium free # files on a filesystem */
int	oumask;			/* Old umask */

static int cattarget(char *);
static int setownership(char *, int, uid_t, gid_t, int);
static int setfilemode(char *, int, int, int);
static int fchog(int, char *, char *, char *, int);
static int removefile(struct stat *, int);
static void doclean(char *);
static void clean(char *);
static void dospecial(char *);
static void docmdspecial(void);
static void query(char *);
static int chkparent(char *, opt_t);
static char *savetarget(char *, opt_t);
static void recvfile(char *, opt_t, int, char *, char *, time_t, time_t, off_t);
static void recvdir(opt_t, int, char *, char *);
static void recvlink(char *, opt_t, int, off_t);
static void hardlink(char *);
static void setconfig(char *);
static void recvit(char *, int);
static void dochmog(char *);
static void settarget(char *, int);

/*
 * Cat "string" onto the target buffer with error checking.
 */
static int
cattarget(char *string)
{
	if (strlen(string) + strlen(target) + 2 > sizeof(target)) {
		message(MT_INFO, "target buffer is not large enough.");
		return(-1);
	}
	if (!ptarget) {
		message(MT_INFO, "NULL target pointer set.");
		return(-10);
	}

	(void) snprintf(ptarget, sizeof(target) - (ptarget - target),
			"/%s", string);

	return(0);
}
	
/*
 * Set uid and gid ownership of a file.
 */
static int
setownership(char *file, int fd, uid_t uid, gid_t gid, int islink)
{
	static int is_root = -1;
	int status = -1;

	/*
	 * We assume only the Superuser can change uid ownership.
	 */
	switch (is_root) {
	case -1:
		is_root = getuid() == 0;
		if (is_root)
			break;
		/* FALLTHROUGH */
	case 0:
		uid = -1;
		break;
	case 1:
		break;
	}

	if (fd != -1 && !islink)
		status = fchown(fd, uid, gid);
	else
		status = fchownat(AT_FDCWD, file, uid, gid,
		    AT_SYMLINK_NOFOLLOW);

	if (status < 0) {
		if (uid == (uid_t)-1)
			message(MT_NOTICE, "%s: chgrp %d failed: %s",
				target, gid, SYSERR);
		else
			message(MT_NOTICE, "%s: chown %d:%d failed: %s", 
				target, uid, gid, SYSERR);
		return(-1);
	}

	return(0);
}

/*
 * Set mode of a file
 */
static int
setfilemode(char *file, int fd, int mode, int islink)
{
	int status = -1;

	if (mode == -1)
		return(0);

	if (islink)
		status = fchmodat(AT_FDCWD, file, mode, AT_SYMLINK_NOFOLLOW);

	if (fd != -1 && !islink)
		status = fchmod(fd, mode);

	if (status < 0 && !islink)
		status = chmod(file, mode);

	if (status < 0) {
		message(MT_NOTICE, "%s: chmod failed: %s", target, SYSERR);
		return(-1);
	}

	return(0);
}
/*
 * Change owner, group and mode of file.
 */
static int
fchog(int fd, char *file, char *owner, char *group, int mode)
{
	static struct group *gr = NULL;
	int i;
	struct stat st;
	uid_t uid;
	gid_t gid;
	gid_t primegid = (gid_t)-2;

	uid = userid;
	if (userid == 0) {	/* running as root; take anything */
		if (*owner == ':') {
			uid = (uid_t) atoi(owner + 1);
		} else if (pw == NULL || strcmp(owner, pw->pw_name) != 0) {
			if ((pw = getpwnam(owner)) == NULL) {
				if (mode != -1 && IS_ON(mode, S_ISUID)) {
					message(MT_NOTICE,
			      "%s: unknown login name \"%s\", clearing setuid",
						target, owner);
					mode &= ~S_ISUID;
					uid = 0;
				} else
					message(MT_NOTICE,
					"%s: unknown login name \"%s\"",
						target, owner);
			} else
				uid = pw->pw_uid;
		} else {
			uid = pw->pw_uid;
			primegid = pw->pw_gid;
		}
		if (*group == ':') {
			gid = (gid_t)atoi(group + 1);
			goto ok;
		}
	} else {	/* not root, setuid only if user==owner */
		struct passwd *lupw;

		if (mode != -1) {
			if (IS_ON(mode, S_ISUID) && 
			    strcmp(locuser, owner) != 0)
				mode &= ~S_ISUID;
			if (mode)
				mode &= ~S_ISVTX; /* and strip sticky too */
		}

		if ((lupw = getpwnam(locuser)) != NULL)
			primegid = lupw->pw_gid;
	}

	gid = (gid_t)-1;
	if (gr == NULL || strcmp(group, gr->gr_name) != 0) {
		if ((*group == ':' && 
		     (getgrgid(gid = atoi(group + 1)) == NULL))
		    || ((gr = (struct group *)getgrnam(group)) == NULL)) {
			if (mode != -1 && IS_ON(mode, S_ISGID)) {
				message(MT_NOTICE, 
				"%s: unknown group \"%s\", clearing setgid",
					target, group);
				mode &= ~S_ISGID;
			} else
				message(MT_NOTICE, 
					"%s: unknown group \"%s\"",
					target, group);
		} else
			gid = gr->gr_gid;
	} else
		gid = gr->gr_gid;

	if (userid && gid >= 0 && gid != primegid) {
		if (gr)
			for (i = 0; gr->gr_mem[i] != NULL; i++)
				if (strcmp(locuser, gr->gr_mem[i]) == 0)
					goto ok;
		if (mode != -1 && IS_ON(mode, S_ISGID)) {
			message(MT_NOTICE, 
				"%s: user %s not in group %s, clearing setgid",
				target, locuser, group);
			mode &= ~S_ISGID;
		}
		gid = (gid_t)-1;
	}
ok:
	if (stat(file, &st) == -1) {
		error("%s: Stat failed %s", file, SYSERR);
		return -1;
	}
	/*
	 * Set uid and gid ownership.  If that fails, strip setuid and
	 * setgid bits from mode.  Once ownership is set, successful
	 * or otherwise, set the new file mode.
	 */
	if (setownership(file, fd, uid, gid, S_ISLNK(st.st_mode)) < 0) {
		if (mode != -1 && IS_ON(mode, S_ISUID)) {
			message(MT_NOTICE, 
				"%s: chown failed, clearing setuid", target);
			mode &= ~S_ISUID;
		}
		if (mode != -1 && IS_ON(mode, S_ISGID)) {
			message(MT_NOTICE, 
				"%s: chown failed, clearing setgid", target);
			mode &= ~S_ISGID;
		}
	}
	(void) setfilemode(file, fd, mode, S_ISLNK(st.st_mode));


	return(0);
}

/*
 * Remove a file or directory (recursively) and send back an acknowledge
 * or an error message.
 */
static int
removefile(struct stat *statb, int silent)
{
	DIR *d;
	static struct dirent *dp;
	char *cp;
	struct stat stb;
	char *optarget;
	int len, failures = 0;

	switch (statb->st_mode & S_IFMT) {
	case S_IFREG:
	case S_IFLNK:
	case S_IFCHR:
	case S_IFBLK:
	case S_IFSOCK:
	case S_IFIFO:
		if (unlink(target) < 0) {
			if (errno == ETXTBSY) {
				if (!silent)
					message(MT_REMOTE|MT_NOTICE, 
						"%s: unlink failed: %s",
						target, SYSERR);
				return(0);
			} else {
				error("%s: unlink failed: %s", target, SYSERR);
				return(-1);
			}
		}
		goto removed;

	case S_IFDIR:
		break;

	default:
		error("%s: not a plain file", target);
		return(-1);
	}

	errno = 0;
	if ((d = opendir(target)) == NULL) {
		error("%s: opendir failed: %s", target, SYSERR);
		return(-1);
	}

	optarget = ptarget;
	len = ptarget - target;
	while ((dp = readdir(d)) != NULL) {
		if (dp->d_name[0] == '.' && (dp->d_name[1] == '\0' ||
		    (dp->d_name[1] == '.' && dp->d_name[2] == '\0')))
			continue;

		if (len + 1 + (int)strlen(dp->d_name) >= PATH_MAX - 1) {
			if (!silent)
				message(MT_REMOTE|MT_WARNING, 
					"%s/%s: Name too long", 
					target, dp->d_name);
			continue;
		}
		ptarget = optarget;
		*ptarget++ = '/';
		cp = dp->d_name;
		while ((*ptarget++ = *cp++) != '\0')
			continue;
		ptarget--;
		if (lstat(target, &stb) < 0) {
			if (!silent)
				message(MT_REMOTE|MT_WARNING,
					"%s: lstat failed: %s", 
					target, SYSERR);
			continue;
		}
		if (removefile(&stb, 0) < 0)
			++failures;
	}
	(void) closedir(d);
	ptarget = optarget;
	*ptarget = CNULL;

	if (failures)
		return(-1);

	if (rmdir(target) < 0) {
		error("%s: rmdir failed: %s", target, SYSERR);
		return(-1);
	}
removed:
#if NEWWAY
	if (!silent)
		message(MT_CHANGE|MT_REMOTE, "%s: removed", target);
#else
	/*
	 * We use MT_NOTICE instead of MT_CHANGE because this function is
	 * sometimes called by other functions that are suppose to return a
	 * single ack() back to the client (rdist).  This is a kludge until
	 * the Rdist protocol is re-done.  Sigh.
	 */
	message(MT_NOTICE|MT_REMOTE, "%s: removed", target);
#endif
	return(0);
}

/*
 * Check the current directory (initialized by the 'T' command to server())
 * for extraneous files and remove them.
 */
static void
doclean(char *cp)
{
	DIR *d;
	struct dirent *dp;
	struct stat stb;
	char *optarget, *ep;
	int len;
	opt_t opts;
	char targ[PATH_MAX*4];

	opts = strtol(cp, &ep, 8);
	if (*ep != CNULL) {
		error("clean: options not delimited");
		return;
	}
	if ((d = opendir(target)) == NULL) {
		error("%s: opendir failed: %s", target, SYSERR);
		return;
	}
	ack();

	optarget = ptarget;
	len = ptarget - target;
	while ((dp = readdir(d)) != NULL) {
		if (dp->d_name[0] == '.' && (dp->d_name[1] == '\0' ||
		    (dp->d_name[1] == '.' && dp->d_name[2] == '\0')))
			continue;

		if (len + 1 + (int)strlen(dp->d_name) >= PATH_MAX - 1) {
			message(MT_REMOTE|MT_WARNING, "%s/%s: Name too long", 
				target, dp->d_name);
			continue;
		}
		ptarget = optarget;
		*ptarget++ = '/';
		cp = dp->d_name;
		while ((*ptarget++ = *cp++) != '\0')
			continue;
		ptarget--;
		if (lstat(target, &stb) < 0) {
			message(MT_REMOTE|MT_WARNING, "%s: lstat failed: %s", 
				target, SYSERR);
			continue;
		}

		ENCODE(targ, dp->d_name);
		(void) sendcmd(CC_QUERY, "%s", targ);
		(void) remline(cp = buf, sizeof(buf), TRUE);

		if (*cp != CC_YES)
			continue;

		if (IS_ON(opts, DO_VERIFY))
			message(MT_REMOTE|MT_INFO, "%s: need to remove", 
				target);
		else
			(void) removefile(&stb, 0);
	}
	(void) closedir(d);

	ptarget = optarget;
	*ptarget = CNULL;
}

/*
 * Frontend to doclean().
 */
static void
clean(char *cp)
{
	doclean(cp);
	(void) sendcmd(CC_END, NULL);
	(void) response();
}

/*
 * Execute a shell command to handle special cases.
 * We can't really set an alarm timeout here since we
 * have no idea how long the command should take.
 */
static void
dospecial(char *xcmd)
{
	char cmd[BUFSIZ];
	if (DECODE(cmd, xcmd) == -1) {
		error("dospecial: Cannot decode command.");
		return;
	}
	runcommand(cmd);
}

/*
 * Do a special cmd command.  This differs from normal special
 * commands in that it's done after an entire command has been updated.
 * The list of updated target files is sent one at a time with RC_FILE
 * commands.  Each one is added to an environment variable defined by
 * E_FILES.  When an RC_COMMAND is finally received, the E_FILES variable
 * is stuffed into our environment and a normal dospecial() command is run.
 */
static void
docmdspecial(void)
{
	char *cp;
	char *cmd, *env = NULL;
	int n;
	size_t len;

	/* We're ready */
	ack();

	for ( ; ; ) {
		n = remline(cp = buf, sizeof(buf), FALSE);
		if (n <= 0) {
			error("cmdspecial: premature end of input.");
			return;
		}

		switch (*cp++) {
		case RC_FILE:
			if (env == NULL) {
				len = (2 * sizeof(E_FILES)) + strlen(cp) + 10;
				env = xmalloc(len);
				(void) snprintf(env, len, "export %s;%s=%s", 
					       E_FILES, E_FILES, cp);
			} else {
				len = strlen(env) + 1 + strlen(cp) + 1;
				env = xrealloc(env, len);
				(void) strlcat(env, ":", len);
				(void) strlcat(env, cp, len);
			}
			ack();
			break;

		case RC_COMMAND:
			if (env) {
				len = strlen(env) + 1 + strlen(cp) + 1;
				env = xrealloc(env, len);
				(void) strlcat(env, ";", len);
				(void) strlcat(env, cp, len);
				cmd = env;
			} else
				cmd = cp;

			dospecial(cmd);
			if (env)
				(void) free(env);
			return;

		default:
			error("Unknown cmdspecial command '%s'.", cp);
			return;
		}
	}
}

/*
 * Query. Check to see if file exists. Return one of the following:
 *
 *  QC_ONNFS		- resides on a NFS
 *  QC_ONRO		- resides on a Read-Only filesystem
 *  QC_NO		- doesn't exist
 *  QC_YESsize mtime 	- exists and its a regular file (size & mtime of file)
 *  QC_YES		- exists and its a directory or symbolic link
 *  QC_ERRMSGmessage 	- error message
 */
static void
query(char *xname)
{
	static struct stat stb;
	int s = -1, stbvalid = 0;
	char name[PATH_MAX];

	if (DECODE(name, xname) == -1) {
		error("query: Cannot decode filename");
		return;
	}

	if (catname && cattarget(name) < 0)
		return;

	if (IS_ON(options, DO_CHKNFS)) {
		s = is_nfs_mounted(target, &stb, &stbvalid);
		if (s > 0)
			(void) sendcmd(QC_ONNFS, NULL);

		/* Either the above check was true or an error occurred */
		/* and is_nfs_mounted sent the error message */
		if (s != 0) {
			*ptarget = CNULL;
			return;
		}
	}

	if (IS_ON(options, DO_CHKREADONLY)) {
		s = is_ro_mounted(target, &stb, &stbvalid);
		if (s > 0)
			(void) sendcmd(QC_ONRO, NULL);

		/* Either the above check was true or an error occurred */
		/* and is_ro_mounted sent the error message */
		if (s != 0) {
			*ptarget = CNULL;
			return;
		}
	}

	if (IS_ON(options, DO_CHKSYM)) {
		if (is_symlinked(target, &stb, &stbvalid) > 0) {
			(void) sendcmd(QC_SYM, NULL);
			return;
		}
	}

	/*
	 * If stbvalid is false, "stb" is not valid because the stat()
	 * by is_*_mounted() either failed or does not match "target".
	 */
	if (!stbvalid && lstat(target, &stb) < 0) {
		if (errno == ENOENT)
			(void) sendcmd(QC_NO, NULL);
		else
			error("%s: lstat failed: %s", target, SYSERR);
		*ptarget = CNULL;
		return;
	}

	switch (stb.st_mode & S_IFMT) {
	case S_IFLNK:
	case S_IFDIR:
	case S_IFREG:
		(void) sendcmd(QC_YES, "%lld %lld %o %s %s",
			       (long long) stb.st_size,
			       (long long) stb.st_mtime,
			       stb.st_mode & 07777,
			       getusername(stb.st_uid, target, options), 
			       getgroupname(stb.st_gid, target, options));
		break;

	default:
		error("%s: not a file or directory", target);
		break;
	}
	*ptarget = CNULL;
}

/*
 * Check to see if parent directory exists and create one if not.
 */
static int
chkparent(char *name, opt_t opts)
{
	char *cp;
	struct stat stb;
	int r = -1;

	debugmsg(DM_CALL, "chkparent(%s, %#x) start\n", name, opts);

	cp = strrchr(name, '/');
	if (cp == NULL || cp == name)
		return(0);

	*cp = CNULL;

	if (lstat(name, &stb) < 0) {
		if (errno == ENOENT && chkparent(name, opts) >= 0) {
			if (mkdir(name, 0777 & ~oumask) == 0) {
				message(MT_NOTICE, "%s: mkdir", name);
				r = 0;
			} else 
				debugmsg(DM_MISC, 
					 "chkparent(%s, %#04o) mkdir fail: %s\n",
					 name, opts, SYSERR);
		}
	} else	/* It exists */
		r = 0;

	/* Put back what we took away */
	*cp = '/';

	return(r);
}

/*
 * Save a copy of 'file' by renaming it.
 */
static char *
savetarget(char *file, opt_t opts)
{
	static char savefile[PATH_MAX];

	if (strlen(file) + sizeof(SAVE_SUFFIX) + 1 > PATH_MAX) {
		error("%s: Cannot save: Save name too long", file);
		return(NULL);
	}

	if (IS_ON(opts, DO_HISTORY)) {
		int i;
		struct stat st;
		/*
		 * There is a race here, but the worst that can happen
		 * is to lose a version of the file
		 */
		for (i = 1; i < 1000; i++) {
			(void) snprintf(savefile, sizeof(savefile),
					"%s;%.3d", file, i);
			if (lstat(savefile, &st) == -1 && errno == ENOENT)
				break;

		}
		if (i == 1000) {
			message(MT_NOTICE, 
			    "%s: More than 1000 versions for %s; reusing 1\n",
				savefile, SYSERR);
			i = 1;
			(void) snprintf(savefile, sizeof(savefile),
					"%s;%.3d", file, i);
		}
	}
	else {
		(void) snprintf(savefile, sizeof(savefile), "%s%s",
				file, SAVE_SUFFIX);

		if (unlink(savefile) != 0 && errno != ENOENT) {
			message(MT_NOTICE, "%s: remove failed: %s",
				savefile, SYSERR);
			return(NULL);
		}
	}

	if (rename(file, savefile) != 0 && errno != ENOENT) {
		error("%s -> %s: rename failed: %s", 
		      file, savefile, SYSERR);
		return(NULL);
	}

	return(savefile);
}

/*
 * Receive a file
 */
static void
recvfile(char *new, opt_t opts, int mode, char *owner, char *group,
	 time_t mtime, time_t atime, off_t size)
{
	int f, wrerr, olderrno;
	off_t i;
	char *cp;
	char *savefile = NULL;
	static struct stat statbuff;

	/*
	 * Create temporary file
	 */
	if (chkparent(new, opts) < 0 || (f = mkstemp(new)) < 0) {
		error("%s: create failed: %s", new, SYSERR);
		return;
	}

	/*
	 * Receive the file itself
	 */
	ack();
	wrerr = 0;
	olderrno = 0;
	for (i = 0; i < size; i += BUFSIZ) {
		off_t amt = BUFSIZ;

		cp = buf;
		if (i + amt > size)
			amt = size - i;
		do {
			ssize_t j;

			j = readrem(cp, amt);
			if (j <= 0) {
				(void) close(f);
				(void) unlink(new);
				fatalerr(
				   "Read error occurred while receiving file.");
				finish();
			}
			amt -= j;
			cp += j;
		} while (amt > 0);
		amt = BUFSIZ;
		if (i + amt > size)
			amt = size - i;
		if (wrerr == 0 && xwrite(f, buf, amt) != amt) {
			olderrno = errno;
			wrerr++;
		}
	}

	if (response() < 0) {
		(void) close(f);
		(void) unlink(new);
		return;
	}

	if (wrerr) {
		error("%s: Write error: %s", new, strerror(olderrno));
		(void) close(f);
		(void) unlink(new);
		return;
	}

	/*
	 * Do file comparison if enabled
	 */
	if (IS_ON(opts, DO_COMPARE)) {
		FILE *f1, *f2;
		int c;

		errno = 0;	/* fopen is not a syscall */
		if ((f1 = fopen(target, "r")) == NULL) {
			error("%s: open for read failed: %s", target, SYSERR);
			(void) close(f);
			(void) unlink(new);
			return;
		}
		errno = 0;
		if ((f2 = fopen(new, "r")) == NULL) {
			error("%s: open for read failed: %s", new, SYSERR);
			(void) fclose(f1);
			(void) close(f);
			(void) unlink(new);
			return;
		}
		while ((c = getc(f1)) == getc(f2))
			if (c == EOF) {
				debugmsg(DM_MISC, 
					 "Files are the same '%s' '%s'.",
					 target, new);
				(void) fclose(f1);
				(void) fclose(f2);
				(void) close(f);
				(void) unlink(new);
				/*
				 * This isn't an error per-se, but we
				 * need to indicate to the master that
				 * the file was not updated.
				 */
				error(NULL);
				return;
			}
		debugmsg(DM_MISC, "Files are different '%s' '%s'.",
			 target, new);
		(void) fclose(f1);
		(void) fclose(f2);
		if (IS_ON(opts, DO_VERIFY)) {
			message(MT_REMOTE|MT_INFO, "%s: need to update", 
				target);
			(void) close(f);
			(void) unlink(new);
			return;
		}
	}

	/*
	 * Set owner, group, and file mode
	 */
	if (fchog(f, new, owner, group, mode) < 0) {
		(void) close(f);
		(void) unlink(new);
		return;
	}
	(void) close(f);

	/*
	 * Perform utimes() after file is closed to make
	 * certain OS's, such as NeXT 2.1, happy.
	 */
	if (setfiletime(new, time(NULL), mtime) < 0)
		message(MT_NOTICE, "%s: utimes failed: %s", new, SYSERR);

	/*
	 * Try to save target file from being over-written
	 */
	if (IS_ON(opts, DO_SAVETARGETS))
		if ((savefile = savetarget(target, opts)) == NULL) {
			(void) unlink(new);
			return;
		}

	/*
	 * If the target is a directory, we need to remove it first
	 * before we can rename the new file.
	 */
	if ((stat(target, &statbuff) == 0) && S_ISDIR(statbuff.st_mode)) {
		char *saveptr = ptarget;

		ptarget = &target[strlen(target)];
		removefile(&statbuff, 0);
		ptarget = saveptr;
	}

	/*
	 * Install new (temporary) file as the actual target
	 */
	if (rename(new, target) < 0) {
		static const char fmt[] = "%s -> %s: rename failed: %s";
		struct stat stb;
		/*
		 * If the rename failed due to "Text file busy", then
		 * try to rename the target file and retry the rename.
		 */
		switch (errno) {
		case ETXTBSY:
			/* Save the target */
			if ((savefile = savetarget(target, opts)) != NULL) {
				/* Retry installing new file as target */
				if (rename(new, target) < 0) {
					error(fmt, new, target, SYSERR);
					/* Try to put back save file */
					if (rename(savefile, target) < 0)
						error(fmt,
						      savefile, target, SYSERR);
					(void) unlink(new);
				} else
					message(MT_NOTICE, "%s: renamed to %s",
						target, savefile);
				/*
				 * XXX: We should remove the savefile here.
				 *	But we are nice to nfs clients and
				 *	we keep it.
				 */
			}
			break;
		case EISDIR:
			/*
			 * See if target is a directory and remove it if it is
			 */
			if (lstat(target, &stb) == 0) {
				if (S_ISDIR(stb.st_mode)) {
					char *optarget = ptarget;
					for (ptarget = target; *ptarget;
						ptarget++);
					/* If we failed to remove, we'll catch
					   it later */
					(void) removefile(&stb, 1);
					ptarget = optarget;
				}
			}
			if (rename(new, target) >= 0)
				break;
			/*FALLTHROUGH*/

		default:
			error(fmt, new, target, SYSERR);
			(void) unlink(new);
			break;
		}
	}

	if (IS_ON(opts, DO_COMPARE))
		message(MT_REMOTE|MT_CHANGE, "%s: updated", target);
	else
		ack();
}

/*
 * Receive a directory
 */
static void
recvdir(opt_t opts, int mode, char *owner, char *group)
{
	static char lowner[100], lgroup[100];
	char *cp;
	struct stat stb;
	int s;

	s = lstat(target, &stb);
	if (s == 0) {
		/*
		 * If target is not a directory, remove it
		 */
		if (!S_ISDIR(stb.st_mode)) {
			if (IS_ON(opts, DO_VERIFY))
				message(MT_NOTICE, "%s: need to remove",
					target);
			else {
				if (unlink(target) < 0) {
					error("%s: remove failed: %s",
					      target, SYSERR);
					return;
				}
			}
			s = -1;
			errno = ENOENT;
		} else {
			if (!IS_ON(opts, DO_NOCHKMODE) &&
			    (stb.st_mode & 07777) != mode) {
				if (IS_ON(opts, DO_VERIFY))
					message(MT_NOTICE, 
						"%s: need to chmod to %#04o",
						target, mode);
				else if (chmod(target, mode) != 0)
					message(MT_NOTICE,
				  "%s: chmod from %#04o to %#04o failed: %s",
						target, 
						stb.st_mode & 07777, 
						mode,
						SYSERR);
				else
					message(MT_NOTICE,
						"%s: chmod from %#04o to %#04o",
						target, 
						stb.st_mode & 07777, 
						mode);
			}

			/*
			 * Check ownership and set if necessary
			 */
			lowner[0] = CNULL;
			lgroup[0] = CNULL;

			if (!IS_ON(opts, DO_NOCHKOWNER) && owner) {
				int o;

				o = (owner[0] == ':') ? opts & DO_NUMCHKOWNER :
					opts;
				if ((cp = getusername(stb.st_uid, target, o))
				    != NULL)
					if (strcmp(owner, cp))
						(void) strlcpy(lowner, cp,
						    sizeof(lowner));
			}
			if (!IS_ON(opts, DO_NOCHKGROUP) && group) {
				int o;

				o = (group[0] == ':') ? opts & DO_NUMCHKGROUP :
					opts;
				if ((cp = getgroupname(stb.st_gid, target, o))
				    != NULL)
					if (strcmp(group, cp))
						(void) strlcpy(lgroup, cp,
						    sizeof(lgroup));
			}

			/*
			 * Need to set owner and/or group
			 */
#define PRN(n) ((n[0] == ':') ? n+1 : n)
			if (lowner[0] != CNULL || lgroup[0] != CNULL) {
				if (lowner[0] == CNULL && 
				    (cp = getusername(stb.st_uid, 
						      target, opts)))
					(void) strlcpy(lowner, cp,
					    sizeof(lowner));
				if (lgroup[0] == CNULL && 
				    (cp = getgroupname(stb.st_gid, 
						       target, opts)))
					(void) strlcpy(lgroup, cp,
					    sizeof(lgroup));

				if (IS_ON(opts, DO_VERIFY))
					message(MT_NOTICE,
				"%s: need to chown from %s:%s to %s:%s",
						target, 
						PRN(lowner), PRN(lgroup),
						PRN(owner), PRN(group));
				else {
					if (fchog(-1, target, owner, 
						  group, -1) == 0)
						message(MT_NOTICE,
					       "%s: chown from %s:%s to %s:%s",
							target,
							PRN(lowner), 
							PRN(lgroup),
							PRN(owner), 
							PRN(group));
				}
			}
#undef PRN
			ack();
			return;
		}
	}

	if (IS_ON(opts, DO_VERIFY)) {
		ack();
		return;
	}

	/*
	 * Create the directory
	 */
	if (s < 0) {
		if (errno == ENOENT) {
			if (mkdir(target, mode) == 0 ||
			    (chkparent(target, opts) == 0 && 
			    mkdir(target, mode) == 0)) {
				message(MT_NOTICE, "%s: mkdir", target);
				(void) fchog(-1, target, owner, group, mode);
				ack();
			} else {
				error("%s: mkdir failed: %s", target, SYSERR);
				ptarget = sptarget[--catname];
				*ptarget = CNULL;
			}
			return;
		}
	}
	error("%s: lstat failed: %s", target, SYSERR);
	ptarget = sptarget[--catname];
	*ptarget = CNULL;
}

/*
 * Receive a link
 */
static void
recvlink(char *new, opt_t opts, int mode, off_t size)
{
	char tbuf[PATH_MAX], dbuf[BUFSIZ];
	struct stat stb;
	char *optarget;
	int uptodate;
	off_t i;

	/*
	 * Read basic link info
	 */
	ack();
	(void) remline(buf, sizeof(buf), TRUE);

	if (response() < 0) {
		err();
		return;
	}

	if (DECODE(dbuf, buf) == -1) {
		error("recvlink: cannot decode symlink target");
		return;
	}

	uptodate = 0;
	if ((i = readlink(target, tbuf, sizeof(tbuf)-1)) != -1) {
		tbuf[i] = '\0';
		if (i == size && strncmp(dbuf, tbuf, (int) size) == 0)
			uptodate = 1;
	}
	mode &= 0777;

	if (IS_ON(opts, DO_VERIFY) || uptodate) {
		if (uptodate)
			message(MT_REMOTE|MT_INFO, NULL);
		else
			message(MT_REMOTE|MT_INFO, "%s: need to update",
				target);
		if (IS_ON(opts, DO_COMPARE))
			return;
		(void) sendcmd(C_END, NULL);
		(void) response();
		return;
	}

	/*
	 * Make new symlink using a temporary name
	 */
	if (chkparent(new, opts) < 0 || mktemp(new) == NULL ||
	    symlink(dbuf, new) < 0) {
		error("%s -> %s: symlink failed: %s", new, dbuf, SYSERR);
		return;
	}

	/*
	 * See if target is a directory and remove it if it is
	 */
	if (lstat(target, &stb) == 0) {
		if (S_ISDIR(stb.st_mode)) {
			optarget = ptarget;
			for (ptarget = target; *ptarget; ptarget++);
			if (removefile(&stb, 0) < 0) {
				ptarget = optarget;
				(void) unlink(new);
				(void) sendcmd(C_END, NULL);
				(void) response();
				return;
			}
			ptarget = optarget;
		}
	}

	/*
	 * Install link as the target
	 */
	if (rename(new, target) < 0) {
		error("%s -> %s: symlink rename failed: %s",
		      new, target, SYSERR);
		(void) unlink(new);
		(void) sendcmd(C_END, NULL);
		(void) response();
		return;
	}

	message(MT_REMOTE|MT_CHANGE, "%s: updated", target);

	/*
	 * Indicate end of receive operation
	 */
	(void) sendcmd(C_END, NULL);
	(void) response();
}

/*
 * Creat a hard link to existing file.
 */
static void
hardlink(char *cmd)
{
	struct stat stb;
	int exists = 0;
	char *xoldname, *xnewname;
	char *cp = cmd;
	static char expbuf[BUFSIZ];
	char oldname[BUFSIZ], newname[BUFSIZ];

	/* Skip over opts */
	(void) strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("hardlink: options not delimited");
		return;
	}

	xoldname = strtok(cp, " ");
	if (xoldname == NULL) {
		error("hardlink: oldname name not delimited");
		return;
	}

	if (DECODE(oldname, xoldname) == -1) {
		error("hardlink: Cannot decode oldname");
		return;
	}

	xnewname = strtok(NULL, " ");
	if (xnewname == NULL) {
		error("hardlink: new name not specified");
		return;
	}

	if (DECODE(newname, xnewname) == -1) {
		error("hardlink: Cannot decode newname");
		return;
	}

	if (exptilde(expbuf, oldname, sizeof(expbuf)) == NULL) {
		error("hardlink: tilde expansion failed");
		return;
	}

	if (catname && cattarget(newname) < 0) {
		error("Cannot set newname target.");
		return;
	}

	if (lstat(target, &stb) == 0) {
		int mode = stb.st_mode & S_IFMT;

		if (mode != S_IFREG && mode != S_IFLNK) {
			error("%s: not a regular file", target);
			return;
		}
		exists = 1;
	}

	if (chkparent(target, options) < 0 ) {
		error("%s: no parent: %s ", target, SYSERR);
		return;
	}
	if (exists && (unlink(target) < 0)) {
		error("%s: unlink failed: %s", target, SYSERR);
		return;
	}
	if (linkat(AT_FDCWD, expbuf, AT_FDCWD, target, 0) < 0) {
		error("%s: cannot link to %s: %s", target, oldname, SYSERR);
		return;
	}
	ack();
}

/*
 * Set configuration information.
 *
 * A key letter is followed immediately by the value
 * to set.  The keys are:
 *	SC_FREESPACE	- Set minimium free space of filesystem
 *	SC_FREEFILES	- Set minimium free number of files of filesystem
 */
static void
setconfig(char *cmd)
{
	char *cp = cmd;
	char *estr;
	const char *errstr;

	switch (*cp++) {
	case SC_HOSTNAME:	/* Set hostname */
		/*
		 * Only use info if we don't know who this is.
		 */
		if (!fromhost) {
			fromhost = xstrdup(cp);
			message(MT_SYSLOG, "startup for %s", fromhost);
			setproctitle("serving %s", cp);
		}
		break;

	case SC_FREESPACE: 	/* Minimium free space */
		min_freespace = (int64_t)strtonum(cp, 0, LLONG_MAX, &errstr);
		if (errstr)
			fatalerr("Minimum free space is %s: '%s'", errstr,
				optarg);
		break;

	case SC_FREEFILES: 	/* Minimium free files */
		min_freefiles = (int64_t)strtonum(cp, 0, LLONG_MAX, &errstr);
		if (errstr)
			fatalerr("Minimum free files is %s: '%s'", errstr,
				optarg);
		break;

	case SC_LOGGING:	/* Logging options */
		if ((estr = msgparseopts(cp, TRUE)) != NULL) {
			fatalerr("Bad message option string (%s): %s", 
				 cp, estr);
			return;
		}
		break;

	case SC_DEFOWNER:
		(void) strlcpy(defowner, cp, sizeof(defowner));
		break;

	case SC_DEFGROUP:
		(void) strlcpy(defgroup, cp, sizeof(defgroup));
		break;

	default:
		message(MT_NOTICE, "Unknown config command \"%s\".", cp-1);
		return;
	}
}

/*
 * Receive something
 */
static void
recvit(char *cmd, int type)
{
	int mode;
	opt_t opts;
	off_t size;
	time_t mtime, atime;
	char *owner, *group, *file;
	char new[PATH_MAX];
	char fileb[PATH_MAX];
	int64_t freespace = -1, freefiles = -1;
	char *cp = cmd;

	/*
	 * Get rdist option flags
	 */
	opts = strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("recvit: options not delimited");
		return;
	}

	/*
	 * Get file mode
	 */
	mode = strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("recvit: mode not delimited");
		return;
	}

	/*
	 * Get file size
	 */
	size = (off_t) strtoll(cp, &cp, 10);
	if (*cp++ != ' ') {
		error("recvit: size not delimited");
		return;
	}

	/*
	 * Get modification time
	 */
	mtime = (time_t) strtoll(cp, &cp, 10);
	if (*cp++ != ' ') {
		error("recvit: mtime not delimited");
		return;
	}

	/*
	 * Get access time
	 */
	atime = (time_t) strtoll(cp, &cp, 10);
	if (*cp++ != ' ') {
		error("recvit: atime not delimited");
		return;
	}

	/*
	 * Get file owner name
	 */
	owner = strtok(cp, " ");
	if (owner == NULL) {
		error("recvit: owner name not delimited");
		return;
	}

	/*
	 * Get file group name
	 */
	group = strtok(NULL, " ");
	if (group == NULL) {
		error("recvit: group name not delimited");
		return;
	}

	/*
	 * Get file name. Can't use strtok() since there could
	 * be white space in the file name.
	 */
	if (DECODE(fileb, group + strlen(group) + 1) == -1) {
		error("recvit: Cannot decode file name");
		return;
	}

	if (fileb[0] == '\0') {
		error("recvit: no file name");
		return;
	}
	file = fileb;

	debugmsg(DM_MISC,
		 "recvit: opts = %#x mode = %#04o size = %lld mtime = %lld",
		 opts, mode, (long long) size, (long long)mtime);
	debugmsg(DM_MISC,
       "recvit: owner = '%s' group = '%s' file = '%s' catname = %d isdir = %d",
		 owner, group, file, catname, (type == S_IFDIR) ? 1 : 0);

	if (type == S_IFDIR) {
		if ((size_t) catname >= sizeof(sptarget)) {
			error("%s: too many directory levels", target);
			return;
		}
		sptarget[catname] = ptarget;
		if (catname++) {
			*ptarget++ = '/';
			while ((*ptarget++ = *file++) != '\0')
			    continue;
			ptarget--;
		}
	} else {
		/*
		 * Create name of temporary file
		 */
		if (catname && cattarget(file) < 0) {
			error("Cannot set file name.");
			return;
		}
		file = strrchr(target, '/');
		if (file == NULL)
			(void) strlcpy(new, tempname, sizeof(new));
		else if (file == target)
			(void) snprintf(new, sizeof(new), "/%s", tempname);
		else {
			*file = CNULL;
			(void) snprintf(new, sizeof(new), "%s/%s", target,
					tempname);
			*file = '/';
		}
	}

	/*
	 * Check to see if there is enough free space and inodes
	 * to install this file.
	 */
	if (min_freespace || min_freefiles) {
		/* Convert file size to kilobytes */
		int64_t fsize = (int64_t)size / 1024;

		if (getfilesysinfo(target, &freespace, &freefiles) != 0)
			return;

		/*
		 * filesystem values < 0 indicate unsupported or unavailable
		 * information.
		 */
		if (min_freespace && (freespace >= 0) && 
		    (freespace - fsize < min_freespace)) {
			error(
		     "%s: Not enough free space on filesystem: min %lld "
		     "free %lld", target, min_freespace, freespace);
			return;
		}
		if (min_freefiles && (freefiles >= 0) &&
		    (freefiles - 1 < min_freefiles)) {
			error(
		     "%s: Not enough free files on filesystem: min %lld free "
		     "%lld", target, min_freefiles, freefiles);
			return;
		}
	}

	/*
	 * Call appropriate receive function to receive file
	 */
	switch (type) {
	case S_IFDIR:
		recvdir(opts, mode, owner, group);
		break;

	case S_IFLNK:
		recvlink(new, opts, mode, size);
		break;

	case S_IFREG:
		recvfile(new, opts, mode, owner, group, mtime, atime, size);
		break;

	default:
		error("%d: unknown file type", type);
		break;
	}
}

/*
 * Chmog something
 */
static void
dochmog(char *cmd)
{
	int mode;
	opt_t opts;
	char *owner, *group, *file;
	char *cp = cmd;
	char fileb[PATH_MAX];

	/*
	 * Get rdist option flags
	 */
	opts = strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("dochmog: options not delimited");
		return;
	}

	/*
	 * Get file mode
	 */
	mode = strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("dochmog: mode not delimited");
		return;
	}

	/*
	 * Get file owner name
	 */
	owner = strtok(cp, " ");
	if (owner == NULL) {
		error("dochmog: owner name not delimited");
		return;
	}

	/*
	 * Get file group name
	 */
	group = strtok(NULL, " ");
	if (group == NULL) {
		error("dochmog: group name not delimited");
		return;
	}

	/*
	 * Get file name. Can't use strtok() since there could
	 * be white space in the file name.
	 */
	if (DECODE(fileb, group + strlen(group) + 1) == -1) {
		error("dochmog: Cannot decode file name");
		return;
	}

	if (fileb[0] == '\0') {
		error("dochmog: no file name");
		return;
	}
	file = fileb;

	debugmsg(DM_MISC,
		 "dochmog: opts = %#x mode = %#04o", opts, mode);
	debugmsg(DM_MISC,
	         "dochmog: owner = '%s' group = '%s' file = '%s' catname = %d",
		 owner, group, file, catname);

	if (catname && cattarget(file) < 0) {
		error("Cannot set newname target.");
		return;
	}

	(void) fchog(-1, target, owner, group, mode);

	ack();
}

/*
 * Set target information
 */
static void
settarget(char *cmd, int isdir)
{
	char *cp = cmd;
	opt_t opts;
	char file[BUFSIZ];

	catname = isdir;

	/*
	 * Parse options for this target
	 */
	opts = strtol(cp, &cp, 8);
	if (*cp++ != ' ') {
		error("settarget: options not delimited");
		return;
	}
	options = opts;

	if (DECODE(file, cp) == -1) {
		error("settarget: Cannot decode target name");
		return;
	}

	/*
	 * Handle target
	 */
	if (exptilde(target, cp, sizeof(target)) == NULL)
		return;
	ptarget = target;
	while (*ptarget)
		ptarget++;

	ack();
}

/*
 * Cleanup in preparation for exiting.
 */
void
cleanup(int dummy)
{
	/* We don't need to do anything */
}

/*
 * Server routine to read requests and process them.
 */
void
server(void)
{
	static char cmdbuf[BUFSIZ];
	char *cp;
	int n, proto_version;

	if (setjmp(finish_jmpbuf))
		return;
	(void) signal(SIGHUP, sighandler);
	(void) signal(SIGINT, sighandler);
	(void) signal(SIGQUIT, sighandler);
	(void) signal(SIGTERM, sighandler);
	(void) signal(SIGPIPE, sighandler);
	(void) umask(oumask = umask(0));
	(void) strlcpy(tempname, _RDIST_TMP, sizeof(tempname));
	if (fromhost) {
		message(MT_SYSLOG, "Startup for %s", fromhost);
#if 	defined(SETARGS)
		setproctitle("Serving %s", fromhost);
#endif	/* SETARGS */
	}

	/* 
	 * Let client know we want it to send it's version number
	 */
	(void) sendcmd(S_VERSION, NULL);

	if (remline(cmdbuf, sizeof(cmdbuf), TRUE) < 0) {
		error("server: expected control record");
		return;
	}

	if (cmdbuf[0] != S_VERSION || !isdigit((unsigned char)cmdbuf[1])) {
		error("Expected version command, received: \"%s\".", cmdbuf);
		return;
	}

	proto_version = atoi(&cmdbuf[1]);
	if (proto_version != VERSION) {
		error("Protocol version %d is not supported.", proto_version);
		return;
	}

	/* Version number is okay */
	ack();

	/*
	 * Main command loop
	 */
	for ( ; ; ) {
		n = remline(cp = cmdbuf, sizeof(cmdbuf), TRUE);
		if (n == -1)		/* EOF */
			return;
		if (n == 0) {
			error("server: expected control record");
			continue;
		}

		switch (*cp++) {
		case C_SETCONFIG:  	/* Configuration info */
		        setconfig(cp);
			ack();
			continue;

		case C_DIRTARGET:  	/* init target file/directory name */
			settarget(cp, TRUE);
			continue;

		case C_TARGET:  	/* init target file/directory name */
			settarget(cp, FALSE);
			continue;

		case C_RECVREG:  	/* Transfer a regular file. */
			recvit(cp, S_IFREG);
			continue;

		case C_RECVDIR:  	/* Transfer a directory. */
			recvit(cp, S_IFDIR);
			continue;

		case C_RECVSYMLINK:  	/* Transfer symbolic link. */
			recvit(cp, S_IFLNK);
			continue;

		case C_RECVHARDLINK:  	/* Transfer hard link. */
			hardlink(cp);
			continue;

		case C_END:  		/* End of transfer */
			*ptarget = CNULL;
			if (catname <= 0) {
				error("server: too many '%c's", C_END);
				continue;
			}
			ptarget = sptarget[--catname];
			*ptarget = CNULL;
			ack();
			continue;

		case C_CLEAN:  		/* Clean. Cleanup a directory */
			clean(cp);
			continue;

		case C_QUERY:  		/* Query file/directory */
			query(cp);
			continue;

		case C_SPECIAL:  	/* Special. Execute commands */
			dospecial(cp);
			continue;

		case C_CMDSPECIAL:  	/* Cmd Special. Execute commands */
			docmdspecial();
			continue;

	        case C_CHMOG:  		/* Set owner, group, mode */
			dochmog(cp);
			continue;

		case C_ERRMSG:		/* Normal error message */
			if (cp && *cp)
				message(MT_NERROR|MT_NOREMOTE, "%s", cp);
			continue;

		case C_FERRMSG:		/* Fatal error message */
			if (cp && *cp)
				message(MT_FERROR|MT_NOREMOTE, "%s", cp);
			return;

		default:
			error("server: unknown command '%s'", cp - 1);
		case CNULL:
			continue;
		}
	}
}
@


1.41
log
@The change to make mkstemp(3) require at least 6 trailing Xs broke
rdistd for directories that do not exist on the destination.  Calling
mkstemp(3) twice with the same format (filled in by the first
mkstemp(3) call) is bogus so call chkparent() *before* mkstemp(3)
instead of only on error.  This costs an extra lstat(2) in the case
where the directory already exists but simplifies the code and
doesn't rely on undefined behavior (namely, the state of the template
when mkstemp fails).  OK tim@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.40 2015/12/22 08:48:39 mmcc Exp $	*/
d842 1
a842 1
				error("");
d1147 1
a1147 1
			message(MT_REMOTE|MT_INFO, "");
@


1.40
log
@remove needless allocation casts
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.39 2015/12/22 08:22:33 mmcc Exp $	*/
d753 3
a755 6
	if ((f = mkstemp(new)) < 0) {
		if (errno != ENOENT || chkparent(new, opts) < 0 ||
		    (f = mkstemp(new)) < 0) {
			error("%s: create failed: %s", new, SYSERR);
			return;
		}
d1161 4
a1164 7
	if (mktemp(new) == NULL || symlink(dbuf, new) < 0) {
		if (errno != ENOENT || chkparent(new, opts) < 0 ||
		    mktemp(new) == NULL || symlink(dbuf, new) < 0) {
			error("%s -> %s: symlink failed: %s", new, dbuf,
			    SYSERR);
			return;
		}
@


1.39
log
@Remove a couple needless allocation casts. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.38 2015/11/15 06:18:19 guenther Exp $	*/
d520 1
a520 1
				env = (char *) xmalloc(len);
@


1.38
log
@Switch to linkat() to support hardlinked symlinks
Simplify chown logic by using fchownat()
Cache whether we're root instead of calling getuid() before each chown
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.37 2015/01/21 04:08:37 guenther Exp $	*/
d525 1
a525 1
				env = (char *) xrealloc(env, len);
d535 1
a535 1
				env = (char *) xrealloc(env, len);
@


1.37
log
@Assume NFS_CHECK and RO_CHECK are defined.
We only need the dev_t and not the entire struct stat in mntinfo.
Delete some superfluous casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.36 2015/01/21 03:18:31 guenther Exp $	*/
d109 1
d115 7
a121 1
	if (getuid() != 0) 
d123 4
a126 3

	if (islink)
		status = lchown(file, uid, gid);
d130 3
a132 3

	if (status < 0 && !islink)
		status = chown(file, uid, gid);
d139 1
a139 1
			message(MT_NOTICE, "%s: chown %d.%d failed: %s", 
d704 1
a704 1
			if (stat(savefile, &st) == -1 && errno == ENOENT)
d1282 1
a1282 1
	if (link(expbuf, target) < 0) {
@


1.36
log
@Reduce opt_t from long to int.
Debug message consistency: format opts with %#x and modes with %#04o
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.35 2015/01/20 09:00:16 guenther Exp $	*/
a548 1
#ifdef NFS_CHECK
a549 2
#endif NFS_CHECK
#ifdef RO_CHECK
a550 1
#endif RO_CHECK
a570 1
#if	defined(NFS_CHECK)
a582 1
#endif 	/* NFS_CHECK */
a583 1
#if	defined(RO_CHECK)
a595 1
#endif 	/* RO_CHECK */
d605 2
a606 4
	 * If stbvalid is false, "stb" is not valid because:
	 *	a) RO_CHECK and NFS_CHECK were not defined
	 *	b) The stat by is_*_mounted() either failed or
	 *	   does not match "target".
@


1.35
log
@Split out from rdist/defs.h the client-only and server-only bits into
 rdist/client.h and rdistd/server.h
Only put #includes in .h files that are necessary for the .h to be used;
 all other #includes go in the .c files
Move all extern variable declarations to the .h files, renaming local
 variables to avoid shadowing
Replace me_type member of mntent_t with an "is NFS?" flag bit
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.34 2015/01/16 06:40:11 deraadt Exp $	*/
d656 1
a656 1
	debugmsg(DM_CALL, "chkparent(%s, %lo) start\n", name, opts);
d671 1
a671 1
					 "chkparent(%s, %lo) mkdir fail: %s\n",
d999 1
a999 1
						"%s: need to chmod to %o",
d1001 13
a1013 15
				else {
					if (chmod(target, mode) != 0)
						message(MT_NOTICE,
					  "%s: chmod from %o to %o failed: %s",
							target, 
							stb.st_mode & 07777, 
							mode,
							SYSERR);
					else
						message(MT_NOTICE,
						"%s: chmod from %o to %o",
							target, 
							stb.st_mode & 07777, 
							mode);
				}
d1449 1
a1449 1
		 "recvit: opts = %04lo mode = %04o size = %lld mtime = %lld",
d1605 1
a1605 1
		 "dochmog: opts = %04lo mode = %04o", opts, mode);
@


1.34
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.33 2014/07/12 03:10:03 guenther Exp $	*/
d32 1
d34 9
d44 1
a44 1
#include "defs.h"
a172 1
	extern char *locuser;
d1678 1
a1678 2
	int n;
	extern jmp_buf finish_jmpbuf;
@


1.33
log
@Rename 'link' parameter to eliminate shadow warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.32 2014/07/12 03:02:27 guenther Exp $	*/
d42 1
a42 1
char	target[MAXPATHLEN];	/* target/source directory name */
d327 1
a327 1
		if (len + 1 + (int)strlen(dp->d_name) >= MAXPATHLEN - 1) {
d390 1
a390 1
	char targ[MAXPATHLEN*4];
d410 1
a410 1
		if (len + 1 + (int)strlen(dp->d_name) >= MAXPATHLEN - 1) {
d556 1
a556 1
	char name[MAXPATHLEN];
d680 1
a680 1
	static char savefile[MAXPATHLEN];
d682 1
a682 1
	if (strlen(file) + sizeof(SAVE_SUFFIX) + 1 > MAXPATHLEN) {
d1113 1
a1113 1
	char tbuf[MAXPATHLEN], dbuf[BUFSIZ];
d1358 2
a1359 2
	char new[MAXPATHLEN];
	char fileb[MAXPATHLEN];
d1544 1
a1544 1
	char fileb[MAXPATHLEN];
@


1.32
log
@Yes, we have setproctitle().  Delete that and several unused HAVE_* #defines
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.31 2014/07/05 07:39:18 guenther Exp $	*/
d97 1
a97 1
setownership(char *file, int fd, uid_t uid, gid_t gid, int link)
d107 1
a107 1
	if (link)
d110 1
a110 1
	if (fd != -1 && !link)
d113 1
a113 1
	if (status < 0 && !link)
d133 1
a133 1
setfilemode(char *file, int fd, int mode, int link)
d140 1
a140 1
	if (link)
d143 1
a143 1
	if (fd != -1 && !link)
d146 1
a146 1
	if (status < 0 && !link)
@


1.31
log
@Assume POSIX: S_IFSOCK and S_IFIFO
Kill some 'notyet' code that will never be enabled
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.30 2014/07/05 07:22:18 guenther Exp $	*/
a1306 1
#if defined(SETARGS) || defined(HAVE_SETPROCTITLE)
a1307 1
#endif /* SETARGS || HAVE_SETPROCTITLE */
@


1.30
log
@Assume POSIX: lchown(), fchown(), fchmod(), fchmodat()
Assume we have rcmdsh()
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.29 2014/07/05 06:53:36 guenther Exp $	*/
a289 1
#ifdef S_IFSOCK
a290 2
#endif
#ifdef S_IFIFO
a291 1
#endif
a621 10
#ifdef notyet
	case S_IFCHR:
	case S_IFBLK:
#ifdef S_IFSOCK
	case S_IFSOCK:
#endif
#ifdef S_IFIFO
	case S_IFIFO:
#endif
#endif
@


1.29
log
@Assume POSIX: uid_t and gid_t
Add parens to quiet gcc on previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.28 2014/07/05 06:45:00 guenther Exp $	*/
a106 5
	/*
	 * If we are dealing with a symlink, only try to change it if
	 * we have lchown, if we don't leave it alone.
	 */
#if	defined(HAVE_LCHOWN)
a108 4
#else
	if (link)
		return 0;
#endif
a109 1
#if	defined(HAVE_FCHOWN)
d112 1
a112 1
#endif
a139 8
	/*
	 * If we are dealing with a symlink, only try to change it if
	 * we have lchown, if we don't leave it alone.
	 */
#if	defined(HAVE_LCHMOD)
	if (link)
		status = lchmod(file, mode);
#else
d141 1
a141 2
		return 0;
#endif
a142 1
#if	defined(HAVE_FCHMOD)
a144 1
#endif
@


1.28
log
@Assume POSIX: <dirent.h>, struct dirent
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.27 2014/07/05 06:40:54 guenther Exp $	*/
d52 1
a52 1
static int setownership(char *, int, UID_T, GID_T, int);
d97 1
a97 1
setownership(char *file, int fd, UID_T uid, GID_T gid, int link)
d113 1
a113 2
		status = lchown(file, (CHOWN_UID_T) uid, 
				(CHOWN_GID_T) gid);
d121 1
a121 2
		status = fchown(fd, (CHOWN_UID_T) uid, 
				(CHOWN_GID_T) gid);
d124 1
a124 2
		status = chown(file, (CHOWN_UID_T) uid, 
			       (CHOWN_GID_T) gid);
d127 1
a127 1
		if (uid == (UID_T) -1)
d187 3
a189 3
	UID_T uid;
	GID_T gid;
	GID_T primegid = (GID_T)-2;
d194 1
a194 1
			uid = (UID_T) atoi(owner + 1);
d214 1
a214 1
			gid = (GID_T) atoi(group + 1);
d232 1
a232 1
	gid = (GID_T) -1;
d262 1
a262 1
		gid = (GID_T) -1;
d349 1
a349 1
		    dp->d_name[1] == '.' && dp->d_name[2] == '\0'))
d432 1
a432 1
		    dp->d_name[1] == '.' && dp->d_name[2] == '\0'))
@


1.27
log
@Oops, fix both locations using D_NAMLEN()
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.26 2014/07/05 06:39:13 guenther Exp $	*/
d31 3
d303 1
a303 1
	static DIRENTRY *dp;
d413 1
a413 1
	DIRENTRY *dp;
@


1.26
log
@Stop using silly macro when checking for '.' and '..' directory entries
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.25 2013/10/27 18:31:24 guenther Exp $	*/
d431 2
a432 3
		if ((D_NAMLEN(dp) == 1 && dp->d_name[0] == '.') ||
		    (D_NAMLEN(dp) == 2 && dp->d_name[0] == '.' &&
		     dp->d_name[1] == '.'))
@


1.25
log
@If a constant string needs a name, use a static const array instead of a
pointer or non-const array, as that minimizes the symbols, maximizes the
placement into read-only memory, and avoids warnings from gcc -Wformat=2
when they're used as format strings.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.24 2013/04/16 19:24:53 deraadt Exp $	*/
d348 2
a349 3
		if ((D_NAMLEN(dp) == 1 && dp->d_name[0] == '.') ||
		    (D_NAMLEN(dp) == 2 && dp->d_name[0] == '.' &&
		     dp->d_name[1] == '.'))
@


1.24
log
@remove casts to time_t * which are not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.23 2012/11/12 01:14:41 guenther Exp $	*/
d933 1
a933 1
		static char fmt[] = "%s -> %s: rename failed: %s";
@


1.23
log
@Fix various format string issues.  Stop assuming time_t is long or smaller.
Enable warnings.

ok krw@@, ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.22 2011/04/10 15:47:28 krw Exp $	*/
d905 1
a905 1
	if (setfiletime(new, time((time_t *) 0), mtime) < 0)
@


1.22
log
@Apply some tough type-love and give rdist a chance to handle files
larger than 2GB. Diff from Stephan R. Gerber via PR#6586, tweaks
by me.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.21 2009/10/27 23:59:42 deraadt Exp $	*/
d659 3
a661 2
		(void) sendcmd(QC_YES, "%lld %ld %o %s %s",
			       (long long) stb.st_size, stb.st_mtime,
d684 1
a684 1
	debugmsg(DM_CALL, "chkparent(%s, %o) start\n", name, opts);
d699 1
a699 1
					 "chkparent(%s, %o) mkdir fail: %s\n",
d1432 1
a1432 1
	mtime = (time_t) strtol(cp, &cp, 10);
d1441 1
a1441 1
	atime = strtol(cp, &cp, 10);
d1481 2
a1482 2
		 "recvit: opts = %04o mode = %04o size = %lld mtime = %d",
		 opts, mode, (long long) size, mtime);
d1637 1
a1637 1
		 "dochmog: opts = %04o mode = %04o", opts, mode);
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.20 2009/03/28 15:18:29 deraadt Exp $	*/
d44 2
a45 2
static long min_freespace = 0;	/* Minimium free space on a filesystem */
static long min_freefiles = 0;	/* Minimium free # files on a filesystem */
d659 2
a660 2
		(void) sendcmd(QC_YES, "%ld %ld %o %s %s",
			       (long) stb.st_size, stb.st_mtime,
d797 1
a797 1
		int amt = BUFSIZ;
d803 1
a803 1
			int j;
d1333 1
d1350 4
a1353 5
		if (!isdigit((unsigned char)*cp)) {
			fatalerr("Expected digit, got '%s'.", cp);
			return;
		}
		min_freespace = (unsigned long) atoi(cp);
d1357 4
a1360 5
		if (!isdigit((unsigned char)*cp)) {
			fatalerr("Expected digit, got '%s'.", cp);
			return;
		}
		min_freefiles = (unsigned long) atoi(cp);
d1398 1
a1398 1
	long freespace = -1, freefiles = -1;
d1422 1
a1422 1
	size = strtol(cp, &cp, 10);
d1431 1
a1431 1
	mtime = strtol(cp, &cp, 10);
d1480 2
a1481 2
		 "recvit: opts = %04o mode = %04o size = %d mtime = %d",
		 opts, mode, size, mtime);
d1525 1
a1525 1
		long fsize = (long) (size / 1024);
d1537 2
a1538 2
		     "%s: Not enough free space on filesystem: min %d free %d",
			      target, min_freespace, freespace);
d1544 2
a1545 2
		     "%s: Not enough free files on filesystem: min %d free %d",
			      target, min_freefiles, freefiles);
@


1.20
log
@pathnames with space, tab, newline, etc are encoded before being sent.
But they were not reliably being decoded, resulting in wrong naming
on the target machine.  diff from Tim van der Molen
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.19 2008/05/25 22:33:56 millert Exp $	*/
a31 17

#ifndef lint
#if 0
static char RCSid[] __attribute__((__unused__)) =
"$From: server.c,v 1.10 1999/08/04 15:57:33 christos Exp $";
#else
static char RCSid[] __attribute__((__unused__)) =
"$OpenBSD: server.c,v 1.19 2008/05/25 22:33:56 millert Exp $";
#endif

static char sccsid[] __attribute__((__unused__)) =
"@@(#)server.c	5.3 (Berkeley) 6/7/86";

static char copyright[] __attribute__((__unused__)) =
"@@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */
@


1.19
log
@Fix breakage introduced in rev 1.8 wrt rdisting symlinks.  Push the
mkstemp() down into recvfile() and use mktemp() for recvlink().
OK okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.18 2008/05/13 02:13:46 ray Exp $	*/
d39 1
a39 1
"$OpenBSD: server.c,v 1.18 2008/05/13 02:13:46 ray Exp $";
d1166 1
a1166 1
	char tbuf[MAXPATHLEN];
d1183 5
d1191 1
a1191 1
		if (i == size && strncmp(buf, tbuf, (int) size) == 0)
d1212 1
a1212 1
	if (mktemp(new) == NULL || symlink(buf, new) < 0) {
d1214 3
a1216 2
		    mktemp(new) == NULL || symlink(buf, new) < 0) {
			error("%s -> %s: symlink failed: %s", new, buf, SYSERR);
@


1.18
log
@Change a mktemp(3) to mkstemp(3), preventing a race condition.
Improve error checking.

OK okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.17 2006/02/01 19:06:24 otto Exp $	*/
d39 1
a39 1
"$OpenBSD: server.c,v 1.17 2006/02/01 19:06:24 otto Exp $";
d77 1
a77 1
static void recvfile(char *, int, opt_t, int, char *, char *, time_t, time_t, off_t);
d787 2
a788 2
recvfile(char *new, int f, opt_t opts, int mode, char *owner,
    char *group, time_t mtime, time_t atime, off_t size)
d790 1
a790 1
	int wrerr, olderrno;
d797 11
d1207 1
a1207 1
	if (symlink(buf, new) < 0) {
d1209 2
a1210 3
		    symlink(buf, new) < 0) {
			error("%s -> %s: symlink failed: %s", new, buf,SYSERR);
			(void) unlink(new);
d1403 1
a1403 1
	int f, mode;
a1528 4
		if ((f = mkstemp(new)) == -1) {
			error("%s: create failed: %s", new, SYSERR);
			return;
		}
d1575 1
a1575 1
		recvfile(new, f, opts, mode, owner, group, mtime, atime, size);
@


1.17
log
@double semicolon; from Daniel Matic in PR 4929
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.16 2003/07/07 14:39:26 mpech Exp $	*/
d39 1
a39 1
"$OpenBSD: server.c,v 1.16 2003/07/07 14:39:26 mpech Exp $";
d77 1
a77 1
static void recvfile(char *, opt_t, int, char *, char *, time_t, time_t, off_t);
d787 2
a788 2
recvfile(char *new, opt_t opts, int mode, char *owner, char *group,
	 time_t mtime, time_t atime, off_t size)
d790 1
a790 1
	int f, wrerr, olderrno;
a796 12
	 * Create temporary file
	 */
	if ((f = open(new, O_CREAT|O_EXCL|O_WRONLY, mode)) < 0) {
		if (errno != ENOENT || chkparent(new, opts) < 0 ||
		    (f = open(new, O_CREAT|O_EXCL|O_WRONLY, mode)) < 0) {
			error("%s: create failed: %s", new, SYSERR);
			(void) unlink(new);
			return;
		}
	}

	/*
d1393 1
a1393 1
	int mode;
d1519 4
a1522 1
		(void) mktemp(new);
d1569 1
a1569 1
		recvfile(new, opts, mode, owner, group, mtime, atime, size);
@


1.16
log
@fix readlink() usage.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.15 2003/06/03 02:56:15 millert Exp $	*/
d39 1
a39 1
"$OpenBSD: server.c,v 1.15 2003/06/03 02:56:15 millert Exp $";
d379 1
a379 1
		cp = dp->d_name;;
d461 1
a461 1
		cp = dp->d_name;;
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.14 2003/05/14 01:34:35 millert Exp $	*/
d39 1
a39 1
"$OpenBSD: server.c,v 1.14 2003/05/14 01:34:35 millert Exp $";
d1185 1
a1185 1
	if ((i = readlink(target, tbuf, sizeof(tbuf))) != -1) {
@


1.14
log
@ o Sync w/ freerdist 0.92 minus the compress option
 o KNF and ANSIfy the function headers

Sparse file support is currently a no-op since it didn't work.
Proper sparse file support will be added later.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.13 2003/04/19 17:22:30 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d39 1
a39 1
"$OpenBSD: server.c,v 1.13 2003/04/19 17:22:30 millert Exp $";
@


1.13
log
@strcpy/strcat/sprintf removal; krw@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.12 2003/04/10 22:42:29 millert Exp $	*/
d35 2
d39 2
a40 2
static char RCSid[] = 
"$From: server.c,v 6.85 1996/03/12 22:55:38 mcooper Exp $";
d42 2
a43 2
static char RCSid[] = 
"$OpenBSD: server.c,v 1.12 2003/04/10 22:42:29 millert Exp $";
d46 2
a47 1
static char sccsid[] = "@@(#)server.c	5.3 (Berkeley) 6/7/86";
d49 1
a49 1
static char copyright[] =
a57 2
#include "defs.h"

d69 21
d93 2
a94 2
static int cattarget(string)
	char *string;
d105 2
a106 2
	(void) snprintf(ptarget, target + sizeof(target) - ptarget,
	    "/%s", string);
d114 2
a115 5
static int setownership(file, fd, uid, gid)
	char *file;
	int fd;
	UID_T uid;
	GID_T gid;
d122 14
a135 5
	if (getuid() == 0) {
#if	defined(HAVE_FCHOWN)
		if (fd != -1)
			status = fchown(fd, (CHOWN_UID_T) uid, 
					(CHOWN_GID_T) gid);
d137 1
a137 10
		if (status < 0)
			status = chown(file, (CHOWN_UID_T) uid, 
				       (CHOWN_GID_T) gid);

		if (status < 0) {
			message(MT_NOTICE, "%s: chown %d:%d failed: %s", 
				target, (UID_T) uid, (GID_T) gid, SYSERR);
			return(-1);
		}
	} else {
d139 3
a141 3
		if (fd != -1)
			status = fchown(fd, (CHOWN_UID_T) -1, 
					(CHOWN_GID_T) gid);
d143 3
a145 3
		if (status < 0)
			status = chown(file, (CHOWN_UID_T) -1, 
				       (CHOWN_GID_T) gid);
d147 2
a148 1
		if (status < 0) {
d150 5
a154 3
				target, (GID_T) gid, SYSERR);
			return(-1);
		}
d163 2
a164 4
static int setfilemode(file, fd, mode)
	char *file;
	int fd;
	int mode;
d171 12
d184 1
a184 1
	if (fd != -1)
d188 1
a188 1
	if (status < 0)
a197 19

/*
 * Get group entry.  This routine takes a string argument (name).
 * If name is of form ":N" a lookup for gid N is done.
 * Otherwise a lookup by name is done.
 */
static struct group *mygetgroup(name)
	char *name;
{
    	struct group *gr;

	if (*name == ':')
	    	gr = getgrgid(atoi(name + 1));
	else
	    	gr = getgrnam(name);

	return(gr);
}

d201 2
a202 4
static int fchog(fd, file, owner, group, mode)
	int fd;
	char *file, *owner, *group;
	int mode;
d204 1
a204 6
	struct group *gr = NULL;
	static char last_group[128];
	static char last_owner[128];
	static GID_T last_gid = (GID_T)-2;
	static UID_T last_uid = (UID_T)-2;
	static GID_T last_primegid;
d207 1
d216 1
a216 2
		} else if (last_uid == (UID_T)-2 ||
			   strcmp(owner, last_owner) != 0) {
d228 2
a229 5
			} else {
				uid	 = last_uid	 = pw->pw_uid;
				primegid = last_primegid = pw->pw_gid;
				strlcpy(last_owner, owner, sizeof last_owner);
			}
d231 2
a232 2
			uid = last_uid;
			primegid = last_primegid;
d254 4
a257 8
	if (last_gid < (GID_T)0 || strcmp(group, last_group) != 0) {
	        /*
		 * Invalid cached values so we need to do a new lookup.
		 */
		if ((gr = mygetgroup(group))) {
			last_gid = gid = gr->gr_gid;
			strlcpy(last_group, gr->gr_name, sizeof last_group);
		} else {
d267 4
a270 7
		}
	} else {
	    	/*
		 * Use the cached values.
		 */
		gid = last_gid;
	}
a271 4
	/*
	 * We need to check non-root users to make sure they're a member
	 * of the group.  If they are not, we don't set that gid ownership.
	 */
a272 2
		if (!gr)
		    	gr = mygetgroup(group);
d275 1
a275 1
			    	if (strcmp(locuser, gr->gr_mem[i]) == 0)
d286 4
d295 1
a295 1
	if (setownership(file, fd, uid, gid) < 0) {
d307 1
a307 1
	(void) setfilemode(file, fd, mode);
d317 2
a318 2
static int removefile(statb)
	struct stat *statb;
d330 8
d340 4
a343 3
				message(MT_REMOTE|MT_NOTICE, 
					"%s: unlink failed: %s",
					target, SYSERR);
d368 1
a368 1
	while ((dp = readdir(d))) {
d375 4
a378 2
			message(MT_REMOTE|MT_WARNING, "%s/%s: Name too long", 
				target, dp->d_name);
d384 2
a385 2
		while ((*ptarget++ = *cp++))
			;
d388 4
a391 2
			message(MT_REMOTE|MT_WARNING, "%s: lstat failed: %s", 
				target, SYSERR);
d394 1
a394 1
		if (removefile(&stb) < 0)
d409 4
d420 1
d428 2
a429 2
static void doclean(cp)
	char *cp;
d437 1
d452 1
a452 1
	while ((dp = readdir(d))) {
d466 2
a467 2
		while ((*ptarget++ = *cp++))
			;
d475 2
a476 1
		(void) sendcmd(CC_QUERY, "%s", dp->d_name);
d486 1
a486 1
			(void) removefile(&stb);
d497 2
a498 2
static void clean(cp)
	char *cp;
d510 2
a511 2
static void dospecial(cmd)
	char *cmd;
d513 5
d529 2
a530 1
static void docmdspecial()
d599 2
a600 2
static void query(name)
	char *name;
d604 6
d670 10
d681 1
a681 2
			       (long) stb.st_size, 
			       stb.st_mtime, 
d697 2
a698 3
static int chkparent(name, opts)
	char *name;
	opt_t opts;
d734 2
a735 2
static char *savetarget(file)
	char *file;
d744 12
a755 1
	(void) snprintf(savefile, sizeof savefile, "%s%s", file, SAVE_SUFFIX);
d757 19
a775 3
	if (unlink(savefile) != 0 && errno != ENOENT) {
		message(MT_NOTICE, "%s: remove failed: %s", savefile, SYSERR);
		return(NULL);
a787 18
 * See if buf is all zeros (sparse check)
 */
static int iszeros (buf, size)
	char *buf;
	off_t size;
{
    	while (size > 0) {
	    if (*buf != CNULL)
		return(0);
	    buf++;
	    size--;
	}

	return(1);
}

  
/*
d790 3
a792 9
static void recvfile(new, opts, mode, owner, group, mtime, atime, size)
	/*ARGSUSED*/
	char *new;
	opt_t opts;
	int mode;
	char *owner, *group;
	time_t mtime;
	time_t atime;
	off_t size;
d794 1
a794 1
	int f, wrerr, olderrno, lastwashole = 0, wassparse = 0;
d841 1
a841 25
		if (IS_ON(opts, DO_SPARSE) && iszeros(buf, amt)) {
		    	if (lseek (f, amt, SEEK_CUR) < 0L) {
			    	olderrno = errno;
				wrerr++;
			}
			lastwashole = 1;
			wassparse++;
		} else {
		    	if (wrerr == 0 && xwrite(f, buf, amt) != amt) {
			    	olderrno = errno;
				wrerr++;
			}
			lastwashole = 0;
		}
	}

	if (lastwashole) {
#if	defined(HAVE_FTRUNCATE)
	    	if (write (f, "", 1) != 1 || ftruncate (f, size) < 0)
#else
		/* Seek backwards one character and write a null.  */
		if (lseek (f, (off_t) -1, SEEK_CUR) < 0L
		    || write (f, "", 1) != 1)
#endif
		{
d877 1
d933 1
a933 1
		if ((savefile = savetarget(target)) == NULL) {
d946 1
a946 1
		removefile(&statbuff);
d954 2
d960 2
a961 1
		if (errno == ETXTBSY) {
d963 1
a963 1
			if ((savefile = savetarget(target)) != NULL) {
d966 1
a966 2
					error("%s -> %s: rename failed: %s",
					      new, target, SYSERR);
d969 3
a971 4
						error(
					         "%s -> %s: rename failed: %s",
						      savefile, target, 
						      SYSERR);
d975 21
d997 6
a1002 3
		} else {
			error("%s -> %s: rename failed: %s", 
			      new, target, SYSERR);
d1004 1
a1007 3
	if (wassparse)
	    	message (MT_NOTICE, "%s: was sparse", target);

d1017 2
a1018 4
static void recvdir(opts, mode, owner, group)
	opt_t opts;
	int mode;
	char *owner, *group;
d1078 2
a1079 1
				if ((cp = getusername(stb.st_uid, target, o)))
d1082 1
a1082 1
						    sizeof lowner);
d1089 2
a1090 1
				if ((cp = getgroupname(stb.st_gid, target, o)))
d1093 1
a1093 1
						    sizeof lgroup);
d1105 1
a1105 1
					    sizeof lowner);
d1110 1
a1110 1
					    sizeof lgroup);
d1168 2
a1169 5
static void recvlink(new, opts, mode, size)
	char *new;
	opt_t opts;
	int mode;
	off_t size;
d1171 1
d1174 1
d1188 21
a1221 24
	 * Do comparison of what link is pointing to if enabled
	 */
	mode &= 0777;
	if (IS_ON(opts, DO_COMPARE)) {
		char tbuf[MAXPATHLEN];
		
		if ((i = readlink(target, tbuf, sizeof(tbuf)-1)) != -1)
			tbuf[i] = '\0';
		if (i != -1 && i == size && strncmp(buf, tbuf, (size_t) size) == 0) {
			(void) unlink(new);
			ack();
			return;
		}
		if (IS_ON(opts, DO_VERIFY)) {
			(void) unlink(new);
			message(MT_REMOTE|MT_INFO, "%s: need to update",
				target);
			(void) sendcmd(C_END, NULL);
			(void) response();
			return;
		}
	}

	/*
d1228 1
a1228 1
			if (removefile(&stb) < 0) {
d1251 1
a1251 4
	if (IS_ON(opts, DO_COMPARE))
		message(MT_REMOTE|MT_CHANGE, "%s: updated", target);
	else
	        ack();
d1263 2
a1264 2
static void hardlink(cmd)
	char *cmd;
d1268 1
a1268 1
	char *oldname, *newname;
d1271 1
d1280 2
a1281 2
	oldname = strtok(cp, " ");
	if (oldname == NULL) {
d1286 7
a1292 2
	newname = strtok(NULL, " ");
	if (newname == NULL) {
d1297 5
a1305 1
	oldname = expbuf;
d1330 1
a1330 1
	if (link(oldname, target) < 0) {
d1345 2
a1346 2
static void setconfig(cmd)
	char *cmd;
d1358 1
a1358 1
			message(MT_SYSLOG, "startup for %s",  fromhost);
d1366 1
a1366 1
		if (!isdigit(*cp)) {
d1374 1
a1374 1
		if (!isdigit(*cp)) {
d1382 1
a1382 1
		if ((estr = msgparseopts(cp, TRUE))) {
d1389 8
d1406 2
a1407 3
static void recvit(cmd, type)
	char *cmd;
	int type;
d1415 1
d1483 1
a1483 1
	 * Get file name.  Can't use strtok() since there could
d1486 6
a1491 2
	file = group + strlen(group) + 1;
	if (file == NULL) {
d1495 1
d1505 1
a1505 1
		if (catname >= sizeof(sptarget)) {
d1512 2
a1513 2
			while ((*ptarget++ = *file++))
			    ;
d1526 1
a1526 1
			(void) strlcpy(new, tempname, sizeof new);
d1528 1
a1528 1
			(void) snprintf(new, sizeof new, "/%s", tempname);
d1531 2
a1532 1
			(void) snprintf(new, sizeof new, "%s/%s", target, tempname);
d1592 79
d1673 2
a1674 3
static void settarget(cmd, isdir)
	char *cmd;
	int isdir;
d1678 1
d1692 5
d1712 2
a1713 1
extern void cleanup()
d1721 2
a1722 1
extern void server()
d1729 1
a1729 2
	if (setjmp(finish_jmpbuf)) {
		setjmp_ok = FALSE;
a1730 2
	}
        setjmp_ok = TRUE;
d1737 1
a1737 1
	(void) strlcpy(tempname, _RDIST_TMP, sizeof tempname);
a1750 1
		setjmp_ok = FALSE;
d1755 1
a1755 2
	if (cmdbuf[0] != S_VERSION || !isdigit(cmdbuf[1])) {
		setjmp_ok = FALSE;
a1761 1
		setjmp_ok = FALSE;
d1774 1
a1774 2
		if (n == -1) {		/* EOF */
			setjmp_ok = FALSE;
a1775 1
		}
d1838 2
a1839 3
#ifdef DOCHMOD
	        case C_CHMOD:  		/* Set mode */
			dochmod(cp);
a1840 1
#endif /* DOCHMOD */
a1849 1
			setjmp_ok = FALSE;
@


1.12
log
@more POSIX chown
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.11 2003/04/05 20:31:58 deraadt Exp $	*/
d41 1
a41 1
"$OpenBSD: server.c,v 1.11 2003/04/05 20:31:58 deraadt Exp $";
d83 2
a84 1
	(void) sprintf(ptarget, "/%s", string);
d515 1
a515 1
	int len;
d535 4
a538 6
				len = strlen(env);
				env = (char *) xrealloc(env, 
				    len + strlen(cp) + 2);
				env[len] = CNULL;
				(void) strcat(env, ":");
				(void) strcat(env, cp);
d545 4
a548 6
				len = strlen(env);
				env = (char *) xrealloc(env, 
							len + strlen(cp) + 2);
				env[len] = CNULL;
				(void) strcat(env, ";");
				(void) strcat(env, cp);
d1261 1
a1261 1
	if (exptilde(expbuf, oldname) == NULL) {
d1562 1
a1562 1
	if (exptilde(target, cp) == NULL)
@


1.11
log
@strings; ok miod ho krw
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.10 2001/11/19 19:02:15 mpech Exp $	*/
d41 1
a41 1
"$OpenBSD: server.c,v 1.10 2001/11/19 19:02:15 mpech Exp $";
d113 1
a113 1
			message(MT_NOTICE, "%s: chown %d.%d failed: %s", 
d1080 1
a1080 1
				"%s: need to chown from %s.%s to %s.%s",
d1088 1
a1088 1
					       "%s: chown from %s.%s to %s.%s",
@


1.10
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.9 2001/09/19 10:58:07 mpech Exp $	*/
d41 1
a41 1
"$OpenBSD: server.c,v 1.9 2001/09/19 10:58:07 mpech Exp $";
d224 1
a224 1
				strcpy(last_owner, owner);
d256 1
a256 1
			strcpy(last_group, gr->gr_name);
d531 1
a531 1
				(void) sprintf(env, "export %s;%s=%s", 
d536 1
a536 1
							len + strlen(cp) + 2);
d713 1
a713 1
	(void) sprintf(savefile, "%s%s", file, SAVE_SUFFIX);
d1048 2
a1049 1
						(void) strcpy(lowner, cp);
d1058 2
a1059 1
						(void) strcpy(lgroup, cp);
d1070 2
a1071 1
					(void) strcpy(lowner, cp);
d1075 2
a1076 1
					(void) strcpy(lgroup, cp);
d1476 1
a1476 1
			(void) strcpy(new, tempname);
d1478 1
a1478 1
			(void) sprintf(new, "/%s", tempname);
d1481 1
a1481 1
			(void) sprintf(new, "%s/%s", target, tempname);
d1603 1
a1603 1
	(void) strcpy(tempname, _RDIST_TMP);
@


1.9
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.8 1999/02/04 23:18:57 millert Exp $	*/
d41 1
a41 1
"$OpenBSD: server.c,v 1.8 1999/02/04 23:18:57 millert Exp $";
d199 1
a199 1
	register int i;
d327 1
a327 1
	register char *cp;
d416 1
a416 1
	register char *cp;
d419 1
a419 1
	register DIRENTRY *dp;
d483 1
a483 1
	register char *cp;
d511 1
a511 1
	register char *cp;
d669 1
a669 1
	register char *cp;
d762 1
a762 1
	register char *cp;
d989 1
a989 1
	register char *cp;
d1307 1
a1307 1
	register char *cp = cmd;
d1584 2
a1585 2
	register char *cp;
	register int n;
@


1.8
log
@Fix a serious memory consumption problem when running over directories
that contain many hard-linked files; johnh@@isi.edu
Also add an xstrdup() that behaves like xmalloc() on failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.7 1998/06/26 21:20:53 millert Exp $	*/
d41 1
a41 1
"$OpenBSD: server.c,v 1.7 1998/06/26 21:20:53 millert Exp $";
d597 1
a597 1
		/* Either the above check was true or an error occured */
d612 1
a612 1
		/* Either the above check was true or an error occured */
d798 1
a798 1
				   "Read error occured while receiving file.");
@


1.7
log
@rdist 6.1.4 + OpenBSD patches + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
"$OpenBSD$";
d1316 1
a1316 1
			fromhost = strdup(cp);
@


1.6
log
@readlink len-1
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.5 1996/07/25 05:31:03 millert Exp $	*/
d36 1
d38 5
a42 1
"$OpenBSD: server.c,v 1.5 1996/07/25 05:31:03 millert Exp $";
d254 1
a254 1
		if (gr = mygetgroup(group)) {
d364 1
a364 1
	while (dp = readdir(d)) {
d378 1
a378 1
		while (*ptarget++ = *cp++)
d438 1
a438 1
	while (dp = readdir(d)) {
d452 1
a452 1
		while (*ptarget++ = *cp++)
d710 1
a710 1
		return((char *) NULL);
d717 1
a717 1
		return((char *) NULL);
d723 1
a723 1
		return((char *) NULL);
d1046 1
a1046 1
				if (cp = getusername(stb.st_uid, target, o))
d1055 1
a1055 1
				if (cp = getgroupname(stb.st_gid, target, o))
d1109 2
a1110 2
			    chkparent(target, opts) == 0 && 
			    mkdir(target, mode) == 0) {
d1170 3
a1172 2
		if ((i = readlink(target, tbuf, sizeof(tbuf)-1)) >= 0 &&
		    i == size && strncmp(buf, tbuf, (int) size) == 0) {
d1254 1
a1254 1
	newname = strtok((char *)NULL, " ");
d1318 1
a1318 1
#if defined(SETARGS)
d1320 1
a1320 1
#endif /* SETARGS */
d1341 1
a1341 1
		if (estr = msgparseopts(cp, TRUE)) {
d1427 1
a1427 1
	group = strtok((char *)NULL, " ");
d1458 1
a1458 1
			while (*ptarget++ = *file++)
@


1.5
log
@Updated to rdist 6.1.3.  Used real snprintf() (instead of string length
in the format) since we have it.
@
text
@d1 1
a1 1
/*	$OpenBSD: server.c,v 1.4 1996/06/26 05:38:24 deraadt Exp $	*/
d37 1
a37 1
"$OpenBSD: server.c,v 1.4 1996/06/26 05:38:24 deraadt Exp $";
d1165 1
a1165 1
		if ((i = readlink(target, tbuf, sizeof(tbuf))) >= 0 &&
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
a37 1
"$OpenBSD: server.c,v 1.3 1996/06/25 22:43:26 deraadt Exp $";
d396 7
a402 1
	message(MT_CHANGE|MT_REMOTE, "%s: removed", target);
d759 1
d923 12
d1361 1
a1361 1
	int freespace = -1, freefiles = -1;
d1483 1
a1483 1
		int fsize = size / 1024;
@


1.3
log
@open O_EXCL instead of creat; for writable rdist directories... still small DOS
@
text
@d1 2
d37 1
a37 1
"$Id: server.c,v 1.2 1996/03/05 03:16:21 dm Exp $";
@


1.2
log
@rdist 6.1.2
@
text
@d35 1
a35 1
"$Id: server.c,v 6.82 1996/01/30 02:29:43 mcooper Exp $";
d755 1
a755 1
	if ((f = creat(new, mode)) < 0) {
d757 1
a757 1
		    (f = creat(new, mode)) < 0) {
@


1.1
log
@rdist 6.1.1
@
text
@d35 1
a35 1
"$Id: server.c,v 6.79 1996/01/02 21:09:16 mcooper Exp $";
d189 2
d201 2
a202 1
		} else if (pw == NULL || strcmp(owner, last_owner) != 0) {
d215 2
a216 1
				uid = pw->pw_uid;
d220 2
a221 2
			uid = pw->pw_uid;
			primegid = pw->pw_gid;
d717 18
d747 1
a747 1
	int f, wrerr, olderrno;
d793 25
a817 1
		if (wrerr == 0 && xwrite(f, buf, amt) != amt) {
d828 1
d945 3
d1561 2
a1562 1
	if (setjmp(finish_jmpbuf))
d1564 2
d1586 1
d1592 1
d1599 1
d1612 2
a1613 1
		if (n == -1)		/* EOF */
d1615 1
d1692 1
@
