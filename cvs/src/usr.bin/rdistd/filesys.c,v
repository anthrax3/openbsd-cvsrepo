head	1.19;
access;
symbols
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.8
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.4
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.12.0.14
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.10
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.28
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.24
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.22
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.20
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.18
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.16
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.8
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.19
date	2015.01.21.04.08.37;	author guenther;	state Exp;
branches;
next	1.18;
commitid	odBXDHtM07CJ1lov;

1.18
date	2015.01.20.09.00.16;	author guenther;	state Exp;
branches;
next	1.17;
commitid	0Y0sKBv6c3xIKoav;

1.17
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	Uu5nFG3wCl0LACBb;

1.16
date	2015.01.10.07.56.16;	author guenther;	state Exp;
branches;
next	1.15;
commitid	5u9Lfw7qnVkP1oHx;

1.15
date	2014.07.05.10.21.24;	author guenther;	state Exp;
branches;
next	1.14;
commitid	r8EYE1OfDRw3QDRj;

1.14
date	2014.07.05.07.58.41;	author guenther;	state Exp;
branches;
next	1.13;
commitid	zEROlkuwKt3KIqlJ;

1.13
date	2014.07.05.06.33.54;	author guenther;	state Exp;
branches;
next	1.12;
commitid	h3KYLdjPYFpJP1e5;

1.12
date	2011.04.10.15.47.28;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.03.02.56.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.14.01.34.35;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.05.20.31.58;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	99.11.26.21.32.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.06.26.21.20.48;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.20.46.40;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.38.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.05.03.16.17;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.02.03.12.12.57;	author dm;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Assume NFS_CHECK and RO_CHECK are defined.
We only need the dev_t and not the entire struct stat in mntinfo.
Delete some superfluous casts.
@
text
@/*	$OpenBSD: filesys.c,v 1.18 2015/01/20 09:00:16 guenther Exp $	*/

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/mount.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>

#include "server.h"

/*
 * This file contains functions dealing with getting info
 * about mounted filesystems.
 */


jmp_buf env;

/*
 * Given a pathname, find the fullest component that exists.
 * If statbuf is not NULL, set it to point at our stat buffer.
 */
char *
find_file(char *pathname, struct stat *statbuf, int *isvalid)
{
	static char last_pathname[PATH_MAX];
	static char file[PATH_MAX + 3];
	static struct stat filestat;
	char *p;

	/*
	 * Mark the statbuf as invalid to start with.
	 */
	*isvalid = 0;

	/*
	 * If this is the same pathname as the last time, and
	 * the file buffer is valid and we're doing the same stat()
	 * or lstat(), then set statbuf to the last filestat and 
	 * return the last file we found.
	 */
	if (strcmp(pathname, last_pathname) == 0 && file[0]) {
		if (statbuf)
			statbuf = &filestat;
		if (strcmp(pathname, file) == 0)
			*isvalid = 1;
		return(file);
	}

	if (strlen(pathname) > sizeof(file) + 3) {
		error("%s: Name to large for buffer.", pathname);
	        return(NULL);
	}

	/*
	 * Save for next time
	 */
	(void) strlcpy(last_pathname, pathname, sizeof(last_pathname));

	if (*pathname == '/')
	        (void) strlcpy(file, pathname, sizeof(file));
	else {
		/*
		 * Ensure we have a directory (".") in our path
		 * so we have something to stat in case the file
		 * does not exist.
		 */
	        (void) strlcpy(file, "./", sizeof(file));
		(void) strlcat(file, pathname, sizeof(file));
	}

	while (lstat(file, &filestat) != 0) {
		/*
		 * Trim the last part of the pathname to try next level up
		 */
		if (errno == ENOENT) {
			/*
			 * Trim file name to get directory name.
			 * Normally we want to change /dir1/dir2/file
			 * into "/dir1/dir2/."
			 */
			if ((p = strrchr(file, '/')) != NULL) {
				if (strcmp(p, "/.") == 0) {
					*p = CNULL;
				} else {
					*++p = '.';
					*++p = CNULL;
				}
			} else {
				/*
				 * Couldn't find anything, so give up.
				 */
				debugmsg(DM_MISC, "Cannot find dir of `%s'",
					 pathname);
				return(NULL);
			}
			continue;
		} else {
			error("%s: lstat failed: %s", pathname, SYSERR);
			return(NULL);
		}
	}

	if (statbuf)
		bcopy(&filestat, statbuf, sizeof(filestat));

	/*
	 * Trim the "/." that we added.
	 */
	p = &file[strlen(file) - 1];
	if (*p == '.')
		*p-- = CNULL;
	for ( ; p && *p && *p == '/' && p != file; --p)
		*p = CNULL;

	/*
	 * If this file is a symlink we really want the parent directory
	 * name in case the symlink points to another filesystem.
	 */
	if (S_ISLNK(filestat.st_mode))
		if ((p = strrchr(file, '/')) && *p+1) {
			/* Is this / (root)? */
			if (p == file)
				file[1] = CNULL;
			else
				*p = CNULL;
		}

	if (strcmp(pathname, file) == 0)
		*isvalid = 1;

	return(*file ? file : NULL);
}


/*
 * Find the device that "filest" is on in the "mntinfo" linked list.
 */
mntent_t *
findmnt(struct stat *filest, struct mntinfo *mntinfo)
{
	struct mntinfo *mi;

	for (mi = mntinfo; mi; mi = mi->mi_nxt) {
		if (mi->mi_mnt->me_flags & MEFLAG_IGNORE)
			continue;
		if (filest->st_dev == mi->mi_dev)
			return(mi->mi_mnt);
	}

	return(NULL);
}

/*
 * Is "mnt" a duplicate of any of the mntinfo->mi_mnt elements?
 */
int
isdupmnt(mntent_t *mnt, struct mntinfo *mntinfo)
{
	struct mntinfo *m;

	for (m = mntinfo; m; m = m->mi_nxt)
		if (strcmp(m->mi_mnt->me_path, mnt->me_path) == 0)
			return(1);

	return(0);
}

/*
 * Alarm clock
 */
void
wakeup(int dummy)
{
	debugmsg(DM_CALL, "wakeup() in filesys.c called");
	longjmp(env, 1);
}

/*
 * Make a linked list of mntinfo structures.
 * Use "mi" as the base of the list if it's non NULL.
 */
struct mntinfo *
makemntinfo(struct mntinfo *mi)
{
	static struct mntinfo *mntinfo;
	struct mntinfo *newmi, *m;
	struct stat mntstat;
	mntent_t *mnt;
	int timeo = 310;

	if (!setmountent()) {
		message(MT_NERROR, "setmntent failed: %s", SYSERR);
		return(NULL);
	}

	(void) signal(SIGALRM, wakeup);
	(void) alarm(timeo);
	if (setjmp(env)) {
		message(MT_NERROR, "Timeout getting mount info");
		return(NULL);
	}

	mntinfo = mi;
	while ((mnt = getmountent()) != NULL) {
		debugmsg(DM_MISC, "mountent = '%s'", mnt->me_path);

		/*
		 * Make sure we don't already have it for some reason
		 */
		if (isdupmnt(mnt, mntinfo))
			continue;

		/*
		 * Get stat info
		 */
		if (stat(mnt->me_path, &mntstat) != 0) {
			message(MT_WARNING, "%s: Cannot stat filesystem: %s", 
				mnt->me_path, SYSERR);
			continue;
		}

		/*
		 * Create new entry
		 */
		newmi = xcalloc(1, sizeof(*newmi));
		newmi->mi_mnt = newmountent(mnt);
		newmi->mi_dev = mntstat.st_dev;

		/*
		 * Add entry to list
		 */
		if (mntinfo) {
			for (m = mntinfo; m->mi_nxt; m = m->mi_nxt)
				continue;
			m->mi_nxt = newmi;
		} else
			mntinfo = newmi;
	}

	alarm(0);
	endmountent();

	return(mntinfo);
}

/*
 * Given a name like /usr/src/etc/foo.c returns the mntent
 * structure for the file system it lives in.
 *
 * If "statbuf" is not NULL it is used as the stat buffer too avoid
 * stat()'ing the file again back in server.c.
 */
mntent_t *
getmntpt(char *pathname, struct stat *statbuf, int *isvalid)
{
	static struct mntinfo *mntinfo = NULL;
	static struct stat filestat;
	struct stat *pstat;
	struct mntinfo *tmpmi;
	mntent_t *mnt;

	/*
	 * Use the supplied stat buffer if not NULL or our own.
	 */
	if (statbuf) 
		pstat = statbuf;
	else
		pstat = &filestat;

	if (!find_file(pathname, pstat, isvalid))
	        return(NULL);

	/*
	 * Make mntinfo if it doesn't exist.
	 */
	if (!mntinfo)
		mntinfo = makemntinfo(NULL);

	/*
	 * Find the mnt that pathname is on.
	 */
	if ((mnt = findmnt(pstat, mntinfo)) != NULL)
		return(mnt);

	/*
	 * We failed to find correct mnt, so maybe it's a newly
	 * mounted filesystem.  We rebuild mntinfo and try again.
	 */
	if ((tmpmi = makemntinfo(mntinfo)) != NULL) {
		mntinfo = tmpmi;
		if ((mnt = findmnt(pstat, mntinfo)) != NULL)
			return(mnt);
	}

	error("%s: Could not find mount point", pathname);
	return(NULL);
}


/*
 * Is "path" NFS mounted?  Return 1 if it is, 0 if not, or -1 on error.
 */
int
is_nfs_mounted(char *path, struct stat *statbuf, int *isvalid)
{
	mntent_t *mnt;

	if ((mnt = getmntpt(path, statbuf, isvalid)) == NULL)
		return(-1);

	if (mnt->me_flags & MEFLAG_NFS)
		return(1);

	return(0);
}

/*
 * Is "path" on a read-only mounted filesystem?  
 * Return 1 if it is, 0 if not, or -1 on error.
 */
int
is_ro_mounted(char *path, struct stat *statbuf, int *isvalid)
{
	mntent_t *mnt;

	if ((mnt = getmntpt(path, statbuf, isvalid)) == NULL)
		return(-1);

	if (mnt->me_flags & MEFLAG_READONLY)
		return(1);

	return(0);
}

/*
 * Is "path" a symlink?
 * Return 1 if it is, 0 if not, or -1 on error.
 */
int
is_symlinked(char *path, struct stat *statbuf, int *isvalid)
{
	static struct stat stb;

	if (!(*isvalid)) {
		if (lstat(path, &stb) != 0)
			return(-1);
		statbuf = &stb;
	}
	
	if (S_ISLNK(statbuf->st_mode))
		return(1);

	return(0);
}

/*
 * Get filesystem information for "file".  Set freespace
 * to the amount of free (available) space and number of free
 * files (inodes) on the filesystem "file" resides on.
 * Returns 0 on success or -1 on failure.
 * Filesystem values < 0 indicate unsupported or unavailable
 * information.
 */
int
getfilesysinfo(char *file, int64_t *freespace, int64_t *freefiles)
{
	struct statfs statfsbuf;
	char *mntpt;
	int64_t val;
	int t, r;

	/*
	 * Get the mount point of the file.
	 */
	mntpt = find_file(file, NULL, &t);
	if (!mntpt) {
		debugmsg(DM_MISC, "unknown mount point for `%s'", file);
		return(-1);
	}

	r = statfs(mntpt, &statfsbuf);
	if (r < 0) {
		error("%s: Cannot statfs filesystem: %s.", mntpt, SYSERR);
		return(-1);
	}

	/*
	 * If values are < 0, then assume the value is unsupported
	 * or unavailable for that filesystem type.
	 */
	val = -1;
	if (statfsbuf.f_bavail >= 0)
		val = (statfsbuf.f_bavail * (statfsbuf.f_bsize / 512)) / 2;
	*freespace = val;

	val = -1;
	if (statfsbuf.f_favail >= 0)
		val = statfsbuf.f_favail;
	*freefiles = val;

	return(0);
}
@


1.18
log
@Split out from rdist/defs.h the client-only and server-only bits into
 rdist/client.h and rdistd/server.h
Only put #includes in .h files that are necessary for the .h to be used;
 all other #includes go in the .c files
Move all extern variable declarations to the .h files, renaming local
 variables to avoid shadowing
Replace me_type member of mntent_t with an "is NFS?" flag bit
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.17 2015/01/16 06:40:11 deraadt Exp $	*/
d111 1
a111 1
			if ((p = (char *) strrchr(file, '/')) != NULL) {
d134 1
a134 1
		bcopy((char *) &filestat, (char *) statbuf, sizeof(filestat));
d150 1
a150 1
		if ((p = (char *) strrchr(file, '/')) && *p+1) {
a163 1
#if defined(NFS_CHECK) || defined(RO_CHECK)
d176 1
a176 1
		if (filest->st_dev == mi->mi_statb->st_dev)
d255 1
a255 1
		newmi = (struct mntinfo *) xcalloc(1, sizeof(struct mntinfo));
d257 1
a257 4
		newmi->mi_statb = 
		    (struct stat *) xcalloc(1, sizeof(struct stat));
		bcopy((char *) &mntstat, (char *) newmi->mi_statb, 
		      sizeof(struct stat));
a328 1
#endif /* NFS_CHECK || RO_CHECK */
a329 1
#if	defined(NFS_CHECK)
a345 1
#endif	/* NFS_CHECK */
a346 1
#if	defined(RO_CHECK)
d356 1
a356 1
	if ((mnt = (mntent_t *) getmntpt(path, statbuf, isvalid)) == NULL)
a363 1
#endif	/* RO_CHECK */
@


1.17
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.16 2015/01/10 07:56:16 guenther Exp $	*/
d34 3
d38 1
a38 1
#include "defs.h"
d236 1
a236 2
		debugmsg(DM_MISC, "mountent = '%s' (%s)", 
			 mnt->me_path, mnt->me_type);
d344 1
a344 1
	if ((mnt = (mntent_t *) getmntpt(path, statbuf, isvalid)) == NULL)
d347 1
a347 5
	/*
	 * We treat "cachefs" just like NFS
	 */
	if ((strcmp(mnt->me_type, METYPE_NFS) == 0) ||
	    (strcmp(mnt->me_type, "cachefs") == 0))
@


1.16
log
@Correct reversed test of setmountent() return

Fix from Dennis Lindroos (denafcm (at) gmail.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.15 2014/07/05 10:21:24 guenther Exp $	*/
d32 1
a32 1
#include <sys/param.h>
d52 2
a53 2
	static char last_pathname[MAXPATHLEN];
	static char file[MAXPATHLEN + 3];
@


1.15
log
@Assume we have getfsstat(); simplify the interface to the *mountent()
wrappers
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.14 2014/07/05 07:58:41 guenther Exp $	*/
d219 1
a219 1
	if (setmountent()) {
@


1.14
log
@Assume BSD44: statfs()
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.13 2014/07/05 06:33:54 guenther Exp $	*/
d32 3
a212 1
	FILE *mfp;
d219 2
a220 3
	if (!(mfp = setmountent(MOUNTED_FILE, "r"))) {
		message(MT_NERROR, "%s: setmntent failed: %s", 
			MOUNTED_FILE, SYSERR);
d232 1
a232 1
	while ((mnt = getmountent(mfp)) != NULL) {
d272 2
a273 2
	(void) alarm(0);
	(void) endmountent(mfp);
@


1.13
log
@A local array can't be NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.12 2011/04/10 15:47:28 krw Exp $	*/
d407 1
a407 2
#if	defined(STATFS_TYPE)
	static statfs_t statfsbuf;
d409 1
a420 7
	/*
	 * Stat the filesystem (system specific)
	 */
#if	STATFS_TYPE == STATFS_SYSV
	r = statfs(mntpt, &statfsbuf, sizeof(statfs_t), 0);
#endif
#if	STATFS_TYPE == STATFS_BSD || STATFS_TYPE == STATFS_44BSD
a421 5
#endif
#if	STATFS_TYPE == STATFS_OSF1
	r = statfs(mntpt, &statfsbuf, sizeof(statfs_t));
#endif

d431 1
d433 2
a434 2
		*freespace = (statfsbuf.f_bavail * (statfsbuf.f_bsize / 512))
			      / 2;
d436 1
a436 7
	/*
	 * BROKEN_STATFS means that statfs() does not set fields
	 * to < 0 if the field is unsupported for the filesystem type.
	 */
#if	defined(BROKEN_STATFS)
	if (statfsbuf.f_favail > 0)
#else
d438 2
a439 8
#endif 	/* BROKEN_STATFS */
		*freefiles = statfsbuf.f_favail;

#else	/* !STATFS_TYPE */

    	*freespace = *freefiles = -1;

#endif	/* STATFS_TYPE */
@


1.12
log
@Apply some tough type-love and give rdist a chance to handle files
larger than 2GB. Diff from Stephan R. Gerber via PR#6586, tweaks
by me.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.11 2009/10/27 23:59:42 deraadt Exp $	*/
d155 1
a155 1
	return((file && *file) ? file : NULL);
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.10 2003/06/03 02:56:15 millert Exp $	*/
d405 1
a405 1
getfilesysinfo(char *file, long *freespace, long *freefiles)
d452 1
a452 1
	if (statfsbuf.f_ffree > 0)
d454 1
a454 1
	if (statfsbuf.f_ffree >= 0)
d456 1
a456 1
		*freefiles = statfsbuf.f_ffree;
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.9 2003/05/14 01:34:35 millert Exp $	*/
a32 17

#ifndef lint
#if 0
static char RCSid[] __attribute__((__unused__)) = 
"$From: filesys.c,v 1.2 1999/08/04 15:57:33 christos Exp $";
#else
static char RCSid[] __attribute__((__unused__)) = 
"$OpenBSD: filesys.c,v 1.9 2003/05/14 01:34:35 millert Exp $";
#endif

static char sccsid[] __attribute__((__unused__)) =
"@@(#)filesys.c";

static char copyright[] __attribute__((__unused__)) =
"@@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */
@


1.9
log
@ o Sync w/ freerdist 0.92 minus the compress option
 o KNF and ANSIfy the function headers

Sparse file support is currently a no-op since it didn't work.
Proper sparse file support will be added later.
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.8 2003/04/05 20:31:58 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
"$OpenBSD: filesys.c,v 1.8 2003/04/05 20:31:58 deraadt Exp $";
@


1.8
log
@strings; ok miod ho krw
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.7 2001/11/19 19:02:15 mpech Exp $	*/
d36 2
d40 2
a41 2
static char RCSid[] = 
"$From: filesys.c,v 6.24 1996/01/30 01:57:07 mcooper Exp $";
d43 2
a44 2
static char RCSid[] = 
"$OpenBSD: filesys.c,v 1.7 2001/11/19 19:02:15 mpech Exp $";
d47 2
a48 1
static char sccsid[] = "@@(#)filesys.c";
d50 1
a50 1
static char copyright[] =
a59 2
#include "defs.h"
#include "filesys.h"
d67 2
a68 4
char *find_file(pathname, statbuf, isvalid)
	char *pathname;
	struct stat *statbuf;
	int *isvalid;
d94 1
a94 1
	if ((int)strlen(pathname) > sizeof(file)+3) {
d102 1
a102 1
	(void) strlcpy(last_pathname, pathname, sizeof last_pathname);
d105 1
a105 1
	        (void) strlcpy(file, pathname, sizeof file);
d112 2
a113 2
	        (void) strlcpy(file, "./", sizeof file);
		(void) strlcat(file, pathname, sizeof file);
d126 1
a126 1
			if ((p = (char *) strrchr(file, '/'))) {
d128 1
a128 1
				    *p = CNULL;
d130 2
a131 2
				    *++p = '.';
				    *++p = CNULL;
d184 2
a185 3
mntent_t *findmnt(filest, mntinfo)
	struct stat *filest;
	struct mntinfo *mntinfo;
d202 2
a203 3
int isdupmnt(mnt, mntinfo)
	mntent_t *mnt;
	struct mntinfo *mntinfo;
d217 2
a218 1
void wakeup()
d228 2
a229 2
struct mntinfo *makemntinfo(mi) 
	struct mntinfo *mi;
d252 1
a252 1
	while ((mnt = getmountent(mfp))) {
d285 2
a286 1
			for (m = mntinfo; m->mi_nxt; m = m->mi_nxt);
d305 2
a306 4
mntent_t *getmntpt(pathname, statbuf, isvalid)
	char *pathname;
	struct stat *statbuf;
	int *isvalid;
d334 1
a334 1
	if ((mnt = findmnt(pstat, mntinfo)))
d341 1
a341 1
	if ((tmpmi = makemntinfo(mntinfo))) {
d343 1
a343 1
		if ((mnt = findmnt(pstat, mntinfo)))
d357 2
a358 4
int is_nfs_mounted(path, statbuf, isvalid)
	char *path;
	struct stat *statbuf;
	int *isvalid;
d381 2
a382 4
int is_ro_mounted(path, statbuf, isvalid)
	char *path;
	struct stat *statbuf;
	int *isvalid;
d400 2
a401 5
int is_symlinked(path, statbuf, isvalid)
	/*ARGSUSED*/
	char *path;
	struct stat *statbuf;
	int *isvalid;
d425 2
a426 4
int getfilesysinfo(file, freespace, freefiles)
	char *file;
	long *freespace;
	long *freefiles;
d448 1
a448 1
#if	STATFS_TYPE == STATFS_BSD
@


1.7
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.6 1999/11/26 21:32:38 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: filesys.c,v 1.6 1999/11/26 21:32:38 millert Exp $";
d103 1
a103 1
	(void) strcpy(last_pathname, pathname);
d106 1
a106 1
	        (void) strcpy(file, pathname);
d113 2
a114 2
	        (void) strcpy(file, "./");
		(void) strcat(file, pathname);
@


1.6
log
@Make two variables that ought not to be static be auto.
Remove a useless loop invariant (already tested before the loop is reached).
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.5 1998/06/26 21:20:48 millert Exp $	*/
d42 1
a42 1
"$OpenBSD: filesys.c,v 1.5 1998/06/26 21:20:48 millert Exp $";
d74 1
a74 1
	register char *p;
d189 1
a189 1
	register struct mntinfo *mi;
d208 1
a208 1
	register struct mntinfo *m;
d315 1
a315 1
	register mntent_t *mnt;
@


1.5
log
@rdist 6.1.4 + OpenBSD patches + some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
"$OpenBSD$";
d234 2
a235 1
	static struct mntinfo *mntinfo, *newmi, *m;
d287 1
a287 1
			for (m = mntinfo; m && m->mi_nxt; m = m->mi_nxt);
@


1.4
log
@Fixed a bug causing a CPU loop if dist'ing a file whose parent
dir doesn't exist on the target machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: filesys.c,v 1.3 1996/06/26 05:38:21 deraadt Exp $	*/
d37 1
d39 5
a43 1
"$OpenBSD: filesys.c,v 1.3 1996/06/26 05:38:21 deraadt Exp $";
d97 1
a97 1
	        return((char *) NULL);
d140 1
a140 1
				return((char *) NULL);
d145 1
a145 1
			return((char *) NULL);
d177 1
a177 1
	return((file && *file) ? file : (char *)NULL);
d198 1
a198 1
	return((mntent_t *) NULL);
d242 1
a242 1
		return((struct mntinfo *) NULL);
d249 1
a249 1
		return((struct mntinfo *) NULL);
d253 1
a253 1
	while (mnt = getmountent(mfp)) {
d325 1
a325 1
	        return((mntent_t *) NULL);
d331 1
a331 1
		mntinfo = makemntinfo((struct mntinfo *) NULL);
d336 1
a336 1
	if (mnt = findmnt(pstat, mntinfo))
d343 1
a343 1
	if (tmpmi = makemntinfo(mntinfo)) {
d345 1
a345 1
		if (mnt = findmnt(pstat, mntinfo))
d350 1
a350 1
	return((mntent_t *) NULL);
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
"$OpenBSD: filesys.c,v 1.2 1996/03/05 03:16:17 dm Exp $";
d122 7
a128 3
			if (p = (char *) strrchr(file, '/')) {
				*++p = '.';
				*++p = CNULL;
@


1.2
log
@rdist 6.1.2
@
text
@d1 2
d38 1
a38 1
"$Id: filesys.c,v 6.24 1996/01/30 01:57:07 mcooper Exp $";
@


1.1
log
@rdist 6.1.1
@
text
@d36 1
a36 1
"$Id: filesys.c,v 6.23 1994/08/15 22:06:43 mcooper Exp $";
d358 5
a362 1
	if (strcmp(mnt->me_type, METYPE_NFS) == 0)
@
