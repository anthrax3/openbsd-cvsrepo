head	1.163;
access;
symbols
	OPENBSD_6_1:1.163.0.4
	OPENBSD_6_1_BASE:1.163
	OPENBSD_6_0:1.147.0.2
	OPENBSD_6_0_BASE:1.147
	OPENBSD_5_9:1.145.0.2
	OPENBSD_5_9_BASE:1.145
	OPENBSD_5_8:1.139.0.4
	OPENBSD_5_8_BASE:1.139
	OPENBSD_5_7:1.138.0.2
	OPENBSD_5_7_BASE:1.138
	OPENBSD_5_6:1.126.0.4
	OPENBSD_5_6_BASE:1.126
	OPENBSD_5_5:1.114.0.4
	OPENBSD_5_5_BASE:1.114
	OPENBSD_5_4:1.109.0.2
	OPENBSD_5_4_BASE:1.109
	OPENBSD_5_3:1.107.0.2
	OPENBSD_5_3_BASE:1.107
	OPENBSD_5_2:1.105.0.2
	OPENBSD_5_2_BASE:1.105
	OPENBSD_5_1_BASE:1.103
	OPENBSD_5_1:1.103.0.6
	OPENBSD_5_0:1.103.0.4
	OPENBSD_5_0_BASE:1.103
	OPENBSD_4_9:1.103.0.2
	OPENBSD_4_9_BASE:1.103
	OPENBSD_4_8:1.102.0.2
	OPENBSD_4_8_BASE:1.102
	OPENBSD_4_7:1.97.0.2
	OPENBSD_4_7_BASE:1.97
	OPENBSD_4_6:1.91.0.4
	OPENBSD_4_6_BASE:1.91
	OPENBSD_4_5:1.83.0.2
	OPENBSD_4_5_BASE:1.83
	OPENBSD_4_4:1.80.0.2
	OPENBSD_4_4_BASE:1.80
	OPENBSD_4_3:1.75.0.2
	OPENBSD_4_3_BASE:1.75
	OPENBSD_4_2:1.74.0.2
	OPENBSD_4_2_BASE:1.74
	OPENBSD_4_1:1.72.0.2
	OPENBSD_4_1_BASE:1.72
	OPENBSD_4_0:1.68.0.2
	OPENBSD_4_0_BASE:1.68
	OPENBSD_3_9:1.57.0.2
	OPENBSD_3_9_BASE:1.57
	OPENBSD_3_8:1.56.0.2
	OPENBSD_3_8_BASE:1.56
	OPENBSD_3_7:1.51.0.2
	OPENBSD_3_7_BASE:1.51
	OPENBSD_3_6:1.50.0.2
	OPENBSD_3_6_BASE:1.50
	OPENBSD_3_5:1.49.0.2
	OPENBSD_3_5_BASE:1.49
	OPENBSD_3_4:1.47.0.2
	OPENBSD_3_4_BASE:1.47
	OPENBSD_3_3:1.44.0.2
	OPENBSD_3_3_BASE:1.44
	OPENBSD_3_2:1.39.0.2
	OPENBSD_3_2_BASE:1.39
	OPENBSD_3_1:1.38.0.2
	OPENBSD_3_1_BASE:1.38
	OPENBSD_3_0:1.35.0.2
	OPENBSD_3_0_BASE:1.35
	OPENBSD_2_9_BASE:1.33
	OPENBSD_2_9:1.33.0.4
	OPENBSD_2_8:1.33.0.2
	OPENBSD_2_8_BASE:1.33
	OPENBSD_2_7:1.30.0.2
	OPENBSD_2_7_BASE:1.30
	OPENBSD_2_6:1.24.0.4
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.24.0.2
	OPENBSD_2_5_BASE:1.24
	OPENBSD_2_4:1.23.0.2
	OPENBSD_2_4_BASE:1.23
	OPENBSD_2_3:1.18.0.2
	OPENBSD_2_3_BASE:1.18
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12;
locks; strict;
comment	@ * @;


1.163
date	2017.03.07.08.00.23;	author sunil;	state Exp;
branches;
next	1.162;
commitid	lK8Mdfh5nJiQaLI9;

1.162
date	2017.03.02.09.29.53;	author sthen;	state Exp;
branches;
next	1.161;
commitid	WnPXsenwTW7Af6mZ;

1.161
date	2017.02.28.06.31.12;	author guenther;	state Exp;
branches;
next	1.160;
commitid	za2djg3PCSnGLlrt;

1.160
date	2017.01.21.08.33.07;	author krw;	state Exp;
branches;
next	1.159;
commitid	l2fu419jw6ah0BY2;

1.159
date	2017.01.20.05.51.50;	author krw;	state Exp;
branches;
next	1.158;
commitid	WxVSpCQFucTcyZ7W;

1.158
date	2017.01.14.18.03.11;	author jca;	state Exp;
branches;
next	1.157;
commitid	TJil2WIV5q8cFHcn;

1.157
date	2017.01.10.17.43.12;	author deraadt;	state Exp;
branches;
next	1.156;
commitid	oJRD7ipVpdJdOIGT;

1.156
date	2017.01.07.12.10.11;	author tb;	state Exp;
branches;
next	1.155;
commitid	GMuIGwdUIxdmOCGd;

1.155
date	2017.01.03.17.00.04;	author deraadt;	state Exp;
branches;
next	1.154;
commitid	9X2MbmZeyJX7O96R;

1.154
date	2016.12.28.17.48.04;	author deraadt;	state Exp;
branches;
next	1.153;
commitid	UIBQPJAx3NVjVFnr;

1.153
date	2016.12.24.13.52.42;	author jsing;	state Exp;
branches;
next	1.152;
commitid	h1X7mgIq76umvhOX;

1.152
date	2016.12.16.17.44.59;	author krw;	state Exp;
branches;
next	1.151;
commitid	q7MaMOobu9Z5raUb;

1.151
date	2016.12.08.19.59.51;	author millert;	state Exp;
branches;
next	1.150;
commitid	FmV3kLBIGiAB0ty3;

1.150
date	2016.12.08.19.31.17;	author millert;	state Exp;
branches;
next	1.149;
commitid	Je8NVUWz46d46WDm;

1.149
date	2016.08.20.20.18.42;	author millert;	state Exp;
branches;
next	1.148;
commitid	F2AU4cYS2XzonLey;

1.148
date	2016.08.18.16.23.06;	author millert;	state Exp;
branches;
next	1.147;
commitid	ku5uVo6mFCThpOmQ;

1.147
date	2016.05.27.15.16.16;	author jsing;	state Exp;
branches;
next	1.146;
commitid	nmSAEJ7kJwFx9GH4;

1.146
date	2016.05.06.22.06.09;	author jca;	state Exp;
branches;
next	1.145;
commitid	ivkrTCmMssc36Xjc;

1.145
date	2016.01.28.21.31.50;	author martijn;	state Exp;
branches;
next	1.144;
commitid	ch8LZe38G0AKNxGl;

1.144
date	2016.01.08.20.36.01;	author sthen;	state Exp;
branches;
next	1.143;
commitid	ur0LA5UVbA9t1Ysx;

1.143
date	2015.10.13.08.53.43;	author guenther;	state Exp;
branches;
next	1.142;
commitid	adMq7GmRAZvRj4Py;

1.142
date	2015.09.10.13.43.35;	author jsing;	state Exp;
branches;
next	1.141;
commitid	5LO7MyA7GrFjWVdi;

1.141
date	2015.09.10.10.35.58;	author beck;	state Exp;
branches;
next	1.140;
commitid	ZDJvybHCuqk2AN1U;

1.140
date	2015.09.09.19.23.03;	author jsing;	state Exp;
branches;
next	1.139;
commitid	X2IG5NNOPyZHX2ay;

1.139
date	2015.07.18.21.50.47;	author bluhm;	state Exp;
branches
	1.139.4.1;
next	1.138;
commitid	XU2CN0CcxASWQp5F;

1.138
date	2015.02.27.17.38.19;	author jca;	state Exp;
branches
	1.138.2.1;
next	1.137;
commitid	C0NJkHmqXFvuJn0f;

1.137
date	2015.01.16.06.40.08;	author deraadt;	state Exp;
branches;
next	1.136;
commitid	Uu5nFG3wCl0LACBb;

1.136
date	2015.01.12.15.46.55;	author bluhm;	state Exp;
branches;
next	1.135;
commitid	a8gGPdJGrmIAUUQL;

1.135
date	2014.11.25.08.22.09;	author deraadt;	state Exp;
branches;
next	1.134;
commitid	lOVHgf9oKA4knTvs;

1.134
date	2014.10.31.13.48.21;	author jsing;	state Exp;
branches;
next	1.133;
commitid	JZSdm092LMmDs9NJ;

1.133
date	2014.10.30.15.50.50;	author tedu;	state Exp;
branches;
next	1.132;
commitid	O0Vz66aCGFMbDtZw;

1.132
date	2014.10.08.04.01.10;	author doug;	state Exp;
branches;
next	1.131;
commitid	XXEbyxKssnS22KuB;

1.131
date	2014.10.06.11.47.25;	author jca;	state Exp;
branches;
next	1.130;
commitid	XvW62WG7ye1gR4L2;

1.130
date	2014.10.04.15.48.24;	author miod;	state Exp;
branches;
next	1.129;
commitid	WWDUkp1xUhX0ZIOu;

1.129
date	2014.08.25.15.36.00;	author deraadt;	state Exp;
branches;
next	1.128;
commitid	Tt75fdkxFcLU6prW;

1.128
date	2014.08.25.11.33.55;	author jca;	state Exp;
branches;
next	1.127;
commitid	kNV1Gp4HWkEf2TOO;

1.127
date	2014.08.21.16.46.48;	author jca;	state Exp;
branches;
next	1.126;
commitid	3ZbUvTPtdEj2Ffmj;

1.126
date	2014.07.14.09.26.27;	author jsing;	state Exp;
branches;
next	1.125;
commitid	BJRfx2HJ6v6eQobV;

1.125
date	2014.07.11.18.19.45;	author halex;	state Exp;
branches;
next	1.124;
commitid	qfJqzOcHblb5zgf9;

1.124
date	2014.07.11.03.31.52;	author lteo;	state Exp;
branches;
next	1.123;
commitid	TgWHWtjz2JHTa3XV;

1.123
date	2014.07.05.09.20.54;	author guenther;	state Exp;
branches;
next	1.122;
commitid	Xz2U5Wn1v5ErbpTZ;

1.122
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.121;

1.121
date	2014.05.19.20.09.22;	author jca;	state Exp;
branches;
next	1.120;

1.120
date	2014.05.19.20.05.09;	author jca;	state Exp;
branches;
next	1.119;

1.119
date	2014.05.19.20.03.16;	author jca;	state Exp;
branches;
next	1.118;

1.118
date	2014.04.09.10.10.57;	author jca;	state Exp;
branches;
next	1.117;

1.117
date	2014.03.30.22.40.38;	author jca;	state Exp;
branches;
next	1.116;

1.116
date	2014.03.30.22.39.42;	author jca;	state Exp;
branches;
next	1.115;

1.115
date	2014.03.30.22.37.41;	author jca;	state Exp;
branches;
next	1.114;

1.114
date	2014.03.02.17.57.18;	author tedu;	state Exp;
branches
	1.114.4.1;
next	1.113;

1.113
date	2014.02.26.20.48.06;	author tedu;	state Exp;
branches;
next	1.112;

1.112
date	2013.12.24.13.00.59;	author jca;	state Exp;
branches;
next	1.111;

1.111
date	2013.11.13.20.41.10;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2013.10.27.18.31.24;	author guenther;	state Exp;
branches;
next	1.109;

1.109
date	2013.04.09.08.58.46;	author sthen;	state Exp;
branches;
next	1.108;

1.108
date	2013.03.30.10.11.35;	author tobias;	state Exp;
branches;
next	1.107;

1.107
date	2012.08.18.06.46.46;	author haesbaert;	state Exp;
branches;
next	1.106;

1.106
date	2012.08.14.20.47.08;	author haesbaert;	state Exp;
branches;
next	1.105;

1.105
date	2012.04.30.13.41.26;	author haesbaert;	state Exp;
branches;
next	1.104;

1.104
date	2012.04.23.21.22.02;	author sthen;	state Exp;
branches;
next	1.103;

1.103
date	2010.08.25.20.32.37;	author martynas;	state Exp;
branches;
next	1.102;

1.102
date	2010.07.23.22.27.16;	author halex;	state Exp;
branches;
next	1.101;

1.101
date	2010.07.03.00.21.14;	author halex;	state Exp;
branches;
next	1.100;

1.100
date	2010.06.29.23.12.33;	author halex;	state Exp;
branches;
next	1.99;

1.99
date	2010.06.03.07.50.02;	author halex;	state Exp;
branches;
next	1.98;

1.98
date	2010.06.03.07.39.53;	author phessler;	state Exp;
branches;
next	1.97;

1.97
date	2009.10.16.12.28.04;	author martynas;	state Exp;
branches;
next	1.96;

1.96
date	2009.08.26.11.54.31;	author sthen;	state Exp;
branches;
next	1.95;

1.95
date	2009.08.06.23.33.35;	author martynas;	state Exp;
branches;
next	1.94;

1.94
date	2009.08.03.21.34.54;	author martynas;	state Exp;
branches;
next	1.93;

1.93
date	2009.07.27.23.11.26;	author martynas;	state Exp;
branches;
next	1.92;

1.92
date	2009.07.18.12.43.30;	author jsg;	state Exp;
branches;
next	1.91;

1.91
date	2009.06.29.09.58.40;	author halex;	state Exp;
branches;
next	1.90;

1.90
date	2009.06.13.20.01.10;	author martynas;	state Exp;
branches;
next	1.89;

1.89
date	2009.06.04.23.37.09;	author halex;	state Exp;
branches;
next	1.88;

1.88
date	2009.06.04.20.58.34;	author martynas;	state Exp;
branches;
next	1.87;

1.87
date	2009.05.10.21.45.52;	author martynas;	state Exp;
branches;
next	1.86;

1.86
date	2009.05.05.19.35.30;	author martynas;	state Exp;
branches;
next	1.85;

1.85
date	2009.04.27.21.37.13;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2009.04.26.21.26.03;	author martynas;	state Exp;
branches;
next	1.83;

1.83
date	2008.10.16.23.15.53;	author martynas;	state Exp;
branches;
next	1.82;

1.82
date	2008.10.16.21.23.49;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2008.09.26.11.11.59;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2008.07.08.21.07.57;	author martynas;	state Exp;
branches;
next	1.79;

1.79
date	2008.06.26.05.42.20;	author ray;	state Exp;
branches;
next	1.78;

1.78
date	2008.06.25.21.15.19;	author martynas;	state Exp;
branches;
next	1.77;

1.77
date	2008.06.15.04.43.20;	author martynas;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.15.03.11.28;	author martynas;	state Exp;
branches;
next	1.75;

1.75
date	2007.11.26.12.39.00;	author martynas;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.13.13.52.26;	author pyr;	state Exp;
branches;
next	1.73;

1.73
date	2007.04.17.14.58.51;	author drahn;	state Exp;
branches;
next	1.72;

1.72
date	2007.02.08.03.19.12;	author ray;	state Exp;
branches;
next	1.71;

1.71
date	2007.02.03.05.18.40;	author ray;	state Exp;
branches;
next	1.70;

1.70
date	2006.09.25.18.59.59;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2006.09.25.10.18.39;	author jsg;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.07.12.00.25;	author ray;	state Exp;
branches;
next	1.67;

1.67
date	2006.06.23.20.35.25;	author steven;	state Exp;
branches;
next	1.66;

1.66
date	2006.06.01.22.42.11;	author ray;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.25.03.48.23;	author ray;	state Exp;
branches;
next	1.64;

1.64
date	2006.05.25.03.45.25;	author ray;	state Exp;
branches;
next	1.63;

1.63
date	2006.05.25.03.43.36;	author ray;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.16.23.43.16;	author ray;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.16.16.20.42;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2006.04.25.05.45.20;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2006.04.03.21.05.14;	author uwe;	state Exp;
branches;
next	1.58;

1.58
date	2006.03.29.15.54.55;	author grunk;	state Exp;
branches;
next	1.57;

1.57
date	2006.02.01.09.19.07;	author otto;	state Exp;
branches;
next	1.56;

1.56
date	2005.08.05.21.01.53;	author fgsch;	state Exp;
branches;
next	1.55;

1.55
date	2005.07.18.02.55.59;	author fgsch;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.21.05.17.21;	author fgsch;	state Exp;
branches;
next	1.53;

1.53
date	2005.04.11.15.16.50;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2005.04.05.22.37.00;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2004.09.16.04.39.16;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2004.07.20.03.50.25;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2004.02.28.20.08.38;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.16.21.46.22;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2003.08.15.23.13.06;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2003.04.05.17.19.47;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2003.03.31.23.04.07;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2003.03.10.06.20.10;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2003.02.17.18.51.11;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.12.30.23.04.42;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2002.12.19.01.52.09;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.08.03.30.17;	author fgsch;	state Exp;
branches;
next	1.39;

1.39
date	2002.05.30.06.51.46;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2002.02.16.21.27.46;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2001.11.14.07.59.28;	author heko;	state Exp;
branches;
next	1.36;

1.36
date	2001.10.27.10.31.27;	author heko;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.03.18.49.39;	author heko;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.23.22.48.44;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.30.16.00.15;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2000.05.25.16.09.26;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.15.16.07.04;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2000.05.03.19.50.41;	author deraadt;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2000.05.02.00.54.53;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.24.03.30.16;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2000.01.09.05.14.38;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2000.01.04.17.15.12;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	99.12.08.12.57.06;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	99.02.09.03.43.48;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.09.30.07.49.36;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	98.09.28.13.38.22;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	98.09.11.08.04.24;	author marc;	state Exp;
branches;
next	1.20;

1.20
date	98.05.13.10.46.12;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	98.05.13.10.42.38;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.03.26.03.17.08;	author marc;	state Exp;
branches;
next	1.17;

1.17
date	98.02.17.23.22.54;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.09.11.01.55.15;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.09.04.04.37.15;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.07.25.21.56.20;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.07.24.14.22.21;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.05.19.05.36.56;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.04.28.21.10.06;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.04.23.20.33.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.04.18.18.56.49;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.04.16.05.02.48;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.04.14.00.48.44;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.04.10.00.17.08;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.03.21.20.59.29;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.03.14.04.32.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.02.05.04.55.16;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.02.03.01.05.37;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.02.03.01.02.37;	author millert;	state Exp;
branches;
next	;

1.30.2.1
date	2000.10.06.21.16.13;	author jason;	state Exp;
branches;
next	;

1.114.4.1
date	2014.04.09.20.35.58;	author jca;	state Exp;
branches;
next	;

1.138.2.1
date	2016.02.02.19.47.38;	author martijn;	state Exp;
branches;
next	;
commitid	5Ul8OdWS3eApneGB;

1.139.4.1
date	2016.02.02.19.43.20;	author martijn;	state Exp;
branches;
next	;
commitid	X1NyzpGEnW2roNxJ;


desc
@@


1.163
log
@tls_close() can return TLS_WANT_POLLIN/TLS_WANT_POLLOUT, handle them
appropriately.

Ok jca@@
@
text
@/*	$OpenBSD: fetch.c,v 1.162 2017/03/02 09:29:53 sthen Exp $	*/
/*	$NetBSD: fetch.c,v 1.14 1997/08/18 10:20:20 lukem Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason Thorpe and Luke Mewburn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * FTP User Program -- Command line file retrieval
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <netinet/in.h>

#include <arpa/ftp.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <libgen.h>
#include <netdb.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <stdarg.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>
#include <resolv.h>

#ifndef NOSSL
#include <tls.h>
#else /* !NOSSL */
struct tls;
#endif /* !NOSSL */

#include "ftp_var.h"
#include "cmds.h"

static int	url_get(const char *, const char *, const char *, int);
void		aborthttp(int);
void		abortfile(int);
char		hextochar(const char *);
char		*urldecode(const char *);
char		*recode_credentials(const char *_userinfo);
int		ftp_printf(FILE *, struct tls *, const char *, ...) __attribute__((format(printf, 3, 4)));
char		*ftp_readline(FILE *, struct tls *, size_t *);
size_t		ftp_read(FILE *, struct tls *, char *, size_t);
#ifndef NOSSL
int		proxy_connect(int, char *, char *);
int		SSL_vprintf(struct tls *, const char *, va_list);
char		*SSL_readline(struct tls *, size_t *);
#endif /* !NOSSL */

#define	FTP_URL		"ftp://"	/* ftp URL prefix */
#define	HTTP_URL	"http://"	/* http URL prefix */
#define	HTTPS_URL	"https://"	/* https URL prefix */
#define	FILE_URL	"file:"		/* file URL prefix */
#define FTP_PROXY	"ftp_proxy"	/* env var with ftp proxy location */
#define HTTP_PROXY	"http_proxy"	/* env var with http proxy location */

#define EMPTYSTRING(x)	((x) == NULL || (*(x) == '\0'))

static const char at_encoding_warning[] =
    "Extra `@@' characters in usernames and passwords should be encoded as %%40";

jmp_buf	httpabort;

static int	redirect_loop;

/*
 * Determine whether the character needs encoding, per RFC1738:
 *	- No corresponding graphic US-ASCII.
 *	- Unsafe characters.
 */
static int
unsafe_char(const char *c0)
{
	const char *unsafe_chars = " <>\"#{}|\\^~[]`";
	const unsigned char *c = (const unsigned char *)c0;

	/*
	 * No corresponding graphic US-ASCII.
	 * Control characters and octets not used in US-ASCII.
	 */
	return (iscntrl(*c) || !isascii(*c) ||

	    /*
	     * Unsafe characters.
	     * '%' is also unsafe, if is not followed by two
	     * hexadecimal digits.
	     */
	    strchr(unsafe_chars, *c) != NULL ||
	    (*c == '%' && (!isxdigit(*++c) || !isxdigit(*++c))));
}

/*
 * Encode given URL, per RFC1738.
 * Allocate and return string to the caller.
 */
static char *
url_encode(const char *path)
{
	size_t i, length, new_length;
	char *epath, *epathp;

	length = new_length = strlen(path);

	/*
	 * First pass:
	 * Count unsafe characters, and determine length of the
	 * final URL.
	 */
	for (i = 0; i < length; i++)
		if (unsafe_char(path + i))
			new_length += 2;

	epath = epathp = malloc(new_length + 1);	/* One more for '\0'. */
	if (epath == NULL)
		err(1, "Can't allocate memory for URL encoding");

	/*
	 * Second pass:
	 * Encode, and copy final URL.
	 */
	for (i = 0; i < length; i++)
		if (unsafe_char(path + i)) {
			snprintf(epathp, 4, "%%" "%02x",
			    (unsigned char)path[i]);
			epathp += 3;
		} else
			*(epathp++) = path[i];

	*epathp = '\0';
	return (epath);
}

/* ARGSUSED */
static void
tooslow(int signo)
{
	dprintf(STDERR_FILENO, "%s: connect taking too long\n", __progname);
	_exit(2);
}

/*
 * Retrieve URL, via the proxy in $proxyvar if necessary.
 * Modifies the string argument given.
 * Returns -1 on failure, 0 on success
 */
static int
url_get(const char *origline, const char *proxyenv, const char *outfile, int lastfile)
{
	char pbuf[NI_MAXSERV], hbuf[NI_MAXHOST], *cp, *portnum, *path, ststr[4];
	char *hosttail, *cause = "unknown", *newline, *host, *port, *buf = NULL;
	char *epath, *redirurl, *loctail, *h, *p;
	int error, i, isftpurl = 0, isfileurl = 0, isredirect = 0, rval = -1;
	struct addrinfo hints, *res0, *res;
	const char * volatile savefile;
	char * volatile proxyurl = NULL;
	char *credentials = NULL;
	volatile int s = -1, out;
	volatile sig_t oldintr, oldinti;
	FILE *fin = NULL;
	off_t hashbytes;
	const char *errstr;
	ssize_t len, wlen;
	char *proxyhost = NULL;
#ifndef NOSSL
	char *sslpath = NULL, *sslhost = NULL;
	char *full_host = NULL;
	const char *scheme;
	int ishttpurl = 0, ishttpsurl = 0;
#endif /* !NOSSL */
#ifndef SMALL
	char *locbase;
	struct addrinfo *ares = NULL;
#endif
	struct tls *tls = NULL;
	int status;
	int save_errno;
	const size_t buflen = 128 * 1024;

	direction = "received";

	newline = strdup(origline);
	if (newline == NULL)
		errx(1, "Can't allocate memory to parse URL");
	if (strncasecmp(newline, HTTP_URL, sizeof(HTTP_URL) - 1) == 0) {
		host = newline + sizeof(HTTP_URL) - 1;
#ifndef SMALL
		ishttpurl = 1;
		scheme = HTTP_URL;
#endif /* !SMALL */
	} else if (strncasecmp(newline, FTP_URL, sizeof(FTP_URL) - 1) == 0) {
		host = newline + sizeof(FTP_URL) - 1;
		isftpurl = 1;
#ifndef SMALL
		scheme = FTP_URL;
#endif /* !SMALL */
	} else if (strncasecmp(newline, FILE_URL, sizeof(FILE_URL) - 1) == 0) {
		host = newline + sizeof(FILE_URL) - 1;
		isfileurl = 1;
#ifndef NOSSL
		scheme = FILE_URL;
	} else if (strncasecmp(newline, HTTPS_URL, sizeof(HTTPS_URL) - 1) == 0) {
		host = newline + sizeof(HTTPS_URL) - 1;
		ishttpsurl = 1;
		scheme = HTTPS_URL;
#endif /* !NOSSL */
	} else
		errx(1, "url_get: Invalid URL '%s'", newline);

	if (isfileurl) {
		path = host;
	} else {
		path = strchr(host, '/');		/* Find path */
		if (EMPTYSTRING(path)) {
			if (outfile) {			/* No slash, but */
				path=strchr(host,'\0');	/* we have outfile. */
				goto noslash;
			}
			if (isftpurl)
				goto noftpautologin;
			warnx("No `/' after host (use -o): %s", origline);
			goto cleanup_url_get;
		}
		*path++ = '\0';
		if (EMPTYSTRING(path) && !outfile) {
			if (isftpurl)
				goto noftpautologin;
			warnx("No filename after host (use -o): %s", origline);
			goto cleanup_url_get;
		}
	}

noslash:

#ifndef NOSSL
	/*
	 * Look for auth header in host, since now host does not
	 * contain the path. Basic auth from RFC 2617, valid
	 * characters for path are in RFC 3986 section 3.3.
	 */
	if (proxyenv == NULL && (ishttpurl || ishttpsurl)) {
		if ((p = strchr(host, '@@')) != NULL) {
			*p = '\0';
			credentials = recode_credentials(host);
			host = p + 1;
		}
	}
#endif	/* NOSSL */

	if (outfile)
		savefile = outfile;
	else {
		if (path[strlen(path) - 1] == '/')	/* Consider no file */
			savefile = NULL;		/* after dir invalid. */
		else
			savefile = basename(path);
	}

	if (EMPTYSTRING(savefile)) {
		if (isftpurl)
			goto noftpautologin;
		warnx("No filename after directory (use -o): %s", origline);
		goto cleanup_url_get;
	}

#ifndef SMALL
	if (resume && pipeout) {
		warnx("can't append to stdout");
		goto cleanup_url_get;
	}
#endif /* !SMALL */

	if (!isfileurl && proxyenv != NULL) {		/* use proxy */
#ifndef NOSSL
		if (ishttpsurl) {
			sslpath = strdup(path);
			sslhost = strdup(host);
			if (! sslpath || ! sslhost)
				errx(1, "Can't allocate memory for https path/host.");
		}
#endif /* !NOSSL */
		proxyhost = strdup(host);
		if (proxyhost == NULL)
			errx(1, "Can't allocate memory for proxy host.");
		proxyurl = strdup(proxyenv);
		if (proxyurl == NULL)
			errx(1, "Can't allocate memory for proxy URL.");
		if (strncasecmp(proxyurl, HTTP_URL, sizeof(HTTP_URL) - 1) == 0)
			host = proxyurl + sizeof(HTTP_URL) - 1;
		else if (strncasecmp(proxyurl, FTP_URL, sizeof(FTP_URL) - 1) == 0)
			host = proxyurl + sizeof(FTP_URL) - 1;
		else {
			warnx("Malformed proxy URL: %s", proxyenv);
			goto cleanup_url_get;
		}
		if (EMPTYSTRING(host)) {
			warnx("Malformed proxy URL: %s", proxyenv);
			goto cleanup_url_get;
		}
		if (*--path == '\0')
			*path = '/';		/* add / back to real path */
		path = strchr(host, '/');	/* remove trailing / on host */
		if (!EMPTYSTRING(path))
			*path++ = '\0';		/* i guess this ++ is useless */

		path = strchr(host, '@@');	/* look for credentials in proxy */
		if (!EMPTYSTRING(path)) {
			*path = '\0';
			if (strchr(host, ':') == NULL) {
				warnx("Malformed proxy URL: %s", proxyenv);
				goto cleanup_url_get;
			}
			credentials = recode_credentials(host);
			*path = '@@'; /* restore @@ in proxyurl */

			/*
			 * This removes the password from proxyurl,
			 * filling with stars
			 */
			for (host = 1 + strchr(proxyurl + 5, ':');  *host != '@@';
			     host++)
				*host = '*';

			host = path + 1;
		}

		path = newline;
	}

	if (isfileurl) {
		struct stat st;

		s = open(path, O_RDONLY);
		if (s == -1) {
			warn("Can't open file %s", path);
			goto cleanup_url_get;
		}

		if (fstat(s, &st) == -1)
			filesize = -1;
		else
			filesize = st.st_size;

		/* Open the output file.  */
		if (!pipeout) {
#ifndef SMALL
			if (resume)
				out = open(savefile, O_CREAT | O_WRONLY |
					O_APPEND, 0666);

			else
#endif /* !SMALL */
				out = open(savefile, O_CREAT | O_WRONLY |
					O_TRUNC, 0666);
			if (out < 0) {
				warn("Can't open %s", savefile);
				goto cleanup_url_get;
			}
		} else
			out = fileno(stdout);

#ifndef SMALL
		if (resume) {
			if (fstat(out, &st) == -1) {
				warn("Can't fstat %s", savefile);
				goto cleanup_url_get;
			}
			if (lseek(s, st.st_size, SEEK_SET) == -1) {
				warn("Can't lseek %s", path);
				goto cleanup_url_get;
			}
			restart_point = st.st_size;
		}
#endif /* !SMALL */

		/* Trap signals */
		oldintr = NULL;
		oldinti = NULL;
		if (setjmp(httpabort)) {
			if (oldintr)
				(void)signal(SIGINT, oldintr);
			if (oldinti)
				(void)signal(SIGINFO, oldinti);
			goto cleanup_url_get;
		}
		oldintr = signal(SIGINT, abortfile);

		bytes = 0;
		hashbytes = mark;
		progressmeter(-1, path);

		if ((buf = malloc(buflen)) == NULL)
			errx(1, "Can't allocate memory for transfer buffer");

		/* Finally, suck down the file. */
		i = 0;
		oldinti = signal(SIGINFO, psummary);
		while ((len = read(s, buf, buflen)) > 0) {
			bytes += len;
			for (cp = buf; len > 0; len -= i, cp += i) {
				if ((i = write(out, cp, len)) == -1) {
					warn("Writing %s", savefile);
					signal(SIGINFO, oldinti);
					goto cleanup_url_get;
				}
				else if (i == 0)
					break;
			}
			if (hash && !progress) {
				while (bytes >= hashbytes) {
					(void)putc('#', ttyout);
					hashbytes += mark;
				}
				(void)fflush(ttyout);
			}
		}
		signal(SIGINFO, oldinti);
		if (hash && !progress && bytes > 0) {
			if (bytes < mark)
				(void)putc('#', ttyout);
			(void)putc('\n', ttyout);
			(void)fflush(ttyout);
		}
		if (len != 0) {
			warn("Reading from file");
			goto cleanup_url_get;
		}
		progressmeter(1, NULL);
		if (verbose)
			ptransfer(0);
		(void)signal(SIGINT, oldintr);

		rval = 0;
		goto cleanup_url_get;
	}

	if (*host == '[' && (hosttail = strrchr(host, ']')) != NULL &&
	    (hosttail[1] == '\0' || hosttail[1] == ':')) {
		host++;
		*hosttail++ = '\0';
#ifndef SMALL
		if (asprintf(&full_host, "[%s]", host) == -1)
			errx(1, "Cannot allocate memory for hostname");
#endif /* !SMALL */
	} else
		hosttail = host;

	portnum = strrchr(hosttail, ':');		/* find portnum */
	if (portnum != NULL)
		*portnum++ = '\0';
#ifndef NOSSL
	port = portnum ? portnum : (ishttpsurl ? httpsport : httpport);
#else /* !NOSSL */
	port = portnum ? portnum : httpport;
#endif /* !NOSSL */

#ifndef SMALL
	if (full_host == NULL)
		if ((full_host = strdup(host)) == NULL)
			errx(1, "Cannot allocate memory for hostname");
	if (debug)
		fprintf(ttyout, "host %s, port %s, path %s, "
		    "save as %s, auth %s.\n", host, port, path,
		    savefile, credentials ? credentials : "none");
#endif /* !SMALL */

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = family;
	hints.ai_socktype = SOCK_STREAM;
	error = getaddrinfo(host, port, &hints, &res0);
	/*
	 * If the services file is corrupt/missing, fall back
	 * on our hard-coded defines.
	 */
	if (error == EAI_SERVICE && port == httpport) {
		snprintf(pbuf, sizeof(pbuf), "%d", HTTP_PORT);
		error = getaddrinfo(host, pbuf, &hints, &res0);
#ifndef NOSSL
	} else if (error == EAI_SERVICE && port == httpsport) {
		snprintf(pbuf, sizeof(pbuf), "%d", HTTPS_PORT);
		error = getaddrinfo(host, pbuf, &hints, &res0);
#endif /* !NOSSL */
	}
	if (error) {
		warnx("%s: %s", host, gai_strerror(error));
		goto cleanup_url_get;
	}

#ifndef SMALL
	if (srcaddr) {
		hints.ai_flags |= AI_NUMERICHOST;
		error = getaddrinfo(srcaddr, NULL, &hints, &ares);
		if (error) {
			warnx("%s: %s", srcaddr, gai_strerror(error));
			goto cleanup_url_get;
		}
	}
#endif /* !SMALL */

	/* ensure consistent order of the output */
	if (verbose)
		setvbuf(ttyout, NULL, _IOLBF, 0);

	s = -1;
	for (res = res0; res; res = res->ai_next) {
		if (getnameinfo(res->ai_addr, res->ai_addrlen, hbuf,
		    sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)
			strlcpy(hbuf, "(unknown)", sizeof(hbuf));
		if (verbose)
			fprintf(ttyout, "Trying %s...\n", hbuf);

		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
		if (s == -1) {
			cause = "socket";
			continue;
		}

#ifndef SMALL
		if (srcaddr) {
			if (ares->ai_family != res->ai_family) {
				close(s);
				s = -1;
				errno = EINVAL;
				cause = "bind";
				continue;
			}
			if (bind(s, ares->ai_addr, ares->ai_addrlen) < 0) {
				save_errno = errno;
				close(s);
				errno = save_errno;
				s = -1;
				cause = "bind";
				continue;
			}
		}
#endif /* !SMALL */

		if (connect_timeout) {
			(void)signal(SIGALRM, tooslow);
			alarmtimer(connect_timeout);
		}

		for (error = connect(s, res->ai_addr, res->ai_addrlen);
		    error != 0 && errno == EINTR; error = connect_wait(s))
			continue;
		if (error != 0) {
			save_errno = errno;
			close(s);
			errno = save_errno;
			s = -1;
			cause = "connect";
			continue;
		}

		/* get port in numeric */
		if (getnameinfo(res->ai_addr, res->ai_addrlen, NULL, 0,
		    pbuf, sizeof(pbuf), NI_NUMERICSERV) == 0)
			port = pbuf;
		else
			port = NULL;

#ifndef NOSSL
		if (proxyenv && sslhost)
			proxy_connect(s, sslhost, credentials);
#endif /* !NOSSL */
		break;
	}
	freeaddrinfo(res0);
#ifndef SMALL
	if (srcaddr)
		freeaddrinfo(ares);
#endif /* !SMALL */
	if (s < 0) {
		warn("%s", cause);
		goto cleanup_url_get;
	}

#ifndef NOSSL
	if (ishttpsurl) {
		if (proxyenv && sslpath) {
			ishttpsurl = 0;
			proxyurl = NULL;
			path = sslpath;
		}
		if (sslhost == NULL) {
			sslhost = strdup(host);
			if (sslhost == NULL)
				errx(1, "Can't allocate memory for https host.");
		}
		if ((tls = tls_client()) == NULL) {
			fprintf(ttyout, "failed to create SSL client\n");
			goto cleanup_url_get;
		}
		if (tls_configure(tls, tls_config) != 0) {
			fprintf(ttyout, "SSL configuration failure: %s\n",
			    tls_error(tls));
			goto cleanup_url_get;
		}
		if (tls_connect_socket(tls, s, sslhost) != 0) {
			fprintf(ttyout, "SSL failure: %s\n", tls_error(tls));
			goto cleanup_url_get;
		}
	} else {
		fin = fdopen(s, "r+");
	}
#else /* !NOSSL */
	fin = fdopen(s, "r+");
#endif /* !NOSSL */

#ifdef SMALL
	if (lastfile) {
		if (pipeout) {
			if (pledge("stdio rpath inet dns tty",  NULL) == -1)
				err(1, "pledge");
		} else {
			if (pledge("stdio rpath wpath cpath inet dns tty", NULL) == -1)
				err(1, "pledge");
		}
	}
#endif

	if (connect_timeout) {
		signal(SIGALRM, SIG_DFL);
		alarmtimer(0);
	}

	/*
	 * Construct and send the request. Proxy requests don't want leading /.
	 */
#ifndef NOSSL
	cookie_get(host, path, ishttpsurl, &buf);
#endif /* !NOSSL */

	epath = url_encode(path);
	if (proxyurl) {
		if (verbose) {
			fprintf(ttyout, "Requesting %s (via %s)\n",
			    origline, proxyurl);
		}
		/*
		 * Host: directive must use the destination host address for
		 * the original URI (path).
		 */
		if (credentials)
			ftp_printf(fin, tls, "GET %s HTTP/1.0\r\n"
			    "Proxy-Authorization: Basic %s\r\n"
			    "Host: %s\r\n%s%s\r\n\r\n",
			    epath, credentials,
			    proxyhost, buf ? buf : "", httpuseragent);
		else
			ftp_printf(fin, tls, "GET %s HTTP/1.0\r\n"
			    "Host: %s\r\n%s%s\r\n\r\n",
			    epath, proxyhost, buf ? buf : "", httpuseragent);
	} else {
		if (verbose)
			fprintf(ttyout, "Requesting %s\n", origline);
#ifndef SMALL
		if (resume) {
			struct stat stbuf;

			if (stat(savefile, &stbuf) == 0)
				restart_point = stbuf.st_size;
			else
				restart_point = 0;
		}
#endif	/* SMALL */
#ifndef NOSSL
		if (credentials) {
			ftp_printf(fin, tls,
			    "GET /%s %s\r\nAuthorization: Basic %s\r\nHost: ",
			    epath, restart_point ?
			    "HTTP/1.1\r\nConnection: close" : "HTTP/1.0",
			    credentials);
			free(credentials);
			credentials = NULL;
		} else
#endif	/* NOSSL */
			ftp_printf(fin, tls, "GET /%s %s\r\nHost: ", epath,
#ifndef SMALL
			    restart_point ? "HTTP/1.1\r\nConnection: close" :
#endif /* !SMALL */
			    "HTTP/1.0");
		if (proxyhost) {
			ftp_printf(fin, tls, "%s", proxyhost);
			port = NULL;
		} else if (strchr(host, ':')) {
			/*
			 * strip off scoped address portion, since it's
			 * local to node
			 */
			h = strdup(host);
			if (h == NULL)
				errx(1, "Can't allocate memory.");
			if ((p = strchr(h, '%')) != NULL)
				*p = '\0';
			ftp_printf(fin, tls, "[%s]", h);
			free(h);
		} else
			ftp_printf(fin, tls, "%s", host);

		/*
		 * Send port number only if it's specified and does not equal
		 * 80. Some broken HTTP servers get confused if you explicitly
		 * send them the port number.
		 */
#ifndef NOSSL
		if (port && strcmp(port, (ishttpsurl ? "443" : "80")) != 0)
			ftp_printf(fin, tls, ":%s", port);
		if (restart_point)
			ftp_printf(fin, tls, "\r\nRange: bytes=%lld-",
				(long long)restart_point);
#else /* !NOSSL */
		if (port && strcmp(port, "80") != 0)
			ftp_printf(fin, tls, ":%s", port);
#endif /* !NOSSL */
		ftp_printf(fin, tls, "\r\n%s%s\r\n\r\n",
		    buf ? buf : "", httpuseragent);
	}
	free(epath);

#ifndef NOSSL
	free(buf);
#endif /* !NOSSL */
	buf = NULL;

	if (fin != NULL && fflush(fin) == EOF) {
		warn("Writing HTTP request");
		goto cleanup_url_get;
	}
	if ((buf = ftp_readline(fin, tls, &len)) == NULL) {
		warn("Receiving HTTP reply");
		goto cleanup_url_get;
	}

	while (len > 0 && (buf[len-1] == '\r' || buf[len-1] == '\n'))
		buf[--len] = '\0';
#ifndef SMALL
	if (debug)
		fprintf(ttyout, "received '%s'\n", buf);
#endif /* !SMALL */

	cp = strchr(buf, ' ');
	if (cp == NULL)
		goto improper;
	else
		cp++;

	strlcpy(ststr, cp, sizeof(ststr));
	status = strtonum(ststr, 200, 416, &errstr);
	if (errstr) {
		warnx("Error retrieving file: %s", cp);
		goto cleanup_url_get;
	}

	switch (status) {
	case 200:	/* OK */
#ifndef SMALL
		/*
		 * When we request a partial file, and we receive an HTTP 200
		 * it is a good indication that the server doesn't support
		 * range requests, and is about to send us the entire file.
		 * If the restart_point == 0, then we are not actually
		 * requesting a partial file, and an HTTP 200 is appropriate.
		 */
		if (resume && restart_point != 0) {
			warnx("Server does not support resume.");
			restart_point = resume = 0;
		}
		/* FALLTHROUGH */
	case 206:	/* Partial Content */
#endif /* !SMALL */
		break;
	case 301:	/* Moved Permanently */
	case 302:	/* Found */
	case 303:	/* See Other */
	case 307:	/* Temporary Redirect */
		isredirect++;
		if (redirect_loop++ > 10) {
			warnx("Too many redirections requested");
			goto cleanup_url_get;
		}
		break;
#ifndef SMALL
	case 416:	/* Requested Range Not Satisfiable */
		warnx("File is already fully retrieved.");
		goto cleanup_url_get;
#endif /* !SMALL */
	default:
		warnx("Error retrieving file: %s", cp);
		goto cleanup_url_get;
	}

	/*
	 * Read the rest of the header.
	 */
	free(buf);
	filesize = -1;

	for (;;) {
		if ((buf = ftp_readline(fin, tls, &len)) == NULL) {
			warn("Receiving HTTP reply");
			goto cleanup_url_get;
		}

		while (len > 0 && (buf[len-1] == '\r' || buf[len-1] == '\n'))
			buf[--len] = '\0';
		if (len == 0)
			break;
#ifndef SMALL
		if (debug)
			fprintf(ttyout, "received '%s'\n", buf);
#endif /* !SMALL */

		/* Look for some headers */
		cp = buf;
#define CONTENTLEN "Content-Length: "
		if (strncasecmp(cp, CONTENTLEN, sizeof(CONTENTLEN) - 1) == 0) {
			size_t s;
			cp += sizeof(CONTENTLEN) - 1;
			if ((s = strcspn(cp, " \t")))
				*(cp+s) = 0;
			filesize = strtonum(cp, 0, LLONG_MAX, &errstr);
			if (errstr != NULL)
				goto improper;
#ifndef SMALL
			if (restart_point)
				filesize += restart_point;
#endif /* !SMALL */
#define LOCATION "Location: "
		} else if (isredirect &&
		    strncasecmp(cp, LOCATION, sizeof(LOCATION) - 1) == 0) {
			cp += sizeof(LOCATION) - 1;
			/*
			 * If there is a colon before the first slash, this URI
			 * is not relative. RFC 3986 4.2
			 */
			if (cp[strcspn(cp, ":/")] != ':') {
#ifdef SMALL
				errx(1, "Relative redirect not supported");
#else /* SMALL */
				/* XXX doesn't handle protocol-relative URIs */
				if (*cp == '/') {
					locbase = NULL;
					cp++;
				} else {
					locbase = strdup(path);
					if (locbase == NULL)
						errx(1, "Can't allocate memory"
						    " for location base");
					loctail = strchr(locbase, '#');
					if (loctail != NULL)
						*loctail = '\0';
					loctail = strchr(locbase, '?');
					if (loctail != NULL)
						*loctail = '\0';
					loctail = strrchr(locbase, '/');
					if (loctail == NULL) {
						free(locbase);
						locbase = NULL;
					} else
						loctail[1] = '\0';
				}
				/* Contruct URL from relative redirect */
				if (asprintf(&redirurl, "%s%s%s%s/%s%s",
				    scheme, full_host,
				    portnum ? ":" : "",
				    portnum ? portnum : "",
				    locbase ? locbase : "",
				    cp) == -1)
					errx(1, "Cannot build "
					    "redirect URL");
				free(locbase);
#endif /* SMALL */
			} else if ((redirurl = strdup(cp)) == NULL)
				errx(1, "Cannot allocate memory for URL");
			loctail = strchr(redirurl, '#');
			if (loctail != NULL)
				*loctail = '\0';
			if (verbose)
				fprintf(ttyout, "Redirected to %s\n", redirurl);
			if (fin != NULL)
				fclose(fin);
			else if (s != -1)
				close(s);
			rval = url_get(redirurl, proxyenv, savefile, lastfile);
			free(redirurl);
			goto cleanup_url_get;
		}
		free(buf);
	}

	/* Open the output file.  */
	if (!pipeout) {
#ifndef SMALL
		if (resume)
			out = open(savefile, O_CREAT | O_WRONLY | O_APPEND,
				0666);
		else
#endif /* !SMALL */
			out = open(savefile, O_CREAT | O_WRONLY | O_TRUNC,
				0666);
		if (out < 0) {
			warn("Can't open %s", savefile);
			goto cleanup_url_get;
		}
	} else {
		out = fileno(stdout);
#ifdef SMALL
		if (lastfile) {
			if (pledge("stdio tty", NULL) == -1)
				err(1, "pledge");
		}
#endif
	}

	/* Trap signals */
	oldintr = NULL;
	oldinti = NULL;
	if (setjmp(httpabort)) {
		if (oldintr)
			(void)signal(SIGINT, oldintr);
		if (oldinti)
			(void)signal(SIGINFO, oldinti);
		goto cleanup_url_get;
	}
	oldintr = signal(SIGINT, aborthttp);

	bytes = 0;
	hashbytes = mark;
	progressmeter(-1, path);

	free(buf);

	/* Finally, suck down the file. */
	if ((buf = malloc(buflen)) == NULL)
		errx(1, "Can't allocate memory for transfer buffer");
	i = 0;
	len = 1;
	oldinti = signal(SIGINFO, psummary);
	while (len > 0) {
		len = ftp_read(fin, tls, buf, buflen);
		bytes += len;
		for (cp = buf, wlen = len; wlen > 0; wlen -= i, cp += i) {
			if ((i = write(out, cp, wlen)) == -1) {
				warn("Writing %s", savefile);
				signal(SIGINFO, oldinti);
				goto cleanup_url_get;
			}
			else if (i == 0)
				break;
		}
		if (hash && !progress) {
			while (bytes >= hashbytes) {
				(void)putc('#', ttyout);
				hashbytes += mark;
			}
			(void)fflush(ttyout);
		}
	}
	signal(SIGINFO, oldinti);
	if (hash && !progress && bytes > 0) {
		if (bytes < mark)
			(void)putc('#', ttyout);
		(void)putc('\n', ttyout);
		(void)fflush(ttyout);
	}
	if (len != 0) {
		warn("Reading from socket");
		goto cleanup_url_get;
	}
	progressmeter(1, NULL);
	if (
#ifndef SMALL
		!resume &&
#endif /* !SMALL */
		filesize != -1 && len == 0 && bytes != filesize) {
		if (verbose)
			fputs("Read short file.\n", ttyout);
		goto cleanup_url_get;
	}

	if (verbose)
		ptransfer(0);
	(void)signal(SIGINT, oldintr);

	rval = 0;
	goto cleanup_url_get;

noftpautologin:
	warnx(
	    "Auto-login using ftp URLs isn't supported when using $ftp_proxy");
	goto cleanup_url_get;

improper:
	warnx("Improper response from %s", host);

cleanup_url_get:
#ifndef NOSSL
	if (tls != NULL) {
		do {
			i = tls_close(tls);
		} while (i == TLS_WANT_POLLIN || i == TLS_WANT_POLLOUT);
		tls_free(tls);
	}
	free(full_host);
	free(sslhost);
#endif /* !NOSSL */
	if (fin != NULL)
		fclose(fin);
	else if (s != -1)
		close(s);
	if (out >= 0 && out != fileno(stdout))
		close(out);
	free(buf);
	free(proxyhost);
	free(proxyurl);
	free(newline);
	free(credentials);
	return (rval);
}

/*
 * Abort a http retrieval
 */
/* ARGSUSED */
void
aborthttp(int signo)
{

	alarmtimer(0);
	fputs("\nhttp fetch aborted.\n", ttyout);
	(void)fflush(ttyout);
	longjmp(httpabort, 1);
}

/*
 * Abort a http retrieval
 */
/* ARGSUSED */
void
abortfile(int signo)
{

	alarmtimer(0);
	fputs("\nfile fetch aborted.\n", ttyout);
	(void)fflush(ttyout);
	longjmp(httpabort, 1);
}

/*
 * Retrieve multiple files from the command line, transferring
 * files of the form "host:path", "ftp://host/path" using the
 * ftp protocol, and files of the form "http://host/path" using
 * the http protocol.
 * If path has a trailing "/", then return (-1);
 * the path will be cd-ed into and the connection remains open,
 * and the function will return -1 (to indicate the connection
 * is alive).
 * If an error occurs the return value will be the offset+1 in
 * argv[] of the file that caused a problem (i.e, argv[x]
 * returns x+1)
 * Otherwise, 0 is returned if all files retrieved successfully.
 */
int
auto_fetch(int argc, char *argv[], char *outfile)
{
	char *xargv[5];
	char *cp, *url, *host, *dir, *file, *portnum;
	char *username, *pass, *pathstart;
	char *ftpproxy, *httpproxy;
	int rval, xargc, lastfile;
	volatile int argpos;
	int dirhasglob, filehasglob, oautologin;
	char rempath[PATH_MAX];

	argpos = 0;

	if (setjmp(toplevel)) {
		if (connected)
			disconnect(0, NULL);
		return (argpos + 1);
	}
	(void)signal(SIGINT, (sig_t)intr);
	(void)signal(SIGPIPE, (sig_t)lostpeer);

	if ((ftpproxy = getenv(FTP_PROXY)) != NULL && *ftpproxy == '\0')
		ftpproxy = NULL;
	if ((httpproxy = getenv(HTTP_PROXY)) != NULL && *httpproxy == '\0')
		httpproxy = NULL;

	/*
	 * Loop through as long as there's files to fetch.
	 */
	username = pass = NULL;
	for (rval = 0; (rval == 0) && (argpos < argc); free(url), argpos++) {
		if (strchr(argv[argpos], ':') == NULL)
			break;

		free(username);
		free(pass);
		host = dir = file = portnum = username = pass = NULL;

		lastfile = (argv[argpos+1] == NULL);

		/*
		 * We muck with the string, so we make a copy.
		 */
		url = strdup(argv[argpos]);
		if (url == NULL)
			errx(1, "Can't allocate memory for auto-fetch.");

		/*
		 * Try HTTP URL-style arguments first.
		 */
		if (strncasecmp(url, HTTP_URL, sizeof(HTTP_URL) - 1) == 0 ||
#ifndef NOSSL
		    /* even if we compiled without SSL, url_get will check */
		    strncasecmp(url, HTTPS_URL, sizeof(HTTPS_URL) -1) == 0 ||
#endif /* !NOSSL */
		    strncasecmp(url, FILE_URL, sizeof(FILE_URL) - 1) == 0) {
			redirect_loop = 0;
			if (url_get(url, httpproxy, outfile, lastfile) == -1)
				rval = argpos + 1;
			continue;
		}

		/*
		 * Try FTP URL-style arguments next. If ftpproxy is
		 * set, use url_get() instead of standard ftp.
		 * Finally, try host:file.
		 */
		host = url;
		if (strncasecmp(url, FTP_URL, sizeof(FTP_URL) - 1) == 0) {
			char *passend, *passagain, *userend;

			if (ftpproxy) {
				if (url_get(url, ftpproxy, outfile, lastfile) == -1)
					rval = argpos + 1;
				continue;
			}
			host += sizeof(FTP_URL) - 1;
			dir = strchr(host, '/');

			/* Look for [user:pass@@]host[:port] */

			/* check if we have "user:pass@@" */
			userend = strchr(host, ':');
			passend = strchr(host, '@@');
			if (passend && userend && userend < passend &&
			    (!dir || passend < dir)) {
				username = host;
				pass = userend + 1;
				host = passend + 1;
				*userend = *passend = '\0';
				passagain = strchr(host, '@@');
				if (strchr(pass, '@@') != NULL ||
				    (passagain != NULL && passagain < dir)) {
					warnx(at_encoding_warning);
					username = pass = NULL;
					goto bad_ftp_url;
				}

				if (EMPTYSTRING(username)) {
bad_ftp_url:
					warnx("Invalid URL: %s", argv[argpos]);
					rval = argpos + 1;
					username = pass = NULL;
					continue;
				}
				username = urldecode(username);
				pass = urldecode(pass);
			}

			/* check [host]:port, or [host] */
			if (host[0] == '[') {
				cp = strchr(host, ']');
				if (cp && (!dir || cp < dir)) {
					if (cp + 1 == dir || cp[1] == ':') {
						host++;
						*cp++ = '\0';
					} else
						cp = NULL;
				} else
					cp = host;
			} else
				cp = host;

			/* split off host[:port] if there is */
			if (cp) {
				portnum = strchr(cp, ':');
				pathstart = strchr(cp, '/');
				/* : in path is not a port # indicator */
				if (portnum && pathstart &&
				    pathstart < portnum)
					portnum = NULL;

				if (!portnum)
					;
				else {
					if (!dir)
						;
					else if (portnum + 1 < dir) {
						*portnum++ = '\0';
						/*
						 * XXX should check if portnum
						 * is decimal number
						 */
					} else {
						/* empty portnum */
						goto bad_ftp_url;
					}
				}
			} else
				portnum = NULL;
		} else {			/* classic style `host:file' */
			dir = strchr(host, ':');
		}
		if (EMPTYSTRING(host)) {
			rval = argpos + 1;
			continue;
		}

		/*
		 * If dir is NULL, the file wasn't specified
		 * (URL looked something like ftp://host)
		 */
		if (dir != NULL)
			*dir++ = '\0';

		/*
		 * Extract the file and (if present) directory name.
		 */
		if (!EMPTYSTRING(dir)) {
			cp = strrchr(dir, '/');
			if (cp != NULL) {
				*cp++ = '\0';
				file = cp;
			} else {
				file = dir;
				dir = NULL;
			}
		}
#ifndef SMALL
		if (debug)
			fprintf(ttyout,
			    "user %s:%s host %s port %s dir %s file %s\n",
			    username, pass ? "XXXX" : NULL, host, portnum,
			    dir, file);
#endif /* !SMALL */

		/*
		 * Set up the connection.
		 */
		if (connected)
			disconnect(0, NULL);
		xargv[0] = __progname;
		xargv[1] = host;
		xargv[2] = NULL;
		xargc = 2;
		if (!EMPTYSTRING(portnum)) {
			xargv[2] = portnum;
			xargv[3] = NULL;
			xargc = 3;
		}
		oautologin = autologin;
		if (username == NULL)
			anonftp = 1;
		else {
			anonftp = 0;
			autologin = 0;
		}
		setpeer(xargc, xargv);
		autologin = oautologin;
		if (connected == 0 ||
		    (connected == 1 && autologin && (username == NULL ||
		    !ftp_login(host, username, pass)))) {
			warnx("Can't connect or login to host `%s'", host);
			rval = argpos + 1;
			continue;
		}

		/* Always use binary transfers. */
		setbinary(0, NULL);

		dirhasglob = filehasglob = 0;
		if (doglob) {
			if (!EMPTYSTRING(dir) &&
			    strpbrk(dir, "*?[]{}") != NULL)
				dirhasglob = 1;
			if (!EMPTYSTRING(file) &&
			    strpbrk(file, "*?[]{}") != NULL)
				filehasglob = 1;
		}

		/* Change directories, if necessary. */
		if (!EMPTYSTRING(dir) && !dirhasglob) {
			xargv[0] = "cd";
			xargv[1] = dir;
			xargv[2] = NULL;
			cd(2, xargv);
			if (!dirchange) {
				rval = argpos + 1;
				continue;
			}
		}

		if (EMPTYSTRING(file)) {
#ifndef SMALL
			rval = -1;
#else /* !SMALL */
			recvrequest("NLST", "-", NULL, "w", 0, 0);
			rval = 0;
#endif /* !SMALL */
			continue;
		}

		if (verbose)
			fprintf(ttyout, "Retrieving %s/%s\n", dir ? dir : "", file);

		if (dirhasglob) {
			snprintf(rempath, sizeof(rempath), "%s/%s", dir, file);
			file = rempath;
		}

		/* Fetch the file(s). */
		xargc = 2;
		xargv[0] = "get";
		xargv[1] = file;
		xargv[2] = NULL;
		if (dirhasglob || filehasglob) {
			int ointeractive;

			ointeractive = interactive;
			interactive = 0;
			xargv[0] = "mget";
#ifndef SMALL
			if (resume) {
				xargc = 3;
				xargv[1] = "-c";
				xargv[2] = file;
				xargv[3] = NULL;
			}
#endif /* !SMALL */
			mget(xargc, xargv);
			interactive = ointeractive;
		} else {
			if (outfile != NULL) {
				xargv[2] = outfile;
				xargv[3] = NULL;
				xargc++;
			}
#ifndef SMALL
			if (resume)
				reget(xargc, xargv);
			else
#endif /* !SMALL */
				get(xargc, xargv);
		}

		if ((code / 100) != COMPLETE)
			rval = argpos + 1;
	}
	if (connected && rval != -1)
		disconnect(0, NULL);
	return (rval);
}

char *
urldecode(const char *str)
{
	char *ret, c;
	int i, reallen;

	if (str == NULL)
		return NULL;
	if ((ret = malloc(strlen(str)+1)) == NULL)
		err(1, "Can't allocate memory for URL decoding");
	for (i = 0, reallen = 0; str[i] != '\0'; i++, reallen++, ret++) {
		c = str[i];
		if (c == '+') {
			*ret = ' ';
			continue;
		}

		/* Cannot use strtol here because next char
		 * after %xx may be a digit.
		 */
		if (c == '%' && isxdigit((unsigned char)str[i+1]) &&
		    isxdigit((unsigned char)str[i+2])) {
			*ret = hextochar(&str[i+1]);
			i+=2;
			continue;
		}
		*ret = c;
	}
	*ret = '\0';

	return ret-reallen;
}

char *
recode_credentials(const char *userinfo)
{
	char *ui, *creds;
	size_t ulen, credsize;

	/* url-decode the user and pass */
	ui = urldecode(userinfo);

	ulen = strlen(ui);
	credsize = (ulen + 2) / 3 * 4 + 1;
	creds = malloc(credsize);
	if (creds == NULL)
		errx(1, "out of memory");
	if (b64_ntop(ui, ulen, creds, credsize) == -1)
		errx(1, "error in base64 encoding");
	free(ui);
	return (creds);
}

char
hextochar(const char *str)
{
	unsigned char c, ret;

	c = str[0];
	ret = c;
	if (isalpha(c))
		ret -= isupper(c) ? 'A' - 10 : 'a' - 10;
	else
		ret -= '0';
	ret *= 16;

	c = str[1];
	ret += c;
	if (isalpha(c))
		ret -= isupper(c) ? 'A' - 10 : 'a' - 10;
	else
		ret -= '0';
	return ret;
}

int
isurl(const char *p)
{

	if (strncasecmp(p, FTP_URL, sizeof(FTP_URL) - 1) == 0 ||
	    strncasecmp(p, HTTP_URL, sizeof(HTTP_URL) - 1) == 0 ||
#ifndef NOSSL
	    strncasecmp(p, HTTPS_URL, sizeof(HTTPS_URL) - 1) == 0 ||
#endif /* !NOSSL */
	    strncasecmp(p, FILE_URL, sizeof(FILE_URL) - 1) == 0 ||
	    strstr(p, ":/"))
		return (1);
	return (0);
}

char *
ftp_readline(FILE *fp, struct tls *tls, size_t *lenp)
{
	if (fp != NULL)
		return fparseln(fp, lenp, NULL, "\0\0\0", 0);
#ifndef NOSSL
	else if (tls != NULL)
		return SSL_readline(tls, lenp);
#endif /* !NOSSL */
	else
		return NULL;
}

size_t
ftp_read(FILE *fp, struct tls *tls, char *buf, size_t len)
{
#ifndef NOSSL
	ssize_t tret;
#endif
	size_t ret = 0;

	if (fp != NULL)
		ret = fread(buf, sizeof(char), len, fp);
#ifndef NOSSL
	else if (tls != NULL) {
		do {
			tret = tls_read(tls, buf, len);
		} while (tret == TLS_WANT_POLLIN || tret == TLS_WANT_POLLOUT);
		if (tret < 0)
			errx(1, "SSL read error: %s", tls_error(tls));
		ret = (size_t)tret;
	}
#endif /* !NOSSL */
	return (ret);
}

int
ftp_printf(FILE *fp, struct tls *tls, const char *fmt, ...)
{
	int ret;
	va_list ap;

	va_start(ap, fmt);

	if (fp != NULL)
		ret = vfprintf(fp, fmt, ap);
#ifndef NOSSL
	else if (tls != NULL)
		ret = SSL_vprintf(tls, fmt, ap);
#endif /* !NOSSL */
	else
		ret = 0;

	va_end(ap);
#ifndef SMALL
	if (debug) {
		va_start(ap, fmt);
		ret = vfprintf(ttyout, fmt, ap);
		va_end(ap);
	}
#endif /* !SMALL */
	return (ret);
}

#ifndef NOSSL
int
SSL_vprintf(struct tls *tls, const char *fmt, va_list ap)
{
	char *string, *buf;
	size_t len;
	int ret;

	if ((ret = vasprintf(&string, fmt, ap)) == -1)
		return ret;
	buf = string;
	len = ret;
	while (len > 0) {
		ret = tls_write(tls, buf, len);
		if (ret == TLS_WANT_POLLIN || ret == TLS_WANT_POLLOUT)
			continue;
		if (ret < 0)
			errx(1, "SSL write error: %s", tls_error(tls));
		buf += ret;
		len -= ret;
	}
	free(string);
	return ret;
}

char *
SSL_readline(struct tls *tls, size_t *lenp)
{
	size_t i, len;
	char *buf, *q, c;
	int ret;

	len = 128;
	if ((buf = malloc(len)) == NULL)
		errx(1, "Can't allocate memory for transfer buffer");
	for (i = 0; ; i++) {
		if (i >= len - 1) {
			if ((q = reallocarray(buf, len, 2)) == NULL)
				errx(1, "Can't expand transfer buffer");
			buf = q;
			len *= 2;
		}
		do {
			ret = tls_read(tls, &c, 1);
		} while (ret == TLS_WANT_POLLIN || ret == TLS_WANT_POLLOUT);
		if (ret < 0)
			errx(1, "SSL read error: %s", tls_error(tls));

		buf[i] = c;
		if (c == '\n') {
			buf[i] = '\0';
			break;
		}
	}
	*lenp = i;
	return (buf);
}

int
proxy_connect(int socket, char *host, char *cookie)
{
	int l;
	char buf[1024];
	char *connstr, *hosttail, *port;

	if (*host == '[' && (hosttail = strrchr(host, ']')) != NULL &&
		(hosttail[1] == '\0' || hosttail[1] == ':')) {
		host++;
		*hosttail++ = '\0';
	} else
		hosttail = host;

	port = strrchr(hosttail, ':');               /* find portnum */
	if (port != NULL)
		*port++ = '\0';
	if (!port)
		port = "443";

	if (cookie) {
		l = asprintf(&connstr, "CONNECT %s:%s HTTP/1.1\r\n"
			"Proxy-Authorization: Basic %s\r\n%s\r\n\r\n",
			host, port, cookie, HTTP_USER_AGENT);
	} else {
		l = asprintf(&connstr, "CONNECT %s:%s HTTP/1.1\r\n%s\r\n\r\n",
			host, port, HTTP_USER_AGENT);
	}

	if (l == -1)
		errx(1, "Could not allocate memory to assemble connect string!");
#ifndef SMALL
	if (debug)
		printf("%s", connstr);
#endif /* !SMALL */
	if (write(socket, connstr, l) != l)
		err(1, "Could not send connect string");
	read(socket, &buf, sizeof(buf)); /* only proxy header XXX: error handling? */
	free(connstr);
	return(200);
}
#endif /* !NOSSL */
@


1.162
log
@close ftp(1)'s output file to avoid leaking one FD per request.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.161 2017/02/28 06:31:12 guenther Exp $	*/
d1034 3
a1036 1
		tls_close(tls);
@


1.161
log
@Use a do{}while loop with ssize_t return value when calling tls_read()

problem noted by and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.160 2017/01/21 08:33:07 krw Exp $	*/
d1044 2
@


1.160
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.159 2017/01/20 05:51:50 krw Exp $	*/
d1505 1
a1505 1
	ssize_t tls_ret;
d1513 4
a1516 6
 again:
		if ((tls_ret = tls_read(tls, buf, len)) >= 0)
			ret = (size_t)tls_ret;
		if (ret == TLS_WANT_POLLIN || ret == TLS_WANT_POLLOUT)
			goto again;
		if (ret < 0)
d1518 1
d1594 3
a1596 4
again:
		ret = tls_read(tls, &c, 1);
		if (ret == TLS_WANT_POLLIN || ret == TLS_WANT_POLLOUT)
			goto again;
@


1.159
log
@Move a couple of variables that are unused in SMALL under #ifndef SMALL.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.158 2017/01/14 18:03:11 jca Exp $	*/
d103 2
a104 2
 * 	- No corresponding graphic US-ASCII.
 * 	- Unsafe characters.
@


1.158
log
@HTTPS proxy support for ftp-ssl.

The install media already allow for plaintext HTTP proxying.  The code
to support CONNECT is short enough.  Reported/fix tested by rpe@@,  ok
deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.157 2017/01/10 17:43:12 deraadt Exp $	*/
d201 1
a201 1
	char *locbase, *full_host = NULL;
d204 3
d208 1
a208 1
#endif /* !NOSSL */
@


1.157
log
@Pledge more strictly.  This is only enabled on the ramdisk version of the
ftp(1) client, which operates only in URL mode.  Not willing to spend the
time tracking piles of global variables for sub-modes, and finding all
the pledge interactions.  Would rather have the install media ftp(1) as
safe as possible, immediately.
ok tb jca
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.156 2017/01/07 12:10:11 tb Exp $	*/
d79 1
a79 1
#ifndef SMALL
a80 2
#endif /* !SMALL */
#ifndef NOSSL
d83 1
a83 1
#endif /* !SMALL */
d593 1
a593 1
#ifndef SMALL
d596 1
a596 1
#endif /* !SMALL */
d1650 1
a1650 1
#endif /* !SMALL */
@


1.156
log
@-#endif /* !SMALL */
+#endif /* !NOSSL */
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.155 2017/01/03 17:00:04 deraadt Exp $	*/
d70 1
a70 1
static int	url_get(const char *, const char *, const char *);
d184 1
a184 1
url_get(const char *origline, const char *proxyenv, const char *outfile)
d643 12
d918 1
a918 1
			rval = url_get(redirurl, proxyenv, savefile);
d939 1
a939 1
	} else
d941 7
d1100 1
a1100 1
	int rval, xargc;
d1132 2
d1151 1
a1151 1
			if (url_get(url, httpproxy, outfile) == -1)
d1166 1
a1166 1
				if (url_get(url, ftpproxy, outfile) == -1)
@


1.155
log
@Add a "-w connect_timeout" option in support of URL-fetching.  This allows
slow / failing connects to be identified.  The install script needs this
functionaly.
ok jca rpe millert
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.154 2016/12/28 17:48:04 deraadt Exp $	*/
d744 1
a744 1
#endif /* !SMALL */
@


1.154
log
@Split -DSMALL into -DNOSSL, so that a SSL-enabled version of ftp can
be built, which is still pretty small (in distrib/special/ftp-ssl).
Lots of testing by rpe.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.153 2016/12/24 13:52:42 jsing Exp $	*/
d170 8
d571 5
d642 5
@


1.153
log
@Correctly handle tls_read()/tls_write().

In one tls_read() case, we failed to check for WANT_{POLLIN,POLLOUT}, so
fix that. In the same tls_read() case and the tls_write() case we fail to
handle errors correctly, which means that error is not reported and can be
lost by a futher libtls call.

ok beck@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.152 2016/12/16 17:44:59 krw Exp $	*/
d61 1
a61 1
#ifndef SMALL
d63 1
a63 1
#else /* !SMALL */
d65 1
a65 1
#endif /* !SMALL */
d81 2
d193 1
a193 1
#ifndef SMALL
d199 1
a199 1
#endif /* !SMALL */
d225 1
a225 1
#ifndef SMALL
d231 1
a231 1
#endif /* !SMALL */
d260 1
a260 1
#ifndef SMALL
d273 1
a273 1
#endif	/* SMALL */
d299 1
a299 1
#ifndef SMALL
d306 1
a306 1
#endif /* !SMALL */
d476 1
a476 1
#ifndef SMALL
d478 1
a478 1
#else /* !SMALL */
d480 1
a480 1
#endif /* !SMALL */
d503 1
a503 1
#ifndef SMALL
d507 1
a507 1
#endif /* !SMALL */
d598 1
a598 1
#ifndef SMALL
d626 1
a626 1
#else /* !SMALL */
d628 1
a628 1
#endif /* !SMALL */
d633 1
a633 1
#ifndef SMALL
d635 1
a635 1
#endif /* !SMALL */
d669 2
d680 1
a680 1
#endif	/* SMALL */
d709 1
a709 1
#ifndef SMALL
d715 1
a715 1
#else /* !SMALL */
d718 1
a718 1
#endif /* !SMALL */
d724 1
a724 1
#ifndef SMALL
d994 1
a994 1
#ifndef SMALL
d1001 1
a1001 1
#endif /* !SMALL */
d1106 1
a1106 1
#ifndef SMALL
d1109 1
a1109 1
#endif /* !SMALL */
d1439 1
a1439 1
#ifndef SMALL
d1441 1
a1441 1
#endif /* !SMALL */
d1453 1
a1453 1
#ifndef SMALL
d1456 1
a1456 1
#endif /* !SMALL */
d1464 1
a1464 1
#ifndef SMALL
d1471 1
a1471 1
#ifndef SMALL
d1481 1
a1481 1
#endif /* !SMALL */
d1495 1
a1495 1
#ifndef SMALL
d1498 1
a1498 1
#endif /* !SMALL */
d1513 1
a1513 1
#ifndef SMALL
@


1.152
log
@Eliminate some gcc warnings about 'unused variables', mostly by
adding appropriate #ifdef's around declarations.

ok millert@@ (with a tweak I will commit separately)
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.151 2016/12/08 19:59:51 millert Exp $	*/
d1469 1
d1472 4
d1526 1
a1526 1
			break;
@


1.151
log
@Avoid splitting the "Requesting %s" printf and its trailing newline.
Fixes a missing newline in one place and an extra one later on when
both debug and verbose are set.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.150 2016/12/08 19:31:17 millert Exp $	*/
d180 1
a180 1
	struct addrinfo hints, *res0, *res, *ares = NULL;
d196 1
d1460 1
d1462 1
@


1.150
log
@Avoid printf of a NULL pointer as a string in debug mode.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.149 2016/08/20 20:18:42 millert Exp $	*/
a626 3
	if (verbose)
		fprintf(ttyout, "Requesting %s", origline);

d636 4
a639 2
		if (verbose)
			fprintf(ttyout, " (via %s)\n", proxyurl);
d655 2
a715 2
		if (verbose)
			fprintf(ttyout, "\n");
@


1.149
log
@Use connect(2) + a connect_wait() function instead of connect_sync(),
similar to the example in connect(2).  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.148 2016/08/18 16:23:06 millert Exp $	*/
d473 5
d485 2
a486 2
		    "save as %s, auth %s.\n",
		    host, portnum, path, savefile, credentials);
a491 5
#ifndef SMALL
	port = portnum ? portnum : (ishttpsurl ? httpsport : httpport);
#else /* !SMALL */
	port = portnum ? portnum : httpport;
#endif /* !SMALL */
@


1.148
log
@Move connect_sync() to util.c and use it when connecting via http
too.  OK sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.147 2016/05/27 15:16:16 jsing Exp $	*/
d560 4
a563 2
again:
		if (connect_sync(s, res->ai_addr, res->ai_addrlen) < 0) {
@


1.147
log
@Per the libtls man page, tls_init() must be called prior to any other
tls_* function; so actually do that.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.146 2016/05/06 22:06:09 jca Exp $	*/
d561 1
a561 3
		if (connect(s, res->ai_addr, res->ai_addrlen) < 0) {
			if (errno == EINTR)
				goto again;
@


1.146
log
@Remove #ifdef INET6 bits, missed in a commit earlier this week

This probably broke passive FTP on IPv6 and [ip::v6]:port syntax in
RAMDISK ftp(1), sorry about that.

The diff was initially ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.145 2016/01/28 21:31:50 martijn Exp $	*/
a605 4
		}
		if (tls_init() != 0) {
			fprintf(ttyout, "SSL initialisation failed\n");
			goto cleanup_url_get;
@


1.145
log
@Fix a crash when a server sends a non-standard newline ("\n" instead of "\r\n").
Present since ssl support was initially added in OpenBSD 4.0

Found by sthen@@ via github downtime

OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.144 2016/01/08 20:36:01 sthen Exp $	*/
a1163 1
#ifdef INET6
a1176 3
#else
			cp = host;
#endif
@


1.144
log
@Handle redirects to _relative_ URIs containing '://', e.g. for archive.org.
From Lauri Tirkkonen, plus tweak to comment.  ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.143 2015/10/13 08:53:43 guenther Exp $	*/
d1560 2
a1561 1
		if (c == '\n')
d1563 1
@


1.143
log
@ctype functions isxdigit() expect an unsigned char value; add missing casts
and adjust variable types to get correct behavior

ok beck@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.142 2015/09/10 13:43:35 jsing Exp $	*/
d836 5
a840 1
			if (strstr(cp, "://") == NULL) {
d844 1
@


1.142
log
@Unbreak ftp(1) after tls_read()/tls_write() change.

Found the hard way by naddy@@

Joint work with beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.141 2015/09/10 10:35:58 beck Exp $	*/
d1377 2
a1378 1
		if (c == '%' && isxdigit(str[i+1]) && isxdigit(str[i+2])) {
d1413 1
a1413 1
	char c, ret;
@


1.141
log
@fix after libtls api changes
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.140 2015/09/09 19:23:03 jsing Exp $	*/
d1462 3
a1464 1
	size_t ret;
d1468 3
a1470 3
	else if (tls!= NULL) {
		if ((ret = tls_read(tls, buf, len)) != 0)
			ret = 0;
a1472 2
	else
		ret = 0;
d1550 1
a1550 1
		if (ret != 0)
@


1.140
log
@Make sure we check TLS_WRITE_AGAIN when calling tls_read() and if
tls_read() fails, print the tls_error() rather than just the return value.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.139 2015/07/18 21:50:47 bluhm Exp $	*/
d1467 1
a1467 3
		size_t nr;

		if ((ret = tls_read(tls, buf, len, &nr)) != 0)
a1468 2
		else
			ret = nr;
d1509 1
a1509 1
	size_t nw, len;
d1517 2
a1518 2
		ret = tls_write(tls, buf, len, &nw);
		if (ret == TLS_READ_AGAIN || ret == TLS_WRITE_AGAIN)
d1522 2
a1523 2
		buf += nw;
		len -= nw;
d1532 1
a1532 1
	size_t i, len, nr;
d1547 2
a1548 2
		ret = tls_read(tls, &c, 1, &nr);
		if (ret == TLS_READ_AGAIN || ret == TLS_WRITE_AGAIN)
@


1.139
log
@Handle short writes and TLS_{READ,WRITE}_AGAIN around tls_write().
input doug@@; OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.138 2015/02/27 17:38:19 jca Exp $	*/
d1552 1
a1552 1
		if (ret == TLS_READ_AGAIN)
d1555 1
a1555 1
			errx(1, "SSL read error: %u", ret);
@


1.139.4.1
log
@Backport fix for crash when non-standard newline is returned.

OK sthen@@ and beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.139 2015/07/18 21:50:47 bluhm Exp $	*/
d1558 1
a1558 2
		if (c == '\n') {
			buf[i] = '\0';
a1559 1
		}
@


1.138
log
@Fix URL-encoding of characters with the high order bit set.

Before/after:
127.0.0.1 - - [25/Feb/2015:09:39:24 +0100] "GET /h%ff%ffh%ff%ff.dat HTTP/1.0" 404 162 "-" "OpenBSD ftp"
127.0.0.1 - - [25/Feb/2015:09:39:27 +0100] "GET /h%c3%a9h%c3%a9.dat HTTP/1.0" 200 0 "-" "OpenBSD ftp"

Additionnally, avoid one case of undefined behaviour with ctype.h.

Input from guenther@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.137 2015/01/16 06:40:08 deraadt Exp $	*/
d1512 2
a1513 2
	char *string;
	size_t nw;
d1518 11
a1528 1
	ret = tls_write(tls, string, ret, &nw);
@


1.138.2.1
log
@Backport fix for crash when non-standard newline is returned.

OK sthen@@ and beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.138 2015/02/27 17:38:19 jca Exp $	*/
d1548 1
a1548 2
		if (c == '\n') {
			buf[i] = '\0';
a1549 1
		}
@


1.137
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.136 2015/01/12 15:46:55 bluhm Exp $	*/
d107 1
a107 1
unsafe_char(const char *c)
d110 1
d158 2
a159 1
			snprintf(epathp, 4, "%%" "%02x", path[i]);
@


1.136
log
@Fetching port distfiles with the ftp command from githup did not
work when using a https proxy because of a missing host header.
Remember the host form the url and write it into the http request.
Fix the format string when using Proxy-Authorization together with
Cookie.  Also write the http request to the debugging output to
see what is going on.
input jca@@; OK sthen@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.135 2014/11/25 08:22:09 deraadt Exp $	*/
a37 1
#include <sys/param.h>
a48 1
#include <limits.h>
d1059 1
a1059 1
	char rempath[MAXPATHLEN];
@


1.135
log
@set ttyout to line buffered, because the signal handler writes are
non-buffered. They were getting out of order.
from Kaspars Bankovskis, discussion included millert
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.134 2014/10/31 13:48:21 jsing Exp $	*/
d190 1
d304 3
d647 1
a647 1
		 * the original URI (path).  We do not attach it at this moment.
d651 4
a654 3
			    "Proxy-Authorization: Basic %s%s\r\n%s\r\n\r\n",
			    epath, credentials, buf ? buf : "",
			    httpuseragent);
d656 3
a658 3
			ftp_printf(fin, tls, "GET %s HTTP/1.0\r\n%s%s\r\n\r\n",
			    epath, buf ? buf : "", httpuseragent);

d684 4
a687 1
		if (strchr(host, ':')) {
d1002 1
d1498 7
@


1.134
log
@Update ftp(1) to use libtls instead of libressl.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.133 2014/10/30 15:50:50 tedu Exp $	*/
d517 4
@


1.133
log
@use ressl constant; from Jan Klemkow
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.132 2014/10/08 04:01:10 doug Exp $	*/
d64 1
a64 1
#include <ressl.h>
d66 1
a66 1
struct ressl;
d78 3
a80 3
int		ftp_printf(FILE *, struct ressl *, const char *, ...) __attribute__((format(printf, 3, 4)));
char		*ftp_readline(FILE *, struct ressl *, size_t *);
size_t		ftp_read(FILE *, struct ressl *, char *, size_t);
d83 2
a84 2
int		SSL_vprintf(struct ressl *, const char *, va_list);
char		*SSL_readline(struct ressl *, size_t *);
d196 1
a196 1
	struct ressl *ssl = NULL;
d599 1
a599 1
		if (ressl_init() != 0) {
d603 1
a603 1
		if ((ssl = ressl_client()) == NULL) {
d607 1
a607 1
		if (ressl_configure(ssl, ressl_config) != 0) {
d609 1
a609 1
			    ressl_error(ssl));
d612 2
a613 2
		if (ressl_connect_socket(ssl, s, sslhost) != 0) {
			fprintf(ttyout, "SSL failure: %s\n", ressl_error(ssl));
d642 1
a642 1
			ftp_printf(fin, ssl, "GET %s HTTP/1.0\r\n"
d647 1
a647 1
			ftp_printf(fin, ssl, "GET %s HTTP/1.0\r\n%s%s\r\n\r\n",
d661 1
a661 1
			ftp_printf(fin, ssl,
d670 1
a670 1
			ftp_printf(fin, ssl, "GET /%s %s\r\nHost: ", epath,
d685 1
a685 1
			ftp_printf(fin, ssl, "[%s]", h);
d688 1
a688 1
			ftp_printf(fin, ssl, "%s", host);
d697 1
a697 1
			ftp_printf(fin, ssl, ":%s", port);
d699 1
a699 1
			ftp_printf(fin, ssl, "\r\nRange: bytes=%lld-",
d703 1
a703 1
			ftp_printf(fin, ssl, ":%s", port);
d705 1
a705 1
		ftp_printf(fin, ssl, "\r\n%s%s\r\n\r\n",
d721 1
a721 1
	if ((buf = ftp_readline(fin, ssl, &len)) == NULL) {
d791 1
a791 1
		if ((buf = ftp_readline(fin, ssl, &len)) == NULL) {
d920 1
a920 1
		len = ftp_read(fin, ssl, buf, buflen);
d978 3
a980 3
	if (ssl != NULL) {
		ressl_close(ssl);
		ressl_free(ssl);
d1434 1
a1434 1
ftp_readline(FILE *fp, struct ressl *ssl, size_t *lenp)
d1439 2
a1440 2
	else if (ssl != NULL)
		return SSL_readline(ssl, lenp);
d1447 1
a1447 1
ftp_read(FILE *fp, struct ressl *ssl, char *buf, size_t len)
d1453 1
a1453 1
	else if (ssl != NULL) {
d1456 1
a1456 1
		if ((ret = ressl_read(ssl, buf, len, &nr)) != 0)
d1468 1
a1468 1
ftp_printf(FILE *fp, struct ressl *ssl, const char *fmt, ...)
d1478 2
a1479 2
	else if (ssl != NULL)
		ret = SSL_vprintf(ssl, fmt, ap);
d1490 1
a1490 1
SSL_vprintf(struct ressl *ssl, const char *fmt, va_list ap)
d1498 1
a1498 1
	ret = ressl_write(ssl, string, ret, &nw);
d1504 1
a1504 1
SSL_readline(struct ressl *ssl, size_t *lenp)
d1521 2
a1522 2
		ret = ressl_read(ssl, &c, 1, &nr);
		if (ret == RESSL_READ_AGAIN)
@


1.132
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the arguments with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.131 2014/10/06 11:47:25 jca Exp $	*/
d1522 1
a1522 1
		if (ret == -2)
@


1.131
log
@Amend previous commit to unbreak TLS cert validation when using a proxy.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.130 2014/10/04 15:48:24 miod Exp $	*/
d1515 1
a1515 1
			if ((q = realloc(buf, 2 * len)) == NULL)
@


1.130
log
@Be sure to only path the remote host to ressl_connect_socket(), without a
possible :portnumber suffix.
Noticed by ajacoutot@@

ok ajacoutot@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.129 2014/08/25 15:36:00 deraadt Exp $	*/
a345 6
#ifndef SMALL
	} else if (ishttpsurl) {
		sslhost = strdup(host);
		if (sslhost == NULL)
			errx(1, "Can't allocate memory for https path/host.");
#endif /* !SMALL */
d594 5
d612 1
a612 1
		if (ressl_connect_socket(ssl, s, host) != 0) {
@


1.129
log
@you broke the ramdisk builds...
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.128 2014/08/25 11:33:55 jca Exp $	*/
d613 1
a613 1
		if (ressl_connect_socket(ssl, s, sslhost) != 0) {
@


1.128
log
@When using a proxy for an https connection, validate the cert hostname
against the target hostname, not the proxy hostname.  Issue reported by
dlg@@, fix by Alex Wilson on tech@@, tweaks by me.
No reply from tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.127 2014/08/21 16:46:48 jca Exp $	*/
d346 1
d351 1
@


1.127
log
@Fix double free.  ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.126 2014/07/14 09:26:27 jsing Exp $	*/
d346 4
d611 1
a611 1
		if (ressl_connect_socket(ssl, s, host) != 0) {
d982 1
@


1.126
log
@Convert ftp(1) to libressl, rather than rolling in^W^Whand rolling libssl.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.125 2014/07/11 18:19:45 halex Exp $	*/
a977 1
	free(credentials);
@


1.125
log
@simplify and slightly tweak user agent handling

ok lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.124 2014/07/11 03:31:52 lteo Exp $	*/
d64 1
a64 3
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/x509v3.h>
d66 1
a66 1
#define SSL void
d78 3
a80 3
int		ftp_printf(FILE *, SSL *, const char *, ...) __attribute__((format(printf, 3, 4)));
char		*ftp_readline(FILE *, SSL *, size_t *);
size_t		ftp_read(FILE *, SSL *, char *, size_t);
d83 2
a84 7
int		SSL_vprintf(SSL *, const char *, va_list);
char		*SSL_readline(SSL *, size_t *);
int		ssl_match_hostname(char *, char *);
int		ssl_check_subject_altname(X509 *, char *);
int		ssl_check_common_name(X509 *, char *);
int		ssl_check_hostname(X509 *, char *);
SSL_CTX		*ssl_get_ssl_ctx(void);
a167 205
#ifndef SMALL
int
ssl_match_hostname(char *cert_hostname, char *hostname)
{
	if (strcasecmp(cert_hostname, hostname) == 0)
			return 0;

	/* wildcard match? */
	if (cert_hostname[0] == '*') {
		char	*cert_domain, *domain;

		cert_domain = &cert_hostname[1];
		if (cert_domain[0] != '.')
			return -1;
		if (strlen(cert_domain) == 1)
			return -1;

		domain = strchr(hostname, '.');
		/* no wildcard match against a hostname with no domain part */
		if (domain == NULL || strlen(domain) == 1)
			return -1;

		if (strcasecmp(cert_domain, domain) == 0)
			return 0;
	}

	return -1;
}

int
ssl_check_subject_altname(X509 *cert, char *host)
{
	STACK_OF(GENERAL_NAME)	*altname_stack = NULL;
	union { struct in_addr ip4; struct in6_addr ip6; } addrbuf;
	int	addrlen, type;
	int	count, i;
	int	rv = -1;

	altname_stack =
	    X509_get_ext_d2i(cert, NID_subject_alt_name, NULL, NULL);
	if (altname_stack == NULL)
		return -1;

	if (inet_pton(AF_INET, host, &addrbuf) == 1) {
		type = GEN_IPADD;
		addrlen = 4;
	} else if (inet_pton(AF_INET6, host, &addrbuf) == 1) {
		type = GEN_IPADD;
		addrlen = 16;
	} else
		type = GEN_DNS;

	count = sk_GENERAL_NAME_num(altname_stack);
	for (i = 0; i < count; i++) {
		GENERAL_NAME	*altname;

		altname = sk_GENERAL_NAME_value(altname_stack, i);

		if (altname->type != type)
			continue;

		if (type == GEN_DNS) {
			unsigned char	*data;
			int		 format;

			format = ASN1_STRING_type(altname->d.dNSName);
			if (format == V_ASN1_IA5STRING) {
				data = ASN1_STRING_data(altname->d.dNSName);

				if (ASN1_STRING_length(altname->d.dNSName) !=
				    (int)strlen(data)) {
					fprintf(ttyout, "%s: NUL byte in "
					    "subjectAltName, probably a "
					    "malicious certificate.\n",
					    getprogname());
					rv = -2;
					break;
				}

				if (ssl_match_hostname(data, host) == 0) {
					rv = 0;
					break;
				}
			} else
				fprintf(ttyout, "%s: unhandled subjectAltName "
				    "dNSName encoding (%d)\n", getprogname(),
				    format);

		} else if (type == GEN_IPADD) {
			unsigned char	*data;
			int		 datalen;

			datalen = ASN1_STRING_length(altname->d.iPAddress);
			data = ASN1_STRING_data(altname->d.iPAddress);

			if (datalen == addrlen &&
			    memcmp(data, &addrbuf, addrlen) == 0) {
				rv = 0;
				break;
			}
		}
	}

	sk_GENERAL_NAME_free(altname_stack);
	return rv;
}

int
ssl_check_common_name(X509 *cert, char *host)
{
	X509_NAME	*name;
	char		*common_name = NULL;
	int		 common_name_len;
	int		 rv = -1;

	name = X509_get_subject_name(cert);
	if (name == NULL)
		goto out;

	common_name_len = X509_NAME_get_text_by_NID(name, NID_commonName,
	    NULL, 0);
	if (common_name_len < 0)
		goto out;

	common_name = calloc(common_name_len + 1, 1);
	if (common_name == NULL)
		goto out;

	X509_NAME_get_text_by_NID(name, NID_commonName, common_name,
	    common_name_len + 1);

	/* NUL bytes in CN? */
	if (common_name_len != (int)strlen(common_name)) {
		fprintf(ttyout, "%s: NUL byte in Common Name field, "
		    "probably a malicious certificate.\n", getprogname());
		rv = -2;
		goto out;
	}

	if (ssl_match_hostname(common_name, host) == 0)
		rv = 0;
out:
	free(common_name);
	return rv;
}

int
ssl_check_hostname(X509 *cert, char *host)
{
	int	rv;

	rv = ssl_check_subject_altname(cert, host);
	if (rv == 0 || rv == -2)
		return rv;

	return ssl_check_common_name(cert, host);
}

SSL_CTX *
ssl_get_ssl_ctx(void)
{
	static SSL_CTX	*ssl_ctx = NULL;
	static int	 libssl_loaded = 0;

 	if (ssl_ctx != NULL)
		return ssl_ctx;

	if (!libssl_loaded) {
		SSL_library_init();
		SSL_load_error_strings();
		libssl_loaded = 1;
	}

	ssl_ctx = SSL_CTX_new(SSLv23_client_method());
	if (ssl_ctx == NULL)
		goto err;

	if (ssl_verify) {
		if (ssl_ca_file == NULL && ssl_ca_path == NULL)
			ssl_ca_file = _PATH_SSL_CAFILE;

		if (SSL_CTX_load_verify_locations(ssl_ctx,
		    ssl_ca_file, ssl_ca_path) != 1)
			goto err;

		SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);
		if (ssl_verify_depth != -1)
			SSL_CTX_set_verify_depth(ssl_ctx,
			    ssl_verify_depth);
	}

	if (ssl_ciphers != NULL &&
	    SSL_CTX_set_cipher_list(ssl_ctx, ssl_ciphers) == -1)
		goto err;

	return ssl_ctx;
err:
	if (ssl_ctx != NULL) {
		SSL_CTX_free(ssl_ctx);
		ssl_ctx = NULL;
	}
	return NULL;
}
#endif

a194 1
	SSL_CTX *ssl_ctx = NULL;
d196 1
a196 1
	SSL *ssl = NULL;
a588 2
		union { struct in_addr ip4; struct in6_addr ip6; } addrbuf;

d594 2
a595 3
		ssl_ctx = ssl_get_ssl_ctx();
		if (ssl_ctx == NULL) {
			ERR_print_errors_fp(ttyout);
d598 2
a599 3
		ssl = SSL_new(ssl_ctx);
		if (ssl == NULL) {
			ERR_print_errors_fp(ttyout);
d602 3
a604 2
		if (SSL_set_fd(ssl, s) == 0) {
			ERR_print_errors_fp(ttyout);
d607 2
a608 13
		/*
		 * RFC4366 (SNI): Literal IPv4 and IPv6 addresses are not
		 * permitted in "HostName".
		 */
		if (inet_pton(AF_INET,  host, &addrbuf) != 1 &&
		    inet_pton(AF_INET6, host, &addrbuf) != 1) {
			if (SSL_set_tlsext_host_name(ssl, host) == 0) {
				ERR_print_errors_fp(ttyout);
				goto cleanup_url_get;
			}
		}
		if (SSL_connect(ssl) <= 0) {
			ERR_print_errors_fp(ttyout);
a610 20
		if (ssl_verify) {
			X509	*cert;

			cert = SSL_get_peer_certificate(ssl);
			if (cert == NULL) {
				fprintf(ttyout, "%s: no server certificate\n",
				    getprogname());
				goto cleanup_url_get;
			}

			if (ssl_check_hostname(cert, host) != 0) {
				X509_free(cert);
				fprintf(ttyout, "%s: host `%s' not present in"
				    " server certificate\n",
				    getprogname(), host);
				goto cleanup_url_get;
			}

			X509_free(cert);
		}
d973 3
a975 3
	if (ssl) {
		SSL_shutdown(ssl);
		SSL_free(ssl);
d1429 1
a1429 1
ftp_readline(FILE *fp, SSL *ssl, size_t *lenp)
d1442 1
a1442 1
ftp_read(FILE *fp, SSL *ssl, char *buf, size_t len)
d1449 1
a1449 1
		int nr;
d1451 1
a1451 3
		if (len > INT_MAX)
			len = INT_MAX;
		if ((nr = SSL_read(ssl, buf, (int)len)) <= 0)
d1463 1
a1463 1
ftp_printf(FILE *fp, SSL *ssl, const char *fmt, ...)
d1474 1
a1474 1
		ret = SSL_vprintf((SSL*)ssl, fmt, ap);
d1485 1
a1485 1
SSL_vprintf(SSL *ssl, const char *fmt, va_list ap)
d1487 2
a1489 1
	char *string;
d1493 1
a1493 1
	ret = SSL_write(ssl, string, ret);
d1499 1
a1499 1
SSL_readline(SSL *ssl, size_t *lenp)
d1501 1
a1501 1
	size_t i, len;
d1516 6
a1521 8
		ret = SSL_read(ssl, &c, 1);
		if (ret <= 0) {
			if (SSL_get_error(ssl, ret) == SSL_ERROR_WANT_READ)
				goto again;
			else
				errx(1, "SSL_read error: %u",
				    SSL_get_error(ssl, ret));
		}
@


1.124
log
@Allow ftp(1) to change its User-Agent for HTTP(S) URL requests using a
-U command-line option.

feedback from deraadt@@, halex@@, and Adam Thompson
ok deraadt@@ sthen@@, man page changes ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.123 2014/07/05 09:20:54 guenther Exp $	*/
a1286 3
#ifndef SMALL
	char *uagent = NULL;
#endif /* !SMALL */
a1306 7
	if (httpuseragent == NULL)
		httpuseragent = HTTP_USER_AGENT;
#ifndef SMALL
	else
		uagent = httpuseragent;
#endif /* !SMALL */

a1582 3
#ifndef SMALL
	free(uagent);
#endif /* !SMALL */
@


1.123
log
@Given an http or https URL with user and password, URL-decode the user
and password info before base64 encoding it for the Authorization header.
Also:
 - eliminate the COOKIE_MAX_LEN constant (if they can fit it on the command
   line or in their environment, surely we can malloc the base64 version)
 - rename the variable with user:pass from "cookie" to "credentials"
 - empty password isn't an error
 - add a boolean ishttpurl so that we don't have to do strcmps on the schema
   that we just set
 - when looping across multiple ftp:// urls on the command line, don't
   leak the username/password memory

problem noted by Se'bastien Marie (semarie-openbsd (at) latrappe.fr)
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.122 2014/05/20 01:25:23 guenther Exp $	*/
d887 1
a887 1
			    HTTP_USER_AGENT);
d890 1
a890 1
			    epath, buf ? buf : "", HTTP_USER_AGENT);
d948 1
a948 1
		    buf ? buf : "", HTTP_USER_AGENT);
d1287 3
d1310 7
d1593 3
@


1.122
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.121 2014/05/19 20:09:22 jca Exp $	*/
d79 1
a100 2
#define COOKIE_MAX_LEN	42

d395 1
a395 1
	char *cookie = NULL;
d404 1
a404 1
	char *locbase, *full_host = NULL, *auth = NULL;
d406 1
a406 1
	int ishttpsurl = 0;
d422 1
d475 1
a475 2
	if (proxyenv == NULL &&
	    (!strcmp(scheme, HTTP_URL) || !strcmp(scheme, HTTPS_URL))) {
d477 2
a478 8
			size_t authlen = (strlen(host) + 5) * 4 / 3;
			*p = 0;	/* Kill @@ */
			if ((auth = malloc(authlen)) == NULL)
				err(1, "Can't allocate memory for "
				    "authorization");
			if (b64_ntop(host, strlen(host),
			    auth, authlen) == -1)
				errx(1, "error in base64 encoding");
d540 1
a540 2
			cookie = strchr(host, ':');
			if (EMPTYSTRING(cookie)) {
d544 1
a544 5
			cookie  = malloc(COOKIE_MAX_LEN);
			if (cookie == NULL)
				errx(1, "out of memory");
			if (b64_ntop(host, strlen(host), cookie, COOKIE_MAX_LEN) == -1)
				errx(1, "error in base64 encoding");
d546 1
d557 1
d690 1
a690 1
		    host, portnum, path, savefile, auth);
d786 1
a786 1
			proxy_connect(s, sslhost, cookie);
d883 1
a883 1
		if (cookie)
d886 2
a887 1
			    epath, cookie, buf ? buf : "", HTTP_USER_AGENT);
d902 1
a902 1
		if (auth) {
d907 3
a909 3
			    auth);
			free(auth);
			auth = NULL;
d1225 1
a1225 1
	free(auth);
d1234 1
a1234 1
	free(cookie);
d1310 1
d1314 3
d1373 1
d1381 1
d1616 20
@


1.121
log
@X509_free() the certificate if the server hostname check fails.
No functional change.  Reported by Mike Small and Maxime Villard.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.120 2014/05/19 20:05:09 jca Exp $	*/
d726 1
a726 1
		warnx("%s: %s", gai_strerror(error), host);
d735 1
a735 1
			warnx("%s: %s", gai_strerror(error), srcaddr);
@


1.120
log
@Explicitely initialize two static variables introduced in the previous
commit, to please lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.119 2014/05/19 20:03:16 jca Exp $	*/
d859 1
@


1.119
log
@HTTPS connections may see redirects, so initialize libcrypto and libssl
only once, and reuse the crafted SSL_CTX for further connections.
ok lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.118 2014/04/09 10:10:57 jca Exp $	*/
d337 2
a338 2
	static SSL_CTX	*ssl_ctx;
	static int	 libssl_loaded;
@


1.118
log
@If TLS validation is on, retrieve the server TLS certificate and
check the server hostname against the subjectAltName extension field
and/or the CommonName DN portion.  ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.117 2014/03/30 22:40:38 jca Exp $	*/
d90 1
d333 46
d819 1
a819 3
		SSL_library_init();
		SSL_load_error_strings();
		ssl_ctx = SSL_CTX_new(SSLv23_client_method());
a820 18
			ERR_print_errors_fp(ttyout);
			goto cleanup_url_get;
		}
		if (ssl_verify) {
			if (ssl_ca_file == NULL && ssl_ca_path == NULL)
				ssl_ca_file = _PATH_SSL_CAFILE;
			if (SSL_CTX_load_verify_locations(ssl_ctx,
			    ssl_ca_file, ssl_ca_path) != 1) {
				ERR_print_errors_fp(ttyout);
				goto cleanup_url_get;
			}
			SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);
			if (ssl_verify_depth != -1)
				SSL_CTX_set_verify_depth(ssl_ctx,
				    ssl_verify_depth);
		}
		if (ssl_ciphers != NULL &&
		    SSL_CTX_set_cipher_list(ssl_ctx, ssl_ciphers) == -1) {
@


1.117
log
@SNI support.  ok guenther@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.116 2014/03/30 22:39:42 jca Exp $	*/
d66 1
d86 4
d175 159
d820 19
@


1.116
log
@Check the return value from SSL_CTX_set_cipher_list(), for consistency.
ok guenther@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.115 2014/03/30 22:37:41 jca Exp $	*/
d601 2
d641 11
@


1.115
log
@SSLeay_add_ssl_algorithms() is just a #define for SSL_library_init(), so
kill the former.  ok guenther@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.114 2014/03/02 17:57:18 tedu Exp $	*/
d626 5
a630 2
		if (ssl_ciphers != NULL)
			SSL_CTX_set_cipher_list(ssl_ctx, ssl_ciphers);
@


1.114
log
@only signed types work when comparing less than zero.
reported by matthieu. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.113 2014/02/26 20:48:06 tedu Exp $	*/
a607 1
		SSLeay_add_ssl_algorithms();
@


1.114.4.1
log
@SECURITY fix: the ftp(1) client would fail to check the server hostname
when connecting to an https website. This allowed any trusted CA-signed
certificate to impersonate any other website.  ok sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.114 2014/03/02 17:57:18 tedu Exp $	*/
a65 1
#include <openssl/x509v3.h>
a84 4
int		ssl_match_hostname(char *, char *);
int		ssl_check_subject_altname(X509 *, char *);
int		ssl_check_common_name(X509 *, char *);
int		ssl_check_hostname(X509 *, char *);
a169 159
#ifndef SMALL
int
ssl_match_hostname(char *cert_hostname, char *hostname)
{
	if (strcasecmp(cert_hostname, hostname) == 0)
			return 0;

	/* wildcard match? */
	if (cert_hostname[0] == '*') {
		char	*cert_domain, *domain;

		cert_domain = &cert_hostname[1];
		if (cert_domain[0] != '.')
			return -1;
		if (strlen(cert_domain) == 1)
			return -1;

		domain = strchr(hostname, '.');
		/* no wildcard match against a hostname with no domain part */
		if (domain == NULL || strlen(domain) == 1)
			return -1;

		if (strcasecmp(cert_domain, domain) == 0)
			return 0;
	}

	return -1;
}

int
ssl_check_subject_altname(X509 *cert, char *host)
{
	STACK_OF(GENERAL_NAME)	*altname_stack = NULL;
	union { struct in_addr ip4; struct in6_addr ip6; } addrbuf;
	int	addrlen, type;
	int	count, i;
	int	rv = -1;

	altname_stack =
	    X509_get_ext_d2i(cert, NID_subject_alt_name, NULL, NULL);
	if (altname_stack == NULL)
		return -1;

	if (inet_pton(AF_INET, host, &addrbuf) == 1) {
		type = GEN_IPADD;
		addrlen = 4;
	} else if (inet_pton(AF_INET6, host, &addrbuf) == 1) {
		type = GEN_IPADD;
		addrlen = 16;
	} else
		type = GEN_DNS;

	count = sk_GENERAL_NAME_num(altname_stack);
	for (i = 0; i < count; i++) {
		GENERAL_NAME	*altname;

		altname = sk_GENERAL_NAME_value(altname_stack, i);

		if (altname->type != type)
			continue;

		if (type == GEN_DNS) {
			unsigned char	*data;
			int		 format;

			format = ASN1_STRING_type(altname->d.dNSName);
			if (format == V_ASN1_IA5STRING) {
				data = ASN1_STRING_data(altname->d.dNSName);

				if (ASN1_STRING_length(altname->d.dNSName) !=
				    (int)strlen(data)) {
					fprintf(ttyout, "%s: NUL byte in "
					    "subjectAltName, probably a "
					    "malicious certificate.\n",
					    getprogname());
					rv = -2;
					break;
				}

				if (ssl_match_hostname(data, host) == 0) {
					rv = 0;
					break;
				}
			} else
				fprintf(ttyout, "%s: unhandled subjectAltName "
				    "dNSName encoding (%d)\n", getprogname(),
				    format);

		} else if (type == GEN_IPADD) {
			unsigned char	*data;
			int		 datalen;

			datalen = ASN1_STRING_length(altname->d.iPAddress);
			data = ASN1_STRING_data(altname->d.iPAddress);

			if (datalen == addrlen &&
			    memcmp(data, &addrbuf, addrlen) == 0) {
				rv = 0;
				break;
			}
		}
	}

	sk_GENERAL_NAME_free(altname_stack);
	return rv;
}

int
ssl_check_common_name(X509 *cert, char *host)
{
	X509_NAME	*name;
	char		*common_name = NULL;
	int		 common_name_len;
	int		 rv = -1;

	name = X509_get_subject_name(cert);
	if (name == NULL)
		goto out;

	common_name_len = X509_NAME_get_text_by_NID(name, NID_commonName,
	    NULL, 0);
	if (common_name_len < 0)
		goto out;

	common_name = calloc(common_name_len + 1, 1);
	if (common_name == NULL)
		goto out;

	X509_NAME_get_text_by_NID(name, NID_commonName, common_name,
	    common_name_len + 1);

	/* NUL bytes in CN? */
	if (common_name_len != (int)strlen(common_name)) {
		fprintf(ttyout, "%s: NUL byte in Common Name field, "
		    "probably a malicious certificate.\n", getprogname());
		rv = -2;
		goto out;
	}

	if (ssl_match_hostname(common_name, host) == 0)
		rv = 0;
out:
	free(common_name);
	return rv;
}

int
ssl_check_hostname(X509 *cert, char *host)
{
	int	rv;

	rv = ssl_check_subject_altname(cert, host);
	if (rv == 0 || rv == -2)
		return rv;

	return ssl_check_common_name(cert, host);
}
#endif

a640 19
		}
		if (ssl_verify) {
			X509	*cert;

			cert = SSL_get_peer_certificate(ssl);
			if (cert == NULL) {
				fprintf(ttyout, "%s: no server certificate\n",
				    getprogname());
				goto cleanup_url_get;
			}

			if (ssl_check_hostname(cert, host) != 0) {
				fprintf(ttyout, "%s: host `%s' not present in"
				    " server certificate\n",
				    getprogname(), host);
				goto cleanup_url_get;
			}

			X509_free(cert);
@


1.113
log
@use a larger read buffer to speed things up, particularly during upgrades.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.112 2013/12/24 13:00:59 jca Exp $	*/
d191 1
a191 1
	size_t len, wlen;
@


1.112
log
@Add support for SSL/TLS server certificate validation, enabled by
default.  See the documentation for the `-S' switch.  This also allows
setting the preferred ciphers for the communication.  Documentation bits
ok'ed by jmc@@, ok beck@@ sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.111 2013/11/13 20:41:10 deraadt Exp $	*/
d202 1
d422 1
a422 1
		if ((buf = malloc(4096)) == NULL)
d428 1
a428 1
		while ((len = read(s, buf, 4096)) > 0) {
d939 1
a939 1
	if ((buf = malloc(4096)) == NULL)
d945 1
a945 1
		len = ftp_read(fin, ssl, buf, 4096);
@


1.111
log
@satisfy gcc in -Whiny mode
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.110 2013/10/27 18:31:24 guenther Exp $	*/
d609 19
d629 1
a629 1
		if (ssl == NULL || ssl_ctx == NULL) {
@


1.110
log
@If a constant string needs a name, use a static const array instead of a
pointer or non-const array, as that minimizes the symbols, maximizes the
placement into read-only memory, and avoids warnings from gcc -Wformat=2
when they're used as format strings.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.109 2013/04/09 08:58:46 sthen Exp $	*/
d816 1
a816 1
			if (s=strcspn(cp, " \t"))
@


1.109
log
@Retry when SSL_read fails with SSL_ERROR_WANT_READ. Fixes the case where
an https server attempts renegotiation. ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.108 2013/03/30 10:11:35 tobias Exp $	*/
d98 1
a98 1
static const char *at_encoding_warning =
@


1.108
log
@Fixed a memory leak during HTTP header parsing.

ok deraadt, halex, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.107 2012/08/18 06:46:46 haesbaert Exp $	*/
d754 1
a754 1
		/*              
d1488 1
d1500 9
a1508 2
		if (SSL_read(ssl, &c, 1) <= 0)
			break;
@


1.107
log
@Fix http resume without out auth, which I broke on the last commit,
spotted by bluhm.

ok bluhm.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.106 2012/08/14 20:47:08 haesbaert Exp $	*/
d880 1
@


1.106
log
@Add support for basic HTTP authentication as described on RFC 2617 and
RFC 3986. This allows the following idiom in ftp:

ftp http[s]://user:pass@@host/file

With some pointers from halex a lot of testing and feedback from lteo,
thanks a lot.

ok lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.105 2012/04/30 13:41:26 haesbaert Exp $	*/
d675 5
a679 2
		ftp_printf(fin, ssl, "GET /%s %s\r\nHost: ", epath,
		    "HTTP/1.0");
@


1.105
log
@Add a -s flag to ftp(1) to let the user specify the source IP address
of the connection. This is useful for testing ftp(1) over VPN tunnels.

This -s flag is present in the other BSDs, including OS X.

All work was done by Lawrence Teo, thanks (-:.

ok myself mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.104 2012/04/23 21:22:02 sthen Exp $	*/
d180 1
a180 1
	char *epath, *redirurl, *loctail;
d194 1
a194 1
	char *locbase, *full_host = NULL;
d256 23
d486 3
a488 2
		fprintf(ttyout, "host %s, port %s, path %s, save as %s.\n",
		    host, portnum, path, savefile);
d665 10
a674 1
#endif /* !SMALL */
d676 1
a676 4
#ifndef SMALL
			restart_point ? "HTTP/1.1\r\nConnection: close" :
#endif /* !SMALL */
			"HTTP/1.0");
a677 2
			char *h, *p;

d984 1
@


1.104
log
@Handle HTTP Content-Length headers with trailing whitespace. ok martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.103 2010/08/25 20:32:37 martynas Exp $	*/
d182 1
a182 1
	struct addrinfo hints, *res0, *res;
d201 1
d494 11
d519 20
a540 2
			int save_errno;

d565 4
@


1.103
log
@don't free proxyurl and cookie twice in the location code;  with halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.102 2010/07/23 22:27:16 halex Exp $	*/
d749 1
d751 2
@


1.102
log
@Handle redirection to relative url's in the Location: header of http
responses. Yes, they are violating the rfc's. Yes they do exist anyway.

Also fix a memory leak when url_encode fails to malloc, by simply
err'ing out if so.

feedback and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.101 2010/07/03 00:21:14 halex Exp $	*/
a760 2
			free(proxyurl);
			free(cookie);
@


1.101
log
@make lint happy

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.100 2010/06/29 23:12:33 halex Exp $	*/
d153 1
a153 1
		return NULL;
d180 1
a180 1
	char *epath;
d194 2
d207 1
a207 1
	if (strncasecmp(newline, HTTP_URL, sizeof(HTTP_URL) - 1) == 0)
d209 4
a212 1
	else if (strncasecmp(newline, FTP_URL, sizeof(FTP_URL) - 1) == 0) {
d215 3
d222 1
d226 1
d446 4
d458 3
a581 2
	if (epath == NULL)
		return (-1);
d761 43
d805 1
a805 1
				fprintf(ttyout, "Redirected to %s\n", cp);
d810 3
a812 6
			free(proxyurl);
			free(newline);
			free(cookie);
			rval = url_get(cp, proxyenv, savefile);
			free(buf);
			return (rval);
d920 1
@


1.100
log
@fix output handling:
- if a remote file by the name '-' is retrieved, that does not imply
  it should go to standard output...
- make -o '' reset any previous -o action
- properly handle multiple -o 's

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.99 2010/06/03 07:50:02 halex Exp $	*/
d685 1
@


1.99
log
@HTTP/1.1 requests must send a "Connection: close" header. Fixes the issue where
a download would stall at the end of the file for no apparent reason.

ok sthen@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.98 2010/06/03 07:39:53 phessler Exp $	*/
d262 1
a262 1
	if (resume && (strcmp(savefile, "-") == 0)) {
d340 1
a340 1
		if (strcmp(savefile, "-") != 0) {
d761 1
a761 1
	if (strcmp(savefile, "-") != 0) {
@


1.98
log
@When attempting to resume a download, against an HTTP server that
doesn't support resume, we restart the download from the beginning, like
all other browsers.

Diagnosed by sthen and halex, comment from sthen
OK sthen@@, halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.97 2009/10/16 12:28:04 martynas Exp $	*/
d595 1
a595 1
			restart_point ? "HTTP/1.1" :
@


1.97
log
@factor psummary code of ftp.c to be generic, for all types of
transfers.  makes output between all transfers consistent;  handles
SIGINFO for non-ftp transfers too;  shows statistics at the end:
7303400 bytes received in 96.00 seconds (74.29 KB/s)
tweak / ok halex@@, sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.96 2009/08/26 11:54:31 sthen Exp $	*/
d674 11
@


1.96
log
@In "auto-fetch" mode without -o, the filename to save under is derived
from the URL. In cases where the URL supplied on the command-line returned
an HTTP redirection, ftp(1) was changing the filename to one derived from
the redirected URL. Change this to always use a name derived from the
command-line URL.

Avoids unexpected behaviour with URI-encoded redirection URLs as seen
by matecocido on misc@@, and avoids surprises when the redirection is
to an unexpected filename. No change when -o is used.

ok martynas@@ deraadt@@ "I totally approve" halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.95 2009/08/06 23:33:35 martynas Exp $	*/
d187 1
a187 1
	volatile sig_t oldintr;
d200 2
d373 1
d377 2
d392 1
d398 1
d412 1
d425 1
a425 1
			fputs("Successfully retrieved file.\n", ttyout);
d768 1
d772 2
d789 1
d796 1
d810 1
d833 1
a833 1
		fputs("Successfully retrieved file.\n", ttyout);
@


1.95
log
@encode special or unsafe characters defined by rfc1738.  as a result,
- urls passed to ftp containing special characters or unsafe
characters (like, spaces, <>"#{}|\^~[]`%) work
- redirects containing special characters or unsafe characters
(like, spaces, <>"#{}|\^~[]`%) work
reported & tested by ian@@ (can fetch a distfile from sourceforge now)
feedback + ok tedu@@ & sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.94 2009/08/03 21:34:54 martynas Exp $	*/
d735 1
a735 1
			rval = url_get(cp, proxyenv, outfile);
@


1.94
log
@tweak error message.  url is valid per rfc1738 and can now be
fetchable with -o.  so point to it too.  requested by chris@@
ok sthen@@.  better halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.93 2009/07/27 23:11:26 martynas Exp $	*/
d106 65
d180 1
d548 1
d555 4
d569 1
a569 1
			    path, cookie, buf ? buf : "", HTTP_USER_AGENT);
d572 1
a572 1
			    path, buf ? buf : "", HTTP_USER_AGENT);
d585 1
a585 1
		ftp_printf(fin, ssl, "GET /%s %s\r\nHost: ", path,
d627 1
a627 1

@


1.93
log
@- make urls such as http://foo, http://foo/, or http://foo/bar/
fetchable, if -o outfile is passed.  outfile will be used as a local
filename
- fix a bug where 'no file after host' code path never got entered;
consider no file after dir invalid;  as code intended
proxy help&ok halex@@;  testing(including proxies,pkg_add)&ok sthen@@;
looks good to millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.92 2009/07/18 12:43:30 jsg Exp $	*/
d164 1
a164 1
			warnx("Invalid URL (no `/' after host): %s", origline);
d171 1
a171 1
			warnx("Invalid URL (no file after host): %s", origline);
d189 1
a189 1
		warnx("Invalid URL (no file after directory): %s", origline);
@


1.92
log
@Don't assign NULL to an integer type, use 0 instead.
No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.91 2009/06/29 09:58:40 halex Exp $	*/
d156 1
a156 1
		path = strchr(host, '/');		/* find path */
d158 4
d168 1
a168 1
		if (EMPTYSTRING(path)) {
d176 1
d179 5
a183 7
	else
		savefile = basename(path);

#ifndef SMALL
	if (resume && (strcmp(savefile, "-") == 0)) {
		warnx("can't append to stdout");
		goto cleanup_url_get;
a184 1
#endif /* !SMALL */
d193 7
d224 2
a225 1
		*--path = '/';			/* add / back to real path */
@


1.91
log
@Fix the range of a #ifndef SMALL ... #endif not to include the "break;"
needed not to make a status of 200 (OK) fall through to the redirect
handling.

This was not noticed since the later code would ignore the isredirect
flag unless it also received a "Location: " header.

ok martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.90 2009/06/13 20:01:10 martynas Exp $	*/
d1232 1
a1232 1
		ret = NULL;
@


1.90
log
@- stat is not fatal, since we want resume not to fail for non-existent
file transfers in all cases
- do it a bit earlier and use HTTP/1.0 if we won't send the range header
- change resume -> restart_point where it is intended
ok halex@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.89 2009/06/04 23:37:09 halex Exp $	*/
d586 1
a587 1
#endif /* !SMALL */
@


1.89
log
@silently ignore -a if a username is supplied in the url

"looks sensible" deraadt@@, "fine by me" martynas@@

also removed an indeed misplaced/outdated comment per martynas@@ request
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.88 2009/06/04 20:58:34 martynas Exp $	*/
d494 10
d506 1
a506 1
			resume ? "HTTP/1.1" :
d534 1
a534 12
		if (resume) {
			int ret;
			struct stat stbuf;

			ret = stat(savefile, &stbuf);
			if (ret < 0) {
				if (verbose)
					fprintf(ttyout, "\n");
				warn("Can't open %s", savefile);
				goto cleanup_url_get;
			}
			restart_point = stbuf.st_size;
a536 1
		}
d638 1
a638 1
			if (resume)
@


1.88
log
@set anonftp a little later;  in autofetcher itself.  after we
actually know that that login is not provided in url;  and we should
guess it.  fixes a bug reported by halex@@ where it tried to login
as 'ftp' after unsuccessful logins;  ok theo, halex@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.87 2009/05/10 21:45:52 martynas Exp $	*/
d1013 3
a1015 2
			anonftp = 1;	/* Handle "automatic" transfers. */
		else
d1017 1
@


1.87
log
@couple of fixes for fetch:
- don't spam ftp server with four anonftp logins;  if ftp_login has
already failed in setpeer we give up.  also makes install script
nicer;  req'd by theo
- fix autologin = no case which never really worked in fetch since
it did not check for autologin before logging in...
part 1: ok theo, krw@@
part 2: "looks right" millert@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.86 2009/05/05 19:35:30 martynas Exp $	*/
d1012 3
a1014 1
		if (username != NULL)
@


1.86
log
@make it clean removing the ifdef SMALL maze.  separate cmds and
small stuff.  make it a fetcher.  shrinks quite a bit
agreed by millert@@, krw@@
ok theo, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.85 2009/04/27 21:37:13 deraadt Exp $	*/
d1016 3
a1018 2
		if ((connected == 0) ||
		    ((connected == 1) && !ftp_login(host, username, pass))) {
@


1.85
log
@toast the rcsid strings which just get in the way
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.84 2009/04/26 21:26:03 martynas Exp $	*/
d71 1
d1049 1
d1051 4
@


1.84
log
@figure out titles automatically by using remote file name.  remove
-T and just show titles by default for non-verbose transfers;
discussed with, ok theo, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.83 2008/10/16 23:15:53 martynas Exp $	*/
a31 4

#if !defined(lint) && !defined(SMALL)
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.83 2008/10/16 23:15:53 martynas Exp $";
#endif /* not lint and not SMALL */
@


1.83
log
@- resume http transfers [-C], if local file does not exist
- resume ftp transfers [-C, reget, mget], if local file does not
exist
ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.82 2008/10/16 21:23:49 deraadt Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.82 2008/10/16 21:23:49 deraadt Exp $";
d307 1
a307 1
		progressmeter(-1);
d342 1
a342 1
		progressmeter(1);
d693 1
a693 1
	progressmeter(-1);
d731 1
a731 1
	progressmeter(1);
@


1.82
log
@use O_CREAT in -C mode too, for in case it is not there the first time
from frantisek holop, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.81 2008/09/26 11:11:59 espie Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.81 2008/09/26 11:11:59 espie Exp $";
d264 1
a264 1
		/* Open the output file */
d669 2
a670 1
			out = open(savefile, O_APPEND | O_WRONLY);
@


1.81
log
@support proxies with password.
adapted from a patch by nikns, with tweaks by millert.

took forever to test for real...

okay miod@@, henning@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.80 2008/07/08 21:07:57 martynas Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.80 2008/07/08 21:07:57 martynas Exp $";
d264 1
a264 1
		/* Open the output file.  */
d268 3
a270 1
				out = open(savefile, O_APPEND | O_WRONLY);
@


1.80
log
@- add support for recursive transfers (but not for floppies), e.g.
'mget -cr 4.*' would recursively fetch (-r), and resume the previous
transfers (-c) of 4.X release directories
uses local matching (fnmatch), but only for recursive transfers.
current behavior is not changed in any way.
- while here, ifndef SMALL debugging stuff, this saves some space,
for floppies
- some debugging code was enabled for non-debugging mode, checks
assume debug is set to zero, but it's not initially set
- all "Confirm with" prompts are forced, remove redundant argument
- fix usage: -C and -c are not available for SMALL

discussed a year ago w/ pyr@@
looks good to millert@@
previous version looked good to pyr@@
man page tweaks & ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.79 2008/06/26 05:42:20 ray Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.79 2008/06/26 05:42:20 ray Exp $";
d85 1
a85 1
int		proxy_connect(int, char *);
d225 1
a225 1
			*path++ = '\0';
d232 5
a236 1
			b64_ntop(host, strlen(host), cookie, COOKIE_MAX_LEN);
d238 1
a238 1
			 * This removes the password from proxyenv,
d241 1
a241 1
			for (host = strchr(proxyenv + 5, ':');  *host != '@@';
d245 1
a245 1
			host = path;
d430 1
a430 1
			proxy_connect(s, sslhost);
d481 1
a481 1
			fprintf(ttyout, " (via %s)\n", proxyenv);
d656 1
d768 1
d1271 1
a1271 1
proxy_connect(int socket, char *host)
d1290 9
a1298 1
	l = asprintf(&connstr, "CONNECT %s:%s HTTP/1.1\n\n", host, port);
@


1.79
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.78 2008/06/25 21:15:19 martynas Exp $	*/
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.78 2008/06/25 21:15:19 martynas Exp $";
d356 1
d360 1
d563 1
d566 1
d623 1
d626 1
d983 1
d989 1
d1287 1
d1290 1
@


1.78
log
@in resume mode, pass -c to mget when {dir,file}hasglob, so that i'm
able to continue multiple transfers with -C;  ok millert@@
while here fix some comments (!SMALL vs. SMALL stuff), and add
missing
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.77 2008/06/15 04:43:20 martynas Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.77 2008/06/15 04:43:20 martynas Exp $";
@


1.77
log
@accept empty password, since that's exactly what rfc1738 tells us
to do;  theo agrees, millert oks
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.76 2008/06/15 03:11:28 martynas Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.76 2008/06/15 03:11:28 martynas Exp $";
d77 1
a77 1
#else
d79 1
a79 1
#endif
d95 1
a95 1
#endif
d140 1
a140 1
#endif
d159 1
a159 1
#endif
d192 1
a192 1
#endif
d209 1
a209 1
#endif
d273 1
a273 1
#endif
d295 1
a295 1
#endif
d372 1
a372 1
#else
d374 1
a374 1
#endif
d387 1
a387 1
#endif
d432 1
a432 1
#endif
d468 1
a468 1
#else
d470 1
a470 1
#endif
d479 1
a479 1
#endif
d499 1
a499 1
#endif
d541 1
a541 1
#else
d544 1
a544 1
#endif
d554 1
a554 1
#endif
d589 1
a589 1
#endif
d604 1
a604 1
#endif
d640 1
a640 1
#endif
d665 1
a665 1
#endif
d728 1
a728 1
#endif
d756 1
a756 1
#endif
d858 1
a858 1
#endif
d1065 8
d1085 1
a1085 1
#endif
d1159 1
a1159 1
#endif
d1174 1
a1174 1
#endif
d1196 1
a1196 1
#endif
d1215 1
a1215 1
#endif
d1294 1
a1294 1
#endif
@


1.76
log
@in debug mode (-d), hide password in the same way as command() does;
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.75 2007/11/26 12:39:00 martynas Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.75 2007/11/26 12:39:00 martynas Exp $";
d901 1
a901 1
				if (EMPTYSTRING(username) || EMPTYSTRING(pass)) {
@


1.75
log
@implement -C for continuing ftp, http(s), and file transfers
ok millert@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.74 2007/06/13 13:52:26 pyr Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.74 2007/06/13 13:52:26 pyr Exp $";
d987 2
a988 1
			    username, pass, host, portnum, dir, file);
@


1.74
log
@Enable cookie support. This allows parsing of netscape-like cookie jars
and sending of appropriate cookies. No retrieval of new cookies is done.
Careful review and lots of input by millert and ray.

ok millert@@, ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.73 2007/04/17 14:58:51 drahn Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.73 2007/04/17 14:58:51 drahn Exp $";
d187 7
d269 7
a275 2
			out = open(savefile, O_CREAT | O_WRONLY | O_TRUNC,
			    0666);
d283 14
d496 5
a500 1
		ftp_printf(fin, ssl, "GET /%s HTTP/1.0\r\nHost: ", path);
d526 15
d578 1
a578 1
	status = strtonum(ststr, 200, 307, &errstr);
d586 2
d589 1
d600 5
d637 4
d661 7
a667 1
		out = open(savefile, O_CREAT | O_WRONLY | O_TRUNC, 0666);
d725 5
a729 1
	if (filesize != -1 && len == 0 && bytes != filesize) {
d1072 6
a1077 1
			get(xargc, xargv);
@


1.73
log
@Support proxies which require a password just like ftp servers accept passwords
based on code from Florent Thoumie, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.72 2007/02/08 03:19:12 ray Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.72 2007/02/08 03:19:12 ray Exp $";
d451 3
d463 2
a464 2
			    "Proxy-Authorization: Basic %s\r\n%s\r\n\r\n",
			    path, cookie, HTTP_USER_AGENT);
d466 2
a467 2
			ftp_printf(fin, ssl, "GET %s HTTP/1.0\r\n%s\r\n\r\n",
			    path, HTTP_USER_AGENT);
d500 2
a501 1
		ftp_printf(fin, ssl, "\r\n%s\r\n\r\n", HTTP_USER_AGENT);
d505 7
@


1.72
log
@Remove double semicolons.

From Pierre Riteau <pierre dot riteau at free dot fr>.

OK jaredy@@ and moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.71 2007/02/03 05:18:40 ray Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.71 2007/02/03 05:18:40 ray Exp $";
d72 1
d104 1
d129 1
d221 4
d226 17
d458 8
a465 2
		ftp_printf(fin, ssl, "GET %s HTTP/1.0\r\n%s\r\n\r\n", path,
		    HTTP_USER_AGENT);
@


1.71
log
@Plug memory leak.

OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.70 2006/09/25 18:59:59 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.70 2006/09/25 18:59:59 deraadt Exp $";
d413 1
a413 1
			goto cleanup_url_get;;
@


1.70
log
@You forgot about -DSMALL and broke all the install media
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.69 2006/09/25 10:18:39 jsg Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.69 2006/09/25 10:18:39 jsg Exp $";
d1169 1
@


1.69
log
@Support some additional HTTP redirect codes.
"looks good" pedro, fgsch, ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.68 2006/07/07 12:00:25 ray Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.68 2006/07/07 12:00:25 ray Exp $";
d135 1
a135 1
	int ishttpsurl = 0, status;
d139 1
@


1.68
log
@Remove extraneous code:
 - Instead of generating the same string twice using printf,
   generate once and reuse.
 - Use err instead of errx with strerror.

OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.67 2006/06/23 20:35:25 steven Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.67 2006/06/23 20:35:25 steven Exp $";
d121 1
a121 1
	char pbuf[NI_MAXSERV], hbuf[NI_MAXHOST], *cp, *portnum, *path;
d135 1
a135 1
	int ishttpsurl = 0;
d489 15
a503 1
	if (strncmp(cp, "301", 3) == 0 || strncmp(cp, "302", 3) == 0) {
d509 2
a510 1
	} else if (strncmp(cp, "200", 3)) {
@


1.67
log
@free and sl_free already check against NULL, remove a few unneeded ifs.

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.66 2006/06/01 22:42:11 ray Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.66 2006/06/01 22:42:11 ray Exp $";
a1144 2
	if (debug)
		printf("CONNECT %s:%s HTTP/1.1\n\n", host, port);
d1148 2
d1151 1
a1151 1
		 errx(1, "Could not send connect string: %s", strerror(errno));
@


1.66
log
@Remove two unnecessary strlen() calls.  Also, check if asprintf
returns -1 instead of checking if connstr == NULL.

OK beck@@, moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.65 2006/05/25 03:48:23 ray Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.65 2006/05/25 03:48:23 ray Exp $";
d537 1
a537 2
			if (proxyurl)
				free(proxyurl);
d540 1
a540 2
			if (buf)
				free(buf);
d637 2
a638 4
	if (buf)
		free(buf);
	if (proxyurl)
		free(proxyurl);
@


1.65
log
@No matter how big the buffer size is, always limit to INT_MAX for
SSL connections, due to SSL_read()'s prototype.  This allows us to
change ftp_read to return size_t and have it return (0) on error,
just like fread().

OK otto@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.64 2006/05/25 03:45:25 ray Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.64 2006/05/25 03:45:25 ray Exp $";
d1132 1
d1151 2
a1152 2
	asprintf(&connstr, "CONNECT %s:%s HTTP/1.1\n\n", host, port);
	if (!connstr)
d1154 1
a1154 1
	if (write(socket, connstr, strlen(connstr)) != strlen(connstr))
@


1.64
log
@Don't recalculate string length, just use return value from vasprintf.
While here, remove pointless void pointer cast.

OK otto@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.63 2006/05/25 03:43:36 ray Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.63 2006/05/25 03:43:36 ray Exp $";
d89 1
a89 1
int		ftp_read(FILE *, SSL *, char *, size_t);
d1045 1
a1045 1
int
d1048 1
a1048 1
	int ret;
d1052 10
a1061 2
	else if (ssl != NULL)
		ret = SSL_read(ssl, buf, (int)len);
@


1.63
log
@Minor type correction.

OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.62 2006/05/16 23:43:16 ray Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.62 2006/05/16 23:43:16 ray Exp $";
d1090 1
a1090 1
	ret = SSL_write(ssl, (void *)string, (int)strlen(string));
@


1.62
log
@Remove shadowing variables and properly use /* FALLTHROUGH */
comments.  No binary change.

Found by lint.

OK beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.61 2006/05/16 16:20:42 deraadt Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.61 2006/05/16 16:20:42 deraadt Exp $";
d1098 1
a1098 2
	int i;
	size_t len;
@


1.61
log
@https URL support; rototilled by a few people including me; originally
from Rainer_Giedat@@genua.de
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.60 2006/04/25 05:45:20 tedu Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.60 2006/04/25 05:45:20 tedu Exp $";
d122 1
a122 1
	char *hosttail, *cause = "unknown", *line, *host, *port, *buf = NULL;
d126 1
a126 1
	char * volatile proxy = NULL;
d140 2
a141 2
	line = strdup(origline);
	if (line == NULL)
d143 4
a146 4
	if (strncasecmp(line, HTTP_URL, sizeof(HTTP_URL) - 1) == 0)
		host = line + sizeof(HTTP_URL) - 1;
	else if (strncasecmp(line, FTP_URL, sizeof(FTP_URL) - 1) == 0) {
		host = line + sizeof(FTP_URL) - 1;
d148 2
a149 2
	} else if (strncasecmp(line, FILE_URL, sizeof(FILE_URL) - 1) == 0) {
		host = line + sizeof(FILE_URL) - 1;
d152 2
a153 2
	} else if (strncasecmp(line, HTTPS_URL, sizeof(HTTPS_URL) - 1) == 0) {
		host = line + sizeof(HTTPS_URL) - 1;
d157 1
a157 1
		errx(1, "url_get: Invalid URL '%s'", line);
d199 2
a200 2
		proxy = strdup(proxyenv);
		if (proxy == NULL)
d202 4
a205 4
		if (strncasecmp(proxy, HTTP_URL, sizeof(HTTP_URL) - 1) == 0)
			host = proxy + sizeof(HTTP_URL) - 1;
		else if (strncasecmp(proxy, FTP_URL, sizeof(FTP_URL) - 1) == 0)
			host = proxy + sizeof(FTP_URL) - 1;
d218 1
a218 1
		path = line;
d394 1
a394 1
			proxy = NULL;
d426 1
a426 1
	if (proxy) {
d506 1
a506 1
	while (1) {
d537 3
a539 3
			if (proxy)
				free(proxy);
			free(line);
d641 3
a643 3
	if (proxy)
		free(proxy);
	free(line);
d693 2
a694 2
	char *cp, *line, *host, *dir, *file, *portnum;
	char *user, *pass, *pathstart;
d719 1
a719 1
	for (rval = 0; (rval == 0) && (argpos < argc); free(line), argpos++) {
d722 1
a722 1
		host = dir = file = portnum = user = pass = NULL;
d727 2
a728 2
		line = strdup(argv[argpos]);
		if (line == NULL)
d734 1
a734 1
		if (strncasecmp(line, HTTP_URL, sizeof(HTTP_URL) - 1) == 0 ||
d737 1
a737 1
		    strncasecmp(line, HTTPS_URL, sizeof(HTTPS_URL) -1) == 0 ||
d739 1
a739 1
		    strncasecmp(line, FILE_URL, sizeof(FILE_URL) - 1) == 0) {
d741 1
a741 1
			if (url_get(line, httpproxy, outfile) == -1)
d751 2
a752 2
		host = line;
		if (strncasecmp(line, FTP_URL, sizeof(FTP_URL) - 1) == 0) {
d756 1
a756 1
				if (url_get(line, ftpproxy, outfile) == -1)
d770 1
a770 1
				user = host;
d781 1
a781 1
				if (EMPTYSTRING(user) || EMPTYSTRING(pass)) {
d787 1
a787 1
				user = urldecode(user);
d867 1
a867 1
			    user, pass, host, portnum, dir, file);
d884 1
a884 1
		if (user != NULL)
d889 1
a889 1
		    ((connected == 1) && !ftp_login(host, user, pass))) {
@


1.60
log
@two strtol calls that were begging to be converted to strtonum
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.59 2006/04/03 21:05:14 uwe Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: fetch.c,v 1.59 2006/04/03 21:05:14 uwe Exp $";
d66 1
d73 7
d87 8
d98 1
a130 1
	size_t len;
d132 7
d151 5
d191 8
d319 3
d323 1
d325 4
a329 4
		/*
		 * If the services file is corrupt/missing, fall back
		 * on our hard-coded defines.
		 */
d332 5
d378 4
d390 28
d419 1
d433 1
a433 1
		fprintf(fin, "GET %s HTTP/1.0\r\n%s\r\n\r\n", path,
d436 1
a436 1
		fprintf(fin, "GET /%s HTTP/1.0\r\nHost: ", path);
d449 1
a449 1
			fprintf(fin, "[%s]", h);
d452 1
a452 1
			fprintf(fin, "%s", host);
d459 4
d464 3
a466 2
			fprintf(fin, ":%s", port);
		fprintf(fin, "\r\n%s\r\n\r\n", HTTP_USER_AGENT);
d470 1
a470 1
	if (fflush(fin) == EOF) {
d474 1
a474 2

	if ((buf = fparseln(fin, &len, NULL, "\0\0\0", 0)) == NULL) {
d507 1
a507 1
		if ((buf = fparseln(fin, &len, NULL, "\0\0\0", 0)) == NULL) {
d511 1
d576 3
a578 1
	while ((len = fread(buf, sizeof(char), 4096, fin)) > 0) {
d580 2
a581 2
		for (cp = buf; len > 0; len -= i, cp += i) {
			if ((i = write(out, cp, len)) == -1) {
d629 6
d735 4
d979 4
a982 2
		/* Can't use strtol here because next char after %xx may be
		 * a digit. */
d1023 3
d1031 121
@


1.59
log
@Ignore http_proxy for file urls; ok millert deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.58 2006/03/29 15:54:55 grunk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.58 2006/03/29 15:54:55 grunk Exp $";
@


1.58
log
@fix fetching zero-length files via proxy.  while there, also fix progress-meter
for files >2GB via proxy.

help and discussion otto@@,  ok otto@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.57 2006/02/01 09:19:07 otto Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.57 2006/02/01 09:19:07 otto Exp $";
d162 1
a162 1
	if (proxyenv != NULL) {				/* use proxy */
@


1.57
log
@save errno, from Ray Lai in PR 4999.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.56 2005/08/05 21:01:53 fgsch Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.56 2005/08/05 21:01:53 fgsch Exp $";
d61 1
d104 1
a104 1
	char pbuf[NI_MAXSERV], hbuf[NI_MAXHOST], *cp, *ep, *portnum, *path;
d115 1
d441 2
a442 2
			filesize = strtol(cp, &ep, 10);
			if (filesize < 1 || *ep != '\0')
@


1.56
log
@when i did the cleanup and switched to http 1.1, i forgot to add chunked
support. while it's being tested switch to 1.0. noticed and tested by nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.55 2005/07/18 02:55:59 fgsch Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.55 2005/07/18 02:55:59 fgsch Exp $";
d312 2
d316 1
d318 1
@


1.55
log
@some cleanup and on non-proxy operation switch to HTTP 1.1 since we've
using some sort of it for a long time now; shrinks ~200 bytes.
ok by millert@@ and sturm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.54 2005/04/21 05:17:21 fgsch Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.54 2005/04/21 05:17:21 fgsch Exp $";
d352 1
a352 1
		fprintf(fin, "GET /%s HTTP/1.1\r\nHost: ", path);
d377 1
a377 2
		fprintf(fin, "\r\nConnection: close\r\n%s\r\n\r\n",
		    HTTP_USER_AGENT);
@


1.54
log
@avoid infinite recursion on redirects; From NetBSD but limit set to 10.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.53 2005/04/11 15:16:50 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.53 2005/04/11 15:16:50 deraadt Exp $";
d199 2
a200 1
			out = open(savefile, O_CREAT | O_WRONLY | O_TRUNC, 0666);
d337 2
d343 2
d349 2
a350 4
		if (verbose)
			fprintf(ttyout, "Requesting %s (via %s)\n",
			    origline, proxyenv);
		fprintf(fin, "GET %s HTTP/1.0\r\n%s\r\n\r\n", path, HTTP_USER_AGENT);
d352 1
a352 2
		if (verbose)
			fprintf(ttyout, "Requesting %s\n", origline);
d356 4
a359 1
			/* strip off scoped address portion, since it's local to node */
d365 1
a365 13
			/*
			 * Send port number only if it's specified and does not equal
			 * 80. Some broken HTTP servers get confused if you explicitly
			 * send them the port number.
			 */
			if (port && strcmp(port, "80") != 0)
				fprintf(fin,
				    "GET /%s HTTP/1.0\r\nHost: [%s]:%s\r\n%s\r\n\r\n",
				    path, h, port, HTTP_USER_AGENT);
			else
				fprintf(fin,
				    "GET /%s HTTP/1.0\r\nHost: [%s]\r\n%s\r\n\r\n",
				    path, h, HTTP_USER_AGENT);
d367 14
a380 10
		} else {
			if (port && strcmp(port, "80") != 0)
				fprintf(fin,
				    "GET /%s HTTP/1.0\r\nHost: %s:%s\r\n%s\r\n\r\n",
				    path, host, port, HTTP_USER_AGENT);
			else
				fprintf(fin,
				    "GET /%s HTTP/1.0\r\nHost: %s\r\n%s\r\n\r\n",
				    path, host, HTTP_USER_AGENT);
		}
@


1.53
log
@knf; cloder ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.52 2005/04/05 22:37:00 henning Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.52 2005/04/05 22:37:00 henning Exp $";
d93 2
d407 4
d643 1
@


1.52
log
@a : in the path is not a port # indicator so don't take ones into
account after the first / behind the hostname, ok jaredy
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.51 2004/09/16 04:39:16 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.51 2004/09/16 04:39:16 deraadt Exp $";
d89 1
a89 1
   "Extra `@@' characters in usernames and passwords should be encoded as %%40";
d101 3
a104 6
	int error;
	int i, isftpurl, isfileurl, isredirect;
	volatile int s, out;
	size_t len;
	char *cp, *ep, *portnum, *path;
	char pbuf[NI_MAXSERV], hbuf[NI_MAXHOST];
d106 2
a107 3
	char *line, *host, *port, *buf;
	char * volatile proxy;
	char *hosttail;
d109 1
d111 1
a111 12
	char *cause = "unknown";
	FILE *fin;
	int rval;

	s = -1;
	proxy = NULL;
	fin = NULL;
	buf = NULL;
	isftpurl = 0;
	isfileurl = 0;
	isredirect = 0;
	rval = -1;
d862 2
a863 24
        char *ret;
        char c;
        int i, reallen;

        if (str == NULL)
                return NULL;
        if ((ret = malloc(strlen(str)+1)) == NULL)
                err(1, "Can't allocate memory for URL decoding");
        for (i = 0, reallen = 0; str[i] != '\0'; i++, reallen++, ret++) {
                c = str[i];
                if (c == '+') {
                        *ret = ' ';
                        continue;
                }
                /* Can't use strtol here because next char after %xx may be
                 * a digit. */
                if (c == '%' && isxdigit(str[i+1]) && isxdigit(str[i+2])) {
                        *ret = hextochar(&str[i+1]);
                        i+=2;
                        continue;
                }
                *ret = c;
        }
        *ret = '\0';
d865 22
a886 1
        return ret-reallen;
d892 1
a892 1
        char c, ret;
d894 15
a908 15
        c = str[0];
        ret = c;
        if (isalpha(c))
                ret -= isupper(c) ? 'A' - 10 : 'a' - 10;
        else
                ret -= '0';
        ret *= 16;

        c = str[1];
        ret += c;
        if (isalpha(c))
                ret -= isupper(c) ? 'A' - 10 : 'a' - 10;
        else
                ret -= '0';
        return ret;
@


1.51
log
@type corrections and other delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.50 2004/07/20 03:50:25 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.50 2004/07/20 03:50:25 deraadt Exp $";
d609 1
a609 1
	char *user, *pass;
d722 6
@


1.50
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.49 2004/02/28 20:08:38 krw Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.49 2004/02/28 20:08:38 krw Exp $";
d565 1
d567 1
a567 1
aborthttp(int notused)
d579 1
d581 1
a581 1
abortfile(int notused)
@


1.49
log
@Open a new connection for each URL given on the command line.

This eliminates problematic 'CWD /' commands that caused interactive
commands and auto fetch commands to occaisonally end up in different
directories, creating problems for the install scripts.

Problematic 'CWD /' commands noticed by deraadt@@.

ok millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.48 2003/12/16 21:46:22 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.48 2003/12/16 21:46:22 deraadt Exp $";
d99 1
a99 4
url_get(origline, proxyenv, outfile)
	const char *origline;
	const char *proxyenv;
	const char *outfile;
d566 1
a566 2
aborthttp(notused)
	int notused;
d579 1
a579 2
abortfile(notused)
	int notused;
d603 1
a603 4
auto_fetch(argc, argv, outfile)
	int argc;
	char *argv[];
	char *outfile;
d866 1
a866 2
urldecode(str)
        const char *str;
d897 1
a897 2
hextochar(str)
        const char *str;
d919 1
a919 2
isurl(p)
	const char *p;
@


1.48
log
@for -DSMALL, do not include rcsid[]s
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.47 2003/08/15 23:13:06 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.47 2003/08/15 23:13:06 deraadt Exp $";
a612 1
	static char lasthost[MAXHOSTNAMELEN];
d619 1
a619 1
	int dirhasglob, filehasglob;
d780 1
a780 1
		 * Set up the connection if we don't have one.
d782 4
a785 34
		if (strcmp(host, lasthost) != 0) {
			int oautologin;

			(void)strlcpy(lasthost, host, sizeof lasthost);
			if (connected)
				disconnect(0, NULL);
			xargv[0] = __progname;
			xargv[1] = host;
			xargv[2] = NULL;
			xargc = 2;
			if (!EMPTYSTRING(portnum)) {
				xargv[2] = portnum;
				xargv[3] = NULL;
				xargc = 3;
			}
			oautologin = autologin;
			if (user != NULL)
				autologin = 0;
			setpeer(xargc, xargv);
			autologin = oautologin;
			if ((connected == 0) ||
			    ((connected == 1) && !ftp_login(host, user, pass))) {
				warnx("Can't connect or login to host `%s'",
				    host);
				rval = argpos + 1;
				continue;
			}

			/* Always use binary transfers. */
			setbinary(0, NULL);
		}
		/* cd back to '/' */
		xargv[0] = "cd";
		xargv[1] = "/";
d787 14
a800 2
		cd(2, xargv);
		if (!dirchange) {
d804 3
@


1.47
log
@remove extra \n in {warn,err}{,x} calls
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.46 2003/04/05 17:19:47 deraadt Exp $	*/
d40 3
a42 3
#ifndef lint
static char rcsid[] = "$OpenBSD: fetch.c,v 1.46 2003/04/05 17:19:47 deraadt Exp $";
#endif /* not lint */
@


1.46
log
@string fixes; ok miod henning
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.45 2003/03/31 23:04:07 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.45 2003/03/31 23:04:07 millert Exp $";
d236 1
a236 1
			errx(1, "Can't allocate memory for transfer buffer\n");
d500 1
a500 1
		errx(1, "Can't allocate memory for transfer buffer\n");
@


1.45
log
@Treat empty environment variables the same as NULL.  henning@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.44 2003/03/10 06:20:10 itojun Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.44 2003/03/10 06:20:10 itojun Exp $";
d786 1
a786 1
			(void)strcpy(lasthost, host);
@


1.44
log
@correct use of getnameinfo.  PR 3138
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.43 2003/02/17 18:51:11 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.43 2003/02/17 18:51:11 millert Exp $";
d633 4
a636 2
	ftpproxy = getenv(FTP_PROXY);
	httpproxy = getenv(HTTP_PROXY);
@


1.43
log
@Fix double free; Brian Poole
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.42 2002/12/30 23:04:42 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.42 2002/12/30 23:04:42 deraadt Exp $";
d110 1
a110 1
	char pbuf[NI_MAXSERV];
d312 3
a314 2
		getnameinfo(res->ai_addr, res->ai_addrlen, pbuf, sizeof(pbuf),
		    NULL, 0, NI_NUMERICHOST);
d316 1
a316 1
			fprintf(ttyout, "Trying %s...\n", pbuf);
@


1.42
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.41 2002/12/19 01:52:09 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.41 2002/12/19 01:52:09 deraadt Exp $";
a470 1
	free(buf);
d494 2
@


1.41
log
@only do "Trying ..." if verbose
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.40 2002/11/08 03:30:17 fgsch Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.40 2002/11/08 03:30:17 fgsch Exp $";
d76 2
a77 2
char    	hextochar(const char *);
char   		*urldecode(const char *);
d193 1
a193 1
		if (! EMPTYSTRING(path))
d230 1
a230 1
	
d237 1
a237 1
	
d272 1
a272 1
	
d380 2
a381 1
				fprintf(fin, "GET /%s HTTP/1.0\r\nHost: [%s]:%s\r\n%s\r\n\r\n", 
d384 2
a385 1
				fprintf(fin, "GET /%s HTTP/1.0\r\nHost: [%s]\r\n%s\r\n\r\n", 
d390 2
a391 1
				fprintf(fin, "GET /%s HTTP/1.0\r\nHost: %s:%s\r\n%s\r\n\r\n", 
d394 2
a395 1
				fprintf(fin, "GET /%s HTTP/1.0\r\nHost: %s\r\n%s\r\n\r\n", 
d688 1
a688 1
				if (strchr(pass, '@@') != NULL || 
d692 1
a692 1
				}	
d761 1
a761 1
		if (! EMPTYSTRING(dir)) {
d772 2
a773 1
			fprintf(ttyout, "user %s:%s host %s port %s dir %s file %s\n",
d789 1
a789 1
			if (! EMPTYSTRING(portnum)) {
d815 1
a815 1
		if (! dirchange) {
d822 1
a822 1
			if (! EMPTYSTRING(dir) &&
d825 1
a825 1
			if (! EMPTYSTRING(file) &&
d831 1
a831 1
		if (! EMPTYSTRING(dir) && !dirhasglob) {
d836 1
a836 1
			if (! dirchange) {
d886 1
a886 1
urldecode(str) 
d893 1
a893 1
        if (str == NULL) 
@


1.40
log
@http redirect support; adapted from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.38 2002/02/16 21:27:46 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.38 2002/02/16 21:27:46 millert Exp $";
d313 3
a315 2
			NULL, 0, NI_NUMERICHOST);
		fprintf(ttyout, "Trying %s...\n", pbuf);
@


1.39
log
@-4 and -6 options; kanai@@big.or.jp; itojun ok
@
text
@d69 1
d106 1
a106 1
	int i, isftpurl, isfileurl;
d109 1
a109 1
	char c, *cp, *ep, *portnum, *path, buf[4096];
d112 1
a112 1
	char *line, *host, *port;
d118 2
d123 2
d127 2
d234 3
d240 1
a240 1
		while ((len = read(s, buf, sizeof(buf))) > 0) {
d273 2
a274 7
		close(s);
		if (out != fileno(stdout))
			close(out);
		if (proxy)
			free(proxy);
		free(line);
		return (0);
a301 2
		char pbuf[NI_MAXSERV];

d312 1
a312 1
		getnameinfo(res->ai_addr, res->ai_addrlen, buf, sizeof(buf),
d314 1
a314 1
		fprintf(ttyout, "Trying %s...\n", buf);
d347 2
d350 1
a350 2
	 * Construct and send the request.  We're expecting a return
	 * status of "200". Proxy requests don't want leading /.
d360 1
a360 1
		snprintf(buf, sizeof(buf), "GET %s HTTP/1.0\r\n%s\r\n\r\n", path, HTTP_USER_AGENT);
d379 1
a379 2
				snprintf(buf, sizeof(buf),
				    "GET /%s HTTP/1.0\r\nHost: [%s]:%s\r\n%s\r\n\r\n", 
d382 1
a382 2
				snprintf(buf, sizeof(buf),
				    "GET /%s HTTP/1.0\r\nHost: [%s]\r\n%s\r\n\r\n", 
d387 1
a387 2
				snprintf(buf, sizeof(buf),
				    "GET /%s HTTP/1.0\r\nHost: %s:%s\r\n%s\r\n\r\n", 
d390 1
a390 2
				snprintf(buf, sizeof(buf),
				    "GET /%s HTTP/1.0\r\nHost: %s\r\n%s\r\n\r\n", 
d394 1
a394 4
	len = strlen(buf);
	if (debug)
		fprintf(ttyout, "Sending request:\n%s", buf);
	if (write(s, buf, len) < len) {
d398 4
a401 9
	memset(buf, 0, sizeof(buf));
	for (cp = buf; cp < buf + sizeof(buf); ) {
		if (read(s, cp, 1) != 1)
			goto improper;
		if (*cp == '\r')
			continue;
		if (*cp == '\n')
			break;
		cp++;
d403 6
a408 1
	buf[sizeof(buf) - 1] = '\0';		/* sanity */
d414 3
a416 1
	if (strncmp(cp, "200", 3)) {
d424 11
a434 8
	memset(buf, 0, sizeof(buf));
	c = '\0';
	for (cp = buf; cp < buf + sizeof(buf); ) {
		if (read(s, cp, 1) != 1)
			goto improper;
		if (*cp == '\r')
			continue;
		if (*cp == '\n' && c == '\n')
d436 2
a437 4
		c = *cp;
		cp++;
	}
	buf[sizeof(buf) - 1] = '\0';		/* sanity */
d439 2
a440 1
	/* Look for the "Content-length: " header.  */
d442 23
a464 4
	for (cp = buf; *cp != '\0'; cp++) {
		if (tolower(*cp) == 'c' &&
		    strncasecmp(cp, CONTENTLEN, sizeof(CONTENTLEN) - 1) == 0)
			break;
d466 1
a466 12
	if (*cp != '\0') {
		cp += sizeof(CONTENTLEN) - 1;
		ep = strchr(cp, '\n');
		if (ep == NULL)
			goto improper;
		else
			*ep = '\0';
		filesize = strtol(cp, &ep, 10);
		if (filesize < 1 || *ep != '\0')
			goto improper;
	} else
		filesize = -1;
d492 2
d495 1
a495 1
	while ((len = read(s, buf, sizeof(buf))) > 0) {
d534 2
a535 7
	close(s);
	if (out != fileno(stdout))
		close(out);
	if (proxy)
		free(proxy);
	free(line);
	return (0);
d546 3
a548 1
	if (s != -1)
d550 2
d555 1
a555 1
	return (-1);
d794 1
a794 1
			    ((connected == 1) && !login(host, user, pass))) {
@


1.38
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.37 2001/11/14 07:59:28 heko Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.37 2001/11/14 07:59:28 heko Exp $";
d288 1
a288 1
	hints.ai_family = PF_UNSPEC;
@


1.37
log
@o Don't accept URLs with user:pass@@ and an extra unencoded @@.
  @@ should be encoded as %40 for passwords and usernames. @@ in
  the pathname portion of the URL is ok.
o decode usernames and passwords as per FTP URL specification.
spotted by krw@@, input from krw@@ and fgs@@
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.36 2001/10/27 10:31:27 heko Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.36 2001/10/27 10:31:27 heko Exp $";
d72 5
a76 5
static int	url_get __P((const char *, const char *, const char *));
void		aborthttp __P((int));
void		abortfile __P((int));
char    	hextochar __P((const char *));
char   		*urldecode __P((const char *));
@


1.36
log
@Send User-Agent: OpenBSD ftp to WWW servers and proxies.

``User agents SHOULD include this field with requests'', from RFC 2616:
http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43

Patch from and problem reported by Diana Eichert <deicher@@sandia.gov>
when using proxies with specific browser requirements. Tested by me with
the ports mirror-maker makefile / fetch-all script (with and without a
proxy).

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.35 2001/10/03 18:49:39 heko Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.35 2001/10/03 18:49:39 heko Exp $";
d75 2
a76 1

d87 3
d651 1
a651 1
			char *passend, *userend;
d664 1
a665 1
			userend = strchr(host, ':');
d672 6
d685 2
d867 55
@


1.35
log
@o Only send port number in the HTTP request 'Host: ' specification
  if it is non-default (i.e., != 80) to circumvent bugs in
  some broken HTTP servers. naddy@@ got hit by this with a port,
  lebel@@ spotted the problem.
o Print the HTTP request if debug (the ``-d'' flag) is specified.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.34 2001/06/23 22:48:44 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.34 2001/06/23 22:48:44 millert Exp $";
d352 1
a352 1
		snprintf(buf, sizeof(buf), "GET %s HTTP/1.0\r\n\r\n", path);
d372 2
a373 2
				    "GET /%s HTTP/1.0\r\nHost: [%s]:%s\r\n\r\n", 
				    path, h, port);
d376 2
a377 2
				    "GET /%s HTTP/1.0\r\nHost: [%s]\r\n\r\n", 
				    path, h);
d382 2
a383 2
				    "GET /%s HTTP/1.0\r\nHost: %s:%s\r\n\r\n", 
				    path, host, port);
d386 2
a387 2
				    "GET /%s HTTP/1.0\r\nHost: %s\r\n\r\n", 
				    path, host);
@


1.34
log
@remove evil #ifdef __GNUC__ garbage to avoid longjmp clobbering and use volatile instead
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.33 2000/06/30 16:00:15 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.33 2000/06/30 16:00:15 millert Exp $";
d365 13
a377 3
			snprintf(buf, sizeof(buf),
			    "GET /%s HTTP/1.0\r\nHost: [%s]%s%s\r\n\r\n",
			    path, h, port ? ":" : "", port ? port : "");
d380 8
a387 3
			snprintf(buf, sizeof(buf),
			    "GET /%s HTTP/1.0\r\nHost: %s%s%s\r\n\r\n",
			    path, host, port ? ":" : "", port ? port : "");
d391 2
@


1.33
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.32 2000/05/25 16:09:26 itojun Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.32 2000/05/25 16:09:26 itojun Exp $";
d101 2
a102 2
	int i, out, isftpurl, isfileurl;
	volatile int s;
d106 3
a108 2
	const char *savefile;
	char *line, *proxy, *host, *port;
a117 6

#ifdef __GNUC__				/* XXX: to shut up gcc warnings */
	(void)&out;
	(void)&proxy;
	(void)&savefile;
#endif
@


1.32
log
@do not attach incorrect Host: directive if we are using proxy.
Host: directive must be based on original URI, not the proxy address.
see RFC2616.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.31 2000/05/15 16:07:04 itojun Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.31 2000/05/15 16:07:04 itojun Exp $";
d341 1
a341 1
		warn(cause);
@


1.31
log
@parse RFC2732 ftp URL (ftp://[::1]:21/readme)
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.30 2000/05/03 19:50:41 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.30 2000/05/03 19:50:41 deraadt Exp $";
d349 6
a354 4
	if (verbose) {
		if (!proxy)
			fprintf(ttyout, "Requesting %s\n", origline);
		else
d357 1
a357 6
	}
	if (strchr(host, ':')) {
		snprintf(buf, sizeof(buf),
		    "GET %s%s HTTP/1.0\r\nHost: [%s]%s%s\r\n\r\n",
		    proxy ? "" : "/", path, host,
		    port ? ":" : "", port ? port : "");
d359 20
a378 4
		snprintf(buf, sizeof(buf),
		    "GET %s%s HTTP/1.0\r\nHost: %s%s%s\r\n\r\n",
		    proxy ? "" : "/", path, host,
		    port ? ":" : "", port ? port : "");
@


1.30
log
@if no /etc/services file, use defaults. found by millert, fixed by itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.29 2000/05/02 00:54:53 itojun Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.29 2000/05/02 00:54:53 itojun Exp $";
d622 2
d633 12
a644 6
			pass = strpbrk(host, ":@@/");
			if (pass == NULL || *pass == '/') {
				pass = NULL;
				goto parsed_url;
			}
			if (pass == host || *pass == '@@') {
d646 4
a649 3
				warnx("Invalid URL: %s", argv[argpos]);
				rval = argpos + 1;
				continue;
d651 13
a663 22
			*pass++ = '\0';
			/* XXX - assumes no '@@' in pathname */
			if ((cp = strrchr(pass, '@@')) == NULL)
				cp = strpbrk(pass, ":@@/");
			if (cp == NULL || *cp == '/') {
				portnum = pass;
				pass = NULL;
				goto parsed_url;
			}
			if (EMPTYSTRING(cp) || *cp == ':')
				goto bad_ftp_url;
			*cp++ = '\0';
			user = host;
			if (EMPTYSTRING(user))
				goto bad_ftp_url;
			host = cp;

#if 0
			/* look for IPv6 address URL */
			if (host == '[' && (cp = strrchr(host, ']'))) {
				host++;
				*cp++ = '\0';
d666 2
d669 22
a690 4
		
			portnum = strrchr(cp, ':');
			if (portnum != NULL)
				*portnum++ = '\0';
a693 1
parsed_url:
@


1.30.2.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.30 2000/05/03 19:50:41 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.30 2000/05/03 19:50:41 deraadt Exp $";
d341 1
a341 1
		warn("%s", cause);
@


1.29
log
@always attach port in numeric, for HTTP Host: header.
from: chris and mickey
XXX Host: header is specified in HTTP/1.1, not HTTP/1.0.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.28 2000/04/24 03:30:16 itojun Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.28 2000/04/24 03:30:16 itojun Exp $";
d293 10
@


1.28
log
@support RFC2732 IPv6 address literal URLs (http://[::1]:80/index.html).
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.27 2000/01/09 05:14:38 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.27 2000/01/09 05:14:38 millert Exp $";
d105 1
d320 7
d348 3
a350 2
		    "GET %s%s HTTP/1.0\r\nHost: [%s]:%s\r\n\r\n",
		    proxy ? "" : "/", path, host, port);
d353 3
a355 2
		    "GET %s%s HTTP/1.0\r\nHost: %s:%s\r\n\r\n",
		    proxy ? "" : "/", path, host, port);
@


1.27
log
@Make 'ftp host:/path/to/file' work again.  This got broken during IPV6
integration.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.26 2000/01/04 17:15:12 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.26 2000/01/04 17:15:12 deraadt Exp $";
d107 1
d272 8
a279 1
	portnum = strchr(host, ':');			/* find portnum */
d338 9
a346 2
	snprintf(buf, sizeof(buf), "GET %s%s HTTP/1.0\r\nHost: %s\r\n\r\n",
	    proxy ? "" : "/", path, host);
@


1.26
log
@fix file:// URL support; broken by KAME support
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.25 1999/12/08 12:57:06 itojun Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.25 1999/12/08 12:57:06 itojun Exp $";
d782 1
d785 4
a788 3
	    strncasecmp(p, FILE_URL, sizeof(FILE_URL) - 1) == 0)
		return 1;
	return 0;
@


1.25
log
@ftp(1) from KAME, should be good for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.24 1999/02/09 03:43:48 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.24 1999/02/09 03:43:48 deraadt Exp $";
d782 3
a784 2
	if (strncasecmp(p, FTP_URL, sizeof(FTP_URL) - 1) == 0
	 || strncasecmp(p, HTTP_URL, sizeof(HTTP_URL) - 1) == 0) {
a785 1
	}
@


1.24
log
@if we read less than Content-Length, whine and error
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.23 1998/09/30 07:49:36 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.23 1998/09/30 07:49:36 deraadt Exp $";
d99 2
a100 1
	struct sockaddr_in sin;
a101 1
	in_port_t port;
d106 1
a106 1
	char *line, *proxy, *host;
d109 1
a109 1
	struct hostent *hp = NULL;
d279 8
a286 19
	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;

	if (isdigit(host[0])) {
		if (inet_aton(host, &sin.sin_addr) == 0) {
			warnx("Invalid IP address: %s", host);
			goto cleanup_url_get;
		}
	} else {
		hp = gethostbyname(host);
		if (hp == NULL) {
			warnx("%s: %s", host, hstrerror(h_errno));
			goto cleanup_url_get;
		}
		if (hp->h_addrtype != AF_INET) {
			warnx("%s: not an Internet address?", host);
			goto cleanup_url_get;
		}
		memcpy(&sin.sin_addr, hp->h_addr, (size_t)hp->h_length);
d289 5
a293 3
	if (! EMPTYSTRING(portnum)) {
		char *ep;
		long nport;
d295 4
a298 4
		nport = strtol(portnum, &ep, 10);
		if (nport < 1 || nport > USHRT_MAX || *ep != '\0') {
			warnx("Invalid port: %s", portnum);
			goto cleanup_url_get;
a299 10
		port = htons((in_port_t)nport);
	} else
		port = httpport;
	sin.sin_port = port;

	s = socket(AF_INET, SOCK_STREAM, 0);
	if (s == -1) {
		warn("Can't create socket");
		goto cleanup_url_get;
	}
d301 7
a307 21
	while (connect(s, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
		if (errno == EINTR)
			continue;
		if (hp && hp->h_addr_list[1]) {
			int oerrno = errno;
			char *ia;

			ia = inet_ntoa(sin.sin_addr);
			errno = oerrno;
			warn("connect to address %s", ia);
			hp->h_addr_list++;
			memcpy(&sin.sin_addr, hp->h_addr_list[0],
			    (size_t)hp->h_length);
			fprintf(ttyout, "Trying %s...\n",
			    inet_ntoa(sin.sin_addr));
			(void)close(s);
			s = socket(AF_INET, SOCK_STREAM, 0);
			if (s < 0) {
				warn("socket");
				goto cleanup_url_get;
			}
d310 6
a315 1
		warn("connect");
d623 11
a633 1
			portnum = strchr(host, ':');
d776 11
@


1.23
log
@something was too verboase in http fetch mode
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.22 1998/09/28 13:38:22 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.22 1998/09/28 13:38:22 deraadt Exp $";
d477 6
@


1.22
log
@first cut at file:/ URL support
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.21 1998/09/11 08:04:24 marc Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.21 1998/09/11 08:04:24 marc Exp $";
d351 7
a357 4
	if (!proxy)
		fprintf(ttyout, "Requesting %s\n", origline);
	else
		fprintf(ttyout, "Requesting %s (via %s)\n", origline, proxyenv);
@


1.21
log
@don't display Retrieving... message unless verbose output desired
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.20 1998/05/13 10:46:12 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.20 1998/05/13 10:46:12 deraadt Exp $";
d51 1
d74 1
d79 1
d100 1
a100 1
	int i, out, isftpurl;
d114 1
d130 3
d136 17
a152 13
	path = strchr(host, '/');		/* find path */
	if (EMPTYSTRING(path)) {
		if (isftpurl)
			goto noftpautologin;
		warnx("Invalid URL (no `/' after host): %s", origline);
		goto cleanup_url_get;
	}
	*path++ = '\0';
	if (EMPTYSTRING(path)) {
		if (isftpurl)
			goto noftpautologin;
		warnx("Invalid URL (no file after host): %s", origline);
		goto cleanup_url_get;
d190 81
d518 14
d592 2
a593 1
		if (strncasecmp(line, HTTP_URL, sizeof(HTTP_URL) - 1) == 0) {
@


1.20
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.19 1998/05/13 10:42:38 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.19 1998/05/13 10:42:38 deraadt Exp $";
d642 1
a642 1
		if (!verbose)
@


1.19
log
@try other h_addr_list addresses when connecting, and handle EINTR
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.18 1998/03/26 03:17:08 marc Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.18 1998/03/26 03:17:08 marc Exp $";
a251 7
		goto cleanup_url_get;
	}

	while (connect(s, (struct sockaddr *)&sin, sizeof(sin)) == -1) {
		if (errno == EINTR)
			continue;
		warn("Can't connect to %s", host);
@


1.18
log
@pass host name with GET request so servers hosting multiple virtual
hosts know to which host the given path applies
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.17 1998/02/17 23:22:54 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.17 1998/02/17 23:22:54 millert Exp $";
d64 1
d106 1
a195 2
		struct hostent *hp;

d228 30
a257 1
	if (connect(s, (struct sockaddr *)&sin, sizeof(sin)) == -1) {
@


1.17
log
@Add a new option "-o filename" for autofetch mode.  Allows use of
"-" to mean stdout.  This replaces the old (unreliable) hueristic
of checking if stdout is a tty and if not make the output go to stdout.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.16 1997/09/11 01:55:15 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.16 1997/09/11 01:55:15 millert Exp $";
d241 2
a242 2
	snprintf(buf, sizeof(buf), "GET %s%s HTTP/1.0\r\n\r\n",
	    proxy ? "" : "/", path);
@


1.16
log
@- Move `parsed_url' label such that the next statement after the label is
  not an "else" (which some strict compilers reject).

- If getlogin() fails fall back on getpwuid(getuid()).
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.15 1997/09/04 04:37:15 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.15 1997/09/04 04:37:15 millert Exp $";
d59 1
d70 1
a70 1
static int	url_get __P((const char *, const char *, int));
d90 1
a90 1
url_get(origline, proxyenv, fd)
d93 1
a93 1
	int fd;
d142 2
a143 3
	savefile = strrchr(path, '/');			/* find savefile */
	if (savefile != NULL)
		savefile++;
d145 2
a146 1
		savefile = path;
d306 2
a307 2
	/* Open the output file. */
	if (fd == -1) {
d314 1
a314 1
		out = fd;
d365 1
a365 1
	if (fd != -1)
d418 1
a418 1
auto_fetch(argc, argv, fd)
d421 1
a421 1
	int fd;
d465 1
a465 1
			if (url_get(line, httpproxy, fd) == -1)
d478 1
a478 1
				if (url_get(line, ftpproxy, fd) == -1)
d642 3
a644 2
			if (fd != -1) {
				xargv[2] = "-";
a646 1
			xargv[3] = NULL;
@


1.15
log
@Updtaes from NetBSD (lukem)
    bugs fixed:
      * don't interpret '-' or '|' when a local filename is determined from
        the remote name (i.e, in mget, and in get with only one argument).
        This is implemented using an extra argument to recvrequest().
        Fixes a major security hole.
      * clean up memory leak when using globulize()
      * clean up a couple of comments
      * fix wording in TNF copyright

    features added:
      * support for TIS fwtk gate-ftp servers:
        * read defaults from $FTPSERVER && $FTPSERVERPORT
        * start in gate-ftp mode if invoked as 'gate-ftp'
        * toggle or set with 'gate [host [port]]'

Other changes:
    * use symbolic flags in access(2)
    * Use USHRT_MAX, not 0xffff
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.14 1997/07/25 21:56:20 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.14 1997/07/25 21:56:20 millert Exp $";
a514 1
parsed_url:
d518 1
@


1.14
log
@Updates from NetBSD (lukem) include -Wall cleanup.
More -W* cleanup and in_port_t usage by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: fetch.c,v 1.13 1997/07/24 14:22:21 deraadt Exp $	*/
/*	$NetBSD: fetch.c,v 1.13 1997/07/20 12:49:26 lukem Exp $	*/
d30 2
a31 2
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.13 1997/07/24 14:22:21 deraadt Exp $";
d212 1
a212 1
		if (nport < 1 || nport > 0xffff || *ep != '\0') {
@


1.13
log
@no content-length is OK; cato@@ulysses.df.lth.se
@
text
@d1 2
a2 2
/*	$OpenBSD: fetch.c,v 1.12 1997/05/19 05:36:56 millert Exp $	*/
/*	$NetBSD: fetch.c,v 1.8 1997/04/21 18:45:47 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.12 1997/05/19 05:36:56 millert Exp $";
d69 4
d88 4
a91 4
int
url_get(line, proxyenv, fd)
	char *line;
	char *proxyenv;
d95 8
a102 5
	int i, out, port, s;
	size_t buflen, len;
	char c, *cp, *cp2, *savefile, *portnum, *path, buf[4096];
	char *proxy, *host;
	sig_t oldintr;
d107 1
d109 9
d120 1
a120 1
	else if (strncasecmp(line, FTP_URL, sizeof(FTP_URL) - 1) == 0)
d122 3
a124 2
	else
		errx(1, "url_get: invalid url '%s'", line);
d127 4
a130 1
	if (EMPTYSTRING(path))
d132 1
d134 4
a137 1
	if (EMPTYSTRING(path))
d139 1
d146 4
a149 1
	if (EMPTYSTRING(savefile))
d151 1
d156 1
a156 1
			errx(1, "Can't allocate memory for proxy url.");
d162 1
a162 1
			warnx("Malformed proxy URL: %s", proxy);
d165 2
a166 1
		if (EMPTYSTRING(host))
d168 1
d204 1
a204 1
		memcpy(&sin.sin_addr, hp->h_addr, hp->h_length);
d208 5
a212 2
		port = atoi(portnum);
		if (port < 1 || (port & 0xffff) != port) {
d216 1
a216 1
		port = htons(port);
d223 1
a223 1
		warnx("Can't create socket");
d237 1
a237 2
		fprintf(ttyout, "Requesting %s:%d/%s\n", line, ntohs(port),
		    path);
d239 1
a239 1
		fprintf(ttyout, "Requesting %s (via %s)\n", line, proxyenv);
d242 3
a244 3
	buflen = strlen(buf);
	if (write(s, buf, buflen) < buflen) {
		warn("write");
d248 1
a248 1
	for (i = 0, buflen = sizeof(buf), cp = buf; i < buflen; cp++, i++) {
d255 1
d257 1
a257 1
	buf[buflen - 1] = '\0';		/* sanity */
d273 1
a273 1
	for (i = 0, buflen = sizeof(buf), cp = buf; i < buflen; cp++, i++) {
d281 1
d283 1
a283 1
	buf[buflen - 1] = '\0';		/* sanity */
d294 2
a295 2
		cp2 = strchr(cp, '\n');
		if (cp2 == NULL)
d298 3
a300 3
			*cp2 = '\0';
		filesize = atoi(cp);
		if (filesize < 1)
d368 1
d371 5
d378 1
d384 1
d427 2
a428 1
	int rval, xargc, argpos;
d430 1
a430 1
	char rempath[MAXPATHLEN], fakedev[MAXPATHLEN];
d492 1
a492 1
				warnx("Bad ftp URL: %s", argv[argpos]);
d572 1
a572 1
			    ((connected == 1) && !login(host, user, pass)) ) {
@


1.12
log
@Make ftp ftp://anonymous:root@@your.dom.ain@@ftp.our.place.foo/pub/OpenBSD/
work.  Needed for install scripts to work.  I didn't run into this as
I was installing from a non-anonymous account.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.11 1997/04/28 21:10:06 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.11 1997/04/28 21:10:06 millert Exp $";
d206 1
a206 1
	snprintf(buf, sizeof(buf), "GET %s%s HTTP/1.0\n\n",
d256 12
a267 11
	if (*cp == '\0')
		goto improper;
	cp += sizeof(CONTENTLEN) - 1;
	cp2 = strchr(cp, '\n');
	if (cp2 == NULL)
		goto improper;
	else
		*cp2 = '\0';
	filesize = atoi(cp);
	if (filesize < 1)
		goto improper;
@


1.11
log
@From NetBSD (lukem):
  Cleanup parser of ftp://[user:pass@@]host[:port]/[dir/][file
  Should be more robust now.  Fixes NetBSD PR #3520.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.10 1997/04/23 20:33:06 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.10 1997/04/23 20:33:06 deraadt Exp $";
d451 3
a453 1
			cp = strpbrk(pass, ":@@/");
@


1.10
log
@allow "ftp -aV ftp://host/foo.tar.gz | tar xvfpz -" to work
@
text
@d1 2
a2 2
/*	$OpenBSD: fetch.c,v 1.9 1997/04/18 18:56:49 millert Exp $	*/
/*	$NetBSD: fetch.c,v 1.6 1997/04/14 09:09:19 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.9 1997/04/18 18:56:49 millert Exp $";
d439 1
a439 2
			user = host;
			pass = strpbrk(user, ":@@/");
d441 1
a441 1
				user = pass = NULL;
d444 2
a445 1
			if (*pass == '@@') {
d454 1
a454 1
				user = pass = NULL;
d457 2
a458 5
			if (*cp == ':') {
				warnx("Bad ftp URL: %s", argv[argpos]);
				rval = argpos + 1;
				continue;
			}
d460 3
@


1.9
log
@Fix problem when fetching files with -a.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.8 1997/04/16 05:02:48 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.8 1997/04/16 05:02:48 millert Exp $";
d85 1
a85 1
url_get(line, proxyenv)
d88 1
d149 1
a149 1
		printf("host %s, port %s, path %s, save as %s.\n",
d202 2
a203 1
		printf("Requesting %s:%d/%s\n", line, ntohs(port), path);
d205 1
a205 1
		printf("Requesting %s (via %s)\n", line, proxyenv);
d269 8
a276 5
	out = open(savefile, O_CREAT | O_WRONLY | O_TRUNC, 0666);
	if (out < 0) {
		warn("Can't open %s", savefile);
		goto cleanup_url_get;
	}
d305 1
a305 1
				(void)putchar('#');
d308 1
a308 1
			(void)fflush(stdout);
d313 3
a315 3
			(void)putchar('#');
		(void)putchar('\n');
		(void)fflush(stdout);
d323 1
a323 1
		puts("Successfully retrieved file.");
d327 2
a328 1
	close(out);
d352 2
a353 2
	puts("\nhttp fetch aborted.");
	(void)fflush(stdout);
d372 1
a372 1
auto_fetch(argc, argv)
d375 1
d384 1
a384 1
	char rempath[MAXPATHLEN];
d418 1
a418 1
			if (url_get(line, httpproxy) == -1)
d431 1
a431 1
				if (url_get(line, ftpproxy) == -1)
d497 1
a497 1
			printf("user %s:%s host %s port %s dir %s file %s\n",
d572 1
a572 1
			printf("Retrieving %s/%s\n", dir ? dir : "", file);
d580 1
d590 1
a590 1
			mget(2, xargv);
d592 8
a599 2
		} else
			get(2, xargv);
@


1.8
log
@Sync with NetBSD (lukem):
 * differentiate between being connected, and being logged in
 * cleanup some text messages
 * support username & password ftp URLs (ftp://user:pass@@host/) in non-proxy
   situations; assume proxy supports it for proxy situations.
 * cd to / before performing any autofetch transfers
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.7 1997/04/14 00:48:44 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.7 1997/04/14 00:48:44 millert Exp $";
d247 1
a247 3
	/*
	 * Look for the "Content-length: " header.
	 */
d434 2
a435 1
			if (pass == NULL || *pass == '/')
d437 1
d470 1
a470 1
		 * If cp is NULL, the file wasn't specified
@


1.7
log
@URL specifiers are case insensitive.  Noticed by Theo.
@
text
@d1 2
a2 2
/*	$OpenBSD: fetch.c,v 1.6 1997/04/10 00:17:08 millert Exp $	*/
/*	$NetBSD: fetch.c,v 1.5 1997/04/05 03:27:36 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.6 1997/04/10 00:17:08 millert Exp $";
d131 1
a131 1
			warnx("Malformed proxy url: %s", proxy);
d156 1
a156 1
			warnx("invalid IP address: %s", host);
d177 1
a177 1
			warnx("invalid port: %s", portnum);
d330 1
a330 1
	warnx("improper response from %s", host);
d375 1
d400 1
a400 1
		host = dir = file = portnum = NULL;
d431 1
a431 1
			cp = strchr(host, '/');
d433 24
a456 1
			/* Look for a port number after the host name. */
d460 4
a463 2
		} else				/* classic style `host:file' */
			cp = strchr(host, ':');
d473 2
a474 2
		if (cp != NULL)
			*cp++ = '\0';
a478 1
		dir = cp;
d480 1
a480 1
			cp = strrchr(cp, '/');
d490 2
a491 2
			printf("host '%s', dir '%s', file '%s'\n",
			    host, dir, file);
d497 2
d506 1
a506 1
			if (portnum != NULL) {
d511 3
d515 5
a519 2
			if (connected == 0) {
				warnx("Can't connect to host `%s'", host);
d527 8
a534 10
		else	/* already have connection, cd back to '/' */
		{
			xargv[0] = "cd";
			xargv[1] = "/";
			xargv[2] = NULL;
			cd(2, xargv);
			if (! dirchange) {
				rval = argpos + 1;
				continue;
			}
@


1.6
log
@Sync with NetBSD (lukem)
    * support $ftp_proxy for ftp:// transfers [bin/3245]
    * add "more" & "less" as synonyms for "page"
    * move editline setup code into controlediting(), and call appropriately.
      only setup setup terminal if going into interactive mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.5 1997/03/21 20:59:29 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.5 1997/03/21 20:59:29 millert Exp $";
d100 1
a100 1
	if (strncmp(line, HTTP_URL, sizeof(HTTP_URL) - 1) == 0)
d102 1
a102 1
	else if (strncmp(line, FTP_URL, sizeof(FTP_URL) - 1) == 0)
d126 1
a126 1
		if (strncmp(proxy, HTTP_URL, sizeof(HTTP_URL) - 1) == 0)
d128 1
a128 1
		else if (strncmp(proxy, FTP_URL, sizeof(FTP_URL) - 1) == 0)
d411 1
a411 1
		if (strncmp(line, HTTP_URL, sizeof(HTTP_URL) - 1) == 0) {
d423 1
a423 1
		if (strncmp(line, FTP_URL, sizeof(FTP_URL) - 1) == 0) {
@


1.5
log
@Add in recent NetBSD changes we didn't already have:
    Always compile complete.c but ifdef out the bits if -DSMALL (christos)
    reset interactive mode correctly in auto_fetch() mget mode (lukem)
@
text
@d1 2
a2 2
/*	$OpenBSD: fetch.c,v 1.4 1997/03/14 04:32:14 millert Exp $	*/
/*	$NetBSD: fetch.c,v 1.4 1997/03/16 14:24:18 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.4 1997/03/14 04:32:14 millert Exp $";
d71 1
d80 1
a80 1
 * Retrieve an http:// URL, via a proxy if necessary.
d85 1
a85 1
http_get(line)
d87 1
d93 1
a93 1
	char *proxyenv, *proxy, *host;
d100 7
a106 1
	host = line + sizeof(HTTP_URL) - 1;
d109 1
a109 1
		goto cleanup_http_get;
d112 1
a112 1
		goto cleanup_http_get;
d120 1
a120 1
		goto cleanup_http_get;
a121 1
	proxyenv = getenv(HTTP_PROXY);
a122 4
		if (strncmp(proxyenv, HTTP_URL, sizeof(HTTP_URL) - 1) != 0) {
			warnx("Malformed proxy url: %s", proxyenv);
			goto cleanup_http_get;
		}
d126 8
a133 1
		host = proxy + sizeof(HTTP_URL) - 1;
d135 1
a135 1
			goto cleanup_http_get;
d157 1
a157 1
			goto cleanup_http_get;
d165 1
a165 1
			goto cleanup_http_get;
d169 1
a169 1
			goto cleanup_http_get;
d178 1
a178 1
			goto cleanup_http_get;
d188 1
a188 1
		goto cleanup_http_get;
d193 1
a193 1
		goto cleanup_http_get;
d209 1
a209 1
		goto cleanup_http_get;
d228 1
a228 1
		goto cleanup_http_get;
d272 1
a272 1
		goto cleanup_http_get;
d280 1
a280 1
		goto cleanup_http_get;
d295 1
a295 1
				goto cleanup_http_get;
d316 1
a316 1
		goto cleanup_http_get;
d331 1
a331 1
cleanup_http_get:
d375 1
d390 3
d412 1
a412 1
			if (http_get(line) == -1)
d418 3
a420 1
		 * Try FTP URL-style arguments next, then host:file.
d424 5
@


1.4
log
@Sync with NetBSD and fix "get foo.txt /dev/tty" wrt progress meter
and setting times.
@
text
@d1 2
a2 2
/*	$OpenBSD: fetch.c,v 1.3 1997/02/05 04:55:16 millert Exp $	*/
/*	$NetBSD: fetch.c,v 1.3 1997/03/13 06:23:15 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.3 1997/02/05 04:55:16 millert Exp $";
d451 1
a451 1
			strcpy(lasthost, host);
d531 1
a531 1
			interactive = 1;
@


1.3
log
@Include signal.h where reasonable and make signal handlers match
what signal(3)'s prototype says (and cast when not).
Also change MAXFOO+1 -> MAXFOO since MAXFOO includes the NULL.
Support $TMPDIR and use utime(3) not utimes(2) for portability's sake.
Don't spew "Passive mode enabled/disabled" unless verbose (this means
togglevar() needs to watch for a NULL 'message').
@
text
@d1 2
a2 2
/*	$OpenBSD: fetch.c,v 1.2 1997/02/03 01:05:37 millert Exp $	*/
/*	$NetBSD: fetch.c,v 1.2 1997/02/01 10:45:00 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.2 1997/02/03 01:05:37 millert Exp $";
d205 2
d229 2
d338 1
a338 1
	puts("\nhttp fetch aborted");
d366 2
d485 10
d496 1
a496 1
		if (! EMPTYSTRING(dir)) {
d515 6
a520 1
		/* Fetch the file. */
d524 10
a533 1
		get(2, xargv);
d535 1
a535 1
		if ((code / 100) != COMPLETE)	/* XXX: is this valid? */
@


1.2
log
@Add back ``-r'' option and fix strncpy() usage and other nits because
I'm anal.  Closer to KNF now.
@
text
@d1 1
a1 1
/*	$OpenBSD: fetch.c,v 1.2 1997/02/01 10:45:00 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: fetch.c,v 1.2 1997/02/01 10:45:00 lukem Exp $";
d61 1
d329 2
a330 1
aborthttp()
d370 2
a371 2
	(void)signal(SIGINT, intr);
	(void)signal(SIGPIPE, lostpeer);
@


1.1
log
@Sync with NetBSD
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: fetch.c,v 1.2 1997/02/01 10:45:00 lukem Exp $";
d264 1
a264 1
			(void) signal(SIGINT, oldintr);
d287 1
a287 1
				(void) putchar('#');
d290 1
a290 1
			(void) fflush(stdout);
d295 3
a297 3
			(void) putchar('#');
		(void) putchar('\n');
		(void) fflush(stdout);
d305 2
a306 2
		printf("Successfully retrieved file.\n");
	(void) signal(SIGINT, oldintr);
d312 1
a312 1
	return(0);
d321 1
a321 1
	return(-1);
d332 2
a333 2
	printf("\nhttp fetch aborted\n");
	(void) fflush(stdout);
d342 1
a342 1
 * If path has a trailing "/", then return(-1);
d366 1
a366 1
		return(argpos + 1);
d368 2
a369 2
	(void) signal(SIGINT, intr);
	(void) signal(SIGPIPE, lostpeer);
@
