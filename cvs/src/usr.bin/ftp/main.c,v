head	1.119;
access;
symbols
	OPENBSD_6_1:1.119.0.4
	OPENBSD_6_1_BASE:1.119
	OPENBSD_6_0:1.109.0.2
	OPENBSD_6_0_BASE:1.109
	OPENBSD_5_9:1.105.0.2
	OPENBSD_5_9_BASE:1.105
	OPENBSD_5_8:1.102.0.6
	OPENBSD_5_8_BASE:1.102
	OPENBSD_5_7:1.102.0.2
	OPENBSD_5_7_BASE:1.102
	OPENBSD_5_6:1.92.0.4
	OPENBSD_5_6_BASE:1.92
	OPENBSD_5_5:1.87.0.2
	OPENBSD_5_5_BASE:1.87
	OPENBSD_5_4:1.85.0.4
	OPENBSD_5_4_BASE:1.85
	OPENBSD_5_3:1.85.0.2
	OPENBSD_5_3_BASE:1.85
	OPENBSD_5_2:1.83.0.2
	OPENBSD_5_2_BASE:1.83
	OPENBSD_5_1_BASE:1.81
	OPENBSD_5_1:1.81.0.8
	OPENBSD_5_0:1.81.0.6
	OPENBSD_5_0_BASE:1.81
	OPENBSD_4_9:1.81.0.4
	OPENBSD_4_9_BASE:1.81
	OPENBSD_4_8:1.81.0.2
	OPENBSD_4_8_BASE:1.81
	OPENBSD_4_7:1.80.0.2
	OPENBSD_4_7_BASE:1.80
	OPENBSD_4_6:1.79.0.4
	OPENBSD_4_6_BASE:1.79
	OPENBSD_4_5:1.71.0.2
	OPENBSD_4_5_BASE:1.71
	OPENBSD_4_4:1.70.0.2
	OPENBSD_4_4_BASE:1.70
	OPENBSD_4_3:1.68.0.2
	OPENBSD_4_3_BASE:1.68
	OPENBSD_4_2:1.65.0.2
	OPENBSD_4_2_BASE:1.65
	OPENBSD_4_1:1.61.0.4
	OPENBSD_4_1_BASE:1.61
	OPENBSD_4_0:1.61.0.2
	OPENBSD_4_0_BASE:1.61
	OPENBSD_3_9:1.59.0.2
	OPENBSD_3_9_BASE:1.59
	OPENBSD_3_8:1.58.0.6
	OPENBSD_3_8_BASE:1.58
	OPENBSD_3_7:1.58.0.4
	OPENBSD_3_7_BASE:1.58
	OPENBSD_3_6:1.58.0.2
	OPENBSD_3_6_BASE:1.58
	OPENBSD_3_5:1.57.0.2
	OPENBSD_3_5_BASE:1.57
	OPENBSD_3_4:1.54.0.2
	OPENBSD_3_4_BASE:1.54
	OPENBSD_3_3:1.50.0.4
	OPENBSD_3_3_BASE:1.50
	OPENBSD_3_2:1.50.0.2
	OPENBSD_3_2_BASE:1.50
	OPENBSD_3_1:1.48.0.4
	OPENBSD_3_1_BASE:1.48
	OPENBSD_3_0:1.48.0.2
	OPENBSD_3_0_BASE:1.48
	OPENBSD_2_9_BASE:1.47
	OPENBSD_2_9:1.47.0.4
	OPENBSD_2_8:1.47.0.2
	OPENBSD_2_8_BASE:1.47
	OPENBSD_2_7:1.45.0.2
	OPENBSD_2_7_BASE:1.45
	OPENBSD_2_6:1.43.0.4
	OPENBSD_2_6_BASE:1.43
	OPENBSD_2_5:1.43.0.2
	OPENBSD_2_5_BASE:1.43
	OPENBSD_2_4:1.42.0.2
	OPENBSD_2_4_BASE:1.42
	OPENBSD_2_3:1.38.0.2
	OPENBSD_2_3_BASE:1.38
	OPENBSD_2_2:1.36.0.2
	OPENBSD_2_2_BASE:1.36
	OPENBSD_2_1:1.31.0.2
	OPENBSD_2_1_BASE:1.31
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.119
date	2017.01.24.23.47.34;	author beck;	state Exp;
branches;
next	1.118;
commitid	bJ7cpsloOiZinRoH;

1.118
date	2017.01.21.08.33.07;	author krw;	state Exp;
branches;
next	1.117;
commitid	l2fu419jw6ah0BY2;

1.117
date	2017.01.20.04.03.53;	author krw;	state Exp;
branches;
next	1.116;
commitid	fvKilaTzh2Vbur5J;

1.116
date	2017.01.03.17.00.04;	author deraadt;	state Exp;
branches;
next	1.115;
commitid	9X2MbmZeyJX7O96R;

1.115
date	2016.12.28.17.48.04;	author deraadt;	state Exp;
branches;
next	1.114;
commitid	UIBQPJAx3NVjVFnr;

1.114
date	2016.12.22.16.30.03;	author beck;	state Exp;
branches;
next	1.113;
commitid	y1kvl8nyimUOdLfQ;

1.113
date	2016.12.16.17.44.59;	author krw;	state Exp;
branches;
next	1.112;
commitid	q7MaMOobu9Z5raUb;

1.112
date	2016.11.30.07.55.24;	author mestre;	state Exp;
branches;
next	1.111;
commitid	PShULm8qKLmGFyBX;

1.111
date	2016.11.06.13.16.50;	author jsing;	state Exp;
branches;
next	1.110;
commitid	vQX7Ncx0CStHimDB;

1.110
date	2016.08.13.12.55.21;	author jsing;	state Exp;
branches;
next	1.109;
commitid	K4PXzbfjsUk3ePIN;

1.109
date	2016.07.13.16.35.47;	author jsing;	state Exp;
branches;
next	1.108;
commitid	02rKn2WBJ6A1ygkh;

1.108
date	2016.05.27.15.16.16;	author jsing;	state Exp;
branches;
next	1.107;
commitid	nmSAEJ7kJwFx9GH4;

1.107
date	2016.05.06.22.06.09;	author jca;	state Exp;
branches;
next	1.106;
commitid	ivkrTCmMssc36Xjc;

1.106
date	2016.03.16.15.41.11;	author krw;	state Exp;
branches;
next	1.105;
commitid	JEVxsRygqcjPtWTf;

1.105
date	2015.11.04.17.54.06;	author jca;	state Exp;
branches;
next	1.104;
commitid	rqnGP52IirwD0wBq;

1.104
date	2015.10.18.03.39.37;	author deraadt;	state Exp;
branches;
next	1.103;
commitid	xpq634eKjAMo7Iu6;

1.103
date	2015.10.16.05.35.19;	author doug;	state Exp;
branches;
next	1.102;
commitid	vqkUQePZB9QK3Xfc;

1.102
date	2015.02.22.15.09.54;	author jsing;	state Exp;
branches;
next	1.101;
commitid	lRyL0pnPfoLbeA76;

1.101
date	2015.02.22.14.55.41;	author jsing;	state Exp;
branches;
next	1.100;
commitid	qDSb6EAJHuZKbiwf;

1.100
date	2015.02.17.22.39.32;	author tedu;	state Exp;
branches;
next	1.99;
commitid	rmPzrj0TBnBpQiAq;

1.99
date	2015.02.13.08.41.34;	author sthen;	state Exp;
branches;
next	1.98;
commitid	xsKl3NuZDLdzhpdW;

1.98
date	2015.02.12.04.23.17;	author jsing;	state Exp;
branches;
next	1.97;
commitid	YIftjrdQsRMjeEvV;

1.97
date	2015.02.09.08.24.21;	author tedu;	state Exp;
branches;
next	1.96;
commitid	Ab1pEJVaQayQbO7E;

1.96
date	2015.01.16.06.40.08;	author deraadt;	state Exp;
branches;
next	1.95;
commitid	Uu5nFG3wCl0LACBb;

1.95
date	2014.10.31.13.48.21;	author jsing;	state Exp;
branches;
next	1.94;
commitid	JZSdm092LMmDs9NJ;

1.94
date	2014.10.03.14.15.41;	author tedu;	state Exp;
branches;
next	1.93;
commitid	WGd81urRzN00l6lq;

1.93
date	2014.10.03.13.44.08;	author jsing;	state Exp;
branches;
next	1.92;
commitid	qHMp97ZOvlXS7pfh;

1.92
date	2014.07.16.04.52.43;	author lteo;	state Exp;
branches;
next	1.91;
commitid	PBjGSbR6ZTtHsoD5;

1.91
date	2014.07.14.09.26.27;	author jsing;	state Exp;
branches;
next	1.90;
commitid	BJRfx2HJ6v6eQobV;

1.90
date	2014.07.14.05.54.12;	author deraadt;	state Exp;
branches;
next	1.89;
commitid	6XcTKAYtkRJXTmU8;

1.89
date	2014.07.11.18.19.45;	author halex;	state Exp;
branches;
next	1.88;
commitid	qfJqzOcHblb5zgf9;

1.88
date	2014.07.11.03.31.52;	author lteo;	state Exp;
branches;
next	1.87;
commitid	TgWHWtjz2JHTa3XV;

1.87
date	2014.01.23.00.39.15;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2013.12.24.13.00.59;	author jca;	state Exp;
branches;
next	1.85;

1.85
date	2012.08.26.02.16.02;	author lteo;	state Exp;
branches;
next	1.84;

1.84
date	2012.08.14.20.47.08;	author haesbaert;	state Exp;
branches;
next	1.83;

1.83
date	2012.05.19.02.04.22;	author lteo;	state Exp;
branches;
next	1.82;

1.82
date	2012.04.30.13.41.26;	author haesbaert;	state Exp;
branches;
next	1.81;

1.81
date	2010.06.29.23.12.33;	author halex;	state Exp;
branches;
next	1.80;

1.80
date	2009.08.09.18.36.11;	author sobrado;	state Exp;
branches;
next	1.79;

1.79
date	2009.06.06.12.07.33;	author martynas;	state Exp;
branches;
next	1.78;

1.78
date	2009.06.04.20.58.34;	author martynas;	state Exp;
branches;
next	1.77;

1.77
date	2009.05.05.19.35.30;	author martynas;	state Exp;
branches;
next	1.76;

1.76
date	2009.04.27.22.51.51;	author martynas;	state Exp;
branches;
next	1.75;

1.75
date	2009.04.27.21.37.13;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2009.04.27.08.32.15;	author sobrado;	state Exp;
branches;
next	1.73;

1.73
date	2009.04.26.21.26.03;	author martynas;	state Exp;
branches;
next	1.72;

1.72
date	2009.04.13.01.47.04;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2008.08.22.08.52.35;	author sobrado;	state Exp;
branches;
next	1.70;

1.70
date	2008.07.08.21.07.57;	author martynas;	state Exp;
branches;
next	1.69;

1.69
date	2008.06.25.21.15.19;	author martynas;	state Exp;
branches;
next	1.68;

1.68
date	2007.11.28.16.21.25;	author jmc;	state Exp;
branches;
next	1.67;

1.67
date	2007.11.26.12.39.00;	author martynas;	state Exp;
branches;
next	1.66;

1.66
date	2007.09.05.08.04.49;	author moritz;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.16.08.58.33;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.13.18.43.16;	author jmc;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.13.13.52.26;	author pyr;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.07.23.20.18;	author tedu;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.16.16.20.42;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2006.04.25.05.45.20;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2005.09.21.22.31.47;	author fgsch;	state Exp;
branches;
next	1.58;

1.58
date	2004.07.20.03.50.26;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2003.12.16.21.46.22;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2003.11.20.12.43.55;	author jmc;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.31.08.47.31;	author otto;	state Exp;
branches;
next	1.54;

1.54
date	2003.07.02.21.04.10;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.03.02.56.08;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2003.04.05.17.19.47;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2003.03.31.23.04.07;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.04.10.13.23;	author mpech;	state Exp;
branches;
next	1.49;

1.49
date	2002.05.30.06.51.46;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.23.22.48.45;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2000.06.21.19.22.54;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2000.06.11.09.03.32;	author fgsch;	state Exp;
branches;
next	1.45;

1.45
date	2000.03.22.15.38.23;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	99.12.08.12.57.06;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	98.11.21.02.58.37;	author d;	state Exp;
branches;
next	1.42;

1.42
date	98.09.19.20.47.17;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	98.09.19.20.12.31;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	98.06.08.16.55.58;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	98.05.13.08.59.08;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	98.02.17.23.22.56;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	97.12.17.16.03.05;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	97.09.04.04.37.16;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	97.08.06.17.35.42;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	97.07.25.21.56.22;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	97.06.10.19.39.54;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	97.06.01.22.30.49;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	97.04.28.20.35.59;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	97.04.23.20.33.19;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	97.04.11.23.14.04;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	97.04.10.00.17.10;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	97.04.05.19.53.10;	author kstailey;	state Exp;
branches;
next	1.26;

1.26
date	97.04.01.21.19.05;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	97.03.21.20.59.30;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	97.03.14.05.36.02;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	97.03.14.05.03.45;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	97.03.14.04.32.17;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	97.02.18.18.04.31;	author kstailey;	state Exp;
branches;
next	1.20;

1.20
date	97.02.05.04.55.19;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.02.03.01.22.08;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.02.03.01.05.42;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.02.03.01.02.41;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.01.29.22.21.32;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.01.25.21.42.33;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.01.15.23.42.31;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.01.09.11.22.16;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.01.07.22.03.39;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.01.07.21.34.57;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.12.18.01.59.15;	author michaels;	state Exp;
branches;
next	1.9;

1.9
date	96.12.17.02.11.45;	author michaels;	state Exp;
branches;
next	1.8;

1.8
date	96.11.09.19.58.59;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.10.31.14.36.57;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.09.03.18.00.06;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.26.05.33.38;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.03.16.35.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.03.15.55.48;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.10.12.59.51;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.17;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.119
log
@Add -S noverifytime to ftp to permit an unvalidated TLS connection when
you don't knwo what time it is
@
text
@/*	$OpenBSD: main.c,v 1.118 2017/01/21 08:33:07 krw Exp $	*/
/*	$NetBSD: main.c,v 1.24 1997/08/18 10:20:26 lukem Exp $	*/

/*
 * Copyright (C) 1997 and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1985, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * FTP User Program -- Command Interface.
 */
#include <sys/types.h>
#include <sys/socket.h>

#include <ctype.h>
#include <err.h>
#include <netdb.h>
#include <pwd.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <tls.h>

#include "cmds.h"
#include "ftp_var.h"

int connect_timeout;

#ifndef NOSSL
char * const ssl_verify_opts[] = {
#define SSL_CAFILE	0
	"cafile",
#define SSL_CAPATH	1
	"capath",
#define SSL_CIPHERS	2
	"ciphers",
#define SSL_DONTVERIFY	3
	"dont",
#define SSL_DOVERIFY	4
	"do",
#define SSL_VERIFYDEPTH	5
	"depth",
#define SSL_MUSTSTAPLE	6
	"muststaple",
#define SSL_NOVERIFYTIME	7
	"noverifytime",
	NULL
};

struct tls_config *tls_config;

static void
process_ssl_options(char *cp)
{
	const char *errstr;
	long long depth;
	char *str;

	while (*cp) {
		switch (getsubopt(&cp, ssl_verify_opts, &str)) {
		case SSL_CAFILE:
			if (str == NULL)
				errx(1, "missing CA file");
			if (tls_config_set_ca_file(tls_config, str) != 0)
				errx(1, "tls ca file failed: %s",
				    tls_config_error(tls_config));
			break;
		case SSL_CAPATH:
			if (str == NULL)
				errx(1, "missing CA directory path");
			if (tls_config_set_ca_path(tls_config, str) != 0)
				errx(1, "tls ca path failed: %s",
				    tls_config_error(tls_config));
			break;
		case SSL_CIPHERS:
			if (str == NULL)
				errx(1, "missing cipher list");
			if (tls_config_set_ciphers(tls_config, str) != 0)
				errx(1, "tls ciphers failed: %s",
				    tls_config_error(tls_config));
			break;
		case SSL_DONTVERIFY:
			tls_config_insecure_noverifycert(tls_config);
			tls_config_insecure_noverifyname(tls_config);
			break;
		case SSL_DOVERIFY:
			tls_config_verify(tls_config);
			break;
		case SSL_VERIFYDEPTH:
			if (str == NULL)
				errx(1, "missing depth");
			depth = strtonum(str, 0, INT_MAX, &errstr);
			if (errstr)
				errx(1, "certificate validation depth is %s",
				    errstr);
			tls_config_set_verify_depth(tls_config, (int)depth);
			break;
		case SSL_MUSTSTAPLE:
			tls_config_ocsp_require_stapling(tls_config);
			break;
		case SSL_NOVERIFYTIME:
			tls_config_insecure_noverifytime(tls_config);
			break;
		default:
			errx(1, "unknown -S suboption `%s'",
			    suboptarg ? suboptarg : "");
			/* NOTREACHED */
		}
	}
}
#endif /* !NOSSL */

int family = PF_UNSPEC;
int pipeout;

int
main(volatile int argc, char *argv[])
{
	int ch, rval;
#ifndef SMALL
	int top;
#endif
	struct passwd *pw = NULL;
	char *cp, homedir[PATH_MAX];
	char *outfile = NULL;
	const char *errstr;
	int dumb_terminal = 0;

	ftpport = "ftp";
	httpport = "http";
#ifndef NOSSL
	httpsport = "https";
#endif /* !NOSSL */
	gateport = getenv("FTPSERVERPORT");
	if (gateport == NULL || *gateport == '\0')
		gateport = "ftpgate";
	doglob = 1;
	interactive = 1;
	autologin = 1;
	passivemode = 1;
	activefallback = 1;
	preserve = 1;
	verbose = 0;
	progress = 0;
	gatemode = 0;
#ifndef NOSSL
	cookiefile = NULL;
#endif /* NOSSL */
#ifndef SMALL
	editing = 0;
	el = NULL;
	hist = NULL;
	resume = 0;
	srcaddr = NULL;
	marg_sl = sl_init();
#endif /* !SMALL */
	mark = HASHBYTES;
	epsv4 = 1;
	epsv4bad = 0;

	/* Set default operation mode based on FTPMODE environment variable */
	if ((cp = getenv("FTPMODE")) != NULL && *cp != '\0') {
		if (strcmp(cp, "passive") == 0) {
			passivemode = 1;
			activefallback = 0;
		} else if (strcmp(cp, "active") == 0) {
			passivemode = 0;
			activefallback = 0;
		} else if (strcmp(cp, "gate") == 0) {
			gatemode = 1;
		} else if (strcmp(cp, "auto") == 0) {
			passivemode = 1;
			activefallback = 1;
		} else
			warnx("unknown FTPMODE: %s.  Using defaults", cp);
	}

	if (strcmp(__progname, "gate-ftp") == 0)
		gatemode = 1;
	gateserver = getenv("FTPSERVER");
	if (gateserver == NULL)
		gateserver = "";
	if (gatemode) {
		if (*gateserver == '\0') {
			warnx(
"Neither $FTPSERVER nor $GATE_SERVER is defined; disabling gate-ftp");
			gatemode = 0;
		}
	}

	cp = getenv("TERM");
	dumb_terminal = (cp == NULL || *cp == '\0' || !strcmp(cp, "dumb") ||
	    !strcmp(cp, "emacs") || !strcmp(cp, "su"));
	fromatty = isatty(fileno(stdin));
	if (fromatty) {
		verbose = 1;		/* verbose if from a tty */
#ifndef SMALL
		if (!dumb_terminal)
			editing = 1;	/* editing mode on if tty is usable */
#endif /* !SMALL */
	}

	ttyout = stdout;
	if (isatty(fileno(ttyout)) && !dumb_terminal && foregroundproc())
		progress = 1;		/* progress bar on if tty is usable */

#ifndef NOSSL
	cookiefile = getenv("http_cookies");
	if (tls_init() != 0)
		errx(1, "tls init failed");
	if (tls_config == NULL) {
		tls_config = tls_config_new();
		if (tls_config == NULL)
			errx(1, "tls config failed");
		if (tls_config_set_protocols(tls_config,
		    TLS_PROTOCOLS_ALL) != 0)
			errx(1, "tls set protocols failed: %s",
			    tls_config_error(tls_config));
		if (tls_config_set_ciphers(tls_config, "legacy") != 0)
			errx(1, "tls set ciphers failed: %s",
			    tls_config_error(tls_config));
	}
#endif /* !SMALL */

	httpuseragent = NULL;

	while ((ch = getopt(argc, argv,
		    "46AaCc:dD:Eegik:Mmno:pP:r:S:s:tU:vVw:")) != -1) {
		switch (ch) {
		case '4':
			family = PF_INET;
			break;
		case '6':
			family = PF_INET6;
			break;
		case 'A':
			activefallback = 0;
			passivemode = 0;
			break;

		case 'a':
			anonftp = 1;
			break;

		case 'C':
#ifndef SMALL
			resume = 1;
#endif /* !SMALL */
			break;

		case 'c':
#ifndef SMALL
			cookiefile = optarg;
#endif /* !SMALL */
			break;

		case 'D':
			action = optarg;
			break;
		case 'd':
#ifndef SMALL
			options |= SO_DEBUG;
			debug++;
#endif /* !SMALL */
			break;

		case 'E':
			epsv4 = 0;
			break;

		case 'e':
#ifndef SMALL
			editing = 0;
#endif /* !SMALL */
			break;

		case 'g':
			doglob = 0;
			break;

		case 'i':
			interactive = 0;
			break;

		case 'k':
			keep_alive_timeout = strtonum(optarg, 0, INT_MAX,
			    &errstr);
			if (errstr != NULL) {
				warnx("keep alive amount is %s: %s", errstr,
					optarg);
				usage();
			}
			break;
		case 'M':
			progress = 0;
			break;
		case 'm':
			progress = -1;
			break;

		case 'n':
			autologin = 0;
			break;

		case 'o':
			outfile = optarg;
			if (*outfile == '\0') {
				pipeout = 0;
				outfile = NULL;
				ttyout = stdout;
			} else {
				pipeout = strcmp(outfile, "-") == 0;
				ttyout = pipeout ? stderr : stdout;
			}
			break;

		case 'p':
			passivemode = 1;
			activefallback = 0;
			break;

		case 'P':
			ftpport = optarg;
			break;

		case 'r':
			retry_connect = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr != NULL) {
				warnx("retry amount is %s: %s", errstr,
					optarg);
				usage();
			}
			break;

		case 'S':
#ifndef NOSSL
			process_ssl_options(optarg);
#endif /* !NOSSL */
			break;

		case 's':
#ifndef SMALL
			srcaddr = optarg;
#endif /* !SMALL */
			break;

		case 't':
			trace = 1;
			break;

#ifndef SMALL
		case 'U':
			free (httpuseragent);
			if (strcspn(optarg, "\r\n") != strlen(optarg))
				errx(1, "Invalid User-Agent: %s.", optarg);
			if (asprintf(&httpuseragent, "User-Agent: %s",
			    optarg) == -1)
				errx(1, "Can't allocate memory for HTTP(S) "
				    "User-Agent");
			break;
#endif /* !SMALL */

		case 'v':
			verbose = 1;
			break;

		case 'V':
			verbose = 0;
			break;

		case 'w':
			connect_timeout = strtonum(optarg, 0, 200, &errstr);
			if (errstr)
				errx(1, "-w: %s", errstr);
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

#ifndef NOSSL
	cookie_load();
#endif /* !NOSSL */
	if (httpuseragent == NULL)
		httpuseragent = HTTP_USER_AGENT;

	cpend = 0;	/* no pending replies */
	proxy = 0;	/* proxy not active */
	crflag = 1;	/* strip c.r. on ascii gets */
	sendport = -1;	/* not using ports */
	/*
	 * Set up the home directory in case we're globbing.
	 */
	cp = getlogin();
	if (cp != NULL) {
		pw = getpwnam(cp);
	}
	if (pw == NULL)
		pw = getpwuid(getuid());
	if (pw != NULL) {
		(void)strlcpy(homedir, pw->pw_dir, sizeof homedir);
		home = homedir;
	}

	setttywidth(0);
	(void)signal(SIGWINCH, setttywidth);

	if (argc > 0) {
		if (isurl(argv[0])) {
			if (pipeout) {
#ifndef SMALL
				if (pledge("stdio rpath dns tty inet proc exec fattr",
				    NULL) == -1)
					err(1, "pledge");
#else
				if (pledge("stdio rpath dns tty inet fattr",
				    NULL) == -1)
					err(1, "pledge");
#endif
			} else {
#ifndef SMALL
				if (pledge("stdio rpath wpath cpath dns tty inet proc exec fattr",
				    NULL) == -1)
					err(1, "pledge");
#else
				if (pledge("stdio rpath wpath cpath dns tty inet fattr",
				    NULL) == -1)
					err(1, "pledge");
#endif
			}

			rval = auto_fetch(argc, argv, outfile);
			if (rval >= 0)		/* -1 == connected and cd-ed */
				exit(rval);
		} else {
#ifndef SMALL
			char *xargv[5];

			if (setjmp(toplevel))
				exit(0);
			(void)signal(SIGINT, (sig_t)intr);
			(void)signal(SIGPIPE, (sig_t)lostpeer);
			xargv[0] = __progname;
			xargv[1] = argv[0];
			xargv[2] = argv[1];
			xargv[3] = argv[2];
			xargv[4] = NULL;
			do {
				setpeer(argc+1, xargv);
				if (!retry_connect)
					break;
				if (!connected) {
					macnum = 0;
					fputs("Retrying...\n", ttyout);
					sleep(retry_connect);
				}
			} while (!connected);
			retry_connect = 0; /* connected, stop hiding msgs */
#endif /* !SMALL */
		}
	}
#ifndef SMALL
	controlediting();
	top = setjmp(toplevel) == 0;
	if (top) {
		(void)signal(SIGINT, (sig_t)intr);
		(void)signal(SIGPIPE, (sig_t)lostpeer);
	}
	for (;;) {
		cmdscanner(top);
		top = 1;
	}
#else /* !SMALL */
	usage();
#endif /* !SMALL */
}

void
intr(void)
{
	int save_errno = errno;

	write(fileno(ttyout), "\n\r", 2);
	alarmtimer(0);

	errno = save_errno;
	longjmp(toplevel, 1);
}

void
lostpeer(void)
{
	int save_errno = errno;

	alarmtimer(0);
	if (connected) {
		if (cout != NULL) {
			(void)shutdown(fileno(cout), SHUT_RDWR);
			(void)fclose(cout);
			cout = NULL;
		}
		if (data >= 0) {
			(void)shutdown(data, SHUT_RDWR);
			(void)close(data);
			data = -1;
		}
		connected = 0;
	}
	pswitch(1);
	if (connected) {
		if (cout != NULL) {
			(void)shutdown(fileno(cout), SHUT_RDWR);
			(void)fclose(cout);
			cout = NULL;
		}
		connected = 0;
	}
	proxflag = 0;
	pswitch(0);
	errno = save_errno;
}

#ifndef SMALL
/*
 * Generate a prompt
 */
char *
prompt(void)
{
	return ("ftp> ");
}

/*
 * Command parser.
 */
void
cmdscanner(int top)
{
	struct cmd *c;
	int num;
	HistEvent hev;

	if (!top && !editing)
		(void)putc('\n', ttyout);
	for (;;) {
		if (!editing) {
			if (fromatty) {
				fputs(prompt(), ttyout);
				(void)fflush(ttyout);
			}
			if (fgets(line, sizeof(line), stdin) == NULL)
				quit(0, 0);
			num = strlen(line);
			if (num == 0)
				break;
			if (line[--num] == '\n') {
				if (num == 0)
					break;
				line[num] = '\0';
			} else if (num == sizeof(line) - 2) {
				fputs("sorry, input line too long.\n", ttyout);
				while ((num = getchar()) != '\n' && num != EOF)
					/* void */;
				break;
			} /* else it was a line without a newline */
		} else {
			const char *buf;
			cursor_pos = NULL;

			if ((buf = el_gets(el, &num)) == NULL || num == 0) {
				putc('\n', ttyout);
				fflush(ttyout);
				quit(0, 0);
			}
			if (buf[--num] == '\n') {
				if (num == 0)
					break;
			}
			if (num >= sizeof(line)) {
				fputs("sorry, input line too long.\n", ttyout);
				break;
			}
			memcpy(line, buf, (size_t)num);
			line[num] = '\0';
			history(hist, &hev, H_ENTER, buf);
		}

		makeargv();
		if (margc == 0)
			continue;
		c = getcmd(margv[0]);
		if (c == (struct cmd *)-1) {
			fputs("?Ambiguous command.\n", ttyout);
			continue;
		}
		if (c == 0) {
			/*
			 * Give editline(3) a shot at unknown commands.
			 * XXX - bogus commands with a colon in
			 *       them will not elicit an error.
			 */
			if (editing &&
			    el_parse(el, margc, (const char **)margv) != 0)
				fputs("?Invalid command.\n", ttyout);
			continue;
		}
		if (c->c_conn && !connected) {
			fputs("Not connected.\n", ttyout);
			continue;
		}
		confirmrest = 0;
		(*c->c_handler)(margc, margv);
		if (bell && c->c_bell)
			(void)putc('\007', ttyout);
		if (c->c_handler != help)
			break;
	}
	(void)signal(SIGINT, (sig_t)intr);
	(void)signal(SIGPIPE, (sig_t)lostpeer);
}

struct cmd *
getcmd(const char *name)
{
	const char *p, *q;
	struct cmd *c, *found;
	int nmatches, longest;

	if (name == NULL)
		return (0);

	longest = 0;
	nmatches = 0;
	found = 0;
	for (c = cmdtab; (p = c->c_name) != NULL; c++) {
		for (q = name; *q == *p++; q++)
			if (*q == 0)		/* exact match? */
				return (c);
		if (!*q) {			/* the name was a prefix */
			if (q - name > longest) {
				longest = q - name;
				nmatches = 1;
				found = c;
			} else if (q - name == longest)
				nmatches++;
		}
	}
	if (nmatches > 1)
		return ((struct cmd *)-1);
	return (found);
}

/*
 * Slice a string up into argc/argv.
 */

int slrflag;

void
makeargv(void)
{
	char *argp;

	stringbase = line;		/* scan from first of buffer */
	argbase = argbuf;		/* store from first of buffer */
	slrflag = 0;
	marg_sl->sl_cur = 0;		/* reset to start of marg_sl */
	for (margc = 0; ; margc++) {
		argp = slurpstring();
		sl_add(marg_sl, argp);
		if (argp == NULL)
			break;
	}
	if (cursor_pos == line) {
		cursor_argc = 0;
		cursor_argo = 0;
	} else if (cursor_pos != NULL) {
		cursor_argc = margc;
		cursor_argo = strlen(margv[margc-1]);
	}
}

#define INC_CHKCURSOR(x)	{ (x)++ ; \
				if (x == cursor_pos) { \
					cursor_argc = margc; \
					cursor_argo = ap-argbase; \
					cursor_pos = NULL; \
				} }

/*
 * Parse string into argbuf;
 * implemented with FSM to
 * handle quoting and strings
 */
char *
slurpstring(void)
{
	int got_one = 0;
	char *sb = stringbase;
	char *ap = argbase;
	char *tmp = argbase;		/* will return this if token found */

	if (*sb == '!' || *sb == '$') {	/* recognize ! as a token for shell */
		switch (slrflag) {	/* and $ as token for macro invoke */
			case 0:
				slrflag++;
				INC_CHKCURSOR(stringbase);
				return ((*sb == '!') ? "!" : "$");
				/* NOTREACHED */
			case 1:
				slrflag++;
				altarg = stringbase;
				break;
			default:
				break;
		}
	}

S0:
	switch (*sb) {

	case '\0':
		goto OUT;

	case ' ':
	case '\t':
		INC_CHKCURSOR(sb);
		goto S0;

	default:
		switch (slrflag) {
			case 0:
				slrflag++;
				break;
			case 1:
				slrflag++;
				altarg = sb;
				break;
			default:
				break;
		}
		goto S1;
	}

S1:
	switch (*sb) {

	case ' ':
	case '\t':
	case '\0':
		goto OUT;	/* end of token */

	case '\\':
		INC_CHKCURSOR(sb);
		goto S2;	/* slurp next character */

	case '"':
		INC_CHKCURSOR(sb);
		goto S3;	/* slurp quoted string */

	default:
		*ap = *sb;	/* add character to token */
		ap++;
		INC_CHKCURSOR(sb);
		got_one = 1;
		goto S1;
	}

S2:
	switch (*sb) {

	case '\0':
		goto OUT;

	default:
		*ap = *sb;
		ap++;
		INC_CHKCURSOR(sb);
		got_one = 1;
		goto S1;
	}

S3:
	switch (*sb) {

	case '\0':
		goto OUT;

	case '"':
		INC_CHKCURSOR(sb);
		goto S1;

	default:
		*ap = *sb;
		ap++;
		INC_CHKCURSOR(sb);
		got_one = 1;
		goto S3;
	}

OUT:
	if (got_one)
		*ap++ = '\0';
	argbase = ap;			/* update storage pointer */
	stringbase = sb;		/* update scan pointer */
	if (got_one) {
		return (tmp);
	}
	switch (slrflag) {
		case 0:
			slrflag++;
			break;
		case 1:
			slrflag++;
			altarg = (char *) 0;
			break;
		default:
			break;
	}
	return (NULL);
}

/*
 * Help command.
 * Call each command handler with argc == 0 and argv[0] == name.
 */
void
help(int argc, char *argv[])
{
	struct cmd *c;

	if (argc == 1) {
		StringList *buf;

		buf = sl_init();
		fprintf(ttyout, "%sommands may be abbreviated.  Commands are:\n\n",
		    proxy ? "Proxy c" : "C");
		for (c = cmdtab; c < &cmdtab[NCMDS]; c++)
			if (c->c_name && (!proxy || c->c_proxy))
				sl_add(buf, c->c_name);
		list_vertical(buf);
		sl_free(buf, 0);
		return;
	}

#define HELPINDENT ((int) sizeof("disconnect"))

	while (--argc > 0) {
		char *arg;

		arg = *++argv;
		c = getcmd(arg);
		if (c == (struct cmd *)-1)
			fprintf(ttyout, "?Ambiguous help command %s\n", arg);
		else if (c == NULL)
			fprintf(ttyout, "?Invalid help command %s\n", arg);
		else
			fprintf(ttyout, "%-*s\t%s\n", HELPINDENT,
				c->c_name, c->c_help);
	}
}
#endif /* !SMALL */

__dead void
usage(void)
{
	fprintf(stderr, "usage: "
#ifndef SMALL
	    "ftp [-46AadEegiMmnptVv] [-D title] [-k seconds] [-P port] "
	    "[-r seconds]\n"
	    "           [-s srcaddr] [host [port]]\n"
	    "       ftp [-C] [-o output] [-s srcaddr]\n"
	    "           ftp://[user:password@@]host[:port]/file[/] ...\n"
	    "       ftp [-C] [-c cookie] [-o output] [-S ssl_options] "
	    "[-s srcaddr]\n"
	    "           [-U useragent] [-w seconds] "
	    "http[s]://[user:password@@]host[:port]/file ...\n"
	    "       ftp [-C] [-o output] [-s srcaddr] file:file ...\n"
	    "       ftp [-C] [-o output] [-s srcaddr] host:/file[/] ...\n"
#else /* !SMALL */
	    "ftp [-o output] "
	    "ftp://[user:password@@]host[:port]/file[/] ...\n"
#ifndef NOSSL
	    "       ftp [-o output] [-S ssl_options] [-w seconds] "
	    "http[s]://[user:password@@]host[:port]/file ...\n"
#else
	    "       ftp [-o output] [-w seconds] http://host[:port]/file ...\n"
#endif /* NOSSL */
	    "       ftp [-o output] file:file ...\n"
	    "       ftp [-o output] host:/file[/] ...\n"
#endif /* !SMALL */
	    );
	exit(1);
}
@


1.118
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.117 2017/01/20 04:03:53 krw Exp $	*/
d101 2
d156 3
@


1.117
log
@Straggling __dead. Mark usage() as __dead and make gcc happier.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.116 2017/01/03 17:00:04 deraadt Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d337 1
a337 1
			keep_alive_timeout = strtonum(optarg, 0, INT_MAX, 
d340 1
a340 1
				warnx("keep alive amount is %s: %s", errstr, 
d380 1
a380 1
				warnx("retry amount is %s: %s", errstr, 
@


1.116
log
@Add a "-w connect_timeout" option in support of URL-fetching.  This allows
slow / failing connects to be identified.  The install script needs this
functionaly.
ok jca rpe millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.115 2016/12/28 17:48:04 deraadt Exp $	*/
d917 1
a917 1
void
@


1.115
log
@Split -DSMALL into -DNOSSL, so that a SSL-enabled version of ftp can
be built, which is still pretty small (in distrib/special/ftp-ssl).
Lots of testing by rpe.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.114 2016/12/22 16:30:03 beck Exp $	*/
d83 2
d279 1
a279 1
		    "46AaCc:dD:Eegik:Mmno:pP:r:S:s:tU:vV")) != -1) {
d422 5
d929 1
a929 1
	    "           [-U useragent] "
d934 2
a935 1
	    "ftp [-o output] ftp://[user:password@@]host[:port]/file[/] ...\n"
d937 1
a937 1
	    "       ftp [-o output] [-S ssl_options] "
d940 1
a940 1
	    "       ftp [-o output] http://host[:port]/file ...\n"
@


1.114
log
@add muststaple option so that oscp stapling can be required for sites you
expect to provide it.
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.113 2016/12/16 17:44:59 krw Exp $	*/
d83 1
a83 1
#ifndef SMALL
d160 1
a160 1
#endif /* !SMALL */
d180 1
a180 1
#ifndef SMALL
d182 1
a182 1
#endif /* !SMALL */
d195 3
a201 1
	cookiefile = NULL;
d256 1
a256 1
#ifndef SMALL
d385 1
a385 1
#ifndef SMALL
d387 1
a387 1
#endif /* !SMALL */
d427 1
a427 1
#ifndef SMALL
d429 1
a429 1
#endif /* !SMALL */
d915 1
a915 1
	    "%1$s [-46AadEegiMmnptVv] [-D title] [-k seconds] [-P port] "
d918 1
a918 1
	    "       %1$s [-C] [-o output] [-s srcaddr]\n"
d920 1
a920 1
	    "       %1$s [-C] [-c cookie] [-o output] [-S ssl_options] "
d924 2
a925 2
	    "       %1$s [-C] [-o output] [-s srcaddr] file:file ...\n"
	    "       %1$s [-C] [-o output] [-s srcaddr] host:/file[/] ...\n",
d927 9
a935 4
	    "%1$s [-o output] ftp://[user:password@@]host[:port]/file[/] ...\n"
	    "       %1$s [-o output] http://host[:port]/file ...\n"
	    "       %1$s [-o output] file:file ...\n"
	    "       %1$s [-o output] host:/file[/] ...\n",
d937 1
a937 1
	    __progname);
@


1.113
log
@Eliminate some gcc warnings about 'unused variables', mostly by
adding appropriate #ifdef's around declarations.

ok millert@@ (with a tweak I will commit separately)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.112 2016/11/30 07:55:24 mestre Exp $	*/
d97 2
d149 3
@


1.112
log
@Check return value of tls_config_set_protocols(3) and bail out in case of
failure

Feedback and OK jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.111 2016/11/06 13:16:50 jsing Exp $	*/
d163 4
a166 1
	int ch, top, rval;
@


1.111
log
@Bump ftp(1)'s cipher default from "all" to "legacy" - this really should
be "compat", but that will require further testing.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.110 2016/08/13 12:55:21 jsing Exp $	*/
d254 4
a257 1
		tls_config_set_protocols(tls_config, TLS_PROTOCOLS_ALL);
@


1.110
log
@Split out the SSL options handling into a separate function, which makes
for more readable code and reduces line wrapping. Also improve error
messages by adding tls_config_error() to errx() where appropriate.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.109 2016/07/13 16:35:47 jsing Exp $	*/
d255 1
a255 1
		if (tls_config_set_ciphers(tls_config, "all") != 0)
@


1.109
log
@Adjust existing tls_config_set_cipher() callers for TLS cipher group
changes - map the previous configuration to the equivalent in the new
groups. This will be revisited post release.

Discussed with beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.108 2016/05/27 15:16:16 jsing Exp $	*/
d101 54
a168 3
#ifndef SMALL
	long long depth;
#endif
d256 2
a257 1
			errx(1, "tls set ciphers failed");
d373 2
a374 54
			cp = optarg;
			while (*cp) {
				char	*str;
				switch (getsubopt(&cp, ssl_verify_opts, &str)) {
				case SSL_CAFILE:
					if (str == NULL)
						errx(1, "missing CA file");
					if (tls_config_set_ca_file(
					    tls_config, str) != 0)
						errx(1, "tls ca file failed");
					break;
				case SSL_CAPATH:
					if (str == NULL)
						errx(1, "missing CA directory"
						    " path");
					if (tls_config_set_ca_path(
					    tls_config, str) != 0)
						errx(1, "tls ca path failed");
					break;
				case SSL_CIPHERS:
					if (str == NULL)
						errx(1, "missing cipher list");
					if (tls_config_set_ciphers(
					    tls_config, str) != 0)
						errx(1, "tls ciphers failed");
					break;
				case SSL_DONTVERIFY:
					tls_config_insecure_noverifycert(
					    tls_config);
					tls_config_insecure_noverifyname(
					    tls_config);
					break;
				case SSL_DOVERIFY:
					tls_config_verify(tls_config);
					break;
				case SSL_VERIFYDEPTH:
					if (str == NULL)
						errx(1, "missing depth");
					depth = strtonum(str, 0, INT_MAX,
					    &errstr);
					if (errstr)
						errx(1, "certificate "
						    "validation depth is %s",
						    errstr);
					tls_config_set_verify_depth(
					    tls_config, (int)depth);
					break;
				default:
					errx(1, "unknown -S suboption `%s'",
					    suboptarg ? suboptarg : "");
					/* NOTREACHED */
				}
			}
#endif
@


1.108
log
@Per the libtls man page, tls_init() must be called prior to any other
tls_* function; so actually do that.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.107 2016/05/06 22:06:09 jca Exp $	*/
d204 1
a204 1
		if (tls_config_set_ciphers(tls_config, "compat") != 0)
@


1.107
log
@Remove #ifdef INET6 bits, missed in a commit earlier this week

This probably broke passive FTP on IPv6 and [ip::v6]:port syntax in
RAMDISK ftp(1), sorry about that.

The diff was initially ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.106 2016/03/16 15:41:11 krw Exp $	*/
d197 2
@


1.106
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.105 2015/11/04 17:54:06 jca Exp $	*/
a145 1
#ifdef INET6
a146 3
#else
	epsv4 = 0;
#endif
@


1.105
log
@Fix inverted pledge requests, from Frederic Nowak
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.104 2015/10/18 03:39:37 deraadt Exp $	*/
d855 1
a855 1
	return ((char *)0);
d890 1
a890 1
		else if (c == (struct cmd *)0)
@


1.104
log
@First casualty of making pledge "dns" mandatory for dns users.
"dns" was missing, and this was relying on "inet" support..
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.103 2015/10/16 05:35:19 doug Exp $	*/
d447 1
a447 1
				if (pledge("stdio rpath dns tty inet fattr",
d451 1
a451 1
				if (pledge("stdio rpath dns tty inet proc exec fattr",
d457 1
a457 1
				if (pledge("stdio rpath wpath cpath dns tty inet fattr",
d461 1
a461 1
				if (pledge("stdio rpath wpath cpath dns tty inet proc exec fattr",
@


1.103
log
@Pledge for ftp(1) in non-interactive mode.

We will iterate and remove some of the pledges in the future.  This is
conservative for now.

Tested by sthen@@ and myself.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.102 2015/02/22 15:09:54 jsing Exp $	*/
d447 1
a447 1
				if (pledge("stdio rpath tty inet fattr",
d451 1
a451 1
				if (pledge("stdio rpath tty inet proc exec fattr",
d457 1
a457 1
				if (pledge("stdio rpath wpath cpath tty inet fattr",
d461 1
a461 1
				if (pledge("stdio rpath wpath cpath tty inet proc exec fattr",
@


1.102
log
@Rename tls_config_insecure_noverifyhost() to
tls_config_insecure_noverifyname(), so that it is more accurate and keeps
inline with the distinction between DNS hostname and server name.

Requested by tedu@@ during s2k15.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.101 2015/02/22 14:55:41 jsing Exp $	*/
d445 22
@


1.101
log
@Set the TLS ciphers to "compat" mode, restoring the previous behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.100 2015/02/17 22:39:32 tedu Exp $	*/
d350 1
a350 1
					tls_config_insecure_noverifyhost(
d352 1
a352 1
					tls_config_insecure_noverifycert(
@


1.100
log
@add -M to disable progressmeter. ok dlg halex millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.99 2015/02/13 08:41:34 sthen Exp $	*/
d205 3
a207 2
		tls_config_set_protocols(tls_config,
		    TLS_PROTOCOLS_ALL);
d209 1
a210 1
#endif /* !SMALL */
@


1.99
log
@Call tls_config earlier; otherwise TLS_PROTOCOLS_ALL (to allow TLSv1.0 etc)
was only called if -S was used. Fixes TLSv1.0/1.1. Problem reported by nigel@@,
ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.98 2015/02/12 04:23:17 jsing Exp $	*/
d213 1
a213 1
		    "46AaCc:dD:Eegik:mno:pP:r:S:s:tU:vV")) != -1) {
d279 3
d881 1
a881 1
	    "%1$s [-46AadEegimnptVv] [-D title] [-k seconds] [-P port] "
@


1.98
log
@Change TLS_PROTOCOLS_DEFAULT to be TLSv1.2 only. Add a TLS_PROTOCOLS_ALL
that includes all currently supported protocols (TLSv1.0, TLSv1.1 and
TLSv1.2). Change all users of libtls to use TLS_PROTOCOLS_ALL so that they
maintain existing behaviour.

Discussed with tedu@@ and reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.97 2015/02/09 08:24:21 tedu Exp $	*/
d201 8
a318 8
			if (tls_config == NULL) {
				tls_config = tls_config_new();
				if (tls_config == NULL)
					errx(1, "tls config failed");
				tls_config_set_protocols(tls_config,
				    TLS_PROTOCOLS_ALL);
			}

@


1.97
log
@various defines always exist, so delete the ifdef test.
the socks support seems to be dead, since there are no other references.
also, redeclaring a standard function? that's a no-no.
custom compiles with gate-ftp servers don't need to be supported either.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.96 2015/01/16 06:40:08 deraadt Exp $	*/
d315 2
@


1.96
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.95 2014/10/31 13:48:21 jsing Exp $	*/
d173 2
a174 2
	if (gateserver == NULL || *gateserver == '\0')
		gateserver = GATE_SERVER;
@


1.95
log
@Update ftp(1) to use libtls instead of libressl.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.94 2014/10/03 14:15:41 tedu Exp $	*/
a69 1
#include <limits.h>
d111 1
a111 1
	char *cp, homedir[MAXPATHLEN];
@


1.94
log
@update for new ressl noverify API
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.93 2014/10/03 13:44:08 jsing Exp $	*/
d79 1
a79 1
#include <ressl.h>
d101 1
a101 1
struct ressl_config *ressl_config;
d312 4
a315 4
			if (ressl_config == NULL) {
				ressl_config = ressl_config_new();
				if (ressl_config == NULL)
					errx(1, "ressl config failed");
d325 3
a327 3
					if (ressl_config_set_ca_file(
					    ressl_config, str) != 0)
						errx(1, "ressl ca file failed");
d333 3
a335 3
					if (ressl_config_set_ca_path(
					    ressl_config, str) != 0)
						errx(1, "ressl ca path failed");
d340 3
a342 3
					if (ressl_config_set_ciphers(
					    ressl_config, str) != 0)
						errx(1, "ressl ciphers failed");
d345 4
a348 4
					ressl_config_insecure_noverifyhost(
					    ressl_config);
					ressl_config_insecure_noverifycert(
					    ressl_config);
d351 1
a351 1
					ressl_config_verify(ressl_config);
d362 2
a363 2
					ressl_config_set_verify_depth(
					    ressl_config, (int)depth);
@


1.93
log
@Update ftp ressl configuration to handle recent changes in the library.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.92 2014/07/16 04:52:43 lteo Exp $	*/
d345 3
a347 1
					ressl_config_insecure_no_verify(
@


1.92
log
@Clean up the ifdef maze in usage() by reformatting it to have distinct
!SMALL and SMALL sections.  This makes future changes easier to review
and to compare with the man page's synopsis.

The usage output is the same as before so there is no change from the
user's point of view.

usage() cleanup and !SMALL/SMALL separation suggested by jmc@@
ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.91 2014/07/14 09:26:27 jsing Exp $	*/
d325 3
a327 2
					ressl_config_set_ca_file(ressl_config,
					    str);
d333 3
a335 2
					ressl_config_set_ca_path(ressl_config,
					    str);
d340 3
a342 2
					ressl_config_set_ciphers(ressl_config,
					    str);
@


1.91
log
@Convert ftp(1) to libressl, rather than rolling in^W^Whand rolling libssl.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.90 2014/07/14 05:54:12 deraadt Exp $	*/
d870 1
a870 1
	(void)fprintf(stderr, "usage: %s "
d872 1
a872 1
	    "[-46AadEegimnptVv] [-D title] [-k seconds] [-P port] "
d875 3
a877 15
	    "       %s [-C] "
#endif /* !SMALL */
	    "[-o output] "
#ifndef SMALL
	    "[-s srcaddr]\n"
	    "           "
#endif /* !SMALL */
	    "ftp://[user:password@@]host[:port]/file[/] ...\n"
	    "       %s "
#ifndef SMALL
	    "[-C] [-c cookie] "
#endif /* !SMALL */
	    "[-o output] "
#ifndef SMALL
	    "[-S ssl_options] "
d880 3
a882 30
#endif /* !SMALL */
	    "http"
#ifndef SMALL
	    "[s]"
#endif
	    "://"
#ifndef SMALL
	    "[user:password@@]"
#endif
	    "host[:port]/file ...\n"
	    "       %s "
#ifndef SMALL
	    "[-C] "
#endif /* !SMALL */
	    "[-o output] "
#ifndef SMALL
	    "[-s srcaddr] "
#endif /* !SMALL */
	    "file:file ...\n"
	    "       %s "
#ifndef SMALL
	    "[-C] "
#endif /* !SMALL */
	    "[-o output] "
#ifndef SMALL
	    "[-s srcaddr] "
#endif /* !SMALL */
	    "host:/file[/] ...\n",
#ifndef SMALL
	    __progname, __progname, __progname, __progname, __progname);
d884 4
a887 1
	    __progname, __progname, __progname, __progname);
d889 1
a891 1

@


1.90
log
@Repair handling of ^C and ^D around command prompts, by inserting
correct newlines.  Of course, that means removing stdio use from
signal handlers.  Can we find someone to rewrite the entire interactive
half of this program?
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.89 2014/07/11 18:19:45 halex Exp $	*/
d79 3
a82 1
#include "cmds.h"
d100 2
a101 5
char	*ssl_ciphers;
int	 ssl_verify = 1;
int	 ssl_verify_depth = -1;
char	*ssl_ca_file;
char	*ssl_ca_path;
d116 3
d312 6
d325 2
a326 1
					ssl_ca_file = str;
d332 2
a333 1
					ssl_ca_path = str;
d338 2
a339 1
					ssl_ciphers = str;
d342 2
a343 1
					ssl_verify = 0;
d346 1
a346 1
					ssl_verify = 1;
d351 2
a352 2
					ssl_verify_depth = strtonum(str, 0,
					    INT_MAX, &errstr);
d357 2
@


1.89
log
@simplify and slightly tweak user agent handling

ok lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.88 2014/07/11 03:31:52 lteo Exp $	*/
d470 1
d472 1
d474 2
d559 3
a561 1
			if ((buf = el_gets(el, &num)) == NULL || num == 0)
d563 1
@


1.88
log
@Allow ftp(1) to change its User-Agent for HTTP(S) URL requests using a
-U command-line option.

feedback from deraadt@@, halex@@, and Adam Thompson
ok deraadt@@ sthen@@, man page changes ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.87 2014/01/23 00:39:15 deraadt Exp $	*/
d365 1
d367 1
a367 4
#ifndef SMALL
			if (httpuseragent)
				errx(1, "User-Agent was already defined");
			/* Ensure that User-Agent value is in a single line. */
d374 1
a375 1
			break;
d395 2
@


1.87
log
@Add -D shorttitle support, so that the progress meter can show some sort
of reason why it is processing a certain file.  This will be used by the
installer for that purpose.
ok krw rpe
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.86 2013/12/24 13:00:59 jca Exp $	*/
d201 1
d204 1
a204 1
		    "46AaCc:dD:Eegik:mno:pP:r:S:s:tvV")) != -1) {
d365 14
d870 1
a870 1
	    "           "
@


1.86
log
@Add support for SSL/TLS server certificate validation, enabled by
default.  See the documentation for the `-S' switch.  This also allows
setting the preferred ciphers for the communication.  Documentation bits
ok'ed by jmc@@, ok beck@@ sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.85 2012/08/26 02:16:02 lteo Exp $	*/
d203 1
a203 1
		    "46AaCc:dEegik:mno:pP:r:S:s:tvV")) != -1) {
d232 3
d836 3
a838 3
	    "[-46AadEegimnptVv] [-k seconds] [-P port] "
	    "[-r seconds] [-s srcaddr]\n"
	    "           [host [port]]\n"
@


1.85
log
@Make a few ftp(1) usage/man page changes related to Basic
authentication:

- Combine the http and https usage formats into a single http[s] format
  to make it more concise.

- In the AUTO-FETCHING FILES section of the ftp(1) man page, mention
  that specifying "user" and "password" with HTTP and HTTPS URLs will
  log in using Basic authentication (if http_proxy is not defined).

- When compiled with -DSMALL, fix ftp(1) usage so that
  "[user:password@@]" is not shown for http[s] since Basic authentication
  is not supported with -DSMALL.

Done with a lot of discussion with and help from jmc@@ (thank you!).

ok deraadt haesbaert jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.84 2012/08/14 20:47:08 haesbaert Exp $	*/
d70 1
d82 23
d202 2
a203 1
	while ((ch = getopt(argc, argv, "46AaCc:dEegik:mno:pP:r:s:tvV")) != -1) {
d304 47
d850 1
@


1.84
log
@Add support for basic HTTP authentication as described on RFC 2617 and
RFC 3986. This allows the following idiom in ftp:

ftp http[s]://user:pass@@host/file

With some pointers from halex a lot of testing and feedback from lteo,
thanks a lot.

ok lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.83 2012/05/19 02:04:22 lteo Exp $	*/
d781 1
a781 1
	    "http://[user:password@@]host[:port]/file ...\n"
d783 7
a789 5
	    "       %s [-C] [-c cookie] [-o output] [-s srcaddr]\n"
	    "           "
	    "https://[user:password@@]host[:port]/file\n"
	    "           ...\n"
#endif /* !SMALL */
d809 1
a809 2
	    __progname, __progname, __progname, __progname, __progname,
	    __progname);
@


1.83
log
@Reformat usage() to avoid the line wrap, and make it match the way it
looks on the man page.

ok haesbaert jmc henning
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.82 2012/04/30 13:41:26 haesbaert Exp $	*/
d778 2
a779 1
	    "[-s srcaddr] "
d781 1
a781 1
	    "http://host[:port]/file ...\n"
d783 3
a785 2
	    "       %s [-C] [-c cookie] [-o output] [-s srcaddr] "
	    "https://host[:port]/file\n"
@


1.82
log
@Add a -s flag to ftp(1) to let the user specify the source IP address
of the connection. This is useful for testing ftp(1) over VPN tunnels.

This -s flag is present in the other BSDs, including OS X.

All work was done by Lawrence Teo, thanks (-:.

ok myself mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.81 2010/06/29 23:12:33 halex Exp $	*/
d762 2
a763 1
	    "[-r seconds] [host [port]]\n"
d768 2
a769 1
	    "[-s srcaddr] "
d783 2
a784 1
	    "https://host[:port]/file ...\n"
@


1.81
log
@fix output handling:
- if a remote file by the name '-' is retrieved, that does not imply
  it should go to standard output...
- make -o '' reset any previous -o action
- properly handle multiple -o 's

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.80 2009/08/09 18:36:11 sobrado Exp $	*/
d117 1
d178 1
a178 1
	while ((ch = getopt(argc, argv, "46AaCc:dEegik:mno:pP:r:tvV")) != -1) {
d279 6
d766 3
d775 3
d780 1
a780 1
	    "       %s [-C] [-c cookie] [-o output] "
d788 3
d796 5
a800 1
	    "[-o output] host:/file[/] ...\n",
@


1.80
log
@document the "file:file" auto-fetching mode.

based on a conversation with martynas@@; diff tweaked by jmc@@ and martynas@@

ok jmc@@, martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.79 2009/06/06 12:07:33 martynas Exp $	*/
d82 1
d250 8
a257 2
			if (strcmp(outfile, "-") == 0)
				ttyout = stderr;
@


1.79
log
@it fetches multiple urls;  so usage was wrong.  ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.78 2009/06/04 20:58:34 martynas Exp $	*/
d767 6
d775 2
a776 1
	    __progname, __progname, __progname, __progname, __progname);
d778 1
a778 1
	    __progname, __progname, __progname);
@


1.78
log
@set anonftp a little later;  in autofetcher itself.  after we
actually know that that login is not provided in url;  and we should
guess it.  fixes a bug reported by halex@@ where it tried to login
as 'ftp' after unsuccessful logins;  ok theo, halex@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.77 2009/05/05 19:35:30 martynas Exp $	*/
d752 1
a752 1
	    "ftp://[user:password@@]host[:port]/file[/]\n"
d758 1
a758 1
	    "http://host[:port]/file\n"
d761 1
a761 1
	    "https://host[:port]/file\n"
d767 1
a767 1
	    "[-o output] host:/file[/]\n",
@


1.77
log
@make it clean removing the ifdef SMALL maze.  separate cmds and
small stuff.  make it a fetcher.  shrinks quite a bit
agreed by millert@@, krw@@
ok theo, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.76 2009/04/27 22:51:51 martynas Exp $	*/
a316 1
			anonftp = 1;	/* Handle "automatic" transfers. */
@


1.76
log
@remove uploading and macros support from install media;  to save
some space
discussed with theo, todd@@, millert@@
tested and looked over by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.75 2009/04/27 21:37:13 deraadt Exp $	*/
d79 1
d116 1
a118 1
	marg_sl = sl_init();
d322 1
a338 1
#ifndef SMALL
a339 1
#endif /* !SMALL */
d345 1
a349 1
#endif /* !SMALL */
d359 3
d405 1
a422 1
#ifndef SMALL
a423 1
#endif /* !SMALL */
d425 1
a425 5
	if (!top 
#ifndef SMALL
	    && !editing
#endif /* !SMALL */
	    )
a427 1
#ifndef SMALL
a428 1
#endif /* !SMALL */
a447 1
#ifndef SMALL
a465 1
#endif /* !SMALL */
a475 1
#ifndef SMALL
a482 1
#endif /* !SMALL */
a552 1
#ifndef SMALL
a559 1
#endif /* !SMALL */
a561 3
#ifdef SMALL
#define INC_CHKCURSOR(x)	(x)++
#else  /* SMALL */
a567 2
						
#endif /* SMALL */
d741 1
d746 1
a746 2
	(void)fprintf(stderr,
	    "usage: %s [-46Aa"
d748 3
a750 6
	    "d"
#endif /* !SMALL */
	    "EegimnptVv] [-k seconds] [-P port] [-r seconds] [host [port]]\n"
	    "       %s "
#ifndef SMALL
	    "[-C] "
d772 1
a772 1
	    __progname, __progname, __progname, __progname);
d776 1
@


1.75
log
@toast the rcsid strings which just get in the way
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.74 2009/04/27 08:32:15 sobrado Exp $	*/
d337 1
d339 1
@


1.74
log
@embellish usage now that -T has been removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.73 2009/04/26 21:26:03 martynas Exp $	*/
a60 10

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1985, 1989, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#if !defined(lint) && !defined(SMALL)
static const char rcsid[] = "$OpenBSD: main.c,v 1.73 2009/04/26 21:26:03 martynas Exp $";
#endif /* not lint and not SMALL */
@


1.73
log
@figure out titles automatically by using remote file name.  remove
-T and just show titles by default for non-verbose transfers;
discussed with, ok theo, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.72 2009/04/13 01:47:04 deraadt Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.72 2009/04/13 01:47:04 deraadt Exp $";
d773 1
a773 2
	    "EegimnptVv] [-k seconds] [-P port] [-r seconds]\n"
	    "           [host [port]]\n"
@


1.72
log
@add a "-T title" option to ftp; this is is used in progress bar mode to
show which filename is being used. ok krw, mdoc repair from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.71 2008/08/22 08:52:35 sobrado Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.71 2008/08/22 08:52:35 sobrado Exp $";
d185 1
a185 1
	while ((ch = getopt(argc, argv, "46AaCc:dEegik:mno:pP:r:tT:vV")) != -1) {
a283 4
		case 'T':
			title = strdup(optarg);
			break;

d774 1
a774 1
	    "           [-T title] [host [port]]\n"
@


1.71
log
@default file transfer type is binary, not ascii;
commands which toggle settings can take an explicit on or off argument
to force the setting appropiately, show these arguments in usage;
synchronize synopsis and usage of commands; spacing; KNF;
other minor documentation tweaks.

written with help by jmc@@

ok jmc@@ (documentation), martynas@@ (type usage and default file transfer type)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.70 2008/07/08 21:07:57 martynas Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.70 2008/07/08 21:07:57 martynas Exp $";
d185 1
a185 1
	while ((ch = getopt(argc, argv, "46AaCc:dEegik:mno:pP:r:tvV")) != -1) {
d284 4
d777 2
a778 2
	    "EegimnptVv] [-k seconds] "
	    "[-P port] [-r seconds] [host [port]]\n"
@


1.70
log
@- add support for recursive transfers (but not for floppies), e.g.
'mget -cr 4.*' would recursively fetch (-r), and resume the previous
transfers (-c) of 4.X release directories
uses local matching (fnmatch), but only for recursive transfers.
current behavior is not changed in any way.
- while here, ifndef SMALL debugging stuff, this saves some space,
for floppies
- some debugging code was enabled for non-debugging mode, checks
assume debug is set to zero, but it's not initially set
- all "Confirm with" prompts are forced, remove redundant argument
- fix usage: -C and -c are not available for SMALL

discussed a year ago w/ pyr@@
looks good to millert@@
previous version looked good to pyr@@
man page tweaks & ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.69 2008/06/25 21:15:19 martynas Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.69 2008/06/25 21:15:19 martynas Exp $";
d795 1
a795 1
	    "[-o output] host:[/path/]file[/]\n",
@


1.69
log
@in resume mode, pass -c to mget when {dir,file}hasglob, so that i'm
able to continue multiple transfers with -C;  ok millert@@
while here fix some comments (!SMALL vs. SMALL stuff), and add
missing
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.68 2007/11/28 16:21:25 jmc Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.68 2007/11/28 16:21:25 jmc Exp $";
d215 1
d218 1
d769 5
a773 1
	    "usage: %s [-46AadEegimnptVv] [-k seconds] "
d775 5
a779 1
	    "       %s [-C] [-o output] "
d781 5
a785 1
	    "       %s [-C] [-c cookie] [-o output] "
d791 5
a795 1
	    "       %s [-C] [-o output] host:[/path/]file[/]\n",
@


1.68
log
@- [-C] and [-c cookie] do not belong in the first synopsis/usage();
after some discussion with martynas
- tweak the description of -C a little more, for readability
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.67 2007/11/26 12:39:00 martynas Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.67 2007/11/26 12:39:00 martynas Exp $";
d106 1
a106 1
#endif
d125 1
a125 1
#endif
d174 1
a174 1
#endif
d183 1
a183 1
#endif
d205 1
a205 1
#endif
d211 1
a211 1
#endif
d226 1
a226 1
#endif
d299 1
a299 1
#endif
d427 1
a427 1
#endif
d580 1
a580 1
#else  /* !SMALL */
d588 1
a588 1
#endif /* !SMALL */
d776 1
a776 1
#endif
d780 1
a780 1
#else
d782 1
a782 1
#endif
@


1.67
log
@implement -C for continuing ftp, http(s), and file transfers
ok millert@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.66 2007/09/05 08:04:49 moritz Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.66 2007/09/05 08:04:49 moritz Exp $";
d767 6
a772 5
	    "usage: %s [-46AaCdEegimnptVv] [-c cookie] [-k seconds] "
	    "[-P port] [-r seconds]\n"
	    "           [host [port]]\n"
	    "       %s [-o output] ftp://[user:password@@]host[:port]/file[/]\n"
	    "       %s [-o output] http://host[:port]/file\n"
d774 2
a775 1
	    "       %s [-o output] https://host[:port]/file\n"
d777 1
a777 1
	    "       %s [-o output] host:[/path/]file[/]\n",
@


1.66
log
@Replace magic numbers in calls to shutdown(2)
with their respective defines.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.65 2007/06/16 08:58:33 espie Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.65 2007/06/16 08:58:33 espie Exp $";
d124 1
d185 1
a185 1
	while ((ch = getopt(argc, argv, "46Aac:dEegik:mno:pP:r:tvV")) != -1) {
d202 6
d767 1
a767 1
	    "usage: %s [-46AadEegimnptVv] [-c cookie] [-k seconds] "
@


1.65
log
@implement a `keep-alive' option that sends bytes over an inactive
connection. The FTP protocol provides us with a NOOP operation that
is perfectly suitable for that, and so far servers are happy with it.
Sending the command slowly is an idea I borrowed from spamd.
No change for people not using the option, so it can't break normal ftp.

okay beck@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.64 2007/06/13 18:43:16 jmc Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.64 2007/06/13 18:43:16 jmc Exp $";
d376 1
a376 1
			(void)shutdown(fileno(cout), 1+1);
d381 1
a381 1
			(void)shutdown(data, 1+1);
d390 1
a390 1
			(void)shutdown(fileno(cout), 1+1);
@


1.64
log
@- shorten -c's argument name to avoid ugly line split
- tidy up the description of -c and http_cookies
- add -c to usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.63 2007/06/13 13:52:26 pyr Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.63 2007/06/13 13:52:26 pyr Exp $";
d184 1
a184 1
	while ((ch = getopt(argc, argv, "46Aac:dEegimno:pP:r:tvV")) != -1) {
d230 9
d264 2
a265 2
			if (errstr != NULL)
				errx(1, "retry amount is %s: %s", errstr, 
d267 2
d760 3
a762 2
	    "usage: %s [-46AadEegimnptVv] [-c cookie] [-P port] "
	    "[-r seconds] [host [port]]\n"
@


1.63
log
@Enable cookie support. This allows parsing of netscape-like cookie jars
and sending of appropriate cookies. No retrieval of new cookies is done.
Careful review and lots of input by millert and ray.

ok millert@@, ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.62 2007/04/07 23:20:18 tedu Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.62 2007/04/07 23:20:18 tedu Exp $";
d749 2
a750 1
	    "usage: %s [-46AadEegimnptVv] [-P port] [-r seconds] [host [port]]\n"
@


1.62
log
@use strtonum, from jason dixon
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.61 2006/05/16 16:20:42 deraadt Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.61 2006/05/16 16:20:42 deraadt Exp $";
d123 1
d180 5
a184 1
	while ((ch = getopt(argc, argv, "46AadEegimno:pP:r:tvV")) != -1) {
d201 6
d278 4
@


1.61
log
@https URL support; rototilled by a few people including me; originally
from Rainer_Giedat@@genua.de
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.60 2006/04/25 05:45:20 tedu Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.60 2006/04/25 05:45:20 tedu Exp $";
d99 1
d243 4
a246 4
			if (isdigit(*optarg))
				retry_connect = atoi(optarg);
			else
				errx(1, "-r requires numeric argument");
@


1.60
log
@two strtol calls that were begging to be converted to strtonum
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.59 2005/09/21 22:31:47 fgsch Exp $	*/
d69 1
a69 1
static const char rcsid[] = "$OpenBSD: main.c,v 1.59 2005/09/21 22:31:47 fgsch Exp $";
d103 3
d736 3
d740 3
d744 1
@


1.59
log
@add ability to disable EPSV/EPRT from command-line.
from Thorsten Glaser via Matt Van Mater < matt dot vanmater at gmail dot com >
with some minor mods. deraadt@@ jmc@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.58 2004/07/20 03:50:26 deraadt Exp $	*/
d63 1
a63 1
static char copyright[] =
d69 1
a69 1
static char rcsid[] = "$OpenBSD: main.c,v 1.58 2004/07/20 03:50:26 deraadt Exp $";
@


1.58
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.57 2003/12/16 21:46:22 deraadt Exp $	*/
d69 1
a69 1
static char rcsid[] = "$OpenBSD: main.c,v 1.57 2003/12/16 21:46:22 deraadt Exp $";
d175 1
a175 1
	while ((ch = getopt(argc, argv, "46Aadegimno:pP:r:tvV")) != -1) {
d197 4
d730 1
a730 1
	    "usage: %s [-46AadegimnptVv] [-P port] [-r seconds] [host [port]]\n"
@


1.57
log
@for -DSMALL, do not include rcsid[]s
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.56 2003/11/20 12:43:55 jmc Exp $	*/
d69 1
a69 1
static char rcsid[] = "$OpenBSD: main.c,v 1.56 2003/11/20 12:43:55 jmc Exp $";
d327 1
a327 1
intr()
d335 1
a335 1
lostpeer()
d371 1
a371 1
prompt()
d380 1
a380 2
cmdscanner(top)
	int top;
d475 1
a475 2
getcmd(name)
	const char *name;
d512 1
a512 1
makeargv()
d555 1
a555 1
slurpstring()
d687 1
a687 3
help(argc, argv)
	int argc;
	char *argv[];
d723 1
a723 1
usage()
@


1.56
log
@ftp.1:
- simpler macros
- sort options
- some updates
- remove some old groff stuff

main.c:
sync usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.54 2003/07/02 21:04:10 deraadt Exp $	*/
d68 3
a70 7
#ifndef lint
#if 0
static char sccsid[] = "@@(#)main.c	8.6 (Berkeley) 10/9/94";
#else
static char rcsid[] = "$OpenBSD: main.c,v 1.54 2003/07/02 21:04:10 deraadt Exp $";
#endif
#endif /* not lint */
@


1.55
log
@New libedit api changes.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d734 4
a737 4
	    "usage: %s [-AVadegimnptv46] [-o output] [-P port] [-r <seconds>] [host [port]]\n"
	    "       %s host:[/path/]file[/]\n"
	    "       %s ftp://[user:password@@]host[:port]/file[/]\n"
	    "       %s http://host[:port]/file\n",
@


1.54
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.53 2003/06/03 02:56:08 millert Exp $	*/
d72 1
a72 1
static char rcsid[] = "$OpenBSD: main.c,v 1.53 2003/06/03 02:56:08 millert Exp $";
d389 3
d439 1
a439 1
			history(hist, H_ENTER, buf);
d459 1
a459 1
			    el_parse(el, margc, margv) != 0)
@


1.53
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.52 2003/04/05 17:19:47 deraadt Exp $	*/
d72 1
a72 1
static char rcsid[] = "$OpenBSD: main.c,v 1.52 2003/04/05 17:19:47 deraadt Exp $";
d97 1
a97 3
main(argc, argv)
	volatile int argc;
	char ** volatile argv;
@


1.52
log
@string fixes; ok miod henning
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.51 2003/03/31 23:04:07 millert Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d72 1
a72 1
static char rcsid[] = "$OpenBSD: main.c,v 1.51 2003/03/31 23:04:07 millert Exp $";
@


1.51
log
@Treat empty environment variables the same as NULL.  henning@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.50 2002/06/04 10:13:23 mpech Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: main.c,v 1.50 2002/06/04 10:13:23 mpech Exp $";
d284 1
a285 1
		(void)strcpy(home, pw->pw_dir);
@


1.50
log
@We want sync usage() w/ manual since -4/-6 options have been added.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.49 2002/05/30 06:51:46 deraadt Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: main.c,v 1.49 2002/05/30 06:51:46 deraadt Exp $";
d114 1
a114 1
	if (gateport == NULL)
d140 1
a140 1
	if ((cp = getenv("FTPMODE")) != NULL) {
d170 1
a170 1
	dumb_terminal = (cp == NULL || !strcmp(cp, "dumb") ||
@


1.49
log
@-4 and -6 options; kanai@@big.or.jp; itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.48 2001/06/23 22:48:45 millert Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: main.c,v 1.48 2001/06/23 22:48:45 millert Exp $";
d737 3
a739 3
	    "usage: %s [-adegimnptvV] [-r <seconds>] [host [port]]\n"
	    "       %s host:path[/]\n"
	    "       %s ftp://host[:port]/path[/]\n"
@


1.48
log
@remove evil #ifdef __GNUC__ garbage to avoid longjmp clobbering and use volatile instead
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.47 2000/06/21 19:22:54 itojun Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: main.c,v 1.47 2000/06/21 19:22:54 itojun Exp $";
d98 2
d185 1
a185 1
	while ((ch = getopt(argc, argv, "Aadegimno:pP:r:tvV")) != -1) {
d187 6
@


1.47
log
@add epsv4 command, which turns off epsv on ipv4 (off by dfeault)
automagicaslly disable epsv on ipv4, if epsv fails for single connection.
merge from netbsd-current.

req from fgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.46 2000/06/11 09:03:32 fgsch Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: main.c,v 1.46 2000/06/11 09:03:32 fgsch Exp $";
a97 2
int main __P((int, char **));

d100 2
a101 2
	int argc;
	char *argv[];
a281 5

#ifdef __GNUC__				/* XXX: to shut up gcc warnings */
	(void)&argc;
	(void)&argv;
#endif
@


1.46
log
@do not add empty lines to history; always check the size of the returned
string by el_gets.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.45 2000/03/22 15:38:23 markus Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: main.c,v 1.45 2000/03/22 15:38:23 markus Exp $";
d132 6
@


1.45
log
@fix overflows, ok aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.44 1999/12/08 12:57:06 itojun Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: main.c,v 1.44 1999/12/08 12:57:06 itojun Exp $";
d425 1
a425 1
			if (line[--num] == '\n') {
d428 2
a429 1
			} else if (num >= sizeof(line)) {
@


1.44
log
@ftp(1) from KAME, should be good for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.43 1998/11/21 02:58:37 d Exp $	*/
d76 1
a76 1
static char rcsid[] = "$OpenBSD: main.c,v 1.43 1998/11/21 02:58:37 d Exp $";
d453 2
a454 1
			if (el_parse(el, margc, margv) != 0)
@


1.43
log
@add -m to usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.42 1998/09/19 20:47:17 millert Exp $	*/
d5 29
d76 1
a76 1
static char rcsid[] = "$OpenBSD: main.c,v 1.42 1998/09/19 20:47:17 millert Exp $";
a104 1
	struct servent *sp;
a105 1
	long port;
d107 1
a107 1
	char *cp, *ep, homedir[MAXPATHLEN];
d111 5
a115 27
	sp = getservbyname("ftp", "tcp");
	if (sp == 0)
		ftpport = htons(FTP_PORT);	/* good fallback */
	else
		ftpport = sp->s_port;
	sp = getservbyname("http", "tcp");
	if (sp == 0)
		httpport = htons(HTTP_PORT);	/* good fallback */
	else
		httpport = sp->s_port;
	gateport = 0;
	cp = getenv("FTPSERVERPORT");
	if (cp != NULL) {
		port = strtol(cp, &ep, 10);
		if (port < 1 || port > USHRT_MAX || *ep != '\0')
			warnx("bad FTPSERVERPORT port number: %s (ignored)",
			    cp);
		else
			gateport = htons(port);
	}
	if (gateport == 0) {
		sp = getservbyname("ftpgate", "tcp");
		if (sp == 0)
			gateport = htons(GATE_PORT);
		else
			gateport = sp->s_port;
	}
d229 1
a229 5
			port = strtol(optarg, &ep, 10);
			if (port < 1 || port > USHRT_MAX || *ep != '\0')
				warnx("bad port number: %s (ignored)", optarg);
			else
				ftpport = htons((in_port_t)port);
d285 1
a285 1
		if (strchr(argv[0], ':') != NULL) {
@


1.42
log
@Make -m flag turn on progress meter in all situations
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.41 1998/09/19 20:12:31 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.41 1998/09/19 20:12:31 millert Exp $";
d727 1
a727 1
	    "usage: %s [-adeginptvV] [-r <seconds>] [host [port]]\n"
@


1.41
log
@add -m option to turn on progress meter in non-verbose mode
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.40 1998/06/08 16:55:58 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.40 1998/06/08 16:55:58 millert Exp $";
d205 1
a205 1
			progress = 1;
@


1.40
log
@Fix some problems noted by lukem@@netbsd.org
 o getopt string is wrong in main(); (missing : after P)
 o use of vprintf(...) instead of vfprintf(ttyout,...) in ftp.c::command()
 o missing \n in fputs in cmds.c::status()
 o should use strtol() instead of atol()
 o sometimes use 'NULL' instead of 'NUL' (in comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.39 1998/05/13 08:59:08 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.39 1998/05/13 08:59:08 deraadt Exp $";
d174 1
a174 1
	while ((ch = getopt(argc, argv, "Aadegino:pP:r:tvV")) != -1) {
d202 4
@


1.39
log
@make signal handlers save/restore errno
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.38 1998/02/17 23:22:56 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.38 1998/02/17 23:22:56 millert Exp $";
d174 1
a174 1
	while ((ch = getopt(argc, argv, "Aadegino:pPr:tvV")) != -1) {
@


1.38
log
@Add a new option "-o filename" for autofetch mode.  Allows use of
"-" to mean stdout.  This replaces the old (unreliable) hueristic
of checking if stdout is a tty and if not make the output go to stdout.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.37 1997/12/17 16:03:05 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.37 1997/12/17 16:03:05 millert Exp $";
d62 1
d335 1
d362 1
@


1.37
log
@By default, use passive mode and fall back to active as needed.
The user can specify active only with the -A flag, or use the
new FTPMODE envariable.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.36 1997/09/04 04:37:16 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.36 1997/09/04 04:37:16 millert Exp $";
d80 1
a81 1
	int outfd = -1;
d173 1
a173 6
	if (!isatty(fileno(ttyout))) {
		outfd = fileno(stdout);
		ttyout = stderr;
	}

	while ((ch = getopt(argc, argv, "AadeginpPr:tvV")) != -1) {
d207 6
d281 1
a281 1
			rval = auto_fetch(argc, argv, outfd);
@


1.36
log
@Updtaes from NetBSD (lukem)
    bugs fixed:
      * don't interpret '-' or '|' when a local filename is determined from
        the remote name (i.e, in mget, and in get with only one argument).
        This is implemented using an extra argument to recvrequest().
        Fixes a major security hole.
      * clean up memory leak when using globulize()
      * clean up a couple of comments
      * fix wording in TNF copyright

    features added:
      * support for TIS fwtk gate-ftp servers:
        * read defaults from $FTPSERVER && $FTPSERVERPORT
        * start in gate-ftp mode if invoked as 'gate-ftp'
        * toggle or set with 'gate [host [port]]'

Other changes:
    * use symbolic flags in access(2)
    * Use USHRT_MAX, not 0xffff
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 1997/08/06 17:35:42 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.35 1997/08/06 17:35:42 mickey Exp $";
d113 2
a114 1
	passivemode = 0;
d127 18
a144 5
	cp = strrchr(argv[0], '/');
	cp = (cp == NULL) ? argv[0] : cp + 1;
	if (strcmp(cp, "pftp") == 0)
		passivemode = 1;
	else if (strcmp(cp, "gate-ftp") == 0)
a145 1

d152 1
a152 1
"Neither $FTPSERVER nor GATE_SERVER is defined; disabling gate-ftp");
d178 1
a178 1
	while ((ch = getopt(argc, argv, "adeginpPr:tvV")) != -1) {
d180 5
d214 1
@


1.35
log
@proper msgs display w/ -r
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.34 1997/07/25 21:56:22 millert Exp $	*/
/*	$NetBSD: main.c,v 1.23 1997/07/20 09:45:58 lukem Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.34 1997/07/25 21:56:22 millert Exp $";
d79 1
a79 1
	char *cp, homedir[MAXPATHLEN];
d93 17
d117 1
d130 13
d199 2
a200 2
			port = strtol(optarg, &cp, 10);
			if (port < 1 || port > 0xffff || *cp != '\0')
@


1.34
log
@Updates from NetBSD (lukem) include -Wall cleanup.
More -W* cleanup and in_port_t usage by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 1997/06/10 19:39:54 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.33 1997/06/10 19:39:54 millert Exp $";
d255 1
d669 1
a669 1
	    "usage: %s [-adeginprtvV] [host [port]]\n"
@


1.33
log
@Disable progress meter if started as a bg process.  Also don't
print the progress meter if the ftp process is put in the bg
(but do print it when/if the process is foregrounded).
From Enami Tsugutomo <enami@@ba2.so-net.or.jp> with tweaks by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.32 1997/06/01 22:30:49 deraadt Exp $	*/
/*	$NetBSD: main.c,v 1.21 1997/04/05 03:27:39 lukem Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.32 1997/06/01 22:30:49 deraadt Exp $";
d68 2
d76 2
a77 1
	int ch, top, port, rval;
d121 1
a121 1
			editing = 1;	/* editing mode on if from a tty */
d127 1
a127 1
		progress = 1;		/* progress bar on if going to a tty */
d168 2
a169 2
			port = atoi(optarg);
			if (port <= 0)
d172 1
a172 1
				ftpport = htons(port);
d222 5
d372 1
a372 1
			memcpy(line, buf, num);
@


1.32
log
@fix emacs batch download problem, i think
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 1997/04/28 20:35:59 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.31 1997/04/28 20:35:59 millert Exp $";
d123 1
a123 1
	if (isatty(fileno(ttyout)) && !dumb_terminal)
@


1.31
log
@Deal with $TERM not being set (like in single user mode).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 1997/04/23 20:33:19 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.30 1997/04/23 20:33:19 deraadt Exp $";
d125 3
a127 1
	else {
a128 1
		outfd = fileno(stdout);
@


1.30
log
@allow "ftp -aV ftp://host/foo.tar.gz | tar xvfpz -" to work
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 1997/04/11 23:14:04 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.29 1997/04/11 23:14:04 millert Exp $";
d110 3
a112 2
	dumb_terminal = (!strcmp(getenv("TERM"), "dumb") ||
	    !strcmp(getenv("TERM"), "emacs") || !strcmp(getenv("TERM"), "su"));
@


1.29
log
@emacs is dumb too--the $TERM entry that is.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 1997/04/10 00:17:10 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.28 1997/04/10 00:17:10 millert Exp $";
d78 1
d120 3
a122 1
	if (isatty(fileno(stdout)) && !dumb_terminal)
d124 4
d220 1
a220 1
			rval = auto_fetch(argc, argv);
d241 1
a241 1
					puts("Retrying...");
d324 1
a324 1
		(void)putchar('\n');
d330 2
a331 2
				fputs(prompt(), stdout);
				(void)fflush(stdout);
d343 1
a343 1
				puts("sorry, input line too long.");
d359 1
a359 1
				puts("sorry, input line too long.");
d373 1
a373 1
			puts("?Ambiguous command.");
d385 1
a385 1
				puts("?Invalid command.");
d389 1
a389 1
			puts("Not connected.");
d395 1
a395 1
			(void)putchar('\007');
d627 1
a627 1
		printf("%sommands may be abbreviated.  Commands are:\n\n",
d645 1
a645 1
			printf("?Ambiguous help command %s\n", arg);
d647 1
a647 1
			printf("?Invalid help command %s\n", arg);
d649 1
a649 1
			printf("%-*s\t%s\n", HELPINDENT,
@


1.28
log
@Sync with NetBSD (lukem)
    * support $ftp_proxy for ftp:// transfers [bin/3245]
    * add "more" & "less" as synonyms for "page"
    * move editline setup code into controlediting(), and call appropriately.
      only setup setup terminal if going into interactive mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.27 1997/04/05 19:53:10 kstailey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.27 1997/04/05 19:53:10 kstailey Exp $";
d109 2
a110 2
	dumb_terminal =
	    (!strcmp(getenv("TERM"), "dumb") || !strcmp(getenv("TERM"), "su"));
@


1.27
log
@if TERM=dumb disable progress and editing for emacs ange-ftp
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.26 1997/04/01 21:19:05 millert Exp $	*/
/*	$NetBSD: main.c,v 1.20 1997/03/16 14:24:21 lukem Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.26 1997/04/01 21:19:05 millert Exp $";
d77 1
a77 1
	int from_emacs;
d98 2
d109 2
a110 1
	from_emacs = !strcmp(getenv("TERM"), "dumb");
d115 1
a115 1
		if (!from_emacs)
d119 1
a119 1
	if (isatty(fileno(stdout)) && !from_emacs)
d133 2
a134 2
		case 'e':	/* XXX should TERM=dumb be the only way to */
#ifndef SMALL			/* turn off editing or not? */
a206 23
#ifndef SMALL
	if (argc > 0)				/* batch mode */
		editing = 0;
	if (editing) {
		el = el_init(__progname, stdin, stdout); /* init editline */

		hist = history_init();		/* init the builtin history */
		history(hist, H_EVENT, 100);	/* remember 100 events */
		el_set(el, EL_HIST, history, hist);	/* use history */

		el_set(el, EL_EDITOR, "emacs");	/* default editor is emacs */
		el_set(el, EL_PROMPT, prompt);	/* set the prompt function */

		/* add local file completion, bind to TAB */
		el_set(el, EL_ADDFN, "ftp-complete",
		    "Context sensitive argument completion",
		    complete);
		el_set(el, EL_BIND, "^I", "ftp-complete", NULL);

		el_source(el, NULL);	/* read ~/.editrc */
	}
#endif /* !SMALL */

a208 4
#ifndef SMALL
	if (editing)
		el_set(el, EL_SIGNAL, 1);
#endif /* !SMALL */
d240 3
@


1.26
log
@Disable editing when in batch mode.  Idea from Theo.
This makes ``ftp ftp://some.place.com/some/file &'' work.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 1997/03/21 20:59:30 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.25 1997/03/21 20:59:30 millert Exp $";
d77 1
d107 1
d112 2
a113 1
		editing = 1;		/* editing mode on if from a tty */
d116 1
a116 1
	if (isatty(fileno(stdout)))
d130 2
a131 2
		case 'e':
#ifndef SMALL
@


1.25
log
@Add in recent NetBSD changes we didn't already have:
    Always compile complete.c but ifdef out the bits if -DSMALL (christos)
    reset interactive mode correctly in auto_fetch() mget mode (lukem)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 1997/03/14 05:36:02 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.24 1997/03/14 05:36:02 millert Exp $";
d202 2
@


1.24
log
@Fix problem where tty mode could get clobbered when ftp was suspended.
Call el_parse() to catch editrc(5) commands if the command is not known
to ftp.  Thorsten did all the real work for this :-)
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.23 1997/03/14 05:03:45 millert Exp $	*/
/*	$NetBSD: main.c,v 1.18 1997/03/13 06:23:19 lukem Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.23 1997/03/14 05:03:45 millert Exp $";
d95 1
a95 1
#ifndef SMALLFTP
d109 1
a109 1
#ifndef SMALLFTP
d128 1
a128 1
#ifndef SMALLFTP
d201 1
a201 1
#ifndef SMALLFTP
d220 1
a220 1
#endif /* !SMALLFTP */
d224 1
a224 1
#ifndef SMALLFTP
d227 1
a227 1
#endif /* !SMALLFTP */
d329 1
a329 1
#ifndef SMALLFTP
d331 1
a331 1
#endif /* !SMALLFTP */
d335 1
a335 1
#ifndef SMALLFTP
d337 1
a337 1
#endif /* !SMALLFTP */
d357 1
a357 1
#ifndef SMALLFTP
d375 1
a375 1
#endif /* !SMALLFTP */
d386 1
a386 1
#ifndef SMALLFTP
d393 1
a393 1
#endif /* !SMALLFTP */
d465 1
a465 1
#ifndef SMALLFTP
d473 1
a473 1
#endif /* !SMALLFTP */
d476 1
a476 1
#ifdef SMALLFTP
d478 1
a478 1
#else  /* !SMALLFTP */
d486 1
a486 1
#endif /* !SMALLFTP */
@


1.23
log
@Change an occurrence of if (fromatty) -> if (edit) -- from Thorsten.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 1997/03/14 04:32:17 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.22 1997/03/14 04:32:17 millert Exp $";
d224 4
a379 8
#if 0 && !defined(SMALLFTP)	/* XXX: don't want el_parse */
		/*
		 * el_parse returns -1 to signal that it's not been handled
		 * internally.
		 */
		if (el_parse(el, margc, margv) != -1)
			continue;
#endif /* !SMALLFTP */
d386 9
a394 1
			puts("?Invalid command.");
@


1.22
log
@Sync with NetBSD and fix "get foo.txt /dev/tty" wrt progress meter
and setting times.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 1997/02/18 18:04:31 kstailey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.21 1997/02/18 18:04:31 kstailey Exp $";
d202 1
a202 1
	if (fromatty) {
@


1.21
log
@add -e command line option to suppress use of editline(3)\
this is useful for Emacs ange-ftp
@
text
@d1 2
a2 2
/*	$OpenBSD: main.c,v 1.20 1997/02/05 04:55:19 millert Exp $	*/
/*	$NetBSD: main.c,v 1.17 1997/02/01 10:45:07 lukem Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.20 1997/02/05 04:55:19 millert Exp $";
d95 3
a99 1
	use_editline = 1;	/* use editline if possible */
d107 1
a107 1
	if (fromatty)
d109 6
d128 3
a130 1
			use_editline = 0;
d202 1
a202 3
	editing = 0;			/* command line editing off */
	if (fromatty && use_editline) {
		editing = 1;		/* editing mode on if a tty */
d348 1
a348 1
				puts("sorry, input line too long");
d364 1
a364 1
				puts("sorry, input line too long");
d386 1
a386 1
			puts("?Ambiguous command");
d390 1
a390 1
			puts("?Invalid command");
d663 1
a663 1
	    "usage: %s [-adginprtvV] [host [port]]\n"
@


1.20
log
@Include signal.h where reasonable and make signal handlers match
what signal(3)'s prototype says (and cast when not).
Also change MAXFOO+1 -> MAXFOO since MAXFOO includes the NULL.
Support $TMPDIR and use utime(3) not utimes(2) for portability's sake.
Don't spew "Passive mode enabled/disabled" unless verbose (this means
togglevar() needs to watch for a NULL 'message').
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 1997/02/03 01:22:08 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.19 1997/02/03 01:22:08 millert Exp $";
d97 1
d108 1
a108 1
	while ((ch = getopt(argc, argv, "adginpPr:tvV")) != -1) {
d119 4
d193 1
a193 1
	if (fromatty) {
@


1.19
log
@Turn off progress bar by default as it interacts poorly with
"get FILE /dev/tty" and "get FILE |pager" among others.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 1997/02/03 01:05:42 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.18 1997/02/03 01:05:42 millert Exp $";
d223 2
a224 2
			(void)signal(SIGINT, intr);
			(void)signal(SIGPIPE, lostpeer);
d244 2
a245 2
		(void)signal(SIGINT, intr);
		(void)signal(SIGPIPE, lostpeer);
d391 2
a392 2
	(void)signal(SIGINT, intr);
	(void)signal(SIGPIPE, lostpeer);
@


1.18
log
@Add back ``-r'' option and fix strncpy() usage and other nits because
I'm anal.  Closer to KNF now.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 1997/02/01 10:45:07 lukem Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.17 1997/02/01 10:45:07 lukem Exp $";
a105 2
	if (isatty(fileno(stdout)))
		progress = 1;		/* progress bar on if going to a tty */
@


1.17
log
@Sync with NetBSD
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: main.c,v 1.17 1997/02/01 10:45:07 lukem Exp $";
d57 1
d62 1
d109 1
a109 1
	while ((ch = getopt(argc, argv, "adginpP:tvV")) != EOF) {
d139 1
a139 1
				warnx("bad port number: %s", optarg);
d144 7
d185 1
a185 1
		(void) strcpy(home, pw->pw_dir);
d212 1
a212 1
	(void) signal(SIGWINCH, setttywidth);
d225 2
a226 2
			(void) signal(SIGINT, intr);
			(void) signal(SIGPIPE, lostpeer);
d232 10
a241 1
			setpeer(argc+1, xargv);
d246 2
a247 2
		(void) signal(SIGINT, intr);
		(void) signal(SIGPIPE, lostpeer);
d270 2
a271 2
			(void) shutdown(fileno(cout), 1+1);
			(void) fclose(cout);
d275 2
a276 2
			(void) shutdown(data, 1+1);
			(void) close(data);
d284 2
a285 2
			(void) shutdown(fileno(cout), 1+1);
			(void) fclose(cout);
d318 1
a318 1
		(void) putchar('\n');
d324 2
a325 2
				printf("%s", prompt());
				(void) fflush(stdout);
d337 1
a337 1
				printf("sorry, input line too long\n");
d353 1
a353 1
				printf("sorry, input line too long\n");
d375 1
a375 1
			printf("?Ambiguous command\n");
d379 1
a379 1
			printf("?Invalid command\n");
d383 1
a383 1
			printf("Not connected.\n");
d389 1
a389 1
			(void) putchar('\007');
d393 2
a394 2
	(void) signal(SIGINT, intr);
	(void) signal(SIGPIPE, lostpeer);
d631 1
a631 1
#define HELPINDENT ((int) sizeof ("disconnect"))
d652 1
a652 1
	    "usage: %s [-adginptvV] [host [port]]\n"
@


1.16
log
@Break out of infinite loop ftp://home.host/som/path mode if host
does not exist.  Also, use herror, not perror if gethostbynam() fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 1997/01/25 21:42:33 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.15 1997/01/25 21:42:33 deraadt Exp $";
a52 1
/*#include <sys/ioctl.h>*/
a53 1
#include <sys/file.h>
a54 1
#include <netinet/in.h>
a55 3
#include <arpa/ftp.h>

#include <ctype.h>
a58 1
#include <signal.h>
a59 1
#include <stdlib.h>
a64 2
#define HASHBYTES 1024	/* default buffer size for drawing hash marks */

d70 2
a71 1
	int ch, top;
a73 1
	int force_port = 0;
d77 8
a84 1
		errx(1, "ftp/tcp: unknown service");
d88 4
d93 1
d95 12
a106 1
	while ((ch = getopt(argc, argv, "p:r:dgintv")) != -1) {
d108 4
d116 1
a116 1
			
d130 1
a130 1
			force_port = atoi(optarg);
d133 6
a138 10
		case 'r':
			if (isdigit(*optarg))
				retry_connect = atoi(optarg);
			else {
				extern char *__progname;
				(void)fprintf(stderr,
					"%s: -r requires numeric argument\n",
					__progname);
				exit(1);
			}
d142 1
a142 1
			trace++;
d146 5
a150 1
			verbose++;
d154 1
a154 3
			(void)fprintf(stderr, "usage: "
				"ftp [-dgintv] [-r<seconds>] [host [port]]\n");
			exit(1);
a159 3
	fromatty = isatty(fileno(stdin));
	if (fromatty)
		verbose++;
a161 1
	passivemode = 0; /* passive mode not active */
d178 22
a199 3
	if (argc > 0 && strchr(argv[0], ':')) {
		int ret = 0;
		anonftp = 1;
d201 10
a210 1
		while (argc > 0 && strchr(argv[0], ':')) {
a211 4
			extern char *__progname;
			char portstr[20], *p, *bufp = NULL;
			char *host = NULL, *dir = NULL, *file = NULL;
			int xargc = 2, looping = 0, tmp;
d218 5
a222 87

			host = strdup(argv[0]);
			if (host == NULL) {
				ret = 1;
				goto bail;
			}
			if (!strncmp(host, "http://", sizeof("http://") - 1)) {
				ret = http_fetch(host);
				argc--;
				argv++;
				goto bail;
			}
			if (strncmp(host, "ftp://", sizeof("ftp://") - 1) ==
			    0) {
				host += sizeof("ftp://") - 1;
				p = strchr(host, '/');
			}
			else
				p = strchr(host, ':');
			*p = '\0';

			xargv[1] = host;
			xargc = 2;
			if (force_port) {
				xargv[xargc++] = portstr;
				snprintf(portstr, sizeof portstr, "%d",
				    force_port);
			}
			xargv[xargc] = NULL;
		   	setpeer(xargc, xargv);
			if (!connected) {
				printf("failed to connect to %s\n", host);
				ret = 1;
				argc--;
				argv++;
				goto bail;
			}
			*argv = p + 1;
			do {
				dir = *argv;
				p = strrchr(dir, '/');
				if (p != NULL) {
					*p = '\0';
					file = ++p;
				} else {
					file = dir;
					dir = NULL;
				}
				if (dir != NULL && *dir != '\0') {
					xargv[1] = dir;
					xargv[2] = NULL;
					xargc = 2;
					cd(xargc, xargv);
				}
				xargv[1] = *file == '\0' ? "/" : file;
				xargv[2] = NULL;
				xargc = 2;
				tmp = verbose;
				verbose = -1;
				if (mcd(xargc, xargv) == 0) {
					verbose = tmp;
					goto CLINE_CD;
				}
				verbose = tmp;
				if (!looping) {
					setbinary(NULL, 0);
					looping = 1;
				}
				/* fetch file */
				xargv[1] = file;
				xargv[2] = NULL;
				xargc = 2;
				get(xargc, xargv);
				if (code != 226)
					ret = 1;
				--argc;
				argv++;
			} while (argc > 0 && strchr(argv[0], ':') == NULL);

			/* get ready for the next file */
bail:
			if (bufp) {
				free(bufp);
				bufp = NULL;
			}
			if (connected)
				disconnect(1, xargv);
a223 1
		exit(ret);
a224 25
	if (argc > 0) {
		char *xargv[5];
		extern char *__progname;

		if (setjmp(toplevel))
			exit(0);
		(void) signal(SIGINT, intr);
		(void) signal(SIGPIPE, lostpeer);
		xargv[0] = __progname;
		xargv[1] = argv[0];
		xargv[2] = argv[1];
		xargv[3] = argv[2];
		xargv[4] = NULL;
		do {
			setpeer(argc+1, xargv);
			if (!retry_connect)
				break;
			if (!connected) {
				macnum = 0;
				printf("Retrying...\n");
				sleep(retry_connect);
			}
		} while (!connected);
	}
CLINE_CD:
d240 1
d248 1
d276 2
d279 1
a279 2
tail(filename)
	char *filename;
d281 1
a281 11
	char *s;
	
	while (*filename) {
		s = strrchr(filename, '/');
		if (s == NULL)
			break;
		if (s[1])
			return (s + 1);
		*s = '\0';
	}
	return (filename);
a282 1
*/
d292 1
a292 1
	int l;
d294 5
a298 1
	if (!top)
d301 34
a334 11
		if (fromatty) {
			printf("ftp> ");
			(void) fflush(stdout);
		}
		if (fgets(line, sizeof line, stdin) == NULL)
			quit(0, 0);
		l = strlen(line);
		if (l == 0)
			break;
		if (line[--l] == '\n') {
			if (l == 0)
d336 7
a342 7
			line[l] = '\0';
		} else if (l == sizeof(line) - 2) {
			printf("sorry, input line too long\n");
			while ((l = getchar()) != '\n' && l != EOF)
				/* void */;
			break;
		} /* else it was a line without a newline */
d344 1
a344 1
		if (margc == 0) {
d346 8
a353 1
		}
d367 1
d380 1
a380 1
	char *name;
d382 1
a382 1
	char *p, *q;
d392 1
a392 1
	for (c = cmdtab; p = c->c_name; c++) {
d419 1
a419 1
	char **argp;
a420 1
	argp = margv;
d424 1
d426 3
a428 13
		/* Expand array if necessary */
		if (margc == margvlen) {
			margv = (margvlen == 0)
				? (char **)malloc(20 * sizeof(char *))
				: (char **)realloc(margv,
					(margvlen + 20)*sizeof(char *));
			if (margv == NULL)
				errx(1, "cannot realloc argv array");
			margvlen += 20;
			argp = margv + margc;
		}

		if ((*argp++ = slurpstring()) == NULL)
d431 10
d442 11
a452 1
}
d471 1
a471 1
				stringbase++;
d491 2
a492 1
		sb++; goto S0;
d518 2
a519 1
		sb++; goto S2;	/* slurp next character */
d522 2
a523 1
		sb++; goto S3;	/* slurp quoted string */
d526 3
a528 1
		*ap++ = *sb++;	/* add character to token */
d540 3
a542 1
		*ap++ = *sb++;
d554 2
a555 1
		sb++; goto S1;
d558 3
a560 1
		*ap++ = *sb++;
a586 2
#define HELPINDENT ((int) sizeof ("directory"))

d599 1
a599 2
		int i, j, w, k;
		int columns, width = 0, lines;
d601 8
a608 34
		printf("Commands may be abbreviated.  Commands are:\n\n");
		for (c = cmdtab; c < &cmdtab[NCMDS]; c++) {
			int len = strlen(c->c_name);

			if (len > width)
				width = len;
		}
		width = (width + 8) &~ 7;
		columns = 80 / width;
		if (columns == 0)
			columns = 1;
		lines = (NCMDS + columns - 1) / columns;
		for (i = 0; i < lines; i++) {
			for (j = 0; j < columns; j++) {
				c = cmdtab + j * lines + i;
				if (c->c_name && (!proxy || c->c_proxy)) {
					printf("%s", c->c_name);
				}
				else if (c->c_name) {
					for (k=0; k < strlen(c->c_name); k++) {
						(void) putchar(' ');
					}
				}
				if (c + lines >= &cmdtab[NCMDS]) {
					printf("\n");
					break;
				}
				w = strlen(c->c_name);
				while (w < width) {
					w = (w + 8) &~ 7;
					(void) putchar('\t');
				}
			}
		}
d611 3
d616 1
d627 12
@


1.15
log
@split cd() into two pieces, whoever was here last did a bad job
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 1997/01/15 23:42:31 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.14 1997/01/15 23:42:31 millert Exp $";
d216 2
@


1.14
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 1997/01/09 11:22:16 niklas Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.13 1997/01/09 11:22:16 niklas Exp $";
d240 1
a240 1
				if (cd(xargc, xargv) == 0) {
@


1.13
log
@HTTP fetches would always loop indefinitely
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 1997/01/07 22:03:39 niklas Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.12 1997/01/07 22:03:39 niklas Exp $";
d93 1
a93 1
	while ((ch = getopt(argc, argv, "p:r:dgintv")) != EOF) {
@


1.12
log
@some strlen(constant) -> sizeof(ditto) - 1, plus make ftp://host/path work
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 1996/12/18 01:59:15 michaels Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 1996/12/18 01:59:15 michaels Exp $";
d190 3
a192 1
				http_fetch(host);
@


1.11
log
@Return exit status != 0 if any transfers fail in the commandline
specified file fetch mode.  Makes backup locations in the ports system work.
@
text
@d189 1
a189 1
			if (!strncmp(host, "http://", strlen("http://"))) {
d193 3
a195 2
			if (strncmp(host, "ftp://", strlen("ftp://")) == 0) {
				host += strlen("ftp://");
d216 1
a216 1
			*argv = strchr(argv[0], ':') + 1;
@


1.10
log
@support getting multiple files at once, e.g
"ftp host:pub/tst/test /pub/tst/test2 /pub/tst" will get files
"test", then "test2" and then the cd to "pub/tst" on the same host and
become interactive without closing/reopening connection each time.
(needs leading '/' on every path but the first, as the rest are
relative to the first. (a feauture, really))
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1996/12/17 02:11:45 michaels Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 1996/12/17 02:11:45 michaels Exp $";
d251 2
d255 1
a255 1
		} while (argc > 0 && strchr(argv[0], ':') == NULL);
@


1.9
log
@if pathname given is a valid directory, cd to it at remote, also
assume empty pathname means cd to '/', like ncftp (?).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1996/10/31 14:36:57 mickey Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 1996/10/31 14:36:57 mickey Exp $";
d176 1
a176 1
			int xargc = 2, tmp;
d193 2
a194 2
			if (strncmp(host, "ftp://", sizeof("ftp://")-1) == 0) {
				host += sizeof("ftp://") - 1;
d196 2
a197 1
			} else
a199 9
			dir = ++p;
			p = strrchr(p, '/');
			if (p) {
				*p = '\0';
				file = ++p;
			} else {
				file = dir;
				dir = NULL;
			}
d209 1
a209 1
			setpeer(xargc, xargv);
d215 18
a232 3

			if (dir != NULL && *dir != '\0') {
				xargv[1] = dir;
d235 6
a240 13
				cd(xargc, xargv);
			}
			/*
		 	 * either "file" is the file user wants, or he wants
			 * to cd to "file" aswell, so try cd first, after
			 * switcing of verbose (already got a CWD from above).
			*/
			xargv[1] = *file == '\0' ? "/" : file;
			xargv[2] = NULL;
			xargc = 2;
			tmp = verbose;
			verbose = 0;
			if (cd(xargc, xargv) == 0) {
d242 12
a253 10
				goto CLINE_CD;
			}
			verbose = tmp;
			setbinary(NULL, 0);

			/* fetch file */
			xargv[1] = file;
			xargv[2] = NULL;
			xargc = 2;
			get(xargc, xargv);
a262 2
			--argc;
			argv++;
@


1.8
log
@optional size argument to hash command
@
text
@d166 1
d176 1
a176 1
			int xargc = 2;
d224 1
a224 3
			setbinary(NULL, 0);

			if (dir) {
d230 16
d290 1
@


1.7
log
@add -r<seconds> option to retry connection.
dunno how to do optional argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 1996/09/03 18:00:06 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.6 1996/09/03 18:00:06 deraadt Exp $";
d73 2
d91 1
@


1.6
log
@http:// support for the command line fetches; useful for the ports subsystem
and other scripts. written by brian@@saturn.net (and then i clawed at it for
a bit..)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1996/06/26 05:33:38 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1996/06/26 05:33:38 deraadt Exp $";
d90 1
a90 1
	while ((ch = getopt(argc, argv, "p:dgintv")) != EOF) {
d113 12
d134 2
a135 2
			(void)fprintf(stderr,
				"usage: ftp [-dgintv] [host [port]]\n");
a205 1
			xargv[2] = NULL;
d208 1
a208 1
				xargv[2] = portstr;
a210 1
				xargc++;
d212 1
d261 10
a270 1
		setpeer(argc+1, xargv);
@


1.5
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: main.c,v 1.11 1996/05/07 00:16:55 pk Exp $";
d55 1
d57 1
d173 4
a176 1

d226 1
a226 1
			if (bufp)
d228 2
@


1.4
log
@handle ftp://host/path
@
text
@d1 2
d46 1
a46 1
static char rcsid[] = "$NetBSD: main.c,v 1.11 1996/05/07 00:16:55 pk Exp $";
@


1.3
log
@add support for automatic anonftp fetches of host:path
add support for -p portnum
might need todo: -N for silence, better exit status for failures
@
text
@d154 2
a155 1
			char portstr[20], *p, *bufp;
d164 11
a174 3
			/* connect to host */
			bufp = xargv[1] = strdup(argv[0]);
			p = strchr(xargv[1], ':');
d176 11
d188 1
d197 1
a197 1
				printf("failed to connect to %s\n", xargv[1]);
a200 1
			free(bufp);
d204 5
a208 5
			/* cd into correct directory */
			bufp = xargv[1] = strdup(argv[0]);
			if (xargv[1] == NULL) {
				ret = 1;
				goto bail;
a209 9
			xargv[1] = strchr(xargv[1], ':');
			xargv[1]++;
			p = strrchr(xargv[1], '/');
			if (p)
				*p = '\0';
			xargv[2] = NULL;
			xargc = 2;
			cd(xargc, xargv);
			free(bufp);
d212 1
a212 10
			bufp = xargv[1] = strdup(argv[0]);
			if (xargv[1] == NULL) {
				ret = 1;
				goto bail;
			}
			xargv[1] = strchr(xargv[1], ':');
			xargv[1]++;
			p = strrchr(xargv[1], '/');
			if (p)
				xargv[1] = p + 1;
a215 1
			free(bufp);
d219 2
@


1.2
log
@Fence off NULL args in getcmd() (fixes/works around PR#824)
@
text
@d77 1
d86 1
a86 1
	while ((ch = getopt(argc, argv, "dgintv")) != EOF) {
d105 4
d146 78
@


1.1
log
@Initial revision
@
text
@d44 1
a44 1
static char rcsid[] = "$NetBSD: main.c,v 1.10 1995/09/15 00:32:33 pk Exp $";
d290 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
