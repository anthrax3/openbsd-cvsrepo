head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.2
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.16
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.14
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.12
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.10
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.8
	OPENBSD_5_0:1.26.0.6
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.19.0.8
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.14
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.12
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.10
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.8
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7;
locks; strict;
comment	@ * @;


1.30
date	2017.01.21.08.33.07;	author krw;	state Exp;
branches;
next	1.29;
commitid	l2fu419jw6ah0BY2;

1.29
date	2015.10.18.03.04.11;	author mmcc;	state Exp;
branches;
next	1.28;
commitid	QQdb0QX6CyUg58R7;

1.28
date	2015.01.16.06.40.08;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	Uu5nFG3wCl0LACBb;

1.27
date	2014.04.23.11.47.04;	author jca;	state Exp;
branches;
next	1.26;

1.26
date	2010.04.26.16.51.59;	author stsp;	state Exp;
branches;
next	1.25;

1.25
date	2010.04.25.14.32.04;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.25.09.11.54;	author stsp;	state Exp;
branches;
next	1.23;

1.23
date	2009.05.05.19.35.30;	author martynas;	state Exp;
branches;
next	1.22;

1.22
date	2009.04.27.21.37.13;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.08.21.07.57;	author martynas;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.26.05.42.20;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.23.20.35.25;	author steven;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.25.05.45.20;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.16.04.39.16;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.20.03.50.25;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.09.17.11.22;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.05.17.19.47;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.46;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.03.22.43.16;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.26.23.44.00;	author lebel;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.09.17.01.02;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.09.04.04.37.14;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.25.21.56.18;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.04.23.20.33.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.04.16.05.02.43;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.03.21.20.59.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.03.14.04.32.13;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.02.05.04.55.14;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.02.03.01.05.35;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.02.03.01.02.34;	author millert;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: complete.c,v 1.29 2015/10/18 03:04:11 mmcc Exp $	*/
/*	$NetBSD: complete.c,v 1.10 1997/08/18 10:20:18 lukem Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Luke Mewburn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef SMALL

/*
 * FTP user program - command and file completion routines
 */

#include <ctype.h>
#include <err.h>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ftp_var.h"

static int	     comparstr(const void *, const void *);
static unsigned char complete_ambiguous(char *, int, StringList *);
static unsigned char complete_command(char *, int);
static unsigned char complete_local(char *, int);
static unsigned char complete_remote(char *, int);
static void          ftpvis(char *, size_t, const char *, size_t);

static int
comparstr(const void *a, const void *b)
{
	return (strcmp(*(char **)a, *(char **)b));
}

/*
 * Determine if complete is ambiguous. If unique, insert.
 * If no choices, error. If unambiguous prefix, insert that.
 * Otherwise, list choices. words is assumed to be filtered
 * to only contain possible choices.
 * Args:
 *	word	word which started the match
 *	list	list by default
 *	words	stringlist containing possible matches
 */
static unsigned char
complete_ambiguous(char *word, int list, StringList *words)
{
	char insertstr[PATH_MAX * 2];
	char *lastmatch;
	int i, j;
	size_t matchlen, wordlen;

	wordlen = strlen(word);
	if (words->sl_cur == 0)
		return (CC_ERROR);	/* no choices available */

	if (words->sl_cur == 1) {	/* only once choice available */
		char *p = words->sl_str[0] + wordlen;
		ftpvis(insertstr, sizeof(insertstr), p, strlen(p));
		if (el_insertstr(el, insertstr) == -1)
			return (CC_ERROR);
		else
			return (CC_REFRESH);
	}

	if (!list) {
		lastmatch = words->sl_str[0];
		matchlen = strlen(lastmatch);
		for (i = 1 ; i < words->sl_cur ; i++) {
			for (j = wordlen ; j < strlen(words->sl_str[i]); j++)
				if (lastmatch[j] != words->sl_str[i][j])
					break;
			if (j < matchlen)
				matchlen = j;
		}
		if (matchlen > wordlen) {
			ftpvis(insertstr, sizeof(insertstr),
			    lastmatch + wordlen, matchlen - wordlen);
			if (el_insertstr(el, insertstr) == -1)
				return (CC_ERROR);
			else
					/*
					 * XXX: really want CC_REFRESH_BEEP
					 */
				return (CC_REFRESH);
		}
	}

	putc('\n', ttyout);
	qsort(words->sl_str, words->sl_cur, sizeof(char *), comparstr);
	list_vertical(words);
	return (CC_REDISPLAY);
}

/*
 * Complete a command
 */
static unsigned char
complete_command(char *word, int list)
{
	struct cmd *c;
	StringList *words;
	size_t wordlen;
	unsigned char rv;

	words = sl_init();
	wordlen = strlen(word);

	for (c = cmdtab; c->c_name != NULL; c++) {
		if (wordlen > strlen(c->c_name))
			continue;
		if (strncmp(word, c->c_name, wordlen) == 0)
			sl_add(words, c->c_name);
	}

	rv = complete_ambiguous(word, list, words);
	sl_free(words, 0);
	return (rv);
}

/*
 * Complete a local file
 */
static unsigned char
complete_local(char *word, int list)
{
	StringList *words;
	char dir[PATH_MAX];
	char *file;
	DIR *dd;
	struct dirent *dp;
	unsigned char rv;

	if ((file = strrchr(word, '/')) == NULL) {
		dir[0] = '.';
		dir[1] = '\0';
		file = word;
	} else {
		if (file == word) {
			dir[0] = '/';
			dir[1] = '\0';
		} else {
			(void)strlcpy(dir, word, (size_t)(file - word) + 1);
		}
		file++;
	}

	if ((dd = opendir(dir)) == NULL)
		return (CC_ERROR);

	words = sl_init();

	for (dp = readdir(dd); dp != NULL; dp = readdir(dd)) {
		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
			continue;
		if (strlen(file) > dp->d_namlen)
			continue;
		if (strncmp(file, dp->d_name, strlen(file)) == 0) {
			char *tcp;

			tcp = strdup(dp->d_name);
			if (tcp == NULL)
				errx(1, "Can't allocate memory for local dir");
			sl_add(words, tcp);
		}
	}
	closedir(dd);

	rv = complete_ambiguous(file, list, words);
	sl_free(words, 1);
	return (rv);
}

/*
 * Complete a remote file
 */
static unsigned char
complete_remote(char *word, int list)
{
	static StringList *dirlist;
	static char	 lastdir[PATH_MAX];
	StringList	*words;
	char		 dir[PATH_MAX];
	char		*file, *cp;
	int		 i;
	unsigned char	 rv;

	char *dummyargv[] = { "complete", dir, NULL };

	if ((file = strrchr(word, '/')) == NULL) {
		dir[0] = '.';
		dir[1] = '\0';
		file = word;
	} else {
		cp = file;
		while (*cp == '/' && cp > word)
			cp--;
		(void)strlcpy(dir, word, (size_t)(cp - word + 2));
		file++;
	}

	if (dirchange || strcmp(dir, lastdir) != 0) {	/* dir not cached */
		char *emesg;

		sl_free(dirlist, 1);
		dirlist = sl_init();

		mflag = 1;
		emesg = NULL;
		if (debug)
			(void)putc('\n', ttyout);
		while ((cp = remglob(dummyargv, 0, &emesg)) != NULL) {
			char *tcp;

			if (!mflag)
				continue;
			if (*cp == '\0') {
				mflag = 0;
				continue;
			}
			tcp = strrchr(cp, '/');
			if (tcp)
				tcp++;
			else
				tcp = cp;
			tcp = strdup(tcp);
			if (tcp == NULL)
				errx(1, "Can't allocate memory for remote dir");
			sl_add(dirlist, tcp);
		}
		if (emesg != NULL) {
			fprintf(ttyout, "\n%s\n", emesg);
			return (CC_REDISPLAY);
		}
		(void)strlcpy(lastdir, dir, sizeof lastdir);
		dirchange = 0;
	}

	words = sl_init();
	for (i = 0; i < dirlist->sl_cur; i++) {
		cp = dirlist->sl_str[i];
		if (strlen(file) > strlen(cp))
			continue;
		if (strncmp(file, cp, strlen(file)) == 0)
			sl_add(words, cp);
	}
	rv = complete_ambiguous(file, list, words);
	sl_free(words, 0);
	return (rv);
}

/*
 * Generic complete routine
 */
unsigned char
complete(EditLine *el, int ch)
{
	static char word[FTPBUFLEN];
	static int lastc_argc, lastc_argo;
	struct cmd *c;
	const LineInfo *lf;
	int celems, dolist;
	size_t len;

	ch = ch;		/* not used */
	lf = el_line(el);
	len = lf->lastchar - lf->buffer;
	if (len >= sizeof(line))
		return (CC_ERROR);
	(void)memcpy(line, lf->buffer, len);
	line[len] = '\0';
	cursor_pos = line + (lf->cursor - lf->buffer);
	lastc_argc = cursor_argc;	/* remember last cursor pos */
	lastc_argo = cursor_argo;
	makeargv();			/* build argc/argv of current line */

	if (cursor_argo >= sizeof(word))
		return (CC_ERROR);

	dolist = 0;
			/* if cursor and word is same, list alternatives */
	if (lastc_argc == cursor_argc && lastc_argo == cursor_argo
	    && strncmp(word, margv[cursor_argc], cursor_argo) == 0)
		dolist = 1;
	else if (cursor_argo)
		memcpy(word, margv[cursor_argc], cursor_argo);
	word[cursor_argo] = '\0';

	if (cursor_argc == 0)
		return (complete_command(word, dolist));

	c = getcmd(margv[0]);
	if (c == (struct cmd *)-1 || c == 0)
		return (CC_ERROR);
	celems = strlen(c->c_complete);

		/* check for 'continuation' completes (which are uppercase) */
	if ((cursor_argc > celems) && (celems > 0)
	    && isupper((unsigned char)c->c_complete[celems - 1]))
		cursor_argc = celems;

	if (cursor_argc > celems)
		return (CC_ERROR);

	switch (c->c_complete[cursor_argc - 1]) {
	case 'l':			/* local complete */
	case 'L':
		return (complete_local(word, dolist));
	case 'r':			/* remote complete */
	case 'R':
		if (connected != -1) {
			fputs("\nMust be logged in to complete.\n", ttyout);
			return (CC_REDISPLAY);
		}
		return (complete_remote(word, dolist));
	case 'c':			/* command complete */
	case 'C':
		return (complete_command(word, dolist));
	case 'n':			/* no complete */
		return (CC_ERROR);
	}

	return (CC_ERROR);
}

/*
 * Copy characters from src into dst, \ quoting characters that require it.
 */
static void
ftpvis(char *dst, size_t dstlen, const char *src, size_t srclen)
{
	size_t	di, si;

	di = si = 0;
	while (di + 1 < dstlen && si < srclen && src[si] != '\0') {
		switch (src[si]) {
		case '\\':
		case ' ':
		case '\t':
		case '\r':
		case '\n':
		case '"':
			/* Need room for two characters and NUL, avoiding
			 * incomplete escape sequences at end of dst. */
			if (di + 3 >= dstlen)
				break;
			dst[di++] = '\\';
			/* FALLTHROUGH */
		default:
			dst[di++] = src[si++];
		}
	}
	if (dstlen != 0)
		dst[di] = '\0';
}
#endif /* !SMALL */
@


1.29
log
@A whole buncha unsigned char casts for ctype function arguments.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.28 2015/01/16 06:40:08 deraadt Exp $	*/
d107 1
a107 1
			else	
@


1.28
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.27 2014/04/23 11:47:04 jca Exp $	*/
d325 1
a325 1
	    && isupper(c->c_complete[celems-1]))
@


1.27
log
@Kill useless assignement, matchlen is initialized two lines below.
From Fritjof Bornebusch.
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.26 2010/04/26 16:51:59 stsp Exp $	*/
d74 1
a74 1
	char insertstr[MAXPATHLEN * 2];
d154 1
a154 1
	char dir[MAXPATHLEN];
d207 1
a207 1
	static char	 lastdir[MAXPATHLEN];
d209 1
a209 1
	char		 dir[MAXPATHLEN];
@


1.26
log
@Fix a bug in auto-completion accidentally introduced when support
for auto-completion of filenames containing whitespace was added.
This bug was tracked a decade ago in NetBSD as pr 7014.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.25 2010/04/25 14:32:04 tedu Exp $	*/
a92 1
		matchlen = 0;
@


1.25
log
@ftpvis was not ok.  fix it.
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.24 2010/04/25 09:11:54 stsp Exp $	*/
d105 1
a105 1
			    lastmatch + wordlen, matchlen);
@


1.24
log
@Fix auto-completion of filenames containing whitespace.
Before this change whitespace wasn't escaped during completion which
caused the ftp command to see multiple arguments where a single path
was expected.  Based on similar commit made to NetBSD's ftp in 1999.

help and ok uwe tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.23 2009/05/05 19:35:30 martynas Exp $	*/
a360 8
	/* paranoia paranoia everybody's trying to get me */
	if (dstlen == 0)
		return;
	if (srclen == 0) {
		dst[0] = '\0';
		return;
	}
		
d362 1
a362 1
	while (src[si] != '\0' && di < dstlen && si < srclen) {
d372 1
a372 1
			if (di >= dstlen - 3)
d377 1
a377 3
			dst[di] = src[si++];
			if (di < dstlen)
				di++;
d380 2
a381 1
	dst[di] = '\0';
a382 1

a383 1

@


1.23
log
@make it clean removing the ifdef SMALL maze.  separate cmds and
small stuff.  make it a fetcher.  shrinks quite a bit
agreed by millert@@, krw@@
ok theo, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.22 2009/04/27 21:37:13 deraadt Exp $	*/
d53 1
d74 1
a74 1
	char insertstr[MAXPATHLEN];
d84 3
a86 2
		(void)strlcpy(insertstr, words->sl_str[0], sizeof insertstr);
		if (el_insertstr(el, insertstr + wordlen) == -1)
d104 3
a106 2
			(void)strlcpy(insertstr, lastmatch, matchlen+1);
			if (el_insertstr(el, insertstr + wordlen) == -1)
d351 40
@


1.22
log
@toast the rcsid strings which just get in the way
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.21 2008/07/08 21:07:57 martynas Exp $	*/
a233 1
#ifndef SMALL
a235 1
#endif /* !SMALL */
d351 1
@


1.21
log
@- add support for recursive transfers (but not for floppies), e.g.
'mget -cr 4.*' would recursively fetch (-r), and resume the previous
transfers (-c) of 4.X release directories
uses local matching (fnmatch), but only for recursive transfers.
current behavior is not changed in any way.
- while here, ifndef SMALL debugging stuff, this saves some space,
for floppies
- some debugging code was enabled for non-debugging mode, checks
assume debug is set to zero, but it's not initially set
- all "Confirm with" prompts are forced, remove redundant argument
- fix usage: -C and -c are not available for SMALL

discussed a year ago w/ pyr@@
looks good to millert@@
previous version looked good to pyr@@
man page tweaks & ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.20 2008/06/26 05:42:20 ray Exp $	*/
a33 3
#ifndef lint
static const char rcsid[] = "$OpenBSD: complete.c,v 1.20 2008/06/26 05:42:20 ray Exp $";
#endif /* not lint */
@


1.20
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.19 2006/06/23 20:35:25 steven Exp $	*/
d35 1
a35 1
static const char rcsid[] = "$OpenBSD: complete.c,v 1.19 2006/06/23 20:35:25 steven Exp $";
d237 1
d240 1
@


1.19
log
@free and sl_free already check against NULL, remove a few unneeded ifs.

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.18 2006/04/25 05:45:20 tedu Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d35 1
a35 1
static const char rcsid[] = "$OpenBSD: complete.c,v 1.18 2006/04/25 05:45:20 tedu Exp $";
@


1.18
log
@two strtol calls that were begging to be converted to strtonum
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.17 2004/09/16 04:39:16 deraadt Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: complete.c,v 1.17 2004/09/16 04:39:16 deraadt Exp $";
d239 1
a239 2
		if (dirlist != NULL)
			sl_free(dirlist, 1);
@


1.17
log
@type corrections and other delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.16 2004/07/20 03:50:25 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.16 2004/07/20 03:50:25 deraadt Exp $";
@


1.16
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.15 2004/07/09 17:11:22 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.15 2004/07/09 17:11:22 millert Exp $";
a294 1

d300 1
d341 15
a355 16
		case 'l':			/* local complete */
		case 'L':
			return (complete_local(word, dolist));
		case 'r':			/* remote complete */
		case 'R':
			if (connected != -1) {
				fputs("\nMust be logged in to complete.\n", ttyout);
				return (CC_REDISPLAY);
			}
			return (complete_remote(word, dolist));
		case 'c':			/* command complete */
		case 'C':
			return (complete_command(word, dolist));
		case 'n':			/* no complete */
		default:
			return (CC_ERROR);
@


1.15
log
@You can only use strlcpy() on real C strings, which lf->buffer is not.
Use memcpy() instead and NUL terminate.
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.14 2003/04/05 17:19:47 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.14 2003/04/05 17:19:47 deraadt Exp $";
d65 1
a65 2
comparstr(a, b)
	const void *a, *b;
d81 1
a81 4
complete_ambiguous(word, list, words)
	char *word;
	int list;
	StringList *words;
d133 1
a133 3
complete_command(word, list)
	char *word;
	int list;
d159 1
a159 3
complete_local(word, list)
	char *word;
	int list;
d212 1
a212 3
complete_remote(word, list)
	char *word;
	int list;
d291 1
a291 3
complete(el, ch)
	EditLine *el;
	int ch;
@


1.14
log
@string fixes; ok miod henning
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.13 2002/02/16 21:27:46 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.13 2002/02/16 21:27:46 millert Exp $";
d317 2
a318 1
	(void)strlcpy(line, lf->buffer, len+1);
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.12 2001/08/03 22:43:16 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.12 2001/08/03 22:43:16 millert Exp $";
d97 1
a97 1
		(void)strcpy(insertstr, words->sl_str[0]);
d280 1
a280 1
		(void)strcpy(lastdir, dir);
@


1.12
log
@Add back NUL termination of 'word' in complete() that was erroneously
removed in strlcpy() conversion.  Previously we were trying to
strlcpy() a pointer that could be NULL.  Now we check that the
length != 0 and use memcpy() instead, then NUL terminate by hand
to catch the other cases.  Core dump noticed by fgs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.11 2001/06/26 23:44:00 lebel Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.11 2001/06/26 23:44:00 lebel Exp $";
d58 5
a62 5
static int	     comparstr		__P((const void *, const void *));
static unsigned char complete_ambiguous	__P((char *, int, StringList *));
static unsigned char complete_command	__P((char *, int));
static unsigned char complete_local	__P((char *, int));
static unsigned char complete_remote	__P((char *, int));
@


1.11
log
@use strlcpy vs strncpy+a[len-1]='\0'.  millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.10 2001/03/09 17:01:02 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.10 2001/03/09 17:01:02 millert Exp $";
d331 3
a333 2
	else
	    (void)strlcpy(word, margv[cursor_argc], cursor_argo+1);
@


1.10
log
@Add a missing newline in debug mode to separate debug output from
line containing command completion; "Brian J. Kifiak" <bk@@rt.fm>
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.9 1997/09/04 04:37:14 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.9 1997/09/04 04:37:14 millert Exp $";
d116 1
a116 2
			(void)strncpy(insertstr, lastmatch, matchlen);
			insertstr[matchlen] = '\0';
d185 1
a185 2
			(void)strncpy(dir, word, (size_t)(file - word));
			dir[file - word] = '\0';
d242 1
a242 2
		(void)strncpy(dir, word, (size_t)(cp - word + 1));
		dir[cp - word + 1] = '\0';
d317 1
a317 2
	(void)strncpy(line, lf->buffer, len);
	line[len] = '\0';
d332 1
a332 2
	    (void)strncpy(word, margv[cursor_argc], cursor_argo);
	word[cursor_argo] = '\0';
@


1.9
log
@Updtaes from NetBSD (lukem)
    bugs fixed:
      * don't interpret '-' or '|' when a local filename is determined from
        the remote name (i.e, in mget, and in get with only one argument).
        This is implemented using an extra argument to recvrequest().
        Fixes a major security hole.
      * clean up memory leak when using globulize()
      * clean up a couple of comments
      * fix wording in TNF copyright

    features added:
      * support for TIS fwtk gate-ftp servers:
        * read defaults from $FTPSERVER && $FTPSERVERPORT
        * start in gate-ftp mode if invoked as 'gate-ftp'
        * toggle or set with 'gate [host [port]]'

Other changes:
    * use symbolic flags in access(2)
    * Use USHRT_MAX, not 0xffff
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.8 1997/07/25 21:56:18 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.8 1997/07/25 21:56:18 millert Exp $";
d258 2
@


1.8
log
@Updates from NetBSD (lukem) include -Wall cleanup.
More -W* cleanup and in_port_t usage by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: complete.c,v 1.7 1997/04/23 20:33:00 deraadt Exp $	*/
/*	$NetBSD: complete.c,v 1.9 1997/07/20 09:45:43 lukem Exp $	*/
d30 2
a31 2
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.7 1997/04/23 20:33:00 deraadt Exp $";
@


1.7
log
@allow "ftp -aV ftp://host/foo.tar.gz | tar xvfpz -" to work
@
text
@d1 2
a2 2
/*	$OpenBSD: complete.c,v 1.6 1997/04/16 05:02:43 millert Exp $	*/
/*	$NetBSD: complete.c,v 1.7 1997/04/14 09:09:16 lukem Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.6 1997/04/16 05:02:43 millert Exp $";
d58 6
d89 2
a90 1
	int i, j, matchlen, wordlen;
d144 1
a144 1
	int wordlen;
d186 1
a186 1
			(void)strncpy(dir, word, file - word);
d244 2
a245 7
		if (cp == word) {
			dir[0] = '/';
			dir[1] = '\0';
		} else {
			(void)strncpy(dir, word, cp - word + 1);
			dir[cp - word + 1] = '\0';
		}
a250 1
		int dirlen, ftpdslashbug;
a251 8
		dirlen = strlen(dir);
		ftpdslashbug = 0;
		if (strcmp(dir, "/") == 0)
			ftpdslashbug = 1;
		else if (strcmp(dir, ".") == 0)
			dirlen = 0;
		else
			dirlen++;
d267 6
a272 9
			/*
			 * Work around ftpd(1) bug, which puts a // instead
			 * of / in front of each filename returned by "NLST /".
			 * Without this, remote completes of / don't work.
			 * However, only do this if the bug is present.
			 */
			if (ftpdslashbug && (cp[dirlen] != '/'))
				ftpdslashbug = 0;
			tcp = strdup(cp + dirlen + ftpdslashbug);
d311 2
a312 1
	int len, celems, dolist;
d374 2
a375 1
#endif
@


1.6
log
@Sync with NetBSD (lukem):
 * differentiate between being connected, and being logged in
 * cleanup some text messages
 * support username & password ftp URLs (ftp://user:pass@@host/) in non-proxy
   situations; assume proxy supports it for proxy situations.
 * cd to / before performing any autofetch transfers
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.5 1997/03/21 20:59:28 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.5 1997/03/21 20:59:28 millert Exp $";
d121 1
a121 1
	putchar('\n');
d288 1
a288 1
			printf("\n%s\n", emesg);
d369 1
a369 1
				puts("\nMust be logged in to complete.");
@


1.5
log
@Add in recent NetBSD changes we didn't already have:
    Always compile complete.c but ifdef out the bits if -DSMALL (christos)
    reset interactive mode correctly in auto_fetch() mget mode (lukem)
@
text
@d1 2
a2 2
/*	$OpenBSD: complete.c,v 1.4 1997/03/14 04:32:13 millert Exp $	*/
/*	$NetBSD: complete.c,v 1.6 1997/03/16 14:24:16 lukem Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.4 1997/03/14 04:32:13 millert Exp $";
d368 2
a369 2
			if (!connected) {
				puts("\nMust be connected to complete.");
@


1.4
log
@Sync with NetBSD and fix "get foo.txt /dev/tty" wrt progress meter
and setting times.
@
text
@d1 2
a2 2
/*	$OpenBSD: complete.c,v 1.3 1997/02/05 04:55:14 millert Exp $	*/
/*	$NetBSD: complete.c,v 1.3 1997/03/13 06:23:13 lukem Exp $	*/
d40 1
d42 1
a42 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.3 1997/02/05 04:55:14 millert Exp $";
d90 1
a90 1
		strcpy(insertstr, words->sl_str[0]);
d109 1
a109 1
			strncpy(insertstr, lastmatch, matchlen);
d171 2
a172 1
		strcpy(dir, ".");
d175 5
a179 4
		if (file == word)
			strcpy(dir, "/");
		else {
			strncpy(dir, word, file - word);
d182 1
a182 1
		++file;
d230 2
a231 1
		(void)strcpy(dir, ".");
d327 1
a327 1
	strncpy(line, lf->buffer, len);
d343 1
a343 1
	    strncpy(word, margv[cursor_argc], cursor_argo);
d383 1
@


1.3
log
@Include signal.h where reasonable and make signal handlers match
what signal(3)'s prototype says (and cast when not).
Also change MAXFOO+1 -> MAXFOO since MAXFOO includes the NULL.
Support $TMPDIR and use utime(3) not utimes(2) for portability's sake.
Don't spew "Passive mode enabled/disabled" unless verbose (this means
togglevar() needs to watch for a NULL 'message').
@
text
@d1 2
a2 2
/*	$OpenBSD: complete.c,v 1.2 1997/02/03 01:05:35 millert Exp $	*/
/*	$NetBSD: complete.c,v 1.2 1997/02/01 10:44:57 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.2 1997/02/03 01:05:35 millert Exp $";
d61 1
a61 1
	return strcmp(*(char **)a, *(char **)b);
d86 1
a86 1
		return CC_ERROR;	/* no choices available */
d91 1
a91 1
			return CC_ERROR;
d93 1
a93 1
			return CC_REFRESH;
d111 1
a111 1
				return CC_ERROR;
d116 1
a116 1
				return CC_REFRESH;
d123 1
a123 1
	return CC_REDISPLAY;
d151 1
a151 1
	return rv;
d183 1
a183 1
		return CC_ERROR;
d205 1
a205 1
	return rv;
a217 1
	static int	 ftpdslashbug;
d221 1
a221 1
	int		 i, offset;
a225 1
	offset = 0;
d227 1
a227 1
		strcpy(dir, ".");
d230 9
a238 7
		if (file == word)
			strcpy(dir, "/");
		else {
			offset = file - word;
			strncpy(dir, word, offset);
			dir[offset] = '\0';
			offset++;
d244 11
a258 1
		ftpdslashbug = 0;
d260 2
a261 1
		while ((cp = remglob(dummyargv, 0)) != NULL) {
d273 2
a274 1
			 * Without this, remote completes of / look ugly.
d276 3
a278 6
			if (dir[0] == '/' && dir[1] == '\0' &&
			    cp[0] == '/' && cp[1] == '/') {
				cp++;
				ftpdslashbug = 1;
			}
			tcp = strdup(cp);
d283 5
a287 1
		strcpy(lastdir, dir);
d294 1
a294 1
		if (strlen(word) > strlen(cp))
d296 2
a297 2
		if (strncmp(word, cp, strlen(word)) == 0)
			sl_add(words, cp + offset + ftpdslashbug);
d301 1
a301 1
	return rv;
d322 1
a322 1
		return CC_ERROR;
d331 1
a331 1
		return CC_ERROR;
d343 1
a343 1
		return complete_command(word, dolist);
d347 1
a347 1
		return CC_ERROR;
d356 1
a356 1
		return CC_ERROR;
d361 1
a361 1
			return complete_local(word, dolist);
d365 2
a366 2
				puts("\nMust be connected to complete");
				return CC_REDISPLAY;
d368 1
a368 1
			return complete_remote(word, dolist);
d371 1
a371 1
			return complete_command(word, dolist);
d374 1
a374 1
			return CC_ERROR;
d377 1
a377 1
	return CC_ERROR;
@


1.2
log
@Add back ``-r'' option and fix strncpy() usage and other nits because
I'm anal.  Closer to KNF now.
@
text
@d1 1
a1 1
/*	$OpenBSD: complete.c,v 1.2 1997/02/01 10:44:57 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: complete.c,v 1.2 1997/02/01 10:44:57 lukem Exp $";
d80 1
a80 1
	char insertstr[MAXPATHLEN + 1];
d163 1
a163 1
	char dir[MAXPATHLEN + 1];
d217 1
a217 1
	static char	 lastdir[MAXPATHLEN + 1];
d220 1
a220 1
	char		 dir[MAXPATHLEN + 1];
@


1.1
log
@Sync with NetBSD
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: complete.c,v 1.2 1997/02/01 10:44:57 lukem Exp $";
d352 1
a352 1
				printf("\nMust be connected to complete\n");
@
