head	1.84;
access;
symbols
	OPENBSD_6_0:1.77.0.2
	OPENBSD_6_0_BASE:1.77
	OPENBSD_5_9:1.76.0.2
	OPENBSD_5_9_BASE:1.76
	OPENBSD_5_8:1.72.0.4
	OPENBSD_5_8_BASE:1.72
	OPENBSD_5_7:1.70.0.2
	OPENBSD_5_7_BASE:1.70
	OPENBSD_5_6:1.66.0.6
	OPENBSD_5_6_BASE:1.66
	OPENBSD_5_5:1.66.0.2
	OPENBSD_5_5_BASE:1.66
	OPENBSD_5_4:1.64.0.16
	OPENBSD_5_4_BASE:1.64
	OPENBSD_5_3:1.64.0.14
	OPENBSD_5_3_BASE:1.64
	OPENBSD_5_2:1.64.0.12
	OPENBSD_5_2_BASE:1.64
	OPENBSD_5_1_BASE:1.64
	OPENBSD_5_1:1.64.0.10
	OPENBSD_5_0:1.64.0.8
	OPENBSD_5_0_BASE:1.64
	OPENBSD_4_9:1.64.0.6
	OPENBSD_4_9_BASE:1.64
	OPENBSD_4_8:1.64.0.4
	OPENBSD_4_8_BASE:1.64
	OPENBSD_4_7:1.64.0.2
	OPENBSD_4_7_BASE:1.64
	OPENBSD_4_6:1.63.0.4
	OPENBSD_4_6_BASE:1.63
	OPENBSD_4_5:1.56.0.2
	OPENBSD_4_5_BASE:1.56
	OPENBSD_4_4:1.54.0.2
	OPENBSD_4_4_BASE:1.54
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.43.0.2
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.40.0.2
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.39.0.2
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	OPENBSD_3_5:1.37.0.2
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	OPENBSD_3_3:1.31.0.2
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_9:1.24.0.4
	OPENBSD_2_8:1.24.0.2
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	OPENBSD_2_6:1.21.0.6
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.21.0.4
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9;
locks; strict;
comment	@ * @;


1.84
date	2017.01.21.08.33.07;	author krw;	state Exp;
branches;
next	1.83;
commitid	l2fu419jw6ah0BY2;

1.83
date	2017.01.20.01.19.18;	author krw;	state Exp;
branches;
next	1.82;
commitid	P8uCwiDEzQ5BjLe1;

1.82
date	2017.01.11.13.40.24;	author zhuk;	state Exp;
branches;
next	1.81;
commitid	wUPWqLV9OjjrtYC7;

1.81
date	2016.08.20.20.18.42;	author millert;	state Exp;
branches;
next	1.80;
commitid	F2AU4cYS2XzonLey;

1.80
date	2016.08.18.16.23.06;	author millert;	state Exp;
branches;
next	1.79;
commitid	ku5uVo6mFCThpOmQ;

1.79
date	2016.08.14.18.34.48;	author guenther;	state Exp;
branches;
next	1.78;
commitid	PKvTittpF6Ut9SpV;

1.78
date	2016.07.28.21.37.45;	author tedu;	state Exp;
branches;
next	1.77;
commitid	mWujHdKL90lJ6y6i;

1.77
date	2016.03.16.15.41.11;	author krw;	state Exp;
branches;
next	1.76;
commitid	JEVxsRygqcjPtWTf;

1.76
date	2015.12.09.17.55.42;	author mmcc;	state Exp;
branches;
next	1.75;
commitid	nwkkB0Qgo34HsyMP;

1.75
date	2015.10.18.03.41.14;	author deraadt;	state Exp;
branches;
next	1.74;
commitid	ZgYKwFWL8EWAf4kq;

1.74
date	2015.10.18.03.39.37;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	xpq634eKjAMo7Iu6;

1.73
date	2015.10.18.03.04.11;	author mmcc;	state Exp;
branches;
next	1.72;
commitid	QQdb0QX6CyUg58R7;

1.72
date	2015.03.17.19.31.30;	author millert;	state Exp;
branches;
next	1.71;
commitid	0y5bUkEOUrNvvJEO;

1.71
date	2015.03.15.00.41.28;	author millert;	state Exp;
branches;
next	1.70;
commitid	IbVxlqGw2UipKdDr;

1.70
date	2015.02.09.04.10.50;	author tedu;	state Exp;
branches;
next	1.69;
commitid	yV0bTLuocKQjgbU2;

1.69
date	2015.01.30.04.45.45;	author tedu;	state Exp;
branches;
next	1.68;
commitid	AzhkSUz6nBmdvJNd;

1.68
date	2015.01.16.06.40.08;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	Uu5nFG3wCl0LACBb;

1.67
date	2014.08.16.07.49.27;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	VtJEhEZFfTUoD9C5;

1.66
date	2014.01.29.16.58.21;	author dcoppa;	state Exp;
branches;
next	1.65;

1.65
date	2014.01.23.00.39.15;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2009.11.11.17.10.25;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2009.05.10.16.31.17;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2009.05.05.19.35.30;	author martynas;	state Exp;
branches;
next	1.61;

1.61
date	2009.04.27.22.51.51;	author martynas;	state Exp;
branches;
next	1.60;

1.60
date	2009.04.27.21.37.13;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2009.04.26.21.26.03;	author martynas;	state Exp;
branches;
next	1.58;

1.58
date	2009.04.26.10.30.07;	author sthen;	state Exp;
branches;
next	1.57;

1.57
date	2009.04.13.01.47.04;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2009.01.27.22.04.36;	author martynas;	state Exp;
branches;
next	1.55;

1.55
date	2008.08.22.08.52.35;	author sobrado;	state Exp;
branches;
next	1.54;

1.54
date	2008.07.08.21.07.57;	author martynas;	state Exp;
branches;
next	1.53;

1.53
date	2008.06.26.05.42.20;	author ray;	state Exp;
branches;
next	1.52;

1.52
date	2008.06.25.21.15.19;	author martynas;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.16.19.56.04;	author martynas;	state Exp;
branches;
next	1.50;

1.50
date	2008.06.16.12.03.51;	author martynas;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.15.03.09.13;	author martynas;	state Exp;
branches;
next	1.48;

1.48
date	2008.05.13.02.09.38;	author ray;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.06.19.15.33;	author pyr;	state Exp;
branches;
next	1.45;

1.45
date	2006.11.02.01.51.33;	author ray;	state Exp;
branches;
next	1.44;

1.44
date	2006.11.02.01.43.01;	author ray;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.16.23.43.16;	author ray;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.25.05.45.20;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2005.10.12.06.50.42;	author otto;	state Exp;
branches;
next	1.40;

1.40
date	2005.04.11.15.16.50;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2004.09.16.04.39.16;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2004.07.20.03.50.26;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.16.21.46.22;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2003.10.31.08.47.31;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.03.02.56.08;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.04.07.22.15.57;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.05.17.19.47;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.31.23.04.07;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.08.03.30.17;	author fgsch;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.12.00.25.30;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.30.17.45.44;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.19.18.38.01;	author mpech;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.16.21.27.46;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.12.05.17.08;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.18.21.20.17;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.15.18.27.27;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.01.20.53.06;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	99.12.08.12.57.06;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	98.09.22.04.42.49;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.09.19.22.38.56;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	98.05.13.08.59.10;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.04.26.17.52.15;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.03.30.06.59.36;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.11.25.08.10.34;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.09.15.04.57.54;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.09.11.01.55.16;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.09.04.04.37.17;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.08.25.21.41.55;	author jkatz;	state Exp;
branches;
next	1.11;

1.11
date	97.07.25.21.56.23;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.06.10.19.39.54;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.05.11.17.12.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.05.05.20.49.51;	author jkatz;	state Exp;
branches;
next	1.7;

1.7
date	97.04.23.20.33.24;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.04.16.05.02.59;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.04.10.00.17.11;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.03.14.04.32.18;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.02.05.04.55.21;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.02.03.01.05.46;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.02.03.01.02.43;	author millert;	state Exp;
branches;
next	;


desc
@@


1.84
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: util.c,v 1.83 2017/01/20 01:19:18 krw Exp $	*/
/*	$NetBSD: util.c,v 1.12 1997/08/18 10:20:27 lukem Exp $	*/

/*-
 * Copyright (c) 1997-1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Luke Mewburn.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1985, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * FTP User Program -- Misc support routines
 */
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <arpa/ftp.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <glob.h>
#include <poll.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "ftp_var.h"
#include "pathnames.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

static void updateprogressmeter(int);

/*
 * Connect to peer server and
 * auto-login, if possible.
 */
void
setpeer(int argc, char *argv[])
{
	char *host, *port;

	if (connected) {
		fprintf(ttyout, "Already connected to %s, use close first.\n",
		    hostname);
		code = -1;
		return;
	}
#ifndef SMALL
	if (argc < 2)
		(void)another(&argc, &argv, "to");
	if (argc < 2 || argc > 3) {
		fprintf(ttyout, "usage: %s host [port]\n", argv[0]);
		code = -1;
		return;
	}
#endif /* !SMALL */
	if (gatemode)
		port = gateport;
	else
		port = ftpport;
	if (argc > 2)
		port = argv[2];

	if (gatemode) {
		if (gateserver == NULL || *gateserver == '\0')
			errx(1, "gateserver not defined (shouldn't happen)");
		host = hookup(gateserver, port);
	} else
		host = hookup(argv[1], port);

	if (host) {
		int overbose;

		if (gatemode) {
			if (command("PASSERVE %s", argv[1]) != COMPLETE)
				return;
			if (verbose)
				fprintf(ttyout,
				    "Connected via pass-through server %s\n",
				    gateserver);
		}

		connected = 1;
		/*
		 * Set up defaults for FTP.
		 */
		(void)strlcpy(formname, "non-print", sizeof formname);
		form = FORM_N;
		(void)strlcpy(modename, "stream", sizeof modename);
		mode = MODE_S;
		(void)strlcpy(structname, "file", sizeof structname);
		stru = STRU_F;
		(void)strlcpy(bytename, "8", sizeof bytename);
		bytesize = 8;

		/*
		 * Set type to 0 (not specified by user),
		 * meaning binary by default, but don't bother
		 * telling server.  We can use binary
		 * for text files unless changed by the user.
		 */
		(void)strlcpy(typename, "binary", sizeof typename);
		curtype = TYPE_A;
		type = 0;
		if (autologin)
			(void)ftp_login(argv[1], NULL, NULL);

		overbose = verbose;
#ifndef SMALL
		if (!debug)
#endif /* !SMALL */
			verbose = -1;
		if (command("SYST") == COMPLETE && overbose) {
			char *cp, c;
			c = 0;
			cp = strchr(reply_string + 4, ' ');
			if (cp == NULL)
				cp = strchr(reply_string + 4, '\r');
			if (cp) {
				if (cp[-1] == '.')
					cp--;
				c = *cp;
				*cp = '\0';
			}

			fprintf(ttyout, "Remote system type is %s.\n", reply_string + 4);
			if (cp)
				*cp = c;
		}
		if (!strncmp(reply_string, "215 UNIX Type: L8", 17)) {
			if (proxy)
				unix_proxy = 1;
			else
				unix_server = 1;
			if (overbose)
				fprintf(ttyout, "Using %s mode to transfer files.\n",
				    typename);
		} else {
			if (proxy)
				unix_proxy = 0;
			else
				unix_server = 0;
		}
		verbose = overbose;
	}
}

/*
 * login to remote host, using given username & password if supplied
 */
int
ftp_login(const char *host, char *user, char *pass)
{
	char tmp[80], *acctname = NULL, host_name[HOST_NAME_MAX+1];
	char anonpass[LOGIN_NAME_MAX + 1 + HOST_NAME_MAX+1];	/* "user@@hostname" */
	int n, aflag = 0, retry = 0;
	struct passwd *pw;

#ifndef SMALL
	if (user == NULL && !anonftp) {
		if (ruserpass(host, &user, &pass, &acctname) < 0) {
			code = -1;
			return (0);
		}
	}
#endif /* !SMALL */

	/*
	 * Set up arguments for an anonymous FTP session, if necessary.
	 */
	if ((user == NULL || pass == NULL) && anonftp) {
		memset(anonpass, 0, sizeof(anonpass));
		memset(host_name, 0, sizeof(host_name));

		/*
		 * Set up anonymous login password.
		 */
		if ((user = getlogin()) == NULL) {
			if ((pw = getpwuid(getuid())) == NULL)
				user = "anonymous";
			else
				user = pw->pw_name;
		}
		gethostname(host_name, sizeof(host_name));
#ifndef DONT_CHEAT_ANONPASS
		/*
		 * Every anonymous FTP server I've encountered
		 * will accept the string "username@@", and will
		 * append the hostname itself.  We do this by default
		 * since many servers are picky about not having
		 * a FQDN in the anonymous password. - thorpej@@netbsd.org
		 */
		snprintf(anonpass, sizeof(anonpass) - 1, "%s@@",
		    user);
#else
		snprintf(anonpass, sizeof(anonpass) - 1, "%s@@%s",
		    user, hp->h_name);
#endif
		pass = anonpass;
		user = "anonymous";	/* as per RFC 1635 */
	}

tryagain:
	if (retry)
		user = "ftp";		/* some servers only allow "ftp" */

	while (user == NULL) {
		char *myname = getlogin();

		if (myname == NULL && (pw = getpwuid(getuid())) != NULL)
			myname = pw->pw_name;
		if (myname)
			fprintf(ttyout, "Name (%s:%s): ", host, myname);
		else
			fprintf(ttyout, "Name (%s): ", host);
		user = myname;
		if (fgets(tmp, sizeof(tmp), stdin) != NULL) {
			tmp[strcspn(tmp, "\n")] = '\0';
			if (tmp[0] != '\0')
				user = tmp;
		}
		else
			exit(0);
	}
	n = command("USER %s", user);
	if (n == CONTINUE) {
		if (pass == NULL)
			pass = getpass("Password:");
		n = command("PASS %s", pass);
	}
	if (n == CONTINUE) {
		aflag++;
		if (acctname == NULL)
			acctname = getpass("Account:");
		n = command("ACCT %s", acctname);
	}
	if ((n != COMPLETE) ||
	    (!aflag && acctname != NULL && command("ACCT %s", acctname) != COMPLETE)) {
		warnx("Login %s failed.", user);
		if (retry || !anonftp)
			return (0);
		else
			retry = 1;
		goto tryagain;
	}
	if (proxy)
		return (1);
	connected = -1;
#ifndef SMALL
	for (n = 0; n < macnum; ++n) {
		if (!strcmp("init", macros[n].mac_name)) {
			(void)strlcpy(line, "$init", sizeof line);
			makeargv();
			domacro(margc, margv);
			break;
		}
	}
#endif /* SMALL */
	return (1);
}

/*
 * `another' gets another argument, and stores the new argc and argv.
 * It reverts to the top level (via main.c's intr()) on EOF/error.
 *
 * Returns false if no new arguments have been added.
 */
#ifndef SMALL
int
another(int *pargc, char ***pargv, const char *prompt)
{
	int len = strlen(line), ret;

	if (len >= sizeof(line) - 3) {
		fputs("sorry, arguments too long.\n", ttyout);
		intr();
	}
	fprintf(ttyout, "(%s) ", prompt);
	line[len++] = ' ';
	if (fgets(&line[len], (int)(sizeof(line) - len), stdin) == NULL) {
		clearerr(stdin);
		intr();
	}
	len += strlen(&line[len]);
	if (len > 0 && line[len - 1] == '\n')
		line[len - 1] = '\0';
	makeargv();
	ret = margc > *pargc;
	*pargc = margc;
	*pargv = margv;
	return (ret);
}
#endif /* !SMALL */

/*
 * glob files given in argv[] from the remote server.
 * if errbuf isn't NULL, store error messages there instead
 * of writing to the screen.
 * if type isn't NULL, use LIST instead of NLST, and store filetype.
 * 'd' means directory, 's' means symbolic link, '-' means plain
 * file.
 */
char *
remglob2(char *argv[], int doswitch, char **errbuf, FILE **ftemp, char *type)
{
	char temp[PATH_MAX], *bufp, *cp, *lmode;
	static char buf[PATH_MAX], **args;
	int oldverbose, oldhash, fd;

	if (!mflag) {
		if (!doglob)
			args = NULL;
		else {
			if (*ftemp) {
				(void)fclose(*ftemp);
				*ftemp = NULL;
			}
		}
		return (NULL);
	}
	if (!doglob) {
		if (args == NULL)
			args = argv;
		if ((cp = *++args) == NULL)
			args = NULL;
		return (cp);
	}
	if (*ftemp == NULL) {
		int len;

		cp = _PATH_TMP;
		len = strlen(cp);
		if (len + sizeof(TMPFILE) + (cp[len-1] != '/') > sizeof(temp)) {
			warnx("unable to create temporary file: %s",
			    strerror(ENAMETOOLONG));
			return (NULL);
		}

		(void)strlcpy(temp, cp, sizeof temp);
		if (temp[len-1] != '/')
			temp[len++] = '/';
		(void)strlcpy(&temp[len], TMPFILE, sizeof temp - len);
		if ((fd = mkstemp(temp)) < 0) {
			warn("unable to create temporary file: %s", temp);
			return (NULL);
		}
		close(fd);
		oldverbose = verbose;
		verbose = (errbuf != NULL) ? -1 : 0;
		oldhash = hash;
		hash = 0;
		if (doswitch)
			pswitch(!proxy);
		for (lmode = "w"; *++argv != NULL; lmode = "a")
			recvrequest(type ? "LIST" : "NLST", temp, *argv, lmode,
			    0, 0);
		if ((code / 100) != COMPLETE) {
			if (errbuf != NULL)
				*errbuf = reply_string;
		}
		if (doswitch)
			pswitch(!proxy);
		verbose = oldverbose;
		hash = oldhash;
		*ftemp = fopen(temp, "r");
		(void)unlink(temp);
		if (*ftemp == NULL) {
			if (errbuf == NULL)
				fputs("can't find list of remote files, oops.\n",
				    ttyout);
			else
				*errbuf =
				    "can't find list of remote files, oops.";
			return (NULL);
		}
	}
#ifndef SMALL
again:
#endif
	if (fgets(buf, sizeof(buf), *ftemp) == NULL) {
		(void)fclose(*ftemp);
		*ftemp = NULL;
		return (NULL);
	}

	buf[strcspn(buf, "\n")] = '\0';
	bufp = buf;

#ifndef SMALL
	if (type) {
		parse_list(&bufp, type);
		if (!bufp ||
		    (bufp[0] == '.' &&	/* LIST defaults to -a on some ftp */
		    (bufp[1] == '\0' ||	/* servers.  Ignore '.' and '..'. */
		    (bufp[1] == '.' && bufp[2] == '\0'))))
			goto again;
	}
#endif /* !SMALL */

	return (bufp);
}

/*
 * wrapper for remglob2
 */
char *
remglob(char *argv[], int doswitch, char **errbuf)
{
	static FILE *ftemp = NULL;

	return remglob2(argv, doswitch, errbuf, &ftemp, NULL);
}

#ifndef SMALL
int
confirm(const char *cmd, const char *file)
{
	char str[BUFSIZ];

	if (file && (confirmrest || !interactive))
		return (1);
top:
	if (file)
		fprintf(ttyout, "%s %s? ", cmd, file);
	else
		fprintf(ttyout, "Continue with %s? ", cmd);
	(void)fflush(ttyout);
	if (fgets(str, sizeof(str), stdin) == NULL)
		goto quit;
	switch (tolower((unsigned char)*str)) {
		case '?':
			fprintf(ttyout,
			    "?	help\n"
			    "a	answer yes to all\n"
			    "n	answer no\n"
			    "p	turn off prompt mode\n"
			    "q	answer no to all\n"
			    "y	answer yes\n");
			goto top;
		case 'a':
			confirmrest = 1;
			fprintf(ttyout, "Prompting off for duration of %s.\n",
			    cmd);
			break;
		case 'n':
			return (0);
		case 'p':
			interactive = 0;
			fputs("Interactive mode: off.\n", ttyout);
			break;
		case 'q':
quit:
			mflag = 0;
			clearerr(stdin);
			return (0);
		case 'y':
			return(1);
			break;
		default:
			fprintf(ttyout, "?, a, n, p, q, y "
			    "are the only acceptable commands!\n");
			goto top;
			break;
	}
	return (1);
}
#endif /* !SMALL */

/*
 * Glob a local file name specification with
 * the expectation of a single return value.
 * Can't control multiple values being expanded
 * from the expression, we return only the first.
 */
int
globulize(char **cpp)
{
	glob_t gl;
	int flags;

	if (!doglob)
		return (1);

	flags = GLOB_BRACE|GLOB_NOCHECK|GLOB_QUOTE|GLOB_TILDE;
	memset(&gl, 0, sizeof(gl));
	if (glob(*cpp, flags, NULL, &gl) ||
	    gl.gl_pathc == 0) {
		warnx("%s: not found", *cpp);
		globfree(&gl);
		return (0);
	}
		/* XXX: caller should check if *cpp changed, and
		 *	free(*cpp) if that is the case
		 */
	*cpp = strdup(gl.gl_pathv[0]);
	if (*cpp == NULL)
		err(1, NULL);
	globfree(&gl);
	return (1);
}

/*
 * determine size of remote file
 */
off_t
remotesize(const char *file, int noisy)
{
	int overbose;
	off_t size;

	overbose = verbose;
	size = -1;
#ifndef SMALL
	if (!debug)
#endif /* !SMALL */
		verbose = -1;
	if (command("SIZE %s", file) == COMPLETE) {
		char *cp, *ep;

		cp = strchr(reply_string, ' ');
		if (cp != NULL) {
			cp++;
			size = strtoll(cp, &ep, 10);
			if (*ep != '\0' && !isspace((unsigned char)*ep))
				size = -1;
		}
	} else if (noisy
#ifndef SMALL
	    && !debug
#endif /* !SMALL */
	    ) {
		fputs(reply_string, ttyout);
		fputc('\n', ttyout);
	}
	verbose = overbose;
	return (size);
}

/*
 * determine last modification time (in GMT) of remote file
 */
time_t
remotemodtime(const char *file, int noisy)
{
	int overbose;
	time_t rtime;
	int ocode;

	overbose = verbose;
	ocode = code;
	rtime = -1;
#ifndef SMALL
	if (!debug)
#endif /* !SMALL */
		verbose = -1;
	if (command("MDTM %s", file) == COMPLETE) {
		struct tm timebuf;
		int yy, mo, day, hour, min, sec;
		/*
		 * time-val = 14DIGIT [ "." 1*DIGIT ]
		 *		YYYYMMDDHHMMSS[.sss]
		 * mdtm-response = "213" SP time-val CRLF / error-response
		 */
		/* TODO: parse .sss as well, use timespecs. */
		char *timestr = reply_string;

		/* Repair `19%02d' bug on server side */
		while (!isspace((unsigned char)*timestr))
			timestr++;
		while (isspace((unsigned char)*timestr))
			timestr++;
		if (strncmp(timestr, "191", 3) == 0) {
			fprintf(ttyout,
	    "Y2K warning! Fixed incorrect time-val received from server.\n");
			timestr[0] = ' ';
			timestr[1] = '2';
			timestr[2] = '0';
		}
		sscanf(reply_string, "%*s %04d%02d%02d%02d%02d%02d", &yy, &mo,
			&day, &hour, &min, &sec);
		memset(&timebuf, 0, sizeof(timebuf));
		timebuf.tm_sec = sec;
		timebuf.tm_min = min;
		timebuf.tm_hour = hour;
		timebuf.tm_mday = day;
		timebuf.tm_mon = mo - 1;
		timebuf.tm_year = yy - 1900;
		timebuf.tm_isdst = -1;
		rtime = mktime(&timebuf);
		if (rtime == -1 && (noisy
#ifndef SMALL
		    || debug
#endif /* !SMALL */
		    ))
			fprintf(ttyout, "Can't convert %s to a time.\n", reply_string);
		else
			rtime += timebuf.tm_gmtoff;	/* conv. local -> GMT */
	} else if (noisy
#ifndef SMALL
	    && !debug
#endif /* !SMALL */
	    ) {
		fputs(reply_string, ttyout);
		fputc('\n', ttyout);
	}
	verbose = overbose;
	if (rtime == -1)
		code = ocode;
	return (rtime);
}

/*
 * Ensure file is in or under dir.
 * Returns 1 if so, 0 if not (or an error occurred).
 */
int
fileindir(const char *file, const char *dir)
{
	char	parentdirbuf[PATH_MAX], *parentdir;
	char	realdir[PATH_MAX];
	size_t	dirlen;

					/* determine parent directory of file */
	(void)strlcpy(parentdirbuf, file, sizeof(parentdirbuf));
	parentdir = dirname(parentdirbuf);
	if (strcmp(parentdir, ".") == 0)
		return 1;		/* current directory is ok */

					/* find the directory */
	if (realpath(parentdir, realdir) == NULL) {
		warn("Unable to determine real path of `%s'", parentdir);
		return 0;
	}
	if (realdir[0] != '/')		/* relative result is ok */
		return 1;

	dirlen = strlen(dir);
	if (strncmp(realdir, dir, dirlen) == 0 &&
	    (realdir[dirlen] == '/' || realdir[dirlen] == '\0'))
		return 1;
	return 0;
}


/*
 * Returns true if this is the controlling/foreground process, else false.
 */
int
foregroundproc(void)
{
	static pid_t pgrp = -1;
	int ctty_pgrp;

	if (pgrp == -1)
		pgrp = getpgrp();

	return((ioctl(STDOUT_FILENO, TIOCGPGRP, &ctty_pgrp) != -1 &&
	    ctty_pgrp == pgrp));
}

/* ARGSUSED */
static void
updateprogressmeter(int signo)
{
	int save_errno = errno;

	/* update progressmeter if foreground process or in -m mode */
	if (foregroundproc() || progress == -1)
		progressmeter(0, NULL);
	errno = save_errno;
}

/*
 * Display a transfer progress bar if progress is non-zero.
 * SIGALRM is hijacked for use by this function.
 * - Before the transfer, set filesize to size of file (or -1 if unknown),
 *   and call with flag = -1. This starts the once per second timer,
 *   and a call to updateprogressmeter() upon SIGALRM.
 * - During the transfer, updateprogressmeter will call progressmeter
 *   with flag = 0
 * - After the transfer, call with flag = 1
 */
static struct timeval start;

char *action;

void
progressmeter(int flag, const char *filename)
{
	/*
	 * List of order of magnitude prefixes.
	 * The last is `P', as 2^64 = 16384 Petabytes
	 */
	static const char prefixes[] = " KMGTP";

	static struct timeval lastupdate;
	static off_t lastsize;
	static char *title = NULL;
	struct timeval now, td, wait;
	off_t cursize, abbrevsize;
	double elapsed;
	int ratio, barlength, i, remaining, overhead = 30;
	char buf[512];

	if (flag == -1) {
		(void)gettimeofday(&start, NULL);
		lastupdate = start;
		lastsize = restart_point;
	}
	(void)gettimeofday(&now, NULL);
	if (!progress || filesize < 0)
		return;
	cursize = bytes + restart_point;

	if (filesize)
		ratio = cursize * 100 / filesize;
	else
		ratio = 100;
	ratio = MAXIMUM(ratio, 0);
	ratio = MINIMUM(ratio, 100);
	if (!verbose && flag == -1) {
		filename = basename(filename);
		if (filename != NULL)
			title = strdup(filename);
	}

	buf[0] = 0;
	if (!verbose && action != NULL) {
		int l = strlen(action);
		char *dotdot = "";

		if (l < 7)
			l = 7;
		else if (l > 12) {
			l = 12;
			dotdot = "...";
			overhead += 3;
		}
		snprintf(buf, sizeof(buf), "\r%-*.*s%s ", l, l, action,
		    dotdot);
		overhead += l + 1;
	} else
		snprintf(buf, sizeof(buf), "\r");

	if (!verbose && title != NULL) {
		int l = strlen(title);
		char *dotdot = "";

		if (l < 12)
			l = 12;
		else if (l > 25) {
			l = 22;
			dotdot = "...";
			overhead += 3;
		}
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "%-*.*s%s %3d%% ", l, l, title,
		    dotdot, ratio);
		overhead += l + 1;
	} else
		snprintf(buf, sizeof(buf), "\r%3d%% ", ratio);

	barlength = ttywidth - overhead;
	if (barlength > 0) {
		i = barlength * ratio / 100;
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "|%.*s%*s|", i,
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************"
		    "*******************************************************",
		    barlength - i, "");
	}

	i = 0;
	abbrevsize = cursize;
	while (abbrevsize >= 100000 && i < sizeof(prefixes)-1) {
		i++;
		abbrevsize >>= 10;
	}
	snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
	    " %5lld %c%c ", (long long)abbrevsize, prefixes[i],
	    prefixes[i] == ' ' ? ' ' : 'B');

	timersub(&now, &lastupdate, &wait);
	if (cursize > lastsize) {
		lastupdate = now;
		lastsize = cursize;
		if (wait.tv_sec >= STALLTIME) {	/* fudge out stalled time */
			start.tv_sec += wait.tv_sec;
			start.tv_usec += wait.tv_usec;
		}
		wait.tv_sec = 0;
	}

	timersub(&now, &start, &td);
	elapsed = td.tv_sec + (td.tv_usec / 1000000.0);

	if (flag == 1) {
		i = (int)elapsed / 3600;
		if (i)
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
			    "%2d:", i);
		else
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
			    "   ");
		i = (int)elapsed % 3600;
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "%02d:%02d    ", i / 60, i % 60);
	} else if (bytes <= 0 || elapsed <= 0.0 || cursize > filesize) {
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "   --:-- ETA");
	} else if (wait.tv_sec >= STALLTIME) {
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    " - stalled -");
	} else {
		remaining = (int)((filesize - restart_point) /
				  (bytes / elapsed) - elapsed);
		i = remaining / 3600;
		if (i)
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
			    "%2d:", i);
		else
			snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
			    "   ");
		i = remaining % 3600;
		snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),
		    "%02d:%02d ETA", i / 60, i % 60);
	}
	(void)write(fileno(ttyout), buf, strlen(buf));

	if (flag == -1) {
		(void)signal(SIGALRM, updateprogressmeter);
		alarmtimer(1);		/* set alarm timer for 1 Hz */
	} else if (flag == 1) {
		alarmtimer(0);
		(void)putc('\n', ttyout);
		free(title);
		title = NULL;
	}
	fflush(ttyout);
}

/*
 * Display transfer statistics.
 * Requires start to be initialised by progressmeter(-1),
 * direction to be defined by xfer routines, and filesize and bytes
 * to be updated by xfer routines
 * If siginfo is nonzero, an ETA is displayed, and the output goes to STDERR
 * instead of TTYOUT.
 */
void
ptransfer(int siginfo)
{
	struct timeval now, td;
	double elapsed;
	off_t bs;
	int meg, remaining, hh;
	char buf[100];

	if (!verbose && !siginfo)
		return;

	(void)gettimeofday(&now, NULL);
	timersub(&now, &start, &td);
	elapsed = td.tv_sec + (td.tv_usec / 1000000.0);
	bs = bytes / (elapsed == 0.0 ? 1 : elapsed);
	meg = 0;
	if (bs > (1024 * 1024))
		meg = 1;

	/* XXX floating point printf in signal handler */
	(void)snprintf(buf, sizeof(buf),
	    "%lld byte%s %s in %.2f seconds (%.2f %sB/s)\n",
	    (long long)bytes, bytes == 1 ? "" : "s", direction, elapsed,
	    bs / (1024.0 * (meg ? 1024.0 : 1.0)), meg ? "M" : "K");

	if (siginfo && bytes > 0 && elapsed > 0.0 && filesize >= 0 &&
	    bytes + restart_point <= filesize) {
		remaining = (int)((filesize - restart_point) /
		    (bytes / elapsed) - elapsed);
		hh = remaining / 3600;
		remaining %= 3600;

		/* "buf+len(buf) -1" to overwrite \n */
		snprintf(buf + strlen(buf) - 1, sizeof(buf) - strlen(buf),
		    "  ETA: %02d:%02d:%02d\n", hh, remaining / 60,
		    remaining % 60);
	}
	(void)write(siginfo ? STDERR_FILENO : fileno(ttyout), buf, strlen(buf));
}

/*
 * List words in stringlist, vertically arranged
 */
#ifndef SMALL
void
list_vertical(StringList *sl)
{
	int i, j, w;
	int columns, width, lines;
	char *p;

	width = 0;

	for (i = 0 ; i < sl->sl_cur ; i++) {
		w = strlen(sl->sl_str[i]);
		if (w > width)
			width = w;
	}
	width = (width + 8) &~ 7;

	columns = ttywidth / width;
	if (columns == 0)
		columns = 1;
	lines = (sl->sl_cur + columns - 1) / columns;
	for (i = 0; i < lines; i++) {
		for (j = 0; j < columns; j++) {
			p = sl->sl_str[j * lines + i];
			if (p)
				fputs(p, ttyout);
			if (j * lines + i + lines >= sl->sl_cur) {
				putc('\n', ttyout);
				break;
			}
			w = strlen(p);
			while (w < width) {
				w = (w + 8) &~ 7;
				(void)putc('\t', ttyout);
			}
		}
	}
}
#endif /* !SMALL */

/*
 * Update the global ttywidth value, using TIOCGWINSZ.
 */
/* ARGSUSED */
void
setttywidth(int signo)
{
	int save_errno = errno;
	struct winsize winsize;

	if (ioctl(fileno(ttyout), TIOCGWINSZ, &winsize) != -1)
		ttywidth = winsize.ws_col ? winsize.ws_col : 80;
	else
		ttywidth = 80;
	errno = save_errno;
}

/*
 * Set the SIGALRM interval timer for wait seconds, 0 to disable.
 */
void
alarmtimer(int wait)
{
	int save_errno = errno;
	struct itimerval itv;

	itv.it_value.tv_sec = wait;
	itv.it_value.tv_usec = 0;
	itv.it_interval = itv.it_value;
	setitimer(ITIMER_REAL, &itv, NULL);
	errno = save_errno;
}

/*
 * Setup or cleanup EditLine structures
 */
#ifndef SMALL
void
controlediting(void)
{
	HistEvent hev;

	if (editing && el == NULL && hist == NULL) {
		el = el_init(__progname, stdin, ttyout, stderr); /* init editline */
		hist = history_init();		/* init the builtin history */
		history(hist, &hev, H_SETSIZE, 100);	/* remember 100 events */
		el_set(el, EL_HIST, history, hist);	/* use history */

		el_set(el, EL_EDITOR, "emacs");	/* default editor is emacs */
		el_set(el, EL_PROMPT, prompt);	/* set the prompt function */

		/* add local file completion, bind to TAB */
		el_set(el, EL_ADDFN, "ftp-complete",
		    "Context sensitive argument completion",
		    complete);
		el_set(el, EL_BIND, "^I", "ftp-complete", NULL);

		el_source(el, NULL);	/* read ~/.editrc */
		el_set(el, EL_SIGNAL, 1);
	} else if (!editing) {
		if (hist) {
			history_end(hist);
			hist = NULL;
		}
		if (el) {
			el_end(el);
			el = NULL;
		}
	}
}
#endif /* !SMALL */

/*
 * Wait for an asynchronous connect(2) attempt to finish.
 */
int
connect_wait(int s)
{
	struct pollfd pfd[1];
	int error = 0;
	socklen_t len = sizeof(error);

	pfd[0].fd = s;
	pfd[0].events = POLLOUT;

	if (poll(pfd, 1, -1) == -1)
		return -1;
	if (getsockopt(s, SOL_SOCKET, SO_ERROR, &error, &len) < 0)
		return -1;
	if (error != 0) {
		errno = error;
		return -1;
	}
	return 0;
}
@


1.83
log
@#ifndef SMALL around a couple of non-SMALL labels.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.82 2017/01/11 13:40:24 zhuk Exp $	*/
d623 5
a627 5
 		/*
 		 * time-val = 14DIGIT [ "." 1*DIGIT ]
 		 *		YYYYMMDDHHMMSS[.sss]
 		 * mdtm-response = "213" SP time-val CRLF / error-response
 		 */
d637 3
a639 3
 			fprintf(ttyout,
 	    "Y2K warning! Fixed incorrect time-val received from server.\n");
	    		timestr[0] = ' ';
d687 1
a687 1
		 			/* determine parent directory of file */
d831 1
a831 1
		    "|%.*s%*s|", i, 
@


1.82
log
@Don't attempt to read .netrc when we already force anonymous FTP (-a).

Patch from Anton Lindqvist via tech@@, thanks!

okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.81 2016/08/20 20:18:42 millert Exp $	*/
d441 1
d443 1
@


1.81
log
@Use connect(2) + a connect_wait() function instead of connect_sync(),
similar to the example in connect(2).  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.80 2016/08/18 16:23:06 millert Exp $	*/
d224 1
a224 1
	if (user == NULL) {
@


1.80
log
@Move connect_sync() to util.c and use it when connecting via http
too.  OK sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.79 2016/08/14 18:34:48 guenther Exp $	*/
d70 1
d1074 1
a1074 2
 * Wrapper for connect(2) that restarts the syscall when
 * interrupted and operates synchronously.
d1077 1
a1077 1
connect_sync(int s, const struct sockaddr *name, socklen_t namelen)
a1082 6
	if (connect(s, name, namelen) < 0) {
		if (errno != EINTR)
			return -1;
	}

	/* An interrupted connect(2) continues asyncronously. */
d1085 8
a1092 11
	for (;;) {
		if (poll(pfd, 1, -1) == -1) {
			if (errno != EINTR)
				return -1;
			continue;
		}
		if (getsockopt(s, SOL_SOCKET, SO_ERROR, &error, &len) < 0)
			return -1;
		if (error != 0)
			errno = error;
		break;
d1094 1
a1094 1
	return (error ? -1 : 0);
@


1.79
log
@Convert remaining calls to strtoq/strtouq in base with strtoll/strtoull.
Fix a type mismatch in ftp's "page" command and could make transfers restart
at the wrong position.

ok and a ull->ll tweak from natano@@, ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.78 2016/07/28 21:37:45 tedu Exp $	*/
d79 1
d1072 33
@


1.78
log
@these programs probably do not need to use TMPDIR. ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.77 2016/03/16 15:41:11 krw Exp $	*/
d583 1
a583 1
			size = strtoq(cp, &ep, 10);
@


1.77
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.76 2015/12/09 17:55:42 mmcc Exp $	*/
d393 1
a393 2
		if ((cp = getenv("TMPDIR")) == NULL || *cp == '\0')
		    cp = _PATH_TMP;
@


1.76
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.75 2015/10/18 03:41:14 deraadt Exp $	*/
d767 1
a767 1
		(void)gettimeofday(&start, (struct timezone *)0);
d771 1
a771 1
	(void)gettimeofday(&now, (struct timezone *)0);
d928 1
a928 1
	(void)gettimeofday(&now, (struct timezone *)0);
@


1.75
log
@unrelated commit; not ready yet
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.73 2015/10/18 03:04:11 mmcc Exp $	*/
d902 2
a903 4
		if (title != NULL) {
			free(title);
			title = NULL;
		}
@


1.74
log
@First casualty of making pledge "dns" mandatory for dns users.
"dns" was missing, and this was relying on "inet" support..
@
text
@d393 2
a394 1
		cp = _PATH_TMP;
@


1.73
log
@A whole buncha unsigned char casts for ctype function arguments.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.72 2015/03/17 19:31:30 millert Exp $	*/
d393 1
a393 2
		if ((cp = getenv("TMPDIR")) == NULL || *cp == '\0')
		    cp = _PATH_TMP;
@


1.72
log
@Eliminate use of TM_YEAR_BASE.  OK guenther@@ deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.71 2015/03/15 00:41:28 millert Exp $	*/
d491 1
a491 1
	switch (tolower(*str)) {
d585 1
a585 1
			if (*ep != '\0' && !isspace(*ep))
d629 1
a629 1
		while (!isspace(*timestr))
d631 1
a631 1
		while (isspace(*timestr))
@


1.71
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.70 2015/02/09 04:10:50 tedu Exp $	*/
d648 1
a648 1
		timebuf.tm_year = yy - TM_YEAR_BASE;
@


1.70
log
@remove the safeguard against porting to machines without 8 bit bytes.
allows removing sys/param.h include as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.69 2015/01/30 04:45:45 tedu Exp $	*/
a84 1
#include <tzfile.h>
@


1.69
log
@remove tenex transfer support. if you still have TOPS20 machines in
service, you'll need to stick with openbsd 5.6.
bonus: remove references to ebcdic.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.68 2015/01/16 06:40:08 deraadt Exp $	*/
a68 1
#include <sys/param.h>	/* BSD */
a170 5
#if (defined(unix) || defined(BSD)) && NBBY == 8
/*
 * this ifdef is to keep someone form "porting" this to an incompatible
 * system and not checking this out. This way they have to think about it.
 */
a207 1
#endif /* unix || BSD */
@


1.68
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.67 2014/08/16 07:49:27 deraadt Exp $	*/
a211 5
			if (overbose &&
			    !strncmp(reply_string, "215 TOPS20", 10))
				fputs(
"Remember to set tenex mode when transferring binary files from this machine.\n",
				    ttyout);
@


1.67
log
@I found a number of interactive events which can cause signals, and go
down paths not previously marked as signal handled unsafe.  Try to clean
up a few of them especially regarding errno, mark others as unsafe, and
repair a few by avoiding stdio.  Glanced at by misc people in Slovenia,
but considered too risky before release..
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.66 2014/01/29 16:58:21 dcoppa Exp $	*/
d69 1
a78 1
#include <limits.h>
d92 3
d229 2
a230 2
	char tmp[80], *acctname = NULL, host_name[MAXHOSTNAMELEN];
	char anonpass[MAXLOGNAME + 1 + MAXHOSTNAMELEN];	/* "user@@hostname" */
d381 2
a382 2
	char temp[MAXPATHLEN], *bufp, *cp, *lmode;
	static char buf[MAXPATHLEN], **args;
d693 2
a694 2
	char	parentdirbuf[MAXPATHLEN], *parentdir;
	char	realdir[MAXPATHLEN];
d793 2
a794 2
	ratio = MAX(ratio, 0);
	ratio = MIN(ratio, 100);
@


1.66
log
@Unbreak ftp progress meter after the introduction of the '-D' flag

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.65 2014/01/23 00:39:15 deraadt Exp $	*/
d947 2
d953 3
a955 2
	if (siginfo && bytes > 0 && elapsed > 0.0 && filesize >= 0
	    && bytes + restart_point <= filesize) {
d957 1
a957 1
				  (bytes / elapsed) - elapsed);
d960 2
a961 1
			/* "buf+len(buf) -1" to overwrite \n */
d1035 1
d1042 1
@


1.65
log
@Add -D shorttitle support, so that the progress meter can show some sort
of reason why it is processing a certain file.  This will be used by the
installer for that purpose.
ok krw rpe
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.64 2009/11/11 17:10:25 deraadt Exp $	*/
d814 1
a814 1
		snprintf(buf, sizeof(buf), "");
@


1.64
log
@do not walk off the prefix array, off by one; found by parfait
ok jsg millert
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.63 2009/05/10 16:31:17 deraadt Exp $	*/
d756 2
d797 19
d827 2
a828 1
		snprintf(buf, sizeof(buf), "\r%-*.*s%s %3d%% ", l, l, title,
@


1.63
log
@show which username login failed for; ok martynas
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.62 2009/05/05 19:35:30 martynas Exp $	*/
d829 1
a829 1
	while (abbrevsize >= 100000 && i < sizeof(prefixes)) {
@


1.62
log
@make it clean removing the ifdef SMALL maze.  separate cmds and
small stuff.  make it a fetcher.  shrinks quite a bit
agreed by millert@@, krw@@
ok theo, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.61 2009/04/27 22:51:51 martynas Exp $	*/
d311 1
a311 1
		warnx("Login failed.");
@


1.61
log
@remove uploading and macros support from install media;  to save
some space
discussed with theo, todd@@, millert@@
tested and looked over by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.60 2009/04/27 21:37:13 deraadt Exp $	*/
d109 1
d117 1
d340 1
d365 1
d485 1
d538 1
d946 1
d984 1
d1055 1
@


1.60
log
@toast the rcsid strings which just get in the way
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.59 2009/04/26 21:26:03 martynas Exp $	*/
d319 1
d328 1
@


1.59
log
@figure out titles automatically by using remote file name.  remove
-T and just show titles by default for non-verbose transfers;
discussed with, ok theo, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.58 2009/04/26 10:30:07 sthen Exp $	*/
a64 4

#if !defined(lint) && !defined(SMALL)
static const char rcsid[] = "$OpenBSD: util.c,v 1.58 2009/04/26 10:30:07 sthen Exp $";
#endif /* not lint and not SMALL */
@


1.58
log
@make two similar text strings identical; improves consistency and shrinks
the text segment slightly (though due to padding it does not change the size
of the binary).  ok martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.57 2009/04/13 01:47:04 deraadt Exp $	*/
d67 1
a67 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.57 2009/04/13 01:47:04 deraadt Exp $";
d736 1
a736 1
		progressmeter(0);
a751 2
char    *title;

d753 1
a753 1
progressmeter(int flag)
d763 1
d786 6
a791 1
	if (title) {
d805 1
a805 1
	} else		
d886 4
@


1.57
log
@add a "-T title" option to ftp; this is is used in progress bar mode to
show which filename is being used. ok krw, mdoc repair from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.56 2009/01/27 22:04:36 martynas Exp $	*/
d67 1
a67 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.56 2009/01/27 22:04:36 martynas Exp $";
d415 1
a415 1
			warn("unable to create temporary file %s", temp);
@


1.56
log
@on some servers LIST defaults to LIST -a.  ignore pseudo-directories
so that recursive transfers don't cause a loop.  problem reported
and tested by Jesus Sanchez.  string compare inlining and looks
good to millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.55 2008/08/22 08:52:35 sobrado Exp $	*/
d67 1
a67 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.55 2008/08/22 08:52:35 sobrado Exp $";
d752 2
d768 1
a768 1
	int ratio, barlength, i, remaining;
d787 16
a802 1
	snprintf(buf, sizeof(buf), "\r%3d%% ", ratio);
d804 1
a804 1
	barlength = ttywidth - 30;
@


1.55
log
@default file transfer type is binary, not ascii;
commands which toggle settings can take an explicit on or off argument
to force the setting appropiately, show these arguments in usage;
synchronize synopsis and usage of commands; spacing; KNF;
other minor documentation tweaks.

written with help by jmc@@

ok jmc@@ (documentation), martynas@@ (type usage and default file transfer type)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.54 2008/07/08 21:07:57 martynas Exp $	*/
d67 1
a67 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.54 2008/07/08 21:07:57 martynas Exp $";
d461 4
a464 1
		if (!bufp)
@


1.54
log
@- add support for recursive transfers (but not for floppies), e.g.
'mget -cr 4.*' would recursively fetch (-r), and resume the previous
transfers (-c) of 4.X release directories
uses local matching (fnmatch), but only for recursive transfers.
current behavior is not changed in any way.
- while here, ifndef SMALL debugging stuff, this saves some space,
for floppies
- some debugging code was enabled for non-debugging mode, checks
assume debug is set to zero, but it's not initially set
- all "Confirm with" prompts are forced, remove redundant argument
- fix usage: -C and -c are not available for SMALL

discussed a year ago w/ pyr@@
looks good to millert@@
previous version looked good to pyr@@
man page tweaks & ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.53 2008/06/26 05:42:20 ray Exp $	*/
d67 1
a67 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.53 2008/06/26 05:42:20 ray Exp $";
d116 1
a116 1
		fprintf(ttyout, "usage: %s host-name [port]\n", argv[0]);
@


1.53
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.52 2008/06/25 21:15:19 martynas Exp $	*/
d67 1
a67 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.52 2008/06/25 21:15:19 martynas Exp $";
d177 3
a179 1
		if (debug == 0)
d369 3
d374 1
a374 1
remglob(char *argv[], int doswitch, char **errbuf)
d376 1
a376 1
	char temp[MAXPATHLEN], *cp, *lmode;
a377 1
	static FILE *ftemp = NULL;
d384 3
a386 3
			if (ftemp) {
				(void)fclose(ftemp);
				ftemp = NULL;
d398 1
a398 1
	if (ftemp == NULL) {
d426 2
a427 1
			recvrequest("NLST", temp, *argv, lmode, 0, 0);
d436 1
a436 1
		ftemp = fopen(temp, "r");
d438 1
a438 1
		if (ftemp == NULL) {
d448 4
a451 3
	if (fgets(buf, sizeof(buf), ftemp) == NULL) {
		(void)fclose(ftemp);
		ftemp = NULL;
d456 20
d477 1
a477 1
	return (buf);
d481 1
a481 1
confirm(const char *cmd, const char *file, int force)
d485 1
a485 1
	if (!force && (confirmrest || !interactive))
d488 4
a491 1
	fprintf(ttyout, "%s %s? ", cmd, file);
d577 3
a579 1
	if (debug == 0)
d591 5
a595 1
	} else if (noisy && debug == 0) {
d616 3
a618 1
	if (debug == 0)
d654 5
a658 1
		if (rtime == -1 && (noisy || debug != 0))
d662 5
a666 1
	} else if (noisy && debug == 0) {
@


1.52
log
@in resume mode, pass -c to mget when {dir,file}hasglob, so that i'm
able to continue multiple transfers with -C;  ok millert@@
while here fix some comments (!SMALL vs. SMALL stuff), and add
missing
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.51 2008/06/16 19:56:04 martynas Exp $	*/
a22 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d67 1
a67 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.51 2008/06/16 19:56:04 martynas Exp $";
@


1.51
log
@- add 'q', which does the same as eof
- add '?', which will help
- make use of mflag, instead of special-case interactive
- change mflag++ to mflag = 1, because theoretically it can go out
of range
"i like it" millert@@.  man page help and ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.50 2008/06/16 12:03:51 martynas Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.50 2008/06/16 12:03:51 martynas Exp $";
d245 1
a245 1
#endif
@


1.50
log
@fix transfer interrupting when confirmrest mode is used.  change
confirm() to have a 'force' argument, so that ointer/oconf dance
is not needed, and to prevent further bugs like this;  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.49 2008/06/15 03:09:13 martynas Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.49 2008/06/15 03:09:13 martynas Exp $";
d466 1
a466 8

	if (force)
		goto top;

	if (confirmrest == -1)
		return (0);

	if (confirmrest || !interactive)
d471 2
a472 6
	if (fgets(str, sizeof(str), stdin) == NULL) {
		if (!force)
			confirmrest = -1;
		clearerr(stdin);
		return (0);
	}
d474 14
d494 5
a498 4
		case 'a':
			confirmrest = 1;
			fprintf(ttyout, "Prompting off for duration of %s.\n", cmd);
			break;
d503 2
a504 1
			fprintf(ttyout, "n, y, p, a, are the only acceptable commands!\n");
@


1.49
log
@make further prompts work after eof, don't spam with prompts in
m*() cases;  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.48 2008/05/13 02:09:38 ray Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.48 2008/05/13 02:09:38 ray Exp $";
d462 1
a462 1
confirm(const char *cmd, const char *file)
d466 5
a470 1
	if (confirmrest == 2)
d473 1
a473 1
	if (!interactive || confirmrest)
d479 2
a480 1
		confirmrest = 2;
@


1.48
log
@Remove #if 0 code that has been unused for nearly a decade (and
probably doesn't compile, since the types for some variables have
changed from long to char *).

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.47 2007/09/11 15:47:17 gilles Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.47 2007/09/11 15:47:17 gilles Exp $";
d301 2
d356 2
a357 1
	if (fgets(&line[len], (int)(sizeof(line) - len), stdin) == NULL)
d359 1
d466 3
d474 3
a476 1
	if (fgets(str, sizeof(str), stdin) == NULL)
d478 1
@


1.47
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.46 2007/06/06 19:15:33 pyr Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.46 2007/06/06 19:15:33 pyr Exp $";
a130 17
#if 0
	if (argc > 2) {
		char *ep;
		long nport;

		nport = strtol(argv[2], &ep, 10);
		if (nport < 1 || nport > USHRT_MAX || *ep != '\0') {
			fprintf(ttyout, "%s: bad port number '%s'.\n",
			    argv[1], argv[2]);
			fprintf(ttyout, "usage: %s host-name [port]\n",
			    argv[0]);
			code = -1;
			return;
		}
		port = htons((in_port_t)nport);
	}
#else
a132 1
#endif
@


1.46
log
@Remove the .netrc parser when compiling a SMALL binary.
there is no .netrc file on the install media and keeping the parser
shaves a good deal of bytes in the binary.
ok millert@@, "go on" deraadt@@, "makes sense" steven@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.45 2006/11/02 01:51:33 ray Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.45 2006/11/02 01:51:33 ray Exp $";
d315 1
a315 4
			char *p;

			if ((p = strchr(tmp, '\n')) != NULL)
				*p = '\0';
d469 3
a471 2
	if ((cp = strchr(buf, '\n')) != NULL)
		*cp = '\0';
@


1.45
log
@Pass full buffer size to fgets.

OK moritz@@ and jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.44 2006/11/02 01:43:01 ray Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.44 2006/11/02 01:43:01 ray Exp $";
d256 1
d263 1
@


1.44
log
@Add checks for fgets and properly overwrite newline.

Initial patch from Charles Longeau <chl at tuxfamily dot org>.

OK moritz@@ and jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.43 2006/05/16 23:43:16 ray Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.43 2006/05/16 23:43:16 ray Exp $";
d312 1
a312 1
		if (fgets(tmp, sizeof(tmp) - 1, stdin) != NULL) {
@


1.43
log
@Remove shadowing variables and properly use /* FALLTHROUGH */
comments.  No binary change.

Found by lint.

OK beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.42 2006/04/25 05:45:20 tedu Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.42 2006/04/25 05:45:20 tedu Exp $";
d311 9
a319 7
		*tmp = '\0';
		(void)fgets(tmp, sizeof(tmp) - 1, stdin);
		tmp[strlen(tmp) - 1] = '\0';
		if (*tmp == '\0')
			user = myname;
		else
			user = tmp;
@


1.42
log
@two strtol calls that were begging to be converted to strtonum
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.41 2005/10/12 06:50:42 otto Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: util.c,v 1.41 2005/10/12 06:50:42 otto Exp $";
d251 1
a251 1
	char tmp[80], *acct = NULL, hostname[MAXHOSTNAMELEN];
d257 1
a257 1
		if (ruserpass(host, &user, &pass, &acct) < 0) {
d268 1
a268 1
		memset(hostname, 0, sizeof(hostname));
d279 1
a279 1
		gethostname(hostname, sizeof(hostname));
d327 3
a329 3
		if (acct == NULL)
			acct = getpass("Account:");
		n = command("ACCT %s", acct);
d332 1
a332 1
	    (!aflag && acct != NULL && command("ACCT %s", acct) != COMPLETE)) {
d391 1
a391 1
	char temp[MAXPATHLEN], *cp, *mode;
d441 2
a442 2
		for (mode = "w"; *++argv != NULL; mode = "a")
			recvrequest("NLST", temp, *argv, mode, 0, 0);
d476 1
a476 1
	char line[BUFSIZ];
d483 1
a483 1
	if (fgets(line, sizeof(line), stdin) == NULL)
d485 1
a485 1
	switch (tolower(*line)) {
@


1.41
log
@Fix mget directory traversal vulnerability. From NetBSD. CAN-2002-1345.
ok millert@@ deraadt@@, prodding by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.40 2005/04/11 15:16:50 deraadt Exp $	*/
d74 1
a74 1
static char rcsid[] = "$OpenBSD: util.c,v 1.40 2005/04/11 15:16:50 deraadt Exp $";
@


1.40
log
@knf; cloder ok
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.39 2004/09/16 04:39:16 deraadt Exp $	*/
d74 1
a74 1
static char rcsid[] = "$OpenBSD: util.c,v 1.39 2004/09/16 04:39:16 deraadt Exp $";
d88 1
d633 33
@


1.39
log
@type corrections and other delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.38 2004/07/20 03:50:26 deraadt Exp $	*/
d74 1
a74 1
static char rcsid[] = "$OpenBSD: util.c,v 1.38 2004/07/20 03:50:26 deraadt Exp $";
d111 1
a111 2
	char *host;
	char *port;
d250 1
a250 2
	char tmp[80];
	char *acct;
d252 1
a252 1
	char hostname[MAXHOSTNAMELEN];
a253 1
	int n, aflag = 0, retry = 0;
a254 1
	acct = NULL;
d390 24
a413 26
        char temp[MAXPATHLEN];
        static char buf[MAXPATHLEN];
        static FILE *ftemp = NULL;
        static char **args;
        int oldverbose, oldhash, fd;
        char *cp, *mode;

        if (!mflag) {
                if (!doglob)
                        args = NULL;
                else {
                        if (ftemp) {
                                (void)fclose(ftemp);
                                ftemp = NULL;
                        }
                }
                return (NULL);
        }
        if (!doglob) {
                if (args == NULL)
                        args = argv;
                if ((cp = *++args) == NULL)
                        args = NULL;
                return (cp);
        }
        if (ftemp == NULL) {
d429 5
a433 5
                if ((fd = mkstemp(temp)) < 0) {
                        warn("unable to create temporary file %s", temp);
                        return (NULL);
                }
                close(fd);
d438 4
a441 4
                if (doswitch)
                        pswitch(!proxy);
                for (mode = "w"; *++argv != NULL; mode = "a")
                        recvrequest("NLST", temp, *argv, mode, 0, 0);
d448 1
a448 1
                verbose = oldverbose;
d450 3
a452 3
                ftemp = fopen(temp, "r");
                (void)unlink(temp);
                if (ftemp == NULL) {
d459 5
a463 5
                        return (NULL);
                }
        }
        if (fgets(buf, sizeof(buf), ftemp) == NULL) {
                (void)fclose(ftemp);
d465 5
a469 5
                return (NULL);
        }
        if ((cp = strchr(buf, '\n')) != NULL)
                *cp = '\0';
        return (buf);
@


1.38
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.37 2003/12/16 21:46:22 deraadt Exp $	*/
d74 1
a74 1
static char rcsid[] = "$OpenBSD: util.c,v 1.37 2003/12/16 21:46:22 deraadt Exp $";
d655 1
d657 1
a657 1
updateprogressmeter(int dummy)
d848 1
a848 1
	int columns, width, lines, items;
d851 1
a851 1
	width = items = 0;
d885 1
d887 1
a887 1
setttywidth(int a)
@


1.37
log
@for -DSMALL, do not include rcsid[]s
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.36 2003/10/31 08:47:31 otto Exp $	*/
d74 1
a74 1
static char rcsid[] = "$OpenBSD: util.c,v 1.36 2003/10/31 08:47:31 otto Exp $";
d109 1
a109 3
setpeer(argc, argv)
	int argc;
	char *argv[];
d249 1
a249 3
ftp_login(host, user, pass)
	const char *host;
	char *user, *pass;
d364 1
a364 4
another(pargc, pargv, prompt)
	int *pargc;
	char ***pargv;
	const char *prompt;
d392 1
a392 4
remglob(argv, doswitch, errbuf)
        char *argv[];
        int doswitch;
	char **errbuf;
d479 1
a479 2
confirm(cmd, file)
	const char *cmd, *file;
d519 1
a519 2
globulize(cpp)
	char **cpp;
d549 1
a549 3
remotesize(file, noisy)
	const char *file;
	int noisy;
d580 1
a580 3
remotemodtime(file, noisy)
	const char *file;
	int noisy;
d643 1
a643 1
foregroundproc()
d656 1
a656 2
updateprogressmeter(dummy)
	int dummy;
d679 1
a679 2
progressmeter(flag)
	int flag;
d804 1
a804 2
ptransfer(siginfo)
	int siginfo;
d844 1
a844 2
list_vertical(sl)
	StringList *sl;
d885 1
a885 2
setttywidth(a)
	int a;
d901 1
a901 2
alarmtimer(wait)
	int wait;
d916 1
a916 1
controlediting()
@


1.36
log
@New libedit api changes.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.35 2003/06/03 02:56:08 millert Exp $	*/
d73 3
a75 3
#ifndef lint
static char rcsid[] = "$OpenBSD: util.c,v 1.35 2003/06/03 02:56:08 millert Exp $";
#endif /* not lint */
@


1.35
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.34 2003/04/07 22:15:57 millert Exp $	*/
d74 1
a74 1
static char rcsid[] = "$OpenBSD: util.c,v 1.34 2003/04/07 22:15:57 millert Exp $";
d940 2
d943 1
a943 1
		el = el_init(__progname, stdin, ttyout); /* init editline */
d945 1
a945 1
		history(hist, H_EVENT, 100);	/* remember 100 events */
@


1.34
log
@Some NetBSD changes were committed to this file w/o updating the
copyright.  I have gone through the cvs logs and added the appropriate
NetBSD Foundation copyright corresponding to those changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.33 2003/04/05 17:19:47 deraadt Exp $	*/
d56 1
a56 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d74 1
a74 1
static char rcsid[] = "$OpenBSD: util.c,v 1.33 2003/04/05 17:19:47 deraadt Exp $";
@


1.33
log
@string fixes; ok miod henning
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.32 2003/03/31 23:04:07 millert Exp $	*/
d4 40
d78 1
a78 1
static char rcsid[] = "$OpenBSD: util.c,v 1.32 2003/03/31 23:04:07 millert Exp $";
@


1.32
log
@Treat empty environment variables the same as NULL.  henning@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.31 2002/11/08 03:30:17 fgsch Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.31 2002/11/08 03:30:17 fgsch Exp $";
d141 9
a149 4
		(void)strcpy(formname, "non-print"), form = FORM_N;
		(void)strcpy(modename, "stream"), mode = MODE_S;
		(void)strcpy(structname, "file"), stru = STRU_F;
		(void)strcpy(bytename, "8"), bytesize = 8;
d156 1
a156 1
		(void)strcpy(typename, "binary");
d316 1
a316 1
			(void)strcpy(line, "$init");
d405 1
a405 1
		(void)strcpy(temp, cp);
d408 1
a408 1
		(void)strcpy(&temp[len], TMPFILE);
@


1.31
log
@http redirect support; adapted from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.29 2002/03/30 17:45:44 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.29 2002/03/30 17:45:44 deraadt Exp $";
d391 1
a391 1
		if ((cp = getenv("TMPDIR")) == NULL)
@


1.30
log
@malloc/strdup failure not handled; cloder@@acm.org
@
text
@d155 1
a155 1
			(void)login(argv[1], NULL, NULL);
d210 1
a210 1
login(host, user, pass)
@


1.29
log
@stretch banners
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.28 2002/02/19 18:38:01 mpech Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.28 2002/02/19 18:38:01 mpech Exp $";
d510 2
@


1.28
log
@Fix gethostname() usage.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.27 2002/02/16 21:27:46 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.27 2002/02/16 21:27:46 millert Exp $";
d668 1
a668 1
	char buf[256];
d693 7
a699 2
"*****************************************************************************"
"*****************************************************************************",
@


1.27
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.26 2001/07/12 05:17:08 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.26 2001/07/12 05:17:08 deraadt Exp $";
d245 1
a245 1
		gethostname(hostname, MAXHOSTNAMELEN);
@


1.26
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.25 2001/06/18 21:20:17 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.25 2001/06/18 21:20:17 millert Exp $";
d66 1
a66 1
static void updateprogressmeter __P((int));
@


1.25
log
@Change default transfer type from ascii to binary; closes PR 1626
Similar to patch from mpech@@prosoft.org.lv
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.24 2000/05/15 18:27:27 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.24 2000/05/15 18:27:27 deraadt Exp $";
d705 1
a705 1
	    " %5qd %c%c ", (quad_t)abbrevsize, prefixes[i],
d794 2
a795 2
	    "%qd byte%s %s in %.2f seconds (%.2f %sB/s)\n",
	    (quad_t)bytes, bytes == 1 ? "" : "s", direction, elapsed,
@


1.24
log
@0-size files still deserve a progress meter; also, after file is finished
transfer, display a non-ETA line with an elapsed time.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.23 2000/02/01 20:53:06 espie Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.23 2000/02/01 20:53:06 espie Exp $";
a140 2
		(void)strcpy(typename, "ascii"), type = TYPE_A;
		curtype = TYPE_A;
d145 9
a186 8
			/*
			 * Set type to 0 (not specified by user),
			 * meaning binary by default, but don't bother
			 * telling server.  We can use binary
			 * for text files unless changed by the user.
			 */
			type = 0;
			(void)strcpy(typename, "binary");
@


1.23
log
@Work-around for lame servers that return `19100' for a date.

Based on NetBSD patch, slightly trimmed since we don't use the fractional
part yet...
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.22 1999/12/08 12:57:06 itojun Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.22 1999/12/08 12:57:06 itojun Exp $";
d677 1
a677 1
	if (!progress || filesize <= 0)
d681 4
a684 1
	ratio = cursize * 100 / filesize;
d723 12
a734 1
	if (bytes <= 0 || elapsed <= 0.0 || cursize > filesize) {
@


1.22
log
@ftp(1) from KAME, should be good for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.21 1998/09/22 04:42:49 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.21 1998/09/22 04:42:49 deraadt Exp $";
d568 20
@


1.21
log
@if winsize.ws_col is 0, assume 80
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.20 1998/09/19 22:38:56 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.20 1998/09/19 22:38:56 millert Exp $";
d78 1
a78 1
	in_port_t port;
d97 1
d113 4
@


1.20
log
@make the progress meter run correctly in all cases if in -m mode
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.19 1998/05/13 08:59:10 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.19 1998/05/13 08:59:10 deraadt Exp $";
d826 1
a826 1
		ttywidth = winsize.ws_col;
@


1.19
log
@make signal handlers save/restore errno
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.18 1998/04/26 17:52:15 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.18 1998/04/26 17:52:15 deraadt Exp $";
d66 2
d604 1
a604 3
void updateprogressmeter __P((int));

void
d610 2
a611 1
	if (foregroundproc())
@


1.18
log
@recommended fix from tri@@iki.fi...
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.17 1998/03/30 06:59:36 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.17 1998/03/30 06:59:36 deraadt Exp $";
d608 1
d612 1
d821 1
d828 1
@


1.17
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.16 1997/11/25 08:10:34 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.16 1997/11/25 08:10:34 deraadt Exp $";
d271 1
@


1.16
log
@prompting error; pr#352, blair@@nac.net
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.15 1997/09/15 04:57:54 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.15 1997/09/15 04:57:54 millert Exp $";
d60 1
d568 1
a568 1
		timebuf.tm_year = yy - 1900;
@


1.15
log
@Don't error out if the remote server doesn't support the "MDTM"
command.  Based on a patch from Martin Fredriksson <martin@@netman.se>.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.14 1997/09/11 01:55:16 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.14 1997/09/11 01:55:16 millert Exp $";
d447 1
d468 1
a468 3
			fprintf(ttyout, "%s %s? ", cmd, file);
			fgets(line, sizeof(line), stdin);
			confirm(cmd, file);
@


1.14
log
@- Move `parsed_url' label such that the next statement after the label is
  not an "else" (which some strict compilers reject).

- If getlogin() fails fall back on getpwuid(getuid()).
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.13 1997/09/04 04:37:17 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.13 1997/09/04 04:37:17 millert Exp $";
d550 1
d553 1
d580 2
@


1.13
log
@Updtaes from NetBSD (lukem)
    bugs fixed:
      * don't interpret '-' or '|' when a local filename is determined from
        the remote name (i.e, in mget, and in get with only one argument).
        This is implemented using an extra argument to recvrequest().
        Fixes a major security hole.
      * clean up memory leak when using globulize()
      * clean up a couple of comments
      * fix wording in TNF copyright

    features added:
      * support for TIS fwtk gate-ftp servers:
        * read defaults from $FTPSERVER && $FTPSERVERPORT
        * start in gate-ftp mode if invoked as 'gate-ftp'
        * toggle or set with 'gate [host [port]]'

Other changes:
    * use symbolic flags in access(2)
    * Use USHRT_MAX, not 0xffff
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.12 1997/08/25 21:41:55 jkatz Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.12 1997/08/25 21:41:55 jkatz Exp $";
d211 1
d232 6
a237 1
		user = getlogin();
d264 2
a265 6
		if (myname == NULL) {
			struct passwd *pp = getpwuid(getuid());

			if (pp != NULL)
				myname = pp->pw_name;
		}
@


1.12
log
@dumb fix for dumb users-- ftp's mget now idiot-proofs input!
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.11 1997/07/25 21:56:23 millert Exp $	*/
/*	$NetBSD: util.c,v 1.11 1997/07/21 14:03:49 lukem Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.11 1997/07/25 21:56:23 millert Exp $";
d90 4
a93 1
	port = ftpport;
d99 1
a99 1
		if (nport < 1 || nport > 0xffff || *ep != '\0') {
d109 8
a116 1
	host = hookup(argv[1], port);
d120 9
d406 1
a406 1
                        recvrequest("NLST", temp, *argv, mode, 0);
d497 4
a500 1
	*cpp = strdup(gl.gl_pathv[0]);	/* XXX - wasted memory */
@


1.11
log
@Updates from NetBSD (lukem) include -Wall cleanup.
More -W* cleanup and in_port_t usage by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.10 1997/06/10 19:39:54 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.10 1997/06/10 19:39:54 millert Exp $";
d440 9
@


1.10
log
@Disable progress meter if started as a bg process.  Also don't
print the progress meter if the ftp process is put in the bg
(but do print it when/if the process is foregrounded).
From Enami Tsugutomo <enami@@ba2.so-net.or.jp> with tweaks by me.
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.9 1997/05/11 17:12:57 millert Exp $	*/
/*	$NetBSD: util.c,v 1.7 1997/04/14 09:09:24 lukem Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.9 1997/05/11 17:12:57 millert Exp $";
d52 1
d75 1
a75 1
	short port;
d92 9
a100 4
		port = atoi(argv[2]);
		if (port <= 0) {
			fprintf(ttyout, "%s: bad port number '%s'.\n", argv[1], argv[2]);
			fprintf(ttyout, "usage: %s host-name [port]\n", argv[0]);
d104 1
a104 1
		port = htons(port);
d192 1
a192 1
	int n, aflag, retry = 0;
d229 1
a229 1
		user = "ftp";
a232 1

d234 1
a234 1
		user = "anonymous";
d311 1
a311 1
	if (fgets(&line[len], sizeof(line) - len, stdin) == NULL)
d489 11
a499 3
	if (command("SIZE %s", file) == COMPLETE)
		sscanf(reply_string, "%*s %qd", &size);
	else if (noisy && debug == 0) {
d501 1
a501 1
		fputs("\n", ttyout);
d542 1
a542 1
		fputs("\n", ttyout);
d564 2
d567 2
a568 1
updateprogressmeter()
d637 1
a637 1
	    " %5qd %c%c ", abbrevsize, prefixes[i],
d654 1
a654 1
	if (bytes <= 0 || elapsed <= 0.0) {
d716 1
a716 1
	    bytes, bytes == 1 ? "" : "s", direction, elapsed,
d718 2
a719 1
	if (siginfo && bytes > 0 && elapsed > 0.0 && filesize >= 0) {
d724 1
@


1.9
log
@Only retry login as "anonymous" if we are doing anonftp.
Found by grr@@openbsd.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.8 1997/05/05 20:49:51 jkatz Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.8 1997/05/05 20:49:51 jkatz Exp $";
d535 16
d555 2
a556 1
	progressmeter(0);
@


1.8
log
@This fixes FTP so that it first tries with the username FTP, and then with
the username ANONYMOUS. It works, too :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.7 1997/04/23 20:33:24 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.7 1997/04/23 20:33:24 deraadt Exp $";
d228 1
a228 1
	if (retry) {
a229 2
	}

d266 1
a266 1
		if (retry){
d268 2
a269 2
		} else
		retry = 1;
a270 1

@


1.7
log
@allow "ftp -aV ftp://host/foo.tar.gz | tar xvfpz -" to work
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.6 1997/04/16 05:02:59 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.6 1997/04/16 05:02:59 millert Exp $";
d186 1
a186 1
	int n, aflag = 0;
d223 6
d232 1
d268 6
a273 1
		return (0);
@


1.6
log
@Sync with NetBSD (lukem):
 * differentiate between being connected, and being logged in
 * cleanup some text messages
 * support username & password ftp URLs (ftp://user:pass@@host/) in non-proxy
   situations; assume proxy supports it for proxy situations.
 * cd to / before performing any autofetch transfers
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.5 1997/04/10 00:17:11 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.5 1997/04/10 00:17:11 millert Exp $";
d77 1
a77 1
		printf("Already connected to %s, use close first.\n",
d85 1
a85 1
		printf("usage: %s host-name [port]\n", argv[0]);
d93 2
a94 2
			printf("%s: bad port number '%s'.\n", argv[1], argv[2]);
			printf("usage: %s host-name [port]\n", argv[0]);
d138 1
a138 1
			printf("Remote system type is %s.\n", reply_string + 4);
d156 2
a157 2
			    printf("Using %s mode to transfer files.\n",
				typename);
d165 3
a167 2
				puts(
"Remember to set tenex mode when transferring binary files from this machine.");
d236 1
a236 1
			printf("Name (%s:%s): ", host, myname);
d238 1
a238 1
			printf("Name (%s): ", host);
d292 1
a292 1
		puts("sorry, arguments too long.");
d295 1
a295 1
	printf("(%s) ", prompt);
d386 2
a387 1
				puts("can't find list of remote files, oops.");
d412 2
a413 2
	printf("%s %s? ", cmd, file);
	(void)fflush(stdout);
d421 1
a421 1
			puts("Interactive mode: off.");
d425 1
a425 1
			printf("Prompting off for duration of %s.\n", cmd);
d477 4
a480 2
	else if (noisy && debug == 0)
		puts(reply_string);
d515 1
a515 1
			printf("Can't convert %s to a time.\n", reply_string);
d518 4
a521 2
	} else if (noisy && debug == 0)
		puts(reply_string);
d632 1
a632 1
	(void)write(STDOUT_FILENO, buf, strlen(buf));
d639 1
a639 1
		(void)putchar('\n');
d641 1
a641 1
	fflush(stdout);
d650 1
a650 1
 * instead of STDOUT.
d685 1
a685 1
	(void)write(siginfo ? STDERR_FILENO : STDOUT_FILENO, buf, strlen(buf));
d716 1
a716 1
				fputs(p, stdout);
d718 1
a718 1
				putchar('\n');
d724 1
a724 1
				(void)putchar('\t');
d739 1
a739 1
	if (ioctl(fileno(stdout), TIOCGWINSZ, &winsize) != -1)
d768 1
a768 1
		el = el_init(__progname, stdin, stdout); /* init editline */
@


1.5
log
@Sync with NetBSD (lukem)
    * support $ftp_proxy for ftp:// transfers [bin/3245]
    * add "more" & "less" as synonyms for "page"
    * move editline setup code into controlediting(), and call appropriately.
      only setup setup terminal if going into interactive mode.
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.4 1997/03/14 04:32:18 millert Exp $	*/
/*	$NetBSD: util.c,v 1.6 1997/04/05 03:27:39 lukem Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.4 1997/03/14 04:32:18 millert Exp $";
d53 1
d115 1
a115 1
			(void)login(argv[1]);
d171 103
@


1.4
log
@Sync with NetBSD and fix "get foo.txt /dev/tty" wrt progress meter
and setting times.
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.3 1997/02/05 04:55:21 millert Exp $	*/
/*	$NetBSD: util.c,v 1.5 1997/03/13 06:23:21 lukem Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.3 1997/02/05 04:55:21 millert Exp $";
a637 1

d649 37
@


1.3
log
@Include signal.h where reasonable and make signal handlers match
what signal(3)'s prototype says (and cast when not).
Also change MAXFOO+1 -> MAXFOO since MAXFOO includes the NULL.
Support $TMPDIR and use utime(3) not utimes(2) for portability's sake.
Don't spew "Passive mode enabled/disabled" unless verbose (this means
togglevar() needs to watch for a NULL 'message').
@
text
@d1 2
a2 2
/*	$OpenBSD: util.c,v 1.2 1997/02/03 01:05:46 millert Exp $	*/
/*	$NetBSD: util.c,v 1.4 1997/02/01 11:26:34 lukem Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.2 1997/02/03 01:05:46 millert Exp $";
d92 2
a93 2
			printf("%s: bad port number-- %s\n", argv[1], argv[2]);
			printf ("usage: %s host-name [port]\n", argv[0]);
d127 1
a127 1
			cp = strchr(reply_string+4, ' ');
d129 1
a129 1
				cp = strchr(reply_string+4, '\r');
d173 1
a173 1
 * `Another' gets another argument, and stores the new argc and argv.
d187 1
a187 1
		puts("sorry, arguments too long");
d204 5
d210 1
a210 1
remglob(argv, doswitch)
d213 1
d223 1
a223 1
                if (!doglob) {
a224 1
                }
a255 1
;
d261 5
a265 3
                oldverbose = verbose, verbose = 0;
                oldhash = hash, hash = 0;
                if (doswitch) {
a266 1
                }
d268 9
a276 5
                        recvrequest ("NLST", temp, *argv, mode, 0);
                if (doswitch) {
                        pswitch(!proxy);
                }
                verbose = oldverbose; hash = oldhash;
d280 5
a284 1
                        puts("can't find list of remote files, oops");
d289 2
a290 1
                (void)fclose(ftemp), ftemp = NULL;
d315 1
a315 1
			puts("Interactive mode: off");
d319 1
a319 1
			printf("Prompting off for duration of %s\n", cmd);
d372 1
a372 1
		printf("%s\n", reply_string);
d407 1
a407 1
			printf("Can't convert %s to a time\n", reply_string);
@


1.2
log
@Add back ``-r'' option and fix strncpy() usage and other nits because
I'm anal.  Closer to KNF now.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.4 1997/02/01 11:26:34 lukem Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: util.c,v 1.4 1997/02/01 11:26:34 lukem Exp $";
d50 1
d53 1
d236 15
a250 1
                (void)snprintf(temp, sizeof(temp), "%s%s", _PATH_TMP, TMPFILE)
d252 1
a252 2
                fd = mkstemp(temp);
                if (fd < 0) {
@


1.1
log
@Sync with NetBSD
@
text
@d1 1
d38 1
a38 1
static char rcsid[] = "$NetBSD: util.c,v 1.4 1997/02/01 11:26:34 lukem Exp $";
d53 1
d75 1
a75 1
			hostname);
d80 1
a80 1
		(void) another(&argc, &argv, "to");
d105 1
a105 1
		(void) strcpy(typename, "ascii"), type = TYPE_A;
d107 4
a110 4
		(void) strcpy(formname, "non-print"), form = FORM_N;
		(void) strcpy(modename, "stream"), mode = MODE_S;
		(void) strcpy(structname, "file"), stru = STRU_F;
		(void) strcpy(bytename, "8"), bytesize = 8;
d112 1
a112 1
			(void) login(argv[1]);
d114 5
d135 1
a135 2
			printf("Remote system type is %s.\n",
				reply_string+4);
d151 1
a151 1
			(void) strcpy(typename, "binary");
d162 2
a163 3
				printf("Remember to set tenex mode when "
				    "transferring binary files from this "
				    "machine.\n");
d166 1
d185 1
a185 1
		printf("sorry, arguments too long\n");
d220 1
a220 1
                                (void) fclose(ftemp);
d234 1
a234 1
                (void) snprintf(temp, sizeof(temp), "%s%s", _PATH_TMP, TMPFILE)
d254 1
a254 1
                (void) unlink(temp);
d256 1
a256 1
                        printf("can't find list of remote files, oops\n");
d260 2
a261 2
        if (fgets(buf, sizeof (buf), ftemp) == NULL) {
                (void) fclose(ftemp), ftemp = NULL;
d278 1
a278 1
	(void) fflush(stdout);
d286 1
a286 1
			printf("Interactive mode: off\n");
d382 1
a382 1
		printf("%s\n", reply_string);
d425 1
a425 1
		(void) gettimeofday(&start, (struct timezone *)0);
d429 1
a429 1
	(void) gettimeofday(&now, (struct timezone *)0);
d496 1
a496 1
		(void) signal(SIGALRM, updateprogressmeter);
d500 1
a500 1
		(void) putchar('\n');
d526 1
a526 1
	(void) gettimeofday(&now, (struct timezone *)0);
d577 1
a577 1
				printf("%s", p);
d579 1
a579 1
				printf("\n");
d585 1
a585 1
				(void) putchar('\t');
@
