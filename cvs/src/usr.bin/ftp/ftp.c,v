head	1.100;
access;
symbols
	OPENBSD_6_1:1.100.0.2
	OPENBSD_6_1_BASE:1.100
	OPENBSD_6_0:1.96.0.2
	OPENBSD_6_0_BASE:1.96
	OPENBSD_5_9:1.95.0.2
	OPENBSD_5_9_BASE:1.95
	OPENBSD_5_8:1.91.0.6
	OPENBSD_5_8_BASE:1.91
	OPENBSD_5_7:1.91.0.2
	OPENBSD_5_7_BASE:1.91
	OPENBSD_5_6:1.86.0.4
	OPENBSD_5_6_BASE:1.86
	OPENBSD_5_5:1.84.0.2
	OPENBSD_5_5_BASE:1.84
	OPENBSD_5_4:1.82.0.6
	OPENBSD_5_4_BASE:1.82
	OPENBSD_5_3:1.82.0.4
	OPENBSD_5_3_BASE:1.82
	OPENBSD_5_2:1.82.0.2
	OPENBSD_5_2_BASE:1.82
	OPENBSD_5_1_BASE:1.81
	OPENBSD_5_1:1.81.0.6
	OPENBSD_5_0:1.81.0.4
	OPENBSD_5_0_BASE:1.81
	OPENBSD_4_9:1.81.0.2
	OPENBSD_4_9_BASE:1.81
	OPENBSD_4_8:1.80.0.2
	OPENBSD_4_8_BASE:1.80
	OPENBSD_4_7:1.79.0.2
	OPENBSD_4_7_BASE:1.79
	OPENBSD_4_6:1.79.0.4
	OPENBSD_4_6_BASE:1.79
	OPENBSD_4_5:1.73.0.4
	OPENBSD_4_5_BASE:1.73
	OPENBSD_4_4:1.73.0.2
	OPENBSD_4_4_BASE:1.73
	OPENBSD_4_3:1.67.0.4
	OPENBSD_4_3_BASE:1.67
	OPENBSD_4_2:1.67.0.2
	OPENBSD_4_2_BASE:1.67
	OPENBSD_4_1:1.66.0.2
	OPENBSD_4_1_BASE:1.66
	OPENBSD_4_0:1.65.0.2
	OPENBSD_4_0_BASE:1.65
	OPENBSD_3_9:1.61.0.2
	OPENBSD_3_9_BASE:1.61
	OPENBSD_3_8:1.57.0.4
	OPENBSD_3_8_BASE:1.57
	OPENBSD_3_7:1.57.0.2
	OPENBSD_3_7_BASE:1.57
	OPENBSD_3_6:1.56.0.2
	OPENBSD_3_6_BASE:1.56
	OPENBSD_3_5:1.55.0.2
	OPENBSD_3_5_BASE:1.55
	OPENBSD_3_4:1.54.0.2
	OPENBSD_3_4_BASE:1.54
	OPENBSD_3_3:1.51.0.2
	OPENBSD_3_3_BASE:1.51
	OPENBSD_3_2:1.49.0.2
	OPENBSD_3_2_BASE:1.49
	OPENBSD_3_1:1.43.0.2
	OPENBSD_3_1_BASE:1.43
	OPENBSD_3_0:1.41.0.2
	OPENBSD_3_0_BASE:1.41
	OPENBSD_2_9_BASE:1.39
	OPENBSD_2_9:1.39.0.4
	OPENBSD_2_8:1.39.0.2
	OPENBSD_2_8_BASE:1.39
	OPENBSD_2_7:1.35.0.2
	OPENBSD_2_7_BASE:1.35
	OPENBSD_2_6:1.33.0.4
	OPENBSD_2_6_BASE:1.33
	OPENBSD_2_5:1.33.0.2
	OPENBSD_2_5_BASE:1.33
	OPENBSD_2_4:1.32.0.2
	OPENBSD_2_4_BASE:1.32
	OPENBSD_2_3:1.25.0.2
	OPENBSD_2_3_BASE:1.25
	OPENBSD_2_2:1.23.0.2
	OPENBSD_2_2_BASE:1.23
	OPENBSD_2_1:1.18.0.2
	OPENBSD_2_1_BASE:1.18
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.100
date	2016.08.22.16.27.00;	author millert;	state Exp;
branches;
next	1.99;
commitid	W6jZG7rHyYRcDjiK;

1.99
date	2016.08.20.20.18.42;	author millert;	state Exp;
branches;
next	1.98;
commitid	F2AU4cYS2XzonLey;

1.98
date	2016.08.18.16.23.06;	author millert;	state Exp;
branches;
next	1.97;
commitid	ku5uVo6mFCThpOmQ;

1.97
date	2016.08.09.12.09.40;	author millert;	state Exp;
branches;
next	1.96;
commitid	4IBUCDqesHa8baAG;

1.96
date	2016.03.16.15.41.11;	author krw;	state Exp;
branches;
next	1.95;
commitid	JEVxsRygqcjPtWTf;

1.95
date	2015.12.05.22.28.40;	author krw;	state Exp;
branches;
next	1.94;
commitid	G8PmUDyXMxAdbdZL;

1.94
date	2015.12.05.22.20.44;	author krw;	state Exp;
branches;
next	1.93;
commitid	HS2W0COx9GJWDTke;

1.93
date	2015.12.05.22.14.04;	author krw;	state Exp;
branches;
next	1.92;
commitid	9o7RPViGICrylvnm;

1.92
date	2015.09.27.05.25.01;	author guenther;	state Exp;
branches;
next	1.91;
commitid	PQh1CHLROh0mqpnf;

1.91
date	2015.02.09.08.24.20;	author tedu;	state Exp;
branches;
next	1.90;
commitid	Ab1pEJVaQayQbO7E;

1.90
date	2015.01.30.04.45.45;	author tedu;	state Exp;
branches;
next	1.89;
commitid	AzhkSUz6nBmdvJNd;

1.89
date	2015.01.16.06.40.08;	author deraadt;	state Exp;
branches;
next	1.88;
commitid	Uu5nFG3wCl0LACBb;

1.88
date	2014.10.24.02.01.20;	author lteo;	state Exp;
branches;
next	1.87;
commitid	K0sGF4uE2LYJ8DMA;

1.87
date	2014.08.16.07.49.27;	author deraadt;	state Exp;
branches;
next	1.86;
commitid	VtJEhEZFfTUoD9C5;

1.86
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.85;

1.85
date	2014.04.22.20.48.41;	author tedu;	state Exp;
branches;
next	1.84;

1.84
date	2013.12.20.13.44.51;	author jca;	state Exp;
branches;
next	1.83;

1.83
date	2013.11.13.20.41.14;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2012.04.30.13.41.26;	author haesbaert;	state Exp;
branches;
next	1.81;

1.81
date	2010.09.03.03.49.37;	author lum;	state Exp;
branches;
next	1.80;

1.80
date	2010.07.02.22.01.10;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2009.06.06.23.14.44;	author martynas;	state Exp;
branches;
next	1.78;

1.78
date	2009.04.27.23.20.48;	author martynas;	state Exp;
branches;
next	1.77;

1.77
date	2009.04.27.22.51.51;	author martynas;	state Exp;
branches;
next	1.76;

1.76
date	2009.04.27.21.37.13;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2009.04.26.21.26.03;	author martynas;	state Exp;
branches;
next	1.74;

1.74
date	2009.04.25.12.22.19;	author martynas;	state Exp;
branches;
next	1.73;

1.73
date	2008.07.08.21.07.57;	author martynas;	state Exp;
branches;
next	1.72;

1.72
date	2008.06.25.21.15.19;	author martynas;	state Exp;
branches;
next	1.71;

1.71
date	2008.06.25.18.07.00;	author martynas;	state Exp;
branches;
next	1.70;

1.70
date	2008.05.24.00.42.35;	author pyr;	state Exp;
branches;
next	1.69;

1.69
date	2008.04.12.21.20.58;	author ray;	state Exp;
branches;
next	1.68;

1.68
date	2008.03.10.22.56.43;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.16.08.58.33;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2007.03.06.05.16.01;	author beck;	state Exp;
branches;
next	1.65;

1.65
date	2006.06.23.20.35.25;	author steven;	state Exp;
branches;
next	1.64;

1.64
date	2006.05.16.23.43.16;	author ray;	state Exp;
branches;
next	1.63;

1.63
date	2006.05.16.16.20.42;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2006.04.25.05.45.20;	author tedu;	state Exp;
branches;
next	1.61;

1.61
date	2006.02.16.07.41.01;	author pvalchev;	state Exp;
branches;
next	1.60;

1.60
date	2006.01.10.18.12.46;	author moritz;	state Exp;
branches;
next	1.59;

1.59
date	2005.11.13.20.26.09;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2005.10.30.15.17.41;	author sturm;	state Exp;
branches;
next	1.57;

1.57
date	2004.09.16.04.39.16;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2004.07.20.03.50.25;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2003.12.16.21.46.22;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2003.08.11.21.23.58;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.03.02.56.08;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2003.04.05.17.19.47;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2003.03.11.04.01.29;	author itojun;	state Exp;
branches;
next	1.50;

1.50
date	2003.03.11.04.01.11;	author itojun;	state Exp;
branches;
next	1.49;

1.49
date	2002.07.04.10.08.00;	author jakob;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.09.02.36.03;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.09.00.40.29;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.01.20.21.49;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.30.06.51.46;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2002.04.25.10.58.05;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2002.02.16.21.27.46;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.26.23.44.00;	author lebel;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.06.23.22.48.44;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.18.06.53.24;	author itojun;	state Exp;
branches
	1.39.4.1;
next	1.38;

1.38
date	2000.06.30.16.00.14;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.27.00.19.16;	author fgsch;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.21.19.22.54;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2000.05.03.19.50.41;	author deraadt;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	99.12.08.12.57.06;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	98.12.13.21.01.29;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	98.09.19.23.00.50;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	98.09.19.20.47.16;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	98.09.19.20.02.23;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	98.07.07.17.26.41;	author art;	state Exp;
branches;
next	1.28;

1.28
date	98.06.08.16.55.57;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	98.05.13.10.42.35;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	98.05.13.08.59.07;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	98.02.10.02.13.10;	author weingart;	state Exp;
branches;
next	1.24;

1.24
date	97.12.17.16.03.03;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	97.09.05.00.02.29;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	97.09.04.04.37.16;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	97.08.06.17.35.41;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.07.25.21.56.21;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.06.17.20.40.40;	author kstailey;	state Exp;
branches;
next	1.18;

1.18
date	97.04.23.20.33.13;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.04.16.05.02.54;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.03.21.20.59.29;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.03.14.23.25.46;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.03.14.05.40.20;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.03.14.04.32.16;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.02.05.04.55.18;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.02.03.01.05.40;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.02.03.01.02.39;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.01.08.13.19.11;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.12.16.15.51.28;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.11.09.19.57.46;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.10.31.14.36.56;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.08.02.05.56.23;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.33.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.03.16.34.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.03.15.55.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.17;	author deraadt;	state Exp;
branches;
next	;

1.35.2.1
date	2000.10.06.21.16.13;	author jason;	state Exp;
branches;
next	;

1.39.4.1
date	2002.05.16.21.45.31;	author miod;	state Exp;
branches;
next	;

1.41.2.1
date	2002.05.16.21.44.27;	author miod;	state Exp;
branches;
next	;

1.43.2.1
date	2002.05.17.04.45.34;	author jason;	state Exp;
branches;
next	;


desc
@@


1.100
log
@Replace "union sockunion" with "union sockaddr_union" which is also
used in the kernel.  This makes it possible to remove the casts to
"struct sockaddr *" when calling networking syscalls.
OK jsing@@ jca@@
@
text
@/*	$OpenBSD: ftp.c,v 1.99 2016/08/20 20:18:42 millert Exp $	*/
/*	$NetBSD: ftp.c,v 1.27 1997/08/18 10:20:23 lukem Exp $	*/

/*
 * Copyright (C) 1997 and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1985, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <arpa/ftp.h>
#include <arpa/telnet.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <netdb.h>
#include <poll.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <utime.h>

#include "ftp_var.h"

union sockaddr_union {
	struct sockaddr     sa;
	struct sockaddr_in  sin;
	struct sockaddr_in6 sin6;
};

union sockaddr_union myctladdr, hisctladdr, data_addr;

int	data = -1;
int	abrtflag = 0;
jmp_buf	ptabort;
int	ptabflg;
int	ptflag = 0;
off_t	restart_point = 0;


FILE	*cin, *cout;

char *
hookup(char *host, char *port)
{
	int s, tos, error;
	static char hostnamebuf[HOST_NAME_MAX+1];
	struct addrinfo hints, *res, *res0;
#ifndef SMALL
	struct addrinfo *ares;
#endif
	char hbuf[NI_MAXHOST];
	char *cause = "unknown";
	socklen_t namelen;

	epsv4bad = 0;

	memset((char *)&hisctladdr, 0, sizeof (hisctladdr));
	memset(&hints, 0, sizeof(hints));
	hints.ai_flags = AI_CANONNAME;
	hints.ai_family = family;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = 0;
	error = getaddrinfo(host, port, &hints, &res0);
	if (error == EAI_SERVICE) {
		/*
		 * If the services file is corrupt/missing, fall back
		 * on our hard-coded defines.
		 */
		char pbuf[NI_MAXSERV];

		pbuf[0] = '\0';
		if (strcmp(port, "ftp") == 0)
			snprintf(pbuf, sizeof(pbuf), "%d", FTP_PORT);
		else if (strcmp(port, "ftpgate") == 0)
			snprintf(pbuf, sizeof(pbuf), "%d", GATE_PORT);
		else if (strcmp(port, "http") == 0)
			snprintf(pbuf, sizeof(pbuf), "%d", HTTP_PORT);
#ifndef SMALL
		else if (strcmp(port, "https") == 0)
			snprintf(pbuf, sizeof(pbuf), "%d", HTTPS_PORT);
#endif /* !SMALL */
		if (pbuf[0])
			error = getaddrinfo(host, pbuf, &hints, &res0);
	}
	if (error) {
		if (error == EAI_SERVICE)
			warnx("%s: bad port number `%s'", host, port);
		else
			warnx("%s: %s", host, gai_strerror(error));
		code = -1;
		return (0);
	}

	if (res0->ai_canonname)
		strlcpy(hostnamebuf, res0->ai_canonname, sizeof(hostnamebuf));
	else
		strlcpy(hostnamebuf, host, sizeof(hostnamebuf));
	hostname = hostnamebuf;

#ifndef SMALL
	if (srcaddr) {
		struct addrinfo ahints;

		memset(&ahints, 0, sizeof(ahints));
		ahints.ai_family = family;
		ahints.ai_socktype = SOCK_STREAM;
		ahints.ai_flags |= AI_NUMERICHOST;
		ahints.ai_protocol = 0;

		error = getaddrinfo(srcaddr, NULL, &ahints, &ares);
		if (error) {
			warnx("%s: %s", srcaddr, gai_strerror(error));
			code = -1;
			return (0);
		}
	}
#endif /* !SMALL */

	s = -1;
	for (res = res0; res; res = res->ai_next) {
		if (res0->ai_next)	/* if we have multiple possibilities */
		{
			if (getnameinfo(res->ai_addr, res->ai_addrlen,
			    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)
				strlcpy(hbuf, "unknown", sizeof(hbuf));
			if (verbose)
				fprintf(ttyout, "Trying %s...\n", hbuf);
		}
		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
		if (s < 0) {
			cause = "socket";
			continue;
		}
#ifndef SMALL
		if (srcaddr) {
			if (ares->ai_family != res->ai_family) {
				close(s);
				s = -1;
				errno = EINVAL;
				cause = "bind";
				continue;
			}
			if (bind(s, ares->ai_addr, ares->ai_addrlen) < 0) {
				cause = "bind";
				error = errno;
				close(s);
				errno = error;
				s = -1;
				continue;
			}
		}
#endif /* !SMALL */
		for (error = connect(s, res->ai_addr, res->ai_addrlen);
		    error != 0 && errno == EINTR; error = connect_wait(s))
			continue;
		if (error != 0) {
			/* this "if" clause is to prevent print warning twice */
			if (verbose && res->ai_next) {
				if (getnameinfo(res->ai_addr, res->ai_addrlen,
				    hbuf, sizeof(hbuf), NULL, 0,
				    NI_NUMERICHOST) != 0)
					strlcpy(hbuf, "(unknown)",
					    sizeof(hbuf));
				warn("connect to address %s", hbuf);
			}
			cause = "connect";
			error = errno;
			close(s);
			errno = error;
			s = -1;
			continue;
		}

		/* finally we got one */
		break;
	}
	if (s < 0) {
		warn("%s", cause);
		code = -1;
		freeaddrinfo(res0);
		return 0;
	}
	memcpy(&hisctladdr, res->ai_addr, res->ai_addrlen);
	namelen = res->ai_addrlen;
	freeaddrinfo(res0);
	res0 = res = NULL;
#ifndef SMALL
	if (srcaddr) {
		freeaddrinfo(ares);
		ares = NULL;
	}
#endif /* !SMALL */
	if (getsockname(s, &myctladdr.sa, &namelen) < 0) {
		warn("getsockname");
		code = -1;
		goto bad;
	}
	if (hisctladdr.sa.sa_family == AF_INET) {
		tos = IPTOS_LOWDELAY;
		if (setsockopt(s, IPPROTO_IP, IP_TOS, (char *)&tos, sizeof(int)) < 0)
			warn("setsockopt TOS (ignored)");
	}
	cin = fdopen(s, "r");
	cout = fdopen(s, "w");
	if (cin == NULL || cout == NULL) {
		warnx("fdopen failed.");
		if (cin)
			(void)fclose(cin);
		if (cout)
			(void)fclose(cout);
		code = -1;
		goto bad;
	}
	if (verbose)
		fprintf(ttyout, "Connected to %s.\n", hostname);
	if (getreply(0) > 2) {	/* read startup message from server */
		if (cin)
			(void)fclose(cin);
		if (cout)
			(void)fclose(cout);
		code = -1;
		goto bad;
	}
	{
	int ret, on = 1;

	ret = setsockopt(s, SOL_SOCKET, SO_OOBINLINE, (char *)&on, sizeof(on));
#ifndef SMALL
	if (ret < 0 && debug)
		warn("setsockopt");
#endif /* !SMALL */
	}

	return (hostname);
bad:
	(void)close(s);
	return (NULL);
}

/* ARGSUSED */
void
cmdabort(int signo)
{
	int save_errno = errno;

	alarmtimer(0);
	(void) write(fileno(ttyout), "\n\r", 2);
	abrtflag++;

	errno = save_errno;
	if (ptflag)
		longjmp(ptabort, 1);
}

int
command(const char *fmt, ...)
{
	va_list ap;
	int r;
	sig_t oldintr;

	abrtflag = 0;
#ifndef SMALL
	if (debug) {
		fputs("---> ", ttyout);
		va_start(ap, fmt);
		if (strncmp("PASS ", fmt, 5) == 0)
			fputs("PASS XXXX", ttyout);
		else if (strncmp("ACCT ", fmt, 5) == 0)
			fputs("ACCT XXXX", ttyout);
		else
			vfprintf(ttyout, fmt, ap);
		va_end(ap);
		putc('\n', ttyout);
		(void)fflush(ttyout);
	}
#endif /* !SMALL */
	if (cout == NULL) {
		warnx("No control connection for command.");
		code = -1;
		return (0);
	}
	oldintr = signal(SIGINT, cmdabort);
	va_start(ap, fmt);
	vfprintf(cout, fmt, ap);
	va_end(ap);
	fputs("\r\n", cout);
	(void)fflush(cout);
	cpend = 1;
	r = getreply(!strcmp(fmt, "QUIT"));
	if (abrtflag && oldintr != SIG_IGN)
		(*oldintr)(SIGINT);
	(void)signal(SIGINT, oldintr);
	return (r);
}

int keep_alive_timeout = 60;		/* 0 -> no timeout */

static int full_noops_sent = 0;
static time_t last_timestamp = 0;	/* 0 -> no measurement yet */
static char noop[] = "NOOP\r\n";
#define NOOP_LENGTH (sizeof noop - 1)
static int current_nop_pos = 0;		/* 0 -> no noop started */

/* to achieve keep alive, we send noop one byte at a time */
static void
send_noop_char(void)
{
#ifndef SMALL
	if (debug)
		fprintf(ttyout, "---> %c\n", noop[current_nop_pos]);
#endif /* !SMALL */
	fputc(noop[current_nop_pos++], cout);
	(void)fflush(cout);
	if (current_nop_pos >= NOOP_LENGTH) {
		full_noops_sent++;
		current_nop_pos = 0;
	}
}

static void
may_reset_noop_timeout(void)
{
	if (keep_alive_timeout != 0)
		last_timestamp = time(NULL);
}

static void
may_receive_noop_ack(void)
{
	int i;

	if (cout == NULL) {
		/* Lost connection;  so just pretend we're fine. */
		current_nop_pos = full_noops_sent = 0;
		return;
	}

	/* finish sending last incomplete noop */
	if (current_nop_pos != 0) {
		fputs(&(noop[current_nop_pos]), cout);
#ifndef SMALL
		if (debug)
			fprintf(ttyout, "---> %s\n", &(noop[current_nop_pos]));
#endif /* !SMALL */
		(void)fflush(cout);
		current_nop_pos = 0;
		full_noops_sent++;
	}
	/* and get the replies */
	for (i = 0; i < full_noops_sent; i++)
		(void)getreply(0);

	full_noops_sent = 0;
}

static void
may_send_noop_char(void)
{
	if (keep_alive_timeout != 0) {
		if (last_timestamp != 0) {
			time_t t = time(NULL);

			if (t - last_timestamp >= keep_alive_timeout) {
				last_timestamp = t;
				send_noop_char();
			}
		} else {
			last_timestamp = time(NULL);
		}
	}
}

char reply_string[BUFSIZ];		/* first line of previous reply */

int
getreply(int expecteof)
{
	char current_line[BUFSIZ];	/* last line of previous reply */
	int c, n, lineno;
	int dig;
	int originalcode = 0, continuation = 0;
	sig_t oldintr;
	int pflag = 0;
	char *cp, *pt = pasv;

	memset(current_line, 0, sizeof(current_line));
	oldintr = signal(SIGINT, cmdabort);
	for (lineno = 0 ;; lineno++) {
		dig = n = code = 0;
		cp = current_line;
		while ((c = fgetc(cin)) != '\n') {
			if (c == IAC) {     /* handle telnet commands */
				switch (c = fgetc(cin)) {
				case WILL:
				case WONT:
					c = fgetc(cin);
					fprintf(cout, "%c%c%c", IAC, DONT, c);
					(void)fflush(cout);
					break;
				case DO:
				case DONT:
					c = fgetc(cin);
					fprintf(cout, "%c%c%c", IAC, WONT, c);
					(void)fflush(cout);
					break;
				default:
					break;
				}
				continue;
			}
			dig++;
			if (c == EOF) {
				if (expecteof) {
					(void)signal(SIGINT, oldintr);
					code = 221;
					return (0);
				}
				lostpeer();
				if (verbose) {
					fputs(
"421 Service not available, remote server has closed connection.\n", ttyout);
					(void)fflush(ttyout);
				}
				code = 421;
				return (4);
			}
			if (c != '\r' && (verbose > 0 ||
			    ((verbose > -1 && n == '5' && dig > 4) &&
			    (((!n && c < '5') || (n && n < '5'))
			     || !retry_connect)))) {
				if (proxflag &&
				   (dig == 1 || (dig == 5 && verbose == 0)))
					fprintf(ttyout, "%s:", hostname);
				(void)putc(c, ttyout);
			}
			if (dig < 4 && isdigit(c))
				code = code * 10 + (c - '0');
			if (!pflag && (code == 227 || code == 228))
				pflag = 1;
			else if (!pflag && code == 229)
				pflag = 100;
			if (dig > 4 && pflag == 1 && isdigit(c))
				pflag = 2;
			if (pflag == 2) {
				if (c != '\r' && c != ')') {
					if (pt < &pasv[sizeof(pasv) - 1])
						*pt++ = c;
				} else {
					*pt = '\0';
					pflag = 3;
				}
			}
			if (pflag == 100 && c == '(')
				pflag = 2;
			if (dig == 4 && c == '-') {
				if (continuation)
					code = 0;
				continuation++;
			}
			if (n == 0)
				n = c;
			if (cp < &current_line[sizeof(current_line) - 1])
				*cp++ = c;
		}
		if (verbose > 0 || ((verbose > -1 && n == '5') &&
		    (n < '5' || !retry_connect))) {
			(void)putc(c, ttyout);
			(void)fflush (ttyout);
		}
		if (lineno == 0) {
			size_t len = cp - current_line;

			if (len > sizeof(reply_string))
				len = sizeof(reply_string);

			(void)strlcpy(reply_string, current_line, len);
		}
		if (continuation && code != originalcode) {
			if (originalcode == 0)
				originalcode = code;
			continue;
		}
		*cp = '\0';
		if (n != '1')
			cpend = 0;
		(void)signal(SIGINT, oldintr);
		if (code == 421 || originalcode == 421)
			lostpeer();
		if (abrtflag && oldintr != cmdabort && oldintr != SIG_IGN)
			(*oldintr)(SIGINT);
		return (n - '0');
	}
}

#ifndef SMALL
jmp_buf	sendabort;

/* ARGSUSED */
void
abortsend(int signo)
{
	int save_errno = errno;
	alarmtimer(0);
	mflag = 0;
	abrtflag = 0;
#define MSG "\nsend aborted\nwaiting for remote to finish abort.\n"
	(void) write(fileno(ttyout), MSG, strlen(MSG));
#undef MSG

	errno = save_errno;
	longjmp(sendabort, 1);
}

void
sendrequest(const char *cmd, const char *local, const char *remote,
    int printnames)
{
	struct stat st;
	int c, d;
	FILE * volatile fin, * volatile dout;
	int (* volatile closefunc)(FILE *);
	volatile sig_t oldinti, oldintr, oldintp;
	volatile off_t hashbytes;
	char * volatile lmode;
	char buf[BUFSIZ], *bufp;
	int oprogress, serrno;

	hashbytes = mark;
	direction = "sent";
	dout = NULL;
	bytes = 0;
	filesize = -1;
	oprogress = progress;
	if (verbose && printnames) {
		if (local && *local != '-')
			fprintf(ttyout, "local: %s ", local);
		if (remote)
			fprintf(ttyout, "remote: %s\n", remote);
	}
	if (proxy) {
		proxtrans(cmd, local, remote);
		return;
	}
	if (curtype != type)
		changetype(type, 0);
	closefunc = NULL;
	oldintr = NULL;
	oldintp = NULL;
	oldinti = NULL;
	lmode = "w";
	if (setjmp(sendabort)) {
		while (cpend) {
			(void)getreply(0);
		}
		if (data >= 0) {
			(void)close(data);
			data = -1;
		}
		if (oldintr)
			(void)signal(SIGINT, oldintr);
		if (oldintp)
			(void)signal(SIGPIPE, oldintp);
		if (oldinti)
			(void)signal(SIGINFO, oldinti);
		progress = oprogress;
		code = -1;
		return;
	}
	oldintr = signal(SIGINT, abortsend);
	oldinti = signal(SIGINFO, psummary);
	if (strcmp(local, "-") == 0) {
		fin = stdin;
		if (progress == 1)
			progress = 0;
	} else if (*local == '|') {
		oldintp = signal(SIGPIPE, SIG_IGN);
		fin = popen(local + 1, "r");
		if (fin == NULL) {
			warn("%s", local + 1);
			(void)signal(SIGINT, oldintr);
			(void)signal(SIGPIPE, oldintp);
			(void)signal(SIGINFO, oldinti);
			code = -1;
			return;
		}
		if (progress == 1)
			progress = 0;
		closefunc = pclose;
	} else {
		fin = fopen(local, "r");
		if (fin == NULL) {
			warn("local: %s", local);
			(void)signal(SIGINT, oldintr);
			(void)signal(SIGINFO, oldinti);
			code = -1;
			return;
		}
		closefunc = fclose;
		if (fstat(fileno(fin), &st) < 0 ||
		    (st.st_mode & S_IFMT) != S_IFREG) {
			fprintf(ttyout, "%s: not a plain file.\n", local);
			(void)signal(SIGINT, oldintr);
			(void)signal(SIGINFO, oldinti);
			fclose(fin);
			code = -1;
			return;
		}
		filesize = st.st_size;
	}
	if (initconn()) {
		(void)signal(SIGINT, oldintr);
		(void)signal(SIGINFO, oldinti);
		if (oldintp)
			(void)signal(SIGPIPE, oldintp);
		code = -1;
		progress = oprogress;
		if (closefunc != NULL)
			(*closefunc)(fin);
		return;
	}
	if (setjmp(sendabort))
		goto abort;

	if (restart_point &&
	    (strcmp(cmd, "STOR") == 0 || strcmp(cmd, "APPE") == 0)) {
		int rc = -1;

		switch (curtype) {
		case TYPE_A:
			rc = fseeko(fin, restart_point, SEEK_SET);
			break;
		case TYPE_I:
			if (lseek(fileno(fin), restart_point, SEEK_SET) != -1)
				rc = 0;
			break;
		}
		if (rc == -1) {
			warn("local: %s", local);
			progress = oprogress;
			if (closefunc != NULL)
				(*closefunc)(fin);
			return;
		}
		if (command("REST %lld", (long long) restart_point)
			!= CONTINUE) {
			progress = oprogress;
			if (closefunc != NULL)
				(*closefunc)(fin);
			return;
		}
		lmode = "r+w";
	}
	if (remote) {
		if (command("%s %s", cmd, remote) != PRELIM) {
			(void)signal(SIGINT, oldintr);
			(void)signal(SIGINFO, oldinti);
			progress = oprogress;
			if (oldintp)
				(void)signal(SIGPIPE, oldintp);
			if (closefunc != NULL)
				(*closefunc)(fin);
			return;
		}
	} else
		if (command("%s", cmd) != PRELIM) {
			(void)signal(SIGINT, oldintr);
			(void)signal(SIGINFO, oldinti);
			progress = oprogress;
			if (oldintp)
				(void)signal(SIGPIPE, oldintp);
			if (closefunc != NULL)
				(*closefunc)(fin);
			return;
		}
	dout = dataconn(lmode);
	if (dout == NULL)
		goto abort;
	progressmeter(-1, remote);
	may_reset_noop_timeout();
	oldintp = signal(SIGPIPE, SIG_IGN);
	serrno = 0;
	switch (curtype) {

	case TYPE_I:
		d = 0;
		while ((c = read(fileno(fin), buf, sizeof(buf))) > 0) {
			may_send_noop_char();
			bytes += c;
			for (bufp = buf; c > 0; c -= d, bufp += d)
				if ((d = write(fileno(dout), bufp, (size_t)c))
				    <= 0)
					break;
			if (hash && (!progress || filesize < 0) ) {
				while (bytes >= hashbytes) {
					(void)putc('#', ttyout);
					hashbytes += mark;
				}
				(void)fflush(ttyout);
			}
		}
		if (c == -1 || d == -1)
			serrno = errno;
		if (hash && (!progress || filesize < 0) && bytes > 0) {
			if (bytes < mark)
				(void)putc('#', ttyout);
			(void)putc('\n', ttyout);
			(void)fflush(ttyout);
		}
		if (c < 0)
			warnc(serrno, "local: %s", local);
		if (d < 0) {
			if (serrno != EPIPE)
				warnc(serrno, "netout");
			bytes = -1;
		}
		break;

	case TYPE_A:
		while ((c = fgetc(fin)) != EOF) {
			may_send_noop_char();
			if (c == '\n') {
				while (hash && (!progress || filesize < 0) &&
				    (bytes >= hashbytes)) {
					(void)putc('#', ttyout);
					(void)fflush(ttyout);
					hashbytes += mark;
				}
				if (ferror(dout))
					break;
				(void)putc('\r', dout);
				bytes++;
			}
			(void)putc(c, dout);
			bytes++;
		}
		if (ferror(fin) || ferror(dout))
			serrno = errno;
		if (hash && (!progress || filesize < 0)) {
			if (bytes < hashbytes)
				(void)putc('#', ttyout);
			(void)putc('\n', ttyout);
			(void)fflush(ttyout);
		}
		if (ferror(fin))
			warnc(serrno, "local: %s", local);
		if (ferror(dout)) {
			if (errno != EPIPE)
				warnc(serrno, "netout");
			bytes = -1;
		}
		break;
	}
	progressmeter(1, NULL);
	progress = oprogress;
	if (closefunc != NULL)
		(*closefunc)(fin);
	(void)fclose(dout);
	(void)getreply(0);
	may_receive_noop_ack();
	(void)signal(SIGINT, oldintr);
	(void)signal(SIGINFO, oldinti);
	if (oldintp)
		(void)signal(SIGPIPE, oldintp);
	if (bytes > 0)
		ptransfer(0);
	return;
abort:
	(void)signal(SIGINT, oldintr);
	(void)signal(SIGINFO, oldinti);
	progress = oprogress;
	if (oldintp)
		(void)signal(SIGPIPE, oldintp);
	if (!cpend) {
		code = -1;
		return;
	}
	if (data >= 0) {
		(void)close(data);
		data = -1;
	}
	if (dout)
		(void)fclose(dout);
	(void)getreply(0);
	code = -1;
	if (closefunc != NULL && fin != NULL)
		(*closefunc)(fin);
	if (bytes > 0)
		ptransfer(0);
}
#endif /* !SMALL */

jmp_buf	recvabort;

/* ARGSUSED */
void
abortrecv(int signo)
{

	alarmtimer(0);
	mflag = 0;
	abrtflag = 0;
	fputs("\nreceive aborted\nwaiting for remote to finish abort.\n", ttyout);
	(void)fflush(ttyout);
	longjmp(recvabort, 1);
}

void
recvrequest(const char *cmd, const char * volatile local, const char *remote,
    const char *lmode, int printnames, int ignorespecial)
{
	FILE * volatile fout, * volatile din;
	int (* volatile closefunc)(FILE *);
	volatile sig_t oldinti, oldintr, oldintp;
	int c, d, serrno;
	volatile int is_retr, tcrflag, bare_lfs;
	static size_t bufsize;
	static char *buf;
	volatile off_t hashbytes;
	struct stat st;
	time_t mtime;
	int oprogress;
	int opreserve;

	fout = NULL;
	din = NULL;
	oldinti = NULL;
	hashbytes = mark;
	direction = "received";
	bytes = 0;
	bare_lfs = 0;
	filesize = -1;
	oprogress = progress;
	opreserve = preserve;
	is_retr = strcmp(cmd, "RETR") == 0;
	if (is_retr && verbose && printnames) {
		if (local && (ignorespecial || *local != '-'))
			fprintf(ttyout, "local: %s ", local);
		if (remote)
			fprintf(ttyout, "remote: %s\n", remote);
	}
	if (proxy && is_retr) {
		proxtrans(cmd, local, remote);
		return;
	}
	closefunc = NULL;
	oldintr = NULL;
	oldintp = NULL;
	tcrflag = !crflag && is_retr;
	if (setjmp(recvabort)) {
		while (cpend) {
			(void)getreply(0);
		}
		if (data >= 0) {
			(void)close(data);
			data = -1;
		}
		if (oldintr)
			(void)signal(SIGINT, oldintr);
		if (oldinti)
			(void)signal(SIGINFO, oldinti);
		progress = oprogress;
		preserve = opreserve;
		code = -1;
		return;
	}
	oldintr = signal(SIGINT, abortrecv);
	oldinti = signal(SIGINFO, psummary);
	if (ignorespecial || (strcmp(local, "-") && *local != '|')) {
		if (access(local, W_OK) < 0) {
			char *dir;

			if (errno != ENOENT && errno != EACCES) {
				warn("local: %s", local);
				(void)signal(SIGINT, oldintr);
				(void)signal(SIGINFO, oldinti);
				code = -1;
				return;
			}
			dir = strrchr(local, '/');
			if (dir != NULL)
				*dir = 0;
			d = access(dir == local ? "/" : dir ? local : ".", W_OK);
			if (dir != NULL)
				*dir = '/';
			if (d < 0) {
				warn("local: %s", local);
				(void)signal(SIGINT, oldintr);
				(void)signal(SIGINFO, oldinti);
				code = -1;
				return;
			}
			if (!runique && errno == EACCES &&
			    chmod(local, (S_IRUSR|S_IWUSR)) < 0) {
				warn("local: %s", local);
				(void)signal(SIGINT, oldintr);
				(void)signal(SIGINFO, oldinti);
				code = -1;
				return;
			}
			if (runique && errno == EACCES &&
			   (local = gunique(local)) == NULL) {
				(void)signal(SIGINT, oldintr);
				(void)signal(SIGINFO, oldinti);
				code = -1;
				return;
			}
		}
		else if (runique && (local = gunique(local)) == NULL) {
			(void)signal(SIGINT, oldintr);
			(void)signal(SIGINFO, oldinti);
			code = -1;
			return;
		}
	}
	if (!is_retr) {
		if (curtype != TYPE_A)
			changetype(TYPE_A, 0);
	} else {
		if (curtype != type)
			changetype(type, 0);
		filesize = remotesize(remote, 0);
	}
	if (initconn()) {
		(void)signal(SIGINT, oldintr);
		(void)signal(SIGINFO, oldinti);
		code = -1;
		return;
	}
	if (setjmp(recvabort))
		goto abort;
	if (is_retr && restart_point &&
	    command("REST %lld", (long long) restart_point) != CONTINUE)
		return;
	if (remote) {
		if (command("%s %s", cmd, remote) != PRELIM) {
			(void)signal(SIGINT, oldintr);
			(void)signal(SIGINFO, oldinti);
			return;
		}
	} else {
		if (command("%s", cmd) != PRELIM) {
			(void)signal(SIGINT, oldintr);
			(void)signal(SIGINFO, oldinti);
			return;
		}
	}
	din = dataconn("r");
	if (din == NULL)
		goto abort;
	if (!ignorespecial && strcmp(local, "-") == 0) {
		fout = stdout;
		preserve = 0;
	} else if (!ignorespecial && *local == '|') {
		oldintp = signal(SIGPIPE, SIG_IGN);
		fout = popen(local + 1, "w");
		if (fout == NULL) {
			warn("%s", local+1);
			goto abort;
		}
		if (progress == 1)
			progress = 0;
		preserve = 0;
		closefunc = pclose;
	} else {
		fout = fopen(local, lmode);
		if (fout == NULL) {
			warn("local: %s", local);
			goto abort;
		}
		closefunc = fclose;
	}
	if (fstat(fileno(fout), &st) < 0 || st.st_blksize == 0)
		st.st_blksize = BUFSIZ;
	if (st.st_blksize > bufsize) {
		(void)free(buf);
		buf = malloc((unsigned)st.st_blksize);
		if (buf == NULL) {
			warn("malloc");
			bufsize = 0;
			goto abort;
		}
		bufsize = st.st_blksize;
	}
	if ((st.st_mode & S_IFMT) != S_IFREG) {
		if (progress == 1)
			progress = 0;
		preserve = 0;
	}
	progressmeter(-1, remote);
	may_reset_noop_timeout();
	serrno = 0;
	switch (curtype) {

	case TYPE_I:
		if (restart_point &&
		    lseek(fileno(fout), restart_point, SEEK_SET) < 0) {
			warn("local: %s", local);
			progress = oprogress;
			preserve = opreserve;
			if (closefunc != NULL)
				(*closefunc)(fout);
			return;
		}
		errno = d = 0;
		while ((c = read(fileno(din), buf, bufsize)) > 0) {
			ssize_t	wr;
			size_t	rd = c;

			may_send_noop_char();
			d = 0;
			do {
				wr = write(fileno(fout), buf + d, rd);
				if (wr == -1) {
					d = -1;
					break;
				}
				d += wr;
				rd -= wr;
			} while (d < c);
			if (rd != 0)
				break;
			bytes += c;
			if (hash && (!progress || filesize < 0)) {
				while (bytes >= hashbytes) {
					(void)putc('#', ttyout);
					hashbytes += mark;
				}
				(void)fflush(ttyout);
			}
		}
		if (c == -1 || d < c)
			serrno = errno;
		if (hash && (!progress || filesize < 0) && bytes > 0) {
			if (bytes < mark)
				(void)putc('#', ttyout);
			(void)putc('\n', ttyout);
			(void)fflush(ttyout);
		}
		if (c < 0) {
			if (serrno != EPIPE)
				warnc(serrno, "netin");
			bytes = -1;
		}
		if (d < c) {
			if (d < 0)
				warnc(serrno, "local: %s", local);
			else
				warnx("%s: short write", local);
		}
		break;

	case TYPE_A:
		if (restart_point) {
			int i, n, ch;

			if (fseek(fout, 0L, SEEK_SET) < 0)
				goto done;
			n = restart_point;
			for (i = 0; i++ < n;) {
				if ((ch = fgetc(fout)) == EOF) {
					if (!ferror(fout))
						errno = 0;
					goto done;
				}
				if (ch == '\n')
					i++;
			}
			if (fseek(fout, 0L, SEEK_CUR) < 0) {
done:
				if (errno)
					warn("local: %s", local);
				else
					warnx("local: %s", local);
				progress = oprogress;
				preserve = opreserve;
				if (closefunc != NULL)
					(*closefunc)(fout);
				return;
			}
		}
		while ((c = fgetc(din)) != EOF) {
			may_send_noop_char();
			if (c == '\n')
				bare_lfs++;
			while (c == '\r') {
				while (hash && (!progress || filesize < 0) &&
				    (bytes >= hashbytes)) {
					(void)putc('#', ttyout);
					(void)fflush(ttyout);
					hashbytes += mark;
				}
				bytes++;
				if ((c = fgetc(din)) != '\n' || tcrflag) {
					if (ferror(fout))
						goto break2;
					(void)putc('\r', fout);
					if (c == '\0') {
						bytes++;
						goto contin2;
					}
					if (c == EOF)
						goto contin2;
				}
			}
			(void)putc(c, fout);
			bytes++;
	contin2:	;
		}
break2:
		if (ferror(din) || ferror(fout))
			serrno = errno;
		if (bare_lfs) {
			fprintf(ttyout,
"WARNING! %d bare linefeeds received in ASCII mode.\n", bare_lfs);
			fputs("File may not have transferred correctly.\n",
			    ttyout);
		}
		if (hash && (!progress || filesize < 0)) {
			if (bytes < hashbytes)
				(void)putc('#', ttyout);
			(void)putc('\n', ttyout);
			(void)fflush(ttyout);
		}
		if (ferror(din)) {
			if (serrno != EPIPE)
				warnc(serrno, "netin");
			bytes = -1;
		}
		if (ferror(fout))
			warnc(serrno, "local: %s", local);
		break;
	}
	progressmeter(1, NULL);
	progress = oprogress;
	preserve = opreserve;
	if (closefunc != NULL)
		(*closefunc)(fout);
	(void)signal(SIGINT, oldintr);
	(void)signal(SIGINFO, oldinti);
	if (oldintp)
		(void)signal(SIGPIPE, oldintp);
	(void)fclose(din);
	(void)getreply(0);
	may_receive_noop_ack();
	if (bytes >= 0 && is_retr) {
		if (bytes > 0)
			ptransfer(0);
		if (preserve && (closefunc == fclose)) {
			mtime = remotemodtime(remote, 0);
			if (mtime != -1) {
				struct utimbuf ut;

				ut.actime = time(NULL);
				ut.modtime = mtime;
				if (utime(local, &ut) == -1)
					fprintf(ttyout,
				"Can't change modification time on %s to %s",
					    local, asctime(localtime(&mtime)));
			}
		}
	}
	return;

abort:
	/* abort using RFC959 recommended IP,SYNC sequence */
	progress = oprogress;
	preserve = opreserve;
	if (oldintp)
		(void)signal(SIGPIPE, oldintp);
	(void)signal(SIGINT, SIG_IGN);
	if (!cpend) {
		code = -1;
		(void)signal(SIGINT, oldintr);
		(void)signal(SIGINFO, oldinti);
		return;
	}

	abort_remote(din);
	code = -1;
	if (data >= 0) {
		(void)close(data);
		data = -1;
	}
	if (closefunc != NULL && fout != NULL)
		(*closefunc)(fout);
	if (din)
		(void)fclose(din);
	if (bytes > 0)
		ptransfer(0);
	(void)signal(SIGINT, oldintr);
	(void)signal(SIGINFO, oldinti);
}

/*
 * Need to start a listen on the data channel before we send the command,
 * otherwise the server's connect may fail.
 */
int
initconn(void)
{
	char *p, *a;
	int result = ERROR, tmpno = 0;
	int on = 1;
	int error;
	u_int addr[16], port[2];
	u_int af, hal, pal;
	char *pasvcmd = NULL;
	socklen_t namelen;
#ifndef SMALL
	struct addrinfo *ares;
#endif

	if (myctladdr.sa.sa_family == AF_INET6
	 && (IN6_IS_ADDR_LINKLOCAL(&myctladdr.sin6.sin6_addr)
	  || IN6_IS_ADDR_SITELOCAL(&myctladdr.sin6.sin6_addr))) {
		warnx("use of scoped address can be troublesome");
	}
#ifndef SMALL
	if (srcaddr) {
		struct addrinfo ahints;

		memset(&ahints, 0, sizeof(ahints));
		ahints.ai_family = family;
		ahints.ai_socktype = SOCK_STREAM;
		ahints.ai_flags |= AI_NUMERICHOST;
		ahints.ai_protocol = 0;

		error = getaddrinfo(srcaddr, NULL, &ahints, &ares);
		if (error) {
			warnx("%s: %s", srcaddr, gai_strerror(error));
			code = -1;
			return (0);
		}
	}
#endif /* !SMALL */
reinit:
	if (passivemode) {
		data_addr = myctladdr;
		data = socket(data_addr.sa.sa_family, SOCK_STREAM, 0);
		if (data < 0) {
			warn("socket");
			return (1);
		}
#ifndef SMALL
		if (srcaddr) {
			if (bind(data, ares->ai_addr, ares->ai_addrlen) < 0) {
				warn("bind");
				close(data);
				return (1);
			}
		}
		if ((options & SO_DEBUG) &&
		    setsockopt(data, SOL_SOCKET, SO_DEBUG, (char *)&on,
			       sizeof(on)) < 0)
			warn("setsockopt (ignored)");
#endif /* !SMALL */
		switch (data_addr.sa.sa_family) {
		case AF_INET:
			if (epsv4 && !epsv4bad) {
				int ov;
				/* shut this command up in case it fails */
				ov = verbose;
				verbose = -1;
				result = command(pasvcmd = "EPSV");
				/*
				 * now back to whatever verbosity we had before
				 * and we can try PASV
				 */
				verbose = ov;
				if (code / 10 == 22 && code != 229) {
					fputs(
"wrong server: return code must be 229\n",
						ttyout);
					result = COMPLETE + 1;
				}
				if (result != COMPLETE) {
					epsv4bad = 1;
#ifndef SMALL
					if (debug) {
						fputs(
"disabling epsv4 for this connection\n",
						    ttyout);
					}
#endif /* !SMALL */
				}
			}
			if (result != COMPLETE)
				result = command(pasvcmd = "PASV");
			break;
		case AF_INET6:
			result = command(pasvcmd = "EPSV");
			if (code / 10 == 22 && code != 229) {
				fputs(
"wrong server: return code must be 229\n",
					ttyout);
				result = COMPLETE + 1;
			}
			if (result != COMPLETE)
				result = command(pasvcmd = "LPSV");
			break;
		default:
			result = COMPLETE + 1;
			break;
		}
		if (result != COMPLETE) {
			if (activefallback) {
				(void)close(data);
				data = -1;
				passivemode = 0;
				activefallback = 0;
				goto reinit;
			}
			fputs("Passive mode refused.\n", ttyout);
			goto bad;
		}

#define pack2(var, off) \
	(((var[(off) + 0] & 0xff) << 8) | ((var[(off) + 1] & 0xff) << 0))
#define pack4(var, off) \
	(((var[(off) + 0] & 0xff) << 24) | ((var[(off) + 1] & 0xff) << 16) | \
	 ((var[(off) + 2] & 0xff) << 8) | ((var[(off) + 3] & 0xff) << 0))

		/*
		 * What we've got at this point is a string of comma separated
		 * one-byte unsigned integer values, separated by commas.
		 */
		if (!pasvcmd)
			goto bad;
		if (strcmp(pasvcmd, "PASV") == 0) {
			if (data_addr.sa.sa_family != AF_INET) {
				fputs(
"Passive mode AF mismatch. Shouldn't happen!\n", ttyout);
				goto bad;
			}
			if (code / 10 == 22 && code != 227) {
				fputs("wrong server: return code must be 227\n",
					ttyout);
				goto bad;
			}
			error = sscanf(pasv, "%u,%u,%u,%u,%u,%u",
					&addr[0], &addr[1], &addr[2], &addr[3],
					&port[0], &port[1]);
			if (error != 6) {
				fputs(
"Passive mode address scan failure. Shouldn't happen!\n", ttyout);
				goto bad;
			}
			memset(&data_addr, 0, sizeof(data_addr));
			data_addr.sin.sin_family = AF_INET;
			data_addr.sin.sin_len = sizeof(struct sockaddr_in);
			data_addr.sin.sin_addr.s_addr =
				htonl(pack4(addr, 0));
			data_addr.sin.sin_port = htons(pack2(port, 0));
		} else if (strcmp(pasvcmd, "LPSV") == 0) {
			if (code / 10 == 22 && code != 228) {
				fputs("wrong server: return code must be 228\n",
					ttyout);
				goto bad;
			}
			switch (data_addr.sa.sa_family) {
			case AF_INET:
				error = sscanf(pasv,
"%u,%u,%u,%u,%u,%u,%u,%u,%u",
					&af, &hal,
					&addr[0], &addr[1], &addr[2], &addr[3],
					&pal, &port[0], &port[1]);
				if (error != 9) {
					fputs(
"Passive mode address scan failure. Shouldn't happen!\n", ttyout);
					goto bad;
				}
				if (af != 4 || hal != 4 || pal != 2) {
					fputs(
"Passive mode AF mismatch. Shouldn't happen!\n", ttyout);
					error = 1;
					goto bad;
				}

				memset(&data_addr, 0, sizeof(data_addr));
				data_addr.sin.sin_family = AF_INET;
				data_addr.sin.sin_len = sizeof(struct sockaddr_in);
				data_addr.sin.sin_addr.s_addr =
					htonl(pack4(addr, 0));
				data_addr.sin.sin_port = htons(pack2(port, 0));
				break;
			case AF_INET6:
				error = sscanf(pasv,
"%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u",
					&af, &hal,
					&addr[0], &addr[1], &addr[2], &addr[3],
					&addr[4], &addr[5], &addr[6], &addr[7],
					&addr[8], &addr[9], &addr[10],
					&addr[11], &addr[12], &addr[13],
					&addr[14], &addr[15],
					&pal, &port[0], &port[1]);
				if (error != 21) {
					fputs(
"Passive mode address scan failure. Shouldn't happen!\n", ttyout);
					goto bad;
				}
				if (af != 6 || hal != 16 || pal != 2) {
					fputs(
"Passive mode AF mismatch. Shouldn't happen!\n", ttyout);
					goto bad;
				}

				memset(&data_addr, 0, sizeof(data_addr));
				data_addr.sin6.sin6_family = AF_INET6;
				data_addr.sin6.sin6_len = sizeof(struct sockaddr_in6);
			    {
				u_int32_t *p32;
				p32 = (u_int32_t *)&data_addr.sin6.sin6_addr;
				p32[0] = htonl(pack4(addr, 0));
				p32[1] = htonl(pack4(addr, 4));
				p32[2] = htonl(pack4(addr, 8));
				p32[3] = htonl(pack4(addr, 12));
			    }
				data_addr.sin6.sin6_port = htons(pack2(port, 0));
				break;
			default:
				fputs("Bad family!\n", ttyout);
				goto bad;
			}
		} else if (strcmp(pasvcmd, "EPSV") == 0) {
			char delim[4];

			port[0] = 0;
			if (code / 10 == 22 && code != 229) {
				fputs("wrong server: return code must be 229\n",
					ttyout);
				goto bad;
			}
			if (sscanf(pasv, "%c%c%c%d%c", &delim[0],
					&delim[1], &delim[2], &port[1],
					&delim[3]) != 5) {
				fputs("parse error!\n", ttyout);
				goto bad;
			}
			if (delim[0] != delim[1] || delim[0] != delim[2]
			 || delim[0] != delim[3]) {
				fputs("parse error!\n", ttyout);
				goto bad;
			}
			data_addr = hisctladdr;
			data_addr.sin.sin_port = htons(port[1]);
		} else
			goto bad;

		for (error = connect(data, &data_addr.sa, data_addr.sa.sa_len);
		    error != 0 && errno == EINTR;
		    error = connect_wait(data))
			continue;
		if (error != 0) {
			if (activefallback) {
				(void)close(data);
				data = -1;
				passivemode = 0;
				activefallback = 0;
				goto reinit;
			}
			warn("connect");
			goto bad;
		}
		if (data_addr.sa.sa_family == AF_INET) {
			on = IPTOS_THROUGHPUT;
			if (setsockopt(data, IPPROTO_IP, IP_TOS, (char *)&on,
				       sizeof(int)) < 0)
				warn("setsockopt TOS (ignored)");
		}
		return (0);
	}

noport:
	data_addr = myctladdr;
	if (sendport)
		data_addr.sin.sin_port = 0;	/* let system pick one */
	if (data != -1)
		(void)close(data);
	data = socket(data_addr.sa.sa_family, SOCK_STREAM, 0);
	if (data < 0) {
		warn("socket");
		if (tmpno)
			sendport = 1;
		return (1);
	}
	if (!sendport)
		if (setsockopt(data, SOL_SOCKET, SO_REUSEADDR, (char *)&on,
				sizeof(on)) < 0) {
			warn("setsockopt (reuse address)");
			goto bad;
		}
	switch (data_addr.sa.sa_family) {
	case AF_INET:
		on = IP_PORTRANGE_HIGH;
		if (setsockopt(data, IPPROTO_IP, IP_PORTRANGE,
		    (char *)&on, sizeof(on)) < 0)
			warn("setsockopt IP_PORTRANGE (ignored)");
		break;
	case AF_INET6:
		on = IPV6_PORTRANGE_HIGH;
		if (setsockopt(data, IPPROTO_IPV6, IPV6_PORTRANGE,
		    (char *)&on, sizeof(on)) < 0)
			warn("setsockopt IPV6_PORTRANGE (ignored)");
		break;
	}
	if (bind(data, &data_addr.sa, data_addr.sa.sa_len) < 0) {
		warn("bind");
		goto bad;
	}
#ifndef SMALL
	if (options & SO_DEBUG &&
	    setsockopt(data, SOL_SOCKET, SO_DEBUG, (char *)&on,
			sizeof(on)) < 0)
		warn("setsockopt (ignored)");
#endif /* !SMALL */
	namelen = sizeof(data_addr);
	if (getsockname(data, &data_addr.sa, &namelen) < 0) {
		warn("getsockname");
		goto bad;
	}
	if (listen(data, 1) < 0)
		warn("listen");

#define	UC(b)	(((int)b)&0xff)

	if (sendport) {
		char hname[NI_MAXHOST], pbuf[NI_MAXSERV];
		int af_tmp;
		union sockaddr_union tmp;

		tmp = data_addr;
		switch (tmp.sa.sa_family) {
		case AF_INET:
			if (!epsv4 || epsv4bad) {
				result = COMPLETE +1;
				break;
			}
			/*FALLTHROUGH*/
		case AF_INET6:
			if (tmp.sa.sa_family == AF_INET6)
				tmp.sin6.sin6_scope_id = 0;
			af_tmp = (tmp.sa.sa_family == AF_INET) ? 1 : 2;
			if (getnameinfo(&tmp.sa, tmp.sa.sa_len, hname,
			    sizeof(hname), pbuf, sizeof(pbuf),
			    NI_NUMERICHOST | NI_NUMERICSERV)) {
				result = ERROR;
			} else {
				result = command("EPRT |%d|%s|%s|",
				    af_tmp, hname, pbuf);
				if (result != COMPLETE) {
					epsv4bad = 1;
#ifndef SMALL
					if (debug) {
						fputs(
"disabling epsv4 for this connection\n",
						    ttyout);
					}
#endif /* !SMALL */
				}
			}
			break;
		default:
			result = COMPLETE + 1;
			break;
		}
		if (result == COMPLETE)
			goto skip_port;

		switch (data_addr.sa.sa_family) {
		case AF_INET:
			a = (char *)&data_addr.sin.sin_addr;
			p = (char *)&data_addr.sin.sin_port;
			result = command("PORT %d,%d,%d,%d,%d,%d",
				 UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]),
				 UC(p[0]), UC(p[1]));
			break;
		case AF_INET6:
			a = (char *)&data_addr.sin6.sin6_addr;
			p = (char *)&data_addr.sin6.sin6_port;
			result = command(
"LPRT %d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
				 6, 16,
				 UC(a[0]),UC(a[1]),UC(a[2]),UC(a[3]),
				 UC(a[4]),UC(a[5]),UC(a[6]),UC(a[7]),
				 UC(a[8]),UC(a[9]),UC(a[10]),UC(a[11]),
				 UC(a[12]),UC(a[13]),UC(a[14]),UC(a[15]),
				 2, UC(p[0]), UC(p[1]));
			break;
		default:
			result = COMPLETE + 1; /* xxx */
		}
	skip_port:

		if (result == ERROR && sendport == -1) {
			sendport = 0;
			tmpno = 1;
			goto noport;
		}
		return (result != COMPLETE);
	}
	if (tmpno)
		sendport = 1;
	if (data_addr.sa.sa_family == AF_INET) {
		on = IPTOS_THROUGHPUT;
		if (setsockopt(data, IPPROTO_IP, IP_TOS, (char *)&on,
			       sizeof(int)) < 0)
			warn("setsockopt TOS (ignored)");
	}
	return (0);
bad:
	(void)close(data), data = -1;
	if (tmpno)
		sendport = 1;
	return (1);
}

FILE *
dataconn(const char *lmode)
{
	union sockaddr_union from;
	socklen_t fromlen = myctladdr.sa.sa_len;
	int s;

	if (passivemode)
		return (fdopen(data, lmode));

	s = accept(data, &from.sa, &fromlen);
	if (s < 0) {
		warn("accept");
		(void)close(data), data = -1;
		return (NULL);
	}
	(void)close(data);
	data = s;
	if (from.sa.sa_family == AF_INET) {
		int tos = IPTOS_THROUGHPUT;
		if (setsockopt(s, IPPROTO_IP, IP_TOS, (char *)&tos,
				sizeof(int)) < 0) {
			warn("setsockopt TOS (ignored)");
		}
	}
	return (fdopen(data, lmode));
}

/* ARGSUSED */
void
psummary(int signo)
{
	int save_errno = errno;

	if (bytes > 0)
		ptransfer(1);
	errno = save_errno;
}

/* ARGSUSED */
void
psabort(int signo)
{

	alarmtimer(0);
	abrtflag++;
}

void
pswitch(int flag)
{
	sig_t oldintr;
	static struct comvars {
		int connect;
		char name[HOST_NAME_MAX+1];
		union sockaddr_union mctl;
		union sockaddr_union hctl;
		FILE *in;
		FILE *out;
		int tpe;
		int curtpe;
		int cpnd;
		int sunqe;
		int runqe;
		int mcse;
		int ntflg;
		char nti[17];
		char nto[17];
		int mapflg;
		char mi[PATH_MAX];
		char mo[PATH_MAX];
	} proxstruct, tmpstruct;
	struct comvars *ip, *op;

	abrtflag = 0;
	oldintr = signal(SIGINT, psabort);
	if (flag) {
		if (proxy)
			return;
		ip = &tmpstruct;
		op = &proxstruct;
		proxy++;
	} else {
		if (!proxy)
			return;
		ip = &proxstruct;
		op = &tmpstruct;
		proxy = 0;
	}
	ip->connect = connected;
	connected = op->connect;
	if (hostname) {
		(void)strlcpy(ip->name, hostname, sizeof(ip->name));
	} else
		ip->name[0] = '\0';
	hostname = op->name;
	ip->hctl = hisctladdr;
	hisctladdr = op->hctl;
	ip->mctl = myctladdr;
	myctladdr = op->mctl;
	ip->in = cin;
	cin = op->in;
	ip->out = cout;
	cout = op->out;
	ip->tpe = type;
	type = op->tpe;
	ip->curtpe = curtype;
	curtype = op->curtpe;
	ip->cpnd = cpend;
	cpend = op->cpnd;
	ip->sunqe = sunique;
	sunique = op->sunqe;
	ip->runqe = runique;
	runique = op->runqe;
	ip->mcse = mcase;
	mcase = op->mcse;
	ip->ntflg = ntflag;
	ntflag = op->ntflg;
	(void)strlcpy(ip->nti, ntin, sizeof(ip->nti));
	(void)strlcpy(ntin, op->nti, sizeof ntin);
	(void)strlcpy(ip->nto, ntout, sizeof(ip->nto));
	(void)strlcpy(ntout, op->nto, sizeof ntout);
	ip->mapflg = mapflag;
	mapflag = op->mapflg;
	(void)strlcpy(ip->mi, mapin, sizeof(ip->mi));
	(void)strlcpy(mapin, op->mi, sizeof mapin);
	(void)strlcpy(ip->mo, mapout, sizeof(ip->mo));
	(void)strlcpy(mapout, op->mo, sizeof mapout);
	(void)signal(SIGINT, oldintr);
	if (abrtflag) {
		abrtflag = 0;
		(*oldintr)(SIGINT);
	}
}

/* ARGSUSED */
void
abortpt(int signo)
{

	alarmtimer(0);
	putc('\n', ttyout);
	(void)fflush(ttyout);
	ptabflg++;
	mflag = 0;
	abrtflag = 0;
	longjmp(ptabort, 1);
}

void
proxtrans(const char *cmd, const char *local, const char *remote)
{
	volatile sig_t oldintr;
	int prox_type, nfnd;
	volatile int secndflag;
	char * volatile cmd2;
	struct pollfd pfd[1];

	oldintr = NULL;
	secndflag = 0;
	if (strcmp(cmd, "RETR"))
		cmd2 = "RETR";
	else
		cmd2 = runique ? "STOU" : "STOR";
	if ((prox_type = type) == 0) {
		if (unix_server && unix_proxy)
			prox_type = TYPE_I;
		else
			prox_type = TYPE_A;
	}
	if (curtype != prox_type)
		changetype(prox_type, 1);
	if (command("PASV") != COMPLETE) {
		fputs("proxy server does not support third party transfers.\n",
		    ttyout);
		return;
	}
	pswitch(0);
	if (!connected) {
		fputs("No primary connection.\n", ttyout);
		pswitch(1);
		code = -1;
		return;
	}
	if (curtype != prox_type)
		changetype(prox_type, 1);
	if (command("PORT %s", pasv) != COMPLETE) {
		pswitch(1);
		return;
	}
	if (setjmp(ptabort))
		goto abort;
	oldintr = signal(SIGINT, abortpt);
	if (command("%s %s", cmd, remote) != PRELIM) {
		(void)signal(SIGINT, oldintr);
		pswitch(1);
		return;
	}
	sleep(2);
	pswitch(1);
	secndflag++;
	if (command("%s %s", cmd2, local) != PRELIM)
		goto abort;
	ptflag++;
	(void)getreply(0);
	pswitch(0);
	(void)getreply(0);
	(void)signal(SIGINT, oldintr);
	pswitch(1);
	ptflag = 0;
	fprintf(ttyout, "local: %s remote: %s\n", local, remote);
	return;
abort:
	(void)signal(SIGINT, SIG_IGN);
	ptflag = 0;
	if (strcmp(cmd, "RETR") && !proxy)
		pswitch(1);
	else if (!strcmp(cmd, "RETR") && proxy)
		pswitch(0);
	if (!cpend && !secndflag) {  /* only here if cmd = "STOR" (proxy=1) */
		if (command("%s %s", cmd2, local) != PRELIM) {
			pswitch(0);
			if (cpend)
				abort_remote(NULL);
		}
		pswitch(1);
		if (ptabflg)
			code = -1;
		(void)signal(SIGINT, oldintr);
		return;
	}
	if (cpend)
		abort_remote(NULL);
	pswitch(!proxy);
	if (!cpend && !secndflag) {  /* only if cmd = "RETR" (proxy=1) */
		if (command("%s %s", cmd2, local) != PRELIM) {
			pswitch(0);
			if (cpend)
				abort_remote(NULL);
			pswitch(1);
			if (ptabflg)
				code = -1;
			(void)signal(SIGINT, oldintr);
			return;
		}
	}
	if (cpend)
		abort_remote(NULL);
	pswitch(!proxy);
	if (cpend) {
		pfd[0].fd = fileno(cin);
		pfd[0].events = POLLIN;
		if ((nfnd = poll(pfd, 1, 10 * 1000)) <= 0) {
			if (nfnd < 0)
				warn("abort");
			if (ptabflg)
				code = -1;
			lostpeer();
		}
		(void)getreply(0);
		(void)getreply(0);
	}
	if (proxy)
		pswitch(0);
	pswitch(1);
	if (ptabflg)
		code = -1;
	(void)signal(SIGINT, oldintr);
}

#ifndef SMALL
/* ARGSUSED */
void
reset(int argc, char *argv[])
{
	struct pollfd pfd[1];
	int nfnd = 1;

	pfd[0].fd = fileno(cin);
	pfd[0].events = POLLIN;
	while (nfnd > 0) {
		if ((nfnd = poll(pfd, 1, 0)) < 0) {
			warn("reset");
			code = -1;
			lostpeer();
		} else if (nfnd) {
			(void)getreply(0);
		}
	}
}
#endif

char *
gunique(const char *local)
{
	static char new[PATH_MAX];
	char *cp = strrchr(local, '/');
	int d, count=0;
	char ext = '1';

	if (cp)
		*cp = '\0';
	d = access(cp == local ? "/" : cp ? local : ".", W_OK);
	if (cp)
		*cp = '/';
	if (d < 0) {
		warn("local: %s", local);
		return ((char *) 0);
	}
	(void)strlcpy(new, local, sizeof new);
	cp = new + strlen(new);
	*cp++ = '.';
	while (!d) {
		if (++count == 100) {
			fputs("runique: can't find unique file name.\n", ttyout);
			return ((char *) 0);
		}
		*cp++ = ext;
		*cp = '\0';
		if (ext == '9')
			ext = '0';
		else
			ext++;
		if ((d = access(new, F_OK)) < 0)
			break;
		if (ext != '0')
			cp--;
		else if (*(cp - 2) == '.')
			*(cp - 1) = '1';
		else {
			*(cp - 2) = *(cp - 2) + 1;
			cp--;
		}
	}
	return (new);
}

jmp_buf forceabort;

/* ARGSUSED */
static void
abortforce(int signo)
{
	int save_errno = errno;

#define MSG	"Forced abort.  The connection will be closed.\n"
	(void) write(fileno(ttyout), MSG, strlen(MSG));
#undef MSG

	errno = save_errno;
	longjmp(forceabort, 1);
}

void
abort_remote(FILE *din)
{
	char buf[BUFSIZ];
	nfds_t nfds;
	int nfnd;
	struct pollfd pfd[2];
	sig_t oldintr;

	if (cout == NULL || setjmp(forceabort)) {
		if (cout)
			fclose(cout);
		warnx("Lost control connection for abort.");
		if (ptabflg)
			code = -1;
		lostpeer();
		return;
	}

	oldintr = signal(SIGINT, abortforce);

	/*
	 * send IAC in urgent mode instead of DM because 4.3BSD places oob mark
	 * after urgent byte rather than before as is protocol now
	 */
	snprintf(buf, sizeof buf, "%c%c%c", IAC, IP, IAC);
	if (send(fileno(cout), buf, 3, MSG_OOB) != 3)
		warn("abort");
	fprintf(cout, "%cABOR\r\n", DM);
	(void)fflush(cout);
	pfd[0].fd = fileno(cin);
	pfd[0].events = POLLIN;
	nfds = 1;
	if (din) {
		pfd[1].fd = fileno(din);
		pfd[1].events = POLLIN;
		nfds++;
	}
	if ((nfnd = poll(pfd, nfds, 10 * 1000)) <= 0) {
		if (nfnd < 0)
			warn("abort");
		if (ptabflg)
			code = -1;
		lostpeer();
	}
	if (din && (pfd[1].revents & POLLIN)) {
		while (read(fileno(din), buf, BUFSIZ) > 0)
			/* LOOP */;
	}
	if (getreply(0) == ERROR && code == 552) {
		/* 552 needed for nic style abort */
		(void)getreply(0);
	}
	(void)getreply(0);
	(void)signal(SIGINT, oldintr);
}
@


1.99
log
@Use connect(2) + a connect_wait() function instead of connect_sync(),
similar to the example in connect(2).  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.98 2016/08/18 16:23:06 millert Exp $	*/
d86 4
a89 8
union sockunion {
	struct sockinet {
		u_char si_len;
		u_char si_family;
		u_short si_port;
	} su_si;
	struct sockaddr_in  su_sin;
	struct sockaddr_in6 su_sin6;
a90 3
#define su_len		su_si.si_len
#define su_family	su_si.si_family
#define su_port		su_si.si_port
d92 1
a92 1
union sockunion myctladdr, hisctladdr, data_addr;
d255 1
a255 1
	if (getsockname(s, (struct sockaddr *)&myctladdr, &namelen) < 0) {
d260 1
a260 1
	if (hisctladdr.su_family == AF_INET) {
d1276 3
a1278 3
	if (myctladdr.su_family == AF_INET6
	 && (IN6_IS_ADDR_LINKLOCAL(&myctladdr.su_sin6.sin6_addr)
	  || IN6_IS_ADDR_SITELOCAL(&myctladdr.su_sin6.sin6_addr))) {
d1302 1
a1302 1
		data = socket(data_addr.su_family, SOCK_STREAM, 0);
d1320 1
a1320 1
		switch (data_addr.su_family) {
d1393 1
a1393 1
			if (data_addr.su_family != AF_INET) {
d1412 3
a1414 3
			data_addr.su_family = AF_INET;
			data_addr.su_len = sizeof(struct sockaddr_in);
			data_addr.su_sin.sin_addr.s_addr =
d1416 1
a1416 1
			data_addr.su_port = htons(pack2(port, 0));
d1423 1
a1423 1
			switch (data_addr.su_family) {
d1443 3
a1445 3
				data_addr.su_family = AF_INET;
				data_addr.su_len = sizeof(struct sockaddr_in);
				data_addr.su_sin.sin_addr.s_addr =
d1447 1
a1447 1
				data_addr.su_port = htons(pack2(port, 0));
d1471 2
a1472 2
				data_addr.su_family = AF_INET6;
				data_addr.su_len = sizeof(struct sockaddr_in6);
d1475 1
a1475 1
				p32 = (u_int32_t *)&data_addr.su_sin6.sin6_addr;
d1481 1
a1481 1
				data_addr.su_port = htons(pack2(port, 0));
d1508 1
a1508 1
			data_addr.su_port = htons(port[1]);
d1512 2
a1513 2
		for (error = connect(data, (struct sockaddr *)&data_addr,
		    data_addr.su_len); error != 0 && errno == EINTR;
d1527 1
a1527 1
		if (data_addr.su_family == AF_INET) {
d1539 1
a1539 1
		data_addr.su_port = 0;	/* let system pick one */
d1542 1
a1542 1
	data = socket(data_addr.su_family, SOCK_STREAM, 0);
d1555 1
a1555 1
	switch (data_addr.su_family) {
d1569 1
a1569 1
	if (bind(data, (struct sockaddr *)&data_addr, data_addr.su_len) < 0) {
d1580 1
a1580 1
	if (getsockname(data, (struct sockaddr *)&data_addr, &namelen) < 0) {
d1592 1
a1592 1
		union sockunion tmp;
d1595 1
a1595 1
		switch (tmp.su_family) {
d1603 6
a1608 6
			if (tmp.su_family == AF_INET6)
				tmp.su_sin6.sin6_scope_id = 0;
			af_tmp = (tmp.su_family == AF_INET) ? 1 : 2;
			if (getnameinfo((struct sockaddr *)&tmp,
			    tmp.su_len, hname, sizeof(hname),
			    pbuf, sizeof(pbuf), NI_NUMERICHOST | NI_NUMERICSERV)) {
d1632 1
a1632 1
		switch (data_addr.su_family) {
d1634 2
a1635 2
			a = (char *)&data_addr.su_sin.sin_addr;
			p = (char *)&data_addr.su_port;
d1641 2
a1642 2
			a = (char *)&data_addr.su_sin6.sin6_addr;
			p = (char *)&data_addr.su_port;
d1666 1
a1666 1
	if (data_addr.su_family == AF_INET) {
d1683 2
a1684 2
	union sockunion from;
	socklen_t fromlen = myctladdr.su_len;
d1690 1
a1690 1
	s = accept(data, (struct sockaddr *) &from, &fromlen);
d1698 1
a1698 1
	if (from.su_family == AF_INET) {
d1735 2
a1736 2
		union sockunion mctl;
		union sockunion hctl;
@


1.98
log
@Move connect_sync() to util.c and use it when connecting via http
too.  OK sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.97 2016/08/09 12:09:40 millert Exp $	*/
d222 4
a225 2
		error = connect_sync(s, res->ai_addr, res->ai_addrlen);
		if (error) {
d1519 5
a1523 2
		if (connect_sync(data, (struct sockaddr *)&data_addr,
			    data_addr.su_len) < 0) {
@


1.97
log
@When connect(2) is interrupted by a signal it continues asynchronously
and you need to do the same poll(2) dance as if the socket was
non-blocking.  Fixes a crash when the window is resized while
connecting.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.96 2016/03/16 15:41:11 krw Exp $	*/
a109 30

static int
connect_sync(int s, const struct sockaddr *name, socklen_t namelen)
{
	struct pollfd pfd[1];
	int error = 0;
	socklen_t len = sizeof(error);

	if (connect(s, name, namelen) < 0) {
		if (errno != EINTR)
			return -1;
	}

	/* An interrupted connect(2) continues asyncronously. */
	pfd[0].fd = s;
	pfd[0].events = POLLOUT;
	for (;;) {
		if (poll(pfd, 1, -1) == -1) {
			if (errno != EINTR)
				return -1;
			continue;
		}
		if (getsockopt(s, SOL_SOCKET, SO_ERROR, &error, &len) < 0)
			return -1;
		if (error != 0)
			errno = error;
		break;
	}
	return (error ? -1 : 0);
}
@


1.96
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.95 2015/12/05 22:28:40 krw Exp $	*/
d111 30
d252 1
a252 4
		while ((error = connect(s, res->ai_addr, res->ai_addrlen)) < 0
				&& errno == EINTR) {
			;
		}
d1547 1
a1547 1
		while (connect(data, (struct sockaddr *)&data_addr,
a1548 2
			if (errno == EINTR)
				continue;
@


1.95
log
@Let special/ftp compile again. 'ares' is only used inside #ifndef SMALL, so
declare it inside #ifdef SMALL.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.94 2015/12/05 22:20:44 krw Exp $	*/
d307 1
a307 1
	return ((char *)0);
@


1.94
log
@Send bad whitespace to the attic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.93 2015/12/05 22:14:04 krw Exp $	*/
d116 4
a119 1
	struct addrinfo hints, *res, *res0, *ares;
d1280 1
d1282 1
@


1.93
log
@Silence gcc whining about using 'serrno' uninitialized by initializing
it to 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.92 2015/09/27 05:25:01 guenther Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d184 1
a184 1
	
d283 1
a283 1
	if (getreply(0) > 2) { 	/* read startup message from server */
d395 1
a395 1
static void 
d424 1
a424 1
static void 
d434 1
a434 1
			} 
d1331 1
a1331 1
				/* 
d1658 1
a1658 1
		
d2020 1
a2020 1
 
@


1.92
log
@lint is dead: delete the trivial uses of /* VARARGS[0-9]+ */
(others require more care)
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.91 2015/02/09 08:24:20 tedu Exp $	*/
d749 1
d1059 1
@


1.91
log
@various defines always exist, so delete the ifdef test.
the socks support seems to be dead, since there are no other references.
also, redeclaring a standard function? that's a no-no.
custom compiles with gate-ftp servers don't need to be supported either.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.90 2015/01/30 04:45:45 tedu Exp $	*/
a321 1
/*VARARGS*/
@


1.90
log
@remove tenex transfer support. if you still have TOPS20 machines in
service, you'll need to stick with openbsd 5.6.
bonus: remove references to ebcdic.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.89 2015/01/16 06:40:08 deraadt Exp $	*/
a186 3
#if 0	/*old behavior*/
		if (res != res0)	/* not on the first address */
#else
a187 1
#endif
a264 1
#if defined(IPPROTO_IP) && defined(IP_TOS)
a269 1
#endif
a290 1
#ifdef SO_OOBINLINE
a299 1
#endif /* SO_OOBINLINE */
a802 6
#if 0	/* this violates RFC */
			if (c == '\r') {
				(void)putc('\0', dout);
				bytes++;
			}
#endif
a1527 1
#if defined(IPPROTO_IP) && defined(IP_TOS)
a1533 1
#endif
a1666 1
#if defined(IPPROTO_IP) && defined(IP_TOS)
a1672 1
#endif
a1698 1
#if defined(IPPROTO_IP) && defined(IP_TOS)
a1705 1
#endif
@


1.89
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.88 2014/10/24 02:01:20 lteo Exp $	*/
a709 1
		case TYPE_L:
a760 1
	case TYPE_L:
a1075 1
	case TYPE_L:
@


1.88
log
@Remove unnecessary include: netinet/in_systm.h is not needed by these
programs.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.87 2014/08/16 07:49:27 deraadt Exp $	*/
d115 1
a115 1
	static char hostnamebuf[MAXHOSTNAMELEN];
d1758 1
a1758 1
		char name[MAXHOSTNAMELEN];
d1773 2
a1774 2
		char mi[MAXPATHLEN];
		char mo[MAXPATHLEN];
d1999 1
a1999 1
	static char new[MAXPATHLEN];
@


1.87
log
@I found a number of interactive events which can cause signals, and go
down paths not previously marked as signal handled unsafe.  Try to clean
up a few of them especially regarding errno, mark others as unsafe, and
repair a few by avoiding stdio.  Glanced at by misc people in Slovenia,
but considered too risky before release..
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.86 2014/05/20 01:25:23 guenther Exp $	*/
a66 1
#include <netinet/in_systm.h>
@


1.86
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.85 2014/04/22 20:48:41 tedu Exp $	*/
d320 1
d323 1
a323 2
	putc('\n', ttyout);
	(void)fflush(ttyout);
d325 2
d580 1
a580 1

d584 5
a588 2
	fputs("\nsend aborted\nwaiting for remote to finish abort.\n", ttyout);
	(void)fflush(ttyout);
d2048 1
a2048 2
	fputs("Forced abort.  The connection will be closed.\n", ttyout);
	(void)fflush(ttyout);
d2050 3
a2052 4
	if (cout) {
		(void)fclose(cout);
	}
	cout = NULL;
d2054 1
d2068 2
@


1.85
log
@remove dead stores to error. from Fritjof Bornebusch
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.84 2013/12/20 13:44:51 jca Exp $	*/
d179 1
a179 1
			warnx("%s: %s", gai_strerror(error), srcaddr);
d784 1
a784 1
			warnx("local: %s: %s", local, strerror(serrno));
d787 1
a787 1
				warnx("netout: %s", strerror(serrno));
d825 1
a825 1
			warnx("local: %s: %s", local, strerror(serrno));
d828 1
a828 1
				warnx("netout: %s", strerror(serrno));
d1121 1
a1121 1
				warnx("netin: %s", strerror(serrno));
d1126 1
a1126 1
				warnx("local: %s: %s", local, strerror(serrno));
d1206 1
a1206 1
				warnx("netin: %s", strerror(serrno));
d1210 1
a1210 1
			warnx("local: %s: %s", local, strerror(serrno));
d1308 1
a1308 1
			warnx("%s: %s", gai_strerror(error), srcaddr);
@


1.84
log
@When writing a file, break out when we get a write(2) error, not
just EPIPE, else we'll just reattempt the write with non-sensical
values.  From Maxime Villard (max at m00nbsd dot net).
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.83 2013/11/13 20:41:14 deraadt Exp $	*/
a1410 1
				error = 1;
a1415 1
				error = 1;
a1423 1
				error = 1;
a1425 1
			error = 0;
a1435 1
				error = 1;
a1447 1
					error = 1;
a1456 1
				error = 0;
a1476 1
					error = 1;
a1481 1
					error = 1;
a1484 1
				error = 0;
d1499 2
a1500 1
				error = 1;
a1508 1
				error = 1;
a1514 1
				error = 1;
a1519 1
				error = 1;
@


1.83
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.82 2012/04/30 13:41:26 haesbaert Exp $	*/
d1093 2
a1094 1
				if (wr == -1 && errno == EPIPE)
d1096 1
@


1.82
log
@Add a -s flag to ftp(1) to let the user specify the source IP address
of the connection. This is useful for testing ftp(1) over VPN tunnels.

This -s flag is present in the other BSDs, including OS X.

All work was done by Lawrence Teo, thanks (-:.

ok myself mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.81 2010/09/03 03:49:37 lum Exp $	*/
d381 2
a382 2
void 
send_noop_char()
d396 2
a397 2
void
may_reset_noop_timeout()
d403 2
a404 2
void 
may_receive_noop_ack()
d432 2
a433 2
void 
may_send_noop_char()
d2050 1
a2050 1
void
@


1.81
log
@Make second parameter of poll() the correct type. Removes compile warning.

advice and ok martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.80 2010/07/02 22:01:10 deraadt Exp $	*/
d117 1
a117 1
	struct addrinfo hints, *res, *res0;
d166 19
d205 19
d259 6
d1287 1
d1294 18
d1321 7
@


1.80
log
@#ifndef SMALL a few more things to save space on the ramdisks
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.79 2009/06/06 23:14:44 martynas Exp $	*/
d1998 1
d2024 1
a2024 1
	nfnd = 1;
d2028 1
a2028 1
		nfnd++;
d2030 1
a2030 1
	if ((nfnd = poll(pfd, nfnd, 10 * 1000)) <= 0) {
@


1.79
log
@make it possible to abort transfers of broken ftp servers.  first
interrupt will do the standard abort procedure per rfc959.  second
interrupt will force the abort, and close the connection.
done after email from halex@@ couple of months ago.  liked by many
"I like this a lot" marco@@.  ok halex@@, millert@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.78 2009/04/27 23:20:48 martynas Exp $	*/
d1910 1
d1930 1
@


1.78
log
@in silent mode, shut up connect to address warning since it spams
install media if, e.g. ipv6 is not present
discussed with theo, sthen@@, millert@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.77 2009/04/27 22:51:51 martynas Exp $	*/
d1199 1
a1199 3

/* abort using RFC959 recommended IP,SYNC sequence */

d1975 17
d1998 1
d2000 1
a2000 1
	if (cout == NULL) {
d2008 2
d2043 1
@


1.77
log
@remove uploading and macros support from install media;  to save
some space
discussed with theo, todd@@, millert@@
tested and looked over by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.76 2009/04/27 21:37:13 deraadt Exp $	*/
d192 1
a192 1
			if (res->ai_next) {
@


1.76
log
@toast the rcsid strings which just get in the way
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.75 2009/04/26 21:26:03 martynas Exp $	*/
d527 1
d826 1
@


1.75
log
@figure out titles automatically by using remote file name.  remove
-T and just show titles by default for non-verbose transfers;
discussed with, ok theo, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.74 2009/04/25 12:22:19 martynas Exp $	*/
a60 4

#if !defined(lint) && !defined(SMALL)
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.74 2009/04/25 12:22:19 martynas Exp $";
#endif /* not lint and not SMALL */
@


1.74
log
@guard NOOP code (that tries to send remaining NOOP string) after
server closes connection during any get/put transfer.  it dereferences
cout, which will be NULL, oops

originally reported on misc@@.  pirofti@@ can't reproduce it again
since the server has been fixed

tested by simulating the very same failure
sthen@@ and pirofti@@ agree that my analysis is correct
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.73 2008/07/08 21:07:57 martynas Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.73 2008/07/08 21:07:57 martynas Exp $";
d711 1
a711 1
	progressmeter(-1);
d792 1
a792 1
	progressmeter(1);
d1027 1
a1027 1
	progressmeter(-1);
d1169 1
a1169 1
	progressmeter(1);
@


1.73
log
@- add support for recursive transfers (but not for floppies), e.g.
'mget -cr 4.*' would recursively fetch (-r), and resume the previous
transfers (-c) of 4.X release directories
uses local matching (fnmatch), but only for recursive transfers.
current behavior is not changed in any way.
- while here, ifndef SMALL debugging stuff, this saves some space,
for floppies
- some debugging code was enabled for non-debugging mode, checks
assume debug is set to zero, but it's not initially set
- all "Confirm with" prompts are forced, remove redundant argument
- fix usage: -C and -c are not available for SMALL

discussed a year ago w/ pyr@@
looks good to millert@@
previous version looked good to pyr@@
man page tweaks & ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.72 2008/06/25 21:15:19 martynas Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.72 2008/06/25 21:15:19 martynas Exp $";
d367 6
@


1.72
log
@in resume mode, pass -c to mget when {dir,file}hasglob, so that i'm
able to continue multiple transfers with -C;  ok millert@@
while here fix some comments (!SMALL vs. SMALL stuff), and add
missing
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.71 2008/06/25 18:07:00 martynas Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.71 2008/06/25 18:07:00 martynas Exp $";
d260 1
a260 1
	int on = 1;
d262 5
a266 4
	if (setsockopt(s, SOL_SOCKET, SO_OOBINLINE, (char *)&on, sizeof(on))
		< 0 && debug) {
			warn("setsockopt");
		}
d298 1
d312 1
d344 1
d347 1
d371 1
d374 1
d1255 1
d1260 1
d1282 1
d1288 1
d1527 1
d1532 1
d1569 1
d1575 1
@


1.71
log
@- fix -Wall (no behavior change, a || b && c = a || (b && c) anyway)
- use argv[0] for "Confirm with", as other confirm()s do
- fix confirm cases, pass force=1 for mdelete and mabort too, fixes
a bug when you end up deleting all files when you ^C, instead of
getting a confirmation
- add reput command, that will allow to continue transfer uploads
- add -c for mget and mput, that will allow to continue multiple
transfers
- fix a bug when you use restart command together with put.  the
progressmeter would start from zero, and eta would show fictional
time.  this actually allows reput/put -c to have correct progressmeter
too
- document everything
discussed with, suggestions, reminded to ifdef SMALL the code so
we're able to fit in floppies, and ok millert@@, and jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.70 2008/05/24 00:42:35 pyr Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.70 2008/05/24 00:42:35 pyr Exp $";
d152 1
a152 1
#endif
@


1.70
log
@Enclose an informational message in a verbose check.
From Alexander Hall <alexander@@beard.se>
ok henning@@, ``I suppose so'' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.69 2008/04/12 21:20:58 ray Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.69 2008/04/12 21:20:58 ray Exp $";
d451 1
a451 1
			    ((verbose > -1 && n == '5' && dig > 4)) &&
d453 1
a453 1
			     || !retry_connect))) {
a658 1
			restart_point = 0;
a665 1
			restart_point = 0;
a670 1
		restart_point = 0;
@


1.69
log
@Protect errno from being trashed by other functions.

okay okan.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.68 2008/03/10 22:56:43 espie Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.68 2008/03/10 22:56:43 espie Exp $";
d182 2
a183 1
			fprintf(ttyout, "Trying %s...\n", hbuf);
@


1.68
log
@turn on keepalive by default (one byte every 60 seconds)
okay beck@@, deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.67 2007/06/16 08:58:33 espie Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.67 2007/06/16 08:58:33 espie Exp $";
d544 1
a544 1
	int oprogress;
d707 1
a707 1
		errno = d = 0;
d723 2
d732 1
a732 1
			warn("local: %s", local);
d734 2
a735 2
			if (errno != EPIPE)
				warn("netout");
d764 2
d773 1
a773 1
			warn("local: %s", local);
d776 1
a776 1
				warn("netout");
d841 1
a841 1
	int c, d;
d897 1
a897 1
			char *dir = strrchr(local, '/');
d906 1
d1056 2
d1065 2
a1066 2
			if (errno != EPIPE)
				warn("netin");
d1071 1
a1071 1
				warn("local: %s", local);
d1085 3
a1087 1
				if ((ch = fgetc(fout)) == EOF)
d1089 1
d1095 4
a1098 1
				warn("local: %s", local);
d1135 2
d1150 2
a1151 2
			if (errno != EPIPE)
				warn("netin");
d1155 1
a1155 1
			warn("local: %s", local);
@


1.67
log
@implement a `keep-alive' option that sends bytes over an inactive
connection. The FTP protocol provides us with a NOOP operation that
is perfectly suitable for that, and so far servers are happy with it.
Sending the command slowly is an idea I borrowed from spamd.
No change for people not using the option, so it can't break normal ftp.

okay beck@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.66 2007/03/06 05:16:01 beck Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.66 2007/03/06 05:16:01 beck Exp $";
d328 1
a328 1
int keep_alive_timeout = 0;		/* 0 -> no timeout */
@


1.66
log
@Since our ftp client opportuniticly tries EPSV, then falls back to PASV for
older clients, dont' spew out "500 unimplimented" when a sever that
doesn't do EPSV doesn't like it, just notice, and fall back to PASV, then
complain if that fails.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.65 2006/06/23 20:35:25 steven Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.65 2006/06/23 20:35:25 steven Exp $";
d328 67
d701 1
d709 1
d740 1
d783 1
d1012 1
d1031 1
d1094 1
d1154 1
@


1.65
log
@free and sl_free already check against NULL, remove a few unneeded ifs.

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.64 2006/05/16 23:43:16 ray Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.64 2006/05/16 23:43:16 ray Exp $";
d1167 4
d1172 5
@


1.64
log
@Remove shadowing variables and properly use /* FALLTHROUGH */
comments.  No binary change.

Found by lint.

OK beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.63 2006/05/16 16:20:42 deraadt Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.63 2006/05/16 16:20:42 deraadt Exp $";
d926 1
a926 2
		if (buf)
			(void)free(buf);
@


1.63
log
@https URL support; rototilled by a few people including me; originally
from Rainer_Giedat@@genua.de
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.62 2006/04/25 05:45:20 tedu Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.62 2006/04/25 05:45:20 tedu Exp $";
d334 1
a334 1
	int c, n, line;
d343 1
a343 1
	for (line = 0 ;; line++) {
d425 1
a425 1
		if (line == 0) {
d1436 1
a1436 1
		int af;
d1450 1
a1450 1
			af = (tmp.su_family == AF_INET) ? 1 : 2;
d1457 1
a1457 1
				    af, hname, pbuf);
@


1.62
log
@two strtol calls that were begging to be converted to strtonum
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.61 2006/02/16 07:41:01 pvalchev Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: ftp.c,v 1.61 2006/02/16 07:41:01 pvalchev Exp $";
d149 4
@


1.61
log
@delete a few double declarations; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.60 2006/01/10 18:12:46 moritz Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.60 2006/01/10 18:12:46 moritz Exp $";
@


1.60
log
@Prevent close() from clobbering errno. ok otto@@ deraadt@@

From Ray Lai
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.59 2005/11/13 20:26:09 deraadt Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.59 2005/11/13 20:26:09 deraadt Exp $";
a105 2
union sockunion hisctladdr;
union sockunion data_addr;
a110 1
union sockunion myctladdr;
@


1.59
log
@fseeko() and lseek() have different return values.  cope with that correctly.  spotted by dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.58 2005/10/30 15:17:41 sturm Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.58 2005/10/30 15:17:41 sturm Exp $";
d203 1
d205 1
@


1.58
log
@restart_point is of type off_t, so use it with fseeko() and cast it
to long long for printing

this way we can reget partially downloaded files of more than 2GB on
i386

noticed by Thilo Hannemann <hannemann at physnet.uni-hamburg.de>
ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.57 2004/09/16 04:39:16 deraadt Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.57 2004/09/16 04:39:16 deraadt Exp $";
d574 1
a574 1
		int rc;
a575 1
		rc = -1;
d582 2
a583 1
			rc = lseek(fileno(fin), restart_point, SEEK_SET);
d586 1
a586 1
		if (rc < 0) {
@


1.57
log
@type corrections and other delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.56 2004/07/20 03:50:25 deraadt Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.56 2004/07/20 03:50:25 deraadt Exp $";
d579 1
a579 1
			rc = fseek(fin, (long) restart_point, SEEK_SET);
d594 1
a594 1
		if (command("REST %ld", (long) restart_point)
d880 1
a880 1
	    command("REST %ld", (long) restart_point) != CONTINUE)
@


1.56
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.55 2003/12/16 21:46:22 deraadt Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.55 2003/12/16 21:46:22 deraadt Exp $";
d122 1
a122 1
	int s, len, tos, error;
d127 1
d218 1
a218 1
	len = res->ai_addrlen;
d221 1
a221 1
	if (getsockname(s, (struct sockaddr *)&myctladdr, &len) < 0) {
d271 1
d273 1
a273 1
cmdabort(int notused)
d449 1
d451 1
a451 1
abortsend(int notused)
d743 1
d745 1
a745 1
abortrecv(int notused)
d954 1
a954 1
			size_t	wr;
d1137 1
a1137 1
	int result = ERROR, len, tmpno = 0;
d1143 1
d1421 2
a1422 2
	len = sizeof(data_addr);
	if (getsockname(data, (struct sockaddr *)&data_addr, &len) < 0) {
d1526 2
a1527 1
	int s, fromlen = myctladdr.su_len;
d1552 1
d1554 1
a1554 1
psummary(int notused)
d1563 1
d1565 1
a1565 1
psabort(int notused)
d1659 1
d1661 1
a1661 1
abortpt(int notused)
d1794 1
@


1.55
log
@for -DSMALL, do not include rcsid[]s
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.54 2003/08/11 21:23:58 millert Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.54 2003/08/11 21:23:58 millert Exp $";
d120 1
a120 3
hookup(host, port)
	char *host;
	char *port;
d271 1
a271 2
cmdabort(notused)
	int notused;
d326 1
a326 2
getreply(expecteof)
	int expecteof;
d448 1
a448 2
abortsend(notused)
	int notused;
d460 2
a461 3
sendrequest(cmd, local, remote, printnames)
	const char *cmd, *local, *remote;
	int printnames;
d741 1
a741 2
abortrecv(notused)
	int notused;
d753 2
a754 3
recvrequest(cmd, local, remote, lmode, printnames, ignorespecial)
	const char *cmd, * volatile local, *remote, *lmode;
	int printnames, ignorespecial;
d1130 1
a1130 1
initconn()
d1518 1
a1518 2
dataconn(lmode)
	const char *lmode;
d1547 1
a1547 2
psummary(notused)
	int notused;
d1557 1
a1557 2
psabort(notused)
	int notused;
d1565 1
a1565 2
pswitch(flag)
	int flag;
d1652 1
a1652 2
abortpt(notused)
	int notused;
d1665 1
a1665 2
proxtrans(cmd, local, remote)
	const char *cmd, *local, *remote;
d1786 1
a1786 3
reset(argc, argv)
	int argc;
	char *argv[];
d1805 1
a1805 2
gunique(local)
	const char *local;
d1850 1
a1850 2
abort_remote(din)
	FILE *din;
@


1.54
log
@The empty() function basically effects a poll, so replace it with
real poll().  Gets rid of another static select().  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.53 2003/06/03 02:56:08 millert Exp $	*/
d62 3
a64 7
#ifndef lint
#if 0
static char sccsid[] = "@@(#)ftp.c	8.6 (Berkeley) 10/27/94";
#else
static char rcsid[] = "$OpenBSD: ftp.c,v 1.53 2003/06/03 02:56:08 millert Exp $";
#endif
#endif /* not lint */
@


1.53
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.52 2003/04/05 17:19:47 deraadt Exp $	*/
d66 1
a66 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.52 2003/04/05 17:19:47 deraadt Exp $";
d85 2
a91 1
#include <stdarg.h>
a452 12
int
empty(mask, sec)
	fd_set *mask;
	int sec;
{
	struct timeval t;

	t.tv_sec = (long) sec;
	t.tv_usec = 0;
	return (select(32, mask, (fd_set *) 0, (fd_set *) 0, &t));
}

d1689 1
a1689 1
	fd_set mask;
d1783 4
a1786 4
		FD_ZERO(&mask);
		FD_SET(fileno(cin), &mask);
		if ((nfnd = empty(&mask, 10)) <= 0) {
			if (nfnd < 0) {
a1787 1
			}
d1808 1
a1808 1
	fd_set mask;
d1811 2
a1812 1
	FD_ZERO(&mask);
d1814 1
a1814 2
		FD_SET(fileno(cin), &mask);
		if ((nfnd = empty(&mask, 0)) < 0) {
d1818 1
a1818 2
		}
		else if (nfnd) {
d1876 1
a1876 1
	fd_set mask;
d1895 3
a1897 2
	FD_ZERO(&mask);
	FD_SET(fileno(cin), &mask);
d1899 3
a1901 1
		FD_SET(fileno(din), &mask);
d1903 2
a1904 2
	if ((nfnd = empty(&mask, 10)) <= 0) {
		if (nfnd < 0) {
a1905 1
		}
d1910 1
a1910 1
	if (din && FD_ISSET(fileno(din), &mask)) {
@


1.52
log
@string fixes; ok miod henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.51 2003/03/11 04:01:29 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d66 1
a66 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.51 2003/03/11 04:01:29 itojun Exp $";
@


1.51
log
@getnameinfo buffer has to be NI_MAXHOST
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.50 2003/03/11 04:01:11 itojun Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.50 2003/03/11 04:01:11 itojun Exp $";
d1666 1
a1666 1
	(void)strcpy(ntin, op->nti);
d1668 1
a1668 1
	(void)strcpy(ntout, op->nto);
d1672 1
a1672 1
	(void)strcpy(mapin, op->mi);
d1674 1
a1674 1
	(void)strcpy(mapout, op->mo);
d1859 1
a1859 1
	(void)strcpy(new, local);
@


1.50
log
@check error on getnameinfo failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.49 2002/07/04 10:08:00 jakob Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.49 2002/07/04 10:08:00 jakob Exp $";
d134 1
a134 1
	char hbuf[MAXHOSTNAMELEN];
@


1.49
log
@use tcp high portrange for active data connections. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.48 2002/06/09 02:36:03 itojun Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.48 2002/06/09 02:36:03 itojun Exp $";
d186 3
a188 2
			getnameinfo(res->ai_addr, res->ai_addrlen,
				hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
d203 5
a207 3
				getnameinfo(res->ai_addr, res->ai_addrlen,
					hbuf, sizeof(hbuf), NULL, 0,
					NI_NUMERICHOST);
@


1.48
log
@strlcpy fix, PR 2727
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.47 2002/06/09 00:40:29 itojun Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.47 2002/06/09 00:40:29 itojun Exp $";
d1418 14
@


1.47
log
@do not present scopeid on wire format, as it is local to node
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.46 2002/06/01 20:21:49 deraadt Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.46 2002/06/01 20:21:49 deraadt Exp $";
d434 1
a434 1
			(void)strlcpy(reply_string, current_line, len + 1);
@


1.46
log
@more snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.45 2002/05/30 06:51:46 deraadt Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.45 2002/05/30 06:51:46 deraadt Exp $";
d1437 1
a1437 1
		char hname[INET6_ADDRSTRLEN];
d1439 1
d1441 2
a1442 1
		switch (data_addr.su_family) {
d1450 6
a1455 4
			af = (data_addr.su_family == AF_INET) ? 1 : 2;
			if (getnameinfo((struct sockaddr *)&data_addr,
					data_addr.su_len, hname, sizeof(hname),
					NULL, 0, NI_NUMERICHOST)) {
d1458 2
a1459 2
				result = command("EPRT |%d|%s|%d|",
					af, hname, ntohs(data_addr.su_port));
@


1.45
log
@-4 and -6 options; kanai@@big.or.jp; itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.44 2002/04/25 10:58:05 itojun Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.44 2002/04/25 10:58:05 itojun Exp $";
d1886 1
a1886 1
	sprintf(buf, "%c%c%c", IAC, IP, IAC);
@


1.44
log
@avoid buffer overrun on PASV from malicious server.
http://online.securityfocus.com/archive/1/269356/2002-04-22/2002-04-28/0
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.43 2002/02/19 19:39:38 millert Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.43 2002/02/19 19:39:38 millert Exp $";
d142 1
a142 1
	hints.ai_family = AF_UNSPEC;
@


1.43
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.42 2002/02/16 21:27:46 millert Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.42 2002/02/16 21:27:46 millert Exp $";
d403 4
a406 3
				if (c != '\r' && c != ')')
					*pt++ = c;
				else {
@


1.43.2.1
log
@Pull in patch from current:
Fix (itojun):
avoid buffer overrun on PASV from malicious server.
http://online.securityfocus.com/archive/1/269356/2002-04-22/2002-04-28/0
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.43 2002/02/19 19:39:38 millert Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.43 2002/02/19 19:39:38 millert Exp $";
d403 3
a405 4
				if (c != '\r' && c != ')') {
					if (pt < &pasv[sizeof(pasv) - 1])
						*pt++ = c;
				} else {
@


1.42
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.41 2001/06/26 23:44:00 lebel Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.41 2001/06/26 23:44:00 lebel Exp $";
a93 1
#ifdef __STDC__
a94 3
#else
#include <varargs.h>
#endif
a290 1
#ifdef __STDC__
a291 4
#else
command(va_alist)
	va_dcl
#endif
a295 3
#ifndef __STDC__
	const char *fmt;
#endif
a299 1
#ifdef __STDC__
a300 4
#else
		va_start(ap);
		fmt = va_arg(ap, const char *);
#endif
a316 1
#ifdef __STDC__
a317 4
#else
	va_start(ap);
	fmt = va_arg(ap, char *);
#endif
@


1.41
log
@use strlcpy vs strncpy+a[len-1]='\0'.  millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.40 2001/06/23 22:48:44 millert Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.40 2001/06/23 22:48:44 millert Exp $";
d509 1
a509 1
	int (* volatile closefunc) __P((FILE *));
d802 1
a802 1
	int (* volatile closefunc) __P((FILE *));
@


1.41.2.1
log
@MFC, requested by millert, diff by itojun:
avoid buffer overrun on PASV from malicious server.
http://online.securityfocus.com/archive/1/269356/2002-04-22/2002-04-28/0
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.41 2001/06/26 23:44:00 lebel Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.41 2001/06/26 23:44:00 lebel Exp $";
d425 3
a427 4
				if (c != '\r' && c != ')') {
					if (pt < &pasv[sizeof(pasv) - 1])
						*pt++ = c;
				} else {
@


1.40
log
@remove evil #ifdef __GNUC__ garbage to avoid longjmp clobbering and use volatile instead
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.39 2000/10/18 06:53:24 itojun Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.39 2000/10/18 06:53:24 itojun Exp $";
d177 1
a177 1
		strncpy(hostnamebuf, res0->ai_canonname, sizeof(hostnamebuf));
d179 1
a179 2
		strncpy(hostnamebuf, host, sizeof(hostnamebuf));
	hostnamebuf[sizeof(hostnamebuf) - 1] = '\0';
d455 1
a455 2
			(void)strncpy(reply_string, current_line, len);
			reply_string[len] = '\0';
d1639 1
a1639 2
		(void)strncpy(ip->name, hostname, sizeof(ip->name) - 1);
		ip->name[sizeof(ip->name) - 1] = '\0';
d1665 1
a1665 2
	(void)strncpy(ip->nti, ntin, sizeof(ip->nti) - 1);
	(ip->nti)[sizeof(ip->nti) - 1] = '\0';
d1667 1
a1667 2
	(void)strncpy(ip->nto, ntout, sizeof(ip->nto) - 1);
	(ip->nto)[sizeof(ip->nto) - 1] = '\0';
d1671 1
a1671 2
	(void)strncpy(ip->mi, mapin, sizeof(ip->mi) - 1);
	(ip->mi)[sizeof(ip->mi) - 1] = '\0';
d1673 1
a1673 2
	(void)strncpy(ip->mo, mapout, sizeof(ip->mo) - 1);
	(ip->mo)[sizeof(ip->mo) - 1] = '\0';
@


1.39
log
@emit more easier-to-understand error message on port name error.  from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.38 2000/06/30 16:00:14 millert Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.38 2000/06/30 16:00:14 millert Exp $";
d510 3
a512 3
	FILE *fin, *dout;
	int (*closefunc) __P((FILE *));
	sig_t oldinti, oldintr, oldintp;
d514 2
a515 1
	char *lmode, buf[BUFSIZ], *bufp;
a517 10
#ifdef __GNUC__				/* XXX: to shut up gcc warnings */
	(void)&fin;
	(void)&dout;
	(void)&closefunc;
	(void)&oldinti;
	(void)&oldintr;
	(void)&oldintp;
	(void)&lmode;
#endif

d800 1
a800 1
	const char *cmd, *local, *remote, *lmode;
d803 3
a805 3
	FILE *fout, *din;
	int (*closefunc) __P((FILE *));
	sig_t oldinti, oldintr, oldintp;
a815 10
#ifdef __GNUC__				/* XXX: to shut up gcc warnings */
	(void)&local;
	(void)&fout;
	(void)&din;
	(void)&closefunc;
	(void)&oldinti;
	(void)&oldintr;
	(void)&oldintp;
#endif

d1707 1
a1707 1
	sig_t oldintr;
d1710 1
a1710 1
	char *cmd2;
a1711 5

#ifdef __GNUC__				/* XXX: to shut up gcc warnings */
	(void)&oldintr;
	(void)&cmd2;
#endif
@


1.39.4.1
log
@MFC, requested by millert, diff by itojun:
avoid buffer overrun on PASV from malicious server.
http://online.securityfocus.com/archive/1/269356/2002-04-22/2002-04-28/0
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.39 2000/10/18 06:53:24 itojun Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.39 2000/10/18 06:53:24 itojun Exp $";
d426 3
a428 4
				if (c != '\r' && c != ')') {
					if (pt < &pasv[sizeof(pasv) - 1])
						*pt++ = c;
				} else {
@


1.38
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.37 2000/06/27 00:19:16 fgsch Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.37 2000/06/27 00:19:16 fgsch Exp $";
d168 4
a171 1
		warn("%s", gai_strerror(error));
@


1.37
log
@initialize result. this fixes the recent problem that makes ftp coredump
if epsv4 is disabled. problem reported by price@@netdoor.com on misc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.36 2000/06/21 19:22:54 itojun Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.36 2000/06/21 19:22:54 itojun Exp $";
d168 1
a168 1
		warn(gai_strerror(error));
d219 1
a219 1
		warn(cause);
d1279 2
@


1.36
log
@add epsv4 command, which turns off epsv on ipv4 (off by dfeault)
automagicaslly disable epsv on ipv4, if epsv fails for single connection.
merge from netbsd-current.

req from fgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.35 2000/05/03 19:50:41 deraadt Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.35 2000/05/03 19:50:41 deraadt Exp $";
d1196 1
a1196 1
	int result, len, tmpno = 0;
@


1.35
log
@if no /etc/services file, use defaults. found by millert, fixed by itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.34 1999/12/08 12:57:06 itojun Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.34 1999/12/08 12:57:06 itojun Exp $";
d141 2
d1222 4
a1225 3
			result = command(pasvcmd = "EPSV");
			if (code / 10 == 22 && code != 229) {
				fputs(
d1227 11
a1237 2
					ttyout);
				result = COMPLETE + 1;
d1479 5
d1493 8
@


1.35.2.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.38 2000/06/30 16:00:14 millert Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.35 2000/05/03 19:50:41 deraadt Exp $";
d166 1
a166 1
		warn("%s", gai_strerror(error));
d217 1
a217 1
		warn("%s", cause);
a1266 2
		if (!pasvcmd)
			goto bad;
@


1.34
log
@ftp(1) from KAME, should be good for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.33 1998/12/13 21:01:29 millert Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.33 1998/12/13 21:01:29 millert Exp $";
d148 17
@


1.33
log
@Fall back from passive to active if connect() fails.  This can happen if the remote server has an ip filter in place (live cvs does).
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.32 1998/09/19 23:00:50 deraadt Exp $	*/
d5 29
d70 1
a70 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.32 1998/09/19 23:00:50 deraadt Exp $";
d102 17
a118 2
struct	sockaddr_in hisctladdr;
struct	sockaddr_in data_addr;
d124 1
a124 1
struct	sockaddr_in myctladdr;
d132 2
a133 2
	const char *host;
	in_port_t port;
d135 1
a135 2
	struct hostent *hp = NULL;
	int s, len, tos;
d137 13
a149 23

	memset((void *)&hisctladdr, 0, sizeof(hisctladdr));
	if (inet_aton(host, &hisctladdr.sin_addr) != 0) {
		hisctladdr.sin_family = AF_INET;
		(void)strncpy(hostnamebuf, host, sizeof(hostnamebuf) - 1);
		hostnamebuf[sizeof(hostnamebuf) - 1] = '\0';
	} else {
		hp = gethostbyname(host);
		if (hp == NULL) {
			warnx("%s: %s", host, hstrerror(h_errno));
			code = -1;
			return ((char *) 0);
		}
		hisctladdr.sin_family = hp->h_addrtype;
		memcpy(&hisctladdr.sin_addr, hp->h_addr_list[0],
		    (size_t)hp->h_length);
		(void)strncpy(hostnamebuf, hp->h_name, sizeof(hostnamebuf) - 1);
		hostnamebuf[sizeof(hostnamebuf) - 1] = '\0';
	}
	hostname = hostnamebuf;
	s = socket(hisctladdr.sin_family, SOCK_STREAM, 0);
	if (s < 0) {
		warn("socket");
d153 23
a175 4
	hisctladdr.sin_port = port;
	while (connect(s, (struct sockaddr *)&hisctladdr,
			sizeof(hisctladdr)) < 0) {
		if (errno == EINTR)
d177 12
a188 18
		if (hp && hp->h_addr_list[1]) {
			int oerrno = errno;
			char *ia;

			ia = inet_ntoa(hisctladdr.sin_addr);
			errno = oerrno;
			warn("connect to address %s", ia);
			hp->h_addr_list++;
			memcpy(&hisctladdr.sin_addr, hp->h_addr_list[0],
			    (size_t)hp->h_length);
			fprintf(ttyout, "Trying %s...\n",
			    inet_ntoa(hisctladdr.sin_addr));
			(void)close(s);
			s = socket(hisctladdr.sin_family, SOCK_STREAM, 0);
			if (s < 0) {
				warn("socket");
				code = -1;
				return (0);
d190 3
d195 6
a200 1
		warn("connect");
d202 2
a203 1
		goto bad;
d205 4
a208 1
	len = sizeof(myctladdr);
d214 6
a219 4
#ifdef IP_TOS
	tos = IPTOS_LOWDELAY;
	if (setsockopt(s, IPPROTO_IP, IP_TOS, (char *)&tos, sizeof(int)) < 0)
		warn("setsockopt TOS (ignored)");
d397 1
a397 1
			if (!pflag && code == 227)
d399 2
d411 2
d1179 10
a1188 2
	int a0, a1, a2, a3, p0, p1;

d1191 2
a1192 1
		data = socket(AF_INET, SOCK_STREAM, 0);
d1201 28
a1228 1
		if (command("PASV") != COMPLETE) {
d1240 6
d1247 2
a1248 5
		 * What we've got at this point is a string of comma
		 * separated one-byte unsigned integer values.
		 * The first four are the an IP address. The fifth is
		 * the MSB of the port number, the sixth is the LSB.
		 * From that we'll prepare a sockaddr_in.
d1250 55
d1306 20
a1325 3
		if (sscanf(pasv, "%d,%d,%d,%d,%d,%d",
			   &a0, &a1, &a2, &a3, &p0, &p1) != 6) {
			fputs(
d1327 53
a1380 12
		}

		memset(&data_addr, 0, sizeof(data_addr));
		data_addr.sin_family = AF_INET;
		a = (char *)&data_addr.sin_addr.s_addr;
		a[0] = a0 & 0xff;
		a[1] = a1 & 0xff;
		a[2] = a2 & 0xff;
		a[3] = a3 & 0xff;
		p = (char *)&data_addr.sin_port;
		p[0] = p0 & 0xff;
		p[1] = p1 & 0xff;
d1383 1
a1383 1
			    sizeof(data_addr)) < 0) {
d1396 7
a1402 5
#ifdef IP_TOS
		on = IPTOS_THROUGHPUT;
		if (setsockopt(data, IPPROTO_IP, IP_TOS, (char *)&on,
			       sizeof(int)) < 0)
			warn("setsockopt TOS (ignored)");
d1410 1
a1410 1
		data_addr.sin_port = 0;	/* let system pick one */
d1413 1
a1413 1
	data = socket(AF_INET, SOCK_STREAM, 0);
d1426 1
a1426 1
	if (bind(data, (struct sockaddr *)&data_addr, sizeof(data_addr)) < 0) {
d1441 3
d1445 48
a1492 7
		a = (char *)&data_addr.sin_addr;
		p = (char *)&data_addr.sin_port;
#define	UC(b)	(((int)b)&0xff)
		result =
		    command("PORT %d,%d,%d,%d,%d,%d",
		      UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]),
		      UC(p[0]), UC(p[1]));
d1502 7
a1508 4
#ifdef IP_TOS
	on = IPTOS_THROUGHPUT;
	if (setsockopt(data, IPPROTO_IP, IP_TOS, (char *)&on, sizeof(int)) < 0)
		warn("setsockopt TOS (ignored)");
d1522 2
a1523 4
	struct sockaddr_in from;
	int s, fromlen, tos;

	fromlen = sizeof(from);
d1536 8
a1543 4
#ifdef IP_TOS
	tos = IPTOS_THROUGHPUT;
	if (setsockopt(s, IPPROTO_IP, IP_TOS, (char *)&tos, sizeof(int)) < 0)
		warn("setsockopt TOS (ignored)");
d1576 2
a1577 2
		struct sockaddr_in mctl;
		struct sockaddr_in hctl;
@


1.32
log
@write() can do short-writes -- deal; based on rahnds@@ code
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.31 1998/09/19 20:47:16 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.31 1998/09/19 20:47:16 millert Exp $";
d1170 7
@


1.31
log
@Make -m flag turn on progress meter in all situations
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.30 1998/09/19 20:02:23 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.30 1998/09/19 20:02:23 millert Exp $";
d930 12
a941 1
			if ((d = write(fileno(fout), buf, (size_t)c)) != c)
@


1.30
log
@Don't turn of progress meter when output file is stdout.  The meter will go to stderr in this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.29 1998/07/07 17:26:41 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.29 1998/07/07 17:26:41 art Exp $";
d486 2
a487 1
		progress = 0;
d499 2
a500 1
		progress = 0;
d884 2
a885 1
		progress = 0;
d910 2
a911 1
		progress = 0;
@


1.29
log
@fd_set is not a struct
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.28 1998/06/08 16:55:57 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.28 1998/06/08 16:55:57 millert Exp $";
a873 1
		progress = 0;
@


1.28
log
@Fix some problems noted by lukem@@netbsd.org
 o getopt string is wrong in main(); (missing : after P)
 o use of vprintf(...) instead of vfprintf(ttyout,...) in ftp.c::command()
 o missing \n in fputs in cmds.c::status()
 o should use strtol() instead of atol()
 o sometimes use 'NULL' instead of 'NUL' (in comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.27 1998/05/13 10:42:35 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.27 1998/05/13 10:42:35 deraadt Exp $";
d392 1
a392 1
	struct fd_set *mask;
d399 1
a399 1
	return (select(32, mask, (struct fd_set *) 0, (struct fd_set *) 0, &t));
d1395 1
a1395 1
	struct fd_set mask;
d1520 1
a1520 1
	struct fd_set mask;
d1589 1
a1589 1
	struct fd_set mask;
@


1.27
log
@handle EINTR
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.26 1998/05/13 08:59:07 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.26 1998/05/13 08:59:07 deraadt Exp $";
d242 1
a242 1
			vprintf(fmt, ap);
@


1.26
log
@make signal handlers save/restore errno
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.25 1998/02/10 02:13:10 weingart Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.25 1998/02/10 02:13:10 weingart Exp $";
d123 2
d135 2
a136 1
			fprintf(ttyout, "Trying %s...\n", inet_ntoa(hisctladdr.sin_addr));
d1152 1
a1152 1
		if (connect(data, (struct sockaddr *)&data_addr,
d1154 2
@


1.25
log
@Fix buffer overflows in quote1(), clear line buffer
before use.  Hopefully, this is the last of the
PR# 406 stuff that this will need.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.24 1997/12/17 16:03:03 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.24 1997/12/17 16:03:03 millert Exp $";
d1259 1
d1263 1
@


1.24
log
@By default, use passive mode and fall back to active as needed.
The user can specify active only with the -A flag, or use the
new FTPMODE envariable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.23 1997/09/05 00:02:29 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.23 1997/09/05 00:02:29 millert Exp $";
d282 1
@


1.23
log
@getc() -> fgetc() for easy socksification.  imp@@openbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.22 1997/09/04 04:37:16 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.22 1997/09/04 04:37:16 millert Exp $";
d1099 1
d1111 7
@


1.22
log
@Updtaes from NetBSD (lukem)
    bugs fixed:
      * don't interpret '-' or '|' when a local filename is determined from
        the remote name (i.e, in mget, and in get with only one argument).
        This is implemented using an extra argument to recvrequest().
        Fixes a major security hole.
      * clean up memory leak when using globulize()
      * clean up a couple of comments
      * fix wording in TNF copyright

    features added:
      * support for TIS fwtk gate-ftp servers:
        * read defaults from $FTPSERVER && $FTPSERVERPORT
        * start in gate-ftp mode if invoked as 'gate-ftp'
        * toggle or set with 'gate [host [port]]'

Other changes:
    * use symbolic flags in access(2)
    * Use USHRT_MAX, not 0xffff
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.21 1997/08/06 17:35:41 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.21 1997/08/06 17:35:41 mickey Exp $";
d286 1
a286 1
		while ((c = getc(cin)) != '\n') {
d288 1
a288 1
				switch (c = getc(cin)) {
d291 1
a291 1
					c = getc(cin);
d297 1
a297 1
					c = getc(cin);
d626 1
a626 1
		while ((c = getc(fin)) != EOF) {
d961 1
a961 1
				if ((ch = getc(fout)) == EOF)
d976 1
a976 1
		while ((c = getc(din)) != EOF) {
d987 1
a987 1
				if ((c = getc(din)) != '\n' || tcrflag) {
@


1.21
log
@proper msgs display w/ -r
@
text
@d1 2
a2 2
/*	$OpenBSD: ftp.c,v 1.20 1997/07/25 21:56:21 millert Exp $	*/
/*	$NetBSD: ftp.c,v 1.26 1997/07/20 09:45:53 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.20 1997/07/25 21:56:21 millert Exp $";
d716 1
a716 1
recvrequest(cmd, local, remote, lmode, printnames)
d718 1
a718 1
	int printnames;
d755 1
a755 1
		if (local && *local != '-')
d787 2
a788 2
	if (strcmp(local, "-") && *local != '|') {
		if (access(local, 2) < 0) {
d800 1
a800 1
			d = access(dir == local ? "/" : dir ? local : ".", 2);
d868 1
a868 1
	if (strcmp(local, "-") == 0) {
d872 1
a872 1
	} else if (*local == '|') {
d1005 1
a1005 1
			printf(
d1007 2
a1008 1
			fputs("File may not have transferred correctly.\n", ttyout);
d1047 1
a1047 1
					printf(
d1532 1
a1532 1
	d = access(cp == local ? "/" : cp ? local : ".", 2);
d1553 1
a1553 1
		if ((d = access(new, 0)) < 0)
@


1.20
log
@Updates from NetBSD (lukem) include -Wall cleanup.
More -W* cleanup and in_port_t usage by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.19 1997/06/17 20:40:40 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.19 1997/06/17 20:40:40 kstailey Exp $";
d323 3
a325 2
			    (verbose > -1 && n == '5' && dig > 4)) &&
			    (n < '5' || !retry_connect)) {
@


1.19
log
@(foo *)NULL -> NULL
@
text
@d1 2
a2 2
/*	$OpenBSD: ftp.c,v 1.18 1997/04/23 20:33:13 deraadt Exp $	*/
/*	$NetBSD: ftp.c,v 1.25 1997/04/14 09:09:22 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.18 1997/04/23 20:33:13 deraadt Exp $";
d89 1
a89 1
	int port;
d91 1
a91 1
	struct hostent *hp = 0;
d108 2
a109 1
		memcpy(&hisctladdr.sin_addr, hp->h_addr_list[0], hp->h_length);
d132 1
a132 1
			    hp->h_length);
d419 1
a419 1
	FILE *fin, *dout = 0;
d422 1
a422 1
	off_t hashbytes;
d426 10
d438 1
d598 2
a599 1
				if ((d = write(fileno(dout), bufp, c)) <= 0)
d719 1
a719 1
	FILE *fout, *din = 0;
d722 3
a724 2
	int c, d, is_retr, tcrflag, bare_lfs = 0;
	static int bufsize;
d726 1
a726 1
	off_t hashbytes;
d732 13
d748 1
d810 1
a810 1
			    chmod(local, 0600) < 0) {
d922 1
a922 1
			if ((d = write(fileno(fout), buf, c)) != c)
d1374 2
a1375 1
	int secndflag = 0, prox_type, nfnd;
d1379 7
@


1.18
log
@allow "ftp -aV ftp://host/foo.tar.gz | tar xvfpz -" to work
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.17 1997/04/16 05:02:54 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.17 1997/04/16 05:02:54 millert Exp $";
d1413 1
a1413 1
				abort_remote((FILE *) NULL);
d1422 1
a1422 1
		abort_remote((FILE *) NULL);
d1428 1
a1428 1
				abort_remote((FILE *) NULL);
d1437 1
a1437 1
		abort_remote((FILE *) NULL);
@


1.17
log
@Sync with NetBSD (lukem):
 * differentiate between being connected, and being logged in
 * cleanup some text messages
 * support username & password ftp URLs (ftp://user:pass@@host/) in non-proxy
   situations; assume proxy supports it for proxy situations.
 * cd to / before performing any autofetch transfers
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.16 1997/03/21 20:59:29 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.16 1997/03/21 20:59:29 millert Exp $";
d132 1
a132 1
			printf("Trying %s...\n", inet_ntoa(hisctladdr.sin_addr));
d169 1
a169 1
		printf("Connected to %s.\n", hostname);
d201 2
a202 2
	putchar('\n');
	(void)fflush(stdout);
d226 1
a226 1
		fputs("---> ", stdout);
d234 1
a234 1
			fputs("PASS XXXX", stdout);
d236 1
a236 1
			fputs("ACCT XXXX", stdout);
d240 2
a241 2
		putchar('\n');
		(void)fflush(stdout);
d314 3
a316 3
					puts(
"421 Service not available, remote server has closed connection.");
					(void)fflush(stdout);
d326 2
a327 2
					printf("%s:", hostname);
				(void)putchar(c);
d355 2
a356 2
			(void)putchar(c);
			(void)fflush (stdout);
d406 2
a407 2
	puts("\nsend aborted\nwaiting for remote to finish abort.");
	(void)fflush(stdout);
d432 1
a432 1
			printf("local: %s ", local);
d434 1
a434 1
			printf("remote: %s\n", remote);
d495 1
a495 1
			printf("%s: not a plain file.\n", local);
d590 1
a590 1
					(void)putchar('#');
d593 1
a593 1
				(void)fflush(stdout);
d598 3
a600 3
				(void)putchar('#');
			(void)putchar('\n');
			(void)fflush(stdout);
d616 2
a617 2
					(void)putchar('#');
					(void)fflush(stdout);
d636 3
a638 3
				(void)putchar('#');
			(void)putchar('\n');
			(void)fflush(stdout);
d696 2
a697 2
	puts("\nreceive aborted\nwaiting for remote to finish abort.");
	(void)fflush(stdout);
d727 1
a727 1
			printf("local: %s ", local);
d729 1
a729 1
			printf("remote: %s\n", remote);
d899 1
a899 1
					(void)putchar('#');
d902 1
a902 1
				(void)fflush(stdout);
d907 3
a909 3
				(void)putchar('#');
			(void)putchar('\n');
			(void)fflush(stdout);
d953 2
a954 2
					(void)putchar('#');
					(void)fflush(stdout);
d978 1
a978 1
			puts("File may not have transferred correctly.");
d982 3
a984 3
				(void)putchar('#');
			(void)putchar('\n');
			(void)fflush(stdout);
d1080 1
a1080 1
			puts("Passive mode refused.");
d1094 2
a1095 2
			puts(
"Passive mode address scan failure. Shouldn't happen!");
d1333 2
a1334 2
	putchar('\n');
	(void)fflush(stdout);
d1363 2
a1364 1
		puts("proxy server does not support third party transfers.");
d1369 1
a1369 1
		puts("No primary connection.");
d1400 1
a1400 1
	printf("local: %s remote: %s\n", local, remote);
d1506 1
a1506 1
			puts("runique: can't find unique file name.");
@


1.16
log
@Add in recent NetBSD changes we didn't already have:
    Always compile complete.c but ifdef out the bits if -DSMALL (christos)
    reset interactive mode correctly in auto_fetch() mget mode (lukem)
@
text
@d1 2
a2 2
/*	$OpenBSD: ftp.c,v 1.15 1997/03/14 23:25:46 millert Exp $	*/
/*	$NetBSD: ftp.c,v 1.24 1997/03/16 14:24:19 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.15 1997/03/14 23:25:46 millert Exp $";
a59 1
#include <pwd.h>
a192 96
}

int
login(host)
	const char *host;
{
	char tmp[80];
	char *user, *pass, *acct;
	char anonpass[MAXLOGNAME + 1 + MAXHOSTNAMELEN];	/* "user@@hostname" */
	char hostname[MAXHOSTNAMELEN];
	int n, aflag = 0;

	user = pass = acct = NULL;
	if (ruserpass(host, &user, &pass, &acct) < 0) {
		code = -1;
		return (0);
	}

	/*
	 * Set up arguments for an anonymous FTP session, if necessary.
	 */
	if ((user == NULL || pass == NULL) && anonftp) {
		memset(anonpass, 0, sizeof(anonpass));
		memset(hostname, 0, sizeof(hostname));

		/*
		 * Set up anonymous login password.
		 */
		user = getlogin();
		gethostname(hostname, MAXHOSTNAMELEN);
#ifndef DONT_CHEAT_ANONPASS
		/*
		 * Every anonymous FTP server I've encountered
		 * will accept the string "username@@", and will
		 * append the hostname itself.  We do this by default
		 * since many servers are picky about not having
		 * a FQDN in the anonymous password. - thorpej@@netbsd.org
		 */
		snprintf(anonpass, sizeof(anonpass) - 1, "%s@@",
		    user);
#else
		snprintf(anonpass, sizeof(anonpass) - 1, "%s@@%s",
		    user, hp->h_name);
#endif
		pass = anonpass;
		user = "anonymous";
	}

	while (user == NULL) {
		char *myname = getlogin();

		if (myname == NULL) {
			struct passwd *pp = getpwuid(getuid());

			if (pp != NULL)
				myname = pp->pw_name;
		}
		if (myname)
			printf("Name (%s:%s): ", host, myname);
		else
			printf("Name (%s): ", host);
		(void)fgets(tmp, sizeof(tmp) - 1, stdin);
		tmp[strlen(tmp) - 1] = '\0';
		if (*tmp == '\0')
			user = myname;
		else
			user = tmp;
	}
	n = command("USER %s", user);
	if (n == CONTINUE) {
		if (pass == NULL)
			pass = getpass("Password:");
		n = command("PASS %s", pass);
	}
	if (n == CONTINUE) {
		aflag++;
		acct = getpass("Account:");
		n = command("ACCT %s", acct);
	}
	if (n != COMPLETE) {
		warnx("Login failed.");
		return (0);
	}
	if (!aflag && acct != NULL)
		(void)command("ACCT %s", acct);
	if (proxy)
		return (1);
	for (n = 0; n < macnum; ++n) {
		if (!strcmp("init", macros[n].mac_name)) {
			(void)strcpy(line, "$init");
			makeargv();
			domacro(margc, margv);
			break;
		}
	}
	return (1);
@


1.15
log
@Add missing line, doh!
@
text
@d1 2
a2 2
/*	$OpenBSD: ftp.c,v 1.14 1997/03/14 05:40:20 millert Exp $	*/
/*	$NetBSD: ftp.c,v 1.23 1997/03/13 06:23:17 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.14 1997/03/14 05:40:20 millert Exp $";
d813 1
d820 1
d849 1
d939 1
d948 1
d984 1
d1038 1
d1094 1
d1127 1
@


1.14
log
@Correct usage of S_IFREG.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.13 1997/03/14 04:32:16 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.13 1997/03/14 04:32:16 millert Exp $";
d846 1
@


1.13
log
@Sync with NetBSD and fix "get foo.txt /dev/tty" wrt progress meter
and setting times.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.12 1997/02/05 04:55:18 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.12 1997/02/05 04:55:18 millert Exp $";
d591 1
a591 1
		    (st.st_mode&S_IFMT) != S_IFREG) {
d965 1
a965 1
	if (!(st.st_mode & S_IFREG)) {
@


1.12
log
@Include signal.h where reasonable and make signal handlers match
what signal(3)'s prototype says (and cast when not).
Also change MAXFOO+1 -> MAXFOO since MAXFOO includes the NULL.
Support $TMPDIR and use utime(3) not utimes(2) for portability's sake.
Don't spew "Passive mode enabled/disabled" unless verbose (this means
togglevar() needs to watch for a NULL 'message').
@
text
@d1 2
a2 2
/*	$OpenBSD: ftp.c,v 1.11 1997/02/03 01:05:40 millert Exp $	*/
/*	$NetBSD: ftp.c,v 1.22 1997/02/01 10:45:03 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.11 1997/02/03 01:05:40 millert Exp $";
d66 3
d70 1
d307 3
d311 2
a312 1
va_dcl
a314 1
	char *fmt;
d317 3
d324 3
d328 2
a329 1
		fmt = va_arg(ap, char *);
d341 1
a341 1
		warn("No control connection for command");
d346 3
d351 1
d412 1
a412 1
"421 Service not available, remote server has closed connection");
d503 1
a503 1
	puts("\nsend aborted\nwaiting for remote to finish abort");
d520 1
d526 1
d558 1
d564 1
a564 1
	if (strcmp(local, "-") == 0)
d566 2
a567 1
	else if (*local == '|') {
d578 1
d607 1
d632 1
d640 1
d652 1
d663 1
d747 1
d762 1
d793 1
a793 1
	puts("\nreceive aborted\nwaiting for remote to finish abort");
d812 1
d818 1
d932 1
a932 1
	if (strcmp(local, "-") == 0)
d934 2
a935 1
	else if (*local == '|') {
d942 1
d965 4
d977 1
d1030 1
d1065 2
a1066 2
			printf("WARNING! %d bare linefeeds received in ASCII mode\n",
			    bare_lfs);
d1085 1
d1105 2
a1106 1
					printf("Can't change modification time on %s to %s",
d1112 1
d1117 1
d1181 2
a1182 1
			puts("Passive mode address scan failure. Shouldn't happen!");
d1280 3
a1282 1
	int s, fromlen = sizeof(from), tos;
d1455 1
a1455 1
		puts("No primary connection");
d1622 8
@


1.11
log
@Add back ``-r'' option and fix strncpy() usage and other nits because
I'm anal.  Closer to KNF now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp.c,v 1.22 1997/02/01 10:45:03 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.22 1997/02/01 10:45:03 lukem Exp $";
d65 1
d92 1
a92 1
	memset((char *)&hisctladdr, 0, sizeof(hisctladdr));
d198 2
a199 2
	char anonpass[MAXLOGNAME + MAXHOSTNAMELEN + 2];	/* "user@@hostname\0" */
	char hostname[MAXHOSTNAMELEN + 1];
d289 2
a290 1
cmdabort()
d478 2
a479 1
abortsend()
d756 2
a757 1
abortrecv()
a781 1
	struct timeval tval[2];
d1059 5
a1063 5
				(void)gettimeofday(&tval[0],
				    (struct timezone *)0);
				tval[1].tv_sec = mtime;
				tval[1].tv_usec = 0;
				if (utimes(local, tval) == -1) {
a1065 1
				}
d1266 2
a1267 1
psabort()
d1368 2
a1369 1
abortpt()
@


1.10
log
@Sync with NetBSD
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: ftp.c,v 1.22 1997/02/01 10:45:03 lukem Exp $";
d91 1
a91 1
	memset((char *)&hisctladdr, 0, sizeof (hisctladdr));
d94 2
a95 1
		(void) strncpy(hostnamebuf, host, sizeof(hostnamebuf));
d104 3
a106 4
		memmove((caddr_t)&hisctladdr.sin_addr,
				hp->h_addr_list[0], hp->h_length);
		memcpy(&hisctladdr.sin_addr, hp->h_addr, hp->h_length);
		(void) strncpy(hostnamebuf, hp->h_name, sizeof(hostnamebuf));
d117 1
a117 1
			sizeof (hisctladdr)) < 0) {
d126 4
a129 5
			memmove((caddr_t)&hisctladdr.sin_addr,
					hp->h_addr_list[0], hp->h_length);
			fprintf(stdout, "Trying %s...\n",
				inet_ntoa(hisctladdr.sin_addr));
			(void) close(s);
d142 1
a142 1
	len = sizeof (myctladdr);
d158 1
a158 1
			(void) fclose(cin);
d160 1
a160 1
			(void) fclose(cout);
d168 1
a168 1
			(void) fclose(cin);
d170 1
a170 1
			(void) fclose(cout);
d187 1
a187 1
	(void) close(s);
d250 1
a250 1
		(void) fgets(tmp, sizeof(tmp) - 1, stdin);
d273 1
a273 1
		(void) command("ACCT %s", acct);
d278 1
a278 1
			(void) strcpy(line, "$init");
d292 2
a293 2
	printf("\n");
	(void) fflush(stdout);
d311 1
a311 1
		printf("---> ");
d315 1
a315 1
			printf("PASS XXXX");
d317 1
a317 1
			printf("ACCT XXXX");
d319 1
a319 1
			vfprintf(stdout, fmt, ap);
d321 2
a322 2
		printf("\n");
		(void) fflush(stdout);
d334 2
a335 2
	fprintf(cout, "\r\n");
	(void) fflush(cout);
d340 1
a340 1
	(void) signal(SIGINT, oldintr);
d369 1
a369 1
					(void) fflush(cout);
d375 1
a375 1
					(void) fflush(cout);
d385 1
a385 1
					(void) signal(SIGINT, oldintr);
d391 3
a393 4
					printf("421 Service not available, "
					   "remote server has closed "
					   "connection\n");
					(void) fflush(stdout);
d399 2
a400 1
			    (verbose > -1 && n == '5' && dig > 4))) {
d404 1
a404 1
				(void) putchar(c);
d430 4
a433 3
		if (verbose > 0 || (verbose > -1 && n == '5')) {
			(void) putchar(c);
			(void) fflush (stdout);
d441 1
a441 1
			(void) strncpy(reply_string, current_line, len);
d452 1
a452 1
		(void) signal(SIGINT, oldintr);
d482 2
a483 2
	printf("\nsend aborted\nwaiting for remote to finish abort\n");
	(void) fflush(stdout);
d523 1
a523 1
			(void) getreply(0);
d526 1
a526 1
			(void) close(data);
d530 1
a530 1
			(void) signal(SIGINT, oldintr);
d532 1
a532 1
			(void) signal(SIGPIPE, oldintp);
d534 1
a534 1
			(void) signal(SIGINFO, oldinti);
d547 3
a549 3
			(void) signal(SIGINT, oldintr);
			(void) signal(SIGPIPE, oldintp);
			(void) signal(SIGINFO, oldinti);
d558 2
a559 2
			(void) signal(SIGINT, oldintr);
			(void) signal(SIGINFO, oldinti);
d566 3
a568 3
			fprintf(stdout, "%s: not a plain file.\n", local);
			(void) signal(SIGINT, oldintr);
			(void) signal(SIGINFO, oldinti);
d576 2
a577 2
		(void) signal(SIGINT, oldintr);
		(void) signal(SIGINFO, oldinti);
d579 1
a579 1
			(void) signal(SIGPIPE, oldintp);
d621 2
a622 2
			(void) signal(SIGINT, oldintr);
			(void) signal(SIGINFO, oldinti);
d624 1
a624 1
				(void) signal(SIGPIPE, oldintp);
d631 2
a632 2
			(void) signal(SIGINT, oldintr);
			(void) signal(SIGINFO, oldinti);
d634 1
a634 1
				(void) signal(SIGPIPE, oldintp);
d649 1
a649 1
		while ((c = read(fileno(fin), buf, sizeof (buf))) > 0) {
d656 1
a656 1
					(void) putchar('#');
d659 1
a659 1
				(void) fflush(stdout);
d664 3
a666 3
				(void) putchar('#');
			(void) putchar('\n');
			(void) fflush(stdout);
d682 2
a683 2
					(void) putchar('#');
					(void) fflush(stdout);
d688 1
a688 1
				(void) putc('\r', dout);
d691 1
a691 1
			(void) putc(c, dout);
d702 3
a704 3
				(void) putchar('#');
			(void) putchar('\n');
			(void) fflush(stdout);
d718 4
a721 4
	(void) fclose(dout);
	(void) getreply(0);
	(void) signal(SIGINT, oldintr);
	(void) signal(SIGINFO, oldinti);
d723 1
a723 1
		(void) signal(SIGPIPE, oldintp);
d728 2
a729 2
	(void) signal(SIGINT, oldintr);
	(void) signal(SIGINFO, oldinti);
d731 1
a731 1
		(void) signal(SIGPIPE, oldintp);
d737 1
a737 1
		(void) close(data);
d741 2
a742 2
		(void) fclose(dout);
	(void) getreply(0);
d759 2
a760 2
	printf("\nreceive aborted\nwaiting for remote to finish abort\n");
	(void) fflush(stdout);
d801 1
a801 1
			(void) getreply(0);
d804 1
a804 1
			(void) close(data);
d808 1
a808 1
			(void) signal(SIGINT, oldintr);
d810 1
a810 1
			(void) signal(SIGINFO, oldinti);
d822 2
a823 2
				(void) signal(SIGINT, oldintr);
				(void) signal(SIGINFO, oldinti);
d834 2
a835 2
				(void) signal(SIGINT, oldintr);
				(void) signal(SIGINFO, oldinti);
d842 2
a843 2
				(void) signal(SIGINT, oldintr);
				(void) signal(SIGINFO, oldinti);
d849 2
a850 2
				(void) signal(SIGINT, oldintr);
				(void) signal(SIGINFO, oldinti);
d856 2
a857 2
			(void) signal(SIGINT, oldintr);
			(void) signal(SIGINFO, oldinti);
d871 2
a872 2
		(void) signal(SIGINT, oldintr);
		(void) signal(SIGINFO, oldinti);
d883 2
a884 2
			(void) signal(SIGINT, oldintr);
			(void) signal(SIGINFO, oldinti);
d889 2
a890 2
			(void) signal(SIGINT, oldintr);
			(void) signal(SIGINFO, oldinti);
d919 1
a919 1
			(void) free(buf);
d947 1
a947 1
					(void) putchar('#');
d950 1
a950 1
				(void) fflush(stdout);
d955 3
a957 3
				(void) putchar('#');
			(void) putchar('\n');
			(void) fflush(stdout);
d999 2
a1000 2
					(void) putchar('#');
					(void) fflush(stdout);
d1007 1
a1007 1
					(void) putc('\r', fout);
d1016 1
a1016 1
			(void) putc(c, fout);
d1022 3
a1024 3
			printf("WARNING! %d bare linefeeds received in ASCII "
			    "mode\n", bare_lfs);
			printf("File may not have transferred correctly.\n");
d1028 3
a1030 3
				(void) putchar('#');
			(void) putchar('\n');
			(void) fflush(stdout);
d1044 2
a1045 2
	(void) signal(SIGINT, oldintr);
	(void) signal(SIGINFO, oldinti);
d1047 3
a1049 3
		(void) signal(SIGPIPE, oldintp);
	(void) fclose(din);
	(void) getreply(0);
d1056 1
a1056 1
				(void) gettimeofday(&tval[0],
d1061 2
a1062 3
					printf("Can't change modification time "
						"on %s to %s", local,
						asctime(localtime(&mtime)));
d1073 2
a1074 2
		(void) signal(SIGPIPE, oldintp);
	(void) signal(SIGINT, SIG_IGN);
d1077 2
a1078 2
		(void) signal(SIGINT, oldintr);
		(void) signal(SIGINFO, oldinti);
d1085 1
a1085 1
		(void) close(data);
d1091 1
a1091 1
		(void) fclose(din);
d1094 2
a1095 2
	(void) signal(SIGINT, oldintr);
	(void) signal(SIGINFO, oldinti);
d1118 1
a1118 1
			       sizeof (on)) < 0)
d1121 1
a1121 1
			printf("Passive mode refused.\n");
d1135 1
a1135 2
			printf("Passive mode address scan failure. "
			       "Shouldn't happen!\n");
d1169 1
a1169 1
		(void) close(data);
d1179 1
a1179 1
				sizeof (on)) < 0) {
d1183 1
a1183 1
	if (bind(data, (struct sockaddr *)&data_addr, sizeof (data_addr)) < 0) {
d1189 1
a1189 1
			sizeof (on)) < 0)
d1191 1
a1191 1
	len = sizeof (data_addr);
d1222 1
a1222 1
	(void) close(data), data = -1;
d1233 1
a1233 1
	int s, fromlen = sizeof (from), tos;
d1241 1
a1241 1
		(void) close(data), data = -1;
d1244 1
a1244 1
	(void) close(data);
d1316 2
a1317 2
		(void) strncpy(ip->name, hostname, sizeof(ip->name) - 1);
		ip->name[strlen(ip->name)] = '\0';
d1319 1
a1319 1
		ip->name[0] = 0;
d1343 6
a1348 6
	(void) strncpy(ip->nti, ntin, 16);
	(ip->nti)[strlen(ip->nti)] = '\0';
	(void) strcpy(ntin, op->nti);
	(void) strncpy(ip->nto, ntout, 16);
	(ip->nto)[strlen(ip->nto)] = '\0';
	(void) strcpy(ntout, op->nto);
d1351 7
a1357 7
	(void) strncpy(ip->mi, mapin, MAXPATHLEN - 1);
	(ip->mi)[strlen(ip->mi)] = '\0';
	(void) strcpy(mapin, op->mi);
	(void) strncpy(ip->mo, mapout, MAXPATHLEN - 1);
	(ip->mo)[strlen(ip->mo)] = '\0';
	(void) strcpy(mapout, op->mo);
	(void) signal(SIGINT, oldintr);
d1369 2
a1370 2
	printf("\n");
	(void) fflush(stdout);
d1399 1
a1399 2
		printf("proxy server does not support third party "
		    "transfers.\n");
d1404 1
a1404 1
		printf("No primary connection\n");
d1419 1
a1419 1
		(void) signal(SIGINT, oldintr);
d1429 1
a1429 1
	(void) getreply(0);
d1431 2
a1432 2
	(void) getreply(0);
	(void) signal(SIGINT, oldintr);
d1438 1
a1438 1
	(void) signal(SIGINT, SIG_IGN);
d1453 1
a1453 1
		(void) signal(SIGINT, oldintr);
d1467 1
a1467 1
			(void) signal(SIGINT, oldintr);
d1485 2
a1486 2
		(void) getreply(0);
		(void) getreply(0);
d1493 1
a1493 1
	(void) signal(SIGINT, oldintr);
d1513 1
a1513 1
			(void) getreply(0);
d1536 1
a1536 1
	(void) strcpy(new, local);
d1541 1
a1541 1
			printf("runique: can't find unique file name.\n");
d1580 1
a1580 1
	(void) fflush(cout);
d1600 1
a1600 1
		(void) getreply(0);
d1602 1
a1602 1
	(void) getreply(0);
@


1.9
log
@"Too much paranoia" + fake domain in anonftp password as some stupid sites
requires it to at least look sensible.
@
text
@d1 1
a1 2
/*      $OpenBSD: ftp.c,v 1.8 1996/12/16 15:51:28 deraadt Exp $      */
/*      $NetBSD: ftp.c,v 1.13 1995/09/16 22:32:59 pk Exp $      */
d40 1
a40 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.8 1996/12/16 15:51:28 deraadt Exp $";
d44 1
a44 1
#include <sys/param.h>
a45 1
#include <sys/ioctl.h>
a46 2
#include <sys/time.h>
#include <sys/file.h>
a57 1
#include <fcntl.h>
a59 1
#include <signal.h>
a67 2
extern int h_errno;

d83 1
a83 1
	char *host;
d88 1
a88 1
	static char hostnamebuf[80];
d115 2
a116 1
	while (connect(s, (struct sockaddr *)&hisctladdr, sizeof (hisctladdr)) < 0) {
d193 1
a193 1
	char *host;
d197 2
a199 1
	char anonpass[64 + 1];
d201 1
a201 1
	user = pass = acct = 0;
d206 11
a216 1
	if (anonftp) {
d218 15
a232 4
		strncpy(anonpass, user, sizeof anonpass - 1);
		anonpass[sizeof anonpass - 1] = '\0';
		strncat(anonpass, "@@anon.openbsd.org",		/* XXX ugly */
		    sizeof anonpass - strlen(anonpass) - 1);
d236 1
d291 1
d296 1
a296 1
		longjmp(ptabort,1);
d316 3
a318 1
		else 
d344 1
a344 1
char reply_string[BUFSIZ];		/* last line of previous reply */
d350 2
a351 1
	int c, n;
d359 1
a359 1
	for (;;) {
d361 1
a361 1
		cp = reply_string;
d385 1
a385 1
					(void) signal(SIGINT,oldintr);
d391 3
a393 1
					printf("421 Service not available, remote server has closed connection\n");
d399 2
a400 5
			if (n == 0)
				n = c;
			if (c != '\r' && (n < '5' || !retry_connect) &&
			    (verbose > 0 ||
			      (verbose > -1 && n == '5' && dig > 4))) {
d402 2
a403 2
				   (dig == 1 || dig == 5 && verbose == 0))
					printf("%s:",hostname);
d425 3
a427 1
			if (cp < &reply_string[sizeof(reply_string) - 1])
d430 1
a430 2
		if ((verbose > 0 || (verbose > -1 && n == '5')) &&
		    (n < '5' || !retry_connect)) {
d434 9
d451 1
a451 1
		(void) signal(SIGINT,oldintr);
d478 1
d488 1
a488 1
	char *cmd, *local, *remote;
a491 1
	struct timeval start, stop;
d493 1
a493 1
	FILE *fin, *dout = 0, *popen();
d495 2
a496 2
	sig_t oldintr, oldintp;
	long bytes = 0, hashbytes = mark;
d499 4
d518 1
d529 1
a529 1
			(void) signal(SIGINT,oldintr);
d531 3
a533 1
			(void) signal(SIGPIPE,oldintp);
d538 1
d542 1
a542 1
		oldintp = signal(SIGPIPE,SIG_IGN);
d548 1
d558 1
d567 1
d572 1
d576 1
d591 1
d621 1
d631 1
d641 1
a641 1
	(void) gettimeofday(&start, (struct timezone *)0);
d653 1
a653 1
			if (hash) {
d661 1
a661 1
		if (hash && bytes > 0) {
d670 1
a670 1
			if (errno != EPIPE) 
d679 2
a680 1
				while (hash && (bytes >= hashbytes)) {
d692 6
a697 4
	/*		if (c == '\r') {			  	*/
	/*		(void)	putc('\0', dout);  // this violates rfc */
	/*			bytes++;				*/
	/*		}                          			*/	
d699 1
a699 1
		if (hash) {
d714 1
a717 1
	(void) gettimeofday(&stop, (struct timezone *)0);
d720 1
d724 1
a724 1
		ptransfer("sent", bytes, &start, &stop);
d728 1
a744 1
	(void) gettimeofday(&stop, (struct timezone *)0);
d746 1
a746 1
		ptransfer("sent", bytes, &start, &stop);
d755 1
d765 1
a765 1
	char *cmd, *local, *remote, *lmode;
d770 1
a770 1
	sig_t oldintr, oldintp;
d774 1
a774 2
	long bytes = 0, hashbytes = mark;
	struct timeval start, stop;
d776 2
d779 4
d808 2
d814 1
d822 1
d828 1
a828 1
			d = access(dir ? local : ".", 2);
d834 1
d842 1
a842 1
				(void) signal(SIGINT, oldintr);
d849 1
d856 1
d864 5
a868 2
	} else if (curtype != type)
		changetype(type, 0);
d871 1
d883 1
d889 1
d927 1
a927 1
	(void) gettimeofday(&start, (struct timezone *)0);
d944 1
a944 1
			if (hash) {
d952 1
a952 1
		if (hash && bytes > 0) {
d996 2
a997 1
				while (hash && (bytes >= hashbytes)) {
d1021 2
a1022 1
			printf("WARNING! %d bare linefeeds received in ASCII mode\n", bare_lfs);
d1025 1
a1025 1
		if (hash) {
d1040 1
d1044 1
a1047 1
	(void) gettimeofday(&stop, (struct timezone *)0);
d1049 18
a1066 2
	if (bytes > 0 && is_retr)
		ptransfer("received", bytes, &start, &stop);
d1070 1
a1070 1
/* abort using RFC959 recommended IP,SYNC sequence  */
d1073 1
a1073 1
		(void) signal(SIGPIPE, oldintr);
d1078 1
a1091 1
	(void) gettimeofday(&stop, (struct timezone *)0);
d1093 1
a1093 1
		ptransfer("received", bytes, &start, &stop);
d1095 1
d1113 2
a1114 2
			perror("ftp: socket");
			return(1);
d1119 1
a1119 1
			perror("ftp: setsockopt (ignored)");
d1133 1
a1133 1
		if (sscanf(pasv,"%d,%d,%d,%d,%d,%d",
d1140 1
a1140 1
		bzero(&data_addr, sizeof(data_addr));
d1153 1
a1153 1
			perror("ftp: connect");
d1160 1
a1160 1
			perror("ftp: setsockopt TOS (ignored)");
d1162 1
a1162 1
		return(0);
d1168 1
a1168 1
		data_addr.sin_port = 0;	/* let system pick one */ 
d1179 2
a1180 1
		if (setsockopt(data, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof (on)) < 0) {
d1189 2
a1190 1
	    setsockopt(data, SOL_SOCKET, SO_DEBUG, (char *)&on, sizeof (on)) < 0)
d1231 1
a1231 1
	char *lmode;
d1256 2
a1257 4
ptransfer(direction, bytes, t0, t1)
	char *direction;
	long bytes;
	struct timeval *t0, *t1;
d1259 3
a1261 12
	struct timeval td;
	float s;
	long bs;

	if (verbose) {
		timersub(t1, t0, &td);
		s = td.tv_sec + (td.tv_usec / 1000000.);
#define	nz(x)	((x) == 0 ? 1 : (x))
		bs = bytes / nz(s);
		printf("%ld bytes %s in %.3g seconds (%ld bytes/s)\n",
		    bytes, direction, s, bs);
	}
d1268 1
d1369 1
d1380 1
a1380 1
	char *cmd, *local, *remote;
d1400 2
a1401 1
		printf("proxy server does not support third party transfers.\n");
d1509 1
a1509 1
		if ((nfnd = empty(&mask,0)) < 0) {
d1522 1
a1522 1
	char *local;
d1531 1
a1531 1
	d = access(cp ? local : ".", 2);
d1581 1
a1581 1
	fprintf(cout,"%cABOR\r\n", DM);
d1585 1
a1585 1
	if (din) { 
@


1.8
log
@strncat botch
@
text
@d1 1
a1 1
/*      $OpenBSD: ftp.c,v 1.7 1996/11/09 19:57:46 kstailey Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.7 1996/11/09 19:57:46 kstailey Exp $";
d205 1
a205 1
	char anonpass[32+1];
d214 4
a217 3
		strncpy(anonpass, user, sizeof anonpass-1);
		anonpass[sizeof anonpass-1] = '\0';
		strncat(anonpass, "@@", sizeof anonpass-sizeof(anonpass));
@


1.7
log
@optional size argument to hash command
@
text
@d1 1
a1 1
/*      $OpenBSD: ftp.c,v 1.6 1996/10/31 14:36:56 mickey Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.6 1996/10/31 14:36:56 mickey Exp $";
d214 3
a216 2
		strncpy(anonpass, user, sizeof anonpass);
		strncat(anonpass, "@@", sizeof anonpass);
@


1.6
log
@add -r<seconds> option to retry connection.
dunno how to do optional argument.
@
text
@d1 1
a1 1
/*      $OpenBSD: ftp.c,v 1.5 1996/08/02 05:56:23 deraadt Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.5 1996/08/02 05:56:23 deraadt Exp $";
a453 2
#define HASHBYTES 1024

d465 1
a465 1
	long bytes = 0, hashbytes = HASHBYTES;
d609 1
a609 1
					hashbytes += HASHBYTES;
d615 1
a615 1
			if (bytes < HASHBYTES)
d635 1
a635 1
					hashbytes += HASHBYTES;
d722 1
a722 1
	long bytes = 0, hashbytes = HASHBYTES;
d877 1
a877 1
					hashbytes += HASHBYTES;
d883 1
a883 1
			if (bytes < HASHBYTES)
d929 1
a929 1
					hashbytes += HASHBYTES;
@


1.5
log
@password user@@, not user@@hostname
@
text
@d1 1
a1 1
/*      $OpenBSD: ftp.c,v 1.4 1996/06/26 05:33:36 deraadt Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.4 1996/06/26 05:33:36 deraadt Exp $";
d375 5
a379 2
			if (c != '\r' && (verbose > 0 ||
			    (verbose > -1 && n == '5' && dig > 4))) {
a403 2
			if (n == 0)
				n = c;
d407 2
a408 1
		if (verbose > 0 || verbose > -1 && n == '5') {
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*      $OpenBSD: ftp.c,v 1.13 1995/09/16 22:32:59 pk Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ftp.c,v 1.13 1995/09/16 22:32:59 pk Exp $";
d205 1
a205 2
	char anonpass[MAXHOSTNAMELEN+2+32];
	char hostname[MAXHOSTNAMELEN];
d214 2
a215 4
		strncpy(anonpass, user, 32);
		strcat(anonpass, "@@");
		gethostname(hostname, sizeof hostname);
		strcat(anonpass, hostname);
@


1.3
log
@correct anonftp passwd
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: ftp.c,v 1.13 1995/09/16 22:32:59 pk Exp $";
@


1.2
log
@add support for automatic anonftp fetches of host:path
add support for -p portnum
might need todo: -N for silence, better exit status for failures
@
text
@d205 1
d216 2
a217 1
		gethostname(&anonpass[strlen(anonpass)-1], MAXHOSTNAMELEN);
@


1.1
log
@Initial revision
@
text
@d204 1
d210 8
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
