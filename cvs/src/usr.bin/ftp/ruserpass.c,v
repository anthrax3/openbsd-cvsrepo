head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.14
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.12
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.8
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.4
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.20
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.18
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.16
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.14
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.12
	OPENBSD_5_0:1.28.0.10
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.8
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.6
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.26.0.4
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.18.0.8
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.6
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.12.0.6
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.10
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.8
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.6
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2015.01.16.06.40.08;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	Uu5nFG3wCl0LACBb;

1.29
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2009.05.05.19.35.30;	author martynas;	state Exp;
branches;
next	1.27;

1.27
date	2009.04.27.21.37.13;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.25.21.15.19;	author martynas;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.20.17.56.37;	author moritz;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.06.19.15.33;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.24.14.29.02;	author moritz;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.22.15.25.17;	author moritz;	state Exp;
branches;
next	1.21;

1.21
date	2007.03.22.11.35.02;	author moritz;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.16.23.43.16;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.25.05.45.20;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.20.03.50.26;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.16.21.46.22;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.03.02.56.08;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.05.17.19.47;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.31.23.04.07;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.46;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.27.19.59.13;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.03.30.06.59.35;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.09.05.00.02.30;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.25.21.56.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.04.23.20.33.21;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.04.10.00.17.10;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.03.14.04.32.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.02.03.01.05.44;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.02.03.01.02.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.10.28.00.32.30;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.33.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.18;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: ruserpass.c,v 1.29 2014/05/20 01:25:23 guenther Exp $	*/
/*	$NetBSD: ruserpass.c,v 1.14 1997/07/20 09:46:01 lukem Exp $	*/

/*
 * Copyright (c) 1985, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef SMALL

#include <sys/types.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ftp_var.h"

static	int token(void);
static	FILE *cfile;

#define	DEFAULT	1
#define	LOGIN	2
#define	PASSWD	3
#define	ACCOUNT 4
#define MACDEF  5
#define	ID	10
#define	MACH	11

static char tokval[100];

static struct toktab {
	char *tokstr;
	int tval;
} toktab[]= {
	{ "default",	DEFAULT },
	{ "login",	LOGIN },
	{ "password",	PASSWD },
	{ "passwd",	PASSWD },
	{ "account",	ACCOUNT },
	{ "machine",	MACH },
	{ "macdef",	MACDEF },
	{ NULL,		0 }
};

int
ruserpass(const char *host, char **aname, char **apass, char **aacct)
{
	char *hdir, buf[PATH_MAX], *tmp;
	char myname[HOST_NAME_MAX+1], *mydomain;
	int t, i, c, usedefault = 0;
	struct stat stb;

	hdir = getenv("HOME");
	if (hdir == NULL || *hdir == '\0')
		return (0);
	i = snprintf(buf, sizeof(buf), "%s/.netrc", hdir);
	if (i < 0 || i >= sizeof(buf)) {
		warnc(ENAMETOOLONG, "%s/.netrc", hdir);
		return (0);
	}
	cfile = fopen(buf, "r");
	if (cfile == NULL) {
		if (errno != ENOENT)
			warn("%s", buf);
		return (0);
	}
	if (gethostname(myname, sizeof(myname)) < 0)
		myname[0] = '\0';
	if ((mydomain = strchr(myname, '.')) == NULL)
		mydomain = "";
next:
	while ((t = token()) > 0) switch(t) {

	case DEFAULT:
		usedefault = 1;
		/* FALLTHROUGH */

	case MACH:
		if (!usedefault) {
			if ((t = token()) == -1)
				goto bad;
			if (t != ID)
				continue;
			/*
			 * Allow match either for user's input host name
			 * or official hostname.  Also allow match of
			 * incompletely-specified host in local domain.
			 */
			if (strcasecmp(host, tokval) == 0)
				goto match;
			if (strcasecmp(hostname, tokval) == 0)
				goto match;
			if ((tmp = strchr(hostname, '.')) != NULL &&
			    strcasecmp(tmp, mydomain) == 0 &&
			    strncasecmp(hostname, tokval,
			    (size_t)(tmp - hostname)) == 0 &&
			    tokval[tmp - hostname] == '\0')
				goto match;
			if ((tmp = strchr(host, '.')) != NULL &&
			    strcasecmp(tmp, mydomain) == 0 &&
			    strncasecmp(host, tokval,
			    (size_t)(tmp - host)) == 0 &&
			    tokval[tmp - host] == '\0')
				goto match;
			continue;
		}
	match:
		while ((t = token()) > 0 &&
		    t != MACH && t != DEFAULT) switch(t) {

		case LOGIN:
			if ((t = token()) == -1)
				goto bad;
			if (t) {
				if (*aname == 0) {
					if ((*aname = strdup(tokval)) == NULL)
						err(1, "strdup");
				} else {
					if (strcmp(*aname, tokval))
						goto next;
				}
			}
			break;
		case PASSWD:
			if ((*aname == NULL || strcmp(*aname, "anonymous")) &&
			    fstat(fileno(cfile), &stb) >= 0 &&
			    (stb.st_mode & 077) != 0) {
	warnx("Error: .netrc file is readable by others.");
	warnx("Remove password or make file unreadable by others.");
				goto bad;
			}
			if ((t = token()) == -1)
				goto bad;
			if (t && *apass == 0) {
				if ((*apass = strdup(tokval)) == NULL)
					err(1, "strdup");
			}
			break;
		case ACCOUNT:
			if (fstat(fileno(cfile), &stb) >= 0
			    && (stb.st_mode & 077) != 0) {
	warnx("Error: .netrc file is readable by others.");
	warnx("Remove account or make file unreadable by others.");
				goto bad;
			}
			if ((t = token()) == -1)
				goto bad;
			if (t && *aacct == 0) {
				if ((*aacct = strdup(tokval)) == NULL)
					err(1, "strdup");
			}
			break;
		case MACDEF:
			if (proxy) {
				(void)fclose(cfile);
				return (0);
			}
			while ((c = fgetc(cfile)) != EOF)
				if (c != ' ' && c != '\t')
					break;
			if (c == EOF || c == '\n') {
				fputs("Missing macdef name argument.\n", ttyout);
				goto bad;
			}
			if (macnum == 16) {
				fputs(
"Limit of 16 macros have already been defined.\n", ttyout);
				goto bad;
			}
			tmp = macros[macnum].mac_name;
			*tmp++ = c;
			for (i=0; i < 8 && (c = fgetc(cfile)) != EOF &&
			    !isspace(c); ++i) {
				*tmp++ = c;
			}
			if (c == EOF) {
				fputs(
"Macro definition missing null line terminator.\n", ttyout);
				goto bad;
			}
			*tmp = '\0';
			if (c != '\n') {
				while ((c = fgetc(cfile)) != EOF && c != '\n');
			}
			if (c == EOF) {
				fputs(
"Macro definition missing null line terminator.\n", ttyout);
				goto bad;
			}
			if (macnum == 0) {
				macros[macnum].mac_start = macbuf;
			}
			else {
				macros[macnum].mac_start =
				    macros[macnum-1].mac_end + 1;
			}
			tmp = macros[macnum].mac_start;
			while (tmp != macbuf + 4096) {
				if ((c = fgetc(cfile)) == EOF) {
				fputs(
"Macro definition missing null line terminator.\n", ttyout);
					goto bad;
				}
				*tmp = c;
				if (*tmp == '\n') {
					if (tmp == macros[macnum].mac_start) {
						macros[macnum++].mac_end = tmp;
						break;
					} else if (*(tmp-1) == '\0') {
						macros[macnum++].mac_end =
						    tmp - 1;
						break;
					}
					*tmp = '\0';
				}
				tmp++;
			}
			if (tmp == macbuf + 4096) {
				fputs("4K macro buffer exceeded.\n", ttyout);
				goto bad;
			}
			break;
		default:
			warnx("Unknown .netrc keyword %s", tokval);
			break;
		}
		goto done;
	}
done:
	if (t == -1)
		goto bad;
	(void)fclose(cfile);
	return (0);
bad:
	(void)fclose(cfile);
	return (-1);
}

static int
token(void)
{
	char *cp;
	int c;
	struct toktab *t;

	if (feof(cfile) || ferror(cfile))
		return (0);
	while ((c = fgetc(cfile)) != EOF &&
	    (c == '\n' || c == '\t' || c == ' ' || c == ','))
		continue;
	if (c == EOF)
		return (0);
	cp = tokval;
	if (c == '"') {
		while ((c = fgetc(cfile)) != EOF && c != '"') {
			if (c == '\\' && (c = fgetc(cfile)) == EOF)
				break;
			*cp++ = c;
			if (cp == tokval + sizeof(tokval)) {
				warnx("Token in .netrc too long");
				return (-1);
			}
		}
	} else {
		*cp++ = c;
		while ((c = fgetc(cfile)) != EOF
		    && c != '\n' && c != '\t' && c != ' ' && c != ',') {
			if (c == '\\' && (c = fgetc(cfile)) == EOF)
				break;
			*cp++ = c;
			if (cp == tokval + sizeof(tokval)) {
				warnx("Token in .netrc too long");
				return (-1);
			}
		}
	}
	*cp = 0;
	if (tokval[0] == 0)
		return (0);
	for (t = toktab; t->tokstr; t++)
		if (!strcmp(t->tokstr, tokval))
			return (t->tval);
	return (ID);
}

#endif /* !SMALL */

@


1.29
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.28 2009/05/05 19:35:30 martynas Exp $	*/
d78 2
a79 2
	char *hdir, buf[MAXPATHLEN], *tmp;
	char myname[MAXHOSTNAMELEN], *mydomain;
@


1.28
log
@make it clean removing the ifdef SMALL maze.  separate cmds and
small stuff.  make it a fetcher.  shrinks quite a bit
agreed by millert@@, krw@@
ok theo, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.27 2009/04/27 21:37:13 deraadt Exp $	*/
d88 1
a88 1
		warnx("%s/.netrc: %s", hdir, strerror(ENAMETOOLONG));
@


1.27
log
@toast the rcsid strings which just get in the way
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.26 2008/06/25 21:15:19 martynas Exp $	*/
d315 1
d317 1
@


1.26
log
@in resume mode, pass -c to mget when {dir,file}hasglob, so that i'm
able to continue multiple transfers with -C;  ok millert@@
while here fix some comments (!SMALL vs. SMALL stuff), and add
missing
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.25 2007/06/20 17:56:37 moritz Exp $	*/
a33 7
#ifndef lint
#if 0
static char sccsid[] = "@@(#)ruserpass.c	8.4 (Berkeley) 4/27/95";
#else
static const char rcsid[] = "$OpenBSD: ruserpass.c,v 1.25 2007/06/20 17:56:37 moritz Exp $";
#endif
#endif /* not lint */
@


1.25
log
@Add missing return value checks for strdup() andd fgetc().
From Nicholas Marriott. Reminded by ray@@.

ok ray@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.24 2007/06/06 19:15:33 pyr Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: ruserpass.c,v 1.24 2007/06/06 19:15:33 pyr Exp $";
d322 1
a322 1
#endif
@


1.24
log
@Remove the .netrc parser when compiling a SMALL binary.
there is no .netrc file on the install media and keeping the parser
shaves a good deal of bytes in the binary.
ok millert@@, "go on" deraadt@@, "makes sense" steven@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.23 2007/03/24 14:29:02 moritz Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: ruserpass.c,v 1.23 2007/03/24 14:29:02 moritz Exp $";
d152 4
a155 3
				if (*aname == 0)
					*aname = strdup(tokval);
				else {
d171 4
a174 2
			if (t && *apass == 0)
				*apass = strdup(tokval);
d185 4
a188 2
			if (t && *aacct == 0)
				*aacct = strdup(tokval);
d293 2
a294 2
			if (c == '\\')
				c = fgetc(cfile);
d305 2
a306 2
			if (c == '\\')
				c = fgetc(cfile);
@


1.23
log
@Use MAXPATHLEN for buffer, which is only used for path construction
and fix handling of empty macdefs, which could result in the mac_end
ptr beeing smaller than mac_start, resulting in crashes later on.

From Nicholas Marriott.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.22 2007/03/22 15:25:17 moritz Exp $	*/
d33 1
d38 1
a38 3
#ifndef SMALL
static const char rcsid[] = "$OpenBSD: ruserpass.c,v 1.22 2007/03/22 15:25:17 moritz Exp $";
#endif /* SMALL */
d317 1
@


1.22
log
@Remove wrong length check, which ignored the '/' character
and let snprintf(3) decide if the path fitted into the buffer.
Inspired by a diff from Nicholas Marriott.

OK millert@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.21 2007/03/22 11:35:02 moritz Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: ruserpass.c,v 1.21 2007/03/22 11:35:02 moritz Exp $";
d86 1
a86 1
	char *hdir, buf[BUFSIZ], *tmp;
d239 7
a245 3
					if (*(tmp-1) == '\0') {
					   macros[macnum++].mac_end = tmp - 1;
					   break;
@


1.21
log
@Fix buffer overflow when parsing the .netrc file.
From Nicholas Marriott.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.20 2006/05/16 23:43:16 ray Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: ruserpass.c,v 1.20 2006/05/16 23:43:16 ray Exp $";
d94 2
a95 3
	if (strlen(hdir) + sizeof(".netrc") < sizeof(buf)) {
		(void)snprintf(buf, sizeof buf, "%s/.netrc", hdir);
	} else {
@


1.20
log
@Remove shadowing variables and properly use /* FALLTHROUGH */
comments.  No binary change.

Found by lint.

OK beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.19 2006/04/25 05:45:20 tedu Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: ruserpass.c,v 1.19 2006/04/25 05:45:20 tedu Exp $";
d111 1
a111 1
	while ((t = token())) switch(t) {
d119 3
a121 1
			if (token() != ID)
d147 2
a148 1
		while ((t = token()) && t != MACH && t != DEFAULT) switch(t) {
d151 3
a153 1
			if (token()) {
d170 3
a172 1
			if (token() && *apass == 0)
d182 3
a184 1
			if (token() && *aacct == 0)
d260 2
d289 4
d301 4
@


1.19
log
@two strtol calls that were begging to be converted to strtonum
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.18 2004/07/20 03:50:26 deraadt Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: ruserpass.c,v 1.18 2004/07/20 03:50:26 deraadt Exp $";
d115 1
a115 1
		/* FALL THROUGH */
@


1.18
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.17 2003/12/16 21:46:22 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.17 2003/12/16 21:46:22 deraadt Exp $";
@


1.17
log
@for -DSMALL, do not include rcsid[]s
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.16 2003/06/03 02:56:08 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.16 2003/06/03 02:56:08 millert Exp $";
d84 1
a84 3
ruserpass(host, aname, apass, aacct)
	const char *host;
	char **aname, **apass, **aacct;
d259 1
a259 1
token()
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.15 2003/04/05 17:19:47 deraadt Exp $	*/
d37 3
a39 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.15 2003/04/05 17:19:47 deraadt Exp $";
@


1.15
log
@string fixes; ok miod henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.14 2003/03/31 23:04:07 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.14 2003/03/31 23:04:07 millert Exp $";
@


1.14
log
@Treat empty environment variables the same as NULL.  henning@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.13 2002/02/16 21:27:46 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.13 2002/02/16 21:27:46 millert Exp $";
d99 1
a99 1
		(void)sprintf(buf, "%s/.netrc", hdir);
d153 3
a155 5
				if (*aname == 0) {
					*aname = malloc((unsigned)
					    strlen(tokval) + 1);
					(void)strcpy(*aname, tokval);
				} else {
d169 2
a170 4
			if (token() && *apass == 0) {
				*apass = malloc((unsigned) strlen(tokval) + 1);
				(void)strcpy(*apass, tokval);
			}
d179 2
a180 4
			if (token() && *aacct == 0) {
				*aacct = malloc((unsigned) strlen(tokval) + 1);
				(void)strcpy(*aacct, tokval);
			}
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.12 2000/07/27 19:59:13 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.12 2000/07/27 19:59:13 millert Exp $";
d96 1
a96 1
	if (hdir == NULL)
@


1.12
log
@If the HOME environment variable is not set, do not try to read
.netrc from cwd.  Mostly paranoia but good practive.  Closes PR 1332.
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.11 1998/03/30 06:59:35 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.11 1998/03/30 06:59:35 deraadt Exp $";
d58 1
a58 1
static	int token __P((void));
@


1.11
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.10 1997/09/05 00:02:30 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.10 1997/09/05 00:02:30 millert Exp $";
d97 1
a97 1
		hdir = ".";
@


1.10
log
@getc() -> fgetc() for easy socksification.  imp@@openbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.9 1997/07/25 21:56:22 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.9 1997/07/25 21:56:22 millert Exp $";
d152 1
a152 1
			if (token())
d161 1
@


1.9
log
@Updates from NetBSD (lukem) include -Wall cleanup.
More -W* cleanup and in_port_t usage by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.8 1997/04/23 20:33:21 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.8 1997/04/23 20:33:21 deraadt Exp $";
d192 1
a192 1
			while ((c=getc(cfile)) != EOF)
d206 1
a206 1
			for (i=0; i < 8 && (c=getc(cfile)) != EOF &&
d217 1
a217 1
				while ((c=getc(cfile)) != EOF && c != '\n');
d233 1
a233 1
				if ((c=getc(cfile)) == EOF) {
d276 1
a276 1
	while ((c = getc(cfile)) != EOF &&
d283 1
a283 1
		while ((c = getc(cfile)) != EOF && c != '"') {
d285 1
a285 1
				c = getc(cfile);
d290 1
a290 1
		while ((c = getc(cfile)) != EOF
d293 1
a293 1
				c = getc(cfile);
@


1.8
log
@allow "ftp -aV ftp://host/foo.tar.gz | tar xvfpz -" to work
@
text
@d1 2
a2 2
/*	$OpenBSD: ruserpass.c,v 1.7 1997/04/10 00:17:10 millert Exp $	*/
/*	$NetBSD: ruserpass.c,v 1.13 1997/04/01 14:20:34 mrg Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.7 1997/04/10 00:17:10 millert Exp $";
d136 2
a137 1
			    strncasecmp(hostname, tokval, tmp-hostname) == 0 &&
d142 2
a143 1
			    strncasecmp(host, tokval, tmp - host) == 0 &&
@


1.7
log
@Sync with NetBSD (lukem)
    * support $ftp_proxy for ftp:// transfers [bin/3245]
    * add "more" & "less" as synonyms for "page"
    * move editline setup code into controlediting(), and call appropriately.
      only setup setup terminal if going into interactive mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ruserpass.c,v 1.6 1997/03/14 04:32:17 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.6 1997/03/14 04:32:17 millert Exp $";
d194 1
a194 1
				puts("Missing macdef name argument.");
d198 2
a199 2
				puts(
"Limit of 16 macros have already been defined.");
d209 2
a210 2
				puts(
"Macro definition missing null line terminator.");
d218 2
a219 2
				puts(
"Macro definition missing null line terminator.");
d232 2
a233 2
				puts(
"Macro definition missing null line terminator.");
d247 1
a247 1
				puts("4K macro buffer exceeded.");
@


1.6
log
@Sync with NetBSD and fix "get foo.txt /dev/tty" wrt progress meter
and setting times.
@
text
@d1 2
a2 2
/*	$OpenBSD: ruserpass.c,v 1.5 1997/02/03 01:05:44 millert Exp $	*/
/*	$NetBSD: ruserpass.c,v 1.12 1997/03/13 06:23:20 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.5 1997/02/03 01:05:44 millert Exp $";
@


1.5
log
@Add back ``-r'' option and fix strncpy() usage and other nits because
I'm anal.  Closer to KNF now.
@
text
@d1 2
a2 2
/*	$OpenBSD: ruserpass.c,v 1.11 1997/01/19 14:19:16 lukem Exp $	*/
/*	$NetBSD: ruserpass.c,v 1.11 1997/01/19 14:19:16 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: ruserpass.c,v 1.11 1997/01/19 14:19:16 lukem Exp $";
d199 1
a199 1
"Limit of 16 macros have already been defined");
d247 1
a247 1
				puts("4K macro buffer exceeded");
@


1.4
log
@Sync with NetBSD
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: ruserpass.c,v 1.11 1997/01/19 14:19:16 lukem Exp $";
d99 1
a99 1
		(void) sprintf(buf, "%s/.netrc", hdir);
d154 1
a154 1
					(void) strcpy(*aname, tokval);
d170 1
a170 1
				(void) strcpy(*apass, tokval);
d182 1
a182 1
				(void) strcpy(*aacct, tokval);
d187 1
a187 1
				(void) fclose(cfile);
d194 1
a194 1
				printf("Missing macdef name argument.\n");
d198 2
a199 2
				printf(
"Limit of 16 macros have already been defined\n");
d209 2
a210 2
				printf(
"Macro definition missing null line terminator.\n");
d218 2
a219 2
				printf(
"Macro definition missing null line terminator.\n");
d232 2
a233 2
				printf(
"Macro definition missing null line terminator.\n");
d247 1
a247 1
				printf("4K macro buffer exceeded\n");
d258 1
a258 1
	(void) fclose(cfile);
d261 1
a261 1
	(void) fclose(cfile);
@


1.3
log
@Safe $HOME usage.
@
text
@d1 1
a1 2
/*      $OpenBSD: ruserpass.c,v 1.2 1996/06/26 05:33:39 deraadt Exp $      */
/*      $NetBSD: ruserpass.c,v 1.6 1995/09/08 01:06:43 tls Exp $      */
d37 1
d39 3
d86 2
a87 1
	char *host, **aname, **apass, **aacct;
d97 1
a97 1
	if (strlen(hdir) + 7 < sizeof(buf)) {
d126 1
a126 1
			 * or official hostname.  Also allow match of 
d150 3
a152 2
				if (*aname == 0) { 
					*aname = malloc((unsigned) strlen(tokval) + 1);
d189 3
a191 1
			while ((c=getc(cfile)) != EOF && c == ' ' || c == '\t');
d197 2
a198 1
				printf("Limit of 16 macros have already been defined\n");
d208 2
a209 1
				printf("Macro definition missing null line terminator.\n");
d217 2
a218 1
				printf("Macro definition missing null line terminator.\n");
d225 2
a226 1
				macros[macnum].mac_start = macros[macnum-1].mac_end + 1;
d231 2
a232 1
				printf("Macro definition missing null line terminator.\n");
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*      $OpenBSD: ruserpass.c,v 1.6 1995/09/08 01:06:43 tls Exp $      */
d93 6
a98 1
	(void) sprintf(buf, "%s/.netrc", hdir);
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
