head	1.79;
access;
symbols
	OPENBSD_6_1:1.79.0.4
	OPENBSD_6_1_BASE:1.79
	OPENBSD_6_0:1.77.0.2
	OPENBSD_6_0_BASE:1.77
	OPENBSD_5_9:1.75.0.2
	OPENBSD_5_9_BASE:1.75
	OPENBSD_5_8:1.74.0.6
	OPENBSD_5_8_BASE:1.74
	OPENBSD_5_7:1.74.0.2
	OPENBSD_5_7_BASE:1.74
	OPENBSD_5_6:1.71.0.10
	OPENBSD_5_6_BASE:1.71
	OPENBSD_5_5:1.71.0.6
	OPENBSD_5_5_BASE:1.71
	OPENBSD_5_4:1.71.0.4
	OPENBSD_5_4_BASE:1.71
	OPENBSD_5_3:1.71.0.2
	OPENBSD_5_3_BASE:1.71
	OPENBSD_5_2:1.70.0.14
	OPENBSD_5_2_BASE:1.70
	OPENBSD_5_1_BASE:1.70
	OPENBSD_5_1:1.70.0.12
	OPENBSD_5_0:1.70.0.10
	OPENBSD_5_0_BASE:1.70
	OPENBSD_4_9:1.70.0.8
	OPENBSD_4_9_BASE:1.70
	OPENBSD_4_8:1.70.0.6
	OPENBSD_4_8_BASE:1.70
	OPENBSD_4_7:1.70.0.2
	OPENBSD_4_7_BASE:1.70
	OPENBSD_4_6:1.70.0.4
	OPENBSD_4_6_BASE:1.70
	OPENBSD_4_5:1.67.0.2
	OPENBSD_4_5_BASE:1.67
	OPENBSD_4_4:1.63.0.2
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.57.0.2
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.56.0.2
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.55.0.2
	OPENBSD_4_1_BASE:1.55
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.48.0.4
	OPENBSD_3_8_BASE:1.48
	OPENBSD_3_7:1.48.0.2
	OPENBSD_3_7_BASE:1.48
	OPENBSD_3_6:1.47.0.2
	OPENBSD_3_6_BASE:1.47
	OPENBSD_3_5:1.46.0.2
	OPENBSD_3_5_BASE:1.46
	OPENBSD_3_4:1.45.0.2
	OPENBSD_3_4_BASE:1.45
	OPENBSD_3_3:1.42.0.2
	OPENBSD_3_3_BASE:1.42
	OPENBSD_3_2:1.41.0.2
	OPENBSD_3_2_BASE:1.41
	OPENBSD_3_1:1.40.0.2
	OPENBSD_3_1_BASE:1.40
	OPENBSD_3_0:1.38.0.2
	OPENBSD_3_0_BASE:1.38
	OPENBSD_2_9_BASE:1.35
	OPENBSD_2_9:1.35.0.2
	OPENBSD_2_8:1.34.0.2
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.32.0.2
	OPENBSD_2_7_BASE:1.32
	OPENBSD_2_6:1.31.0.2
	OPENBSD_2_6_BASE:1.31
	OPENBSD_2_5:1.29.0.4
	OPENBSD_2_5_BASE:1.29
	OPENBSD_2_4:1.29.0.2
	OPENBSD_2_4_BASE:1.29
	OPENBSD_2_3:1.26.0.2
	OPENBSD_2_3_BASE:1.26
	OPENBSD_2_2:1.24.0.2
	OPENBSD_2_2_BASE:1.24
	OPENBSD_2_1:1.20.0.2
	OPENBSD_2_1_BASE:1.20
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.79
date	2017.01.21.08.33.07;	author krw;	state Exp;
branches;
next	1.78;
commitid	l2fu419jw6ah0BY2;

1.78
date	2016.08.14.18.34.48;	author guenther;	state Exp;
branches;
next	1.77;
commitid	PKvTittpF6Ut9SpV;

1.77
date	2016.05.25.15.36.01;	author krw;	state Exp;
branches;
next	1.76;
commitid	Fr5N4bUlPJcjeziu;

1.76
date	2016.03.17.19.40.43;	author krw;	state Exp;
branches;
next	1.75;
commitid	aCmYZrmRmWHLuztW;

1.75
date	2015.10.18.03.04.11;	author mmcc;	state Exp;
branches;
next	1.74;
commitid	QQdb0QX6CyUg58R7;

1.74
date	2015.01.30.04.45.45;	author tedu;	state Exp;
branches;
next	1.73;
commitid	AzhkSUz6nBmdvJNd;

1.73
date	2015.01.16.06.40.08;	author deraadt;	state Exp;
branches;
next	1.72;
commitid	Uu5nFG3wCl0LACBb;

1.72
date	2014.08.16.07.49.27;	author deraadt;	state Exp;
branches;
next	1.71;
commitid	VtJEhEZFfTUoD9C5;

1.71
date	2012.10.15.21.20.05;	author bluhm;	state Exp;
branches;
next	1.70;

1.70
date	2009.05.05.19.35.30;	author martynas;	state Exp;
branches;
next	1.69;

1.69
date	2009.04.27.22.51.51;	author martynas;	state Exp;
branches;
next	1.68;

1.68
date	2009.04.27.21.37.13;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2008.10.16.23.15.53;	author martynas;	state Exp;
branches;
next	1.66;

1.66
date	2008.09.18.14.45.36;	author todd;	state Exp;
branches;
next	1.65;

1.65
date	2008.09.08.19.31.16;	author martynas;	state Exp;
branches;
next	1.64;

1.64
date	2008.08.22.08.52.35;	author sobrado;	state Exp;
branches;
next	1.63;

1.63
date	2008.07.08.21.07.57;	author martynas;	state Exp;
branches;
next	1.62;

1.62
date	2008.06.25.18.07.00;	author martynas;	state Exp;
branches;
next	1.61;

1.61
date	2008.06.16.19.56.04;	author martynas;	state Exp;
branches;
next	1.60;

1.60
date	2008.06.16.12.03.51;	author martynas;	state Exp;
branches;
next	1.59;

1.59
date	2008.06.15.03.09.13;	author martynas;	state Exp;
branches;
next	1.58;

1.58
date	2008.05.13.02.09.38;	author ray;	state Exp;
branches;
next	1.57;

1.57
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.56;

1.56
date	2007.07.26.17.48.41;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.22.04.08.35;	author ray;	state Exp;
branches;
next	1.54;

1.54
date	2006.11.02.01.51.33;	author ray;	state Exp;
branches;
next	1.53;

1.53
date	2006.11.02.01.43.01;	author ray;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.19.04.05.35;	author ray;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.16.23.43.16;	author ray;	state Exp;
branches;
next	1.50;

1.50
date	2006.04.25.05.45.20;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2005.10.12.06.50.42;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2004.09.16.04.39.16;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.20.03.50.25;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.16.21.46.22;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.03.02.56.08;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2003.04.05.17.19.47;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2003.03.31.23.04.07;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.03.04.57.54;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2002.07.12.00.25.30;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2002.01.04.16.18.59;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.10.24.20.42.24;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2001.10.01.14.58.49;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.12.05.17.07;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.26.23.43.59;	author lebel;	state Exp;
branches;
next	1.35;

1.35
date	2000.12.24.00.29.00;	author aaron;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.21.19.22.54;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.13.21.28.38;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	99.12.08.12.57.06;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	99.06.29.14.33.23;	author aaron;	state Exp;
branches;
next	1.30;

1.30
date	99.06.10.22.38.02;	author pjanzen;	state Exp;
branches;
next	1.29;

1.29
date	98.09.01.17.08.22;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	98.06.08.19.48.56;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	98.06.08.16.55.56;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	98.02.10.02.13.10;	author weingart;	state Exp;
branches;
next	1.25;

1.25
date	98.02.08.21.04.16;	author weingart;	state Exp;
branches;
next	1.24;

1.24
date	97.09.10.20.55.08;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	97.09.04.04.37.13;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	97.08.30.20.48.41;	author kstailey;	state Exp;
branches;
next	1.21;

1.21
date	97.07.25.21.56.17;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	97.04.23.20.32.57;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.04.16.05.02.39;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.04.10.00.17.07;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.03.21.20.59.26;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.03.14.04.32.12;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.02.05.04.55.12;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.02.03.01.05.33;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.02.03.01.02.32;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.01.29.22.11.36;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.01.28.20.48.40;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.01.25.21.42.27;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.12.24.21.22.10;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.12.24.20.00.04;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.12.17.02.11.46;	author michaels;	state Exp;
branches;
next	1.6;

1.6
date	96.11.09.19.53.59;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.09.28.09.56.54;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.09.16.02.26.06;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.09.04.44.38;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.33.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.17;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.79
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: cmds.c,v 1.78 2016/08/14 18:34:48 guenther Exp $	*/
/*	$NetBSD: cmds.c,v 1.27 1997/08/18 10:20:15 lukem Exp $	*/

/*
 * Copyright (C) 1997 and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1985, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef SMALL

/*
 * FTP User Program -- Command Routines.
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <arpa/ftp.h>

#include <ctype.h>
#include <err.h>
#include <fnmatch.h>
#include <glob.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include "ftp_var.h"
#include "pathnames.h"
#include "cmds.h"

/*
 * Set ascii transfer type.
 */
/*ARGSUSED*/
void
setascii(int argc, char *argv[])
{

	stype[1] = "ascii";
	settype(2, stype);
}

/*
 * Set file transfer mode.
 */
/*ARGSUSED*/
void
setftmode(int argc, char *argv[])
{

	fprintf(ttyout, "We only support %s mode, sorry.\n", modename);
	code = -1;
}

/*
 * Set file transfer format.
 */
/*ARGSUSED*/
void
setform(int argc, char *argv[])
{

	fprintf(ttyout, "We only support %s format, sorry.\n", formname);
	code = -1;
}

/*
 * Set file transfer structure.
 */
/*ARGSUSED*/
void
setstruct(int argc, char *argv[])
{

	fprintf(ttyout, "We only support %s structure, sorry.\n", structname);
	code = -1;
}

void
reput(int argc, char *argv[])
{

	(void)putit(argc, argv, 1);
}

void
put(int argc, char *argv[])
{

	(void)putit(argc, argv, 0);
}

/*
 * Send a single file.
 */
void
putit(int argc, char *argv[], int restartit)
{
	char *cmd;
	int loc = 0;
	char *oldargv1, *oldargv2;

	if (argc == 2) {
		argc++;
		argv[2] = argv[1];
		loc++;
	}
	if (argc < 2 && !another(&argc, &argv, "local-file"))
		goto usage;
	if ((argc < 3 && !another(&argc, &argv, "remote-file")) || argc > 3) {
usage:
		fprintf(ttyout, "usage: %s local-file [remote-file]\n",
		    argv[0]);
		code = -1;
		return;
	}
	oldargv1 = argv[1];
	oldargv2 = argv[2];
	if (!globulize(&argv[1])) {
		code = -1;
		return;
	}
	/*
	 * If "globulize" modifies argv[1], and argv[2] is a copy of
	 * the old argv[1], make it a copy of the new argv[1].
	 */
	if (argv[1] != oldargv1 && argv[2] == oldargv1) {
		argv[2] = argv[1];
	}
	if (restartit == 1) {
		if (curtype != type)
			changetype(type, 0);
		restart_point = remotesize(argv[2], 1);
		if (restart_point < 0) {
			restart_point = 0;
			code = -1;
			return;
		}
	}
	if (strcmp(argv[0], "append") == 0) {
		restartit = 1;
	}
	cmd = restartit ? "APPE" : ((sunique) ? "STOU" : "STOR");
	if (loc && ntflag) {
		argv[2] = dotrans(argv[2]);
	}
	if (loc && mapflag) {
		argv[2] = domap(argv[2]);
	}
	sendrequest(cmd, argv[1], argv[2],
	    argv[1] != oldargv1 || argv[2] != oldargv2);
	restart_point = 0;
	if (oldargv1 != argv[1])	/* free up after globulize() */
		free(argv[1]);
}

/*
 * Send multiple files.
 */
void
mput(int argc, char *argv[])
{
	extern int optind, optreset;
	int ch, i, restartit = 0;
	sig_t oldintr;
	char *cmd, *tp, *xargv[] = { argv[0], NULL, NULL };
	const char *errstr;
	static int depth = 0, max_depth = 0;

	optind = optreset = 1;

	if (depth)
		depth++;

	while ((ch = getopt(argc, argv, "cd:r")) != -1) {
		switch(ch) {
		case 'c':
			restartit = 1;
			break;
		case 'd':
			max_depth = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr != NULL) {
				fprintf(ttyout, "bad depth value, %s: %s\n",
				    errstr, optarg);
				code = -1;
				return;
			}
			break;
		case 'r':
			depth = 1;
			break;
		default:
			goto usage;
		}
	}

	if (argc - optind < 1 && !another(&argc, &argv, "local-files")) {
usage:
		fprintf(ttyout, "usage: %s [-cr] [-d depth] local-files\n",
		    argv[0]);
		code = -1;
		return;
	}

	argv[optind - 1] = argv[0];
	argc -= optind - 1;
	argv += optind - 1;

	mname = argv[0];
	mflag = 1;

	oldintr = signal(SIGINT, mabort);
	(void)setjmp(jabort);
	if (proxy) {
		char *cp, *tp2, tmpbuf[PATH_MAX];

		while ((cp = remglob(argv, 0, NULL)) != NULL) {
			if (*cp == '\0') {
				mflag = 0;
				continue;
			}
			if (mflag && confirm(argv[0], cp)) {
				tp = cp;
				if (mcase) {
					while (*tp && !islower((unsigned char)*tp)) {
						tp++;
					}
					if (!*tp) {
						tp = cp;
						tp2 = tmpbuf;
						while ((*tp2 = *tp) != '\0') {
						     if (isupper((unsigned char)*tp2)) {
							    *tp2 =
								tolower((unsigned char)*tp2);
						     }
						     tp++;
						     tp2++;
						}
					}
					tp = tmpbuf;
				}
				if (ntflag) {
					tp = dotrans(tp);
				}
				if (mapflag) {
					tp = domap(tp);
				}
				if (restartit == 1) {
					off_t ret;

					if (curtype != type)
						changetype(type, 0);
					ret = remotesize(tp, 0);
					restart_point = (ret < 0) ? 0 : ret;
				}
				cmd = restartit ? "APPE" : ((sunique) ?
				    "STOU" : "STOR");
				sendrequest(cmd, cp, tp,
				    cp != tp || !interactive);
				restart_point = 0;
				if (!mflag && fromatty) {
					if (confirm(argv[0], NULL))
						mflag = 1;
				}
			}
		}
		(void)signal(SIGINT, oldintr);
		mflag = 0;
		return;
	}

	for (i = 1; i < argc; i++) {
		char **cpp;
		glob_t gl;
		int flags;

		/* Copy files without word expansion */
		if (!doglob) {
			if (mflag && confirm(argv[0], argv[i])) {
				tp = (ntflag) ? dotrans(argv[i]) : argv[i];
				tp = (mapflag) ? domap(tp) : tp;
				if (restartit == 1) {
					off_t ret;

					if (curtype != type)
						changetype(type, 0);
					ret = remotesize(tp, 0);
					restart_point = (ret < 0) ? 0 : ret;
				}
				cmd = restartit ? "APPE" : ((sunique) ?
				    "STOU" : "STOR");
				sendrequest(cmd, argv[i], tp,
				    tp != argv[i] || !interactive);
				restart_point = 0;
				if (!mflag && fromatty) {
					if (confirm(argv[0], NULL))
						mflag = 1;
				}
			}
			continue;
		}

		/* expanding file names */
		memset(&gl, 0, sizeof(gl));
		flags = GLOB_BRACE|GLOB_NOCHECK|GLOB_QUOTE|GLOB_TILDE;
		if (glob(argv[i], flags, NULL, &gl) || gl.gl_pathc == 0) {
			warnx("%s: not found", argv[i]);
			globfree(&gl);
			continue;
		}

		/* traverse all expanded file names */
		for (cpp = gl.gl_pathv; cpp && *cpp != NULL; cpp++) {
			struct stat filestat;

			if (!mflag)
				continue;
			if (stat(*cpp, &filestat) != 0) {
				warn("local: %s", *cpp);
				continue;
			}
			if (S_ISDIR(filestat.st_mode) && depth == max_depth)
				continue;
			if (!confirm(argv[0], *cpp))
				continue;

			/*
			 * If file is a directory then create a new one
			 * at the remote machine.
			 */
			if (S_ISDIR(filestat.st_mode)) {
				xargv[1] = *cpp;
				makedir(2, xargv);
				cd(2, xargv);
				if (dirchange != 1) {
					warnx("remote: %s", *cpp);
					continue;
				}

				if (chdir(*cpp) != 0) {
					warn("local: %s", *cpp);
					goto out;
				}

				/* Copy the whole directory recursively. */
				xargv[1] = "*";
				mput(2, xargv);

				if (chdir("..") != 0) {
					mflag = 0;
					warn("local: %s", *cpp);
					goto out;
				}

 out:
				xargv[1] = "..";
				cd(2, xargv);
				if (dirchange != 1) {
					warnx("remote: %s", *cpp);
					mflag = 0;
				}
				continue;
			}

			tp = (ntflag) ? dotrans(*cpp) : *cpp;
			tp = (mapflag) ? domap(tp) : tp;
			if (restartit == 1) {
				off_t ret;

				if (curtype != type)
					changetype(type, 0);
				ret = remotesize(tp, 0);
				restart_point = (ret < 0) ? 0 : ret;
			}
			cmd = restartit ? "APPE" : ((sunique) ?
			    "STOU" : "STOR");
			sendrequest(cmd, *cpp, tp,
			    *cpp != tp || !interactive);
			restart_point = 0;
			if (!mflag && fromatty) {
				if (confirm(argv[0], NULL))
					mflag = 1;
			}
		}
		globfree(&gl);
	}

	(void)signal(SIGINT, oldintr);

	if (depth)
		depth--;
	if (depth == 0 || mflag == 0)
		depth = max_depth = mflag = 0;
}

void
reget(int argc, char *argv[])
{

	(void)getit(argc, argv, 1, "a+w");
}

char *
onoff(int bool)
{

	return (bool ? "on" : "off");
}

/*
 * Show status.
 */
/*ARGSUSED*/
void
status(int argc, char *argv[])
{
	int i;

	if (connected)
		fprintf(ttyout, "Connected %sto %s.\n",
		    connected == -1 ? "and logged in" : "", hostname);
	else
		fputs("Not connected.\n", ttyout);
	if (!proxy) {
		pswitch(1);
		if (connected) {
			fprintf(ttyout, "Connected for proxy commands to %s.\n",
			    hostname);
		}
		else {
			fputs("No proxy connection.\n", ttyout);
		}
		pswitch(0);
	}
	fprintf(ttyout, "Gate ftp: %s, server %s, port %s.\n", onoff(gatemode),
	    *gateserver ? gateserver : "(none)", gateport);
	fprintf(ttyout, "Passive mode: %s.\n", onoff(passivemode));
	fprintf(ttyout, "Mode: %s; Type: %s; Form: %s; Structure: %s.\n",
		modename, typename, formname, structname);
	fprintf(ttyout, "Verbose: %s; Bell: %s; Prompting: %s; Globbing: %s.\n",
		onoff(verbose), onoff(bell), onoff(interactive),
		onoff(doglob));
	fprintf(ttyout, "Store unique: %s; Receive unique: %s.\n", onoff(sunique),
		onoff(runique));
	fprintf(ttyout, "Preserve modification times: %s.\n", onoff(preserve));
	fprintf(ttyout, "Case: %s; CR stripping: %s.\n", onoff(mcase), onoff(crflag));
	if (ntflag) {
		fprintf(ttyout, "Ntrans: (in) %s (out) %s\n", ntin, ntout);
	}
	else {
		fputs("Ntrans: off.\n", ttyout);
	}
	if (mapflag) {
		fprintf(ttyout, "Nmap: (in) %s (out) %s\n", mapin, mapout);
	}
	else {
		fputs("Nmap: off.\n", ttyout);
	}
	fprintf(ttyout, "Hash mark printing: %s; Mark count: %d; Progress bar: %s.\n",
	    onoff(hash), mark, onoff(progress));
	fprintf(ttyout, "Use of PORT/LPRT cmds: %s.\n", onoff(sendport));
	fprintf(ttyout, "Use of EPSV/EPRT cmds for IPv4: %s%s.\n", onoff(epsv4),
	    epsv4bad ? " (disabled for this connection)" : "");
	fprintf(ttyout, "Command line editing: %s.\n", onoff(editing));
	if (macnum > 0) {
		fputs("Macros:\n", ttyout);
		for (i=0; i<macnum; i++) {
			fprintf(ttyout, "\t%s\n", macros[i].mac_name);
		}
	}
	code = 0;
}

/*
 * Toggle a variable
 */
int
togglevar(int argc, char *argv[], int *var, const char *mesg)
{
	if (argc < 2) {
		*var = !*var;
	} else if (argc == 2 && strcasecmp(argv[1], "on") == 0) {
		*var = 1;
	} else if (argc == 2 && strcasecmp(argv[1], "off") == 0) {
		*var = 0;
	} else {
		fprintf(ttyout, "usage: %s [on | off]\n", argv[0]);
		return (-1);
	}
	if (mesg)
		fprintf(ttyout, "%s %s.\n", mesg, onoff(*var));
	return (*var);
}

/*
 * Set beep on cmd completed mode.
 */
/*ARGSUSED*/
void
setbell(int argc, char *argv[])
{

	code = togglevar(argc, argv, &bell, "Bell mode");
}

/*
 * Set command line editing
 */
/*ARGSUSED*/
void
setedit(int argc, char *argv[])
{

	code = togglevar(argc, argv, &editing, "Editing mode");
	controlediting();
}

/*
 * Toggle use of IPv4 EPSV/EPRT
 */
/*ARGSUSED*/
void
setepsv4(int argc, char *argv[])
{

	code = togglevar(argc, argv, &epsv4, "EPSV/EPRT on IPv4");
	epsv4bad = 0;
}

/*
 * Turn on packet tracing.
 */
/*ARGSUSED*/
void
settrace(int argc, char *argv[])
{

	code = togglevar(argc, argv, &trace, "Packet tracing");
}

/*
 * Toggle hash mark printing during transfers, or set hash mark bytecount.
 */
/*ARGSUSED*/
void
sethash(int argc, char *argv[])
{
	if (argc == 1)
		hash = !hash;
	else if (argc != 2) {
		fprintf(ttyout, "usage: %s [on | off | size]\n", argv[0]);
		code = -1;
		return;
	} else if (strcasecmp(argv[1], "on") == 0)
		hash = 1;
	else if (strcasecmp(argv[1], "off") == 0)
		hash = 0;
	else {
		int nmark;
		const char *errstr;

		nmark = strtonum(argv[1], 1, INT_MAX, &errstr);
		if (errstr) {
			fprintf(ttyout, "bytecount value is %s: %s\n",
			    errstr, argv[1]);
			code = -1;
			return;
		}
		mark = nmark;
		hash = 1;
	}
	fprintf(ttyout, "Hash mark printing %s", onoff(hash));
	if (hash)
		fprintf(ttyout, " (%d bytes/hash mark)", mark);
	fputs(".\n", ttyout);
	code = hash;
}

/*
 * Turn on printing of server echo's.
 */
/*ARGSUSED*/
void
setverbose(int argc, char *argv[])
{

	code = togglevar(argc, argv, &verbose, "Verbose mode");
}

/*
 * Toggle PORT/LPRT cmd use before each data connection.
 */
/*ARGSUSED*/
void
setport(int argc, char *argv[])
{

	code = togglevar(argc, argv, &sendport, "Use of PORT/LPRT cmds");
}

/*
 * Toggle transfer progress bar.
 */
/*ARGSUSED*/
void
setprogress(int argc, char *argv[])
{

	code = togglevar(argc, argv, &progress, "Progress bar");
}

/*
 * Turn on interactive prompting during mget, mput, and mdelete.
 */
/*ARGSUSED*/
void
setprompt(int argc, char *argv[])
{

	code = togglevar(argc, argv, &interactive, "Interactive mode");
}

/*
 * Toggle gate-ftp mode, or set gate-ftp server
 */
/*ARGSUSED*/
void
setgate(int argc, char *argv[])
{
	static char gsbuf[HOST_NAME_MAX+1];

	if (argc > 3) {
		fprintf(ttyout, "usage: %s [on | off | host [port]]\n",
		    argv[0]);
		code = -1;
		return;
	} else if (argc < 2) {
		gatemode = !gatemode;
	} else {
		if (argc == 2 && strcasecmp(argv[1], "on") == 0)
			gatemode = 1;
		else if (argc == 2 && strcasecmp(argv[1], "off") == 0)
			gatemode = 0;
		else {
			if (argc == 3) {
				gateport = strdup(argv[2]);
				if (gateport == NULL)
					err(1, NULL);
			}
			strlcpy(gsbuf, argv[1], sizeof(gsbuf));
			gateserver = gsbuf;
			gatemode = 1;
		}
	}
	if (gatemode && (gateserver == NULL || *gateserver == '\0')) {
		fprintf(ttyout,
		    "Disabling gate-ftp mode - no gate-ftp server defined.\n");
		gatemode = 0;
	} else {
		fprintf(ttyout, "Gate ftp: %s, server %s, port %s.\n",
		    onoff(gatemode),
		    *gateserver ? gateserver : "(none)", gateport);
	}
	code = gatemode;
}

/*
 * Toggle metacharacter interpretation on local file names.
 */
/*ARGSUSED*/
void
setglob(int argc, char *argv[])
{

	code = togglevar(argc, argv, &doglob, "Globbing");
}

/*
 * Toggle preserving modification times on retrieved files.
 */
/*ARGSUSED*/
void
setpreserve(int argc, char *argv[])
{

	code = togglevar(argc, argv, &preserve, "Preserve modification times");
}

/*
 * Set debugging mode on/off and/or set level of debugging.
 */
/*ARGSUSED*/
void
setdebug(int argc, char *argv[])
{
	if (argc > 2) {
		fprintf(ttyout, "usage: %s [on | off | debuglevel]\n", argv[0]);
		code = -1;
		return;
	} else if (argc == 2) {
		if (strcasecmp(argv[1], "on") == 0)
			debug = 1;
		else if (strcasecmp(argv[1], "off") == 0)
			debug = 0;
		else {
			const char *errstr;
			int val;

			val = strtonum(argv[1], 0, INT_MAX, &errstr);
			if (errstr) {
				fprintf(ttyout, "debugging value is %s: %s\n",
				    errstr, argv[1]);
				code = -1;
				return;
			}
			debug = val;
		}
	} else
		debug = !debug;
	if (debug)
		options |= SO_DEBUG;
	else
		options &= ~SO_DEBUG;
	fprintf(ttyout, "Debugging %s (debug=%d).\n", onoff(debug), debug);
	code = debug > 0;
}

/*
 * Set current working directory on local machine.
 */
void
lcd(int argc, char *argv[])
{
	char buf[PATH_MAX];
	char *oldargv1;

	if (argc < 2)
		argc++, argv[1] = home;
	if (argc != 2) {
		fprintf(ttyout, "usage: %s [local-directory]\n", argv[0]);
		code = -1;
		return;
	}
	oldargv1 = argv[1];
	if (!globulize(&argv[1])) {
		code = -1;
		return;
	}
	if (chdir(argv[1]) < 0) {
		warn("local: %s", argv[1]);
		code = -1;
	} else {
		if (getcwd(buf, sizeof(buf)) != NULL)
			fprintf(ttyout, "Local directory now %s\n", buf);
		else
			warn("getcwd: %s", argv[1]);
		code = 0;
	}
	if (oldargv1 != argv[1])	/* free up after globulize() */
		free(argv[1]);
}

/*
 * Delete a single file.
 */
void
deletecmd(int argc, char *argv[])
{

	if ((argc < 2 && !another(&argc, &argv, "remote-file")) || argc > 2) {
		fprintf(ttyout, "usage: %s remote-file\n", argv[0]);
		code = -1;
		return;
	}
	(void)command("DELE %s", argv[1]);
}

/*
 * Delete multiple files.
 */
void
mdelete(int argc, char *argv[])
{
	sig_t oldintr;
	char *cp;

	if (argc < 2 && !another(&argc, &argv, "remote-files")) {
		fprintf(ttyout, "usage: %s remote-files\n", argv[0]);
		code = -1;
		return;
	}
	mname = argv[0];
	mflag = 1;
	oldintr = signal(SIGINT, mabort);
	(void)setjmp(jabort);
	while ((cp = remglob(argv, 0, NULL)) != NULL) {
		if (*cp == '\0') {
			mflag = 0;
			continue;
		}
		if (mflag && confirm(argv[0], cp)) {
			(void)command("DELE %s", cp);
			if (!mflag && fromatty) {
				if (confirm(argv[0], NULL))
					mflag = 1;
			}
		}
	}
	(void)signal(SIGINT, oldintr);
	mflag = 0;
}

/*
 * Rename a remote file.
 */
void
renamefile(int argc, char *argv[])
{

	if (argc < 2 && !another(&argc, &argv, "from-name"))
		goto usage;
	if ((argc < 3 && !another(&argc, &argv, "to-name")) || argc > 3) {
usage:
		fprintf(ttyout, "usage: %s from-name to-name\n", argv[0]);
		code = -1;
		return;
	}
	if (command("RNFR %s", argv[1]) == CONTINUE)
		(void)command("RNTO %s", argv[2]);
}

/*
 * Get a directory listing of remote files.
 */
void
ls(int argc, char *argv[])
{
	const char *cmd;
	char *oldargv2, *globargv2;

	if (argc < 2)
		argc++, argv[1] = NULL;
	if (argc < 3)
		argc++, argv[2] = "-";
	if (argc > 3) {
		fprintf(ttyout, "usage: %s [remote-directory [local-file]]\n",
		    argv[0]);
		code = -1;
		return;
	}
	cmd = strcmp(argv[0], "nlist") == 0 ? "NLST" : "LIST";
	oldargv2 = argv[2];
	if (strcmp(argv[2], "-") && !globulize(&argv[2])) {
		code = -1;
		return;
	}
	globargv2 = argv[2];
	if (strcmp(argv[2], "-") && *argv[2] != '|' && (!globulize(&argv[2]) ||
	    !confirm("output to local-file:", argv[2]))) {
		code = -1;
		goto freels;
	}
	recvrequest(cmd, argv[2], argv[1], "w", 0, 0);

	/* flush results in case commands are coming from a pipe */
	fflush(ttyout);
freels:
	if (argv[2] != globargv2)		/* free up after globulize() */
		free(argv[2]);
	if (globargv2 != oldargv2)
		free(globargv2);
}

/*
 * Get a directory listing of multiple remote files.
 */
void
mls(int argc, char *argv[])
{
	sig_t oldintr;
	int i;
	char lmode[1], *dest, *odest;

	if (argc < 2 && !another(&argc, &argv, "remote-files"))
		goto usage;
	if (argc < 3 && !another(&argc, &argv, "local-file")) {
usage:
		fprintf(ttyout, "usage: %s remote-files local-file\n", argv[0]);
		code = -1;
		return;
	}
	odest = dest = argv[argc - 1];
	argv[argc - 1] = NULL;
	if (strcmp(dest, "-") && *dest != '|')
		if (!globulize(&dest) ||
		    !confirm("output to local-file:", dest)) {
			code = -1;
			return;
	}
	mname = argv[0];
	mflag = 1;
	oldintr = signal(SIGINT, mabort);
	(void)setjmp(jabort);
	for (i = 1; mflag && i < argc-1; ++i) {
		*lmode = (i == 1) ? 'w' : 'a';
		recvrequest("LIST", dest, argv[i], lmode, 0, 0);
		if (!mflag && fromatty) {
			if (confirm(argv[0], NULL))
				mflag ++;
		}
	}
	(void)signal(SIGINT, oldintr);
	mflag = 0;
	if (dest != odest)			/* free up after globulize() */
		free(dest);
}

/*
 * Do a shell escape
 */
/*ARGSUSED*/
void
shell(int argc, char *argv[])
{
	pid_t pid;
	sig_t old1, old2;
	char shellnam[PATH_MAX], *shellp, *namep;
	int wait_status;

	old1 = signal (SIGINT, SIG_IGN);
	old2 = signal (SIGQUIT, SIG_IGN);
	if ((pid = fork()) == 0) {
		for (pid = 3; pid < 20; pid++)
			(void)close(pid);
		(void)signal(SIGINT, SIG_DFL);
		(void)signal(SIGQUIT, SIG_DFL);
		shellp = getenv("SHELL");
		if (shellp == NULL || *shellp == '\0')
			shellp = _PATH_BSHELL;
		namep = strrchr(shellp, '/');
		if (namep == NULL)
			namep = shellp;
		shellnam[0] = '-';
		(void)strlcpy(shellnam + 1, ++namep, sizeof(shellnam) - 1);
		if (strcmp(namep, "sh") != 0)
			shellnam[0] = '+';
		if (debug) {
			fputs(shellp, ttyout);
			fputc('\n', ttyout);
			(void)fflush(ttyout);
		}
		if (argc > 1) {
			execl(shellp, shellnam, "-c", altarg, (char *)NULL);
		}
		else {
			execl(shellp, shellnam, (char *)NULL);
		}
		warn("%s", shellp);
		code = -1;
		exit(1);
	}
	if (pid > 0)
		while (wait(&wait_status) != pid)
			;
	(void)signal(SIGINT, old1);
	(void)signal(SIGQUIT, old2);
	if (pid == -1) {
		warn("Try again later");
		code = -1;
	}
	else {
		code = 0;
	}
}

/*
 * Send new user information (re-login)
 */
void
user(int argc, char *argv[])
{
	char acctname[80];
	int n, aflag = 0;

	if (argc < 2)
		(void)another(&argc, &argv, "username");
	if (argc < 2 || argc > 4) {
		fprintf(ttyout, "usage: %s username [password [account]]\n",
		    argv[0]);
		code = -1;
		return;
	}
	n = command("USER %s", argv[1]);
	if (n == CONTINUE) {
		if (argc < 3 )
			argv[2] = getpass("Password:"), argc++;
		n = command("PASS %s", argv[2]);
	}
	if (n == CONTINUE) {
		if (argc < 4) {
			(void)fputs("Account: ", ttyout);
			(void)fflush(ttyout);
			if (fgets(acctname, sizeof(acctname), stdin) == NULL) {
				clearerr(stdin);
				goto fail;
			}

			acctname[strcspn(acctname, "\n")] = '\0';

			argv[3] = acctname;
			argc++;
		}
		n = command("ACCT %s", argv[3]);
		aflag++;
	}
	if (n != COMPLETE) {
 fail:
		fputs("Login failed.\n", ttyout);
		return;
	}
	if (!aflag && argc == 4) {
		(void)command("ACCT %s", argv[3]);
	}
	connected = -1;
}

/*
 * Print working directory on remote machine.
 */
/*ARGSUSED*/
void
pwd(int argc, char *argv[])
{
	int oldverbose = verbose;

	/*
	 * If we aren't verbose, this doesn't do anything!
	 */
	verbose = 1;
	if (command("PWD") == ERROR && code == 500) {
		fputs("PWD command not recognized, trying XPWD.\n", ttyout);
		(void)command("XPWD");
	}
	verbose = oldverbose;
}

/*
 * Print working directory on local machine.
 */
/* ARGSUSED */
void
lpwd(int argc, char *argv[])
{
	char buf[PATH_MAX];

	if (getcwd(buf, sizeof(buf)) != NULL)
		fprintf(ttyout, "Local directory %s\n", buf);
	else
		warn("getcwd");
	code = 0;
}

/*
 * Make a directory.
 */
void
makedir(int argc, char *argv[])
{

	if ((argc < 2 && !another(&argc, &argv, "directory-name")) ||
	    argc > 2) {
		fprintf(ttyout, "usage: %s directory-name\n", argv[0]);
		code = -1;
		return;
	}
	if (command("MKD %s", argv[1]) == ERROR && code == 500) {
		if (verbose)
			fputs("MKD command not recognized, trying XMKD.\n", ttyout);
		(void)command("XMKD %s", argv[1]);
	}
}

/*
 * Remove a directory.
 */
void
removedir(int argc, char *argv[])
{

	if ((argc < 2 && !another(&argc, &argv, "directory-name")) ||
	    argc > 2) {
		fprintf(ttyout, "usage: %s directory-name\n", argv[0]);
		code = -1;
		return;
	}
	if (command("RMD %s", argv[1]) == ERROR && code == 500) {
		if (verbose)
			fputs("RMD command not recognized, trying XRMD.\n", ttyout);
		(void)command("XRMD %s", argv[1]);
	}
}

/*
 * Send a line, verbatim, to the remote machine.
 */
void
quote(int argc, char *argv[])
{

	if (argc < 2 && !another(&argc, &argv, "command line to send")) {
		fprintf(ttyout, "usage: %s arg ...\n", argv[0]);
		code = -1;
		return;
	}
	quote1("", argc, argv);
}

/*
 * Send a SITE command to the remote machine.  The line
 * is sent verbatim to the remote machine, except that the
 * word "SITE" is added at the front.
 */
void
site(int argc, char *argv[])
{

	if (argc < 2 && !another(&argc, &argv, "arguments to SITE command")) {
		fprintf(ttyout, "usage: %s arg ...\n", argv[0]);
		code = -1;
		return;
	}
	quote1("SITE", argc, argv);
}

/*
 * Turn argv[1..argc) into a space-separated string, then prepend initial text.
 * Send the result as a one-line command and get response.
 */
void
quote1(const char *initial, int argc, char *argv[])
{
	int i, len;
	char buf[BUFSIZ];		/* must be >= sizeof(line) */

	(void)strlcpy(buf, initial, sizeof(buf));
	if (argc > 1) {
		for (i = 1, len = strlen(buf); i < argc && len < sizeof(buf)-1; i++) {
			/* Space for next arg */
			if (len > 1)
				buf[len++] = ' ';

			/* Sanity check */
			if (len >= sizeof(buf) - 1)
				break;

			/* Copy next argument, NUL terminate always */
			strlcpy(&buf[len], argv[i], sizeof(buf) - len);

			/* Update string length */
			len = strlen(buf);
		}
	}

	/* Make double (triple?) sure the sucker is NUL terminated */
	buf[sizeof(buf) - 1] = '\0';

	if (command("%s", buf) == PRELIM) {
		while (getreply(0) == PRELIM)
			continue;
	}
}

void
do_chmod(int argc, char *argv[])
{

	if (argc < 2 && !another(&argc, &argv, "mode"))
		goto usage;
	if ((argc < 3 && !another(&argc, &argv, "file")) || argc > 3) {
usage:
		fprintf(ttyout, "usage: %s mode file\n", argv[0]);
		code = -1;
		return;
	}
	(void)command("SITE CHMOD %s %s", argv[1], argv[2]);
}

void
do_umask(int argc, char *argv[])
{
	int oldverbose = verbose;

	verbose = 1;
	(void)command(argc == 1 ? "SITE UMASK" : "SITE UMASK %s", argv[1]);
	verbose = oldverbose;
}

void
idle(int argc, char *argv[])
{
	int oldverbose = verbose;

	verbose = 1;
	(void)command(argc == 1 ? "SITE IDLE" : "SITE IDLE %s", argv[1]);
	verbose = oldverbose;
}

/*
 * Ask the other side for help.
 */
void
rmthelp(int argc, char *argv[])
{
	int oldverbose = verbose;

	verbose = 1;
	(void)command(argc == 1 ? "HELP" : "HELP %s", argv[1]);
	verbose = oldverbose;
}

/*
 * Terminate session and exit.
 */
/*ARGSUSED*/
void
quit(int argc, char *argv[])
{

	if (connected)
		disconnect(0, 0);
	pswitch(1);
	if (connected) {
		disconnect(0, 0);
	}
	exit(0);
}

void
account(int argc, char *argv[])
{
	char *ap;

	if (argc > 2) {
		fprintf(ttyout, "usage: %s [password]\n", argv[0]);
		code = -1;
		return;
	}
	else if (argc == 2)
		ap = argv[1];
	else
		ap = getpass("Account:");
	(void)command("ACCT %s", ap);
}

jmp_buf abortprox;

/* ARGSUSED */
void
proxabort(int signo)
{
	int save_errno = errno;

	alarmtimer(0);
	if (!proxy) {
		pswitch(1);
	}
	if (connected) {
		proxflag = 1;
	}
	else {
		proxflag = 0;
	}
	pswitch(0);
	errno = save_errno;
	longjmp(abortprox, 1);
}

void
doproxy(int argc, char *argv[])
{
	struct cmd *c;
	int cmdpos;
	sig_t oldintr;

	if (argc < 2 && !another(&argc, &argv, "command")) {
		fprintf(ttyout, "usage: %s command\n", argv[0]);
		code = -1;
		return;
	}
	c = getcmd(argv[1]);
	if (c == (struct cmd *) -1) {
		fputs("?Ambiguous command.\n", ttyout);
		(void)fflush(ttyout);
		code = -1;
		return;
	}
	if (c == 0) {
		fputs("?Invalid command.\n", ttyout);
		(void)fflush(ttyout);
		code = -1;
		return;
	}
	if (!c->c_proxy) {
		fputs("?Invalid proxy command.\n", ttyout);
		(void)fflush(ttyout);
		code = -1;
		return;
	}
	if (setjmp(abortprox)) {
		code = -1;
		return;
	}
	oldintr = signal(SIGINT, proxabort);
	pswitch(1);
	if (c->c_conn && !connected) {
		fputs("Not connected.\n", ttyout);
		(void)fflush(ttyout);
		pswitch(0);
		(void)signal(SIGINT, oldintr);
		code = -1;
		return;
	}
	cmdpos = strcspn(line, " \t");
	if (cmdpos > 0)		/* remove leading "proxy " from input buffer */
		memmove(line, line + cmdpos + 1, strlen(line) - cmdpos + 1);
	(*c->c_handler)(argc-1, argv+1);
	if (connected) {
		proxflag = 1;
	}
	else {
		proxflag = 0;
	}
	pswitch(0);
	(void)signal(SIGINT, oldintr);
}

void
setcase(int argc, char *argv[])
{

	code = togglevar(argc, argv, &mcase, "Case mapping");
}

void
setcr(int argc, char *argv[])
{

	code = togglevar(argc, argv, &crflag, "Carriage Return stripping");
}

void
setntrans(int argc, char *argv[])
{
	if (argc == 1) {
		ntflag = 0;
		fputs("Ntrans off.\n", ttyout);
		code = ntflag;
		return;
	}
	ntflag++;
	code = ntflag;
	(void)strlcpy(ntin, argv[1], sizeof(ntin));
	if (argc == 2) {
		ntout[0] = '\0';
		return;
	}
	(void)strlcpy(ntout, argv[2], sizeof(ntout));
}

void
setnmap(int argc, char *argv[])
{
	char *cp;

	if (argc == 1) {
		mapflag = 0;
		fputs("Nmap off.\n", ttyout);
		code = mapflag;
		return;
	}
	if ((argc < 3 && !another(&argc, &argv, "outpattern")) || argc > 3) {
		fprintf(ttyout, "usage: %s [inpattern outpattern]\n", argv[0]);
		code = -1;
		return;
	}
	mapflag = 1;
	code = 1;
	cp = strchr(altarg, ' ');
	if (proxy) {
		while(*++cp == ' ')
			continue;
		altarg = cp;
		cp = strchr(altarg, ' ');
	}
	*cp = '\0';
	(void)strncpy(mapin, altarg, PATH_MAX - 1);
	while (*++cp == ' ')
		continue;
	(void)strncpy(mapout, cp, PATH_MAX - 1);
}

void
setpassive(int argc, char *argv[])
{

	code = togglevar(argc, argv, &passivemode,
	    verbose ? "Passive mode" : NULL);
}

void
setsunique(int argc, char *argv[])
{

	code = togglevar(argc, argv, &sunique, "Store unique");
}

void
setrunique(int argc, char *argv[])
{

	code = togglevar(argc, argv, &runique, "Receive unique");
}

/* change directory to parent directory */
/* ARGSUSED */
void
cdup(int argc, char *argv[])
{
	int r;

	r = command("CDUP");
	if (r == ERROR && code == 500) {
		if (verbose)
			fputs("CDUP command not recognized, trying XCUP.\n", ttyout);
		r = command("XCUP");
	}
	if (r == COMPLETE)
		dirchange = 1;
}

/*
 * Restart transfer at specific point
 */
void
restart(int argc, char *argv[])
{
	off_t nrestart_point;
	char *ep;

	if (argc != 2)
		fputs("restart: offset not specified.\n", ttyout);
	else {
		nrestart_point = strtoll(argv[1], &ep, 10);
		if (nrestart_point == LLONG_MAX || *ep != '\0')
			fputs("restart: invalid offset.\n", ttyout);
		else {
			fprintf(ttyout, "Restarting at %lld. Execute get, put "
				"or append to initiate transfer\n",
				(long long)nrestart_point);
			restart_point = nrestart_point;
		}
	}
}

/*
 * Show remote system type
 */
/* ARGSUSED */
void
syst(int argc, char *argv[])
{

	(void)command("SYST");
}

void
macdef(int argc, char *argv[])
{
	char *tmp;
	int c;

	if (macnum == 16) {
		fputs("Limit of 16 macros have already been defined.\n", ttyout);
		code = -1;
		return;
	}
	if ((argc < 2 && !another(&argc, &argv, "macro-name")) || argc > 2) {
		fprintf(ttyout, "usage: %s macro-name\n", argv[0]);
		code = -1;
		return;
	}
	if (interactive)
		fputs(
"Enter macro line by line, terminating it with a null line.\n", ttyout);
	(void)strlcpy(macros[macnum].mac_name, argv[1],
	    sizeof(macros[macnum].mac_name));
	if (macnum == 0)
		macros[macnum].mac_start = macbuf;
	else
		macros[macnum].mac_start = macros[macnum - 1].mac_end + 1;
	tmp = macros[macnum].mac_start;
	while (tmp != macbuf+4096) {
		if ((c = getchar()) == EOF) {
			fputs("macdef: end of file encountered.\n", ttyout);
			code = -1;
			return;
		}
		if ((*tmp = c) == '\n') {
			if (tmp == macros[macnum].mac_start) {
				macros[macnum++].mac_end = tmp;
				code = 0;
				return;
			}
			if (*(tmp-1) == '\0') {
				macros[macnum++].mac_end = tmp - 1;
				code = 0;
				return;
			}
			*tmp = '\0';
		}
		tmp++;
	}
	while (1) {
		while ((c = getchar()) != '\n' && c != EOF)
			/* LOOP */;
		if (c == EOF || getchar() == '\n') {
			fputs("Macro not defined - 4K buffer exceeded.\n", ttyout);
			code = -1;
			return;
		}
	}
}

/*
 * Get size of file on remote machine
 */
void
sizecmd(int argc, char *argv[])
{
	off_t size;

	if ((argc < 2 && !another(&argc, &argv, "file")) || argc > 2) {
		fprintf(ttyout, "usage: %s file\n", argv[0]);
		code = -1;
		return;
	}
	size = remotesize(argv[1], 1);
	if (size != -1)
		fprintf(ttyout, "%s\t%lld\n", argv[1], (long long)size);
	code = size;
}

/*
 * Get last modification time of file on remote machine
 */
void
modtime(int argc, char *argv[])
{
	time_t mtime;

	if ((argc < 2 && !another(&argc, &argv, "file")) || argc > 2) {
		fprintf(ttyout, "usage: %s file\n", argv[0]);
		code = -1;
		return;
	}
	mtime = remotemodtime(argv[1], 1);
	if (mtime != -1)
		fprintf(ttyout, "%s\t%s", argv[1], asctime(localtime(&mtime)));
	code = mtime;
}

/*
 * Show status on remote machine
 */
void
rmtstatus(int argc, char *argv[])
{

	(void)command(argc > 1 ? "STAT %s" : "STAT" , argv[1]);
}

/*
 * Get file if modtime is more recent than current file
 */
void
newer(int argc, char *argv[])
{

	(void)getit(argc, argv, -1, "w");
}

/*
 * Display one file through $PAGER (defaults to "more").
 */
void
page(int argc, char *argv[])
{
	off_t orestart_point;
	int ohash, overbose;
	char *p, *pager, *oldargv1;

	if ((argc < 2 && !another(&argc, &argv, "file")) || argc > 2) {
		fprintf(ttyout, "usage: %s file\n", argv[0]);
		code = -1;
		return;
	}
	oldargv1 = argv[1];
	if (!globulize(&argv[1])) {
		code = -1;
		return;
	}
	p = getenv("PAGER");
	if (p == NULL || (*p == '\0'))
		p = PAGER;
	if (asprintf(&pager, "|%s", p) == -1)
		errx(1, "Can't allocate memory for $PAGER");

	orestart_point = restart_point;
	ohash = hash;
	overbose = verbose;
	restart_point = hash = verbose = 0;
	recvrequest("RETR", pager, argv[1], "r+w", 1, 0);
	(void)free(pager);
	restart_point = orestart_point;
	hash = ohash;
	verbose = overbose;
	if (oldargv1 != argv[1])	/* free up after globulize() */
		free(argv[1]);
}

#endif /* !SMALL */

@


1.78
log
@Convert remaining calls to strtoq/strtouq in base with strtoll/strtoull.
Fix a type mismatch in ftp's "page" command and could make transfers restart
at the wrong position.

ok and a ull->ll tweak from natano@@, ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.77 2016/05/25 15:36:01 krw Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d146 1
a146 1
 
d1522 1
a1522 1
/* 
@


1.77
log
@Avoid a use-after-free.

Diff from Vladimir Sotirov via tech@@. Thanks!

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.76 2016/03/17 19:40:43 krw Exp $	*/
d1504 1
a1504 1
	quad_t nrestart_point;
d1510 2
a1511 2
		nrestart_point = strtoq(argv[1], &ep, 10);
		if (nrestart_point == QUAD_MAX || *ep != '\0')
d1655 2
a1656 1
	int orestart_point, ohash, overbose;
@


1.76
log
@Last parameter to execl[e]() functions *must* be cast to a pointer.
Just NULL is not good practise as NULL is theoretically allowed to
be an integer rather than a pointer.

Use (char *)NULL consistently instead of scattering a few (char *)0
and (void *)NULL into the mix.

Prompted by and probably ok deraadt@@ millert@@ kettenis@@

Definitely ok mestre@@ ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.75 2015/10/18 03:04:11 mmcc Exp $	*/
d1646 1
a1646 3
	if (getit(argc, argv, -1, "w"))
		fprintf(ttyout, "Local file \"%s\" is newer than remote file \"%s\".\n",
			argv[2], argv[1]);
@


1.75
log
@A whole buncha unsigned char casts for ctype function arguments.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.74 2015/01/30 04:45:45 tedu Exp $	*/
d1010 1
a1010 1
			execl(shellp, shellnam, "-c", altarg, (char *)0);
d1013 1
a1013 1
			execl(shellp, shellnam, (char *)0);
@


1.74
log
@remove tenex transfer support. if you still have TOPS20 machines in
service, you'll need to stick with openbsd 5.6.
bonus: remove references to ebcdic.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.73 2015/01/16 06:40:08 deraadt Exp $	*/
d282 1
a282 1
					while (*tp && !islower(*tp)) {
d289 1
a289 1
						     if (isupper(*tp2)) {
d291 1
a291 1
								tolower(*tp2);
@


1.73
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.72 2014/08/16 07:49:27 deraadt Exp $	*/
a96 12
	settype(2, stype);
}

/*
 * Set tenex transfer type.
 */
/*ARGSUSED*/
void
settenex(int argc, char *argv[])
{

	stype[1] = "tenex";
@


1.72
log
@I found a number of interactive events which can cause signals, and go
down paths not previously marked as signal handled unsafe.  Try to clean
up a few of them especially regarding errno, mark others as unsafe, and
repair a few by avoiding stdio.  Glanced at by misc people in Slovenia,
but considered too risky before release..
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.71 2012/10/15 21:20:05 bluhm Exp $	*/
d284 1
a284 1
		char *cp, *tp2, tmpbuf[MAXPATHLEN];
d699 1
a699 1
	static char gsbuf[MAXHOSTNAMELEN];
d803 1
a803 1
	char buf[MAXPATHLEN];
d996 1
a996 1
	char shellnam[MAXPATHLEN], *shellp, *namep;
d1123 1
a1123 1
	char buf[MAXPATHLEN];
d1465 1
a1465 1
	(void)strncpy(mapin, altarg, MAXPATHLEN - 1);
d1468 1
a1468 1
	(void)strncpy(mapout, cp, MAXPATHLEN - 1);
@


1.71
log
@Add support for recursive ftp upload.  The mput command of the ftp
client got the -r switch and -d depth option.
From Jan Klemkow <j.klemkow AT wemelug DOT de>
OK haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.70 2009/05/05 19:35:30 martynas Exp $	*/
d82 1
d1330 1
d1343 1
@


1.70
log
@make it clean removing the ifdef SMALL maze.  separate cmds and
small stuff.  make it a fetcher.  shrinks quite a bit
agreed by millert@@, krw@@
ok theo, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.69 2009/04/27 22:51:51 martynas Exp $	*/
d234 3
a236 1
	char *cmd, *tp;
d240 4
a243 1
	while ((ch = getopt(argc, argv, "c")) != -1) {
d248 12
d267 2
a268 1
		fprintf(ttyout, "usage: %s [-c] local-files\n", argv[0]);
d339 1
d345 1
d371 1
d379 2
d382 30
a411 5
			if (mflag && confirm(argv[0], *cpp)) {
				tp = (ntflag) ? dotrans(*cpp) : *cpp;
				tp = (mapflag) ? domap(tp) : tp;
				if (restartit == 1) {
					off_t ret;
d413 8
a420 4
					if (curtype != type)
						changetype(type, 0);
					ret = remotesize(tp, 0);
					restart_point = (ret < 0) ? 0 : ret;
d422 7
a428 8
				cmd = restartit ? "APPE" : ((sunique) ?
				    "STOU" : "STOR");
				sendrequest(cmd, *cpp, tp,
				    *cpp != tp || !interactive);
				restart_point = 0;
				if (!mflag && fromatty) {
					if (confirm(argv[0], NULL))
						mflag = 1;
d430 21
d455 1
d457 5
a461 1
	mflag = 0;
@


1.69
log
@remove uploading and macros support from install media;  to save
some space
discussed with theo, todd@@, millert@@
tested and looked over by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.68 2009/04/27 21:37:13 deraadt Exp $	*/
d62 2
a74 1
#ifndef SMALL
a75 1
#endif /* !SMALL */
d85 1
a85 118

jmp_buf	jabort;
char   *mname;
char   *home = "/";

struct	types {
	char	*t_name;
	char	*t_mode;
	int	t_type;
	char	*t_arg;
} types[] = {
	{ "ascii",	"A",	TYPE_A,	0 },
	{ "binary",	"I",	TYPE_I,	0 },
	{ "image",	"I",	TYPE_I,	0 },
	{ "ebcdic",	"E",	TYPE_E,	0 },
	{ "tenex",	"L",	TYPE_L,	bytename },
	{ NULL }
};

/*
 * Set transfer type.
 */
void
settype(int argc, char *argv[])
{
	struct types *p;
	int comret;

	if (argc > 2) {
		char *sep;

		fprintf(ttyout, "usage: %s [", argv[0]);
		sep = "";
		for (p = types; p->t_name; p++) {
			fprintf(ttyout, "%s%s", sep, p->t_name);
			sep = " | ";
		}
		fputs("]\n", ttyout);
		code = -1;
		return;
	}
	if (argc < 2) {
		fprintf(ttyout, "Using %s mode to transfer files.\n", typename);
		code = 0;
		return;
	}
	for (p = types; p->t_name; p++)
		if (strcmp(argv[1], p->t_name) == 0)
			break;
	if (p->t_name == 0) {
		fprintf(ttyout, "%s: unknown mode.\n", argv[1]);
		code = -1;
		return;
	}
	if ((p->t_arg != NULL) && (*(p->t_arg) != '\0'))
		comret = command("TYPE %s %s", p->t_mode, p->t_arg);
	else
		comret = command("TYPE %s", p->t_mode);
	if (comret == COMPLETE) {
		(void)strlcpy(typename, p->t_name, sizeof typename);
		curtype = type = p->t_type;
	}
}

/*
 * Internal form of settype; changes current type in use with server
 * without changing our notion of the type for data transfers.
 * Used to change to and from ascii for listings.
 */
void
changetype(int newtype, int show)
{
	struct types *p;
	int comret, oldverbose = verbose;

	if (newtype == 0)
		newtype = TYPE_I;
	if (newtype == curtype)
		return;
	if (
#ifndef SMALL
	    !debug &&
#endif /* !SMALL */
	    show == 0)
		verbose = 0;
	for (p = types; p->t_name; p++)
		if (newtype == p->t_type)
			break;
	if (p->t_name == 0) {
		warnx("internal error: unknown type %d.", newtype);
		return;
	}
	if (newtype == TYPE_L && bytename[0] != '\0')
		comret = command("TYPE %s %s", p->t_mode, bytename);
	else
		comret = command("TYPE %s", p->t_mode);
	if (comret == COMPLETE)
		curtype = newtype;
	verbose = oldverbose;
}

char *stype[] = {
	"type",
	"",
	0
};

/*
 * Set binary transfer type.
 */
/*ARGSUSED*/
void
setbinary(int argc, char *argv[])
{

	stype[1] = "binary";
	settype(2, stype);
}
a146 1
#ifndef SMALL
a152 1
#endif /* !SMALL */
a153 1
#ifndef SMALL
a159 1
#endif /* !SMALL */
a163 1
#ifndef SMALL
a197 1
#ifndef SMALL
a207 1
#endif /* !SMALL */
a223 1
#endif /* !SMALL */
a227 1
#ifndef SMALL
a237 1
#ifndef SMALL
a246 1
#endif /* !SMALL */
a254 1
#ifndef SMALL
a257 1
#endif /* !SMALL */
a297 1
#ifndef SMALL
a305 1
#endif /* !SMALL */
a329 1
#ifndef SMALL
a337 1
#endif /* !SMALL */
a361 1
#ifndef SMALL
a369 1
#endif /* !SMALL */
a385 1
#endif /* !SMALL */
a386 1
#ifndef SMALL
a392 271
#endif /* !SMALL */

void
get(int argc, char *argv[])
{

	(void)getit(argc, argv, 0, restart_point ? "a+w" : "w" );
}

/*
 * Receive one file.
 */
int
getit(int argc, char *argv[], int restartit, const char *mode)
{
	int loc = 0;
	int rval = 0;
	char *oldargv1, *oldargv2, *globargv2;

	if (argc == 2) {
		argc++;
		argv[2] = argv[1];
		loc++;
	}
	if (argc < 2 && !another(&argc, &argv, "remote-file"))
		goto usage;
	if ((argc < 3 && !another(&argc, &argv, "local-file")) || argc > 3) {
usage:
		fprintf(ttyout, "usage: %s remote-file [local-file]\n",
		    argv[0]);
		code = -1;
		return (0);
	}
	oldargv1 = argv[1];
	oldargv2 = argv[2];
	if (!globulize(&argv[2])) {
		code = -1;
		return (0);
	}
	globargv2 = argv[2];
	if (loc && mcase) {
		char *tp = argv[1], *tp2, tmpbuf[MAXPATHLEN];

		while (*tp && !islower(*tp)) {
			tp++;
		}
		if (!*tp) {
			tp = argv[2];
			tp2 = tmpbuf;
			while ((*tp2 = *tp) != '\0') {
				if (isupper(*tp2)) {
					*tp2 = tolower(*tp2);
				}
				tp++;
				tp2++;
			}
			argv[2] = tmpbuf;
		}
	}
	if (loc && ntflag)
		argv[2] = dotrans(argv[2]);
	if (loc && mapflag)
		argv[2] = domap(argv[2]);
#ifndef SMALL
	if (restartit) {
		struct stat stbuf;
		int ret;

		ret = stat(argv[2], &stbuf);
		if (restartit == 1) {
			restart_point = (ret < 0) ? 0 : stbuf.st_size;
		} else {
			if (ret == 0) {
				time_t mtime;

				mtime = remotemodtime(argv[1], 0);
				if (mtime == -1)
					goto freegetit;
				if (stbuf.st_mtime >= mtime) {
					rval = 1;
					goto freegetit;
				}
			}
		}
	}
#endif /* !SMALL */

	recvrequest("RETR", argv[2], argv[1], mode,
	    argv[1] != oldargv1 || argv[2] != oldargv2 || !interactive, loc);
	restart_point = 0;
freegetit:
	if (oldargv2 != globargv2)	/* free up after globulize() */
		free(globargv2);
	return (rval);
}

/* XXX - Signal race. */
/* ARGSUSED */
void
mabort(int signo)
{
	alarmtimer(0);
	putc('\n', ttyout);
	(void)fflush(ttyout);
	if (mflag && fromatty)
		if (confirm(mname, NULL))
			longjmp(jabort, 1);
	mflag = 0;
	longjmp(jabort, 1);
}

/*
 * Get multiple files.
 */
void
mget(int argc, char *argv[])
{
	extern int optind, optreset;
	sig_t oldintr;
	int ch, xargc = 2;
	char *cp, localcwd[MAXPATHLEN], *xargv[] = {argv[0], NULL, NULL};
	static int restartit = 0;
#ifndef SMALL
	extern char *optarg;
	const char *errstr;
	int i = 1;
	char type = NULL, *dummyargv[] = {argv[0], ".", NULL};
	FILE *ftemp = NULL;
	static int depth = 0, max_depth = 0;
#endif /* !SMALL */

	optind = optreset = 1;

#ifndef SMALL

	if (depth)
		depth++;

	while ((ch = getopt(argc, argv, "cd:nr")) != -1) {
		switch(ch) {
		case 'c':
			restartit = 1;
			break;
		case 'd':
			max_depth = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr != NULL) {
				fprintf(ttyout, "bad depth value, %s: %s\n",
				    errstr, optarg);
				code = -1;
				return;
			}
			break;
		case 'n':
			restartit = -1;
			break;
		case 'r':
			depth = 1;
			break;
		default:
			goto usage;
		}
	}
#endif /* !SMALL */

	if (argc - optind < 1 && !another(&argc, &argv, "remote-files")) {
usage:
		fprintf(ttyout, "usage: %s [-cnr] [-d depth] remote-files\n",
		    argv[0]);
		code = -1;
		return;
	}

#ifndef SMALL
	argv[optind - 1] = argv[0];
	argc -= optind - 1;
	argv += optind - 1;
#endif /* !SMALL */

	mname = argv[0];
	mflag = 1;
	if (getcwd(localcwd, sizeof(localcwd)) == NULL)
		err(1, "can't get cwd");

	oldintr = signal(SIGINT, mabort);
	(void)setjmp(jabort);
	while ((cp =
#ifndef SMALL
	    depth ? remglob2(dummyargv, proxy, NULL, &ftemp, &type) :
#endif /* !SMALL */
	    remglob(argv, proxy, NULL)) != NULL
#ifndef SMALL
	    || (mflag && depth && ++i < argc)
#endif /* !SMALL */
	    ) {
#ifndef SMALL
		if (cp == NULL)
			continue;
#endif /* !SMALL */
		if (*cp == '\0') {
			mflag = 0;
			continue;
		}
		if (!mflag)
			continue;
#ifndef SMALL
		if (depth && fnmatch(argv[i], cp, FNM_PATHNAME) != 0)
			continue;
#endif /* !SMALL */
		if (!fileindir(cp, localcwd)) {
			fprintf(ttyout, "Skipping non-relative filename `%s'\n",
			    cp);
			continue;
		}
#ifndef SMALL
		if (type == 'd' && depth == max_depth)
			continue;
#endif /* !SMALL */
		if (confirm(argv[0], cp)) {
#ifndef SMALL
			if (type == 'd') {
				mkdir(cp, 0755);
				if (chdir(cp) != 0) {
					warn("local: %s", cp);
					continue;
				}

				xargv[1] = cp;
				cd(xargc, xargv);
				if (dirchange != 1)
					goto out;

				xargv[1] = "*";
				mget(xargc, xargv);

				xargv[1] = "..";
				cd(xargc, xargv);
				if (dirchange != 1) {
					mflag = 0;
					goto out;
				}

out:
				if (chdir("..") != 0) {
					warn("local: %s", cp);
					mflag = 0;
				}
				continue;
			}
			if (type == 's')
				/* Currently ignored. */
				continue;
#endif /* !SMALL */
			xargv[1] = cp;
			(void)getit(xargc, xargv, restartit,
			    (restartit == 1 || restart_point) ? "a+w" : "w");
			if (!mflag && fromatty) {
				if (confirm(argv[0], NULL))
					mflag = 1;
			}
		}
	}
	(void)signal(SIGINT, oldintr);
#ifndef SMALL
	if (depth)
		depth--;
	if (depth == 0 || mflag == 0)
		depth = max_depth = mflag = restartit = 0;
#else /* !SMALL */
	mflag = 0;
#endif /* !SMALL */
}
a454 1
#ifndef SMALL
a461 1
#endif /* !SMALL */
a499 1
#ifndef SMALL
a507 1
#endif /* !SMALL */
a682 1
#ifndef SMALL
a717 29
#endif /* !SMALL */

/*
 * Set current working directory on remote machine.
 */
void
cd(int argc, char *argv[])
{
	int r;

	if ((argc < 2 && !another(&argc, &argv, "remote-directory")) ||
	    argc > 2) {
		fprintf(ttyout, "usage: %s remote-directory\n", argv[0]);
		code = -1;
		return;
	}
	r = command("CWD %s", argv[1]);
	if (r == ERROR && code == 500) {
		if (verbose)
			fputs("CWD command not recognized, trying XCWD.\n", ttyout);
		r = command("XCWD %s", argv[1]);
	}
	if (r == ERROR && code == 550) {
		dirchange = 0;
		return;
	}
	if (r == COMPLETE)
		dirchange = 1;
}
a937 1
#ifndef SMALL
a942 1
#endif /* !SMALL */
a1228 24
/*
 * Terminate session, but don't exit.
 */
/* ARGSUSED */
void
disconnect(int argc, char *argv[])
{

	if (!connected)
		return;
	(void)command("QUIT");
	if (cout) {
		(void)fclose(cout);
	}
	cout = NULL;
	connected = 0;
	data = -1;
#ifndef SMALL
	if (!proxy) {
		macnum = 0;
	}
#endif /* !SMALL */
}

a1358 28
char *
dotrans(char *name)
{
	static char new[MAXPATHLEN];
	char *cp1, *cp2 = new;
	int i, ostop, found;

	for (ostop = 0; *(ntout + ostop) && ostop < 16; ostop++)
		continue;
	for (cp1 = name; *cp1; cp1++) {
		found = 0;
		for (i = 0; *(ntin + i) && i < 16; i++) {
			if (*cp1 == *(ntin + i)) {
				found++;
				if (i < ostop) {
					*cp2++ = *(ntout + i);
				}
				break;
			}
		}
		if (!found) {
			*cp2++ = *cp1;
		}
	}
	*cp2 = '\0';
	return (new);
}

a1390 171
char *
domap(char *name)
{
	static char new[MAXPATHLEN];
	char *cp1 = name, *cp2 = mapin;
	char *tp[9], *te[9];
	int i, toks[9], toknum = 0, match = 1;

	for (i=0; i < 9; ++i) {
		toks[i] = 0;
	}
	while (match && *cp1 && *cp2) {
		switch (*cp2) {
			case '\\':
				if (*++cp2 != *cp1) {
					match = 0;
				}
				break;
			case '$':
				if (*(cp2+1) >= '1' && (*cp2+1) <= '9') {
					if (*cp1 != *(++cp2+1)) {
						toks[toknum = *cp2 - '1']++;
						tp[toknum] = cp1;
						while (*++cp1 && *(cp2+1)
							!= *cp1);
						te[toknum] = cp1;
					}
					cp2++;
					break;
				}
				/* FALLTHROUGH */
			default:
				if (*cp2 != *cp1) {
					match = 0;
				}
				break;
		}
		if (match && *cp1) {
			cp1++;
		}
		if (match && *cp2) {
			cp2++;
		}
	}
	if (!match && *cp1) /* last token mismatch */
	{
		toks[toknum] = 0;
	}
	cp1 = new;
	*cp1 = '\0';
	cp2 = mapout;
	while (*cp2) {
		match = 0;
		switch (*cp2) {
			case '\\':
				if (*(cp2 + 1)) {
					*cp1++ = *++cp2;
				}
				break;
			case '[':
LOOP:
				if (*++cp2 == '$' && isdigit(*(cp2+1))) {
					if (*++cp2 == '0') {
						char *cp3 = name;

						while (*cp3) {
							*cp1++ = *cp3++;
						}
						match = 1;
					}
					else if (toks[toknum = *cp2 - '1']) {
						char *cp3 = tp[toknum];

						while (cp3 != te[toknum]) {
							*cp1++ = *cp3++;
						}
						match = 1;
					}
				}
				else {
					while (*cp2 && *cp2 != ',' &&
					    *cp2 != ']') {
						if (*cp2 == '\\') {
							cp2++;
						}
						else if (*cp2 == '$' &&
   						        isdigit(*(cp2+1))) {
							if (*++cp2 == '0') {
							   char *cp3 = name;

							   while (*cp3) {
								*cp1++ = *cp3++;
							   }
							}
							else if (toks[toknum =
							    *cp2 - '1']) {
							   char *cp3=tp[toknum];

							   while (cp3 !=
								  te[toknum]) {
								*cp1++ = *cp3++;
							   }
							}
						}
						else if (*cp2) {
							*cp1++ = *cp2++;
						}
					}
					if (!*cp2) {
						fputs(
"nmap: unbalanced brackets.\n", ttyout);
						return (name);
					}
					match = 1;
					cp2--;
				}
				if (match) {
					while (*++cp2 && *cp2 != ']') {
					      if (*cp2 == '\\' && *(cp2 + 1)) {
							cp2++;
					      }
					}
					if (!*cp2) {
						fputs(
"nmap: unbalanced brackets.\n", ttyout);
						return (name);
					}
					break;
				}
				switch (*++cp2) {
					case ',':
						goto LOOP;
					case ']':
						break;
					default:
						cp2--;
						goto LOOP;
				}
				break;
			case '$':
				if (isdigit(*(cp2 + 1))) {
					if (*++cp2 == '0') {
						char *cp3 = name;

						while (*cp3) {
							*cp1++ = *cp3++;
						}
					}
					else if (toks[toknum = *cp2 - '1']) {
						char *cp3 = tp[toknum];

						while (cp3 != te[toknum]) {
							*cp1++ = *cp3++;
						}
					}
					break;
				}
				/* FALLTHROUGH */
			default:
				*cp1++ = *cp2;
				break;
		}
		cp2++;
	}
	*cp1 = '\0';
	if (!*new) {
		return (name);
	}
	return (new);
}

a1464 1
#ifndef SMALL
a1521 1
#endif /* !SMALL */
d1620 3
@


1.68
log
@toast the rcsid strings which just get in the way
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.67 2008/10/16 23:15:53 martynas Exp $	*/
d273 1
d280 1
d285 1
d348 1
d353 1
d522 1
a865 1
#endif /* !SMALL */
d872 1
d1691 1
d1695 1
d2133 1
d2191 1
@


1.67
log
@- resume http transfers [-C], if local file does not exist
- resume ftp transfers [-C, reget, mget], if local file does not
exist
ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.66 2008/09/18 14:45:36 todd Exp $	*/
a60 4

#if !defined(lint) && !defined(SMALL)
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.66 2008/09/18 14:45:36 todd Exp $";
#endif /* not lint and not SMALL */
@


1.66
log
@unbreak for gcc2 archs; declaration before code!
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.65 2008/09/08 19:31:16 martynas Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.65 2008/09/08 19:31:16 martynas Exp $";
d527 1
a527 1
	(void)getit(argc, argv, 1, "r+w");
d535 1
a535 1
	(void)getit(argc, argv, 0, restart_point ? "r+w" : "w" );
d599 1
a599 5
			if (ret < 0) {
				warn("local: %s", argv[2]);
				goto freegetit;
			}
			restart_point = stbuf.st_size;
d783 1
a783 1
			    (restartit == 1 || restart_point) ? "r+w" : "w");
@


1.65
log
@- simplify mget(): remove the duplicate code and just use getit(),
as a result it can do nice things getit() does such as:
- -n: use 'newer' for transfers (fetches files that are newer on
the server, than locally), this can be used for e.g. mirroring (mget
-cnr 4.* would fetch missing files, continue interrupted transfers,
and replace newer files of 4.X dirs)
- -d: spedify depth of the recurrence.  e.g. 'mget -rd 2 patches'
in pub/openbsd would fetch only archive files, not going further
into dirs
- use static restartit, max_depth instead of doing the magic
tested/requested&ok merdely@@;  ok pyr@@, millert@@
man page tweaks&ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.64 2008/08/22 08:52:35 sobrado Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.64 2008/08/22 08:52:35 sobrado Exp $";
d657 1
a666 1
	const char *errstr;
@


1.64
log
@default file transfer type is binary, not ascii;
commands which toggle settings can take an explicit on or off argument
to force the setting appropiately, show these arguments in usage;
synchronize synopsis and usage of commands; spacing; KNF;
other minor documentation tweaks.

written with help by jmc@@

ok jmc@@ (documentation), martynas@@ (type usage and default file transfer type)
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.63 2008/07/08 21:07:57 martynas Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.63 2008/07/08 21:07:57 martynas Exp $";
d621 1
a621 1
	    argv[1] != oldargv1 || argv[2] != oldargv2, loc);
d652 7
a658 5
	int ch;
	char *cp, *tp, *tp2, tmpbuf[MAXPATHLEN], localcwd[MAXPATHLEN];
#ifndef SMALL
	int i = 1, restartit = 0, xargc = 2;
	char type = NULL, *xargv[] = {argv[0], ".", NULL, NULL};
d660 1
a660 1
	static int depth = 0;
d666 6
a671 1
	while ((ch = getopt(argc, argv, "cr")) != -1) {
d676 12
d689 1
a689 1
			depth++;
d699 2
a700 1
		fprintf(ttyout, "usage: %s [-cr] remote-files\n", argv[0]);
d720 1
a720 1
	    depth ? remglob2(xargv, proxy, NULL, &ftemp, &type) :
d746 4
a759 2
				xargv[2] = NULL;
				xargc = 2;
d764 1
a764 4
				xargv[1] = (restartit == 1) ? "-cr" : "-r";
				xargv[2] = "*";
				xargv[3] = NULL;
				xargc = 3;
a767 2
				xargv[2] = NULL;
				xargc = 2;
a778 4

				xargv[1] = ".";
				xargv[2] = NULL;
				xargc = 2;
d785 3
a787 23
			tp = cp;
			if (mcase) {
				for (tp2 = tmpbuf; (ch = *tp++) != 0; )
					*tp2++ = isupper(ch) ? tolower(ch) : ch;
				*tp2 = '\0';
				tp = tmpbuf;
			}
			if (ntflag)
				tp = dotrans(tp);
			if (mapflag)
				tp = domap(tp);
#ifndef SMALL
			if (restartit == 1) {
				struct stat stbuf;
				int ret;

				ret = stat(tp, &stbuf);
				restart_point = (ret < 0) ? 0 : stbuf.st_size;
			}
#endif /* !SMALL */
			recvrequest("RETR", tp, cp, restart_point ? "r+w" : "w",
			    tp != cp || !interactive, 1);
			restart_point = 0;
d799 1
a799 1
		depth = mflag = 0;
@


1.63
log
@- add support for recursive transfers (but not for floppies), e.g.
'mget -cr 4.*' would recursively fetch (-r), and resume the previous
transfers (-c) of 4.X release directories
uses local matching (fnmatch), but only for recursive transfers.
current behavior is not changed in any way.
- while here, ifndef SMALL debugging stuff, this saves some space,
for floppies
- some debugging code was enabled for non-debugging mode, checks
assume debug is set to zero, but it's not initially set
- all "Confirm with" prompts are forced, remove redundant argument
- fix usage: -C and -c are not available for SMALL

discussed a year ago w/ pyr@@
looks good to millert@@
previous version looked good to pyr@@
man page tweaks & ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.62 2008/06/25 18:07:00 martynas Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.62 2008/06/25 18:07:00 martynas Exp $";
d121 1
a121 1
		sep = " ";
d126 1
a126 1
		fputs(" ]\n", ttyout);
d303 2
a304 1
		fprintf(ttyout, "usage: %s local-file [ remote-file ]\n", argv[0]);
d557 2
a558 1
		fprintf(ttyout, "usage: %s remote-file [ local-file ]\n", argv[0]);
d898 1
a898 1
		fprintf(ttyout, "usage: %s [ on | off ]\n", argv[0]);
d964 1
a964 1
		fprintf(ttyout, "usage: %s [ on | off | bytecount ]\n", argv[0]);
d1046 1
a1046 1
		fprintf(ttyout, "usage: %s [ on | off | gateserver [ port ] ]\n",
d1111 1
a1111 1
		fprintf(ttyout, "usage: %s [ on | off | debuglevel ]\n", argv[0]);
d1183 1
a1183 1
		fprintf(ttyout, "usage: %s local-directory\n", argv[0]);
d1289 2
a1290 1
		fprintf(ttyout, "usage: %s remote-directory local-file\n", argv[0]);
d1433 2
a1434 1
		fprintf(ttyout, "usage: %s username [password] [account]\n", argv[0]);
d1556 1
a1556 1
		fprintf(ttyout, "usage: %s line-to-send\n", argv[0]);
d1573 1
a1573 1
		fprintf(ttyout, "usage: %s line-to-send\n", argv[0]);
d1624 1
a1624 1
	if ((argc < 3 && !another(&argc, &argv, "file-name")) || argc > 3) {
d1626 1
a1626 1
		fprintf(ttyout, "usage: %s mode file-name\n", argv[0]);
d1874 2
a1875 2
	if ((argc < 3 && !another(&argc, &argv, "mapout")) || argc > 3) {
		fprintf(ttyout, "usage: %s [mapin mapout]\n", argv[0]);
d2151 2
a2152 2
	if ((argc < 2 && !another(&argc, &argv, "macro name")) || argc > 2) {
		fprintf(ttyout, "usage: %s macro_name\n", argv[0]);
d2206 2
a2207 2
	if ((argc < 2 && !another(&argc, &argv, "filename")) || argc > 2) {
		fprintf(ttyout, "usage: %s filename\n", argv[0]);
d2225 2
a2226 2
	if ((argc < 2 && !another(&argc, &argv, "filename")) || argc > 2) {
		fprintf(ttyout, "usage: %s filename\n", argv[0]);
d2267 2
a2268 2
	if ((argc < 2 && !another(&argc, &argv, "filename")) || argc > 2) {
		fprintf(ttyout, "usage: %s filename\n", argv[0]);
@


1.62
log
@- fix -Wall (no behavior change, a || b && c = a || (b && c) anyway)
- use argv[0] for "Confirm with", as other confirm()s do
- fix confirm cases, pass force=1 for mdelete and mabort too, fixes
a bug when you end up deleting all files when you ^C, instead of
getting a confirmation
- add reput command, that will allow to continue transfer uploads
- add -c for mget and mput, that will allow to continue multiple
transfers
- fix a bug when you use restart command together with put.  the
progressmeter would start from zero, and eta would show fictional
time.  this actually allows reput/put -c to have correct progressmeter
too
- document everything
discussed with, suggestions, reminded to ifdef SMALL the code so
we're able to fit in floppies, and ok millert@@, and jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.61 2008/06/16 19:56:04 martynas Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.61 2008/06/16 19:56:04 martynas Exp $";
d77 3
d168 5
a172 1
	if (debug == 0 && show == 0)
d382 3
a384 4
	optind--;
	argv[optind] = argv[0];
	argc -= optind;
	argv += optind;
d400 1
a400 1
			if (mflag && confirm(argv[0], cp, 0)) {
d442 1
a442 2
					if (confirm("Continue with",
					    argv[0], 1))
d457 1
a457 1
			if (mflag && confirm(argv[0], argv[i], 0)) {
d476 1
a476 2
					if (confirm("Continue with",
					    argv[0], 1))
d491 1
a491 1
			if (mflag && confirm(argv[0], *cpp, 0)) {
d510 1
a510 2
					if (confirm("Continue with",
					    argv[0], 1))
d636 1
a636 1
		if (confirm("Continue with", mname, 1))
d650 1
a650 1
	int ch, restartit = 0;
d652 6
d662 1
a662 1
	while ((ch = getopt(argc, argv, "c")) != -1) {
d667 3
d678 1
a678 1
		fprintf(ttyout, "usage: %s [-c] remote-files\n", argv[0]);
d684 3
a686 4
	optind--;
	argv[optind] = argv[0];
	argc -= optind;
	argv += optind;
d696 13
a708 1
	while ((cp = remglob(argv, proxy, NULL)) != NULL) {
d715 4
d724 46
a769 1
		if (confirm(argv[0], cp, 0)) {
d794 1
a794 1
				if (confirm("Continue with", argv[0], 1))
d800 6
d807 1
a914 1
#ifndef SMALL
d918 1
d1103 1
d1139 1
d1242 1
a1242 1
		if (mflag && confirm(argv[0], cp, 0)) {
d1245 1
a1245 1
				if (confirm("Continue with", argv[0], 1))
d1299 1
a1299 1
	    !confirm("output to local-file:", argv[2], 0))) {
d1336 1
a1336 1
		    !confirm("output to local-file:", dest, 0)) {
d1348 1
a1348 1
			if (confirm("Continue with", argv[0], 1))
d1387 1
d1393 1
@


1.61
log
@- add 'q', which does the same as eof
- add '?', which will help
- make use of mflag, instead of special-case interactive
- change mflag++ to mflag = 1, because theoretically it can go out
of range
"i like it" millert@@.  man page help and ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.60 2008/06/16 12:03:51 martynas Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.60 2008/06/16 12:03:51 martynas Exp $";
d261 16
d281 1
a281 1
put(int argc, char *argv[])
d313 16
a328 1
	cmd = (argv[0][0] == 'a') ? "APPE" : ((sunique) ? "STOU" : "STOR");
d337 1
d348 2
a349 1
	int i;
d351 3
a353 1
	char *tp;
d355 15
a369 2
	if (argc < 2 && !another(&argc, &argv, "local-files")) {
		fprintf(ttyout, "usage: %s local-files\n", argv[0]);
d373 8
d383 1
d420 15
a434 2
				sendrequest((sunique) ? "STOU" : "STOR",
				    cp, tp, cp != tp || !interactive);
d436 2
a437 1
					if (confirm("Continue with", "mput", 1))
d455 15
a469 2
				sendrequest((sunique) ? "STOU" : "STOR",
				    argv[i], tp, tp != argv[i] || !interactive);
d471 2
a472 1
					if (confirm("Continue with", "mput", 1))
d490 15
a504 2
				sendrequest((sunique) ? "STOU" : "STOR",
				    *cpp, tp, *cpp != tp || !interactive);
d506 2
a507 1
					if (confirm("Continue with", "mput", 1))
d518 1
d525 1
d587 1
d613 1
d633 1
a633 1
		if (confirm("Continue with", mname, 0))
d645 1
d647 1
a647 1
	int ch;
d650 17
a666 2
	if (argc < 2 && !another(&argc, &argv, "remote-files")) {
		fprintf(ttyout, "usage: %s remote-files\n", argv[0]);
d670 8
d709 10
a718 1
			recvrequest("RETR", tp, cp, "w",
d720 1
d722 1
a722 1
				if (confirm("Continue with", "mget", 1))
d1164 1
a1164 1
				if (confirm("Continue with", "mdelete", 0))
@


1.60
log
@fix transfer interrupting when confirmrest mode is used.  change
confirm() to have a 'force' argument, so that ointer/oconf dance
is not needed, and to prevent further bugs like this;  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.59 2008/06/15 03:09:13 martynas Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.59 2008/06/15 03:09:13 martynas Exp $";
d367 1
a367 1
						mflag++;
d388 1
a388 1
						mflag++;
d409 1
a409 1
						mflag++;
d586 1
a586 1
					mflag++;
d1028 1
a1028 1
					mflag++;
@


1.59
log
@make further prompts work after eof, don't spam with prompts in
m*() cases;  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.58 2008/05/13 02:09:38 ray Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.58 2008/05/13 02:09:38 ray Exp $";
a317 1
	int ointer;
d337 1
a337 1
			if (mflag && confirm(argv[0], cp)) {
d366 1
a366 3
					ointer = interactive;
					interactive = 1;
					if (confirm("Continue with", "mput")) {
a367 2
					}
					interactive = ointer;
d381 1
a381 1
			if (mflag && confirm(argv[0], argv[i])) {
d387 1
a387 3
					ointer = interactive;
					interactive = 1;
					if (confirm("Continue with", "mput")) {
a388 2
					}
					interactive = ointer;
d402 1
a402 1
			if (mflag && confirm(argv[0], *cpp)) {
d408 1
a408 3
					ointer = interactive;
					interactive = 1;
					if (confirm("Continue with", "mput")) {
a409 2
					}
					interactive = ointer;
a525 2
	int ointer, oconf;

d529 2
a530 8
	if (mflag && fromatty) {
		ointer = interactive;
		oconf = confirmrest;
		interactive = 1;
		confirmrest = 0;
		if (confirm("Continue with", mname)) {
			interactive = ointer;
			confirmrest = oconf;
a531 4
		}
		interactive = ointer;
		confirmrest = oconf;
	}
d543 1
a543 1
	int ch, ointer;
d570 1
a570 1
		if (confirm(argv[0], cp)) {
d585 1
a585 3
				ointer = interactive;
				interactive = 1;
				if (confirm("Continue with", "mget")) {
a586 2
				}
				interactive = ointer;
a1007 1
	int ointer;
d1024 1
a1024 1
		if (mflag && confirm(argv[0], cp)) {
d1027 1
a1027 3
				ointer = interactive;
				interactive = 1;
				if (confirm("Continue with", "mdelete")) {
a1028 2
				}
				interactive = ointer;
d1081 1
a1081 1
	    !confirm("output to local-file:", argv[2]))) {
d1103 1
a1103 1
	int ointer, i;
d1118 1
a1118 1
		    !confirm("output to local-file:", dest)) {
d1130 1
a1130 3
			ointer = interactive;
			interactive = 1;
			if (confirm("Continue with", argv[0])) {
a1131 2
			}
			interactive = ointer;
@


1.58
log
@Remove #if 0 code that has been unused for nearly a decade (and
probably doesn't compile, since the types for some variables have
changed from long to char *).

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.57 2007/09/11 15:47:17 gilles Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.57 2007/09/11 15:47:17 gilles Exp $";
d1262 2
a1263 1
			if (fgets(acctname, sizeof(acctname), stdin) == NULL)
d1265 1
@


1.57
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.56 2007/07/26 17:48:41 millert Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.56 2007/07/26 17:48:41 millert Exp $";
a869 14
#if 0
				char *ep;
				long port;

				port = strtol(argv[2], &ep, 10);
				if (port < 0 || port > USHRT_MAX || *ep != '\0') {
					fprintf(ttyout,
					    "%s: bad gateport value.\n",
					    argv[2]);
					code = -1;
					return;
				}
				gateport = htons(port);
#else
a872 1
#endif
@


1.56
log
@Remove the space after "Password:" in password prompts where echo is
turned off.  This is consistent with historic UNIX behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.55 2006/11/22 04:08:35 ray Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.55 2006/11/22 04:08:35 ray Exp $";
a1274 2
			char *p;

d1279 3
a1281 2
			if ((p = strchr(acctname, '\n')) != NULL)
				*p = '\0';
@


1.55
log
@Mark signal race.

``OK!'' deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.54 2006/11/02 01:51:33 ray Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.54 2006/11/02 01:51:33 ray Exp $";
d1270 1
a1270 1
			argv[2] = getpass("Password: "), argc++;
@


1.54
log
@Pass full buffer size to fgets.

OK moritz@@ and jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.53 2006/11/02 01:43:01 ray Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.53 2006/11/02 01:43:01 ray Exp $";
d534 1
@


1.53
log
@Add checks for fgets and properly overwrite newline.

Initial patch from Charles Longeau <chl at tuxfamily dot org>.

OK moritz@@ and jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.52 2006/05/19 04:05:35 ray Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.52 2006/05/19 04:05:35 ray Exp $";
d1278 1
a1278 1
			if (fgets(acctname, sizeof(acctname) - 1, stdin) == NULL)
@


1.52
log
@Remove ``sanity check'' that is already done in loop.

OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.51 2006/05/16 23:43:16 ray Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.51 2006/05/16 23:43:16 ray Exp $";
d1274 2
d1278 4
a1281 2
			(void)fgets(acctname, sizeof(acctname) - 1, stdin);
			acctname[strlen(acctname) - 1] = '\0';
d1289 1
@


1.51
log
@Remove shadowing variables and properly use /* FALLTHROUGH */
comments.  No binary change.

Found by lint.

OK beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.50 2006/04/25 05:45:20 tedu Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.50 2006/04/25 05:45:20 tedu Exp $";
a1414 5

			/* Sanity check */
			if (len >= sizeof(buf) - 1)
				break;

@


1.50
log
@two strtol calls that were begging to be converted to strtonum
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.49 2005/10/12 06:50:42 otto Exp $	*/
d63 1
a63 1
static const char rcsid[] = "$OpenBSD: cmds.c,v 1.49 2005/10/12 06:50:42 otto Exp $";
d1152 1
a1152 1
	char mode[1], *dest, *odest;
d1175 2
a1176 2
		*mode = (i == 1) ? 'w' : 'a';
		recvrequest("LIST", dest, argv[i], mode, 0, 0);
d1201 1
a1201 1
	char shellnam[MAXPATHLEN], *shell, *namep;
d1211 4
a1214 4
		shell = getenv("SHELL");
		if (shell == NULL || *shell == '\0')
			shell = _PATH_BSHELL;
		namep = strrchr(shell, '/');
d1216 1
a1216 1
			namep = shell;
d1222 1
a1222 1
			fputs(shell, ttyout);
d1227 1
a1227 1
			execl(shell, shellnam, "-c", altarg, (char *)0);
d1230 1
a1230 1
			execl(shell, shellnam, (char *)0);
d1232 1
a1232 1
		warn("%s", shell);
d1256 1
a1256 1
	char acct[80];
d1276 4
a1279 3
			(void)fgets(acct, sizeof(acct) - 1, stdin);
			acct[strlen(acct) - 1] = '\0';
			argv[3] = acct; argc++;
d1879 1
a1879 1
				/* intentional drop through */
@


1.49
log
@Fix mget directory traversal vulnerability. From NetBSD. CAN-2002-1345.
ok millert@@ deraadt@@, prodding by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.48 2004/09/16 04:39:16 deraadt Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.48 2004/09/16 04:39:16 deraadt Exp $";
d782 2
a783 2
		long nmark;
		char *ep;
d785 4
a788 3
		nmark = strtol(argv[1], &ep, 10);
		if (nmark < 1 || nmark > INT_MAX || *ep != '\0') {
			fprintf(ttyout, "%s: bad bytecount value.\n", argv[1]);
d944 2
a945 2
			char *ep;
			long val;
d947 4
a950 4
			val = strtol(argv[1], &ep, 10);
			if (val < 0 || val > INT_MAX || *ep != '\0') {
				fprintf(ttyout, "%s: bad debugging value.\n",
				    argv[1]);
d954 1
a954 1
			debug = (int)val;
@


1.48
log
@type corrections and other delinting
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.47 2004/07/20 03:50:25 deraadt Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.47 2004/07/20 03:50:25 deraadt Exp $";
d568 1
a568 1
	char *cp, *tp, *tp2, tmpbuf[MAXPATHLEN];
d577 3
d587 8
a594 1
		if (mflag && confirm(argv[0], cp)) {
@


1.47
log
@ansi; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.46 2003/12/16 21:46:22 deraadt Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.46 2003/12/16 21:46:22 deraadt Exp $";
d192 1
a192 1
/*VARARGS*/
d204 1
a204 1
/*VARARGS*/
d216 1
a216 1
/*VARARGS*/
d709 1
a709 1
/*VARARGS*/
d721 1
a721 1
/*VARARGS*/
d734 1
a734 1
/*VARARGS*/
d746 1
a746 1
/*VARARGS*/
d757 1
a757 1
/*VARARGS*/
d794 1
a794 1
/*VARARGS*/
d805 1
a805 1
/*VARARGS*/
d816 1
a816 1
/*VARARGS*/
d827 1
a827 1
/*VARARGS*/
d838 1
a838 1
/*VARARGS*/
d897 1
a897 1
/*VARARGS*/
d908 1
a908 1
/*VARARGS*/
d919 1
a919 1
/*VARARGS*/
d1022 1
a1022 1
delete(int argc, char *argv[])
d1285 1
a1285 1
/*VARARGS*/
d1305 1
d1484 1
a1484 1
/*VARARGS*/
d1501 1
d1539 1
d1541 1
a1541 1
proxabort(int notused)
d1904 1
d1947 1
@


1.46
log
@for -DSMALL, do not include rcsid[]s
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.45 2003/06/03 02:56:08 millert Exp $	*/
d63 1
a63 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.45 2003/06/03 02:56:08 millert Exp $";
d109 1
a109 3
settype(argc, argv)
	int argc;
	char *argv[];
d156 1
a156 2
changetype(newtype, show)
	int newtype, show;
d194 1
a194 3
setbinary(argc, argv)
	int argc;
	char *argv[];
d206 1
a206 3
setascii(argc, argv)
	int argc;
	char *argv[];
d218 1
a218 3
settenex(argc, argv)
	int argc;
	char *argv[];
d230 1
a230 3
setftmode(argc, argv)
	int argc;
	char *argv[];
d242 1
a242 3
setform(argc, argv)
	int argc;
	char *argv[];
d254 1
a254 3
setstruct(argc, argv)
	int argc;
	char *argv[];
d265 1
a265 3
put(argc, argv)
	int argc;
	char *argv[];
d314 1
a314 3
mput(argc, argv)
	int argc;
	char *argv[];
d433 1
a433 3
reget(argc, argv)
	int argc;
	char *argv[];
d440 1
a440 3
get(argc, argv)
	int argc;
	char *argv[];
d450 1
a450 5
getit(argc, argv, restartit, mode)
	int argc;
	char *argv[];
	int restartit;
	const char *mode;
d536 1
a536 2
mabort(signo)
	int signo;
d564 1
a564 3
mget(argc, argv)
	int argc;
	char *argv[];
d613 1
a613 2
onoff(bool)
	int bool;
d624 1
a624 3
status(argc, argv)
	int argc;
	char *argv[];
d689 1
a689 5
togglevar(argc, argv, var, mesg)
	int   argc;
	char *argv[];
	int  *var;
	const char *mesg;
d711 1
a711 3
setbell(argc, argv)
	int argc;
	char *argv[];
d723 1
a723 3
setedit(argc, argv)
	int argc;
	char *argv[];
d736 1
a736 3
setepsv4(argc, argv)
	int argc;
	char *argv[];
d748 1
a748 3
settrace(argc, argv)
	int argc;
	char *argv[];
d759 1
a759 3
sethash(argc, argv)
	int argc;
	char *argv[];
d796 1
a796 3
setverbose(argc, argv)
	int argc;
	char *argv[];
d807 1
a807 3
setport(argc, argv)
	int argc;
	char *argv[];
d818 1
a818 3
setprogress(argc, argv)
	int argc;
	char *argv[];
d829 1
a829 3
setprompt(argc, argv)
	int argc;
	char *argv[];
d840 1
a840 3
setgate(argc, argv)
	int argc;
	char *argv[];
d899 1
a899 3
setglob(argc, argv)
	int argc;
	char *argv[];
d910 1
a910 3
setpreserve(argc, argv)
	int argc;
	char *argv[];
d921 1
a921 3
setdebug(argc, argv)
	int argc;
	char *argv[];
d959 1
a959 3
cd(argc, argv)
	int argc;
	char *argv[];
d987 1
a987 3
lcd(argc, argv)
	int argc;
	char *argv[];
d1022 1
a1022 3
delete(argc, argv)
	int argc;
	char *argv[];
d1037 1
a1037 3
mdelete(argc, argv)
	int argc;
	char *argv[];
d1077 1
a1077 3
renamefile(argc, argv)
	int argc;
	char *argv[];
d1096 1
a1096 3
ls(argc, argv)
	int argc;
	char *argv[];
d1137 1
a1137 3
mls(argc, argv)
	int argc;
	char *argv[];
d1186 1
a1186 3
shell(argc, argv)
	int argc;
	char *argv[];
d1243 1
a1243 3
user(argc, argv)
	int argc;
	char *argv[];
d1287 1
a1287 3
pwd(argc, argv)
	int argc;
	char *argv[];
d1306 1
a1306 3
lpwd(argc, argv)
	int argc;
	char *argv[];
d1321 1
a1321 3
makedir(argc, argv)
	int argc;
	char *argv[];
d1341 1
a1341 3
removedir(argc, argv)
	int argc;
	char *argv[];
d1361 1
a1361 3
quote(argc, argv)
	int argc;
	char *argv[];
d1378 1
a1378 3
site(argc, argv)
	int argc;
	char *argv[];
d1394 1
a1394 4
quote1(initial, argc, argv)
	const char *initial;
	int argc;
	char *argv[];
d1433 1
a1433 3
do_chmod(argc, argv)
	int argc;
	char *argv[];
d1448 1
a1448 3
do_umask(argc, argv)
	int argc;
	char *argv[];
d1458 1
a1458 3
idle(argc, argv)
	int argc;
	char *argv[];
d1471 1
a1471 3
rmthelp(argc, argv)
	int argc;
	char *argv[];
d1485 1
a1485 3
quit(argc, argv)
	int argc;
	char *argv[];
d1501 1
a1501 3
disconnect(argc, argv)
	int argc;
	char *argv[];
d1519 1
a1519 3
account(argc, argv)
	int argc;
	char *argv[];
d1538 1
a1538 2
proxabort(notused)
	int notused;
d1556 1
a1556 3
doproxy(argc, argv)
	int argc;
	char *argv[];
d1615 1
a1615 3
setcase(argc, argv)
	int argc;
	char *argv[];
d1622 1
a1622 3
setcr(argc, argv)
	int argc;
	char *argv[];
d1629 1
a1629 3
setntrans(argc, argv)
	int argc;
	char *argv[];
d1648 1
a1648 2
dotrans(name)
	char *name;
d1676 1
a1676 3
setnmap(argc, argv)
	int argc;
	char *argv[];
d1708 1
a1708 2
domap(name)
	char *name;
d1879 1
a1879 3
setpassive(argc, argv)
	int argc;
	char *argv[];
d1887 1
a1887 3
setsunique(argc, argv)
	int argc;
	char *argv[];
d1894 1
a1894 3
setrunique(argc, argv)
	int argc;
	char *argv[];
d1902 1
a1902 3
cdup(argc, argv)
	int argc;
	char *argv[];
d1920 1
a1920 3
restart(argc, argv)
	int argc;
	char *argv[];
d1944 1
a1944 3
syst(argc, argv)
	int argc;
	char *argv[];
d1951 1
a1951 3
macdef(argc, argv)
	int argc;
	char *argv[];
d2012 1
a2012 3
sizecmd(argc, argv)
	int argc;
	char *argv[];
d2031 1
a2031 3
modtime(argc, argv)
	int argc;
	char *argv[];
d2050 1
a2050 3
rmtstatus(argc, argv)
	int argc;
	char *argv[];
d2060 1
a2060 3
newer(argc, argv)
	int argc;
	char *argv[];
d2072 1
a2072 3
page(argc, argv)
	int argc;
	char *argv[];
@


1.45
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.44 2003/04/05 17:19:47 deraadt Exp $	*/
d62 3
a64 7
#ifndef lint
#if 0
static char sccsid[] = "@@(#)cmds.c	8.6 (Berkeley) 10/9/94";
#else
static char rcsid[] = "$OpenBSD: cmds.c,v 1.44 2003/04/05 17:19:47 deraadt Exp $";
#endif
#endif /* not lint */
@


1.44
log
@string fixes; ok miod henning
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.43 2003/03/31 23:04:07 millert Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d66 1
a66 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.43 2003/03/31 23:04:07 millert Exp $";
@


1.43
log
@Treat empty environment variables the same as NULL.  henning@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.42 2003/01/03 04:57:54 deraadt Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.42 2003/01/03 04:57:54 deraadt Exp $";
d155 1
a155 1
		(void)strcpy(typename, p->t_name);
d2245 1
a2245 1
	if ((pager = malloc(strlen(p) + 2)) == NULL)
a2246 1
	(void)sprintf(pager, "|%s", p);
@


1.42
log
@be more aware of directory change failures; s@@msmith.net
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.41 2002/07/12 00:25:30 deraadt Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.41 2002/07/12 00:25:30 deraadt Exp $";
d1288 1
a1288 1
		if (shell == NULL)
@


1.41
log
@malloc/strdup failure not handled; cloder@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.40 2002/01/04 16:18:59 art Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.40 2002/01/04 16:18:59 art Exp $";
d1047 4
@


1.40
log
@Don't longjmp(..., 0)
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.39 2001/10/24 20:42:24 millert Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.39 2001/10/24 20:42:24 millert Exp $";
d938 2
@


1.39
log
@Misplaced space in fprintf "Execute get, put orappend  to initiate transfer"
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.38 2001/10/01 14:58:49 millert Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.38 2001/10/01 14:58:49 millert Exp $";
d587 1
a587 1
			longjmp(jabort, 0);
d593 1
a593 1
	longjmp(jabort, 0);
@


1.38
log
@Typo, assign the new restart point to nrestart_point, not restart_point.
Fixes an uninitialized use of nrestart_point.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.37 2001/07/12 05:17:07 deraadt Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.37 2001/07/12 05:17:07 deraadt Exp $";
d2067 2
a2068 2
			fprintf(ttyout, "Restarting at %lld. Execute get, put or"
				"append  to initiate transfer\n",
@


1.37
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.36 2001/06/26 23:43:59 lebel Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.36 2001/06/26 23:43:59 lebel Exp $";
d2063 1
a2063 1
		restart_point = strtoq(argv[1], &ep, 10);
@


1.36
log
@use strlcpy vs strncpy+a[len-1]='\0'.  millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.35 2000/12/24 00:29:00 aaron Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.35 2000/12/24 00:29:00 aaron Exp $";
d2067 1
a2067 1
			fprintf(ttyout, "Restarting at %qd. Execute get, put or"
d2069 1
a2069 1
				nrestart_point);
d2164 1
a2164 1
		fprintf(ttyout, "%s\t%qd\n", argv[1], size);
@


1.35
log
@Spelling: tripple -> triple
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.34 2000/06/21 19:22:54 itojun Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.34 2000/06/21 19:22:54 itojun Exp $";
d940 1
a940 2
			strncpy(gsbuf, argv[1], sizeof(gsbuf) - 1);
			gsbuf[sizeof(gsbuf) - 1] = '\0';
d1288 1
a1288 2
		(void)strncpy(shellnam + 1, ++namep, sizeof(shellnam) - 2);
		shellnam[sizeof(shellnam) - 1] = '\0';
d1497 1
a1497 2
	(void)strncpy(buf, initial, sizeof(buf) - 1);
	buf[sizeof(buf) - 1] = '\0';
d1514 1
a1514 2
			strncpy(&buf[len], argv[i], sizeof(buf) - len - 1);
			buf[sizeof(buf) - 1] = '\0';
d1760 1
a1760 2
	(void)strncpy(ntin, argv[1], sizeof(ntin) - 1);
	ntin[sizeof(ntin) - 1] = '\0';
d1765 1
a1765 2
	(void)strncpy(ntout, argv[2], sizeof(ntout) - 1);
	ntout[sizeof(ntout) - 1] = '\0';
d2108 2
a2109 3
	(void)strncpy(macros[macnum].mac_name, argv[1],
	    sizeof(macros[macnum].mac_name) - 1);
	macros[macnum].mac_name[sizeof(macros[macnum].mac_name) - 1] = '\0';
@


1.34
log
@add epsv4 command, which turns off epsv on ipv4 (off by dfeault)
automagicaslly disable epsv on ipv4, if epsv fails for single connection.
merge from netbsd-current.

req from fgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.33 2000/06/13 21:28:38 millert Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.33 2000/06/13 21:28:38 millert Exp $";
d1525 1
a1525 1
	/* Make double (tripple?) sure the sucker is NUL terminated */
@


1.33
log
@Make both ls and dir send a LIST command.  Perviously, ls would use
NLST but some ftp server (notably wu-ftpd 2.6.x) only list files
in the output of NLST.  This behavior appears to be RFC conforming
and it makes things like "mget *" behave more sanely.  To get just
the file list you can still use the "nlist" command.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.32 1999/12/08 12:57:06 itojun Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.32 1999/12/08 12:57:06 itojun Exp $";
d712 2
d779 14
@


1.32
log
@ftp(1) from KAME, should be good for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.31 1999/06/29 14:33:23 aaron Exp $	*/
d70 1
a70 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.31 1999/06/29 14:33:23 aaron Exp $";
d1172 1
a1172 1
	cmd = strcmp(argv[0], "dir") == 0 ? "LIST" : "NLST";
a1204 1
	int dolist;
a1222 1
	dolist = strcmp(argv[0], "mls");
d1229 1
a1229 2
		recvrequest(dolist ? "LIST" : "NLST", dest, argv[i], mode,
		    0, 0);
@


1.31
log
@retreived -> retrieved
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.30 1999/06/10 22:38:02 pjanzen Exp $	*/
d5 29
d70 1
a70 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.30 1999/06/10 22:38:02 pjanzen Exp $";
d685 2
a686 2
	fprintf(ttyout, "Gate ftp: %s, server %s, port %d.\n", onoff(gatemode),
	    *gateserver ? gateserver : "(none)", ntohs(gateport));
d711 1
a711 1
	fprintf(ttyout, "Use of PORT cmds: %s.\n", onoff(sendport));
d844 1
a844 1
 * Toggle PORT cmd use before each data connection.
d853 1
a853 1
	code = togglevar(argc, argv, &sendport, "Use of PORT cmds");
d907 1
d920 3
d935 1
a935 1
		fprintf(ttyout, "Gate ftp: %s, server %s, port %d.\n",
d937 1
a937 1
		    *gateserver ? gateserver : "(none)", ntohs(gateport));
@


1.30
log
@Handle PAGER in a manner consistent with the Single Unix Specification:
that is, use PAGER rather than "more" if it is defined and non-null, not
just if it is defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.29 1998/09/01 17:08:22 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.29 1998/09/01 17:08:22 deraadt Exp $";
d923 1
a923 1
 * Toggle preserving modification times on retreived files.
@


1.29
log
@use commands("%s", buf); lukem
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.28 1998/06/08 19:48:56 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.28 1998/06/08 19:48:56 millert Exp $";
d2198 1
a2198 1
	if (p == NULL)
@


1.28
log
@use endptr in a strtl()
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.27 1998/06/08 16:55:56 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.27 1998/06/08 16:55:56 millert Exp $";
d1482 1
a1482 1
	if (command(buf) == PRELIM) {
@


1.27
log
@Fix some problems noted by lukem@@netbsd.org
 o getopt string is wrong in main(); (missing : after P)
 o use of vprintf(...) instead of vfprintf(ttyout,...) in ftp.c::command()
 o missing \n in fputs in cmds.c::status()
 o should use strtol() instead of atol()
 o sometimes use 'NULL' instead of 'NUL' (in comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.26 1998/02/10 02:13:10 weingart Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.26 1998/02/10 02:13:10 weingart Exp $";
d782 5
a786 2
		long nmark = strtol(argv[1], NULL, 10);
		if (nmark < 1 && nmark > INT_MAX) {
@


1.26
log
@Fix buffer overflows in quote1(), clear line buffer
before use.  Hopefully, this is the last of the
PR# 406 stuff that this will need.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.25 1998/02/08 21:04:16 weingart Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.25 1998/02/08 21:04:16 weingart Exp $";
d687 1
a687 1
		fputs("Macros:", ttyout);
d782 2
a783 2
		int nmark = atol(argv[1]);
		if (nmark < 1) {
d1467 1
a1467 1
			/* Copy next argument, NULL terminate always */
d1476 1
a1476 1
	/* Make double (tripple?) sure the sucker is NULL terminated */
d2014 2
d2020 9
a2028 3
		restart_point = atol(argv[1]);
		fprintf(ttyout, "Restarting at %qd. Execute get, put or append"
			" to initiate transfer\n", (quad_t)restart_point);
@


1.25
log
@Apply fix for PR# 406.  Thanks to
Motomichi Matsuzaki (mzaki@@e-mail.ne.jp)
for the fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.24 1997/09/10 20:55:08 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.24 1997/09/10 20:55:08 millert Exp $";
d1434 1
a1434 1
	quote1("SITE ", argc, argv);
d1453 20
a1472 7
		len = strlen(buf);
		len += strlen(strncpy(&buf[len], argv[1],
		    sizeof(buf) - len - 1));
		for (i = 2; i < argc && len < sizeof(buf); i++) {
			buf[len++] = ' ';
			len += strlen(strncpy(&buf[len], argv[i],
			    sizeof(buf) - len - 1));
d1475 4
@


1.24
log
@Die union wait die!
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.23 1997/09/04 04:37:13 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.23 1997/09/04 04:37:13 millert Exp $";
d1459 1
a1459 1
			    sizeof(buf) - len) - 1);
@


1.23
log
@Updtaes from NetBSD (lukem)
    bugs fixed:
      * don't interpret '-' or '|' when a local filename is determined from
        the remote name (i.e, in mget, and in get with only one argument).
        This is implemented using an extra argument to recvrequest().
        Fixes a major security hole.
      * clean up memory leak when using globulize()
      * clean up a couple of comments
      * fix wording in TNF copyright

    features added:
      * support for TIS fwtk gate-ftp servers:
        * read defaults from $FTPSERVER && $FTPSERVERPORT
        * start in gate-ftp mode if invoked as 'gate-ftp'
        * toggle or set with 'gate [host [port]]'

Other changes:
    * use symbolic flags in access(2)
    * Use USHRT_MAX, not 0xffff
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.22 1997/08/30 20:48:41 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.22 1997/08/30 20:48:41 kstailey Exp $";
d1224 1
a1224 1
	union wait status;
d1260 1
a1260 1
		while (wait((int *)&status) != pid)
@


1.22
log
@s/toinitiate/to initiate/
@
text
@d1 2
a2 2
/*	$OpenBSD: cmds.c,v 1.21 1997/07/25 21:56:17 millert Exp $	*/
/*	$NetBSD: cmds.c,v 1.26 1997/07/21 14:03:48 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.21 1997/07/25 21:56:17 millert Exp $";
d302 2
d347 2
a348 1
						        *tp2 = 'a' + *tp2 - 'A';
d459 2
a460 1
	char *oldargv1, *oldargv2;
d481 1
d493 1
a493 1
					*tp2 = 'a' + *tp2 - 'A';
d513 1
a513 1
				return (0);
d522 5
a526 3
					return (0);
				if (stbuf.st_mtime >= mtime)
					return (1);
d532 1
a532 1
	    argv[1] != oldargv1 || argv[2] != oldargv2);
d534 4
a537 1
	return (0);
d606 1
a606 1
			    tp != cp || !interactive);
d656 2
d838 1
a838 2
 * Turn on interactive prompting
 * during mget, mput, and mdelete.
d851 57
a907 2
 * Toggle metacharacter interpretation
 * on local file names.
d933 1
a933 2
 * Set debugging mode on/off and/or
 * set level of debugging.
d974 1
a974 2
 * Set current working directory
 * on remote machine.
d1000 1
a1000 2
 * Set current working directory
 * on local machine.
d1008 1
d1017 1
d1025 6
a1030 1
		return;
d1032 2
a1033 5
	if (getcwd(buf, sizeof(buf)) != NULL)
		fprintf(ttyout, "Local directory now %s\n", buf);
	else
		warn("getcwd: %s", argv[1]);
	code = 0;
d1117 1
a1117 2
 * Get a directory listing
 * of remote files.
d1125 1
d1137 1
d1142 5
a1146 5
	if (strcmp(argv[2], "-") && *argv[2] != '|')
		if (!globulize(&argv[2]) || !confirm("output to local-file:",
		    argv[2])) {
			code = -1;
			return;
d1148 1
a1148 1
	recvrequest(cmd, argv[2], argv[1], "w", 0);
d1152 5
d1160 1
a1160 2
 * Get a directory listing
 * of multiple remote files.
d1170 1
a1170 1
	char mode[1], *dest;
d1180 1
a1180 1
	dest = argv[argc - 1];
d1195 2
a1196 1
		recvrequest(dolist ? "LIST" : "NLST", dest, argv[i], mode, 0);
d1208 2
d1989 3
a1991 1
/* restart transfer at specific point */
d2007 3
a2009 1
/* show remote system type */
d2081 1
a2081 1
 * get size of file on remote machine
d2102 1
a2102 1
 * get last modification time of file on remote machine
d2123 1
a2123 1
 * show status on remote machine
d2135 1
a2135 1
 * get file if modtime is more recent than current file
d2157 1
a2157 1
	char *p, *pager;
d2164 1
d2180 1
a2180 1
	recvrequest("RETR", pager, argv[1], "r+w", 1);
d2185 2
@


1.21
log
@Updates from NetBSD (lukem) include -Wall cleanup.
More -W* cleanup and in_port_t usage by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.20 1997/04/23 20:32:57 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.20 1997/04/23 20:32:57 deraadt Exp $";
d1925 2
a1926 2
		fprintf(ttyout, "Restarting at %qd. Execute get, put or append to"
			"initiate transfer\n", (quad_t)restart_point);
@


1.20
log
@allow "ftp -aV ftp://host/foo.tar.gz | tar xvfpz -" to work
@
text
@d1 2
a2 2
/*	$OpenBSD: cmds.c,v 1.19 1997/04/16 05:02:39 millert Exp $	*/
/*	$NetBSD: cmds.c,v 1.23 1997/04/14 09:09:15 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.19 1997/04/16 05:02:39 millert Exp $";
d343 1
a343 1
						while ((*tp2 = *tp) != NULL) {
d486 1
a486 1
			while ((*tp2 = *tp) != NULL) {
d586 1
a586 1
				for (tp2 = tmpbuf; (ch = *tp++) != NULL; )
d591 1
a591 1
			if (ntflag) {
d593 1
a593 2
			}
			if (mapflag) {
a594 1
			}
a875 2
	int val;

d886 7
a892 3
			val = atoi(argv[1]);
			if (val < 0) {
				fprintf(ttyout, "%s: bad debugging value.\n", argv[1]);
d896 1
a896 1
			debug = val;
d1097 1
a1097 1
	const char *cmd;
d1116 1
a1116 1
	cmd = strcmp(argv[0], "mls") == 0 ? "NLST" : "LIST";
d1123 1
a1123 1
		recvrequest(cmd, dest, argv[i], mode, 0);
d1171 1
a1171 1
			fputs("\n", ttyout);
d1926 1
a1926 1
			"initiate transfer\n", restart_point);
@


1.19
log
@Sync with NetBSD (lukem):
 * differentiate between being connected, and being logged in
 * cleanup some text messages
 * support username & password ftp URLs (ftp://user:pass@@host/) in non-proxy
   situations; assume proxy supports it for proxy situations.
 * cd to / before performing any autofetch transfers
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.18 1997/04/10 00:17:07 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.18 1997/04/10 00:17:07 millert Exp $";
d98 1
a98 1
		printf("usage: %s [", argv[0]);
d101 1
a101 1
			printf("%s%s", sep, p->t_name);
d104 1
a104 1
		puts(" ]");
d109 1
a109 1
		printf("Using %s mode to transfer files.\n", typename);
d117 1
a117 1
		printf("%s: unknown mode.\n", argv[1]);
d223 1
a223 1
	printf("We only support %s mode, sorry.\n", modename);
d237 1
a237 1
	printf("We only support %s format, sorry.\n", formname);
d251 1
a251 1
	printf("We only support %s structure, sorry.\n", structname);
d276 1
a276 1
		printf("usage: %s local-file [ remote-file ]\n", argv[0]);
d318 1
a318 1
		printf("usage: %s local-files\n", argv[0]);
d467 1
a467 1
		printf("usage: %s remote-file [ local-file ]\n", argv[0]);
d538 2
a539 2
	putchar('\n');
	(void)fflush(stdout);
d570 1
a570 1
		printf("usage: %s remote-files\n", argv[0]);
d633 1
a633 1
		printf("Connected %sto %s.\n",
d636 1
a636 1
		puts("Not connected.");
d640 1
a640 1
			printf("Connected for proxy commands to %s.\n",
d644 1
a644 1
			puts("No proxy connection.");
d648 2
a649 2
	printf("Passive mode: %s.\n", onoff(passivemode));
	printf("Mode: %s; Type: %s; Form: %s; Structure: %s.\n",
d651 1
a651 1
	printf("Verbose: %s; Bell: %s; Prompting: %s; Globbing: %s.\n",
d654 1
a654 1
	printf("Store unique: %s; Receive unique: %s.\n", onoff(sunique),
d656 2
a657 2
	printf("Preserve modification times: %s.\n", onoff(preserve));
	printf("Case: %s; CR stripping: %s.\n", onoff(mcase), onoff(crflag));
d659 1
a659 1
		printf("Ntrans: (in) %s (out) %s\n", ntin, ntout);
d662 1
a662 1
		puts("Ntrans: off.");
d665 1
a665 1
		printf("Nmap: (in) %s (out) %s\n", mapin, mapout);
d668 1
a668 1
		puts("Nmap: off.");
d670 1
a670 1
	printf("Hash mark printing: %s; Mark count: %d; Progress bar: %s.\n",
d672 1
a672 1
	printf("Use of PORT cmds: %s.\n", onoff(sendport));
d674 1
a674 1
	printf("Command line editing: %s.\n", onoff(editing));
d677 1
a677 1
		puts("Macros:");
d679 1
a679 1
			printf("\t%s\n", macros[i].mac_name);
d702 1
a702 1
		printf("usage: %s [ on | off ]\n", argv[0]);
d706 1
a706 1
		printf("%s %s.\n", mesg, onoff(*var));
d764 1
a764 1
		printf("usage: %s [ on | off | bytecount ]\n", argv[0]);
d774 1
a774 1
			printf("%s: bad bytecount value.\n", argv[1]);
d781 1
a781 1
	printf("Hash mark printing %s", onoff(hash));
d783 2
a784 2
		printf(" (%d bytes/hash mark)", mark);
	puts(".");
d881 1
a881 1
		printf("usage: %s [ on | off | debuglevel ]\n", argv[0]);
d892 1
a892 1
				printf("%s: bad debugging value.\n", argv[1]);
d904 1
a904 1
	printf("Debugging %s (debug=%d).\n", onoff(debug), debug);
d921 1
a921 1
		printf("usage: %s remote-directory\n", argv[0]);
d928 1
a928 1
			puts("CWD command not recognized, trying XCWD.");
d949 1
a949 1
		printf("usage: %s local-directory\n", argv[0]);
d963 1
a963 1
		printf("Local directory now %s\n", buf);
d979 1
a979 1
		printf("usage: %s remote-file\n", argv[0]);
d999 1
a999 1
		printf("usage: %s remote-files\n", argv[0]);
d1041 1
a1041 1
		printf("usage: %s from-name to-name\n", argv[0]);
d1065 1
a1065 1
		printf("usage: %s remote-directory local-file\n", argv[0]);
d1083 1
a1083 1
	fflush(stdout);
d1104 1
a1104 1
		printf("usage: %s remote-files local-file\n", argv[0]);
d1170 3
a1172 2
			puts(shell);
			(void)fflush(stdout);
d1212 1
a1212 1
		printf("usage: %s username [password] [account]\n", argv[0]);
d1224 2
a1225 2
			(void)fputs("Account: ", stdout);
			(void)fflush(stdout);
d1234 1
a1234 1
		puts("Login failed.");
d1259 1
a1259 1
		puts("PWD command not recognized, trying XPWD.");
d1276 1
a1276 1
		printf("Local directory %s\n", buf);
d1293 1
a1293 1
		printf("usage: %s directory-name\n", argv[0]);
d1299 1
a1299 1
			puts("MKD command not recognized, trying XMKD.");
d1315 1
a1315 1
		printf("usage: %s directory-name\n", argv[0]);
d1321 1
a1321 1
			puts("RMD command not recognized, trying XRMD.");
d1336 1
a1336 1
		printf("usage: %s line-to-send\n", argv[0]);
d1355 1
a1355 1
		printf("usage: %s line-to-send\n", argv[0]);
d1403 1
a1403 1
		printf("usage: %s mode file-name\n", argv[0]);
d1499 1
a1499 1
		printf("usage: %s [password]\n", argv[0]);
d1541 1
a1541 1
		printf("usage: %s command\n", argv[0]);
d1547 2
a1548 2
		puts("?Ambiguous command.");
		(void)fflush(stdout);
d1553 2
a1554 2
		puts("?Invalid command.");
		(void)fflush(stdout);
d1559 2
a1560 2
		puts("?Invalid proxy command.");
		(void)fflush(stdout);
d1571 2
a1572 2
		puts("Not connected.");
		(void)fflush(stdout);
d1617 1
a1617 1
		puts("Ntrans off.");
d1671 1
a1671 1
		puts("Nmap off.");
d1676 1
a1676 1
		printf("usage: %s [mapin mapout]\n", argv[0]);
d1806 2
a1807 2
						puts(
"nmap: unbalanced brackets.");
d1820 2
a1821 2
						puts(
"nmap: unbalanced brackets.");
d1907 1
a1907 1
			puts("CDUP command not recognized, trying XCUP.");
d1922 1
a1922 1
		puts("restart: offset not specified.");
d1925 1
a1925 1
		printf("Restarting at %qd. Execute get, put or append to"
d1949 1
a1949 1
		puts("Limit of 16 macros have already been defined.");
d1954 1
a1954 1
		printf("usage: %s macro_name\n", argv[0]);
d1959 2
a1960 2
		puts(
"Enter macro line by line, terminating it with a null line.");
d1971 1
a1971 1
			puts("macdef: end of file encountered.");
d1994 1
a1994 1
			puts("Macro not defined - 4K buffer exceeded.");
d2012 1
a2012 1
		printf("usage: %s filename\n", argv[0]);
d2018 1
a2018 1
		printf("%s\t%qd\n", argv[1], size);
d2033 1
a2033 1
		printf("usage: %s filename\n", argv[0]);
d2039 1
a2039 1
		printf("%s\t%s", argv[1], asctime(localtime(&mtime)));
d2065 1
a2065 1
		printf("Local file \"%s\" is newer than remote file \"%s\".\n",
d2081 1
a2081 1
		printf("usage: %s filename\n", argv[0]);
@


1.18
log
@Sync with NetBSD (lukem)
    * support $ftp_proxy for ftp:// transfers [bin/3245]
    * add "more" & "less" as synonyms for "page"
    * move editline setup code into controlediting(), and call appropriately.
      only setup setup terminal if going into interactive mode.
@
text
@d1 2
a2 2
/*	$OpenBSD: cmds.c,v 1.17 1997/03/21 20:59:26 millert Exp $	*/
/*	$NetBSD: cmds.c,v 1.22 1997/04/05 03:27:32 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.17 1997/03/21 20:59:26 millert Exp $";
d633 2
a634 1
		printf("Connected to %s.\n", hostname);
d1239 1
@


1.17
log
@Add in recent NetBSD changes we didn't already have:
    Always compile complete.c but ifdef out the bits if -DSMALL (christos)
    reset interactive mode correctly in auto_fetch() mget mode (lukem)
@
text
@d1 2
a2 2
/*	$OpenBSD: cmds.c,v 1.16 1997/03/14 04:32:12 millert Exp $	*/
/*	$NetBSD: cmds.c,v 1.21 1997/03/16 14:24:14 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.16 1997/03/14 04:32:12 millert Exp $";
d734 1
@


1.16
log
@Sync with NetBSD and fix "get foo.txt /dev/tty" wrt progress meter
and setting times.
@
text
@d1 2
a2 2
/*	$OpenBSD: cmds.c,v 1.15 1997/02/05 04:55:12 millert Exp $	*/
/*	$NetBSD: cmds.c,v 1.19 1997/03/13 06:23:11 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.15 1997/02/05 04:55:12 millert Exp $";
d672 1
a672 1
#ifndef SMALLFTP
d674 1
a674 1
#endif /* !SMALLFTP */
d722 1
a722 1
#ifndef SMALLFTP
d735 1
a735 1
#endif /* !SMALLFTP */
@


1.15
log
@Include signal.h where reasonable and make signal handlers match
what signal(3)'s prototype says (and cast when not).
Also change MAXFOO+1 -> MAXFOO since MAXFOO includes the NULL.
Support $TMPDIR and use utime(3) not utimes(2) for portability's sake.
Don't spew "Passive mode enabled/disabled" unless verbose (this means
togglevar() needs to watch for a NULL 'message').
@
text
@d1 2
a2 2
/*	$OpenBSD: cmds.c,v 1.14 1997/02/03 01:05:33 millert Exp $	*/
/*	$NetBSD: cmds.c,v 1.18 1997/02/01 10:44:54 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.14 1997/02/03 01:05:33 millert Exp $";
d117 1
a117 1
		printf("%s: unknown mode\n", argv[1]);
d153 1
a153 1
		printf("ftp: internal error: unknown type %d\n", newtype);
d329 1
a329 1
		while ((cp = remglob(argv, 0)) != NULL) {
d578 1
a578 1
	while ((cp = remglob(argv, proxy)) != NULL) {
d648 1
a648 1
	printf("Mode: %s; Type: %s; Form: %s; Structure: %s\n",
d650 1
a650 1
	printf("Verbose: %s; Bell: %s; Prompting: %s; Globbing: %s\n",
d653 1
a653 1
	printf("Store unique: %s; Receive unique: %s\n", onoff(sunique),
d655 2
a656 2
	printf("Preserve modification times: %s\n", onoff(preserve));
	printf("Case: %s; CR stripping: %s\n", onoff(mcase), onoff(crflag));
d661 1
a661 1
		puts("Ntrans: off");
d667 1
a667 1
		puts("Nmap: off");
d669 1
a669 1
	printf("Hash mark printing: %s; Mark count: %d; Progress bar: %s\n",
d671 1
a671 1
	printf("Use of PORT cmds: %s\n", onoff(sendport));
d673 1
a673 1
	printf("Command line editing: %s\n", onoff(editing));
d702 1
a702 1
		return -1;
d772 1
a772 1
			printf("%s: bad bytecount value\n", argv[1]);
d926 1
a926 1
			puts("CWD command not recognized, trying XCWD");
d1005 1
a1005 1
	while ((cp = remglob(argv, 0)) != NULL) {
d1039 1
a1039 1
		printf("%s from-name to-name\n", argv[0]);
d1187 1
a1187 1
		warn("%s", "Try again later");
d1255 1
a1255 1
		puts("PWD command not recognized, trying XPWD");
d1295 1
a1295 1
			puts("MKD command not recognized, trying XMKD");
d1317 1
a1317 1
			puts("RMD command not recognized, trying XRMD");
d1375 2
a1376 1
		len += strlen(strncpy(&buf[len], argv[1], sizeof(buf) - len - 1));
d1543 1
a1543 1
		puts("?Ambiguous command");
d1549 1
a1549 1
		puts("?Invalid command");
d1555 1
a1555 1
		puts("?Invalid proxy command");
d1567 1
a1567 1
		puts("Not connected");
d1672 1
a1672 1
		printf("Usage: %s [mapin mapout]\n", argv[0]);
d1802 2
a1803 1
						puts("nmap: unbalanced brackets");
d1816 2
a1817 1
						puts("nmap: unbalanced brackets");
d1903 1
a1903 1
			puts("CDUP command not recognized, trying XCUP");
d1918 1
a1918 1
		puts("restart: offset not specified");
d1945 1
a1945 1
		puts("Limit of 16 macros have already been defined");
d1950 1
a1950 1
		printf("Usage: %s macro_name\n", argv[0]);
d1954 3
a1956 3
	if (interactive) {
		puts("Enter macro line by line, terminating it with a null line");
	}
d1967 1
a1967 1
			puts("macdef: end of file encountered");
d1990 1
a1990 1
			puts("Macro not defined - 4k buffer exceeded");
d2061 1
a2061 1
		printf("Local file \"%s\" is newer than remote file \"%s\"\n",
d2063 38
@


1.14
log
@Add back ``-r'' option and fix strncpy() usage and other nits because
I'm anal.  Closer to KNF now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.18 1997/02/01 10:44:54 lukem Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.18 1997/02/01 10:44:54 lukem Exp $";
d122 1
a122 1
		comret = command ("TYPE %s %s", p->t_mode, p->t_arg);
d704 2
a705 1
	printf("%s %s.\n", mesg, onoff(*var));
d1508 2
a1509 1
proxabort()
d1867 2
a1868 1
	code = togglevar(argc, argv, &passivemode, "Passive mode");
@


1.13
log
@Sync with NetBSD
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: cmds.c,v 1.18 1997/02/01 10:44:54 lukem Exp $";
d104 1
a104 1
		printf(" ]\n");
d126 1
a126 1
		(void) strcpy(typename, p->t_name);
d325 1
a325 1
	(void) setjmp(jabort);
d371 1
a371 1
		(void) signal(SIGINT, oldintr);
d423 1
a423 1
	(void) signal(SIGINT, oldintr);
d433 1
a433 1
	(void) getit(argc, argv, 1, "r+w");
d442 1
a442 1
	(void) getit(argc, argv, 0, restart_point ? "r+w" : "w" );
d538 2
a539 2
	printf("\n");
	(void) fflush(stdout);
d577 1
a577 1
	(void) setjmp(jabort);
d609 1
a609 1
	(void) signal(SIGINT, oldintr);
d635 1
a635 1
		printf("Not connected.\n");
d643 1
a643 1
			printf("No proxy connection.\n");
d661 1
a661 1
		printf("Ntrans: off\n");
d667 1
a667 1
		printf("Nmap: off\n");
d676 1
a676 1
		printf("Macros:\n");
d705 1
a705 1
	return *var;
d781 1
a781 1
	printf(".\n");
d925 1
a925 1
			printf("CWD command not recognized, trying XCWD\n");
d980 1
a980 1
	(void) command("DELE %s", argv[1]);
d1003 1
a1003 1
	(void) setjmp(jabort);
d1010 1
a1010 1
			(void) command("DELE %s", cp);
d1021 1
a1021 1
	(void) signal(SIGINT, oldintr);
d1043 1
a1043 1
		(void) command("RNTO %s", argv[2]);
d1117 1
a1117 1
	(void) setjmp(jabort);
d1130 1
a1130 1
	(void) signal(SIGINT, oldintr);
d1152 3
a1154 3
			(void) close(pid);
		(void) signal(SIGINT, SIG_DFL);
		(void) signal(SIGQUIT, SIG_DFL);
d1162 2
a1163 1
		(void) strncpy(shellnam + 1, ++namep, sizeof(shellnam) - 1);
d1167 2
a1168 2
			printf ("%s\n", shell);
			(void) fflush (stdout);
d1183 2
a1184 2
	(void) signal(SIGINT, old1);
	(void) signal(SIGQUIT, old2);
d1206 1
a1206 1
		(void) another(&argc, &argv, "username");
d1220 3
a1222 2
			printf("Account: "); (void) fflush(stdout);
			(void) fgets(acct, sizeof(acct) - 1, stdin);
d1230 1
a1230 1
		fprintf(stdout, "Login failed.\n");
d1234 1
a1234 1
		(void) command("ACCT %s", argv[3]);
d1254 2
a1255 2
		printf("PWD command not recognized, trying XPWD\n");
		(void) command("XPWD");
d1294 2
a1295 2
			printf("MKD command not recognized, trying XMKD\n");
		(void) command("XMKD %s", argv[1]);
d1316 2
a1317 2
			printf("RMD command not recognized, trying XRMD\n");
		(void) command("XRMD %s", argv[1]);
d1370 2
a1371 1
	(void) strncpy(buf, initial, sizeof(buf));
d1374 2
a1375 2
		len += strlen(strncpy(&buf[len], argv[1], sizeof(buf) - len));
		for (i = 2; i < argc; i++) {
d1378 1
a1378 1
			    sizeof(buf) - len));
d1401 1
a1401 1
	(void) command("SITE CHMOD %s %s", argv[1], argv[2]);
d1412 1
a1412 1
	(void) command(argc == 1 ? "SITE UMASK" : "SITE UMASK %s", argv[1]);
d1424 1
a1424 1
	(void) command(argc == 1 ? "SITE IDLE" : "SITE IDLE %s", argv[1]);
d1439 1
a1439 1
	(void) command(argc == 1 ? "HELP" : "HELP %s", argv[1]);
d1473 1
a1473 1
	(void) command("QUIT");
d1475 1
a1475 1
		(void) fclose(cout);
d1501 1
a1501 1
	(void) command("ACCT %s", ap);
d1540 2
a1541 2
		printf("?Ambiguous command\n");
		(void) fflush(stdout);
d1546 2
a1547 2
		printf("?Invalid command\n");
		(void) fflush(stdout);
d1552 2
a1553 2
		printf("?Invalid proxy command\n");
		(void) fflush(stdout);
d1564 2
a1565 2
		printf("Not connected\n");
		(void) fflush(stdout);
d1567 1
a1567 1
		(void) signal(SIGINT, oldintr);
d1582 1
a1582 1
	(void) signal(SIGINT, oldintr);
d1610 1
a1610 1
		printf("Ntrans off.\n");
d1616 2
a1617 2
	(void) strncpy(ntin, argv[1], 16);
	ntin[16] = '\0';
d1622 2
a1623 2
	(void) strncpy(ntout, argv[2], 16);
	ntout[16] = '\0';
d1664 1
a1664 1
		printf("Nmap off.\n");
d1683 1
a1683 1
	(void) strncpy(mapin, altarg, MAXPATHLEN - 1);
d1686 1
a1686 1
	(void) strncpy(mapout, cp, MAXPATHLEN - 1);
d1799 1
a1799 2
						printf("nmap: unbalanced "
							"brackets\n");
d1812 1
a1812 2
						printf("nmap: unbalanced "
							"brackets\n");
d1897 1
a1897 1
			printf("CDUP command not recognized, trying XCUP\n");
d1912 1
a1912 1
		printf("restart: offset not specified\n");
d1927 1
a1927 1
	(void) command("SYST");
d1939 1
a1939 1
		printf("Limit of 16 macros have already been defined\n");
d1949 1
a1949 2
		printf("Enter macro line by line, terminating it with a "
			"null line\n");
d1951 4
a1954 2
	(void) strncpy(macros[macnum].mac_name, argv[1], 8);
	if (macnum == 0) {
d1956 1
a1956 2
	}
	else {
a1957 1
	}
d1961 1
a1961 1
			printf("macdef:end of file encountered\n");
d1984 1
a1984 1
			printf("Macro not defined - 4k buffer exceeded\n");
d2042 1
a2042 1
	(void) command(argc > 1 ? "STAT %s" : "STAT" , argv[1]);
@


1.12
log
@only print passive toggle info is verbose set (like other commands)
@
text
@d1 1
a1 2
/*      $OpenBSD: cmds.c,v 1.11 1997/01/28 20:48:40 millert Exp $      */
/*      $NetBSD: cmds.c,v 1.8 1995/09/08 01:06:05 tls Exp $      */
d40 1
a40 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.11 1997/01/28 20:48:40 millert Exp $";
d47 3
a49 1
#include <sys/param.h>
a50 3
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
a56 1
#include <signal.h>
a59 1
#include <time.h>
a60 1
#include <fcntl.h>
a68 141
/*
 * `Another' gets another argument, and stores the new argc and argv.
 * It reverts to the top level (via main.c's intr()) on EOF/error.
 *
 * Returns false if no new arguments have been added.
 */
int
another(pargc, pargv, prompt)
	int *pargc;
	char ***pargv;
	char *prompt;
{
	int len = strlen(line), ret;

	if (len >= sizeof(line) - 3) {
		printf("sorry, arguments too long\n");
		intr();
	}
	printf("(%s) ", prompt);
	line[len++] = ' ';
	if (fgets(&line[len], sizeof(line) - len, stdin) == NULL)
		intr();
	len += strlen(&line[len]);
	if (len > 0 && line[len - 1] == '\n')
		line[len - 1] = '\0';
	makeargv();
	ret = margc > *pargc;
	*pargc = margc;
	*pargv = margv;
	return (ret);
}

/*
 * Connect to peer server and
 * auto-login, if possible.
 */
void
setpeer(argc, argv)
	int argc;
	char *argv[];
{
	char *host;
	short port;

	if (connected) {
		printf("Already connected to %s, use close first.\n",
			hostname);
		code = -1;
		return;
	}
	if (argc < 2)
		(void) another(&argc, &argv, "to");
	if (argc < 2 || argc > 3) {
		printf("usage: %s host-name [port]\n", argv[0]);
		code = -1;
		return;
	}
	port = sp->s_port;
	if (argc > 2) {
		port = atoi(argv[2]);
		if (port <= 0) {
			printf("%s: bad port number-- %s\n", argv[1], argv[2]);
			printf ("usage: %s host-name [port]\n", argv[0]);
			code = -1;
			return;
		}
		port = htons(port);
	}
	host = hookup(argv[1], port);
	if (host) {
		int overbose;

		connected = 1;
		/*
		 * Set up defaults for FTP.
		 */
		(void) strcpy(typename, "ascii"), type = TYPE_A;
		curtype = TYPE_A;
		(void) strcpy(formname, "non-print"), form = FORM_N;
		(void) strcpy(modename, "stream"), mode = MODE_S;
		(void) strcpy(structname, "file"), stru = STRU_F;
		(void) strcpy(bytename, "8"), bytesize = 8;
		if (autologin)
			(void) login(argv[1]);

#if defined(unix) && NBBY == 8
/*
 * this ifdef is to keep someone form "porting" this to an incompatible
 * system and not checking this out. This way they have to think about it.
 */
		overbose = verbose;
		if (debug == 0)
			verbose = -1;
		if (command("SYST") == COMPLETE && overbose) {
			char *cp, c;
			cp = strchr(reply_string+4, ' ');
			if (cp == NULL)
				cp = strchr(reply_string+4, '\r');
			if (cp) {
				if (cp[-1] == '.')
					cp--;
				c = *cp;
				*cp = '\0';
			}

			printf("Remote system type is %s.\n",
				reply_string+4);
			if (cp)
				*cp = c;
		}
		if (!strncmp(reply_string, "215 UNIX Type: L8", 17)) {
			if (proxy)
				unix_proxy = 1;
			else
				unix_server = 1;
			/*
			 * Set type to 0 (not specified by user),
			 * meaning binary by default, but don't bother
			 * telling server.  We can use binary
			 * for text files unless changed by the user.
			 */
			type = 0;
			(void) strcpy(typename, "binary");
			if (overbose)
			    printf("Using %s mode to transfer files.\n",
				typename);
		} else {
			if (proxy)
				unix_proxy = 0;
			else
				unix_server = 0;
			if (overbose && 
			    !strncmp(reply_string, "215 TOPS20", 10))
				printf(
"Remember to set tenex mode when transfering binary files from this machine.\n");
		}
		verbose = overbose;
#endif /* unix */
	}
}

d177 1
a177 1
	char **argv;
d273 1
a273 1
	if (argc < 3 && !another(&argc, &argv, "remote-file")) {
d275 1
a275 1
		printf("usage: %s local-file remote-file\n", argv[0]);
d309 1
a309 1
	char **argv;
d328 2
a329 2
		while ((cp = remglob(argv,0)) != NULL) {
			if (*cp == 0) {
d363 1
a363 1
					if (confirm("Continue with","mput")) {
d375 1
a375 1
		char **cpp, **gargs;
d388 1
a388 1
					if (confirm("Continue with","mput")) {
d413 1
a413 1
					if (confirm("Continue with","mput")) {
a450 1
	char *mode;
d452 1
d464 1
a464 1
	if (argc < 3 && !another(&argc, &argv, "local-file")) {
d512 1
a512 1
				int overbose;
d514 2
a515 28
				overbose = verbose;
				if (debug == 0)
					verbose = -1;
				if (command("MDTM %s", argv[1]) == COMPLETE) {
					int yy, mo, day, hour, min, sec;
					struct tm *tm;
					verbose = overbose;
					sscanf(reply_string,
					    "%*s %04d%02d%02d%02d%02d%02d",
					    &yy, &mo, &day, &hour, &min, &sec);
					tm = gmtime(&stbuf.st_mtime);
					tm->tm_mon++;
					if (tm->tm_year > yy%100)
						return (1);
					if ((tm->tm_year == yy%100 && 
					    tm->tm_mon > mo) ||
					   (tm->tm_mon == mo && 
					    tm->tm_mday > day) ||
					   (tm->tm_mday == day && 
					    tm->tm_hour > hour) ||
					   (tm->tm_hour == hour && 
					    tm->tm_min > min) ||
					   (tm->tm_min == min && 
					    tm->tm_sec > sec))
						return (1);
				} else {
					printf("%s\n", reply_string);
					verbose = overbose;
d517 2
a518 1
				}
d534 1
a534 1
	int ointer;
d536 1
d541 1
d543 1
d546 2
a547 1
			longjmp(jabort,0);
d550 1
d553 1
a553 1
	longjmp(jabort,0);
d562 1
a562 1
	char **argv;
d577 1
a577 1
	while ((cp = remglob(argv,proxy)) != NULL) {
d585 1
a585 1
				for (tp2 = tmpbuf; ch = *tp++;)
d601 1
a601 1
				if (confirm("Continue with","mget")) {
d608 1
a608 1
	(void) signal(SIGINT,oldintr);
a612 67
remglob(argv,doswitch)
	char *argv[];
	int doswitch;
{
	char temp[16];
	static char buf[MAXPATHLEN];
	static FILE *ftemp = NULL;
	int fd; 
	static char **args;
	int oldverbose, oldhash;
	char *cp, *mode;

	if (!mflag) {
		if (!doglob) {
			args = NULL;
		}
		else {
			if (ftemp) {
				(void) fclose(ftemp);
				ftemp = NULL;
			}
		}
		return (NULL);
	}
	if (!doglob) {
		if (args == NULL)
			args = argv;
		if ((cp = *++args) == NULL)
			args = NULL;
		return (cp);
	}
	if (ftemp == NULL) {
		(void) strcpy(temp, _PATH_TMPFILE);
		fd = mkstemp(temp);
		if (fd < 0) {
			printf ("temporary file %s already exists\n", temp);
			return NULL;
		}
		close (fd);
		oldverbose = verbose, verbose = 0;
		oldhash = hash, hash = 0;
		if (doswitch) {
			pswitch(!proxy);
		}
		for (mode = "w"; *++argv != NULL; mode = "a")
			recvrequest ("NLST", temp, *argv, mode, 0);
		if (doswitch) {
			pswitch(!proxy);
		}
		verbose = oldverbose; hash = oldhash;
		ftemp = fopen(temp, "r");
		(void) unlink(temp);
		if (ftemp == NULL) {
			printf("can't find list of remote files, oops\n");
			return (NULL);
		}
	}
	if (fgets(buf, sizeof (buf), ftemp) == NULL) {
		(void) fclose(ftemp), ftemp = NULL;
		return (NULL);
	}
	if ((cp = strchr(buf, '\n')) != NULL)
		*cp = '\0';
	return (buf);
}

char *
d638 2
a639 1
			printf("Connected for proxy commands to %s.\n", hostname);
d646 1
d649 1
a649 1
	printf("Verbose: %s; Bell: %s; Prompting: %s; Globbing: %s\n", 
d654 2
a655 1
	printf("Case: %s; CR stripping: %s\n",onoff(mcase),onoff(crflag));
d657 1
a657 1
		printf("Ntrans: (in) %s (out) %s\n", ntin,ntout);
d668 2
a669 1
	printf("Hash mark printing: %s; Mark count: %d\n", onoff(hash), mark);
d671 3
d677 1
a677 1
			printf("\t%s\n",macros[i].mac_name);
d684 24
d717 1
a717 3
	bell = !bell;
	printf("Bell mode %s.\n", onoff(bell));
	code = bell;
d720 1
d722 1
a722 1
 * Turn on packet tracing.
d726 1
a726 1
settrace(argc, argv)
d731 1
a731 3
	trace = !trace;
	printf("Packet tracing %s.\n", onoff(trace));
	code = trace;
d733 1
d736 1
a736 1
 * Toggle hash mark printing during transfers.
d740 3
a742 1
togglehash()
d745 1
a745 6
	hash = !hash;
	printf("Hash mark printing %s", onoff(hash));
	code = hash;
	if (hash)
		printf(" (%d bytes/hash mark)", mark);
	printf(".\n");
d749 1
a749 1
 * Set hash mark bytecount.
d758 1
a758 1
		togglehash();
d760 8
a767 2
		printf("usage: %s [number of bytes].\n", argv[0]);
	} else {
d770 3
a772 5
			printf("A hash mark bytecount of %d %s",
			       nmark, "is rather pointless...\n");
		} else {
			mark = nmark;
			printf("Hash mark set to %d bytes/hash mark\n", mark);
d774 2
d777 5
a783 1

d794 1
a794 3
	verbose = !verbose;
	printf("Verbose mode %s.\n", onoff(verbose));
	code = verbose;
d807 14
a820 3
	sendport = !sendport;
	printf("Use of PORT cmds %s.\n", onoff(sendport));
	code = sendport;
d834 1
a834 3
	interactive = !interactive;
	printf("Interactive mode %s.\n", onoff(interactive));
	code = interactive;
d847 15
a861 4
	
	doglob = !doglob;
	printf("Globbing %s.\n", onoff(doglob));
	code = doglob;
d876 17
a892 6
	if (argc > 1) {
		val = atoi(argv[1]);
		if (val < 0) {
			printf("%s: bad debugging value.\n", argv[1]);
			code = -1;
			return;
d895 1
a895 2
		val = !debug;
	debug = val;
d908 2
a909 2
int
mcd(argc, argv)
d913 1
d915 2
a916 1
	if (argc < 2 && !another(&argc, &argv, "remote-directory")) {
d919 1
a919 1
		return (-1);
d921 5
a925 9
	if (command("CWD %s", argv[1]) == ERROR) {
		if (code == 500) {
			if (verbose)
		  		printf("CWD command not recognized, "
				       "trying XCWD\n");
			return(command("XCWD %s", argv[1]));
		}
		else
			return(-1);
d927 2
a928 9
	return(0);
}

void
cd(argc, argv)
	int argc;
	char *argv[];
{
	mcd(argc, argv);
d961 1
a961 1
		warnx("getcwd: %s", buf);
d974 1
a974 1
	if (argc < 2 && !another(&argc, &argv, "remote-file")) {
d988 1
a988 1
	char **argv;
d1003 1
a1003 1
	while ((cp = remglob(argv,0)) != NULL) {
d1035 1
a1035 1
	if (argc < 3 && !another(&argc, &argv, "to-name")) {
d1054 1
a1054 1
	char *cmd;
d1065 1
a1065 1
	cmd = argv[0][0] == 'n' ? "NLST" : "LIST";
d1071 2
a1072 1
		if (!globulize(&argv[2]) || !confirm("output to local-file:", argv[2])) {
d1089 1
a1089 1
	char **argv;
d1093 2
a1094 1
	char *cmd, mode[1], *dest;
d1112 1
a1112 1
	cmd = argv[0][1] == 'l' ? "NLST" : "LIST";
d1140 1
a1140 1
	char **argv;
d1144 1
a1144 1
	char shellnam[40], *shell, *namep; 
d1157 1
a1157 1
		namep = strrchr(shell,'/');
d1160 2
a1161 2
		(void) strcpy(shellnam,"-");
		(void) strcat(shellnam, ++namep);
d1169 1
a1169 1
			execl(shell,shellnam,"-c",altarg,(char *)0);
d1172 1
a1172 1
			execl(shell,shellnam,(char *)0);
d1198 1
a1198 1
	char **argv;
d1236 1
a1236 1
 * Print working directory.
d1258 17
d1283 2
a1284 1
	if (argc < 2 && !another(&argc, &argv, "directory-name")) {
d1305 2
a1306 1
	if (argc < 2 && !another(&argc, &argv, "directory-name")) {
d1360 1
a1360 1
	char *initial;
d1362 1
a1362 1
	char **argv;
d1367 1
a1367 1
	(void) strcpy(buf, initial);
d1370 1
a1370 1
		len += strlen(strcpy(&buf[len], argv[1]));
d1373 2
a1374 1
			len += strlen(strcpy(&buf[len], argv[i]));
d1391 1
a1391 1
	if (argc < 3 && !another(&argc, &argv, "file-name")) {
a1480 15
int
confirm(cmd, file)
	char *cmd, *file;
{
	char line[BUFSIZ];

	if (!interactive)
		return (1);
	printf("%s %s? ", cmd, file);
	(void) fflush(stdout);
	if (fgets(line, sizeof line, stdin) == NULL)
		return (0);
	return (*line != 'n' && *line != 'N');
}

d1482 1
a1482 38
fatal(msg)
	char *msg;
{

	errx(1, "%s", msg);
}

/*
 * Glob a local file name specification with
 * the expectation of a single return value.
 * Can't control multiple values being expanded
 * from the expression, we return only the first.
 */
int
globulize(cpp)
	char **cpp;
{
	glob_t gl;
	int flags;

	if (!doglob)
		return (1);

	flags = GLOB_BRACE|GLOB_NOCHECK|GLOB_QUOTE|GLOB_TILDE;
	memset(&gl, 0, sizeof(gl));
	if (glob(*cpp, flags, NULL, &gl) ||
	    gl.gl_pathc == 0) {
		warnx("%s: not found", *cpp);
		globfree(&gl);
		return (0);
	}
	*cpp = strdup(gl.gl_pathv[0]);	/* XXX - wasted memory */
	globfree(&gl);
	return (1);
}

void
account(argc,argv)
d1484 1
a1484 1
	char **argv;
d1486 1
a1486 1
	char acct[50], *ap;
d1488 4
a1491 11
	if (argc > 1) {
		++argv;
		--argc;
		(void) strncpy(acct,*argv,49);
		acct[49] = '\0';
		while (argc > 1) {
			--argc;
			++argv;
			(void) strncat(acct,*argv, 49-strlen(acct));
		}
		ap = acct;
d1493 3
a1495 1
	else {
a1496 1
	}
d1506 1
d1517 1
a1517 1
	longjmp(abortprox,1);
d1526 1
d1567 3
d1587 1
a1587 3
	mcase = !mcase;
	printf("Case mapping %s.\n", onoff(mcase));
	code = mcase;
d1596 1
a1596 3
	crflag = !crflag;
	printf("Carriage Return stripping %s.\n", onoff(crflag));
	code = crflag;
d1600 1
a1600 1
setntrans(argc,argv)
d1664 2
a1665 2
	if (argc < 3 && !another(&argc, &argv, "mapout")) {
		printf("Usage: %s [mapin mapout]\n",argv[0]);
d1747 1
a1747 1
				if (*++cp2 == '$' && isdigit(*(cp2+1))) { 
d1766 1
a1766 1
					while (*cp2 && *cp2 != ',' && 
d1795 2
a1796 1
						printf("nmap: unbalanced brackets\n");
d1809 2
a1810 1
						printf("nmap: unbalanced brackets\n");
d1863 1
a1863 4
	passivemode = !passivemode;
	if (verbose)
		printf("Passive mode %s.\n", onoff(passivemode));
	code = passivemode;
d1872 1
a1872 3
	sunique = !sunique;
	printf("Store unique %s.\n", onoff(sunique));
	code = sunique;
d1881 1
a1881 3
	runique = !runique;
	printf("Receive unique %s.\n", onoff(runique));
	code = runique;
d1884 1
a1884 1
/* change directory to perent directory */
d1890 1
d1892 2
a1893 1
	if (command("CDUP") == ERROR && code == 500) {
d1896 1
a1896 1
		(void) command("XCUP");
d1898 2
d1913 2
a1914 2
		printf("restarting at %qd. %s\n", restart_point,
		    "execute get, put or append to initiate transfer");
d1941 2
a1942 2
	if (argc < 2 && !another(&argc, &argv, "macro name")) {
		printf("Usage: %s macro_name\n",argv[0]);
d1947 2
a1948 1
		printf("Enter macro line by line, terminating it with a null line\n");
d1998 1
d2000 1
a2000 1
	if (argc < 2 && !another(&argc, &argv, "filename")) {
d2005 4
a2008 1
	(void) command("SIZE %s", argv[1]);
d2019 1
a2019 1
	int overbose;
d2021 1
a2021 1
	if (argc < 2 && !another(&argc, &argv, "filename")) {
d2026 4
a2029 13
	overbose = verbose;
	if (debug == 0)
		verbose = -1;
	if (command("MDTM %s", argv[1]) == COMPLETE) {
		int yy, mo, day, hour, min, sec;
		sscanf(reply_string, "%*s %04d%02d%02d%02d%02d%02d", &yy, &mo,
			&day, &hour, &min, &sec);
		/* might want to print this in local time */
		printf("%s\t%02d/%02d/%04d %02d:%02d:%02d GMT\n", argv[1],
			mo, day, yy, hour, min, sec);
	} else
		printf("%s\n", reply_string);
	verbose = overbose;
d2033 1
a2033 1
 * show status on reomte machine
@


1.11
log
@getcwd() not getwd()
@
text
@d1 1
a1 1
/*      $OpenBSD: cmds.c,v 1.10 1997/01/25 21:42:27 deraadt Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.10 1997/01/25 21:42:27 deraadt Exp $";
d2075 2
a2076 1
	printf("Passive mode %s.\n", onoff(passivemode));
@


1.10
log
@split cd() into two pieces, whoever was here last did a bad job
@
text
@d1 1
a1 1
/*      $OpenBSD: cmds.c,v 1.9 1996/12/24 21:22:10 deraadt Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.9 1996/12/24 21:22:10 deraadt Exp $";
d1136 1
a1136 1
	if (getwd(buf) != NULL)
d1139 1
a1139 1
		warnx("getwd: %s", buf);
@


1.9
log
@do not need umask fiddling
@
text
@d1 1
a1 1
/*      $OpenBSD: cmds.c,v 1.8 1996/12/24 20:00:04 deraadt Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.8 1996/12/24 20:00:04 deraadt Exp $";
d1078 1
a1078 1
cd(argc, argv)
d1086 1
a1086 1
		return;
d1099 8
@


1.8
log
@use mkstemp instead
@
text
@d1 1
a1 1
/*      $OpenBSD: cmds.c,v 1.7 1996/12/17 02:11:46 michaels Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.7 1996/12/17 02:11:46 michaels Exp $";
a810 2
		mode_t um;

a811 1
		um = umask(0600);
a817 1
		(void) umask(um);
@


1.7
log
@if pathname given is a valid directory, cd to it at remote, also
assume empty pathname means cd to '/', like ncftp (?).
@
text
@d1 1
a1 1
/*      $OpenBSD: cmds.c,v 1.5 1996/09/28 09:56:54 bitblt Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.5 1996/09/28 09:56:54 bitblt Exp $";
d811 2
d814 2
a815 5
		(void) mktemp(temp);
		/* create a zero-byte version of the file so that
		 * people can't play symlink games.
		*/
		fd = open (temp, O_CREAT | O_EXCL | O_WRONLY, 600);
d817 1
a817 2
			printf ("temporary file %s already exists\n",temp);
			close (fd);
d820 2
a821 1
       	       close (fd);
@


1.6
log
@optional size argument to hash command
@
text
@d1082 1
a1082 1
void
d1093 9
a1101 4
	if (command("CWD %s", argv[1]) == ERROR && code == 500) {
		if (verbose)
			printf("CWD command not recognized, trying XCWD\n");
		(void) command("XCWD %s", argv[1]);
d1103 1
@


1.5
log
@the LIST carried out by mget in remglob() no longer follows symbolic links
on its temporary file.
@
text
@d1 1
a1 1
/*      $OpenBSD: cmds.c,v 1.4 1996/09/16 02:26:06 deraadt Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.4 1996/09/16 02:26:06 deraadt Exp $";
d903 2
a904 2
	printf("Hash mark printing: %s; Use of PORT cmds: %s\n",
		onoff(hash), onoff(sendport));
d949 1
a949 3
sethash(argc, argv)
	int argc;
	char *argv[];
d956 1
a956 1
		printf(" (%d bytes/hash mark)", 1024);
d959 26
@


1.4
log
@_PATH_TMP -> _PATH_TMPFILE; avoid /tmp//fooXXXX where possible too
@
text
@d1 1
a1 1
/*      $OpenBSD: cmds.c,v 1.3 1996/09/09 04:44:38 downsj Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.3 1996/09/09 04:44:38 downsj Exp $";
d65 1
d786 1
d813 10
@


1.3
log
@Add an fflush; from FreeBSD PR# bin/1589 (msmith@@cain.atrad.adelaide.edu.au)
@
text
@d1 1
a1 1
/*      $OpenBSD: cmds.c,v 1.2 1996/06/26 05:33:33 deraadt Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.2 1996/06/26 05:33:33 deraadt Exp $";
d809 1
a809 1
		(void) strcpy(temp, _PATH_TMP);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*      $OpenBSD: cmds.c,v 1.8 1995/09/08 01:06:05 tls Exp $      */
d41 1
a41 1
static char rcsid[] = "$OpenBSD: cmds.c,v 1.8 1995/09/08 01:06:05 tls Exp $";
d1209 3
@


1.1
log
@Initial revision
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: cmds.c,v 1.8 1995/09/08 01:06:05 tls Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
