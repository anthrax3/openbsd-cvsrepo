head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.10.0.30
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.28
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.24
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.22
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.20
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.18
	OPENBSD_5_0:1.10.0.16
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.14
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.12
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.8
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.10
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.6
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.16
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.14
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.12
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.3.0.20
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.09.01.09.48.20;	author tedu;	state Exp;
branches;
next	1.13;
commitid	yelx9eGVSCXg9bi7;

1.13
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	Uu5nFG3wCl0LACBb;

1.12
date	2014.11.16.00.04.53;	author tedu;	state Exp;
branches;
next	1.11;
commitid	daQ2kI1GV56r1Dby;

1.11
date	2014.10.08.04.04.37;	author doug;	state Exp;
branches;
next	1.10;
commitid	6JpOjfjpcnaeQnMI;

1.10
date	2007.09.02.15.19.33;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.08.19.17.29;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.29.16.03.10;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.03.02.56.10;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.24.12.37.20;	author naddy;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.48;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.3;

1.3
date	97.01.17.07.12.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.10.10.09.55.08;	author michaels;	state Exp;
branches;
next	1.1;

1.1
date	96.09.15.16.50.41;	author michaels;	state Exp;
branches;
next	;


desc
@@


1.14
log
@keep the code that endian swaps, but remove the explanation that it's
for converting between freebsd and sunos.
@
text
@/*	$OpenBSD: util.c,v 1.13 2015/01/16 06:40:09 deraadt Exp $
 *
 * Copyright (c) 1995 Wolfram Schneider <wosch@@FreeBSD.org>. Berlin.
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * James A. Woods.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id: util.c,v 1.13 2015/01/16 06:40:09 deraadt Exp $
 */


#include <stdlib.h>
#include <string.h>
#include <err.h>
#include <stdio.h>
#include <limits.h>

#include "locate.h"

char 	**colon(char **, char*, char*);
char 	*patprep(char *);
void print_matches(u_int);
u_char 	*tolower_word(u_char *);
int 	getwm(caddr_t);
int 	getwf(FILE *);
int	check_bigram_char(int);

/*
 * Validate bigram chars. If the test failed the database is corrupt
 * or the database is obviously not a locate database.
 */
int
check_bigram_char(ch)
	int ch;
{
	/* legal bigram: 0, ASCII_MIN ... ASCII_MAX */
	if (ch == 0 ||
	    (ch >= ASCII_MIN && ch <= ASCII_MAX))
		return(ch);

	(void)fprintf(stderr, "locate database header corrupt, bigram ");
	(void)fprintf(stderr, "char outside 0, %d-%d: %d\n",
	    ASCII_MIN, ASCII_MAX, ch);
	exit(1);
}

/* split a colon separated string into a char vector
 *
 * "bla:foo" -> {"bla", "foo"}
 * "bla:"    -> {"bla", dot}
 * "bla"     -> {"bla"}
 * ""	     -> do nothing
 *
 */
char **
colon(dbv, path, dot)
	char **dbv;
	char *path;
	char *dot; /* default for single ':' */
{
	int vlen, slen;
	char *c, *ch, *p;
	char **pv;

	if (dbv == NULL) {
		if ((dbv = malloc(sizeof(*dbv))) == NULL)
			err(1, "malloc");
		*dbv = NULL;
	}

	/* empty string */
	if (*path == '\0') {
		(void)fprintf(stderr, "empty database name, ignored\n");
		return(dbv);
	}

	/* length of string vector */
	for (vlen = 0, pv = dbv; *pv != NULL; pv++, vlen++)
		;

	for (ch = c = path; ; ch++) {
		if (*ch == ':' ||
		    (!*ch && !(*(ch - 1) == ':' && ch == 1+ path))) {
			char **newdbv;

			/* single colon -> dot */
			if (ch == c)
				p = dot;
			else {
				/* a string */
				slen = ch - c;
				if ((p = calloc(sizeof(char), slen + 1))
				    == NULL)
					err(1, "malloc");
				bcopy(c, p, slen);
				*(p + slen) = '\0';
			}
			/* increase dbv with element p */
			if ((newdbv = reallocarray(dbv, vlen + 2,
			    sizeof(*newdbv))) == NULL)
				err(1, "realloc");
			dbv = newdbv;
			*(dbv + vlen) = p;
			*(dbv + ++vlen) = NULL;
			c = ch + 1;
		}
		if (*ch == '\0')
			break;
	}
	return (dbv);
}

void
print_matches(counter)
	u_int counter;
{
	(void)printf("%d\n", counter);
}


/*
 * extract last glob-free subpattern in name for fast pre-match; prepend
 * '\0' for backwards match; return end of new pattern
 */
static char globfree[100];

char *
patprep(name)
	char *name;
{
	char *endmark, *p, *subp;

	subp = globfree;
	*subp++ = '\0';   /* set first element to '\0' */
	p = name + strlen(name) - 1;

	/* skip trailing metacharacters */
	for (; p >= name; p--)
		if (strchr(LOCATE_REG, *p) == NULL)
			break;

	/*
	 * check if maybe we are in a character class
	 *
	 * 'foo.[ch]'
	 *        |----< p
	 */
	if (p >= name &&
	    (strchr(p, '[') != NULL || strchr(p, ']') != NULL)) {
		for (p = name; *p != '\0'; p++)
			if (*p == ']' || *p == '[')
				break;
		p--;

		/*
		 * cannot find a non-meta character, give up
		 * '*\*[a-z]'
		 *    |-------< p
		 */
		if (p >= name && strchr(LOCATE_REG, *p) != NULL)
			p = name - 1;
	}

	if (p < name)
		/* only meta chars: "???", force '/' search */
		*subp++ = '/';

	else {
		for (endmark = p; p >= name; p--)
			if (strchr(LOCATE_REG, *p) != NULL)
				break;
		for (++p;
		    (p <= endmark) && subp < (globfree + sizeof(globfree));)
			*subp++ = *p++;
	}
	*subp = '\0';
	return(--subp);
}

/* tolower word */
u_char *
tolower_word(word)
	u_char *word;
{
	u_char *p;

	for (p = word; *p != '\0'; p++)
		*p = TOLOWER(*p);

	return(word);
}


/*
 * Read integer from mmap pointer.
 * Essential a simple  ``return *(int *)p'' but avoid sigbus
 * for integer alignment.
 *
 * Convert network byte order to host byte order if necessary.
 */

int
getwm(p)
	caddr_t p;
{
	union {
		char buf[INTSIZE];
		int i;
	} u;
	int i;

	for (i = 0; i < INTSIZE; i++)
		u.buf[i] = *p++;

	i = u.i;

	if (i > PATH_MAX || i < -(PATH_MAX)) {
		i = ntohl(i);
		if (i > PATH_MAX || i < -(PATH_MAX)) {
			(void)fprintf(stderr,
			    "integer out of +-PATH_MAX (%d): %d\n",
			    PATH_MAX, i);
			exit(1);
		}
	}
	return(i);
}

/*
 * Read integer from stream.
 *
 * Convert network byte order to host byte order if necessary.
 * So we can read on FreeBSD/i386 (little endian) a locate database
 * which was built on SunOS/sparc (big endian).
 */

int
getwf(fp)
	FILE *fp;
{
	int word;

	word = getw(fp);

	if (word > PATH_MAX || word < -(PATH_MAX)) {
		word = ntohl(word);
		if (word > PATH_MAX || word < -(PATH_MAX)) {
			(void)fprintf(stderr,
			    "integer out of +-PATH_MAX (%d): %d\n",
			    PATH_MAX, word);
			exit(1);
		}
	}
	return(word);
}
@


1.13
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.12 2014/11/16 00:04:53 tedu Exp $
d34 1
a34 1
 * $Id: util.c,v 1.12 2014/11/16 00:04:53 tedu Exp $
d223 1
a223 1
 * for integer alignment (SunOS 4.x, 5.x).
a225 2
 * So we can read on FreeBSD/i386 (little endian) a locate database
 * which was built on SunOS/sparc (big endian).
@


1.12
log
@correct type in sizeof by switching to sizeof(*ptr). (harmless)
from Nicolas Bedos
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.11 2014/10/08 04:04:37 doug Exp $
d34 1
a34 1
 * $Id: util.c,v 1.11 2014/10/08 04:04:37 doug Exp $
a40 1
#include <sys/param.h>
d42 1
d245 1
a245 1
	if (i > MAXPATHLEN || i < -(MAXPATHLEN)) {
d247 1
a247 1
		if (i > MAXPATHLEN || i < -(MAXPATHLEN)) {
d249 2
a250 2
			    "integer out of +-MAXPATHLEN (%d): %d\n",
			    MAXPATHLEN, i);
d273 1
a273 1
	if (word > MAXPATHLEN || word < -(MAXPATHLEN)) {
d275 1
a275 1
		if (word > MAXPATHLEN || word < -(MAXPATHLEN)) {
d277 2
a278 2
			    "integer out of +-MAXPATHLEN (%d): %d\n",
			    MAXPATHLEN, word);
@


1.11
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the size argument with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.10 2007/09/02 15:19:33 deraadt Exp $
d34 1
a34 1
 * $Id: util.c,v 1.10 2007/09/02 15:19:33 deraadt Exp $
d75 2
a76 2
 * "bla:foo" -> {"foo", "bla"}
 * "bla:"    -> {"foo", dot}
d92 1
a92 1
		if ((dbv = malloc(sizeof(char **))) == NULL)
d126 1
a126 1
			    sizeof(char **))) == NULL)
@


1.10
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.9 2003/11/08 19:17:29 jmc Exp $
d34 1
a34 1
 * $Id: util.c,v 1.9 2003/11/08 19:17:29 jmc Exp $
d125 2
a126 2
			if ((newdbv = realloc(dbv, sizeof(char **) * (vlen + 2)))
			    == NULL)
@


1.9
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.8 2003/09/29 16:03:10 deraadt Exp $
d34 1
a34 1
 * $Id: util.c,v 1.8 2003/09/29 16:03:10 deraadt Exp $
d118 1
a118 1
				if ((p = malloc(sizeof(char) * (slen + 1)))
@


1.8
log
@realloc fix; ok henning cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.7 2003/06/03 02:56:10 millert Exp $
d34 1
a34 1
 * $Id: util.c,v 1.7 2003/06/03 02:56:10 millert Exp $
d225 1
a225 1
 * Convert network byte order to host byte order if neccessary.
d260 1
a260 1
 * Convert network byte order to host byte order if neccessary.
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.6 2002/06/24 12:37:20 naddy Exp $
d34 1
a34 1
 * $Id: util.c,v 1.6 2002/06/24 12:37:20 naddy Exp $
d54 2
a55 2
/* 
 * Validate bigram chars. If the test failed the database is corrupt 
d68 2
a69 2
	(void)fprintf(stderr, "char outside 0, %d-%d: %d\n",  
                      ASCII_MIN, ASCII_MAX, ch);
d104 2
a105 1
	for(vlen = 0, pv = dbv; *pv != NULL; pv++, vlen++);
d110 2
d118 1
a118 1
				if ((p = malloc(sizeof(char) * (slen + 1))) 
d125 1
a125 1
			if ((dbv = realloc(dbv, sizeof(char **) * (vlen + 2)))
d128 1
d139 1
a139 1
void 
d168 1
a168 1
	/* 
d174 1
a174 1
	if (p >= name && 
d181 1
a181 1
		/* 
d189 2
a190 2
	
	if (p < name) 			
d213 1
a213 1
	for(p = word; *p != '\0'; p++)
d221 2
a222 2
 * Read integer from mmap pointer. 
 * Essential a simple  ``return *(int *)p'' but avoid sigbus 
d225 1
a225 1
 * Convert network byte order to host byte order if neccessary. 
d230 1
a230 1
int 
d248 3
a250 3
			(void)fprintf(stderr, 
				"integer out of +-MAXPATHLEN (%d): %d\n", 
			    	MAXPATHLEN, i);
d260 1
a260 1
 * Convert network byte order to host byte order if neccessary. 
d276 3
a278 3
			(void)fprintf(stderr, 
				"integer out of +-MAXPATHLEN (%d): %d\n", 
				MAXPATHLEN, word);
@


1.6
log
@prevent potential unaligned access error; ok espie@@, pval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.5 2002/02/16 21:27:48 millert Exp $
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 1
a34 1
 * $Id: util.c,v 1.5 2002/02/16 21:27:48 millert Exp $
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.4 2001/11/19 19:02:15 mpech Exp $
d38 1
a38 1
 * $Id: util.c,v 1.4 2001/11/19 19:02:15 mpech Exp $
d234 4
a237 1
	static char buf[INTSIZE];
d241 1
a241 1
		buf[i] = *p++;
d243 1
a243 1
	i = *(int *)buf;
@


1.4
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.3 1997/01/17 07:12:42 millert Exp $
d38 1
a38 1
 * $Id: util.c,v 1.3 1997/01/17 07:12:42 millert Exp $
d50 7
a56 7
char 	**colon __P((char **, char*, char*));
char 	*patprep __P((char *));
void print_matches __P((u_int));
u_char 	*tolower_word __P((u_char *));
int 	getwm __P((caddr_t));
int 	getwf __P((FILE *));
int	check_bigram_char __P((int));
@


1.3
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.2 1996/10/10 09:55:08 michaels Exp $
d38 1
a38 1
 * $Id: util.c,v 1.2 1996/10/10 09:55:08 michaels Exp $
d157 1
a157 1
	register char *endmark, *p, *subp;
d211 1
a211 1
	register u_char *p;
d235 1
a235 1
	register int i;
d266 1
a266 1
	register int word;
@


1.2
log
@Fix searching for shell quoting characters.  From wosch@@freebsd.
@
text
@d1 1
a1 1
/*	$OpenBSD$
d38 1
a38 1
 * $Id: util.c,v 1.2 1996/10/09 00:33:34 wosch Exp $
d165 1
a165 1
		if (index(LOCATE_REG, *p) == NULL)
d175 1
a175 1
	    (index(p, '[') != NULL || index(p, ']') != NULL)) {
d186 1
a186 1
		if (p >= name && index(LOCATE_REG, *p) != NULL)
d196 1
a196 1
			if (index(LOCATE_REG, *p) != NULL)
@


1.1
log
@Blind update of wosch@@FreeBSD's code:

optimized search algorithm
faster IO due mmap(2) [-m | -s]
better error check for damaged databases
support for databases in network byte order (SunOS/sparc)
optional case insensitve search [-i]
optional multiple databases
optional multiple pattern
new enviroment variable LOCATE_PATH for database(s)
[-S] print some statistic about the database
[-l number] limit output to number file names
[-c] suppress normal output; instead print a count of matching file names
fix prototypes/forward declarations/return type
@
text
@d1 2
a2 3
/*	$OpenBSD	*/

/*
d38 1
a38 1
 * $Id: util.c,v 1.1 1996/08/31 23:14:54 wosch Exp $
d41 1
d160 1
a160 1
	*subp++ = '\0';
d162 2
a163 1
	/* skip trailing metacharacters (and [] ranges) */
d165 1
a165 1
		if (index("*?", *p) == 0)
d167 11
a177 6
	if (p < name)
		p = name;
	if (*p == ']')
		for (p--; p >= name; p--)
			if (*p == '[') {
				p--;
d179 13
a191 8
			}
	if (p < name)
		p = name;
	/*
	 * if pattern has only metacharacters, check every path (force '/'
	 * search)
	 */
	if ((p == name) && index("?*[]", *p) != 0)
d193 1
d196 1
a196 1
			if (index("]*?", *p) != 0)
@
