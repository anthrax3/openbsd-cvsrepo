head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.8
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.18
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.16
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.12
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.6
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.18
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.16
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.14
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.12
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.14
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.12
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.10.23.07.57.03;	author tedu;	state Exp;
branches;
next	1.12;
commitid	eptIRj1sULvwai3n;

1.12
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	Uu5nFG3wCl0LACBb;

1.11
date	2010.10.25.19.16.45;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.04.07.19.45;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2008.07.26.09.48.00;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.29.16.03.16;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.03.02.56.10;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	98.07.24.20.50.24;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.12.41;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.10.20.00.52.54;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.10.10.09.55.06;	author michaels;	state Exp;
branches;
next	1.1;

1.1
date	96.09.15.16.50.38;	author michaels;	state Exp;
branches;
next	;


desc
@@


1.13
log
@mmap is the default. it's effectively the only tested codepath. so burn down
the stdio code path.
pros: everything is simpler. how can anyone read code this heavily spliced
with ifdef?
cons: you can't pipe a database into locate. who does this???
ok deraadt
@
text
@/*	$OpenBSD: fastfind.c,v 1.12 2015/01/16 06:40:09 deraadt Exp $	*/

/*
 * Copyright (c) 1995 Wolfram Schneider <wosch@@FreeBSD.org>. Berlin.
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * James A. Woods.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id: fastfind.c,v 1.12 2015/01/16 06:40:09 deraadt Exp $
 */

#ifndef _LOCATE_STATISTIC_
#define _LOCATE_STATISTIC_

void
statistic (fp, path_fcodes)
	FILE *fp;               /* open database */
	char *path_fcodes;  	/* for error message */
{
	int lines, chars, size, big, zwerg;
	u_char *p, *s;
	int c;
	int count, umlaut;
	u_char bigram1[NBG], bigram2[NBG], path[PATH_MAX];

	for (c = 0, p = bigram1, s = bigram2; c < NBG; c++) {
		p[c] = check_bigram_char(getc(fp));
		s[c] = check_bigram_char(getc(fp));
	}

	lines = chars = big = zwerg = umlaut = 0;
	size = NBG + NBG;

	for (c = getc(fp), count = 0; c != EOF; size++) {
		if (c == SWITCH) {
			count += getwf(fp) - OFFSET;
			size += sizeof(int);
			zwerg++;
		} else
			count += c - OFFSET;

		sane_count(count);
		for (p = path + count; (c = getc(fp)) > SWITCH; size++)
			if (c < PARITY) {
				if (c == UMLAUT) {
					c = getc(fp);
					size++;
					umlaut++;
				}
				p++;
			} else {
				/* bigram char */
				big++;
				p += 2;
			}

		p++;
		lines++;
		chars += (p - path);
	}

	(void)printf("\nDatabase: %s\n", path_fcodes);
	(void)printf("Compression: Front: %2.2f%%, ",
	    (float)(100 * (size + big - (2 * NBG))) / chars);
	(void)printf("Bigram: %2.2f%%, ", (float)(100 * (size - big)) / size);
	(void)printf("Total: %2.2f%%\n",
	    (float)(100 * (size - (2 * NBG))) / chars);
	(void)printf("Filenames: %d, ", lines);
	(void)printf("Characters: %d, ", chars);
	(void)printf("Database size: %d\n", size);
	(void)printf("Bigram characters: %d, ", big);
	(void)printf("Integers: %d, ", zwerg);
	(void)printf("8-Bit characters: %d\n", umlaut);

}
#endif /* _LOCATE_STATISTIC_ */


void


#ifdef FF_ICASE
fastfind_mmap_icase
#else
fastfind_mmap
#endif /* FF_ICASE */
(pathpart, paddr, len, database)
	char *pathpart; 	/* search string */
	caddr_t paddr;  	/* mmap pointer */
	int len;        	/* length of database */
	char *database; 	/* for error message */



{
	u_char *p, *s, *patend, *q, *foundchar;
	int c, cc;
	int count, found, globflag;
	u_char *cutoff;
	u_char bigram1[NBG], bigram2[NBG], path[PATH_MAX];

#ifdef FF_ICASE
	/* use a lookup table for case insensitive search */
	u_char table[UCHAR_MAX + 1];

	tolower_word(pathpart);
#endif /* FF_ICASE*/

	/* init bigram table */
	if (len < (2*NBG)) {
		(void)fprintf(stderr, "database too small: %s\n", database);
		exit(1);
	}

	for (c = 0, p = bigram1, s = bigram2; c < NBG; c++, len-= 2) {
		p[c] = check_bigram_char(*paddr++);
		s[c] = check_bigram_char(*paddr++);
	}

	/* find optimal (last) char for searching */
	for (p = pathpart; *p != '\0'; p++)
		if (strchr(LOCATE_REG, *p) != NULL)
			break;

	if (*p == '\0')
		globflag = 0;
	else
		globflag = 1;

	p = pathpart;
	patend = patprep(p);
	cc = *patend;

#ifdef FF_ICASE
	/* set patend char to true */
	table[TOLOWER(*patend)] = 1;
	table[toupper(*patend)] = 1;
#endif /* FF_ICASE */


	/* main loop */
	found = count = 0;
	foundchar = 0;

	c = (u_char)*paddr++; len--;
	for (; len > 0; ) {

		/* go forward or backward */
		if (c == SWITCH) { /* big step, an integer */
			count += getwm(paddr) - OFFSET;
			len -= INTSIZE; paddr += INTSIZE;
		} else {	   /* slow step, =< 14 chars */
			count += c - OFFSET;
		}

		sane_count(count);
		/* overlay old path */
		p = path + count;
		foundchar = p - 1;

		for (;;) {
			c = (u_char)*paddr++;
			len--;
			/*
			 * == UMLAUT: 8 bit char followed
			 * <= SWITCH: offset
			 * >= PARITY: bigram
			 * rest:      single ascii char
			 *
			 * offset < SWITCH < UMLAUT < ascii < PARITY < bigram
			 */
			if (c < PARITY) {
				if (c <= UMLAUT) {
					if (c == UMLAUT) {
						c = (u_char)*paddr++;
						len--;

					} else
						break; /* SWITCH */
				}
#ifdef FF_ICASE
				if (table[c])
#else
				if (c == cc)
#endif /* FF_ICASE */
					foundchar = p;
				*p++ = c;
			} else {
				/* bigrams are parity-marked */
				TO7BIT(c);

#ifndef FF_ICASE
				if (bigram1[c] == cc ||
				    bigram2[c] == cc)
#else

					if (table[bigram1[c]] ||
					    table[bigram2[c]])
#endif /* FF_ICASE */
						foundchar = p + 1;

				*p++ = bigram1[c];
				*p++ = bigram2[c];
			}
		}

		if (found) {			/* previous line matched */
			cutoff = path;
			*p-- = '\0';
			foundchar = p;
		} else if (foundchar >= path + count) { /* a char matched */
			*p-- = '\0';
			cutoff = path + count;
		} else				/* nothing to do */
			continue;

		found = 0;
		for (s = foundchar; s >= cutoff; s--) {
			if (*s == cc
#ifdef FF_ICASE
			    || TOLOWER(*s) == cc
#endif /* FF_ICASE */
			    ) {	/* fast first char check */
				for (p = patend - 1, q = s - 1; *p != '\0';
				    p--, q--)
					if (*q != *p
#ifdef FF_ICASE
					    && TOLOWER(*q) != *p
#endif /* FF_ICASE */
					    )
						break;
				if (*p == '\0') {   /* fast match success */
					char	*shortpath;

					found = 1;
					shortpath = path;
					if (f_basename)
						shortpath = basename(path);

					if ((!f_basename && (!globflag ||
#ifdef FF_ICASE
					    !fnmatch(pathpart, shortpath,
						FNM_CASEFOLD)))
#else
					    !fnmatch(pathpart, shortpath, 0)))
#endif /* FF_ICASE */
					    || (strstr(shortpath, pathpart) !=
					    NULL)) {
						if (f_silent)
							counter++;
						else if (f_limit) {
							counter++;
							if (f_limit >= counter)
								(void)puts(path);
							else  {
								(void)fprintf(stderr, "[show only %d lines]\n", counter - 1);
								exit(0);
							}
						} else
							(void)puts(path);
					}
					break;
				}
			}
		}
	}
}
@


1.12
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: fastfind.c,v 1.11 2010/10/25 19:16:45 millert Exp $	*/
d35 1
a35 1
 * $Id: fastfind.c,v 1.11 2010/10/25 19:16:45 millert Exp $
a105 1
#ifdef FF_MMAP
a119 16
#else /* MMAP */


#ifdef FF_ICASE
fastfind_icase
#else
fastfind
#endif /* FF_ICASE */

(fp, pathpart, database)
	FILE *fp;               /* open database */
	char *pathpart;		/* search string */
	char *database;		/* for error message */


#endif /* MMAP */
a135 1
#ifdef FF_MMAP
a144 6
#else
	for (c = 0, p = bigram1, s = bigram2; c < NBG; c++) {
		p[c] = check_bigram_char(getc(fp));
		s[c] = check_bigram_char(getc(fp));
	}
#endif /* FF_MMAP */
a170 1
#ifdef FF_MMAP
a172 4
#else
	c = getc(fp);
	for (; c != EOF; ) {
#endif /* FF_MMAP */
a175 1
#ifdef FF_MMAP
a177 3
#else
			count +=  getwf(fp) - OFFSET;
#endif /* FF_MMAP */
a187 1
#ifdef FF_MMAP
a189 3
#else
			c = getc(fp);
#endif /* FF_MMAP */
a200 1
#ifdef FF_MMAP
a202 3
#else
						c = getc(fp);
#endif /* FF_MMAP */
@


1.11
log
@Add missing FNM_CASEFOLD flag to fnmatch() when locate is run in case
insensitive mode.  From Geoff Steckel.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fastfind.c,v 1.10 2009/06/04 07:19:45 espie Exp $	*/
d35 1
a35 1
 * $Id: fastfind.c,v 1.10 2009/06/04 07:19:45 espie Exp $
d50 1
a50 1
	u_char bigram1[NBG], bigram2[NBG], path[MAXPATHLEN];
d143 1
a143 1
	u_char bigram1[NBG], bigram2[NBG], path[MAXPATHLEN];
@


1.10
log
@error out if count gets out of bounds. Happens with corrupted databases,
better than a buffer underflow and a segfault.
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fastfind.c,v 1.9 2008/07/26 09:48:00 pyr Exp $	*/
d35 1
a35 1
 * $Id: fastfind.c,v 1.9 2008/07/26 09:48:00 pyr Exp $
d308 4
d313 1
@


1.9
log
@Add -b switch for matching on the last part of the path only.

ok landry@@, otto liked the idea and the original diff, ``do it'' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fastfind.c,v 1.8 2003/09/29 16:03:16 deraadt Exp $	*/
d35 1
a35 1
 * $Id: fastfind.c,v 1.8 2003/09/29 16:03:16 deraadt Exp $
d68 1
d215 1
@


1.8
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: fastfind.c,v 1.7 2003/06/03 02:56:10 millert Exp $	*/
d35 1
a35 1
 * $Id: fastfind.c,v 1.7 2003/06/03 02:56:10 millert Exp $
d298 2
d301 8
a308 1
					if (!globflag || !fnmatch(pathpart, path, 0)) {
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fastfind.c,v 1.6 2001/11/19 19:02:15 mpech Exp $	*/
d35 1
a35 1
 * $Id: fastfind.c,v 1.6 2001/11/19 19:02:15 mpech Exp $
d41 1
a41 1
void 
d67 1
a67 1
		
d89 1
a89 1
		     (float)(100 * (size + big - (2 * NBG))) / chars);
d91 2
a92 2
	(void)printf("Total: %2.2f%%\n", 
		     (float)(100 * (size - (2 * NBG))) / chars);
d157 1
a157 1
	
d220 2
a221 2
			c = (u_char)*paddr++; 
		        len--;
d242 1
a242 1
						
d253 1
a253 2
			}
			else {		
d271 2
a272 2
		
		if (found) {                     /* previous line matched */
d279 1
a279 1
		} else                           /* nothing to do */
d290 1
a290 1
				     p--, q--)
@


1.6
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fastfind.c,v 1.5 1998/07/24 20:50:24 deraadt Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
 * $Id: fastfind.c,v 1.5 1998/07/24 20:50:24 deraadt Exp $
@


1.5
log
@fix spelling; aaron@@ug.cs.dal.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: fastfind.c,v 1.4 1997/01/17 07:12:41 millert Exp $	*/
d39 1
a39 1
 * $Id: fastfind.c,v 1.4 1997/01/17 07:12:41 millert Exp $
d50 3
a52 3
	register int lines, chars, size, big, zwerg;
	register u_char *p, *s;
	register int c;
d142 2
a143 2
	register u_char *p, *s, *patend, *q, *foundchar;
	register int c, cc;
@


1.4
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: fastfind.c,v 1.3 1996/10/20 00:52:54 michaels Exp $	*/
d39 1
a39 1
 * $Id: fastfind.c,v 1.3 1996/10/20 00:52:54 michaels Exp $
d158 1
a158 1
		(void)fprintf(stderr, "database to small: %s\n", database);
@


1.3
log
@8-Bit character support.  From wosch@@freebsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: fastfind.c,v 1.1 1996/09/15 16:50:38 michaels Exp $	*/
d39 1
a39 1
 * $Id: fastfind.c,v 1.2 1996/10/10 09:55:06 michaels Exp $
d175 1
a175 1
		if (index(LOCATE_REG, *p) != NULL)
@


1.2
log
@Fix searching for shell quoting characters.  From wosch@@freebsd.
@
text
@d39 1
a39 1
 * $Id: fastfind.c,v 1.1 1996/09/15 16:50:38 michaels Exp $
d50 1
a50 1
	register int lines, chars, size, big;
d53 1
a53 1
	int count;
d61 1
a61 1
	lines = chars = big = 0;
d68 1
d73 6
a78 1
			if (c < PARITY)
d80 2
a81 1
			else {
d93 1
a93 1
		     (float)(100 * (size + big)) / chars);
d95 2
a96 1
	(void)printf("Total: %2.2f%%\n", (float)(100 * size) / chars);
d98 5
a102 3
	(void)printf("Chars: %d\n", chars);
	(void)printf("Database size: %d, ", size);
	(void)printf("Bigram chars: %d\n", big);
d116 1
a116 1
#endif
d129 1
a129 1
#else /* !FF_ICASE */
d150 1
a150 1
	u_char table[UCHAR_MAX];
d153 1
a153 1
#endif
d171 1
a171 1
#endif
d177 1
d182 1
d191 1
a191 1
#endif
d199 2
a200 1
	for (c = (u_char)*paddr++; len-- > 0; ) {
d202 3
a204 2
	for (c = getc(fp); c != EOF; ) {
#endif
d213 1
a213 1
#endif
d221 2
d224 2
a225 1
		for (; (c = (u_char)*paddr++) > SWITCH; len--)
d227 10
a236 3
		for (; (c = getc(fp)) > SWITCH; )
#endif

d238 12
d254 1
a254 1
#endif
d269 1
a269 1
#endif
d275 1
a275 1

d292 1
a292 1
#endif
d299 1
a299 1
#endif
@


1.1
log
@Blind update of wosch@@FreeBSD's code:

optimized search algorithm
faster IO due mmap(2) [-m | -s]
better error check for damaged databases
support for databases in network byte order (SunOS/sparc)
optional case insensitve search [-i]
optional multiple databases
optional multiple pattern
new enviroment variable LOCATE_PATH for database(s)
[-S] print some statistic about the database
[-l number] limit output to number file names
[-c] suppress normal output; instead print a count of matching file names
fix prototypes/forward declarations/return type
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 1
a39 1
 * $Id: fastfind.c,v 1.1 1996/08/31 23:14:52 wosch Exp $
d164 7
a171 1
	globflag = index(p, '*') || index(p, '?') || index(p, '[');
@
