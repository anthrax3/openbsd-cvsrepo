head	1.40;
access;
symbols
	OPENBSD_6_1:1.40.0.2
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.38.0.2
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.31.0.8
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.6
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.14
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.12
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.10
	OPENBSD_5_0:1.30.0.8
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.6
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.4
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.10
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.6
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.4
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.26.0.14
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.12
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.10
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.8
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.6
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.8.0.14
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.12
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.10
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.8
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.6
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2017.01.21.11.32.04;	author guenther;	state Exp;
branches;
next	1.39;
commitid	DpBZlpar7mq0CJFq;

1.39
date	2016.08.05.10.34.18;	author jca;	state Exp;
branches;
next	1.38;
commitid	wNwnKGK2r1UQjmoF;

1.38
date	2016.03.28.11.06.09;	author chl;	state Exp;
branches;
next	1.37;
commitid	OgtEJe1juHvfpyow;

1.37
date	2016.03.17.05.27.10;	author bentley;	state Exp;
branches;
next	1.36;
commitid	0afdJPZPXUfvItJV;

1.36
date	2015.12.09.19.39.10;	author mmcc;	state Exp;
branches;
next	1.35;
commitid	vYfMHQk0uPOMI7wA;

1.35
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	0Dp7Dy9FuNZesYo2;

1.34
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	Uu5nFG3wCl0LACBb;

1.33
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.32;
commitid	9QOFSShUOtA0kQLF;

1.32
date	2014.10.08.04.08.47;	author doug;	state Exp;
branches;
next	1.31;
commitid	qcZIwav3aQnQeLWs;

1.31
date	2013.04.03.04.12.49;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.27.23.59.43;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.02.15.19.34;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.25.21.27.16;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2006.09.26.10.30.41;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.04.17.06.46;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.17.21.56.25;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.10.22.20.50;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.04.17.37.16;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.03.01.52.41;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.11.18.26.08;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.02.19.06.39;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.07.00.02.58;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.06.20.51.19;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.06.02.46.29;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.06.02.22.25;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.02.17.16.22;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.01.23.37.42;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.11.03.06.32;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.18.22.19.04;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.17.16.52.23;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.05.21.41.07;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.31.19.48.06;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.08.18.03.11.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.08.16.49.45;	author bitblt;	state Exp;
branches;
next	1.6;

1.6
date	97.06.20.10.07.01;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.17.07.13.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.08.16.22.24.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.38.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.43.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.40
log
@The POSIX APIs that that sockaddrs all ignore the s*_len field in the
incoming socket, so userspace doesn't need to set it unless it has its
own reasons for tracking the size along with the sockaddr.

ok phessler@@ deraadt@@ florian@@
@
text
@/*	$OpenBSD: rusers.c,v 1.39 2016/08/05 10:34:18 jca Exp $	*/

/*
 * Copyright (c) 2001, 2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */
/*-
 *  Copyright (c) 1993 John Brezak
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/signal.h>
#include <rpc/rpc.h>
#include <rpc/pmap_prot.h>
#include <rpc/pmap_rmt.h>
#include <rpcsvc/rusers.h>
#include <rpcsvc/rnusers.h>	/* Old protocol version */
#include <arpa/inet.h>
#include <net/if.h>
#include <err.h>
#include <errno.h>
#include <ifaddrs.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <limits.h>
#include <poll.h>

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

/* Preferred formatting */
#define HOST_WIDTH 17
#define LINE_WIDTH 8
#define NAME_WIDTH 8

#define MAX_BROADCAST_SIZE 1400

struct host_info {
	u_int count;
	u_int idle;
	char *host;
	rusers_utmp *users;
} *hostinfo;

void print_entry(struct host_info *, int);
void fmt_idle(int, char *, size_t);
void onehost(char *);
void allhosts(void);
void sorthosts(void);
void expandhosts(void);
void alarmclock(int);
char *estrndup(const char *, size_t);
struct host_info *add_host(char *);
int hcompare(const void *, const void *);
int icompare(const void *, const void *);
int ucompare(const void *, const void *);
bool_t rusers_reply(char *, struct sockaddr_in *);
bool_t rusers_reply_3(char *, struct sockaddr_in *);
enum clnt_stat get_reply(int, in_port_t, u_long, struct rpc_msg *,
    struct rmtcallres *, bool_t (*)(char *, struct sockaddr_in *));
enum clnt_stat rpc_setup(int *, XDR *, struct rpc_msg *,
    struct rmtcallargs *, AUTH *, char *);
__dead void usage(void);

int aflag, hflag, iflag, lflag, uflag;
u_int nentries, maxentries;
long termwidth;
extern char *__progname;

int
main(int argc, char **argv)
{
	struct winsize win;
	char *cp;
	int ch;
	
	while ((ch = getopt(argc, argv, "ahilu")) != -1)
		switch (ch) {
		case 'a':
			aflag = 1;
			break;
		case 'h':
			hflag = 1;
			break;
		case 'i':
			iflag = 1;
			break;
		case 'l':
			lflag = 1;
			break;
		case 'u':
			uflag = 1;
			break;
		default:
			usage();
			/*NOTREACHED*/
		}

	if (hflag + iflag + uflag > 1)
		usage();

	termwidth = 0;
	if ((cp = getenv("COLUMNS")) != NULL)
		termwidth = strtonum(cp, 1, LONG_MAX, NULL);
	if (termwidth == 0 && ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
	    win.ws_col > 0)
		termwidth = win.ws_col;
	if (termwidth == 0)
		termwidth = 80;

	setvbuf(stdout, NULL, _IOLBF, 0);

	if (argc == optind) {
		if (hflag || iflag || uflag) {
			puts("Collecting responses...");
			allhosts();
			sorthosts();
		} else
			allhosts();
	} else {
		aflag = 1;
		for (; optind < argc; optind++)
			(void) onehost(argv[optind]);
		if (hflag || iflag || uflag)
			sorthosts();
	}

	exit(0);
}

struct host_info *
add_host(char *host)
{
	int i;

	for (i = 0; i < nentries; i++) {
		/* Existing entry. */
		if (strcmp(host, hostinfo[i].host) == 0)
			return(NULL);
	}

	/* New entry, allocate space if needed and store. */
	if (nentries == maxentries) {
		maxentries += 128;
		hostinfo = reallocarray(hostinfo, maxentries,
		    sizeof(*hostinfo));
		if (hostinfo == NULL)
			err(1, NULL);
	}
	if ((hostinfo[nentries].host = strdup(host)) == NULL)
		err(1, NULL);
	return(&hostinfo[nentries++]);
}

void
fmt_idle(int idle, char *idle_time, size_t idle_time_len)
{
	int days, hours, minutes, seconds;

	switch (idle) {
	case 0:
		*idle_time = '\0';
		break;
	case INT_MAX:
		strlcpy(idle_time, "??", idle_time_len);
		break;
	default:
		seconds = idle;
		days = seconds / (60*60*24);
		seconds %= (60*60*24);
		hours = seconds / (60*60);
		seconds %= (60*60);
		minutes = seconds / 60;
		seconds %= 60;
		if (idle >= (24*60*60))
			snprintf(idle_time, idle_time_len,
			    "%d day%s, %d:%02d:%02d", days,
			    days > 1 ? "s" : "", hours, minutes, seconds);
		else if (idle >= (60*60))
			snprintf(idle_time, idle_time_len, "%2d:%02d:%02d",
			    hours, minutes, seconds);
		else if (idle > 60)
			snprintf(idle_time, idle_time_len, "%2d:%02d",
			    minutes, seconds);
		else
			snprintf(idle_time, idle_time_len, "   :%02d", idle);
		break;
	}
}

bool_t
rusers_reply(char *replyp, struct sockaddr_in *raddrp)
{
	utmpidlearr *up = (utmpidlearr *)replyp;
	struct host_info *entry;
	struct hostent *hp;
	rusers_utmp *ut;
	char *host;
	int i;
	
	if (!aflag && up->uia_cnt == 0)
		return(0);

	hp = gethostbyaddr((char *)&raddrp->sin_addr,
	    sizeof(struct in_addr), AF_INET);
	if (hp)
		host = hp->h_name;
	else
		host = inet_ntoa(raddrp->sin_addr);
	if ((entry = add_host(host)) == NULL)
		return(0);

	if (up->uia_cnt == 0)
		ut = NULL;
	else if ((ut = calloc(up->uia_cnt, sizeof(*ut))) == NULL)
		err(1, NULL);
	entry->users = ut;
	entry->count = up->uia_cnt;
	entry->idle = UINT_MAX;
	for (i = 0; i < up->uia_cnt; i++, ut++) {
		ut->ut_user = estrndup(up->uia_arr[i]->ui_utmp.ut_name,
		    RNUSERS_MAXUSERLEN);
		ut->ut_line = estrndup(up->uia_arr[i]->ui_utmp.ut_line,
		    RNUSERS_MAXLINELEN);
		ut->ut_host = estrndup(up->uia_arr[i]->ui_utmp.ut_host,
		    RNUSERS_MAXHOSTLEN);
		ut->ut_time = up->uia_arr[i]->ui_utmp.ut_time;
		ut->ut_idle = up->uia_arr[i]->ui_idle;
		if (ut->ut_idle < entry->idle)
			entry->idle = ut->ut_idle;
	}
	
	if (!hflag && !iflag && !uflag) {
		print_entry(entry, lflag && entry->count);
		for (i = 0, ut = entry->users; i < entry->count; i++, ut++) {
			free(ut->ut_user);
			free(ut->ut_line);
			free(ut->ut_host);
		}
		free(entry->users);
	}
	
	return(0);
}

bool_t
rusers_reply_3(char *replyp, struct sockaddr_in *raddrp)
{
	utmp_array *up3 = (utmp_array *)replyp;
	struct host_info *entry;
	struct hostent *hp;
	rusers_utmp *ut;
	char *host;
	int i;
	
	if (!aflag && up3->utmp_array_len == 0)
		return(0);

	hp = gethostbyaddr((char *)&raddrp->sin_addr,
	    sizeof(struct in_addr), AF_INET);
	if (hp)
		host = hp->h_name;
	else
		host = inet_ntoa(raddrp->sin_addr);
	if ((entry = add_host(host)) == NULL)
		return(0);

	if (up3->utmp_array_len == 0)
		ut = NULL;
	else if ((ut = calloc(up3->utmp_array_len, sizeof(*ut))) == NULL)
		err(1, NULL);
	entry->users = ut;
	entry->count = up3->utmp_array_len;
	entry->idle = UINT_MAX;
	for (i = 0; i < up3->utmp_array_len; i++, ut++) {
		ut->ut_user = estrndup(up3->utmp_array_val[i].ut_user,
		    RUSERS_MAXUSERLEN);
		ut->ut_line = estrndup(up3->utmp_array_val[i].ut_line,
		    RUSERS_MAXLINELEN);
		ut->ut_host = estrndup(up3->utmp_array_val[i].ut_host,
		    RUSERS_MAXHOSTLEN);
		ut->ut_time = up3->utmp_array_val[i].ut_time;
		ut->ut_idle = up3->utmp_array_val[i].ut_idle;
		if (ut->ut_idle < entry->idle)
			entry->idle = ut->ut_idle;
	}
	
	if (!hflag && !iflag && !uflag) {
		print_entry(entry, lflag && entry->count);
		for (i = 0, ut = entry->users; i < entry->count; i++, ut++) {
			free(ut->ut_user);
			free(ut->ut_line);
			free(ut->ut_host);
		}
		free(entry->users);
	}
	
	return(0);
}

void
onehost(char *host)
{
	utmpidlearr up;
	utmp_array up3;
	CLIENT *rusers_clnt;
	struct sockaddr_in sin;
	struct hostent *hp;
	struct timeval tv = { 25, 0 };
	int error;
	
	memset(&sin, 0, sizeof sin);

	hp = gethostbyname(host);
	if (hp == NULL)
		errx(1, "unknown host \"%s\"", host);

	/* Try version 3 first. */
	rusers_clnt = clnt_create(host, RUSERSPROG, RUSERSVERS_3, "udp");
	if (rusers_clnt == NULL) {
		clnt_pcreateerror(__progname);
		exit(1);
	}

	memset(&up3, 0, sizeof(up3));
	error = clnt_call(rusers_clnt, RUSERSPROC_NAMES, xdr_void, NULL,
	    xdr_utmp_array, &up3, tv);
	switch (error) {
	case RPC_SUCCESS:
		sin.sin_addr.s_addr = *(int *)hp->h_addr;
		rusers_reply_3((char *)&up3, &sin);
		clnt_destroy(rusers_clnt);
		return;
	case RPC_PROGVERSMISMATCH:
		clnt_destroy(rusers_clnt);
		break;
	default:
		clnt_perror(rusers_clnt, __progname);
		clnt_destroy(rusers_clnt);
		exit(1);
	}

	/* Fall back to version 2. */
	rusers_clnt = clnt_create(host, RUSERSPROG, RUSERSVERS_IDLE, "udp");
	if (rusers_clnt == NULL) {
		clnt_pcreateerror(__progname);
		exit(1);
	}

	memset(&up, 0, sizeof(up));
	error = clnt_call(rusers_clnt, RUSERSPROC_NAMES, xdr_void, NULL,
	    xdr_utmpidlearr, &up, tv);
	if (error != RPC_SUCCESS) {
		clnt_perror(rusers_clnt, __progname);
		clnt_destroy(rusers_clnt);
		exit(1);
	}
	sin.sin_addr.s_addr = *(int *)hp->h_addr;
	rusers_reply((char *)&up, &sin);
	clnt_destroy(rusers_clnt);
}

enum clnt_stat
get_reply(int sock, in_port_t port, u_long xid, struct rpc_msg *msgp,
    struct rmtcallres *resp, bool_t (*callback)(char *, struct sockaddr_in *))
{
	ssize_t inlen;
	socklen_t fromlen;
	struct sockaddr_in raddr;
	char inbuf[UDPMSGSIZE];
	XDR xdr;

retry:
	msgp->acpted_rply.ar_verf = _null_auth;
	msgp->acpted_rply.ar_results.where = (caddr_t)resp;
	msgp->acpted_rply.ar_results.proc = xdr_rmtcallres;

	fromlen = sizeof(raddr);
	inlen = recvfrom(sock, inbuf, sizeof(inbuf), 0,
	    (struct sockaddr *)&raddr, &fromlen);
	if (inlen < 0) {
		if (errno == EINTR)
			goto retry;
		return (RPC_CANTRECV);
	}
	if (inlen < sizeof(u_int32_t))
		goto retry;

	/*
	 * If the reply we got matches our request, decode the
	 * replay and pass it to the callback function.
	 */
	xdrmem_create(&xdr, inbuf, (u_int)inlen, XDR_DECODE);
	if (xdr_replymsg(&xdr, msgp)) {
		if ((msgp->rm_xid == xid) &&
		    (msgp->rm_reply.rp_stat == MSG_ACCEPTED) &&
		    (msgp->acpted_rply.ar_stat == SUCCESS)) {
			raddr.sin_port = htons(port);
			(void)(*callback)(resp->results_ptr, &raddr);
		}
	}
	xdr.x_op = XDR_FREE;
	msgp->acpted_rply.ar_results.proc = xdr_void;
	(void)xdr_replymsg(&xdr, msgp);
	(void)(*resp->xdr_results)(&xdr, resp->results_ptr);
	xdr_destroy(&xdr);

	return(RPC_SUCCESS);
}

enum clnt_stat
rpc_setup(int *fdp, XDR *xdr, struct rpc_msg *msg, struct rmtcallargs *args,
    AUTH *unix_auth, char *buf)
{
	int on = 1;

	if ((*fdp = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
		return(RPC_CANTSEND);

	if (setsockopt(*fdp, SOL_SOCKET, SO_BROADCAST, &on, sizeof(on)) < 0)
		return(RPC_CANTSEND);

	msg->rm_xid = arc4random();
	msg->rm_direction = CALL;
	msg->rm_call.cb_rpcvers = RPC_MSG_VERSION;
	msg->rm_call.cb_prog = PMAPPROG;
	msg->rm_call.cb_vers = PMAPVERS;
	msg->rm_call.cb_proc = PMAPPROC_CALLIT;
	msg->rm_call.cb_cred = unix_auth->ah_cred;
	msg->rm_call.cb_verf = unix_auth->ah_verf;

	xdrmem_create(xdr, buf, MAX_BROADCAST_SIZE, XDR_ENCODE);
	if (!xdr_callmsg(xdr, msg) || !xdr_rmtcall_args(xdr, args))
		return(RPC_CANTENCODEARGS);

	return(RPC_SUCCESS);
}

void
allhosts(void)
{
	enum clnt_stat stat;
	struct itimerval timeout;
	AUTH *unix_auth;
	size_t outlen[2];
	int sock[2] = { -1, -1 };
	int i, rval;
	u_long xid[2], port[2];
	struct pollfd pfd[2];
	struct sockaddr_in *sin, baddr;
	struct rmtcallargs args;
	struct rmtcallres res[2];
	struct rpc_msg msg[2];
	struct ifaddrs *ifa, *ifap = NULL;
	char buf[2][MAX_BROADCAST_SIZE];
	utmpidlearr up;
	utmp_array up3;
	XDR xdr;

	if ((unix_auth = authunix_create_default()) == NULL)
		err(1, "can't create auth handle");

	if (getifaddrs(&ifap) != 0)
		err(1, "can't get list of interface addresses");

	memset(&up, 0, sizeof(up));
	memset(&up3, 0, sizeof(up3));
	memset(&baddr, 0, sizeof(baddr));
	memset(&res, 0, sizeof(res));
	memset(&msg, 0, sizeof(msg));
	memset(&timeout, 0, sizeof(timeout));

	args.prog = RUSERSPROG;
	args.vers = RUSERSVERS_IDLE;
	args.proc = RUSERSPROC_NAMES;
	args.xdr_args = xdr_void;
	args.args_ptr = NULL;

	stat = rpc_setup(&sock[0], &xdr, &msg[0], &args, unix_auth, buf[0]);
	if (stat != RPC_SUCCESS)
		goto cleanup;
	xid[0] = msg[0].rm_xid;
	outlen[0] = xdr_getpos(&xdr);
	xdr_destroy(&xdr);

	args.vers = RUSERSVERS_3;
	stat = rpc_setup(&sock[1], &xdr, &msg[1], &args, unix_auth, buf[1]);
	if (stat != RPC_SUCCESS)
		goto cleanup;
	xid[1] = msg[1].rm_xid;
	outlen[1] = xdr_getpos(&xdr);
	xdr_destroy(&xdr);

	baddr.sin_family = AF_INET;
	baddr.sin_port = htons(PMAPPORT);
	baddr.sin_addr.s_addr = htonl(INADDR_ANY);

	res[0].port_ptr = &port[0];
	res[0].xdr_results = xdr_utmpidlearr;
	res[0].results_ptr = (caddr_t)&up;

	res[1].port_ptr = &port[1];
	res[1].xdr_results = xdr_utmp_array;
	res[1].results_ptr = (caddr_t)&up3;

	(void)signal(SIGALRM, alarmclock);

	/*
	 * We do 6 runs through the loop.  On even runs we send
	 * a version 3 broadcast.  On odd ones we send a version 2
	 * broadcast.  This should give version 3 replies enough
	 * of an 'edge' over the old version 2 ones in most cases.
	 * We poll() waiting for replies for 5 seconds in between
	 * each broadcast.
	 */
	for (i = 0; i < 6; i++) {
		for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
			if (ifa->ifa_addr->sa_family != AF_INET ||
			    !(ifa->ifa_flags & IFF_BROADCAST) ||
			    !(ifa->ifa_flags & IFF_UP) ||
			    ifa->ifa_broadaddr == NULL ||
			    ifa->ifa_broadaddr->sa_family != AF_INET)
				continue;
			sin = (struct sockaddr_in *)ifa->ifa_broadaddr;
			baddr.sin_addr = sin->sin_addr;

			/* use protocol 2 or 3 depending on i (odd or even) */
			if (i & 1) {
				if (sendto(sock[0], buf[0], outlen[0], 0,
				    (struct sockaddr *)&baddr,
				    sizeof(baddr)) != outlen[0])
					err(1, "can't send broadcast packet");
			} else {
				if (sendto(sock[1], buf[1], outlen[1], 0,
				    (struct sockaddr *)&baddr,
				    sizeof(baddr)) != outlen[1])
					err(1, "can't send broadcast packet");
			}
		}

		/*
		 * We stay in the poll loop for ~5 seconds
		 */
		timeout.it_value.tv_sec = 5;
		timeout.it_value.tv_usec = 0;
		while (timerisset(&timeout.it_value)) {
			pfd[0].fd = sock[0];
			pfd[0].events = POLLIN;
			pfd[1].fd = sock[1];
			pfd[1].events = POLLIN;
			setitimer(ITIMER_REAL, &timeout, NULL);
			rval = poll(pfd, 2, 0);
			setitimer(ITIMER_REAL, NULL, &timeout);
			if (rval == -1) {
				if (errno == EINTR)
					break;
				err(1, "poll");	/* shouldn't happen */
			}
			if (pfd[1].revents & POLLIN) {
				stat = get_reply(sock[1], (in_port_t)port[1],
				    xid[1], &msg[1], &res[1], rusers_reply_3);
				if (stat != RPC_SUCCESS)
					goto cleanup;
			}
			if (pfd[0].revents & POLLIN) {
				stat = get_reply(sock[0], (in_port_t)port[0],
				    xid[0], &msg[0], &res[0], rusers_reply);
				if (stat != RPC_SUCCESS)
					goto cleanup;
			}
		}
	}
cleanup:
	if (ifap != NULL)
		freeifaddrs(ifap);
	if (sock[0] >= 0)
		(void)close(sock[0]);
	if (sock[1] >= 0)
		(void)close(sock[1]);
	AUTH_DESTROY(unix_auth);
	if (stat != RPC_SUCCESS) {
		clnt_perrno(stat);
		exit(1);
	}
}

void
print_entry(struct host_info *entry, int longfmt)
{
	char date[32], idle_time[64];
	char remote[RUSERS_MAXHOSTLEN + 3];
	struct rusers_utmp *ut;
	int i, len;

	if (!longfmt)
		printf("%-*.*s ", HOST_WIDTH, HOST_WIDTH, entry->host);

	for (i = 0, ut = entry->users; i < entry->count; i++, ut++) {
		if (longfmt) {
			time_t tim = ut->ut_time;
			strftime(date, sizeof(date), "%h %d %R",
			    localtime(&tim));
			date[sizeof(date) - 1] = '\0';
			fmt_idle(ut->ut_idle, idle_time, sizeof(idle_time));
			len = termwidth -
			    (MAXIMUM(strlen(ut->ut_user), NAME_WIDTH) + 1 +
			    HOST_WIDTH + 1 + LINE_WIDTH + 1 + strlen(date) +
			    1 + MAXIMUM(8, strlen(idle_time)) + 1 + 2);
			if (len > 0 && ut->ut_host[0] != '\0')
				snprintf(remote, sizeof(remote), "(%.*s)",
				    MINIMUM(len, RUSERS_MAXHOSTLEN), ut->ut_host);
			else
				remote[0] = '\0';
			len = HOST_WIDTH - MINIMUM(HOST_WIDTH, strlen(entry->host)) +
			    LINE_WIDTH - MINIMUM(LINE_WIDTH, strlen(ut->ut_line));
			printf("%-*s %.*s:%.*s%-*s %-12s %8s %s\n",
			    NAME_WIDTH, ut->ut_user, HOST_WIDTH, entry->host,
			    LINE_WIDTH, ut->ut_line, len, "", date,
			    idle_time, remote);
		} else {
			fputs(ut->ut_user, stdout);
			putchar(' ');
		}
	}
	if (!longfmt)
		putchar('\n');
}

void
expandhosts(void)
{
	struct host_info *new_hostinfo, *entry;
	u_int count;
	int i, j;

	for (i = 0, count = 0; i < nentries; i++)
		count += hostinfo[i].count;

	new_hostinfo = calloc(sizeof(*entry), count);
	if (new_hostinfo == NULL)
		err(1, NULL);
	for (i = 0, entry = new_hostinfo; i < nentries; i++) {
		for (j = 0; j < hostinfo[i].count; j++) {
			memcpy(entry, &hostinfo[i], sizeof(*entry));
			entry->users = &hostinfo[i].users[j];
			entry->idle = entry->users->ut_idle;
			entry->count = 1;
			entry++;
		}
	}
	free(hostinfo);
	hostinfo = new_hostinfo;
	nentries = maxentries = count;
}

void
sorthosts(void)
{
	int i;
	int (*compar)(const void *, const void *);

	if (iflag && lflag)
		expandhosts();

	if (hflag)
		compar = hcompare;
	else if (iflag)
		compar = icompare;
	else
		compar = ucompare;
	qsort(hostinfo, nentries, sizeof(*hostinfo), compar);

	for (i = 0; i < nentries; i++)
		print_entry(&hostinfo[i], lflag && hostinfo[i].count);
}

int
hcompare(const void *aa, const void *bb)
{
	const struct host_info *a = (struct host_info *)aa;
	const struct host_info *b = (struct host_info *)bb;
	int rval;

	if ((rval = strcasecmp(a->host, b->host)) != 0)
		return(rval);

	if (a->idle < b->idle)
		return(-1);
	else if (a->idle > b->idle)
		return(1);

	if (a->count > b->count)
		return(-1);
	else if (a->count < b->count)
		return(1);

	return(0);
}

int
icompare(const void *aa, const void *bb)
{
	const struct host_info *a = (struct host_info *)aa;
	const struct host_info *b = (struct host_info *)bb;

	if (a->idle < b->idle)
		return(-1);
	else if (a->idle > b->idle)
		return(1);

	if (a->count > b->count)
		return(-1);
	else if (a->count < b->count)
		return(1);

	return(strcasecmp(a->host, b->host));
}

int
ucompare(const void *aa, const void *bb)
{
	const struct host_info *a = (struct host_info *)aa;
	const struct host_info *b = (struct host_info *)bb;

	if (a->count > b->count)
		return(-1);
	else if (a->count < b->count)
		return(1);

	if (a->idle < b->idle)
		return(-1);
	else if (a->idle > b->idle)
		return(1);

	return(strcasecmp(a->host, b->host));
}

void
alarmclock(int signo)
{

	;		/* just interrupt */
}

char *
estrndup(const char *src, size_t len)
{
	char *dst, *end;

	if ((end = memchr(src, '\0', len)) != NULL)
		len = end - src;

	if ((dst = malloc(len + 1)) == NULL)
		err(1, NULL);
	memcpy(dst, src, len);
	dst[len] = '\0';

	return(dst);
}

void
usage(void)
{

	fprintf(stderr, "usage: %s [-al] [-h | -i | -u] [hosts ...]\n",
	    __progname);
	exit(1);
}
@


1.39
log
@Switch from select(2) to poll(2); ok millert@@

No need to check for POLLHUP since those are UDP sockets.
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.38 2016/03/28 11:06:09 chl Exp $	*/
d421 1
a421 1
	fromlen = sizeof(struct sockaddr);
a536 1
	baddr.sin_len = sizeof(struct sockaddr_in);
d574 1
a574 1
				    sizeof(struct sockaddr)) != outlen[0])
d579 1
a579 1
				    sizeof(struct sockaddr)) != outlen[1])
@


1.38
log
@remove unused variable

ok bentley@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.37 2016/03/17 05:27:10 bentley Exp $	*/
d69 1
d490 1
a490 1
	int i, maxfd, rval;
d492 1
a492 1
	fd_set *fds = NULL;
a536 5
	maxfd = MAXIMUM(sock[0], sock[1]) + 1;
	fds = calloc(howmany(maxfd, NFDBITS), sizeof(fd_mask));
	if (fds == NULL)
		err(1, NULL);

d557 1
a557 1
	 * We select() waiting for replies for 5 seconds in between
d586 1
a586 1
		 * We stay in the select loop for ~5 seconds
d591 4
a594 2
			FD_SET(sock[0], fds);
			FD_SET(sock[1], fds);
d596 1
a596 1
			rval = select(maxfd, fds, NULL, NULL, NULL);
d601 1
a601 1
				err(1, "select");	/* shouldn't happen */
d603 1
a603 1
			if (FD_ISSET(sock[1], fds)) {
d609 1
a609 1
			if (FD_ISSET(sock[0], fds)) {
a619 1
	free(fds);
@


1.37
log
@Switch (non-curses, non-ksh) programs that use COLUMNS to a single idiom.

Previously behaviors were all over the map. This changes them to
use COLUMNS first, and either terminal width or a hardcoded value
(typically 80) as appropriate.

ok deraadt@@; man bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.36 2015/12/09 19:39:10 mmcc Exp $	*/
d116 1
a116 1
	char *cp, *ep;
@


1.36
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.35 2015/08/20 22:32:41 deraadt Exp $	*/
d144 7
a150 14
	if (isatty(STDOUT_FILENO)) {
		if ((cp = getenv("COLUMNS")) != NULL && *cp != '\0') {
			termwidth = strtol(cp, &ep, 10);
			if (*ep != '\0' || termwidth >= INT_MAX ||
			    termwidth < 0)
				termwidth = 0;
		}
		if (termwidth == 0 &&
		    ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) == 0 &&
		    win.ws_col > 0)
			termwidth = win.ws_col;
		else
			termwidth = 80;
	} else
d152 1
@


1.35
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.34 2015/01/16 06:40:11 deraadt Exp $	*/
d628 1
a628 2
	if (fds != NULL)
		free(fds);
@


1.34
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.33 2014/11/26 18:34:51 millert Exp $	*/
d543 1
a543 1
	fds = (fd_set *)calloc(howmany(maxfd, NFDBITS), sizeof(fd_mask));
d693 1
a693 1
	new_hostinfo = (struct host_info *)calloc(sizeof(*entry), count);
@


1.33
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.32 2014/10/08 04:08:47 doug Exp $	*/
a48 1
#include <sys/param.h>
d51 1
d68 4
d542 1
a542 1
	maxfd = MAX(sock[0], sock[1]) + 1;
d660 1
a660 1
			    (MAX(strlen(ut->ut_user), NAME_WIDTH) + 1 +
d662 1
a662 1
			    1 + MAX(8, strlen(idle_time)) + 1 + 2);
d665 1
a665 1
				    MIN(len, RUSERS_MAXHOSTLEN), ut->ut_host);
d668 2
a669 2
			len = HOST_WIDTH - MIN(HOST_WIDTH, strlen(entry->host)) +
			    LINE_WIDTH - MIN(LINE_WIDTH, strlen(ut->ut_line));
@


1.32
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the size argument with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.31 2013/04/03 04:12:49 deraadt Exp $	*/
d155 1
a155 1
	setlinebuf(stdout);
@


1.31
log
@do not assume time_t and timeval.tv_sec are the same type
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.30 2009/10/27 23:59:43 deraadt Exp $	*/
d189 2
a190 2
		hostinfo = realloc(hostinfo,
		    sizeof(*hostinfo) * maxentries);
@


1.30
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.29 2007/09/02 15:19:34 deraadt Exp $	*/
d650 1
d652 1
a652 1
			    localtime((time_t *)&ut->ut_time));
@


1.29
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.28 2007/05/25 21:27:16 krw Exp $	*/
a47 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.28 2007/05/25 21:27:16 krw Exp $";
#endif /* not lint */
@


1.28
log
@"interupt" -> "interrupt" in various comments. Mostly from Diego Casati.
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.27 2006/09/26 10:30:41 otto Exp $	*/
d50 1
a50 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.27 2006/09/26 10:30:41 otto Exp $";
d263 1
a263 1
	else if ((ut = malloc(up->uia_cnt * sizeof(*ut))) == NULL)
d318 1
a318 1
	else if ((ut = malloc(up3->utmp_array_len * sizeof(*ut))) == NULL)
d692 1
a692 1
	new_hostinfo = (struct host_info *)malloc(sizeof(*entry) * count);
@


1.27
log
@authunix_create_default() might return NULL; spotted by tbert;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.26 2003/08/04 17:06:46 deraadt Exp $	*/
d50 1
a50 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.26 2003/08/04 17:06:46 deraadt Exp $";
d795 1
a795 1
	;		/* just interupt */
@


1.26
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.25 2003/06/17 21:56:25 millert Exp $	*/
d50 1
a50 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.25 2003/06/17 21:56:25 millert Exp $";
d492 1
a492 1
	AUTH *unix_auth = authunix_create_default();
d507 3
@


1.25
log
@Sync with share/misc/license.template and add missing DARPA credit
where applicable.
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.24 2003/06/10 22:20:50 deraadt Exp $	*/
d50 1
a50 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.24 2003/06/10 22:20:50 deraadt Exp $";
d102 3
a104 1
    struct rmtcallres *, bool_t (*)());
d413 1
a413 1
	  struct rmtcallres *resp, bool_t (*callback)())
d461 1
a461 1
	  AUTH *unix_auth, char *buf)
@


1.24
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.23 2003/06/04 17:37:16 deraadt Exp $	*/
d10 10
a19 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d50 1
a50 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.23 2003/06/04 17:37:16 deraadt Exp $";
@


1.23
log
@fix stdout line width handling; different from fix in 3289
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.22 2003/06/03 01:52:41 millert Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.22 2003/06/03 01:52:41 millert Exp $";
d675 1
a675 1
expandhosts()
d702 1
a702 1
sorthosts()
@


1.22
log
@Use an ISC-tyle license for all my code; it is simpler and more permissive.
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.21 2003/01/11 18:26:08 millert Exp $	*/
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.21 2003/01/11 18:26:08 millert Exp $";
d152 2
a153 1
	}
@


1.21
log
@o specifying host on the command line implies the -a flag
o honor -h, -i, and -u when hosts are specified on the command line
o print hostname when no users for "rusers -la"
o print "day" not "days" when there is only one of them
o avoid calling malloc(0) (pedantic, this was not used unsafely)
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.20 2002/06/02 19:06:39 deraadt Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d47 1
a47 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.20 2002/06/02 19:06:39 deraadt Exp $";
@


1.20
log
@missing sockaddr inits; ok itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.19 2001/11/07 00:02:58 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.19 2001/11/07 00:02:58 millert Exp $";
d95 1
a95 1
void print_entry(struct host_info *);
d174 1
d177 2
d230 2
a231 2
			    "%d days, %d:%02d:%02d",
			    days, hours, minutes, seconds);
d266 3
a268 1
	if ((ut = malloc(up->uia_cnt * sizeof(*ut))) == NULL)
d287 1
a287 1
		print_entry(entry);
d309 1
a309 1
	if (!aflag && !up3->utmp_array_len)
d321 3
a323 1
	if ((ut = malloc(up3->utmp_array_len * sizeof(*ut))) == NULL)
d342 1
a342 1
		print_entry(entry);
d644 1
a644 1
print_entry(struct host_info *entry)
d651 1
a651 1
	if (!lflag)
d655 1
a655 1
		if (lflag) {
d680 1
a680 1
	if (!lflag)
d729 1
a729 1
		print_entry(&hostinfo[i]);
@


1.19
log
@When mixing the -l and -i flags sort on each individual user's
idle time, not the minimum idle tiem of all users on the host.
This makes the -i option much more useful...
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.18 2001/11/06 20:51:19 millert Exp $	*/
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.18 2001/11/06 20:51:19 millert Exp $";
d358 2
@


1.18
log
@implement missing sorting options
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.17 2001/11/06 02:46:29 millert Exp $	*/
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.17 2001/11/06 02:46:29 millert Exp $";
d100 1
d676 27
d707 3
@


1.17
log
@Must zero out timeout by hand now that it is no longer global.
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.16 2001/11/06 02:22:25 millert Exp $	*/
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.16 2001/11/06 02:22:25 millert Exp $";
d86 10
a95 2
int search_host(struct in_addr);
void remember_host(char **);
a96 1
void print_longline(int, u_int, char *, char *, char *, char *, int);
d99 1
d101 5
d112 2
a113 2
int longopt;
int allopt;
a116 7
struct host_list {
	struct host_list *next;
	struct in_addr addr;
} *hosts;

#define MAX_BROADCAST_SIZE 1400

d124 1
a124 1
	while ((ch = getopt(argc, argv, "al")) != -1)
d127 7
a133 1
			allopt++;
d136 4
a139 1
			longopt++;
d146 3
d164 9
a172 3
	if (argc == optind)
		allhosts();
	else {
d176 1
d180 2
a181 2
int
search_host(struct in_addr addr)
d183 1
a183 4
	struct host_list *hp;
	
	if (!hosts)
		return(0);
d185 4
a188 3
	for (hp = hosts; hp != NULL; hp = hp->next) {
		if (hp->addr.s_addr == addr.s_addr)
			return(1);
a189 2
	return(0);
}
d191 6
a196 7
void
remember_host(char **ap)
{
	struct host_list *hp;

	for (; *ap; ap++) {
		if (!(hp = malloc(sizeof(struct host_list))))
a197 3
		hp->addr.s_addr = *(in_addr_t *)*ap;
		hp->next = hosts;
		hosts = hp;
d199 3
a239 26
void
print_longline(int ut_time, u_int idle, char *host, char *user, char *line,
	       char *remhost, int remhostmax)
{
	char date[32], idle_time[64];
	char remote[RUSERS_MAXHOSTLEN + 1];
	int len;

	strftime(date, sizeof(date), "%h %d %R", localtime((time_t *)&ut_time));
	date[sizeof(date) - 1] = '\0';
	fmt_idle(idle, idle_time, sizeof(idle_time));
	len = termwidth -
	    (MAX(strlen(user), NAME_WIDTH) + 1 + HOST_WIDTH + 1 + LINE_WIDTH +
	    1 + strlen(date) + 1 + MAX(8, strlen(idle_time)) + 1 + 2);
	if (len > 0 && *remhost != '\0')
		snprintf(remote, sizeof(remote), "(%.*s)",
		    MIN(len, remhostmax), remhost);
	else
		remote[0] = '\0';
	len = HOST_WIDTH - MIN(HOST_WIDTH, strlen(host)) +
	    LINE_WIDTH - MIN(LINE_WIDTH, strlen(line));
	printf("%-*s %.*s:%.*s%-*s %-12s %8s %s\n",
	    NAME_WIDTH, user, HOST_WIDTH, host, LINE_WIDTH, line,
	    len, "", date, idle_time, remote);
}

a242 2
	char user[RNUSERS_MAXUSERLEN + 1];
	char utline[RNUSERS_MAXLINELEN + 1];
d244 1
d246 2
a247 1
	char *host, *taddrs[2];
d250 1
a250 1
	if (search_host(raddrp->sin_addr))
a252 3
	if (!allopt && !up->uia_cnt)
		return(0);
	
d255 1
a255 1
	if (hp) {
d257 1
a257 2
		remember_host(hp->h_addr_list);
	} else {
d259 27
a285 23
		taddrs[0] = (char *)&raddrp->sin_addr;
		taddrs[1] = NULL;
		remember_host(taddrs);
	}
	
	if (!longopt)
		printf("%-*.*s ", HOST_WIDTH, HOST_WIDTH, host);
	
	for (i = 0; i < up->uia_cnt; i++) {
		/* NOTE: strncpy() used below for non-terminated strings. */
		strncpy(user, up->uia_arr[i]->ui_utmp.ut_name,
		    sizeof(user) - 1);
		user[sizeof(user) - 1] = '\0';
		if (longopt) {
			strncpy(utline, up->uia_arr[i]->ui_utmp.ut_line,
			    sizeof(utline) - 1);
			utline[sizeof(utline) - 1] = '\0';
			print_longline(up->uia_arr[i]->ui_utmp.ut_time,
			    up->uia_arr[i]->ui_idle, host, user, utline,
			    up->uia_arr[i]->ui_utmp.ut_host, RNUSERS_MAXHOSTLEN);
		} else {
			fputs(user, stdout);
			putchar(' ');
d287 1
a288 2
	if (!longopt)
		putchar('\n');
a295 2
	char user[RUSERS_MAXUSERLEN + 1];
	char utline[RUSERS_MAXLINELEN + 1];
d297 1
d299 2
a300 1
	char *host, *taddrs[2];
d303 1
a303 4
	if (search_host(raddrp->sin_addr))
		return(0);

	if (!allopt && !up3->utmp_array_len)
d308 1
a308 1
	if (hp) {
d310 1
a310 2
		remember_host(hp->h_addr_list);
	} else {
d312 27
a338 23
		taddrs[0] = (char *)&raddrp->sin_addr;
		taddrs[1] = NULL;
		remember_host(taddrs);
	}
	
	if (!longopt)
		printf("%-*.*s ", HOST_WIDTH, HOST_WIDTH, host);
	
	for (i = 0; i < up3->utmp_array_len; i++) {
		/* NOTE: strncpy() used below for non-terminated strings. */
		strncpy(user, up3->utmp_array_val[i].ut_user,
		    sizeof(user) - 1);
		user[sizeof(user) - 1] = '\0';
		if (longopt) {
			strncpy(utline, up3->utmp_array_val[i].ut_line,
			    sizeof(utline) - 1);
			utline[sizeof(utline) - 1] = '\0';
			print_longline(up3->utmp_array_val[i].ut_time,
			    up3->utmp_array_val[i].ut_idle, host, user, utline,
			    up3->utmp_array_val[i].ut_host, RUSERS_MAXHOSTLEN);
		} else {
			fputs(user, stdout);
			putchar(' ');
d340 1
a341 2
	if (!longopt)
		putchar('\n');
d361 1
a361 1
	/* try version 3 first */
d386 1
a386 1
	/* fall back to version 2 */
d592 1
a592 1
		for (;;) {
d634 120
d760 16
d780 2
a781 1
	fprintf(stderr, "usage: %s [-la] [hosts ...]\n", __progname);
@


1.16
log
@Restore asyncronous RPC code now that I found the uninitialized variable
that was causing problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.14 2001/11/01 23:37:42 millert Exp $	*/
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.14 2001/11/01 23:37:42 millert Exp $";
d519 1
a597 1
		timerclear(&timeout.it_value);
@


1.15
log
@Revert to clnt_broadcast() method until an alignment problem with the
asyncronous rpc code in the previous commit is fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.13 2001/10/11 03:06:32 millert Exp $	*/
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.13 2001/10/11 03:06:32 millert Exp $";
d65 2
a66 2
#include <rpc/pmap_clnt.h>
#include <arpa/inet.h>
d69 2
d72 2
d92 1
d95 2
d109 2
d315 1
a315 1
	
d360 1
a360 1
	struct sockaddr_in addr;
d381 2
a382 2
		addr.sin_addr.s_addr = *(int *)hp->h_addr;
		rusers_reply_3((char *)&up3, &addr);
d409 2
a410 2
	addr.sin_addr.s_addr = *(int *)hp->h_addr;
	rusers_reply((char *)&up, &addr);
d414 76
d493 14
d509 1
a509 1
	enum clnt_stat clnt_stat;
d511 4
a514 1
	puts("Sending broadcast for rusersd protocol version 3...");
d516 77
a592 5
	clnt_stat = clnt_broadcast(RUSERSPROG, RUSERSVERS_3,
	    RUSERSPROC_NAMES, xdr_void, NULL, xdr_utmp_array,
	    (char *)&up3, rusers_reply_3);
	if (clnt_stat != RPC_SUCCESS && clnt_stat != RPC_TIMEDOUT)
		errx(1, "%s", clnt_sperrno(clnt_stat));
d594 52
a645 7
	puts("Sending broadcast for rusersd protocol version 2...");
	memset(&up, 0, sizeof(up));
	clnt_stat = clnt_broadcast(RUSERSPROG, RUSERSVERS_IDLE,
	    RUSERSPROC_NAMES, xdr_void, NULL, xdr_utmpidlearr,
	    (char *)&up, rusers_reply);
	if (clnt_stat != RPC_SUCCESS && clnt_stat != RPC_TIMEDOUT)
		errx(1, "%s", clnt_sperrno(clnt_stat));
@


1.14
log
@Major overhaul.

Add protocol version 3 support.  To avoid doing two separate broadcasts
(like the solaris client does) we now do the equivalent of clnt_broadcast()
ourselves and send both version 2 and 3 broadcasts.  These are staggered
such that under normal circumstances the version 3 reply will be received
before the version 2 reply (which is what we want).  Version 3 support
is important now that we have long user and host names in utmp.

Avoid potential duplicates on multihomed machines by storing all
the addresses we get back from gethostbyaddr(), not just a single
address.

Reduce the timeout from 1 minute to 30 seconds which is closer to
what Solaris uses and is generally more useful.

Check window width and take this into account when formatting lines
in -l mode.
@
text
@d65 2
a66 2
#include <rpc/pmap_prot.h>
#include <rpc/pmap_rmt.h>
a68 2
#include <arpa/inet.h>
#include <net/if.h>
a69 2
#include <errno.h>
#include <ifaddrs.h>
a87 1
void alarmclock(int);
a89 2
enum clnt_stat get_reply(int, u_long, u_long, struct rpc_msg *,
    struct rmtcallres *, bool_t (*)());
a94 1
struct itimerval timeout;
a101 2
#define MAX_BROADCAST_SIZE 1400

d237 1
a237 1
int
d253 1
a253 1
	hp = gethostbyaddr((char *)&raddrp->sin_addr.s_addr,
d291 1
a291 1
int
d306 2
a307 2

	hp = gethostbyaddr((char *)&raddrp->sin_addr.s_addr,
a404 75
enum clnt_stat
get_reply(int sock, u_long port, u_long xid, struct rpc_msg *msgp,
	  struct rmtcallres *resp, bool_t (*callback)())
{
	int inlen, fromlen;
	struct sockaddr_in raddr;
	char inbuf[UDPMSGSIZE];
	XDR xdr;

retry:
	msgp->acpted_rply.ar_verf = _null_auth;
	msgp->acpted_rply.ar_results.where = (caddr_t)resp;
	msgp->acpted_rply.ar_results.proc = xdr_rmtcallres;

	fromlen = sizeof(struct sockaddr);
	inlen = recvfrom(sock, inbuf, sizeof(inbuf), 0,
	    (struct sockaddr *)&raddr, &fromlen);
	if (inlen < 0) {
		if (errno == EINTR)
			goto retry;
		return (RPC_CANTRECV);
	}
	if (inlen < sizeof(u_int32_t))
		goto retry;

	/*
	 * If the reply we got matches our request, decode the
	 * replay and pass it to the callback function.
	 */
	xdrmem_create(&xdr, inbuf, (u_int)inlen, XDR_DECODE);
	if (xdr_replymsg(&xdr, msgp)) {
		if ((msgp->rm_xid == xid) &&
		    (msgp->rm_reply.rp_stat == MSG_ACCEPTED) &&
		    (msgp->acpted_rply.ar_stat == SUCCESS)) {
			raddr.sin_port = htons((u_short)port);
			(void)(*callback)(resp->results_ptr, &raddr);
		}
	}
	xdr.x_op = XDR_FREE;
	msgp->acpted_rply.ar_results.proc = xdr_void;
	(void)xdr_replymsg(&xdr, msgp);
	(void)(*resp->xdr_results)(&xdr, resp->results_ptr);
	xdr_destroy(&xdr);

	return(RPC_SUCCESS);
}

enum clnt_stat
rpc_setup(int *fdp, XDR *xdrs, struct rpc_msg *msg, struct rmtcallargs *args,
	  AUTH *unix_auth, char *buf)
{
	int on = 1;

	if ((*fdp = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
		return(RPC_CANTSEND);

	if (setsockopt(*fdp, SOL_SOCKET, SO_BROADCAST, &on, sizeof(on)) < 0)
		return(RPC_CANTSEND);

	msg->rm_xid = arc4random();
	msg->rm_direction = CALL;
	msg->rm_call.cb_rpcvers = RPC_MSG_VERSION;
	msg->rm_call.cb_prog = PMAPPROG;
	msg->rm_call.cb_vers = PMAPVERS;
	msg->rm_call.cb_proc = PMAPPROC_CALLIT;
	msg->rm_call.cb_cred = unix_auth->ah_cred;
	msg->rm_call.cb_verf = unix_auth->ah_verf;

	xdrmem_create(xdrs, buf, MAX_BROADCAST_SIZE, XDR_ENCODE);
	if (!xdr_callmsg(xdrs, msg) || !xdr_rmtcall_args(xdrs, args))
		return(RPC_CANTENCODEARGS);

	return(RPC_SUCCESS);
}

a407 15
	enum clnt_stat stat;
	AUTH *unix_auth = authunix_create_default();
	int outlen, outlen3;
	int sock = -1;
	int sock3 = -1;
	int i, maxfd, rval;
	u_long xid, xid3;
	u_long port, port3;
	fd_set *fds = NULL;
	struct sockaddr_in *sin, baddr;
	struct rmtcallargs args;
	struct rmtcallres res, res3;
	struct rpc_msg msg, msg3;
	struct ifaddrs *ifa, *ifap = NULL;
	char buf[MAX_BROADCAST_SIZE], buf3[MAX_BROADCAST_SIZE];
d410 1
a410 1
	XDR xdr;
d412 7
a418 90
	if (getifaddrs(&ifap) != 0) {
		perror("Cannot get list of interface addresses");
		stat = RPC_CANTSEND;
		goto cleanup;
	}

	args.prog = RUSERSPROG;
	args.vers = RUSERSVERS_IDLE;
	args.proc = RUSERSPROC_NAMES;
	args.xdr_args = xdr_void;
	args.args_ptr = NULL;

	stat = rpc_setup(&sock, &xdr, &msg, &args, unix_auth, buf);
	if (stat != RPC_SUCCESS)
		goto cleanup;
	xid = msg.rm_xid;
	outlen = (int)xdr_getpos(&xdr);
	xdr_destroy(&xdr);

	args.vers = RUSERSVERS_3;
	stat = rpc_setup(&sock3, &xdr, &msg3, &args, unix_auth, buf3);
	if (stat != RPC_SUCCESS)
		goto cleanup;
	xid3 = msg3.rm_xid;
	outlen3 = (int)xdr_getpos(&xdr);
	xdr_destroy(&xdr);

	maxfd = sock3 + 1;
	fds = (fd_set *)calloc(howmany(maxfd, NFDBITS), sizeof(fd_mask));
	if (fds == NULL) {
		stat = RPC_CANTSEND;
		goto cleanup;
	}

	memset(&baddr, 0, sizeof(baddr));
	baddr.sin_len = sizeof(struct sockaddr_in);
	baddr.sin_family = AF_INET;
	baddr.sin_port = htons(PMAPPORT);
	baddr.sin_addr.s_addr = htonl(INADDR_ANY);

	memset(&res, 0, sizeof(res));
	res.port_ptr = &port;
	res.xdr_results = xdr_utmpidlearr;
	res.results_ptr = (caddr_t)&up;

	memset(&res3, 0, sizeof(res3));
	res3.port_ptr = &port3;
	res3.xdr_results = xdr_utmp_array;
	res3.results_ptr = (caddr_t)&up3;

	(void)signal(SIGALRM, alarmclock);

	/*
	 * We do 6 runs through the loop.  On even runs we send
	 * a version 3 broadcast.  On odd ones we send a version 2
	 * broadcast.  This should give version 3 replies enough
	 * of an 'edge' over the old version 2 ones in most cases.
	 * We select() waiting for replies for 5 seconds in between
	 * each broadcast.
	 */
	for (i = 0; i < 6; i++) {
		for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
			if (ifa->ifa_addr->sa_family != AF_INET ||
			    !(ifa->ifa_flags & IFF_BROADCAST) ||
			    !(ifa->ifa_flags & IFF_UP) ||
			    ifa->ifa_broadaddr == NULL ||
			    ifa->ifa_broadaddr->sa_family != AF_INET)
				continue;
			sin = (struct sockaddr_in *)ifa->ifa_broadaddr;
			baddr.sin_addr = sin->sin_addr;

			/* use protocol 2 or 3 depending on i (odd or even) */
			if (i & 1) {
				if (sendto(sock, buf, outlen, 0,
				    (struct sockaddr *)&baddr,
				    sizeof(struct sockaddr)) != outlen) {
					warn("unable to send broadcast packet");
					stat = RPC_CANTSEND;
					goto cleanup;
				}
			} else {
				if (sendto(sock3, buf3, outlen3, 0,
				    (struct sockaddr *)&baddr,
				    sizeof(struct sockaddr)) != outlen3) {
					warn("unable to send broadcast packet");
					stat = RPC_CANTSEND;
					goto cleanup;
				}
			}
		}
d420 7
a426 50
		/*
		 * We stay in the select loop for ~5 seconds
		 */
		timerclear(&timeout.it_value);
		timeout.it_value.tv_sec = 5;
		timeout.it_value.tv_usec = 0;
		while (timerisset(&timeout.it_value)) {
			FD_SET(sock, fds);
			FD_SET(sock3, fds);
			setitimer(ITIMER_REAL, &timeout, NULL);
			rval = select(maxfd, fds, NULL, NULL, NULL);
			setitimer(ITIMER_REAL, NULL, &timeout);
			if (rval == -1) {
				if (!timerisset(&timeout.it_value))
					break;
				warn("select");		/* shouldn't happen */
				stat = RPC_CANTRECV;
				goto cleanup;
			}
			if (FD_ISSET(sock3, fds)) {
				stat = get_reply(sock3, port3, xid3, &msg3,
				    &res3, rusers_reply_3);
				if (stat != RPC_SUCCESS)
					goto cleanup;
			}
			if (FD_ISSET(sock, fds)) {
				stat = get_reply(sock, port, xid, &msg,
				    &res, rusers_reply);
				if (stat != RPC_SUCCESS)
					goto cleanup;
			}
		}
	}
cleanup:
	if (ifap != NULL)
		freeifaddrs(ifap);
	if (fds != NULL)
		free(fds);
	if (sock >= 0)
		(void)close(sock);
	if (sock3 >= 0)
		(void)close(sock3);
	AUTH_DESTROY(unix_auth);
}

void
alarmclock(int signo)
{

	timerclear(&timeout.it_value);
@


1.13
log
@Use RNUSERS_MAXHOSTLEN, RNUSERS_MAXUSERLEN and RNUSERS_MAXLINELEN
instead of UT_HOSTSIZE, UT_NAMESIZE and UT_LINESIZE since the UT_*
constants define sizes on the local machine, not the sizes specified
by the rusers protocol.
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.12 2001/06/18 22:19:04 deraadt Exp $	*/
d3 26
d32 1
a32 1
 * 
d43 1
a43 1
 * 
d58 1
a58 1
static const char rcsid[] = "$OpenBSD: rusers.c,v 1.12 2001/06/18 22:19:04 deraadt Exp $";
a60 1
#include <sys/types.h>
d62 1
d64 10
a74 1
#include <err.h>
d76 1
d78 2
a79 4
#include <rpc/rpc.h>
#include <rpc/pmap_clnt.h>
#include <arpa/inet.h>
#include <stdlib.h>
a80 8
/*
 * For now we only try version 2 of the protocol. The current
 * version is 3 (rusers.h), but only Solaris and NetBSD seem
 * to support it currently.
 */
#include <rpcsvc/rnusers.h>	/* Old version */

#define MAX_INT 0x7fffffff
d82 1
a82 1
#define HOST_WIDTH 20
d86 13
a98 1
struct timeval timeout = { 25, 0 };
d101 3
d110 45
a154 1
extern char *__progname;
d172 1
a172 1
remember_host(struct in_addr addr)
d176 69
a244 5
	if (!(hp = (struct host_list *)malloc(sizeof(struct host_list))))
		err(1, NULL);
	hp->addr.s_addr = addr.s_addr;
	hp->next = hosts;
	hosts = hp;
d250 1
a250 3
	int x, idle, i;
	char date[32], idle_time[64], remote[RNUSERS_MAXHOSTLEN + 1];
	char local[HOST_WIDTH + LINE_WIDTH + 2];
d252 1
d254 2
a255 3
	utmpidlearr *up = (utmpidlearr *)replyp;
	char *host, *tmp;
	int days, hours, minutes, seconds;
d264 2
a265 2
			   sizeof(struct in_addr), AF_INET);
	if (hp)
d267 2
a268 1
	else
d270 4
d278 22
a299 9
	for (x = 0; x < up->uia_cnt; x++) {
		strlcpy(date,
		    &(ctime((time_t *)&(up->uia_arr[x]->ui_utmp.ut_time))[4]),
		    sizeof(date));
		/* ctime() adds a trailing \n.  Trimming it is only
		 * mandatory if the output formatting changes.
		 */
		if ((tmp = strchr(date, '\n')) != NULL)
			*tmp = '\0';
d301 12
a312 24
		idle = up->uia_arr[x]->ui_idle;
		sprintf(idle_time, "   :%02d", idle);
		if (idle == MAX_INT)
			strcpy(idle_time, "??");
		else if (idle == 0)
			strcpy(idle_time, "");
		else {
			seconds = idle;
			days = seconds/(60*60*24);
			seconds %= (60*60*24);
			hours = seconds/(60*60);
			seconds %= (60*60);
			minutes = seconds/60;
			seconds %= 60;
			if (idle > 60)
				sprintf(idle_time, "%2d:%02d",
				    minutes, seconds);
			if (idle >= (60*60))
				sprintf(idle_time, "%2d:%02d:%02d",
				    hours, minutes, seconds);
			if (idle >= (24*60*60))
				sprintf(idle_time, "%d days, %d:%02d:%02d",
				    days, hours, minutes, seconds);
		}
d314 2
a315 6
		strncpy(remote, up->uia_arr[x]->ui_utmp.ut_host,
		    sizeof(remote)-1);
		remote[sizeof(remote) - 1] = '\0';
		if (strlen(remote) != 0)
			snprintf(remote, sizeof(remote), "(%.16s)",
			    up->uia_arr[x]->ui_utmp.ut_host);
d317 20
d338 1
a338 2
			strncpy(local, host, sizeof(local));
			strncpy(utline, up->uia_arr[x]->ui_utmp.ut_line,
d341 7
a347 15
			i = sizeof(local) - strlen(utline) - 2;
			if (i < 0)
				i = 0;
			local[i] = '\0';
			strcat(local, ":");
			strlcat(local, utline, sizeof(local));

			printf("%-*.*s %-*.*s %-12.12s %8s %.18s\n",
			    NAME_WIDTH, RNUSERS_MAXUSERLEN,
			    up->uia_arr[x]->ui_utmp.ut_name,
			    HOST_WIDTH+LINE_WIDTH+1, HOST_WIDTH+LINE_WIDTH+1,
			    local, date, idle_time, remote);
		} else
			printf("%.*s ", RNUSERS_MAXUSERLEN,
			    up->uia_arr[x]->ui_utmp.ut_name);
a351 1
	remember_host(raddrp->sin_addr);
d359 1
d363 2
d370 26
d402 4
a405 3
	bzero((char *)&up, sizeof(up));
	if (clnt_call(rusers_clnt, RUSERSPROC_NAMES, xdr_void, NULL,
	    xdr_utmpidlearr, &up, timeout) != RPC_SUCCESS) {
d415 75
d493 15
d509 36
a544 1
	enum clnt_stat clnt_stat;
d546 100
a645 6
	bzero((char *)&up, sizeof(up));
	clnt_stat = clnt_broadcast(RUSERSPROG, RUSERSVERS_IDLE,
	    RUSERSPROC_NAMES, xdr_void, NULL, xdr_utmpidlearr,
	    (char *)&up, rusers_reply);
	if (clnt_stat != RPC_SUCCESS && clnt_stat != RPC_TIMEDOUT)
		errx(1, "%s", clnt_sperrno(clnt_stat));
d649 1
a649 1
usage(void)
d651 2
a652 2
	fprintf(stderr, "Usage: %s [-la] [hosts ...]\n", __progname);
	exit(1);
d655 2
a656 2
int
main(int argc, char *argv[])
a657 15
	int ch;
	extern int optind;
	
	while ((ch = getopt(argc, argv, "al")) != -1)
		switch (ch) {
		case 'a':
			allopt++;
			break;
		case 'l':
			longopt++;
			break;
		default:
			usage();
			/*NOTREACHED*/
		}
d659 2
a660 8
	setlinebuf(stdout);
	if (argc == optind)
		allhosts();
	else {
		for (; optind < argc; optind++)
			(void) onehost(argv[optind]);
	}
	exit(0);
@


1.12
log
@clnt leaks; tommy@@ti.com
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.11 2001/02/17 16:52:23 pjanzen Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers.c,v 1.11 2001/02/17 16:52:23 pjanzen Exp $";
a44 1
#include <utmp.h>
d102 1
a102 1
	char date[32], idle_time[64], remote[UT_HOSTSIZE + 1];
d104 1
a104 1
	char utline[UT_LINESIZE + 1];
d165 1
a165 1
			snprintf(remote, UT_HOSTSIZE + 1, "(%.16s)",
d171 1
a171 1
			    UT_LINESIZE);
d181 1
a181 1
			    NAME_WIDTH, UT_NAMESIZE,
d186 1
a186 1
			printf("%.*s ", UT_NAMESIZE,
@


1.11
log
@Tidy, be a bit more careful about buffers, and don't use strlen() on utmp.
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.10 2001/02/05 21:41:07 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers.c,v 1.10 2001/02/05 21:41:07 deraadt Exp $";
d219 1
d224 1
@


1.10
log
@default to 8 wide for user names
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.9 2001/01/31 19:48:06 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers.c,v 1.9 2001/01/31 19:48:06 deraadt Exp $";
d39 1
d56 1
d59 1
a59 1
char *argv0;
d70 2
d92 2
a93 4
	if (!(hp = (struct host_list *)malloc(sizeof(struct host_list)))) {
		fprintf(stderr, "%s: no memory.\n", argv0);
		exit(1);
	}
d102 4
a105 2
	int x, idle;
	char date[32], idle_time[64], remote[64], local[64];
d108 1
a108 1
	char *host;
d128 1
a128 1
		strncpy(date,
d130 6
a135 1
		    sizeof(date)-1);
d164 1
d166 1
a166 1
			sprintf(remote, "(%.16s)",
d171 7
a177 2
			local[HOST_WIDTH + LINE_WIDTH + 1 -
			    strlen(up->uia_arr[x]->ui_utmp.ut_line) - 1] = 0;
d179 1
a179 3
			strncat(local, up->uia_arr[x]->ui_utmp.ut_line,
				sizeof (local) - strlen (local) - 1);
			local[sizeof (local) - 1] = 0;
a180 1
#define MAXNAME	8
d182 1
a182 1
			    MAXNAME, UT_NAMESIZE,
d206 2
a207 5
	if (hp == NULL) {
		fprintf(stderr, "%s: unknown host \"%s\"\n",
			argv0, host);
		exit(1);
	}
d211 1
a211 1
		clnt_pcreateerror(argv0);
d218 1
a218 1
		clnt_perror(rusers_clnt, argv0);
d235 2
a236 4
	if (clnt_stat != RPC_SUCCESS && clnt_stat != RPC_TIMEDOUT) {
		fprintf(stderr, "%s: %s\n", argv0, clnt_sperrno(clnt_stat));
		exit(1);
	}
d242 1
a242 1
	fprintf(stderr, "Usage: %s [-la] [hosts ...]\n", argv0);
a251 5
	if (!(argv0 = strrchr(argv[0], '/')))
		argv0 = argv[0];
	else
		argv0++;

@


1.9
log
@fat utmp handling; truncate to 16 chars for now, until we decide how ugly
we will accept.
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.8 1997/08/18 03:11:28 millert Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers.c,v 1.8 1997/08/18 03:11:28 millert Exp $";
d168 1
a168 1
#define MAXNAME	16
@


1.8
log
@#include <string.h> not <strings.h> -- Yes, I'm a weanie...
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.7 1997/07/08 16:49:45 bitblt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers.c,v 1.7 1997/07/08 16:49:45 bitblt Exp $";
d168 3
a170 1
			printf("%-8.8s %-*.*s %-12.12s %8s %.18s\n",
d175 1
a175 1
			printf("%.8s ",
@


1.7
log
@Fixed remotely triggerable buffer overflow.
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.6 1997/06/20 10:07:01 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers.c,v 1.6 1997/06/20 10:07:01 deraadt Exp $";
d40 1
a40 1
#include <strings.h>
@


1.6
log
@Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.5 1997/01/17 07:13:15 millert Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers.c,v 1.5 1997/01/17 07:13:15 millert Exp $";
d164 3
a166 1
			strcat(local, up->uia_arr[x]->ui_utmp.ut_line);
@


1.5
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.4 1996/08/16 22:24:18 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers.c,v 1.4 1996/08/16 22:24:18 deraadt Exp $";
d42 1
d171 1
a171 1
			printf("%0.8s ",
d221 1
a221 1
	    &up, rusers_reply);
@


1.4
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: rusers.c,v 1.3 1996/06/26 05:38:56 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers.c,v 1.3 1996/06/26 05:38:56 deraadt Exp $";
d240 1
a240 1
	if (!(argv0 = rindex(argv[0], '/')))
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: rusers.c,v 1.2 1996/04/21 23:43:46 deraadt Exp $";
d102 1
a102 1
	struct utmpidlearr *up = (struct utmpidlearr *)replyp;
d124 2
a125 2
			&(ctime((time_t *)&(up->uia_arr[x]->ui_utmp.ut_time))[4]),
			sizeof(date)-1);
d143 1
a143 1
					minutes, seconds);
d146 1
a146 1
					hours, minutes, seconds);
d149 1
a149 1
					days, hours, minutes, seconds);
d167 2
a168 4
			    HOST_WIDTH+LINE_WIDTH+1, HOST_WIDTH+LINE_WIDTH+1, local,
			    date,
			    idle_time,
			    remote);
d183 1
a183 1
	struct utmpidlearr up;
d214 1
a214 1
	struct utmpidlearr up;
a243 1

@


1.2
log
@sync to netbsd 960418
@
text
@d1 2
d32 1
a32 1
static char rcsid[] = "$Id: rusers.c,v 1.1.1.1 1995/10/18 08:46:04 deraadt Exp $";
@


1.1
log
@Initial revision
@
text
@d30 1
a30 1
static char rcsid[] = "$Id: rusers.c,v 1.10 1993/12/10 19:33:58 jtc Exp $";
d227 2
a228 1
void usage(void)
d234 2
a235 1
void main(int argc, char *argv[])
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
