head	1.30;
access;
symbols
	OPENBSD_4_8:1.28.0.12
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.8
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.10
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.6
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.4
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.27.0.4
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.26.0.12
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.10
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.8
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.6
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.4
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20;
locks; strict;
comment	@ * @;


1.30
date	2010.10.17.08.43.20;	author djm;	state dead;
branches;
next	1.29;

1.29
date	2010.10.15.10.18.42;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2007.12.30.13.35.27;	author sobrado;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.06.05.03.29;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.15.15.03.11;	author aaron;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.19.23.55.05;	author dhartmei;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.04.00.51.10;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.17.07.10.52;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.20.22.30.58;	author rees;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.20.28.04;	author rees;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.24.17.27.57;	author rees;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.15.21.11.29;	author rees;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.02.17.09.18;	author rees;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.29.21.43.48;	author rees;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.27.14.13.08;	author rees;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.26.22.12.56;	author rees;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.26.21.05.15;	author rees;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.26.20.00.16;	author rees;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.26.16.10.01;	author rees;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.20.15.52.54;	author rees;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.19.21.24.27;	author rees;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.17.21.04.14;	author rees;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.17.17.58.24;	author rees;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.17.17.10.44;	author rees;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.17.15.16.46;	author rees;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.16.23.09.36;	author rees;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.16.21.02.21;	author rees;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.02.20.15.06;	author rees;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.28.21.29.45;	author rees;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.27.19.41.45;	author rees;	state Exp;
branches;
next	;


desc
@@


1.30
log
@remove sectok(1); it hasn't been updated in years and doesn't work
with the current generation of tokens; ok markus@@ deraadt@@
@
text
@/*	$OpenBSD: cyberflex.c,v 1.29 2010/10/15 10:18:42 jsg Exp $ */

/*
 * copyright 1999, 2000
 * the regents of the university of michigan
 * all rights reserved
 *
 * permission is granted to use, copy, create derivative works
 * and redistribute this software and such derivative works
 * for any purpose, so long as the name of the university of
 * michigan is not used in any advertising or publicity
 * pertaining to the use or distribution of this software
 * without specific, written prior authorization.  if the
 * above copyright notice or any other identification of the
 * university of michigan is included in any copy of any
 * portion of this software, then the disclaimer below must
 * also be included.
 *
 * this software is provided as is, without representation
 * from the university of michigan as to its fitness for any
 * purpose, and without warranty by the university of
 * michigan of any kind, either express or implied, including
 * without limitation the implied warranties of
 * merchantability and fitness for a particular purpose. the
 * regents of the university of michigan shall not be liable
 * for any damages, including special, indirect, incidental, or
 * consequential damages, with respect to any claim arising
 * out of or in connection with the use of the software, even
 * if it has been or is hereafter advised of the possibility of
 * such damages.
 */

#ifndef __palmos__
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <fcntl.h>
#include <openssl/des.h>
#ifdef __linux
#include <sha.h>
#define SHA1_CTX SHA_CTX
#define SHA1Init SHA1_Init
#define SHA1Update SHA1_Update
#define SHA1Final SHA1_Final
#else				/* __linux */
#include <sha1.h>
#endif
#else
#pragma pack(2)
#include <Common.h>
#include <System/SysAll.h>
#include <System/Unix/sys_types.h>
#include <System/Unix/unix_stdio.h>
#include <System/Unix/unix_stdlib.h>
#include <System/Unix/unix_string.h>
#include <UI/UIAll.h>
#include "getopt.h"
#include "field.h"
#define NO_SHA
#endif
#include <sectok.h>

#include "sc.h"

#define MAX_KEY_FILE_SIZE 1024
#define NUM_RSA_KEY_ELEMENTS 5
#define RSA_BIT_LEN 1024
#define KEY_FILE_HEADER_SIZE 8

#define myisprint(x) ((x) >= '!' && (x) <= 'z')

static u_char key_fid[] = {0x00, 0x11};
static u_char DFLTATR[] = {0x81, 0x10, 0x06, 0x01};
static u_char DFLTAUT0[] = {0xad, 0x9f, 0x61, 0xfe, 0xfa, 0x20, 0xce, 0x63};
static u_char AUT0[20];

int	aut0_vfyd;

static void print_acl(int isdir, u_char *acl);

#ifndef __palmos__
/* default signed applet key of Cyberflex Access */
static DES_cblock app_key = {0x6A, 0x21, 0x36, 0xF5, 0xD8, 0x0C, 0x47, 0x83};
#endif

static int
get_AUT0(int argc, char *argv[], char *prompt, int confirm, u_char *digest)
{
#ifdef NO_SHA
	memcpy(digest, DFLTAUT0, sizeof DFLTAUT0);
#else
	int	i, dflag = 0, xflag = 0;
	SHA1_CTX ctx;
	char   *s, *s2;

	optind = optreset = 1;
	opterr = 0;

	while ((i = getopt(argc, argv, "dk:x:")) != -1) {
		switch (i) {
		case 'd':
			memcpy(digest, DFLTAUT0, sizeof DFLTAUT0);
			dflag = 1;
			break;
		case 'x':
			if (sectok_parse_input(optarg, digest, 8) != 8) {
				printf("AUT0 must be length 8\n");
				return -1;
			}
			xflag = 1;
			break;
		}
	}

	if (!dflag && !xflag) {
		SHA1Init(&ctx);
		/* "-" means DFLTAUT0 */
		s = getpass(prompt);
		if (!strcmp(s, "-"))
			memcpy(digest, DFLTAUT0, sizeof DFLTAUT0);
		else {
			if (confirm) {
				s2 = strdup(s);
				s = getpass("Re-enter passphrase: ");
				if (strcmp(s, s2)) {
					printf("passphrase mismatch\n");
					return -1;
				}
				bzero(s2, strlen(s2));
				free(s2);
			}
			SHA1Update(&ctx, s, strlen(s));
			bzero(s, strlen(s));
			SHA1Final(digest, &ctx);
		}
	}
#endif

	return 0;
}

int
jlogin(int argc, char *argv[])
{
	int	i, keyno = 0, vflag = 0, sw;

	if (fd < 0 && reset(0, NULL) < 0)
		return -1;

	cla = cyberflex_inq_class(fd);
	if (cla < 0) {
		printf("can't determine Cyberflex application class\n");
		return -1;
	}
	optind = optreset = 1;

	while ((i = getopt(argc, argv, "dk:vx:")) != -1) {
		switch (i) {
		case 'k':
			keyno = atoi(optarg);
			break;
		case 'v':
			vflag = 1;
			break;
		}
	}

	if (get_AUT0(argc, argv, "Enter AUT0 passphrase: ", 0, AUT0) < 0)
		return -1;

	if (vflag) {
		printf("Class %02x\n", cla);
		for (i = 0; i < 8; i++)
			printf("%02x ", AUT0[i]);
		printf("\n");
	}
	sectok_apdu(fd, cla, 0x2a, 0, keyno, 8, AUT0, 0, NULL, &sw);

	if (!sectok_swOK(sw)) {
		printf("AUT0 failed: %s\n", sectok_get_sw(sw));
		aut0_vfyd = 0;
		return -1;
	}
	aut0_vfyd = 1;
	return 0;
}

int
jaut(int argc, char *argv[])
{
	static char *jlav[] = {"login", "-d", NULL};

	return jlogin(2, jlav);
}

int
jdefault(int argc, char *argv[])
{
	u_char buf[8];
	int	i, p1 = 4, sw;

	optind = optreset = 1;

	while ((i = getopt(argc, argv, "d")) != -1) {
		switch (i) {
		case 'd':
			p1 = 5;
			break;
		}
	}

	if (fd < 0 && reset(0, NULL) < 0)
		return -1;
	if (!aut0_vfyd)
		jaut(0, NULL);

	sectok_apdu(fd, cla, 0x08, p1, 0, 0, buf, 0, NULL, &sw);
	if (!sectok_swOK(sw)) {
		/* error */
		sectok_print_sw(sw);
		return -1;
	}
	return 0;
}

int
jatr(int argc, char *argv[])
{
	u_char buf[64];
	int	n = 0, sw;

	buf[n++] = 0x90;
	buf[n++] = 0x94;	/* TA1 */
	buf[n++] = 0x40;	/* TD1 */
	buf[n++] = 0x28;	/* TC2 (WWT=4sec) */
	if (argc > 1) {
		/* set historical bytes from command line */
		n += sectok_parse_input(argv[1], &buf[n], 15);
	} else {
		/* no historical bytes given, use default */
		memcpy(&buf[n], DFLTATR, sizeof DFLTATR);
		n += sizeof DFLTATR;
	}
	buf[0] |= ((n - 2) & 0xf);

	if (fd < 0 && reset(0, NULL) < 0)
		return -1;

	sectok_apdu(fd, cla, 0xfa, 0, 0, n, buf, 0, NULL, &sw);
	if (!sectok_swOK(sw)) {
		/* error */
		sectok_print_sw(sw);
		return -1;
	}
	return 0;
}

int
jdata(int argc, char *argv[])
{
	u_char buf[32];
	int	i, sw;

	if (fd < 0 && reset(0, NULL) < 0)
		return -1;

	cla = cyberflex_inq_class(fd);
	if (cla < 0) {
		printf("can't determine Cyberflex application class\n");
		return -1;
	}
	sectok_apdu(fd, cla, 0xca, 0, 1, 0, NULL, 0x16, buf, &sw);
	if (sectok_swOK(sw)) {
		printf("serno ");
		for (i = 0; i < 6; i++)
			printf("%02x ", buf[i]);
		if (buf[20] == 0x13) {
			/* these cards have a different format */
			printf("scrambled sver %d.%02d ", buf[19], buf[20]);
			if (buf[21] == 0x0c)
				printf("augmented ");
			else
				if (buf[21] != 0x0b)
					printf("unknown ");
			printf("crypto %5.5s class %02x\n", &buf[14],
			    cyberflex_inq_class(fd));
		} else {
			printf("batch %02x sver %d.%02d ", buf[6], buf[7], buf[8]);
			if (buf[9] == 0x0c)
				printf("augmented ");
			else
				if (buf[9] != 0x0b)
					printf("unknown ");
			printf("crypto %9.9s class %02x\n", &buf[10], buf[19]);
		}
	} else {
		/* error */
		sectok_print_sw(sw);
	}
	return 0;
}
#define JDIRSIZE 40

static char *apptype[] = {
	"?",
	"applet",
	"app",
	"app/applet",
};

static char *appstat[] = {
	"?",
	"created",
	"installed",
	"registered",
};

static char *filestruct[] = {
	"binary",
	"fixed rec",
	"variable rec",
	"cyclic",
	"program",
};

static char *principals[] = {
	"world", "CHV1", "CHV2", "AUT0", "AUT1", "AUT2", "AUT3", "AUT4"
};

static char *f_rights[] = {
	"r", "w", "x/a", "inval", "rehab", NULL, "dec", "inc"
};

static char *d_rights[] = {
	"l", "d", "a", NULL, NULL, "i", "manage", NULL
};

static void
print_acl(int isdir, u_char *acl)
{
	int	i, j;
	char   *as;

	for (i = 0; i < 8; i++) {
		if (acl[i]) {
			printf(" %s: ", principals[i]);
			for (j = 0; j < 8; j++)
				if (acl[i] & (1 << j)) {
					as = isdir ? d_rights[j] : f_rights[j];
					if (as)
						printf("%s ", as);
				}
			printf("\n");
		}
	}
}

void
sectok_fmt_aidname(char *aidname, int aidlen, u_char *aid, size_t len)
{
	int	i, istext = 1;

	for (i = 1; i < aidlen; i++)
		if (!myisprint(aid[i])) {
			istext = 0;
			break;
		}
	if (istext) {
		if (aidlen + 1 > len)
			aidlen = len - 1;
		memcpy(aidname, aid, aidlen);
		aidname[aidlen] = '\0';
		if (aid[0] == 0xfc)
			aidname[0] = '#';
	} else {
		for (i = 0; i < aidlen; i++)
			snprintf(&aidname[i * 2], len - ( i * 2),
			    "%02x", aid[i]);
	}
}

int
ls(int argc, char *argv[])
{
	int	i, p2, fid, lflag = 0, buflen, sw;
	int	isdir, fsize;
	char    ftype[32], fname[6], aidname[34];
	u_char buf[JDIRSIZE];

	optind = optreset = 1;

	while ((i = getopt(argc, argv, "l")) != -1) {
		switch (i) {
		case 'l':
			lflag = 1;
			break;
		}
	}

	if (fd < 0 && reset(0, NULL) < 0)
		return -1;

	for (p2 = 0;; p2++) {
		buflen = sectok_apdu(fd, cla, 0xa8, 0, p2, 0, NULL,
		    JDIRSIZE, buf, &sw);
		if (!sectok_swOK(sw))
			break;

		/* Don't show reserved fids */
		fid = sectok_mksw(buf[4], buf[5]);
		if (fid == 0x3f11 || fid == 0x3fff || fid == 0xffff)
			continue;

		/* Format name */
		sectok_fmt_fid(fname, sizeof fname, &buf[4]);

		/* Format size */
		fsize = (buf[2] << 8) | buf[3];

		/* Format file type */
		isdir = 0;
		aidname[0] = '\0';
		if (buf[6] == 1) {
			/* root */
			snprintf(ftype, sizeof ftype, "root");
			isdir = 1;
		} else
			if (buf[6] == 2) {
				/* DF */
				if (buf[12] == 27) {
					/* application */
					snprintf(ftype, sizeof ftype, "%s %s",
					    appstat[buf[10]], apptype[buf[9]]);
					if (buflen > 23 && buf[23]) {
						aidname[0] = ' ';
						sectok_fmt_aidname(&aidname[1],
						    buf[23], &buf[24],
						    sizeof aidname - 1);
					}
				} else
					snprintf(ftype, sizeof ftype,
					    "directory");
				isdir = 1;
			} else
				if (buf[6] == 4) {
					/* EF */
					snprintf(ftype, sizeof ftype, "%s",
					    filestruct[buf[13]]);
				}
		if (!lflag)
			printf("%-4s\n", fname);
		else
			printf("%-4s %5d %s%s\n", fname, fsize, ftype, aidname);
	}
	return 0;
}

int
acl(int argc, char *argv[])
{
	int	i, j, xflag = 0, isdir, prno, rt, sw;
	u_char fid[2], buf[256], acl[8];
	char   *prin;

	optind = optreset = 1;

	while ((i = getopt(argc, argv, "x")) != -1) {
		switch (i) {
		case 'x':
			xflag = 1;
			break;
		}
	}

	if (argc - optind < 1) {
 usage:
		printf("usage: acl [-x] fid [principal: r1 r2 ...]\n");
		return -1;
	}
	/* Select the fid */
	sectok_parse_fname(argv[optind++], fid);
	sectok_apdu(fd, cla, 0xa4, 0, 0, 2, fid, sizeof buf, buf, &sw);
	if (!sectok_swOK(sw)) {
		printf("Select: %s\n", sectok_get_sw(sw));
		return -1;
	}
	isdir = (buf[6] == 1 || buf[6] == 2);

	/* Get current acl */
	sectok_apdu(fd, cla, 0xfe, 0, 0, 0, NULL, 8, acl, &sw);
	if (!sectok_swOK(sw)) {
		printf("GetFileACL: %s\n", sectok_get_sw(sw));
		return -1;
	}
	if (argc - optind < 1) {
		/* No acl given; print acl and exit */
		if (xflag) {
			for (i = 0; i < 8; i++)
				printf("%02x ", acl[i]);
			printf("\n");
		} else
			print_acl(isdir, acl);
		return 0;
	}
	prin = argv[optind++];

	/* strip trailing ':' */
	if (prin[0] != '\0' && prin[strlen(prin) - 1] == ':')
		prin[strlen(prin) - 1] = '\0';
	else
		goto usage;

	/* Find principal */
	for (prno = 0; prno < 8; prno++)
		if (!strcasecmp(prin, principals[prno]))
			break;
	if (prno >= 8) {
		printf("unknown principal \"%s\"\n", prin);
		return -1;
	}
	/* Parse new rights */
	rt = 0;
	for (i = optind; i < optind + 8 && i < argc; i++) {
		for (j = 0; j < 8; j++) {
			if ((d_rights[j] && !strcasecmp(argv[i], d_rights[j])) ||
			    (f_rights[j] && !strcasecmp(argv[i], f_rights[j])))
				rt |= (1 << j);
		}
	}
	acl[prno] = rt;

	/* Set acl */
	sectok_apdu(fd, cla, 0xfc, 0, 0, 8, acl, 0, NULL, &sw);
	if (!sectok_swOK(sw)) {
		printf("ChangeFileACL: %s\n", sectok_get_sw(sw));
		return -1;
	}
	print_acl(isdir, acl);

	return 0;
}

int
jcreate(int argc, char *argv[])
{
	u_char fid[2];
	int	sw, fsize;

	if (argc != 3) {
		printf("usage: create fid size\n");
		return -1;
	}
	sectok_parse_fname(argv[1], fid);
	sscanf(argv[2], "%d", &fsize);

	if (fd < 0 && reset(0, NULL) < 0)
		return -1;
	if (!aut0_vfyd)
		jaut(0, NULL);

	if (cyberflex_create_file(fd, cla, fid, fsize, 3, &sw) < 0) {
		printf("create_file: %s\n", sectok_get_sw(sw));
		return -1;
	}
	return 0;
}

int
jdelete(int argc, char *argv[])
{
	u_char fid[2];
	int	sw;

	if (argc != 2) {
		printf("usage: delete fid\n");
		return -1;
	}
	sectok_parse_fname(argv[1], fid);

	if (fd < 0 && reset(0, NULL) < 0)
		return -1;
	if (!aut0_vfyd)
		jaut(0, NULL);

	if (cyberflex_delete_file(fd, cla, fid, &sw) < 0) {
		printf("delete_file: %s\n", sectok_get_sw(sw));
		return -1;
	}
	return 0;
}
#define MAX_BUF_SIZE 256
#define MAX_APP_SIZE 4096
#define MAX_APDU_SIZE 0xfa
#define BLOCK_SIZE 8
#define MAXTOKENS 16

u_char progID[2], contID[2];

#ifndef __palmos__
int
jload(int argc, char *argv[])
{
	char   *cp, *filename, progname[5], contname[5];
	u_char aid[16], app_data[MAX_APP_SIZE], data[MAX_BUF_SIZE];
	int	i, j, vflag = 0, gotprog = 0, gotcont = 0, fd_app, size;
	int	aidlen = 0, sw;
	int	cont_size = 1152, inst_size = 1024;
	DES_cblock tmp;
	DES_key_schedule schedule;
	static u_char acl[] = {0x81, 0, 0, 0xff, 0, 0, 0, 0};

	optind = optreset = 1;

	while ((i = getopt(argc, argv, "p:c:s:i:a:v")) != -1) {
		switch (i) {
		case 'p':
			sectok_parse_input(optarg, progID, 2);
			gotprog = 1;
			break;
		case 'c':
			sectok_parse_input(optarg, contID, 2);
			gotcont = 1;
			break;
		case 's':
			sscanf(optarg, "%d", &cont_size);
			break;
		case 'i':
			sscanf(optarg, "%d", &inst_size);
			break;
		case 'a':
			aidlen = sectok_parse_input(optarg, aid, sizeof aid);
			break;
		case 'v':
			vflag = 1;
			break;
		default:
			printf("unknown option.  command aborted.\n");
			return -1;
		}
	}

	if (argc - optind < 1) {
		printf("missing file name\n");
		return -1;
	}
	filename = argv[optind++];

	/*
         * We prepend 0xfc to the aid to make it a "proprietary aid".
         * See 7816-5 sec 5.2.4.
         */
	if (aidlen <= 0) {
		/* No aid given, derive from file name */
		cp = strrchr(filename, '/');
		if (cp)
			cp++;
		else
			cp = filename;
		aid[0] = 0xfc;
		strncpy(&aid[1], cp, sizeof aid - 1);
		aidlen = (aid[15] == '\0') ? strlen(aid) : 16;
	} else
		if (aid[0] == '#')
			aid[0] = 0xfc;

	if (!gotprog) {
		/* No progID given, derive from aid */
		progID[0] = aid[1];
		progID[1] = 'p';
	}
	if (!gotcont) {
		/* No contID given, derive from aid */
		contID[0] = aid[1];
		contID[1] = 'c';
	}
	if (fd < 0 && reset(0, NULL) < 0)
		return -1;
	if (!aut0_vfyd)
		jaut(0, NULL);

	sectok_fmt_fid(progname, sizeof progname, progID);
	sectok_fmt_fid(contname, sizeof contname, contID);

	if (vflag) {
		printf("applet file             \"%s\"\n", filename);
		printf("program ID              %s\n", progname);
		printf("container ID            %s\n", contname);
		printf("instance container size %d\n", cont_size);
		printf("instance data size      %d\n", inst_size);
		printf("AID                     ");
		for (i = 0; i < aidlen; i++)
			printf("%02x ", aid[i]);
		printf("\n");
	}
	/* open the input file */
	fd_app = open(filename, O_RDONLY, NULL);
	if (fd_app == -1) {
		fprintf(stderr, "cannot open file \"%s\"\n", filename);
		return -1;
	}
	/* read the input file */
	size = read(fd_app, app_data, MAX_APP_SIZE);
	if (size <= 0) {
		fprintf(stderr, "error reading file %s\n", filename);
		return -1;
	}
	/* size must be able to be divided by BLOCK_SIZE */
	if (size % BLOCK_SIZE != 0) {
		fprintf(stderr, "file \"%s\" size %d not divisible by %d\n", filename, size, BLOCK_SIZE);
		return -1;
	}
	/* compute the signature of the applet */
	/* initialize the result buffer */
	memset(tmp, 0, BLOCK_SIZE);

	/* chain.  DES encrypt one block, XOR the cyphertext with the next
	 * block, ... continues until the end of the buffer */

	DES_set_key(&app_key, &schedule);

	for (i = 0; i < size / BLOCK_SIZE; i++) {
		for (j = 0; j < BLOCK_SIZE; j++)
			tmp[j] = tmp[j] ^ app_data[i * BLOCK_SIZE + j];
		DES_ecb_encrypt(&tmp, &tmp, &schedule, DES_ENCRYPT);
	}

	if (vflag) {
		/* print out the signature */
		printf("signature ");
		for (j = 0; j < BLOCK_SIZE; j++)
			printf("%02x ", tmp[j]);
		printf("\n");
	}
	/* select the default loader */
	sectok_apdu(fd, cla, 0xa4, 0x04, 0, 0, NULL, 0, NULL, &sw);
	if (!sectok_swOK(sw)) {
		/* error */
		printf("can't select default loader: %s\n", sectok_get_sw(sw));
		return -1;
	}
	/* select 3f.00 (root) */
	if (sectok_selectfile(fd, cla, root_fid, &sw) < 0)
		return -1;

	/* create program file */
	if (cyberflex_create_file_acl(fd, cla, progID, size, 3, acl, &sw) < 0) {
		/* error */
		printf("can't create %s: %s\n", progname, sectok_get_sw(sw));
		return -1;
	}
	/* update binary */
	for (i = 0; i < size; i += MAX_APDU_SIZE) {
		int	send_size;

		/* compute the size to be sent */
		if (size - i > MAX_APDU_SIZE)
			send_size = MAX_APDU_SIZE;
		else
			send_size = size - i;

		sectok_apdu(fd, cla, 0xd6, i / 256, i % 256, send_size,
		    app_data + i, 0, NULL, &sw);

		if (!sectok_swOK(sw)) {
			/* error */
			printf("updating binary %s: %s\n", progname,
			    sectok_get_sw(sw));
			return -1;
		}
	}

	/* manage program .. validate */
	sectok_apdu(fd, cla, 0x0a, 01, 0, 0x08, tmp, 0, NULL, &sw);

	if (!sectok_swOK(sw)) {
		/* error */
		printf("validating applet in %s: %s\n", progname,
		    sectok_get_sw(sw));
		return -1;
	}
	/* select the default loader */
	sectok_apdu(fd, cla, 0xa4, 0x04, 0, 0, NULL, 0, NULL, &sw);
	if (!sectok_swOK(sw)) {
		/* error */
		printf("selecting default loader: %s\n", sectok_get_sw(sw));
		return -1;
	}
	/* execute method -- call the install() method in the cardlet. cardlet
	 * type 01 (applet, not application) */

	data[0] = 0x01;		/* cardlet type = 1 (applet, not application) */
	data[1] = progID[0];	/* FID, upper */
	data[2] = progID[1];	/* FID, lower */
	data[3] = cont_size >> 8;	/* instance container size 0x0800
					 * (1152) byte, upper */
	data[4] = cont_size & 0xff;	/* instance container size 0x0800
					 * (1152) byte, lower */
	data[5] = contID[0];	/* container ID (7778), upper */
	data[6] = contID[1];	/* container ID (7778), lower */
	data[7] = inst_size >> 8;	/* instance size 0x0400 (1024) byte,
					 * upper */
	data[8] = inst_size & 0xff;	/* instance size 0x0400 (1024) byte,
					 * lower */
	data[9] = 0x00;		/* AID length 0x0005, upper */
	data[10] = aidlen;	/* AID length 0x0005, lower */
	memcpy(&data[11], aid, aidlen);

	sectok_apdu(fd, cla, 0x0c, 0x13, 0, 11 + aidlen, data, 0, NULL, &sw);
	if (!sectok_swOK(sw)) {
		/* error */
		printf("executing install() method in applet %s: %s\n",
		    progname, sectok_get_sw(sw));
		return -1;
	}
	/* That's it! :) */
	return 0;
}
#endif

int
junload(int argc, char *argv[])
{
	char    progname[5], contname[5];
	int	i, vflag = 0, gotprog = 0, gotcont = 0, sw;

	optind = optreset = 1;

	while ((i = getopt(argc, argv, "p:c:v")) != -1) {
		switch (i) {
		case 'p':
			sectok_parse_input(optarg, progID, 2);
			gotprog = 1;
			break;
		case 'c':
			sectok_parse_input(optarg, contID, 2);
			gotcont = 1;
			break;
		case 'v':
			vflag = 1;
			break;
		default:
			printf("unknown option.  command aborted.\n");
			return -1;
		}
	}

	if (argc - optind >= 1) {
		/* Derive progID and contID from filename */
		if (!gotprog) {
			progID[0] = argv[optind][0];
			progID[1] = 'p';
			gotprog = 1;
		}
		if (!gotcont) {
			contID[0] = argv[optind][0];
			contID[1] = 'c';
			gotcont = 1;
		}
	}
	/* Use old defaults */
	if (!gotprog)
		memcpy(progID, "ww", 2);
	if (!gotcont)
		memcpy(contID, "wx", 2);

	if (fd < 0 && reset(0, NULL) < 0)
		return -1;
	if (!aut0_vfyd)
		jaut(0, NULL);

	sectok_fmt_fid(progname, sizeof progname, progID);
	sectok_fmt_fid(contname, sizeof contname, contID);

	if (vflag) {
		printf("program ID              %s\n", progname);
		printf("container ID            %s\n", contname);
	}
	/* select 3f.00 (root) */
	if (sectok_selectfile(fd, cla, root_fid, &sw) < 0) {
		printf("can't select root: %s\n", sectok_get_sw(sw));
		return -1;
	}
	/* select program file */
	if (sectok_selectfile(fd, cla, progID, &sw) >= 0) {

		/* manage program -- reset */
		sectok_apdu(fd, cla, 0x0a, 02, 0, 0, NULL, 0, NULL, &sw);
		if (!sectok_swOK(sw)) {
			/* error */
			printf("resetting applet: %s\n", sectok_get_sw(sw));
		}
		/* delete program file */
		if (cyberflex_delete_file(fd, cla, progID, &sw) < 0)
			printf("delete_file %s: %s\n", progname, sectok_get_sw(sw));
	} else
		if (vflag)
			printf("no program file... proceed to delete data container\n");

	/* delete data container */
	if (cyberflex_delete_file(fd, cla, contID, &sw) < 0)
		printf("delete_file %s: %s\n", contname, sectok_get_sw(sw));

	return 0;
}

#ifndef __palmos__
#define DELIMITER " :\t\n"
#define KEY_BLOCK_SIZE 14

/* download DES keys into 3f.00/00.11 */
int
cyberflex_load_key(int fd, u_char *buf)
{
	int	sw, argc = 0, i, j, tmp;
	u_char *token;
	u_char data[MAX_BUF_SIZE];
	u_char key[BLOCK_SIZE];

#if 0
	/* select the default loader */
	rv = scwrite(fd, cla, 0xa4, 0x04, 0, 0x00, NULL, &r1, &r2);
	if (r1 != 0x90 && r1 != 0x61) {
		//error
		    printf("selecting the default loader: ");
		print_r1r2(r1, r2);
		return -1;
	}
#endif

	printf("ca_load_key buf=%s\n", buf);
	token = strtok(buf, DELIMITER);
	token = strtok(NULL, DELIMITER);
	if (token == NULL) {
		printf("usage: jk number_of_keys\n");
		return -1;
	}
	argc = atoi(token);

	if (argc > 2) {
		printf("current Cyberflex Access cannot download more than 2 keys to the key file.  Sorry. :(\n");
		return -1;
	}
	if (argc < 0) {
		printf("you want to down load %d keys??\n", argc);
		return -1;
	}
	if (!aut0_vfyd)
		jaut(0, NULL);

	/* Now let's do it. :) */

	/* add the AUT0 */
	cyberflex_fill_key_block(data, 0, 1, AUT0);

	/* add the applet sign key */
	cyberflex_fill_key_block(data + KEY_BLOCK_SIZE, 5, 0, app_key);

	/* then add user defined keys */
	for (i = 0; i < argc; i++) {
		printf("key %d : ", i);
		for (j = 0; j < BLOCK_SIZE; j++) {
			fscanf(cmdf, "%02x", &tmp);
			key[j] = (u_char) tmp;
		}

		cyberflex_fill_key_block(data + 28 + i * KEY_BLOCK_SIZE,
		    6 + i, 0, key);
	}

	/* add the suffix */
	data[28 + argc * KEY_BLOCK_SIZE] = 0;
	data[28 + argc * KEY_BLOCK_SIZE + 1] = 0;

	for (i = 0; i < KEY_BLOCK_SIZE * (argc + 2) + 2; i++)
		printf("%02x ", data[i]);
	printf("\n");

	/* select 3f.00 (root) */
	if (sectok_selectfile(fd, cla, root_fid, &sw) < 0) {
		printf("select root: %s\n", sectok_get_sw(sw));
		return -1;
	}
	/* select 00.11 (key file) */
	if (sectok_selectfile(fd, cla, key_fid, &sw) < 0) {
		printf("select key file: %s\n", sectok_get_sw(sw));
		return -1;
	}
	/* all righty, now let's send it to the card! :) */
	sectok_apdu(fd, cla, 0xd6, 0, 0, KEY_BLOCK_SIZE * (argc + 2) + 2,
	    data, 0, NULL, &sw);
	if (!sectok_swOK(sw)) {
		/* error */
		printf("writing the key file 00.11: %s\n", sectok_get_sw(sw));
		return -1;
	}
	return 0;
}

/* download AUT0 key into 3f.00/00.11 */
int
jsetpass(int argc, char *argv[])
{
	int	sw;
	u_char data[MAX_BUF_SIZE];
	u_char AUT0[20];

	if (!aut0_vfyd && jaut(0, NULL) < 0)
		return -1;

	if (get_AUT0(argc, argv, "Enter new AUT0 passphrase: ", 1, AUT0) < 0)
		return -1;

	cyberflex_fill_key_block(data, 0, 1, AUT0);

#if 0
	/* add the suffix */
	data[KEY_BLOCK_SIZE] = 0;
	data[KEY_BLOCK_SIZE + 1] = 0;
#endif

#ifdef DEBUG
	for (i = 0; i < KEY_BLOCK_SIZE; i++)
		printf("%02x ", data[i]);
	printf("\n");
#endif

	/* select 3f.00 (root) */
	if (sectok_selectfile(fd, cla, root_fid, &sw) < 0)
		return -1;

	/* select 00.11 (key file) */
	if (sectok_selectfile(fd, cla, key_fid, &sw) < 0)
		return -1;

	/* all righty, now let's send it to the card! :) */
	sectok_apdu(fd, cla, 0xd6, 0, 0, KEY_BLOCK_SIZE, data, 0, NULL, &sw);
	if (!sectok_swOK(sw)) {
		/* error */
		printf("writing the key file 00.11: %s\n", sectok_get_sw(sw));
		return -1;
	}
	return 0;
}

/* download RSA private key into 3f.00/00.12 */
int
cyberflex_load_rsa(int fd, u_char *buf)
{
	int	sw, i, j, tmp;
	static u_char key_fid[] = {0x00, 0x12};
	static char *key_names[NUM_RSA_KEY_ELEMENTS] = {
		"p", "q", "1/p mod q", "d mod (p-1)", "d mod (q-1)"
	};
	u_char *key_elements[NUM_RSA_KEY_ELEMENTS];

	printf("ca_load_rsa_priv buf=%s\n", buf);

	printf("input 1024 bit RSA CRT key\n");
	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++) {
		printf("%s (%d bit == %d byte) : ", key_names[i],
		    RSA_BIT_LEN / 2, RSA_BIT_LEN / 2 / 8);
		key_elements[i] = (u_char *) malloc(RSA_BIT_LEN / 8);
		for (j = 0; j < RSA_BIT_LEN / 8 / 2; j++) {
			fscanf(cmdf, "%02x", &tmp);
			key_elements[i][j] = (u_char) tmp;
		}
	}

#ifdef DEBUG
	printf("print RSA CRT key\n");
	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++) {
		printf("%s : ", key_names[i]);
		for (j = 0; j < RSA_BIT_LEN / 8 / 2; j++) {
			printf("%02x ", key_elements[i][j]);
		}
	}
#endif

	if (!aut0_vfyd)
		jaut(0, NULL);

	cyberflex_load_rsa_priv(fd, cla, key_fid, NUM_RSA_KEY_ELEMENTS, RSA_BIT_LEN,
	    key_elements, &sw);

	if (!sectok_swOK(sw))
		printf("load_rsa_priv: %s\n", sectok_get_sw(sw));

	for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
		free(key_elements[i]);
	return 0;
}
#endif
@


1.29
log
@Switch the remaining users of libdes in src to libcrypto,
telnet portion partially from the latest heimdal.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cyberflex.c,v 1.28 2007/12/30 13:35:27 sobrado Exp $ */
@


1.28
log
@add missing arguments to synopsis; fix brackets; lowercase "usage:"

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cyberflex.c,v 1.27 2006/12/06 05:03:29 ray Exp $ */
d41 1
a41 1
#include <des.h>
a67 4
#ifdef __sun
#define des_set_key(key, schedule) des_key_sched(key, schedule)
#endif

d86 1
a86 1
static des_cblock app_key = {0x6A, 0x21, 0x36, 0xF5, 0xD8, 0x0C, 0x47, 0x83};
d611 2
a612 2
	des_cblock tmp;
	des_key_schedule schedule;
d722 1
a722 1
	des_set_key(&app_key, schedule);
d727 1
a727 1
		des_ecb_encrypt(&tmp, &tmp, schedule, DES_ENCRYPT);
@


1.27
log
@Don't access buf[strlen(buf) - 1] for zero-length strings.

OK jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cyberflex.c,v 1.26 2004/03/15 15:03:11 aaron Exp $ */
d941 1
a941 1
		printf("Usage: jk number_of_keys\n");
@


1.26
log
@Replace "if (foo == bar); else baz;" idiom with "if (foo != bar) baz;".  Much
less confusing. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cyberflex.c,v 1.25 2003/04/19 23:55:05 dhartmei Exp $ */
d483 1
d515 4
a518 1
	prin[strlen(prin) - 1] = '\0';
@


1.25
log
@string handling, partly from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cyberflex.c,v 1.24 2003/04/04 00:51:10 deraadt Exp $ */
d290 1
a290 2
				if (buf[21] == 0x0b);
				else
d299 1
a299 2
				if (buf[9] == 0x0b);
				else
@


1.24
log
@adapt to new sectok_fmt_fid API
@
text
@d1 1
a1 1
/*	$OpenBSD: cyberflex.c,v 1.23 2002/06/17 07:10:52 deraadt Exp $ */
d368 1
a368 1
sectok_fmt_aidname(char *aidname, int aidlen, u_char *aid)
d378 2
d386 2
a387 1
			sprintf(&aidname[i * 2], "%02x", aid[i]);
d446 2
a447 1
						    buf[23], &buf[24]);
@


1.23
log
@make this readable.  If I broke something, someone else gets to fix it now that we can read it
@
text
@d1 1
a1 1
/*	$OpenBSD: cyberflex.c,v 1.22 2002/03/20 22:30:58 rees Exp $ */
d421 1
a421 1
		sectok_fmt_fid(fname, &buf[4]);
d682 2
a683 2
	sectok_fmt_fid(progname, progID);
	sectok_fmt_fid(contname, contID);
d872 2
a873 2
	sectok_fmt_fid(progname, progID);
	sectok_fmt_fid(contname, contID);
@


1.22
log
@fix for palm again
get_AUT0: "-" means DFLTAUT0
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.9 2002/03/19 18:13:42 rees Exp $ */
d4 28
a31 28
copyright 1999, 2000
the regents of the university of michigan
all rights reserved

permission is granted to use, copy, create derivative works
and redistribute this software and such derivative works
for any purpose, so long as the name of the university of
michigan is not used in any advertising or publicity
pertaining to the use or distribution of this software
without specific, written prior authorization.  if the
above copyright notice or any other identification of the
university of michigan is included in any copy of any
portion of this software, then the disclaimer below must
also be included.

this software is provided as is, without representation
from the university of michigan as to its fitness for any
purpose, and without warranty by the university of
michigan of any kind, either express or implied, including
without limitation the implied warranties of
merchantability and fitness for a particular purpose. the
regents of the university of michigan shall not be liable
for any damages, including special, indirect, incidental, or
consequential damages, with respect to any claim arising
out of or in connection with the use of the software, even
if it has been or is hereafter advised of the possibility of
such damages.
*/
d48 1
a48 1
#else /* __linux */
d79 4
a82 4
static unsigned char key_fid[] = {0x00, 0x11};
static unsigned char DFLTATR[] = {0x81, 0x10, 0x06, 0x01};
static unsigned char DFLTAUT0[] = {0xad, 0x9f, 0x61, 0xfe, 0xfa, 0x20, 0xce, 0x63};
static unsigned char AUT0[20];
d84 1
a84 1
int aut0_vfyd;
d86 1
a86 1
static void print_acl(int isdir, unsigned char *acl);
d94 1
a94 1
get_AUT0(int ac, char *av[], char *prompt, int confirm, unsigned char *digest)
d97 1
a97 1
    memcpy(digest, DFLTAUT0, sizeof DFLTAUT0);
d99 43
a141 36
    int i, dflag = 0, xflag = 0;
    SHA1_CTX ctx;
    char *s, *s2;

    optind = optreset = 1;
    opterr = 0;

    while ((i = getopt(ac, av, "dk:x:")) != -1) {
	switch (i) {
	case 'd':
	    memcpy(digest, DFLTAUT0, sizeof DFLTAUT0);
	    dflag = 1;
	    break;
	case 'x':
	    if (sectok_parse_input(optarg, digest, 8) != 8) {
		printf("AUT0 must be length 8\n");
		return -1;
	    }
	    xflag = 1;
	    break;
	}
    }

    if (!dflag && !xflag) {
	SHA1Init(&ctx);
	/* "-" means DFLTAUT0 */
	s = getpass(prompt);
	if (!strcmp(s, "-"))
	    memcpy(digest, DFLTAUT0, sizeof DFLTAUT0);
	else {
	    if (confirm) {
		s2 = strdup(s);
		s = getpass("Re-enter passphrase: ");
		if (strcmp(s, s2)) {
		    printf("passphrase mismatch\n");
		    return -1;
a142 6
		bzero(s2, strlen(s2));
		free(s2);
	    }
	    SHA1Update(&ctx, s, strlen(s));
	    bzero(s, strlen(s));
	    SHA1Final(digest, &ctx);
a143 1
    }
d146 1
a146 1
    return 0;
d149 2
a150 1
int jlogin(int ac, char *av[])
d152 4
a155 1
    int i, keyno = 0, vflag = 0, sw;
d157 17
a173 2
    if (fd < 0 && reset(0, NULL) < 0)
	return -1;
d175 2
a176 28
    cla = cyberflex_inq_class(fd);
    if (cla < 0) {
	printf("can't determine Cyberflex application class\n");
	return -1;
    }

    optind = optreset = 1;

    while ((i = getopt(ac, av, "dk:vx:")) != -1) {
	switch (i) {
	case 'k':
	    keyno = atoi(optarg);
	    break;
	case 'v':
	    vflag = 1;
	    break;
	}
    }

    if (get_AUT0(ac, av, "Enter AUT0 passphrase: ", 0, AUT0) < 0)
	return -1;

    if (vflag) {
	printf("Class %02x\n", cla);
	for (i = 0; i < 8; i++)
	    printf("%02x ", AUT0[i]);
	printf("\n");
    }
d178 7
a184 1
    sectok_apdu(fd, cla, 0x2a, 0, keyno, 8, AUT0, 0, NULL, &sw);
d186 7
a192 7
    if (!sectok_swOK(sw)) {
	printf("AUT0 failed: %s\n", sectok_get_sw(sw));
	aut0_vfyd = 0;
	return -1;
    }
    aut0_vfyd = 1;
    return 0;
d195 2
a196 1
int jaut(int ac, char *av[])
d198 1
a198 1
    static char *jlav[] = {"login", "-d", NULL};
d200 1
a200 1
    return jlogin(2, jlav);
d203 2
a204 1
int jdefault(int ac, char *av[])
d206 2
a207 2
    unsigned char buf[8];
    int i, p1 = 4, sw;
d209 1
a209 1
    optind = optreset = 1;
d211 20
a230 20
    while ((i = getopt(ac, av, "d")) != -1) {
	switch (i) {
	case 'd':
	    p1 = 5;
	    break;
	}
    }

    if (fd < 0 && reset(0, NULL) < 0)
	return -1;
    if (!aut0_vfyd)
	jaut(0, NULL);

    sectok_apdu(fd, cla, 0x08, p1, 0, 0, buf, 0, NULL, &sw);
    if (!sectok_swOK(sw)) {
	/* error */
	sectok_print_sw(sw);
	return -1;
    }
    return 0;
d233 2
a234 1
int jatr(int ac, char *av[])
d236 16
a251 2
    unsigned char buf[64];
    int n = 0, sw;
d253 10
a262 24
    buf[n++] = 0x90;
    buf[n++] = 0x94;		/* TA1 */
    buf[n++] = 0x40;		/* TD1 */
    buf[n++] = 0x28;		/* TC2 (WWT=4sec) */
    if (ac > 1) {
	/* set historical bytes from command line */
	n += sectok_parse_input(av[1], &buf[n], 15);
    } else {
	/* no historical bytes given, use default */
	memcpy(&buf[n], DFLTATR, sizeof DFLTATR);
	n += sizeof DFLTATR;
    }
    buf[0] |= ((n - 2) & 0xf);

    if (fd < 0 && reset(0, NULL) < 0)
	return -1;

    sectok_apdu(fd, cla, 0xfa, 0, 0, n, buf, 0, NULL, &sw);
    if (!sectok_swOK(sw)) {
	/* error */
	sectok_print_sw(sw);
	return -1;
    }
    return 0;
d265 2
a266 1
int jdata(int ac, char *av[])
d268 2
a269 2
    unsigned char buf[32];
    int i, sw;
d271 2
a272 2
    if (fd < 0 && reset(0, NULL) < 0)
	return -1;
d274 31
a304 21
    cla = cyberflex_inq_class(fd);
    if (cla < 0) {
	printf("can't determine Cyberflex application class\n");
	return -1;
    }

    sectok_apdu(fd, cla, 0xca, 0, 1, 0, NULL, 0x16, buf, &sw);
    if (sectok_swOK(sw)) {
	printf("serno ");
	for (i = 0; i < 6; i++)
	    printf("%02x ", buf[i]);
	if (buf[20] == 0x13) {
	    /* these cards have a different format */
	    printf("scrambled sver %d.%02d ", buf[19], buf[20]);
	    if (buf[21] == 0x0c)
		printf("augmented ");
	    else if (buf[21] == 0x0b)
		;
	    else
		printf("unknown ");
	    printf("crypto %5.5s class %02x\n", &buf[14], cyberflex_inq_class(fd));
d306 4
a309 14
	    printf("batch %02x sver %d.%02d ", buf[6], buf[7], buf[8]);
	    if (buf[9] == 0x0c)
		printf("augmented ");
	    else if (buf[9] == 0x0b)
		;
	    else
		printf("unknown ");
	    printf("crypto %9.9s class %02x\n", &buf[10], buf[19]);
	}
    } else {
	/* error */
	sectok_print_sw(sw);
    }
    return 0;
a310 1

d314 4
a317 4
    "?",
    "applet",
    "app",
    "app/applet",
d321 4
a324 4
    "?",
    "created",
    "installed",
    "registered",
d328 5
a332 5
    "binary",
    "fixed rec",
    "variable rec",
    "cyclic",
    "program",
d336 1
a336 1
    "world", "CHV1", "CHV2", "AUT0", "AUT1", "AUT2", "AUT3", "AUT4"
d340 1
a340 1
    "r", "w", "x/a", "inval", "rehab", NULL, "dec", "inc"
d344 1
a344 1
    "l", "d", "a", NULL, NULL, "i", "manage", NULL
d348 1
a348 1
print_acl(int isdir, unsigned char *acl)
d350 2
a351 2
    int i, j;
    char *as;
d353 10
a362 8
    for (i = 0; i < 8; i++) {
	if (acl[i]) {
	    printf(" %s: ", principals[i]);
	    for (j = 0; j < 8; j++)
		if (acl[i] & (1 << j)) {
		    as = isdir ? d_rights[j] : f_rights[j];
		    if (as)
			printf("%s ", as);
a363 1
	    printf("\n");
a364 1
    }
d368 1
a368 1
sectok_fmt_aidname(char *aidname, int aidlen, unsigned char *aid)
d370 1
a370 1
    int i, istext = 1;
d372 14
a385 14
    for (i = 1; i < aidlen; i++)
	if (!myisprint(aid[i])) {
	    istext = 0;
	    break;
	}
    if (istext) {
	memcpy(aidname, aid, aidlen);
	aidname[aidlen] = '\0';
	if (aid[0] == 0xfc)
	    aidname[0] = '#';
    } else {
	for (i = 0; i < aidlen; i++)
	    sprintf(&aidname[i * 2], "%02x", aid[i]);
    }
d388 2
a389 1
int ls(int ac, char *av[])
d391 13
a403 12
    int i, p2, fid, lflag = 0, buflen, sw;
    int isdir, fsize;
    char ftype[32], fname[6], aidname[34];
    unsigned char buf[JDIRSIZE];

    optind = optreset = 1;

    while ((i = getopt(ac, av, "l")) != -1) {
	switch (i) {
	case 'l':
	    lflag = 1;
	    break;
a404 1
    }
d406 2
a407 2
    if (fd < 0 && reset(0, NULL) < 0)
	return -1;
d409 53
a461 4
    for (p2 = 0; ; p2++) {
	buflen = sectok_apdu(fd, cla, 0xa8, 0, p2, 0, NULL, JDIRSIZE, buf, &sw);
	if (!sectok_swOK(sw))
	    break;
d463 14
a476 26
	/* Don't show reserved fids */
	fid = sectok_mksw(buf[4], buf[5]);
	if (fid == 0x3f11 || fid == 0x3fff || fid == 0xffff)
	    continue;

	/* Format name */
	sectok_fmt_fid(fname, &buf[4]);

	/* Format size */
	fsize = (buf[2] << 8) | buf[3];

	/* Format file type */
	isdir = 0;
	aidname[0] = '\0';
	if (buf[6] == 1) {
	    /* root */
	    sprintf(ftype, "root");
	    isdir = 1;
	} else if (buf[6] == 2) {
	    /* DF */
	    if (buf[12] == 27) {
		/* application */
		sprintf(ftype, "%s %s", appstat[buf[10]], apptype[buf[9]]);
		if (buflen > 23 && buf[23]) {
		    aidname[0] = ' ';
		    sectok_fmt_aidname(&aidname[1], buf[23], &buf[24]);
a477 6
	    } else
		sprintf(ftype, "directory");
	    isdir = 1;
	} else if (buf[6] == 4) {
	    /* EF */
	    sprintf(ftype, "%s", filestruct[buf[13]]);
d480 12
a491 7
	if (!lflag)
	    printf("%-4s\n", fname);
	else
	    printf("%-4s %5d %s%s\n", fname, fsize, ftype, aidname);
    }
    return 0;
}
d493 17
a509 48
int acl(int ac, char *av[])
{
    int i, j, xflag = 0, isdir, prno, rt, sw;
    unsigned char fid[2], buf[256], acl[8];
    char *prin;

    optind = optreset = 1;

    while ((i = getopt(ac, av, "x")) != -1) {
	switch (i) {
	case 'x':
	    xflag = 1;
	    break;
	}
    }

    if (ac - optind < 1) {
	printf("usage: acl [ -x ] fid [ principal: r1 r2 ... ]\n");
	return -1;
    }

    /* Select the fid */
    sectok_parse_fname(av[optind++], fid);
    sectok_apdu(fd, cla, 0xa4, 0, 0, 2, fid, sizeof buf, buf, &sw);
    if (!sectok_swOK(sw)) {
	printf("Select: %s\n", sectok_get_sw(sw));
	return -1;
    }

    isdir = (buf[6] == 1 || buf[6] == 2);

    /* Get current acl */
    sectok_apdu(fd, cla, 0xfe, 0, 0, 0, NULL, 8, acl, &sw);
    if (!sectok_swOK(sw)) {
	printf("GetFileACL: %s\n", sectok_get_sw(sw));
	return -1;
    }

    if (ac - optind < 1) {
	/* No acl given; print acl and exit */
	if (xflag) {
	    for (i = 0; i < 8; i++)
		printf("%02x ", acl[i]);
	    printf("\n");
	} else
	    print_acl(isdir, acl);
	return 0;
    }
d511 2
a512 1
    prin = av[optind++];
d514 18
a531 2
    /* strip trailing ':' */
    prin[strlen(prin) - 1] = '\0';
d533 7
a539 26
    /* Find principal */
    for (prno = 0; prno < 8; prno++)
	if (!strcasecmp(prin, principals[prno]))
	    break;
    if (prno >= 8) {
	printf("unknown principal \"%s\"\n", prin);
	return -1;
    }

    /* Parse new rights */
    rt = 0;
    for (i = optind; i < optind + 8 && i < ac; i++) {
	for (j = 0; j < 8; j++) {
	    if ((d_rights[j] && !strcasecmp(av[i], d_rights[j]))
		|| (f_rights[j] && !strcasecmp(av[i], f_rights[j])))
		rt |= (1 << j);
	}
    }
    acl[prno] = rt;

    /* Set acl */
    sectok_apdu(fd, cla, 0xfc, 0, 0, 8, acl, 0, NULL, &sw);
    if (!sectok_swOK(sw)) {
	printf("ChangeFileACL: %s\n", sectok_get_sw(sw));
	return -1;
    }
d541 1
a541 3
    print_acl(isdir, acl);

    return 0;
d544 2
a545 1
int jcreate(int ac, char *av[])
d547 9
a555 2
    unsigned char fid[2];
    int sw, fsize;
d557 4
a560 17
    if (ac != 3) {
	printf("usage: create fid size\n");
	return -1;
    }

    sectok_parse_fname(av[1], fid);
    sscanf(av[2], "%d", &fsize);

    if (fd < 0 && reset(0, NULL) < 0)
	return -1;
    if (!aut0_vfyd)
	jaut(0, NULL);

    if (cyberflex_create_file(fd, cla, fid, fsize, 3, &sw) < 0) {
	printf("create_file: %s\n", sectok_get_sw(sw));
	return -1;
    }
d562 5
a566 1
    return 0;
d569 2
a570 1
int jdelete(int ac, char *av[])
d572 2
a573 2
    unsigned char fid[2];
    int sw;
d575 10
a584 16
    if (ac != 2) {
	printf("usage: delete fid\n");
	return -1;
    }

    sectok_parse_fname(av[1], fid);

    if (fd < 0 && reset(0, NULL) < 0)
	return -1;
    if (!aut0_vfyd)
	jaut(0, NULL);

    if (cyberflex_delete_file(fd, cla, fid, &sw) < 0) {
	printf("delete_file: %s\n", sectok_get_sw(sw));
	return -1;
    }
d586 5
a590 1
    return 0;
a591 1

d598 1
a598 1
unsigned char progID[2], contID[2];
d601 2
a602 1
int jload(int ac, char *av[])
d604 38
a641 162
    char *cp, *filename, progname[5], contname[5];
    unsigned char aid[16], app_data[MAX_APP_SIZE], data[MAX_BUF_SIZE];
    int i, j, vflag = 0, gotprog = 0, gotcont = 0, fd_app, size, aidlen = 0, sw;
    int cont_size = 1152, inst_size = 1024;
    des_cblock tmp;
    des_key_schedule schedule;
    static unsigned char acl[] = {0x81, 0, 0, 0xff, 0, 0, 0, 0};

    optind = optreset = 1;

    while ((i = getopt(ac, av, "p:c:s:i:a:v")) != -1) {
	switch (i) {
	case 'p':
	    sectok_parse_input(optarg, progID, 2);
	    gotprog = 1;
	    break;
	case 'c':
	    sectok_parse_input(optarg, contID, 2);
	    gotcont = 1;
	    break;
	case 's':
	    sscanf(optarg, "%d", &cont_size);
	    break;
	case 'i':
	    sscanf(optarg, "%d", &inst_size);
	    break;
	case 'a':
	    aidlen = sectok_parse_input(optarg, aid, sizeof aid);
	    break;
	case 'v':
	    vflag = 1;
	    break;
	default:
	    printf ("unknown option.  command aborted.\n");
	    return -1;
	}
    }

    if (ac - optind < 1) {
	printf("missing file name\n");
	return -1;
    }
    filename = av[optind++];

    /*
     * We prepend 0xfc to the aid to make it a "proprietary aid".
     * See 7816-5 sec 5.2.4.
     */
    if (aidlen <= 0) {
	/* No aid given, derive from file name */
	cp = strrchr(filename, '/');
	if (cp)
	    cp++;
	else
	    cp = filename;
	aid[0] = 0xfc;
	strncpy(&aid[1], cp, sizeof aid - 1);
	aidlen = (aid[15] == '\0') ? strlen(aid) : 16;
    } else if (aid[0] == '#')
	aid[0] = 0xfc;

    if (!gotprog) {
	/* No progID given, derive from aid */
	progID[0] = aid[1];
	progID[1] = 'p';
    }

    if (!gotcont) {
	/* No contID given, derive from aid */
	contID[0] = aid[1];
	contID[1] = 'c';
    }

    if (fd < 0 && reset(0, NULL) < 0)
	return -1;
    if (!aut0_vfyd)
	jaut(0, NULL);

    sectok_fmt_fid(progname, progID);
    sectok_fmt_fid(contname, contID);

    if (vflag) {
	printf ("applet file             \"%s\"\n", filename);
	printf ("program ID              %s\n", progname);
	printf ("container ID            %s\n", contname);
	printf ("instance container size %d\n", cont_size);
	printf ("instance data size      %d\n", inst_size);
	printf ("AID                     ");
	for (i = 0 ; i < aidlen ; i ++ )
	    printf ("%02x ", aid[i]);
	printf ("\n");
    }

    /* open the input file */
    fd_app = open (filename, O_RDONLY, NULL);
    if (fd_app == -1) {
	fprintf (stderr, "cannot open file \"%s\"\n", filename);
	return -1;
    }

    /* read the input file */
    size = read (fd_app, app_data, MAX_APP_SIZE);
    if (size <= 0) {
	fprintf (stderr, "error reading file %s\n", filename);
	return -1;
    }

    /* size must be able to be divided by BLOCK_SIZE */
    if (size % BLOCK_SIZE != 0) {
	fprintf (stderr, "file \"%s\" size %d not divisible by %d\n", filename, size, BLOCK_SIZE);
	return -1;
    }

    /* compute the signature of the applet */
    /* initialize the result buffer */
    memset(tmp, 0, BLOCK_SIZE);

    /* chain.  DES encrypt one block, XOR the cyphertext with the next block,
       ... continues until the end of the buffer */

    des_set_key (&app_key, schedule);

    for (i = 0; i < size/BLOCK_SIZE; i++) {
	for (j = 0; j < BLOCK_SIZE; j++)
	    tmp[j] = tmp[j] ^ app_data[i*BLOCK_SIZE + j];
	des_ecb_encrypt (&tmp, &tmp, schedule, DES_ENCRYPT);
    }

    if (vflag) {
	/* print out the signature */
	printf ("signature ");
	for (j = 0; j < BLOCK_SIZE; j++ )
	    printf ("%02x ", tmp[j]);
	printf ("\n");
    }

    /* select the default loader */
    sectok_apdu(fd, cla, 0xa4, 0x04, 0, 0, NULL, 0, NULL, &sw);
    if (!sectok_swOK(sw)) {
	/* error */
	printf("can't select default loader: %s\n", sectok_get_sw(sw));
	return -1;
    }

    /* select 3f.00 (root) */
    if (sectok_selectfile(fd, cla, root_fid, &sw) < 0)
	return -1;

    /* create program file */
    if (cyberflex_create_file_acl(fd, cla, progID, size, 3, acl, &sw) < 0) {
	/* error */
	printf("can't create %s: %s\n", progname, sectok_get_sw(sw));
	return -1;
    }

    /* update binary */
    for (i = 0; i < size; i += MAX_APDU_SIZE) {
	int send_size;

	/* compute the size to be sent */
	if (size - i > MAX_APDU_SIZE) send_size = MAX_APDU_SIZE;
	else send_size = size - i;
d643 5
a647 1
	sectok_apdu(fd, cla, 0xd6, i / 256, i % 256, send_size, app_data + i, 0, NULL, &sw);
d649 88
d738 7
a744 45
	    /* error */
	    printf("updating binary %s: %s\n", progname, sectok_get_sw(sw));
	    return -1;
	}
    }

    /* manage program .. validate */
    sectok_apdu(fd, cla, 0x0a, 01, 0, 0x08, tmp, 0, NULL, &sw);

    if (!sectok_swOK(sw)) {
	/* error */
	printf("validating applet in %s: %s\n", progname, sectok_get_sw(sw));
	return -1;
    }

    /* select the default loader */
    sectok_apdu(fd, cla, 0xa4, 0x04, 0, 0, NULL, 0, NULL, &sw);
    if (!sectok_swOK(sw)) {
	/* error */
	printf("selecting default loader: %s\n", sectok_get_sw(sw));
	return -1;
    }

    /* execute method -- call the install() method in the cardlet.
       cardlet type 01 (applet, not application) */

    data[0] = 0x01;		/* cardlet type = 1 (applet, not application) */
    data[1] = progID[0];	/* FID, upper */
    data[2] = progID[1];	/* FID, lower */
    data[3] = cont_size >> 8;	/* instance container size 0x0800 (1152) byte, upper */
    data[4] = cont_size & 0xff;	/* instance container size 0x0800 (1152) byte, lower */
    data[5] = contID[0];	/* container ID (7778), upper */
    data[6] = contID[1];	/* container ID (7778), lower */
    data[7] = inst_size >> 8;	/* instance size 0x0400 (1024) byte, upper */
    data[8] = inst_size & 0xff;	/* instance size 0x0400 (1024) byte, lower */
    data[9] = 0x00;		/* AID length 0x0005, upper */
    data[10] = aidlen;		/* AID length 0x0005, lower */
    memcpy(&data[11], aid, aidlen);

    sectok_apdu(fd, cla, 0x0c, 0x13, 0, 11 + aidlen, data, 0, NULL, &sw);
    if (!sectok_swOK(sw)) {
	/* error */
	printf("executing install() method in applet %s: %s\n", progname, sectok_get_sw(sw));
	return -1;
    }
d746 72
a817 2
    /* That's it! :) */
    return 0;
d821 2
a822 1
int junload(int ac, char *av[])
d824 2
a825 2
    char progname[5], contname[5];
    int i, vflag = 0, gotprog = 0, gotcont = 0, sw;
d827 1
a827 1
    optind = optreset = 1;
d829 17
a845 16
    while ((i = getopt(ac, av, "p:c:v")) != -1) {
	switch (i) {
	case 'p':
	    sectok_parse_input(optarg, progID, 2);
	    gotprog = 1;
	    break;
	case 'c':
	    sectok_parse_input(optarg, contID, 2);
	    gotcont = 1;
	    break;
	case 'v':
	    vflag = 1;
	    break;
	default:
	    printf ("unknown option.  command aborted.\n");
	    return -1;
a846 1
    }
d848 12
a859 6
    if (ac - optind >= 1) {
	/* Derive progID and contID from filename */
	if (!gotprog) {
	    progID[0] = av[optind][0];
	    progID[1] = 'p';
	    gotprog = 1;
d861 10
a870 31
	if (!gotcont) {
	    contID[0] = av[optind][0];
	    contID[1] = 'c';
	    gotcont = 1;
	}
    }

    /* Use old defaults */
    if (!gotprog)
	memcpy(progID, "ww", 2);
    if (!gotcont)
	memcpy(contID, "wx", 2);

    if (fd < 0 && reset(0, NULL) < 0)
	return -1;
    if (!aut0_vfyd)
	jaut(0, NULL);

    sectok_fmt_fid(progname, progID);
    sectok_fmt_fid(contname, contID);

    if (vflag) {
	printf ("program ID              %s\n", progname);
	printf ("container ID            %s\n", contname);
    }

    /* select 3f.00 (root) */
    if (sectok_selectfile(fd, cla, root_fid, &sw) < 0) {
	printf("can't select root: %s\n", sectok_get_sw(sw));
	return -1;
    }
d872 2
a873 2
    /* select program file */
    if (sectok_selectfile(fd, cla, progID, &sw) >= 0) {
d875 8
a882 5
	/* manage program -- reset */
	sectok_apdu(fd, cla, 0x0a, 02, 0, 0, NULL, 0, NULL, &sw);
	if (!sectok_swOK(sw)) {
	    /* error */
	    printf("resetting applet: %s\n", sectok_get_sw(sw));
d884 2
d887 12
a898 5
	/* delete program file */
	if (cyberflex_delete_file(fd, cla, progID, &sw) < 0)
	    printf("delete_file %s: %s\n", progname, sectok_get_sw(sw));
    } else if (vflag)
	printf ("no program file... proceed to delete data container\n");
d900 3
a902 3
    /* delete data container */
    if (cyberflex_delete_file(fd, cla, contID, &sw) < 0)
	printf("delete_file %s: %s\n", contname, sectok_get_sw(sw));
d904 1
a904 1
    return 0;
d912 2
a913 1
int cyberflex_load_key (int fd, unsigned char *buf)
d915 4
a918 4
    int sw, argc = 0, i, j, tmp;
    unsigned char *token;
    unsigned char data[MAX_BUF_SIZE];
    unsigned char key[BLOCK_SIZE];
d921 8
a928 8
    /* select the default loader */
    rv = scwrite(fd, cla, 0xa4, 0x04, 0, 0x00, NULL, &r1, &r2);
    if (r1 != 0x90 && r1 != 0x61) {
	// error
	    printf ("selecting the default loader: ");
	print_r1r2 (r1, r2);
	return -1;
    }
d931 47
a977 68
    printf ("ca_load_key buf=%s\n", buf);
    token = strtok (buf, DELIMITER);
    token = strtok (NULL, DELIMITER);
    if (token == NULL) {
	printf ("Usage: jk number_of_keys\n");
	return -1;
    }
    argc = atoi (token);

    if (argc > 2) {
	printf ("current Cyberflex Access cannot download more than 2 keys to the key file.  Sorry. :(\n");
	return -1;
    }

    if (argc < 0) {
	printf ("you want to down load %d keys??\n", argc);
	return -1;
    }

    if (!aut0_vfyd)
	jaut(0, NULL);

    /* Now let's do it. :) */

    /* add the AUT0 */
    cyberflex_fill_key_block (data, 0, 1, AUT0);

    /* add the applet sign key */
    cyberflex_fill_key_block (data+KEY_BLOCK_SIZE, 5, 0, app_key);

    /* then add user defined keys */
    for ( i = 0 ; i < argc ; i++ ) {
	printf ("key %d : ", i);
	for ( j = 0 ; j < BLOCK_SIZE ; j++ ) {
	    fscanf (cmdf, "%02x", &tmp);
	    key[j] = (unsigned char)tmp;
	}

	cyberflex_fill_key_block (data + 28 + i*KEY_BLOCK_SIZE, 6 + i, 0, key);
    }

    /* add the suffix */
    data[28 + argc*KEY_BLOCK_SIZE] = 0;
    data[28 + argc*KEY_BLOCK_SIZE + 1] = 0;

    for ( i = 0 ; i < KEY_BLOCK_SIZE * (argc + 2) + 2; i++ )
	printf ("%02x ", data[i]);
    printf ("\n");

    /* select 3f.00 (root) */
    if (sectok_selectfile(fd, cla, root_fid, &sw) < 0) {
	printf("select root: %s\n", sectok_get_sw(sw));
	return -1;
    }

    /* select 00.11 (key file) */
    if (sectok_selectfile(fd, cla, key_fid, &sw) < 0) {
	printf("select key file: %s\n", sectok_get_sw(sw));
	return -1;
    }

    /* all righty, now let's send it to the card! :) */
    sectok_apdu(fd, cla, 0xd6, 0, 0, KEY_BLOCK_SIZE * (argc + 2) + 2, data, 0, NULL, &sw);
    if (!sectok_swOK(sw)) {
	/* error */
	printf("writing the key file 00.11: %s\n", sectok_get_sw(sw));
	return -1;
    }
d979 19
a997 1
    return 0;
d1001 2
a1002 1
int jsetpass(int ac, char *av[])
d1004 3
a1006 3
    int sw;
    unsigned char data[MAX_BUF_SIZE];
    unsigned char AUT0[20];
d1008 2
a1009 2
    if (!aut0_vfyd && jaut(0, NULL) < 0)
	return -1;
d1011 2
a1012 2
    if (get_AUT0(ac, av, "Enter new AUT0 passphrase: ", 1, AUT0) < 0)
	return -1;
d1014 1
a1014 1
    cyberflex_fill_key_block (data, 0, 1, AUT0);
d1017 3
a1019 3
    /* add the suffix */
    data[KEY_BLOCK_SIZE] = 0;
    data[KEY_BLOCK_SIZE + 1] = 0;
d1023 3
a1025 3
    for (i = 0; i < KEY_BLOCK_SIZE; i++)
	printf ("%02x ", data[i]);
    printf ("\n");
d1028 7
a1034 15
    /* select 3f.00 (root) */
    if (sectok_selectfile(fd, cla, root_fid, &sw) < 0)
	return -1;

    /* select 00.11 (key file) */
    if (sectok_selectfile(fd, cla, key_fid, &sw) < 0)
	return -1;

    /* all righty, now let's send it to the card! :) */
    sectok_apdu(fd, cla, 0xd6, 0, 0, KEY_BLOCK_SIZE, data, 0, NULL, &sw);
    if (!sectok_swOK(sw)) {
	/* error */
	printf("writing the key file 00.11: %s\n", sectok_get_sw(sw));
	return -1;
    }
d1036 8
a1043 1
    return 0;
d1047 2
a1048 1
int cyberflex_load_rsa(int fd, unsigned char *buf)
d1050 18
a1067 16
    int sw, i, j, tmp;
    static unsigned char key_fid[] = {0x00, 0x12};
    static char *key_names[NUM_RSA_KEY_ELEMENTS]= {"p", "q", "1/p mod q",
						       "d mod (p-1)", "d mod (q-1)"};
    unsigned char *key_elements[NUM_RSA_KEY_ELEMENTS];

    printf ("ca_load_rsa_priv buf=%s\n", buf);

    printf ("input 1024 bit RSA CRT key\n");
    for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++) {
	printf ("%s (%d bit == %d byte) : ", key_names[i],
		RSA_BIT_LEN/2, RSA_BIT_LEN/2/8);
	key_elements[i] = (unsigned char *) malloc(RSA_BIT_LEN/8);
	for ( j = 0 ; j < RSA_BIT_LEN/8/2 ; j++ ) {
	    fscanf (cmdf, "%02x", &tmp);
	    key_elements[i][j] = (unsigned char)tmp;
a1068 1
    }
d1071 6
a1076 5
    printf ("print RSA CRT key\n");
    for (i = 0 ; i < NUM_RSA_KEY_ELEMENTS ; i ++ ) {
	printf ("%s : ", key_names[i]);
	for ( j = 0 ; j < RSA_BIT_LEN/8/2 ; j++ ) {
	    printf ("%02x ", key_elements[i][j]);
a1077 1
    }
d1080 2
a1081 2
    if (!aut0_vfyd)
	jaut(0, NULL);
d1083 2
a1084 2
    cyberflex_load_rsa_priv(fd, cla, key_fid, NUM_RSA_KEY_ELEMENTS, RSA_BIT_LEN,
				 key_elements, &sw);
d1086 2
a1087 2
    if (!sectok_swOK(sw))
	printf("load_rsa_priv: %s\n", sectok_get_sw(sw));
d1089 3
a1091 3
    for (i = 0; i < NUM_RSA_KEY_ELEMENTS; i++)
	free(key_elements[i]);
    return 0;
@


1.21
log
@0000 is not a reserved fid
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.20 2001/08/24 17:27:57 rees Exp $ */
d124 1
d126 12
a137 6
	if (confirm) {
	    s2 = strdup(s);
	    s = getpass("Re-enter passphrase: ");
	    if (strcmp(s, s2)) {
		printf("passphrase mismatch\n");
		return -1;
d139 3
a141 2
	    bzero(s2, strlen(s2));
	    free(s2);
a142 3
	SHA1Update(&ctx, s, strlen(s));
	bzero(s, strlen(s));
	SHA1Final(digest, &ctx);
@


1.20
log
@junload: Derive progID and contID from filename
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.7 2001/08/24 17:23:08 rees Exp $ */
d383 1
a383 1
    int i, p2, f0, f1, lflag = 0, buflen, sw;
d405 4
a408 3
	f0 = buf[4];
	f1 = buf[5];
	if (f0 == 0xff || f0 + f1 == 0)
@


1.19
log
@don't include openssl/des.h
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.6 2001/08/15 20:26:22 rees Exp $ */
d816 1
a816 7
    int i, vflag = 0, sw;

    /* Use old defaults */
    if (progID[0] == 0)
	memcpy(progID, "ww", 2);
    if (contID[0] == 0)
	memcpy(contID, "wx", 2);
d824 1
d828 1
d838 20
@


1.18
log
@Mods for PalmOS
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.5 2001/08/02 16:52:21 rees Exp $ */
a40 1
#include <openssl/des.h>
@


1.17
log
@linux mods
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.2 2001/07/29 21:42:22 rees Exp $ */
d33 1
d52 13
d87 3
d92 1
a92 2

static void print_acl(int isdir, unsigned char *acl);
d97 3
d110 1
a110 1
	    memmove(digest, DFLTAUT0, sizeof DFLTAUT0);
d140 1
d242 1
a242 1
	memmove(&buf[n], DFLTATR, sizeof DFLTATR);
d372 1
a372 1
	memmove(aidname, aid, aidlen);
d594 1
d800 1
a800 1
    memmove(&data[11], aid, aidlen);
d812 1
d821 1
a821 1
	memmove(progID, "ww", 2);
d823 1
a823 1
	memmove(contID, "wx", 2);
d886 1
d1072 1
@


1.16
log
@fix acl on program files
add acl -x option
fix help command
add SCPORT ev
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.15 2001/07/26 22:12:56 rees Exp $ */
d40 2
d43 5
a47 1
#include <openssl/des.h>
d49 1
a49 1
#include <des.h>
a50 1
#include <sha1.h>
@


1.15
log
@new sectok_fmt_fid
slap an acl on the program file in jload
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.14 2001/07/26 21:05:15 rees Exp $ */
d426 1
a426 1
    int i, j, isdir, prno, rt, sw;
d428 1
d430 12
a441 2
    if (ac < 2) {
	printf("usage: acl fid [ principal: r1 r2 ... ]\n");
d446 1
a446 1
    sectok_parse_fname(av[1], fid);
d462 1
a462 1
    if (ac < 3) {
d464 6
a469 1
	print_acl(isdir, acl);
d473 2
d476 1
a476 1
    av[2][strlen(av[2]) - 1] = '\0';
d480 1
a480 1
	if (!strcasecmp(av[2], principals[prno]))
d483 1
a483 1
	printf("unknown principal \"%s\"\n", av[2]);
d489 2
a490 2
    for (i = 3; i < 11 && i < ac; i++) {
	for (j = 0; j < 8; j++)
d494 1
d577 1
a577 1
    static unsigned char acl[] = {0x5, 0, 0, 0xff, 0, 0, 0, 0};
@


1.14
log
@require confirmation when changing aut0 passphrase
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.13 2001/07/26 20:00:16 rees Exp $ */
d387 1
a387 1
	sectok_fmt_fid(fname, f0, f1);
d558 1
d630 2
a631 2
    sectok_fmt_fid(progname, progID[0], progID[1]);
    sectok_fmt_fid(contname, contID[0], contID[1]);
d701 1
a701 1
    if (cyberflex_create_file(fd, cla, progID, size, 3, &sw) < 0) {
d803 2
a804 2
    sectok_fmt_fid(progname, progID[0], progID[1]);
    sectok_fmt_fid(contname, contID[0], contID[1]);
@


1.13
log
@Use registration category 'F' for textual aids (see 7816-5 sec 5.2.4)
Use better defaults for progID and contID
work on the man page
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.12 2001/07/26 16:10:01 rees Exp $ */
d74 1
a74 1
get_AUT0(int ac, char *av[], char *prompt, unsigned char *digest)
d78 1
a78 1
    char *s;
d102 10
d146 1
a146 1
    if (get_AUT0(ac, av, "Enter AUT0 passphrase: ", AUT0) < 0)
d943 1
a943 1
    if (get_AUT0(ac, av, "Enter new AUT0 passphrase: ", AUT0) < 0)
@


1.12
log
@fid command now selects aids too
remove jselect
port numbers are now 0-based
print friendly aid names
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.11 2001/07/20 15:52:54 rees Exp $ */
d331 1
a331 1
    for (i = 0; i < aidlen; i++)
d339 2
d538 1
a538 12
unsigned char *app_name;
unsigned char progID[2], contID[2], aid[MAX_BUF_SIZE];
int cont_size, inst_size;
int aid_len;

void load_default_options()
{
    memmove(progID, "ww", 2);
    memmove(contID, "wx", 2);
    memset(aid, 'w', sizeof aid);
    aid_len = 5;
}
d542 4
a545 4
    char progname[5], contname[5];
    unsigned char app_data[MAX_APP_SIZE],
    data[MAX_BUF_SIZE];
    int i, j, vflag = 0, fd_app, size, sw;
a548 4
    load_default_options();
    cont_size = 1152;
    inst_size = 1024;

d555 1
d559 1
d568 1
a568 1
	    aid_len = sectok_parse_input(optarg, aid, sizeof aid);
d583 30
a612 1
    app_name = av[optind++];
d623 1
a623 1
	printf ("applet file             \"%s\"\n", app_name);
d629 2
a630 2
	for (i = 0 ; i < aid_len ; i ++ )
	    printf ("%02x", aid[i]);
d635 1
a635 1
    fd_app = open (app_name, O_RDONLY, NULL);
d637 1
a637 1
	fprintf (stderr, "cannot open file \"%s\"\n", app_name);
d643 2
a644 6
    if (size == 0) {
	fprintf (stderr, "file %s size 0??\n", app_name);
	return -1;
    }
    if (size == -1) {
	fprintf (stderr, "error reading file %s\n", app_name);
d650 1
a650 1
	fprintf (stderr, "file \"%s\" size %d not divisible by %d\n", app_name, size, BLOCK_SIZE);
d673 1
a673 1
	    printf ("%02x", tmp[j]);
d731 1
a731 7
       cardlet type 01 (applet, not application)
       program ID (7777)
       instance container size (0800 (1152))
       instance container ID (7778)
       instance data size (0400 (1024))
       AID length (0005 (5 byte))
       AID (7777777777) */
d736 2
a737 2
    data[3] = cont_size / 256;	/* instance container size 0x0800 (1152) byte, upper */
    data[4] = cont_size % 256;	/* instance container size 0x0800 (1152) byte, lower */
d740 2
a741 2
    data[7] = inst_size / 256;	/* instance size 0x0400 (1024) byte, upper */
    data[8] = inst_size % 256;	/* instance size 0x0400 (1024) byte, lower */
d743 2
a744 3
    data[10] = aid_len;		/* AID length 0x0005, lower */
    for (i = 0; i < aid_len; i++)
	data[i + 11] = aid[i];
d746 1
a746 1
    sectok_apdu(fd, cla, 0x0c, 0x13, 0, 11 + aid_len, data, 0, NULL, &sw);
d762 5
a766 1
    load_default_options();
@


1.11
log
@add -v option to fid command
parse_atr -> sectok_parse_atr
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.10 2001/07/19 21:24:27 rees Exp $ */
d59 2
d202 1
a202 1
    if (ac > optind) {
d232 6
d326 19
d347 1
a347 1
    int i, p2, f0, f1, lflag = 0, sw;
d349 1
a349 1
    char ftype[32], fname[6];
d366 1
a366 1
	sectok_apdu(fd, cla, 0xa8, 0, p2, 0, NULL, JDIRSIZE, buf, &sw);
d382 1
d389 2
a390 1
	    if (buf[12] == 27)
d392 5
a396 1
	    else
d407 1
a407 1
	    printf("%-4s %5d %s\n", fname, fsize, ftype);
a544 2
    cont_size = 1152;
    inst_size = 1024;
d559 2
a813 67

    return 0;
}

int jselect(int ac, char *av[])
{
    int i, vflag = 0, sw;

    load_default_options();

    optind = optreset = 1;

    while ((i = getopt(ac, av, "dp:c:s:i:a:v")) != -1) {
	switch (i) {
	case 'd':
	    aid_len = 0;
	    break;
	case 'p':
	    sectok_parse_input(optarg, progID, 2);
	    break;
	case 'c':
	    sectok_parse_input(optarg, contID, 2);
	    break;
	case 's':
	    sscanf(optarg, "%d", &cont_size);
	    break;
	case 'i':
	    sscanf(optarg, "%d", &inst_size);
	    break;
	case 'a':
	    aid_len = sectok_parse_input(optarg, aid, sizeof aid);
	    break;
	case 'v':
	    vflag = 1;
	    break;
	default:
	    printf ("unknown option.  command aborted.\n");
	    return -1;
	}
    }

    if (fd < 0 && reset(0, NULL) < 0)
	return -1;

    if (vflag && aid_len) {
	printf ("select applet\n");
	printf ("AID                     ");
	for (i = 0 ; i < aid_len ; i ++ )
	    printf ("%02x", (int) aid[i]);
	printf ("\n");
    }

    sectok_apdu(fd, cla, 0xa4, 0x04, 0, aid_len, aid, 0, NULL, &sw);
    if (!sectok_swOK(sw)) {
	/* even with F0 card, select applet APDU (00 a4 04)
	   only accepts class byte 00 (not f0) */
	sectok_apdu(fd, 0, 0xa4, 0x04, 0, aid_len, aid, 0, NULL, &sw);
    }
    if (!sectok_swOK(sw)) {
	/* error */
	printf ("selecting the cardlet: ");
	for (i = 0 ; i < aid_len ; i ++ )
	    printf ("%02x", aid[i]);
	printf("\n");
	sectok_print_sw(sw);
	return -1;
    }
@


1.10
log
@add read -x option
add login -k option
add jload -v option
replace jdeselect with jselect -d
parse new Cyberflex data format in jdata command
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.9 2001/07/17 21:04:14 rees Exp $ */
a46 1
#include <sc7816.h>
d88 1
a88 1
	    if (parse_input(optarg, digest, 8) != 8) {
a195 3
    if (fd < 0 && reset(0, NULL) < 0)
	return -1;

d202 1
a202 1
	n += parse_input(av[1], &buf[n], 15);
d209 4
d534 1
a534 1
	    parse_input(optarg, progID, 2);
d537 1
a537 1
	    parse_input(optarg, contID, 2);
d546 1
a546 1
	    aid_len = parse_input(optarg, aid, sizeof aid);
d729 1
a729 1
	    parse_input(optarg, progID, 2);
d732 1
a732 1
	    parse_input(optarg, contID, 2);
d799 1
a799 1
	    parse_input(optarg, progID, 2);
d802 1
a802 1
	    parse_input(optarg, contID, 2);
d811 1
a811 1
	    aid_len = parse_input(optarg, aid, sizeof aid);
@


1.9
log
@now you can display and set acls
use sectok_apdu for "apdu" command
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.8 2001/07/17 17:58:24 rees Exp $ */
d82 1
a82 1
    while ((i = getopt(ac, av, "dx:")) != -1) {
d111 1
a111 1
    int i, vflag = 0, sw;
d124 1
a124 1
    while ((i = getopt(ac, av, "dvx:")) != -1) {
d126 3
d145 1
a145 1
    sectok_apdu(fd, cla, 0x2a, 0, 0, 8, AUT0, 0, NULL, &sw);
d235 20
a254 8
	printf("batch %02x sver %d.%02d ", buf[6], buf[7], buf[8]);
	if (buf[9] == 0x0c)
	    printf("augmented ");
	else if (buf[9] == 0x0b)
	    ;
	else
	    printf("unknown ");
	printf("crypto %9.9s class %02x\n", &buf[10], buf[19]);
d508 1
a508 1
int analyze_load_options(int ac, char *av[])
d510 2
a511 6
    int i, rv;

    progID[0] = 0x77;
    progID[1] = 0x77;
    contID[0] = 0x77;
    contID[1] = 0x78;
d514 1
d516 1
d518 8
a525 2
    for (i = 0 ; i < 16 ; i ++)
	aid[i] = 0x77;
d527 1
a527 2
    /* applet file name */
    app_name = av[ac - 1];
d531 2
a532 6
    /* switch on options */
    while (1) {
	rv = getopt (ac, av, "p:c:s:i:a:");
	if (rv == -1) break;
	/*printf ("rv=%c, optarg=%s\n", rv, optarg);*/
	switch (rv) {
d547 3
a549 1
	    /*printf ("aid_len = %d\n", aid_len);*/
d557 2
a558 13
    return 0;
}

int jload(int ac, char *av[])
{
    char progname[5], contname[5];
    unsigned char app_data[MAX_APP_SIZE],
    data[MAX_BUF_SIZE];
    int i, j, fd_app, size, sw;
    des_cblock tmp;
    des_key_schedule schedule;

    if (analyze_load_options(ac, av) < 0)
d560 2
d571 11
a581 9
    printf ("applet file             \"%s\"\n", app_name);
    printf ("program ID              %s\n", progname);
    printf ("container ID            %s\n", contname);
    printf ("instance container size %d\n", cont_size);
    printf ("instance data size      %d\n", inst_size);
    printf ("AID                     ");
    for (i = 0 ; i < aid_len ; i ++ )
	printf ("%02x", (unsigned char)aid[i]);
    printf ("\n");
a600 2
    /*printf ("file size %d\n", size);*/

d603 1
a603 2
	fprintf (stderr, "file (%s) size cannot be divided by BLOCK_SIZE.\n",
		 app_name);
d609 1
a609 3
    for (j = 0; j < BLOCK_SIZE; j++ ) {
	tmp[j] = 0;
    }
d617 1
a617 1
	for (j = 0; j < BLOCK_SIZE; j++ ){
a618 1
	}
d622 6
a627 4
    /* print out the signature */
    printf ("signature ");
    for (j = 0; j < BLOCK_SIZE; j++ ) {
	printf ("%02x", tmp[j]);
a628 1
    printf ("\n");
d703 2
a704 2
    for (i = 0; i < aid_len; i++) data[i + 11] = (unsigned int)aid[i];
    /* AID (7777777777) */
d720 5
a724 1
    int sw;
d726 16
a741 2
    if (analyze_load_options(ac, av) < 0)
	return -1;
d751 4
a754 2
    printf ("program ID              %s\n", progname);
    printf ("container ID            %s\n", contname);
d775 1
a775 1
    } else
d787 3
a789 2
    int i, sw;
    unsigned char data[MAX_BUF_SIZE];
d793 28
a820 2
    if (analyze_load_options(ac, av) < 0)
	return -1;
d825 7
a831 11
    printf ("select applet\n");
    printf ("AID                     ");
    for (i = 0 ; i < aid_len ; i ++ )
	printf ("%02x", (unsigned char)aid[i]);
    printf ("\n");

    /* select the cardlet (7777777777) */
    for (i = 0; i < aid_len; i++) data[i] = (unsigned char)aid[i];
    /* quick hack in select_applet()
       even with F0 card, select applet APDU (00 a4 04)
       only accepts class byte 00 (not f0) */
d833 6
a838 1
    sectok_apdu(fd, cla, 0xa4, 0x04, 0, aid_len, data, 0, NULL, &sw);
d843 2
a844 2
	    printf ("%02x", (unsigned char)aid[i]);
	printf ("\n");
a845 17
	return -1;
    }

    return 0;
}

int jdeselect(int ac, char *av[])
{
    int sw;

    if (fd < 0 && reset(0, NULL) < 0)
	return -1;

    sectok_apdu(fd, cla, 0xa4, 0x04, 0, 0, NULL, 0, NULL, &sw);
    if (!sectok_swOK(sw)) {
	/* error */
	printf("selecting default loader: %s\n", sectok_get_sw(sw));
@


1.8
log
@add -l and -a flags to "ls"
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.7 2001/07/17 17:10:44 rees Exp $ */
d70 2
d283 20
d305 1
a305 1
    int i, j, p2, f0, f1, aflag = 0, lflag = 0, sw;
d307 1
a307 1
    char ftype[32], fname[6], *as;
d312 1
a312 1
    while ((i = getopt(ac, av, "la")) != -1) {
a316 3
	case 'a':
	    aflag = 1;
	    break;
d324 1
a324 2
	if (sectok_apdu(fd, cla, 0xa8, 0, p2, 0, NULL, JDIRSIZE, buf, &sw) < 0)
	    break;
d348 1
a348 1
	    else {
d350 1
a350 2
		isdir = 1;
	    }
d360 23
d384 40
a423 20
	if (aflag) {
	    /* Format acl */
	    if (sectok_apdu(fd, cla, 0xfe, 0, 0, 0, NULL, 8, buf, &sw) < 0)
		printf(" [GetFileACL: %s]", sectok_get_sw(sw));
	    else {
		for (i = 0; i < 8; i++) {
		    if (buf[i]) {
			printf(" %s: ", principals[i]);
			for (j = 0; j < 8; j++)
			    if (buf[i] & (1 << j)) {
				as = isdir ? d_rights[j] : f_rights[j];
				if (as)
				    printf("%s, ", as);
			    }
			printf("\n");
		    }
		}
	    }
	    printf("\n");
	}
d425 3
d549 1
a549 1
    int i, j, fd_app, size, rv, sw;
d627 1
a627 1
    rv = sectok_apdu(fd, cla, 0xa4, 0x04, 0, 0, NULL, 0, NULL, &sw);
d653 1
a653 1
	rv = sectok_apdu(fd, cla, 0xd6, i / 256, i % 256, send_size, app_data + i, 0, NULL, &sw);
d663 1
a663 1
    rv = sectok_apdu(fd, cla, 0x0a, 01, 0, 0x08, tmp, 0, NULL, &sw);
d672 1
a672 1
    rv = sectok_apdu(fd, cla, 0xa4, 0x04, 0, 0, NULL, 0, NULL, &sw);
d702 1
a702 1
    rv = sectok_apdu(fd, cla, 0x0c, 0x13, 0, 11 + aid_len, data, 0, NULL, &sw);
d716 1
a716 1
    int sw, rv;
d742 1
a742 1
	rv = sectok_apdu(fd, cla, 0x0a, 02, 0, 0, NULL, 0, NULL, &sw);
d763 1
a763 1
    int i, sw, rv;
d786 1
a786 1
    rv = sectok_apdu(fd, cla, 0xa4, 0x04, 0, aid_len, data, 0, NULL, &sw);
d790 1
a790 1
	for (i = 0 ; i < aid_len ; i ++ ) {
a791 1
	}
d823 1
a823 1
    int sw, rv, argc = 0, i, j, tmp;
d901 1
a901 1
    rv = sectok_apdu(fd, cla, 0xd6, 0, 0, KEY_BLOCK_SIZE * (argc + 2) + 2, data, 0, NULL, &sw);
d914 1
a914 1
    int sw, rv;
d947 1
a947 1
    rv = sectok_apdu(fd, cla, 0xd6, 0, 0, KEY_BLOCK_SIZE, data, 0, NULL, &sw);
d960 1
a960 1
    int rv, sw, i, j, tmp;
d992 1
a992 1
    rv = cyberflex_load_rsa_priv(fd, cla, key_fid, NUM_RSA_KEY_ELEMENTS, RSA_BIT_LEN,
d995 1
a995 1
    if (rv < 0)
d1000 1
a1000 1
    return rv;
@


1.7
log
@more better error checking
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.6 2001/07/17 15:16:46 rees Exp $ */
a69 22
char *apptype[] = {
    "?",
    "applet",
    "app",
    "app/applet",
};

char *appstat[] = {
    "?",
    "created",
    "installed",
    "registered",
};

char *filestruct[] = {
    "binary",
    "fixed rec",
    "variable rec",
    "cyclic",
    "program",
};

d247 34
d283 3
a285 2
    int p2, f0, f1, sw;
    char ftype[32], fname[6];
d288 13
d313 2
d316 7
a322 1
	if (buf[6] == 1)
d325 2
a326 1
	else if (buf[6] == 2) {
d330 1
a330 1
	    else
d332 3
a334 1
	} else if (buf[6] == 4)
d337 27
a363 1
	printf("%4s %5d %s\n", fname, (buf[2] << 8) | buf[3], ftype);
@


1.6
log
@change jaut back to previous behavior; add new "login" command
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.5 2001/07/16 23:09:36 rees Exp $ */
d63 1
a131 1
    unsigned char AUT0[20];
d133 8
a140 2
    if (fd < 0)
	reset(0, NULL);
a154 2
    cla = cyberflex_inq_class(fd);

d195 2
a196 2
    if (fd < 0)
	reset(0, NULL);
d214 2
a215 2
    if (fd < 0)
	reset(0, NULL);
d244 2
a245 2
    if (fd < 0)
	reset(0, NULL);
d275 2
a276 2
    if (fd < 0)
	reset(0, NULL);
d318 2
a319 2
    if (fd < 0)
	reset(0, NULL);
d343 2
a344 2
    if (fd < 0)
	reset(0, NULL);
d430 2
a431 2
    if (fd < 0)
	reset(0, NULL);
d595 2
a596 2
    if (fd < 0)
	reset(0, NULL);
d645 2
a646 2
    if (fd < 0)
	reset(0, NULL);
d679 2
a680 2
    if (fd < 0)
	reset(0, NULL);
d739 1
a739 1
    cyberflex_fill_key_block (data, 0, 1, DFLTAUT0);
@


1.5
log
@add setpass command
augment jaut with "-d" (use default AUT0) and -x
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.4 2001/07/16 21:02:21 rees Exp $ */
d128 1
a128 1
int jaut(int ac, char *av[])
d167 7
@


1.4
log
@add help text for each command
verify aut0 as necessary for Cyberflex commands
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.3 2001/07/02 20:15:06 rees Exp $ */
d33 1
d45 1
d62 1
a62 1
static unsigned char AUT0[] = {0xad, 0x9f, 0x61, 0xfe, 0xfa, 0x20, 0xce, 0x63};
d91 37
d130 2
a131 1
    int i, r, vflag = 0;
d134 3
a136 1
	reset(ac, av);
d138 1
a138 1
    while ((i = getopt(ac, av, "v")) != -1) {
d146 3
d150 2
a151 1
    if (vflag)
d153 6
d160 7
a166 4
    r = cyberflex_verify_AUT0(fd, cla, AUT0, sizeof AUT0);
    if (r >= 0)
	aut0_vfyd = 1;
    return r;
d728 1
a728 1
    cyberflex_fill_key_block (data,    0, 1, AUT0);
d776 1
a776 1
int load_AUT0(int fd, unsigned char *buf)
d778 1
a778 1
    int sw, rv, i, tmp;
d780 1
a780 1
    unsigned char key[BLOCK_SIZE];
d782 2
a783 2
    if (!aut0_vfyd)
	jaut(0, NULL);
d785 2
a786 1
    printf ("ca_load_AUT0 buf=%s\n", buf);
d788 1
a788 9
    /* Now let's do it. :) */

    /* get the AUT0 */
    printf ("input AUT0 : ");
    for ( i = 0 ; i < BLOCK_SIZE ; i++ ) {
	fscanf (cmdf, "%02x", &tmp);
	key[i] = (unsigned char)tmp;
    }
    cyberflex_fill_key_block (data, 0, 1, key);
d796 2
a797 1
    for ( i = 0 ; i < KEY_BLOCK_SIZE ; i++ )
d800 1
@


1.3
log
@libsectok functions now take status word instead of bytes
add create, delete, isearch
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.1 2001/06/27 19:41:45 rees Exp $ */
d62 2
d89 25
d117 1
a117 1
    int i, p1 = 4, r1, r2;
d131 2
d134 2
a135 2
    scwrite(fd, cla, 0x08, p1, 0, 0, buf, &r1, &r2);
    if (r1 != 0x90) {
d137 1
a137 1
	print_r1r2(r1, r2);
d146 1
a146 1
    int n = 0, r1, r2;
d164 2
a165 2
    scwrite(fd, cla, 0xfa, 0, 0, n, buf, &r1, &r2);
    if (r1 != 0x90) {
d167 1
a167 1
	print_r1r2(r1, r2);
d176 1
a176 1
    int i, r1, r2;
d181 2
a182 2
    scread(fd, cla, 0xca, 0, 1, 0x16, buf, &r1, &r2);
    if (r1 == 0x90) {
d196 1
a196 1
	print_r1r2(r1, r2);
d205 1
a205 1
    int p2, f0, f1, r1, r2;
d213 1
a213 1
	if (scread(fd, cla, 0xa8, 0, p2, JDIRSIZE, buf, &r1, &r2) < 0)
d215 1
a215 1
	if (r1 != 0x90)
d254 2
d279 2
a289 10
int jaut(int ac, char *av[])
{
    if (fd < 0)
	reset(0, NULL);

    cla = cyberflex_inq_class(fd);
    printf("Class %02x\n", cla);
    return cyberflex_verify_AUT0(fd, cla, AUT0, sizeof AUT0);
}

d357 1
a357 1
    int i, j, fd_app, size, rv, sw, r1, r2;
d366 2
d435 2
a436 2
    rv = scwrite(fd, cla, 0xa4, 0x04, 0, 0, NULL, &r1, &r2);
    if (r1 != 0x90 && r1 != 0x61) {
d438 1
a438 1
	printf("can't select default loader: %s\n", get_r1r2s(r1, r2));
d461 1
a461 6
	rv = scwrite(fd, cla, 0xd6,
		     i / 256,	/* offset, upper byte */
		     i % 256,	/* offset, lower byte */
		     send_size,
		     app_data + i, /* program file */
		     &r1, &r2);
d463 1
a463 1
	if (r1 != 0x90 && r1 != 0x61) {
d465 1
a465 1
	    printf("updating binary %s: %s\n", progname, get_r1r2s(r1, r2));
d471 1
a471 3
    rv = scwrite(fd, cla, 0x0a, 01, 0, 0x08,
		 tmp,		/* signature */
		 &r1, &r2);
d473 1
a473 1
    if (r1 != 0x90 && r1 != 0x61) {
d475 1
a475 1
	printf("validating applet in %s: %s\n", progname, get_r1r2s(r1, r2));
d480 2
a481 2
    rv = scwrite(fd, cla, 0xa4, 0x04, 0, 0, NULL, &r1, &r2);
    if (r1 != 0x90 && r1 != 0x61) {
d483 1
a483 1
	printf("selecting default loader: %s\n", get_r1r2s(r1, r2));
d510 2
a511 2
    rv = scwrite(fd, cla, 0x0c, 0x13, 0, 11 + aid_len, data, &r1, &r2);
    if (r1 != 0x90 && r1 != 0x61) {
d513 1
a513 1
	printf("executing install() method in applet %s: %s\n", progname, get_r1r2s(r1, r2));
d524 1
a524 1
    int sw, r1, r2, rv;
d531 2
a538 7
    /*printf ("AID                     ");
      for (i = 0 ; i < aid_len ; i ++ ) {
      printf ("%02x", (unsigned char)aid[i]);
      }
      printf ("\n");*/

    /*printf ("unload applet\n");*/
d550 2
a551 2
	rv = scwrite(fd, cla, 0x0a, 02, 0, 0x0, NULL, &r1, &r2);
	if (rv < 0 || (r1 != 0x90 && r1 != 0x61)) {
d553 1
a553 1
	    printf("resetting applet: %s\n", get_r1r2s(r1, r2));
d571 1
a571 1
    int i, r1, r2, rv;
d594 2
a595 2
    rv = scwrite(fd, cla, 0xa4, 0x04, 0, aid_len, data, &r1, &r2);
    if (r1 != 0x90 && r1 != 0x61) {
d602 1
a602 1
	print_r1r2 (r1, r2);
d632 1
a632 1
    int sw, r1, r2, rv, argc = 0, i, j, tmp;
d667 3
d710 2
a711 3
    rv = scwrite(fd, cla, 0xd6, 0, 0, KEY_BLOCK_SIZE * (argc + 2) + 2,
		 data, &r1, &r2);
    if (r1 != 0x90 && r1 != 0x61) {
d713 1
a713 1
	printf("writing the key file 00.11: %s\n", get_r1r2s(r1, r2));
d723 1
a723 1
    int sw, r1, r2, rv, i, tmp;
d727 2
a728 1
    printf ("load AUT0\n");
d761 2
a762 3
    rv = scwrite(fd, cla, 0xd6, 0, 0, KEY_BLOCK_SIZE,
		 data, &r1, &r2);
    if (r1 != 0x90 && r1 != 0x61) {
d764 1
a764 1
	printf("writing the key file 00.11: %s\n", get_r1r2s(r1, r2));
d802 3
@


1.2
log
@fix return codes
@
text
@d45 1
d210 47
d334 1
a334 1
    int i, j, fd_app, size, rv, r1, r2;
d418 1
a418 1
    if (sectok_selectfile(fd, cla, root_fid, &r1, &r2) < 0)
d422 1
a422 1
    if (cyberflex_create_file(fd, cla, progID, size, 3, &r1, &r2) < 0) {
d424 1
a424 1
	printf("can't create %s: %s\n", progname, get_r1r2s(r1, r2));
d506 1
a506 1
    int r1, r2, rv;
d528 2
a529 1
    if (sectok_selectfile(fd, cla, root_fid, &r1, &r2) < 0)
d531 1
d534 1
a534 1
    if (sectok_selectfile(fd, cla, progID, &r1, &r2) >= 0) {
d544 2
a545 2
	if (cyberflex_delete_file(fd, cla, progID[0], progID[1], &r1, &r2) < 0)
	    printf("delete_file %s: %s\n", progname, get_r1r2s(r1, r2));
d550 2
a551 2
    if (cyberflex_delete_file(fd, cla, contID[0], contID[1], &r1, &r2) < 0)
	printf("delete_file %s: %s\n", contname, get_r1r2s(r1, r2));
a574 6
    /* select data container (77.78) */
    /*rv = sectok_selectfile (fd, cla, root_fid, 0);
      if (rv < 0) return rv;
      rv = sectok_selectfile (fd, cla, contID, 0);
      if (rv < 0) return rv;*/

d598 1
a598 1
    int r1, r2, rv;
d603 2
a604 2
    rv = scwrite(fd, cla, 0xa4, 0x04, 0, 0x00, NULL, &r1, &r2);
    if (r1 != 0x90 && r1 != 0x61) {
d606 1
a606 2
	printf ("selecting the default loader: ");
	print_r1r2 (r1, r2);
d619 1
a619 1
    int r1, r2, rv, argc = 0, i, j, tmp;
d682 2
a683 1
    if (sectok_selectfile(fd, cla, root_fid, &r1, &r2) < 0)
d685 1
d688 2
a689 1
    if (sectok_selectfile(fd, cla, key_fid, &r1, &r2) < 0)
d691 1
d708 1
a708 1
    int r1, r2, rv, i, tmp;
d737 1
a737 1
    if (sectok_selectfile(fd, cla, root_fid, &r1, &r2) < 0)
d741 1
a741 1
    if (sectok_selectfile(fd, cla, key_fid, &r1, &r2) < 0)
d759 1
a759 1
    int rv, r1, r2, i, j, tmp;
d789 1
a789 1
				 key_elements, &r1, &r2);
d792 1
a792 1
	printf("load_rsa_priv: %s\n", get_r1r2s(r1, r2));
@


1.1
log
@sectok control program
@
text
@d1 1
a1 1
/* $Id: pay_cyberflex.c,v 1.22 2001/06/27 13:51:44 rees Exp $ */
d365 1
a365 2
	printf("selecting default loader: ");
	print_r1r2(r1, r2);
d370 2
a371 2
    rv = sectok_selectfile(fd, cla, root_fid, 0);
    if (rv < 0) return rv;
d374 1
a374 14
    data[0] = (size + 16) / 256; /* size, upper byte */
    data[1] = (size + 16) % 256; /* size, lower byte */
    data[2] = progID[0];	/* FID, upper */
    data[3] = progID[1];	/* FID, lower */
    data[4] = 0x03;		/* file type = 3 (program file) */
    data[5] = 0x01;		/* status = 1 */
    data[6] = data[7] = 0x00;	/* record related */
    data[8] = 0xff;		/* ACL can do everything with AUT0 */
    for (i = 9; i < 16; i++ ) {
	data[i] = 0x00;		/* ACL : cannot do anything without AUT0 */
    }

    rv = scwrite(fd, cla, 0xe0, 0, 0, 0x10, data, &r1, &r2);
    if (r1 != 0x90 && r1 != 0x61) {
d376 1
a376 1
	printf("creating file %s: %s\n", progname, get_r1r2s(r1, r2));
a379 4
    /* select program */
    rv = sectok_selectfile(fd, cla, progID, 0);
    if (rv < 0) return rv;

d480 2
a481 2
    rv = sectok_selectfile(fd, cla, root_fid, 0);
    if (rv < 0) return rv;
d484 1
a484 5
    rv = sectok_selectfile(fd, cla, progID, 0);
    if (rv < 0) {
	printf ("no program file... proceed to delete data container\n");
	goto del_container;
    }
d486 6
a491 6
    /* manage program -- reset */
    rv = scwrite(fd, cla, 0x0a, 02, 0, 0x0, NULL, &r1, &r2);
    if (r1 != 0x90 && r1 != 0x61) {
	/* error */
	printf("resetting applet: %s\n", get_r1r2s(r1, r2));
    }
d493 5
a497 2
    /* delete program file */
    cyberflex_delete_file(fd, cla, progID[0], progID[1], 1);
a498 1
 del_container:
d500 2
a501 1
    cyberflex_delete_file(fd, cla, contID[0], contID[1], 1);
a637 1
    /* select the key file */
d639 2
a640 2
    rv = sectok_selectfile(fd, cla, root_fid, 0);
    if (rv < 0) return rv;
d643 2
a644 2
    rv = sectok_selectfile(fd, cla, key_fid, 0);
    if (rv < 0) return rv;
d651 1
a651 2
	printf("writing the key file 00.11: ");
	print_r1r2(r1, r2);
a653 1
    print_r1r2 (r1, r2);
a688 1
    /* select the key file */
d690 2
a691 2
    rv = sectok_selectfile(fd, cla, root_fid, 0);
    if (rv < 0) return rv;
d694 2
a695 2
    rv = sectok_selectfile(fd, cla, key_fid, 0);
    if (rv < 0) return rv;
d702 1
a702 2
	printf("writing the key file 00.11: ");
	print_r1r2(r1, r2);
a704 1
    print_r1r2(r1, r2);
d712 1
a712 1
    int rv, i, j, tmp;
d741 5
a745 1
    rv = cyberflex_load_rsa_priv(fd, cla, key_fid, NUM_RSA_KEY_ELEMENTS, RSA_BIT_LEN, key_elements);
@

