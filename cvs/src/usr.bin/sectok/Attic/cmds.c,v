head	1.22;
access;
symbols
	OPENBSD_4_8:1.21.0.30
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.26
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.28
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.24
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.22
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.20
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.18
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.16
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.14
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.12
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.10
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.8
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.6
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17;
locks; strict;
comment	@ * @;


1.22
date	2010.10.17.08.43.20;	author djm;	state dead;
branches;
next	1.21;

1.21
date	2003.04.04.00.42.34;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.17.07.10.52;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.20.22.30.58;	author rees;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.21.11.50;	author rees;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.02.16.22.40;	author rees;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.15.19.48.39;	author rees;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.02.17.09.18;	author rees;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.27.14.13.08;	author rees;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.26.20.00.16;	author rees;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.26.16.10.01;	author rees;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.20.15.52.54;	author rees;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.19.21.24.27;	author rees;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.17.21.04.14;	author rees;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.17.17.58.23;	author rees;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.17.17.10.44;	author rees;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.17.15.16.46;	author rees;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.16.23.09.36;	author rees;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.16.21.02.21;	author rees;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.02.20.15.06;	author rees;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.28.21.29.44;	author rees;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.27.19.41.45;	author rees;	state Exp;
branches;
next	;


desc
@@


1.22
log
@remove sectok(1); it hasn't been updated in years and doesn't work
with the current generation of tokens; ok markus@@ deraadt@@
@
text
@/*	$OpenBSD: cmds.c,v 1.21 2003/04/04 00:42:34 deraadt Exp $ */

/*
 * Smartcard commander.
 * Written by Jim Rees and others at University of Michigan.
 */

/*
 * copyright 2001
 * the regents of the university of michigan
 * all rights reserved
 *
 * permission is granted to use, copy, create derivative works
 * and redistribute this software and such derivative works
 * for any purpose, so long as the name of the university of
 * michigan is not used in any advertising or publicity
 * pertaining to the use or distribution of this software
 * without specific, written prior authorization.  if the
 * above copyright notice or any other identification of the
 * university of michigan is included in any copy of any
 * portion of this software, then the disclaimer below must
 * also be included.
 *
 * this software is provided as is, without representation
 * from the university of michigan as to its fitness for any
 * purpose, and without warranty by the university of
 * michigan of any kind, either express or implied, including
 * without limitation the implied warranties of
 * merchantability and fitness for a particular purpose. the
 * regents of the university of michigan shall not be liable
 * for any damages, including special, indirect, incidental, or
 * consequential damages, with respect to any claim arising
 * out of or in connection with the use of the software, even
 * if it has been or is hereafter advised of the possibility of
 * such damages.
 */

#ifdef __palmos__
#pragma pack(2)
#include <Common.h>
#include <System/SysAll.h>
#include <UI/UIAll.h>
#include <System/Unix/sys_types.h>
#include <System/Unix/unix_stdio.h>
#include <System/Unix/unix_stdlib.h>
#include <System/Unix/unix_string.h>
#include <string.h>
#include "getopt.h"
#include "sectok.h"
#include "field.h"
#else
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <sectok.h>
#endif

#include "sc.h"

#define MAXFILELEN 0xffff
#define CARDIOSIZE 200

struct dispatchtable dispatch_table[] = {
	/* Non-card commands */
	{ "help", "[command]", help },
	{ "?", "[command]", help },
	{ "reset", "[-1234ivf]", reset },
	{ "open", "[-1234ivf]", reset },
	{ "close", "", dclose },
	{ "quit", "", quit },

	/* 7816-4 commands */
	{ "apdu", "[-c class] ins p1 p2 p3 data ...", apdu },
	{ "fid", "[-v] fid/aid", selfid },
	{ "isearch", "", isearch },
	{ "csearch", "", csearch },
	{ "class", "[class]", class },
	{ "read", "[-x] [filesize]", dread },
	{ "write", "input-filename", dwrite },
	{ "challenge", "[size]", challenge },
	{ "pin", "[-k keyno] [PIN]", vfypin },
#ifndef __palmos__
	{ "chpin", "[-k keyno]", chpin },
#endif

	/* Cyberflex commands */
	{ "ls", "[-l]", ls },
	{ "acl", "[-x] fid [principal: r1 r2 ...]", acl },
	{ "create", "fid size", jcreate },
	{ "delete", "fid", jdelete },
	{ "jdefault", "[-d]", jdefault },
	{ "jatr", "", jatr },
	{ "jdata", "", jdata },
	{ "login", "[-d] [-k keyno] [-v] [-x hex-aut0]", jlogin },
#ifndef __palmos__
	{ "jaut", "", jaut },
	{ "jload", "[-p progID] [-c contID] [-s cont_size] [-i inst_size] [-a aid] [-v] filename", jload },
#endif
	{ "junload", "[-p progID] [-c contID]", junload },
#ifndef __palmos__
	{ "setpass", "[-d] [-x hex-aut0]", jsetpass },
#endif
	{ NULL, NULL, NULL }
};

int     curlen;

int
dispatch(int argc, char *argv[])
{
	int     i;

	if (argc < 1)
		return 0;

	for (i = 0; dispatch_table[i].cmd; i++) {
		if (!strncmp(argv[0], dispatch_table[i].cmd, strlen(argv[0]))) {
			(dispatch_table[i].action) (argc, argv);
			break;
		}
	}
	if (!dispatch_table[i].cmd) {
		printf("unknown command \"%s\"\n", argv[0]);
		return -1;
	}
	return 0;
}

int
help(int argc, char *argv[])
{
	int     i, j;

	if (argc < 2) {
		for (i = 0; dispatch_table[i].cmd; i++)
			printf("%s\n", dispatch_table[i].cmd);
	} else {
		for (j = 1; j < argc; j++) {
			for (i = 0; dispatch_table[i].cmd; i++)
				if (!strncmp(argv[j], dispatch_table[i].cmd,
				    strlen(argv[j])))
					break;
			if (dispatch_table[i].help)
				printf("%s %s\n", dispatch_table[i].cmd,
				    dispatch_table[i].help);
			else
				printf("no help on \"%s\"\n", argv[j]);
		}
	}

	return 0;
}

int
reset(int argc, char *argv[])
{
	int     i, n, oflags = 0, rflags = 0, vflag = 0, sw;
	unsigned char atr[34];
	struct scparam param;

	optind = optreset = 1;

	while ((i = getopt(argc, argv, "0123ivf")) != -1) {
		switch (i) {
		case '0':
		case '1':
		case '2':
		case '3':
			port = i - '0';
			break;
		case 'i':
			oflags |= STONOWAIT;
			break;
		case 'v':
			vflag = 1;
			break;
		case 'f':
			rflags |= STRFORCE;
			break;
		}
	}

	if (fd < 0) {
		fd = sectok_open(port, oflags, &sw);
		if (fd < 0) {
			sectok_print_sw(sw);
			return -1;
		}
	}
	aut0_vfyd = 0;

	n = sectok_reset(fd, rflags, atr, &sw);
	if (vflag) {
#ifdef __palmos__
		hidefield(printfield->id);
		sectok_parse_atr(fd, STRV, atr, n, &param);
		showfield(printfield->id);
#else
		sectok_parse_atr(fd, STRV, atr, n, &param);
#endif
	}
	if (!sectok_swOK(sw)) {
		printf("sectok_reset: %s\n", sectok_get_sw(sw));
		dclose(0, NULL);
		return -1;
	}
	return 0;
}

int
dclose(int argc, char *argv[])
{
	if (fd >= 0) {
		sectok_close(fd);
		fd = -1;
	}
	return 0;
}

int
quit(int argc, char *argv[])
{
	dclose(0, NULL);
#ifndef __palmos__
	exit(0);
#else
	return -1;
#endif
}

int
apdu(int argc, char *argv[])
{
	int     i, ilen, olen, n, ins, xcl = cla, p1, p2, p3, sw;
	unsigned char ibuf[256], obuf[256], *bp;

	optind = optreset = 1;

	while ((i = getopt(argc, argv, "c:")) != -1) {
		switch (i) {
		case 'c':
			sscanf(optarg, "%x", &xcl);
			break;
		}
	}

	if (argc - optind < 4) {
		printf("usage: apdu [-c class] ins p1 p2 p3 data ...\n");
		return -1;
	}
	sscanf(argv[optind++], "%x", &ins);
	sscanf(argv[optind++], "%x", &p1);
	sscanf(argv[optind++], "%x", &p2);
	sscanf(argv[optind++], "%x", &p3);

	for (bp = ibuf, i = optind, ilen = 0; i < argc; i++) {
		sscanf(argv[i], "%x", &n);
		if (bp == &ibuf[sizeof ibuf-1]) {
			printf("truncation\n");
			break;
		}
		*bp++ = n;
		ilen++;
	}

	if (fd < 0 && reset(0, NULL) < 0)
		return -1;

	olen = (p3 && !ilen) ? p3 : sizeof obuf;

	n = sectok_apdu(fd, xcl, ins, p1, p2, ilen, ibuf, olen, obuf, &sw);

	sectok_dump_reply(obuf, n, sw);

	return 0;
}

int
selfid(int argc, char *argv[])
{
	unsigned char fid[16], obuf[256];
	char   *fname;
	int     i, n, sel, fidlen, vflag = 0, sw;

	optind = optreset = 1;

	while ((i = getopt(argc, argv, "v")) != -1) {
		switch (i) {
		case 'v':
			vflag = 1;
			break;
		}
	}

	if (argc - optind == 0) {
		/* No fid/aid given; select null aid (default loader for
		 * Cyberflex) */
		sel = 4;
		fidlen = 0;
	} else {
		fname = argv[optind++];
		if (!strcmp(fname, "..")) {
			/* Special case ".." means parent */
			sel = 3;
			fidlen = 0;
		} else
			if (strlen(fname) < 5) {
				/* fid */
				sel = 0;
				fidlen = 2;
				sectok_parse_fname(fname, fid);
			} else {
				/* aid */
				sel = 4;
				fidlen = sectok_parse_input(fname, fid, sizeof fid);
				if (fname[0] == '#') {
					/* Prepend 0xfc to the aid to make it
					 * a "proprietary aid". */
					fid[0] = 0xfc;
				}
			}
	}

	if (fd < 0 && reset(0, NULL) < 0)
		return -1;

	n = sectok_apdu(fd, cla, 0xa4, sel, 0, fidlen, fid, 256, obuf, &sw);
	if (!sectok_swOK(sw)) {
		printf("Select %02x%02x: %s\n", fid[0], fid[1], sectok_get_sw(sw));
		return -1;
	}
	if (vflag && !n && sectok_r1(sw) == 0x61 && sectok_r2(sw)) {
		/* The card has out data but we must explicitly ask for it */
		n = sectok_apdu(fd, cla, 0xc0, 0, 0, 0, NULL, sectok_r2(sw), obuf, &sw);
	}
	if (n >= 4) {
		/* Some cards put the file length here. No guarantees. */
		curlen = (obuf[2] << 8) | obuf[3];
	}
	if (vflag)
		sectok_dump_reply(obuf, n, sw);

	return 0;
}

int
isearch(int argc, char *argv[])
{
	int     i, r1, sw;

	if (fd < 0 && reset(0, NULL) < 0)
		return -1;

	/* find instructions */
	for (i = 0; i < 0xff; i += 2) {
		sectok_apdu(fd, cla, i, 0, 0, 0, NULL, 0, NULL, &sw);
		r1 = sectok_r1(sw);
		if (r1 != 0x06 && r1 != 0x6d && r1 != 0x6e)
			printf("%02x %s %s\n", i, sectok_get_ins(i),
			    sectok_get_sw(sw));
	}
	return 0;
}

int
csearch(int argc, char *argv[])
{
	int     i, r1, sw;

	if (fd < 0 && reset(0, NULL) < 0)
		return -1;

	/* find app classes */
	for (i = 0; i <= 0xff; i++) {
		sectok_apdu(fd, i, 0xa4, 0, 0, 2, root_fid, 0, NULL, &sw);
		r1 = sectok_r1(sw);
		if (r1 != 0x06 && r1 != 0x6d && r1 != 0x6e)
			printf("%02x %s\n", i, sectok_get_sw(sw));
	}
	return 0;
}

int
class(int argc, char *argv[])
{
	if (argc > 1)
		sscanf(argv[1], "%x", &cla);
	else
		printf("Class %02x\n", cla);
	return 0;
}

int
dread(int argc, char *argv[])
{
	int     i, n, col = 0, fsize, xflag = 0, sw;
	unsigned int p3;
	unsigned char buf[CARDIOSIZE + 1];

	optind = optreset = 1;

	while ((i = getopt(argc, argv, "x")) != -1) {
		switch (i) {
		case 'x':
			xflag = 1;
			break;
		}
	}

	if (argc - optind < 1)
		fsize = curlen;
	else
		sscanf(argv[optind++], "%d", &fsize);

	if (!fsize) {
		printf("please specify filesize\n");
		return -1;
	}
	if (fd < 0 && reset(0, NULL) < 0)
		return -1;

	for (p3 = 0; fsize && p3 < MAXFILELEN; p3 += n) {
		n = (fsize < CARDIOSIZE) ? fsize : CARDIOSIZE;
		n = sectok_apdu(fd, cla, 0xb0, p3 >> 8, p3 & 0xff, 0,
		    NULL, n, buf, &sw);
		if (!sectok_swOK(sw)) {
			printf("ReadBinary: %s\n", sectok_get_sw(sw));
			break;
		}
#ifdef __palmos__
		if (xflag) {
			hidefield(printfield->id);
			for (i = 0; i < n; i++) {
				printf("%02x ", buf[i]);
				if (col++ % 12 == 11)
					printf("\n");
			}
			showfield(printfield->id);
		} else {
			buf[n] = '\0';
			printf("%s", buf);
		}
#else
		if (xflag) {
			for (i = 0; i < n; i++) {
				printf("%02x ", buf[i]);
				if (col++ % 16 == 15)
					printf("\n");
			}
		} else
			fwrite(buf, 1, n, stdout);
#endif
		fsize -= n;
	}

	if (xflag && col % 16 != 0)
		printf("\n");

	return 0;
}

#ifndef __palmos__
int
dwrite(int argc, char *argv[])
{
	int     n, p3, sw;
	FILE   *f;
	unsigned char buf[CARDIOSIZE];

	if (argc != 2) {
		printf("usage: write input-filename\n");
		return -1;
	}
	if (fd < 0 && reset(0, NULL) < 0)
		return -1;

	f = fopen(argv[1], "r");
	if (!f) {
		printf("can't open %s\n", argv[1]);
		return -1;
	}
	n = 0;
	while ((p3 = fread(buf, 1, CARDIOSIZE, f)) > 0) {
		sectok_apdu(fd, cla, 0xd6, n >> 8, n & 0xff, p3, buf, 0, NULL, &sw);
		if (!sectok_swOK(sw)) {
			printf("UpdateBinary: %s\n", sectok_get_sw(sw));
			break;
		}
		n += p3;
	}
	fclose(f);

	return (n ? 0 : -1);
}

#else

int
dwrite(int argc, char *argv[])
{
	int     n, sw;
	char   *s;

	if (argc != 2) {
		printf("usage: write text\n");
		return -1;
	}
	s = argv[1];
	n = strlen(s);
	sectok_apdu(fd, cla, 0xd6, 0, 0, n, s, 0, NULL, &sw);
	if (!sectok_swOK(sw)) {
		printf("UpdateBinary: %s\n", sectok_get_sw(sw));
		return -1;
	}
	return 0;
}
#endif

int
challenge(int argc, char *argv[])
{
	int     n = 8, sw;
	unsigned char buf[256];

	if (argc > 1)
		n = atoi(argv[1]);

	n = sectok_apdu(fd, cla, 0x84, 0, 0, 0, NULL, n, buf, &sw);

	if (!sectok_swOK(sw)) {
		printf("GetChallenge: %s\n", sectok_get_sw(sw));
		return -1;
	}
	sectok_dump_reply(buf, n, sw);
	return 0;
}

int
vfypin(int argc, char *argv[])
{
	int     keyno = 1, i, sw;
	char   *pin;

	optind = optreset = 1;

	while ((i = getopt(argc, argv, "k:")) != -1) {
		switch (i) {
		case 'k':
			keyno = atoi(optarg);
			break;
		}
	}

	if (argc - optind >= 1)
		pin = argv[optind++];
	else {
#ifndef __palmos__
		pin = getpass("Enter PIN: ");
#else
		printf("usage: pin PIN\n");
		return -1;
#endif
	}

	sectok_apdu(fd, cla, 0x20, 0, keyno, strlen(pin), pin, 0, NULL, &sw);
	bzero(pin, strlen(pin));

	if (!sectok_swOK(sw)) {
		printf("VerifyCHV: %s\n", sectok_get_sw(sw));
		return -1;
	}
	return 0;
}

#ifndef __palmos__
int
chpin(int argc, char *argv[])
{
	int     keyno = 1, i, sw;
	char    pin[255];
	char	*pass;

	optind = optreset = 1;

	while ((i = getopt(argc, argv, "k:")) != -1) {
		switch (i) {
		case 'k':
			keyno = atoi(optarg);
			break;
		}
	}

	pass = getpass("Enter Old PIN: ");
	strlcpy(pin, pass, sizeof pin);
	pass = getpass("Enter New PIN: ");
	strlcat(pin, pass, sizeof pin);

	sectok_apdu(fd, cla, 0x24, 0, keyno, strlen(pin), pin, 0, NULL, &sw);
	bzero(pin, strlen(pin));

	if (!sectok_swOK(sw)) {
		printf("UpdateCHV: %s\n", sectok_get_sw(sw));
		return -1;
	}
	return 0;
}
#endif
@


1.21
log
@snprintf & strlcpy; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.20 2002/06/17 07:10:52 deraadt Exp $ */
@


1.20
log
@make this readable.  If I broke something, someone else gets to fix it now that we can read it
@
text
@d1 1
a1 1
/*	$OpenBSD: cmds.c,v 1.19 2002/03/20 22:30:58 rees Exp $ */
d583 1
d595 4
a598 2
	strcpy(pin, getpass("Enter Old PIN: "));
	strcat(pin, getpass("Enter New PIN: "));
@


1.19
log
@fix for palm again
get_AUT0: "-" means DFLTAUT0
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.10 2002/03/14 22:24:00 rees Exp $ */
d9 28
a36 28
copyright 2001
the regents of the university of michigan
all rights reserved

permission is granted to use, copy, create derivative works 
and redistribute this software and such derivative works 
for any purpose, so long as the name of the university of 
michigan is not used in any advertising or publicity 
pertaining to the use or distribution of this software 
without specific, written prior authorization.  if the 
above copyright notice or any other identification of the 
university of michigan is included in any copy of any 
portion of this software, then the disclaimer below must 
also be included.

this software is provided as is, without representation 
from the university of michigan as to its fitness for any 
purpose, and without warranty by the university of 
michigan of any kind, either express or implied, including 
without limitation the implied warranties of 
merchantability and fitness for a particular purpose. the 
regents of the university of michigan shall not be liable 
for any damages, including special, indirect, incidental, or 
consequential damages, with respect to any claim arising 
out of or in connection with the use of the software, even 
if it has been or is hereafter advised of the possibility of 
such damages.
*/
d66 18
a83 18
    /* Non-card commands */
    { "help", "[command]", help },
    { "?", "[command]", help },
    { "reset", "[ -1234ivf ]", reset },
    { "open", "[ -1234ivf ]", reset },
    { "close", "", dclose },
    { "quit", "", quit },

    /* 7816-4 commands */
    { "apdu", "[ -c class ] ins p1 p2 p3 data ...", apdu },
    { "fid", "[ -v ] fid/aid", selfid },
    { "isearch", "", isearch },
    { "csearch", "", csearch },
    { "class", "[ class ]", class },
    { "read", "[ -x ] [ filesize ]", dread },
    { "write", "input-filename", dwrite },
    { "challenge", "[ size ]", challenge },
    { "pin", "[ -k keyno ] [ PIN ]", vfypin },
d85 1
a85 1
    { "chpin", "[ -k keyno ]", chpin },
d88 9
a96 9
    /* Cyberflex commands */
    { "ls", "[ -l ]", ls },
    { "acl", "[ -x ] fid [ principal: r1 r2 ... ]", acl },
    { "create", "fid size", jcreate },
    { "delete", "fid", jdelete },
    { "jdefault", "[ -d ]", jdefault },
    { "jatr", "", jatr },
    { "jdata", "", jdata },
    { "login", "[ -d ] [ -k keyno ] [ -v ] [ -x hex-aut0 ]", jlogin },
d98 2
a99 2
    { "jaut", "", jaut },
    { "jload", "[ -p progID ] [ -c contID ] [ -s cont_size ] [ -i inst_size ] [ -a aid ] [ -v ] filename", jload },
d101 1
a101 1
    { "junload", "[ -p progID ] [ -c contID ]", junload },
d103 1
a103 1
    { "setpass", "[ -d ] [ -x hex-aut0 ]", jsetpass },
d105 1
a105 1
    { NULL, NULL, NULL }
d108 1
a108 1
int curlen;
d110 2
a111 1
int dispatch(int ac, char *av[])
d113 4
a116 1
    int i;
d118 10
a127 1
    if (ac < 1)
d129 6
d136 15
a150 4
    for (i = 0; dispatch_table[i].cmd; i++) {
	if (!strncmp(av[0], dispatch_table[i].cmd, strlen(av[0]))) {
	    (dispatch_table[i].action) (ac, av);
	    break;
d152 2
a153 6
    }
    if (!dispatch_table[i].cmd) {
	printf("unknown command \"%s\"\n", av[0]);
	return -1;
    }
    return 0;
d156 2
a157 1
int help(int ac, char *av[])
d159 24
a182 45
    int i, j;

    if (ac < 2) {
	for (i = 0; dispatch_table[i].cmd; i++)
	    printf("%s\n", dispatch_table[i].cmd);
    } else {
	for (j = 1; j < ac; j++) {
	    for (i = 0; dispatch_table[i].cmd; i++)
		if (!strncmp(av[j], dispatch_table[i].cmd, strlen(av[j])))
		    break;
	    if (dispatch_table[i].help)
		printf("%s %s\n", dispatch_table[i].cmd, dispatch_table[i].help);
	    else
		printf("no help on \"%s\"\n", av[j]);
	}
    }

    return 0;
}

int reset(int ac, char *av[])
{
    int i, n, oflags = 0, rflags = 0, vflag = 0, sw;
    unsigned char atr[34];
    struct scparam param;

    optind = optreset = 1;

    while ((i = getopt(ac, av, "0123ivf")) != -1) {
	switch (i) {
	case '0':
	case '1':
	case '2':
	case '3':
	    port = i - '0';
	    break;
	case 'i':
	    oflags |= STONOWAIT;
	    break;
	case 'v':
	    vflag = 1;
	    break;
	case 'f':
	    rflags |= STRFORCE;
	    break;
a183 1
    }
a184 2
    if (fd < 0) {
	fd = sectok_open(port, oflags, &sw);
d186 5
a190 2
	    sectok_print_sw(sw);
	    return -1;
d192 1
a192 1
    }
d194 2
a195 4
    aut0_vfyd = 0;

    n = sectok_reset(fd, rflags, atr, &sw);
    if (vflag) {
d197 3
a199 3
	hidefield(printfield->id);
	sectok_parse_atr(fd, STRV, atr, n, &param);
	showfield(printfield->id);
d201 1
a201 1
	sectok_parse_atr(fd, STRV, atr, n, &param);
d203 7
a209 8
    }
    if (!sectok_swOK(sw)) {
	printf("sectok_reset: %s\n", sectok_get_sw(sw));
	dclose(0, NULL);
	return -1;
    }

    return 0;
d212 2
a213 1
int dclose(int ac, char *av[])
d215 5
a219 5
    if (fd >= 0) {
	sectok_close(fd);
	fd = -1;
    }
    return 0;
d222 2
a223 1
int quit(int ac, char *av[])
d225 1
a225 1
    dclose(0, NULL);
d227 1
a227 1
    exit(0);
d229 1
a229 1
    return -1;
d233 2
a234 1
int apdu(int ac, char *av[])
d236 2
a237 2
    int i, ilen, olen, n, ins, xcl = cla, p1, p2, p3, sw;
    unsigned char ibuf[256], obuf[256], *bp;
d239 1
a239 1
    optind = optreset = 1;
d241 6
a246 5
    while ((i = getopt(ac, av, "c:")) != -1) {
	switch (i) {
	case 'c':
	    sscanf(optarg, "%x", &xcl);
	    break;
a247 1
    }
d249 8
a256 4
    if (ac - optind < 4) {
	printf("usage: apdu [ -c class ] ins p1 p2 p3 data ...\n");
	return -1;
    }
d258 9
a266 10
    sscanf(av[optind++], "%x", &ins);
    sscanf(av[optind++], "%x", &p1);
    sscanf(av[optind++], "%x", &p2);
    sscanf(av[optind++], "%x", &p3);

    for (bp = ibuf, i = optind, ilen = 0; i < ac; i++) {
	sscanf(av[i], "%x", &n);
	*bp++ = n;
	ilen++;
    }
d268 2
a269 2
    if (fd < 0 && reset(0, NULL) < 0)
	return -1;
d271 1
a271 1
    olen = (p3 && !ilen) ? p3 : sizeof obuf;
d273 1
a273 1
    n = sectok_apdu(fd, xcl, ins, p1, p2, ilen, ibuf, olen, obuf, &sw);
d275 1
a275 1
    sectok_dump_reply(obuf, n, sw);
d277 1
a277 1
    return 0;
d280 22
a301 31
int selfid(int ac, char *av[])
{
    unsigned char fid[16], obuf[256];
    char *fname;
    int i, n, sel, fidlen, vflag = 0, sw;

    optind = optreset = 1;

    while ((i = getopt(ac, av, "v")) != -1) {
	switch (i) {
	case 'v':
	    vflag = 1;
	    break;
	}
    }

    if (ac - optind == 0) {
	/* No fid/aid given; select null aid (default loader for Cyberflex) */
	sel = 4;
	fidlen = 0;
    } else {
	fname = av[optind++];
	if (!strcmp(fname, "..")) {
	    /* Special case ".." means parent */
	    sel = 3;
	    fidlen = 0;
	} else if (strlen(fname) < 5) {
	    /* fid */
	    sel = 0;
	    fidlen = 2;
	    sectok_parse_fname(fname, fid);
d303 21
a323 7
	    /* aid */
	    sel = 4;
	    fidlen = sectok_parse_input(fname, fid, sizeof fid);
	    if (fname[0] == '#') {
		/* Prepend 0xfc to the aid to make it a "proprietary aid". */
		fid[0] = 0xfc;
	    }
a324 1
    }
d326 2
a327 2
    if (fd < 0 && reset(0, NULL) < 0)
	return -1;
d329 15
a343 5
    n = sectok_apdu(fd, cla, 0xa4, sel, 0, fidlen, fid, 256, obuf, &sw);
    if (!sectok_swOK(sw)) {
	printf("Select %02x%02x: %s\n", fid[0], fid[1], sectok_get_sw(sw));
	return -1;
    }
d345 1
a345 14
    if (vflag && !n && sectok_r1(sw) == 0x61 && sectok_r2(sw)) {
	/* The card has out data but we must explicitly ask for it */
	n = sectok_apdu(fd, cla, 0xc0, 0, 0, 0, NULL, sectok_r2(sw), obuf, &sw);
    }

    if (n >= 4) {
	/* Some cards put the file length here. No guarantees. */
	curlen = (obuf[2] << 8) | obuf[3];
    }

    if (vflag)
	sectok_dump_reply(obuf, n, sw);

    return 0;
d348 2
a349 1
int isearch(int ac, char *av[])
d351 1
a351 1
    int i, r1, sw;
d353 2
a354 2
    if (fd < 0 && reset(0, NULL) < 0)
	return -1;
d356 9
a364 8
    /* find instructions */
    for (i = 0; i < 0xff; i += 2) {
	sectok_apdu(fd, cla, i, 0, 0, 0, NULL, 0, NULL, &sw);
	r1 = sectok_r1(sw);
	if (r1 != 0x06 && r1 != 0x6d && r1 != 0x6e)
	    printf("%02x %s %s\n", i, sectok_get_ins(i), sectok_get_sw(sw));
    }
    return 0;
d367 2
a368 1
int csearch(int ac, char *av[])
d370 1
a370 1
    int i, r1, sw;
d372 2
a373 2
    if (fd < 0 && reset(0, NULL) < 0)
	return -1;
d375 8
a382 8
    /* find app classes */
    for (i = 0; i <= 0xff; i++) {
	sectok_apdu(fd, i, 0xa4, 0, 0, 2, root_fid, 0, NULL, &sw);
	r1 = sectok_r1(sw);
	if (r1 != 0x06 && r1 != 0x6d && r1 != 0x6e)
	    printf("%02x %s\n", i, sectok_get_sw(sw));
    }
    return 0;
d385 2
a386 1
int class(int ac, char *av[])
d388 5
a392 5
    if (ac > 1)
	sscanf(av[1], "%x", &cla);
    else
	printf("Class %02x\n", cla);
    return 0;
d395 2
a396 1
int dread(int ac, char *av[])
d398 34
a431 34
    int i, n, col = 0, fsize, xflag = 0, sw;
    unsigned int p3;
    unsigned char buf[CARDIOSIZE+1];

    optind = optreset = 1;

    while ((i = getopt(ac, av, "x")) != -1) {
	switch (i) {
	case 'x':
	    xflag = 1;
	    break;
	}
    }

    if (ac - optind < 1)
	fsize = curlen;
    else
	sscanf(av[optind++], "%d", &fsize);

    if (!fsize) {
	printf("please specify filesize\n");
	return -1;
    }

    if (fd < 0 && reset(0, NULL) < 0)
	return -1;

    for (p3 = 0; fsize && p3 < MAXFILELEN; p3 += n) {
	n = (fsize < CARDIOSIZE) ? fsize : CARDIOSIZE;
	n = sectok_apdu(fd, cla, 0xb0, p3 >> 8, p3 & 0xff, 0, NULL, n, buf, &sw);
	if (!sectok_swOK(sw)) {
	    printf("ReadBinary: %s\n", sectok_get_sw(sw));
	    break;
	}
d433 12
a444 12
	if (xflag) {
	    hidefield(printfield->id);
	    for (i = 0; i < n; i++) {
		printf("%02x ", buf[i]);
		if (col++ % 12 == 11)
		    printf("\n");
	    }
	    showfield(printfield->id);
	} else {
	    buf[n] = '\0';
	    printf("%s", buf);
	}
d446 8
a453 8
	if (xflag) {
	    for (i = 0; i < n; i++) {
		printf("%02x ", buf[i]);
		if (col++ % 16 == 15)
		    printf("\n");
	    }
	} else
	    fwrite(buf, 1, n, stdout);
d455 2
a456 2
	fsize -= n;
    }
d458 2
a459 2
    if (xflag && col % 16 != 0)
	printf("\n");
d461 1
a461 1
    return 0;
d465 2
a466 1
int dwrite(int ac, char *av[])
d468 26
a493 3
    int n, p3, sw;
    FILE *f;
    unsigned char buf[CARDIOSIZE];
d495 2
a496 4
    if (ac != 2) {
	printf("usage: write input-filename\n");
	return -1;
    }
d498 1
a498 2
    if (fd < 0 && reset(0, NULL) < 0)
	return -1;
d500 5
a504 5
    f = fopen(av[1], "r");
    if (!f) {
	printf("can't open %s\n", av[1]);
	return -1;
    }
d506 7
a512 3
    n = 0;
    while ((p3 = fread(buf, 1, CARDIOSIZE, f)) > 0) {
	sectok_apdu(fd, cla, 0xd6, n >> 8, n & 0xff, p3, buf, 0, NULL, &sw);
d514 2
a515 2
	    printf("UpdateBinary: %s\n", sectok_get_sw(sw));
	    break;
d517 1
a517 24
	n += p3;
    }
    fclose(f);

    return (n ? 0 : -1);
}
#else
int dwrite(int ac, char *av[])
{
    int n, sw;
    char *s;

    if (ac != 2) {
	printf("usage: write text\n");
	return -1;
    }
    s = av[1];
    n = strlen(s);
    sectok_apdu(fd, cla, 0xd6, 0, 0, n, s, 0, NULL, &sw);
    if (!sectok_swOK(sw)) {
	printf("UpdateBinary: %s\n", sectok_get_sw(sw));
	return -1;
    }
    return 0;
d521 2
a522 1
int challenge(int ac, char *av[])
d524 2
a525 2
    int n = 8, sw;
    unsigned char buf[256];
d527 2
a528 2
    if (ac > 1)
	n = atoi(av[1]);
d530 1
a530 1
    n = sectok_apdu(fd, cla, 0x84, 0, 0, 0, NULL, n, buf, &sw);
d532 6
a537 7
    if (!sectok_swOK(sw)) {
	printf("GetChallenge: %s\n", sectok_get_sw(sw));
	return -1;
    }

    sectok_dump_reply(buf, n, sw);
    return 0;
d540 2
a541 1
int vfypin(int ac, char *av[])
d543 2
a544 2
    int keyno = 1, i, sw;
    char *pin;
d546 1
a546 1
    optind = optreset = 1;
d548 6
a553 5
    while ((i = getopt(ac, av, "k:")) != -1) {
	switch (i) {
	case 'k':
	    keyno = atoi(optarg);
	    break;
a554 1
    }
d556 3
a558 3
    if (ac - optind >= 1)
	pin = av[optind++];
    else {
d560 1
a560 1
	pin = getpass("Enter PIN: ");
d562 2
a563 2
	printf("usage: pin PIN\n");
	return -1;
d565 1
a565 1
    }
d567 2
a568 2
    sectok_apdu(fd, cla, 0x20, 0, keyno, strlen(pin), pin, 0, NULL, &sw);
    bzero(pin, strlen(pin));
d570 5
a574 5
    if (!sectok_swOK(sw)) {
	printf("VerifyCHV: %s\n", sectok_get_sw(sw));
	return -1;
    }
    return 0;
d578 2
a579 1
int chpin(int ac, char *av[])
d581 2
a582 2
    int keyno = 1, i, sw;
    char pin[255];
d584 1
a584 1
    optind = optreset = 1;
d586 6
a591 5
    while ((i = getopt(ac, av, "k:")) != -1) {
	switch (i) {
	case 'k':
	    keyno = atoi(optarg);
	    break;
a592 1
    }
d594 2
a595 2
    strcpy(pin, getpass("Enter Old PIN: "));
    strcat(pin, getpass("Enter New PIN: "));
d597 2
a598 2
    sectok_apdu(fd, cla, 0x24, 0, keyno, strlen(pin), pin, 0, NULL, &sw);
    bzero(pin, strlen(pin));
d600 5
a604 5
    if (!sectok_swOK(sw)) {
	printf("UpdateCHV: %s\n", sectok_get_sw(sw));
	return -1;
    }
    return 0;
@


1.18
log
@Add 'pin' and 'chpin' commands
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.17 2001/10/02 16:22:40 rees Exp $ */
d84 1
d86 1
d540 2
a541 1
    else
d543 5
d559 1
d587 1
@


1.17
log
@add csearch
call sectok_close on exit
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.8 2001/10/02 16:12:57 rees Exp $ */
d80 1
a80 1
    { "read", "[ -x ] filesize", dread },
d83 2
d518 58
@


1.16
log
@Merge latest CITI code:
add "challenge" command
get file length in "f" and use it in "read"
PalmOS changes we don't care about
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.6 2001/08/15 19:41:05 rees Exp $ */
d78 1
d216 1
d347 17
@


1.15
log
@Mods for PalmOS
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.3 2001/08/02 16:52:21 rees Exp $ */
a79 1
#ifndef __palmos__
d81 1
a81 1
#endif
d103 2
d186 6
a191 1
    if (vflag)
d193 2
d269 1
a269 1
    int i, n, sel, fidlen, olen = 0, sw;
d276 1
a276 1
	    olen = 256;
d310 1
a310 1
    n = sectok_apdu(fd, cla, 0xa4, sel, 0, fidlen, fid, olen, obuf, &sw);
d316 1
a316 1
    if (olen && !n && sectok_r1(sw) == 0x61 && sectok_r2(sw)) {
d321 6
a326 1
    if (olen)
d374 7
a380 2
    if (ac - optind != 1) {
	printf("usage: read [ -x ] filesize\n");
a383 2
    sscanf(av[optind++], "%d", &fsize);

d394 1
d396 1
d399 1
a399 1
		if (col++ % 16 == 15)
d402 1
a403 1
#ifdef __palmos__
d406 1
d408 7
a416 1
	}
d460 19
d480 19
@


1.14
log
@fix acl on program files
add acl -x option
fix help command
add SCPORT ev
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.13 2001/07/26 20:00:16 rees Exp $ */
d38 14
d58 1
d62 1
d65 1
a65 4
struct {
    char *cmd, *help;
    int (*action) (int ac, char *av[]);
} dispatch_table[] = {
d80 1
d82 1
d93 1
d96 1
d98 1
d100 1
d207 1
d209 3
d347 3
a349 2
    int i, n, col = 0, p3, fsize, xflag = 0, sw;
    unsigned char buf[CARDIOSIZE];
d371 1
a371 1
    for (p3 = 0; fsize && p3 < 100000; p3 += n) {
d384 5
a388 1
	} else
d390 2
d401 1
d435 1
@


1.13
log
@Use registration category 'F' for textual aids (see 7816-5 sec 5.2.4)
Use better defaults for progID and contID
work on the man page
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.12 2001/07/26 16:10:01 rees Exp $ */
d71 1
a71 1
    { "acl", "fid [ principal: r1 r2 ... ]", acl },
d115 1
a115 1
		if (!strncmp(av[j], dispatch_table[i].cmd, strlen(av[0])))
@


1.12
log
@fid command now selects aids too
remove jselect
port numbers are now 0-based
print friendly aid names
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.11 2001/07/20 15:52:54 rees Exp $ */
d269 4
@


1.11
log
@add -v option to fid command
parse_atr -> sectok_parse_atr
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.10 2001/07/19 21:24:27 rees Exp $ */
d63 1
a63 1
    { "fid", "[ -v ] fid", selfid },
a80 1
    { "jselect", "[ -a aid ] [ -d ]", jselect },
d135 1
a135 1
    while ((i = getopt(ac, av, "1234ivf")) != -1) {
d137 1
d141 1
a141 2
	case '4':
	    port = i - '1';
d236 3
a238 2
    unsigned char fid[2], obuf[256];
    int i, n, olen = 0, sw;
d245 1
a245 1
	    olen = sizeof obuf;
d250 20
a269 3
    if (ac - optind != 1) {
	printf("usage: f [ -v ] fid\n");
	return -1;
a270 1
    sectok_parse_fname(av[optind++], fid);
d275 1
a275 1
    n = sectok_apdu(fd, cla, 0xa4, 0, 0, 2, fid, olen, obuf, &sw);
d279 5
@


1.10
log
@add read -x option
add login -k option
add jload -v option
replace jdeselect with jselect -d
parse new Cyberflex data format in jdata command
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.9 2001/07/17 21:04:14 rees Exp $ */
a43 1
#include <sc7816.h>
d63 1
a63 1
    { "fid", "fid", selfid },
d168 1
a168 1
	parse_atr(fd, SCRV, atr, n, &param);
d181 1
a181 1
	scclose(fd);
d237 2
a238 2
    unsigned char fid[2];
    int sw;
d240 12
a251 2
    if (ac != 2) {
	printf("usage: f fid\n");
d254 1
d259 3
a261 3
    sectok_parse_fname(av[1], fid);
    if (sectok_selectfile(fd, cla, fid, &sw) < 0) {
	printf("selectfile: %s\n", sectok_get_sw(sw));
d265 3
d273 1
a273 2
    int i, r1, r2;
    unsigned char buf[256];
d279 6
a284 4
    for (i = 0; i < 0xff; i += 2)
	if (scread(fd, cla, i, 0, 0, 0, buf, &r1, &r2) == 0
	    && r1 != 0x6d && r1 != 0x6e)
	    printf("%02x %s %s\n", i, lookup_cmdname(i), get_r1r2s(r1, r2));
d312 1
a312 1
    if (ac - optind < 1) {
d326 1
a326 1
	    printf("read binary: %s\n", sectok_get_sw(sw));
d348 1
a348 1
    int n, p3, r1, r2;
d368 3
a370 6
	if (scwrite(fd, cla, 0xd6, n >> 8, n & 0xff, p3, buf, &r1, &r2) < 0) {
	    printf("scwrite failed\n");
	    break;
	}
	if (r1 != 0x90 && r1 != 0x61) {
	    print_r1r2(r1, r2);
@


1.9
log
@now you can display and set acls
use sectok_apdu for "apdu" command
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.8 2001/07/17 17:58:23 rees Exp $ */
d67 1
a67 1
    { "read", "filesize", dread },
d78 1
a78 1
    { "login", "[ -d ] [ -v ] [ -x hex-aut0 ]", jlogin },
d80 1
a80 1
    { "jload", "[ -p progID ] [ -c contID ] [ -s cont_size ] [ -i inst_size ] [ -a aid ] filename", jload },
d82 1
a82 2
    { "jselect", "[ -a aid ]", jselect },
    { "jdeselect", "", jdeselect },
d285 1
a285 1
    int n, p3, fsize, r1, r2;
d288 12
a299 2
    if (ac != 2) {
	printf("usage: read filesize\n");
d303 1
a303 1
    sscanf(av[1], "%d", &fsize);
d310 3
a312 2
	if (scread(fd, cla, 0xb0, p3 >> 8, p3 & 0xff, n, buf, &r1, &r2) < 0) {
	    printf("scread failed\n");
d315 8
a322 5
	if (r1 != 0x90 && r1 != 0x61) {
	    print_r1r2(r1, r2);
	    break;
	}
	fwrite(buf, 1, n, stdout);
d325 3
@


1.8
log
@add -l and -a flags to "ls"
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.7 2001/07/17 17:10:44 rees Exp $ */
d71 2
a72 1
    { "ls", "[ -l ] [ -a ]", ls },
d196 2
a197 2
    int i, n, ins, xcl = cla, p1, p2, p3, r1, r2;
    unsigned char buf[256], obuf[256], *bp;
d219 1
a219 5
#if 0
    for (bp = buf, i = optind; i < ac; i++)
	bp += parse_input(av[i], bp, (int) (sizeof buf - (bp - buf)));
#else
    for (bp = buf, i = optind; i < ac; i++) {
d222 1
a223 1
#endif
d228 1
a228 1
    n = scrw(fd, xcl, ins, p1, p2, p3, buf, sizeof obuf, obuf, &r1, &r2);
d230 1
a230 4
    if (n < 0) {
	printf("scrw failed\n");
	return -1;
    }
d232 1
a232 1
    dump_reply(obuf, n, r1, r2);
@


1.7
log
@more better error checking
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.6 2001/07/17 15:16:46 rees Exp $ */
d71 1
a71 1
    { "ls", "", ls },
@


1.6
log
@change jaut back to previous behavior; add new "login" command
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.5 2001/07/16 23:09:36 rees Exp $ */
d152 1
a152 1
	    rflags |= SCRFORCE;
d167 1
a167 1
    n = scxreset(fd, rflags, atr, &sw);
d170 3
a172 2
    if (sw != SCEOK) {
	printf("%s\n", scerrtab[sw]);
d228 2
a229 2
    if (fd < 0)
	reset(0, NULL);
d253 2
a254 2
    if (fd < 0)
	reset(0, NULL);
d270 2
a271 2
    if (fd < 0)
	reset(0, NULL);
d302 2
a303 2
    if (fd < 0)
	reset(0, NULL);
d333 2
a334 2
    if (fd < 0)
	reset(0, NULL);
@


1.5
log
@add setpass command
augment jaut with "-d" (use default AUT0) and -x
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.4 2001/07/16 21:02:21 rees Exp $ */
d77 2
a78 1
    { "jaut", "[ -d ] [ -v ] [ -x hex-aut0 ]", jaut },
@


1.4
log
@add help text for each command
verify aut0 as necessary for Cyberflex commands
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.3 2001/07/02 20:15:06 rees Exp $ */
d77 1
a77 1
    { "jaut", "[ -v ]", jaut },
d82 1
@


1.3
log
@libsectok functions now take status word instead of bytes
add create, delete, isearch
@
text
@d1 1
a1 1
/* $Id: cmds.c,v 1.1 2001/06/27 19:41:45 rees Exp $ */
d51 1
a51 1
    char *cmd;
d55 6
a60 6
    { "help", help },
    { "?", help },
    { "reset", reset },
    { "open", reset },
    { "close", dclose },
    { "quit", quit },
d63 6
a68 6
    { "apdu", apdu },
    { "fid", selfid },
    { "isearch", isearch },
    { "class", class },
    { "read", dread },
    { "write", dwrite },
d71 12
a82 12
    { "ls", ls },
    { "create", jcreate },
    { "delete", jdelete },
    { "jdefault", jdefault },
    { "jatr", jatr },
    { "jdata", jdata },
    { "jaut", jaut },
    { "jload", jload },
    { "junload", junload },
    { "jselect", jselect },
    { "jdeselect", jdeselect },
    { NULL, NULL }
a83 3
/*
    { "",  },
*/
d107 1
a107 1
    int i;
d109 2
a110 2
    for (i = 0; dispatch_table[i].cmd; i++) {
	if (strlen(dispatch_table[i].cmd) > 1)
d112 10
d163 2
a165 4
    if (n && !vflag) {
	printf("atr ");
	dump_reply(atr, n, 0, 0);
    }
d206 1
a206 1
	printf("usage: apdu [ -c cla ] ins p1 p2 p3 data ...\n");
@


1.2
log
@fix return codes
@
text
@d44 1
d65 1
d72 2
d122 3
a124 2
    int i, n, port = 0, oflags = SCODSR, rflags = 0, err;
    unsigned char buf[34];
d137 1
a137 1
	    oflags &= ~SCODSR;
d140 1
a140 1
	    rflags |= SCRV;
d149 1
a149 1
	fd = scopen(0, oflags, &err);
d151 1
a151 1
	    printf("%s\n", scerrtab[err]);
d156 2
a157 2
    n = scxreset(fd, rflags, buf, &err);
    if (n && !(rflags & SCRV)) {
d159 1
a159 1
	dump_reply(buf, n, 0, 0);
d161 4
a164 2
    if (err != SCEOK) {
	printf("%s\n", scerrtab[err]);
d238 1
a238 1
    int r1, r2;
d249 2
a250 2
    if (sectok_selectfile(fd, cla, fid, &r1, &r2) < 0) {
	printf("selectfile: %s\n", get_r1r2s(r1, r2));
d254 16
@


1.1
log
@sectok control program
@
text
@d1 1
a1 1
/* $Id: $ */
a56 1
    { "r", reset },
a59 1
    { "q", quit },
a62 1
    { "a", apdu },
a63 1
    { "f", selfid },
d88 3
d92 1
a92 1
	if (!strcmp(av[0], dispatch_table[i].cmd)) {
d231 1
d242 4
a245 1
    sectok_selectfile(fd, cla, fid, 1);
@

