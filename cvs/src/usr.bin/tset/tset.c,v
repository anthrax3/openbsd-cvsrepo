head	1.39;
access;
symbols
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.8
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.36.0.10
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.6
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.16
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.14
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.12
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.10
	OPENBSD_5_0:1.35.0.8
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.6
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.4
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.33.0.4
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.32.0.6
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.4
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.29.0.4
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.27.0.14
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.12
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.10
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.8
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.6
	OPENBSD_3_6_BASE:1.27
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.25.0.6
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.4
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2015.11.16.03.02.40;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	IA1AeeziGMt4aH4o;

1.38
date	2015.11.15.14.14.20;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	d7vLtViIR7lQjvoD;

1.37
date	2015.08.20.22.28.58;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	2yxZRmq8If969gkp;

1.36
date	2013.09.18.16.21.30;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2010.01.12.23.22.14;	author nicm;	state Exp;
branches;
next	1.34;

1.34
date	2009.11.11.23.49.01;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2009.05.06.21.07.01;	author sobrado;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.15.02.16.35;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.14.14.29.20;	author chl;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.20.01.52.01;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2006.10.10.21.38.16;	author cloder;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.12.20.58.11;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.03.02.56.20;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.16.06.14.31;	author pvalchev;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.28.22.58.52;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.29.01.58.24;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.22.18.02.20;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.08.22.47.11;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.24.04.06.12;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.07.21.15.23;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.13.23.53.41;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.10.01.35.06;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	99.12.04.22.25.02;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.05.23.17.19.21;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	99.03.15.19.00.19;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.03.02.06.23.56;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.01.18.18.57.36;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.01.11.20.11.16;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	98.12.05.14.12.44;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.11.17.03.25.15;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.11.16.03.08.41;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.10.16.18.51.21;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.04.25.04.30.39;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.22.13.25;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.43.25;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.41.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.27;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.39
log
@pledge "stdio rpath wpath tty"
@
text
@/*	$OpenBSD: tset.c,v 1.38 2015/11/15 14:14:20 deraadt Exp $	*/

/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *  Author: Zeyd M. Ben-Halim <zmbenhal@@netcom.com> 1992,1995               *
 *     and: Eric S. Raymond <esr@@snark.thyrsus.com>                         *
 *     and: Thomas E. Dickey                        1996-on                 *
 ****************************************************************************/

/*
 * tset.c - terminal initialization utility
 *
 * This code was mostly swiped from 4.4BSD tset, with some obsolescent
 * cruft removed and substantial portions rewritten.  A Regents of the
 * University of California copyright applies to some portions of the
 * code, and is reproduced below:
 */
/*-
 * Copyright (c) 1980, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define USE_LIBTINFO
#define __INTERNAL_CAPS_VISIBLE	/* we need to see has_hardware_tabs */
#include <progs.priv.h>

#include <errno.h>
#include <stdio.h>
#include <termcap.h>
#include <fcntl.h>

#if HAVE_GETTTYNAM && HAVE_TTYENT_H
#include <ttyent.h>
#endif
#ifdef NeXT
char *ttyname(int fd);
#endif

#if HAVE_SIZECHANGE
# if !defined(sun) || !TERMIOS
#  if HAVE_SYS_IOCTL_H
#   include <sys/ioctl.h>
#  endif
# endif
#endif

#if NEED_PTEM_H
/* they neglected to define struct winsize in termios.h -- it's only
   in termio.h	*/
#include <sys/stream.h>
#include <sys/ptem.h>
#endif

#include <dump_entry.h>
#include <transform.h>

extern char **environ;

#undef CTRL
#define CTRL(x)	((x) & 0x1f)

const char *_nc_progname = "tset";

static TTY mode, oldmode, original;

static bool opt_c;		/* set control-chars */
static bool opt_w;		/* set window-size */

static bool can_restore = FALSE;
static bool isreset = FALSE;	/* invoked as reset */
static int terasechar = -1;	/* new erase character */
static int intrchar = -1;	/* new interrupt character */
static int tkillchar = -1;	/* new kill character */
static int tlines, tcolumns;	/* window size */

#define LOWERCASE(c) ((isalpha(UChar(c)) && isupper(UChar(c))) ? tolower(UChar(c)) : (c))

static int
CaselessCmp(const char *a, const char *b)
{				/* strcasecmp isn't portable */
    while (*a && *b) {
	int cmp = LOWERCASE(*a) - LOWERCASE(*b);
	if (cmp != 0)
	    break;
	a++, b++;
    }
    return LOWERCASE(*a) - LOWERCASE(*b);
}

static void
exit_error(void)
{
    if (can_restore)
	SET_TTY(STDERR_FILENO, &original);
    (void) fprintf(stderr, "\n");
    fflush(stderr);
    ExitProgram(EXIT_FAILURE);
    /* NOTREACHED */
}

static void
err(const char *fmt,...)
{
    va_list ap;
    va_start(ap, fmt);
    (void) fprintf(stderr, "%s: ", _nc_progname);
    (void) vfprintf(stderr, fmt, ap);
    va_end(ap);
    exit_error();
    /* NOTREACHED */
}

static void
failed(const char *msg)
{
    fprintf(stderr, "%s: ", _nc_progname);
    perror(msg);
    exit_error();
    /* NOTREACHED */
}

static void
cat(char *file)
{
    FILE *fp;
    size_t nr;
    char buf[BUFSIZ];

    if ((fp = fopen(file, "r")) == 0)
	failed(file);

    while ((nr = fread(buf, sizeof(char), sizeof(buf), fp)) != 0)
	if (fwrite(buf, sizeof(char), nr, stderr) != nr)
	      failed("write to stderr");
    fclose(fp);
}

static int
outc(int c)
{
    return putc(c, stderr);
}

/* Prompt the user for a terminal type. */
static const char *
askuser(const char *dflt)
{
    static char answer[256];

    /* We can get recalled; if so, don't continue uselessly. */
    clearerr(stdin);
    if (feof(stdin) || ferror(stdin)) {
	(void) fprintf(stderr, "\n");
	exit_error();
	/* NOTREACHED */
    }
    for (;;) {
	if (dflt)
	    (void) fprintf(stderr, "Terminal type? [%s] ", dflt);
	else
	    (void) fprintf(stderr, "Terminal type? ");
	(void) fflush(stderr);

	if (fgets(answer, sizeof(answer), stdin) == NULL) {
	    if (dflt == 0) {
		exit_error();
		/* NOTREACHED */
	    }
	    return (dflt);
	}

	answer[strcspn(answer, "\n")] = '\0';
	if (answer[0])
	    return (answer);
	if (dflt != 0)
	    return (dflt);
    }
}

/**************************************************************************
 *
 * Mapping logic begins here
 *
 **************************************************************************/

/* Baud rate conditionals for mapping. */
#define	GT		0x01
#define	EQ		0x02
#define	LT		0x04
#define	NOT		0x08
#define	GE		(GT | EQ)
#define	LE		(LT | EQ)

typedef struct map {
    struct map *next;		/* Linked list of maps. */
    const char *porttype;	/* Port type, or "" for any. */
    const char *type;		/* Terminal type to select. */
    int conditional;		/* Baud rate conditionals bitmask. */
    int speed;			/* Baud rate to compare against. */
} MAP;

static MAP *cur, *maplist;

typedef struct speeds {
    const char *string;
    int speed;
} SPEEDS;

static const SPEEDS speeds[] =
{
    {"0", B0},
    {"50", B50},
    {"75", B75},
    {"110", B110},
    {"134", B134},
    {"134.5", B134},
    {"150", B150},
    {"200", B200},
    {"300", B300},
    {"600", B600},
    {"1200", B1200},
    {"1800", B1800},
    {"2400", B2400},
    {"4800", B4800},
    {"9600", B9600},
    /* sgttyb may define up to this point */
#ifdef B19200
    {"19200", B19200},
#endif
#ifdef B38400
    {"38400", B38400},
#endif
#ifdef B19200
    {"19200", B19200},
#endif
#ifdef B38400
    {"38400", B38400},
#endif
#ifdef B19200
    {"19200", B19200},
#else
#ifdef EXTA
    {"19200", EXTA},
#endif
#endif
#ifdef B38400
    {"38400", B38400},
#else
#ifdef EXTB
    {"38400", EXTB},
#endif
#endif
#ifdef B57600
    {"57600", B57600},
#endif
#ifdef B115200
    {"115200", B115200},
#endif
#ifdef B230400
    {"230400", B230400},
#endif
#ifdef B460800
    {"460800", B460800},
#endif
    {(char *) 0, 0}
};

static int
tbaudrate(char *rate)
{
    const SPEEDS *sp;
    int found = FALSE;

    /* The baudrate number can be preceded by a 'B', which is ignored. */
    if (*rate == 'B')
	++rate;

    for (sp = speeds; sp->string; ++sp) {
	if (!CaselessCmp(rate, sp->string)) {
	    found = TRUE;
	    break;
	}
    }
    if (!found)
	err("unknown baud rate %s", rate);
    return (sp->speed);
}

/*
 * Syntax for -m:
 * [port-type][test baudrate]:terminal-type
 * The baud rate tests are: >, <, @@, =, !
 */
static void
add_mapping(const char *port, char *arg)
{
    MAP *mapp;
    char *copy, *p;
    const char *termp;
    char *base = 0;

    copy = strdup(arg);
    mapp = malloc(sizeof(MAP));
    if (copy == 0 || mapp == 0)
	failed("malloc");
    mapp->next = 0;
    if (maplist == 0)
	cur = maplist = mapp;
    else {
	cur->next = mapp;
	cur = mapp;
    }

    mapp->porttype = arg;
    mapp->conditional = 0;

    arg = strpbrk(arg, "><@@=!:");

    if (arg == 0) {		/* [?]term */
	mapp->type = mapp->porttype;
	mapp->porttype = 0;
	goto done;
    }

    if (arg == mapp->porttype)	/* [><@@=! baud]:term */
	termp = mapp->porttype = 0;
    else
	termp = base = arg;

    for (;; ++arg) {		/* Optional conditionals. */
	switch (*arg) {
	case '<':
	    if (mapp->conditional & GT)
		goto badmopt;
	    mapp->conditional |= LT;
	    break;
	case '>':
	    if (mapp->conditional & LT)
		goto badmopt;
	    mapp->conditional |= GT;
	    break;
	case '@@':
	case '=':		/* Not documented. */
	    mapp->conditional |= EQ;
	    break;
	case '!':
	    mapp->conditional |= NOT;
	    break;
	default:
	    goto next;
	}
    }

  next:
    if (*arg == ':') {
	if (mapp->conditional)
	    goto badmopt;
	++arg;
    } else {			/* Optional baudrate. */
	arg = strchr(p = arg, ':');
	if (arg == 0)
	    goto badmopt;
	*arg++ = '\0';
	mapp->speed = tbaudrate(p);
    }

    if (arg == (char *) 0)	/* Non-optional type. */
	goto badmopt;

    mapp->type = arg;

    /* Terminate porttype, if specified. */
    if (termp != 0)
	*base = '\0';

    /* If a NOT conditional, reverse the test. */
    if (mapp->conditional & NOT)
	mapp->conditional = ~mapp->conditional & (EQ | GT | LT);

    /* If user specified a port with an option flag, set it. */
  done:
    if (port) {
	if (mapp->porttype) {
	  badmopt:
	    err("illegal -m option format: %s", copy);
	}
	mapp->porttype = port;
    }
    free(copy);
#ifdef MAPDEBUG
    (void) printf("port: %s\n", mapp->porttype ? mapp->porttype : "ANY");
    (void) printf("type: %s\n", mapp->type);
    (void) printf("conditional: ");
    p = "";
    if (mapp->conditional & GT) {
	(void) printf("GT");
	p = "/";
    }
    if (mapp->conditional & EQ) {
	(void) printf("%sEQ", p);
	p = "/";
    }
    if (mapp->conditional & LT)
	(void) printf("%sLT", p);
    (void) printf("\nspeed: %d\n", mapp->speed);
#endif
}

/*
 * Return the type of terminal to use for a port of type 'type', as specified
 * by the first applicable mapping in 'map'.  If no mappings apply, return
 * 'type'.
 */
static const char *
mapped(const char *type)
{
    MAP *mapp;
    int match;

    for (mapp = maplist; mapp; mapp = mapp->next)
	if (mapp->porttype == 0 || !strcmp(mapp->porttype, type)) {
	    switch (mapp->conditional) {
	    case 0:		/* No test specified. */
		match = TRUE;
		break;
	    case EQ:
		match = (ospeed == mapp->speed);
		break;
	    case GE:
		match = (ospeed >= mapp->speed);
		break;
	    case GT:
		match = (ospeed > mapp->speed);
		break;
	    case LE:
		match = (ospeed <= mapp->speed);
		break;
	    case LT:
		match = (ospeed < mapp->speed);
		break;
	    default:
		match = FALSE;
	    }
	    if (match)
		return (mapp->type);
	}
    /* No match found; return given type. */
    return (type);
}

/**************************************************************************
 *
 * Entry fetching
 *
 **************************************************************************/

/*
 * Figure out what kind of terminal we're dealing with, and then read in
 * its termcap entry.
 */
static const char *
get_termcap_entry(char *userarg)
{
    int errret;
    char *p;
    const char *ttype;
#if HAVE_GETTTYNAM
    struct ttyent *t;
#else
    FILE *fp;
#endif
    char *ttypath;

    if (userarg) {
	ttype = userarg;
	goto found;
    }

    /* Try the environment. */
    if ((ttype = getenv("TERM")) != 0)
	goto map;

    if ((ttypath = ttyname(STDERR_FILENO)) != 0) {
	p = _nc_basename(ttypath);
#if HAVE_GETTTYNAM
	/*
	 * We have the 4.3BSD library call getttynam(3); that means
	 * there's an /etc/ttys to look up device-to-type mappings in.
	 * Try ttyname(3); check for dialup or other mapping.
	 */
	if ((t = getttynam(p))) {
	    ttype = t->ty_type;
	    goto map;
	}
#else
	if ((fp = fopen("/etc/ttytype", "r")) != 0
	    || (fp = fopen("/etc/ttys", "r")) != 0) {
	    char buffer[BUFSIZ];
	    char *s, *t, *d;

	    while (fgets(buffer, sizeof(buffer), fp) != NULL) {
		for (s = buffer, t = d = 0; *s; s++) {
		    if (isspace(UChar(*s)))
			*s = '\0';
		    else if (t == 0)
			t = s;
		    else if (d == 0 && s != buffer && s[-1] == '\0')
			d = s;
		}
		if (t != 0 && d != 0 && !strcmp(d, p)) {
		    ttype = strdup(t);
		    fclose(fp);
		    goto map;
		}
	    }
	    fclose(fp);
	}
#endif /* HAVE_GETTTYNAM */
    }

    /* If still undefined, use "unknown". */
    ttype = "unknown";

  map:ttype = mapped(ttype);

    /*
     * If not a path, remove TERMCAP from the environment so we get a
     * real entry from /etc/termcap.  This prevents us from being fooled
     * by out of date stuff in the environment.
     */
  found:if ((p = getenv("TERMCAP")) != 0 && !_nc_is_abs_path(p)) {
	/* 'unsetenv("TERMCAP")' is not portable.
	 * The 'environ' array is better.
	 */
	int n;
	for (n = 0; environ[n] != 0; n++) {
	    if (!strncmp("TERMCAP=", environ[n], 8)) {
		while ((environ[n] = environ[n + 1]) != 0) {
		    n++;
		}
		break;
	    }
	}
    }

    /*
     * ttype now contains a pointer to the type of the terminal.
     * If the first character is '?', ask the user.
     */
    if (ttype[0] == '?') {
	if (ttype[1] != '\0')
	    ttype = askuser(ttype + 1);
	else
	    ttype = askuser(0);
    }
    /* Find the terminfo entry.  If it doesn't exist, ask the user. */
    while (setupterm((NCURSES_CONST char *) ttype, STDOUT_FILENO, &errret)
	   != OK) {
	if (errret == 0) {
	    (void) fprintf(stderr, "%s: unknown terminal type %s\n",
			   _nc_progname, ttype);
	    ttype = 0;
	} else {
	    (void) fprintf(stderr,
			   "%s: can't initialize terminal type %s (error %d)\n",
			   _nc_progname, ttype, errret);
	    ttype = 0;
	}
	ttype = askuser(ttype);
    }
#if BROKEN_LINKER
    tgetflag("am");		/* force lib_termcap.o to be linked for 'ospeed' */
#endif
    return (ttype);
}

/**************************************************************************
 *
 * Mode-setting logic
 *
 **************************************************************************/

/* some BSD systems have these built in, some systems are missing
 * one or more definitions. The safest solution is to override unless the
 * commonly-altered ones are defined.
 */
#if !(defined(CERASE) && defined(CINTR) && defined(CKILL) && defined(CQUIT))
#undef CEOF
#undef CERASE
#undef CINTR
#undef CKILL
#undef CLNEXT
#undef CRPRNT
#undef CQUIT
#undef CSTART
#undef CSTOP
#undef CSUSP
#endif

/* control-character defaults */
#ifndef CEOF
#define CEOF	CTRL('D')
#endif
#ifndef CERASE
#define CERASE	CTRL('H')
#endif
#ifndef CINTR
#define CINTR	127		/* ^? */
#endif
#ifndef CKILL
#define CKILL	CTRL('U')
#endif
#ifndef CLNEXT
#define CLNEXT  CTRL('v')
#endif
#ifndef CRPRNT
#define CRPRNT  CTRL('r')
#endif
#ifndef CQUIT
#define CQUIT	CTRL('\\')
#endif
#ifndef CSTART
#define CSTART	CTRL('Q')
#endif
#ifndef CSTOP
#define CSTOP	CTRL('S')
#endif
#ifndef CSUSP
#define CSUSP	CTRL('Z')
#endif

#if defined(_POSIX_VDISABLE)
#define DISABLED(val)   (((_POSIX_VDISABLE != -1) \
		       && ((val) == _POSIX_VDISABLE)) \
		      || ((val) <= 0))
#else
#define DISABLED(val)   ((int)(val) <= 0)
#endif

#define CHK(val, dft)   (DISABLED(val) ? dft : val)

static bool set_tabs(void);

/*
 * Reset the terminal mode bits to a sensible state.  Very useful after
 * a child program dies in raw mode.
 */
static void
reset_mode(void)
{
#ifdef TERMIOS
    tcgetattr(STDERR_FILENO, &mode);
#else
    stty(STDERR_FILENO, &mode);
#endif

#ifdef TERMIOS
#if defined(VDISCARD) && defined(CDISCARD)
    mode.c_cc[VDISCARD] = CHK(mode.c_cc[VDISCARD], CDISCARD);
#endif
    mode.c_cc[VEOF] = CHK(mode.c_cc[VEOF], CEOF);
    mode.c_cc[VERASE] = CHK(mode.c_cc[VERASE], CERASE);
#if defined(VFLUSH) && defined(CFLUSH)
    mode.c_cc[VFLUSH] = CHK(mode.c_cc[VFLUSH], CFLUSH);
#endif
    mode.c_cc[VINTR] = CHK(mode.c_cc[VINTR], CINTR);
    mode.c_cc[VKILL] = CHK(mode.c_cc[VKILL], CKILL);
#if defined(VLNEXT) && defined(CLNEXT)
    mode.c_cc[VLNEXT] = CHK(mode.c_cc[VLNEXT], CLNEXT);
#endif
    mode.c_cc[VQUIT] = CHK(mode.c_cc[VQUIT], CQUIT);
#if defined(VREPRINT) && defined(CRPRNT)
    mode.c_cc[VREPRINT] = CHK(mode.c_cc[VREPRINT], CRPRNT);
#endif
#if defined(VSTART) && defined(CSTART)
    mode.c_cc[VSTART] = CHK(mode.c_cc[VSTART], CSTART);
#endif
#if defined(VSTOP) && defined(CSTOP)
    mode.c_cc[VSTOP] = CHK(mode.c_cc[VSTOP], CSTOP);
#endif
#if defined(VSUSP) && defined(CSUSP)
    mode.c_cc[VSUSP] = CHK(mode.c_cc[VSUSP], CSUSP);
#endif
#if defined(VWERASE) && defined(CWERASE)
    mode.c_cc[VWERASE] = CHK(mode.c_cc[VWERASE], CWERASE);
#endif

    mode.c_iflag &= ~(IGNBRK | PARMRK | INPCK | ISTRIP | INLCR | IGNCR
#ifdef IUCLC
		      | IUCLC
#endif
#ifdef IXANY
		      | IXANY
#endif
		      | IXOFF);

    mode.c_iflag |= (BRKINT | IGNPAR | ICRNL | IXON
#ifdef IMAXBEL
		     | IMAXBEL
#endif
	);

    mode.c_oflag &= ~(0
#ifdef OLCUC
		      | OLCUC
#endif
#ifdef OCRNL
		      | OCRNL
#endif
#ifdef ONOCR
		      | ONOCR
#endif
#ifdef ONLRET
		      | ONLRET
#endif
#ifdef OFILL
		      | OFILL
#endif
#ifdef OFDEL
		      | OFDEL
#endif
#ifdef NLDLY
		      | NLDLY
#endif
#ifdef CRDLY
		      | CRDLY
#endif
#ifdef TABDLY
		      | TABDLY
#endif
#ifdef BSDLY
		      | BSDLY
#endif
#ifdef VTDLY
		      | VTDLY
#endif
#ifdef FFDLY
		      | FFDLY
#endif
	);

    mode.c_oflag |= (OPOST
#ifdef ONLCR
		     | ONLCR
#endif
	);

    mode.c_cflag &= ~(CSIZE | CSTOPB | PARENB | PARODD | CLOCAL);
    mode.c_cflag |= (CS8 | CREAD);
    mode.c_lflag &= ~(ECHONL | NOFLSH
#ifdef TOSTOP
		      | TOSTOP
#endif
#ifdef ECHOPTR
		      | ECHOPRT
#endif
#ifdef XCASE
		      | XCASE
#endif
	);

    mode.c_lflag |= (ISIG | ICANON | ECHO | ECHOE | ECHOK
#ifdef ECHOCTL
		     | ECHOCTL
#endif
#ifdef ECHOKE
		     | ECHOKE
#endif
	);
#endif

    SET_TTY(STDERR_FILENO, &mode);
}

/*
 * Returns a "good" value for the erase character.  This is loosely based on
 * the BSD4.4 logic.
 */
#ifdef TERMIOS
static int
default_erase(void)
{
    int result;

    if (over_strike
	&& key_backspace != 0
	&& strlen(key_backspace) == 1)
	result = key_backspace[0];
    else
	result = CERASE;

    return result;
}
#endif

/*
 * Update the values of the erase, interrupt, and kill characters in 'mode'.
 *
 * SVr4 tset (e.g., Solaris 2.5) only modifies the intr, quit or erase
 * characters if they're unset, or if we specify them as options.  This differs
 * from BSD 4.4 tset, which always sets erase.
 */
static void
set_control_chars(void)
{
#ifdef TERMIOS
    if (DISABLED(mode.c_cc[VERASE]) || terasechar >= 0)
	mode.c_cc[VERASE] = (terasechar >= 0) ? terasechar : default_erase();

    if (DISABLED(mode.c_cc[VINTR]) || intrchar >= 0)
	mode.c_cc[VINTR] = (intrchar >= 0) ? intrchar : CINTR;

    if (DISABLED(mode.c_cc[VKILL]) || tkillchar >= 0)
	mode.c_cc[VKILL] = (tkillchar >= 0) ? tkillchar : CKILL;
#endif
}

/*
 * Set up various conversions in 'mode', including parity, tabs, returns,
 * echo, and case, according to the termcap entry.  If the program we're
 * running was named with a leading upper-case character, map external
 * uppercase to internal lowercase.
 */
static void
set_conversions(void)
{
#ifdef __OBSOLETE__
    /*
     * Conversion logic for some *really* ancient terminal glitches,
     * not supported in terminfo.  Left here for succeeding generations
     * to marvel at.
     */
    if (tgetflag("UC")) {
#ifdef IUCLC
	mode.c_iflag |= IUCLC;
	mode.c_oflag |= OLCUC;
#endif
    } else if (tgetflag("LC")) {
#ifdef IUCLC
	mode.c_iflag &= ~IUCLC;
	mode.c_oflag &= ~OLCUC;
#endif
    }
    mode.c_iflag &= ~(PARMRK | INPCK);
    mode.c_lflag |= ICANON;
    if (tgetflag("EP")) {
	mode.c_cflag |= PARENB;
	mode.c_cflag &= ~PARODD;
    }
    if (tgetflag("OP")) {
	mode.c_cflag |= PARENB;
	mode.c_cflag |= PARODD;
    }
#endif /* __OBSOLETE__ */

#ifdef TERMIOS
#ifdef ONLCR
    mode.c_oflag |= ONLCR;
#endif
    mode.c_iflag |= ICRNL;
    mode.c_lflag |= ECHO;
#ifdef OXTABS
    mode.c_oflag |= OXTABS;
#endif /* OXTABS */

    /* test used to be tgetflag("NL") */
    if (newline != (char *) 0 && newline[0] == '\n' && !newline[1]) {
	/* Newline, not linefeed. */
#ifdef ONLCR
	mode.c_oflag &= ~ONLCR;
#endif
	mode.c_iflag &= ~ICRNL;
    }
#ifdef __OBSOLETE__
    if (tgetflag("HD"))		/* Half duplex. */
	mode.c_lflag &= ~ECHO;
#endif /* __OBSOLETE__ */
#ifdef OXTABS
    /* test used to be tgetflag("pt") */
    if (has_hardware_tabs)	/* Print tabs. */
	mode.c_oflag &= ~OXTABS;
#endif /* OXTABS */
    mode.c_lflag |= (ECHOE | ECHOK);
#endif
}

/* Output startup string. */
static void
set_init(void)
{
    char *p;
    bool settle;

#ifdef __OBSOLETE__
    if (pad_char != (char *) 0)	/* Get/set pad character. */
	PC = pad_char[0];
#endif /* OBSOLETE */

#ifdef TAB3
    if (oldmode.c_oflag & (TAB3 | ONLCR | OCRNL | ONLRET)) {
	oldmode.c_oflag &= (TAB3 | ONLCR | OCRNL | ONLRET);
	SET_TTY(STDERR_FILENO, &oldmode);
    }
#endif
    settle = set_tabs();

    if (isreset) {
	if ((p = reset_1string) != 0) {
	    tputs(p, 0, outc);
	    settle = TRUE;
	}
	if ((p = reset_2string) != 0) {
	    tputs(p, 0, outc);
	    settle = TRUE;
	}
	/* What about rf, rs3, as per terminfo man page? */
	/* also might be nice to send rmacs, rmul, rmm */
	if ((p = reset_file) != 0
	    || (p = init_file) != 0) {
	    cat(p);
	    settle = TRUE;
	}
    }

    if (settle) {
	(void) putc('\r', stderr);
	(void) fflush(stderr);
	(void) napms(1000);	/* Settle the terminal. */
    }
}

/*
 * Set the hardware tabs on the terminal, using the ct (clear all tabs),
 * st (set one tab) and ch (horizontal cursor addressing) capabilities.
 * This is done before if and is, so they can patch in case we blow this.
 * Return TRUE if we set any tab stops, FALSE if not.
 */
static bool
set_tabs(void)
{
    if (set_tab && clear_all_tabs) {
	int c;

	(void) putc('\r', stderr);	/* Force to left margin. */
	tputs(clear_all_tabs, 0, outc);

	for (c = 8; c < tcolumns; c += 8) {
	    /* Get to the right column.  In BSD tset, this
	     * used to try a bunch of half-clever things
	     * with cup and hpa, for an average saving of
	     * somewhat less than two character times per
	     * tab stop, less than .01 sec at 2400cps. We
	     * lost all this cruft because it seemed to be
	     * introducing some odd bugs.
	     * -----------12345678----------- */
	    (void) fputs("        ", stderr);
	    tputs(set_tab, 0, outc);
	}
	putc('\r', stderr);
	return (TRUE);
    }
    return (FALSE);
}

/**************************************************************************
 *
 * Main sequence
 *
 **************************************************************************/

/*
 * Tell the user if a control key has been changed from the default value.
 */
#ifdef TERMIOS
static void
report(const char *name, int which, unsigned def)
{
    unsigned older, newer;
    char *p;

    newer = mode.c_cc[which];
    older = oldmode.c_cc[which];

    if (older == newer && older == def)
	return;

    (void) fprintf(stderr, "%s %s ", name, older == newer ? "is" : "set to");

    if (DISABLED(newer))
	(void) fprintf(stderr, "undef.\n");
    /*
     * Check 'delete' before 'backspace', since the key_backspace value
     * is ambiguous.
     */
    else if (newer == 0177)
	(void) fprintf(stderr, "delete.\n");
    else if ((p = key_backspace) != 0
	     && newer == (unsigned char) p[0]
	     && p[1] == '\0')
	(void) fprintf(stderr, "backspace.\n");
    else if (newer < 040) {
	newer ^= 0100;
	(void) fprintf(stderr, "control-%c (^%c).\n", UChar(newer), UChar(newer));
    } else
	(void) fprintf(stderr, "%c.\n", UChar(newer));
}
#endif

/*
 * Convert the obsolete argument forms into something that getopt can handle.
 * This means that -e, -i and -k get default arguments supplied for them.
 */
static void
obsolete(char **argv)
{
    for (; *argv; ++argv) {
	char *parm = argv[0];

	if (parm[0] == '-' && parm[1] == '\0') {
	    argv[0] = strdup("-q");
	    continue;
	}

	if ((parm[0] != '-')
	    || (argv[1] && argv[1][0] != '-')
	    || (parm[1] != 'e' && parm[1] != 'i' && parm[1] != 'k')
	    || (parm[2] != '\0'))
	    continue;
	switch (argv[0][1]) {
	case 'e':
	    argv[0] = strdup("-e^H");
	    break;
	case 'i':
	    argv[0] = strdup("-i^C");
	    break;
	case 'k':
	    argv[0] = strdup("-k^U");
	    break;
	}
    }
}

static void
usage(void)
{
    static const char *tbl[] =
    {
	""
	,"Options:"
	,"  -c          set control characters"
	,"  -e ch       erase character"
	,"  -I          no initialization strings"
	,"  -i ch       interrupt character"
	,"  -k ch       kill character"
	,"  -m mapping  map identifier to type"
	,"  -Q          do not output control key settings"
	,"  -r          display term on stderr"
	,"  -s          output TERM set command"
	,"  -V          print curses-version"
	,"  -w          set window-size"
    };
    unsigned n;
    (void) fprintf(stderr, "Usage: %s [-cIQqrsVw] [-] "
	"[-e ch] [-i ch] [-k ch] [-m mapping] [terminal]\n",
	_nc_progname);
    for (n = 0; n < sizeof(tbl) / sizeof(tbl[0]); ++n)
	fprintf(stderr, "%s\n", tbl[n]);

    exit_error();
    /* NOTREACHED */
}

static char
arg_to_char(void)
{
    return (char) ((optarg[0] == '^' && optarg[1] != '\0')
		   ? ((optarg[1] == '?') ? '\177' : CTRL(optarg[1]))
		   : optarg[0]);
}

int
main(int argc, char **argv)
{
    int ch, noinit, noset, quiet, Sflag, sflag, showterm;
    const char *p;
    const char *ttype;

    if (pledge("stdio rpath wpath tty", NULL) == -1)
	err("pledge: %s", strerror(errno));

    obsolete(argv);
    noinit = noset = quiet = Sflag = sflag = showterm = 0;
    while ((ch = getopt(argc, argv, "a:cd:e:Ii:k:m:np:qQSrsVw")) != -1) {
	switch (ch) {
	case 'c':		/* set control-chars */
	    opt_c = TRUE;
	    break;
	case 'a':		/* OBSOLETE: map identifier to type */
	    add_mapping("arpanet", optarg);
	    break;
	case 'd':		/* OBSOLETE: map identifier to type */
	    add_mapping("dialup", optarg);
	    break;
	case 'e':		/* erase character */
	    terasechar = arg_to_char();
	    break;
	case 'I':		/* no initialization strings */
	    noinit = 1;
	    break;
	case 'i':		/* interrupt character */
	    intrchar = arg_to_char();
	    break;
	case 'k':		/* kill character */
	    tkillchar = arg_to_char();
	    break;
	case 'm':		/* map identifier to type */
	    add_mapping(0, optarg);
	    break;
	case 'n':		/* OBSOLETE: set new tty driver */
	    break;
	case 'p':		/* OBSOLETE: map identifier to type */
	    add_mapping("plugboard", optarg);
	    break;
	case 'Q':		/* don't output control key settings */
	    quiet = 1;
	    break;
	case 'q':		/* display term only */
	    noset = 1;
	    break;
	case 'r':		/* display term on stderr */
	    showterm = 1;
	    break;
	case 'S':		/* OBSOLETE: output TERM & TERMCAP */
	    Sflag = 1;
	    break;
	case 's':		/* output TERM set command */
	    sflag = 1;
	    break;
	case 'V':		/* print curses-version */
	    puts(curses_version());
	    ExitProgram(EXIT_SUCCESS);
	case 'w':		/* set window-size */
	    opt_w = TRUE;
	    break;
	case '?':
	default:
	    usage();
	}
    }

    _nc_progname = _nc_rootname(*argv);
    argc -= optind;
    argv += optind;

    if (argc > 1)
	usage();

    if (!opt_c && !opt_w)
	opt_c = opt_w = TRUE;

    if (GET_TTY(STDERR_FILENO, &mode) < 0)
	failed("standard error");
    can_restore = TRUE;
    original = oldmode = mode;
#ifdef TERMIOS
    ospeed = (NCURSES_OSPEED) cfgetospeed(&mode);
#else
    ospeed = (NCURSES_OSPEED) mode.sg_ospeed;
#endif

    if (!strcmp(_nc_progname, PROG_RESET)) {
	isreset = TRUE;
	reset_mode();
    }

    ttype = get_termcap_entry(*argv);

    if (!noset) {
	tcolumns = columns;
	tlines = lines;

#if HAVE_SIZECHANGE
	if (opt_w) {
	    struct winsize win;
	    /* Set window size if not set already */
	    (void) ioctl(STDERR_FILENO, TIOCGWINSZ, &win);
	    if (win.ws_row == 0 &&
		win.ws_col == 0 &&
		tlines > 0 && tcolumns > 0) {
		win.ws_row = tlines;
		win.ws_col = tcolumns;
		(void) ioctl(STDERR_FILENO, TIOCSWINSZ, &win);
	    }
	}
#endif
	if (opt_c) {
	    set_control_chars();
	    set_conversions();

	    if (!noinit)
		set_init();

	    /* Set the modes if they've changed. */
	    if (memcmp(&mode, &oldmode, sizeof(mode))) {
		SET_TTY(STDERR_FILENO, &mode);
	    }
	}
    }

    /* Get the terminal name from the entry. */
    ttype = _nc_first_name(cur_term->type.term_names);

    if (noset)
	(void) printf("%s\n", ttype);
    else {
	if (showterm)
	    (void) fprintf(stderr, "Terminal type is %s.\n", ttype);
	/*
	 * If erase, kill and interrupt characters could have been
	 * modified and not -Q, display the changes.
	 */
#ifdef TERMIOS
	if (!quiet) {
	    report("Erase", VERASE, CERASE);
	    report("Kill", VKILL, CKILL);
	    report("Interrupt", VINTR, CINTR);
	}
#endif
    }

    if (Sflag)
	err("The -S option is not supported under terminfo.");

    if (sflag) {
	int len;
	char *var;
	char *leaf;
	/*
	 * Figure out what shell we're using.  A hack, we look for an
	 * environmental variable SHELL ending in "csh".
	 */
	if ((var = getenv("SHELL")) != 0
	    && ((len = (int) strlen(leaf = _nc_basename(var))) >= 3)
	    && !strcmp(leaf + len - 3, "csh"))
	    p = "set noglob;\nsetenv TERM %s;\nunset noglob;\n";
	else
	    p = "TERM=%s;\n";
	(void) printf(p, ttype);
    }

    ExitProgram(EXIT_SUCCESS);
}
@


1.38
log
@Simplify TIOCGWINSZ codeblock by removing support for SCO Unix.
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.37 2015/08/20 22:28:58 deraadt Exp $	*/
d1138 3
@


1.37
log
@Do not need to cast malloc().  stdlib.h is brought in via a local .h file.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.36 2013/09/18 16:21:30 millert Exp $	*/
a107 22
MODULE_ID("$Id: tset.c,v 1.36 2013/09/18 16:21:30 millert Exp $")

/*
 * SCO defines TIOCGSIZE and the corresponding struct.  Other systems (SunOS,
 * Solaris, IRIX) define TIOCGWINSZ and struct winsize.
 */
#ifdef TIOCGSIZE
# define IOCTL_GET_WINSIZE TIOCGSIZE
# define IOCTL_SET_WINSIZE TIOCSSIZE
# define STRUCT_WINSIZE struct ttysize
# define WINSIZE_ROWS(n) n.ts_lines
# define WINSIZE_COLS(n) n.ts_cols
#else
# ifdef TIOCGWINSZ
#  define IOCTL_GET_WINSIZE TIOCGWINSZ
#  define IOCTL_SET_WINSIZE TIOCSWINSZ
#  define STRUCT_WINSIZE struct winsize
#  define WINSIZE_ROWS(n) n.ws_row
#  define WINSIZE_COLS(n) n.ws_col
# endif
#endif

d1232 1
a1232 1
	    STRUCT_WINSIZE win;
d1234 3
a1236 3
	    (void) ioctl(STDERR_FILENO, IOCTL_GET_WINSIZE, &win);
	    if (WINSIZE_ROWS(win) == 0 &&
		WINSIZE_COLS(win) == 0 &&
d1238 3
a1240 3
		WINSIZE_ROWS(win) = tlines;
		WINSIZE_COLS(win) = tcolumns;
		(void) ioctl(STDERR_FILENO, IOCTL_SET_WINSIZE, &win);
@


1.36
log
@Remove "tset -S" compatibility I added years ago.  Most converted
terminfo entries for most terminals are too large to fit within the
1023 bytes allowed for termcap.  We're better off without it.
OK espie@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.35 2010/01/12 23:22:14 nicm Exp $	*/
d108 1
a108 1
MODULE_ID("$Id: tset.c,v 1.35 2010/01/12 23:22:14 nicm Exp $")
d376 1
a376 1
    mapp = (MAP *) malloc(sizeof(MAP));
@


1.35
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.34 2009/11/11 23:49:01 nicm Exp $	*/
d108 1
a108 1
MODULE_ID("$Id: tset.c,v 1.76 2008/10/11 19:26:19 tom Exp $")
d1136 1
a1136 1
    (void) fprintf(stderr, "Usage: %s [-cIQqrSsVw] [-] "
a1159 5
#ifdef __OpenBSD__
    char tcapbuf[1024], *t;
    int tcgetent(char *, const char *);
    void wrtermcap (char *);
#endif /* __OpenBSD__ */
a1246 4
#ifdef __OpenBSD__
    if (tcgetent(tcapbuf, ttype) < 0)
	    tcapbuf[0] = '\0';
#endif /* __OpenBSD__ */
a1300 9
#ifdef __OpenBSD__
    if (Sflag) {
	if (tcapbuf[0]) { 
	    (void) printf("%s ", ttype);
	    wrtermcap(tcapbuf);
	} else
	    err("No termcap entry for %s, only terminfo.", ttype);
    }
#else
a1302 1
#endif /* __OpenBSD__ */
a1303 35
#ifdef __OpenBSD__
    if (sflag) {
	/*
	 * Figure out what shell we're using.  A hack, we look for an
	 * environmental variable SHELL ending in "csh".
	 */
	if ((p = getenv("SHELL")) != 0 && !strcmp(p + strlen(p) - 3, "csh")) {
	    if (tcapbuf[0])
		p = "set noglob histchars="";\nsetenv TERM %s;\nsetenv TERMCAP ";
	    else
		p = "set noglob histchars="";\nsetenv TERM %s;\n";
		t = "unset noglob histchars;\n";
	} else {
	    if (tcapbuf) {
		p = "TERM=%s;\nTERMCAP=";
		t = "export TERMCAP TERM;\n";
	    } else {
		if (tcapbuf) {
		    p = "TERM=%s;\nTERMCAP=";
		    t = "export TERMCAP TERM;\n";
		} else {
		    p = "TERM=%s;\n";
		    t = "export TERMCAP;\n";
		}
	    }
	}
	(void) printf(p, ttype);
	if (tcapbuf[0]) {
	    putchar('\'');
	    wrtermcap(tcapbuf);
	    fputs("';\n", stdout);
	}
	(void)fputs(t, stdout);
    }
#else
a1319 1
#endif /* __OpenBSD__ */
@


1.34
log
@Fix memory leaks found by parfait.

ok deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.33 2009/05/06 21:07:01 sobrado Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *
d34 1
d74 1
d90 6
a95 3
/* this is just to stifle a missing-prototype warning */
#if defined(linux) || defined(__OpenBSD__)
# include <sys/ioctl.h>
d101 2
a102 2
#include	<sys/stream.h>
#include	<sys/ptem.h>
a104 1
#include <curses.h>		/* for bool typedef */
d108 21
a128 1
MODULE_ID("$From: tset.c,v 0.49 2001/02/24 23:29:33 tom Exp $")
d137 4
a140 1
static TTY mode, oldmode;
d142 1
d149 1
a149 1
#define LOWERCASE(c) ((isalpha(CharOf(c)) && isupper(CharOf(c))) ? tolower(CharOf(c)) : (c))
d164 11
d179 1
a179 1
    (void) fprintf(stderr, "tset: ");
d182 1
a182 2
    (void) fprintf(stderr, "\n");
    exit(EXIT_FAILURE);
d189 1
a189 1
    (void)fputs("tset: ", stderr);
d191 1
a191 1
    exit(EXIT_FAILURE);
d198 2
a199 1
    int fd, nr;
d202 1
a202 1
    if ((fd = open(file, O_RDONLY, 0)) < 0)
d205 4
a208 6
    while ((nr = read(fd, buf, sizeof(buf))) > 0)
	if (write(STDERR_FILENO, buf, (size_t) nr) == -1)
	    failed("write to stderr");
    if (nr != 0)
	failed(file);
    (void) close(fd);
d224 1
d227 2
a228 1
	exit(EXIT_FAILURE);
d239 2
a240 2
		(void) fprintf(stderr, "\n");
		exit(EXIT_FAILURE);
d376 1
a376 1
    mapp = malloc(sizeof(MAP));
d454 6
a459 3
  done:if (port) {
	if (mapp->porttype)
	  badmopt:err("illegal -m option format: %s", copy);
d576 1
a576 1
		    if (isspace(CharOf(*s)))
d604 1
a604 1
  found:if ((p = getenv("TERMCAP")) != 0 && *p != '/') {
d633 2
a634 2
	    (void) fprintf(stderr, "tset: unknown terminal type %s\n",
			   ttype);
d638 2
a639 2
			   "tset: can't initialize terminal type %s (error %d)\n",
			   ttype, errret);
d657 2
a658 1
 * one or more definitions. The safest solution is to override.
d660 1
d671 1
d674 1
d676 2
d679 2
d682 2
d685 2
d688 2
d691 2
d694 2
d697 2
d700 2
d703 1
d705 9
a713 1
#define	CHK(val, dft)	((int)val <= 0 ? dft : val)
d796 16
a811 1
		      | NLDLY | CRDLY | TABDLY | BSDLY | VTDLY | FFDLY
d845 1
a845 5
#ifdef TERMIOS
    tcsetattr(STDERR_FILENO, TCSADRAIN, &mode);
#else
    stty(STDERR_FILENO, &mode);
#endif
d880 2
a881 2
    if (mode.c_cc[VERASE] == 0 || terasechar >= 0)
	mode.c_cc[VERASE] = terasechar >= 0 ? terasechar : default_erase();
d883 2
a884 2
    if (mode.c_cc[VINTR] == 0 || intrchar >= 0)
	mode.c_cc[VINTR] = intrchar >= 0 ? intrchar : CINTR;
d886 2
a887 2
    if (mode.c_cc[VKILL] == 0 || tkillchar >= 0)
	mode.c_cc[VKILL] = tkillchar >= 0 ? tkillchar : CKILL;
d975 1
a975 1
	tcsetattr(STDERR_FILENO, TCSADRAIN, &oldmode);
d1025 1
a1025 1
	     * tab stop, less that .01 sec at 2400cps. We
d1028 1
a1028 1
	     * ----------12345678----------- */
d1049 1
a1049 1
report(const char *name, int which, unsigned int def)
d1051 1
a1051 1
    unsigned int older, newer;
d1062 2
d1068 1
a1068 1
    if (newer == 0177)
d1076 1
a1076 1
	(void) fprintf(stderr, "control-%c (^%c).\n", newer, newer);
d1078 1
a1078 1
	(void) fprintf(stderr, "%c.\n", newer);
d1117 1
a1117 1
usage(const char *pname)
d1119 25
a1143 4
    (void) fprintf(stderr, "usage: %s [-IQqrSsV] [-] "
		   "[-e ch] [-i ch] [-k ch] [-m mapping] [terminal]\n",
		   pname);
    exit(EXIT_FAILURE);
d1149 3
a1151 3
    return (optarg[0] == '^' && optarg[1] != '\0')
	? ((optarg[1] == '?') ? '\177' : CTRL(optarg[1]))
	: optarg[0];
a1156 3
#if defined(TIOCGWINSZ) && defined(TIOCSWINSZ)
    struct winsize win;
#endif
a1165 15
    if (GET_TTY(STDERR_FILENO, &mode) < 0)
	failed("standard error");
    oldmode = mode;
#ifdef TERMIOS
    ospeed = cfgetospeed(&mode);
#else
    ospeed = mode.sg_ospeed;
#endif

    p = _nc_basename(*argv);
    if (!strcmp(p, PROG_RESET)) {
	isreset = TRUE;
	reset_mode();
    }

d1168 1
a1168 1
    while ((ch = getopt(argc, argv, "a:d:e:Ii:k:m:np:qQSrsV")) != -1) {
d1170 2
a1171 2
	case 'q':		/* display term only */
	    noset = 1;
d1202 2
a1203 2
	case 'S':		/* OBSOLETE: output TERM & TERMCAP */
	    Sflag = 1;
d1208 3
d1214 1
a1214 1
	case 'V':
d1216 4
a1219 1
	    return EXIT_SUCCESS;
d1222 1
a1222 1
	    usage(*argv);
d1225 2
d1231 19
a1249 1
	usage(*argv);
d1261 12
a1272 8
#if defined(TIOCGWINSZ) && defined(TIOCSWINSZ)
	/* Set window size */
	(void) ioctl(STDERR_FILENO, TIOCGWINSZ, &win);
	if (win.ws_row == 0 && win.ws_col == 0 &&
	    tlines > 0 && tcolumns > 0) {
	    win.ws_row = tlines;
	    win.ws_col = tcolumns;
	    (void) ioctl(STDERR_FILENO, TIOCSWINSZ, &win);
d1275 11
a1285 13
	set_control_chars();
	set_conversions();

	if (!noinit)
	    set_init();

	/* Set the modes if they've changed. */
	if (memcmp(&mode, &oldmode, sizeof(mode))) {
#ifdef TERMIOS
	    tcsetattr(STDERR_FILENO, TCSADRAIN, &mode);
#else
	    stty(STDERR_FILENO, &mode);
#endif
d1304 2
a1305 2
	    report("Kill", VKILL, CINTR);
	    report("Interrupt", VINTR, CKILL);
d1318 1
a1318 1
#else           
d1359 3
d1366 3
a1368 2
	if ((p = getenv("SHELL")) != 0
	    && !strcmp(p + strlen(p) - 3, "csh"))
d1376 1
a1376 1
    return EXIT_SUCCESS;
a1377 2

/* tset.c ends here */
@


1.33
log
@add missing flags to the output of usage() and sort them as usual
in BSD operating systems; while here, indent source code in a way it
fits on 80-column displays.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.32 2007/10/15 02:16:35 deraadt Exp $	*/
d420 1
@


1.32
log
@specifying int instead of just unsigned is better style
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.31 2007/09/14 14:29:20 chl Exp $	*/
d1032 3
a1034 2
    (void) fprintf(stderr,
		   "usage: %s [-IQVrs] [-] [-e ch] [-i ch] [-k ch] [-m mapping] [terminal]\n", pname);
@


1.31
log
@remove some warnings:
unused variable `variable'
`variable' might be used uninitialized in this function

ok gilles@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.30 2007/09/11 15:47:17 gilles Exp $	*/
d964 1
a964 1
report(const char *name, int which, unsigned def)
d966 1
a966 1
    unsigned older, newer;
@


1.30
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.29 2007/02/20 01:52:01 ray Exp $	*/
a184 1
    char *p;
@


1.29
log
@Change hard coded numbers to sizeof(buf).  Also change some
sizeof(buf) - 1 to sizeof(buf), since fgets takes the whole buffer size.

Based on diff from Charles Longeau <chl at tuxfamily dot org> long ago.

OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.28 2006/10/10 21:38:16 cloder Exp $	*/
d207 1
a207 2
	if ((p = strchr(answer, '\n')) != 0)
	    *p = '\0';
@


1.28
log
@fgets(3) returns NULL on error, not 0. No functional change, but it makes
the code easier to read.
OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.27 2003/06/12 20:58:11 deraadt Exp $	*/
d533 1
a533 1
	    while (fgets(buffer, sizeof(buffer) - 1, fp) != NULL) {
@


1.27
log
@de-register and ansification; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.26 2003/06/03 02:56:20 millert Exp $	*/
d199 1
a199 1
	if (fgets(answer, sizeof(answer), stdin) == 0) {
d533 1
a533 1
	    while (fgets(buffer, sizeof(buffer) - 1, fp) != 0) {
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.25 2001/11/19 19:02:17 mpech Exp $	*/
d929 1
a929 1
set_tabs()
@


1.25
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.24 2001/07/16 06:14:31 pvalchev Exp $	*/
d56 1
a56 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.24
log
@-Wall cleanup; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.23 2001/02/28 22:58:52 millert Exp $	*/
d164 1
a164 1
    register int fd, nr;
@


1.23
log
@ncurses-5.2-20010224
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.22 2001/01/29 01:58:24 niklas Exp $	*/
d93 1
a93 1
#ifdef linux
@


1.22
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d108 1
a108 1
MODULE_ID("$From: tset.c,v 0.48 2000/11/04 22:50:15 tom Exp $")
d164 1
a164 1
    register int fd, nr, nw;
d171 1
a171 1
	if ((nw = write(STDERR_FILENO, buf, (size_t) nr)) == -1)
d500 1
a500 1
    int rval, errret;
d593 2
a594 2
    while ((rval = setupterm((NCURSES_CONST char *) ttype, STDOUT_FILENO,
			     &errret)) != OK) {
@


1.21
log
@Update to ncurses-5.2-20010114
@
text
@d1 2
@


1.20
log
@update to ncurses-5.1-20001007
@
text
@d106 1
a106 1
MODULE_ID("$From: tset.c,v 0.47 2000/10/08 01:01:08 tom Exp $")
d123 1
a123 1
#define LOWERCASE(c) ((isalpha(c) && isupper(c)) ? tolower(c) : (c))
d537 1
a537 1
		    if (isspace(*s))
@


1.19
log
@Update to ncurses-5.1-20000722
@
text
@d104 1
d106 1
a106 1
MODULE_ID("$From: tset.c,v 0.42 2000/07/09 23:17:34 tom Exp $")
d117 1
a119 1
static int isreset;		/* invoked as reset */
d237 1
a237 1
    speed_t speed;		/* Baud rate to compare against. */
d518 1
a518 4
	if ((p = strrchr(ttypath, '/')) != 0)
	    ++p;
	else
	    p = ttypath;
d592 1
a592 1
		&errret)) != OK) {
d595 1
a595 1
		ttype);
d599 2
a600 2
		"tset: can't initialize terminal type %s (error %d)\n",
		ttype, errret);
d693 1
a693 1
	| IUCLC
d696 1
a696 1
	| IXANY
d698 1
a698 1
	| IXOFF);
d702 1
a702 1
	| IMAXBEL
d708 1
a708 1
	| OLCUC
d711 1
a711 1
	| OCRNL
d714 1
a714 1
	| ONOCR
d717 1
a717 1
	| ONLRET
d720 1
a720 1
	| OFILL
d723 1
a723 1
	| OFDEL
d726 1
a726 1
	| NLDLY | CRDLY | TABDLY | BSDLY | VTDLY | FFDLY
d732 1
a732 1
	| ONLCR
d740 1
a740 1
	| TOSTOP
d743 1
a743 1
	| ECHOPRT
d746 1
a746 1
	| XCASE
d752 1
a752 1
	| ECHOCTL
d755 1
a755 1
	| ECHOKE
d988 2
a989 2
	    && newer == (unsigned char) p[0]
	&& p[1] == '\0')
d1037 1
a1037 1
	"usage: %s [-IQrs] [-] [-e ch] [-i ch] [-k ch] [-m mapping] [terminal]\n", pname);
d1073 3
a1075 6
    if ((p = strrchr(*argv, '/')) != 0)
	++p;
    else
	p = *argv;
    if (!CaselessCmp(p, "reset")) {
	isreset = 1;
d1081 1
a1081 1
    while ((ch = getopt(argc, argv, "a:d:e:Ii:k:m:np:qQSrs")) != -1) {
d1124 3
@


1.18
log
@avoid non-formatter printf, use fputs
@
text
@d105 1
a105 1
MODULE_ID("$From: tset.c,v 0.41 2000/03/12 00:03:00 tom Exp $")
d263 2
d266 2
d269 2
d272 2
d275 1
d773 1
d788 1
d968 1
a971 1
#ifdef TERMIOS
d998 1
a999 1
}
d1066 1
a1066 2
#ifdef TERMIOS
    if (tcgetattr(STDERR_FILENO, &mode) < 0)
a1067 1

d1069 1
a1071 4
    if (gtty(STDERR_FILENO, &mode) < 0)
	failed("standard error");

    oldmode = mode;
d1188 1
d1194 1
@


1.17
log
@update to ncurses-5.0-20000311
@
text
@d1234 1
a1234 1
	(void)printf(t);
@


1.16
log
@Update to ncurses-5.0-20000304
@
text
@d105 1
a105 1
MODULE_ID("$From: tset.c,v 0.40 2000/03/05 04:37:53 tom Exp $")
d358 1
a358 1
    for (;; ++arg)		/* Optional conditionals. */
d380 1
d382 2
a383 1
  next:if (*arg == ':') {
d585 1
a585 1
	&errret)) != OK) {
d1161 1
a1161 1
	if (memcmp(&mode, &oldmode, sizeof(mode)))
d1167 1
@


1.15
log
@Avoid an oflow in failed().  There's really no need to make a temporary
copy of the string since we are just printing to stderr.
@
text
@d2 1
a2 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
a33 1

d102 1
a102 1
#include <curses.h>	/* for bool typedef */
d105 1
a105 1
MODULE_ID("$From: tset.c,v 0.37 1999/03/14 12:30:02 tom Exp $")
d116 5
a120 5
static int	terasechar = -1;	/* new erase character */
static int	intrchar = -1;		/* new interrupt character */
static int	isreset;		/* invoked as reset */
static int	tkillchar = -1;		/* new kill character */
static int	tlines, tcolumns;		/* window size */
d125 9
a133 9
CaselessCmp(const char *a, const char *b) /* strcasecmp isn't portable */
{
	while (*a && *b) {
		int cmp = LOWERCASE(*a) - LOWERCASE(*b);
		if (cmp != 0)
			break;
		a++, b++;
	}
	return LOWERCASE(*a) - LOWERCASE(*b);
a135 5
#if !HAVE_STRDUP
#define strdup _nc_strdup
extern char *_nc_strdup(const char *);
#endif /* not HAVE_STRDUP */

d137 1
a137 1
err(const char *fmt, ...)
d139 8
a146 8
	va_list ap;
	va_start(ap, fmt);
	(void)fprintf(stderr, "tset: ");
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fprintf(stderr, "\n");
	exit(EXIT_FAILURE);
	/* NOTREACHED */
d152 4
a155 4
	(void)fputs("tset: ", stderr);
	perror(msg);
	exit(EXIT_FAILURE);
	/* NOTREACHED */
d161 2
a162 2
	register int fd, nr, nw;
	char buf[BUFSIZ];
d164 2
a165 2
	if ((fd = open(file, O_RDONLY, 0)) < 0)
		failed(file);
d167 6
a172 6
	while ((nr = read(fd, buf, sizeof(buf))) > 0)
		if ((nw = write(STDERR_FILENO, buf, (size_t)nr)) == -1)
			failed("write to stderr");
	if (nr != 0)
		failed(file);
	(void)close(fd);
d178 1
a178 1
	return putc(c, stderr);
d185 2
a186 2
	static char answer[256];
	char *p;
d188 15
a202 3
	/* We can get recalled; if so, don't continue uselessly. */
	if (feof(stdin) || ferror(stdin)) {
		(void)fprintf(stderr, "\n");
d204 2
a206 14
	for (;;) {
		if (dflt)
			(void)fprintf(stderr, "Terminal type? [%s] ", dflt);
		else
			(void)fprintf(stderr, "Terminal type? ");
		(void)fflush(stderr);

		if (fgets(answer, sizeof(answer), stdin) == 0) {
			if (dflt == 0) {
				(void)fprintf(stderr, "\n");
				exit(EXIT_FAILURE);
			}
			return (dflt);
		}
d208 7
a214 7
		if ((p = strchr(answer, '\n')) != 0)
			*p = '\0';
		if (answer[0])
			return (answer);
		if (dflt != 0)
			return (dflt);
	}
d232 5
a236 5
	struct map *next;	/* Linked list of maps. */
	const char *porttype;	/* Port type, or "" for any. */
	const char *type;	/* Terminal type to select. */
	int conditional;	/* Baud rate conditionals bitmask. */
	speed_t speed;		/* Baud rate to compare against. */
d242 2
a243 2
	const char *string;
	int	speed;
d246 21
a266 20
static const SPEEDS speeds[] = {
	{ "0",		B0 },
	{ "50",		B50 },
	{ "75",		B75 },
	{ "110",	B110 },
	{ "134",	B134 },
	{ "134.5",	B134 },
	{ "150",	B150 },
	{ "200",	B200 },
	{ "300",	B300 },
	{ "600",	B600 },
	{ "1200",	B1200 },
	{ "1800",	B1800 },
	{ "2400",	B2400 },
	{ "4800",	B4800 },
	{ "9600",	B9600 },
	{ "19200",	B19200 },
	{ "38400",	B38400 },
	{ "19200",	B19200 },
	{ "38400",	B38400 },
d268 1
a268 1
	{ "19200",	B19200 },
d271 1
a271 1
	{ "19200",	EXTA },
d275 1
a275 1
	{ "38400",	B38400 },
d278 1
a278 1
	{ "38400",	EXTB },
d282 1
a282 1
	{ "57600",	B57600 },
d285 1
a285 1
	{ "115200",	B115200 },
d288 1
a288 1
	{ "230400",	B230400 },
d291 1
a291 1
	{ "460800",	B460800 },
d293 1
a293 1
	{ (char *)0,    0 }
d299 2
a300 2
	const SPEEDS *sp;
	int found = FALSE;
d302 13
a314 13
	/* The baudrate number can be preceded by a 'B', which is ignored. */
	if (*rate == 'B')
		++rate;

	for (sp = speeds; sp->string; ++sp) {
		if (!CaselessCmp(rate, sp->string)) {
			found = TRUE;
			break;
		}
	}
	if (!found)
		err("unknown baud rate %s", rate);
	return (sp->speed);
d325 42
a366 69
	MAP *mapp;
	char *copy, *p;
	const char *termp;
	char *base = 0;

	copy = strdup(arg);
	mapp = malloc(sizeof(MAP));
	if (copy == 0 || mapp == 0)
		failed("malloc");
	mapp->next = 0;
	if (maplist == 0)
		cur = maplist = mapp;
	else {
		cur->next = mapp;
		cur =  mapp;
	}

	mapp->porttype = arg;
	mapp->conditional = 0;

	arg = strpbrk(arg, "><@@=!:");

	if (arg == 0) {			/* [?]term */
		mapp->type = mapp->porttype;
		mapp->porttype = 0;
		goto done;
	}

	if (arg == mapp->porttype)		/* [><@@=! baud]:term */
		termp = mapp->porttype = 0;
	else
		termp = base = arg;

	for (;; ++arg)				/* Optional conditionals. */
		switch(*arg) {
		case '<':
			if (mapp->conditional & GT)
				goto badmopt;
			mapp->conditional |= LT;
			break;
		case '>':
			if (mapp->conditional & LT)
				goto badmopt;
			mapp->conditional |= GT;
			break;
		case '@@':
		case '=':			/* Not documented. */
			mapp->conditional |= EQ;
			break;
		case '!':
			mapp->conditional |= NOT;
			break;
		default:
			goto next;
		}

next:	if (*arg == ':') {
		if (mapp->conditional)
			goto badmopt;
		++arg;
	} else {				/* Optional baudrate. */
		arg = strchr(p = arg, ':');
		if (arg == 0)
			goto badmopt;
		*arg++ = '\0';
		mapp->speed = tbaudrate(p);
	}

	if (arg == (char *)0)		/* Non-optional type. */
d368 44
a411 18

	mapp->type = arg;

	/* Terminate porttype, if specified. */
	if (termp != 0)
		*base = '\0';

	/* If a NOT conditional, reverse the test. */
	if (mapp->conditional & NOT)
		mapp->conditional = ~mapp->conditional & (EQ | GT | LT);

	/* If user specified a port with an option flag, set it. */
done:	if (port) {
		if (mapp->porttype)
badmopt:		err("illegal -m option format: %s", copy);
		mapp->porttype = port;
	}

d413 15
a427 15
	(void)printf("port: %s\n", mapp->porttype ? mapp->porttype : "ANY");
	(void)printf("type: %s\n", mapp->type);
	(void)printf("conditional: ");
	p = "";
	if (mapp->conditional & GT) {
		(void)printf("GT");
		p = "/";
	}
	if (mapp->conditional & EQ) {
		(void)printf("%sEQ", p);
		p = "/";
	}
	if (mapp->conditional & LT)
		(void)printf("%sLT", p);
	(void)printf("\nspeed: %d\n", mapp->speed);
d439 2
a440 2
	MAP *mapp;
	int match;
d442 29
a470 29
	for (mapp = maplist; mapp; mapp = mapp->next)
		if (mapp->porttype == 0 || !strcmp(mapp->porttype, type)) {
			switch (mapp->conditional) {
			case 0:			/* No test specified. */
				match = TRUE;
				break;
			case EQ:
				match = (ospeed == mapp->speed);
				break;
			case GE:
				match = (ospeed >= mapp->speed);
				break;
			case GT:
				match = (ospeed > mapp->speed);
				break;
			case LE:
				match = (ospeed <= mapp->speed);
				break;
			case LT:
				match = (ospeed < mapp->speed);
				break;
			default:
				match = FALSE;
			}
			if (match)
				return (mapp->type);
		}
	/* No match found; return given type. */
	return (type);
d486 3
a488 3
	int rval, errret;
	char *p;
	const char *ttype;
d490 1
a490 1
	struct ttyent *t;
d492 1
a492 1
	FILE *fp;
d494 1
a494 1
	char *ttypath;
d496 23
a518 3
	if (userarg) {
		ttype = userarg;
		goto found;
d520 14
a533 19

	/* Try the environment. */
	if ((ttype = getenv("TERM")) != 0)
		goto map;

	if ((ttypath = ttyname(STDERR_FILENO)) != 0) {
		if ((p = strrchr(ttypath, '/')) != 0)
			++p;
		else
			p = ttypath;
#if HAVE_GETTTYNAM
		/*
		 * We have the 4.3BSD library call getttynam(3); that means
		 * there's an /etc/ttys to look up device-to-type mappings in.
		 * Try ttyname(3); check for dialup or other mapping.
		 */
		if ((t = getttynam(p))) {
			ttype = t->ty_type;
			goto map;
d535 4
a538 22
#else
		if ((fp = fopen("/etc/ttytype", "r")) != 0
		 || (fp = fopen("/etc/ttys", "r")) != 0) {
			char buffer[BUFSIZ];
			char *s, *t, *d;

			while (fgets(buffer, sizeof(buffer)-1, fp) != 0) {
				for (s = buffer, t = d = 0; *s; s++) {
					if (isspace(*s))
						*s = '\0';
					else if (t == 0)
						t = s;
					else if (d == 0 && s != buffer && s[-1] == '\0')
						d = s;
				}
				if (t != 0 && d != 0 && !strcmp(d,p)) {
					ttype = strdup(t);
					fclose(fp);
					goto map;
				}
			}
			fclose(fp);
d540 3
d544 1
a544 1
	}
d546 2
a547 2
	/* If still undefined, use "unknown". */
	ttype = "unknown";
d549 1
a549 1
map:	ttype = mapped(ttype);
d551 8
a558 4
	/*
	 * If not a path, remove TERMCAP from the environment so we get a
	 * real entry from /etc/termcap.  This prevents us from being fooled
	 * by out of date stuff in the environment.
d560 5
a564 12
found:	if ((p = getenv("TERMCAP")) != 0 && *p != '/') {
		/* 'unsetenv("TERMCAP")' is not portable.
		 * The 'environ' array is better.
		 */
		int n;
		for (n = 0; environ[n] != 0; n++) {
			if (!strncmp("TERMCAP=", environ[n], 8)) {
				while ((environ[n] = environ[n+1]) != 0) {
					n++;
				}
				break;
			}
d566 2
d569 1
d571 22
a592 22
	/*
	 * ttype now contains a pointer to the type of the terminal.
	 * If the first character is '?', ask the user.
	 */
	if (ttype[0] == '?') {
		if (ttype[1] != '\0')
			ttype = askuser(ttype + 1);
		else
			ttype = askuser(0);
	}
	/* Find the terminfo entry.  If it doesn't exist, ask the user. */
	while ((rval = setupterm((NCURSES_CONST char *)ttype, STDOUT_FILENO, &errret)) != OK) {
		if (errret == 0) {
			(void)fprintf(stderr, "tset: unknown terminal type %s\n",
			    ttype);
			ttype = 0;
		}
		else {
			(void)fprintf(stderr, "tset: can't initialize terminal type %s (error %d)\n", ttype, errret);
			ttype = 0;
		}
		ttype = askuser(ttype);
d594 2
d597 1
a597 1
	tgetflag("am");	/* force lib_termcap.o to be linked for 'ospeed' */
d599 1
a599 1
	return (ttype);
d636 1
a636 1
static bool	set_tabs (void);
d646 1
a646 1
	tcgetattr(STDERR_FILENO, &mode);
d648 1
a648 1
	stty(STDERR_FILENO,&mode);
d653 1
a653 1
	mode.c_cc[VDISCARD] = CHK(mode.c_cc[VDISCARD], CDISCARD);
d655 2
a656 2
	mode.c_cc[VEOF] = CHK(mode.c_cc[VEOF], CEOF);
	mode.c_cc[VERASE] = CHK(mode.c_cc[VERASE], CERASE);
d658 1
a658 1
	mode.c_cc[VFLUSH] = CHK(mode.c_cc[VFLUSH], CFLUSH);
d660 2
a661 2
	mode.c_cc[VINTR] = CHK(mode.c_cc[VINTR], CINTR);
	mode.c_cc[VKILL] = CHK(mode.c_cc[VKILL], CKILL);
d663 1
a663 1
	mode.c_cc[VLNEXT] = CHK(mode.c_cc[VLNEXT], CLNEXT);
d665 1
a665 1
	mode.c_cc[VQUIT] = CHK(mode.c_cc[VQUIT], CQUIT);
d667 1
a667 1
	mode.c_cc[VREPRINT] = CHK(mode.c_cc[VREPRINT], CRPRNT);
d670 1
a670 1
	mode.c_cc[VSTART] = CHK(mode.c_cc[VSTART], CSTART);
d673 1
a673 1
	mode.c_cc[VSTOP] = CHK(mode.c_cc[VSTOP], CSTOP);
d676 1
a676 1
	mode.c_cc[VSUSP] = CHK(mode.c_cc[VSUSP], CSUSP);
d679 1
a679 1
	mode.c_cc[VWERASE] = CHK(mode.c_cc[VWERASE], CWERASE);
d682 1
a682 1
	mode.c_iflag &= ~(IGNBRK | PARMRK | INPCK | ISTRIP | INLCR | IGNCR
d684 1
a684 1
			  | IUCLC
d687 1
a687 1
			  | IXANY
d689 1
a689 1
			  | IXOFF);
d691 1
a691 1
	mode.c_iflag |= (BRKINT | IGNPAR | ICRNL | IXON
d693 1
a693 1
			 | IMAXBEL
d695 1
a695 1
			 );
d697 1
a697 1
	mode.c_oflag &= ~(0
d699 1
a699 1
			  | OLCUC
d702 1
a702 1
			  | OCRNL
d705 1
a705 1
			  | ONOCR
d708 1
a708 1
			  | ONLRET
d711 1
a711 1
			  | OFILL
d714 1
a714 1
			  | OFDEL
d717 1
a717 1
			  | NLDLY | CRDLY | TABDLY | BSDLY | VTDLY | FFDLY
d719 1
a719 1
			  );
d721 1
a721 1
	mode.c_oflag |= (OPOST
d723 1
a723 1
			 | ONLCR
d725 1
a725 1
			 );
d727 3
a729 3
	mode.c_cflag &= ~(CSIZE | CSTOPB | PARENB | PARODD | CLOCAL);
	mode.c_cflag |= (CS8 | CREAD);
	mode.c_lflag &= ~(ECHONL | NOFLSH
d731 1
a731 1
			  | TOSTOP
d734 1
a734 1
			  | ECHOPRT
d737 1
a737 1
			  | XCASE
d739 1
a739 1
			  );
d741 1
a741 1
	mode.c_lflag |= (ISIG | ICANON | ECHO | ECHOE | ECHOK
d743 1
a743 1
			 | ECHOCTL
d746 1
a746 1
			 | ECHOKE
d748 1
a748 1
 			 );
d752 1
a752 1
	tcsetattr(STDERR_FILENO, TCSADRAIN, &mode);
d754 1
a754 1
	stty(STDERR_FILENO, &mode);
d765 1
a765 1
	int result;
d767 6
a772 6
	if (over_strike
	 && key_backspace != 0
	 && strlen(key_backspace) == 1)
		result = key_backspace[0];
	else
		result = CERASE;
d774 1
a774 1
	return result;
d788 2
a789 2
	if (mode.c_cc[VERASE] == 0 || terasechar >= 0)
		mode.c_cc[VERASE] = terasechar >= 0 ? terasechar : default_erase();
d791 2
a792 2
	if (mode.c_cc[VINTR] == 0 || intrchar >= 0)
		 mode.c_cc[VINTR] = intrchar >= 0 ? intrchar : CINTR;
d794 2
a795 2
	if (mode.c_cc[VKILL] == 0 || tkillchar >= 0)
		mode.c_cc[VKILL] = tkillchar >= 0 ? tkillchar : CKILL;
d809 6
a814 6
	/*
	 * Conversion logic for some *really* ancient terminal glitches,
	 * not supported in terminfo.  Left here for succeeding generations
	 * to marvel at.
	 */
	if (tgetflag("UC")) {
d816 2
a817 2
		mode.c_iflag |= IUCLC;
		mode.c_oflag |= OLCUC;
d819 1
a819 1
	} else if (tgetflag("LC")) {
d821 2
a822 2
		mode.c_iflag &= ~IUCLC;
		mode.c_oflag &= ~OLCUC;
d824 11
a834 11
	}
	mode.c_iflag &= ~(PARMRK | INPCK);
	mode.c_lflag |= ICANON;
	if (tgetflag("EP")) {
		mode.c_cflag |= PARENB;
		mode.c_cflag &= ~PARODD;
	}
	if (tgetflag("OP")) {
		mode.c_cflag |= PARENB;
		mode.c_cflag |= PARODD;
	}
d839 1
a839 1
	mode.c_oflag |= ONLCR;
d841 2
a842 2
	mode.c_iflag |= ICRNL;
	mode.c_lflag |= ECHO;
d844 1
a844 1
	mode.c_oflag |= OXTABS;
d847 3
a849 3
	/* test used to be tgetflag("NL") */
	if (newline != (char *)0 && newline[0] == '\n' && !newline[1]) {
		/* Newline, not linefeed. */
d851 1
a851 1
		mode.c_oflag &= ~ONLCR;
d853 2
a854 2
		mode.c_iflag &= ~ICRNL;
	}
d856 2
a857 2
	if (tgetflag("HD"))			/* Half duplex. */
		mode.c_lflag &= ~ECHO;
d860 3
a862 3
	/* test used to be tgetflag("pt") */
	if (has_hardware_tabs)			/* Print tabs. */
		mode.c_oflag &= ~OXTABS;
d864 1
a864 1
	mode.c_lflag |= (ECHOE | ECHOK);
d872 2
a873 2
	char	*p;
	bool settle;
d876 2
a877 2
	if (pad_char != (char *)0)		/* Get/set pad character. */
		PC = pad_char[0];
d881 30
a910 30
	if (oldmode.c_oflag & (TAB3 | ONLCR | OCRNL | ONLRET)) {
		oldmode.c_oflag &= (TAB3 | ONLCR | OCRNL | ONLRET);
		tcsetattr(STDERR_FILENO, TCSADRAIN, &oldmode);
	}
#endif
	settle = set_tabs();

	if (isreset) {
		if ((p = reset_1string) != 0) {
			tputs(p, 0, outc);
			settle = TRUE;
		}
		if ((p = reset_2string) != 0) {
			tputs(p, 0, outc);
			settle = TRUE;
		}
		/* What about rf, rs3, as per terminfo man page? */
		/* also might be nice to send rmacs, rmul, rmm */
		if ((p = reset_file) != 0
		 || (p = init_file) != 0) {
			cat(p);
			settle = TRUE;
		}
	}

	if (settle) {
		(void)putc('\r', stderr);
		(void)fflush(stderr);
		(void)napms(1000);	/* Settle the terminal. */
	}
d922 2
a923 2
	if (set_tab && clear_all_tabs) {
		int c;
d925 2
a926 2
		(void)putc('\r', stderr);	/* Force to left margin. */
		tputs(clear_all_tabs, 0, outc);
d928 16
a943 16
		for (c = 8; c < tcolumns; c += 8) {
			/* Get to the right column.  In BSD tset, this
			 * used to try a bunch of half-clever things
			 * with cup and hpa, for an average saving of
			 * somewhat less than two character times per
			 * tab stop, less that .01 sec at 2400cps. We
			 * lost all this cruft because it seemed to be
			 * introducing some odd bugs.
			 * ----------12345678----------- */
			(void)fputs("        ", stderr);
			tputs(set_tab, 0, outc);
		}
		putc('\r', stderr);
		return (TRUE);
	}
	return (FALSE);
d959 2
a960 5
	unsigned older, newer;
	char *p;

	newer = mode.c_cc[which];
	older = oldmode.c_cc[which];
d962 2
a963 2
	if (older == newer && older == def)
		return;
d965 2
a966 1
	(void)fprintf(stderr, "%s %s ", name, older == newer ? "is" : "set to");
d968 17
a984 15
	/*
	 * Check 'delete' before 'backspace', since the key_backspace value
	 * is ambiguous.
	 */
	if (newer == 0177)
		(void)fprintf(stderr, "delete.\n");
	else if ((p = key_backspace) != 0
	 && newer == (unsigned char)p[0]
	 && p[1] == '\0')
		(void)fprintf(stderr, "backspace.\n");
	else if (newer < 040) {
		newer ^= 0100;
		(void)fprintf(stderr, "control-%c (^%c).\n", newer, newer);
	} else
		(void)fprintf(stderr, "%c.\n", newer);
d995 2
a996 8
	for (; *argv; ++argv) {
		char *parm = argv[0];

		if (parm[0] == '-' && parm[1] == '\0')
		{
		    argv[0] = strdup("-q");
		    continue;
		}
d998 20
a1017 16
		if ((parm[0] != '-')
		 || (argv[1] && argv[1][0] != '-')
		 || (parm[1] != 'e' && parm[1] != 'i' && parm[1] != 'k')
		 || (parm[2] != '\0'))
			continue;
		switch(argv[0][1]) {
		case 'e':
			argv[0] = strdup("-e^H");
			break;
		case 'i':
			argv[0] = strdup("-i^C");
			break;
		case 'k':
			argv[0] = strdup("-k^U");
			break;
		}
d1019 1
d1023 1
a1023 1
usage(const char* pname)
d1025 3
a1027 3
	(void)fprintf(stderr,
"usage: %s [-IQrs] [-] [-e ch] [-i ch] [-k ch] [-m mapping] [terminal]\n", pname);
	exit(EXIT_FAILURE);
d1030 2
a1031 1
static char arg_to_char(void)
d1033 3
a1035 3
	return (optarg[0] == '^' && optarg[1] != '\0')
		? ((optarg[1] == '?') ? '\177' : CTRL(optarg[1]))
		: optarg[0];
d1042 1
a1042 1
	struct winsize win;
d1044 3
a1046 3
	int ch, noinit, noset, quiet, Sflag, sflag, showterm;
	const char *p;
	const char *ttype;
d1048 4
a1051 4
	char tcapbuf[1024], *t;
	int tcgetent(char *, const char *);
	void wrtermcap (char *);
#endif
d1054 2
a1055 2
	if (tcgetattr(STDERR_FILENO, &mode) < 0)
		failed("standard error");
d1057 2
a1058 2
	oldmode = mode;
	ospeed = cfgetospeed(&mode);
d1060 2
a1061 2
	if (gtty(STDERR_FILENO, &mode) < 0)
		failed("standard error");
d1063 2
a1064 2
	oldmode = mode;
	ospeed = mode.sg_ospeed;
d1067 61
a1127 61
	if ((p = strrchr(*argv, '/')) != 0)
		++p;
	else
		p = *argv;
	if (!CaselessCmp(p, "reset")) {
		isreset = 1;
		reset_mode();
	}

	obsolete(argv);
	noinit = noset = quiet = Sflag = sflag = showterm = 0;
	while ((ch = getopt(argc, argv, "a:d:e:Ii:k:m:np:qQSrs")) != -1) {
		switch (ch) {
		case 'q':		/* display term only */
			noset = 1;
			break;
		case 'a':		/* OBSOLETE: map identifier to type */
			add_mapping("arpanet", optarg);
			break;
		case 'd':		/* OBSOLETE: map identifier to type */
			add_mapping("dialup", optarg);
			break;
		case 'e':		/* erase character */
			terasechar = arg_to_char();
			break;
		case 'I':		/* no initialization strings */
			noinit = 1;
			break;
		case 'i':		/* interrupt character */
			intrchar = arg_to_char();
			break;
		case 'k':		/* kill character */
			tkillchar = arg_to_char();
			break;
		case 'm':		/* map identifier to type */
			add_mapping(0, optarg);
			break;
		case 'n':		/* OBSOLETE: set new tty driver */
			break;
		case 'p':		/* OBSOLETE: map identifier to type */
			add_mapping("plugboard", optarg);
			break;
		case 'Q':		/* don't output control key settings */
			quiet = 1;
			break;
		case 'S':		/* OBSOLETE: output TERM & TERMCAP */
			Sflag = 1;
			break;
		case 'r':		/* display term on stderr */
			showterm = 1;
			break;
		case 's':		/* output TERM set command */
			sflag = 1;
			break;
		case '?':
		default:
			usage(*argv);
		}
	}
	argc -= optind;
	argv += optind;
d1129 2
a1130 2
	if (argc > 1)
		usage(*argv);
d1132 1
a1132 1
	ttype = get_termcap_entry(*argv);
d1134 3
a1136 3
	if (tcgetent(tcapbuf, ttype) < 0)
		tcapbuf[0] = '\0';
#endif
d1138 3
a1140 3
	if (!noset) {
		tcolumns = columns;
		tlines = lines;
d1143 8
a1150 8
		/* Set window size */
		(void)ioctl(STDERR_FILENO, TIOCGWINSZ, &win);
		if (win.ws_row == 0 && win.ws_col == 0 &&
		    tlines > 0 && tcolumns > 0) {
			win.ws_row = tlines;
			win.ws_col = tcolumns;
			(void)ioctl(STDERR_FILENO, TIOCSWINSZ, &win);
		}
d1152 2
a1153 2
		set_control_chars();
		set_conversions();
d1155 2
a1156 2
		if (!noinit)
			set_init();
d1158 2
a1159 2
		/* Set the modes if they've changed. */
		if (memcmp(&mode, &oldmode, sizeof(mode)))
d1161 1
a1161 1
			tcsetattr(STDERR_FILENO, TCSADRAIN, &mode);
d1163 1
a1163 1
			stty(STDERR_FILENO, &mode);
d1165 1
a1165 1
	}
d1167 2
a1168 2
	/* Get the terminal name from the entry. */
	ttype = _nc_first_name(cur_term->type.term_names);
d1170 13
a1182 14
	if (noset)
		(void)printf("%s\n", ttype);
	else {
		if (showterm)
			(void)fprintf(stderr, "Terminal type is %s.\n", ttype);
		/*
		 * If erase, kill and interrupt characters could have been
		 * modified and not -Q, display the changes.
		 */
		if (!quiet) {
			report("Erase", VERASE, CERASE);
			report("Kill", VKILL, CINTR);
			report("Interrupt", VINTR, CKILL);
		}
d1184 1
d1187 10
a1196 10
	if (Sflag) {
		if (tcapbuf[0]) {
			(void) printf("%s ", ttype);
			wrtermcap(tcapbuf);
		} else
			err("No termcap entry for %s, only terminfo.", ttype);
	}
#else
	if (Sflag)
		err("The -S option is not supported under terminfo.");
d1200 19
a1218 12
	if (sflag) {
		/*
		 * Figure out what shell we're using.  A hack, we look for an
		 * environmental variable SHELL ending in "csh".
		 */
		if ((p = getenv("SHELL")) != 0
		 && !strcmp(p + strlen(p) - 3, "csh")) {
			if (tcapbuf[0])
				p = "set noglob histchars="";\nsetenv TERM %s;\nsetenv TERMCAP ";
			else
				p = "set noglob histchars="";\nsetenv TERM %s;\n";
				t = "unset noglob histchars;\n";
d1220 2
a1221 12
			if (tcapbuf) {
				p = "TERM=%s;\nTERMCAP=";
				t = "export TERMCAP TERM;\n";
			} else {
				if (tcapbuf) {
					p = "TERM=%s;\nTERMCAP=";
					t = "export TERMCAP TERM;\n";
				} else {
					p = "TERM=%s;\n";
					t = "export TERMCAP;\n";
				}
			}
d1223 7
a1229 7
		(void) printf(p, ttype);
		if (tcapbuf[0]) {
			putchar('\'');
			wrtermcap(tcapbuf);
			fputs("';\n", stdout);
		}
		(void)printf(t);
d1231 2
d1234 12
a1245 12
	if (sflag) {
		/*
		 * Figure out what shell we're using.  A hack, we look for an
		 * environmental variable SHELL ending in "csh".
		 */
		if ((p = getenv("SHELL")) != 0
		 && !strcmp(p + strlen(p) - 3, "csh"))
			p = "set noglob;\nsetenv TERM %s;\nunset noglob;\n";
		else
			p = "TERM=%s;\n";
		(void) printf(p, ttype);
	}
d1248 1
a1248 1
	return EXIT_SUCCESS;
@


1.14
log
@getopt(3) returns -1, not EOF
@
text
@d158 2
a159 2
	char	temp[BUFSIZ];
	perror(strcat(strcpy(temp, "tset: "), msg));
@


1.13
log
@ncurses-4.2-990314
@
text
@d1082 1
a1082 1
	while ((ch = getopt(argc, argv, "a:d:e:Ii:k:m:np:qQSrs")) != EOF) {
@


1.12
log
@ncurses-4.2-990301
@
text
@d106 1
a106 1
MODULE_ID("$From: tset.c,v 0.36 1999/02/23 11:05:30 tom Exp $")
d138 2
a139 9
static char *strdup (char *s)
{
  char *p;

  p = malloc(strlen(s)+1);
  if (p)
    strcpy(p,s);
  return(p);
}
@


1.11
log
@updates from ncurses-4.2-990116
@
text
@d106 1
a106 1
MODULE_ID("$From: tset.c,v 0.35 1999/01/02 19:57:24 tom Exp $")
d602 1
a602 2
			(void)fprintf(stderr, "tset: can't initialize terminal\
			    type %s (error %d)\n", ttype, errret);
@


1.10
log
@Move break statement so that -Q really works
@
text
@d106 1
a106 1
MODULE_ID("$From: tset.c,v 0.34 1998/09/05 22:02:19 tom Exp $")
d343 1
a343 1
	mapp = malloc((u_int)sizeof(MAP));
d595 1
a595 1
	while ((rval = setupterm(ttype, STDOUT_FILENO, &errret)) != OK) {
d968 1
a968 1
report(const char *name, int which, u_int def)
d971 1
a971 1
	u_int older, newer;
d989 1
a989 1
	 && newer == (u_int)p[0]
d1057 1
a1057 1
	const char *p, *t;
d1060 1
a1060 1
	char tcapbuf[1024];
@


1.9
log
@Add missing printf
@
text
@d1122 1
a1123 1
			quiet = 1;
@


1.8
log
@preserve ncruses module id
@
text
@d1244 1
@


1.7
log
@ncurses tset plus hacks to make $TERMCAP still get set
@
text
@d106 1
a106 1
MODULE_ID("$Id: tset.c,v 0.33 1998/04/04 19:09:17 juergen Exp $")
@


1.6
log
@don't dump core when linked against ncurses
@
text
@d1 32
a32 2
/*	$OpenBSD: tset.c,v 1.5 1998/04/25 04:30:39 millert Exp $	*/
/*	$NetBSD: tset.c,v 1.4 1994/12/07 05:08:15 jtc Exp $	*/
d34 9
d76 3
a78 16
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1991, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)tset.c	8.1 (Berkeley) 6/9/93";
#endif
static char rcsid[] = "$OpenBSD: tset.c,v 1.5 1998/04/25 04:30:39 millert Exp $";
#endif /* not lint */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <termios.h>
a79 2
#include <unistd.h>
#include <stdlib.h>
d81 968
a1048 16
#include <ctype.h>
#include <string.h>
#include <err.h>
#include "extern.h"

void	obsolete __P((char *[]));
void	report __P((char *, int, u_int));
void	usage __P((void));

struct termios mode, oldmode;

int	erasechar;		/* new erase character */
int	intrchar;		/* new interrupt character */
int	isreset;		/* invoked as reset */
int	killchar;		/* new kill character */
int	lines, columns;		/* window size */
d1051 1
a1051 3
main(argc, argv)
	int argc;
	char *argv[];
d1053 1
a1053 1
#ifdef TIOCGWINSZ
d1056 8
a1063 2
	int ch, noinit, noset, quiet, Sflag, sflag, showterm, usingupper;
	char savech, *p, *t, *tcapbuf, *ttype;
d1065 1
d1067 1
a1067 1
		err(1, "standard error");
d1071 7
d1079 1
a1079 1
	if (p = strrchr(*argv, '/'))
d1083 1
a1083 2
	usingupper = isupper(*p);
	if (!strcasecmp(p, "reset")) {
d1090 1
a1090 1
	while ((ch = getopt(argc, argv, "-a:d:e:Ii:k:m:np:QSrs")) != -1) {
d1092 1
a1092 1
		case '-':		/* display term only */
d1102 1
a1102 3
			erasechar = optarg[0] == '^' && optarg[1] != '\0' ?
			    optarg[1] == '?' ? '\177' : CTRL(optarg[1]) :
			    optarg[0];
d1108 1
a1108 3
			intrchar = optarg[0] == '^' && optarg[1] != '\0' ?
			    optarg[1] == '?' ? '\177' : CTRL(optarg[1]) :
			    optarg[0];
d1111 1
a1111 3
			killchar = optarg[0] == '^' && optarg[1] != '\0' ?
			    optarg[1] == '?' ? '\177' : CTRL(optarg[1]) :
			    optarg[0];
d1114 1
a1114 1
			add_mapping(NULL, optarg);
d1122 1
d1124 1
a1124 2
			break;
		case 'S':		/* output TERM/TERMCAP strings */
d1130 1
a1130 1
		case 's':		/* output TERM/TERMCAP strings */
d1135 1
a1135 1
			usage();
d1142 1
a1142 1
		usage();
d1144 5
a1148 1
	ttype = get_termcap_entry(*argv, &tcapbuf);
d1151 2
a1152 2
		columns = tgetnum("co");
		lines = tgetnum("li");
d1154 1
a1154 1
#ifdef TIOCGWINSZ
d1158 3
a1160 3
		    lines > 0 && columns > 0) {
			win.ws_row = lines;
			win.ws_col = columns;
d1165 1
a1165 1
		set_conversions(usingupper);
d1172 1
d1174 3
d1180 1
a1180 11
	p = tcapbuf;
	if (p != NULL && *p != ':') {
		t = p;
		if (p = strpbrk(p, "|:")) {
			savech = *p;
			*p = '\0';
			if ((ttype = strdup(t)) == NULL)
				err(1, "strdup");
			*p = savech;
		}
	}
d1193 2
a1194 2
			report("Kill", VKILL, CKILL);
			report("Interrupt", VINTR, CINTR);
d1198 1
d1200 2
a1201 2
		(void)printf("%s ", ttype);
		if (tcapbuf)
d1203 2
d1206 4
d1211 1
d1217 3
a1219 3
		if ((p = getenv("SHELL")) &&
		    !strcmp(p + strlen(p) - 3, "csh")) {
			if (tcapbuf)
d1223 1
a1223 1
			t = "unset noglob histchars;\n";
d1229 7
a1235 2
				p = "TERM=%s;\n";
				t = "export TERMCAP;\n";
d1238 2
a1239 2
		(void)printf(p, ttype);
		if (tcapbuf) {
a1243 1
		(void)printf(t);
d1245 14
d1260 1
a1260 60
	exit(0);
}

/*
 * Tell the user if a control key has been changed from the default value.
 */
void
report(name, which, def)
	char *name;
	int which;
	u_int def;
{
	u_int old, new;
	char *bp, buf[1024];

	new = mode.c_cc[which];
	old = oldmode.c_cc[which];

	if (old == new && old == def)
		return;

	(void)fprintf(stderr, "%s %s ", name, old == new ? "is" : "set to");

	bp = buf;
	if (tgetstr("kb", &bp) && new == buf[0] && buf[1] == '\0')
		(void)fprintf(stderr, "backspace.\n");
	else if (new == 0177)
		(void)fprintf(stderr, "delete.\n");
	else if (new < 040) {
		new ^= 0100;
		(void)fprintf(stderr, "control-%c (^%c).\n", new, new);
	} else
		(void)fprintf(stderr, "%c.\n", new);
}

/*
 * Convert the obsolete argument form into something that getopt can handle.
 * This means that -e, -i and -k get default arguments supplied for them.
 */
void
obsolete(argv)
	char *argv[];
{
	for (; *argv; ++argv) {
		if (argv[0][0] != '-' || argv[1] && argv[1][0] != '-' ||
		    argv[0][1] != 'e' && argv[0][1] != 'i' &&
		    argv[0][1] != 'k' || argv[0][2] != '\0')
			continue;
		switch(argv[0][1]) {
		case 'e':
			argv[0] = "-e^H";
			break;
		case 'i':
			argv[0] = "-i^C";
			break;
		case 'k':
			argv[0] = "-k^U";
			break;
		}
	}
d1263 1
a1263 7
void
usage()
{
	(void)fprintf(stderr,
"usage: tset [-IQrSs] [-] [-e ch] [-i ch] [-k ch] [-m mapping] [terminal]\n");
	exit(1);
}
@


1.5
log
@fix some minor nits:
    o no need to flush stderr as it is not buffered
    o use putc to print a newline, not fprintf
    o set histchars to be null when we set noglob (and undo of course).
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.4 1997/07/25 22:13:25 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tset.c,v 1.4 1997/07/25 22:13:25 mickey Exp $";
d221 2
a222 1
		wrtermcap(tcapbuf);
d232 5
a236 2
			p = "set noglob histchars="";\nsetenv TERM %s;\nsetenv TERMCAP '";
			t = "';\nunset noglob histchars;\n";
d238 7
a244 2
			p = "TERM=%s;\nTERMCAP='";
			t = "';\nexport TERMCAP TERM;\n";
d247 5
a251 1
		wrtermcap(tcapbuf);
@


1.4
log
@user err(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.3 1997/01/15 23:43:25 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tset.c,v 1.3 1997/01/15 23:43:25 millert Exp $";
d231 2
a232 2
			p = "set noglob;\nsetenv TERM %s;\nsetenv TERMCAP '";
			t = "';\nunset noglob;\n";
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.2 1996/06/26 05:41:58 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tset.c,v 1.2 1996/06/26 05:41:58 deraadt Exp $";
d59 1
d86 1
a86 1
		err("standard error: %s", strerror(errno));
d198 1
a198 1
				err("%s", strerror(errno));
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: tset.c,v 1.4 1994/12/07 05:08:15 jtc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: tset.c,v 1.4 1994/12/07 05:08:15 jtc Exp $";
d102 1
a102 1
	while ((ch = getopt(argc, argv, "-a:d:e:Ii:k:m:np:QSrs")) != EOF) {
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: tset.c,v 1.4 1994/12/07 05:08:15 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
