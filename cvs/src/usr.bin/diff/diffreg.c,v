head	1.91;
access;
symbols
	OPENBSD_6_2:1.91.0.4
	OPENBSD_6_2_BASE:1.91
	OPENBSD_6_1:1.91.0.6
	OPENBSD_6_1_BASE:1.91
	OPENBSD_6_0:1.91.0.2
	OPENBSD_6_0_BASE:1.91
	OPENBSD_5_9:1.90.0.2
	OPENBSD_5_9_BASE:1.90
	OPENBSD_5_8:1.86.0.4
	OPENBSD_5_8_BASE:1.86
	OPENBSD_5_7:1.85.0.2
	OPENBSD_5_7_BASE:1.85
	OPENBSD_5_6:1.82.0.12
	OPENBSD_5_6_BASE:1.82
	OPENBSD_5_5:1.82.0.10
	OPENBSD_5_5_BASE:1.82
	OPENBSD_5_4:1.82.0.6
	OPENBSD_5_4_BASE:1.82
	OPENBSD_5_3:1.82.0.4
	OPENBSD_5_3_BASE:1.82
	OPENBSD_5_2:1.82.0.2
	OPENBSD_5_2_BASE:1.82
	OPENBSD_5_1_BASE:1.80
	OPENBSD_5_1:1.80.0.4
	OPENBSD_5_0:1.80.0.2
	OPENBSD_5_0_BASE:1.80
	OPENBSD_4_9:1.79.0.4
	OPENBSD_4_9_BASE:1.79
	OPENBSD_4_8:1.79.0.2
	OPENBSD_4_8_BASE:1.79
	OPENBSD_4_7:1.73.0.2
	OPENBSD_4_7_BASE:1.73
	OPENBSD_4_6:1.72.0.4
	OPENBSD_4_6_BASE:1.72
	OPENBSD_4_5:1.70.0.6
	OPENBSD_4_5_BASE:1.70
	OPENBSD_4_4:1.70.0.4
	OPENBSD_4_4_BASE:1.70
	OPENBSD_4_3:1.70.0.2
	OPENBSD_4_3_BASE:1.70
	OPENBSD_4_2:1.69.0.2
	OPENBSD_4_2_BASE:1.69
	OPENBSD_4_1:1.66.0.2
	OPENBSD_4_1_BASE:1.66
	OPENBSD_4_0:1.64.0.4
	OPENBSD_4_0_BASE:1.64
	OPENBSD_3_9:1.64.0.2
	OPENBSD_3_9_BASE:1.64
	OPENBSD_3_8:1.62.0.4
	OPENBSD_3_8_BASE:1.62
	OPENBSD_3_7:1.62.0.2
	OPENBSD_3_7_BASE:1.62
	OPENBSD_3_6:1.57.0.2
	OPENBSD_3_6_BASE:1.57
	OPENBSD_3_5:1.55.0.2
	OPENBSD_3_5_BASE:1.55
	OPENBSD_3_4:1.50.0.2
	OPENBSD_3_4_BASE:1.50;
locks; strict;
comment	@ * @;


1.91
date	2016.03.01.20.57.35;	author natano;	state Exp;
branches;
next	1.90;
commitid	UryANQYJHHNzyGhl;

1.90
date	2015.10.26.12.52.27;	author tedu;	state Exp;
branches;
next	1.89;
commitid	iT29VK1nO9sccs6J;

1.89
date	2015.10.13.16.37.17;	author tobias;	state Exp;
branches;
next	1.88;
commitid	aFjpx9iEnmBZ86cm;

1.88
date	2015.10.05.20.15.00;	author millert;	state Exp;
branches;
next	1.87;
commitid	ploPtaulyei0HJ2S;

1.87
date	2015.09.25.16.16.26;	author tedu;	state Exp;
branches;
next	1.86;
commitid	ufT3acxBNu7Ulbo5;

1.86
date	2015.04.29.04.00.25;	author deraadt;	state Exp;
branches;
next	1.85;
commitid	bgNifxVaPtXhk3GY;

1.85
date	2015.02.05.12.59.57;	author millert;	state Exp;
branches;
next	1.84;
commitid	DTQbfd4poqBW8iSJ;

1.84
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.83;
commitid	Uu5nFG3wCl0LACBb;

1.83
date	2014.08.27.15.22.40;	author kspillner;	state Exp;
branches;
next	1.82;
commitid	LnZk4rQSnpIl7rFq;

1.82
date	2012.07.08.15.48.56;	author stsp;	state Exp;
branches;
next	1.81;

1.81
date	2012.05.22.12.30.24;	author millert;	state Exp;
branches;
next	1.80;

1.80
date	2011.04.01.17.25.26;	author nicm;	state Exp;
branches;
next	1.79;

1.79
date	2010.07.16.21.47.02;	author ray;	state Exp;
branches;
next	1.78;

1.78
date	2010.07.16.08.06.00;	author ray;	state Exp;
branches;
next	1.77;

1.77
date	2010.07.15.21.32.37;	author ray;	state Exp;
branches;
next	1.76;

1.76
date	2010.07.15.18.31.33;	author ray;	state Exp;
branches;
next	1.75;

1.75
date	2010.07.14.22.15.57;	author ray;	state Exp;
branches;
next	1.74;

1.74
date	2010.03.22.19.33.19;	author schwarze;	state Exp;
branches;
next	1.73;

1.73
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2009.06.07.08.39.13;	author ray;	state Exp;
branches;
next	1.71;

1.71
date	2009.06.06.15.00.27;	author ray;	state Exp;
branches;
next	1.70;

1.70
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.69;

1.69
date	2007.06.09.05.16.21;	author ray;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.29.18.24.56;	author ray;	state Exp;
branches;
next	1.67;

1.67
date	2007.03.18.21.12.27;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2007.02.23.08.03.19;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2007.02.22.01.44.36;	author millert;	state Exp;
branches;
next	1.64;

1.64
date	2006.02.22.07.26.08;	author otto;	state Exp;
branches;
next	1.63;

1.63
date	2006.02.16.08.15.05;	author otto;	state Exp;
branches;
next	1.62;

1.62
date	2005.01.13.08.27.45;	author otto;	state Exp;
branches;
next	1.61;

1.61
date	2004.12.09.18.56.10;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2004.11.27.19.16.25;	author otto;	state Exp;
branches;
next	1.59;

1.59
date	2004.10.20.08.52.19;	author otto;	state Exp;
branches;
next	1.58;

1.58
date	2004.09.14.23.04.27;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2004.06.20.18.47.45;	author otto;	state Exp;
branches;
next	1.56;

1.56
date	2004.06.18.07.23.50;	author otto;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.07.17.18.32;	author otto;	state Exp;
branches;
next	1.54;

1.54
date	2003.11.22.18.02.44;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2003.11.21.01.28.01;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2003.11.10.18.51.35;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2003.10.28.13.23.59;	author avsm;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.07.07.53.01;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2003.08.13.20.44.15;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2003.08.08.16.09.26;	author otto;	state Exp;
branches;
next	1.47;

1.47
date	2003.07.31.20.00.03;	author otto;	state Exp;
branches;
next	1.46;

1.46
date	2003.07.31.02.53.57;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2003.07.29.18.38.47;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2003.07.27.18.58.26;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2003.07.27.07.39.52;	author otto;	state Exp;
branches;
next	1.42;

1.42
date	2003.07.23.22.01.36;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.22.01.16.01;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2003.07.22.00.20.40;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.22.00.15.55;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.21.21.59.58;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.21.21.57.22;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.21.15.56.48;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.17.21.54.28;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.16.21.39.06;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.15.23.17.56;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.09.00.39.26;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.07.09.00.07.44;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2003.07.08.04.51.30;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.07.08.04.45.32;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.06.22.17.21;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.06.20.48.59;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.07.04.17.37.07;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.04.02.54.36;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.02.18.54.13;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.27.20.28.13;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.26.22.04.45;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.26.18.19.29;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.26.04.52.26;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.26.04.47.30;	author vincent;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.25.22.38.11;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.25.22.14.43;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.25.21.43.49;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.25.17.49.22;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.25.07.26.59;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.25.03.55.45;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.25.03.53.59;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.25.03.50.27;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.25.03.46.45;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.25.03.42.16;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.25.03.42.00;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.25.03.39.23;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.25.03.38.34;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.25.03.37.32;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.25.03.25.29;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.25.03.02.33;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.25.01.23.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.25.01.20.52;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.91
log
@Rectify line numbers for s/.// commands in ed-style diffs.

When diff encounters a line that consists of a single dot, it emits two
dots instead, stops the current command and emits a substitute command
to replace the double dot with a single one. Then it restarts the
(original) command if necessary and inserts further lines. This is done
because a single dot on a line does have special meaning in ed. (It
stops text insertion.)

Following issues are fixed by this commit.

- The line number for the substitute command should be the number of the
most recently inserted line. diff instead uses the number of the first
inserted line of the current hunk. The first character of that line is
removed when applying the diff, while the superfluous dot is not.

- The line number of the restarted command is not adjusted for the
number of lines already inserted, resulting in the reordering of lines..

- When there is a bare dot in the replacement text of a change command,
too many lines are deleted, because a second change command is emitted.
An append command should be emitted instead, because the target lines
have already been removed by the first change command.

tweaks and ok stefan@@
@
text
@/*	$OpenBSD: diffreg.c,v 1.90 2015/10/26 12:52:27 tedu Exp $	*/

/*
 * Copyright (C) Caldera International Inc.  2001-2002.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code and documentation must retain the above
 *    copyright notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed or owned by Caldera
 *	International, Inc.
 * 4. Neither the name of Caldera International, Inc. nor the names of other
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
 * INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE FOR ANY DIRECT,
 * INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)diffreg.c   8.1 (Berkeley) 6/6/93
 */

#include <sys/stat.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "diff.h"
#include "xmalloc.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

/*
 * diff - compare two files.
 */

/*
 *	Uses an algorithm due to Harold Stone, which finds
 *	a pair of longest identical subsequences in the two
 *	files.
 *
 *	The major goal is to generate the match vector J.
 *	J[i] is the index of the line in file1 corresponding
 *	to line i file0. J[i] = 0 if there is no
 *	such line in file1.
 *
 *	Lines are hashed so as to work in core. All potential
 *	matches are located by sorting the lines of each file
 *	on the hash (called ``value''). In particular, this
 *	collects the equivalence classes in file1 together.
 *	Subroutine equiv replaces the value of each line in
 *	file0 by the index of the first element of its
 *	matching equivalence in (the reordered) file1.
 *	To save space equiv squeezes file1 into a single
 *	array member in which the equivalence classes
 *	are simply concatenated, except that their first
 *	members are flagged by changing sign.
 *
 *	Next the indices that point into member are unsorted into
 *	array class according to the original order of file0.
 *
 *	The cleverness lies in routine stone. This marches
 *	through the lines of file0, developing a vector klist
 *	of "k-candidates". At step i a k-candidate is a matched
 *	pair of lines x,y (x in file0 y in file1) such that
 *	there is a common subsequence of length k
 *	between the first i lines of file0 and the first y
 *	lines of file1, but there is no such subsequence for
 *	any smaller y. x is the earliest possible mate to y
 *	that occurs in such a subsequence.
 *
 *	Whenever any of the members of the equivalence class of
 *	lines in file1 matable to a line in file0 has serial number
 *	less than the y of some k-candidate, that k-candidate
 *	with the smallest such y is replaced. The new
 *	k-candidate is chained (via pred) to the current
 *	k-1 candidate so that the actual subsequence can
 *	be recovered. When a member has serial number greater
 *	that the y of all k-candidates, the klist is extended.
 *	At the end, the longest subsequence is pulled out
 *	and placed in the array J by unravel
 *
 *	With J in hand, the matches there recorded are
 *	check'ed against reality to assure that no spurious
 *	matches have crept in due to hashing. If they have,
 *	they are broken, and "jackpot" is recorded--a harmless
 *	matter except that a true match for a spuriously
 *	mated line may now be unnecessarily reported as a change.
 *
 *	Much of the complexity of the program comes simply
 *	from trying to minimize core utilization and
 *	maximize the range of doable problems by dynamically
 *	allocating what is needed and reusing what is not.
 *	The core requirements for problems larger than somewhat
 *	are (in words) 2*length(file0) + length(file1) +
 *	3*(number of k-candidates installed),  typically about
 *	6n words for files of length n.
 */

struct cand {
	int	x;
	int	y;
	int	pred;
};

struct line {
	int	serial;
	int	value;
} *file[2];

/*
 * The following struct is used to record change information when
 * doing a "context" or "unified" diff.  (see routine "change" to
 * understand the highly mnemonic field names)
 */
struct context_vec {
	int	a;		/* start line in old file */
	int	b;		/* end line in old file */
	int	c;		/* start line in new file */
	int	d;		/* end line in new file */
};

#define	diff_output	printf
static FILE	*opentemp(const char *);
static void	 output(char *, FILE *, char *, FILE *, int);
static void	 check(FILE *, FILE *, int);
static void	 range(int, int, char *);
static void	 uni_range(int, int);
static void	 dump_context_vec(FILE *, FILE *, int);
static void	 dump_unified_vec(FILE *, FILE *, int);
static void	 prepare(int, FILE *, off_t, int);
static void	 prune(void);
static void	 equiv(struct line *, int, struct line *, int, int *);
static void	 unravel(int);
static void	 unsort(struct line *, int, int *);
static void	 change(char *, FILE *, char *, FILE *, int, int, int, int, int *);
static void	 sort(struct line *, int);
static void	 print_header(const char *, const char *);
static int	 ignoreline(char *);
static int	 asciifile(FILE *);
static int	 fetch(long *, int, int, FILE *, int, int, int);
static int	 newcand(int, int, int);
static int	 search(int *, int, int);
static int	 skipline(FILE *);
static int	 isqrt(int);
static int	 stone(int *, int, int *, int *, int);
static int	 readhash(FILE *, int);
static int	 files_differ(FILE *, FILE *, int);
static char	*match_function(const long *, int, FILE *);
static char	*preadline(int, size_t, off_t);

static int  *J;			/* will be overlaid on class */
static int  *class;		/* will be overlaid on file[0] */
static int  *klist;		/* will be overlaid on file[0] after class */
static int  *member;		/* will be overlaid on file[1] */
static int   clen;
static int   inifdef;		/* whether or not we are in a #ifdef block */
static int   len[2];
static int   pref, suff;	/* length of prefix and suffix */
static int   slen[2];
static int   anychange;
static long *ixnew;		/* will be overlaid on file[1] */
static long *ixold;		/* will be overlaid on klist */
static struct cand *clist;	/* merely a free storage pot for candidates */
static int   clistlen;		/* the length of clist */
static struct line *sfile[2];	/* shortened by pruning common prefix/suffix */
static u_char *chrtran;		/* translation table for case-folding */
static struct context_vec *context_vec_start;
static struct context_vec *context_vec_end;
static struct context_vec *context_vec_ptr;

#define FUNCTION_CONTEXT_SIZE	55
static char lastbuf[FUNCTION_CONTEXT_SIZE];
static int lastline;
static int lastmatchline;


/*
 * chrtran points to one of 2 translation tables: cup2low if folding upper to
 * lower case clow2low if not folding case
 */
u_char clow2low[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
	0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
	0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
	0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
	0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41,
	0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c,
	0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,
	0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
	0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
	0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
	0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
	0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
	0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
	0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5,
	0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0,
	0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
	0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
	0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1,
	0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc,
	0xfd, 0xfe, 0xff
};

u_char cup2low[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
	0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
	0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
	0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
	0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x60, 0x61,
	0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
	0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x60, 0x61, 0x62,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,
	0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
	0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
	0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
	0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
	0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
	0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
	0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5,
	0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0,
	0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
	0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
	0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1,
	0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc,
	0xfd, 0xfe, 0xff
};

int
diffreg(char *file1, char *file2, int flags)
{
	FILE *f1, *f2;
	int i, rval;

	f1 = f2 = NULL;
	rval = D_SAME;
	anychange = 0;
	lastline = 0;
	lastmatchline = 0;
	context_vec_ptr = context_vec_start - 1;
	if (flags & D_IGNORECASE)
		chrtran = cup2low;
	else
		chrtran = clow2low;
	if (S_ISDIR(stb1.st_mode) != S_ISDIR(stb2.st_mode))
		return (S_ISDIR(stb1.st_mode) ? D_MISMATCH1 : D_MISMATCH2);
	if (strcmp(file1, "-") == 0 && strcmp(file2, "-") == 0)
		goto closem;

	if (flags & D_EMPTY1)
		f1 = fopen(_PATH_DEVNULL, "r");
	else {
		if (!S_ISREG(stb1.st_mode)) {
			if ((f1 = opentemp(file1)) == NULL ||
			    fstat(fileno(f1), &stb1) < 0) {
				warn("%s", file1);
				status |= 2;
				goto closem;
			}
		} else if (strcmp(file1, "-") == 0)
			f1 = stdin;
		else
			f1 = fopen(file1, "r");
	}
	if (f1 == NULL) {
		warn("%s", file1);
		status |= 2;
		goto closem;
	}

	if (flags & D_EMPTY2)
		f2 = fopen(_PATH_DEVNULL, "r");
	else {
		if (!S_ISREG(stb2.st_mode)) {
			if ((f2 = opentemp(file2)) == NULL ||
			    fstat(fileno(f2), &stb2) < 0) {
				warn("%s", file2);
				status |= 2;
				goto closem;
			}
		} else if (strcmp(file2, "-") == 0)
			f2 = stdin;
		else
			f2 = fopen(file2, "r");
	}
	if (f2 == NULL) {
		warn("%s", file2);
		status |= 2;
		goto closem;
	}

	switch (files_differ(f1, f2, flags)) {
	case 0:
		goto closem;
	case 1:
		break;
	default:
		/* error */
		status |= 2;
		goto closem;
	}

	if ((flags & D_FORCEASCII) == 0 &&
	    (!asciifile(f1) || !asciifile(f2))) {
		rval = D_BINARY;
		status |= 1;
		goto closem;
	}
	prepare(0, f1, stb1.st_size, flags);
	prepare(1, f2, stb2.st_size, flags);

	prune();
	sort(sfile[0], slen[0]);
	sort(sfile[1], slen[1]);

	member = (int *)file[1];
	equiv(sfile[0], slen[0], sfile[1], slen[1], member);
	member = xreallocarray(member, slen[1] + 2, sizeof(*member));

	class = (int *)file[0];
	unsort(sfile[0], slen[0], class);
	class = xreallocarray(class, slen[0] + 2, sizeof(*class));

	klist = xcalloc(slen[0] + 2, sizeof(*klist));
	clen = 0;
	clistlen = 100;
	clist = xcalloc(clistlen, sizeof(*clist));
	i = stone(class, slen[0], member, klist, flags);
	free(member);
	free(class);

	J = xreallocarray(J, len[0] + 2, sizeof(*J));
	unravel(klist[i]);
	free(clist);
	free(klist);

	ixold = xreallocarray(ixold, len[0] + 2, sizeof(*ixold));
	ixnew = xreallocarray(ixnew, len[1] + 2, sizeof(*ixnew));
	check(f1, f2, flags);
	output(file1, f1, file2, f2, flags);
closem:
	if (anychange) {
		status |= 1;
		if (rval == D_SAME)
			rval = D_DIFFER;
	}
	if (f1 != NULL)
		fclose(f1);
	if (f2 != NULL)
		fclose(f2);

	return (rval);
}

/*
 * Check to see if the given files differ.
 * Returns 0 if they are the same, 1 if different, and -1 on error.
 * XXX - could use code from cmp(1) [faster]
 */
static int
files_differ(FILE *f1, FILE *f2, int flags)
{
	char buf1[BUFSIZ], buf2[BUFSIZ];
	size_t i, j;

	if ((flags & (D_EMPTY1|D_EMPTY2)) || stb1.st_size != stb2.st_size ||
	    (stb1.st_mode & S_IFMT) != (stb2.st_mode & S_IFMT))
		return (1);
	for (;;) {
		i = fread(buf1, 1, sizeof(buf1), f1);
		j = fread(buf2, 1, sizeof(buf2), f2);
		if ((!i && ferror(f1)) || (!j && ferror(f2)))
			return (-1);
		if (i != j)
			return (1);
		if (i == 0)
			return (0);
		if (memcmp(buf1, buf2, i) != 0)
			return (1);
	}
}

static FILE *
opentemp(const char *file)
{
	char buf[BUFSIZ], tempfile[PATH_MAX];
	ssize_t nread;
	int ifd, ofd;

	if (strcmp(file, "-") == 0)
		ifd = STDIN_FILENO;
	else if ((ifd = open(file, O_RDONLY, 0644)) < 0)
		return (NULL);

	(void)strlcpy(tempfile, _PATH_TMP "/diff.XXXXXXXX", sizeof(tempfile));

	if ((ofd = mkstemp(tempfile)) < 0) {
		close(ifd);
		return (NULL);
	}
	unlink(tempfile);
	while ((nread = read(ifd, buf, BUFSIZ)) > 0) {
		if (write(ofd, buf, nread) != nread) {
			close(ifd);
			close(ofd);
			return (NULL);
		}
	}
	close(ifd);
	lseek(ofd, (off_t)0, SEEK_SET);
	return (fdopen(ofd, "r"));
}

char *
splice(char *dir, char *file)
{
	char *tail, *buf;
	size_t dirlen;

	dirlen = strlen(dir);
	while (dirlen != 0 && dir[dirlen - 1] == '/')
	    dirlen--;
	if ((tail = strrchr(file, '/')) == NULL)
		tail = file;
	else
		tail++;
	xasprintf(&buf, "%.*s/%s", (int)dirlen, dir, tail);
	return (buf);
}

static void
prepare(int i, FILE *fd, off_t filesize, int flags)
{
	struct line *p;
	int j, h;
	size_t sz;

	rewind(fd);

	sz = (filesize <= SIZE_MAX ? filesize : SIZE_MAX) / 25;
	if (sz < 100)
		sz = 100;

	p = xcalloc(sz + 3, sizeof(*p));
	for (j = 0; (h = readhash(fd, flags));) {
		if (j == sz) {
			sz = sz * 3 / 2;
			p = xreallocarray(p, sz + 3, sizeof(*p));
		}
		p[++j].value = h;
	}
	len[i] = j;
	file[i] = p;
}

static void
prune(void)
{
	int i, j;

	for (pref = 0; pref < len[0] && pref < len[1] &&
	    file[0][pref + 1].value == file[1][pref + 1].value;
	    pref++)
		;
	for (suff = 0; suff < len[0] - pref && suff < len[1] - pref &&
	    file[0][len[0] - suff].value == file[1][len[1] - suff].value;
	    suff++)
		;
	for (j = 0; j < 2; j++) {
		sfile[j] = file[j] + pref;
		slen[j] = len[j] - pref - suff;
		for (i = 0; i <= slen[j]; i++)
			sfile[j][i].serial = i;
	}
}

static void
equiv(struct line *a, int n, struct line *b, int m, int *c)
{
	int i, j;

	i = j = 1;
	while (i <= n && j <= m) {
		if (a[i].value < b[j].value)
			a[i++].value = 0;
		else if (a[i].value == b[j].value)
			a[i++].value = j;
		else
			j++;
	}
	while (i <= n)
		a[i++].value = 0;
	b[m + 1].value = 0;
	j = 0;
	while (++j <= m) {
		c[j] = -b[j].serial;
		while (b[j + 1].value == b[j].value) {
			j++;
			c[j] = b[j].serial;
		}
	}
	c[j] = -1;
}

/* Code taken from ping.c */
static int
isqrt(int n)
{
	int y, x = 1;

	if (n == 0)
		return (0);

	do { /* newton was a stinker */
		y = x;
		x = n / x;
		x += y;
		x /= 2;
	} while ((x - y) > 1 || (x - y) < -1);

	return (x);
}

static int
stone(int *a, int n, int *b, int *c, int flags)
{
	int i, k, y, j, l;
	int oldc, tc, oldl, sq;
	u_int numtries, bound;

	if (flags & D_MINIMAL)
		bound = UINT_MAX;
	else {
		sq = isqrt(n);
		bound = MAXIMUM(256, sq);
	}

	k = 0;
	c[0] = newcand(0, 0, 0);
	for (i = 1; i <= n; i++) {
		j = a[i];
		if (j == 0)
			continue;
		y = -b[j];
		oldl = 0;
		oldc = c[0];
		numtries = 0;
		do {
			if (y <= clist[oldc].y)
				continue;
			l = search(c, k, y);
			if (l != oldl + 1)
				oldc = c[l - 1];
			if (l <= k) {
				if (clist[c[l]].y <= y)
					continue;
				tc = c[l];
				c[l] = newcand(i, y, oldc);
				oldc = tc;
				oldl = l;
				numtries++;
			} else {
				c[l] = newcand(i, y, oldc);
				k++;
				break;
			}
		} while ((y = b[++j]) > 0 && numtries < bound);
	}
	return (k);
}

static int
newcand(int x, int y, int pred)
{
	struct cand *q;

	if (clen == clistlen) {
		clistlen = clistlen * 11 / 10;
		clist = xreallocarray(clist, clistlen, sizeof(*clist));
	}
	q = clist + clen;
	q->x = x;
	q->y = y;
	q->pred = pred;
	return (clen++);
}

static int
search(int *c, int k, int y)
{
	int i, j, l, t;

	if (clist[c[k]].y < y)	/* quick look for typical case */
		return (k + 1);
	i = 0;
	j = k + 1;
	for (;;) {
		l = (i + j) / 2;
		if (l <= i)
			break;
		t = clist[c[l]].y;
		if (t > y)
			j = l;
		else if (t < y)
			i = l;
		else
			return (l);
	}
	return (l + 1);
}

static void
unravel(int p)
{
	struct cand *q;
	int i;

	for (i = 0; i <= len[0]; i++)
		J[i] = i <= pref ? i :
		    i > len[0] - suff ? i + len[1] - len[0] : 0;
	for (q = clist + p; q->y != 0; q = clist + q->pred)
		J[q->x + pref] = q->y + pref;
}

/*
 * Check does double duty:
 *  1.	ferret out any fortuitous correspondences due
 *	to confounding by hashing (which result in "jackpot")
 *  2.  collect random access indexes to the two files
 */
static void
check(FILE *f1, FILE *f2, int flags)
{
	int i, j, jackpot, c, d;
	long ctold, ctnew;

	rewind(f1);
	rewind(f2);
	j = 1;
	ixold[0] = ixnew[0] = 0;
	jackpot = 0;
	ctold = ctnew = 0;
	for (i = 1; i <= len[0]; i++) {
		if (J[i] == 0) {
			ixold[i] = ctold += skipline(f1);
			continue;
		}
		while (j < J[i]) {
			ixnew[j] = ctnew += skipline(f2);
			j++;
		}
		if (flags & (D_FOLDBLANKS|D_IGNOREBLANKS|D_IGNORECASE)) {
			for (;;) {
				c = getc(f1);
				d = getc(f2);
				/*
				 * GNU diff ignores a missing newline
				 * in one file for -b or -w.
				 */
				if (flags & (D_FOLDBLANKS|D_IGNOREBLANKS)) {
					if (c == EOF && d == '\n') {
						ctnew++;
						break;
					} else if (c == '\n' && d == EOF) {
						ctold++;
						break;
					}
				}
				ctold++;
				ctnew++;
				if ((flags & D_FOLDBLANKS) && isspace(c) &&
				    isspace(d)) {
					do {
						if (c == '\n')
							break;
						ctold++;
					} while (isspace(c = getc(f1)));
					do {
						if (d == '\n')
							break;
						ctnew++;
					} while (isspace(d = getc(f2)));
				} else if ((flags & D_IGNOREBLANKS)) {
					while (isspace(c) && c != '\n') {
						c = getc(f1);
						ctold++;
					}
					while (isspace(d) && d != '\n') {
						d = getc(f2);
						ctnew++;
					}
				}
				if (chrtran[c] != chrtran[d]) {
					jackpot++;
					J[i] = 0;
					if (c != '\n' && c != EOF)
						ctold += skipline(f1);
					if (d != '\n' && c != EOF)
						ctnew += skipline(f2);
					break;
				}
				if (c == '\n' || c == EOF)
					break;
			}
		} else {
			for (;;) {
				ctold++;
				ctnew++;
				if ((c = getc(f1)) != (d = getc(f2))) {
					/* jackpot++; */
					J[i] = 0;
					if (c != '\n' && c != EOF)
						ctold += skipline(f1);
					if (d != '\n' && c != EOF)
						ctnew += skipline(f2);
					break;
				}
				if (c == '\n' || c == EOF)
					break;
			}
		}
		ixold[i] = ctold;
		ixnew[j] = ctnew;
		j++;
	}
	for (; j <= len[1]; j++)
		ixnew[j] = ctnew += skipline(f2);
	/*
	 * if (jackpot)
	 *	fprintf(stderr, "jackpot\n");
	 */
}

/* shellsort CACM #201 */
static void
sort(struct line *a, int n)
{
	struct line *ai, *aim, w;
	int j, m = 0, k;

	if (n == 0)
		return;
	for (j = 1; j <= n; j *= 2)
		m = 2 * j - 1;
	for (m /= 2; m != 0; m /= 2) {
		k = n - m;
		for (j = 1; j <= k; j++) {
			for (ai = &a[j]; ai > a; ai -= m) {
				aim = &ai[m];
				if (aim < ai)
					break;	/* wraparound */
				if (aim->value > ai[0].value ||
				    (aim->value == ai[0].value &&
					aim->serial > ai[0].serial))
					break;
				w.value = ai[0].value;
				ai[0].value = aim->value;
				aim->value = w.value;
				w.serial = ai[0].serial;
				ai[0].serial = aim->serial;
				aim->serial = w.serial;
			}
		}
	}
}

static void
unsort(struct line *f, int l, int *b)
{
	int *a, i;

	a = xcalloc(l + 1, sizeof(*a));
	for (i = 1; i <= l; i++)
		a[f[i].serial] = f[i].value;
	for (i = 1; i <= l; i++)
		b[i] = a[i];
	free(a);
}

static int
skipline(FILE *f)
{
	int i, c;

	for (i = 1; (c = getc(f)) != '\n' && c != EOF; i++)
		continue;
	return (i);
}

static void
output(char *file1, FILE *f1, char *file2, FILE *f2, int flags)
{
	int m, i0, i1, j0, j1;

	rewind(f1);
	rewind(f2);
	m = len[0];
	J[0] = 0;
	J[m + 1] = len[1] + 1;
	if (diff_format != D_EDIT) {
		for (i0 = 1; i0 <= m; i0 = i1 + 1) {
			while (i0 <= m && J[i0] == J[i0 - 1] + 1)
				i0++;
			j0 = J[i0 - 1] + 1;
			i1 = i0 - 1;
			while (i1 < m && J[i1 + 1] == 0)
				i1++;
			j1 = J[i1 + 1] - 1;
			J[i1] = j1;
			change(file1, f1, file2, f2, i0, i1, j0, j1, &flags);
		}
	} else {
		for (i0 = m; i0 >= 1; i0 = i1 - 1) {
			while (i0 >= 1 && J[i0] == J[i0 + 1] - 1 && J[i0] != 0)
				i0--;
			j0 = J[i0 + 1] - 1;
			i1 = i0 + 1;
			while (i1 > 1 && J[i1 - 1] == 0)
				i1--;
			j1 = J[i1 - 1] + 1;
			J[i1] = j1;
			change(file1, f1, file2, f2, i1, i0, j1, j0, &flags);
		}
	}
	if (m == 0)
		change(file1, f1, file2, f2, 1, 0, 1, len[1], &flags);
	if (diff_format == D_IFDEF) {
		for (;;) {
#define	c i0
			if ((c = getc(f1)) == EOF)
				return;
			diff_output("%c", c);
		}
#undef c
	}
	if (anychange != 0) {
		if (diff_format == D_CONTEXT)
			dump_context_vec(f1, f2, flags);
		else if (diff_format == D_UNIFIED)
			dump_unified_vec(f1, f2, flags);
	}
}

static void
range(int a, int b, char *separator)
{
	diff_output("%d", a > b ? b : a);
	if (a < b)
		diff_output("%s%d", separator, b);
}

static void
uni_range(int a, int b)
{
	if (a < b)
		diff_output("%d,%d", a, b - a + 1);
	else if (a == b)
		diff_output("%d", b);
	else
		diff_output("%d,0", b);
}

static char *
preadline(int fd, size_t rlen, off_t off)
{
	char *line;
	ssize_t nr;

	line = xmalloc(rlen + 1);
	if ((nr = pread(fd, line, rlen, off)) < 0)
		err(2, "preadline");
	if (nr > 0 && line[nr-1] == '\n')
		nr--;
	line[nr] = '\0';
	return (line);
}

static int
ignoreline(char *line)
{
	int ret;

	ret = regexec(&ignore_re, line, 0, NULL, 0);
	free(line);
	return (ret == 0);	/* if it matched, it should be ignored. */
}

/*
 * Indicate that there is a difference between lines a and b of the from file
 * to get to lines c to d of the to file.  If a is greater then b then there
 * are no lines in the from file involved and this means that there were
 * lines appended (beginning at b).  If c is greater than d then there are
 * lines missing from the to file.
 */
static void
change(char *file1, FILE *f1, char *file2, FILE *f2, int a, int b, int c, int d,
    int *pflags)
{
	static size_t max_context = 64;
	int i;

restart:
	if (diff_format != D_IFDEF && a > b && c > d)
		return;
	if (ignore_pats != NULL) {
		char *line;
		/*
		 * All lines in the change, insert, or delete must
		 * match an ignore pattern for the change to be
		 * ignored.
		 */
		if (a <= b) {		/* Changes and deletes. */
			for (i = a; i <= b; i++) {
				line = preadline(fileno(f1),
				    ixold[i] - ixold[i - 1], ixold[i - 1]);
				if (!ignoreline(line))
					goto proceed;
			}
		}
		if (a > b || c <= d) {	/* Changes and inserts. */
			for (i = c; i <= d; i++) {
				line = preadline(fileno(f2),
				    ixnew[i] - ixnew[i - 1], ixnew[i - 1]);
				if (!ignoreline(line))
					goto proceed;
			}
		}
		return;
	}
proceed:
	if (*pflags & D_HEADER) {
		diff_output("%s %s %s\n", diffargs, file1, file2);
		*pflags &= ~D_HEADER;
	}
	if (diff_format == D_CONTEXT || diff_format == D_UNIFIED) {
		/*
		 * Allocate change records as needed.
		 */
		if (context_vec_ptr == context_vec_end - 1) {
			ptrdiff_t offset = context_vec_ptr - context_vec_start;
			max_context <<= 1;
			context_vec_start = xreallocarray(context_vec_start,
			    max_context, sizeof(*context_vec_start));
			context_vec_end = context_vec_start + max_context;
			context_vec_ptr = context_vec_start + offset;
		}
		if (anychange == 0) {
			/*
			 * Print the context/unidiff header first time through.
			 */
			print_header(file1, file2);
			anychange = 1;
		} else if (a > context_vec_ptr->b + (2 * diff_context) + 1 &&
		    c > context_vec_ptr->d + (2 * diff_context) + 1) {
			/*
			 * If this change is more than 'diff_context' lines from the
			 * previous change, dump the record and reset it.
			 */
			if (diff_format == D_CONTEXT)
				dump_context_vec(f1, f2, *pflags);
			else
				dump_unified_vec(f1, f2, *pflags);
		}
		context_vec_ptr++;
		context_vec_ptr->a = a;
		context_vec_ptr->b = b;
		context_vec_ptr->c = c;
		context_vec_ptr->d = d;
		return;
	}
	if (anychange == 0)
		anychange = 1;
	switch (diff_format) {
	case D_BRIEF:
		return;
	case D_NORMAL:
	case D_EDIT:
		range(a, b, ",");
		diff_output("%c", a > b ? 'a' : c > d ? 'd' : 'c');
		if (diff_format == D_NORMAL)
			range(c, d, ",");
		diff_output("\n");
		break;
	case D_REVERSE:
		diff_output("%c", a > b ? 'a' : c > d ? 'd' : 'c');
		range(a, b, " ");
		diff_output("\n");
		break;
	case D_NREVERSE:
		if (a > b)
			diff_output("a%d %d\n", b, d - c + 1);
		else {
			diff_output("d%d %d\n", a, b - a + 1);
			if (!(c > d))
				/* add changed lines */
				diff_output("a%d %d\n", b, d - c + 1);
		}
		break;
	}
	if (diff_format == D_NORMAL || diff_format == D_IFDEF) {
		fetch(ixold, a, b, f1, '<', 1, *pflags);
		if (a <= b && c <= d && diff_format == D_NORMAL)
			diff_output("---\n");
	}
	i = fetch(ixnew, c, d, f2, diff_format == D_NORMAL ? '>' : '\0', 0, *pflags);
	if (i != 0 && diff_format == D_EDIT) {
		/*
		 * A non-zero return value for D_EDIT indicates that the
		 * last line printed was a bare dot (".") that has been
		 * escaped as ".." to prevent ed(1) from misinterpreting
		 * it.  We have to add a substitute command to change this
		 * back and restart where we left off.
		 */
		diff_output(".\n");
		diff_output("%ds/.//\n", a + i - 1);
		b = a + i - 1;
		a = b + 1;
		c += i;
		goto restart;
	}
	if ((diff_format == D_EDIT || diff_format == D_REVERSE) && c <= d)
		diff_output(".\n");
	if (inifdef) {
		diff_output("#endif /* %s */\n", ifdefname);
		inifdef = 0;
	}
}

static int
fetch(long *f, int a, int b, FILE *lb, int ch, int oldfile, int flags)
{
	int i, j, c, lastc, col, nc;

	/*
	 * When doing #ifdef's, copy down to current line
	 * if this is the first file, so that stuff makes it to output.
	 */
	if (diff_format == D_IFDEF && oldfile) {
		long curpos = ftell(lb);
		/* print through if append (a>b), else to (nb: 0 vs 1 orig) */
		nc = f[a > b ? b : a - 1] - curpos;
		for (i = 0; i < nc; i++)
			diff_output("%c", getc(lb));
	}
	if (a > b)
		return (0);
	if (diff_format == D_IFDEF) {
		if (inifdef) {
			diff_output("#else /* %s%s */\n",
			    oldfile == 1 ? "!" : "", ifdefname);
		} else {
			if (oldfile)
				diff_output("#ifndef %s\n", ifdefname);
			else
				diff_output("#ifdef %s\n", ifdefname);
		}
		inifdef = 1 + oldfile;
	}
	for (i = a; i <= b; i++) {
		fseek(lb, f[i - 1], SEEK_SET);
		nc = f[i] - f[i - 1];
		if (diff_format != D_IFDEF && ch != '\0') {
			diff_output("%c", ch);
			if (Tflag && (diff_format == D_NORMAL || diff_format == D_CONTEXT
			    || diff_format == D_UNIFIED))
				diff_output("\t");
			else if (diff_format != D_UNIFIED)
				diff_output(" ");
		}
		col = 0;
		for (j = 0, lastc = '\0'; j < nc; j++, lastc = c) {
			if ((c = getc(lb)) == EOF) {
				if (diff_format == D_EDIT || diff_format == D_REVERSE ||
				    diff_format == D_NREVERSE)
					warnx("No newline at end of file");
				else
					diff_output("\n\\ No newline at end of "
					    "file\n");
				return (0);
			}
			if (c == '\t' && (flags & D_EXPANDTABS)) {
				do {
					diff_output(" ");
				} while (++col & 7);
			} else {
				if (diff_format == D_EDIT && j == 1 && c == '\n'
				    && lastc == '.') {
					/*
					 * Don't print a bare "." line
					 * since that will confuse ed(1).
					 * Print ".." instead and return,
					 * giving the caller an offset
					 * from which to restart.
					 */
					diff_output(".\n");
					return (i - a + 1);
				}
				diff_output("%c", c);
				col++;
			}
		}
	}
	return (0);
}

/*
 * Hash function taken from Robert Sedgewick, Algorithms in C, 3d ed., p 578.
 */
static int
readhash(FILE *f, int flags)
{
	int i, t, space;
	int sum;

	sum = 1;
	space = 0;
	if ((flags & (D_FOLDBLANKS|D_IGNOREBLANKS)) == 0) {
		if (flags & D_IGNORECASE)
			for (i = 0; (t = getc(f)) != '\n'; i++) {
				if (t == EOF) {
					if (i == 0)
						return (0);
					break;
				}
				sum = sum * 127 + chrtran[t];
			}
		else
			for (i = 0; (t = getc(f)) != '\n'; i++) {
				if (t == EOF) {
					if (i == 0)
						return (0);
					break;
				}
				sum = sum * 127 + t;
			}
	} else {
		for (i = 0;;) {
			switch (t = getc(f)) {
			case '\t':
			case '\r':
			case '\v':
			case '\f':
			case ' ':
				space++;
				continue;
			default:
				if (space && (flags & D_IGNOREBLANKS) == 0) {
					i++;
					space = 0;
				}
				sum = sum * 127 + chrtran[t];
				i++;
				continue;
			case EOF:
				if (i == 0)
					return (0);
				/* FALLTHROUGH */
			case '\n':
				break;
			}
			break;
		}
	}
	/*
	 * There is a remote possibility that we end up with a zero sum.
	 * Zero is used as an EOF marker, so return 1 instead.
	 */
	return (sum == 0 ? 1 : sum);
}

static int
asciifile(FILE *f)
{
	unsigned char buf[BUFSIZ];
	size_t cnt;

	if (f == NULL)
		return (1);

	rewind(f);
	cnt = fread(buf, 1, sizeof(buf), f);
	return (memchr(buf, '\0', cnt) == NULL);
}

#define begins_with(s, pre) (strncmp(s, pre, sizeof(pre)-1) == 0)

static char *
match_function(const long *f, int pos, FILE *fp)
{
	unsigned char buf[FUNCTION_CONTEXT_SIZE];
	size_t nc;
	int last = lastline;
	char *state = NULL;

	lastline = pos;
	while (pos > last) {
		fseek(fp, f[pos - 1], SEEK_SET);
		nc = f[pos] - f[pos - 1];
		if (nc >= sizeof(buf))
			nc = sizeof(buf) - 1;
		nc = fread(buf, 1, nc, fp);
		if (nc > 0) {
			buf[nc] = '\0';
			buf[strcspn(buf, "\n")] = '\0';
			if (isalpha(buf[0]) || buf[0] == '_' || buf[0] == '$') {
				if (begins_with(buf, "private:")) {
					if (!state)
						state = " (private)";
				} else if (begins_with(buf, "protected:")) {
					if (!state)
						state = " (protected)";
				} else if (begins_with(buf, "public:")) {
					if (!state)
						state = " (public)";
				} else {
					strlcpy(lastbuf, buf, sizeof lastbuf);
					if (state)
						strlcat(lastbuf, state,
						    sizeof lastbuf);
					lastmatchline = pos;
					return lastbuf;
				}
			}
		}
		pos--;
	}
	return lastmatchline > 0 ? lastbuf : NULL;
}

/* dump accumulated "context" diff changes */
static void
dump_context_vec(FILE *f1, FILE *f2, int flags)
{
	struct context_vec *cvp = context_vec_start;
	int lowa, upb, lowc, upd, do_output;
	int a, b, c, d;
	char ch, *f;

	if (context_vec_start > context_vec_ptr)
		return;

	b = d = 0;		/* gcc */
	lowa = MAXIMUM(1, cvp->a - diff_context);
	upb = MINIMUM(len[0], context_vec_ptr->b + diff_context);
	lowc = MAXIMUM(1, cvp->c - diff_context);
	upd = MINIMUM(len[1], context_vec_ptr->d + diff_context);

	diff_output("***************");
	if ((flags & D_PROTOTYPE)) {
		f = match_function(ixold, lowa-1, f1);
		if (f != NULL)
			diff_output(" %s", f);
	}
	diff_output("\n*** ");
	range(lowa, upb, ",");
	diff_output(" ****\n");

	/*
	 * Output changes to the "old" file.  The first loop suppresses
	 * output if there were no changes to the "old" file (we'll see
	 * the "old" lines as context in the "new" list).
	 */
	do_output = 0;
	for (; cvp <= context_vec_ptr; cvp++)
		if (cvp->a <= cvp->b) {
			cvp = context_vec_start;
			do_output++;
			break;
		}
	if (do_output) {
		while (cvp <= context_vec_ptr) {
			a = cvp->a;
			b = cvp->b;
			c = cvp->c;
			d = cvp->d;

			if (a <= b && c <= d)
				ch = 'c';
			else
				ch = (a <= b) ? 'd' : 'a';

			if (ch == 'a')
				fetch(ixold, lowa, b, f1, ' ', 0, flags);
			else {
				fetch(ixold, lowa, a - 1, f1, ' ', 0, flags);
				fetch(ixold, a, b, f1,
				    ch == 'c' ? '!' : '-', 0, flags);
			}
			lowa = b + 1;
			cvp++;
		}
		fetch(ixold, b + 1, upb, f1, ' ', 0, flags);
	}
	/* output changes to the "new" file */
	diff_output("--- ");
	range(lowc, upd, ",");
	diff_output(" ----\n");

	do_output = 0;
	for (cvp = context_vec_start; cvp <= context_vec_ptr; cvp++)
		if (cvp->c <= cvp->d) {
			cvp = context_vec_start;
			do_output++;
			break;
		}
	if (do_output) {
		while (cvp <= context_vec_ptr) {
			a = cvp->a;
			b = cvp->b;
			c = cvp->c;
			d = cvp->d;

			if (a <= b && c <= d)
				ch = 'c';
			else
				ch = (a <= b) ? 'd' : 'a';

			if (ch == 'd')
				fetch(ixnew, lowc, d, f2, ' ', 0, flags);
			else {
				fetch(ixnew, lowc, c - 1, f2, ' ', 0, flags);
				fetch(ixnew, c, d, f2,
				    ch == 'c' ? '!' : '+', 0, flags);
			}
			lowc = d + 1;
			cvp++;
		}
		fetch(ixnew, d + 1, upd, f2, ' ', 0, flags);
	}
	context_vec_ptr = context_vec_start - 1;
}

/* dump accumulated "unified" diff changes */
static void
dump_unified_vec(FILE *f1, FILE *f2, int flags)
{
	struct context_vec *cvp = context_vec_start;
	int lowa, upb, lowc, upd;
	int a, b, c, d;
	char ch, *f;

	if (context_vec_start > context_vec_ptr)
		return;

	b = d = 0;		/* gcc */
	lowa = MAXIMUM(1, cvp->a - diff_context);
	upb = MINIMUM(len[0], context_vec_ptr->b + diff_context);
	lowc = MAXIMUM(1, cvp->c - diff_context);
	upd = MINIMUM(len[1], context_vec_ptr->d + diff_context);

	diff_output("@@@@ -");
	uni_range(lowa, upb);
	diff_output(" +");
	uni_range(lowc, upd);
	diff_output(" @@@@");
	if ((flags & D_PROTOTYPE)) {
		f = match_function(ixold, lowa-1, f1);
		if (f != NULL)
			diff_output(" %s", f);
	}
	diff_output("\n");

	/*
	 * Output changes in "unified" diff format--the old and new lines
	 * are printed together.
	 */
	for (; cvp <= context_vec_ptr; cvp++) {
		a = cvp->a;
		b = cvp->b;
		c = cvp->c;
		d = cvp->d;

		/*
		 * c: both new and old changes
		 * d: only changes in the old file
		 * a: only changes in the new file
		 */
		if (a <= b && c <= d)
			ch = 'c';
		else
			ch = (a <= b) ? 'd' : 'a';

		switch (ch) {
		case 'c':
			fetch(ixold, lowa, a - 1, f1, ' ', 0, flags);
			fetch(ixold, a, b, f1, '-', 0, flags);
			fetch(ixnew, c, d, f2, '+', 0, flags);
			break;
		case 'd':
			fetch(ixold, lowa, a - 1, f1, ' ', 0, flags);
			fetch(ixold, a, b, f1, '-', 0, flags);
			break;
		case 'a':
			fetch(ixnew, lowc, c - 1, f2, ' ', 0, flags);
			fetch(ixnew, c, d, f2, '+', 0, flags);
			break;
		}
		lowa = b + 1;
		lowc = d + 1;
	}
	fetch(ixnew, d + 1, upd, f2, ' ', 0, flags);

	context_vec_ptr = context_vec_start - 1;
}

static void
print_header(const char *file1, const char *file2)
{
	if (label[0] != NULL)
		diff_output("%s %s\n", diff_format == D_CONTEXT ? "***" : "---",
		    label[0]);
	else
		diff_output("%s %s\t%s", diff_format == D_CONTEXT ? "***" : "---",
		    file1, ctime(&stb1.st_mtime));
	if (label[1] != NULL)
		diff_output("%s %s\n", diff_format == D_CONTEXT ? "---" : "+++",
		    label[1]);
	else
		diff_output("%s %s\t%s", diff_format == D_CONTEXT ? "---" : "+++",
		    file2, ctime(&stb2.st_mtime));
}
@


1.90
log
@remove TMPDIR support. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.89 2015/10/13 16:37:17 tobias Exp $	*/
d1078 3
a1080 2
		diff_output("%ds/.//\n", a);
		a += i;
@


1.89
log
@Replace our /^\.\././ expression with /.//. The term is simpler and has
the same meaning in our diff ed-context.

As a bonus, our ed-diff output can be processed by GNU patch now, too.

okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.88 2015/10/05 20:15:00 millert Exp $	*/
d449 1
a449 1
	char buf[BUFSIZ], *tempdir, tempfile[PATH_MAX];
d458 1
a458 10
	if ((tempdir = getenv("TMPDIR")) == NULL)
		tempdir = _PATH_TMP;

	if (strlcpy(tempfile, tempdir, sizeof(tempfile)) >= sizeof(tempfile) ||
	    strlcat(tempfile, "/diff.XXXXXXXX", sizeof(tempfile)) >=
	    sizeof(tempfile)) {
		close(ifd);
		errno = ENAMETOOLONG;
		return (NULL);
	}
@


1.88
log
@Remove the non-standard -l flag that pipes the output through pr(1).
Based on a diff from and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.87 2015/09/25 16:16:26 tedu Exp $	*/
d1087 1
a1087 1
		diff_output("%ds/^\\.\\././\n", a);
@


1.87
log
@xmalloc/free wrappers don't need to support 20 year old non comformance
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.86 2015/04/29 04:00:25 deraadt Exp $	*/
d74 1
a83 1
#include "pathnames.h"
d296 1
a296 2
	int i, rval, ostdout = -1;
	pid_t pid = -1;
a371 39
	if (lflag) {
		/* redirect stdout to pr */
		int pfd[2];
		char *header;
		char *prargv[] = { "pr", "-h", NULL, "-f", NULL };

		xasprintf(&header, "%s %s %s", diffargs, file1, file2);
		prargv[2] = header;
		fflush(stdout);
		rewind(stdout);
		pipe(pfd);
		switch ((pid = fork())) {
		case -1:
			warnx("No more processes");
			status |= 2;
			free(header);
			rval = D_ERROR;
			goto closem;
		case 0:
			/* child */
			if (pfd[0] != STDIN_FILENO) {
				dup2(pfd[0], STDIN_FILENO);
				close(pfd[0]);
			}
			close(pfd[1]);
			execv(_PATH_PR, prargv);
			_exit(127);
		default:
			/* parent */
			if (pfd[1] != STDOUT_FILENO) {
				ostdout = dup(STDOUT_FILENO);
				dup2(pfd[1], STDOUT_FILENO);
				close(pfd[1]);
			}
			close(pfd[0]);
			rewind(stdout);
			free(header);
		}
	}
a403 13
	if (ostdout != -1) {
		int wstatus;

		/* close the pipe to pr and restore stdout */
		fflush(stdout);
		rewind(stdout);
		if (ostdout != STDOUT_FILENO) {
			close(STDOUT_FILENO);
			dup2(ostdout, STDOUT_FILENO);
			close(ostdout);
		}
		waitpid(pid, &wstatus, 0);
	}
@


1.86
log
@Change internal xrealloc() to a idiom-following xreallocarray().
This loses a "new size is 0" failure case.  Probably not relevant;
and since we develop this in OpenBSD, we'll catch that before someone
else imports this...
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.85 2015/02/05 12:59:57 millert Exp $	*/
d388 1
a388 1
			xfree(header);
d409 1
a409 1
			xfree(header);
d432 2
a433 2
	xfree(member);
	xfree(class);
d437 2
a438 2
	xfree(clist);
	xfree(klist);
d902 1
a902 1
	xfree(a);
d1009 1
a1009 1
	xfree(line);
@


1.85
log
@Include stdint.h, not limits.h to get SIZE_MAX.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.84 2015/01/16 06:40:07 deraadt Exp $	*/
d421 1
a421 1
	member = xrealloc(member, slen[1] + 2, sizeof(*member));
d425 1
a425 1
	class = xrealloc(class, slen[0] + 2, sizeof(*class));
d435 1
a435 1
	J = xrealloc(J, len[0] + 2, sizeof(*J));
d440 2
a441 2
	ixold = xrealloc(ixold, len[0] + 2, sizeof(*ixold));
	ixnew = xrealloc(ixnew, len[1] + 2, sizeof(*ixnew));
d573 1
a573 1
			p = xrealloc(p, sz + 3, sizeof(*p));
d704 1
a704 1
		clist = xrealloc(clist, clistlen, sizeof(*clist));
d1067 1
a1067 1
			context_vec_start = xrealloc(context_vec_start,
@


1.84
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.83 2014/08/27 15:22:40 kspillner Exp $	*/
d75 1
@


1.83
log
@Ensure diff -uw always produces valid output when one file doesn't end
with a newline.  Issue reported by guenther@@.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.82 2012/07/08 15:48:56 stsp Exp $	*/
a66 1
#include <sys/param.h>
d79 1
d85 3
d501 1
a501 1
	char buf[BUFSIZ], *tempdir, tempfile[MAXPATHLEN];
d659 1
a659 1
		bound = MAX(256, sq);
d1366 4
a1369 4
	lowa = MAX(1, cvp->a - diff_context);
	upb = MIN(len[0], context_vec_ptr->b + diff_context);
	lowc = MAX(1, cvp->c - diff_context);
	upd = MIN(len[1], context_vec_ptr->d + diff_context);
d1469 4
a1472 4
	lowa = MAX(1, cvp->a - diff_context);
	upb = MIN(len[0], context_vec_ptr->b + diff_context);
	lowc = MAX(1, cvp->c - diff_context);
	upd = MIN(len[1], context_vec_ptr->d + diff_context);
@


1.82
log
@Switch diff(1) binary file detection from !(isprint() || isspace()) to
checking for embedded NULs, as was done for grep(1) some time ago.
Avoids problems with e.g. latin1-encoded files being treated as binary, since
isprint() uses only ASCII by default and diff(1) doesn't call setlocale().
prodded by and ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.81 2012/05/22 12:30:24 millert Exp $	*/
d781 8
a788 4
				if ((flags & (D_FOLDBLANKS|D_IGNOREBLANKS)) &&
				    ((c == EOF && d == '\n') ||
				    (c == '\n' && d == EOF))) {
					break;
@


1.81
log
@Strip trailing slashes from directory in splice() before
appending the file portion.  OK krw@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.80 2011/04/01 17:25:26 nicm Exp $	*/
d1291 1
a1291 1
	size_t i, cnt;
d1298 1
a1298 4
	for (i = 0; i < cnt; i++)
		if (!isprint(buf[i]) && !isspace(buf[i]))
			return (0);
	return (1);
@


1.80
log
@Move an isqrt() call outside a macro, from Michael W Bombardieri.

ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.79 2010/07/16 21:47:02 ray Exp $	*/
d539 1
d541 3
d548 1
a548 1
	xasprintf(&buf, "%s/%s", dir, tail);
@


1.79
log
@Close FILEs when fork fails.

OK nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.78 2010/07/16 08:06:00 ray Exp $	*/
d645 2
a646 2
	int oldc, tc, oldl;
	u_int numtries;
d648 6
a653 3
	/* XXX move the isqrt() out of the macro to avoid multiple calls */
	const u_int bound = (flags & D_MINIMAL) ? UINT_MAX :
	    MAX(256, isqrt(n));
@


1.78
log
@diff exits 2 on error, not 1.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.77 2010/07/15 21:32:37 ray Exp $	*/
d385 2
a386 1
			return (D_ERROR);
@


1.77
log
@cvs and rcs use diff_output() to print everything since it is not
always to stdout. A large number of differences are due to this.
This diff reduces many more differences between diff and cvs/rcs.
Personally I think it's kinda ugly. =(

"Looks fine" millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.76 2010/07/15 18:31:33 ray Exp $	*/
d980 1
a980 1
		err(1, "preadline");
@


1.76
log
@Remove unused arguments from check(). From cvs/rcs.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.75 2010/07/14 22:15:57 ray Exp $	*/
d175 1
d941 1
a941 1
			putchar(c);
d956 1
a956 1
	printf("%d", a > b ? b : a);
d958 1
a958 1
		printf("%s%d", separator, b);
d965 1
a965 1
		printf("%d,%d", a, b - a + 1);
d967 1
a967 1
		printf("%d", b);
d969 1
a969 1
		printf("%d,0", b);
d1041 1
a1041 1
		printf("%s %s %s\n", diffargs, file1, file2);
d1088 1
a1088 1
		putchar(a > b ? 'a' : c > d ? 'd' : 'c');
d1091 1
a1091 1
		putchar('\n');
d1094 1
a1094 1
		putchar(a > b ? 'a' : c > d ? 'd' : 'c');
d1096 1
a1096 1
		putchar('\n');
d1100 1
a1100 1
			printf("a%d %d\n", b, d - c + 1);
d1102 1
a1102 1
			printf("d%d %d\n", a, b - a + 1);
d1105 1
a1105 1
				printf("a%d %d\n", b, d - c + 1);
d1112 1
a1112 1
			puts("---");
d1123 2
a1124 2
		puts(".");
		printf("%ds/^\\.\\././\n", a);
d1130 1
a1130 1
		puts(".");
d1132 1
a1132 1
		printf("#endif /* %s */\n", ifdefname);
d1151 1
a1151 1
			putchar(getc(lb));
d1157 1
a1157 1
			printf("#else /* %s%s */\n",
d1161 1
a1161 1
				printf("#ifndef %s\n", ifdefname);
d1163 1
a1163 1
				printf("#ifdef %s\n", ifdefname);
d1171 1
a1171 1
			putchar(ch);
d1174 1
a1174 1
				putchar('\t');
d1176 1
a1176 1
				putchar(' ');
d1185 2
a1186 1
					puts("\n\\ No newline at end of file");
d1191 1
a1191 1
					putchar(' ');
d1203 1
a1203 1
					puts(".");
d1206 1
a1206 1
				putchar(c);
d1359 1
a1359 1
	printf("***************");
d1362 2
a1363 4
		if (f != NULL) {
			putchar(' ');
			fputs(f, stdout);
		}
d1365 1
a1365 1
	printf("\n*** ");
d1367 1
a1367 1
	printf(" ****\n");
d1406 1
a1406 1
	printf("--- ");
d1408 1
a1408 1
	printf(" ----\n");
d1462 1
a1462 1
	fputs("@@@@ -", stdout);
d1464 1
a1464 1
	fputs(" +", stdout);
d1466 1
a1466 1
	fputs(" @@@@", stdout);
d1469 2
a1470 4
		if (f != NULL) {
			putchar(' ');
			fputs(f, stdout);
		}
d1472 1
a1472 1
	putchar('\n');
d1521 1
a1521 1
		printf("%s %s\n", diff_format == D_CONTEXT ? "***" : "---",
d1524 1
a1524 1
		printf("%s %s\t%s", diff_format == D_CONTEXT ? "***" : "---",
d1527 1
a1527 1
		printf("%s %s\n", diff_format == D_CONTEXT ? "---" : "+++",
d1530 1
a1530 1
		printf("%s %s\t%s", diff_format == D_CONTEXT ? "---" : "+++",
@


1.75
log
@Return -1 on error as advertised.
Handle case when only one stream failed.

OK otto, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.74 2010/03/22 19:33:19 schwarze Exp $	*/
d177 1
a177 1
static void	 check(char *, FILE *, char *, FILE *, int);
d436 1
a436 1
	check(file1, f1, file2, f2, flags);
d744 1
a744 1
check(char *file1, FILE *f1, char *file2, FILE *f2, int flags)
@


1.74
log
@Even though this cannot happen in the diff -r case,
even though diff(1) will exit(3) soon after this mkstemp(3) failure,
even though this cannot really leak anything,
close the file descriptor as soon as it is not used any more
to make correctness of the code more obvious.

patch from Igor Zinovik <zinovik dot igor at gmail dot com> on tech@@
"looks nice" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.73 2009/10/27 23:59:37 deraadt Exp $	*/
d482 2
d486 1
a486 3
		if (i == 0 && j == 0) {
			if (ferror(f1) || ferror(f2))
				return (1);
a487 1
		}
@


1.73
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.72 2009/06/07 08:39:13 ray Exp $	*/
d517 2
a518 1
	if ((ofd = mkstemp(tempfile)) < 0)
d520 1
@


1.72
log
@More cvs/diff/rcs convergence:
1. Mostly variable/function renaming, SIZE_T_MAX->SIZE_MAX, and
spacing.
2. One strchr -> strncspn.
3. diff had a weird thing where it set file[12] = ofile[12] but
never updated file or ofile, then if file and ofile were different
it freed it. I removed it.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.71 2009/06/06 15:00:27 ray Exp $	*/
a65 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.71 2009/06/06 15:00:27 ray Exp $";
#endif /* not lint */
@


1.71
log
@Pull changes from rcsdiff, similar to what was pulled into cvsdiff.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.70 2007/09/11 15:47:17 gilles Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.70 2007/09/11 15:47:17 gilles Exp $";
d292 1
a292 1
diffreg(char *ofile1, char *ofile2, int flags)
a293 2
	char *file1 = ofile1;
	char *file2 = ofile2;
d412 1
d425 1
a425 1
	klist = xmalloc((slen[0] + 2) * sizeof(*klist));
d428 1
a428 1
	clist = xmalloc(clistlen * sizeof(*clist));
a464 4
	if (file1 != ofile1)
		xfree(file1);
	if (file2 != ofile2)
		xfree(file2);
d512 1
a512 1
	
d562 1
a562 1
	p = xmalloc((sz + 3) * sizeof(*p));
d883 1
a883 1
	a = xmalloc((l + 1) * sizeof(*a));
d911 1
a911 1
	if (format != D_EDIT) {
d938 1
a938 1
	if (format == D_IFDEF) {
d948 1
a948 1
		if (format == D_CONTEXT)
d950 1
a950 1
		else if (format == D_UNIFIED)
d1014 1
a1014 1
	if (format != D_IFDEF && a > b && c > d)
d1046 1
a1046 1
	if (format == D_CONTEXT || format == D_UNIFIED) {
d1064 2
a1065 2
		} else if (a > context_vec_ptr->b + (2 * context) + 1 &&
		    c > context_vec_ptr->d + (2 * context) + 1) {
d1067 1
a1067 1
			 * If this change is more than 'context' lines from the
d1070 1
a1070 1
			if (format == D_CONTEXT)
d1084 1
a1084 2
	switch (format) {

d1091 1
a1091 1
		if (format == D_NORMAL)
d1111 1
a1111 1
	if (format == D_NORMAL || format == D_IFDEF) {
d1113 1
a1113 1
		if (a <= b && c <= d && format == D_NORMAL)
d1116 2
a1117 2
	i = fetch(ixnew, c, d, f2, format == D_NORMAL ? '>' : '\0', 0, *pflags);
	if (i != 0 && format == D_EDIT) {
d1131 1
a1131 1
	if ((format == D_EDIT || format == D_REVERSE) && c <= d)
d1148 1
a1148 1
	if (format == D_IFDEF && oldfile) {
d1157 1
a1157 1
	if (format == D_IFDEF) {
d1172 1
a1172 1
		if (format != D_IFDEF && ch != '\0') {
d1174 2
a1175 2
			if (Tflag && (format == D_NORMAL || format == D_CONTEXT
			    || format == D_UNIFIED))
d1177 1
a1177 1
			else if (format != D_UNIFIED)
d1183 2
a1184 2
				if (format == D_EDIT || format == D_REVERSE ||
				    format == D_NREVERSE)
d1195 1
a1195 1
				if (format == D_EDIT && j == 1 && c == '\n'
a1316 1

d1330 1
a1330 1
						strlcat(lastbuf, state, 
d1355 4
a1358 4
	lowa = MAX(1, cvp->a - context);
	upb = MIN(len[0], context_vec_ptr->b + context);
	lowc = MAX(1, cvp->c - context);
	upd = MIN(len[1], context_vec_ptr->d + context);
d1460 4
a1463 4
	lowa = MAX(1, cvp->a - context);
	upb = MIN(len[0], context_vec_ptr->b + context);
	lowc = MAX(1, cvp->c - context);
	upd = MIN(len[1], context_vec_ptr->d + context);
d1526 1
a1526 1
		printf("%s %s\n", format == D_CONTEXT ? "***" : "---",
d1529 1
a1529 1
		printf("%s %s\t%s", format == D_CONTEXT ? "***" : "---",
d1532 1
a1532 1
		printf("%s %s\n", format == D_CONTEXT ? "---" : "+++",
d1535 1
a1535 1
		printf("%s %s\t%s", format == D_CONTEXT ? "---" : "+++",
@


1.70
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.69 2007/06/09 05:16:21 ray Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.69 2007/06/09 05:16:21 ray Exp $";
d181 1
a181 1
static void	 check(char *, FILE *, char *, FILE *);
d184 3
a186 3
static void	 dump_context_vec(FILE *, FILE *);
static void	 dump_unified_vec(FILE *, FILE *);
static void	 prepare(int, FILE *, off_t);
d196 1
a196 1
static int	 fetch(long *, int, int, FILE *, int, int);
d201 2
a202 2
static int	 stone(int *, int, int *, int *);
static int	 readhash(FILE *);
d296 2
a297 4
	FILE *f1 = NULL;
	FILE *f2 = NULL;
	int rval = D_SAME;
	int i, ostdout = -1;
d300 2
d306 4
a309 1
	chrtran = (iflag ? cup2low : clow2low);
d368 2
a369 1
	if (!asciifile(f1) || !asciifile(f2)) {
d412 2
a413 2
	prepare(0, f1, stb1.st_size);
	prepare(1, f2, stb2.st_size);
d430 1
a430 1
	i = stone(class, slen[0], member, klist);
d441 2
a442 2
	check(file1, f1, file2, f2);
	output(file1, f1, file2, f2, (flags & D_HEADER));
d470 1
d555 1
a555 1
prepare(int i, FILE *fd, off_t filesize)
d568 1
a568 1
	for (j = 0; (h = readhash(fd));) {
d648 1
a648 1
stone(int *a, int n, int *b, int *c)
d654 3
a656 1
	const u_int bound = dflag ? UINT_MAX : MAX(256, isqrt(n));
d717 3
a719 3
	while (1) {
		l = i + j;
		if ((l >>= 1) <= i)
d752 1
a752 1
check(char *file1, FILE *f1, char *file2, FILE *f2)
d772 1
a772 1
		if (bflag || wflag || iflag) {
d778 1
a778 1
				 * in one file if bflag || wflag.
d780 1
a780 1
				if ((bflag || wflag) &&
d787 2
a788 1
				if (bflag && isspace(c) && isspace(d)) {
d799 1
a799 1
				} else if (wflag) {
d954 1
a954 1
			dump_context_vec(f1, f2);
d956 1
a956 1
			dump_unified_vec(f1, f2);
d980 1
a980 1
preadline(int fd, size_t len, off_t off)
d985 2
a986 2
	line = xmalloc(len + 1);
	if ((nr = pread(fd, line, len, off)) < 0)
d1076 1
a1076 1
				dump_context_vec(f1, f2);
d1078 1
a1078 1
				dump_unified_vec(f1, f2);
d1118 1
a1118 1
		fetch(ixold, a, b, f1, '<', 1);
d1122 1
a1122 1
	i = fetch(ixnew, c, d, f2, format == D_NORMAL ? '>' : '\0', 0);
d1146 1
a1146 1
fetch(long *f, int a, int b, FILE *lb, int ch, int oldfile)
d1196 1
a1196 1
			if (c == '\t' && tflag) {
d1225 1
a1225 1
readhash(FILE *f)
d1232 2
a1233 2
	if (!bflag && !wflag) {
		if (iflag)
d1262 1
a1262 1
				if (space && !wflag) {
d1290 1
a1290 1
	int i, cnt;
d1292 1
a1292 1
	if (aflag || f == NULL)
d1306 1
a1306 1
match_function(const long *f, int pos, FILE *file)
d1315 1
a1315 1
		fseek(file, f[pos - 1], SEEK_SET);
d1319 1
a1319 1
		nc = fread(buf, 1, nc, file);
d1351 1
a1351 1
dump_context_vec(FILE *f1, FILE *f2)
d1368 1
a1368 1
	if (pflag) {
d1404 1
a1404 1
				fetch(ixold, lowa, b, f1, ' ', 0);
d1406 1
a1406 1
				fetch(ixold, lowa, a - 1, f1, ' ', 0);
d1408 1
a1408 1
				    ch == 'c' ? '!' : '-', 0);
d1413 1
a1413 1
		fetch(ixold, b + 1, upb, f1, ' ', 0);
d1440 1
a1440 1
				fetch(ixnew, lowc, d, f2, ' ', 0);
d1442 1
a1442 1
				fetch(ixnew, lowc, c - 1, f2, ' ', 0);
d1444 1
a1444 1
				    ch == 'c' ? '!' : '+', 0);
d1449 1
a1449 1
		fetch(ixnew, d + 1, upd, f2, ' ', 0);
d1456 1
a1456 1
dump_unified_vec(FILE *f1, FILE *f2)
d1477 1
a1477 1
	if (pflag) {
d1508 3
a1510 3
			fetch(ixold, lowa, a - 1, f1, ' ', 0);
			fetch(ixold, a, b, f1, '-', 0);
			fetch(ixnew, c, d, f2, '+', 0);
d1513 2
a1514 2
			fetch(ixold, lowa, a - 1, f1, ' ', 0);
			fetch(ixold, a, b, f1, '-', 0);
d1517 2
a1518 2
			fetch(ixnew, lowc, c - 1, f2, ' ', 0);
			fetch(ixnew, c, d, f2, '+', 0);
d1524 1
a1524 1
	fetch(ixnew, d + 1, upd, f2, ' ', 0);
@


1.69
log
@- Change sizeof(type) to sizeof(*ptr).
- Move function prototypes before variables.

No binary change.

OK otto and millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.68 2007/05/29 18:24:56 ray Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.68 2007/05/29 18:24:56 ray Exp $";
a1302 1
	char *p;
d1314 2
a1315 3
			p = strchr(buf, '\n');
			if (p != NULL)
				*p = '\0';
@


1.68
log
@Bring in some changes from rcsdiff:
1. Replace all the e*alloc functions with the x*alloc versions.
2. Whitespace syncs according to style.
3. Remove the __inline stuff.
4. Remove the min/max functions, using the MAX/MIN macros instead.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.67 2007/03/18 21:12:27 espie Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.67 2007/03/18 21:12:27 espie Exp $";
d179 28
a231 28
static FILE *opentemp(const char *);
static void output(char *, FILE *, char *, FILE *, int);
static void check(char *, FILE *, char *, FILE *);
static void range(int, int, char *);
static void uni_range(int, int);
static void dump_context_vec(FILE *, FILE *);
static void dump_unified_vec(FILE *, FILE *);
static void prepare(int, FILE *, off_t);
static void prune(void);
static void equiv(struct line *, int, struct line *, int, int *);
static void unravel(int);
static void unsort(struct line *, int, int *);
static void change(char *, FILE *, char *, FILE *, int, int, int, int, int *);
static void sort(struct line *, int);
static void print_header(const char *, const char *);
static int  ignoreline(char *);
static int  asciifile(FILE *);
static int  fetch(long *, int, int, FILE *, int, int);
static int  newcand(int, int, int);
static int  search(int *, int, int);
static int  skipline(FILE *);
static int  isqrt(int);
static int  stone(int *, int, int *, int *);
static int  readhash(FILE *);
static int  files_differ(FILE *, FILE *, int);
static char *match_function(const long *, int, FILE *);
static char *preadline(int, size_t, off_t);

d416 1
a416 1
	member = xrealloc(member, slen[1] + 2, sizeof(int));
d420 1
a420 1
	class = xrealloc(class, slen[0] + 2, sizeof(int));
d422 1
a422 1
	klist = xmalloc((slen[0] + 2) * sizeof(int));
d425 1
a425 1
	clist = xmalloc(clistlen * sizeof(struct cand));
d430 1
a430 1
	J = xrealloc(J, len[0] + 2, sizeof(int));
d435 2
a436 2
	ixold = xrealloc(ixold, len[0] + 2, sizeof(long));
	ixnew = xrealloc(ixnew, len[1] + 2, sizeof(long));
d562 1
a562 1
	p = xmalloc((sz + 3) * sizeof(struct line));
d566 1
a566 1
			p = xrealloc(p, sz + 3, sizeof(struct line));
d692 1
a692 1
		clist = xrealloc(clist, clistlen, sizeof(struct cand));
d880 1
a880 1
	a = xmalloc((l + 1) * sizeof(int));
d1051 1
a1051 1
			    max_context, sizeof(struct context_vec));
@


1.67
log
@improve -p for C++ code: classes definition often have
public:/protected:/private: at the start of line.
This lets the -p scanner just take note of the section and keep
looking for the actual class definition.

Also increase function name bufsize so it shows most of these pesky C++
decls...

okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.66 2007/02/23 08:03:19 espie Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.66 2007/02/23 08:03:19 espie Exp $";
d87 1
d157 3
a159 3
	int x;
	int y;
	int pred;
d163 2
a164 2
	int serial;
	int value;
d173 4
a176 4
	int a;			/* start line in old file */
	int b;			/* end line in old file */
	int c;			/* start line in new file */
	int d;			/* end line in new file */
a228 2
static __inline int min(int, int);
static __inline int max(int, int);
d376 1
a376 1
		easprintf(&header, "%s %s %s", diffargs, file1, file2);
d385 1
a385 1
			free(header);
d405 1
a405 1
			free(header);
d416 1
a416 1
	member = erealloc(member, (slen[1] + 2) * sizeof(int));
d420 1
a420 1
	class = erealloc(class, (slen[0] + 2) * sizeof(int));
d422 1
a422 1
	klist = emalloc((slen[0] + 2) * sizeof(int));
d425 1
a425 1
	clist = emalloc(clistlen * sizeof(struct cand));
d427 2
a428 2
	free(member);
	free(class);
d430 1
a430 1
	J = erealloc(J, (len[0] + 2) * sizeof(int));
d432 2
a433 2
	free(clist);
	free(klist);
d435 2
a436 2
	ixold = erealloc(ixold, (len[0] + 2) * sizeof(long));
	ixnew = erealloc(ixnew, (len[1] + 2) * sizeof(long));
d463 1
a463 1
		free(file1);
d465 1
a465 1
		free(file2);
d545 1
a545 1
	easprintf(&buf, "%s/%s", dir, tail);
d562 1
a562 1
	p = emalloc((sz + 3) * sizeof(struct line));
d566 1
a566 1
			p = erealloc(p, (sz + 3) * sizeof(struct line));
d630 1
a630 1
		return(0);
d649 1
a649 1
	const u_int bound = dflag ? UINT_MAX : max(256, isqrt(n));
d692 1
a692 1
		clist = erealloc(clist, clistlen * sizeof(struct cand));
d880 1
a880 1
	a = emalloc((l + 1) * sizeof(int));
d885 1
a885 1
	free(a);
d952 1
a952 1
static __inline void
d960 1
a960 1
static __inline void
d977 1
a977 1
	line = emalloc(len + 1);
d992 1
a992 1
	free(line);
d1050 2
a1051 2
			context_vec_start = erealloc(context_vec_start,
			    max_context * sizeof(struct context_vec));
a1294 10
static __inline int min(int a, int b)
{
	return (a < b ? a : b);
}

static __inline int max(int a, int b)
{
	return (a > b ? a : b);
}

d1356 4
a1359 4
	lowa = max(1, cvp->a - context);
	upb = min(len[0], context_vec_ptr->b + context);
	lowc = max(1, cvp->c - context);
	upd = min(len[1], context_vec_ptr->d + context);
d1461 4
a1464 4
	lowa = max(1, cvp->a - context);
	upb = min(len[0], context_vec_ptr->b + context);
	lowc = max(1, cvp->c - context);
	upd = min(len[1], context_vec_ptr->d + context);
@


1.66
log
@print the header only once.
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.65 2007/02/22 01:44:36 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.65 2007/02/22 01:44:36 millert Exp $";
d198 1
a198 1
#define FUNCTION_CONTEXT_SIZE	41
d1306 2
d1315 1
d1330 17
a1346 3
				strlcpy(lastbuf, buf, sizeof lastbuf);
				lastmatchline = pos;
				return lastbuf;
@


1.65
log
@Defer printing of the per-file diff header until after the regexp
"ignore" processing has finished.  This way we only print the header
for files that have diffs.  The new behavior matches GNU diff (which
is where the -I flag comes from).  OK otto@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.64 2006/02/22 07:26:08 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.64 2006/02/22 07:26:08 otto Exp $";
d215 1
a215 1
static void change(char *, FILE *, char *, FILE *, int, int, int, int, int);
d919 1
a919 1
			change(file1, f1, file2, f2, i0, i1, j0, j1, flags);
d931 1
a931 1
			change(file1, f1, file2, f2, i1, i0, j1, j0, flags);
d935 1
a935 1
		change(file1, f1, file2, f2, 1, 0, 1, len[1], flags);
d1006 1
a1006 1
    int flags)
d1040 1
a1040 1
	if (flags & D_HEADER)
d1042 2
@


1.64
log
@Append two string using strlcpy()/strlcat() instead of snprintf() to
avoid having to check for encoding errors returned by snprintf().
From Ray Lai; ok millert@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.63 2006/02/16 08:15:05 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.63 2006/02/16 08:15:05 otto Exp $";
d204 1
a204 1
static void output(char *, FILE *, char *, FILE *);
d215 1
a215 1
static void change(char *, FILE *, char *, FILE *, int, int, int, int);
d408 1
a408 2
	} else if (flags & D_HEADER)
		printf("%s %s %s\n", diffargs, file1, file2);
d439 1
a439 1
	output(file1, f1, file2, f2);
d900 1
a900 1
output(char *file1, FILE *f1, char *file2, FILE *f2)
d919 1
a919 1
			change(file1, f1, file2, f2, i0, i1, j0, j1);
d931 1
a931 1
			change(file1, f1, file2, f2, i1, i0, j1, j0);
d935 1
a935 1
		change(file1, f1, file2, f2, 1, 0, 1, len[1]);
d1005 2
a1006 1
change(char *file1, FILE *f1, char *file2, FILE *f2, int a, int b, int c, int d)
d1040 2
@


1.63
log
@Strip newline from lines used with -I, otherwise ^$ will match all
lines and ignore them all. With and ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.62 2005/01/13 08:27:45 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.62 2005/01/13 08:27:45 otto Exp $";
d514 4
a517 2
	if (snprintf(tempfile, sizeof(tempfile), "%s/diff.XXXXXXXX",
	    tempdir) >= sizeof(tempfile)) {
@


1.62
log
@Handle all isspace() chars the same for -w and -b. ok millert@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.61 2004/12/09 18:56:10 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.61 2004/12/09 18:56:10 millert Exp $";
d980 2
@


1.61
log
@If the -L option is specified twice, use it for the second filename
like GNU diff does.  Adapted from a diff by YAMAMOTO Takashi
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.60 2004/11/27 19:16:25 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.60 2004/11/27 19:16:25 otto Exp $";
d1240 3
@


1.60
log
@Use unsigned char for bytes that are fed to isxxx() functions, to improve
portability. Spotted by YAMAMOTO Takashi.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.59 2004/10/20 08:52:19 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.59 2004/10/20 08:52:19 otto Exp $";
d217 1
d1052 1
a1052 10
			if (label != NULL)
				printf("%s %s\n",
				    format == D_CONTEXT ? "***" : "---", label);
			else
				printf("%s %s\t%s",
				    format == D_CONTEXT ? "***" : "---", file1,
				    ctime(&stb1.st_mtime));
			printf("%s %s\t%s",
			    format == D_CONTEXT ? "---" : "+++", file2,
			    ctime(&stb2.st_mtime));
d1504 17
@


1.59
log
@Change tabs in string constants to \t. "of course" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.58 2004/09/14 23:04:27 deraadt Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.58 2004/09/14 23:04:27 deraadt Exp $";
d1279 1
a1279 1
	char buf[BUFSIZ];
d1306 1
a1306 1
	char buf[FUNCTION_CONTEXT_SIZE];
@


1.58
log
@use sizeof(struct cand) instead of defining an unused cand object, and
then doing sizeof(cand).  silly kids
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.57 2004/06/20 18:47:45 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.57 2004/06/20 18:47:45 otto Exp $";
d1055 1
a1055 1
				printf("%s %s	%s",
d1058 1
a1058 1
			printf("%s %s	%s",
@


1.57
log
@Implement -I option: ignore changes matching a set of regexes.  From
Jared Yanovich, with twists from millert@@ and me. Testing by brad@@,
sturm@@ and pval@@. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.56 2004/06/18 07:23:50 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.56 2004/06/18 07:23:50 otto Exp $";
d159 1
a159 1
} cand;
d426 1
a426 1
	clist = emalloc(clistlen * sizeof(cand));
d691 1
a691 1
		clist = erealloc(clist, clistlen * sizeof(cand));
@


1.56
log
@If a new hunk immediately follows the previous one, merge them
into a single hunk. This makes diff produce the same diff as gdiff
in more cases. Found by brad@@ and sturm@@ using the ports tree.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.55 2004/01/07 17:18:32 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.55 2004/01/07 17:18:32 otto Exp $";
d217 1
d230 1
d970 23
d1009 26
@


1.55
log
@Implement -p option.

"works here" millert@@ ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.54 2003/11/22 18:02:44 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.54 2003/11/22 18:02:44 millert Exp $";
d1011 2
a1012 2
		} else if (a > context_vec_ptr->b + (2 * context) &&
		    c > context_vec_ptr->d + (2 * context)) {
@


1.54
log
@Fix diff -q exit value which was broken in last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.53 2003/11/21 01:28:01 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.53 2003/11/21 01:28:01 millert Exp $";
d198 5
d228 1
d301 2
d1252 31
d1290 1
a1290 1
	char ch;
d1301 9
a1309 1
	printf("***************\n*** ");
d1395 1
a1395 1
	char ch;
d1410 9
a1418 1
	fputs(" @@@@\n", stdout);
@


1.53
log
@Fix broken assumption that a file must contain differences if files_differ()
fails.  Fixes "diff -i" exit value.  Problem found by Claudio Jeker.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.52 2003/11/10 18:51:35 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.52 2003/11/10 18:51:35 millert Exp $";
d357 1
a359 2
	if (format == D_BRIEF)
		goto closem;
d1025 2
@


1.52
log
@Din't print the "No newline at end of file" to inline (ie: to stdout)
for edit scripts.  Instead, print it to stderr.  This matches the
GNU diff behavior and fixes a problem with RCS and files with no
trailing newline.  tedu@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.51 2003/10/28 13:23:59 avsm Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.51 2003/10/28 13:23:59 avsm Exp $";
a354 5
	/*
	 * Files certainly differ at this point; set status accordingly
	 */
	status |= 1;
	rval = D_DIFFER;
d445 5
@


1.51
log
@prototype declared static, but function was not. add static to function.
millert@@ otto@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.50 2003/09/07 07:53:01 tedu Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.50 2003/09/07 07:53:01 tedu Exp $";
d1122 6
a1127 2
				puts("\n\\ No newline at end of file");
				return (0);;
@


1.50
log
@correct ascii file test.  ok deraadt@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.49 2003/08/13 20:44:15 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.49 2003/08/13 20:44:15 millert Exp $";
d1212 1
a1212 1
int
@


1.49
log
@Based on what otto@@ said on icb.  The expensive thing in diff is
newcand() (this is what blows up the memory usage so badly).  Instead
of counting how many times we go through the loop, count how many
times we called newcand().  I renamed loopcount -> numtries since
it is no longer the number of loop runs.  This fixes espie@@'s regression.
tedu@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.48 2003/08/08 16:09:26 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.48 2003/08/08 16:09:26 otto Exp $";
d1215 1
a1215 1
	char buf[BUFSIZ], *cp;
a1222 1
	cp = buf;
d1224 1
a1224 1
		if (!isprint(*cp) && !isspace(*cp))
@


1.48
log
@Guess the number of lines in a file and use that number for initial
memory allocation. Initial version by me, cleanup by millert@@.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.47 2003/07/31 20:00:03 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.47 2003/07/31 20:00:03 otto Exp $";
d637 1
a637 1
	u_int loopcount;
d650 1
a650 1
		loopcount = 0;
a651 1
			loopcount++;
d664 1
d670 1
a670 1
		} while ((y = b[++j]) > 0 && loopcount < bound);
@


1.47
log
@- Change the hash function to a simple multiplicative one. The old
hash function was apparently optimized for 16 bit processors and
generates quite some collisions.
- Fix another case of excessive reallocing.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.46 2003/07/31 02:53:57 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.46 2003/07/31 02:53:57 millert Exp $";
d205 1
a205 1
static void prepare(int, FILE *);
d405 2
a406 2
	prepare(0, f1);
	prepare(1, f2);
d540 1
a540 1
prepare(int i, FILE *fd)
d544 1
a544 1
	int sz;
d547 5
a551 1
	sz = 100;
@


1.46
log
@o correct exit code when comparing stdin and stdin (a noop)
o after copying to a temp file, lseek() to the beginning so the
  inline cmp routine works.
Fixes an exit code issue when comparing against stdin.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.45 2003/07/29 18:38:47 deraadt Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.45 2003/07/29 18:38:47 deraadt Exp $";
d544 1
d547 2
a548 1
	p = emalloc(3 * sizeof(struct line));
d550 5
a554 2
		p = erealloc(p, (++j + 3) * sizeof(struct line));
		p[j].value = h;
a1145 2
#define HASHMASK (16 - 1)	/* for masking out 16 bytes */

d1147 1
a1147 3
 * hashing has the effect of
 * arranging line in 7-bit bytes and then
 * summing 1-s complement in 16-bit hunks
d1152 2
a1153 3
	unsigned int shift;
	int t, space;
	long sum;
d1159 1
a1159 1
			for (shift = 0; (t = getc(f)) != '\n'; shift += 7) {
d1161 1
a1161 1
					if (shift == 0)
d1165 1
a1165 1
				sum += (long)chrtran[t] << (shift &= HASHMASK);
d1168 1
a1168 1
			for (shift = 0; (t = getc(f)) != '\n'; shift += 7) {
d1170 1
a1170 1
					if (shift == 0)
d1174 1
a1174 1
				sum += (long)t << (shift &= HASHMASK);
d1177 1
a1177 1
		for (shift = 0;;) {
d1185 1
a1185 1
					shift += 7;
d1188 2
a1189 2
				sum += (long)chrtran[t] << (shift &= HASHMASK);
				shift += 7;
d1192 1
a1192 1
				if (shift == 0)
d1201 5
a1205 1
	return (sum);
@


1.45
log
@clean
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.44 2003/07/27 18:58:26 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.44 2003/07/27 18:58:26 millert Exp $";
d300 1
a300 1
		goto notsame;
a354 1
notsame:
d522 1
@


1.44
log
@We need to initialize clen to 0 each time through diffreg() for
when diffreg() is called multiple times (i.e. in directory mode).
Fixes a hang I saw doing "diff -r" of two large directory trees.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.43 2003/07/27 07:39:52 otto Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.43 2003/07/27 07:39:52 otto Exp $";
d629 1
a629 1
	
@


1.43
log
@- Use a heuristic to bound  memory and cpu usage, at the cost of
producing suboptimal diffs for large file containing lots of changes.
Switch heuristic off with -d/--minimal (GNU compatible). Some hints
from millert@@.
- Improve performance by reducing the number of realloc(3) calls.

ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.42 2003/07/23 22:01:36 tedu Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.42 2003/07/23 22:01:36 tedu Exp $";
d421 1
@


1.42
log
@better ascii test for fewer false negatives.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.41 2003/07/22 01:16:01 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.41 2003/07/22 01:16:01 millert Exp $";
d191 1
d217 1
d221 3
d421 2
a422 1
	clist = emalloc(sizeof(cand));
d603 19
d627 3
d640 1
d642 1
d660 1
a660 1
		} while ((y = b[++j]) > 0);
d670 5
a674 2
	clist = erealloc(clist, ++clen * sizeof(cand));
	q = clist + clen - 1;
d678 1
a678 1
	return (clen - 1);
@


1.41
log
@Implement the -L and -T options from GNU diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.40 2003/07/22 00:20:40 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.40 2003/07/22 00:20:40 millert Exp $";
d1174 1
a1174 1
	int cnt;
d1182 2
a1183 2
	while (--cnt >= 0)
		if (*cp++ & 0200)
@


1.40
log
@Historically, when comparing two directories in -e mode, BSD diff
printed a header that turned the output into an actual script that
called ed(1) to make the changes.  This conflicts with POSIX so the
header has been removed and the standard diff header is used instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.39 2003/07/22 00:15:55 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.39 2003/07/22 00:15:55 millert Exp $";
d212 1
a212 1
static int  fetch(long *, int, int, FILE *, char *, int);
d950 10
a959 4
			printf("%s %s	%s", format == D_CONTEXT ? "***" : "---",
			   file1, ctime(&stb1.st_mtime));
			printf("%s %s	%s", format == D_CONTEXT ? "---" : "+++",
			    file2, ctime(&stb2.st_mtime));
d1008 1
a1008 1
		fetch(ixold, a, b, f1, "< ", 1);
d1012 1
a1012 1
	i = fetch(ixnew, c, d, f2, format == D_NORMAL ? "> " : "", 0);
d1036 1
a1036 1
fetch(long *f, int a, int b, FILE *lb, char *s, int oldfile)
d1068 8
a1075 2
		if (format != D_IFDEF)
			fputs(s, stdout);
d1245 1
a1245 1
				fetch(ixold, lowa, b, f1, "  ", 0);
d1247 1
a1247 1
				fetch(ixold, lowa, a - 1, f1, "  ", 0);
d1249 1
a1249 1
				    ch == 'c' ? "! " : "- ", 0);
d1254 1
a1254 1
		fetch(ixold, b + 1, upb, f1, "  ", 0);
d1281 1
a1281 1
				fetch(ixnew, lowc, d, f2, "  ", 0);
d1283 1
a1283 1
				fetch(ixnew, lowc, c - 1, f2, "  ", 0);
d1285 1
a1285 1
				    ch == 'c' ? "! " : "+ ", 0);
d1290 1
a1290 1
		fetch(ixnew, d + 1, upd, f2, "  ", 0);
d1341 3
a1343 3
			fetch(ixold, lowa, a - 1, f1, " ", 0);
			fetch(ixold, a, b, f1, "-", 0);
			fetch(ixnew, c, d, f2, "+", 0);
d1346 2
a1347 2
			fetch(ixold, lowa, a - 1, f1, " ", 0);
			fetch(ixold, a, b, f1, "-", 0);
d1350 2
a1351 2
			fetch(ixnew, lowc, c - 1, f2, " ", 0);
			fetch(ixnew, c, d, f2, "+", 0);
d1357 1
a1357 1
	fetch(ixnew, d + 1, upd, f2, " ", 0);
@


1.39
log
@Don't print lines consisting solely of a dot ('.') in -e mode since
that will confuse ed(1).
POSIX says "one way to fix this bug is to output two periods whenever a lone
period is needed, then terminate the append command with a period, and then
use the substitute command to convert the two periods into one period."
This is exactly what I have done.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.38 2003/07/21 21:59:58 henning Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.38 2003/07/21 21:59:58 henning Exp $";
a78 1
#include <libgen.h>
d399 2
a400 9
	} else {
		if (flags & D_HEADER) {
			if (format == D_EDIT)
				printf("ed - %s << '-*-END-*-'\n",
				    basename(file1));
			else
				printf("%s %s %s\n", diffargs, file1, file2);
		}
	}
d442 1
a442 2
	} else if ((flags & D_HEADER) && format == D_EDIT)
		printf("w\nq\n-*-END-*-\n");
@


1.38
log
@a little KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.37 2003/07/21 21:57:22 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.37 2003/07/21 21:57:22 millert Exp $";
a198 1
static void fetch(long *, int, int, FILE *, char *, int);
d213 1
d938 1
d940 1
d1015 15
a1029 1
	fetch(ixnew, c, d, f2, format == D_NORMAL ? "> " : "", 0);
d1038 1
a1038 1
static void
d1041 1
a1041 1
	int i, j, c, col, nc;
d1055 1
a1055 1
		return;
d1074 1
a1074 1
		for (j = 0; j < nc; j++) {
d1077 1
a1077 1
				return;
d1084 12
d1101 1
@


1.37
log
@POSIX-compliant output when there are two paths w/ the same name but
one is a file and the other is a directory in -r mode (cosmetic).
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.36 2003/07/21 15:56:48 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.36 2003/07/21 15:56:48 millert Exp $";
d967 1
a967 1
			 */ 
@


1.36
log
@Expand change records array as needed; passes Otto's new regression test.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.35 2003/07/17 21:54:28 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.35 2003/07/17 21:54:28 millert Exp $";
d294 1
a294 1
		return (D_MISMATCH);
@


1.35
log
@cc -O2 -pipe  -DSTDC_HEADERS=1 -DHAVE_UNISTD_H=1 -DDIRENT=1 -DDYN_ALLOC   -c unpGet rid of ugly hack in readhash() that appears to be there for
machines with a 16 bit word size.  Also replace (HALFLONG - 1) with
a new define, HASHMASK since it really is a mask.
None of this results in any actual change in behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.34 2003/07/16 21:39:06 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.34 2003/07/16 21:39:06 millert Exp $";
d80 1
d167 12
d194 3
d291 1
a927 16
 * The following struct is used to record change information when
 * doing a "context" or "unified" diff.  (see routine "change" to
 * understand the highly mnemonic field names)
 */
struct context_vec {
	int a;			/* start line in old file */
	int b;			/* end line in old file */
	int c;			/* start line in new file */
	int d;			/* end line in new file */
};

struct context_vec *context_vec_start, *context_vec_end, *context_vec_ptr;

#define	MAX_CONTEXT	128

/*
d937 2
d941 16
a956 3
	if (anychange == 0) {
		anychange = 1;
		if (format == D_CONTEXT || format == D_UNIFIED) {
d961 7
a967 19
			if (context_vec_start == NULL)
				context_vec_start = emalloc(MAX_CONTEXT *
				    sizeof(struct context_vec));
			context_vec_end = context_vec_start + MAX_CONTEXT;
			context_vec_ptr = context_vec_start - 1;
		}
	}
	if (format == D_CONTEXT || format == D_UNIFIED) {
		/*
		 * If this new change is within 'context' lines of
		 * the previous change, just add it to the change
		 * record.  If the record is full or if this
		 * change is more than 'context' lines from the previous
		 * change, dump the record, reset it & add the new change.
		 */
		if (context_vec_ptr >= context_vec_end ||
		    (context_vec_ptr >= context_vec_start &&
		    a > (context_vec_ptr->b + 2 * context) &&
		    c > (context_vec_ptr->d + 2 * context))) {
d980 2
@


1.34
log
@Deal with files that lack a final newline before EOF (you naughty
emacs users!).  In most cases this just means checking for EOF in
addition to '\n'.  However, we need to tread carefully in readhash().
There we return 0 on EOF iff it is the first char in a "line".

Additionally, if the -b or -w flags were specified and the last
character in one file was '\n' but the other file is missing '\n',
pretend that we didn't see the newline in the one file.  This is
consistent with GNU diff.  For the non-{b,w} case, print
"\ No newline at end of file" when we see EOF before a newline in
one file where the other file has one.  Again, this is for consistency
with GNU diff and patch(1) in -current knows how to interpret this
message.

OK tedu@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.33 2003/07/15 23:17:56 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.33 2003/07/15 23:17:56 millert Exp $";
d1069 1
a1069 4
#define POW2			/* define only if HALFLONG is 2**n */
#define HALFLONG 16
#define low(x)	(x&((1L<<HALFLONG)-1))
#define high(x)	(x>>HALFLONG)
d1093 1
a1093 6
				sum += (long)chrtran[t] << (shift
#ifdef POW2
				    &= HALFLONG - 1);
#else
				    %= HALFLONG);
#endif
d1102 1
a1102 6
				sum += (long)t << (shift
#ifdef POW2
				    &= HALFLONG - 1);
#else
				    %= HALFLONG);
#endif
d1116 1
a1116 6
				sum += (long)chrtran[t] << (shift
#ifdef POW2
				    &= HALFLONG - 1);
#else
				    %= HALFLONG);
#endif
d1129 1
a1129 2
	sum = low(sum) + high(sum);
	return ((short) low(sum) + (short) high(sum));
@


1.33
log
@Fix line ranges for unidiffs.  Problem noted by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.32 2003/07/09 00:39:26 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.32 2003/07/09 00:39:26 millert Exp $";
d708 9
d743 1
a743 1
					if (c != '\n')
d745 1
a745 1
					if (d != '\n')
d749 1
a749 1
				if (c == '\n')
d759 1
a759 1
					if (c != '\n')
d761 1
a761 1
					if (d != '\n')
d765 1
a765 1
				if (c == '\n')
d832 2
a833 3
	for (i = 1; (c = getc(f)) != '\n'; i++)
		if (c < 0)
			return (i);
d877 1
a877 2
			c = getc(f1);
			if (c < 0)
d1053 6
a1058 3
			c = getc(lb);
			if (c == '\t' && tflag)
				do
d1060 2
a1061 2
				while (++col & 7);
			else {
d1091 5
a1095 2
				if (t == -1)
					return (0);
d1105 5
a1109 2
				if (t == -1)
					return (0);
a1119 2
			case -1:
				return (0);
d1137 4
@


1.32
log
@Unlink temp file as soon as it is opened and return a FILE * for
it so we don't have to worry about cleanup.  This means the quit()
signal handler and error/errorx can go away too.

Move splice() out of diffreg() and into diff.c where it belongs
since we don't want to be calling splice() for a directory diff.
Add a check for mismatched paths (one file, one dir) in diffreg.c.

deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.31 2003/07/09 00:07:44 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.31 2003/07/09 00:07:44 millert Exp $";
d187 1
d884 19
a1009 8
range(int a, int b, char *separator)
{
	printf("%d", a > b ? b : a);
	if (a < b)
		printf("%s%d", separator, b);
}

static void
d1276 5
a1280 2
	printf("@@@@ -%d,%d +%d,%d @@@@\n", lowa, upb - lowa + 1,
	    lowc, upd - lowc + 1);
@


1.31
log
@Re-implement -l flag; diff -l now works correctly in non-directory
mode (like GNU diff).
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.30 2003/07/08 04:51:30 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.30 2003/07/08 04:51:30 millert Exp $";
d71 1
a71 1
#include <sys/types.h>
d77 1
a79 1
#include <signal.h>
d182 1
d275 2
a279 1
	/* XXX - only make temp file for stdin if not seekable? (millert) */
d283 3
a285 3
		if (S_ISDIR(stb1.st_mode)) {
			file1 = splice(file1, file2);
			if (stat(file1, &stb1) < 0) {
d290 1
a290 9
		} else if (!S_ISREG(stb1.st_mode)) {
			file1 = copytemp(file1, 1);
			if (file1 == NULL || stat(file1, &stb1) < 0) {
				warn("%s", file1);
				status |= 2;
				goto closem;
			}
		}
		if (strcmp(file1, "-") == 0)
d304 3
a306 10
		if (S_ISDIR(stb2.st_mode)) {
			file2 = splice(file2, file1);
			if (stat(file2, &stb2) < 0) {
				warn("%s", file2);
				status |= 2;
				goto closem;
			}
		} else if (!S_ISREG(stb2.st_mode)) {
			file2 = copytemp(file2, 2);
			if (file2 == NULL || stat(file2, &stb2) < 0) {
d311 1
a311 2
		}
		if (strcmp(file2, "-") == 0)
d439 1
a439 5
	if (tempfiles[0] != NULL) {
		unlink(tempfiles[0]);
		free(tempfiles[0]);
		tempfiles[0] = NULL;
	} else if (file1 != ofile1)
d441 1
a441 5
	if (tempfiles[1] != NULL) {
		unlink(tempfiles[1]);
		free(tempfiles[1]);
		tempfiles[1] = NULL;
	} else if (file2 != ofile2)
d475 2
a476 5
char *tempfiles[2];

/* XXX - pass back a FILE * too (millert) */
char *
copytemp(const char *file, int n)
d478 3
a480 5
	char buf[BUFSIZ], *tempdir, *tempfile;
	int i, ifd, ofd;

	if (n != 1 && n != 2)
		return (NULL);
d489 4
a492 1
	if (asprintf(&tempfile, "%s/diff%d.XXXXXXXX", tempdir, n) == -1)
d494 1
a494 1
	tempfiles[n - 1] = tempfile;
d496 1
a496 7
	signal(SIGHUP, quit);
	signal(SIGINT, quit);
	signal(SIGPIPE, quit);
	signal(SIGTERM, quit);
	signal(SIGPIPE, SIG_IGN);
	ofd = mkstemp(tempfile);
	if (ofd < 0)
d498 5
a502 2
	while ((i = read(ifd, buf, BUFSIZ)) > 0) {
		if (write(ofd, buf, i) != i)
d504 1
d507 1
a507 2
	close(ofd);
	return (tempfile);
d515 1
a515 2
	tail = strrchr(file, '/');
	if (tail == NULL)
@


1.30
log
@fix pasto in last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.29 2003/07/08 04:45:32 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.29 2003/07/08 04:45:32 millert Exp $";
d73 1
a78 1
#include <paths.h>
d86 1
d261 1
a261 1
void
d268 3
a270 1
	int i;
d338 1
a338 1
		goto same;
d352 3
a354 2
	if (format == D_BRIEF) {
		printf("Files %s and %s differ\n", file1, file2);
d357 1
a357 8
	if (flags & D_HEADER) {
		if (format == D_EDIT)
			printf("ed - %s << '-*-END-*-'\n", basename(file1));
		else
			printf("%s %s %s\n", diffargs, file1, file2);
	}
	if (!asciifile(f1) || !asciifile(f2)) {
		printf("Binary files %s and %s differ\n", file1, file2);
d359 45
d434 13
a446 1
	if ((flags & D_HEADER) && format == D_EDIT)
a447 4
same:
	if (anychange == 0 && sflag != 0)
		printf("Files %s and %s are identical\n", file1, file2);

d465 1
d524 1
a540 1
	size_t len;
d547 1
a547 3
	len = strlen(dir) + 1 + strlen(tail) + 1;
	buf = emalloc(len);
	snprintf(buf, len, "%s/%s", dir, tail);
d1012 1
a1012 1
		fprintf(stdout, "#endif /* %s */\n", ifdefname);
d1045 1
a1045 1
			fprintf(stdout, "#else /* %s%s */\n",
d1049 1
a1049 1
				fprintf(stdout, "#ifndef %s\n", ifdefname);
d1051 1
a1051 1
				fprintf(stdout, "#ifdef %s\n", ifdefname);
@


1.29
log
@o Avoid a temp file if using stdin and stdin is redirected from a regular file
o Fix a double free in the temmp file case
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.28 2003/07/06 22:17:21 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.28 2003/07/06 22:17:21 millert Exp $";
d314 1
a314 1
		} else if (!S_ISREG(stb1.st_mode)) {
@


1.28
log
@Add -q option from GNU diff
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.27 2003/07/06 20:48:59 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.27 2003/07/06 20:48:59 millert Exp $";
d285 1
a285 1
		} else if (strcmp(file1, "-") == 0 || !S_ISREG(stb1.st_mode)) {
d293 4
a296 1
		f1 = fopen(file1, "r");
d314 1
a314 1
		} else if (strcmp(file2, "-") == 0 || !S_ISREG(stb2.st_mode)) {
d322 4
a325 1
		f2 = fopen(file2, "r");
d407 2
a408 1
	}
d413 1
a413 4
	}
	if (file1 != ofile1)
		free(file1);
	if (file2 != ofile2)
@


1.27
log
@Some fairly major changes:
 o -N is implemented
 o -X is implemented
 o -x is implemented
 o diff.c has been rewritten and GNU long options are now supported
 o diffdir.c has been rewritten
    + no longer does fork + exec of /usr/bin/diff
    + can be called recursively (and will be for -r)
 o diff.h
    + don't include any .h files here any more, do it in the .c files
    + no Bell Labs code in this, gets a UCB copyright (the 32v sources
      only have a diff.c and there is nothing in common).
 o diffreg.c
    + most all remaining globals are now private to diffreg.c
    + files are only opened once
    + dynamically allocated objects are either freed or realloced
    + added missing UCB copyright (there were lots of UCB changes)
    + print correct thing when -s is specified
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.26 2003/07/04 17:37:07 millert Exp $	*/
d68 1
a68 1
static const char rcsid[] = "$OpenBSD: diffreg.c,v 1.26 2003/07/04 17:37:07 millert Exp $";
d343 4
@


1.26
log
@Kill diff -h, we don't use or want diffh.  Discussed w/ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.25 2003/07/04 02:54:36 millert Exp $	*/
d36 34
d72 1
d74 7
d82 1
a83 2
#include <fcntl.h>
#include <string.h>
a85 5
#include "pathnames.h"

#if 0
static char const sccsid[] = "@@(#)diffreg.c 4.21 4/6/90";
#endif
a153 4
#define	prints(s)	fputs(s,stdout)

FILE *input[2];

d165 15
a179 14
int len[2];
struct line *sfile[2];	/* shortened by pruning common prefix and suffix */
int slen[2];
int pref, suff;			/* length of prefix and suffix */
int inifdef;			/* whether or not we are in a #ifdef block */
int *class;			/* will be overlaid on file[0] */
int *member;			/* will be overlaid on file[1] */
int *klist;			/* will be overlaid on file[0] after class */
struct cand *clist;		/* merely a free storage pot for candidates */
int clen = 0;
int *J;				/* will be overlaid on class */
long *ixold;			/* will be overlaid on klist */
long *ixnew;			/* will be overlaid on file[1] */
u_char *chrtran;		/* translation table for case-folding */
d182 2
a183 2
static void output(void);
static void check(void);
d185 2
a186 2
static void dump_context_vec(void);
static void dump_unified_vec(void);
d192 1
a192 1
static void change(int, int, int, int);
d194 7
a200 6
static int newcand(int, int, int);
static int search(int *, int, int);
static int skipline(int);
static int asciifile(FILE *);
static int stone(int *, int, int *, int *);
static int readhash(FILE *);
d261 1
a261 1
diffreg(void)
d263 5
a267 3
	char buf1[BUFSIZ], buf2[BUFSIZ];
	FILE *f1, *f2;
	int i, j;
d269 1
a271 27
		errorx("can't specify - -");
	if (S_ISDIR(stb1.st_mode)) {
		file1 = splice(file1, file2);
		if (stat(file1, &stb1) < 0)
			error("%s", file1);
	} else if (strcmp(file1, "-") == 0 ||
	    (!S_ISREG(stb1.st_mode) && strcmp(file1, _PATH_DEVNULL) != 0)) {
		file1 = copytemp(file1, 1);
		if (stat(file1, &stb1) < 0)
			error("%s", file1);
	}
	if (S_ISDIR(stb2.st_mode)) {
		file2 = splice(file2, file1);
		if (stat(file2, &stb2) < 0)
			error("%s", file2);
	} else if (strcmp(file2, "-") == 0 ||
	    (!S_ISREG(stb2.st_mode) && strcmp(file2, _PATH_DEVNULL) != 0)) {
		file2 = copytemp(file2, 2);
		if (stat(file2, &stb2) < 0)
			error("%s", file2);
	}
	if ((f1 = fopen(file1, "r")) == NULL)
		error("%s", file1);
	if ((f2 = fopen(file2, "r")) == NULL)
		error("%s", file2);
	if ((stb1.st_mode & S_IFMT) != (stb2.st_mode & S_IFMT) ||
	    stb1.st_size != stb2.st_size)
d273 63
a335 14
	for (;;) {
		i = fread(buf1, 1, BUFSIZ, f1);
		j = fread(buf2, 1, BUFSIZ, f2);
		if (i < 0 || j < 0 || i != j)
			goto notsame;
		if (i == 0 && j == 0) {
			fclose(f1);
			fclose(f2);
			status = 0;	/* files don't differ */
			goto same;
		}
		for (j = 0; j < i; j++)
			if (buf1[j] != buf2[j])
				goto notsame;
d337 1
d342 7
a348 1
	status = 1;
d351 1
a351 1
		exit(status);
a354 2
	fclose(f1);
	fclose(f2);
d373 1
a373 1
	J = emalloc((len[0] + 2) * sizeof(int));
d378 6
a383 5
	ixold = emalloc((len[0] + 2) * sizeof(long));
	ixnew = emalloc((len[1] + 2) * sizeof(long));
	check();
	output();
	status = anychange;
d385 51
a435 2
	if (anychange == 0 && (opt == D_CONTEXT || opt == D_UNIFIED))
		printf("No differences encountered\n");
d440 1
d453 1
a453 1
		error("%s", file);
d458 1
a458 1
		error(NULL);
d461 4
a464 4
	signal(SIGHUP, done);
	signal(SIGINT, done);
	signal(SIGPIPE, done);
	signal(SIGTERM, done);
d467 1
a467 1
		error("%s", tempfile);
d470 1
a470 1
			error("%s", tempfile);
a482 2
	if (!strcmp(file, "-"))
		errorx("can't specify - with other arg directory");
d500 1
a500 1
	fseek(fd, 0L, SEEK_SET);
d654 1
a654 1
check(void)
d659 2
a660 4
	if ((input[0] = fopen(file1, "r")) == NULL)
		error("%s", file1);
	if ((input[1] = fopen(file2, "r")) == NULL)
		error("%s", file2);
d667 1
a667 1
			ixold[i] = ctold += skipline(0);
d671 1
a671 1
			ixnew[j] = ctnew += skipline(1);
d676 2
a677 2
				c = getc(input[0]);
				d = getc(input[1]);
d685 1
a685 1
					} while (isspace(c = getc(input[0])));
d690 1
a690 1
					} while (isspace(d = getc(input[1])));
d693 1
a693 1
						c = getc(input[0]);
d697 1
a697 1
						d = getc(input[1]);
d705 1
a705 1
						ctold += skipline(0);
d707 1
a707 1
						ctnew += skipline(1);
d717 1
a717 1
				if ((c = getc(input[0])) != (d = getc(input[1]))) {
d721 1
a721 1
						ctold += skipline(0);
d723 1
a723 1
						ctnew += skipline(1);
d734 2
a735 5
	for (; j <= len[1]; j++) {
		ixnew[j] = ctnew += skipline(1);
	}
	fclose(input[0]);
	fclose(input[1]);
d789 1
a789 1
skipline(int f)
d793 1
a793 1
	for (i = 1; (c = getc(input[f])) != '\n'; i++)
d800 1
a800 1
output(void)
d804 2
a805 2
	input[0] = fopen(file1, "r");
	input[1] = fopen(file2, "r");
d809 1
a809 1
	if (opt != D_EDIT) {
d819 1
a819 1
			change(i0, i1, j0, j1);
d831 1
a831 1
			change(i1, i0, j1, j0);
d835 2
a836 2
		change(1, 0, 1, len[1]);
	if (opt == D_IFDEF) {
d839 1
a839 1
			c = getc(input[0]);
d847 4
a850 4
		if (opt == D_CONTEXT)
			dump_context_vec();
		else if (opt == D_UNIFIED)
			dump_unified_vec();
d856 2
a857 2
 * doing a "context" diff.  (see routine "change" to understand the
 * highly mneumonic field names)
d871 2
a872 2
 * indicate that there is a difference between lines a and b of the from file
 * to get to lines c to d of the to file. If a is greater then b then there
d874 1
a874 1
 * lines appended (beginning at b). If c is greater than d then there are
d878 1
a878 1
change(int a, int b, int c, int d)
d880 1
a880 3
	struct stat stbuf;

	if (opt != D_IFDEF && a > b && c > d)
d884 8
a891 9
		if (opt == D_CONTEXT || opt == D_UNIFIED) {
			stat(file1, &stbuf);
			printf("%s %s	%s", opt == D_CONTEXT ? "***" : "---",
			   file1, ctime(&stbuf.st_mtime));
			stat(file2, &stbuf);
			printf("%s %s	%s", opt == D_CONTEXT ? "---" : "+++",
			    file2, ctime(&stbuf.st_mtime));
			context_vec_start = emalloc(MAX_CONTEXT *
			    sizeof(struct context_vec));
d896 1
a896 1
	if (opt == D_CONTEXT || opt == D_UNIFIED) {
d908 2
a909 2
			if (opt == D_CONTEXT)
				dump_context_vec();
d911 1
a911 1
				dump_unified_vec();
d920 1
a920 1
	switch (opt) {
d926 1
a926 1
		if (opt == D_NORMAL)
d946 8
a953 8
	if (opt == D_NORMAL || opt == D_IFDEF) {
		fetch(ixold, a, b, input[0], "< ", 1);
		if (a <= b && c <= d && opt == D_NORMAL)
			prints("---\n");
	}
	fetch(ixnew, c, d, input[1], opt == D_NORMAL ? "> " : "", 0);
	if ((opt == D_EDIT || opt == D_REVERSE) && c <= d)
		prints(".\n");
d977 1
a977 1
	if (opt == D_IFDEF && oldfile) {
d986 1
a986 1
	if (opt == D_IFDEF) {
d1001 2
a1002 2
		if (opt != D_IFDEF)
			prints(s);
d1092 1
a1092 1
static int
d1098 1
a1098 1
	if (aflag)
d1101 2
a1102 2
	fseek(f, 0L, SEEK_SET);
	cnt = fread(buf, 1, BUFSIZ, f);
d1110 10
d1122 1
a1122 1
dump_context_vec(void)
d1143 1
a1143 1
	 * output changes to the "old" file.  The first loop suppresses
d1167 1
a1167 1
				fetch(ixold, lowa, b, input[0], "  ", 0);
d1169 2
a1170 2
				fetch(ixold, lowa, a - 1, input[0], "  ", 0);
				fetch(ixold, a, b, input[0],
d1176 1
a1176 1
		fetch(ixold, b + 1, upb, input[0], "  ", 0);
d1203 1
a1203 1
				fetch(ixnew, lowc, d, input[1], "  ", 0);
d1205 2
a1206 2
				fetch(ixnew, lowc, c - 1, input[1], "  ", 0);
				fetch(ixnew, c, d, input[1],
d1212 1
a1212 1
		fetch(ixnew, d + 1, upd, input[1], "  ", 0);
d1219 1
a1219 1
dump_unified_vec(void)
d1260 3
a1262 3
			fetch(ixold, lowa, a - 1, input[0], " ", 0);
			fetch(ixold, a, b, input[0], "-", 0);
			fetch(ixnew, c, d, input[1], "+", 0);
d1265 2
a1266 2
			fetch(ixold, lowa, a - 1, input[0], " ", 0);
			fetch(ixold, a, b, input[0], "-", 0);
d1269 2
a1270 2
			fetch(ixnew, lowc, c - 1, input[1], " ", 0);
			fetch(ixnew, c, d, input[1], "+", 0);
d1276 1
a1276 1
	fetch(ixnew, d + 1, upd, input[1], " ", 0);
@


1.25
log
@Some cosmetic fixes:
o get rid of now-unused tempfile variable
o move inifdef into diffreg.c (only used there)
o correct a comment
o use _PATH_DIFF, _PATH_DIFFH and _PATH_PR instead of variables set to them
o get rid of hack to look for pr and diff in /bin
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.24 2003/07/02 18:54:13 millert Exp $	*/
a232 5
	if (hflag) {
		diffargv[0] = "diffh";
		execv(_PATH_DIFFH, diffargv);
		error("%s", _PATH_DIFFH);
	}
@


1.24
log
@Treat /dev/null specially; there is no need to make a temp file for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.23 2003/06/27 20:28:13 tedu Exp $	*/
d137 1
d235 2
a236 2
		execv(diffh, diffargv);
		error("%s", diffh);
@


1.23
log
@-a to force ascii compare.  ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.22 2003/06/26 22:04:45 millert Exp $	*/
d244 2
a245 1
	} else if (!S_ISREG(stb1.st_mode) || strcmp(file1, "-") == 0) {
d254 2
a255 1
	} else if (!S_ISREG(stb2.st_mode) || strcmp(file2, "-") == 0) {
d264 1
a264 1
	if (S_ISREG(stb1.st_mode) && S_ISREG(stb2.st_mode) &&
@


1.22
log
@Remove cruft; We don't have the -I, -1 or -2 options anymore so we don't
need the associated scaffolding.  tedu@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.21 2003/06/26 18:19:29 millert Exp $	*/
d994 3
@


1.21
log
@Fix temp file handling.
o honor TMPDIR environment variable as per man page
o need 2 temp files if both file1 and file2 are devices
o add error() and errorx() which cleanup temp file and then
call err() and errx() respectively.

OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.20 2003/06/26 04:52:26 millert Exp $	*/
d795 1
a795 1
		 * if this new change is within 'context' lines of
d852 1
a852 1
		fprintf(stdout, "#endif /* %s */\n", endifname);
a867 1
	int oneflag = (*ifdef1 != '\0') != (*ifdef2 != '\0');
d884 1
a884 1
		if (inifdef)
d886 6
a891 13
			    oneflag && oldfile == 1 ? "!" : "", ifdef2);
		else {
			if (oneflag) {
				/* There was only one ifdef given */
				endifname = ifdef2;
				if (oldfile)
					fprintf(stdout, "#ifndef %s\n", endifname);
				else
					fprintf(stdout, "#ifdef %s\n", endifname);
			} else {
				endifname = oldfile ? ifdef1 : ifdef2;
				fprintf(stdout, "#ifdef %s\n", endifname);
			}
a912 5

	if (inifdef && !wantelses) {
		fprintf(stdout, "#endif /* %s */\n", endifname);
		inifdef = 0;
	}
d1013 1
a1013 1
	if (cvp > context_vec_ptr)
d1110 1
a1110 1
	if (cvp > context_vec_ptr)
@


1.20
log
@Fix temp file handling and deal with the case where we might need 2 temp files.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.19 2003/06/26 04:47:30 vincent Exp $	*/
d235 1
a235 2
		warn("%s", diffh);
		done(0);
d238 2
a239 4
	if (strcmp(file1, "-") == 0 && strcmp(file2, "-") == 0) {
		warnx("can't specify - -");
		done(0);
	}
d242 2
a243 4
		if (stat(file1, &stb1) < 0) {
			warn("%s", file1);
			done(0);
		}
d246 2
a247 4
		if (stat(file1, &stb1) < 0) {
			warn("%s", file1);
			done(0);
		}
d251 2
a252 4
		if (stat(file2, &stb2) < 0) {
			warn("%s", file2);
			done(0);
		}
d255 2
a256 13
		if (stat(file2, &stb2) < 0) {
			warn("%s", file2);
			done(0);
		}
	}
	if ((f1 = fopen(file1, "r")) == NULL) {
		warn("%s", file1);
		done(0);
	}
	if ((f2 = fopen(file2, "r")) == NULL) {
		warn("%s", file2);
		fclose(f1);
		done(0);
d258 4
d287 1
a287 3
		fclose(f1);
		fclose(f2);
		done(0);
a323 1
	done(0);
d339 2
a340 4
	else if ((ifd = open(file, O_RDONLY, 0644)) < 0) {
		warn("%s", file);
		done(0);
	}
d344 2
a345 4
	if (asprintf(&tempfile, "%s/diff%d.XXXXXXXX", tempdir, n) == -1) {
		warn(NULL);
		done(0);
	}
d353 6
a358 9
	if (ofd < 0) {
		warn("%s", tempfile);
		done(0);
	}
	while ((i = read(ifd, buf, BUFSIZ)) > 0)
		if (write(ofd, buf, i) != i) {
			warn("%s", tempfile);
			done(0);
		}
d370 2
a371 4
	if (!strcmp(file, "-")) {
		warnx("can't specify - with other arg directory");
		done(0);
	}
d548 4
a551 8
	if ((input[0] = fopen(file1, "r")) == NULL) {
		perror(file1);
		done(0);
	}
	if ((input[1] = fopen(file2, "r")) == NULL) {
		perror(file2);
		done(0);
	}
@


1.19
log
@off by one in size calculation

ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.18 2003/06/25 22:38:11 tedu Exp $	*/
d239 5
a243 1
	if ((stb1.st_mode & S_IFMT) == S_IFDIR) {
d249 8
a256 1
	} else if ((stb2.st_mode & S_IFMT) == S_IFDIR) {
d262 2
a263 12
	} else if ((stb1.st_mode & S_IFMT) != S_IFREG || !strcmp(file1, "-")) {
		if (!strcmp(file2, "-")) {
			warnx("can't specify - -");
			done(0);
		}
		file1 = copytemp();
		if (stat(file1, &stb1) < 0) {
			warn("%s", file1);
			done(0);
		}
	} else if ((stb2.st_mode & S_IFMT) != S_IFREG || !strcmp(file2, "-")) {
		file2 = copytemp();
d278 2
a279 1
	if (stb1.st_size != stb2.st_size)
d345 1
a345 1
char *tempfile = _PATH_TMP;
d348 1
a348 1
copytemp(void)
d350 20
a369 2
	char buf[BUFSIZ];
	int i, f;
d375 2
a376 2
	f = mkstemp(tempfile);
	if (f < 0) {
d380 2
a381 2
	while ((i = read(0, buf, BUFSIZ)) > 0)
		if (write(f, buf, i) != i) {
d385 2
a386 1
	close(f);
@


1.18
log
@fix unified diff output.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.17 2003/06/25 22:14:43 millert Exp $	*/
d384 1
a384 1
	len = strlen(dir) + strlen(tail) + 1;
@


1.17
log
@Add unidiff support and try to pretty up usage() a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.16 2003/06/25 21:43:49 millert Exp $	*/
d1168 3
a1170 3
			fetch(ixold, lowa, a - 1, input[0], "  ", 0);
			fetch(ixold, a, b, input[0], "- ", 0);
			fetch(ixnew, c, d, input[1], "+ ", 0);
d1173 2
a1174 2
			fetch(ixold, lowa, a - 1, input[0], "  ", 0);
			fetch(ixold, a, b, input[0], "- ", 0);
d1177 2
a1178 2
			fetch(ixnew, lowc, c - 1, input[1], "  ", 0);
			fetch(ixnew, c, d, input[1], "+ ", 0);
d1184 1
a1184 1
	fetch(ixnew, d + 1, upd, input[1], "  ", 0);
@


1.16
log
@o use S_ISDIR instead of doing it by hand
o rename talloc -> emalloc and ralloc -> erealloc
o struct direct -> struct dirent (POSIX)
o kill remaining strcpy()
o fix unterminated string in setfile()
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.15 2003/06/25 17:49:22 millert Exp $	*/
d152 1
d338 1
a338 1
	if (opt == D_CONTEXT && anychange == 0)
d751 6
a756 2
	if (anychange && opt == D_CONTEXT)
		dump_context_vec();
d791 1
a791 2
		if (opt == D_CONTEXT) {
			printf("*** %s	", file1);
d793 2
a794 2
			printf("%s--- %s	",
			    ctime(&stbuf.st_mtime), file2);
d796 2
a797 2
			printf("%s", ctime(&stbuf.st_mtime));

d804 1
a804 1
	if (opt == D_CONTEXT) {
d814 7
a820 4
			a > (context_vec_ptr->b + 2 * context) &&
			c > (context_vec_ptr->d + 2 * context)))
			dump_context_vec();

d1122 64
@


1.15
log
@o use getopt()
o use err/warn
o only call done() when needed (after mkstemp)
o add "-C lines" like GNU grep
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.14 2003/06/25 07:26:59 tedu Exp $	*/
d314 1
a314 1
	member = ralloc(member, (slen[1] + 2) * sizeof(int));
d318 1
a318 1
	class = ralloc(class, (slen[0] + 2) * sizeof(int));
d320 2
a321 2
	klist = talloc((slen[0] + 2) * sizeof(int));
	clist = talloc(sizeof(cand));
d326 1
a326 1
	J = talloc((len[0] + 2) * sizeof(int));
d331 2
a332 2
	ixold = talloc((len[0] + 2) * sizeof(long));
	ixnew = talloc((len[1] + 2) * sizeof(long));
d371 2
a372 1
	char *tail, buf[BUFSIZ];
d379 1
a379 1
	if (tail == 0)
d383 4
a386 2
	snprintf(buf, sizeof buf, "%s/%s", dir, tail);
	return (strdup(buf));
d396 1
a396 1
	p = talloc(3 * sizeof(struct line));
d398 1
a398 1
		p = ralloc(p, (++j + 3) * sizeof(struct line));
d497 1
a497 1
	clist = ralloc(clist, ++clen * sizeof(cand));
d543 4
a546 3
 * check does double duty: 1.  ferret out any fortuitous correspondences due
 * to confounding by hashing (which result in "jackpot") 2.  collect random
 * access indexes to the two files
a547 1

d684 1
a684 1
	a = talloc((l + 1) * sizeof(int));
d794 1
a794 1
			context_vec_start = talloc(MAX_CONTEXT *
a1019 1

@


1.14
log
@remove silly signal catcher, and just use done.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.13 2003/06/25 03:55:45 deraadt Exp $	*/
d234 1
a234 2
		fprintf(stderr, "diff: ");
		perror(diffh);
d241 1
a241 2
			fprintf(stderr, "diff: ");
			perror(file1);
d247 1
a247 2
			fprintf(stderr, "diff: ");
			perror(file2);
d252 1
a252 1
			fprintf(stderr, "diff: can't specify - -\n");
d257 1
a257 2
			fprintf(stderr, "diff: ");
			perror(file1);
d263 1
a263 2
			fprintf(stderr, "diff: ");
			perror(file2);
d268 1
a268 2
		fprintf(stderr, "diff: ");
		perror(file1);
d272 1
a272 2
		fprintf(stderr, "diff: ");
		perror(file2);
d356 1
a356 2
		fprintf(stderr, "diff: ");
		perror(tempfile);
d361 1
a361 2
			fprintf(stderr, "diff: ");
			perror(tempfile);
d374 1
a374 1
		fprintf(stderr, "diff: can't specify - with other arg directory\n");
@


1.13
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.12 2003/06/25 03:53:59 deraadt Exp $	*/
d357 4
a360 4
	signal(SIGHUP, catchsig);
	signal(SIGINT, catchsig);
	signal(SIGPIPE, catchsig);
	signal(SIGTERM, catchsig);
d924 1
a924 2
				while (++col & 7)
					;
@


1.12
log
@use SEEK_SET with fseek()
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.11 2003/06/25 03:50:27 deraadt Exp $	*/
d401 1
a401 1
	fseek(fd, (off_t)0, SEEK_SET);
d1019 1
a1019 1
	fseek(f, (off_t)0, SEEK_SET);
@


1.11
log
@more knf
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.10 2003/06/25 03:46:45 deraadt Exp $	*/
d401 1
a401 1
	fseek(fd, 0, 0);
d914 1
a914 1
		fseek(lb, f[i - 1], 0);
d1019 1
a1019 1
	fseek(f, 0, 0);
@


1.10
log
@index -> strrchr
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.9 2003/06/25 03:42:16 deraadt Exp $	*/
d302 1
a302 1
	 *	Files certainly differ at this point; set status accordingly
d418 2
a419 1
	    pref++);
d422 2
a423 1
	    suff++);
d543 1
a543 2
		    i > len[0] - suff ? i + len[1] - len[0] :
		    0;
d924 2
a925 1
				while (++col & 7);
@


1.9
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.8 2003/06/25 03:42:00 tedu Exp $	*/
d386 1
a386 1
	tail = rindex(file, '/');
@


1.8
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.7 2003/06/25 03:39:23 tedu Exp $	*/
d227 2
a229 2
	FILE *f1, *f2;
	char buf1[BUFSIZ], buf2[BUFSIZ];
d380 1
a380 2
	char *tail;
	char buf[BUFSIZ];
d415 1
d434 1
d461 3
a463 4
	int i, k, y;
	int j, l;
	int oldc, tc;
	int oldl;
d512 2
a513 2
	int i, j, l;
	int t;
d536 1
d538 1
a538 1
	struct cand *q;
d556 1
a556 2
	int i, j;
	int jackpot;
a557 1
	int c, d;
d646 3
a648 3
		if(jackpot)
			fprintf(stderr, "jackpot\n");
	*/
d651 1
d654 3
a656 6
{				/* shellsort CACM #201 */
	struct line w;
	int j, m = 0;		/* gcc */
	struct line *ai;
	struct line *aim;
	int k;
d687 1
a687 2
	int *a;
	int i;
d711 2
a712 3
	int m;
	int i0, i1, j1;
	int j0;
d870 1
a870 1
	if (a < b) {
a871 1
	}
a876 4
	int i, j;
	int c;
	int col;
	int nc;
d878 1
d895 2
a896 1
			fprintf(stdout, "#else /* %s%s */\n", oneflag && oldfile == 1 ? "!" : "", ifdef2);
d950 2
a952 3
	unsigned shift;
	int t;
	int space;
d1014 1
a1014 1
	char buf[BUFSIZ];
a1015 1
	char *cp;
d1031 2
a1034 3
	struct context_vec *cvp = context_vec_start;
	int lowa, upb, lowc, upd;
	int do_output;
d1077 2
a1078 1
				fetch(ixold, a, b, input[0], ch == 'c' ? "! " : "- ", 0);
d1113 2
a1114 1
				fetch(ixnew, c, d, input[1], ch == 'c' ? "! " : "+ ", 0);
@


1.7
log
@-Wstrict-prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.6 2003/06/25 03:38:34 deraadt Exp $	*/
d131 1
a131 1
} *file[2], line;
d403 1
a403 1
	p = talloc(3 * sizeof(line));
d405 1
a405 1
		p = ralloc(p, (++j + 3) * sizeof(line));
@


1.6
log
@avoid signed issues; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.5 2003/06/25 03:37:32 deraadt Exp $	*/
a120 1
FILE *fopen();
@


1.5
log
@exit path signal race safe
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.4 2003/06/25 03:25:29 tedu Exp $	*/
d146 1
a146 1
char *chrtran;			/* translation table for case-folding */
d171 1
a171 1
char clow2low[256] = {
d198 1
a198 1
char cup2low[256] = {
@


1.4
log
@more cast removal, and fix some indent(1) oddities
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.3 2003/06/25 03:02:33 tedu Exp $	*/
d237 1
a237 1
		done();
d245 1
a245 1
			done();
d252 1
a252 1
			done();
d257 1
a257 1
			done();
d263 1
a263 1
			done();
d270 1
a270 1
			done();
d276 1
a276 1
		done();
d282 1
a282 1
		done();
d310 1
a310 1
		done();
d347 1
a347 1
	done();
d366 1
a366 1
		done();
d372 1
a372 1
			done();
d386 1
a386 1
		done();
d563 1
a563 1
		done();
d567 1
a567 1
		done();
@


1.3
log
@cleanup.  ansi, headers, correct prototypes, some safer string and
tempfile functions, whitespace, ...
no functional improvements yet
@
text
@d1 1
a1 1
/*	$OpenBSD: diffreg.c,v 1.2 2003/06/25 01:23:38 deraadt Exp $	*/
d135 1
a135 2
struct line *sfile[2];		/* shortened by pruning common prefix and
				 * suffix */
d322 1
a322 1
	member = ralloc((char *) member, (slen[1] + 2) * sizeof(int));
d324 1
a324 1
	class = (int *) file[0];
d326 1
a326 1
	class = ralloc((char *) class, (slen[0] + 2) * sizeof(int));
d398 1
a398 1
prepare(int i, FILE * fd)
d406 1
a406 1
		p = (struct line *) ralloc((char *) p, (++j + 3) * sizeof(line));
d432 1
a432 1
equiv(struct line * a, int n, struct line * b, int m, int *c)
d502 1
a502 1
	clist = (struct cand *) ralloc((char *) clist, ++clen * sizeof(cand));
d654 1
a654 1
sort(struct line * a, int n)
d689 1
a689 1
unsort(struct line * f, int l, int *b)
d882 1
a882 1
fetch(long *f, int a, int b, FILE * lb, char *s, int oldfile)
d957 1
a957 1
readhash(FILE * f)
d1022 1
a1022 1
asciifile(FILE * f)
@


1.2
log
@caldera licenses
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 6
a42 1
static	char sccsid[] = "@@(#)diffreg.c 4.21 4/6/90";
d46 5
d70 1
a70 1
 *	file0 by the index of the first element of its 
d85 1
a85 1
 *	between the first i lines of file0 and the first y 
d91 3
a93 3
 *	lines in file1 matable to a line in file0 has serial number 
 *	less than the y of some k-candidate, that k-candidate 
 *	with the smallest such y is replaced. The new 
d115 1
a115 1
 *	6n words for files of length n. 
d120 2
a121 2
FILE	*input[2];
FILE	*fopen();
d124 3
a126 3
	int	x;
	int	y;
	int	pred;
d128 1
d130 2
a131 2
	int	serial;
	int	value;
d133 38
a170 17
int	len[2];
struct	line *sfile[2];	/* shortened by pruning common prefix and suffix */
int	slen[2];
int	pref, suff;	/* length of prefix and suffix */
int	*class;		/* will be overlaid on file[0] */
int	*member;	/* will be overlaid on file[1] */
int	*klist;		/* will be overlaid on file[0] after class */
struct	cand *clist;	/* merely a free storage pot for candidates */
int	clen = 0;
int	*J;		/* will be overlaid on class */
long	*ixold;		/* will be overlaid on klist */
long	*ixnew;		/* will be overlaid on file[1] */
char	*chrtran;	/* translation table for case-folding */

/* chrtran points to one of 2 translation tables:
 *	cup2low if folding upper to lower case
 *	clow2low if not folding case
d172 25
a196 17
char	clow2low[256] = {
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
d199 25
a223 17
char	cup2low[256] = {
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
d226 2
a227 1
diffreg()
d229 1
a229 1
	register int i, j;
d240 1
a240 1
	chrtran = (iflag? cup2low : clow2low);
d295 1
a295 1
			status = 0;		/* files don't differ */
d318 2
a319 2
	sort(sfile[0],slen[0]);
	sort(sfile[1],slen[1]);
d323 1
a323 1
	member = (int *)ralloc((char *)member,(slen[1]+2)*sizeof(int));
d325 1
a325 1
	class = (int *)file[0];
d327 1
a327 1
	class = (int *)ralloc((char *)class,(slen[0]+2)*sizeof(int));
d329 2
a330 2
	klist = (int *)talloc((slen[0]+2)*sizeof(int));
	clist = (struct cand *)talloc(sizeof(cand));
d332 2
a333 2
	free((char *)member);
	free((char *)class);
d335 1
a335 1
	J = (int *)talloc((len[0]+2)*sizeof(int));
d337 2
a338 2
	free((char *)clist);
	free((char *)klist);
d340 2
a341 2
	ixold = (long *)talloc((len[0]+2)*sizeof(long));
	ixnew = (long *)talloc((len[1]+2)*sizeof(long));
d354 1
a354 1
copytemp()
d357 1
a357 1
	register int i, f;
d359 5
a363 6
	signal(SIGHUP,done);
	signal(SIGINT,done);
	signal(SIGPIPE,done);
	signal(SIGTERM,done);
	mktemp(tempfile);
	f = creat(tempfile,0600);
d369 2
a370 2
	while ((i = read(0,buf,BUFSIZ)) > 0)
		if (write(f,buf,i) != i) {
d380 1
a380 2
splice(dir, file)
	char *dir, *file;
d394 2
a395 2
	(void)sprintf(buf, "%s/%s", dir, tail);
	return (savestr(buf));
d398 2
a399 3
prepare(i, fd)
	int i;
	FILE *fd;
d401 2
a402 2
	register struct line *p;
	register j,h;
d404 4
a407 4
	fseek(fd, (long)0, 0);
	p = (struct line *)talloc(3*sizeof(line));
	for(j=0; h=readhash(fd);) {
		p = (struct line *)ralloc((char *)p,(++j+3)*sizeof(line));
d414 2
a415 1
prune()
d417 11
a427 11
	register i,j;
	for(pref=0;pref<len[0]&&pref<len[1]&&
		file[0][pref+1].value==file[1][pref+1].value;
		pref++ ) ;
	for(suff=0;suff<len[0]-pref&&suff<len[1]-pref&&
		file[0][len[0]-suff].value==file[1][len[1]-suff].value;
		suff++) ;
	for(j=0;j<2;j++) {
		sfile[j] = file[j]+pref;
		slen[j] = len[j]-pref-suff;
		for(i=0;i<=slen[j];i++)
d432 2
a433 3
equiv(a,n,b,m,c)
struct line *a, *b;
int *c;
d435 1
a435 1
	register int i, j;
d437 2
a438 2
	while(i<=n && j<=m) {
		if(a[i].value <b[j].value)
d440 1
a440 1
		else if(a[i].value == b[j].value)
d445 1
a445 1
	while(i <= n)
d447 1
a447 1
	b[m+1].value = 0;
d449 1
a449 1
	while(++j <= m) {
d451 1
a451 1
		while(b[j+1].value == b[j].value) {
d459 2
a460 4
stone(a,n,b,c)
int *a;
int *b;
register int *c;
d462 1
a462 1
	register int i, k,y;
d467 2
a468 2
	c[0] = newcand(0,0,0);
	for(i=1; i<=n; i++) {
d470 1
a470 1
		if(j==0)
d476 1
a476 1
			if(y <= clist[oldc].y)
d479 4
a482 4
			if(l!=oldl+1)
				oldc = c[l-1];
			if(l<=k) {
				if(clist[c[l]].y <= y)
d485 1
a485 1
				c[l] = newcand(i,y,oldc);
d489 1
a489 1
				c[l] = newcand(i,y,oldc);
d493 1
a493 1
		} while((y=b[++j]) > 0);
d495 1
a495 1
	return(k);
d498 2
a499 1
newcand(x,y,pred)
d501 4
a504 3
	register struct cand *q;
	clist = (struct cand *)ralloc((char *)clist,++clen*sizeof(cand));
	q = clist + clen -1;
d508 1
a508 1
	return(clen-1);
d511 2
a512 2
search(c, k, y)
int *c;
d514 1
a514 1
	register int i, j, l;
d516 2
a517 2
	if(clist[c[k]].y<y)	/*quick look for typical case*/
		return(k+1);
d519 1
a519 1
	j = k+1;
d522 1
a522 1
		if ((l >>= 1) <= i) 
d525 1
a525 1
		if(t > y)
d527 1
a527 1
		else if(t < y)
d530 1
a530 1
			return(l);
d532 1
a532 1
	return(l+1);
d535 2
a536 1
unravel(p)
d538 8
a545 8
	register int i;
	register struct cand *q;
	for(i=0; i<=len[0]; i++)
		J[i] =	i<=pref ? i:
			i>len[0]-suff ? i+len[1]-len[0]:
			0;
	for(q=clist+p;q->y!=0;q=clist+q->pred)
		J[q->x+pref] = q->y+pref;
d548 5
a552 4
/* check does double duty:
1.  ferret out any fortuitous correspondences due
to confounding by hashing (which result in "jackpot")
2.  collect random access indexes to the two files */
d554 2
a555 1
check()
d557 1
a557 1
	register int i, j;
d560 1
a560 1
	register int c,d;
d562 1
a562 1
	if ((input[0] = fopen(file1,"r")) == NULL) {
d566 1
a566 1
	if ((input[1] = fopen(file2,"r")) == NULL) {
d574 2
a575 2
	for(i=1;i<=len[0];i++) {
		if(J[i]==0) {
d579 1
a579 1
		while(j<J[i]) {
d583 2
a584 2
		if(bflag || wflag || iflag) {
			for(;;) {
d589 1
a589 1
				if(bflag && isspace(c) && isspace(d)) {
d591 1
a591 1
						if(c=='\n')
d594 1
a594 1
					} while(isspace(c=getc(input[0])));
d596 1
a596 1
						if(d=='\n')
d599 4
a602 4
					} while(isspace(d=getc(input[1])));
				} else if ( wflag ) {
					while( isspace(c) && c!='\n' ) {
						c=getc(input[0]);
d605 2
a606 2
					while( isspace(d) && d!='\n' ) {
						d=getc(input[1]);
d610 1
a610 1
				if(chrtran[c] != chrtran[d]) {
d613 1
a613 1
					if(c!='\n')
d615 1
a615 1
					if(d!='\n')
d619 1
a619 1
				if(c=='\n')
d623 1
a623 1
			for(;;) {
d626 1
a626 1
				if((c=getc(input[0])) != (d=getc(input[1]))) {
d629 1
a629 1
					if(c!='\n')
d631 1
a631 1
					if(d!='\n')
d635 1
a635 1
				if(c=='\n')
d643 1
a643 1
	for(;j<=len[1];j++) {
d648 4
a651 4
/*
	if(jackpot)
		fprintf(stderr, "jackpot\n");
*/
d654 3
a656 3
sort(a,n)	/*shellsort CACM #201*/
struct line *a;
{
d658 1
a658 1
	register int j,m;
d660 1
a660 1
	register struct line *aim;
d665 6
a670 6
	for(j=1;j<=n;j*= 2)
		m = 2*j - 1;
	for(m/=2;m!=0;m/=2) {
		k = n-m;
		for(j=1;j<=k;j++) {
			for(ai = &a[j]; ai > a; ai -= m) {
d672 5
a676 5
				if(aim < ai)
					break;	/*wraparound*/
				if(aim->value > ai[0].value ||
				   aim->value == ai[0].value &&
				   aim->serial > ai[0].serial)
d689 2
a690 3
unsort(f, l, b)
struct line *f;
int *b;
d692 5
a696 4
	register int *a;
	register int i;
	a = (int *)talloc((l+1)*sizeof(int));
	for(i=1;i<=l;i++)
d698 1
a698 1
	for(i=1;i<=l;i++)
d700 1
a700 1
	free((char *)a);
d703 2
a704 1
skipline(f)
d706 1
a706 1
	register i, c;
d708 1
a708 1
	for(i=1;(c=getc(input[f]))!='\n';i++)
d710 2
a711 2
			return(i);
	return(i);
d714 2
a715 1
output()
d718 1
a718 1
	register int i0, i1, j1;
d720 2
a721 2
	input[0] = fopen(file1,"r");
	input[1] = fopen(file2,"r");
d724 29
a752 21
	J[m+1] = len[1]+1;
	if(opt!=D_EDIT) for(i0=1;i0<=m;i0=i1+1) {
		while(i0<=m&&J[i0]==J[i0-1]+1) i0++;
		j0 = J[i0-1]+1;
		i1 = i0-1;
		while(i1<m&&J[i1+1]==0) i1++;
		j1 = J[i1+1]-1;
		J[i1] = j1;
		change(i0,i1,j0,j1);
	} else for(i0=m;i0>=1;i0=i1-1) {
		while(i0>=1&&J[i0]==J[i0+1]-1&&J[i0]!=0) i0--;
		j0 = J[i0+1]-1;
		i1 = i0+1;
		while(i1>1&&J[i1-1]==0) i1--;
		j1 = J[i1-1]+1;
		J[i1] = j1;
		change(i1,i0,j1,j0);
	}
	if(m==0)
		change(1,0,1,len[1]);
	if (opt==D_IFDEF) {
d772 4
a775 4
	int	a;	/* start line in old file */
	int	b;	/* end line in old file */
	int	c;	/* start line in new file */
	int	d;	/* end line in new file */
d778 1
a778 3
struct	context_vec	*context_vec_start,
			*context_vec_end,
			*context_vec_ptr;
d782 9
a790 7
/* indicate that there is a difference between lines a and b of the from file
   to get to lines c to d of the to file.
   If a is greater then b then there are no lines in the from file involved
   and this means that there were lines appended (beginning at b).
   If c is greater than d then there are lines missing from the to file.
*/
change(a,b,c,d)
a791 1
	int lowa,upb,lowc,upd;
d794 1
a794 1
	if (opt != D_IFDEF && a>b && c>d)
d798 1
a798 1
		if(opt == D_CONTEXT) {
d806 2
a807 3
			context_vec_start = (struct context_vec *) 
						malloc(MAX_CONTEXT *
						   sizeof(struct context_vec));
d812 1
a812 1
	if(opt == D_CONTEXT) {
d820 4
a823 4
		if ( context_vec_ptr >= context_vec_end ||
		     ( context_vec_ptr >= context_vec_start &&
		       a > (context_vec_ptr->b + 2*context) &&
		       c > (context_vec_ptr->d + 2*context) ) )
d837 4
a840 4
		range(a,b,",");
		putchar(a>b?'a':c>d?'d':'c');
		if(opt==D_NORMAL)
			range(c,d,",");
d844 2
a845 2
		putchar(a>b?'a':c>d?'d':'c');
		range(a,b," ");
d848 14
a861 14
        case D_NREVERSE:
                if (a>b)
                        printf("a%d %d\n",b,d-c+1);
                else {
                        printf("d%d %d\n",a,b-a+1);
                        if (!(c>d))
                           /* add changed lines */
                           printf("a%d %d\n",b, d-c+1);
                }
                break;
	}
	if(opt == D_NORMAL || opt == D_IFDEF) {
		fetch(ixold,a,b,input[0],"< ", 1);
		if(a<=b&&c<=d && opt == D_NORMAL)
d864 2
a865 2
	fetch(ixnew,c,d,input[1],opt==D_NORMAL?"> ":"", 0);
	if ((opt ==D_EDIT || opt == D_REVERSE) && c<=d)
d873 2
a874 2
range(a,b,separator)
char *separator;
d876 2
a877 2
	printf("%d", a>b?b:a);
	if(a<b) {
d882 2
a883 4
fetch(f,a,b,lb,s,oldfile)
long *f;
FILE *lb;
char *s;
d885 5
a889 5
	register int i, j;
	register int c;
	register int col;
	register int nc;
	int oneflag = (*ifdef1!='\0') != (*ifdef2!='\0');
d895 1
a895 1
	if (opt == D_IFDEF && oldfile){
d898 1
a898 1
		nc = f[a>b? b : a-1 ] - curpos;
d906 1
a906 1
			fprintf(stdout, "#else /* %s%s */\n", oneflag && oldfile==1 ? "!" : "", ifdef2);
d915 1
a915 2
			}
			else {
d920 1
a920 1
		inifdef = 1+oldfile;
d922 3
a924 4

	for(i=a;i<=b;i++) {
		fseek(lb,f[i-1],0);
		nc = f[i]-f[i-1];
d928 1
a928 1
		for(j=0;j<nc;j++) {
d955 1
a955 1
 * summing 1-s complement in 16-bit hunks 
d957 2
a958 2
readhash(f)
register FILE *f;
d960 4
a963 4
	register long sum;
	register unsigned shift;
	register t;
	register space;
d967 5
a971 5
	if(!bflag && !wflag) {
		if(iflag)
			for(shift=0;(t=getc(f))!='\n';shift+=7) {
				if(t==-1)
					return(0);
d980 3
a982 3
			for(shift=0;(t=getc(f))!='\n';shift+=7) {
				if(t==-1)
					return(0);
d991 2
a992 2
		for(shift=0;;) {
			switch(t=getc(f)) {
d994 1
a994 1
				return(0);
d1000 1
a1000 1
				if(space && !wflag) {
d1019 1
a1019 1
	return((short)low(sum) + (short)high(sum));
d1022 2
a1023 4
#include <a.out.h>

asciifile(f)
	FILE *f;
d1026 2
a1027 2
	register int cnt;
	register char *cp;
d1029 1
a1029 1
	fseek(f, (long)0, 0);
a1030 6
	if (cnt >= sizeof (struct exec)) {
		struct exec hdr;
		hdr = *(struct exec *)buf;
		if (!N_BADMAG(hdr))
			return (0);
	}
d1040 2
a1041 1
dump_context_vec()
d1043 5
a1047 5
	register int	a, b, c, d;
	register char	ch;
	register struct	context_vec *cvp = context_vec_start;
	register int	lowa, upb, lowc, upd;
	register int	do_output;
d1049 1
a1049 1
	if ( cvp > context_vec_ptr )
d1052 1
d1054 1
a1054 1
	upb  = min(len[0], context_vec_ptr->b + context);
d1056 1
a1056 1
	upd  = min(len[1], context_vec_ptr->d + context);
d1059 1
a1059 1
	range(lowa,upb,",");
d1068 1
a1068 1
	for ( ; cvp <= context_vec_ptr; cvp++)
d1074 1
a1074 2
	
	if ( do_output ) {
d1076 4
a1079 1
			a = cvp->a; b = cvp->b; c = cvp->c; d = cvp->d;
d1087 1
a1087 1
				fetch(ixold,lowa,b,input[0],"  ");
d1089 2
a1090 2
				fetch(ixold,lowa,a-1,input[0],"  ");
				fetch(ixold,a,b,input[0],ch == 'c' ? "! " : "- ");
d1095 1
a1095 1
		fetch(ixold, b+1, upb, input[0], "  ");
a1096 1

d1099 1
a1099 1
	range(lowc,upd,",");
a1108 1
	
d1111 4
a1114 1
			a = cvp->a; b = cvp->b; c = cvp->c; d = cvp->d;
d1122 1
a1122 1
				fetch(ixnew,lowc,d,input[1],"  ");
d1124 2
a1125 2
				fetch(ixnew,lowc,c-1,input[1],"  ");
				fetch(ixnew,c,d,input[1],ch == 'c' ? "! " : "+ ");
d1130 1
a1130 1
		fetch(ixnew, d+1, upd, input[1], "  ");
a1131 1

@


1.1
log
@4.3reno diff.  This is free because of the Caldera license.  Nasty, but a
place to start.
@
text
@d1 36
@

