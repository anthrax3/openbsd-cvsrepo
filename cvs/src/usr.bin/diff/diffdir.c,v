head	1.45;
access;
symbols
	OPENBSD_6_0:1.45.0.4
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.43.0.6
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.41.0.8
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.4
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.2
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.40.0.8
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.6
	OPENBSD_5_0:1.40.0.4
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.37.0.2
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.34.0.4
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.32.0.8
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.6
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.4
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.30.0.8
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.6
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.4
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.27.0.4
	OPENBSD_3_6_BASE:1.27
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24;
locks; strict;
comment	@ * @;


1.45
date	2015.10.05.20.15.00;	author millert;	state Exp;
branches;
next	1.44;
commitid	ploPtaulyei0HJ2S;

1.44
date	2015.09.25.16.16.26;	author tedu;	state Exp;
branches;
next	1.43;
commitid	ufT3acxBNu7Ulbo5;

1.43
date	2015.01.16.06.40.07;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	Uu5nFG3wCl0LACBb;

1.42
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2012.11.29.02.15.44;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2010.11.14.18.24.43;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2010.11.08.15.49.13;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2010.10.28.15.02.41;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.17.00.00.32;	author ray;	state Exp;
branches;
next	1.36;

1.36
date	2010.07.16.23.27.58;	author ray;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2009.06.07.08.39.13;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2009.06.06.15.37.28;	author ray;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.09.05.16.21;	author ray;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.29.18.24.56;	author ray;	state Exp;
branches;
next	1.30;

1.30
date	2005.06.15.18.44.01;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.26.20.09.56;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2004.10.02.18.13.24;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.16.00.40.34;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.09.20.13.57;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.07.23.37.27;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.21.23.28.00;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.21.22.57.17;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.09.00.07.44;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.06.22.17.21;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.06.22.02.36;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.06.20.48.59;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.06.02.11.12;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.04.17.50.24;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.04.02.54.36;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.27.20.28.13;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.26.18.19.29;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.25.22.14.43;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.25.21.43.49;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.25.17.49.22;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.25.03.50.27;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.25.03.44.49;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.25.03.39.23;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.25.03.37.32;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.25.03.32.11;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.25.03.29.46;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.25.03.25.29;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.25.03.02.33;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.25.01.23.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.25.01.20.52;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Remove the non-standard -l flag that pipes the output through pr(1).
Based on a diff from and OK deraadt@@
@
text
@/*	$OpenBSD: diffdir.c,v 1.44 2015/09/25 16:16:26 tedu Exp $	*/

/*
 * Copyright (c) 2003, 2010 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#include <sys/stat.h>

#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <fnmatch.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "diff.h"
#include "xmalloc.h"

static int selectfile(const struct dirent *);
static void diffit(struct dirent *, char *, size_t, char *, size_t, int);

#define d_status	d_type		/* we need to store status for -l */

/*
 * Diff directory traversal. Will be called recursively if -r was specified.
 */
void
diffdir(char *p1, char *p2, int flags)
{
	struct dirent *dent1, **dp1, **edp1, **dirp1 = NULL;
	struct dirent *dent2, **dp2, **edp2, **dirp2 = NULL;
	size_t dirlen1, dirlen2;
	char path1[PATH_MAX], path2[PATH_MAX];
	int pos;

	dirlen1 = strlcpy(path1, *p1 ? p1 : ".", sizeof(path1));
	if (dirlen1 >= sizeof(path1) - 1) {
		warnc(ENAMETOOLONG, "%s", p1);
		status = 2;
		return;
	}
	if (path1[dirlen1 - 1] != '/') {
		path1[dirlen1++] = '/';
		path1[dirlen1] = '\0';
	}
	dirlen2 = strlcpy(path2, *p2 ? p2 : ".", sizeof(path2));
	if (dirlen2 >= sizeof(path2) - 1) {
		warnc(ENAMETOOLONG, "%s", p2);
		status = 2;
		return;
	}
	if (path2[dirlen2 - 1] != '/') {
		path2[dirlen2++] = '/';
		path2[dirlen2] = '\0';
	}

	/*
	 * Get a list of entries in each directory, skipping "excluded" files
	 * and sorting alphabetically.
	 */
	pos = scandir(path1, &dirp1, selectfile, alphasort);
	if (pos == -1) {
		if (errno == ENOENT && (Nflag || Pflag)) {
			pos = 0;
		} else {
			warn("%s", path1);
			goto closem;
		}
	}
	dp1 = dirp1;
	edp1 = dirp1 + pos;

	pos = scandir(path2, &dirp2, selectfile, alphasort);
	if (pos == -1) {
		if (errno == ENOENT && Nflag) {
			pos = 0;
		} else {
			warn("%s", path2);
			goto closem;
		}
	}
	dp2 = dirp2;
	edp2 = dirp2 + pos;

	/*
	 * If we were given a starting point, find it.
	 */
	if (start != NULL) {
		while (dp1 != edp1 && strcmp((*dp1)->d_name, start) < 0)
			dp1++;
		while (dp2 != edp2 && strcmp((*dp2)->d_name, start) < 0)
			dp2++;
	}

	/*
	 * Iterate through the two directory lists, diffing as we go.
	 */
	while (dp1 != edp1 || dp2 != edp2) {
		dent1 = dp1 != edp1 ? *dp1 : NULL;
		dent2 = dp2 != edp2 ? *dp2 : NULL;

		pos = dent1 == NULL ? 1 : dent2 == NULL ? -1 :
		    strcmp(dent1->d_name, dent2->d_name);
		if (pos == 0) {
			/* file exists in both dirs, diff it */
			diffit(dent1, path1, dirlen1, path2, dirlen2, flags);
			dp1++;
			dp2++;
		} else if (pos < 0) {
			/* file only in first dir, only diff if -N */
			if (Nflag)
				diffit(dent1, path1, dirlen1, path2, dirlen2,
				    flags);
			else
				print_only(path1, dirlen1, dent1->d_name);
			dp1++;
		} else {
			/* file only in second dir, only diff if -N or -P */
			if (Nflag || Pflag)
				diffit(dent2, path1, dirlen1, path2, dirlen2,
				    flags);
			else
				print_only(path2, dirlen2, dent2->d_name);
			dp2++;
		}
	}

closem:
	if (dirp1 != NULL) {
		for (dp1 = dirp1; dp1 < edp1; dp1++)
			free(*dp1);
		free(dirp1);
	}
	if (dirp2 != NULL) {
		for (dp2 = dirp2; dp2 < edp2; dp2++)
			free(*dp2);
		free(dirp2);
	}
}

/*
 * Do the actual diff by calling either diffreg() or diffdir().
 */
static void
diffit(struct dirent *dp, char *path1, size_t plen1, char *path2, size_t plen2,
    int flags)
{
	flags |= D_HEADER;
	strlcpy(path1 + plen1, dp->d_name, PATH_MAX - plen1);
	if (stat(path1, &stb1) != 0) {
		if (!(Nflag || Pflag) || errno != ENOENT) {
			warn("%s", path1);
			return;
		}
		flags |= D_EMPTY1;
		memset(&stb1, 0, sizeof(stb1));
	}

	strlcpy(path2 + plen2, dp->d_name, PATH_MAX - plen2);
	if (stat(path2, &stb2) != 0) {
		if (!Nflag || errno != ENOENT) {
			warn("%s", path2);
			return;
		}
		flags |= D_EMPTY2;
		memset(&stb2, 0, sizeof(stb2));
		stb2.st_mode = stb1.st_mode;
	}
	if (stb1.st_mode == 0)
		stb1.st_mode = stb2.st_mode;

	if (S_ISDIR(stb1.st_mode) && S_ISDIR(stb2.st_mode)) {
		if (rflag)
			diffdir(path1, path2, flags);
		else
			printf("Common subdirectories: %s and %s\n",
			    path1, path2);
		return;
	}
	if (!S_ISREG(stb1.st_mode) && !S_ISDIR(stb1.st_mode))
		dp->d_status = D_SKIPPED1;
	else if (!S_ISREG(stb2.st_mode) && !S_ISDIR(stb2.st_mode))
		dp->d_status = D_SKIPPED2;
	else
		dp->d_status = diffreg(path1, path2, flags);
	print_status(dp->d_status, path1, path2, "");
}

/*
 * Returns 1 if the directory entry should be included in the
 * diff, else 0.  Checks the excludes list.
 */
static int
selectfile(const struct dirent *dp)
{
	struct excludes *excl;

	if (dp->d_fileno == 0)
		return (0);

	/* always skip "." and ".." */
	if (dp->d_name[0] == '.' && (dp->d_name[1] == '\0' ||
	    (dp->d_name[1] == '.' && dp->d_name[2] == '\0')))
		return (0);

	/* check excludes list */
	for (excl = excludes_list; excl != NULL; excl = excl->next)
		if (fnmatch(excl->pattern, dp->d_name, FNM_PATHNAME) == 0)
			return (0);

	return (1);
}
@


1.44
log
@xmalloc/free wrappers don't need to support 20 year old non comformance
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.43 2015/01/16 06:40:07 deraadt Exp $	*/
a134 2
			else if (lflag)
				dent1->d_status |= D_ONLY;
a142 2
			else if (lflag)
				dent2->d_status |= D_ONLY;
a147 13
	if (lflag) {
		path1[dirlen1] = '\0';
		path2[dirlen2] = '\0';
		for (dp1 = dirp1; (dent1 = *dp1) != NULL; dp1++) {
			print_status(dent1->d_status, path1, path2,
			    dent1->d_name);
		}
		for (dp2 = dirp2; (dent2 = *dp2) != NULL; dp2++) {
			if (dent2->d_status == D_ONLY)
				print_status(dent2->d_status, path2, NULL,
				    dent2->d_name);
		}
	}
a195 2
		else if (lflag)
			dp->d_status |= D_COMMON;
d207 1
a207 2
	if (!lflag)
		print_status(dp->d_status, path1, path2, "");
@


1.43
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.42 2014/05/20 01:25:23 guenther Exp $	*/
d169 2
a170 2
			xfree(*dp1);
		xfree(dirp1);
d174 2
a175 2
			xfree(*dp2);
		xfree(dirp2);
@


1.42
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.41 2012/11/29 02:15:44 guenther Exp $	*/
a22 1
#include <sys/param.h>
d35 1
d54 1
a54 1
	char path1[MAXPATHLEN], path2[MAXPATHLEN];
d187 1
a187 1
	strlcpy(path1 + plen1, dp->d_name, MAXPATHLEN - plen1);
d197 1
a197 1
	strlcpy(path2 + plen2, dp->d_name, MAXPATHLEN - plen2);
@


1.41
log
@Change scandir()'s 'select' argument from
	int (*)(struct dirent *)
to
	int (*)(const struct dirent *)
to match POSIX.

ok millert@@, ports check by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.40 2010/11/14 18:24:43 millert Exp $	*/
d59 1
a59 1
		warnx("%s: %s", p1, strerror(ENAMETOOLONG));
d69 1
a69 1
		warnx("%s: %s", p2, strerror(ENAMETOOLONG));
@


1.40
log
@scandir() does not NULL-terminate the list of dirent structs so use
the returned count and set and end pointer instead.  we no longer
need to allocate a dummy array when diffing against a non-existent
directory so eliminate slurpdir() and call scandir() directly.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.39 2010/11/08 15:49:13 millert Exp $	*/
d40 1
a40 1
static int selectfile(struct dirent *);
d235 1
a235 1
selectfile(struct dirent *dp)
@


1.39
log
@getdirentries(2) should be avoided outside of libc so use scandir(3)
instead.  This makes slurpdir() just a thin wrapper around scandir(3).
OK schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.38 2010/10/28 15:02:41 millert Exp $	*/
a40 1
static struct dirent **slurpdir(char *, int);
d51 2
a52 2
	struct dirent *dent1, **dp1, **dirp1 = NULL;
	struct dirent *dent2, **dp2, **dirp2 = NULL;
d78 27
a104 5
	/* get a list of the entries in each directory */
	dp1 = dirp1 = slurpdir(path1, Nflag + Pflag);
	dp2 = dirp2 = slurpdir(path2, Nflag);
	if (dirp1 == NULL || dirp2 == NULL)
		goto closem;
d110 1
a110 1
		while (*dp1 != NULL && strcmp((*dp1)->d_name, start) < 0)
d112 1
a112 1
		while (*dp2 != NULL && strcmp((*dp2)->d_name, start) < 0)
d119 3
a121 3
	while (*dp1 != NULL || *dp2 != NULL) {
		dent1 = *dp1;
		dent2 = *dp2;
d168 2
a169 2
		for (dp1 = dirp1; (dent1 = *dp1) != NULL; dp1++)
			xfree(dent1);
d173 2
a174 2
		for (dp2 = dirp2; (dent2 = *dp2) != NULL; dp2++)
			xfree(dent2);
a176 24
}

/*
 * Read in a whole directory, culling out the "excluded" files.
 * Returns an array of struct dirent *'s in alphabetic order.
 * Caller is responsible for free()ing each array element and the array itself.
 */
static struct dirent **
slurpdir(char *dirname, int enoentok)
{
	struct dirent **namelist = NULL;
	int rval;

	rval = scandir(dirname, &namelist, selectfile, alphasort);
	if (rval == -1) {
		if (enoentok && errno == ENOENT) {
			namelist = xmalloc(sizeof(struct dirent *));
			namelist[0] = NULL;
		} else {
			warn("%s", dirname);
		}
	}

	return (namelist);
@


1.38
log
@Change basep parameter of getdirentries() to be off_t *, not long *
so it works correctly with large offsets (and matches other systems).
This requires adding a new getdirentries syscall, with the old one
renamed to ogetdirentries.  All in-tree consumers of getdirentries()
have been updated.  Bump libc and libpthread major numbers.
OK and with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.37 2010/07/17 00:00:32 ray Exp $	*/
d4 1
a4 1
 * Copyright (c) 2003 Todd C. Miller <Todd.Miller@@courtesan.com>
d40 2
a41 3
static int dircompare(const void *, const void *);
static int excluded(const char *);
static struct dirent **slurpdir(char *, char **, int);
d52 2
a53 2
	struct dirent **dirp1, **dirp2, **dp1, **dp2;
	struct dirent *dent1, *dent2;
a55 1
	char *dirbuf1, *dirbuf2;
d80 3
a82 3
	dp1 = dirp1 = slurpdir(path1, &dirbuf1, Nflag + Pflag);
	dp2 = dirp2 = slurpdir(path2, &dirbuf2, Nflag);
	if (dirp1 == NULL || dirp2 == NULL) {
a83 1
	}
d146 3
a148 1
	if (dirbuf1 != NULL) {
a149 1
		xfree(dirbuf1);
d151 3
a153 1
	if (dirbuf2 != NULL) {
a154 1
		xfree(dirbuf2);
d159 3
a161 4
 * Read in a whole directory's worth of struct dirents, culling
 * out the "excluded" ones.
 * Returns an array of struct dirent *'s that point into the buffer
 * returned via bufp.  Caller is responsible for free()ing both of these.
d164 1
a164 1
slurpdir(char *path, char **bufp, int enoentok)
d166 2
a167 47
	char *buf, *ebuf, *cp;
	size_t bufsize, have, need;
	off_t base;
	int fd, nbytes, entries;
	struct stat sb;
	struct dirent **dirlist, *dp;

	*bufp = NULL;
	if ((fd = open(path, O_RDONLY, 0644)) == -1) {
		static struct dirent *dummy;

		if (!enoentok || errno != ENOENT) {
			warn("%s", path);
			return (NULL);
		}
		return (&dummy);
	}
	if (fstat(fd, &sb) == -1) {
		warn("%s", path);
		close(fd);
		return (NULL);
	}

	need = roundup(sb.st_blksize, sizeof(struct dirent));
	have = bufsize = roundup(MAX(sb.st_size, sb.st_blksize),
	    sizeof(struct dirent)) + need;
	ebuf = buf = xmalloc(bufsize);

	do {
		if (have < need) {
		    bufsize += need;
		    have += need;
		    cp = xrealloc(buf, 1, bufsize);
		    ebuf = cp + (ebuf - buf);
		    buf = cp;
		}
		nbytes = getdirentries(fd, ebuf, have, &base);
		if (nbytes == -1) {
			warn("%s", path);
			xfree(buf);
			close(fd);
			return (NULL);
		}
		ebuf += nbytes;
		have -= nbytes;
	} while (nbytes != 0);
	close(fd);
d169 7
a175 19
	/*
	 * We now have all the directory entries in our buffer.
	 * However, in order to easily sort them we need to convert
	 * the buffer into an array.
	 */
	for (entries = 0, cp = buf; cp < ebuf; ) {
		dp = (struct dirent *)cp;
		if (dp->d_fileno != 0)
			entries++;
		if (dp->d_reclen <= 0)
			break;
		cp += dp->d_reclen;
	}
	dirlist = xcalloc(sizeof(*dirlist), entries + 1);
	for (entries = 0, cp = buf; cp < ebuf; ) {
		dp = (struct dirent *)cp;
		if (dp->d_fileno != 0 && !excluded(dp->d_name)) {
			dp->d_status = 0;
			dirlist[entries++] = dp;
a176 3
		if (dp->d_reclen <= 0)
			break;
		cp += dp->d_reclen;
a177 3
	dirlist[entries] = NULL;

	qsort(dirlist, entries, sizeof(struct dirent *), dircompare);
d179 1
a179 14
	*bufp = buf;
	return (dirlist);
}

/*
 * Compare d_name in two dirent structures; for qsort(3).
 */
static int
dircompare(const void *vp1, const void *vp2)
{
	struct dirent *dp1 = *((struct dirent **) vp1);
	struct dirent *dp2 = *((struct dirent **) vp2);

	return (strcmp(dp1->d_name, dp2->d_name));
d234 2
a235 1
 * Exclude the given directory entry?
d238 1
a238 1
excluded(const char *entry)
d242 3
d246 3
a248 3
	if (entry[0] == '.' &&
	    (entry[1] == '\0' || (entry[1] == '.' && entry[2] == '\0')))
		return (1);
d252 2
a253 2
		if (fnmatch(excl->pattern, entry, FNM_PATHNAME) == 0)
			return (1);
d255 1
a255 1
	return (0);
@


1.37
log
@Plug memory leak.

OK nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.36 2010/07/16 23:27:58 ray Exp $	*/
d170 1
a170 1
	long base;
@


1.36
log
@Simplify print_status by removing NULL handling.

OK nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.35 2009/10/27 23:59:37 deraadt Exp $	*/
d84 3
a86 2
	if (dirp1 == NULL || dirp2 == NULL)
		return;
d148 1
@


1.35
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.34 2009/06/07 08:39:13 ray Exp $	*/
d306 1
a306 1
		print_status(dp->d_status, path1, path2, NULL);
@


1.34
log
@More cvs/diff/rcs convergence:
1. Mostly variable/function renaming, SIZE_T_MAX->SIZE_MAX, and
spacing.
2. One strchr -> strncspn.
3. diff had a weird thing where it set file[12] = ofile[12] but
never updated file or ofile, then if file and ofile were different
it freed it. I removed it.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.33 2009/06/06 15:37:28 ray Exp $	*/
a21 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.33 2009/06/06 15:37:28 ray Exp $";
#endif /* not lint */
@


1.33
log
@Oops, forgot to pass dflags to diffreg. Now the flags work again.

OK millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.32 2007/06/09 05:16:21 ray Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.32 2007/06/09 05:16:21 ray Exp $";
d231 1
a231 1
	dirlist = xmalloc(sizeof(*dirlist) * (entries + 1));
@


1.32
log
@- Change sizeof(type) to sizeof(*ptr).
- Move function prototypes before variables.

No binary change.

OK otto and millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.31 2007/05/29 18:24:56 ray Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.31 2007/05/29 18:24:56 ray Exp $";
d47 1
a47 1
static void diffit(struct dirent *, char *, size_t, char *, size_t);
d55 1
a55 1
diffdir(char *p1, char *p2)
d112 1
a112 1
			diffit(dent1, path1, dirlen1, path2, dirlen2);
d118 2
a119 1
				diffit(dent1, path1, dirlen1, path2, dirlen2);
d128 2
a129 1
				diffit(dent2, path1, dirlen1, path2, dirlen2);
d266 2
a267 1
diffit(struct dirent *dp, char *path1, size_t plen1, char *path2, size_t plen2)
d269 1
a269 2
	int flags = D_HEADER;

d295 1
a295 1
			diffdir(path1, path2);
@


1.31
log
@Bring in some changes from rcsdiff:
1. Replace all the e*alloc functions with the x*alloc versions.
2. Whitespace syncs according to style.
3. Remove the __inline stuff.
4. Remove the min/max functions, using the MAX/MIN macros instead.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.30 2005/06/15 18:44:01 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.30 2005/06/15 18:44:01 millert Exp $";
d229 1
a229 1
	dirlist = xmalloc(sizeof(struct dirent *) * (entries + 1));
@


1.30
log
@bye bye whiteouts
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.29 2004/11/26 20:09:56 otto Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.29 2004/11/26 20:09:56 otto Exp $";
d42 1
d150 2
a151 2
		free(dirp1);
		free(dirbuf1);
d154 2
a155 2
		free(dirp2);
		free(dirbuf2);
d194 1
a194 1
	ebuf = buf = emalloc(bufsize);
d200 1
a200 1
		    cp = erealloc(buf, bufsize);
d207 1
a207 1
			free(buf);
d229 1
a229 1
	dirlist = emalloc(sizeof(struct dirent *) * (entries + 1));
@


1.29
log
@Fix the getdirentries() loop memory handling and EOF detection.
Also fix typo in sizeof.  Problem spotted by YAMAMOTO Takashi; this
diff joint work with millert@@

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.28 2004/10/02 18:13:24 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.28 2004/10/02 18:13:24 millert Exp $";
d222 1
a222 1
		if (dp->d_fileno != 0 && dp->d_type != DT_WHT)
d231 1
a231 2
		if (dp->d_fileno != 0 && dp->d_type != DT_WHT &&
		    !excluded(dp->d_name)) {
@


1.28
log
@Keep calling getdirentries() until we no longer fill up our buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.27 2004/03/16 00:40:34 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.27 2004/03/16 00:40:34 millert Exp $";
d168 1
a168 1
	size_t bufsize;
d184 10
a193 1
	fstat(fd, &sb);
a194 2
	bufsize = 0;
	ebuf = buf = NULL;
d196 3
a198 5
		bufsize += roundup(MAX(sb.st_size, sb.st_blksize),
		    sizeof(struct dirent));
		if (buf == NULL)
		    buf = ebuf = emalloc(bufsize);
		else {
d203 1
a203 1
		nbytes = getdirentries(fd, ebuf, bufsize, &base);
d205 1
d207 1
a207 1
			warn("%s", path);
d211 2
a212 1
	} while (nbytes == bufsize);
d242 1
a242 1
	qsort(dirlist, entries, sizeof(struct dir *), dircompare);
@


1.27
log
@POSIX specifies that in directory mode device special files and
FIFOs shall be skipped.  Other types of files may be skipped too
(this is implementation-dependent).  In directory mode, just skip
anything that is not a regular file or directory.  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.26 2003/11/09 20:13:57 otto Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.26 2003/11/09 20:13:57 otto Exp $";
d186 20
a205 12
	bufsize = sb.st_size;
	if (bufsize < sb.st_blksize)
		bufsize = sb.st_blksize;
	buf = emalloc(bufsize);

	nbytes = getdirentries(fd, buf, bufsize, &base);
	if (nbytes <= 0) {
		free(buf);
		warn("%s", path);
		return (NULL);
	}
	ebuf = buf + nbytes;
@


1.26
log
@Typos in comments from Jared Yanovich <jjy2+ at pitt dot edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.25 2003/10/07 23:37:27 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.25 2003/10/07 23:37:27 millert Exp $";
d286 6
a291 1
	dp->d_status = diffreg(path1, path2, flags);
@


1.25
log
@Fix printing of "Only in foo" when foo is "/" (trailing slash removal
was overzealous in this case).  Fix tested by Hugo Villeneuve and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.24 2003/07/21 23:28:00 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.24 2003/07/21 23:28:00 millert Exp $";
d51 1
a51 1
 * Diff directory traveral. Will be called recursively if -r was specified.
@


1.24
log
@Historically, the "Only in" messages produced in dir mode
were not printed when the output format was -e (ed) since this
prevented the output from being used as an ed script.
However, POSIX specifies that this message shall always be printed
regardless of the output format (this is also what GNU diff does).
Also do the same with the "Common subdirectory" message which
POSIX lists as optional.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.23 2003/07/21 22:57:17 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.23 2003/07/21 22:57:17 millert Exp $";
d121 1
a121 2
				printf("Only in %.*s: %s\n", (int)(dirlen1 - 1),
				    path1, dent1->d_name);
d130 1
a130 2
				printf("Only in %.*s: %s\n", (int)(dirlen2 - 1),
				    path2, dent2->d_name);
@


1.23
log
@Fix printing of status when not in -l mode which was broken when the
-l support was added.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.22 2003/07/09 00:07:44 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.22 2003/07/09 00:07:44 millert Exp $";
d120 1
a120 3
			else if (format == D_NORMAL || format == D_CONTEXT ||
			    format == D_UNIFIED || format == D_BRIEF)
				/* XXX GNU diff always prints this XXX */
d130 1
a130 3
			else if (format == D_NORMAL || format == D_CONTEXT ||
			    format == D_UNIFIED || format == D_BRIEF)
				/* XXX GNU diff always prints this XXX */
d283 1
a283 2
		else if (format != D_EDIT)
			/* XXX GNU diff always prints this for dirs XXX */
@


1.22
log
@Re-implement -l flag; diff -l now works correctly in non-directory
mode (like GNU diff).
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.21 2003/07/06 22:17:21 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.21 2003/07/06 22:17:21 millert Exp $";
d141 2
a142 2
		path1[dirlen1 - 1] = '\0';
		path2[dirlen2 - 1] = '\0';
d294 2
@


1.21
log
@Add -q option from GNU diff
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.20 2003/07/06 22:02:36 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.20 2003/07/06 22:02:36 millert Exp $";
d48 2
d118 2
d130 2
d140 13
d223 2
a224 1
		    !excluded(dp->d_name))
d226 1
d285 2
d293 1
a293 1
	diffreg(path1, path2, flags);
@


1.20
log
@Implement -P from GNU diff (like -N but only for files that are missing
from dir1).
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.19 2003/07/06 20:48:59 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.19 2003/07/06 20:48:59 millert Exp $";
d117 1
a117 1
			    format == D_UNIFIED)
d127 1
a127 1
			    format == D_UNIFIED)
@


1.19
log
@Some fairly major changes:
 o -N is implemented
 o -X is implemented
 o -x is implemented
 o diff.c has been rewritten and GNU long options are now supported
 o diffdir.c has been rewritten
    + no longer does fork + exec of /usr/bin/diff
    + can be called recursively (and will be for -r)
 o diff.h
    + don't include any .h files here any more, do it in the .c files
    + no Bell Labs code in this, gets a UCB copyright (the 32v sources
      only have a diff.c and there is nothing in common).
 o diffreg.c
    + most all remaining globals are now private to diffreg.c
    + files are only opened once
    + dynamically allocated objects are either freed or realloced
    + added missing UCB copyright (there were lots of UCB changes)
    + print correct thing when -s is specified
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.18 2003/07/06 02:11:12 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: diffdir.c,v 1.18 2003/07/06 02:11:12 millert Exp $";
d45 1
a45 1
static struct dirent **slurpdir(char *, char **);
d83 2
a84 2
	dp1 = dirp1 = slurpdir(path1, &dirbuf1);
	dp2 = dirp2 = slurpdir(path2, &dirbuf2);
d123 2
a124 2
			/* file only in second dir, only diff if -N */
			if (Nflag)
d152 1
a152 1
slurpdir(char *path, char **bufp)
d165 1
a165 1
		if (!Nflag) {
d240 1
a240 1
		if (!Nflag || errno != ENOENT) {
d262 4
a265 2
		/* XXX GNU diff always prints this for dirs XXX */
		if (format != D_EDIT)
a267 2
		if (rflag)
			diffdir(path1, path2);
@


1.18
log
@Use symbolic constants for output format.
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.17 2003/07/04 17:50:24 millert Exp $	*/
d4 1
a4 2
 * Copyright (C) Caldera International Inc.  2001-2002.
 * All rights reserved.
d6 3
a8 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code and documentation must retain the above
 *    copyright notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed or owned by Caldera
 *	International, Inc.
 * 4. Neither the name of Caldera International, Inc. nor the names of other
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
d10 11
a20 12
 * USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
 * INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE FOR ANY DIRECT,
 * INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
d23 6
a28 2
#include <sys/types.h>
#include <sys/wait.h>
d31 1
d34 2
a41 1
#include "pathnames.h"
d43 4
a46 3
#if 0
static const char sccsid[] = "@@(#)diffdir.c	4.12 (Berkeley) 4/30/89";
#endif
d49 1
a49 1
 * diff - directory comparison
d51 30
a80 1
#define	d_flags	d_ino
d82 5
a86 1
#define	DIRECT	1		/* Directory */
d88 9
a96 19
struct dir {
	u_long d_ino;
	short d_reclen;
	short d_namlen;
	char *d_entry;
};

static int dirstatus;		/* exit status from diffdir */
static char title[2 * BUFSIZ];


static struct dir *setupdir(char *);
static int ascii(int);
static void compare(struct dir *);
static void calldiff(void);
static void setfile(char **fpp, char **epp, char *file);
static int useless(char *);
static void only(struct dir *dp, int which);
static int entcmp(const void *, const void *);
d98 24
a121 51
void
diffdir(char **argv)
{
	struct dir *dir1, *dir2;
	struct dir *d1, *d2;
	int i, cmp;

	if (opt == D_IFDEF)
		warnx("can't specify -I with directories");
	if (opt == D_EDIT && sflag)
		warnx("warning: shouldn't give -s with -e");
	strlcpy(title, "diff ", sizeof title);
	for (i = 1; diffargv[i + 2]; i++) {
		if (!strcmp(diffargv[i], "-"))
			continue;	/* was -S, dont look silly */
		strlcat(title, diffargv[i], sizeof title);
		strlcat(title, " ", sizeof title);
	}
	setfile(&file1, &efile1, file1);
	setfile(&file2, &efile2, file2);
	argv[0] = file1;
	argv[1] = file2;
	dir1 = setupdir(file1);
	dir2 = setupdir(file2);
	d1 = dir1;
	d2 = dir2;
	while (d1->d_entry != 0 || d2->d_entry != 0) {
		if (d1->d_entry && useless(d1->d_entry)) {
			d1++;
			continue;
		}
		if (d2->d_entry && useless(d2->d_entry)) {
			d2++;
			continue;
		}
		if (d1->d_entry == 0)
			cmp = 1;
		else if (d2->d_entry == 0)
			cmp = -1;
		else
			cmp = strcmp(d1->d_entry, d2->d_entry);
		if (cmp < 0) {
			if (opt == D_NORMAL || opt == D_CONTEXT ||
			    opt == D_UNIFIED)
				only(d1, 1);
			d1++;
			dirstatus |= 1;
		} else if (cmp == 0) {
			compare(d1);
			d1++;
			d2++;
d123 9
a131 5
			if (opt == D_NORMAL || opt == D_CONTEXT ||
			    opt == D_UNIFIED)
				only(d2, 2);
			d2++;
			dirstatus |= 1;
d134 8
a141 10
	if (rflag) {
		for (d1 = dir1; d1->d_entry; d1++) {
			if ((d1->d_flags & DIRECT) == 0)
				continue;
			strlcpy(efile1, d1->d_entry,
			    file1 + MAXPATHLEN - efile1);
			strlcpy(efile2, d1->d_entry,
			    file2 + MAXPATHLEN - efile2);
			calldiff();
		}
a142 1
	status = dirstatus;
d145 8
a152 2
void
setfile(char **fpp, char **epp, char *file)
d154 18
a171 2
	char *cp;
	size_t len;
d173 10
a182 12
	if (*file == '\0')
		file = ".";
	*fpp = emalloc(MAXPATHLEN);
	len = strlcpy(*fpp, file, MAXPATHLEN);
	if (len >= MAXPATHLEN - 1)
		errorx("%s: %s", file, strerror(ENAMETOOLONG));
	cp = *fpp + len - 1;
	if (*cp == '/')
		++cp;
	else {
		*++cp = '/';
		*++cp = '\0';
d184 2
a185 2
	*epp = cp;
}
d187 24
a210 5
void
only(struct dir *dp, int which)
{
	char *file = which == 1 ? file1 : file2;
	char *efile = which == 1 ? efile1 : efile2;
d212 1
a212 2
	printf("Only in %.*s: %s\n", (int)(efile - file - 1), file, dp->d_entry);
}
d214 2
a215 29
struct dir *
setupdir(char *cp)
{
	struct dir *dp, *ep;
	struct dirent *rp;
	int nitems;
	DIR *dirp;

	dirp = opendir(cp);
	if (dirp == NULL)
		error("%s", cp);
	nitems = 0;
	dp = emalloc(sizeof(struct dir));
	while ((rp = readdir(dirp))) {
		ep = &dp[nitems++];
		ep->d_reclen = rp->d_reclen;
		ep->d_namlen = rp->d_namlen;
		ep->d_entry = 0;
		ep->d_flags = 0;
		if (ep->d_namlen > 0) {
			ep->d_entry = emalloc(ep->d_namlen + 1);
			strlcpy(ep->d_entry, rp->d_name, ep->d_namlen + 1);
		}
		dp = erealloc(dp, (nitems + 1) * sizeof(struct dir));
	}
	dp[nitems].d_entry = 0;	/* delimiter */
	closedir(dirp);
	qsort(dp, nitems, sizeof(struct dir), entcmp);
	return (dp);
d218 3
d222 1
a222 1
entcmp(const void *v1, const void *v2)
d224 2
a225 1
	const struct dir *d1, *d2;
d227 1
a227 3
	d1 = v1;
	d2 = v2;
	return (strcmp(d1->d_entry, d2->d_entry));
d230 3
d234 1
a234 1
compare(struct dir *dp)
d236 7
a242 33
	char buf1[BUFSIZ], buf2[BUFSIZ];
	int i, j, f1, f2, fmt1, fmt2;
	struct stat stb1, stb2;

	strlcpy(efile1, dp->d_entry, file1 + MAXPATHLEN - efile1);
	strlcpy(efile2, dp->d_entry, file2 + MAXPATHLEN - efile2);
	f1 = open(file1, 0);
	if (f1 < 0) {
		warn("%s", file1);
		return;
	}
	f2 = open(file2, 0);
	if (f2 < 0) {
		warn("%s", file2);
		close(f1);
		return;
	}
	fstat(f1, &stb1);
	fstat(f2, &stb2);
	fmt1 = stb1.st_mode & S_IFMT;
	fmt2 = stb2.st_mode & S_IFMT;
	if (fmt1 != S_IFREG || fmt2 != S_IFREG) {
		if (fmt1 == fmt2) {
			if (fmt1 != S_IFDIR && stb1.st_rdev == stb2.st_rdev)
				goto same;
			if (fmt1 == S_IFDIR) {
				dp->d_flags = DIRECT;
				if (opt == D_EDIT)
					goto closem;
				printf("Common subdirectories: %s and %s\n",
				    file1, file2);
				goto closem;
			}
d244 2
a245 1
		goto notsame;
a246 42
	if (stb1.st_size != stb2.st_size)
		goto notsame;
	for (;;) {
		i = read(f1, buf1, BUFSIZ);
		j = read(f2, buf2, BUFSIZ);
		if (i < 0 || j < 0 || i != j)
			goto notsame;
		if (i == 0 && j == 0)
			goto same;
		for (j = 0; j < i; j++)
			if (buf1[j] != buf2[j])
				goto notsame;
	}
same:
	if (sflag != 0)
		printf("Files %s and %s are identical\n", file1, file2);
	goto closem;
notsame:
	dirstatus |= 1;
	if (!ascii(f1) || !ascii(f2)) {
		if (opt == D_NORMAL || opt == D_CONTEXT || opt == D_UNIFIED)
			printf("Binary files %s and %s differ\n",
			    file1, file2);
		goto closem;
	}
	close(f1);
	close(f2);
	anychange = 1;
	if (opt == D_EDIT) {
		printf("ed - %s << '-*-END-*-'\n", dp->d_entry);
		calldiff();
	} else {
		printf("%s%s %s\n", title, file1, file2);
		calldiff();
	}
	if (opt == D_EDIT)
		printf("w\nq\n-*-END-*-\n");
	return;
closem:
	close(f1);
	close(f2);
}
d248 21
a268 13
static void
calldiff(void)
{
	int lstatus;
	pid_t pid;

	fflush(stdout);
	pid = fork();
	if (pid == -1)
		errorx("No more processes");
	if (pid == 0) {
		execv(_PATH_DIFF, diffargv);
		error("%s", _PATH_DIFF);
d270 1
a270 7
	while (wait(&lstatus) != pid)
		continue;
	/*
		if ((lstatus >> 8) >= 2)
			done(0);
	*/
	dirstatus |= lstatus >> 8;
d273 5
a277 2
int
ascii(int f)
d279 1
a279 2
	char buf[BUFSIZ], *cp;
	int cnt;
d281 3
a283 1
	if (aflag)
d286 4
a289 8
	lseek(f, (off_t)0, SEEK_SET);
	cnt = read(f, buf, BUFSIZ);
	cp = buf;
	while (--cnt >= 0)
		if (*cp++ & 0200)
			return (0);
	return (1);
}
a290 14
/*
 * THIS IS CRUDE.
 */
int
useless(char *cp)
{
	if (cp[0] == '.') {
		if (cp[1] == '\0')
			return (1);	/* directory "." */
		if (cp[1] == '.' && cp[2] == '\0')
			return (1);	/* directory ".." */
	}
	if (start && strcmp(start, cp) > 0)
		return (1);
@


1.17
log
@Kill non-standard -l option as discussed with tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.16 2003/07/04 02:54:36 millert Exp $	*/
d124 2
a125 1
			if (opt == 0 || opt == 2)
d134 2
a135 1
			if (opt == 0 || opt == 2)
@


1.16
log
@Some cosmetic fixes:
o get rid of now-unused tempfile variable
o move inifdef into diffreg.c (only used there)
o correct a comment
o use _PATH_DIFF, _PATH_DIFFH and _PATH_PR instead of variables set to them
o get rid of hack to look for pr and diff in /bin
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.15 2003/06/27 20:28:13 tedu Exp $	*/
d60 1
a60 4
#define	ONLY	1		/* Only in this directory */
#define	SAME	2		/* Both places and same */
#define	DIFFER	4		/* Both places and different */
#define	DIRECT	8		/* Directory */
a68 1
int header;
d70 1
a70 4
extern int status;
char title[2 * BUFSIZ];
char *etitle;
char *prargs[] = {"pr", "-h", 0, "-f", 0, 0};
d76 1
a76 1
static void calldiff(char *);
a79 1
static void scanpr(struct dir *, int, char *, char *, char *, char *, char *);
d91 2
a92 2
	if (opt == D_EDIT && (sflag || lflag))
		warnx("warning: shouldn't give -s or -l with -e");
a99 2
	for (etitle = title; *etitle; etitle++)
		;
d124 1
a124 3
			if (lflag)
				d1->d_flags |= ONLY;
			else if (opt == 0 || opt == 2)
d133 1
a133 3
			if (lflag)
				d2->d_flags |= ONLY;
			else if (opt == 0 || opt == 2)
a138 10
	if (lflag) {
		scanpr(dir1, ONLY, "Only in %.*s", file1, efile1, 0, 0);
		scanpr(dir2, ONLY, "Only in %.*s", file2, efile2, 0, 0);
		scanpr(dir1, SAME, "Common identical files in %.*s and %.*s",
		    file1, efile1, file2, efile2);
		scanpr(dir1, DIFFER, "Binary files which differ in %.*s and %.*s",
		    file1, efile1, file2, efile2);
		scanpr(dir1, DIRECT, "Common subdirectories of %.*s and %.*s",
		    file1, efile1, file2, efile2);
	}
a139 2
		if (header && lflag)
			printf("\f");
d147 1
a147 1
			calldiff(0);
a174 24
static void
scanpr(struct dir *dp, int test, char *title, char *file1, char *efile1,
    char *file2, char *efile2)
{
	int titled = 0;

	for (; dp->d_entry; dp++) {
		if ((dp->d_flags & test) == 0)
			continue;
		if (titled == 0) {
			if (header == 0)
				header = 1;
			else
				printf("\n");
			printf(title,
			    efile1 - file1 - 1, file1,
			    efile2 - file2 - 1, file2);
			printf(":\n");
			titled = 1;
		}
		printf("\t%s\n", dp->d_entry);
	}
}

d255 1
a255 1
				if (lflag || opt == D_EDIT)
d278 1
a278 5
	if (sflag == 0)
		goto closem;
	if (lflag)
		dp->d_flags = SAME;
	else
d284 1
a284 3
		if (lflag)
			dp->d_flags |= DIFFER;
		else if (opt == D_NORMAL || opt == D_CONTEXT || opt == D_UNIFIED)
d292 6
a297 12
	if (lflag)
		calldiff(title);
	else {
		if (opt == D_EDIT) {
			printf("ed - %s << '-*-END-*-'\n", dp->d_entry);
			calldiff(0);
		} else {
			printf("%s%s %s\n", title, file1, file2);
			calldiff(0);
		}
		if (opt == D_EDIT)
			printf("w\nq\n-*-END-*-\n");
d299 2
d308 1
a308 1
calldiff(char *wantpr)
d310 1
a310 1
	int lstatus, lstatus2, pv[2];
a312 1
	prargs[2] = wantpr;
a313 16
	if (wantpr) {
		snprintf(etitle, title + sizeof title - etitle,
		    "%s %s", file1, file2);
		pipe(pv);
		pid = fork();
		if (pid == -1)
			errorx("No more processes");
		if (pid == 0) {
			close(0);
			dup(pv[0]);
			close(pv[0]);
			close(pv[1]);
			execv(_PATH_PR, prargs);
			errorx("%s", _PATH_PR);
		}
	}
a317 6
		if (wantpr) {
			close(1);
			dup(pv[1]);
			close(pv[0]);
			close(pv[1]);
		}
a320 4
	if (wantpr) {
		close(pv[0]);
		close(pv[1]);
	}
a321 2
		continue;
	while (wait(&lstatus2) != -1)
@


1.15
log
@-a to force ascii compare.  ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.14 2003/06/26 18:19:29 millert Exp $	*/
d49 1
d387 2
a388 3
			execv(pr + 4, prargs);
			execv(pr, prargs);
			errorx("%s", pr);
d401 2
a402 3
		execv(diff + 4, diffargv);
		execv(diff, diffargv);
		error("%s", diff);
@


1.14
log
@Fix temp file handling.
o honor TMPDIR environment variable as per man page
o need 2 temp files if both file1 and file2 are devices
o add error() and errorx() which cleanup temp file and then
call err() and errx() respectively.

OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.13 2003/06/25 22:14:43 millert Exp $	*/
d425 3
@


1.13
log
@Add unidiff support and try to pretty up usage() a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.12 2003/06/25 21:43:49 millert Exp $	*/
d189 1
a189 1
		errx(1, "%s: %s", file, strerror(ENAMETOOLONG));
d242 2
a243 4
	if (dirp == NULL) {
		warn("%s", cp);
		done(0);
	}
d285 1
a285 1
		perror(file1);
d290 1
a290 1
		perror(file2);
d379 2
a380 4
		if (pid == -1) {
			warnx("No more processes");
			done(0);
		}
d388 1
a388 2
			perror(pr);
			done(0);
d392 2
a393 4
	if (pid == -1) {
		warnx("No more processes");
		done(0);
	}
d403 1
a403 2
		perror(diff);
		done(0);
@


1.12
log
@o use S_ISDIR instead of doing it by hand
o rename talloc -> emalloc and ralloc -> erealloc
o struct direct -> struct dirent (POSIX)
o kill remaining strcpy()
o fix unterminated string in setfile()
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.11 2003/06/25 17:49:22 millert Exp $	*/
d341 1
a341 1
		else if (opt == D_NORMAL || opt == D_CONTEXT)
@


1.11
log
@o use getopt()
o use err/warn
o only call done() when needed (after mkstemp)
o add "-C lines" like GNU grep
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.10 2003/06/25 03:50:27 deraadt Exp $	*/
d40 3
d45 1
a45 1
#include <fcntl.h>
a46 1
#include <string.h>
d168 4
a171 2
			strcpy(efile1, d1->d_entry);
			strcpy(efile2, d1->d_entry);
d182 1
d184 13
a196 5
	*fpp = talloc(BUFSIZ);
	strcpy(*fpp, file);
	for (cp = *fpp; *cp; cp++)
		continue;
	*cp++ = '/';
d237 1
a237 1
	struct direct *rp;
d247 1
a247 1
	dp = talloc(sizeof(struct dir));
d255 2
a256 2
			ep->d_entry = talloc(ep->d_namlen + 1);
			strcpy(ep->d_entry, rp->d_name);
d258 1
a258 1
		dp = ralloc(dp, (nitems + 1) * sizeof(struct dir));
d283 2
a284 2
	strcpy(efile1, dp->d_entry);
	strcpy(efile2, dp->d_entry);
@


1.10
log
@more knf
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.9 2003/06/25 03:44:49 deraadt Exp $	*/
d94 2
a95 4
	if (opt == D_IFDEF) {
		fprintf(stderr, "diff: can't specify -I with directories\n");
		done(0);
	}
d97 1
a97 2
		fprintf(stderr,
		    "diff: warning: shouldn't give -s or -l with -e\n");
d230 1
a230 2
		fprintf(stderr, "diff: ");
		perror(cp);
d369 1
a369 1
			fprintf(stderr, "No more processes");
d385 1
a385 1
		fprintf(stderr, "diff: No more processes\n");
@


1.9
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.8 2003/06/25 03:39:23 tedu Exp $	*/
d108 2
a109 1
	for (etitle = title; *etitle; etitle++);
@


1.8
log
@-Wstrict-prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.7 2003/06/25 03:37:32 deraadt Exp $	*/
a86 1

d90 1
d92 1
a92 3
	struct dir *dir1, *dir2;
	int i;
	int cmp;
d269 2
a270 2
	int i, j;
	int f1, f2, fmt1, fmt2;
a271 1
	char buf1[BUFSIZ], buf2[BUFSIZ];
d361 2
a362 1
	int pid, lstatus, lstatus2, pv[2];
d421 1
a421 1
	char buf[BUFSIZ];
a422 1
	char *cp;
@


1.7
log
@exit path signal race safe
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.6 2003/06/25 03:32:11 deraadt Exp $	*/
d40 1
d85 2
a223 2
int entcmp();

d258 2
a259 2
int
entcmp(struct dir *d1, struct dir *d2)
d261 4
@


1.6
log
@fix lseek
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.5 2003/06/25 03:29:46 deraadt Exp $	*/
d95 1
a95 1
		done();
d235 1
a235 1
		done();
d370 1
a370 1
			done();
d380 1
a380 1
			done();
d386 1
a386 1
		done();
d398 1
a398 1
		done();
d410 1
a410 1
			done();
@


1.5
log
@snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.4 2003/06/25 03:25:29 tedu Exp $	*/
d422 1
a422 1
	lseek(f, 0, 0);
@


1.4
log
@more cast removal, and fix some indent(1) oddities
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.3 2003/06/25 03:02:33 tedu Exp $	*/
d364 2
a365 1
		sprintf(etitle, "%s %s", file1, file2);
@


1.3
log
@cleanup.  ansi, headers, correct prototypes, some safer string and
tempfile functions, whitespace, ...
no functional improvements yet
@
text
@d1 1
a1 1
/*	$OpenBSD: diffdir.c,v 1.2 2003/06/25 01:23:38 deraadt Exp $	*/
d82 1
a82 1
static void only(struct dir * dp, int which);
d189 1
a189 1
scanpr(struct dir * dp, int test, char *title, char *file1, char *efile1,
d213 1
a213 1
only(struct dir * dp, int which)
d249 1
a249 6
		dp = realloc((char *) dp,
		    (nitems + 1) * sizeof(struct dir));
		if (dp == 0) {
			fprintf(stderr, "diff: ran out of memory\n");
			done();
		}
d258 1
a258 1
entcmp(struct dir * d1, struct dir * d2)
d264 1
a264 1
compare(struct dir * dp)
@


1.2
log
@caldera licenses
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 7
a43 1
static	char *sccsid = "@@(#)diffdir.c	4.12 (Berkeley) 4/30/89";
d46 5
d62 4
a65 4
	u_long	d_ino;
	short	d_reclen;
	short	d_namlen;
	char	*d_entry;
d68 16
a83 5
struct	dir *setupdir();
int	header;
static int	dirstatus;		/* exit status from diffdir */
extern int	status;
char	title[2*BUFSIZ], *etitle;
d85 2
a86 2
diffdir(argv)
	char **argv;
d88 1
a88 1
	register struct dir *d1, *d2;
d90 1
a90 1
	register int i;
d100 2
a101 3
	title[0] = 0;
	strcpy(title, "diff ");
	for (i = 1; diffargv[i+2]; i++) {
d104 2
a105 2
		strcat(title, diffargv[i]);
		strcat(title, " ");
d107 1
a107 2
	for (etitle = title; *etitle; etitle++)
		;
d114 2
a115 1
	d1 = dir1; d2 = dir2;
d164 1
a164 1
		for (d1 = dir1; d1->d_entry; d1++)  {
d175 2
a176 3
setfile(fpp, epp, file)
	char **fpp, **epp;
	char *file;
d178 1
a178 1
	register char *cp;
d180 1
a180 5
	*fpp = malloc(BUFSIZ);
	if (*fpp == 0) {
		fprintf(stderr, "diff: ran out of memory\n");
		exit(1);
	}
d188 3
a190 4
scanpr(dp, test, title, file1, efile1, file2, efile2)
	register struct dir *dp;
	int test;
	char *title, *file1, *efile1, *file2, *efile2;
d212 2
a213 3
only(dp, which)
	struct dir *dp;
	int which;
d218 1
a218 2
	printf("Only in %.*s: %s\n", efile - file - 1, file, dp->d_entry);
	
d221 1
a221 1
int	entcmp();
d224 1
a224 2
setupdir(cp)
	char *cp;
d226 3
a228 3
	register struct dir *dp, *ep;
	register struct direct *rp;
	register int nitems, n;
d238 2
a239 6
	dp = (struct dir *)malloc(sizeof (struct dir));
	if (dp == 0) {
		fprintf(stderr, "diff: ran out of memory\n");
		done();
	}
	while (rp = readdir(dirp)) {
d246 1
a246 5
			ep->d_entry = malloc(ep->d_namlen + 1);
			if (ep->d_entry == 0) {
				fprintf(stderr, "diff: out of memory\n");
				done();
			}
d249 2
a250 2
		dp = (struct dir *)realloc((char *)dp,
			(nitems + 1) * sizeof (struct dir));
d256 1
a256 1
	dp[nitems].d_entry = 0;		/* delimiter */
d258 1
a258 1
	qsort(dp, nitems, sizeof (struct dir), entcmp);
d262 2
a263 2
entcmp(d1, d2)
	struct dir *d1, *d2;
d268 2
a269 2
compare(dp)
	register struct dir *dp;
d271 1
a271 1
	register int i, j;
a273 1
	int flag = 0;
d289 2
a290 1
	fstat(f1, &stb1); fstat(f2, &stb2);
d339 2
a340 1
	close(f1); close(f2);
d357 2
a358 1
	close(f1); close(f2);
d361 2
a362 4
char	*prargs[] = { "pr", "-h", 0, "-f", 0, 0 };

calldiff(wantpr)
	char *wantpr;
d369 1
a369 1
		(void)sprintf(etitle, "%s %s", file1, file2);
d381 1
a381 1
			execv(pr+4, prargs);
d399 1
a399 1
		execv(diff+4, diffargv);
d412 4
a415 4
/*
	if ((lstatus >> 8) >= 2)
		done();
*/
d419 2
a420 4
#include <a.out.h>

ascii(f)
	int f;
d423 2
a424 2
	register int cnt;
	register char *cp;
d426 1
a426 1
	lseek(f, (long)0, 0);
a427 6
	if (cnt >= sizeof (struct exec)) {
		struct exec hdr;
		hdr = *(struct exec *)buf;
		if (!N_BADMAG(hdr))
			return (0);
	}
d438 2
a439 2
useless(cp)
register char *cp;
a440 1

@


1.1
log
@4.3reno diff.  This is free because of the Caldera license.  Nasty, but a
place to start.
@
text
@d1 36
@

