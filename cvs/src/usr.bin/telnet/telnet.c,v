head	1.35;
access;
symbols
	OPENBSD_6_2_BASE:1.35
	OPENBSD_6_1:1.35.0.8
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.4
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.20.0.22
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.18
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.16
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.14
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.12
	OPENBSD_5_0:1.20.0.10
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.8
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.6
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.19.0.18
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.16
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.14
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.12
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.10
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.8
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.6
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2016.01.26.18.35.01;	author mmcc;	state Exp;
branches;
next	1.34;
commitid	GsRXMVCQnadZuSoJ;

1.34
date	2015.12.23.13.08.24;	author sthen;	state Exp;
branches;
next	1.33;
commitid	Mix6uOb5H4Cc1EGM;

1.33
date	2015.11.24.05.06.24;	author beck;	state Exp;
branches;
next	1.32;
commitid	UPNmjZ9lwrIxCZws;

1.32
date	2015.11.13.17.13.59;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	F2YeJCpXd3bTjvTz;

1.31
date	2015.11.13.17.01.12;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	d9ke1jbuBYVSlCUU;

1.30
date	2014.09.09.03.41.08;	author guenther;	state Exp;
branches;
next	1.29;
commitid	VR4fCtOZMbshOip1;

1.29
date	2014.07.22.07.30.24;	author jsg;	state Exp;
branches;
next	1.28;
commitid	5F2TXUtxGWuYgYJc;

1.28
date	2014.07.20.10.55.26;	author guenther;	state Exp;
branches;
next	1.27;
commitid	KvN9Bh2AXHiOi5nI;

1.27
date	2014.07.20.10.32.23;	author jsg;	state Exp;
branches;
next	1.26;
commitid	9XoXHCD8D3PmuHcG;

1.26
date	2014.07.20.10.18.10;	author guenther;	state Exp;
branches;
next	1.25;
commitid	g3VtcxajtWcT7VuD;

1.25
date	2014.07.20.08.56.47;	author guenther;	state Exp;
branches;
next	1.24;
commitid	uvklKjlkNqUA10lW;

1.24
date	2014.07.20.08.12.46;	author guenther;	state Exp;
branches;
next	1.23;
commitid	qbZdS8s4KEeVt81G;

1.23
date	2014.07.20.06.39.41;	author guenther;	state Exp;
branches;
next	1.22;
commitid	2c9hYJDg2dE2R3T8;

1.22
date	2014.07.20.03.00.31;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	HAasfAU6uciboOsY;

1.21
date	2014.07.19.23.50.38;	author guenther;	state Exp;
branches;
next	1.20;
commitid	J1fNmylmVMpKGeua;

1.20
date	2009.04.28.06.46.03;	author chl;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.27.15.46.42;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.08.19.17.29;	author jmc;	state Exp;
branches
	1.18.2.1
	1.18.4.1;
next	1.17;

1.17
date	2003.10.04.10.18.05;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.03.02.56.18;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.22.13.49.28;	author hin;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.17.17.20.49;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.03.00.07.53;	author hin;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.10.15.33.13;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.24.21.52.38;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.10.15.41.11;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.12.30.16.58.22;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	99.07.23.15.04.48;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	98.07.27.15.29.29;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.05.15.03.16.43;	author art;	state Exp;
branches;
next	1.4;

1.4
date	98.03.12.04.57.43;	author art;	state Exp;
branches;
next	1.3;

1.3
date	97.06.05.01.07.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.27.19.33.10;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.15;	author deraadt;	state Exp;
branches;
next	;

1.18.2.1
date	2005.03.29.20.20.10;	author brad;	state Exp;
branches;
next	;

1.18.4.1
date	2005.03.29.19.49.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.35
log
@typos
@
text
@/*	$OpenBSD: telnet.c,v 1.34 2015/12/23 13:08:24 sthen Exp $	*/
/*	$NetBSD: telnet.c,v 1.7 1996/02/28 21:04:15 thorpej Exp $	*/

/*
 * Copyright (c) 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "telnet_locl.h"

#include <arpa/telnet.h>
#include <ctype.h>
#include <curses.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <term.h>

#define        strip(x) (eight ? (x) : ((x) & 0x7f))

static unsigned char	subbuffer[SUBBUFSIZE],
			*subpointer, *subend;	 /* buffer for sub-options */
#define	SB_CLEAR()	subpointer = subbuffer;
#define	SB_TERM()	{ subend = subpointer; SB_CLEAR(); }
#define	SB_ACCUM(c)	if (subpointer < (subbuffer+sizeof subbuffer)) { \
				*subpointer++ = (c); \
			}

#define	SB_GET()	((*subpointer++)&0xff)
#define	SB_PEEK()	((*subpointer)&0xff)
#define	SB_EOF()	(subpointer >= subend)
#define	SB_LEN()	(subend - subpointer)

static void	lm_will(unsigned char *, int);
static void	lm_wont(unsigned char *, int);
static void	lm_do(unsigned char *, int);
static void	lm_dont(unsigned char *, int);

static void	slc_init(void);
static void	slc_import(int);
static void	slc_export(void);
static void	slc_start_reply(void);
static void	slc_add_reply(unsigned char, unsigned char, cc_t);
static void	slc_end_reply(void);
static void	slc(unsigned char *, int);
static int	slc_update(void);

static void	env_opt(char *, int);
static void	env_opt_start(void);

char	options[256];		/* The combined options */
char	do_dont_resp[256];
char	will_wont_resp[256];

int
	eight = 3,
	binary = 0,
	autologin = 0,	/* Autologin anyone? */
	skiprc = 0,
	connections = 0,
	connected,
	showoptions,
	ISend,		/* trying to send network data in */
	crmod,
	netdata,	/* Print out network data flow */
	crlf,		/* Should '\r' be mapped to <CR><LF> (or <CR><NUL>)? */
	telnetport,
	SYNCHing,	/* we are in TELNET SYNCH mode */
	flushout,	/* flush output */
	autoflush = 0,	/* flush output when interrupting? */
	autosynch,	/* send interrupt characters with SYNCH? */
	localflow,	/* we handle flow control locally */
	restartany,	/* if flow control enabled, restart on any character */
	localchars,	/* we recognize interrupt/quit */
	donelclchars,	/* the user has set "localchars" */
	donebinarytoggle,	/* the user has put us in binary */
	dontlecho,	/* do we suppress local echoing right now? */
	globalmode,
	clienteof = 0;

char *prompt = NULL;

int scheduler_lockout_tty = 0;

cc_t escape;
cc_t rlogin;
#ifdef	KLUDGELINEMODE
cc_t echoc;
#endif

/*
 * Telnet receiver states for fsm
 */
#define	TS_DATA		0
#define	TS_IAC		1
#define	TS_WILL		2
#define	TS_WONT		3
#define	TS_DO		4
#define	TS_DONT		5
#define	TS_CR		6
#define	TS_SB		7		/* sub-option collection */
#define	TS_SE		8		/* looking for sub-option end */

static int	telrcv_state;
# define telopt_environ TELOPT_NEW_ENVIRON

jmp_buf	toplevel = { 0 };
jmp_buf	peerdied;

int	flushline;
int	linemode;

#ifdef	KLUDGELINEMODE
int	kludgelinemode = 1;
#endif

/*
 * The following are some clocks used to decide how to interpret
 * the relationship between various variables.
 */

Clocks clocks;


/*
 * Initialize telnet environment.
 */

void
init_telnet(void)
{
    env_init();

    SB_CLEAR();
    memset(options, 0, sizeof options);

    connected = ISend = localflow = donebinarytoggle = 0;
    restartany = -1;

    SYNCHing = 0;

    escape = CONTROL(']');
    rlogin = _POSIX_VDISABLE;
#ifdef	KLUDGELINEMODE
    echoc = CONTROL('E');
#endif

    flushline = 1;
    telrcv_state = TS_DATA;
}


/*
 * These routines are in charge of sending option negotiations
 * to the other side.
 *
 * The basic idea is that we send the negotiation if either side
 * is in disagreement as to what the current state should be.
 */

void
send_do(int c, int init)
{
    if (init) {
	if (((do_dont_resp[c] == 0) && my_state_is_do(c)) ||
				my_want_state_is_do(c))
	    return;
	set_my_want_state_do(c);
	do_dont_resp[c]++;
    }
    NET2ADD(IAC, DO);
    NETADD(c);
    printoption("SENT",DO, c);
}

void
send_dont(int c, int init)
{
    if (init) {
	if (((do_dont_resp[c] == 0) && my_state_is_dont(c)) ||
				my_want_state_is_dont(c))
	    return;
	set_my_want_state_dont(c);
	do_dont_resp[c]++;
    }
    NET2ADD(IAC, DONT);
    NETADD(c);
    printoption("SENT", DONT, c);
}

void
send_will(int c, int init)
{
    if (init) {
	if (((will_wont_resp[c] == 0) && my_state_is_will(c)) ||
				my_want_state_is_will(c))
	    return;
	set_my_want_state_will(c);
	will_wont_resp[c]++;
    }
    NET2ADD(IAC, WILL);
    NETADD(c);
    printoption("SENT", WILL, c);
}

void
send_wont(int c, int init)
{
    if (init) {
	if (((will_wont_resp[c] == 0) && my_state_is_wont(c)) ||
				my_want_state_is_wont(c))
	    return;
	set_my_want_state_wont(c);
	will_wont_resp[c]++;
    }
    NET2ADD(IAC, WONT);
    NETADD(c);
    printoption("SENT", WONT, c);
}

static void
willoption(int option)
{
	int new_state_ok = 0;

	if (do_dont_resp[option]) {
	    --do_dont_resp[option];
	    if (do_dont_resp[option] && my_state_is_do(option))
		--do_dont_resp[option];
	}

	if ((do_dont_resp[option] == 0) && my_want_state_is_dont(option)) {

	    switch (option) {

	    case TELOPT_ECHO:
	    case TELOPT_BINARY:
	    case TELOPT_SGA:
		settimer(modenegotiated);
		/* FALL THROUGH */
	    case TELOPT_STATUS:
		new_state_ok = 1;
		break;

	    case TELOPT_TM:
		if (flushout)
		    flushout = 0;
		/*
		 * Special case for TM.  If we get back a WILL,
		 * pretend we got back a WONT.
		 */
		set_my_want_state_dont(option);
		set_my_state_dont(option);
		return;			/* Never reply to TM will's/wont's */

	    case TELOPT_LINEMODE:
	    default:
		break;
	    }

	    if (new_state_ok) {
		set_my_want_state_do(option);
		send_do(option, 0);
		setconnmode(0);		/* possibly set new tty mode */
	    } else {
		do_dont_resp[option]++;
		send_dont(option, 0);
	    }
	}
	set_my_state_do(option);

}

static void
wontoption(int option)
{
	if (do_dont_resp[option]) {
	    --do_dont_resp[option];
	    if (do_dont_resp[option] && my_state_is_dont(option))
		--do_dont_resp[option];
	}

	if ((do_dont_resp[option] == 0) && my_want_state_is_do(option)) {

	    switch (option) {

#ifdef	KLUDGELINEMODE
	    case TELOPT_SGA:
		if (!kludgelinemode)
		    break;
		/* FALL THROUGH */
#endif
	    case TELOPT_ECHO:
		settimer(modenegotiated);
		break;

	    case TELOPT_TM:
		if (flushout)
		    flushout = 0;
		set_my_want_state_dont(option);
		set_my_state_dont(option);
		return;		/* Never reply to TM will's/wont's */

	    default:
		break;
	    }
	    set_my_want_state_dont(option);
	    if (my_state_is_do(option))
		send_dont(option, 0);
	    setconnmode(0);			/* Set new tty mode */
	} else if (option == TELOPT_TM) {
	    /*
	     * Special case for TM.
	     */
	    if (flushout)
		flushout = 0;
	    set_my_want_state_dont(option);
	}
	set_my_state_dont(option);
}

static void
dooption(int option)
{
	int new_state_ok = 0;

	if (will_wont_resp[option]) {
	    --will_wont_resp[option];
	    if (will_wont_resp[option] && my_state_is_will(option))
		--will_wont_resp[option];
	}

	if (will_wont_resp[option] == 0) {
	  if (my_want_state_is_wont(option)) {

	    switch (option) {

	    case TELOPT_TM:
		/*
		 * Special case for TM.  We send a WILL, but pretend
		 * we sent WONT.
		 */
		send_will(option, 0);
		set_my_want_state_wont(TELOPT_TM);
		set_my_state_wont(TELOPT_TM);
		return;

	    case TELOPT_BINARY:		/* binary mode */
	    case TELOPT_NAWS:		/* window size */
	    case TELOPT_TSPEED:		/* terminal speed */
	    case TELOPT_LFLOW:		/* local flow control */
	    case TELOPT_TTYPE:		/* terminal type option */
	    case TELOPT_SGA:		/* no big deal */
		new_state_ok = 1;
		break;

	    case TELOPT_NEW_ENVIRON:	/* New environment variable option */
		new_state_ok = 1;
		break;

	    case TELOPT_XDISPLOC:	/* X Display location */
		if (env_getvalue("DISPLAY", 0))
		    new_state_ok = 1;
		break;

	    case TELOPT_LINEMODE:
#ifdef	KLUDGELINEMODE
		kludgelinemode = 0;
		send_do(TELOPT_SGA, 1);
#endif
		set_my_want_state_will(TELOPT_LINEMODE);
		send_will(option, 0);
		set_my_state_will(TELOPT_LINEMODE);
		slc_init();
		return;

	    case TELOPT_ECHO:		/* We're never going to echo... */
	    default:
		break;
	    }

	    if (new_state_ok) {
		set_my_want_state_will(option);
		send_will(option, 0);
		setconnmode(0);			/* Set new tty mode */
	    } else {
		will_wont_resp[option]++;
		send_wont(option, 0);
	    }
	  } else {
	    /*
	     * Handle options that need more things done after the
	     * other side has acknowledged the option.
	     */
	    switch (option) {
	    case TELOPT_LINEMODE:
#ifdef	KLUDGELINEMODE
		kludgelinemode = 0;
		send_do(TELOPT_SGA, 1);
#endif
		set_my_state_will(option);
		slc_init();
		send_do(TELOPT_SGA, 0);
		return;
	    }
	  }
	}
	set_my_state_will(option);
}

static void
dontoption(int option)
{

	if (will_wont_resp[option]) {
	    --will_wont_resp[option];
	    if (will_wont_resp[option] && my_state_is_wont(option))
		--will_wont_resp[option];
	}

	if ((will_wont_resp[option] == 0) && my_want_state_is_will(option)) {
	    switch (option) {
	    case TELOPT_LINEMODE:
		linemode = 0;	/* put us back to the default state */
		break;
	    }
	    /* we always accept a DONT */
	    set_my_want_state_wont(option);
	    if (my_state_is_will(option))
		send_wont(option, 0);
	    setconnmode(0);			/* Set new tty mode */
	}
	set_my_state_wont(option);
}

/*
 * This routine will turn a pipe separated list of names in the buffer
 * into an array of pointers to NUL terminated names.  We toss out any
 * bad, duplicate, or verbose names (names with spaces).
 */

int is_unique(char *, char **, char **);

static char *name_unknown = "UNKNOWN";
static char *unknown[] = { NULL, NULL };

char **
mklist(char *buf, char *name)
{
	int n;
	char c, *cp, **argvp, *cp2, **argv, **avt;

	if (name) {
		if (strlen(name) > 40) {
			name = NULL;
			unknown[0] = name_unknown;
		} else {
			unknown[0] = name;
			upcase(name);
		}
	} else
		unknown[0] = name_unknown;
	/*
	 * Count up the number of names.
	 */
	for (n = 1, cp = buf; *cp; cp++) {
		if (*cp == '|')
			n++;
	}
	/*
	 * Allocate an array to put the name pointers into
	 */
	argv = reallocarray(NULL, n+3, sizeof(char *));
	if (argv == NULL)
		return(unknown);

	/*
	 * Fill up the array of pointers to names.
	 */
	*argv = NULL;
	argvp = argv+1;
	n = 0;
	for (cp = cp2 = buf; (c = *cp);  cp++) {
		if (c == '|' || c == ':') {
			*cp++ = '\0';
			/*
			 * Skip entries that have spaces or are over 40
			 * characters long.  If this is our environment
			 * name, then put it up front.  Otherwise, as
			 * long as this is not a duplicate name (case
			 * insensitive) add it to the list.
			 */
			if (n || (cp - cp2 > 41))
				;
			else if (name && (strncasecmp(name, cp2, cp-cp2) == 0))
				*argv = cp2;
			else if (is_unique(cp2, argv+1, argvp))
				*argvp++ = cp2;
			if (c == ':')
				break;
			/*
			 * Skip multiple delimiters. Reset cp2 to
			 * the beginning of the next name. Reset n,
			 * the flag for names with spaces.
			 */
			while ((c = *cp) == '|')
				cp++;
			cp2 = cp;
			n = 0;
		}
		/*
		 * Skip entries with spaces or non-ascii values.
		 * Convert lower case letters to upper case.
		 */
#define ISASCII(c) (!((c)&0x80))
		if ((c == ' ') || !ISASCII(c))
			n = 1;
		else
			*cp = toupper((unsigned char)c);
	}

	/*
	 * Check for an old V6 2 character name.  If the second
	 * name points to the beginning of the buffer, and is
	 * only 2 characters long, move it to the end of the array.
	 */
	if ((argv[1] == buf) && (strlen(argv[1]) == 2)) {
		--argvp;
		for (avt = &argv[1]; avt < argvp; avt++)
			*avt = *(avt+1);
		*argvp++ = buf;
	}

	/*
	 * Duplicate last name, for TTYPE option, and null
	 * terminate the array.  If we didn't find a match on
	 * our terminal name, put that name at the beginning.
	 */
	cp = *(argvp-1);
	*argvp++ = cp;
	*argvp = NULL;

	if (*argv == NULL) {
		if (name)
			*argv = name;
		else {
			--argvp;
			for (avt = argv; avt < argvp; avt++)
				*avt = *(avt+1);
		}
	}
	if (*argv)
		return(argv);
	else
		return(unknown);
}

int
is_unique(char *name, char **as, char **ae)
{
	char **ap;
	int n;

	n = strlen(name) + 1;
	for (ap = as; ap < ae; ap++)
		if (strncasecmp(*ap, name, n) == 0)
			return(0);
	return (1);
}

int resettermname = 1;

char *
gettermname(void)
{
	char *tname;
	static char **tnamep = NULL;
	static char **next;
	int errret;

	if (resettermname) {
		resettermname = 0;
		if (tnamep && tnamep != unknown)
			free(tnamep);
		if ((tname = env_getvalue("TERM", 0)) &&
		    (setupterm(tname, 1, &errret) == OK)) {
			tnamep = mklist(ttytype, tname);
		} else {
			if (tname && (strlen(tname) <= 40)) {
				unknown[0] = tname;
				upcase(tname);
			} else
				unknown[0] = name_unknown;
			tnamep = unknown;
		}
		next = tnamep;
	}
	if (*next == NULL)
		next = tnamep;
	return(*next++);
}

/*
 * suboption()
 *
 *	Look at the sub-option buffer, and try to be helpful to the other
 * side.
 *
 *	Currently we recognize:
 *
 *		Terminal type, send request.
 *		Terminal speed (send request).
 *		Local flow control (is request).
 *		Linemode
 */

static void
suboption(void)
{
    unsigned char subchar;

    printsub('<', subbuffer, SB_LEN()+2);
    switch (subchar = SB_GET()) {
    case TELOPT_TTYPE:
	if (my_want_state_is_wont(TELOPT_TTYPE))
	    return;
	if (SB_EOF() || SB_GET() != TELQUAL_SEND) {
	    return;
	} else {
	    char *name;
	    unsigned char temp[50];
	    int len;

	    name = gettermname();
	    len = strlen(name) + 4 + 2;
	    if (len < NETROOM()) {
		snprintf((char *)temp, sizeof(temp), 
			 "%c%c%c%c%s%c%c", IAC, SB, TELOPT_TTYPE,
			 TELQUAL_IS, name, IAC, SE);
		ring_supply_data(&netoring, temp, len);
		printsub('>', &temp[2], len-2);
	    } else
		ExitString("No room in buffer for terminal type.\n", 1);
	}
	break;
    case TELOPT_TSPEED:
	if (my_want_state_is_wont(TELOPT_TSPEED))
	    return;
	if (SB_EOF())
	    return;
	if (SB_GET() == TELQUAL_SEND) {
	    long ospeed, ispeed;
	    unsigned char temp[50];
	    int len;

	    TerminalSpeeds(&ispeed, &ospeed);

	    snprintf((char *)temp, sizeof(temp), 
		     "%c%c%c%c%ld,%ld%c%c", IAC, SB, TELOPT_TSPEED,
		     TELQUAL_IS, ospeed, ispeed, IAC, SE);
	    len = strlen((char *)temp+4) + 4;	/* temp[3] is 0 ... */

	    if (len < NETROOM()) {
		ring_supply_data(&netoring, temp, len);
		printsub('>', temp+2, len - 2);
	    }
/*@@*/	    else printf("lm_will: not enough room in buffer\n");
	}
	break;
    case TELOPT_LFLOW:
	if (my_want_state_is_wont(TELOPT_LFLOW))
	    return;
	if (SB_EOF())
	    return;
	switch(SB_GET()) {
	case LFLOW_RESTART_ANY:
	    restartany = 1;
	    break;
	case LFLOW_RESTART_XON:
	    restartany = 0;
	    break;
	case LFLOW_ON:
	    localflow = 1;
	    break;
	case LFLOW_OFF:
	    localflow = 0;
	    break;
	default:
	    return;
	}
	setcommandmode();
	setconnmode(0);
	break;

    case TELOPT_LINEMODE:
	if (my_want_state_is_wont(TELOPT_LINEMODE))
	    return;
	if (SB_EOF())
	    return;
	switch (SB_GET()) {
	case WILL:
	    lm_will(subpointer, SB_LEN());
	    break;
	case WONT:
	    lm_wont(subpointer, SB_LEN());
	    break;
	case DO:
	    lm_do(subpointer, SB_LEN());
	    break;
	case DONT:
	    lm_dont(subpointer, SB_LEN());
	    break;
	case LM_SLC:
	    slc(subpointer, SB_LEN());
	    break;
	case LM_MODE:
	    lm_mode(subpointer, SB_LEN(), 0);
	    break;
	default:
	    break;
	}
	break;

    case TELOPT_NEW_ENVIRON:
	if (SB_EOF())
	    return;
	switch(SB_PEEK()) {
	case TELQUAL_IS:
	case TELQUAL_INFO:
	    if (my_want_state_is_dont(subchar))
		return;
	    break;
	case TELQUAL_SEND:
	    if (my_want_state_is_wont(subchar)) {
		return;
	    }
	    break;
	default:
	    return;
	}
	env_opt(subpointer, SB_LEN());
	break;

    case TELOPT_XDISPLOC:
	if (my_want_state_is_wont(TELOPT_XDISPLOC))
	    return;
	if (SB_EOF())
	    return;
	if (SB_GET() == TELQUAL_SEND) {
	    unsigned char temp[50], *dp;
	    int len;

	    if ((dp = env_getvalue("DISPLAY", 0)) == NULL) {
		/*
		 * Something happened, we no longer have a DISPLAY
		 * variable.  So, turn off the option.
		 */
		send_wont(TELOPT_XDISPLOC, 1);
		break;
	    }
	    snprintf((char *)temp, sizeof(temp),
		    "%c%c%c%c%s%c%c", IAC, SB, TELOPT_XDISPLOC,
		    TELQUAL_IS, dp, IAC, SE);
	    len = strlen((char *)temp+4) + 4;	/* temp[3] is 0 ... */

	    if (len < NETROOM()) {
		ring_supply_data(&netoring, temp, len);
		printsub('>', temp+2, len - 2);
	    }
/*@@*/	    else printf("lm_will: not enough room in buffer\n");
	}
	break;

    default:
	break;
    }
}

static unsigned char str_lm[] = { IAC, SB, TELOPT_LINEMODE, 0, 0, IAC, SE };

static void
lm_will(unsigned char *cmd, int len)
{
    if (len < 1) {
/*@@*/	printf("lm_will: no command!!!\n");	/* Should not happen... */
	return;
    }
    switch(cmd[0]) {
    case LM_FORWARDMASK:	/* We shouldn't ever get this... */
    default:
	str_lm[3] = DONT;
	str_lm[4] = cmd[0];
	if (NETROOM() > sizeof(str_lm)) {
	    ring_supply_data(&netoring, str_lm, sizeof(str_lm));
	    printsub('>', &str_lm[2], sizeof(str_lm)-2);
	}
/*@@*/	else printf("lm_will: not enough room in buffer\n");
	break;
    }
}

static void
lm_wont(unsigned char *cmd, int len)
{
    if (len < 1) {
/*@@*/	printf("lm_wont: no command!!!\n");	/* Should not happen... */
	return;
    }
    switch(cmd[0]) {
    case LM_FORWARDMASK:	/* We shouldn't ever get this... */
    default:
	/* We are always DONT, so don't respond */
	return;
    }
}

static void
lm_do(unsigned char *cmd, int len)
{
    if (len < 1) {
/*@@*/	printf("lm_do: no command!!!\n");	/* Should not happen... */
	return;
    }
    switch(cmd[0]) {
    case LM_FORWARDMASK:
    default:
	str_lm[3] = WONT;
	str_lm[4] = cmd[0];
	if (NETROOM() > sizeof(str_lm)) {
	    ring_supply_data(&netoring, str_lm, sizeof(str_lm));
	    printsub('>', &str_lm[2], sizeof(str_lm)-2);
	}
/*@@*/	else printf("lm_do: not enough room in buffer\n");
	break;
    }
}

static void
lm_dont(unsigned char *cmd, int len)
{
    if (len < 1) {
/*@@*/	printf("lm_dont: no command!!!\n");	/* Should not happen... */
	return;
    }
    switch(cmd[0]) {
    case LM_FORWARDMASK:
    default:
	/* we are always WONT, so don't respond */
	break;
    }
}

static unsigned char str_lm_mode[] = {
	IAC, SB, TELOPT_LINEMODE, LM_MODE, 0, IAC, SE
};

void
lm_mode(unsigned char *cmd, int len, int init)
{
	if (len != 1)
		return;
	if ((linemode&MODE_MASK&~MODE_ACK) == *cmd)
		return;
	if (*cmd&MODE_ACK)
		return;
	linemode = *cmd&(MODE_MASK&~MODE_ACK);
	str_lm_mode[4] = linemode;
	if (!init)
	    str_lm_mode[4] |= MODE_ACK;
	if (NETROOM() > sizeof(str_lm_mode)) {
	    ring_supply_data(&netoring, str_lm_mode, sizeof(str_lm_mode));
	    printsub('>', &str_lm_mode[2], sizeof(str_lm_mode)-2);
	}
/*@@*/	else printf("lm_mode: not enough room in buffer\n");
	setconnmode(0);	/* set changed mode */
}



/*
 * slc()
 * Handle special character suboption of LINEMODE.
 */

struct spc {
	cc_t val;
	cc_t *valp;
	char flags;	/* Current flags & level */
	char mylevel;	/* Maximum level & flags */
} spc_data[NSLC+1];

#define SLC_IMPORT	0
#define	SLC_EXPORT	1
#define SLC_RVALUE	2
static int slc_mode = SLC_EXPORT;

static void
slc_init(void)
{
	struct spc *spcp;

	localchars = 1;
	for (spcp = spc_data; spcp < &spc_data[NSLC+1]; spcp++) {
		spcp->val = 0;
		spcp->valp = NULL;
		spcp->flags = spcp->mylevel = SLC_NOSUPPORT;
	}

#define	initfunc(func, flags) { \
					spcp = &spc_data[func]; \
					if ((spcp->valp = tcval(func))) { \
					    spcp->val = *spcp->valp; \
					    spcp->mylevel = SLC_VARIABLE|flags; \
					} else { \
					    spcp->val = 0; \
					    spcp->mylevel = SLC_DEFAULT; \
					} \
				    }

	initfunc(SLC_SYNCH, 0);
	/* No BRK */
	initfunc(SLC_AO, 0);
	initfunc(SLC_AYT, 0);
	/* No EOR */
	initfunc(SLC_ABORT, SLC_FLUSHIN|SLC_FLUSHOUT);
	initfunc(SLC_EOF, 0);
	initfunc(SLC_SUSP, SLC_FLUSHIN);
	initfunc(SLC_EC, 0);
	initfunc(SLC_EL, 0);
	initfunc(SLC_EW, 0);
	initfunc(SLC_RP, 0);
	initfunc(SLC_LNEXT, 0);
	initfunc(SLC_XON, 0);
	initfunc(SLC_XOFF, 0);
	initfunc(SLC_FORW1, 0);
	initfunc(SLC_FORW2, 0);
	/* No FORW2 */

	initfunc(SLC_IP, SLC_FLUSHIN|SLC_FLUSHOUT);
#undef	initfunc

	if (slc_mode == SLC_EXPORT)
		slc_export();
	else
		slc_import(1);

}

void
slcstate(void)
{
    printf("Special characters are %s values\n",
		slc_mode == SLC_IMPORT ? "remote default" :
		slc_mode == SLC_EXPORT ? "local" :
					 "remote");
}

void
slc_mode_export(int unused)
{
    slc_mode = SLC_EXPORT;
    if (my_state_is_will(TELOPT_LINEMODE))
	slc_export();
}

void
slc_mode_import(int def)
{
    slc_mode = def ? SLC_IMPORT : SLC_RVALUE;
    if (my_state_is_will(TELOPT_LINEMODE))
	slc_import(def);
}

unsigned char slc_import_val[] = {
	IAC, SB, TELOPT_LINEMODE, LM_SLC, 0, SLC_VARIABLE, 0, IAC, SE
};
unsigned char slc_import_def[] = {
	IAC, SB, TELOPT_LINEMODE, LM_SLC, 0, SLC_DEFAULT, 0, IAC, SE
};

static void
slc_import(int def)
{
    if (NETROOM() > sizeof(slc_import_val)) {
	if (def) {
	    ring_supply_data(&netoring, slc_import_def, sizeof(slc_import_def));
	    printsub('>', &slc_import_def[2], sizeof(slc_import_def)-2);
	} else {
	    ring_supply_data(&netoring, slc_import_val, sizeof(slc_import_val));
	    printsub('>', &slc_import_val[2], sizeof(slc_import_val)-2);
	}
    }
/*@@*/ else printf("slc_import: not enough room\n");
}

static void
slc_export(void)
{
    struct spc *spcp;

    TerminalDefaultChars();

    slc_start_reply();
    for (spcp = &spc_data[1]; spcp < &spc_data[NSLC+1]; spcp++) {
	if (spcp->mylevel != SLC_NOSUPPORT) {
	    if (spcp->val == (cc_t)(_POSIX_VDISABLE))
		spcp->flags = SLC_NOSUPPORT;
	    else
		spcp->flags = spcp->mylevel;
	    if (spcp->valp)
		spcp->val = *spcp->valp;
	    slc_add_reply(spcp - spc_data, spcp->flags, spcp->val);
	}
    }
    slc_end_reply();
    (void)slc_update();
    setconnmode(1);	/* Make sure the character values are set */
}

static void
slc(unsigned char *cp, int len)
{
	struct spc *spcp;
	int func,level;

	slc_start_reply();

	for (; len >= 3; len -=3, cp +=3) {

		func = cp[SLC_FUNC];

		if (func == 0) {
			/*
			 * Client side: always ignore 0 function.
			 */
			continue;
		}
		if (func > NSLC) {
			if ((cp[SLC_FLAGS] & SLC_LEVELBITS) != SLC_NOSUPPORT)
				slc_add_reply(func, SLC_NOSUPPORT, 0);
			continue;
		}

		spcp = &spc_data[func];

		level = cp[SLC_FLAGS]&(SLC_LEVELBITS|SLC_ACK);

		if ((cp[SLC_VALUE] == (unsigned char)spcp->val) &&
		    ((level&SLC_LEVELBITS) == (spcp->flags&SLC_LEVELBITS))) {
			continue;
		}

		if (level == (SLC_DEFAULT|SLC_ACK)) {
			/*
			 * This is an error condition, the SLC_ACK
			 * bit should never be set for the SLC_DEFAULT
			 * level.  Our best guess to recover is to
			 * ignore the SLC_ACK bit.
			 */
			cp[SLC_FLAGS] &= ~SLC_ACK;
		}

		if (level == ((spcp->flags&SLC_LEVELBITS)|SLC_ACK)) {
			spcp->val = (cc_t)cp[SLC_VALUE];
			spcp->flags = cp[SLC_FLAGS];	/* include SLC_ACK */
			continue;
		}

		level &= ~SLC_ACK;

		if (level <= (spcp->mylevel&SLC_LEVELBITS)) {
			spcp->flags = cp[SLC_FLAGS]|SLC_ACK;
			spcp->val = (cc_t)cp[SLC_VALUE];
		}
		if (level == SLC_DEFAULT) {
			if ((spcp->mylevel&SLC_LEVELBITS) != SLC_DEFAULT)
				spcp->flags = spcp->mylevel;
			else
				spcp->flags = SLC_NOSUPPORT;
		}
		slc_add_reply(func, spcp->flags, spcp->val);
	}
	slc_end_reply();
	if (slc_update())
		setconnmode(1);	/* set the  new character values */
}

void
slc_check(void)
{
    struct spc *spcp;

    slc_start_reply();
    for (spcp = &spc_data[1]; spcp < &spc_data[NSLC+1]; spcp++) {
	if (spcp->valp && spcp->val != *spcp->valp) {
	    spcp->val = *spcp->valp;
	    if (spcp->val == (cc_t)(_POSIX_VDISABLE))
		spcp->flags = SLC_NOSUPPORT;
	    else
		spcp->flags = spcp->mylevel;
	    slc_add_reply(spcp - spc_data, spcp->flags, spcp->val);
	}
    }
    slc_end_reply();
    setconnmode(1);
}


static unsigned char slc_reply[2 * SUBBUFSIZE];
static unsigned char *slc_replyp;

unsigned char
slc_add(unsigned char ch)
{
	if (slc_replyp == slc_reply + sizeof(slc_reply))
		return ch;
	return *slc_replyp++ = ch;
}

static void
slc_start_reply(void)
{
	slc_replyp = slc_reply;
	slc_add(IAC);
	slc_add(SB);
	slc_add(TELOPT_LINEMODE);
	slc_add(LM_SLC);
}

static void
slc_add_reply(unsigned char func, unsigned char flags, cc_t value)
{
	if (slc_replyp + 6 >= slc_reply + sizeof(slc_reply)) {
		printf("slc_add_reply: not enough room\n");
		return;
	}
	if (slc_add(func) == IAC)
		slc_add(IAC);
	if (slc_add(flags) == IAC)
		slc_add(IAC);
	if (slc_add((unsigned char)value) == IAC)
		slc_add(IAC);
}

static void
slc_end_reply(void)
{
    int len;

    if (slc_replyp + 2 >= slc_reply + sizeof(slc_reply)) {
	printf("slc_end_reply: not enough room\n");
	return;
    }

    slc_add(IAC);
    slc_add(SE);
    len = slc_replyp - slc_reply;
    if (len <= 6)
	return;
    if (NETROOM() > len) {
	ring_supply_data(&netoring, slc_reply, slc_replyp - slc_reply);
	printsub('>', &slc_reply[2], slc_replyp - slc_reply - 2);
    }
/*@@*/else printf("slc_end_reply: not enough room\n");
}

static int
slc_update(void)
{
	struct spc *spcp;
	int need_update = 0;

	for (spcp = &spc_data[1]; spcp < &spc_data[NSLC+1]; spcp++) {
		if (!(spcp->flags&SLC_ACK))
			continue;
		spcp->flags &= ~SLC_ACK;
		if (spcp->valp && (*spcp->valp != spcp->val)) {
			*spcp->valp = spcp->val;
			need_update = 1;
		}
	}
	return(need_update);
}

static void
env_opt(char *buf, int len)
{
	char *ep = 0, *epc = 0;
	int i;

	switch(buf[0]&0xff) {
	case TELQUAL_SEND:
		env_opt_start();
		if (len == 1) {
			env_opt_add(NULL);
		} else for (i = 1; i < len; i++) {
			switch (buf[i]&0xff) {
			case NEW_ENV_VAR:
			case ENV_USERVAR:
				if (ep) {
					*epc = 0;
					env_opt_add(ep);
				}
				ep = epc = &buf[i+1];
				break;
			case ENV_ESC:
				i++;
				/*FALL THROUGH*/
			default:
				if (epc)
					*epc++ = buf[i];
				break;
			}
		}
		if (ep) {
			*epc = 0;
			env_opt_add(ep);
		}
		env_opt_end(1);
		break;

	case TELQUAL_IS:
	case TELQUAL_INFO:
		/* Ignore for now.  We shouldn't get it anyway. */
		break;

	default:
		break;
	}
}

#define	OPT_REPLY_SIZE	(2 * SUBBUFSIZE)
static unsigned char *opt_reply;
static unsigned char *opt_replyp;
static unsigned char *opt_replyend;

void
opt_add(unsigned char ch)
{
	if (opt_replyp == opt_replyend)
		return;
	*opt_replyp++ = ch;
}

static void
env_opt_start(void)
{
	unsigned char *p;

	p = realloc(opt_reply, OPT_REPLY_SIZE);
	if (p == NULL)
		free(opt_reply);
	opt_reply = p;
	if (opt_reply == NULL) {
/*@@*/		printf("env_opt_start: realloc() failed!!!\n");
		opt_reply = opt_replyp = opt_replyend = NULL;
		return;
	}
	opt_replyp = opt_reply;
	opt_replyend = opt_reply + OPT_REPLY_SIZE;
	opt_add(IAC);
	opt_add(SB);
	opt_add(telopt_environ);
	opt_add(TELQUAL_IS);
}

void
env_opt_start_info(void)
{
	env_opt_start();
	if (opt_replyp)
	    opt_replyp[-1] = TELQUAL_INFO;
}

void
env_opt_add(char *ep)
{
	char *vp, c;

	if (opt_reply == NULL)		/*XXX*/
		return;			/*XXX*/

	if (ep == NULL || *ep == '\0') {
		/* Send user defined variables first. */
		env_default(1, 0);
		while ((ep = env_default(0, 0)))
			env_opt_add(ep);

		/* Now add the list of well know variables.  */
		env_default(1, 1);
		while ((ep = env_default(0, 1)))
			env_opt_add(ep);
		return;
	}
	vp = env_getvalue(ep, 1);
	if (2 * (vp ? strlen(vp) : 0) + 2 * strlen(ep) + 6 >
	    opt_replyend - opt_replyp)
	{
		size_t len;
		unsigned char *p;

		len = opt_replyend - opt_reply;
		len += OPT_REPLY_SIZE + 2 * strlen(ep);
		if (vp)
			len += 2 * strlen(vp);
		p = realloc(opt_reply, len);
		if (p == NULL) {
			free(opt_reply);
/*@@*/			printf("env_opt_add: realloc() failed!!!\n");
			opt_reply = opt_replyp = opt_replyend = NULL;
			return;
		}
		opt_replyp = p + (opt_replyp - opt_reply);
		opt_replyend = p + len;
		opt_reply = p;
	}
	if (opt_welldefined(ep))
		opt_add(NEW_ENV_VAR);
	else
		opt_add(ENV_USERVAR);

	for (;;) {
		while ((c = *ep++)) {
			switch(c&0xff) {
			case IAC:
				opt_add(IAC);
				break;
			case NEW_ENV_VAR:
			case NEW_ENV_VALUE:
			case ENV_ESC:
			case ENV_USERVAR:
				opt_add(ENV_ESC);
				break;
			}
			opt_add(c);
		}
		if ((ep = vp)) {
				opt_add(NEW_ENV_VALUE);
			vp = NULL;
		} else
			break;
	}
}

int
opt_welldefined(const char *ep)
{
	if ((strcmp(ep, "USER") == 0) ||
	    (strcmp(ep, "DISPLAY") == 0) ||
	    (strcmp(ep, "PRINTER") == 0) ||
	    (strcmp(ep, "SYSTEMTYPE") == 0) ||
	    (strcmp(ep, "JOB") == 0) ||
	    (strcmp(ep, "ACCT") == 0))
		return(1);
	return(0);
}

void
env_opt_end(int emptyok)
{
	int len;

	len = opt_replyp - opt_reply + 2;
	if (emptyok || len > 6) {
		opt_add(IAC);
		opt_add(SE);
		if (NETROOM() > len) {
			ring_supply_data(&netoring, opt_reply, len);
			printsub('>', &opt_reply[2], len - 2);
		}
/*@@*/		else printf("slc_end_reply: not enough room\n");
	}
	if (opt_reply) {
		free(opt_reply);
		opt_reply = opt_replyp = opt_replyend = NULL;
	}
}



int
telrcv(void)
{
    int c;
    int scc;
    unsigned char *sbp;
    int count;
    int returnValue = 0;

    scc = 0;
    count = 0;
    while (TTYROOM() > 2) {
	if (scc == 0) {
	    if (count) {
		ring_consumed(&netiring, count);
		returnValue = 1;
		count = 0;
	    }
	    sbp = netiring.consume;
	    scc = ring_full_consecutive(&netiring);
	    if (scc == 0) {
		/* No more data coming in */
		break;
	    }
	}

	c = *sbp++ & 0xff, scc--; count++;

	switch (telrcv_state) {

	case TS_CR:
	    telrcv_state = TS_DATA;
	    if (c == '\0') {
		break;	/* Ignore \0 after CR */
	    }
	    else if ((c == '\n') && my_want_state_is_dont(TELOPT_ECHO) && !crmod) {
		TTYADD(c);
		break;
	    }
	    /* Else, fall through */

	case TS_DATA:
	    if (c == IAC) {
		telrcv_state = TS_IAC;
		break;
	    }
		    /*
		     * The 'crmod' hack (see following) is needed
		     * since we can't set CRMOD on output only.
		     * Machines like MULTICS like to send \r without
		     * \n; since we must turn off CRMOD to get proper
		     * input, the mapping is done here (sigh).
		     */
	    if ((c == '\r') && my_want_state_is_dont(TELOPT_BINARY)) {
		if (scc > 0) {
		    c = *sbp&0xff;
		    if (c == 0) {
			sbp++, scc--; count++;
			/* a "true" CR */
			TTYADD('\r');
		    } else if (my_want_state_is_dont(TELOPT_ECHO) &&
					(c == '\n')) {
			sbp++, scc--; count++;
			TTYADD('\n');
		    } else {
			TTYADD('\r');
			if (crmod) {
				TTYADD('\n');
			}
		    }
		} else {
		    telrcv_state = TS_CR;
		    TTYADD('\r');
		    if (crmod) {
			    TTYADD('\n');
		    }
		}
	    } else {
		TTYADD(c);
	    }
	    continue;

	case TS_IAC:
process_iac:
	    switch (c) {

	    case WILL:
		telrcv_state = TS_WILL;
		continue;

	    case WONT:
		telrcv_state = TS_WONT;
		continue;

	    case DO:
		telrcv_state = TS_DO;
		continue;

	    case DONT:
		telrcv_state = TS_DONT;
		continue;

	    case DM:
		    /*
		     * We may have missed an urgent notification,
		     * so make sure we flush whatever is in the
		     * buffer currently.
		     */
		printoption("RCVD", IAC, DM);
		SYNCHing = 1;
		(void) ttyflush(1);
		SYNCHing = stilloob();
		break;

	    case SB:
		SB_CLEAR();
		telrcv_state = TS_SB;
		continue;

	    case IAC:
		TTYADD(IAC);
		break;

	    case NOP:
	    case GA:
	    default:
		printoption("RCVD", IAC, c);
		break;
	    }
	    telrcv_state = TS_DATA;
	    continue;

	case TS_WILL:
	    printoption("RCVD", WILL, c);
	    willoption(c);
	    telrcv_state = TS_DATA;
	    continue;

	case TS_WONT:
	    printoption("RCVD", WONT, c);
	    wontoption(c);
	    telrcv_state = TS_DATA;
	    continue;

	case TS_DO:
	    printoption("RCVD", DO, c);
	    dooption(c);
	    if (c == TELOPT_NAWS) {
		sendnaws();
	    } else if (c == TELOPT_LFLOW) {
		localflow = 1;
		setcommandmode();
		setconnmode(0);
	    }
	    telrcv_state = TS_DATA;
	    continue;

	case TS_DONT:
	    printoption("RCVD", DONT, c);
	    dontoption(c);
	    flushline = 1;
	    setconnmode(0);	/* set new tty mode (maybe) */
	    telrcv_state = TS_DATA;
	    continue;

	case TS_SB:
	    if (c == IAC) {
		telrcv_state = TS_SE;
	    } else {
		SB_ACCUM(c);
	    }
	    continue;

	case TS_SE:
	    if (c != SE) {
		if (c != IAC) {
		    /*
		     * This is an error.  We only expect to get
		     * "IAC IAC" or "IAC SE".  Several things may
		     * have happened.  An IAC was not doubled, the
		     * IAC SE was left off, or another option got
		     * inserted into the suboption are all possibilities.
		     * If we assume that the IAC was not doubled,
		     * and really the IAC SE was left off, we could
		     * get into an infinite loop here.  So, instead,
		     * we terminate the suboption, and process the
		     * partial suboption if we can.
		     */
		    SB_ACCUM(IAC);
		    SB_ACCUM(c);
		    subpointer -= 2;
		    SB_TERM();

		    printoption("In SUBOPTION processing, RCVD", IAC, c);
		    suboption();	/* handle sub-option */
		    telrcv_state = TS_IAC;
		    goto process_iac;
		}
		SB_ACCUM(c);
		telrcv_state = TS_SB;
	    } else {
		SB_ACCUM(IAC);
		SB_ACCUM(SE);
		subpointer -= 2;
		SB_TERM();
		suboption();	/* handle sub-option */
		telrcv_state = TS_DATA;
	    }
	}
    }
    if (count)
	ring_consumed(&netiring, count);
    return returnValue||count;
}

static int bol = 1, local = 0;

int
rlogin_susp(void)
{
    if (local) {
	local = 0;
	bol = 1;
	command(0, "z\n", 2);
	return(1);
    }
    return(0);
}

static int
telsnd(void)
{
    int tcc;
    int count;
    int returnValue = 0;
    unsigned char *tbp;

    tcc = 0;
    count = 0;
    while (NETROOM() > 2) {
	int sc;
	int c;

	if (tcc == 0) {
	    if (count) {
		ring_consumed(&ttyiring, count);
		returnValue = 1;
		count = 0;
	    }
	    tbp = ttyiring.consume;
	    tcc = ring_full_consecutive(&ttyiring);
	    if (tcc == 0) {
		break;
	    }
	}
	c = *tbp++ & 0xff, sc = strip(c), tcc--; count++;
	if (rlogin != _POSIX_VDISABLE) {
		if (bol) {
			bol = 0;
			if (sc == rlogin) {
				local = 1;
				continue;
			}
		} else if (local) {
			local = 0;
			if (sc == '.' || c == termEofChar) {
				bol = 1;
				command(0, "close\n", 6);
				continue;
			}
			if (sc == termSuspChar) {
				bol = 1;
				command(0, "z\n", 2);
				continue;
			}
			if (sc == escape) {
				command(0, (char *)tbp, tcc);
				bol = 1;
				count += tcc;
				tcc = 0;
				flushline = 1;
				break;
			}
			if (sc != rlogin) {
				++tcc;
				--tbp;
				--count;
				c = sc = rlogin;
			}
		}
		if ((sc == '\n') || (sc == '\r'))
			bol = 1;
	} else if (escape != _POSIX_VDISABLE && sc == escape) {
	    /*
	     * Double escape is a pass through of a single escape character.
	     */
	    if (tcc && strip(*tbp) == escape) {
		tbp++;
		tcc--;
		count++;
		bol = 0;
	    } else {
		command(0, (char *)tbp, tcc);
		bol = 1;
		count += tcc;
		tcc = 0;
		flushline = 1;
		break;
	    }
	} else
	    bol = 0;
#ifdef	KLUDGELINEMODE
	if (kludgelinemode && (globalmode&MODE_EDIT) && (sc == echoc)) {
	    if (tcc > 0 && strip(*tbp) == echoc) {
		tcc--; tbp++; count++;
	    } else {
		dontlecho = !dontlecho;
		settimer(echotoggle);
		setconnmode(0);
		flushline = 1;
		break;
	    }
	}
#endif
	if (sc != _POSIX_VDISABLE && MODE_LOCAL_CHARS(globalmode)) {
	    if (TerminalSpecialChars(sc) == 0) {
		bol = 1;
		break;
	    }
	}
	if (my_want_state_is_wont(TELOPT_BINARY)) {
	    switch (c) {
	    case '\n':
		    /*
		     * If we are in CRMOD mode (\r ==> \n)
		     * on our local machine, then probably
		     * a newline (unix) is CRLF (TELNET).
		     */
		if (MODE_LOCAL_CHARS(globalmode)) {
		    NETADD('\r');
		}
		NETADD('\n');
		bol = flushline = 1;
		break;
	    case '\r':
		if (!crlf) {
		    NET2ADD('\r', '\0');
		} else {
		    NET2ADD('\r', '\n');
		}
		bol = flushline = 1;
		break;
	    case IAC:
		NET2ADD(IAC, IAC);
		break;
	    default:
		NETADD(c);
		break;
	    }
	} else if (c == IAC) {
	    NET2ADD(IAC, IAC);
	} else {
	    NETADD(c);
	}
    }
    if (count)
	ring_consumed(&ttyiring, count);
    return returnValue||count;		/* Non-zero if we did anything */
}

/*
 * Scheduler()
 *
 * Try to do something.
 *
 * If we do something useful, return 1; else return 0.
 *
 */

int
Scheduler(int block)			/* should we block in the select ? */
{
		/* One wants to be a bit careful about setting returnValue
		 * to one, since a one implies we did some useful work,
		 * and therefore probably won't be called to block next
		 * time (TN3270 mode only).
		 */
    int returnValue;
    int netin, netout, netex, ttyin, ttyout;

    /* Decide which rings should be processed */

    netout = ring_full_count(&netoring) &&
	    (flushline ||
		(my_want_state_is_wont(TELOPT_LINEMODE)
#ifdef	KLUDGELINEMODE
			&& (!kludgelinemode || my_want_state_is_do(TELOPT_SGA))
#endif
		) ||
			my_want_state_is_will(TELOPT_BINARY));
    ttyout = ring_full_count(&ttyoring);

    ttyin = ring_empty_count(&ttyiring) && (clienteof == 0);

    netin = !ISend && ring_empty_count(&netiring);

    netex = !SYNCHing;

    /* If we have seen a signal recently, reset things */

    if (scheduler_lockout_tty) {
	ttyin = ttyout = 0;
    }

    /* Call to system code to process rings */

    returnValue = process_rings(netin, netout, netex, ttyin, ttyout, !block);

    /* Now, look at the input rings, looking for work to do. */

    if (ring_full_count(&ttyiring)) {
        returnValue |= telsnd();
    }

    if (ring_full_count(&netiring)) {
	returnValue |= telrcv();
    }
    return returnValue;
}

/*
 * Select from tty and network...
 */
void
telnet(char *user)
{
    connections++;
    sys_telnet_init();

    if (pledge("stdio rpath tty", NULL) == -1) {
	perror("pledge");
	exit(1);
    }

    if (telnetport) {
	send_do(TELOPT_SGA, 1);
	send_will(TELOPT_TTYPE, 1);
	send_will(TELOPT_NAWS, 1);
	send_will(TELOPT_TSPEED, 1);
	send_will(TELOPT_LFLOW, 1);
	send_will(TELOPT_LINEMODE, 1);
	send_will(TELOPT_NEW_ENVIRON, 1);
	send_do(TELOPT_STATUS, 1);
	if (env_getvalue("DISPLAY", 0))
	    send_will(TELOPT_XDISPLOC, 1);
	if (binary)
	    tel_enter_binary(binary);
    }

    for (;;) {
	int schedValue;

	while ((schedValue = Scheduler(0)) != 0) {
	    if (schedValue == -1) {
		setcommandmode();
		return;
	    }
	}

	if (Scheduler(1) == -1) {
	    setcommandmode();
	    return;
	}
    }
}

#if	0	/* XXX - this not being in is a bug */
/*
 * nextitem()
 *
 *	Return the address of the next "item" in the TELNET data
 * stream.  This will be the address of the next character if
 * the current address is a user data character, or it will
 * be the address of the character following the TELNET command
 * if the current address is a TELNET IAC ("I Am a Command")
 * character.
 */

static char *
nextitem(char *current)
{
    if ((*current&0xff) != IAC) {
	return current+1;
    }
    switch (*(current+1)&0xff) {
    case DO:
    case DONT:
    case WILL:
    case WONT:
	return current+3;
    case SB:		/* loop forever looking for the SE */
	{
	    char *look = current+2;

	    for (;;) {
		if ((*look++&0xff) == IAC) {
		    if ((*look++&0xff) == SE) {
			return look;
		    }
		}
	    }
	}
    default:
	return current+2;
    }
}
#endif	/* 0 */

/*
 * netclear()
 *
 *	We are about to do a TELNET SYNCH operation.  Clear
 * the path to the network.
 *
 *	Things are a bit tricky since we may have sent the first
 * byte or so of a previous TELNET command into the network.
 * So, we have to scan the network buffer from the beginning
 * until we are up to where we want to be.
 *
 *	A side effect of what we do, just to keep things
 * simple, is to clear the urgent data pointer.  The principal
 * caller should be setting the urgent data pointer AFTER calling
 * us in any case.
 */

static void
netclear(void)
{
#if	0	/* XXX */
    char *thisitem, *next;
    char *good;
#define	wewant(p)	((nfrontp > p) && ((*p&0xff) == IAC) && \
				((*(p+1)&0xff) != EC) && ((*(p+1)&0xff) != EL))

    thisitem = netobuf;

    while ((next = nextitem(thisitem)) <= netobuf.send) {
	thisitem = next;
    }

    /* Now, thisitem is first before/at boundary. */

    good = netobuf;	/* where the good bytes go */

    while (netoring.add > thisitem) {
	if (wewant(thisitem)) {
	    int length;

	    next = thisitem;
	    do {
		next = nextitem(next);
	    } while (wewant(next) && (nfrontp > next));
	    length = next-thisitem;
	    memmove(good, thisitem, length);
	    good += length;
	    thisitem = next;
	} else {
	    thisitem = nextitem(thisitem);
	}
    }

#endif	/* 0 */
}

/*
 * These routines add various telnet commands to the data stream.
 */

static void
doflush(void)
{
    NET2ADD(IAC, DO);
    NETADD(TELOPT_TM);
    flushline = 1;
    flushout = 1;
    (void) ttyflush(1);			/* Flush/drop output */
    /* do printoption AFTER flush, otherwise the output gets tossed... */
    printoption("SENT", DO, TELOPT_TM);
}

void
xmitAO(void)
{
    NET2ADD(IAC, AO);
    printoption("SENT", IAC, AO);
    if (autoflush) {
	doflush();
    }
}


void
xmitEL(void)
{
    NET2ADD(IAC, EL);
    printoption("SENT", IAC, EL);
}

void
xmitEC(void)
{
    NET2ADD(IAC, EC);
    printoption("SENT", IAC, EC);
}


int
dosynch(void)
{
    netclear();			/* clear the path to the network */
    NETADD(IAC);
    setneturg();
    NETADD(DM);
    printoption("SENT", IAC, DM);
    return 1;
}

int want_status_response = 0;

int
get_status(void)
{
    unsigned char tmp[16];
    unsigned char *cp;

    if (my_want_state_is_dont(TELOPT_STATUS)) {
	printf("Remote side does not support STATUS option\n");
	return 0;
    }
    cp = tmp;

    *cp++ = IAC;
    *cp++ = SB;
    *cp++ = TELOPT_STATUS;
    *cp++ = TELQUAL_SEND;
    *cp++ = IAC;
    *cp++ = SE;
    if (NETROOM() >= cp - tmp) {
	ring_supply_data(&netoring, tmp, cp-tmp);
	printsub('>', tmp+2, cp - tmp - 2);
    }
    ++want_status_response;
    return 1;
}

void
intp(void)
{
    NET2ADD(IAC, IP);
    printoption("SENT", IAC, IP);
    flushline = 1;
    if (autoflush) {
	doflush();
    }
    if (autosynch) {
	dosynch();
    }
}

void
sendbrk(void)
{
    NET2ADD(IAC, BREAK);
    printoption("SENT", IAC, BREAK);
    flushline = 1;
    if (autoflush) {
	doflush();
    }
    if (autosynch) {
	dosynch();
    }
}

void
sendabort(void)
{
    NET2ADD(IAC, ABORT);
    printoption("SENT", IAC, ABORT);
    flushline = 1;
    if (autoflush) {
	doflush();
    }
    if (autosynch) {
	dosynch();
    }
}

void
sendsusp(void)
{
    NET2ADD(IAC, SUSP);
    printoption("SENT", IAC, SUSP);
    flushline = 1;
    if (autoflush) {
	doflush();
    }
    if (autosynch) {
	dosynch();
    }
}

void
sendeof(void)
{
    NET2ADD(IAC, xEOF);
    printoption("SENT", IAC, xEOF);
}

void
sendayt(void)
{
    NET2ADD(IAC, AYT);
    printoption("SENT", IAC, AYT);
}

/*
 * Send a window size update to the remote system.
 */

void
sendnaws(void)
{
    long rows, cols;
    unsigned char tmp[16];
    unsigned char *cp;

    if (my_state_is_wont(TELOPT_NAWS))
	return;

#define	PUTSHORT(cp, x) { if ((*cp++ = ((x)>>8)&0xff) == IAC) *cp++ = IAC; \
			    if ((*cp++ = ((x))&0xff) == IAC) *cp++ = IAC; }

    if (TerminalWindowSize(&rows, &cols) == 0) {	/* Failed */
	return;
    }

    cp = tmp;

    *cp++ = IAC;
    *cp++ = SB;
    *cp++ = TELOPT_NAWS;
    PUTSHORT(cp, cols);
    PUTSHORT(cp, rows);
    *cp++ = IAC;
    *cp++ = SE;
    if (NETROOM() >= cp - tmp) {
	ring_supply_data(&netoring, tmp, cp-tmp);
	printsub('>', tmp+2, cp - tmp - 2);
    }
}

void
tel_enter_binary(int rw)
{
    if (rw&1)
	send_do(TELOPT_BINARY, 1);
    if (rw&2)
	send_will(TELOPT_BINARY, 1);
}

void
tel_leave_binary(int rw)
{
    if (rw&1)
	send_dont(TELOPT_BINARY, 1);
    if (rw&2)
	send_wont(TELOPT_BINARY, 1);
}
@


1.34
log
@Add rpath to telnet's more restrictive pledge; otherwise if the server requests
the client to send the next terminal-type (RFC-1091), the client tries to read
terminfo files and is killed by pledge. Noticed when connecting to 4.3 BSD.
ok semarie@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.33 2015/11/24 05:06:24 beck Exp $	*/
d1589 1
a1589 1
		     * get into an infinate loop here.  So, instead,
@


1.33
log
@Don't support repeated connections - avoids pledge problems
ok deraadt@@, "god please commit before I see any more" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.32 2015/11/13 17:13:59 deraadt Exp $	*/
d1844 1
a1844 1
    if (pledge("stdio tty", NULL) == -1) {
@


1.32
log
@pledge "stdio rpath wpath getpw inet tty" at startup.   After opening
the socket and entering the main loop, pledge "stdio tty".

For my next trick, I will be adding chacha20-poly1305 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.31 2015/11/13 17:01:12 deraadt Exp $	*/
d84 1
d1841 1
@


1.31
log
@Remove support for the debug command; noone needs setsockopt SO_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.30 2014/09/09 03:41:08 guenther Exp $	*/
d39 1
d1841 5
@


1.30
log
@Eliminate a pile of casts that were superfluous or wrong, or that were
the result of bad type choices, particularly (unsigned char *) vs
(const char *).  Also, use reallocarray().
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.29 2014/07/22 07:30:24 jsg Exp $	*/
a85 1
	debug = 0,
@


1.29
log
@use ansi style function declarations
with suggestions from and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.28 2014/07/20 10:55:26 guenther Exp $	*/
d71 1
a71 1
static void	env_opt(unsigned char *, int);
d158 1
a158 1
    memset((char *)options, 0, sizeof options);
d385 1
a385 1
		if (env_getvalue((unsigned char *)"DISPLAY", 0))
d477 1
a477 1
		if ((int)strlen(name) > 40) {
d496 1
a496 1
	argv = (char **)malloc((n+3)*sizeof(char *));
d608 2
a609 2
		if ((tname = (char *)env_getvalue((unsigned char *)"TERM", 0)) &&
				(setupterm(tname, 1, &errret) == OK)) {
d612 1
a612 1
			if (tname && ((int)strlen(tname) <= 40)) {
d776 1
a776 1
	    if ((dp = env_getvalue((unsigned char *)"DISPLAY", 0)) == NULL) {
d1209 1
a1209 1
env_opt(unsigned char *buf, int len)
d1211 1
a1211 1
	unsigned char *ep = 0, *epc = 0;
d1273 1
a1273 1
	p = (unsigned char *)realloc(opt_reply, OPT_REPLY_SIZE);
d1299 1
a1299 1
env_opt_add(unsigned char *ep)
d1301 1
a1301 1
	unsigned char *vp, c;
d1319 2
a1320 2
	if (opt_replyp + 2 * (vp ? strlen((char *)vp) : 0) +
				2 * strlen((char *)ep) + 6 > opt_replyend)
d1329 1
a1329 1
		p = (unsigned char *)realloc(opt_reply, len);
d1340 2
a1341 2
	if (opt_welldefined((char *)ep))
			opt_add(NEW_ENV_VAR);
d1369 1
a1369 1
opt_welldefined(char *ep)
d1851 1
a1851 1
	if (env_getvalue((unsigned char *)"DISPLAY", 0))
@


1.28
log
@Mark a slurry of functions as static
Eliminate two more trivial wrappers
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.27 2014/07/20 10:32:23 jsg Exp $	*/
d152 2
a153 2
    void
init_telnet()
d184 2
a185 3
    void
send_do(c, init)
    int c, init;
d199 2
a200 3
    void
send_dont(c, init)
    int c, init;
d214 2
a215 3
    void
send_will(c, init)
    int c, init;
d229 2
a230 3
    void
send_wont(c, init)
    int c, init;
a243 1

d245 1
a245 2
willoption(option)
	int option;
d298 1
a298 2
wontoption(option)
	int option;
d346 1
a346 2
dooption(option)
	int option;
d435 1
a435 2
dontoption(option)
	int option;
d470 2
a471 3
	char **
mklist(buf, name)
	char *buf, *name;
d581 2
a582 3
	int
is_unique(name, as, ae)
	char *name, **as, **ae;
d596 2
a597 2
	char *
gettermname()
d625 1
d640 2
a641 2
    static void
suboption()
d805 1
a805 3
lm_will(cmd, len)
    unsigned char *cmd;
    int len;
d826 1
a826 3
lm_wont(cmd, len)
    unsigned char *cmd;
    int len;
d841 1
a841 3
lm_do(cmd, len)
    unsigned char *cmd;
    int len;
d862 1
a862 3
lm_dont(cmd, len)
    unsigned char *cmd;
    int len;
d880 2
a881 4
	void
lm_mode(cmd, len, init)
	unsigned char *cmd;
	int len, init;
d921 1
a921 1
slc_init()
d972 2
a973 2
    void
slcstate()
d981 1
a981 1
    void
d989 2
a990 3
    void
slc_mode_import(def)
    int def;
d1005 1
a1005 2
slc_import(def)
    int def;
d1020 1
a1020 1
slc_export()
d1044 1
a1044 3
slc(cp, len)
	unsigned char *cp;
	int len;
d1111 2
a1112 2
    void
slc_check()
d1135 1
a1135 1
	unsigned char
d1144 1
a1144 1
slc_start_reply()
d1154 1
a1154 4
slc_add_reply(func, flags, value)
	unsigned char func;
	unsigned char flags;
	cc_t value;
d1169 1
a1169 1
slc_end_reply()
d1191 1
a1191 1
slc_update()
d1209 1
a1209 3
env_opt(buf, len)
	unsigned char *buf;
	int len;
d1260 1
a1260 1
	void
d1267 1
d1269 1
a1269 1
env_opt_start()
d1290 2
a1291 2
	void
env_opt_start_info()
d1298 2
a1299 3
	void
env_opt_add(ep)
	unsigned char *ep;
d1368 2
a1369 3
	int
opt_welldefined(ep)
	char *ep;
d1380 3
a1382 3
	void
env_opt_end(emptyok)
	int emptyok;
d1404 2
a1405 2
    int
telrcv()
d1621 2
a1622 2
    int
rlogin_susp()
d1633 2
a1634 2
    static int
telsnd()
d1783 2
a1784 4

    int
Scheduler(block)
    int	block;			/* should we block in the select ? */
d1837 2
a1838 3
    void
telnet(user)
    char *user;
d1886 2
a1887 3
    static char *
nextitem(current)
    char *current;
d1933 2
a1934 2
    static void
netclear()
d1976 2
a1977 2
    static void
doflush()
d1988 2
a1989 2
    void
xmitAO()
d1999 2
a2000 2
    void
xmitEL()
d2006 2
a2007 2
    void
xmitEC()
d2014 2
a2015 2
    int
dosynch()
d2027 2
a2028 2
    int
get_status()
d2053 2
a2054 2
    void
intp()
d2067 2
a2068 2
    void
sendbrk()
d2081 2
a2082 2
    void
sendabort()
d2095 2
a2096 2
    void
sendsusp()
d2109 2
a2110 2
    void
sendeof()
d2116 2
a2117 2
    void
sendayt()
d2127 2
a2128 2
    void
sendnaws()
d2159 2
a2160 3
    void
tel_enter_binary(rw)
    int rw;
d2168 2
a2169 3
    void
tel_leave_binary(rw)
    int rw;
@


1.27
log
@use NULL instead of 0 when dealing with pointers
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.26 2014/07/20 10:18:10 guenther Exp $	*/
d57 17
d249 1
a249 1
	void
d303 1
a303 1
	void
d352 1
a352 1
	static void
d442 1
a442 1
	static void
d814 1
a814 1
    void
d837 1
a837 1
    void
d854 1
a854 1
    void
d877 1
a877 1
    void
d940 1
a940 1
	void
d1025 1
a1025 1
    void
d1041 1
a1041 1
    void
d1065 1
a1065 1
	void
d1167 1
a1167 1
	void
d1177 1
a1177 1
	void
d1195 1
a1195 1
    void
d1217 1
a1217 1
	int
d1235 1
a1235 1
	void
d1296 1
a1296 1
	void
@


1.26
log
@Kill lint comments; mark ExitString() as __dead
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.25 2014/07/20 08:56:47 guenther Exp $	*/
d87 1
a87 1
char *prompt = 0;
d460 1
a460 1
static char *unknown[] = { 0, 0 };
d471 1
a471 1
			name = 0;
d490 1
a490 1
	if (argv == 0)
d496 1
a496 1
	*argv = 0;
d557 1
a557 1
	*argvp = 0;
d559 1
a559 1
	if (*argv == 0) {
d594 1
a594 1
	static char **tnamep = 0;
d615 1
a615 1
	if (*next == 0)
d931 1
a931 1
		spcp->valp = 0;
@


1.25
log
@Add prototypes to some function callbacks and fix the type errors that
this reveals.
Make NetTrace static to utilities.c
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.24 2014/07/20 08:12:46 guenther Exp $	*/
d658 1
a658 1
	    } else {
a659 2
		/*NOTREACHED*/
	    }
@


1.24
log
@More encryption tentacles: intr_happened and intr_waiting vanish
Push more includes into .c files
Make ring.c only need ring.h
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.23 2014/07/20 06:39:41 guenther Exp $	*/
a147 2
    /* Don't change NetTrace */

d987 1
a987 1
slc_mode_export()
@


1.23
log
@Correctly cast to unsigned char for ctype functions/macros
Push <ctype.h> and <unistd.h> into the .c files
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.22 2014/07/20 03:00:31 deraadt Exp $	*/
d35 1
d38 2
@


1.22
log
@remove a variable called wantencryption.
hahahahahahahahahha.  OK, I'm done.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.21 2014/07/19 23:50:38 guenther Exp $	*/
d34 2
d533 2
a534 2
		else if (islower(c))
			*cp = toupper(c);
@


1.21
log
@Flense the telnet code base of unwanted ifdefs: authentication/encryption
tn3270, sgtty, pre-POSIX and other ancient system support, etc.  Brings up
to date the manpage with what we support.

ok matthieu@@ beck@@ jmc@@ millert@@ deraadt@@ okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.20 2009/04/28 06:46:03 chl Exp $	*/
a68 1
	wantencryption = 0,
@


1.20
log
@replacing malloc/realloc dance, by only one realloc

While there, also move a variable declaration, in the #ifdef block it is
used

ok gilles@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.19 2005/02/27 15:46:42 otto Exp $	*/
a62 1
	In3270,		/* Are we in 3270 mode? */
a67 5
#if	defined(TN3270)
	noasynchtty = 0,/* User specified "-noasynch" on command line */
	noasynchnet = 0,/* User specified "-noasynch" on command line */
	askedSGA = 0,	/* We have talked about suppress go ahead */
#endif	/* defined(TN3270) */
a106 3
#ifdef	OLD_ENVIRON
unsigned char telopt_environ = TELOPT_NEW_ENVIRON;
#else
a107 1
#endif
d139 1
a139 4
    connected = In3270 = ISend = localflow = donebinarytoggle = 0;
#if	defined(AUTHENTICATION) || defined(ENCRYPTION)
    auth_encrypt_connect(connected);
#endif	/* defined(AUTHENTICATION) || defined(ENCRYPTION) */
a246 24
#	    if defined(TN3270)
		/*
		 * The following is a pain in the rear-end.
		 * Various IBM servers (some versions of Wiscnet,
		 * possibly Fibronics/Spartacus, and who knows who
		 * else) will NOT allow us to send "DO SGA" too early
		 * in the setup proceedings.  On the other hand,
		 * 4.2 servers (telnetd) won't set SGA correctly.
		 * So, we are stuck.  Empirically (but, based on
		 * a VERY small sample), the IBM servers don't send
		 * out anything about ECHO, so we postpone our sending
		 * "DO SGA" until we see "WILL ECHO" (which 4.2 servers
		 * DO send).
		  */
		{
		    if (askedSGA == 0) {
			askedSGA = 1;
			if (my_want_state_is_dont(TELOPT_SGA))
			    send_do(TELOPT_SGA, 1);
		    }
		}
		    /* Fall through */
	    case TELOPT_EOR:
#endif	    /* defined(TN3270) */
a251 6
#if	defined(AUTHENTICATION)
	    case TELOPT_AUTHENTICATION:
#endif
#if    defined(ENCRYPTION)
	    case TELOPT_ENCRYPT:
#endif
a280 4
#if    defined(ENCRYPTION)
	if (option == TELOPT_ENCRYPT)
		encrypt_send_support();
#endif
a314 5
#ifdef ENCRYPTION
	    case TELOPT_ENCRYPT:
		encrypt_not();
		break;
#endif
a359 3
#	if defined(TN3270)
	    case TELOPT_EOR:		/* end of record */
#	endif	/* defined(TN3270) */
a365 3
#if    defined(ENCRYPTION)
	    case TELOPT_ENCRYPT:        /* encryption variable option */
#endif
a369 10
#ifdef	OLD_ENVIRON
		if (my_state_is_will(TELOPT_OLD_ENVIRON))
			send_wont(TELOPT_OLD_ENVIRON, 1); /* turn off the old */
		goto env_common;
	    case TELOPT_OLD_ENVIRON:	/* Old environment variable option */
		if (my_state_is_will(TELOPT_NEW_ENVIRON))
			break;		/* Don't enable if new one is in use! */
	    env_common:
		telopt_environ = option;
#endif
a372 7
#if	defined(AUTHENTICATION)
	    case TELOPT_AUTHENTICATION:
		if (autologin)
			new_state_ok = 1;
		break;
#endif

a438 10
#ifdef	OLD_ENVIRON
	    case TELOPT_NEW_ENVIRON:
		/*
		 * The new environ option wasn't recognized, try
		 * the old one.
		 */
		send_will(TELOPT_OLD_ENVIRON, 1);
		telopt_environ = TELOPT_OLD_ENVIRON;
		break;
#endif
a647 5
#if	defined(TN3270)
	    if (tn3270_ttype()) {
		return;
	    }
#endif	/* defined(TN3270) */
a739 3
#ifdef	OLD_ENVIRON
    case TELOPT_OLD_ENVIRON:
#endif
a789 92
#if	defined(AUTHENTICATION)
	case TELOPT_AUTHENTICATION: {
		if (!autologin)
			break;
		if (SB_EOF())
			return;
		switch(SB_GET()) {
		case TELQUAL_IS:
			if (my_want_state_is_dont(TELOPT_AUTHENTICATION))
				return;
			auth_is(subpointer, SB_LEN());
			break;
		case TELQUAL_SEND:
			if (my_want_state_is_wont(TELOPT_AUTHENTICATION))
				return;
			auth_send(subpointer, SB_LEN());
			break;
		case TELQUAL_REPLY:
			if (my_want_state_is_wont(TELOPT_AUTHENTICATION))
				return;
			auth_reply(subpointer, SB_LEN());
			break;
		case TELQUAL_NAME:
			if (my_want_state_is_dont(TELOPT_AUTHENTICATION))
				return;
			auth_name(subpointer, SB_LEN());
			break;
		}
	}
	break;
#endif
#if    defined(ENCRYPTION)
	case TELOPT_ENCRYPT:
		if (SB_EOF())
			return;
		switch(SB_GET()) {
		case ENCRYPT_START:
			if (my_want_state_is_dont(TELOPT_ENCRYPT))
				return;
			encrypt_start(subpointer, SB_LEN());
			break;
               case ENCRYPT_END:
			if (my_want_state_is_dont(TELOPT_ENCRYPT))
				return;
			encrypt_end();
			break;
               case ENCRYPT_SUPPORT:
                        if (my_want_state_is_wont(TELOPT_ENCRYPT))
                                return;
			encrypt_support(subpointer, SB_LEN());
			break;
               case ENCRYPT_REQSTART:
                        if (my_want_state_is_wont(TELOPT_ENCRYPT))
			        return;
			encrypt_request_start(subpointer, SB_LEN());
			break;
               case ENCRYPT_REQEND:
                        if (my_want_state_is_wont(TELOPT_ENCRYPT))
                                return;
			/*
			 * We can always send an REQEND so that we cannot
			 * get stuck encrypting.  We should only get this
			 * if we have been able to get in the correct mode
			 * anyhow.
			 */
			encrypt_request_end();
			break;
               case ENCRYPT_IS:
                        if (my_want_state_is_dont(TELOPT_ENCRYPT))
                                return;
			encrypt_is(subpointer, SB_LEN());
			break;
               case ENCRYPT_REPLY:
		        if (my_want_state_is_wont(TELOPT_ENCRYPT))
                                return;
			encrypt_reply(subpointer, SB_LEN());
			break;
               case ENCRYPT_ENC_KEYID:
                        if (my_want_state_is_dont(TELOPT_ENCRYPT))
                                return;
                        encrypt_enc_keyid(subpointer, SB_LEN());
                        break;
               case ENCRYPT_DEC_KEYID:
                        if (my_want_state_is_wont(TELOPT_ENCRYPT))
                                return;
                        encrypt_dec_keyid(subpointer, SB_LEN());
                        break;
               default:
                        break;
               }
               break;
#endif
a952 1
#ifndef	SYSV_TERMIO
a953 1
#endif
a955 1
#ifndef	SYSV_TERMIO
a958 1
#endif
a960 4
#ifdef	SYSV_TERMIO
	spc_data[SLC_XON].mylevel = SLC_CANTCHANGE;
	spc_data[SLC_XOFF].mylevel = SLC_CANTCHANGE;
#endif
a961 1
#ifdef	USE_TERMIO
a963 1
#endif
a1217 20
#ifdef	OLD_ENVIRON
# ifdef	ENV_HACK
/*
 * Earlier version of telnet/telnetd from the BSD code had
 * the definitions of VALUE and VAR reversed.  To ensure
 * maximum interoperability, we assume that the server is
 * an older BSD server, until proven otherwise.  The newer
 * BSD servers should be able to handle either definition,
 * so it is better to use the wrong values if we don't
 * know what type of server it is.
 */
int env_auto = 1;
int old_env_var = OLD_ENV_VAR;
int old_env_value = OLD_ENV_VALUE;
# else
#  define old_env_var OLD_ENV_VAR
#  define old_env_value OLD_ENV_VALUE
# endif
#endif

a1232 19
#ifdef	OLD_ENVIRON
			case OLD_ENV_VAR:
# ifdef	ENV_HACK
				if (telopt_environ == TELOPT_OLD_ENVIRON
				    && env_auto) {
					/* Server has the same definitions */
					old_env_var = OLD_ENV_VAR;
					old_env_value = OLD_ENV_VALUE;
				}
				/* FALL THROUGH */
# endif
			case OLD_ENV_VALUE:
				/*
				 * Although OLD_ENV_VALUE is not legal, we will
				 * still recognize it, just in case it is an
				 * old server that has VAR & VALUE mixed up...
				 */
				/* FALL THROUGH */
#else
a1233 1
#endif
a1352 5
#ifdef	OLD_ENVIRON
		if (telopt_environ == TELOPT_OLD_ENVIRON)
			opt_add(old_env_var);
		else
#endif
a1372 5
#ifdef	OLD_ENVIRON
			if (telopt_environ == TELOPT_OLD_ENVIRON)
				opt_add(old_env_value);
			else
#endif
a1443 4
#if    defined(ENCRYPTION)
	if (decrypt_input)
                c = (*decrypt_input)(c);
#endif
a1462 13
#	    if defined(TN3270)
	    if (In3270) {
		*Ifrontp++ = c;
		while (scc > 0) {
		    c = *sbp++ & 0377, scc--; count++;
		    if (c == IAC) {
			telrcv_state = TS_IAC;
			break;
		    }
		    *Ifrontp++ = c;
		}
	    } else
#	    endif /* defined(TN3270) */
a1472 4
#if    defined(ENCRYPTION)
		    if (decrypt_input)
                        c = (*decrypt_input)(c);
#endif
a1481 4
#if    defined(ENCRYPTION)
			if (decrypt_input)
			    (*decrypt_input)(-1);
#endif
a1528 1
		settimer(gotDM);
a1535 15
#	    if defined(TN3270)
	    case EOR:
		if (In3270) {
		    if (Ibackp == Ifrontp) {
			Ibackp = Ifrontp = Ibuf;
			ISend = 0;	/* should have been! */
		    } else {
			Ibackp += DataFromNetwork(Ibackp, Ifrontp-Ibackp, 1);
			ISend = 1;
		    }
		}
		printoption("RCVD", IAC, EOR);
		break;
#	    endif /* defined(TN3270) */

a1536 1
#	    if !defined(TN3270)
a1537 7
#	    else /* !defined(TN3270) */
		if (In3270) {
		    *Ifrontp++ = IAC;
		} else {
		    TTYADD(IAC);
		}
#	    endif /* !defined(TN3270) */
a1551 1
	    SetIn3270();
a1557 1
	    SetIn3270();
a1563 1
	    SetIn3270();
a1578 1
	    SetIn3270();
a1611 1
		    SetIn3270();
a1622 1
		SetIn3270();
a1820 3
#if	defined(TN3270)
    ttyin = ring_empty_count(&ttyiring) && (clienteof == 0) && (shell_active == 0);
#else	/* defined(TN3270) */
a1821 1
#endif	/* defined(TN3270) */
a1822 3
#if	defined(TN3270)
    netin = ring_empty_count(&netiring);
#   else /* !defined(TN3270) */
a1823 1
#   endif /* !defined(TN3270) */
a1832 7
#   if defined(TN3270) && defined(unix)
    if (HaveInput) {
	HaveInput = 0;
	(void) signal(SIGIO, inputAvailable);
    }
#endif	/* defined(TN3270) && defined(unix) */

d1840 1
a1840 16
#   if defined(TN3270)
	if (In3270) {
	    int c;

	    c = DataFromTerminal(ttyiring.consume,
					ring_full_consecutive(&ttyiring));
	    if (c) {
		returnValue = 1;
		ring_consumed(&ttyiring, c);
	    }
	} else {
#   endif /* defined(TN3270) */
	    returnValue |= telsnd();
#   if defined(TN3270)
	}
#   endif /* defined(TN3270) */
a1843 1
#	if !defined(TN3270)
a1844 3
#	else /* !defined(TN3270) */
	returnValue = Push3270();
#	endif /* !defined(TN3270) */
a1857 13
#if	defined(AUTHENTICATION) || defined(ENCRYPTION)
    {
	static char local_host[256] = { 0 };

	if (!local_host[0]) {
		gethostname(local_host, sizeof(local_host));
		local_host[sizeof(local_host)-1] = 0;
	}
	auth_encrypt_init(local_host, hostname, "TELNET", 0);
	auth_encrypt_user(user);
    }
#endif	/* defined(AUTHENTICATION) || defined(ENCRYPTION) */
#   if !defined(TN3270)
a1858 8
#if	defined(AUTHENTICATION)
	if (autologin)
		send_will(TELOPT_AUTHENTICATION, 1);
#endif
#if    defined(ENCRYPTION)
	send_do(TELOPT_ENCRYPT, 1);
	send_will(TELOPT_ENCRYPT, 1);
#endif
a1871 1
#   endif /* !defined(TN3270) */
a1872 64
#ifdef ENCRYPTION
    /*
     * Note: we assume a tie to the authentication option here.  This
     * is necessary so that authentication fails, we don't spin
     * forever. 
     */
    if (wantencryption) {
	extern int auth_has_failed;
	time_t timeout = time(0) + 60;
	int printed_encrypt = 0;
	
	send_do(TELOPT_ENCRYPT, 1);
	send_will(TELOPT_ENCRYPT, 1);
	while (1) {
	    if (my_want_state_is_wont(TELOPT_AUTHENTICATION)) {
		if (wantencryption == -1) {
		    break;
		} else {
		    printf("\nServer refused to negotiate authentication,");
		    printf(" which is required for encryption.\n");
		    Exit(1);
		}
	    }
	    if (auth_has_failed) {
		printf("\nAuthentication negotiation has failed,");
		printf(" which is required for encryption.\n");
		Exit(1);
	    }
	    if (my_want_state_is_dont(TELOPT_ENCRYPT) ||
		my_want_state_is_wont(TELOPT_ENCRYPT)) {
		printf("\nServer refused to negotiate encryption.\n");
		Exit(1);
	    }
	    if (encrypt_is_encrypting())
		break;
	    if (time(0) > timeout) {
		printf("\nEncryption could not be enabled.\n");
		Exit(1);
	    }
	    if (printed_encrypt == 0) {
		printed_encrypt = 1;
		printf("Waiting for encryption to be negotiated...\n");
		/*
		 * Turn on MODE_TRAPSIG and then turn off localchars 
		 * so that ^C will cause telnet to exit.
		 */
		TerminalNewMode(getconnmode()|MODE_TRAPSIG);
		intr_waiting = 1;
	    }
	    if (intr_happened) {
		printf("\nUser interrupt.\n");
		Exit(1);
	    }
	    telnet_spin();
	}
	if (printed_encrypt) {
	    printf("Encryption negotiated.\n");
	    intr_waiting = 0;
	    setconnmode(0);
	}
    }
#endif
    
#   if !defined(TN3270)
a1887 39
#   else /* !defined(TN3270) */
    for (;;) {
	int schedValue;

	while (!In3270 && !shell_active) {
	    if (Scheduler(1) == -1) {
		setcommandmode();
		return;
	    }
	}

	while ((schedValue = Scheduler(0)) != 0) {
	    if (schedValue == -1) {
		setcommandmode();
		return;
	    }
	}
		/* If there is data waiting to go out to terminal, don't
		 * schedule any more data for the terminal.
		 */
	if (ring_full_count(&ttyoring)) {
	    schedValue = 1;
	} else {
	    if (shell_active) {
		if (shell_continue() == 0) {
		    ConnectScreen();
		}
	    } else if (In3270) {
		schedValue = DoTerminalOutput();
	    }
	}
	if (schedValue && (shell_active == 0)) {
	    if (Scheduler(1) == -1) {
		setcommandmode();
		return;
	    }
	}
    }
#   endif /* !defined(TN3270) */
@


1.19
log
@- only send exported vars (based on a diff from Solar Designer)
- fix some buffer overflows (also some Solar Designer input)

ok deraadt@@ cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.18 2003/11/08 19:17:29 jmc Exp $	*/
d1519 3
a1521 6
	if (opt_reply) {
		p = (unsigned char *)realloc(opt_reply, OPT_REPLY_SIZE);
		if (p == NULL)
			free(opt_reply);
	} else
		p = (unsigned char *)malloc(OPT_REPLY_SIZE);
d1524 1
a1524 1
/*@@*/		printf("env_opt_start: malloc()/realloc() failed!!!\n");
a2189 2
    int printed_encrypt = 0;

d2238 1
@


1.18
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.17 2003/10/04 10:18:05 jmc Exp $	*/
d449 1
a449 1
		if (env_getvalue((unsigned char *)"DISPLAY"))
d685 1
a685 1
		if ((tname = (char *)env_getvalue((unsigned char *)"TERM")) &&
d862 1
a862 1
	    if ((dp = env_getvalue((unsigned char *)"DISPLAY")) == NULL) {
d1334 10
a1343 2
unsigned char slc_reply[128];
unsigned char *slc_replyp;
d1349 4
a1352 4
	*slc_replyp++ = IAC;
	*slc_replyp++ = SB;
	*slc_replyp++ = TELOPT_LINEMODE;
	*slc_replyp++ = LM_SLC;
d1361 10
a1370 6
	if ((*slc_replyp++ = func) == IAC)
		*slc_replyp++ = IAC;
	if ((*slc_replyp++ = flags) == IAC)
		*slc_replyp++ = IAC;
	if ((*slc_replyp++ = (unsigned char)value) == IAC)
		*slc_replyp++ = IAC;
d1378 7
a1384 2
    *slc_replyp++ = IAC;
    *slc_replyp++ = SE;
d1502 4
a1505 4
#define	OPT_REPLY_SIZE	256
unsigned char *opt_reply;
unsigned char *opt_replyp;
unsigned char *opt_replyend;
d1508 7
d1533 4
a1536 4
	*opt_replyp++ = IAC;
	*opt_replyp++ = SB;
	*opt_replyp++ = telopt_environ;
	*opt_replyp++ = TELQUAL_IS;
d1568 3
a1570 3
	vp = env_getvalue(ep);
	if (opt_replyp + (vp ? strlen((char *)vp) : 0) +
				strlen((char *)ep) + 6 > opt_replyend)
d1572 1
a1572 1
		int len;
d1574 1
a1574 1
		opt_replyend += OPT_REPLY_SIZE;
d1576 3
d1580 1
a1580 1
		if (p == NULL)
a1581 2
		opt_reply = p;
		if (opt_reply == NULL) {
d1586 3
a1588 2
		opt_replyp = opt_reply + len - (opt_replyend - opt_replyp);
		opt_replyend = opt_reply + len;
d1593 1
a1593 1
			*opt_replyp++ = old_env_var;
d1596 1
a1596 1
			*opt_replyp++ = NEW_ENV_VAR;
d1598 2
a1599 1
		*opt_replyp++ = ENV_USERVAR;
d1604 1
a1604 1
				*opt_replyp++ = IAC;
d1610 1
a1610 1
				*opt_replyp++ = ENV_ESC;
d1613 1
a1613 1
			*opt_replyp++ = c;
d1618 1
a1618 1
				*opt_replyp++ = old_env_value;
d1621 1
a1621 1
				*opt_replyp++ = NEW_ENV_VALUE;
d1649 2
a1650 2
		*opt_replyp++ = IAC;
		*opt_replyp++ = SE;
d2227 1
a2227 1
	if (env_getvalue((unsigned char *)"DISPLAY"))
@


1.18.2.1
log
@MFC:
Fix by otto@@

- only send exported vars (based on a diff from Solar Designer)
- fix some buffer overflows (also some Solar Designer input)
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.18 2003/11/08 19:17:29 jmc Exp $	*/
d449 1
a449 1
		if (env_getvalue((unsigned char *)"DISPLAY", 0))
d685 1
a685 1
		if ((tname = (char *)env_getvalue((unsigned char *)"TERM", 0)) &&
d862 1
a862 1
	    if ((dp = env_getvalue((unsigned char *)"DISPLAY", 0)) == NULL) {
d1334 2
a1335 10
static unsigned char slc_reply[2 * SUBBUFSIZE];
static unsigned char *slc_replyp;

	unsigned char
slc_add(unsigned char ch)
{
	if (slc_replyp == slc_reply + sizeof(slc_reply))
		return ch;
	return *slc_replyp++ = ch;
}
d1341 4
a1344 4
	slc_add(IAC);
	slc_add(SB);
	slc_add(TELOPT_LINEMODE);
	slc_add(LM_SLC);
d1353 6
a1358 10
	if (slc_replyp + 6 >= slc_reply + sizeof(slc_reply)) {
		printf("slc_add_reply: not enough room\n");
		return;
	}
	if (slc_add(func) == IAC)
		slc_add(IAC);
	if (slc_add(flags) == IAC)
		slc_add(IAC);
	if (slc_add((unsigned char)value) == IAC)
		slc_add(IAC);
d1366 2
a1367 7
    if (slc_replyp + 2 >= slc_reply + sizeof(slc_reply)) {
	printf("slc_end_reply: not enough room\n");
	return;
    }

    slc_add(IAC);
    slc_add(SE);
d1485 4
a1488 4
#define	OPT_REPLY_SIZE	(2 * SUBBUFSIZE)
static unsigned char *opt_reply;
static unsigned char *opt_replyp;
static unsigned char *opt_replyend;
a1490 7
opt_add(unsigned char ch)
{
	if (opt_replyp == opt_replyend)
		return;
	*opt_replyp++ = ch;
}
	void
d1509 4
a1512 4
	opt_add(IAC);
	opt_add(SB);
	opt_add(telopt_environ);
	opt_add(TELQUAL_IS);
d1544 3
a1546 3
	vp = env_getvalue(ep, 1);
	if (opt_replyp + 2 * (vp ? strlen((char *)vp) : 0) +
				2 * strlen((char *)ep) + 6 > opt_replyend)
d1548 1
a1548 1
		size_t len;
d1550 1
a1550 1

a1551 3
		len += OPT_REPLY_SIZE + 2 * strlen(ep);
		if (vp)
			len += 2 * strlen(vp);
d1553 1
a1553 1
		if (p == NULL) {
d1555 2
d1561 2
a1562 3
		opt_replyp = p + (opt_replyp - opt_reply);
		opt_replyend = p + len;
		opt_reply = p;
d1567 1
a1567 1
			opt_add(old_env_var);
d1570 1
a1570 1
			opt_add(NEW_ENV_VAR);
d1572 1
a1572 2
		opt_add(ENV_USERVAR);

d1577 1
a1577 1
				opt_add(IAC);
d1583 1
a1583 1
				opt_add(ENV_ESC);
d1586 1
a1586 1
			opt_add(c);
d1591 1
a1591 1
				opt_add(old_env_value);
d1594 1
a1594 1
				opt_add(NEW_ENV_VALUE);
d1622 2
a1623 2
		opt_add(IAC);
		opt_add(SE);
d2200 1
a2200 1
	if (env_getvalue((unsigned char *)"DISPLAY", 0))
@


1.18.4.1
log
@MFC:
Fix by otto@@

- only send exported vars (based on a diff from Solar Designer)
- fix some buffer overflows (also some Solar Designer input)
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.18 2003/11/08 19:17:29 jmc Exp $	*/
d449 1
a449 1
		if (env_getvalue((unsigned char *)"DISPLAY", 0))
d685 1
a685 1
		if ((tname = (char *)env_getvalue((unsigned char *)"TERM", 0)) &&
d862 1
a862 1
	    if ((dp = env_getvalue((unsigned char *)"DISPLAY", 0)) == NULL) {
d1334 2
a1335 10
static unsigned char slc_reply[2 * SUBBUFSIZE];
static unsigned char *slc_replyp;

	unsigned char
slc_add(unsigned char ch)
{
	if (slc_replyp == slc_reply + sizeof(slc_reply))
		return ch;
	return *slc_replyp++ = ch;
}
d1341 4
a1344 4
	slc_add(IAC);
	slc_add(SB);
	slc_add(TELOPT_LINEMODE);
	slc_add(LM_SLC);
d1353 6
a1358 10
	if (slc_replyp + 6 >= slc_reply + sizeof(slc_reply)) {
		printf("slc_add_reply: not enough room\n");
		return;
	}
	if (slc_add(func) == IAC)
		slc_add(IAC);
	if (slc_add(flags) == IAC)
		slc_add(IAC);
	if (slc_add((unsigned char)value) == IAC)
		slc_add(IAC);
d1366 2
a1367 7
    if (slc_replyp + 2 >= slc_reply + sizeof(slc_reply)) {
	printf("slc_end_reply: not enough room\n");
	return;
    }

    slc_add(IAC);
    slc_add(SE);
d1485 4
a1488 4
#define	OPT_REPLY_SIZE	(2 * SUBBUFSIZE)
static unsigned char *opt_reply;
static unsigned char *opt_replyp;
static unsigned char *opt_replyend;
a1490 7
opt_add(unsigned char ch)
{
	if (opt_replyp == opt_replyend)
		return;
	*opt_replyp++ = ch;
}
	void
d1509 4
a1512 4
	opt_add(IAC);
	opt_add(SB);
	opt_add(telopt_environ);
	opt_add(TELQUAL_IS);
d1544 3
a1546 3
	vp = env_getvalue(ep, 1);
	if (opt_replyp + 2 * (vp ? strlen((char *)vp) : 0) +
				2 * strlen((char *)ep) + 6 > opt_replyend)
d1548 1
a1548 1
		size_t len;
d1550 1
a1550 1

a1551 3
		len += OPT_REPLY_SIZE + 2 * strlen(ep);
		if (vp)
			len += 2 * strlen(vp);
d1553 1
a1553 1
		if (p == NULL) {
d1555 2
d1561 2
a1562 3
		opt_replyp = p + (opt_replyp - opt_reply);
		opt_replyend = p + len;
		opt_reply = p;
d1567 1
a1567 1
			opt_add(old_env_var);
d1570 1
a1570 1
			opt_add(NEW_ENV_VAR);
d1572 1
a1572 2
		opt_add(ENV_USERVAR);

d1577 1
a1577 1
				opt_add(IAC);
d1583 1
a1583 1
				opt_add(ENV_ESC);
d1586 1
a1586 1
			opt_add(c);
d1591 1
a1591 1
				opt_add(old_env_value);
d1594 1
a1594 1
				opt_add(NEW_ENV_VALUE);
d1622 2
a1623 2
		opt_add(IAC);
		opt_add(SE);
d2200 1
a2200 1
	if (env_getvalue((unsigned char *)"DISPLAY", 0))
@


1.17
log
@negotation -> negotiation;
from Marc Balmer
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.16 2003/06/03 02:56:18 millert Exp $	*/
d1870 1
a1870 1
		     * have happend.  An IAC was not doubled, the
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.15 2002/03/22 13:49:28 hin Exp $	*/
d2230 1
a2230 1
		printf("\nAuthentication negotation has failed,");
@


1.15
log
@Telnet encryption warning messages, taken from kth-krb4-1.1.1.

(krb4-1.1.1 will be imported after release)

Noone bothered to look at this, but I've used this for a couple of weeks,
and i really want this to go in before release.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.14 2002/02/17 17:20:49 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14
log
@telnet used a P macro instead of __P -- g/c that too.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.13 2001/11/19 19:02:16 mpech Exp $	*/
d79 1
d95 2
d2116 5
d2170 2
d2211 62
@


1.13
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.12 2001/11/03 00:07:53 hin Exp $	*/
d541 1
a541 1
int is_unique P((char *, char **, char **));
@


1.12
log
@Telnet client shouldn't say it does Kerberos unless there actually exists
a krb4 or krb5 ticket file.
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.11 2000/11/10 15:33:13 provos Exp $	*/
d181 1
a181 1
    register int c, init;
d197 1
a197 1
    register int c, init;
d213 1
a213 1
    register int c, init;
d229 1
a229 1
    register int c, init;
d550 2
a551 2
	register int n;
	register char c, *cp, **argvp, *cp2, **argv, **avt;
d660 1
a660 1
	register char *name, **as, **ae;
d662 2
a663 2
	register char **ap;
	register int n;
d1112 1
a1112 1
	register struct spc *spcp;
d1223 1
a1223 1
    register struct spc *spcp;
d1246 1
a1246 1
	register unsigned char *cp;
d1249 2
a1250 2
	register struct spc *spcp;
	register int func,level;
d1317 1
a1317 1
    register struct spc *spcp;
d1365 1
a1365 1
    register int len;
d1382 1
a1382 1
	register struct spc *spcp;
d1419 2
a1420 2
	register unsigned char *buf;
	register int len;
d1422 2
a1423 2
	register unsigned char *ep = 0, *epc = 0;
	register int i;
d1526 1
a1526 1
	register unsigned char *ep;
d1528 1
a1528 1
	register unsigned char *vp, c;
d1549 1
a1549 1
		register int len;
d1617 1
a1617 1
	register int emptyok;
d1619 1
a1619 1
	register int len;
d1642 3
a1644 3
    register int c;
    register int scc;
    register unsigned char *sbp;
d1934 2
a1935 2
	register int sc;
	register int c;
d2285 1
a2285 1
	    register char *look = current+2;
d2322 1
a2322 1
    register char *thisitem, *next;
d2416 1
a2416 1
    register unsigned char *cp;
d2517 1
a2517 1
    register unsigned char *cp;
@


1.11
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.10 2000/10/24 21:52:38 millert Exp $	*/
d192 1
a192 1
    printoption("SENT", DO, c);
@


1.10
log
@When calling setupterm() pass in an int* for the error code so
it doesn't spew to stderr if the terminal type can't be found.

Fix a logic thinko wrt terminaltypeok() -- it should return 0 on failure,
not success.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.9 2000/10/10 15:41:11 millert Exp $	*/
d536 1
a536 1
 * This routine will turn a pipe seperated list of names in the buffer
@


1.9
log
@Use curses, not ocurses and thus setupterm() not tgetent().  This means
we no longer need to have a faked up telnet_setupterm().

Remove some unused variables and add missing err.h include in sys_bsd.c
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.8 1999/12/30 16:58:22 itojun Exp $	*/
d680 1
d687 1
a687 1
				(setupterm(tname, 1, NULL) == OK)) {
@


1.8
log
@avoid memory leak on realloc() failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.7 1999/07/23 15:04:48 aaron Exp $	*/
d38 2
d536 3
a538 4
 * Given a buffer returned by tgetent(), this routine will turn
 * the pipe seperated list of names in the buffer into an array
 * of pointers to null terminated names.  We toss out any bad,
 * duplicate, or verbose names (names with spaces).
d566 1
a566 1
	for (n = 1, cp = buf; *cp && *cp != ':'; cp++) {
a671 19
static char termbuf[1024];

	/*ARGSUSED*/
	int
telnet_setupterm(tname, fd, errp)
	char *tname;
	int fd, *errp;
{
	if (tgetent(termbuf, tname) == 1) {
		termbuf[1023] = '\0';
		if (errp)
			*errp = 1;
		return(0);
	}
	if (errp)
		*errp = 0;
	return(-1);
}

a679 1
	int err;
d686 2
a687 2
				(telnet_setupterm(tname, 1, &err) == 0)) {
			tnamep = mklist(termbuf, tname);
@


1.7
log
@Fix the case where telnet(1) would escape if in binary (-8) mode, even if the
-E option (stop all characters from being recognized as an escape character)
was specified, if it was passed a 0xFF character; from FreeBSD, millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.6 1998/07/27 15:29:29 millert Exp $	*/
d1512 9
a1520 4
	if (opt_reply)
		opt_reply = (unsigned char *)realloc(opt_reply, OPT_REPLY_SIZE);
	else
		opt_reply = (unsigned char *)malloc(OPT_REPLY_SIZE);
d1568 1
d1571 4
a1574 1
		opt_reply = (unsigned char *)realloc(opt_reply, len);
@


1.6
log
@don't include term.h
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.5 1998/05/15 03:16:43 art Exp $	*/
d1995 1
a1995 1
	} else if (sc == escape) {
@


1.5
log
@cleanup warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.4 1998/03/12 04:57:43 art Exp $	*/
a37 1
#include <term.h>
@


1.4
log
@encryption support from kth-krb 0.9.8 (kerberos only)
plus some tweaks for better binary/8-bit support.
@
text
@d1 1
a1 1
/*	$OpenBSD: telnet.c,v 1.3 1997/06/05 01:07:39 deraadt Exp $	*/
d38 1
d541 2
d785 1
a785 1
		     "%c%c%c%c%d,%d%c%c", IAC, SB, TELOPT_TSPEED,
@


1.3
log
@do not interpret _POSIX_VDISABLE as a special character; netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
a37 24
#ifndef lint
#if 0
static char sccsid[] = "@@(#)telnet.c	8.4 (Berkeley) 5/30/95";
static char rcsid[] = "$NetBSD: telnet.c,v 1.7 1996/02/28 21:04:15 thorpej Exp $";
#else
static char rcsid[] = "$OpenBSD$";
#endif
#endif /* not lint */

#include <sys/types.h>

#if	defined(unix)
#include <signal.h>
/* By the way, we need to include curses.h before telnet.h since,
 * among other things, telnet.h #defines 'DO', which is a variable
 * declared in curses.h.
 */
#endif	/* defined(unix) */

#include <arpa/telnet.h>

#include <ctype.h>

#include "ring.h"
d39 1
a39 7
#include "defines.h"
#include "externs.h"
#include "types.h"
#include "general.h"


#define	strip(x) ((my_want_state_is_wont(TELOPT_BINARY)) ? ((x)&0x7f) : (x))
d59 2
a60 1
	eight = 0,
a133 12

#ifdef	notdef
Modelist modelist[] = {
	{ "telnet command mode", COMMAND_LINE },
	{ "character-at-a-time mode", 0 },
	{ "character-at-a-time mode (local echo)", LOCAL_ECHO|LOCAL_CHARS },
	{ "line-by-line mode (remote echo)", LINE | LOCAL_CHARS },
	{ "line-by-line mode", LINE | LOCAL_ECHO | LOCAL_CHARS },
	{ "line-by-line mode (local echoing suppressed)", LINE | LOCAL_CHARS },
	{ "3270 mode", 0 },
};
#endif
d146 1
a146 1
    ClearArray(options);
d149 1
a149 1
#if	defined(AUTHENTICATION)
d151 1
a151 1
#endif	/* defined(AUTHENTICATION)  */
a168 50
#ifdef	notdef
#include <varargs.h>

    /*VARARGS*/
    static void
printring(va_alist)
    va_dcl
{
    va_list ap;
    char buffer[100];		/* where things go */
    char *ptr;
    char *format;
    char *string;
    Ring *ring;
    int i;

    va_start(ap);

    ring = va_arg(ap, Ring *);
    format = va_arg(ap, char *);
    ptr = buffer;

    while ((i = *format++) != 0) {
	if (i == '%') {
	    i = *format++;
	    switch (i) {
	    case 'c':
		*ptr++ = va_arg(ap, int);
		break;
	    case 's':
		string = va_arg(ap, char *);
		ring_supply_data(ring, buffer, ptr-buffer);
		ring_supply_data(ring, string, strlen(string));
		ptr = buffer;
		break;
	    case 0:
		ExitString("printring: trailing %%.\n", 1);
		/*NOTREACHED*/
	    default:
		ExitString("printring: unknown format character.\n", 1);
		/*NOTREACHED*/
	    }
	} else {
	    *ptr++ = i;
	}
    }
    ring_supply_data(ring, buffer, ptr-buffer);
}
#endif

d291 3
d323 5
d361 5
d420 3
d612 2
a613 1
		if ((c == ' ') || !isascii(c))
d669 1
a669 2
#ifdef	TERMCAP
char termbuf[1024];
d673 1
a673 1
setupterm(tname, fd, errp)
a686 4
#else
#define	termbuf	ttytype
extern char ttytype[];
#endif
d703 1
a703 1
				(setupterm(tname, 1, &err) == 0)) {
d758 3
a760 2
		sprintf((char *)temp, "%c%c%c%c%s%c%c", IAC, SB, TELOPT_TTYPE,
				TELQUAL_IS, name, IAC, SE);
d781 3
a783 2
	    sprintf((char *)temp, "%c%c%c%c%d,%d%c%c", IAC, SB, TELOPT_TSPEED,
		    TELQUAL_IS, ospeed, ispeed, IAC, SE);
d887 2
a888 1
	    sprintf((char *)temp, "%c%c%c%c%s%c%c", IAC, SB, TELOPT_XDISPLOC,
d931 61
d1139 1
a1139 1
					if (spcp->valp = tcval(func)) { \
d1547 1
a1547 1
		while (ep = env_default(0, 0))
d1552 1
a1552 1
		while (ep = env_default(0, 1))
d1572 1
a1572 1
	if (opt_welldefined(ep))
d1582 1
a1582 1
		while (c = *ep++) {
d1596 1
a1596 1
		if (ep = vp) {
d1673 4
d1711 1
a1711 1
		     * since we can't * set CRMOD on output only.
d1719 4
d1732 4
a1735 1

d2171 1
a2171 1
#if	defined(AUTHENTICATION)
d2182 1
a2182 1
#endif	/* defined(AUTHENTICATION)  */
d2189 4
d2203 2
a2204 2
	if (eight)
	    tel_enter_binary(eight);
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d2028 1
a2028 1
	if (MODE_LOCAL_CHARS(globalmode)) {
@


1.1
log
@Initial revision
@
text
@d1 3
d38 6
a43 2
/* from: static char sccsid[] = "@@(#)telnet.c	8.1 (Berkeley) 6/6/93"; */
static char *rcsid = "$Id: telnet.c,v 1.4 1995/03/17 18:03:10 mycroft Exp $";
d68 1
a68 1
#define	strip(x)	((x)&0x7f)
d189 1
a189 1
#if	defined(AUTHENTICATION) 
d625 1
a625 1
		if (strlen(name) > 40) {
d691 1
a691 1
	
d784 1
a784 1
			if (tname && (strlen(tname) <= 40)) {
d1759 1
a1759 1
	    
d2145 1
a2145 1
	        ring_consumed(&ttyiring, c);
d2174 1
a2174 1
#if	defined(AUTHENTICATION) 
d2352 1
a2352 1
	    memcpy(good, thisitem, length);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

